00:00:06 <pjdelport> Who needs these fancy "algorithms".
00:00:07 <orzo> i think you won
00:00:37 <pjdelport> Arahael: Literate Haskell is pretty cool.
00:00:48 <Arahael> But when I build it (It's nothing more than the main = print "hey", really), it has an error: /usr/bin/ld --hash-size=31: Unknown option
00:01:18 <Arahael> pjdelport: I'm hoping it's also practical. :)
00:01:28 <Arahael> pjdelport: And that it'll force me to think more about the code.
00:01:47 <pjdelport> Arahael: Well, you'll see many articles and blog posts and such written as literate Haskell.
00:01:54 <Arahael> So I'm wondering why "cabal build" is not calling ld properly.
00:02:18 <Arahael> I don't import anything, and I haven't edited the .cabal file significantly.
00:02:21 <pjdelport> It's very practical when your code lends itself to an exposition style.
00:02:33 <Arahael> pjdelport: And if it doesn't?
00:02:48 <Cale> Arahael: Apparently that's a problem with binutils-gold
00:02:51 <pjdelport> Then a traditional module is more appropriate. :)
00:02:58 <Arahael> Cale: How do I fix it?
00:03:10 <Cale> sudo apt-get remove binutils-gold  would be one way
00:03:14 <Arahael> pjdelport: I guess I should make that call once I get more familiar with it.
00:03:23 <Arahael> Cale: Any other ways? :)
00:03:26 <Cale> I don't know what the more permanent solution would be
00:03:44 <pjdelport> But you can always mix it; for example, have one literate Haskell file that methodically explains and introduces all your important concepts in prose style, and then have a plain Haskell file for boring helper and utility code.
00:04:25 <Cale> oh, here's a comprehensive answer: http://stackoverflow.com/a/13046709
00:04:32 <Arahael> Cale: Thanks.
00:05:24 * hackagebot system-canonicalpath 0.3.0.0 - Abstract data type for canonical paths with some utilities  http://hackage.haskell.org/package/system-canonicalpath-0.3.0.0 (d12frosted)
00:05:52 <johnw> I don't really get literate Haskell, since it's lacking what I see as the main feature of literate programming: the ability to extract parts of a function to another place in the file, with having to actually define another function.  .lhs files just invert comments and code
00:06:22 <Cale> Arahael: btw, which GHC version do you have?
00:06:38 <Cale> Arahael: I'm seeing some remarks that this shouldn't be necessary with GHC 7.8
00:07:34 <Arahael> Cale: Yikes. 7.4, as it turns out.
00:10:18 <Arahael> Aaand my 5 minutes is up.
00:10:20 <Arahael> Back after dinner!
00:13:31 <EvanR> huh. after fixing some problems it still hangs. but then i tried +RTS -N2 and it didnt hang
00:13:43 <orzo> > cycle "fizzbuzz 1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 "
00:13:44 <lambdabot>  "fizzbuzz 1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz 1 2 fizz...
00:13:52 <orzo> smallest fizbuz program, right here
00:15:13 <orzo> actually, our last two have bugs, the numbers are not incrementing beyond 14
00:15:40 <orzo> the version with the dots didnt have that issue
00:26:26 <Arahael> johnw: I did notice that.
00:27:26 <johnw> Arahael: in which case, a regular Haskell file is just a literate Haskell file using different syntax :)
00:28:49 <orzo> i don't really like literate style in any language
00:29:49 <Arahael> johnw: That's true, but I think it makes a difference that the .lhs files have slightly better formatting that encourages the commentary.
00:30:07 * Arahael wonders why activate.hs requires root.
00:30:08 <johnw> I just use {- ... -} to open a big block of text
00:30:18 <orzo> i prefer that
00:31:12 <orzo> haddock is awesome incidentally.  I think it's output is better looking than any similar tool for other languagges i've used
00:31:41 <Arahael> johnw: What about html generation of the docs?
00:32:01 <johnw> then use {- | ... -} :)
00:32:40 <Arahael> johnw: Where do I find those documented? :)
00:32:56 <orzo> https://www.haskell.org/haddock/doc/html/
00:33:05 <catsup> is there any tool i can use that will edit a haskell source file and add type annotations?
00:33:20 <orzo> yeah
00:33:42 <catsup> thanks.  i'll keep that in mind.
00:33:56 <liff> [exthelen@sterope ~]$ dzdo -u pamela ls
00:33:56 <liff> Sorry, user exthelen is not allowed to execute '/bin/ls' as pamela on sterope.
00:34:07 <liff> sorry, wrong paste
00:34:13 <liff> window
00:35:34 <orzo> i saw a script earlier that did something like echo ":t $v" | ghci -v0
00:35:47 <Arahael> Does the 2014 haskell platform not work on Debian?
00:36:08 <catsup> orzo: what about non-toplevel variables tho?
00:36:47 <orzo> ghc-mod then probably
00:36:54 <orzo> i was looking for something more minimal
00:36:56 <Arahael> cabal: /lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.14' not found (required by cabal)
00:37:26 <catsup> ghc-mod sounds like something i would use to implement a tool, rather than a tool :/
00:37:46 <orzo> http://www.mew.org/~kazu/proj/ghc-mod/en/
00:38:36 <Lokathor> Arahael, i've got several versions of the haskell platform installed on different debaians, it should be mostly fine
00:38:50 <orzo> if you set that up for vim, let me know how it goes, i haven't bothered
00:39:36 <Lokathor> stable, unstable, and experimental; went straight past testing to unstable, used experimental to get ghcjs built
00:40:26 * hackagebot test-sandbox 0.0.1.12 - Sandbox for system tests  http://hackage.haskell.org/package/test-sandbox-0.0.1.12 (yjkmy)
00:40:31 <Arahael> Lokathor: Well, I got that error trying to run cabal.
00:40:40 <Lokathor> fresh install?
00:40:50 <Arahael> Lokathor: Unpacked the tarball and then activated it, yes.
00:41:17 <Arahael> Lokathor: I'm about to delete it though, but haven't yet as I'm wondering what the responses here will be first.
00:41:31 <Lokathor> ah, hmm, a tarball? I've always used apt to make sure that my dependencies were covered
00:41:59 <Arahael> Lokathor: That's what's provided on haskell.org.  My system provides haskell, but it's verison 7.4
00:43:04 <Lokathor> yes, stable is quite old indeed
00:43:32 <Lokathor> if you're admin of the system you might consider moving to testing at least to install haskell
00:43:47 <Arahael> Lokathor: So stable's version is too old, and the haskell platform doesn't work.  Hmm, you really suggest moving to testing?
00:44:27 <Arahael> Lokathor: This is making it quite inconvenient to use haskell...  I don't want to deal with SELinux and all those systemd changes yet.
00:44:27 <Lokathor> unless it's a server for your business or something there's really no harm in debian testing compared to debian stable
00:44:51 <Arahael> Lokathor: Well, it's only a personal server, but it's Yet Another Thing to deal with.
00:46:01 <Arahael> Lokathor: Also, the platform clearly claims to support Debian 7.
00:46:47 <Lokathor> it does say that
00:46:56 <Lokathor> you could try updating just the one library it's looking for
00:47:07 <Arahael> Lokathor: Which just happens to be the libc?
00:47:29 <Lokathor> i can't say it won't complain about a second missing library if you fix libc
00:47:35 <Lokathor> but that might be the only missing thing
00:48:04 <Arahael> Lokathor: Updating the libc is usually a pretty serious update.
00:48:20 <Lokathor> officially from debian's point of view, even debian unstable is on the 2013 version of the haskell platform
00:49:23 <Lokathor> debian is sturdy as a titan, and slow as a titan
00:49:30 <Arahael> Lokathor: You're missing the point.
00:49:35 <catsup> i'm using haskell platform on debian stable
00:50:06 <Lokathor> yeah you can install via apt if you're fine with an older GHC, and cabal-install can update itself from there as well
00:50:21 <catsup> i mean i'm using the latest haskell platform
00:50:26 <Lokathor> oh!
00:50:36 <catsup> i installed it on several debian stable boxes
00:50:42 <Arahael> Lokathor: It's annoying and confusing to get haskell on this platform. Only haskell seems to have this problem. If this were python, and for some reason, the very latest is required, you'd just download the damn thing and compile it.
00:50:58 <catsup> there were some issues i had to fix to do so
00:51:11 <Lokathor> catsup, that seems to be the problem here as well
00:51:41 <catsup> i think.  or maybe that was just with pre-release versions
00:51:43 <Lokathor> arahael, you can install the older GHC and probably use it to build the newest haskell platform from source if you like
00:51:53 <Arahael> Lokathor: But here, Haskell is saying: "Hey, use this, it WORKS ON YOUR DEBIAN 7 PLATFORM", but it does not. When I go to the ghc download when I invariably give up on that, it says "STOP! Use the platform!"  From memory even when I ignore that warning I"m going to have a few more annoyances until I finally have a working cabal.
00:52:55 <Lokathor> yes, the trouble is that they're two totally different teams so they don't always communicate as well about the "message" peolpe should take from things
00:53:04 <Arahael> Lokathor: Again, you're missing the point.
00:53:25 <Arahael> Lokathor: The point I'm trying to make is that _regardless_ of the paths that are available, there should exist ONE path that freaking works.
00:53:26 <Lokathor> well, ignore what the GHC page says and just install GHC by itself if you want
00:54:08 <Arahael> Lokathor: I'm thinking I will. I'm just irritated that the "default" path is fundamentally broken.
00:54:09 <catsup> Arahael: do you have the debian haskell packages installed?
00:54:23 <Arahael> catsup: Yeah, I do, actually. It's Haskell 7.4 (And honestly, I'm thinking of just using that.)
00:54:48 <Lokathor> you can probably use 7.4 to build a newer version from source, like you suggested
00:55:07 <Arahael> Lokathor: I don't want "probably".
00:55:35 <Arahael> Lokathor: Haskell is a mature language. It should have mature installation instructions.
00:55:48 <catsup> 1st rule of software: nothing ever works
00:56:07 <Arahael> catsup: Heh, the well worn path should work, at least.
00:56:20 <Arahael> catsup: I can't remember another language I've used recently that had this difficulty.
00:56:24 <catsup> you might think i should, but then you're forgetting the 1st rule of software
00:56:25 <Lokathor> at this point i hesitate to make any promises, but i do know for a fact that you need GHC to build GHC so if you uninstall it entirely you won't be able to build it from source
00:56:51 <Arahael> Lokathor: You certainly can't build it from a broken 2014 platform.
00:56:53 <catsup> it*
00:57:16 <Cale> Arahael: What seems to be the difficulty?
00:57:27 <Cale> Arahael: Debian only has an old version of GHC?
00:57:53 <Arahael> Cale: I'm ranting, to be honest.  I'm frustrated that I would prefer to use the latest GHC, and while Debian only has 7.4, the haskell website should _clearly_ and _easily_ allow me to obtain haskell, even if it's from source.
00:57:57 <catsup> really the problem is that the platform should be distributed as binary packages
00:58:00 <Cale> Personally, I just ignore my distribution's packages when it comes to Haskell stuff, since it's usually out of date.
00:58:03 <Arahael> Cale: As it is, I went to the website, saw the download link.
00:58:04 <agocorona> Arahael:  do you want to ruin the software industry? If every mature platfom just works that should endanger thounsands of people´s jobs
00:58:21 <Cale> Arahael: There are downloads for binaries of GHC on the GHC website
00:58:23 <Arahael> Cale: And followed the instructions there. They specifically state they support Debian 7, yet it doesn't.
00:58:28 <Cale> which is what I tend to use
00:58:28 <catsup> Cale: but not the platform
00:58:43 <Lokathor> Cale: debian stable repo is the 2012 platform, and testing and unstable are both 2013, and only experimental repo is 2014
00:59:02 <Cale> https://www.haskell.org/ghc/download_ghc_7_8_4#x86_64linux
00:59:22 <Arahael> agocorona: Most mature platforms do tend to work.
00:59:31 <Cale> Just get whichever package is appropriate from there (not source, since you're not hacking on GHC, and you don't want to waste a whole bunch of time)
00:59:45 <catsup> theyr'e also annoying non-fhs-compliant tarballs instead of packages
00:59:52 <Arahael> Cale: Yes, but I used the most obvious links - and they did waste my time.
01:00:08 <Arahael> catsup: I did notice that too, I was willing to overlook those if they worked.
01:00:27 <Cale> and then grab the cabal install tarball from here: http://hackage.haskell.org/package/cabal-install
01:00:27 <catsup> Arahael: i understand your frustration.  but you realize this channel is not a paid IT support line for haskell incorporated, right?
01:01:03 <Cale> that contains a bootstrap.sh script which can get cabal-install installed at which point you don't really need the Platform, since you can just cabal install anything on Hackage.
01:01:22 <Arahael> catsup: I'm aware, however this channel is a semi-official support channel for haskell.  It's #haskell, not ##haskell.
01:01:47 <Lokathor> i don't know what the extra # indicates
01:01:47 <Arahael> Cale: I'll have to try that another day - I'm out of time to do anything productive. :(
01:01:59 <Arahael> Lokathor: The extra '#' indicates an "about" channel.
01:02:16 <Lokathor> honestly there's not much reason to use the platform if you're on linux, just get the parts you need
01:02:20 <Cale> Arahael: The Platform tends to be the right answer if you're on Windows or Mac OS, but on Linux, I tend to just skip it, because installing things manually is straightforward.
01:02:23 <catsup> Arahael: ok, but emphasis on "not a paid IT support line"...  i mean you're complaining here that it should just work...  but all we can do is agree -- indeed, it should just work!  alas, it never does.
01:02:29 <Cale> (and usually more up to date)
01:02:33 <Arahael> Cale: Yeah. I just made the mistake and then had to vent.
01:03:38 <Cale> Lokathor: Yeah, freenode has this wacky convention that if you only have one # then you're an "official" channel, whatever that means
01:03:43 <Arahael> catsup: Please, do find me one single language that is commmonly used, and is well supported on the platforms they support.
01:04:03 <Lokathor> i should probably stay logged into #lokathor then :P
01:04:12 <Arahael> catsup: Tip: Even Embarcadero's Delphi works, albiet in a crashy fashion, on Windows, which is the only platform they support.
01:04:22 <Cale> Lokathor: Well, you need an open source project associated with the name
01:04:36 <catsup> Cale: official channel means that the people who 'own' the name (as adjudicated by freenode) can take over the channel via bot
01:04:45 <Lokathor> ah, well, i'm a propriatary project unfortunately
01:04:50 <catsup> or via chanserv, rather
01:06:00 <Lokathor> Arahael, for years python didn't officially have a windows build, and the build and installer were provided by outside the organization.
01:06:08 <Lokathor> if you'll accept that as an example
01:06:38 <Arahael> Lokathor: Yes, that is fairly true.  When they did have an official version for windows though - did it install and run?
01:07:01 <Lokathor> ...as long as there weren't spaces in the path name, which would mess up libraries a lot of the time
01:07:15 <Arahael> Lokathor: That's widely known to be a commmon issue with dev projects.
01:07:23 * catsup offers Arahael a full refund
01:07:36 <Arahael> Lokathor: Many experienced devs would overlook that, like not using fhs conventions in the haskell tarballs.
01:12:15 <Arahael> Anyway.
01:12:36 <speak> The Haskell tarballs don't use the fhs conventions?
01:13:07 <Arahael> speak: Not the 2014 platform, no.
01:13:22 <Arahael> speak: They unpack directly to usr/local/haskell/whatever.
01:14:33 <speak> Ah, I see
01:15:27 * hackagebot uhc-util 0.1.4.0 - UHC utilities  http://hackage.haskell.org/package/uhc-util-0.1.4.0 (AtzeDijkstra)
01:30:28 * hackagebot vinyl-utils 0.1.0.1 - Utilities for vinyl  http://hackage.haskell.org/package/vinyl-utils-0.1.0.1 (mjmrotek)
01:30:33 <Arahael> Cale: Incidentally, for my own reference next time, do you know if there is a clear, simple, set of instructions for setting up a haskell system?
01:31:58 <merijn> Arahael: It depends on what sorta programming you wanna do. For example, Yesod is a lot more brittle (due to it's large dependency tree) than, say, standalone systems programming
01:33:18 <Arahael> merijn: At this point in time, just regular systems programming is what I'm interested in.
01:35:29 * hackagebot type-list 0.0.0.1 - Operations on type-level lists and tuples.  http://hackage.haskell.org/package/type-list-0.0.0.1 (mjmrotek)
01:35:31 <tdammers> merijn: isn't that somewhat ironic though? Yesod, the web framework that tries to make everything type-safe and robust, ends up being brittle on the dependency front?
01:35:33 <merijn> Arahael: Then either grabbing the platform (on OSX/windows) or just grabbing GHC + cabal should be sufficient
01:35:38 <Arahael> merijn: In the past I tried to use the system haskell - ie, what was included in Debian, but I kept running into package inconsistencies.
01:35:46 <merijn> You can then just install everything using cabal
01:36:20 <Arahael> merijn: I am currently doing that.  I've managed to find http://www.extellisys.com/articles/haskell-on-debian-wheezy which looks to be suitable.
01:36:39 <merijn> Arahael: Well, one problem is that the ecosystem moves rather fast so using the "newest" thing may not have settled down to work with everything in the platform. The best way to do that is to use cabal sandboxes whenev you need newer libraries
01:37:03 <Arahael> merijn: It's a bit bewildering for a new haskell user.
01:37:24 <merijn> Arahael: Sandboxes basically restrict build/installed libraries to the current project, so if your newer libraries conflict what's installed on your system that doesn't end up being a problem
01:37:39 <Arahael> merijn: And sandboxes haven't saved me here.  'cabal sandbox', 'cabal install cabal-install' still breaks if you're using too old a ghc.
01:38:05 <merijn> What does "breaks" mean here?
01:38:56 <Arahael> merijn: I don't have the error message anymore, however I don't think the very latest cabal works with ghc 7.4
01:39:30 <merijn> Arahael: That doesn't surprise me at all, 7.4 is fairly ancient
01:39:40 <Arahael> Wait, it does. (I've since deleted my ~/.ghc and ~/.cabal, so maybe that fixed it)
01:40:26 <Arahael> merijn: I am aware. :)  It's the version that comes with Debian.
01:40:55 <merijn> Arahael: I would personally just grab the linux binaries of GHC from the GHC site :)
01:41:43 <Arahael> merijn: Yes, I'm currently doing that. After wasting a good 30 minutes getting the platform (as the site clearly recommends)
01:42:25 <merijn> Arahael: I'm not a big fan of recommending platform for linux since most of them either bollocks with the distribution or have you compile it from scratch (mostly defeating the point IMO)
01:42:44 <merijn> It works best as a precompiled binary distribution, but I'm not aware of any linux distro shipping it as such
01:43:40 <Arahael> merijn: Yes, I did then look into the so-called "source" version, as well.
01:45:02 <Arahael> ghc 7.8.4 works nicely - just installed it! :)
01:45:05 <merijn> Arahael: It's just a set of "blessed" packages, which you can just as easily install on demand via cabal :)
01:45:52 <Arahael> merijn: Yeah, except those "blessed" packages didn't support the one platform that it was supposed to support, so I spent a fair bit of time ranting about it. (As I was annoyed0
01:46:31 * Arahael is now cabal install cabal-install'ing now.
01:46:49 <merijn> Don't forget to update your PATH, cabal doesn't install to the system path
01:47:07 <merijn> Else you'll be like all other confused beginners "I just updated and it says I should update?!"
01:47:19 <merijn> ~/.cabal/bin or something along those lines on linux
01:47:49 <Arahael> merijn: Yep, I remember that.
01:48:24 <merijn> ok, time to teach class
01:48:26 <Arahael> 12 more minutes before I must get to bed. :)
01:48:30 <Arahael> merijn: Enjoy. :)
01:50:55 <Arahael> Cale: I seem to have quietened down now, though a bit depressed about the situation.  7.8.4's now working nicely.
01:51:54 <Cale> Arahael: Yeah, it could definitely be better. I'm not entirely sure why there isn't just an easy generic binary Haskell Platform for Linux installer.
01:52:46 <Cale> oh, there sort of is
01:53:04 <Cale> What problem did you have with it?
01:53:52 <Arahael> Cale: ghc binaries itself works fine, although the 32-bit version didn't work at all, but I can't remember if I have hte 32-bit support installed anyway.
01:54:08 <Arahael> Cale: The problem I had with the haskell platform was that the GLIBC was incompatible.
01:54:16 <Cale> ah, okay
01:54:25 <Cale> Well, not much can be done about that apart from making more packages
01:55:18 <Arahael> Arguably. The easiest way to fix it would be to rebuild the platform - using the oldest platform they want to support.
01:55:55 <Cale> Well, compiling GHC takes forever and requires a working GHC
01:56:13 <Arahael> Cale: Don't even need to recompile GHC, that bit's fine.  Just recompile cabal.
01:56:22 <Cale> Ah, I suppose.
01:56:39 <Arahael> Cale: It was cabal that was broken, although most of the other packages would probably be broken, too.
01:57:35 <Cale> That's really interesting actually, that ghc itself would work, but the cabal-install binary wouldn't.
01:57:46 <Cale> I'd expect them to depend on essentially the same C libraries.
01:57:48 <breadmonster> Cale: Can you explain to me how the Haskell stack works?
01:58:03 <zq> pancakes
01:58:13 <Cale> breadmonster: Oh, the evaluation stack?
01:58:22 <breadmonster> Cale: Aye.
01:58:34 <Arahael> Cale: I'm assuming that the haskell platform uses the ghc binaries.
01:58:38 <breadmonster> "pattern matching stack" sounds counterintuitive.
01:58:53 <Cale> breadmonster: It pretty much consists of the pattern matches which are waiting for their scrutinee to be sufficiently evaluated to match a pattern.
01:59:35 <breadmonster> Cale: Is this in the RTS or the compiler?
01:59:51 <danilo2> Hello! I'm trying to use CloudHaskell and I've got a very simple problem. Namely I've got a slave working on a specific address and I want to create connection from the master node to the one basing on the tcp address. In the docs and examples there are examples showing how to connect between nodes when forking processes, but I cannot just find function to connect to remote nodes. Have anyone used CH before and could give me any hin
02:00:06 <Cale> It's an interpretation for what looks like a call stack if you're observing everything from a lower level.
02:00:22 <mniip> danilo2, your message cut off after "could give me any hin"
02:00:51 <danilo2> mniip: Oh, but there was not much cutted of : "Could you give me any hint please?" :)
02:01:02 <Cale> breadmonster: and this is in the binary executables which are being produced, not necessarily the RTS code itself which is packaged with them
02:01:19 <Cale> breadmonster: Or at runtime, if you like
02:01:35 <Cale> I suppose it also applies to interpreted code
02:02:35 <Cale> breadmonster: There is another case where you can put something on the stack: evaluating an application f x will wait on the stack for f to be evaluated.
02:02:50 <Cale> breadmonster: i.e. up until f turns into a lambda abstraction
02:03:16 <Cale> (which will be represented at runtime by a closure)
02:03:56 <mniip> so I was experimenting with monadic versions of user-supplied comparison functions from Data.List
02:04:01 <Cale> but I have never seen a case outside of contrived programs where that sort of entry on the stack caused an overflow
02:04:15 <mniip> and got some rather interesting results
02:04:28 <mniip> @let maximumByM cmp (x:xs) = foldM maxByM x xs where maxByM x y = do { r <- cmp x y; case r of GT -> return x; _ -> return y}
02:04:31 <lambdabot>  Defined.
02:04:32 <Cale> breadmonster: Is everything clear? Would you like an example?
02:04:33 <mniip> > minimumByM (\_ _ -> [GT, LT]) "fedcba"
02:04:34 <lambdabot>  Not in scope: ‘minimumByM’
02:04:34 <lambdabot>  Perhaps you meant one of these:
02:04:34 <lambdabot>    ‘F.minimumBy’ (imported from Data.Foldable),
02:04:47 <mniip> > maximumByM (\_ _ -> [GT, LT]) "fedcba"
02:04:49 <lambdabot>  "fabacabadabacabaeabacabadabacaba"
02:05:02 <Cale> heh
02:05:08 <jle`> heh
02:05:09 <breadmonster> Cale: I got that, thanks a ton (:
02:05:29 <mniip> heh intensifies
02:05:39 <jle`> maximumBy is a little useless if you don't preserve ordering
02:05:55 <Cale> It's trying all possible orderings... sort of
02:05:59 <jle`> if a > b and b > c does not imply a > c, then maximumBy is not going to give you anything useful ;)
02:05:59 <mniip> I gues such functions are only useful with m ~ IO
02:06:07 <jle`> no, it's just as bad with IO
02:06:09 <Cale> Yeah, that's true
02:06:24 <Cale> You'd prefer to make consistent choices there
02:06:35 <mniip> oh you haven't seen the outcomes of sortByM :P
02:06:40 <Cale> mniip: m ~ Maybe could also be useful?
02:06:42 <mniip> although insertByM does make sense
02:06:47 <jle`> yeah, your list monad case will basically consider the possibilities when a > b, b > c, and a < c
02:07:55 <mniip> no wait, there is one use
02:08:00 <mniip> > maximumByM (\_ _ -> [GT, LT]) "ehhh"
02:08:01 <lambdabot>  "ehhhhhhh"
02:08:28 <nshepperd_> maximumOnM seems like it would be more useful
02:09:04 <mniip> what would that do? (can't find maximumOn)
02:09:56 <jle`> m ~ Maybe sounds like it would give sane/meaningful results
02:10:26 <nshepperd_> Ord b => (a -> b) -> [a] -> a
02:10:51 <nshepperd_> Er, that would be maximumOn
02:11:00 <mniip> so instead of a comparator we supply a key?
02:11:07 <mniip> yeah I get the M part
02:11:29 <jle`> yeah that does sound like it'd be reasonable
02:11:57 <jle`> i remember seeing a reddit post where the person implemented maximumBy with IO by using unsafePerformIO
02:12:08 <jle`> they used it to query the user for every comparison as it was requested for
02:12:15 <jle`> it stirred interesting feelings
02:12:27 <jle`> er, s/implemented/used
02:12:43 <nshepperd_> Hah
02:13:35 <jle`> i think it was a demo from a new user excited at how they could make a useful program in haskell
02:13:45 <nshepperd_> I think *On functions seem more useful generally, they should really be in base
02:13:55 <jle`> like a "look, i finally got the hang of this haskell thing!"
02:14:13 <nshepperd_> Keyed maximum, minimum, sort, etc
02:14:16 <jle`> nshepperd_: i'm surprised they aren't, actually
02:14:19 <jle`> i use them all the time...
02:14:31 <jle`> or well, i crudely re-implement them all the time
02:15:04 <jle`> using map/zip and sortBy
02:20:33 <nshepperd_> Hmm, you could actually implement a decent random shuffle using sortOnM
02:21:05 <jle`> yeah, it's the one that i always use v.v
02:21:10 <nshepperd_> Well, unbiased, but really slow
02:24:17 <mniip> uhh
02:24:21 <mniip> are all Monad's Functor's?
02:24:30 <mniip> can I safely fmap over a monad?
02:24:40 <merijn> mniip: Theoretically yes, in practice not yet
02:24:43 <nshepperd_> They will be in 7.10
02:24:43 <jle`> > map fst . sortBy (comparing snd) . zip [1..10] . randoms . mkStdGen $ 10
02:24:45 <lambdabot>  [2,5,8,4,1,3,10,6,7,9]
02:24:55 <merijn> mniip: In 7.10 Monad will get Applicative as superclass (which has Functor as superclass)
02:25:00 <jle`> ^ that's the shuffle, woo hoo
02:25:14 <merijn> mniip: In practice, most (all?) Monad instance should already be Functor
02:25:15 <merijn> Compare
02:25:17 <merijn> :t fmap
02:25:18 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:25:18 <jle`> mniip: if you are thinking about a specific Monad, then in modern practice, yes
02:25:19 <merijn> :t liftM
02:25:19 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
02:25:26 <fujimura> Anybody knows why mempy returns () in ghci?
02:25:31 <mniip> liftM it is then
02:25:37 <merijn> fujimura: Extended defaulting
02:25:40 <jle`> if your question is, "i have this monad M, can i safely use fmap on it?" => the answer is most liekly yes
02:26:00 <jle`> if your question is "if i am writing a function that is supposed to polymorphic/generic for all instances of Monad", then the answer is no
02:26:15 <merijn> fujimura: If it can't figure out what type you want (i.e., you try to print a polymorphic value) it has to select one type to know which "show" to use
02:26:23 <merijn> fujimura: And ghci happens to default to ()
02:27:01 <jle`> *the answer is no, for now
02:27:03 <merijn> fujimura: Specify the type you intend to use if you want something more sensible :) i.e. "mempty :: [a]
02:27:10 <merijn> > mempty :: [a]
02:27:12 <lambdabot>  []
02:27:16 <nshepperd_> Fisher Yates shuffle is better of course, but it shows what *On can do
02:27:16 <merijn> > mempty :: ()
02:27:17 <lambdabot>  ()
02:27:28 <jle`> there's actually a name for this shuffle i think
02:27:50 <jstolarek> os there a way I can prevent backtracking in a list comprehension?
02:28:15 <merijn> jstolarek: Backtracking?
02:28:27 <jstolarek> here's an example
02:28:28 <jle`> jstolarek: can you show an example of something you want to prevent?
02:28:33 <jle`> hooray
02:29:12 <bezirg> question on haskell module system:   module M where is equivalent to module (module M) where    ?
02:29:16 <jstolarek> [(a,b,c) | a <- [1..], b <- [1..], STOP_BACKTRACKING_HERE, c <- [1..2]]
02:29:31 <jstolarek> I want this to return [(1,1,1),(1,1,2)]
02:29:37 <bezirg> sry I meant: module M where  ===   module M (module M) where
02:29:39 <merijn> jstolarek: You could use parallel list comprehensions
02:29:42 <fujimura> merijn: Thanks!
02:29:54 <jstolarek> meroijn: no, I couldn't :-)
02:29:55 <merijn> jstolarek: Maybe...
02:30:02 <merijn> jstolarek: Otherwise, no you can't
02:30:10 <jstolarek> :-(
02:30:12 <jstolarek> oh well
02:30:22 <jstolarek> of course I know a way of implementing what I want
02:30:25 <Zoetrope_> I'm confused why you'd want that
02:30:27 <jstolarek> but it won't be elegant
02:30:34 <merijn> zipWith?
02:30:34 <jle`> i'm not sure what is meant by "here", but
02:30:41 <tdammers> me neither
02:30:58 <Zoetrope_> I mean your previous example is map (1,1,) [1,2] really
02:31:08 <jle`> i'm not totally sure how to get your result from your example
02:31:10 <merijn> > [f c | f <- zipWith (,,) [1..] [1..], c <- [1..2]]
02:31:12 <lambdabot>  [(1,1,1),(1,1,2),(2,2,1),(2,2,2),(3,3,1),(3,3,2),(4,4,1),(4,4,2),(5,5,1),(5,...
02:31:18 <merijn> oh, wait, no
02:32:06 <jle`> jstolarek: can you give another example? i'm just not getting it, sorry
02:32:12 <merijn> jstolarek: ZipList applicative?
02:32:41 <hamid> lambdabot, i love you :P
02:32:43 <tdammers> maybe provide a better description of the problem you want to solve, instead of only giving the solution that doesn't work and a trivial example
02:32:56 <jstolarek> jle`: I could show you the actual code, but I don;t think this will make things clearer
02:33:03 <jle`> how about a less trivial example
02:33:05 <jstolarek> so I'll try to exmplain with words
02:33:19 <jle`> code could possibly be better
02:33:23 <jstolarek> I have a list comprehension with matches that check for some condtions
02:34:05 <tdammers> take one step back. forget about list comprehensions. you have three lists that you need to combine into one list of triples - what are the rules for this?
02:34:05 <jstolarek> once I find the first set of "solutions" that match these conditions I want to use them to generate stuff in a further part of list comprehension
02:34:46 <jstolarek> http://lpaste.net/119931
02:34:52 <jstolarek> Ok, I'll try with the actual code
02:35:02 <jstolarek> fromBranchList produces a list
02:35:21 <jstolarek> from elements of that list I construct a subst
02:35:32 <jstolarek> once I have a subst I use zip3
02:35:41 <jstolarek> what I want is to use only the first subst I find
02:35:53 <jstolarek> and ignore all the remaining ones that might come later
02:36:28 <jtanguy> exploit the laziness maybe?
02:37:43 <jstolarek> this is orthiogonal
02:37:55 <jstolarek> I will be exploiting lziness here
02:38:10 <jstolarek> but I'm trying to find an elegant solution
02:38:23 <mniip> @let maximumOnM k (x:xs) = do {kx <- k x; liftM fst $ foldM (\(x, xk) y -> do { yk <- k y; if yk < xk then return (x, xk) else return (y, yk)}) (x, kx) xs}
02:38:26 <lambdabot>  Defined.
02:38:43 <mniip> nshepperd, what now
02:39:30 <jle`> > maximumOnM (\_ -> [LT, GT]) "abcdef"
02:39:32 <lambdabot>  "ffefdfefcfefdfefbfefdfefcfefdfefafefdfefcfefdfefbfefdfefcfefdfef"
02:39:56 <mniip> Ordering is quite a bad example of Ord
02:40:28 <jle`> heh
02:40:57 <jle`> the answer is interesting though
02:41:05 <mniip> this thing can emulate last!
02:41:07 <jle`> the only time `a` will be the result is if a is GT and the rest are LT
02:41:18 <mniip> > maximumOnM (const [()]) "hello world"
02:41:20 <lambdabot>  "d"
02:42:00 <mniip> that's not actually last...
02:42:03 <mniip> (:[]).last
02:43:10 <mniip> but yeah again, maximumOnM is of little use outside IO
02:44:15 <jle`> > evalState (maximumOnM (\_ -> state random) "abcdef") (mkStdGen 10)
02:44:17 <lambdabot>  'f'
02:44:19 <jle`> > evalState (maximumOnM (\_ -> state random) "abcdef") (mkStdGen 100)
02:44:21 <lambdabot>  'c'
02:44:27 <jle`> pick an element at random :)
02:44:31 <mniip> > maximumOnM (\x -> [-fromEnum x, fromEnum x]) "hello"
02:44:33 <lambdabot>  "eolololoeolololoholololoholololo"
02:44:58 <jle`> > evalState (maximumOnM (\_ -> state random) ["cat","dog","mouse","bird","hamster"]) (mkStdGen 100)
02:44:59 <lambdabot>  "mouse"
02:45:08 <mniip> fancy
02:45:22 <mniip> now how about something actually using the argument?
02:45:23 <jle`> and it's unbiased too
02:52:23 <mniip> well one thing I could think of
02:52:25 <mniip> getDirectoryContents "." >>= maximumOnM (liftM fileSize . getFileStatus)
02:57:33 <jle`> nice :)
02:57:52 <jle`> hm
02:58:10 <jle`> Arrow is really weird to me.  i feel like it's trying to claim to represent one thing but really represents another
02:58:28 <jle`> (f *** g) =/= first f . second g =/= second g . first f
02:58:44 <jle`> seems to basically kill the idea of what Arrow is supposed to represent in the first place
02:58:47 <jle`> oh well
02:59:15 <jle`> i mean, those aren't true for any noncommutative kleisli
02:59:27 <saep> Control.Arrow provides nice tuple functions.
02:59:30 * saep ducks.
02:59:46 <jle`> yeah, it does, but it might not be the best place to get your tuple functions
03:00:05 <jle`> idk, in order for arrow to really work in a way that matches intuition, those laws really should hold, but
03:00:16 <jle`> i guess they wanted a more general solution?
03:00:24 <jle`> i guess that's why arrow is more or less abandonded.
03:01:35 <jle`> the intuition they are trying to invoke is nice but the laws don't really hold to the intuition
03:01:39 <jle`> so why
03:07:11 <dibblego> jle`: just use profunctor
03:08:46 <mniip> why does lens insist on stab'ing xD
03:17:25 <nerium> Is there a way to make two lists equally long?
03:17:28 <jle`> dibblego: yeah, but we can't use that with proc notation yet ;_;
03:17:55 <jle`> nerium: unzip (zip xs ys) ?
03:18:03 <dibblego> notation schmotation
03:18:37 <tdammers> unzip . zip is surprisingly elegant :P
03:18:43 <nerium> jle`: Hmm, that didin't work
03:19:07 <tdammers> nerium: it works though... it cuts the longer list to the length of the shorter one
03:19:33 <tdammers> > (unzip . zip) [1,2,3] ["foo", "bar", "baz", "quux" ]
03:19:35 <lambdabot>  Couldn't match expected type ‘[[GHC.Types.Char]] -> t’
03:19:35 <lambdabot>              with actual type ‘([a0], [b0])’Couldn't match type ‘[b1] -> [(a1...
03:19:35 <lambdabot>  Expected type: [a1] -> [(a0, b0)]
03:19:45 <tdammers> hmm
03:19:53 <nerium> tdammers: I wanted to make them as long as possible
03:19:59 <nerium> maybe add some padding
03:20:08 <tdammers> oh, right so you want to pad the shorter one to match the longer
03:20:26 <jle`> maybe you were thinking of (.:), tdammers ?
03:22:17 <jameseb> nerium: maybe infinitely padding the shorter one then trying something similar to unzip . zip would work
03:22:26 <nerium> I'll try it, thanks!
03:22:48 <jameseb> that assumes you start knowing which one is shorter
03:24:01 <jameseb> depending on what you're trying to do you could just append infinite lists to both and work lazily with the new infinite lists
03:30:37 <jle`> this is a problem that I am sure has some nice solution that only traverses both lists once but I haven't found it yet
03:30:50 <jle`> of course the hand rolled explicit recursion solution exists
03:33:23 <dibblego> data These a b = This a | That b or Both a b; align :: [a] -> [b] -> These a b -- to zip, taking alignment into consideration
03:33:47 <dibblego> https://hackage.haskell.org/package/these-0.4.2/docs/Data-These.html
04:06:07 <LnL> Has anybody here used https://github.com/mietek/halcyon
04:09:40 <Profpatsch> Can I add another monadic context to ghci?
04:09:52 <Profpatsch> e.g. a state monad that holds an open socket?
04:11:02 <drewbert> so let's say I've got a cabal sandbox, but I've got another package I've been rolling on my system, and I want to install it into that sandbox, how do I go about that?
04:11:18 <Profpatsch> drewbert: nixOS :P
04:11:59 <tdammers> drewbert: you can cabal install into a sandbox from outside by specifying a local filesystem path instead of a package name
04:12:20 <tdammers> cd /where/my/sandbox/at; cabal install ~/some/other/package
04:12:44 <tdammers> and once installed, cabal will use it like any other "already installed" package when resolving dependencies
04:13:33 <bergmark> and there's also --sandbox-config-file
04:16:15 <drewbert> tdammers: I was hoping it was something like that, but I wasn't totally clear on reading the documentation, and after I just nuked my ~/.cabal ~/.ghc to get out of cabal hell and spent an hour rebuilding packages in the sandbox... I wasn't willing to take any risks.
04:16:24 <drewbert> tdammers: thanks for your help.
04:17:28 <tdammers> np
04:37:37 <tasker> I seem to remember that there was some way of streaming records from a persistent db using conduit - could anyone point me towards it?
05:06:02 <jstolarek> mokus_: ping
05:14:56 <nshepperd> Profpatsch: i don't think so, but if you need a mutable variable in ghci, you could create an IORef
05:15:41 * hackagebot sized-vector 1.4.2.0 - Size-parameterized vector types and functions.  http://hackage.haskell.org/package/sized-vector-1.4.2.0 (HiromiIshii)
05:16:28 <nshepperd> er, or you can just shadow the same binding repeatedly
05:16:32 <gcganley> rhaps0dy: im reading it now, i didnt have time last night
05:17:43 <rhaps0dy> gcganley, Oh hello :)
05:17:46 <rhaps0dy> It's okay, don't worry
05:17:58 <rhaps0dy> Sorry for being obnoxious and asking several times
05:18:20 <gcganley> rhaps0dy: it's fine! lol im not on the channel much but i do enjoy reading other peoples work and helping
05:18:21 <rhaps0dy> well, if you read it now I'd thank you for it though
05:18:47 <rhaps0dy> I'm looking if I can use >>= to simplify some of those cases
05:19:27 <gcganley> rhaps0dy: your datatype would have to be kind (* -> *) to be a monad. do you understand kinds?
05:19:44 <gcganley> :k Monad
05:19:45 <lambdabot> (* -> *) -> Constraint
05:19:45 <rhaps0dy> not in general, but I think I unerstand this case
05:19:48 <rhaps0dy> I mean with the Maybe Board
05:19:58 <rhaps0dy> I have two or three functions that do a -> Maybe b
05:19:59 <gcganley> rhaps0dy: oh you could use the Maybe monad i guess
05:20:00 <rhaps0dy> and I chain them
05:20:05 <rhaps0dy> yeah
05:20:13 <rhaps0dy> and in several of them there's a
05:20:27 <rhaps0dy> case a of Nothing -> Nothing; Just b -> dosomethingwith b
05:20:45 <gcganley> ill rewrite those parts in the maybe monad and get back to you. make sure you really do need a monad and you dont need something like applicative
05:20:55 <rhaps0dy> hum
05:21:00 <rhaps0dy> oh, you'll rewrite them?
05:21:07 <rhaps0dy> I really don't want to be too much of a bother :|
05:21:19 <rhaps0dy> I'll check out applicative now
05:21:41 <gcganley> rhaps0dy: dude its fine, after im done with some work I'll whip it up. and yeah look at applicative funtors
05:22:47 <rhaps0dy> oh
05:22:50 <rhaps0dy> fmap
05:23:08 <rhaps0dy> let's see
05:23:35 <gcganley> rhaps0dy: no no thats just normal functor
05:23:37 <gcganley> :t fmap
05:23:38 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:23:41 <gcganley> :t (<*>)
05:23:41 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
05:23:53 <gcganley> rhaps0dy: see the difference?
05:24:06 <rhaps0dy> oh, the function is wrapped in an applicative too
05:24:50 <gcganley> rhaps0dy: Functor /= Applicative Functor
05:24:57 <gcganley> too different things
05:25:01 <gcganley> s/too/two
05:25:11 <rhaps0dy> > (Just (+1)) <$> (Just 4)
05:25:12 <lambdabot>  Couldn't match expected type ‘a0 -> b’
05:25:12 <lambdabot>              with actual type ‘Data.Maybe.Maybe (a1 -> a1)’
05:25:31 <rhaps0dy> sec
05:25:39 <gcganley> :t (Just (+1)) <*> (Just 4)
05:25:40 <lambdabot> Num b => Maybe b
05:25:52 <gcganley> :t (+1) <$> (Just 4)
05:25:53 <lambdabot> Num b => Maybe b
05:25:54 <rhaps0dy> oh, it's <*>, gotcha
05:25:55 <gcganley> see?
05:25:59 <rhaps0dy> <$> is fmap ?
05:26:01 <rhaps0dy> seems so
05:26:05 <gcganley> rhaps0dy: yes!
05:26:26 <rhaps0dy> I actually read this before, but didn't remember accurately :\
05:26:47 <gcganley> rhaps0dy: have you read the typeclassopedia?
05:26:59 <rhaps0dy> nope
05:27:18 <rhaps0dy> is it the best place to learn about typeclasses, or more of a reference manual?
05:27:25 <gcganley> rhaps0dy: do so, helps a lot with intuition with type classes such as Monad and Applicative
05:27:49 <gcganley> rhaps0dy: learn about typeclasses. Written by Brent Yorgey for the Monad Reader if i remember correctly
05:29:02 <rhaps0dy> "learn about typeclasses" or "typeclassopedia" ?
05:29:41 <gcganley> rhaps0dy: the paper is called "the typeclassopedia"
05:29:57 <rhaps0dy> https://wiki.haskell.org/Typeclassopedia this?
05:30:00 <gcganley> there should be a command in here for linking it i just cant remebeer it
05:30:03 <gcganley> rhaps0dy: yes!
05:30:07 <rhaps0dy> cool!
05:30:24 <rhaps0dy> I'll put it in an ebook and read in the train, I have to leave soon
05:30:47 <gcganley> rhaps0dy: now I still re-read it, its quite dense but it is very good. embrace the ignorance and confusion. dont let it scare you
05:31:00 <rhaps0dy> yes, I learned to do that already :)
05:31:10 <rhaps0dy> keep on reading confusing stuff, and if it doesn't make sense, well
05:31:12 <rhaps0dy> read it again
05:31:17 <rhaps0dy> and try it out
05:31:34 <rhaps0dy> That's why I've been only intermittently learning haskell :\
05:31:39 <gcganley> rhaps0dy: good, have fun!
05:31:50 <gcganley> rhaps0dy: youll grasp it eventually
05:32:38 <rhaps0dy> yeah
05:32:43 <rhaps0dy> eventually :D
05:32:47 <rhaps0dy> Thanks for the help.
05:33:04 <rhaps0dy> talk to you in a few hours I guess
05:35:11 <gcganley> rhaps0dy: will do
05:39:23 <tapuu> my cabal is saying strange things
05:39:31 <gcganley> tapuu: like what
05:39:35 <merijn> tapuu: Such as?
05:39:53 <clrnd> in argentinian spanish tapuu means something quite insulting
05:40:05 <tapuu> when I try to cabal update it says, "cabal: The package environment file blaa doesnt exist"
05:41:37 <gcganley> tapuu: what OS are you running?
05:41:58 <tapuu> gcganley: arch
05:42:22 <gcganley> hmm, have you done something like --force-reinstall or somethhing to corrupt the database?
05:42:53 <tapuu> gcganley: I don't think I have
05:43:35 <gcganley> tapuu: hmm, whats the file that it doesnt see? is it lots of messages or just one?
05:43:37 <dgonyeo> does anyone know the reason why template haskell doesn't work on arm?
05:43:47 <dgonyeo> I can't seem to find anything explaining the problem
05:43:55 <gcganley> dgonyeo: its just not implemented yet
05:44:18 <dgonyeo> ah
05:44:31 <gcganley> dgonyeo: ask at #ghc, you may get a better reason WHY
05:44:35 <tapuu> gcganley: it's looking for cabal.sandbox.config in my home directory. It isn't there, I don't remember it being there, and I don't know why there would be a sandbox in my home directory
05:44:45 <dgonyeo> gcganley: will do, thanks
05:45:19 <gcganley> submit the stderr output somewhere so i can read it please
05:46:00 <tapuu> what I posted is pretty much all of it
05:50:55 <gcganley> tapuu: hmmm, what i usually do is do `sudo rm -r ~/.ghc ~/.cabal && cabal update` but idk if reinstalling everything is an option for you
05:51:10 <tapuu> I ran cabal sandbox init in my home directory and now it lets me cabal update
05:51:14 <tapuu> this is very strange
05:52:17 <gcganley> tapuu: if you dont want a sandbox in ~ i would just rm -r ~/.cabal
05:52:34 <tapuu> ill try that
05:53:50 <tapuu> its complaining that theres no sandbox now
05:53:52 <tapuu> lol
05:54:15 <gcganley> one sec ill try something
05:55:04 <jtanguy> cabal sandboxes install in .cabal-sandbox. maybe there is one in your ~ ?
05:55:11 <gcganley> tapuu so you tried deleting the ~/.cabal and its stil happening?
05:56:08 <tsahyt> Is there any clean way to put constraints on a phantom type? Like if I have data UserInput a, I want to constrain a to be one of several things like data Validated or data Unvalidated, but I want UserInput Int to be invalid.
05:56:21 <danilo2_> Hello! Could anybody tell me why so many cloud haskell modules are not available on hackage and exist only on github? like distributed-process-platform?
05:56:41 <tapuu> okay, I've fixed it now
05:56:47 <danilo2_> ugh, apparently distributed-process-platform exist on hackage, but there are many that does not
05:56:51 <mpickering> tsahyt: You need to use data kinds and kind signatures
05:57:07 <tapuu> I deleted all the configuration files I could find, and then made a sandbox somewhere, and it made a default configuration file
05:57:23 <gcganley> tapuu: yeah at ~/.cabal/config
05:57:30 <mpickering> data Foo = Bar | Baz ... data MyProxy (a :: Foo) = MyProxy
05:57:36 <danilo2_> btw - is cloud haskell under devlopment? I love it and I love the ideas behind it and I'm going to use it in our production code, but I would like to know if it is being developped
05:58:53 <merijn> danilo2_: It is, 7.10 is getting the new StaticPointers extension to support it
05:59:27 <merijn> tsahyt: You may wanna read up on TypeFamilies
06:00:51 <merijn> tsahyt: The "Fun with Type Functions" paper is a good start, see also: https://gist.github.com/merijn/6130082 for an example of TF constraints. You'll also wanna look up GADTs for constraining constructors.
06:01:36 <danilo2_> merijn: great, so I'm going with it! By the way - is here anybody that uses cloud haskell everyday? I would have some questions and I would love to get some help in exchange for writing some documentation for example
06:01:46 <tsahyt> merijn: The GADT variant requires different constructors though which means that I always have to pattern match against the possibilities. At least as far as I understand it.
06:04:19 <merijn> tsahyt: Why would it require different variants
06:04:50 <merijn> tsahyt: Also, you could skip the GADT and just make your type "IsValid a => UserInput a" as my Restrict example does
06:05:16 <merijn> That would just require defining IsValid, which should mostly be explained by the paper I mentioned and that example :)
06:05:35 <tsahyt> The way I'd write it would be to have two constructors like InpUnvalidated :: String -> UserInput Unvalidated and InpValidated :: String -> UserInput Validated. So I'd always have to pattern match when using the type
06:06:02 <tsahyt> I'll have a look at the paper. But kind signatures + data kinds seem to do the trick for this simple example. I wonder what the catch is though
06:07:33 <tsahyt> Also, I didn't look at type families enough yet to understand the example
06:08:30 <merijn> tsahyt: Yeah, the tagged DataKinds approach would also work, but may end up requiring you to use RankNTypes if you write functions that are supposed to work on both Validated and Unvalidated input
06:09:48 <tsahyt> When would I need RankNTypes for this? I'm just playing with a toy example here but validate :: UserInput a -> UserInput Validated typechecks at least.
06:10:50 <merijn> Actually, nevermind, in the simple case you won't need it at all.
06:11:54 <tsahyt> Is there any way to "pattern match" on the phantom type argument?
06:12:23 <merijn> No
06:12:24 <tsahyt> So I can get different behavior for unvalidated input for instance
06:12:41 <danilo2_> Btw - I've found out that hackage did not generate docs for https://hackage.haskell.org/package/distributed-process-platform - is there any way to fix it or I have to download it and generate locally?
06:13:06 <merijn> danilo2_: How long since it was updated?
06:13:24 <danilo2_> merijn: about 5 months
06:14:57 <merijn> danilo2_: Notify #hackage and/or #haskell-infrastructure
06:15:04 <danilo2_> merijn: ok
06:15:44 * hackagebot clash-lib 0.4.1 - CAES Language for Synchronous Hardware - As a Library  http://hackage.haskell.org/package/clash-lib-0.4.1 (ChristiaanBaaij)
06:15:46 * hackagebot clash-ghc 0.4.1 - CAES Language for Synchronous Hardware  http://hackage.haskell.org/package/clash-ghc-0.4.1 (ChristiaanBaaij)
06:17:01 <tapuu> is there any global cabal configuration somewhere that would affect the sandbox-config-file option?
06:17:06 <tapuu> something seems to be changing it
06:25:45 * hackagebot clay 0.10.1 - CSS preprocessor as embedded Haskell.  http://hackage.haskell.org/package/clay-0.10.1 (SebastiaanVisser)
06:48:00 <darthdeus_> how do people handle forms with blaze?
06:50:46 * hackagebot extensible 0.2.8 - Extensible, efficient, lens-friendly data types  http://hackage.haskell.org/package/extensible-0.2.8 (FumiakiKinoshita)
06:55:26 <sdegutis> I find it very limiting that I can't use the same name for two record fields in the same module.
06:56:21 <merijn> sdegutis: It's a bit annoying, people are working on solutions, but so far I've never found it too problematic to be a *real* problem (which is probably one of the contributing factors for changes taking so long)
06:56:44 <sdegutis> merijn: ah
06:57:09 <sdegutis> I think I've settled on writing my budget app in pure command line UI, without even ncurses or anything, just tabular output.
06:57:27 <merijn> sdegutis: A common solution is to simply prefix a record with some short type specific prefix
06:57:42 <rasen> sdegutis: https://ghc.haskell.org/trac/ghc/wiki/Records
06:57:51 <merijn> sdegutis: You can look into vty and vty-ui libraries, they're saner, non-curses haskell libraries for doing terminal interfaces
06:58:24 <merijn> rasen: This is what is currently (being) implemented: https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields
06:59:36 <rasen> there is also ansi-terminal which is also works on windows
07:00:45 <rasen> merijn: in which ghc version it will be available?
07:01:54 <merijn> rasen: Not in 7.10 :p
07:02:09 <merijn> Basically, it's not known, probably 7.12 will have it?
07:03:42 <clrnd> mmmm I'm using stackage, trough cabal.config, and it says it can't find my own library defined trough the cabal file
07:03:59 <clrnd> you know, library: etc, executable: etc
07:04:06 <clrnd> this worked before stackage's cabal.config
07:05:32 <clrnd> anyone know how to handle this?
07:10:44 <clrnd> lol sorry I figured it out, the vim macro I used for something left some absurd dependencies
07:10:46 * hackagebot pcg-random 0.1.0.1 - Haskell bindings to the PCG random number generator.  http://hackage.haskell.org/package/pcg-random-0.1.0.1 (cchalmers)
07:11:00 <sdegutis> merijn: I tried really hard to get a basic hello-world working with either vty or vty-ui, and failed both times.
07:11:18 <rasen> sdegutis: Try ansi-terminal. It's pretty easy
07:11:55 <merijn> sdegutis: Did you look at the example program that ships with it?
07:12:04 <sdegutis> merijn: yes, those are the ones I tried compiling
07:12:09 <sdegutis> Couldn't get it to work.
07:12:22 <merijn> sdegutis: Which platform?
07:12:28 <sdegutis> Most likely the fault of the Haskell tooling, but either way, it was horrendous enough to make me give up on it.
07:12:37 <sdegutis> merijn: osx
07:12:45 <joneshf-laptop> i'm parsing a file and getting `Either ParseError a`, printing the error and exiting if it exists, then validating what was parsed with more logic. This gives me a few questions:
07:12:51 <sdegutis> merijn: it was not finding the vty library even though I had it installed
07:13:16 <joneshf-laptop> 1) it seems good to me to have the parsing and validation separate, is this good thinking?
07:13:37 <joneshf-laptop> 2) casing on the either seems like I'm missing some abstraction, what could I do differently?
07:13:50 <merijn> sdegutis: That sounds odd, lemme try
07:14:10 <merijn> joneshf-laptop: Why does casing on Either seem like a missing abstraction? What else would you do?
07:14:15 <merijn> I mean, you could use
07:14:17 <merijn> :t either
07:14:18 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
07:14:23 <merijn> But that's hardly different
07:15:26 <merijn> sdegutis: How did you install things/do you remember what went wrong?
07:15:38 <sdegutis> I don't know anymore.
07:15:44 <sdegutis> I tried so many combinations of things.
07:15:53 <joneshf-laptop> merijn, I've done it a few times in different situations, I always seem to end up with nested cases where the "left" side is doing error dispaly and exiting, while the right is continuing with domain logic
07:16:20 <clrnd> sdegutis, I just resigned using gitlib because I couldn't install gitlib-libgit2 lol, high five!
07:16:24 <joneshf-laptop> merijn, it feels very much like js or go or some such
07:16:28 <tdammers> there's ekmett's Monad instance for Either, fwiw
07:16:30 <merijn> joneshf-laptop: Well, if you have lots of *repeated* cases like this, you may want to look into ExceptT (basically EitherT)
07:16:40 <sdegutis> clrnd: uh
07:17:24 <joneshf-laptop> tdammers, merijn do either of those handle the left side as errors so I don't have to?
07:17:38 <tdammers> yes, pretty much all of them do
07:17:59 <merijn> joneshf-laptop: Yes, that's the entire point ;)
07:18:09 <joneshf-laptop> merijn, tdammers k thanks
07:18:09 <merijn> Also, christ, why is vty-ui pulling in lens?
07:18:21 <clrnd> gotta love lens
07:18:21 <tdammers> merijn: all the cool kids pull in lens these days
07:18:39 <clrnd> they wanna use the (&) combinator
07:18:58 <meoblast001> hi. i'm using haskell-vim-now, which relies on ghcmod-vim. in my vimrc, i have "nmap <silent> <leader>hc :SyntasticCheck ghc_mod<CR>". strangely, when i run this command, it complains about missing libraries which i've installed through cabal. does anyone know if there's a way that i can direct ghcmod-vim to look for my haskell environment in cabal?
07:19:24 <merijn> oh...new vty relies on lens :\
07:19:53 <Haskellfant> there is never enough lens in your code
07:22:50 <merijn> sdegutis: Anyway, this appears to work for me: "cabal get vty-ui", cd to vty-ui dir, "cabal sandbox init && cabal install --dependencies-only && cabal configure -fdemos && cabal build"
07:23:27 <merijn> sdegutis: The first command grabs the source, the second creates a new sandbox, followed by installing any dependencies, configuring it to also build demos and then building everything
07:23:41 <merijn> (This on yosemite with 7.8.3)
07:23:53 <merijn> I'm curious if that works for you too, and if not, what the errors are
07:25:39 <csd_> Does haskell have something similar to the Clojure Koans?
07:25:47 * hackagebot deepseq-bounded 0.8.0.0 - Bounded deepseq, including support for generic deriving  http://hackage.haskell.org/package/deepseq-bounded-0.8.0.0 (AndrewSeniuk)
07:25:49 * hackagebot seqaid 0.4.0.0 - Dynamic strictness control, including space leak repair  http://hackage.haskell.org/package/seqaid-0.4.0.0 (AndrewSeniuk)
07:25:51 * hackagebot leaky 0.4.0.0 - Robust space leak, and its strictification  http://hackage.haskell.org/package/leaky-0.4.0.0 (AndrewSeniuk)
07:26:20 <merijn> csd_: That depends on what those are...
07:26:34 <tdammers> csd_: we have videos of the inventors of the language describing how useless the language is, and presentations typeset in Comic Sans
07:26:52 <tdammers> hmm, that may not make for a good first impression
07:26:58 <csd_> They're basically code snippets that you have to complete, and in doing learn about the language
07:27:08 <tdammers> oh, that
07:27:19 <merijn> csd_: I've got one for you: Implementing State and StateT: https://gist.github.com/merijn/098106abd45c940dab09 :)
07:27:33 <merijn> csd_: Also, typeclassopedia has a bunch of example assignments, I think?
07:27:52 <tdammers> there's Write Yourself A Scheme
07:27:56 <tdammers> @where scheme
07:27:57 <lambdabot> https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
07:27:57 <rasen> @google haskell 99
07:27:58 <lambdabot> https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems
07:28:13 <merijn> csd_: As extra credit, try to prove that your implementation of State/StateT obey the functor, applicative and monad laws
07:28:23 <merijn> rasen: Those are pretty trivial beginner problems, though
07:28:36 <csd_> what's that one homework where it is increasingly difficult type/monad completion
07:28:38 <frawgie> nice, didnt knwo about h99 :) now i got something to do during spring festival \m/
07:28:38 <ajcoppa> just do the whole NICTA course!
07:28:44 <merijn> They're more "basic recursion" and less "broaden my understanding of concepts"
07:28:51 <ajcoppa> (of which State/StateT are a part)
07:29:34 <csd_> write yourself a scheme is actually a great idea since i'm workign primarily in clojure
07:30:05 <sdegutis> Is Haskell anything like Rust?
07:30:16 <merijn> sdegutis: Eh, in what way? :)
07:30:23 <sdegutis> I dunno.
07:30:27 <clrnd> rust is kindof like haskell maybe
07:30:42 <sdegutis> I want to like Haskell, but there's just so much about it that's really making using it difficult.
07:30:55 <merijn> Rust is more of a "safer C++ that doesn't ignore last 40 years of PL research"
07:30:56 <sdegutis> So I'm wondering if any of you Haskellers like Rust.
07:31:02 <Cale> Rust seems pretty different from Haskell
07:31:17 <MrPopinjay> Similar in some ways
07:31:21 <merijn> sdegutis: I, conceptually like Rust, but not as a Haskell replacement, but as a C/C++ replacement
07:31:25 <Kaidelong> sdegutis: I'm holding out hope that Frege will turn into something good
07:31:28 <clrnd> I like rust, but I don't see it making it in the large or replacing C++
07:31:29 <sdegutis> Rust has constrained types, pattern matching, first-class functions.
07:31:48 <merijn> sdegutis: But no higher kinded types or GC :\
07:31:49 <Kaidelong> Haskell on JVM could solve most of Haskell's deployment/library problems, done well
07:31:51 <clrnd> sdegutis, first class functions? sure?
07:32:00 <merijn> clrnd: Why not? C++ has those...
07:32:05 <MrPopinjay> merijn: The no GC is kind of the point of Rust
07:32:14 <rasen> MrPopinjay: C++ has GC
07:32:19 <merijn> MrPopinjay: Sure, but it also means that it's not competing with Haskell :)
07:32:26 <sdegutis> merijn: Rust has something like a GC, no?
07:32:29 <clrnd> merijn, oh he means pointers
07:32:30 <MrPopinjay> Nope
07:32:32 <rasen> MrPopinjay: in standard... as optional feature...
07:32:47 <merijn> clrnd: C++ has first class functions, not function pointers...
07:32:50 <Kaidelong> RAII is a form of reference counting GC anyway
07:32:51 <tdammers> merijn: rust *is* competing with Haskell in the "almost as fast as C, statically-typed, higher-level" league
07:32:52 <merijn> Well, it has function pointers TOO
07:33:02 <vanila> sdegutis, what do you find difficult about haskell
07:33:03 <Kaidelong> it annoys me when C++ advocates go on about how great it is that C++ has no GC
07:33:15 <clrnd> tdammers, rust is high level? this is getting weird
07:33:15 <sdegutis> vanila: mostly the tooling around it, especially cabal
07:33:17 <merijn> Kaidelong: It is great if you wanna do real time
07:33:19 <Kaidelong> you just write the GC yourself, and a simpler and less optimal implementation than in something like C#
07:33:21 <vanila> oh yeah :(
07:33:22 <tdammers> clrnd: relatively
07:33:23 <Kaidelong> merijn: bingo
07:33:27 <rasen> merijn: C++ has function pointers
07:33:30 <vanila> i have so much trouble with that
07:33:32 <tdammers> clrnd: compared to, uhm, C
07:33:41 <Eduard_Munteanu> Is there a way to reference the default implementation of a method when defining a typeclass?
07:33:42 <merijn> rasen: I just said it did, I just said it ALSO has first class functions
07:33:56 <Kaidelong> reference counting is better in realtime and some embedded applications
07:33:58 <clrnd> and I had no idea, thanks merijin for pointing that out
07:33:59 <merijn> Eduard_Munteanu: What do you mean by that?
07:34:07 <Kaidelong> but it's still a form of "GC"
07:34:16 <tdammers> the advantage of refcounting is that it's deterministic
07:34:18 <merijn> clrnd: Only since C++11, but it has lambda's with proper closures (can capture by copy, value and reference)
07:34:21 <Kaidelong> and in theory something like Haskell could just have its GC implemented to be like C++ RAII
07:34:41 <MrPopinjay> It could be added later
07:34:41 <Kaidelong> it's just, there are good reasons why we don't implement GCs that way
07:34:43 <merijn> clrnd: They work pretty well, given the constraints of C++
07:34:49 <pjdelport> Eduard_Munteanu: You can refer to the superclass's implementation from a subclass, by operating on values of the appropriate type.
07:34:51 <MrPopinjay> They're doing that for class based inheritance too
07:34:53 <pjdelport> Eduard_Munteanu: Is that what you mean?
07:35:05 <MrPopinjay> OOP style classes, that is
07:35:11 <Eduard_Munteanu> merijn, class Foo a where foo :: a -> a; foo x = x; instance Foo Int where foo x = foo x + foo x
07:35:14 <clrnd> merijn, oh, I did C++ before 2011 so you see
07:35:17 <Kaidelong> there is a tradeoff, aggressive, frequent freeing of memory like what refcounting does is significantly slower than reusing already allocated memory and freeing in large batches (or never at all)
07:35:25 <Eduard_Munteanu> And I don't want recursion, just referencing the default foo.
07:35:26 <tdammers> Kaidelong: different priorities. In C++, deterministic resource cleanup is important, so "out-of-band" GC is not desirable
07:35:31 <Kaidelong> so it's bizzare when I hear about how superior RAII is
07:35:34 <merijn> sdegutis: Basically, in the near future I'll use haskell for almost everything and rust for the stuff that I'd now use C/C++ for
07:35:42 <merijn> Kaidelong: RAII is pretty awesome
07:35:44 <Eduard_Munteanu> pjdelport, no, same class
07:35:59 <Kaidelong> tdammers: yeah but it is a form of GC and you can in theory use it with managed languages
07:36:01 <pjdelport> Eduard_Munteanu: Can you paste an example of what you mean?
07:36:02 <merijn> Kaidelong: I mean, not as awesome as GC, but if you have to give up GC it's a pretty good idea :)
07:36:07 <Kaidelong> this is the point that seems to evade people
07:36:17 <Eduard_Munteanu> One moment...
07:36:29 <Kaidelong> it's also not superior, it's an engineering tradeoff
07:36:40 <tdammers> I don't think you actually *can* transparently implement full-blown GC using RAII
07:36:43 <merijn> Kaidelong: The difference is that unlike "regular" GC RAII has predictable runtime behaviour, which is the real important issue
07:36:52 <pjdelport> Eduard_Munteanu: You can have methods of the same class refer to each other, as defaults. (This requires subclasses to override at least one of them, if there are circular dependencies.)
07:36:53 <tdammers> Python uses refcounting, but that's not 100% the same thing
07:37:05 <merijn> tdammers: It uses refcounting + tracing to break cycles
07:37:06 <tdammers> and they had to add cycle detection to make it not leak
07:37:10 <pjdelport> PyPy uses a tracing GC, FWIW.
07:37:25 <Kaidelong> yeah but A) it's a form of garbage collection, enforced by convention and B) you could implement this kind of garbage collection elsewhere. It's a good idea. People just haven't much
07:37:38 <Kaidelong> it's not an advantage C++ has because it is unmanaged
07:37:45 <merijn> Kaidelong: It's not really a form of GC in any common understanding of the term
07:38:08 <sinnsat> pjdelport: yeah, sad that pypy still lacks numpy support and some other stuff
07:38:22 <sinnsat> it's pretty cool otherwise
07:38:50 <agocorona> RAII does not work except for objects allocated in the stack
07:39:02 <Eduard_Munteanu> pjdelport, merijn: http://lpaste.net/119969  -- try eliminating the defaultFoo
07:39:14 <Kaidelong> agocorona: the way C++ folks seem to deal with this is to wrap everything in objects just to get RAII back
07:39:38 <pjdelport> sinnsat: NumPyPy is going pretty strong, from the looks of it!
07:39:45 <Kaidelong> which is okay
07:39:46 <tasker> How do recordwildcards work if you have qualified imported the type
07:39:48 <tasker> ?
07:39:50 <Kaidelong> it's a sensible enough programming paradigm
07:39:53 <cdx> agocorona: even if that's true, with shared/unique_ptr even heap allocated objects can be managed on the stack with RAII
07:40:18 <Kaidelong> wait destructors don't fire on heap allocated objects?
07:40:18 <agocorona> Kaidelong: but when you have long living data that you pass along, RAII can do nothing with that
07:40:24 <Kaidelong> this would defy my intuition a lot
07:41:03 <cdx> Kaidelong: dtors fire when the heap obj is 'delete'-ed
07:41:19 <agocorona> so you have to delete it manually
07:41:25 <Kaidelong> well
07:41:38 <Kaidelong> it will get deleted in other dtors, right?
07:41:39 <Eduard_Munteanu> pjdelport, merijn: obviously my real usecase involves something a lot more complex than id
07:41:44 <cdx> this is no longer really about haskell... maybe we should take the cpp discussion to haskell-blah?
07:41:45 <sinnsat> Eduard_Munteanu: uh, wat? foo = (+)?
07:41:49 <Kaidelong> that's in fact what smart pointers are supposed to do?
07:42:10 <Eduard_Munteanu> sinnsat, pretend 'foo' is more intricate
07:42:19 <agocorona> In practical terms it is not different from malloc and free. only you use new and delete
07:43:08 <Eduard_Munteanu> And I don't have a defaultFoo, the class has already been defined with foo's code inlined
07:43:22 <Eduard_Munteanu> I'm trying to avoid copy-pasting it.
07:43:35 <tdammers> Eduard_Munteanu: move it out of the typeclass and reference it from there? idk
07:43:52 <Eduard_Munteanu> tdammers, it's not my class
07:44:36 <tdammers> ah
07:44:38 <Eduard_Munteanu> defaultLayout at http://hackage.haskell.org/package/yesod-core-1.4.7.2/docs/src/Yesod-Core-Class-Yesod.html#defaultLayout
07:44:46 <Eduard_Munteanu> That's my actual usecase.
07:45:01 <b0rn> people, what are you working on?
07:45:09 <athan> b0rn: http://deconfigured.com/blog/atlc5 :D
07:45:47 * hackagebot ap-reflect 0.2 - Partial evaluation reflection a la simple-reflect.  http://hackage.haskell.org/package/ap-reflect-0.2 (NickolayKudasov)
07:45:49 * hackagebot http-client 0.4.7.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.7.1 (MichaelSnoyman)
07:47:21 <sinnsat> b0rn: half-edge data structure in haskell
07:47:33 <b0rn> hackagebot are you by any chance called Domen ?
07:47:46 <rasen> b0rn: bittorrent client
07:48:39 <b0rn> i love haskell, libraries are great, clients too ... but a services change the world :)
07:50:09 <sinnsat> b0rn: no bonus points for loving haskell in
07:50:14 <sinnsat>  #haskell :P
07:50:24 <b0rn> you all have a day job, or client work, is haskell just a hobby ?
07:50:48 * hackagebot file-embed 0.0.8 - Use Template Haskell to embed file contents directly.  http://hackage.haskell.org/package/file-embed-0.0.8 (MichaelSnoyman)
07:50:55 <rasen> There are some guys that do haskell for living
07:51:01 <rasen> who do*
07:51:13 <Eduard_Munteanu> I am doing some for work right now. :)
07:51:45 <Lokathor> i don't work in programming i just like trying to get haskell to work :P
07:52:21 <juanpablo_> I got this error message when working with type families: "Credentials’ is a type function, and may not be injective". I'm not sure what it means, does it mean my type function is not injective and GHC is complaining about or that my type function is not allowed to be injective?
07:52:22 <b0rn> i am working in swift on a app, but i am learning haskell
07:52:27 <juanpablo_> This confuses me :(
07:52:42 <sinnsat> b0rn: swift as in the new obj-c successor?
07:52:47 <sinnsat> I tried it... it's uhm.
07:52:59 <Eduard_Munteanu> juanpablo_, it means type functions aren't always injective
07:53:10 <Eduard_Munteanu> Or not provably.
07:53:15 <sinnsat> you can write curried functions even... but no default currying, meh
07:53:15 <juanpablo_> Eduard_Munteanu: they can't be injective or they must be injective?
07:53:30 <b0rn> sinnsat yeah, it takes some things from haskell, not much :)
07:53:33 <HeladoDeBrownie> it is not the case that they must be injective
07:53:42 <HeladoDeBrownie> they can be injective
07:53:57 <Eduard_Munteanu> juanpablo_, yours must be, but it isn't or it can't tell
07:54:02 <sinnsat> b0rn: and the API to C is very poor... very poor. Swift doesn't even support C macros. ouch
07:54:33 <rasen> Who knows how well javascript is suited for FP?
07:54:44 <b0rn> C macros are unreadable, you dont need them
07:54:53 <tdammers> rasen: that's kind of a vague question
07:54:59 <sinnsat> b0rn: so you rewrite random libraries for fun, because they have C macros?
07:55:00 <athan> rasen: Angular?
07:55:04 <clrnd> rasen, reactjs
07:55:06 <rasen> node.js
07:55:06 <athan> erm
07:55:10 <tdammers> rasen: JS has some heavy scheme influences in it
07:55:13 <HeladoDeBrownie> rasen, depends what you mean by fp. it has first-class procedures (functions) at least, but it's missing several other desirable features like static typing, lazy evaluation, etc.
07:55:24 <tdammers> rasen: first class functions, proper closures, etc. - you get all that
07:55:25 <athan> check out fantasyland
07:55:26 <clrnd> js has far more FP libraries than any other non-fp language I'm aware of
07:55:38 <HeladoDeBrownie> it also has a lot of excess complexity and pitfalls
07:55:38 <sinnsat> b0rn: I don't think so... it's not a real argument. By not supporting C macros they make it exceptionally hard to use C libraries that heavily use them.
07:55:49 <b0rn> dont rewrite them, if you have a finished library you can use it
07:55:50 <tdammers> but OTOH, trying to enforce purity in a meaningful way and containing impure parts is pretty damn hard
07:56:19 <Lokathor> on fpcomplete, what's the deployment system like? do you press a button somewhere and it'll make a .zip of the compiled binary/libs for win/linux/mac?
07:56:22 <Kaidelong> "functional programming" doesn't conventionally require that ability
07:56:33 <b0rn> not really, like cd/floppy disks macros are a thing of the past, and thats good
07:56:39 <Lokathor> or do you still compile it on your machine in the end?
07:56:50 <tasker> I'm trying to use the new support for primary keys in persistent. If I have a Text primary key, I can't quite work out how to construct the key from the appropriate Text.
07:56:51 <tdammers> Kaidelong: well, thing is, "functional programming" means different things to different people
07:57:00 <sinnsat> b0rn: that might be your opinion but it doesn't reflect reality
07:57:19 <b0rn> sinnsat what are you working on ?
07:57:21 <sinnsat> b0rn: and as long as it doesn't reflect reality... it makes Swift less useful
07:57:38 <tdammers> you could say that functional programming is based on functions as mappings from input values to output values, and this concept of a function implies purity
07:57:57 <tdammers> so in that sense, JS isn't very suitable for FP
07:58:11 <b0rn> the problem with objective-c was that it was a pain for development, swift made it more fun
07:58:26 <sinnsat> b0rn: I've written an encryption class in Swift that uses pure NTRUEncrypt or NTRUEncrypt + AES... utilizing the C libraries libntru and polarssl. It was a major pain.
07:58:32 <athan> If I legitimately invent a new lambda calculus, what are the chances I would get like a grant or a hi-five with some money in it?
07:58:39 <b0rn> c is okey and you can access c libraries from swift
07:58:58 <sinnsat> b0rn: accessing c libraries from swift is not nice
07:59:02 <sinnsat> I've done it ;)
07:59:44 <sinnsat> but then again... I don't know many languages where it is nice
07:59:48 <b0rn> okey ... i am doing an app, so i mostly use CALayer and UIKit libraries, I dont write my own
08:00:24 <sinnsat> b0rn: you happen to work with XCode? It has a feature called "crash"... which works very reliably.
08:00:46 <sinnsat> but you cannot disable that feature
08:00:48 * hackagebot amqp-conduit 0.1.0.0 - Conduit bindings for AMQP (see amqp package)  http://hackage.haskell.org/package/amqp-conduit-0.1.0.0 (toru_tomita)
08:00:50 * hackagebot yesod-test 1.4.3 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-1.4.3 (MichaelSnoyman)
08:01:09 <b0rn> sinsat every development environment has this feature
08:01:18 <lpaste> Alpy pasted “Cabal does not let me download threadscope” at http://lpaste.net/119971
08:01:24 <alpy> hello, cabal does not let me download threadscope .
08:01:25 <tdammers> b0rn: mine doesn't
08:01:27 <b0rn> i like xcode, its big, but it kind of works :)
08:01:40 <sinnsat> b0rn: vim doesn't crash for me... never
08:01:49 <b0rn> vim is just an editor
08:01:50 <alpy> when i try to it tells this; http://lpaste.net/119971
08:02:01 <sinnsat> b0rn: that depends on your extensions and configuration
08:02:02 <b0rn> i use zed
08:02:04 <tdammers> b0rn: vim is the text editor component in my development environment
08:02:13 <tdammers> b0rn: I haven't seen it crash, *ever*.
08:02:16 <tdammers> honestly.
08:02:28 <b0rn> try to write an app in vim
08:02:29 <tdammers> and the same goes for most of the other components of my toolchain
08:02:32 <sinnsat> b0rn: XCode crashes for me like every 15 minutres
08:02:48 <b0rn> it will not crash, but it would not work either
08:03:03 <tdammers> b0rn: I have. Granted, I'm using phonegap, and granted, mobile apps are disgusting, but it works fine
08:03:09 <sinnsat> b0rn: that's because the toolchain and libraries of Swift are not really opensource
08:03:11 <rasen> b0rn: I'm using Vim for Haskell and also write an operating system at work
08:03:29 <b0rn> again with this opensource
08:03:41 <tdammers> for anything that doesn't mandate nonfree tools, my toolchain is pretty much perfect, as far as my needs are concerned
08:03:49 <geekosaur> alpy: it's looking for the C devel library
08:04:01 * merijn was hacking >100k C++ codebases using vim...
08:04:06 <b0rn> i like the idea of opensource, but the problem with it is that there is not enough focus to push
08:04:20 <sinnsat> b0rn: I cannot follow
08:04:25 <alpy> <geekosaur> so how di get it?
08:04:52 <alpy> geekosaur so how do i get it?
08:04:57 <geekosaur> alpy: on linux you'll find most distributions install runtime libraries but not the development headers/link-time libraries. how you install those and what they're called depends on the distribution
08:05:00 <b0rn> sinnsat are you into crypto protocols ?
08:05:03 * rasen hacking ~2m C codebase every day
08:05:24 <alpy> geekosaur, i have ubuntu.
08:05:33 <sinnsat> b0rn: not much. I've just implemented NTRUEncrypt once... very poorly probably, but it works. Not really an expert.
08:05:57 <b0rn> okey
08:06:08 <sinnsat> the algorithm is fun
08:06:19 <alpy> geekosaur, ubuntu 14.10 to be precise
08:07:05 <geekosaur> on my debianish work machine libglib2.0-dev and libcairo2-dev
08:07:22 <clrnd> hey anyone here used gitlib successfully?
08:07:23 <geekosaur> (actually mint so somewhat close to ubuntu, but perhaps a version behind yours)
08:07:25 <b0rn> i like to start a startup for an algorithm - machine learning - in haskell
08:07:35 <geekosaur> you'll probably need a few more libs like that as well
08:07:52 <b0rn> i been working on it as a side project
08:09:23 <gregnwosu> hi can i compose parsec parsers with '.' ?
08:09:46 <merijn> gregnwosu: No, what do you mean by compose? Can you give use the types?
08:09:53 <tapuu> gregnwosu: they arent functions
08:09:59 <sinnsat> isn't it <*> or *> or <* for combining parsers?
08:10:12 <gregnwosu> ah yes
08:10:12 <sinnsat> <|> for choice afair
08:10:15 <tdammers> combine *how*?
08:10:23 <tdammers> there are several useful ways
08:10:24 <merijn> Or >> or >>= or >=> or a million other ways
08:10:36 <merijn> Or do notation, etc.
08:10:39 <gregnwosu> i want the output of one to be put into the other
08:10:49 <gregnwosu> yes i think i want monadic compose
08:10:53 <merijn> So, say, a type like...
08:10:53 <tdammers> >>= then
08:10:55 <gregnwosu> >=>
08:10:57 <merijn> :t (>>=)
08:10:58 <lambdabot> Monad m => m a -> (a -> m b) -> m b
08:11:15 <merijn> :t (>=>) -- everything needs more Kleisli
08:11:16 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
08:11:30 <tdammers> or, depending on how you want to "put it into the other", you may want <$> / <*>
08:11:44 <c_wraith> :t (<=<) -- is even more kleisli
08:11:45 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
08:11:46 <tdammers> SomeConstructor <$> parser <*> anotherParser
08:11:57 <tdammers> ^ quite a nice pattern actually
08:12:15 <gregnwosu> i have a = Parser Expr and b = Parser Expr
08:12:29 <tapuu> What do you want to do with them
08:12:38 <geekosaur> alpy: http://askubuntu.com/questions/168154/installing-gtk-dev-environment-with-aptitude
08:12:51 <tapuu> With the Exprs I mean
08:12:51 <rasen> tdammers: with binary it gets something like MyConstructor <$> get <*> get <*> get
08:12:54 <alpy> geekosaur, cheers
08:13:01 <tdammers> example: binaryExpressionParser = BinaryExpression <$> operandParser <*> binaryOperatorParser <*> operandParser
08:13:02 <gregnwosu> i want the result of parsing a Expr to be parsed by b
08:13:04 <tdammers> yeah
08:13:11 <tdammers> oh, right
08:13:13 <tdammers> I see
08:13:15 <tapuu> you mean the rest of the string?
08:13:19 <gregnwosu> yes
08:13:25 <tapuu> What do you want to do with the first Expr?
08:13:37 <rasen> tdammers: wrote parser for udp tracker protocol in about 10-20 minutes
08:13:42 <rasen> in that way
08:13:49 <tdammers> rasen: yep
08:14:13 <gregnwosu> sorry , you guys are right , i think im just confused
08:14:17 <tdammers> rasen: I like how it closely follows the semantics of the thing you're parsing
08:14:19 <tapuu> no wait
08:14:32 <tapuu> what are you trying to do with the first Expr
08:14:35 <tapuu> discard it?
08:14:52 <Kaidelong> wouldn't the first resort for using the result of another parser in a new parser be <*>?
08:15:06 <alpy> geekosaur, it seems to for work for now
08:15:09 <tdammers> do { a <- expression; b <- expression; return $ Something a b } -- something like this, using pseudo-imperative do notation?
08:15:16 <Kaidelong> I thought the use of >>= generally meant you were using a recursive descent style parser with exponentially increasing parse time
08:15:23 <Kaidelong> and was to be avoided
08:15:30 <tdammers> Something <$> expression <*> expression -- is equivalent
08:15:38 <sinnsat> Kaidelong: I think it's uncelar what people mean with "Result" here
08:15:38 <gregnwosu> tdammers thats right
08:15:53 <sinnsat> the Result is a data structure
08:15:56 <gregnwosu> so but i want to applyit ot a parser
08:16:12 <tdammers> oh, so you want something like a two-pass parser
08:16:26 <tdammers> parse something into a data structure, and then run another parser over that data structure
08:16:38 <gregnwosu> tdammers yes , but i was hoping i could compose them
08:16:46 <tdammers> I guess you'd have to call runParsec or one of its brethren on the parse result from the first parse
08:16:48 <gregnwosu> since the output from one parser can go in the second
08:17:21 <tapuu> I'm really confused now
08:17:32 <tdammers> except that the parser itself doesn't take the input as an argument; the input is passed around through the Parsec monad's plumbing
08:17:38 <tdammers> implicitly
08:17:42 <tapuu> Do your parsers that returns Exprs also parse Exprs?
08:18:19 <gregnwosu> I have two parsers Parser String and Parser Expr
08:18:36 <tapuu> Oh that makes more sense
08:18:37 <gregnwosu> I want a Parser Expr
08:18:55 <gregnwosu> such that I feed a String into Parser String
08:19:10 <gregnwosu> get a String out and Feed it into Parser Expr
08:19:37 <tdammers> you need to wrap the Parser Expr in some sort of runParsec to feed a string to it
08:19:55 <Eduard_Munteanu> reparseAs p q = p >>= runParser q >>= either fail return    -- something like that
08:20:10 <tdammers> ^ this
08:20:11 <Eduard_Munteanu> reparseAs :: Parser String -> Parser a -> Parser a
08:20:29 <javjarfer> Hi there! Anyone could explain to me the equivalence "exists a. a" equivalent to "forall r. (forall a. a -> r) -> r"?
08:21:44 <merijn> javjarfer: "Given a function that can take any 'a' to produce an 'r', we can produce an 'r'"
08:21:51 <javjarfer> I think that i don't really get it, because I'm not able to replace existential datatypes with univeral quantification using this equivalence
08:22:13 <merijn> javjarfer: So if we have SOME unknown 'a' and feed it into this function we're getting (which turns ANY 'a' into an 'r') we can produce an 'r'
08:22:15 <Eduard_Munteanu> javjarfer, the second type gets a continuation as an argument, and you can call that continuation with a suitable 'a'
08:22:42 <merijn> javjarfer: So therefore we must have some implicit 'a' that exists
08:25:34 <javjarfer> so, actually i could really wrote that code? and could i replace any existential type throught that definition?
08:26:07 <Eduard_Munteanu> javjarfer, for example, 'exists a. a' would be proven with existsTruth k = k ()
08:26:11 <merijn> javjarfer: Yes, that's how GHC does existentials, but it's gym time, so no time to explain :)
08:27:40 <javjarfer>  merijn: thanks you so much
08:28:06 <Eduard_Munteanu> existsFalsehood :: exists a. a -> Void, existsFalsehood k = k id
08:28:30 <Cheery> I wonder if you've seen a data structure like this before: http://i.imgur.com/bxJ2kLV.png
08:28:56 <Eduard_Munteanu> (I'm using exists because it's shorter to type, it's not actual syntax.)
08:29:16 <Cheery> basically notated in text it's a sequence of atomic objects: ["", "", "", "" "hello", "world"]
08:29:45 <Cheery> and then there's nodes, referencing cells in that sequence, or each other
08:30:13 <Cheery> a = and([0], [1]); b = or(a, [2])
08:30:28 <Cheery> the structures must  comform to the order in the sequence
08:30:29 <javjarfer> Eduard_Munteanu: Sorry, but i'm lost
08:30:38 <Cheery> that is. and([1], [0]) disallowed
08:31:44 <Cheery> this is a prototype I'm working on, but I wonder whether that structure has a name
08:34:09 <Eduard_Munteanu> javjarfer, are you familiar with continuations and CPS transforms?
08:37:08 <tomphreek> @hoogle stdUniform
08:37:10 <lambdabot> No results found
08:38:39 <javjarfer> Eduard_Munteanu: yes, i'm but it looks like isn't enough
08:40:03 <hodapp> I might be starting to get some idea of what people mean when they talk about OCaml's module system, despite having little OCaml experience.
08:40:29 <hodapp> I'm in the situation that what I have as a module actually needs to be N swappable modules that implement the same sort of implicit interface.
08:40:37 <hodapp> so I suppose I need to change this to a record, or something like that.
08:41:41 <Eduard_Munteanu> javjarfer, the '(forall a. a -> r)' bit is a continuation. You give it some proof of 'a', which you can pick.
08:43:19 <Eduard_Munteanu> javjarfer, the rank-2 type there lets the caller of the continuation pick the 'a'.
08:43:37 <joneshf-laptop> how do you interpret haddock coverage?
08:43:37 <Eduard_Munteanu> Contrast to 'forall a r. (a -> r) -> r'.
08:43:46 <joneshf-laptop> it's saying 9/10 for a file
08:43:54 <joneshf-laptop> but I've only got 9 functions
08:44:19 <hodapp> Is there a pattern that people tend to follow here? Does one have to modify any definition that relies on the module to parametrize it over some record type?
08:44:23 <ClaudiusMaximus> joneshf-laptop: probably the module itself is missing documentation? or some types?
08:44:30 <javjarfer> Eduard_Munteanu, oookay! i think i start getting it
08:44:42 <javjarfer> Eduard_Munteanu, thanks you so much
08:44:50 <joneshf-laptop> ClaudiusMaximus, ah
08:49:16 <joneshf-laptop> hmm, no that wasn't it
08:51:51 <homesitter> Hi ! I wrote a SAT solver :)
08:52:03 <vanila> cool homesitter :D
08:52:28 <homesitter> https://github.com/toki78/NestedIntervalsSAT
08:52:53 <vanila> oh its in java
08:53:55 <homesitter> vanila: It's slow and inefficient, and I have absolutely no knowledge about its runtime complexity
08:54:06 <vanila> SAT is in NP
08:54:31 <Kaidelong> SAT solvers use heuristics to deal with that
08:54:38 <Kaidelong> some of them may also give false negatives
08:54:50 <Kaidelong> and decide a formula is unsatisfiable when it actually is
08:55:06 <Kaidelong> this lets them work on non-NP subsets of the problem
08:55:53 <homesitter> sorry it's in java, but the guys here are the only ones, whom I can talk about that
08:56:04 <vanila> that sounds awful Kaidelong
08:56:11 <hodapp> ahh, a prof of mine at university did a lot of work with SAT
08:56:11 <vanila> I would not liek to use a sat solver that gave falses
08:56:31 <hodapp> homesitter: no love from #java?
08:57:09 <tomphreek> I am struggling with using Data.Random.Rvar. I ve read up on monads and read the random chapter from LYAH, but this is the first time I am acutally using something more complicated than print X with regards to monads. A simple sample from a random variable and print example would help me a lot
08:57:17 <tomphreek> and it's missing in http://hackage.haskell.org/package/random-fu-0.1.4/docs/Data-Random-RVar.html
08:57:50 <Kaidelong> vanila: you've never had to deal with unsafeCoerce or unsafePerformIO? Granted, that's about validity, not satisfiability, and the Haskell type checker will work in exponential time before giving up
08:57:57 <homesitter> hodapp: I will try
08:58:08 <hodapp> homesitter: it's fine to ask here
08:58:19 <homesitter> Kaidelong: mine doesn't use a heuristic
08:58:21 <hodapp> homesitter: I was just curious if you had already tried that channel
08:58:26 <Kaidelong> well, not being able to infer a type works too, so being forced to annotate your type
08:59:02 <homesitter> hodapp: they normally are not too much into theoretical computer science
08:59:11 <hodapp> homesitter: they are not much into practical computer science either
08:59:14 <Kaidelong> tomphreek: unfortunately, Data.RVar does not compose very well into monad stacks, in particular ones involving ST, so think carefully if you really want to use it over System.Random
08:59:17 <hodapp> homesitter: or common politeness
08:59:36 <Kaidelong> if you want a simple example... mmm
08:59:42 <tomphreek> Kaidelong: ST?
08:59:50 <tomphreek> State monad?
08:59:57 <homesitter> hodapp: :)
08:59:58 <hodapp> hmmm... I guess I could have this Haskell code generate another Haskell file at runtime which contains some Haddock docs that I'd really like to be kept alongside the rest of the Haddock docs
09:00:15 <hodapp> that's clunky but I know of no other way to evaluate some simple definitions and get them into the docs
09:00:31 <Kaidelong> randomSquare sqrt = (+) <*> (uniform 1 sqrt) (uniform 1 sqrt) :: RVar Int
09:00:40 <Kaidelong> is that a good enough example?
09:00:45 <Kaidelong> err also
09:00:47 <Kaidelong> that is actually
09:00:50 <Kaidelong> Int -> RVar Int
09:00:51 * hackagebot yesod-bin 1.4.3.5 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.3.5 (MichaelSnoyman)
09:01:03 <Kaidelong> well, the body is RVar Int
09:01:43 <tomphreek> Kaidelong: will it print? print ({what you wrote}) will return IO (RVar Int)
09:01:44 <tomphreek> ?
09:02:00 <tomphreek> oh sorry
09:02:01 <Cheery> http://www.reddit.com/r/compsci/comments/2urpy3/name_a_data_structure/
09:02:03 <tomphreek> just IO ()
09:02:09 <Kaidelong> no, but IO is a RandomSource so you can runRVar to get an IO Int
09:02:11 <Kaidelong> and then print that
09:02:31 <Kaidelong> so you could do
09:02:44 <tomphreek> Kaidelong: the doc says use of sample of sampleFrom preferred to runRVar
09:02:47 <Kaidelong> runVarT (randomSquare 5) >>= print
09:03:04 <Kaidelong> runRVar, I meant
09:03:35 <Kaidelong> then use sampleFrom
09:03:46 <juanpablo_> is there a way to use Aeson's Generic interface and remove prefixes during code generation?
09:03:48 <tomphreek> I can't :(
09:03:52 <juanpablo_> Or am I doomed to use TH?
09:03:53 <tomphreek> I ll try a bit more
09:04:06 <Kaidelong> what's the type error?
09:04:43 <Kaidelong> also why sampleFrom instead of sample?
09:05:13 <Kaidelong> in fact given IO's MonadRandom instance
09:05:26 <Kaidelong> you can't even do sampleFrom because you'd need to get the RealWorld
09:07:06 <Eduard_Munteanu> juanpablo_, see Options from Data.Aeson.Types, which you can use with genericParseJSON
09:09:09 * Eduard_Munteanu has to head home now
09:11:54 <tomphreek> Kaidelong: IO is RandomSource?
09:12:28 <tapuu> Is there a way to use http-client without a manager
09:14:42 <MrMetric> Hay
09:14:57 <MrMetric> How can I tell ghc to use 4 as the tab width?
09:15:30 <MrMetric> I checked Google, but all I see is discussions and arguments about tabs vs spaces
09:15:58 <tapuu> Use spaces
09:16:04 <kadoban> MrMetric: Use spaces instead? Most decent editors can do that transparently.
09:16:43 <MrMetric> tapuu, kadoban: Thanks, that really answers my question
09:17:07 <tapuu> you're welcome
09:17:33 <kadoban> MrMetric: Well, as far as I know there is no direct answer to your question. Even if you /can/ get GHC to do it, you really want code that requires a command-line switch to even compile for other people, just to get the tabs you want?
09:18:12 <MrMetric> kadoban: I'm hoping there's a setting I can put at the top of the file
09:18:49 <kadoban> Not that I know of, I'd be somewhat surprised if it exists.
09:18:50 <horny-sama> https://github.com/mr-fool/haskell/blob/master/random/random.hs <---I don't understand why it works with 'a' to 'z' but not 1 to 8
09:19:27 <horny-sama> it works with '1' to '8'
09:19:38 <josephle> ah, 1 and 8 are ambiguous, you need to give an explicit type
09:19:49 <horny-sama> but the issue is there a way to store the result?
09:19:53 <tomphreek> > :t runRVar (uniform 1 100)
09:19:55 <lambdabot>  <hint>:1:1: parse error on input ‘:’
09:20:09 <horny-sama> josephle: but if I do '1' this is a char
09:20:11 <horny-sama> not int?
09:20:21 <sinnsat> (1 :: Int)
09:20:49 <Kaidelong> @type runRVar (uniform 1 100)
09:20:50 <lambdabot> Not in scope: ‘runRVar’
09:20:50 <lambdabot> Not in scope: ‘uniform’
09:21:43 <geekosaur> so, defaulting only works when only certain standard typeclasses are involved. in this case there's a typeclass for things that can have random values, which prevents defaulting --- so you need an explicit type
09:21:47 <kadoban> horny-sama: AFAIU, number literals like ```1``` are polymorphic. They can be :: Num a => a, depending on how you use them. Sometimes defaulting helps you, or context, but if not you have to specify…something, somewhere.
09:22:38 <geekosaur> if you specify (1 :: Integer) or something like that (Int, Float, Double, whatever) then it will work
09:22:43 <MrMetric> Maybe I can just modify ghc
09:22:54 <kadoban> MrMetric: :)
09:22:58 <Kaidelong> number literals are *supposed* to default to Int when the type is ambiguous
09:23:00 <horny-sama> geekosaur: as in?
09:23:09 <Kaidelong> but I'm not sure if GHC actually does this consistently
09:23:16 <MrMetric> kadoban: I'm assuming ghc just has an 8 somewhere that I can change to a 4
09:23:17 <geekosaur> it does so whent he Report says it can
09:23:45 <geekosaur> the Report says typeclasses like Show allow it, it won't work if typeclasses not in the short list of defaulting-allowed typeclasses are involved
09:24:05 <kadoban> MrMetric: Well, even if so that seems like an awful idea to me. "You have to use this private fork of GHC to compile my code? What's different? Oh, the tab size…"
09:24:08 <geekosaur> and it's not "Int", it's whatever is listed in a `default` declaration (the default for that being Integer, Double)
09:24:34 <horny-sama> https://github.com/mr-fool/haskell/blob/master/random/random.hs <---now line 6-7 is blowing ghc off the water
09:25:22 <horny-sama>   let a = take 1 (randomRs ('1', '8') g)
09:25:22 <horny-sama>   putStrLn (show(a) ) works
09:25:30 <geekosaur> horny-sama, so did you notice that the call on line 5 looks like: randomRs ('1', '8') g
09:25:34 <MrMetric> kadoban: I don't see why it can't have an option for it already
09:25:53 <geekosaur> randomRs ('1', '8') is a partial application; its value is a gunction expecting a `g`
09:25:56 <geekosaur> *function
09:25:58 <horny-sama> geekosaur: is it possible to have a generate a new number everytime I call it?
09:26:01 <geekosaur> and functions aren't printable
09:26:30 <homesitter> OKay I found somebody to talk to
09:26:40 <horny-sama> geekosaur: https://github.com/mr-fool/haskell/blob/master/random/random.hs <---I gust print a
09:26:41 <horny-sama> :P
09:26:48 <horny-sama> :P
09:27:14 <geekosaur> yes, and the value of a is a function
09:27:23 <geekosaur> because you did not complete the call to randomRs
09:27:37 <geekosaur> you did not give it a random seed, so it's a function that takes a random seed
09:27:55 <geekosaur> > print (+1)
09:27:55 <horny-sama> geekosaur: ?
09:27:56 <lambdabot>  <IO ()>
09:28:02 <geekosaur> oh, foo
09:28:14 <horny-sama> the problem is that without the seed the number is always 7
09:28:20 <geekosaur> randomRs takes two parameters: a tuple specifying a range, and a random seed
09:28:31 <geekosaur> line 6 gives it the tuple
09:28:58 <tsani> When I do a whole bunch of reinstalls in a sandbox, cabal warns me that packages *outside* the sandbox are likely to become broken. Is it safe to ignore that?
09:28:59 <geekosaur> you did not give it the seed, so the value of "a" is a function that takes a random seed and produces a lazy list of random values
09:29:02 <horny-sama> https://github.com/mr-fool/haskell/blob/master/random/random.hs
09:29:13 <horny-sama> geekosaur: so g is the seed?
09:29:43 <Welkin> g is the generator
09:29:57 <geekosaur> randomRs does not do what you want the way you're trying to do it, anyway; since it takes a seed and produces an infinite list, you want to save the infinite list and continue to consume items from it, not run randomRs again to get a different list
09:30:12 <geekosaur> unless you want to genrrate a different random seed and feed it to the other randomRs invocation
09:30:15 <lpaste> pjdelport annotated “Reference the default implementation” with “Solution using a newtype” at http://lpaste.net/119969#a119973
09:30:54 <horny-sama> geekosaur: I am just trying to generate a random number within a range
09:31:03 <clrnd> how can I go from a git commit short hash to it's information, for e.g. it's message, using gitlib?
09:31:13 <horny-sama> and all the tutorial I am reading is like way more complicated than it has to be
09:31:17 <sinnsat> horny-sama: check out homework 12 from http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html it's about random and also explains some stuff
09:31:18 <hodapp> hrm, well, it's 'git show' at the commandline...
09:31:51 <clrnd> hodapp, yeah I mean using gitlib
09:31:56 <bitonic> what was that recent extension to unbox "small" strict fields?
09:32:16 <hodapp> clrnd: yeah, I know you mean gitlib, it was just a guess tossed out there on the chance it might translate over somehow
09:32:35 <geekosaur> let rs = randomRs ('1', '8') g; print (take 10 rs); let (a, rs') = rs; putStrLn (show a); {- do more stuff with rs' here -}
09:32:51 <clrnd> hodapp, lol (I did consider parsing the output of `git` but it's just so cheap)
09:32:59 <geekosaur> whoops
09:33:05 <geekosaur> let (a:rs') = ...
09:33:11 <clrnd> and gitlib is just so complicated
09:33:34 <geekosaur> it's "complicated" only if you're thinking about it from completely the wrong direction...
09:33:50 <horny-sama> Random randGen = new Random();
09:33:51 <horny-sama> int dieRoll = 1 + randGen.nextInt(6); <---wish haskell has something as simple as that
09:34:09 <shiona> why
09:34:15 <fresheyeball_> @pl (\x -> "( " <> show x <> " )" )
09:34:16 <lambdabot> (<> " )") . ("( " <>) . show
09:34:19 <shiona> you already have a ton of languages that do that
09:34:24 <dfeuer> Why does Data.List have init and last but not unsnoc?
09:35:02 <clrnd> horny-sama, do { randomRIO (0,6) :: Int >>= print } -- look, it's even easier!
09:35:32 <clrnd> I think you can even avoid the type
09:35:43 <clrnd> > randomRIO (0,6)
09:35:44 <lambdabot>  <IO Integer>
09:35:45 <lpaste> dfeuer pasted “unsnoc” at http://lpaste.net/5013416226840379392
09:35:51 <geekosaur> heh
09:35:52 <clrnd> > randomRIO (0,6) >>= print
09:35:53 <lambdabot>  <IO ()>
09:36:00 <geekosaur> still not gonna work
09:36:06 <geekosaur> :t randomRIO (0,6)
09:36:07 <lambdabot> (Random a, Num a) => IO a
09:36:08 <horny-sama> geekosaur: ur's blow on on me
09:36:43 <horny-sama> https://github.com/mr-fool/haskell/blob/master/random/random.hs
09:37:09 <geekosaur> you did catch my correction right afterward? (a,rs') should be (a:rs')
09:37:23 <sinnsat> horny-sama: you removed "g <- getStdGen"
09:37:28 <horny-sama> noooo
09:39:05 <horny-sama> https://github.com/mr-fool/haskell/blob/master/random/random.hs
09:39:10 <horny-sama> still no goal
09:39:30 <horny-sama> from two lines of code to like a million line for a simple random number gen
09:39:31 <horny-sama> :<
09:40:10 <geekosaur> line 5 should have stayed as is...
09:40:13 <clrnd> horny-sama, oh cmon what's with the negative attitude :P
09:40:24 <geekosaur> can I suggest you start off with a Haskell tutorial?
09:40:43 <geekosaur> Prelude System.Random> do {g <- getStdGen; let {rs = randomRs ('1', '8') g}; print (take 10 rs); let {(a:rs') = rs}; putStrLn (show a)}
09:40:43 <geekosaur> "3764828718"
09:40:43 <geekosaur> '3'
09:40:44 <sinnsat> I already liked one above...
09:40:50 <sinnsat> s/liked/linked/
09:40:52 * hackagebot libgraph 1.4 - Store and manipulate data in a graph.  http://hackage.haskell.org/package/libgraph-1.4 (faddegon)
09:41:20 <horny-sama> geekosaur: I was reading the tutorial
09:42:28 <horny-sama> geekosaur: but the issues remind the same
09:42:34 <horny-sama> the number is always the same
09:42:50 <geekosaur> yes, you never update the generator
09:42:56 <geekosaur> someone pointed you at randomRIO earlier
09:43:16 <horny-sama> https://github.com/mr-fool/haskell/blob/master/random/random.hs
09:43:16 <geekosaur> which uses a "hidden" generator (hence must be in IO) and updates it as needed
09:43:34 <horny-sama> geekosaur: clrnd did but his attempt fail?
09:43:34 <sinnsat> horny-sama: in the link I gave you it is explained how the Random stuff works with states
09:43:54 <horny-sama> http://www.seas.upenn.edu/~cis194/fall14/spring13/hw/12-monads.pdf
09:43:56 <horny-sama> right
09:44:28 <sinnsat> it's quite similar to the state monad
09:44:30 <clrnd> horny-sama, what geekosaur is trying to teach you is the "correct" way, but what I told you works
09:45:07 <clrnd> do { r <- randomRIO (0,6) ; print r ; r2 <- randomRIO (7,9) ; print r2 }
09:45:50 <Kaidelong> oh look Cale, the University of Pennsylvania is making students download your library
09:45:57 <tomphreek> how to get this instance RandomSource IO (Gen RealWorld)?
09:46:22 <geekosaur> uhhhhh
09:46:27 <geekosaur> you don't
09:46:37 <geekosaur> what did you do that thinks it wants that instance?
09:46:46 <Kaidelong> the instance is given for you
09:47:00 <geekosaur> Gen RealWorld? really?
09:47:14 <horny-sama> clrnd: it blow up on my ghc
09:47:38 <sinnsat> horny-sama: do it in ghci first... just do "randomRIO (0, 6)" in there multiple times
09:47:46 <Kaidelong> @hoogle randomRIO
09:47:46 <lambdabot> System.Random randomRIO :: Random a => (a, a) -> IO a
09:48:12 <Kaidelong> clrnd: horny-sama's assignment specifically mandates the use of MonadRandom
09:48:22 <tomphreek> runRVar :: RandomSource m s => RVar a -> s -> m a. I have RVar a, I need s
09:48:26 <Kaidelong> so I don't think he's supposed to be using randomRIO
09:48:34 <Kaidelong> tomphreek: use sample
09:48:36 <horny-sama> clrnd: Prelude System.Random> ranadomRIO(0,6)
09:48:36 <horny-sama> <interactive>:4:1:
09:48:36 <horny-sama>     Not in scope: ‘ranadomRIO’
09:48:36 <horny-sama>     Perhaps you meant one of these:
09:48:36 <horny-sama>       ‘randomRIO’ (imported from System.Random),
09:48:36 <horny-sama>       ‘randomIO’ (imported from System.Random),
09:48:38 <horny-sama>       ‘randomR’ (imported from System.Random)
09:48:42 <clrnd> ok I didn't know, I'd suggest he reads a little first then
09:48:44 <horny-sama> Kaidelong: I doubt it
09:49:07 <sinnsat> Kaidelong: I just pointed him to that assignment for better understanding of how random works... I think he doesn't have a specific assignment
09:49:09 <geekosaur> horny-sama, "ranadomRIO" is not "randomRIO"
09:49:13 <Kaidelong> MonadRandom is a really simple library to pick up
09:49:23 <Kaidelong> sinnsat: oh, oops!
09:49:24 <horny-sama> oooo typo
09:49:28 <geekosaur> it even includes the correct spelling of your typo in the error message
09:49:32 <clrnd> lol
09:50:07 <sinnsat> ghci has tab-completion
09:50:35 <Kaidelong> tomphreek: oh, there is an s for IO provided for you, btw, it's called StdGen
09:50:51 <Kaidelong> see what happens if you pass StdGen to runRVar
09:50:54 <horny-sama> clrnd: the issue is the same still always the same number
09:51:09 <sinnsat> horny-sama: do you run a windows kernel? :P
09:51:16 <horny-sama> sinnsat: fedora
09:51:17 <hodapp> I think my code made hlint explode
09:51:28 <horny-sama> what about let generator = mkSTDGen 0
09:51:57 <Kaidelong> tomphreek: to get a StdGen, you can use getStdGen or newStdGen
09:52:05 <clrnd> horny-sama, paste your code
09:52:39 <dfeuer> Could someone give me a sense of how "unsnoc" and "unsnocNormal" should compare in http://lpaste.net/5478247480585879552 ?
09:52:43 <horny-sama> clrnd: https://github.com/mr-fool/haskell/blob/master/random/random.hs
09:53:00 <horny-sama> now I have a seed but still the same result :<
09:53:36 <Kaidelong> also
09:53:38 <Kaidelong> runRVar x StdRandom === sampleRVar
09:53:45 <Kaidelong> this equation is in the docs
09:53:56 <horny-sama> Kaidelong: ?
09:53:58 <Kaidelong> so you can use StdRandom, too
09:54:01 <sinnsat> horny-sama: you don't run the code clrnd gave you
09:54:08 <Kaidelong> horny-sama: this is for tomphreek
09:54:13 <horny-sama> sinnsat: coz it did even compile
09:54:29 <sinnsat> horny-sama: then you mistyped it :P
09:54:59 <horny-sama> sinnsat: works on ghci but not ghc
09:55:19 <clrnd> horny-sama, let (a, g) = next generator ; print a; let (a, g) = next g; print a
09:55:21 <horny-sama> https://github.com/mr-fool/haskell/blob/master/random/random.hs
09:55:24 <clrnd> you need to call next
09:55:39 <horny-sama> clrnd: ok
09:55:53 <clrnd> horny-sama, oh for that you need to call it `randomRIO (0,6) :: Int`
09:56:02 <tomphreek> Kaidelong: I think docs are slowly clearing up :)
09:56:14 <clrnd> that's because randomRIO is polymorphic on it's return type
09:57:04 <sinnsat> I think it's :: IO Int
09:58:05 <clrnd> yes sorry horny-sama ^ `r <- randomRIO (0, 6) :: IO Int`
09:58:15 <horny-sama> clrnd: fpaste?
09:58:52 <clrnd> ok wait a sec
09:59:19 <horny-sama> clrnd: https://github.com/mr-fool/haskell/blob/master/random/random.hs
09:59:28 <horny-sama> still 1 1 all the time
09:59:36 * horny-sama blows his face @ haskell compiler
10:00:06 <clrnd> horny-sama, ofc, r1 is just a variable
10:00:15 <tsani> Has anyone used HaskellNet-SSL with unsigned certificates before? I'm having a hard time getting it to use TLS with my server (which has a self-signed certificate)
10:00:22 <clrnd> in most languages variables don't change by themselves their value
10:00:25 <NemesisD> what's that category theory joke in haskell. its some ridiculously long term that has either zoo or hippo in it
10:00:45 <clrnd> zygoismorphism I think NemesisD
10:00:46 <geekosaur> no, there's magic global hidden state
10:00:47 <horny-sama> so I should do let r1 = randomRIO (0,6)
10:00:59 <geekosaur> zygohistomorphic prepromorphism?
10:01:13 <NemesisD> yeah!
10:01:41 <horny-sama> clrnd: just fpaste it if you don't mind
10:02:00 * horny-sama is now in confuse and frustrated mode
10:02:08 * horny-sama drinks some more red bull
10:02:12 <sinnsat> horny-sama: r1 is then of type (IO Int), not Int
10:02:24 <horny-sama> sinnsat: okay
10:02:28 <clrnd> horny-sama, http://lpaste.net/119974
10:02:48 <horny-sama> clrnd: i have that and it works
10:03:02 <clrnd> horny-sama, ok, what's next?
10:03:09 <horny-sama> but the issue is I want the variable to change everytime I call it
10:03:40 <clrnd> horny-sama, ....you want it to also print itself?
10:03:41 <sinnsat> call what? main?
10:03:44 <Peaker> horny-sama: Randomizing a number via randomRIO is an action in the IO type. r <- randomRIO..   randomizes once, and puts the result into "r" which is then immutable
10:03:57 <horny-sama> clrnd: let would be nice :P
10:04:08 <Peaker> horny-sama: variables don't change themselves, but they can represent computations that can be re-run repeatedly
10:04:14 <horny-sama> Peaker: so there is no time to change it :<
10:04:26 <johnw> clrnd: ping
10:04:29 <johnw> clrnd: if you want to join me in gitlib, I'd be happy to answer your questions
10:04:29 <horny-sama> Peaker: exactly, but the issues is how do I do that
10:04:36 <Peaker> horny-sama: you can say:  let randomize = randomRIO (0, 6)    and now "randomize" is *not* a random number, but an IO computation that when executed, *will* randomize a number
10:04:41 <johnw> clrnd: uh, I meant #gitlib :)
10:05:01 <Peaker> horny-sama: then you can say:  r1 <- randomize ; r2 <- randomize ; r3 <- randomize    to get 3 random numbers
10:05:02 <clrnd> johnw, oh yes please!
10:05:54 <horny-sama> Peaker: still the same number
10:06:12 <Peaker> horny-sama: r1, r2, r3 will be different numbers (most of the time :-) )
10:06:13 <horny-sama> https://github.com/mr-fool/haskell/blob/master/random/random.hs
10:06:36 <Peaker> horny-sama: http://xkcd.com/221/
10:06:38 <horny-sama> Peaker: I want r to be different number everytime I call it or at least most of the time
10:07:02 <horny-sama> Peaker: I know pseudo-random numbers :P
10:07:04 <Peaker> horny-sama: you can't have a variable that changes whenever its read
10:07:18 <Peaker> horny-sama: you (sort-of) have to have another "<-" for each randomization
10:07:27 <horny-sama> Peaker: that sucks
10:07:30 <Peaker> horny-sama: you can define   printRandomNumber = print =<< randomize
10:07:46 <Peaker> horny-sama: and then you can say:  do { printRandomNumber ; printRandomNumber ; printRandomNumber }
10:07:51 <horny-sama> Peaker: got it
10:08:15 <horny-sama> https://github.com/mr-fool/haskell/blob/master/random/random.hs
10:08:16 <Peaker> horny-sama: the idea is for the code not to lie. A guarantee that a variable is always bound to an immutable value is a huge help when reasoning about code
10:08:16 <horny-sama> works
10:08:32 <horny-sama> thx everyone
10:08:36 <Peaker> horny-sama: yeah, because those are two different 'r' variables, the latter shadows the former
10:08:57 <sinnsat> I think he should read about state monad
10:08:59 <horny-sama> Peaker: now I have the test case it is time to try to implement it into the bigger code
10:09:32 <Peaker> horny-sama: note: the benefit of the Haskell approach, is that if "r" is of type "Int", you know it is an Int, and not some bizarre "number that changes"
10:09:59 <sinnsat> horny-sama: I like https://www.youtube.com/watch?v=ZhuHCtR3xq8 and https://www.youtube.com/watch?v=XxzzJiXHOJs for Monad/State-Monad explanation
10:10:19 <horny-sama> Peaker: I think haskell might get phrase out once functional programming takes off
10:10:29 <horny-sama> since hybrid langauge is the way to go :
10:10:32 <horny-sama> :}
10:10:39 <Peaker> horny-sama: well, obviously Haskellers would disagree :)
10:11:06 <Peaker> horny-sama: hybrid, in my view means: "We let the types lie to make it slightly easier to write code, and infinitely harder to read/maintain it"
10:11:12 <horny-sama> now I need food before I got phrase out
10:11:20 <geekosaur> horny-sama, hidden global state is "great" if laziness trumps correctness for you
10:11:36 <geekosaur> granted, it does for many... which is why web sites are full of security holes and weird bugs
10:11:41 <Peaker> horny-sama: Haskell lets you do all these things, you just have to be a bit more explicit about where crazy stuff (like non-determinism) is thrown in, to help future readers/maintainers
10:11:43 <sinnsat> hybrid languages are terrible... they allow a lot of stuff, but don't do anything of it properly
10:12:00 <sinnsat> It would be more important to make connecting different languages easier
10:12:02 <sinnsat> not mixing them
10:12:25 <tomphreek> :t runRVar (Data.Random.uniform 1 100) getStdGen -- :: (Distribution Uniform a, RandomSource m (IO StdGen), Num a) => m a. I want IO to be in place of m...
10:12:27 <lambdabot> Not in scope: ‘runRVar’
10:12:40 <Peaker> horny-sama: imagine a language letting you do something you want in a handful of locations, saving you a bit of pain there, and adding a huge pain and potential for unknowns in the rest of the code that doesn't need it. Every line you read might mean something crazy! Just for these handful of locations
10:13:12 <Peaker> horny-sama: languages should be as restrictive and rigid as they possibly can, while still allowing the full expressiveness you need
10:13:21 <horny-sama> imagine if I don't get food within 15mins
10:13:24 <dlowe> that's a statement of faith
10:13:25 <horny-sama> I will be die
10:13:42 <davean> horny-sama: I only object if you are saying the second follows from the first
10:13:49 <sinnsat> Peaker: expressiveness also has a trade-off in terms of readability
10:14:13 <Peaker> sinnsat: is it not the same trade-off I mentioned?
10:14:26 <Peaker> dlowe: what is a statement of faith?
10:14:39 <dlowe> " languages should be as restrictive and rigid as they possibly can, while still allowing the full expressiveness you need"
10:15:11 <Peaker> dlowe: well, language power that you don't use is a huge burden for everyone that reads the code, be it humans or compilers/optimizers
10:15:25 <Peaker> dlowe: do you disagree with that?
10:15:25 <dlowe> I mean, so is "languages should be as expressive as possible, without bounds"
10:16:04 <Peaker> dlowe: I think everyone can/should agree that unused power is a downside for reading, maintaining, reasoning and optimizing
10:16:30 <Peaker> dlowe: and if they do -- it follows from that that we should strive to constrain power around the need for it, and no more than that
10:16:54 <dlowe> I don't agree with the premise, no.
10:17:44 <Peaker> dlowe: for optimizers, it's pretty obviously correct..  the power to distinguish object identities, and have mutability everywhere, means the optimizer cannot optimize "filter (const True)" to "id"
10:18:13 <dlowe> and I think that a programmer may decide for themselves where the power needs constraining.
10:18:15 <Peaker> readers can assume much less about the code
10:18:30 <Peaker> dlowe: I really recommend this talk: https://www.youtube.com/watch?v=TS1lpKBMkgg
10:18:40 <sinnsat> I think a lot of the expressiveness that we have in haskell isn't an actual design decision, but comes from it's nature of abstraction. And it has downsides. Like 20+ ways to express function composition.
10:18:52 <Peaker> dlowe: it's about Scala, but it's mostly about the unconstrained power in Scala and how problematic it is
10:19:46 <dlowe> I think your constrictive viewpoint is valid and valuable, but I don't think it's an objective truth
10:20:00 <dlowe> maybe I'll be convinced at some later date
10:20:13 <Peaker> dlowe: I think it's an objective truth, but proving it would be hard work :-)
10:20:19 <horny-sama> o fuck it, I will let my teammates figure out the rest of the assignment
10:20:22 <horny-sama> I have done a lot
10:20:36 <Peaker> dlowe: watch the talk, though, it's good!
10:20:40 * horny-sama is an "idea guy"
10:20:49 <dlowe> I'll put it in the queue :)
10:21:17 <horny-sama> uni time
10:21:18 <horny-sama> afk
10:22:48 <joneshf-laptop> If i've got a sum, say `data Foo = A | B | C` and i want to parse a string to `Foo`, is there a way to ensure it's exhaustive?
10:23:20 <sinnsat> so I think haskell allows way more expressiveness than is actually needed
10:23:30 <bitemyapp> joneshf-laptop: probably not in the way you're thinking
10:23:46 <bitemyapp> joneshf-laptop: because it's not necessarily the case that a String *should* be able to become all inhabitants of a sum, it's an arbitrary assertion.
10:24:16 <bitemyapp> joneshf-laptop: you can see this with JSON, actually.
10:24:30 <sinnsat> but I don't think there is a reasonable way to restrict it... other than through project policies
10:25:05 <joneshf-laptop> bitemyapp, well, i mean exhaustively parsed to a data type, like I didn't miss any of the cases in the data type.
10:25:12 <joneshf-laptop> bitemyapp, not so much that the parse is exhaustive
10:25:16 <joneshf-laptop> err total
10:26:16 <zq> how does one derive a standalone Show instance for a non-Show ADT?
10:26:46 <kadoban> zq: You don't, as far as I know. You have to specify the show instance manually in that case.
10:26:52 <horny-sama> btw, learning haskell is an eye opening experience for me
10:27:01 <horny-sama> despite knowing a few langauges already
10:27:55 <zq> kadoban: why can't i invoke, "deriving instance Show (...)"?
10:29:04 <tomphreek> sampling within IO monad should return IO Int and then binding it to print should result in IO (). Why does this not work? main = sample (uniform 1 100) >>= print
10:29:19 <Xe> tomphreek: IO is not a monad
10:29:45 <c_wraith> Xe: that's a fascinating statement. What do you mean?
10:30:15 <Xe> http://blog.jle.im/entry/io-monad-considered-harmful
10:30:34 <chpatrick> it's still a monad
10:30:41 <prophile> IO is most definitely a monad
10:30:43 <kadoban> Xe: That's…incredibly badly worded. IO /is/ in fact a monad.
10:30:50 <prophile> even if calling it "the IO monad" is a little misleading
10:31:17 <chpatrick> you can call it just IO if you like but saying it's a monad is still correct
10:31:19 <kadoban> zq: I'm not sure what you mean, sorry. Can you pastebin some short code demonstrating what you're trying to do and what's not working?
10:31:28 <zq> :t return :: a -> IO a  -- Xe oops it's a monad after all
10:31:29 <lambdabot> a -> IO a
10:31:31 <prophile> tomphreek: what's the type of sample
10:31:45 <prophile> and in what way does it not work?
10:31:50 <hodapp> err, I'm not sure if one guy's polemic is really sufficient to say emphatically that IO is not a monad
10:31:51 <tomphreek>   :: (Distribution d t, Data.Random.MonadRandom m) => d t -> m t
10:32:07 <lucs> Sloppy use of "is".
10:32:27 <clrnd> I wonder, can I break the monad laws with IO? since it's so nasty ...
10:32:40 <hodapp> Also, the same link says that lists aren't monads.
10:32:49 <c_wraith> clrnd: with things like unsafeInterleaveIO, yes
10:32:55 <prophile> hodapp: well, that's arguably true
10:32:55 <zq> stupid cargo cultism
10:33:00 <jedai42> tomphreek: is IO an instance of MonadRandom ?
10:33:12 <prophile> [] is a monad but any particular list isn't a monad
10:33:31 <prophile> tomphreek: and what's the error?
10:33:57 <prophile> jedai: answering for him (sorry), it is
10:34:05 <prophile> https://hackage.haskell.org/package/MonadRandom-0.3.0.1/docs/Control-Monad-Random-Class.html#t:MonadRandom
10:34:12 <tomphreek> yep it is
10:34:54 <tomphreek> prophile: very long and unreadable error
10:35:08 <prophile> tomphreek: could you put it into a pastebin of some description?
10:35:12 <jedai> ok, so it should work so what's the error (just paste it somewhere (hpaste)
10:35:24 <prophile> I suspect it's an ambiguous type
10:35:39 <prophile> ie it's (Num n) => IO n rather than IO Int or something along those lines
10:37:15 <bitemyapp> joneshf-laptop: that's what I was replying to.
10:37:56 <bitemyapp> joneshf-laptop: consider what I said more carefully. It is not always the case that a serialized representation of a datatype will necessarily have the possibility of becoming every possible inhabitant of that datatype.
10:38:04 <bitemyapp> joneshf-laptop: reflect on it.
10:38:36 <jedai> prophile: yes, looking at Distribution, this is quite ambiguous (though shouldn't defaulting works it out ?)
10:39:16 <prophile> perhaps not, but if not it's not disastrous—(sample (uniform 1 100) :: IO Int) should do the trick
10:40:07 <lpaste> tomphreek pasted “error” at http://lpaste.net/119979
10:40:42 <tomphreek> took some time to extract the relevant bit
10:40:50 <hodapp> I'm still not sure what exactly this guy's point is in that polemic about IO not being a monad.
10:41:58 <barrucadu> It's not about IO not being a monad, it's against the term "the IO monad"
10:42:02 <vanila> IO is a monad
10:42:09 <barrucadu> Yes, it is
10:43:24 <lucs> hodapp: It would be similar to someone saying "the transcendental number pi" instead of just "the number pi" -- sure, it's true that pi is transcendental, but in most cases it's irrelevant.
10:44:01 <HeladoDeBrownie> i think "in a monad" is another phrase to be stricken from our vocabulary
10:44:02 <hodapp> who is this guy, Dr. Harper while completely wasted?
10:44:36 <joneshf-laptop> bitemyapp, d you mean in the general case? I'm fine with that. I'm more interested in a specific case, where my data type looks like `data Foo = A | B | C`, modulo renaming.
10:45:25 <joneshf-laptop> bitemyapp, it represents characters from english, so in this specific case it should be possible, right?
10:45:32 <joneshf-laptop> bitemyapp, or am i missing what you're saying?
10:46:05 <HeladoDeBrownie> although i think it may also be wrong to say either "IO is a monad" or "IO is a Monad". in the former case, we might say "IO gives rise to a monad", and in the latter, "there is a Monad instance for IO". however those are long, thus the abbreviation involving "is" seems convenient, as long as we don't forget what we really mean.
10:47:14 <vanila> There is a monad instance for IO
10:47:55 <tapuu> Is it possible to use viewpatterns inside a case?
10:48:08 <lpaste> tomphreek pasted “forgot Data.Random.Source.IO import” at http://lpaste.net/119980
10:50:22 <hape01> how do I initialize the hoogle database i created with "hoogle data" ?
10:50:41 <hape01> don't know where this is stored, which i could remoev
10:50:56 * hackagebot OpenGLRaw 2.0.0.0 - A raw binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGLRaw-2.0.0.0 (SvenPanne)
10:50:58 * hackagebot OpenGL 2.10.0.1 - A binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGL-2.10.0.1 (SvenPanne)
10:51:00 * hackagebot GLUT 2.6.0.1 - A binding for the OpenGL Utility Toolkit  http://hackage.haskell.org/package/GLUT-2.6.0.1 (SvenPanne)
10:51:17 <tomphreek> prophile: sorry didn't notice you answered me already. thanks a lot
10:51:28 <prophile> tomphreek: no worries, did that work?
10:51:32 <tomphreek> yes
10:51:37 <prophile> shiny
10:52:13 <HeladoDeBrownie> hodapp, oh, were you referring to the linked article?
10:52:33 <tomphreek> so if I see ambiguous error, just sprinkle the code with explicit types as a quick fix?
10:52:39 <HeladoDeBrownie> hodapp, the article is not making the point that "IO is not a Monad", it's making the point that "IO monad is a needlessly overused phrase in a way that is harmful"
10:52:49 <bitemyapp> joneshf-laptop: exhaustivity checking in Haskell is about pattern matching on a sum type
10:53:26 <bitemyapp> joneshf-laptop: There might be a way to enforce exhaustivity of *construction*, but I don't know how to do so in Haskell. It would require some wrangling. Best to just get the job done and review later.
10:53:46 <vanila> its not harmful
10:54:15 <HeladoDeBrownie> vanila, would you like to offer a rebuttal of why not?
10:54:31 <vanila> because it is accurate
10:55:01 <HeladoDeBrownie> when accurate, it's not harmful. however, it's often used in ways that are inaccurate, as in many examples cited in the article.
10:55:07 <lucs> vanila: Perhaps it's harmful pedagogically.
10:55:19 <joneshf-laptop> bitemyapp, hmm, that's unfortunate. But I guess makes sense
10:55:21 <HeladoDeBrownie> "how do i print to the screen?" "with the io monad" is just plain wrong.
10:56:08 <vanila> I would say: with 'print'
10:56:11 <NightRa> How does cabal find C libraries and how to find out why it doesn't find one when installing a package?
10:56:12 <hodapp> HeladoDeBrownie: If that's the point of the article, I completely missed it in all the hyperbole.
10:57:14 <HeladoDeBrownie> well say the question were "how do i do i/o?" instead. equally wrong.
10:57:24 <HeladoDeBrownie> as a general question about how haskell works.
10:57:42 <HeladoDeBrownie> a correct answer would be "the io type".
10:57:52 <geekosaur> NightRa, looks in platform standard directories, which can be extended with --extra-lib-dirs, if it's a pkgconfig package then it checks pkg-config and you can extend that search path the usual way ($PKG_CONFIG_PATH)
10:58:05 <geekosaur> on windows, $DEITY help you; "standard locations" are not a thing
10:58:34 <NightRa> geekosaur: $DEITY as an environment variable?
10:58:40 <NightRa> geekosaur: Yes, I'm on windows
10:58:41 <clrnd> it's about the word `monad` where it doesn't matter
10:58:53 <NightRa> geekosaur: Context: https://github.com/skogsbaer/hscurses/issues/22
10:58:57 <geekosaur> ........
10:59:17 * geekosaur suspects what he said there just got horrifically misparsed as something useful...
10:59:30 <gregnwosu> how do i build an executable in cabal?
10:59:38 <NightRa> geekosaur: :)
10:59:57 <HeladoDeBrownie> write_janky_program ; pray $DEITY
11:00:05 <geekosaur> what "libs&includes"?
11:00:06 <NightRa> I'm stuck on this for a couple of days already
11:00:29 <NightRa> --extra-lib-dirs & the corresponding includes one
11:00:31 <gregnwosu> HeladoDeBrownie: write_janky_program && pray $DEITY surely
11:00:51 <HeladoDeBrownie> gregnwosu, pray $DEITY might retroactively make it have worked as long as you didn't observe that fact already ;)
11:02:59 <NightRa> T_T Life is soo hard on windows regarding installing c-based haskell libraries
11:03:32 <geekosaur> s/haskell//
11:03:46 <geekosaur> if windows had the concept of standard locations for C libs, a whole lot of things would be easier
11:04:01 <NightRa> It's also practically impossible to install any gui libraries
11:04:03 <geekosaur> haskell being pretty much the least part of that
11:04:57 <NightRa> So many days killed on this! Come on! I just want key input in the console!!!!
11:05:07 <toors> >
11:06:10 <NightRa> (Which could be solved easily if it were'nt for a GHC bug T_T)
11:06:12 <edwardk> NightRa: the hsqml bindings install pretty cleanly
11:09:51 <sinnsat> geekosaur: the location doesn't matter... it's just about that the system knows where they are. If they are scattered anywhere, but the system knows it, then that works too.
11:11:00 <sinnsat> and that works only through a proper abstraction level... the registry is not a real substitute for a package manager
11:11:31 <geekosaur> sinnsat, imo "the system knows about it" is the *definition" of "standard location"
11:11:41 <sinnsat> geekosaur: not really
11:12:03 <geekosaur> there can be more than one, for a number of reasons, but have at least somewhere that you can install stuff to and have it found...
11:12:44 <sinnsat> geekosaur: check NixOS... they do things a bit more complicated with non-standard locations and a lot of hackery which works only because they have abstraction for it
11:13:01 <sinnsat> not sure if that's the way to go, though
11:13:03 <geekosaur> yes, you can be utterly pedantic about the dictionary definition of "location"... if you like not adding any useful content to a discussion
11:13:25 <sinnsat> geekosaur: the content is that "standard location" != "the system knows about its files"
11:13:46 <geekosaur> nixos has its own definition of "standard location" though. location is not a hard place for most people, it's more conceptual, and the point of nixos or similar solutions is to make the definition of "location" more flexible
11:14:05 <geekosaur> but, yes, let us be horribly pedantic to (a) no point (b) ignoring the user's actual problem
11:14:27 <sinnsat> I don't think it's pedantic, but a basic difference, but anyway.
11:14:52 <geekosaur> (...never mind, I am clearly not in any condition to be trying to help anyone since I am just inviting people to be as utterly confusing to the person supposedly being helped as they possibly can)
11:16:16 <sinnsat> the point is that windows doesn't need to move to a model like FHS in order to fix these kind of problems... instead they just need a proper package manager where the software properly tells the system where which kind of files are and what they are for
11:16:36 <orzo> maybe chocolatey is the answer for windows installs
11:19:15 <sinnsat> the advantage with FHS is just one: file collisions...
11:19:56 <orzo> how do you figure
11:20:24 <orzo> seems file collisions happen as easily and often with FHS
11:21:11 <orzo> forcing packages to put all their files into one special dedicated tree would make it less likely
11:21:27 <sinnsat> orzo: yes... but file collisions have advantages too
11:23:06 <sinnsat> if you can have 200 different copies of libz.so then you need more abstraction to figure stuff out, e.g. which of them are affected by a vulnerability
11:23:11 <sinelaw> What's a simple way to add type classes to an HM inference/checking algorithm?
11:23:15 <sinelaw> Any nice references?
11:23:48 <sinelaw> for example, without higher kinds
11:24:31 <sinnsat> FHS just gives an easier way to think about the state of the system
11:25:35 <orzo> FHS is full of strange warts
11:25:37 <sinnsat> (and leads to people hardcoding library locations in their build system instead of using pkg-config etc)
11:26:10 <sinnsat> FHS is basically outdated and doesn't reflect any modern linux distro... all of them deviate
11:26:12 <Peaker> Kaidelong: every (non-trivial) transformer's primitive needs to be lifted through every other transformer, and I don't think you can auto-generate this code in the general case
11:26:27 <Peaker> so the N^2 problem sounds inherent, and not an artifact of a bad encoding
11:26:30 <sinnsat> but there's no one interested in working on it
11:26:40 <Peaker> agocorona: let's move the #blah discussion here?
11:27:22 <Peaker> agocorona: what better way do you have than callCC to express continuations?
11:28:20 <orzo> i've only used callCC when translating C++ code and rewrote when i understood it better
11:30:14 <agocorona> Peaker I did it for injecting events in a monadic expression
11:30:48 <agocorona> you can see the monad here: https://www.fpcomplete.com/user/agocorona/monad-reactive-programming-2
11:30:57 * hackagebot debian 3.85.2 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.85.2 (DavidFox)
11:32:04 <agocorona> At least it is somewhat easier to use
11:34:55 <agocorona> basically I keep individual statements of te monadic expression in a state monad. The state for each point  in the computation has the  closure (x) and the rest o the statements that are after. when an event arrives at that point, I fire again the monad from this point on
11:37:42 <NightRa> https://github.com/skogsbaer/hscurses/issues/22#issuecomment-72922409
11:39:29 <agocorona> I have refined the idea for multithreaded monads, that respond to events concurrently
11:40:17 <agocorona> That is amazing, because I can perform asyncronous cocurrent computations and still be composable
11:41:26 <agocorona> an event above in the flow would invalidate what is below, that means that the threads running below must be killed.. I´m doing that right now
11:41:34 * HeladoDeBrownie wonders if it was bad tutorials, missteps in tutorials, or a flaw of people's intuition that originally proliferated the overuse of the word "monad". maybe a combination thereof.
11:42:03 <HeladoDeBrownie> (not referring to any overuse in particular, just in general)
11:42:53 <sinelaw> A monad is a tutorial
11:42:56 <sinelaw> statistically speaking
11:43:02 <HeladoDeBrownie> XD
11:43:17 <Peaker> agocorona: does it have all the power that callCC has?
11:45:02 <agocorona> Peaker:  I think so. although I do not use callCC.  I can capture the contination and I can run it later.
11:45:24 <Peaker> agocorona: callCC gives you general global "goto"
11:45:39 <Peaker> agocorona: for example, I can use "callCC" to implement Python's bidirectional generators
11:45:45 <Peaker> agocorona: can your callCC replacement do that?
11:45:58 * hackagebot hindent 4.3.6 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.3.6 (ChrisDone)
11:46:35 <agocorona> I have getCont :: IO Cont      and runCont
11:47:00 <agocorona> I can use the trick also for doing backtracking
11:47:26 <Peaker> agocorona: specific to IO?
11:47:33 <agocorona> since what I have in the state is the list of statements. I can interpret them as I please
11:47:45 <Peaker> agocorona: ContT works without IO..
11:47:48 <agocorona> Peaker:  it has`nt to be limited to IO
11:47:59 <Peaker> where do you "store" the continuation?
11:48:05 <monochrom> is "IO Cont" even legal?
11:48:05 <vanila> it's not goto
11:48:06 <agocorona> In the state monad
11:48:14 <Peaker> "callCC" does the simple thing of "storing" it in an argument
11:48:25 <prophile> ContT IO () is basically node.js
11:48:37 <Peaker> it's also bracket
11:49:01 <prophile> who knew hipster web technology could be surmised in a single function
11:49:05 <agocorona> but the syntax of callCC is weird. This is  a plain monadic expression
11:51:10 <agocorona> that has the  asyncronicity effect
11:51:13 <vanila> callCC isn't a good operator reset/shit is better
11:52:05 <sinnsat> HeladoDeBrownie: are you proposing that people should use the terms "Monad class" and "instance of Monad class"? Or do you think the class name "Monad" was not a good choice?
11:52:33 <agocorona> a monad is a form of intrincated syntactic sugar
11:52:51 <quchen> Monad was an excellent name until the public realized it's a term from mathematics
11:52:54 <hsk3> let-in allows me to do multiple variables: let a=1; b=2; c=3, in (a,b,c)
11:52:54 <hsk3> Question: Is the order of execution known in Haskell? Is a assigned first, then b, then c?
11:52:55 <hsk3> Reason for asking: Could I do   let a=1;  b=a+1;  c=b+1;   in (a,b,c)    i.e. make variables depend on others?
11:53:12 <vanila> hsk3, there is no order
11:53:21 <vanila> evaluation is driven by-need lazily
11:53:34 <vanila> yeah you can make them depend on each other
11:53:38 <agocorona> there is an article about the asyncronous effect: http://people.cs.missouri.edu/~harrisonwl/papers/mpc08.pdf
11:53:56 <hsk3> vanila: so if I just do   in (0,b,c)   a will not be used regardless of the order?
11:54:02 <sinnsat> hsk3: you can even do crazy things like: let (first,last) = go last xs first in first
11:54:02 <hsk3> so a will not be created, i mean
11:54:22 <tommd> hsk3: 'b' depends on 'a' so 'a' will be used.
11:54:27 <hsk3> ahk
11:54:30 <HeladoDeBrownie> sinnsat, not at all, just that there is a tendency to say "IO monad" instead of simply "IO" or even "IO type"
11:54:42 <HeladoDeBrownie> sinnsat, in cases where "monad" doesn't matter at all
11:55:05 <HeladoDeBrownie> e.g., "how does haskell handle i/o?" "using the io type"
11:55:10 <hsk3> sinnsat: what's "go"
11:55:14 <HeladoDeBrownie> an incorrect response would be "using the io monad"
11:55:26 <sinnsat> hsk3: check https://wiki.haskell.org/Tying_the_Knot#Migrated_from_the_old_wiki very cool
11:55:27 <agocorona> Peaker:  what my monad does is to de-invert the control so that interruptions can follow the flow, instead of breaking it
11:55:28 <clrnd> @hoogle liftIO
11:55:29 <shachaf> Nothing incorrect about "the IO monad".
11:55:29 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
11:55:29 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
11:55:29 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
11:55:36 <shachaf> It's a bit silly but so is "the IO type".
11:56:07 <shachaf> No one says "the Int type".
11:56:08 <tommd> In memory you'd have a thunk, a computation akin to 'b = [ptr to a] + 1'  then you'd  return '([ptr to b], [ptr to c])'  where c is a computation too 'c = '[ptr to b] + 1'.  This is all a bit hand-wavy but it give you some idea of what's going on if you aren't familiar with thunks or closures.
11:56:11 <Welkin> Simon Marlow mentions "the IO monad" in Parallel and Concurrent Haskell
11:56:11 <tommd> hsk3: ^^
11:56:33 <prophile> shachaf: I like to substitute other typeclasses
11:56:37 <prophile> "the Int Eq"
11:56:47 <HeladoDeBrownie> shachaf, to me, "IO Monad" refers to the Monad instance for IO, which has nothing to do with it. even if you use it to refer to IO, it still draws unnecessary attention to Monad. anyway, i said "the io type" to clarify it's a type rather than the general concept of I/O.
11:57:32 <Peaker> shachaf: well, "IO" is a bit more ambiguous than "Int"
11:57:41 <Welkin> IO is also a moon of Jupiter
11:57:47 <hsk3> thanks!
11:58:02 <bitemyapp> The IO type has semantics independent of whether you use the Monad instance or not.
11:58:28 <bitemyapp> Using the Monad instance of IO to refer to a strictly more general category (everything associated with IO-the-type) is not very precise.
11:58:35 <bitemyapp> whereas the IO type encompasses its instances.
11:58:44 <Welkin> I'd rather refer to the Jovian moon
11:59:20 <Welkin> so, we construct our expression inside of IO, then travel there to plant a flag and execute them inside the ghc runtime system
11:59:53 <Welkin> should the spacecraft we use to travel there be called main?
11:59:54 <hsk3> are ghci commands essentially haskell code within an IO monad?
12:00:26 <quchen> GHCi is a lot like being inside an IO "do" block.
12:00:36 <Welkin> hsk3: it must be, otherwise you cannot do anything in the interpreter
12:00:37 <vin-ivar> exit
12:00:38 <quchen> But not quite, you can use things like "import Foo" etc.
12:00:49 <HeladoDeBrownie> Welkin, even the Simons have been known to use the terminology very loosely. :P although i'm not faulting any specific person for it; it's a cultural phenomenon among haskellers, a curious one that seems like it would cause trouble.
12:00:51 <hsk3> quchen: ok
12:00:59 * hackagebot hindent 4.3.7 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.3.7 (ChrisDone)
12:01:13 <hsk3> quchen: so it's just a helpful analogy to say that it's the same as IO do block + other features
12:01:16 <hsk3> nothing too accurate
12:02:11 <HeladoDeBrownie> quchen, it would be kinda nice to be able to declare types locally though :P (which of course you can do in ghci but not in a do expression)
12:02:20 <sinnsat> HeladoDeBrownie: But I am not sure if it's easier for beginners to get the full precision of haskell-terminology at first.
12:02:31 <quchen> hsk3: I think of GHCi as something you can type expressions into, and some other syntax it available as well. If you're trying to write multiline "do" blocks in GHCi you should probably do so in a source file and then :l that in GHCi.
12:02:33 <monochrom> It's English. Sometimes we write simply "English", somtimes we write "the English language". The different wording sometimes reflect different emphasis, and sometimes just different writing style. Similarly for "IO", "the IO monad", "the IO functor", and "the IO type". Why do people make a big fuss?
12:02:47 <shachaf> ==monochrom
12:02:47 <sinnsat> HeladoDeBrownie: sometimes you need a few "white lies"
12:02:57 <HeladoDeBrownie> sinnsat, the goal isn't to give beginners perfect understanding all at once, it's to make an attempt at optimizing the learning environment so as to minimize misunderstandings.
12:03:04 <quchen> The Monochrom Eq
12:03:13 <hsk3> ok thanks
12:03:16 <HeladoDeBrownie> sinnsat, this isn't about white lies that are helpful, this is about terminology implying a connection that doesn't exist.
12:04:04 <HeladoDeBrownie> monochrom, i agree, i just think the emphasis should be appropriate.
12:04:14 <shachaf> It isn't even a lie.
12:04:24 <monochrom> no, sometimes it is just writing style, no emphasis.
12:05:12 <Welkin> I always say "the A instance of B" when referring to it
12:05:27 <HeladoDeBrownie> although i feel like my words may make it seem like i feel more strongly about this than i do. it's an annoyance, one that hopefully can be corrected in time to prevent problems by further clarification.
12:05:39 <tasker> How can I use lens to append an item to a list, inside a datatype ?
12:05:54 <quchen> tasker: (<>~)?
12:06:01 <hsk3> monochrom - creator of the greatest IO tutorial around: http://www.vex.net/~trebla/haskell/IO.xhtml
12:06:17 <tasker> quchen: Could be - I'm just learning lenses. I guess I was wondering what sort of terminology I should be googling for.
12:06:29 <quchen> > ("hello", 2) & _1 <>~ " world" -- tasker
12:06:30 <lambdabot>  ("hello world",2)
12:06:37 <merijn> tasker: Also: #haskell-lens
12:06:52 <tasker> merijn: Ah, good to know!
12:06:57 <quchen> tasker: Maybe this helps with Lens nomenclature, https://github.com/quchen/articles/blob/master/lens-infix-operators.md
12:07:01 <tasker> quchen: Cool, thanks.
12:08:29 <hsk3> We know that "let" in do-notation is just syntactic sugar for "let-in" in the monad >>= notation.  Is "let" in GHCi the same or something else entirely?
12:08:54 <quchen> hsk3: You can see it like that, yes.
12:09:02 <quchen> "<-" also works, by the way.
12:09:16 <hsk3> see it like the same?
12:09:58 <quchen> x <- getLine    ← works
12:11:00 <monochrom> on April 1st, I will change my IO.xhtml article so that it speaks of "the IO monadic applicative functor type". just to horiify the shit out of you!
12:11:02 <hsk3> hmm
12:11:10 <HeladoDeBrownie> XD
12:11:11 <ocramz> hi all!
12:11:15 <hsk3> heh..
12:12:08 <sinnsat> HeladoDeBrownie: I wonder if it would be more accurate if the class name was "Monadic"?
12:12:09 <HeladoDeBrownie> we should just always refer to it IO: The Type That Is Instance Of Many Typeclasses That May Or May Not Be Relevant To The Discussion At Hand
12:12:24 <ocramz> anybody here has some experience with Repa ?
12:12:37 <quchen> monochrom: Don't forget MonadPlus! Then remove MonadPlus on April 2nd.
12:12:39 <HeladoDeBrownie> sinnsat, not regarding the point i was making
12:12:47 <arw_> HeladoDeBrownie: sounds like "he who must not be named"...
12:13:05 <cmtptr> given "putRows :: [Row] -> IO ()", how do I write "putRows [] = ()" ?
12:13:23 <quchen> cmtptr: putRows [] = return ()?
12:13:24 <HeladoDeBrownie> cmtptr, return () -- is this what you want?
12:13:29 <cmtptr> ah, thanks
12:13:33 <HeladoDeBrownie> return :: () -> IO ()
12:13:37 <ocramz> :hoogle Z
12:13:57 <Iceland_jack> cmtptr: It's possible that you want "mapM_"
12:14:11 <cmtptr> that is absolutely possible
12:14:19 <cmtptr> thanks
12:15:15 <cmtptr> I don't understand how anyone is supposed to remember all of these
12:15:43 <Iceland_jack> cmtptr: It comes quite quickly
12:15:53 <cmtptr> it has not been coming quickly to me
12:16:00 <cmtptr> it's been the opposite of that
12:16:30 <Welkin> cmtptr: with practice it becomes natural
12:16:33 <Iceland_jack> You are famliar with 'map' no doubt
12:16:42 <cmtptr> yes
12:16:42 <Welkin> you'll know which to use and when without really thinking at all
12:16:51 <HeladoDeBrownie> cmtptr, expect to reference documentation a lot. i do it even for things i use often
12:16:56 <ocramz> :t map
12:16:57 <lambdabot> (a -> b) -> [a] -> [b]
12:17:02 <ocramz> :t mapM
12:17:03 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
12:17:09 <Iceland_jack> Specialised to IO:
12:17:09 <Iceland_jack>     map  :: (a ->    b) -> [a] ->    [b]
12:17:09 <Iceland_jack>     mapM :: (a -> IO b) -> [a] -> IO [b]
12:17:10 <Welkin> yes, I have spent a *lot* of time reading docs
12:17:18 <HeladoDeBrownie> cmtptr, you'll pick up on some things and remember them, others not so much. it doesn't need to be a problem
12:17:34 <Welkin> it is actually quite fun
12:17:39 <cmtptr> HeladoDeBrownie, what documentation are you referring to, exactly?  I've struggled to find a good reference source
12:17:47 <Welkin> the APIs tend to be both extensive and clean
12:17:48 <HeladoDeBrownie> cmtptr, package documentation on hackage
12:17:51 <HeladoDeBrownie> @hackage base
12:17:51 <lambdabot> http://hackage.haskell.org/package/base
12:17:52 <Welkin> at least for base
12:18:12 <cmtptr> thanks again
12:18:29 <ocramz> @hoogle Z
12:18:30 <lambdabot> Control.Applicative ZipList :: [a] -> ZipList a
12:18:30 <lambdabot> Control.Applicative newtype ZipList a
12:18:30 <lambdabot> Codec.Compression.Zlib module Codec.Compression.Zlib
12:18:41 <ocramz> @hoogle (:.)
12:18:41 <lambdabot> No results found
12:18:59 <merijn> cmtptr: Also, using hoogle instead of remembering works well if you can formulate what kinda type you want
12:19:08 <Welkin> @hoogle ((:.))
12:19:09 <lambdabot> Warning: Unknown type :.
12:19:09 <lambdabot> Prelude undefined :: a
12:19:09 <lambdabot> Test.QuickCheck discard :: a
12:19:18 <merijn> Welkin: That's not actually an existing function
12:19:29 <HeladoDeBrownie> i find that hoogle only works for me at most half the time though
12:19:37 <merijn> @hoogle Monad m => (a -> m b) -> [a] -> m ()
12:19:38 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
12:19:38 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
12:19:38 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
12:19:44 <merijn> HeladoDeBrownie: FPComplete has better indexing
12:19:51 <cmtptr> yeah, I was trying to use hoogle earlier but I don't think it's going to be very useful to someone as clueless as I am right now
12:20:12 <ocramz> Welkin: do you by chance use Repa? that one is a constructor for shape array
12:20:13 <ocramz> s
12:20:18 <Profpatsch> Does someone know why this doesn’t work with OverloadedStrings?
12:20:20 <Profpatsch> test :: Int -> ByteString
12:20:22 <Profpatsch> test x = pack $ intersperse " " [ "test", show x, "foo" ]
12:20:27 <Welkin> with hoogle you can search by type (a -> b -> a)
12:20:43 <Welkin> use hayoo for a general function search, since it is more extensive
12:20:44 <HeladoDeBrownie> @hoogle a -> b -> a
12:20:45 <lambdabot> Prelude const :: a -> b -> a
12:20:45 <lambdabot> Data.Function const :: a -> b -> a
12:20:45 <lambdabot> Prelude seq :: a -> b -> b
12:20:47 <merijn> Profpatsch: Because "show x" returns a String
12:20:54 <Profpatsch> It says Couldn’t mach type [Char] with Word8.
12:20:59 <merijn> Profpatsch: The *literals* are overloaded
12:21:04 <Welkin> ocramz: nope, I just thought it was an existing combinator and was curious to see what it was
12:21:07 <merijn> Profpatsch: Not arbitrary strings, that'd be dreadful
12:21:27 <ocramz> Welkin: ok :)
12:21:28 <Profpatsch> merijn: But pack takes a String!
12:21:37 <unknownloner> Profpatsch: I think its the 'show'
12:21:44 <unknownloner> try pack (show x)
12:21:51 <merijn> Profpatsch: Oh, now I see the issue: 1) intersperse isn't returning a String
12:21:54 <ocramz> anybody here that could answer a Repa question? namely, update in-place of subarrays
12:21:55 <merijn> :t intersperse
12:21:56 <lambdabot> a -> [a] -> [a]
12:22:03 <unknownloner> ah yeah
12:22:07 <unknownloner> that makes sense
12:22:09 <merijn> :t intersperse `asAppliedTo` " "
12:22:11 <lambdabot> [Char] -> [[Char]] -> [[Char]]
12:22:14 <Profpatsch> unknownloner: Ah, that doesn’t work.
12:22:18 <merijn> That's [String], not String
12:22:22 <merijn> Profpatsch: More importantly
12:22:31 <Welkin> :t intersperse
12:22:32 <chpatrick> Profpatsch: you want Data.ByteString.Char8
12:22:32 <lambdabot> a -> [a] -> [a]
12:22:37 <Welkin> :t intercalate
12:22:37 <lambdabot> [a] -> [[a]] -> [a]
12:22:50 <merijn> Profpatsch: "pack" accepting a String means you are using BS.Char8 ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ
12:23:02 <merijn> chpatrick: He most definitely does not want that and you should feel bad too ಠ_ಠ
12:23:12 <unknownloner> dat unicode
12:23:13 <unknownloner> wut
12:23:14 <merijn> Char8 is filled with lies, latent bugs and regrets
12:23:19 <Iceland_jack> lol
12:23:21 <HeladoDeBrownie> merijn, i've imported that before, can i get a look of disapproval too?
12:23:23 <Profpatsch> merijn: I’m using Data.ByteString.
12:23:39 <merijn> https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad
12:23:49 <Profpatsch> So this has the same error:
12:23:51 <Profpatsch> test :: Int -> ByteString
12:23:53 <Profpatsch> test x = pack $ show x
12:23:56 <quchen> merijn: :-)
12:23:58 <merijn> Profpatsch: Well, then pack wants [Word8]
12:24:09 <merijn> Profpatsch: So giving it a String is wrong
12:24:11 <merijn> :t BS.pack
12:24:13 <lambdabot> [Word8] -> BSC.ByteString
12:24:34 <Profpatsch> merijn: Oooooh, rigth.
12:24:43 <Profpatsch> I’m with stupid and myself.
12:25:03 <merijn> Profpatsch: You probably want "Text.Encoding.encodeUtf8 . Data.Text.pack $ show x"
12:25:10 <Profpatsch> Says all the more when I look at my imports: import Data.ByteString (pack, ByteString)
12:25:19 <merijn> Or whatever encoding you wanted instead of utf8
12:25:51 <HeladoDeBrownie> come to think of it i think the only binding from Data.ByteString.Char8 i ever used was putStrLn, but i replaced that with putStr (foo <> "\n")
12:26:14 <Profpatsch> merijn: Actually the original was something like:   liftIO $ sendAll s $ pack $ intersperse " " [ show x, show y, show c ]
12:27:31 <arbelos_> I have been hacking some F# for a few days now and it is not too unpleasant. Except the OOP diversions. I kind-of like the forward pipe thing. I wonder if there is a reason why it is not used that much in Haskell. That is, let (|>) = flip ($)
12:27:39 <merijn> HeladoDeBrownie: The only real reason to use it is "I'm working with a network protocol that's all ASCII (SMTP, HTTP, etc) and want to write literals in my code, therefore I understand the terrible, terrible dangers of using Char8's IsString instance"
12:28:00 <merijn> arbelos_: (&) is being added to Data.Function soon (7.10?)
12:28:03 <merijn> :t (&)
12:28:04 <lambdabot> a -> (a -> b) -> b
12:28:14 <merijn> arbelos_: So your wish has been granted :p
12:28:17 <Profpatsch> merijn: Nice!
12:28:28 <quchen> merijn: Oh, is it? That took its time, I thought it would never land
12:28:36 <arbelos_> merijn: oh. ok. that's good news..
12:28:45 <merijn> quchen: You need to subscribe to libraries@ and ghc-devs@ ;)
12:28:48 <monochrom> "all bad things come to an end"
12:29:01 <merijn> arbelos_: It's in lens atm, I think (but then, what isn't?)
12:29:01 <quchen> \h -> writeTo h "foobar" & withFile ".bashrc"
12:29:02 <quchen> ;-)
12:29:03 <HeladoDeBrownie> all things come to an end, of which the bad are a subset
12:29:22 <quchen> merijn: I am subscribed, but I don't read all the mail
12:29:53 <quchen> merijn: The 7.10 thread in particular is something I've learned to avoid
12:30:08 <arbelos_> merijn: right. It's just interesting since it seems like a very basic pattern, and I haven't really thought about it much before I started with F#
12:30:09 <merijn> :)
12:30:21 <merijn> arbelos_: Well, neither did anyone else ;)
12:30:35 <monochrom> $ and the right-to-left order was the more basic pattern in Haskell
12:31:00 <quchen> merijn: I fear that we're going from bad to horrible the way things are right now. It's a load of last-minute bikeshedding.
12:31:00 * hackagebot Rasterific 0.4.2 - A pure haskell drawing engine.  http://hackage.haskell.org/package/Rasterific-0.4.2 (VincentBerthoux)
12:31:35 <arbelos_> yep. well, at least that was the one feature that I found useful in F#.. hehe. which is obviously not a feature that is missing in Haskell, but more of a usage pattern
12:32:10 <merijn> quchen: Naah, everyone seems to have given in
12:32:18 <arbelos_> oh. yes another thing.. the "yield" idiom..
12:32:32 <quchen> merijn: Really? What happened? Did Edward go godmode?
12:32:33 <merijn> quchen: Neil and Lennart agree that BBP breaks almost no code and changing Data.List would break a ton more
12:32:56 <arbelos_> F# does have a sort of "efficient builders" to create sequences and lists using a yield keyword..
12:32:59 <merijn> quchen: There was a skype call between a bunch of people, some emails say that basically it's
12:33:06 <quchen> I should revisit the thread then. Thanks for the pointer.
12:33:21 <merijn> arbelos_: Haskell is lazy, all lists are efficiently build like that automatically ;)
12:34:30 <ttt_fff> so I followed through http://www.stephendiehl.com/posts/vim_haskell.html ... and realized, I don't even have bsicll syntax highlighting in haskell in vim
12:34:32 <arbelos_> merijn: yes, well.. the nice thing is that you can "pick and choose" what to output to a list.. but i guess a filter does the job as well
12:34:35 <ttt_fff> (previously was using emacs)
12:34:36 <ttt_fff> how do I setup this up?
12:34:57 <merijn> ttt_fff: Which version of vim? Mine has syntax highlighting out of the box, I think?
12:35:08 <ttt_fff> merijn: vim 7.4, from brew, on osx
12:35:53 <ttt_fff> oh shit, I got it all now
12:35:55 <ttt_fff> this is intense
12:36:13 <ttt_fff> wtf
12:36:16 <ttt_fff> my editor is talking back to me
12:36:18 <ttt_fff> and telling me how to code
12:36:24 <ttt_fff> it's like "dude, you are missing a "main :: IO()"
12:36:29 <ttt_fff> then it's like "dude, you are using a redundant do
12:36:33 <dfeuer_> Is there a convenient way to pack two Word32s into a single word?
12:36:46 <arbelos_> merijn: the advantage, in terms of efficiency, would be to allow more complex data structures to be implemented using the FFI and then expose them with this builder notation or some sort of DSL.. i don't know.. i am just speculating
12:37:22 <arbelos_> with lists, yes of course.. that is pretty much redundant
12:38:09 <quchen> dfeuer_: decode (encode x <> encode y) ;-)
12:38:20 <merijn> arbelos_: You can do pretty efficient things without going into the FFI :)
12:38:23 <merijn> quchen: *bzzt*
12:38:33 <dfeuer_> quchen, I think that looks horrible.
12:38:33 <quchen> Modulo endianness
12:38:35 <merijn> quchen: encode/decode add binary specific details to the serialised output
12:38:46 <dfeuer_> Ugh.
12:38:48 <quchen> Modulo correctness
12:38:51 <dfeuer_> :-P
12:39:04 <merijn> I found this out with my parser not worker when using encode/decode
12:39:11 <merijn> The correct solution is explicit Put/Get
12:39:38 <dfeuer_> I just want  data Foo = {-# UNPACK #-} !Int32 {-# WITHTHISTOO #-} !Int32
12:39:58 <Sornaensis> <Sornaensis> can anyone tell me what this means: “Bad Interface file: /usr/lib/ghc-7.8.4/base-4.7.0.2/Prelude.hi mismatched interface file versions (wanted "7083", got "7084")”
12:40:00 <merijn> dfeuer_: Campaign for a new primop ;)
12:40:06 <arbelos_> merijn: yes, but what about, say, "in-place" semantics for example
12:40:19 <dfeuer_> merijn, I think it's more a language feature than a primop.
12:40:34 <dfeuer_> Although I could be wrong.
12:40:50 <merijn> arbelos_: You can do a lot of in-place stuff in haskell :)
12:40:58 <merijn> arbelos_: Firstly inside IO and secondly inside ST
12:40:58 <quchen> :t let f :: (Word32, Word32) -> Word64; f = \(x,y) -> fromIntegral x `shiftL` finiteBitSize x .|. fromIntegral y in f -- where do I collect my beauty prize
12:41:00 <lambdabot> (Word32, Word32) -> Word64
12:43:27 <vhuisd> hey in general for any type T a it is possible to write a function T a -> a right?
12:43:31 <tomphreek> this is more of soft que or que of style. If I have a bunch of random variables and then I realise them (sample) and then do some manipulations on samples, is IO appropriate monad to work with samples? Should the samples be IO Int or some other monad Int?
12:43:32 <vhuisd> other than impure types
12:43:51 <barrucadu> vhuisd: Nope, consider "data Foo a = Foo".
12:44:04 <merijn> Phantom types \o/
12:44:24 <vhuisd> barrucadu: why is there an a?
12:44:24 <exio4> well, you can always return undefined, right? ;P
12:44:25 <quchen> Also T = (r ->)
12:44:27 <merijn> vhuisd: Also consider "data Foo a = Foo (a -> Bool)"
12:44:36 <merijn> vhuisd: Phantom type, they're very useful!
12:44:38 <vhuisd> oh right...
12:44:50 <merijn> vhuisd: (It's called phantom because it "has no body")
12:44:58 <quchen> merijn: For example the Proxy Monad! :-D
12:45:18 <vhuisd> okay what if I match against the constructor as func T a = a ?
12:45:22 <vhuisd> where T is a constructor?
12:45:34 <quchen> ?let T a = T a
12:45:35 <lambdabot>  .L.hs:150:1: Not in scope: data constructor ‘T’
12:45:35 <lambdabot>  
12:45:35 <lambdabot>  .L.hs:150:7: Not in scope: data constructor ‘T’
12:45:35 <vhuisd> in this case if the match succeeds it should be valid right?
12:45:39 <quchen> ?undef
12:45:39 <lambdabot> Undefined.
12:45:40 <quchen> ?let T a = T a
12:45:40 <lambdabot>  .L.hs:150:1: Not in scope: data constructor ‘T’
12:45:41 <lambdabot>  
12:45:41 <lambdabot>  .L.hs:150:7: Not in scope: data constructor ‘T’
12:45:42 <quchen> :-C
12:45:44 <merijn> vhuisd: If "T a" is a constructor of some type Foo, then yes you can return that 'a'
12:46:15 <vhuisd> merijn: can you also do this for impure types?
12:46:24 <vhuisd> like IO
12:46:56 <quchen> IO isn't "impure". It's a normal type. GHC chooses to do fancy things with it.
12:47:09 <quchen> There are types that have their constructors hidden. IO is one of them.
12:47:29 <quchen> You can't pattern match on the right hand side of "data IO = Something ..." because Something is not exposed anywhere.
12:47:39 <monochrom> vhuisd: I have "newtype T a = Ctor (a -> T a)". is there a total function of type "a -> T a"? I think not. in fact, the whole point is that I have a black hole, it takes input and never gives back.
12:48:12 <merijn> quchen: Actually, IO's constructor isn't hidden, you can import it >.>
12:48:19 <quchen> shhhh
12:48:24 <monochrom> err, typo
12:48:34 <monochrom> I have "newtype T a = Ctor (a -> T a)". is there a total function of type "T a -> a"? I think not. in fact, the whole point is that I have a black hole, it takes input and never gives back.
12:48:38 <quchen> merijn: unsafesomethingsomething isn't hidden as well
12:48:43 <vhuisd> im assuming there are more impure types than IO?
12:48:51 <merijn> vhuisd: IO is not impure :)
12:48:58 <Welkin> everything in haskell is pure
12:49:00 <merijn> vhuisd: Else haskell wouldn't be a pure language...
12:49:04 <Welkin> only the runtime is impure
12:49:06 <Welkin> as far as I know
12:49:10 <monochrom> it is also fortunate that my T has nothing impure
12:49:32 <vhuisd> uhh
12:49:43 <quchen> IO allows you to build a program using the IO-using functions to build a program. The GHC runtime then exectutes that program.
12:49:53 <vhuisd> monochrom: what do you mean a total function?
12:50:00 <monochrom> people really need to knock off the prejudice that "just because the type mentions Int, its value contains an extractible Int"
12:50:21 <monochrom> "\x -> undefined" is not a total function.
12:50:31 <merijn> vhuisd: A total function is one that always returns a result from an input
12:50:35 <merijn> vhuisd: As opposed to
12:50:37 <merijn> > head []
12:50:38 <lambdabot>  *Exception: Prelude.head: empty list
12:50:53 <merijn> vhuisd: I personally rather like this summary about why IO is pure: http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity
12:51:14 <monochrom> there is really no need to go IO for an example of lack of "T a -> a"
12:51:14 <merijn> It's not flawless, but a decent starting point
12:51:59 <vhuisd> monochrom: wait are you saying that you can do T a -> a where a is a constructor?
12:52:06 <vhuisd> funct T a = a?
12:52:10 <monochrom> any phantom type, and any non-covariant type, fits the bill, and they are all pure, in all senses.
12:52:31 <monochrom> no, I cannot do. can you?
12:52:58 <vhuisd> monochrom: how is IO pure if it can change the operation of the program?
12:53:14 <monochrom> I don't care whether IO is pure or not. wrong person to ask.
12:53:23 <vhuisd> wat\
12:53:35 <monochrom> I only care "here is a type where 'T a -> a' doesn't exist"
12:53:48 <quchen> monochrom: That "covariant" there, what functor did you refer to with it?
12:53:57 <vhuisd> monochrom: i mean T is a constructor not type
12:54:26 <vhuisd> im confusing constructors and types
12:54:31 <merijn> vhuisd: "data Foo a = T (a -> Foo a)" <- how about that?
12:54:41 <monochrom> you wrote "a function T a -> a". therefore that T is a type. or at least "T a" is a type.
12:55:23 <monochrom> quchen: no functor is referred
12:55:27 <vhuisd> T so you can write a function that returns the parameter to the constructor though it wont have type a
12:56:02 <vhuisd> merijn: let me rephrase - for any constructed value you can return the parameter of the constructor using pattern matching?
12:56:05 <quchen> monochrom: Usually "co{,ntra}variant" refers to some functor in a sense, I thought you used it that way too
12:56:09 <orzo> :t (\(Just x) -> x)
12:56:10 <monochrom> ok, I'm talking cross you and you're talking cross me. I'll stop.
12:56:10 <lambdabot> Maybe t -> t
12:57:03 <merijn> vhuisd: Yes, IF the constructor is exported
12:57:10 <vhuisd> merijn: okay got it
12:57:16 <vhuisd> merijn: why is IO pure?
12:57:19 <merijn> vhuisd: You can create abstract types by not exporting the constructor, preventing you from pattern matching
12:57:35 <ttt_fff> between monads-tf-0.1.0.2 and mtl-2.1.3.1 ... which one am I supposed to hide?
12:57:50 <merijn> vhuisd: I think the best starting point is the link from earlier (http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity) and if you've read that and have questions then we can answer those :)
12:58:02 <monochrom> quchen: ok. when I have the type equation or isomorphism "T a ~ Int -> a", T is covariant in a. when I have "U a ~ a -> a", U is neither covariant nor contravariant in a. etc.
12:58:11 <ttt_fff> between monads-tf-0.1.0.2 and mtl-2.1.3.1 ... which one am I supposed to hide?
12:58:35 <vhuisd> okay ill get on that merijn thanks
12:58:54 <monochrom> in particular, U is not a functor either way, but I still need to say that U is non-covariant. therefore, one cannot restrict "non-covariant" to functors.
12:59:19 <monochrom> there can be no functor whatsoever and I still need to talk about non-covariant.
13:00:13 <quchen> Hmm, right. I've heard people call this "invariant", but nowhere around Haskell.
13:00:24 <cmtptr> is there a convention about how Instance Show output should be formatted?  Would it be discouraged to use this for program output?
13:00:38 <benzrf> cmtptr: yeah
13:00:43 <orzo> not a consistent convention
13:00:50 <cmtptr> I suspect it's really intended to generate something that can be read by Read
13:00:56 <benzrf> cmtptr: generally yes
13:01:01 <benzrf> cmtptr: or debug ouptut
13:01:03 <quchen> cmtptr: Show should format things so you can re-insert them into Haskell source code. cf https://github.com/quchen/articles/blob/master/fbut.md#show-is-not-for-prettyprinting
13:01:03 <benzrf> *output
13:01:12 <cmtptr> so what should I use for output?  just an explicit function?
13:01:20 <benzrf> cmtptr: sure
13:01:35 <orzo> seems show instances often fail in that property though
13:01:51 <csd_> How can I take a value returned by a Parser from parsec, and perform and if/else on it?
13:02:15 <orzo> you mean the value is in the Parsec monad?
13:02:22 <csd_> yes
13:02:27 <merijn> csd_: "do { val <- myParser; if val == foo then alt1 else alt2 }"?
13:02:42 <csd_> is there something equivalent for when i'm not in do notation?
13:02:56 <csd_> https://www.refheap.com/96911
13:03:11 <orzo> myParser >>= boolean alt1 alt2
13:04:26 <waxjar> trying to write an implementation for this exercism problem (https://github.com/exercism/xhaskell/blob/master/nucleotide-count/nucleotide-count_test.hs), having a bit of trouble trying to figure out how to "throw the error" (tests on line 36, 38, 54). I've been using the error function, seems to be incorrect.
13:04:52 <orzo> hm
13:04:56 <csd_> orzo-- what if i'm using guards?
13:04:57 <merijn> csd_: Why don't you fail and backtrack using try instead of trying the prefix first?
13:05:14 <merijn> csd_: So parse the #x inside parseHex instead of later
13:05:23 <csd_> because its hard to express my ideals in haskell so i just want to get something that compiles first :-P
13:05:24 <merijn> csd_: "parseHex <|> parseOct <|> ..."
13:05:26 <csd_> ideas
13:05:45 <orzo> yeah <|> is probably what you want
13:06:05 <merijn> csd_: This has 1) a related example and 2) a pitfall to be aware of: http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
13:06:39 <merijn> csd_: <|> first tries the left parser and if it fails, tries the right one
13:07:12 <csd_> i see the value of doing it your way and will probably change my code, but how would i do the binding just out of curiosity
13:07:42 <orzo> myParser >>= \case { True -> alt1 ; False -> alt2 }
13:07:55 <orzo> heh
13:08:04 <orzo> am i misunderstanding your question?
13:08:20 <csd_> oh are guards sugar for case
13:08:39 <orzo> i think so actually
13:08:44 <csd_> cool
13:08:58 <orzo> the syntax i just used requires the extension LambdaCase
13:09:48 <benzrf> :t bool
13:09:49 <lambdabot> a -> a -> Bool -> a
13:09:56 <orzo> oh, it's called bool then
13:09:59 <orzo> i was wondering that
13:10:00 <benzrf> csd_: they arent that i know of
13:10:16 <benzrf> csd_: if-expressions are probably sugar for case, though
13:10:24 <orzo> that 'bool' function is not (yet?) in the prelude i don't think
13:10:57 <merijn> orzo: It is in 7.8, afaik
13:11:13 <merijn> Yeah
13:11:13 <orzo> where's lambdabot getting it?
13:11:23 <merijn> @define import Data.Bool
13:11:24 <orzo> a search on hoogle gives a lot of noise
13:11:28 <lambdabot>  Defined.
13:11:29 <merijn> :t bool
13:11:30 <lambdabot> a -> a -> Bool -> a
13:11:52 <merijn> Careful though, bool is "Bool elimination", not "if-else", so the order is "reversed"
13:11:55 <merijn> > bool 1 2 True
13:11:57 <lambdabot>  2
13:13:39 <orzo> is there a quick combinator to rearange an elimation style function to put the success case argument so i can hang a lambda off?
13:14:44 <csd_> How would I have parsec try to parse an optional prefix #d representing decimal
13:15:12 <merijn> csd_: Did you see the link I send earlier from ezyang's blog?
13:15:15 <monochrom> "bool" uses the same parameter order as "maybe" and "either", i.e., the Bool parameter is at the end, not at the beginning
13:15:23 <monochrom> @type maybe
13:15:23 <lambdabot> b -> (a -> b) -> Maybe a -> b
13:15:24 <csd_> merijn: yeah its in my browser
13:15:43 <csd_> haven't read it yet though
13:15:56 <merijn> csd_: That has an example with try later on, showing exactly that :)
13:16:03 <orzo> yeah, but i have some code where i noticed i wrote a lot of (flip $ maybe (failcase)) $ \x -> do
13:16:07 <csd_> oh, guess i should read it then
13:16:18 <orzo> pretty awkward
13:16:29 <monochrom> you are better off writing your code for alternative parameter orders
13:16:36 <ttt_fff> http://ctags.sourceforge.net/ does not suppor thaskell does it?
13:16:42 <ttt_fff> what do you guys use for tagbar + haskell ?
13:16:51 <ttt_fff> since I am running into the problem that ctags can not generate tags for my haskell code
13:16:52 <Profpatsch> So, back to my ByteString Word8 Problem, how do I convert String to ByteString?
13:17:08 <merijn> Profpatsch: I told you that too :>
13:17:11 <monochrom> because there was one time someone thought of "how about a library of combinators standing for all permutations of parameter orders?"
13:17:20 <merijn> Profpatsch: "Text.Encoding.encodeUtf8 . Data.Text.pack $ show x"
13:17:22 <merijn> :t T.pack
13:17:24 <lambdabot>     Not in scope: ‘T.pack’
13:17:24 <lambdabot>     Perhaps you meant ‘BS.pack’ (imported from Data.ByteString)
13:17:26 <merijn> Eh
13:17:36 <Peaker> merijn: isn't there a function that skips Text?
13:17:36 <merijn> :t Data.Text.pack -- pretty please?
13:17:38 <lambdabot> String -> Data.Text.Internal.Text
13:17:44 <merijn> Peaker: I don't think so
13:17:45 <monochrom> and I cited one or two theorems from group theory (which talks about all permutations, in one perspective) to make it futile.
13:17:52 <Profpatsch> merijn: Ah, I see.
13:18:09 <merijn> Profpatsch: Well, you can pick some other encoding from Text.Encoding, obviously
13:18:17 <merijn> But something along those lines
13:18:27 <Peaker> http://hackage.haskell.org/package/utf8-string-1/docs/Data-ByteString-UTF8.html#v:fromString
13:18:31 <Profpatsch> merijn: Actually I have two Ints and one Datatype Color Word8 Word8.
13:18:34 <Peaker> though that package seems a bit terrible
13:18:36 <ned-> hello, have someone already used the vty-ui library ? (please, query me for a small question)
13:18:42 <merijn> Peaker: If you're dealing with literals you can rely on OverloadedStrings to do the pack
13:19:04 <Profpatsch> merijn: So I tought converting them through their Show instance was a good ideo.
13:19:07 <Profpatsch> *idea
13:19:14 <Profpatsch> But I’m not so sure about that now.
13:19:17 <merijn> Profpatsch: You probably want binary instead?
13:19:20 <sinnsat> ned-: public questions work better I think
13:19:24 <merijn> Profpatsch: show is for debugging
13:19:31 <Profpatsch> Okay.
13:19:34 <merijn> Profpatsch: binary is for "proper" serialisation to ByteString
13:19:45 <Profpatsch> So I should probably use something like printf ?
13:20:45 <ned-> sinnsat: ok, I find it a bit noisy here, but ok :) :
13:20:56 <ned-> I would like, for exemple, to use a confirmation dialog widget
13:20:56 <ned-> (in his own collection) for  several different purposes.
13:20:56 <ned-> But how to know where it comes from ?
13:21:00 <ned-> Is there a way to get the actual focused widget(s) of an other
13:21:00 <ned-> focusGroup ?
13:21:00 <ned-> Or is there a better way to dela with it ?
13:21:08 <Profpatsch> Basically it’s `"PX %d %d %s" Int Int (Color Word8 Word8)`
13:21:29 <Profpatsch> merijn: So I should never use show for anything but debugging?
13:22:08 <ned-> s/dela/deal
13:22:17 <merijn> Profpatsch: Probably not :)
13:25:02 <Profpatsch> Ah, Text.Printf, and Byte8 is an instance of PrintfArg.
13:33:11 <samba1> To execute in MaybeIO - I'm trying to read from the database, do something on that data that might be Nothing, and then return. This typechecks, but can I do it more tersely?
13:33:18 <samba1> do;  result <- liftIO getFromDb; MaybeT (process result)
13:33:42 <samba1> instead of liftIO, and then putting it back
13:33:42 <vanila> MaybeT . process <%> liftIO getFromDb  I think
13:33:45 <vanila> <$> *
13:33:47 <samba1> do;  result <- liftIO getFromDb; MaybeT (return $ process result)
13:34:10 <merijn> samba1: Or just "return $ process result" wrapping that in MaybeT is redundant :p
13:34:24 <Peaker> samba1: maybe process can return it in MaybeT already?
13:34:51 <samba1> merijn: I get an error trying to return like that - return expects a value, not a Maybe value
13:35:15 <mjrosenb> Cannot decode byte '\x72': Data.Text.Encoding.decodeUtf8: Invalid UTF-8 stream ... what sequence of bytes is it that it couldn't decode?
13:35:22 <samba1> Peaker: maybe. but sometimes in my cases it might be something like safeHead, which exists and which I could make but why
13:35:49 <Peaker> samba1: it sounds like "process" is actually in Maybe, not MaybeT?
13:36:14 <samba1> Peaker: yes, process just takes a regular value and returns Maybe another value
13:36:14 <Peaker> samba1: you could do a:  hoistMaybe :: Monad m => Maybe a -> MaybeT m a ; hoistMaybe = MaybeT . return
13:36:21 <samba1> but the whole thing is in IO because it's database
13:37:01 <samba1> yes, there are ways to hide what I am doing
13:37:03 <Peaker> samba1: getFromDb & liftIO >>= hoistMaybe . process
13:37:09 <samba1> I just thought maybe there's a normal way
13:37:38 <Peaker> (which is only nice iff you're used to this style of function chaining
13:38:01 <samba1> it seems like I'm lifting IO, then unwrapping, then getting a maybe, then wrapping that back up - lots of back and forth
13:39:10 <Peaker> samba1: there's no unwrapping
13:39:38 <Peaker> samba1: hoistMaybe . process =<< liftIO getFromDb
13:39:39 <samba1> slurping
13:42:36 <samba1> i wanted to avoid the explicit liftio... it seems to work as MaybeT $ process <$> getFromDb, I think that's the best
13:43:57 <EvanR> does anyone know how to explain the following, i have an FFI callback via FunPtr, wrapper, etc, and my program will hang unless I do +RTS -N2 ?
13:43:59 <samba1> thank you everyone
13:44:02 <EvanR> is the N2 really necessary or what
13:44:30 <Peaker> EvanR: sounds like your FFI is blocking the capability and causing a deadlock?
13:45:12 <EvanR> i execute a foreign function by passing it a callback, which it then uses. it is never able to callback, thats when it hangs
13:45:21 <EvanR> unless i do N2
13:45:36 <EvanR> thats number of cpus to use right?
13:45:59 <dmwit> number of capabilities to use
13:46:24 <EvanR> ok
13:46:29 <dmwit> ...which corresponds to the number of OS threads to spawn to manage Haskell evaluation contexts.
13:46:34 <EvanR> should callbacks like this work with only 1 capability?
13:47:04 <dmwit> Is the thing it's calling back from imported safe or unsafe?
13:47:10 <EvanR> safe
13:47:15 <dmwit> And are you using the threaded or non-threaded runtime?
13:47:19 <EvanR> threaded
13:48:08 <dmwit> I'm not sure. I think if the thing you're calling back from is *not* in a bound thread, you should be okay.
13:48:20 <dmwit> If it *is* in a bound thread, I don't know the answer.
13:48:35 <EvanR> in my test im starting from the main thread, isnt that a bound thread?
13:48:49 <dmwit> main is always bound, yes
13:49:00 <EvanR> ill run my test from a forkIO
13:51:44 <Profpatsch> I’m at a loss how to contruct this datatype:
13:51:45 <Profpatsch> https://bigmac.caelum.uberspace.de/paste/data-constructor.hs.html
13:52:09 <Profpatsch> Should I use a definition like Color, or rather like Color' and rgb?
13:52:18 <Profpatsch> Or something entirely different?
13:52:51 <dmwit> Each are defensible in different contexts.
13:55:54 <Peaker> Profpatsch: I wouldn't want Color, if it's a sum anyway, may as well abuse the alpha=1 to mean it's RGB and not RGBA?
13:56:03 <Peaker> (or in this case alpha=255 I guess?)
13:56:31 <Profpatsch> Well, I noticed I have to do pattern matching for pretty senseless things with Color.
13:56:51 <dmwit> Profpatsch: If it's me, I just use the colour package.
13:56:52 <EvanR> dmwit: thanks for the information, very interesting. but the hanging effect seems to have gone away with on -N1
13:58:00 <EvanR> maybe i had a weird bug somewhere else that i fixed
13:58:07 <EvanR> in fact, it doesnt hang without -threaded either
13:59:19 <EvanR> there is a noticable difference of the length of my thread delay between -threaded and not threaded, audible because its how long im playing two sound clips
13:59:28 <EvanR> expected i guess
13:59:36 <EvanR> huzzah
13:59:48 <Profpatsch> dmwit: Whaaa, it didn’t occur to me to search for colour as well. :(
14:00:34 <Profpatsch> But it’s rather simple in my case, so I don’t need that.
14:01:31 <newsham> this post argues for static typing because monkeys at keyboards with grammar checkers would only type grammatically well formed stuff, and have more chance of generating shakespeare
14:01:37 <monochrom> yes, they should be spelt Colour and Colour' :)
14:01:40 <newsham> what he forgot is that shakespeares plays are not grammatically correct ;-)
14:02:01 <Profpatsch> I’m a lazy programmer, so Color for me. :)
14:02:09 <cmtptr> "spelt"
14:02:20 <Profpatsch> On the other hand I write behaviour, not behavior.
14:02:32 <Iceland_jack> behvr
14:02:41 <Profpatsch> The first word simply rolls better on the keyboard.
14:03:31 <hvr> ..."be hvr" however summons me
14:03:51 <Iceland_jack> haha apologies hvr
14:03:57 <hvr> np =)
14:04:07 <newsham> "Your thought experiment with monkeys has a fatal flow: None of Shakespeares plays were grammatically correct. So your grammar checked monkeys have zero probability of generating one of his plays. (Maybe dependent types would help here?)"
14:04:13 <Peaker> newsham: well, my 10 month old used Lamdu to generate some structurally valid type-checked code :) (quite meaningless code, but still :-) )
14:04:55 <Peaker> banging at the keyboard does that with a structural/type-driven editor :)
14:11:05 * hackagebot mikmod 0.1.3.2 - MikMod bindings  http://hackage.haskell.org/package/mikmod-0.1.3.2 (evanrinehart)
14:13:44 <newsham> what if compiler always gave you Integer unless it could prove that your variable was finite (or you provided a proof to it), in which case it would narrow to something like Int32 ?
14:13:53 <newsham> do any do that?
14:14:59 <EvanR> that would be cool
14:15:04 <vanila> cryptol sort of ish...
14:15:11 <vanila> no not really
14:15:23 <vanila> but similar ideas using SMT could
14:15:53 <vanila> when you're working with finite vectors it will sometimes sasy 'this needs to be infinite"
14:19:08 <orzo> would that be practical though
14:19:28 <orzo> the Int32 only when it could prove finite
14:19:57 <orzo> seems like we'd typically explicitly ask for Int32 instead
14:20:10 <orzo> or Int64
14:20:25 <vanila> yes and get a type error when your program cannot be shown to stay within bounds
14:20:47 <orzo> so force the coder to handle overflow
14:20:54 <vanila> it would be nice to get static analysis and errors like this
14:21:02 <dmwit> newsham: Seems like it would only really be useful in straight-line programs.
14:21:03 <Eduard_Munteanu> Or you could ask the CPU to interrupt on overflow and re-JIT the code with larger ints or Integer.
14:21:24 <dmwit> newsham: Every time you use + you add a bit. Every time you use * you sum the number of bits in the two arguments.
14:21:35 <dmwit> newsham: First time you write a loop, you're at Integer.
14:21:55 <orzo> + and * would require pattern matches on the result
14:22:18 <EvanR> orzo: s/handle overflow/be guaranteed overflow does not happen/
14:22:28 <EvanR> (unless you do want overflow behavior and thats a totally different ring)
14:22:51 <EvanR> i hate handling the impossible
14:23:25 <orzo> well i wasn't thinking it was a different thing, how does it gaurontee it stays within bounds when you do a + operation?
14:23:38 <EvanR> its a case by case argument
14:23:54 <EvanR> 4 + 9 is definitely ok
14:23:59 <vanila> x + y is within bounds when x + y < 0x10000000000000000
14:24:00 <orzo> okay, i see
14:24:01 <vanila> or something like that
14:24:15 <EvanR> for any two numbers less than max / 2, addition is ok
14:24:59 <EvanR> you make arguments like this all the time when writing C code
14:25:05 <EvanR> silently
14:26:51 <vanila> I think that static analysis for array bounds check is very important for C
14:27:01 <vanila> it's ashame there isn't an easy way to get that
14:28:19 <samba1> If there's something in IO that calls fail, but I liftIO that into MaybeT, I still get a runtime erroar, since the fail was IO's fail at the call site. There's no way to stop that except catching and wrapping it myself?
14:29:14 <roconnor> samba1: yes
14:29:22 <orzo> does the code that calls fail explicitly state IO monad?
14:29:40 <samba1> yes, it's Network.HTTP
14:29:54 <samba1> I can redo things myself looking at the internals of Network.HTTP
14:30:11 <samba1> but i thought i'd be nice if I could avoid that
14:30:27 <orzo> why not just handle the exception
14:30:56 <roconnor> it would be nice.
14:31:08 <samba1> orzo: i don't understand why it's like that anyways
14:31:11 <roconnor> but lower-level IO is not exposed :(
14:31:22 <roconnor> historical reasons.
14:31:22 <samba1> http://hackage.haskell.org/package/HTTP-4000.2.19/docs/src/Network-HTTP.html#getResponseCode
14:32:06 <samba1> I can do that myself safely without fail
14:32:13 <orzo> they could simply change IO to m
14:33:41 <orzo> fail in Maybe is the same as Nothing i believe
14:34:22 <samba1> yes, which is why I'd like to be able to capture all that in MaybeIO, but I can't without redoing it myself
14:34:42 <samba1> which is not hard, but it makes my code more messy
14:34:50 <samba1> instead of being able to pipeline
14:35:08 <orzo> will you submit a patch afterward
14:35:34 <samba1> my coworker gave me what he uses but he doesn't know if it's useful
14:35:57 <samba1> or if it's bad
14:36:35 <RyanGlScott> edwardk: Is there an mtl-compat package (or something similar) that provides mtl instances for ExceptT in transformers-compat?
14:36:35 <samba1> for what we do, all we care about is 200 or not 200. if it's not 200 - 404, 500, or a real failure - we don't care
14:37:00 <samba1> but he doesn't think the author will accept such a function, so we keep it ourselves
14:37:09 <orzo> i think i'd just wrap an exception handler and keep using the standard api
14:40:00 <Lokathor> at first glance, orphan instances seem like they're trouble waiting to happen. Are there plans in haskell's future to be able to specify which instances to export from a module? or which to import?
14:40:17 <stepcut> yes they are, and no there is not.
14:40:38 <orzo> not waiting to happen
14:40:40 <orzo> already happened
14:40:57 <Lokathor> how very un-haskell a thing it seems
14:41:33 <orzo> i think in practice it means making only very parochial type classes
14:42:02 <orzo> only base/ghc can give us meaningful general ones
14:43:41 <orzo> Lokathor: ImplicitParameters is a kind of solution
14:44:24 <orzo> correction, ImplicitParams
14:44:32 <S11001001> RyanGlScott: no
14:45:36 <RyanGlScott> Hm, I wonder if I should make that myself. I've found myself reimplementing ExceptT instances in packages where I use transformers-compat, and I'm worried that one day somebody will use them together.
14:46:44 <orzo> are transformers really good practice apart from legacy code considerations?
14:47:27 <hiptobecubic> I think newtyping a transforming stack is pretty much how application development in haskell works today, no?
14:47:36 <orzo> i've not used extensible effects yet myself, but i was sort of thinking it'd be a revolution
14:47:55 <vanila> hiptobecubic, I thought so too but i've recently been pretty confused about how few people seem to get this
14:48:08 <hiptobecubic> transformer*
14:48:13 <hiptobecubic> vanila, get what?
14:48:14 <orzo> http://okmij.org/ftp/Haskell/extensible/
14:48:22 <vanila> the methodology
14:48:49 <orzo> there's several alternatives invented now that i figure are better
14:49:05 <hiptobecubic> Well, for me at least, I find it pretty easy to end up with a really complicated pile of shit at the end of the process. Granted I've only built a few.
14:50:00 <orzo> hiptobecubic, vanila, are you familiar with the alternative methods to transformer stacks?
14:50:34 <hiptobecubic> I'm aware that there are some, at least at the research level. I haven't used them and I haven't seen anyone use them.
14:50:58 <vanila> orzo, not really I have looked into one
14:51:44 <Zemyla> Can Typeable and Data instamces be written for types with non-type parameters?
14:51:48 <vanila> I thought that monad stacking was the cornerstone of haskell programming but I'm finding that it's not at all
14:52:09 <Zemyla> Like, say, Fixed (n :: Nat)?
14:52:13 <vanila> in my experience if you do this you can write very elegant code in exactly the DSL you need
14:52:38 <orzo> well teh extensible effects still provide a monad with do syntax
14:52:51 <vanila> yeah I read the ext eff paper
14:53:02 <eacameron1> Visual Studio is complaining that it can't find _HsStart in my GHC-compiled lib file. But DUMPBIN /EXPORTS says "HsStart" is there. Why would VS add "_" to the beginning? Anyone have general experience with this?
14:53:06 <vanila> it's pretty cool but the need for a type level union is annoying
14:53:13 <vanila> if we can get that added to the type system that would be nice
14:54:10 <orzo> well the type system is evolving fairly fast
14:54:11 <hiptobecubic> I don't feel like I have enough experience to compare methods for combining monads, really.
14:54:29 <hiptobecubic> What does type level union give you?
14:54:36 <vanila> a set of effects
14:54:45 <orzo> i look forward to transformers being a legacy thing
14:54:50 <vanila> exteff works by specifying a set of effects in the type level, rather than a stack of them
14:55:01 <hiptobecubic> I mean what is it? As in set of types?
14:55:02 <vhuisd> http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity <- this article says that IO computations are always the same 'computational structure' regardless of state but it is the execution that is impure... seems like a play on words
14:55:03 <hiptobecubic> ah
14:55:16 <vanila> orzo, why? aren't they good?
14:55:27 <tomphreek>         nodeVal :: BinTree a -> a
14:55:27 <tomphreek>         nodeVal (Node x _ _) = x
14:55:27 <tomphreek>         nodeVal Empty = mempty
14:55:35 <tomphreek> 3 line fails
14:56:02 <orzo> i'm not sure i can articulate that
14:56:11 <orzo> i'm a little supprised you don't have the same attitude
14:56:16 <exio4> tomphreek: you're missing the Monoid a => constraint
14:56:20 <vhuisd> compiled c++ programs are also the same program regardless of input and 'evaluated' the same and impure at runtime..
14:56:36 <tomphreek> exio4: I have it, I copied where clause
14:56:41 <hiptobecubic> vanila, they are kind of annoying I'd say. Although flattening the stack into a set seems less... good
14:57:02 <hiptobecubic> vhuisd, this argument has been torn apart over and over again in various blogs.
14:57:14 <tomphreek> sumNeighs :: (Monoid a) => a -> BinTree a -> BinTree a
14:57:22 <vhuisd> so what are you saying to me hiptobecubic ?
14:57:24 <tomphreek> ... where ^^ above 3 lines
14:57:32 <vhuisd> hiptobecubic: the article is bs?
14:57:38 <hiptobecubic> vhuisd, I'm saying rather than rant about how it seems fishy, go read counter arguments.
14:57:50 <phaazon> hey, what’s the best recommanded way to write an instance of Storable for an algebraic data type?
14:57:52 <MP2E> vhuisd: good reading on the topic imo http://conal.net/blog/posts/is-haskell-a-purely-functional-language
14:57:59 <vhuisd> hiptobecubic: not ranting... trying to undestand
14:58:08 <orzo> i've done a bunch of transformer coding experiments (along with some serious code) and at the end of the day felt something was wrong, IO should be a giant stack of mini monads rather than we start with full IO and restrict
14:58:15 <hiptobecubic> At best, all you'll get here is a lazy (harr harr) rehash of what you would read in the blogs.
14:58:16 <phaazon> for instance, data Foo = Bar Int Int | Zoo Float String Double Bool
14:58:37 <tomphreek> oh turns out I have to repeat the constraint in where clause
14:58:46 <phaazon> I guess I should allocate memory for two ints, one float, one string and one double for _any_ kind of Foo
14:58:59 <vhuisd> hiptobecubic: MP2E: does it even matter if we call haskell 'pure' or 'impure' ?
14:59:02 <phaazon> it’s a bit a waste of space, but I don’t see how to deal with that another way
14:59:07 <hyPiRion> :t gets >> throwError "wat"
14:59:08 <lambdabot> (MonadState s m, MonadError [Char] ((->) (s -> a))) => (s -> a) -> b
14:59:09 <tomphreek> exio4: I didn't know constrants are to be repeated in the where clause. Thanks!
14:59:27 <hyPiRion> ^ Is that a sensible result, and if so, could anyone tell me what it means?
14:59:32 <enthropy> tomphreek: you are using -XScopedTypeVariables?
14:59:53 <Iceland_jack> hyPiRion: You should provide a function argument to 'gets'
15:00:06 <Iceland_jack> :t get >> throwError "wat"
15:00:06 <hiptobecubic> vhuisd, it does if you want to be able to compare haskell with other languages. If you don't care about the benefits of pure functions and all the rest, then no. It doesn't matter.
15:00:07 <lambdabot> (MonadState a m, MonadError [Char] m) => m b
15:00:07 <hyPiRion> Iceland_jack: thanks, that was it
15:00:43 <hiptobecubic> vhuisd, but that's like asking if it really matters if python is compiled or interpreted. It depends on why you want to know.
15:01:07 * hackagebot postgrest 0.2.5.2 - REST API for any Postgres database  http://hackage.haskell.org/package/postgrest-0.2.5.2 (begriffs)
15:01:10 <vhuisd> hiptobecubic: okay, i think it doesn't matter to me at this point then
15:01:22 <Iceland_jack> vhuisd: The important thing to take away is that actions are "first-class"
15:01:30 <orzo> is there anyway to use haskell to code vim plugins while avoiding learning vimscript?
15:01:41 <vhuisd> are there people that have good arguments for not using do notation?
15:02:01 <vhuisd> Iceland_jack: you mean functions are first class?
15:02:09 <orzo> the AMP will take away one of the good arguments against do notation
15:02:34 <Iceland_jack> vhuisd: No, (IO) actions
15:02:59 <tomphreek> enthropy: I don't think so. if it's not default then no. my hlint or hdevtools yelled at me
15:03:02 <vhuisd> Iceland_jack: if IO actions are either values or functions wouldn't that automatically make them first class?
15:03:09 <orzo> very often <*> is more efficient than >>= , but do notation encourages you to ignore that
15:03:09 <vhuisd> since those are first-class
15:03:27 <athan> Hey folks, what's wrong with my lexer? http://lpaste.net/119988
15:03:41 <vhuisd> orzo: AMP?
15:03:57 <orzo> vhuisd: Applicative will be a parent class of Monad
15:03:58 <Iceland_jack> vhuisd: You can check this out http://blog.jle.im/entry/first-class-statements
15:04:22 <vhuisd> okay Iceland_jack
15:04:25 <orzo> vhuisd: therefore the compiler will be able to use Applicative when its more efficient, even when using do syntax
15:04:30 <vhuisd> orzo: you mean in upcoming haskell versions?
15:04:35 <orzo> vhuisd: yes
15:05:03 <athan> anyone? :(
15:05:06 <vhuisd> ah okay - are there arguments along the lines of style - ie its not 'functional-style' ?
15:05:07 <orzo> vhuisd: currently do syntax means Monad, and Monad is often wrong or less efficient when Applicative is what you should use
15:05:09 <hiptobecubic> there is also ApplicativeDo
15:05:18 <enthropy> tomphreek: if you're using it (and brought those type variables into scope with a forall) then you shouldn't have to repeat constraints
15:05:34 <enthropy> @hackage applicative-quoters -- has an ado
15:05:34 <lambdabot> http://hackage.haskell.org/package/applicative-quoters -- has an ado
15:05:49 * Iceland_jack . o O (( <much ado joke> ))
15:06:23 <pacak> athan: add feed B.empty if you want to get a result
15:06:33 <orzo> i really really hate having to type brackets with | in them
15:06:38 <athan> :o
15:06:40 <orzo> [| ugg |]
15:06:45 <tomphreek> enthropy: thanks I will look into it
15:06:48 <athan> pacak: Thank you!
15:06:48 <supki> athan: why do you think there's anything wrong?
15:07:03 <athan> supki: I can't parse "foo", but I can with "foo "
15:07:05 <supki> athan: Partial means the parsing will continue if you give it more input
15:07:14 <athan> oh woah
15:07:18 <athan> hmm
15:07:26 <supki> athan: there's also `parseOnly` if you don't like Partials
15:07:32 <vhuisd> orzo: yeah I find that confusing because its very similar to list syntax - couldnt some other symbol like % or @ be used?
15:07:37 <tomphreek> now that my sumNeighboors function works on monoids, so it really be a product of neighboors, or a concatenation of neighboors, I don't have a good name for it
15:07:38 <athan> I might give that a shot, thank you supki :)
15:08:21 <tomphreek> perhaps I could further specialise my generic function by adding Num constrait simply for it to have a good name
15:08:53 <tomphreek> what's the standard practice around haskell code?
15:09:13 <orzo> vhuisd: i have a syntax hilight program that colors [blah| ... |] the same as a string
15:09:35 <toblerone> using quickcheck how does one generate n samples of "arbitrary"? I assumed that sample' would produce an infinite list, but it seems to only give a finite number of elements
15:09:43 <TallerGhostWalt> if I make my records with _recordName for lens use, should I not use the recordAccessors ever ?  Feels weird using something with an underscore but sometimes I don't want a lens I just want an accessor.
15:10:14 <Iceland_jack> toblerone: You only use "sample" for poking around
15:10:29 <Iceland_jack> You can use "vectorof" (I think it's called)
15:10:39 <Hijiri> TallerGhostWalt: I don't think there's anything wrong with just using the record accessors
15:10:48 <Hijiri> although you could always do view recordName
15:11:14 <Iceland_jack> toblerone: No sorry, 'vector :: Arbitrary a => Int -> Gen [a]'
15:11:17 <Iceland_jack> Generates a list of a given length.
15:11:21 <orzo> hm, UnicodeSyntax should give us ⟦ and ⟧
15:12:02 <orzo> i could program my editor to let me type that in some way that is less onerous than [| which is pinky shift hell
15:12:24 <toblerone> Iceland_jack: Well "vectorOf :: Int -> Gen a -> Gen [a]" seems appropriate? No? I'd then have you use "unGen" to get the values
15:12:42 <Iceland_jack> toblerone: vectorOf is only if you want to supply your own generator
15:13:04 <Iceland_jack> and you shouldn't have to use unGen
15:13:46 <toblerone> Well I'm probably not using QuickCheck for its intended purpose. At the moment, I'm just trying to generate random data
15:14:06 <Iceland_jack> Ah.
15:14:24 <toblerone> I've found the Arbitrary class quite convenient though
15:14:58 <athan> supki: Hmm, but with `parseOnly`, nothing fails? It just attempts to parse as much as possible?
15:15:11 <athan> (in combination with `many`?)
15:21:08 * hackagebot seqid 0.3.1 - Sequence ID production and consumption  http://hackage.haskell.org/package/seqid-0.3.1 (LukeHoersten)
15:25:48 <supki> athan: it's certainly possible for parseOnly to fail
15:26:04 <supki> athan: one subtle thing is that parseOnly doesn't try to eat all of its input
15:26:28 <supki> athan: you'd need  parseOnly (p <* endOfInput)  for that
15:26:33 <supki> where p is your parser
15:30:14 <athan> oh wow, okay! Thank you supki!!
15:31:09 * hackagebot seqid-streams 0.3.1 - Sequence ID IO-Streams  http://hackage.haskell.org/package/seqid-streams-0.3.1 (LukeHoersten)
15:32:05 <Profpatsch> At a loss again.
15:32:30 <Profpatsch> I nicely defined my type like so: newtype Pixelflut a = Pixelflut { runPixelflut :: ReaderT Socket IO a }
15:33:05 <Profpatsch> So I can have an open socket connection with which the program communicates.
15:33:46 <Profpatsch> But how can I instantiate a new Pixelflut with a working socket now?
15:35:01 <pacak> Profpatsch: You dont, you pass it when you want to run it
15:36:25 <Profpatsch> Aaaaah
15:37:02 <Profpatsch> But how do I unwrap that then?
15:37:16 <Profpatsch> runPixelflut and now I’ve got a ReaderT Socket IO a
15:37:31 <Profpatsch> Then runReaderT?
15:37:41 <Hijiri> yes
15:38:14 <Profpatsch> So I’m constructing the Pixelflut monad inside the do and run it at the end.
15:38:25 <pacak> flip (runReaderT . runPixelflut)
15:38:54 <pacak> :: Socket -> Pixelflut a -> IO a
15:39:12 <Profpatsch> If there is a computation inside the Pixelflut do-block that takes some time, will the IO be actually performed when an IO-function is called?
15:39:58 <Profpatsch> Or at the far end, when the thing is actually run?
15:40:10 <Profpatsch> I think I’m confusing the effects of lazy execution here.
15:40:14 <Hijiri> things don't run until they run
15:40:41 <Profpatsch> Hijiri: You mean the compiler decides?
15:40:51 <Profpatsch> b/c of lazyness?
15:40:52 <Hijiri> do you know how IO works in general?
15:41:25 <Profpatsch> I build up some IO inside the monad and the compiler can then execute it the way it sees fit?
15:41:56 <MP2E> No, a monad is ordered because an action can depend on a value of the previous action
15:42:02 <Hijiri> I mean, how do things get run
15:42:15 <pacak> Profpatsch: liftIO
15:42:19 <Hijiri> a value of (IO a) doesn't do anything on its own
15:42:36 <Hijiri> the only IO action that gets run is main
15:42:45 <Hijiri> (and of course main is usually defined in terms of other IO actions)
15:42:59 <Hijiri> so if your IO action is never incorporated in main, it's just an inert piece of data
15:43:07 <Hijiri> I like to think of IO as composable programs
15:43:12 <Profpatsch> Okay.
15:43:14 <Hijiri> they don't do anything just lying around
15:43:41 <Profpatsch> As are the other monads, like State and Pixelflut?
15:43:49 <Profpatsch> Ah, I see.
15:44:11 <Hijiri> I'm talking specifically about IO
15:44:22 <Hijiri> other monads do their own things
15:44:54 <Hijiri> Pixelflut gives you a way of getting an IO action, so you have to make that IO action part of main somehow to get it run
15:45:12 <Profpatsch> I already wrote a function Int -> Pixelflut () that writes that int to the socket.
15:45:39 <Profpatsch> with liftIO $ socketWrite int
15:46:19 <Profpatsch> Now I want to do something like main = withConnection host port $ do { writeFunction }
15:46:39 <Hijiri> just to be precise, functions don't do any IO
15:47:01 <Profpatsch> withConnection has to unwrap Pixelflut then, right?
15:47:21 <Hijiri> is withConnection something you're writing?
15:47:44 <Profpatsch> main = _test $ do … says that _test needs a Sig of Pixelflut a -> IO ()
15:47:49 <Profpatsch> Yes.
15:48:07 <Hijiri> Pixelflut () says that you can give it a Socket and you will get back IO ()
15:48:24 <Hijiri> so you need withConnection to create a connection and give the resultant Socket to Pixelflut
15:48:29 <Hijiri> (using runReaderT)
15:48:52 <Profpatsch> okay, I’ll try.
15:49:01 <ezrios> Can anyone recommend a good daemon library for Haskell?
15:49:05 <Profpatsch> I’m just glad the Compiler tells me when I’m done. :)
15:49:16 <Profpatsch> ezrios: Unix™
15:49:37 <ezrios> Profpatsch: so just straight up forks?
15:49:48 <Profpatsch> ezrios: daemons are just normal programs that take from stdin and write to stdout and stderr.
15:50:03 <Profpatsch> It’s bad practice to fork itself into the background.
15:50:17 <ezrios> Profpatsch: it is?
15:50:21 <ezrios> I thought it was standard practice
15:50:40 <Profpatsch> That should be the job of a supervisor system, like https://en.wikipedia.org/wiki/Daemontools
15:51:05 <ezrios> I see
15:51:08 <ezrios> or like /etc/init.d I guess
15:51:15 <Profpatsch> or systemd. :)
15:51:26 <ezrios> hrmph
15:51:31 <Profpatsch> Yeah, and it greatly simplifies the internal program structure.
15:51:33 <ezrios> I really need to learn more about unix programming
15:52:03 <hiptobecubic>  /etc/rc.d forever!
15:52:48 <hiptobecubic> There's no reason a daemon needs to use stdin/out/err
15:52:57 <hiptobecubic> it might do everything over dbus for example
15:53:08 <Profpatsch> of course.
15:53:13 <hiptobecubic> its' just a guy running in the metaphorical background, doing his thing
15:53:34 <ezrios> yeesh
15:53:58 <ezrios> while we're on this topic, would anyone recommend "Advanced Programming in the Unix Environment" by W. Richard Stevens?
15:54:04 <ezrios> (I know I know, this is #haskell)
15:54:17 <Iceland_jack> ezrios: Yes.
15:54:23 <Profpatsch> ezrios: Maybe after TAOUP.
15:54:43 <Profpatsch> http://catb.org/~esr/writings/taoup/
15:54:44 <ezrios> Profpatsch: ooh, Eric Raymond
15:54:50 <Profpatsch> ^ this is a masterpiece.
15:55:01 <Profpatsch> And it can be read online.
15:58:36 <barrucadu> It's not so much about programming for or on Unix though
15:59:18 <Profpatsch> Yeah, it’s Unix Programming, not programming on Unix.
16:00:17 <Profpatsch> But it has lots of case studies.
16:00:34 <Profpatsch> Yet, no code.
16:01:10 <detrumi> Looks interesting, thanks for the link
16:01:34 <Profpatsch> Books about programming on Unix/POSIX are most often about the C interfaces and get relatively dirty and detail-y.
16:12:51 <SunDown5656> Hi all ... im considering using Haskell for an upcoming side project. Thoughts on best web framework?
16:13:42 <tnks> so in cabal, sometimes "cabal install" is smart enough to say something like "All the requested packages are already installed". . . but for other packages, it's not so smart, and reinstalls the package anyways.
16:13:53 <tnks> does someone know what's going on there?
16:13:57 <tnks> it's not important, just curious.
16:14:43 <MP2E> it's not a matter of cabal not deducing that you have the package installed, it's that the new package you are installing is requesting a version of the package installed, except with different configure flags
16:14:53 <MP2E> this might be because of optional functionality it depends on
16:15:21 <MP2E> (varies per case of course but that's usually the case)
16:16:10 <tnks> MP2E: interesting.
16:16:12 * hackagebot test-sandbox 0.0.1.13 - Sandbox for system tests  http://hackage.haskell.org/package/test-sandbox-0.0.1.13 (yjkmy)
16:16:33 <tnks> but if I build it again, fresh, I seem to have the same behavior.
16:17:16 <tnks> MP2E: let me find a specific example.
16:18:58 <tnks> MP2E: yeah, if I build djinn fresh in a sandbox, and then "cabal install djinn" again, it rebuilds.
16:19:27 <tnks> (unless I'm not understanding something about how these configuration flags are threading through.
16:19:35 <Profpatsch> SunDown5656: If you want it to be very grande and impressive, you can try Yesod.
16:20:08 <Profpatsch> Personally, the compilation was too slow for my taste when I tried it.
16:20:40 <Profpatsch> I’m interested in trying out http://snapframework.com/ when I get the chance.
16:20:55 <MP2E> Huh, yeah that's not explained by my reasoning. I'm not sure actually
16:21:05 <MP2E> @ tnks
16:21:12 * hackagebot ascii-progress 0.1.0.1 - A simple progress bar for the console.  http://hackage.haskell.org/package/ascii-progress-0.1.0.1 (yamadapc)
16:21:14 * hackagebot ascii-progress 0.1.0.2 - A simple progress bar for the console.  http://hackage.haskell.org/package/ascii-progress-0.1.0.2 (yamadapc)
16:21:42 <tnks> MP2E: same with haddock.
16:22:35 <tnks> but I get the behavior I'd expect with a lot of other tools I compile including:  codex, ghcid, ghc-mod, and hasktags
16:22:55 <tnks> so curious if there's something peculiar with djinn and haddock.
16:23:36 <tnks> but I'm happy to look at cabal as a voodoo witch doctor that I just pray to
16:24:33 <MP2E> tnks: ah there's an old issue open about it https://github.com/haskell/cabal/issues/467
16:25:48 <tnks> MP2E: cool; thanks for helping find that.
16:26:12 * hackagebot ascii-progress 0.1.0.3 - A simple progress bar for the console.  http://hackage.haskell.org/package/ascii-progress-0.1.0.3 (yamadapc)
16:40:18 <Dynasty> So I'm wondering why this five line typeclass/instance doesn't compile http://pastebin.com/EJZinucg
16:41:14 <Iceland_jack> Dynasty: You're treating "Num" as a type
16:41:33 <Iceland_jack> The type of add would be 'add :: Num -> Num -> Num' which doesn't work
16:41:52 <Dynasty> Is there a way to constrain the type to be of typeclass Num?
16:41:52 <Iceland_jack> You can do something simple like 'instance AddAlg Int where add x y = x + y'
16:42:15 <orzo> Iceland_jack: Num a => a -> a -> a
16:42:25 <orzo> that's different than Num -> Num -> Num
16:42:33 <Dynasty> Yes that is what I want
16:42:53 <orzo> oh
16:42:57 <orzo> right, i meant you
16:43:01 <orzo> sorry Iceland_jack
16:43:09 <Iceland_jack> You *can* do 'instance Num a => AddAlg a where'
16:43:13 <Iceland_jack> but you run into problems
16:43:39 <Dynasty> That doesn't compile for me
16:43:50 <Dynasty> It says "constraint no smaller than instance head"
16:43:54 <Iceland_jack> Yes
16:44:39 <Iceland_jack> You'd need the FlexibleInstances extension for that to work
16:45:02 <orzo> it's better to make a newtype in that situation, Dynasty.  newtype NumAddAlg a = NumAddAlg a and then declare the instance for (NumAddAlg a) instead
16:45:08 <Iceland_jack> What orzo said
16:47:28 <Dynasty> orzo what would the first line of the instance declaration look like then?
16:47:37 <Dynasty> the line starting with instance
16:48:02 <orzo> Iceland_jack: what you should undersand is that ... => AddAlg t will prevent any type that matches t to declare a different instance than that one
16:48:33 <orzo> and all types match t
16:48:50 <Dynasty> but they don't satisfy the predicate
16:48:53 <orzo> instances Num a => AddAlg (NumAddAlg a) where
16:49:58 <orzo> that's true, but it's not checked for that.
16:50:13 <orzo> the predicate isn't checked to match instances
16:51:14 * hackagebot slack-api 0.3 - Bindings to the Slack RTM API.  http://hackage.haskell.org/package/slack-api-0.3 (mpickering)
16:51:57 <Dynasty> orzo will "-XFlexibleInstances" remove this restriction?
16:52:41 <orzo> it will not address what i said, it will just allow your code to compile you can use that universal instance assuming types have Num, but will not be able to make any other instances
16:54:42 <arianvp___> Does it matter how you stack your Monad stack?
16:54:54 <arianvp___> like is StateT ReaderT ~ ReaderT StateT ?
16:54:55 <osa1> can anyone help me with this vector error: "./Data/Vector/Generic/Mutable.hs:423 (slice): invalid slice (160000,176000,320000)" what's wrong here? my bounds are clearly in range here.
16:55:30 <orzo> arianvp___: more or less in that case, and in a lot of cases, but occasionally it matters considerable
16:56:27 <orzo> arianvp___: an example for vastly different semantics would be reversing your ListT and MonadIO
16:56:42 <arianvp___> orzo: that being a well-behaving ListT ?
16:57:31 <orzo> depends on what well-behaving means, ListT does violate the monad laws, but I don't think that's the only way ordering can matter
16:57:48 <sinnsat> If I am dealing with Data.Vector.Mutable inside ST Monad, do I have to use Data.Vector.freeze to escape out of the ST monad? Because that will copy the whole thing.
16:57:52 <osa1> is this a bug with vector's bound checking?
16:57:53 <orzo> consider List and Maybe, Maybe [a] versus [Maybe a]
16:58:17 <osa1> oh wait, second argument is length, right?
16:59:06 <orzo> sinnsat: i'd be pretty surprised if freeze causes a large copy to occur
16:59:22 <sinnsat> orzo: doc says O(n)
17:01:28 <sinnsat> I find the API a bit more confusing than STArray
17:02:42 <orzo> i gues you could use unsafeFreeze and immediately exit ST
17:03:13 <orzo> once you leave ST, there's no chance to modify the mutable vector
17:03:31 <sinnsat> orzo: so it is safe if the unsafeFreeze is basically the last thing I do inside the ST monad?
17:04:16 <orzo> i'm not confident to answer in the afirmative in the face of your continued doubt
17:04:27 <sinnsat> :D
17:05:28 <randomclown> is there a takeWhileM that looks like takeWhileM :: m a -> (a -> m Bool) -> m [a]
17:06:14 <orzo> :t takeWhileM
17:06:15 <lambdabot>     Not in scope: ‘takeWhileM’
17:06:15 <lambdabot>     Perhaps you meant one of these:
17:06:15 <lambdabot>       ‘takeWhile’ (imported from Data.List),
17:06:41 <sinnsat> orzo: "O(1) Unsafe convert a mutable vector to an immutable one without copying. The mutable vector may not be used after this operation." <- well, they are just saying I may not use the _mutable_ one, then I guess I can safely use the immutable one
17:07:31 <sinnsat> let's hope this is true
17:07:43 <orzo> assuming the mutable one cannot be modified outside of ST, but that would mean STRefs rather than IORefs or whatever
17:08:49 <johnw> sinnsat: I usually find that unsafe* doesn't mean unusable or dangerous, just that you have to take care yourself to uphold the semantics, rather than relying on types to ensure behavior
17:09:01 <horny-sama> I think I have successfully convince my teammates that despite my efforts, I am no use in the haskell assignment and that they will fill in my role instead of having me fucking stuff up
17:09:10 <geekosaur> yes, and my strong impression was that this was the exact use case for unsafeFreeze
17:09:14 <barrucadu> randomclown: There's untilM in the monad-loops package
17:09:17 <barrucadu> @hackage monad-loops
17:09:17 <lambdabot> http://hackage.haskell.org/package/monad-loops
17:09:48 <randomclown> barrucadu: I could have just used sequence + takeWhile
17:09:49 <barrucadu> Oh, that's not quite the same
17:09:51 <randomclown> to get what I wanted
17:09:52 <horny-sama> don't know if it is a good news or not
17:09:53 <barrucadu> Yeah, that works
17:09:58 <geekosaur> go into ST to use a mutable vector for some operation that is faster if you can use mutation, then unsafeFreeze it to immutable to export it
17:10:01 <mseeks> what's a typical monad stack for an app that has concurrently-mutable state?
17:10:17 <johnw> mseeks: ReaderT (TVar State) IO a
17:11:22 <mseeks> johnw: thanks -- and here `State` is some custom state type?
17:11:26 <johnw> right
17:11:30 <mseeks> and I guess I could also have a custom state type containing TVars
17:11:35 <johnw> I usually do, yes
17:11:41 <mseeks> cool, thanks
17:12:09 <jmcarthur> mseeks: what johnw said. also, a common one for me is   ReaderT (IORef State) IO a   because i often have pure functions that i can modify the state with using atomicModifyIORef
17:12:15 <orzo> is an unsafe-labeled call the only way to do that, geekosaur?  I would think there'd be a library interface that forced ST for mutation and the unsafe- would be hidden
17:12:48 <jmcarthur> mseeks: *because i often only have pure functions...
17:12:57 <geekosaur> orzo, as I understand it the whole "workflow" is unsafe, but unsafeFreeze is the part that makes the unsafeness "visible" outside of ST
17:13:21 <mseeks> jmcarthur: interesting; when would you prefer IORef with atomicModifyIORef over TVars?
17:13:26 <sinnsat> yeah, otherwise it has to copy the thing
17:13:35 <randomclown> :t takeWhile (/="") <$> (sequence . repeat $ getLine)
17:13:36 <lambdabot> IO [[Char]]
17:13:39 <randomclown> perfect
17:13:40 <geekosaur> and in this case "unsafe" means "it's on you to ensure referential transparency, because the type system cannot help you here --- you have explicitly gone behind its back in ST"
17:13:48 <mseeks> I guess "Extending the atomicity to multiple IORefs is problematic, so it is recommended that if you need to do anything more complicated then using MVar instead is a good idea."
17:14:02 <jmcarthur> mseeks: s/MVar/TVar/
17:14:19 <mseeks> that's what i was thinking; i got this from the IORef hackage page
17:14:21 <jmcarthur> mseeks: MVar is fine, but TVar is harder to get wrong
17:14:30 <johnw> jmcarthur++
17:14:35 <randomclown> TVar's a pain in the butt
17:14:46 <johnw> it's the right kind of pain, though
17:14:47 <randomclown> can't do IO inside it, hard to debug
17:14:51 <randomclown> hard to use as well
17:15:00 <randomclown> because you usually need IO
17:15:11 <johnw> randomclown: that's most people's argument against type systems as well
17:15:18 <geekosaur> also, certainly libraries can provide this functionality "safely" --- in fact that's kinda the point, a library can dive into mutability as long as its author has verified by whatever means that the result is correct, and hide the mutability inside itself
17:15:31 <jmcarthur> randomclown: i have never felt like i needed to add IO into an STM transaction
17:15:49 <johnw> if you really really need to use IO and TVars together, you might want to check out my http://hackage.haskell.org/package/consistent package
17:15:50 <jmcarthur> randomclown: not saying it doesn't happen, but i'm guessing it depends on how you approach it
17:15:55 <orzo> http://hackage.haskell.org/package/array-0.5.0.0/docs/Data-Array-ST.html#v:runSTUArray
17:16:05 <orzo> https://hackage.haskell.org/package/safe-freeze-0.2.1/docs/Control-Monad-ST-Freeze.html
17:16:07 <randomclown> it is a pain to debug is it not?
17:16:22 <johnw> it can be more painful to debug, but as jmcarthur said, it's also harder to get wrong
17:16:31 <johnw> which is true about Haskell overall
17:17:32 <johnw> donning the hair shirt comes with costs, but it's the best way to curb the rapid accumulation of technical debt that I know
17:17:35 <jmcarthur> the only reason i've ever had to actively avoid STM is when i needed to hide it behind unsafePerformIO
17:17:46 <orzo> TVars are wonderful heh
17:17:50 <jmcarthur> heh, "needed"
17:18:11 <orzo> pain to debug must be user error
17:18:30 <johnw> also, trace still works in STM
17:18:38 <johnw> it just outputs multiple times if there are retries
17:18:51 <johnw> which itself can be informative
17:18:59 <tommd> unsafeIOtoSTM is also an option...
17:19:15 <johnw> right, so for debugging, you can usually do what you need to do
17:19:17 <orzo> i've done a bunch of STM and not needed any of that
17:19:40 <johnw> what's harder to debug is starvation, but repeating traces is a sign of that
17:19:57 <tommd> Ditto.  Lots of STM but always small STM blocks that were "so small they clearly had no bugs" vs "so complex they had no clear bugs".
17:20:08 <orzo> right
17:20:11 <johnw> haha
17:20:14 <orzo> small blocks is the way to do STM
17:20:14 <johnw> well put
17:20:25 <tommd> (Not my quote, a common and old phrase)
17:20:43 <orzo> big STM blocks sounds suspicious
17:20:44 <johnw> choosing transactional boundaries well is part of the art
17:21:14 <jmcarthur> i still prefer a simple IORef with atomicModifyIORef when i can help it. pure code is least error prone code. it does mean you might have a harder time guessing which thread will be evaluating your expression, though.
17:21:41 <johnw> isn't the use of IORef just as impure as TVar?
17:22:02 <jmcarthur> yes, but atomicModifyIORef only accepts a pure function
17:22:17 <jmcarthur> that's its "transaction"
17:22:27 <johnw> same with modifyTVar
17:22:30 <jmcarthur> yes
17:22:30 <orzo> STM doesn't allow any IO (normally) either
17:22:51 <jmcarthur> orzo: no, but it does provide a controlled kind of mutable state within a transaction
17:22:55 <mseeks> with a (MonadWriter [String], MonadIO) stack, would the runner function return something like ([String], IO a)?
17:22:57 <johnw> i only use atomicModifyIORef if I only need the simplest form of thread communication, and I don't want to incur an stm dependency just for that
17:23:14 <jmcarthur> johnw: that's most of my concurrency right there :)
17:23:43 <johnw> mseeks: that doesn't typecheck for me
17:23:52 <jmcarthur> i rarely need to make one thread wait on another or anything like that
17:24:02 <Hijiri> mseeks: I think IO (a, [String])
17:24:08 <johnw> jmcarthur: if you ever do, async is the way to go :)
17:24:25 <johnw> or http://hackage.haskell.org/package/async-pool if you want to get fancy about dependencies; it's like a poor man's Haxl
17:24:28 <jmcarthur> at least in the haskell projects using concurrency i've worked on... in ocaml i use async stuff all the time
17:24:37 <mseeks> johnw: you're right, thanks
17:24:46 <jmcarthur> johnw: ah, well, i suppose i have used async a fair bit. i never use "raw" stm for such things though
17:25:46 <Profpatsch> It works now. Thanks ezrios Hijiri dmwit merijn and other for helping me out with my questions. https://github.com/Profpatsch/pixelflut-haskell
17:26:55 <jmcarthur> johnw: come to think of it, i usually use async whenever one thread might wait on another and atomicModifyIORef for shared state without any sort of blocking, and i've hardly ever needed shared state that can be blocked on, such as one normally thinks of STM as being for.
17:26:56 <sinnsat> still annoying that there is no nice way of pattern matching with array/vector
17:27:09 <jmcarthur> sinnsat: maybe pattern synonyms can help?
17:27:16 <johnw> hah, I was just going to say that :)
17:27:43 <sinnsat> jmcarthur: I don't know them well... I just copy pasted an obscure code block for some data type once :o
17:29:07 <sinnsat> afais vectors are better than lists at almost anything... just handling them is more tedious
17:29:52 <johnw> they are not at all better for laziness
17:29:59 <sebastianrkg> ghc --make can't see cabal dependencies
17:30:06 <sebastianrkg> but I can't pass flags to cabal build?
17:30:35 <sebastianrkg> I'm trying to use "criterion"
17:30:42 <geekosaur> the flags are applied during cabal configure
17:31:01 <geekosaur> so if you're usong cabal build directly, add a cabal configure --flags=whatever beforehand
17:31:05 <osa1> I want to generate an extra executable when --enable-tests is used, is there a way to do that? does Cabal define a flag when --enable-tests used?
17:31:26 <osa1> hm I guess I have to name my executable test-suite, right
17:31:30 <sebastianrkg> oh I see, so I could apply environment flags for the criterion defaultMain to access in cabal configure
17:31:47 <sinnsat> johnw: the values are not lazy?
17:31:58 <johnw> sinnsat:  your thunk either makes the array or it doesn't
17:32:09 <johnw> it can be lazy in the values, if it's boxed
17:32:14 <johnw> but the spine is all or nothing
17:32:23 <johnw> whereas with lists, GHC can sometimes fuse away the list entirely
17:32:25 <sinnsat> that's fine for my use case
17:32:29 <johnw> which beats any data structure
17:32:58 <johnw> I don't know that people appreciate enough that laziness can actually be an optimization
17:33:24 <johnw> there seems to be this all too common thought that the way to make Haskell programs faster and more efficient is to keep adding strictness
17:33:34 <johnw> but that's only true in cases where strictness is the answer
17:34:36 <sebastianrkg> "cabal configure --flags="-0 --make Fibber" is not having the same expected behavior as "ghc -0 --make Fibber"
17:34:54 <sebastianrkg> unless the executable is not made in the top-level directory?
17:34:56 <johnw> use --ghc-options=
17:35:00 <johnw> --flags is for cabal flags
17:35:01 <sinnsat> johnw: in my case laziness doesn't help much, because when I use my final data structure the first lookup might be the last element of a list of ~16k elems... it just matters to me that the values are lazy
17:35:44 <sebastianrkg> johnw: that results in "cannot use `--print-libdir' with `--make'"
17:35:52 <sinnsat> I guess that sounds a bit vague, though
17:35:53 <johnw> sinnsat: a lookup in the last element, which only uses the last elements, should fuse the list down to a for-loop.  Unless you do something else to the list which causes it to remain resident
17:35:57 <sorressean> I'm not getting this, wanted some help just learning. I have fb x = x `mod` 3 || x `mod` 5. how should I write that?
17:35:57 <sebastianrkg> which is not a flag I was using
17:36:12 <johnw> hmm
17:36:28 <sorressean> Basically: I want to return true if it's divisible by 3 or 5
17:36:30 <mseeks> considering the two stacks, (a): `EitherT Error (WriterT [String] IO) a` and (b): `WriterT [String] (EitherT Error IO) a`, then stack (b) would let you extract `IO ([String], (Either Error a))` whereas (a) would only give `IO (Either Error ([String], a))`, right?
17:36:36 <johnw> do you mean x `mod` 3 == 0?
17:37:01 <sorressean> yeah. but I guess the or isn't working there.
17:37:08 <johnw> it'll work with a boolean test
17:37:15 <sinnsat> johnw: I am actually not sure at all what the best data structure for my use case is
17:37:16 <johnw> x `mod` 3 == 0 || x `mod` 5 == 0
17:37:31 <johnw> sinnsat: can you describe your pattern of usage?
17:37:51 <sinnsat> johnw: that would be a wall of text, do you mind a paste?
17:37:52 <platz> so the 'add strictness' argument only makes more sense to me if you're willing to pre-fuse (i.e. restructure) your code.  that's what they did for transducers - give up on compilers and manually do it
17:37:58 <platz> then strictness makes sense
17:38:06 <johnw> sinnsat: I love pastes
17:38:31 <sorressean> johnw:  Prelude> fb x = x `mod` 3 == 0 || x `mod` 5 == 0 results in a parse error. :(
17:38:36 <sinnsat> johnw: http://lpaste.net/119991
17:38:45 <johnw> sorressean: try adding parens
17:39:04 <sorressean> oh. it's ghci, need let.
17:39:04 <johnw> (x `mod` 3) == 0 || (x `mod` 5) == 0
17:39:09 <johnw> ah
17:39:49 <johnw> sinnsat: ah, you are using a kind of graph?
17:40:06 <sinnsat> johnw: you could probably say it is one...
17:40:16 <johnw> I'm afraid I can't grasp this quick enough to give you an intelligient opinion before dinner is served
17:40:17 <sorressean> johnw:  thanks. that works. :)
17:40:29 <sinnsat> johnw: yeah, it's non-trivial, unfortunately
17:42:52 <sebastianrkg>  cabal configure --ghc-options="--make Fibber" always results in "cannot use `--print-libdir' with `--make'"
17:43:28 <sebastianrkg> cabal configure --flags="--ghc-options="--make Fibber'" successfully runs, but does not generate the executable that I need
17:43:45 <sebastianrkg> and I'm not really sure that that makes any sense anyway
17:45:13 <johnw> why are you using --make with cabal anyway?
17:45:19 <johnw> that is implied just by using "cabal build"
17:45:35 <johnw> you need to specify what module to build in the .cabal file
17:47:14 <sebastianrkg> ah I see, it wasn't making my executable at the top-level and it was naming it after the .cabal file
17:48:32 <Ally> I'm building a recursive function that aims to do something similar to a function I've already written, except instead of taking in one string, it takes in a list of strings
17:48:36 <Ally> type BinaryRelation a b = [(a,b)]
17:48:40 <Ally> applyRel a b = [y | (x,y) <- b, a == x]
17:48:57 <Ally> I'm trying to do applyRel, but recursively and with input of a list of strings
17:49:19 <Ally> I can't get my brain past starting with something like applyToList a (b:bs) = [y | (x,y) <- (b:bs), a == x]
17:49:26 <Ally> but I'm not sure where to use applyRel in the recursion here
17:49:32 <Ally> can anyone help with this? :)
17:49:45 <johnw> what is the type of applyRel, before and after?
17:49:56 <Ally> applyRel :: Eq a => a -> BinaryRelation a b -> [b]
17:50:17 <Ally> and applyRel :: Eq a => [a] -> BinaryRelation a b -> [b]
17:50:23 <Ally> err
17:50:28 <Ally> applyToList is the second one*
17:50:39 <johnw> how about fmap (flip applyRel b)?
17:50:50 <sinnsat> and then concat, probably
17:51:03 <Ally> I figure I have to do ++ somewhere, yeah
17:51:28 <Ally> <johnw> how about fmap (flip applyRel b)? <--I'm not sure precisely what that does, trynna build that kind of function from scratch for practice
17:51:37 <johnw> it should have the type of applyToList
17:51:38 <Ally> I'll look it up regardless!
17:53:22 <sinnsat> Ally: if the 'flip' confuses you... it is the same as: fmap (\x -> applyRel x b)
17:53:49 <Ally> I'm not familiar with many of those functions at all, even fmap
17:53:57 <sinnsat> oh, fmap is very important
17:53:59 <johnw> map would work equally as well here
17:53:59 <Ally> I'm starting out trying to learn recursion and stuff
17:54:11 <benzrf> Ally are you doing cis194
17:54:19 <Ally> haven't looked at the docs besides to try and imitate those functions by hand
17:54:19 <sinnsat> map is basically implicit recursion
17:54:21 <ReinH> johnw: flip applyRel b is a Kleisli arrow :)
17:54:22 <benzrf> because if not im legally obligated to harangue you into doing it
17:54:27 <johnw> Ally: conceptually, what you are doing is something which is exactly addressed by the concept of a Functor, which is why I picked fmap.  But map will do the same thing.
17:54:28 <Ally> no, not cis194 :o
17:54:38 <benzrf> Ally: y-you're not using LYAH are you
17:54:44 <Ally> noooo!
17:54:50 <Ally> >.o
17:54:54 <benzrf> what then
17:54:55 <Ally> thanks johnw!
17:55:00 <johnw> ReinH: so not helpful :)
17:55:02 <ReinH> johnw: you need concatMap though
17:55:05 <ReinH> is my point
17:55:17 <johnw> oh, right, I miss that on applyRel
17:55:20 <johnw> missed
17:55:32 <ReinH> you have an xs :: [a], flip applyRel b :: a -> [b] and you want a [b]
17:56:04 <ReinH> :t (>>=) `asAppliedTo` []
17:56:05 <lambdabot> [a] -> (a -> [b]) -> [b]
17:56:08 <ReinH> And Bob's your uncle.
17:56:16 * hackagebot HaskellNet 0.4.2 - Client support for POP3, SMTP, and IMAP  http://hackage.haskell.org/package/HaskellNet-0.4.2 (lemol)
17:56:19 <johnw> applyToList = (>>= flip applyRel b)
17:56:33 <ReinH> or concatMap flip applyRel b
17:56:38 <sinnsat> golfers :P
17:57:15 <ReinH> er, concatMap (flip applyRel b)
17:57:19 <sinnsat> he probably didn't have monads yet
17:57:24 <mseeks> what are your favorite bare-bones http servers?
17:57:27 <Ally> o_o
17:57:33 <ReinH> mseeks: Scotty
17:57:46 <brisbin> isn't that a web framework?
17:57:51 <johnw> ReinH: sorry, your comment was indeed very helpful :)
17:57:56 <ReinH> johnw: :p
17:57:57 <johnw> I missed that it was Kleisli
17:58:09 <Ally> you all are nerdy as hell, love it :3
17:58:24 <ReinH> johnw: which is why I, you know, said that. :)
17:58:41 <johnw> and which is something, you know, I took a moment to get and appreciate
17:58:55 <johnw> my mind had edited his [b] to just b for some reason
17:59:00 <ReinH> johnw: :)
17:59:44 <Ally> her :<
18:00:00 <johnw> Ally: thankfully, nerdy is the new cool
18:00:05 <Ally> yes
18:00:06 <Ally> yes it is!
18:00:11 <sinnsat> if that would work in real life...
18:00:32 <Ally> I'm looking at map and fmap
18:00:40 <Ally> trying to do the same thing those do, but without using them
18:00:47 <johnw> Ally: fmap it turns out was the wrong function here
18:00:52 <Ally> oh
18:00:53 <johnw> you want concatMap
18:01:02 <johnw> which does a map, followed by a ++
18:01:03 <Ally> maybe that's why I was confused looking at it
18:01:16 <johnw> or as many ++'s as needed (i.e., concat)
18:01:17 <mseeks> if I'm writing something that takes HTTP requests, "does stuff", and makes HTTP responses, should I try to separate the "does stuff" part from the http part?
18:01:35 <mseeks> e.g., the "does stuff" returns some data structure and the http part serializes and sends it
18:01:35 <johnw> mseeks: I would think so
18:03:04 <mseeks> I guess I'd like to know more about convention re: general architecture of these sorts of apps
18:03:22 <johnw> separation of concerns is a good general principle
18:03:26 <sinnsat> I wonder if someone knows if there have been attempts to abstract out some of the more complicated tying-the-knots methods and put that into a library. I know this sounds vague and I have no idea how that would look like.
18:03:35 <johnw> it helps with testing, reasoning, identification of problems, etc.
18:04:32 <mseeks> a general pattern for me is: read a config file, start listening for messages, hand messages off to some computation that happens in an app monad which reads the config structure, and respond
18:06:42 <mseeks> so for example, where would be a good place to actually do the `runApp m config`? e.g., with scotty, is something like `get "/" $ json $ runApp doStuff cfg` reasonable?
18:07:36 <johnw> i'm not familiar enough with scotty to say
18:10:54 <jle`> mseeks: if you want, you can look at my blog engine, which is on scotty :) https://github.com/mstksg/blog
18:11:03 <jle`> keep in mind i wrote it over a year ago
18:11:35 <mseeks> jle`: cool, thanks!
18:18:20 <jle`> i wrote it over a year ago but i still feel comfrotable editing and refactoring
18:18:23 <jle`> i love haskell
18:19:15 <jle`> ask me to refactor any of my ruby web apps that i haven't touched in a year and i'll run far away :P
18:19:33 <sdegutis> Is threepenny anything like ReactJS?
18:20:01 <joneshf-laptop> is there a function: `\e -> hPrint stderr e >> exitFailure` ?
18:20:06 <joneshf-laptop> taht seems like a common thing
18:20:16 <johnw> you mean, "die"?
18:20:21 <geekosaur> error?
18:20:30 <jle`> ha
18:20:31 <johnw> yeah, error would be it
18:20:37 <sdegutis> die msg = ioError (userError msg)
18:20:52 <thoughtpolice> 'die' actually exists with that exact definition in GHC 7.10
18:21:10 <sdegutis> That's where I got it from.
18:21:24 <sdegutis> Oh no wait, I got it from Distribution.Simple.Utils
18:21:29 <thoughtpolice> No, not that definition. The one joneshf-laptop posted
18:21:32 <jle`> error has the right type and effect but is completely coincidental, heh
18:21:33 <sdegutis> Oh.
18:21:50 <thoughtpolice> https://github.com/ghc/ghc/blob/master/libraries/base/System/Exit.hs#L78
18:22:32 <joneshf-laptop> damn, why couldn't that be 7.8 or older
18:22:39 <joneshf-laptop> ah well, give it time i guess
18:22:43 <jle`> find a time machine ;D
18:22:51 <johnw> you know, you can define that function :)
18:23:00 <joneshf-laptop> yes, I know
18:23:05 <jle`> naaah
18:24:04 <Ally> johnw: okay, so now I looked up some of the functions you guys mentioned
18:24:09 <Ally> does applyToList a b = concatMap (flip applyRel b) sound rightish to you?
18:24:57 <sinnsat> the a is missing
18:25:04 <joneshf-laptop> where'd the `a` go?
18:25:08 <Ally> oh
18:25:08 <joneshf-laptop> ^
18:25:09 <Ally> oops
18:25:12 <sinnsat> and it isn't eta reduction
18:25:42 <Ally> eta reduction?
18:26:44 <sinnsat> Ally: "plus = (+)" instead of "plus a b = a + b"
18:27:07 <sinnsat> so arguments can be omitted sometimes
18:27:11 <sinnsat> but not here
18:27:24 <sinnsat> (err.. they can be omitted always afair, but you don't want that)
18:27:45 * sinnsat mumbles about 'pointfree' 
18:28:23 <sinnsat> http://hackage.haskell.org/package/pointfree
18:31:14 <sinnsat> @pl applyToList a b = concatMap (flip applyRel b) a
18:31:14 <lambdabot> applyToList = (. flip applyRel) . (>>=)
18:31:18 <sinnsat> ouch
18:33:40 <fread2282> applyToList a b = a >>= flip applyRel b
18:35:02 <sdegutis> Is trying to use Haskell without using monads pretty much futile?
18:35:09 <johnw> not at all
18:35:18 <Ally> is >>= a monad thing?
18:35:21 <johnw> you can write tons of useful, pure code without touching a single monad
18:35:29 <Ally> <sinnsat> @pl applyToList a b = concatMap (flip applyRel b) a <--yeah, that worked! :D
18:35:31 <sinnsat> sdegutis: a lot of libs force you to use them ofc
18:35:32 <sdegutis> It seems like monads are the only reasonable way to create an abstraction.
18:35:35 <Ally> <lambdabot> applyToList = (. flip applyRel) . (>>=) <--what in the hell x.x
18:35:53 <fread2282> Ally: yes, for lists it's flip concatMap
18:36:00 <fread2282> :t concatMap
18:36:01 <lambdabot> (a -> [b]) -> [a] -> [b]
18:36:02 <sinnsat> Ally: yeah, just ignore that for now :P
18:36:04 <fread2282> :t (>>=)
18:36:04 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:36:05 <ttt_fff> is it just me, or is threepenny gui the greatest thing ever invented?
18:36:10 <mseeks> i'm rewriting a quite concurrent go project in haskell; it's like an order of magnitude simpler largely because of STM
18:36:17 <Ally> doesn't . mean not?
18:36:20 <Ally> or uh, maybe not
18:36:20 <sdegutis> No.
18:36:22 <Ally> (ha!)
18:36:24 <ttt_fff> . means conspose
18:36:24 <Ally> oh :<
18:36:24 <sdegutis> . means compose
18:36:26 <johnw> ttt_fff: I'm waiting for fourpenny gui, at least 33% better ;)
18:36:27 <Ally> ooo
18:36:40 <Ally> I think I wrote something similar to a compose function earlier
18:36:41 <ttt_fff> johnw: then it'll be nickel gui
18:36:48 <Ally> compose a b = [(w,z) | (w,x) <- a, (y,z) <- b, x == y]
18:36:53 <sdegutis> ttt_fff: isn't it just like ReactJS?
18:36:58 <sinnsat> Ally: f(g(a)) <- you know this from maths?
18:37:02 <Ally> yesh
18:37:03 <ttt_fff> nickel gui will provide acess to the occulus rift
18:37:12 <ttt_fff> dime gui will include access to drones + driverless cars
18:37:17 <sinnsat> Ally: well, it's basically the same notation in haskell
18:37:22 <fread2282> f . g = \x -> f (g x)
18:37:26 <sinnsat> yep
18:37:28 <ttt_fff> sdegutis: it's (1) write haskell code, (2) use web browser for GUI (3) be happy
18:37:42 <johnw> ah, for the days of ha'penny gui
18:37:47 <sdegutis> ttt_fff: I looked at it and it looked kind of complicted
18:38:19 <Ally> <fread2282> f . g = \x -> f (g x) <--ohwow, that's cool
18:38:28 <Ally> looks very similar to the f o g thing
18:38:31 <sdegutis> Ally: there's a free book on this kind of thing btw
18:38:34 <Ally> er, notation
18:38:37 <Ally> learn you a haskell?
18:38:39 <sdegutis> Ally: precisely
18:38:41 <Ally> or something different?
18:38:47 <sdegutis> Ally: I meant "precisely" in regards to "f o g"
18:38:48 <Ally> yeah, I've been goin' through it bit by bit
18:38:50 <Ally> oh
18:38:54 <sdegutis> Ally: what's "f o g" from?
18:39:11 <Ally> f(g(x)
18:39:13 <Ally> )
18:39:18 <sdegutis> Ally: also slow down, you're talking circles around me like a 12 year old girl :P
18:39:27 <Ally> I'm a 23 year old girl :B
18:39:27 <sdegutis> Ally: no I mean what language is that notation from?
18:39:30 <MP2E> lol
18:39:30 <Ally> oh
18:39:31 <Ally> uh
18:39:45 <Ally> not sure >.o
18:39:49 <Ally> I just recall it from high school math stuff
18:39:52 <sdegutis> omgsh
18:39:56 <Ally> and more recently, calc
18:39:57 <sdegutis> I cannot take this anymore.
18:40:01 <Ally> SORRY ;-;
18:40:03 <sdegutis> Feels like being in high school.
18:40:03 <MP2E> function composition in math is denoted as that
18:40:08 <sinnsat> :D
18:40:13 <Ally> what does, sdegutis? :<
18:40:34 <sinnsat> Ally is probably getting a lot of pm right now
18:40:46 <Ally> naw
18:40:48 <Ally> not yet o.o
18:40:59 <Ally> I'm still in the how does i haskell stage
18:41:04 <Ally> not very hot yet
18:41:06 <fread2282> the thing about monads is that everything that is a parametric data constructor is sort of like a container, and all things that have a monad instance must be parametric, therefore all monads are sort of like a container (in the sense that a -> b is a container for b(s))
18:41:10 <edwardk> Ally: your compose is very close to the definition of function composition, just in the sort of Set-theory notation mathematicians use
18:41:12 <edwardk> in haskell
18:41:17 <edwardk> f . g = \x -> f (g x)
18:41:19 <Ally> right, ja
18:41:20 <benzrf> fread2282: nonsenes
18:41:22 <edwardk> gives the composition of two functions
18:41:38 <edwardk> which you can also read as: (.) f g x = f (g x)
18:41:47 <benzrf> data Const r a = Const r
18:41:53 <benzrf> WHERE IS YOUR CONTAINER NOW
18:42:09 <edwardk> benzrf: Const isn't a Monad ;)
18:42:16 <edwardk> merely Applicative
18:42:24 <benzrf> i was just talking about parametric
18:42:29 <benzrf> not necessarily monads :U
18:42:59 <fread2282> benzrf: a container can be too small to actually hold anything
18:43:05 <benzrf> fread2282: now you're just cheating
18:43:10 <sinnsat> haha
18:43:11 <shachaf> "Const r a" is a container that contains 0 'a's.
18:43:20 <mseeks> I have a monad stack that looks like `EitherT Err m a` where `m` is some other monad, and I'm trying to derive the instance `MonadError Err` for this stack but I get an error "no instance for (Monoid Err)"
18:43:45 <edwardk> mseeks: given instance Foo a => Bar a -- you can get to Bar a from Foo a, but not back.
18:43:57 <fread2282> also http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
18:44:00 <benzrf> mseeks: obviously there is no Monoid instance for Err
18:44:10 <mseeks> but I'm not trying to derive Monoid anywhere
18:44:19 <shachaf> But in general the "container" analogy is pretty bad.
18:44:24 <benzrf> mseeks: something in your stack wants a monoid
18:44:26 <mseeks> I don't think MonadError e m requires (Monoid e)?
18:44:41 <benzrf> @unmtl EitherT Err m a
18:44:41 <lambdabot> EitherT Err m a
18:44:43 <osa1> I have multiple executables in my Cabal project and I want to compile one of them with -prof -fprof-auto, but is there a way to compile the library part two times, one with profiling and one without?
18:44:48 <mseeks> `MonadError Err` is the only instance I'm deriving that includes Err
18:44:48 <benzrf> thaaaaaanks lambdabot
18:44:59 <shachaf> There's a reasonably well-established meaning of "container", actually, defined by Michael Abbott, but no one is talking about those.
18:45:02 <edwardk> mseeks:  the instance for MonadError for EitherT is where you need to look
18:45:02 <benzrf> @unmtl ExceptT Err m a
18:45:02 <lambdabot> ExceptT Err m a
18:45:06 <benzrf> hrf
18:45:26 <edwardk> instance (Monad m, Monoid e) => MonadPlus (EitherT e m)
18:45:43 <edwardk> that is the shape of the instance for MonadPlus (EitherT e m)
18:45:50 <edwardk> so you need 'e' to be a Monoid and m to be a Monad.
18:46:03 <edwardk> if 'Err' isn't a Monoid then you can't use MonadPlus on EitherT e m
18:47:09 <edwardk> instance Monad m => MonadError e (EitherT e m) -- though
18:47:17 <edwardk> so I don't see why you are getting a Monoid constraint
18:48:23 <mseeks> I do derive MonadPlus but I guess it's unnecessary if it's already a MonadError Err
18:49:02 <mseeks> removed the MonadPlus deriving, but still getting the same error
18:49:15 <csd_> Hi, can someone please explain what I'm doing wrong here? https://www.refheap.com/96923 -- I feel like my code is pretty similar to this https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/parsing-floats-with-parsec
18:49:16 <mseeks> actually it removed one of the errors -- previously it was giving me that error twice
18:49:54 <mseeks> edwardk: where did you find those instance definitions, by the way?
18:50:06 <edwardk> mseeks: well, i wrote the 'either' package
18:50:35 <mseeks> ohhh you're ed kmett?
18:50:41 * edwardk nods.
18:51:17 <mseeks> awesome
18:51:29 <edwardk> to be fair, i did cheat and look at my haddocks ;)
18:52:41 <mseeks> I watched a few of your videos on lenses; they were super helpful
18:54:06 <benzrf> lenses are neato
18:54:09 <mseeks> anyway, here's the actual type: http://lpaste.net/119996
18:54:22 <sorressean> Is there a better way to write this? (Just learning). http://pastebin.com/yQQAHJYq
18:54:33 <mseeks> this is what I'm getting the (Monoid Err) constraint error
18:55:00 <shachaf> http://pastebin.com/raw.php?i=yQQAHJYq is a better way to write it.
18:55:21 <shachaf> As for the code itself, it's better to put a space before the "::" and after the "$", and it's better to write a type signature for func.
18:56:03 <shachaf> Other than that it looks fine.
18:56:24 <sorressean> thanks.
18:56:30 <edwardk> mseeks: Alternative has the same Monoid constraint
18:56:36 <shachaf> I don't know if there's a point to naming numtest -- you can just write filter (\x -> x `mod` 3 == 0 || x `mod` 5 == 0)
18:56:42 <pacak>  sum [a | a <- [1..999], a `mod` 3 == 0 || a `mod` 5 == 0]
18:57:04 <shachaf> Or you can use a list comprehension, that's just a matter of taste.
18:57:20 <n0n3such> edwardk: is ClariFi written in haskell ?
18:57:24 <sorressean> ah. gotcha. thanks. used to procedural.
18:57:37 <mseeks> edwardk: thanks! probably should've known; i only added in Alternative because I had MonadPlus
18:58:10 <edwardk> n0n3such: ClariFi predates us using haskell. It is mostly java and some scala. Ermine is scala and is switching to haskell, and is used inside ClariFi and the S&P CapitalIQ web platform
18:58:59 <edwardk> n0n3such: https://www.youtube.com/watch?v=o3m2NkusI9k is a talk I gave on the topic
18:59:15 <n0n3such> edwardk: ty, does haskell have an akka equivalent ?
18:59:15 <sorressean> My AI prof said we could use any lang we want... I want to start using Haskell.
18:59:37 <sorressean> I think "any language" ment c++/Python/Java, but...
19:00:08 <edwardk> We have cloud haskell, and there are a number of session-typed projects out there, but I don't think anything has been as aggressively optimized as akka.
19:00:30 <n0n3such> edwardk: an actor package ?
19:01:14 <edwardk> there are a few. i think there was one called thespian at one point, not sure if its actively maintained
19:01:37 <n0n3such> edwardk: ok, ty again.
19:01:44 <edwardk> we have a lot of streaming libraries that can do similar things with a bit different focus. conduit, pipes, machines
19:02:07 <edwardk> those are closer to scalaz-streams, or the scala machines library (which is a port of haskell machines)
19:02:17 <n0n3such> edwardk lightweight concurrency model in haskell ?
19:02:38 <edwardk> haskell's threads are actually considerably lighter weight than threads in other languages (even Java)
19:02:51 <edwardk> So you can spin up millions of them without a real problem
19:03:03 <edwardk> The RTS is rather insanely optimized on that front
19:03:09 <n0n3such> user level context switching ?
19:03:39 <edwardk> yeah, it is more or less a green threading model, you have a limited number of haskell "capabilities" that threads share.
19:03:58 <edwardk> the capabilities are analogous to os threads / cores.
19:04:04 <n0n3such> no remoting ala akka ?
19:04:28 <edwardk> cloud haskell is working to fill that niche, but it is a 90% library 10% compiler changing solution
19:04:49 <n0n3such> haskell equiv. of akka Agents ?
19:04:52 <edwardk> i can honestly say that akka has the edge there in terms of broad adoption and active work on usability
19:04:56 <sgronblo> anyone know if scala abstract types are sort of similar to type families?
19:05:40 <edwardk> You can write an in process version of an agent very easily with the MVar machinery and other IO communication primitives
19:05:55 <n0n3such> and haskell has native STM ?
19:06:03 <edwardk> a cross-machine form would really be mixing in cloud-haskell
19:06:18 <edwardk> yeah, STM in Haskell shines in particularly because of strong control over side-effects
19:06:54 <n0n3such> k, what is best practice in writing scalable haskell services ?
19:06:55 <edwardk> in practice STM hasn't proven to be the magical cure-all folks thought it might be a decade ago, but it is a great way to make it so that you can grab the output from, say, a couple of MVars and not worry overmuch about the order.
19:06:58 <orzo> did the term 'cloud' originate from technical people or marketting people
19:07:08 <orzo> heh
19:07:51 <edwardk> orzo: whenever folks would draw a diagram of services they wanted to sweep under the rug back in the day we always used to do it by sketching a cloud on the slide, eventually folks probably just started referring to "the stuff in the cloud" and it took off
19:08:59 <edwardk> n0n3such: good question. the web frameworks we have are pretty good at throwing up nice little restful services with rather ridiculously high performance
19:09:02 <benzrf> edwardk: i cannot believe that that is not apocryphal
19:09:10 <edwardk> benzrf: it totally is
19:09:15 <benzrf> :D
19:09:41 <edwardk> benzrf: but i distinctly remember doing wallstreet dog and pony shows in the mid 90s with slides focusing on what i wanted to talk about with clouds all around the rim, and it was just 'the style' at the time
19:09:59 <edwardk> benzrf: so it isn't a big leap from that to the current state
19:10:17 <edwardk> just the right marketing term and all of a sudden all those slideshows fit into a globally consistent context
19:10:31 <benzrf> hmmm
19:10:55 <n0n3such> edwardk: just curious why you are moving away from scala to haskell @ S&P when it appears that scala has better support for scalability and integration with 3rd party services ?
19:11:40 <edwardk> n0n3such: we're using haskell in writing a compiler for a little language we use in specifying financial reports. we were spending roughly 9/10ths of our time fighting with scala, and very little time working on the compiler itself.
19:11:45 <sinnsat> csd_: (fst . head . readFloat) <$> ((++) <$> int <*> dec) would work, but it's still not the right way to do it
19:11:49 <edwardk> we still compile ermine down into a form we can interpret on the jvm
19:12:14 <n0n3such> so you have active scala development work ongoing ?
19:12:19 <sinnsat> csd_: parsec already has support for parsing floats afais
19:12:29 <edwardk> but nothing from the front end language down to the spineless-tagless-g-machine representation we use on the backend needs to live in scala.
19:12:57 <edwardk> sure, it is a big company. in fact most development is on the .net stack, not on the jvm.
19:13:09 <n0n3such> yikes
19:13:58 <n0n3such> but given the choice, you would do new projects in haskell before you'd do them in scala ?
19:14:09 <edwardk> by building the ermine compiler down to a portable intermediate language we can write small interpreters or compilers for different backends, jvm, javascript, .net, com-shims for running inside excel, etc.
19:14:38 <joneshf-laptop> I'm casing on `Either`s with different `Left` sides so I can't clean it up with do's. Do I need to unify the `Left`s in some other sum type, or is there some simpler way to do that?
19:14:41 <edwardk> n0n3such: ultimately it depends on the nature of the project. a lot of what i do is remove barriers from being able to do things in haskell. this is sort of the nature of the projects i have on github.
19:15:13 <n0n3such> right ok thanks ttyl
19:15:56 <edwardk> i've spent pretty much the last 8 years building tools for other people to make it easier for them to make the case that they can write what they want to write in haskell, and trying to showcase some cool things along the way
19:16:03 <mseeks> I'm getting an error about not-in-scope data constructor for `Object` in a FromJSON instance even though I import `Object (..)` from Data.Aeson
19:16:38 <edwardk> along the way this has led to er.. a rather large set of projects: https://github.com/ekmett?tab=repositories
19:16:52 <dmwit> mseeks: perhaps Object is not a constructor of the Object type
19:17:14 <n0n3such> edwardk i'm aware of your contributions to haskell and computer science in general
19:17:54 <joneshf-laptop> or am I just wanting like `ErrorT`/`ExceptT`/whatever it is
19:18:03 <n0n3such> thanks for being so accessible
19:18:09 <dmwit> :t left -- joneshf-laptop
19:18:10 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
19:18:20 <mseeks> dmwit: you're right, it's a data constructor for Value
19:18:33 <edwardk> thanks =)
19:19:53 <edwardk> joneshf-laptop: my usual recommendation would be to just do the two cases and figure out how you want to handle the different Left's you have, when you're done look at it and see if you can collapse the code with a well placed 'either' combinator or two
19:21:04 <joneshf-laptop> edwardk, i'm just calling `die` on them: https://github.com/ghc/ghc/blob/master/libraries/base/System/Exit.hs#L78-L82
19:21:09 <joneshf-laptop> or a close approximation
19:21:29 <joneshf-laptop> Show a => a -> IO ()
19:21:50 <edwardk> so 'either die return' could be used on each one individually
19:24:05 <joneshf-laptop> oh, I guess my `die` is too restrictive
19:24:12 <joneshf-laptop> Show a => a -> IO b
19:26:20 <jmcarthur> joneshf-laptop: i'd go with Show a => a -> IO Void, myself
19:26:50 <joneshf-laptop> oh?
19:26:50 <shachaf> Why IO Void rather than forall b. IO b?
19:27:31 <joneshf-laptop> but with either of those choices, wont `either` not work?
19:27:34 <jmcarthur> because with Show a => a -> IO b, i'm more likely to make a mistake
19:28:02 <jmcarthur> joneshf-laptop: ah, yeah, your either thing would be more complicated
19:28:19 <joneshf-laptop> I'd pretty much have to case again, I think
19:28:22 <jmcarthur> joneshf-laptop: it would have to be  either (absurd <$> die) return  or somesuch
19:28:24 <shachaf> I suppose that can be true.
19:28:44 <jmcarthur> joneshf-laptop: oops, type error
19:28:53 <jmcarthur> joneshf-laptop:   either (fmap absurd . die) return
19:29:13 <jmcarthur> shachaf: i have definitely seen bugs in production code from the same issue
19:29:24 <joneshf-laptop> hmm
19:29:34 <joneshf-laptop> maybe it's best to leave it as cases then
19:29:40 <joneshf-laptop> wait
19:29:49 <shachaf> jmcarthur: I can believe that.
19:29:52 <joneshf-laptop> then why is `die` going into 7.10?
19:30:02 <jmcarthur> shachaf: that is, bugs that would have been caught by the compiler by using never_returns/Nothing.t (this is ocaml)
19:30:23 <jmcarthur> joneshf-laptop: what's this about cases now?
19:30:33 <shachaf> jmcarthur: OCaml does something similar for continuations, doesn't it?
19:30:34 <joneshf-laptop> one sec, i'll paste
19:30:39 <shachaf> Or was that SML? Or am I thinking of something else?
19:30:48 <jmcarthur> shachaf: ocaml doesn't have built-in continuations
19:30:59 <jmcarthur> there's some ML out there that does i think
19:31:36 <haasn> What's a continuation?
19:31:37 <jmcarthur> well, i should say... ocaml doesn't have anything like callcc
19:31:51 <shachaf> jmcarthur: Would you change Haskell's callcc to use Void?
19:32:14 <dolio> You mean where you have an 'a cont type?
19:32:15 <jmcarthur> shachaf: no, i would instead change it to more of a delimited continuation thing ;)
19:32:44 <dolio> And a throw : 'a cont -> 'a -> 'b or something?
19:32:59 <joneshf-laptop> jmcarthur, so I've got code that looks like this: https://gist.github.com/joneshf/d41f35c6b634a6f5e3ad
19:33:27 <jmcarthur> joneshf-laptop: looks like a job for the Monad instance for Either, to me
19:33:30 <shachaf> dolio: I don't know what I mean exactly.
19:33:36 <shachaf> haasn: It's how you continue. hth
19:34:02 <yukko> :t [return 'a'] :: [String]
19:34:04 <lambdabot> [String]
19:34:13 <yukko> im really confused about why that works
19:34:19 <haasn> shachaf: thanks!
19:34:21 <Zemyla> Why is Either not a MonadPlus?
19:34:39 <jmcarthur> Zemyla: what would mzero be?
19:34:42 <joneshf-laptop> jmcarthur, if i go with the less safe definition of `die` I can flatten: https://gist.github.com/joneshf/d41f35c6b634a6f5e3ad#file-flatter-hs
19:34:50 <shachaf> haasn: I guess you probably want a better answer but that would be easier with more context.
19:34:57 <Zemyla> jmcarthur: ...right.
19:35:02 <jmcarthur> joneshf-laptop: i'll annotate what i mean
19:35:33 <joneshf-laptop> jmcarthur, but `foo :: Either Foo Bar` and `bar :: Bar -> Either Baz Bar`
19:35:40 <jmcarthur> ugh, i never properly figured out how to work with gists
19:35:42 <joneshf-laptop> so the types don't line up
19:35:48 <jmcarthur> aha
19:35:49 <joneshf-laptop> want me to lpaste instead?
19:36:29 <joneshf-laptop> jmcarthur, http://lpaste.net/119997
19:37:25 <jmcarthur> joneshf-laptop: yeah, now that i realize your problem i realize my idea doesn't work, at least not as simply
19:38:36 <t4nk979> Hi guys. What's wrong with my pattern matching??
19:38:39 <t4nk979> data List a = Cons a (List a)    3              | Nil    4                deriving (Show)    5    6converse :: List a -> [a]    7converse (Cons a (List as)) = a ++ converse as    8converse Nil = []
19:38:48 <jmcarthur> joneshf-laptop: all these eithers are things you can't control or don't want to change? that is, you wouldn't want to just use die instead of Left in the first place?
19:39:16 <t4nk979> data List a = Cons a (List a) | Nil deriving (Show)
19:39:25 <t4nk979> converse :: List a -> [a]
19:39:31 <shachaf> t4nk979: Probably best to use hpaste.org
19:39:38 <jmcarthur> lpaste.org
19:39:46 <shachaf> You can use hpaste.org or lpaste.net
19:39:51 <jmcarthur> bah
19:39:54 <jmcarthur> i was more wrong
19:39:55 <shachaf> They are the same website.
19:40:00 <vanila> converse (Cons a as) = a ++ converse as
19:40:01 <vanila> do this
19:40:09 <jmcarthur> i got used to hpaste being defunct and never recovered
19:40:12 <vanila> when you have (List a) in the data definition, it just means that one will be of type list
19:41:01 <t4nk979> are you talking about the (Cons a as) is List a
19:41:08 <vanila> yes
19:41:13 <vanila> and as :: List a
19:42:56 <joneshf-laptop> jmcarthur, I guess that's another option, since they're all `IO (Either Foo Bar)` and I don't care about the `Foo`s, I could just make them `IO Bar` and be done with it
19:43:16 <Hijiri> IO (Maybe Bar)
19:43:49 <joneshf-laptop> but that feels weird
19:44:06 <joneshf-laptop> since main can exit at some random time without it looking explicit
19:44:14 <joneshf-laptop> explicit like it's going to exit
19:44:37 <joneshf-laptop> at least with `die` strewn about I have an indicator that something fishy might happen
19:44:51 <edwardk> fwiw- i tend to make things that never return give back a polymorphic result rather than an explicit Void
19:44:56 <jmcarthur> joneshf-laptop: or if you want something in between...    data OrError a = forall e. Show e => Error e | Ok a
19:45:39 <jmcarthur> joneshf-laptop: or a monad transformer version of the same:   newtype OrErrorT m a = OrErrorT (m (OrError a))
19:47:13 <wizao> can someone help me understand this problem I'm having
19:47:38 <wizao> I have a function that is the same code
19:47:48 <jmcarthur> edwardk: any particular reason, or is it largely unmotivated?
19:47:59 <wizao> doesNotWork = map f . transpose . map f
19:48:10 <wizao> doesWork = map g. transpose . map f
19:48:16 <wizao> if i just make g and f have same bodies
19:48:21 <wizao> I'm kinda new to haskell
19:48:25 <benzrf> aha
19:48:33 <edwardk> jmcarthur: much easier to use in practice, and the polymorphic value in positive position, with no other constraints tells you it has to be unused anyways
19:48:36 <benzrf> wizao: are f and g defined in a where clause
19:48:43 <geekosaur> I think we'd have to see more...
19:48:45 <benzrf> er, wait
19:48:45 <wizao> doesnt matter if its top level
19:48:48 <benzrf> :t transpose
19:48:49 <lambdabot> [[a]] -> [[a]]
19:48:49 <dpwright> I'm trying to patch up a library to build on windows, and some of the changes are in Setup.hs.  If I put "#if defined(__MINGW32__)" etc in there I get a lexical error though.  Does cabal not run Setup.hs through the CPP before compiling it?
19:48:52 <edwardk> :t traverse (const Nothing)
19:48:53 <benzrf> nvm
19:48:53 <lambdabot> Traversable t => t a -> Maybe (t b)
19:48:59 <wizao> but the bodies are the same
19:49:08 <jmcarthur> edwardk: the reason i prefer Void is not for the documentation but for the type errors, when i write something i probably didn't intend
19:49:10 <benzrf> i was thinking of where clauses not generalizing properly
19:49:16 <geekosaur> dpwright, {-# LANGUAGE CPP #-}
19:49:17 <benzrf> but i guess transpose keeps the type the same
19:49:21 <benzrf> wizao: full code?
19:49:23 <dmwit> wizao: I challenge your claim. Show us some code!
19:49:25 <dpwright> geekosaur: D7oh! thanks :-D
19:49:27 <benzrf> wizao: and first off, whats the error
19:49:31 <wizao> ill add it in a sec
19:49:41 <dmwit> ?paste
19:49:42 <wizao> I'm working on this problem:
19:49:42 <lambdabot> Haskell pastebin: http://lpaste.net/
19:49:43 <edwardk> jmcarthur: my experience is i don't write those 'hey crash' polymorphic things in contexts where i can intend something else. =P
19:49:52 <wizao> http://www.reddit.com/r/dailyprogrammer/comments/2uo3yf/20150204_challenge_200_intermediate_metro_tile/
19:49:54 <dmwit> wizao: (Use that site instead of pasting in-channel.)
19:50:06 <wizao> I'll use site shortly
19:50:09 <wizao> but the problem is there
19:50:13 <wizao> just for learning
19:50:14 <jmcarthur> edwardk: they aren't always "crashes". e.g. the continuation of callcc
19:50:33 <edwardk> sure, but lets look at the continuation of callCC. you can put it anywhere _because you shoul be able to put it anywhere!)
19:50:40 <edwardk> it isn't even the right type
19:50:41 <edwardk> :t callCC
19:50:42 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
19:50:50 <edwardk> that should have another quantifier on it
19:51:01 <jmcarthur> sure
19:51:06 <edwardk> MoandCont m => ((forall b. a -> m b) -> m a) -> m a
19:51:10 <jmcarthur> that would be the same as using Void
19:51:20 <jmcarthur> just without having to use absurd in some contexts
19:51:28 <edwardk> except, the Void makes actually invoking the continuation you want even harder.
19:51:46 <edwardk> you now have to mess with absurd <$>   needlessly making code slower and harder to read when there is no other possible interpretation
19:52:03 <sinnsat> @pl foo (x, y) (a, b) = (x ++ a, y ++ b)
19:52:03 <lambdabot> foo = uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (++)) . flip . (((.) . (,)) .) . (++))
19:52:05 <sinnsat> lol
19:52:10 <edwardk> one or the other is a forgivable sin, but making code both slower and harder to read seems kind of a false economy to me ;)
19:53:06 <edwardk> on the other hand, every time i write a parsing combinator and have to litter it with _ <- char 'c'   's I get particularly annoyed as well.
19:54:07 <edwardk> Anyways, my personal habit is to limit my use of Void to negative position.
19:54:32 <lpaste> wizao pasted “Wizao's problem” at http://lpaste.net/119998
19:54:54 <jmcarthur> i agree that in negative position it seems far less controversial
19:55:37 <lpaste> wizao revised “Wizao's problem”: “No title” at http://lpaste.net/119998
19:55:40 <edwardk> wizao: if you put a signature on f does it work?
19:55:50 <wizao> I'll try that
19:56:35 <mseeks> maybe because it's specializing `f` to a specific type?
19:56:40 <edwardk> wizao: f :: Eq a => [a] -> [[(Integer, a)]]
19:56:42 <edwardk> that should fix it
19:56:42 <wizao> no luck edwardk
19:56:52 <enthropy> @where dmr
19:56:52 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
19:56:59 <wizao> I used CHar instead, ill try the Eq a
19:57:20 <wizao> but i thtought it was what mseeks said so i came here
19:57:23 <edwardk> wizao: g :: [[(Integer, Char)]] -> [[(Integer, [(Integer, Char)])]]  -- was the other signature
19:57:29 <edwardk> so they were getting different signatures
19:57:33 <dmwit> Okay. I announce where I was wrong: "transpose :: [[a]] -> [[a]]" in "transpose . map f" does not imply "f :: [a] -> [a]". I also apologize to wizao for challenging his claim.
19:57:38 <edwardk> if you used NoMonomorphismRestriction it would have worked
19:57:58 <wizao> Any good articles on that?  ive seen it here and there
19:57:59 <edwardk> so either {-# LANGUAGE NoMonomorphismRestriction #-}
19:58:05 <edwardk> or the explicit signature on 'f' is needed
19:58:10 <wizao> the wiki was a start and it kinda lead me to that
19:59:09 <Zemyla> How does if work in NoImplicitPrelude?
19:59:29 <wizao> it works with NoMonomorphismRestriction and type
19:59:35 <dmwit> if/then/else is syntax, not a library function.
19:59:51 <wizao> thanks guys!
20:00:50 <edwardk> wizao: you only need one or the other
20:00:54 <t4nk979> Is there an obvious difference between guards and cases?
20:01:14 <Hijiri> guards check boolean expressions and cases do pattern matching
20:01:25 <wizao> I understand that, thanks
20:01:26 <sinnsat> edwardk: your lenses videos are with scala examples? :/
20:01:42 <edwardk> sinnsat: i gave a talk on scala lenses early on. i also gave a talk on lenses in haskell
20:01:49 <edwardk> well, several talks
20:01:56 <edwardk> but at least one at new york haskell is available online
20:01:56 <sinnsat> then I looked up the wrong video I guess
20:02:06 <edwardk> most of the other tutorials i've done weren't recorded for various reasons
20:02:24 <edwardk> the one from new york haskell is even still mostly true today, the bit about isomorphisms at the end is a bit off
20:02:30 <sinnsat> the one with the vacuum cleaner until minute 11
20:02:37 <edwardk> yeah that was kind of maddening
20:03:41 <edwardk> i'd banged out lenses in scalaz when we had to deal with all sorts of complex state inside of a stream processing library at work, and that talk was summarizing the work on those.
20:04:01 <edwardk> the machinery that gave rise to 'lens' came later, based on putting laws on some observations by roconnor
20:05:22 <randomclown> How do you pattern match on bytestrings
20:05:30 <Denommus> hi
20:05:45 <randomclown> let (xs, '\n':ys) = B.break "whatever\nasdfasd"
20:05:51 <randomclown> except for bytestrings
20:05:54 <EvanR> randomclown: you cant directly because the constructors are for all intents and purposes hidden
20:06:12 <randomclown> how do you write the above with viewpatterns
20:07:11 <benzrf> randomclown: uncons or something!
20:07:11 <octopuscabbage> anyone got a good small open source haskell project they want help on? i'm looking for something to contribute to
20:08:42 <mmachenry> octopuscabbage: I would love it if Esqualtio had Oracle support :)
20:09:24 <mmachenry> That's perhaps not small.
20:10:57 <sinnsat> octopuscabbage: do you do computational geometry or somesuch?
20:12:29 <jle`> it's cool in haskell that you can work with the concept of infinite lists
20:12:44 <jle`> with little friction
20:13:40 <octopuscabbage> sinnsat, i can tryyy
20:15:26 <octopuscabbage> sinnsat, at the moment i mostly do student
20:15:31 <sinnsat> octopuscabbage: not really much, but if you feel bored you can review/comment/improve my attempt of the half-edge data structure https://gist.github.com/hasufell/f954d110086b06b3adc9
20:15:46 <sinnsat> there is a lot to improve, I guess
20:16:07 <t4nk979> mean' :: Num a => [a] -> Fractional
20:16:08 <t4nk979> mean' as = fromIntegral (sum as) / fromIntegral $ length' as
20:16:30 <t4nk979> how come the compiler complains about fractional has kind '* -> Constraint'
20:17:51 <octopuscabbage> sinnsat, i'm afraid i don't know enough about the subject matter to be able to even help :/
20:17:57 <Hijiri> t4nk979: it means Fractional isn't a concrete type
20:18:00 <Hijiri> it's a typeclass
20:18:45 <Hijiri> If the output can be any Fractional, you would want (Num a, Fractional b) => [a] -> Fractional
20:18:50 <Hijiri> typo
20:19:00 <Hijiri> (Num a, Fractional b) => [a] -> b
20:19:25 <sinnsat> octopuscabbage: if you check the link at the module description you come to a page that explains the data structure in C code... which is farily simple. Only constructing it and making a purely functional API on top of it is difficult
20:19:26 <Hijiri> but that isn't how your function is typed
20:19:34 <t4nk979> ah.
20:19:53 <Hijiri> it would still be badly typed because you can't do fromIntegral (sum as)
20:20:03 <Hijiri> you would need a to be Integral
20:20:43 <Hijiri> (I mean that a has an Integral instance)
20:21:14 <t4nk979> I would like a to be in the Num type class (?)
20:21:16 <t4nk979> I think
20:21:23 <t4nk979> it doesn't have to be an integral.
20:21:36 <Hijiri> sum as will give you some Num a => a, right?
20:21:44 <Hijiri> :t fromIntegral
20:21:45 <lambdabot> (Num b, Integral a) => a -> b
20:22:00 <Hijiri> what you put in fromIntegral needs to have Integral instance
20:22:06 <Hijiri> that's why it's called fromIntegral
20:22:08 <Hijiri> :t sum
20:22:09 <lambdabot> Num a => [a] -> a
20:22:12 <t4nk979> ah i see.
20:22:27 <Hijiri> If you only know that the list has Nums in it, then you only know that the result is a Num, not that it is Integral
20:22:43 <t4nk979> can I just take out the fromIntegral then
20:22:45 <t4nk979> and have the type
20:22:50 <t4nk979> Num a => a -> a
20:23:19 <Hijiri> no, because (/) is only defined for Fractionals
20:24:22 <t4nk979> Can I do a num to a fractional?
20:24:25 <Hijiri> nope
20:24:34 <t4nk979> why is division so hard
20:24:43 <Hijiri> you can't divide everything that is num
20:24:54 <Hijiri> for example, you can't do fractional division on integers
20:25:03 <Hijiri> (you can do integer division that just throws away the remainder)
20:25:25 <Hijiri> Num just doesn't give you the operations to implement division
20:26:28 * hackagebot egison 3.5.6 - Programming language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.5.6 (SatoshiEgi)
20:27:46 <t4nk979> Can I do a fractional to fractional?
20:28:01 <Hijiri> I'm not sure, I wouldn't expect to be able to
20:28:06 <Hijiri> I don't think so
20:28:26 <Hijiri> you can't, just checked
20:28:32 <shachaf> whoa, Gmail filtered HWN to Spam.
20:30:14 <t4nk979> So doesthat mean a different average function has to be constructed for different input data types?
20:31:13 <Hijiri> you could define one that works on all Integrals, and all Fractional, I think, not sure how much more general you can get
20:32:19 <Hijiri> the Integral one would be polymorphic in the output (which would be something Fractional), but the Fractional one would have an output type the same as the input
20:42:13 <ReinH> ]
20:42:15 <ReinH> ['
20:42:25 <ReinH> woops  sorry
20:42:28 <ReinH> cat
20:47:28 <jle`> t4nk979: how do you think you would write an algorithm that can average any Num?
20:48:36 <jle`> there really isn't a meaningful way, so haskell's type system not allowing it is actaully a reflection of what is actually possible
20:49:00 <orzo> what's wrong with sum xs / length xs ?
20:49:26 <jle`> orzo: not all things that can be summed can be divided
20:49:48 <orzo> oh i guess / is not in Num
20:51:41 <t4nk979> Haskell is my favorite language
20:51:46 <orzo> not all things that can be summed have a multiplicative identity either, but that didn't stop Num
20:51:50 <t4nk979> though it furustrates me sometimes
20:52:25 <jle`> orzo: a multiplicative identity is actaully a part of the Num typeclass
20:52:34 <orzo> exactly my point
20:52:37 <orzo> and / is not
20:53:04 <t4nk979> So if I had an integral list
20:53:08 <orzo> your coments make it sound like it was all due to well planned mathematics rather than somewhat arbitrary decisions of the designers
20:53:17 <t4nk979> or i mean
20:53:21 <jle`> ;)
20:53:22 <ttt_fff> isntead of idris/purescript, will someone please create a variant of ahskell where (1) syntax is exact same, (2) language is strict, and (3) language compiles to js? pretty please ?
20:53:33 <t4nk979> sum returns a integral so I have to convert that to a num
20:53:36 <t4nk979> and same with length rirhgt
20:53:40 <t4nk979> in order for fractional to work
20:54:09 <nshepperd> the numeric typeclasses are not particularly logical right now
20:54:10 <orzo> hmmm
20:54:19 <orzo> isn't there an llvm backend targetting js?
20:54:30 <orzo> i'd expect we could compile haskell to that
20:54:36 <orzo> via the haskell llvm codegen
20:54:56 <ttt_fff> if we go tht far
20:55:01 <ttt_fff> I think there is a qemu written in js
20:55:10 <ttt_fff> so I could have haskell on linux on qemu on chrome
20:55:16 <orzo> emscripten
20:55:16 <jle`> orzo: it's more like, you can't necessarily expect it to be merged in...and if it is, then that's a happy coincidence
20:55:39 <orzo> https://github.com/kripken/emscripten/wiki
20:55:59 <orzo> ^ does this mean a js target for ghc is trivial?
20:56:17 <jle`> there are a lot of Nums that don't have meaningful /'s, so the division of the classes is something kinda neat
20:57:11 <orzo> yes, i think i'd rather Num was split up more
20:57:40 <t4nk979> for the sortBy function
20:57:54 <orzo> its not being so causes us to define silly point-wise multiplication operators for vectors
20:58:04 <t4nk979> i need to supply it a function that does a -> a -> Ordering
20:58:11 <t4nk979> can the a be a list?
20:58:14 <Azel> To compile to Javascript, isn't there ghcjs?
20:58:22 <Cale> t4nk979: It can be any type you like
20:58:39 <orzo> https://github.com/ghcjs/ghcjs
20:58:42 <orzo> looks like it
20:59:00 <nshepperd> i hope to live to see the day that haskell's numeric prelude gets made into something sensible
20:59:16 <orzo> ttt_fff: see ghcjs for haskell to js compiler
20:59:18 <HeladoDeBrownie> nshepperd, you will most likely not survive the heat death of the universe.
20:59:20 <Cale> I don't think it's that far from being sensible
20:59:34 <Cale> There are a few small things which are a bit off
21:00:58 <t4nk979> So this is a valid ordering function
21:00:58 <t4nk979> order' [a] -> [a] -> Ordering   33order' as bs   34  | length as > length bs = GT   35  | length as < length bs = LT   36  | length as == length bs = EQ
21:01:21 <t4nk979> order' [a] -> [a] -> Ordering order' as bs     | length as > length bs = GT     | length as < length bs = LT     | length as == length bs = EQ
21:01:49 <orzo> t4nk979: that's real hard to read, maybe use a pastebin?
21:01:57 <t4nk979> how do i do that
21:02:08 <dmwit> :t comparing length
21:02:09 <lambdabot> [a] -> [a] -> Ordering
21:02:15 <orzo> t4nk979: http://lpaste.net/
21:02:33 <t4nk979> http://lpaste.net/raw/120004
21:02:35 <t4nk979> does that work?
21:02:42 <orzo> yep
21:02:52 <orzo> readable now
21:02:54 <benzrf> t4nk979: sounds like you want
21:02:55 <dmwit> :t sortBy (comparing length)
21:02:56 <lambdabot> [[a]] -> [[a]]
21:03:03 <benzrf> t4nk979: compare (length as) (length bs)
21:03:42 <orzo> or import Data.Function and use (compare `on` length)
21:04:00 <t4nk979> Yeah. I just want to get the type signature right
21:04:12 <orzo> oh, well you need :::
21:04:13 <orzo> er
21:04:13 <orzo> ::
21:04:17 <orzo> you're missing that in your paste
21:04:22 <t4nk979> oh.
21:04:24 <orzo> order' :: [a] -> [a] -> Ordering
21:06:23 <dmwit> :t realToFrac
21:06:24 <lambdabot> (Real a, Fractional b) => a -> b
21:06:32 <dmwit> To convert between Fractional types.
21:11:42 <glguy> t4nk979: If you were doing that for anything "real" you'd at least want to make sure that you only computed the lengths once
21:12:14 <sdegutis> Is there a ReactJS thing for Haskell?
21:12:15 <orzo> i'd not be surprised if ghc would unifty that anyway, glguy
21:12:26 <orzo> unify
21:12:27 <glguy> orzo: very unlikely
21:12:52 <t4nk979> like use a where clause right
21:13:11 <glguy> t4nk979: You could pair up the lists with their lengths in a tuple and sort by the length field of the tuple
21:13:20 <glguy> and then remove the length annotation, for example
21:14:11 <dmwit> This is why we need *On for everything we have *By for already.
21:14:27 <glguy> map snd (sortBy (comparing fst) [(length x, x) | x <- xs]) -- is the inlined version
21:14:54 <dmwit> Dmwit.Prelude has them already. ;-)
21:18:56 <edwardk> didn't we add sortOn?
21:19:30 <johnw> yes, we did
21:19:35 <johnw> at least, I submitted the PR on it
21:19:41 <glguy> It's in HEAD, at lest
21:19:58 <glguy> and 7.10-rc
21:20:50 <lpaste> orzo pasted “ghc does unify it.” at http://lpaste.net/120005
21:21:07 <orzo> glguy: you're wrong
21:21:29 <glguy> about what?
21:21:55 <orzo> about ghc not duplicating calls to length
21:22:11 <orzo> it unified it like i said
21:22:18 <glguy> orzo: No, you missed by point
21:22:28 <glguy> when you sort with this function it will recompute the length at each comparison
21:22:43 <glguy> Not inside order', but inside sortBy
21:23:00 <orzo> i figured you were reacting to how many times he wrote length in his definition of order'
21:23:42 <glguy> Nope, but in that case it'd be better to use compare directly than to inline it like that
21:24:06 <glguy> Not for efficiency but for clarity
21:25:55 <MrMetric> Hay
21:26:31 * hackagebot warp-tls 3.0.1.4 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-3.0.1.4 (MichaelSnoyman)
21:26:33 * hackagebot warp 3.0.8 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.8 (MichaelSnoyman)
21:26:35 * hackagebot wai-websockets 3.0.0.4 - Provide a bridge betweeen WAI and the websockets package.  http://hackage.haskell.org/package/wai-websockets-3.0.0.4 (MichaelSnoyman)
21:26:37 <EvanR> i cant remember whether True or False is the return value for an error or not... so i changed it to Either () (). have i lost my mind
21:27:05 <fread2282>     /j #mtg
21:27:09 <fread2282> whops
21:27:10 <glguy> data WhateverResult = ThatParticularError | It'sAllGood
21:27:27 <MrMetric> Is that hackagebot warp thing an ad?
21:27:36 <EvanR> ok
21:27:49 <EvanR> theres no particular error just "failed"
21:27:58 <glguy> MrMetric: Better word is "announcement" probably
21:27:59 <EvanR> but yeah a new type makes more sense
21:34:12 <c_wraith> MrMetric: hackagebot just posts when a new package (or version of a package) is uploaded to hackage.  It's not endorsing libraries - just letting us know what's seeing updates.
21:34:16 <siddhu> I need to do: `f a >>= f >>= f >>= f >>= f >>= mapM_ print` where the number of times I have to call f is 20. Is there a shorter way to do this?
21:34:59 <MrMetric> How can I install the "dyn" libraries for transformers? cabal says I need it for some other stuff, but when I tell it to reinstall transformers with shared enabled, it says that some other packages are likely to be broken
21:35:03 <augur> :t iterateM
21:35:04 <lambdabot>     Not in scope: ‘iterateM’
21:35:05 <lambdabot>     Perhaps you meant one of these:
21:35:05 <lambdabot>       ‘iterate’ (imported from Data.List),
21:35:14 <c_wraith> augur: iterateM doesn't make sense for most monads anyway
21:35:21 <augur> hm
21:35:31 <c_wraith> siddhu: some combination of replicate and foldr (<=<) return
21:35:53 <c_wraith> :t foldr (<=<) return . replicate 20
21:35:55 <lambdabot> Monad m => (b -> m b) -> b -> m b
21:35:55 <augur> or maybe iterate (join.f) ?
21:36:33 <c_wraith> yeah, my example got the right type signature!  woo!  :)
21:36:39 <augur> :)
21:42:30 <siddhu> that worked. thanks c_wraith and augur :)
21:42:44 <augur> dont thank me, i did nothing! :p
21:43:30 <c_wraith> siddhu: Do you understand what's going on there?  I don't want to just throw out a cryptic recipe. :)
21:44:14 <augur> c_wraith: i love me some Kleisli categories
21:45:36 <c_wraith> I may think that Kleisli categories are the best reason to explain the motivation for monads.  Hey!  Categories are cool!  Ones that fit this pattern are handy!  (... and they happen to be the same thing as monads, but nevermind that detail)
21:47:07 <HeladoDeBrownie> i, too, agree that kleisli categories are the bee's knees.
21:53:00 <merkeyes> http://foreskin-restoration.net/forum/search.php?do=getdaily
21:53:50 --- mode: ChanServ set +o glguy
21:53:55 --- kick: merkeyes was kicked by glguy (Your behavior is not conducive to the desired environment.)
21:56:41 <ttt_fff> glguy: would that have been acceptable for #haskell-blah ?
21:56:59 <glguy> moderation discussion is welcome in #haskell-ops
21:58:06 <EvanR> :t bool
21:58:07 <lambdabot> a -> a -> Bool -> a
21:58:16 <EvanR> > bool 3 4 False
21:58:17 <lambdabot>  3
21:59:04 <EvanR> hehe bool-extras
21:59:28 <siddhu> c_wraith: yes, I understand.
21:59:28 <EvanR> downloading this so i dont have to implement the entire bool function myself
22:02:21 <ttt_fff> :t (1+2)
22:02:22 <lambdabot> Num a => a
22:03:09 <orzo> EvanR: bool is in base since 4.7.0.0 in Data.Bool
22:06:33 <taylor1791> Can someone tell me if this function exists somewhere else? evolve f g a b = f (g a) (g b)
22:06:41 <heatsink> @src on
22:06:41 <lambdabot> (*) `on` f = \x y -> f x * f y
22:06:55 <Axman6> so, that's f `on` g
22:07:05 <heatsink> yea
22:07:35 <taylor1791> Thats awesome thanks!
22:08:22 <Axman6> @hoogle on
22:08:24 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
22:08:25 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
22:08:25 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
22:08:35 <Axman6> for completeness, it's in Data.Function
22:09:03 <glguy> Data.Function.on
22:09:10 <glguy> Oh... I was scrolled off :)
22:09:12 --- mode: glguy set -o glguy
22:12:46 <heatsink> If non-Haskell code creates a new OS thread and calls Haskell functions from it, what thread does the Haskell code run on in GHC?
22:46:37 * hackagebot mikmod 0.2.0.0 - MikMod bindings  http://hackage.haskell.org/package/mikmod-0.2.0.0 (evanrinehart)
22:46:39 <EvanR> orzo: i actually decided not to use it because i got it backwards
22:46:46 <EvanR> so i used a case
22:47:03 <jle`> evolve is a great name for a function
22:48:45 <EvanR> heatsink: some thread
22:49:10 <EvanR> it just works (tm)
22:49:11 <heatsink> Well, that's better than no thread
22:49:24 <heatsink> Is it a bound thread?
22:49:44 <EvanR> i had to read this paper just to get started understanding this stuff http://community.haskell.org/~simonmar/papers/conc-ffi.pdf
22:50:19 <EvanR> these things never seem to have a date on them so i dont know how up to date it is with respect to ghc
22:50:35 <EvanR> "Submitted to The Haskell Workshop, 2004"
22:51:21 <EvanR> the case youre talking about, some OS thread created in another language calling haskell code is one of the cases discussed in that paper
22:51:35 <LordBrain> maybe the internet itself should have date stamps
22:51:49 <LordBrain> i suppose it does
22:51:55 <LordBrain> for whatever they are worth
22:52:22 <LordBrain> the browsers tend to delete them, but if you use wget i think its default is to leave the ctime from the server
22:52:32 <LordBrain> i think...
22:52:39 <LordBrain> not 100% on that :)
22:52:44 <EvanR> heatsink: it takes the stance that the only way bound threads come into existence is through this mechanism, a foreign function calls into haskell
22:52:45 <heatsink> thanks EvanR
22:55:17 <EvanR> page 4 under required 4
22:55:20 <EvanR> requirement
23:06:44 <dmwit> EvanR: that's a great paper
23:07:19 <dmwit> you might also like the non-gtk parts of dmwit.com/gtk2hs
23:21:36 <EvanR> dmwit: im starting to get a feel for how the ffi and threads work, the first thing i found on the subject suggested that unsafe should be the default and safe is for the 'rare occasion' youd be calling back into haskell
23:21:43 <EvanR> which bit me in the ass
23:23:04 <EvanR> at this point im still not tatally sure how my test program works without -threaded
23:23:24 <EvanR> i guess everything is all happening on one thread anyway
23:26:09 <EvanR> dmwit: speaking of gtk, do you know of any project to make something like it in "pure haskell"
23:26:33 <EvanR> a gui toolkit without the platform baggage
