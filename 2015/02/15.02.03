00:07:33 <gamegoblin> Does newtype add any overhead comapred with a type synonym?
00:07:54 <phaazon> hm
00:08:03 <phaazon> in C, is #line defined?
00:08:10 <gamegoblin> __LINE__ iirc
00:08:11 <phaazon> I think that’s causing an error in c2hs
00:08:50 <phaazon> or it’s a c2hs CPP directive?
00:09:26 * hackagebot pgdl 6.8 - pgdownloader  http://hackage.haskell.org/package/pgdl-6.8 (sifmelcara)
00:09:26 * hackagebot pgdl 6.9 - pgdownloader  http://hackage.haskell.org/package/pgdl-6.9 (sifmelcara)
00:10:33 <dmwit> gamegoblin: There is a risk of overhead in certain operations, though modern GHC has ways around it.
00:10:49 <Zemyla> Why isn't build exposed at all?
00:11:13 <dmwit> gamegoblin: e.g. (map unNewtype) would traverse a structure, whereas the type-synonym version is just "id". But modern GHC would let you write this as a coercion with the same cost as id.
00:11:33 <gamegoblin> dmwit: what do you mean as a coercion?
00:12:03 <dmwit> gamegoblin: https://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Coerce.html#v:coerce
00:12:12 <Zemyla> Hmm. build makes (++) pretty much free, right?
00:12:13 <jle`> interpret this thing in memory as if it were the other thing
00:12:29 <Zemyla> Because (build g) ++ ls = g (:) ls?
00:12:40 <jle`> [Sum 1, Sum 2, Sum 3] is indistinguishable in memory from [1, 2, 3]
00:13:08 <jle`> so coerce can treat [Sum 1, Sum 2, Sum 3] as if it were a [1, 2, 3], with no cost
00:13:32 <jle`> coerce :: [Sum a] -> [a], for "free", no overhead
00:13:57 <dmwit> It's odd that they decided to make an actual class named Coercible.
00:13:59 <jle`> um, same for the backwards coerce :: [a] -> [Sum a]
00:14:14 <phaazon> god, c2hs has such a bad documentation :(
00:14:27 <dmwit> I wonder why they did that instead of going the route they used with ~, that is, just make a new type-level thing of kind k -> k -> Constraint.
00:14:28 <phaazon> hm
00:14:30 <ab9rf> dmwit: i guess to allow typechecking to occur normally
00:14:39 <phaazon> I guess the #line keyword is ill-formed in c2hs
00:14:42 <dmwit> ab9rf: I don't understand.
00:14:46 <phaazon> it doesn’t even understand it
00:14:46 <ab9rf> dmwit: neither do i
00:14:59 <ab9rf> dmwit: there's a paper that may explain
00:16:11 <jle`> does anybody ever really understand anything
00:16:24 <tzaeru> yes, but generally no
00:16:25 <dmwit> The paper does not appear to discuss this question.
00:16:45 <ab9rf> i understand very few things
00:16:57 <ab9rf> and the more things i try to understand, the fewer i actually do
00:17:01 <negatratoron> i understand fewer things!
00:17:10 <tzaeru> that's weird. I understand the more things the more I try to understand O_o
00:17:36 <negatratoron> actually i try to climb on top of things
00:17:55 <negatratoron> typically that gives me a better vantage point
00:17:57 <tzaeru> I understand billions of things. naturally there are also billions upon billions upon billions of things I don't.
00:18:12 <tzaeru> and I do suppose that upon understanding some hundred new things, there are a few thousand new things popping to my consciousness I don't understand
00:18:56 <tzaeru> but the idea that "wisdom is knowing that we know nothing" is just an empty worldplay, really.
00:19:27 <dmwit> I assert without evidence that this was not a conscious design choice.
00:19:31 <tzaeru> and I find that it kinda trivialises the amazingness of human cognition
00:20:30 <negatratoron> yo mama both complete and consistent!
00:20:42 <randomclown> How can you get something like this to work
00:20:54 <randomclown> i.e. Left 'a' >>= Left "abcd"
00:21:02 <dmwit> > Left 'a' >> Left "abcd"
00:21:03 <lambdabot>  Couldn't match expected type ‘GHC.Types.Char’
00:21:04 <lambdabot>              with actual type ‘[GHC.Types.Char]’
00:21:04 <jle`> randomclown: what do you want to do?
00:21:07 <randomclown> chaining together two eithers with different lefts
00:21:09 <jle`> what do you want it to end up as?
00:21:09 <randomclown> error handling
00:21:16 <jle`> what should the result be?
00:21:24 <randomclown> (Show a0
00:21:26 <dmwit> > Left "a" >> Left "abcd"
00:21:28 <lambdabot>  Left "a"
00:21:35 <glguy> Dmwit: the constraint is solved as a special case in the type checker AFAIK. That it looks like a type class just seems to save us from a syntactic special case, it seems
00:21:39 <jle`> what do you expect the result to be?
00:21:44 <jle`> s/expect/want
00:21:45 <randomclown> I'm looking for something like Either (Show a) b
00:21:58 <jle`> so what should the result of that be?
00:22:01 <randomclown> b
00:22:05 <ab9rf> (Show a) => Either a b ?
00:22:12 <dmwit> glguy: Why would there have to be a special case?
00:22:13 <jle`> Left 'a' *> Left "abc"   == b?
00:22:22 <jle`> is b a defined variable?
00:22:47 <jle`> Left 'a' >> Left "abc" == ????? (what is the result you are looking for?)
00:22:51 <dmwit> bimap show id (Left 'a') >> bimap show id (Left "abc")
00:22:58 <randomclown> jie` well a variable of b
00:23:05 <jle`> this is a concrete example
00:23:20 <Axman6> randomclown: what specific result do you want from Left 'a' >> Left "abcd"
00:23:21 <jle`> what do you expect that to end up as?
00:23:26 <Axman6> Left ????
00:23:27 <randomclown> Let me rephrase
00:23:30 <randomclown> lol
00:23:40 <jle`> i don't really know what you want it to be, heh
00:23:47 <jle`> so i can't really give an answer as to how to get it that way
00:23:49 <jle`> :)
00:23:50 <lfairy> randomclown: Since the only thing you can do with a Show is convert it to a String, why not just use a String instead?
00:24:29 <glguy> Dmwit: I don't think you can encode transitive instances and whatever all it allows just by automatically generating all the possible instances reasonably
00:24:43 <Axman6> > fail "pretty sure this doesn't work" :: Either String Int
00:24:44 <lambdabot>  *Exception: pretty sure this doesn't work
00:24:46 <randomclown> So suppose you have f: x -> Either a y, g: y -> b z
00:24:48 <ab9rf> do you want a combiner such that Left a >*> Left b == Left (a ++ b), maybe?
00:24:57 <dmwit> glguy: No, no, I understand why the analog of "instance search" has to be special.
00:24:58 <jle`> randomclown: mk
00:25:00 <grohne> is there a way to obtain a value of type Language.Haskell.TH.Name that is equal to '[] without enabling -XTemplateHaskell?
00:25:12 <dmwit> glguy: I'm just saying they wouldn't have to make an actual class just to avoid syntactic special cases.
00:25:14 <randomclown> I want to be able to f >>= g
00:25:30 <randomclown> but it seems like it's not happy because a != b
00:25:34 <jle`> typically what we do is we write a natural transformation
00:25:34 <dmwit> glguy: Just add a new single type-level term, Coercible, of kind forall k. k -> k -> Constraint.
00:25:45 <dmwit> glguy: Essentially the same way they've done with ~, which also has its own "instance search" analog.
00:25:48 <randomclown> sorry f >=> g
00:25:56 <randomclown> :t (>=>)
00:25:56 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
00:25:57 <jle`> natty :: b t -> (Either a) t
00:26:09 <jle`> we write a function that can convert any `b t` into an `Either a t`
00:26:12 <ab9rf> dmwit: so the quesiton is why use one strategy for Coercible, and a different for ~ ?
00:26:15 <jle`> call it `natty`
00:26:21 <jle`> and we say f >=> (natty . g)
00:26:49 <dmwit> ab9rf: Well, I guess. But not really. The real question is why make a class named Coercible. =)
00:26:51 <jle`> natty . g :: y -> Either a z
00:27:04 <dmwit> ab9rf: I'm not saying they're equally good approaches and consistency is important. I'm saying the ~ approach is *better*.
00:27:05 <randomclown> ok
00:27:17 <jle`> this is actually a pretty strong approach
00:27:24 <ab9rf> dmwit: well, that's a strong claim :)
00:27:28 <jle`> er, a powerful technique
00:27:42 <jle`> because if you have a *lot* of dofferent various b's...different contexts that all of your things live in
00:28:01 <jle`> you can find a "common denominator" and then write natural transformations from *all* of your types to that common denominator
00:28:15 <jle`> and then now all of your different y -> b z's compose with eachother in that common denominator type
00:28:35 <jle`> So if you had Either Bool, Either Char, Either Int
00:28:39 <randomclown> So I'm using (Show a, Show b) as the common denominator
00:28:44 <jle`> you could have a common denominator type as Either String
00:28:47 <dmwit> ab9rf: Not very strange. Having a magic class with no instances, which you can't declare instances for, and which nevertheless is useful, is a very magical property. Having a fresh type-level term with new behavior is not magical.
00:28:56 <jle`> and then write your Either Bool a -> Either String a, Either Char a -> Either String a, etc.
00:29:05 <jle`> and before composing, just pick the right natural transformation
00:29:24 <jle`> why not jst use Either String?
00:29:39 <randomclown> Because I'm composing library functions
00:29:55 <jle`> okay. i'm going to have to see some mroe concrete examples before i know what you're after, sorry
00:30:28 <randomclown> jle`: let's suppose that the left type implemented the Show typeclass
00:30:39 <jle`> okay
00:30:45 <jle`> of what?
00:30:55 <dmwit> :t either show id
00:30:57 <jle`> can you show some examples of what you want to compose together?
00:30:57 <lambdabot> Show a => Either a String -> String
00:31:08 <dmwit> :t either (Left . show) (Right . id)
00:31:09 <lambdabot> Show a => Either a b -> Either String b
00:31:21 <jle`> hmm
00:31:31 <dmwit> :t Data.Bifunctor.bimap show id
00:31:32 <lambdabot> (Bifunctor p, Show a) => p a d -> p String d
00:31:36 <ab9rf> dmwit: i have no response, because i don't really understand how ~ works in types anyhow :)
00:31:43 <jle`> :t left show
00:31:44 <lambdabot> Show a => Either a d -> Either String d
00:31:51 <dmwit> also good
00:31:56 <jle`> and in base so yay
00:32:24 <jle`> randomclown: `left show` gives you a a free natural transformation from any `Either a b`, where `a` is a Show, to `Either String b`
00:32:49 <jle`> so if your common denominator is Either String, you can `left show` all of your Either a b's (where a is Show), and compose them all together
00:32:53 <jle`> into one giant Either String a block
00:33:20 <randomclown> How about (Right "a" :: Either String String) >>= \x -> (Right 'a' :: Either Char Char)
00:33:37 <jle`> > left show (Left True) >> left show (Left 73854) >> left show (Right "ok") >> left show (Left [])
00:33:38 <lambdabot>  Left "True"
00:33:42 <Axman6> well clearly you can't use >>= to do that
00:33:49 <ab9rf> dmwit: type families are one of those things that i've been aware exist but haven't had a use for in any of my own code and so haven't learned how to do use them
00:33:59 <jle`> randomclown: your final function needs to be Either String String
00:34:02 <Axman6> since the m's don't match; Either String /= Either Char
00:34:11 <jle`> so you can `left show` the result
00:34:22 <randomclown> jle`: the lambda has type String -> Either Char Char
00:34:24 <jle`> (blah :: Either String String) >>= \x -> left show (blah blah)
00:34:29 <jle`> randomclown: yes
00:34:32 <jle`> so `left show` it
00:34:37 <dmwit> > (Right "a" :: Either String String) >>= \x -> left show (Right 'a' :: Either Char Char)
00:34:39 <lambdabot>  Right 'a'
00:34:55 <randomclown> :t left
00:34:56 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
00:34:57 <randomclown> :t show
00:34:58 <lambdabot> Show a => a -> String
00:35:12 <randomclown> Oh right I see
00:35:13 <jle`> left applies a function to the left of an Either if it is left, and leaves it alone if it is Right
00:35:17 <jle`> :t left show
00:35:18 <lambdabot> Show a => Either a d -> Either String d
00:35:44 <darthdeus_> hey guys, what's the preferred way of combining blaze with html files? blaze-from-html seems that it's only supposed to be used externally
00:35:54 <gamegoblin> if I put something stupid like a giant chain of `id`, will GHC optmize them out?
00:35:58 <randomclown> jle`: Do I have to left show? Why can't haskell figure it out
00:36:25 <dmwit> randomclown: Yes, you have to tell the compiler what computation you want it to perform.
00:36:28 <jle`> have you looked at a language like javascript?
00:36:29 <jle`> or php?
00:36:33 <jle`> er, perl
00:36:36 <jle`> those do implicit conversions for you
00:36:43 <dmwit> gamegoblin: Sometimes. Look at -ddump-simpl if in doubt.
00:36:47 <randomclown> Oh I meant explicitly specify a show at the end or something
00:36:50 <jle`> so if you use an Int where it wanted a String, it'd implicitly convert/cast the Int to a String
00:37:01 <jle`> but in haskell, we usually avoid implicit conversions and casts
00:37:06 <dmwit> randomclown: We are telling you how to explicitly specify a show.
00:37:17 <ab9rf> i hate imnplicit conversions
00:37:19 <ab9rf> they are evil
00:37:27 <ab9rf> they seem nice at first, but they are, in fact, evil
00:37:32 <jle`> randomclown: can you show an example of what you are talking about?
00:37:41 <jle`> "specify a show at the end"?
00:37:46 <jle`> what sort of interface are you thinking of?
00:38:04 <randomclown> (Right "a" :: Either (Show a) String) >>= ...  etc etc
00:38:38 <jle`> hm
00:38:40 <merijn> randomclown: That's not a valid type, Show is a typeclass constraint, not a type
00:38:47 <jle`> so you want a (>>=) of something like...
00:38:56 <randomclown> merijn: well year but that's the idea I'm trying to express
00:38:59 <randomclown> yeah*
00:39:09 <merijn> "Show a => Either a String"
00:39:29 <jle`> (>>=) :: (Show e, Show o) => Either e a -> (a -> Either o b) -> Either ??? b
00:39:39 <jle`> it sounds like you want a (>>=) of that type
00:39:39 <dmwit> :t let funnyBind m f = left show m >>= left show . f in funnyBind
00:39:40 <lambdabot> (Show b2, Show b1) => Either b1 a -> (a -> Either b2 b) -> Either String b
00:39:50 <dmwit> Except you probably really don't want that, but rather
00:39:52 <merijn> dmwit: Also known as "indexed monad"
00:39:58 <dmwit> :t let funnyBind m f = left show m >>= f in funnyBind
00:39:59 <lambdabot> Show b1 => Either b1 a -> (a -> Either String b) -> Either String b
00:40:33 <dmwit> merijn: Hm. I'm not so sure.
00:41:05 <jle`> randomclown: working in Either String, and using natural transformations like `left show` to put everyhting in Either String before >>='ing it, is probably the more disciplined answer
00:41:23 <jle`> besides, the only thing you can do with a polymorphic `Show a` is to convert it into a string anyway
00:41:32 <dmwit> :t showsPrec
00:41:33 <lambdabot> Show a => Int -> a -> ShowS
00:41:36 <jle`> ;)
00:42:40 <jle`> besides, how do yuo even expect something like what you wrote before to end up as?
00:42:51 <jle`> Left True >> Left 123 = ???
00:42:57 <jle`> Left "True", perhaps?
00:43:15 <randomclown> I missed a lambda obviously
00:43:25 <jle`> i mean, what would you expect that to show up as
00:43:26 <randomclown> Left True >> \x -> Left 122
00:43:39 <jle`> you probably mean Left True >>= \x -> Left 123 ?
00:43:43 <jle`> which is Left True >> Left 123
00:43:47 <randomclown> >>= yes
00:44:03 <jle`> `x >>= \_ -> y` is x >> y
00:44:23 <jle`> so you would want Left True >> Left 123 to evaluate to Left "True", i'm guessing?
00:44:37 <jle`> doesn't that seem a little magical? ;)
00:44:58 <randomclown> Nah I was hoping to contrain it using Show
00:45:02 <randomclown> which both implement
00:45:04 <jle`> using an explicit type signature?
00:45:13 <randomclown> which I have yes
00:45:19 <jle`> that sounds even more verbose than `left show`, heh
00:45:34 <phaazon> AHAH
00:45:36 <phaazon> $ cabal build --with-gcc=/c/MinGW/bin/cc.exe
00:45:37 <phaazon> Building cuda-0.6.6.0...
00:45:37 <phaazon> Preprocessing library cuda-0.6.6.0...
00:45:37 <phaazon> setup.exe: permission denied
00:45:40 <phaazon> what a joke.
00:45:53 <randomclown> :t Left True >> Left 123 :: (Show a) => Either a b
00:45:54 <phaazon> how could I gain permission on setup.exe? (windows)
00:45:54 <lambdabot>     Could not deduce (a1 ~ Bool)
00:45:54 <lambdabot>     from the context (Show a)
00:45:54 <lambdabot>       bound by the inferred type of it :: Show a => Either a b
00:46:04 <randomclown> which didn't work
00:46:05 <ab9rf> phaazon: disable your antivirus
00:46:10 * dmwit notes that it has now been 24 minutes since he said how to fix things. presumably that is enough time to Just Fix It already instead of complaining
00:46:10 <phaazon> ab9rf: :D
00:46:19 <jle`> except...the answer you expect isn't Show a => Either a b
00:46:22 <jle`> it's just Either String b
00:46:30 <jle`> if you wanted the answer to be Left "True"
00:46:38 <randomclown> :t Left True >> Left 123 :: Either String b
00:46:38 <lambdabot>     Couldn't match type ‘Bool’ with ‘[Char]’
00:46:38 <lambdabot>     Expected type: String
00:46:38 <lambdabot>       Actual type: Bool
00:46:56 <jle`> and in that case it's pretty magical
00:47:02 <jle`> how would it know you want to Show to get a String?
00:47:12 <ab9rf> phaazon: cabal creates temporary executables and then runs them; many AV programs for windows do not approve of such behavior and blocks them from running, or interferes with them in some way or another
00:47:27 <randomclown> jle`: I just typed Show a => Either a b
00:47:35 <jle`> yes, but that's not the result you acctually wanted
00:47:40 <jle`> you wanted an Either Left b
00:47:43 <jle`> er, Either String b
00:48:07 <jle`> there isn't really any meaningful way to state what you are saying in a way that can be unambiguously understood
00:48:10 <dmwit> randomclown: "Show a => Either a b" isn't what you want, and "Either String b" isn't what you have.
00:48:13 <dmwit> What now?
00:48:29 <randomclown> dmwit: I wanted Show a => Either a b
00:48:35 <randomclown> which didn't type check
00:48:40 <dmwit> randomclown: "you have to tell the compiler what computation you want it to perform" -- me, probably
00:48:43 <randomclown> String is fine too I suppose
00:48:43 <jle`> if you wanted Left True >> Left 123 to be Left "True"
00:48:47 <speak> Haha dmwit
00:48:47 <jle`> then that isn't what you have
00:48:51 <jle`> you have Either STring b
00:48:51 <ab9rf> i kinda get the feeling he wants (Show a1, Show a2) => Either a1 b -> Either a2 b -> Either ... b
00:48:58 <randomclown> dmwit: I explictly gave it :: Show a => Either a b
00:49:10 <jle`> randomclown: yes, but you said earlier that you wanted it to evaluate to `Left "True"`
00:49:12 <dmwit> randomclown: That's what you say you want. But it isn't.
00:49:15 <ab9rf> the problem is coming up with sonethiug for the ...
00:49:19 <jle`> so what you wanted is actually Either String b
00:49:21 <dmwit> randomclown: You're lying about what you want, is what I'm saying.
00:49:38 <jle`> that's why `Show a => EIther a b` doesn't match the type of the result that you said you wanted
00:49:53 <jle`> you said you wanted the result to be `Left "True"`, which is `Either String b`
00:50:07 <ab9rf> randomclown: could you explain at a high level what you are trying to do?
00:50:24 <randomclown> jle`: You can go up and look at the logs, and quote me where I said I expected it to evaluate to Left True
00:50:55 <jle`> ah i see, i misintereted a "nah"
00:51:10 <Hijiri> randomclown: Show a => Either a b means it has to work for *Every* a that is showable
00:51:14 <dmwit> jle`: He's got you there. He never even defined the question properly!
00:51:22 <dmwit> HAHA, IDIOT, YOU ANSWERED WRONG
00:51:25 <jle`> :|
00:51:30 <Hijiri> So that means it has to be a valid value for Either () b, Either Float b, etc
00:51:43 <randomclown> ab9rf: Use the either monad when the two eithers I'm working with both have implement the Show type class
00:51:45 <Hijiri> I don't see how you would get that out of Left True >> Left 123
00:51:50 <speak> ab9rf SO often that is the question that keeps getting not asked in help channels, it drives me nuts!
00:52:04 <ab9rf> randomclown: use it how?
00:52:04 <jle`> i think randomclown understands the solution we gave, but they are trying to understand why the interface they wanted isn't statable in a meaningful way with the way things are constructed in haskell
00:52:21 <randomclown> Hijiri: how do you write it extential types?
00:52:22 <jle`> the solution we gave works, but now is just to explain why such an interface as is originally intended can't work out in haskell
00:52:45 <Hijiri> if you are going to go existentiable Show types you might as well just go Either String b
00:52:51 <speak> So often I see in help channels 5 hours of "how to do what the newbie wants", and then someone asks "why??" and turns out the newbie REALLY wanted something completely different which is resolved in 5 minutes
00:52:54 <Hijiri> existential*
00:52:55 * speak stops meta-helping
00:53:12 <jle`> speak: well, randomclown wanted it, and got it
00:53:16 <randomclown> Hijiri: as I said, I'm composing library function which I can't forcefully return string
00:53:18 <jle`> but now this is a new question :)
00:53:24 <ab9rf> it smells to me like you have a value of type (Show a1) => Either a1 b, and another value of type (SHow a2) => Either a2 b, and you want to combine them somehow into a value of type (Show a3) => Either a3 b ?
00:53:32 <randomclown> ab9rf: exactly
00:53:39 <speak> jle` ah I see. What I said still stands!
00:53:43 <speak> I'd still ask "why?"
00:53:47 <jle`> the best and most disciplined solution is still `left show`
00:53:48 <speak> :D
00:53:51 <ab9rf> randomclown: how are you going to intuit a3 from a1 and a2?
00:53:54 <jle`> with what your library functions give you
00:54:11 <dmwit> jle`: (disagree, actually)
00:54:20 <randomclown> ab9rf: intuit?
00:54:25 <dmwit> jle`: (best answer is a new type which can take on values from all library's errors)
00:54:30 <ab9rf> randomclown: you are better off reducing the values of type (Show a) => Either a b to a nonparameterized type Either String b
00:54:46 <jle`> dmwit: heh. that is probably better in the big picture, yes >_>
00:54:56 <dmwit> randomclown: Suppose I pick two types a1 and a2 that I promise implement Show. How do you pick a3?
00:55:04 <briareus> hi all, pretty new to haskell & had a question about lists. when i prepend a new element to a list, what does it's index become? the index doesn't seem to update...
00:55:12 <jle`> briareus: what do you mean by index?
00:55:25 <ab9rf> briareus: the index of an element in a list is an epiphenomenal property
00:55:25 <randomclown> dmwit: well there exists a type right?
00:55:30 <ab9rf> randomclown: no, there doesn't
00:55:34 <briareus> the first element in a list is index 0, then 1,2,3 etc
00:55:48 <dmwit> randomclown: If there exists a type, you should be able to tell me one.
00:55:57 <dmwit> randomclown: That's what "exists" means, right?
00:56:11 <jle`> randomclown: if you can't tell, then the compiler can't tell :)
00:56:27 <jle`> briareus: if you pretend a new element to the list, to the new list, that element is at index 0
00:56:33 <jle`> > 1:[2,3,4]
00:56:35 <lambdabot>  [1,2,3,4]
00:56:42 <phaazon> ab9rf: thanks for the explaination
00:56:45 <jle`> see, the 1 is at index 0 :) (if we are using 0 indexing)
00:56:49 <ab9rf> you want a join that combines Either a1 b and Either a2 b into an Either a3 b, with the only constraitn on a1, a2, and a3 is that they're all instances of Show
00:56:54 <dmwit> briareus: You never prepend a new element to a list. You can only construct a new list which shares a tail with an old one.
00:57:03 <ab9rf> join can't do that.  it doesn't have enough information.
00:57:05 <briareus> ahh, now it makes sense
00:57:12 <briareus> i'm still referencing the old list
00:57:19 <briareus> gracias :)
00:57:20 <ab9rf> briareus: the old list is unchanged
00:57:24 <jle`> > let x = [1,2,3]; y = 0:x, in (x, y)
00:57:25 <lambdabot>  <hint>:1:25: parse error on input ‘,’
00:57:29 <jle`> > let x = [1,2,3]; y = 0:x in (x, y)
00:57:30 <lambdabot>  ([1,2,3],[0,1,2,3])
00:57:32 <ab9rf> briareus: creating a new list doesn't change the old one
00:57:38 <jle`> see, x is still [1,2,3], and y is now [0,1,2,3] :)
00:57:47 <briareus> it is clear, thank you
00:57:58 <dmwit> randomclown: Still waiting on your explanation of how to choose a3, by the way.
00:58:00 <phaazon> http://lpaste.net/119851
00:58:09 <phaazon> any idea what might causes that?
00:58:19 <phaazon> the first line of the .i file is this:
00:58:19 <dmwit> clang?
00:58:23 <randomclown> dmwit: I don't know why a concrete type matters when you know whatever you have implemented the Show interface
00:58:31 <randomclown> implementes*
00:58:45 <speak> Does anyone know what randomclown is trying to do at a non-code level? :o
00:58:51 <Hijiri> randomclown: how do you know it has an instance of show?
00:58:52 <dmwit> randomclown: What is it that I have that implements the Show interface?
00:58:56 <phaazon> http://lpaste.net/119851
00:59:08 <ab9rf> speak: i think he wants a combinator for Either that combines the lefts
00:59:11 <phaazon> #line 1 "…"
00:59:15 <phaazon> :(
00:59:22 <speak> ab9rf that's still "code level"
00:59:24 <dmwit> phaazon: clang?
00:59:30 <randomclown> You know how in jave you can pass around say an IComparable
00:59:35 <phaazon> nope
00:59:37 <phaazon> gcc
00:59:39 <ab9rf> speak: but he refuses to require the Eithers to have the same type
00:59:56 <jle`> speak: so they have a bunch of Either a t's, Either b t's, Either c t's, etc, that they get from different library functions.  and they want to use it all in a single bind/composition
01:00:02 <jle`> i don't think randomclown is refusing to do it...
01:00:07 <Hijiri> randomclown: Show a3 => Either a3 b isn't existentially quantified
01:00:09 <jle`> i think they're just on a quest to find the deeper reason why it isn't possible
01:00:10 <Hijiri> it's universal
01:00:23 <speak> No this is all code level... What is trying to DO? Code usually accomplishes something. What is his end goal?
01:00:23 <Hijiri> if you want it to be existential it would be a completely different type
01:00:27 <ab9rf> jle`: that could be.  i understand why it's not but i'm not sure how to explain that
01:00:28 <phaazon> dmwit: I thought c2hs fails on that
01:00:33 <phaazon> the #line pragma
01:00:37 <phaazon> but it’s very unlikely
01:00:56 <ab9rf> jle`: i've tried and dmwit tried and i don't think he got it, or he refuses to believe it, not sure which
01:01:02 <Hijiri> If it was existential, you could choose String ~ a3, since you can always get String from something Showable
01:01:02 <dmwit> I don't know, sorry. I've seen errors like that from clang, and know how to fix them; but not from gcc.
01:01:09 <phaazon> hm, or it’s nvcc
01:01:10 <Hijiri> but somehow I don't think that's what you want
01:01:10 * speak shakes fist at mathematician-like haskell coders!! ;P
01:01:12 <jle`> it isn't something easy to explain
01:01:15 <jle`> :/
01:01:21 <phaazon> dmwit: how would you fix that?
01:01:22 <jle`> i think it just has to come from intuition after using it for a while
01:01:26 <phaazon> remove the #line? :D
01:01:38 <dmwit> phaazon: switch to hscpp or whatever it's called
01:01:45 <ab9rf> jle`: unlearning the concept of type used in languages like java helps
01:01:47 <randomclown> ab9rf: Why does any of these matter to you?
01:01:47 <dmwit> phaazon: instead of clang's cpp
01:01:53 <randomclown> Is a man not allowed to ask questions
01:01:55 <phaazon> yeah, ok
01:01:56 <dmwit> phaazon: But it may not even be cpp that's tripping up here.
01:02:03 <phaazon> it’s because of nvcc then.
01:02:04 <phaazon> dammit.
01:02:11 <ab9rf> randomclown: we are trying to understand and if possible answer your questions
01:02:41 <randomclown> Well I'm just asking things and now I'm being accused of "refusing to understand x"
01:02:44 <jle`> i think...i'm pretty sure randomclown understands the actual solution that we gave.  the question they're asking now is sorta well defined
01:02:48 <dmwit> randomclown: For what it's worth, I *don't* know how you can pass something two different kinds of IComparable in Java and expect to get something useful out.
01:02:55 <jle`> so now it's just a matter of finding something out for fun
01:02:57 <jle`> :)
01:03:00 <Hijiri> randomclown: the answer is you can't make a function (Show a, Show a2, Show a3) => Either a b -> Either a2 b -> Either a3 b
01:03:04 <speak> jle` & ab9rf nobody still answered what randomclown is trying accomplish
01:03:08 <ab9rf> well, you *can*
01:03:32 <jle`> okay, i'm going to bow out then.  i feel like some tension is rising and i don't want to accidentally make it worse :)
01:03:34 <speak> On a non code level. Maybe he doesn't know what he actually wants on a non code level. Why not try to suss THAT out first, and then tell him how to accomplish it?
01:03:37 <ab9rf> speak: i have some idea what he's doing, i've done something similar
01:03:45 <Hijiri> I can't see how you would make it total
01:03:50 <dmwit> speak: Stop accusing us of sucking at teaching and teach.
01:04:04 <ab9rf> Hijiri: agreed.
01:04:15 <randomclown> Hijiri: ok done
01:04:40 <speak> dmwit I'm a complete newbie at haskell, and I'm not accusing anyone of anything, I'm trying to offer constructive solutions to what seems to be a stalemate in trying to help this person
01:04:59 <speak> But if you want to take it as accusations, I'll just drop it
01:05:16 <jle`> the library gives (x -> Either a y), (x -> Either b y), (x -> Either c y)'s, etc, and they want to be able to sequence those in a meaningful way.  for example, f >=> g >=> h.  turn those three and run them all one after the other, with short-circuiting capabilities
01:05:47 <phaazon> hm, yeah
01:05:52 <phaazon> nvcc does support #line actually
01:05:54 <jle`> as Monad works in haskell, and as the type system works in haskell, the only way for something like that to work nicely with Monad is if you convert all of the Left types into a common type, and *then* use >=>, >>=, do blocks, etc.
01:05:59 <dmwit> speak: We have asked repeatedly what he's trying to do, and why. He's been very reticent about answering those questions.
01:06:18 <dmwit> speak: So we're doing the best we can in the environment we've got.
01:06:32 <randomclown> dmwit: Well to be honest I'm trying to join decodeASN1 and fromANS1 together
01:06:34 <speak> dmwit I'd just stop helping him until he answers those questions
01:06:43 * dmwit did
01:06:48 <speak> dmwit but good I'm glad people were asking those
01:06:54 <ab9rf> and since he wants the various type sto all be instances of Show, the obvious conversion is to use show to convert them to String
01:06:57 <phaazon> I guess the error is from…
01:06:58 <phaazon> c2hs
01:07:07 <randomclown> but I didn't want you to waste time looking at the functions
01:07:08 <phaazon> I’m gonna write a little snippet of code to test that
01:07:08 <ab9rf> so just stuff (left show) in front of each value
01:07:15 <dmwit> randomclown: I don't believe that's all you're trying to do, because we said how to do that an hour ago. =)
01:07:17 <ab9rf> randomclown: it's our time to waste!
01:07:23 <jle`> :D
01:07:40 <ab9rf> randomclown: do uyou think i'd be here if i had something else to be doing?
01:07:46 <ab9rf> i'm just up cuz i can't sleep
01:07:58 <jle`> yeah nobody in #haskell has anything better to do
01:08:02 <jle`> than look up functions
01:08:05 <jle`> and read people's code they post
01:08:13 <jle`> this isn't on the topic?
01:08:15 <jle`> :)
01:08:35 <ab9rf> dmwit: it's been an hour?  really?
01:09:01 <Hijiri> I'm here to not do homework
01:09:05 <dmwit> Sorry, only 45 minutes.
01:09:40 <ab9rf> dmwit: thought so. i'm watching tv on netflix and i was fairly sure he's noty been here for more than a single hour episode :)
01:09:48 <speak> Hehe
01:11:12 <jle`> can we have a group hug before we continue
01:11:32 <speak> Sure
01:11:47 <jle`> o/
01:12:32 <dmwit> http://bit.ly/16d2Fh4
01:13:03 <speak> Haha
01:13:42 <ab9rf> yay grumpycat
01:13:48 <ab9rf> my (anti)hero
01:14:19 <speak> Time for lunch and why not MORE COFFEE
01:14:26 <ab9rf> mmmm coffee
01:14:29 <ab9rf> it's 3am here
01:14:40 <dmwit> ab9rf: nethack time
01:14:51 <speak> Nethack AND coffee at 3am
01:15:03 <speak> Best way to pass out... in the next 10 hours or so, maybe
01:15:05 <dmwit> nethack\nnwef  i
01:15:18 <ab9rf> i haven't played nethack in years
01:15:44 <jle`> does anyone even play games other than `rogue`
01:15:51 <dmwit> rogue is the standard game
01:15:54 <speak> Neither have I actually, not too much anyway. Too many roguelikes out there to try. Dungeon Crawl Stone Soup is pretty fun
01:16:16 <speak> Oops lunch ->
01:16:19 <ab9rf> i should try out the new dwarf fortress sometime
01:16:28 <Hijiri> does elona count? I played that for a bit
01:16:48 <Hijiri> most recently of roguelikes
01:24:36 <ab9rf> i don't understand type families yet.  i've read this article three times now and they still don't make sense.
01:24:53 <dmwit> Type families are functions.
01:24:55 <dmwit> But on types.
01:24:59 <shachaf> It could be the article.
01:25:14 <ab9rf> shachaf: more likely it's me, i'm dense.
01:25:21 <kosmikus> shachaf: :)
01:25:22 <merijn> ab9rf: Which article?
01:25:33 <dmwit> They're also open, which means you can add clauses in different modules/different places within a module (unlike term-level functions, which must have all defining clauses together in one spot).
01:25:36 <ab9rf> the one on the haskell wiki
01:25:54 <merijn> ab9rf: I recommend reading the paper "Fun with Type Functions"
01:26:08 <ab9rf> dmwit: on some level i understand that they're functions on types, but obvously not on a level that is, as of yet, useful to me
01:26:13 <ab9rf> merijn: link?
01:26:24 <shachaf> it's on the type level hth
01:26:35 <dmwit> thachaf
01:26:45 <shachaf> I think type families must be simpler than that article makes them look.
01:26:54 <ab9rf> shachaf: i'd throw something at you if i could figure out how.
01:27:12 <merijn> ab9rf: http://research.microsoft.com/en-us/um/people/simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf but it's not responding for me right now >.>
01:27:34 <sgronblo> I'm also interested in understanding type families. So far my understanding is that they allow you to specify a specific subtype that some function in a typeclass would return.
01:27:36 <ab9rf> merijn: loaded for me, thanks
01:27:57 <sgronblo> From what I remember from the example in the Yesod book (if it was there)
01:28:00 <shachaf> Haskell doesn't do really do anything that would be called subtyping.
01:28:57 <merijn> It would be more accurate to say that type functions let you have functions whose return type (or input type, or any other type) depends in some arbitrary way on one of it's other types
01:29:12 <merijn> Which is almost entirely unlike subtyping in all possible ways :)
01:29:24 <shachaf> ab9rf: I guess it would be good to figure out where you get lost.
01:29:40 <ab9rf> shachaf: and i will attempt to do that the next time i read the article :)
01:30:08 <shachaf> Oh, I was going to write something out here, but reading the article is even better.
01:30:17 <shachaf> Or the paper merijn linked to.
01:30:21 <shachaf> Whatever works.
01:30:25 <sgronblo> shachaf: yeah subtype was a poor choice of word
01:30:37 <ab9rf> shachaf: if i had a more focused question, i'd ask it.  i'm not really looking for focused help because i don't really know what question to ask yet.
01:30:54 <ab9rf> shachaf: being offered an alternate paper is likely the best possible help, in fact
01:31:06 <shachaf> ab9rf: Does the idea of a type function makes sense?
01:31:20 <ab9rf> shachaf: since that will presumably explain the same concept in a different way, and that might get over whatever cognitive block i'm having
01:31:26 <shachaf> ab9rf: E.g. you can define a function f, say f :: Bool -> Int, and then write f False = 5; f True = 10. That's a regular function.
01:31:40 <ab9rf> shachaf: yes, that i understand.
01:32:00 <shachaf> ab9rf: You can also define a type function (which is called a "type family"): type family F a; type instance F Int = Double; type instnace F Char = Bool
01:32:11 <phaazon> https://github.com/tmcdonell/cuda/issues/25#issuecomment-72619077
01:32:15 <sgronblo> ab9rf: have you seen this example? http://www.yesodweb.com/book/haskell#I_sect12_d1e753
01:32:19 <phaazon> arf!
01:32:20 <phaazon> is everything broken now? :(
01:32:25 <shachaf> Now writing "F Int" is the same as writing "Double", just like writing "f False" is the same as writing "5".
01:32:52 <sgronblo> I'm sure theres more to type families than whats in that small section but at least it explains one way that type families can be used quite well.
01:32:56 <shachaf> So I can write x :: F Int; x = 0.5
01:33:47 <shachaf> Does that make sense?
01:34:01 <Zemyla> Okay, question. I have a bunch of packet types, which are identified with a byte at the start.
01:35:05 <ab9rf> shachaf: i'm going tyo go read this paper now, and thus will probablyh not be attendig the channel for a bit.  what you've said does make sense so far.
01:35:21 <shachaf> OK. That's most of what there is to type families.
01:35:32 * dmwit pre-emptively mumbles "attoparsec, binary, cereal"
01:35:50 <merijn> dmwit: cereal is mostly obsolete now :p
01:35:52 <ab9rf> dmwit: you need to add 22 more libraries to that mumble :)
01:35:58 <ab9rf> sorry 23
01:36:02 <merijn> dmwit: binary now has incremental parsing using strict BS too
01:36:24 <Zemyla> I was thinking about a typeclass (KnownNat n, Data p) => Packet p n | p -> n, n -> p.
01:36:52 <jle`> is cereal really obsolete now?
01:37:06 <Zemyla> However, is there a way to take a run-time byte value and return a type, or a foralled type wrapper?
01:37:07 <jle`> i had just switched my library from binary to ceareal
01:37:09 <jle`> dangit
01:37:18 <jle`> >.<
01:37:24 <merijn> jle`: It's not REALLY obsolete
01:37:37 <merijn> jle`: But the main use case for cereal was "incremental strict BS parsing"
01:37:51 <jle`> and binary has that too now?
01:37:59 <merijn> Now that binary can do both that and lazy parsing the only difference is "cereal can serialise to strict BS"
01:38:09 <jle`> oh okay i can live with this
01:38:10 <shachaf> Zemyla: Sure, you can do that.
01:38:16 <dmwit> Zemyla: What are you hoping to get out of putting this information at the type level?
01:38:29 <merijn> But I've been informed that generating a lazy ByteString using binary and then using toStrict is probably as fast or faster as directly generating strict
01:38:29 <dmwit> Zemyla: I'm suspicious that you just want a boring old sum type.
01:38:41 <shachaf> dmwit: But reflection is such a fun package.
01:38:43 <merijn> jle`: Therefore, there is not much incentive to use cereal in new code
01:38:52 <jle`> i'm going to release a library
01:38:55 <jle`> i should probably switch then
01:39:03 <jle`> *i'm using it in a library i'm releasing
01:40:26 <Zemyla> dmwit: Well, since it's a subclass of Data, I can get the information out at my leisure.
01:40:39 <dmwit> Zemyla: That's not what I asked. =)
01:40:51 <shachaf> There's a deeper point that I think dmwit is getting at.
01:41:38 <dmwit> Why do this at the type level when doing it at the term level is Good Enough (tm)?
01:41:54 <Zemyla> Though what I actually want is a way, without writing a big-ass table myself, of getting a Parser s u m Packet.
01:42:08 <dmwit> Putting things at the type level isn't going to prevent writing a big-ass table.
01:42:38 <Zemyla> Well, okay, but I want to write only one big-ass table instead of several.
01:42:58 <dmwit> It will, however, make the big-ass table more verbose, harder to write, and harder to read. =)
01:44:24 * hackagebot proteaaudio 0.6.2 - A wrapper for the proteaaudio library.  http://hackage.haskell.org/package/proteaaudio-0.6.2 (CsabaHruska)
01:46:42 <dmwit> I don't see why it should be easier to avoid duplication at the type level than at the term level.
01:47:14 <Zemyla> Because I did a rudimentary Perl implementation of this protocol a while back, and I managed to write an import library that let me simply say, fpr instance, "package PointerPacket; use Packet (id => 11, xcoord => "Integer", ycoord => "Integer", user => "String") and it made all the constructors, accessors, read and write functions automatically.
01:48:17 <dmwit> data Packet = Packet11 { xcoord :: Integer, ycoord :: Integer, user :: String } -- ?
01:49:45 <dmwit> Well.
01:49:52 <dmwit> Okay, I understand there's going to be some programming here.
01:50:21 <dmwit> But it shouldn't be too bad, I shouldn't think.
01:50:58 <dmwit> data Types = Integer | String; data PacketType = PacketType { id :: Integer, fields :: [(String, Types)] } is not so bad.
01:51:06 <dmwit> s/bad/different from what you did in Perl/
01:51:48 <dmwit> Then you can write functions of type PacketType -> Parser Packet, etc.
01:53:00 <Zemyla> dmwit: Well, I like the thought of just using Data to deconstruct and construct objects.
01:53:07 <dmwit> Or Data, yep.
01:53:59 <dmwit> (That's the data Packet = Packet11 { xcoord :: Integer, ... } way, I guess.)
01:57:38 <joelteon> oh no
01:57:57 <joelteon> this is very specific, but has anyone been able to successfully pass the test suite for enclosed-exceptions using GHC HEAD?
01:58:25 <joelteon> i fear some internal change in base has ruined my evening
01:59:07 <joelteon> oh, wait, that's not even on HEAD. false alarm everyone
02:06:41 <phaazon> hm, does c2hs work in 64bit?
02:06:43 <phaazon> I have a weird error
02:20:36 <gamegoblin> If I do something like "true = True"
02:20:45 <gamegoblin> will GHC inline True everywhere I use "true"?
02:20:56 <gamegoblin> On -O2?
02:21:46 <phaazon> gamegoblin: that’s very likely, yes
02:22:02 <phaazon> you can put a {-# INLINE #-} pragma though
02:22:37 <phaazon> don’t forget to add zero = 0, one = 1, two = 2, three = 3… fortySix = 46
02:22:39 <phaazon> :D
02:23:38 <gamegoblin> Well that’s a given ;)
02:31:56 <YaRly> When using where, is each expression re-evaluated every time it's used? I.e. z = a+b is re-evaluated every time z is used somewhere
02:34:26 * hackagebot hint 0.4.2.2 - Runtime Haskell interpreter (GHC API wrapper)  http://hackage.haskell.org/package/hint-0.4.2.2 (DanielGorin)
02:36:01 <merijn> YaRly: No
02:36:12 <merijn> YaRly: In GHC it's guaranteed only evaluated once
02:36:30 <merijn> YaRly: (and any sane haskell implementation should do the same :p)
02:36:49 <adam_hardkey_shi> Hum, I got a weird result for a filter map composition
02:37:21 <adam_hardkey_shi> I write : filter (\(x,y) -> y > 0.0) $ map (\(x,y) -> (x,y - diff)) pos_boulettes
02:37:45 <adam_hardkey_shi> where diff is a double, pos_boulettes is [(Double,Double)]
02:38:37 <adam_hardkey_shi> And I got the error : EssaiSDL2.hs:54:17:
02:38:37 <adam_hardkey_shi>     Couldn't match expected type `[(Double, Double)]'
02:38:37 <adam_hardkey_shi>                 with actual type `Set (t0, Double)'
02:38:37 <adam_hardkey_shi>     In the expression:
02:38:37 <adam_hardkey_shi>       (filter (\ (x, y) -> y > 0.0)
02:38:38 <adam_hardkey_shi>        $ map (\ (x, y) -> (x, y - diff)) pos_boulettes)
02:38:38 <adam_hardkey_shi>     In the command: returnA -< (filter (\ (x, y) -> y > 0.0)
02:38:39 <adam_hardkey_shi>                                 $ map (\ (x, y) -> (x, y - diff)) pos_boulettes)
02:38:39 <adam_hardkey_shi>     In a stmt of a 'do' block in an arrow command:
02:38:40 <adam_hardkey_shi>       returnA -< (filter (\ (x, y) -> y > 0.0)
02:38:40 <adam_hardkey_shi>                   $ map (\ (x, y) -> (x, y - diff)) pos_boulettes)
02:38:41 <adam_hardkey_shi> EssaiSDL2.hs:54:46:
02:38:41 <adam_hardkey_shi>     Couldn't match expected type `Set (t0, Double)'
02:38:42 <adam_hardkey_shi>                 with actual type `[(Double, Double)]'
02:39:23 <Yuras> merijn: to be precise, it is not 100% guaranteed. it may be inlined; or evaluated independently by multiple threads; etc
02:40:12 <mpickering> adam_hardkey_shi: Can you paste your whole program at lpaste pls?
02:40:31 <merijn> Yuras: Ah, true
02:40:46 <mpickering> @lpaste
02:40:46 <lambdabot> Haskell pastebin: http://lpaste.net/
02:40:56 <merijn> Yuras: But unlikely to be relevant for a beginner
02:41:18 <Yuras> merijn: true :)
02:42:14 <adam_hardkey_shi> mpickering: http://lpaste.net/119855
02:42:21 <adam_hardkey_shi> I pasted the problematic function
02:42:52 <adam_hardkey_shi> Ok, I found my problem.
02:42:54 <YaRly> merijn: Ok, thank you
02:43:01 <adam_hardkey_shi> I import filter from Data.Set.
02:43:05 * adam_hardkey_shi facepalm
02:49:53 <merijn> YaRly: Anyway, where/let are a common way to explicitly introduce sharing of expensive computation. And one of the nice things of purity is that it guarantees us that reevaluating it will always have the exact same result, which is why GHC won't bother. Yuras' remarks basically mean that GHC sometimes inlines/duplicates computation if it figures that redoing will be faster/more efficient than storing/shari
02:49:59 <merijn> ng the result
02:56:50 <mbuf> how do I catch a FormatError from https://hackage.haskell.org/package/mysql-simple-0.2.2.4/docs/Database-MySQL-Simple.html#g:12 ?
03:01:37 <Yuras> mbuf: https://hackage.haskell.org/package/base-4.5.0.0/docs/Control-Exception-Base.html#t:Exception
03:01:53 <Yuras> mbuf: ^ it contains examples
03:02:18 <Yuras> mbuf: feel free to ask specific questions
03:03:35 <phischu> How do I tell cabal-install to ignore _all_ installed packages? Even those that are installed globally and those that come with GHC?
03:07:08 <phaazon> http://lpaste.net/119857
03:07:10 <phaazon> any idea?
03:08:03 <gfixler> https://github.com/haskell/c2hs/issues/60
03:08:05 <Kneiva> phischu: make a sandbox?
03:09:28 <phaazon> gfixler: huh…
03:09:35 <phaazon> I don’t get how I can fix that then
03:10:30 <gfixler> is there a command line flag (as per ian-ross' comment)?
03:11:39 <phaazon> there’s a lot of flags
03:11:53 <gfixler> I'm not sure if this link I sent is exactly related now
03:12:21 <phaazon> I think it’s --no-gnu
03:12:23 <phaazon> I’ll try that…
03:14:01 <phaazon> it’s not available in my version
03:14:13 <phaazon> dammit I’m frustrated of all that shit around cuda
03:14:27 <gfixler> :(
03:14:27 * hackagebot monad-levels 0.1.0.1 - Specific levels of monad transformers  http://hackage.haskell.org/package/monad-levels-0.1.0.1 (IvanMiljenovic)
03:15:58 <phischu> Kneiva: thank you, but even within a sandbox cabal-install prefers installed packages from the global package database (at /usr/local/lib/ghc-7.8.3/package.conf.d) instead of reinstalling them
03:16:34 <Kneiva> phischu: Ok, then I don't know.
03:18:22 <gregnwosu> just discovered type holes. its insane, programming haskell is like something from a scifi movie
03:19:17 <gfixler> gregnwosu: Hole-driven Haskell?
03:19:30 <phaazon> gfixler: what platform are you on?
03:19:37 <gfixler> ubuntu
03:19:52 <gregnwosu> gfixler: yes its very cool
03:19:57 <phaazon> hm
03:20:03 <phaazon> is there any guy here on Windows?
03:20:06 <gregnwosu> hole driven haskell using type holes
03:20:15 <gregnwosu> feature in ghc 7.8+
03:20:34 <gregnwosu> with emacs-frontend
03:20:50 <mpickering> phischu: Maybe we can help more if you paste the result of "cabal install <pkg> -v3"
03:20:57 <gregnwosu> gfixler: it nearly writes the program for you
03:21:08 <gfixler> gregnwosu: yep, it's cool stuff
03:21:14 <phaazon> hey, am _really_ I the single guy on Windows who can’t compile the cuda packae?!
03:21:19 <phaazon> package*
03:21:28 <gfixler> phaazon: it's 3AM here in the US
03:22:24 <gregnwosu> phaazon: dont use windows
03:22:33 <gregnwosu> sorry, im trolling
03:22:34 <phaazon> I’m used to be on archlinux
03:22:42 <phaazon> but for my laptop I have no choice
03:22:48 <gfixler> I kicked Windows out the window 9 years ago
03:22:48 <phaazon> the linux support for it is really poor
03:22:49 <gfixler> feels good
03:23:17 <gfixler> I considered maybe getting a laptop for like, 10 years
03:23:24 <gregnwosu> phaazon: have you tried cygwin?
03:23:25 <gfixler> finally got one - Linux, from System76
03:23:43 <gregnwosu> phaazon: can you use a vm?
03:24:09 <phaazon> gregnwosu: no, but it won’t solve my issue, since Haskell Platform uses a stupid embedded mingw…
03:26:21 <gregnwosu> phaazon: is the laptop your target platform?
03:26:28 <phaazon> yes
03:26:42 <phaazon> there’s no support for my wirelless card on linux
03:26:46 <phaazon> I talked with its developper
03:26:57 <phaazon> the driver will be out maybe in a few months
03:27:00 <phaazon> or years…
03:27:19 <phaazon> that’s why I keep using windows
03:27:32 <phaazon> now, I don’t get why I’m getting such a nasty issue
03:27:36 <gregnwosu> phaazon: not good enough you could have a plugin usb wireless
03:27:36 <phaazon> isn’t c2hs a mature tool?
03:27:46 <phaazon> I bought one
03:27:49 <phaazon> it’s poor.
03:29:04 <gregnwosu> phaazon: documentation for FFI in Haskell is scarce IMO, I got most of my knowledge from Chapter 17 of Real World Haskell , and a very bright fellow called ezyang
03:30:20 <gregnwosu> but yes its fairly mature, though people often dont really pay too much attention to the windows platform in FOSS
03:30:58 <phaazon> FOSS?
03:32:04 <ibid> phaazon: free and open source software?
03:32:24 <phaazon> ok
03:34:28 <ibid> (personally, i like FLOSS better)
03:35:13 <phischu> mpickering: thank you, 'cabal-install ansi-terminal' into a sandbox installs ansi-terminal but what I want is that it also installs bytestring, unix, time, and others. I expect --package-db=clear to hide globally installed packages but it doesn't. Output: http://lpaste.net/119860
03:41:26 <NightRa> Is there any way of capturing key presses (arrows and enter) in the console without any additional c-based libraries on windows?
03:41:49 <phaazon> ok, in the waiting of a true port of cuda
03:41:55 <phaazon> I’m using OpenCL
03:42:05 <NightRa> Or at least with some precompiled binaries
03:42:39 <zipper> What does "subsite" mean in context of yesod?
03:43:25 <tigerfinch> gregnwosu: can you point me to any resources on getting started with hole driven dev? I remember reading about it somewhere but my google-fu is failing me :/
03:43:31 <zipper> In the first paragraph after the first codeblock http://www.yesodweb.com/book/authentication-and-authorization
03:44:31 <gregnwosu> tigerfinch: yes theres an excellent video one second
03:44:53 <gregnwosu> and theres also your how to set up your emacs
03:45:20 <gregnwosu> tigerfinch: https://www.youtube.com/watch?v=52VsgyexS8Q
03:45:35 <gregnwosu> note that shows the technique of inductive reasoning
03:45:55 <gregnwosu> but predates the new features of type holes
03:46:11 <tigerfinch> gregnwosu: awesome thanks :) I
03:46:42 <gregnwosu> tigerfinch: new features and how to set up emacs and some examples of using type holes are here : http://www.mew.org/~kazu/proj/ghc-mod/en/emacs.html
03:47:35 <gregnwosu> let me know what you think, I would love to hear what others thoughts are - in case im not on IRC greg.nwosu@gmail.com
03:48:45 <Zemyla> Hmm. I'm trying to figure out zip :: List a -> List b -> List (a, b), where type List a = forall r. (a -> r -> r) -> r -> r.
03:49:18 <tigerfinch> Cool, thanks! I will do - bookmarking this all for some lunch time exploration
03:49:44 <gregnwosu> :)
03:50:59 <tigerfinch> Yet another feature to mention in my slow campaign to get haskell considered at work ;) Hopefully as a rebutall to the "but, but, types are HARD argument"
03:51:20 <zq> thinking is hard
03:51:29 <gregnwosu> tigerfinch: It makes haskell like playing tetris lol
03:51:32 <tigerfinch> hah
03:52:24 <gregnwosu> Zemyla: I cant parse that :    ``` type List a = forall r. (a -> r -> r) -> r -> ```
03:52:45 <gregnwosu> can anyone explain what it means to me?
03:54:29 * hackagebot web-routing 0.4.2 - simple routing library  http://hackage.haskell.org/package/web-routing-0.4.2 (HirotomoMoriwaki)
03:54:42 <Zemyla> :t \c n -> foldr c n []
03:54:43 <lambdabot> (a -> b -> b) -> b -> b
03:55:14 <Zemyla> That;s basically what it is. It's a fold with a list already put in.
03:56:42 <gregnwosu> Zemyla: ok
03:58:21 <gregnwosu> Zemyla: you need a fold that zips two lists?
03:58:40 <gregnwosu> maybe just zip
03:59:54 <mniip> () is an interesting monoid
04:00:18 <gregnwosu> Zemyla: sorry , forget i said that
04:01:40 <mniip> wait what
04:01:46 <mniip> why is () not a Functor
04:02:06 <Zemyla> mniip: Because it's not of kind * -> *.
04:02:13 <mniip> ah right
04:02:14 <mniip> yeah
04:02:27 <Zemyla> You're looking for Proxy.
04:02:35 <mniip> Functors are *->* whereas Monoids are *
04:03:26 <Zemyla> Proxy is a Functor, an Applicative, a Monad, a dessert topping, and a floor wax.
04:05:01 <Zemyla> gregnwosu: Also, in a nutshell, what the forall means in the function is that the function can't manipulate the data except in certain specific ways.
04:06:19 <Zemyla> Question: How many functions of type a -> a are there?
04:09:20 <mpickering> 1
04:10:02 <Zemyla> Yes, but I was asking gregnwosu.
04:10:08 <mpickering> oh sorry ha
04:10:22 <ouchthats> Aren't there three?
04:11:14 <mniip> is there some typeclass for things with 2 operators, their respective identities, and 2 associativity rules?
04:11:19 <mniip> (no distributivity rules)
04:11:24 <Zemyla> ouchthats: Not counting undefined.
04:11:34 <Zemyla> @hoogle Semiring
04:11:35 <lambdabot> package semiring
04:11:56 <ouchthats> Ah; got it.
04:14:48 <mniip> hmm
04:15:36 <Zemyla> But yeah. If you have a value of type (forall r. (a -> r -> r) -> r -> r) as an argument, then you know that all it's going to do is take whatever you pass as the second argument, amd apply it withthe function that's the first argument to some cache of a arguments it has inside.
04:16:41 <merijn> gregnwosu: The location of 'forall' decides on WHO gets to pick the value
04:17:22 <merijn> gregnwosu: For example, while haskell has "id :: a -> a" in the underlying theory this is just "id :: forall a . a -> a" which basically says "for any input type 'a', this is a function from 'a' to 'a'"
04:18:46 <merijn> gregnwosu: Now, if you use RankNTypes (a haskell extension) you can place forall's in different place. Let's start with a non-RankN example: "foo :: forall a b . (a -> b) -> b" (I'm not sure this is a sensible function, but let's skip that for now)
04:19:20 <merijn> gregnwosu: This says given a function that takes some 'a' that you (the caller) pick, I will return a 'b'
04:19:29 <mniip> hmm, I'm no abstract matematician, but if for 2 operators & and |, and 2 elements 0 and 1, the axioms are (a|b)|c=a|(b|c); (a&b)&c=a&(b&c); a|1=1|a=1; a&0=0&a=0; a|0=a; a&1=a;
04:19:32 <mniip> what am I dealking with
04:19:44 <merijn> For example, I could give that "Int -> Bool" as argument and that'd return a Bool
04:20:56 <merijn> gregnwosu: Now suppose I write "foo :: forall b . (forall a . a -> b) -> b", now this does something completely different. This says "given a functio that takes ANY type 'a' (the internals of 'foo' will pick which 'a') that returns a 'b', 'foo' will return a 'b'"
04:21:22 <merijn> gregnwosu: So the difference is that in the former case the person who *calls* 'foo' picks the type of 'a', but in the latter the internals of 'foo' pick the type of 'a'
04:21:46 <mniip> example of such an object is a set
04:22:59 <mniip> hmm
04:23:09 <mniip> maybe I should define my own typeclass
04:23:34 <merijn> mniip: Are you sure you need a typeclass?
04:23:37 <mniip> that builds up on the Monoid for one of the operators, but declares the 4 other axioms as its own
04:23:39 <merijn> @google scrap your typeclasses
04:23:41 <lambdabot> http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
04:23:41 <lambdabot> Title: Haskell for all: Scrap your type classes
04:25:48 <mniip> fun
04:31:38 <Zemyla> The thing is, I really don't want to pass a Num typeclass to every numeric function I use.
04:34:00 <Zemyla> merijn: You know, I figured out how exactly how to get rid of passing undefined :: a to functions.
04:34:50 <Zemyla> Instead of having sizeOf :: a -> Int (for instance), you have sizeOf :: Tagged a Int.
04:44:19 <gregnwosu> sorry Zemyla: i was away , there are 1 id
04:46:13 <Zemyla> And here is what I was looking for. http://okmij.org/ftp/Haskell/zip-folds.lhs
04:50:46 <pyr> hi #haskell!
04:50:56 <pyr> I seem to be stuck in a bit of a cabal pickle
04:51:18 <pyr> the latest type-level (0.2.4)
04:51:38 <pyr> does not seem to compile anymore, it reports a few errors when compiling:
04:51:41 <gregnwosu> thanks merijn Zemyla i think i follow , will look into it more closely
04:52:07 <pyr> Illegal instance declaration for <several symbols>
04:52:57 <pyr> which all boil down to: Reason: lhs types <x> <y> <z> do not jointly determine rhs types ‘(x, x)’, ‘(x, x)’ in the instance declaration for
04:54:08 <pyr> i suspect this is due to my recent cabal update
04:54:30 <pyr> and subsequent cabal install cabal-install
04:56:49 <saep> pyr: Can you build it in a sandbox? (I can)
04:56:59 <merijn> gregnwosu: Simplest example I can come up with: https://gist.github.com/merijn/77e3fa9757658e59b01d
04:57:09 <pyr> saep: i'm building in a sandbox
04:57:14 <mpickering> pyr: What version of ghc are you using?
04:57:28 <pyr> mpickering: 7.8.4
04:57:29 <merijn> gregnwosu: The problem with the former example is that it says it wants "a function that works with *a* Num type", whereas what it needs is "a function that works with *all* Num types"
04:57:43 <pyr> saep: but I updated cabal + cabal-install after the sandbox creation
04:57:52 <mpickering> pyr: I don't know why you want this package but it was last updated in 2010
04:57:53 <pyr> saep: i cleaned the sandbox and started over
04:58:02 <merijn> gregnwosu: So, for example "mangle (+1)" will work for the 2nd example
04:58:07 <pyr> mpickering: i depend on it for some custom protobuf stuff
04:58:14 <mpickering> and since then there are much better ways to implement type functions
04:59:54 <pyr> mpickering: specifically: https://github.com/pyr/himpy/blob/master/System/Himpy/Serializers/Riemann.hs#L12-L13
05:01:39 <gregnwosu> merijn: so RankNTypes allow the definition of a to vary between instances
05:03:21 <merijn> gregnwosu: Not so much, RankNTypes allow you to specify "more polymorphic" types
05:03:53 <merijn> gregnwosu: The second type demands a function that works "for all 'a' that are Num instances" rather than "A single 'a' that is a Num instance"
05:04:06 <mpickering> pyr: http://hydra.nixos.org/build/18782367/log
05:04:07 <merijn> gregnwosu: For example, trying to pass "Int -> Int" to the second is a type error
05:04:10 <mpickering> Looks like it has bitrotted
05:04:27 <merijn> gregnwosu: Whereas "Int -> Int" would be ok for the first example (hence why it can't work)
05:04:55 <pyr> mpickering: same here, but it seems as though Data.ProtocolBuffers can live without it now, I'll adapt accordingly
05:05:01 <merijn> gregnwosu: Since the function must work for *all* Num instances and Int and Double are both Num instances it must, by definition, work in both the Foo and Bar constructor case
05:05:06 <mpickering> sure, what exactly are you using it for?
05:05:09 <gregnwosu> ah
05:05:21 <merijn> gregnwosu: Which is why GHC happily accepts it
05:05:32 <gregnwosu> but Num -> Num would work in the second no?
05:05:44 <mpickering> you can probably just use type-level literals from a quick glance
05:05:48 <merijn> gregnwosu: That's not a valid type, since "Num" is a typeclass constraint
05:05:54 <merijn> Not a type :)
05:06:22 <ab9rf> it took me a while to understand that a typeclass is not a type
05:06:36 <gregnwosu> merijn: true.
05:07:08 <merijn> gregnwosu: Like I said, the differnce between the two 'mangle' types is who picks 'a', i.e. the first case you (the caller) picks what 'a' is. In the second case 'mangle' is asking you (the caller) for a function that "works for any 'a' I pick, and I'm not telling you which"
05:07:21 <merijn> Now, a function that works for "all a" is usually not very interesting
05:07:37 <merijn> But one that works "for all 'a' that are Num instances" is a little more interesting :)
05:08:05 <merijn> ab9rf: And then it turns out they are, but they just have different kinds ;)
05:08:09 <merijn> :k Num
05:08:10 <lambdabot> * -> Constraint
05:08:35 <merijn> :k Num Int
05:08:35 <lambdabot> Constraint
05:08:57 <ab9rf> merijn: what can you do with a type of kind Constraint?
05:09:10 <merijn> Put it in front of => on type signatures ;)
05:09:28 <HeladoDeBrownie> also anything you can do with any type, like pass it as a type argument
05:09:33 <merijn> ab9rf: The only types that have values are types of kind * (Minor lie here)
05:10:00 <merijn> ab9rf: Or, formulated differently, all values have types whose kind is *
05:10:07 <ab9rf> that i knew
05:10:23 <merijn> ab9rf: But, you can create custom constraints using type families
05:10:36 <ab9rf> merijn: i'm still trying to make sense of type families
05:10:44 <merijn> ab9rf: Like https://gist.github.com/merijn/6130082 :)
05:10:44 <ab9rf> don't make me think right now, i'm too tired
05:11:07 <merijn> The identity function for all types, except Int and () :p
05:12:12 <chpatrick> merijn: that's cool
05:12:33 <chpatrick> ("Error!" ~ "Tried to apply a restricted type!")
05:12:37 <chpatrick> that's a bit evil though :)
05:12:57 <merijn> chpatrick: I'm open to better suggestions
05:13:21 <merijn> There is no "false" constraint, this one at least has semi useful text in the error :)
05:14:02 <chpatrick> hmm
05:14:09 <chpatrick> is this really creating a constraint though?
05:14:21 <merijn> The alternative would be to make it return True/False and put a "(True ~ Restrict a [Int, ()])" constraint on it, which is hardly nicer
05:14:24 <merijn> chpatrick: Yes
05:14:26 <chpatrick> I mean it's either () or compile error
05:14:40 <chpatrick> the error isn't an error in the unsatisfied constraint sense is it?
05:14:53 <merijn> chpatrick: It's a compile error because line 6 returns an invalid constraint
05:15:19 <HeladoDeBrownie> "invalid" in this case meaning "that will always fail to be met"
05:15:20 <chpatrick> yes but I mean ideally the error would be that a doesn't satisfy the given constraint
05:15:22 <merijn> chpatrick: It's putting a type unification constraint on two incompatible types (those two Symbol)
05:15:24 <chpatrick> not that the constraint is bogus
05:15:45 <merijn> chpatrick: Haskell has no way of expressing that
05:15:54 <chpatrick> I mean ideally it would be like
05:15:59 <merijn> chpatrick: At least, not in any way that results in nice errors
05:16:02 <HeladoDeBrownie> i suppose it would be nicer if there were a constraint included, or one that could be defined, that will always fail, and isn't some application of (~)
05:16:18 <merijn> HeladoDeBrownie: I proposed this on the mailing list
05:16:25 <merijn> SPJ and other didn't think it was worthwhile
05:16:34 <HeladoDeBrownie> oh well
05:16:35 <chpatrick> it would be nice if you could make like a constraint newtype
05:16:48 <chpatrick> newtype Restrict = (ElemOf a ts ~ False)
05:16:52 <chpatrick> or something with less horrible syntax
05:17:14 <chpatrick> *newtype Restrict a
05:17:24 <HeladoDeBrownie> then you have to check that ElemOf a ts could never actually unify with False
05:17:35 <chpatrick> that's not a problem with closed type families right?
05:17:53 <HeladoDeBrownie> (and by "you have to check", i mean you as the programmer)
05:18:15 <chpatrick> isn't that the idea?
05:18:18 <merijn> chpatrick: How is that newtype different from what my code is doing?
05:19:03 <chpatrick> well I suppose because it's always a valid constraint
05:19:11 <chpatrick> well "valid"
05:19:17 <chpatrick> instead of either () or impossible depending on a
05:19:22 <merijn> chpatrick: In what way is it more valid than mine?
05:19:31 <merijn> () is a valid constraint
05:19:32 <rasen> Hi all!
05:19:36 <jonkri> In haskell-mode (installed through MELPA just now) in 24.4.1, I don't seem to be in prog-mode. Does anyone have any idea why this is? (I'm thinking that the changes in <https://github.com/haskell/haskell-mode/issues/16> should be available on my installation.)
05:19:40 <merijn> It's just a constraint that is vacuously true
05:19:44 <HeladoDeBrownie> rasen, hi!
05:19:54 <jonkri> (24.4.1 is the Emacs version, obviously. :))
05:20:00 <chpatrick> I mean, in your version the constraint itself depends on a right?
05:20:23 <chpatrick> here it's the same constraint that may or may not match depending on a
05:20:40 <merijn> chpatrick: What do you mean by "depends on 'a'"?
05:20:51 <rasen> From Haskell language report I read: "Haskell 2010 is the first revision to be created in this way, and new revisions are expected once per year"
05:20:56 <merijn> Isn't that kinda the point
05:20:59 <chpatrick> I mean you look at a and produce either () or contradiction
05:21:28 <chpatrick> with a typeclass constraint for example the constraint is fixed, and it's a predicate on types
05:21:30 <merijn> rasen: The Haskell Prime process is dormant because there's not enough competing compilers for a standards process to be very interesting
05:21:53 <merijn> chpatrick: How is this not a predicate on types?
05:22:03 <chpatrick> it is of course
05:22:18 <chpatrick> but it just seems less natural than to have a fixed constraint that is checked
05:22:24 <merijn> rasen: Note that Haskell's standard process is different than C/C++, i.e. it's a descriptive rather than prescriptive process
05:22:26 <chpatrick> rather than a type family-produced constraint
05:22:56 <rasen> merijn: that was different in 2010?
05:22:58 <merijn> chpatrick: I just don't understand what you mean
05:23:14 <chpatrick> ok so
05:23:22 <chpatrick> you have a constraint like Show a for example
05:23:23 <merijn> rasen: No, but then that was the first updated since Haskell98 (unless you account for the FFI addendum)
05:23:35 <chpatrick> Show is the same constraint whatever a is
05:23:45 <chpatrick> the compiler then decides if a matches it or not
05:23:53 <rasen> So, I should expect new revision somewhere near 2020?
05:23:59 <merijn> chpatrick: You mean you don't like the parameterisation?
05:24:16 <merijn> rasen: Yes, unless you plan to join and reorganise the Prime committee yourself :p
05:24:21 <chpatrick> with Restrict you have a constraint which is either truth or contradiction depending on a, and then that's checked by the compiler
05:24:29 <chpatrick> it's mathematically the same I suppose
05:24:32 <merijn> chpatrick: But then you have to write a new constraint type for every set of restrictions
05:24:49 <rasen> merijn: I believe I won't be able to do that before 2020 either :)
05:24:52 <pyr> mpickering: I can do without type-level, thanks!
05:25:14 <chpatrick> do you know if the constraint newtype was ever proposed?
05:25:16 <merijn> rasen: Alternatively, contribute to UHC to make it more production ready ;)
05:25:23 <merijn> No idea
05:26:29 <merijn> rasen: Or bug Standard Chartered's lawyers into open sourcing Mu :p
05:29:22 <rasen> merijn: why open-sourcing it matters?
05:30:53 <merijn> rasen: Because right now no one outside SC can use Mu and thus there's not much interest in basing a standard on it and GHC :p
05:31:15 <rasen> I see
05:31:27 <rasen> Should go
05:31:34 <ab9rf> go og go
05:31:38 <merijn> Some of the Utrecht guys told me they're about to finish a massive change that will make it easier to implement a lot of GHC's extensions, at which point it may become more interesting to talk about standardising
05:31:50 <merijn> But they don't have money to pay someone to implement those extensions
05:32:11 <chpatrick> merijn: http://lpaste.net/119866
05:32:45 <chpatrick> *Main> :k Restrict
05:32:45 <chpatrick> Restrict :: [*] -> * -> Constraint
05:33:59 <merijn> Restrict is actually more general, but you don't have PolyKinds enabled
05:34:30 <recursion-ninja> Hey guys, I was trying to learn more about the Ix typeclass but the source sorce is a mess! Why is this so unreadable? Is there a cleaned up version I can look at? http://hackage.haskell.org/package/base-4.7.0.2/docs/src/GHC-Arr.html#line-75
05:34:36 <merijn> I don't really see how that version is any more elegant, though?
05:35:04 <merijn> recursion-ninja: Easy answer: The colours source generator doesn't like literate haskell, afaik
05:35:29 <merijn> recursion-ninja: Good news: GHC is eliminating all literate haskell source files. Short term solution: Open the actual source from the GHC repo
05:35:36 <recursion-ninja> merijn: That's unfortunate, if I were to grab the original lhs file it might be mor intelligable?
05:36:04 <recursion-ninja> merijn: Okay, thanks!
05:36:38 <merijn> recursion-ninja: Yes
05:36:55 <merijn> There's a mirror on github you can browse
05:38:23 <HasSkull> Hello
05:38:41 <HasSkull> Anyone fancy giving me a little help with a noob "getting started" haskell question?
05:38:50 <HasSkull> I'm having trouble, however, running "cabal install cabal-install" w/ cabal version 1.18.0.5
05:38:58 <HasSkull> It whinges about: <command line>: cannot satisfy -package-id HTTP-4000.2.10-da371776b88c2889959897a2dc40abe7
05:39:19 <ab9rf> ugh
05:40:17 <recursion-ninja> HasSkull: Did you `cabal update` first?
05:40:21 <HasSkull> yup.
05:40:31 <merijn> Did you run "--force-reinstall" at some point?
05:40:31 <c_wraith> HasSkull: first off, that's an ancient version of cabal-install.  What version of GHC are you using?
05:40:36 <HasSkull> Apologies if I hijacked the topic... did I mention I'm new to IRC as well?
05:40:56 <recursion-ninja> HasSkull: I had similar problems about a month ago when I redid by setup...
05:41:05 <merijn> c_wraith: That shouldn't produce the version hash though, should it?
05:41:10 <recursion-ninja> HasSkull: I forget what the solution was
05:41:10 <HasSkull> I didn't force-reinstall. I'm using GHC 7.8.3
05:41:20 <c_wraith> HasSkull: it's common to have many topics going on at once in IRC.  No worries there.
05:41:47 <HasSkull> ok - thanks. Am trying --force-reinstall now
05:42:03 <merijn> No, don't >.>
05:42:03 <c_wraith> HasSkull: ok, so it's not an ancient version of ghc that doesn't even use package ids.  These days, the recommended way to install cabal-install is via a binary distribution:  https://www.haskell.org/cabal/download.html
05:42:08 <recursion-ninja> HasSkull: It sounds cliche but "have you tried turning it off & on again"
05:42:24 <recursion-ninja> HasSkull: I remember a reboot helped me at somepoint in my setup
05:42:34 <ab9rf> probably not going to help here
05:42:39 <merijn> HasSkull: --force-reinstall is prone to breaking things, hence why i asked >.>
05:42:47 <HasSkull> I haven't actually.. I'll try the reboot and then the binary install
05:42:50 <merijn> Because people insist on not heeding it's warning
05:42:50 <ab9rf> cabal update with be first
05:42:50 <clrnd> HasSkull, windows? linux? and how did you install it?
05:43:13 <clrnd> we should have #cabal-helpdesk
05:43:28 <HasSkull> I'm on Mac OSX 10.10.1 (Yosemite)
05:43:41 <HasSkull> installed from the "haskell platform" dmg
05:43:57 <geekosaur> haskell platform dmg for mac is broken :(
05:44:01 <clrnd> ^
05:44:03 <clrnd> ^_^
05:44:05 <merijn> geekosaur: Wait, since when?
05:44:10 <merijn> I call bollocks
05:44:40 <geekosaur> we reported it several days ago, among other things all the embedded RPATH records point into to the builder's source tree
05:44:53 <merijn> oh, is this the new build?
05:45:02 <ab9rf> heh
05:45:03 <merijn> Mine is about a month or two old
05:45:04 <geekosaur> I have not seen an update announced since then
05:45:35 <HasSkull> Should I completely uninstall and use either an older platform or ... ?
05:45:52 <merijn> HasSkull: You might as well install binary GHC build + binary cabal build instead
05:46:00 <recursion-ninja> HasSkull: I was installing on Debian Linux so my cabal issues were probably different then what you were experiancing
05:46:14 <merijn> HasSkull: The main advantage of Platform is that it installs a bunch of common libraries, but cabal can install those easily too
05:47:05 <HasSkull> ok. Do people tend to use cabal directly, or some "cabal sandboxing" mechanism? I've read about "cabal hell", but am only getting started, so wouldn't have multiple projects on the go
05:48:06 <clrnd> HasSkull, well I prefer sandboxes, but some people use stackage ...
05:48:17 <geekosaur> the currently recommended install mechanism for os x is apparently https://github.com/ghcformacosx/
05:48:22 <merijn> HasSkull: People mix up lots of things, the cabal hell of old is pretty much gone and people are now using the term for basically any problem where cabal doesn't do what they want, even if what they want is impossible
05:48:28 <clrnd> sandboxes are like python's virtualenvs
05:48:36 <hodapp> what about hsenv?
05:48:53 <clrnd> never tried it, seems deprecated
05:48:56 <merijn> hodapp: Mostly pointless, imo
05:49:02 <HasSkull> @geekosaur - thanks!
05:49:03 <lambdabot> Unknown command, try @list
05:49:06 <geekosaur> hsenv sandboxes multiple ghc installations
05:49:13 <hodapp> clrnd: I'll treat it as such.
05:49:15 <hodapp> I wasn't too familiar.
05:49:22 <merijn> Which is odd, since multiple GHC installations don't need sandboxing
05:49:27 * hodapp shrugs
05:49:30 <geekosaur> this is not especially useful in ghc's ecosystem if you keep your global packages to a minimum
05:49:32 <merijn> GHC already uses per version package databases
05:49:54 <merijn> geekosaur: Even then it's not useful, since global packages aren't shared between compiler versions :)
05:50:02 <hodapp> I need to learn nix too
05:50:14 <merijn> I just have multiple GHC versions in different paths and select which to use my changing which comes first in my path
05:50:17 <geekosaur> well, for that it's more about being able to select ghc-s easily
05:50:28 <geekosaur> but yes, it's not as useful as it sounds initially
05:55:21 <HasSkull> Right - thanks for the help. I'm off to install/restart. Cheers!
06:02:45 <dredozubov> does RecordWildCards considered evil?
06:03:18 <merijn> dredozubov: It's mildly confusing imo
06:04:09 <dredozubov> i'm not sure what to make of it
06:04:37 <dredozubov> sugar all the things!
06:04:47 <ab9rf> that the {..} magic syntax?
06:04:53 <dredozubov> yep
06:05:49 <ab9rf> imo falls in the "mostly harmless" category
06:05:51 <mpickering> there are some objections because it implicitly shadows existing definitions
06:05:58 <mpickering> but it is very useful when you have big records.
06:06:38 <ab9rf> i agree it can get confusing especially if used in a nested context
06:07:43 <ddellacosta> is null O(1) ?
06:07:54 <clrnd> ddellacosta, on lists? yeah
06:08:00 <ddellacosta> clrnd: yeah, thanks
06:08:03 <ab9rf> it's not defined on anytthing but lists
06:08:15 <ab9rf> yeah, even if the list is infinite
06:08:19 <clrnd> Text has a null
06:08:24 <clrnd> and bytestring
06:08:31 <ab9rf> hm
06:08:43 <dredozubov> ab9rf: it's defined on maps, sets, bytestrings, text etc
06:08:49 <ddellacosta> "but it was such an innocent question"
06:08:56 <dredozubov> null is everywhere
06:09:01 <ab9rf> dredozubov: interesting, i thought it was just [a] -> Bool
06:09:07 <dredozubov> (sounds like some sort of javascript)
06:09:09 <mauke> ab9rf: there's more than one null
06:09:09 <clrnd> null pointers for example, but they are an exception
06:09:11 <merijn> :t S.null
06:09:12 <lambdabot> S.Set a -> Bool
06:09:18 <merijn> :t M.null
06:09:19 <lambdabot> M.Map k a -> Bool
06:09:19 <geekosaur> might be more correct there to say it doesn't live in a typeclass so you need to invoke the appropriate null for the type if one exists
06:09:21 <merijn> etc.
06:09:22 <mniip> [17:05:31] <ab9rf> it's not defined on anytthing but lists
06:09:26 <ab9rf> ah, right, shadowed
06:09:29 <mniip> some modules define their own null
06:09:36 <mniip> yeah as demonstrated above
06:09:37 <dredozubov> ab9rf: it's Prelude.null
06:10:08 <ab9rf> i am not very awake right now
06:31:22 <ddellacosta> is there a way to use let on the right side of a guard?  like, | x = let foo = 1, foo + 2 (<- obviously that doesn't work)
06:31:43 <mauke> what for?
06:32:21 <ddellacosta> mauke: I want to use an intermediary value in the expression on the right side...?
06:32:58 <mauke> right side of what?
06:33:22 <ddellacosta> | boolean_value = the_right_side
06:33:57 <jtanguy> maybe a where clause instead of a let ?
06:34:02 <mauke> but that's not part of the guard at all
06:34:13 <mauke> why are you asking about guards, then?
06:35:32 <ddellacosta> mauke: So, whatever you'd call it--I guess I made a mistake using the terminology "guard," please forgive my sin and try to answer my question...or ignore me.
06:35:54 <mauke> this is not about terminology
06:35:57 <ddellacosta> jtanguy: from what I understand, where is going to apply to the entire guard statement
06:36:07 <mauke> this is about figuring out what the heck you're talking about
06:36:21 <mauke> I still don't know what you're trying to do
06:36:50 <mauke> your first fragment is a syntax error, and your description makes no sense, and you don't provide any examples
06:37:55 <mauke> ... I guess I could answer the question as asked, then: "yes"
06:38:21 <awestroke> > let x = let foo = 1 in foo + 2; x
06:38:23 <lambdabot>  <hint>:1:34:
06:38:23 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
06:38:34 <awestroke> > let x = let foo = 1 in foo + 2 in x
06:38:35 <lambdabot>  3
06:38:46 <mauke> > let {foo x | even x = let y = 2 in x + y} in foo 40
06:38:48 <lambdabot>  42
06:38:58 <mauke> and ^this is how
06:39:16 <ddellacosta> awestroke: thanks, that's what I was looking for!
06:39:43 <mauke> oh, wow
06:40:20 <mauke> ok, I didn't realize you didn't know how to use "let". like, at all
06:40:28 <Skip> Hello
06:40:37 <awestroke> that's unnessecary, mauke
06:40:41 <awestroke> Skip: hello!
06:40:53 <mauke> awestroke: but that actually seems to be the problem!
06:41:42 <ddellacosta> mauke: amazing how you figured out what I meant immediately after awestroke commented, despite having no clue whatsoever before that...
06:41:57 <ddellacosta> mauke: and even if it is the case that I have no idea how let works, is that really a great way to talk to a beginner?
06:42:05 <awestroke> ^
06:43:50 <mauke> ddellacosta: I figured it out after you said "that's what I was looking for" and reading awestroke's examples, not immediately after awestroke commented
06:44:39 <mauke> ddellacosta: before that, it's not like I didn't have a clue; it's more like your description was ambiguous enough that I couldn't determine a plausible interpretation
06:45:19 <mauke> ddellacosta: I didn't say that you have no idea how let works (otherwise you probably wouldn't ask about "let" specifically), just that you didn't know how to use it
06:45:40 <ddellacosta> mauke: hey, it's cool, I concede, you win--let's just call it off now, okay?  Cheers. :-)
06:45:49 <mauke> no, this sucks
06:45:50 <ddellacosta> mauke: thanks for all your help
06:45:52 <mauke> I don't want to "win"
06:45:54 <mauke> :-(
06:46:29 <mauke> I want to understand stuff and I want to see other people understand stuff
06:47:21 <clrnd> mauke wins
06:47:22 <mitu> moral superiority win!
06:47:35 <awestroke> "ok, I didn't realize you didn't know how to use "let". like, at all" <- not friendly. in fact, it reads very aggressively, like ddellacosta did something wrong in not using a vocabulary you'd use.
06:48:15 <mauke> yeah, that's my fault. I didn't mean it that way
06:48:24 <awestroke> asking is very hard, and even harder when you have an incomplete vocabulary
06:49:22 <mauke> I still don't think this is a vocabulary issue
06:50:53 <mauke> "is there a way to use let in X" threw me off because it sounds like the speaker knows what 'let' is and how it's used normally
06:51:24 <mauke> they just need assistance with X
06:52:06 <Skip> I'm having a little problem, but don't know how to phrase it really
06:52:10 <Skip> :P
06:52:12 <Saizan> from the example it looks like let in do-notation
06:52:36 <awestroke> I'd phrase the question: "How do I use 'let' for CSE in a guard predicate?", but then I already know that shutit
06:52:41 <mauke> my first thought was pattern guards, because that's what lets you bind/reuse variables in guards
06:52:47 <jtanguy> Skip: go ahead
06:52:52 <Skip> Can someone take a look at this gist? https://gist.github.com/Balletie/f0c9f7f6cb90ac102a3a
06:53:21 <mauke> but as it turned out, the question had nothing to do with guards
06:53:57 <Skip> Basically, I have one type class, and two instances of that type class. Then I have a function which operates on that type class, and I want to let the user choose which instance to use
06:54:17 <awestroke> How would you know let worls the same inaide guard predicates though?
06:54:22 <Skip> But I can't figure out a good way to write it
06:54:30 <awestroke> damn autocorrect
06:55:18 <mauke> Skip: if choice then doSomethingWith instA else doSomethingWith instB
06:55:59 <Skip> mauke: thanks, but is there a way to write doSomethingWith inst just once?
06:56:24 <mauke> awestroke: but it wasn't about inside guard predicates, it was about the "right side" (i.e. function body)
06:56:33 <awestroke> or doSomethingWith (if choice then instA else instB)
06:56:42 <Saizan> awestroke: won't typecheck
06:57:06 <mauke> Skip: maybe with existentials
06:57:53 <Skip> I don't really understand existentials, but where would I have to apply it?
06:58:00 <Saizan> mauke: still, not all the right sides might have to work the same, often we ask people to include all the context because they won't know what's irrelevant to their problem, it happens that here it was indeed irrelevant
06:58:27 <Yuras> Skip: add "data I = I1 inst1 | I2 ist2" and make an "instance Foo I"
06:58:51 <Skip> but then I have to pattern match for each function of instance Foo
06:59:08 <Yuras> yes
06:59:32 <Skip> Something in me tells that's ugly :P
06:59:39 <Skip> but maybe it is the best solution
06:59:41 <jtanguy> why do you want the user to choose between two datatypes?
06:59:42 <Yuras> typeclasses are not like virtual functions :)
07:00:07 <mauke> data SomeFoo a = forall f. Foo f => SomeFoo (f a); xinst = if choice then SomeFoo inst1 else SomeFoo inst2
07:00:17 <mauke> case xinst of SomeFoo inst -> doStuffWith inst
07:00:20 <mauke> completely untested
07:00:27 <merijn> Existentials are better of being replaced with
07:00:31 <merijn> @google scrap your typeclasses
07:00:34 <lambdabot> http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
07:00:34 <lambdabot> Title: Haskell for all: Scrap your type classes
07:01:00 <mauke> Saizan: I think a real example of the problem would have helped
07:01:00 <Skip> jtanguy: well a concrete version of my problem is this: I have code for 1D cellular automata. And one way is to have it operate on an infinite list (Inst1) and the other on a loop (Inst2)
07:01:15 * hodapp sprays merijn with a squirt bottle
07:01:16 <mauke> Saizan: as in "here's the actual code I'm trying to get to work"
07:01:17 <hodapp> no holy wars!
07:01:47 <Saizan> mauke: yeah, but the example wasn't that bad, just fixing the parse error would have answered the question
07:02:02 <Skip> jtanguy: So basically the user gets prompted: "Do you want to use a Loop?", then either answer with yes or no.
07:02:20 <merijn> hodapp: This is not a holy way
07:02:25 <mauke> Saizan: that depends on how you fix it :-)
07:02:30 <merijn> hodapp: Existentials are a bad solution to this problem
07:02:31 <merijn> See also
07:02:36 <merijn> @where existential-antipattern
07:02:36 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
07:02:39 <mauke> Saizan: my first instinct was to correct "| x = ..." to "| x == ..."
07:03:13 <apo_> Skip: Prompt the user if they want to build a snowman
07:03:50 <Saizan> mauke: could have been a starting point anyway
07:04:35 <Skip> apo_: I have no snowman type :(
07:05:03 <apo_> Skip: You should fix that
07:05:11 <Saizan> merijn: oh, come on, for locally abstracting over two different types? next you're telling me we should church encode Either
07:05:21 <apo_> Skip: Here's a type-ographic snowman: ☃
07:05:40 <Skip> thank god for unicode support
07:06:08 <ab9rf> i swear i read that as "if they want to build a snoyman"
07:06:43 <Yuras> merijn: +1 for scrap your typeclasses. I even think that FromJSON and friends are pure evil
07:07:14 <Yuras> merijn: that is like having toXML() method in domain object in OOP
07:07:47 <Skip> So I should scrap my type class?
07:08:21 <Skip> Is data I = I1 inst1 | I2 ist2 the best solution here?
07:08:32 <jtanguy> Skip: I guess mauke's answer might be your best fit: if choice then doSomethingWith instA else doSomethingWith instB
07:08:56 <Skip> maybe yea
07:09:38 <Saizan> Skip: yeah, either that if or the existential, data I really changes behaviour here
07:10:00 <Kaedenn> So, I'm seeing a C++ abstraction interface that uses Maybe<> objects, and I'd like to learn about these modern-algebra constructs. Where can I read up on what these objects are?
07:10:53 <jtanguy> plus you don't need to know anything about your `a` in `doSomethingWith` (apart from implementing Foo)
07:12:04 <Kaedenn> Like, what's a Maybe type? And what does Just do with a Maybe?
07:12:33 <mauke> Kaedenn: data Maybe a = Nothing | Just a  -- ?
07:12:49 <Kaedenn> So it's a "variable" that may or may not be "set"?
07:12:56 <Kaedenn> (in non-functional terms)
07:13:22 <ab9rf> Kaedenn: more or less
07:13:27 <Kaedenn> or, rather, may or may not have a value
07:13:31 <bergey> I would say "possibly null"
07:13:32 <Kaedenn> Okay, that's simple enough.
07:13:39 <exio4> yes, it's a bit like an explicit null
07:13:44 <Kaedenn> bergey: I gathered that much
07:13:46 <Kaedenn> exio4: Right
07:13:48 <Kaedenn> Okay, thank you!
07:13:48 <ab9rf> it will have a value, but that value might be Nothing
07:13:50 <ab9rf> :)
07:13:54 <Kaedenn> ...true.
07:14:48 <Kaedenn> And it's an error to use Just on a Maybe that is Nothing
07:15:01 <ab9rf> Just is a constructor
07:15:03 <mauke> > Just Nothing  :: Maybe (Maybe Int)
07:15:04 <lambdabot>  Just Nothing
07:15:09 <Kaedenn> Oh
07:15:17 <ab9rf> > fromJust Nothing
07:15:18 <lambdabot>  *Exception: Maybe.fromJust: Nothing
07:15:19 <Kaedenn> Okay
07:15:29 <Kaedenn> fromJust?
07:15:31 <jtanguy> :t Just
07:15:32 <ab9rf> > fromJust (Just 20)
07:15:33 <lambdabot> a -> Maybe a
07:15:34 <lambdabot>  20
07:15:42 <jtanguy> :t fromJust
07:15:43 <lambdabot> Maybe a -> a
07:15:47 <Skip> Maybe is either "Just something" or "Nothing"
07:15:59 <Kaedenn> I'm starting to understand all of this
07:16:18 <ab9rf> Kaedenn: fromJust takes Just a and returns a.  it errors on Nothing.
07:17:03 <ab9rf> also, Maybe isn't a type.
07:17:07 <Kaedenn> Alright, in the C++ API I'm looking at, Just is a -> Maybe a
07:17:27 <ab9rf> yes, that's the type of Just in haskell, too
07:17:37 <Kaedenn> I thought all labels starting with capitals were types?
07:17:41 <Kaedenn> In Haskell
07:17:45 <ab9rf> Maybe is a type constructor
07:17:49 <Kaedenn> Ohhh
07:17:50 <mauke> Kaedenn: no, constants
07:17:50 <sinnsat> does GHC.Arr.listArray copy all the elements or does it just do pointer magic under the hood?
07:17:54 <ab9rf> :k Maybe
07:17:55 <lambdabot> * -> *
07:17:56 <mauke> Kaedenn: lowercase is variables
07:18:06 <mauke> Kaedenn: this applies both at the type and the value level
07:18:10 <Kaedenn> Aha
07:18:11 <Kaedenn> Okay
07:18:21 <Kaedenn> So you have functions whose result is a type
07:18:30 <mauke> (for appropriate definitions of "constant" and "variable")
07:18:31 <Kaedenn> Just being one
07:18:36 <Kaedenn> mauke: Right
07:18:39 <mauke> (Just is not a type)
07:18:42 <hsk3> One of my pet peeves with Haskell so far is those import statements at the top of a file, and which type below belongs to which import not being so obvious anymore. Is there a way out?
07:18:54 <mauke> hsk3: you could use explicit import lists
07:19:00 <ab9rf> hsk3: not really, although hoogle helps somewhat
07:19:13 <Kaedenn> mauke: Just being a function whose result is a type
07:19:28 <Kaedenn> I wonder if hoogle.com routes to google.com
07:19:34 <hsk3> ab9rf: ok
07:19:37 <merijn> mauke: Type families kinda screw tih the "uppercase == constructor" logic at the type level, sadly :\
07:19:38 <hsk3> a good IDE would help
07:19:42 <ab9rf> no, Just is a constructor whose return type is a value
07:19:46 <Kaedenn> Nope!
07:19:56 <Kaedenn> (in terms of hoogle.com)
07:19:57 <ab9rf> :k Just
07:19:58 <lambdabot> k -> Maybe k
07:20:01 <nshepperd> hsk3: there are two ways out. explicit import lists and 'import qualified'
07:20:12 <Kaedenn> So constructors and functions are fundamentally different in Haskell?
07:20:16 <hsk3> ok, thanks
07:20:26 <mauke> Kaedenn: huh?
07:20:35 <mauke> Kaedenn: Just is a function whose result is a value, which has a type
07:20:42 <ab9rf> Kaedenn: they're different but not that different.  the main difference is that constructors can be used in a pattern match, while functions cannot
07:20:42 <mauke> types aren't values
07:21:05 <ab9rf> also, constructors start with an uppercase letter
07:21:42 <sinnsat> ab9rf: afair there are some ghcisms that allow pattern matching with functions like 'foo (i + 1) = undefined'
07:21:53 <nshepperd> data constructions are basically a special kind of function that can also be used in a patten match
07:21:54 <Yuras> Kaedenn: consider abstract class Maybe and two subclasses, Just and Nothing. (They are templates, but lets ignore that). Maybe implements IMonad. Pattern matching is like dynamic_cast, but compiler warns you in case if abuse. The cool thing is how many things can be done without dynamic_cast, using only IMonad (and/or IApplicative, IFunctor etc)
07:21:58 <Kaedenn> Hokkay, so, we're getting to things about Haskell specifically, and I don't know Haskell.
07:22:08 <ab9rf> Kaedenn: won't hurt you to learn it :)
07:22:16 <nshepperd> constructors
07:22:36 <Kaedenn> Is Nothing really a subclass of Maybe?
07:22:40 <ab9rf> Yuras: they're implemented as classes?  really?
07:22:43 <Kaedenn> Or is that just for sake of argument?
07:22:50 <lpaste> SleepyPikachu pasted “Algebraic Data Types” at http://lpaste.net/119874
07:22:52 <nshepperd> sinnsat: I think the ghc developers decided that syntax was a bad idea and took it away recently
07:22:58 <Yuras> ab9rf: they could be in c++
07:22:59 <ab9rf> i haven't looked at C++11 or recent versions of boost
07:23:16 <Kaedenn> In C++ they are
07:23:18 <SleepyPikachu> I've posted a paste illustrating my problem, hopefully someone can help. :-)
07:23:22 <sinnsat> nshepperd: yeah, I remember when I tried the "tying-the-knots" wiki page where that pattern is used. It didn't typecheck :)
07:23:36 <Kaedenn> Implementing complex types without using classes in C++ is very, very difficult, if not impossible
07:23:43 <joelwilliamson> Is there an equivalent for finally that works with arbitrary monads?
07:23:59 <merijn> joelwilliamson: You mean as in Control.Exception.finally?
07:24:15 <joelwilliamson> yes
07:24:17 <merijn> joelwilliamson: You probably want
07:24:20 <nshepperd> Kaedenn: no, Nothing is not really a subclass of Maybe
07:24:20 <merijn> @hackage exceptions
07:24:20 <lambdabot> http://hackage.haskell.org/package/exceptions
07:24:30 <geekosaur> SleepyPikachu, you need a constructor to distinguish that you are talking about a Nom as part of a Command, as opposed to just some random Nom
07:24:39 <ab9rf> Nom nom nom
07:25:05 <merijn> joelwilliamson: That lifts throw/catch for transformer stacks, I don't think there's anything more general
07:25:14 <SleepyPikachu> geekosaur: so I need NomC Nom (A Command which is produced with a Nom?)
07:25:19 <geekosaur> yes
07:25:37 <geekosaur> otherwise when you say NOMUP it has no idea whether you intend it to be a Nom or a Command
07:26:01 <joelwilliamson> Great. Thanks.
07:26:02 <SleepyPikachu> geekosaur: Ok, would you say that this strategy is typical to add meaning? The alternative is having some 50 or so constructors for Command
07:26:19 <rasen> If I use type MyMonad = StateT MyState IO monad stack and I want a couple of helper function that will abstract common operation on state, should I declare them as `MyMonad result` or `StateT MyState a`? The first one is simpler and clearly specifies where to use it, while from second one it's obvious that function operates on state only and does no IO
07:26:49 <merijn> rasen: Whichever is easier/readable
07:27:03 <merijn> rasen: The advantage of MyMonad result is that if you ever change the stack you only need to update the type :)
07:27:18 <geekosaur> SleepyPikachu, I am not entirely certain what you are doing here but I might suggest you want just Direction and then data Command = Move Direction Int | Nom Direction
07:27:20 <merijn> Assuming you're using the operators from mtl instead of transformers
07:27:28 <geekosaur> the organization is unclear here
07:28:02 <nshepperd> Kaedenn: enums are probably a more meaningful analogy. "data Bool = False | True" is the equivalent of a C/C++ enum with two possible values
07:28:14 <Kaedenn> nshepperd: I understand that
07:28:19 <rasen> Oh.. I can also declare it as State MyState
07:28:27 <Kaedenn> I'm geeking out over algebraic data types
07:28:56 <SleepyPikachu> geekosaur: I'm parsing an existing language and the concepts of direction are distinct (NOMUP is a concrete command).
07:29:04 <nshepperd> "data Maybe a = Nothing | Just a" is similar except one of the values is allowed to carry data too
07:29:33 <Kaedenn> What's the purpose of Just?
07:29:47 <tdammers> Kaedenn: you need a constructor
07:29:56 <tdammers> "data Maybe a = Nothing | a" wouldn't work
07:29:57 <phaazon> hi; I repost that here, maybe some new guys know… http://lpaste.net/119875
07:30:13 <merijn> Ok, hold on, can we please stop doing this thing where we spoonfeed someone what they could just as easily read in LYAH?
07:30:19 <Kaedenn> tdammers: So Just is a constructor for Maybe.
07:30:24 <tdammers> Kaedenn: yes
07:30:26 * geekosaur is about to vanish into a conference call but in that case you may be better just making them all part of Command.
07:30:42 <SleepyPikachu> geekosaur: Thanks for your help.
07:30:51 <Kaedenn> tdammers: Okay, makes sense for me. Thanks!
07:30:57 <Kaedenn> And fromJust gets the value out of a Maybe
07:31:04 <merijn> It's fine to ask questions if you're confused about something, or double check, or get feedback/clarification, but this whole "typing out in IRC what's just as easily read in a free book" gets old :\
07:31:12 <tdammers> fromJust gets the value out, or crashes your program if there is none
07:31:14 <geekosaur> (and our conference server is on the blink, so this is likely to be more "interesting" than desired. sigh.)
07:31:20 <ab9rf> merijn: killjoy!
07:31:24 <Kaedenn> tdammers: Sounds very reasonable.
07:31:25 <rasen> merijn: I like `State MyState` better because then I can isolate IO and also don't have to change declaration when stack changes
07:31:28 <tdammers> which is why shouldn't normally use it
07:31:34 <ab9rf> geekosaur: oh, that's always so much fun
07:31:39 <tdammers> use fromMaybe instead, or pattern-match on the Maybe directly
07:31:50 <ab9rf> geekosaur: i was the admin responsible for the conference server so i know *exactly* what that's like
07:32:11 <Kaedenn> tdammers: Also makes sense
07:32:29 <tdammers> > let fooMay = Just 15 in case fooMay of { Nothing -> "nope"; Just x -> "yes, namely: " ++ show x } -- something like this
07:32:31 <lambdabot>  "yes, namely: 15"
07:32:39 <ab9rf> the nice thing about Maybe is that it's a monad, so you can use monadic forms with it
07:32:50 <tdammers> ab9rf: that's *one* of the nice things
07:32:59 <ab9rf> well, ok, one of the nice things :)
07:33:12 <tdammers> it's also an instance of Alternative, so you can use <|> to chain them and pick the first non-nothing one
07:33:15 <Lokathor> marijn, it's only just as easily read in a free book if you know exactly where to look in the book ;)
07:33:26 <tdammers> oh, and Applicative
07:33:31 <ab9rf> tdammers: hm, yeah, i use that all the time
07:33:34 <Kaedenn> Thank you everyone! I actually understand quite a bit more now
07:33:49 <ab9rf> <|> is insanely useful
07:33:54 <tdammers> yup
07:34:02 <ab9rf> my code got a lot more readable when i learned how to use that
07:34:52 <tdammers> also, monoid
07:35:59 <Lokathor> I have an issue on my github that i need to replace my manual Maybe chaining with Either chaining at some point
07:36:32 <ab9rf> Lokathor: well, Maybe a is really just Either () a, so how hard can that be? :)
07:37:14 <Lokathor> well, in my case I'm converting the Nothings into different error messages as I get them, and either returning the first error message or the Just at the end, so there's some transformer i was supposed to look up
07:39:43 <ab9rf> Lokathor: i'm actualyl surprised there doesn't seem to be a function to transform Maybe a into Either b a
07:39:45 <Lokathor> https://github.com/Strifepad/StrifeServer/blob/master/src/Main.hs starting at line 112, it's kinda ugly :/
07:40:11 <ab9rf> it would be easy enough to write but if there is one already out there hooogle doesn't find it
07:40:23 <Lokathor> oh there is such a function, uhm, Control.Error.Util has it
07:41:25 <ab9rf> ah, note
07:42:07 <ab9rf> i guess hoogle doesn't index that package
07:45:14 <Lokathor> really my entire api is a mess, but it works (i think?) and it's cleaner/stabler than i'd probably get in any other language
07:47:23 <geekosaur> hayoo can be helpful for searching all of hackage
07:49:59 <tdammers> I use a 3-stage approach - !hoogle, !hayoo, !hackage (duckduckgo bang patterns)
07:51:46 <toblerone> How does one search a broader db with Hoogle?
07:52:22 <ab9rf> by not using hoogle?
07:52:39 <geekosaur> build your own hoogle database. which has limitations, which is why hoogle doesn't currently index all of hackage (I believe fixes specifically to enable all-hackage are planned for the next release)
07:54:00 <toblerone> hmm, okay. I was looking to make a simple key mapping in vim to lookup a function's type
07:54:29 <toblerone> but since it only indexes base limited its usefullness
07:54:39 * hackagebot tellbot 0.4.0.3 - IRC tellbot  http://hackage.haskell.org/package/tellbot-0.4.0.3 (DimitriSabadie)
07:59:39 * hackagebot rethinkdb-client-driver 0.0.13 - Client driver for RethinkDB  http://hackage.haskell.org/package/rethinkdb-client-driver-0.0.13 (wereHamster)
08:00:28 <deconfigured> Hi everyone. How would I "capture" a delimited string with attoparsec? It doesn't feel intuitive to me how I would parse _until_ a '"' character, for example, and use that result
08:02:17 <ab9rf> i implemented that once forget how
08:02:26 <ab9rf> i'm sure it's in the attoparsec examples though
08:02:45 <deconfigured> I'll dig around, thanks ab9rf
08:04:29 <deconfigured> Ah! `scan`!
08:16:51 <sdegutis> Is there a tool for re-running your whole test suite the moment any file in your project changes?
08:17:10 <hiptobecubic> sdegutis, what platform?
08:17:14 <lf94> is there no way to type binary in haskell?
08:17:31 <hiptobecubic> on linux there's inotify, which i use all the time and love dearly. mac has something similar which i don't remember.
08:18:08 <elzair> OSX has FSEvents
08:18:20 <hiptobecubic> windows does too i think, but it's hard to use. Look for 'watchdog' (python) which I think abstracts out the differences
08:19:14 <tdammers> lf94: what do you mean, "type binary"?
08:19:27 <hiptobecubic> binary literals?
08:19:33 <lf94> like in python i can type 0b010101+0b101
08:19:35 <hiptobecubic> ala python's 0b00101011
08:19:36 <lf94> yeah
08:19:39 <tdammers> ah, right
08:19:51 <hiptobecubic> I don't think so, unfortunately.
08:20:03 <elzair> You can always use True and False
08:20:10 <tdammers> you could write a quasiquoter that would give you [binary|010101] :P
08:20:21 <tdammers> [binary|010101|] that is
08:20:25 <lf94> lol
08:21:33 <Iceland_jack> You can write binary literals
08:21:51 <hiptobecubic> Is there an extension?
08:21:54 <Iceland_jack> Yes, in GHC 7.10
08:22:02 <tdammers> i.e., "no, not yet"
08:22:04 <hiptobecubic> hah, so no then :)
08:22:32 <Iceland_jack> It's not my fault we're living in the present :)
08:23:31 <tdammers> Iceland_jack: or... ARE WE????
08:23:49 <Iceland_jack> Well I'm not
08:24:34 <Iceland_jack> I'm stuck in 1921, dictating IRC messages through correspondences
08:24:57 <tdammers> you're mighty fast then
08:25:22 <tdammers> otoh, you don't have to be, seeing how you can just time your messages by adjusting the time travel parameters appropriately
08:25:59 <hiptobecubic> you also have uncanny foresight. I certainly didn't see the conversation coming back in 1921
08:27:58 <gcganley> is there anyway of looking at the haddocks of a function in ghci?
08:28:15 <gcganley> ghci(-ng) i should say
08:31:27 <Zekka> Smile! My lecturer's showing off this channel for Haskell class.
08:32:03 <Skip> Hi :)
08:34:09 <gcganley> Hi Mister!
08:34:24 <gcganley> s/Mister/Proffesor
08:35:04 <gcganley> but really is there anyway to search the haddocks from ghci(-ng)
08:36:31 <Skip> gcganley: No idea, but maybe there's something availabe for the editor/IDE you use?
08:37:20 <hiptobecubic> gcganley, you can search hooglydoogly from ghci
08:37:40 <hiptobecubic> well, you can do it by installing hoogle and defining an alias in your .ghci config
08:38:09 <gcganley> hiptobecubic: I've done that but im looking at libraries like Control.Lens
08:38:32 <Skip> https://wiki.haskell.org/Hoogle#GHCi_Integration
08:38:49 <Alonely> hello everyone! :)
08:38:51 <nerium> Is there a way to "zip" to lists in haskell?
08:38:52 <nerium> Like this: [a,b,c] `superZip` [d,e,f] => [a,d,b,e,c,f]
08:39:16 <gcganley> nerium: isnt that just (++)
08:39:21 <Zekka> nerium: You can write that but it's not what Haskell'z `zip` does
08:39:25 <gcganley> > "123" ++ "456"
08:39:26 <Zekka> It's (++) if you don't care about order
08:39:27 <lambdabot>  "123456"
08:39:38 <nerium> Zekka: I do care about order
08:39:41 <Zekka> > zip "abc" "def"
08:39:42 <lambdabot>  [('a','d'),('b','e'),('c','f')]
08:39:48 <nerium> I'ts not zip
08:39:54 <nerium> that's why I wrote superZip :)
08:39:58 <Alonely> ohhai zekka
08:40:26 <Zekka> > concat $ zipWith (\x y -> [x, y]) "abc" "def"
08:40:27 <lambdabot>  "adbecf"
08:40:35 <gcganley> why wouldnt (++) be good for you?
08:40:49 <Zekka> gcganley: Because he doesn't want the order of (++)
08:40:52 <rhaps0dy> Hello guys
08:40:55 <Zekka> Look at tthe ordering of his result list
08:40:57 <Alonely> hiya
08:41:01 <rhaps0dy> Is this good style? https://github.com/rhaps0dy/proves-haskell/blob/master/sudoku/sudoku.hs#L98-103
08:41:03 <rhaps0dy> or at least passable
08:41:15 <rhaps0dy> like, checking if a var is Nothing
08:41:22 <rhaps0dy> and if it's not then extracting
08:41:30 <rhaps0dy> and relying on laziness to not be an exception?
08:41:34 <uucico> is there a way to figure out what specific optimizations -O1 is enabling with ghc?
08:42:01 <nerium> Zekka: Thanks!
08:44:00 <Ally> Zekka: I'm still a little lost on getting used to reading types
08:44:10 <Ally> when I write scale :: Double -> Vector -> Vector, it's expecting a double, and a vector, and returning a vector?
08:44:13 <gcganley> rhaps0dy: I'll load it up inna bit, I'll get back to you eventually
08:44:22 <Ally> the -> confuses me
08:44:30 <Zekka> Ally: Do you know about currying yet?
08:44:31 <sdegutis> hiptobecubic, elzair: I was hoping for something with integration into a Haskell library.
08:44:34 <Ally> no x.x
08:44:38 <rhaps0dy> gcganley: alright, thanks
08:44:38 <sdegutis> But if need be, I'll just use "fswatch".
08:45:10 <Zekka> Ally: You'll probably want to learn about that but for now that can be your reading
08:45:15 <gcganley> rhaps0dy: is it tested to work?
08:45:17 <rhaps0dy> Ally, it takes a double and returns a function that takes a vector and returns a vector
08:45:21 <rhaps0dy> gcganley: yes, it works
08:45:25 <sdegutis> In fact maybe I'll write my own fswatch.
08:45:33 <Zekka> (->) makes sense if you understand currying (which is what rhaps0dy is getting into)
08:45:34 <rhaps0dy> gcganley: the program solves sudokus accurately
08:45:39 <Ally> oh
08:45:41 <hiptobecubic> sdegutis, why would you want that? Do you never do anything outside of haskell? Filesystem change notifications are really useful.
08:45:43 <Ally> hmm
08:46:00 <rhaps0dy> Ally, i find learn you a haskell explains it pretty well, but I'm sure some other people here will know an even better source
08:46:11 <Ally> yeah, I'm reading through that bit by bit
08:46:12 <sdegutis> hiptobecubic: Because it's nice to be able to re-run my tests from within the interpreter that knows which tests to re-run.
08:46:15 <Iceland_jack> You don't need to talk about currying to understand how to use 'scale :: Double -> Vector -> Vector'
08:46:37 <Iceland_jack> I would explain currying after they understand 'scale' proper
08:46:43 <hiptobecubic> for example when I'm working I have something like the following in a second shell somewhere  "onmodify $testdir 'test-runner --failed-only || beep-loudly'"
08:46:48 <sdegutis> Currying is dead simple to explain.
08:47:04 <Zekka> Currying isn't complicated but it threw a friend or two for a loop
08:47:06 <rhaps0dy> Ally like Iceland_jack  said
08:47:07 <sinnsat> Ally: I'd start with http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html
08:47:07 <sdegutis> If you have a function "add 1 2" that returns 3, then "add 1" returns a function that takes one argument and returns 1 added to it.
08:47:11 <Iceland_jack> Not saying it's not, but it can complicate things
08:47:16 <sdegutis> That's currying. Done.
08:47:18 <Ally> ahhh, right; now that I've looked it upm I do have an idea what currying is; I saw it but never knew the name
08:47:21 <rhaps0dy> you can think that functions take n arguments and always return one
08:47:37 <rhaps0dy> and they return the last one, and the syntax for specifying type is just the arrow thing
08:48:51 <hiptobecubic> sdegutis, if you're running it within the interpreter, what is it supposed to do when your files change? Clear whatever you were doing and run tests?
08:49:05 <Zekka> Ally: Don't forget, by the way, (->) is right-associative
08:49:22 <Zekka> a -> a -> a -> a is a -> a -> (a -> a), but not (a -> a) -> (a -> a)
08:49:24 <Ally> as in the function that it takes in will always be ont he right?
08:49:28 <Ally> oh
08:49:34 <hiptobecubic> tasty can run only failed tests, if i recall correctly. Although it doesn't work as nicely as nose
08:50:14 <Zekka> That makes sense because the first two functions take bare 'a's while the third one takes a function
08:50:24 <Zekka> they really couldn't mean the same ting
08:51:09 <sdegutis> hiptobecubic: this isn't hypothetical -- many other languages have such a tool as this
08:51:26 <Iceland_jack> I find that many Haskell newcomers assume 'a -> b -> c' is some kind of special syntax or notation, not that (->) is a type operator
08:51:44 <Iceland_jack> so they may not consider its fixity
08:51:58 <sdegutis> hiptobecubic: in the other well-tooled languages I use, there is often a library that runs your tests, and when they're done running, watches for changes in the project's filesystem hierarchy, and if anything changes, re-runs them, etc
08:52:28 <hiptobecubic> sdegutis, yes, but it's a waste of effort. Every language community reinvents this tool whose one job is to react to changes and run tests, while all three platforms have it built in.
08:52:58 <hiptobecubic> sdegutis, all you need is a command to run tests that knows what just failed (i.e. by having a log). Lots of things have this. Suddenly you have a reactive test runner.
08:53:04 <Ally> Zekka: so scale :: Double -> Vector -> Vector is not the same as scale :: (Double -> Vector) -> Vector?
08:53:12 <Ally> I want it to take in a double and a vector and return a vector
08:53:21 <hiptobecubic> sdegutis, I use tasty + inotify to do what you're describing, for example.
08:53:24 <Zekka> Ally: Yes. The second one takes a function from doubles to vectors, and returns a vector
08:53:26 <Ally> a vector with each of its values multiplied by the double
08:53:34 <Ally> but the first one doesn't?
08:53:47 <Zekka> The first one takes a double and returns a function from vectors to vectors
08:53:56 <Ally> ahh
08:54:07 <hiptobecubic> sdegutis, in python I use nose + inotify. In latex I use xelatex + inotify to rebuild the pdf... it's a recurring pattern and it's already solved.
08:54:08 <Zekka> Like I said, (->) is right-associative
08:54:23 <sdegutis> okay
08:54:32 <hiptobecubic> sdegutis, not that you should go build one if you want to
08:54:45 <sdegutis> I was planning on rebuilding fswatch.
08:54:47 <hiptobecubic> sdegutis, but if all you want is the tool and not the project, it's out there.
08:54:51 <sdegutis> I built it in Go years ago when I was dumb.
08:55:01 <sdegutis> But now I want to rewrite it in Haskell.
08:55:08 <hiptobecubic> That's a fine project, go for it
08:55:52 <hiptobecubic> I'm just saying that it's applicable *way* beyond "rerun my tests" if you write the watcher separately from the test runner.
09:06:45 <eacameron> if Gabriel's "Managed" monad is for beginners, what's the advanced version, MonadSafe?
09:09:42 * hackagebot mime-mail 0.4.7 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.4.7 (MichaelSnoyman)
09:09:44 * hackagebot purescript 0.6.4.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.6.4.1 (PhilFreeman)
09:10:55 <sdegutis> How do you link against a Mac-style shared library, i.e. "framework"?
09:11:29 <eacameron> sdegutis: Try this: https://github.com/mchakravarty/language-c-inline
09:12:07 <sdegutis> No I just mean to link against it like you would link against ncurses.
09:12:30 <eacameron> sdegutis: Oh, I don't know that. I'm on Win.
09:12:34 <sdegutis> oh
09:13:23 <sdegutis> Found it:  ghc -framework <name>
09:16:39 <sinnsat> GHC.Arr.(!) is O(1), no?
09:16:59 <sinnsat> can't find any info about it in the documentation
09:16:59 <davidthomas> Does anyone have any experience with the XHB library?
09:18:01 <chpatrick> sinnsat: what would you like to use it for?
09:20:00 <sinnsat> chpatrick: I have done something similar like AndrewBromage suggested here https://wiki.haskell.org/Tying_the_Knot#Migrated_from_the_old_wiki regarding a DFA implementation, but for the half-edge data structure. The knots are very complex so I do array/list lookups, but want to tweak performance.
09:20:34 <geekosaur> sdegutis, ghc supports -framework etc. like most OS X compilers
09:20:49 <sdegutis> Right.
09:20:56 <chpatrick> sinnsat: how about vector?
09:21:39 <sinnsat> chpatrick: are they lazy?
09:22:08 <chpatrick> sinnsat: in the elements I believe so
09:23:07 <sinnsat> chpatrick: I'll look into it, thanks. But does that mean I cannot assume Array lookup is O(1)?
09:23:28 <chpatrick> I'm not sure but iirc there are very little guarantees about array
09:23:39 <chpatrick> it's meant to be O(1) I think
09:24:10 <pjdelport> sinnsat: The lookup can be O(1) even if evaluation of the result of the lookup isn't.
09:24:43 * hackagebot keyword-args 0.2.0.1 - Extract data from a keyword-args config file format  http://hackage.haskell.org/package/keyword-args-0.2.0.1 (jsl)
09:27:09 <saep> davidthomas: I worked with it a little, what do you want to do?.
09:27:48 <darkroom> does anyone know a way to catch bash commands from outputing to the terminal when running the shell command?
09:28:27 <mmachenry> darkroom: Add a "> /dev/null "to the end
09:29:12 <mmachenry> Assuming you don't want the output. If you want to have Haskell's subprocess stuff handle that, there's a way too. Even a way to get the output into memory in Haskell so you can look at it, but I don't know it off hand.
09:30:24 <enthropy> @type System.Process.readProcess
09:30:25 <lambdabot> FilePath -> [String] -> String -> IO String
09:38:21 <sinnsat> chpatrick: I just did ghc profiling and had to realize the performance breaks at the parser, not at tying the knots, lol.
09:39:43 * hackagebot sshd-lint 0.1.0.1 - Check sshd configuration for adherence to best practices  http://hackage.haskell.org/package/sshd-lint-0.1.0.1 (jsl)
09:42:12 <agocorona> blocking considered harmful
09:42:40 <elzair> Is there a good way to convert a ByteString to a Vector of Bools (i.e. Bits)?
09:44:33 <agocorona> and nonblocking considered yet more harmful
09:45:55 <elzair> I am trying to figure out an efficient representation for the Game of Life.
09:46:00 <ClaudiusMaximus> elzair: last time i checked (3 years ago..) Vector Bool wasn't packed, and i needed multi-dimensional indexing too, so I wrote the bitwise package
09:46:30 <elzair> ClaudiusMaximus: Thanks, I will check it out.
09:47:11 <ClaudiusMaximus> elzair: but GoL is best represented in a different way to an array of cells - most cells will be dead, so it's better to consider only live cells, and also see things like hashlife
09:48:00 <elzair> Thanks
09:49:14 <agocorona> or you can use Data.Bits over a raw integer
09:49:31 <edwardk> hashlife is amazing
09:55:16 <hiptobecubic> :)
09:56:00 <johnw> edwardk: http://en.wikipedia.org/wiki/Hashlife?
09:56:36 <agocorona> bloking is intuitive but forces the explicit creation of treads in many programs.  unblocking is more efficient. threading are implicitly  managed in each callback but  there is the callback hell
10:00:13 <EvilMachine> Why does the following not work: data TAnchorPoint = (CNode from, CNode what) => AnchorPoint (TAnchor from) (TAnchor to) URI
10:01:03 <MrMetric> Hay
10:01:07 <johnw> "not work" is hard to help with
10:01:08 <EvilMachine> (It tells me, “from” and “to” are not in scope)
10:01:19 <johnw> add a forall
10:01:36 <exio4> vikram_: do you really want that
10:01:41 <exio4> s/$/?/
10:01:59 <EvilMachine> johnw: I’ll try that.
10:02:29 <Eduard_Munteanu> Are there binary builds of LTS Haskell / Stackage?
10:03:08 <hiptobecubic> that would be great.
10:03:45 <begriffs> Has anyone had problems installing the bcrypt package on ubuntu?
10:05:30 <glguy> begriffs: Unless you're curious specifically about how many people had problems in general, you'll probably get better information asking about a particular problem installing it
10:07:22 <begriffs> glguy: someone filed an issue on my haskell project saying they couldn't build it on Ubuntu 14, and it seems to be due to bcrypt. https://github.com/begriffs/postgrest/issues/129
10:09:07 <tommd> begriffs: Do you run Linux?  Perhaps you can reproduce inside a docker.
10:09:17 <ReinH> edwardk: Yeah, many fast wow.
10:09:50 <begriffs> tommd: good idea. I'm on mac but I could spin up an ec2 instance I guess.
10:10:37 <tsahyt> I'm implementing a board game and was wondering if I can use laziness to implement alpha beta pruning. I have an annotated game tree with the minimax values (lazily of course), can I somehow traverse the tree in a way that resembles alpha beta pruning, such that only the relevant nodes get evaluated?
10:11:26 <begriffs> What we really need is a haskell cross-compiling server, so I can generate binaries for multiple platforms at once so people don't need to build my haskell project from source.
10:11:50 <dmwit> agocorona: blocking+green threads=best of botth worlds
10:12:14 <dmwit> tsahyt: that sounds plausible
10:13:11 <dmwit> tsahyt: what have you tried?
10:13:41 <agocorona> dmwit:  green thread are great and efficient, but still it does not solve the  need to manually manage threads when you need to do something else when your main thread is blocked
10:14:23 <dmwit> agocorona: don't block the main thread, then
10:15:11 <agocorona> dmwit:  of course, but this is applicable to any thead
10:15:20 <tsahyt> dmwit: Nothing yet, I'm not even quite sure whether it's really possible in a nice way, or if it was just better to implement alpha beta pruning like you would without laziness. I've implemented the standard minimax algorithm of course to get an annotated game tree.
10:15:38 <agocorona> I say so becaue I´m on a Monad  for non-blocking IO (and also convert  blocking IO into non-blocking) while retain the intuitive syntax of blocking IO. It also perform automatic thread management
10:15:46 <tsahyt> I was thinking I can build on minimax and just evaluate the nodes I need, because that's what alpha beta essentially does
10:16:43 <dmwit> agocorona: i disagree; main thread is special
10:17:02 <dmwit> block on all other threads with impunity
10:17:43 <quchen> I've got an odd Cabal error. I'm in a sandbox, and `cabal test` tells me "hunit >=1.2.5 is missing". `cabal install hunit` tells me that it's already installed.
10:17:55 <quchen> Sound familiar to anyone?
10:17:59 <dmwit> or maybe block on all unbound threads with impunity, not sure
10:18:09 <johnw> the right version?
10:18:16 <agocorona> dmwit: yes it is harmful to block the main thread for some obscure reasons in the scheduler AFAIK, but what I´m against is about any manual thread management at all
10:18:42 <quchen> johnw: Yes. http://lpaste.net/119893
10:18:47 <quchen> Everything looks just right.
10:19:08 <johnw> that doesn't show me that it's installed
10:19:12 <johnw> can you run: ghc-pkg list
10:19:21 <johnw> it could be shadowed
10:19:27 <quchen> johnw: Oh, my bad. http://lpaste.net/119894
10:19:32 <dmwit> cabal hc-pkg
10:19:40 <juanpablo____> If I'm using stackage within a sandbox I shouldn't need to specify package versions in my cabal file, right?
10:19:50 <juanpablo____> jvilla: ^^^^
10:20:35 <agocorona> both blocking + threading and  non blocking IO  are bad for composability of functional blocks of code
10:21:10 <quchen> dmwit: `cabal list --installed` shows me this, http://lpaste.net/119895
10:21:43 <dmwit> quchen: presumably hunit /=HUnit
10:22:03 <quchen> Uhh. Really? I thought packages were case-insensitive
10:22:09 <dmwit> no
10:22:29 <quchen> Oh wow. You nailed it.
10:22:45 <quchen> Thanks a lot.
10:23:03 <agocorona> with functional block of code I mean anything self contained  that does something meaningful for the user, that may have many threads, IO, presentation etc
10:25:38 <ReinH> edwardk: even a relatively slow implementation of hashlife can calculate a quadrillion generations in a second or so o_O It's ridiculous.
10:25:53 <dmwit> agocorona: i see. could throw *everything* in a fresh async thread; you propose something more subtle?
10:26:14 <johnw> quchen: yeah, I had dismissed that thought too
10:26:29 <agocorona> dmwit: if a functional block can be encoded in a single monadic/applicative/alternative expression, then it is composable.
10:26:47 <dmwit> edwardk: i eagerly await hashminecraft
10:27:01 <agocorona> and this is what I´m after
10:28:58 <agocorona> but the monad must automatically handle many things.
10:31:10 <agocorona> dmwit:  I need multiple threads to overcome blocking, and also manage event handlers for asyncronous IO, but all of them automatically manged by the monad and the monad primitives
10:33:29 <dmwit> agocorona: is this a wishlist or do you have a plan to achieve it?
10:33:47 <agocorona> dmwit:  I almost have it done!!
10:34:11 <dmwit> neat!
10:34:29 <agocorona> I have somre problems with thread management and concurrency in some cases
10:37:32 <agocorona> if a functional block is an application, It means that it is possible to compose applications with monad and applicative combinators
10:38:00 <fbpsd> can someone point me to a site that has a list of commercial Haskell applications? I am new to Haskell and interested in learning about real world applications written in Haskell
10:38:28 <mmachenry> fbpsd: https://wiki.haskell.org/Haskell_in_industry
10:38:39 <shapr> Anyone doing anything with the reduceron here?
10:39:06 <mmachenry> fbpsd: And there's also my project, which I plan to announce on that wiki but I can't just yet.
10:40:35 <fbpsd> mmachenry: great this is helpful..! looking forward to hearing about your project as well.
10:41:13 <fbpsd> I hear also BUMP the iphone app is powered by Haskell
10:43:07 <dedgrant> fbpsd: Rings a bell I've stumbled across the bumptech repos before. Some Haskell bindings: https://github.com/bumptech
10:43:23 <tommd> begriffs: I ran  apt-get update && apt-get install haskell-platform && cabal update && cabal install bcrypt
10:43:23 <tommd> in a new ubuntu 14.04 (docker run -t -i ubuntu:14:04).  The install succeeded without issue.  I assert this is either an architecture specific issue or the user has foobared their system somehow.
10:44:07 <fbpsd> @dedgrant thanks!
10:44:08 <lambdabot> Unknown command, try @list
10:44:42 <begriffs> tommd: thank you so much!
10:46:13 <begriffs> tommd: would you mind adding that comment to the github issue thread?
10:47:16 <juanpablo____> anyone here on Stackage?
10:47:23 <tommd> begriffs: Did I install the wrong bcrypt (named "bcrypt" on hackage)?  I don't see said issue on the github.
10:47:27 <rhaps0dy> so uh
10:47:47 <rhaps0dy> is relying on laziness to not have exceptions when extracing Maybes good style? https://github.com/rhaps0dy/proves-haskell/blob/master/sudoku/sudoku.hs#L98-103
10:47:47 <begriffs> tommd: https://github.com/begriffs/postgrest/issues/129
10:49:02 <arjanb> shapr: unlikely, but i saw recently that few people are trying to restart that project on github
10:49:31 <shapr> arjanb: yeah, I sent Tommy Thorn an email, got a good reply
10:49:38 <shapr> I'm just trying to get more people together :-)
10:49:46 * hackagebot resolve-trivial-conflicts 0.2.0.2 - Remove trivial conflict markers in a git repository  http://hackage.haskell.org/package/resolve-trivial-conflicts-0.2.0.2 (EyalLotem)
10:53:02 <arjanb> shapr: it's an interesting project, however i'm too busy with getting an alternative processor design working :-)
10:53:32 <shapr> arjanb: I'm interested in using 'real' Haskell in the embedded space, and the Reduceron seems like a good approach to that.
10:53:40 <shapr> arjanb: Which project are you working on?
10:55:14 <dino-> quchen: hm, couchbase for Haskell. I could use that, is it on hub.darcs.net or github?
10:56:02 <johnw> shapr: \∘/!
10:56:25 <quchen> dino-: We're still working on it, it's not finished at all yet :-\
10:56:34 <shapr> howdy johnw!
10:56:38 <arjanb> shapr: I'm working on the pilgrim which is focused on high performance and looks more like an normal processor with an instruction set and a deep pipeline
10:57:22 <shapr> haven't heard of it
10:58:07 <shapr> arjanb: aha, utwente?
10:58:08 <dino-> quchen: Fantastic that it's being worked on at all!
10:58:11 <arjanb> yep
10:59:03 <shapr> arjanb: any non-paywall papers I can read?
10:59:22 <quchen> dino-: Glad to hear that! Unfortunately I can't open source it right now ("reasons"), but it's going to be published under an open license (BSD or something) when we're done.
11:03:12 <arjanb> shapr: no but i could mail you that (somewhat outdated) paper, and i hope to have working implementation with paper this summer
11:03:53 <shapr> arjanb: what I can find about pilgrim looks awesome, does it have an implementation on an FPGA?
11:04:04 <shapr> arjanb: ah, I see, I'm interested, yes :-)
11:04:51 <byorgey> shapr: my student has been doing some stuff with the reduceron
11:04:55 <byorgey> I don't think he's on IRC though
11:05:12 <shapr> byorgey: ooh, tell me more! Is he part of the effort on github?
11:05:34 <Ygral> Has anyone tried to do linear algebra with Repa?
11:05:36 <shapr> I'm getting a novena laptop, and it has a decent sized Xilinx FPGA, so I want to try that for embedded dev purposes.
11:06:19 <arjanb> shapr: it doesn't have an fpga implementation yet but i'm working on that (now that my colleague has cλash in usable state)
11:06:53 <byorgey> shapr: he knows about the effort on github, I think he has corresponded with Tommy Thorn, but I don't think he has directly contributed to the repo
11:07:21 <byorgey> shapr: he has been trying to compile Haskell to the reduceron by compiling GHC Core -> F Lite -> reduceron
11:07:24 <shapr> byorgey: Is he using a Xilinx FPGA?
11:07:28 <shapr> ah, interesting
11:07:37 <shapr> any preliminary code/results?
11:07:50 <byorgey> shapr: I don't think he's gotten as far as actually running anything on an FPGA
11:07:54 <shapr> fair enough
11:07:59 <byorgey> I think we have some FPGAs lying around here but I dunno what kind
11:08:40 <shapr> I have the urge to create a haskell-fpga mailing list...
11:08:44 * shapr denies the urge
11:09:16 * sinelaw gives shapr a small push
11:09:48 <shapr> sinelaw: nah, not until I get something actually working :-P
11:09:50 <sinelaw> at least make a wiki page
11:10:36 <shapr> sinelaw: good idea, I thought there would already be one
11:10:47 <sinelaw> maybe there is. Haven't checked.
11:10:51 <sinelaw> didn't check. whatever.
11:10:53 <shapr> I just checked, there isn't
11:11:10 <sinelaw> there you go - accomplishment of the day, waiting for you
11:13:15 <rhaps0dy> whoah, you talking bout the reduceron?
11:13:18 <rhaps0dy> is it going nice and smooth?
11:13:27 <sinelaw> is it still being developed?
11:17:58 <sdegutis> Is there some tool for making GHC's error messages easier to read? Perhaps some colorizing and highlighting or something?
11:19:02 <jeltsch> The --run-tests flag for cabal install doesn’t seem to have any effect. Any ideas why?
11:19:42 <jeltsch> For now, I can only run test suites with cabal test, but this registers the package in-place, which I want to avoid.
11:20:01 <fbpsd> mmachenry: on the link you provided, i noticed an IHG are they active? doing anything to promote Haskell and expand its usage? not sure if anyone else is doing that I certainly came across Haskell by a coincidence.
11:23:11 <hsk3> This is a stretch, but has any of you ever installed plain GHC and Cabal (without Haskell Platform) on OS X?
11:23:24 <johnw> yes
11:25:21 <shelf> woah - reduceron
11:25:23 <shelf> this is cool
11:25:45 <hsk3> johnw: How did you do it? Did you compile GHC yourself? there are no mac binaries on the ghc site
11:25:53 <mmachenry> fbpsd: No clue
11:27:08 <johnw> hsk3: you'll need to download a Mac binary; there should be one on teh GHC site
11:27:21 <johnw> https://ghcformacosx.github.io
11:27:38 <shapr> rhaps0dy, sinelaw: yes, Tommy Thorn is developing the reduceron, it's on github
11:27:48 <kadoban> hsk3: I do it all the time on ubuntu, which is probably pretty similar honestly. https://gist.github.com/ion1/2815423 is the steps I do, https://www.haskell.org/ghc/download_ghc_7_8_3#macosx_x86_64 has an OS X version of the thing I use for GHC, etc.
11:28:05 <rhaps0dy> shapr, are we on our way to a Haskell machine?
11:28:08 <rhaps0dy> That would be pretty rad
11:28:18 <fbpsd> i think its somewhat sad, that such highly productive, efficient language under utilized and not widely used! can u imagine the state of code quality and productivity you get if more ppl use Haskell… !! wondering what we r doing as Haskellers to change this?
11:28:18 <shapr> rhaps0dy: that's the idea, I hope it works out.
11:28:37 <shapr> and arjanb is working on a related effort to build a graph reduction CPU called "pilgrim"
11:28:44 <kadoban> hsk3: Actually, you should probably do 7.8.4 I guess, but same difference.
11:28:58 <hsk3> kadoban: yeah I just noticed that 7.8.3 has the ready-made mac binaries, but not 7.8.4, not sure why
11:29:08 <shapr> fbpsd: lots of good improvements happening, jump in and contribute!
11:29:14 <rhaps0dy> shapr, yeah, I hope it works out too
11:29:23 <kadoban> hsk3: Oh, strange.
11:29:24 <rhaps0dy> unfortunately, I don't think I can contribute, I know next to nothing about hardware development
11:29:47 * hackagebot patronscraper 0.0.0.1 - A webpage scraper for Patreon which dumps a list of patrons to a text file.  http://hackage.haskell.org/package/patronscraper-0.0.0.1 (Forkk)
11:30:02 <shapr> rhaps0dy: same here, but I didn't know anything about Haskell when I started the #haskell IRC channel
11:30:20 <fbpsd> i will for sure… ! i want to build real apps in Haskell and tell as a story
11:30:22 <hiptobecubic> fbpsd, i think you underestimate our ability to write hideous code.
11:30:29 <hiptobecubic> I, for one, am an expert.
11:30:30 <rhaps0dy> 1) You started this channel? :O 2) you didn't know anything about haskell and yet started this channel??
11:30:37 <shapr> rhaps0dy: yup, many years ago
11:30:57 <glguy> That's called squatting ^_^
11:30:59 <shapr> according to chanserv, 13 years and 40 weeks ago
11:30:59 <rhaps0dy> shapr: why would you start the channel then?
11:31:20 <shapr> rhaps0dy: because I wanted to learn Haskell! so I convinced a bunch of academics that there were smart academics to talk to here on #haskell
11:31:24 <shapr> and when they showed up, it was true!
11:31:30 <rhaps0dy> shapr: oh, cool :)
11:31:38 <rhaps0dy> what do I need to do to contribute then?
11:31:40 <csd_> Would someone please critique this code and let me know why I'm getting type errors? https://www.refheap.com/96865
11:31:53 <glguy> csd_: What'd the compiler say?
11:31:58 <geekosaur> you should include the full type errors...
11:32:06 <hsk3> kadoban: why does it say "The source distribution needs an installed GHC" here https://www.haskell.org/ghc/download_ghc_7_8_4  Does GHC compilation require GHC?!!
11:32:12 <shapr> rhaps0dy: I emailed Tommy Thorn and asked him, he recommended several FPGAs of various costs
11:32:14 <monochrom> shapr understood lazy evaluation before learning haskell :)
11:32:15 <sdegutis> Is there a way to colorize GHC's compiler error messages?
11:32:21 <csd_> glguy-- https://www.refheap.com/96866
11:32:22 <sdegutis> These things are so hard to parse through when monochromatic.
11:32:26 <shapr> rhaps0dy: come on over to #haskell-embedded and we can chat about reduceron stuff
11:32:31 <shapr> monochrom: haha, yes
11:32:49 <rhaps0dy> csd_: why do you map myMax to a tuple of lists?
11:33:10 <glguy> csd_: It looks like it couldn't match (t,t1) with [b0]
11:33:11 <csd_> destructing splitAt's result that way seemed like an elegant way of splitting up xs
11:33:21 <kadoban> hsk3: Probably? Most of it is written in Haskell I believe. That's why I use the binary ones. I would think you'd be fine with 7.8.3, unless one of those bugs fixed is really a blocker for you.
11:33:23 <csd_> is it not actually destructuring?
11:33:27 <geekosaur> csd_: map will always produce a list, not a tuple
11:33:31 <rhaps0dy> csd_: you can't do that ^
11:33:47 <geekosaur> maybe that list contains tuples, but you can't turn it *into* a tuple
11:33:57 <rhaps0dy> you should maybe run myMax on both sids of tuple maybe
11:34:23 <csd_> oh
11:34:32 <csd_> type error because splitAt produces tuple and map takes list
11:34:42 <hsk3> kadoban: yeah
11:34:46 <hsk3> i'll do the binary
11:34:54 <glguy> csd_: It'll be a good exercise to figure out how to fix this could, but it will be less efficient than computing the maximum from the beginning straight to the end
11:35:07 <glguy> (this code*)
11:35:33 <csd_> glguy-- what do you mean "beginning straight to end"? iterating?
11:35:50 <rhaps0dy> now that we're code reviewing
11:35:57 <glguy> yeah, "folding" the list with max
11:36:01 <rhaps0dy> Please, can you give me a style tip?
11:36:12 <csd_> i'm just doing this as a divide and conquer exercise
11:36:21 <rhaps0dy> Is relying on the laziness to not evalute a Maybe that you extract and not produce an exception good?
11:36:51 <rhaps0dy> relevant code: https://github.com/rhaps0dy/proves-haskell/blob/master/sudoku/sudoku.hs#L98-103
11:37:27 <tsahyt> is there any reason to prefer transformers over mtl?
11:37:31 <csd_> glguy-- so what's the ideal way to split a list in two and then map over the result?
11:37:51 <csd_> [a] -> b -> [[a][a]] doesn't exist in hoogle
11:38:12 <geekosaur> tsahyt, I would say no. you may be seeing stuff that is out of date, referring to mtl1 vs. transformers. that one is long done; mtl2 is *based on* transformers
11:38:14 <sinnsat> is there a haskell channel for bored people who want to review random code snippets?
11:38:32 <tsahyt> so when starting a new project, I should pick mtl?
11:38:36 <geekosaur> yes
11:38:43 <tsahyt> okay, thanks!
11:38:59 <kadoban> sinnsat: There's http://exercism.io/
11:39:39 <platz> +1 exercism
11:39:47 <glguy> csd_: for a divide and conquer algorithm on singly-linked lists like this I like the method of turning the input [a] into a [[a]], and then repeatedly processing neighboring elements together until you have one left
11:39:56 <glguy> that way you don't spend your time splitting and appending things
11:41:41 <monochrom> in divide and conquer, it is not required to divide evenly
11:42:15 <monochrom> for example, to find the max of 10 numbers, it is valid to find the max of the first number, and find the max of the other 9 numbers, then find the max of the two.
11:43:03 <hsk3> kadoban: Why do you add that $HOME/.cabal-sandbox/bin into PATH? Isn't a cabal sandbox supposed to be one per each project?
11:43:51 <lpaste> glguy pasted “divide/conquer maximum for csd_” at http://lpaste.net/119900
11:44:03 <kadoban> hsk3: I think that's for people who use sandboxes differently from how I do. I leave out that specific part from my $PATH
11:44:14 <hsk3> kadoban: thanks
11:44:48 * hackagebot hxt 9.3.1.13 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-9.3.1.13 (UweSchmidt)
11:44:55 <hsk3> kadoban: wow this ghci loaded up FAST (unlike the platform one)
11:45:49 <fbpsd> these r cool case studies for Haskell https://www.fpcomplete.com/page/case-studies
11:45:54 <kadoban> hsk3: Heh, nice. I'm not sure why that would be exactly, less modules to load maybe?
11:46:02 <hsk3> kadoban: yeah probably
11:47:34 <rhaps0dy> johnw: hey, are you around?
11:47:44 <johnw> rhaps0dy: yes
11:47:55 <rhaps0dy> johnw, can you help me for a moment please? It's a silly question
11:48:01 <johnw> ask away!
11:48:11 <rhaps0dy> is using a lazy check on Nothing to avoid exceptions being thrown when extracting a Just good practice?
11:48:19 <rhaps0dy> 1 sec
11:48:29 <rhaps0dy> johnw: relevant code https://github.com/rhaps0dy/proves-haskell/blob/master/sudoku/sudoku.hs#L98-103
11:48:36 <rhaps0dy> thanks :)
11:49:17 <sinnsat> kadoban: I was rather referring to random code I wrote... not in the sense of exercises to do.
11:49:19 <johnw> I'd do: case possibilities of [x] -> Just x; _ -> Nothing
11:49:27 <johnw> which I think is called listToMaybe
11:50:01 <kadoban> sinnsat: Then, here probably? I've seen people ask and get answers of that type.
11:50:14 <johnw> i'm not sure what the exact question is from that code though
11:50:33 <ahammel> Hypothetical question:
11:50:46 <Saizan> rhaps0dy: you should really use a case expression on propagate s there
11:51:14 <sinnsat> kadoban: it's more than 100 lines... feels impolite to dump something like this here
11:51:23 <johnw> use case matching when you can in general, rather than equality tests
11:51:42 <ahammel> how much would you hate me if you were working on my code and you found I had defined an operator (!!!) :: [a] -> Int -> Maybe a
11:52:13 <kadoban> sinnsat: Well, people are free to ignore your request. As long as you're polite about it and use a pastebin instead of pasting to channel, I don't think you'll ruffle any feathers.
11:52:23 <sinnsat> ahammel: isn't that the same as Safe.atMay?
11:52:30 <rhaps0dy> johnw, but how can I use matching there? maybe creating a separate function, but it'd leave "solve" pretty short
11:52:34 <rhaps0dy> Saizan: let's see
11:52:45 <rhaps0dy> oh
11:52:50 <rhaps0dy> case (propagate s) of ...
11:52:56 <rhaps0dy> ty <3
11:53:03 <johnw> you don't even need the parens then
11:53:26 <sinnsat> ahammel: https://hackage.haskell.org/package/safe-0.3.8/docs/Safe.html#v:atMay
11:53:30 <dmj> ahammel: what makes you think that's a bad idea
11:53:47 <kadoban> ahammel: A negative amount of hate
11:54:05 <ahammel> dmj: mostly my calling it (!!!)
11:54:17 <ahammel> if it already exists, that's even better, though
11:54:18 <ahammel> cheers
11:54:32 <dmj> ahammel: you could call it lookupMaybe or something, I've seen far crazier infix operators though
11:54:42 <sinnsat> maybe something like (!!?) would be better... the Vector package does (!?)... so
11:54:48 * hackagebot cabal-test-bin 0.1.4 - A program for finding temporary build file during cabal-test.  http://hackage.haskell.org/package/cabal-test-bin-0.1.4 (junjihashimoto)
11:55:48 <ahammel> sinnsat: (¿!!?) = (!!?) -- localization
12:03:58 <sdegutis> I've had a nearly impossible time getting the Haskell tools to play nicely together.
12:04:10 <sdegutis> I'm almost ready to just give up on it.
12:04:35 <Clint> "the Haskell tools"
12:05:58 <arjanb> sdegutis: what kind of problems are you hitting?
12:06:17 <csd_> Is there a Haskell package that will tell me what the run time of my code in Big O is?
12:06:23 <sdegutis> Well, I wanted to create a small application that had Hspec tests, and be able to run them automatically.
12:06:35 <sdegutis> But, first I couldn't get the tests in test/ to see the files in src/
12:06:44 <sdegutis> So I gave up and put all my files together in the root directory of the project.
12:07:08 <sdegutis> Now I'm trying to get `cabal test` to show the output of the tests in color, as well as the output of the compiler errors.
12:07:25 <sdegutis> And ideally I'd like to have the tests back in test/ and the source back in src/
12:09:49 * hackagebot cabal-test-bin 0.1.5 - A program for finding temporary build file during cabal-test.  http://hackage.haskell.org/package/cabal-test-bin-0.1.5 (junjihashimoto)
12:13:45 <arjanb> sdegutis: never used Hspec, but i see that the hspec project (on github) has a seperate source and test directories, so maybe you can reuse of parts their cabal file
12:14:01 <sdegutis> I couldn't find the relevant part in this:  https://github.com/sol/hspec-tutorial/blob/master/time-service.cabal
12:15:38 <arjanb> it's at the bottom starting at line 35
12:16:23 <sdegutis> arjanb: I mean I couldn't find the part of this that made the test suite see the main project source files.
12:16:38 <hsk3> kadoban: why does that gist advocate downloading ghc BINARY but cabal SOURCE?
12:16:44 <sdegutis> Oooh, I see. It creates a library that does all the work.
12:16:54 <sdegutis> And the executable is the "driver/Main.hs" file, which just loads the library.
12:17:04 <sdegutis> Is this a common trick when testing a Haskell executable?
12:17:59 <arjanb> it's a common approach with cabal at least
12:18:27 <kadoban> hsk3: I think just because you can. There's probably some cabal binary out there you could use, but I dunno where to find it, and the instructions work for me. IIUC you could do GHC source as well, it's just much harder, since you need to have GHC already, and probably more deps, where cabal is easier to build from source
12:18:48 <hsk3> kadoban: makes sense
12:19:50 * hackagebot tidal 0.4.29 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.29 (AlexMcLean)
12:19:55 <sdegutis> Are there decent alternatives to cabal?
12:22:41 <dfeuer> sdegutis, no. For what Cabal does, there is nothing else. If you want something that does something a little different, people seem to recommend Nix a lot.
12:22:49 <sdegutis> okay thanks
12:22:55 <sdegutis> I'm just spoiled by Leiningen I guess.
12:22:57 <kadoban> Most OS package managers seem to have a decent amount of haskell packages you could use I guess, but they tend to be super outdated and missing a lot as far as I noticed.
12:26:37 <chpatrick> why isn't Constraint not just Bool?
12:26:47 <chpatrick> it would be pretty neat if Show :: * -> Bool
12:26:53 <chpatrick> (~) :: k -> k -> Bool
12:26:54 <chpatrick> etc
12:27:34 <shachaf> Bool is awful. :-(
12:27:43 <sdegutis> shachaf: why?
12:27:45 <shachaf> A Constraint gives you information, Bool doesn't.
12:27:52 <chpatrick> what does it give?
12:28:02 <ab9rf> yeah, what if it's false for every possible input.  or true?
12:28:09 <shachaf> @where boolean-blindness for instance.
12:28:10 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
12:28:17 <chpatrick> this is at the type-level
12:28:26 <chpatrick> *kind-level
12:28:49 <shachaf> Yes, it's a different level of awful.
12:29:07 <ab9rf> the nth circle of hell
12:29:17 <chpatrick> ok, but what does Constraint do other than "yes this type matches/doesn't match"
12:30:33 <josephle> it tells you which types match
12:30:40 <chpatrick> ah, I see
12:30:42 <shachaf> Constraints don't even behave like Bools. There isn't exactly such a thing as a "no" answer to "is T an instance of C?".
12:31:01 <chpatrick> so they're more like a proof
12:31:06 <shachaf> If I write foo :: (a ~ b) => a -> b; foo x = x, and it turns out the thing on the left of the => is True, how does that help me?
12:31:21 <ab9rf> proofs and computability are closely related
12:31:34 <chpatrick> I mean they're like a certificate
12:31:44 <ab9rf> and as we all know, truth and proof have a complex relationship
12:31:48 <chpatrick> Show takes a type and if it's a Show then you get a certificate saying that "x is a Show"
12:32:20 <shachaf> ab9rf: Maybe those things are related but I'm not sure how relevant they are to this discussion. :-)
12:32:32 <shachaf> chpatrick: Right.
12:32:57 <shachaf> It could mean different things for different sorts of constraints.
12:33:10 <chpatrick> fair enough
12:37:19 <ab9rf> the name "conor mcbride" always makes me think of highlander
12:45:10 <joneshf-laptop> There's this line herE: https://www.haskell.org/cabal/users-guide/developing-packages.html#test-suites "...it is preferred that new test suites be written for the detailed-0.9 interface." but I don't see many of the more popular libraries doing this
12:45:23 <joneshf-laptop> is it actually a thing to do?
12:48:31 <Adeon> joneshf-laptop: AFAIK, no
12:48:57 <Adeon> I've never seen a package that uses the detailed test-suite type but then again I don't usually pay attention to their test-suite types
12:49:34 <ab9rf> mmm, passive voice.  just who is doing this preferring?
12:53:56 <hsk3> kadoban: Do you know what that "EXTRA_CONFIGURE_OPTS=-p" is?
12:54:28 <hsk3> The command shown in README.md in the cabal-install-1.22.0.0 folder is: EXTRA_CONFIGURE_OPTS="" ./bootstrap.sh
12:54:41 <hsk3> But the command in that gist is: EXTRA_CONFIGURE_OPTS=-p sh bootstrap.sh
12:54:46 <hsk3> What's the difference?
12:57:59 <kadoban> hsk3: No, I'm not really sure what that is. I've never tried without.
13:04:10 <oisjfoisjdf> hey are attoparsec and parsec infinite lookahead? - would choice [string "asdf',
13:04:23 <oisjfoisjdf> hey are attoparsec and parsec infinite lookahead? - would choice [string "asdf', string "aaa"] work?
13:05:21 <sinnsat> hsk3: just a guess.. maybe profiling?
13:05:40 <hsk3> sinnsat: yes I'm wondering about that. could it be that -p is the same as --enable-library-profiling ?
13:05:43 <hsk3> by any chance
13:06:01 <clrnd> oisjfoisjdf, parsec has 'try' which doesn't consume input
13:06:13 <hsk3> it's something being run inside of that bootstrap.sh script
13:09:03 <oisjfoisjdf> clrnd: im guessing its very slow? does attoparsec have this?
13:09:26 <chpatrick> http://lpaste.net/119905
13:09:28 <clrnd> oisjfoisjdf, it's not recommended yeah, and I think attoparsec doesn't have this but I;m not completely sure
13:09:32 <chpatrick> any idea why this won't compile?
13:09:42 <chpatrick> first time I've seen an "inaccessible code" error
13:10:07 <oisjfoisjdf> clrnd: actually i found it in the attoparsec docs and it says there might be siginificant performance costs
13:10:17 <chpatrick> it's like it decides that a doesn't ~ ElemOf '[Int, String] before even knowing what it is
13:10:46 <oisjfoisjdf> clrnd: that answers my question - they primarily made for 1 lookahead but have a workaround for infinite lookahead
13:10:50 <clrnd> oisjfoisjdf, This combinator is provided for compatibility with Parsec. attoparsec parsers always backtrack on failure.
13:11:04 <oisjfoisjdf> wait what
13:11:08 <clrnd> from Attoparsec's docs
13:13:31 <oisjfoisjdf> clrnd: wouldnt that make it very computationally expensive?
13:13:53 <clrnd> oisjfoisjdf, I guess that's why they don't include a functionning `try` combinator
13:14:03 <clrnd> attoparsec is focused on performance
13:14:16 <clrnd> parsec isn't
13:14:18 <oisjfoisjdf> clrnd: i mean always backtracking should be very expensive
13:14:46 <oisjfoisjdf> cause you never know if you will need to backtrack until you've fully matched something
13:14:52 <clrnd> oisjfoisjdf, I'm pretty sure it would
13:15:35 <oisjfoisjdf> whereas with try you could limit the backtracking to a few cases
13:15:58 <cdx> oisjfoisjdf: attoparsec is based on continuations, so I'm pretty sure backtracking is just jumping back to the parent continuation (pretty efficient)
13:16:46 <ab9rf> i thought attoparsec lacked try bceause it didn't need it
13:17:30 <oisjfoisjdf> cdx: the backtracking itself isnt expensive but keeping track of all the intermediate states which you cannot discard is expensive
13:18:02 <Haskellfant> chpatrick: I tried looking at it but for me it fails with “elemof should have 3 arguments but has been given 2”
13:25:24 <hsk3> kadoban: Is one of the reasons you prefer plain ghc&cabal over Platform not to get package conflicts?
13:27:59 <oisjfoisjdf> is there a way in haskell to write a function Monad m => m a -> a ?
13:28:18 <johnw> no
13:28:38 <johnw> there is however Comonad w => w a -> a
13:28:42 <oisjfoisjdf> johnw: is this the main property of monads?
13:28:54 <johnw> you could say it is a main property of monads, yes
13:29:07 <oisjfoisjdf> okay cool
13:29:15 <johnw> I'd call "join" the main property, personally
13:29:22 <johnw> with return a close second
13:29:26 <johnw> :)
13:29:29 <oisjfoisjdf> johnw: join as in bind?
13:29:38 <johnw> bind is implemented in terms of fmap and join
13:29:59 <shachaf> oisjfoisjdf: Do you mean, is the fact that you can't write a function :: Monad m => m a -> a fundamental to what a monad is?
13:30:08 <oisjfoisjdf> ya shachaf
13:30:18 <shachaf> If so, no. You can write that function for some particular monads. You can't write it for other monads.
13:30:29 <shachaf> It's just not part of the monad API.
13:30:42 <pjdelport> You can think of it this way: Functor gives you fmap; Applicative adds pure (or return) and <*> (or ap) to it; and Monad adds join to Applicative.
13:30:58 <oisjfoisjdf> shachaf: can you give an example of such a function?
13:31:12 <c_wraith> :t runIdentity
13:31:13 <lambdabot> Identity a -> a
13:31:19 <c_wraith> there's an example of one!
13:31:23 <shachaf> c_wraith's example is an example.
13:31:36 <shachaf> Monads aren't about "hiding things" or "trapping you" or anything like that.
13:31:38 <ahammel> oisjfoisjdf: \[a] -> a
13:31:56 <shachaf> ahammel's example isn't as good of an example. :-(
13:31:56 <kadoban> hsk3: It seems easier to tell what's going on with sandboxes, and then I can use stackage and etc. and everything works perfectly
13:32:01 <shachaf> (Because it crashes on most inputs.)
13:32:06 <c_wraith> :t runST
13:32:07 <lambdabot> (forall s. ST s a) -> a
13:32:13 <ahammel> shachaf: yeah, that's a crappy function, but it's got the right type signature!
13:32:18 <ahammel> even worse:
13:32:19 <bolmar> :t (maybe 0 id)
13:32:20 <lambdabot> Num b => Maybe b -> b
13:32:25 <ahammel> @hoogle unsafePerformIO
13:32:25 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
13:32:25 <lambdabot> Foreign unsafePerformIO :: IO a -> a
13:32:25 <shachaf> ahammel: You're being unhelpful here.
13:32:26 <oisjfoisjdf> hmm
13:32:32 <shachaf> ahammel: What's the point?
13:32:39 <ahammel> sorry, I didn't mean to be
13:32:40 <hsk3> kadoban: yeah. however, i'm wondering, what happens if you'd accidentally install cabal packages globally? would you have to delete the .cabal folder and reinstall from scratch?
13:32:52 <ahammel> just giving an example of a monad where it's trivial to "escape" so to speak
13:32:57 <c_wraith> hsk3: deleting the .cabal directory does nothing.  packages are installed into .ghc
13:33:09 <hsk3> oh
13:33:10 <ab9rf> hsk3: it's possible to uninstall a package with ghc-pkg
13:33:27 <hsk3> ab9rf: yes but does that also delete all the dependencies? packages tend to have tons of dependent packages
13:33:32 <kadoban> hsk3: Well, globally is just for my user, but yes I do that commonly if I've screwed something up.
13:33:35 <ab9rf> hsk3: you have to do them by hand
13:33:42 <ab9rf> hsk3: i've done this and it's tedious
13:33:44 <hsk3> kadoban: ok, nice strategy to know.
13:33:49 <hsk3> just delete and start over :)
13:34:06 <ab9rf> i've done the "blow away the package store" too
13:34:08 <hsk3> kadoban: thanks dude. helped me a lot
13:34:11 <ab9rf> three or four times :)
13:34:12 <hsk3> your comments today
13:34:17 <hsk3> Hehe
13:34:23 <oisjfoisjdf> okay so a function 'foo M a = a' is valid where M is a monad constructor?
13:34:30 <johnw> hsk3: I'll also note that Nix is a good option here
13:34:40 <johnw> if you want to avoid ever have to "blow away and restart" as a solution
13:34:43 <kadoban> 'welcome, glad it worked for you. I'm not sure who ever wrote up those instructions, but it seems like a great solution to me, has saved me a ton of hassle
13:34:54 <oisjfoisjdf> shachaf: okay so a function 'foo M a = a' is valid where M is a monad constructor?
13:35:31 <shachaf> oisjfoisjdf: I don't think so. You're probably looking for the wrong sort of thing here.
13:35:39 <c_wraith> oisjfoisjdf: sometimes.  Depends on the exact M.  It's *really* hard for things like State
13:35:51 <shachaf> The FAQ about this is good:
13:35:53 <Zemyla> @hoogle Char -> String
13:35:53 <ab9rf> don't you need parens?
13:35:54 <shachaf> @faq
13:35:54 <lambdabot> Network.URI escapeURIChar :: (Char -> Bool) -> Char -> String
13:35:54 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
13:35:54 <lambdabot> Text.Html prettyHtml :: HTML html => html -> String
13:35:54 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
13:36:13 <Zemyla> What function escapes and prints a character?
13:36:23 <c_wraith> Zemyla: print?
13:36:37 <Zemyla> Well, escapes and stringifies.
13:36:39 <oisjfoisjdf> c_wraith: but those things like state are 'special' builtins in the language?
13:37:00 <oisjfoisjdf> c_wraith: im talking about just pure user-defined monads
13:37:03 <c_wraith> oisjfoisjdf: no.  State is a simple pure haskell library.  (I could write it from scratch in 10 minutes or so)
13:37:07 <ab9rf> Zemyla: that sounds like show; it produces a represetnation that would, if read, return the same vcalue
13:37:15 <johnw> c_wraith: the stopwatch has started
13:37:31 <oisjfoisjdf> c_wraith: okay I think i should read the code for that then
13:37:37 <c_wraith> johnw: before starting it, tell me if I need to implement the whole mtl along with it. :P
13:37:54 <johnw> nah, just newtype State and its basic instances
13:38:05 <c_wraith> well, and get and set
13:38:23 <johnw> those are technically needed
13:38:28 <johnw> if I have access to the constructor
13:38:33 <johnw> s/are/aren't
13:42:02 <jug1> Is there a generic way to get the diff between two structures of the same type?
13:43:00 <johnw> you could use Alignable
13:43:01 <Haskellfant> chpatrick: you can work around your problem using http://lpaste.net/119907
13:43:13 <johnw> from Data.Align in http://hackage.haskell.org/package/these
13:43:20 <Haskellfant> not quite sure why I can't partially apply your predicate type family
13:44:02 <mwr54> does anyone know if you can use Postgres's JSON features with persistent?
13:46:34 <shachaf> Saying "you can't escape monads" is like saying "you can't compare numbers".
13:46:51 <chpatrick> Haskellfant: the idea was to convert a type family to a constraint though
13:46:59 <chpatrick> I'm not sure why it's not possible
13:47:07 <jug1> johnw: Looks a little advanced for my knowledge, but I will play around with it
13:47:55 <sinnsat> hmm, seems that in attoparsec "space" also matches "endOfLine"
13:47:56 <c_wraith> johnw: oh.  finished a couple minutes ago. Got distracted by video games. :)
13:48:44 <Haskellfant> chpatrick: are you on ghc < 7.8.4? I just found https://www.haskell.org/pipermail/ghc-devs/2015-January/007982.html which says that partial application of type families is never allowed and it was a bug that is was turned on in 7.8.3
13:48:54 <Haskellfant> which seems to make what you are trying to do impossible
13:49:47 <tasker> Is there some easy way to estimate the memory that a mutable unboxed array of doubles will take up ? e.g. given the size in entries..
13:50:26 <jyepesr1> How Can I convert a int to string?
13:50:34 <Haskellfant> jyepesr1: show
13:51:14 <chpatrick> Haskellfant: yeah I'm on 7.8.3
13:51:17 <chpatrick> fair enough :)
13:51:30 <shachaf> tasker: Probably the length of the array times the size of a Double, plus a constant?
13:51:47 <Haskellfant> chpatrick: richard mentions some ideas on how to work around this here https://www.haskell.org/pipermail/ghc-devs/2015-January/007983.html (still reading)
13:52:02 <Zemyla> Oh, I know how to do deserialization now without making a giant-ass table.
13:52:29 <c_wraith> shachaf: I think mutable arrays use card-marking to speed up GC.  That would give them a very small constant-factor overhead
13:52:30 <tasker> shachaf: Er, how can I work out the size of a Double? And, any estimate on the constant? (if not I can experiment)
13:52:39 <shachaf> c_wraith: Oh, right.
13:52:51 <shachaf> c_wraith: Wait, even unboxed arrays?
13:53:01 <c_wraith> shachaf: oh, nevermind.  Those shouldn't
13:53:13 <shachaf> tasker: sizeOf (undefined :: Double)
13:53:17 <shachaf> (It's 8.)
13:53:17 <tasker> Ah, cool
13:53:45 <jyepesr1> Haskellfant Thanks a lot very helpful
13:54:19 <Zemyla> If I have type (Data p, KnownNat n) => Packer p n | p -> n, n -> p, then I can have a token parser using tokenPrim that takes a byte and sees if it's equal to n. If so, it returns a Tagged p Constr.
13:54:39 <Haskellfant> jyepesr1: show works not only for Int but for all types that are an instance of the Show typeclass
13:54:48 <tasker> Incidentally, what is this card-marking?
13:54:53 <tasker> I've never heard of it
13:55:19 <c_wraith> tasker: card-marking is a strategy where you keep (rough) track of what ranges of an array have been updated since the last GC
13:55:31 <Profpatsch> Is there an overview of all Module namespaces?
13:56:05 <shachaf> It's relevant if you have a boxed array, because you have to follow the pointers when you GC.
13:56:15 <tasker> shachaf: Ahh, okay.
13:56:45 <Profpatsch> Something that lists the modules of most packages, like http://hackage.haskell.org/package/base-4.7.0.2 does, but for all packages.
13:57:14 <Profpatsch> Oh wait.
13:57:17 <Profpatsch> ghci …
13:58:00 <tasker> shachaf: Actually, stupid question - what are the units of sizeOf?
13:58:26 <shachaf> http://hackage.haskell.org/package/base-4.7.0.2/docs/Foreign-Storable.html#v:sizeOf tells you.
13:58:43 <tasker> Ok, cool cool. Thanks ;)
13:58:50 <shachaf> At some point Foreign should get a new sizeOf that takes a proxy.
13:59:17 <c_wraith> Foreign hasn't been updated in ages.
13:59:30 <tasker> It seems like my array is going to be too big for my laptop :(
13:59:37 <tasker> ..by loads, actually
13:59:51 <tasker> I guess I'll have to look into some kind of sparse array
13:59:52 <c_wraith> tasker: then it's time to see if you can do what you want without storing everything in memory. :)
14:00:09 <tasker> c_wraith: The array is actually really sparse, so that is the first port of call :)
14:00:21 <tasker> or I could use my lab's cluster when no one else is..
14:00:21 <c_wraith> tasker: Data.IntMap is actually a passable sparse array
14:00:50 <ab9rf> tasker: i have an app somewhere that used a gig and a half on the first iteration, and now runs today in 35 megs. :)
14:01:04 <tasker> ab9rf: Hah, nice :D
14:01:32 <ab9rf> i have a lot of respect for conduits
14:01:33 <tasker> If it turns out to not be a stupid idea, then I will try to optimise :p
14:01:48 <ab9rf> tasker: it wasn't so much optimization as using an appropriate computational model
14:01:59 <tasker> I've been really impressed with conduits
14:02:10 <tasker> super simple to use
14:02:18 <tasker> once you stop being scared of the type signature, anyway
14:02:34 <johnw> tasker: you can have most of conduits without scary type signatures btw
14:02:41 <ab9rf> the hard part was figuring how what needed to be strict and what should be lazy
14:02:48 <Ankhers> Would anyone mind taking a look at http://lpaste.net/119909 and letting me know what I am doing wrong?
14:02:58 <tasker> johnw: With the Source/Conduit/Sink stuff ?
14:03:01 <johnw> http://hackage.haskell.org/package/simple-conduit
14:03:04 <tasker> I assumed they were just synonums
14:03:16 <ab9rf> conduit's type signatures are scary?
14:03:30 <johnw> in conduit, they are synonyms for a type that takes 6 type variables
14:03:30 <tasker> johnw: Oh, that is cool
14:03:36 <monochrom> "the last 1% accounts for 99% of the type signatures" :)
14:03:44 <johnw> in simple-conduit, a "Conduit" is just a type synonym for a function
14:03:44 <tasker> johnw: What do you miss out on?
14:04:03 <tasker> ab9rf: They are if you have no idea what you are doing...
14:04:04 <johnw> tasker: the monad instance for Source is different, no pushbacks, and no fine-grained exception control
14:04:14 <ab9rf> tasker: but i have no idea what i'm doing, and they're not scary to me
14:04:28 <ab9rf> i just do things. sometimes they work, and when they do, i'm happy
14:04:28 <johnw> but on the plus side, easier to reason about, and trivially fulfills the catgeory laws
14:04:30 <tasker> johnw: Huh, sounds like that would actually be perfect for what I'm doing so far with them.
14:04:43 <johnw> it should be perfect for 90% of what people use conduit for
14:04:50 <johnw> I've started using it myself in all projects
14:04:51 <tasker> ab9rf: I tend to not really read the type signature when it is longer than a few terms, and assume I won't be able to understand it
14:05:02 <johnw> oh, and they're naturally fast
14:05:27 <ab9rf> i don't necesasrily understand the underlying type that conduit is based on, but the main exposed types in conduit i think i understand
14:05:31 <tasker> johnw: I'll convert some webscraping stuff to try these simpler conduits :) cheers!
14:05:43 <ab9rf> i have even successfully used a monad transformer on a conduit
14:05:51 <tasker> Hah, nice
14:06:04 <tasker> I think I have used StateT on one, once
14:06:09 <ab9rf> it was stateT :)
14:06:19 <tasker> hehe
14:06:32 <tasker> my next type signature battle is with lenses ;s
14:06:42 <tasker> but I will leave that for a day when I am less ill/tired
14:06:52 <johnw> ab9rf: the underlying type is effectively a free monad which "describes" a communication between two sides of a conversation along with some actions in between; running this description (with $$) is what causes the data to flow accordingly
14:06:57 <NightRa> Can I get any GTK2hs help?
14:07:21 <ab9rf> tasker: i have yet to essay lens.
14:07:46 <NightRa> Trying to build on windows, I get: * Missing C libraries: z, cairo, * Missing C libraries: gobject-2.0, gthread-2.0, glib-2.0, intl. gtk/bin is on my path
14:07:48 <johnw> in simple-conduit, conversely, the underlying type is the Cont monad, such that the originator of the data just keeps calling the consumer until either the consumer says "stop!", or the flow of data ends
14:08:12 <ab9rf> johnw: hm, that might not actually work with some of my uses of conduit
14:08:24 <johnw> ab9rf: such as?
14:08:25 <monochrom> Ankhers: I wonder if it's simply operator precedence
14:08:51 <tasker> c_wraith: How is IntMap as a sparse array, if you are doing many many updates on it?
14:08:52 <ab9rf> i have one app, at least, that makes fairly heavy use of sequence to provide "fanout"
14:09:18 <ab9rf> not sure how that would work with a continuation approach
14:10:01 <c_wraith> tasker: really, it's just something to experiment with.  Sometimes it works quite well.
14:10:01 <johnw> ab9rf: the continuation approach (i.e., a push-based model) is what makes the fine-grained exception control impossible; but it greatly simplifies deterministic resource cleanup
14:10:10 <c_wraith> (sometimes it doesn't)
14:10:16 <tasker> c_wraith: Fair enough :)
14:10:26 <ab9rf> johnw: life is full of tradeoffs
14:10:29 <johnw> yep
14:10:35 <johnw> simple-conduit can directly use conduit Sources, btw
14:10:39 <Ankhers> monochrom: Could be, but I still don't seem to be able to figure it out.
14:10:40 <johnw> the converse is not true
14:10:40 <ab9rf> johnw: in this app i could care less about exceptions, i'm happy with it just going splat.
14:11:19 <Gurkenglas> What was the criterion for a type constructor to only have up to one Functor instance?
14:11:38 <monochrom> you should include the complete verbatim error message. I'm too lazy to install aeson and test-compile the code myself.
14:11:53 <Ally> hm
14:12:05 <Ally> how can I add two vectors to each other?
14:12:16 <Gurkenglas> Ally, are they stored as lists?
14:12:23 <Ally> add (v1:v1s) (v2:v2s) = v1+v2 + add v1s v2s?
14:12:24 <monochrom> that depends on which library the vectors come from
14:12:25 <c_wraith> Gurkenglas: that's true of all types in haskell.  They have zero or one correct instances of Functor
14:12:27 <Ally> yes
14:12:39 <cjenkin2> Ally, "add together"? Append them or pointwise addition?
14:12:42 <Gurkenglas> Ally, zipWith (+) does the job. Your implementation does too.
14:12:43 <Ally> something like add [5,3,4] [4,2,2] = [9,5,6]
14:12:47 <Ally> pointwise
14:12:52 <ab9rf> Ally: you're close
14:12:57 <cjenkin2> Ally, zipWith (+)
14:13:06 <ab9rf> Ally: your right hand side should be (v1+v2) : (add v1s v2s)
14:13:14 <joneshf-laptop> is there a standard nat type somewhere that I'm not seeing?
14:13:27 <ab9rf> Ally: you used + when you wanted :, the list constructor
14:13:28 <monochrom> no, there isn't
14:13:29 <joneshf-laptop> efficient i guess is my requirement
14:13:47 <ab9rf> Ally: youalso need to terminate the recusion by adding cases for the empty list
14:13:56 <cjenkin2> joneshf-laptop, Efficient? Efficient unary numbers? I don't think those exist
14:14:02 <ab9rf> Ally: or you can just use zipWith, which does all this work for you
14:14:10 <joneshf-laptop> poo
14:14:21 <Ally> <ab9rf> Ally: your right hand side should be (v1+v2) : (add v1s v2s) <--oh!
14:14:29 <cjenkin2> joneshf-laptop, You'd need magic runtime support for that
14:14:32 <Ally> <ab9rf> Ally: you used + when you wanted :, the list constructor <--you're right, I keep getting the types on the right side mixed up
14:14:47 <Ally> I'm still a little confused on what to put past | and all that in a lot of functions I'm making
14:15:15 <Zemyla> Unary numbers at the type level?
14:15:33 <monochrom> nat != unary
14:15:43 <Gurkenglas> joneshf-laptop, https://hackage.haskell.org/package/naturals-0.2.0.2/docs/Data-Natural.html is unary natural numbers
14:16:03 <Gurkenglas> (As in, it takes O(m*n) to multiply the nats m and n, for example)
14:16:06 <Zemyla> You could make efficient type-level binary numbers. I've done it.
14:16:07 <ab9rf> thgat paper i was reading last night on type families had a Nat thing running through it.  i can't say i really understood it.
14:16:14 <cjenkin2> monochrom, So just Ints guaranteed to be positive?
14:16:31 <monochrom> yes
14:16:57 <Gurkenglas> (Whoops, missed that + in Allys try)
14:17:00 <EvanR> Word
14:17:29 <cjenkin2> monochrom, I guess you can hack around with a private constructor and an API that does the checking for you
14:17:42 <cjenkin2> (run time checking)
14:18:11 <EvanR> its a guarantee the you wont have a negative number but its not a guarantee your program wont crash
14:18:41 <EvanR> better than continuing on with a bogus value though
14:18:43 <cjenkin2> EvanR, Couldn't your API export only Maybe's?
14:18:51 <EvanR> what would you do with the Nothing?
14:18:59 <cjenkin2> So the only way to get a Nat is inside a Maybe
14:19:00 <EvanR> especially if its supposed to be impossible
14:19:05 <cjenkin2> EvanR, Nothing, of course :)
14:19:14 <EvanR> nothing? error?
14:19:15 <Ally> <ab9rf> Ally: youalso need to terminate the recusion by adding cases for the empty list <--the base case would be something like add [] [] = 0?
14:19:25 <Gurkenglas> Also, the link I gave isn't even what I thought it is. It's apparently exactly what joneshf-laptop wanted?
14:19:30 <cjenkin2> EvanR, Don't run your program then
14:19:34 <Ankhers> monochrom: http://lpaste.net/119909 is updated with my actual type, and the two error messages I get.
14:19:39 <EvanR> always a good strategy imo
14:19:39 <ab9rf> Ally: no, that won't typecheck
14:19:57 <ab9rf> Ally: the recursive case returns a list, so the base case has to return a list too
14:20:05 <Ally> oh! can I just return []?
14:20:11 <ab9rf> Ally: indeed you can
14:20:17 <Ally> yay!
14:20:20 <Ally> sorry, I'm just getting started
14:20:23 <Ally> I really appreciate the help :D
14:20:34 <EvanR> cjenkin2: same reason why division shouldnt return a maybe, probably
14:20:47 <ab9rf> Ally: you may also want to handle the case of the lists being of different length.  or not, that's up to you.
14:21:15 <Ally> so now I have add [] [] = []
14:21:16 <monochrom> @type maybe False (==1)
14:21:16 <Ally> add (v1:v1s) (v2:v2s) = [v1+v2: add v1s v2s]
14:21:17 <lambdabot> (Num a, Eq a) => Maybe a -> Bool
14:21:19 <Ally> and add :: Vector -> Vector -> Vector
14:21:34 <ab9rf> Ally: the main thing is that all of the various cases of your function have to have the same type signature
14:21:55 <monochrom> Ankhers: (maybe False (==1) <$> (v .:? "test"))
14:22:01 <ab9rf> ally: remove the [] from the right hand side of the recursive case
14:22:35 <ab9rf> Ally: that won't typecheck, it'll be [Vector] instead Vector (assuming Vector is a typedef for Num a => [a] or something similar)
14:22:42 <Ally> oh
14:22:49 <Ally> I see, so I'm mainly having bracket issues
14:23:11 <ab9rf> the : operator creates a list, so you don't need ot put it inside brackets, that makes a list of lists.
14:23:51 <Ally> okay! that one seems great!
14:24:23 <Ally> so what if I wanted to edit it slightly to return a double, the dot product of two vectors
14:24:34 <Ally> something like dot (v1:v1s) (v2:v2s) = v1*v2 + dot v1s v2s?
14:24:42 <ab9rf> ally: the dot product is the pairwise product of the two vectors, summed.
14:24:43 <Ally> (with dot :: Vector -> Vector -> Double o'course)
14:24:51 <Ally> oh wait!
14:24:53 <Ally> same thing?
14:24:56 <Ally> I did + instead of :
14:25:13 <ab9rf> ally: that's basically correct, except you'd need a different base case
14:25:27 <ab9rf> Ally: since the dot product of two empty vectors is zero, not the empty vector
14:25:47 <ab9rf> you want +, because you're summing the list, not constructing one
14:26:06 <ab9rf> (frankly i'm amazed nobody has mentioned foldr yet)
14:26:24 <Ally> :
14:26:25 <Ally> :o*
14:26:36 <Ally> okay
14:26:45 <Ally> I see I'm getting : and + confused, and using brackets when I shouldn't
14:26:58 <Ally> thanks for helping me figure out what my issues were :D
14:29:18 <Ankhers> monochrom: New error. http://lpaste.net/119909 I think I should be able to fix it by explicitly stating the type. But I can't quite seem to figure it out.
14:30:30 <ab9rf> Ally: no problem.  when you're satisfied with your solutions, you might look up the standard functions zip, zipWith, and foldr, which basically do what you're doing by hand.  it's good to learn how to write these sorts of functions, though.
14:31:04 <monochrom> Ankhers: yes, (== (1 :: Int))
14:31:29 <Ally> ^_^
14:34:39 <ab9rf> Ankhers: that's going to yield a Bool, but you're asking to stuff that into an Integer
14:35:00 <ab9rf> the type conflict is with your record type
14:35:22 <Ankhers> ab9rf: Thanks for pointing that out. I forgot to change it...
14:36:25 <ab9rf> i'm now vaguely impressed with aeson, i haven't used it and yet i can intuit a good deal of what's going on just from looking at that code with no external context
14:36:40 <monochrom> it is a good use of Applicative
14:37:29 <ab9rf> even if the .:? operator makes me think i'm caught in a sendmail.cf file
14:38:08 <monochrom> if you have a monadic parser, then you have an applicative parser. therefore, to parse a thing into a record, you just need Ctor <$> parse_thing_for_field_1 <*> parse_thing_for_field_2 <*> ...
14:39:32 <ab9rf> monochrom: it really speaks to the expressiveness of that particular model.  i like languages and syntaxes that make obvious things obvious.
14:39:33 <monochrom> optparse-applicative is similar
14:39:49 <startling> that style is so nice.
14:39:57 <ab9rf> my toy NBT parser for minecraft files is similar.
14:40:27 <ab9rf> it's really quite small, too, the most complicated part is the stuff that converts bytestrings to floating point.
14:40:50 <monochrom> that part can't be helped :)
14:41:13 <ab9rf> monochrom: and it's rteally not that complicated, there's a library for it that i just call :)
14:41:42 <ab9rf> parseNBTFloat  = do b <- A.take 4; return $ NBTFloat  $ (runGet getFloat32be) $ BL.fromStrict b
14:42:10 <monochrom> neato
14:42:32 <ab9rf> A is attoparsec; BL is lazy bytestring
14:42:40 <ab9rf> i have strict bytestring wandering around too
14:43:24 <meretrix> Is there an easy way to "lines" on the TCP packets from a pipes-network socket?
14:43:44 <ab9rf> i think i had to use lazy bytestring because the getFloat32be thing only accepts lazy bytestrings
14:43:53 <meretrix> It seems like a common problem but a pain to write the buffering necessary to glue packets together..
14:44:59 <ab9rf> oh, that was the big key to making this code work better
14:45:34 <ab9rf> using B.copy so i wasn't carrying around unevaluated thunks with the entire uncompressed NBT structure in them
14:47:13 <ab9rf> a given chunk will typically have 30-50 kilobytes of uncompressed serialized data, and without that strictness all of those uncompressed serialized chunks would hang around until all downstream consumers were done with them
14:48:45 <Zemyla> @hoogle ByteString -> Maybe (Int32, ByteString)
14:48:46 <lambdabot> Data.ByteString.Lazy mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
14:48:46 <lambdabot> Data.ByteString mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
14:48:46 <lambdabot> Data.ByteString mapAccumR :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
14:51:40 <koala_man> what's the story behind the HTTP package being version 4000?
14:51:52 <ab9rf> 4000 is a sexy number
14:51:58 <hpc> they add a zero every version ;)
14:52:15 <koala_man> but the previous version was 3001
14:52:27 <ab9rf> hpc: that's not going to asymtoptically approach a finite value though
14:52:31 <Enigmagic> 3001 was a superior version number
14:57:49 <codygman> Why doesn't this return any matches? ((" " :: LT.Text) =~ ("^\\s.$" :: LT.Text)) :: [[LT.Text]]
14:58:05 <mwr54> Alright so I just want to confirm that I'm reading this right based on the docs
14:58:19 <ab9rf> ugh
14:58:22 <shachaf> codygman: Because the regular expression looks for two characters and the string is only one character, presumably.
14:58:22 <ab9rf> regepx.s
14:58:45 <ab9rf> yeah, " " does not match /\s./
14:58:50 <mwr54> if i create a List type in persistent, and I'm using Postgres, will it just make that column JSON and put a list in there?
14:59:58 <ab9rf> let alone /^\s.$/, that pattern recognizes two character strings where the first is a whitespace character (if \s is what i remember it being).
15:02:39 <codygman> shachaf, ab9rf: Thanks
15:02:57 <hpc> mwr54: it seems to use sqlString, whatever that is
15:03:15 <codygman> Should regex-tdfa work roughly the same as Python? I saw it was POSIX compliant but couldn't find any good documents telling me exactly what that meant.
15:03:23 <hpc> oh, it's a constructor
15:03:28 * hpc is reading the wrong thing
15:04:06 <codygman> What about this one? (("haskell" :: Text) =~ ("^\\S+$" :: Text)) :: [[Text]] -- match all non-whitespace characters from beginning to end of line
15:04:48 <hpc> codygman: have you tried it?
15:04:49 <ab9rf> i would expect that to match the entire string
15:05:13 <codygman> hpc: Yes, I get `[]`
15:05:19 <shachaf> It's funny that people turn on OverloadedStrings and then annotate their string literals with :: Text
15:05:21 <codygman> ab9rf: That's what I was expecting
15:05:22 <ab9rf> (it pretty much has to because of the lead/tail anchors)
15:05:35 <ab9rf> but i don't know what \S is in this regexp library
15:05:42 <ab9rf> i hate regexps
15:05:56 <EvanR> does it not exist, a regex library where you dont have to write your stuff as a string
15:05:56 <ab9rf> just write an attoparsec parser to recognize whatever language you need to recognize :)
15:06:09 <hpc> or use perl
15:06:26 <hpc> "perl-compatible" regexes in other languages...
15:06:26 <hpc> well
15:06:27 <hpc> aren't
15:06:39 <ab9rf> hpc: and they're a giant quagmire
15:06:47 <hpc> yeah
15:06:53 <codygman> ab9rf, hpc: I wrote a quick one off script to count the number of times emails were duplicated in a log/json/html file but had to use grep for extracting emails. I want to do it with Haskell via regex or any other quick method.
15:06:57 <ab9rf> you can use pcres to test for primality, althoughj doing so is INSANELY slow
15:07:08 <hpc> javascript is the only other language that's even close with regex power
15:07:17 <hpc> it doesn't have any blatant stupidities i have encountered
15:07:21 <hpc> and it has // syntax
15:07:39 <hpc> (but not =~ which is very annoying)
15:08:40 <ab9rf> codygman: "use grep for extracting emails"?  are you just trying to filter a logfile for certain lines that meet a specified criterion?
15:09:34 <ab9rf> my advice would be to use conduit with a source that generates by the line, a filter that accepts only the lines you want, and then a sink that does whatever counting or whatever
15:10:23 <codygman> ab9rf: A file with lots of crap in it also happens to have emails. I want to extract those emails. I don't care so much about the how to stream/put into list, just about a quick easy way to extract patterns from mixed text
15:11:13 <danilo2> Hello! I'm trying to create a distributed computing environment (many workers, many clients, task queue etc). I would love to ask you - what is the status of cloud haskell? Is it mature enough, so I can trust it and blindly use it or should I stay with 0mq if my time to investigate bugs (or missbehaviours in library) is very limited?
15:11:26 <Eolus> oh cod
15:12:38 <ab9rf> codygman: you can recognize lines with relevant data in one conduit stage, then extract in the next, or you can combine the two.  either way i'd be thinking attoparsec
15:14:01 <codygman> ab9rf: I feel like extracting an email with attoparsec would be rather verbose. I'm also not sure how I'd say ignore everything except this pattern in a given line. This is after a cursory glance at: https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/attoparsec
15:14:36 <ab9rf> codygman: by 'extracting an email' dyou mean an email address or an entire email?
15:15:01 * hackagebot eventstore 0.7.0.0 - EventStore TCP Client  http://hackage.haskell.org/package/eventstore-0.7.0.0 (YorickLaupa)
15:15:43 <codygman> ab9rf: an email address
15:16:32 <codygman> I want to extract email addresses out of arbitrary log files (sometimes json, sometimes html, sometimes xml, etc) and count how many times each email from that document appears. I already did the second part once I have a stream or list of emails.
15:17:52 <codygman> How can I make my "" default to text? For instance in ghci if I type `:t ""` I'd like it to return `"" :: Text`
15:18:41 <mwr54> codygman: You could always force it with type inference
15:19:02 <mwr54> Like, use it with a function that takes Text, not sure if you can default it though
15:19:25 <ansible1> you can do it this way I think:
15:19:26 <ansible1> let a = "" :: Text
15:19:30 <monochrom> modify GHC to default to Text.
15:19:52 <pacak> If you are using OverloadedStrings and avoid getting IsString instance for [Char] into your scope that might work.
15:20:02 <codygman> monochrom: Aww, I was hoping that "ExtendedDefaultRules" had something to do with that
15:20:11 <ab9rf> codygman: i'd write an attoparsec parser that recognizes an email
15:20:20 <monochrom> I think it may help. I haven't really checked.
15:20:32 <monochrom>  <-- not keen on defaulting
15:20:36 <ab9rf> codygman: then compose that with skipMany in front, and call it repeatedly until it fails.  it will generate one email address per call
15:20:41 <pacak> Usually just OverloadedStrings is enough as long as you have function that takes string.
15:21:15 <enthropy> ifIsInstance :: IsInstance c t => Proxy c -> (c t => t -> r) -> r -> r -- is this the best argument order?
15:21:20 <ab9rf> an attoParsec result of Done contains the remaining unparsed data so you can just call it again on the tail
15:21:28 <codygman> ab9rf: The problem is I'd like a way to quickly solve problems of extracting patterns like this. I'm going to try to write the attoparsec parser, but I feel like that'll be a rather heavyweight solution for < 15 min scripts.
15:21:46 <ab9rf> codygman: attoparsec is not heavyweight, it's really easy to write attoparsec parsers
15:21:58 <ab9rf> and certainly lighter than the annoying complexity of regexps
15:22:28 <ab9rf> i still don't know why people think of regexps as "simple"
15:22:42 <ab9rf> they're simple until they're not and then they're a RIGHT ROYAL PAIN IN THE ASS
15:23:39 <pacak> ab9rf: A parser for email? That might be more difficult than you expect. Regexp for email looks like this: http://www.ex-parrot.com/pdw/Mail-RFC822-Address.html
15:24:12 <ab9rf> pacak: you can probably get close enough for horseshoes without much trouble
15:24:32 <codygman> ab9rf: Yeah, I don't like regexps either... but that was a quick solution using other languages and I know them fairly well.
15:24:59 <Hijiri> I thought the point of that regexp was to show that regexps are the wrong solution and it would be easier to use something else?
15:25:10 <Hijiri> for email addresses, I mean
15:25:15 <ab9rf> hell, just string-of-nonwhitespace @ string-of-whitespace will do the job
15:25:21 <ab9rf> and that's a trivial parser to write
15:25:30 <ab9rf> er string of nonwhitespace on both sides of @
15:26:25 <ab9rf> you will match some things that aren't emails, but implementing the exact RFC822 spec would be hdieous and pointless as most of the options in that spec are never used anymore anyway
15:26:55 <ab9rf> bang paths, :@ routing, % routing
15:27:17 <hpc> also many of those things no longer even work
15:27:35 <ab9rf> explicitly disallowed or simply no longer implemented, yes
15:27:44 <hpc> try using an email address of <your_email(blahblah)@domain.com>
15:28:04 <codygman> ab9rf: lol, the thing is... I just wanted to replace python for quick simple scripts when coworkers ask "hey can you tell me how many of x are in this document"
15:28:07 <hpc> it's valid, but a crapshoot if anything will actually recognize it as an email
15:28:26 <ab9rf> i used to have a UUCP node
15:28:33 <ab9rf> my email address had bangs in it
15:30:12 <codygman> ab9rf: non witespace "@" non whitespace will also match the crap on the sides of the emails I don't want though won't it? For instance it'd fail on this string  `>>> example@example.com <<<` by returning the entire thing
15:30:41 <arw_> then the 'non-whitespace'-part is broken
15:30:44 <ab9rf> codygman: no, it won't return the <<< >>> because there's whitespace
15:31:13 <ab9rf> if there isn't whitespace, then you'll have to rely on a leading alpha, but not all emails start with an alpha (some start with digits, even though that's technically wrong)
15:31:49 <ab9rf> logparsing is a pita
15:32:20 <Enigmagic> ab9rf: rfc 822 has been dead for quite a long time, at least for most of us.
15:32:33 <codygman> ab9rf: what about: `>>>example@example.com<<<`... hmm so there's no way to extract emails out of arbitrary content then? this regex worked with grep for example: "\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,6}\b"
15:32:57 <hpc> codygman: not good enough still
15:33:00 <arw_> codygman: correct, there isn't a sane way. the localpart may contain lots of stuff.
15:33:02 <hpc> missing "=" on the left
15:33:19 <hpc> just from 5 seconds of looking
15:34:03 <arw_> and the domain part does not have to contain a dot, and it may end in a dot.
15:34:15 <hpc> arw_: wut
15:34:19 <arw_> and there are tlds longer than 6 characters.
15:34:39 <hpc> oh, and there are TLDs with hypens
15:34:41 <arw_> hpc: trailing dot is for the root zone, to anchor your domain name to a tld.
15:34:57 <ab9rf> there are even tlds with double hyphens
15:35:11 <hpc> that's what i was referring to
15:35:18 <arw_> hpc: and the domain part may be partial, in case you want to deliver to some hostname in your local search part.
15:35:25 <arw_> search path
15:35:31 <ab9rf> the punycode encoding of some of the nonlatin TLDs are quite long indeed
15:35:41 <codygman> I'm not validating emails though really, more I was counting "email like strings" which even if a little off was useful. There was an error related to an email that was duplicated a lot through a certain logfile.
15:35:55 <arw_> hpc: oh, and there are even some weird TLDs that have an A and MX dns entry, so they can accept mail
15:36:15 <lenovo> Hello
15:36:19 <adam_hardkey_shi> Does someone have an example instance for the TypeClass HasTime in NetWire?
15:36:32 <hpc> for a good time, look up how spamassassin detects email addresses
15:37:02 <lenovo> map (10*) [1..100]
15:37:11 <ab9rf> i would assume that an emaila ddress contains an @, has arbitrary crpa befor the @, and has something hostname-shaped after the @ (which means alpha/num/-/.)
15:37:34 <hpc> SA has a regex just for matching TLDs
15:37:41 <ab9rf> about the only thing you can be fairly certain of is that there's no whitespace
15:37:41 <hpc> it's 4183 characters, and structured as a trie
15:37:45 <lenovo> > map (10*) [1.10]
15:37:46 <lambdabot>  [11.0]
15:37:54 <lenovo> > map (10*) [1..10]
15:37:55 <lambdabot>  [10,20,30,40,50,60,70,80,90,100]
15:38:01 <codygman> hpc: Whoa, that is insane
15:38:03 <c_wraith> doesn't the email spec allow quoted whitespace inside a valid email?
15:38:08 <ab9rf> hpc: haha
15:38:19 <ab9rf> c_wraith: probably, but nobody actually does that.
15:38:30 <hpc> i helped try to get rid of it
15:38:35 <arw_> c_wraith: you mean inside the localpart? i think only in encoded form. but i'm not sure
15:38:39 <hpc> people complained that it's necessary and used in places
15:38:40 <ab9rf> c_wraith: the spec allows all sorts of things that never happen in the wild and are genreally not allowed anyhow
15:38:45 <hpc> turns out it was, and really damn hard to remove
15:38:56 <hpc> so instead there's a shell script that does wget against the official TLD list
15:39:19 <ab9rf> i think microsoft exchange did allow that in early versions
15:39:31 <ab9rf> microsoft is fond of local identifiers having spaces
15:39:49 <arw_> C:\Program Files ;)
15:40:15 <ab9rf> arw_: and literally everywhere in active directory, which means security identifiers are full of them
15:40:19 <hpc> extra credit: C:\Program Files (x86)
15:40:31 <ab9rf> "Domain Administrators@domain.local"
15:40:38 <hpc> it's got the unholy trinity of whitespace, parens, and backslash
15:40:52 <hpc> extra credit for colon, which means something different after a drive letter or after a file name
15:41:17 <Lokathor> fun fact, if you compile a vty program without threaded support, it'll totally mess up your terminal when it crashes :P
15:41:39 <ab9rf> hpc: microsoft has enough hysterical raisins to fill an entire fruity asylum
15:42:04 <hpc> bonus fun fact, the XOR operation in LDAP is a numeric literal
15:42:11 <hpc> it's longer than maxBound :: Word64
15:42:50 <ab9rf> i don't remember there being an xor operation in ldap but i'll take your word for it :)
15:43:19 <hpc> it's...
15:43:22 <danilo2> Hello! I'm trying to create a distributed computing environment (many workers, many clients, task queue etc). I would love to ask you - what is the status of cloud haskell? Is it mature enough, so I can trust it and blindly use it or should I stay with 0mq if my time to investigate bugs (or missbehaviours in library) is very limited?
15:43:26 <arw_> ab9rf: theres a whole kindergarten full of different string types in LDAP...
15:43:30 <hpc> (support.microsoft.com is being slow)
15:43:56 <ab9rf> arw_: i do remember that.  it's been a few yeras since i did ldap work at that level
15:44:16 <hpc> oh, i was entirely wrong
15:44:26 <hpc> "The string 1.2.840.113556.1.4.803 specifies LDAP_MATCHING_RULE_BIT_AND. This specifies a bitwise AND of a flag attribute"
15:44:30 <hpc> http://social.technet.microsoft.com/wiki/contents/articles/5392.active-directory-ldap-syntax-filters.aspx?Sort=MostUseful&PageIndex=1
15:44:53 <ab9rf> hpc: i was aware of those idiotic oids
15:45:09 <ab9rf> i've used them although not lately
15:45:20 <ab9rf> there isn't one for XOR as far as i know
15:45:32 <monochrom> xkcd numbers are better than these ID's
15:45:39 <hpc> yeah, i was misremembering
15:46:24 <hpc> #16 on the page is amazing too
15:46:43 <ab9rf> i spent a month or so setting up SNMP monitoring at one employuer, and got utterly tired at looking at long incomprehensible strings of digits in SNMP OIDs
15:47:23 <ab9rf> hpc: haha, is that why security identifiers are all negative!
15:47:26 <arw_> that reminds me, my "if I have 2 months on a lonely island" project, kerberos in haskell...: https://lists.debian.org/debian-security-announce/2015/msg00036.html
15:48:00 <ab9rf> hpc: i noticed long ago that security identifiers were all negative, but had no idea as to why.
15:48:48 <hpc> oh god, i forgot about #8 too
15:48:49 <ab9rf> if adsiedit showed attribute values in hex i would likely have spotted it much faster
15:48:52 <hpc> GUIDs </3
15:49:19 <ab9rf> but i'm not good at manually spotting bits in 32-bit numnbers expressed in decimal especially signed decimal
15:51:09 <ab9rf> i've only got powers of two memorized up to 2^20, after all
15:51:20 <hpc> > 2**20
15:51:21 <lambdabot>  1048576.0
15:51:27 <hpc> uh
15:51:37 <hpc> i don't know that many :P
15:52:02 <ab9rf> i sometimes get 2^19 wrong
15:52:17 <monochrom> I am only up to 2^16
15:52:31 <hpc> i sometimes take the xkcd route with powers of two
15:52:38 <monochrom> but my excuse is that I grew up with at most 16-bit addresses
15:52:42 <ab9rf> monochrom: same here
15:52:46 <hpc> similarly to verifying pgp messages
15:52:48 <arw_> ack. at 128k I start adding up 2*65536...
15:52:54 <hpc> "is it divisible by two? eh good enough"
15:52:59 <ab9rf> hehe
15:53:10 <koomi> danilo2: cloud haskell is not mature at all, I doubt anyone has used it for anything serious
15:53:20 <hpc> http://www.xkcd.com/1181/
15:53:34 <danilo2> koomi: sad to hear that :(
15:54:22 <Enigmagic> danilo2: neither is courier
15:54:52 <danilo2> Enigmagic: courier?
15:55:04 <Enigmagic> @hackage courier
15:55:04 <lambdabot> http://hackage.haskell.org/package/courier
15:55:18 <Enigmagic> just in case you were looking for alternatives ;-)
15:56:25 <danilo2> Enigmagic: oh, this courier. Hmm, I wonder why the developer of courier does not join the forces of cloud haskell in such situation
15:57:16 <codygman> I made a simple attoparsec parser and managed to extract one value, but I'm not sure how to extract multiple: http://lpaste.net/119916
15:57:39 <Enigmagic> codygman: Control.Applicative.many ?
15:59:41 <codygman> Enigmagic: Thanks, I'll try to use it
16:01:32 <codygman> Enigmagic: Indeed it was, parseOnly (many findNumbers) "#3\n#4". I used parse instead of parseOnly and got "Partial _"... that seems interesting, but maybe confusing.
16:04:08 <Hijiri> that's because when you use parse, you don't know if you're out of input yet
16:04:18 <Hijiri> since many x could continue getting more values if they exist
16:04:31 <Hijiri> but if you're only parsing a single value, you're done once you have it
16:04:46 <Hijiri> parseOnly tells the parser that there is no more input except what is given
16:05:39 <sinnsat> I wonder if there are bindings for C parsers. I think even attoparsec cannot compete with C-style parsing or I am doing something wrong.
16:06:17 <hpc> you mean like yacc?
16:06:42 <hpc> because i would sooner use spring framework than deal with that again
16:07:04 <Hijiri> happy is sort of like a yacc, right? not that I've ever used either
16:07:19 <hpc> it is
16:07:40 <hpc> i think happy is somewhat saved by haskell being friendlier to having many tiny code blocks
16:07:45 <hpc> but i wouldn't use it either
16:08:07 <Enigmagic> sinnsat: what are you parsing
16:08:23 <sinnsat> Enigmagic: .obj mesh files
16:08:44 <Enigmagic> sinnsat: have you tried binary or cereal first?
16:09:04 <sinnsat> probably not
16:09:32 <sinnsat> in C I wrote my own parser... it's still like 3 times faster than anything I've done with attoparsec
16:10:30 <sinnsat> and completely non-abstract ofc
16:11:23 <sinnsat> lazy bytestring/parsing didn't help either
16:12:47 <Profpatsch> How do I import all fields of a datatype with record syntax?
16:12:59 <sinnsat> (..) I think
16:13:05 <Profpatsch> import Network.Socket ( AddrInfo(..) ) ?
16:13:19 <Profpatsch> Ha, works!
16:13:22 <Profpatsch> thx!
16:13:41 <Profpatsch> This is missing from https://wiki.haskell.org/Import
16:15:03 * hackagebot gl 0.7.2 - Complete OpenGL raw bindings  http://hackage.haskell.org/package/gl-0.7.2 (EdwardKmett)
16:18:25 <lenovo> Who was I talking to earlier ?
16:41:28 <ab9rf> i've used happy
16:41:36 <ab9rf> i have about 90% of a PHP grammer in happy + alex actually
16:42:45 <ab9rf> it needs work, mainly because i haven't decided on an IR
16:50:15 <joneshf-laptop> hmm, there's no `Eq` instance for `Parsec` is there a reason for that?
16:51:25 <prophile> joneshf-laptop: because Parsec is a newtype around a function
16:51:31 <prophile> and there's no sensible Eq in general for ->
16:51:35 <pacak> joneshf-laptop: Because Parsec is a monad transformer other than data?
16:52:48 <joneshf-laptop> sorry
16:52:53 <enthropy> any sensible way to get ghc to deduce C (Either a b) given (C a, C b)?
16:52:53 <joneshf-laptop> for `ParseError`
16:53:47 <enthropy> probably nobody has needed Eq ParseError
16:54:52 <joneshf-laptop> hmm, then maybe I'm going about this wrong
16:54:56 <joneshf-laptop> how do you test a parser?
16:54:58 <c_wraith> enthropy: I believe GHC is simply unwilling to make that assumption.
16:55:04 * hackagebot trifecta 1.5.1.2 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-1.5.1.2 (EdwardKmett)
16:55:13 <Lokathor> aeson can't decode "100" into a (Number 100), it just decodes Nothing
16:55:14 <Lokathor> how sad
16:55:23 <prophile> joneshf-laptop: run it against known inputs and test it produces known outputs
16:55:26 <c_wraith> enthropy: (It allows you to write an instance for Either that's different than the natural one)
16:55:41 <c_wraith> Lokathor: there are other decoding functions that are less spec-centric
16:56:00 <c_wraith> Lokathor: since the original JSON spec required the top-level value to be an object or array
16:56:03 <joneshf-laptop> prophile, right, but don't I need an equality test for that?
16:56:09 <Lokathor> ah
16:56:11 <Lokathor> hmm
16:56:34 <prophile> joneshf-laptop: yes, an Eq on what's parsed, not on the parser itself
16:57:27 <joneshf-laptop> prophile, the result is an `Either ParseError a`
16:57:55 <prophile> right, not a Parsec
16:58:00 <c_wraith> Lokathor: see https://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson-Parser.html#v:value
16:58:01 <prophile> you're concerned about the lack of an Eq on ParseError?
16:58:15 <joneshf-laptop> prophile, yeah, I mixed up the types earlier
16:58:40 <prophile> yeah, that is a bit odd
16:59:41 <prophile> if you're testing valid inputs you can do something like case (blah) of { Left _ -> False; Right result -> result == expectedResult }
16:59:41 <mpickering> Is there a good way to test API bindings?
16:59:52 <prophile> mpickering: as in FFI things?
17:00:00 <mpickering> as in a web API
17:00:15 <deech> I'd like to install my executable components into a subdirectory of ~/.cabal/bin. Is there a Cabal file the sets the install directory?
17:00:20 <prophile> various web APIs have "mock" versions you can install
17:00:25 <prophile> I think the twitter web API has this for instance
17:00:29 <joneshf-laptop> prophile, yeah, I guess that's a possibility. That or just have an orphan
17:00:40 <prophile> I wouldn't recommend that
17:01:02 <enthropy> c_wraith: the actual problem is I have a "instance (Show a, Show b) => IsInstance Show (Either a b)" but that doesn't work nicely (I get Show constraints coming up too early)
17:01:07 <joneshf-laptop> prophile, an orphan for testing?
17:01:13 <prophile> yeah
17:01:15 <joneshf-laptop> okay, now I'm really confused: https://github.com/aslatter/parsec/pull/14
17:01:18 <joneshf-laptop> that added the instance
17:01:22 <joneshf-laptop> but it's not in the latest release
17:01:28 <enthropy> so if I could write   instance (IsInstance Show a, IsInstance Show b) => IsInstance Show (Either a b), I think it would work properly
17:01:30 <joneshf-laptop> or haddock for that matter
17:01:31 <prophile> was the latest release after that?
17:01:31 <mpickering> I guess the problem is that I don't want to put an API key in the tests
17:01:34 <c_wraith> enthropy: I know nothing about IsInstance
17:01:48 <prophile> mpickering: you could skip those tests unless an API key is provided
17:01:52 <Axman6> deech: won;t that make executing them more diifficult? you'd need to modify your PATH to include the subdir
17:01:58 <joneshf-laptop> 3.1.8 was jan 10
17:02:00 <Sornaensis> can anyone tell me what this means: “Bad Interface file: /usr/lib/ghc-7.8.4/base-4.7.0.2/Prelude.hi mismatched interface file versions (wanted "7083", got "7084")”
17:02:05 <joneshf-laptop> commit was nov something
17:02:07 <enthropy> c_wraith: http://lpaste.net/119917
17:02:19 <prophile> Travis supports encrypted bits and pieces so you can still have tests run there with the API key
17:02:41 <deech> Axman6: They're examples, and I didn't want to pollute user's bin directory with them ...
17:04:12 <enthropy> which is roughly some template haskell automating/generalizing the ShowPred in https://wiki.haskell.org/GHC/AdvancedOverlap
17:05:29 <asdaiojsd> is there a good article/paper that discusses functors in depth in terms of design, application and category theory?
17:06:01 <mpickering> prophile: Perfect thanks
17:06:21 <prophile> mpickering: np]
17:06:30 <Axman6> asdaiojsd: they're not a particularly complex topic really (though I don't know the CT side of things, that may be more interesting)
17:06:52 <Lokathor> c_wraith: I want to be able to convert "100" or "\"foo\"" or "{\"bar\":12}" into a Value, because the resulting Value will be later stuck into a top level object
17:07:04 <Lokathor> it seems... i'll need to write a custom parser for this task?
17:07:06 <asdaiojsd> Axman6: would you say its a good idea to start from the CT side then?
17:07:30 <Axman6> their design is almost always quite obvious when looking at any type
17:07:36 <Lokathor> or is that what value is saying it does
17:07:50 <Axman6> most people have no need to ever look at the CT side because they're so simple
17:08:48 <asdaiojsd> Axman6: yeah but I'm looking for undestanding of things such as when to use a functor, how to generalize them etc
17:09:33 <gregnwosu> does cabal init create Setup.hs
17:10:05 <Enigmagic> Sornaensis: sounds like you're using ghc 7.8.3 but it's reading interface files from 7.8.4?
17:10:48 <c_wraith> Lokathor: the parser already exists..
17:11:07 <c_wraith> Lokathor: it's the one I mentioned above.
17:11:08 <Lokathor> you mean the one, value :: Parser Value
17:11:12 <c_wraith> yes
17:11:24 <Lokathor> oh sorry, didn't see that there was an anchor on that URL
17:18:21 <joneshf-laptop> geez, so using the primitives of parsec, you can get the `Message` out, but there's no show instance for a `Message`
17:18:42 <joneshf-laptop> i'm fighting this api too much
17:18:49 <joneshf-laptop> any thoughts on trifecta?
17:19:06 <edwardk> joneshf-laptop: i'm rather partial to it
17:19:13 <joneshf-laptop> :)
17:19:31 <edwardk> another option is to write to the 'parsers' API then choose backends later
17:19:34 <joneshf-laptop> does it have a better testing situation than parsec?
17:19:53 <edwardk> what do you want to test?
17:20:16 <edwardk> parsers can be run on a bunch of different backends, attoparsec, parsec, trifecta, readp, etc.
17:20:23 <Profpatsch> Okay, how to use a where clause over multiple pattern-matches? oO
17:20:25 <Profpatsch> https://bigmac.caelum.uberspace.de/paste/where.hs.html
17:20:26 <joneshf-laptop> i want to feed a string to a parser and make sure it's coming out with what i expect
17:20:41 <edwardk> so parse, get an ADT, and look at it ;)
17:20:43 <joneshf-laptop> just writing some unit tests
17:20:45 <Profpatsch> hex is only valid in the second pattern.
17:21:04 <edwardk> you can do that in a unit test in both
17:21:05 <joneshf-laptop> right, but parsec is missing instances left and right
17:21:07 <LordBrain> i think a fun tool for making parsers is bnfc, it may not fit your needs tho
17:21:08 <edwardk> sure
17:21:10 <Profpatsch> But that makes not much sense, since it’s the same function. oO
17:21:26 <edwardk> trifecta should _not_ be lacking instances, if it is for something in its dependencies anywhere i'd say that is a bug
17:21:37 <edwardk> parsec is a much more mixed bag
17:21:47 <joneshf-laptop> alright, i'll give it a whirl
17:21:49 <joneshf-laptop> thanks
17:22:04 <edwardk> i happen to be hacking on trifecta right at this very moment, so let me know if you run into issues
17:22:28 <joneshf-laptop> k
17:24:06 <LordBrain> is there an already written lbnf for haskell?
17:24:52 <bitemyapp> LordBrain: EBNF?
17:25:01 <ClaudiusMaximus> Profpatsch: nope.  where binds to the definition, and the pattern matches on the left of the = are in scope.  what would you want where to do with   f False x = g ; f x [] = g ; where g = x
17:25:28 <LordBrain> labeled bnf, its what bnfc uses
17:26:03 <LordBrain> https://svn.spraakdata.gu.se/clt/bnfc/document/LBNF-report.pdf
17:26:17 <benzrf> hmm
17:26:19 <bitemyapp> oh interesting
17:26:27 <ClaudiusMaximus> Profpatsch: you could use a case expression so you have one definition to bind to
17:26:41 <bitemyapp> LordBrain: your name reminds me of a game I loved on the SNES when I was a kid.
17:26:42 <benzrf> is there some kind of library or technique for safely and/or atomically altering a critical file
17:26:51 <bitemyapp> benzrf: MVar?
17:26:58 <benzrf> no, like
17:27:03 <benzrf> filesystem
17:27:05 <benzrf> let me step back
17:27:07 <bitemyapp> MVar
17:27:11 * bitemyapp grins toothily
17:27:23 <hpc> pretty much nothing is atomic in the filesystem
17:27:32 <benzrf> =[
17:27:36 <benzrf> ok
17:27:36 <bitemyapp> atomicity and mutex must be in-application
17:27:39 <hpc> but there's a lot of locking conventions
17:27:44 <bitemyapp> you can track it via lock-file metadata if you need cross-process mutex
17:27:46 <benzrf> im thinking about writing a frontend for configuring and interacting with cjdns
17:27:48 <hpc> .lock files, FS-specific flags, etc
17:27:48 <bitemyapp> but if you can stay in process, MVar.
17:28:01 <bitemyapp> my recommendation: try to stay in process.
17:28:02 <n0n3such> ok quick question: what is the haskell 'value proposition' ? Why should someone learn/use haskell ?
17:28:07 <benzrf> afaik the only way to deal with it is thru a json config file
17:28:13 <hpc> n0n3such: it makes you a better programmer
17:28:18 <benzrf> and if i write this, priority 1 is DON'T BREAK SHIT
17:28:19 <joneshf-laptop> edwardk, so http://hackage.haskell.org/package/trifecta-1.5.1.1/docs/Text-Trifecta-Result.html#g:1 doesn't have an `Eq` instance, when I want to test that a parse came out right what are my options here?
17:28:19 <Lokathor> c_wraith: the value parser seems to be unable to parse numbers, though it can parse stand alone strings for example
17:28:27 <bitemyapp> benzrf: welp.
17:28:31 <joneshf-laptop> bitemyapp, Brain Lord?
17:28:32 <n0n3such> hpc where better means ?
17:28:45 <bitemyapp> joneshf-laptop: yissss
17:28:48 <bitemyapp> benzrf: https://hackage.haskell.org/package/lock-file-0.5.0.0/candidate/docs/System-IO-LockFile.html
17:28:53 <joneshf-laptop> bitemyapp, :)
17:28:55 <bitemyapp> benzrf: https://hackage.haskell.org/package/filelock-0.1.0.0/docs/System-FileLock.html
17:28:58 <joneshf-laptop> bitemyapp, that was a fun game
17:29:11 <bitemyapp> joneshf-laptop: it was like a puzzlier/more RPG'ish Legend of Zelda.
17:29:13 <bitemyapp> joneshf-laptop: I adored it.
17:29:15 <hpc> being able to form more specific thoughts, understand more complex concepts, notice more edge cases, etc
17:29:23 <benzrf> bitemyapp: hmmmm
17:29:35 <bitemyapp> benzrf: https://github.com/trskop/lock-file-resourcet
17:29:56 <edwardk> joneshf-laptop: I can't compare Doc's for Eq. you can convert it down to an Either
17:30:01 <bitemyapp> benzrf: part of the problem with cross-process file locking is that "fairness" is hard to enforce.
17:30:02 <n0n3such> hpc: so does this translate to quality, productivity or some other standard measure ?
17:30:12 <edwardk> joneshf-laptop: the docs can change their formatting based on column width
17:30:35 <hpc> yes
17:30:48 <edwardk> it is easy enough to convert to an Either String   by rendering the Doc though
17:31:15 <n0n3such> hpc so you would assert that haskell programs are higher quality than others, and haskell programmers more productive than others ?
17:31:57 <edwardk> joneshf-laptop: but such an instance wouldn't be sound in general. the Doc's have functions in them for computing layout by line length.
17:31:58 <LordBrain> bitemyapp, it's cool because bnfc generates a parser and haskell AST, or if you give it different switches you can get for example a java parser, or a c one.. That multilingual aspect probably makes it a lot more upkeep, but it means make one langauge spec and have generated parsers in different platforms.. Nice excuse for having something prettier than xml or s-expressions.
17:33:15 <n0n3such> hpc compared (say) to clojure or scala programs/programmers ?
17:33:42 <hpc> i would say you're comparing the wrong thing there
17:33:50 <hpc> it's not "this programmer of X vs this programmer of Y"
17:34:06 <hpc> it's "this programmer knowing X" vs "the same programmer knowing X and Y"
17:34:42 <hpc> haskell needs to be part of a balanced breakfast
17:35:17 <hpc> it's like a banana
17:35:20 <joneshf-laptop> edwardk, I see
17:35:32 <ab9rf> just don't attempt to put a burrito inside the banana peel
17:35:34 <ab9rf> that never works out well
17:36:25 <n0n3such> hpc so you would assert that (say) a clojure programmer that also wrote haskell would produce higher quality code and be more productive than a clojure programmer with no exposure to haskell ?
17:36:32 <hpc> 100% yes
17:37:20 <n0n3such> hpc but would you assert that a haskell programmer who didn't know clojure would product lower quality code and be less productive than one who knew both ?
17:37:41 <ab9rf> n0n3such: learning haskell will improve one's skill in writing powershell and java code.
17:37:41 <bitemyapp> wtf banana
17:37:53 <bitemyapp> I'm going to take the contrary argument
17:37:56 <n0n3such> ab9rf: as would clojure
17:38:04 <bitemyapp> learning Haskell probably won't improve your Clojure that much in most cases.
17:38:06 <ab9rf> n0n3such: i can't say with clojure because i don't know clojure
17:38:08 <edwardk> n0n3such: in a lot of ways the benefit flows down from the language where users get used to playing with more complicated types, because they get benefit of learning to think in terms of those abstractions
17:38:17 <bitemyapp> in fact, it'll probably just make you pissed that you don't get to write Haskell.
17:38:20 <LordBrain> i do not know clojure
17:38:21 <hpc> clojure is just a lisp
17:38:24 <LordBrain> is it functional?
17:38:27 <bitemyapp> the primary benefit from having learnt Haskell won't be in your code looking different
17:38:28 <hpc> n0n3such: also yes
17:38:35 <edwardk> n0n3such: a lot of haskellers learn a lot from playing around in agda or coq or idris, because the type system there can express things the haskellers can't say or can't say nicely in haskell
17:38:36 <bitemyapp> LordBrain: relatively speaking, but by our standards, not particularly.
17:38:50 <bitemyapp> so your code will look the same, but Haskell will teach you to think in a denser encoding than "code"
17:39:00 <ab9rf> hpc: so i'm told, but as  don't know it i can say that learning haskell has had no impact on my ability to write good clojure code :)
17:39:13 <hpc> n0n3such: less so, because of the relationship between the concepts at play in lisp-likes and ML-likes but the effect is still there
17:39:16 <n0n3such> ab9rf: lol
17:39:22 <bitemyapp> I don't think learning Haskell changed my Clojure code, it just made me aware that using Clojure was silly.
17:39:31 <bitemyapp> OTOH, it did teach me to think in terms of types
17:39:31 <ab9rf> bitemyapp: hehe
17:39:38 <hpc> bitemyapp: that's the main thing
17:39:43 <bitemyapp> which isn't nothing, but yeah, it didn't mean using monads in Clojure suddenly made sense. It doesn't and it won't.
17:39:47 <edwardk> n0n3such: that said, i think folks in the haskell community _have_ learned a fair bit from the erlang community which is also 'untyped' in that sense. we keep stealing techniques for how to coordinate lots of little distributed processes, etc. from their toolbox
17:39:47 <hpc> haskell improved my perl considerably
17:39:49 <bitemyapp> "in terms of types"
17:39:56 <bitemyapp> nobody appreciates me :(
17:40:06 <bitemyapp> edwardk: v good example
17:40:06 <edwardk> n0n3such: and we've stolen things like HashMap from the Clojure approach of using HAMTs
17:40:16 <hpc> bitemyapp: in types of terms?
17:40:18 <edwardk> n0n3such: so there is some cross-pollination
17:40:37 <bitemyapp> edwardk: does Hashable still need fixed?
17:41:51 <n0n3such> so rather than assert that learning haskell results in higher quality code and higher productivity it might be more meaningful to assert that learning a 'different' language will enhance the conceptual toolkit you bring to problem solving in general and that learning haskell for a clojure programmer is equivalent in value to learning clojure for a haskell programmer ?
17:42:00 <hpc> yes
17:42:07 <bitemyapp> n0n3such: yes except for the "equivalent" part.
17:42:09 <edwardk> bitemyapp: not sure i follow
17:42:20 <hpc> it depends on the 'different'
17:42:25 <LordBrain> hmm part of haskell's benefit is the ecosystem, you end up learning a little category theory, a little type theory... it has a tendency to eventually turn programmers into computer scientists.
17:42:26 <bitemyapp> edwardk: you'd said back at BayHac that Hashable was lumpy.
17:42:38 <ab9rf> a good programmer has lots of tools in the toolbox
17:42:40 <bitemyapp> LordBrain: which won't happen in Clojure.
17:42:40 <n0n3such> LordBrain: true also of scala
17:42:40 <ab9rf> haskell is a tool
17:42:43 <hpc> learning 5 similar languages is not terribly expansive of the mind
17:43:00 <hpc> but learning haskell, clojure, scala, c, perl
17:43:01 <n0n3such> so let me cut to the chase
17:43:07 <hpc> is a pretty damn broad base of concepts
17:43:10 <edwardk> n0n3such: honestly i do think the benefit there is asymmetric. a lot more power seems to be won on the heavily typed side in terms of informing your code in languages with less to over on the type side
17:43:12 <ab9rf> prolog!
17:43:15 * ab9rf giggles
17:43:18 <n0n3such> i have spent the last 2 years learning and using scala and i'm looking to pick up another language
17:43:22 <hpc> ppsh, prolog is just a type system
17:43:28 <n0n3such> my choices are haskell and clojure
17:43:37 <hpc> n0n3such: pick up both
17:43:44 <ab9rf> people should learn SQL too
17:43:45 <n0n3such> haskell seems more similar to scala than clojure
17:43:48 <hpc> oh man, SQL
17:43:56 <n0n3such> therefore clojure seems the best candidate
17:44:07 <bitemyapp> n0n3such: the experience of writing Haskell is profoundly different from Scala or Clojure.
17:44:07 <ab9rf> or some other declarative language but really SQL is the headliner in that category
17:44:09 <hpc> haskell is very different
17:44:16 <edwardk> n0n3such: funny i was going to say quite the opposite. learning haskell will show you how a screen full of scala can be written in a few lines of haskell ;)
17:44:18 <bitemyapp> n0n3such: Scala is more similar to Clojure than Haskell.
17:44:20 * hpc regrets not knowing scala yet, actually
17:44:27 <bitemyapp> hpc: don't bother, if you can help it.
17:44:27 <tnks> n0n3such: learn Haskell.
17:44:38 <ab9rf> edwardk: yeah, that's why i never spent much time with scala
17:44:53 <hpc> so i have heard, but i do want to know what their pseudo-dependent type thingy for inheritance is
17:44:58 <n0n3such> scala was a great learning experience for me coming from C
17:45:08 <n0n3such> :)
17:45:10 <bitemyapp> hpc: path dependent types aren't interesting.
17:45:12 <LordBrain> i havent messed with scala, but i have been tempted while working on android apps
17:45:18 <edwardk> ab9rf: there are benefits, you can get scala easily into the enterprise, java interop, etc. but you give up a lot to get those benefits
17:45:18 <hpc> ah, k
17:45:23 <bitemyapp> hpc: they're also not dependent types.
17:45:24 <ab9rf> scala seems like "for when you have to use the JVM but don't want to have to put up with java and are not insane enough to use JRuby"
17:45:31 <sinnsat> edwardk: LOC doesn't necessarily tell me something about the understandability of the code, so I don't really get why people love these one-liners so much
17:45:41 <n0n3such> scala/akka are actually very nice
17:45:45 <hpc> bitemyapp: that i knew, but they had some surface similarities in the explanation i read
17:45:51 <edwardk> sinnsat: honestly i'm not talking about the one liners so much as i'm talking about reducing noise in types
17:45:51 <n0n3such> as you were speaking of erlang ...
17:45:54 <bitemyapp> hpc: if you really want to stretch your legs, learn Coq/Agda/Idris if you haven't already.
17:45:59 <ab9rf> edwardk: yeah, i've come to the conclision that scala's main benefit is interop with the java ecosystem
17:46:01 <hpc> i know agda
17:46:01 <edwardk> having rank-n types for instance
17:46:24 <n0n3such> bitemyapp: that sounds like biting off (no pun intended) a bit too much for this old fella atm
17:46:30 <hpc> i should learn coq because it's so different
17:46:34 <hpc> but eh
17:46:43 <bitemyapp> n0n3such: I was talking to hpc. You should learn Haskell first.
17:46:45 <sinnsat> edwardk: I am just saying that I have seen a lot of one-liners that do so much implicit things that it's incredibly hard to follow what is going on under the hood... in haskell. I think it's a debatable thing.
17:46:55 <edwardk> n0n3such: knowing akka gives you a lot of the understanding of what the erlang style message passing is about. erlang gives you a representation that is easier to upgrade via hot-swapping code
17:46:57 <ab9rf> one of the reasons i like haskell is that it is an anodyne to one of the things i see in so many other languages that annoys me so much
17:47:06 <hpc> n0n3such: but yeah, learn haskell so you have a language in the ML family
17:47:16 <n0n3such> edwardk: perhaps but akka has a nice supervisory system too
17:47:17 <ab9rf> the unwillingness of programmers to create a type for a single purpose i a program
17:47:18 <hpc> n0n3such: and learn clojure so you have a language in the lisp family
17:47:24 <n0n3such> so hot-swapping isn't really useful
17:47:33 <ab9rf> in haskell, this is taken for granted.  create types! have at it! make all the types ytou want!  use more!
17:47:47 <edwardk> sinnsat: i think the penchant for golfing is something we as a community picked up from the rather large number of perl users who came into #haskell from #perl via pugs.
17:47:51 <hpc> they're totally different frames of mind, built around a lot of the same theory
17:47:54 <ab9rf> in java, php, perl, there's a heck of a lot of incentive against creating throwaway types
17:48:12 <hpc> edwardk: it was there before
17:48:14 <ab9rf> in java, classes are ridiculously heavy with all sorts of baggage
17:48:58 <edwardk> n0n3such: i know erlang systems that have been up and serving without service interruption for many years, by using the hot-swap bits, it takes a lot more careful engineering to do that with just the supervisory side of the coin.
17:49:00 <hpc> it's just fun to golf in haskell because of how /possible/ it is, with the wrinkle of fighting against the layout syntax
17:49:40 <n0n3such> edwardk: that is not a real benefit for most systems
17:49:41 <mniip> the list monad lets you do all kinds of fancy iterations
17:49:49 <edwardk> n0n3such: erlang exploits its lack of type system to make it easier to hot-swap code, and its relative paucity of internal data types to make it easy to take the errors you get out of a process that fails fast and pick up and result the computation
17:49:57 <ab9rf> in php, i see people constantly doing crazy stuff with ad hoc dictionaries and such not, and doing wild stuff with brnaching based on the dynamic type of a variable which is horribly difficult to maintain
17:49:58 <edwardk> n0n3such: sure. i tend to err on the benefit of types side myself
17:50:04 <n0n3such> edwardk: the lifetime of a product these days is shorter than the lifetime of a erlang hot-swap
17:50:06 <exio4> n0n3such: it lets you think problems in a "different way"
17:50:22 <exio4> that's the main point, I'd say
17:50:37 <ab9rf> haskell doesn't make you burn a lot of energy to make a new type
17:50:38 <n0n3such> edwardk: the lifetime of a software product today is less than the life-time of an erlang hot-swap
17:50:49 <bitemyapp> ab9rf: GND hooooo
17:50:49 <ab9rf> it encourages you to use the RIGHT type for everything
17:51:00 <edwardk> i was giving the reason why the erlang folks have some claim to a better distribution story than others due to properties of the language. full process isolation, single process copy-collection for better responsiveness, the hot-swap machinery, are all quite powerful. not powerful enough i'm keen to give up my haskell types, but they are compelling
17:51:00 <edwardk> advantages
17:51:11 <edwardk> n0n3such: that is sadly very true
17:51:37 <ab9rf> bitemyapp: ?
17:51:37 <n0n3such> exio4: please explain
17:52:16 <edwardk> n0n3such: My respect for erlang comes from having been on the 'keeping things up at a telecom' side, and having gone with Siemens, not Ericsson for the phone switch. ;)
17:52:53 <ab9rf> erlang is really interesting, but i haven't had a personal use case for it yet
17:53:13 <n0n3such> edwardk: yeah i looked at erlang and akka took a lot from it but the choice between scala/akka and erlang is easy :)
17:53:20 <edwardk> akka does a pretty good job of raiding as many benefits from the erlang toolbox as it can within the confines of scala
17:53:33 <exio4> n0n3such: just like learning to think in terms of high-order functions instead of objects helps you model problems (in your mind) in a different way than you did before
17:53:52 <n0n3such> exio4: you're talking haskell vv clojure ?
17:54:08 <exio4> no, I am talking about new paradigms and different abstractions for solving the same problem
17:54:10 <n0n3such> because scala supports higher-order functions etc too
17:54:11 <exio4> it was an example
17:54:21 <edwardk> Anyways, i'm going to go disengage from the 'why is programming language X better than programming language Y' debate, as i find they tend to be disruptive and not terribly productive.
17:54:50 <n0n3such> what benefits will learning haskell bring that further study of scala can't ?
17:54:59 <tnks> n0n3such: that's a good question.
17:55:02 <tnks> tons really.
17:55:09 <tnks> Scala makes FP seem tedious.
17:55:14 <exio4> lazy evaluation! purity!
17:55:24 <exio4> burritos! I mean, monads!
17:55:57 <ab9rf> tnks: that, i think, is because it derives in part from java, and java can make ANYTHING seem tedious
17:56:07 <edwardk> n0n3such: http://www.reddit.com/r/haskell/comments/1pjjy5/odersky_the_trouble_with_types_strange_loop_2013/cd3bgcu summarizes my opinion of the pain points of scala to a haskeller
17:56:14 <bananagram> I like burritoes and monads for about the same reason
17:56:15 <tnks> ab9rf: sure, there's probably lots of justifications
17:56:25 <sinnsat> I think there should be more research/teaching about how to write understandable (not elegant, quality or performant) code. I don't know of many references. Does anyone have one for haskell?
17:56:32 <n0n3such> edwardk: bookmarked ty
17:56:51 <edwardk> i wrote it in a hurry a year back to answer a direct question to me, and a couple of points have since been partially addressed, but its a window into my innermost thoughts on the topic
17:57:45 <edwardk> n0n3such: ultimately things like Monads don't actually encode in scala very well, you have to choose between blowing the stack on non-toy problems or accepting a trampolining solution that makes mockery of the laws while simultaneously running 50x slower.
17:58:23 <edwardk> to a haskeller, something like a Monad is pretty fundamental, to most Scala developers they are a curiosity, for a good reason.
17:59:25 <edwardk> sinnsat: the closest i can come to that is to say you should read a bunch of stuff by Richard Bird.
17:59:39 <n0n3such> so to summarize ? why haskell instead of clojure as a new language for a scala programmer ?
17:59:49 <edwardk> Richard Bird's "Pearls of Functional Algorithm Design" is the best guide to how to "think" like a haskeller.
17:59:58 <n0n3such> right i have it
18:00:01 <tnks> edwardk: what do you mean by "mockery of the laws"?
18:00:16 <tnks> are some laws irreparably broken in Scalaz?
18:00:26 <edwardk> tnks: you can count flatMap's by reading Bind constructors the Free[Function0, _] solutions
18:00:30 <Axman6> n0n3such: a nicer type system and much stricter avoidance of unsafe things like mutation would be, imo, good reasons to use haskell
18:00:42 <edwardk> tnks: notice the unsafe operations to race IO actions
18:01:02 <edwardk> tnks: those shouldn't be able to exist, they don't sync up at delays, but rather at every flatMap.
18:01:19 <n0n3such> Axman6: but will those things help me be more productive and produce more reliable code ?
18:01:27 <Axman6> absolutely
18:01:40 <edwardk> tnks: since the trampoline is the only way to actually write a monad that doesn't destroy your stack, this makes me deeply unsettled.
18:01:50 <n0n3such> ok, so why is haskell not more widely adopted for product development ?
18:01:58 <ab9rf> personally, i think the discipline regarding side effects that haskell forces will teach a lot of people to be ebtter coders
18:02:07 <edwardk> n0n3such: because it doesn't run on the JVM and has a complicated interop story
18:02:12 <Axman6> a strong type system lets you find bugs sooner, and a lack of (or really controlled) side effects will make bugs harder to write in the first place
18:02:13 <platz> n0n3such: I believe both clojure and haskell have very similar concepts of transactional references (vars/mvars) and STM (refs/tvars)
18:02:20 <edwardk> n0n3such: and it requires you to program in a very different manner
18:02:26 <ab9rf> i know that smoe of the thorniest bugs i've debugged in actual C code have been due to tangled messes of interacting side effects
18:02:39 <tnks> yeah, I think it's the latter more than the former.
18:02:56 <edwardk> ok, disengaging on the language debate for real this time.
18:02:58 <meoblast001> oh god i'm forgetting pattern matching again
18:03:57 <LordBrain> i'd like a lowlevel haskell, i know there have been several low level functional languages, but it would be nice if haskell itself could fill that niche
18:04:12 <n0n3such> Axman6: scala brings those same benefits when used with skill
18:04:55 <LordBrain> in fact, it would be nice to basically be assembler but you could add as much of it as you want to eventually get full blown ghc
18:05:14 <Axman6> n0n3such: scala does many things that haskell does elegantly in a very ugly, less well thought out way, imo.
18:05:33 <n0n3such> edwardk: i think the real story is that folks in industry realize how hard it would be to staff a haskell project, maintain, support and enhance it etc
18:05:44 <edwardk> n0n3such: def test = diff(new FF[Id,Id,Double] {  def apply[S[_]](x: AD[S, Double])(implicit mode: Mode[S, Double]): AD[S, Double] = cos(x) }) -- is a little bit noisier than the Haskell equivalent: test = diff cos
18:05:50 <n0n3such> Axman6: ok i can see that
18:05:59 <Axman6> my personal impressions of scala, probably unfairly, are that it looks like someone's school project to try and do what haskell does but they couldn't figure out how to do things properly
18:06:00 <n0n3such> but in return it brings a different meld of capabilities
18:06:33 <n0n3such> Axman6: you now intrigue me lol
18:06:53 <edwardk> n0n3such: there is an element of truth in the fact that "nobody ever got fired for picking Java" and scala inherits some of that shield.
18:07:52 <n0n3such> edwardk: ok, so lets say i have a startup and i am writing a software product that i hope to build fast company growth around
18:08:20 <tnks> n0n3such: talent can be found or trained.
18:08:22 <n0n3such> its going to be hard to staff it with haskell devs and keep 'em interested over the entire product lifecycle
18:08:28 <LordBrain> i think who you know makes a difference, if all your friends are haskellers why would you want to use java?
18:08:30 <tnks> you just have to draw from a different pool.
18:08:52 <edwardk> n0n3such: there is actually a rather huge supply of mid-level haskell talent these days to keep such an enterprise going.
18:09:19 <n0n3such> perhaps but how many haskell devs want to maintain a product over its entire lifecycle instead of working on new projects ?
18:09:25 <tnks> n0n3such: I do.
18:09:28 <Welkin> I have a funny story
18:09:37 <tnks> as do the two others on my team.
18:09:38 <LordBrain> there's no official numbers, but there is some unscientific evidence that haskell gets quite a lot of use
18:09:44 <edwardk> i know a couple of startups in exactly that boat that are happily employing 10-20 haskellers each in the new york area, more in singapore, a lot more on the west coast, etc. Larger scale? Standard Chartered has a pretty decent sized Haskell team. We here at McGraw Hill Financial have a few, etc.
18:09:50 <LordBrain> take the size of this room for example
18:09:54 <tnks> it's not hard to find people that care about code in general.
18:10:05 <n0n3such> tnks and the minute i get left in the lurch my company has a hard time replacing you
18:10:08 * hackagebot scholdoc-types 0.1.3.1 - Scholdoc fork of pandoc-types  http://hackage.haskell.org/package/scholdoc-types-0.1.3.1 (timtylin)
18:10:11 <Welkin> I just went to a career fair at my university today, and when I talked to a representative from motorola, he said "What's Haskell? Is it object-oriented? We only use Java"
18:10:16 <Axman6> n0n3such: have a look at http://code.haskell.org/~dons/talks/dons-google-2015-01-27.pdf to see how Standard Chartered are using Haskell in a large number of systems to very good effect, allowing them to move very quickly in development with low risk
18:10:17 <LordBrain> 1510, not bad, now join scala and tell me how big that room is >:D
18:10:32 <tnks> n0n3such: it's not that hard. . . I found talent within a month when hiring.
18:10:33 <n0n3such> Axman6: i read the Standard Charted article
18:10:40 <edwardk> n0n3such: The team we have here has been here "maintaining code" for ~5 years now. ;)
18:10:40 <tnks> I'd hire more, but we have a freeze.
18:10:59 <edwardk> n0n3such: It has had some churn, but not out of line with any organizational structure.
18:11:07 <tnks> n0n3such: if you haven't /tried/ to find talent, it seems wildly presumptuous to make these claims.
18:11:10 <n0n3such> I can train a java coder to maintain a scala project in a few weeks
18:11:25 <n0n3such> how long would it take to train a haskell mid-level coder to do that ?
18:11:49 <platz> some folks at the new york times were using haskell in data visualization projects
18:11:53 <n0n3such> tnks: flattery will get you nowhere :)
18:11:56 <LordBrain> i don't know, my impression is haskellers generally already know c
18:12:04 <Welkin> I can;t seem to find any companies even using haskell beyond small pet projects (like at facebook, microsoft, google, etc.)
18:12:11 <edwardk> to cross-train haskell to scala? is generally pretty easy. almost everyone has the baseline java/c style language skills.
18:12:13 <tnks> n0n3such: first off, I've seen the way java developers "maintain" Scala. . . it's not pretty.
18:12:15 <Welkin> none using it as a primary tool
18:12:23 <edwardk> unlike the java folks they'd be comfortable with all the higher order function bits though
18:12:26 <tnks> I think you're downplaying the hidden cost of rework.
18:12:34 <edwardk> so you get more concise scala and can leverage scalaz and the like out of the gate
18:12:35 <Axman6> edwardk: where are you working again? you aren't also at SC are you?
18:12:36 <sinnsat> n0n3such: it will take incredibly longer, yes. But I'd argue that you waste less money long-term, because you use haskell.
18:13:04 <edwardk> Axman6: nah, i'm at McGraw Hill Financial with sclv, dolio, mizu_no_oto, joshcough, S11001001, etc.
18:13:14 <n0n3such> sinnsat: company lifecycles in this industry are short, by design
18:13:26 <Axman6> that's right. I keep thinking McGraw Hill is a publishing house =)
18:14:06 <sinnsat> n0n3such: then I don't understand you. First you are talking about long-term projects...
18:14:08 <n0n3such> so for those of you who know scala and haskell how would you compare the learning curves ?
18:14:08 <Welkin> it is
18:14:16 <edwardk> Axman6: That is part of why they split up the company into two completely separate entities a couple years back, MHF vs. MHE.
18:14:29 <Axman6> E = ?
18:14:33 <n0n3such> sinnsat: long term is from a 'twinkle in the eye' to a sale to Google
18:14:33 <Welkin> Education?
18:14:47 <tnks> n0n3such: "learning Haskell" can lead to something far more consistent than "learning Scala"
18:14:50 <n0n3such> if it takes more than 3 years its a failure
18:14:56 <edwardk> n0n3such: well, within 2 weeks of starting scala i started finding compiler bugs that still aren't fixed, so your mileage may vary on how high you can climb the curve ;)
18:15:08 * hackagebot scholdoc-texmath 0.1.0.1 - Scholdoc fork of texmath  http://hackage.haskell.org/package/scholdoc-texmath-0.1.0.1 (timtylin)
18:15:08 <Axman6> n0n3such: I guess C++ is a pretty big failure then
18:15:09 <Welkin> google/microsoft/apple/facebook/amazon buy companies every week for $10-30 million
18:15:11 <platz> n0n3such: if all you care about is initial time to market and have no need of maintenance, or performance concerns, i would suggest ruby, but even the most conservative companies won't pick ruby due to "difficulty hiring"
18:15:20 <edwardk> damnit, i was really going to disengage on the language front
18:15:28 <Axman6> (yes, it is in many ways, but that doesn't mean it's not being used successfully)
18:15:44 <tnks> n0n3such: people can and do solve these problems you're talking about.
18:15:50 <tnks> I think that's the most important point.
18:15:52 <n0n3such> platz: i am coming from the perspective of someone who learned scala cold while developing a fairly complicated product
18:16:14 <n0n3such> and i found the learning curve steep but the gains worth it over 12 months of activity
18:16:22 <LordBrain> if it is hard to get haskellers, then i guess everyone here is basically employed and/or unavailable?
18:16:36 <benzrf> LordBrain: im not employed
18:16:42 <LordBrain> me neither
18:16:48 <Welkin> LordBrain: I can't find any haskell positions that aren't in europe
18:16:50 <LordBrain> so there goes that theory
18:16:54 <n0n3such> with haskell i imagine the actual learning curve is steeper
18:16:57 <edwardk> benzrf: um, aren't you still in high school?
18:17:06 <benzrf> edwardk: :^)
18:17:23 <edwardk> benzrf: i seem to recall there being restrictions on how many hours you can work at your age ;)
18:17:27 <LordBrain> well, i want a place in florida, and i havent found that
18:17:36 * Axman6 uses Haskell in Australia
18:17:51 <mizu_no_oto> n0n3such: As a Java programmer, you can start writing java-ish code in Scala faster than you could learn Haskell.  Going from Java to haskellish scala or actual haskell is probably similar
18:17:52 <benzrf> pfft, ill be 18 in about 2 weeks
18:17:54 <n0n3such> tnks so your first choice for a development language in a fast paced startup environment would be haskell ?
18:18:05 <Welkin> n0n3such: it is my first choice
18:18:10 <n0n3such> mizu_no_oto: i went from C to scala. never learned java
18:18:10 <edwardk> benzrf: fair nuff
18:18:17 <acomar> benzrf: did you apply for the position at fp complete?
18:18:22 <Welkin> I used it to build my application
18:18:23 <benzrf> acomar: n-no
18:18:28 <tnks> n0n3such: yes. . . but in a "fast paced startup" you probably want to have some experts -- regardless of your platform choice.
18:18:29 <benzrf> i have no resume
18:18:34 <Welkin> I built it faster and better than I did with python
18:18:46 <edwardk> my rule of thumb when starting a "fast paced startup" is to hire experts anyways.
18:18:58 <platz> n0n3such: I'm not sure it's that steeper.  One doesn't need to go into the research topics.  There are many many nooks in scala that take a lot of time, and I think the same 12 months would get you to mid-level haskell too
18:19:10 <ab9rf> yoeah, you do not want tyros at a startup
18:19:13 <ab9rf> at least not at first
18:19:19 <mizu_no_oto> Saying that there are many nooks in Scala is a bit of an understatement
18:19:27 <acomar> benzrf: oh, didn't realize you were in high school. take a look at the various haskell industry groups and reach out to the companies on the list to see if any are willing to offer an internship.
18:19:44 <platz> n0n3such: maybe there's more 'fish-out-water' feeling with haskell, but on a pure time basis, i'm not sure it takes more time
18:19:56 <benzrf> acomar: im in maine :\
18:20:00 <edwardk> benzrf: you can probably snag an internship somewhere
18:20:21 <Welkin> it's unlikely you'll get an internship using haskell
18:20:32 <acomar> benzrf: you generally fly to the company for an internship. I went to college in Indiana but did an internship in Boston for example.
18:20:33 <Welkin> it more likely it will be python/ruby/c++
18:20:38 <benzrf> acomar: hrf
18:20:39 <LordBrain> it is easier and more likely to produce nice readable haskell than most other languages, so you really get a pay off in terms of maintenance.
18:21:21 <LordBrain> obviously, if one is out to create a counter example to that, they can...
18:21:46 <edwardk> well, benzrf has picked up an awful lot of haskell (and surprisingly some category theory) in the time he's been around here, he can probably make a good case for himself, if he can mellow out enough to get through the interview ;)
18:22:26 <edwardk> benzrf: college plans?
18:22:48 <n0n3such> edwardk: the best
18:22:52 <Welkin> benzrf: don't bother trying to find a job writing haskell, just write haskell regardless
18:23:14 <Welkin> writing in haskell for a shitty company is worse than writing any other language for a good company
18:23:27 <n0n3such> edwardk: the best 'fast paced startups' are composed of 2 or 3 committed believers, not hired guns
18:23:41 <tnks> Welkin: are there lots of shitty companies using Haskell?
18:23:48 <tnks> I'm not sure I've seen too much of that.
18:23:52 <icbm> Just get enough material on yoru resume that you can detect and say no to the shitty companies.
18:23:56 <Welkin> tnks: no, I can;t seem to find any companies at all
18:24:00 <Welkin> well, there is soostone
18:24:01 <edwardk> n0n3such: sure. i just have a pretty good supply of committed believers around here i can find that can also kick ass at haskell, so i have the luxury of not having to choose. ;)
18:24:05 <Welkin> but that place looks shady
18:24:24 <benzrf> edwardk: yeah probs
18:24:25 <n0n3such> edwardk: here ?
18:25:05 <tnks> Welkin: are you looking?
18:25:13 <sinnsat> I find this business/money talk depressing. I write haskell, because it is fun.
18:25:14 <Welkin> yes
18:25:21 <tnks> where you at?
18:25:26 <Welkin> the US
18:25:29 <edwardk> benzrf: ping me later
18:25:31 <tnks> sorry, I mean city.
18:25:36 <Welkin> I'm looking all over
18:25:42 <benzrf> edwardk: what for?
18:25:44 <tnks> remote-only?
18:25:47 <platz> Welkin: I might suggest not being too picky about language makes sense when older, but not sure when younger - might make sense to experiment more when it's easier
18:25:53 <Welkin> most of the companies I'm interested in seem to be in San Francisco/SV
18:26:05 <Welkin> I've given up on finding a haskell position
18:26:21 <Welkin> it looks like it's python/ruby/c++ for me
18:26:50 <icbm> There are worse languages than python or ruby.  Like C++.
18:27:18 <n0n3such> dunno that is a hard call icbm
18:27:23 <tnks> Welkin: I think the landscape is changing, but it feels recent to me.
18:27:31 <n0n3such> i think python is worse
18:27:31 <edwardk> sinnsat: I write haskell because it happens to be the language I've found in which I can write reusable code that I can build on top of without refactoring it constantly. I write Haskell for code reuse. I write Haskell because it is the best supply of abstractions I know that don't leak. I write Haskell because I can rely on the code working if it compiles.
18:27:31 <edwardk> I write Haskell because the community here is ridiculously nice and patient with newcomers. It also happens that I can make a living at it, which is nice, but it isn't the 'why'. ;)
18:28:21 <sinnsat> edwardk: that was very verbose, but I agree basically
18:28:30 <MP2E> there's a lot to love!
18:28:30 <benzrf> edwardk: do you have that on copy/paste
18:28:32 <MP2E> :P
18:28:39 <Welkin> I will continue to write haskell even if it never makes me a dime
18:28:42 <n0n3such> sinnsat: i am very goal oriented. i want to learn languages that allow me to be maximally productive while fun
18:28:43 <MP2E> ^
18:28:47 <MP2E> er @ welkin :P
18:28:49 <edwardk> benzrf: no, just wrote it on a very long line and it was cut up by my client.
18:28:56 <Welkin> even though it has already made money for me through one of my applications
18:29:01 <icbm> True story, I was offered a Haskell job once, and I turned it down to write Visual Basic 6 for a big company, because I was so remarkably stupid.
18:29:20 <MP2E> icbm: Well, did you know much Haskell back then? :P
18:29:24 <benzrf> edwardk: well, ive seen you say almost exactly the same things before so i was just wondering if you had that prewritten for pasting to ppl who ask
18:29:28 <tnks> I think the market is openning up. . . I'd like to see what we can do to push that along.
18:29:28 <MP2E> I can understand if it was just 'some weird language you'd heard of once'
18:29:33 <MP2E> hehe
18:29:43 <MP2E> That actually encapsulated my opinion of Haskell until I learned it :X
18:29:48 <edwardk> benzrf: nah, probably should though. =)
18:29:50 <icbm> MP2E: Just the basics. I thought it was a dead-end academic language. Like I said, stupid.
18:29:54 <MP2E> Ah
18:30:01 <MP2E> I haev a friend stuck in that rut unfortunately
18:30:05 <MP2E> he took an FP class but didn't learn any IO :P
18:30:11 <MP2E> so he thinks it's all 'useless'
18:30:16 <sinnsat> n0n3such: I don't know how you measure productiveness. If it's about amount of bugs, then you might be disappointed by haskell, because you usually have less. :P
18:30:22 <edwardk> icbm: if it was more than 7 years ago or so, then at the time it pretty much was.
18:30:56 <n0n3such> sinnsat: productive as in 'take an idea to market as quickly as possible' while ensuring reliability and maintainability and quality of code
18:31:05 <Welkin> I don't understand why Go is being picked up so readily instead of a better and more mature language like Haskell
18:31:08 <edwardk> Real World Haskell and having cabal/hackage really went a _long_ way towards demonstrating the viability of Haskell and making it possible for folks to collaborate.
18:31:10 <Welkin> or at the very least Ocaml
18:31:11 <MP2E> edwardk: I'm curious now, it was mostly useless 7 years ago? Is that because code gen wasn't fast enough? Not all of the nice abstrctions we have today found yet?
18:31:11 <icbm> edwardk: It was in 2001 or 2002, and it was a random number generation project that my CS prof was doing.
18:31:31 <sinnsat> n0n3such: those are conflicting goals. Your priority is not clear
18:31:42 <n0n3such> sinnsat: i disagree
18:31:45 <MP2E> ah cabal and RWH
18:31:51 <edwardk> MP2E: without cabal it was hard to build on other people's code. without RWH few people thought about how to do systems-y things in haskell at all, so we didn't have a good culture of interop
18:32:09 <MP2E> ohh that makes sense
18:32:11 <sinnsat> n0n3such: if you write software as quickly as possible... it will most likely not be of very high quality
18:32:21 <n0n3such> sinnsat: when you are building companies there are a lot of different things you have to balance
18:32:26 <Welkin> I would say LYAH is also very valuable with regard to the growth of the community
18:32:41 <n0n3such> sinnsat: getting to market with a viable product first is essential
18:32:44 <Welkin> that is how I first came to it, because LYAH made it look fun
18:32:46 <edwardk> MP2E: for all that we have 'cabal hell' we have it because we have so many people pouring code into the library ecosystem, and we have very fine grained packages compared to almost every other language out there.
18:32:53 <tnks> n0n3such: it's not conflicting, but people that think Scala is faster than Haskell at this are often cutting huge corners in reliability, maintainability, and quality in general.
18:33:09 <bitemyapp> Welkin: not the best way to learn, though.
18:33:09 <tnks> faster time-to-market, I mean.
18:33:18 <Welkin> bitemyapp: yes, but it was my gateway
18:33:18 <n0n3such> tnks i've found scala to have a nice balance here
18:33:20 <Welkin> so it has value
18:33:21 * dcoutts_ has been teaching haskell to professional programmers all day
18:33:23 <bitemyapp> tnks: I'm not sold on even flawed TTM either.
18:33:33 <edwardk> Welkin: LYAH did a lot to help sell the language to the masses. That and dons' work on getting Haskell to start putting up a respectable fight in all the language shootouts that were popular around 2008.
18:33:42 <edwardk> dcoutts++
18:33:57 <bitemyapp> dcoutts_ leads me to believe I should stop doing this for free :)
18:33:59 <tnks> n0n3such: Haskell's story is fine.
18:34:07 <edwardk> ^- Duncan and Austin have been in New York teaching Haskell classes
18:34:14 <tnks> but it does help to have some help bootstrapping learning.
18:34:19 <bergmark> it's interesting to consider that all version conflicts in cabal is a potential runtime failure with node.js/npm
18:34:24 <dcoutts_> bitemyapp: ah well I also do it for free
18:34:26 <edwardk> and apparently my mention of cabal summoned the genie
18:34:33 <dcoutts_> hah
18:34:34 <n0n3such> tnks in my experience if the product architecture has been though out scala can result in fast time-to-market reliable and maintainable code
18:34:38 <MP2E> haha
18:34:39 <n0n3such> thought*
18:34:46 <bitemyapp> dcoutts_: I've been paid to write Haskell, but not to teach it. Not yet.
18:34:52 <edwardk> dcoutts_: we really need to work on your business acumen ;)
18:34:54 <sinnsat> edwardk: I found LYAH too verbose, I started with the haskell course of Brent Yorgey half a year ago or so
18:34:58 <bitemyapp> dcoutts_: sounds lovely though.
18:35:03 <tnks> n0n3such: what you're not talking about, is you're bias towards Scala has a /lot/ of bias towards hiring people that want to code in a way that's familiar.
18:35:04 <bitemyapp> I like teaching this stuff.
18:35:19 <bitemyapp> tnks: your
18:35:34 <edwardk> sinnsat: LYAH is very enthusiastic and very verbose, it is more like _why's poignant guide to Ruby than to a normal tutorial. it doesn't get very far, but it gets there with a whole lot of enthusiasm
18:35:36 <tnks> bitemyapp: sure -- I'm bad about that
18:35:42 <n0n3such> tnks i don't think i'm biased. i'm looking to learn another language while i polish the scala chops and considering haskell or clojure
18:35:55 <dcoutts_> edwardk: "the first one is free", I thought that was standard practice from dealers to consultants :-)
18:35:59 <edwardk> I mean you really have to consider that when Miran wrote LYAH I think he was a freshman in college, so there is a lot of enthusiasm there, but not a whole lot of meat.
18:36:02 <bitemyapp> n0n3such: roll a die, 1-3 Clojure, 4-6 Haskell
18:36:05 <bitemyapp> n0n3such: you're wasting time.
18:36:09 <tnks> n0n3such: maybe you're not personally, but this hypothetical argument about staffing a fast-paced startup or whatever.
18:36:09 <bitemyapp> n0n3such: pick something and get to work.
18:36:19 <bergmark> pick both and get to work?
18:36:20 <edwardk> dcoutts_: hah
18:36:24 <n0n3such> bitemyapp: just did that with scala
18:36:26 <bitemyapp> bergmark: yeah but which first?
18:36:31 <bergmark> roll a die :-)
18:36:32 <bitemyapp> bergmark: that's their whole spiel.
18:36:36 <bitemyapp> bergmark: see that's my point
18:36:41 <dcoutts_> bergmark: yes, it often brings forward the interface mismatches
18:36:43 <bergmark> that's why i quoted you :P
18:36:48 <bitemyapp> bergmark: your point about Cabal vs. npm is well made. I wish more understood it.
18:37:26 <n0n3such> bitemyapp: the thing about clojure is that the clojure community seems less erm 'formally inclined' than haskell
18:37:31 <edwardk> bergmark: my approach to API design is typically to try out both. it is faster to do that usually than to debate about best practices for style =P
18:37:50 <n0n3such> it looks like a lot of the interesting things in haskell are interesting for theoretical reasons, not practical ones
18:37:51 <bergmark> edwardk: i remember you saying that before :-)
18:37:52 <bitemyapp> n0n3such: k, but you could be learning something right now
18:38:01 <bitemyapp> n0n3such: I used to write Clojure professionally, now I do only Haskell.
18:38:02 <bramgg> How can I get the contents of a handle without closing the handle? I create a process with System.Process's "createProcess" and bind the output to "hout" similar to this example: http://stackoverflow.com/a/7589314, but when I get the output with "hGetContents" (System.IO) it closes it and I can't get the contents again! This is frusturating because I want to continuously enter input and get output.
18:38:08 <n0n3such> i am bitemyapp, i am canvassing opinion :)
18:38:15 <bitemyapp> n0n3such: consider that my vote but your time would be profitably spent if it was spent *learning*
18:38:22 <bitemyapp> n0n3such: why not gather data and form your own opinion?
18:38:26 <n0n3such> i am learning now bitemyapp
18:38:26 <bitemyapp> n0n3such: start learning. Chop chop.
18:38:29 <bitemyapp> no you're not
18:38:32 <bitemyapp> you're shooting the shit
18:38:37 <n0n3such> bitemyapp: chop chop just finished my 12 hours
18:38:44 <sinnsat> n0n3such: example for something in haskell that is only theoretically interesting, but has no practical use?
18:38:52 <bitemyapp> it's not the hours, it's what you put in them.
18:38:55 <n0n3such> bitemyapp: why did you pick a name like that anyways lol
18:38:59 <edwardk> bramg: hGetContents grabs the whole shebang. hGetLine will just get you a line, etc.
18:39:16 <platz> n0n3such: If you're interested in clojure you'll eventually want to learn some haskell anyway.  Many clojure contributors know Haskell too and borrow those ideas.. it's probably just a matter of ordering which to learn first
18:39:25 <n0n3such> bitemyapp: your attitude is getting obnoxious my friend. you don't know anything about me, my history, my skills or my grandkids
18:39:26 <Welkin> that's funny
18:39:32 <Welkin> I originally wanted to learn clojure
18:39:40 <Welkin> then I experienced the jvm and jumped to haskell
18:39:42 <bitemyapp> Welkin: LOL
18:39:50 <n0n3such> sinnsat: category theoretic meanderings
18:39:59 <sinnsat> n0n3such: they have practical use.
18:40:11 <edwardk> n0n3such: funny. they've proven quite useful to me
18:40:13 <n0n3such> well sure, after you take 12 years to learn them
18:40:17 <bitemyapp> n0n3such: category theory informs some of the nicest, most broadly useful Haskell libraries I use
18:41:00 <bitemyapp> Doesn't take 12 years unless you spend all that time in IRC.
18:41:09 <sinnsat> n0n3such: in order to use concepts in haskell that come from category theory, you don't necessarily have to understand them on the formal mathematical level
18:41:11 <n0n3such> bitemyapp: that is all well and good and intellectually stimilulating but does it help you get product out the door ?
18:41:20 <tnks> n0n3such: yeah.
18:41:24 <bitemyapp> n0n3such: does for my work, yes.
18:41:27 <edwardk> n0n3such: i was 'gainfully' using category theory in haskell within a few months to find out that 'oh, i don't have to keep looking for other cases over there, they are impossible', it has proven a great way to stop wondering about the world of types and start drawing deep insights into what is really possible
18:41:27 <mgsloan> good news is that you don't need to know category theory to use these useful libraries.  Instead you can just be thankful their design rests upon firm foundations
18:41:51 <ab9rf> yeah, you don't need to know structural analysis to live in a house, either :)
18:42:14 <n0n3such> edwardk: example ?
18:42:16 <edwardk> n0n3such: i'd argue the lens library has done more for haskell productivity than almost anything, and well, the way we figured it all out was through category theory
18:42:33 <n0n3such> practical example ?
18:42:49 <sdegutis> Can someone please show me a Haskell file with excellent code in it? I'd like to see what good Haskell looks like.
18:42:52 <ab9rf> i still need to learn lens
18:42:59 <platz> look at clojure vars, refs, test.check, reducers, etc...
18:43:01 <Welkin> sdegutis: look at the source for base
18:43:09 <ab9rf> i have a grasp on type families now at least
18:43:09 <Welkin> it has a lot of comments
18:43:21 <sdegutis> I was hoping to look at something more third party.
18:43:27 <benzrf> sdegutis: pipes is OK
18:43:32 <bramgg> Sorry realize my long question might be intimidating, basically want to get the output of a handle without closing it. I want to use "hGetContents" multiple times as there's constantly new output.
18:43:35 <benzrf> sdegutis: it's a bit incomprehensible though
18:43:35 <edwardk> lenses are functional getters and setters. we had these things tupled up in a data type before. with category theory and understanding the notion of a profunctor, tambara modules over monoidal categories, etc. we found out that there is a related construction that gives us a notion of a smart constructor, a way to encode isomorphisms, traversals of parts of
18:43:36 <edwardk> a structure, etc.
18:43:46 <benzrf> sdegutis: like reading a State monad instance out of context
18:44:05 <sdegutis> I started to write a web app in Haskell and it occurred to me that perhaps Haskell is in fact one of those languages that's nice on paper but very ugly in practice.
18:44:08 <MP2E> lens is a functional pearl imo :)
18:44:09 <enthropy> bramgg: because you want to read from it elsewhere?
18:44:13 <MP2E> i know not all feel that way hehe
18:44:15 <n0n3such> sdegutis: lol
18:44:22 <ab9rf> sdegutis: if anything, haskell is nicer in practice than it is on paper
18:44:29 <Welkin> sdegutis: I have never had an easier time developing web apps than with haskell
18:44:31 <sdegutis> I really wanted to like it, a very lot. But it's incredibly hard to convince myself that it's not going to be ugly.
18:44:35 <bramgg> enthropy: what do you mean?
18:44:41 <sdegutis> So if anyone could just show me a single .hs file that's beautiful, I would really love that.
18:44:44 <Welkin> sdegutis: try using scotty or yesod
18:44:49 <edwardk> we were able to build a form of 'jquery for haskell data types' that rests on a bedrock of real insight, where you can actually reason through why all the bits compose for deep reasons not just operator overloading, such that all the bits you reach for work in all the contexts you'd expect them to work in, and if they don't it exposes an error in your
18:44:49 <edwardk> understanding of what is possible, not the library
18:44:50 <ab9rf> sdegutis: at least some of the time.  there are some really beautiful practical libraries
18:44:56 <exio4> sdegutis: I think there is no good code, just good enough for our actual standards
18:44:57 <sdegutis> Welkin: I am using scotty and so far it's a little scary.
18:45:12 <Welkin> sdegutis: scotty is a one-to-one clone of sinatra
18:45:17 <Welkin> but in haskell
18:45:18 <sdegutis> Right, I use scotty.
18:45:21 <edwardk> folks use it now to munge xml, html, haskell records, maps, ad hoc data types of all sorts using a common vocabulary.
18:45:22 <sdegutis> It's the types that confuse me.
18:45:24 <n0n3such> edwardk: that sounds nice and academic
18:45:31 <Welkin> sdegutis: okay, that is normal
18:45:36 <n0n3such> how did that contribute to getting a product out the door ?
18:45:42 <Welkin> sdegutis: types are very important in haskell, so spend some time studying them
18:45:44 <edwardk> n0n3such: most of the lens users write web apps, business apps, crud, web services, etc.
18:45:45 <Welkin> it will get a lot easier
18:45:53 <sdegutis> I have been studying Haskell types for like a week.
18:45:55 <n0n3such> i mean, what kind of product cares about jquery for haskell types ?
18:45:57 <tnks> n0n3such: lenses just allow you to access data structures nicely.
18:45:58 <ab9rf> n0n3such: because haskell progframmers tend to be computer scientists, instead of just code monkeys
18:45:59 <sdegutis> I am not any better at Haskell for it.
18:46:00 <tnks> you do that /all/ the time.
18:46:01 <enthropy> bramgg: you could do something like:    do c <- newChan; forkIO $ forever $ writeChan c =<< hGetLine h
18:46:04 <Welkin> sdegutis: a week is nothing
18:46:11 <tnks> (to get product out the door)
18:46:13 <sdegutis> Welkin: for someone of my experience it ought to be sufficient
18:46:19 <n0n3such> ab9rf: exactly
18:46:41 <sdegutis> Plus, the program I want to write is a simple personal-budget program.
18:46:46 <sdegutis> I think Haskell is probably overkill for this.
18:46:47 <ab9rf> n0n3such: the ones who weren't computer scientists when they started tend to end up learning some computer science on the way
18:46:48 <NemesisD> does anyone think haskell will ever be able to support import cycles?
18:46:56 <ab9rf> sdegutis: why?
18:46:57 <edwardk> n0n3such: the kind of application that wants code to be easy to read and concise.
18:46:58 <n0n3such> not many comp.sci folks actually know what it means to make a living writing code in a startup
18:46:58 <pharaun> sdegutis: nice, web? did you look into penny? hledger?
18:47:00 <enthropy> bramgg: rereading your question it seems like that'll do it (you that chan will have whatever additional lines come in as they are input)
18:47:03 <jle`> i think ghc already does, n0n3such
18:47:07 <jle`> er, NemesisD
18:47:07 <edwardk> aka almost all of them
18:47:08 <Welkin> sdegutis: it only seems complicated because you do not yet understand it
18:47:11 <sdegutis> ab9rf: because I don't need sum types and other such advanced features for this
18:47:16 <sdegutis> pharaun: no, scotty only
18:47:25 <Welkin> sdegutis: once you understand it, it will be as easy as, or even easier than, doing it with other languages
18:47:31 <ab9rf> sdegutis: if anything, it's where i'd like haskell, because you really don't want your financial management program to have may-fail-randomly code in it, now, do you?
18:47:39 <NemesisD> jle`: whats up with the error then
18:47:48 <jle`> NemesisD: you have to play some tricks
18:47:49 <bramgg> enthropy: thanks!
18:48:00 <NemesisD> but i don't wanna!
18:48:01 <n0n3such> edwardk: i was at holmdel in bell labs in the 80s and everybody who wasn't a physicist had ph.d in computer science and few could survive as software developers in a startup environment
18:48:05 <jle`> ;_;
18:48:12 <pharaun> sdegutis: ahh then i would encourage you to check out hledger-web, there's also penny, libraries/codes for doing account tracking/etc so might be educational to read upon them :)
18:48:13 <sdegutis> For example, I found myself writing this:   data CalendarMonth = January | February | March | April | May | June | July | August | September | October | November | December deriving (Eq, Show)
18:48:26 <tnks> n0n3such: why are you so obssessed with a particular type of startup (one with an horrendous failure rate)?
18:48:30 <sdegutis> And then I wanted a nextMonth function where for January it would give me February, etc.
18:48:37 <ab9rf> n0n3such: but that startup environment wouldn't exist without computer scientists :)
18:48:38 <sdegutis> But the implementation was exceedingly stupid.
18:48:39 <jle`> you can derive Enum ?
18:48:43 <n0n3such> tnks because they tend to be worth a billion dollars
18:48:47 <Welkin> sdegutis: succ
18:48:48 <sdegutis> It was literally just this, 12 times:  nextMonth January = February
18:48:58 <ab9rf> n0n3such: markets are unreliable at pricing things that they do not understand
18:49:05 <sdegutis> Except one variation:  nextMonth December = January
18:49:07 <n0n3such> ab9rf: we count on that
18:49:21 <Welkin> sdegutis: you are doing it wrong
18:49:22 <sdegutis> Welkin: I tried to do that but had no idea how to make it work
18:49:25 <tnks> n0n3such: you can make plenty of money in a more stable/reasonable way
18:49:28 <Welkin> :t succ
18:49:29 <lambdabot> Enum a => a -> a
18:49:31 <sdegutis> Welkin: please enlighten me on this, because I really hated my way
18:49:32 <Welkin> :t pred
18:49:33 <jle`> nextMonth = toEnum . (`mod` 12) . (+1) . fromEnum
18:49:33 <lambdabot> Enum a => a -> a
18:49:41 <ab9rf> n0n3such: so the market evaluation of a business doing soething markets do not understand is not a relialbe indicator of its actual worth
18:49:43 <n0n3such> tnks been there done that, not my style
18:49:49 <bramgg> enthropy: looking into what you wrote as we speek, but would you mind really briefly explaining what that does in english?
18:49:51 <n0n3such> ab9rf: who cares ?
18:49:55 <edwardk> n0n3such: having computer science chops doesn't necessarily rule out software engineering chops
18:50:00 <jle`> succ won't work because derived Enum instances are partial
18:50:01 <benzrf> edwardk: what was that 'ping me later' about :?
18:50:04 <jle`> ikr
18:50:08 <n0n3such> edwardk: agree, but its a cultural difference
18:50:12 <ab9rf> n0n3such: if your goal is to make money, become an investment banker.  much more money with much less effort than being a programmer.
18:50:12 <sdegutis> jle`: thanks
18:50:15 <tnks> n0n3such: coming around to a Haskell IRC channel and making unsubstantiated claims about the language doesn't seem like much of a path to billions of dollars.
18:50:19 <edwardk> benzrf: about trying to figure out if we can find you an internship / degree program somewhere =P
18:50:32 <jle`> except for for newtypes
18:50:34 <jle`> then it depends
18:50:35 <n0n3such> tnks: sigh
18:50:35 <sdegutis> Also, I was writing my other types.
18:50:40 <sdegutis> And it was really fun.
18:50:44 <jle`> :D
18:50:46 <sinnsat> sdegutis: you could also build a cyclic doubly linked list
18:50:53 <sdegutis> But then I realized they'll have to be so dead-simple that they can be represented via JSON for serialization.
18:50:55 <n0n3such> tnks i'm not making any claims i am encouraging discussion of haskell/scala/clojure
18:51:02 <sdegutis> At which point I realized, this is no different than any other language.
18:51:06 <jle`> sdegutis: any luck with the automatic JSON serialization?
18:51:11 <jle`> for your fun types?
18:51:12 <benzrf> edwardk: :-D
18:51:13 <sdegutis> jle`: I was just going to use Aeson.
18:51:16 <enthropy> bramgg: make a new thread that constantly tries to get lines from that handle, and then puts that input into a chan
18:51:17 <benzrf> edwardk: thank!
18:51:24 <jle`> i thin aeson has automatic serialization
18:51:30 <sdegutis> So all in all, my web app is looking extraordinarily ordinary and non-fun.
18:51:42 <bramgg> enthropy: thanks :)
18:51:55 <enthropy> so now you have the problem of wanting to use getChanContents
18:51:59 <Welkin> sdegutis: try adding conduit for streaming IO
18:52:00 <enthropy> (maybe)
18:52:02 <Welkin> that is pretty cool
18:52:04 <edwardk> n0n3such: i'd think if you just cared about the highest market rate acquisition targets, you'd care more about erlang, after all, it has one $21.8 billion dollar success story nobody can shut up about =P
18:52:06 <n0n3such> ok y'all seem to be a nice bunch of people i kinda like haskell, those scalaz guys are a bunch 'o finger wigglers, i am off to #clojure now ty
18:52:12 <jle`> sdegutis: try finishing it, and we'll see how we can refactor it :)
18:52:24 <jle`> if you can actually make something work first, then that's already a big accomplishment
18:52:31 <jle`> making it work in the style you are used to, that is
18:52:37 <jle`> this is your first haskell project, right?
18:52:42 <jle`> or am i thinking about someone else
18:52:46 <n0n3such> edwardk: that was in yesterday's world
18:52:56 <n0n3such> edwardk: look forward, not backwards
18:52:57 <edwardk> n0n3such: scalaz is pretty much the half way point between mainstream scala and haskell, it is writing haskell in scala, and as a result pays all the prices of both.
18:53:01 <jle`> make it work in the style you are used to, and then as you learn more, you can adjust more to make it work in the style that haskell works best with
18:53:06 <pharaun> edwardk: gotta move fast, chop chop :)
18:53:22 <n0n3such> edwardk: perhaps but the culture in scalaz is pretty nasty compared to the culture in haskell
18:53:25 <edwardk> n0n3such: sure, and even joe armstrong would admit that the reason that whatsapp used clojure was a misread of what facebook was doing at the time as what they'd keep doing
18:53:33 <MP2E> I think if you expect to write perfect code off the bat you'll always be disappointed, regardless of the language
18:53:37 <platz> To be fair I have noticed there are more discussions about correctness than about things like domain driven design, cqrs, or other "sw arch" ideas in that category
18:53:40 <MP2E> haskell's strength is refactoring
18:53:47 <edwardk> n0n3such: there is definitely a different tone between the communities, sure.
18:53:48 <MP2E> sitting there and making crappy code excellent
18:53:49 <pharaun> edwardk: interesting, i never heard bout the misreading one
18:53:51 <jle`> s/perfect/interesting
18:54:00 <n0n3such> MP2E:  I want a language that give me new conceptual frameworks to apply to creative solutions
18:54:08 <edwardk> pharaun: I had Joe come out and give a keynote for us at CUFP last year, he talked about it a fair bit
18:54:10 <n0n3such> gives*
18:54:14 <ab9rf> my first few haskell programs were embarrassingly bad
18:54:14 <pharaun> edwardk: neat :D
18:54:18 <Welkin> pulling apart haskell and rewriting it is trivially easy
18:54:26 <tnks> Scalaz people are often on the defensive -- because of deep cultural schisms in the user base.
18:54:28 <edwardk> http://cufp.org/2014/joe-armstrong-making-money-from-fp.html
18:54:29 <Welkin> just follow what the compiler says and fix it
18:54:39 <sinnsat> MP2E: yeah, you can use sed on major data types, compile a few times and fix remaining warnings. Try the same in C without getting segfaults all over your face :)
18:54:56 <n0n3such> edwardk: that is a nice way of putting it
18:55:04 <sdegutis> jle`: I already write Clojure web apps which are extremely similar to this.
18:55:15 <jle`> sdegutis: yes, that's what i mean
18:55:16 <sdegutis> jle`: it uses hiccup and compojure which are extremely similar to scotty and lucid
18:55:19 <jle`> write the web apps the way you are familiar with
18:55:26 <edwardk> pharaun: anyways in particular it was that when whatsapp was getting off the ground facebook was at that very moment powering their chat with erlang, this was before they poured money down a pit rewriting it all into c++ or whatever.
18:55:29 <jle`> and then, as you learn more haskell
18:55:34 <jle`> you'll slowly see more ways that are suited for haskell
18:55:35 <jle`> and more interesting
18:55:37 <Welkin> facebook originally used erlang for their chat app backend
18:55:39 <sdegutis> jle`: the main difference is that Haskell is typed and prefers functions whereas Clojure is dynamically typed and prefers raw data that the library transforms later
18:55:42 <MP2E> n0n3such: Haskell is probably going to resonate well, with enough effort, then. The concepts at first may seem painfully abstract, to the point where they seem applicable no where
18:55:45 <MP2E> but in fact you'll find
18:55:49 <MP2E> most of the abstractions are applicable *everywhere*
18:55:55 <Welkin> then they quickly switched it over to C++ because they couldn't find enough decent erlang programmers
18:55:56 <sdegutis> jle`: but can you give me an idea of some things that would be more interesting in Haskell?
18:56:12 <pharaun> edwardk: ahh i see
18:56:20 <sdegutis> jle`: anyway yes, I agree with you -- I'm actively trying really hard to set up a scotty application that has unit tests
18:56:23 <edwardk> pharaun: so whatsapp adopted erlang because of ejabberd and the facebook success story
18:56:27 <MP2E> The trick is to not get swept up by the fancy words or concepts that you don't get at first :)
18:56:29 <sdegutis> jle`: but it's a huge pain because the .cabal file is so awful to setup
18:56:30 <MP2E> just keep trying!
18:56:32 <sdegutis> jle`: so it's taking an hour
18:56:43 <MP2E> keep coding and playing with GHCi especially
18:56:54 <n0n3such> MP2E: good advice ty
18:56:57 <jle`> sdegutis: you're using a unit test framework?
18:57:05 <sdegutis> jle`: yes, I wanted to test my stuff for some reason
18:57:09 <edwardk> you can point to 2-3 other $150 million range erlang acquires though, but whatsapp definitely sits atop the money pile
18:57:10 <sinnsat> how about QuickCheck
18:57:14 <jle`> heh, it's a habit
18:57:16 <sdegutis> jle`: I'm using Hspec
18:57:34 <sdegutis> sinnsat: I want to do as little thinking about my testing framework thus Hspec works fine for me
18:57:42 <sinnsat> for functions you usually write property tests
18:58:00 <jle`> for your pure functions you just write property tests
18:58:13 <jle`> @check \xs -> length (reverse xs) == length xs
18:58:15 <lambdabot>  +++ OK, passed 100 tests.
18:58:21 <sdegutis> Yes that's fine
18:58:26 <jle`> for IO functions then it gets a little trickier
18:58:29 <sdegutis> But what about my month thing?
18:58:37 <sdegutis> How would you use quickCheck to test nextMonth?
18:58:43 <sdegutis> See?
18:58:47 <platz> quickcheck has been ported to every language possible to the extent the language supports it, especially in the last few years
18:58:47 <jle`> maybe nextMonth twelve times will be id?
18:58:59 <pharaun> edwardk: informative, thanks :) i've heard of whatsapp and its use of erlang and read up on it a bit etc but never knew fb used to be on erlang
18:59:01 <sdegutis> see my point?
18:59:04 <sdegutis> there's no point in it
18:59:06 <edwardk> n0n3such: I think the key distinguishing feature with the haskell community is that it isn't afraid to call a spade a spade, it isn't afraid to use the high-falutin' language to talk about what a thing fundamentally is. But doing that carries a cost. It means that if you use a piece of jargon you always have to be willing to break it down into what it really
18:59:06 <edwardk> means. The vocabulary is the scaffolding we use to climb to a higher level of abstraction, but you always have to be willing to offer someone a hand up.
18:59:34 <jle`> yeah, heh. that might not be a best case for quickcheck.  but admittedly it's not quite a best case unit test either
19:00:12 <sdegutis> Anyway, let's see if I survive this cabal yak shaving.
19:00:22 <sdegutis> I'm taking hspec-tutorial and trying to convert it into my app.
19:00:26 <sdegutis> re: https://github.com/sol/hspec-tutorial
19:00:30 <Welkin> cabal init does most of the work for you
19:00:34 <edwardk> n0n3such: folks look at haskell posts as a static artifact, and then try to puzzle through what the hell those academic types are doing in isolation without actually talking to someone about what the parts mean. all communication is done in context, and a lot of the fancier stuff is being said in haskell because haskell enables us to say it at all, so
19:00:34 <edwardk> haskell gets a reputation for being really abstract, when really its that in these other languages i can't think the thought at all.
19:00:37 <sdegutis> And it's admittedly still horrifyingly awful.
19:00:38 <Welkin> then you just add some dependencies
19:01:34 <sdegutis> Is there a way to quickly reload my scotty app if any files change, while it's running?
19:01:48 <sdegutis> Or do I have to keep stopping it and re-running `cabal run` every time I change a file?
19:01:50 <Welkin> sdegutis: yesod does that by default
19:01:55 <sdegutis> I'm not using yesod.
19:01:59 <edwardk> I hopped into the Haskell community assuming everyone here knew what all those category theory terms meant. So I went nuts learning them and applying myself so I, too, could communicate in that way. Little did I know that the number of folks in the Haskell community who really knew what, say, comonads were or how to apply them was vanishingly small, and the
19:01:59 <edwardk> intersection almost non-existent.
19:02:37 <nshepperd> QuickCheck is nice if there's a reference implementation you can write in a slow obvious way, then you can just demand both implementations to be equal
19:02:40 <orzo> you didn't learn category theory at schooL?
19:02:41 <Welkin> sdegutis: there should be some way
19:02:44 <Welkin> check the docs
19:02:47 <Rotaerk> haskell as a language isn't that complicated
19:02:52 <Welkin> hakyll has ./site watch
19:02:55 <MP2E> edwardk: I'm still quite thankfully you've delved as deep as you have, I think you've brought some great things back for the rest of us :P
19:03:04 <sdegutis> I'm not using hakyll.
19:03:11 <Welkin> sdegutis: I know
19:03:16 <Rotaerk> the "problem" is that in languages like C++, you tend to implement most of your stuff in terms of the raw mechanisms of the language
19:03:17 <Welkin> I did not say you are
19:03:23 <Rotaerk> like if we were to always implement everything in terms of recursion
19:03:25 <edwardk> Then I stated blogging about it in those terms, just broadcasting a signal. Eventually a bunch of folks started picking up that signal and extracting useful information, but using the "right" academic names for things really helps in that regard. It retains a connection to all those years of documentation and papers and books. Category theory gives us
19:03:25 <edwardk> something that has had 73 years of testing against all of modern mathematics.
19:03:26 <sdegutis> Welkin: also, it's much simpler for them to do it
19:03:34 <Rotaerk> but in haskell, we use abstractions upon abstractions to simplify code
19:03:45 <Rotaerk> and some of those abstractions can be offputting to learn
19:03:46 <sdegutis> Welkin: they just serve raw files off disk, so it's easy for them to re-build them at the change of a file system
19:03:56 <Rotaerk> to someone who's used to other languages
19:04:03 <edwardk> And it happens to prove to be a really great way to organize code, because the category of haskell types behaves enough like some things that are very very well studied.
19:04:42 <sdegutis> So far, my experience with Haskell is that the language is awesome but the tools are complete and utter crap compared to the tools competing languages have.
19:04:52 <edwardk> We use the terms explicitly to enable folks to find what stuff has come before, to get insights we couldn't craft directly ourselves, not to exclude people.
19:05:04 <platz> nshepperd: here's a nice post about how to construct properties for your code (it's F# but same concept)
19:05:34 <orzo> edwardk: i've been in a situation where i saw some particular general category theory like type class in your libraries, but using *your* defintion would mean dragging in a bunch of imports.  Maybe type classes should be in special type class packages that depend only on other type class packages
19:05:35 <platz> http://fsharpforfunandprofit.com/posts/property-based-testing-2/
19:05:44 <edwardk> There is always the cheap "monads are monoids in the category of endofunctors" in-jokes that folks memorize and say to sound smart.
19:05:52 <MP2E> haha
19:06:17 <edwardk> orzo: ultimately it comes down to the notion that i need my packages to work with each other. You have no idea how bad the situation used to be ;)
19:06:42 <edwardk> orzo: also you can't get such a clean layering because you have instances for types that don't or won't ever depend on those packages
19:06:56 <edwardk> and orphans lead to a terrible set of headaches for all users for all time
19:07:19 <edwardk> orzo: so while i respect your concern the language doesn't allow me to address it in a satisfactory way
19:07:31 <Welkin> edwardk: my favorite haskell joke is the one about the software engineer drinking beer at lunch time and colleague asks "Don't you have work to complete today? Why are you drinking so early?", to which he responds "Don't worry, I work in a type-safe lanuage"
19:07:41 <edwardk> Welkin: =)
19:07:42 <MP2E> :D
19:08:48 <sinnsat> sdegutis: what tools are you using?
19:08:50 <nshepperd> platz: neat
19:09:04 <nshepperd> platz: these examples are excellent
19:10:05 <platz> summarized as: Different paths to same result, Inverses, Invariants, Idempotence, Structural induction, Easy to verify, Test oracle -> choose one
19:11:57 <JoshWVS> Hi all - beginner question. Can anyone advise?
19:12:11 <shachaf> Probably many people can, but only if you ask it.
19:12:27 <sdegutis> sinnsat: any of them
19:13:08 <edwardk> JoshWVS: the usual rule of thumb is "just ask", don't "ask to ask", it makes it a lot easier for folks to answer your question, and folks don't feel on the hook, if they say yes to the former but have no idea on the latter ;)
19:13:26 <edwardk> JoshWVS: so how can we help?
19:13:43 <JoshWVS> I was looking at implementing a solution Project Euler problem #2, and was wondering about the difference between two list comprehensions. The problem tasks you with finding the sum of the even Fibonacci numbers less than 4 million, and I had written:
19:14:04 <JoshWVS> [x | x <- fibs, x < 4000000, even x]
19:14:18 <JoshWVS> Which took forever and gave me an error. However, the following worked instantly:
19:14:27 <fragamus> how are people liking the monad levels
19:14:40 <JoshWVS> [x | x <- takeWhile (< 4000000) fibs, even x]
19:14:40 <shachaf> JoshWVS: It takes forever because it doesn't know when to stop.
19:15:03 <shachaf> takeWhile knows when to stop -- it stops as soon as it finds something that the predicate doesn't hold for.
19:15:28 <edwardk> the latter is able to exploit the property that it knows it'll only ever drop an entire tail of the list. the former has to worry that after it drops something that it may need to give you more stuff!
19:15:35 <edwardk> it has to run until it runs out of integers!
19:15:38 <shachaf> > [x | x <- [1,2,10,3,4], x < 5]
19:15:40 <lambdabot>  [1,2,3,4]
19:15:56 <shachaf> The list comprehension has no magic insight into your list -- it just filters it.
19:16:19 <HeladoDeBrownie> seems like proving arbitrary properties like that would be nontrivial and in some cases impossible
19:16:25 <HeladoDeBrownie> (automatically)
19:16:36 <edwardk> you have a list of fibs that is monotonically increasing, and a predicate there x < 4000000, which goes from True to False at some point in the list, but never can go back to True
19:16:48 <orzo> maybe a language extension could hint ghc to identify duplicate type classes
19:16:48 <edwardk> takeWhile exploits that insight
19:16:48 <JoshWVS> Hmmm... interesting. I don't fully understand, don't they both have to check each element, one by one?
19:16:56 <shachaf> HeladoDeBrownie: Yes, it's an instance of the halting problem. You can tell because it's a program that doesn't halt. :-)
19:17:04 <edwardk> JoshWVS: the moment takeWhile finds a counter-example it ends the list
19:17:05 <JoshWVS> Sorry, missed that last comment - interesting!
19:17:09 <shachaf> JoshWVS: takeWhile stops as soon as it finds an element that's >= 4000000
19:17:09 <edwardk> in shachaf's example it'd be [1,2]
19:17:45 <shachaf> Without using list comprehensions, the analogy would be "filter (< 4000000) fibs" vs. "takeWhile (< 4000000) fibs"
19:18:09 <shachaf> > takeWhile (< 5) [1,2,10,3,4] -- like edwardk says
19:18:10 <lambdabot>  [1,2]
19:18:12 <edwardk> so if you had 1000000 element list, and found a counter-example 10 elements in takeWhile touches 10 elements, while the other comprehension touches all 1000000 and keeps rejecting all the ones at the tail
19:18:18 <octopuscabbage> does anyone have a reccomendation for a tutorial on writing a programming language in haskell for an intermediate haskeller
19:18:40 <edwardk> because filter has to worry that it may find another success
19:18:45 <acomar> octopuscabbage: have you seen write you a scheme in 48 hours?
19:18:45 <octopuscabbage> write you a scheme seemed a bit introductory for my taste
19:18:47 <Welkin> octopuscabbage: write yourself a scheme in 48 hours
19:18:49 <MP2E> octopuscabbage: it's not done yet but I found http://dev.stephendiehl.com/fun/ to be helpful
19:18:52 <acomar> ahh, kk
19:19:12 <octopuscabbage> ie i don't really need to start from main is in the io monad, just ignore that from now on
19:19:16 <fragamus> does anyone have impressions of monad levels they would like to share
19:19:19 <octopuscabbage> i (vaguely) understand monads
19:19:27 <johnw> fragamus: my impression is that it's far too complicated
19:19:36 <HeladoDeBrownie> "main is in the io monad" is misleading at best anyway
19:19:38 <johnw> and I'm someone who's extremely familiar with the problem
19:19:47 <acomar> octopuscabbage: you can more or less skim through it then, the ideas on how to design the AST and evaluate it are still valuable
19:19:51 <JoshWVS> Oh! So was my original version never stopping, and considering every Fibonacci number (and immediately rejecting them all?)
19:19:57 <Hijiri> what's a monad level?
19:20:13 <MP2E> Hijiri: it's a new monad transformers library
19:20:15 <MP2E> monad-levels
19:20:15 <octopuscabbage> acomar, that was what i was planning on doing if there wasn't a better option
19:20:22 <Hijiri> MP2E: neat
19:20:46 <MP2E> https://ivanmiljenovic.wordpress.com/2015/02/02/monadic-yak-shaving/
19:21:10 <Hijiri> wow, so fresh hayoo hasn't indexed it yet
19:21:24 <Welkin> hayoo hasn't indexed gl either
19:21:28 <Welkin> what's with that?
19:22:08 <dmwit> octopuscabbage: TAPL is in ocaml but quite good
19:22:32 <dmwit> ?google TAPL
19:22:33 <lambdabot> http://www.tapl.org/
19:22:34 <lambdabot> Title: Tulsa Association of Professional Landmen, | Tulsa, Oklahoma
19:22:37 <Hijiri> hayoo is underwritten by a cabal of people who dislike gl and monad-levels
19:22:41 <dmwit> ...no
19:23:00 <dmwit> ?where tapl
19:23:01 <MP2E> lol
19:23:01 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
19:23:03 <Hijiri> tulpa amalgam of pony lovers
19:23:09 <monochrom> :)
19:23:41 <neuroserpens> Guys... What do you recommend I use for web development?
19:24:07 <johnw> neuroserpens: do you want it to be in Haskell?
19:24:17 <neuroserpens> johnw: Well... Yes lol
19:24:23 <johnw> because Ur/web looks fun
19:24:36 <neuroserpens> johnw: What do you mean?
19:24:41 <johnw> as a web development language
19:24:47 <johnw> Ur/web for the front-end, Haskell for the backend
19:24:59 <johnw> that's what bazqux did
19:25:22 <neuroserpens> johnw: I'm talking about the back end
19:25:24 <edwardk> neuroserpens: snap or yesod is a good all-haskell solution
19:25:45 <edwardk> neuroserpens: happstack also has some fans, and there is scotty, and probably a few others
19:25:48 <johnw> edwardk: have you used yesod?
19:26:17 <neuroserpens> edwardk: We have a problem right there... I've been studying haskell for 2 months and snap code is still extremely cryptic to me
19:26:19 <edwardk> johnw: sure. i put examples on fp complete's site using it a fair bit, and it was nice in shapr's haskell live project back a ways
19:26:25 <johnw> ah, cool
19:26:33 <neuroserpens> edwardk: I'll take a look at yesod
19:26:36 <edwardk> neuroserpens: my recommendation for either snap or yesod is to lurk in the channel
19:26:37 <ab9rf> i'm thinking about throwing up a hakyll site
19:26:43 <edwardk> and not be afraid to ask
19:26:52 <johnw> I hear people recommending snap a lot more often, but that's interesting that you also liked it
19:26:52 <neuroserpens> edwardk: to lurk in the channel?
19:27:00 <johnw> I found it pretty nice to work with
19:27:02 <edwardk> #snapframework or #yesod
19:27:05 <Cale> neuroserpens: I've been programming in Haskell for well over a decade, and Yesod code is still extremely cryptic to me ;)
19:27:11 <ab9rf> both snap and yesod have fairly complicated frameworks that need to be understood, and that's not so much haskell as it is understanding the framework's operational design
19:27:13 <neuroserpens> Cale: wtf
19:27:16 <edwardk> mightybyte and company are quite helpful in the snap channel
19:27:39 <Cale> neuroserpens: But mostly because Yesod has all these miniature programming languages through quasiquoter macro expansion
19:27:45 <johnw> scotty is one of the more bare bones
19:27:48 <Cale> neuroserpens: It's not just plain Haskell
19:27:54 <edwardk> neuroserpens: Yesod is basically designed as a "ruby on rails" in haskell. it does a lot with template haskell to make nice little EDSLs for describing the problem domain that means that a lot of Yesod experience is very different from a lot of general haskell experience.
19:28:04 <ab9rf> my brief examination left me liking snap slightly better than yesod, but i've done barely anything in either and so don't really have a basis to prefer one or the other
19:28:16 <neuroserpens> Cale: Is there something in haskell's standard library for web dev?
19:28:30 <neuroserpens> Cale: It feels like frameworks are going to be a pain in the @#$%
19:28:32 <edwardk> If you are looking for a ruby-on-rails-alike where you get nice typechecking guarantees that the resource you name on disk is actually there and not a typo, then yesod is kinda awesome
19:28:41 <abrar> neuroserpens: we use snap at work. it was over a year ago that we made the decision to do so. it seemed easier to learn than the other haskell server frameworks we investigated (including yesod)
19:28:47 <edwardk> if you are looking to learn haskell it is a rather awkward introduction
19:29:01 <ab9rf> web frameworks are inherently complicated
19:29:17 <ab9rf> if you are using one that is not complicated, it's probably either very limited, or is shortcutting something important
19:29:19 <edwardk> snap gives a better "haskell" introduction, at the expense of being a bit harder to use for the basic web dev tasks
19:29:40 <neuroserpens> Crap. Alright. Thanks for the info. I'll see if I can translate snap's hieroglyphs
19:29:46 <Cale> I think happstack seems like the most "normal"
19:30:03 <Cale> But I haven't had the chance to use it as extensively as snap
19:30:18 <edwardk> neuroserpens: please seek help if you start getting stuck or just have general architecture questions in #snapframework
19:30:31 <neuroserpens> edwardk: Alright. Thanks.
19:30:39 <Cale> Yeah, if you have some specific confusion, definitely just ask, either here or in the specific channel
19:30:59 <ab9rf> and the absolute worst thing someone can do is try to learn haskell via one of the web frameworks with the only prior experience being PHP :)
19:31:05 <stepcut> Happstack definitely aims to be normal. We only use quasiquoters for things like javascript and html templating where there is a pre-existing syntax
19:31:18 <Rotaerk> it's worse than murder !
19:31:25 <edwardk> yeah that wasn't meant as a shunt to kick you there, it was more that they are quite good at questions and we're a bit mediocre on snap questions ;)
19:31:29 <ab9rf> because there you're learning both a completely different language _and_ a completely different web framework architecture
19:31:38 <edwardk> happstack is definitely the 'most haskelly' of the web frameworks i think
19:31:41 <mgsloan> Cale: There's nothing in Yesod forcing usage of the templating languages.  As far as I can tell, the routing language is the only one that is reasonably mandatory
19:32:06 <edwardk> snap has a bunch of snaplet machinery that can seem unnecessary when you are just building something small or don't want to buy into the abstraction
19:32:20 <jkarni> edwardk: I'm certainly biased, but I feel like servant is in the running for most haskelly
19:32:21 <mgsloan> Also, not that it matters much, but standard style eschews quasiquotes in favor of having splices load templates from files
19:32:21 <Cale> mgsloan: I seem to recall that the routing language binds values which are not mentioned in its syntax.
19:32:23 <ab9rf> mgsloan: yeah, that fits with my experience too
19:32:23 <stepcut> pretty sure you can just ignore snaplets if you don't want to use them
19:32:52 <stepcut> though, perhaps they are more tightly integrated these days
19:32:55 <abrar> stepcut: i've only ever used snap that way
19:33:00 <Cale> mgsloan: Which I personally thought was kind of confusing -- you sort of had to understand what definitions the quasiquoter was going to make
19:33:36 <Cale> mgsloan: I could be wrong about that now though, it's actually been some time since I last looked at the web frameworks closely.
19:33:40 <n0n3such> edwardk that was interesting in #clojure ... everyone who responded responded positively about haskell
19:33:49 <monochrom> :)
19:34:07 <monochrom> and in #haskell, agda and idris :)
19:34:14 <n0n3such> lol
19:34:17 <n0n3such> no coq ?
19:34:23 <mgsloan> Cale: True, it does take a bit of getting used to, but it's very convenient!  You pretty much express how to take portions of a route apart into variables, and you get a dispatcher / route constructors from that!
19:34:26 <monochrom> "it's paying forward all the way down"
19:34:45 <n0n3such> monochrom: thats a bit cryptic
19:34:47 <mgsloan> But I'm not really a source of "which web framework is the best", as I'm pretty much only experienced with Yesod
19:35:12 <mgsloan> but I've found Yesod to be extremely nice to work with
19:35:12 * hackagebot growler 0.5.0 - A revised version of the scotty library that attempts to be simpler and more performant.  http://hackage.haskell.org/package/growler-0.5.0 (IanDuncan)
19:35:14 * hackagebot mikmod 0.1.3.0 - MikMod bindings  http://hackage.haskell.org/package/mikmod-0.1.3.0 (evanrinehart)
19:35:24 <orzo> edwardk: to enable library authors to provide instances for your nice classes without requiring them to bring in more dependencies, we could have two sets of type classes.  The ones your libraries actually use could have default rules for using less coupled versions that other authors could provide at little cost.
19:35:44 <edwardk> jkarni: i haven't taken a look at servant yet, i'll add that to my todo list next time i touch a web app
19:35:57 <platz> I couldn't imagine trying to build a large site without templating.. anyone have a good experience building HTMl from a DSL for anything larger than a micro-site?
19:36:08 <stepcut> It's my opinion that all the frameworks can get the job done reasonably well, but none really get it right :)
19:36:22 <edwardk> orzo: that doesn't actually work, and doubles the complexity for folks who do buy into using my packages
19:36:29 <mgsloan> stepcut: Sounds plausible, perfection is tough!
19:36:34 <stepcut> :)
19:36:47 <monochrom> perhaps Ur is better
19:36:47 <edwardk> you can't have a 'catch all' case like that that works. it violates open world expectations
19:36:57 <johnw> stepcut: are you including happstack in that characterization?
19:37:05 <stepcut> johnw: yup!
19:37:17 <johnw> then you would certainly be one whose opinion on this I'd trust :)
19:37:35 <stepcut> johnw: since taking over Happstack I've rewritten pretty much every line.. and I am now almost smart enough to rewrite it all again, but right ;)
19:37:37 <sdegutis> What's a language that's not as good as Haskell but very well-tooled?
19:37:41 <stepcut> right-er
19:37:49 <stepcut> java?
19:37:51 <johnw> sdegutis: Java has awesome tooling
19:38:06 <monochrom> visual basic
19:38:06 <sdegutis> Okay not *that* much worse than Haskell.
19:38:10 <platz> sdegutis: go wants to compete that that space
19:38:18 <johnw> um, F# maybe?
19:38:18 <sdegutis> platz: so OCaml?
19:38:19 <platz> "in that"
19:38:25 <johnw> Scala?
19:38:40 <sdegutis> All good suggestions so far (except VB) -- any more?
19:38:57 <johnw> are you asking for functional languages?
19:39:05 <orzo> edwardk: we're talking about the exact same type classes, just under different module headings.  It would also provide a smooth migration path if a library author decides to provide instances in his own code.  He could do so for the uncoupled versions, and you could at your leisure, change your own code to use the default rules for your instances
19:39:07 <sdegutis> Ideally, but doesn't have to be pure.
19:39:13 <johnw> very few of them are
19:39:20 <johnw> and I think that's about sums the well-tooled ones
19:39:29 <sdegutis> Nobody mentioned Clojure.
19:39:33 <platz> F# tooling is improving but many things have been in the dark there for a while with focus on making C# nice
19:39:41 <johnw> does clojure have good tooling?
19:39:46 <solirc> sdegutis: you either have to add to add you library to build-depnedns, or your source dir to hs-source-dirs
19:39:47 <sdegutis> Yep, Leiningen is great.
19:39:48 <n0n3such> sdegutis: lein is nice
19:39:53 <edwardk> orzo: i can't make a default that fires like that
19:40:10 <edwardk> orzo: it is a great plan right up until you go to actually implement it ;)
19:40:12 <edwardk> and then it fails
19:40:12 <platz> lein is slow as balls
19:40:26 <sdegutis> True.
19:40:35 <sdegutis> But only because clojure.core is
19:41:07 <sdegutis> I'm trying to write a small web app, and I want it to have very minimal dependencies and be in a language that's not completely insane.
19:41:22 <n0n3such> sdegutis: play2/akka/scala
19:41:25 <sdegutis> So far I'm leaning towards writing it in Swift using a WebView -- and that makes me shudder.
19:41:31 <edwardk> orzo: also there is the pain that some of the classes wind up using other data types defined in the self-same packages in their definitions, or in contexts for other instances, or as parameters that are fundeps off of another, etc.
19:41:33 <sdegutis> Oh also it's only a web app to be run locally.
19:41:46 <sdegutis> In other words, I haven't found a reasonable GUI toolkit yet.
19:42:02 <n0n3such> sdegutis: whats wrong with the browser ?
19:42:06 <edwardk> 'typeclasses on the bottom' works only for simple cases
19:42:18 <sdegutis> n0n3such: if I can find a reasonable language to implement it, then that's fine
19:42:26 <edwardk> and requires libraries to buy in that can never and will never buy in to many of those abstractions, period.
19:42:29 <sdegutis> n0n3such: but I refuse to use Ruby, and getting it setup in Haskell has been a nightmare so far
19:42:51 <edwardk> folks who care about maintaining haskell 98 / 2010 compatibility will never pick up a dependency on a class that breaks that guideline!
19:42:51 <n0n3such> play2/scala/akka/browser/jquery/etc
19:43:10 <edwardk> you'll never see 'transformers' pick up dependencies on, say, 'Bind' in semigroupoids.
19:43:21 <sdegutis> And Haskell seems wayyyy too mathy.
19:43:26 <edwardk> you'll never see it pick up dependencies on the indexed foldables, etc.
19:43:27 <sdegutis> And I'm not a math-oriented guy.
19:43:28 <solirc> sdegutis, sinnsat: You can use QuickCheck in combination with Hspec
19:43:55 <edwardk> sdegutis: haskell sucks at guis generally. hsqml seems to be the best we've got right now in terms of raw installability.
19:43:58 <n0n3such> sdegutis: cljs :)
19:44:12 <sdegutis> Does Haskell have a haskell-webkit like JS has node-webkit?
19:44:13 <acomar> sdegutis: check out threepenny-gui
19:44:16 <sdegutis> Oh right!
19:44:20 <exio4> edwardk: I think it's just that it sucks like any other language around
19:44:23 <monochrom> hmm, haskell is a bit mathy to me, but only a bit. not way mathy.
19:44:26 <edwardk> sdegutis: threepenny-gui is the closest i think
19:44:44 <sinnsat> edwardk: I've used the gtk bindings... ouch.
19:45:11 <solirc> Isn't it that GUIs actually suck?
19:45:13 <sinnsat> that's the problem... those are just bindings
19:45:13 <edwardk> exio4: well, part of it is we have a hard time with C++ interop, and we don't have something like java where Swing and the like are always available to you and dealt with by a gigantic corporation to ensure it works everywhere.
19:45:16 <sinnsat> not a real framework
19:45:18 <acomar> working on a browser now with the gtk bindings... it's basically writing imperative code in a much nicer language
19:45:26 <monochrom> proof by contradiction: if haskell were way too mathy, then [x | x<-[1..], x<=3] would terminate. but it doesn't. haskell is still just a do-what-you-asked programming language.
19:45:32 <orzo> edwardk: i mean only DefaultInstances, you'd not try make catch all automatic instances, just provide the means for people to make it convenient for people to declare instances for classes they didn't want to depend on directly
19:45:35 <edwardk> exio4: so that makes a ton of the things we could bind to very difficult to bind to
19:45:38 <sdegutis> I wouldn't mind making it in vty-ui or even vty but I can't get a hello-world working in either.
19:45:43 <orzo> edwardk: sorry, i meant DefaultSignatures
19:46:24 <edwardk> orzo: this is a pattern that doesn't scale. folks define contradictory versions of stuff for third party packages and bam the whole arrangement is dead in the water
19:46:26 <ab9rf> monochrom: haskell holds out hope that someday, there will be an integer so large that is less than or equal to 3,
19:46:31 <exio4> edwardk: you're right with that, C++ interop is a bit of a PITA
19:46:41 <edwardk> orzo: you have folks who pick up dependencies on lens from 5-6 sources these days for instance.
19:46:43 <ab9rf> C++ mangling?
19:46:54 <edwardk> if any two of them supplied your instances they'd just break.
19:47:37 <shachaf> monochrom: It does terminate, with the value (_ : _)
19:47:52 <acomar> ab9rf: that's part of it. The ffi also doesn't really understand the c++ object system, and the tooling support to compile c++ and haskell sources is not really there
19:48:12 <edwardk> orzo: you're asking for an entirely parallel class framework, which requires library authors who can and will never adopt them to adopt them, and to make a situation where code that currently easily works together can probably never work together again.
19:48:22 <edwardk> orzo: it just doesn't work
19:48:34 <ab9rf> acomar: yeah, i would imagine that is difficult
19:48:56 <edwardk> orzo: you'll never sneak another dependency into transformers, or containers.
19:49:21 <edwardk> the inversion you seek is impossible to attain
19:49:33 <ab9rf> acomar: also if you use a C++ templated class, you need direct interation with the compiler if there are instance dependencies that require separate compilation (at least, as i understand how C++ template metaprogramming works)
19:50:28 <sinnsat> sdegutis: what are you doing again?
19:50:34 <acomar> ab9rf: I'm not sure anyone has even tried to tackle templates. The closest I've gotten is mechanically generating C wrappers that call out to the appropriate functions/methods.
19:50:46 <orzo> edwardk: we don't need them too. You declare all the instances your declaring.  It's new authors who are friendly to your classes but don't want to depend on other things that would be accomodated
19:50:48 <ab9rf> acomar: yeah, that's probably the best strategy.
19:50:49 <edwardk> the cost of my current solution is that importing my packages tends to drag in a number of others of mine and a few that are already in the platform. i tend not to depend on too many things outside of the platform
19:51:01 <ab9rf> acomar: otherwise you get lost in the complexity of C++'s class system
19:51:13 <edwardk> orzo: and any two of those authors break when they go to depend on the same class.
19:51:21 <edwardk> or supply the same instance
19:51:59 <orzo> they'd only be supplying instances for types *they* defined of course, i don't see how they end up supplying the same instances
19:52:15 <acomar> ab9rf: yea, exactly. the sticking point is that you always have to translate it through C, so even if you came up with a way to handle templates between C++ and Haskell (i.e. generating type classes and the appropriate instances, etc.), you'd get stuck when you had to try and wrap it all in C first.
19:52:52 <n0n3such> is there a haskell compiler that targets the JVM ?
19:52:56 <acomar> so you lose even the nice (for some definitions of nice) features of C++ in the process, and it's all kind of monstrous.
19:53:43 <edwardk> say i make a package with just Control.Lens.At. Now, containers won't incur a dependency on it in order to give us all 'at'. You can't write a 'catch-all' instance without overlapping instances, and dispatch on that is notoriously unreliable whenever the instances are not each and every single one defined within a _single_ module.
19:54:05 <acomar> header parsing and mechanical translation is the only approach that really works, but to do it write, you first need to write a C++ parser that's compatible with the ones in use by e.g. gcc
19:54:45 <acomar> there might be some hope on that front to use the clang parser, but it's all a w.i.p. type situation
19:55:14 <ab9rf> acomar: and C++ is such an easy language to write parsers for :)
19:55:24 <edwardk> And even if you can somehow overcome both of those concerns I then go from defining 25 instances per data type to something like 40 and then naming those redundant classes.
19:55:34 <edwardk> my imports double
19:55:42 <edwardk> it is a rats nest =P
19:56:08 <ab9rf> edwardk: so is there a solution?
19:56:12 <acomar> ab9rf: it's relatively easy to get an 80% solution. It's virtually impossible to get a 100% solution. I'm pretty sure the various C++ compilers all do it in slightly different ways.
19:56:32 <edwardk> ab9rf: to which?
19:56:36 <ab9rf> edwardk: the rats nest
19:56:50 <edwardk> ab9rf: yes, the current one that orzo is railing against ;)
19:56:57 <edwardk> wherein all my code works with all of my code flawlessly
19:57:11 <edwardk> but it requires folks who depends on it to build rather more packages than they'd expect
19:57:52 <orzo> that's not what i do
19:57:55 <edwardk> it used to be more packages cut up finer grained, i consolidated a lot a couple of years ago
19:58:04 <orzo> when i like something in your stuff, i more often paste it
19:58:08 <orzo> to avoid depending
19:58:12 <ab9rf> ouchies
19:58:40 <edwardk> orzo: you are welcome to do so. i'm afraid at that point in time you aren't going to get any of the benefits to improvements in the abstractions and tools i write without following them all and copying again
19:58:52 <edwardk> orzo: i'm sorry for your loss
19:58:56 <orzo> heh
19:59:25 <acomar> orzo: what's wrong with just adding a dependency? installing dependencies takes a little longer, but that happens infrequently, right?
19:59:35 <edwardk> fwiw- i believe roman cheplyaka does the same, maybe you can collaborate ;)
19:59:47 <ab9rf> the more dependencies you have, the more your chance of being caught in cabal hell
20:00:05 <edwardk> ab9rf: almost everything i have written builds back 2-3 major platforms and on stackage
20:00:13 * hackagebot mikmod 0.1.3.1 - MikMod bindings  http://hackage.haskell.org/package/mikmod-0.1.3.1 (evanrinehart)
20:00:22 <acomar> haven't run into cabal hell once since switching to sandboxes for all my projects
20:00:27 <edwardk> ab9rf: if it doesn't build back that far it didn't exist back that far =P
20:00:35 <orzo> its more than that, i was targetting dated systems, like multiple versions of debian and wanted to mesh well with what the systems provide out of the box
20:01:19 <edwardk> orzo: when i know i have a user on a dated platform i take great care around not breaking it =P
20:01:26 <edwardk> some of my code works clear back to hugs =P
20:01:34 <ab9rf> edwardk: you have a reputation for putting more concern into such issues than the average package developer, though :)
20:01:54 <edwardk> ab9rf: yes, however, the concern at hand is incurring a dependency on my packages in particular, so it seems relevant =P
20:02:21 <n0n3such> careful edwardk you may wear out your P key :)
20:02:38 <edwardk> yeah i noticed i left my tongue hanging out there for a few sentences. it was getting a bit dry
20:03:43 * edwardk shrugs and goes to write more code for folks to cut and paste.
20:04:31 <ab9rf> heh
20:04:34 <orzo> hm, well, i wasn't really thinking edward's code directly.  I guess my default mode is that once i depend on a package, i use it freely, so i avoid depending.	Also, i was actually making a system of packages so a user could use apt to install my software or everythign needed tobuild it by pointing at my repository, that means typically porting cabal packages to debian ones, which i have some
20:04:40 <orzo> nice utilities for, but still, every dependency is more effort to accomplish the end result
20:04:54 <n0n3such> ok the magnanimity and wisdom of #haskell has convinced me to learn haskell and clojure at the same time
20:05:27 <MP2E> n0n3such: you'll be lucky if you get out of here only having to learn those two! There are agda, idris, and coq as well :P
20:05:35 <n0n3such> hehe
20:05:37 <n0n3such> ol
20:06:04 <MP2E> (I still have to learn those at some point..)
20:06:11 <n0n3such> MP2E:  i don't feel like i have to prove anything to anybody :)
20:06:17 <edwardk> MP2E: then the trek into the wilds of homotopy type theory where you don't really have a language, just a promise that some day it might be usable for computer science ;)
20:06:23 <ab9rf> i tried to learn coq several years ago
20:06:37 <MP2E> n0n3such: It was more a joke about how #haskell tends to favor exploring multiple languages than anything else :P
20:06:45 <n0n3such> hey i have my saunders mac lane right here
20:06:56 <n0n3such> careful about the P key MP2E
20:07:03 <MP2E> heh
20:07:17 <ab9rf> there's definitely an excess of showing tongue in here tonight :)
20:07:20 <sinnsat> as long as it's just a P
20:07:23 <MP2E> I tend to overuse it quite a lot.
20:07:26 <MP2E> not just here >_>
20:07:38 <acomar> edwardk: btw, been looking at your zipper library over the past couple of days, and would love to make use of the save/restore notion. The problem is, the problem domain I'm working in requires that the structure opened up as a zipper (simple list for now) be modified in flight via user interaction. I can't see any way to do that with your lens based zippers without grabbing an index, rezipping the whole structure, inserting the
20:07:38 <acomar>  element, then opening it back up. Is inserting an element/modifying the in-flight data structure really not possible?
20:08:11 <MP2E> edwardk: ooh interesting!
20:08:15 <edwardk> n0n3such: Categories for the Working Mathematician is a great way to make someone walk away and never look at category theory again. Awodey, or Lawvere and Schanuel, etc. are much more accessible introductions.
20:08:43 <MP2E> http://homotopytypetheory.org/book/ is this the right place to start?
20:09:22 <n0n3such> edwardk saw that but bought mac lane instead
20:09:34 <edwardk> I got lucky in that while i bounced off CftWM a few times i'd had just enough context to eventually make it through wrongly, and then repeat enough that it started to make sense in a useful way.
20:10:11 <orzo> hm
20:10:13 * hackagebot chart-histogram 0.4.5 - Easily render histograms with Chart  http://hackage.haskell.org/package/chart-histogram-0.4.5 (BenGamari)
20:10:33 <monochrom> "categories for the working mathematician" is really intended for working mathematicians, as said.
20:10:38 <orzo> edwardk could probably write a decent introduction to category theory
20:10:43 <orzo> i'd read it
20:10:49 <edwardk> Another good source on the category theory front is the Catsters account on youtube, Eugenia Cheng is great at explaining how things hang together and she's incredibly upbeat and enthusiastic about the material.
20:10:53 <n0n3such> edwardk is that a recommendation ?
20:11:43 <edwardk> n0n3such: i can recommend the catsters videos pretty much without qualification, yes.
20:12:33 <shachaf> The Catsters are great.
20:12:36 <edwardk> http://www.quora.com/What-is-the-best-textbook-for-Category-theory/answer/Edward-Kmett?srid=X8C1&share=1 <- is a more nuanced take on the "recommended category theory book" question
20:12:43 <shachaf> I like Tom Leinster's recent book, _Basic Category Theory_.
20:12:46 <edwardk> since it is one i get quite a bit
20:13:04 <edwardk> I still need to read that one to see if I should add it to my list of recommendations
20:13:08 <shachaf> Or at least I like what I've read of it.
20:13:40 <shachaf> Lots of examples, gets at the ideas/ways of thinking/etc., which is probably a lot of what you get out of category theory.
20:13:43 <edwardk> acomar: hrmm
20:13:45 <n0n3such> so is this stuff actually useful to know ?
20:13:59 <edwardk> n0n3such: my experience has been a definite yes
20:14:07 <orzo> edwardk: would you say category theory might make somebody a better software designer?  Maybe we need a "design patterns" like book along those lines?
20:14:07 <n0n3such> why ?
20:14:19 <roconnor> I like "Category Theory for Computing Science" at least as an introduction.
20:14:28 <shachaf> And "a free online version will be released in January 2016"
20:14:42 <shachaf> At which point I'll recommend it more freely. :-)
20:15:06 <ab9rf> damn
20:15:09 <ab9rf> i have to wait a year?
20:15:22 <monochrom> or you have to pay
20:15:25 <shachaf> No, you can order it now. Support the arts and so on.
20:15:44 <ab9rf> i'd have to find money to spend on it that isn't better spent on soething else
20:15:50 <shachaf> I like this quote from the introduction: "In subjects such as number theory and combinatorics, some questions are simple to state but extremely hard to answer. Basic category theory is not like that. To understand the question is very nearly to know the answer."
20:15:56 <edwardk> n0n3such: "design patterns" leak. Category theory gives you a source of "design pattern"-like ground truth that has been very well tested and works damn near perfectly for functional programming. It doesn't give you a name for a thing you'll have to write from scratch over and over, it gives you a name, and laws, properties you can test for, that if
20:15:56 <edwardk> satisfied give rise to all sorts of other non-obvious properties.
20:16:14 <johnw> that is a great quote, shachaf
20:16:14 <roconnor> http://www.math.mcgill.ca/triples/Barr-Wells-ctcs.pdf
20:16:26 <n0n3such> cool. im on it !
20:16:45 <roconnor> ctcs is freely available ... it seems
20:16:47 <edwardk> It also happens to be a vocabulary that can be implemented rather directly, so it can be encapsulated in a library and then built upon by lots of people.
20:16:51 <n0n3such> along with  Bird and Pierce
20:17:02 <shachaf> @remember TomLeinster In subjects such as number theory and combinatorics, some questions are simple to state but extremely hard to answer. Basic category theory is not like that. To understand the question is very nearly to know the answer.
20:17:03 <lambdabot> Done.
20:18:15 <edwardk> but for me the main thing that category theory has supplied me is a ton of tools for knowing when i can stop hunting for another, better, solution. it tells me a lot of conditions under which no such solution can exist. it gives me a way to let those questions stop serving as a denial of service attack on my brain.
20:18:54 <n0n3such> interesting
20:18:59 <n0n3such> are nootropics involved ?
20:19:28 <orzo> edwardk: i assume your "design patterns" reference was meant for me rather than n0n3such as it was me who brought it up
20:19:44 <n0n3such> orzo you can have all the credit, np :)
20:19:56 <orzo> heh
20:20:00 <dfeuer> I see that the aeson-schema maintainer has declared that he is no longer interested in continuing development. Is that a package of any significance?
20:20:56 <n0n3such> edwardk: certainty is a terrible thing. to state that no other solution exists is to admit a solution to the p:np problem
20:21:06 <edwardk> An obscure topic like Day-convolution gives me a way to figure out how to consume data structures with GHC.Generics automatically. Kan extensions give me a way to fuse together fmaps or (>>=)s in a monad, lets me take the concept of currying, and apply it to functor composition. These in turn give me all sorts of tools for optimizing the performance of code
20:21:06 <edwardk> I never even thought about before.
20:22:10 <n0n3such> its just an algebra of representational systems
20:22:20 <edwardk> n0n3such: no. when i say something like (,) e -| (->) e is the only adjunction from Hask <-> Hask up to isomorphism that requires no appeal to P vs NP or axiom of choice or anything such magic.
20:22:23 <n0n3such> nothing very complicated
20:22:23 <orzo> as far as i know, none of those books, even the ones specifically targetting "Computing Sciences" targets the working programmer who might benifit from looking for the specific abstractions in the math and applying them to make his design more flexible
20:22:51 <edwardk> orzo: that comment around design patterns was an attempt to drag both conversations in a similar direction and merge them ;)
20:23:27 <n0n3such> edwardk: asserting the absence of an alternate ontology is a bit, ummm ... assertive
20:23:40 <edwardk> category theory is just a form of algebra. it just happens to be very much the right form of algebra for talking about all sorts of systems that arise in practice.
20:24:02 <n0n3such> many sorts, not all sorts
20:24:16 <joneshf-laptop> can anyone tell me what this error means:
20:24:18 <edwardk> i meant all there colloquially, yes.
20:24:23 <joneshf-laptop> <command line>: cannot satisfy -package-id foo-0.1.0.0-inplace
20:24:26 <joneshf-laptop> from cabal
20:24:33 <n0n3such> the more you assert fealty to one way of thinking the more you are blinded to the alternatives
20:24:35 <edwardk> we're going to have all sorts of fun. ;)
20:24:50 <joneshf-laptop> I have a `test-suite` that depends on `foo`, so I imagine that's where it's coming from
20:24:51 <n0n3such> ;)
20:24:56 <joneshf-laptop> but i'm not sure how to fix
20:26:25 <johnw> orzo:  from a computer scientist point of view, I see category theory as giving us a framework for reasoning about a lot of different kinds of composition in a uniform way
20:26:35 <mmachenry> n0n3such: He is not blind to alternatives. You're nitpicking phrasing of sentences to win a debate.
20:27:01 <n0n3such> i'm not interested in winning debates, or for that matter having a debate
20:27:09 <n0n3such> i am interested in creative destruction
20:27:25 <edwardk> n0n3such: the claim i mentioned about that particular adjunction, however, does hold universally in haskell. it doesnt require any sort of fuzzy word games to muddle the water between different formalisms, the conditions are met for that formalism to apply, and we can bring all the bits and pieces together to prove that statement about haskell in particular.
20:27:25 <edwardk> it means i can stop looking for other adjunctions on that one particular category, and so by handling that one case i can know i'm 'done'. previously i spent an awful lot of time looking for others. now i can know that they are all isomorphic to that case. and given that insight i've been able to refactor a ton of code to exploit that representation.
20:28:25 <osa1> any ideas what's invalid about this: uncaught exception: ErrorCall (./Data/Vector/Generic/Mutable.hs:423 (slice): invalid slice (80000,96000,160000)) ?
20:28:37 <osa1> looks like indexes are in range
20:28:57 <n0n3such> edwardk: bravo !
20:29:14 <n0n3such> can't beat 'done'
20:29:39 <n0n3such> tty'all later gn
20:29:41 <edwardk> it means i can package those things up in code and know i'm not missing cases, and gives a guiding principle for code i have that deals with things from automatically computing derivatives in calculus to linear algebra, to playing with getters and setters in data types, to smart constructors, etc.
20:29:49 <edwardk> later n0n3such
20:31:34 <n0n3such> certainty is a marvelous thing ! later edwardk
20:38:49 <sdegutis> It's really frustrating that we can't reuse the sake record name for more than one type in the same module.
20:39:26 <MP2E> There's a few proposals in the works to address many problems with records
20:39:50 <orzo> edwardk: would you consider compiling a list of examples of the DOS attack on the brain situation, that'd be very interesting reading
20:41:19 <edwardk> orzo: it is something i think about fairly often. of course compiling such a list is a meta-DOS ;)
20:41:23 <orzo> i was a grad student in math and for some reason could never get very excited about category theory, even though the course would give numerous examples, somehow it felt unmotivated
20:41:49 <edwardk> one of the main things i learned with category theory was to hunt for initial or terminal solutions to a problem
20:41:58 <edwardk> because all the other solutions would factor through them one way or the other
20:42:18 <edwardk> so even if you don't want to use my code, you'll use the idea, because it is part of any other solution you come up with ;)
20:42:30 <shachaf> Is there anything you learned with category theory that *isn't* about finding an initial solution to some problem? :-)
20:42:45 <edwardk> shachaf: i'd be surprised =)
20:42:54 <shachaf> Universal properties are an important idea.
20:43:02 <edwardk> exactly
20:43:11 <edwardk> they kind of are the point of adjunctions, etc.
20:43:29 <shachaf> Mostly it's not necessarily about finding answers so much knowing what questions to ask.
20:43:44 <edwardk> and category theory is really all about adjunctions, so what do you have left? =)
20:44:35 <monochrom> http://www.vex.net/~trebla/photo/unorganized/IO-String.png
20:48:13 <ab9rf> answers are overrated
20:53:18 <acomar> edwardk: any thoughts on my question from earlier?
20:53:47 <edwardk> acomar: that it'd require knowing exactly the nature of the zipper you are using, e.g. what are the traversals or lenses you walk into the structure with?
20:53:58 <edwardk> you do generally have to save your location and walk back down, yes
20:54:18 <edwardk> but if your structure is traversed based on indices the 'tape' you can save should be fairly robust against edits
20:54:34 <edwardk> e.g. if it uses keys in a map rather than just position side-to-side
20:55:00 <acomar> ok fair enough
20:55:07 <Lokathor> when might the haskell platform 2015 come out?
20:55:22 <MP2E> probably several months after GHC 7.10.1 comes out if last year is any indication :P
20:55:26 <edwardk> Lokathor: that is pretty much up to mzero
20:55:36 <edwardk> Lokathor: typically in Q2 though i think
20:55:54 <Lokathor> well that's soon enough for my purposes then, thanks
20:57:00 <edwardk> MP2E: well that also depends on if Mark deems 7.10 as a stable enough target for the platform to adopt, and given that he didn't do so with 7.8 last year at this time, and his rather severe reservations about not just FTP but AMP as well indicates what the likely reception 7.10 has in stock for the next platform. ;)
20:57:29 <edwardk> MP2E: the platform has always favored stability
20:57:47 <MP2E> that makes sense, it's a good stance to take
20:57:49 <dfeuer> Stability is a myth.
20:57:55 <MP2E> I have no issues with AMP or FTP though :)
20:57:59 <MP2E> I welcome them happily :P
20:58:21 <orzo> Lokathor: what OS do you use if I might ask?  I'm curious if windows/mac users are more concerned with the "haskell platform" than linux users are (i use linux and barely think about it for better or worse)
20:59:00 <MP2E> NixOS actually removed the platform entirely because there's little point for it with nix around :P
20:59:14 <Lokathor> I use windows, and my haskell install regularly explodes. Currently I have none on this machine actually. I was wondering when i should check for a newer platform install.
20:59:36 <Lokathor> on my debian machines i just install ghc/cabal-install/etc through the manager directly, as you suspect
20:59:45 <dfeuer> carter++
21:00:11 <carter> dfeuer: i try to help peopl:)
21:00:24 <fread2282> I installed haskell on windows by unpacking ghc and cabal in the same directory then setting PATH, is working fine so far
21:00:39 <ahihi> with the opengl library, is there a way to use float-typed uniforms? it seems the Uniform class has no suitable instance: http://hackage.haskell.org/package/OpenGL-2.10.0.0/docs/Graphics-Rendering-OpenGL-GL-Shaders-Uniform.html#t:Uniform
21:01:33 <Lokathor> fread2282, that works, but then many libraries are fiddly to get working from there
21:02:13 <fread2282> Lokathor: which ones?
21:02:56 <fread2282> looks like ghc bundles mingw, which explains why things have been working so far
21:03:04 <Lokathor> specifically SDL was the one that i cared about the most and couldn't get running myself (though a friend was able to sit down and sort it out for me just to prove me wrong when i'd given up)
21:09:14 <carter> ahihi: you should check out the gl package by edwardk  and Polarina
21:09:43 <ttt_fff> is purescript the best solution to the haskell /js problem ?
21:11:27 <orzo> MP2E: page out of date? "a good way to get started is to install the current Haskell Platform: " -- https://nixos.org/wiki/Haskell
21:12:10 <edwardk> ahihi: the lack of float uniforms in OpenGL is rather maddening. i filed a bug a couple months back.
21:14:16 <MP2E> orzo: quite out of date actually, heh. haskell platform is now out in stable, and on the bleeding edge of things we've actually deprecated haskellPackages entirely :P
21:14:27 <MP2E> haskellngPackages is being phased in
21:14:57 <MP2E> (haskellPackages broke with GHC 7.10)
21:15:22 <MP2E> oops awkward wording
21:15:27 <MP2E> by 'now out' i mean taken out entirely.
21:17:38 <MP2E> *sigh* yikes I should take some time to update this wiki page.
21:18:12 <Sornaensis> <Enigmagic> Sornaensis: sounds like you're using ghc 7.8.3 but it's reading interface files from 7.8.4? <-- GHC says it's version 7.8.4, booted by 7.8.3. What does that mean?
21:18:47 <ahihi> carter: gl looks somewhat lower-level; I think porting my current engine just for this isn't worth it :)
21:19:01 <carter> ahihi: fair nuff
21:19:08 <ahihi> edwardk: a workaround I found is to wrap the float in TexCoord1... rather horrible but it works
21:22:30 <edwardk> ahihi: that is exactly what i wound up doing too
21:22:41 <edwardk> ahihi: but when you get to wanting to send a matrix you'll be dead in the water, watch out
21:23:23 <ahihi> D:
21:27:21 <orzo> does anybody know if there's an actual theoretical advantage as opposed to merely a smoother migration path to using richard eisenberg's approach to dependent types while maintaining haskell's run-time/compile-time value/type distinctions over the more direct path that edwin brady took in creating idris?
21:29:09 <dmwit> orzo: by "brady's approach" you mean "write a compiler"?
21:29:27 <orzo> yeah, but brady actually said he started out thinking "what if haskell had dependent types"
21:30:01 <orzo> it's not like he wasnt a haskeller wanting a dependent type language
21:31:17 <dmwit> theoretical advantage is you don't have to write an optimizing compiler from scratch
21:31:21 <krakrjak> orzo: Stephanie Weirich is exploring that idea through Haskell instead of through a new language.
21:31:38 <dmwit> otherwise none that i know of
21:31:52 <athan> dmwit: ...can I show you?
21:32:12 <dmwit> show me what?
21:32:16 <athan> :D http://deconfigured.com/blog/atlc5
21:32:30 <athan> it's kinda.. weird
21:32:40 <athan> but, it works I thinks
21:33:46 <dmwit> have you managed to describe the problem you're solving yet
21:33:50 <orzo> not having to write an optimizing compiler from scratch seems more a practical advantage than a theoretical one.  I was thinking how the end result will be different.  It seems clear the haskell varient will have more distinctions and maybe just more syntax and clutter for the coder with no benifit other than that the compiler is more mature and optimized or whatever
21:36:03 <orzo> not that i'm going to use idris any time soon as i gave up on it after wasting too much time trying to figure out the errors in my code
21:36:40 <athan> dmwit: poly-arity higher-order function application
21:37:04 <dmwit> athan: that's a solution, not a problem
21:37:18 <fread2282> orzo: haskell's run-time/compile-time value/type distinctions are nasty?
21:37:40 <orzo> fread2282: for type-level coding? yeah i suppose so
21:38:24 <dmwit> athan: tell me about some code i write every day, but in a crappy way
21:38:25 <orzo> fread2282: compare the singletons package on hackage and accompaning documentation with tutorials on idris-lang.org
21:38:26 <athan> dmwit: cascading potential parameters with that ideal soltuion
21:38:36 <dmwit> convince me it's crappy
21:38:45 <athan> dmwit: I like the term "mashin together"
21:38:52 <athan> so
21:39:00 <athan> all you need to do, is just mash this stuff together
21:39:08 <athan> and, tada :D
21:39:15 <athan> hmm
21:39:22 <athan> rewriting type signatures
21:39:31 <athan> when changing the schema of your higher order functions
21:39:37 <athan> that's the problem this addresses
21:39:49 <fread2282> orzo: I'll be happy with haskell's types when I can write instance Monad id (you can do this in idris & agda) (a idTypeLevel is fine, but type families aren't powerful enough)
21:40:41 <dmwit> ?google byorgey ad hoc parameter generalization
21:40:43 <lambdabot> https://byorgey.wordpress.com/2010/04/03/haskell-anti-pattern-incremental-ad-hoc-parameter-abstraction/
21:41:03 <athan> :O!
21:41:10 <dmwit> athan: what sucks about the standard solution?
21:41:19 <athan> :|
21:41:34 <athan> It's not well known lol
21:41:55 <orzo> i was just wondering if there was an actual benefit of maintaining the phase distinction other than making change incrementally
21:43:00 <MrMetric> Can I get feedback on a short bit of code here?
21:43:02 <dmwit> orzo: efficiency; but nothing stops idris from making the same distinctions
21:43:32 <pjdelport> MrMetric: Paste away!
21:43:37 <MrMetric> Yay!
21:43:44 <dmwit> orzo: hence my "otherwise no advantage" comment right when you first asked
21:43:53 <MrMetric> I made my first ever FizzBuzz
21:43:59 <orzo> dmwit: i would think efficiency, but edwin seems to claim his types are "erased at run time" and i assume he's maintaining any neccessary distinctions in the background so that the programmer does not have gto be aware
21:44:11 <lpaste> MrMetric pasted “fizzbuzz.hs” at http://lpaste.net/119924
21:44:41 <MrMetric> According to lpaste, I have redundant brackets and a redundant do :[
21:44:45 <dmwit> orzo: why are you still asking this when you have the answer already
21:44:54 <athan> dmwit: This isn't good enough
21:45:01 <Rotaerk> MrMetric, the do isn't necessary because you only have one IO action
21:45:03 <mniip> MrMetric, stuff like rem is usually written infix
21:45:12 <mniip> a `rem` 3
21:45:19 <MrMetric> Rotaerk: I understand why, I just didn't think of it when I made the code :[
21:45:21 <athan> You would still need to track down the data declarations and change them
21:45:26 <pjdelport> MrMetric: Saying "do action", for a single action, is always the same as just saying "action".
21:45:29 <athan> mine automatically handles the cascade
21:45:46 <pjdelport> MrMetric: You only actually need the do block if you have more than one action, like saying "do first; second"
21:46:09 <MrMetric> I've deleted the do bit and the redundant parens
21:46:18 <dmwit> athan: i encourage you to make a short blof post explaining the details of your complaint
21:46:19 <athan> (once I write the interpreter)
21:46:25 <MrMetric> mniip: Do I have to use infix style? I don't really like it
21:46:29 <athan> whyyyy
21:46:40 <fread2282> orzo: an advantage of singleton types is that you can use then to do things like represent Nats using peano at compile time (or whatever ideal model) and GMP at run time (or whatever efficient implementation). this isn't about haskell however (but I bet you could do this in haskell)
21:46:44 <pjdelport> MrMetric: The brackets around the (rem a 15 == 0) are technically redundant, but in my opinion they also enhance readability, so you don't *have* to remove them. :)
21:46:53 <pjdelport> MrMetric: That's why it's just a warning, and not an error.
21:46:59 <MrMetric> pjdelport: Hmm, alright
21:47:00 <athan> dmwit: Thank you
21:47:17 <MrMetric> I'm just thinking about how I could shorten this
21:47:23 <pjdelport> MrMetric: What you can do, though, is to create a helper function for the divisiblity testing.
21:47:25 <MrMetric> I'm glad that it at least compiled on the first try
21:47:31 <mniip> "shorten" heh
21:47:37 <fread2282> imo, that's a bad idea, because now compile time can be **really** slow, and instead we should just use gmp at compile time
21:47:41 <MrMetric> mniip: Eh?
21:48:07 <fread2282> but then we need a smt solver for unification involving nats
21:49:28 <fread2282> or a ring solver, if we limit what we can do w/ nats
21:50:04 <fread2282> iirc
21:50:45 <Rotaerk> huh, I didn't know about the LambdaCase extension
21:52:57 <MrMetric> Why do I need to specify Show along with Integral? Are there some mystical Integral values that can't be shown?
21:53:14 <johnw> Integral doesn't imply Show
21:53:21 <MrMetric> I'm asking why that is
21:53:22 <johnw> a thing could be Integral but not be Show
21:53:27 <orzo> fread2282: but maybe there exists some better example than Nat that you wouldn't object to?
21:54:37 <johnw> although I guess in that case a default Show instance would always be possible...
21:54:38 <pjdelport> MrMetric: All the built-in Integral types are also Show-able, but that's not a requirement in general. Remember that anyone can create new Integral types, and they might not have an obvious Show instance.
21:54:57 <johnw> i.e., show . toInteger
21:55:18 <MrMetric> pjdelport: I don't see why an Integral type would ever not be showable
21:55:22 <fread2282> orzo: i object anything that slows down compiles by an order of magnitude, and I think most if not all uses of singleton types for reasoning about an external implementation do that :)
21:55:29 <fread2282> *object to
21:55:35 <pjdelport> MrMetric: Num actually used to require Show as a superclass, but that got removed circa Haskell 7.4.
21:55:58 <MrMetric> pjdelport: Are there numbers that don't have a string representation?
21:56:13 <athan> dmwit: heterogeneous function application, maybe
21:56:14 <HeladoDeBrownie> arguably it'd be more magical if Num did imply Show. there's no deep link between the two. but then again, Num is fairly arbitrary.
21:56:34 <athan> which makes, really, all function types homogeneous
21:57:03 <HeladoDeBrownie> er, Integral. either one really
21:57:13 <fread2282> but Integral has toInteger, so a show instance must exist?
21:57:23 <glguy> MrMetric: Yes this are some function types that make sense to have a Num instance that don't admit a Show instance
21:57:30 <glguy> there are*
21:57:45 <MrMetric> glguy: May I have an example?
21:58:03 <glguy> MrMetric: first one that comes to mind: http://hackage.haskell.org/package/contravariant-1.2.0.1/docs/Data-Functor-Contravariant.html#g:6
21:58:50 <MrMetric> I've no idea what this is
21:58:56 <Rotaerk> lol
21:59:12 <MrMetric> læl
21:59:22 <fread2282> orzo: but sinleton types can be used to reason about an external implementation, which is more general than just as a hack in haskell
22:00:34 <pjdelport> MrMetric: It's an example of a Num instance for functions.
22:01:36 <pjdelport> MrMetric: Basically, the idea is that you can say for example: f + g = \a -> f a + g a
22:01:37 <fread2282> MrMetric: instance Num a => Num (b -> a)
22:02:08 <fread2282> wrapped up in a newtype
22:02:08 <MrMetric> I've never heard of contravariant things, cofunctors, or functors. I also don't think ADT means what I'm thinking of (Android) :P
22:02:24 <orzo> heh
22:02:29 <ab9rf> hehe
22:02:33 <pjdelport> ADT means "Algebraic Data Type", in this context.
22:02:33 <mniip> oh god I just typed hoogle into hoogle
22:02:42 <ab9rf> mniip: did the internet explode?
22:02:45 * MrMetric claps moderately
22:03:00 <mniip> no looks more like it imploded
22:03:03 <joelteon> so show-details=always in cabal test doesn't seem to help a whole lot, it still saves all the output for teh end
22:04:11 <pjdelport> MrMetric: Anyway, what that Num instance lets you do is to take functions of some common type, and directly do arithmetic operations on them, to get new functions that will do the actual arithmetic operations on the input functions' results.
22:04:54 <MrMetric> wut
22:05:04 <Rotaerk> f = (+1) + (*3)
22:05:19 <Rotaerk> f 3 = 3+1 + 3*3
22:05:19 * hackagebot equational-reasoning 0.2.0.5 - Proof assistant for Haskell using DataKinds & PolyKinds  http://hackage.haskell.org/package/equational-reasoning-0.2.0.5 (HiromiIshii)
22:05:29 <Rotaerk> I think?
22:05:33 <orzo> yeah
22:05:58 <fread2282> f + f = ((+1) + (*3)) + ((+1) + (*3))
22:06:09 <fread2282> I think?
22:06:14 <fread2282> no
22:06:36 <fread2282> f + f = \a -> ((+1) + (*3)) a + ((+1) + (*3)) a
22:07:07 <Rotaerk> you're right the first time though
22:07:20 <pjdelport> MrMetric: Imagine you have a Person data type, with various fields that you can read.
22:07:23 <Rotaerk> and the second
22:07:45 <fread2282> Rotaerk: yea, but (+) on it's own looks too much like (.)
22:07:57 <MrMetric> pjdelport: Do I need to know how to do data type stuff in Haskell for this?
22:07:59 <pjdelport> This lets you say things like: (getAge + getHeight) * getFoo
22:07:59 <pjdelport> instead of: \person -> (getAge person + getHeight person) * getFoo person
22:08:07 <MrMetric> I started using Haskell 2 days ago
22:08:14 <orzo> (f+f) 4 = 4+1 + 4*3 + 4+1 + 4*3
22:08:43 <pjdelport> MrMetric: Oh, you probably don't need to worry about all this then. You will learn more about this as you go along. :)
22:09:35 <orzo> this isn't actual haskell, btw, MrMetric, the code referenced actually wrapped the functions and didn't define Num on the function type directly
22:09:40 <pjdelport> The key thing is that Haskell data types can get *really* flexible though, and it's entirely possible (and sometimes even routine) to have things like Num instances that don't have a Show instance.
22:10:02 <orzo> not that it couldn't have, but probably not a good idea
22:10:10 <fread2282> MrMetric: for Integral, imagine that there is a string representation, but it's strange, so you don't want to expose it for easy use via a Show instance
22:10:22 <pjdelport> Because Num instances can be things like functions, weird polynomials, or things that are even more exotic.
22:11:15 <MrMetric> ._.
22:11:26 <Rotaerk> just because all types that are an instance of TC1 can also be made instances of TC2, doesn't mean the type classes themselves should be interdependent
22:11:35 <orzo> do you know 'newtype' yet MrMetric ?
22:11:57 <MrMetric> orzo: I do not recall seeing that word ever
22:12:17 <orzo> well, 'data' then
22:14:44 <MrMetric> orzo: I've seen 'data', but never used it
22:14:55 <orzo> hm
22:15:12 <orzo> would have guessed that's in day 1
22:15:16 <orzo> heh
22:15:50 <MrMetric> Eh?
22:16:23 <EvanR> data keyword is pretty fundamental
22:16:55 <MrMetric> I'm sure I'll find out what it's for eventually
22:17:20 <EvanR> its for data types ;)
22:17:27 <EvanR> spoiler alert
22:17:32 <MrMetric> :P
22:18:05 <orzo> ADTs in particular heh
22:18:07 <mniip> I guess you could get rid of the data keyword
22:18:27 <mniip> and use only newtype, Either, and tuples xD
22:18:56 <orzo> mniip: naw, i recommend () and functions
22:19:11 <EvanR> just functions
22:19:14 <orzo> heh
22:19:22 <EvanR> worst programming language ever
22:19:24 <MrMetric> Here's a thing I made a while ago: https://www.reddit.com/r/shittyprogramming/comments/2pj9dp/how_can_i_improve_my_python_hello_world_script/
22:19:32 <MrMetric> I'm thinking I'd like to do this with Haskell (as soon as I know how)
22:19:35 <MrMetric> :]
22:19:50 <mniip> functions heh
22:20:08 <pjdelport> MrMetric: If you like that, you might enjoy https://themonadreader.files.wordpress.com/2014/04/fizzbuzz.pdf :)
22:20:40 <MrMetric> I am a fan of FizzBuzzEnterpriseEdition (by EnterpriseQualityCoding)
22:21:45 <pjdelport> That would be the very functional version of FizzBuzz; but it's actually a serious implementation, using the problem to illustrate a bunch of neat techniques.
22:22:25 <MrMetric> Hmm
22:22:37 <MrMetric> I'll look at this PDF shortly
22:22:40 <MrMetric> Gotta try something first!
22:27:13 <pjdelport> MrMetric: At the other extreme, here's an example of how compact it can get in Haskell:
22:27:13 <pjdelport> > let (m ~> s) x = s <$ guard (x `mod` m == 0); fizzbuzz = map (fromMaybe . show <*> 3 ~> "fizz" <> 5 ~> "buzz") in fizzbuzz [0..]
22:27:14 <lambdabot>  ["fizzbuzz","1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fiz...
22:27:37 <pjdelport> (courtesy of http://www.reddit.com/r/haskell/comments/2cum9p/i_did_a_haskell_fizzbuzz/cjj7g65 )
22:28:39 <orzo> ghc's module dependency graph: http://jerkface.net/~joe/ghc.tred.svg
22:29:07 <orzo> may have to zoom out
22:29:29 <MP2E> pjdelport: wow that's great !
22:29:46 <MP2E> i've seen the fizzbuzz problem before
22:30:20 * hackagebot type-natural 0.2.3.2 - Type-level natural and proofs of their properties.  http://hackage.haskell.org/package/type-natural-0.2.3.2 (HiromiIshii)
22:30:36 <glguy> > imap (\i x -> if null x then show i else x) (zipWith (++) (cycle ("fizz" : replicate 2 "")) (cycle ("buzz" : replicate 4 "")))
22:30:38 <lambdabot>  ["fizzbuzz","1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fiz...
22:30:44 <glguy> I like that one because it didn't use "mod" directly
22:31:36 <Zemyla> glguy: That's what I was trying to write. :P
22:31:40 <pjdelport> Yeah, that's the other common approach in Haskell, which is quite nifty.
22:33:33 <Zemyla> Also, it really feels like if you shake just about any problem involving state hard enough, a monad falls out.
22:34:16 <shachaf> I think State is usually not the right answer to "problems involving state".
22:34:40 <shachaf> Unless you define the latter as problems for which State is the right answer, or something.
22:35:35 <MrMetric> I modified my fizzbuzz to work with a list like this:
22:35:36 <MrMetric> tests = [(3, "Fizz"), (5, "Buzz"), (7, "Poop"), (11, "Pope")]
22:35:41 <MrMetric> So now I can just add whatever there
22:35:48 <Zemyla> I mean I was working on a problem, and I figured, "This will be simple, I don't need to make a monad for it."
22:36:08 <pjdelport> MrMetric: That's a good instinct.
22:36:20 <tel> Stage 0, you need state and gnash and cry out. Stage 1, you miss state and don't understand why it was taken from you. Stage 2, you accept the monad and take state from its hand. Stage 3, you fail to remember why you ever wanted state in the first place.
22:36:34 <MrMetric> pjdelport: What is?
22:36:58 <pjdelport> MrMetric: Separating out the factors and strings like that.
22:37:10 <MrMetric> Ah
22:37:20 <pjdelport> (In real code, that's the kind of thing you'll want to do.)
22:37:21 <jle`> Stage 4 is when you realize how unmaintainable and unreadable and obfuscating having state makes code
22:37:23 <orzo> removing state makes algorithms more clear
22:37:45 <Zemyla> tel: Well, I was working on parsing that takes full ByteStrings and pulls out as much as possible, sometimes requiring more data.
22:37:47 <orzo> too bad the RFCs all use stateful pseudocode
22:38:40 <tel> Zemyla: I was being a little facetious, sorry. I think parser combinators are a fine place to use state monads.
22:38:43 <lpaste> MrMetric pasted “fizzbuzz.hs” at http://lpaste.net/119925
22:38:51 <MrMetric> Feel free to tell me what I did wrong :]
22:39:09 <glguy> it looks like you forgot to tell us what's wrong
22:39:37 <MrMetric> Oh
22:39:44 <MrMetric> No, that's not what I mean
22:39:44 <orzo> X509 algorithm, state free: http://jerkface.net/~joe/Validate.html#v:validate
22:39:48 <MrMetric> It runs and appears to work
22:40:05 <jle`> according to lpaste, you have a redundant bracket
22:40:06 <Zemyla> Yeah, and now I don't have to write "start deserializing" and "continue deserializing" functions.
22:40:22 <MrMetric> jlebacktick: I like the brackets :[
22:40:42 <MrMetric>                ^ But
22:40:56 <MrMetric> Dammit! Too many spaces!
22:40:59 <Zemyla> Question: Why is ViewL so sad?
22:41:09 <jle`> stylistically we like to either pattern match or use `null` instead of comparing something to ""
22:41:16 <jle`> or []
22:41:22 <jle`> :<
22:41:48 <jle`> um
22:41:52 <Zemyla> jle`: Yes. ViewL is really sad. :<
22:41:53 <jle`> foldl (++) "" is `concat`
22:42:04 <MrMetric> Of course that exists
22:42:05 <jle`> thingy might be more clear as a map
22:42:07 * MrMetric palmfaces
22:42:25 <jle`> thingy = concatMap (fizzbuzzstr num) tests
22:43:09 <jle`> list comprehensions are neat but often times simple maps and filters would do as well
22:43:18 <gamegoblin> Mmmm just got a 50% speed increase by sticking in INLINE pragma on everything
22:43:25 <MrMetric> That's the same as this? thingy = concat . map (fizzbuzzstr num) $ tests
22:43:28 <gamegoblin> an *
22:43:40 <jle`> MrMetric: yup
22:43:42 <jle`> @src concatMap
22:43:42 <lambdabot> concatMap f = foldr ((++) . f) []
22:43:54 <jle`> huh how unfortunate
22:44:02 <jle`> concatMap f = concat . map f
22:44:05 <MrMetric> What is foldr vs foldl?
22:44:23 <jle`> there's that haskellwiki page that has a good description
22:44:29 <jle`> @src foldl
22:44:29 <lambdabot> foldl f z []     = z
22:44:29 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
22:44:31 <jle`> @src foldr
22:44:31 <lambdabot> foldr f z []     = z
22:44:31 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
22:44:33 <MrMetric> To the Google!
22:44:33 <jle`> the two are different
22:45:10 <jle`> by the way, there is practically no use for `foldl` over the strict version `foldl'`
22:45:28 <jle`> it's sort of a bad design of the libraries that foldl is in prelude and not foldl'
22:45:43 <jle`> our bad, sorry
22:45:53 <neuroserpens> lol
22:45:55 <orzo> the burning bridges proposal isn't going to fix that one, is it?
22:46:10 <MrMetric> Alrighty then
22:46:13 <MrMetric> Allefty then
22:46:33 <tel> foldr f z (cons a (cons b (cons c nil))) = (f a (f b (f c z)))
22:46:38 <tel> foldl f z (cons a (cons b (cons c nil))) = (f (f (f z a) b) c)
22:46:55 <jle`> conceptually, foldr f z is like replacing every (:) with f and every [] with z
22:47:06 <jle`> i like to think of foldl conceptually as something gobbling up input from the front
22:47:15 <drewbert> What's the difference between ~/.ghc/*/package.conf.d and ~/.cabal/packages/*/ ?
22:47:48 <jle`> one benefit of foldr over foldl' is that if your `f` (the thing you are replacing every (:) with) is lazy on the second argument, you can make it work with infinite lists
22:48:05 <jle`> > foldr (||) False (repeat True)
22:48:06 <lambdabot>  True
22:48:23 <ab9rf> heh
22:48:34 <ab9rf> i like using infinite lists
22:48:39 <jle`> `True:True:True:True:....` (which is repeat True) is turned into True || True || True || True ...
22:48:52 <jle`> which you know is True after the first item
22:48:54 <jle`> @src (||)
22:48:54 <lambdabot> True  || _ =  True
22:48:54 <lambdabot> False || x =  x
22:49:30 <MrMetric> @src (&&)
22:49:30 <lambdabot> True  && x = x
22:49:30 <lambdabot> False && _ = False
22:49:39 <jle`> (&&) has the same trick :D
22:49:44 <MrMetric> Is there an xor?
22:49:49 <jle`> (/=) ?
22:50:00 <MrMetric> Isn't that != ?
22:50:01 <ab9rf> > True /= False
22:50:02 <lambdabot>  True
22:50:09 <gamegoblin> > True /= True
22:50:11 <lambdabot>  False
22:50:12 <jle`> yes, != is xor
22:50:16 <ab9rf> xor can't be lazy in either argument, of course
22:50:38 <jle`> you can also use `xor` from Data.Bits
22:50:45 <jle`> > True `xor` False
22:50:46 <lambdabot>  True
22:50:54 <jle`> i don't think it's in base...
22:50:55 <MrMetric> Oh, right, I forgot. xor is true if the 2 arguments are different
22:51:00 <gamegoblin> jle`: it’s not
22:51:01 <Cale> I think most people get caught by that at some point :)
22:51:03 <ab9rf> didn't realize xor had a defn on Bool
22:51:11 <Cale> (the "where's xor?" question :)
22:51:15 <jle`> @check \x y -> (x /= y) == (x `xor` y)
22:51:16 <lambdabot>  +++ OK, passed 100 tests.
22:51:25 <jle`> one hundred tests were definitely needed
22:51:30 <ab9rf> xor is strict in both of its arguments, i'm fairly certain
22:51:31 <MrMetric> Neat
22:51:31 <gamegoblin> Hahahaha
22:51:39 <Cale> @smallcheck \x y -> (x /= y) == (x `xor` y)
22:51:39 <lambdabot> Unknown command, try @list
22:51:39 <charlie> link to lambdabot source?
22:51:41 <Cale> hmm
22:51:47 <MrMetric> @src @check
22:51:47 <lambdabot> Source not found. stty: unknown mode: doofus
22:51:49 <ab9rf> charlie: it's in hackage
22:51:49 <MrMetric> :[
22:51:52 <charlie> ab9rf ~ ty
22:51:54 <tel> ha, I was just wondering about smallcheck too
22:51:56 <jle`>  @check is quickcheck
22:51:58 <Cale> I thought we had smallcheck in the bot at some point
22:52:02 <Cale> @list
22:52:02 <lambdabot> What module?  Try @listmodules for some ideas.
22:52:06 <Cale> @listmodules
22:52:06 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
22:52:08 <jle`> it generates random tests with inputs of the desired type
22:52:24 <Cale> @list check
22:52:24 <lambdabot> check provides: check
22:52:31 <MrMetric> Hopefully, it got all 4 cases
22:52:32 <Cale> nope
22:52:35 <Cale> oh, well :)
22:52:39 <jle`> @check \x y -> (x * y) <= (x^2 + y^2)
22:52:39 <ab9rf> "random" :)
22:52:40 <lambdabot>  +++ OK, passed 100 tests.
22:53:01 <MrMetric> @check \x y -> x + y == y + x
22:53:03 <lambdabot>  +++ OK, passed 100 tests.
22:53:05 <ab9rf> quickcheck can be a little inexhaustive in its checks
22:53:09 <jle`> um i definitely got my awkward statement of cauchy schwartz incorrect but it was still true...so nobody has to know i was triyng to incorretly prove cauchy schwartz...
22:53:21 <ab9rf> especially when one the free variables is a completely unrestricted type
22:53:52 <jle`> @check \a b c d -> (a*c + b*d) <= ((a^2 + b^2) * (c^2 + d^2))
22:53:54 <lambdabot>  +++ OK, passed 100 tests.
22:54:03 <charlie> It operates as a command line tool, embedded in an editor, embedded in GHCi, via internet relay chat and on the web.
22:54:08 <charlie> verry nice^
22:54:11 <jle`> haha
22:54:37 <charlie> has hackage always used git? what happened to darcs
22:55:04 <ab9rf> charlie: hackage is agnostic on that, it lists whatever the package submitter lists
22:55:17 <ab9rf> charlie: two years ago darcs was far more common than it is now
22:55:34 <jle`> i think you use cabal to submit to hackage
22:55:39 <jle`> so it doesn't really care
22:55:46 <ab9rf> these days there do seem to be far more git repos than darcs repos
22:55:50 <charlie> ab9rf ~ i see!
22:55:55 <jle`> the "source repo" link is just a field you can enter in on your .cabal file
22:56:01 <jle`> like "package name"
22:56:41 <ab9rf> you could put a link to a rick astley video there, and it wouldn't care
22:57:00 <jle`> my non haskelling friend made a haskell joke on my facebook
22:57:06 <MrMetric> ab9rf: Will this one work? https://www.youtube.com/watch?v=rgUrqGFxV3Q
22:57:15 <jle`> we were having a discussion and i posted, 'monads are going to change the world'
22:57:21 <jle`> and then he replied, 'because they're the only things allowed to'
22:57:35 <ab9rf> hehe
22:57:36 <Zemyla> jle`: Niiice.
22:57:37 <MrMetric> hue
22:57:59 <jle`> i actually didn't get it until i read it again :|
22:58:13 <jle`> i thought it was some commentary on the haskell community at first >_>
22:58:26 <drewbert> grrrr cabal
22:58:39 * drewbert considers sacrificing a goat.
22:58:46 <jle`> heh
22:58:47 <ab9rf> make sure it's a virgin
22:58:52 <pjdelport> jle`: You should point out that monads != IO. :P
22:58:54 <MrMetric> Do I need to slap you with my trout?
22:58:59 <orzo> i don't even use cabal for package management anymore
22:59:01 <orzo> heh
22:59:17 <jle`> i...actually really haven't ever had any problems with cabal
22:59:20 <jle`> ever since sandboxing
22:59:22 <drewbert> orzo: how do you work around it?
22:59:46 <orzo> drewbert: my methods are debian specific
22:59:54 <jle`> pjdelport: :P
23:00:13 <MP2E> I haven't had any trouble with cabal ever since i let nix take the reins
23:00:19 <jle`> i let it slide on a technicality in that the only thing allowed to perform IO in haskell happens to be a monad instance
23:00:36 <drewbert> But I need newer packages than are in my distro's repo.
23:00:43 <orzo> i have a script that almost never fails to turn a github cloned haskell package into aa native debian one
23:00:46 <jle`> only x can y does not necessarily imply all x's can y
23:01:04 <jle`> or...idk what i'm saying anymore.  can someone write a quickcheck to prove my propositional logic
23:01:10 <MP2E> haha
23:01:12 <ab9rf> hehe
23:01:20 <MP2E> write up a proof in coq/agda/idris!
23:01:27 <orzo> i think accumulate my packages into a local apt source
23:01:34 <ab9rf> coqdris?
23:01:42 <drewbert> orzo: I'm in ubuntu, maybe I can adapt it to my system?
23:01:51 <MrMetric> jlebacktick, are you saying there exists an x != for all x?
23:02:15 <MP2E> acoqdris, the ultimate amalgamation
23:02:25 <tel> Not (Ex X (Can Y) -> Forall X (Can Y))
23:02:30 <pjdelport> acoqdriskell?
23:02:46 <MrMetric> →
23:03:40 <MrMetric> Well, it's time for me to dream about things that may or may not be related to programming
23:04:02 <orzo> drewbert: apt-get install cabal-debian, then make a script that runs "mkdir debian && touch debian/changelog && cabal-debian --debianize" and invoke that script within a haskell package source tree obtained from github or whatever, there'll be some dependency chasing, but you get apt as your haskell package manager
23:05:03 <shachaf> I wonder why "exists" and "forall" are binders, anyway. Mathematicians make everything into binders.
23:05:27 <orzo> drewbert, avoid trying to install things already distributed in base, use chroots for with different ghc versions
23:05:48 <fread2282> what else would you use for a binder when writing dependent function types?
23:05:51 <jle`> pjdelport: Ex X (Can Y X) might not be the best translation of "only X can Y"
23:06:13 <tel> shachaf: what else would they be?
23:07:08 <shachaf> E.g. newtype Forall f = Forall (forall x. (f x))
23:07:13 <fread2282> jle`: forall A. Not (A = X) -> Not (Can A Y) ?
23:07:15 <jle`> Forall A ((Can Y A) -> A `elemOf` X)
23:07:44 <shachaf> And then Forall (\x -> ...)
23:07:46 <jle`> ah the contrapositive works too
23:09:01 <drewbert> orzo: I'm going to give that a shot!
23:10:28 <fread2282> shachaf: well you can have pi (forall) and lambda as one binder
23:10:33 <orzo> drewbert: i end up installing -doc -dev and -prof versions of everything even though the system packages them independently, you'll need them all as build depends for other debianized packages
23:10:46 <shachaf> Everything has built-in lambdas, that's all.
23:11:04 <shachaf> forall, exists, pi, sigma, lim, what not.
23:11:16 <shachaf> (The ones for integrals and derivatives are particularly strange.)
23:11:53 <tel> shachaf: so there's just one binding construct and its context sets its meaning
23:12:02 <orzo> drewbert: also, i use the version of cabal-debian in debian jessie, wheezy version too old (even for making wheezy packages).  I expect ubuntu will have a resonably late versoin but i dont know
23:12:10 <shachaf> mu and nu, too.
23:12:40 <fread2282> shachaf: how is using lambda any different than having another binder then?
23:12:50 <shachaf> No big difference.
23:13:10 <tel> maybe if you could talk syntactically about abstracting over binding
23:13:11 <shachaf> Maybe built-in lambdas is so convenient that programming languages should take a cue from maths and support it.
23:13:24 <tel> I guess you could state alpha equivalence once and for all
23:13:25 <shachaf> withFile f -> ...
23:15:07 <fread2282> how do you type Pi (the thing that uses lambda) without Pi (the binder) though?
23:15:18 <fread2282> if you're encoding like that
23:17:06 <fread2282> Pi : (x : Type) -> (f : x -> Type) -> Type
23:17:08 <fread2282> i think
23:17:12 <mniip> check out my fizzbuzzgolf
23:17:15 <fread2282> so that uses Pi
23:17:15 <mniip> > let f m y x|mod x y==0=m|True="" in map(head.dropWhile null.(\x->[f"fizz"3 x++f"buzz"4 x,show x]))[1..]
23:17:17 <lambdabot>  ["1","2","fizz","buzz","5","fizz","7","buzz","fizz","10","11","fizzbuzz","13...
23:17:21 <dmwit> exists id
23:18:23 <orzo> drewbert: this system has plenty of drawbacks i'm sure, but one big advantage for me is that it's easier to package my own haskell programs when all the depends are packaged
23:19:45 <shachaf> Pi : Pi (-> Type) -> Type, clearly.
23:20:02 <shachaf> I don't know.
23:22:41 <fumieval> is it possible to pass command-line arguments to ghc in cabal exec?
23:22:49 <mniip> I might have forgotten the rules of fizzbuzz, that should be f"buzz"5
23:24:02 <fumieval> oh, -- works, thanks
23:26:30 <EvanR> i think i need some guidance on an FFI problem. libmikmod takes a pointer to a structure of function pointers to load data from an iostream-like interface. i set it all up, call the foreign function, and as soon as it tries to call one of the functions it hangs and i have to kill -9 ghc.
23:26:35 <shiona> can i have a type that contains a map whose keys (and thus size) is forced, but values are lazy?
23:26:58 <shachaf> Data.Map.Lazy does this.
23:26:58 <EvanR> as soon as it calls back into haskell via a FunPtr, hang
23:27:28 <shiona> shachaf: ok, thanks
23:29:12 <ab9rf> mniip: that's not the classical fizzbuzz problem
23:29:41 <mniip> ab9rf, elaborate?
23:30:00 <ab9rf> mniip: i usually see it miultiples of 5 as 'buzz', but otherwise it think it's the same
23:30:06 <mniip> yeah, hence
23:30:07 <mniip> [10:20:06] <mniip> I might have forgotten the rules of fizzbuzz, that should be f"buzz"5
23:30:32 <ab9rf> mniip: ah, missed that
23:30:33 <drewbert> orzo: if I run into any major pitfalls, I'll let you know.  I'm nuking everything atm.
23:30:38 <ab9rf> mniip: i had to go poo :)
23:31:47 <johnw> highly inappropriate for this channel, ab9rf
23:32:18 <EvanR> ah, maybe i need -threaded
23:33:04 <ab9rf> johnw: i'm sorry, i wasn't aware that channel participants were required to deny their humanity
23:35:37 <johnw> We keep a semi-professional tone in #haskell, and some aspects of being human do not fit that tone.  You are welcome to speak about such details elsewhere.
23:38:15 <orzo> > map (\x -> case mod x 15 of { 15 -> "fizbuz"; 5 -> "buz" ; 3 -> "fiz" ; _ -> show x }) [0..]
23:38:16 <lambdabot>  ["0","1","2","fiz","4","buz","6","7","8","9","10","11","12","13","14","15","...
23:38:22 <ab9rf> johnw: you need to work on what "professional" is, then, as your conduct just now has not been professional by any reasnable standard.  good day.
23:38:25 <orzo> the boring way
23:38:27 <orzo> heh
23:38:36 <Cale> mod x 15 will never be 15
23:38:41 <orzo> oops
23:38:59 <orzo> > map (\x -> case mod x 15 of { 0 -> "fizbuz"; 5 -> "buz" ; 3 -> "fiz" ; _ -> show x }) [0..]
23:39:01 <lambdabot>  ["fizbuz","1","2","fiz","4","buz","6","7","8","9","10","11","12","13","14","...
23:39:16 <orzo> heh
23:39:20 <orzo> i screwed it up
23:42:05 <EvanR> maybe i need to explicitly say safe on the ffi import, rather than rely on the default being safe
23:44:10 <orzo> isn't "5" suppoesd to be mapped?
23:49:53 <orzo> > zipWith (\i c -> case c of 'Z' -> "fizzbuzz"; 'f' -> "fizz"; 'b' -> "buzz"; _ -> show i) [0..] $ cycle "Z..f.bf..fb.f.."
23:49:54 <lambdabot>  ["fizzbuzz","1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fiz...
23:59:41 <Arahael> So I've managed to find another 5 minute block to try learning more Haskell.
23:59:44 <pjdelport> > cycle ["fizzbuzz","1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fizz","13","14"]
23:59:46 <lambdabot>  ["fizzbuzz","1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fiz...
23:59:53 <speak> Arahael hehe good luck!
23:59:58 <Arahael> And so I've set up a new cabal project, etcetera, etcetera, but this time I'm thinking that I should try Literate Haskell.
