00:00:05 <EvanR_> and trigger the entry points with ghci
00:00:15 <funfunctor> back to the code.. can you see essentially what I am trying to do there? Cale
00:00:19 <Cale> funfunctor: So when you define an instance of the Functor type class in Haskell, you're always defining an endofunctor on the category of Haskell types. Same goes for Applicative and Monad, only those introduce additional structure.
00:00:26 <Cale> I really have no idea :)
00:00:33 <Cale> Let's see...
00:01:01 <L8D> EvanR_: That’s what I do, and I’d want something more interactive and convenient like GHCi
00:01:02 <EvanR_> L8D: i find that workflow is easier than even lisp repl, it doesnt forget what you tried
00:01:23 <L8D> EvanR_: I normally just define a quickie 'run' function
00:01:39 <L8D> EvanR_: for turning my expressions into IO
00:01:42 <EvanR_> yeah i used to do that, and redefine it, and redefine it every time it came time to re-test ;)
00:01:52 <EvanR_> now i just make a short program and ghci that
00:01:52 <L8D> EvanR_: but I also want to be able to test sequences of instructions
00:02:03 <EvanR_> then change the source, then reload the file
00:02:06 <EvanR_> repeat
00:02:21 <L8D> EvanR_: but that’s not interactive -.-
00:02:28 <L8D> EvanR_: but ok.
00:02:36 <EvanR_> your last statement is a hard sell at best ;)
00:03:14 <L8D> Changing, reloading and re-running a file over and over again isn’t nearly as interactive as typing raw expressions into a REPL
00:03:20 <L8D> in my opinion
00:03:25 <Cale> funfunctor: Which System.Log is this?
00:03:29 <EvanR_> whatever it is, its faster
00:03:33 <L8D> true
00:03:33 <EvanR_> :reload
00:03:54 <EvanR_> you dont rerun the whole file btw
00:03:57 <EvanR_> its not python
00:04:00 <funfunctor> Cale: hslogger
00:04:01 <L8D> no I mean I
00:04:15 <shachaf> Functor is injective on objects, but that doesn't seem like a very categorical thing to say. What would be better to say about it?
00:04:20 <L8D> I’d have to run said monadic action in IO
00:04:24 <L8D> from the start
00:04:51 <EvanR_> not necessarily
00:05:03 <L8D> if I had a sequence of instructions, like DB queries, I’d have to reload the module which contains the queries, reset the DB, then run the querieis
00:05:15 <EvanR_> test just the subsequence you are interested in, with the context you want it to be executed in
00:05:33 <EvanR_> you dont need to reset the db connection, you can save it and provide it next time
00:05:52 <L8D> maybe I’m doing something wrong
00:06:05 <EvanR_> if you have a huge stack of monad transformers, its likely
00:06:20 <L8D> well, it’s 3 monad transformers
00:06:47 <EvanR_> to test database queries in particular, you just need the connection and the query
00:06:55 <EvanR_> the test generating a query, you dont even need the connection
00:07:13 <L8D> EvanR_: I would be testing them on the DB
00:07:14 <EvanR_> to test other stuff, you need other stuff
00:07:33 <EvanR_> well since youre in ghci, you can save correctly generated queries and just use them on the db
00:07:44 <Cale> funfunctor: So, I take it you somehow got fed up with passing around a value of type GenericHandler Handle, and a String?
00:07:48 <EvanR_> compartmentalize
00:07:54 <L8D> I guess so
00:08:38 <EvanR_> youre still doing better it sounds like from the way ive seen people test stuff, restart entire server programs, go through a sequence of GUI actions, then wait 30 seconds for a result after each change to the code
00:10:11 <funfunctor> Cale: yes
00:10:26 * hackagebot transformers-compat 0.4.0.2 - A small compatibility shim exposing the new types from transformers 0.3 and 0.4 to older Haskell platforms.  http://hackage.haskell.org/package/transformers-compat-0.4.0.2 (EdwardKmett)
00:10:26 * hackagebot transformers-compat 0.4.0.3 - A small compatibility shim exposing the new types from transformers 0.3 and 0.4 to older Haskell platforms.  http://hackage.haskell.org/package/transformers-compat-0.4.0.3 (EdwardKmett)
00:10:30 <funfunctor> Cale: I want to create a logging instance per system componenent
00:10:48 <funfunctor> Cale: If that makes sense?
00:12:41 <Cale> funfunctor: Personally, my approach would be to still pass around parameters rather than to force myself to liftIO everything, but this GenericHandler type and the operations on it seem like more than what you'd really want. I'd probably do something like instead pass around a function of type  LogRecord -> IO (), which would be an application of 'handle' to the appropriate handler and log name.
00:13:29 <Cale> (the order of arguments to handle is weird, I question John's judgement there... why make the log name last?)
00:14:06 <funfunctor> Cale: sorry where?
00:14:16 <Cale> https://hackage.haskell.org/package/hslogger-1.2.7/docs/System-Log-Handler.html
00:15:26 <Cale> funfunctor: So at the top level of the application, I'd do the stuff involving setLevel and setFormatter, as well as close
00:16:05 <Cale> funfunctor: And I'd pass something like (\pri msg -> handle h (pri, msg) logname) down to the stuff which needed to do logging.
00:16:09 <funfunctor> Cale: how would I deal with making sure close is always called, I usually try to use bracket for this
00:17:15 <Cale> You *could* use bracket, but if you set things up like I'm talking about, there's less worry that you'll miss it, because the call to close will be within a couple lines of the code which sets up the logging.
00:17:47 <funfunctor> Cale: maybe I am miss understanding it
00:17:58 <Cale> I guess you have to worry a bit if there's a bunch of different ways for your program to finish
00:18:14 <funfunctor> Cale: can you sort of show me a test case please?
00:18:26 <Cale> all right
00:18:28 <funfunctor> yea I am trying to figure out how it fits in with the rest
00:18:39 <EvanR_> when the program finishes, the log will be closed even if you dont do it explicitly
00:18:41 <funfunctor> wonderful thanks!
00:18:44 <Cale> Let me just install this package
00:19:37 <Cale> EvanR_: Yeah, that's probably also true, there's likely not much which really needs to be done in that regard
00:20:21 <funfunctor> Cale: this is essentially how I am using logging in one componenet http://pastebin.com/n3eVvsJ8
00:20:29 <funfunctor> Cale: just for your interest
00:20:52 <Cale> sz == (BladeRF $ liftIO $ return FPGA_UNKNOWN) -- how is that possibly going to work?
00:21:03 <Cale> Unless you have a broken Eq instance...
00:21:05 <jle`> can we agree that a shorter alias of liftA2/liftA3 is called for
00:21:11 <Cale> jle`: huh?
00:21:17 <jle`> la2, la3, maybe
00:21:23 <Cale> jle`: You can define those locally
00:21:28 <funfunctor> EvanR_: thing is, the project has many components that need logging
00:21:32 <jle`> yes but maybe it can be a commonly used idiom
00:21:35 <Cale> If you really use those functions that much...
00:21:36 <jle`> like how people use `io` for liftIO
00:21:40 <funfunctor> Cale: oh that does not work.. It was commented out..
00:21:52 <EvanR_> funfunctor: the logging component can serve the other components
00:22:03 <jle`> Applicative is supposed to abstract away function application in contexts... <$> and <*> in f <$> x <*> y is really supposed to be "read" as "f x y"
00:22:15 <jle`> the <$> and <*> are just line noise
00:22:22 <funfunctor> EvanR_: but it needs to close the file handle else the resource will become busy
00:22:24 <Cale> funfunctor: yeah, you can't compare IO actions, and so you're very unlikely to be able to compare liftIO'ed IO actions as well
00:22:39 <jle`> `la2 f x y` may help make it more streamlined
00:22:50 <EvanR_> funfunctor: well, if thats really true, the logging component is a good place to do that stuff
00:23:16 <EvanR_> im not sure what busy means here though
00:23:45 <funfunctor> Cale: yea I didn't figure out how to deal with that bit of the project yet.. I have a binded haskell function to some C than comes back with a value of what type the hardware is in the form of a C enum. I decode that using a Enum instance in the binding but its wrapped up in a IO action.. I need to figure that out later..
00:23:45 <EvanR_> jle`: banana bracket syntax?
00:24:13 <Cale> funfunctor: It's important that you not think of IO actions as being values that are wrapped up in something
00:24:40 <Cale> funfunctor: A value of type IO String is like a String in the same sense as /bin/ls is like a list of files.
00:25:01 <funfunctor> Cale: oh sorry, what I mean to say is that there is a value that is happens to occur while the IO action is in flight
00:25:53 <Cale> funfunctor: You get the results of IO actions by executing them, so you'll have to execute the IO action you get if you want to check what its result was.
00:26:41 <Cale> (This might seem like I'm being picky, but I really do think it's important to be careful about it :)
00:26:53 <funfunctor> Cale: here is the function to make it clear what I mean.. http://pastebin.com/siVMSqYF
00:27:18 <Cale> Right, and the thing you just pasted doesn't count as a function ;)
00:27:39 <funfunctor> Cale: sorry C background.. IO action rather
00:27:42 <Cale> right
00:28:48 <mrkkrp> Hello, where cabal keeps records about installed packages? I want to do some testing and I need to uninstall everything. I've deleted ~/.cabal directory, but cabal still thinks that some packages are installed.
00:28:49 <Cale> How is this BladeRF type defined?
00:29:01 <funfunctor> Cale: my main point is, IO action does atomic computation (dispatches out to C "function" talks to hardware, finds a magic int and comes back as a enum type) but now we have our Enum instance in Haskell as the result of this IO action so its uncomparable
00:29:11 <funfunctor> just a sec
00:29:45 <funfunctor> Cale:  newtype BladeRF a = BladeRF { unBladeRF :: ExceptT BladeRFError (StateT (Ptr C'bladerf) IO) a } deriving (Monad, MonadIO)
00:30:22 * hackagebot shell-conduit 4.5.1 - Write shell scripts with Conduit  http://hackage.haskell.org/package/shell-conduit-4.5.1 (ChrisDone)
00:30:45 <funfunctor> The Haskell binding I built is monadic in structure around the C libbladeRF.so library
00:31:09 <funfunctor> Cale: that pointer type is the device handle
00:31:24 <funfunctor> hopefully I am making sense?
00:31:45 <Cale> funfunctor: So in order to do something that will execute this BladeRF action you're receiving as an argument in choiceFPGA, you'll need to produce a BladeRF action as the result.
00:32:16 <Cale> funfunctor: Most likely, you really just want to take a BladeRFFPGASize as an argument to this choiceFPGA function.
00:32:30 <funfunctor> Cale: yes
00:32:33 <funfunctor> exactly
00:32:50 <funfunctor> but there is no unIO that exists
00:32:53 <Cale> because you don't really need to execute the sz action more than once or something
00:32:56 <Cale> that's right
00:33:03 <Cale> You can only execute IO actions inside other IO actions
00:33:09 <funfunctor> right!
00:33:18 <funfunctor> indeed, so
00:33:31 <funfunctor> hence the mess I made at the top of that file..
00:33:32 <Cale> and you can "only" execute BladeRF actions inside other BladeRF actions (except that's not quite true, you have ways to turn them into IO actions)
00:34:05 <funfunctor> Cale: let me paste you my BladeRF interface which is at the core of the binding
00:34:18 <Cale> Taking an argument sz of type BladeRF BladeRFFPGASize means that you have an action that you could run more than once!
00:34:22 <supki> mrkkrp: ~/.ghc
00:34:35 <funfunctor> Cale: http://pastebin.com/ZnhXjNqd
00:34:37 <supki> mkoskar: and .cabal-sandbox/*-packages.conf.d for sandboxes
00:34:52 <Cale> For example, you're allowed to write   choiceFPGA sz = do r1 <- sz; r2 <- sz; if r1 == r2 then ... else ...
00:35:23 * hackagebot zeromq4-haskell 0.6.3 - Bindings to ZeroMQ 4.x  http://hackage.haskell.org/package/zeromq4-haskell-0.6.3 (ToralfWittner)
00:35:23 <Cale> Here, r1 and r2 would be values of type BladeRFFPGASize and they may be different, and the effects of running sz would happen twice.
00:35:36 <mrkkrp> supki: thanks!
00:36:30 <funfunctor> Cale: ah well, what I would need to compare the "results" of bladeRFGetFPGASize :: BladeRF BladeRFFPGASize  with a Enum to see which hw I have and give me a string. that is basically what I actually need it to do
00:38:02 <funfunctor> Cale: I was thinking about applicative control interfaces yesterday "try the thing on the left else the right" sort of thing and wondering if this would somehow solve my problem
00:38:31 <EvanR_> funfunctor: most of what you just described is non-IO, just some functions
00:38:32 <funfunctor> but right now I was just trying to solve the "have a suitable logging framework interface working" problem
00:38:57 <funfunctor> EvanR_: I know, but the issue is the value orginates from actual bare metal
00:39:01 <Cale> funfunctor: Okay, so what you *really* want to do is just to run the action of type BladeRF BladeRFFPGASize, and pass the result of that to choiceFPGA as a simple  BladeRFFPGASize  argument that you can pattern match on normally
00:39:08 <funfunctor> EvanR_: so we end up with a IO action
00:39:11 <L8D> “target ‘base’ is not a module name or a source file”
00:39:21 <Cale> i.e. write  choiceFPGA FPGA_UNKNOWN = "none"   etc.
00:39:22 <EvanR_> funfunctor: you need to start by executing an IO action, and then youre ok from then on
00:39:35 <funfunctor> Cale: exactly
00:39:41 <L8D> I got the above error when installing dependent-map-0.1.1.2
00:39:52 <L8D> where should I go or what should I do?
00:39:59 <Cale> and then down in the place where you use it, you'll have something like   sz <- bladeRFGetFPGASize; let fpgaName = choiceFPGA sz
00:40:29 <Cale> or more succinctly:  fmap choiceFPGA bladeRFGetFPGASize
00:40:33 <funfunctor> Cale: I don't think that type-checks let me try again
00:40:53 <Cale> funfunctor: Note that now  choiceFPGA :: BladeRFFPGASize -> String
00:41:20 <Cale> funfunctor: Also, liftIO $ return x is always the same as  return x
00:41:39 <Cale> funfunctor: and  v <- return x  is just an awkward way to write  let v = x
00:41:47 <jle`> cause monad morphism laws :O
00:43:19 <EvanR_> Cale: it is, and it has different effects on type inference ...
00:43:31 <EvanR_> i found out earlier
00:43:32 <Cale> funfunctor: You might want to write something like  getFPGA = fmap choiceFPGA bladeRFGetFPGASize
00:43:58 <Cale> EvanR_: Yeah, the fact that v is lambda bound in v <- return x means that it must have a monomorphic type
00:44:16 <Cale> EvanR_: While things which are bound by let are allowed to be polymorphic
00:44:22 <EvanR_> right
00:44:41 <Cale> (though with certain extensions turned on, you might need to put in the explicit type signatures now if you want polymorphic let bindings...)
00:45:07 <EvanR_> (that might be why when i tried to use a polymorphic let it didnt work)
00:45:48 <Cale> funfunctor: Another thing: you may find it convenient to use concat or unwords to concatenate many strings
00:46:23 <funfunctor> Cale:     Expected type: String
00:46:23 <funfunctor>       Actual type: BladeRF String
00:46:29 <Cale> funfunctor: Where?
00:46:34 <Cale> funfunctor: Show me the new code :)
00:46:49 <Cale> funfunctor: also you might try lpaste.net if it's no trouble :)
00:47:00 <Cale> It's a little nicer than pastebin for Haskell code
00:47:11 <funfunctor> Cale: bladeRFLoadFPGA $ getFPGA where getFPGA = fmap choiceFPGA bladeRFGetFPGASize
00:47:26 <funfunctor> lpaste.net ok got it
00:47:27 <Cale> Right, now getFPGA has what type?
00:47:36 <Cale> It's a BladeRF action right?
00:47:50 <Cale> So it's not a String, and you can't pass it to something which demands a String
00:47:58 <Cale> You have to execute it, and pass its *result*
00:48:08 <Cale> fpga <- getFPGA
00:48:09 <funfunctor> Cale: getFPGA :: BladeRF String  naturally
00:48:21 <Cale> then fpga :: String
00:48:33 <Cale> and you can write bladeRFLoadFPGA fpga
00:48:48 <L8D> is anyone getting the error "target ‘base’ is not a module name or a source file" when installing dependent-map-0.1.1.2
00:48:49 <funfunctor> ah ok got it !
00:48:55 <Cale> Or, if you want to be clever, you can write  bladeRFLoadFPGA =<< getFPGA
00:49:01 <funfunctor> yea
00:49:04 <funfunctor> got that
00:49:34 <funfunctor> =<< just to remind you what language you are programming in
00:49:42 <Cale> heh
00:49:53 <L8D> wait...
00:50:05 <EvanR_> =<< is "monad function application to a monadic argument"
00:50:07 <L8D> is the Haskell logo supposed to be the monadic bind operator?
00:50:15 <Cale> yes
00:50:26 <Cale> sort of
00:50:33 <Cale> With a lambda
00:50:53 <Cale> Also, vaguely reminiscent of the C64 logo, because reasons?
00:51:48 <funfunctor> :D
00:51:58 <funfunctor> Cale: thanks for setting me straight on that one!
00:52:06 <Cale> funfunctor: No problem
00:52:08 <funfunctor> Cale: did you get hslogger installed?
00:52:14 <Cale> funfunctor: yeah
00:52:27 <funfunctor> awesome!
00:52:27 <Cale> funfunctor: Oh, right, I was going to write you this example of what I meant
00:52:48 <funfunctor> Cale: btw.. I'll publish this BladeRF haskell binding to Hackage soon
00:53:00 <Cale> funfunctor: But since I've seen the rest of your code, I'm not even sure it's really the right answer?
00:53:11 <funfunctor> possibly another week, I rather have the first version reasonably stable
00:53:24 <Cale> You have a significant amount of stuff going on in this BladeRF monad, so maybe the right answer is just to build logging into that
00:54:01 <funfunctor> Cale: well the binding is rather large
00:54:21 <funfunctor> cat /usr/include/libbladeRF.h | wc -l
00:54:21 <funfunctor> 2907
00:54:54 <Cale> Moreover, you also already have bracketing going on
00:55:00 <funfunctor> the application of the binding is to make a GSM BTS in Haskell Cale
00:55:04 <funfunctor> so its rather large
00:55:36 <Cale> So, that provides an ideal place to put the init and close for the log as well.
00:56:06 <funfunctor> problem is the logging is more specific to the application than it is to the binding in truth
00:56:22 <Cale> Oh, I suppose.
00:56:28 <funfunctor> I just happened to show you the low level component where the project touches the binding
00:56:48 <funfunctor> btw, thanks for all your help!
00:56:56 <Cale> It's no problem :)
00:57:06 <funfunctor> :)
01:01:21 <Cale> funfunctor: OH, I see what hslogger is doing. It's maintaining some sort of global state for how each of arbitrarily many String-named loggers are configured.
01:02:28 <Cale> That's... sort of ugly.
01:02:56 <Cale> I'm not sure I'd even bother with that part.
01:03:41 <Cale> But it does solve your problem of passing around that handler
01:06:50 <funfunctor> Cale: yea so you kind of see how I got to the place I am at?
01:07:26 <funfunctor> or am I "thinking all wrong wrong wrong" ? :)
01:08:14 <Cale> funfunctor: imo, you're thinking better than the author of this library, but that's because of my extreme bias against using Strings to key into global state when you don't really have to.
01:09:00 <funfunctor> haha! awesome!
01:09:00 <Cale> funfunctor: But what the library author intended for you to do is not to pass around the GenericHandler that you get
01:09:35 <funfunctor> but he provides {debug,info,..}M :: .. primitives
01:09:50 <Cale> Instead, you use updateGlobalLogger to update a named logger with that handler
01:09:55 <Cale>        h <- fileHandler "debug.log" DEBUG >>= \lh -> return $
01:09:55 <Cale>                 setFormatter lh (simpleLogFormatter "[$time : $loggername : $prio] $msg")
01:09:55 <Cale>        updateGlobalLogger "MyApp.BuggyComponent" (addHandler h)
01:10:07 <funfunctor> yes
01:10:12 <Cale> like in this code from the example at https://hackage.haskell.org/package/hslogger-1.2.7/docs/System-Log-Logger.html
01:11:03 <Cale> So, then you can basically discard h from that point on, because it's been installed in this global map from logger names to the information about what handlers to use.
01:11:38 <funfunctor> Cale: you mean I can close it?
01:11:55 <funfunctor> wont that be a use after free sort of thing
01:12:20 <Cale> I mean, so long as you want to continue logging to the file forever, you don't have to hang on to h itself.
01:13:13 <funfunctor> Cale: the issue mainly here is that we have things like infoM :: String -> String -> IO ()
01:13:28 <funfunctor> Cale: and that first string is the "MyApp.BuggyComponent"
01:13:40 <Cale> and there's removeAllHandlers, which cleans everything up
01:14:27 <funfunctor> so we need to redefine infoM per "BuggyComponent" else we need to pass it correctly every time
01:14:32 <funfunctor> which is annoying
01:15:13 <funfunctor> so I had the idea "hey make a interface that allows me to enumerate the setup of the logger and provide primitives with the enumerated instance name"
01:16:09 <Cale> To be honest, I don't think I'd use this library. The logging level stuff is cute, but no big deal, and the global state is really the only other benefit. Here, I'll write that example of how I'd do logging without this library, and I'll even throw in log levels :P
01:16:36 <funfunctor> haha awesome ok
01:16:39 <funfunctor> all ears
01:16:46 <funfunctor> *eyes
01:19:53 <funfunctor> Cale: i'm just reading http://stackoverflow.com/questions/6310961/how-do-i-do-logging-in-haskell and found http://hackage.haskell.org/package/logger-0.1.0.0 no idea if its any better?
01:21:17 <funfunctor> looks a lot more complex
01:21:37 <Cale> funfunctor: I feel like it's easy to go way off the deep end with these libraries. I think anything which involves adding a monad transformer over IO to do logging is probably a bit nutty. Some people are less allergic to unnecessary monad transformers than I am though.
01:23:57 <funfunctor> Cale: https://github.com/wdanilo/haskell-logger  yea it looks pretty wizz-bang
01:26:35 <EvanR_> whats an idomatic way to specify a Bits value with "all ones"
01:26:43 <mauke> -1
01:26:46 <L8D> ^
01:26:52 <EvanR_> mkay
01:27:05 <L8D> EvanR_: true
01:27:21 <mauke> > complement 0
01:27:23 <lambdabot>  -1
01:27:38 <EvanR_> ah thats better
01:27:47 <EvanR_> -1 seems hocus pocus
01:28:08 <EvanR_> > complement 0 :: Integer
01:28:09 <funfunctor> :t complement
01:28:09 <L8D> but everybody and they’re girlfriend knows what -1 means
01:28:09 <lambdabot>  -1
01:28:10 <lambdabot> Bits a => a -> a
01:28:38 <L8D> > complement 1
01:28:38 <merijn> L8D: But what if your code gets run on a 1s complement machine?!
01:28:39 <lambdabot>  -2
01:28:39 <mauke> *their
01:29:02 <mauke> merijn: doesn't matter, Integer isn't machine integers anyway
01:29:04 <EvanR_> ive gotten used to haskell code saying what it means
01:29:30 <merijn> True
01:29:42 <EvanR_> in my case its Word
01:30:06 <lpaste> Cale pasted “hastily written example to provide the general shape of what I mean” at http://lpaste.net/120430
01:31:02 <Cale> funfunctor: Of course, in your case, it might even be better to have withLog work with BladeRF actions rather than IO, just to save the trouble of having to liftIO stuff all over.
01:31:28 <Cale> (and instead liftIO inside withLog for that)
01:32:29 <funfunctor> Cale: yea I was trying to work out how to do that
01:33:38 <Cale> funfunctor: There's a bunch of stuff that's probably worth pointing out you could do with this. If your application is multithreaded and you'll want to be logging from more than one thread, then probably you want to have withLog forkIO a thread which reads from a Chan and writes to the file, and change the log function defined inside it to writeChan instead.
01:34:14 <Cale> funfunctor: If you want to log to the terminal as well, that's easy, obviously.
01:35:04 <darthdeus> is there a way to clear a let binding in GHCi?
01:35:36 <Cale> funfunctor: Also, might want to make a type synonym for (LogPriority -> Message -> IO ()) and/or made a record datatype to hold that and other possible functions of this sort.
01:35:48 <merijn> darthdeus: :reload clears all bindings
01:35:50 <funfunctor> Cale: right now I am trying to just decide on what is a nice interface for the rest of the application then once the type-signatures are in place work out actually how to get the logger working
01:35:57 <Cale> funfunctor: I find it's really not so bad to pass things like this around explicitly if you package it up the right way
01:36:11 <darthdeus> merijn: but I only need to clear one :(
01:36:15 <Cale> You *could* use a ReaderT to do it
01:36:32 <Cale> but... it's often not really worth all the extra lifting
01:36:46 <merijn> darthdeus: Then not really
01:36:56 <merijn> darthdeus: Well, maybe you can shadow it using let again
01:37:17 <Cale> funfunctor: and note that this gives you things which are parameterised over a choice of how to do logging
01:37:32 <darthdeus> merijn: yeah, but that doesn't work when the new expression has a different type, only works if I assign to "a", and then do "let b = a", which would ignore that "a" has a different type
01:37:41 <Cale> funfunctor: So when you're testing individual bits, maybe you just pass in something which prints to the terminal there.
01:38:08 <funfunctor> Cale: well this guy has come up with a functor interface https://github.com/wdanilo/haskell-logger/blob/master/src/System/Log/Log.hs
01:38:12 <Cale> funfunctor: Or if your Message type were more interesting than String, you could pass in a function which filtered the messages for you
01:38:17 <merijn> darthdeus: I would generally avoid writing significant code in ghci, tbh
01:39:04 <funfunctor> Cale: the logging kind of just logs all sorts of random things really
01:39:06 <darthdeus> merijn: yeah I'm using it for exploration
01:39:36 <mauke> darthdeus: what do you mean by the type thing?
01:39:40 <funfunctor> Cale: everything from voltages and fequencies to modulation details
01:39:42 <Cale> funfunctor: Uh, that Log type is a Functor instance just because it can be -- it's a trivial wrapper.
01:40:26 * hackagebot lifted-base 0.2.3.5 - lifted IO operations from the base library  http://hackage.haskell.org/package/lifted-base-0.2.3.5 (BasVanDijk)
01:40:28 * hackagebot yet-another-logger 0.1 - Yet Another Logger  http://hackage.haskell.org/package/yet-another-logger-0.1 (larsk)
01:40:47 <merijn> darthdeus: I usually just keep an editor and ghci terminal side by side, writing in the editor and using ":r" to update ghci
01:41:07 <darthdeus> mauke: hmm weird, I'm not getting the same error ... but it just happened to me that I tried to re-set a binding and got a type error saying that the binding has a different type and that I can't set it
01:41:08 <jle`> yeah i used to slime
01:41:10 <jle`> but now i just :r
01:41:29 <Cale> funfunctor: Oh, and another thing, if you have a format like I've given, and you choose to have more interesting Message type, like one which has separate constructors for voltages and frequencies, and such... you have a single location in the program which needs changing if you want to write those to different files
01:43:37 <funfunctor> Cale: did you paste something and I missed it?
01:43:40 <Cale> oh
01:43:46 <Cale> http://lpaste.net/120430
01:43:48 <Cale> yes
01:43:49 <Cale> :)
01:43:55 <funfunctor> ah!
01:44:28 <Cale> lpaste announced it in the channel, but I should have pointed that out :)
01:44:29 <funfunctor> I knew I was missing something.. lol
01:45:03 <Cale> This withLog is actually stuff you could just put in main, but I separated it out just to show that you can.
01:45:08 <funfunctor> ah sorry, irssi is not properly setup on this machine yet.. other disk has linux panicing just because linux..
01:45:48 <EvanR_> funny talking about linux as if it was windows 98
01:46:42 <Cale> funfunctor: So does that example code generally make sense?
01:46:42 <funfunctor> EvanR_: i wish some of the grsec stuff would get merged
01:46:51 <funfunctor> Cale: yes, thank you!
01:47:47 <Cale> funfunctor: and yeah, it does mean you have this log function you're passing around manually, but if you stick that into a record with the rest of your program's configuration, it's likely not so bad
01:48:10 <Cale> and the ability to override that during testing really is handy
01:48:55 <Cale> (e.g. with one which is filtering for certain things, or one which just dumps to the terminal, or whatever)
01:49:16 <lpaste> funfunctor pasted “No title” at http://lpaste.net/120432
01:49:50 <funfunctor> Cale: ^ one other thing, what is the issue around lines 108?
01:50:54 <Cale> Is there an error message I should be aware of?
01:51:02 <Cale> I guess I can find out :)
01:51:28 <xenocons> whats the state of the art html parser in haskell?
01:51:29 <funfunctor> Cale: it should be self-containted no need to cabal wast time ;)
01:51:30 <Cale> oh, the = sign on 108
01:51:39 <Cale> is before the guards
01:52:02 <Cale> ... there are a bunch more type errors once you fix that
01:52:27 <funfunctor> ah man
01:52:39 <funfunctor> I didn't see that = for hours
01:53:26 <merijn> xenocons: html-conduit was pretty good last time I used it :)
01:53:33 <lpaste> funfunctor pasted “No title” at http://lpaste.net/120433
01:53:37 <merijn> xenocons: Fits well with http-conduit for simple fetching of pages too
01:53:51 <funfunctor> Cale: thats the reference code
01:57:08 <funfunctor> Cale: advice on writing this better is much welcome here, i'm not so great at bit operations like this in haskell yet
01:57:14 <Cale> funfunctor: btw, "the majority bit" means the most frequently occurring one
01:57:27 <xenocons> merijn: ill check it out
01:58:49 <funfunctor> Cale: I believe so https://en.wikipedia.org/wiki/A5/1#Description just going off this.. and that reference code
01:59:06 <funfunctor> it was not clearly mathematically defined for me
02:00:51 <Cale> I believe !!x in C will make x equal to 0 if x was 0, but 1 otherwise.
02:01:08 <Cale> Because you're doing a unary logical negation, and then another.
02:01:15 <shachaf> !!x won't modify x. :-)
02:01:25 <Cale> uh, right :)
02:01:30 <arw_> Cale: not quite. true is "something other than 0", not "always 1"
02:01:59 <arw_> Cale: so the compiler is free to do as shachaf says and do nothing
02:02:08 <shachaf> ?
02:02:16 <Cale> right, though this code appears to rely on the behaviour that it produces 1
02:02:19 <EvanR_> !0 is 1
02:02:23 <Cale> but yeah, I misspoke
02:02:48 <shachaf> All I said was that it didn't mutate x.
02:02:52 <funfunctor> yea !!x could me a couple of things
02:02:59 <Cale> (!!v1 + !!v2 + !!v3) >= 2
02:03:02 <Cale> ^^ it's doing that
02:03:13 <Cale> Which pretty clearly needs true to be 1
02:03:18 <shachaf> But http://c0x.coding-guidelines.com/6.5.3.3.html disagrees with you.
02:03:21 <jle`> i remember ruby people using !! to coerce to bool
02:04:08 <funfunctor> Cale: so fromIntegral on each v_i , sum them and check for >= 2 ?
02:04:14 <jle`> ruby is one of those languages where every single value/type has a truthness value
02:04:38 <jle`> so !foo will be False if foo was truthy and True of foo was falsy, and !!foo will be True if foo was truthy etc.
02:04:43 <funfunctor> i'm not even 100% on the type-signatures here
02:06:18 <joe9> is there a filter function in Data.Traversable or Data.Foldable?
02:06:25 <joe9> > :t filter
02:06:26 <lambdabot>  <hint>:1:1: parse error on input ‘:’
02:06:32 <EvanR_> no
02:06:49 <jle`> filter doesn't quite make sense for either structures unfortunately
02:06:50 <Cale> funfunctor: Uh, fromIntegral won't work. You could write something like  f 0 = 0; f x = 1 and then use (f v1 + f v2 + f v3) >= 2
02:07:27 <funfunctor> Cale: isn't there a function that exits that does that?
02:07:30 <jle`> joe9: for Foldable, all your operations lose the structure.  for Traversable, all your operations preserve the structure
02:07:35 <funfunctor> it looks familar
02:07:45 <jle`> joe9: so neither interfaces allow you to modify the structure in that sort of piecemeal way
02:08:08 <joe9>  How do I tell lambdabot/hoogle to show me function definitions? > :t filter or some such?
02:08:14 <jle`> :t filter
02:08:15 <EvanR_> > signum 3
02:08:15 <lambdabot> (a -> Bool) -> [a] -> [a]
02:08:16 <lambdabot>  1
02:08:18 <EvanR_> > signum 0
02:08:20 <lambdabot>  0
02:08:22 <EvanR_> ;)
02:08:22 <Cale> I guess it's the same thing as  fromEnum . (/= 0)
02:08:33 <Cale> Oh, or abs . signum
02:08:38 <joe9> :t filter
02:08:39 <lambdabot> (a -> Bool) -> [a] -> [a]
02:08:49 <joe9> ok thanks
02:09:06 <jle`> the best you could do with Foldable is filter :: Foldable f => (a -> Bool) -> f a -> [a]
02:09:14 <jle`> or whatever custom target data type you wanted
02:09:38 <joe9> https://github.com/joe9/masked-libraries might be of interest here.
02:09:49 <jle`> you could make it target any Alternative actually
02:09:52 <EvanR_> Foldable f, Conj g => (a -> Bool) -> f a -> g a ;)
02:10:14 <Cale> I find the Foldable/Traversable thing a bit odd. I'm happy with Traversable, but not Foldable
02:10:20 <shachaf> You could do lots of things, but (almost) none of them would have more information than a list, because Foldable is the class that lets you convert things to lists.
02:10:33 <shachaf> By "convert" I mean it'll give you a list.
02:10:43 <arw_> shachaf: indeed, you are right, its even specified in c99
02:10:48 <shachaf> No warranties, expressed or implied, about the contents.
02:10:58 <Cale> If the proposal were to remove the superclass constraint on Traversable and put that in the Prelude, I would be fine with that, I think.
02:11:30 <jle`> this devolved into an ftp discussion faster than i could have forseen
02:11:32 <Cale> But Foldable is nonsense, because you can't state what properties its methods should have.
02:11:39 <funfunctor> alright so I used signum to fix it
02:11:40 <funfunctor> thanks
02:11:50 <shachaf> Its methods should have the property that it gives you a list.
02:11:53 <Cale> I mean, the Prelude is already full of such classes, but :(
02:12:08 <funfunctor> the more scary one is a51Clock
02:12:44 <jle`> isn't naturality a good property
02:12:47 <EvanR_> Cale: whats this blurb about "Foldable (without traversable) deeply connects like 33 or more functions scattering in the base libraries" then
02:12:56 <jle`> toList . fmap f = fmap f . toList
02:13:03 <Cale> EvanR_: I don't know, where are you reading that?
02:13:03 <EvanR_> not an actual quote
02:13:16 <shachaf> Foldable doesn't have any laws about fmap because a Foldable instance isn't necessarily a functor.
02:13:23 <jle`> wait, really?
02:13:34 <EvanR_> https://ghc.haskell.org/trac/ghc/wiki/Prelude710/FTP
02:13:37 <jle`> oh
02:13:39 <jle`> huh
02:13:41 <jle`> this whole time...
02:14:18 <shachaf> Also Foldable is slightly more than toList. It's toFMList.
02:14:36 <EvanR_> Cale: so this page has a lot of support for these classes, im interested in other views too
02:14:54 <jle`> FMList?
02:15:26 <jle`> i think a Foldable instance is completely and uniquely specified from its toList
02:15:55 <jle`> i just like to think of Foldable as things you can `sequence_` and Traversable as things you can `sequence`
02:16:10 <Cale> If someone can come up with a law which explains why  foldMap f x = mempty  isn't an appropriate implementation for every instance of Foldable, then I'll probably be happy.
02:16:32 <shachaf> It's law-abiding.
02:16:49 <shachaf> I'm not quite happy with Foldable either but I don't know how to improve it.
02:16:55 <shachaf> I don't know that removing it would improve it, either.
02:16:58 <Cale> shachaf: But if that's what the Foldable instance for [] did, people would be upset
02:16:59 <jle`> how about foldMap's behavior has to satisfy a univesal property
02:17:12 <Cale> shachaf: and so this class seems poorly designed to me
02:17:27 <EvanR_> did everyone here fill out that survey heh
02:17:34 <Cale> because you can't seem to state what laws its methods should have without additional stuff
02:17:35 <shachaf> Cale: Yep, see above.
02:17:41 <jle`> such that, among all typechecking foldMaps, the "most proper" foldMap is clear
02:17:44 <jle`> through a universal property
02:17:47 <Cale> Merging Foldable into Traversable might work?
02:18:06 <jle`> er
02:18:07 <merijn> Cale: You'd lose some stuff
02:18:08 <jle`> universal construction
02:18:09 <shachaf> Do you have a universal property in mind?
02:18:14 <merijn> Cale: i.e. Set isn't Traversable
02:18:36 <jle`> i am thinking
02:19:32 <Cale> merijn: yeah, hmm
02:20:31 * hackagebot calculator 0.2.2.0 - A calculator repl.  http://hackage.haskell.org/package/calculator-0.2.2.0 (sumitsahrawat)
02:21:04 <jle`> given two toList f and g, we can say that f is more proper than g if g can be expressed as k . f, where k :: [a] -> [a]
02:21:31 <jle`> so the proper implementation of toList f, is the toList such that for any g :: t a -> [a], you can make a unique `k` such that g = k . g
02:21:38 <jle`> er, g = k . f
02:22:27 <jle`> so if your toList definition was toList' _ = [], then your k would be `const []`, so const [] . toList = toList'
02:22:38 <Cale> toList [] = []; toList (x:xs) = x:x:xs
02:22:53 <jle`> aw
02:23:23 <jle`> well then
02:23:29 <Cale> But indeed, your law is better than nothing
02:23:44 <Cale> It at least stops my mempty shenanigans
02:26:11 <jle`> hm
02:26:29 <jle`> so the property says that no information can be lost that was originally there
02:26:44 <jle`> is there a way to prevent a case like duplication there?
02:26:53 <EvanR_> would you want to prevent duplication?
02:26:56 <Cale> I wouldn't be surprised if that were the best you can do
02:27:11 <Cale> EvanR_: Well, people would be unhappy if the list instance did what I suggested
02:27:23 <EvanR_> yes but what if a Bag was foldable
02:27:45 <EvanR_> and you expect duplicates
02:28:18 <Cale> But I'm sort of okay with the idea of *a* canonical Foldable structure, as long as there's a law to prevent it from being completely degenerate.
02:28:23 <Cale> I dunno
02:30:16 <jle`> Cale: how about, it has to be the one of the many satisfying that property that produces the shortest list
02:30:55 <jle`> i guess this might include toList = reverse
02:30:58 <Cale> doesn't help much for the Stream instance
02:31:03 <Cale> but yeah
02:31:16 <Cale> reverse is not general enough
02:31:23 <Cale> But you could take many other permutations
02:31:45 <Cale> (reverse doesn't work in the infinite case)
02:31:54 <jle`> oh hey cool.
02:32:26 <funfunctor> terrifying, it type-checks now but looks horrible
02:32:54 <EvanR_> is there an argument showing that no meaningful law could be established for the Foldable class as it is
02:33:06 <lpaste> funfunctor revised “No title”: “No title” at http://lpaste.net/120432
02:33:22 <Cale> Well, I'm not totally upset with a law like what jle` suggested
02:33:31 <funfunctor> Cale: take a look at that insanity
02:34:13 <Cale> funfunctor: Don't be surprised if you need to eliminate these lists later to improve performance
02:34:13 <agocorona> do you know a simple game or demo that can use multiple threads?
02:34:43 <funfunctor> Cale: well I am just trying to figure out how to write this completely differently and much more fitting
02:34:56 <funfunctor> surely there much be a better way to write that
02:34:56 <Cale> funfunctor: xs !! n takes about n+1 steps to evaluate, because it has to walk down the list
02:35:12 <funfunctor> yes I understand that
02:35:18 <funfunctor> as I said, horrible!
02:35:27 <funfunctor> actually I said, terrifying!
02:35:30 <funfunctor> :)
02:36:06 <EvanR_> jle`: does your law stop loss of information somehow or just emptiness
02:36:10 <mauke> horrible! terrible! horrific! terrific!
02:36:12 <mauke> english is weird
02:36:18 <Cale> Yeah, I suppose it also depends on what your goals are. If you're only after a reference implementation which is easy to read, you might make things pretty but slower :)
02:36:32 <jle`> EvanR_: it stops loss of information
02:36:52 <jle`> any implementation that can provide more information than another will win out
02:36:58 <jle`> so it picks out the maximal amount
02:37:18 <jle`> so for Bag, it'll probably put each thing in the appropriate amount of times
02:37:25 <jle`> because it has to encode the number of occurrences
02:37:29 <jle`> ...assuming bag is multiset
02:37:33 <EvanR_> yeah
02:37:40 <Hijiri> what about an implementation (for []) that switches the first two elements before folding
02:37:46 <EvanR_> but more than that?
02:37:49 <funfunctor> Cale: its horrible to read, I just smashed my head on the keyboard :p
02:38:12 <Cale> mauke: Well, terrific originally meant something like what you'd expect, but became sort of generically used for things that were impressive.
02:38:16 <funfunctor> but i'm not sure how to write these bit operation things more elegantly in haskell
02:38:31 <mauke> well, that's just awful. I mean awesome.
02:39:02 <EvanR_> Hijiri: what would stop that and make sense for an unordered thing becoming a list
02:39:13 <EvanR_> or being folded
02:39:32 <EvanR_> should the user have any sort of guarantee on ordering
02:39:53 <Hijiri> well, the ordering is information
02:39:58 <Hijiri> I don't know if that counts
02:40:16 <EvanR_> you have to lose information in a fold
02:40:26 <EvanR_> at least the structure
02:40:28 <shachaf> Cale: The permutations issue applies to Traversable too.
02:40:34 <Cale> mauke: "Enormity" is another one which I hear misused like that all the time.
02:40:49 <Cale> mauke: Because it sounds like some conjugate of "enormous"
02:41:18 <mauke> "outside of the norm"
02:42:10 <arw_> isn't that anomaly?
02:42:30 <Cale> Well, enormity refers to extreme crimes or horrible events.
02:42:41 <mauke> arw_: that looks like "unlawful"
02:42:47 <funfunctor> mauke: hospital/hospitable
02:43:48 <mauke> demonstration: monster removal
02:43:57 <Cale> shachaf: You have a law which says that  traverse Identity = Identity
02:44:09 <Cale> shachaf: which prevents that
02:44:25 <shachaf> No it doesn't?
02:44:57 <shachaf> "both f (x,y) = (,) <$> f x <*> f y" and "both f (x,y) = flip (,) <$> f y <*> f x" are both valid.
02:45:11 <Cale> oh, right, that sort of permutation
02:45:29 <jle`> you mean you have to worry about the order of effects, *and* the order of the results, too?
02:45:31 <jle`> dang
02:45:34 <Cale> hehe
02:45:37 <shachaf> For a type with exactly n values you have n! Traversable instances.
02:45:52 <Cale> uhhh
02:45:54 <shachaf> n occurrences of type thing it's paramterized on. You know what I mean.
02:45:58 <Cale> yeah
02:46:07 <mauke> when in doubt, choose the funniest one
02:46:25 <shachaf> I seem to be slightly incoherent right now.
02:47:29 <shachaf> Cale: These permutations are the direct analogue to the Foldable ones, since foldMapDefault gives you the elements in that order.
02:47:36 <Cale> right
02:48:01 <jle`> Cale: i think...all functions that satisfy the universal property are unique up to an isomorphism anyway
02:48:06 <Cale> So probably nothing more can be done. The operations based on Foldable are a little curious in light of that, but that's fine.
02:48:09 <jle`> so maybe i'd be okay with that being the main condition
02:49:03 <jle`> like your double-the-head toList and toList = id instances...they have a unique isomorphism
02:49:38 <Cale> The other moral opposition I secretly have about Foldable is that it kind of sidesteps making use of universal data types, but that's not really a fair complaint.
02:53:06 <Cale> It still sort of feels like "here's a bunch of stuff which factors through toList, let's lump it up into a type class and obscure the utility of lists" -- of course, sometimes it's really a binary tree instead, but still.
02:53:09 <EvanR_> jle`: what exactly is isomorphic in this case?
02:54:46 <jle`> EvanR_: the two instances
02:55:03 <jle`> toList = id vs. toList [] = []; toList (x:xs) = x:x:xs
02:55:05 <EvanR_> how can two instances be isomorphic, whats that
02:55:32 <Cale> EvanR_: There are maps going back and forth that make the relevant diagrams commute
02:55:43 <jle`> isomorphic is where you have a function f that turns one into the other, and a function g that goes backwards, such that f . g = id, and g . f = id
02:56:18 <EvanR_> yes so we have two mappings between...
02:56:32 <jle`> the first toList and the second toList
02:56:41 <jle`> oh
02:56:44 <jle`> i mean
02:56:46 <Cale> the duplication map is only invertible on one side
02:56:50 <jle`> the results of the first toList and the results of the second toList
02:56:56 <EvanR_> oh
02:56:56 <Cale> errr
02:57:01 <Cale> yeah, that's true
02:57:28 <jle`> to turn the results of the second into the results of the first you just chop off the first element if there is one
02:57:35 <jle`> er, that's drop 1
02:57:46 <EvanR_> got it
03:17:03 <dr_diagoras> struggling to understand pipes-parse - can anyone help please? Tutorial describes how parsers can take input from a producers. but what if I want to plug parser in the middle of a conveyor - is it possible to make parser as pipe? something like "Pipe T.Text ParsedValue m ()". or maybe I'm thinking wrong?
03:39:47 <dcoutts> folks, we need a new lambdabot @quote command
03:39:48 <dcoutts> @HaskellCEO
03:39:49 <lambdabot> Unknown command, try @list
03:39:56 <dcoutts> https://twitter.com/HaskellCEO
03:40:14 <mauke> just @remember them individually
03:40:51 <dcoutts> aw, not as fun
03:41:17 <mauke> is "God in Christ" a reference to anything?
03:43:16 <HugoDaniel> mauke: http://worshipsatan.today/
03:52:46 <zomg> lol, why does that redirect to hadoop
03:56:21 <zipper> Is there a way to just write plain javascript and not julius in yesod?
03:59:02 <zomg> you can just include script tags on the page which include your standard-js files
04:00:23 <zipper> zomg: I'm trying that but getting a 404 on the js files yet they are in that very directory
04:01:13 <zomg> iirc you might have to set up static file serving
04:01:35 <zomg> if you're getting a 404, then chances are it's not set up properly or the paths are wrong or something
04:02:12 <zipper> zomg: Yeah the issue is that these files are taken to a dir static/tmp/autogen...js
04:02:22 <zipper> but the js file isn't
04:05:35 <Haskellfant> I'm trying to understand the proof why functor instances are unique. I have found this proof http://article.gmane.org/gmane.comp.lang.haskell.libraries/15384 but I don't understand why 'foo (g . f) = fmap g . foo f' must be true. if foo follows the functor laws 'foo (g . f) = foo g . foo f' must obviously be true, but I don't see why I can just replace foo with fmap
04:05:59 <funfunctor> zipper: I recommend Fay for writing JS btw
04:06:40 <funfunctor> zipper: its a EDSL, it is very good
04:07:21 <Haskellfant> dr_diagoras: afaik you can't make parsers a pipe because of leftovers.
04:07:31 <bennofs> Haskellfant: it's a so-called "free theorem", it follows from the type of foo alone
04:07:42 <bennofs> @google Theorems for free
04:07:44 <lambdabot> http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf
04:07:44 <lambdabot> Title: Theorems for free Philip Wadler University of Glasgow* June 1989 Abstract Fro...
04:08:02 <bennofs> Haskellfant: I never understood that paper :|
04:08:10 <Haskellfant> bennofs: hm okay, I'll try reading it later :)
04:08:48 <bennofs> Haskellfant: it's kind of the same reasoning that allows you to say that if you have a function f :: forall a. a -> a, f x = x must hold forall x
04:08:54 <bennofs> (-> f = id)
04:09:14 <Haskellfant> that only holds if you don't have bottom, right?
04:09:26 <hpc> yep
04:09:39 <hpc> there's a couple more values f can take if you admit bottom
04:10:54 <Procian> Dumb question: but isn't the theorem just assuming what you can construct using the normal rules of lambda calculus? There's no contradiction presumably, in imagining a function of type "forall a. a -> a" which behaves as the identity on everything other than Integer, where it instead behaves as successor?
04:11:28 <hpc> in a language like java, sure
04:11:40 <zipper> I get the following error from using julius in js console `Uncaught TypeError: Cannot read property 'addEventListener' of null`
04:11:41 <hpc> but it violates parametricity
04:11:43 <zipper> This is the js file. https://gist.github.com/urbanslug/7a87528371f86ff7b477
04:11:45 <Procian> I mean, in Coq, say, is there actually a theorem which says that all these functions are id?
04:12:40 <bennofs> Procian: free theorems are much more powerfull in Haskell, since Haskell doesn't have real dependent types
04:13:10 <a3gis> bennofs: how come are free theorems more powerful without dependent types?
04:13:26 <hpc> because computing the full domain of a type is decidable
04:13:42 <Cale> Wait, what?
04:13:44 <hpc> (or at least, much much easier)
04:13:46 <Cale> How do you do that?
04:17:18 <Cale> Procian: The reasoning by parametricity is a metatheorem, there's no way in Coq to prove that the identity is the only function forall a, a -> a. Coq also doesn't prove function extensionality, you need to add that as an axiom if you want it.
04:18:00 <Procian> Cale: Cheers. That's what I was getting at by referring to the rules of the calculus.
04:18:33 <Procian> Follow up: a metatheorem in constructive Coq would be that some propositions are undecidable. But Coq refutes undecidability of any given proposition. Does the same apply here?
04:18:55 <Procian> That Coq could refute a theorem saying "any polymorphic functions of type a -> a is the identity"?
04:19:49 <Cale> You can add an axiom which says that any two functions of that type are equal, and I don't believe it would create any inconsistencies.
04:19:55 <funfunctor> Cale: suppose you have multiple versions/revisions of a stream cipher and you wanted to dispatch to a particular 'version' predicated on some data SCVersion = SCV1 | SCV2 | .. , would a typeclass be sutiable here for a interface?
04:19:57 <Procian> Ah cool.
04:22:01 <Lamen> I got some problem using async, here is my code http://lpaste.net/120444
04:22:25 <Cale> funfunctor: Possibly! Another approach would just be to have a datatype whose fields consist of whatever the type class methods would have been.
04:23:15 <Lamen> I tested both versions using nc/telnet
04:23:54 <Lamen> the one without async: as soon as I hit ctrl-c, both sides will print out "connection closed"
04:25:02 <Lamen> but in the one using async, if I close one side, the other side will not exit immediately
04:25:06 <Cale> Why are you using void on the result of async?
04:25:16 <Cale> That seems to indicate that you shouldn't be using async at all
04:25:59 <Cale> If you're not going to wait on the result of a computation, you should just use forkIO, probably.
04:26:26 <Lamen> Cale: thanks for your input
04:26:46 <Cale> I don't know what the real problem is...
04:26:58 <funfunctor> Cale: sorry I missed what you mean by that?
04:27:11 <Cale> funfunctor: Well, what would the methods of your type class be?
04:27:25 <Lamen> I use void basically to get a (), instead of the ThreadId async returned
04:27:41 <Cale> Lamen: async doesn't produce a ThreadId
04:27:54 <Cale> async :: IO a -> IO (Async a)
04:28:01 <Cale> wait :: Async a -> IO a
04:28:04 <Lamen> sorry...my mistake...
04:28:36 <Lamen> to get a (), actually
04:28:39 <zipper> How do I stop my julius code from executing before the page has loaded? What seems to work in javascript doesn't work in julius
04:29:00 <Cale> There is secretly a ThreadId inside that Async structure, but the more important thing is that there's an STM computation for attempting to wait for the result of the asynchronous computation.
04:29:33 <funfunctor> Cale: encrypt :: a key -> a stream -> the output essentially
04:30:18 <Lamen> Cale: so your suggestion is stay with plain forkIO?
04:30:41 <Cale> Lamen: Well, for that anyway
04:33:00 <Lamen> Thanks, I feel the same way too. I was just trying to do some experiments with async.
04:33:20 <Lamen> to see if I could use that to replace forkIO
04:35:48 <Haskellfant> Lamen: async starts to get useful once you want to interact with the thing you have forked in some way
04:35:51 <Haskellfant> like wait for it to terminate
04:35:54 <Haskellfant> get some result back
04:35:57 <Haskellfant> and so on
04:36:04 <Haskellfant> after all it calls forkio under the hood
04:37:08 <funfunctor> ugh, I am spending too much time on this non-important component
04:38:03 <Cale> funfunctor: So, once you know what that type is, you can pass values of that function type around to abstract things over a choice of it.
04:38:37 <Lamen> Haskellfant: I am just curious...why these two version works differently :-P
04:39:18 <lpaste> funfunctor pasted “No title” at http://lpaste.net/120448
04:39:33 <funfunctor> Cale: thats me thinking out loud ^
04:40:28 <funfunctor> Cale: the module is mostly done, its just very hacky
04:43:20 <Cale> funfunctor: That reminds me, this might be a use-case for http://hackage.haskell.org/package/crypto-api
04:43:45 <Haskellfant> Lamen: from a quick look at the source of async it looks like it installs different exception handlers than forkIO, but I don't have time right now to look more into it
04:44:56 <Lamen> the main reason that I decided to give async a try is the article "network-conduit, async, and conduit-combinators" from snoyman
04:45:52 <Cale> It's possible that somehow it's automatically cancelling the async when the result is GCed.
04:46:35 <Cale> I'm not sure if it's clever enough to do that -- I know that if a thread is blocked on a write to an MVar which no other thread has a reference to, for instance, an exception gets thrown at that thread.
04:47:15 <nkar> what's the best way to represent a bytestring of a certain length at the type level?
04:47:53 <awestroke> nkar: do you want the length encoded in the types?
04:47:56 <Cale> I've been up all night, and the fancy exception masking stuff that's going on inside the async library is a little too subtle for me right at the moment.
04:48:11 <nkar> awestroke: yeah.  is it similar to how it's done with lists?
04:48:29 <awestroke> nkar: lists are dynamic length
04:48:57 <nkar> awestroke: I mean number-parameterized lists
04:49:01 <the_other_cat> Hi, i'd like to use Actions.GridSelect from the contribs to display the workspaces sorted by (already defined) WorkspaceGroups (e.g. one WSGroup by column, and all it's workspaces in different rows). I don't quite get how the workspaces are sort in GridSelect per default?!
04:49:11 <Cale> nkar: Probably just start with a type which has a ByteString and a phantom Nat type parameter, and then build smart constructors of some sort
04:49:46 <nkar> Cale: newtype Foo a = Foo ByteString?
04:49:52 <Cale> Yeah, pretty much
04:49:58 <Lamen> Thanks Haskellfant & Cale, I'll just leave the questions behind for now. I shoud get some sleep too. Thanks again.
04:50:03 <nkar> Cale: k
04:50:07 <nkar> Cale: thanks
04:50:49 <Cale> nkar: and then don't export the Foo data constructor from the module, so that only operations you're confident produce the correct type level tag will be available
04:50:55 <Cale> (from outside)
04:51:11 <nkar> Cale: yeah, I know about smart constructors
04:51:37 <nkar> Cale: do I need to encode the numbers as peano numerals?
04:51:56 <nkar> which has no value-level representation
04:52:00 <nkar> have*
04:52:37 <nkar> Z, S Z, S (S Z), etc
04:52:39 <Cale> I think there are proper type level nats in newer GHCs along with some arithmetic and stuff even? I haven't really played with it much
04:52:55 <nkar> I don't know offhand either
04:53:06 <nkar> but I'll look into it.  thanks for the pointers
04:53:33 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-level-literals.html
04:56:23 <Cale> This is one of those areas where you really need a dependently typed language as soon as things get modestly complicated, but they're trying to push the envelope a bit to see what they can get.
04:58:13 <bennofs> Can anyone explain the behaviour of this code involving the FFI and concurrency to me: https://gist.github.com/bennofs/95959bbe8dc336e4c4ca ?
04:58:28 <Cale> The fact that it doesn't know that addition is associative or that a + 0 is the same as a, or things like that, will eventually get in your way.
04:59:45 <bennofs> If I don't do the safe call first, -N2 is enough to not get the whole program interrupted. I thought when doing a safe FFI call, GHC creates a new OS thread, so after the safe FFI call, there are still 2 OS threads available, then one gets blocked by the unsafe FFI call, but there should still be one for Haskell code, no?
05:02:51 <bennofs> even more surprisingly, if I compile without -threaded, and use a safe FFI call, the code finishes much faster (it seems like the sleep is ignored????)
05:03:24 <Cale> well, that's amusing
05:03:29 <Cale> I have no idea
05:03:54 <bennofs> And if I change the first call to be unsafe too, it doesn't even get to the second forkIO :|
05:04:03 <bennofs> (with -N3)
05:04:43 <bennofs> *but* it does get there *and* executes the final putStrLn if I add a putStrLn between the first and the second forkIO. And a yield doesn't have that effect
05:04:53 <Cale> oh, there's a blog post all about why this is
05:05:28 <bennofs> Cale: if you mean the ezyang post, I've read that
05:05:51 <bennofs> Cale: or do you mean the sleep behaviour without -threaded?
05:07:16 <bennofs> Cale: ah, the sleep behaviour is because of the RTS timer
05:07:31 <bennofs> Cale: it uses SIGALARM, so sleep exits prematurely
05:10:40 * hackagebot kansas-lava 0.2.4.2 - Kansas Lava is a hardware simulator and VHDL generator.  http://hackage.haskell.org/package/kansas-lava-0.2.4.2 (GergoErdi)
05:12:58 <nkar> is intmap a good choice for a very small collection, e.g., 5-10 elems?
05:13:49 <hvr> nkar: https://wiki.haskell.org/GHC/Memory_Footprint :)
05:14:10 <nkar> hvr: cool! thank you
05:15:40 * hackagebot kansas-lava-cores 0.1.2.1 - FPGA Cores Written in Kansas Lava.  http://hackage.haskell.org/package/kansas-lava-cores-0.1.2.1 (GergoErdi)
05:21:52 <lush> yo everybody
05:25:41 * hackagebot kansas-lava-shake 0.1.2 - Shake rules for building Kansas Lava projects  http://hackage.haskell.org/package/kansas-lava-shake-0.1.2 (GergoErdi)
05:32:18 <lush> askljdas
05:40:42 * hackagebot threads-supervisor 1.0.1.0 - Simple, IO-based library for Erlang-style thread supervision  http://hackage.haskell.org/package/threads-supervisor-1.0.1.0 (AlfredoDiNapoli)
05:57:06 <cfoch> hello
05:57:18 <cfoch> what is this operator for ?
05:57:21 <cfoch> ">>?"
05:57:33 <cfoch> sorry
05:57:37 <cfoch> "?>>"
05:58:07 <c_wraith> cfoch: no idea offhand.  what library is it from?
05:58:20 <cfoch> Cabal uses it
05:58:45 <dcoutts_> it must be defined locally
05:59:34 <cfoch> https://github.com/haskell/cabal/blob/master/cabal-install/Distribution/Client/Init.hs#L156
05:59:42 <phaazon> I'm pretty happy with my scarce resource typeclass
05:59:46 <phaazon> http://lpaste.net/120452
05:59:47 <lpsmith> @tell RyanGlScott http://blog.melding-monads.com/2015/02/12/announcing-blaze-builder-0-4/
05:59:47 <lambdabot> Consider it noted.
05:59:49 <phaazon> if it's useful I'll release it on hackagedb
05:59:56 <phaazon> for now, I just keep that in my project
06:00:01 <phaazon> IOResourceT should be named IOScopedT though
06:00:02 <lpsmith> bergmark, yeah my bad about the Changelog
06:00:57 <c_wraith> cfoch: that appears to be MaybeT IO's <|> operator, but without the MaybeT transformer
06:01:28 <bergmark> lpsmith: i wish hackage would let you give a url to the changelog so you can update it!
06:08:27 <lattenwald> Hi. I got problem with lenses, here's the description http://lpaste.net/120453
06:08:46 <lattenwald> does not typecheck and I don't understand why. Any help would be appreciated
06:10:08 <tiger717> &quit
06:10:15 <tiger717> :D
06:10:37 <c_wraith> lattenwald: it would need to derive a rank-2 type for getStuff to make that work.
06:10:44 <c_wraith> lattenwald: err, infer
06:11:05 <c_wraith> lattenwald: but rank-2 types can't be inferred
06:11:22 <lattenwald> sooo I need to give getStuff explicit type?
06:11:48 <c_wraith> lattenwald: yes, and it needs to be rank 2. :)  Are you comfortable with the RankNTypes extension?
06:12:13 <lattenwald> no :) But will be if needed
06:12:52 <lattenwald> thanks.
06:17:07 <bennofs> Wow, I've got a Haskell program that behaves differently depending on whether I run it from fish shell or from bash ......
06:18:57 <ChristianS> fish shell?
06:19:13 <bennofs> http://fishshell.com/
06:21:03 <ChristianS> "Finally, a command line shell for the 90s" haha
06:30:14 <awestroke> bennofs: environment variables?
06:32:10 <bennofs> awestroke: same behaviour running with env -i
06:32:17 <jstolarek> at least it looks different than it used to
06:32:23 <jstolarek> sorry, wrong window
06:32:55 <bennofs> awestroke: note that the running bash -c /my/haskell/prog in fish produces the fish shell behaviour, not the bash behaviour
06:39:44 <augur> boy oh boy hakyll takes forever to install :)
06:39:52 <augur> its been going for like an hour or two!
06:40:20 <Scheriderm> Hi guys !! has any one being played with Netwire ??
06:40:44 <jstolarek> did anyone tried to compile HList with GHC 7.10RC2 ?
06:41:13 <fmapE> Can I ask ghci to show me what qualified name an unqualified name resolves to in a particular module's context?
06:45:46 * hackagebot reasonable-operational 0.1.0.0 - library for takahashi method.  http://hackage.haskell.org/package/reasonable-operational-0.1.0.0 (outoftune)
06:46:08 <eacameron1> So the crypto-random doesn't currently work when being built by 64-bit GHC on Windows. That means a lot of other things don't work too (TLS and therefore HTTPS requests). I submitted a PR to fix it but haven't gotten any feedback. Does anyone know if vincenthz is still active?
06:48:26 <eacameron1> fmapE: Can you just load up the module in GHC and do ":info <name>"?
06:48:34 <eacameron1> fmapE: I meant GHCi
06:52:27 <stelleg> has anyone ever proposed a config function `config :: IO (IO ())` that returns the main function? seems like it would be a nice way to do IO at configure time
06:54:38 <eacameron1> stelleg: Can't you just `config = return myMain;   main = join config;`
06:57:04 <stelleg> eacameron1: that has the right type, but I'm thinking compiler support for such a function, so that you can compile the resulting myMain
06:58:02 <eacameron1> stelleg: Oh, so akin to what you would do with Template Haskell?
06:58:44 <stelleg> eacameron1: yeah I suppose you probably could do something along those lines with template haskell, good point
06:59:07 <stelleg> ah yeah
06:59:13 <stelleg> runIO
07:01:01 <stelleg> still its fun to imagine a heirarchy of functions like that
07:01:12 <stelleg> you could have configur :: IO (IO (IO ()))
07:01:18 <stelleg> build :: IO (IO ())
07:01:21 <stelleg> main :: IO ()
07:04:36 <bananagram> is there a way to make a Show instance for a function?
07:06:07 <fmapE> eacameron1: Maybe but the docs don't say so for sure. I'm waiting on a build to finish before I fire up ghci
07:14:34 <jameseb> bananagram: what sort of Show instance do you want?
07:20:56 * hackagebot reasonable-operational 0.1.0.1 - library for takahashi method.  http://hackage.haskell.org/package/reasonable-operational-0.1.0.1 (outoftune)
07:20:58 * hackagebot csound-expression-typed 0.0.6.1 - typed core for the library csound-expression  http://hackage.haskell.org/package/csound-expression-typed-0.0.6.1 (AntonKholomiov)
07:21:00 * hackagebot csound-expression 4.3 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-4.3 (AntonKholomiov)
07:21:02 * hackagebot csound-catalog 0.2.1 - a gallery of Csound instruments.  http://hackage.haskell.org/package/csound-catalog-0.2.1 (AntonKholomiov)
07:21:30 <hodapp> bitemyapp: Just now saw that you are writing a book. Very cool.
07:23:10 <fmapE> eacameron1: :info didn't show me the qualified name, but it did show me which typeclass it came from.
07:23:23 <fmapE> But more generally this would be helpful.
07:25:51 <osa1> when I define a CPP macro using cabal --ghc-options=-D<flag> does that the dependencies?
07:26:06 <osa1> does that effect the dependencies*
07:26:53 <jophish> https://twitter.com/HaskellCEO
07:33:53 <clrnd> jophish, I love that account
07:34:25 <clrnd> it's been months since I lol'd like that in twitter
07:35:57 * hackagebot cartel 0.14.2.0 - Specify Cabal files in Haskell  http://hackage.haskell.org/package/cartel-0.14.2.0 (OmariNorman)
07:37:29 <tomphreek> (list monad) ... = do x <- xs; if x then return [1] <- (1) ... else ...; is it possible to stop execution of the implied concat . map at the <- (1) point?
07:37:42 <jophish> clrnd: see https://twitter.com/PHP_CEO too
07:38:50 <clrnd> I’M NOT SURE I CAN MAKE OUT WHAT @HaskellCEO IS SAYING FROM ATOP HIS IVORY TOWER
07:38:52 <jophish> tomphreek: what do you mean by "stop execution"?
07:39:06 <Welkin> wtf is with HaskellCEO?
07:39:28 <shapr> isn't it awesome?
07:39:37 <Welkin> all of the turmoil over FTP is so stupid
07:39:47 <Welkin> just lay it to rest and move forward
07:39:50 <shapr> I wonder what the long term endpoint will be for FTP?
07:39:59 <tomphreek> jophish: say xs = [1,2], x is 1. I don't want concat . map to be consider 2; this return [1] is final, no more to concatenate
07:40:01 <shapr> will we end up with a totally generalized Prelude that newbies can't understand?
07:40:18 <Welkin> shapr: the key is to have better introductory materials
07:40:33 <shapr> hm, perhaps
07:40:52 <shapr> Welkin: how would you improve the introductory materials?
07:41:00 <Welkin> I don't see how it makes anything harder to understand
07:41:11 <Welkin> you can explain the concepts in terms of lists
07:41:21 <Welkin> but then say "it generalizes to anything that you can fold"
07:41:21 <shapr> It's more that I've seen codebases that were completely factored out into reusable pieces, and they were very hard to grasp.
07:41:29 <jophish> something like [x | x <- xs, x == 1]
07:41:33 <jophish> tomphreek: ^
07:41:34 <Procian> I might consider writing a Prelude.Newbies, monomorphising a load of stuff for an intro Haskell course, just to keep errors easier to understand.
07:42:14 <shapr> Procian: that's a good idea
07:42:16 <tomphreek> ah guard
07:43:04 <jophish> Procian: shapr: http://www.reddit.com/r/haskell/comments/2icjmf/how_to_rewrite_the_prelude/cl0xdyr
07:43:22 <jmcarthur> IMO, catering to beginners at the expense of experts is dangerous. Also, I don't think a plethora of monomorphic functions is necessarily more beginner friendly in the first place; beginners often get confused about why they need to know about so many functions that do basically the same thing.
07:43:46 <jmcarthur> Did I really just stick my toe in this water?
07:44:27 <jophish> If you want a monomorphic function for better error messages when teaching, why not call it mapList or traverseList
07:44:47 <shapr> jmcarthur: on the other hand, if you don't cater to beginners, you don't ever get experts :-P
07:44:49 <tomphreek> no I don't think guard is what I want. I don't want to keep checking the condition for the rest of the list. I simply want to return [] once guard is satisfied
07:45:26 <hodapp> Welkin: what *is* FTP?
07:45:27 <jophish> tomphreek: head . filter (==1) $ xs
07:45:35 <jmcarthur> shapr: There are other ways to help beginners.
07:45:44 <shapr> jmcarthur: what would you suggest?
07:45:54 <shapr> hodapp: the foldable traversable proposal
07:45:57 * hackagebot MusicBrainz 0.2.3 - interface to MusicBrainz XML2 web service  http://hackage.haskell.org/package/MusicBrainz-0.2.3 (ClintAdams)
07:46:05 <Welkin> hodapp: Foldable/Traversable Proposal
07:46:15 <jmcarthur> shapr: Better introductory materials. Better documentation.
07:46:21 <shapr> jmcarthur: any specifics?
07:46:50 <Welkin> I tried to make introductory materials in the past for things like using Haskell with SDL2 and OpenGL
07:46:58 <shapr> pair programming seems to be the best way for me to learn and teach, the teacher explains why they make particular choices...
07:46:58 <Welkin> I'd like to continue that
07:47:09 <Welkin> there are general intro materials, then there are domain specific ones
07:47:13 <shapr> are there videos like that for Haskell?
07:47:22 <tomphreek> jophish: that would work but my real example is recursive call and I don't think I can simply filter out things I don't need to consider
07:47:47 <jophish> tomphreek: what do you mean?
07:48:31 <jmcarthur> shapr: I think it is uncontroversial to say that our documentation is not very beginner friendly, and it seems an easy (though very time-consuming) problem to fix.
07:48:41 <Welkin> I think a book works well in the format of LYAH/RWH/Parallel and Concurrent Haskell
07:49:04 <Welkin> When I was a beginner, I found the hackage docs to be very clean and informative
07:49:10 <lpaste> tomphreek pasted “stop concat . map” at http://lpaste.net/120465
07:49:17 <Welkin> I had to learn to actually open the source and read the comments though
07:49:20 <Welkin> those are very nice
07:49:24 <tomphreek> jophish: http://lpaste.net/120465, 8th line
07:49:54 <jmcarthur> shapr: most of our documentation consists of (1) a type, which is inherently unhelpful for a beginner; (2) a one-sentence explanation; (3) sometimes, a series of gotchas that might hit somebody very concerned about performance, also not useful to beginners.
07:50:13 <Welkin> hm
07:50:29 <Welkin> yes, it is important to understand the types, which a lot of beginners seem to ignore
07:50:44 <jmcarthur> Welkin: not just ignore. they simply don't know how to use them yet.
07:50:47 <Welkin> and the typeclassopedia is more of a reference
07:50:56 <kofno> As a beginner, I find tutorials/examples to be sorely lacking on most libraries. Sometimes, if you go to the source repo, you can find example code, but it is seldom in the docs.
07:51:27 <Welkin> kofno: I learned to just read the source code a lot of the time, but that isn't the best solution if we want to language to continue growing
07:53:09 <jophish> tomphreek: so you want to return a singleton list when (isSuccessfullAttempt attempt potentialPass) is true?
07:53:19 <tremon> I'm mostly missing contextual data. Hackage docs are useful to know which functions exist, but mostly I need to know how library functions combine into a bigger picture
07:54:19 <Welkin> yes, tutorials are important
07:54:33 <Welkin> I intend to write more tutorials
07:55:06 <kofno> It would be helpful if documentation for a library had a Getting Started or Hello World-ish example of how to use the API.
07:55:37 <kofno> well, helpful to me :)
07:55:54 <Welkin> you are right, but sometimes it is too simple to be helpful
07:56:08 <Welkin> so even if it exists, it may not be that useful
07:56:31 <Welkin> a full tutorial is preferable
07:57:36 <tomphreek> jophish: once (isSuccessFullAttempt attempt potentialPass) is true the code should return [potentialPass] where I commented, but the entire block is wrapped in the implicit concat . map over ys = (shortestPasses (y:xs) passwords) and I don't want to consider the next element in ys
07:58:01 <Procian> kofno: Gabriel Gonzales is leading the way there.
07:58:31 <Procian> *Gonzalez
07:58:48 <cmtptr> as a beginner, I would just like to see a small, complete, real-world program
07:59:03 <cmtptr> I'm halfway through LYAH and real world haskell and still have no idea how to start or structure a haskell program
07:59:28 <cmtptr> way too much time is spent in ghci
08:01:00 * hackagebot takahashi 0.2.0.2 - Operational Monad implementation. It is more small but adequately.  http://hackage.haskell.org/package/takahashi-0.2.0.2 (outoftune)
08:05:12 <tomphreek> jophish: a better analogy might be [x*y | x <- [1, 2, 3], y <- [2, 5, 100, 500], x*y < 3]. In the world where multiplication is a very expensive operation, I want to tell Haskell that once you are over 3 no need to multiply further since lists are sorted
08:07:51 <coltfred> If I want to generate an Aeson FromJson instance for an ADT is there a way to do that? For instance {"colors": ["Green", "Blue", "Black"]} and I have an ADT representing legal colors (data Color = Green | Blue | Black) , can I generate the code to convert to the ADT from Strings?
08:08:29 <Scheriderm> is possible to import a constructor wich its hide ?? i tried with import foo (foo2 (fooconstructor)) but it doesn't work...
08:09:24 <lush> !quit
08:09:56 <tomphreek> so do x <- [1, 2, 3]; y <- [2, 5, 100, 500]; if x*y > 3 then return [] {- how tell haskell to look no further?-} else return x*y;
08:10:14 <lush> !id yo?
08:10:14 <lush-hs-bot> yo?
08:10:18 <lush> !quit
08:13:34 <jmcarthur> Scheriderm: you mean there is a module that hides the constructors of a type and you want to import them anyway?
08:13:45 <jophish> tomphreek: this is what lazy evaluation is all about
08:14:05 <geekosaur> Scheriderm, packages that are willing to expose their internals often have a .Internals module somewhere. otherwise, no
08:14:51 <jophish> tomphreek: you might find it easier to split that function up into smaller parts
08:15:30 <tomphreek> jophish: but it still needs to evaluate 2*100 to tell whether it's bigger than 3
08:16:01 * hackagebot haskell-formatter 1.0.0 - Haskell source code formatter  http://hackage.haskell.org/package/haskell-formatter-1.0.0 (evolutics)
08:16:07 <tomphreek> I want to break out. I know what I am doing and don't want to evalutate at all. i.e. break out
08:17:19 <jophish> That's not really a concept appropriate to haskell. The idiomatic way of doing things is to construct them lazily and only evaluate what you need
08:20:13 <Big_G> > tail [1..]
08:20:15 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
08:20:32 <Big_G> > reverse [1..]
08:20:40 <lambdabot>  mueval: signalProcess: permission denied (Operation not permitted)
08:20:40 <lambdabot>  mueval-core: Time limit exceeded
08:20:53 <tomphreek> jophish: at line 8 I know it won't be needed. If I want to check whether it's needed later on I need to evaluate it (I need length of the list to tell if it's needed, so haskell will be forced to evaluate it in order to throw it away)
08:23:03 <jophish> tomphreek: somehting like this: http://lpaste.net/120465
08:23:15 <jmcarthur> tomphreek: why not:   takeWhile (<=3) $ do { x <- [1, 2, 3]; y <- [2, 5, 100, 500]; return (x*y) }
08:24:02 <Kneiva> takeWhile (< 3) [a * b | a <- [1..], b <- [2,5,100,500]]
08:24:04 <Welkin> > tails [1..]
08:24:05 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
08:24:12 <Kneiva> jmcarthur: bet me to it =)
08:24:12 <Welkin> > tails [1..3]
08:24:14 <lambdabot>  [[1,2,3],[2,3],[3],[]]
08:26:13 <tomphreek> jophish: marvelous, thank you
08:26:31 <jophish> tomphreek: I don't think my answer is particularly neat
08:26:41 <jophish> and I've not checked if it typechecks or anything
08:26:53 <jtanguy> tomphreek: haskell does not need to fully evaluate a list to know its length
08:27:02 <jtanguy> > length [1,2,3,4,undefined, undefined]
08:27:03 <lambdabot>  6
08:27:30 <jtanguy> > [1,2,3,4,undefined, 5, undefined, 6]
08:27:31 <lambdabot>  [1,2,3,4,*Exception: Prelude.undefined
08:28:13 <coltfred> jtanguy: Huh, how's that work? I assumed length was O(n) and walked the list
08:28:36 <jtanguy> it walks _the structure_ of the list
08:28:38 <tomphreek> coltfred: don't evaluate the nodes
08:28:42 <jtanguy> not its contents
08:28:56 <coltfred> _ : tail?
08:30:00 <narendraj9> How much memory would the list occupy after we have traversed the _structure_ only? A list of pointers?
08:32:21 <sccrstud92_> and the thunks they point to
08:32:33 <jophish> narendraj9: ideally nothing if there are no more references to it
08:33:35 <narendraj9> If there are references to it, then instead of the list being a thunk itself, it would become a list of thunks?
08:33:49 <narendraj9> sccrstud92_: Okay. I see.
08:35:29 <Big_G> tails [1, 2, 3]
08:35:36 <Big_G> > tails [1, 2, 3]
08:35:37 <lambdabot>  [[1,2,3],[2,3],[3],[]]
08:38:26 <mfzb111> > traceShow 3 4
08:38:27 <lambdabot>  Not in scope: ‘traceShow’
08:39:43 <tomphreek> jophish: It works with a tiny modification, awesome!
08:40:14 <jophish> tomphreek: glad I could help
08:46:03 * hackagebot OpenGLRaw21 2.0.0.0 - The intersection of OpenGL 2.1 and OpenGL 3.1 Core  http://hackage.haskell.org/package/OpenGLRaw21-2.0.0.0 (JakeMcArthur)
08:49:31 <l3france> Is there a reason why "let eq' = (==)" results in a function whose type is not the same as ==?
08:49:35 <Big_G> What is a thunk?
08:50:00 <Welkin> :t let eq' = (==) in eq'
08:50:01 <lambdabot> Eq a => a -> a -> Bool
08:50:05 <Welkin> :t (==)
08:50:06 <lambdabot> Eq a => a -> a -> Bool
08:50:19 <Welkin> Big_G: a thunk is an unevaluated computation
08:50:31 <geekosaur> l3france, monomorphism restriction
08:50:36 <geekosaur> @where dmr
08:50:36 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
08:50:42 <Big_G> Welkin, So 2+2 is a thunk while 4 isn't?
08:50:54 <Welkin> Big_G: everything is a thunk until it is evaluated
08:51:03 * hackagebot OpenGLRaw21 2.0.0.1 - The intersection of OpenGL 2.1 and OpenGL 3.1 Core  http://hackage.haskell.org/package/OpenGLRaw21-2.0.0.1 (JakeMcArthur)
08:51:41 <Big_G> Welkin, So 4 could be a thunk until it is used?
08:51:42 <Welkin> thunks are only evaluated when they are needed for other computations, like printing the value
08:51:44 <geekosaur> actually 4 is a thunk too (mainly because of some jiggery-pokery that makes numbers polymorphic, which introduces a thunk)
08:51:46 <Welkin> yes
08:52:05 <Welkin> or if a strict function is applied
08:52:06 <Big_G> Welkin, Thanks for the vocab lesson
08:52:07 <l3france> Welkin: okay that's what I expected, but when I do "let eq' = (==)" and then ":t eq'" on separate lines in ghci, it gives "eq' :: () -> () -> Bool"
08:52:09 <Welkin> like +
08:52:49 <geekosaur> l3france, http://www.haskell.org/haskellwiki/Monomorphism_restriction
08:52:51 <l3france> geekosaur: okay I will check that link out!
08:53:35 <geekosaur> basically, any binding without parameters has its type forced to be specific. ghc would complain about your binding; ghci has some extra rules, so it forces the type to be based on ()
08:54:45 <geekosaur> you generally expect that when you say `let foo = ...` and then use foo somewhere, they're all the same foo. if it is polymorphic, they're not all the same foo, they're all distinct "clones" of it with their own specific types as needed
08:55:38 <geekosaur> laziness makes this significant because it gets us a cheap form of memoization (not recomputing stuff when it's aready been done) --- you lose this if it has to instantiate it with a specific type all the time
08:55:53 <geekosaur> so they're forced to a monomprphic type, and now they can be shared and memoization works
08:55:55 <Big_G> What would you the biggest realization you've had from learning Haskell is?
08:56:12 <geekosaur> *monomorphic type
08:56:37 <Welkin> Big_G: programs are transformations on data, and the types encode those transformations
08:57:08 <Big_G> Welkin, What do you mean by that last part?
08:57:19 <Welkin> the types tell you what happens to the data
08:57:20 <l3france> geekosaur: Ah okay, so since I used it in a let statement, ghc(i?) wants to just have one computed thing without having to redo it every time, which requires that it's type is determined
08:57:34 <Big_G> Welkin, The function types?
08:57:36 <l3france> and unit is the easiest thing to restrict it's type to?
08:57:39 <Welkin> yes
08:57:53 <Big_G> Makes sense
08:58:14 <geekosaur> l3france, ghc wants it as well, it is just less insistent about assigning it a type (after all, that () -> () -> Bool is kinda useless)
08:58:33 <geekosaur> ghci tries harder because people like to use ghci in a "desk calculator" type of mode
08:58:48 <Welkin> use emacs quickcalc!
08:59:00 <geekosaur> anyway, the rationale behind it won't make much sense until you develop an intuition for non-strict evaluation
08:59:04 <greenhorn> hello, is this the Haskell Channel for beginner ?
08:59:12 <Welkin> greenhorn: #haskell-beginners
08:59:19 <greenhorn> thanks
08:59:50 <l3france> Wait, but if that link says it's turned off by default in GHCi, wouldn't that mean that the restriction occurs when compiling with ghc, and not appear when using ghci?
09:02:48 <geekosaur> l3france, actually it depends on what version of ghci. if you have ghc 7.6 or older then ghci has it turned on. 7.8 and up have it off in ghci, because sharing isn't often useful in a "desk calculator"
09:03:23 <geekosaur> whereas being able to play around with types is useful, so you want an accuate reflection of types without having to force the issue with a type signature
09:04:25 <geekosaur> (I don't recall the exact version where ghci started defaulting it off, even... might be on in some 7.8 releases; should be default off in 7.8.4)
09:05:29 <l3france> geekosaur: Okay, I think I am going to go read that page in depth and come back to it afterwards. Thanks for your help! : )
09:05:58 <geekosaur> no problem. it's one of the things that always confuses newcomers
09:06:07 <geekosaur> which is why we have a wiki page about it :)
09:07:42 <geekosaur> (just to give you an idea, when I asked the bot to point to the wiki page I asked for "dmr". The "d" usually means "dreaded" --- although many people tripping over it often use a stronger word :)
09:14:12 <agocorona_> I just finised "an EDSL for hardworking IT programmers" https://www.fpcomplete.com/user/agocorona/An%20EDSL%20for%20hard%20working%20IT%20programmers
09:15:39 <agocorona_> a draft open to critics
09:18:39 <l3france> geekosaur: haha okay, thanks for that link, it was very informative : )
09:32:22 <cschneid> Is there a library that implements a SortedList type, that holds that invariant, but otherwise has the normal list functions?
09:34:05 <Ainieco> hello
09:34:39 <Ainieco> reading this currently http://strictlypositive.org/Easy.pdf and they say that normal form is "a variable applied to a (possibly
09:34:41 <Ainieco> empty) sequence of values, or it is a lambda abstraction"
09:35:37 <Ainieco> but in 2 section(evaluation) they say that "The rules we present will evaluate a term to its normal form. As a result, unlike Haskell, we will
09:35:52 <Ainieco> continue to evaluate under a lambda."
09:36:06 * hackagebot MonadCompose 0.4.0.0 - Methods for composing monads.  http://hackage.haskell.org/package/MonadCompose-0.4.0.0 (JamesCandy)
09:37:30 <Ainieco> but lambda is a normal form and they say they will eval a term to tormal form. why continue lambda eval then?
09:38:48 <Ainieco> i don't get it
09:39:11 <edwardk> @remember Taneb I love how there's something in lens that has 32 lines of documentation. Then its definition is "id"
09:39:11 <lambdabot> Good to know.
09:40:11 <sssilver|> OK well. I've read 7 chapters of a certain famous Haskell book, more or less understood everything, everything makes sense, except... After 7 chapters, I still have no idea how to write "Hello, world"
09:40:30 <sssilver|> At first I thought I must have skipped/forgot something
09:40:37 <sssilver|> went back, re-read every chapter
09:40:47 <sssilver|> nope, still don't know how to write a Hello world program
09:40:58 <Ally> it's not that you can't
09:41:06 <sssilver|> Ally: that's good to know!
09:41:09 <Ally> but I feel the advantages of functional programming lie elsewher
09:41:11 <Ally> e
09:41:38 <MP2E> sssilver|: main = putStrLn "Hello World!"
09:41:42 <Ally> its ties to subjects like math and discrete are more obvious than those of imperative programming like C++ or Java
09:41:50 <nick_named> > putStrLn "Hello, world"
09:41:52 <lambdabot>  <IO ()>
09:41:53 <Ally> something like helloworld is not as emphasized
09:42:01 <MP2E> lambdabot doesn't run IO
09:42:24 <MP2E> > "Hello, world"
09:42:26 <lambdabot>  "Hello, world"
09:42:47 <sssilver|> I've never read a programming language book before that wouldn't teach me how to write Hello world in the first 7 (!!!) chapters
09:43:00 <sssilver|> I mean, I'm halfway through :)
09:43:21 <sssilver|> I'm gonna start making my own typeclasses in the next chapter
09:43:44 <KaneTW> @hoogle :: Void
09:43:46 <lambdabot> Warning: Unknown type Void
09:43:46 <lambdabot> Prelude undefined :: a
09:43:46 <lambdabot> Test.QuickCheck discard :: a
09:45:16 <sssilver|> so I feel like Haskell programs just exist in the void, they don't ever communicate with any external sources, and they never produce any output.... They are these Zen abstract machines, fully abstracted from everything tangible
09:45:24 <hodapp> hmm, I wonder what's worse, doing (join $ fooN <$> arg1 <*> arg2 ... <*> argN), or doing (join $ liftMN $ fooN arg1... argN)
09:45:35 <MP2E> I just showed you how to write Hello World. It very much communicates with outside sources
09:45:45 <MP2E> I don't think it is brought up early because IO is trickier than most languages
09:45:47 <MP2E> it requires more thinking
09:45:58 <chrisdone> hodapp: both suck
09:46:04 <MP2E> :t putStrLn
09:46:05 <lambdabot> String -> IO ()
09:46:07 * hackagebot mtl-compat 0.2.0.4 - Backported Control.Monad.Except module from mtl  http://hackage.haskell.org/package/mtl-compat-0.2.0.4 (ryanglscott)
09:46:11 <chrisdone> hodapp: but idiom brackets are cool: http://hackage.haskell.org/package/applicative-quoters-0.1.0.8/docs/Control-Applicative-QQ-Idiom.html
09:46:16 <sssilver|> MP2E: yup
09:46:33 <MP2E> As you see there, putStrLn is a pure function that takes a String and returns an IO action
09:46:47 <MP2E> this IO action is run by the runtime when you run the program
09:46:59 <sssilver|> MP2E: I even understand actions! (or I am ignorant enough to think I do)
09:47:06 <chrisdone> i should take over maintainership of that package and bring it up to speed
09:47:12 <init> MP2E: they don't require more thinking, they need a different way of thinking, that's easier to see if you play with simpler examples first, I'd say
09:47:18 <hodapp> chrisdone: hmmmm...
09:47:36 <chrisdone> hodapp: they're a Conor McBride invention but for reasons unknown to me was never added to GHC
09:48:10 <hodapp> also, as it happens, foo1... fooN are automatically generated and I could probably just generate (join $ liftM)'ed versions for each
09:48:50 <hodapp> they're not generated with TH but they should be probably...
09:49:06 <hodapp> either that or I should just figure out how Text.Printf does the variadic stuff
09:49:33 <chrisdone> http://weknowgifs.com/wp-content/uploads/2013/03/its-magic-shia-labeouf-gif.gif
09:49:45 <hodapp> that's the most I've figured out so far
09:49:53 <MP2E> haha
09:49:54 <hodapp> I have basically my own printf wrapper here for generated C code
09:51:07 * hackagebot mtl-compat 0.2.1.3 - Backported Control.Monad.Except module from mtl  http://hackage.haskell.org/package/mtl-compat-0.2.1.3 (ryanglscott)
09:51:09 * hackagebot mtl-compat 0.2.1.2 - Backported Control.Monad.Except module from mtl  http://hackage.haskell.org/package/mtl-compat-0.2.1.2 (ryanglscott)
09:51:11 * hackagebot mtl-compat 0.2.1.1 - Backported Control.Monad.Except module from mtl  http://hackage.haskell.org/package/mtl-compat-0.2.1.1 (ryanglscott)
09:51:12 <MP2E> init: Yeah true, I find Haskell has decreased my mental overhead a lot, dealing with IO or otherwise, but at first it took me some time to come to grips with how 'evaluation' and 'execution' are different things :)
09:51:18 <chrisdone> it occurs to me that idioms can also be written $(idiom [| … |]) which would support more syntax than HSE
09:51:23 <chrisdone> but that's a bit longer to write
09:51:55 <hodapp> quasiquoting things seems to mess with haskell-mode in Emacs
09:52:06 <hodapp> and I'm not sure sometimes how to document quasi-quoted stuff in Haddock
09:52:07 <chrisdone> what part?
09:52:11 <clintm> I just want to confirm that I'm on the right track with something. It's been a solid year since I've written anything and the dev environment seems to have changed.  If I start from a bare machine with the latest stable ghc, and haskell/cabal from github, is it expected that if I want everything to work correctly, I sandbox everything else and symlink the executables?  happy and alex come to mind.
09:52:39 <hodapp> chrisdone: its attempts to suggest indentation level
09:52:43 <Big_G> > length [1..100000000000000]
09:52:46 <hodapp> sometimes it just says 'parse error' or something like that
09:52:47 <lambdabot>  mueval-core: Time limit exceeded
09:53:04 <chrisdone> hodapp: oh, okay
09:53:06 <Big_G> Is there a way to get array like properties from a list?
09:53:14 <chrisdone> structured-haskell-mode supports quasiquotes
09:53:28 <hodapp> the particular quasiquotation I'm using I don't particularly like either though...
09:53:32 <geekosaur> Big_G: a list is a singly linked list, it's not an array. consider using Vector instead
09:53:52 <geekosaur> (actually it's most like Lisp cons cells. it's not ever going to behave like an array type)
09:53:59 <hodapp> perhaps I'll look at structured-haskell-mode
09:54:08 <hodapp> still need to figure out how to make Haddock grok this though...
09:54:09 <Big_G> geekosaur, Are you able to use a vector in the same way with comprehensions?
09:54:39 <geekosaur> I don't think so. that's getting into the DPH extensions which are currently kaput :/
09:55:16 <Big_G> geekosaur, So I'm stuck with poor performance on some search/sort algorithms that would be much better suited to an array?
09:56:41 <geekosaur> let me ask this: are you wedded to list comprehension syntax? because there's usually some equivalent, and even on lists I'm more likely to ignore the list comprension syntax
09:57:00 <Big_G> geekosaur, I like it but I'm willing to experiment
09:58:23 <geekosaur> look at http://lambda.haskell.org/platform/doc/current/packages/vector-0.10.0.1/doc/html/Data-Vector.html#g:14 and following sections for "bulk" operations on Vectors
09:58:46 <barrucadu> Is there a way to re-use the haddock of some identifier? I've got a typeclass with documentation for all the entries, and then in two different modules implementing that typeclass I'm re-exporting functions of the class, but with specialised types, so it's simpler. But at the moment I'm just copying and pasting the documentation across, which isn't ideal.
09:58:48 <Big_G> Thanks. I have to leave soon but I'll look at it tonight
09:59:03 <geekosaur> you don't get the pretty comprehension syntax but you get much the same kinds of operations, and sometimes the alternative syntax works out better anyway depending on what you're doing
09:59:52 <Big_G> I was just hoping to improve the performance
10:00:43 <Kaligule> Hi there.
10:01:10 <Kaligule> I want to parse a term (something like x^2 + (sin(cos(x)) )
10:01:34 <Kaligule> I tried it using parsec, but I don't seem to get it right
10:01:54 <Kaligule> (have problems with * before +)
10:02:40 <Kaligule> I assume parsing terms with parsec is not so uncommon, is there some project I can learn from?
10:06:22 <Moggle> Kaligule: RWH has a chapter on it, you might find it useful http://book.realworldhaskell.org/read/using-parsec.html
10:06:42 <Moggle> As I recall, it's outdated in types, but the core information is still true
10:06:47 <Moggle> may want to check the comments
10:07:02 <geekosaur> parsec has a higher level interface that can do things like operator precedence. https://hackage.haskell.org/package/parsec-3.1.0/docs/Text-Parsec-Expr.html
10:33:36 <Kaligule> Moggle: I already read rwh, but it didn't help me there. It seems that they aimed more to file parsing (which indeed is much more a thing you would need in the real world).
10:34:15 <Kaligule> geekosaur: Wow, thats cool. I definitely will have a look at that, thanks.
10:38:43 <quchen> kosmikus: Ping, or: you're Löh, right?
10:39:12 <quchen> My name/IRC association is a bit rusty.
10:39:43 <bergmark> quchen: you are correct!
10:40:02 <bergmark> why don't everyone use their real name :(
10:40:07 <quchen> bergmark: While we're at it, who are you? Were you at the meetup yesterday?
10:40:16 <bergmark> i was not at a meetup yesterday
10:40:23 <bergmark> I am Adam Bergmark believe it or not
10:40:39 <DavidLuposchains> Yeah, so my name is too long for IRC
10:41:07 <sccrstud92> agocorona_: paralelization -> parallelization
10:41:10 * hackagebot pipes-safe 2.2.1 - Safety for the pipes ecosystem  http://hackage.haskell.org/package/pipes-safe-2.2.1 (GabrielGonzalez)
10:41:11 <cmtptr> my real name is already registered by someone on freenode staff
10:41:21 <begood> irc
10:41:36 <geekosaur> it happens.
10:41:48 <bergmark> quchen: i see your name in your WHOIS so it's ok!
10:41:56 * geekosaur uses this nick because there's a better-known Allbery running about, and several better-known Brandons
10:42:08 <sccrstud92> agocorona_: use a spell checker, i see a couple typos that would be caught
10:42:52 <bergmark> it also helps if you manage to get the same irc nick and github id
10:43:00 <agocorona_> sccrstud92:  where?
10:43:08 <agocorona_> wherhe?
10:43:32 <sccrstud92> agocorona_: paralelization, paragrap
10:43:39 <agocorona_> ok, in the article. thanks
10:43:45 <sccrstud92> yeah, sorry
10:43:48 <sccrstud92> article
10:44:08 <KaneTW> using esqueleto, how can i apply a sql function to a field
10:45:03 <sccrstud92> KaneTW: does esqueleto support sql functions?
10:45:20 <KaneTW> no idea
10:45:32 <KaneTW> it does say "
10:45:35 <KaneTW> Support the mostly used SQL features. We'd like you to be able to use esqueleto for all of your queries, no exceptions"
10:45:44 <KaneTW> i just can't find anything in the module
10:46:10 <sccrstud92> KaneTW: so you want something like "select foo(field) from ..."
10:46:20 <sccrstud92> but you dont know how to do the foo parT?
10:46:23 <KaneTW> yeah
10:47:35 <sccrstud92> KaneTW: my initial guess is you cant do it, but im not that familiar with esqueleto. only used it once before. is there are reason you prefer performing the funciton on the mysql side instead of the haskell side?
10:47:58 <KaneTW> not particularly
10:48:04 <arw_> no idea about esqueleto, but most ORMs claim to support "all of SQL" by knowing 3 types of joins :>
10:48:10 <KaneTW> i'm just wondering if you can
10:49:17 <sccrstud92> KaneTW: what funciton are oyu looking for?
10:49:35 <KaneTW> to_date in this case
10:50:01 <arw_> KaneTW: docs say "Not all SQL features are available, but most of them can be easily added (especially functions)"
10:50:23 <sccrstud92> KaneTW: yeah there are a lot of function included. someone could probably fork and add one easily
10:50:38 <KaneTW> kay
10:50:56 <fryguybob> agocorona_: You should have {-# NOINLINE ... #-} pragmas for your uses of unsafePerformIO to get global variables.
10:50:56 <KaneTW> i'll probably just work around it until i actually need sql functions
10:51:29 <sccrstud92> KaneTW: is there raw query support you can use?
10:51:41 <KaneTW> yes
10:53:17 <agocorona> fryguybob:  ok
10:54:35 <fryguybob> For more information see: http://wiki.haskell.org/Top_level_mutable_state
10:56:02 <arw_> KaneTW: you could also create a view that is the original table with the desired function applied and select from that.
10:56:11 * hackagebot semigroupoids 4.3 - Semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-4.3 (EdwardKmett)
10:56:18 <arw_> KaneTW: usually most tools don't know or care about views
11:00:40 <KaneTW> yup
11:01:11 * hackagebot exceptions 0.8 - Extensible optionally-pure exceptions  http://hackage.haskell.org/package/exceptions-0.8 (EdwardKmett)
11:04:11 <chrisdone> haasn: ping. do you have a full-page version of the haskell 2010 report generated?
11:05:56 <cmtptr> what's the lambdabot prefix?
11:06:32 <Clint> ask a better question
11:06:51 <cmtptr> how do I invoke lambdabot?
11:07:02 <cschneid> > putStrLn ">"
11:07:04 <lambdabot>  <IO ()>
11:07:11 <Clint> @pl \x -> x + 1
11:07:11 <lambdabot> (1 +)
11:07:21 <cschneid> :t putStrLn
11:07:22 <lambdabot> String -> IO ()
11:07:50 <cmtptr> there we go.  @help or @list is what I was after.  thanks
11:08:00 <lightstep> does lambdabot think that (+) is commutative?
11:08:34 <clrnd> wow
11:08:41 <clrnd> @pl \x -> x - 1
11:08:41 <lambdabot> subtract 1
11:08:50 <clrnd> @pl \x -> 1 + x
11:08:50 <lambdabot> (1 +)
11:09:16 <lightstep> @pl \x -> x * 1
11:09:16 <lambdabot> id
11:09:18 <lightstep> @pl \x -> x * 2
11:09:18 <lambdabot> (2 *)
11:09:24 <lightstep> smart!
11:09:26 <clrnd> that's way smarter than me
11:09:38 <lightstep> @pl \x -> x * 1 + 0
11:09:38 <lambdabot> id
11:09:44 <lightstep> @pl \x -> x + x - x
11:09:44 <lambdabot> (-) =<< join (+)
11:09:49 <clrnd> pffff
11:11:11 <sccrstud92_> is \x -> x * 1 === id  always true? doesnt it depends on the num instance?
11:11:28 <clrnd> I guess `1` defines the Num instance
11:11:37 <sccrstud92_> :t 1
11:11:38 <lambdabot> Num a => a
11:11:41 <sccrstud92_> nope
11:11:42 <clrnd> lol
11:12:04 <lightstep> probably it's one of the class laws
11:12:45 <sccrstud92_> maybe, though I was under the impression that the Num class laws were a little lax
11:20:56 <cmtptr> so, I have this line: main = parse "file.txt" >>= dump . trim  -- I don't want to write parse just yet; I'd rather hard-code its return value (parse :: FileName -> IO [Row]).  How do I do that?
11:21:53 <Clint> cmtptr: parse fn = return []
11:22:09 <cmtptr> oh return, of course
11:22:13 <cmtptr> I keep forgetting about that
11:23:13 <pjdelport> cmtptr: Or pure. :)
11:23:24 <ronda> it is really nice with mondeas when you have code lik if (cond) {if (con2)}....
11:24:31 <cmtptr> pjdelport, so would it be better to write parse :: String -> [Row] and leave it up to the caller to readFile?
11:26:01 <lightstep> going pure will prevent you from using IO inadvertantly in the implementation... and may simplify some of the syntax
11:27:07 <tac_> Anyone have any idea off the top of their head,
11:27:09 <pjdelport> cmtptr: It would make sense to have parse :: String -> [Row], and then as a convenience, say, parseFile :: FilePath -> IO [Row]; parseFile f = parse <$> readFile f
11:27:38 <tac_> Why I have a field _x and a makeLenses thingy, and no lens x is being exported from my module?
11:27:59 <pjdelport> cmtptr: That way, you separate the functional logic from the IO, which is always a good thing.
11:28:29 <pjdelport> (Rule of thumb, you IO should be a thin shell over your functional core, wherever possible.)
11:28:40 <pjdelport> (your IO, even)
11:28:55 <cmtptr> so when I print out the result, I guess my dump function also shouldn't be dump :: [Row] -> IO (), but rather dump :: [Row] -> String
11:29:38 <pjdelport> Right.
11:29:45 <cmtptr> thanks
11:30:08 <pjdelport> Same idea; then you can write a dumpToFile :: FilePath -> [Row] -> IO ()
11:30:16 <tac_> oh
11:30:18 <tac_> apparently: http://stackoverflow.com/questions/17256091/existential-quantifier-silently-disrupts-template-haskell-makelenses-why
11:30:32 <pjdelport> Which just uses the pure dump to do the conversion from [Row] to String.
11:30:40 <cmtptr> right
11:32:20 <tac_> In that case, can anyone point me to how lenses for a datatype are defined using makeLenses?
11:33:01 * extor just thought of squidoo after hearing that
11:35:37 <zachstone> Is there a way to make something like "(:+) <$> [1..10] <*> [1..10]" generate a list of lists instead of one large list?
11:36:33 <pjdelport> zachstone: What would you want, exactly?
11:37:05 <sssilver|> Guys, so I need a very basic 2D rendering library (module?) to implement my first real Haskell project (a game of tetris!). It should be simple enough that I don't have to "learn" it, allowing me to focus on Haskell itself and the gameplay logic. Recommendations?
11:37:21 <zachstone> A list of 10 lists, with 10 elements in each.
11:37:38 <pjdelport> The list Applicative won't give you that.
11:37:53 <pjdelport> What would the lists actually be?
11:37:54 <Welkin> sssilver|: Gloss or SDL
11:37:55 <zachstone> Yeah, I figured that :P
11:38:06 <pjdelport> Would it differ from "repeat 10 [1..10]"?
11:38:25 <sssilver|> I literally just need something that'll let me say "draw this sprite at these coordinates", and also probably process user input and create a window in a platform-independent way
11:38:28 <pjdelport> Err, "replicate 10 [1..10]", even.
11:38:34 <zachstone> I'm trying to make a grid to generate an image of the mandelbrot set.
11:38:43 <sssilver|> Welkin: thanks!
11:38:57 <pjdelport> zachstone: Ah; have you looked at Array, or similar?
11:39:04 <tac_> nvm
11:39:10 <pjdelport> Lists of lists are probably not a very good representation of this.
11:39:17 <sssilver|> wow gloss seems cool haha, I can zoom stuff in
11:39:29 <pjdelport> You can use Array to define a true 2D array with performant access, instead.
11:39:35 <zachstone> Heh, I see. No, I haven't. I'll go look into that.
11:40:21 <pjdelport> zachstone: The Array API might be a bit imposing, if you're just encountering it for the first time, but it's very powerful.
11:40:29 <pjdelport> https://wiki.haskell.org/Arrays has an introduction
11:41:22 <zachstone> Ah. Well would lists work, at least? I"m just trying to get something going, because I'm pretty sure my mandelbrot algorithm is off anyways.
11:41:46 <zachstone> I just wanted something to visualize.
11:41:54 <pjdelport> zachstone: It's probably worth trying Array; the channel can help. It will make working with the 2D coordinates easier than lists of lists, to start with.
11:42:10 <pjdelport> You can define an array to be directly indexed by tuples of (x, y)
11:42:16 <pjdelport> Instead of having to do your own acrobatics for it.
11:43:58 <zachstone> Haha, well I'm just mapping over it anyways, not explicitly accessing elements.
11:44:25 <pjdelport> > array ((0,0), (10,10)) [ ((x,y), x+y) | x <- [0..10], y <- [0..10] ]
11:44:26 <lambdabot>  array ((0,0),(10,10)) [((0,0),0),((0,1),1),((0,2),2),((0,3),3),((0,4),4),((0...
11:45:14 <pjdelport> zachstone: That array is indexed by (x,y) tuples. The first argument is the lower and upper bound: (0,0) is the one corner, and (10,10) is the opposite corner.
11:45:26 <cmtptr> and if I have a record with five fields, is there a better way to do this: dump' (Row a b c d e) = intercalate "\t" [show a, show b, show c, show d, show e] ?
11:45:32 <pjdelport> So that defines a 2D square, indexed from 0 to 10 on each side.
11:46:04 <pjdelport> And then the list comprehension defines the values for each index: in this case, it's just the sum of each x and y coordinate, but you can insert the Mandelbrot function in there instead.
11:46:20 <zachstone> ... Well I can't scroll up in irssi for some reason.
11:47:28 <zachstone> Alright, let me mess with that for a bit.
11:49:35 <zachstone> pjdelport: Which Library is that array in?
11:50:17 <pjdelport> zachstone: Data.Array
11:50:28 <pjdelport> zachstone: There are a few variants, for different purposes.
11:50:29 <zachstone> Ah, thanks.
11:50:37 <zachstone> Yeah, I see that >_>
11:51:00 <pjdelport> You might be interested in UArray: it uses an unboxed representation, which is more memory-efficient when you have big, strict arrays of types like numbers.
11:51:15 <pjdelport> (Using the variants are largely the same.)
11:56:15 * hackagebot monad-control 0.3.3.1 - Lift control operations, like exception catching, through monad transformers  http://hackage.haskell.org/package/monad-control-0.3.3.1 (BasVanDijk)
12:00:21 <Welkin> used unboxed arrays unless you *need* boxed arrays
12:00:23 <Welkin> use*
12:01:06 <chrisdone> pjdelport: how does UArray compare with unboxed Vector?
12:01:12 <augur> anyone have a good tutorial on implementing prolog-y stuff in haskell? :T
12:01:16 * hackagebot monad-control 1.0.0.4 - Lift control operations, like exception catching, through monad transformers  http://hackage.haskell.org/package/monad-control-1.0.0.4 (BasVanDijk)
12:01:32 <pjdelport> chrisdone: The biggest difference in this case probably is that UArray lets you use (x,y) as the index type.
12:01:53 <pjdelport> While with vector, you have to manually do your own row or column striding (at least as far as i know).
12:02:24 <pjdelport> OTOH, Vector can be slightly than Array, as far as i understand, and it also has more convenience functions for things.
12:02:39 <Welkin> pjdelport: it's easy enough to index into a "multi-dimensional" vector using an equation
12:02:42 <pjdelport> (slightly faster than Array, even)
12:02:46 <Welkin> vector is very nice
12:03:01 <pjdelport> Welkin: Right, right, but why do that when Ix can do it for you? :)
12:03:02 <_ryan> hi everyone.. can i ask here about yesod?
12:03:11 <simon_> _ryan, you can try.
12:03:45 <pjdelport> I think the mental simplification that Array gives you for multi-dimensional index is worth something, in cases like this.
12:03:47 <_ryan> simon: i have a problem installing it on my machine. my OS is win..
12:04:14 <tommd> _ryan: How about you paste your error from `cabal update && cabal install yesod -v3`
12:04:22 <simon_> _ryan, I accidentally wrote to you on #yesod. :)
12:04:27 <chrisdone> pjdelport: hmm tuples are boxed, though, that seems like it would have a speed hit when indexing
12:04:29 <kuznero> Hi All!
12:04:43 <pjdelport> chrisdone: Well, the tuples don't take up any storage.
12:04:46 <tommd> @where paste -- _ryan
12:04:46 <lambdabot> Haskell pastebin: http://lpaste.net/
12:04:59 <ReinH> chrisdone: o/
12:05:09 <chrisdone> pjdelport: i suppose if ghc compiles it down to two registers that's ok
12:05:12 <chrisdone> ReinH: sup homie
12:05:23 <pjdelport> Yeah.
12:05:44 <pjdelport> chrisdone: My instinct is to go for algorithm convenience first. If Array makes things simpler to express, then that's a win.
12:05:57 <ReinH> chrisdone: what up g
12:06:03 <pjdelport> If you run into a bottleneck, and optimizing to Vector makes enough of a difference to be a win, then that's a second step. :)
12:06:16 * hackagebot lifted-base 0.2.3.6 - lifted IO operations from the base library  http://hackage.haskell.org/package/lifted-base-0.2.3.6 (BasVanDijk)
12:06:21 <ReinH> pjdelport: just hide your column striding behind an IndexedTraversable interface ;)
12:06:35 <pantsman-> any fpcomplete people around? Just wondering why your Hoogle doesn't warn when searching for an unknown type; instead it interprets it as a type parameter even if it began with uppercase.
12:06:36 <pjdelport> ReinH: Oh, i'm not familiar with that.
12:06:50 <pjdelport> ReinH: How does it compare to Ix in terms of convenience?
12:07:31 <chrisdone> pjdelport: sure, but if vector *is* significantly faster then that's worth knowing as an option to port from array to it when it's time to optimize
12:08:16 <chrisdone> i'm still waiting for someone to write a small booklet on the various haskell data structures; their use-cases and performance characteristics
12:08:35 <ReinH> Hmm, did the lens interface change here or am I misremembering?
12:08:37 <chrisdone> it'd be a great learning experience to write one myself, but i'd rather someone else do it
12:10:19 <chrisdone> even cooler would be to make a package that just imports them all and defines a big-ass benchmark suite and the haddocks could be the explanation
12:10:32 <cschneid> What's the lowest ceremony "database" library? Either for a real relational db, acidstate, whatever.  I'd like to just throw data at it and then find it later. Mongo style perhaps?
12:10:43 <cschneid> I just need to store stuff and don't want to bother too much w/ that layer for now
12:11:18 <colah> Hi! I've been writing a visual reference for fold*/scan*/map*/unfoldr from Data.List -- you can find a draft here: http://colah.github.io/posts/2015-02-DataList-Illustrated/ . If anyone has some time, I'd appreciate someone taking a quick glance to make sure there aren't any errors.
12:12:38 <cschneid> colah: I like it :)
12:13:01 <colah> cschneid: Thanks!
12:13:04 <kuznero> colah: Looks cool
12:13:43 <shachaf> hi colah
12:14:08 <shachaf> I think saying unfoldr "actually starts on the left" suggests that foldr "starts on the right", which is misleading (because it doesn't).
12:14:13 <ReinH> colah: Cool. I think it would be a bit more clear if the tree format was represented in a top-down way, like http://colah.github.io/posts/2015-02-DataList-Illustrated/
12:14:34 <ReinH> s/format/structure
12:15:18 <shachaf> I think you might've intended to link to Cale's thing.
12:15:20 <ReinH> Uh, that is the wrong link, obviously
12:15:24 <ReinH> http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29
12:15:40 <ReinH> shachaf: which thing is Cale's thing?
12:15:50 <shachaf> The pictures you linked to are Cale's.
12:15:55 <shachaf> I think he also has some for other functions.
12:15:58 <ReinH> Oh. Cool.
12:16:18 * hackagebot either 4.3.3.2 - An either monad transformer  http://hackage.haskell.org/package/either-4.3.3.2 (EdwardKmett)
12:16:52 <ReinH> colah: Also getting a 404 here btw http://colah.github.io/posts/2014-07-Understanding-Convolutions/disqussion-5
12:17:30 <colah> ReinH: Ah, disqus gets cofused. :/
12:17:48 <colah> shachaf: Thanks, I'll think about how to reword that.
12:18:29 <coltfred> Is there a way to generate an Aeson FromJson instance for an ADT? For instance {"colors": ["Green", "Blue", "Black"]} and I have an ADT representing legal colors (data Color = Green | Blue | Black) , can I generate the code to convert to the ADT from Strings?
12:18:30 <colah> ReinH: The problem with the tree structure, I think, is that it works less well for some of the others.
12:18:43 <shachaf> I think "foldr starts from the right/foldl starts from the left" is a big misconception and slightly unfortunate naming.
12:19:00 <colah> shachaf: How would you describe it?
12:19:10 <shachaf> foldr is right-associative, foldl is left-associative
12:19:29 <chrisdone> the concept of 'starting' is a bit vague
12:19:58 <shachaf> foldr (*) 1 [a,b,c] = a * (b * (c * 1)), foldl (*) 1 [a,b,c] = ((1 * a) * b) * c
12:20:12 <colah> chrisdone: Yeah, I was relying on people looking at the diagrams.
12:20:13 <shachaf> Yes, "starts" is an odd word to use in the first place.
12:21:00 <ReinH> They both "start" from the left if "start" has anything to do with how expressions are evaluated/reduced.
12:21:02 <colah> shachaf: I think it depends on the whether ou are thinking from the perspective of fold, or the resulting computational graph.
12:21:43 <shachaf> There are lots of ways to reduce a graph.
12:21:51 <colah> True enough
12:22:15 <shachaf> foldr/foldl is about the value, not so much how you get to it.
12:22:24 <chrisdone> 'map' is definable in terms of foldr but i wouldn't say map "starts" from the right
12:22:27 <colah> This is true.
12:22:32 <shachaf> And yes, anything that works on a list has to start from the left, because that's the only part you get. :-)
12:23:12 <c_wraith> foldr definitely starts at the left.  It has a bunch of subtleties involving laziness - fully understanding them is helpful
12:23:17 <ReinH> Perhaps the problem is trying to mix denotational and operational semantics. "start" implies the latter, but it seems like you are talking about the former.
12:23:18 <shachaf> foldr is structural (and so is unfoldr); foldl is some strange thing specific to the idea of lists.
12:24:02 <colah> Thinking about it in terms of associativity feels a bit less accessible, though.
12:24:12 <colah> Ah.
12:25:03 <colah> I will think about this a bunch more.
12:25:12 <shachaf> Hmm, maybe it is less accessible.
12:25:30 <shachaf> But it's what the names mean, so if you don't talk about it, it might be better not to explain the names at all.
12:25:47 <shachaf> Talking about "starting on the left" is a bit misleading.
12:25:56 <chrisdone> certainly when i started learning foldl/foldr the main thing i thought was which way the applications of f nest, i.e. associativity. isn't that the main interesting thing?
12:26:41 <shachaf> I don't think grouping the parentheses this way or that is all that confusing.
12:26:57 <colah> chrisdone: The people I actually care most about are some machine learning people who are doing this, but definitely think about it as being from the right or left.
12:27:05 <chrisdone> me neither, it's the most elucidating thing for me
12:27:13 <ReinH> I think the tree structure makes the associativity easy to see. That is being lost in this presentation.
12:28:01 <chrisdone> http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=foldr+%28*%29+7+%5B1%2C2%2C3%2C4%2C5%5D
12:28:03 <shachaf> I also think the fact that foldr is structural is important.
12:28:27 <shachaf> Unless you're talking about foldr/foldl from Data.Foldable, which isn't biased like Data.List.
12:28:30 <c_wraith> I think the most important thing about foldr is that `foldr f ...` reduces to an application of f on non-empty lists, so its laziness properties depend on those of f.
12:28:36 <chrisdone> shachaf: what does structural mean here?
12:28:51 <shachaf> It's the thing that we'd normally call a fold if we weren't talking about lists. :-)
12:29:12 <shachaf> The two arguments to foldr correspond to (:) and [], i.e. the structure of a list.
12:29:12 <chrisdone> the fact that foldr (:) [] = id?
12:29:23 <shachaf> Right.
12:29:26 <chrisdone> gotcha
12:30:16 <shachaf> You can give foldr the type (Maybe (a,b) -> b) -> [a] -> b to show the symmetry with unfoldr, by the way.
12:31:10 <chrisdone> that's nice :3
12:31:44 <chrisdone> where foldr (maybe [] (uncurry (:))) would be the id?
12:31:53 * chrisdone making dinner, but thinks that's right
12:31:55 <shachaf> Right.
12:32:08 <chrisdone> that is pretty sweet
12:32:15 <shachaf> To be clearer you can define data Protolist a b = Nil | Cons a b
12:32:31 <shachaf> Then List a = Fix (Protolist a)
12:34:28 <shachaf> And you can define fold :: Functor f => (f a -> a) -> Fix f -> a
12:34:47 <shachaf> And unfold :: Functor f => (a -> f a) -> a -> Fix f
12:35:35 <shachaf> (And then you can define (co)lists directly as (un)folds and everything, it's great.)
12:35:40 <shachaf> (I feel like I've skipped a few steps.)
12:36:20 <chrisdone> corrr
12:36:26 <chrisdone> that's elegant
12:36:42 <cmtptr> why doesn't my ghc have a Data.Text module?
12:36:51 <clrnd> what's the state of the haskell platform? would it be useful for a 2hs introductory workshop?
12:37:07 <clrnd> cmtptr, ghc-pkg list | grep Text
12:37:08 <yyyyy> I still haven't grasped fixed points like the ones above, shachaf. Is there some introductory material? I recently got the 'Data types a la carte' paper, but haven't really dig into it. Any suggestions?
12:37:25 <cmtptr> clrnd, nothing
12:37:34 <clrnd> cmtptr, are you in a sandbox?
12:37:39 <cmtptr> no
12:37:45 <yyyyy> I feel like not understanding it is hindering my further studies of recursion schemes.
12:37:53 <clrnd> cmtptr, ghc-pkg list | grep text # case sensitive!
12:37:59 <cmtptr> I know
12:38:08 <clrnd> ok, my mistake anyway
12:38:17 <clrnd> cmtptr, you need to install it then
12:38:21 <shachaf> yyyyy: Hmm, I'm not sure.
12:38:40 <cmtptr> clrnd, is it not part of the base lib?  what is the package name?
12:38:44 <shachaf> yyyyy: I guess there is http://mainisusuallyafunction.blogspot.com/2010/12/type-level-fix-and-generic-folds.html
12:38:49 <clrnd> cmtptr, text
12:39:04 <cmtptr> thanks
12:39:13 <chrisdone> shachaf: i guess that could work with: data Maybe' a b = Nothing | Just a
12:39:30 <shachaf> chrisdone: Without the b you're not going to do much recursing.
12:40:23 <chrisdone> just thinking about whether the fold could work on both lists and Maybe, as a generalization of the deconstructing aspects of foldr and maybe
12:40:36 <chrisdone> but i guess it's unrelated
12:40:45 <shachaf> yyyyy: A good exercise is to take the types Mu («newtype Mu f = Mu { runMu :: forall r. (f r -> r) -> r }») and Nu («data Nu f = forall x. Nu x (x -> f x)»), which are both isomorphic to Fix («newtype Fix f = Fix { runFix :: f (Fix f) }») in Haskell, and figure out the relationships between them.
12:41:18 <shachaf> Note that they're only isomorphic in Haskell because Haskell isn't careful. In other languages they're different.
12:41:39 <shachaf> yyyyy: E.g., take Mu Maybe and Nu Maybe and figure out what their inhabitants are, and how they're different.
12:42:14 <shachaf> yyyyy: For clarity don't allow yourself recursive functions inside the Nu/Mu.
12:42:33 <seubert> why would `cabal build` find all my dependencies fine, but `cabal repl` fails and thinks it needs to add most of my dependencies to `<project>.cabal`?
12:42:44 <seubert> (i'm using a sandbox)
12:42:55 <yyyyy> shachaf: Ah, good link there. I'll run through it soon today and the new types.
12:43:13 <shachaf> I recommend this exercise to other people too, it's great.
12:43:20 <sssilver|> wow the records syntax is ugly as hell
12:43:58 <cmtptr> sssilver|, agreed
12:44:05 <yyyyy> I'll do it soon today still. Is the isomorphism in Haskell only due to...?
12:44:10 <yyyyy> Some of the typing rules?
12:45:04 <bitemyapp> hodapp: yerp :)
12:45:10 <clrnd> it's almost like in js or python ..
12:45:17 <bitemyapp> hodapp: I have a coauthor too! She'd never programmed before I started teaching her Haskell.
12:45:33 <shachaf> yyyyy: They're not isomorphic with this "don't allow recursion" constraint.
12:45:51 <yyyyy> To be fair this is something that I've always had a hard time. If you look at Idris for instance you can (mostly) read a paper and see the typing rules laid out, 'operational-wise', in one place. With Haskell it seems that each GHC extension changes something, or just some algorithmic aspect of type-checking, that I'm mostly lost in finding a single reference.
12:47:03 <yyyyy> I.e. I just wanted a PDF with all possible typing judgements, separated by extension. If this does not exist I (almost) feel like doing it myself.
12:47:31 <yyyyy> Hmmm, shachaf, I suppose it'll be clearer once I actually try the examples you mentioned.
12:47:35 <shachaf> You should do it!
12:47:38 <shachaf> Good luck.
12:49:51 <shachaf> (The PDF you mentioned, I mean.)
12:50:16 <shachaf> yyyyy: Mu is the least fixed point and Nu is the greatest fixed point, if you've come across that in other contexts. In Haskell those are the same thing.
12:52:13 <yyyyy> shachaf: Only saw it in a paper introducing codata and corecursion, where it was presented in a initial vs. terminal algebra scenario.
12:52:24 <shachaf> Right.
12:52:47 <shachaf> Maybe I should say initial and terminal rather than least and greatest, since this isn't an order anyway.
12:52:56 <yyyyy> I fail to see how they could be the same thing, but enlightenment comes from experience in this case. In some (maybe many) hours from now I might have a different opinion.
12:53:22 <Cale> shachaf, ReinH: http://cale.yi.org/share/Folds.png
12:53:30 <ReinH> Cale: :)
12:53:38 <shachaf> colah: ☝
12:53:44 <ReinH> Cale: pretty!
12:59:18 <hiptobecubic> scanl f z is a little terse...
13:04:21 <athan> Cale: IveGotToGetMeOneOfDese.wav
13:04:44 * athan goes back to his Will Smith shrine
13:06:21 * hackagebot digestive-functors-lucid 0.0.0.1 - Lucid frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-lucid-0.0.0.1 (athanclark)
13:16:05 <sssilver|> So what if someone REALLY has to do an IO action within a pure function?
13:16:21 * hackagebot y0l0bot 0.1.1 - #plaimi's all-encompassing bot  http://hackage.haskell.org/package/y0l0bot-0.1.1 (alexander)
13:16:25 <MP2E> unsafePerformIO http://hackage.haskell.org/package/base-4.7.0.2/docs/System-IO-Unsafe.html
13:16:36 <MP2E> you've now descended into the dark depths sssilver|, take care :P
13:16:41 <MP2E> hehe
13:16:51 <MP2E> generally you shouldn't use unsafePerformIO unless it's for an FFI call that is pure
13:16:52 <sssilver|> faster, easier, more seductive?
13:16:54 <MP2E> you just can't prove it
13:17:12 <MP2E> there's some good stackoverflow answers on the subject, *looks*
13:17:19 <barrucadu> If using unsafePerformIO be *very* certain that the function is actually referentially-transparent and has no lasting side-effects
13:17:21 <geekosaur> note that because you're doing IO inside a pure function, you can expect odd behavior. like it usually gets run exactly once
13:17:23 <MP2E> http://stackoverflow.com/questions/10529284/is-there-ever-a-good-reason-to-use-unsafeperformio
13:17:24 <geekosaur> and saved
13:17:44 <geekosaur> so it does no good to e.g. call a function to get the current time
13:17:50 <chrisdone> using unsafePerformIO is like that saying about asking how much a car costs
13:17:57 <chrisdone> "if you have to ask you can't afford it"
13:18:14 <sssilver|> well lets imagine that your whole architecture is messed up and ugly, and now you can't stick all those IO actions anywhere other than your regular pure functions
13:18:15 <shachaf> That's only sort of true.
13:18:28 <geekosaur> this is why you don't find many programs cheating and using unsafePerformIO; it really is as unsafe as it claims to be
13:18:33 <stephen_> Hello everyone, I'm having an issue running stylish-haskell in emacs: I get this error: http://lpaste.net/120477 Any suggestions?
13:18:43 <sssilver|> also, if your IO is actually only O, then what's the problem?
13:18:47 <geekosaur> you are violating the compiler's expectations and it *will* punish you for it
13:18:59 <sssilver|> output doesn't have any side effects by definition
13:19:06 <geekosaur> it may still only happen once, because any pure expression may be computed once
13:19:25 <sssilver|> also, how do you log stuff in Haskell?
13:19:31 <sssilver|> (architecture-wise)
13:19:33 <barrucadu> sssilver|: Output is a side-effect by definition: you're printing something to the console
13:20:21 <jmcarthur> sssilver|: the haskelly notion of a side effect is something that happens which is not observable to your code.
13:20:36 <chrisdone> jmcarthur: is it?
13:20:38 <jmcarthur> sssilver|: to be precise: as an effect of evaluation
13:21:02 <sssilver|> sure, but practically sending something to the video card cannot possibly create any actual side effects for your code to be concerned about
13:21:09 <sssilver|> video card / file / whatever
13:21:12 <chrisdone> i'd always personally reasoned that way, but i don't remember reading it stated anywhere
13:21:41 <jmcarthur> chrisdone: i didn't mean to convey that as though it was a formal, rigorous definition
13:21:42 <stephen_> chrisdone: I can second jmcarthur's definition
13:21:52 <barrucadu> Sure it can: what if you use unsafePerformIO to log to a file, and then read that file in your program?
13:21:53 <stephen_> (broadly speaking)
13:21:57 <chrisdone> jmcarthur: i didn't mean to imply it should be either ;)
13:22:11 <sssilver|> so how do Haskell functions log stuff?
13:22:19 <sssilver|> logging seems to fall out of the whole functional paradigm
13:22:30 <chrisdone> pure functions generally don't
13:22:41 <jmcarthur> sssilver|: they don't. they describe IO actions that can do it when executed.
13:22:54 <MP2E> sssilver|: Writer monad if you want to do it purely, but if you want a 'quick and dirty' trace for debug purposes, use trace
13:22:55 <sssilver|> so above any pure function that needs logging there's an impure one?
13:23:01 <MP2E> https://hackage.haskell.org/package/base-4.7.0.2/docs/Debug-Trace.html
13:23:03 <barrucadu> Often the only sort of place you'd want to log things is when doing IO  anyway
13:23:26 <bodie_> why is rust better than haskell?
13:23:27 <jmcarthur> sssilver|: what do you mean an impure one?
13:23:35 <stephen_> I'm having issues getting stylish-haskell to work with my emacs setup -- does anyone have it working? Here's my error http://lpaste.net/120477
13:23:57 <jmcarthur> bodie_: an interesting audience to ask that question... in any case, i'd say the big win rust has over haskell is tight, predictable control over resources
13:24:11 <sssilver|> jmcarthur: I mean one that's IO
13:24:29 <barrucadu> sssilver|: What sort of pure functions are you wanting to do logging in?
13:24:35 <jmcarthur> sssilver|: i wouldn't put IO *above* the pure function, but *below* it... in the sense that the pure function generates it
13:25:03 <bodie_> jmcarthur, I was gonna ask #rust-lang but I'm too lazy to dig up my connection info for Mozilla's IRC server.  plus I figured it would get a more interesting reaction here; many of you have spent enough time around Haskell to know your grips and wish-lists in detail.  :)
13:25:10 <sssilver|> see I'm confused. I'm writing a function that calculates a bunch of prices using some moderately complex logic. That function is run every day upon new batch of data. I want to log the results of my calculations so that I can verify their correctness independently.
13:25:18 <bodie_> s/grips/gripes/
13:25:40 <sssilver|> do I log it in the same place I send the results over the network?
13:25:49 <MP2E> bodie_: I still like Haskell more, I think I would use it anywhere I didn't need fine-grained control over memory :P
13:25:55 <MP2E> But there are some things where rust undeniably wins
13:26:00 <MP2E> I would rather write an emulator in rust, for instance
13:26:14 <init> sssilver|: do you want to log "internal data" of the function, or just the result of it?
13:27:08 <sssilver|> init: I want to log both, the final result, and the interim calculations
13:27:14 <sssilver|> that are discarded outside of the function
13:27:24 <jmcarthur> sssilver|: to log information, you either need to return the information to log from your function or return an IO action that performs the logging from your function (these are from some points of view equivalent anyway)
13:27:29 <bodie_> MP2E, yeah, I'm seeing Rust as a pretty nice C++ replacement (although obviously its downside is lacking 30 years of library work)
13:27:49 <MP2E> that's how I see it as well
13:27:51 <jmcarthur> sssilver|: and either way, the information needs to be converted into an IO action which is then executed, or the IO action you returned needs to just be executed
13:28:07 <bodie_> but seeing as Haskell is also competitive in the compiled arena I'm making sure I think carefully about the options before I consider committing to one
13:28:26 <jmcarthur> MP2E: i think i would much rather write an emulator in haskell :P
13:28:48 <MP2E> Really jmcarthur ? I definitely want to try to write one in Haskell, but previous attempts have looked painful
13:29:09 <MP2E> speed was also a huge concern :(
13:29:13 <jmcarthur> to be fair, i have only ever written pretty simple emulators
13:29:19 <MP2E> same here
13:29:40 <jmcarthur> if i need speed i'd probably write some JIT stuff
13:29:42 <bodie_> I mean, Haskell can be written with performance constraints in mind, it just doesn't come out very "haskelly" ... isn't that right?
13:29:48 <jmcarthur> which is way more fun in haskell
13:30:00 <MP2E> ooh
13:30:14 <MP2E> making a JIT in haskell would be really fun
13:30:26 <jmcarthur> bodie_: it's something i think is awesome in haskell, actually, or more specifically with ghc
13:30:44 <jmcarthur> bodie_: you basically get access to most layers of abstraction, when you want
13:30:59 <bodie_> interesting
13:31:11 <sssilver|> so then my function that does the calculations has to return both the actual final result of calculations, AND the interim results for logging
13:31:23 <sssilver|> and that seems kinda awkward
13:31:30 <bodie_> it seems clear to me that Haskell has a better functional abstraction layer... on the other hand, so does scheme :P
13:31:31 <MP2E> sssilver|: see the writer type for a useful pattern :)
13:31:43 <MP2E> abstracts away manually passing the log
13:31:58 <barrucadu> sssilver|: Can't you just verify that the interim calculations are correct ahead-of-time?
13:32:03 <jmcarthur> sssilver|: purely functional programming is undeniably awkward in some cases, but abstraction carries you a long way, and the benefits are generally worth it
13:32:16 <barrucadu> As in, rather than check the results every month or whatever, test it now to make sure it's right
13:33:03 <sssilver|> barrucadu: well the way my department works is, you do your stuff, and then just in case the management always verifies everything using Microsoft Excel :)) I know it's weird, but that's how it works for us
13:33:41 <jmcarthur> sssilver|: i think with problems it sounds like your is, i would return the results in some form that "shows its work", such that it would be trivial to get the final result or to log the intermediate steps or both
13:34:05 <MP2E> bodie_: Haskell's strength, for me, comes in a combination of functional purity with the strong static type system. The type system allows GHC to logically check your program to see if it 'makes sense' and I've found that when my Haskell programs compile they work as intended 99% of the time
13:34:10 <init> maybe you're doing too much work in a single function
13:34:13 <MP2E> bodie_: and the other 1% is easy enough to figure out just by elimination
13:34:54 <MP2E> This is especially evident in refactoring
13:35:06 <jmcarthur> sssilver|: for example, if the problem is expressible as a fold, it's also expressible as a scan
13:35:14 <barrucadu> Mmm, refactoring Haskell
13:37:42 <chrisdone> https://www.haskell.org/pipermail/haskell-cafe/2015-February/118163.html
13:37:42 <bodie_> MP2E, do you feel the need to write tests?
13:38:27 <jmcarthur> bodie_: some properties are more easily checked with unit tests, yes. however, it's very easy to write comprehensive tests using libraries like quickcheck, and again this is thanks to purity
13:38:31 <bodie_> and jmcarthur, where do I need to start studying to learn to unwrap the abstraction layers?
13:38:48 <jmcarthur> bodie_: real world haskell might have something
13:39:05 <MP2E> exactly what jmcarthur said. It does depend on the size of the project, but unit tests are very easy to do, and they provide even stronger guarantees
13:39:07 <jmcarthur> bodie_: learning how ghc works is a big deal too
13:39:28 <bitemyapp> bodie_: I use HSpec for writing tests, usually they look like unit/functional/integration tests or some-such.
13:39:32 <bitemyapp> I don't think about it that much.
13:39:57 <jmcarthur> i can't stress the awesomeness of {quick,small,lazysmall}check enough
13:40:59 <bodie_> okay, fun stuff.  I appreciate the input, folks.  I can't help but find Rust very attractive, but I haven't invested any time in it since the spec has been so unstable.  however, I noticed they finally nailed down a 1.0 release date, so I have to make some decisions.  :P
13:41:00 <tommd> smartcheck
13:41:26 <fread2282> imo, rust isn't ready for 1.0 yet
13:41:28 <bodie_> and I can't give it a serious consideration without giving Haskell its due as well.
13:41:39 <jmcarthur> tommd: i thought of including that, because it sounds great, but i have never used it, so didn't feel confident to put my "reputation" behind it
13:41:50 <cschneid> paf31: there's a web api thing that relies on types to auto-generate rest apis - what's that lib called - I think I remember you using that
13:41:56 <MP2E> bodie_: funnily enough 1 year ago I started learning Rust, but because it wasn't in 1.0 yet I checked out other functional languages and came to Haskell
13:41:58 <tommd> jmcarthur: Makes great sense.
13:42:00 <MP2E> I'm glad I found it :)
13:42:11 <bodie_> heh.  :)
13:42:26 <jmcarthur> bodie_: i think rust and haskell fill very separate niches
13:42:26 <tommd> jmcarthur: I have two advantages 1) I have no reputation 2) I have tremendous trust in the author.
13:42:27 <fread2282> rust's previous state was "break everything twice a week", which is horrible, but 1.0 is the exact oppositite of the spectrum, and they're rushing out things like syntax extensions
13:42:32 <sssilver|> it's crazy that the idiomatic way to make a string uppercase is to map toUpper to every one of its characters :)))
13:42:41 <chrisdone> jmcarthur: i'm itching to mess around with HERMIT and write a proof assistant D:
13:42:45 <MP2E> Yeah Haskell and Rust don't occupy the same space, exactly
13:42:57 <MP2E> I think it'd be fun to use Haskell and call into Rust via FFI :P
13:43:01 <MP2E> instead of the Haskell + C combo we usually see
13:43:02 <jmcarthur> tommd: my reputation is dubious enough as to be surrounded by double quotes
13:43:27 <oconnore> MP2E: yeah, C/C++ does that now, and Rust aims to replace those.
13:43:27 <jmcarthur> i was going to add exactly what MP2E just said
13:43:31 <tommd> jmcarthur: At least you don't write papers about "hair shirts".  That's a start.  /blah
13:43:38 <bodie_> machine language compiled, concurrency happy, performant, functional to one or another extent....  I think rust's philosophy is sloppier but that might not be such a bad thing
13:43:45 * chrisdone is waiting for suavecheck
13:43:53 <bodie_> MP2E, I like that idea :)
13:44:06 <fread2282> rust doesn't have non-* traits (typeclasses) though, whch sucks
13:44:21 <chrisdone> or compile haskell down to rust :3
13:44:25 <paf31> cschneid: servant?
13:44:42 <cschneid> that looks right.
13:44:43 <cschneid> sweet
13:44:48 <cschneid> paf31: thanks :)
13:45:06 <paf31> yeah, the servant libraries are really nice
13:46:19 <jmcarthur> though, the subset of programs i would write in haskell is significantly larger than the subset of programs i would in rust.
13:46:46 <jmcarthur> rust is quite fun, nonetheless
13:46:53 <bodie_> yeah, it looks fun
13:47:02 <bodie_> I might have to play with it for a while just to satisfy my curiosity
13:47:29 <chrisdone> the ownership model sounds reet cool
13:48:20 <chrisdone> mainstream use for linear types
13:48:36 <jmcarthur> more like affine types?
13:49:06 <fread2282> the other thing about rust is that they have a rfc process where they listen to community feedback, but then things for servo (struct inheritance) get rushed in with 0 community feedback and imo little design thought
13:49:50 <bodie_> heh
13:50:42 <bodie_> since you fellas have been so helpful, I'll have to give Haskell an equal chance :P
13:50:48 <bodie_> thanks again
13:51:02 <bjz> fread2282: struct inheritance hasn't been added
13:51:14 <fread2282> oh... sorry
13:52:31 <chrisdone> jmcarthur: is it? i don't know much about it, seemed lineary from the blog posts i saw on it, anyway
13:52:49 <bjz> fread2282: and syntax extensions are currently in a 'good enough' state. But there will be a better version later. So macro_rules! will become macro!
13:53:35 <sssilver|> the exclamation marks in Rust just look odd
13:53:46 <sssilver|> also .val0(), .val1() is odd
13:53:59 <sssilver|> on tuples...
13:54:07 <bjz> sssilver|: .val0() is now .0
13:54:22 <sssilver|> oh, a few months ago it was val0() lol
13:54:27 <sssilver|> does my code break now?
13:54:32 <init> it does
13:54:36 <sssilver|> haha
13:54:46 <bjz> those methods were unstable
13:54:48 <bodie_> "the exclamation marks in Rust just look odd", said the Haskeller, ironically
13:54:57 <sssilver|> I'm not a Haskeller yet, unfortunately
13:55:17 <sssilver|> more of a C++/Python person embarking on a journey with the belief that "there has to be a better way to do this"
13:55:24 <bjz> the important thing is that functionality that is marked as stable won't change
13:55:26 <sssilver|> and yes, I've been megapleased with Rust
13:55:28 <josephle> considering the exclamation marks are for macros, I sure hope they catch your attention
13:55:32 <barrucadu> And what a magical journey it will be
13:55:43 <josephle> although Rust macros are "sanitary"
13:55:58 <sssilver|> barrucadu: absolutely!
13:56:17 <init> I'd say ((<*>) .) . fmap) looks odder than ! after than macros
13:56:45 <init> @type ((<*>) .) . fmap) -- did I get liftA2 right?
13:56:46 <lambdabot> parse error on input ‘)’
13:56:57 <init> @type ((<*>) .) . fmap -- did I get liftA2 right?
13:56:58 <lambdabot> Applicative f => (a1 -> a -> b) -> f a1 -> f a -> f b
13:57:15 <init> \o/
13:57:20 <MP2E> jmcarthur: curious, how would you implement a JIT using Haskell? I don't think it supports inline ASM does it?
13:57:29 <MP2E> (i'd be surprised at least :P)
13:57:40 <MP2E> emulator JIT I mean
13:57:51 <MP2E> obviously don't have to get into crazy specifics :P
13:58:14 <bodie_> sssilver|, I'm pretty sure there's a better way.  or rather.. there are many ways.  different ways have different advantages and disadvantages.  :/
13:58:46 <bodie_> sssilver|, I feel many of the benefits of some of the newer languages are negated by other more abstract drawbacks, e.g. community, or language instability
13:58:59 <bodie_> ... job availability...
13:59:51 <MP2E> Haskell is pretty old, but I get what you mean. In terms of popularity, it has only boomed recently
13:59:55 <MP2E> jobs are popping up more and more for it though
14:00:14 <MP2E> we're still no where near the jobs that C# and Java could get you though :P
14:00:17 <MP2E> in terms of numbers
14:00:27 <bodie_> I feel like Go stole a lot of the thunder that perhaps belongs to other languages.  but if you actually analyze why that is, maybe it's for good reasons
14:00:54 <bodie_> or maybe I'm just saying things calibrated to irritate people in #haskell...  such mysterious
14:00:55 <Welkin> bodie_: it's unfortunate, but the google marketing machine is strong
14:01:07 <MP2E> haha
14:01:23 <barrucadu> Not strong enough for them to actually succeed in calling it "go" rather than "golang", though :p
14:01:29 <bodie_> lol
14:01:34 <MP2E> go is missing unicode and generics, need i say more? :D
14:01:42 <init> Go doesn't have first-class tuples, nor proper parametric polymorphism
14:01:57 <init> which is a shame, because, man, we're not in 1960
14:02:03 <bodie_> and away we go!
14:02:38 <csd_> Hi I'm looking for an library that will help with interacting with a RESTful API that returns a JSON object. Does anyone know of something like this?
14:05:06 <Welkin> csd_: Aeson
14:05:14 <Welkin> you can convert to and from JSON
14:05:49 <csd_> Welkin: thanks. what about for making the web requests?
14:06:13 <Welkin> it works the same way
14:06:20 <csd_> Aeson does that?
14:06:26 <Welkin> if you are sending JSON, just serialize your Haskell data as JSON
14:06:32 <Welkin> using toJSON
14:06:45 <csd_> no sorry if i'm not being clear. i dont know how to do anything network related in Haskell
14:06:45 <Welkin> fromJSON convert it into a native HAskell data structure
14:06:52 <Welkin> oh
14:06:54 <csd_> So i'm looking for a lib that can also handle the HTTP stuff
14:07:01 <Riccardo> I need to downgrade cabal from 1.22 because of some breakage with ghc-mod and ghc 7.8.4. is it as simple as "cabal install cabal-install==1.20.x" and then rebuilding all my projects or will i run into other issues?
14:07:11 <Clint> csd_: http-conduit works
14:07:31 <Riccardo> i will do that in a sandbox probably if it makes any difference and then put the executable in my path
14:07:53 <csd_> Clint: thanks
14:08:41 <csd_> looks like http-conduit is now known at wreq
14:09:28 <Clint> csd_: what
14:09:48 <csd_> https://github.com/exbb2/http-conduit-browser
14:10:00 <csd_> I guess that's just part of the package
14:11:07 <sssilver|> Is "action" the same as "monad"? *cowers in fear*
14:11:28 <barrucadu> It's common to refer to a value of type Monad m => m a as an "action"
14:11:37 <Welkin> the only time I have heard "action" used is to refer to an IO value
14:12:47 <EvanR_> is there a way to show the source code for something in haddock without copying it into a @ @ block
14:13:35 <tiger717> If a profiling report reports that a program spends (quite some) time "calculating" (?) a constant variable, what does that mean?
14:17:05 <tommd> tiger717: Do you mean a literal?  What type of profiling?  What exactly is being reported?
14:17:50 <fread2282> is there an explanation of typechecking with metavariables somewhere (not the paper)?
14:21:25 * hackagebot derive 2.5.20 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.5.20 (NeilMitchell)
14:26:16 <Xenasis> Which is easier for a newbie, Happy or Alex?
14:26:36 <Clint> Xenasis: they don't do the same thing
14:26:50 <Xenasis> oh
14:26:58 <fread2282> Xenasis: parsec probably, but happy/alex are usually used togeather
14:27:37 <Xenasis> Ah, Parsec's description made it sound very complicated
14:27:42 <Xenasis> I'll have a look though
14:28:27 <chirpsalot> Xenasis: parsec stuff is actually really easy :). It's super cool too.
14:28:47 <Xenasis> I'll give it a try
14:28:57 <Xenasis> "It is defined as a monad transformer that can be stacked on arbitrary monads, and it is also parametric in the input stream type." turned me off a bit though <.<
14:29:04 <Xenasis> I'll have a look of some example code
14:29:05 <chirpsalot> Some of the types look a bit scary because of the monad transformer hoo-haa, but you don't have to worry about that.
14:29:07 <fread2282> if you have already used things like flex/yacc then alex/happy is the haskell equivalent
14:29:11 <Clint> attoparsec's a smidge easier
14:29:44 <Xenasis> I've never used flex or yacc before
14:29:45 <chirpsalot> Xenasis: yeah, Clint's suggestion is worth looking into. Attoparsec lacks the monad transformer stuff so it's a bit easier to follow.
14:29:45 <fread2282> (and will likely be easier (if you know flex/yacc))
14:30:02 <Xenasis> ah, I'll give that a search
14:31:14 <tiger717> tommd: Yes, a literal (in a where clause, but that shouldn't matter). Profiling using -fprof-auto. It reports ~4% time spent on the literal.
14:32:11 <chirpsalot> Xenasis: you basically just write grammars (like with Alex / Yacc), but in pure Haskell instead. It's nice and clean and simple :).
14:32:21 <tommd> tiger717: Seems odd, I'll agree.  Keep in mind literals do imply some processing (fromIntegral for Num, fromString iff OverloadedStrings, fromList iff OverloadedLists).
14:32:38 <Xenasis> I've never used Alex or Yacc before
14:32:44 <chirpsalot> Sorry, Happy, not Alex.
14:33:19 <Xenasis> Is there any generater that takes in plain old BNF?
14:33:22 <tiger717> tommd: It's just a floating point number, no conversions or any other functions involved at all.
14:33:24 <tommd> tiger717: So if you put the where clause as a top-level value then it shouldn't be recomputed and this observation should go away.  All that said, this could be -prof fooling you seeing as the actual costs change when you enable profiling.
14:34:02 <EvanR_> Xenasis: thing is, to parse stuff in haskell you often dont need a parser generator. it can be done directly with parsing combinators (attoparsec)
14:34:32 <EvanR_> the grammar is almost directly readable from the parser program itself
14:34:33 <tommd> tiger717: Are you saying float literals aren't polymorphic in the same way Integrals are?  Because that isn't true.
14:34:58 <akurilin3> I'm trying to use classy-prelude to get a NonEmpty (or something else representing the same concept) from a list with fromList. It looks like the package might be expecting me to use some other abstraction besides NonEmpty, such as maybe NonNull or MinLen. I'm a bit confused as far as what the recommended path is
14:35:06 <fread2282> tiger717: what type is it?
14:36:02 <EvanR_> Xenasis: a good way to understand parser combinators is to try to invent them. starting from this http://www.willamette.edu/~fruehr/haskell/seuss.html
14:36:14 <tiger717> tommd: I just converted it to a top-level literal (type Floating a => a) and now we're at 8% :D
14:36:15 <sssilver|> Hey guys, I'm reading this https://github.com/snkkid/LazyFooHaskell/blob/master/lesson01/lesson01.hs and I don't understand line 29's [SWSurface] -- does it pass a list made of a single SWSurface to setVideoMode? If so, what's SWSurface? Where does it come from?
14:36:46 <fread2282> tiger717: give it a concrete type
14:36:47 <tommd> tiger717: LOL, sorry I'm at a loss without a better understanding of the code.  I really do dislike the profiling though because it can give you red herrings.
14:37:03 <barrucadu> sssilver|: SWSurface is a value
14:37:12 <sssilver|> barrucadu: but where did it come from?
14:37:22 <tiger717> fread2282: I will try, give me a second
14:37:25 <Xenasis> EvanR_: that's fine and good, but I'm not experienced enough with haskell to know what a combinator is, never mind invent a parser with them
14:37:36 <tiger717> tommd: I guess it must be the polymorphism
14:37:50 <tommd> Yes, if you didn't give it a type signature that would make sense.
14:37:51 <barrucadu> Graphics.UI.SDL: https://hackage.haskell.org/package/SDL-0.6.5/docs/Graphics-UI-SDL-Types.html it's a constructor of SurfaceFlag
14:38:21 <Welkin> why would you use SDL1?
14:38:26 <EvanR_> Xenasis: its slang for a function you use in composition with other functions
14:38:29 <Welkin> SDL2 has been out for a long time now
14:38:56 <EvanR_> SDL1.2 has been out for a long time too ;)
14:39:08 <sssilver|> barrucadu: hmm, is there a way to more explicitly point it out? like write [Graphics.UI.SDL.SWSurface], coz then you can glance at the imports and figure it out
14:39:41 <tommd> tiger717: Notice that without profiling you would get inlining and a specialized type which would eliminate this problem in the vast majority of cases.  Such inlining is prevented by profiling, which is why I made the prior statements wrt -prof.
14:39:58 <barrucadu> "import Graphics.UI.SDL as SDL", that means it could be written as SDL.SWSurface
14:40:41 <barrucadu> A style that is also used a lot is only importing the things you use, so eg "import Graphics.UI.SDL (SurfaceFlag(SWSurface), ... other things)"
14:41:00 <barrucadu> But that's a bit unwieldy if you import a lot from one module
14:41:47 <fread2282> tiger717: how long is your program run time? it could be that this 4% is just evaluating fromRational once, which is what literals are compiled to
14:42:56 <sssilver|> barrucadu: sounds like the reasonable thing to do is to avoid using `as`, and then use the full explicit qualifier name in the program
14:43:01 <sssilver|> it's a bit verbose but very clear
14:43:04 <fread2282> tiger717: you can -ddump-core to see if ghc is doing that (compiling it to s top-level fromRational thunk)
14:44:27 <barrucadu> sssilver|: Another option is qualified imports: "import Foo as F", and then you have to refer to everything as F.whatever
14:44:36 <barrucadu> I mean, "import qualified Foo as F"
14:44:45 <EvanR_> or with the fully qualified name
14:45:15 <sssilver|> `import Graphics.UI.SDL`, and then use stuff like `doStuff Graphics.UI.SDL.SWSurface`
14:45:35 <sssilver|> ^ clear and explicit
14:45:47 <sssilver|> (albeit a bit verbose)
14:46:14 * sssilver| expects credit for fitting use of the word 'albeit'
14:46:26 <fread2282> tiger717: if your funcion is generic, you should use SPECIALIZE or INLINE to get that
14:47:20 <EvanR_> sssilver|: youll get nothing
14:47:38 <sssilver|> EvanR_: why?
14:48:02 <EvanR_> stone cold said so
14:48:14 <sssilver|> stone cold crazy yo
14:48:52 <sssilver|> English is my third language! ^.^
14:49:22 <sssilver|> most native speakers don't properly use the word 'albeit' in daily speech
14:49:34 <EvanR_> or at all
14:49:44 <sssilver|> exactly
14:49:52 * sssilver| totally deserves a cookie
14:50:19 <EvanR_> instance Default Cookie
14:50:25 <EvanR_> putMVar sssilver| def
14:50:46 <barrucadu> Good thinking, sssilver| can't have another cookie if he's still full
14:52:17 <sssilver|> >.<
14:52:50 * sssilver| is off googling putMVar
14:53:27 <EvanR_> i cant wait for christmas. which is probably when gl-0.7.2.3 will finish compiling
14:53:32 <tiger717> fread2282, tommd: Thanks for your help!
14:58:20 <lightstep> sssilver|: try http://hoogle.haskell.org
14:58:32 <sssilver|> lightstep: yup, already figured it out :)
14:58:54 <sssilver|> thanks!
15:02:17 <codygman> What does left and right biased mean in the context of Either?
15:03:32 <chrisdone> depends on the operation
15:03:37 <shapr> If it weren't for the obscenities, I'd write a @haskellceo plugin for lambdabot
15:09:24 <MP2E> *sigh* sometimes I hate discussing haskell with friends who program and don't knwo about it
15:09:28 <MP2E> i get the most frustrating responses
15:09:57 <codygman> chrisdone: hm, okay. Within the EitherT monad transformer the computation short circuits on the first Left value, does that make it left biased?
15:12:30 <yac> I just found https://www.haskell.org/pipermail/libraries/2013-May/019903.html I think I can safely assume someone already pointed out that the migration to python 3 is hardly to be called a success
15:12:39 <yac> right? right?!
15:13:06 <Welkin> that is not relevant to haskell though
15:13:15 <acetoline> I got disconnected
15:13:23 <acetoline> did anyone answer my question?
15:13:24 <Welkin> the situation is clearly not the same
15:14:04 <MP2E> 2 GHC HQs? haha as if
15:14:24 <chrisdone> codygman: bias usually refers to a choice between two equally legitimate choices, e.g. Right 0 <|> Right 1 — which does it choose?
15:14:28 <yac> Welkin: really? Why?
15:14:28 <acetoline> I have a list of functions (with associated types) and want to find all functions in the list matching some type
15:15:09 <MP2E> Python 3 was a dramatic change, i've recompiled over 100 hackage packages and with GHC 7.10.1-RC2 and it has needed 3 patches so far, only one of them even being related to the BBP
15:15:23 <Stratege> MP2E the obvious solution to that frustration is to get them interested in haskell and then teach them haskell / point them at things where they can learn it @frustrating responses
15:16:00 <chrisdone> codygman: Just x <|> Just y = Just x, but you could do an unbiased instance where Just x <|> Just y = Nothing
15:16:01 <MP2E> Stratege : well, the friend I'm talking about took a Functional Programming class at his university but he didn't learn how to make any real programs, so as a result he's no longer interested and sees it all as a waste of time
15:16:15 <MP2E> so i keep trying to tell him all these great things you can do with IO and real programs
15:16:18 <MP2E> and he just doesn't believe it
15:16:22 <yac> MP2E: interesting. Was that with or without the migration tool?
15:16:22 <MP2E> comes up with some silly reason
15:16:27 <MP2E> yac: without
15:16:28 * hackagebot repl-toolkit 0.3.1.0 - Toolkit for quickly whipping up config files and command-line interfaces.  http://hackage.haskell.org/package/repl-toolkit-0.3.1.0 (jtapolczai)
15:16:35 <MP2E> i actually did not know there was a migration tool
15:16:49 <barrucadu> Mmm, I have a similar friend. He likes Haskell, but doesn't see it as useful for writing actual programs in
15:16:54 <Stratege> well... the friend of mine who got me interested in Haskell first pointed me to the very simple case of passing functions as arguments and it went from there.
15:16:57 <yac> MP2E: well I don't know either. I just saw it proposed in that email
15:17:25 <codygman> chrisdone: I don't really understand where Just x <|> Just y = Nothing would be useful, do you have any examples?
15:17:54 <MP2E> Hopefully a little convincing over time will go a long way :P
15:17:56 <chrisdone> codygman: like XOR 1 1
15:17:59 <Stratege> codygman XOR? ^^
15:18:28 <MP2E> But for instance, friend said 'I just don't see the universe as functionally pure, how do you model anything useful? I don't disappear and reappear every time I move, my position is mutated'
15:18:29 <lightstep> wasn't the motto of haskell at one time "avoid success at all costs"?
15:18:41 <MP2E> I of course replied with 'mutation is perfectly possible, just encode it in the types'
15:18:44 <codygman> chrisdone: Ah, there we go :)
15:18:46 <MP2E> but that did not seem to click.
15:18:49 <Stratege> MP2E just show them functional programming in their language of choice instead of trying to beat them over the head with haskell ^^
15:18:51 <barrucadu> It's a good motto, I think
15:18:56 <MP2E> Fair enough Stratege :P
15:19:13 <chrisdone> codygman: but i don't know where you read 'bias', maybe it's just referring to Left being the zero. shrug
15:19:22 <acetoline> I guess I'm asking about how to use libghc to match function types
15:19:28 <yac> MP2E: the type safety and explicitness about performing things sold haskell to me ... once I grokked it
15:19:37 <yac> MP2E: now I find haskell to be not strict enough
15:19:49 <acowley> chrisdone: Thanks so much for sending that email to the list earlier. I have so often bemoaned that missing part of TH and never thought to ask SPJ why it was.
15:19:49 <MP2E> same!
15:20:13 <chrisdone> acowley: :D i'd also thought it was due to some subtle stage restriction i hadn't considered
15:20:21 <yac> I need haskell because I'm a shitty programmer ...
15:20:28 <chrisdone> acowley: currently looking at the TH implementation to see what he's talking about
15:20:32 <Welkin> list comprehensions in python were my gateway to haskell
15:20:36 <Welkin> and I never looked back
15:20:41 <MP2E> I feel that way too, but be careful stating that to non-haskellers yac :P they usually get the wrong idea
15:20:42 <acowley> chrisdone: Me, too! Everytime I write a QQ it's always some horribly limited thing because writing my own Haskell parser seems absurd.
15:20:48 <MP2E> don't know why exactly
15:20:50 <Welkin> python is absolutely horrible now when I go back to it
15:21:17 <acowley> chrisdone: It sounded like it was a different data structure emitted by the Parser than that used by TH, which is unfortunate.
15:21:27 <yac> Welkin: generally, unityped languages
15:21:36 <Stratege> MP2E because people generally consider themselves to be atleast decent, or more likely good at programming... for some reason. Now I wonder if learning Haskell really does make one misserable.
15:21:51 <MP2E> It had the opposite effect on me
15:22:00 <Welkin> yac: the design of the language matters a lot though, which is why ruby is so much nicer to use than python
15:22:05 <MP2E> I tried learning C/C++ for about 7-8 years, I say tried because I read countless books and felt like I grokked them
15:22:08 <MP2E> writing is my issue
15:22:10 <MP2E> but writing?
15:22:14 <MP2E> i've written more in Haskell than I ever have
15:22:17 <MP2E> and that's 1 year vs 9
15:22:22 <MP2E> at this point
15:22:37 <MP2E> when i write stuff i don't feel like i'ts going to spontaneously combust
15:22:38 <Welkin> C was never meant as a general purpose language though
15:22:44 <Welkin> it has always been a systems language
15:22:58 <Welkin> C++ is a frankenstein language
15:24:13 <chrisdone> that implies a mad genius invented it
15:24:21 <chrisdone> C++ is more like Igor tried his best
15:24:27 <yac> Welkin: python is superior to ruby because syntax and not open classes. Not that it matters...
15:24:52 <MP2E> haha
15:25:09 <Stratege> I really like Haskell, and it is my language of choice these days, but it feels a LOT more difficult to write programs in than say C# with LINQ
15:25:20 <Stratege> (atleast, more complex programs)
15:25:29 <chrisdone> what's LINQ used for in C#?
15:25:46 <simon_> chrisdone, querying containers, I think.
15:25:50 <chrisdone> last time i used C# LINQ wasn't a thing
15:26:10 <Welkin> Stratege: I feel the opposite way
15:26:21 <Welkin> it is easier for me to think and write in haskell than any other language
15:26:21 <agocorona> LINQ is something inspired in  haskell isn't?
15:26:34 <simon_> the last time I looked at F#, the "docs" for it were a list of less than a dozen ways it deviated from O'Caml.
15:26:39 <Welkin> agocorona: mostly likely from Erik Meyer
15:27:14 <chrisdone> tried to compile ghc
15:27:15 <chrisdone> ghc-pkg: Prelude.chr: bad argument: 3956864
15:27:15 <Welkin> Meijer*
15:27:17 <Welkin> oops
15:27:20 <simon_> agocorona, sort of.
15:27:26 <chrisdone> why does this always have to be hard =p
15:27:26 <Stratege> LINQ allows you to apply functions to collections, it implements map, filter and fold and possibly other things
15:27:40 <enthropy> chrisdone: what do you mean haskell-src-meta doesn't handle infix?
15:28:10 <enthropy> the TH AST has an UInfixE which lets stuff get re-associated according to ghc's fixities
15:28:11 <Stratege> also with it comes a convenient to build AST in C#, including having Lambdas be compiled to ASTs that you can fully compile at runtime (and muck about with as well if you want)
15:28:23 <enthropy> I'm pretty sure haskell-src-meta uses it
15:29:07 <csd_> I'm working with lenses for the first time. I'm getting from the lens the value [Number 2.7], which is an Aeson value. I thought _Float was supposed to extract the value but it's not working for some reason
15:29:09 <enthropy> though I think the default parseExp might still use a hardcoded list of fixities
15:29:16 <MP2E> Stratege: that sounds awfully like Haskell, actually. mapping over is Functor, fold is Foldable, I don't think there's a generic filter though
15:29:37 <MP2E> Stratege: the AST thing might be different, I'd have to play with it more to know
15:29:54 <chrisdone> enthropy: ah, i wasn't aware it fixed that. seems it got that in 7.4
15:30:05 <Stratege> the AST thing is just borderline related to the main LINQ part, really, but yeah
15:30:06 <edwardk> csd_: _Double ?
15:30:25 <csd_> edwardk: nope
15:30:48 <csd_> oh wait that just worked for some reason.. i had tried it earlier, go figure
15:30:59 <csd_> thought i had, anyway
15:32:24 <agocorona> really after get used to haskell, other languages look like being made by frankenstein. And they are: they have much ad-hoc pieces
15:32:30 <Stratege> MP2E and jup, it sounds an awful lot like Haskell and that's why I really like LINQ ^^ although it's probably a lot harder to extend and less 'modular', since your type needs to implement both Functor and Foldable and some other things, it's more used as a generalization over Collections (including SQL and such) with a completly functional API :D
15:33:00 <codygman> Does Aeson always short circuit when any error is encountered? It seems that "try parsing the whole thing logging a list of failures" would be a popular use case.
15:33:47 <hpc> codygman: it's pretty futile to continue after a syntax error
15:33:48 <agocorona> didn't ghc have a SQL like sublanguage as an extension of list comprehension?
15:34:01 <yac> agocorona: disagree. Python is a beautifull language. But the "compiler" guarantees to you just syntactic correctness. Nothing else.
15:34:04 <hpc> agocorona: yes
15:34:38 <agocorona> that extension is still available?
15:34:40 <hpc> uh
15:35:09 <hpc> maybe TransformListComp?
15:35:17 <hpc> yes
15:37:20 <agocorona> I think that this is something related to LINQ,  the TransformListComp
15:38:21 <hpc> yes
15:38:42 <codygman> hpc: What about for [{"withdraw": 15.00},{"deposit": "you've been hacked"}, {"deposit": 200}, {"deposit": 15}, {"deposit": "lololol"}] where you are parsing for a String and (for simplicity) a Float. Since my example is crappy, you are validating transactions.
15:38:53 <Stratege> possibly. also about linq - you luckily don't have to write it as an SQL query, you can do normal function calling on your collections and it will only execute the call once the data is needed (yay for lazy evaluation ^^)
15:40:15 <hpc> codygman: that makes more sense
15:40:29 <hpc> codygman: you need some way to know how to recover from a syntax error
15:40:48 <hpc> when you see that first '"' and the parser doesn't know wtf to do with it
15:40:54 <chrisdone> list comprehensions are kind of pointless to me
15:41:04 <chrisdone> including the transform stuff and monad comps
15:41:05 <hpc> it has to know it's the start of a string, how to end the string, and where in the language it is when the string terminates
15:41:22 <hpc> so you'd probably expand the parser in that case, and have a step after to verify types
15:41:22 <codygman> hpc: Ah, I thought that each object would be validated and on error it would log the error and try to parse the next object.
15:41:40 <fread2282> is there an explanation of typechecking with metavariables somewhere (not the paper)?
15:41:49 <chrisdone> if ever wrote a book on haskell i wouldn't even include list comps
15:42:00 <enthropy> acowley / chrisdone I dunno about your uses, but I think we're missing a parser that lets you easily override / extend parts. Here's a start that doesn't have such limitations https://gist.github.com/aavogt/906cfc6468b258e966aa
15:42:47 <chrisdone> enthropy: indeed, an extensible parser is needed
15:42:49 <codygman> chrisdone: Funny you say that, I think the only time I've used list comprehensions in Haskell (Besides trivial ones like [1..5]) is when I was reading Learn You A Haskell
15:42:59 <enthropy> mostly I'm stuck on parsing layout at this point
15:43:09 <hpc> codygman: that's a range, not a comprehension
15:43:20 <codygman> hpc: Thanks for the correction.
15:44:10 <hpc> but yeah, usually when you get to the point of complexity where comprehensions are nice, you've outgrown [] anyway
15:44:38 <hpc> and monad comprehensions aren't as nice a syntax as do-notation
15:44:59 * enthropy likes them
15:45:40 <chrisdone> enthropy: hindent is the same as your approach, but a printer instead of a parser :3
15:47:06 <chrisdone> although rather than a large record that you override i opted for a typeable-based dispatcher
15:48:09 <chrisdone> enthropy: so i think your idea will be very useful in practice
15:48:29 <chrisdone> i guess the 'record' package is the obvious use-case
15:48:31 <enthropy> the parser is really slow
15:50:06 <enthropy> the "testsuite" takes 3s to run here
15:51:20 <chrisdone> lol
15:51:24 <chrisdone> why?
15:51:39 <acowley> enthropy: Wow, that's great!
15:51:42 <enthropy> no clue
15:51:56 <enthropy> https://www.haskell.org/pipermail/haskell-cafe/2014-April/113470.html is also on-topic
15:52:06 <acowley> I still feel like when using TH, GHC should contribute to the parsing, though
15:52:16 <acowley> I mean, it's sitting right there
15:52:42 <enthropy> chrisdone: I think it's because nothing gets inlined?
15:52:43 <chrisdone> indeed
15:52:50 <chrisdone> hmm
15:53:06 <chrisdone> it should
15:54:15 <acowley> I also wonder if this missing piece of GHC as a library has been a major contributor to why TH rubs so many people the wrong way.
15:54:48 <acowley> Easy quasi-quotation is a great asset
15:55:56 <chrisdone> yeah, we lack the basic lisp macro
15:56:52 <chrisdone> we have quotation [| … |] and splicing $(foo …), and reader-macros [foo|…|] but no regular old syntax macros
15:57:10 <enthropy> @hackage frquotes
15:57:10 <lambdabot> http://hackage.haskell.org/package/frquotes
15:57:51 <Stratege> does GHC have some way to tell it that it should fully evaluate (or perhaps even partially evaluate, if it can do that?) things at compile time?
15:57:54 <geekosaur> @google liquid haskell
15:57:55 <lambdabot> http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/about
15:57:56 <lambdabot> Title: About - LiquidHaskell
15:58:15 <acowley> Stratege: Template Haskell :(
15:58:30 <agocorona> Just a question: can I insert haskell code in a quasiquotation ?
15:58:34 <chrisdone> acowley: we lack something like {foo|…} = $(foo [|…|])
15:58:48 <fread2282> Stratege: putting INLINE everywhere sometimes works
15:58:57 <Stratege> acowley hm ... okay, I guess I'll have to look into that then, hoped for something simpler
15:59:01 <fread2282> depends on what though
15:59:04 <chrisdone> then i could implement {i|…|} for idiom brackets
15:59:24 <acowley> chrisdone: It's striking because it's the second thing you try to do when writing a macro.
15:59:27 <Stratege> fread2282 "sometimes works" is sorta exactly the thing I'd like to avoid via using Haskell
15:59:29 <agocorona> there is an scape sequence for haskell code inside the scape  of a quasiquote?
15:59:34 <acowley> Stratege: Hence my frowny face
15:59:44 <fread2282> Stratege: yep :(
15:59:47 <geekosaur> agocorona, no, that's what chrisdone is complaining about :)
15:59:57 <coltfred> it sure does seem like I should be able to do better than this, but being fairly new to haskell. I basically want something of the shape (Monad m, Monad n) => m (n a) -> (a -> n b)  -> m( n b) which I accomplished via (fmap (stringToColor =<<) (v .:?  "colors")). Can I do better? Hoogle recommended forM, but the aeson parser doesn't seem to be traversable...
16:00:10 <acowley> Stratege: There is some agitation for this, but I don't think it's anywhere near implementation
16:00:14 <enthropy> agocorona: it's up to the quasiquote to implement
16:00:19 <enthropy> @hackage Rlang-QQ does it
16:00:20 <lambdabot> http://hackage.haskell.org/package/Rlang-QQ does it
16:00:29 <acowley> Stratege: Particularly, I know cartazio was after it
16:00:45 <Cale> coltfred: That basically looks right
16:00:55 <geekosaur> those use haskell-src-exts though, not ghc's own parser, right?
16:00:56 <Cale> (though I don't know what .:? is)
16:01:03 <Cale> Oh, aeson
16:01:06 <coltfred> Cale: Bummer. Was hoping there was something cleaner.
16:01:07 <coltfred> Ya.
16:01:25 <shachaf> coltfred: It looks pretty clean to me.
16:01:30 <coltfred> Basically parse an optional field and apply a function to it.
16:01:43 <shachaf> coltfred: You want to do "n a -> (a -> n b) -> n b", which is just (>>=).
16:01:45 <Cale> coltfred: Of course, if you have to do that a lot, make a name for it
16:01:55 <fread2282> since INLINABLE isn't default, you often have to copy external definitions to get ghc to inline them away :(, for one
16:02:14 <shachaf> coltfred: But you  want to lift it to m (n a) -> (a -> n b) -> m (n b), so you use fmap (>>= f) instead of just (>>= f)
16:02:43 <coltfred> shachaf: Ya, I guess.
16:02:46 <agocorona> I miss a quasiquoter for HList expressions
16:02:49 <enthropy> geekosaur: I don't think you want to write something big enough in an antiquote for the differences between those parsers to matter
16:03:03 <Stratege> acowley ah, thanks. Shame it's not further in yet
16:03:08 <coltfred> I should be happy I didn't f it up completely :)
16:03:11 <enthropy> agocorona: such as?
16:03:43 <agocorona> enthropy: there is none. that is why miss it
16:03:43 <acowley> Stratege: I think it overlaps with a number of features, but frankly TH wouldn't be the worst thing in the world if it were easier to use.
16:03:46 <enthropy> I mean what would such a thing look like (there's already a QQ for record puns in HList)
16:04:15 <Stratege> acowley I haven't touched it so far, given its name should I expect something as terrible as C++ templates or rather something like LISP?
16:04:29 <chrisdone> more like lisp
16:04:34 <chrisdone> but without macros
16:04:42 <chrisdone> just quotation and reader macros
16:05:06 <chrisdone> and splices
16:05:17 <geekosaur> enthropy, the worry is not size, it's that h-s-e can be out of step with ghc
16:05:26 <Stratege> aren't macros just something that naturally arises from having lisp? ^^
16:05:29 <chrisdone> enabling template-haskell in a module is like wrapping the whole thing in `( …) in lisp
16:05:49 <chrisdone> and then when you write $(foo …) that's like doing ,(foo …) in the quasi-quoted module in lisp
16:06:05 <acowley> Yeah, it's like lisp, but you can imagine doing what you wanted with [eval|foo 42]
16:06:16 <chrisdone> [foo|…] is like #foo"…"
16:06:31 * hiptobecubic should learn some more lisp
16:06:37 <cmccann> people complaining about the haskell community being a bit rude sometimes makes me want to go dig up that photo of DHH and his presentation slide refuting people who don't like Ruby on Rails
16:06:40 * Stratege should learn some more lisp as well ^^
16:06:43 <chrisdone> there's nothing correspinding to simply (my-macro foo bar)
16:06:52 <acowley> Having to import things makes it a little awkward, and it's kind of understandable from an implementation point of view
16:06:59 <hiptobecubic> cmccann, rude? really? I always hear the opposite
16:07:26 <hiptobecubic> cmccann, and people love to post that example of the guy trying to troll in here and being earnestly convinced to try haskell out :)
16:07:28 <acowley> Learning lisp or scheme is pretty great
16:07:46 <enthropy> geekosaur: right but if you just write small expressions, it seems less likely you'll use an unimplemented feature (say DataKinds)
16:07:46 <hiptobecubic> I "know" scheme. But I don't know scheme.
16:07:50 <chrisdone> haskell's community is 99% friendly and 1% loud nutters
16:07:53 <cmccann> hiptobecubic: there are a few chronically abrasive people and in general people aren't perfect
16:08:00 * Stratege actually intends to learn McCarthy's LISP ^^ it looks so interesting
16:08:20 <chrisdone> Stratege: i suggest you *implement* mccarthy's lisp ;)
16:08:29 <hiptobecubic> I tried to get someone at work to use 'hy' for something with me. I was shot down pretty quickly :D
16:08:35 <chrisdone> http://ep.yimg.com/ty/cdn/paulgraham/jmc.lisp
16:08:39 <Stratege> chrisdone I actually do intend to do that, but I read the paper a couple of times by now and I still don't know how to start implementing it.
16:09:00 <acowley> Stratege: Implement it in Haskell!
16:09:03 <MP2E> cmccann : I agree. I find the backlash of Mono Haskell to be much more frightening than the actual joke :/
16:09:05 <agocorona> there are many implementations of lisp: javascript, ruby, python....
16:09:13 <MP2E> the joke wasn't in the best taste but still
16:09:22 <EvanR_> agocorona: ruby ? python ? no
16:09:36 <cmccann> MP2E: tbh at this point I think a lot of people on both sides are getting worked up because everyone else is worked up :T
16:09:37 <EvanR_> all no
16:09:43 <MP2E> Sounds about right :)
16:09:51 <chrisdone> stratege: implementing lambda-calculus in haskell is rather fun. it ranges from the trivial to the sophisticated
16:10:08 <EvanR_> whats the talk about Mono Haskell i cant see to find a reference to it
16:10:33 <acowley> EvanR_: It's just a badly timed bad joke that became a symbol
16:10:35 <lightstep> the tale about the first implementation of lisp says that jmc and his students wrote the first compiler in lisp, and then hand-executed it on its own code and wrote down the output in machine language
16:10:38 <hiptobecubic> python does at least give you direct access to the ast, you *could* lisp in it. That's what hy is trying to do
16:10:48 <acowley> EvanR_: Someone linked to an archive of it on reddit, so you can find it
16:10:54 <Stratege> chrisdone ... yeah that's some more papers I have to read, somewhen. Planning to implement that as well at -some- point
16:10:59 <hiptobecubic> lightstep, that is pretty amazing.
16:11:18 <Stratege> lightstep so the first ever lisp compiler were actually jmc and his students? ... that's really cool and makes sense.
16:11:19 <chrisdone> Stratege: you need a paper to understand this one? =p https://gist.githubusercontent.com/chrisdone/24e47c2952e4ad78c246/raw/313b4710ee0bf7c1c70f172899d37ae9c9b7d125/000HOAS.hs
16:11:30 <lightstep> yeah :)
16:12:03 <acowley> I oscillate between finding the idea of a circular interpreter mind blowing and obvious. Which is, I think, exactly the right strange loop to exist in.
16:12:35 <chrisdone> acowley: more recently i'm interested in well-typed metacircular interpreters =p
16:12:59 <chrisdone> e.g. https://gist.github.com/chrisdone/516489f4f27846712225
16:13:00 <acowley> chrisdone: Yes, my DSL work is all PHOASy
16:13:16 <agocorona> EvanR_:  http://www.randomhacks.net/2005/12/03/why-ruby-is-an-acceptable-lisp/
16:13:28 <chrisdone> although i didn't get to the point of deconstructing the AST, which is the hard part
16:13:30 <EvanR_> ah i saw that
16:13:33 <EvanR_> a while back
16:14:15 <acowley> chrisdone: Yes, I've seen this typed lisp of yours. I hope you keep pushing on it!
16:14:23 <Stratege> chrisdone ... kinda? ^^; maybe...
16:14:43 <agocorona> and this: http://raganwald.com/2013/07/19/javascript-is-a-lisp.html
16:14:43 <chrisdone> the comments at the bottom of it are like https://www.youtube.com/watch?v=L3LHAlcrTRA&t=0m18s
16:15:54 <shapr> acowley: Frames is awesome! I wish I had it a year ago!
16:16:30 <chrisdone> acowley: \o/
16:17:10 <acowley> shapr: I was too slow!
16:17:35 <cmccann> acowley: oh hey I wanted something like that a year or two ago myself
16:17:56 <acowley> shapr: I only wrote it because I was frustrated at people proclaiming its absence as some intrinsic quality of static typing. But now I'm glad I did!
16:18:50 <chrisdone> frames? what be that?
16:19:12 <shapr> chrisdone: Haskell version of DataFrames in R and Python : https://github.com/acowley/Frames
16:19:25 <Stratege> agocorona - yes, js being a lisp is, in my opinion, one of the greatest jokes in programming. ^^
16:19:30 <acowley> chrisdone: In gif form here: https://twitter.com/a_cowley/status/537674947234373632
16:19:35 <acowley> chrisdone: In video form on youtube
16:19:43 <shapr> chrisdone: This past year I did huge amounts of CSV processing for data imports, Frames is perfect for what I was doing!
16:20:01 <acowley> chrisdone: In tutorial form here: http://acowley.github.io/Frames/
16:20:01 <shapr> acowley: youtube link?
16:20:29 <shapr> I wrote a csv cleanup framework in Python, but it would have been so much nicer with Frames!
16:20:29 <acowley> shapr: http://youtu.be/2-JFkv9-JOQ
16:20:35 * shapr clicks
16:21:18 <acowley> Only the first 20 minutes talk about Frames
16:21:33 <cmccann> acowley: you seem to make good use of vinyl
16:21:36 <nkar> what does N mean in the container types section? https://wiki.haskell.org/GHC/Memory_Footprint
16:22:03 <agocorona> anyone develop with a tablet using an online IDE like the FPcomplete one?
16:22:04 <chrisdone> acowley: ah it's a type-provider TH whatsit?
16:22:05 <acowley> cmccann: This was one of the applications that first got me interested in Vinyl!
16:22:10 <acowley> chrisdone: Yes!
16:22:18 <acowley> chrisdone: But then it takes the next step, too
16:22:24 <acowley> which is efficient column-based storage
16:22:36 <acowley> so Doubles and Ints are in Unboxed vectors, while Text is in Boxed Vectors
16:22:39 <chrisdone> i've been telling my coworkers this was easy in haskell for ages but no-one believed me
16:22:46 <acowley> and you can extend the set of possible types with your own data types
16:22:51 <chrisdone> nice
16:22:54 <cmccann> acowley: ah, I see. I was using vinyl-gl for a while when tinkering with loading 3d model data
16:23:20 <acowley> cmccann: vinyl-gl was the first thing I did with Vinyl while Frames was the first thing I thought of (but didn't do) :P
16:23:27 <cmccann> heh
16:23:44 <nkar> acowley: thanks for the compose conf talk!
16:23:46 <chrisdone> acowley: so it guesses the types based on looking at a few rows of the data in the file?
16:23:50 <acowley> chrisdone: Yeah, I got tired of claiming it would work out great
16:24:00 <acowley> chrisdone: Yes, although it looks at something like 1000 rows
16:24:05 <acowley> chrisdone: But that's just a number
16:24:29 <acowley> chrisdone: You can get the type from a model data set (which I haven't written up an example of yet) or of course write out the type yourself if you want to.
16:24:34 <cmccann> acowley: vinyl can be a bit cryptic at first but I thought vinyl-gl did a good job of showing how pleasant using it could be
16:24:36 <chrisdone> right. definitely how i would've done it. this is sweet
16:24:56 <acowley> cmccann: Thanks! I find it that it makes GLSL interop much easier, myself.
16:24:59 <chrisdone> i'm gonna share this at work, we have some quant clients interested in this kind of stuff
16:25:28 <acowley> chrisdone: I'm working with CJ East on extending it. There are two features next up: summarize and melt
16:25:47 <cmccann> acowley: I since moved on to hacking on some lower-level stuff but I'm probably going to take some inspiration from vinyl-gl later on even if I don't use it directly
16:26:11 <acowley> chrisdone: melt lets you view columns as rows, in a sense, while summary should just identify a handful of folds for each column based on data type (e.g. min, max, mean)
16:26:29 <cmccann> acowley: plus I got tired of working around the weird abstraction gaps in the OpenGL package :T
16:26:46 <acowley> cmccann: I've been doing all my rendering with OpenCL of late since that's what my DSL can target righ tnow
16:27:04 <acowley> cmccann: At some point I'll do a GLSL backend, but ... time
16:27:09 <chrisdone> acowley: this makes me want to complete my 'present' package which might complement it
16:27:34 <shapr> chrisdone: what's present?
16:27:38 <acowley> chrisdone: That sounds good. The way it fits into IHaskell is great
16:27:51 <cmccann> acowley: I decided that if I was gonna have to dig into the raw API for opengl I might as well use edwardk's gl package instead, heh
16:28:29 <acowley> nkar: I hope you enjoyed the talk! Also, in case nobody's answered your earlier question, N on that page is the length of the container.
16:28:38 <chrisdone> shapr: https://www.youtube.com/watch?v=ijmtEzqlmJM
16:28:55 <chrisdone> shapr: a lazy, structured printer for haskell values
16:29:06 <acowley> chrisdone: Have you taken a look at IHaskell, btw? The evaluation part of it is really quite good.
16:29:19 <chrisdone> yup
16:29:23 <acowley> It's missing something like present
16:29:24 <shapr> ooh, neat
16:29:46 <acowley> But I like the way it blurs the line between writing a source file and working at a REPL
16:29:47 <chrisdone> that main roadblock for general use of present is that it requires data types to be instances of Data
16:30:10 <shapr> Wow, I hadn't seen IHaskell, so nice!
16:30:11 <chrisdone> so i have a branch that replaces that with some template-haskell to derive the right printer
16:30:23 <chrisdone> acowley: yeah, great for demonstration purposes
16:31:13 <acowley> chrisdone: Have you gotten an "eval-region" into haskell-mode yet?
16:31:18 <chrisdone> (gibiansky approached me about getting present in there)
16:31:26 <acowley> chrisdone: I know we've talked about it in the past, but I never got anything done
16:31:49 <chrisdone> haha
16:32:17 <chrisdone> no, but others have asked for it once in a while
16:32:48 <acowley> I kind of like working with outorg in emacs so I can get images, text formatting, LaTeX and junk into comments, but the fragility of the REPL state makes that aspect less than satisfying.
16:33:37 <shapr> acowley: Do you have any of your exciting org-mode documents in github or something?
16:33:47 <shapr> I use org-mode, but don't consider myself much of a power user.
16:34:37 <acowley> shapr: It's not super exciting, but the entire Frames tutorial is an org file that I can load into the REPL
16:34:42 <acowley> https://github.com/acowley/Frames/blob/master/demo/Tutorial.hs
16:35:20 <acowley> shapr: The documents don't look too exciting when viewed as code, of course, which is kind of the point
16:35:29 <shapr> wow
16:35:42 <acowley> shapr: But just dropping in an image file of a plot with [[plot1.png]] and viewing it inline is pretty sweet
16:35:43 <shapr> Module.org instead of Module.lhs ? :-)
16:36:21 <chrisdone> acowley: hmm
16:36:22 <ronbrz> join #emacs
16:36:27 <ronbrz> ...
16:36:27 <chrisdone> we could add inline images in the repl
16:37:10 <chrisdone> but like, rendering charts and such
16:37:21 <shapr> that would be cool
16:37:40 <chrisdone> if :t it = Diagram then renderDiagramToFile → emacs embed file as output
16:37:45 <chrisdone> badabingbadaboom
16:37:52 <shapr> yay!
16:44:31 <fread2282> is there an explanation of typechecking with metavariables somewhere (not the paper)?
16:45:29 <chrisdone> acowley: sending code to the repl should improve when we add a --json arg to ghci-ng
16:45:43 <chrisdone> the whole :{ :} stuff is pretty biz
16:46:13 <acowley> chrisdone: Yeah, though why json and not s-exprs?
16:48:37 <chrisdone> acowley: emacs can do either, but editors like vim and sublime are more likely to grok json so i figured that was more diplomatic
16:49:18 <chrisdone> although it probably doesn't matter once a format infrastructure is setup any format can be added
16:49:20 <acowley> chrisdone: It certainly sounds diplomatic, but I'm just wondering if it brings along too many annoyances with quoting and whatnot.
17:03:45 <yac> https://en.wikipedia.org/wiki/Purely_functional
17:03:51 <yac> is haskell purely functional or impurely?
17:04:07 <yac> ^ That article claims it's impure but I have always heard haskell being pure.
17:04:18 <MP2E> Haskell is pure, Haskell programs are impure
17:04:22 <MP2E> confusing, I know :P
17:04:31 <shachaf> That phrase is meaningless but it's also likely to cause a lot of irritation and arguing.
17:04:36 <MP2E> ^
17:04:50 <yac> Also I want to have lightning talk demonstrating how it is impossible to insert IO () into a pure function and how it is a good thing
17:04:54 <shachaf> So it's best not to worry about whether Haskell is purely functional or not, but rather to worry about what properties you actually care about.
17:05:11 <shachaf> MP2E: You seem to be agreeing with me but you were saying the exact opposite a few moments ago...
17:05:12 <yac> I have called "Functional purity of haskell" but now I'm thinking the subject matter actually doesn't have anything to do with purity
17:05:19 <acetoline> haskell accumulates impurities over time due to damage by cosmic radiation
17:05:34 <yac> more like with the type system expressivity (?) - like having an extra type for IO
17:05:40 <glguy> I don't think it's interesting to describe a language as "pure", but to think of its functions as generally (modulo escape hatches) pure
17:06:18 <reem> You can't insert IO () into a pure function because you can't go from IO x -> x safely, it doesn't strictly have anything to do with purity - IO is not special in this way.
17:06:25 <yac> MP2E: mmkay, I lack the PLT training to truly understand that but I think I get the main idea
17:06:34 <reem> You can easily define your own types and write Monad instances for them that have this property in common with IO
17:07:24 <yac> yeah. That's what I realized. But now I need to figure out the proper name for the lightning talk
17:07:34 <yac> but I got nothing ...
17:08:10 <chrisdone> i think of evaluation of haskell as pure given that very few things are observable like time, exceptions or mutation
17:08:50 <yac> maybe haskell type system strictness?
17:08:56 <MP2E> shachaf: My statement is the reverse of yours? I didn't say purity was important
17:08:58 <chrisdone> execution of ST, IO, STM or a user-defined library tend to have their own odd operational properties
17:09:21 <MP2E> as in, the label
17:09:41 <MP2E> I'd rather not argue about semantics though, I think I just tend to express things badly
17:09:44 <MP2E> heh
17:09:50 <chrisdone> glguy: is there a substantial difference?
17:10:35 <yac> actually maybe I can keep the "Functional purity of haskell" title given that the talk is to people with zero-knowledge and basing the talk on "Haskell if purely functional but we need the programs to actually be impure to perform side-effects, therefore ..."
17:10:48 <yac> s/ if / is /
17:11:49 <vanila> I don't understand how this is a point of contention
17:12:07 <vanila> its so clear cut and obvious
17:12:22 <chrisdone> the distinction between evaluation and execution seems like a pretty reliable one
17:13:29 <chrisdone> e.g. OCaml has sleep : int -> unit, and it has a function time : unit -> float which would allow you to measure, during evaluation, how much time actually passed after calling sleep 5
17:13:57 <chrisdone> haskell doesn't have that capability in its evaluation
17:14:31 <chrisdone> though GHC might give you tricks to get around that, they are tricks
17:15:48 <nkar> acowley: one question about the talk.  you said that the copter's protocol is not reversed, so you had to do something special in order to manipulate it.  but I forgot what exactly.  how did you talk to it?
17:16:12 <Stratege> "unit -> float" is sort of a scary type ^^
17:16:48 <acowley> nkar: I tore the potentiometers off of the joysticks, soldered wires into their middle pins, then ran a PWM through a low-pass circuit from a microcontroller that I could talk to via USB
17:35:02 <acowley> nkar: Here are the pictures: https://twitter.com/a_cowley/status/566409313707888640
17:46:43 <hakujin> I made a small "tree + ag" filesystem visualization program called leaves. I'd love some feedback on areas where I could improve: https://github.com/hakujin/leaves
17:51:36 * hackagebot yet-another-logger 0.1.1 - Yet Another Logger  http://hackage.haskell.org/package/yet-another-logger-0.1.1 (larsk)
18:00:58 <mniip> any advices on dynamic loading and reflection in haskell?
18:03:12 <hakujin> mniip: maybe https://www.fpcomplete.com/user/thoughtpolice/using-reflection
18:03:51 <shachaf> The word "reflection" means a lot of things. But someone who hasn't seen the Haskell library "reflection" probably isn't thinking of the thing it does when they say it.
18:06:37 <mniip> yeah I'm more interested in dynamic loading than reflection
18:08:58 <mniip> like loading a module from an compiled object/shared object at runtime, and then loading some values (with known types) from there
18:11:16 <hakujin> you can use something like http://hackage.haskell.org/package/plugins-1.5.4.0 or the GHC api directly
18:11:53 <mniip> I've tried plugins some weeks ago
18:12:05 <mniip> they should use some more descriptive names than Prelude.undefined
18:12:12 <mniip> descriptive errors*
18:16:10 <Javran> http://lpaste.net/120483 is this a monad? got to be the most boring monad ever if it is.
18:16:22 <shachaf> It's a monad. The usual name is Proxy.
18:17:06 <Cale> Javran: It obviously satisfies the laws :)
18:17:22 <Javran> oh I see
18:17:37 <Cale> (not hard to satisfy equational laws when there's only one value available)
18:18:01 <Javran> it even has a name
18:18:34 <Javran> I thought before Identity was the most trivial one, but I was wrong
18:18:49 <EvanR_> Identity is more boring
18:19:17 <Javran> wait ... Identity is more boring?
18:19:31 <Rotaerk> why are people so keen on stealing it then?
18:19:34 <Javran> but Proxy does nothing IMHO...
18:19:58 <Rotaerk> Javran, proxy can be useful for resolving types
18:20:02 <EvanR_> Boring a and Identity do the sme thing
18:20:10 <EvanR_> they just have different type level behavior
18:21:14 <shachaf> Proxy is a useful type in Haskell.
18:21:37 <shachaf> It would be less useful in a language with (closer to) first-class types, but still useful.
18:21:40 <Javran> I get the type resolving idea - I came up with Proxy monad after I learned that phatom type trick
18:22:15 <EvanR_> you could have invented Proxy
18:22:38 <Javran> @hoogle Proxy
18:22:39 <lambdabot> Network.HTTP.Proxy module Network.HTTP.Proxy
18:22:40 <lambdabot> Graphics.Rendering.OpenGL.GL.PixelRectangles.ColorTable Proxy :: Proxy
18:22:40 <lambdabot> Network.HTTP.Proxy Proxy :: String -> (Maybe Authority) -> Proxy
18:23:26 <Javran> where can I find Proxy monad?
18:23:36 <shachaf> Data.Typeable exports it.
18:23:54 <shachaf> Oh, Data.Proxy
18:23:58 <shachaf> It's in base now.
18:24:12 <Javran> ah thanks, I found it
18:24:18 <lfairy> if it's not in base, it's in the tagged package
18:32:57 <Javran> one question starts to bother me: is "Proxy Void" inhabitable?
18:33:24 <shachaf> Not only is it inhabitable, it's inhabited.
18:33:30 <shachaf> Proxy :: Proxy Void
18:33:40 <shachaf> Nothing :: Maybe Void, [] :: [Void]. Same thing.
18:35:26 <Javran> ahh I see
18:36:03 <Javran> just like "f :: Void -> Int" is still possible
18:39:09 <pingu> junmin: an infinite number of f :: Void -> Integers are possible ;)
18:39:16 <pingu> *Javran
18:39:24 <Javran> wait ... a^0 = 1 when a /= 0, but there should be more than one inhabitant in "Void -> Int", f _ = 0, f _ = 1, .... for example
18:39:42 <shachaf> Javran: That's because Haskell's Void has an extra inhabitant, _|_
18:39:50 <pingu> Javran: yes, because you are invoking bottom
18:40:00 <pingu> to inhabit it, which breaks all such reasoning
18:40:08 <EvanR_> but you dont need bottom for Proxy Void
18:40:28 <Javran> I see
18:41:10 <vanila> there is only one function f :: Void -> Int  if you think about it. take g :: Void -> Int too, then forall x, f x = g x
18:41:20 <Javran> I did recall those type algebra tutorials don't like to talk about bottom
18:41:22 <vanila> the reason forall x, f x = g x holds is that there are no such 'x''s
18:41:43 <pingu> Javran: perhaps this helps explain what Proxy is:
18:41:50 <pingu> http://ponies.io/posts/2014-07-30-typelits.html#proxies-like-existentials-but-exactly-the-opposite.
18:42:01 <pingu> err....
18:42:05 <shachaf> That's a bizarre title.
18:42:23 <pingu> http://ponies.io/posts/2014-07-30-typelits.html#proxies-like-existentials-but-exactly-the-opposite%2E
18:42:30 <shachaf> What does Proxy have to do with existentials?
18:42:50 <EvanR_> unexistential?
18:43:07 <pingu> Okay, perhaps it's a terrible analogy, I don't know ;)
18:43:31 <shachaf> I read the explanation but I think it's a stretch.
18:43:34 <shachaf> Ah, that's your page.
18:43:46 <vanila> the rules like |a -> b| = |b|^|a| hold when you restrict your attention to total functions, they work for Void just fine
18:45:55 <shachaf> Most of the time there's nothing special about Proxy. You just need any type.
18:46:09 <shachaf> You can often write it lower-case: typeRep :: Typeable a => proxy a -> TypeRep
18:46:20 <shachaf> The user can choose any type they want, not just Proxy.
18:46:31 <shachaf> E.g. typeRep (Just x) or typeRep [x] to get the type of x.
18:48:29 <Javran> pingu: I don't have much knowledge about kinds, but it seems to be fun. that " let p = Proxy :: Proxy "hai" " looks interesting, I didn't know you can plug in values in type arguments.
18:48:45 <shachaf> Javran: It's not a value, it's on the type level.
18:48:51 <shachaf> It just happens to look exactly like a String. :-)
18:49:22 <shachaf> "abc" :: Symbol exists on the type level to make things convenient.
18:49:31 <Javran> I tried "let k = Proxy :: Proxy Monad" and "let k = Proxy :: Proxy Num"... they all worked.
18:49:45 <shachaf> Yes, Proxy is polykinded now.
18:49:55 <shachaf> This goes well outside of Haskell 2010, but it's a useful extension.
18:50:16 <Javran> typeclasses has a kind called "Constraint" or something if I recall it correctly?
18:50:37 <shachaf> Constraints have a kind called Constraint.
18:50:52 <shachaf> A Constraint is something that can go on the left side of =>
18:50:56 <shachaf> E.g. Show is a type class, but (Show a) is a constraint.
18:51:02 <Javran> shachaf: I see
18:51:05 <shachaf> (There are non-type-clas constraints too.)
18:51:37 <shachaf> (class)
18:51:37 <Javran> like "MonadReader [Int] m"?
18:51:47 <shachaf> That's still a class constraint.
18:51:57 <Javran> hmm
18:52:10 <shachaf> But e.g. (a ~ b) is a constraint that says a is equal to b, and (?x :: a) is a constraint that says that ?x has type a.
18:52:33 <Javran> i see
18:55:31 <shachaf> Can you manipulate a Symbol as a String on the type level?
18:56:40 * hackagebot hjsonschema 0.2.0.0 - Haskell implementation of JSON Schema v4.  http://hackage.haskell.org/package/hjsonschema-0.2.0.0 (seagreen)
18:59:28 <Javran> shachaf: I found some "functions on type literals" here http://hackage.haskell.org/package/base-4.7.0.2/docs/GHC-TypeLits.html is this related?
18:59:44 <LordBrain> what tool reads files with the extension .spec ?
18:59:51 <Javran> I know nothing about type familes though
18:59:56 <LordBrain> such as alex.spec in the alex source repo
19:00:12 <L8D> Where can I find more information on this "Mu Haskell" compiler I see scattered around
19:00:36 <shachaf> Javran: It's related but I'm not sure that it answers my question.
19:03:13 <Big_G> What are you all doing this lovely Friday night?
19:04:09 <Javran> I tried "let t = Proxy :: Proxy something-not-defined" and it worked. now I know why there are literals
19:19:40 <fread2282> Could not deduce (Monad n) from the context: (Monad m, m ~ n)
19:19:41 <fread2282> :(
19:22:23 <Big_G> fread2282, What does ~ do?
19:22:44 <fread2282> :k (~)
19:22:45 <lambdabot> k -> k -> Constraint
19:23:03 <Big_G> That doesn't make much more sense
19:23:12 <fread2282> Big_G: forces the arguments to be equal
19:23:49 <Big_G> What is the point of forcing the input and output to be equal?
19:24:19 <mniip> input and output?
19:24:37 <mniip> there's no "ouput"
19:24:52 <pavonia> It's operating on types
19:24:53 <Big_G> It has a return type though
19:25:29 <mniip> it returns a Constraints
19:25:29 <mniip> it returns a Constraint
19:25:35 <fread2282> Big_G: kind, and it's Constraint
19:25:37 <fread2282> :k Eq
19:25:38 <lambdabot> * -> Constraint
19:25:46 <Big_G> Ah Thanks
19:28:01 <koala_man> I have a filenames :: [FilePath] and a getLines :: FilePath -> IO [String]. How do I get a list of (filepath,String) pairs for each filename and line in that file, i.e. IO [(FilePath, String)]? I'm using ListT IO but it seems weird
19:28:46 <koala_man> runListT $ do { file <- ListT $ return files; line <- listT $ getLines file; return (file, line); }
19:29:38 <koala_man> can I write that with less ListTs everywhere?
19:30:44 <fread2282> if we have Constraint type synonyns, why not have value type synonyms?
19:31:06 <pavonia> :t mapM
19:31:07 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
19:31:21 <fread2282> sort of functions that will always be inlined and must be fully applied
19:31:42 <vanila> :t liftM concat . mapM (\filename -> getLines >>= (\lines -> map ((,) filename) lines))
19:31:42 <lambdabot>     Not in scope: ‘getLines’
19:31:43 <lambdabot>     Perhaps you meant one of these:
19:31:43 <lambdabot>       ‘getLine’ (imported from Prelude),
19:32:26 <xnil_> :k +
19:32:27 <lambdabot> parse error on input ‘+’
19:32:30 <xnil_> :k (+)
19:32:31 <lambdabot> Not in scope: type constructor or class ‘+’
19:32:32 <koala_man> so two nested maps
19:32:42 <xnil_> gay
19:32:46 <xnil_> :t (+)
19:32:47 <lambdabot> Num a => a -> a -> a
19:32:55 <xnil_> :k Num
19:32:56 <lambdabot> * -> Constraint
19:38:28 <Dhalli> Can someone help me with a ranking function for a basic game?  ranking :: (Ord x) => [x] > [(Int, x)]
19:39:45 <Dhalli> ranking ["one","one"]) "==" [(1,"one"),(1,"one")]  would be if two people are tied
19:40:14 <Dhalli> ranking ["two","one","one"]) "==" [(1,"one"),(1,"one"),(3,"two")]
19:40:21 <meoblast001> when i `cabal install`, isn't cabal supposed to install all referenced dependencies in my cabal file?
19:41:39 <meoblast001> oh, nvm. i see my issue
19:41:53 <mniip> does it have to be a 3?
19:42:05 <mniip> or any number larger than 2
19:42:07 <mniip> er
19:42:10 <mniip> than 1
19:42:47 <Dhalli> anything larger than 1
19:45:59 <hakujin> rank xs = zipWith (,) (group $ sort xs) [1..]
19:46:02 <hakujin> might work
19:46:02 <Arahael> So, I'm using overloaded strings, but this line using the wreq library  gives me problems:
19:46:31 <Arahael> r <- post "http://www.foo.com/" ["selectDay" := "today"]
19:47:02 <mniip> hakujin, that's not it
19:47:13 <Arahael> Because it can't tell if "today" should be a string, so it's ambigious.  What's the best way to work around that? (Other than setting x :: String = "today", and using x)
19:47:13 <mniip> but the idea is nice
19:48:08 <bananagram> @pl \c a b -> either a b c
19:48:08 <lambdabot> flip (flip . either)
19:49:15 <jmcarthur> Arahael: you could just say ("today" :: String)
19:49:26 <jmcarthur> Arahael: or you could stop using OverloadedStrings
19:49:36 <mniip> dhalli---
19:49:40 <mniip>  rank xs = concat $ zipWith (map . (,)) [1..] (group $ sort xs)
19:49:41 <mniip> :/
19:50:13 <jmcarthur> Arahael: or you could make a specialized function to use in place of (:=)
19:50:33 <Arahael> jmcarthur: The odd thing is that the wreq tutorial specifically suggests using OverloadedStrings.  There is nothing that allows Haskell to do: "Ok, strings are all overloaded...  But if it's ambigious, try ordinary String instead""?
19:51:23 <jmcarthur> Arahael: that could lead to behavior that is difficult to predict (e.g. if it's ambiguous for most of your testing but then becomes unambiguous, behavior would change)
19:51:42 * hackagebot static-canvas 0.2.0.0 - DSL to generate HTML5 Canvas javascript.  http://hackage.haskell.org/package/static-canvas-0.2.0.0 (jeffreyrosenbluth)
19:51:46 <Arahael> jmcarthur: That's a point.
19:52:04 <Arahael> So explicitly stating that it's String is probably the best way, then?
19:52:34 <jmcarthur> Arahael: or my last suggestion, a specialized (:=) or somesuch. basically you just need some way of ensuring that the compiler can tell the type
19:53:01 <Arahael> jmcarthur: The problem isn't that it can't tell the type - but that it's ambigious.
19:53:06 <jmcarthur> right
19:53:16 <Arahael> jmcarthur: (And I'm very, very new to Haskell.)
19:53:20 <jmcarthur> ah
19:54:18 <shachaf> i,i it can tell the type, but it can also tell several other types
19:54:29 <Arahael> About 18 other types, iirc.
19:54:43 <jmcarthur> Arahael: my two suggestions other than not using OverloadedStrings are (1) just say ("today" :: String), or (2) define your own alternative to (:=) where the second argument is monomorphized to String via type signature
19:54:49 <cmccann> shachaf: are you really still using that weird i,i emoticon
19:55:00 <jmcarthur> Arahael: the benefit of the second approach is that you can reuse it multiple times
19:55:12 <Arahael> jmcarthur: Thanks - so I think I'll do that second approach.
19:55:21 <jmcarthur> Arahael: the benefit of the first is that it's cleaner when you only do it once or twice
19:55:38 <jmcarthur> Arahael: and is easier to read without needing to figure out the other operator
19:55:52 <Arahael> jmcarthur: Well, in practice most of the time "today" comes from an argument, so I think second is best.
19:56:39 <jmcarthur> Arahael: a third option is what you were thinking: define a variable with the correct type. useful if you will be reusing it anyway. e.g.  today = "today" :: String
19:57:22 <Arahael> jmcarthur: Awesome. :)  So now I can move on to making sense of the resulting html. ;)
19:57:33 <Arahael> So I'm going to look for html parsers.
19:58:02 <Gholli> why would the function group say it is out of scope?
19:58:19 <hakujin> Gholli: import Data.List (group)
19:59:51 <Gholli> Thank you!
20:00:03 <enthropy> maybe there should be defaulting for Strings when using OverloadedStrings
20:00:23 <mniip> Gholli == Dhalli?
20:00:33 <t4nk929> anyone online?
20:00:39 <mniip> everyone is dead
20:00:45 <t4nk929> hey i need help
20:01:10 <t4nk929> mniip you can help?
20:01:29 <mniip> not until you evaluate your question
20:01:46 <t4nk929> i have evaluated it as both urgent and serious
20:01:51 <t4nk929> i will describe
20:02:06 <t4nk929> socket-io package examples are confusing
20:02:10 <shachaf> t4nk929: Don't put people on the hook for helping you before knowing what your question is. It's not nice.
20:02:23 <t4nk929> kk sry
20:02:42 <t4nk929> i know nothing about cabal run as a way to build packages
20:02:52 <t4nk929> the internet is really barren on this
20:03:00 <mniip> no I can't help you there
20:03:17 <t4nk929> there is a resource directory that cabal uses?
20:03:22 <Gholli> mniip yes. I switched IRC clients and my name was still taken
20:03:35 <Arahael> Gholli: Don't you register your nicks?
20:03:36 <mniip>  rank xs = concat $ zipWith (map . (,)) [1..] (group $ sort xs)
20:04:02 <mniip> or even
20:04:14 <mniip> concat . zipWith (map . (,)) [1..] . group . sort
20:05:38 <t4nk929> ok i wrote up my problem here http://www.reddit.com/r/haskell/comments/2euj6e/what_is_the_proper_way_to_communicate_with_a_web/
20:07:26 <Gholli> I want rank ["two","one","one"]) to equal  [(1,"one"),(1,"one"),(3,"two")]  because one of those is second since they are tied    but it returns [(1,"one"),(1,"one"),(2,"two")] mniip can you help?
20:08:23 <t4nk929> this package serves as the front end for new users wanting to interface with js. if someone knew about cabal makes the program uses resources from the resource directory such as apparently invoking a node server, i would really like to know!
20:08:36 <t4nk929> how*
20:09:35 <t4nk929> i could describe in more detail if anyone had some time to help look at this problem, it would be really helpful
20:10:01 <Arahael> t4nk929: Your problem is that you need to make people _want_ to help, and generally, making people dig for more informmation is not fun.
20:10:32 <Arahael> t4nk929: For instance, I notice that you already described the problem in that reddit link, however, I see no mention of cabal there, yet you think the problem is cabal?
20:10:33 <t4nk929> im trying to describe as best i can but it seems desperate if no1 cares
20:10:49 <t4nk929> sorry for being flippant
20:10:53 <nkar> I have a record like this: data Record = Record { ... , fieldN :: (ByteString, ByteString) , ... }.  would it be represented differently in memory if I change it to: data Record = Record { ... , fieldN1 :: ByteString, fieldN2 :: ByteString , ... }?
20:10:54 <t4nk929> thanks for reading the link
20:11:30 <Arahael> t4nk929: Curiously, the reddit link also makes no mention of javascript.
20:11:31 <mniip> Gholli, rank l = let s = sort l in map (\x -> (1 + fromJust (elemIndex x s), x)) l
20:11:49 <Arahael> t4nk929: So I can only conclude that the reddit link, and your (new?) problem are completely unrelated?
20:12:04 <RickyGF> encrypt :: (Int >
20:12:04 <RickyGF> Int) >
20:12:04 <RickyGF> (Char >
20:12:04 <RickyGF> Char)   how can I encrypt a message  so encrypt (+3) 'a')   would equal  'd'
20:12:08 <t4nk929> i dont think the problem is cabal but in my bugfinding because i dont know how cabal accesses this resource directory to bring about the functionality of the example
20:12:31 <RickyGF> encrypt :: (Int -> Int) -> (Char -> Char)   how can I encrypt a message  so encrypt (+3) 'a')   would equal  'd'
20:12:50 <bitemyapp> cmccann: did you look at what I linked to in my comments before you replied?
20:12:57 <t4nk929> my problem was that the build instructions were unclear and that it was not a useful example for learning how to use this package
20:12:57 <bitemyapp> cmccann: just wondering.
20:13:01 <Gholli> Thank you mniip, this should help my game scoring!
20:13:15 <mniip> RickyGF, encrypt f = chr . f . ord
20:13:27 <Arahael> t4nk929: Perhaps find a different example, then?
20:13:43 <t4nk929> this is actually THE point of access to the community at large
20:13:53 <cmccann> bitemyapp: yes. and you are still missing my point.
20:14:18 <Arahael> t4nk929: What resources have you been learning from?
20:14:53 <t4nk929> it provides interface to jacascript through nodes engine.io and socket.io which are a primary alternative to websockets in html. i think a lot of pressure on this haskell package to allow haskell to communicate with node.js
20:15:53 <cmccann> bitemyapp: let me be very clear that I'm not agreeing or disagreeing with you here. I'm thoroughly unimpressed with the behavior of everyone involved right now.
20:16:05 <vanila> RickyGF, you might need modular arithmetic
20:16:28 <t4nk929> i learned haskell from phil wadeler and it has always been my primary language
20:17:04 <cmccann> bitemyapp: I'm trying to appeal to your better nature here in hopes of not having your stubbornness and other people's irrational grudges become a permanent part of the FTP discussion.
20:17:04 <bitemyapp> cmccann: and yet you're only correcting me.
20:17:09 <t4nk929> but i have never submited a package using cabal or seen it used in this way to invoke js
20:17:24 <cmccann> bitemyapp: are you sure about that?
20:17:34 <bitemyapp> let me check your comment history again.
20:17:41 <Arahael> t4nk929: Submitting a package is *another* entirely separate problem.
20:17:53 <t4nk929> yes, but thats why i dont know how to use cabal
20:18:13 <t4nk929> or how it uses the "resource" folder
20:18:20 <bitemyapp> cmccann: oooh you did call out jonsterling for creating off-topic negativity.
20:18:25 <bitemyapp> you got downvoted though, lol
20:18:38 <t4nk929> i mean i have little experience of "cabal run"
20:19:09 <nathan__> does anyone know of a decent haskell book/guide for people with background in category theory, but little background in programming?
20:19:12 <mniip> RickyGF, alternative elegant solution
20:19:26 <mniip> encode = over $ iso chr ord
20:19:38 <bitemyapp> cmccann: bos started the fire in the CEO thread.
20:19:40 <mniip> no wait inverse
20:19:43 <mniip> encode = over $ iso ord chr
20:19:54 <Arahael> t4nk929: I'm actually new to Haskell, but I can find out the project structure from https://wiki.haskell.org/Structure_of_a_Haskell_project
20:20:05 <t4nk929> i found that too
20:20:16 <t4nk929> and it was no help, i need someone who knows about this stuff
20:20:20 <jonsterling> to be more accurate, it was *on-topic* negativity. but I apologize for the vitriol. I certainly wasn't making anything better by partitipating in the very thing I was trying to critique.  / cmccann bitemyapp
20:20:28 <Arahael> t4nk929: You've yet to *explain the problem*.
20:20:28 <cmccann> bitemyapp: I really don't want to make lists of who's done what wrong here.
20:20:39 <bitemyapp> cmccann: they seem quite happy to subject me to that.
20:21:10 <RickyGF> mniip: not in scope over iso ord chr do I need to import?
20:21:18 <cmccann> bully for them, but that's not me.
20:21:27 <hakujin> RickyGF: let encrypt fn = chr . fn . ord
20:21:28 <bitemyapp> jonsterling: consider yourself fortunate that you're not going to have a group of people calling you a terrible person for creating negativity in the thread - I have no such breathing room.
20:21:37 <hakujin> import Data.Char (ord, chr)
20:21:43 <bitemyapp> jonsterling: I've admitted my mistakes and that I was a jerk before and that it's something I need to work on.
20:21:55 <vanila> jonsterling, what happened?
20:21:58 <bitemyapp> jonsterling: the people you are associating yourself with on Twitter are not, do not, and are creating fear.
20:22:19 <jonsterling> bite: I appreciate that. but you keep on doing it again and again. and don't talk to me about other people.
20:22:27 <bitemyapp> jonsterling: people are coming to me in priv chat on IRC to tell me acfoltzer & crew are making them afraid to participate in the Haskell community.
20:22:32 <mniip> RickyGF, iso and over come from the lens package
20:22:38 <bitemyapp> jonsterling: you are part of the problem
20:22:38 <mniip> ord and chr come from Data.Char
20:22:46 <cmccann> jonsterling: I disagree. it was not on-topic, and it was not at all constructive.
20:22:51 <darinmorrison> bitemyapp: so, I don't get it. You just cc me on twitter calling me out for "sniping" at you… I don't even know what you're talking about.
20:22:57 <mniip> but yeah, just use
20:22:57 <mniip> [07:09:41] <mniip> RickyGF, encrypt f = chr . f . ord
20:23:07 <bitemyapp> jonsterling: you snipe and complain aimlessly in public. Unconstructive back-biting.
20:23:18 <bitemyapp> jonsterling: I joined a non-Haskell IRC channel recently, you know what they told me?
20:23:26 <t4nk929> argh its really hard, performing "cabal run" on this directory; https://github.com/ocharles/engine.io/tree/master/examples/latency, creates and executes a binary which *somehow* vends an index.html from the folder "resources"
20:23:26 <bitemyapp> jonsterling: they said I could stay as long as I didn't *act like you*
20:23:36 <darinmorrison> ugh…
20:23:38 <bitemyapp> jonsterling: you are not well loved by everybody either.
20:23:52 <bitemyapp> jonsterling: I know I need to improve - do you?
20:24:01 <Arahael> bitemyapp, jonsterling: Perhaps it might be better to take this somewhere else?
20:24:03 <cmccann> anyway. consider this final notice that personal grudges, no matter how justified, are off-topic in /r/haskell.
20:24:05 <t4nk929> i would like to know how it does this so that i can reproduce its functionality in an easyer example!
20:24:15 <bitemyapp> Arahael: I'm done, sorry.
20:24:33 <cmccann> and I don't want to drag #haskell into this any further, so that's all I'm saying.
20:24:52 <vanila> Part of the problem with bitemyapp is no attempts to help him be less horrible to people ever get through. Every criticism of his is immediately brushed off by his sychophants: anything bad he does is fine 'because he teaches'
20:25:06 <Arahael> bitemyapp: It can still be useful/therapetic for the group to discuss these issues, just probably best not to do it here while we've got newbies (such as I).
20:25:08 <t4nk929> why is everyone having a flame war!?
20:25:11 <nathan__> is this irc usually filled with this kind of drama?
20:25:16 <geekosaur> no
20:25:19 <shapr> vanila: be nice
20:25:24 <shapr> vanila: take it elsewhere
20:25:24 <geekosaur> and I'm close to putting a couple of people on timeout
20:25:32 <Arahael> nathan__: No, and bitemyapp's resources _are_ very useful.
20:25:37 <vanila> ^ lol
20:25:38 <cmccann> nathan__: this is very much non-IRC drama and I hope it stays that way
20:25:43 --- mode: ChanServ set +o shapr
20:25:46 <t4nk929> performing "cabal run" on this directory; https://github.com/ocharles/engine.io/tree/master/examples/latency, creates and executes a binary which *somehow* vends an index.html from the folder "resources" , I  would like to know how it does this so that i can reproduce its functionality
20:26:03 <RickyGF> if I want to use my encrypt function to encrypt a list of strings character by character how would I do that? encryptNew (rot (+1)) ["a","bad","guy"]) == ["b","cbe","hvz"]
20:26:06 <shapr> jonsterling, bitemyapp: take it elsewhere
20:26:30 <geekosaur> t4nk929, it's using Cabal's ability to embed paths. note that it imports a module Paths_latency
20:26:36 <geekosaur> this can be auto-generated by cabal
20:26:37 <cmccann> shapr, geekosaur: sorry for letting this invade #haskell
20:26:46 <t4nk929> yes i did see this
20:26:53 <shapr> I have the banhammer at ready.
20:27:02 <t4nk929> how do i indicate that this is what i want it to do
20:27:27 <geekosaur> t4nk929, https://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-data-files-from-package-code
20:27:39 <vanila> shapr, you should be aware that this has been a problem here too, e.g. http://ircbrowse.net/browse/haskell/?events_page=570101
20:27:48 --- kick: vanila was kicked by shapr (Kicked by shapr)
20:27:56 <shapr> vanila: that's a hint
20:28:15 <geekosaur> yes, please don't add to the mess
20:29:20 <t4nk929> thanks geekosaur
20:29:30 <t4nk929> i dont understand where these are indicated
20:30:12 <t4nk929> getDataDir =  catchIO (getEnv "latency_datadir") (\_ -> getPrefixDirRel "x86_64-windows-ghc-7.8.3\\latency-1.0.0")
20:30:28 <RickyGF> mniip and hakujin   if I want to use my encrypt function to encrypt a list of strings character by character how would I do that? encryptNew (rot (+1)) ["a","bad","guy"]) == ["b","cbe","hvz"]
20:30:29 <t4nk929> its referencing appdata somewhere
20:30:47 <geekosaur> ? it tells you. list files in the other-files: stanza, declare Paths_modulename in other-modules:, import Paths_modulename, and call getDataFIleName. the path is defined by --datadir which you can pass to cabal install or cabal configure
20:31:08 <geekosaur> or there is a default (often listed in a comment in ~/.cabal/config or Windows equivalent)
20:31:15 <hakujin> RickyGF: have a function that is (Int -> Int) -> Char -> Char. You want to apply that function to every Char in a String.
20:31:24 <hakujin> :t map
20:31:24 <lambdabot> (a -> b) -> [a] -> [b]
20:31:36 <mniip> ricardo82, encryptNew = map . encrypt
20:31:43 <mniip> RickyGF, *
20:32:34 <hakujin> you need to realize that String = [Char] too
20:33:02 <RickyGF> Oh okay, did not realize that
20:33:45 <geekosaur> (note that system-installed and user-installed packages have different defaults; the cabal config should show both in appropriate sections)
20:34:50 <t4nk929> ok so i guess all that im confused about is that which is under the hood in snap, i gues... as long as it sees an index.html it is happy and vends it... must be
20:34:57 <t4nk929> thanks guys
20:35:32 <t4nk929> i think my solution was here https://github.com/ocharles/engine.io/commit/ca4086f3424a7e0fa872924a556eb7a9b4d93336
20:35:39 <RickyGF> how do I import the Lens package for iso and over?
20:35:48 <hakujin> RickyGF: don't for now
20:35:52 <t4nk929> i dont know why but maybe cabal deleets the cabal file!?
20:36:06 <csd_> Hello-- would someone please explain to me what this type signature does `Shell :: (forall r. FoldM IO a r -> IO r) -> Shell a` ?
20:36:07 <hakujin> lens is cool but it's not very beginner friendly
20:36:12 <edwardk> RickyGF: "import Control.Lens" after you 'cabal install lens'
20:37:08 <csd_> is Shell just FoldM wrapped in a newtype?
20:37:55 <lfairy> csd_: what library is that from?
20:38:08 <RickyGF> Is there a way to do the encrypting using fromEnum and toEnum? I will be calling "encrypt (+2) 'a' " to produce the letter 'c'
20:38:20 <csd_> lfairy: the new Turtle library, the one that mimics shell scripting
20:38:55 <hakujin> RickyGF: 'ord' and 'chr' are type-restricted forms of 'fromEnum'
20:38:57 <hakujin> https://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Char.html
20:39:02 <hakujin> so, yes
20:39:45 <hakujin> s/fromEnum/fromEnum and toEnum
20:40:08 <lfairy> csd_: so Shell wraps a function that executes a FoldM
20:40:49 <geekosaur> csd_, that looks like a data constructor Shell for a GADT that takes an existentially wrapped FoldM (a monad transformer over IO, from the looks of it) and returns a Shell (type) value
20:40:50 <csd_> lfairy: where should i see the functinon executing the FoldM part?
20:41:43 <lfairy> csd_: it's right below the Shell definition in the docs
20:41:51 <Rotaerk> hmm does Rank2Types only still exist (given the existence of RankNTypes) for backwards compatibility?
20:41:56 <lfairy> csd_: fold, sh, view
20:42:00 <Rotaerk> (I see that it's a synonym of RankNTypes)
20:42:06 <geekosaur> Rotaerk, I think so, yes
20:42:17 <geekosaur> there was an earlier time when only Rank2Types was supported
20:42:25 <Gholli> Can I Map A function Like addOne (+1) [[1,1],[2,2],[3,3]]    so I Have A List Of Lists and Add one to every element so I produces [[2,2],[3,3],[4,4]] I am trying to add curving to my ranking
20:42:44 <csd_> lfairy: oh right but that's not part of the Shell type itself
20:42:56 <fread2282> > map (map (+1)) [[1,1],[2,2],[3,3]]
20:42:58 <lambdabot>  [[2,2],[3,3],[4,4]]
20:43:13 <csd_> forgive me if i'm wrong, i'm new to this
20:43:31 <lfairy> csd_: take a look at the functions that return Shells
20:45:12 <Rotaerk> geekosaur, k, thanks
20:45:37 <Gholli> fread2282 if my function Is Called addOne then would I Say addOne = map (map ...)?
20:45:50 <csd_> lfairy: so if i run `fold <shell>` that runs foldIO, which exposes the innards of the monad, and then lets me supply the folding function to be executed on it
20:46:09 <fread2282> > let addOne = (+1) in map (map addOne) [[1,1],[2,2],[3,3]]
20:46:10 <lambdabot>  [[2,2],[3,3],[4,4]]
20:46:13 <fread2282> Gholli: ?
20:46:59 <fread2282> > map (map (+1))
20:47:00 <lambdabot>  <[[Integer]] -> [[Integer]]>
20:47:04 <fread2282> or that?
20:47:54 <Gholli> what if I want To Pass any type of List of any Calculation like next time I might want (*2) and a different list?
20:47:56 <fread2282> Gholli: if you want to give (map (map (+1)) a name you can do addOne = map (map (+1)), yes
20:48:14 <Gholli> Thank you
20:48:26 <fread2282> > let map2 f = map (map f) in map2 (*2) [[2,2],[4,4]]
20:48:28 <lambdabot>  [[4,4],[8,8]]
20:52:24 <Gholli> Fread2282 if I want To Take a list of functions and return a functions which is their composition would that be similar?  comp [(*5),(+2)] 4)     ==  30        and comp [(3*),(4+),(10*)] 1)     == (3*(4+10))
20:54:57 <fread2282> > let {comp (x:xs) = x . comp xs; comp [] = id} in comp [(*5),(+2)] 4
20:54:58 <lambdabot>  30
20:55:03 <fread2282> Gholli: sort of
20:55:53 <fread2282> Gholli: (curly braces and ; is an alternative to newlines and whitespace)
20:56:07 <orzo> anyone use ipsec basedvpn software and want to join me in writing an IKEv2 daemon in haskell?
20:56:19 <RickyGF> yes orzo
20:56:26 <RickyGF> PM me!
20:56:46 * hackagebot hwsl2 0.1.0.0 - Hashing with SL2  http://hackage.haskell.org/package/hwsl2-0.1.0.0 (srijs)
20:57:34 <orzo> weird, such enthusaism preceded by an abrupt quit
20:57:51 <Halfwit> proceded?
20:58:39 <orzo> preceded, as in came before, RickyGF was very unthusiastic to work with me before abruptly quitting irc.
20:58:42 <orzo> is it a joke?
20:59:06 <shapr> orzo: I think reality impinges on IRC all too often :-P
20:59:31 <vanila> enthusaism preceded by an abrupt quit means that abrupt quit came first
20:59:38 <hakujin> > foldr ($) 4 [(*5), (+2)]
20:59:40 <lambdabot>  30
20:59:47 <orzo> oh, yeah i said that wrong
20:59:48 <hakujin> Gholli: ^
21:00:29 <Gholli> Thanks you
21:01:19 <Halfwit> No, they both mean the same thing. I was just asking because of the ambiguity in the sentence, I hadn't read up a few lines for context at that point.
21:02:27 <fread2282> > foldr (.) id [(*5), (+2)] 4
21:02:29 <lambdabot>  30
21:03:20 <geekosaur> with such a short response then disconnect I suspect they were on their way out and did a quick response before pulling the plug
21:03:44 <Welkin> or maybe Steve Jobs put them on the Mac team
21:03:53 <orzo> so you think RickyGF's response was sincere?
21:03:54 <geekosaur> I've been known to do that when in a hurry (and I note it just turned midnight US eastern; possibly were being chased out of a closing coffeehouse or ertc.)
21:03:59 <Welkin> and they just found out the hard way
21:04:13 <Halfwit> I hope so
21:04:45 <orzo> i'm in US eastern too, geekosaur
21:04:58 <geekosaur> at one point I was dependent on a public library for network access, contacting me when they were closing could well get you that kind of response
21:05:04 <orzo> you anywhere near florida?
21:05:12 <geekosaur> nope, Akron
21:05:48 <orzo> oh
21:09:08 <orzo> here's my IKE library so far, http://jerkface.net/~joe/ike/Data-IKE-Message.html
21:09:27 <orzo> comments/suggestions appreciated
21:11:28 <Rotaerk> huh, so ExistentialQuantification is redundant when you use RankNTypes?
21:11:40 <shachaf> No.
21:11:56 <Rotaerk> I eliminated the former, and my code still has a "forall" in it
21:12:17 <shachaf> Yes. "forall" is used for many things other than existential quantification.
21:12:20 <orzo> not all forall is ExistentialQuantification
21:12:27 <Rotaerk> oh
21:12:28 <shachaf> If you try to existentially quantify something, GHC will ask you to turn it on.
21:12:52 <bitemyapp> shachaf: so existentially quantified types in Haskell do exist
21:13:03 <orzo> RankNTypes enables uses of forall
21:13:36 <orzo> independent of ExistentialQuantification's enabled uses
21:14:06 <monochrom> the litmus test is to really write an existential type and see which extensions allow it.
21:14:12 <shachaf> Lots of extensions let you use forall. RankNTypes, ExistentialQuantification, ScopedTypedVariables, ExplicitForAll...
21:14:32 <orzo> right, but you need at leas tone of them
21:14:48 <monochrom> a controlled experiment that admits no other plausible explanations
21:15:09 <shachaf> monochrom: A controlled experiment admits no unfounded IRC arguments.
21:15:11 <shachaf> So what's the fun?
21:15:17 <monochrom> programmers need to take classes on scientific experiment methods IMO
21:15:29 <orzo> have you guys found a lot of use for ExistentialQuantificaiton?
21:15:49 <monochrom> not a lot, but not very few either
21:15:53 <shachaf> monochrom: Hmm, maybe that's what I call "the usual debugging strategy", or at least a big part of it.
21:16:19 <Rotaerk> having trouble understanding what is existential quantification but isn't a rank 2 type
21:16:34 <shachaf> data T = forall a. T a
21:16:37 <geekosaur> ScopedTypeVariables uses (or abuses) is
21:16:44 <Rotaerk> ah
21:16:47 * hackagebot PerfectHash 0.1.4 - A perfect hashing library for mapping bytestrings to values.  http://hackage.haskell.org/package/PerfectHash-0.1.4 (MarkWotton)
21:17:07 <shachaf> If I give you a value t :: T, you know that it contains x :: a
21:17:10 <shachaf> But you don't know what a is.
21:17:21 <shachaf> You just know that it exists, that's the origin of the term.
21:17:26 <geekosaur> forall is implicit at the top level of a type signature, STV uses it to specify that some type variable should be scoped over an entire definition instead of just that signature
21:17:38 <geekosaur> (explicit forall that is)
21:17:55 <Rotaerk> which means T :: forall a. a -> T
21:17:58 <Rotaerk> which is a rank 1 type..
21:18:00 <monochrom> there is a way to translate a program containing existentials to a program containing rank-2. Oleg has an article on it (and other translations and simulations).
21:18:32 <monochrom> so it is understandable that you may wonder why provide existential when providing rank-2
21:19:27 <monochrom> but it is the same wonder of why provide "f (x:xs) = True" when one can already write "f = \y -> case y of x:xs -> True"
21:20:16 <shachaf> Well, you can also implement existentials more efficiently than you can encode them with rank-2 types (I think?).
21:20:16 <Rotaerk> interesting
21:20:22 <monochrom> or indeed why support user-defined algebraic data types at all when there is a translation to plain lambdas
21:21:10 <Rotaerk> what is the translation of data Foo = Foo Int to lambdas?
21:21:10 <shachaf> Yes.
21:21:22 <shachaf> Foo = Int
21:21:28 <shachaf> No lambdas needed.
21:21:29 <orzo> i was breifly toying with using existentials in my IKE serialization library, so the user could extend it.  But I thought better after a while
21:22:04 <orzo> there's many fields whose formats are identified by 1-byte type codes and new ones may be published later
21:22:20 <monochrom> you can translate user-defined algebraic data types to plain lambdas by church encoding or scott encoding
21:22:22 <orzo> any opinions on that use of Existentials?
21:22:52 <Rotaerk> ah.. I just read about church encoding in the article about rank N types
21:22:54 <Rotaerk> church lists
21:22:56 <Rotaerk> interesting
21:23:00 <monochrom> in fact translating existential to rank-2 is very similar to church encoding.
21:23:20 <monochrom> so this parallel is robust
21:24:20 <shachaf> Yes, it's a good parallel.
21:25:27 <orzo> does oleg's parallel imply that you consider Existential deprecated for your own practice?
21:26:04 <shachaf> I don't think Oleg invented the translation of existentials to rank-n types.
21:26:19 <orzo> well, whoever it belongs to
21:26:23 <orzo> same question
21:26:50 <shachaf> It's a very old thing. Similar to the relationship between "exists x. P(x)" and "not (forall x. not P(x))" in logic.
21:26:56 <monochrom> no, not to my practice. but it inspires me to write this joke:
21:27:01 <monochrom> @quote monochrom river
21:27:01 <lambdabot> monochrom says: You are to send a boolean, a character, and an integer across the river. The list for transporting across the river can hold 3 items, in fact any number of items you like, but they must all be of the same type. On the bright side, after crossing the river, the boolean, the character, and the integer need only be put on show. How
21:27:01 <lambdabot> many trips do you need? Solution: one trip, [show the_boolean, show the_character, show the_integer]
21:27:13 <shachaf> If you can implement a feature in terms of another feature, does that mean it should be deprecated?
21:28:26 <orzo> not generally, but it was a question regrdless
21:28:38 <shachaf> I don't understand the question exactly.
21:28:50 <pingu> shachaf: you can go from Symbol -> String, and String -> Symbol
21:28:54 <shachaf> Existentials are useful, and simulating them with rank-n types is also useful sometimes.
21:29:10 <pingu> shachaf: so yes, to answer your earlier question, you can manipulate Symbols as strings.
21:29:11 <shachaf> pingu: You're talking about String on the type level?
21:29:45 <pingu> You can't do things like isSuffixOf at the type level, at type checking time, no.
21:29:53 <pingu> you can do some weird introspection at runtime.
21:30:02 <shachaf> OK, so you mean you can turn a Symbol into a value-level String.
21:30:06 <pingu> though in theory you could, perhaps.
21:30:10 <shachaf> I meant a type-level String. It would be convenient.
21:30:29 <shachaf> (But you'd need GHC to expose some information about it somehow if you don't want to go through the value level.)
21:31:02 <pingu> shachaf: you can get an ordering from symbols, it seems.
21:31:39 <pingu> but I don't think you can "subdivide" a symbol at the type level.
21:31:40 <shachaf> oh boy, so you can do it
21:31:45 <pingu> so real manipulation is probably out.
21:31:47 <shachaf> Hmm, or maybe not.
21:31:56 <pingu> you could probably quicksort a bunch of symbols
21:32:02 <pingu> if that floats your boat
21:32:14 <shachaf> Yes, but you can't generate symbols and compare until you find one that matches.
21:32:15 <pingu> but most of the useful type magic is for Nat
21:32:17 <shachaf> Oh well.
21:32:38 <pingu> shachaf: correct, at runtime all you can do is construct a symbol and see if it matches a compile time one.
21:32:52 <shachaf> Right. A bit of a scow, but oh well.
21:34:22 <pingu> shachaf: you can, however, have type level lists. and by encoding strings as Nats...
21:34:25 <pingu> you could probably do whatever you want
21:34:36 <pingu> if you have lots of time on your hands and hate yourself
21:35:16 <pingu> your program is probably going to take a while to typecheck and you'll be lucky to get away with this without undecidableinstances.
21:36:17 <shachaf> pingu: Yes, that's why I want to convert from Symbol to type-level String.
21:54:42 <orzo> i'd like for hackage to have a link to reverse dependencies right off the main page for the package
21:59:05 <xnil________> :t getArgs
21:59:06 <lambdabot> Not in scope: ‘getArgs’
21:59:16 <xnil________> :t System.Environment.getArgs
21:59:17 <lambdabot> IO [String]
22:00:26 <xnil________> how would i print out the first string that i get from getArgs? i would like to do something like `getArgs >>= putStrLn . (!! 1)'
22:00:29 <xnil________> err
22:00:33 <xnil________> (!! 0)
22:01:32 <shachaf> You seem to have answered your own question.
22:01:35 <orzo> what's wrong with wha tyou wrote?
22:01:40 <xnil________> that works?
22:02:04 <shachaf> What happened when you tried it?
22:02:05 <pjdelport> Slightly more applicatively, you can say: putStrLn . head =<< getArgs
22:02:06 <xnil________> ohhhhh
22:02:13 <geekosaur> you should try things. (in ghci you may be interested in System.Environment.withArgs for such testing)
22:02:19 <xnil________> sorry, i had it wrapped in a do statement
22:02:39 <xnil________> i'm sleepy, sorry
22:02:39 <shachaf> In ghci you can ":main a b c" to run main with arguments.
22:02:41 <xnil________> thanks guys
22:02:49 <pjdelport> Or, if you're using do syntax, and you don't mind it crashing if you don't have exactly one argument, you can say: [arg] <- getArgs; putStrLn arg
22:02:55 <orzo> you realize your code will crash when they call the program with no arguments
22:03:13 <xnil________> orzo: will it? i thought it would just print the name of the program
22:03:18 <orzo> no
22:03:25 <orzo> haskell doesn't put the name of the program in that list at all
22:03:29 <xnil________> oh
22:03:30 <xnil________> neat-o
22:03:31 <orzo> getProgramName is what you want
22:03:37 <xnil________> i just wanted it to compile
22:03:54 * shachaf sighs with relief.
22:03:54 <xnil> thanks
22:03:59 <orzo> getProgName
22:04:07 <orzo> i mispelled i guess
22:04:09 <xnil> tyty
22:04:51 * mjrosenb is looking for the definition of V2 that is used in the git version of sdl2
22:04:59 <mjrosenb> is there a standard V2?
22:05:25 * mjrosenb also can't find its definition in sdl2 :-/
22:05:28 <wz1000> Does anyone know of a techique to construct the powerset of an infinite list in such a way that every element in the powerset is reachable?
22:06:15 <mjrosenb> wz1000: do you mean every element with a finite number of elements?
22:06:30 <wz1000> mjrosenb: Yes
22:06:48 <mjrosenb> e.g. powerset [0..], it is might hard for both [] and [0..] and [0,2..] and primes to be reachable.
22:06:55 <mjrosenb> s/both/all of/
22:07:05 <shachaf> mjrosenb: It probably comes from linear.
22:07:24 <shachaf> At least, I looked at sdl2 in git and it has "import Linear" at the top of the file.
22:07:30 <shachaf> That's a plausible place to get a type called V2. :-)
22:07:47 <xnil> wait, so why doesn't `getArgs >>= foldl (++) "" . map (++ " ")' work? I get the error `Expected type: [[String]]; Actual type: IO [String]'
22:08:11 <wz1000> In this case I don't really care about infinite sequences, but that would be a nice addition to have.
22:08:12 <shachaf> xnil: You're writing everything in point-free style for some reason. You're only making life hard for yourself.
22:08:23 <xnil> ,_,
22:08:27 <pjdelport> wz1000: Maybe using factoradics / Lehmer coding?
22:08:29 <shachaf> do { args <- getArgs; foldl (++) "" (map (++ " ") args) }
22:08:46 <shachaf> xnil: The type of the whole thing needs to be IO something, but foldl (++) "" will gives you a String.
22:09:12 <xnil> shachaf: how do i unwrap the IO something and just get something
22:09:24 <pjdelport> Hmm, no, nevermind.
22:09:25 <xnil> is it at all possible?
22:09:28 <shachaf> There's no such thing as unwrapping the IO something.
22:09:32 <shachaf> There's no IO wrapper.
22:09:47 <shachaf> And what do you want to "unwrap", anyway? args, in the snippet I wrote, is already :: [String].
22:10:01 <xnil> sorry, i'm just picturing IO as something like a GADT where i can extract the inner value
22:10:05 <Buttons840> can I force cabal to build a new binary every time I run cabal build -- right now it doesn't actually do any building if the source files haven't changed
22:10:25 <xnil> something like Rust's matching with Some/None
22:10:41 <pjdelport> wz1000: You could use the isomorphism with binary numbers and enumerate the elements in that order, or would that not work for your purposes?
22:11:21 <orzo> Buttons840: cabal has a 'clean' command you konw
22:11:28 <pjdelport> xnil: An IO action doesn't contain anything: it just describes an action to perform.
22:11:39 <xnil> then what's an IO String
22:11:41 <shachaf> xnil: There's no inner value.
22:11:43 <pjdelport> xnil: All you can do is enrich it with more actions to perform. :)
22:11:43 <shachaf> @quote IO.String
22:11:44 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
22:11:58 <pjdelport> xnil: IO String is an IO action that produces String values.
22:12:05 <xnil> WOW
22:12:13 <shachaf> (You really set me up for that one.)
22:12:17 <xnil> this makes everything make more sense
22:12:28 <Buttons840> orzo: too ez ;)  thanks for pointing that out
22:12:42 <cmccann> shachaf: that's one of your better quotes.
22:13:02 <shachaf> cmccann: I'm not sure how to take that. :-)
22:13:13 <xnil> sorry, Rust just had me thinking IO was a GADT that contained something
22:13:25 <shachaf> Rust doesn't have GADTs, does it?
22:13:37 <bjz> shachaf: no
22:13:44 <xnil> what's the word i'm looking for then
22:14:00 <xnil> what is Option<T>
22:14:02 <mjrosenb> c.c Linear.Affine defines the constructor P
22:14:02 <pjdelport> xnil: Another way of thinking about it is that the only thing that gets "wrapped" with a type like IO is the inner *type*. Values don't get wrapped.
22:14:18 <xnil> aha
22:14:19 <bjz> shachaf: well, not yet - given the nature of the language I wouldn't be surprised if they were added in the future
22:14:34 <shachaf> bjz: Let's wait for higher-kinded types first.
22:14:39 <shachaf> xnil: Algebraic data types?
22:14:40 <pjdelport> So with "IO String", String is the "inner" type, but it's just a type-level parameter. There are no String values getting wrapped in anything.
22:14:41 <fread2282> xnil: IO a contains an a in the same way v -> a contains an a
22:14:45 <shachaf> xnil: "G" stands for "Generalized".
22:14:50 <mjrosenb> xnil: haskell has lots of datatypes tha can wrap values, and can be matched, just not IO.
22:15:13 <bjz> shachaf: yup
22:15:19 <shachaf> In Haskell the equivalent to Option is called Maybe -- data Maybe a = Nothing | Just a -- and it's indeed an algebraic data type.
22:15:34 <xnil> shachaf: yeah, i knew of the analogy to Maybe
22:15:54 <xnil> oh, Nothing and Just are type constructors
22:15:54 <pjdelport> xnil: You could actually define your own IO that contains things, and that you can match against, but what it would contain is a tree or similar structure of actions to perform, rather than any values.
22:15:58 <xnil> i see
22:15:59 <mjrosenb> c.c and P does /nothing/
22:16:05 <shachaf> xnil: No, they're data constructors.
22:16:08 <xnil> that
22:16:14 <xnil> IO is not a data constructor
22:16:18 <shachaf> bjz: Hmm, it would be funny to have type equality via GADTs in a language that can't support Leibniz equality vs. rank-2 types.
22:16:25 <shachaf> IO is a type constructor, and so is Maybe.
22:16:27 <xnil> it's more like `Maybe'
22:16:29 <xnil> aha!
22:16:32 <orzo> i think there's an IO data constructor in some GHC.* module you could import
22:16:32 <pjdelport> xnil: In fact, here's an article that goes through that, defining your own IO type: http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/
22:16:40 <xnil> awesome
22:16:41 <shachaf> The exact words aren't too important except for communicating with others. :-)
22:16:48 <abhillman> Is this evil? (return $ unsafePerformIO getLine) >>= putStrLn
22:17:12 <mjrosenb> abhillman: probably.
22:17:15 <shachaf> abhillman: Yes.
22:17:21 <abhillman> Muahahhahahhha
22:17:26 <pjdelport> xnil: The end result is a normal ADT that you can build up just like the primitive IO, but then also deconstruct, transform, and execute (by interpreting and translating it to IO)
22:17:34 <fread2282> abhillman: depends on what you mean by evil
22:17:39 <xnil> muh lambda calculus
22:17:40 <shachaf> pjdelport: I wrote http://stackoverflow.com/a/13538351 probably along similar lines.
22:17:52 <shachaf> I should expand on it at one point, and get the monad nonsense out of it.
22:17:54 <wz1000> abhillman: What is the point except to increase the chances of bugs?
22:18:41 <mjrosenb> it appears as if P merely forces its argument to have a type created by a type constructor
22:18:56 <mjrosenb> Is there a word for that, Maybe Int vs. Int?
22:19:26 <shachaf> For what?
22:19:30 <Arahael> Couldn't match type ‘Data.ByteString.Internal.ByteString' with 'ByteString' <-- How should I deal with that error?
22:19:52 <abhillman> wz1000: Just for some Friday night craziness
22:19:56 <mjrosenb> shachaf: P :: f a -> Point f a
22:19:58 <orzo> Arahael: maybe it's a mismatch between lazy and strict bytestring?
22:20:00 <shachaf> Arahael: Most likely one of them is Lazy and one of them is Strict (confusing error message there). Look in the documentation for how to convert back and forth.
22:20:08 <mjrosenb> shachaf: so you can P (Just 5), but not P 5
22:20:25 <Arahael> shachaf: Will do - thanks.
22:21:07 <shachaf> mjrosenb: You mean newtype Point f a = P (f a)?
22:21:22 <xnil> :t System.Environment.getArgs
22:21:23 <lambdabot> IO [String]
22:21:26 <shachaf> I don't know of a word. Maybe "f a" is an application or something.
22:21:53 <mjrosenb> right, so it is a type that has been created by an application as opposed to a regular type
22:22:01 <mjrosenb> hah, P (2,3) works.
22:22:32 <shachaf> Maybe "atomic" or something, but that's probably not a good word.
22:22:58 <Fusebox> what's an intelligent way to right, say, a duplicate function without explicitly recursing? type: duplicate :: String -> Integer -> String
22:23:22 <shachaf> That depends on what it does.
22:23:55 <Fusebox> duplicate "hello" 3 = "hellohellohello"
22:24:40 <Fusebox> i'm doing some exercises and trying to write a definition using higher order functions for every definition which i use explicit recursion
22:24:48 <shachaf> duplicate :: String -> Int -> String; duplicate s n = concat (replicate n s)
22:25:04 <shachaf> If you insist on taking Integer you'll need to convert to Int to use replicate.
22:25:19 <shachaf> It's not so much "intelligent" as "happens to know about standard library functions".
22:25:34 <xnil> ok, the `do {args <- getArgs; foldl (++) "" (map (++ " ") args)}' solution did not work
22:26:12 <xnil> ghci complains that `args <- getArgs' cannot match type `IO' with `[]'
22:26:17 <shachaf> Yes. 22:05 <shachaf> xnil: The type of the whole thing needs to be IO something, but foldl (++) "" will gives you a String.
22:26:51 <mjrosenb> xnil: it should be return $ foldl... rather than just foldl...
22:27:00 <Fusebox> ta
22:27:03 <xnil> i tried that earlier
22:27:13 <abhillman> For fun, I ran the example for unsafePerformIO provided at http://hackage.haskell.org/package/base-4.7.0.2/docs/System-IO-Unsafe.html#v:unsafePerformIO and it did not seem to  core dump, contrary to the warning specified.
22:27:25 <Fusebox> are list comprehensions slower than higher order functions or explicit recursion?
22:27:37 <xnil> same issue
22:27:38 <mjrosenb> Fusebox: nope.
22:28:05 <shachaf> That question is too vaguely specified to answer.
22:28:21 <shachaf> xnil: You aren't saying what your code is, what you're trying to achieve, or what the error message was.
22:28:33 <shachaf> It's difficult to help you that way.
22:28:59 <mjrosenb> xnil: how is that expression being used, since the orginal one should have typechecked, you're probably using that whoe expression incorrectly.
22:28:59 <xnil> shachaf: i want to return getArgs as a single String joined by " " consisting of the arguments passed to the program
22:29:34 <mjrosenb> xnil: keep in mind, this thing will always have an IO attached to it
22:29:52 <shachaf> xnil: That's part of the way there. :-)
22:29:52 <mjrosenb> it is like bonded quarks, once they're stuck, they're always stuck.
22:29:58 <Fusebox> cheers guys. Btw, I just discovered that somebody has built a bang for Hoogle on DuckDuckGo: e.g. !hoogle concat
22:30:12 <mjrosenb> Fusebox: that's cool
22:30:12 <xnil> myGetArgs = do { args <- getArgs; return $ foldl (++) "" (map (++ " ") args) }
22:30:17 <Fusebox> mjrosenb, LHC split bonded quarks
22:30:46 <mjrosenb> Fusebox: last I checked, they just knocked them around a bit, enough to verify that they were there.
22:30:54 <xnil> i'm calling myGetArgs with
22:31:00 <xnil> putStrLn myGetArgs
22:31:10 <mjrosenb> xnil: there's your problem
22:31:16 <xnil> ?
22:31:24 <mjrosenb> putStrLn takes String, and myGetArgs has type IO String.
22:31:25 <shachaf> xnil: You should give everything I mentioned. What you're trying to accomplish, the code you used, the error message, everything.
22:31:37 <shachaf> xnil: If the problem was where you thought it was, you'd have been able to solve it already. :-)
22:32:14 <mjrosenb> is there a way to get the output of :browse in ghci to be routed to less?
22:32:28 <mjrosenb> it would be /super/ nice if I could search throught that mass of text.
22:32:29 <xnil> how do i pass the result of a function with type `IO String' into a function with type `String -> IO ()'?
22:32:45 <mjrosenb> :t >>=
22:32:46 <lambdabot> parse error on input ‘>>=’
22:32:51 <mjrosenb> :t (>>=)
22:32:52 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:32:53 <xnil> OI
22:32:55 <shachaf> mjrosenb: ghc -e ':browse ...' | less
22:32:56 <xnil> excellent.
22:33:02 <xnil> thank you mjrosenb it all just clicked
22:33:32 <mjrosenb> shachaf: that... is less awesome than I was hoping for.
22:33:40 <shachaf> mjrosenb: Yes. :-(
22:33:42 <Fusebox> mjrosenb, sorry to go off-topic, and I'll stop here, but it seems that they're still trying to verify the data on the quark-gluon plasma the LHC may have produced: http://phys.org/news/2014-05-rice-physicist-quark-gluon-plasma-lhc.html
22:34:40 <xnil> wait, what the heckle?
22:35:14 <mjrosenb> xnil: we're pretty good at heckling, but if it bothers you, we can stop :-p
22:35:50 <xnil> here's the full thing. i want to pass the results of `getArgs' into `foldl (++) "" $ map (++ " ")'
22:36:36 <mjrosenb> xnil: you did that already.
22:36:45 <shachaf> You can use hpaste.org to paste longer code.
22:37:48 <bitemyapp> shachaf: that gets redirected to lpaste.net
22:38:08 * mjrosenb just uses wgetpaste
22:38:12 <mjrosenb> because it is awesome.
22:38:16 <xnil> i'm not able to do that at all
22:38:46 <xnil> the whole `getArgs >>= foldl (++) "" $ map (++ " ")' thing is not at all working in isolation
22:38:56 <mjrosenb> xnil: it sounded like your definition of myGetArgs was correct
22:39:22 <xnil> :t getArgs
22:39:22 <lambdabot> Not in scope: ‘getArgs’
22:39:28 <glguy> xnil: Looks like you meant . instead of $
22:39:30 <xnil> :t System.EnvironmentgetArgs
22:39:31 <lambdabot>     Not in scope: data constructor ‘System.EnvironmentgetArgs’
22:39:34 <xnil> glguy: yes, that
22:39:38 <glguy> and then... some more
22:39:38 <xnil> :t System.Environment.getArgs
22:39:39 <lambdabot> IO [String]
22:39:46 <mjrosenb> xnil: $ binds tighter than anthing else, so that is parsed as getArgs >>= foldl (++) "" (map (++ " "))
22:40:23 <mjrosenb> xnil: also the libraries are awesome, you should use them
22:40:28 <xnil> ok, so this should all work but
22:40:42 <shachaf> No, it shouldn't work out, for the same reason I gave above.
22:40:45 <mjrosenb> > intercalate " " ["hello", "world", "!"]
22:40:46 <lambdabot>  "hello world !"
22:40:47 <xnil> getArgs >>= foldl (++) "" . map (++ " ")
22:40:52 <xnil> gives an IO error
22:41:07 <shachaf> You have to tell people the actual errors you're seeing. They can't guess.
22:41:08 <mjrosenb> xnil: an IO error or a type error with IO in it?
22:41:19 <mjrosenb> these are /very/ different.
22:41:24 <xnil> shachaf: well then how on earth do i get some kind of modifiable [String] out of IO [String]
22:41:26 <shachaf> xnil: In "getArgs >>= foo", foo must have type [String] -> IO b for some type b.
22:41:30 <xnil> mjrosenb: type error with IO in it
22:41:31 <shachaf> xnil: You can't. :-(
22:41:42 <xnil> wat.
22:42:00 <xnil> so i can't get any sort of string from the console
22:42:00 <mjrosenb> xnil: like I said, once you have a value in IO, it will forever be in IO
22:42:04 <xnil> which can be manipulated?
22:42:14 <xnil> i want to create at least a copy of the value in IO
22:42:14 <mjrosenb> xnil: you can, but any value that depends on it will be in IO.
22:42:15 <xnil> without IO
22:42:26 <xnil> oh dear lord
22:42:33 <xnil> is this as messy as it sounds
22:42:37 <mjrosenb> xnil: that is what IO is.
22:42:49 <xnil> agh why
22:42:52 <xnil> i know why but
22:43:01 <xnil> how do i do stuff to it
22:43:11 <mjrosenb> xnil: you stay in the IO monad.
22:43:23 <xnil> how do i add things in the IO monad
22:43:25 <mjrosenb> this is why the do syntactiv sugar is so nice
22:43:37 <xnil> how do i concatenate something to an IO String
22:43:46 <xnil> even if it means i get an IO String back
22:43:59 <vanila> xnil, you can only concatenate a String
22:44:02 <xnil> AGH
22:44:05 * xnil cries
22:44:09 <vanila> look here's an example
22:44:13 <vanila> readLine :: IO String
22:44:23 <vanila> this has type IO String, and it reads a line from the input
22:44:23 <mjrosenb> > let getArgs = return ["hello","world"] in do {args <- GetArgs; let a = intercalate " " args; putStrLn a; }
22:44:25 <lambdabot>  <hint>:1:104: parse error on input ‘;’
22:44:36 <vanila> reverse :: String -> String  is a pure function, nothing to do with IO
22:44:43 <chrisnc_> fmap ("foo" ++) readLine
22:44:53 <vanila> do l <- readLine ; print l   -- in this code, l :: String
22:44:55 <vanila> so you can do
22:45:03 <vanila> do l <- readLine ; print (reverse l)
22:46:16 * mjrosenb never quite got the hang of replacing \n with ;
22:47:08 <shachaf> mjrosenb: The ; is being associated with the let. Use do { let { ... }; ... }
22:47:22 <xnil> vanila: Couldn't match type `IO' with `[]'.
22:47:32 <xnil> in args <- getArgs
22:47:51 <vanila> well you are doing something a little differrent from what I wrote, before looking at what you're doing - did what I say make sense?
22:48:14 <xnil> yes
22:48:17 <vanila> ok !
22:48:24 <vanila> so can you paste your code to lpaste.net ?
22:48:30 <vanila> or if it's only a few lines, youcan post it here
22:48:50 <xnil> printArgs = do
22:48:55 <mjrosenb> xnil: also, really, it is *super* helpful when you paste all of your code, rather than the single line
22:48:58 <xnil>     args <- getArgs
22:49:08 <mjrosenb> and by paste, I mean pastebin.
22:49:23 <xnil>     (foldl (++) "" . map (++ " ")) args
22:49:26 <xnil> that's it
22:49:32 <vanila> that last line should be changed to this:
22:49:42 <vanila>     print ((foldl (++) "" . map (++ " ")) args)
22:49:53 <xnil> i want myGetArgs to have the type
22:49:56 <xnil> String
22:50:09 <xnil> oh
22:50:11 <xnil> :t print
22:50:11 <lambdabot> Show a => a -> IO ()
22:50:14 <mjrosenb> xnil: it will never have the type String.
22:50:16 <xnil> oh cool
22:50:33 <mjrosenb> xnil: it may have the type IO String, but never String.
22:50:37 <ReinH> (Is there a particular reason for avoiding intercalate here?)
22:51:01 <mjrosenb> xnil: you can also write a function, putStrLnIO :: IO String -> IO ()
22:51:21 <mjrosenb> ReinH: my guess would be that he doesn't know about it because it seems like this is the first time he's writing haskell.
22:51:36 <xnil> it's actually not
22:51:38 <mjrosenb> ReinH: but that isn't the biggest problem thusfar.
22:51:43 <xnil> it's my first time dealing with IO
22:52:04 <vanila> xnil, so hopefully with the change I suggested thecompiler accepts it? and does it work?
22:52:12 <xnil> vanila: now myGetArgs :: IO ()
22:52:19 <blackdog> g'day all. anyone know an on-disk key-value store with a similar interface to Data.HashMap.Strict?
22:52:24 <vanila> wait a sec, what is myGetArgs?
22:52:29 <vanila> I just saw printArgs
22:52:35 <xnil> i gravely apologize
22:52:40 <xnil> printArgs should be myGetArgs
22:52:44 <vanila> oh okay
22:53:07 <xnil> i'd honestly like to have myGetArgs :: IO String
22:53:16 <xnil> if that's what i think it is
22:53:16 <vanila> you can do that
22:53:22 <vanila> instead of 'print' use 'return'
22:53:25 <xnil> oh, cool
22:53:40 <blackdog> looking at berkeleydb but the haskell interface looks pretty brutal
22:53:42 <xnil> well
22:53:42 <xnil> wow
22:53:54 <vanila> xnil, then you an do myArgs <- myGetArgs ;  ... later on
22:54:07 <vanila> like printing it or wahtever
22:54:24 <xnil> i now know what i was doing wrong though, i was calling it with putStrLn myGetArgs instead of myGetArgs >>= putStrLn
22:54:43 <mjrosenb> xnil: isn't that what I said earlier?
22:54:46 <xnil> the concept i was missing was that you couldn't extract the String
22:54:55 <vanila> do r <- myGetArgs ; putStrLn r is syntactic sugar for myGetArgs >>= putStrLn
22:54:56 <ReinH> xnil: instead of thinking about how to get values "out of" IO, think about how to put the rest of your program into IO.
22:55:01 <Rotaerk> putStrLn =<< myGetArgs
22:55:21 <xnil> mjrosenb: yes, but usually a misunderstanding takes a few different times of restating things to get it figured out
22:55:32 <ReinH> do notation is useful for this because <- allows you to "extract"  a value within the context of the do block.
22:55:32 <EvanR> blackdog: acid-state?
22:55:38 <xnil> i was thinking about it the wrong way
22:55:44 <ReinH> but only within the do block
22:56:06 <vanila> xnil, it's a very different style of programming than other languages! It's called monadic style
22:56:26 <xnil> it just seems messy
22:56:35 <xnil> wait, never mind
22:56:39 <vanila> it's a necessity, because haskell is a pure language
22:56:44 <bitemyapp> xnil: it's just making what was always messy more explicit.
22:56:52 * hackagebot MonadCompose 0.5.0.0 - Methods for composing monads.  http://hackage.haskell.org/package/MonadCompose-0.5.0.0 (JamesCandy)
22:56:53 <xnil> you can still keep all the IO stuff sort of abstracted away from the pure stuff
22:56:56 <bitemyapp> xnil: there are ways to abstract and deal with it.
22:56:59 <xnil> and call the pure stuff inside do blocks
22:56:59 <bitemyapp> xnil: yes.
22:57:03 <xnil> wow, neat
22:57:03 <vanila> yeah
22:57:04 <bitemyapp> precisely!
22:57:14 <xnil> that's awesome
22:57:15 <vanila> it lets you 'tag' the side effects a piece of your program uses
22:57:37 <xnil> it took me way too long to realize what was going on here
22:57:44 * fread2282 is really bad at do notation
22:57:48 <ReinH> xnil: btw,
22:57:57 <Hijiri> there are other ways to do pure IO
22:57:58 <ReinH> > intercalate " " ["foo", "bar"]
22:57:59 <lambdabot>  "foo bar"
22:58:08 <xnil> ReinH: oh thanks
22:58:13 <Hijiri> like uniqueness types in clean or mercury
22:58:33 <EvanR> Hijiri: or Applicative ;)
22:59:08 <ReinH> EvanR: applicate doesn't let you do much of anything interesting though
22:59:21 <EvanR> good
22:59:23 <EvanR> hehe
22:59:29 <ReinH> *applicative
22:59:46 <xnil> so... instead of using a do block for myGetArgs, why can't i just do `myGetArgs >>= intercalate " "'
22:59:58 <EvanR> i like more options with a variety of restrictive implications
23:00:06 <xnil> oops
23:00:07 <vanila> xnil, you could do myGetArgs >>= \r -> print (intercalate " " r)
23:00:18 <vanila> or
23:00:22 <vanila> myGetArgs >>= \r -> return (intercalate " " r)
23:00:25 <xnil> `myGetArgs = getArgs >>= intercalate " "'
23:00:29 <xnil> that's what i meant
23:00:34 <homovitruvius> if one needs to split a (possibly lazy) ByteString at occurrences of a regex, where should he look? same for removing text matching a regex
23:00:44 <vanila> but you need something like print or return, otherwise you're mixing up a pure function with a monadic function
23:00:50 <vanila> and that's a type error so the compiler wont accept it
23:01:40 <xnil> but i thought >>= was sort of like anonymously binding, circumventing the need for <-
23:01:52 * hackagebot hwsl2 0.1.1.0 - Hashing with SL2  http://hackage.haskell.org/package/hwsl2-0.1.1.0 (srijs)
23:01:57 <xnil> wait...
23:01:57 <ReinH> xnil: that won't work
23:02:11 <xnil> can't you just do
23:02:14 <ReinH> >>= works with functions of type a -> m b for some Monad m
23:02:21 <ReinH> but IO is also a Functor
23:02:23 <ReinH> :t fmap
23:02:24 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:02:36 <ReinH> specialized to IO, that's (a -> b) -> IO a -> IO b
23:02:39 <bitemyapp> homovitruvius: http://hackage.haskell.org/package/regex-applicative-0.3.1/docs/Text-Regex-Applicative.html
23:02:40 <xnil> myGetArgs = getArgs >>= return . intercalate " "
23:02:47 <ReinH> so fmap (intercalate " ") getArgs
23:03:12 <ReinH> xnil: and one of the Monad laws is that fmap f x = x >>= return . f :)
23:03:38 * xnil is a tad bit confus
23:04:03 <xnil> gimme a sec to read fmap's type
23:04:22 <xnil> oh
23:04:30 <ReinH> Compare to (>>=)
23:04:33 <xnil> OHHHH
23:04:33 <ReinH> :t (>>=)
23:04:34 <lambdabot> Monad m => m a -> (a -> m b) -> m b
23:04:47 <xnil> sorry i was reading that = wrong
23:04:51 <ReinH> it's easier to see if you use the version of >>= that goes the other way
23:04:54 <ReinH> :t (=<<)
23:04:55 <lambdabot> Monad m => (a -> m b) -> m a -> m b
23:05:03 <xnil> (fmap f x = x) >>= (return . f)
23:05:06 <ReinH> fmap works on functions of type (a -> b), >>= works on functions of type (a -> m b)
23:05:14 <xnil> i was code-dyslexia-ing
23:05:26 <ReinH> xnil: no, it's (fmap f x) = (x >>= return . f)
23:05:34 <xnil> yup
23:05:36 <xnil> gotcha
23:05:39 <xnil> that's really neat
23:05:43 <xnil> fmap solves my problems
23:06:08 <ReinH> basically, with >>= you need to return an (m b), but f only gives you a b
23:06:12 <ReinH> so you use return :: b -> m b
23:06:24 <ReinH> sorry, "f only gives you a `b'"
23:06:42 <xnil> the type definition gives me what i need :^)
23:06:45 <xnil> thank you!
23:06:48 <ReinH> np :)
23:06:54 <xnil> where's intercalate defined?
23:06:57 <mjrosenb> if I have a Constructor with field constructors that aren't visible, can I still use them?
23:07:00 <ReinH> @hoogle intercalate
23:07:02 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
23:07:02 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
23:07:02 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
23:07:06 <ReinH> This one is Data.List
23:07:08 <xnil> thanks
23:07:42 <ReinH> mjrosenb: if the data constructor is exported, you can still pattern match, but you can't use field accessors that aren't exported
23:08:07 <abhillman> Is there a better way to write this function? https://gist.github.com/anonymous/fe8d130e3f848d6dfb5c
23:08:30 <mjrosenb> oohh, defaultWindow, that sounds useful.
23:08:47 <xnil> this is fantastic guys it works perfectly
23:08:58 <abhillman> The idea is to take an index and a list and to return the list without the element at the given index
23:08:59 <xnil> i was doing this to better understand IO, and i think i really got it now
23:09:43 <ReinH> abhillman: without i = map snd . filter ((== i) . fst) . zip [0..]
23:09:59 <ReinH> er, filter ((/= i) . fst)
23:10:07 <shachaf> ReinH: That won't share the tail.
23:10:19 <ReinH> shachaf: :(
23:10:44 <mjrosenb> ReinH: ahh, it was exported, but those guys are qualified
23:10:54 <mjrosenb> because I qualified the whole module.
23:11:15 <ReinH> shachaf: er, why not?
23:11:53 * hackagebot lbfgs 0.0.5 - L-BFGS optimization  http://hackage.haskell.org/package/lbfgs-0.0.5 (DanielDeKok)
23:12:15 <vanila> without 0 (x:xs) = xs ; without i (x:xs) = x : without (i-1) xs
23:12:30 <ReinH> vanila: nice
23:12:52 <vanila> ty :)
23:13:06 <shachaf> ReinH: Because (map snd . filter (\_ -> True) . zip [n..]) xs isn't xs
23:13:27 <chrisnc_> :t fmap (intercalate " ") getArgs
23:13:27 <abhillman> Reinh: What do you think of this? https://gist.github.com/anonymous/305d86737df3b4cb53cf
23:13:28 <lambdabot> Not in scope: ‘getArgs’
23:13:36 <ReinH> shachaf: hmm
23:13:41 <ReinH> shachaf: fair enough
23:13:49 <ReinH> vanila's is better anyway
23:14:00 <ReinH> abhillman: ^
23:14:18 <vanila> take (n) xs ++ drop (n+1) xs  is good, but if n is huge it will have to walk down n steps of the three times
23:14:21 <shachaf> It's like map id xs. Maybe you don't care too much, but you probably do if you're doing a whole bunch of withouts.
23:14:29 <vanila> this is not really important, but worth pointing out
23:14:32 <ReinH> shachaf: makes sense
23:14:52 <vanila> of the list *
23:14:52 <ReinH> shachaf: and it doesn't get fused?
23:15:00 <abhillman> vanilla: Yea, that is pretty nice
23:15:02 <shachaf> Get fused to what?
23:15:16 <shachaf> filter (\_ -> True) xs isn't xs either.
23:15:30 <shachaf> It'll build a whole new list, equal to the old list.
23:17:16 <ReinH> shachaf: oh right, there are no fusion rules for filter.
23:17:27 <shachaf> What sort of fusion would you expect here?
23:17:46 <ReinH> shachaf: foldr rules
23:17:52 <shachaf> You're asking GHC to recognize that the predicate is true everywhere past some point.
23:18:00 <shachaf> That's way beyond the scope of fusion.
23:18:16 <ReinH> Oh, there are rules for filter. Anyway.
23:18:31 <chrisnc_> would it not be able to fuse the predicate with subsequent ops?
23:19:20 <shachaf> Fuse what?
23:19:36 <ReinH> shachaf: I was trying to see if allocations of intermediate values could be optimized awway
23:19:37 <shachaf> Fusion turns code into other code. What are you thinking it'll turn the filter into?
23:20:02 <shachaf> OK, you mean, if you aren't starting with a list in the first place, but with a producer.
23:20:22 <shachaf> OK, that could work, and in that case it can be better than the explicit recursion code, which won't get fused at all.
23:20:45 <chrisnc_> yes, what ReinH said... if you filter and then map something else, it's reasonable that fusion would prevent an intermediate list allocation
23:22:17 <chrisnc_> is a lazy list different from a producer in that terminology?
23:25:53 <shachaf> Yes.
23:26:15 <shachaf> https://downloads.haskell.org/~ghc/7.0.1/docs/html/users_guide/rewrite-rules.html
23:26:54 * hackagebot hwsl2 0.1.1.1 - Hashing with SL2  http://hackage.haskell.org/package/hwsl2-0.1.1.1 (srijs)
23:30:59 <ReinH> shlevy_: so zip is a good producer and map and filter are both good consumers
23:31:18 <ReinH> (and filter is also a good producer)
23:31:41 <ReinH> so my understanding was be that this would be deforested via list fusion
23:31:54 * hackagebot hwsl2 0.1.1.2 - Hashing with SL2  http://hackage.haskell.org/package/hwsl2-0.1.1.2 (srijs)
23:31:58 <chrisnc_> it appears most of the "good producers" are various ways of forming a lazy list, and it lists filter among them
23:32:07 <shachaf> ReinH: I'm not talking about zip's list, I'm talking about the original list.
23:32:24 <ReinH> shachaf: right, originally, and I understand that
23:32:35 <ReinH> but we went through a period where you didn't seem to understand what I meant by fusion
23:32:40 <ReinH> which I found surprising
23:32:52 <ReinH> since you're linking me to the documentation I had in mind when I mentioned it
23:33:07 <shachaf> I was linking chrisnc_.
23:33:33 <shachaf> I know what fusion is. But it won't help you as far as sharing the list goes, if you're dealing with an actual list.
23:35:02 <shachaf> It could help you to some degree or another if you're dealing with a list that's being produced by a producer in the sense above.
23:35:05 <ReinH> Of course you do, which is why I was confused. But never mind.
23:36:29 <ReinH> Right, but otherwise there's nothing for zip to fuse wth "on that side". Makes sense.
23:37:52 <funfunctor> hi
23:38:05 <EvanR> hi
23:38:15 <funfunctor> hows things/
23:39:29 <funfunctor> EvanR: any idea why this type-checks but does not run? http://lpaste.net/120488
23:39:59 <EvanR> not enough information
23:40:35 <funfunctor> EvanR: oh its self contained, it should run, but the talk IO action talks about not having a Show instance..
23:40:49 <EvanR> wheres main?
23:41:00 <shachaf> funfunctor: It's not nice to say hi, wait for someone to respond, and then put them on the hook for answering your question. If you have a question that isn't specifically for one person you should ask the channel.
23:41:05 <funfunctor> No instance for (Show (UDPSocket -> IO ()))
23:41:42 <EvanR> ah so it doesnt type check
23:42:16 <dicker> p
23:42:21 <funfunctor> it type-checks on load but not running it
23:42:34 <bkaes> So you try to use it in GHCi?
23:42:42 <funfunctor> yep
23:42:53 <EvanR> are you just typing talk
23:42:53 <dicker> fuck	fuck	fuck
23:42:53 <dicker> 3	damn	damn	damn
23:42:53 <dicker> 4	bitch	bitch	bitch
23:42:53 <dicker> 5	crap	crap	crap
23:42:53 <dicker> 6	piss	dick	piss
23:42:54 <dicker> 7	dick	piss	darn
23:42:54 <dicker> 8	darn	pussy	dick
23:42:55 <dicker> 9	cock	fag	cock
23:42:55 <dicker> 10	pussy	asshole	asshole
23:42:56 <dicker> 11	asshole	cock	pussy
23:42:56 <dicker> 12	fag	bastard	fag
23:42:57 <dicker> 13	bastard	darn	bastard
23:43:01 --- mode: ChanServ set +o johnw
23:43:01 --- mode: johnw set +b *!dicker@c-71-58-196-93.hsd1.pa.comcast.net
23:43:01 --- kick: dicker was kicked by johnw (Kicked)
23:43:01 --- mode: johnw set -o johnw
23:43:24 <funfunctor> johnw: thx
23:44:10 <ReinH> "it type-checks on load but not running it"... that seems unlikely. How are you running it?
23:44:55 <bkaes> Hm, I think my message didn't get pass the anti-flood: Could you provide the complete line you use in GHCi?
23:44:57 <ReinH> I like that "darn" is included.
23:45:04 <funfunctor> ReinH: just invocaking the talk function
23:45:10 -ChanServ(ChanServ@services.)- edwardk set flags +S on shapr
23:45:43 <funfunctor> ReinH: its reduced out something larger, you should be able to load it locally and try
23:46:10 <EvanR> funfunctor: whats the type of the expression you type into ghci, that is, what does putting :t in front of it say?
23:46:13 <bkaes> funfunctor: Well, you _do_ use a socket for `talk`, do you?
23:46:43 <EvanR> yeah the error suggests you didnt pass in the UDP socket
23:46:52 <funfunctor> wait is talk already a function
23:46:54 <funfunctor> :t talk
23:46:55 <lambdabot> Not in scope: ‘talk’
23:47:00 <funfunctor> oh good
23:47:21 <ReinH> talk requires an argument
23:47:54 <jle`> ha ha
23:47:57 <funfunctor> EvanR: line 83 should construct the socket and put it into the StateT monad
23:48:13 <EvanR> are you trying to run this in ghci?
23:48:19 <funfunctor> yep
23:48:32 <jle`> ReinH: how pessimistic :(
23:48:32 <EvanR> whats the input line?
23:48:33 <ReinH> funfunctor: that may be so, but talk still requires an argument
23:48:43 <bkaes> funfunctor: Could you provide the actual GHCi session, including all commands that lead to the error (shrinked down if possible).
23:48:58 <funfunctor> oh wait, why does talk need a UDPSocket?
23:49:05 <EvanR> look at the type
23:49:09 <bkaes> Line 61.
23:49:19 <funfunctor> yea I wrote that :p
23:49:25 <ReinH> funfunctor: Because that's the type it was given.
23:49:45 <EvanR> on 62 you didnt list a variable, but its still well typed
23:49:47 <funfunctor> but what needs that, why did the type infer that
23:50:00 <ReinH> It has an explicit type annotation.
23:50:01 <funfunctor> eta reduced from where though?
23:51:13 <EvanR> why does it have that type? because you wrote it in. why did you write it in? not sure
23:51:17 <ReinH> Maybe you should fix the type annotation.
23:51:35 <ReinH> I'm actually surprised that it type-checks at all
23:51:37 <bkaes> `withTRXManager` requires an UDPSocket, so `talk` should use a `UDPSocket`. See l61, 62 and 68.
23:52:14 <orzo> ReinH: that vim plugin for stylish-haskell causes my REDO not to work after i save, which is apparently a problem for me
23:52:26 <ReinH> orzo: k
23:52:26 <EvanR> talk gets the socket from the context so it doesnt need one passed in
23:53:21 <ReinH> well it would if withTRXManager weren't also broken
23:53:53 <funfunctor> yea something is up with withTRXManager
23:54:14 <ReinH> it's never passed a socket
23:54:25 <ReinH> so it's being used  like withTRXManager :: HostName -> ServiceName -> TRXManager a -> (UDPSocket -> IO ())
23:54:43 <bramgg> Is there a built in reverse of take? Not drop, but something that takes the first n elements from the end of a list to the beginning.
23:54:56 <bramgg> I know one can use drop to achieve this, but I'm wondering if there's something simpler
23:55:06 <ReinH> bramgg: nothing built in
23:55:15 <bramgg> alright, thanks
23:56:07 <ReinH> runTRXManager is similarly broken
23:56:21 <ReinH> bracket is broken in a totally different way
23:57:08 <funfunctor> i'm confused
23:57:29 <funfunctor> where the genisis of the bad type-signature is so I can work my way back outwards
23:57:41 <ReinH> runTRXManager, it looks like
23:57:48 <funfunctor> openTRXManager and closeTRXManager seem to have the right signature
23:58:44 <funfunctor> ah
23:59:02 <funfunctor> oh, yea a default empty UDPSocket should be passed there
23:59:23 <funfunctor> because openTRXManager runs to fill it in right
