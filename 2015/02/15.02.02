00:14:29 <lpaste> Lokathor pasted “not in scope: 'client'” at http://lpaste.net/119793
00:14:43 <Lokathor> why does "client" fall out of scope in the where block?
00:15:17 <HeladoDeBrownie> Lokathor, it's only in scope within the do block from the point it's defined on.
00:15:43 <Lokathor> hmm
00:15:48 <HeladoDeBrownie> everything in the where block is in scope in the do block, but not vice versa.
00:16:04 <Lokathor> so i move it into the where block?
00:16:47 <HeladoDeBrownie> depends; it looks like you'll have to explicitly pass something that you're not currently trying to explicitly pass, in any case
00:16:52 <Lokathor> now it says that conn and message aren't in scope >_<
00:17:00 <HeladoDeBrownie> either that or move what's declared in the where block into a let
00:17:36 <HeladoDeBrownie> it seems like the least amount of change to get what you want would be to define disconnect using let at the same time or just after client
00:18:00 <lpaste> Lokathor pasted “client moved into where” at http://lpaste.net/119794
00:18:10 <Lokathor> like that it says that message and conn aren't in scope now
00:18:18 <HeladoDeBrownie> well, client's definition depends on yet other things only defined within the do block…
00:20:02 <Lokathor> i think i'll just move client into a let above, and then make disconnect its own function
00:20:10 <Lokathor> and eliminate the where entirely
00:29:03 <Lokathor> it works now
00:30:02 <Lokathor> it also seems that you can't Text.append an overloaded String literal and a ByteString.Lazy, but you can `mappend` between the two and haskell figures it outsomehow
00:30:22 <Lokathor> typeclass magic i expect
00:30:37 * hackagebot debian-build 0.6.0.0 - Debian package build sequence tools  http://hackage.haskell.org/package/debian-build-0.6.0.0 (KeiHibino)
00:31:58 <merijn> Lokathor: No, you can't
00:32:24 <Lokathor> you mean the former or the latter?
00:32:34 <Lokathor> becaues GHC says the latter works...
00:32:40 <merijn> Lokathor: If you're using mappend it's just inferring your OverloadedString literal to be ByteString.Lazy
00:32:49 <merijn> Lokathor: Silently truncating all your data in there to be ascii
00:33:09 <Lokathor> ahh, well close enough then, because it is ascii
00:33:25 <merijn> ಠ_ಠ
00:33:43 <merijn> You should always use Text.Encoding to go from Text to ByteString and vice versa
00:34:18 <Lokathor> ah, and sendTextData from websockets is letting me send an a
00:34:29 <merijn> "oh it's just ascii" is a recipe for misery at an undefined time in the future
00:35:45 <Lokathor> well, aeson turns an Object into a Bytestring.Lazy, but I want to send that out with sendTextData, but I also need to put a prefix on it.. so BS.append i guess
00:36:59 <Lokathor> still, it is an ascii string literal being sent to a client that only reads ascii anyway
00:37:12 <merijn> Famous last words :)
00:37:21 <Lokathor> well i'm writing the client too in this case :P
00:37:33 <Lokathor> rather, another project member is who's even less careful about data than i am
00:37:40 <merijn> I'm a bit worried that a websockets library does not provide a send primitve for ByteString
00:38:21 <Lokathor> it provides, sendTextData :: WebSocketsData a => Connection -> a -> IO ()
00:39:16 <Lokathor> and it has instances for both types of ByteString and both types of Text
00:39:25 <merijn> ah
00:40:06 <Lokathor> though the doc says it's all ByteString natively under the hood
00:40:30 <Lokathor> perhaps I should work to eliminate Text from my program if I can
00:46:44 <merijn> Lokathor: "It depends"
00:46:58 <merijn> If you have textual data, it should be Text and encoded when going to the network
00:47:20 <merijn> If it's NOT textual data (i.e., encoded JSON or whatever) then it should be ByteString
00:48:02 <Lokathor> it's coming in as ByteString, and sometimes being stored as JSON and sometimes needing to be parsed as though it were text.
00:50:38 * hackagebot elevator 0.2.1 - Immediately lifts to a desired level  http://hackage.haskell.org/package/elevator-0.2.1 (FumiakiKinoshita)
00:50:46 <merijn> Then it sounds like you have a Web2.0 engineering problem :p
00:51:29 <Lokathor> now why is JSON bytestring exactly?
00:51:39 <ahihi> any recommendations for an audio library that can play back e.g. ogg vorbis or flac, and provides accurate timing information (for syncing visuals to the audio)?
00:54:31 <merijn> Lokathor: Because the web is a fucking mess and afaik there's no ACTUAL standard for encoding
00:54:41 <merijn> Lokathor: It's just that everyone kinda sorta assumes UTF-8
00:54:41 <Lokathor> ahh
00:55:00 <merijn> But I don't think there's any spec that says it has to be
00:55:05 <Lokathor> perhaps i can tell the JS guy to attempt to enforce such a thing somehow
00:55:09 <Lokathor> and make him look it up
00:55:38 <Lokathor> well that is enough for tonight
00:55:46 <Lokathor> thanks for the guidance merijn
00:55:49 <merijn> This is the reason why RoR uses a utf-8 checkmark in the URL for utf-8 form submissions. Internet Explorer defaults to latin1 unless there's a character that it can't encode as latin1 on the page
00:58:22 <jle`> haha
00:59:28 <merijn> jle`: The worst part is that that's true and not even made up by me :\
00:59:44 <merijn> Try searching github and check the URL of the results page
01:00:07 <Lokathor> :(
01:01:04 <jle`> the web is a crazy place
01:01:33 <merijn> The web is what you get what JS devs try to build an ecosystem >.>
01:01:42 <jle`> <.<
01:01:49 <merijn> Well, let's not place all the blame on them. There's also the PHP people
01:02:17 <jle`> the web is what you get when { x | x } ecosystem
01:02:25 <jle`> *build an ecosystem
01:02:30 <jle`> that was supposed to be a set comprehension
01:02:48 <jle`> i probably could have framed that better
01:03:00 <Zemyla> jle`: Well, it sure wasn't comprehensible! Dohoho!
01:03:04 <jle`> ba dum psh
01:18:19 <hexagonest> hey how would I solve this trivial problem using haskell?
01:18:20 <hexagonest> train A leaves the station. train A is going 55 km/h. 15 minutes later, train B leaves the station. This train is going 65km/h. How long will it take for train B to pass train A?
01:20:19 <jle`> heh
01:20:29 <jle`> well you could solve out teh math and use haskell as a calculator
01:20:31 <jle`> you could also simulate it
01:21:30 <jle`> @let times = [0,0.05..] -- time in hours
01:21:33 <lambdabot>  Defined.
01:21:58 <hexagonest> Oh jeez, isn't there a more efficient way to do it?
01:22:08 <jle`> @let apos = map (* 55) times
01:22:10 <lambdabot>  Defined.
01:22:13 <hexagonest> @\x y = y + x
01:22:13 <lambdabot> Maybe you meant: wn v thx rc pl id do bf @ ? .
01:22:32 <hexagonest> lol
01:22:57 <jle`> @let bpos = replicate 5 0 ++ map (* 65) times
01:22:59 <lambdabot>  Defined.
01:24:21 <jle`> > dropWhile isNothing $ zipWith3 (\t a b | b <= a = Nothing | otherwise = Just t ) times apos bpos
01:24:23 <lambdabot>  <hint>:1:40: parse error on input ‘|’
01:24:47 <jle`> > dropWhile isNothing $ zipWith3 (\t a b -> t <$ guard (b >= a)) times apos bpos
01:24:49 <lambdabot>  [Just 0.0,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,No...
01:24:54 <jle`> huh.
01:25:17 <jle`> oh
01:25:21 <jle`> > dropWhile isNothing $ zipWith3 (\t a b -> t <$ guard (b > a)) times apos bpos
01:25:22 <lambdabot>  [Just 1.650000000000001,Just 1.700000000000001,Just 1.750000000000001,Just 1...
01:25:27 <jle`> there, at 1.65 hours
01:25:40 <jle`> +/- 0.025 hrs
01:26:03 <jle`> the more efficient way is to just do the math out manually :P
01:26:23 <startling> isn't there some symbolic algebra thing for haskell?
01:26:36 <merijn> The most efficient way is to bully someone else into doing the math for you
01:28:13 <nshepperd> "Haskell is useless, it can't even do my homework for me!"
01:29:07 <startling> jle`, I think that's wrong
01:29:11 <mjrosenb> aargh, noooo, the thing I didn't want to happen happened :-(
01:29:12 <startling> I don't know why though
01:29:26 <jle`> i think there might be some floating point errors possible
01:30:11 <jle`> > catMaybes $ zipWith3 (\t a b -> t <$ guard (abs (b - a) <= 0.00001)) times apos bpos
01:30:14 <lambdabot>  mueval-core: Time limit exceeded
01:30:20 <jle`> really?
01:30:25 <jle`> oh
01:30:36 <startling> jle`, 15 minutes isn't 0.25 of an hour
01:30:56 <startling> wait
01:31:01 <startling> <- needs to sleep
01:31:48 <jle`> > catMaybes $ zipWith3 (\t a b -> t <$ guard ((b - a) > 0.001)) times apos bpos
01:31:49 <lambdabot>  [1.650000000000001,1.700000000000001,1.750000000000001,1.8000000000000012,1....
01:32:02 <jle`> um
01:32:05 <jle`> > catMaybes $ zipWith3 (\t a b -> t <$ guard ((b - a) > -0.001)) times apos bpos
01:32:07 <lambdabot>  [0.0,1.650000000000001,1.700000000000001,1.750000000000001,1.800000000000001...
01:32:12 <jle`> yeah i think that's right
01:32:29 <abayley> hi. trying to write a function: [IO (Either a b)] -> IO [Either a b] using monad transformers (ErrorT) but getting stuck
01:32:44 <jle`> abayley: what do you want your function to do?
01:33:01 <jle`> do you want to turn a list of IO actions returning Eithers into an IO action returning a list of eithers?
01:33:05 <jle`> if so, you can just use `sequence`
01:33:18 <jle`> sequence :: [IO a] -> IO [a]
01:33:21 <abayley> like sequence (execute a list of IO actions) but halt on the first Left
01:33:29 <jle`> ah
01:33:54 <abayley> I have a hand-rolled implementation but it seems that there should be a way with an Either monad
01:33:55 <jle`> do you want all of the values so far to be returned too?
01:34:04 <jle`> you actually can't really even do this with Either
01:34:10 <jle`> er, the Either monad instance
01:34:28 <abayley> Preferably. I'd settle for a list of Rights or a single Left tho.
01:34:31 <jle`> Either monad instance has semantics that once you get to a left, your entire thing is a left
01:34:40 <jle`> you lose all the rights
01:34:52 <jle`> this sounds like untilM
01:34:53 <merijn> @hackage monad-loops -- abayley
01:34:53 <lambdabot> http://hackage.haskell.org/package/monad-loops -- abayley
01:35:23 <jameseb> abayley: takeWhile and sequence might be the best way to do it
01:35:24 <merijn> If nothing in there helps you'll have to handroll it
01:35:29 <merijn> No
01:35:32 <merijn> sequence won't work
01:35:41 <merijn> Sequence won't return until ALL IO actions run
01:35:45 <merijn> It can't return prematurely
01:35:57 <jameseb> merijn: ah yes, that's true
01:36:15 <jameseb> takeWhile wouldn't work properly with monads
01:36:15 <startling> jle`: oh, right, the answer isn't a multiple of 0.05
01:36:28 <jle`> yes that too ;)
01:36:52 <jle`> with FRP you can get arbitrary precision answers with only tweaking your simulation timestep
01:37:11 <abayley> I'd like to avoid non-HP code. Gabriel Gonzalez published errors package,which looks ideal, but I want to minimise non-HP dependencies.
01:37:35 <jle`> any reason why?
01:37:41 <merijn> abayley: Then you'll have to handwrite it
01:37:59 <abayley> I asked same q over a week ago and quchen suggested foldM, but I cannot see how to make it work.
01:38:03 <jle`> or you can use foldM, heh.
01:38:11 <jle`> ah yes. foldM would work
01:38:43 <jle`> if you want to only keep the Right's, you can just return a list of [a]'s, right?
01:39:26 <jle`> foldM :: ([a] -> IO (Either a b) -> IO [a]) -> [a] -> [IO (Either a b)] -> IO [a]
01:39:28 <jle`> does that help? :)
01:39:51 <zipper> Am I mistaken or does Yesod seem to have a few inbuilt functions to handle articles such as `articleTitle`?
01:40:15 <abayley> jle: yes, that would also work. I can get this by running sequence of the result: IO [Either a b]
01:40:29 <jle`> sequence won't work
01:40:43 <jle`> also if you sequence to get that, you already execute all of the IO's
01:40:47 <jle`> even after the first Left
01:41:14 <jle`> as i understand it, you want to conditionally sequence and go on only if you haven't seen a Left yet?
01:42:22 <abayley> jle: yes. would it help if I showed my hand-rolled one? does code paste well here?
01:42:29 <nshepperd> this is almost unfoldM, isn't it?
01:42:31 <jle`> @where paste
01:42:31 <lambdabot> Haskell pastebin: http://lpaste.net/
01:42:39 <jle`> the foldM solution works pretty naturally
01:42:44 <nshepperd> or, oh not
01:42:52 <jle`> see the type signature i used earlier
01:43:27 <jle`> your ([a] -> IO (Either a) -> IO [a]) takes in the current ist of a's (Rights), and the IO action to produce the next Either
01:43:31 <jle`> *Either a b
01:43:39 <jle`> oh
01:43:54 <jle`> i was going to say, if it's a Right, then append it to the list; if ti's a left, then don't, but...
01:43:59 <jle`> i guess this will filter everything
01:44:02 <jle`> and not stop at the first Left
01:44:16 <jle`> you would need to add another bit to the state to do that, heh.
01:44:19 <jle`> does IO have an Alternative instance?
01:44:33 <abayley> http://lpaste.net/119795
01:45:51 <jle`> as far as package goes, monad-loops is pretty low-dependency i think
01:46:07 <jle`> but if you don't want to import it, then you might have to just hand-roll it, or write a kind of ugly foldM
01:47:02 <abayley> jle: so I have a hand-rolled sequenceE, as you see, but I feel there's a better way.
01:47:17 <jle`> a better way to write a hand-rolled one?
01:47:24 <jle`> or a way using a higher-order function?
01:47:35 <abayley> i.e. can I golf it down to a runErrorT and ...
01:47:57 <abayley> jle: HOF
01:48:52 <jle`> I don't think any monad instances are going to help you here, because of how Either's monad semantics work
01:49:58 <jle`> hm
01:50:08 <jle`> if not the monad instance, you might be able to use an Alternative instance
01:50:23 <yokumm> help
01:50:25 <yokumm> help
01:50:27 <yokumm> :(
01:50:27 <yokumm> :(
01:50:57 <abayley> not even ErrorT? It seems so close...
01:51:32 <jle`> ErrorT's monad/applicative instances model short-circuiting behavior
01:51:38 <jle`> if anything is Left, *everyhting* is a Left
01:51:47 <abayley> jle: e.g. ErrorT a IO [b]
01:52:05 <jle`> yes, but that only gives you Right [b] or Left a
01:52:06 <abayley> jle: it's OK to collapse to a Left
01:52:12 <jle`> and you have no Rights?
01:52:21 <ClaudiusMaximus> no Alternative IO -- the problem seems to be defining an  i :: IO a  that acts as a unit for all a
01:52:25 <abayley> that's fine - it's the error state
01:52:29 <jle`> oh
01:52:41 <jle`> so you don't mind throwing away the Lefts?
01:52:44 <jle`> er
01:52:46 <jle`> the Rights?
01:52:56 <abayley> jle: yep, that's fine.
01:52:58 <jle`> then yeah, sequence works
01:53:22 <jle`> sequence :: [ErrorT a IO b] -> ErrorT a IO [b]
01:53:37 <jle`> which, if we unwrap, we get IO (Either a [b])
01:53:49 <abayley> jle: I want it to stop when the first Left appears. Plain sequence won't do that; it runs all the actions.
01:53:51 <jle`> the IO action will be `Left a`, with the `a` of the first encountered Left
01:54:00 <abayley> jle: OK, I'll test that.
01:54:03 <jle`> no, sequence on ErrorT should stop at the first left
01:54:15 <jle`> if there are no Lefts, it'll go through the end and return Right [a]
01:54:30 <jle`> remember that sequence's behavior depends on the behavior of (>>)
01:54:40 <jle`> for IO, >> just does all actions one after the other
01:54:49 <jle`> for EitherT, >> only does the next action if the result is Right
01:57:19 <jle`> that's the trick, you know :)  IO (Either a b) and EitherT a IO b have the exact same type, underneath.  the latter is just a newtype wrapper over the other.  the difference is their Monad, Applicative istances, and the behavior of >>, etc.
01:57:50 <jle`> keep on mind that with ErrorT a m b, if you use the Monad instance, `a` needs an Error constraint
01:58:21 <jle`> luckily for you, you only need the Applicative instance here
01:58:38 <jle`> so you can use `sequenceA` from Data.Traversable
02:00:54 <ClaudiusMaximus> ahh, there is   instance (Monad m, Monoid e) => Alternative (EitherT e m)   -- whether it is useful here i don't know
02:01:23 <nshepperd> evalSupplyT (unfoldM supply) . (++[Nothing]) . fmap (fmap rightToMaybe)
02:02:47 <nshepperd> oh, you solved it already
02:02:49 <abayley> jle`: lost me a bit. My Error type is just String, which is an instance of Error, but then I must specialise my function to IO (Either String b), right?
02:03:18 <jle`> abayley: you wrap your IO (Either String b) into a newype wrapper
02:03:21 <jle`> er, the newtype wrapper
02:03:34 <jle`> ErrorT :: IO (Either String b) -> EitherT String IO b
02:03:34 <nshepperd> I think ExceptT is what you're meant to use these days
02:03:40 <abayley> jle`: or are you saying sequenceA will suffice?
02:04:02 <jle`> abayley: ah yes.  i'm saying that if your `e` does not have a Error instance, you can use sequenceA
02:04:08 <jle`> which doesn't require an Error e constraint
02:04:18 <jle`> ah yes if your mtl has ExceptT, then that is preferred these days
02:05:16 <jle`> ExceptT is EitherT except in mtl
02:05:18 <jle`> it's a long story
02:05:20 <jle`> :)
02:05:32 <abayley> jle`: if I use sequenceE = Traversable.sequenceA, I get this type error: expected: [IO (Either a b)] -> IO (Either a [b])
02:05:50 <jle`> can you post your code?
02:06:08 <jle`> maybe your type signature is still there
02:06:08 <abayley> jle`: actual: [IO (Either a b)] -> IO [Either a b]
02:06:34 <jle`> yeah you have to use it on an ErrorT e IO b
02:06:43 <jle`> which means you have to map the newtype wrapper
02:07:05 <jle`> runErrorT . sequenceA . map ErrorT
02:07:19 <jle`> or `coerce`
02:08:14 <jle`> are you comfortable with those newtype wrappers that give you alternative instances?
02:08:19 <jle`> > mconcat . map Sum $ [1..10]
02:08:21 <lambdabot>  Sum {getSum = 55}
02:08:27 <jle`> > mconcat . map Product $ [1..10]
02:08:28 <lambdabot>  Product {getProduct = 3628800}
02:08:35 <jle`> > getProduct . mconcat . map Product $ [1..10]
02:08:36 <lambdabot>  3628800
02:08:56 <jle`> it's the same deal here....Product changes the Monoid instance so that mconcat will do what we want.  ErrorT changes the Applicative instance so that sequenceA will do what we want
02:09:05 <abayley> jle`: ok, so this: Error.runErrorT . map Error.ErrorT gives type error: expected: [ErrorT a IO b] -> ErrorT a IO [b]
02:09:36 <jle`> can you post the full error?
02:09:39 <jle`> and code?
02:10:00 <abayley> jle`: actual: IO (Either a b) -> [ErrorT a IO b]
02:10:11 <abayley> jle`: another lpaste?
02:10:19 <jle`> you forgot the sequence
02:10:28 <jle`> in the mimddle
02:10:37 <jle`> runErrorT . sequenceA . map ErrorT
02:11:41 <abayley> jle`: oh sweet, that works. thanks.
02:11:47 <jle`> :)
02:12:00 <jle`> unfortunately most of that is just line noise, isn't it
02:12:15 <jle`> > getSum . mconcat . map Sum $ [1..10]
02:12:17 <lambdabot>  55
02:12:55 <jle`> > getAny . mconcat . map Any $ [True, False, True]
02:12:56 <lambdabot>  True
02:13:07 <jle`> i think you can use coerce to make it a little less noisy
02:13:10 <jtanguy> > ala Sum foldMap [1..10]
02:13:11 <lambdabot>  55
02:13:14 <abayley> jle`: now I'm wondering, is there a systematic way I can golf my hand-rolled recursion into a HOF?
02:13:28 <jle`> coerce . sequenceA . coerce
02:13:40 <jle`> well, your hand rolled recursion isn't *quiiite* the same thing
02:13:54 <jle`> if you decided to hand-roll the behavior we eventually got, then we might be able to...but...
02:14:07 <jle`> the biggest hint that a sequence was what you wanted was in the type signature
02:14:50 <jle`> usually we recognize these types of HOF's in haskell by the type signature we want
02:15:08 <jle`> instead of starting with verbose code and shortening it systematically
02:15:55 <jle`> we can do that, and you probably could shorten your code down golf-style systematically...but i think you'd have a non-systematic jump to sequence at some point
02:16:22 <jle`> learning to recognize "shapes" of type signatures is a haskell skill we develop :)
02:17:09 <jle`> fwiw, this pattern is commonly recognized as the "Traversable" pattern.  if you want to turn an t (f a) into an f (t a) .... "flip" two type constructors ... then often times you are looking for Traversable pattern
02:17:40 <jle`> in your case you had [IO (Either a b)] -> IO (Either a [b])
02:17:48 <jle`> you "flipped" (IO . Either a) and []
02:18:13 <fread2282> @hoogle t (f a) -> f (t a)
02:18:17 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
02:18:18 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
02:18:18 <lambdabot> Test.QuickCheck.Gen promote :: Monad m => m (Gen a) -> Gen (m a)
02:18:47 <jle`> from there it was only a matter of which Applicative instance you wanted that would do the job :)
02:19:47 <jle`> (this is slightly simplified)
02:20:45 <abayley> jle`: thanks. will rewrite the hand-rolled one to the new type sig and see where it leads. I could see that sequence matched well (and Error) but could not see how to combine.
02:22:06 <abayley> jle`: coerce is new to me. looks a bit scary as there seems to be some compiler magic involved. no obvious link from types to implementation.
02:22:27 <jtanguy> I wish more of lens was more distilled into base
02:24:01 <jtanguy> here the usecase seems to fit Control.Lens.Wrapped
02:24:12 <nshepperd> oh it is Applicative isn't it, so you can use Data.Functor.Compose even
02:24:13 <jle`> abayley: ah yes.  yeah, the sequence intuition was nice.  Maybe the jump was that, with IO, normally for sequence you switch IO and [].  But for your case, you need to switch (IO . Either a) and [].
02:24:24 <nshepperd> getCompose . sequenceA . Compose
02:24:30 <jle`> oh yeah
02:24:31 <nshepperd> er, map Compose
02:24:40 <jle`> that's nice :)
02:24:48 <abayley> jle`: anyways, gotta go. thanks for the help.
02:24:53 <jle`> that might be a nice way to look for it
02:25:00 <jle`> abayley: np :) take care
02:25:30 <jle`> they need to sequence with f ~ (IO . Either a) and t ~ []....so.... that's just the composition of IO and Either a
02:25:38 <jle`> neat
02:25:57 <jle`> ^ nshepperd, not abayley
02:26:26 <jle`> :t ala Compose
02:26:27 <lambdabot> Not in scope: data constructor ‘Compose’
02:26:35 <jle`> c'mon
02:26:52 <jle`> :'(
02:26:57 <chatEj> www.mirctr.biz / irc.mirctr.biz
02:26:57 <chatJh> www.mirctr.biz / irc.mirctr.biz
02:26:57 <chatzf> www.mirctr.biz / irc.mirctr.biz
02:26:57 <chatwu> www.mirctr.biz / irc.mirctr.biz
02:26:58 <chatDl> www.mirctr.biz / irc.mirctr.biz
02:26:58 <chatWO> www.mirctr.biz / irc.mirctr.biz
02:27:13 <nshepperd> good grief
02:27:13 <chatkq> www.mirctr.biz / irc.mirctr.biz
02:27:13 <chatkq> www.mirctr.biz / irc.mirctr.biz
02:27:54 <jtanguy> :t ala Compose sequenceA
02:27:55 <lambdabot> Not in scope: data constructor ‘Compose’
02:27:55 <lambdabot>     Not in scope: ‘sequenceA’
02:27:55 <lambdabot>     Perhaps you meant one of these:
02:27:57 <ubuntuXE> www.mirctr.biz / irc.mirctr.biz
02:27:57 <ubuntuXE> www.mirctr.biz / irc.mirctr.biz
02:27:57 <ubuntuXE> www.mirctr.biz / irc.mirctr.biz
02:27:57 <ubuntuXE> www.mirctr.biz / irc.mirctr.biz
02:27:57 <ubuntuXE> www.mirctr.biz / irc.mirctr.biz
02:28:02 <ubuntuFP> www.mirctr.biz / irc.mirctr.biz
02:28:02 <ubuntuFP> www.mirctr.biz / irc.mirctr.biz
02:28:02 <ubuntuFP> www.mirctr.biz / irc.mirctr.biz
02:28:02 <ubuntuFP> www.mirctr.biz / irc.mirctr.biz
02:28:02 <ubuntuFP> www.mirctr.biz / irc.mirctr.biz
02:28:07 <jle`> if ala Compose sequenceA worked i'd be pretty happy
02:28:12 <jle`> i don't see why it wouldn't, too
02:28:25 <jtanguy> well the Rewrapping instance is defined
02:28:33 <jle`> yeah
02:28:33 <jtanguy> Rewrapped
02:28:46 <jtanguy> http://hackage.haskell.org/package/lens-4.7/docs/Control-Lens-Wrapped.html#t:Rewrapped
02:29:25 <ubuntuts> www.mirctr.biz / irc.mirctr.biz
02:30:11 <nshepperd> ala Compose traverse, I think?
02:34:24 <jle`> ok i imported it in /query
02:34:32 <jle`> :t ala Compose sequenceA
02:34:34 <lambdabot>     Not in scope: ‘sequenceA’
02:34:34 <lambdabot>     Perhaps you meant one of these:
02:34:34 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
02:34:38 <jle`> :t ala Compose T.sequenceA
02:34:39 <lambdabot>     Couldn't match type ‘e -> a0’ with ‘Compose f' g' a'’
02:34:39 <lambdabot>     In the expression: ala Compose T.sequenceA
02:34:39 <lambdabot>     Couldn't match type ‘Unwrapped (e -> a0) -> a0’
02:36:35 <Tazmain> Hi all how hard is haskell to pick up if you have done java, c++ ?
02:36:50 <nshepperd> :t ala Compose traverse
02:36:51 <lambdabot> (Traversable t, Applicative (Compose f' g')) => t (f' (g' a')) -> Unwrapped (Compose f' g' (t a'))
02:37:00 <jle`> thanks :)
02:37:11 <nshepperd> woo
02:37:15 <jle`> :D
02:37:35 <jle`> Tazmain: well, java and c++ might not help you, but your experience with programming workflow might :)
02:37:42 <jle`> text editors, compiling etc.
02:37:54 <merijn> Tazmain: About as hard a learning a language without ever having programmed (well, note entirely)
02:38:12 <jle`> :t ala Compose traverse `asAppledTo` [undefined :: IO (Either a b)]
02:38:12 <lambdabot>     Not in scope: ‘asAppledTo’
02:38:13 <lambdabot>     Perhaps you meant ‘asAppliedTo’ (line 156)
02:38:15 <Tazmain> I see, and haskell is cross platform ? is it linear or object orientate ?
02:38:33 <merijn> Tazmain: Basically, Haskell is *very* different (note, not so much harder, code golfing in the channel right now notwithstanding) from java/C++
02:38:43 <jle`> sorry :)
02:38:49 <jle`> haskell is cross platform
02:38:53 <merijn> Tazmain: In comparison to haskell, Java, C# and Python might as well be the same language :)
02:38:54 <jle`> but it is not object-oriented
02:39:44 <merijn> Tazmain: GHC (the main compiler) supports Windows, OSX, linux and the usual BSD suspects. What do you mean by "linear"?
02:39:59 <Shockk> hello, I have an issue that I've written up in a gist: https://gist.github.com/shockkolate/e1ae00733da94e751bb4
02:40:10 <Tazmain> What is haskell maninly used for
02:40:32 <Tazmain> merijn, like C is linear , so not object orientated
02:40:50 <merijn> Tazmain: The most well known programs (other than GHC itself) are Xmonad and pandoc, it's used for pretty much everything any other general purpose language is
02:41:03 <merijn> Tazmain: Haskell is neither like C nor object oriented :)
02:41:16 <merijn> Tazmain: You probably wanna have a look at Learn You a Haskell and https://github.com/bitemyapp/learnhaskell
02:41:18 <merijn> @where lyah
02:41:19 <lambdabot> http://www.learnyouahaskell.com/
02:41:21 <jle`> it is a general-purpose language, so it is useful for anything.  but areas where haskell shines compared to other languages are areas where you need reliability, maintainability, speed (over interpreted langages), fast prototyping, and scalability in architecture
02:41:32 <jle`> and correctness
02:41:47 <jle`> yeah, Haskell is almost nothing like C or Java :)
02:42:04 <Tazmain> can haskell do GUI?
02:42:09 <jle`> yes
02:42:14 <Tazmain> oh sweet
02:42:35 <jle`> having learned C++ and Java, the most meainigfulthing you can probably carry over when learning haskell is...how to use a text editor, how to compile things, etc.
02:42:36 <merijn> Hell, I would say that, even if you never practically use Haskell, it's worth learning just to realise how similar Java and C++ are compared to other options :)
02:42:47 <Shockk> so, tldr, one of my dynamically loaded modules needs to put something extra in a thing it exports, and another dynamically loaded module needs to be able to get that extra thing in a type-safe way if possible
02:42:57 <jle`> it is unlikely that anything you've learned about the languages themselves will help you very much
02:43:00 <jle`> :)
02:43:33 <merijn> jle`: Well, understanding algorithms and decomposing problems
02:43:38 <merijn> Those are helpful skills
02:44:07 <jle`> i think...being trained to approach algorithms in a way c++/java encouranges ... might actually hinder progress
02:44:12 <jle`> but knowing what an algorithm is is a nice start
02:44:22 <ab9rf> hah
02:44:55 <ab9rf> i think haskell is easier to learn if you don't know a language like C++ or Java :)
02:44:56 <jle`> Shockk: what library is this?
02:45:37 <Shockk> jle`: the dynamic module loading you mean?
02:45:49 <ab9rf> i dread the idea of trying to use haskell with run-time loading of dynamic libraries
02:45:54 <jle`> or, whatever you are doing at all, heh
02:45:57 <merijn> ab9rf: There was a blogpost on teaching haskell to people who had *never* programmed and they ran into some substantial hurdles too, so
02:45:57 <ab9rf> i suppose it's possibnle but wow, such ugyl
02:46:18 <Shockk> ah, this: https://github.com/shockkolate/arata
02:46:18 <ab9rf> FFI all over the place
02:46:27 <merijn> Also, if you know C++ to the extend of template meta programming, then lots of template magic is considerably easier in haskell ;)
02:46:52 <Shockk> this is the module I want to export the Command from, with the help info that I don't want to be a part of my Command type
02:46:57 <Shockk> https://github.com/shockkolate/arata/blob/master/plugins/NickServ/Add.hs
02:47:56 <Zoetrope_> I'd prefer to teach haskell to people who knew some programming already, personally
02:48:21 <jle`> i've heard anecdotal success stories of people learning haskell as a first language
02:48:36 <jle`> it's not something i can really encourage myself without more materials designed for something like that though
02:49:02 <liyang> For srs bsnss, it helps to know something lower-level.
02:49:13 <jle`> there's that cute story about an elementary school teacher teaching his kids procedural programming and everyone always being very confused
02:49:18 <tdammers> liyang: you can still learn low-level stuff later
02:49:24 <jle`> and then one year switching to haskell and every single kid understood everything
02:49:30 <jle`> and wondered when "the hard part" was coming
02:49:31 <merijn> Any TH experts around? I've got some questions on lifting datatypes, i.e. "t -> Q Exp", I see there's a Lift class which has "lift :: Lift t => t -> Q Exp", but that only has a handful of instances. (i.e., Int, Bool, Integer, etc.) I don't see a way to lift general ADTs?
02:49:34 <liyang> tdammers: I would not disagree. :)
02:49:41 <simg> Hi, could anyone help me with a postgres-simple question?   I'm trying to write a ToField instance for the postgres money data type but get a runtime error - invalid input syntax for type money: \"PgMoney {moneyCurrency = \"\\163\", moneyAmount = 0.0}\"".   My toField instance code is ---->  toField = Escape . BS.pack . show
02:49:41 <tdammers> liyang: besides, there's always a lower level... you don't start with semiconductor physics, right?
02:49:56 <liyang> tdammers: I've done it…
02:50:23 <Zoetrope_> I've had some success but I, selfishly, like coming in when they already know what a structured program looks like
02:50:26 <liyang> (But I did it around the same time as Haskell.)
02:50:28 <merijn> simg: "BS.pack . show" tells me you're using ByteString.Char8 and you deserve all the pain you get
02:50:49 <simg> merijn - yes, I deserve the pain :)
02:51:12 <merijn> simg: Now go rewrite your code to properly encode it >.<
02:51:17 <simg> I think postgres simple requires me to use that though. I'm using "Text" throughout most of my program
02:51:24 <merijn> > text '\163'
02:51:25 <liyang> tdammers: but sure, it doesn't really add anything when you need to do low-level stuff. :)
02:51:25 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[GHC.Types.Char]’
02:51:25 <lambdabot>  Expected type: GHC.Base.String
02:51:25 <lambdabot>    Actual type: GHC.Types.Char
02:51:32 <merijn> > text "\163"
02:51:34 <lambdabot>  £
02:51:40 <merijn> simg: That's not ASCII
02:51:47 <merijn> simg: Char8 silently truncates to ASCII
02:51:48 <ab9rf> tdammers: i actually have managed to learn a good deal of semiconductor physics and i'm fairly adept with electronics :)
02:51:56 <merijn> simg: Which is why using it is pretty uch always wrong
02:52:28 <Zoetrope_> How low level are we talking?
02:52:35 <simg> hmm, but if postgres-simple requires it, what do I do ?
02:52:58 <ab9rf> however, i do _not_ understand much of the quantum physics that underlies semiconductor technology
02:53:03 <ab9rf> some of it, yeah, but not much
02:53:18 <jle`> the quantum physics is the easy part
02:53:20 <Shockk> one thing I thought of doing was giving Command a Map String [String], but that's kind of eh and I can't share any extra stuff except Strings; another solution would be to give Command a [Dynamic] or something; I don't know if that's a good or bad solution
02:53:22 <jle`> the engineering is the hard part :P
02:53:29 <tdammers> ab9rf: yeah, but my point is, you don't really need to know anything about that in order to get started with programming
02:53:34 <ab9rf> jle`: not gonna be doing any of that :)
02:53:36 <merijn> simg: postgres-simple requires ByteString, you should properly encode it
02:53:37 <merijn> simg: https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad
02:53:38 <ab9rf> tdammers: doesn't hurt!
02:53:44 <mbuf> How to connect to MySQL using mysql-simple? http://lpaste.net/119784
02:53:55 <ab9rf> ew, mysql
02:54:02 <ab9rf> hit me with a query optimizer already
02:54:05 <tdammers> ab9rf: at some point, these things become somewhat relevant, e.g. when you're driving the hardware to its limits, but it's not the most important thing you need to learn
02:54:38 <merijn> simg: Text.Encoding is the right way to do it, but you need to know which encoding you configured postgres to use
02:56:29 <simg> merijn: thanks. reading that link now, makes sense. will adjust somehow :)
02:56:53 <jle`> i wonder why lambdabot doesnt' want to import the Applicative instance for Compose f g
02:59:01 <ab9rf> tdammers: it's helpful to have some of that when someone starts pressing you on "why can't we do this faster"
03:00:02 <ab9rf> tdammers: comes into play more for me on the network-engineering side, but i'm a network engineer, not a developer :)
03:02:24 <tdammers> ab9rf: yes, exactly. But when you start with programming, you have enough food for thoughts already, no need to go that deep
03:05:43 * hackagebot MoeDict 0.0.2 - Utilities working with MoeDict.tw JSON dataset  http://hackage.haskell.org/package/MoeDict-0.0.2 (AudreyTang)
03:08:15 <simg> I've tried: toField = Escape . encodeUtf8 . T.pack . show     - still get the same error :/
03:23:45 <xxprismxx> haii
03:28:51 <ClaudiusMaximus> simg: what type are you using  show  at?  show adds backslashes for non-ascii (and other) characters, which might be confusing things
03:29:37 <ClaudiusMaximus> > "£"  -- lambdabot uses  show :: String -> String  here
03:29:38 <lambdabot>  "\163"
03:30:03 <ClaudiusMaximus> > text "£"  -- avoiding show
03:30:04 <lambdabot>  £
03:30:30 <simg> ClaudiusMaximus: aaah, thanks. bet it's show causing the problem ... will check, thx
03:30:55 <mniip> :t text
03:30:56 <lambdabot> String -> Doc
03:30:59 <mniip> that's kinda
03:31:17 <mniip> don't you want 'putStrLn' ?
03:32:00 <ClaudiusMaximus> mniip: yeah, but lambdabot doesn't IO, so text is a workaround using  show :: Doc -> String
03:32:26 <mniip> > putStrLn "what"
03:32:28 <lambdabot>  <IO ()>
03:32:49 <mniip> o
03:33:16 <mniip> hmm guessing there's not a way to sandbox IO?
03:33:22 <mniip> not within same process at least
03:33:55 <MP2E> There is, you make a type with the operations you want out of IO and lift it up to IO when you need to compute it. I think that would be a useful technique for a video game DSL or something similar.
03:34:00 <mniip> well maybe you could go and create your own SandboxedIO monad
03:34:10 <mniip> and redefine all the needed functions
03:34:18 <simg> ClaudiusMaximus: any idea how re-write my toField function without show ?
03:35:02 <mpickering> simg: What are you trying to toField?
03:35:05 <mpickering> what type
03:35:18 <simg> mpickering: money
03:35:40 <ClaudiusMaximus> simg: not much apart from essentially duplicating   class Show a  and writing new instances for all the types you need
03:36:04 <mpickering> and you're storing that as a varchar in your db?
03:36:26 <simg> mpickering: no, using the pg builtin money type
03:36:36 <mpickering> hum ok
03:37:02 <simg> ClaudiusMaximus: hmm, ok, will give that a go :)
03:38:09 <simg> I'm surprised that postgres-simple doesn't already come with a money type since it seems like it would be a very commonly used data type?
03:43:49 <zipper> simg: I've been wondering why haskell itself has no money type.
03:44:02 <zipper> simg: Since it's used in so many money things.
03:44:08 <Tazmain> money in general is a pain
03:44:17 <Tazmain> just do what the japanese do
03:45:02 <speak> What's that then, Tazmain?
03:45:06 <zipper> Tazmain: What do the Japanese do?
03:45:09 <lpaste> mniip pasted “SandboxedIO” at http://lpaste.net/119798
03:45:40 <zipper> Building suspense "Just do what the Japanese do?"
03:46:02 <mniip> next thing you do is not export the constructor, and define a limited amount of functions that do create SandboxedIO objects
03:46:46 <Shockk> I'd guess that they're talking about the japanese yen not having a decimal, 1 yen is the lowest denomination I think
03:48:40 <Tazmain> lo/ speak
03:48:58 <Tazmain> zipper, the japanese have no cents. their whole currency has no decimal
03:51:28 <zipper> Wow I didn't know that.
03:51:56 <speak> Oh Tazmain, nice :D
03:51:59 <zipper> Japanese surprisingly thought a lot of things through.
03:52:03 <speak> That would get rid of a lot of problems
03:52:26 <merijn> zipper: What does a "money type" mean?
03:52:35 <merijn> Haskell has fixed width decimals...
03:52:52 <zipper> merijn: Like a two decimal places at most?
03:53:07 <zipper> merijn: Uh a type that holds cents.
03:53:09 <merijn> http://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Fixed.html
03:53:19 <zipper> merijn: Thanks
03:55:08 <zipper> Got it a type called `Centi'
03:55:58 <rasen> Strange it doesn't instanciate Num
03:56:21 <rasen> Sorry, it does
04:05:45 * hackagebot data-filepath 2.1.1.0 - A type safe file path data structure  http://hackage.haskell.org/package/data-filepath-2.1.1.0 (domdere)
04:17:09 <ironChicken> is there reference documentation for all the standard .cabal file options?
04:17:25 <merijn> ironChicken: Yes, the cabal user's guide
04:17:36 <rasen> @google cabal user guide
04:17:36 <lambdabot> https://www.haskell.org/cabal/users-guide/
04:18:07 <ironChicken> hmm, but where?
04:18:25 <rasen> creating packages section
04:19:02 <ironChicken> that's where i was looking before i asked
04:19:34 <ironChicken> ok, found it: https://www.haskell.org/cabal/users-guide/developing-packages.html#package-descriptions
04:37:25 <h_neophyte> I've a question regarding the Traversable package.
04:37:32 <h_neophyte> It defines a function https://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Traversable.html#v:traverse
04:38:15 <h_neophyte> It's type signature is (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
04:38:24 <rasen> :t traverse
04:38:25 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
04:38:44 <merijn> h_neophyte: What's the question? :)
04:38:44 <rasen> yep
04:39:29 <h_neophyte> Can I define a function like : (a -> f b) -> (y -> f z) -> t a y -> f (t b z)
04:39:50 <flux> 1/6
04:39:50 <h_neophyte> i.e, a multi param Traversable type class
04:39:51 <rasen> @djinn (a -> f b) -> (y -> f z) -> t a y -> f (t b z)
04:39:51 <lambdabot> -- f cannot be realized.
04:40:00 <merijn> h_neophyte: Maybe, hard to say
04:40:20 <merijn> h_neophyte: Depends on 'f' and 't' and what you expect the semantics to be
04:40:28 <rasen> Traversable are of kind * -> *
04:40:45 <h_neophyte> The DeriveTraversable can derive an instance for Traversable for types of kind * -> *
04:41:07 <alpounet> h_neophyte: http://hackage.haskell.org/package/bifunctors-4.2/docs/Data-Bitraversable.html#v:bitraverse ?
04:41:08 <rasen> So, you can't do t a y
04:42:15 <h_neophyte> @alpounet, is there a language extension like DeriveBitraversable ?
04:42:15 <lambdabot> Unknown command, try @list
04:42:22 <alpounet> nope
04:44:14 <h_neophyte> By using DeriveTraversable extension, I was able to avoid a lot of boilerplate code. But, now that my types have changed, I would need something like DeriveBitraversable. How hard will it be to implement such an extension?
04:45:06 <rasen> Probably a bit harder than writing all instances yourself
04:45:47 * hackagebot deepseq-bounded 0.7.0.2 - Bounded deepseq, including support for generic deriving  http://hackage.haskell.org/package/deepseq-bounded-0.7.0.2 (AndrewSeniuk)
04:45:49 * hackagebot seqaid 0.3.0.1 - Dynamic strictness control, including space leak repair  http://hackage.haskell.org/package/seqaid-0.3.0.1 (AndrewSeniuk)
04:45:51 * hackagebot leaky 0.3.0.3 - Robust space leak, and its strictification  http://hackage.haskell.org/package/leaky-0.3.0.3 (AndrewSeniuk)
05:02:12 <merijn> ok, typeclass design question
05:03:03 <merijn> If I have a class Foo which can have an efficient implementation of the type is an instance of Bar or an inefficient implementation (that always works), what's the best way to expose this?
05:04:03 <merijn> I could use a default signature to make the efficient version the default, but that means everyone else would have to overwrite it for the non-fast case. Alternatively, I could make the slow case the default, but that'd mean losing out on the "efficient" way where it applies
05:04:34 <rasen> The default should always work, I believe
05:05:13 <merijn> The always working function is bad, tbh and the only reason to have it is if you can't define an instance for Bar for unrelated reasons
05:05:37 <jtanguy> maybe a SPECIALIZE pragma ?
05:06:30 <arw_> put both in different modules and just let the user pick the right module?
05:06:36 <merijn> I don't think you can specialise on typeclass instances
05:07:05 <merijn> arw_: No, because the user should never access this class anyway. I'm using it in TH to generate code (and potentially in the future integrated into GHC)
05:07:34 <merijn> Also, specialise is the wrong way anyway, but maybe rewrite rules will work...
05:07:47 <jtanguy> merijn: ghc user guide: 7.20.10. SPECIALIZE instance pragma
05:07:52 <jtanguy> oh ok
05:08:12 <merijn> jtanguy: Specialise pragma's let you explicitly specify a type to specialise for, but that's not what I need
05:08:23 <merijn> I need a "use this different code if it's an instance of class Bar"
05:08:24 <rasen> merijn: I've seen many cases where some function is implemented as general in typeclass for allowing more efficient overloading
05:09:14 <rasen> How many there're classes for which fast version work/doesn't
05:09:19 <rasen> ?
05:09:21 <merijn> The difference here is that if a type is an instance of the Lift class, then it can produce completely evaluated expression compiled into the resulting program
05:09:31 <rasen> types*
05:09:45 <merijn> The slow approach is to quote the generating expression and splice that in, i.e. the result will be evaluated at runtime, rather than compile time
05:09:51 <jtanguy> maybe a Foobar typeclass which just Constraints on Foo and Bar, and a specialize on the Foobar ?
05:10:15 <merijn> Clearly you never want the second behaviour, except in the few case where you CAN'T statically evaluate (i.e. there's no Lift instance possible)
05:10:43 <jtanguy> but maybe my understanding of specialize is wrong
05:12:21 <rasen> Can't you instanciate class for anything with Lift constraint?
05:12:51 <rasen> Something like instance Lift a => Bar a where ...
05:13:25 <merijn> rasen: No, because that overlaps
05:13:44 <merijn> Actually
05:14:03 <merijn> That may be ok, since no one should be defining manual instances anyway if there's a Lift instance available
05:14:53 * koomi doubts a typeclass is the best solution in the first place
05:15:04 <rasen> https://wiki.haskell.org/GHC/AdvancedOverlap#Solution_1_.28using_safer_overlapping_instances.29
05:15:10 <koomi> but I don't know enough about what you're doing to suggest alternatives
05:20:05 <merijn> koomi: It has to be a typeclass, I'm trying to expand on IsString/Num/IsList to allow you to have user-defined, compile time validation of literals
05:20:33 <merijn> i.e. "newtype Even = Even Integer; x :: Even; x = $$(validate 3)" <- compile time error
05:22:12 <merijn> Now, clearly, when you use this you want "$$(validate 2)" to result in the completely evaluated equivalent of "Even 2", rather than "if even 2 then Even 2 else undefined" even though the latter is guaranteed correct, you'd want to avoid evaluating that every time at runtime (imagine if 'even' is an expensive function!)
05:30:20 <jtanguy> and you would like a fast shortcut implementation of validate ? e.g. if a is prime then we just check for some cases instead of using even ?
05:30:51 <merijn> jtanguy: The problem is that I want to splice the *result* of validate, not the *computation*
05:31:14 <merijn> But, splicing the result requires the type has a Lift instance (to actually lift it into the splice)
05:31:41 <merijn> But some types (for example functions) can't have a Lift instance, so there I need to do the slow thing
05:33:53 <dacm> Hi guys.
05:34:54 <Black0range> Are there any way to flush sockets in haskell?
05:34:57 <dacm> If I use type inference on a function that takes a string and reads a string from standard input then ghci gives the type signature as being: [Char] -> IO String
05:35:33 <dacm> Is there any logic as to why this is? i.e. Why not [Char] -> IO [Char] or String -> IO String ?
05:36:15 <geekosaur> the only logic is internal to ghc's typechecker
05:36:21 <flux> I guess how it works between type aliases is pretty arbitrary 'first come first serve' perhaps
05:36:36 <flux> look at the signatures of the functions you are using?
05:36:53 <flux> if the first one takes [Char] and the last one returns IO String, then there's your answer, maybe :)
05:37:24 <dacm> geekosaur: Is that a nice way of saying that it is inconsistent and a bit crazy? :-)
05:37:53 <geekosaur> dacm, more or less :)
05:37:59 <dacm> flux: That makes sense I suppose. Still annoys me though!
05:38:07 <dacm> Also, when I declare the type signatures on my functions is there an accepted style on when to use [Char] and when to use String?
05:38:20 <Black0range> [Char] == String
05:38:31 <flux> but hey, in actual text written by people it's considered good form to not repeat, ie. use the same name for the thing, if there is a suitable alias :)
05:38:34 <detrumi> Depends on how you use it, I guess
05:38:37 <Black0range> use [Char] when you want to remind yourself that you're working with characters
05:38:43 <dacm> Black0range: I know. But mixing them in the same type signature is slightly confusing.
05:39:14 <dacm> Black0range: Yes, that might be a sensible approach. :-)
05:39:16 <Black0range> dacm: Can't deny that
05:40:19 <Black0range> Any how, does anyone know how tu flush sockets in haskell? Without closing them that is
05:42:04 <Black0range> If not does anyone know if B.append on a lazy Bytestring / text forces evaluation on the first argument or is it lazy?
05:43:33 <Black0range> **** It! lets prove Cunninghams Law! :D
05:44:00 <Black0range> Did you guys know that using B.append on a Lazy ByteString forces evaluation on the first agument?
05:46:01 <niklaus> newbie here, looking for a cool project to learn haskell
05:46:17 <Black0range> make a tetris
05:48:15 <niklaus> tetris, with gui and stuff, wont it be complicated?
05:48:45 <tdammers> a curses UI would work
05:48:46 <ezrios> niklaus: write a chess AI
05:48:54 <tdammers> but still, plenty of complications
05:49:10 <tdammers> frankly, I think a JSON parser would be an easier project :P
05:49:12 <Black0range> niklaus use bash to print colored spaces
05:49:17 <arw_> if you want easy, try a sudoku-solver.
05:49:49 <ezrios> John Hughes' "Why Functional Programming Matters" has a section at the end regarding minimax/alpha-beta pruning for game AIs
05:50:00 <ezrios> that might be a good place to start
05:50:35 <niklaus> ok curses is cool \m/
05:51:31 <hyPiRion> niklaus: a small game is always nice. Tic-tac-toe, Snake or something more obscure like Quarto is doable.
05:59:04 <niklaus> i will try making  small game, its nice to have something useful at the end
06:01:24 <niklaus> join archlinux
06:05:50 * hackagebot language-fortran 0.3 - Fortran lexer and parser, language support, and extensions.  http://hackage.haskell.org/package/language-fortran-0.3 (DominicOrchard)
06:15:07 <Hi-Angel> Could anybody explain, what does the "As operator" here: «addlKeys conf@(XConfig {modMask = modm}) = M.fromList $ …»(after the ellipsis some more code)
06:15:23 <Hi-Angel> Here no a pattern to match o.o
06:15:45 <rasen> It's a pattern match on function argument
06:16:38 <rasen> XConfig{ modMask = modm } is a pattern
06:17:19 <Hi-Angel> Is it mathes when the data «XConfig» have the field «modMask» set to «modm»?
06:17:53 <rasen> It matches when constructor is XConfig
06:18:08 <rasen> it also assigns modMask field to modm
06:18:39 <Hi-Angel> Ah, now I see… Thank you very much rasen !!
06:18:43 <Black0range> Hi-Angel: if you do a function on a list and want to do the (x:xs) thing but STILL want to have a reference to the original list you can do f list@(x:s)
06:18:57 <rasen> Hi-Angel: np
06:19:45 <Hi-Angel> Black0range, no, here was a few unusual situation, there was a pattern as a constructor
06:19:58 <rasen> record syntax*
06:22:02 <Athas> Why has Control.Monad.Error been deprecated in favor of Control.Monad.Except?
06:31:42 <clrnd> I can guess because of the error instance, which was kinda silly, but just guessing
06:32:16 <Hi-Angel> rasen, is there a way to reproduce a simplest version of the Constructor mathing in the ghci? I.e. the «let myFunc pat@([Int]) = 1» gives me an error.
06:32:35 <rasen> Int is not a constructor but name of type
06:32:46 <Hi-Angel> Ah, indeed
06:32:55 <rasen> the simplest case you already know is (:)
06:33:19 <Hi-Angel> But this isn't a constructor
06:33:47 <rasen> > let all@((:) a as) = [1,2,3] in (all, a, as)
06:33:48 <lambdabot>  ([1,2,3],1,[2,3])
06:33:53 <rasen> Indeed, it is
06:34:29 <rasen> data [a] = a : [a] | []
06:34:38 <Hi-Angel> Okay, thank you
06:35:30 <rasen> so, basically both (x:xs) and [] match on constructors
07:15:19 <zipper> Can't one tell haddock to generate docs for all files in a dir? Like point it to src/? According to haddock documentation it seems it takes files.
07:16:58 <rasen> If you use something funcier than sh you can do haddock directory/**/*.hs
07:18:05 <rasen> fancier*
07:20:05 <kgadek> hi. Just curious: what's the status of cabal's testing interface "detailed-0.9"? I see little toolset support for that (and it seems everybody's using exitcode-stdio-x.y). Why's that?
07:20:40 <rasen> I think exitcode is easier to adopt
07:21:48 <geekosaur> I think I reall people trying to use detailed and finding it wanting, but nobody has time/interest to figure out how it should work and make it usable
07:22:30 <kgadek> and what would be the benefits of "detailed"? Progress status? Concurrent execution (although hspec / tasty already do that)?
07:30:32 <gregnwosu> can i used typed holes in a function signature i.e.  fun :: _
07:30:50 <gregnwosu> its seems to be giving an error not, sure if its just my ide that doesnt like it
07:30:52 <rasen> you can use type variables
07:30:57 <rasen> fun :: a
07:31:02 <tdammers> yeah
07:31:07 <tdammers> just use an unconstrained type variable
07:31:30 <gregnwosu> rasen but i guess a hole doesnt make sense
07:31:48 <rasen> gregnwosu: the short answer, you can't put holes in types
07:32:37 <gregnwosu> thanks
07:33:19 <ClaudiusMaximus> gregnwosu: long answer, http://downloads.haskell.org/~ghc/7.10.1-rc2/docs/html/users_guide/partial-type-signatures.html
07:40:54 * hackagebot turtle 1.0.1 - Shell programming, Haskell-style  http://hackage.haskell.org/package/turtle-1.0.1 (GabrielGonzalez)
07:45:04 <athan> Hi everyone, wikipedia states that the grammar for the simply-typed lambda calculus includes type labels as first-class expressions, which I think is bologna. Does anyone have a good idea of what it should be?
07:46:41 <codygman> Does anyone else think that the fact that wordpress pages == posts { postType = "page" } is horrible?
07:46:59 <tdammers> you lost me at "wordpress"
07:49:21 <kgadek> athan: probably better to ask on #haskell-in-depth
07:49:40 <athan> now that's a new chan :) Thanks kgadek
07:49:53 <byorgey> athan: where does it say that?
07:50:30 <kgadek> athan: and what does bologna mean? :P
07:50:48 <athan> (nonsense :P)
07:50:53 <byorgey> athan: are you referring to   \x:tau. e   ?  you are worried about the tau?
07:51:28 <athan> byorgey: No, it's the second figure
07:51:31 <Black0range> guys shouldn't haskell be able to use @ in a let? ex: let x@(Just a) = Just "Hello"
07:51:50 <athan> the `e = (x : T) | \x.e | e e | c`
07:51:53 <byorgey> Black0range: yes
07:51:53 <athan> c shouldn't be there
07:52:12 <athan> shouldn't it be only defined in the set `B`?
07:52:20 <Black0range> god damn it! I was writing into the console!
07:52:31 <byorgey> athan: that c is not a type label, it is a term constant
07:52:45 <athan> oh wait... shoot
07:52:51 <byorgey> athan: e.g. if you include the type 'Nat' in your 'B' then you might want to include term constants 'Zero' and 'Succ'
07:53:01 <athan> ahh I see
07:53:11 <athan> okay great, so it's domain specific
07:53:33 <byorgey> right
07:53:39 <athan> thanks byorgey
07:53:45 <byorgey> you need *some* base types since otherwise you would only have infinite function types
07:53:49 <byorgey> but it doesn't really matter which
07:54:07 <byorgey> you're welcome
07:54:09 <athan> That makes sense, B is assumed to be finite
07:55:30 <byorgey> it doesn't matter whether B is finite
07:55:43 <byorgey> the point is that *type expressions* must be finite
07:56:00 <byorgey> if you only have  tau := tau -> tau   then there are no finite type expressions
07:57:46 <robstewartuk> when compiling with ghc's LLVM backend, am I able to inspect the LLVM IR that GHC generated before compiling it to native code?
07:58:47 <byorgey> robstewartuk: yes, try -ddump-llvm
07:58:56 <robstewartuk> byorgey: thanks
07:59:03 * robstewartuk trying -ddump-llvm
07:59:09 <byorgey> robstewartuk: I looked at https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flag-reference.html and did a grep for 'llvm'
07:59:32 <angerman> sometimes I really wish for stacktraces
07:59:46 <robstewartuk> byorgey: ah, I was looking at https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/code-generators.html
08:00:49 <codygman> tdammers: I wish I had lost myself at "wordpress"
08:01:05 <tdammers> codygman: dealing with that myself ATM
08:01:35 <tdammers> codygman: I take it you're familiar with this gem? http://codex.wordpress.org/Function_Reference/capital_P_dangit
08:02:15 <zomg> ^ wat
08:02:30 <zomg> I thought wordpress couldn't surprise me with its... "quality"... anymore
08:02:37 <zomg> but I was wrong
08:02:46 <a3gis> is there a ghci command to print off the source code of a given function or open up the relevant file? e.g. ":i" on steroids
08:02:57 <a3gis> specifically for library functions
08:05:21 <fryguybob> a3gis: Not built-in to GHCi, but hoogle gets you close to that
08:05:43 <a3gis> fryguybob: yep I know hoogle; was hoping for something within ghci
08:05:46 <a3gis> thanks anyway :)
08:05:55 * hackagebot debian-build 0.7.0.0 - Debian package build sequence tools  http://hackage.haskell.org/package/debian-build-0.7.0.0 (KeiHibino)
08:06:01 <fryguybob> You can get hoogle in GHCi, but I don't know about source links with that.
08:13:49 <sdegutis> I can't help but notice tons of similarities between Clojure and Haskell.
08:15:42 <tac_> sdegutis: they both share the same dna.
08:15:54 <tac_> sdegutis: they are just as different as they are similar though.
08:16:29 <Profpatsch> Is there a way to write this simpler / more expressive? https://bigmac.caelum.uberspace.de/paste/simpler.hs.html
08:18:24 <sdegutis> tac_: They both have things like comp and partial, they both have plenty of ways to operate on lists, they both encourage writing small, pure functions...
08:18:58 <tac_> you might say they are both functional languages ;o
08:19:13 <tac_> but yes. Those are both traits of the functional style of programming
08:19:30 <tac_> Clojure embraces that style. Haskell worships it.
08:20:46 <Kaidelong> I'd say that in a sense Haskell kind of goes full circle and "embraces" imperative programming in a way things like Clojure don't/can't
08:20:57 <sdegutis> Kaidelong: :)
08:21:26 <gregnwosu> whats a good date library for converting epoch timestamps
08:21:27 <gregnwosu> ?
08:21:43 <tac_> What Haskell would use fancy types and heavy abstraction for, Clojure would just slap with a few macros
08:22:01 <gregnwosu> tac_: untyped macros slap back
08:22:36 <tac_> I didn't say it was better. I just think it's a little short-sighted to say you can't "write imperatively" in Clojure.
08:22:49 <tac_> Macros are very powerful.
08:22:54 <sdegutis> Oh of course you can. I do all the time.
08:22:57 <hellofunk> tac_: i'm a big fan of macros, but macros are not first-class in any language i know of. You can't pass them around like you can with functions. sometimes a functional abstraction is worth the extra effort, but it really depends on context.
08:22:58 <tac_> But of course, in the sense that a gun with no safety is powerful
08:23:03 <Kaidelong> tac_: how do you do IO in Clojure without side effects, though?
08:23:15 <Kaidelong> or for that matter, what is the equivalent of ST
08:23:47 <tac_> hellofunk: types aren't first-class either. Your language will always have its limits.
08:23:48 <clrnd> now core.typed is ridiculously complicated
08:24:33 <exio4> tac_: yet!
08:24:33 <Kaidelong> I think Haskell's significance might in part be that it pointed out that it's useful to capture effects implicitly, even with a brain dead stupid, simple, obvious version of that, which IO is
08:24:35 <dfeuer> Kaidelong, ST is type magic. You can fake it in an untyped language either using discipline or using an interpreter for a restricted language, I guess.
08:25:14 <Black0range> we're having the lisp/scheme/clojure vs haskell battle? :D *grabs popcorn*
08:25:23 <Kaidelong> what I expect we'll eventually see are obstensible imperative languages with C like syntax that still can do optimizations as if they are purely functional
08:25:24 <MP2E> It doesn't seem like much of a battle
08:25:27 <sdegutis> Black0range: No we're not.
08:25:35 <sdegutis> We all prefer Haskell here.
08:25:38 <Kaidelong> because they can infer what effects there are in your code and prove it pure if it is pure
08:25:46 <nbouscal> yeah it's really not a battle. types win.
08:25:53 <nbouscal> core.typed is a nice initiative but has a long way to go
08:25:53 <sdegutis> I personally am tired of all the time dynamic typing wastes.
08:26:11 <sdegutis> core.typed's main flaw is that it's opt-in
08:26:25 <sdegutis> That kind of defeats the whole point of typing.
08:27:13 <Kaidelong> well you can still do typing with unsatisfiability proofs where people do opt in, you still end up with the typechecker catching some mistakes
08:27:13 <sdegutis> Are all Haskell's list operations lazy in the same sense that some of Clojure's are?
08:27:36 <gregnwosu> not all lists are lazy
08:27:42 <Profpatsch> Kaidelong: Yeah, but C like syntax for functional languages is crap.
08:27:43 <Black0range> sdegutis: Haskell lets you do whatever you want. But by default most are lazy
08:27:52 <clrnd> Reactjs is very haskell-like too :P
08:28:18 <sdegutis> clrnd: wait, do I know you from #clojure?
08:28:22 <Profpatsch> Kaidelong: Function application needs to have the lowest friction syntactically, or else it’s no good. See Javascript.
08:28:22 <Kaidelong> sdegutis: I'm not sure what you mean by this because I don't know what clojure does, but Haskell's lists should behave in a maximally lazy way in terms of how many evaluation steps are used to get the result
08:28:44 <Kaidelong> Profpatsch: what's wrong with Javascript function application?
08:28:49 <clrnd> sdegutis, I was there for a year, I remember your nick
08:28:54 <sdegutis> Ah ok.
08:29:04 <sdegutis> clrnd: got fed up with dynamic typing?
08:29:18 <tdammers> lists themselves are lazy, but not all list operations are lazy
08:29:20 <Kaidelong> currying is clunky sometimes maybe but application itself is straightforward
08:29:27 <Profpatsch> Kaidelong: It’s long, clutters the view. And lambdas are horrible.
08:29:39 <sdegutis> tdammers: oh I see
08:29:42 <Kaidelong> tdammers: wasn't there a *proof* that short of cheating, like seq, it is as lazy as possible?
08:29:47 <clrnd> sdegutis, more like fell in love with types, also figured out I can't read prefix notation, only write it
08:29:55 <Profpatsch> Kaidelong: Plus, explicit blocks with {} and Callbacks lead to });};);)-hell
08:29:59 <sdegutis> clrnd: lol
08:30:02 <tdammers> Kaidelong: idk, never heard of that, but makes intuitive sense
08:30:46 <Kaidelong> I seem to recall that being something intentionally built into Haskell's design and one of the tradeoffs of that is that pattern order matters, unlike in miranda
08:31:14 <tdammers> my complaint with JS, apart from how you're forced into a single thread for all actual JS code, is how the whole callback thing requires so much ceremony, especially when you want to throw error handling into the mix
08:31:19 <clrnd> what does it even mean it doesn't follow order? is mrianda total?
08:31:43 <tdammers> the whole callback situation *screams* of monads, but actually implementing monads in JS isn't very straightforward and doesn't easily lead to very readable code
08:31:47 <Kaidelong> miranda had a partial ordering on patterns that it could use to short them for you
08:31:54 <Kaidelong> sort*
08:31:56 <clrnd> tdammers, actually, clojurescript's core.async is the best solution for that I've ever seen
08:32:17 <alpy> Hey, i was trying to download threadscope to check something , and cabal is telling me that i can't download cairo. Is there a solution?
08:32:25 <Kaidelong> I think there were still some situations where pattern order mattered but for example it could do
08:32:51 <hellofunk> tdammers: the whole callback thing in js is more or less "solved" by asynchronous programming using clojurescript now. almost all cljs devs use it, it pretty much removes callbacks entirely from your architecture
08:33:06 <Kaidelong> "if I check (x:xs) before (x:y:xs) I'll never match (x:y:xs) so clearly the programmer meant to put (x:y:xs) first"
08:33:31 <clrnd> but it's true that a monadic/applicative interface would be "fucking awesome", to use frontender slang
08:33:55 <tdammers> clojurescript isn't part of the javascript/ecmascript standard though
08:34:16 <hellofunk> sdegutis: some basic list operations that in clojure are not lazy at all are lazy in haskell. the big daddy is folding. clojure has no right folds, and it has no lazy folds.
08:34:34 <tdammers> of course issues can be solved by using a "compile-to-js" language... I mean, I could just use ghcjs or fay or something and call it a day
08:35:02 <tdammers> it's just that I'd prefer a pure JS solution to the problem
08:35:17 <Kaidelong> F#'s scan was right associativity
08:35:23 <Kaidelong> associative*
08:35:26 <hellofunk> tdammers: eh, JS is basically assembly language now. no one should write JS any more.
08:35:54 <Black0range> I would say that Javascript is great for it's puropse. Hacking together some code to fix simple things
08:35:57 <rasen> hellofunk: many guys do. and js becomes more popular today
08:36:28 <Kaidelong> Javascript's "purpose" at this point seems to be GUI code
08:36:30 <rasen> especially when node.js comes to game
08:36:41 <tdammers> hellofunk: if only that were true
08:36:49 <Black0range> Kaidelong: yes, and being very dynamical at doing so
08:37:12 <tdammers> anyway, compared to the rest of the dynamic bunch, I find JS with the right libraries almost decent
08:37:42 <tdammers> JS + require.js + underscore + some DOM manipulation lib -> quite bearable
08:38:04 <mmachenry> tdammers: I'd rather have Scheme or Python. Javascript's type system is as insane as Perl's.
08:38:06 <Black0range> tdammers: you mean you like JS when you don't have to write it? :P
08:38:10 <Kaidelong> I'm told that if you understand how Javascript was born the thought that strikes you is that it's amazing it wasn't a lot worse than it actually was and a testament to the talent of the people who did design it
08:38:25 <tdammers> mmachenry: python isn't much better than JS, really
08:38:25 <Kaidelong> and also that you realize that it is basically lisp
08:38:30 <sdegutis> hellofunk: oh
08:38:40 <Black0range> Kaidelong: word
08:38:41 <tdammers> mmachenry: the "types" are more consistent, but the FP features are more crippled
08:39:08 <Kaidelong> supposedly the time it took to design javascript initially was like <50h
08:39:16 <mmachenry> tdammers: You don
08:39:18 <Black0range> tdammers: some problems are by it's nature stateful, going hardcore FP might not always be the right solution
08:39:20 <tdammers> also, yeah, if you treat JS as "half a Scheme with wacky syntax", things make a lot of sense
08:39:28 <Kaidelong> netscape developed it on a rush schedule
08:39:33 <mmachenry> tdammers:  You don't need scare quotes. They are types even if they are not static.
08:39:35 <tdammers> Black0range: you realize this is #haskell right? :D
08:39:38 <Kaidelong> modern javascript evolved from what was basically a hack
08:39:51 <Kaidelong> oh
08:39:53 <Kaidelong> I didn't
08:40:05 <tdammers> mmachenry: some people would argue that they're not types, but tags, and that "dynamically typed" languages should be called "unityped" instead
08:40:06 <Black0range>  tdammers: I do but i hope we cane have a civil discussion :)
08:40:10 <mmachenry> tdammers: Things make sense, until you try mistakenly subtract a number from a string.
08:40:27 <tdammers> yes. JavaScripts type coercion is broken
08:40:32 <tdammers> I acknowledge this
08:40:35 <tdammers> no argument there
08:40:41 <Kaidelong> Black0range: fortunately, Haskell is better at dealing with state than most other languages
08:40:45 <mmachenry> tdammers: This is why I'd rather have Python or Scheme.
08:40:51 <tdammers> but it's not something that bites me all that often, really
08:41:06 <tdammers> what does bite me is stuff that JS shares with all the other dynamically-typed languages
08:41:16 <tdammers> and in fact, JS has better encapsulation support than Python, really
08:41:32 <Kaidelong> although it is a bit more verbose than it really has to be, sometimes
08:41:38 <tdammers> using closures to wrap state in functions works really well, unlike python
08:41:42 <hodapp> tdammers: what sort of encapsulation?
08:41:52 <tdammers> hodapp: hide implementation details from dependent code
08:42:07 <tdammers> hodapp: Python has no private anything, and its scope model is too simple to be useful
08:42:18 <tdammers> hodapp: JavaScript has proper closures and proper lexical scope
08:42:48 <Kaidelong> @hoogle (:=)
08:42:50 <lambdabot> No results found
08:42:57 <hodapp> tdammers: ahh, true
08:43:12 <tdammers> to me, this makes *a lot* of difference
08:43:36 <Kaidelong> http://hackage.haskell.org/package/ref-mtl-0.2/docs/Control-Monad-Ref.html
08:43:48 <tdammers> because with JS, I can write modular code, and I can pretty much make sure that what I shield off from the rest of the code remains private, but in Python, everything is more or less nude
08:44:00 <tdammers> I don't feel comfortable with this level of nudity
08:44:00 <sdegutis> Dear you all:  what kind of apps do you personally use Haskell to write?
08:44:18 <tdammers> sdegutis: web apps, mainly. Also made a music notation program.
08:44:36 <rasen> sdegutis: I'm writing torrent client
08:44:36 <sdegutis> tdammers: what Haskell web app stack do you use?
08:44:38 <Kaidelong> what if "var" was an alias for newRef and "(:=)" was an alias for writeRef?
08:44:45 <sdegutis> rasen: impressive
08:44:45 <Kaidelong> then you can say
08:44:55 <tdammers> sdegutis: scotty, or just plain wai over warp, usually
08:45:04 <sdegutis> tdammers: do you use lucid?
08:45:06 <rasen> sdegutis: before that I was doing some silly expression transformassions
08:45:10 <tdammers> depends on how closely scotty matches the architecture I have in mind
08:45:17 <gregnwosu> sdegutis: im not trolling but ive recently decided to do all my development in Haskell
08:45:18 <tdammers> nope
08:45:24 <sdegutis> gregnwosu: me too :)
08:45:27 <tdammers> welp, gotta go
08:45:29 <sdegutis> tdammers: what do you use to generate HTML?
08:45:31 <gregnwosu> it really just seems like the best tool for the job
08:45:31 <sdegutis> aww
08:45:36 <RchrdB> Kaidelong: "x <- var initialValue"? :)
08:45:37 <sdegutis> gregnwosu: agreed
08:45:47 <gregnwosu> sdegutis: :D
08:45:49 <Kaidelong> RchrdB: yes
08:45:55 <Kaidelong> and x := newValue
08:46:00 <tdammers> sdegutis: depends... blaze, or one of the many templating solutions I cooked up :D
08:46:13 <tdammers> and now I'm *really* leaving
08:47:42 <sdegutis> ok bye thanx lol
08:49:13 <athan> sdegutis: Check out hamlet & lucid
08:49:35 <sdegutis> I checked out Lucid, very cool although I have no idea how it actually works.
08:49:59 <sdegutis> Hamlet looks awesome but I don't see how it can be type-safe.
08:50:01 <athan> Yeah it's a brain teaser
08:50:06 <RchrdB> Kaidelong: Data.StateVar defines ($=) :: (HasSetter s) => s a -> a -> IO (), which is roughly the same as (:=).
08:50:09 <athan> sdegutis: It's like...
08:50:14 <sdegutis> Oh I see, Hamlet needs a secondary tool.
08:50:18 <athan> a preprocessor from hamlet -> blaze
08:50:30 <sdegutis> I can see that getting annoying quick.
08:50:39 <sdegutis> Lucid looks like a better blaze.
08:50:53 <athan> it is, imo
08:51:03 <athan> I'm gonna port hamlet over sometime
08:51:06 <athan> when I'm not homeless
08:51:22 <sdegutis> One thing Slim does better than Haml is allowing JS and Markdown inline in a template.
08:51:31 <sdegutis> If Hamlet can do that, while being type-safe, then I'm content.
08:55:29 <tac_> Just to be a little obnoixious, knowing something is "type safe" doesn't really tell you much about it
08:55:30 <rasen> Can somebody help me find an image? It was a joke about lazy resume
08:55:40 <tac_> You need to know what the type system enforces first
08:55:57 * hackagebot web-routing 0.4.1 - simple routing library  http://hackage.haskell.org/package/web-routing-0.4.1 (HirotomoMoriwaki)
09:04:46 <gregnwosu> can someone give me the function to get the 3 most significant decimal digits from a Fractional as a String?
09:05:52 <rasen> Finally found it. In case someone is interested https://ro-che.info/ccc/11
09:06:36 <gregnwosu> rasen: LOL
09:16:12 <sinelaw> Is there a way to define a class instance for a fixed-point type?
09:16:20 <sssilver> OK so I got my functions, lisp comprehensions, type classes, and pattern matching. Now where's my Ferrari?
09:16:20 <sinelaw> without enabling UndecidableInstances
09:16:27 <sssilver> *list
09:17:09 <rasen> sssilver: you should get Zygohistomorphic prepromorphism first
09:17:24 <sssilver> shit :(
09:17:38 <sssilver> K, thanks!
09:17:38 <lpaste> mbuf pasted “How to use mysql-simple?” at http://lpaste.net/119811
09:17:54 <mbuf> are there any simple examples on how to use mysql-simple?
09:19:16 <sinelaw> sssilver, http://www.stephendiehl.com/what/
09:20:05 <tiger717> I'm looking for a nice function with to do (a -> b -> c) -> (a, a) -> (b, b) -> (c, c)
09:20:23 <tiger717> Thought it might work with Arrows (***)
09:27:48 <crobbins> tiger717: i don't think you'll find a single function, but you could make one
09:28:13 <crobbins> :t \f -> f *** f
09:28:14 <lambdabot> Arrow a => a b' c' -> a (b', b') (c', c')
09:28:57 <sssilver> sinelaw: this seems mega helpful, awesome -- thanks!
09:29:09 <tomphreek> is it possible to create [0, 3] datatype (i.e. all doubles between 0 and 3 inclusively
09:29:17 <sssilver> hopefully the Ferrari is on the horizon...
09:29:19 <sinelaw> sssilver, yup! I've yet to read it myself :)
09:29:52 <tomphreek> sorry for list notation, automatically used mathsy one
09:29:56 <breadmonster> sinelaw sssilver: What's up?
09:30:14 <sinelaw> breadmonster, the usual
09:30:49 <breadmonster> Is there an offtopic chat room?
09:30:55 <sinelaw> #haskell-blah
09:31:10 <juan_> tix is the most powerful I know
09:33:14 <rasen> Can I run ghcjs compiled code on client-side?
09:33:37 <geekosaur> with a hugeous library download, as I understand it, yes
09:34:32 <rasen> oh... it should... "Our goal is to provide a full-featured Haskell runtime in the browser"
09:40:58 <dacm> Is it considered crazy to try to create a phone app in Haskell?
09:41:20 <athan> I think there's an android port of GHC
09:41:22 <gregnwosu> i heard there  was an android compiler, or am i just making it up
09:41:28 <enthropy> tomphreek: you could define newtype DoublesGe0Le3 = DoublesGe0Le3 Double, and have the instances of that type do the same thing as Doubles do, except error if you get a number outside the range...
09:41:38 <athan> gregnwosu: we both are ;)
09:41:50 <arw_> wouldn't consider it crazier than trying to run java on an underpowered arm... ;)
09:42:03 <dacm> I think there are a few options. I'm just wondering if any of them are known to be any good.
09:42:09 <gregnwosu> dacm: i think doing the whole of it in haskell is a bit nuts
09:42:16 <gregnwosu> there are great tools to help with the layout
09:42:16 <MP2E> athan, gregnwosu : you can certainly compile GHC to target Android, it's a bit painful at the moment but it does work
09:42:24 <rasen> https://wiki.haskell.org/Android
09:42:26 <MP2E> template haskell doesn't work for instance
09:42:37 <MP2E> or rather you can get it to work but through an evil hack
09:42:40 <athan> M2PE: Oh wow that's interesting, why wouldn't TH work?
09:42:41 <MP2E> aptly named Evil Splicer :P
09:42:46 <athan> Isn't that pre-core?
09:42:52 <athan> Ha!
09:42:55 <gregnwosu> yeah i would be selective as to what parts you implement in haskell
09:43:04 <dacm> gregnwosu: I'd like to at least do algorthimy and mathsy bits in haskell.
09:43:21 <gregnwosu> dacm: seems sensible to me
09:43:24 <MP2E> athan : because we don't have a way of running the haskell code to generate the TH splices, the GHC being used generates for ARM and you're on x86 for instance
09:43:43 <MP2E> athan: there's work towards fixing this so that we can have out-of-process template haskell
09:43:54 <MP2E> didn't make it into 7.10 but it's being worked on last i checked
09:43:57 <ahammel> So, I've got a collection of a few modules that depend on one another and all install to the same sandbox
09:44:09 <athan> but... couldn't you just --ddump-splices, then compile to ARM?
09:44:16 <athan> hmm
09:44:17 <MP2E> that's what evil splicer does :)
09:44:20 <athan> that's really interesting
09:44:21 <athan> Ha!!
09:44:25 <MP2E> uses host ghc to make splices, then cuts and pastes
09:44:29 <ahammel> whenever I run a `cabal configure` on one of the submodules, cabal insists that one of the third party modules isn't installed
09:44:31 <MP2E> it works well in practice
09:44:34 <MP2E> it's still not 'correct' though :P
09:44:35 <athan> I had no idea TH was runtime
09:44:51 <athan> MP2E: Thank you :)
09:44:57 <dacm> Does anyone know is parrallised haskell code has any chance of running on android?
09:45:11 <ahammel> and continues to insist on that until I do a `git clean -dfX` and rebuild the whole schmear
09:45:13 <thoughtpolice> That's still not full proof, because splices can mention things like 'sizeof (undefined :: CLong)' which will work, but be subtly wrong on different platforms
09:45:21 <MP2E> ^ exactly
09:45:38 <tommd> dacm: How are you getting to the 'running on android' phase?
09:45:43 <athan> Wow
09:45:52 <thoughtpolice> (Frankly I'm not convinced of the out-of-process TH approach either, but whatever, this issue can't be easily solved either way)
09:45:57 <athan> Do you know of any blog posts on this thoughtpolice or MP2E?
09:46:14 <tommd> dacm: That's rather critical.  Someone used Hugs to run on Android (!).  Some use this ghc-android fork which is rather hacky but works (ish).  What's your technique?
09:46:28 <dacm> tommd: Don't know yet. Do any of the ways support it?
09:46:52 <tommd> ghc-android is probably your best bet if any work at all.
09:46:58 <dacm> tommd: This is all speculative.
09:47:03 <MP2E> athan: there's not much out there but EvilSplicer has a blog post http://joeyh.name/blog/entry/Template_Haskell_on_impossible_architectures/
09:47:19 <athan> :D
09:47:28 <athan> thank you. Propellor looks effing rad, too
09:48:57 <ahammel> Are there flags you have to pass to `cabal configure` to make it work correctly when the sandbox is in a non-standard location?
09:49:01 <dacm> tommd: It wouldn't be the end of the say if it only actually executed on a single thread, as long a parallel algorithm still compiled.
09:50:28 <lf94> What is (x:xs) called?
09:50:39 <athan> lf94: Cons
09:50:42 <athan> :t (:)
09:50:43 <lambdabot> a -> [a] -> [a]
09:50:51 <thoughtpolice> dacm: Yes, you should be able to run GHC compiled programs in parallel on Android. I do believe the 'threaded runtime system' is supported fully there
09:50:51 <lf94> Thank you :)
09:50:55 <athan> > (1:[]) == [1]
09:50:56 <lambdabot>  True
09:50:59 <athan> ^ lf94 :)
09:51:00 * hackagebot diff-parse 0.2.0 - A parser for diff file formats  http://hackage.haskell.org/package/diff-parse-0.2.0 (mulby)
09:51:11 <athan> > (1:2:[]) == [1,2] -- lf94
09:51:13 <lambdabot>  True
09:51:18 <lf94> athan isnt it also used to extract elements
09:51:24 <athan> it is!
09:51:26 <lf94> hello (x:xs) = x
09:51:27 <athan> actually
09:51:30 <enthropy> MP2E: does EvilSplicer support ExpQ splices unlike zeroth?
09:51:31 <lf94> what is that called
09:51:33 <athan> what's strange
09:51:34 <supki> ahammel: yes, cabal --sandbox-config-file=PATH configure ...
09:51:44 <athan> is that (most) data constructors are bi-drectional
09:51:57 <lf94> so I've seen :)
09:52:10 <dacm> thoughtpolice: Vary cool. :-)
09:52:16 <dacm> s/vary/very/
09:52:19 <athan> if we capture the pattern in the parameter, then we can match a variable to it's contents, like a regex :)
09:52:29 <MP2E> enthropy: yep it does :P
09:52:33 <dacm> tommd, thoughtpolice: Thanks!
09:52:36 <MP2E> i ran into that issue when i originally used zeroth
09:53:22 <lf94> let (maybeYears:_) = drop 0 args
09:53:28 <ahammel> supki: cheers
09:53:29 <lf94> so this is totally wrong then right
09:53:34 <lf94> or no?
09:53:48 <ahammel> however, I'm still getting a 'Could not find module' message.
09:54:05 <athan> > fix \f (x:xs) -> x + 1 : f xs & [1,2,3,4] -- lf94
09:54:06 <lambdabot>  <hint>:1:5: parse error on input ‘\’
09:54:07 <tomphreek> enthropy: isn't it a bit like instead of having a Maybe type just throwing run time errors if something is null... which defeats the point.
09:54:10 <athan> shoot
09:54:23 <athan> lf94: We never really use args
09:54:34 <lf94> athan I need an argument from the user
09:54:38 <athan> (unless it's `getArgs` from the command line)
09:54:41 <lf94> Yes :)
09:54:43 <athan> ahh sorry
09:54:50 <athan> then yep! That's correct!
09:54:58 <athan> actually no
09:54:59 <athan> sorry
09:55:09 <athan> when you pattern match, you only do it in a parameter of a function
09:55:22 <athan> wait
09:55:24 <athan> sorry
09:55:28 <athan> I am spinning loops
09:55:34 <athan> lf94: You are correct :)
09:56:19 <enthropy> tomphreek: you can make the implementation (Maybe Double), or values outside the range become -Infinity or +Infinity
09:57:00 <sabreman> Ok so
09:57:18 <sabreman> I want to make a type, or something, that takes a char and returns a list of doubles
09:57:28 <sabreman> BUT, the lists of doubles are pre-defined for each char
09:57:33 <sabreman> like, a map more or less
09:57:55 <sabreman> ie, if i pass in a 'c', [5,6,3,4,5.34...] is always returned
09:58:05 <sabreman> and so on for other chars
09:58:10 <sabreman> How can i do this?
09:58:21 <lf94> athan: thank you X)
09:58:27 <ahammel> sabreman: why not an actual map?
09:58:34 <athan> no worries xD
09:58:47 <athan> lf94: Ping me if you get any weird type errors :)
09:59:20 <ahammel> or something like `foo 'c' = [5,6,3,4,5.34...]` and so on for other chars
10:00:18 <sabreman> ahammel: oh lol wtf
10:00:20 <sabreman> im stupid
10:00:22 <sabreman> Thanks
10:00:27 <ahammel> haha, no problem
10:00:33 <sabreman> totaly forgot i could do that with functions :P
10:00:42 <lf94> athan: nope, it worked. I want to understand something though.
10:00:43 <ahammel> don't forget the fall-though case
10:00:44 <lf94> athan: https://wiki.haskell.org/Avoiding_partial_functions#.28.21.21.29
10:00:45 <sabreman> (maps a tad out of my current range of knowlage)
10:00:48 <sabreman> yep
10:00:53 <lf94> athan: Look at "avoiding !!"
10:01:04 <lf94> Doesn't drop only return the suffix?
10:01:17 <lf94> How is this case statement capturing the elements being dropped?
10:03:30 <athan> It's not capturing the dropped elements, but rather the result suffix
10:03:35 <athan> because the suffix is also a list :)
10:03:47 <athan> (in `drop k xs of`...)
10:04:04 <athan> so `x` in that example is the head of the suffix
10:04:17 <athan> In the case statement, we're pattern matching on the result of `k xs`
10:04:21 <lf94> Yeah but if I wanted the first element, am I not losing it?
10:04:21 <athan> lf94 ^
10:04:38 <lf94> Oh I guess not eh
10:04:39 <lf94> haha
10:04:41 <lf94> genius
10:04:51 <lf94> I was starting to think I need "take"
10:05:03 <athan> :)
10:05:12 <athan> It's rediculously incredible
10:05:33 <lf94>     Pattern match(es) are overlapped
10:05:33 <lf94>     In a case alternative: [] -> ...
10:05:40 <lf94> It compiled but I got that warning
10:05:50 <lf94> I have a case statement underneat
10:05:52 <lf94> underneath*
10:06:08 <sabreman> ahammel: yay it works, thanks man!
10:06:11 <lf94> case maybeYears of (years:_) (blahblahblah) []
10:06:16 <athan> lf94: They should be in order from most general to most specific
10:06:37 <ahammel> sabreman: no problem
10:13:25 <Factionwars> Quick question
10:14:03 <ChristianS> how can i force a value to be evaluated? i want to do Map.insert key val, but evaluating val before it's actually added (to make sure it's valid)
10:14:23 <Factionwars> I want to add a new num funtion to the Matrix type, now how i can i add it. When i use instance Num a => Num (Matrix a) where it's already defined in the base source
10:15:24 <Factionwars> Or if somebody can tell my why matrix subtraction is not included
10:18:27 <elzair> Are there any good solutions for packaging cabal executables?
10:19:38 <HeladoDeBrownie> ChristianS, what do you mean by "valid"?
10:20:14 <predator217> how would one program a filter function for length indexed vectors in haskell?  In idris there is the dependent pair but as that is not available in haskell is there some form of workaround?
10:20:47 <HeladoDeBrownie> predator217, i doubt it's possible
10:21:01 <scott> predator217: my gut feeling is that you can't do it without dependent pairs
10:21:42 <HeladoDeBrownie> Factionwars, i don't quite understand your question, can you elaborate a little?
10:21:59 <predator217> HeladoDeBrownie, scott thanks I kind of feared that
10:23:31 <elzair> How does pandoc handle packaging?
10:23:33 <dmwit> content-indexed vectors...
10:23:57 <dmwit> Depending on how much boilerplate you're willing to do.
10:25:00 <predator217> dmwit: is that for me?
10:25:08 <elzair> I assume.
10:25:11 <dmwit> predator217: yes
10:25:13 <Factionwars> HeladoDeBrownie: in langauges like octave the subtract operator on Matrix -> Double -> Matrix is defined.
10:25:21 <predator217> what are content-indexed vectors?
10:25:36 <Factionwars> I think it's some undefined thing, because hmatrix also doesn't support it
10:25:37 <dmwit> predator217: Just like length-indexed, except instead of putting the length at the type level, you put *everything* at the type level.
10:25:51 <dmwit> predator217: Reflect the data in each spot, too.
10:26:02 <dmwit> predator217: Requires rewriting all data structures you ever plan on putting in such a list, of course.
10:26:41 <dmwit> predator217: There's a paper by Richard Eisenberg and others about faking dependently typed programming in Haskell that should give you some more details, if you're interested.
10:26:53 <predator217> dmwit: sounds a little bit boilerplate-y yeah, thanks for the hint
10:27:30 <enthropy> predator217: I would write the filter as: notReallyFilter fun :: HList [a,b,c] -> HList [Maybe a, Maybe b, Maybe c]
10:28:13 <predator217> enthropy: but that's for HList not length-indexed vectors
10:28:15 <enthropy> so then notReallyFilter is hMap which is "easy" to implement / get a type for
10:28:18 <enthropy> yes
10:29:38 <HeladoDeBrownie> Factionwars, ah, well matrix subtraction is not of the right type to be included under Num. however, there is mapMatrix, which can be used with (subtract n) for some n
10:31:31 <Factionwars> Thank you
10:31:40 <Factionwars> Looking into linear as well not
10:31:42 <Factionwars> now
10:38:25 <Haskellfant> I'm trying to understand how gadts are equivalent to finally tagless encodings, but I'm having trouble with functions that accept multiple arguments. Say I have a gadt T and replace it by a class T'. now every function that just takes one T becomes an instance of T'. But how are functions encoded that take multiple Ts, something like T -> T -> A?
10:39:12 <dfeuer> Haskellfant, what's a finally tagless encoding?
10:39:34 <Haskellfant> dfeuer: I got the name from https://oleksandrmanzyuk.wordpress.com/2014/06/18/from-object-algebras-to-finally-tagless-interpreters-2/
10:40:23 <Haskellfant> basically you replace your data type by a type class and the functions that operate on it become instance (at least that's my understanding)
10:40:42 <dfeuer> Hmm.
10:40:46 <dfeuer> Weird.
10:40:51 <Haskellfant> so the clasical dsl example of gadts becomes a type class Expr and you have maybe a PrettyPrint instance, a Eval instance and so on
10:41:15 <dfeuer> Whoa.
10:41:42 <Haskellfant> ekmett claims that all gadts can be replaced by finally tagless representations https://www.reddit.com/r/haskell/comments/md7e8/gadts_question/
10:42:03 <dfeuer> He's almost always at least half-right.
10:42:23 <Haskellfant> yep, that's why I think there needs to be a way and I'm just stupid
10:42:32 <dfeuer> Huh. Stuff with rank N types ......
10:43:28 <dfeuer> Interesting that Tekmo asked that question.
10:44:09 <Haskellfant> to be a bit more concrete, this is the code I have so far http://lpaste.net/119817
10:44:28 <Haskellfant> and I'm trying to convert zipForestWith to work on the typeclass encoding
10:45:16 <haskell-beginner> can anybody clarify what 'Either a b'  or 'Maybe a' are? for example 'Int', 'Float' are data types. Is 'Either a b' also a data type?
10:46:16 <scott> haskell-beginner: 'a' and 'b' are type variables that can be filled in by any data type. so Either Int Float and Maybe Int are data types
10:46:35 <scott> 'Maybe' by itself is called a type constructor. it takes a type like 'Int' and gives you the type 'Maybe Int'
10:47:09 <dfeuer> haskell-beginner, the terminology is a bit confusing in part because different people use the same words to talk about different things.
10:48:30 <haskell-beginner> @scott : thank you. So 'Either Int Float' are data type but not 'Either a b' is not a data type?
10:48:30 <lambdabot> Unknown command, try @list
10:48:31 <dfeuer> haskell-beginner, one way to be precise is by talking about the "kind* of a type.
10:48:40 <dfeuer> er ...
10:48:42 <dfeuer> "kind".
10:48:55 <dfeuer> So for example, Int has kind *, meaning that you can have values of type Int.
10:49:23 <dfeuer> Maybe has kind *->*, meaning that it's a sort of type function that takes a type and gives a type of kind *.
10:49:24 <scott> haskell-beginner: 'Either a b' is a data type, but with two unknowns that need to be filled in ('a' and 'b')
10:50:14 <dfeuer> Either has kind * -> * -> *, Either t has kind *->*, and EIther t u has kind *->*->*
10:50:23 <jle`> i'm not sure if "data type" is a word with rigorous definition
10:50:33 <dfeuer> *nod*
10:50:34 <HeladoDeBrownie> dfeuer, did you typo there?
10:50:36 <dfeuer> Yes.
10:50:37 <levi> haskell-beginner: Just to clarify, what is your understanding of what "data type" means?
10:50:40 <scott> haskell-beginner: when a type uses 'Either a b' that means it works with any 'a' or 'b', like 'Either Int Float' or 'Either String Int' - the function won't care
10:51:10 <dfeuer> The term "type constructor" is best reserved for type-level things that start with a capital letter.
10:51:13 <jle`> things like `Either a b` are types that values can be of.  You can have a value of type `Either a b`, but not a value of type `Either a`
10:51:20 <dfeuer> So Either, Maybe, and Int are all type constructors.
10:51:29 <jle`> values can only be of types that are kind *
10:51:31 <levi> Sometimes "data type" is just used as a synonym for "type", but other times people have something more specific in mind.
10:51:35 <dfeuer> Er..., and only have one word.
10:51:58 <dfeuer> Like   Maybe Int  and Maybe t  are not type constructors, because they have more than one piece to them.
10:54:35 <dfeuer> Haskellfant, your class has no instances. That makes it a bit hard for me to understand.
10:54:44 <HeladoDeBrownie> t is also not a type constructor, even though it's only got one "word"
10:54:55 <dfeuer> Because it doesn't start with a capital letter.
10:55:19 <dfeuer> Oh, and operators can also be type constructors, which is confusing.
10:55:23 <dfeuer> But oh well.
10:55:27 <haskell-beginner> @scott, @ dfeuer , @jle` :Thank you all. I got some clarity. It took me some time to read all the responses.
10:55:27 <lambdabot> Unknown command, try @list
10:55:31 <HeladoDeBrownie> i'm sure there must be a better way to formalize what is a type constructor but i can't think of it right now
10:56:03 * hackagebot olwrapper 0.4.1 - An OpenLayers JavaScript Wrapper and Webframework with snaplet-fay  http://hackage.haskell.org/package/olwrapper-0.4.1 (tomnobleman)
10:56:31 <HeladoDeBrownie> although it might be helpful to note that when you use data or newtype declarations, like data Foo = Bar or newtype Foo = Bar, the Foo is a type constructor and the Bar is a data constructor, both of which are created by the declaration
10:56:32 <dfeuer> HeladoDeBrownie, you can formalize them in terms of the way they're defined, I think.
10:56:43 <dfeuer> Yeah.
10:56:51 <jle`> i don't really have any problem saying that in Functor f => (a -> b) -> f a -> f b, f is a type constructor
10:56:59 <jle`> but maybe that is my own fault
10:56:59 <scott> I've thought of type constructors as things with a -> in their kind
10:57:10 <scott> and I think Int is just a type
10:57:19 <HeladoDeBrownie> jle`, so you use "type constructor" to mean "type of kind k -> k'"?
10:57:25 <dfeuer> jle`, but it's *not* one, and that will bite you because you can only pattern match on constructors.
10:57:39 <jle`> you can pattern match on type constructors?
10:57:45 <jle`> i guess with type families?
10:57:50 <dfeuer> Yeah.
10:57:54 <jle`> ah
10:58:00 <dfeuer> Also, instance heads distinguish.
10:58:07 <dfeuer> I think.
10:58:10 <jle`> that brings in a whole new dimension.
10:58:18 <dfeuer> You can't write   instance Foo (f a) where ....
10:58:28 <HeladoDeBrownie> i think you can
10:58:36 <dfeuer> Really?
10:58:38 <dfeuer> Huh.
10:58:42 <dfeuer> Let's try.
10:58:49 <jle`> i've written instances like that where f is constrained
10:58:51 <shachaf> For example, "instance Monoid [a]"
10:59:03 <jle`> i think dfeuer is referring to `f` as polymorphic
10:59:09 <HeladoDeBrownie> yes, i got that
10:59:16 <HeladoDeBrownie> oh, you were talking to shachaf
10:59:26 <shachaf> Ah. Still possible.
10:59:48 <dfeuer> Oh, you're right, FlexibleInstances allows it.
11:00:01 <dfeuer> I'm not sure what you can do with such a thing.
11:00:36 <shachaf> instance (Applicative f, Monoid a) => Monoid (f a)
11:00:38 <HeladoDeBrownie> so in haskell you can't, but in ghc haskell you can.
11:01:06 <dfeuer> shachaf, that looks interesting. How's it work?
11:01:27 <jle`> mempty = pure mempty
11:01:29 <exio4> mempty = pure mempty ; mappend = liftA2 mappend
11:01:30 <jle`> mappend = liftA2 mappend
11:01:34 <jle`> heh
11:01:48 <jle`> it's lawful cause laws
11:01:53 * jle` qed
11:03:46 <dfeuer> Nice.
11:03:58 <dfeuer> But
11:04:04 <Haskellfant> dfeuer: well the problem is that (as far as I understand it) function become instances so what I'm looking for is actually an instance corresponding to zipForestWith, but I added a really stupid one
11:05:01 <dfeuer> Haskellfant, so the Forest' class represents ... functions that take a forest?
11:06:28 <Haskellfant> dfeuer: that's my understanding of the finally tagless encoding
11:07:30 <dfeuer> Interesting.
11:07:54 <dfeuer> shachaf, that instance declaration seems kind of overlappy with all sorts of anything else.
11:08:38 <shachaf> Any instance declaration of the form "instance Foo (f a)" overlaps with everything.
11:09:57 <dfeuer> Yeah.
11:10:00 <dfeuer> Hrm.
11:10:50 <c_wraith> shachaf: it doesn't overlap with an instance for Int!
11:11:26 <shachaf> True. I shouldn't say everything else.
11:12:10 <dfeuer> c_wraith, it doesn't? That's ... horrible?
11:14:23 <dfeuer> Or not? I can't decide.
11:15:06 <enthropy> the f has to be an actual constructor, not something like type Id a = a
11:16:13 <Dobiasd> Hi, can somebody tell me, why this ( http://upload.wikimedia.org/wikibooks/en/6/65/Not-a-cat.png ) is not a category?   -   When checking for associativity of composition I get:   -   (f ° g) ° h = idA ° h   -   and   -   f ° (g ° h) = f ° idB   -   Now I whould think that   -   idA ° h = f ° idB   -   but this seems not to be the case, right? And if so, why? :)
11:17:08 <scott> Dobiasd: idA ° h = h and f ° idB = f, so you've shown f = h
11:17:30 <scott> Dobiasd: that's why it's not a category as drawn. there should just be one arrow which is both f and h
11:17:53 <Dobiasd> scott: Ok, thanks. So only one arrow between two objects is allowed?
11:17:57 <solrize> i thought that the selectors in a case expression all had to have the same type.  but it looks like they can be different branches of a gadt.  is that some kind of hack, or is it natural?
11:18:25 <scott> Dobiasd: no, there can be multiple arrows, but only if they are not the same arrow
11:18:33 <dfeuer> enthropy, yeah, I realized just now that type family things aren't allowed there, so I guess it's safe.
11:18:49 <scott> Dobiasd: for example, it makes no sense to draw the id arrows more than once. for the same reason, it makes no sense to draw f (aka h) more than once
11:21:00 <scott> Dobiasd: I believe if you added another arrow other than g from A to B, it could be a category. the fact that there is only g forces f = h
11:21:18 <shachaf> Or if you removed g, for instance.
11:21:32 <brycelane> Is there a way to make cabal install its dependencies when trying to enable the benchmarks in a cabal project?
11:22:12 <Dobiasd> shachaf: Ah OK, this would then be and example of a category with two arrows with the same type.
11:23:08 <Dobiasd> scott: ok, so the existance of f and h with the same type implies they are not the same. Then I understand why this is not a cat. thanks.
11:23:12 <dfeuer> Can someone explain in simple words what Control.Monad.ST.Class is about?
11:23:23 <dfeuer> (i.e., the MonadST class)?
11:23:24 <Dobiasd> So this would be a valid category with two arrows of the same type? http://i.imgur.com/bNZ5FTb.jpg
11:23:29 <dfeuer> It's completely mystifying to me.
11:23:42 <shachaf> Dobiasd: In this sort of diagram, yes.
11:23:56 <shachaf> Dobiasd: I.e. a diagram specifying an entire category's arrows and objects.
11:24:17 <Dobiasd> shachaf: Great, thanks.
11:24:21 <shachaf> Dobiasd: But note that usually when people draw a diagram with two objects/arrows that have different names, they *are* allowed to be the same.
11:24:59 <shachaf> I guess this case is special because you're defining an entire category here. f/g/h aren't variables, they're distinct things.
11:25:10 <dfeuer> Diagrams tend to need some words around them for context.
11:25:15 <dfeuer> Or equations, or whatever.
11:25:23 <dfeuer> Or so it seems.
11:25:47 <sinelaw> If I allow my type checker to generalize record fields during literal anonymous record assignment, am I somehow losing soundness?
11:25:59 <Dobiasd> dfeuer: OK, it was an exercise taken from here: http://en.wikibooks.org/wiki/Haskell/Category_theory#Hask.2C_the_Haskell_category
11:26:16 <sinelaw> this may be equivalent to the PolymorphicComponents. I'm not sure.
11:26:17 <dfeuer> Dobiasd, I'm not saying they always *have* such.
11:27:59 <shachaf> Dobiasd: That looks like a category, sure.
11:28:05 <scott> Dobiasd: re: http://i.imgur.com/bNZ5FTb.jpg, this is a category unless I'm rustier than I thought. it implies h . f = i = h . g, but that doesn't mean f = g
11:28:55 <hexagoxel> brycelane: `cabal install --dep --enable-benchmarks`
11:29:07 <shachaf> Drawing a graph and asking "is there a way to define composition such that this is a category" isn't something people do very often. :-)
11:29:12 <brycelane> hexagoxel: thanks.
11:31:19 <dfeuer> Anyone know about MonadST?
11:31:40 <dfeuer> It has some rather strong/strange warnings at the top that I don't understand.
11:31:52 <shachaf> Maybe it's more popular to draw a graph and then talk about the category whose arrows are paths through that graph.
11:34:14 <Dobiasd> OK, thanks again, guys. I will now continue to read the articles by Bartosz Milewski. ;-) Have a nice day.
11:41:34 <augur> so do existentials and type classes sort of solve the expression problem?
11:42:48 <augur> i think to do it properly, you end up having something like one data type for each constructor, or at least each batch of constructors you want, and instead of using true recursive types you do something like
11:43:36 <augur> data FooBase = forall a. FooClass a => Foo1 a | forall a. FooClass a => Bar1 a | ...
11:44:40 <geekosaur> I think it's just a different set of tradeoffs
11:45:01 <augur> and i guess somehow you want to define FooClass to have a kind of recurser, so that later classes can generically recurse??
11:45:03 <augur> hmm
11:45:43 <sdegutis> Aha! I finally have my first legitimate use for Haskell!
11:46:07 <sdegutis> I was writing a Budget app for myself, and I was going to use Swift and make it a native Mac app. But then I remembered NSTableView is awful.
11:46:16 <exio4> is there any reason to not use Haskell? ;)
11:46:17 <sdegutis> So now I'm going to make it be a small Haskell web app.
11:46:27 <Haskellfant> augur: as I'm trying to understand finally tagless encoding better, is that what you're referring to?
11:46:28 <Denommus> sdegutis: are you going to use GHCJS or Haste?
11:46:33 <sdegutis> Denommus: neither
11:46:41 <sdegutis> Denommus: although -- maybe one of them?
11:46:42 <augur> haasn: no :)
11:46:48 <sdegutis> Denommus: which one do you recommend?
11:46:51 <augur> whoops not haasn
11:46:55 <Haskellfant> :)
11:46:55 <augur> Haskellfant: no
11:47:24 <Denommus> sdegutis: good question. A good thing about GHCJS is that it generates a webkitgtk application if you compile your project with normal GHC
11:47:24 <Haskellfant> augur: so how do you want to use typeclasses and existentials to solve the expression problem?
11:47:35 <sdegutis> Denommus: hmm that'd be cool too
11:47:51 <sdegutis> I'm more concerned about the database.
11:48:06 <sdegutis> Which database is best for this?
11:48:21 <augur> Haskellfant: im not _entirely_ sure. i need to find some good examples of the expression problem to try to tackle
11:48:37 <Denommus> sdegutis: well, GHCJS and Haste are typically used for the front-end, in which I'd recommend SQLite
11:48:46 <Denommus> sdegutis: for the backend, I usually recommend Postgres
11:48:57 <sdegutis> Denommus: um, how can the front-end have a database?
11:49:05 <sdegutis> Denommus: the front-end literally means "being in a browser" for a web app
11:49:07 <Haskellfant> augur: what got me into wanting to understand finally tagless encoding better was this blogpost https://oleksandrmanzyuk.wordpress.com/2014/06/18/from-object-algebras-to-finally-tagless-interpreters-2/ which uses them for solving the expression problem. obviously they rely on type classes
11:49:25 <Denommus> sdegutis: well, modern front-end also has local storage
11:49:31 <Haskellfant> however he doesn't use existentials
11:49:53 <sdegutis> Denommus: oh that I don't care about
11:49:58 <sdegutis> I just mean the back-end storage.
11:49:58 <Denommus> sdegutis: anyway, Postgres is probably the best free RDBMS nowadays
11:50:00 <sdegutis> I'm running this locally.
11:50:16 <sdegutis> Denommus: that feels like overkill for a local-only web app
11:50:31 <Denommus> sdegutis: then use SQLite :-P
11:51:00 <Denommus> sdegutis: you may create your backend with GHC, and your front-end with GHCJS instead of JavaScript ;-)
11:51:28 <ReinH> Denommus: I would really like to see an existence proof for a modern front-end written in GHCJS
11:51:50 <Denommus> ReinH: I'm trying it, but some things are still lacky
11:51:56 <solrize> acid-state ?
11:51:59 <ReinH> Especially one that shares types, etc
11:52:07 <Denommus> ReinH: for instance: I wish to treat my DOM as a reactive value
11:52:20 <Denommus> ReinH: well, shared types are perfectly viable in Haste :-)
11:52:46 <ReinH> Denommus: Right, but I might just depend on react for that.
11:52:50 <sdegutis> GHCJS vs Haste?
11:52:55 <ReinH> So reasonable FFI would be important
11:53:24 <Denommus> ReinH: GHCJS has good FFI
11:53:53 <ReinH> That reminds me we should get luite on the Haskell Cast.
11:54:08 <sdegutis> Why would GHCJS need FFI?
11:54:21 <sdegutis> Would that be for external JS libs (e.g. jQuery)?
11:54:25 <Denommus> sdegutis: GHCJS is newer, havier and may lack some libraries, but it has the full power of GHC. Haste is lighter, more mature, has a complete web framework, but it lacks some things from GHC
11:54:31 <Denommus> sdegutis: yes
11:54:40 <sdegutis> Okay. I'll go with Haste.
11:55:03 <sdegutis> Scotty, Haste, and Lucid... now, what's a good lib for Sqlite3?
11:55:11 <Denommus> Haste is also probably easier to install
11:55:15 <Denommus> GHCJS needs cabal-install 1.22
11:55:27 <Geraldus> GHCJS is awesome (:
11:55:45 <Denommus> sdegutis: I think you can even use just Haste, it has a built-in framework
11:56:21 <sdegutis> Oh nice.
11:56:57 <gregnwosu> ok faily basic question but I want to be able to turn a POSIXTime into a Float or Double
11:57:05 <gregnwosu> cant figure out how to do it
11:57:25 <Geraldus> fromEnum . toEnum?
11:57:46 <gregnwosu> that easy? Dammit!
11:58:18 <Geraldus> If I'm not mistaken, POSIXTime should be an instance of Enum (:
11:58:46 <Geraldus> was struggling with UTCTime some time ago with similar issues
11:58:56 <Geraldus> :info POSIXTime
11:58:57 <gregnwosu> thanks Geraldus
11:59:04 <gregnwosu> yes it is an instance of enum
12:00:37 <Geraldus> not at all! now you have to learn about what exact magnitude this gives
12:01:14 <Geraldus> I suppose this will give you number of µ—seconds
12:02:36 * phaul is sad that he has to program in a lang where -1 is the error as a day job...
12:03:32 <ReinH> sdegutis: You might also consider Fay
12:03:35 <sdegutis> Is there a decent library for Sqlite?
12:04:03 <sdegutis> Persistent uses weird non-Haskell DSLs.
12:05:06 <ReinH> sdegutis: What do you mean by "weird non-Haskell DSLs"?
12:05:14 <sdegutis> ReinH: http://www.yesodweb.com/book/persistent
12:05:23 <ReinH> sdegutis: Why are you linking me to the entire book?
12:05:27 <ReinH> I know what peristent is.
12:05:39 <gregnwosu> Geraldus: i think its milliseconds from epoch
12:05:41 <sdegutis> ReinH: grep that page for "persistLowerCase|"
12:05:41 <ReinH> Can you show me an example of these weird DSLs?
12:05:46 <sdegutis> ReinH: that's the example.
12:06:15 <Geraldus> gregnwosu: did not certain for now (:
12:06:49 <augur> you know, with non-recursive data types, type classes alone suffice for solving the expression problem
12:06:58 <gregnwosu> Geraldus: you are right its something completely different
12:07:02 <gregnwosu> curses!
12:07:49 <sdegutis> I'll go with https://hackage.haskell.org/package/sqlite-simple
12:08:35 <ReinH> sdegutis: That isn't a "weird non-haskell DSL". It's template haskell.
12:08:49 <Yuras> why "aeson" is "aeson"? is there any story behind the name?
12:09:11 <Welkin> yes
12:09:13 <Geraldus> gregnwosu: ok, just take a look what other instances of POSIXTime you have
12:09:13 <ReinH> Yuras: json was taken
12:09:15 <Welkin> Aeson is the father of Jason
12:09:15 <c_wraith> Yuras: you mean the thing documented in the package itself?
12:09:19 <sdegutis> ReinH: oh, a GHC extension -- yeah, still weird
12:09:27 <Welkin> it says it at the top of the package description on hackage
12:09:34 <gregnwosu> Geraldus: Fractional, Real, RealFrac,
12:09:38 <ReinH> sdegutis: It is a bit weird, but it provides functionality you can't get without it.
12:09:44 <juanpablo____> Guys what's the difference between this http://www.stackage.org/package and this http://www.stackage.org/snapshot/nightly-2015-02-02
12:09:50 <sdegutis> ReinH: sugar maybe, but I doubt functionality
12:09:51 <juanpablo____> The first one includes packages the second one doesn't
12:10:17 <gregnwosu> Geraldus: Data, and Typeable seem interesting
12:10:33 <ReinH> sdegutis: I consider compile-time metaprogramming to be functionality, but I'm not interested in playing word games.
12:10:41 <Yuras> oh, I didn't noticed the "A note on naming" somehow... Thanks!
12:11:01 <sdegutis> ReinH: meh, there's a reason I left Clojure
12:11:15 <bluex> sde wanna help me on somthin
12:11:18 * ReinH shrugs
12:11:29 <sdegutis> ReinH: any time metaprogramming is used, I can't help but suspect that a little more creativity and imagination could come up with a better non-metaprogrammed API
12:12:15 <dfeuer> Data.Vector has a modify operation that attempts to do the modification in-place "if it is safe to do so" and otherwise copies. How does this work? How, if at all, can I make sure that it does?
12:12:27 <dfeuer> Should I just use mutable Vectors to be sure?
12:12:35 <ReinH> sdegutis: Ok, feel free to suggest improvements to persistent that remove the TH. It's not like they use it because they just enjoy metaprogramming.
12:13:06 <bluex> what do http://i.imgur.com/quBjaQ1.png
12:13:14 <ReinH> sdegutis: There are some things you just *can't* do without metaprogramming. It's not about creativity or imagination.
12:13:29 <sdegutis> ReinH: I'm skeptical of that assertion.
12:13:36 <sdegutis> ReinH: but either way, let's agree to disagree
12:14:01 <bluex> whats metaprogramming
12:14:08 <ReinH> sdegutis: I mean, it's pretty obvious that the Haskell language has limitations that TH is designed to overcome.
12:14:09 <bluex> i code in python, node, ruby
12:14:10 <Hijiri> programs making programs
12:14:12 <c_wraith> Did GHC 7.10 get explicit type annotation?
12:14:23 <Zoetrope_> bluex: Code that generates code basically, at compile time in Haskell
12:14:24 <ReinH> Like programmatically named top-level bindings
12:14:30 <c_wraith> err, explicit type assignment?  Was that what it was called?
12:14:31 <ReinH> or programmaticaly defined names at all
12:14:49 <gregnwosu> Geraldus: I think im just going to use Show , i feel cheap and dirty
12:16:50 <Yuras> dfeuer: iirc it uses the same approach as in list fusion. It just let `copy` and `feeze` fuse.
12:17:50 <dfeuer> Yuras, so what do I need to do to make sure it recognizes the use is single-threaded?
12:18:09 <dfeuer> That sounds somewhat harder than just writing in ST :-/
12:18:30 <dfeuer> If I want a Vector that might get very large, should I start with a small one and use `grow`, or should I start with a ridiculously huge one and rely on the OS over-committing?
12:18:39 <dfeuer> (Sorry, whole new question, that)
12:18:48 <Yuras> dfeuer: http://stackoverflow.com/questions/21138189/data-vector-modify-creates-vector-copies-on-each-iteration
12:19:27 <Geraldus> gregnwosu: in this case consider also formatTime function
12:19:46 <Geraldus> :t formatTime
12:19:47 <lambdabot> Not in scope: ‘formatTime’
12:19:48 <dfeuer> Thanks Yuras. It definitely sounds like I'll need to get my hands dirty.
12:20:00 <Geraldus> :t Data.Time.Format.formatTime
12:20:01 <lambdabot> Data.Time.Format.FormatTime t => System.Locale.TimeLocale -> String -> t -> String
12:20:09 <Yuras> dfeuer: yeah
12:20:11 <dfeuer> Still wondering about the growing thing though.
12:20:37 <dfeuer> Relying on overcommit could, I believe, give a pretty huge performance boost,
12:20:41 <dfeuer> but it's not so portable.
12:21:21 <Yuras> dfeuer: if you are sure they are not reused, you can mutate then, see Buffer attoparsec
12:21:34 <gregnwosu> got it RealToFrac
12:21:46 <dfeuer> (I'm talking about 2^32-element vector, where each element is 16 bytes)
12:22:10 <dfeuer> Yuras, eh? I'm not sure what you mean there.
12:22:13 <Yuras> dfeuer: attoparsec doubles the buffer each time it is not big enough
12:22:41 <dfeuer> Yuras, right, but doesn't that mean copying everything each time it grows?
12:22:59 <rasen> dfeuer: usually, yes
12:23:22 <Yuras> dfeuer: if you know it is not reused, then no
12:23:24 <dfeuer> Whereas if I just allocate 2^36 bytes of RAM, the OS should be able to play fun games with memory mapping instead?
12:23:59 <dfeuer> Yuras, there's clearly something important you're saying but I can't understand what it is.
12:24:02 <dfeuer> Explain?
12:24:07 <Yuras> one sec
12:24:45 <Yuras> dfeuer: https://github.com/bos/attoparsec/blob/master/Data/Attoparsec/Text/Buffer.hs#L15
12:25:00 <Yuras> it is a clever hack :)
12:25:25 <dfeuer> Yuras, that looks like a clever hack around the mutation in place deal.
12:25:44 <dfeuer> Since their "mutation" is restricted to appending.
12:25:45 <S11001001> dfeuer: 32-bit machine, what is this? https://github.com/facebook/flow/blob/master/hack/heap/hh_shared.c#L110-L132
12:25:54 <dfeuer> S11001001, no, a 64-bit machine.
12:26:04 <gregnwosu> Geraldus: thanks, realtofrac was another blind alley
12:26:06 <S11001001> dfeuer: I kid :)
12:26:12 <dfeuer> A (potentially) 2^32 element heap.
12:26:14 <juanpablo____> What if I want to use Stackage, but it doesn't include some of the packages I need?
12:26:40 <dfeuer> S11001001, the size of the heap may be up to the square root of the largest number representable as a Word.
12:27:02 <Geraldus> gregnwosu: glad it helped (:
12:27:12 <rasen> dfeuer: why?
12:27:46 <dfeuer> rasen, actually I'm off by a constant factor there.
12:27:58 <dfeuer> They're related though
12:28:14 <rasen> dfeuer: I can't see why square root?
12:28:23 <dfeuer> rasen, the heap is to hold prime numbers up to the square root of the maximum representable number.
12:29:13 <dfeuer> If I read it right, the prime number theorem indicates there are about 2^32/log_e (2^32)  of those.
12:29:19 <rasen> sorry. confused the heaps
12:30:25 <dfeuer> rasen, I'm attempting to make an O'Neill sieve a few times faster than the one in Math.Sieves.ONeill or whatever it's called.
12:31:00 <dfeuer> Her tree-based heap is a performance bottleneck.
12:31:24 <c_wraith> her tree-based heap is also not correct for other use cases..
12:31:31 <rasen> I'd missed first part about primary numbers and though about program's heap memory
12:31:40 <dfeuer> c_wraith, not correct how?
12:32:00 <dfeuer> rasen, I didn't state that part at first. Sorry for the confusion.
12:32:09 <rasen> it's ok
12:32:14 <kranius> I wish I had been exposed to Haskell earlier, I'm having so much fun :D
12:32:22 <c_wraith> I don't remember the details - I just remember that it doesn't always maintain the heap invariant in use patterns that differ from those of the sieving problem
12:32:29 <dfeuer> c_wraith, she borrowed hers from an ML textbook, so it seems unlikely to be entirely *wrong*.
12:33:33 <dfeuer> It *looks* pretty straightforward. In any case, it doesn't *matter* if it's correct in some other context.
12:35:43 <Yuras> dfeuer: oh, sorry, I misread you question. I thought it is a continuation of the previous one...
12:35:56 <dfeuer> No prolem.
12:37:57 <dfeuer> c_wraith, there is something strange about it indeed. That | wk<=vk=Br wk wv (insertPQ vk vv t2) t1   line must be what you're thinking of.
12:38:15 <dfeuer> Unless....
12:38:18 <dfeuer> Hmm...
12:38:20 <athan> ...something I never really noticed - there's no "abstraction" operator, is there?
12:38:24 <dfeuer> ?
12:38:37 <athan> (to create a parameter)
12:39:18 <HeladoDeBrownie> flip const?
12:39:20 <HeladoDeBrownie> @type flip const
12:39:21 <lambdabot> b -> c -> c
12:39:32 <HeladoDeBrownie> lambdas? \x -> …
12:40:11 <dfeuer> Wait, c_wraith, I got confused there. I actually don't think there's any problem.
12:41:23 <dfeuer> But a tree-based heap is just too large and modifying it takes too much allocation to really run this algorithm well.
12:46:10 * hackagebot mikmod 0.1.0.1 - bindings to libmikmod  http://hackage.haskell.org/package/mikmod-0.1.0.1 (evanrinehart)
12:49:54 <lachenmayer> is there any way to automatically derive Show for ADTs? I'm trying to debug a library with some hefty datatypes and i ideally don't want to mess around in its code adding "deriving Show" everywhere
12:50:41 <fmapE> lachenmayer: Is your datatype an instance of Data, by chance?
12:51:44 <lachenmayer> fmapE: Not that I can tell
12:52:01 <fmapE> lachenmayer: Well there goes my idea.
12:52:20 <lachenmayer> ie. :info TheType doesn't show me that it's deriving Data, is that what you mean?
12:52:25 <shachaf> lachenmayer: You can write a bunch of standalone "deriving instance Show ..." in one clump.
12:52:59 <athan> HeladoDeBrownie: :)
12:53:37 <bz> herskerl
12:53:56 <fmapE> lachenmayer: https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/deriving.html#stand-alone-deriving is what shachaf is talking about
12:54:19 <fmapE> shachaf: Can you say "deriving Show Foo" in a module besides the one where Foo is defined?
12:55:29 <geekosaur> yes
12:55:56 <geekosaur> not a good idea in general because orphans are bad, but in a program vs. a library there's usually no problem
12:59:05 <HeladoDeBrownie> athan, i honestly don't know if i answered your question :P
13:00:09 <lachenmayer> neat - adding the option and doing this in ghci now, seems to work. thanks fmapE and shachaf!
13:01:31 <platz> anyone know why cabal wouldn't build documentation when installing pkgs when setting documentation=True, haddoc/html=True in .caba/config?
13:01:42 <fmapE> lachenmayer: np :)
13:02:46 <platz> actually just turning on verbose will probably tell me
13:06:11 * hackagebot mikmod 0.1.1.0 - bindings to libmikmod  http://hackage.haskell.org/package/mikmod-0.1.1.0 (evanrinehart)
13:14:51 <dfeuer> Is GHC smart enough to merge multiple reads from an STRef?
13:15:40 <horny-sama> 's hood
13:16:00 <horny-sama> I am just wondering is there any good resources on how to actually System.Random
13:16:42 <horny-sama> like example code
13:16:44 <chirpsalot> horny-sama: what do you want to do with it?
13:17:06 <horny-sama> chirpsalot: generate random number within certain range?
13:18:22 <ab9rf> for what purpose do you want random numbers?
13:18:30 <athan> HeladoDeBrownie: It was good enough! - https://github.com/athanclark/ltext/paper/main.pdf :)
13:18:37 <ReinH> horny-sama: What have you tried so far?
13:18:45 <horny-sama> ReinH: finding tutorial on it?
13:18:55 <horny-sama> ab9rf: creating a strategy for a game
13:19:06 <ReinH> horny-sama: Have you tried looking at the library's documentation?
13:19:13 <mmachenry> horny-sama: is that a question or have you found a tutorial on it?
13:19:21 <ab9rf> horny-sama: you might want to use one of the seeded generators instead of system.random to avoid the IO dependency
13:19:46 <horny-sama> mmachenry: I found this so far https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/randoms
13:19:53 <ab9rf> oh, wait, randomgen is in System.Random
13:20:21 <ab9rf> why is that in System.Random?  System suggests stuff that interacts with the OS, and a pure seeded PRNG doesn't interact with the OS
13:21:47 <ReinH> ab9rf: module classifications frequently seem arbitrary
13:21:56 <ReinH> vis. Data and Control
13:22:00 <ab9rf> ReinH: i won't argue with that statement
13:22:06 <ab9rf> ReinH: yeah, that's frustrating,
13:22:58 <chirpsalot> horny-sama: well you can look at the state monad stuff if you want to use that, but you probably don't have to http://en.wikibooks.org/wiki/Haskell/Understanding_monads/State
13:23:00 <horny-sama> should I use Crypto.Random or System.RAndom
13:23:17 <ab9rf> horny-sama: crypto.random is probably overkill for a game
13:23:31 <horny-sama> ab9rf: good point
13:24:02 <chirpsalot> horny-sama: you can probably just use randomRs depending on what you want https://hackage.haskell.org/package/random-1.0.0.1/docs/System-Random.html#4
13:24:03 <ab9rf> horny-sama: also, often in a game you want predictably random behavior, which means you want control over seeds
13:24:40 <horny-sama> okay, I need to grab some bubble tea first before any more haskell
13:24:46 <horny-sama> coz my brain is mad
13:26:15 <athan> Is there a common UTF8 syntax for occours-checks?
13:26:19 <athan> something like \in?
13:26:41 <zq> x \elem ftv(t)
13:26:49 <dfeuer> What's the best way to deal with an unboxable reference in the ST monad? I see Data.Ref.Unboxed, but that looks a little old.
13:26:58 <zq> where \elem looks like E
13:27:05 <athan> Ahh! Thank you zq :)
13:27:05 <dfeuer> And very weird.
13:27:21 <athan> (what's ftv, zq?)
13:27:26 <athan> ahh
13:27:29 <athan> free type variables
13:27:30 <athan> thank you
13:27:32 <zq> athan: occurs check, right?
13:27:39 <athan> ><
13:27:45 <geekosaur> U+2208 "ELEMENT OF", unless you meant U+2203 "THERE EISTS"
13:27:50 <geekosaur> *EXISTS
13:28:27 <zq> x ∈ ftv(sigma)
13:28:29 <zq> voila
13:29:06 <dfeuer> Anyone? Would it maybe be sanest even to use an unboxed MVector with just one element?
13:30:39 <dfeuer> Or should I maybe go for StateT (ST s)? That smells funny.
13:33:02 <Welkin> why not MVar?
13:33:14 <horny-sama> I just went on a smoke break without smoking
13:33:30 <dfeuer> Welkin, those are for concurrent stuff with locking, right?
13:33:33 <dfeuer> I don't need that.
13:34:33 <Adeon> STRef?
13:35:24 <dfeuer> Adeon, the trouble with STRef is that, as I understand it anyway, any time I change the value I allocate a new box--there's no unboxing there.
13:36:17 <ReinH> horny-sama: randomR is pretty easy to use.
13:36:18 <Adeon> is that a problem
13:36:20 <ReinH> > fst .  randomR (1,5) $ mkStdGen 1
13:36:22 <lambdabot>  3
13:36:28 <dfeuer> Adeon, I believe that could come close to *doubling* the amount of allocation I do.
13:36:35 <Adeon> allocation is cheap
13:36:38 <Adeon> very cheap
13:37:45 <dfeuer> Adeon, in and of itself, yes. But when there are data structures you'd really like to be "stuck" in L1 cache, and you're using that L1 cache as a nursery instead, that's a bit of a problem.
13:39:23 <Adeon> you can try the various approaches you came up and profile
13:39:27 <dfeuer> True.
13:39:35 <dfeuer> And I will.
13:39:36 <sdegutis> I'm having trouble getting wxHaskell to work.
13:40:03 <ab9rf> sdegutis: join the crowd
13:40:11 <sdegutis> really?
13:40:18 <sdegutis> :(
13:40:18 <athan> zq: Is there a package I need to import for \elem?
13:40:33 <athan> (actually I'll just ask on #latex -.-)
13:40:35 <dfeuer> Adeon, FYI, in a previous project, I discovered that using ST just for a single STRef is significantly worse than using the strict State monad for the same thing. STRefs just kind of suck...
13:41:48 <zq> athan, \in
13:41:48 <osa1> uhh, I'm having a very annoying threadscope bug
13:41:55 <athan> crud
13:41:58 <athan> I'm already using that
13:42:01 <osa1> it doesn't allow me to scroll
13:42:11 <athan> Wouldn't the capital E work?
13:42:12 <dfeuer> Ouch?
13:42:53 <zq> for...latex?
13:43:49 <athan> yeah :\
13:44:36 <zq> you want "∈", right? that's \in.
13:46:56 <ReinH> sdegutis: Haskell's GUI story is pretty bad right now. :/
13:47:17 <sdegutis> Yeah. I'm currently debating between a small web UI (via scotty) or a simple command line interface.
13:47:23 <athan> noooo
13:47:24 <ReinH> GUI programming doesn't seem to get much love from the community.
13:47:26 <athan> I need E
13:47:30 <athan> zq: I
13:47:36 <athan> I'm already using \in for other things
13:47:40 <Welkin> design your own with opengl
13:47:41 <athan> Don't want to confuz :\
13:47:47 <ReinH> sdegutis: There was a thing to program reactive UIs using webkit iirc, one sec
13:47:48 <sdegutis> But I'm making a budget app, so being able to actually click a field and edit it directly is useful.
13:47:53 <jedai> You can try threepenny
13:47:54 <sdegutis> ReinH: cool thx
13:48:03 <ReinH> jedai: That's what I'm thinking of, isn't it?
13:48:06 <sdegutis> So that's one hit against doing a CLI.
13:48:07 <jedai> IT actually works ok
13:48:22 <ReinH> sdegutis: Seems like UIs are moving to the web anyway
13:48:23 <jedai> ReinH: didn't use webkit
13:48:30 <sdegutis> yeah :(
13:48:42 <Adeon> there is hsqml for a qt story
13:48:47 <ReinH> jedai: Ok, not webkit, but it does use "the browser" https://hackage.haskell.org/package/threepenny-gui
13:48:49 <jedai> ReinH: but it's a reactive GUI written in HTML so maybe
13:48:50 <Adeon> haskell+javascript I believe
13:48:51 <ReinH> FSVO "the browser" I guess
13:49:50 <zipper> ReinH: Yeah so I was going to learn Qt but figured it would be hard do anything stand-alone nowadays and I'm learning Yesod.
13:49:51 <ReinH> sdegutis: People seem to be doing interesting, non-trivial things with threepenny http://www.reddit.com/r/haskell/comments/1nidyp/whod_have_thought_i_made_a_serial_monitor_with/
13:49:56 <sdegutis> I'd almost just give up and do this in Swift if it weren't for NSTableView being so awful.
13:49:56 <athan> fudkit, i'll confuse ppl
13:50:03 <sdegutis> ReinH: thanks
13:50:10 <ReinH> sdegutis: np
13:50:17 <sdegutis> I found this  https://github.com/HeinrichApfelmus/threepenny-gui/blob/master/samples/Chat.hs
13:51:01 <zipper> ReinH: Dying for the next episode btw
13:51:08 <ReinH> zipper: :)
13:52:13 <ReinH> sdegutis: Also https://ocharles.org.uk/blog/posts/2013-12-07-24-days-of-hackage-threepenny-gui.html
13:55:14 <seubert> more of a lib than language question, but does anyone know if there is a way to do connection pooling with Database.PostgreSQL.Simple?
13:55:38 <seubert> or is it more of an exercise left up to the reader deal?
13:55:52 <phaazon> hey, where does c2hs puts its fail logs?
13:56:15 <phaazon> put*
13:59:20 <sdegutis> I think I'm opting towards Lucid and Scotty.
13:59:29 <sdegutis> What's a good Haskell data serialization library?
13:59:45 <sdegutis> I'd like to persist my super-cool Haskell data types across launches.
13:59:51 <burp> cereal :D
14:00:02 <tommd> binary
14:00:04 <Clint> binary, cereal, aeson, yaml, acid-state
14:00:15 <sdegutis> Um..
14:00:18 <sdegutis> That's a lot of choices.
14:00:28 <Clint> they all have their downsides
14:00:29 <tommd> Well it is a big area "serialization"
14:00:30 <sdegutis> Maybe I'll just do JSON.
14:00:39 <phaazon> aeson :3
14:00:43 <stephen_> carter: how's your numerical haskell project going?
14:00:47 <phaazon> it’s ridiculously fast
14:01:26 <sdegutis> Haha! Aeson!
14:01:28 <sdegutis> The father of JSON!
14:01:29 <burp> maybe you want something like "persistent"
14:01:42 <sdegutis> nevar.
14:02:00 <phaazon> sdegutis: never?
14:02:07 <phaazon> would you prefer dumb XML?
14:02:13 <sdegutis> dumb JSON
14:02:14 <sdegutis> yes.
14:02:17 <sdegutis> I like dumb.
14:02:23 <phaazon> then go for JSON
14:02:25 <phaazon> it’s simple.
14:02:26 <phaazon> fast.
14:02:27 <sdegutis> Thanks. Will do.
14:03:12 <phaazon> so, does anyone know where c2hs outputs logs?
14:03:23 <phaazon> I’m stuck on a fix I’d like to push for cuda
14:07:13 <phaazon> :(
14:07:59 <sdegutis> It's one thing to learn a brand new language. It's an entirely different thing to learn someone else's mini-language within that language.
14:08:14 <sdegutis> That's one big reason I defected from Clojure to Haskell.
14:11:44 <P4Titan> Hello all, is there some way within a do statement to have a bunch of String returning functions, and then at the end, get a large concatonated string of all the returns of the functions
14:12:23 <Clint> yes
14:12:25 <jedai> P4Titan: I'm not sure what you mean ?
14:12:25 <koala_man> P4Titan: Writer monad?
14:12:32 <hiptobecubic> P4Titan, you have to concatenate the results yourself unless you are using the Writer monad or something similar
14:13:02 <P4Titan> So what will this writer do
14:13:43 <P4Titan> What I am tring to do is: do \n fun "Hello" \n fun " World!" where fun returns a string in all caps, and somehow at the end get
14:13:47 <P4Titan> "HELLO WORLD!"
14:14:20 <sdegutis> P4Titan: you don't even need a monad
14:14:35 <P4Titan> ok, so how?
14:15:10 <sdegutis> P4Titan: map (\x -> x ()) [fn1, fn2, fn3]
14:15:16 <sdegutis> and then string-concat them (dunno what fn that is)
14:15:43 <sdegutis> P4Titan: oooh, this is homework, isn't it?
14:16:30 <P4Titan> no, ..., well I am working on my own project and I could obviosly do a concationation of a list of strings, but for stylists reasons, It would be better to somehow be in a do statement
14:16:39 <monochrom> this is a very strange question. I doubt that it's the real problem you have to solve. but the Writer monad is useful.
14:16:45 <phaazon> I think there’s a bug in c2hs…
14:16:46 <phaazon> :(
14:16:54 <phaazon> I can’t compile cuda…
14:16:59 <sdegutis> P4Titan: maybe make a monad for it so you learn how monads work
14:17:07 <tommd> phaazon: Minimum reproducible example?
14:17:23 <P4Titan> sdegutis: I tried doing that and still haven't gotten anything working
14:17:27 <phaazon> yeah, cabal install cuda.
14:17:31 <tommd> Well.. cuda is bigish and in flux sometimes so that isn't directly indicative of a bug in the compilation tools.
14:17:31 <phaazon> on windows
14:17:53 <phaazon> I’d like to find the error logs of c2hs
14:17:57 <phaazon> but there isn’t any
14:18:14 <phaazon> I can configure the package
14:18:19 <phaazon> but then when building
14:18:33 <phaazon> I just get an error
14:18:35 <tommd> Keep in mind cabal install anything isn't exactly a minimal example.  It would be good to find a code snippet that, when c2hs is ran, it fails somehow.
14:18:36 <phaazon> c2hs.exe: Error during preprocessing custom header file
14:18:59 <phaazon> hm yeah well
14:19:28 <phaazon> cabal update; cabal unpack cuda; cd cuda*; runhaskell Setup.hs configure; runhaskell Setup.hs build
14:19:31 <phaazon> on windows, it does fail.
14:19:46 <exio4> P4Titan: the Writer monad is what you probably need, but any details on what you are trying to do would be useful
14:19:56 <phaazon> I spotted similair issues in the issues history
14:20:05 <phaazon> similar*
14:20:41 <P4Titan> exio4: The details were the hello world example above, it is pretty simple really, I am looking at the Writer monad right now.
14:21:05 <kgadek> hi. could newtype have a GADT-style constraints? seems like no, GHC calls "A newtype constructor cannot have a context in its type". Is there way around this?
14:21:14 * hackagebot tidal 0.4.27 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.27 (AlexMcLean)
14:21:30 <phaazon> tommd: do you have an idea where c2hs usually puts errors in windows?
14:22:07 <S11001001> kgadek: what would coerce do?
14:22:42 <kgadek> S11001001: coerce? what do you mean?
14:22:42 <S11001001> kgadek: (I don't mean to say that the point of this restriction is coerce, just that the underlying properties of newtype gave rise to coerce in the first place)
14:22:51 <kgadek> ah.
14:23:07 <S11001001> kgadek: https://wiki.haskell.org/GHC/Coercible
14:23:08 <kgadek> S11001001: I want to limit the scope of some types
14:23:24 <kgadek> as an example
14:23:53 <kgadek> I want to have an Int tagged as `Wrapper a`
14:23:58 <kgadek> with some phantom a
14:25:06 <kgadek> (this only an example, I actually want to say: this is a tagged IntMap, but with keys of type `k` that has `Iso' k Int` so that I could use my newtype'd ints inside)
14:26:08 <tommd> phaazon: The console.  So this is really up to cabal where to put the error messages.
14:26:21 <tommd> phaazon: Have you tried -v3?
14:26:29 <phaazon> yeah
14:26:32 <phaazon> nothing more…
14:26:45 <phaazon> tommd: maybe the version of nvcc is not recent?
14:26:54 <phaazon> I see the cabal file has a warning about that
14:27:01 <phaazon> I’m using nvcc 0.22
14:27:11 <S11001001> kgadek: so what are you writing?
14:27:20 <S11001001> kgadek: I mean, your newtype definition
14:27:40 <sdegutis> Oh, duh! Why didn't I think of this before?
14:27:41 <sdegutis> ncurses!
14:28:00 <sdegutis> So excited.
14:28:08 <kgadek> S11001001: I think I can't explain myself well… ehh.
14:28:13 <geekosaur> if ncurses is the answer, I can't imagine the question
14:28:18 <kgadek> S11001001: I want to write something like: newtype MyGenIntMap k v = (Iso' k Int) => MyGenIntMap v
14:28:25 * geekosaur points at vty-ui
14:29:14 <sdegutis> geekosaur: I was trying to find a reasonable UI for my budget application
14:29:28 <geekosaur> there is very little that is reasonable about (n)curses
14:29:37 <geekosaur> look at vty / vty-ui
14:29:51 <sdegutis> thanks, doing
14:30:01 <sdegutis> Finding example.
14:30:35 <moghedrin> Yeah... vty-ui spoiled ncurses for me.
14:30:43 <moghedrin> Never again.
14:30:48 <phaazon> tommd: when it says that the “header file” is incorrect, which file is that?
14:30:51 <phaazon> cuda.h?
14:31:14 * hackagebot mikmod 0.1.2.0 - bindings to libmikmod  http://hackage.haskell.org/package/mikmod-0.1.2.0 (evanrinehart)
14:31:17 <S11001001> kgadek: So, it must be possible for this to work, for it to be a valid newtype: swapin :: (IntMap v -> IntMap v') -> (MyGenIntMap k v -> MyGenIntMap k' v'); swapin = unsafeCoerce.  What will happen with your example, with this definition?
14:32:45 <kgadek> S11001001: well, this gets ambiguous k/k' (or gets it resolved from context)
14:33:21 <S11001001> kgadek: it typechecks
14:34:12 <S11001001> kgadek: but what will happen when you call swapin (\im -> workwiththeim) somegenintmap?
14:34:18 <S11001001> kgadek: at runtime.
14:35:45 <S11001001> kgadek: to simplify matters, this is also required to work.  coerce' :: IntMap v -> MyGenIntMap k v; coerce' = unsafeCoerce.  I did not make a mistake by leaving off your Iso'.
14:35:55 <S11001001> kgadek: what will happen if you try to use coerce'?
14:36:14 * hackagebot tidal 0.4.28 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.28 (AlexMcLean)
14:36:17 <kgadek> S11001001: hmm ok, that would explode since no `Iso' k Int` would be suitable
14:36:57 <kgadek> S11001001: and this way it would be possible to - eg. - create `MyGenIntMap () v`
14:37:05 <kgadek> S11001001: is that what you mean?
14:37:44 <S11001001> kgadek: it doesn't matter because you could call this to make a MyGenIntMap Int Int from an IntMap Int and it *still* wouldn't work!
14:39:21 <kgadek> S11001001: I think I don't understand… could you elaborate?
14:39:37 <S11001001> kgadek: You would like the newtype data constructor to package up a context when you call it, and then unpackage the context when you pattern match it.
14:39:49 <S11001001> kgadek: yes?
14:40:01 <kgadek> S11001001: yes
14:40:12 <S11001001> right.  They are not allowed to do that.
14:40:18 <S11001001> They aren't allowed to do *anything*!
14:40:46 <kgadek> S11001001: by the "context" you mean information about the constraints on `k`?
14:41:01 <S11001001> kgadek: Any call to a newtype constructor, or pattern match extracting the value therein, can be deleted by the compiler.
14:41:04 <S11001001> kgadek: yes.
14:41:55 <S11001001> kgadek: A newtype is fully erased; it has the same runtime representation as the underlying value.  There's nowhere to put extra data of any kind, even a tag saying that you are in a newtype is 100% forbidden.
14:42:51 <kgadek> S11001001: okay. However I think it's only the data for the typechecker to constrain the usage. Then the erasure can happen and the runtime doesn't mind… wait.
14:43:10 <sdegutis> I can't get vty-ui to work at all.
14:43:11 <kgadek> S11001001: the runtime *does* mind since it must select appropriate iso, right?
14:43:40 <S11001001> kgadek: instances have a runtime representation; that's how sort can call < for the type you gave it
14:44:17 <kgadek> S11001001: okay, that makes sense
14:45:22 <kgadek> S11001001: I think I understand (to select right "iso-conversion" I must have runtime info). Thank you very much, that was a good explanation!
14:45:46 <S11001001> kgadek: more specifically, the compiler selects the appropriate Iso; it gives the runtime information about its selection by way of a runtime value, the "dictionary"
14:46:20 <S11001001> kgadek: so when you call sort, you also pass along compile-time-computed information about the location of the 'compare' function for that type
14:46:37 <kgadek> S11001001: oohhhh right! because it doesn't have to inline that (that could be harmful for size / performance)
14:48:02 <kgadek> S11001001: thank you again, that helps a lot
14:48:06 <kgadek> S11001001: :)
14:48:13 <S11001001> kgadek: no prob
14:51:33 <fread2282> since Category is polykinded, why can't I write an instance for `data Lens :: (*,*) -> (*,*) -> * where Lens :: (s -> (a,b -> t)) -> Lens '(s,t) '(a,b)`?
14:52:05 <fread2282> (I get `Couldn't match type `a' with '(a0, t0)`)
14:54:02 <fread2282> a has to be of kind (*,*), and `(,) is the only thing of that kind, right?
14:54:06 <sdegutis> lolololol
14:54:09 <sdegutis> "depends on * which failed to install"
14:54:13 <bramgg> This might seem really stupid, and I thought I understood Haskell IO, but I can't seem use hashUnique with newUnique on the same line (Data.Unique). It works if I create my unique on it's own with "<-", but trying to do it on the same line (>>=) is giving me errors. What do?
14:54:15 <sdegutis> a dozen times
14:55:08 <mniip> bramgg, how are you doing it in two lines, and how in one?
14:55:16 <S11001001> fread2282: (,) is of kind * -> * -> *
14:55:30 <mniip> (*,*) is not a kind...
14:55:58 <S11001001> @kind (Bool,Bool)
14:55:59 <lambdabot> *
14:56:10 <S11001001> @kind (,)
14:56:11 <lambdabot> * -> * -> *
14:56:22 <fread2282> S11001001: sure, but (Lens :: (,) * * -> (,) * * -> *)
14:56:32 <fread2282> @kind Category
14:56:33 <lambdabot> (k -> k -> *) -> Constraint
14:56:45 <bramgg> mniip: http://lpaste.net/8092256596605796352 I've tried a few varients
14:56:46 <fread2282> @kind Control.Category.id
14:56:47 <lambdabot> parse error on input ‘Control.Category.id’
14:57:00 <S11001001> fread2282: I know; I think you're mixing kind and type level though
14:57:12 <bramgg> I'm about to look really derpy, aren't I
14:57:56 <fread2282> @kind '(,)
14:57:57 <lambdabot> k -> k1 -> (,) k k1
14:58:37 <fread2282> @kind '(Bool,Bool)
14:58:38 <lambdabot> (,) * *
14:59:37 <fread2282> S11001001: this is using DataKinds, where '(a,b) is the only thing of kind (a,b) i think
15:00:11 <shachaf> fread2282: What about what's-it-called? Any?
15:01:18 <mniip> bramgg, hashUnique doesn't return an IO
15:01:30 <sdegutis> @kind Int
15:01:31 <lambdabot> *
15:01:32 <mniip> I don't see how those 2 lines would even work in a do block
15:01:38 <sdegutis> @type Int
15:01:39 <lambdabot>     Not in scope: data constructor ‘Int’
15:01:39 <lambdabot>     Perhaps you meant one of these:
15:01:39 <lambdabot>       ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
15:01:43 <sdegutis> @type 3
15:01:43 <lambdabot> Num a => a
15:02:11 <S11001001> fread2282: very useful, thanks
15:03:03 <sdegutis> @kind [Num]
15:03:04 <lambdabot>     Expecting one more argument to ‘Num’
15:03:04 <lambdabot>     Expected kind ‘*’, but ‘Num’ has kind ‘* -> Constraint’
15:03:04 <lambdabot>     In a type in a GHCi command: [Num]
15:03:17 <sdegutis> @kind [[[\x -> x ()]]]
15:03:18 <lambdabot> parse error on input ‘\’
15:03:23 <sdegutis> @kind [[[(\x -> x ())]]]
15:03:24 <lambdabot> parse error on input ‘\’
15:03:24 <sdegutis> weird bot
15:03:31 <fread2282> shachaf: Dynamic?
15:03:37 <exio4> there are no lambdas at the type level
15:03:45 <sdegutis> Oh
15:04:04 <sdegutis> @type [[[(\x -> x ())]]]
15:04:05 <lambdabot> [[[(() -> t) -> t]]]
15:04:22 <sdegutis> @botsnack
15:04:22 <lambdabot> :)
15:04:24 <Axman6> @kind [[[(x -> x ())]]]
15:04:26 <lambdabot> Not in scope: type variable ‘x’
15:04:26 <lambdabot> Not in scope: type variable ‘x’
15:04:33 <Axman6> :(
15:04:46 <shachaf> fread2282: No, the GHC thing that's in every kind.
15:05:24 <bramgg> mniip: yeah I know :/ I must misunderstand something. How would you do it?
15:05:30 <S11001001> fread2282: maybe the problem is that the 'a' in id : Lens a a is rigid.
15:05:54 <S11001001> fread2282: i.e. the implementation supposes that it's '(a, b) for some a, b
15:06:36 <sdegutis> I screwed up my Cabal installation.
15:06:44 <sdegutis> Now tons of pckages won't install.
15:07:05 <fread2282> `id :: forall (a :: k). cat a a`
15:07:52 <mniip> bramgg, fmap hashUnique newUnique
15:08:13 <mniip> although that's pretty useless because you only generate one unique value
15:08:52 <fread2282> S11001001: if it supposes it's some '(a, b) then `Couldn't match type `a' with '(a0, t0)` shouldn't be an issue though I think
15:08:55 <bramgg> mniip: is there a better way? Just seems like a waste of space to have two lines when I just want to create a unique ID.
15:08:58 <bramgg> thanks btw
15:09:15 <fread2282> shachaf: i don't know
15:09:20 <mniip> bramgg, I don't think you understand how Unique works
15:10:09 <mniip> oh
15:10:10 <mniip> maybe it's me
15:10:13 <mniip> nevermind
15:10:19 <shachaf> fread2282: Yes, GHC.Exts.Any :: k for any k
15:10:42 <mniip> bramgg, well you realize that  newUnique returns an IO
15:10:45 <mniip> which you can't get rid of
15:13:39 <bramgg> yes
15:14:00 <mniip> can you rpovide a larger example
15:14:06 <mniip> like where are you using the unique
15:15:17 <Luke> anyone know how to get flycheck-haskell to use a cabal sandbox? the code looks like it's supposed to work automatically
15:15:22 <S11001001> fread2282: I don't think it will suppose that though
15:15:35 <S11001001> fread2282: it's not required to make an inhabited choice, I mean.
15:15:43 <bramgg> Ehh nevermind it's not that important
15:16:33 <fread2282> S11001001: sure, but is there a way to get it to (just plain coerce doesn't work, `:~:`?)
15:17:46 <S11001001> fread2282: that sounds like it'd be a constraint on id
15:18:42 <fread2282> shachaf: i don't see how Any effects this?
15:19:09 <shachaf> I don't know what this is, I was typing on my phone before and missed the beginning.
15:19:18 <shachaf> fread2282: I was talking about 14:57 <fread2282> S11001001: this is using DataKinds, where '(a,b) is the only thing of kind (a,b) i think
15:19:34 <fread2282> since Category is polykinded, why can't I write an instance for `data Lens :: (*,*) -> (*,*) -> * where Lens :: (s -> (a,b -> t)) -> Lens '(s,t) '(a,b)`?
15:19:40 <fread2282> (the beginning)
15:19:48 <edwardk> fread2282: write 'id'
15:19:53 <edwardk> wake me when you're done
15:20:16 <edwardk> ghc doesn't know that the only inhabitants of kind (*,*) are of the form '(a,b) for some a and some b
15:20:26 <edwardk> tried it ;)
15:21:06 <edwardk> Any inhabiting every kind (used to) actively get in the way of this, and it hasn't been a priority since
15:22:36 <shachaf> edwardk: Used to?
15:23:10 <ReinH> shachaf: Maybe Ed is making a Mitch Hedberg joke? It still does, but it used to too?
15:23:50 <edwardk> ghc 7.10> :info Any    ==> type family Any :: k 	-- Defined in ‘GHC.Prim’
15:24:34 <edwardk> Any still is an inhabitant
15:24:46 <edwardk> but it doesn't have the ability to be matched on
15:25:16 <meoblast001> does anyone here use haskell-vim-now for vim that knows how to disable those silly replacements of symbols with unicode?
15:25:19 <S11001001> Any in Haskell is like Nothing in Scala :)
15:25:21 <shachaf> Ah. That's an improvement, I suppose.
15:25:29 <shachaf> Like _|_
15:26:14 <meoblast001> oh.. hm.. i found it
15:31:17 * hackagebot mikmod 0.1.2.1 - MikMod bindings  http://hackage.haskell.org/package/mikmod-0.1.2.1 (evanrinehart)
15:37:03 <fread2282> where can I find the code for epigram 2?
15:38:07 <lachenmayer> hmm, I'm sure I'm just being silly, but how come Aeson doesn't have a ToJSON instance for ByteString? (it used to!)
15:39:10 <lachenmayer> ah, according to an issue on github, "ByteString instances were removed because they allowed people to try and insert arbitrary binary data that JSON can't handle."
15:42:51 <codygman> How does this work (using pcre-light)? http://lpaste.net/119832
15:43:50 <mauke> {1} is redundant
15:44:24 <geekosaur> codygman, index 0 is what matches the whole regex, index 1 is what you captired
15:44:26 <fread2282> for an arbitrary type defined in say agda (or another dependently typed language) with one variant (no sum types), can I package up it's constructor and eliminator as an iso?
15:44:51 <codygman> So what do I do if I want to capure every number in the string?
15:44:58 <geekosaur> since your regex doesn't match anything beyond the capture, the capture is superfluous (and the parens also don't do useful grouping)
15:45:23 <fread2282> or as something like a prism for >1 variant?
15:46:20 <shachaf> fread2282: I'm not sure I understand your question.
15:46:32 <mauke> well, I can tell you how to do it in perl
15:46:40 <geekosaur> if you intended the ^ to match after newlines then you wanted to compile the regex with the multiline flag. I have no idea what you intended with the {1} but it does nothing whatsoever
15:47:11 <codygman> I thought {1} meant "match one occurence of previous pattern"
15:47:29 <geekosaur> yes, but any given pattern matches one occurrence
15:47:36 <geekosaur> so what is {1} for?
15:48:11 <geekosaur> "instead of matching just one occurrence, match one occurrence"
15:48:30 <mauke> it's like wrapping a for loop around a statement, but the loop iterates over [1 .. 1]
15:49:36 <joness> > do 1 + 2
15:49:38 <lambdabot>  3
15:49:42 <joness> what is up with that!?
15:49:42 <c_wraith> is foldMap the crush operator?
15:49:57 <mauke> joness: lenient desugaring?
15:50:03 <c_wraith> joness: do-notation translates an expression from one syntax to another, without any typechecking involved
15:50:12 <fread2282> shachaf: in haskell (is this true for GADTs?), we can package up all one-field one-variant data types as an isomorphism and have the full power of pattern matching (modulo compiler support for sequencing), and >1 field with (,). is this true for agda (with Σ instead of (,))?
15:50:14 <c_wraith> joness: if the final expression typechecks, the do notation is accepted
15:50:19 <codygman> geekosaur: I'm not sure tbh. Using multiline still didn't help: http://lpaste.net/119832
15:50:29 <geekosaur> as for the rest, match does not support a /g, you're supposed to loop. (Perl's m//g also requires you to loop)
15:50:45 <mauke> codygman: you're probably using the wrong function
15:50:46 <zq> :t do 1 + 2
15:50:47 <lambdabot> Num a => a
15:50:52 <zq> :t do 3
15:50:53 <lambdabot> Num a => a
15:50:55 <joness> so because there is no ; or newline there, bind operator is not called?
15:51:00 <c_wraith> joness: correct
15:51:14 <codygman> geekosaur: You have to apply the match to every line of a file for instance?
15:51:37 <geekosaur> looks like it, yes
15:51:46 <mauke> geekosaur: this case doesn't require a loop in perl (or javascript)
15:51:47 <geekosaur> this is probably part of why it's "light"
15:52:15 <fread2282> or: if I bundle up the constructor and eliminator into an isomorphism, can I always? do I lose expresiveness with the eliminator?
15:52:38 <P4Titan> Hello all, I am trying to restrict the instance a monad type I am making to hold monoidic values only, how would that be done since GHC is giving me Monoid exprects * -> * when I give it *
15:52:58 <mauke> you'd just do 'my @matches = $str =~ m/\d+/g;' or m/\d+$/mg or whatever
15:53:19 <geekosaur> true, I'm thinking of a more general case
15:53:24 <fread2282> maybe I should ask this in #agda...
15:53:43 <monochrom> P4Titan: show complete unabridged verbatim code. put it on lpaste.net
15:53:45 <glguy> P4Titan: That sounds like something you don't get to do. Perhaps you can paste some code to lpaste
15:53:52 <mauke> IIRC the javascript version is something icky like var matches = str.match(/\d+/g) || [];
15:54:59 <P4Titan> Here it is http://lpaste.net/119834
15:55:03 <geekosaur> in any case, pcre-light doesn't appear to do more than one match at a time
15:55:09 <shachaf> fread2282: I'm not sure what you mean by package up.
15:56:17 <monochrom> P4Titan: it can only be "instance Monad TexyllBody", and you cannot impose the restriction "but I insist b to come from a Monoid"
15:56:50 <P4Titan> Ok, is restrict bad terminology and how would I do it?
15:57:07 <lpsmith> @tell simg those errors are coming from postgres itself:  you are going to have to find the documentation for the syntax that Postgres expects on the money type,  and you are going to have to generate that syntax.
15:57:07 <lambdabot> Consider it noted.
15:57:27 <c_wraith> P4Titan: well, there's the rmonad package for restricted monads...  https://hackage.haskell.org/package/rmonad
15:57:39 <cap10> Anyone interested in creating a better language?
15:57:49 <eiffel76> Why is (_, _) different from (_,_) in http://lpaste.net/119835 ?
15:57:57 <monochrom> "restrict" is the right word
15:58:02 <fread2282> cap10: everyone is :)
15:58:14 <shachaf> eiffel76: You tell us.
15:58:16 <fread2282> yea, that's wrong... let me try again: can any constructor/eliminator pair be represented as an isomorphism to something?
15:58:19 <P4Titan> monochrom: Then, is it possible to do what I want?
15:58:19 <monochrom> the standard Monad type class simply can't do it, that's all.
15:58:36 <monochrom> or perhaps s/can't/doesn't/
15:58:47 <shachaf> fread2282: Do you have a clear definition of "constructor/eliminator pair"?
15:58:56 <shachaf> I think the answer is maybe right now.
15:58:59 <cap10> fread2282: Why stop at that? We create it now.
15:59:02 <eiffel76> space is an operator?
15:59:19 <P4Titan> That does not sound too good, there has to be some way, is that rmonad thing viable?
15:59:19 <eiffel76> (Just started going through school of Haskell on fpcomplete FYI)
15:59:34 <mauke> eiffel76: huh?
15:59:39 <geekosaur> sort of. it's application
15:59:42 <shachaf> eiffel76: What I mean is: How did you come to the conclusion that they're different?
15:59:54 <shachaf> You told us they're different.
16:00:12 <eiffel76> mauke: (_,_) doesn't compile, while (_, _) does
16:00:20 <cap10> fread2282: I can't hear you.
16:00:21 <fread2282> cap10: sure :)
16:00:24 <geekosaur> ummmm
16:00:27 <mauke> eiffel76: (_,_) compiles fine
16:00:33 <eiffel76> ....
16:00:36 <eiffel76> hm
16:00:47 <mauke> > case (1,2) of (_,_) -> ()
16:00:48 <lambdabot>  ()
16:00:52 <cap10> fread2282: I will hear your strong opinions on the matter.
16:01:05 <cap10> By the way guys, tuples are retarded and you should be ashamed.
16:01:22 <monochrom> tuples are not retarded.
16:01:41 <fread2282> cap10: I am playing around with dependent types right now
16:02:03 <eiffel76> well that's odd - my fpcomplete web GUI now compiles it. Must have been a server timeout error, not a compile error. Thanks!
16:02:05 <mcjohnalds> I just saw some haskell code: `data Union (r :: [*])` I've never seen syntax like that before, what is it?
16:02:20 <geekosaur> kind syntax
16:02:40 <geekosaur> and, well, you're getting into deep water :)
16:02:56 <mcjohnalds> I'll look that up, thanks
16:02:57 <cap10> fread2282: agda or idris?
16:03:27 <fread2282> cap10: neither? I'm working on a toy one of my own :)
16:04:00 <cap10> fread2282: oh, you're a doer
16:04:05 <glguy> P4Titan: You can actually do what you appear to be trying to do.
16:04:20 <glguy> You seem to want this type: newtype TexyllBody b a = TexyllBody b
16:04:21 <P4Titan> With RMonad?
16:04:33 <glguy> aka Const or Constant
16:05:18 <glguy> I'm basing that on the sketch of an implementation you provided for return and >>=
16:05:41 <glguy> (using the normal Monad)
16:05:51 <P4Titan> Ok, I added that extra letter and am getting a bunch of errors about cannot deduce type
16:06:39 <glguy> err, I guess you can't make const a monad :)
16:06:50 <glguy> You can make it an Applicative though!
16:07:15 <glguy> Either way what you're trying to do isn't a Monad or an RMonad given the way you're trying to use mempty in return and mappend of the function in bind
16:07:37 <glguy> We should probably roll back to "what are you trying to do"
16:08:09 <P4Titan> Why? I am tring to make a Writer type like construct, just with 1 instead of a tuple of 2 args
16:08:30 <P4Titan> I want the >>= to append c to b as it passes on
16:12:34 <glguy> The type of (>>=) :: Monad m => m a -> (a -> m b) -> m b -- How are you going to be able to mappend the 'a' in the first argument with the 'b' result of the second?
16:14:18 <P4Titan> a is a String, b is a String, the f in the middle gives m (a ++ "result from f")
16:14:32 <glguy> No, you don't get to force a and b to be the same
16:14:36 <glguy> you have to deal with them being different
16:14:52 <glguy> the type of >>= allows the caller to pick the types a and b
16:15:15 <Jimmy__> I'm very new to Haskell and have a question about list comprehension, if I may.
16:15:26 <P4Titan> Well, how does the Writer monad do its jobs>
16:15:32 <Jimmy__> I have: cities = [("Atlanta","Georgia"),("Miami","Florida"),("Orlando","Florida"),("San Francisco","California")]
16:15:33 <P4Titan> s/>/?
16:15:39 <Jimmy__> select k c = [if True then (x,b) else (x,b) | (x,b) <- c]
16:15:52 <glguy> P4Titan: It has a pair of values, the accumulated value as well as a value of the type
16:16:02 <Jimmy__> Is there a way to do something like "else null"
16:16:12 <Jimmy__> as in, else do nothing.
16:16:20 <glguy> newtype Writer i a = Writer (i,a)
16:16:21 <geekosaur> if is an expression, not a statement
16:16:22 <Hijiri> you can put predicates on the right hand side of the |
16:16:29 <Hijiri> if you are trying to do that
16:16:39 <Hijiri> you can't just do nothing
16:16:41 <Hijiri> because you need a value
16:16:49 <Jimmy__> My desired output is like: select (\(_,y) -> y == "Florida") cities) == [("Miami","Florida"),("Orlando","Florida")]
16:17:06 <Hijiri> (it would be more correct to say that you can't just be nothing)
16:17:12 <glguy> P4Titan: ;So you get      >>= :: Writer i a -> (a -> Writer i b) -> Writer i b --   (i,a) -> (a -> (i,b)) -> (i,b)
16:17:17 <Jimmy__> Ok, right, I need a value. I come from C-land so I forget. :)
16:17:44 <glguy> P4Titan: Since the 'i' types stay the same it can mappend them
16:17:47 <Hijiri> You can put predicates on the right, like [e | x <-xs, p x]
16:18:04 <Hijiri> > [x| x <- [1..], even x]
16:18:06 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
16:18:09 <mauke> > [ x | (z, y) <- [("Atlanta","Georgia"),("Miami","Florida"),("Orlando","Florida"),("San Francisco","California")], y == "Florida" ]
16:18:11 <lambdabot>  [x,x]
16:18:11 <P4Titan> Ohh, ok, so Monad forces them to be different
16:18:16 <Jimmy__> Hijiri, ok, thanks. So my boolean expression would go on the right?
16:18:18 <mauke> > [ x | (x, y) <- [("Atlanta","Georgia"),("Miami","Florida"),("Orlando","Florida"),("San Francisco","California")], y == "Florida" ]
16:18:19 <lambdabot>  ["Miami","Orlando"]
16:18:38 <Jimmy__> whoa that is a sweet bot.
16:18:42 <P4Titan> And what I was tring to do did not allow different types
16:18:48 <mauke> > [ x | (x, "Florida") <- [("Atlanta","Georgia"),("Miami","Florida"),("Orlando","Florida"),("San Francisco","California")] ]
16:18:49 <lambdabot>  ["Miami","Orlando"]
16:19:59 <Jimmy__> mauke you're getting one result
16:20:22 <Jimmy__> oh wait i see Miami and Orlando, nevermind.
16:21:53 <orzo> is there any extension to give some quick sugar for Bool cases, some kind of very concise syntax to turn a pattern into a True/False value?
16:22:22 <c_wraith> orzo: if the type has prisms, I bet lens can do that.
16:23:06 <mcjohnalds> Ok, I know what kinds are but I don't know what `data Union (r :: [*])` means in english
16:23:08 <shachaf> lens can do it with prisms/traversals/etc., sure.
16:23:14 <codygman> Can anyone show me an example of a simple match using regex-tdfa? The library seems rather unapproachable :/
16:23:18 <mcjohnalds> Can someone give a rough description
16:23:36 <c_wraith> mcjohnalds: the second type paramater of union is a promoted list of types.
16:24:02 <c_wraith> mcjohnalds: look into the DataKinds extension for lots of examples of things like that.
16:24:19 <orzo> what does the lens syntax look like?
16:24:21 <glguy> > has _Left (Right ())
16:24:23 <lambdabot>  False
16:24:24 <mcjohnalds> c_wraith: Ok cool thanks!
16:24:50 <c_wraith> mcjohnalds: also, there's a paper named something like "giving types a promotion" that explains the design of the extension in greater detail.  It's very readable.
16:25:05 <orzo> say i want to inline a predicate to filter or something, maybe the pattern is (InterestingConstructor {}) ?
16:25:15 <c_wraith> mcjohnalds: http://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf  that paper
16:25:28 <shachaf> There's no simple syntax to turn a pattern match into a function that returns Bool.
16:25:36 <mcjohnalds> c_wraith: Thanks, I've been struggling to understand some of the other haskell papers
16:25:40 <shachaf> Other than (\x -> case x of P -> True; _ -> False) or something along those lines.
16:26:05 <shachaf> (\case P -> True; _ -> False) with that extension.
16:26:21 <orzo> oh
16:26:27 <orzo> well i was aware of that one
16:26:33 <jle`> a special syntax would have come in handy many times but i don't know if it's worth complicating the language
16:27:07 <shachaf> Bool is a bad idea anyway.
16:27:09 <HeladoDeBrownie> patterns as values seems like it would make this and other interesting things easy
16:27:30 <jle`> ah yes that too
16:27:30 <HeladoDeBrownie> isn't that basically what prisms are anyway?
16:27:38 <orzo> patterns as values?  Is that an upcoming extension?
16:27:43 <jle`> using bools is a code smell
16:27:46 <HeladoDeBrownie> orzo, no, just wishful thinking
16:28:01 <shachaf> Prisms and lenses are like first-class patterns.
16:29:05 <orzo> heh
16:29:21 <orzo> i don't understand the aversion to bool
16:29:31 <orzo> prelude certainly encourages it
16:30:31 <mniip> is there a flipped infix version of fmap or liftA
16:30:32 <ReinH> Prelude also encourages using [Char] to represent text.
16:30:35 <jle`> boolean blindness, information loss, etc.
16:30:36 <orzo> is there a bool-avoiding idiom for me to learn to replace using any of the prelude functions that take predicates?
16:31:00 <jle`> for example, consider this `listToMaybe`:
16:31:14 <joness> mniip it is coming in ghc 7.10, called &. it is already in lens. but no need to get lens just for a simple function like that
16:31:28 <orzo> the one i was using in particular when i wanted the smaller syntax was 'partition'
16:31:31 <jle`> listToMabe xs | null xs = Nothing | otherwise = Just (head xs)
16:31:46 <jle`> > listToMaybe [1,2,3]
16:31:47 <joness> mniip unless you're already using lens for other things
16:31:48 <lambdabot>  Just 1
16:31:49 <mniip> joness, ampersand-dot?
16:31:50 <glguy> joness & is different, that's flipped $
16:31:51 <mniip> or just &
16:32:05 <jle`> orzo: do you seea better way to write that?
16:32:07 <glguy> (<&>) :: Functor f => f a -> (a -> b) -> f b
16:32:08 <glguy>   	-- Defined in ‘Control.Lens.Lens’
16:32:13 <joness> oh right, my mistake. & is flipped $
16:32:19 <Jimmy__> mauke, if I have this declaration, how would I change it? select :: ((a,b) -> Bool) -> (BinaryRelation a b) -> (BinaryRelation a b)
16:32:28 <joness> indeed you want <&>, a flipped version of <$>
16:32:30 <orzo> a betterway to do a 'partition' operation, sure
16:32:37 <jle`> i mean, to write listToMaybe
16:32:41 <jle`> other than what i wrote earlier
16:32:54 <Jimmy__> select k cities = [a | (a,b) <- cities, k] is throwing a type error on k
16:32:56 <jle`> instead of using null xs, a Bool
16:33:27 <orzo> lambdaCase could do the listToMaybe nicer i thikn
16:33:37 <markmc_att> How to interpret this type sig:
16:33:40 <markmc_att> wrapBinaryArithOp :: String -> (Integer -> Integer -> Val) -> Val
16:33:54 <jle`> orzo: the answer is to not use a boolean, but use pattern matching :P
16:34:06 <jle`> listToMaybe [] = Nothing; listToMaybe (x:xs) = Just x
16:34:21 <mniip> markmc_att, it takes a String, and a function (taking 2 integers and returning a value), and returns a value
16:34:32 <orzo> i'm familiar
16:34:32 <HeladoDeBrownie> markmc_att, you can imagine that it's a function with two inputs, a String, and another function (one of type Integer -> Integer -> Val, and returning a Val
16:34:41 <HeladoDeBrownie> +)
16:34:42 <osa1> wow, my programs spends 82% of the runtime GCing http://lpaste.net/119839 :->
16:34:44 <jle`> orzo: do you see why the bool version is wasteful?
16:34:45 <joness> listToMaybe == headMay in Safe package
16:34:48 <markmc_att> Hm, that's what I thought thanks have some other syntax probl
16:34:52 <markmc_att> thanks!
16:34:55 <jle`> you check for null and then use head
16:35:01 <orzo> i understand
16:35:05 <jle`> you get it twice
16:35:12 <jle`> and you also have to "prove in your mind" that head works
16:35:21 <jle`> in this case, the compiler guaruntees that your function is total
16:35:32 <jle`> and also, you don't do double-work
16:35:41 <jle`> the test for being empty or not *gives you* the first value
16:35:44 <jle`> implicity
16:35:56 <jle`> when you use null, you get the first value (if there is one), and throw it away
16:36:09 <jle`> (minus laziness)
16:36:10 <orzo> i like patterns generally, but i was using 'partition' and writing a boolean predicate seems the thing to do
16:36:11 <mniip> pattern matching > some things
16:36:15 <HeladoDeBrownie> technically null only needs to—okay :P
16:36:38 <jle`> booleans are an answer to some problems, but they are an answer to a lot less problems than people think
16:36:41 <ReinH> jle`: There's also the part where your first listToMaybe is not the same function as your second one in a rather annoying way
16:37:01 <jle`> and most cases of boolean usage are actually code smells for information loss, repitition, and waste
16:37:10 <jle`> ReinH: yes?
16:37:20 <ReinH> jle`: what is its type?
16:37:37 <ReinH> Oh wait, you used null, not xs == []
16:37:41 <ReinH> nvm
16:37:45 <jle`> :t null
16:37:46 <lambdabot> [a] -> Bool
16:37:47 <jle`> ah yeah
16:37:51 <jle`> haha. that would have been even worse ;)
16:37:52 <orzo> is it smelly with partition or not?  If it is, i'm in the market for your more clever solution
16:38:08 <ReinH> Yeah, one problem with using booleans is that you often have to introduce an unnecessary Eq constraint
16:38:09 <jle`> :t partition
16:38:10 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
16:38:14 <jle`> it depends on what you want to do in the end
16:38:22 <jle`> in the bigger picture
16:39:05 <mniip> jle`, would you justify ByteString.null usage?
16:39:17 <jle`> sometimes, your "predicate test" does work to prove something is true or not
16:39:24 <jle`> and later on, you have to do that exact same work to get a result
16:39:26 <sinnsat> Can you pattern match on GHC.Arr or Data.Array.MArray?
16:39:34 <ReinH> jle`: but you can't write a polymorphic partition using pattern matching
16:39:36 <ReinH> so there's that
16:39:40 <Hijiri> is there a way to unthielemann haddocks
16:39:44 <shachaf> When your language is more expressive, booleans are even less useful.
16:40:33 <jle`> yeah, there's also the thing about type systems where you could write an entire function to return a bool, and to the compiler, it'd be identical to a function where all o the answers are wrong
16:40:41 <jle`> about haskell, at least
16:40:53 <ReinH> null and similar are useful for abstract types
16:40:55 <jle`> for example, i could swap the results of a definition of (>), and it'd still typecheck
16:41:08 <ReinH> they don't export constructors so you can't pattern match
16:41:30 <orzo> i do have constructors for my partitioning
16:41:45 <orzo> still seems like i need to write a predicate
16:41:46 <jle`> if you do a lot of work to find out whether or not something is true or false, and you need to repeat that work later to get an answer (ie, null and head), then bools are still kind of annoying
16:42:26 <ReinH> partition and filter are good uses of booleans
16:42:30 <ReinH> since you can't write them without them
16:42:46 <jle`> i like to use (a -> Maybe b) for filters
16:43:00 <jle`> and then catMaybes or something
16:43:05 <orzo> mapMaybe
16:43:07 <monochrom> if you do a lot of work to find out whether you have a Just, then if yes, do the same amount of work to get the content of the Just cell, then I have good news for you.
16:43:09 <jle`> yes that too
16:43:18 <ReinH> jle`: Well, without Bool or a surjection of Bool.
16:43:19 <orzo> i use that
16:43:25 <monochrom> GHC will optimize it to doing that work just once :)
16:43:33 <jle`> ;D
16:43:54 <orzo> i also use the list monad to filter
16:44:05 <ReinH> jle`: the point is that those functions can't be fully generalized
16:44:16 <orzo> but i think partitioning means it's time for Bool
16:44:20 <jle`> yes, you can't generalize it in every case
16:44:24 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/104783/
16:44:30 <jle`> it isn't a dogma/hard rule
16:44:39 <jle`> but if it happens, it's an occasion for a second look/pause
16:44:46 <jle`> *if you use a Bool
16:44:56 <ReinH> jle`: "you can't generalize it in every case"... that's what generalize means...
16:45:10 <jle`> heh, then, "you can't generalize" works the same for my point :)
16:46:20 * hackagebot http-conduit-downloader 1.0.24 - HTTP downloader tailored for web-crawler needs.  http://hackage.haskell.org/package/http-conduit-downloader-1.0.24 (VladimirShabanov)
16:48:45 <zq> alright. could someone explain why i should bother thinking about profunctors?
16:49:47 <monochrom> only someone who know your future can tell you whether and why you should bother
16:50:45 <Lokathor> i have a situation where i need to chain Maybe functions together
16:51:07 <monochrom> >>= and >=> are helpful. also =<< and <=<, if you want them flipped
16:51:15 <Lokathor> but, depending on where the failure is, the return value is a different error string each time
16:51:23 <Lokathor> have i screwed myself out of using the maybe monad?
16:51:30 <monochrom> then you have to go Either
16:51:43 <Lokathor> can't in this case, it's several library calls in a row
16:51:47 <c_wraith> the errors package contains handy combinators for Maybe -> Either
16:51:55 <Lokathor> hnnnn
16:51:58 <Lokathor> hmmm*
16:52:04 <EvanR> you can chain Either e's
16:52:14 <c_wraith> Lokathor: like note in https://hackage.haskell.org/package/errors-1.4.7/docs/Control-Error-Util.html
16:52:57 <Lokathor> hmm
16:53:56 <orzo> i can motivate contravarient functors a bit, if you like, zq. Haven't used profunctor specifically though.
16:54:31 <c_wraith> as far as I know, the only major use profunctor has found is as a theoretical basis for unifying everything in the lens hierarchy.
16:54:45 <edwardk> they also work nicely for folds
16:54:52 <c_wraith> It's a very general class, though.  It applies to a lot of things.
16:55:36 <dacm> Can "where" syntax be used alongside "do" syntax? (Or is that silly?)
16:55:50 <zq> orzo: well contravariant functors aren't constrained to being contra/co functors in 2 arguments, so i can see the utility in that too
16:56:25 <monochrom> no, "where" doesn't attach to "do"
16:56:36 <zq> edwardk: would you mind dropping a few more hints?
16:56:48 <c_wraith> dacm: You have to be careful with the rules..  where clauses can only be added to equations or pattern matches.
16:57:15 <c_wraith> err, expressions or branches of a case expression
16:57:24 <dacm> Ok. Thanks guys.
16:57:27 <c_wraith> .. equations or..  English is hard.
16:58:01 <edwardk> zq: data Fold a b = forall x. Fold (x -> b) (x -> a -> x) x -- gives you a data type for a left fold that is contravariant in a covariant in b, it is a comonad, applicative, profunctor, etc.
16:58:09 <dacm> Is there some simple way to achieve what I want? Can I just use the "<-" syntax or is that just for when doing something involving a monad?
16:58:48 <jle`> you can use `let`?  i'm not totally sure waht you want
16:59:09 <orzo> when you design a higher order function that implements a big picture and you want to pass in a collection of little-picture function details, it's wise to consider if you can design a reasonable contravarient functor on a record containing the little-picture function arguments
16:59:18 <dacm> jle`: Oh ok. Thanks!
16:59:41 <Lokathor> you guys make me feel like a kid with a tonka truck in a sandbox across the street from a real construction site :P
16:59:46 <codygman> Is there a better way to use regex-tdfa than this? code: http://lpaste.net/119840
16:59:47 <jle`> do { let x = "foo"; y <- f "foo"; g y }
16:59:59 <jle`> dacm: for the "rest of the block" x is an alias for foo
17:00:01 <jle`> er, "foo"
17:00:14 <jle`> you can e even use it in the middle of the block too for great effect
17:00:29 <jle`> like, you can use `y` in a `let` statement after the second line there
17:01:11 <jle`> remember the key rule...if you have x :: a, then let y = x will amke y :: a .   if you have x :: IO a, then y <- x will make y :: a
17:01:34 <zq> edwardk: i'm a little confused on what the third argument of the Fold ctor represents
17:01:34 <jle`> and if x :: IO a then let y = x will make y :: IO a as well.  "let" is basically just a definitoin/alias
17:01:45 <ReinH> :t foldl
17:01:46 <lambdabot> (b -> a -> b) -> b -> [a] -> b
17:02:05 <zq> ReinH: that's not useful at all with the forall x.
17:05:11 <benzrf> bab bab
17:07:39 <dacm> jle`: That makes sense and was just what I was looking for. Thanks! :-)
17:08:09 <ReinH> zq: why not?
17:08:51 <ReinH> zq: the (x -> b) lets you avoid "looking at" the x, so it can be existential.
17:09:16 <ReinH> Otherwise it is a foldl plus a "post-processing" function.
17:10:47 <zq> ReinH: how would you construct a Fold as edwardk defined it?
17:11:04 <ReinH> e.g., sum = Fold id (+) 0
17:11:37 <edwardk> zq: the forall x is the seed, the a's are the inputs, b's are the result you get after applying a tweak to the 'x'
17:12:08 <edwardk> the need for the tweak rather than have the 'b' in foldl's signature be the one we use for the second arg is that it enables it to be applicative, etc.
17:12:23 <zq>  /trigger add irc_join modifier 2000|weechat_print "${tg_tags} =~ ,irc_join," "/.*/${tg_prefix}\t${color:237}${tg_message_nocolor}"
17:12:37 <Lokathor> okay, I have a strict Text, and I need a Lazy ByteString. encode and decode seem to only go between Text/ByteString and not strict/lazy
17:12:54 <edwardk> zq: foldl f z = Fold id f z
17:13:02 <edwardk> or rather thats the analogy
17:13:11 <ReinH> Right, you still have to apply the Fold
17:13:31 <edwardk> to apply a fold
17:13:40 <ReinH> But now you get to defer the dicision of strict vs lazy, etc
17:13:45 <ReinH> s/dicision/decision
17:13:48 <edwardk> fold (Fold g f z) = g . foldl' f z
17:13:51 <edwardk> yeah
17:14:15 <edwardk> well, the major motivation for me for these is that i can make multiple folds and fuse them
17:14:22 <edwardk> sum / length
17:14:22 <edwardk> etc
17:14:25 <ReinH> yep
17:14:31 <ReinH> That's where the magic happens
17:14:46 <ReinH> zq: look at Tekmo's foldl library, it's the same thing.
17:14:48 <edwardk> zq: http://hackage.haskell.org/package/folds-0.6.2/docs/Data-Fold-L.html
17:14:54 <ReinH> Or Ed's folds
17:15:06 <edwardk> http://hackage.haskell.org/package/folds-0.6.2/docs/Data-Fold-M.html does it with a monoidal fold like foldMap
17:15:19 <edwardk> http://hackage.haskell.org/package/folds-0.6.2/docs/Data-Fold-R.html builds fusable foldr's
17:15:34 <Rotaerk> I made a foldy function yesterday http://lpaste.net/119778
17:15:38 <ReinH> zq: Also https://www.fpcomplete.com/user/edwardk/cellular-automata/part-2 talks about them
17:16:56 <orzo> can ghc be taught to fuse folds more aggressively to the point that profunctor for that purpose is obviated?
17:17:50 <edwardk> orzo: well the idea is more that the fold captures up all the things up want to talk about into one data type
17:18:17 <edwardk> the initializer, the action of how you update your state and how you finalize it. its the 3 parts of an HMAC or CRC all bundled in a nice data type
17:18:46 <edwardk> if you don't use it you're stuck like the crypto packages we have, giving 3 names to the parts
17:19:34 <ReinH> You can also do clever things like delayed finalization to make a composable, resumable fold, or something
17:21:15 <ReinH> That's where I start to get confused.
17:24:59 <EvanR> hmm. where other languages use the term "Native" (ffi) haskell uses "Foreign"... are these words supposed to mean the same thing
17:25:17 <EvanR> if so why are there two
17:25:22 <EvanR> if not whats the difference
17:25:47 <EvanR> i cant tell if they are opposite or the same
17:27:26 <monochrom> firstly, they refer to the same thing. secondly, opposite words are chosen because of opposite perspectives.
17:28:00 <EvanR> ok
17:28:09 <EvanR> what is the perspective of "Native" ?
17:29:03 <benzrf> EvanR: Native means that the code is native to the cpu
17:29:10 <benzrf> EvanR: foreign means that it's foreign to haskell
17:29:27 <monochrom> self-insecure, "the language I normally use is of second-class on computers"
17:29:49 <monochrom> "therefore, the language I normally use is not native"
17:30:29 <monochrom> a person who is paranoidly aware that the language is usually interpreted, seldom compiled, tends to be like that
17:30:47 <monochrom> whereas, in reality, it shouldn't matter
17:30:59 <EvanR> that clears some things up thanks
17:31:51 <shaykha> would a function map2 :: (a->b->c)->[a]->[b]->[c] such that map2 f (x:xs) (y:ys) = ((f x y) : (map2 xs ys)) be the same as zipWith? They seem to have the same type signature
17:32:30 <shachaf> shaykha: You forgot the cases where the arguments are empty lists.
17:32:50 <shachaf> But you can't conclude that functions are the same from the type. There are other standard functions with that type.
17:32:55 <shaykha> oh yeah, map2 f [] _ = [] and map2 f _ [] = []
17:33:45 <shachaf> If you're asking whether your function is zipWith, the answer is yes.
17:33:48 <shachaf> @src zipWith
17:33:49 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
17:33:49 <lambdabot> zipWith _ _      _      = []
17:33:55 <shachaf> But you can't conclude that from the type.
17:34:16 <shaykha> I understand what you are saying; I asked the question pretty hastily
17:34:22 <shaykha> thank you
17:34:43 <eer> hi all - the old hackage server had a way to download a text file listing all uploads made to the server; it wasn't index.tar.gz - it was just a simple text file. Is that still available?
17:35:04 <shachaf> eer: Maybe ask in #hackage
17:35:34 <eer> ok will do
17:35:56 <sgronblo> is there a term for a graph represented using a function neighbors :: Node -> [Node] ?
17:38:55 <josephle> http://en.wikipedia.org/wiki/Adjacency_list
17:39:36 <sinnsat> is there no safe version of (!) for Arrays, as in: I get "Nothing" instead of an Exception for out of range?
17:40:05 <sinnsat> the Safe package only works for Lists
17:41:28 <ab9rf> i'm sure there's a safe method somewhere
17:41:56 <ab9rf> which "array" implementation are you refering to?
17:42:24 <ab9rf> (!!) is defined only on lists.
17:42:29 <sinnsat> GHC.Arr
17:44:11 <zq> alright
17:45:45 <edwardk> ReinH: to 'resume' a fold. make Fold a (Fold a b) from Fold a b -- which is duplicate.
17:46:12 <edwardk> ReinH: to do that you just need to figure out how to write x -> Fold a b for the x that is the one internal to the first fold. but thats easy.
17:46:24 <enthropy> does open recursion get in the way of inlining?
17:46:31 <edwardk> duplicate (Fold g f x) = Fold (Fold g f) f x
17:46:54 <edwardk> just like duplicate (Store f s) = Store (Store f) s
17:47:41 <edwardk> in fact if you squint hard enough StoreT'd Env and Fold have a lot in common, they are the same except Fold, in the end, existentially quantifies over a variable.
17:47:55 <c_wraith> my read of the "Essence of the Iterator Pattern" paper suggests that it's kind of the spiritual leadin to what lens has become.
17:48:13 <edwardk> c_wraith: pretty much. it is our old testament ;)
17:48:49 <glguy> A++ would read again
17:48:51 <ReinH> edwardk: Oh right, isn't that just duplicate?
17:48:58 <ReinH> oh right, you said that
17:49:01 <ReinH> yeah, it's a comonad, duh
17:49:44 <gcganley> is that paper a good read? I've had it on my ipad for a while but never bothered to even look at whats it about
17:49:55 <ReinH> gcganley: It seems to come up a lot
17:50:20 <gcganley> ReinH: what is it about? recursion? looping?
17:50:37 <ReinH> gcganley: um... iterators? :p
17:50:51 <c_wraith> gcganley: you could see it as being about how traverse does everything. :)
17:51:04 <gcganley> ReinH: ive never used iterators...
17:51:10 <gcganley> ReinH: nor heard of them
17:51:36 <edwardk> In the beginning the Haskell committee made mapM, and McBride and Paterson looked upon mapM and saw that it was good; and they divided the light from the darkness.
17:52:18 <edwardk> gcganley: it is a paper that shows remarkable foresight
17:52:51 <gcganley> i guess ill just have to read it
17:53:08 <edwardk> there is a sort of middle to the paper where Jeremy has some doubts and is wondering if we need all sorts of extra conditions and laws, etc. that all have since been proven unnecessary
17:53:12 <ReinH> It also uses the banana split theorem, which is adorable
17:53:17 <edwardk> =)
17:53:46 <c_wraith> edwardk: might you call that portion something like being lost in the desert for years?
17:53:50 <ReinH> edwardk: Lots of Jeremy's papers seem to have that quality of foresight...
17:54:00 <edwardk> c_wraith: pretty much =)
17:54:14 <gcganley> Jeremy who...
17:54:19 <edwardk> Jeremy Gibbons
17:54:45 <gcganley> huh... I've never heard of him. Ill print 20 of his papers
17:54:55 <gcganley> free ink and paper baby
17:55:35 <gcganley> whats the linux command for print? is it lp?
17:55:42 <ReinH> gcganley: he's kind of a big deal.
17:55:48 <c_wraith> I think I've used lpr for printing
17:56:08 <geekosaur> lp or lpr depending on whether you're using cups or not
17:56:35 <gcganley> crap i have to install CUPS. its the 4th time this month ive had to reinstall lol
17:56:39 <ReinH> gcganley: editor in chief of JFP, vice-chair of SIGPLAN, chair of oxford's computer science department, etc
17:57:11 <gcganley> ReinH: why have i not heard of him before...
17:57:28 <ReinH> gcganley: Does your dwelling bear any resemblance to a rock?
17:57:59 <gcganley> ReinH: my roof does
17:58:09 <ReinH> gcganley: indeed indeed
17:58:43 <sdegutis> Is there a Haskell lib to transform Haskell to CSS, similarly to how Lucid transforms Haskell to HTML?
17:58:59 <gcganley> sdegutis: look at clay, half decent
17:59:09 <gcganley> never used it before though lol
17:59:23 <gcganley> besides some playing around
17:59:33 <ab9rf> "transform Haskell to HTML"?  how would that work
17:59:42 <ReinH> ab9rf: an EDSL for generating HTML
17:59:48 <ab9rf> ReinH: oh
17:59:49 <gcganley> ab9rf: hes using an EDSL
17:59:57 <ab9rf> that makes so much more sense
18:00:12 <ReinH> A particularly nice one, imo
18:00:31 <gcganley> ReinH: do you have any projects up that use it?
18:00:34 <ab9rf> one of my first haskell experiences involved one of those, not sure which one, but yeah
18:00:40 <gcganley> ReinH: up on github i mean lol
18:01:00 <sdegutis> Lucid is awesome
18:01:01 <ab9rf> i first encountered haskell while thrashing about for methods for parsing HTML & XML
18:01:11 <ReinH> gcganley: I don't.
18:01:27 <sdegutis> Why does everyone keep using OverloadedStrings ?
18:01:31 <ab9rf> i didn't understand a damn bit of the haskell
18:01:34 <ReinH> sdegutis: no one pays me to write HTML in Haskell as of right now. ;)
18:01:35 <gcganley> ReinH: that makes me sad...
18:01:35 <ab9rf> sdegutis: convenience
18:01:36 <sdegutis> Why not just make the thing take a String?
18:01:42 <ab9rf> sdegutis: because TYPES MATTER
18:01:46 <sdegutis> orite
18:01:56 <ReinH> Because String is a pretty poor type for text
18:01:57 <gcganley> ReinH: what if i gave you $10?
18:02:04 <ab9rf> yeah, it reall yis
18:02:09 <nshepperd> because Text is hip and way cooler than String
18:02:16 <ab9rf> Text is much more efficient :)
18:02:35 <ab9rf> String is a chain of dingleberries, each containing one character
18:04:47 <ab9rf> sdegutis: having different types for different things that could be represented by strings but are fundamentally different things makes it possible to, for example, write web frameworks that are automatically safe from SQL injection and XSS attacks
18:05:10 <ab9rf> eek, a disemvowelment
18:09:32 <hiptobecubic> yuckaroo
18:15:14 <codygman> I have a large list of emails and I'd like a list of those that are duplicated. Perhaps using a map with foldr M.empty adjust to increment how many times something is found?
18:17:36 <pacak> codygman: filter ... . toList  . M.insertWith (+) 0 ...
18:17:44 <pacak> (+) 1
18:24:41 <simon> pacak, codygman: or using a Data.Set.Set instead of a Data.Map.Map Email Count.
18:25:45 <enthropy> and how does Set give you the count?
18:28:02 <Cale> simon: He only wants to know which are duplicated
18:30:32 <monochrom> I recommend computing sha256 checksums of the emails, and first find duplicate checksums, before committing to comparing emails.
18:31:42 <monochrom> also, you probably don't need to keep counts, do only keep "set of things seen so far", and ask "now I am fetching one more, is it in the set already?"
18:32:37 <monochrom> so at the end it's going to be actually "Map Checksum [Email]"
18:32:53 <monochrom> or "Map Checksum (Nonempty_List Email)"
18:34:03 <sinnsat> I have an infinite cyclic data structure which depends on laziness, but it constructed via an indirection layer and array/list lookups, because the knots are not known at compile-time. When converting from the indirect data structure to the direct one (as in: tying the knots) I have a lot of unsafe operations like (!) or (!!). But, I cannot use Maybe, because it breaks laziness => stack overflow. Does anyone have a hint?
18:38:24 <hiptobecubic> you probably don't want to construct it that way
18:38:30 <hiptobecubic> certainly not if you're using !!
18:38:38 <hiptobecubic> assuming you care about performance at all, i mean
18:39:44 <sinnsat> Because of performance, I construct it that way. Or do you refer to the use of lists?
18:41:02 <sinnsat> I tested it on very complex input and it performs well.
18:41:21 <sinnsat> (I also have a C version, which is slightly faster ofc)
18:42:49 <monochrom> I wonder why (!) works while a safe version doesn't, because both are equally strict on the array skeleton and equally non-strict on the array content
18:43:08 <monochrom> similarly (!!) and list
18:44:09 <monochrom> because of this consideration, my concurrent stance is "the problem is elsewhere"
18:47:44 <sinnsat> the output is not a list, but a "cyclic" (actually a bit more complex with cross-references) data structure... if any of the index operations fail, then I want to return Nothing... in order to know that, it must evaluate the whole thing which is infinite, because it has to know which Constructor to use. That's what I thought.
18:56:37 <nshepperd> well, the Just constructor is lazy in its contents
18:57:08 <nshepperd> so that might be an issue if you're using some strict folds or seq'ing things to try and control the order of evaluation
18:59:55 <monochrom> in fact, (!) is even stricter than its safe variant.
19:02:21 <monochrom> yikes, there are now so many monad transformer libraries, a new yet another one has to avoid the "transformer" meme and say "levels" instead. (monad-levels)
19:11:51 <Lokathor> hmm, the arrow keys don't output characters do they? So you can't use hGetChar to read arrow presses from stdin?
19:12:24 <shachaf> It's more complicated than that.
19:12:32 <shachaf> Did you see what happened when you tried?
19:12:32 <Lokathor> oh my
19:12:50 <Lokathor> no i was about to write it and then figured i'd ask
19:13:00 <Lokathor> it's some escape sequence i take it?
19:14:56 <shachaf> I think "ghci␤c <- getChar␤←c␤" is shorter than the question you typed and would give you more information. :-)
19:15:23 <shachaf> If the question is "is it easy to use getChar to find out whether the user pressed an arrow key", the answer is "probably not, better to find a library that does it".
19:15:46 <Lokathor> that indeed was the primary question
19:16:02 <Lokathor> but musings on terminal standards are also accepted :3
19:17:00 <shachaf> I think I overstate this. :-(
19:18:09 <nshepperd> I think terminal standards are best described as "awful"
19:18:19 <sdegutis> How do you use Cabal to install your dependencies?
19:18:23 <nshepperd> but, ncurses seems to work most of the time somehow
19:18:48 <ReinH> nshepperd: Or perhaps "A few people tried but mostly couldn't even and yet ncurses still somehow works"
19:19:23 <ReinH> Or perhaps "There are terminal standards?"
19:19:42 <shachaf> Certainly there are standards.
19:20:06 <Lokathor> there is a standard library, as i understand it, that you put your terminal info into
19:20:14 <Lokathor> and then curses reads it out of that library to do things
19:20:15 <Lokathor> magically
19:20:55 <ReinH> terminfo is... uh... yeah...
19:20:58 <nshepperd> theoretically, the terminfo database tells you what control characters are for what
19:23:23 <ReinH> is the terminfo database even maintained?
19:23:48 <dmwit> sdegutis: cabal install --only-dependencies
19:23:56 <ReinH> afaik ncurses has a number of fixes that have never been backported
19:25:39 <ReinH> ESR's terminfo database was last modified in 2000, so
19:26:06 <sdegutis> Thanks dmwit.
19:26:31 <ReinH> I guess the ncurses one is the de facto standard now
19:26:33 <sdegutis> Is using a monad one way to effectively create a function with "variadic arguments" using the builder pattern?
19:26:35 <monochrom> on the bright side, there hasn't really been new terminals since 2000
19:26:48 <EvanR> theres terminfo
19:26:52 <ab9rf> really, who makes terminals anymore?
19:26:53 <ReinH> monochrom: yeah, but it wasn't exactly bug free in 2000 either ;)
19:26:58 <EvanR> oops was scrolled up
19:27:01 <sdegutis> I tried to use ncurses earlier.
19:27:08 <sdegutis> And then someone told me to just use vty and vty-ui
19:27:17 <sdegutis> But I couldn't get them working. At all. After like an hour of trying.
19:27:25 <sdegutis> And I couldn't get ncurses working (in Haskell) either.
19:27:32 <nshepperd> well, terminfo doesn't really represent modifier keys like alt,shift,control
19:27:36 <sdegutis> So I just gave up and now I'm using scotty + lucid + clay instead.
19:27:40 <sdegutis> (+ aeson)
19:27:41 <ReinH> sdegutis: It's a well known internet phenomenon that if you ask a question about a particular tool, someone else will suggest that you use a different tool.
19:27:43 <ab9rf> sdegutis: are you using wiundows, linux, or macos?
19:27:49 <nshepperd> so all that stuff is just hardcoded in random software still
19:27:52 <sdegutis> ab9rf: macosx
19:28:01 <ab9rf> sdegutis: ah.  dunno what the sitation with the mac is
19:28:08 <monochrom> I can't see how the builder pattern looks like variadic. and I can't see the benefits of variadic.
19:28:12 <EvanR> how a given terminal emulator reacts to your keyboard is up to anybody's guess
19:28:15 <sdegutis> ab9rf: no its just the Haskell lib I couldn't get working
19:28:26 <EvanR> better use X, cocoa, winforms etc
19:28:27 <ab9rf> i know that getting a lot of these libs working in windows is challenging.
19:28:34 <simon> sdegutis, what do lucid and clay do?
19:28:41 <nshepperd> so it really does need to be updated
19:28:47 <sdegutis> simon: edsl for html and css
19:28:54 <ab9rf> nshepperd: curses is a backwater technology for the most part
19:28:56 <sdegutis> simon: they gud
19:29:28 <sdegutis> A big part of me wants to just use ncurses and backpack it.
19:29:29 <simon> sdegutis, I've only used scotty and aeson so far. I'm willing to bet on that.
19:29:47 <sdegutis> But then I remember that the terminal is an awful place to do interactive UI
19:29:49 <ab9rf> i've considered reimplementing ncurses in native haskell
19:29:57 <sdegutis> ab9rf: that'd be cool, go for it
19:30:01 <ab9rf> sdegutis: there is no good place to do interacvtive UI
19:30:09 <ab9rf> sdegutis: it's also a monster buttload of work
19:30:12 <sdegutis> ab9rf: sure but the browser is the least painful way right now
19:30:21 <geekosaur> reimplement something better. pleas/ or contribute to vty / vty-ui
19:30:24 <ab9rf> sdegutis: ugh, i hate browser-based apps
19:30:43 <ab9rf> geekosaur: heh
19:31:16 <geekosaur> curses is just bizarre
19:31:17 <glguy> Sdegutis, if you learn from examples I have some small vty games on my github
19:31:20 <glguy> https://github.com/glguy/set-game/blob/master/src/SetGame.hs
19:31:27 <sdegutis> ab9rf: theres really no decent alternative
19:31:36 <ab9rf> sdegutis: there is no decency in UIs.
19:31:38 <EvanR> terminals are just bizarre
19:31:44 <ab9rf> all UIs are inherently indecent
19:31:47 <ab9rf> users suck
19:31:55 <ab9rf> the best option is to eliminate the user entirely
19:31:57 <geekosaur> it *looks* simple. then you discover the hard way all the odd corner cases that are sort-of documented once you read the documentation *after* hitting each one....
19:32:22 <sdegutis> ab9rf: every other API either (1) is proprietary and/or doomed to become outdated soon, (2) impossible to get setup and working, and/or (3) an awful and painful API for doing UI
19:32:35 <glguy> Or another one is https://github.com/glguy/TwosGame/blob/master/Main.hs however it also mixed in a demo of the machines library
19:33:06 <sdegutis> Case in point: I'm writing a budget app for myself -- I will be the only user -- and I chose *against* my own personal favorite UI toolkit for all 3 of the above reasons.
19:33:56 <sdegutis> If (a) I can't get the API working, or (b) I can but it's unusable, or (c) it's usable but won't be able to compile in 10 years, it's not worth using.
19:34:01 <EvanR> sdegutis: youre your own only user? wow. just make it file system based, and monitor file touches to trigger effects ;)
19:34:01 <monochrom> you know, perhaps make your program use morse code for input and output
19:34:16 <sdegutis> EvanR: I want it to be usable.
19:34:24 <EvanR> duh
19:34:44 <monochrom> Murphy's law implies that some vocal minority is bound to say: only morse code is decent.
19:34:45 <EvanR> my idea is both usable and terminal
19:34:59 <dmwit> monochrom: st started in 2008
19:35:05 <sdegutis> EvanR: lol no
19:35:20 <dmwit> monochrom: (as a counterexample to "nobody's made a new terminal since 2000")
19:35:25 <sdegutis> I forked st for OS X and the authors were vehemently against my fork purely in principle.
19:35:53 <Lokathor> rejecting: base-4.7.0.2, <many other version numbers here> (global constraint requires installed instance)
19:36:03 <Lokathor> what does that last part mean in a cabal build?
19:36:03 <sdegutis> I'm not against their reasoning, just their furious hostility.
19:36:07 <EvanR> there is no fork
19:36:10 <geekosaur> for base, it's normal
19:36:18 <sdegutis> Okay so back to writing my app :)
19:36:20 <geekosaur> you can only use the one that came with your ghc
19:36:24 <sdegutis> it's at https://github.com/sdegutis/HomeBudget for those following along
19:36:27 * hackagebot pgdl 6.8 - pgdownloader  http://hackage.haskell.org/package/pgdl-6.8 (sifmelcara)
19:36:59 <dmwit> EvanR: Even better, use fuse.
19:37:08 <monochrom> haha
19:37:21 <Lokathor> i can't install hscurses into this sandbox :/
19:38:27 <EvanR> Lokathor: have you investigated libterm
19:41:27 * hackagebot pgdl 6.9 - pgdownloader  http://hackage.haskell.org/package/pgdl-6.9 (sifmelcara)
19:41:37 <Lokathor> ab9rf, if you do implement curses or a curses-like library in native haskell, you'll be a Hero among ants. Alan Turing himself will look upon you and weep
19:42:20 <Lokathor> EvanR: I'm not familiar with libterm.
19:42:30 <EvanR> me neither ;)
19:42:44 <Lokathor> I have a program that's using HSCurses on one machine, but i can't build it on the other because the other can't build hscurses
19:42:54 <EvanR> windows?
19:42:59 <Lokathor> no, both debian
19:43:05 <EvanR> :S
19:43:30 <Lokathor> the one that CAN build it is using a slightly older GHC, the one that CANNOT is using the newest GHC/Cabal so that I could build GHCJS
19:43:49 <Lokathor> hscurses might be sunk if it won't build on the newest GHC without an update
19:49:30 <ReinH> Lokathor: vty is a curses-like library in almost pure Haskell. There's a very small amount of C.
19:50:07 <ReinH> I'm not sure if hscurses is actively maintained. I use ncurses and vty.
19:50:57 <ab9rf> in theory curses is "easy".  but it's not.
19:51:35 <Lokathor> ReinH I will investigate such a thing. It still runs in a terminal i take it
19:54:47 <ReinH> Lokathor: yep, it's a curses-like
19:55:10 <ReinH> There's also an extension library called vty-ui that provides ui elements like menus, buttons, etc.
19:55:20 <ReinH> It's rather nice.
19:56:13 <Lokathor> hmm. I only planned on making a roguelike, UI drawing should be pretty simple
19:56:41 <Lokathor> perhaps I'll have to develop it exclusively on the raspberry pi for now, and abstract out the interface code later
19:59:50 <sdegutis> here's my models  https://github.com/sdegutis/HomeBudget/blob/master/src/Model.hs
20:00:25 <ReinH> Lokathor: roguelikes usually have some sort of menu system for inventory
20:00:56 <Lokathor> well, yes, but that's just a bunch of lines with letters, nothing too fancy usually
20:01:28 <ReinH> ime vty is a bit too high-level (it doesn't give you low level "move point to (x,y) and draw c" functionality) for things like map drawing, but it's really nice for other things.
20:02:02 <ReinH> Well, it gives you "draw an image containing char c and translate it +x +y", but that's relatively inefficient
20:02:17 <ReinH> Then again, in a roguelike you aren't *super* concerned with screen drawing efficiency
20:02:41 <Lokathor> well, i do indeed want that ability to draw a char at an x,y location, but i'm willing to accept some inefficiencies i suppose
20:03:01 <ReinH> It's super nice for stats bars, inventory menu systems, etc
20:03:38 <ReinH> I would actually like to see a system based on Tekmo's mvc but then I'd have to write it and ain't nobody got time for that
20:18:01 <fread2282> is there a Eq (a -> a -> Maybe a) typelcass somewhere?
20:18:12 <fread2282> *typeclass
20:19:34 <Cale> fread2282: uh, do you mean a function of type  Eq a => a -> a -> Maybe a?
20:19:39 <fread2282> I guess you could call it Unify
20:19:56 <Cale> Oh
20:20:10 <fread2282> a different typeclass that is like Eq
20:20:13 <Cale> So something kind of like Eq but for unification? I don't think that exists
20:20:41 <fread2282> Eq but it's allowed to return a "simplified" version, yes
20:21:23 <chrisdotcode> @src filter
20:21:24 <lambdabot> filter _ []     = []
20:21:24 <lambdabot> filter p (x:xs)
20:21:24 <lambdabot>     | p x       = x : filter p xs
20:21:24 <lambdabot>     | otherwise = filter p xs
20:27:40 <sdegutis> grr
20:27:46 <sdegutis> I can't get hspec working with cabal test.
20:28:11 <jle`> and if x :: IO a then let y = x will make y :: IO a as well.  "let" is basically just a definitoin/alias
20:28:41 <jle`> oh
20:28:50 <jle`> accidentally managed to press up and enter without noticing
20:31:22 <sdegutis> woo fixed it
20:37:17 <dmwit> ?tell fread2282 ?hackage unification-fd
20:37:17 <lambdabot> Consider it noted.
20:38:25 <dmwit> ?hackage vty
20:38:25 <lambdabot> http://hackage.haskell.org/package/vty
20:50:21 <sdegutis> blarg
21:36:23 <jle`> are there any interesting results from `f`s for loop :: ((a, c) -> (b, c)) -> (a -> b)
21:36:31 <jle`> loop f x = let (y, z) = f (x, z) in y
21:36:44 <jle`> the only f's i can get to terminate are ones that ignore the second argument completely
21:37:22 <jle`> i'm trying to see if i can get a terminating answer (or one that i can get a terminating value from) from an `f` that uses the second argument
21:38:51 <scott> jle`: how is it defined?
21:39:18 <jle`> i defined it above
21:39:20 <jle`> loop f x = let (y, z) = f (x, z) in y
21:40:28 <scott> oops, that was some impressive selective blindness
21:40:42 <jle`> for ones that ignore the second element to get the first element, it's basically just loop f x = fst (f (x, undefined))
21:41:01 <jle`> loop (\(x,y) -> (x+1, y-1)) 2 = 3
21:41:33 <jle`> but i'm trying to think of an interesting f where the first field of the result depends on the second field of the input
21:41:52 * jle` shrugs
21:51:24 <jle`> oh, the first field of the result can depend on the second field of the input, as long as the second field of the result doesn't
21:51:27 <jle`> interesting
21:54:09 <Hijiri> @let loop f x = let (y,z) = f (x,z) in y
21:54:12 <lambdabot>  Defined.
21:54:37 <Hijiri> > loop (\(x,y) -> (x + head y, 1:y)) 5
21:54:38 <lambdabot>  Ambiguous occurrence ‘loop’
21:54:38 <lambdabot>  It could refer to either ‘L.loop’, defined at L.hs:159:1
21:54:38 <lambdabot>                        or ‘Control.Arrow.loop’,
21:54:43 <Hijiri> > L.loop (\(x,y) -> (x + head y, 1:y)) 5
21:54:45 <lambdabot>  6
21:54:47 <jle`> fortunately, Control.Arrow.loop is this exact same function
21:54:49 <jle`> :)
21:54:55 <Hijiri> yeah, just realized
21:54:55 <jle`> whoaooa
21:55:34 <Hijiri> > L.loop (\(x,y) -> (x:y, 1:y)) 5
21:55:36 <lambdabot>  [5,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
21:55:53 <jle`> hm
21:56:24 <jle`> interesting
21:56:29 <jle`> is there any way to make an ascecnding list?
21:56:33 <jle`> @undefine
21:56:33 <lambdabot> Undefined.
21:56:51 <Hijiri> I don't know, I was just using the second argument like fix
21:56:59 <Hijiri> there must be more useful examples
21:57:04 <Hijiri> I know repmin is one
21:57:05 <jle`> i want to believe
21:58:41 <Hijiri> > loop (\(x,y) -> (map (+x) y, 1 : map (+1) y))
21:58:43 <lambdabot>  <Integer -> [Integer]>
21:58:46 <Hijiri> > loop (\(x,y) -> (map (+x) y, 1 : map (+1) y)) 50
21:58:47 <lambdabot>  [51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,...
21:58:52 <Hijiri> but this is just fix again
21:59:29 <jle`> yeah i think it is pretty related to fix
21:59:32 <jle`> that's nice
21:59:46 <jle`> the second argument is basically fix
21:59:50 <jle`> and the first argument uses the result of fix
22:00:13 <jle`> it's starting to make sense now
22:00:25 <Hijiri> I think it gets more interesting if the second argument depends on the first somehow
22:01:28 <jle`> can that happen?
22:01:54 <Zemyla> Man, I think I'm getting addicted to Haskell. :<
22:02:03 <Hijiri> this page discusses some usefulness of loop https://wiki.haskell.org/Circular_programming#Repmin_problem
22:02:25 <jle`> oh yeah, that's a thing
22:02:39 <cjenkin2> Hijiri, how do you mean "depend"?
22:03:26 <Hijiri> I didn't have a clear definition in mind, I guess I meant that the value of the second argument changes based on x
22:04:04 <jle`> "depends" is a good word considering haskell evaluation is graph resolution
22:04:09 <cjenkin2> Hijiri, I was just wondering if I could sneak in dependent types. Carry on.
22:11:28 <jle`> thanks for the link Hijiri :)
22:32:57 <ReinH> Hijiri, jle`: here's another really cool use http://www.cse.chalmers.se/~emax/documents/axelsson2013using.pdf
22:35:38 <Hijiri> thanks ReinH
23:03:24 <om-foxy> I have a GADT for arithmetic expressions that provides instances of numeric typeclasses.  I am stuck on how to implement `compare` from the `Ord` typeclass.  It expects a function of type `Expr a -> Expr a -> Ordering but I have a constructor `ExprCompare :: Expr a -> Expr a -> Expr Ordering`.  How do I resolve this?
23:05:05 <om-foxy> I don't want to do any actual comparison until I call an `eval` function.
23:05:09 <nshepperd> > loop (\(x,y) -> (x:y, x:y)) 5
23:05:11 <lambdabot>  [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
23:06:16 <kranius> @type loop
23:06:17 <lambdabot> ArrowLoop a => a (b, d) (c, d) -> a b c
23:17:41 <glguy_> Om-foxy: your operation doesn't fit the type that is required, so you won't be able to use Ord
23:23:03 <CindyLinz> > loop (\(a, b) -> (a:b, a:zipWith (+) (a:b) b)) 1
23:23:05 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
23:24:05 <Ferdirand> :t loop
23:24:06 <lambdabot> ArrowLoop a => a (b, d) (c, d) -> a b c
23:27:46 <phaazon> is there anyone here today who could explain me where I can find c2hs errors file?
23:47:35 <tommd> phaazon: Why can't you just look for the .chs file and manually invoke c2hs?
23:49:10 <jle`> thanks ReinH
23:49:22 <jle`> thank you CindyLinz
23:49:26 <jle`> i was looking for that exact one, heh
23:56:21 <phaazon> tommd: yeah
23:56:22 <phaazon> well
23:56:27 <phaazon> I’m gonna try something different.
23:56:34 <phaazon> I’m compile from the git version
23:56:43 <phaazon> do you know whether it’s stable, tommd?
23:57:29 <phaazon> Linking .\dist\setup\setup.exe ...
23:57:30 <phaazon> setup.exe: autoconf: does not exist
23:57:32 <phaazon> god…
23:57:36 <dmwit> OmegaA: You call your operation something other than compare. ;-)
23:57:41 <dmwit> uh
23:57:55 <dmwit> Sorry, mis-nick.
23:58:05 <phaazon> $ autoconf --version
23:58:06 <phaazon> autoconf (GNU Autoconf) 2.68
23:58:16 <phaazon> what the hell’s happening
