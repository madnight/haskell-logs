00:02:45 <edwardk> 'sdl2' is the new hotness
00:10:03 * hackagebot duplo 1.8.0 - Frontend development build tool  http://hackage.haskell.org/package/duplo-1.8.0 (kenhkan)
00:10:03 * hackagebot cabal-debian 4.23.1 - Create a Debianization for a Cabal package  http://hackage.haskell.org/package/cabal-debian-4.23.1 (DavidFox)
00:33:24 <dmwit> mjrosenb: regarding (t ~ t1) problem, perhaps ScopedTypeVariables can help
00:33:47 <dmwit> GHC docs have details on how to use them
00:34:54 <dmwit> they can often be avoided if necessary, but things are more readable without the tricks needed to do that
00:36:14 <mjrosenb> dmwit: I just re-wrote the code to not use Either (thus not needing an explicit type)
00:36:37 * mjrosenb is currently looking at sdl2, and being rather dissapointed with the bindings.
00:37:30 <mjrosenb> although that may be in part an issue with the documentation, not the library itself.
00:45:00 * hackagebot cndict 0.5.0 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.5.0 (DavidHimmelstrup)
00:46:31 <gfixler> in the haskell community I often hear about "the growing complexity of software"
00:46:40 <gfixler> especially in terms of concurrency
00:46:45 <gfixler> but I keep feeling like I'm seeing the opposite
00:46:52 <gfixler> everyone just glues together frameworks now
00:47:12 <gfixler> I used to work on big games with 30 levels, 80 characters, open worlds, etc
00:47:16 <gfixler> now I work on tiny apps
00:47:28 <gfixler> I feel like everywhere I look things keep getting simpler and dumber
00:47:58 <gfixler> design has trimmed way back, too - empty backgrounds with light text on them are everywhere now
00:47:59 <tdammers> it's more like programmers are becoming one-trick ponies
00:48:22 <gfixler> which software keeps getting more complex?
00:48:27 <gfixler> I can never think of anything
00:48:39 <speak> gfixler well, software IS getting more complex in a way, even if the end result is simple
00:48:42 <gfixler> except things likes Big Search (is that a thing?)
00:48:44 <tdammers> think about it; a mobile app is pretty damn complex
00:48:49 <bitemyapp> gfixler: everything, we just keep piling things on top of each other.
00:48:52 <tdammers> but you don't need to implement it all yourself
00:48:57 <bitemyapp> gfixler: but the abstractions hide the pile.
00:48:59 <speak> Take your design as an example, you'll have 300 scripts being loaded to show that simple background and light text
00:49:03 <tdammers> 98% is covered by libraries, hardware, and external api's
00:49:15 <gfixler> but no one is rewriting everything from the bottom up
00:49:20 <tdammers> no, of course not
00:49:23 <gfixler> we're just making some simple blob to stick on top of what's there
00:49:29 <tdammers> but that doesn't mean the complexity isn't there
00:49:34 <gfixler> no one is writing 300 script towers
00:49:38 <tdammers> you can be quite successful ignoring the complexity
00:49:47 <gfixler> the complexity can be there
00:49:48 <speak> Why? Because developers are a bunch of comformist scumbags and everything is going to HELL   *cough* Sorry about that
00:49:51 <gfixler> but it's irrelevant to my question
00:49:53 <tdammers> but at some point, it'll catch up, and then you need to know how stuff works
00:49:59 <gfixler> maybe
00:50:02 <bitemyapp> speak: you sound upset.
00:50:04 <tdammers> speak: no need to be sorry ;)
00:50:23 <speak> bitemyapp I may be slightly frustrated at the current state of affairs
00:51:01 <speak> Thanks tdammers :P
00:51:46 <speak> Venting is a good alternative to snapping completely!
00:51:48 <gfixler> our future: https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript
00:52:53 <nshepperd> rewriting things from the bottom up would actually help reduce the complexity problem
00:53:03 <nshepperd> but, no-one's got time to do that
00:53:07 <gfixler> nshepperd: I think about that all the time
00:53:15 <gfixler> no one's got money to do that
00:53:21 <gfixler> one of us needs to get stinking rich
00:53:27 <gfixler> I volunteer
00:54:04 <tdammers> gfixler: we're waiting. chop chop
00:54:28 <tdammers> I'll forward you some "get rich quick" e-mails that you will find useful
00:54:59 <speak> Haha
00:55:05 <speak> Thanks for the link gfixler, btw
00:55:16 <gfixler> speak: np - it's a fun talk
00:57:41 <mjrosenb> question about haskell's cairo bindings: can I render to a window with it, or is it limited to rendering into files?
00:59:06 <bitemyapp> mjrosenb: http://hackage.haskell.org/package/cairo-0.13.0.6/docs/Graphics-Rendering-Cairo.html
00:59:17 <bitemyapp> "Cairo is a 2D graphics library with support for multiple output devices. Currently supported output targets include the X Window System, win32, and image buffers. Experimental backends include OpenGL (through glitz), Quartz, XCB, PostScript and PDF file output."
00:59:34 <bitemyapp> that said, I've had difficulty getting it to do something other than dumping to a file in the past.
01:00:29 <pavonia> Drawing to a Gtk widget is very easy
01:01:42 * mjrosenb wants to draw directly to an X window
01:01:49 <mjrosenb> preferably, one created with xcb
01:04:56 <mjrosenb> pavonia: how do you do that? I wasn't able to find much documentation on the subject.
01:06:02 <pavonia> One second, I'll paste an example ...
01:06:06 <pavonia> @lpaste
01:06:06 <lambdabot> Haskell pastebin: http://lpaste.net/
01:11:26 <pavonia> mjrosenb: http://lpaste.net/120191
01:12:04 <pavonia> That should draw a window with a white background
01:12:07 <mjrosenb> import qualified Graphics.Rendering.Cairo as Gtk
01:12:10 <mjrosenb> c.c
01:14:04 <pavonia> Hhm, I copied that from one of my programs which had conflicting MonadIO instances from different libraries :/
01:20:28 <mjrosenb> oh, great, I cannot install gtk
01:22:31 <udevd> peddie: and the thing with LAPACK was that NaNs were passed to it
01:22:44 <udevd> It wasn't that obvious :P
01:23:39 <udevd> I think I will send e-mail to hmatrix maintainer that more descriptive error message would be better
01:48:14 <mroman> how do you consume stuff with parsec
01:48:17 <mroman> without having to return anything
01:48:21 <mroman> like filtering out comments
01:48:53 <jle`> you can use void or (*>), etc.
01:48:59 <mauke> just return ()
01:49:20 <jle`> return () after you consume of course
01:49:37 <mroman> yeah
01:49:38 <mroman> but i have
01:49:44 <mroman> parseFoo :: Parser Foo
01:49:45 <jle`> `stuff *> return ()` is equivalent to `void stuff` btw
01:49:52 <mroman> parseFoo = parseInt <|> parseDouble <|> ...
01:50:05 * hackagebot test-sandbox 0.1.0 - Sandbox for system tests  http://hackage.haskell.org/package/test-sandbox-0.1.0 (junjihashimoto)
01:50:05 <mroman> I'd want parseFoo = (skipComment) <|> parseInt <|> parseDouble
01:50:07 * hackagebot test-framework-sandbox 0.1.0 - test-sandbox support for the test-framework package  http://hackage.haskell.org/package/test-framework-sandbox-0.1.0 (junjihashimoto)
01:50:09 * hackagebot test-sandbox-hunit 0.1.0 - HUnit convenience functions for use with test-sandbox  http://hackage.haskell.org/package/test-sandbox-hunit-0.1.0 (junjihashimoto)
01:50:09 <mroman> of course, this can't typecheck
01:50:11 * hackagebot test-sandbox-quickcheck 0.1.0 - QuickCheck convenience functions for use with test-sandbox  http://hackage.haskell.org/package/test-sandbox-quickcheck-0.1.0 (junjihashimoto)
01:50:46 <mauke> why would you want skipComment in there?
01:51:02 <mroman> because a comment can be everywhere
01:51:03 <mroman> like
01:51:10 <mroman> [1,2 /* i'm a comment */,3]
01:51:26 <mauke> non sequitur
01:51:33 <jle`> my parsec is a bit rusty, but how about optional skipComment *> choice [parseInt, parseDouble ...]
01:51:43 <jle`> but
01:51:47 <jle`> you probably want to separate that part out
01:51:50 <mroman> @type (*>)
01:51:52 <lambdabot> Applicative f => f a -> f b -> f b
01:52:00 <mauke> it's like >>
01:52:03 <mjrosenb> ok, it appears as if cairo drawing in gtk is done largely from gtk's side.
01:52:03 <jle`> check for comments before trying to parse your token
01:52:10 <mauke> no, after
01:52:25 <mauke> IIRC the convention is that every parser consumes trailing whitespace
01:52:32 <jle`> ah yes
01:52:52 <mauke> so if parseInt/parseDouble/etc do that, you don't have to do anything
01:52:52 <jle`> and also as a separate part of the logic/function
01:52:59 <jle`> oh
01:53:15 <jle`> yeah huh.
01:53:50 <mroman> nvm
01:54:06 <mroman> i can just do parseFo = do { skipComments; p <- a <|> b; return p };
01:54:40 <mauke> that's equivalent to do { skipComments; a <|> b }
01:54:49 <mauke> which desugars to skipComments >> (a <|> b)
01:55:12 <jle`> yeah, do { x <- m; return x } is just m
01:55:38 <EvanR> its the law!
01:57:11 <zipper> Which package exports functions testProprty and testCase?
01:57:35 <mjrosenb> ooh, a .chs file
01:57:41 <mjrosenb> what is that for?
01:58:13 <mauke> zipper: http://hayoo.fh-wedel.de/?query=testProperty ?
01:58:39 <mjrosenb>  -> IO a
01:58:53 <mjrosenb> gah, stupid mouse
01:59:09 <mjrosenb> renderWithDrawable drawable m = bracket (liftM Cairo.Cairo $ {#call unsafe gdk_cairo_create#} (toDrawable drawable))
01:59:17 <mjrosenb> so, that looks like some fun stuff.
01:59:39 <mauke> mjrosenb: c2hs, apparently
01:59:54 <mjrosenb> it looks like normal haskell code
02:00:04 <mauke> {#call
02:00:05 <zipper> mauke: According to http://hackage.haskell.org/package/test-framework test framework no longer has a Test.Framework.QuickCheck module
02:00:08 <mjrosenb> but with C-preprocessor directives in it.
02:00:39 <zipper> How do people do testing in haskell? I seriously can't find anything that works from `cabal test`
02:01:24 <mauke> I wrote an ad-hoc TAP module and used that once
02:02:36 <mjrosenb> bitemyapp: c.c, evidently, cairo has two different help pages?
02:02:40 <barrucadu> zipper: http://hackage.haskell.org/package/test-framework-quickcheck
02:02:59 <mjrosenb> bitemyapp: http://hackage.haskell.org/package/cairo-0.13.0.6
02:03:28 <mjrosenb> ahh, one is for the package, one is for the primary module
02:03:31 <barrucadu> Actually, http://hackage.haskell.org/package/test-framework-quickcheck2 is probably what you want
02:03:44 <mjrosenb> the one for the package doesn't say that it supports X :-/
02:04:24 <mjrosenb> Note the Haskell bindings do not support all the possible cairo backends because it would require bindings for the associated technology (eg X11, glitz, etc) however bindings to other backends may be implemented externally. For example, Gtk2Hs provides a binding to the backend for X11
02:04:29 <mjrosenb> ahh, there we go.
02:04:30 <mjrosenb> bummer.
02:06:21 <mjrosenb> ok, does anyone know what {#call unsafe gdk_cairo_create#} does?
02:07:04 <mauke> have you tried reading the manual?
02:07:18 <mroman> ) main -> (putstrln ''I am a comment'' :(Hello, world!) ''Neat'')
02:07:21 <mroman> > Hello, world!
02:07:22 <lambdabot>  <hint>:1:6: parse error on input ‘,’
02:07:23 <mroman> ok, works :D
02:07:50 <reem> Are there dependency injection libraries in Haskell?
02:08:46 <johnw> reem: can you clarify why you ask?  the answer is no, and there are reasons
02:09:06 <johnw> both because they're pretty much not necessary, and because trying to do it is attempting the wrong thing
02:09:50 <reem> I'm thinking about how to encode dependencies for some kind of plugin in the type system
02:10:03 <reem> I was thinking that could be accomplished via dependency injection
02:10:23 <johnw> I'm not completely sure what you mean by dependency injection, that you'd think it relates to Haskell....
02:10:40 * EvanR tries to find out what dependency injection is again
02:10:44 <Hijiri> data Plugin = Plugin Stuff MoreStuff Dependency ?
02:11:00 <Hijiri> and then fill Dependency with your dependencies
02:11:09 <reem> Ya, something like that
02:11:17 <johnw> EvanR: it's when an object can say "I need a database handle", and the programmer sets up how to answer that request via a configuration file at the top level, to avoid passing the handle all the way down from the top to the function
02:11:42 <EvanR> global variables?
02:11:52 <reem> not global
02:11:52 <johnw> pretty much it relies on a global registry
02:11:57 <reem> but part of a system
02:12:08 <reem> I'm specifically thinking for a middleware stack for webapps
02:12:13 <EvanR> kill it with fire
02:12:24 <reem> that the framework could check that all the middleware dependencies are fulfilled before starting
02:12:31 <reem> or before compiling, ideally
02:12:33 <mauke> no, passing down from the top is also dependency injection
02:12:46 <Hijiri> dependency injection is a hack for languages that don't have first-class functions isn't it?
02:12:47 <mauke> the point is that the object doesn't create it itself
02:12:49 <Hijiri> or is it more than that
02:15:03 <johnw> mauke: I thought the point of calling it "injection" is that you don't pass it through layers that shouldn't need to have any dependency on the type of the injected object
02:15:38 <mauke> I thought it went like this:
02:15:39 <EvanR> after reading wikipedias java examples, it seems like this is better described in the opposite way. to not explicitly have your initialization code embedded deep in your library but have it separate
02:16:00 <EvanR> dependency removal
02:16:02 <mauke> let's say you have an object that needs to do web stuff, so it needs an http client
02:16:41 <mauke> the conventional way is to instantiate an HTTP.Client in your constructor (and stash it away for later use)
02:16:59 <mauke> this introduces a direct dependency from your class to whatever http client class you're using
02:17:26 <mauke> "dependency injection" makes the http client a constructor parameter
02:17:49 <mauke> i.e. your class no longer depends on a particular http implementation; instead it's "injected" by your caller
02:18:06 <johnw> ah, I see what you mean
02:18:27 <johnw> yeah, it does do that too
02:19:01 <EvanR> decomplection ;)
02:19:02 <mjrosenb>  Ambiguous module name ‘Graphics.UI.SDL’:
02:19:04 <mjrosenb> :-(
02:19:16 <mauke> benefits of this approach include easier testing and stuff
02:19:36 <mjrosenb> why do sdl and sdl2 use the same module paths?
02:19:55 <mjrosenb> also, is there a way to choose one explicitly on the command line (or is the .hs file)?
02:19:56 <merijn> mjrosenb: Because they're fundamentally incompatible and will therefore never conflict anyway?
02:20:02 <merijn> mjrosenb: Use cabal
02:20:07 <EvanR> because people someone think sdl1.2 and sdl2 are the same library with just different veresions
02:20:14 <EvanR> somehow
02:21:08 <mjrosenb> merijn: that seems like an awful lot of effort just to determine which library this code expects :-(
02:22:02 <mjrosenb> hrm, this repository is 5 years old
02:22:11 <mjrosenb> I'm guessing that is before sdl2 was released.
02:22:34 * mjrosenb still has not found anything that actually uses sdl2's haskell bindings.
02:25:52 <merijn> mjrosenb: I use cabal for pretty much anything I build in haskell. Inititally I would start with a single file and only switch to cabal later, but by now I prefer to just cabalize asap
02:27:31 <jle`> yeah i don't know if it even makes sense to develop haskell projects w/out cabal these days...and it's a pretty low friction kinda deal too
02:27:48 <Kaidelong> > 150/5000
02:27:51 <lambdabot>  3.0e-2
02:27:56 <Kaidelong> GHCi does this too
02:28:11 <Kaidelong> is there any way I can tell it not to resort to scientific notation for two decimal places
02:28:18 <Kaidelong> 0.03 is a lot clearer
02:28:21 <mauke> :t showFFloat
02:28:22 <lambdabot> RealFloat a => Maybe Int -> a -> ShowS
02:28:23 <merijn> No, because it's using the Show instance
02:28:26 <merijn> Use a proper pretty printer
02:28:35 <mauke> > showFFloat Nothing 3.0e-2 ""
02:28:36 <lambdabot>  "0.03"
02:29:04 <EvanR> > printf "%.2f" 0.314159
02:29:06 <lambdabot>  No instance for (GHC.Show.Show a0)
02:29:06 <lambdabot>    arising from a use of ‘M353402889002713596118864.show_M3534028890027135961...
02:29:06 <lambdabot>  The type variable ‘a0’ is ambiguous
02:29:43 <mauke> > ""++ printf "%.2f" 0.314159
02:29:44 <lambdabot>  "0.31"
02:30:12 <Hijiri> > printf "%n" nullPtr :: String
02:30:13 <lambdabot>  Not in scope: ‘nullPtr’
02:31:21 <Kaidelong> > (printf "%.2f" (2/3)) :: String
02:31:24 <lambdabot>  "0.67"
02:31:26 <EvanR> Kaidelong: that aspect of that show instance is kind of annoying
02:31:29 <Kaidelong> okay
02:31:32 <Kaidelong> that looks like what I want
02:31:42 <Kaidelong> well in ghci I can just have it interpreted as IO String
02:31:49 <Kaidelong> so I should be able to just use bare printf?
02:32:27 <Kaidelong> err
02:32:29 <Kaidelong> IO ()
02:32:30 <Kaidelong> I meant
02:32:33 <Kaidelong> not IO String
02:33:02 <ClaudiusMaximus> Kaidelong: ghci -interactive-print=Some.Pretty.print might be useful too, if you find a pretty printing library you like with sane instances for the things you need
02:33:14 <EvanR> whoa
02:33:22 <Kaidelong> ClaudiusMaximus: that's more what I was looking for, thanks!
02:34:13 <EvanR> if that prints records out on more lines that would be epic
02:36:13 <Kaidelong> I realized though
02:36:23 <Kaidelong> that scientific notation was convenient in my case
02:36:33 <Kaidelong> because I just strip the exponent and it's a percentage
02:36:38 <Kaidelong> which is what I have to report
02:59:35 <zipper> Anyone got an instance of Arbitrary for Centi from Data.Fixed handy?
03:00:49 <zipper> Also do you prefer to see tests in a different directiory or with the source?
03:01:05 <bitemyapp> zipper: https://hackage.haskell.org/package/QuickCheck-2.7.6/docs/src/Test-QuickCheck-Arbitrary.html ctrl-f "Fixed"
03:01:34 <bennofs> :O conditional instances???
03:01:49 <bennofs> doesn't look like a good idea to me
03:02:39 <zipper> bitemyapp: Thanks PM
03:02:49 <zipper> bitemyapp: Thanks and PM
03:02:53 <bennofs> ah, it's only for UHC
03:07:56 <mjrosenb> merijn: I guess I should finally learn about cabal.
03:08:00 <ClaudiusMaximus> zipper: for my one package with tests (so far), i put my tests in a cabal test-suite - but i can also see it being useful to put the tests (or at least Arbitrary instances etc) in the library (eg: for testing another library that depends on the library in question)
03:08:21 * mjrosenb tired using it once, but the project that is using cabal won't build on my server :-(
03:08:54 <mjrosenb> oh fun, haskell's sdl2-image bindings don't compile.
03:10:57 <jameseb> mjrosenb: what error are you getting?
03:11:24 <mrkkrp> Hello, if a program need to have some parameters that may be changed interactively, is State monad is the only way? My current implementation uses StateT, and I end up writing most part of my program inside StateT. Is it normal?
03:13:23 <EvanR> youre already doing better than you could be, because you might have said "i need the parameters changed interactively so im doing everything in IO"
03:14:43 <EvanR> but if the parameters are only being changed via interaction, why not Reader or ReaderT ?
03:15:24 <mjrosenb> jameseb: https://gist.github.com/9d78064290dee0fde947
03:16:52 <mrkkrp> EvanR: I will look into it
03:17:16 <jameseb> mjrosenb: it seems to think you don't have the sdl2 library installed
03:18:01 <mjrosenb> which is almost certainly not the case
03:18:10 * mjrosenb wishes it said why it believed that.
03:18:41 <jameseb> what OS are you on?
03:19:44 <mjrosenb> linux.
03:20:18 <bennofs> mjrosenb: do you have pkgconfig installed?
03:20:32 <bennofs> That sometimes helps
03:20:38 <reem> How can I go from ['1', '2', '3', '4'] => [1, 2, 3, 4]?
03:20:52 <mauke> :t map digitToInt
03:20:52 <lambdabot> [Char] -> [Int]
03:21:10 <reem> wondrous
03:22:04 <jameseb> mjrosenb: do you have the dev version of sdl2 installed?
03:22:17 <mjrosenb> they're all the dev versions.
03:23:13 <mjrosenb> bennofs: I have a pkg-config, if that is what you mean.
03:26:44 <mniip> > digitToInt '!'
03:26:46 <lambdabot>  *Exception: Char.digitToInt: not a digit '!'
03:27:11 <nymacro> Could someone please take a second to look at this type error and explain to me why I am an idiot. I would be super helpful: http://pastebin.com/43S9ChcD
03:30:09 <mauke> nymacro: did you redefine 'rem' somewhere?
03:30:39 <nymacro> I am pretty sure I didn't do that
03:30:42 <mauke> the error says rem is an Int64
03:30:44 <Axman6> what happens if you remove fromIntegral in the definition of skipBytes?
03:30:51 <nymacro> same error
03:30:58 <mauke> show the whole file
03:31:04 <nymacro> oh wait..
03:31:07 <Axman6> oh good catch
03:31:07 <nymacro> i am an idiot
03:31:08 <nymacro> sorry
03:31:19 <nymacro> mauke: you're on the mark -_-
03:31:29 <mauke> \o/
03:31:37 <nymacro>   rem <- remaining
03:31:54 <Axman6> yeah rem is one of those functions that I think i've shaddowed many times, usually in parsing code
03:32:27 <nymacro> The error looked almost correct.. almost..
03:33:29 <nymacro> You guys are champs. I probably would have sat there for a while longer. :)
03:33:39 <mauke> I speak compiler
03:33:53 <Freundlich> Doesn't ghc warn about shadowing?
03:34:06 <nymacro> not in this instance
03:38:29 <zipper> I need to import something from the latest QuickCheck but one of the packages I am depending on (test-framework-quickcheck) depends on an older version of quickcheck.
03:38:50 <zipper> How can I get around this? Mind you this is all happening in one sandbox
03:39:41 <bennofs> zipper: test-framework is not maintained anymore AFAIK. You could switch to tasty
03:41:08 <merijn> mjrosenb: For what it's worth just "cabal init" should walk you through setting up a cabal project
03:41:19 <merijn> Freundlich: It does if you enable -Wall
03:41:31 <merijn> Freundlich: Which you should probably enable since it warns about lots of useful things
03:42:21 <Kaligule> Hello there
03:42:29 <Freundlich> merijn: Ok, thank you. That's what I was hoping for.
03:42:55 <merijn> Freundlich: The correct approach with GHC is -Wall and explicitly silence those warnings you don't want.
03:43:08 <merijn> I think without -Wall it doesn't even warn about incomplete patterns (sadly)
03:44:00 <Eliel_> ghc is complaining about a type error and I'm having a little trouble figuring out exactly what's wrong. Here's the error http://lpaste.net/8087558941766057984 and here's the code https://github.com/blitzcode/ray-marching-distance-fields/blob/master/QuadRendering.hs#L186
03:44:12 <zipper> bennofs: Arrgghhhhh I was in the dark
03:44:46 <zipper> bennofs: I swear all documentation on writing tests in haskell is from past 2010
03:45:04 <zipper> I've been having a lot of issues with testing in haskell.
03:46:14 <merijn> Eliel_: Ok, so an exercise in socratic reasoning, do you understand what line 7 & 8 of that error are telling you?
03:46:34 <merijn> Eliel_: As a clue: ~ means type level equality
03:48:36 <Eliel_> it looks to me like the compiler is just uncertain if a0 can be considered equal to (a, QuadRenderBuffer) and wants me to clarify that it's indeed supposed to be considered equal.
03:49:04 <merijn> Eliel_: No, it's telling you that there's two conflicting demands being placed on it in a way that it can't prove
03:49:07 <Eliel_> I just can't figure out where I can do that in this code (not my code, I'm trying out code I found on github)
03:49:58 <merijn> Eliel_: i.e., something is claiming that there's a value of type "StM m (Maybe (a, QuadRenderBuffer)" and something else is claiming the same value has type "StM m (Maybe a0)" and it's not able to prove that those two are the same (which is because they're not...)
03:50:39 <merijn> Eliel_: So on line 6 of the error we see GHC telling us that it noticed this problem while dealing with line "209" of the source file, and if we go there what do we find?
03:51:08 <merijn> Eliel_: An expression that happens to stretch from line 209-212, now what can you tell me about the type of that expression?
03:51:38 <Eliel_> it returns type (a, QuadRenderBuffer)
03:52:00 <Eliel_> ... I think, I'm not sure about that bindVBO below it
03:52:07 <merijn> Eliel_: Right, yet if we look at the type signature of withQuadRenderBuffer on line 186-191 we see?
03:52:24 <merijn> bindVBO is the second argument to "finally" on line 208
03:52:37 <Eliel_> merijn: please look at the part on line 222
03:52:57 <Cale> But the type of withQuadRenderBuffer says that its result has type m (Maybe a), not m (Maybe a, QuadRenderBuffer)
03:53:31 <Cale> ah, okay
03:53:51 <Eliel_> Cale: I tried to change that, the error changed sligthly but was essentially the same.
03:54:08 <merijn> Eliel_: Can you annotate the type of bindVBO on line 197?
03:54:29 <merijn> Actually, no that shouldn't matter
03:55:09 <merijn> oh, I do see it
03:56:02 <Kaligule> Hi, I am pocking around with the CGI Module ( http://hackage.haskell.org/package/cgi-3001.2.2.0/docs/Network-CGI.html ) and struggle combining it with the IO Monad.
03:56:04 <merijn> There's a type mismatch with the 'run' function passed in on 196
03:56:05 <Kaligule>   How can I convert a String read in by getInput to IO(String)? I think I am searching for a funkction with type (MonadCGI m) => m a -> IO a ?
03:56:15 <merijn> But tbh, I find this whole MonadBaseControl thing pretty confusing
03:57:37 <merijn> Kaligule: I don't see a getInput function in those docs?
03:57:56 <Cale> Kaligule: runCGI :: MonadIO m => CGIT m CGIResult -> m ()
03:59:17 <Kaligule> merijn: It is there: http://hackage.haskell.org/package/cgi-3001.2.2.0/docs/Network-CGI.html#g:6
03:59:29 <Kaligule> Cale: Thanks, I will try that.
04:00:09 <Cale> Kaligule: There should typically be only one runCGI in your program
04:00:18 <Cale> Kaligule: Usually in main
04:01:34 <Cale> Kaligule: and then the action which gets passed to that will be a CGI action, most likely
04:02:04 <Cale> and for example, getInput :: String -> CGI (Maybe String)  is a possible specialisation of its type
04:02:41 <Kaligule> Cale: So I have 1 "runCGI" for geting input and some "output" for generating the output?
04:02:42 <merijn> Eliel_: Anyway, I recommend figuring out what the type of 'run' is on line 196, use typed holes if you have ghc 7.8
04:03:21 <Kaligule> Cale: I will try that, this is better than running everything in the CGI monad
04:03:23 <Eliel_> merijn: I'd really like to load this thing in ghci and play with the types interactively but ... it's been too long since I played with haskell so I can't recall how to do that.
04:03:29 <Cale> Kaligule: The output will be inside the same CGI action that you pass to runCGI.
04:03:51 <Eliel_> it doesn't compile so the straightforward method doesn't work.
04:04:32 <merijn> Eliel_: ":l file.hs" ?
04:04:39 <Kaligule> Cale: So where will I store the computation? Inside the CGI?
04:04:53 <Cale> Kaligule: I don't understand what you mean by store?
04:05:31 <merijn> Eliel_: Comment out the lambda from line 196 through 220 and replace it with "_func" (including underscore at the start) and it'll tell you the type in 7.8
04:06:06 <Cale> Kaligule: The single CGI action you pass to runCGI will ultimately contain most of the logic of your server, but that doesn't mean everything has to be written using the CGI type, since CGI actions can use IO actions as well as pure functions and other stuff in their definition.
04:06:33 <Kaligule> Cale: I thought I would  have 3 commands in the main: get some Input (by your advice via runCGI), compute something with it, give it back.
04:06:51 <Eliel_> merijn: ok, thank you, I'll try that.
04:07:09 <Cale> Kaligule: No, you want the runCGI further out. The action you pass to runCGI should also do the computing and output.
04:07:26 <breadmonster> Cale merijn: What's the difference between Text.Derp and Text.Parsec?
04:07:37 <Cale> breadmonster: What's Text.Derp?
04:07:56 <breadmonster> https://hackage.haskell.org/package/derp-0.1.1/docs/Text-Derp.html
04:08:03 <breadmonster> Cale: : ^
04:08:53 <Eliel_> merijn: it's telling me "Found hole ‘_func’ with type: t0
04:08:56 <Cale> um, lots? :)
04:08:58 <Kaligule> Cale: so I will have a CGImain :: CGI Result wich does contain readInput, computation and IO altogether?
04:09:00 <Eliel_> merijn: this is what you meant?
04:09:06 <breadmonster> Cale: can you ELI5?
04:09:34 <Axman6> well, for one, no one has ever heard of Text.Derp
04:09:57 <merijn> Eliel_: Yeah, basically when GHC finds a name that 1) starts with an underscore and 2) is not in scope, it will print out the inferred type
04:09:59 <pacak> They have a paper attached
04:10:03 <Cale> This library is tiny and not very full featured compared to Parsec, and it uses a different method of building parsers...
04:10:27 <breadmonster> Cale: Okay, then I'll just use Parsec instead.
04:11:04 <zipper> breadmonster: Hey nice nick
04:11:20 <Cale> Kaligule: Pretty much
04:11:42 <breadmonster> zipper: Thanks.
04:12:33 <Cale> Kaligule: you won't be able to name it CGImain because that starts with a capital letter (so it'd have to be a data constructor), but otherwise, that's the right idea. Note that you can turn an arbitrary IO action into a CGI action using  liftIO :: IO a -> CGI a
04:12:53 <Cale> Kaligule: (really liftIO is more polymorphic than that, but that's the type at which you'd be using it)
04:17:23 <Kaligule> Cale: I think that works. At least the types work out now.
04:18:04 <Kaligule> Cale: Thank you. Were you involved in writing the CGI Module or do you just happen to know it well?
04:18:47 <Cale> Kaligule: I don't know it all that well, I'm just good at reading documentation, because I've been programming in Haskell since 2001 or so.
04:20:29 <Kaligule> Ahh, so you are 12 years ahead. Thanks :)
04:29:48 <breadmonster> Cale: I'm having a slight issue with Parsec.
04:29:55 <breadmonster> How do I explicitly annotate types?
04:29:58 <breadmonster> I don't get that.
04:30:30 <Cale> breadmonster: Well, if you can write something which passes the typechecker, you can always ask GHCi what type it is with :t
04:30:49 <Cale> breadmonster: But you probably won't need all the polymorphism you're getting
04:30:56 <breadmonster> Cale: I don't.
04:31:10 <Cale> So it might make sense just to use one of the Parser type synonyms
04:31:18 <breadmonster> What are those?
04:31:26 <Cale> http://hackage.haskell.org/package/parsec3-1.0.0.9/docs/Text-Parsec-Text.html -- for example
04:31:49 <Cale> http://hackage.haskell.org/package/parsec3-1.0.0.9/docs/Text-Parsec-String.html -- or this
04:32:12 <breadmonster> Cale: So just import Text.Parsec.String instead of Text.Parsec?
04:32:22 <Cale> um, in addition to
04:32:40 <breadmonster> Cale: Does it matter which one I import first?
04:32:46 <Cale> no
04:33:06 <Cale> (in general, it doesn't matter which order you list imports in)
04:33:56 <breadmonster> Cale: Also, do you know how to type annotate GHCi declarations?
04:34:01 <breadmonster> It keeps asking me to do that.
04:35:16 * hackagebot foreign-store 0.2 - Store a stable pointer in a foreign context to be retrieved later.  http://hackage.haskell.org/package/foreign-store-0.2 (ChrisDone)
04:36:05 <Cale> breadmonster: Sorry, can I see the error message?
04:36:14 <Cale> breadmonster: Is it complaining that something is ambiguous?
04:37:42 <tdammers> "Error: Ambiguous error dialog. Cancel operation? [Cancel] [Cancel]"
04:37:57 <breadmonster> Cale: One second, I'll PM? It's pretty long.
04:38:04 <Cale> okay
04:38:10 <Cale> Or just use lpaste.net
04:39:16 <breadmonster> Cale: http://lpaste.net/120198
04:40:27 <Cale> breadmonster: It's probably best to avoid this just by not typing declarations into GHCi
04:41:25 <breadmonster> Cale: Okay, so suitable alternative?
04:41:43 <breadmonster> I'd like this to typecheck.
04:41:54 <breadmonster> Also, is there a ghc prompt to only typecheck a particular file?
04:42:06 <Cale> But you could type :set -XNoMonomorphismRestriction (you can tab complete that) to avoid this issue, it's complaining because parsePositive is a pattern binding, and it's type class polymorphic, so the monomorphism restriction applies to it.
04:42:55 <Cale> You could give an explicit signature like  let parsePositive :: Parser String; parsePositive = many1 digit
04:43:17 <Cale> But that's awkward to type at the GHCi prompt, just make a file and stick your declarations in that.
04:43:25 <breadmonster> Cale: Oh okay awesome.
04:43:42 <Cale> I recommend always having (at least) two windows open, one with your editor, and the other with ghci :)
04:43:54 <Cale> :r in ghci will reload when you save the file in your editor
04:49:13 <Kaligule> Is there any clever algebraic name for a function a -> a?
04:49:22 <mniip> id
04:49:38 <bennofs> Kaligule: Endomorphism (if not forall a)
04:49:41 <bennofs> :t Endo
04:49:42 <lambdabot> (a -> a) -> Endo a
04:49:43 <mniip> oh
04:49:55 <mniip> endomorphism yes
04:50:25 <Kaligule> a, that was the word I searched for. Thanks.
04:58:13 <haskellNoob> hello all.  I have a question on trying to access a type class method via the type without having an actual instance of that class
04:58:23 <haskellNoob> example code is here:  <script src="https://gist.github.com/jason-johnson/49479a4a4f4386d19b00.js"></script>
04:58:25 <haskellNoob> oops
04:59:17 <haskellNoob> https://gist.github.com/jason-johnson/49479a4a4f4386d19b00
05:01:12 <barrucadu> haskellNoob: The 'a's in your function are not the 'a's in the type. You want ScopedTypeVariables
05:02:06 <haskellNoob> barrucadu:  Yea, I figured the a's were different.  Is this the only way to force them to be the same?  Is there a more proper way to do what I'm trying to do here?
05:02:47 <haskellNoob> I also tried writing the whole thing as one line so the `a` should be the same but that didn't work either
05:03:07 <haskellNoob> I also tried using Proxy but that didn't help either (presumably for the same reason)
05:03:24 <barrucadu> If the type inference isn't able to solve the problem, then I think ScopedTypeVariables are your best bet
05:04:43 <haskellNoob> barrucadu: hrm, I added ScopedTypeVariables but no change
05:05:24 <barrucadu> You also need to specify which variables you want it to work with, so add a "forall a." to the start of your function's type
05:07:41 <zipper> Does the test type detailed-0.9 work?
05:08:36 <haskellNoob> barrucadu: yep, that seems to work.  Thanks for your help
05:15:19 * hackagebot twitter-types 0.7.0 - Twitter JSON parser and types  http://hackage.haskell.org/package/twitter-types-0.7.0 (TakahiroHimura)
05:20:19 * hackagebot twitter-types-lens 0.7.0 - Twitter JSON types (lens powered)  http://hackage.haskell.org/package/twitter-types-lens-0.7.0 (TakahiroHimura)
05:36:56 <tomphreek> is it possible to generate all permutations using Control.Monad.List? somewhat like powerset = filterM (const [True, False]). If it is a hint would be appreciated. I am trying to solidify my understanding of List monad by posing this question.
05:37:16 <mauke> :t permutations
05:37:17 <lambdabot> [a] -> [[a]]
05:37:24 <mauke> HTH
05:38:20 <tomphreek> it doesn't use Lists as monads.
05:38:29 <tomphreek> just recurrence
05:39:08 <lpaste> breadmonster pasted “number parsers” at http://lpaste.net/120201
05:39:15 <breadmonster> Is that bad style?
05:40:46 <merijn> breadmonster: It's pretty brittle
05:40:53 <breadmonster> merijn: How so?
05:41:07 <merijn> > read "3.1e-2" :: Double
05:41:07 <mauke> tomphreek: I'm thinking of something like: permutations (x : xs) = do ys <- permutations xs; (pre, post) <- splits ys; return (pre ++ [x] ++ post)
05:41:08 <lambdabot>  3.1e-2
05:41:17 <merijn> breadmonster: Your parser doesn't accept that
05:41:28 <breadmonster> merijn: Cool stuff, will add.
05:41:48 <breadmonster> merijn: anything else?
05:41:51 <breadmonster> I didn't know this
05:42:41 <breadmonster> > read "31.2e0" :: Double
05:42:42 <lambdabot>  31.2
05:42:53 <breadmonster> > read "31.2e-2.4" :: Double
05:42:54 <lambdabot>  *Exception: Prelude.read: no parse
05:42:58 <breadmonster> Okay, fine.
05:44:24 <insitu> hello following upgrade to cabal 1.22, cabal install suddenly chokes on my .cabal fine: it says build-depends is not allowed anymore in the Library section
05:44:57 <bennofs> insitu: please show the cabal file
05:45:00 <bennofs> @where lpaste
05:45:00 <lambdabot> http://lpaste.net/
05:45:01 <insitu> tried to browse internet but could only find reference to a bug about pretty printing which is apparently unrelated
05:47:19 <insitu> ok
05:47:35 <insitu> found the culprit while pasting the .cabal file on lpaste :-)
05:47:53 <insitu> there was a `build-depends:  base` directive at toplevel
05:48:11 <insitu> thanks for helping
06:09:46 <fractalsea> I have a JSON string that I want to parse using Aeson. It contains a field that is a string, but contains an escaped JSON object. I want to parse this into a a field of type Text. However I get the error “Failed to decode JSON; when expecting a Text, encountered Object instead”. http://pastebin.com/g2ERmCwe
06:10:48 <Fuuzetsu> :t parseJSON
06:10:49 <lambdabot> Not in scope: ‘parseJSON’
06:12:12 <fractalsea> Oh my parseJSON is defined like so http://pastebin.com/t3hYBN1s
06:12:13 <Fuuzetsu> fractalsea: as your comment says, Aeson is ignoring the fact that it's an escaped object because such a notion doesn't exist
06:12:34 <fractalsea> But why doesn’t it treat it like a regular string?
06:12:59 <Fuuzetsu> hm
06:13:07 <Fuuzetsu> I don't know, what Value does it parse out to?
06:13:34 <fractalsea> How can I check that?
06:13:42 <fractalsea> It eventually should be Text
06:13:54 <Fuuzetsu> you should post a snippet of your actual JSON
06:13:56 <fractalsea> Not sure what intermediate Aeson value it would be
06:14:05 <jtanguy> the error tells you that it got an Object
06:14:06 <Fuuzetsu> and check it just by printing the results when you take Value
06:14:37 <fractalsea> Yeah I think it thinks it’s an object, i.e. implicitely parsing the string
06:15:12 <fractalsea> There’s a snippet of the JSON I’m trying to parse in the pastebin link
06:15:45 <jtanguy> what if you change your msgData to Object instead of Text ?
06:16:18 <jtanguy> or even Value
06:20:20 <fractalsea> jtanguy: then it works fine, but it’s not what I want
06:20:23 * hackagebot on-demand-ssh-tunnel 0.1.0.4 - Program that sends traffic through SSH tunnels on-demand  http://hackage.haskell.org/package/on-demand-ssh-tunnel-0.1.0.4 (pedja)
06:20:25 * hackagebot on-demand-ssh-tunnel 0.1.0.5 - Program that sends traffic through SSH tunnels on-demand  http://hackage.haskell.org/package/on-demand-ssh-tunnel-0.1.0.5 (pedja)
06:21:39 <fractalsea> Seems like Aeson recursively tries to parse or something
06:23:34 <jtanguy> you might want to derive your FromJSON instance manually then
06:24:17 <jtanguy> maybe using jstring instead of value for your msgData parser
06:25:35 <oscar__> msg oscar_toro hej!
06:25:59 <fractalsea> jtanguy: Well I have defined my FromJSON like this already http://pastebin.com/YRWbbSqr
06:26:20 <fractalsea> jtanguy: Is that what you mean?
06:30:33 <jtanguy> hum FromJSON already takes a Value
06:31:09 <jtanguy> you might want to operate at the Attoparsec level, and define your parser there
06:31:16 <jbracker> Has anybody here tried to use the TypeChecker plugins in the current dev version of GHC? https://ghc.haskell.org/trac/ghc/wiki/Plugins/TypeChecker
06:31:43 <fractalsea> hmm ok, sounds pretty nasty. Good idea though
06:32:19 <jtanguy> or maybe encode the data to a Text builder and get the Text form that
06:33:13 <fractalsea> What before I run aeson decode on it?
06:36:02 <sedeki> general question. does haskell have the overhead of one function call on each iteration / each time i want to use a looping construct = recursion?
06:36:27 <sedeki> or does it transform it somehow (is it mathematically possible even)
06:36:53 <Eliel_> sedeki: depends on the function but it is avoided in many cases.
06:36:56 <opqdonut> the machine code generated is very far from the code you wrote, especially with optimizations
06:37:45 <Eliel_> most standard looping constructs won't have that overhead.
06:37:49 <opqdonut> see e.g. http://lambda.jstolarek.com/2013/04/haskell-as-fast-as-c-a-case-study/
06:38:28 <arw_> sedeki: there are transformations like the removal of calls, elimination of recursion and map/fold fusion. so in most simple cases, it will be optimized.
06:38:42 <opqdonut> or http://neilmitchell.blogspot.fi/2014/01/optimising-haskell-for-tight-inner-loop.html
06:39:03 <sedeki> thanks for the links guys, didn't expect much help but there we go
06:39:42 <arw_> sedeki: but sometimes there are unexpected things that will bite you, like lazy evaluation. (well, only unexpected if you are new to haskell)
06:41:15 <sedeki> thanks
06:43:16 <arw_> oh, and mathematically its often possible because of the purity of most constructs (purity is of course a haskell buzzword)
06:45:17 <Ongy> Hi, is there a difference during execution betwenn the two implementations proposed in: http://pastebin.com/njNgz3UA ?
06:48:22 <Saizan> Ongy: if you inline liftM you get the first version
06:48:37 <bergmark> Ongy: looks the same to me
06:49:11 <tomphreek> mauke: what did you mean by splits? I think your method going to have many duplicates...
06:50:11 <tomphreek> the way I am thinking right now is to "map" "abc" so that a -> [0, 1, 2]; b-> [0, 1]; c -> [0];
06:50:37 <tomphreek> that should generate permutations
06:50:55 <Ongy> ok thanks
06:55:46 <Schrostfutz> hi, coming from imperative/oop languages, what would be the functional way of combining two sets, where entries from the second one replace entries from the first if they have the same name?
06:56:07 <mauke> tomphreek: splits [1,2,3] = [([], [1,2,3]), ([1], [2,3]), ([1,2], [3]), ([1,2,3], [])]
06:56:13 <mauke> tomphreek: i.e. all possible ways to cut a list in two
06:56:58 <mauke> Schrostfutz: Set.union b a
06:57:42 <Schrostfutz> mauke: the elements also have other fields, so they dont have to be equal, just their name has to match
06:57:55 <tomphreek> > mapM (\(ch, size) -> [0..size]) [('a', 2), ('b', 1), ('c', 0)]
06:57:57 <lambdabot>  [[0,0,0],[0,1,0],[1,0,0],[1,1,0],[2,0,0],[2,1,0]]
06:58:08 <mauke> Schrostfutz: ... ok?
06:58:12 <tomphreek> -- trying to get permutaitons of "abc" using List monad
06:58:43 <Schrostfutz> mauke: so a simple union wont work, I think, because the elements are not the same
06:59:10 <geekosaur> then the items aren't the same. perhaps you intend a Map?
06:59:34 <mauke> Schrostfutz: depends on how your Ord instance is defined
07:00:05 <Schrostfutz> geekosaur: propably that would be the best solution
07:00:19 <geekosaur> hrm, Ord instance feels like abuse of something...
07:00:31 <mauke> yes
07:00:47 <mauke> anyway, Map.union b a
07:02:43 <tomphreek>  [[0,0,0],[0,1,0],[1,0,0],[1,1,0],[2,0,0],[2,1,0]]
07:03:13 <tomphreek> if only I could it back in a slightly convoluted manner then I'd get my permutations
07:04:03 <tomphreek> [0, 0, 0] is abc and [2, 1, 0] is cba
07:04:51 <SoupEvil> is there a solution for this: http://stackoverflow.com/questions/15996796/haskell-sdl-cant-find-mingw32-dll
07:05:30 <SoupEvil> currently experience the same problem when using sdl2
07:07:31 <mauke> > let splits xs = ([], xs) : case xs of { [] -> []; x : xs' -> map (first (x :)) (splits xs') }; px [] = [[]]; px (x : xs) = do { ys <- px xs; (pre, post) <- splits ys; return (pre ++ [x] ++ post) } in px "tomphreek"
07:07:43 <lambdabot>  ["tomphreek","otmphreek","omtphreek","ompthreek","omphtreek","omphrteek","om...
07:10:17 <tomphreek> mauke: I am trying to understand list monad in the context of nen deterministic computation better. I think I am close in my soln though :).
07:11:56 <tomphreek> mauke: I understand yours, thanks
07:16:30 <tasker> I'm using this dockerfile https://github.com/darinmorrison/docker-haskell, and have had trouble getting profiling to work. I get many erros of the form x depends on y which failed to install, due to enabling profiling. What should I do to fix this ?
07:17:17 <tasker> There are messages like: could not find module x, perhaps you havent installed the profiling libraries for package y
07:17:53 <tasker> Could it be that the binaries the dockerfile is specifing don't have profiling enabled? Or is the mistake more likely to be my own?
07:22:35 <tasker> Ok, so it looks like Prelude is installed without profiling. I assume it isn't safe to --force-reinstalls ?
07:23:52 <hodapp> :t mapMaybe
07:23:53 <lambdabot> (a -> Maybe b) -> [a] -> [b]
07:23:56 <hodapp> \o/
07:25:46 <Saizan> tasker: base should come with your ghc installation, if it's without profiling you probably have more packages to install from your distro
07:26:05 <tasker> Saizan: Hm. Could you suggest what these might be ?
07:26:17 <tasker> the installed packages are those specified here: https://github.com/darinmorrison/docker-haskell/blob/master/7.8/Dockerfile
07:27:14 <Saizan> tasker: e.g. libghc-base-prof
07:27:19 <tasker> ah
07:28:08 <tasker> Saizan: So this dockerfile appears to not be installing any of these packages, and rather directly installing binaries. Are there versions of the binaries with profiling enabled? Or am I completely misunderstanding how things work ?
07:28:29 <tasker> Saizan: My mistake, it is installing ghc
07:28:57 <tasker> (via apt, I mean)
07:33:37 <bitonic> is there an "accepted" way to pass flags to TH?
07:35:53 <Saizan> tasker: installing ghc will install the core libraries as well (in binary form) but not the corresponding profiling versions of those binaries
07:55:11 <tasker> I'm a bit confused. If ghc-7.8.3 is installed on debian, does this also install the base package ?
07:57:02 <Rryy> tasker: yes, the base (hackage/cabal) package is bundled with ghc
07:57:48 <udevd> how do Debug.Trace functions work?
07:58:08 <Rryy> tasker: wait! maybe that is not true on Debian, but I think so
07:58:22 <tdammers> udevd: unsafePerformIO, basically
07:58:42 <udevd> well
07:58:42 <tasker> Rryy: Hehe, okay. I've found reference to both ghc, and ghc-prof. I'm not sure if one complements the other, or if prof should replace ghc..
07:59:00 <creichert> tasker: -prof package are supplimentary in debian
07:59:02 <udevd> interesting to have >unsafe IO in haskell
07:59:04 <creichert> install them in addition to
07:59:19 <tasker> creichert: Cool, thanks!
07:59:20 <creichert> you want ghc and ghc-prof is profiling is the goal
07:59:22 <creichert> no prob!
08:00:02 <udevd> do they affect performance somehow? for instance compiler no longer can assume that things are safe anymore
08:00:36 <creichert> profiling will add overhead, in general. I'm not sure about the safety tbh
08:01:43 <kerr0r> Say I were to write a version of "nub" that used a Data.Set to keep track of items it's seen already. This would of course require the type in the list to be of class "Ord", while normal "nub" only requires "Eq". Is there a way to write a polymorphic function that calls my improved "nub" for lists of "Ord" types, and reverts to plain old "nub" if they're not "Ord"?
08:02:00 <kadoban> IIUC, which is…pretty unlikely, it doesn't hurt anything because GHC just assumes you know what you're doing if you use the unsafe stuff and doesn't check your assumptions at all.
08:02:22 <bennofs> udevd: the compiler still assumes that things are safe in some places. that's why using them is unsafe
08:04:15 <mauke> kerr0r: no
08:06:17 <kerr0r> mauke: Bummer. Oh well.
08:19:29 <josgraha> hi, i'm a haskell newbie seeking to grasp functional programming.  wondering if i should start with lambda calculus or just work my way through LYAH and then dive into more academic topics.  suggestions?
08:19:44 <josgraha> apologies if this is a FAQ
08:19:44 <benzrf> josgraha: neither!
08:19:47 <benzrf> @where to-start
08:19:47 <lambdabot> https://github.com/bitemyapp/learnhaskell
08:19:52 <benzrf> ^use this
08:20:05 <josgraha> sweet, this is why i joined this channel.  thank u sir
08:20:17 <benzrf> you can learn about the lambda calculus if you like, but it probably won't help you /that/ much
08:20:21 <benzrf> and LYAH has some issues
08:21:01 <n00b83> i'm trying to use WebDriver (the Selenium client) and I'm getting: BadJSON "when expecting a StackFrame, encountered Null instead"
08:21:07 <hiptobecubic> "ShellCheck is written in Haskell, and requires 2 GB of memory to compile."
08:21:09 <josgraha> i am also working my way through the pluralsight course by Benson Joeris
08:21:13 <n00b83> is it failing to produce an exception properly?
08:22:07 <josgraha> well my goal is to have a deep understanding of functional programming in general, also hope to take E. Meijer's course on EdX
08:23:44 <osa1> wouldn't that be awesome if Cabal accepted an extra comma at the end of build-depends list?
08:24:59 <hiptobecubic> yes
08:25:01 <hiptobecubic> it would
08:25:36 <hiptobecubic> i really hate it when languages don't allow trailing commas. I understand why from a pedantic point of view, but as a developer it's just a giant middle finger in your face
08:25:57 <hiptobecubic> Javascript is even worse about it, it just vomits and tries to keep going
08:26:02 <enthropy> why does it need commas at all?
08:26:08 <Yuras> osa1: https://github.com/haskell/cabal/issues/1509
08:26:56 <osa1> Yuras: last update is Jan 2014 and that's not even from OP ;-(
08:27:13 <Yuras> osa1: you may take care :)
08:27:17 <osa1> but it's good to know that it's OK for the devs
08:27:19 <osa1> yeah
08:27:25 <osa1> sounds like a good weekend project
08:27:57 <osa1> enthropy: that's also a good point
08:28:18 <osa1> other-modules doesn't use commas for example
08:28:53 <osa1> I'm really OK with commas as long as it's allowed to have an extra at the end
08:29:16 <breadmonster> Does Haskell have built in string constants?
08:29:37 <mauke> huh?
08:29:38 <breadmonster> Like Python's string.ascii_uppercase
08:29:38 <osa1> what is a string constant?
08:29:44 <clrnd> oh
08:29:55 <tdammers> you mean string literals?
08:29:57 <tommd> > "Hello, I am a string literal".
08:29:58 <lambdabot>  <hint>:1:32:
08:29:58 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
08:30:01 <breadmonster> Yeah, sorry :P
08:30:10 <tdammers> > "Hi there"
08:30:10 <clrnd> no he means string constants
08:30:11 <lambdabot>  "Hi there"
08:30:28 <clrnd> python has string.digits == "0123456789"
08:30:37 <mauke> what for?
08:30:38 <tdammers> oh, that
08:30:42 <tommd> clrnd: Ah, so immutable variables that are strings?
08:30:56 <tdammers> tommd: all variables are immutable in haskell
08:31:08 <tommd> tdammers: Yes, but not in python....
08:31:13 <clrnd> well, yeah, but not really need to be immutable
08:31:26 <breadmonster> tommd: Python's strings are immutable as well.
08:31:27 <tdammers> "constants are variables, too!" :D
08:31:28 <mauke> > ['0' .. '9']
08:31:29 <lambdabot>  "0123456789"
08:31:49 <clrnd> > ['a'..'z']
08:31:51 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
08:31:51 <breadmonster> mauke: Okay fine, I'll have to use that.
08:32:10 <tommd> breadmonster: Depending on your need you could is isDigit.
08:32:17 <mauke> breadmonster: for what?
08:32:21 <mauke> breadmonster: why do you need this?
08:32:23 <breadmonster> mauke: Writing a parser.
08:32:27 <mauke> breadmonster: go on
08:32:42 <clrnd> Parsec has isAlpha I think
08:32:44 <breadmonster> It just makes for fewer keystrokes.
08:32:50 <breadmonster> Nothing really required.
08:32:50 <mauke> breadmonster: than what?
08:32:54 <mauke> breadmonster: and what is "it"?
08:33:09 <tdammers> let digits = ['0'..'9'] in oneOf digits -- something like this, if it weren't built into Parsec already?
08:33:22 <breadmonster> clrnd mauke: I was going to do something like foldl1 char characterSet
08:33:33 <mauke> breadmonster: that makes no sense
08:33:54 <mauke> char takes one argument, not two
08:34:14 <mauke> also, why aren't you using a set if you need a set?
08:34:36 <breadmonster> mauke: a set of characters ie. a list of them.
08:34:44 <mauke> breadmonster: a list is not a set
08:34:45 <breadmonster> It's called the character set, yeah?
08:34:47 <mauke> breadmonster: a set is a set
08:35:39 <breadmonster> "In computer science, the terms "character encoding", "character map", "character set" and "code page" were historically synonymous, as the same standard would specify a repertoire of characters and how they were to be encoded into a stream of code units"
08:35:43 <breadmonster> From Wikipedia.
08:35:46 <breadmonster> But okay, I'll call it something else.
08:35:55 <miklcct> A set is not necessary nordered and normally don't contain duplicates
08:35:55 <mauke> what
08:36:10 <mauke> breadmonster: why don't you just explain what you're trying to do?
08:36:14 <miklcct> A list is ordered, formed by a head joining a tail
08:36:20 <b1> http://lpaste.net/120203
08:36:33 <mauke> breadmonster: it feels like you're trying to protect "secret" information
08:36:55 <mauke> b1: number literals are overloaded
08:37:24 <breadmonster> Okay, okay, I didn't want to waste your time. One second, I'll put the whole code fragment online.
08:37:38 <mauke> b1: in particular, you have 2 :: Num t => t
08:37:52 <jroes> hi yall! I know this is a long shot, but I'm trying to install haskell-platform on ubuntu, and it's trying to install a bunch of X libs. is there a flag I can pass?
08:38:02 <jroes> sorry to pollute with non-language-specific questions :/
08:38:08 <lpaste> breadmonster pasted “Scheme Parser” at http://lpaste.net/120207
08:38:08 <mauke> b1: you're using 2 as a function (applying it to 3), which adds the constraint t ~ (a -> b)
08:38:24 <mauke> b1: i.e. t must be the type of a function
08:38:28 <breadmonster> mauke: That's it
08:38:47 <b1> wow, thanks mauke
08:39:18 <mauke> breadmonster: how are you planning to use characterSet?
08:43:13 <breadmonster_> mauke: character = liftM HCharacter $ string "#\\" >> try (space <|> newline) <|> oneOf characterSet
08:45:14 <mauke> ah
08:45:15 <breadmonster_> mauke: Is that okay?
08:45:20 <mauke> that would work
08:45:25 <breadmonster_> mauke: Yeah I'm not completely nuts :P
08:45:37 <mauke> I may have written it as characterSet = S.fromList $ ...
08:45:53 <mauke> character = ... <|> satisfy (`S.member` characterSet)
08:46:01 <mauke> i.e. store the set as a set
08:46:05 <breadmonster_> Okay, I've never seen the satisfy function.
08:46:11 <breadmonster_> Also, interesting.
08:46:33 <mauke> found it in http://hackage.haskell.org/package/parsec-3.1.8/docs/Text-Parsec-Char.html#v:oneOf :-)
08:46:35 <breadmonster_> I thought the words character set didn't necessarily connote a set.
08:46:57 <breadmonster_> Oh okay, interesting.
08:46:58 <mauke> well, you're doing a membership test
08:47:06 <mauke> seems like a natural operation for a set
08:48:06 <breadmonster_> Interesting, okay then.
08:56:04 <jtanguy> I guess using Set + satisfy member would be faster than using oneOf ?
08:56:59 <mauke> maybe
08:57:01 <jtanguy> I guess the complexity of `elem` on lists is O(n) ?
08:57:07 <mauke> (oneOf = satisfy + elem)
08:57:09 <mauke> yes
08:57:20 <jtanguy> member on Sets is O(log n)
08:57:54 <jtanguy> in theory it should be faster
08:58:29 <ChristianS> jtanguy: it's faster, but you'll only notice a difference for bigger sets
08:58:43 <jedai> for small sets it isn't really significant =though
08:58:51 <jtanguy> indeed
08:59:00 <jedai> in fact there's a chance the constant factors make it worse with a set
08:59:23 <jedai> I guess benchmark are the only way ! :)
08:59:51 <jtanguy> you could also cleverly order your initial list to make elem faster on average
09:01:00 <k0ral> hello haskellers, how would you use the FreeT monad transformer with control functions (e.g. forkIO) since "FreeT a" cannot be made an instance of MonadTransControl ?
09:03:52 <benzrf> what is MonadTransControl :?
09:06:33 <k0ral> benzrf: many "control" functions have a signature like "IO a -> IO b"; forkIO is one of them; when you are running in a stack of monads, let's call it m, you wish forkIO was defined as "m a -> m b"
09:07:08 <k0ral> benzrf: this is what MonadTransControl typeclass aims at solving
09:07:34 <magnapPrime> Hi guys! I have a problem. I want to transform a Data.Map.Map FilePath [IO String] into an IO (Data.Map.Map FilePath [String]). My attempt at doing so is Control.Monad.liftM Data.Traversable.sequence . Data.Map.sequence sequence, but it doesn't work, and I'm not sure why. If anyone could help I'd greatly appreciate it
09:07:37 <benzrf> o_o
09:08:37 <k0ral> benzrf: with usual monads, you can lift an "IO a" into an "m a", but not the other way
09:08:42 <Enigmagic> k0ral: there has been speculation that it can be done with operational (instead of free) but i haven't been successful in making an instance of MonadTransControl for it
09:08:47 <benzrf> magnapPrime: hm
09:08:53 <enthropy> magnapPrime: traverse sequence
09:08:56 <benzrf> enthropy: nice
09:09:34 <ski> magnapPrime : `sequence . fmap sequence'
09:10:17 <Enigmagic> k0ral: in general i find it easier to make instances for random typeclasses in operational though, so maybe you'll have better luck there..
09:10:20 <benzrf> ski: aka traverse sequence :)
09:10:33 <ski> benzrf : yes, i was just checking that :)
09:10:34 <k0ral> Enigmagic: I've read that operational isn't as theoretically satisfying as free because you can't prove as many things as you can with free (let me retrieve that link)
09:10:56 <magnapPrime> enthropy: Thanks a lot! Now I'll go and try to figure out why this works ;-)
09:11:32 <k0ral> Enigmagic: here it is: http://stackoverflow.com/questions/14263363/is-operational-really-isomorphic-to-a-free-monad
09:11:54 <ski> magnapPrime : `fmap' "lifts the cover of" `Data.Map.Map FilePath', allowing `sequence' to get you from `[IO String]' to `IO [String]'. then `sequence' will get you from `Data.Map.Map FilePath (IO [String])' to `IO (Data.Map.Map FilePath [String])'
09:12:05 <Enigmagic> k0ral: doesn't bother me, i use operational for GADTs which are not functors..
09:12:54 <Enigmagic> i think you'll see that the naive approach to implementing MonadTransControl doesn't allow a functor either.
09:13:02 <glguy> sequence . fmap sequence    is     traverse sequence
09:13:10 <ski> yes
09:13:38 <glguy> ah, that was mentioned above already ^_^
09:13:39 <ski> (it's just more natural for me to think in terms of `sequence')
09:14:31 <Enigmagic> anyhow i gotta head to the office
09:14:36 <k0ral> Enigmagic: well, I have no reason to succeed where you have failed
09:14:52 <k0ral> Enigmagic: but thanks for the information :)
09:14:59 <magnapPrime> ski; Thank you. This was what I though I was doing with the previous, but apparently not
09:15:43 <n00b83> so in WebDriver, "BadJSON "when expecting a StackFrame, encountered Null instead" seems to be caused by calling the maximize function
09:16:08 <Enigmagic> k0ral: if you do make one i'd like to see it ;-) anyhow i gotta run
09:19:44 <Darwin226> Hey guys. Say you have a game where the server needs to tell the client the positions of objects. Would it be a better idea to send absolute positions, or just deltas from the last position?
09:20:03 <Darwin226> Size-wise it's pretty much the same thing because deltas aren't that much smaller.
09:21:02 <sssilver|> Darwin226: it depends on the nature of the game
09:21:07 <Darwin226> I know it isn't strictly haskell but I've been thinking about it. It's interesting to me that if you send deltas you only need to last update packet to go one step backwards in time. But if you send absolute positions
09:21:12 <sssilver|> Darwin226: (I somehow assumed it's a game)
09:21:15 <Darwin226> you need the last two. Well actually, the second to last one
09:21:43 <Darwin226> sssilver|: It is a game, yeah.
09:21:57 <sssilver|> Darwin226: what kind of a game is it? an FPS? a chess game? a turn-based strategy?
09:22:10 <bennofs> Darwin226: if you send deltas, then rounding errors will accumulate
09:22:18 <bennofs> (assuming positions are not exact)
09:22:53 <Darwin226> sssilver|: Say it's for an engine and you have to make the best choice without knowing the game. This is more of a theoretical question than a practical one
09:23:06 <sssilver|> sssilver: that question cannot be properly answered then
09:23:15 <Darwin226> bennofs: Not if the server also only updates it's state using the same update packets it sends the client.
09:23:17 <sssilver|> for an FPS the answer is drastically different from a turn-based game
09:23:56 <Darwin226> sssilver|: What are the advantages of one approach over the other?
09:24:02 <k0ral> Darwin226: you could send deltas most of the time, and from time to time, send the absolute coordinates to avoid accumulating errors (that's what some video encodings do)
09:24:52 <sssilver|> in the ideal case (and this is what games like World of Warcraft do), you want to send 'current states' that the game will process until it receives the next update packet.
09:25:08 <sssilver|> Example: your character pushes 'forward'
09:25:22 <sssilver|> the server sends everyone that character X pushed forward in the direction of V vector
09:25:39 <sssilver|> until the clients receive another update, they'll run your character in that direction
09:25:57 <sssilver|> when you release the 'forward' key, the server will tell them 'this character stopped at this position'
09:26:22 <sssilver|> so even if some of them had lag and ran your character further away than you did, they'll see the player 'jump back' to where it ought to be
09:27:07 <fsjdifo> Is there a good resource for programming problems with test data? Like projest euler but with test input data and expected output?
09:27:19 <sssilver|> so it's not deltas and it's not full game state, it's more like events plus event data
09:27:35 <Darwin226> sssilver|: I see.
09:28:42 <sssilver|> Darwin226: again, this is for WoW (although it applies to a wide range of games). There may be a ton of games where this complication makes no sense and simply transferring the entire game state would be the optimal implementation
09:29:18 <sssilver|> also, isn't this #haskell? lol
09:29:49 <bennofs> Maybe try #haskell-blah
09:29:59 <fsjdifo> I'm looking for CS-oriented problems I can solve to learn haskell
09:30:15 <fsjdifo> programming problems
09:30:17 <Darwin226> sssilver|: Yeah. I was hoping someone had some insight regarding that property where you only need the last update to reconstruct the previous state. You can't do that with absolute states.
09:30:24 <sssilver|> fsjdifo: I found this resource pretty awesome https://wiki.haskell.org/99_questions/1_to_10
09:30:45 <fsjdifo> thanks sssilver|  looks good
09:30:48 <Darwin226> sssilver|: There might not be anything interesting about that, but I've been surprised before
09:30:48 <sssilver|> Darwin226: hope I shed some light!
09:30:52 <hiptobecubic> fsjdifo, there are approximately one billion places offering coding challenges. You can just do them *in haskell*
09:31:09 <sssilver|> fsjdifo: note that most of the solutions make no sense to me :)) but still megahelpful to train myself
09:31:37 <sssilver|> Darwin226: not sure I understood
09:31:45 <fsjdifo> hiptobecubic: i cant find any problems with data and stuff so I can make use of stuff pipes, various data structures, threads
09:32:17 <hiptobecubic> kaggle
09:32:50 <Darwin226> sssilver|: Honestly, forget about it. I need to think about it a bit more before it starts making sense to anyone (me included) :D
09:33:13 <fsjdifo> hiptobecubic: kaggle?
09:34:26 <hiptobecubic> fsjdifo, make a rolling histogram generator of twitter words. Make a good ol' fashioned irc bot.
09:34:37 <hiptobecubic> fsjdifo, yes kaggle. "data science" competition site
09:35:31 <fsjdifo> okay ill check it out thanks
09:39:01 <RaceCondition> is there a name for this "pattern" where you have e.g. data Foo = Foo Int, with a private constructor, and then mkFoo :: Int -> Maybe Foo?
09:39:22 <ClaudiusMaximus> RaceCondition: "smart constructor"
09:39:46 <RaceCondition> ClaudiusMaximus: ok, that's what I meant, thanks!
09:43:10 <ski> RaceCondition : i suppose you could also say "partial constructor" in this case (since you're evidently intending the abstract(?) type `Foo' to be a subtype of the representation type `Int')
09:43:42 <RaceCondition> ski: but then "partial" can be ambiguous with partial functions, but a smart ctor isn't a partial fn
09:44:14 <ski> good point
09:44:35 <ski> (so it rather represents a partial function)
09:48:40 <hodapp> somehow, I think that my apparent need for a function (a -> Maybe b) -> Maybe (a -> b) is an indication I have mangled something somewhere
09:49:28 <hodapp> since I'm pretty sure that doesn't make much sense, except the degenerate case of "\ _ -> Nothing"
09:49:45 * ski nods
10:01:06 <Xenasis> How do I write these two patterns to have the same RHS (without writing said RHS twice)? - http://lpaste.net/8843267839180668928
10:01:11 <dfeuer> My brain's twisting around, so I don't know if this name makes sense, but I'm wondering if there's a usual name for this GADT:
10:01:12 <dfeuer> data UnCurry f a where
10:01:12 <dfeuer>   UnCurry :: f k v -> UnCurry f (k, v)
10:02:53 <izohask> what is the difference betweeen quickQuery and quickQuery', in HDBC  ?
10:03:03 <XniX23> does haskell limit you to persistent datastructures only?
10:03:06 <izohask> "quickQuery' is strict" - what does it mean ?
10:03:26 <mauke> Xenasis: lexer ('<' : c : '>' : xs) | c `elem` "-=" = ...
10:03:26 <Xenasis> It's not lazy
10:03:40 <Xenasis> thanks!
10:04:02 <mauke> XniX23: no, there's stuff like STRef and IORef
10:04:13 <ski> XniX23 : no. you can also do ephemeral as mauke say
10:07:15 <XniX23> but wouldn't that break the whole pure functional idea?
10:08:35 <ski> XniX23 : no ?
10:09:25 <ski> not anymore than using an `Int' to index an element in an `IntMap', later replacing the element at that index, does
10:09:47 <ski> you can basically think of an `IORef a' or `STRef s a' as an index into some external data structure
10:10:24 <ski> even if the contents at that index is changed (replaced), the index (/ reference / pointer) is still the same (this is why equality on `IORef a' doesn't require equality on `a')
10:13:33 <ski> XniX23 : an alternative way to do emphemeral data structures is with uniqueness (uniqueness typing in Clean, uniqueness modes in Mercury). the system (statically) checks that you have the only reference to a block of memory, and in that case you can implement a new construction based on the old one by update-in-place (rather by copy&initialize) (and you can get a compile-time inserted deallocation if you drop the reference)
10:14:37 <ski> (btw, note that the sense i used "reference" here is different from the sense i used it above. above was in terms of semantics. here it was in terms of implementation)
10:14:59 <XniX23> ski, so if you have only 1 reference, then it allows you to change it?
10:15:21 <pjdelport> XniX23: Pure functional code does not mean you can't have effects and references; it just means you have to make your effects and reference manipulations first-class and explicit.
10:15:38 * hackagebot calculator 0.2.0.2 - A calculator repl.  http://hackage.haskell.org/package/calculator-0.2.0.2 (sumitsahrawat)
10:15:40 <ski> XniX23 : s/change/update-in-place/. in Clean and Mercury, yes
10:15:42 <pjdelport> (Instead of treating them as implicit side effects.)
10:18:02 <ski> XniX23 : Haskell doesn't have any static uniqueness system. `IO' and `ST s' guarantees that there's a single/unique "global" state data structure, which `IORef's / `STRef's act as indices/keys/references into. you can only access this state by the abstract data type operations for `IO'&`IORef' / `ST'&`STRef'
10:18:20 <hsk3> Recursion is EVERYWHERE in haskell, but i don't understand WHY. is there some mathematical or computer science result out there that proves that all computer programs can be written recursively and that recursion is crucial in purely functional programming, or something like that?
10:18:37 <ski> hsk3 : iteration is a special case of recursion
10:18:50 <dfeuer> Yes, there are a lot of mathematical results about recursion.
10:19:07 <dfeuer> No, I don't know much about them.
10:19:07 <ski> recursion can be implemented in terms of iteration, but not locally (iirc)
10:19:29 <ski> hsk3 : recursion is also in natural language
10:20:04 <hsk3> hm ok
10:20:21 <pjdelport> hsk3: Do you understand what it means to say that iteration is a special case of recursion?
10:20:21 <padre_angolano> hsk3: https://en.wikipedia.org/wiki/Computability_theory "Computability theory, also called recursion theory, is a branch of mathematical logic, of computer science, and of the theory of computation"
10:20:23 <ski> "the color of the cat that bit the hat that Jenny's uncle sat on", &c.
10:20:50 <hsk3> pjdelport: not really
10:20:57 <dfeuer> ski, I'm playing today with  data UnCurry f a where UnCurry :: f k v -> UnCurry f (k,v)   It seems somewhat nice, but I'm wondering if there's a way to do something similar with type/data families
10:21:17 <pjdelport> hsk3: Maybe https://en.wikipedia.org/wiki/Recursion_(computer_science)#Recursion_versus_iteration helps?
10:21:21 <dfeuer> Specifically to get something newtypish instead of dataish.
10:22:19 <pjdelport> hsk3: But it's literally true: when you have an iterative loop, it is exactly equivalent to a tail-recursive function that calls itself for each step of the loop.
10:22:32 <ski> hsk3 : an "iterative process" is usually implemented in commonly used imperative languages using `while' or `for' loop constructs (or similar) (or sometimes using `goto'). given "proper tail recursion", we can just as well implement the same iterative process using tail recursion (a special case of recursion)
10:22:51 <hsk3> ok
10:22:55 <hsk3> intersting
10:23:04 <ski> hsk3 : a "recursive process" must be implemented either via recursion in the language, or by simulating it (by simulating a stack, in some way)
10:23:20 <pjdelport> hsk3: Scheme is a good example of the first language that discarded iteration as a special case, and just kept tail-recursive functions. It still has syntax for loops, but it's just a recursive function under the hood.
10:23:35 <hsk3> but in C, you can use both recursion and while loops. In Haskell, only recursion?
10:23:41 <pjdelport> Right.
10:23:52 <hsk3> ok
10:24:15 <ski> hsk3 : because Haskell lists are non-strict, one can also get an iterative process (sometimes), even if not using tail recursion. `map' isn't defined tail-recursively, but compositions of that can still be iterative (more specifically : incremental). tail recursion tends to be "bulky" (the opposite of incremental)
10:24:21 <pjdelport> hsk3: But in C, the while loop is just, mathematically speaking, a recursive function of the loop's state.
10:24:33 <hsk3> cool
10:24:55 <mmachenry> hsk3: A while loop depends on there being state manipulated in order for the loop to terminate. Functional programmers believe that that is hard to reason about that a recursive function where expressions reduce to values.
10:25:41 <ski> @let while :: (s -> Bool) -> (s -> s) -> (s -> s); while cond step s | cond s = while cond step (step s) | otherwise = s
10:25:43 <lambdabot>  Defined.
10:26:06 <mmachenry> hsk3: So we don't have them for that reason. You could implement a while loop on top of recursive in the state monad and have the condition change within that state, but to my knowledge no one has made a library for this because it doesn't seem all that useful to have a while loop when you efficient recursion.
10:26:38 <hsk3> hehe
10:26:42 <dfeuer> pjdelport, it only sort of has syntax for loops. The do syntax (which seems terribly awkward to me) is generally implemented as a macro. The "named let" syntax is a fair bit more general than iteration.
10:27:25 <ski> > snd (while (\(i,f) -> i > 0) (\(i,f) -> (i - 1,i * f)) (5,1))
10:27:26 <lambdabot>  120
10:27:27 <ski> > snd (while (\(i,f) -> i > 0) (\(i,f) -> (i - 1,i * f)) (5,1))  :: Expr
10:27:28 <lambdabot>  (5 - 1 - 1 - 1 - 1) * ((5 - 1 - 1 - 1) * ((5 - 1 - 1) * ((5 - 1) * (5 * 1))))
10:28:20 <mmachenry> hsk3: I was wrong, someone implemented while in Haskell. https://hackage.haskell.org/package/loop-while-1.0.0/docs/Control-Monad-LoopWhile.html
10:28:25 <mmachenry> I bet it's not very popular.
10:28:28 <ski> (it might be nicer to join the arguments of type `s -> Bool' and `s -> s' into one of type `s -> (Bool,s)' .. or even `s -> Maybe s')
10:28:32 <ski> @type unfoldr
10:28:33 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
10:28:50 <hsk3> Heh ok. Yeah, i'm not too interested. I was just curious. As a haskell programmer i'll do things the haskell way
10:29:05 <hsk3> It makes more sense now why recursion is everywhere
10:30:02 <ski> dfeuer : `do' can sometimes be nice. some variant of `foof-loop'/`loopy-loop' is more modular (and also more expressive)
10:31:17 <dfeuer> mmachenry, it actually looks like a fairly nice bit of work. Specifically, it seems to support a nice version of the "break" concept.
10:31:50 <dfeuer> I bet it's not popular, but now I know it exists, I would consider using it for some weird things.
10:32:05 <mmachenry> dfeuer: Yeah sure
10:32:34 <ski> hsk3 : anyway : if you have tail recursion, then you get an iterative process (assuming you don't build up an unbounded amount of storage on "the heap" in each step). the converse doesn't hold since you can also get an iterative process by composing incremental (delayed) operations (compare with coroutines)
10:32:59 <dfeuer> Regarding its popularity, mmachenry, you are totally right. It's only been downloaded 188 times since 2010.
10:33:05 <mmachenry> dfeuer: I implemented a loop myself recently that could be written with this. Basically I used to have a "Control.Monad.forever" but then I realize "nothing is forever" so I rewrote it as a recursive function.
10:34:11 <ski> mmachenry : `forever' can be useful in an exception monad
10:35:37 <ski> > (`runStateT` 1) . forever $ do n <- get; if n > 1000 then lift (Left n) else put (2 * n)
10:35:39 <lambdabot>  Left 1024
10:35:41 <lelf> How do you "cabal install-docs-as-always --dont-do-anything-else"?
10:35:54 <ski> this executes until it aborts with the exception (`1024')
10:36:46 <quchen> lelf: cabal haddock?
10:37:08 <jle`> that's neat ski
10:38:24 <lelf> quchen: won't install docs, won't update index, skips deps
10:38:38 <eacameron> I keep getting "cabal: permission denied" when installing stuff on Windows into a sandbox (cabal 1.22). But it only happens after a while (after installing several packages). Running the console as admin makes it go away. What could possibly be requiring admin to install into a sandbox?
10:38:55 <eacameron> I'll add that this did not happen with previous cabal versions
10:43:14 <Twey> dfeuer: http://lpaste.net/108354
10:44:40 <Denommus> oh, great, I'm unable to enter ##programming again
10:45:14 <Twey> Denommus: You got an identification-related ban, IIRC
10:45:16 <shapr> Denommus: it's okay, you're in a better place.
10:45:25 <Twey> Hehe.
10:45:40 <shapr> Denommus: Have you tried Haskell?
10:45:44 <clrnd> Denommus, did you preach the benefits of FP and the greatness of type safe languages?
10:45:46 * shapr winds up for a tour...
10:45:54 <shapr> man, I haven't given a tour in years...
10:46:03 <Denommus> I know Haskell well
10:46:16 <Denommus> Twey: I don't think ERC can currently do SASL :-/
10:46:21 <shapr> Denommus: oh cool! Do you use it at your job?
10:46:32 <shapr> Denommus: quick, write an IRC bouncer in Haskell that does SSL!
10:46:54 <clrnd> use the IO monad
10:46:55 <Denommus> shapr: in a certain way, I do
10:47:15 <Twey> Denommus: You can use Freenode's login thing: set your server password to account_name:password
10:47:43 <shapr> Denommus: ooh, tell me more!
10:47:44 <Twey> Denommus: But also http://www.emacswiki.org/emacs/ErcSASL
10:47:59 <athan> Are data constructors just bijective haskell functions?
10:48:00 <dfeuer> Twey, I'm not quite sure where all that is going. My own particular desire was for a nice way to make a Foldable instance for Map whose foldr would look like foldrWithKey, etc.  So that UnCurry Map (k,v)  would be represented by  Map k v.
10:48:08 <athan> (because of pattern matching?)
10:48:19 <Denommus> shapr: I'm doing some internal services, used for our metrics, in GHCJS
10:48:36 <shapr> Wow, that's great! What company are you doing this for? Or is that secret information?
10:48:47 <Denommus> Twey: I used to use this, but it broke on Emacs 24.4
10:48:52 <Denommus> Twey: let's see if it's fixed
10:49:02 <Twey> Denommus: Did you apply for the FB Haskell hiring round?
10:49:06 <shapr> if it IS fixed, I'll start using it too!
10:49:50 <Denommus> Twey: I tried to apply to some companies. Waiting for a response
10:50:04 <dfeuer> Denommus, your TupleC class might be what I was looking for. Not sure.
10:50:24 <Denommus> dfeuer: TupleC class?
10:50:36 <dfeuer> EEr....
10:50:40 <dfeuer> Sorry, that was for Twey.
10:51:03 <Twey> dfeuer: Mm, I don't think it lifts to the type-level.
10:51:57 <ReinH> athan: not necessarily. data Proxy a = Proxy is not bijective.
10:53:00 <athan> ReinH: Thank you :)
10:53:16 <ski> dfeuer : afaiu, one could do such a type family
10:53:45 <ski> ReinH : .. not bijective with what ?
10:53:54 <jle`> type family might be a good way
10:54:29 <ReinH> ski: With any function you can write using pattern matching.
10:54:43 <ski> athan : data constructors are (per definition) (a) injective; (b) pairwise disjoint; (c) (collectively) exhaustive
10:54:44 <ReinH> it's surjective but not injective
10:54:46 <dfeuer> ski, you can definitely write such a type family; the challenge is then figuring out how to use it to make the thing with the Foldable instance. I think an extra type class probably will be necessary.
10:54:53 <ReinH> ski: eh?
10:54:56 <jle`> F (a, b) = a; S (a, b) = b.  and, newtype TupleMap t = TupleMap (F t) (S t)
10:54:57 <jle`> ?
10:54:57 <ski> ReinH : clearly, for each `a', `Proxy a' is iso to `()', no ?
10:55:50 <ReinH> ski: Yes, but we're talking about the Proxy function
10:55:53 <ReinH> Also how is it injective?
10:56:21 <ski> athan : if there's only one data constructor, then the defined type is bijective (injective, and also surjective (because of exhaustiveness)) with the product of the argument types
10:56:27 <ReinH> It does not preserve distinctness. Proxy 1 == Proxy 2
10:56:55 <ski> ReinH : i'm not sure what you mean by "the Proxy function". the type constructor ? or something else ?
10:57:07 <ReinH> er
10:57:15 <ReinH> Sorry
10:57:29 <ReinH> That's not a thing.
10:57:55 <ski> dfeuer : "make the thing with the Foldable instance" ?
10:58:39 <ski> jle` : s/newtype/data/ or use some kind of product type
10:58:58 <jle`> er
10:59:00 <jle`> sorry
10:59:10 <jle`> newtype TupleMap t = TupleMap (Map (F t) (S t))
10:59:10 <ski> (np)
10:59:15 <jle`> does that work?
10:59:27 * ski isn't sure what jle` wants to achieve here
10:59:34 <jle`> dfeuer's quest
10:59:43 <jle`> where F and S are type families
11:00:15 * ski didn't notice that statement of dfeuer
11:00:41 <ReinH> athan: never mind, sorry
11:02:16 <lush> hi everybody!
11:03:30 * dfeuer looks up.
11:03:39 <dfeuer> ski,
11:03:46 * ski looks down
11:03:52 <dfeuer> Heh.
11:04:05 <Denommus> I have no idea if it worked. I don't think so :-/
11:04:32 <dfeuer> I started thinking about a way to transform Map into a type whose Foldable instance would fold up (k,v) pairs.
11:05:22 <dfeuer> The way I have managed to do it is with  data UnCurry f a where UnCurry :: f k v -> UnCurry f (k,v)
11:05:36 <dfeuer> But I don't really like having this be data; I'd rather have newtype.
11:05:58 <dfeuer> That's what I'm talking about, ski.
11:06:17 <fsjdifo> is there a reason to use brackets for a type constraint - :: (Eq a) => vs :: Eq a => ?
11:07:06 <dfeuer> fsjdifo, only because doing so makes it easier to add additional constraints later.
11:07:13 <fsjdifo> okay
11:07:29 <dfeuer> I think some people think it looks more consistent.
11:09:52 <ski> fsjdifo : fwiw, i prefer `Eq a =>'
11:10:42 <ski> (and similarly `deriving Eq')
11:11:16 <fsjdifo> okay guess its just a style thing
11:13:52 <dfeuer> ski, ha. I prefer `Eq a =>` as well, but `deriving (Eq)`, because the latter matches module import/export syntax.
11:14:07 <dfeuer> No, it's not necessarily sane of me.
11:14:38 * ski smiles
11:14:40 <Denommus> gosh, I can't access FreeNode's site
11:14:48 <Denommus> what is the support channel, again?
11:15:02 <cmtptr> ... #freenode?
11:18:27 <fsjdifo> is a function a monad or something? I dont understand this - 'Control.Monad.liftM2 (==) id reverse' (it checks if a list a palindrome)
11:19:17 <dfeuer> fsjdifo,
11:19:18 <dfeuer> yes.
11:19:34 <dfeuer> fsjdifo, the key words to search for are "reader monad".
11:19:58 <dfeuer> (in quotes, because "monad reader" is very very different)
11:20:03 <fsjdifo> okay
11:20:10 <dfeuer> [Monad Reader is a cool publication though!]
11:20:15 <ski> fsjdifo : functions (on values) are values. monads don't exist on the value level. they exist on the type level. a monad is a type function (a function mapping types to types), equipped with a few related operations (on the value level), satisfying a couple of laws
11:20:27 <dfeuer> Yes.
11:21:05 <fsjdifo> i have no idea what you just said ski
11:21:06 <ski> `(rho ->)' (in Haskell written `(->) rho') is the type function that maps any type `a' to the (function) type `rho -> a'
11:21:13 <ski> `(rho ->)' is a monad
11:21:19 <dfeuer> ski, can you remind me why type operator sections aren't allowed? Everyone has to explain that  ((->) r) is really (r ->) except the latter isn't valid syntax.
11:21:37 <ski> dfeuer : no good reason, afaiu
11:21:39 <dfeuer> I mean, really, just *make it* valid syntax, and suddenly everyone will be happier.
11:21:42 <fsjdifo> what is rho ski ?
11:21:47 <fsjdifo> just a type placeholder?
11:21:50 <ski> fsjdifo : `rho' is any type
11:21:52 <ski> yes
11:21:53 <fsjdifo> okay
11:21:54 <dfeuer> ski is flying above the clouds today.
11:22:23 <ski> for any concrete type (like `Integer'), `(rho ->)' is a monad (so `(Integer ->)' is one monad)
11:22:25 <fsjdifo> wait so '->' is a function?
11:22:27 <jle`> dfeuer: i think it  causes some ambiguity for typeclasses
11:22:36 <fsjdifo> :t ->
11:22:37 <lambdabot> parse error on input ‘->’
11:22:44 <benzrf> fsjdifo: (->) is a type constructor
11:22:47 <benzrf> aka a type-level function
11:22:50 <dfeuer> jle`, how's that?
11:22:53 <ski> `->' is the symbol used to write function types (the types of (value) functions)
11:22:53 <Xenasis> :k (->)
11:22:54 <lambdabot> * -> * -> *
11:22:54 <bennofs> :k (->) -- it's a type function.
11:22:55 <lambdabot> * -> * -> *
11:22:55 <benzrf> fsjdifo: but since it's at the type level it has a kind rather than a type
11:23:14 <jle`> dfeuer: for example, if you could write an instance for (Writer w) and for (`Writer` a), which one would you pick when using a Writer?
11:23:21 * dfeuer thinks ski and benzrf are confusing fsjdifo, which is not a good thing.
11:23:23 <Xenasis> Kinds are pretty complex but there's a bit in LYAH about them
11:23:25 <ski> the type `X -> Y' is syntactic sugar for `(->) X Y', just like (the value/expression) `2 + 3' is syntactic sugar for `(+) 2 3'
11:23:29 <fsjdifo> so kind (->) is defined in terms of itself
11:23:36 <benzrf> fsjdifo: no
11:23:40 <ski> dfeuer : possibly
11:24:07 <dfeuer> jle`, I think only sections on the other side can be added conservatively.
11:24:07 <fsjdifo> ski: can I use (-> a b) in a function signature?
11:24:16 <fsjdifo> err (->) a b
11:24:20 <kadoban> fsjdifo: The arrows there have a different meaning, unfortunately. Or the same meaning on a different level.
11:24:21 <dfeuer> fsjdifo, you can write     f :: (->) a b, yes.
11:24:23 <ski> fsjdifo : there is one `->' on the type level, and another (similar, but distinct) `->' on the kind level
11:24:24 <jle`> fsjdifo: one way to find out :)
11:24:29 <dfeuer> But you shouldn't in almost any situation.
11:24:39 <ski> fsjdifo : you can say `not :: (->) Bool Bool', yes
11:24:42 <dfeuer> Because it will confuse people.
11:24:45 <jle`> > :t ord :: (->) Char Int
11:24:46 <lambdabot>  <hint>:1:1: parse error on input ‘:’
11:24:56 <jle`> :t ord :: (->) Char Int
11:24:57 <benzrf> :t ord :: (->) Char Int
11:24:57 <lambdabot> Char -> Int
11:24:59 <lambdabot> Char -> Int
11:25:21 <dfeuer> fsjdifo, my suggestion: first learn about the reader monad using the type   newtype Reader rho a = Reader (rho -> a)
11:25:24 <jle`> dfeuer: what is the other side?
11:25:28 <dfeuer> Then unwrap the newtype.
11:25:36 <fsjdifo> okay ill do that
11:25:42 <fsjdifo> so confused right now
11:25:42 * hackagebot curve25519 0.2.1 - Fast implementations of the curve25519 elliptic curve primitives.  http://hackage.haskell.org/package/curve25519-0.2.1 (AdamWick)
11:25:46 <dfeuer> jle`,   (a->) vs (->a)
11:25:53 <ski> fsjdifo : also note that "reader monad" is sometimes called "environment monad"
11:26:01 <fsjdifo> okay
11:26:16 <ski> (`Reader rho' is a reader/environment monad, and so is `(rho ->)')
11:26:18 <jle`> dfeuer: and the first allowed, but not the second?
11:26:26 <dfeuer> jle`, allowing (a->) as a synonym for ((->) a) doesn't introduce anything that looks ambiguous to me. If you have instances for two ways of saying the same thing, that's overlapping, of course.
11:26:37 <dfeuer> jle`, well, currently, neither is allowed.
11:26:42 <jle`> ah yes. so allow (a ->) sections, but not (-> a) sections
11:26:46 <ski> fsjdifo : do you know what an "environment variable" in OS processes is ?
11:26:55 <fsjdifo> ski: yeah
11:27:20 <dfeuer> jle`, I would *love* to know how to allow (->a) sections. But I don't think it's possible--I think you always end up needing some newtypes.
11:27:37 <ski> fsjdifo : then this is similar. the point is that you have some kind of "configuration" that you want to "propagate downwards", and perhaps change locally
11:28:02 <dfeuer> Yes.
11:28:19 <jle`> dfeuer: if you did then you could write a Functor instance for (`Either` r)
11:28:32 <jle`> so what would `fmap` be :O
11:28:42 <jle`> :t fmap
11:28:43 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:28:47 <dfeuer> The fact that we can use    (->) r   for the reader monad instead of Reader r   is convenient and confusing.
11:28:53 <ski> fsjdifo : if you have locally changed an environment variable, and then you spawn a new process, it will inherit (a copy of) the environment variable (with its associated value) .. locally changing it in the child doesn't affect the parent, though
11:28:55 <jle`> the f could validly be (`Either` r) and (Either l)
11:29:07 <benzrf> jle`: how does idris handle it
11:29:09 <NemesisD> i was thinking about passing -Wall -Werror in ghc-options on my package so I can't build or publish it with warnings. is there any unseen downside for the end user to this?
11:29:12 <dfeuer> jle`, well, there are ways to do this sort of thing. lens does a *lot* of that.
11:29:23 <dfeuer> But it seems you always need some newtypes.
11:29:31 <NemesisD> like my library possibly interacting with some dependency of theirs and tripping the Werror
11:29:41 <jle`> yeah, and it involves reifying typeclasses like Functor to some extent
11:29:46 <glguy> NemesisD: Your package it just much more likely to break when someone tries it with a new version of something
11:30:01 <ski> dfeuer : perhaps we need a `Flip' such that `Flip (Flip f)' unifies with `f'
11:30:22 <NemesisD> glguy: what's an example of that? what would trigger a warning i wouldn't see at my build time for the package?
11:30:23 <bennofs> NemesisD: don't enable -Werror in the cabal file, new GHC versions often introduce new warnings which leads to more breakage of your package
11:30:45 <NemesisD> bennofs: hmm, what if i put it behind a flag?
11:30:59 <dfeuer> ski, yeah, that would be nice; is it possible?
11:31:05 <ski> i'm not sure
11:31:12 <bennofs> NemesisD: you can do that, but then you can just as well simply compile with cabal configure --ghc-option=-Werror
11:31:13 <dfeuer> And then of course there are other combinators.
11:31:14 <ski> perhaps with type/data families
11:31:39 <NemesisD> bennofs: i guess in both cases that's something I need to remember to do so I lose either way
11:31:56 <jle`> that's the spirit
11:31:58 <dfeuer> ski, I don't *think* it's possible today; I *think* it would need some sort of new extension. And I am not optimistic about the chances of it behaving well.
11:32:19 <bennofs> NemesisD: or, if you use github, just setup travis-ci or something to use -Werror :) then you can also easily test on multiple ghc/cabal versions
11:32:25 <dfeuer> But nice it would be.
11:32:40 <quchen> dfeuer: If you had the full untyped lambda calculus on the type level, would that not make type inference undecidable?
11:32:58 <ski> quchen : yes
11:33:29 <NemesisD> i still want to see this during my dev process. so i'll want to configure with the right flags
11:33:31 <dfeuer> quchen, yes, that would be bad. But can't certain sorts of rearrangements be done without bringing in that much power?
11:33:39 <dfeuer> I don't know.
11:34:02 <ski> `Flip' neither discards nor duplicates any input
11:34:14 <quchen> dfeuer: Neither do I. But in even simpler terms, all you need is S and K, and those are very basic and get you all the way to undecidability.
11:34:32 <NemesisD> bennofs: hmm if i put Wall, Werror on my test suite, i wonder if that would trigger errors on the main lib itself
11:34:44 <geekosaur> actually, it occurs to me that a nice cabal workflow could come from (a) put things like that under a flag (b) allow cabals andbox config to include some default flags
11:34:52 <ski> quchen : instead of `S' and `K', you could possibly use the weaker `C',`B',`I' (maybe together with `K')
11:34:56 <geekosaur> so you could set up a "devel sandbox"
11:34:59 <bennofs> NemesisD: I mean you could setup travis-ci to cabal configure with --ghc-option=-Werror
11:35:12 <bennofs> NemesisD: it won't
11:35:13 <quchen> ski: c and b are (.) and flip, if I recall correctl?
11:35:25 <NemesisD> bennofs: i get that but i don't want to wait till i push and travis builds before i found out i've created some warnings
11:35:29 <ski> quchen : iirc, yes
11:35:44 <quchen> And those are weaker?
11:35:47 <bennofs> NemesisD: You can still put -Wall in the ghc-options
11:35:47 <ski> yes
11:35:56 <ski> `S' gets you contraction/duplication
11:36:13 <ski> `K' gets you weakening/dilution/thinning/discard
11:36:38 <ski> `B' gets you exchange/commutation/permutation
11:36:46 <ski> `C' regroups (associativity)
11:37:00 <quchen> I wonder where those names come from.
11:37:13 <ski> hm, ask Schönfinkel, iirc
11:37:28 <ski> (or maybe Curry ?)
11:37:40 <quchen> Let me get my time phone then
11:38:09 <dfeuer> quchen++
11:39:09 <dfeuer> I wouldn't be surprised if these answers were recorded history.
11:39:19 <quchen> ..?
11:39:26 <dfeuer> K seems reasonably likely related to the German for "constant", no?
11:39:37 <ski> sounds plausible
11:40:14 <scott> reminds me of P/V for semaphores
11:41:59 <quchen> dfeuer: Yes, and "I" for identity makes sense too. But the rest is strange.
11:42:16 <ReinH> ski: were the bird names in To Mock a Mockingbird based on the pre-existing names for combinators?
11:42:18 <xavier_> The jewish banker reptoids live on the dark side of the moon, they were first found by the cia. But then thats when they killed jfk and started to inflate our money with zargon dollars from the planet volltar causing the financial crisis & houseing bubble which led to the bale out which was really funded by the marclars. They sent a zeon-class five robot back in time to stop 9/11 but it was too late the jews already did 9/11 and b
11:42:29 --- mode: ChanServ set +o geekosaur
11:42:35 --- mode: geekosaur set +b *!*@gateway/web/freenode/ip.104.181.136.244
11:42:35 --- kick: xavier_ was kicked by geekosaur (xavier_)
11:42:47 --- mode: geekosaur set -o geekosaur
11:43:40 <ski> ReinH : hm, i'm not sure, i haven't read Smullyan's book (i read "To Dissect a Mockingbird"). i would assume at least the most basic ones used pre-existing names
11:44:07 <ReinH> ski: I mean, Kestrel is K, etc
11:44:17 <ReinH> I'm just wondering which direction the arrow of causality is pointing
11:44:27 <ReinH> presumably K -> Kestrel
11:47:25 <ski> ReinH : i'd presume so
11:49:06 <mizu_no_oto> How often are dictionaries actually passed in ghc?  Will it typically do something like C++ where you create separate monomorphic versions of templated functions, or does it typically have only one compiled implementation and pass in dictionaries at runtime?
11:49:29 <Scriptonaut> can someone tell me why I'm getting an error on line 10: https://gist.github.com/robins35/63294b2c792aec92374c
11:49:32 <Scriptonaut> it's some type issue
11:49:33 <mizu_no_oto> with typeclasses, that is
11:49:49 <Scriptonaut> I'm trying to make a simple RPN calculator
11:49:50 <dmj`> Scriptonaut: please include the ghc error output
11:50:15 <Scriptonaut> dmj`: here ya go: https://gist.github.com/robins35/63294b2c792aec92374c
11:50:17 <dmj`> Scriptonaut: here's a problem
11:50:19 <dmj`> putStrLn $ computeRPN eq
11:50:28 <Scriptonaut> what's wrong with taht?
11:50:29 <dmj`> the type of putStrLn is String -> IO ()
11:50:36 <dmj`> computeRPN returns a Num a => a
11:50:43 <Scriptonaut> ah, shit
11:50:47 <Scriptonaut> ok, thanks
11:50:54 <Scriptonaut> why are the error messages so unhelpful
11:50:55 <dmj`> you'd have to call show on it first, but GHC will need a concrete type
11:50:56 <Scriptonaut> why wouldn't it just say that
11:51:39 <dmj`> Scriptonaut: it does just say that
11:51:48 <dmj`> "In the second argument of ‘($)’, namely ‘computeRPN eq’"
11:52:20 <dmj`> :t read
11:52:21 <lambdabot> Read a => String -> a
11:52:46 <dmj`> I don't recommend using read, really ever, unless you're positive it will do what you want 100% of the time
11:52:47 <eacameron> multiple times I've run into problem with bindings to Windows APIs not working in x64-bit. In my particular case I see a lot of Word32/Int32 floating around in the code. Could it simply be that I need to use Word64/Int64?
11:52:59 <dmj`> Scriptonaut: check out readMaybe from Text.Read
11:53:02 <ski> mizu_no_oto : <http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/pragmas.html#specialize-pragma>
11:53:47 <dmj`> Scriptonaut: try "(read numberString :: [Int])" ghc needs help knowing what read should do
11:54:00 <dmj`> readMaybe numberString :: Maybe [Int]
11:54:11 <dfeuer> I think my idea of an UnCurry type family for my original purpose is *utterly doomed*. Foldable instances have to have kind *->*, so there's no way to express the notion that they fold over pairs. GADTs offer a magic trick for this that I think nothing else does.
11:54:47 <ski> mizu_no_oto : dunno about how often it would specialize by itself (ask #ghc ?) .. for sure it can't possibly do it always (because of polymorphic recursion, existentials, GADTs). ignoring module boundaries, one could possibly do it when the instances are known statically
11:55:12 <Scriptonaut> why does ghc need me to do that, isn't it obvious I want a Num, seeing as I'm consing it to a list of [Num]
11:55:20 <Scriptonaut> plus doing that limits me to ints
11:55:26 <glguy> A num isn't a type, it's a class of types
11:55:35 <ski> dmj`,Scriptonaut : `(read :: ReadS [Int]) numberString'
11:55:37 <Scriptonaut> so how do I achieve polymorphism here
11:55:38 <glguy> [Num] is invalid
11:55:41 <ski> er, s/read/reads/
11:56:02 <ski> > (reads :: ReadS [Int]) "[0,1,2] stuff"
11:56:04 <lambdabot>  [([0,1,2]," stuff")]
11:56:10 <ski> > (reads :: ReadS [Int]) "garbage [0,1,2] stuff"
11:56:11 <lambdabot>  []
11:56:21 <dmj`> > read "[1,2,3]" :: [Int]
11:56:23 <lambdabot>  [1,2,3]
11:56:33 <dmj`> ski: ah very cool !
11:56:42 <dmj`> a pure empty list on failure
11:56:56 <ski> usually you'd use it like
11:57:07 <Scriptonaut> bleh, I've used read plenty of times in other programs, I don't understand what about this function is so hard for ghc to figure out what I want
11:57:27 <Hijiri> what does the surrounding code look like?
11:57:28 <Scriptonaut> the fact that my function type signature says it wants a Num and not a concrete type?
11:57:35 <Hijiri> wait nevermind, you posted it already
11:57:37 <Scriptonaut> that's all the code, I posted the entire file
11:57:50 <geekosaur> Scriptonaut, yes, if you use a concrete type and a Read instance is known for it then it will work
11:58:14 <geekosaur> if you work polymorphically then you need to name all your constraints, in this case including Read a
11:58:16 <ski>   case (reads :: ReadS [Int]) "[0,1,2] stuff" of [(ns,rest)] -> ..ns..rest..; _ -> ... {- no parse, or ambiguous parse -}
11:58:17 <Scriptonaut> so to use Read, you MUST use a concrete type?
11:58:20 <ski> or, perhaps more commonly
11:58:25 <Hijiri> oh, it doesn't know you can read
11:58:28 <Hijiri> because not all Num are Read
11:58:43 <geekosaur> (Num a, Read a) =>
11:58:44 <Scriptonaut> geekosaur: follow up on that
11:58:54 <ski>   case [ns | (ns,s) <- (reads :: ReadS [Int]) "[0,1,2] stuff" , ("","") <- lex s] of [ns] -> ..ns..; _ -> ... {- no parse, or ambiguous parse -}
11:59:00 <Scriptonaut> ah
11:59:01 <Scriptonaut> cool
11:59:02 <Scriptonaut> got it
11:59:02 <glguy> Scriptonaut: You have to decide what type getEquation's implementation should actually read, you have to pick one at that point
11:59:12 <ski> (the `lex' there makes sure there's only whitespace after the parsed part)
11:59:26 <Scriptonaut> I wasn't aware not all Num types could be read
11:59:28 <Scriptonaut> which ones can't?
11:59:38 <glguy> Scriptonaut: Even if they could, you still have to pick one
11:59:41 <eacameron> How do I detect x86 vs x86-64 in a CPP flag?
11:59:56 <mauke> Scriptonaut: (e -> Integer)
11:59:58 <ski> Scriptonaut : if you say `instance Num a => Num (rho -> a)', e.g.
12:00:02 <Hijiri> Scriptonaut: you can make up any new Num instance
12:00:26 <orzo> eacameron: iduno about CPP, but the package cpu has useful related functionality if i recall and maybe check it's source for CPP stuff
12:00:32 <Scriptonaut> h ya
12:00:39 <mauke> Scriptonaut: PortNumber
12:00:52 <ski> Scriptonaut : "so to use Read, you MUST use a concrete type?" -- no. but often (at least in isolation) it's ambiguous, so you then need some way to specify which you want
12:01:05 <bennofs> Scriptonaut: how does GHC know which number type you want to use?  does your function work with Float (Float is also Read & Num instance)
12:01:11 <dmj`> in ghc typeclasses become records, each instance gets its own, if you call show on a Num a => a, ghc won't know which record to use, unless the function you're using makes the usage specific, but your signature is general (Num a) => a
12:01:28 <eacameron> orzo: Bingo! Just what I needed. Thanks. http://hackage.haskell.org/package/cpu-0.1.2/docs/src/System-Arch.html
12:01:44 <dmj`> what bennofs said
12:01:56 <geekosaur> actually in this case I think all typeclasses allow defaulting so it will probably end up using Integer
12:02:37 <dmj`> geekosaur: even if the function returns a Num a => a ?
12:03:01 <dfeuer> You need a Read instance.
12:03:05 <bennofs> > show (read "1" + read "2")
12:03:07 <lambdabot>  "3"
12:03:07 <dfeuer> This sounds messy.
12:03:10 <bennofs> :O
12:03:14 <Hijiri> to me it looks like it would just use the read instance of a
12:03:24 <geekosaur> yes, because at some point it needs to determine a concrete type to actually use it, and nothing in that code lets it infer a type otherwise so defaulting kicks in
12:03:29 <Hijiri> oh, it's not specified
12:03:40 <geekosaur> and Integer will fit the constraints so will be used
12:03:45 <Hijiri> nevermind what I said
12:04:04 <dmj`> geekosaur: if you had a Read instance it would have to be for a concrete type, so the Num a => a signature would be invalid, it would have to be String -> Integer
12:04:06 <dmj`> right ?
12:04:15 <geekosaur> hm
12:04:36 <geekosaur> I am not sure what you are asking especially since the signature has already been changed to (Num a, Read a) => ...
12:04:40 <geekosaur> read backscroll
12:05:58 <Hijiri> a Show instance on a will also probably be helpful
12:06:07 <Hijiri> since the result needs to be printed
12:06:16 <Hijiri> show constraint, I mean
12:07:59 <dmj`> geekosaur: I see, so Read defaults to Integer, so that will be used everytime, despite the fact the signature is for anything that is an instance of Num
12:08:29 <mauke> it's not Read specific
12:09:17 <kadoban> dmj`: If, somewhere in the types it's required to be something else, that'll work too. The only way defaulting comes in is if you specify nothing, anywhere, that it could use to tell.
12:10:06 <geekosaur> dmj`, not exactly. https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-790004.3.4
12:11:08 <nvez> Hi, I have the following line of code but I'm trying to understand the concept behind it.. can someone help? .. the "$" .. I'd like to know what that means -- str = concat $ "eggs " : ["cream " | j <- [1..length r]]
12:11:25 <fsjdifo> ski: how can i express the id function as a monad? whats the pattern (constructor and params) ?
12:11:29 <geekosaur> nvez, $ is function application at low precedence
12:11:54 <geekosaur> `a $ b` is equivalent to `(a) (b)`, acting kinda like backwards parentheses
12:11:56 <mauke> @src ($)
12:11:56 <lambdabot> f $ x = f x
12:12:16 <geekosaur> so in this case: str = concat ("eggs " : ["cream " | j <- [1..length r]])
12:12:27 <ski> fsjdifo : no
12:12:37 <dmj`> mauke, kadoban, geekosaur: thank you !
12:12:53 <ski> fsjdifo : monads live on the type level. the function `id', defined by `id :: a -> a; id x = x', lives on the value level
12:12:57 <nvez> geekosaur: that makes a bit more sense, i'll do some more reading, never written in a language like haskell before so it's an interesting challenge
12:13:19 <ski> fsjdifo : maybe you had a type function like `Id', defined by `type Id a = a', in mind ?
12:13:25 <fsjdifo> ski: werent you saying that (->) is like a constructor for a monad?
12:13:32 <ski> fsjdifo : no
12:13:44 <mauke> the only interesting thing about $ is its infix syntax/precedence
12:13:53 <ski> fsjdifo : first, you need to distinguish between data constructors and type constructors (which did you mean ?)
12:14:07 <mauke> 'a b $ c d' is equivalent to '($) (a b) (c d)'
12:14:15 <mauke> and then ($) is simply a no-op
12:14:22 <fsjdifo> how does id get promoted to a Monad type in 'liftM2 (==) id'  ?
12:14:23 <Welkin> (->) is a type constructor for functions
12:14:30 <ski> fsjdifo : for any type `rho', `(->) rho' (aka `(rho ->)') is a monad
12:14:43 <ski> Welkin : to nitpick, for function types
12:15:20 <benzrf> fsjdifo: i'd use liftA2 myself
12:15:44 <benzrf> fsjdifo: but you could just write "isFix f x = f x == x"
12:15:50 <ski> (i don't care that much if people are sloppy about such terms, when they know what was meant. but i think that's not the case here)
12:16:24 <fsjdifo> ski: is there a paper that describes this or something?
12:16:42 <fsjdifo> ski: is there a definition of bind for '(->) rho' ?
12:16:52 <fsjdifo> in regular haskell>?
12:16:55 <Welkin> yes
12:17:15 <Welkin> instance Monad ((->) e))
12:17:16 <ski> nshepperd : `$' is just an infix operator, which happens to have lower precedence than `:'. so `a $ b : c' means `a $ (b : c)', just like `x + y * z' means `x + (y * z)' (because `+' has lower precedence than `*')
12:17:21 <ski> er
12:17:22 <voidzero> a paper... i found one interesting read about this yesterday
12:17:25 <ski> nvez : see above
12:17:25 <mauke> @src (->) (>>=)
12:17:26 <lambdabot> f >>= k = \ r -> k (f r) r
12:17:26 <voidzero> lemme see if i can find it
12:17:50 <mauke> fsjdifo: are you familiar with Reader?
12:18:00 <ski> fsjdifo : perhaps one of the Wadler papers on monads, i don't recall
12:18:03 <fsjdifo> mauke: no was just raeding it
12:18:18 <nvez> thats what i figured ski :D
12:18:19 <mauke> I'd read about Reader first :-)
12:18:30 <mauke> then realize that Reader is simply a newtype wrapper around (->)
12:18:37 <ski> nvez : the effect of this is what geekosaur said
12:18:45 <nvez> and i assume this is .. "eggs " : ["cream " | j <- [1..length r]] -- kind alike add "eggs " to the array of cream "r" times
12:18:50 <nvez> and then concat all that
12:19:07 <voidzero> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
12:19:10 <Welkin> a list, not an array
12:19:26 <ski> nvez : yes, `x : xs' adds the element `x' in front of the list (not array) `xs', constructing a new list
12:19:29 <nvez> so given r = 4 .. i end up with [eggs, cream, cream, cream, cream] which is called by concat resulting in "eggs cream cream cream cream"
12:19:32 <ski> > 0 : [1,2,3]
12:19:34 <lambdabot>  [0,1,2,3]
12:19:35 <mauke> nvez: "length r" times
12:19:41 <nvez> slowly making sense
12:19:44 <nvez> :)
12:19:44 <mauke> nvez: and that's a weird way to write that, btw
12:20:00 <mauke> nvez: ["cream " | _ <- r] would be more natural
12:20:00 <nvez> it is supposed to be a "bug" that I fix as an assigment
12:20:03 <ski> (nvez : in practice, the tail of the new list is shared with the old one, not copied, in case you wondered)
12:20:09 <Welkin> nvez: list comprehensions are not idiomatic. It's better to use map/filter/etc. instead
12:20:18 <Scriptonaut> hmm, I'm still having trouble with read
12:20:21 <nvez> it's supposed to be broken code t one fixed as part of an assigmnet
12:20:28 <ski> Welkin : depends
12:20:34 <Scriptonaut> can someone tell me how to make a polymorphic read that doesn't require :: somedatatype
12:20:36 <nvez> so it's supposed to actually look up these values instead of cream 4 times
12:20:38 <hop> hello all, do you know if haskell platform is still supported? We use it on Windows and it it convenient actually
12:20:47 <Scriptonaut> it works with ints but not floats
12:21:03 <ReinH> map (const "cream ") xs
12:21:05 <kadoban> hop: Yes, haskell platform is still a thing.
12:21:08 <ski> Scriptonaut : paste the actual code (e.g. on lpaste)
12:21:17 <ski> @paste
12:21:17 <lambdabot> Haskell pastebin: http://lpaste.net/
12:21:24 <hop> kadoban: are they waiting for 7.10 for the update?
12:21:27 <Welkin> > "eggs" : replicate 4 "cream"
12:21:28 <lambdabot>  ["eggs","cream","cream","cream","cream"]
12:21:37 <Welkin> that is a cleaner way to do it
12:21:47 <ReinH> Welkin: Not if you need to find the length first
12:21:55 <fsjdifo> how does haskell know that a function type is an instance of monad? is that a special thing built in to the language?
12:22:03 <mauke> > unwords ("eggs" : replicate 4 "cream")
12:22:04 <lambdabot>  "eggs cream cream cream cream"
12:22:10 <ski> fsjdifo : no. it's just an `instance' declaration, as always
12:22:13 <mauke> fsjdifo: no, just normal type checking
12:22:17 <Welkin> fsjdifo: it has `instance Monad of ...` declared for it
12:22:25 <ReinH> no "of"
12:22:32 <Welkin> er, yes
12:23:03 <Scriptonaut> ski, it's the same code I posted
12:23:04 <kadoban> hop: I…don't really know. I would guess maybe?
12:23:27 <ski> fsjdifo : otoh, the function type constructor `(->)' *is* built in to the language (just like `Int',`Float',`Double',`Integer',`IO' are)
12:23:42 <fsjdifo> where can i see this instance declaration?
12:23:43 <hop> kadoban: ok. Would you know where to ask?
12:24:03 <Scriptonaut> ski: https://gist.github.com/robins35/525f13089eb2124ecde3
12:24:10 <fsjdifo> ski: but is the instance declaration actually defined in regular haskell somewhere or is that definition built in?
12:24:17 <Scriptonaut> when I use floats, it gives me: Prelude.read: no parse
12:24:27 <ReinH> fsjdifo: Yes, it's defined in regular Haskell.
12:24:30 <ski> Scriptonaut : i missed that before
12:24:37 <kadoban> hop: Probably here. I'm sure there's someone out there that knows much more than I, especially on this specific subject.
12:24:41 <mauke> Scriptonaut: that's because your code is hardcoded to use Integers
12:24:43 <fsjdifo> ReinH: u know where?
12:24:51 <ReinH> fsjdifo: http://hackage.haskell.org/package/base-4.7.0.2/docs/src/GHC-Base.html#Monad
12:24:57 <Scriptonaut> mauke: how so? I never mention integers
12:24:58 <kadoban> hop: I would be surprised if they didn't have their own channel too, but…I don't know what it is.
12:25:01 <orzo> hmm, i don't think the Monad insatnce for ((->) r) is in the prelude...
12:25:04 <voidzero> also useful: https://wiki.haskell.org/Typeclassopedia
12:25:10 <johnw> orzo: Control.Monad.Instances?
12:25:14 <fsjdifo> ReinH: thanks that helps to understand quite a bit
12:25:18 <mauke> Scriptonaut: yeah, so defaulting kicks in
12:25:22 <hop> kadoban: thanks! I will try to find out!
12:25:24 <ReinH> orzo: Yes it is.
12:25:29 <ReinH> It is in the prelude.
12:25:33 <Scriptonaut> so how the hell do people write polymorphic functions that read in a string?
12:25:42 <voidzero> and I found this a good read - http://www.alpheccar.org/content/60.html
12:25:42 <johnw> Scriptonaut: ?
12:25:53 <orzo> ReinH: am i just remembering wrong or did it get moved in?
12:25:57 <ReinH> http://hackage.haskell.org/package/base-4.7.0.2/docs/Prelude.html#t:Monad
12:26:02 <Scriptonaut> johnw: I'm talking about the thing I posted
12:26:25 <Scriptonaut> I don't want to specify the data type, that destroys any polymorphic behavior I'd get
12:26:34 <ReinH> It's been in the Prelude since at least base 4.0
12:26:34 <ski> Scriptonaut : `putStrLn' forces the return type of that call to `computeRPN' to be `String'. use `show' (as suggested before), or use `print' instead of `putStrLn'
12:26:48 <orzo> actually, source links on instances would be a nice feature for haddock
12:26:58 <fsjdifo> how would the type signature for id look with the -> constructor?
12:26:59 <johnw> Scriptonaut: won't you need Show a as well there?
12:27:23 <voidzero> what's a numberstring anyway?
12:27:24 <ski> johnw : where ?
12:27:30 <mauke> fsjdifo: http://hackage.haskell.org/package/base-4.7.0.2/docs/src/GHC-Base.html#instance%20Monad%20((-%3E)%20r)
12:27:35 <johnw> in the type of computeRPN
12:27:40 <bennofs> Scriptonaut: somehow, you still need to decide which data type you want to use in your program. There is a difference between using Float and Int as a number type, GHC can't just guess what you want for that
12:27:48 <johnw> oh, I guess eq is fixing it
12:28:12 <Scriptonaut> bennofs: ok, so there is no way to make a polymorphic function that reads in arbitrary Nums then?
12:28:32 <mauke> Scriptonaut: sure there is. you wrote one
12:28:39 <Scriptonaut> mine doesn't do that
12:28:43 <mauke> yes, it does
12:28:48 <Scriptonaut> mine defaults to Int and that's all it does
12:28:49 <mauke> but you're only calling it at type Integer
12:28:49 <ski> johnw : `Read' perhaps, but `Show' ?
12:28:52 <voidzero> doesn't line 9 of Scriptonaut's paste - (read numberString) - need a type here?
12:28:55 <kadoban> Scriptonaut: It wouldn't even be meaningful, I don't think. How would it decide what Num instance to use at runtime?
12:28:58 <voidzero> (read numberString :: Float)
12:29:00 <mauke> Scriptonaut: that's not the function, that's how you're calling it
12:29:00 <johnw> ski: n/m
12:29:08 <johnw> cstrahan_: ping
12:29:15 <fsjdifo> mauke: I still dont understand how the type of a function look like using -> constructor since -> only has one parameter but a function a -> b has 2 :S
12:29:19 <bennofs> Scriptonaut: the type you want to read needs to be fixed at compile time, it cannot depend on runtime input
12:29:33 <voidzero> fsjdifo, it takes an a and returns a b
12:29:38 <Scriptonaut> seriously?
12:29:42 <Scriptonaut> that seems so limiting
12:29:45 <mauke> fsjdifo: what do you mean, -> only has one parameter?
12:29:47 <voidzero> or better yet, you apply a to the function, returning b
12:30:00 <bennofs> Scriptonaut: (well, you could try to read either an Int or a Double, but at least the set of types which you try needs to be specified at compile time)
12:30:06 <fsjdifo> mauke: the constructor -> is defined with only one type parameter
12:30:10 <mauke> fsjdifo: no, it's not
12:30:16 <ski> fsjdifo : a function of type `A -> B' (for any concrete types `A' and `B') takes one (value) argument (of type `A'). the function type constructor `(->)' itself takes two (concrete) (type) arguments
12:30:18 <voidzero> how about using fromIntegral btw?
12:30:30 <voidzero> :t fromIntegral
12:30:31 <lambdabot> (Num b, Integral a) => a -> b
12:30:38 <Scriptonaut> because what if I want floats?
12:30:43 <Scriptonaut> floats aren't integral
12:31:08 <ski> bennofs : it can depend on runtime input .. but that's a little bit more advanced
12:31:10 <Scriptonaut> so the type inference isn't good enough to determine that "3.4" is a float when I read?
12:31:16 <orzo> Scriptonaut: read is polymorphic in return type, you can read Float or Int or whatever
12:31:17 <ski> Scriptonaut ^
12:31:18 <voidzero> :t fromRational
12:31:19 <lambdabot> Fractional a => Rational -> a
12:31:29 <bennofs> ski: yeah, that's why I added the note about the set of possible types being fixed at compile time :)
12:31:36 <mauke> Scriptonaut: type inference happens at compile time
12:31:44 <mauke> Scriptonaut: reading happens at runtime
12:31:48 <ski> Scriptonaut : type checking (at compile-time) can't possibly know when you'll pass in `3.4' at run-time
12:31:49 <kadoban> Scriptonaut: There's no type inference to go by. You didn't specify anything that narrows it down.
12:32:09 <Scriptonaut> so, there's no way for a user to enter floats and integers at runtime and have the same function handle them?
12:32:09 <mauke> also, types don't depend on values
12:32:25 <ski> Scriptonaut : it is possible to distiguish between `3' and `3.4' at run-time, and depending on that, return a value of a different type
12:32:32 <voidzero> mauke, maybe values depend on types :)
12:32:33 <orzo> i suppose reading a string literal can potentially happen at compile time, but why the hell would anyone want to do that?
12:32:46 <mauke> orzo: printf
12:33:03 <bennofs> Scriptonaut: you can write a function readNumber :: IO (Either Int Double) that reads either an integer or a double
12:33:18 <nitrix> EitherT IO Int Double :3
12:33:18 <Scriptonaut> what if I want to read a float
12:33:23 * ski . o O ( `$(printf "...") ...' )
12:33:23 <ChristianS> Scriptonaut: why not always read as float? that should work for "3" too
12:33:26 <voidzero> a float is a short double
12:33:29 <mauke> ski: BTDT
12:33:35 <Scriptonaut> ya, I was thinking of that ChristianS
12:33:48 <bennofs> nitrix: ew, that wouldn't be what I expect in this case, as the monad semantics don't really fit here
12:33:49 <ski> > (reads :: ReadS Float) "3"
12:33:50 <lambdabot>  [(3.0,"")]
12:34:29 <bennofs> Scriptonaut: the user cannot use types you didn't think of when you wrote the program, if that's what your asking
12:34:44 <Scriptonaut> :(
12:35:00 <mauke> how would that even work
12:35:01 <ChristianS> Scriptonaut: though actually, Double is probably better
12:35:07 <orzo> i think maybe Scriptonaut wants something like Parsec
12:35:08 <fsjdifo> 'instance Monad ((->) r) where' why does '->' have only one parameter 'r' here?
12:35:10 <Scriptonaut> I dunno, lots of languages do it
12:35:16 <mauke> fsjdifo: partial application
12:35:18 <voidzero> yeah imperative languages
12:35:19 <mauke> Scriptonaut: none do
12:35:20 <bennofs> mauke: in Java, it would be possible via reflection. Python it could also work
12:35:25 <hsk3> In this function: https://pastee.org/c8pzn  Does Haskell ever compute a (even if it's not needed)?
12:35:30 <mauke> bennofs: no
12:35:39 <fsjdifo> mauke: constructors can be partially applied?
12:35:43 <bennofs> voidzero: nothing to do with imperative/functional
12:35:46 <mauke> fsjdifo: A -> B is equivalent to (->) A B is equivalent to ((->) A) B
12:35:50 <mauke> fsjdifo: yes, type-level currying
12:35:58 <ski> fsjdifo : because given `instance Monad Foo', we must have `Foo :: * -> *'. since `(->) :: * -> * -> *', we can't say `Monad (->)'. but if `rho :: *', then `(->) rho :: * -> *', which fits
12:35:59 <voidzero> bennofs, with python you can do (1 + 2.1) and Python won't care
12:36:02 <fsjdifo> mauke: oh i didnt know that was possible
12:36:03 <bennofs> mauke: well, in java I could write a program that reads in a class name and creates an object of that class at runtime
12:36:11 <benzrf> bennofs: eek
12:36:13 <orzo> hsk3: well, you could do something similar in haskell with dynamics and generics
12:36:20 <ski> fsjdifo : it's the same with `instance Monad (Either e)'
12:36:22 <bennofs> mauke: so surely it would work for numbers too?
12:36:23 <mauke> bennofs: only if that class is actually loaded in your program
12:36:26 <ChristianS> Scriptonaut: what do you even want to do with a value if you don't know it's type?
12:36:35 <bennofs> mauke: the jvm can load classes at runtime, no?
12:36:48 <bennofs> ChristianS++
12:36:59 <orzo> hsk3: wrong nick i think, excuse me
12:37:05 <hsk3> yeah, np
12:37:19 <mauke> bennofs: sure, but I don't expect a user that types text into my program to also supply a custom .class file to go with it :-)
12:37:43 <ski> Scriptonaut : a value doesn't "carry" its type. if you don't know its type, the only thing you can do with it is pass it on to someone else (who perhaps knows its type)
12:37:48 <mauke> some programmer still has to think beforehand and supply the .class
12:37:52 <fsjdifo> ski: okay that was what i was missing i think, i didnt know you could do type-level currying
12:37:55 <bennofs> mauke: you could have some kind of global class where "number providers" need to register themselves. Those could then be loaded at runtime. This is not so easy to achieve in haskell
12:38:09 <fsjdifo> ski: or is that kind-level currying?
12:38:16 <ski> fsjdifo : type-level
12:38:29 <fsjdifo> kk
12:38:44 <Scriptonaut> it doesn't like when I change it to: computeRPN :: (Double a, Read a) => String -> a
12:38:47 <Scriptonaut> the type signature
12:38:55 <bennofs> Scriptonaut: double is not a typeclass
12:38:58 <Scriptonaut> 'Double' is applied to too many type arguments
12:39:00 <mauke> Scriptonaut: String -> Double
12:39:00 <Scriptonaut> oh
12:39:03 <bennofs> Scriptonaut: you need to use String -> Double
12:39:10 <Scriptonaut> that's right
12:39:39 <Welkin> :t 1.0
12:39:40 <lambdabot> Fractional a => a
12:39:46 <Welkin> use Fractional a
12:39:50 <Scriptonaut> don't I still need (Read a) =>...
12:39:56 <Scriptonaut> how do I work that in with Double
12:40:03 <bennofs> Scriptonaut: no, because you now said that a = Double
12:40:03 <voidzero> Read isn't a type
12:40:10 <Scriptonaut> I know
12:40:18 <Scriptonaut> oh, I get it
12:40:22 <Welkin> Double is an instance of Fractional
12:40:27 <Scriptonaut> Double derives from Read
12:40:30 <mauke> Scriptonaut: no
12:40:30 <Scriptonaut> so I don't have to specify
12:40:31 <bennofs> Scriptonaut: so that when you use read x :: Double, the compiler will need to solve Read Double. And it knows that is true, no need to "assume" it via =>
12:40:33 <mauke> Scriptonaut: Double is not a class
12:40:39 <Scriptonaut> I never said itw as?
12:40:42 <Scriptonaut> it's a type
12:40:47 <mauke> Scriptonaut: you said it derived from Read
12:40:55 <Scriptonaut> ya
12:40:59 <mauke> ??
12:41:02 <johnw> he means it's an instance of Read
12:41:02 <Welkin> there is no derivation
12:41:03 <kadoban> Scriptonaut: It's an instance of Read. Derived from is…not really right terminology.
12:41:03 <voidzero> :t read
12:41:04 <lambdabot> Read a => String -> a
12:41:05 <Scriptonaut> or many I mean instance
12:41:08 <bennofs> Scriptonaut: the proper terminology is to say that is an instance of Read
12:41:09 <ski> Scriptonaut : `computeRPN :: (Num a,Read a) => String -> a' if you want to be general. e.g. `computeRPN :: String -> Double' if you want to be specific
12:41:11 <Scriptonaut> maybe*
12:41:25 <voidzero> anyway. glhf.
12:41:27 * voidzero &
12:41:29 <Scriptonaut> so derive is when you're talkinga bout another type class?
12:41:33 <mauke> no
12:41:39 <Welkin> Scriptonaut: no, there is no deriving in haskell
12:41:42 <ski> Scriptonaut : plus you need to fix the call in `getEquation'
12:41:47 <Welkin> typeclasses do not inherit or derive from anything
12:41:50 <johnw> Welkin: you mean, except for the keyword "deriving"? :)
12:41:50 <mauke> Welkin: wrong
12:41:53 <Scriptonaut> Welkin: ya there is
12:41:56 <voidzero> types derive
12:42:02 <kadoban> Welkin: Well, there is, but it's not the same thing, haha.
12:42:07 <fsjdifo> whats the difference between 'prelude' and 'base' ?
12:42:10 <voidzero> data Foo = Foo { bar :: baz } deriving Show
12:42:16 <bennofs> Scriptonaut: derive doesn't really exist in haskell the way you know it from other languages (there is a keyword deriving, but that means something different)
12:42:21 <johnw> fsjdifo: prelude is the implicitly imported modules from base
12:42:24 <mauke> Scriptonaut: the compiler can "derive" instances
12:42:27 <ski> you can (sometimes) derive ("automatically generate") an instance of a type class, for a given type
12:42:27 <fsjdifo> ah ok
12:42:30 <Welkin> kadoban: do you mean constraints on the types? Such that all Monads are Functors?
12:42:31 <geekosaur> fsjdifo, base is a collection of modules, Prelude being one of them. Prelude is implicitly imported into every module
12:42:38 <Welkin> I wouldn't call that deriving
12:43:01 <mauke> Scriptonaut: classes can have superclasses. in OO languages this might be called "deriving" but not in haskell
12:43:10 <kadoban> Welkin: I mean there is something called "deriving", so your first statement is not really correct, heh. It just means something totally different than Scriptonaut was using it for.
12:43:12 <Scriptonaut> what am I thinking about then
12:43:16 <Scriptonaut> the tutorial I'm reading said derive
12:43:31 <Welkin> kadoban: yes, but that is just a way to make the compiler write instances for those typeclasses
12:43:37 <kadoban> Scriptonaut: Hopefully in a different context?
12:43:42 <Scriptonaut> http://learnyouahaskell.com/chapters
12:43:42 <kadoban> Welkin: Yeah
12:43:49 <bennofs> Scriptonaut: what chapter
12:43:52 <Scriptonaut> I'll try to find where it talks about derivation
12:43:54 <ReinH> Welkin: Yes, the point is that there is a thing called "deriving".
12:44:12 <jedai> Scriptonaut: data .. = ... deriving (Show, Eq...) ?
12:44:21 <Scriptonaut> yes, that
12:44:25 <bennofs> Scriptonaut: "to derive" in haskell means more like "the compiler automatically generates(derives) code"
12:44:45 <Scriptonaut> I know, I didn't think it was like classical OOP or anything
12:44:55 <Scriptonaut> but there is literally a derives keyword lol
12:45:02 <voidzero> thus... https://www.haskell.org/haskellwiki/Typeclassopedia
12:45:07 <jedai> deriving
12:45:31 <MonrealRyan> hi everyone new to haskell
12:45:39 <hsk3> In this function: https://pastee.org/c8pzn  Does Haskell ever compute a?
12:45:46 <mauke> hi to everyone not new to haskell, too!
12:45:53 <kadoban> :)
12:45:58 <Welkin> hsk3: no
12:46:01 <ski> welcome, MonrealRyan
12:46:26 <hsk3> Welkin: so in that sense it's lazy. and it's different from imperative where unused variable would be computed (unless the compiler optmizes it away). right?
12:46:27 <geekosaur> and being an unreferenced local binding it may not even appear in the generated Core
12:46:39 <Welkin> hsk3: yes
12:46:42 <hsk3> THANKS
12:46:50 <Welkin> expressions are only evaluated when they are needed
12:46:55 <hsk3> cool
12:46:55 <nvez> [names !! j | j <- [1..length r]] ... if 'r' is a list, how would i modify it to take every single value of the list?
12:47:18 <mauke> heh
12:47:28 <mauke> nvez: remove [1..length and ]
12:47:41 <Scriptonaut> can you modify what an existing type derives from?
12:47:54 <Scriptonaut> by that I mean what typeclasses it's an instance of
12:48:01 <mauke> you can't remove instances
12:48:06 <mauke> you can always add instances
12:48:09 <Welkin> Scriptonaut: you can declare your own instance for existing types
12:48:14 <nvez> mauke: so it would be j <- r ?
12:48:14 <kadoban> Scriptonaut: You can add instances. (by the way, don't use that first phrasing, it's…not correct)
12:48:17 <mauke> nvez: yep
12:48:22 <Scriptonaut> Welkin: instance of a type? Or a typeclass
12:48:25 <Welkin> that is what `deriving` does
12:48:36 <geekosaur> you can add new typeclass instances but it's not always a wise idea because they're global. (it's ok in programs, bad idea in libraries unless you created the typeclass you're instancing it for)
12:48:43 <ski> > [["Jane","Bart","Karen","John"] !! j | j <- [2,1,3,0]]
12:48:45 <lambdabot>  ["Karen","Bart","John","Jane"]
12:48:49 <mauke> Scriptonaut: all instances are for existing types. a non-existing type can't have instances
12:48:53 <hsk3> Welkin: can a similar thing be said about   let <a bunch of variables> in ...    if some of the variables are not used in ... ?
12:49:10 <benzrf> ski: isnt that O(n^2) or something
12:49:16 <ski> yes
12:49:18 <kadoban> hsk3: Yeah, they're equivalent
12:49:22 <Scriptonaut> So I can make Double an instance of Blah (some random typeclass I made)
12:49:23 <nvez> cool ski makes sense
12:49:24 <hsk3> ok thx
12:49:25 <nvez> now i have another issue
12:49:27 <mauke> Scriptonaut: sure
12:49:29 <geekosaur> "deriving" in Haskell refers to automatically constructing an instance of a typeclass, which can be done for some Report-standard typeclasses and can be done to make existing instances visible through a newtype declaration (which normally hides them)
12:49:43 <Scriptonaut> how do I require that Double is an instance of Blah in a type constraint
12:49:49 <mauke> Scriptonaut: you don't
12:49:53 <Scriptonaut> when it looks like: computerRPN :: String -> Double
12:50:04 <Welkin> Blah a => a
12:50:05 <mauke> Scriptonaut: you just use it
12:50:05 <geekosaur> you have a declaration instance Blah Double where ...
12:50:11 <Welkin> where a is a Double in your program
12:50:19 <mauke> Welkin: doesn't contain Double
12:50:28 <mauke> geekosaur: not a type signature
12:50:30 <Scriptonaut> I want both double and blah in there
12:50:32 <jedai> Scriptonaut:
12:50:42 <orzo> nvez: that [names !! ... stuff is not good code, better to take (length r - 1) $ drop 1 names
12:50:43 <mauke> Scriptonaut: you can't
12:50:49 <geekosaur> right, you had already said "you don't", did I need to repeat that?
12:51:16 <orzo> nvez: all those !! will cause exceptions and each one is order-n acess making your version order r^2
12:51:20 <kadoban> Scriptonaut: You don't. It either is or isn't. You only require types to be instances of typeclasses when that's all you care about, not when it's a specific type. So you'd do (Blah a) => a -> Something. But if the type you're using is just Double…there's no point to (Blah Double) => Doublde -> Something. I don't know if that's even valid syntax. It wouldn't do anything even if it was though.
12:51:41 <jedai> Scriptonaut: Constraints are for type variables, when you want your function to be polymorphic but only for types that are instances of a certain typeclass
12:51:43 <Scriptonaut> hmm, k
12:51:52 <Scriptonaut> ah, ok
12:52:21 <ski> > let foo :: Eq (Bool -> Bool) => (); foo = () in foo  -- requiring (in vain, in this case) that `Bool -> Bool' is to be an instance of `Eq'
12:52:22 <lambdabot>  No instance for (GHC.Classes.Eq (GHC.Types.Bool -> GHC.Types.Bool))
12:52:22 <lambdabot>    arising from a use of ‘foo’
12:52:49 <kadoban> If, in the function you used something that required the Blah typeclass, but Double isn't an instance of Blah, you'd already get an error (that's why it wouldn't do anything even if the syntax was valid).
12:53:12 <mauke> hmm
12:53:12 <ski> as kadoban says, i can't see if there'd ever be any point in doing this
12:54:10 <ski> (using an (nonlocal) in-scope tyvar in the constraint could be useful, though)
12:54:17 <orzo> maybe !! should be deprecated, i don't think experienced haskellers ever find much use for it
12:54:38 <Welkin> it can still be useful
12:54:38 <Scriptonaut> what do you use in place of it
12:54:51 <Welkin> but if you want to index a sequence, you probably want a Vector
12:54:55 <ski> you use some other data structure than lists
12:55:01 <Welkin> a List is better used as a control structure
12:55:05 <Scriptonaut> ah, that makes sense
12:55:07 <mauke> drop
12:55:09 <Scriptonaut> is there an Array?
12:55:11 <Welkin> use a Sequence or a Vector if you want to store data
12:55:18 <mauke> Scriptonaut: several!
12:55:18 <jedai> orzo: That's a bit exagerated, sure if you use it a lot list is probably not the right data structure but once in a blue moon, it's ok
12:55:19 <Welkin> Vector is a wrapper around Array
12:55:21 <mauke> sadly
12:55:24 <kadoban> Scriptonaut: Yeah. Several actually, depending on exactly how you want them to behave.
12:55:27 <Scriptonaut> oh, cool
12:55:38 <ski> there's both immutable and mutable arrays
12:55:44 <Welkin> Sequence is like a List but with O(log n) access to the middle and O(1) access to the ends
12:55:50 <orzo> jedai: how long would it take you to find a !! in the code you've written?
12:55:56 <Scriptonaut> Anyone know why maps are implemented as trees?
12:55:57 <kadoban> Arrays are pretty badass in haskell actually, once you get past the part where there's like 5 you have to pick from.
12:56:04 <ski> mutable arrays must be accessed through a monadic or applicative interface
12:56:20 <Scriptonaut> seems like haskell could have done it like other languages with O(1) lookup time
12:56:24 <mauke> Scriptonaut: what else would you use?
12:56:27 <kadoban> Scriptonaut: They have nice properties in a purely functional language like haskell.
12:56:33 <orzo> jedai: an opperator suggests cheapness when it is actually pretty expensive
12:56:44 <orzo> maybe rename it to elementAt
12:56:51 <Welkin> Scriptonaut: Arrays and Vector have O(1) access time
12:56:58 <Scriptonaut> I think other languages use some kind of heuristic and indexing thing, I'm nots ure
12:57:01 <ski> Scriptonaut : immutability of haskell values means that you can share most of the old tree with the new one
12:57:10 <Scriptonaut> Welkin: that's good
12:57:10 <Welkin> Sequence is a finger tree, not a contiguous section of memory
12:57:11 <kadoban> Scriptonaut: The naive way of implementing hash-table-like stuff requires mutability/non-purity.
12:57:29 <jedai> orzo: well maybe but you should still have it at your fingertip for the rare case where it is useful (sometimes for memoization)
12:57:33 <Scriptonaut> oh that's right
12:58:06 <ski> jedai : .. immutable arrays can be useful for memoization
12:58:20 <ReinH> Welkin: Well, vector is a wrapper around Data.Primitive.Array, not the Array from the array package.
12:58:39 <ski> Scriptonaut : do you understand the difference between persistent and ephemeral data structures ?
12:58:40 <jedai> ski: sure, that's my preferred way of doing it, but sometimes an infinite list is cool (not for long running programs)
12:58:44 <kadoban> Scriptonaut: If you're pretty interested, there's a great book on the subject, Okasaki's Purely Functional Data Structures
12:58:48 <ski> jedai : *nod*
12:59:11 <nvez> reading buffer
12:59:12 <ski> kadoban : what i just said is discussed in that book, e.g.
12:59:17 <Scriptonaut> ya ski I do
12:59:26 <kadoban> Indeed
12:59:30 <nitrix> If I have a record, and I place multiple times that record in a list, is it going to consume N times the memory?
12:59:31 <Scriptonaut> kadoban, I'll check it out
12:59:44 <nitrix> Or is haskell smart enough to recognise it's using the same object?
12:59:51 <nitrix> GHC actually.
12:59:51 <fsjdifo> record syntax for retrieving a value is so confusing
12:59:57 <Welkin> nitrix: it is not the same object
12:59:57 <ski> nitrix : the latter
13:00:03 <bennofs> Scriptonaut: hashmaps are actually not easily implemented in haskell. In fact, to be efficient, they require mutation
13:00:10 <bennofs> oh, forgot to scroll
13:00:15 <Scriptonaut> that makes sense
13:00:39 <orzo> mutation is not hard in haskell
13:00:47 <ReinH> nitrix: let x = "foo" in [x,x,x,x] will only store one copy of "foo"
13:00:47 <Welkin> ski: what do you mean?
13:00:52 <nitrix> Welkin: The object is obtained from the same constant function. It is passed around a bit, copies are made, but it's the same record from the begining, not mutable.
13:01:02 <Welkin> hm, okay
13:01:05 <jedai> nitrix: that depends what you mean by "use the same object" : if you build several time in several places similar objects, Haskell won't magically recognize that
13:01:07 <ReinH> Or rather, it will store 4 thunks that, when evaluated, will share the value "foo"
13:01:27 <Scriptonaut> in ML there was a ref type, is there something like that in haskell
13:01:31 <mauke> nitrix: how are you making copies?
13:01:37 <ski> Welkin : i'm not sure whether "it is not the same object" holds in this case
13:01:41 <orzo> what's the ref type do in ML?
13:01:46 <jedai> nitrix: in this case it will work (you can basically count on everything being "passed by reference" in Haskell
13:01:47 <Scriptonaut> it's a reference
13:01:48 <ski> Scriptonaut : yes, `IORef',`STRef'
13:01:48 <mauke> Scriptonaut: STRef
13:01:49 <kadoban> fsjdifo: You get used to it. It's actually pretty nice, mostly.
13:01:50 <Scriptonaut> so you can mutate shit
13:02:20 <orzo> oh, yeah there's a lot of those, TVar is another one
13:02:29 <ski> @type Data.IORef.writeIORef
13:02:30 <lambdabot> GHC.IORef.IORef a -> a -> IO ()
13:02:40 <nitrix> mauke: jedai: They're not really copies, just passed as an argument to other functions and eventually gobbled into a list. I used to have something called a Resource with a ProviderId and a BlockId, now I'm wondering if I can't just have the Provider record directly in my Resource.
13:03:01 <Scriptonaut> do you guys recommend using ref types
13:03:10 <Scriptonaut> WHen I was writing ML it was kinda taboo
13:03:16 <Welkin> don't use mutation unless you absolutely need to
13:03:18 <mauke> if everything is immutable, you never have to make a straight-up copy
13:03:21 <mauke> share all the things
13:03:31 <ski> nitrix : if you just pass it around, then implementations typically wouldn't copy (unless they decide to do that for optimization reasons)
13:03:32 <Scriptonaut> ya
13:03:49 <Scriptonaut> has haskell changed much since 1999?
13:03:53 <Welkin> yes
13:03:56 <Scriptonaut> I dunno if I want to spend my money on a 16 year old book heh
13:04:02 <Welkin> it has changed a lot since a few months ago
13:04:07 <Scriptonaut> the "Purely Functional Data Structures"
13:04:10 <Welkin> oh
13:04:15 <nitrix> ski: providers :: [Provider]
13:04:20 <Welkin> that uses ML for the examples
13:04:30 <Welkin> Okasaki's book is about concepts
13:04:34 <jedai> Scriptonaut: that's a theoretical book, it's still completely valable
13:04:35 <nitrix> ski: So providers would, in practice, always give me the same static list?
13:04:35 <Welkin> it does have haskell code in the back
13:04:40 <ski> Scriptonaut : imho, that book is worth its salt
13:04:41 <hodapp> what book's this?
13:04:42 <Welkin> but the code throughout  the book is in ML
13:04:46 <ReinH> Scriptonaut: Okasaki is not a Haskell book. It's a book about data structures.
13:04:46 <orzo> Scriptonaut: haskell has been changing pretty fast steadily since it was born
13:04:59 <Welkin> it's like a math book -- the information is still good and will be for decades
13:05:01 <ski> nitrix : i believe so
13:05:14 <jedai> Scriptonaut: The concept are still the same (though some nice data structures have been discovered since)
13:05:19 <bennofs> Wasn't there some free version of Okasaki? I saw it was linked from free programming books articlle recently iirc
13:05:25 <hodapp> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf ?
13:05:29 <ReinH> Scriptonaut: There have been some new ideas but everything in the book is still relevant.
13:05:30 <hodapp> that's '96 though
13:05:32 <ski> bennofs : there's Okasaki's thesis .. ^
13:05:33 <orzo> Scriptonaut: expect your haskell code to require more maintenence to keep up with the latest compiler than your c code does
13:05:33 <Welkin> Okasaki wrote it as a thesis first
13:05:33 <nitrix> ski: Does that means things like `length providers` gets memoized?
13:05:42 <ski> nitrix : no
13:05:47 <Welkin> the book is the second edition (with haskell code in the back)
13:06:07 <ski> nitrix : memoizing functions is different
13:07:20 <nitrix> It's a function with no arguments and no side-effects, the compiler should be able to already do quite a lot of static analysis on those :/
13:07:34 <mauke> "function with no arguments" makes no sense
13:07:42 <mauke> every function has exactly one argument
13:07:55 <nitrix> mauke: Then what is the argument of that function?
13:07:57 <orzo> nitrix: the compiler, by default, will not attempt computations that it cannot prove will terminate.  An NP hard problem in general.
13:08:00 <jedai> nitrix: if it has no arguments it is not a function
13:08:02 <mauke> nitrix: of what function?
13:08:10 <nitrix> mauke: providers :: [Provider]
13:08:16 <mauke> nitrix: that's a list, not a function
13:08:56 <init> orzo: NP hard? you mean undecidable?
13:08:57 <nitrix> Right.
13:09:13 <kadoban> orzo: "Will this arbitrary code terminate" is acutally much harder than NP, right undecidable.
13:09:21 <nitrix> So it can probably reduce all the `length providers` then.
13:09:21 <orzo> init: oh, right
13:09:38 <orzo> init: same differece to me ;)
13:09:40 <ski> nitrix : you might find monochrom's "Lazy Evaluation of Haskell" at <http://www.vex.net/~trebla/haskell/lazy.xhtml> interesting (appears to be down atm ?, try <https://web.archive.org/web/20141218085154/http://www.vex.net/~trebla/haskell/lazy.xhtml>)
13:10:30 <Scriptonaut> thanks for the tips guys
13:10:31 <Scriptonaut> I might buy it
13:10:39 <Scriptonaut> I know ML so that's not a problem
13:10:43 <Scriptonaut> (the it being in ML part)
13:11:30 <Darwin226> Can you guys recommend a light weigth lens library? Something that just let's me use record fields as setters as well as getters
13:11:41 <johnw> lens-family
13:11:57 <fsjdifo> how does haskell infer the monad to use for liftM* ? Does it look at the next parameter (after the function) ?
13:11:59 <johnw> I don't think it has any TH machineray to help you makes those getters and setters, though
13:12:11 <orzo> i think the compiler should try computations optimistically and just give up before termination if it doesn't work out
13:12:30 <kadoban> :t liftM2
13:12:32 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:12:33 <mauke> fsjdifo: it looks at everything, as usual
13:12:36 <ski> Scriptonaut : it uses in places an ML extension (a version thereof implemented in SML/NJ, iirc) for (explicit) laziness. you should also check out Wadler's paper "How to add laziness to a strict language, without even being odd" at <http://homepages.inf.ed.ac.uk/wadler/topics/language-design.html>, if you haven't already
13:12:45 <fsjdifo> mauke: what about partial application?
13:12:48 <bennofs> johnw, Darwin226: there is lens-family-th
13:12:53 <c_wraith> fsjdifo: inference always works the same way.  It looks at the arguments and how the expression is used.
13:12:54 <bennofs> (for the th part=
13:12:59 <nvez> orzo: trying to understanding the logic of this .. take (length r - 1) $ drop 1 names ... can you help me understand what this is trying to do?  drop 1 names -> drops the first item in names .. then take (length r-1) takes the items 0...r-1 out of names?  but I'm not sure why the drop?
13:13:06 <fsjdifo> :t liftM id
13:13:07 <lambdabot> Monad m => m r -> m r
13:13:15 <nvez> s/out of names/out of the names with the first item dropped?/
13:13:17 <johnw> bennofs: oh, cool!
13:13:18 <Darwin226> johnw: bennofs: Ok guys, I'll check those out
13:13:45 <ski> Scriptonaut : you might also compare with SRFI 45 "Primitives for Expressing Iterative Lazy Algorithms" <http://srfi.schemers.org/srfi-45/srfi-45.html>
13:13:46 <orzo> nvez: i don't remember your original code, but i thought you started indexing [1..] where as the firsgt element has index 0
13:14:20 <fsjdifo> :t liftM (==)
13:14:22 <lambdabot> (Monad m, Eq a1) => m a1 -> m (a1 -> Bool)
13:14:26 <Scriptonaut> thanks ski
13:14:33 <nvez> orzo: str = concat $ "eggs " : [names !! j | j <- r]
13:14:35 <Scriptonaut> so far I've only done the learn you a haskell, on ch.10
13:14:40 <nvez> that is what i was trying to do.. but i was recommended against !!
13:14:55 <nvez> wouldn't i have ... take (length r - 1) names ?
13:15:00 <Welkin> Scriptonaut: a better resource is the UPenn course
13:15:05 <Welkin> ?where learnhaskell
13:15:05 <lambdabot> https://github.com/bitemyapp/learnhaskell
13:15:23 <Scriptonaut> I'll do that one as well
13:15:27 <Scriptonaut> this one just seemed beginner friendly
13:15:28 <Welkin> use those resources, especially the UPenn course and Nicta course
13:15:31 <Scriptonaut> and I like the illustrations
13:15:36 <Scriptonaut> reminds me of the little schemer
13:15:38 <Welkin> LYAH is not really a good resource
13:15:47 <Darwin226> I'm having such a hard time forcing myself to like the operator galore that all these lens packages provide
13:15:52 <Welkin> it is good to get people exciting about Haskell and to get them started
13:16:00 <Welkin> excited*
13:16:07 <glguy> Darwin226: You don't have to use operators to use lens
13:16:20 <bennofs> Darwin226: lens-family has much less operators. also they have a system (
13:16:27 <bennofs> iirc
13:16:28 <Darwin226> glguy: I know, but I assume that other people do use them
13:16:38 <orzo> nvez: your deleting all string from the list names except those indexed by an element in the list r.  I wouldn't suggest using drop for that.  it's possible i misunderstood what you were doing when i made the suggestion earlier
13:16:40 <kadoban> Scriptonaut: The upenn course actually suggests readings from LYAH (and RWH, and probably others) at appropriate times. It just has more structure to it, and the most important part is it has exercises to do so you learn better.
13:16:54 <glguy> Darwin226: Well, you at least shouldn't feel compelled to force yourself to like it ^_^
13:17:04 <hsk3> let square x = x*x in (square 2, square 3)
13:17:05 <hsk3> How can I specify the type of a function in let?
13:17:11 <Welkin> the best way to learn is to open up a text editor and write programs
13:17:14 <EvanR> any tips on what i should read to model this kind of thing in the type system http://lpaste.net/120224 literally spelling out 256 data types doesnt seem right. but somehow i feel like the workflow here can be encoded in types, and help someone understand the order and context
13:17:16 <Darwin226> <$> looks good to me. %~ on the other hand... Not to mention ^. or the other similar completely assimetric ones
13:17:27 <Scriptonaut> that's one thing I haven't liked about LYAH
13:17:30 <Welkin> hsk3: f :: Type
13:17:33 <Scriptonaut> I can read haskell pretty well
13:17:38 <Welkin> hsk3: the same way you always do
13:17:38 <Scriptonaut> but I haven't written much
13:17:50 <ReinH> Darwin226: <$> is from Control.Applicative.
13:17:53 <kadoban> hsk3: The same way you specify multiple clauses in let, one clause is the type, the next is the definition, etc.
13:17:53 <Welkin> let f :: Type
13:17:56 <Welkin>     f = ...
13:17:59 <bennofs> Darwin226: ^. looks ok if you write it without spaces, like x^.a.b._1
13:18:03 <hsk3> kadoban: ah ok
13:18:04 <hodapp> the one fellow whose blog people link to constantly said he'll write a book after finishing his PhD
13:18:10 <kadoban> Scriptonaut: Exactly. After reading it I was like…okay cool.. uhmm now how do I actually code?
13:18:16 <Darwin226> ReinH: Yeah, yeah, I know. I was just naming an example of an operator that I don't mind.
13:18:34 <nvez> orzo: r is a list of numbers, names is a list of strings, for example r might contain [1,2,3,4] and names might contain ["a", "b", "c", "d", "e"] .. given that r, i want to return [a, b, c, d]
13:18:36 <ReinH> Darwin226: "asymmetric" seems like a strange way to judge them, but ok
13:18:43 <Scriptonaut> heh ya, that's how I feel
13:18:58 <Darwin226> ReinH: From an aesthetic point of view, it makes perfect sense
13:19:08 <ReinH> Darwin226: Yes, but I don't think the aesthetic point of view is very useful
13:19:15 <nvez> in python. i'd say ... [names[x] for x in r]
13:19:38 * ski minds `<*>'
13:19:39 <Welkin> nvez: [x | x <- xs] is read as "x for x in x's"
13:19:39 <Darwin226> ReinH: It makes me unhappy looking at my code. That's also to very useful. Though I, of course, realize that's I'm the problem here
13:19:41 <orzo> nvez: i take it you want 1 in r to indicate the first element of names?  Well !! uses 0 for that, not 1.  fyi
13:19:59 <Darwin226> *not very useful
13:20:03 <cstrahan_> johnw: pong
13:20:09 <ReinH> nvez: Well, you can do something like map fst . filter (`elem` [1,2,3,4]) . zip [1..]
13:20:22 <ReinH> nvez: But maybe there's a better way to do this than checking indexes in a list
13:20:26 <ChristianS> ski: what's wrong with <*> ?
13:20:26 <ReinH> er map snd
13:20:37 <init> ReinH: you're missing a fst, too?
13:20:43 <ReinH> init: yeah
13:21:05 <init> @type map snd . filter ((`elem` [1,2,3,4]) . fst) . zip [1..]
13:21:06 <lambdabot> [b] -> [b]
13:21:21 <benzrf> ~d   i            DANtheBEASTman       DANtheBEASTman                  f         i   i    i     Interpretist     inad922       Interpretist       doofy         d          doofy           doofy      Darwin226      d     Darwin226     i           Darwin226      init        d                            Darwin226
13:21:26 <benzrf> shit
13:21:31 <orzo> nvez: it'd be better O(n) to write it using a fold than it is to use use the list comprehension with !!
13:21:33 <benzrf> this is what happens when you abuse tab complete :|
13:21:38 <edwardk> Darwin226: import Control.Lens.Combinators -- all the combinators, none of the operators. done
13:21:49 <orzo> the list comprehension with !! is O(n^2)
13:21:51 <ReinH> > map snd . filter ((`elem` [1,2,3,4]) . fst) . zip [1..] $ "abcde"
13:21:52 <lambdabot>  "abcd"
13:22:14 <bennofs> edwardk: I think this was with lens-family
13:22:17 <ReinH> is O(n*m) in length of both lists
13:22:31 <ski> ChristianS : imho, `<$>' would be a better name for `<*>', and `<*>' a better name for `liftA2 (,)'
13:22:35 <edwardk> i was just answering a comment he mentioned at the opening around not liking the fact that lens had so many operators
13:23:29 <mniip> is there a way I could somehow use a typevariable from an instance declaration in a type constraint within that declaration?
13:23:32 <Darwin226> edwardk: I'd rather find a way to like them. I thought maybe I'd get a "don't worry, you get used to them" or something similar
13:23:37 <ski> ChristianS : to me, `<*>' suggests an operation with operands having symmetric roles
13:23:43 <nvez> orzo: i see what you mean at the indexed at 1
13:23:57 <edwardk> Darwin226: well, they _do_ grow on you =)
13:24:00 <nvez> it is indexed at 1 so i would have to increase the length by 1 to get the 0 index
13:24:07 <ChristianS> ski: yeah, that's true
13:24:35 <nvez> and this is an entry-level assignment in a haskall class.. looking at basics really
13:24:39 <benzrf> ski: same
13:24:43 <ski> ChristianS : `<$>' could perhaps then be renamed to `$>'
13:24:43 <edwardk> Darwin226: but e also try to not be too prescriptive about how folks use lens. Since there was a very vocal minority who just couldn't stand the operators at all we made it possible to avoid them without 100+ hiding clauses ;)
13:25:00 <ski> benzrf :)
13:25:25 <edwardk> it has the benefit that it serves both the community that hates operators entirely, and also the community that really loves the operators but wants to qualify all the combinators, since that latter group can use import qualified Control.Lens.Combinators as Lens; import Control.Lens.Operators
13:25:48 <edwardk> so by adopting that practice i don't have to choose between the 3 major camps of lens users and they can all just feud amongst themselves
13:25:48 <Darwin226> edwardk: That's very nice of you.
13:25:50 <ReinH> ski: That might be confusing when <$ means something else though
13:26:43 <edwardk> ski: having a ($>) that actually obeys the <* and *> intuitions is actually more beneficial, especially when you start using wfix on comonads
13:26:51 <edwardk> since you often have a complex value being put on the right.
13:27:30 <ski> ReinH : possibly
13:29:26 <orzo> nvez: !! does a search starting at the beginning of the list each time you use it, there's no direct access to the nth element of a list
13:32:39 <MonrealRyan> Hi Does Tuples is the same as ARRAY?
13:32:47 <ski> edwardk : hm. any example ?
13:32:50 <ski> MonrealRyan : no
13:33:01 <MonrealRyan> Hi Does TUPLES is the same as ARRAY?
13:33:05 <ski> tuples are heterogenous. arrays (and lists) are homogenous
13:33:20 <phaul> that's the thing with early haskell assignments + even the 99 propblems of haskell. Lists for everything. even if list is not the right thing to use
13:33:22 <orzo> MonrealRyan: are you asking if the implementation is isomorphic?
13:33:39 <MonrealRyan> ski: what do you by heterogenous?
13:33:46 <ski> homogenous : for any given array, all the elements of that array has to have the same type
13:33:50 <ski> (and similarly for lists)
13:33:53 <edwardk> ski: used to have some good ones. it has been a while =)
13:33:55 <kadoban> phaul: The 99 problems thing is pretty godawful, IMO.
13:34:07 <ski> heterogenous : the components of a tuple can be of different types
13:34:08 <Hijiri> 99 problems is a translation of a lisp thing, isn't it?
13:34:18 <hodapp> ...but a Lisp ain't one?
13:34:23 <cjenkin2> MonrealRyan, You can have multiple types in a tupple, e.g. (String, Int, [Double])
13:34:25 <phaul> not disputing that. It just gives you a feeling that lists are the answer
13:34:28 <edwardk> ski: pos :: History a -> Int; pos dx = wfix $ dx $> fby 0 . fmap (+1)
13:34:28 <ski> but also : arrays (and lists) can have variable number of elements. tuples have fixed number of components
13:34:30 <phaul> for everything
13:34:41 <ski> MonrealRyan ^
13:34:51 <edwardk> :t Control.Comonad.wfix
13:34:52 <lambdabot> Control.Comonad.Comonad w => w (w a -> a) -> a
13:35:02 <MonrealRyan> ski: Thank you....
13:35:14 <edwardk> nowadays i'd use kenny foner's version of fix though
13:35:25 <bmuk> Hey everyone, I know this isn't strictly haskell related, but I have found you all to be a warm and helpful community, and I need advice. Do you know of any companies that would be willing to hire me with my current level of experience (haskell, functional, or otherwise - haskell obviously preferred)? github: https://github.com/bmuk, cv: https://docs.google.com/document/d/181WKjSGbMXOLmLbsHG0OcWb3txuDIUp2jPrl9emxGSc/edit?usp=sharing,
13:35:25 <bmuk> linkedin: www.linkedin.com/in/brittmathis
13:35:46 <edwardk> ski: the pos example there is contained as a worked example in the comonad package
13:35:47 <EvanR> phaul: lists are a degenerate tree. a tree of dynamically typed values can get you so far, but not that far
13:35:52 <ski> MonrealRyan : use arrays or lists (or similar) when you want to "do the same thing" to every element. consider using tuples when you want to treat each component differently
13:35:56 <MonrealRyan> ski: does tuples can be muli-dimensional?
13:36:19 <ski> MonrealRyan : tuples are always `n'-tuples, for some finite natural number `n' (not `1')
13:36:24 <EvanR> phaul: a lot of lisp dogma centers around the easy of implementation, and so the implementation details leak into the perception of all solutions
13:36:53 <MonrealRyan> ski: thank you.
13:37:00 <cjenkin2> MonrealRyan, We usually call that "arity", and you can have any number of elements that you want (up to some upper bound iirc)
13:37:02 <ski> edwardk> :t dx
13:37:04 <stephen_> I've been looking at Galois' libraries for embedded software development -- Ivory and Copilot -- does anyone have a project using either -- or both -- that I could peruse for reference? (besides Galois' own SMACCMPilot, that is)
13:37:32 <edwardk> ski: data History a = First a | History a :> a -- is the history type used there
13:37:33 <cjenkin2> But unlike arrays or lists, the length of a tuple shows in the type, e.g. (Int, Int, Int) is not the same as (Int, Int)
13:37:41 <MonrealRyan> ski: by the way can i also shout the topic about Yesod Framework? hehehe
13:37:50 <cjenkin2> whereas [Int] can have 1, 2, or many ints in it
13:37:57 <Welkin> MonrealRyan: there is #yesod
13:38:08 <edwardk> dx is the arg to pos, and pos :: History a -> Int
13:38:14 <edwardk> so dx :: History a
13:38:29 <edwardk> it ignores the 'a' and just borrows the shape, and fills it up with numbers using fby
13:38:41 * hodapp gets rid of 175 instances of fromJust, feels better
13:38:42 <ski> edwardk : .. oh, for some reason i missed that `dx' was the argument name
13:38:48 <MonrealRyan> How to add that on my channel? or do i need t log out and change my channel?
13:38:50 <edwardk> this is a causal stream as a comonad
13:39:03 * ski nods
13:39:14 <Welkin> MonrealRyan: /join #yesod
13:39:15 <cjenkin2> MonrealRyan, type "/join #yesod"
13:39:34 <Welkin> it's not the most active channel
13:39:40 <MonrealRyan> THANK YOU GUYS......
13:39:46 <ski> you're welcome ..
13:39:46 <Welkin> but you can get questions answered there eventually
13:41:13 <MonrealRyan> I need to learn Haskell first http://learnyouahaskell.com/ bring me hear... and after that i need to use Yesod framework for my current project
13:42:25 <jmueller> Hi, are there any resources for writing a parser that produces a HOAS representation? Or more generally, how can I convert a "first order" AST into a higher order one?
13:42:41 <Hijiri> MonrealRyan: https://github.com/bitemyapp/learnhaskell might be a better learning resource
13:42:59 <Hijiri> more exercises, even if you ignore everything else
13:43:27 <Hijiri> and by things that could be ignored I mean qualities in the guide that are better than just reading lyah
13:44:36 <cjenkin2> Hijiri, Would you recommend that for someone who hasn't done much programming before at all, who is learning Haskell as their first real language?
13:44:56 <benzrf> cjenkin2: well
13:45:01 <benzrf> cjenkin2: how much math do you know
13:45:14 <benzrf> cjenkin2: do you know what a function is and what expressions are and what "f(x) = x * 2" means
13:45:15 <cjenkin2> benzrf, It's not me xD I have a student
13:45:20 <benzrf> ah
13:45:28 <cjenkin2> benzrf, I learned Agda before learning Haskell
13:45:29 <benzrf> well if they know all of that, they should be good for cis194
13:45:31 <benzrf> hopefully
13:46:05 <cjenkin2> benzrf, Ok, thanks. Just looking for more resources for them to study on their own
13:47:38 <nvez> I see this function in the code which I think I'm supposed to use.. but I don't understand it, how would I call this?  --- (.#.) :: [a] -> Integer -> a                  -- 1-indexing with 'Integer'
13:48:02 <nvez> There is a function below it but I'm not sure, never seen the defined like that
13:48:06 <ski>   myList .#. myIndex
13:48:17 <MonrealRyan> Hijiri: the site is much complicated, I need to go to the link to understand what was the title all about But i'll try this one.. and is the any site that can you recommend to me..
13:48:19 <nvez> that's interesting
13:48:21 <ski> or
13:48:27 <ski>   (.#.) myList myIndex
13:48:43 <nvez> which one is the "preferred" type when working with haskell?
13:48:56 <Welkin> MonrealRyan: https://github.com/bitemyapp/learnhaskell#yorgey-course---do-this-first-this-is-the-primary-way-i-recommend-being-introduced-to-haskell
13:49:14 <mniip> nvez, if it's made of symbols, it's an operator
13:49:16 <mniip> it goes infix
13:49:26 <josephle> nvez: which ever is readable, but in general it's going to be infix
13:49:26 <Welkin> MonrealRyan: also, /join #haskell-beginners
13:49:29 <nvez> str = concat $ "eggs " : [names .#. j | j <- r]
13:49:34 <nvez> this looks a lot more readable
13:49:36 <mniip> otherwise, if it's made of letters, so prefix, but there are some exceptions
13:49:38 <Welkin> MonrealRyan: you can get help with the course there
13:50:26 <MonrealRyan> Welkin: Thank you
13:50:37 <ski> > elem 2 [0,1,2,3]
13:50:38 <lambdabot>  True
13:50:43 <ski> > 2 `elem`[0,1,2,3]
13:50:44 <lambdabot>  True
13:50:50 <mniip> concat $ "eggs " : (map (names .#.) r)
13:51:15 <yyyyy> homebrew ghc + cabal-install on yosemite. anyone having issues with broken packages after install? i don't even get to load Data.Text on ghci, it just dies complaining about 'dyn' packages.
13:51:19 <nvez> mniip: what's the difference between that and the one above?
13:51:23 <mniip> there's none
13:51:25 <nvez> I'm sure the result is the same but what happens under
13:51:37 <yyyyy> does 7.8.4 uses shared libraries by default?
13:51:42 <nvez> oh okay
13:51:45 <bennofs> yyyyy: yes
13:51:48 * ski 'd prefer `concat ("eggs " : map (names .#.) r)' to that .. or in this case probably instead `"eggs" ++ concatMap (names .#.) r'
13:52:02 <ski> nvez : style
13:52:07 <mniip> yeah
13:52:09 <mniip> concatMap
13:52:17 <nvez> this is an assignment about "fixing" code.. so I'm trying to deviate the least from the original :p
13:52:26 <yyyyy> bennofs: so rebuilding everything but base with --enable-shared should get me rid of the problems?
13:52:34 <MonrealRyan> Welkin: Do i need to enroll in this site? http://www.seas.upenn.edu/~cis194/spring13/index.html
13:52:47 <mniip> hold on!
13:52:47 <Welkin> MonrealRyan: no, just go through the assignments and lectures
13:52:56 <mniip> ("eggs" ++) . ((names .#.) =<<)
13:53:04 * ski grins
13:55:08 <Cale> MonrealRyan: Nope! Just click Lectures and Assignments at the top
13:55:20 <Cale> (and then the links from there)
13:55:29 <MonrealRyan> Welkin: Thank you
13:55:31 <yyyyy> or, better, what's the preferable way to having a minimal, recent ghc install on os x yosemite?
13:55:32 <MonrealRyan> Cale: thank you
13:56:31 <Brandon`> @undo do img <- readImage path; return (img >>= toRGBA8Image)
13:56:32 <lambdabot> readImage path >>= \ img -> return (img >>= toRGBA8Image)
13:56:34 <kadoban> yyyyy: The instructions on here may work? https://github.com/bitemyapp/learnhaskell
13:56:47 <Brandon`> any way to make that prettier?
13:58:08 <Cale> Brandon`: You really want the computation to be deferred like that?
13:58:26 <Brandon`> Cale not sure what you mean
13:58:27 <yyyyy> kadoban: thanks. it links to the relocatable builds that have been around for a while. I'll revert to using them instead of a homebrew package. maybe it'll work :)
13:58:32 <phaul> edwardk: sorry for offtopic, but I was just wondering aren't you in the US? Isn't it like 3am over there?
13:58:47 <ski> Brandon` : `return . (toRGBA8Image =<<) =<< readImage path', i suppose. (also what Cale said)
13:58:53 <ReinH> Brandon`: what is that expression's type?
13:59:11 <Brandon`> FilePath -> IO (Either String (Image PixelRGBA8))
13:59:23 <kadoban> phaul: It's closer to 3pm in USA
13:59:28 <Brandon`> readImage :: FilePath -> IO (Either String DynamicImage)
13:59:37 <Brandon`> toRGBA8Image :: DynamicImage -> Either String (Image PixelRGBA8)
13:59:40 <Cale> Ah, okay, I see
13:59:42 <Enigmagic> Brandon`: maybe this?  fmap toRGBA8Image <$> readImage
13:59:57 <ReinH> Cale: So two different binds
14:00:05 <phaul> :) I see
14:00:08 <Enigmagic> oh
14:00:35 <Cale> fmap (>>= toRGB8Image) (readImage path)  would work, but I'm not sure it's clearer.
14:00:51 * hackagebot file-location 0.4.6 - common functions that show file location information  http://hackage.haskell.org/package/file-location-0.4.6 (GregWeber)
14:00:52 <ski> Brandon` : perhaps consider using some exception monad transformer, on top of `IO'
14:01:13 <Cale> For one line, I'm not sure it'd be worth the trouble though...
14:01:23 <orzo> ghc should make a new shared library format to support better inlining at dynamic link time
14:01:41 <Cale> For what it's worth, I think the original do-block is fine.
14:02:13 <edwardk> phaul: yes, i'm in the US
14:02:46 <orzo> i'm in the US, it's only 5pm
14:02:48 <Brandon`> I like fmap (>>= toRGB8Image) (readImage path). but I wonder if I'll know what it means in a few days :P
14:03:07 <phaul> 10:00pm here sorry for the off
14:03:35 <ski> Brandon` : add a comment `-- Can you remember what this means ?'
14:04:19 <kadoban> Brandon`: The type annotation probably helps quite a bit, I'd think.
14:05:12 <ReinH> let imageFrom img = return (img >>= toRGBA8Image) in imageFrom <$> readImage path
14:05:30 <ReinH> er, imageFrom =<< readImage path
14:06:19 <ReinH> er, liet imageFrom img = img >>= toRGBA8Image in imageFrom <$> readImage path -- such monad laws
14:07:12 <athan> Hey guys, `cabal install securemem` in my sandbox is yeilding "does not exist". What should I see this as?
14:07:31 <ReinH> athan: Maybe you need to cabal update?
14:07:56 <athan> it's copied from the same machine haha
14:08:01 <athan> but worth a shot :)
14:08:06 <athan> thanks ReinH
14:08:55 <Welkin> athan: did you get the message I sent you?
14:10:18 <athan> Welkin: I did! I will apply as soon as I finish this app (for a friend that already paid me). I just hope I can get along
14:12:05 <hodapp> hmm... I don't exactly know if I need heterogeneous lists here or not, as ultimately things are all turned to the same type, but I'm not sure how else to aggregate things
14:12:49 <hodapp> but, I have N things that all are instances of typeclass Foo, and what I do to all items eventually produces the same type
14:13:02 <Cale> What operations does Foo have?
14:13:19 <Cale> Yeah, usually the solution is just to apply the operation beforehand.
14:13:38 <hodapp> well, I'm trying to avoid having to make a bunch of calls on each things individually
14:14:13 <tdammers> you're not making the calls until the result is needed
14:14:17 <Cale> Like, just syntactically, or you're worried about performance of doing that operation if you might not have to? Lazy evaluation will take care of the latter.
14:15:02 <hodapp> Cale: Syntactically, it just seems ugly to have to do the call on each N items.
14:15:28 <tdammers> there are a few things you can do to make the syntax more palatable
14:15:54 <Cale> You could write something like  let i = ... in [i ..., i ...]
14:15:56 <tdammers> e.g., provide a different list construction operator that automatically does the conversion while assembling the list
14:16:11 <Cale> Or yeah, define your own variant of (:)
14:16:21 <tdammers> I think Aeson does something like that with its pair operator
14:17:34 <hodapp> looking at https://wiki.haskell.org/Heterogenous_collections and seeing if anything here is clean-ish
14:17:38 <worldsayshi> Dumb question: How do I interrupt the evaluation of a long/infinite evaluation in ghci without killing ghci altogether?
14:18:03 <worldsayshi> ctrl+c kills ghci for me
14:19:46 <EvanR> worldsayshi: thats a problem on windows
14:20:06 <worldsayshi> EvanR: Nope, os x
14:20:10 <EvanR> oh?
14:20:39 * ski would prefer `showsPrec p (MkShowable a) = showParen (p > 10) $ showString "MkShowable " . showsPrec 11 a'
14:20:39 <worldsayshi> So I take that to mean that it’s supposed to work then :)
14:20:59 <EvanR> what is the infinite computation i keep getting <<loop>> in my test
14:21:28 <worldsayshi> EvanR: Oh, it’s in cabal repl. Not ghci
14:21:45 <worldsayshi> I just run [1..]
14:21:50 <EvanR> oh cabal repl
14:22:40 <hodapp> hmm, having to use 'catMaybes' inside this is complicating things
14:23:55 <hodapp> in that I have a bunch 'Maybe a' items where 'a' varies but is always an instance of Foo, and how many 'b' items I end up with depends on which Maybes are Just rather than Nothing
14:25:13 <orzo> hodapp: could fmap them all to ()
14:25:36 <hodapp> orzo: I don't get what you mean
14:25:47 <orzo> well i probably don't get what you mean either
14:26:41 <orzo> 'a' varies, but you only care about the Just part, so i was thinking fmap the Maybe a to Maybe () for all (), now you can use catMaybes on a homogeneously typed list
14:26:51 <EvanR> hodapp: instance of class Foo?
14:26:58 <hodapp> EvanR: right
14:27:03 <EvanR> yurg
14:27:08 <hodapp> what?
14:27:27 <orzo> you can use existential quantification to create a type that hides the difference also
14:27:38 <hodapp> orzo: wouldn't mapping to () lose everything?
14:27:40 <EvanR> hodapp: well whats the problem with catmaybes
14:27:41 <worldsayshi> EvanR: Found an issue but it’s supposed to be fixed: https://github.com/haskell/cabal/issues/1448   - I’m using cabal 1.18.1
14:27:53 <EvanR> worldsayshi: try upgrading
14:27:53 <orzo> data FooThing = FooThing (Foo x => x)
14:27:57 <hodapp> EvanR: my list is not homogeneous
14:28:08 <orzo> that will let you form a list [FooThing]
14:28:16 <orzo> it's probably not really waht you wan tthough
14:28:29 <EvanR> hodapp: surely you want to do some homogeneous with it? preprocess it for that purpose
14:28:34 <EvanR> do something*
14:29:17 <hodapp> EvanR: the processing that turns it to a single type is not over Maybe, it's over the type inside of that
14:29:25 <EvanR> if you fmap . fmap it, youll be left with Maybe something that doesnt vary, and you can use catMaybes
14:29:37 <hodapp> :t (fmap . fmap)
14:29:38 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
14:30:29 <orzo> hodapp: how do you have this collection?  they can't alll be in a single list
14:30:41 <EvanR> you can always get around "i have a list of instances of Foo" by just using the Foo operation you want on that list
14:31:00 <EvanR> when constructing it
14:31:04 <voidzero> what does 'foo :: !String' mean?
14:31:04 <ski> EvanR : no
14:31:32 <orzo> voidzero: using datakinds?
14:31:36 <EvanR> no ?
14:31:51 <voidzero> just looking at some random code
14:31:52 <johnw> voidzero: it means that the record field is strict
14:32:09 <ski> EvanR : it depends on which operations `Foo' provide. in particular, how they use the tyvar (multiple times ? contravariantly ? inside type constructors, other than to the left of `->' ?)
14:32:12 <DanZimm> Hey guys - I'm attempting to learn some functional programming and so I came over to haskell; I ran into an issue that has confused me and I'm not sure how to fix
14:32:12 <hodapp> EvanR: it's technically a list of instances of Maybe Foo, to abuse notation.
14:32:40 <lpaste> DanZimm pasted “Num (Maybe a)” at http://lpaste.net/120233
14:32:43 <orzo> so Foo is a type?
14:32:46 <orzo> not a type class?
14:32:53 <ski> hodapp : `[Maybe (exists a. Foo a *> a)]' or perhaps `[exists a. Foo a *> Maybe a]', presumably
14:32:54 <hodapp> orzo: no, it's a type. I'm abusing notation.
14:33:05 <DanZimm> In that paste its giving me back a type of Num (Maybe a) and I don
14:33:09 <hodapp> orzo: sorry, type class.
14:33:18 <DanZimm> 't understand why - shouldn't it give back Maybe a?
14:33:21 <kadoban> hodapp: I kinda feel like everyone is giving the same answer, with some random other stuff thrown in. Can you show code, or an example or…something?
14:33:25 <EvanR> well im thoroughly confused
14:33:50 <orzo> hodapp: you cxan actually create [FooThing] where each FooThing has a differently typed argument to its constructor using the ExistentialQualification extension
14:34:06 <hodapp> orzo: that's one way I'm looking at, as the link I posted earlier had it
14:34:19 <ski> orzo : itym `data FooThing = forall x. Foo x => WrapFooThing x'
14:34:19 <DanZimm> erm rather here's the type sig: blah :: (Num (Maybe a), Fractional a, Eq a) => Maybe a
14:34:32 <DanZimm> so it has a typeclass of Num (Maybe a)
14:35:14 <voidzero> this is a laggy connection, got a lot of lines at once
14:35:18 <johnw> DanZimm: safeDivide type checks for me: https://gist.github.com/2bcbb6d290e719e83e1f
14:35:41 <voidzero> ok maybe I should ask..
14:35:46 <voidzero> :t !String
14:35:47 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
14:35:59 <horny-sama> https://github.com/mr-fool/haskell/blob/master/bmi/bmi.hs <---I suspect it is a spacing error
14:36:01 <horny-sama> any tips
14:36:02 <voidzero> no of course not, silly me
14:36:09 <mseeks> i'm writing a program that has handlers that return IO, and i want to write tests for the functions that call those handlers by switching out some stub handlers
14:36:11 <horny-sama> one sec
14:36:12 <horny-sama> typo
14:36:18 <mseeks> is this a typical way to test these kinds of things?
14:36:25 <mseeks> if so, what are some good ways to do it?
14:36:32 <johnw> mseeks: I'm afraid that 's not enough information to go on
14:36:42 <DanZimm> johnw: right, I get the same (I'm working in the interpreter - ghci) but when I apply it the type changes to have a type class of Num (Maybe a)
14:36:44 <johnw> "switching out"?  "these kinds of things"?
14:36:54 <horny-sama> https://github.com/mr-fool/haskell/blob/master/bmi/bmi.hs still error
14:36:56 <horny-sama> help help
14:37:18 <johnw> DanZimm: you mean, when you invoke it?  How are you invoking it?
14:37:23 <orzo> ski: is there a difference? is one syntax deprecated?
14:37:37 <DanZimm> johnw: `safeDivide 5 6`
14:37:56 <DanZimm> but even when I do `safeDivide 5` and partially apply it the type class changes
14:38:23 <Welkin> :t safeDivide
14:38:24 <lambdabot> Not in scope: ‘safeDivide’
14:38:44 <mseeks> let's say I have a function `f` that makes some structure T which it passes to a function `g :: T -> IO ()`, and in testing I want to replace `g` with my own function `h` which lets me test that `f` is calling `g` with the correct T's
14:39:13 <mseeks> or in general, just make sure that `f` is calling `g` with the correct T's somehow
14:39:53 <mseeks> hm maybe I can use monadic quickcheck for this
14:39:55 <kadoban> DanZimm: Your safeDivide is of type :: Maybe a -> Maybe a -> Maybe a though. So you need to wrap the arguments in Just. Or possibly you meant the type to be… :: a -> a -> Maybe a ?
14:40:01 <ski> orzo : `data FooThing = FooThing (Foo x => x)' does something else (though imho, it ought to be invalid or deprecated, unless `x' is already in scope)
14:40:33 <horny-sama> anyone here familiar with haskell?
14:40:35 <quchen> mseeks: If you're looking for mocking, I don't think that's available in Haskell. Your pieces to test should be so small you can test them individually most of the time.
14:41:30 <DanZimm> kadoban: aha! Thanks, silly me. Could you explain how the additional typeclass was inferred by ghci?
14:41:36 <horny-sama> anyone want to help me with haskell? https://github.com/mr-fool/haskell/blob/master/bmi/bmi.hs
14:41:56 <ski> orzo : `data FooThing = FooThing (Foo x => x)' is currently interpreted to mean `data FooThing = FooThing (forall x. Foo x => x)', which gives the type `(forall x. Foo x => x) -> FooThing' for the data constructor .. which is not what you/hodapp wanted
14:42:12 <lpaste> Hodapp pasted “No title” at http://lpaste.net/120234
14:42:12 <quchen> horny-sama: your bmi-tell function is just defined in the middle of a `do` block.
14:42:44 <horny-sama> quchen: you can't do that?
14:42:52 <hodapp> kadoban: what I just pasted is a similar example of what I'm talking about.
14:42:55 <mseeks> quchen: Ok, I'll do that then
14:42:57 <hodapp> EvanR: ^
14:43:19 <kadoban> DanZimm: It's…pretty extremely gross, but: When you have number literals in haskell, like 5, it basically automatically tries to convert them to any Num instance. Since your types are Maybe a, it assumed that there had to be a Num instance that it could convert it to, so it was assuming 5 :: Maybe a
14:43:50 <orzo> ski: so in other words, it would only accept polymorphic values (x :: Foo t => t) and not any more concrete arguments
14:43:59 <ski> yes
14:44:06 <EvanR> hodapp: looks pretty straighforward. just use catMaybes on [f x, f y, f z]
14:44:06 <ski> very different from existentials
14:44:07 <DanZimm> kadoban: aha makes sense, thanks!
14:44:10 <tommd> DanZimm: When you write `safeDivide 5` the `5` is a literal of type `Num b => b` while your first argument of safeDivide is of type `Maybe a`.  Unifying `b` and `Maybe a` we know we need an instance `Num (Maybe a)`.
14:44:14 <kadoban> DanZimm: …which, doesn't really make any sense, except to a computer. But it's kinda hard for the computer to figure that out :-/
14:44:14 <DanZimm> johnw: thanks for your attention too!
14:44:24 <quchen> horny-sama: No. There are only three things you can have in a `do` block: "let foo...", "p <- foo" and "foo".
14:44:25 <EvanR> hodapp: well f <$> x
14:44:34 <hodapp> where 'f' is what?
14:44:42 <DanZimm> tommd: right, definitely makes sense now, thanks!
14:44:50 <EvanR> hodapp: bar
14:44:53 <DanZimm> back to the world of haskell, ttyl
14:45:08 <tommd> Yay!
14:45:23 <hodapp> EvanR: 'bar' doesn't take Maybe.
14:45:33 <EvanR> hodapp: thats why you need bar <$> x
14:45:36 <horny-sama> quchen: https://github.com/mr-fool/haskell/blob/master/bmi/bmi.hs :<
14:46:46 <quchen> horny-sama: You have to declare the type and the value of that type inside the same "let".
14:46:52 <hodapp> EvanR: [bar <$> x, bar <$> y, bar <$> z] ?
14:46:58 <EvanR> yeah
14:47:19 <horny-sama> quchen?
14:47:23 <zyla> horny-sama: and the '|'s should be indented more than "bmiTell".
14:47:24 <quchen> horny-sama: You can have multiple declarations inside a single "let", by the way.
14:47:30 <orzo> would it be ambiguous to have an extension that would let us declare little where clauses on arbitrary expressions, like (f x where x=3) ?
14:48:06 <hodapp> EvanR: ahhh, okay, that seems to work!
14:48:20 <orzo> i find where to be overly limitted compared to let
14:48:36 <EvanR> hodapp: this kind of thing, where you use the typeclass before making the list is what i was getting at earlier. i guess it wont always work though
14:48:55 <hodapp> EvanR: I was getting two things at once about fmap and it didn't make sense in total
14:49:00 <ski> orzo : btw, do you know that you can attach `where' to `case' branches ?
14:49:18 <horny-sama> zyla: quchen: https://github.com/mr-fool/haskell/blob/master/bmi/bmi.hs still blow up on me
14:49:27 <orzo> ski: is that new?
14:49:28 * horny-sama 's face is burning
14:49:48 <ski> orzo : no. old
14:50:04 <quchen> horny-sama: (^) is integral power. You're looking for (**) here, I think.
14:50:07 <quchen> :t (^)
14:50:08 <lambdabot> (Num a, Integral b) => a -> b -> a
14:50:08 <quchen> :t (**)
14:50:09 <lambdabot> Floating a => a -> a -> a
14:50:17 <ski> @type (^^)
14:50:18 <monochrom> orzo: it would be ambiguous, it doesn't fit nicely with current Haskell syntax. unless you say, the extension not only adds what you said, but also takes away the existing rule for "where".
14:50:18 <lambdabot> (Integral b, Fractional a) => a -> b -> a
14:50:22 <hodapp> so, in this case, I suppose I could do (bar . fmap) and just assign that to something less ugly
14:50:42 <ski> monochrom : in that case it wouldn't scope over guards
14:50:55 * hackagebot GeBoP 1.7.4.1 - Several games  http://hackage.haskell.org/package/GeBoP-1.7.4.1 (HenkJanVanTuyl)
14:50:59 <EvanR> hodapp: i think bar <$> whatever is more idiomatic, showing that its not being applied directly but through some functor action
14:51:18 <zyla> horny-sama: also, I'd rather define "bmiTell" at toplevel
14:51:27 <horny-sama> zyla: fpaste?
14:52:37 <killerstorm> hi. I'm working on a combinator library for Bitcoin-style smart contracts. if anybody is interested to review work-in-progress please PM me.
14:53:15 <zyla> horny-sama: just don't put it inside main
14:53:21 <monochrom> ski: perhaps then it becomes not an extension, but a restriction :)
14:53:31 <horny-sama> zyla: the entire function?
14:53:48 <monochrom> -RExpressionistWhere
14:54:03 <monochrom> because -R stands for "restriction"
14:54:48 <horny-sama> zyla: still fail
14:55:03 <ski> monochrom : in the ambiguous case, you could go for the more general one ..
14:55:23 <horny-sama> zyla, quchen https://github.com/mr-fool/haskell/blob/master/bmi/bmi.hs
14:55:29 <horny-sama> my face continues to burn
14:55:30 <horny-sama> :<
14:55:38 * ski never considered `X' to stand for "extension"
14:56:18 <quchen> horny-sama: bmi-tell calculates a "String" result, but since you're in the "main" "do" block it expects an IO action.
14:56:22 <orzo> well maybe we can fit it in somehow without restricting, suppose the expressin form must start with 'do' so (do f x where x = 3) it'd also be the same do for monad syntax, because i don't find the current where limitting except when i use do blocks
14:56:42 <quchen> ski: "Mysterious stuff is going to happen"? :L
14:57:28 <horny-sama> quchen: bmiTell :: (RealFloat a) => a -> a -> IO String  does not help :<
14:58:29 <quchen> Right, because whatever bmiTell calculates, it's not an "IO String".
14:58:50 <quchen> You should try to find a conversion function from the "bmiTell" result to "IO something".
14:59:53 <horny-sama> quchen: any more tips?
15:01:20 <quchen> :t print
15:01:22 <lambdabot> Show a => a -> IO ()
15:01:27 <kadoban> horny-sama: What is the type of line 25? What is the type of line 12? What is the type of the part of line 12 after putStrLn ?
15:01:36 <P4Titan> Hello all, I am tring to use runhaskell. How can I execute a project with multiple files?
15:01:59 <quchen> P4Titan: runhaskell Main.hs?
15:02:03 <monochrom> simply use runhaskell on the file that has your main.
15:02:17 <P4Titan> yes, so how do I include the other files though?
15:02:29 <kadoban> P4Titan: import ?
15:02:35 <horny-sama> kadoban: 12 is io string
15:02:41 <monochrom> if that file already imports stuff, they are honoured.
15:02:45 <P4Titan> Ok, I'll explain what I have now
15:02:53 <quchen> > 12 :: IO String -- I don't think so
15:02:55 <lambdabot>  No instance for (GHC.Num.Num (GHC.Types.IO GHC.Base.String))
15:02:56 <lambdabot>    arising from the literal ‘12’
15:02:59 <monochrom> if that file doesn't import stuff, then they aren't needed
15:03:08 <ski> quchen : heh
15:03:09 <orzo> -idir1:dir2:... add dir, dir2, etc. to import path
15:03:26 <horny-sama> have to grab food
15:03:33 <horny-sama> cya nerds later
15:03:34 <horny-sama> lol
15:03:48 <kadoban> horny-sama: Close, but not exactly. But hopefully those will guide you to an answer.
15:03:56 <P4Titan> I have 2 files so far, one with the main and another that has functions and stuff. I want to access the functions from that file in the main file. What I did is module Utils where ... in the file with the functions and stuff and import Utils in the main file
15:04:34 <orzo> P4Titan: and both files are in the same directory?  And putting "import Utils" at the top of main doesn't work?
15:04:39 <P4Titan> yes
15:04:47 <kadoban> P4Titan: Did you name the utils-function-file Utils.hs ?
15:04:50 <P4Titan> Could not find module `Utils'
15:05:00 <P4Titan> no, I named it utils.hs
15:05:10 <orzo> that's probably the issue
15:05:30 <monochrom> Util.hs . no compromise. not negotiable
15:05:38 <P4Titan> I'll rename it then and try again, also is there a way to have the module a lowercase?
15:05:44 <Denommus> hi
15:05:45 <monochrom> no
15:05:54 <kadoban> P4Titan: I don't believe so. Even if you could, don't…it'd be very confusing.
15:06:17 <quchen> CPP! :-D
15:06:25 * quchen shows himself out
15:06:32 <P4Titan> Ok, it works! Thanks for the help
15:07:18 <kadoban> Cool
15:10:17 <ReinH> monochrom: but maaaaaaybe?
15:11:08 <monochrom> you could offer a bounty on "modify GHC or Hugs to do that"
15:12:28 <orzo> people still use Hugs?
15:15:00 <monochrom> I haven't used Hugs for a while. but between "modify GHC" and "modify Hugs", I'm sure which one you would choose.
15:17:27 <orzo> ghc of course, it's very simple after all: http://jerkface.net/~joe/ghc.tred.svg
15:17:32 <kadoban> It seems a bit worrisome that almost nobody uses anything except GHC. I wonder if that'll change at some point in the near future.
15:18:25 <voidzero> there also is UHC
15:18:29 <voidzero> dunno what state it is in
15:18:39 <lpaste> LordBrain pasted “alex syntax error” at http://lpaste.net/120237
15:19:15 <orzo> why is it worrisome?
15:19:18 <LordBrain> Anyone good wiht alex? i am not, so this might be simple
15:19:40 <orzo> the error message is not in that paste
15:20:23 <LordBrain> I get a syntax error on this line: ($u # (\^ | \- | $d | \()) ($u # (\^ | \( | \))| \.)+ { tok (\p s -> PT p (eitherResIdent (T_MSymbolToken . share) s)) }
15:20:29 <LordBrain> at the \^
15:21:13 <orzo> kadoban: why is it worrisome if everyone uses ghc?
15:21:13 <LordBrain> its line 32 or there abouts
15:22:04 <kadoban> orzo: Just seems like a language with multiple viable implementations is in better general health than one without.
15:22:06 <xpika> is there any alternative to puppet written in haskell ?
15:22:36 <LordBrain> I'd be down with a project to make  a new implementation.
15:23:13 <LordBrain> Does anybody know how to use alex?
15:23:52 <josephle> kadoban, didn't C only relatively recently get a second viable implementation?
15:23:57 <josephle> clang isn't all that old compared to gcc
15:24:19 <kadoban> josephle: I /highly/ doubt it. One of C's big strengths is that you can implement it for a soup can in an afternoon.
15:24:21 <xpika> josephle: how about visual studio ?
15:24:26 <orzo> kadoban: I don't think i share your intuition on that
15:24:53 <josephle> xpika: that is true, so I guess we had 2 for a while. this particular objection is withdrawn
15:25:16 <Denommus> kadoban: lots of successful languages have a single viable implementation
15:25:28 <josephle> kadoban, being able to implement the language does not make the implementation viable.
15:25:39 <kadoban> Denommus: Really? All I can think of is Perl, and I'm not even sure that's correct.
15:25:58 <xpika> orzo: 1 set of implementors could become complacent. A bit of competition can help there.
15:26:03 <orzo> kadoban: in fact, i suspect it might be somewhat opposite: a single dominant implementation is linked with success
15:26:18 <LordBrain> there is jhc.. not sure how active John is
15:26:30 <saurik> win 176
15:26:37 <Denommus> kadoban: Python, C#, Go, OCaml
15:26:44 <kadoban> orzo: Well, most I can think of have a dominant one, and then several others.
15:26:55 <xpika> yhc and hugs but haskell is so dominant
15:27:05 <kadoban> Denommus: Python has like, at least three. cPython, pypy and ipython? or whatever that one is called.
15:27:07 <josephle> CPython, mono, ... and the other two probably have single implementations
15:27:07 <xpika> ghc *
15:27:19 <Denommus> kadoban: you're right, I forgot about PyPy
15:27:26 <Denommus> kadoban: but there's still the three others :P
15:27:40 <josephle> does mono not count for C#?
15:27:42 <kadoban> C#, yeah does mono count? It can't be using the same toolchain as microsoft is
15:27:50 <_um> fwiw, Prolog has a bazillion implementations--but that doesn't seem to have any effect on it's being successful, popular, or widely used.
15:27:57 <Denommus> josephle: now that .NET is open source mono will mostly work together with the main implementation
15:27:58 <_um> s/it's/its
15:28:01 <LordBrain> microsoft hired the mono people i think
15:28:09 <kadoban> Go is pretty new so that's not terribly surprising to me, and OCaml…I just don't know.
15:28:15 <orzo> kadaban, when i used python, i wanted to use some non-mainline pythons but they always lagged too far behind the mainline one.  Seems analagous to wha twe have
15:28:26 <Denommus> there's more, if you want
15:28:29 <josephle> Denommus, hey, no fair using a hypothetical merger between 2 implementations! :P
15:28:49 <josephle> hmmm
15:28:51 <kadoban> orzo: That's somewhat possible. I think pypy is pretty decent though, as far as I know.
15:28:52 <josephle> objective-C?
15:28:58 <josephle> that's still Apple only right?
15:29:03 <Denommus> and Swift, and Clojure, and Scala
15:29:09 <xpika> someone is writing a tutorial on writing a haskell compiler http://dev.stephendiehl.com/fun/index.html
15:29:21 <Denommus> (ok, Clojure has ClojureScript, but they fill completely different roles, much like GHC and Haste)
15:29:31 <josephle> debatable whether or not Swift is a healthy language yet (same for rust)
15:29:35 <EvanR> to implement haskell you must first implement haskell
15:29:42 <Denommus> Swift is growing like mad
15:30:08 <josephle> I mean, in the context of kadoban's claim
15:30:16 <josephle> we probably want languages with lasting growth
15:30:32 <josephle> swift and rust are simply too young for us to know
15:30:50 <orzo> hm, a good test for an indpendne thaskell compiler would be if it could compile ghc
15:30:52 <Denommus> I have not cited Rust
15:31:05 <josephle> I know, I'm just preempting any mention of Rust P
15:31:07 <josephle> *:P
15:32:09 <hodapp> EvanR: yeah, not sure why fmap wasn't apparent there... I need to be more familiar with this applicative stuff
15:32:52 <reem> fwiw rust cannot be implemented for a soup can in an afternoon ;)
15:33:04 <hodapp> reem: whaaa?
15:33:19 <reem> I'm referring to what kadoban said about C earlier
15:33:23 <reem> that it's easy to implement
15:33:29 <EvanR> yeah rust takes a few days to form on a can
15:33:33 <reem> (which is separately debatable)
15:33:35 <kadoban> ;)
15:33:41 <Denommus> doesn't R also have a single implementation?
15:33:44 <hodapp> There's a reason "As easy as a compiler" is not an expression
15:34:09 <josephle> the wolfram language!
15:34:28 <orzo> scheme cultivated a great many implementations and then slowly brought them together with the srfi process
15:34:43 <hiptobecubic> javascript has a lots of implementations :)
15:34:43 <Denommus> I wouldn't consider the wolfram language to be successful
15:34:46 <hiptobecubic> has a lot*
15:34:51 <hiptobecubic> All of them stellar
15:35:01 <Denommus> that reminds me of Lua
15:35:01 <orzo> do you consider scheme more successful than haskell?
15:35:19 <Welkin> scheme is a great teaching language
15:35:23 <hodapp> if a minimalist scripting language that integrates trivially with C is what you need, Lua delivers
15:35:33 <orzo> heh
15:35:33 <Welkin> (typed) racket looks very nice
15:35:38 <Hijiri> I was confused by the STG paper until I realized that \something {} meant a lambda with no args
15:35:49 <EvanR> programming in lua hurts
15:35:54 <Hijiri> is that just a thing to turn everything into lambdas?
15:35:54 <orzo> i hate lua as i was forced to config with it when i used the ion desktop
15:35:59 <hodapp> lua is..... lua
15:36:05 <Denommus> lua is just a saner JavaScript
15:36:09 <Hijiri> I knew a bit of lua
15:36:12 <Hijiri> because I played roblox
15:36:19 <hodapp> Denommus: why's it saner?
15:36:21 <kadoban> It's kind of a…far more boring javascript.
15:36:34 <Denommus> hodapp: the comparison operator makes more sense, and no undefined vs nil madness
15:36:41 <EvanR> Denommus: except you can chain map group by etc stuff in javascript, and not in lua. which has no composability
15:36:43 <reem> null*
15:36:57 <Denommus> it's nil in Lua
15:37:19 <Denommus> EvanR: hm?
15:37:21 <hodapp> EvanR: one cannot compose in Lua?
15:37:28 <Welkin> why do many langages  have their reference implementation in C rather than being written in itself and bootstrapped from assembly?
15:37:28 <EvanR> its not pleasant
15:37:39 <EvanR> lua emphasizes heavily the iterators, which dont compose
15:37:48 <orzo> Welkin: why would it be done that way?
15:38:05 <Denommus> EvanR: Lua doesn't have the same standard library from JS because it's a minimal language, but you can implement anything from JS's standard library on it
15:38:05 <kadoban> There's extremely little to lua. You can't do very much. It only has like, "tables" for a data structure too, which is pretty annoying out-of-the-box.
15:38:15 <reem> EvanR: Well, most of it is provided by libs. Some of the methods have finally made it to Array.prototype, but not the majority.
15:38:22 <orzo> Welkin: assembly isn't portable and is a bit more onerous than C.  So why would you do that?
15:38:24 <hodapp> Welkin: well, Lua is written in C partly to make it really easy to integrate with C APIs
15:38:42 <Welkin> orzo: C isn't portable either
15:38:52 <Welkin> there are always platform specific parts of your code
15:38:59 <Welkin> you are running on physical hardware afterall
15:39:05 <Welkin> not magic
15:39:15 <Denommus> Welkin: I have written plenty of portable C code
15:39:16 <hodapp> that's.... not really accurate, unless you're talking OS kernels
15:39:24 <EvanR> Welkin stop ruining the dream of abstract reasoning
15:39:30 <orzo> only windows coders have trouble writing portable c
15:39:33 <orzo> heh
15:39:55 <EvanR> C was an upgrade from B in the sense of having a standard IO library
15:40:04 <EvanR> which the implementation was obliged to provide somehow
15:40:19 <kadoban> Welkin: It's /far/ more portable than assembly at least. Assembly is about as unportable as it's possible to be, and it's really painful to do much of anything in.
15:40:49 <orzo> kadoban: you say that, but emulators proliferate...
15:41:15 <EvanR> kadoban: oh ho but what about http://www.menuetos.net/
15:41:33 <EvanR> all the apps are in assembly because its so pleasant!
15:41:53 <orzo> probably 6502 code is more portable than jvm
15:42:02 <Denommus> I wish Facebook hired me to work with Haskell :-(
15:42:06 <kadoban> orzo: Like, emulators for game consoles? Yeah, that's not really what portability usually means, hehe. That's just, out of necessity, because they have no other choice if they want to play NES games on X.
15:42:10 <kadoban> EvanR: Oh god…
15:42:13 <hodapp> Denommus: did they make you do OCaml instead?
15:42:22 <hodapp> EvanR: The idea of MenuetOS is neat. I'm not sure how lovely the reality of it is.
15:42:30 <arw_> EvanR: thats more the mount everest of coding. you go up there on foot, because using a helicopter would be uncool...
15:42:35 * ashfall waves at shapr
15:42:59 <EvanR> hodapp: well, from what i see, they have some sort of library set up to make programming even remotely possible, but you use it via simple register moves
15:43:00 <Sornaensis> > (\enumLetter charNumber m k -> (\message key cipher -> map charNumber (cipher message key)) (map enumLetter m) (map enumLetter . take (length m) $ cycle k) (fix (\cf ms ks -> if null ms || null ks then [] else ((head ms) + (head ks)) `mod` 26 : cf (tail ms) (tail ks))) ) (\x -> fromJust $ elemIndex x ['A'..'Z']) (\x -> ['A'..'Z'] !! x) "MESSAGE" "KEY"
15:43:02 <lambdabot>  "WIQCEEO"
15:43:02 <kadoban> EvanR: That's actually quite ridiculously impressive.
15:43:05 <Denommus> hodapp: they didn't hire me
15:43:06 <Sornaensis> thanks
15:43:25 <Denommus> hodapp: I should have said "would hire me", right?
15:43:31 <orzo> it would be interesting to know for sure which has more coverage, jvm bytecode or 6502 machine code
15:44:09 <ski> EvanR : if only it wasn't x86 ..
15:44:31 <kadoban> ski: Hah
15:44:34 <EvanR> i think practically you have to use x64
15:44:47 <EvanR> no one likes x86
15:45:00 <orzo> what's wrong with x86
15:45:19 <EvanR> the api is awful
15:45:26 <kadoban> orzo: Have you ever coded in it? It's…/really/ awful.
15:45:34 <orzo> i coded in 8086
15:45:38 <orzo> back in the day
15:45:50 <orzo> not sure if that counts anymore
15:45:57 <kadoban> orzo: It got worse and more cludgey as time went on.
15:46:03 <kadoban> orzo: But I guess it counts.
15:46:06 * ski . o O ( x64 <http://vice-emu.sourceforge.net/vice_8.html#SEC203> )
15:46:37 <ski> orzo : 680x0 is much more pleasant
15:46:52 <Welkin> oh
15:47:05 <Welkin> there was some tutorial on how to write a gameboy emulator in x86
15:47:16 <kadoban> I remember we did MIPS assembly in school, and it was like a breath of fresh air in comparison. Of course now I remember very little of either probably…
15:47:18 <Welkin> I almost forgot about it -- I'll have to read that
15:47:28 <Welkin> MIPS is common in school curriculum
15:47:38 <Welkin> I used Motorola myself
15:47:52 <orzo> i used to have my own 8086 assembler
15:48:15 <orzo> it was lost to a hard drive disaster
15:48:18 <orzo> heh
15:48:36 <orzo> it was written in 8086 assembler
15:48:47 <orzo> so there you go, kadoban
15:48:52 <kadoban> Nice :)
15:49:17 <monochrom> that is an accomplishment :)
15:50:25 <EvanR> arw_: yeah that one guy did use a helicopter, im sure he was ridiculed despite saving a few guys on the way down
15:50:26 * ski remember writing a "sink ships" in 6502, parallel to a Java laboration
15:50:49 <orzo> monochrom: yeah it was a bad day when i lost it
15:50:55 <orzo> oops
15:50:58 <kadoban> I also did some itanium assembly too I guess. I remember that being pretty fun, comparatively. Except it's extremely close to useless knowledge…
15:52:35 <codygman> What does Text refer to in a PostgreSQL create table function when using posgreSQL-simple? Context, trying to recreate database accepting these book data types: https://github.com/alpmestan/servant/blob/new-impl/docs/getting-started/getting-started.md#book-data-type
15:52:50 * ski . o O ( <https://en.wikipedia.org/wiki/High_Level_Assembly> )
15:53:18 <kadoban> codygman: Presumably Data.Text ?
15:54:22 <codygman> kadoban: I know that, I mean how do I create the database that accepts a Data.Text field. I initially thought `varchar not null`.
15:54:55 <EvanR> string not null
15:54:59 <EvanR> postgres thx
15:58:30 <Lokathor> say I've got a function, demux :: Bool -> Bool -> (Bool,Bool)
15:59:10 <Lokathor> how might one "chain" such a function to take a list of selection bools and then call demux several times?
15:59:28 <Lokathor> i'm confusing myself trying to figure out how you recursively call things that return tuples
16:00:17 <Lokathor> in other words, i'm looking for the "smart" version of dmux4way :: Signal -> [Signal] -> (Signal,Signal,Signal,Signal)
16:00:44 <Lokathor> instead of just assigning each output bit individually
16:01:38 <kadoban> Lokathor: I don't really understand what that function means. Does it just convert a list of 4 items to a tuple? Or three and the other one gets added on?
16:01:47 <EvanR> exploding Bits values into list of Bools?
16:02:33 <Lokathor> well, the "base case" is an input, a select, and two outputs. the first output is the input when the selection is 0, the sectond bit is the output when the selection is 1
16:02:45 <Lokathor> the not-selected output is always 0
16:03:09 <Lokathor> so you can of course do this 4 ways with 2 bits of selection, and 8 ways with 3 bits, etc
16:03:29 <Lokathor> i'm wondering if this can be generalized, or must be rewritten each time you want to scale up
16:03:36 <EvanR> you are doing an AND with a bit?
16:04:05 <Lokathor> yeah kinda
16:04:18 <EvanR> > (1234 :: Integer) .&. 1
16:04:19 <lambdabot>  0
16:04:21 <EvanR> > (1234 :: Integer) .&. 2
16:04:22 <lambdabot>  2
16:04:45 <EvanR> Integer is a finite stream of bits ;)
16:05:40 <Lokathor> well i mean i've got all the bitwise operators of course
16:06:12 <Lokathor> uhm, demuxing is not quite the same
16:06:42 <Lokathor> i'm probably not explaining this well
16:06:57 <EvanR> ANDing by a bit results in a signal of all zeros and possibly one one
16:07:26 <ski> why is the select a list ?
16:08:50 <Lokathor> ski, I was using tuples at first, but i started moving to lists once the length for them got up to 8
16:09:13 <ski> ok
16:09:27 <Lokathor> or8way, and16, etc all have very ugly type signatures if you're using tuples
16:09:36 <ski> Lokathor : have you checked out Lava ?
16:09:40 <Lokathor> though i agree that they'd be more accurate
16:09:47 <Lokathor> i have not checked out lava
16:09:59 <ski> they might have something you could snarf
16:10:32 <Lokathor> ah, yes, this is exactly the sort of thing i'm doing
16:10:58 <Lokathor> but i want to write it out, not just use a library.
16:11:57 <Lokathor> ah, yes, they've got "select :: [Bit] -> [[Bit]] -> [Bit]"
16:12:32 <Lokathor> which is what i'm trying to build... of course they return a [bit] instead of a (bit,bit), which is probably the secret
16:15:14 <EvanR> Lokathor: what would the point of (Bit,Bit) be?
16:16:00 <Lokathor> well the output is two bits, one is the input and one is off, depending on what the selection value is
16:16:13 <Lokathor> so i wrote (,) instead of [] "just because" i suppose
16:16:39 <Lokathor> and now in retrospect i can see that that was a bit of an error causing me a lot of trouble
16:21:58 <asdaoisj> If liftM2 is used here: http://lpaste.net/120240 shouldnt the signature of the function have a monadic return type?
16:22:22 <asdaoisj> :t lifM2 (==)
16:22:23 <lambdabot>     Not in scope: ‘lifM2’
16:22:23 <lambdabot>     Perhaps you meant ‘liftM2’ (imported from Control.Monad.Writer)
16:22:31 <asdaoisj> :t Control.Monad.lifM2 (==)
16:22:32 <lambdabot>     Not in scope: ‘Control.Monad.lifM2’
16:22:32 <lambdabot>     Perhaps you meant one of these:
16:22:32 <lambdabot>       ‘Control.Monad.liftM2’ (imported from Control.Monad),
16:22:41 <Lokathor> :t liftM2 (==)
16:22:41 <asdaoisj> :t Control.Monad.liftM2 (==)
16:22:42 <lambdabot> (Monad m, Eq a2) => m a2 -> m a2 -> m Bool
16:22:42 <lambdabot> (Monad m, Eq a2) => m a2 -> m a2 -> m Bool
16:22:50 <Brandon`> asdaoisj no
16:22:56 <asdaoisj> :t liftM2 (==) id
16:22:57 <lambdabot> Eq a => (a -> a) -> a -> Bool
16:22:59 <glguy> asdaoisj: It does.  ((->) [a])   is the 'm' in liftM2's type
16:23:53 <asdaoisj> oh right
16:24:36 <glguy> in this case you can continue to obfuscate things with: ap (==) return    using that same Monad instance
16:24:52 <kadoban> :t ap (==) return
16:24:54 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ m0 a
16:24:54 <lambdabot>     Expected type: a -> a
16:24:54 <lambdabot>       Actual type: a -> m0 a
16:24:54 <glguy> errr, ap (==) reverse
16:24:55 <kaiyin> some people say that idomatic ocaml is faster than idiomatic haskell, to what extent is this claim true?
16:24:58 <asdaoisj> uh
16:25:00 <kadoban> Oh, duh
16:25:08 <asdaoisj> glguy: i can barelly understand it right now lol
16:25:25 <asdaoisj> i dont even know what you're talking about
16:25:34 <asdaoisj> :t ap
16:25:35 <lambdabot> Monad m => m (a -> b) -> m a -> m b
16:26:20 <glguy> pick m to be ([a] -> _)  -- making up a bit of syntax there, but it's a little clearer, and you get:
16:26:25 <kadoban> asdaoisj: It's basically stupid-monad-tricks, not really something that I would consider important to understand on its own. If you study typeclassopedia for a while, it should make slightly more sense eventually.
16:27:02 <voidzero> :t ap (==) reverse
16:27:03 <lambdabot> Eq a => [a] -> Bool
16:27:15 <asdaoisj> kadoban: im trying to understand how ((->) a) monads work
16:27:25 <glguy> ([x] -> a -> b) -> ([x] -> a) -> b
16:27:29 <ski> asdaoisj : do you understand `Reader r' ?
16:27:47 <glguy> (I changed the list to use 'x' so I wouldn't have to rename the a and b from the type)
16:27:47 <asdaoisj> ski: no - i think its the same?
16:28:11 <ski> asdaoisj : are you familiar with environment variables, as related to OS processes ?
16:28:21 <asdaoisj> ski: yeah
16:28:39 <Lokathor> is the (->) pronounced "arrow"? or are just "arrows" called arrow and (->) is called something else?
16:28:48 <voidzero> I call it "to"
16:29:03 <asdaoisj> how could you describe the Reader bind implementation in regular english?
16:29:10 <voidzero> because Arrow is also a class, similar to Monad
16:29:24 <Lokathor> ..makes sence i suppose, since that's how you'd say a type signature after all
16:29:36 <kadoban> Lokathor: Arrow is kind of a generalization of (->), as far as I understand. (->) is an instance of Arrow.
16:29:37 <ski> asdaoisj : environment/reader is about distributing an "environment"/"configuration" "down" to all parts (there is no communication back up). one part receiving it may *locally* change it, before passing it on down to children spawned by it
16:30:15 <voidzero> it is?
16:30:18 <voidzero> :t (->)
16:30:19 <lambdabot> parse error on input ‘->’
16:30:24 <ski> asdaoisj : to a first approximation, you can think of it as "read-only state" (if you know about state monads)
16:30:57 <voidzero> or does Control.Arrow redefine -> ?
16:31:10 <lpaste> Lokathor pasted “demux” at http://lpaste.net/120241
16:31:45 <Lokathor> EvanR, http://lpaste.net/120241 explains a little more about what i was trying to do, and why it seemed sane *to start off with* to have the return type be a tuple
16:32:02 <voidzero> > :info (->)
16:32:03 <lambdabot>  <hint>:1:1: parse error on input ‘:’
16:32:04 <voidzero> data (->) a b   -- Defined in ‘GHC.Prim’
16:32:06 <voidzero> instance Monad ((->) r) -- Defined in ‘GHC.Base’
16:32:08 <voidzero> instance Functor ((->) r) -- Defined in ‘GHC.Base’
16:32:26 <ski> asdaoisj : "how could you describe the Reader bind implementation in regular english?" -- first accept the environment passed to the current `ma >>= amb' computation. then pass it to the `ma' subcomputation, and extract an answer `a'. pass `a' to `amb', getting a new subcomputation, call it `mb'. then pass the environment to `mb', and return as answer from `ma >>= amb' whatever answer `mb' returns
16:32:42 <asdaoisj> ski: so when I lift a function to reader/function monad and apply it to a parameter that parameter will be 'given' to all the reader monad params?
16:32:50 <ski> asdaoisj : in short : distribute down the environment, passing the answer from the first subcomputation to the second
16:32:51 <kadoban> :k (->)
16:32:52 <lambdabot> * -> * -> *
16:33:20 <ski> asdaoisj : i'd prefer not using the term "function monad". "environment monad" or "reader monad" is ok
16:33:53 <kadoban> voidzero: It uses the normal definition. (->) is on a different…level than :t expects. It constructs types.
16:33:58 <ski> asdaoisj : i'm not sure what you mean by "the reader monad params"
16:34:28 <lpaste> kadoban pasted “(->) Arrow instance” at http://lpaste.net/120242
16:34:30 <asdaoisj> ski: can you chaing multiple monads with bind like that if they are Reader (a -> b) ? Since you cant typically do (a -> b) . (a -> b) ?
16:34:46 <kadoban> voidzero: That's the bit of Control.Arrow that gives it an Arrow instance, if that somehow helps.
16:34:46 <ski> asdaoisj : the reader/environment monad is `Reader r' (or `(r ->)'). the only parameter it accepts is a type, say `a', "computing" the final type `Reader r a' (or `r -> a')
16:34:53 <voidzero> yeah. I realised a second too late. Which is one second less than the previous time. Progress. :)
16:35:09 <ski> asdaoisj : i don't understand
16:35:24 <asdaoisj> ski: what do you mean computing a type?
16:35:49 <voidzero> kadoban, yeah that does help, and it also makes Arrow more interesting (or me more curious about it actually)
16:36:34 <voidzero> and something I need to stare at
16:37:16 <kadoban> voidzero: I've read about it a few times…I still haven't gone beyond the point of "An Arrow is (->), which you can use for some neat higher-order-functions" though, which is clearly far from the whole story, heh.
16:37:46 <kadoban> So I really just use it for dumb tricks on tuples and Eithers and stuff…
16:39:58 <voidzero> kadoban, the only thing that stuck with me so far is, "If you don't exactly need a Monad, maybe Arrow is the thing for you"
16:40:11 <asdaoisj> ski: when you chain reader monads with >>= they don't actually get evaluated until the whole thing is applied to a value?
16:40:33 <asdaoisj> and thats when haskell 'computes' the type through type inference?
16:40:40 <voidzero> and I decided to deem myself not fit to make these decisions yet :)
16:41:04 <kadoban> voidzero: Heh, yeah I dunno. To me that sounds like Applicative, but maybe it's both.
16:41:43 <Cale> I think probably the right thing to do in most cases is just to be informed about the various library abstractions, but not to try to force your library to fit any one of them.
16:42:06 <Cale> Figure out which operations you'd like to support, and then see if that implies that it should be a Monad or Applicative or Arrow etc.
16:42:34 <ski> asdaoisj : when you write `Maybe Int', you can think of this as passing the `Int' type as argument to the `Maybe' type function, and that it returns the type of values which either contains one `Int', or none
16:42:40 <voidzero> Cale, yeah
16:42:51 <voidzero> maybe it will help if I just stare at this for a while
16:42:53 <voidzero> https://i.stack.imgur.com/auyOf.png
16:43:13 <ski> asdaoisj : if you consider the definition `type ReadS a = String -> [(a,String)]', then you can think of `ReadS Int' as returning the type `String -> [(Int,String)]'
16:43:59 <ski> asdaoisj : the type expression `Maybe Int' doesn't really return anything other than "itself". compare with how `Just 3' doesn't really compute anything else, it just is
16:44:54 <asdaoisj> yeah i get that ski
16:46:49 <Brandon`> is there a function like this already? ifM :: Monad m => m Bool -> a -> a -> m a
16:47:39 <asdaoisj> ski: so my question was - the Reader monad itself does not contain an environment... it gets applied to an environment... ?
16:47:56 <Brandon`> and should I make that ifM :: Monad m => m Bool -> m a -> m a -> m a  instead?
16:48:24 <pavonia> If I have a record data type with several fields, is there a way to define an Ord instance that first compares field x, if they are equal field y, then field z and so on, without having to use lots of nested cases?
16:48:50 <pavonia> Brandon`: Thare's the cond package
16:49:38 <Brandon`> I am curoius why they made it with the second signature and not the first one
16:49:39 <asdaoisj> and because it has type (a -> *) - passing a value to a reader monad is the same as applying the reader to an environment?
16:50:17 <shachaf> What ended up happening with http://www2.berkeley.intel-research.net/~rennals/pubs/talk_opt.pdf ?
16:50:58 <shachaf> Apparently it was in GHC CVS one, so maybe I should ask in #ghc
16:51:42 <Sornaensis> > sum [1..]
16:51:54 <lambdabot>  mueval: signalProcess: permission denied (Operation not permitted)
16:51:54 <lambdabot>  mueval-core: Time limit exceeded
16:52:02 <Sornaensis> > product [1..]
16:52:13 <lambdabot>  mueval: signalProcess: permission denied (Operation not permitted)
16:52:13 <lambdabot>  mueval-core: Time limit exceeded
16:55:55 <voidzero> SUM ALL THE THINGS!!!
16:56:02 * hackagebot yesod-purescript 0.0.4.5 - PureScript integration for Yesod  http://hackage.haskell.org/package/yesod-purescript-0.0.4.5 (mp)
16:56:13 <voidzero> np, i'll wait.
16:58:03 <Cale> voidzero: Well, apart from staring at the diagram, just using lots of examples of these eventually you start to get a feel for what sorts of things fit into each abstraction.
16:59:00 <Cale> I think the whole Arrow side of things needs reworking eventually before it'll really be popular though. The way that Arrow is laid out right now undermines a lot of the potential uses the abstraction has.
17:00:41 <Cale> (especially the required heavy use of arr in order to wire the results of arrow computations to where they're needed, because there's no primitive combinators for reassociating/swapping pairs and introducing/removing units)
17:01:41 <voidzero> it's something for later, but definitely on my list of things to learn
17:02:08 <voidzero> https://www.haskell.org/arrows/ has some nice diagrams
17:02:48 <voidzero> and refers to PDFs, probably nice bed time material hehe
17:03:03 <voidzero> sure beats RFCs
17:03:48 <Welkin> I always love reading about haskell in bed
17:04:07 <Welkin> and yes, that arrow page is great
17:04:52 <Welkin> I remember when LYAH was my bedtime reading
17:04:59 <Welkin> that was always fun
17:05:12 <Welkin> now it's PArallel and Concurrent Haskell
17:05:22 <voidzero> ha. Same here.
17:06:33 <voidzero> plus that thing where the brain is autonomously visualising Haskell concepts
17:06:49 <Welkin> I remember when I would dream about programming in Haskell
17:07:00 <Welkin> that was a trip, back when I first started learning it
17:07:19 <Welkin> I had nightmares about folds
17:07:55 <voidzero> and suddenly maths became exciting.. :)
17:08:22 <dibblego> profunctor almost subsumes arrow
17:08:39 <geekosaur> dreams of endless running from zygohistomorphic prepromorphisms :p
17:08:42 <voidzero> folds lol
17:09:10 * EvanR decapitates it with a vorpal sword
17:10:21 <voidzero> geekosaur LOL, I'm gonna use that one if I can remember it
17:11:39 <voidzero> I probably won't.
17:11:41 * voidzero folds
17:12:25 * EvanR raises
17:13:33 <Rotaerk> EvanR, haskell poker should involve "lifting", instead of raising
17:14:08 <Cale> You have the option of lifting, raising, or hoisting, and they're all somehow different.
17:14:14 <Rotaerk> oh heh
17:15:03 <shachaf> I'll see your Reader and raise you a State.
17:15:53 <dibblego> ReaderWriterStateT
17:16:02 <dibblego> thanks for playing
17:16:28 <glguy> Bust!
17:16:37 <glguy> If you go over 21 you lose
17:19:02 <EvanR> ContT is wild
17:26:51 <drewbert> Could I get some help understand this error? http://lpaste.net/5232978425345474560
17:29:32 <nshepperd_> I've been trying to write a combinator library for building neural networks, and one of the things I ran into is that it doesn't quite work with Arrow, because a general (a -> b) function can't be differentiated
17:30:54 <nshepperd_> or examined in any way at all
17:31:17 <jmcarthur> nshepperd_: yeah, my least favorite thing about Arrow is arr
17:31:36 <glguy> arr is were people often realize they don't want Arrow
17:32:11 <jmcarthur> i want various other monoidal categories far more often than i want arrows
17:32:41 <nshepperd_> yeah, so I ended up writing my own left, right, (***), (&&&) etc instead
17:33:03 <jmcarthur> or i guess that should be phrased "i have some monoidal category far more often than i have an arrow"
17:34:48 * voidzero hands out some RandomGens
17:36:06 * hackagebot up-grade 0.0.2 - Software management tool  http://hackage.haskell.org/package/up-grade-0.0.2 (ppenzin)
17:42:05 <dmwit> nshepperd_: You might like
17:42:05 <nshepperd_> though, it turned out (&&&) needs typeclass restrictions anyway, so it wouldn't have worked in any case I guess
17:42:09 <dmwit> ?hackage profunctors
17:42:09 <lambdabot> http://hackage.haskell.org/package/profunctors
17:42:24 <nshepperd_> profunctors are cool, yes
17:43:23 <voidzero> i worry for when i know all these infix operators by heart; I'll probably never be able to look at those symbols outside of haskell without trying to apply them mathematically
17:43:33 <nshepperd_> you can't fmap neural networks though
17:44:48 <EvanR> nshepperd_: or can you?
17:45:02 <hodapp> every time I hear "neural network", my hype filter kicks into high gear
17:45:21 <kadoban> Neural networks are pretty far from hyped, they're kind of old-hat at this point.
17:45:54 <voidzero> lol yeah who needs neurons
17:46:57 <nshepperd_> EvanR: not if you want to be able to stick them together and do gradient descent on the product
17:47:32 <tnks> hodapp: what about when you hear "deep learning"?
17:48:35 <shachaf> Artificial neural networks have only a vague similarity at best to actual neurons.
17:48:42 <shachaf> Especially the ones that work well.
17:49:17 <nshepperd_> calling them neural is certainly a misnomer
17:52:08 <voidzero> monadic
17:52:14 <voidzero> maybe that's the word? :)
17:53:03 <voidzero> at any rate, "higher order" just won't be it for me
17:54:19 <voidzero> but 'High Order Network™' would probably catch on quicker
17:54:23 <reem> If I'm interested in the internal implementation of bits of Haskell where should I go?
17:54:30 <voidzero> especially if you call it New World®
17:54:45 <shachaf> reem: If you mean GHC, there's all sorts of documentation on the GHC wiki.
17:56:06 <nshepperd_> how about "learned sequences of continuous transformations in high dimensional space"
17:56:11 <reem> shachaf: Hmmm, thank you
17:56:36 <voidzero> too big for the headlines, nshepperd_
17:56:39 <jle`> nshepperd_: yeah, Arrow w/out arr is profunctor and bifunctor
17:56:52 <shachaf> nshepperd_: Well, a very specific sort of continuous transformations, right?
17:56:58 <benzrf> o3o
17:57:14 <benzrf> jle`: it's not bifunctor, it's strength over bifunctors... or something...
17:57:17 <nshepperd_> that's true
17:57:17 <shachaf> nshepperd_: A bunch of affine maps followed by some nonaffine function applied componentwise. Or something.
17:57:21 <jle`> benzrf: oh you're right
17:57:32 <benzrf> jle`: also profunctors dont necessarily form a category
17:57:34 <nshepperd_> piecewise linear if you're using relu
17:57:43 <benzrf> you can only 'compose' Hask morphisms with them
17:57:48 <shachaf> Right.
17:57:55 <benzrf> tbh they arent all that similar
17:57:58 <jle`> benzrf: i meant to implicitly say Category
17:58:16 <jle`> the non-category parts are prof/strength
17:58:29 <benzrf> hm hm
17:58:30 <nshepperd_> the profunctor part requires arr
17:58:37 <benzrf> isnt it just strength actually
17:58:41 <jle`> nshepperd_: it doesn't need arr
17:58:46 <shachaf> nshepperd_: This isn't the right channel for that conversation but I'd like to know more about these sorts of functions, what can and can't be represented, the appropriate choice of nonaffine function, etc.
17:58:48 <jle`> if you don't have Category
17:59:07 <jle`> if your profunctor is Category then you get the arr
17:59:31 <jle`> i don't think you get an arr with profunctor alone
17:59:35 <shachaf> (relu is just (\x -> max x 0), right?)
17:59:50 <nshepperd_> shachaf: yep
18:00:07 <nshepperd_> jle`: no, I mean that Arrow is not a profunctor without arr
18:00:16 <jle`> nshepperd_: oh ah.
18:00:33 <voidzero> nshepperd_, your description is awesome if printed on a t-shirt btw
18:00:40 <jle`> wasn't i saying that Arrow w/out arr is profunctor+etc.?
18:00:57 <jle`> maybe my categorical logic is faulty today
18:01:04 <shachaf> Profunctor is at least very related to the thing people don't like about arrows.
18:02:08 <jle`> i've started on several projects that tried to leverage an arrow interface and almost all of them hit walls
18:02:27 <jle`> arrow is "nice" but its usefulness seems to be in very limited domains
18:02:48 <nshepperd_> the thing that allows you to compose Arrows with ordinary functions is arr
18:02:53 <shachaf> You can think of Monad/Functor/etc. as being like embedding other logics in Haskell. E.g. with Cont you can talk about classical logic within the context of a constructive logic like Haskell.
18:02:53 <jle`> er...usefulness seems to be limited to a very small number of domains
18:03:22 <Hijiri> oppositeways, if you have lmap/rmap and composition, you could just lmap/rmap onto id
18:03:23 <nshepperd_> so if you take arr away from arrow you have to "add dimap back" explicitly
18:03:26 <jle`> nshepperd_: yes, but arr is much more powerful than that
18:03:29 <Hijiri> so you end up with arr
18:03:35 <shachaf> But allowing fmap means that the "logic" you're talking about is at least as powerful as Haskell. If you want something weaker than Haskell (which is therefore easier to reason about), you have to get rid of fmap.
18:03:51 <jle`> arr is much more powerful than just being used to compose w/ normal functions ala dimap
18:03:55 <voidzero> a weak, lazy language
18:04:01 <jle`> in order to recover dimap you need `id` from Category
18:04:02 <nshepperd_> yes
18:04:14 <jle`> which Profunctor doesn't have
18:04:14 <voidzero> javascript
18:04:17 * voidzero ducks
18:04:26 <Welkin> javascript is strict
18:04:39 <shachaf> voidzero: You aren't really contributing to anything with that. If nothing else: No language bashing, please.
18:04:42 <jle`> um i think maybe my point earlier was totally not made very well or i am not understanding your point either :)
18:04:59 <voidzero> ha. ok, my sincere apologies shachaf, i shall step back in line at once.
18:05:58 <nshepperd_> jle`: I meant that there are things which satisfy Category and (Arrow minus arr) but which you can't implement dimap for
18:06:44 <shachaf> Arrow minus arr is just a category with products, isn't it?
18:07:34 <nshepperd_> an example would be a category of functions with restricted domain/codomain
18:08:14 <jle`> nshepperd_: ah. my not-well-stated-before point was that Arrow minus arr is Category + Prof + etc.
18:08:56 <Hijiri> category + prof gives you arr doesn't it?
18:09:01 <shachaf> Without arr you certainly can't implement dimap
18:09:18 <jle`> Hijiri: heh, you're right.
18:09:23 <jle`> i think i've tangled up my thoughts
18:10:06 <shachaf> nshepperd_: What is this Haskell ANN thing you're doing?
18:10:14 <jle`> there are things that admit an arr but not a dimap, if you don't have category...but i said you had category earlier...so...i have completely lost my mind
18:13:06 <nshepperd_> shachaf: an attempt at a combinator library for constructing them
18:14:41 <shachaf> nshepperd_: Is any code or anything released?
18:14:50 * shachaf would like to see.
18:15:58 <nshepperd_> I only started this a few days ago so there'll probably be a lot more iterations yet
18:16:05 <nshepperd_> a really simple example would be something like 'left (fcLayer 2 3 >> reluLayer >> fcLayer 3 1) >>> quadraticCost'
18:17:07 <nshepperd_> which builds a 'Network (Blob, Blob) ()' representing a network with one hidden layer containing 3 units
18:17:57 <nshepperd_> which you can run over a pair of (input, output) data and get the total error, do gradient descent to train the parameters, etc etc
18:18:08 <shachaf> fc?
18:18:18 <nshepperd_> er, 'fully connected'
18:18:40 <shachaf> Ah.
18:18:49 <nshepperd_> 'fully connected layer taking x units to y units'
18:18:54 <shachaf> Right.
18:19:12 <shachaf> I guess that just means some affine map.
18:19:20 <nshepperd_> yes, exactly
18:21:20 <shachaf> nshepperd_: You should tell me when you have more because this is exactly the sort of thing I was thinking about recently. :-)
18:21:32 <shachaf> (I only started to learn anything about this subject a little while ago.)
18:23:55 <mseeks> how do I convert a number to a `Fixed a` for some `a`?
18:25:03 <mseeks> ohhh MkFixed
18:25:17 <nshepperd_> lpastebot?
18:25:52 <glguy_> realToFrac
18:26:09 <nshepperd_> oh well, shachaf http://lpaste.net/120244 is my current code
18:26:20 <nshepperd_> it's a bit of a mess, of course
18:30:11 <EvanR> mseeks: use realToFrac or fromIntegral for most numeric conversions. floor is sometimes needed when you want to lose information
18:30:29 <EvanR> well, potentially a lot of information
18:35:10 <shachaf> nshepperd_: What other sorts of layers are plausible?
18:35:48 <shachaf> I guess you're hinting at partially-connected layers, and maybe nonlinear layers that aren't just applied componentwise or something.
18:36:31 <nshepperd_> well, the big thing in deep learning is convolutional layers
18:37:12 <nshepperd_> they take in a structured array of W×H units and run a 2d convolution over it
18:38:27 <nshepperd_> so you have a small number of parameters, maybe 25 for a 5×5 filter, rather than the thousands of parameters typical of a fully connected layer
18:39:18 <nshepperd_> very effective for extracting features from natural images apparently
18:39:29 <shachaf> Ah, makes sense.
18:46:51 <jle`> does anyone know if i can make a Num instance such that `fix sqrt` => 1 or something
18:47:13 <jle`> this has been on my mind for a long time
18:48:29 <jle`> sorry, not Num
18:48:34 <jle`> Floating
18:48:43 <jle`> but same idea :)
18:48:53 <Cale> If fix sqrt is not _|_, then sqrt _|_ is not _|_
18:48:57 <Welkin> Floating is a typeclass?
18:49:08 <Welkin> I thought it was Fractional
18:49:13 <jle`> there is both
18:49:24 <jle`> Cale: aw
18:49:31 <jle`> hm
18:49:33 <jmcarthur> Cale: i don't see how that follows.
18:49:35 <jle`> how about `mfix`?
18:49:52 <Cale> jmcarthur: fix finds the least defined fixed point
18:50:04 <Cale> jmcarthur: So, if _|_ is a fixed point of f, then fix f is _|_
18:51:19 <HeladoDeBrownie> Cale, how might be go a step further and prove that it is the least defined fixed point that fix finds?
18:51:23 <HeladoDeBrownie> s/be/we/
18:52:05 <jmcarthur> Cale: i think jle`'s question just threw me off and got me thinking about limits instead of fix.
18:52:08 <jmcarthur> my bad
18:53:01 <shachaf> The least fixed point is a limit. :-)
18:54:02 <shachaf> I guess it's more usefully a colimit.
18:56:11 * hackagebot call 0.1.3 - The call game engine  http://hackage.haskell.org/package/call-0.1.3 (FumiakiKinoshita)
19:03:32 <_um> I've got a very newbie question: if I'm working with a cabal sandbox, do I still use ghc --make to compile my program? Or do i replace it with cabal build? Or they unrelated and I should use something else?
19:05:22 <Denommus`> _um: cabal build
19:05:29 <_um> Denommus`: Thanks!
19:05:36 <Denommus`> _um: but I guess you have to install your dependencies with cabal install first
19:05:37 <_um> Can I still use  flags like -fwarn-unused-imports ?
19:05:39 <_um> with build?
19:05:45 <_um> Yep, got that part, thanks.
19:06:13 <Denommus`> _um: there's some ways to pass arguments to ghc from cabal
19:06:23 <Denommus`> _um: see here: http://stackoverflow.com/questions/10519740/specify-ghc-options-at-command-line-via-cabal-cabal-install-without-editing-c
19:06:38 <_um> many thanks!
19:08:11 <_um> Denommus`: Word. that got me all sorts of set up. Thanks ;)
19:08:42 <Denommus`> _um: one more thing: you can specify -j<number> option to have more than one compilation job :-)
19:08:49 <Denommus`> _um: like cabal install -j8
19:09:14 <_um> What does that do? "more than one compilation job"
19:09:33 <_um> Like to compile a number of projects with one command?
19:09:52 <nshepperd_> to compile using multiple cores
19:09:56 <Denommus`> _um: no
19:10:08 <nshepperd_> more or less
19:10:11 <Denommus`> _um: it creates multiple processes to compile your project
19:10:20 <_um> Ah. I see to get it done quicker.
19:10:43 <Denommus`> _um: so if you have 8 independent dependencies to be compiled, it will compile them at the same time
19:10:56 <_um> Handy :)
19:19:55 <hodapp> Is the <$> notation meant to suggest it's simply an applicative form of $?
19:22:39 <_um> good question.
19:22:58 <Rotaerk> :t ($)
19:22:59 <lambdabot> (a -> b) -> a -> b
19:23:03 <Rotaerk> :t (<$>)
19:23:04 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:23:12 <_um> Does <$> function like $? Or don't we need <*> for every additional argument?
19:23:26 <_um> (I'm just dipping my toes in applicative)
19:23:36 <_um> :t <*>
19:23:37 <lambdabot> parse error on input ‘<*>’
19:23:40 <_um> :t (<*>)
19:23:41 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:24:33 <_um> > (+) $ 2 4
19:24:35 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> s))
19:24:35 <lambdabot>    arising from the ambiguity check for ‘e_124’
19:24:35 <lambdabot>  from the context (GHC.Num.Num (a -> s),
19:25:26 * _um tries to fade into the background
19:25:26 <ski> hodapp : `<*>' is the applicative form of `$'
19:25:45 <ski> (which is why i think `<*>' would be better named `<$>')
19:26:12 <byorgey> _um: $ doesn't really 'function' in any special way, it is just function application
19:26:35 <hodapp> :t ($)
19:26:36 <lambdabot> (a -> b) -> a -> b
19:26:38 <hodapp> :t (<$>)
19:26:39 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:26:50 <hodapp> :t <*>
19:26:51 <lambdabot> parse error on input ‘<*>’
19:26:55 <hodapp> :t (<*>)
19:26:56 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:27:00 <ski> > [(+),(*)] <*> [10,20] <*> [3,4]
19:27:01 <lambdabot>  [13,14,23,24,30,40,60,80]
19:27:11 <ski> > [(+),(*)] <*> [10,20] <*> [3,4]  :: [Expr]
19:27:11 <byorgey> I think you can make the argument that <$> and <*> are both generalized forms of $
19:27:12 <lambdabot>  [10 + 3,10 + 4,20 + 3,20 + 4,10 * 3,10 * 4,20 * 3,20 * 4]
19:27:25 <hodapp> Expr? I should look this up...
19:27:32 <byorgey> @where expr
19:27:32 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
19:27:35 <_um> But, with $, we can do:
19:27:45 <_um> > (++) $ "ab" "cd"
19:27:46 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Char] -> [a]’
19:27:47 <lambdabot>              with actual type ‘[GHC.Types.Char]’
19:27:50 <ski> no
19:27:53 <_um> nope.
19:27:55 <_um> Stupid me.
19:28:02 <byorgey> _um: no, you can't.  That tries to apply "ab" as a function to "cd"
19:28:08 * _um remembers why he was trying to fade into background.
19:28:09 <ski> > ((++) $ "ab") $ "cd"
19:28:10 <lambdabot>  "abcd"
19:28:18 <_um> thanks :)
19:28:35 <ski> > (($) $ ((($) $ (++)) $ "ab")) $ "cd"
19:28:37 <lambdabot>  "abcd"
19:28:44 <Denommus`> > (++) "ab" "cd"
19:28:45 <lambdabot>  "abcd"
19:28:55 <byorgey> _um: no need to be ashamed of being wrong.  Everyone is wrong sometimes.  It means you're learning.
19:28:56 <_um> (I think I'm trying to use $ like prolog's "call"...)
19:29:09 <_um> byorgey: True.
19:29:11 <hodapp> I think I need to learn Prolog in the first place.
19:29:11 <ski> _um : call/N is a kludge
19:29:18 <hodapp> or Datalog. Or Mercury.
19:29:22 <hodapp> or what this call/N nonsense is.
19:29:33 * _um proudly steps out from the shadows to flaunt his former ignorance.
19:29:52 <byorgey> =)
19:29:55 <_um> hodapp: N just means the arity, the number of arguments, of a predicate.
19:30:18 <_um> father(Father, Son) is a predicate father/2
19:30:28 <_um> between(Low, High, Between) is a predicate between/3
19:30:30 <ski> call/N was invented because the theory behind Prolog really only supports first-order logic (so no higher-order relations), but we'd pretty-please-with-sugar-on-top still like to simulate them
19:30:48 <hodapp> will Prolog turn my brain inside out the way that Lisp did first, and then Haskell did again?
19:31:04 <ski> hodapp : learning logic programming is fun :)
19:31:04 <byorgey> hodapp: quite likely
19:31:08 <_um> ski: But combined with prolog's explicit evaluation, call gives us partial application for free :)
19:31:19 * hodapp checks to see if he has weed
19:32:09 <ski> _um : it doesn't give use partial application. it can interpret the predicate term as an already partially applied predicate
19:32:20 <ski> s/use/us/
19:32:47 <ski> hodapp : Mercury is cool. so's deductive databases
19:33:16 <ski> hodapp : if you learn Prolog first, you'll appreciate Mercury more
19:34:08 <mnaser> Is there a "setw" equiv. in Haskell?
19:34:40 <_um> ski: right, what I mean is, we can have the effects of partial application (relatively easily) with higher order predicates like call
19:35:08 <ski> hodapp : perhaps see "Re: Mercury in academic teaching?" by Richard A. O'Keefe in 2006-10-{09,10} at <http://www.mercurylang.org/list-archives/users/2006-October/004000.html>,<http://www.mercurylang.org/list-archives/users/2006-October/004011.html> for more useful info on Prolog vs. Mercury (in fact, it's more general than that)
19:35:38 <ski> mnaser : can you tell us what `setw' does ` (is that Common Lisp ? Emacs Lisp ?)
19:36:00 <sdfiou> is the r on line 3 here http://lpaste.net/120247 constrained by the r on line 1, or can all the 'r's on line 3 be changed to 't's ?
19:36:19 <ski> _um : yes .. anonymous predicate terms is harder (but not *that* hard)
19:36:32 <_um> ski: You mean for lambdas?
19:36:45 <ski> sdfiou : the latter
19:37:05 <mnaser> ski: something that allows to construct this type of output .. without doing a lot of strlen's http://lpaste.net/5757999363662020608
19:37:08 <sdfiou> ski: so its only there because it 'should' be the same type?
19:37:11 <ski> sdfiou : the first `r' is a type variable, the latter ones are value variables. these live in distinct name spaces
19:37:19 <ski> sdfiou : presumably, yes
19:37:24 <sdfiou> ah gotcha ski
19:37:31 <ski> _um : if you want to call them that, yes
19:38:00 <ski> sdfiou : if you had a type signature, then the type variable `r' would be in scope in that, though
19:38:23 <_um> ski: have you seen the lambda pack for swi-prolog?
19:38:38 <mightybyte> Robots on Haskell: https://news.ycombinator.com/item?id=9025249
19:39:19 <_um> If i'm not mistaken, it implements anonymous predicates without recourse to macros.
19:39:46 <_um> http://www.swi-prolog.org/pack/file_details/lambda/prolog/lambda.pl?show=src
19:39:57 <ski> mnaser : hm, alignment in formatted tables .. i don't see how you'd compute how many spaces to pad with, without counting the number of characters for each field .. possibly you could use attribute grammar techniques to compute this in a nice way
19:40:32 <mnaser> ski: right now i'm doing something like .. replicate (40 - length str) ' '
19:41:00 <ski> _um_afk : yes. Ulrich Neumerkel's implementation. it's basically the same as mine (which i've mentioned in ##prolog for years, maybe since 2004 or something)
19:41:07 <gcganley> ReinH: any update on a new episode?
19:41:34 <ReinH> gcganley: Not yet. Been super busy with other stuff.
19:41:43 <ski> (i used a different concrete syntax, and nesting it a little bit differently. still, the same idea)
19:43:47 <gcganley> ReinH: if I can be that guy and throw out an idea. In every episode you ask your guests how they got into haskell and their past in programming. I'd like to hear about chris' and your 'road to haskell'. there would be no guest. on the nerdist podcast they call it a 'hostful' and they are my favorite episode. just throwing it out there. also sorry for the poor grammer
19:46:02 <L8D> https://travis-ci.org/L8D/cido-api/builds/50140313
19:46:19 <L8D> https://github.com/L8D/cido-api/tree/restart
19:46:30 <L8D> anyone have a clue how to fix this linker error?
19:46:50 <L8D> undefined reference to `cidozmapizm0zi0zi1zi0_Util_zdfToMessageValue1_closure'
19:47:16 <gcganley> L8D: what system are you running?
19:47:23 <gcganley> L8D: OS i mean, sorry
19:47:26 <L8D> gcganley: OS X
19:47:38 <gcganley> L8D: one sec I'll take a look
19:47:44 <L8D> gcganley: But I’ve reproduced it on Arch and on Travis CI
19:47:51 <L8D> *whatever OS Travis CI uses
19:48:47 <gcganley> L8D: it uses apt so its probebly ubuntu or a debian-derivitive
19:49:44 <gcganley> L8D: are you just running `cabal install`?
19:51:09 <L8D> gcganley: I’m getting this after I `cabal build`
19:51:30 <L8D> gcganley: `cabal update && cabal install --only-dependencies && cabal build`
19:51:42 <L8D> after a git clone
19:52:41 <gcganley> L8D: running that right now after i blow away ~/.cabal and ~/.ghc
19:53:17 <L8D> gcganley: I’m guessing this error has something to do with https://github.com/L8D/cido-api/blob/restart/lib/Util.hs
19:53:21 <L8D> ^ orphan instances
19:53:39 <gcganley> L8D: that sorta error i would manually build binary and then run ldd
19:54:13 <gcganley> L8D: does it build to a binary or a library?
19:55:33 <_um> ski: Oh cool! I didn't realize you were an old Prolog maestro. Is your implementation available online? I'd love to take a look.
19:55:56 <L8D> gcganley: there is an executable and a library
19:55:59 <L8D> gcganley: the library builds fine
19:56:14 * hackagebot postgresql-typed 0.3.2 - A PostgreSQL access library with compile-time SQL type inference  http://hackage.haskell.org/package/postgresql-typed-0.3.2 (DylanSimon)
19:56:15 <L8D> gcganley: building the executable is what produces the problem
19:56:27 <gcganley> L8D: ldd the library... see if there is any funny buissness
19:56:53 <L8D> gcganley: what are the steps involved in doing that?
19:57:03 <L8D> in "ldd-ing the library"
19:57:21 <L8D> sorry I’m not a compiler/low-level person
19:57:44 <_um> (ski: "old" not implying anything about your age, big if you were working on implementing anonymous predicates at the same time... that one's been around for a while... any how "old" only relative to my < 2 years experience :))
19:57:50 <_um> s/big/but
19:58:06 <gcganley> L8D: run `man ldd` to understand what it means, basically it scans for unlinked ref's. atleast thats how i use it
19:58:52 <L8D> OS X does not have ldd
19:59:10 <L8D> homebrew doesn’t either
19:59:13 <gcganley> L8D: oh... awkward...
19:59:20 <gcganley> L8D: binutils?
19:59:31 <gcganley> L8D: `brew instrall binutils`
19:59:39 <L8D> there we go
19:59:59 <gcganley> L8D: hey maybe that Linux+ cert will be worth something
20:00:02 <mnaser> Little question.. http://lpaste.net/5109098331439628288 .. I ned to make sure that all rules are ran and return true, that code is wrong for me to fix, I removed the 'head $' but now i have a list of Bool's .. what would be the best way to check they're all True (or is there a cleaner way?)
20:00:04 <ski> _um : i've never packaged it up. a sample is `lambda(Environment,Formal0,Formal1,FormalBody,Actual0,Actual1) :- copyterm(t(Environment,Formal0,Formal1,FormalBody),t(Environment,Actual0,Actual1,ActualBody)),ActualBody.'
20:00:13 <ski> _um : you call it like `maplist(lambda([],M+Ns,Os,( maplist(lambda([M],N,O,( O is M + N )),Ns,Os) )),[10+[0,1,2,3],20+[4,5,6],30+[7,8],40+[9],50+[]],ListOfNumbers)'
20:00:33 <L8D> gcganley: were you able to reproduce the issue?
20:01:01 <gcganley> L8D: its chugging away right now, i did have to --force-reinstalls which is super scary
20:01:11 <L8D> gcganley: why not use a sandbox?
20:01:48 <gcganley> L8D: true, i've just never had the need to because my projects have so few dependencies
20:02:06 <gcganley> L8D: its going slow, i forgot to turn on parellel make
20:02:26 <_um> ski: Thanks.
20:02:28 <L8D> gcganley: I hate it when that happens...
20:03:08 <gcganley> mnaser: there is only the def for rule2 where is the definition for the rest of the terms in the list?
20:03:24 <mnaser> gcganley: they are all similar, i just left them out for brievety
20:03:25 <ski> _um : if you know you're using the lambda (mostly) uniquely (see <https://www.mercurylang.org/information/doc-latest/mercury_ref/Backtrackable-destructive-update.html>), then you can instead use `lambda(Param0,Param1,Body,Param0,Param1) :- Body.' and be rid of the copyterm/2, and the bother of having to explicitly enumerate each nonlocal variable in `Environment'
20:03:42 <L8D> gcganley: binutils just installed but there is no ldd
20:04:01 <gcganley> L8D: bother... im googling where you can find it now
20:04:07 <gcganley> mnaser: ok one sec
20:04:25 <ski> _um : the extra brackets around the "body" argument is so that you can more easily add more conjuncts
20:04:37 <gcganley> :t filter . map
20:04:38 <lambdabot>     Couldn't match type ‘[b]’ with ‘Bool’
20:04:38 <lambdabot>     Expected type: (a -> b) -> [a] -> Bool
20:04:38 <lambdabot>       Actual type: (a -> b) -> [a] -> [b]
20:04:42 <gcganley> :t filter
20:04:43 <lambdabot> (a -> Bool) -> [a] -> [a]
20:04:43 <_um> (ski: The princes bride quote there is excellently placed)
20:05:08 <gcganley> mnaser: maybe `filter legal`?
20:05:37 <gcganley> mnaser: some type sig's would be of great use
20:05:59 <mnaser> filter legal is okay, but i think the problem is in the legal
20:06:27 <mnaser> oh unless you mean filter legal to check for T only.. i need all them to be T
20:06:31 <gcganley> :t choose
20:06:32 <lambdabot> Random a => (a, a) -> Gen a
20:06:39 <mnaser> that's
20:06:41 <mnaser> probably good
20:06:44 <gcganley> mnaser: I've never used that function...
20:06:51 <ski> _um : `Environment' is just any term which mentions the nonlocal variables that you use. e.g. a list `[...]'. you could use a structure `env(...)' instead if you think that conserves more space
20:07:04 <mnaser> gcganley: the choose is in the app
20:07:04 <_um> ski: Since we're in #haskell, and this is therefore a marginally more related topic than prolog and mercury, have you tried Curry at all? Do you have an opinion on the prospects of doing logical-functional from the logical side as opposed to from the logical side (like with Mercury or Ciao)?
20:07:32 <_um> sorry, that first "logical" should be "functional"
20:07:46 <mnaser> all it returns is a list of lists containing k values out of n values
20:07:53 <gcganley> L8D: `otool`
20:07:55 <ski> _um : Neumerkel's `Free+\X1^X2^ ..^XN^Goal' corresponds to my `lambda(Free,X1,X2,...,XN,( Goal ))'
20:08:13 <_um> ski: Oh, I see.
20:08:14 <_um> That's nice.
20:08:22 <mnaser> it would return something like this... [[1,2,3,4], [1,2,4,5], [2,3,4,5]]
20:09:25 <gcganley> mnaser: in legal (\rule -> True) makes no sense. in all cases thats True
20:09:42 <gcganley> :t (\rule -> True)
20:09:42 <lambdabot> t -> Bool
20:09:55 <gcganley> > (\rule -> True) "memes"
20:09:57 <lambdabot>  True
20:10:24 <ski> _um : iow, it's basically the same idea. quite possibly Neumerkel invented it independently
20:10:33 <dmwit> ?quickcheck \rule -> True
20:10:33 <lambdabot> Unknown command, try @list
20:10:42 <ski> (afaik, i did)
20:11:29 <gcganley> L8D: does `otool` work for you?
20:11:57 <gcganley> @list
20:11:57 <lambdabot> What module?  Try @listmodules for some ideas.
20:11:59 <mnaser> gcganley: so that isn't actually evaluating the rule and checking it's resulting to true?
20:12:20 <benzrf> meeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeemes
20:12:38 <gcganley> mnaser: it returns True for every single input... wait... i wanna try something
20:12:44 <ski> _um : i've read a little about Curry, and Escher. not tried them (however, i've implemented a simple logic programming combinator library in Haskell, featuring logic variables (see papers by Seres and Spivey, and also Claessen), and (new) goal implication and goal universals (distinct from the operational interpretation of such in lambdaProlog)
20:12:47 <gcganley> > (\rule -> True) undefined
20:12:48 <lambdabot>  True
20:13:00 <gcganley> mnaser: yeah it never looks at its arg
20:13:02 <gcganley> :t const
20:13:03 <lambdabot> a -> b -> a
20:13:14 <gcganley> nope woops
20:13:18 <L8D> gcganley: otool with all relevant options finds nothing in dist/build/**.o
20:13:32 <mnaser> wait so does it or does it not now :p
20:13:34 <dmwit> :t (const True, \rule -> True)
20:13:35 <lambdabot> (b -> Bool, t -> Bool)
20:13:48 <gcganley> mnaser: it does nothing at all
20:14:04 <mnaser> okay i'll go learn some more map-ing
20:14:05 <shachaf> dmwit: If you have an isomorphism between b and t then those are the same function.
20:14:07 <_um>  ski: I like that you just use a normal predicate. Tbh, I find find this sntax `+Free\X^Y^Z^` way to jagged and pointy, it makes me feel uneasy.
20:14:07 <gcganley> > const True $ "memes"
20:14:08 <lambdabot>  True
20:14:15 <ski> _um : i haven't really checked out Ciao, so can't comment on that
20:14:16 <gcganley> dmwit: thank you
20:14:17 * ski notes _um is neither in ##prolog, nor in #mercury
20:14:38 <_um> ski: For some reason I'm banned from ##prolog.
20:14:44 <_um> I don't think I've even be in there.
20:15:07 <gcganley> shachaf: thats what he's attempting to show
20:15:34 <_um> ski: Also, while I compiled mercury once and run a few programs for fun, I haven't developed any facility in there.
20:15:43 <gcganley> L8D: haskell-src-exts failed to build, trying some more stuff
20:15:46 <shachaf> gcganley: Never mind, it was just a silly joke.
20:15:59 <_um> ski: Yep, I'm banned from ##prolog...
20:16:17 <ski> _um : have you been there before ?
20:16:35 <gcganley> L8D: oh... i need to install postgres i guess lol
20:16:38 <_um> ski: Not that I can recall. Some sort of glitchy thing.
20:16:43 <dmwit> :t id :: (forall b. b) -> (forall t. t)
20:16:44 <lambdabot>     Couldn't match type ‘t1’ with ‘forall b. b’
20:16:44 <lambdabot>       ‘t1’ is a rigid type variable bound by
20:16:44 <lambdabot>            an expression type signature: (forall b. b) -> t1
20:16:53 <dmwit> foiled
20:17:08 <ski> looks like there's an overly wide ban which catches you
20:17:38 <dmwit> ?let {-# LANGUAGE ImpredicativeTypes #-}
20:17:38 <lambdabot>  Parse failed: Parse error: EOF
20:17:57 <L8D> gcganley: it doesn’t matter, I found the issue
20:18:05 <shachaf> dmwit: It won't help.
20:18:08 <L8D> It’s an already-noted bug in GHC
20:18:15 <shachaf> You have to eta-expand, e.g. (\x -> id x), for that sort of thing.
20:18:20 <gcganley> L8D: whats the trac number/
20:18:24 <shachaf> (Of course id is pointless at that point. Or should I say pointful?)
20:18:25 <_um> ski: I guess I need to contact whoever runs ##prolog.
20:18:26 <L8D> for when unexposed modules are indirectly referenced
20:18:30 <gcganley> s/\//?
20:18:44 <dmwit> :t (\x -> x) :: (forall b. b) -> (forall t. t)
20:18:45 <lambdabot> (forall b. b) -> t
20:18:51 <dmwit> nailed it
20:19:03 <gcganley> dmwit: wow. good job mate
20:19:05 <L8D> gcganley: add all the modules to exposed-modules: fixed it
20:19:17 <shachaf> dmwit: Fortunately the argument of that function isn't :: forall b. b
20:19:23 <shachaf> That wouldn't be a very useful function.
20:19:30 <gcganley> L8D: oh... yeah im crap at cabal
20:19:56 <L8D> gcganley: I shouldn’t have to do that, but that’s what fixed the issue
20:20:11 <gcganley> L8D: you cant hide any modules?
20:20:38 <gcganley> goodnight
20:20:49 <mnaser> If I have a list of functions which I'm calling map on, how can I call them?
20:21:05 <dmwit> :t ($)
20:21:06 <lambdabot> (a -> b) -> a -> b
20:21:17 <mnaser> legal r = map (???) ruleset
20:21:24 <mnaser> if i want to call "r" for every ruleset
20:23:54 <dmwit> mnaser: Although you may not have guessed it, I was answering you.
20:24:05 <mnaser> i'm still just as lost :|
20:24:16 <dmwit> :t \r -> map ($r)
20:24:17 <lambdabot> a -> [a -> b] -> [b]
20:24:20 <mnaser> (please send me reading if there is something i should look at)
20:25:14 <mnaser> so I can do... map($r) rulset?
20:26:01 <bananagram> map ($ 1) [(2+),(4+)]
20:26:03 <bananagram> > map ($ 1) [(2+),(4+)]
20:26:05 <lambdabot>  [3,5]
20:26:07 <bananagram> cool
20:26:22 <mnaser> p
20:26:24 <mnaser> oh
20:26:25 <mnaser> i see
20:30:01 <ski> _um : try joining now
20:30:50 <lifter> I'm trying to use "dropEnd" from Data.Text but I'm getting a "not in scope" error; I can only imagine that the version of Text I have doesn't have this function. Is it possible to confirm that?
20:32:51 <dmwit> You can use `ghc-pkg list text` to find out which version(s) you have installed, and read the haddocks for that version.
20:33:29 <dmwit> Hackage has haddocks for most released versions, or you may have a local copy if you've asked cabal to build documentation for you.
20:33:52 <dmwit> If you're in a cabal sandbox, you will of course need to use cabal sandbox hc-pkg instead of ghc-pkg.
20:34:01 <lifter> ah
20:35:17 <lifter> well I don't have the latest ver in my sandbox but I don't have the docs for my version, either
20:36:18 <L8D> Is there some way I can force generalized deriving?
20:36:24 <L8D> for a newtype
20:37:08 <lifter> L8D: I believe there is a GHC extension for that?
20:37:25 <dmwit> L8D: Why do you ask?
20:37:33 <dmwit> (What does "force" mean?)
20:38:07 <L8D> dmwit: as in, if I have deriving (Show)
20:38:17 <L8D> in: newtype Foo = Foo Int
20:38:27 <L8D> then if I do: show (Foo 1)
20:38:30 <dmwit> L8D: no
20:38:32 <L8D> it gives me "Foo 1"
20:38:35 <dmwit> L8D: But the instance is easy to write.
20:38:45 <L8D> but then I'll end up writing 10 instances
20:38:46 <dmwit> showsPrec n (Foo v) = showsPrec n v
20:38:56 <dmwit> L8D: Oh NOOOOO, ten whole lines of code!
20:39:05 <EvanR> implicit deriving
20:39:23 <ski>   showsPrec p (Foo v) = showParen (p > 10) $ showString "Foo " . showsPrec 11 v  -- the correct instance
20:39:26 <L8D> EvanR: is that what I’m looking for?
20:39:31 <EvanR> yeah
20:39:37 <EvanR> doesnt exist though
20:39:41 <L8D> EvanR: is that a language extension or what?
20:39:43 <L8D> -.-
20:39:44 <dmwit> ski: He doesn't want the "Foo" part.
20:40:03 <ski> L8D : why ?
20:40:07 <L8D> dmwit: it’ll be more like 60 lines of code
20:40:08 <EvanR> L8D: another case of Show not living up to peoples expectations. solution dont use show?
20:40:14 <dmwit> L8D: Why 60?
20:40:26 <L8D> dmwit: because when I serialize to JSON I don’t want {"Foo": 1} I want 1
20:40:46 <dmwit> L8D: GND will do that one correctly.
20:40:48 <ski> L8D : if you don't want `Foo' to be part of the output, why not use a separate function (not `show'/`shows'/`showsPrec') ?
20:40:49 <EvanR> thats the ToJSON instance not Show
20:40:53 <dmwit> L8D: "correctly"
20:41:03 <ski> hm
20:41:27 <ski> L8D : why are you using `Show' on `Foo' to output JSON ?
20:41:35 <dmwit> He's not.
20:41:41 <L8D> ski: I’m using show as an example
20:41:49 <ski> ok
20:42:03 <dmwit> I think you'd better start talking about the actual problem you're having, or else you're going to get solutions that don't apply.
20:42:06 <dmwit> Like you did.
20:42:50 <L8D> my problem is actually with read
20:43:09 <L8D> that is the only one that I need generalized newtype deriving from
20:43:30 <dmwit> ...which is why you started talking about Show and ToJSON, right? makes sense
20:43:54 * glguy_ is also upset
20:43:58 <EvanR> lol
20:44:01 <L8D> still whatever
20:44:04 * ski is downset
20:44:13 <L8D> my question has been answered
20:44:20 <L8D> the answer is: no, you cannot.
20:44:30 <dmwit> correct
20:44:35 <EvanR> you cant do something, but maybe there is something else that would help
20:44:45 <EvanR> if there was more information
20:45:33 <L8D> here's the semi-up-to-date code: https://github.com/L8D/cido-api/tree/restart
20:45:57 <L8D> but I’m already fixing the problem
20:52:12 <ruler501> I'm getting an error when trying to link my program http://pastebin.com/3903N5q2 Is this a problem with my package(freshly installed from the package manager) or am I calling it wrong?
21:03:06 <glguy> ruler501: Perhaps you wanted to use the "-dynamic" flag instead of the -shared and -fPIC ones
21:04:17 <glguy> or if you did need shared and fPIC, you should still use dynamic
21:04:43 <glguy> In any case you should check out https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-shared-libs.html
21:06:18 * hackagebot xml-conduit 1.2.3.2 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.2.3.2 (MichaelSnoyman)
21:24:24 <NemesisD> is there some way i can attach or otherwise get info about a ghci session? i've got one hanging and I want to figure out what its doing
21:26:02 <lpaste> nocturne777 pasted “replicate'” at http://lpaste.net/120248
21:26:11 <NemesisD> strace says its hanging on a futex
21:26:33 <ski> NemesisD : have you logged in remotely ?
21:26:59 <nocturne777> guys, in this particular paste, what is the benefit of having (Num i, Ord i) in the function's type signature ?
21:27:05 <NemesisD> ski: its on my local machine but i'm trying to debug an issue i'm having with haskell-mode where the interactive process hangs (all the time)
21:27:05 <nocturne777> why is it better than the second one?
21:27:06 * ski is wondering whether GNU Screen would have helped in NemesisD's case
21:27:18 <NemesisD> so i didn't spawn it and am not managing it
21:27:34 <nocturne777> the version with "Int" in the function type signature
21:27:52 <ski> (perhaps `screenify' could be used, dunno)
21:28:09 <nocturne777> Num implies that it could be any number, Ord implies that it should be orderable
21:28:37 <ski> nocturne777 : generality
21:28:41 <enthropy> nocturne777: it means you can confuse people with replicate' 2.5 x
21:29:03 <kadoban> nocturne777: It's just more general. I don't know that it's actually better. I'd think something in Integral would be best, since I'm not sure Floating stuff actually makes much sense there?
21:29:05 <nocturne777> but "7.2" meets those criterion as well
21:29:33 <nocturne777> so, I agree with kadoban that those class constraints are redundant
21:30:12 <nocturne777> it just misrepresents the function
21:30:13 <ski> i'd possibly use `Integral' instead of `Num'
21:30:31 <ski> enthropy : not with `Integral' :)
21:31:20 * hackagebot amazonka-core 0.3.0 - Core functionality and data types for Amazonka libraries.  http://hackage.haskell.org/package/amazonka-core-0.3.0 (BrendanHay)
21:31:22 * hackagebot amazonka 0.3.0 - Comprehensive Amazon Web Services SDK  http://hackage.haskell.org/package/amazonka-0.3.0 (BrendanHay)
21:31:24 * hackagebot amazonka-autoscaling 0.3.0 - Amazon Auto Scaling SDK.  http://hackage.haskell.org/package/amazonka-autoscaling-0.3.0 (BrendanHay)
21:31:26 * hackagebot amazonka-cloudformation 0.3.0 - Amazon CloudFormation SDK.  http://hackage.haskell.org/package/amazonka-cloudformation-0.3.0 (BrendanHay)
21:31:28 * hackagebot amazonka-cloudfront 0.3.0 - Amazon CloudFront SDK.  http://hackage.haskell.org/package/amazonka-cloudfront-0.3.0 (BrendanHay)
21:31:41 <nocturne777> enthropy, kadoban, ski: thanks for confirming my thinking :) I am just going through the book and wanted to make sure that I am not missing something
21:32:54 * ski confirms the antecedent
21:36:30 * hackagebot amazonka-cloudhsm 0.3.0 - Amazon CloudHSM SDK.  http://hackage.haskell.org/package/amazonka-cloudhsm-0.3.0 (BrendanHay)
21:36:32 * hackagebot amazonka-cloudsearch 0.3.0 - Amazon CloudSearch SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-0.3.0 (BrendanHay)
21:36:34 * hackagebot amazonka-cloudsearch-domains 0.3.0 - Amazon CloudSearch Domain SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-domains-0.3.0 (BrendanHay)
21:36:36 * hackagebot amazonka-cloudtrail 0.3.0 - Amazon CloudTrail SDK.  http://hackage.haskell.org/package/amazonka-cloudtrail-0.3.0 (BrendanHay)
21:36:38 * hackagebot amazonka-cloudwatch 0.3.0 - Amazon CloudWatch SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-0.3.0 (BrendanHay)
21:41:40 * hackagebot amazonka-cloudwatch-logs 0.3.0 - Amazon CloudWatch Logs SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-logs-0.3.0 (BrendanHay)
21:41:42 * hackagebot amazonka-codedeploy 0.3.0 - Amazon CodeDeploy SDK.  http://hackage.haskell.org/package/amazonka-codedeploy-0.3.0 (BrendanHay)
21:41:44 * hackagebot amazonka-cognito-identity 0.3.0 - Amazon Cognito Identity SDK.  http://hackage.haskell.org/package/amazonka-cognito-identity-0.3.0 (BrendanHay)
21:41:46 * hackagebot amazonka-cognito-sync 0.3.0 - Amazon Cognito Sync SDK.  http://hackage.haskell.org/package/amazonka-cognito-sync-0.3.0 (BrendanHay)
21:41:48 * hackagebot amazonka-config 0.3.0 - Amazon Config SDK.  http://hackage.haskell.org/package/amazonka-config-0.3.0 (BrendanHay)
21:42:33 <mseeks> this question is sort of vague, but i have a monad stack with includes a `ReaderT AppConfig` sort of monad
21:43:24 <mseeks> i have a number of small (3-4 lines) functions which take some arguments and use a piece of the config and return something (sort of utility functions)
21:44:11 <mseeks> is it generally preferable to make these functions pure and require the calling function to `asks` the required config value from the ReaderT, or have the utility function compute in the monad?
21:45:13 <mseeks> i was thinking to prefer pure functions, but was wondering if anyone had any strong reasons to prefer one or the other
21:46:28 <EvanR> use a regular function to operate on the value
21:46:37 <Cale> Well, it's a matter of taste and what works for you. I usually don't like using ReaderT very much, and would prefer just passing a configuration parameter directly in most cases, but if I'm going to use ReaderT to construct some kind of monad, I'm probably going to try my best to hide the fact that I'm using monad transformers at all by providing all the computations required to interact with it.
21:46:50 * hackagebot amazonka-elasticbeanstalk 0.3.0 - Amazon Elastic Beanstalk SDK.  http://hackage.haskell.org/package/amazonka-elasticbeanstalk-0.3.0 (BrendanHay)
21:46:52 * hackagebot amazonka-elastictranscoder 0.3.0 - Amazon Elastic Transcoder SDK.  http://hackage.haskell.org/package/amazonka-elastictranscoder-0.3.0 (BrendanHay)
21:46:54 * hackagebot amazonka-elb 0.3.0 - Amazon Elastic Load Balancing SDK.  http://hackage.haskell.org/package/amazonka-elb-0.3.0 (BrendanHay)
21:46:56 * hackagebot amazonka-emr 0.3.0 - Amazon Elastic MapReduce SDK.  http://hackage.haskell.org/package/amazonka-emr-0.3.0 (BrendanHay)
21:46:58 * hackagebot amazonka-glacier 0.3.0 - Amazon Glacier SDK.  http://hackage.haskell.org/package/amazonka-glacier-0.3.0 (BrendanHay)
21:48:11 <mseeks> Cale: what do you mean by providing the computations required to interact with it?
21:48:46 <ademily> hello
21:48:54 <ademily> instring
21:48:59 <ademily> chiness
21:49:09 <mseeks> something like, `port <- getAppPort` instead of `port <- port <$> asks appConfig`?
21:49:37 <Cale> I mean, so you have some newtyped monad defined through monad transformers:  newtype MyAction a = MA (ReaderT ... possibly other transformers and stuff ...)
21:49:53 <mseeks> right
21:50:10 <Cale> I'd try to make sure that I could get away with not exporting the MA constructor, and hiding any sign of the fact that ReaderT was around from outside modules.
21:50:28 <Cale> Even if I went ahead and exported it anyway.
21:51:07 <Cale> but yeah, like that
21:51:08 <mseeks> would you allow stuff like `ask` and `withReaderT`?
21:51:39 <Cale> Well, ideally I would expose something nicer than that :)
21:51:52 <Cale> I would use those things to define the operations I really wanted to have
21:52:00 * hackagebot amazonka-iam 0.3.0 - Amazon Identity and Access Management SDK.  http://hackage.haskell.org/package/amazonka-iam-0.3.0 (BrendanHay)
21:52:02 * hackagebot amazonka-importexport 0.3.0 - Amazon Import/Export SDK.  http://hackage.haskell.org/package/amazonka-importexport-0.3.0 (BrendanHay)
21:52:04 * hackagebot amazonka-kinesis 0.3.0 - Amazon Kinesis SDK.  http://hackage.haskell.org/package/amazonka-kinesis-0.3.0 (BrendanHay)
21:52:06 * hackagebot amazonka-kms 0.3.0 - Amazon Key Management Service SDK.  http://hackage.haskell.org/package/amazonka-kms-0.3.0 (BrendanHay)
21:52:08 * hackagebot amazonka-lambda 0.3.0 - Amazon Lambda SDK.  http://hackage.haskell.org/package/amazonka-lambda-0.3.0 (BrendanHay)
21:53:59 <mseeks> interesting, that makes sense!
21:54:43 <mseeks> i've been using only the typical MonadTrans methods so far
21:55:28 <Cale> It's really tempting to use ReaderT to hide parameter passing, but often it gets abused. Having  ReaderT Foo ...  in your types and having to lift/liftIO everywhere throughout your program is not necessarily better (and often definitely worse) than just having  Foo -> ...  and passing a parameter around.
21:57:10 * hackagebot amazonka-opsworks 0.3.0 - Amazon OpsWorks SDK.  http://hackage.haskell.org/package/amazonka-opsworks-0.3.0 (BrendanHay)
21:57:12 * hackagebot amazonka-rds 0.3.0 - Amazon Relational Database Service SDK.  http://hackage.haskell.org/package/amazonka-rds-0.3.0 (BrendanHay)
21:57:14 * hackagebot amazonka-redshift 0.3.0 - Amazon Redshift SDK.  http://hackage.haskell.org/package/amazonka-redshift-0.3.0 (BrendanHay)
21:57:16 * hackagebot amazonka-route53 0.3.0 - Amazon Route 53 SDK.  http://hackage.haskell.org/package/amazonka-route53-0.3.0 (BrendanHay)
21:57:18 * hackagebot amazonka-route53-domains 0.3.0 - Amazon Route 53 Domains SDK.  http://hackage.haskell.org/package/amazonka-route53-domains-0.3.0 (BrendanHay)
21:57:27 <Cale> and liftIO is one thing, but if people are required to recall how many lifts they need to access various features of your eventual monad, that's pretty brittle to future changes.
21:57:37 <Cale> It's best to keep your lifting confined to one module.
21:58:31 <Cale> Because if you want to change how your type is implemented in the future, you probably don't want to hunt down all the lifts to fix them, even if the compiler is going to help you do it.
22:00:56 <Cale> The mtl monad transformers obscure the problem somewhat by defining O(n^2) "lifting instances", so that you can use MonadState operations on a ReaderT transformed monad if the base monad implements MonadState, and so on.
22:02:20 * hackagebot amazonka-s3 0.3.0 - Amazon Simple Storage Service SDK.  http://hackage.haskell.org/package/amazonka-s3-0.3.0 (BrendanHay)
22:02:22 * hackagebot amazonka-sdb 0.3.0 - Amazon SimpleDB SDK.  http://hackage.haskell.org/package/amazonka-sdb-0.3.0 (BrendanHay)
22:02:24 * hackagebot amazonka-ses 0.3.0 - Amazon Simple Email Service SDK.  http://hackage.haskell.org/package/amazonka-ses-0.3.0 (BrendanHay)
22:02:26 * hackagebot amazonka-sns 0.3.0 - Amazon Simple Notification Service SDK.  http://hackage.haskell.org/package/amazonka-sns-0.3.0 (BrendanHay)
22:02:28 * hackagebot amazonka-sqs 0.3.0 - Amazon Simple Queue Service SDK.  http://hackage.haskell.org/package/amazonka-sqs-0.3.0 (BrendanHay)
22:03:15 <Cale> That works to a degree, but I'm not really a huge fan of relying on it either.
22:07:30 * hackagebot amazonka-storagegateway 0.3.0 - Amazon Storage Gateway SDK.  http://hackage.haskell.org/package/amazonka-storagegateway-0.3.0 (BrendanHay)
22:07:32 * hackagebot amazonka-sts 0.3.0 - Amazon Security Token Service SDK.  http://hackage.haskell.org/package/amazonka-sts-0.3.0 (BrendanHay)
22:07:34 * hackagebot amazonka-support 0.3.0 - Amazon Support SDK.  http://hackage.haskell.org/package/amazonka-support-0.3.0 (BrendanHay)
22:07:36 * hackagebot amazonka-swf 0.3.0 - Amazon Simple Workflow Service SDK.  http://hackage.haskell.org/package/amazonka-swf-0.3.0 (BrendanHay)
22:28:51 <johnw> Cale: unless you need to guarantee the immutability of the Foo throughout the action
22:29:12 <johnw> which is probably the least often reason people reach for Reader/T
22:30:13 <Cale> johnw: Yeah, and if you want to do that, then you mustn't expose the fact that you're using ReaderT, because local is a thing
22:31:32 <johnw> oh, right!
22:31:51 <johnw> except that local can't propagate the change back out, so it's more of a sub-action
22:32:33 <johnw> whereas Reader in CPS-style is equivalent to State
22:35:01 <EvanR> without local cant you just run a new reader with a function of the context
22:37:05 <jle`> yea it's basically the same thing
22:37:10 <jle`> oh
22:41:12 <mjrosenb> ok, I've now tried building reactive-banana-sdl on two different distros
22:41:23 <mjrosenb> both seem to fail for more or less the same reason.
22:41:37 <mjrosenb>     <command line>: can't load .so/.DLL for: /usr/lib64/sdl-ttf-0.6.2/ghc-7.8.4/libHSSDL-ttf-0.6.2-ghc7.8.4.so (/usr/lib64/sdl-ttf-0.6.2/ghc-7.8.4/libHSSDL-ttf-0.6.2-ghc7.8.4.so: undefined symbol: TTF_CloseFont)
23:16:39 <_um> How would I go about adding "cc-options: -fPIC"
23:16:41 <_um> ?
23:17:32 <_um> maybe nm. sorry. gfg...
23:31:55 <jle`> anyone ever consider aliasing liftA2 to la2 or something
23:32:02 <jle`> seriously it's so long
23:32:57 <_um> where should I look for the cabal `config.log`?
23:33:47 <_um> Also, in order to add `cc-options: -fPIC` to a .cabal file, do I need to change other configurations in there as well?
