00:00:15 <mniip> I found lens-aeson insufficient because those lenses don't actually lens, they mangle the picture outside of the lens
00:00:34 <orzo> benchmarks show reverse $ BS.unpack bytestring is actually slightly better than runpack' (BS.length bs - 1) bytestring where runpack' is straightforwardly indexing the bytes from the end and recursing
00:01:19 <shachaf> orzo: What about the foldl solution I gave?
00:01:23 <orzo> maybe due to optimisations recognizing the reverse . unpack phenomenon?
00:01:38 <orzo> i've not been working on this, i just cme back to it
00:01:43 <orzo> didn't try your foldl
00:01:55 <orzo> i will
00:02:01 <orzo> but my intuition has already failed
00:02:17 <orzo> wouldn't you expect runpack' to be faster?
00:02:45 <shachaf> Why?
00:03:24 <shachaf> foldl is doing the same thing but its implementation of indexing is better than yours.
00:03:58 <orzo> i expect BS.unpack to build a list starting from index 0 and going to the end, and then reverse to run.  runpack' would build the reversed list in one pass from the back end.  This is a strict bytestring, indexing the end is O(1)
00:04:27 <shachaf> Oh, better than reverse . unpack
00:04:47 <orzo> runpack' 0 bs = [BS.head bs]
00:04:47 <orzo> runpack' n bs = BS.index bs n : runpack' (n-1) bs
00:04:53 <orzo> that's my implementaiton of indexing
00:05:20 <shachaf> What happened with foldl?
00:07:58 <mniip> I should try to rewrite those as actual lenses
00:08:04 * hackagebot mono-traversable 0.9.0 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.9.0 (MichaelSnoyman)
00:08:04 * hackagebot extensible 0.3 - Extensible, efficient, lens-friendly data types  http://hackage.haskell.org/package/extensible-0.3 (FumiakiKinoshita)
00:08:48 <orzo> your foldl solution benchmarks equivelently to my runpack'
00:10:09 <orzo> hmm, maybe all 3 implementations are benchmarking similarly, it was just a stastistical fluke i think now
00:11:03 <orzo> i still think if i use -O0, then my runpack' might beat your foldl and my reverse . unpack
00:11:25 <shachaf> Why would it beat foldl?
00:11:34 <shachaf> foldl is doing exactly the same thing but better.
00:11:44 <shachaf> Unless you mean because it wouldn't inline.
00:12:55 <mniip> last time I tried benchmarking haskell I gave up because of the memoization
00:14:22 <orzo> well i need to process the list after it's built, and foldl would force two passes, in my mind, one pass to build the list, another to process it.  the runpack' method should use less memory because it can discard the list boxes as i consume them shortly after i make them
00:15:27 <orzo> by the way, if there's some nice efficient canned algorithm for writing a bignum in as a bigendian bytestring of a given width, then that would make this whole issue moot
00:16:21 <shachaf> foldl is doing the same thing your function is doing.
00:17:49 <orzo> memory-wise as well?
00:18:07 <orzo> when i access head of tghat foldl-constructed list, wont it force all the elements to the end?
00:18:34 <orion> Is it possible to make a data constructor available only to some modules and not others?
00:19:08 <shachaf> Why would it?
00:19:15 <shachaf> You can look at the code: https://hackage.haskell.org/package/bytestring-0.10.4.1/docs/src/Data-ByteString.html#line-527
00:24:09 <orzo> i see
00:27:07 <xandaros> Since every Monad is a functor, am I right in assuming that return is a specialised version of pure like map is a specialised version of fmap?
00:27:56 <johnw> you are exactly right
00:28:03 <johnw> wait, no
00:28:14 <johnw> return and pure are the same function
00:28:17 <thebnq> other way i think
00:28:27 <jle`> return is to pure as map is to fmap, roughly
00:28:28 <johnw> sorry, I misread you
00:28:30 <jle`> at least when 7.10 hits
00:28:40 <johnw> return and pure differ in their constraints only
00:28:42 <jle`> pure is a much more general return
00:28:47 <johnw> map and fmap differ in their types
00:28:53 <jle`> fmap is a much more general map
00:29:03 <xandaros> As I thought, then, thanks
00:29:05 <johnw> jle`: how is pure more general than return?
00:29:25 <jle`> not all things that can pure can return
00:29:39 <jle`> but all things that can return can pure
00:29:56 <johnw> in 7.10, pure and return will be equivalent, while map and fmap never will be
00:30:48 <xandaros> map is a specialised version of fmap, working only on lists, whereas fmap works on any functor, but they do basically the same, don't they? And lists are functors...
00:31:13 <jle`> but even in 7.10 not all things that can return can pure
00:31:15 <jle`> er
00:31:18 <johnw> in the case of list, fmap = map
00:31:19 <jle`> not all things that can pure can return
00:31:27 <jle`> in the case of Monad, return = pure
00:31:50 <johnw> jle`: I see what you mean
00:32:01 <jle`> it's a bit of a stretch in technicality/semantics though
00:32:16 <jle`> so if i argue with yuo anymore it's probably not going to do any good to anyone :P
00:32:34 <johnw> I have no more argument
00:33:02 <psycoder__> Hi, started learning haskell today and need help finding problem with cabal. Could someone please help if they have time?
00:33:33 <jle`> it could be said that pure gives an identity of sorts for Applicative operations and return gives an identity for Monad operations, and the fact that they are the same might actually be some cosmic coincidence
00:34:16 <jle`> s/it could be said/maybe?????
00:34:42 <johnw> they are the same because they are the same thing
00:35:17 <johnw> in other places (not Haskell), Monad doesn't have "return" at all, there is only "pure", which is inherited by Monad
00:35:54 <jle`> we picked two sets of operations, and they happen to have the same identity
00:36:23 <jle`> i guess they are still the same no matter how you slice it.  but we arrive at the significance of both through differentpaths
00:36:27 <psycoder__> I created a paste file if somebody is interested in helping out: http://lpaste.net/2439567382910337024
00:36:40 <johnw> for example, if Applicative had never had Functor as a superclass, as we had define "amap" with the same signature just an Applicative constraint, you wouldn't say there is a difference between amap and fmap, simply because of this historical accident.  That is also the case between pure and return
00:37:06 <johnw> i.e., if Applicative had been found before Monad, Monad wouldn't have 'return'
00:37:20 <shachaf> psycoder__: It's what the error says. There is no Main module.
00:37:55 <xandaros> and you are missing a LICENSE file
00:38:01 * hackagebot html5-entity 0.1.0.0 - A library for looking up and validating HTML5 entities.  http://hackage.haskell.org/package/html5-entity-0.1.0.0 (zudov)
00:38:07 <jle`> sometimes i like to believe that the hierarchy isn't so clear...that monad and applicative both add independent/separate structure over Functor, and the fact that one can subsume the other is a coincidence
00:38:22 <johnw> jle`: mathematically, it's no coincidence
00:38:36 <jle`> i think for example that comonad and coapplicative are also things that add structure to functor, but the "one subsumes the other" isn't the case
00:38:50 <psycoder__> shachaf, xandaros  thanks, i will search google for modules...
00:39:06 <shachaf> psycoder__: Your module is called Greetings. Rename it to Main.
00:39:11 <shachaf> module Main(main) where ...
00:39:50 <psycoder__> shachaf, ohh thanks...
00:40:18 <johnw> jle`: take the alternative formulation of Applicative, from the Typeclassopedia: unit :: m ().  This is a way of producing a "default" context, in the sense of a monoidal unit.  Now, return x = fmap (const x) unit.  That's what return *is*, it's not a different thing that feels related.
00:40:49 <jle`> the alternative formulation of applicative is actually closer to what i'm talking about actually
00:41:01 <jle`> so Applicative adds the ability to f a -> f b -> f (a, b)
00:41:04 <jle`> with an identity f ()
00:41:26 <jle`> Monad adds the ability on top of functor to f (f a) -> f a, with a natural transformation (a -> f a) that is an identity
00:41:41 <johnw> it only really adds the former
00:41:41 <jle`> the two seem to be independent "extra structure" on top of functor...in two orthogonal directions
00:41:59 <jle`> having an f (f a) -> f a isn't nearly as useful without an identity
00:42:19 <johnw> both are dealing with monoids in the category of endofunctors
00:42:32 <johnw> they both share the fact that they are defined in terms of a unit
00:42:36 <shachaf> Why is Applicative dealing with monoids in the category of endofunctors?
00:42:39 <johnw> that notion of unit is the same notion
00:42:43 <shachaf> I think you're missing jle`'s point, at any rate.
00:42:55 <johnw> shachaf: it's transporting monoidal structure, functorally, or am I mistaken?
00:43:08 <johnw> I could well be missing his point
00:43:12 <jle`> Applicative gives you a an action, and an identity for that action...Monad gives you a totally different action, and an identity for that different action
00:43:27 <jle`> the fact that the two identities happen to be "the same" in some sense might be taken as a coincidence
00:43:45 <johnw> I just can't imagine a world in which pure and return end up being different in any way, not unless the Applicative and Monad instances are working with separate monoidal structures
00:43:47 <shachaf> What does it mean to transport monoidal structure functorially?
00:44:04 <jle`> for example if you consider coapplicative, it doesn't have the same sort of relationship with comonad. yet both "add structure" (orthogonal structure) to functor
00:44:09 <johnw> shachaf: as a functor, it maps the monoidal structure of one category to another
00:44:19 * Arahael reckons it'll take him a very long time before he realises what this current topic is even about.
00:44:28 <johnw> though now you have me feeling that I'm not getting this right
00:44:31 <johnw> so I will just stop here
00:45:47 <shachaf> jle`: Monad could be defined in Haskell with unit :: m () too, of course. I don't know about join.
00:46:04 <shachaf> In the nice well-behaved world of Functor and Applicative, join is an odd operation.
00:46:04 <psycoder__> shachaf, thanks. i got it finally :-D
00:46:34 <johnw> shachaf: perhaps this relates?  "The action of a monoidal category is the monoidal functor from it to some category of endofunctors" (http://link.springer.com/article/10.1007/BF02365309#page-1)
00:47:18 <shachaf> Perhaps. I can't see the article.
00:47:25 <johnw> oh, it comes up in some dumb viewer
00:47:26 <shachaf> But I'm not sure what it relates to.
00:47:41 <jle`> defining a mathematical monad in terms of its action on an initial object sees like a contrived way of going about it...and i'm not totally sure you can recover the full strength
00:48:06 <dulla> so what is it really
00:48:21 <shachaf> Yes.
00:48:56 <shachaf> () isn't initial, but at any rate.
00:48:58 <vanila> hi #haskell
00:49:07 <johnw> shachaf: aha, found it: "There are different notions of computation, the most popular being monads, applicative functors, and arrows. In this article we show that these three notions can be seen as monoids in a monoidal category." (http://www.fceia.unr.edu.ar/~mauro/pubs/Notions_of_Computation_as_Monoids.pdf)
00:49:33 <jle`> shachaf: ah my mistake. glad you understand my intent though
00:49:35 <johnw> "it is known that lax monoidal functors are monoids with respect to the Day convolution, and hence applicative functors are also monoids in a monoidal category of endofunctors using the Day convolution as a tensor"
00:49:56 <johnw> I didn't know about the Day convolution stuff, but I think the rest is what I Meant
00:50:26 <edwardk> jle`: coapplicative?
00:50:30 <jle`> i know some words
00:50:42 <edwardk> jle`: what would that be?
00:51:04 <johnw> and so, if Applicative and Monad are both monoids in a monoidal category of endofunctors, then insofar as they relate to the same monoidal structure, they should have the same unit
00:51:07 <shachaf> You're linking to a lot of papers but I'm still not sure what you meant, or what Applicative has to do with "monoids in the category of endofunctors".
00:51:16 <edwardk> johnw: no
00:51:16 <vanila> edwardk, re. before http://winterkoninkje.dreamwidth.org/101276.html
00:51:25 <johnw> edwardk: ok
00:51:28 <shachaf> That phrase is cursed by now. People say it for no reason.
00:51:46 <johnw> edwardk: please correct?
00:51:52 <edwardk> johnw: throw out that statement and lets rebuild it
00:51:57 <johnw> ok, thrown
00:52:36 <johnw> shachaf: just two papers, and the latter explains that in rather some depth it appears
00:52:37 <shachaf> Ah, the category of endofunctors with day convolution as the monoidal product.
00:53:28 <edwardk> we can define a monoidal category. this is a category C, equipped with some bifunctor (*), and a unit for that bifunctor, e such that we have a few things, an associator alpha :: (a * b) * c <-> a * (b * c),   unit laws saying rho :: a * e <-> a    and lambda :: e * a -> a
00:53:36 <edwardk> where <-> is isomorphism
00:53:47 <merijn> Arahael: You stare at all the dense jargon for a while and before you know it, some of it starts seeping into your own vocabulary
00:53:49 <edwardk> er lambda :: e * a <-> a
00:54:01 <johnw> right, I remember that from your chalkboard at Hac Boston
00:54:16 <Arahael> merijn: That is a terrifying thought. :)
00:54:23 <dulla> vanila  > silent culture
00:54:26 <merijn> Arahael: And suddenly one day you'll wake up and go like "oh! So that's what they mean by codensity transformation!" and not even realise how weird that sounds :D
00:54:27 <dulla> you lost me there
00:54:31 <edwardk> and where we satisfy mac lane's pentagonal coherence condition, which says you can go (((a * b) * c) * d to a * (b * (c * d))  via the two paths and both give the same answer
00:54:53 <Arahael> merijn: People already look at me funny for mentioning covariance and contravariance.
00:54:57 <vanila> certain person want to silence criticism and that enables bullying and other bad things
00:55:26 <merijn> Arahael: The whole "monads are monoids in the category of endofunctors" thing is actually pretty easy, for example, just not very useful practically :)
00:55:36 <johnw> edwardk: ok, that's clear
00:55:36 <dulla> chalkboard?
00:55:40 <edwardk> now we can talk about a monoid object for such a category. since we'll be using the same base category C, and equipping it with different bifunctors, i'll choose to adopt the language 'the monoidal category C equipped with the tensor (*)' rather than just saying the monoidal category (C,(*),e)'
00:56:34 <edwardk> now a monoid object for a 'monoidal category (C, (*), e)' is an object m, such that you have mempty :: e -> m; and mappend :: m * m -> m
00:56:41 <edwardk> to borrow haskelly vocabulary
00:56:59 <edwardk> with the obvious unit and associative laws -- in terms of whatever tensor we had for our monoidal category.
00:57:07 <johnw> why is it e -> m, and not just m?
00:57:12 <edwardk> here I used the notation (*) indicating its probably a product like thing
00:57:17 <johnw> you need to pick your unit?
00:57:24 <merijn> Arahael: My way of explaining contravariance is: Functors are data sources, contravariant functors are data sinks and profunctors are pipes :)
00:57:24 <edwardk> because its a morphism
00:57:29 <edwardk> i need to go from something
00:57:31 <johnw> ah, right
00:57:41 <edwardk> so it goes from the unit for the bifunctor in question
00:57:49 <johnw> is e "just some initial object?"
00:58:01 <shachaf> e isn't initial
00:58:04 <merijn> Arahael: Which is, like the "functors as boxes" analogy a bit limited, but it's an ok first approximation
00:58:05 <edwardk> remember we have rho_a :: (a * e) -> a
00:58:07 <shachaf> It's just an identity of (*)
00:58:14 <johnw> shachaf: ok
00:58:16 <merijn> Arahael: Plus a useful example of "when functors are not boxes"
00:58:18 <shachaf> (An identity with rho, like edwardk said.)
00:58:19 <edwardk> which gives us the ability to put in and take off 'e's in the tensor
00:58:38 <edwardk> in the case of products the unit for the product is the initial object
00:58:53 <edwardk> but there is no reason why all monoidal categories use the initial object as their unit
00:58:58 <johnw> makes sense
00:59:01 <edwardk> for instance we can take (Hask,Either,Void)
00:59:06 <edwardk> Void is terminal, not initial
00:59:11 <edwardk> er
00:59:13 <edwardk> sorry backwards
00:59:25 <edwardk> ot ahead
00:59:27 <johnw> ((), a) =~ (a, ()) in the product case, Either a Void =~ Either Void a in the coproduct case
00:59:28 <merijn> edwardk: Wait, what?
00:59:39 <edwardk> (Hask,(,),())   and (Hask,Either,Void)
00:59:43 <edwardk> merijn: i said i screwed up
00:59:57 <edwardk> () is the terminal object in the category, Void is initial
01:00:01 <merijn> edwardk: Thank god, I was worried everything I learned was wrong :p
01:00:16 <edwardk> merijn: i was primed by johnw saying 'initial object' and flipped my worldview
01:00:21 <edwardk> unflipped
01:00:27 <merijn> Arahael: Actually, a decent intro would be: http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
01:00:28 <johnw> i was flipped inside too
01:00:29 <edwardk> the unit for the product is the terminal object =P
01:00:31 <johnw> I said initial and thought ()
01:00:46 <merijn> Arahael: It contains lots of C++ and Haskell examples :)
01:00:46 <edwardk> the unit for coproduct is initial
01:01:04 <johnw> and presumably there are units which are neither initial nor final?
01:01:09 <Arahael> merijn: That's not going to help with most programmers. :)
01:01:21 <edwardk> both the product and coproduct bifunctors are choices of tensor you could equip Set or Hask with to get a monoidal category.
01:01:26 <edwardk> yes
01:01:28 <Arahael> merijn: Most who are just shocked that Java is _better_ at this than C#. ;)
01:01:57 <edwardk> now, we can talk about a 'monoid object' for (Hask,(,),())
01:02:08 <edwardk> and in this setting you recover something that feels a lot like the monoids you know and love
01:02:18 <edwardk> you have a thing that takes () -> m        and m * m -> m
01:02:30 <merijn> Arahael: I would also argue you can do quite a lot of haskell without needing of any of this, so :p
01:02:33 <edwardk> it feels like you have a unit and a binary operation
01:02:41 <edwardk> but written purely in terms of morphisms
01:02:51 <edwardk> but we can have a 'monoid object' for (Hask,Either,Void) as well
01:02:59 <edwardk> Void -> m    and Either m m -> m
01:03:09 <edwardk> Void -> Void  and Either Void Void -> Void
01:03:15 <edwardk> Void is such a monoid object!
01:03:24 <edwardk> (you can check the laws they are boring)
01:03:31 <johnw> heh
01:03:50 <edwardk> (the unit for the tensor will always be such a monoid object, hence why () is a Monoid instance)
01:04:05 <shachaf> Isn't everything a monoid object there?
01:04:10 <edwardk> now, we can look for other categories, so we can look at the category of endofunctors over Hask.
01:04:13 <shachaf> With absurd and either id id
01:04:25 <edwardk> shachaf: i don't remember if the laws check out
01:04:30 <edwardk> give it a shot, report back ;)
01:04:36 <shachaf> It works out.
01:04:43 <shachaf> But the laws force you to use either id id no matter what the type.
01:04:48 <shachaf> So it's as boring as comonoids.
01:05:26 <edwardk> so we can look at categories like [Hask,Hask]  and we can equip it with one of several different tensors.
01:05:44 <edwardk> you can take the product of functors, coproduct of functors... composition of functors...
01:05:53 <edwardk> each of those admits a notion of a monoid
01:06:02 <shachaf> Exercise: What do you get when you use the product of functors?
01:06:24 <edwardk> composition of functors is interesting. remember our objects here are functors from Hask -> Hask
01:06:30 <edwardk> so our arrows are natural transformations
01:06:58 <edwardk> so Compose as a bifunctor takes natural transformations   f ~> g   and h ~> j    and takes Compose f h ~> Compose g j
01:07:02 <johnw> shachaf: Monad?
01:07:17 <johnw> or is that from composition
01:07:18 <edwardk> and the associator reassociates Compose f (Compose g h) <~> Compose (Compose f g) h
01:07:30 <shachaf> It's an exercise, not a guessercise.
01:07:32 <edwardk> johnw: composition, not products
01:07:32 <johnw> oh, no, n/m
01:07:38 <johnw> shachaf: lol
01:08:06 <edwardk> and the unit laws lambda and rho puts on and takes off the identity functor, which is the unit for composition
01:08:15 <acetoline> so what's the deal with hlearn?
01:08:24 <edwardk> Compose Identity f <~> f <~> Compose f Identity
01:08:55 <edwardk> this is where monads come from,     the mempty for this is Identity ~> m   -- Identity a -> m a
01:09:11 <edwardk> mappend :: Compose m m ~> m       m (m a) -> m a
01:09:24 <edwardk> the former is return, the latter is join
01:09:41 <johnw> shachaf: when you say "what do you get", do you mean Product f Identity a <~> Product Identity f a, and Product f (Product g h) a <~> Product (Product f g) h a?
01:09:41 <edwardk> so when we say 'monads are monoids in the category of endofunctors'
01:09:58 <edwardk> we're really saying monads are monoid objects in ([Hask,Hask],Compose,Identity)
01:10:01 <jle`> f a -> f (a, a); f () -> ().b 6
01:10:01 <johnw> edwardk: ah, ok, so my thought about composition and Monad was correct
01:10:04 <jle`> oh sorry
01:10:10 <jle`> accidentally pressed enter on my scratch work
01:10:15 <shachaf> What is a monoid object in the category of Hask endofunctor, where the monoidal product is (f :*: g) a = (f a, g a)?
01:10:49 <shachaf> edwardk is showing you what a monoid object is where you use (f :.: g) a = f (g a)
01:10:58 <edwardk> Applicatives are monoid objects in ([Hask,Hask],Day,Identity)
01:11:01 <johnw> ok, working
01:11:09 <edwardk> and shachaf has another case
01:11:32 <shachaf> edwardk: I didn't know that about Applicative until a few minutes ago.
01:11:32 <edwardk> so there are plenty of notions of 'monoids in the category of endofunctors' ;)
01:11:49 <shachaf> I guess Day f Identity is like Coyoneda f
01:12:27 <edwardk> and technically its not Identity for the Day case, its what you get with Yoneda, when you look at the homsets from the identity, which here is (), which happens to be () -> a
01:12:43 <edwardk> but that is isomorphic to identity because we're in a closed category
01:12:52 <edwardk> so we can treat it as such
01:13:30 <shachaf> What about Day convolution with Either? Void1?
01:13:33 <edwardk> but if we cared about day convolution from something that wasn't product, and so had a different unit, we'd have to use   (e -> a) as the unit.
01:13:41 <shachaf> Er, no.
01:13:45 <shachaf> Just Proxy.
01:14:09 <shachaf> I guess Proxy being representable as (Void ->) or something.
01:14:25 <johnw> shachaf: ([Hask,Hask],Product,Const ())
01:14:26 <edwardk> (Void -> a)
01:14:58 <shachaf> johnw: OK, what's that in Haskell terms?
01:15:12 <johnw> I'm not sure I follow
01:15:38 <johnw> edwardk: what is Day again?
01:15:57 <shachaf> edwardk wrote ([Hask,Hask],Compose,Identity), and then he wrote join :: m (m a) -> ma, return :: a -> m a
01:16:19 <edwardk> newtype Day f g c = forall a b. Day (a -> b -> c) (f a) (g b)
01:16:28 <NightRa> I have a `StateT m (a,Maybe b)`, and I want it to continue only if `Maybe b` is a just. What monad transformer should I use?
01:16:29 <johnw> oh, you mean what does that monoid object give rise to that I would recognize
01:16:42 <edwardk> Day :: (a -> b -> c) -> f a -> g b -> Day f g c
01:16:52 <johnw> edwardk: thanks
01:16:57 <johnw> I actually hadn't seen that yet
01:17:00 <merijn> NightRa: And what do you want to do if "Maybe b" is not a just?
01:17:05 <shachaf> edwardk: Those are fancy newtypes you have there.
01:17:11 <edwardk> shachaf: =P
01:17:11 <NightRa> Then stop.
01:17:14 <edwardk> ok, data Day
01:17:30 <NightRa> Not continue the transformations in State
01:17:52 <edwardk> :t liftA2
01:17:53 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
01:17:54 <vanila> NightRa, what about MaybeT of State? try both and see which works
01:17:59 <edwardk> ^- that looks a lot like Day if you squint
01:18:00 <merijn> NightRa: What does "stop" mean? Return some random value? Produce "(a, Nothing)"?
01:18:11 <shachaf> Day f g a = exists c d. (f g, c d, c -> d -> a)
01:18:11 <merijn> vanila: His Maybe is inside the tuple
01:18:34 <NightRa> The last `a` for which there was a Just, and Nothing as the second part
01:18:58 <lf94> How do I pass a javascript object from a function to javascript in haste?
01:19:07 <edwardk> since we're in a monoidal closed category you can write a form of Day that looks closer to (<*>)
01:19:12 <phaazon> hi
01:19:17 <lf94> Apparently JSON -> IO() is wrong
01:19:22 <phaazon> is there a way to load a module in ghci hiding symbols?
01:19:23 <edwardk> but it loses explanatory power when you to go look for a contravariant version
01:19:29 <phaazon> hiding doesn't work in ghci :(
01:19:31 <shachaf> (<*>) is more confusing than liftA2 anyway.
01:19:55 <mtbottle> rgg anyways
01:20:12 <merijn> NightRa: "do { (a, mB) <- previousStateT; case mB of { Nothing -> return (a, Nothing); Just x -> f x }" where "f :: StateT m (a, Maybe b)"?
01:20:23 <shachaf> Is there a version of Day that looks like times :: f a -> f b -> f (a,b)?
01:20:33 <edwardk> anyways the monoids for Day convolution have     pure ::   Identity ~> f             and   liftA2 :: Day f f ~> f     -- with the expected unit and associativity laws
01:21:07 <edwardk> shachaf: trying to capture the 'strong lax monoidal functor' view ?
01:21:20 <shachaf> That's the usual view of Applicative.
01:21:32 <edwardk> well, its one view of them
01:21:38 <edwardk> its the one in the idiom paper
01:21:45 <shachaf> I guess the name "Applicative" disagrees with me here.
01:21:58 <shachaf> But anyway is there?
01:22:17 <edwardk> but its kinda meh. viewing them as closed functors works better.    (<*>) :: f (a -> b) -> (f a -> f b)    takes arrows to arrows
01:22:30 <shachaf> That lets you be existential over the a.
01:22:33 <edwardk> the action on (,) is determined by the fact that we're monoidal closed
01:22:35 <edwardk> so it has to be compatible
01:22:40 <merijn> NightRa: I guess I don't see why you wouldn't just pattern match on the result to see if it's a maybe and then decide actions based on that?
01:22:50 <edwardk> but the fact that we're closed is what we _actually_ work with in Applicative
01:23:31 <NightRa> merijn: Yeah, that's about what I'm doing now. It just is the same behavior each time, so there's duplication
01:23:39 <acetoline> so what's the deal with hlearn?
01:23:43 <NightRa> I guess there isn't a nice combination of instances currently which gives me what I need. Thanks for the help!
01:23:53 <thebnq> phaazon: does import xyz () do what you wanted
01:23:54 <merijn> NightRa: You could write a custom combinator that abstracts the pattern?
01:23:55 <edwardk> shachaf: basically you need the result to be functorial in the last argument, so once you do that you take (a,b) -> c  and quantify over everything and you get day convolution
01:24:11 <phaazon> thebnq: what
01:24:24 <NightRa> merijn: Yeah, I'll probably write a specific >>= for this one.
01:24:25 <phaazon> thebnq: I'd like to hide stuff from Prelude
01:24:35 <edwardk> Day f g c = exists a b. ((a * b) -> c) * f a * g b
01:24:45 <shachaf> Just like actual convolution.
01:24:46 <edwardk> so the version you are looking for _is_ day convolution.
01:24:47 <merijn> phaazon: "import Prelude hiding (foo)" and/or ":set -XNoImplicitPrelude"
01:24:50 <shachaf> I guess I should say "usual convolution".
01:25:34 <shachaf> The (a*b -> c) part is like summing over every a,b such that a*b=c
01:25:41 <edwardk> and the nice thing is this trick works whether we go from [C,D] or [C^op,D]
01:25:50 <edwardk> *nods*
01:25:59 <johnw> shachaf: Alternative?
01:26:12 <shachaf> Alternative is correct.
01:26:12 <edwardk> when you do the other you get the Divisible and Decidable machinery in contravariant
01:26:26 <johnw> shachaf: thank you for the exercise, that was most helpful
01:27:08 <edwardk> and it answers the question of whether or not "contravariant applicative" makes sense
01:27:36 <edwardk> coapplicative is still nonsense, we don't have coexponentials! --  but "contravariant applicative" works fine
01:27:38 <johnw> edwardk: I'd like to chat with you more about Day convolution next week
01:28:06 <edwardk> johnw: http://hackage.haskell.org/package/contravariant-1.2.0.1/docs/Data-Functor-Contravariant-Divisible.html
01:28:16 <edwardk> ^- see "Divisible" from there
01:28:19 <johnw> i'll study that in preparation :)
01:28:28 <shachaf> I guess we don't have any bifunctors with inverses.
01:29:01 <shachaf> But if we did we could presumably write something like Day f g a = exists c. (f c, g (d * c^-1))
01:29:23 <shachaf> Er, I messed that up.
01:29:30 <phaazon> merijn: thanks
01:29:52 <shachaf> Day f g a = exists c. (f c, g (a * c^-1))
01:33:57 <shachaf> So what do you get for Day convolution with Either?
01:34:14 <shachaf> unit :: F a, times :: (Either a b -> c) -> F a -> F b -> F c
01:35:21 <shachaf> times :: (a -> c) -> (b -> c) -> F a -> F b -> F c
01:36:17 <edwardk> that is 'covariant Day convolution taking Either to Product'
01:37:02 <edwardk> now, fuse the functions into those functors as you have no other occurence of the variables involved
01:37:09 <edwardk> times :: F c -> F c -> F c
01:37:17 <edwardk> unit :: F c
01:37:21 <shachaf> Oh. :-(
01:37:28 <edwardk> -- this should look a bit like Alternative
01:37:35 <shachaf> It works out the same as for (:*:)
01:38:03 <johnw> edwardk: very cool!
01:38:11 <edwardk> the key here is that you'd ideally use the distributive law between (*) and (+) to get Alternative laws
01:38:15 <shachaf> (exists a. (F a, a -> c)) -> (exists b. (F b, b -> c)) -> F c
01:38:16 <edwardk> but we don't really have them
01:38:30 <shachaf> I should know to watch for that by now.
01:39:44 <johnw> wait, that looks like Coyoneda, except for exists instead of forall... or is it still, because those appear contravariantly?
01:39:54 <edwardk> in the contravariant ((+)->(*)) case we wind up with choose :: (a -> Either b c) -> f b -> f c -> f a    and lose :: (a -> Void) -> f a
01:40:30 <edwardk> when all you know is you have a functor  holding an 'a' and something from a -> c -- all you can do is map that function over
01:40:38 <edwardk> it might be identity, it might not you can't know
01:40:48 <edwardk> so thats a form of Coyoneda F
01:41:01 <edwardk> its the existential one
01:41:13 <johnw> ah, I didn't know about the existential one, how does it relate?
01:41:18 <johnw> (other than the obvious)
01:41:19 <edwardk> exists a. (F a, a -> c)     is isomorphic to  F c
01:41:30 <johnw> ok
01:41:50 <edwardk> its 'the arguments to fmap' balled up
01:42:01 <johnw> edwardk: yep.  I'm glad you jumped in to correct me earlier, this has been great
01:42:06 <NightRa> This is the function I finally used:
01:42:08 <NightRa> compose :: (Monad m) => (a -> b -> m (a, Maybe c)) -> (a -> c -> m (a, Maybe d)) -> (a -> b -> m (a, Maybe d))
01:42:15 <shachaf> And where does unliftA2 :: (a -> b -> c) -> (p a -> p r) -> (p b -> p r) -> p c -> p r come from?
01:42:41 <edwardk> your fevered imagination? =)
01:43:01 <shachaf> If only my imagination was that fevered.
01:43:14 <shachaf> It came from the bizarro unlenses world years ago.
01:43:43 <shachaf> (p is contravariant)
01:43:55 <edwardk> oh that stuff
01:43:57 <edwardk> meh
01:44:00 <shachaf> Along with unid :: p x x -> p b a and uncompose :: (p y e -> p b a) -> (p e x -> p b a) -> p y x -> p b a
01:44:14 <shachaf> I still think there ought to be something there.
01:44:20 <shachaf> Oh well.
01:44:32 <solatis> which network library do people recommend? it seems like the standard 'network' library is a bit too low-level, and you need to work around certain known concurrency bugs
01:44:45 <merijn> solatis: Wait
01:44:49 <merijn> solatis: Which concurrency bugs?
01:44:56 <solatis> https://hackage.haskell.org/package/streaming-commons-0.1.9.1/docs/src/Data-Streaming-Network.html#safeRecv
01:44:58 <solatis> that for example
01:45:17 <solatis> windows doesn't work well with interrupts
01:45:44 <jle`> is there a standard empty typeclass
01:45:57 <NightRa> And the impl: http://lpaste.net/120755
01:45:59 <jle`> the identity in the monoid of constraints
01:46:15 <Cale> jle`: I believe you can just write that ()
01:46:25 <Cale> jle`: () :: Constraint
01:46:27 <merijn> solatis: I wouldn't consider that a bug
01:46:30 <jle`> such that (MyClass f, Foo f) == MyClass f
01:46:43 <merijn> solatis: That's just a race condition when sharing a socket between threads
01:46:48 <solatis> ah right
01:46:53 <merijn> solatis: But you shouldn't be sharing sockets between threads anyway
01:46:59 <merijn> solatis: Just use one thread per socket
01:46:59 <solatis> nah i know
01:47:07 <jle`> Cale: it'd be nice to have one of a similar kind to the Foo above tho ain't it
01:47:12 <solatis> in that case, i suppose the bug is somewhere in my code
01:47:21 <merijn> solatis: What bug are you experiencing?
01:47:39 <jle`> then you can say something like f :: a -> a -> a === f :: Foo a => a -> a -> a
01:47:47 <Cale> jle`: I don't know what purpose it would serve...
01:48:00 <solatis> i'm getting safePtrMalloc errors
01:48:02 <solatis> hold on
01:48:04 * hackagebot pgdl 7.5 - pgdownloader  http://hackage.haskell.org/package/pgdl-7.5 (sifmelcara)
01:48:11 <jle`> you can sort of imagine every parameterized type signature has having constraints then
01:48:12 <Cale> jle`: Maybe if you start to have things parameterised on a choice of (* -> Constraint)
01:48:16 <jle`> some just with more constraints than others
01:48:41 <merijn> solatis: Also, you should probably (definitely...) use Network.Socket.ByteString if you aren't already
01:48:47 <solatis> assertion mallocPlainForeignPtrBytes size must be >= 0
01:48:49 <jle`> then f :: Empty a => a -> Bool and f :: Show a => a -> Bool have the same kind of form
01:49:25 <jle`> it's sort of the same reason you would use the Identity type for
01:49:35 <solatis> it's raised by Network.Socket.ByteString.recv
01:49:44 <merijn> solatis: If you can get a stack trace (we have those now, right?) and figure out what code path calls that...
01:49:51 <solatis> yes i have one
01:50:18 <merijn> solatis: uhoh...which platform?
01:50:19 <jle`> to show that f x y is just f <$> x <*> y when you have Identity...or like how we can say that return :: Monad m => Identity a -> m a is a natural transformation
01:50:23 * merijn has a sinking feeling
01:50:28 <solatis> merijn, windows 8.1
01:50:30 <merijn> solatis: And what value are you passing in?
01:50:43 <jle`> or that (=<<) is ($) when you imagine all normal values being in Identity
01:50:45 <merijn> Oh, nevermind my sinking feeling, then :p
01:51:02 <solatis> merijn, what is happening is that i send data, and immediately close the socket afterwards
01:51:15 <solatis> if i don't close the socket, this error is not raised
01:51:21 <solatis> (as in, threadDelay 1000000)
01:51:43 <Cale> jle`: You can always write () => ...
01:51:47 <solatis> so this /feels/ like a platform bug
01:52:09 <solatis> but i'm using the raw Network.Socket.ByteString library, so I might be doing something wrong myself..
01:52:24 <solatis> if i don't compile with -threaded, an IOException is raised instead
01:52:25 <merijn> solatis: Yeah, sounds like it, but I don't have windows 8, so I wouldn't be able to test that. AFAIK, windows is not that well maintained for many libraries because there's not that many testers
01:52:26 <jle`> something on `a` though.....hmmmm..... yeah it probably doesn't have too much general uasge to exist
01:52:33 <jle`> also i didn't realize that () was a Constraint too
01:52:59 <merijn> solatis: Try to Debug.Trace which values are getting passed and examine the code?
01:53:44 <solatis> merijn, yeah i've been grinding on this one for more than 1 day already, i'm way past that lol
01:53:53 <merijn> solatis: I've heard weird errors due to the RTS system assming that Haskell word size and C word size matched
01:53:58 <merijn> solatis: s/heard/had
01:54:07 <jle`> :t let foo :: (Show a, ()) => a -> Boo; foo = odd . length . show in foo
01:54:08 <lambdabot>     Not in scope: type constructor or class ‘Boo’
01:54:08 <lambdabot>     Perhaps you meant ‘Bool’ (imported from Data.Bool)
01:54:33 <merijn> solatis: I'm expecting something like an overflow in the Int to CInt conversion of recvInner causing it to crash
01:55:07 <merijn> solatis: That'd explain the negative value error, assuming the Int you pass in is big
01:55:15 <solatis> merijn, yeah but at the moment i'm kind of fed up with it
01:55:32 <solatis> i cannot reproduce the bug in an isolated case
01:55:47 <solatis> this feels way too much like coding C again :)
01:56:08 <merijn> solatis: Someone has to do it so the rest dn
01:56:13 <merijn> *rest don't have to
01:56:49 <solatis> merijn, that's correct
01:57:08 <solatis> but from my C time, i also learned that i should never assume that something is a compiler bug rather than a bug in my code
01:57:29 <solatis> (as in, if no one else has ran into this issue, it usually means the bug is in my code)
01:57:44 <solatis> but i feel like haskell + windows + networking is a bit... rough on the edges, right?
01:58:05 <vanila> edwardk, ping
01:58:07 <EvanR> why are you using Socket.ByteString
01:58:13 <edwardk> ?
01:58:26 <vanila> catch my link eralier
01:58:37 <edwardk> vanila: don't think so
01:58:42 <vanila> edwardk, re. before http://winterkoninkje.dreamwidth.org/101276.html
01:58:44 <vanila> certain person want to silence criticism and that enables bullying and other bad things
02:00:15 <merijn> EvanR: What else?
02:00:23 <EvanR> to write to a socket?
02:00:30 <ab9rf> socketry
02:00:35 <merijn> EvanR: Write to/read from, yes
02:00:37 <solatis> EvanR, this bug is raised when reading
02:00:46 <solatis> but why shouldn't i use Socket.ByteString ?
02:00:49 <solatis> is that a bad thing ?
02:00:53 <EvanR> hGet works, from Data.ByteString
02:00:58 <EvanR> or hGetLine etc
02:01:01 <merijn> EvanR: hGet works on handles
02:01:06 <merijn> And handles are exclusive
02:01:12 <EvanR> thats what a socket is
02:01:19 <merijn> Which means you can't have concurrent reads/writes from different threads
02:01:22 <edwardk> vanila: i heavily respect wren. that said, i also respect shapr, and when i reviewed the traffic in the channel, i still think he did the right thing. please move this to #haskell-ops if you feel you have a grievance, but i'm going to bed
02:01:37 <ab9rf> why would you want more than one thread reading from or writing to a socket?
02:01:50 <merijn> ab9rf: Why not? One thread to read, one to write
02:01:57 <ab9rf> merijn: not on the same socket
02:02:05 <ab9rf> merijn: you'd need to use a socket pair for that
02:02:13 <merijn> ab9rf: Eh, why?
02:02:38 <EvanR> a read and a write locks out a Handle?
02:02:43 <merijn> ab9rf: One thread reads from network, forwards to application, other reads from application forward to networks
02:02:45 <ab9rf> merijn: eh, i suppose it makes sense to do that
02:02:55 <merijn> EvanR: Yes, Handle have an internal MVar to guarantee exclusive access
02:03:04 <ab9rf> merijn: if the read task and write tasks are on different threads
02:03:12 <EvanR> alright so the answer is that Handle stuff would totally work, its just not as high performance
02:03:23 <merijn> ab9rf: You can't block on both a socket and a Chan so a single thread won't work
02:03:23 <ocharles_> Does anyone else find it surprising that asum [a,b] is NOT a <|> b?
02:03:29 <ocharles_> in fact it's a <|> b <|> empty
02:03:40 <ocharles_> which means if you use it with parsec, it potentially throws away useful error reporting
02:03:41 <ab9rf> ocharles_: no really, no
02:03:50 <ocharles_> debating whether or not I should open a thread on the cafe for it...
02:04:02 <ab9rf> ocharles_: otherwise, what would asum [] be?
02:04:07 <ocharles_> ab9rf: that can be empty
02:04:12 <ocharles_> but asum [a] = a
02:04:16 <ab9rf> ocharles_: so yuou want it special-cased?
02:04:16 <int-e> ocharles_: it's not surprising; I'd blame Parsec there.
02:04:28 <solatis> hmmm
02:04:28 <ocharles_> ab9rf: i don't know what I want, just bouncing ideas out :)
02:04:32 <solatis> implement a socket as a Chan
02:04:36 <ab9rf> is a <|> empty different from a?
02:04:41 <solatis> that sounds like an interesting idea
02:04:58 <int-e> ab9rf: it really shouldn't be different
02:05:14 <ocharles_> i forget if Alternative even has laws
02:05:14 <ab9rf> i forget how <|> is defined
02:05:18 <ab9rf> heh
02:05:25 <merijn> EvanR: Right, Socket from network is just a CInt for the socket's file descriptor, so if you care about performance using network is preferable to using a Handle
02:05:28 <edwardk> ocharles_: it basically doesn't
02:05:29 <ab9rf> alternative just does stuff and we hope it makes sense
02:05:35 <edwardk> ocharles_: there are multiple sets of laws we like to think it has
02:05:50 <edwardk> ocharles_: but they are mutually contradictory
02:05:54 <ocharles_> edwardk: that's as good as no laws, when it comes to reasoning like this
02:05:57 <ab9rf> edwardk: lovely!
02:06:00 <edwardk> ocharles_: yep
02:06:06 <ab9rf> edwardk: i thought you were going to bed
02:06:12 <int-e> edwardk: is anything wrong with a = empty <|> a = a <|> empty ?
02:06:21 <edwardk> ocharles_: but fixing the situation actually causes a great deal more pain than the situation
02:06:31 <ab9rf> i'd be surprised if empty wasn't the identity for <|>
02:06:33 <vanila> I guess im missing from the list of people you have respect for
02:06:37 <edwardk> int-e: sure. putStrLn "hello" <|> empty /= empty
02:06:43 <int-e> sleeptyping is so horrible.
02:06:45 <int-e> edwardk: thanks.
02:06:53 <solatis> maybe i should try out Network.Transport instead of Network.Socket
02:06:58 <ocharles_> edwardk: fixing the laws, or "fixing" asum?
02:07:03 <int-e> (though the alternative instance for IO is... well... odd.)
02:07:07 <merijn> solatis: Which package is that?
02:07:10 <edwardk> int-e: gets worse with launching missiles ;)
02:07:14 <solatis> https://hackage.haskell.org/package/network-transport
02:07:21 <solatis> merijn, part of haskell-distributed
02:07:24 <int-e> edwardk: no kidding. has anybody actually done that yet?
02:07:25 <solatis> it has a tcp and a zmq backend
02:07:42 <solatis> https://hackage.haskell.org/package/network-transport-tcp
02:07:47 <solatis> and it has mock sockets!
02:07:57 <int-e> I mean it seems to be just a matter of time. (I'm talking about launching missiles with Haskell.)
02:07:59 <ocharles_> you know, I might be lying actually... chrisdone points out in private that asum [a,b] does produce the same error reporting as a <|> b <|> []
02:08:01 <ab9rf> the docs for Alternative say that empty is supposed to be the identity for <|> so if a <|> empty /= a, there's a problem
02:08:01 <ocharles_> err, <|> empty
02:08:56 <edwardk> well my old boss used to have remote controlled helicopters that he'd take up to a farm in michigan that were rigged up with bottle-rocket launch-tubes. they'd do dog-fights. now he has some automated stuff flying them, i suppose if we hooked the bottle-rocket launchers again, we really could launch missiles from code.
02:09:52 <edwardk> ocharles_: you should have the associativity law as well
02:09:59 <edwardk> ab9rf: the docs lie there, as almost no instance actually satisfies that law
02:10:02 <tdammers> edwardk: DO IT!
02:10:11 <ab9rf> edwardk: hehe
02:10:28 <ab9rf> edwardk: which ones don't?
02:10:36 <edwardk> ab9rf: IO is a good start
02:10:51 <edwardk> and almost any monad transformer on top of it
02:10:55 <ab9rf> edwardk: IO is in Alternative?
02:11:03 <solatis> merijn, looks like network-transport is more for loosely coupled connections in a distributed context, tho
02:11:15 <edwardk> its a MonadPlus in mtl and the instance is being migrated back to base eventually
02:11:24 <edwardk> and so post AMP it _has_ to be Alternative
02:11:35 <ab9rf> hm
02:11:42 <jle`> oh yeah, is MonadPlus going to be an empty typeclass now
02:11:54 <jle`> all it does is add laws right
02:12:02 <ab9rf> edwardk: so that's not really a good thing, i should think
02:12:06 <edwardk> jle`: no, AMP doesn't remove redundant members, just unscrews up the relationship between the classes
02:12:06 <edwardk> fixing stuff is for later versions
02:12:14 <edwardk> ab9rf: the stated laws for Alternative are wrong
02:12:17 <edwardk> they just are
02:12:42 <jle`> what's wrong with the Alternative laws? ;_;
02:12:46 <edwardk> the MonadPlus laws already were acknowledged as broken, one piece of documentation for Alternative apparently survived the purge
02:12:51 <edwardk> it doesn't make it correct
02:13:09 <xandaros> associativity for Alternative makes sense, though
02:13:24 <ab9rf> edwardk: so does that means that Alternative doesn't have an identity?
02:13:32 <ab9rf> edwardk: or at least should not be assumed to have one?
02:13:34 <edwardk> https://wiki.haskell.org/MonadPlus_reform_proposal talks about old proposals for laws for monadplus
02:13:37 <vanila> edwardk,  I guess im missing from the list of people you have respect for
02:13:44 <edwardk> but it still gets the a <|> empty case wrong
02:13:48 <ab9rf> and why is IO Alternative?  it doesn't seem to make sense to me for it to be Alternative
02:14:08 --- mode: ChanServ set +o edwardk
02:14:12 <tdammers> ab9rf: why not?
02:14:17 --- kick: vanila was kicked by edwardk (vanila)
02:14:18 --- mode: edwardk set +b vanila!*@*
02:14:23 <EvanR> it uses quantum physics to try both actions
02:14:25 <ab9rf> i dunno, i guess i don't understand Alternative :)
02:14:42 <ab9rf> EvanR: ha
02:14:49 --- mode: edwardk set -o edwardk
02:14:53 <ab9rf> nondeterministic IO
02:15:05 <ab9rf> "Write this to output, maybe"
02:15:12 <xandaros> I don't see IO as Alternative, either... It could have side effects and evaluation would be pretty much random with Alternative
02:15:24 <tdammers> hmm righ
02:15:25 <xandaros> *evaluation order
02:15:26 <tdammers> t
02:15:44 <xandaros> and what would empty be?
02:16:03 <EvanR> hitting the center of a black hole
02:16:08 <tdammers> empty = fail? idk
02:19:42 <Hijiri> :k (~)
02:19:42 <lambdabot> k -> k -> Constraint
02:20:26 --- mode: ChanServ set +o edwardk
02:20:42 --- mode: edwardk set -b vanila!*@*
02:20:54 <EvanR> this is awesome, im about to close and dup in such a way as to have the child process and the parent process be writing to each others stdin
02:21:20 <EvanR> i hope thats a thing that you can do
02:21:55 --- mode: edwardk set -o edwardk
02:22:21 <ab9rf> EvanR: i don't see why not.  be careful with deadlock, though.
02:22:26 <merijn> EvanR: Why not?
02:22:47 <EvanR> i just became confused how the child will get the fd for the parent
02:22:50 <ab9rf> you don't want one process waiting on the other when the other is waiting on the first
02:23:28 <EvanR> i guess its just another pipe
02:23:33 <ixs_> > 5
02:23:35 <lambdabot>  5
02:23:42 <mauke\> hi, 5
02:24:06 <ab9rf> EvanR: the main issue is that you need two pipes for this
02:24:23 <EvanR> yes
02:24:34 <ab9rf> EvanR: so that means four fds, and you'll have to juggle them with dup to get them onto 0 and 1 if that's what you really want
02:25:09 <ab9rf> the child inherits all of the parent's open FDs (except those fcntl'd to close-on-fork)
02:25:19 <EvanR> that seems the "simplest" way, otherwise how do you tell the child program about the other fds still open, parseint an argument/
02:25:45 <ab9rf> EvanR: the child inherits the parent's memory image, too.
02:25:59 <ab9rf> EvanR: everything the parent knoiws, the child knows initially too
02:26:11 <mauke\> ab9rf: there's a close-on-fork?
02:26:13 <EvanR> yes but then im doing exec
02:26:17 <merijn> mauke\: Yes
02:26:26 <mauke\> merijn: what's it called?
02:26:29 <ab9rf> EvanR: so juggle the fds between fork and exec
02:26:38 <merijn> mauke\: On some platforms at least, I forget the name though
02:26:43 <ab9rf> mauke\: it's one of the many options you can set with fcntl
02:26:44 <EvanR> yes reassigning to 0 or 1 works
02:26:53 <mauke\> ab9rf: what's it called?
02:26:54 <ab9rf> i'm not sure how widely supported it is
02:27:07 <ab9rf> mauke\: dunno, i haven't written low-level code to juggle descriptors in a decade
02:27:08 <merijn> mauke\: Oh, I can guess where this is going
02:27:12 <EvanR> i was just saying if you wanted it to be on 3 for instances, having a haskell child process "guess" at 3 then make that a handle seems wonky
02:27:25 <merijn> ab9rf, mauke\: I think ab9rf is misremembering (and affecting me) FD_CLOEXEC
02:27:35 <merijn> ab9rf: Which closes on *exec*, not on fork
02:27:39 <mauke\> ah
02:27:44 <mauke\> yeah, I know about CLOEXEC
02:28:07 <ab9rf> that might be
02:28:17 <ab9rf> although i think i ran into a platform once that has close-on-fork
02:28:23 <ab9rf> linux apparently not :)
02:28:39 <ab9rf> EvanR: what do you mean, "guess at 3"?
02:29:11 <EvanR> ab9rf: lets say i want to keep stdin and stdout, and allow the child (after exec) to use a pipe which for instance is fd 3
02:29:24 <EvanR> and the child program isnt as powerful as C as to just use a 3
02:29:26 <ab9rf> EvanR: you can force whatever handle to be on whatever fd you want
02:29:36 <EvanR> ok
02:30:38 <ab9rf> i don't know if haskjell exposes dup2, but dup2 can bne used to ensure that a particular descriptor is exactly the file you want
02:30:59 <merijn> ab9rf: The posix libraries do
02:31:03 <ab9rf> fd = open(...); dup2(fd,3); close(fd);
02:31:07 <EvanR> pipe, fork, dup, exec, i feel tough
02:34:02 <EvanR> i see the posix haskell libs, but is there a "better" way to spawn processes?
02:34:09 <ab9rf> EvanR: and actually if you want the child to have a specific stdin/stdout, you pretty much have to use dup2
02:34:31 <EvanR> ab9rf: yeah i just noticed dup"1" is a little weird
02:35:11 <ab9rf> dup just grabs a free fd, which should be the lowest-numbered not-already-open one
02:35:36 <EvanR> yeah so if youre careful to close stdin, then dup, then close stdout, then dup...
02:35:39 <ab9rf> so the sequence close(0); fd = dup(...) should return fd == 0.... unless you're using threads.
02:36:32 <ab9rf> if you're using threads and don't mutex all file operations on that critical section, you get a race condition (what if another thread opens a descriptor?)
02:36:48 <EvanR> i refuse to do anything with threads, why do you think im forking ;)
02:37:57 <ab9rf> i honestly do not recall how threads and forking interact :)
02:38:10 <EvanR> "its complicated"
02:38:45 <ab9rf> i have written multithreaded code in C, but it has been a LONG time and most of it didn't really work right :)
02:39:04 <mniip> how the hell does lens work...
02:39:38 <mniip> I mean I can continue substituting (a -> x b) -> s -> x t into different places and get expected results but just wow
02:40:03 <ab9rf> mniip: i think it involves the blood of virgins and dark pacts with several different demons of the eighth circle of hell.
02:40:20 <EvanR> it might help to read that as (a -> x b) -> (s -> x t)
02:40:26 <xandaros> took me a long time to even see the point of lenses, but I still think it is overly complicated...
02:41:18 <mniip> EvanR, I don't have issues interpreting that type as either of the representations
02:41:18 <merijn> mniip: edwardk has  a two hour long talk on youtube :)
02:41:23 <xandaros> I probably just don't fully understand them
02:41:43 <mniip> well I do undestand lenses now, I just don't understand how do they work
02:41:45 <jtanguy> there's also a nice talk about lens from spj
02:41:48 <merijn> mniip, xandaros: http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
02:42:43 <xandaros> merijn: Thanks; can't watch that right now, but I'll watch it when I get home
02:44:28 <ab9rf> i freely admit to not understanding lenses
02:44:40 <ab9rf> i also admit to not having tried to understand them
02:46:05 <xandaros> I'm doing some web stuff with snap and they use lenses about as much as they possibly can, so I am exposed to lenses a lot. Never realy used them myself, though, only passed them to functions expecting them
02:46:44 <mniip> ooo
02:46:59 <phaazon> hm
02:47:03 <mniip> writing the type as "Lens picture picture' element element'" makes more sense
02:47:12 <phaazon> I don't understand how « at », in netwire, builds an Event a
02:47:35 <phaazon> or I guess it forwards its input into the output?
02:47:43 <phaazon> Wire s e m a (Event a)
02:47:58 <phaazon> if the time is beyond the parameter of at
02:48:07 <phaazon> it forwards the a parameter into the EVent
02:48:09 <phaazon> Event=
02:48:09 <NightRa> Is there a nicer way to write (.).(.).(.)...?
02:48:19 <EvanR> :t (.:)
02:48:20 <lambdabot>     Not in scope: ‘.:’
02:48:20 <lambdabot>     Perhaps you meant one of these:
02:48:20 <lambdabot>       ‘.’ (imported from Data.Function),
02:48:25 <EvanR> .: .:: .:::
02:48:27 <phaazon> otherwise, inhibit
02:48:30 <phaazon> :t (:.)
02:48:31 <lambdabot>     Not in scope: data constructor ‘:.’
02:48:31 <lambdabot>     Perhaps you meant one of these:
02:48:31 <lambdabot>       ‘:+’ (imported from Data.Complex),
02:48:41 <mniip> @unpl (.).(.).(.)
02:48:41 <lambdabot> (\ l b c f i -> l (b c f i))
02:51:05 <NightRa> It's in Data.Composition. Thank you!
02:52:21 <Qfwfq> NightRa: See also https://hackage.haskell.org/package/functor-infix
02:53:11 <NightRa> Qfwfq: Nice.
03:02:21 <kqr> how can I find the source of an instance of a typeclass in hackage haddocks?
03:02:30 <kqr> I'm specifically looking for the source of Num Float
03:02:42 <kqr> or double, for that matter
03:04:06 <mniip> http://hackage.haskell.org/package/base-4.7.0.2/docs/src/GHC-Float.html#instance%20Num%20Float
03:04:26 <mniip> (plusFloat and friends are defined in the same module)
03:04:42 <kqr> ah, thank you
03:06:41 <phaazon> hm
03:06:51 <phaazon> that's funny how Auto, from Arrow, closely looks like State
03:08:25 <jle`> data Auto a b = forall s. Auto (a -> s -> (b, s))
03:08:34 <jle`> s -> (b, s) is just State s b
03:08:47 <jle`> and a -> s -> (b, s) is a -> State s b
03:09:04 <jle`> so Auto sort of represents a kleisli arrow on State s...with a hidden s
03:09:30 <jle`> data Auto a b = forall s. Auto (a -> State s b)
03:10:00 <jle`> um both of those types should haev an `s` as a second field
03:11:18 <phao> damn.... 1526 people!!!!
03:11:27 <phao> I didn't know haskell was so popular...
03:11:43 <tdammers> haskell is the most popular off-mainstream language :D
03:11:50 <phao> hehehehe
03:17:06 <jaseemabid> I was working on a tiny lisp interpreter all alone and even though its going slow, its shaping up. Anyone here mind going through the code and give me a few comments on it? Its just ~250 LOC.
03:17:16 <jaseemabid> https://github.com/jaseemabid/lisper
03:18:23 <jaseemabid> Any sort of comments, nit picks, whatever is more than welcome. For example, I'm not sure how to start writing tests for this, be it unit or quickcheck. Any pointers would be welcome.
03:21:03 <bennofs> jaseemabid: in Main.hs, why don't you just omit the >> exitSuccess in parseArgs and the >>= putStr in main?
03:23:09 * hackagebot matrix 0.3.4.2 - A native implementation of matrix operations.  http://hackage.haskell.org/package/matrix-0.3.4.2 (DanielDiaz)
03:23:39 <danilo2> Hello! :) Is it possible to generate in TemplateHaskell another Template haskell that would reify the thing generated by the first one?
03:26:44 <init> jaseemabid: I'd use Except and State in eval
03:26:46 <jaseemabid> bennofs: Because exitSuccess is the default behavior of the script?
03:27:10 <bennofs> jaseemabid: ah, but the >>= putStr is redundant, isn't it?
03:27:28 <jaseemabid> init: I know I'll have to use some state soon, not there yet. No mutation/state so far. Evaluating a series of expressions work, but not a repl.
03:27:59 <jaseemabid> bennofs: Yes, it looks like it now.
03:28:01 <init> jaseemabid: I'd factor out exitSuccess to main, (instead of repeating it in the cases)
03:28:22 <bennofs> also, I think exitSuccess is the default for haskell programs, so it should not be needed
03:28:36 <kqr> jaseemabid, between open close p matches open, followed by p and close. returns the value returned by p
03:28:52 <kqr> jaseemabid, useful for parsing things (inside parens) or "surrounded by quotes"
03:29:25 <init> jaseemabid: (State s a) is basically a nice wrapper over (s -> (a,s))
03:29:53 <dramforever> init: in haskell basically anything we normally use is a nice wrapper over something else
03:30:34 <tzaeru> doesn't that end up increasing the amount of details and specs that you need to be aware of?
03:30:36 <init> dramforever: don't spoil the fun! :P
03:30:54 <tdammers> it's wrappers all the way down
03:31:06 <dramforever> init: sorry :P
03:31:48 <tdammers> but no, the whole point of those abstractions is to bundle a bunch of lower-level details into something that has consistent semantics itself
03:31:59 <dramforever> tdammers: softwares are nice wrappers over the machine
03:32:03 <tdammers> dramforever: that, too
03:32:08 <dramforever> tdammers: yeah, agreed
03:32:28 <tzaeru> well, "it's wrappers all the way down" is certainly not what I meant..
03:32:38 <dramforever> s/machine/hardware/, just looks cleaner
03:32:39 <tdammers> I know
03:32:45 <dramforever> I know, too
03:32:51 <tzaeru> why be a smartass about it then? :P
03:32:58 <dramforever> okay, back to "serious business"
03:33:16 <jaseemabid> bennofs: Had to rename `parseArgs :: [String] -> IO a` to `parseArgs :: [String] -> IO ()`
03:33:20 <tdammers> tzaeru: wasn't meant to be smartass, just a semi-funny stab
03:33:30 <dramforever> tzaeru: it *does* increase, but lazily
03:33:55 <dramforever> you only need to be aware of that detail if you look at it
03:34:12 <tzaeru> mmh, I'm somehow always appreciated minimalism in language (and in framework and in everything's) design
03:34:26 <tzaeru> well, if you work with say, 10 other programmers, you generally end up having to be aware of almost all details that may be getting used.
03:36:28 <kqr> less so with haskell than other languages in my experience
03:36:37 <kqr> because type systems and equational reasoning and all that
03:37:21 <jaseemabid> bennofs: https://github.com/jaseemabid/lisper/commit/33aff18eff833dc72c4acb42a14b0692cbb32c3d
03:37:26 <init> I'd say Haskell abstractions are easier to deal with because they are really constrained to what they should do (type system + purity)
03:40:28 <jaseemabid> init: Where can I learn more about State?
03:42:05 <merijn> jaseemabid: The best way is to implement it yourself, IMO
03:42:12 <dramforever> jaseemabid: 1. (no insults) Ha ha, return 0 from C :P (really no insults. sorry if it hurts you)
03:42:24 <dramforever> 2. I think you have problems parsing arguments. right?
03:42:24 <merijn> jaseemabid: i.e., try and implement these functions: https://gist.github.com/merijn/098106abd45c940dab09
03:42:54 <phaazon> jaseemabid: what merijn said
03:43:01 <phaazon> a State is nothing more than a function ;)
03:44:06 <jaseemabid> merijn: I'll try.
03:44:19 <dramforever> jaseemabid: oh sorry...your new code seems good
03:45:46 <jaseemabid> I thought a lot about quick test. For eg, eval any lisp exp in a let block and it should not modify the env it was invoked in. It looks like a property that will hold. But I have no clue how to write a generator, which will generate arbitrary progns.
03:47:12 <jaseemabid> Unit tests might be more viable than quicktest.
03:47:31 <dramforever> jaseemabid: yeah, exactly what I was typing 5 secs ago :P
03:48:00 <jaseemabid> Testing is at the moment high priority. Also, trying to be compatible with scheme soon so that I will have sample code to test.
03:48:10 <jaseemabid> dramforever: Thanks!
03:48:15 <dramforever> quick check is more suitable for stuff like Data.Map and Data.Set
03:48:40 <dramforever> where large numbers of random data is needed to test for correctness
03:49:08 <tdammers> with something like a lisp interpreter, I'd start with simulation tests, not necessarily unit / property tests
03:49:26 <jaseemabid> dramforever: There are some lazy bits, which could use a lot of testing to be sure. PS, its mostly lazy at the moment.
03:51:32 <bennofs> tdammers: what are simulation tests?
03:51:52 <dramforever> tdammers: you mean compare it with another implementation?
03:51:54 <jaseemabid> There is some hunit specifics which I have to figure out.
03:52:12 <jaseemabid> dramforever: That would be 'reference testing'>
03:52:17 <fractalsea> Is there a nicer way of composing a function that takes 1 argument with a function that takes multiple ones? Other than ((.).(.)) and ((.).((.).(.))) etc?
03:52:32 <merijn> fractalsea: Just writing out the arguments
03:53:11 * hackagebot amqp 0.12.1 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.12.1 (HolgerReinhardt)
03:53:30 <fractalsea> merjin: ok, I just thought “unsubscribeAuthMsg channel appKey signature userData = unsubscribeMsg $ authData channel appKey signature userData” was so verbose
03:53:57 <dramforever> jaseemabid: uh..just a small suggestion: maybe typing q to quit is not good. If some user sets p to 1, q to 2 and he/she checks q, he/she will get really confused
03:54:26 <jaseemabid> dramforever: `quit` then?
03:54:43 <bennofs> jaseemabid: :q? or maybe /q ?
03:54:47 <fractalsea> merjin: compared to something like “unsubscribeAuthMsg = unsubscribeMsg `com4` authData”
03:55:08 <jaseemabid> dramforever: I could never get piping from shell like echo "(+ 1 1)" |lisper and repl work at the same time. Some shell buffering issues.
03:55:12 <augur> is there a standard parsec way of doing character escaping?
03:55:39 <dramforever> jaseemabid: You get a End of file Exception, right?
03:55:45 <dramforever> s/a/an/
03:55:48 <merijn> fractalsea: You can always use shorter variable names
03:56:24 <jaseemabid> dramforever: I dont recall the exact error. Lack of state + not so great repl made me never use repl.
03:56:52 <jaseemabid> I would just go with exec "(+ 1 1)" in the inferior-haskell buffer. Worked well so far.
03:57:03 <fractalsea> merjin: Yeah fair enough. It doesn’t feel very elegent producing it, but composing composition operators is definitely too unreadable and unintuitive
03:57:05 <danilo2> Hello! :) Is it possible to generate in TemplateHaskell another Template haskell that would reify the thing generated by the first one?
03:57:24 <augur> ahh nevermind, i got something that works
03:58:01 <dramforever> danilo2: maybe you could just call the other one?
03:58:47 <danilo2> dramforever: nope, it does not find the code generated by first one
03:59:48 <dramforever> you mean like [q1| [q2| foo |] |]? then no...sorry I'm not really familiar with TH stuff
03:59:56 <dramforever> just trying to be helpful
04:04:00 <gfixler> Prelude λ :t return 6
04:04:01 <gfixler> return 6 :: (Monad m, Num a) => m a
04:04:27 <gfixler> Prelude λ return 6
04:04:28 <gfixler> 6
04:05:09 <gfixler> is that second one treating return 6 as IO?
04:05:30 <shlevy> gfixler: I think so, ghci has you in the IO monad
04:05:36 <gfixler> shlevy: that was my guess
04:05:44 <gfixler> I can return anything, and it just prints it out
04:05:52 <gfixler> return "foo" -> foo
04:05:58 <gfixler> figured it was deciding on the IO monad
04:06:09 <gfixler> but just getting it's type keeps it generic as Monad m
04:07:31 <dramforever> IMHO (Monad m => m a) and (Num a => a) are bad, until they gets specialized
04:07:37 <dramforever> s/gets/get/
04:07:45 <gfixler> bad?
04:07:59 <dramforever> gfixler: well, Num a => a is worse
04:08:06 <gfixler> baddest type constraints in the whole damn town?
04:08:12 <dramforever> no
04:08:22 <dramforever> gfixler: I mean some value with such a generic type
04:08:29 <dramforever> :t 1
04:08:30 <lambdabot> Num a => a
04:38:16 * hackagebot multiarg 0.30.0.2 - Command lines for options that take multiple arguments  http://hackage.haskell.org/package/multiarg-0.30.0.2 (OmariNorman)
05:12:53 <xpika> does anyone know how to get this to typecheck ?
05:13:06 <xpika> with rank N types? (\q -> show (q (+1) [1]) ++ show (q (+1) (Just 1))) fmap
05:13:34 <rui> cabal haddock --hyperlink-source   gives docs with link to sources that, when clicked, show "file not found". Does this smell like a common stupid newbie obvious mistake I am making?
05:13:55 <xpika> should output "[2]Just 2"
05:14:30 <merijn> xpika: You need explicit type annotations for RankNTypes
05:14:46 <merijn> xpika: RankNTypes can't be inferred, because their inference algorithm is undecidable
05:15:02 <merijn> xpika: So replace your lambda with a named function with an explicit RankNType and it should work
05:15:48 <phaazon> merijn: do you think it's possible to use ArrowLoop to make a Wire loop?
05:15:51 <phaazon> instead of
05:16:03 <phaazon> myWire = render . asSoonAs . onKey --> myWire
05:16:57 <merijn> Why not just use the Monad instance of Wire?
05:17:44 <phaazon> hm
05:18:10 <phaazon> because it's not, merijn
05:18:31 <phaazon> it's only Applicative
05:18:58 <merijn> Oh, I was confusing ArrowLoop and ArrowApply
05:20:12 <lpaste> merijn pasted “RankNTypes” at http://lpaste.net/120767
05:20:22 <merijn> xpika: That compiles and runs for me
05:20:38 <phaazon> anyway, netwire rocks so hard §§§
05:20:57 <phaazon> I find it interesting that he can be used with realtime application
05:21:02 <phaazon> because it uses Either a lot
05:21:14 <phaazon> I've always thought Either was not designed for performance purpose
05:21:28 <xpika> merijn: thanks
05:23:19 * hackagebot gitdo 0.1.0.0 - Create Github issues out of TODO comments in code  http://hackage.haskell.org/package/gitdo-0.1.0.0 (MatthewHall)
05:26:57 <vin-ivar> hey
05:27:07 <vin-ivar> any way I can use CmdArgs
05:27:14 <vin-ivar> to accept arguments without requiring a flag?
05:27:28 <vin-ivar> like, runhaskell stuff.hs abc def
05:27:38 <vin-ivar> rather than runhaskell stuff.hs -a abc -b def
05:28:09 <merijn> vin-ivar: Perhaps you want optparse-applicative? I've found that to be easier to use
05:29:10 <jtanguy> there are argsPos n and args in CmdArgs
05:29:44 <vin-ivar> doesn't it also require flags?
05:30:10 <merijn> vin-ivar: I've written optparse-applicative parsers taking bare arguments
05:30:33 <merijn> CmdArgs has slightly too much magic for my comfort
05:31:08 <tdammers> bennofs: simulation tests? run the entire thing in a simulated environment, and verify its behavior
05:31:40 <tdammers> e.g. for a compiler, a suitable simulation test would be to run it on a set of input files, and verify that the compiled binary matches your expectations
05:31:58 <tdammers> or for an interpreter, you'd feed it some input and verify that it does the right thing
05:32:25 <vin-ivar> thanks, merijn, jtanguy
05:32:28 <vin-ivar> i'll give them both a look
05:32:29 <vin-ivar> cheers
05:32:35 <tdammers> for a web API, you'd run a series of HTTP requests against it and verify that the responses meet your expectations
05:32:41 <bennofs> tdammers: isn't that what HUnit tests for a lisp evaluator would do
05:32:49 <tdammers> probably, yes
05:32:56 <tdammers> but they wouldn't be unit tests
05:33:03 <tdammers> despite the name "HUnit"
05:33:20 <tdammers> a unit test would do the same thing for an individual function
05:33:55 <tdammers> but in a language like Haskell, it's a bit harder to even identify what your "units" are and what their "dependencies" are, let alone how to stub them
05:34:31 <merijn> tdammers: I think this whole TDD/unit testing craze has left everyone unfamiliar with any other type of term/test
05:34:55 * merijn relies mostly on simulation/integration testing
05:34:59 <tdammers> merijn: yes. but I value precise language too much to accept it
05:36:02 <tdammers> "here's a unit test that deploys a docker container, starts up the web application, and then performs a series of tests on it using PhantomJS"
05:36:04 <merijn> tdammers: I wasn't saying you were wrong to be pedantic :p
05:36:17 <tdammers> merijn: "pedantic" is such an ugly word
05:36:23 <tdammers> merijn: it's dual to "pragmatic"
05:36:44 <ski> (dual ?)
05:37:15 <arw_> from the space formed by transformations between the elements.
05:37:22 <merijn> oh, and regression testing, of course
05:37:34 <bennofs> Does anyone know a way to improve the accurrancy of criterion benchmarks? I get a R² between 0.985 and 1.000 which according to the tutorial is very bad
05:38:22 <quchen2> rui: I might be a bit late, but do you have hscolour installed? I'm not sure what Haddock does with --hyperlink-source if you don't. hscolour is the tool Haddock uses to generate pretty source output.
05:38:25 <ski> arw_ : i was thinking more of in the sense of CT
05:39:40 <tdammers> ski: haha...
05:39:48 <tdammers> ski: CT much, do you?
05:40:17 <ski> well, it can be fun
05:40:19 <tdammers> "dual" in the sense of "opposite, but in the same domain and along the same axis" or sth like that
05:40:38 <tdammers> both are ugly words that are abused a lot these days
05:40:45 <arw_> ski: the CT usage of dual is a bit weird imho.
05:40:59 * ski has lately been thinking a bit about user-friendlier proofs
05:41:20 <ski> (well, or rather proof notations and calculi)
05:42:33 <kgadek> hi. learning about uniplate right now, the question: is there any run-time performance penalty?
05:43:14 <kgadek> I mean: does it any run-time introspection? or is it all compile-time?
05:43:26 <ski> arw_ : hm .. i think it accords with dual connectives in logic
05:43:34 <bennofs> Ok, looking at the html output, I can see that there is a spike between 3 iterations and 4 iterations :|
05:43:50 <bennofs> after that, the measurements lie pretty much on a straight line
05:44:00 <bennofs> but the slope is much greater from 1-3 iters
05:45:08 <phaazon> hm
05:45:38 <phaazon> how can I write a Wire that consumes its input, like (+1)?
05:45:44 <phaazon> using the Applicative interface?
05:45:58 <phaazon> that sounds wrong
05:46:06 <phaazon> I guess it's from the Arrow interface
05:46:08 <phaazon> I don't know
05:46:33 <merijn> kgadek: afaik uniplate is runtime and not particularly fast
05:47:15 <kgadek> merijn: hmm are there any semi-generic libs there that… I don't know, exploit typeclasses to do all work compile-time?
05:48:15 <merijn> Depends on whether what you're trying to do is even possible at compile-time
05:48:21 <phaazon> or using mkPure_?
05:48:22 <rui> quchen2 It was exactly that! Thanks!
05:49:56 <kgadek> merijn: that's required, yes. Assuming the above, do we have any choice or I'd need to implement it by myself (would rather not do that)?
05:51:20 <quchen2> rui: Did Haddock not complain in its output  la "hscolour missing"?
05:51:30 <quchen2> Might be worth a ticket if it did not
05:52:11 <kgadek> merijn: watching https://skillsmatter.com/skillscasts/4250-uniplate and Neil Mitchell at 31:36 tells that it's very performant. I'm confused
05:52:47 * frerich reading the latest posts on haskell-hanoi@ with great interest.
05:53:43 <rui> quchen2 I think it didn't, but its too late to check
05:55:23 <arw_> ski: i guess i'm just confused whenever dual happens to be the same or almost the same as inverse or opposite.
05:55:44 <arw_> ski: because in most cases its not.
05:56:09 <ski> (in CT it's not the same as opposite)
05:58:05 <ab9rf> category theory has always felt a bit too meta for me to fully accept
05:58:21 * hackagebot docopt 0.6.0.2 - A command-line interface parser that will make you smile  http://hackage.haskell.org/package/docopt-0.6.0.2 (ryanartecona)
05:58:57 <ab9rf> "that will make you smile"?  really?  is that warranteed?
05:59:42 * ski smiles
06:03:21 <Fusebox> I have a function: flipH :: Picture -> Picture; flipH = reverse
06:03:27 <Fusebox> and get an indention error
06:03:28 <Fusebox> why?
06:03:53 <Fusebox> "parse error (possibly incorrect indentation or mismatched brackets)
06:04:12 <ski> do you have a literal `;' in your source ?
06:04:19 <Fusebox> no
06:04:30 <ski> check whether stuff are aligned properly
06:04:31 <mauke\> Fusebox: you might have incorrect indentation or mismatched brackets
06:04:44 <ski> you could try pasting your code (including surrounding code)
06:04:46 <ski> @paste
06:04:47 <lambdabot> Haskell pastebin: http://lpaste.net/
06:04:48 <ab9rf> i'm going to go with mauke\ here and say that you likely have incorrect indentation or mismatched brackets.
06:05:49 <Fusebox> I'll do the paste. There are no brackets, and no extra whitespace. I've never written a function without explicit use of arguments before, but it's like that in the textbook.
06:06:09 <ski> that ought not to be the problem
06:06:13 <ab9rf> indeed
06:06:19 <mauke\> include the actual, full error message
06:06:33 * merijn is putting $10 on tabs
06:06:57 <Fusebox> I've got my editor to convert all tabs to spaces automatically
06:08:22 * hackagebot OpenGLRaw 2.2.0.0 - A raw binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGLRaw-2.2.0.0 (SvenPanne)
06:08:24 * hackagebot path-pieces 0.2.0 - Components of paths.  http://hackage.haskell.org/package/path-pieces-0.2.0 (MichaelSnoyman)
06:08:26 * hackagebot yesod-core 1.4.8.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.8.1 (MichaelSnoyman)
06:08:43 <lpaste> Fusebox pasted “weird error” at http://lpaste.net/120768
06:09:06 <mauke\> Fusebox: missing ]
06:09:16 <Fusebox> I knew I'd be facepalming
06:09:21 <Fusebox> ty
06:09:33 <mauke\> "There are no brackets"
06:09:44 <Fusebox> I was thinking of function composition brackets :(
06:10:01 <mauke\> http://i0.kym-cdn.com/entries/icons/original/000/005/498/1300044776986.jpg
06:10:24 <ab9rf> mismatched bracket it is
06:10:39 <ab9rf> there are always brackets
06:10:58 <Fusebox> it's 1am here :(
06:11:12 <ab9rf> it's -8 here
06:11:26 <ab9rf> i can't feel my toes
06:11:45 <Clint> but at least it's not humid
06:11:51 <Jello_Raptor> ab9rf: D:
06:12:44 <ab9rf> 61% relative humidity at the last record report
06:12:50 <ab9rf> dewpoint -17
06:13:22 * hackagebot html5-entity 0.1.0.1 - A library for looking up and validating HTML5 entities.  http://hackage.haskell.org/package/html5-entity-0.1.0.1 (zudov)
06:14:18 <ajcoppa> ab9rf: yep, 0 here, wind chill -16 F :(
06:14:51 <ab9rf> sref has us getting up to 2 by 2100
06:15:19 <ab9rf> maybe even as high as 4
06:15:44 <ab9rf> ajcoppa: wind chill is a nonreal measurement anyhow
06:16:02 <tdammers> ab9rf: no, it's not...
06:16:10 <ajcoppa> my face sure thinks it's real!
06:16:25 <ajcoppa> regardless, It's Cold
06:16:29 <ab9rf> it's a mathematical model based on experimental data collected in the 1950s by explorers in the antarctic freezing plexiglas cylinders full of water
06:17:02 <ab9rf> unless you are, in fact, a plexiglas cylinder of water in antarctica, it's not really relevant.
06:17:21 <tdammers> ab9rf: who says I'm not?
06:17:57 <haasn> How unscientific. They should have done the experiments with freezing humans in the antarctic
06:17:59 <ab9rf> the concept that wind makes cold temperatures more dangerous is valid, but there is no meaningful reality to the formula used.
06:18:11 <joeyh> -15 forecast for tonight. brr
06:19:27 <nshepperd> surely it's a better approximation than ignoring wind completely
06:19:33 <tdammers> hmm, I thought the windchill thing was based on how the air around the human body heats up, which effectively makes cold weather less cold when there's no wind
06:20:07 <haasn> Surely wind speed has a non-negligible effect on temperature transfer, otherwise we wouldn't be using high speed fans inside every PC
06:20:28 <hodapp> I don't know that that is sufficient to say that there is "no meaningful reality".
06:20:53 <frerich> tdammers: Indeed, air is a very poor conductor for heat i.e. it isolates rather well. When there's no wind, the isolation won't be blown away. Which is also why - if you find yourself in antarctica without suitable clothing, you should not jump into water even if it's not freezing.
06:21:01 <frerich> ...because water is a much better conductor for heat.
06:21:02 <ab9rf> tdammers: that's not entirely inaccurate
06:21:20 <ab9rf> still air is an excellent heat insulator
06:21:22 <hodapp> frerich: Well, damn, there go my plans for Friday night.
06:21:34 <haasn> When stuck in antarctica, you should deform yourself into a perfect sphere to minimize surface area
06:21:55 <tdammers> haasn: I have a better plan: don't get stuck in antarctica
06:21:57 <ab9rf> the problem is that the formula leads to silly numbers
06:22:08 <tdammers> it's an approximation, yes
06:22:14 <ab9rf> a windchill of -60 is nowhere near as dangerous as an actual tmperature of -60
06:22:23 <hodapp> they should call it something else then
06:22:27 <hodapp> like maybe "windchill"
06:22:50 <tdammers> hodapp: the problem isn't the name, the problem is that they express it in the same units as actual temperature
06:22:56 <ab9rf> tdammers: that's exactly the problem
06:23:04 <ab9rf> if they just used risk categories
06:23:10 <ab9rf> "slight" "moderate" "high" "extreme"
06:23:12 <tdammers> yeah
06:23:26 <hodapp> everywhere I've seen it used, they always put "feels like" by the windchill to clarify
06:23:28 <tdammers> or something like a Richter scale, or good old Beaufort
06:23:46 <haasn> “slight”, “moderate”, “high”, “extreme”, “viking”
06:23:59 <ab9rf> it would convey the purpose (warning the public of risk) more effectively without creating undue panic or confusion
06:24:04 <tdammers> "pleasant", "mildly chilly", "chilly", "cold", "bloody fucking cold", "shrink your nuts to the size of a raisin and then some cold"
06:24:06 <flux> hmm, isn't the 'meaning' of the number the amount of energy that flows out from you when you remain still?
06:24:11 <flux> I suppose it depends on many factors of course :)
06:24:13 <tdammers> anyway, idk
06:24:17 <ab9rf> flux: no, it's not calibrated in any such way
06:24:21 <hodapp> ab9rf: "undue panic"? Have you ever even been in some cities when there is rain or snow involved?
06:24:27 <haasn> flux: °C is not a measure of the amount of energy that flows out from you, in the first place
06:24:29 <tdammers> I use windchill indications to judge what I should be wearing when going out for a run
06:24:33 <hodapp> ab9rf: it's not the windchill figure causing the panic
06:24:37 <tdammers> and for that, it works pretty well
06:24:42 <flux> haasn, it is not, but it is highly correlated :)
06:24:50 <ab9rf> flux: it's too hard to parameterize that because it is so dependent on exactly how you're dressed, on the humiudity as well as temperature, the exact wind speed, and too many other factors
06:24:51 <nshepperd> maybe it should be calibrated that way
06:25:13 <flux> ab9rf, so you're saying it should be dumbed down a bit.. ;-)
06:25:17 <haasn> flux: It's a contributing factor, I guess
06:25:30 <nshepperd> since kJ/hour is what actually matters as far as odds of dying of hypothermia
06:25:44 <haasn> The rate of energy transfer is dependent on the difference in temperature *and* the thermal conductivity, right?
06:25:50 <ab9rf> flux: imo -20 with no wind (which is  wind chill of -20) should be just as dangerous as a wind chill of -20.  but it's not
06:25:56 <nshepperd> divided by body weight I guess
06:26:11 <ab9rf> flux: -20 WC is nowhere near as dangerous as -20 with no wind
06:26:31 <ab9rf> and it gets worse the more negative the numbers go
06:26:48 <haasn> There's also a difference between subjective perception and objective danger
06:27:32 <haasn> I would consider a scale of how cold something *feels* to be useful, but I have no idea if that's related to windchill
06:27:39 <ab9rf> also, iirc the cooling effect of wind is not much different at 15 mph as it is at 35 mph
06:27:55 <ab9rf> although that's probably not true if you're wearing certain clothing
06:28:09 <ab9rf> the exact type of attire worn has a huge impact
06:28:38 <ab9rf> haasn: there are some things like that, the trademarked RealFeel that i think accuweather uses fore xample
06:28:59 <ab9rf> but the algorithm for computing RealFeel is a trade secret
06:29:24 <hodapp> "the perceived decrease in air temperature felt by the body on exposed skin due to the flow of air"
06:29:28 <haasn> they let their researchers stand outside naked and count how many swear words they utter per minute
06:29:39 <hodapp> 'perceived'
06:29:42 <hodapp> 'exposed skin'
06:29:48 <hodapp> 'felt'
06:29:53 <ab9rf> hodapp: people are fairly poor at "perceiving" temperature
06:30:04 <nshepperd> thermoception is pretty complicated
06:30:41 <ab9rf> although i can tell you that it's probably about 67 or 68 in here right now
06:31:19 <haasn> We perceive heat, not temperature, right?
06:31:49 <tdammers> haasn: not even that.
06:31:50 <ab9rf> haasn: i'm not sure how thermoception works physiologically
06:31:52 <hodapp> ab9rf: I'm not sure what that matters, since that definition has nothing to do with temperature, but perceived temperature.
06:31:55 <qz> i had to look up channel name to make sure its still #haskell ...
06:32:03 <ab9rf> heh, we are indeed off topic :)
06:32:09 <KaneTW> #hascool
06:32:18 <hodapp> #haskchill
06:32:19 <tdammers> actual temperature is a factor, but the current state of affairs wrt various physiological processes also plays a role
06:32:59 <Kron> #haskhell
06:33:06 <tdammers> e.g., when you're developing a fever, you'll start freezing; this is to make you dress warmer or find a warmer spot to help ramp up core temperature
06:33:11 <haasn> ab9rf: “The details of how temperature receptors work are still being investigated.” seems you're not the only one
06:33:17 <tdammers> it's an evolutionary feature we inherit from reptiles
06:33:23 * hackagebot yesod-auth-basic 0.1.0.0 - Yesod Middleware for HTTP Basic Authentication  http://hackage.haskell.org/package/yesod-auth-basic-0.1.0.0 (ChristopherReichert)
06:33:24 <hodapp> tdammers: I have a lot of those.
06:33:30 <ab9rf> i'm reading a medical school article on it right now, and it's fairly complicated
06:33:33 <tdammers> once you've reached "target temperature", you'll feel normal again
06:34:12 <tdammers> and, vv., when you take fever-reducing medication, like paracetamol, you'll often start sweating profusely when the meds kick in
06:34:33 <ab9rf> there's a variety of thermoceptors that have temperature-sensitive firing rates (some fire faster as they get warmer, others fire faster as tehy get colder)
06:34:41 <tdammers> so basically, an important function of thermoception is to regulate body temperature
06:34:53 <ab9rf> above 45C and below 5C +/- the nociceptors get into the game too
06:34:58 <tdammers> but it's not the only one, obviously
06:35:16 <tdammers> ab9rf: that's where you start feeling pain from extreme temperatures, ya?
06:35:28 <ab9rf> tdammers: yes, hence the term "nociceptor" (noci = pain)
06:35:34 <tdammers> duh :D
06:35:42 <tdammers> oh, and humidity also plays a huge role I think
06:35:56 <ab9rf> humidity is a more complex perception
06:35:58 <haasn> tdammers: I'm reminded of color perception. There's a certain physical process that happens in our eyes, which is capable of perceiving, for example, a gradient between opposite colors (eg. a yellow-white-blue gradient). Actually figuring out which of these gradient steps coresponds to “neutral” (eg. white) is a complex psychological process that depends on many factors
06:35:59 <frerich> As far as survivability goes, the 'perceived' temperature is quite irrelevant. Not only because at some point (very warm and very cold) people can't tell the temperatures apart, but also because what you're used to influenes whether something feels particularly hot or cold. For survivability, the only thing that matters is to reduce the rate at which your body loses heat (which means: more time for rescue to find
06:35:59 <frerich>  you), which means - you have to surround yourself with a bad conductor.
06:36:05 <byorgey> this is a truly fascinating conversation, but maybe it should be taken to #haskell-blah please
06:36:22 <frerich> tdammers: humidity improves the rate at which air can conduct heat.
06:36:23 <tdammers> I know this because I can run barefoot on frozen ground if it's cold, but when the ground is wet, anything below 5°C is kind of unpleasant
06:36:36 <haasn> tdammers: This seems similar to the temperature scenario, where we have a perception of “neutral”, “hot” and “cold” on some scale, which is internally derived by the brain from the raw measurement (hot-cold gradient) by a complex psychological process
06:36:37 * frerich shuts up now
06:36:42 <haasn> Let's move to #-blah
06:36:51 <tdammers> oh this isn't -blah, sorry :x
06:36:58 <tdammers> thought it was
06:37:02 <bennofs> lol
06:37:14 <ab9rf> hurrr
06:50:21 <Yushatak> hey - i need to translate a haskell98 script (works on 2014) to f# for something work-related. it's fairly short - is there anyone here who would be willing to either translate it to f# (ideal) or help me comprehend how it works so that i can do so myself
06:50:57 <Yushatak> script in question: http://www.allisons.org/ll/FP/Haskell/1998/Edit01/
06:51:34 <Yushatak> i can't even seem to get it to compile as a stand-alone exe, only in interactive mode
06:51:41 <Yushatak> so i'm feeling pretty fail-ful here
06:52:08 <Yushatak> i tried adding a second script with a Main function, but it threw errors - tried converting this script to be/use a main function, and similar errors
06:53:00 <mauke\> url blocked by antivirus
06:53:25 * hackagebot yesod-auth-basic 0.1.0.1 - Yesod Middleware for HTTP Basic Authentication  http://hackage.haskell.org/package/yesod-auth-basic-0.1.0.1 (ChristopherReichert)
06:53:55 <ab9rf> Yushatak: the article says the original was written in Lazy ML, perhaps you'd have better luck translating it from that?
06:54:08 <ab9rf> or just get the journal article
06:54:11 <Yushatak> ab9rf: that version made even less sense, and from what i can tell that language is very dead
06:54:29 <Yushatak> ab9rf: i was under the impression that the lazy ML page was the journal article
06:55:14 <ab9rf> it would appear so, yes
06:55:35 <Yushatak> it didn't have sufficient language to make me understand the concepts well enough to write something based on them myself
06:55:56 <merijn> Yushatak: As far as I can tell you won't be able to translate that to F#
06:55:57 <Yushatak> i understand that you iterate the diagonals starting from the center and stop (presumably) when the values start rising
06:56:02 <ab9rf> is F# lazy?
06:56:04 <ab9rf> i don't use F#
06:56:07 <merijn> Yushatak: It uses lazines for efficiency
06:56:07 <Yushatak> it has the option to be lazy
06:56:18 <merijn> Ah, then maybe it might work
06:56:35 <Yushatak> there's a Lazy<T> "wrapper" that makes things evaluate lazy
06:56:35 <ab9rf> this algorithm appears to rely on laziness
06:56:36 <Yushatak> for any type
06:56:45 <merijn> Yushatak: May wanna read this instead: http://jelv.is/blog/Lazy-Dynamic-Programming/
06:56:49 <Yushatak> yeah that's the point, currently we are using a standard levenschtein distance
06:57:15 <merijn> Yushatak: That's an explanation of dynamic programming in haskell that is easier to read
06:57:42 <dulla> leven... distance
06:57:48 <dulla> approximate string matching?
06:57:57 <ab9rf> edit distance computation
06:58:03 <dulla> close enough
06:58:20 <merijn> dulla: It's an "edit distance" metric, which are commonly used for approximate matching, yes
06:58:26 * hackagebot octohat 0.1.2 - A tested, minimal wrapper around GitHub's API.  http://hackage.haskell.org/package/octohat-0.1.2 (stackbuilders)
06:58:34 <dulla> is it the one that counts adds/deletes, or the one that does adds/deletes/swaps, merijn ab9rf
06:58:35 <Yushatak> we're using it for ranking DNA string searches
06:58:35 <ab9rf> d "acgtacgtacgt" "acatacttgtact" == 4
06:58:38 <merijn> In that "smaller edit distance" == better match
06:58:48 <Yushatak> and we'll be doing hundreds of thousands of comparisons
06:58:49 <merijn> dulla: I always forget :p
06:58:52 <Yushatak> so optimziation is important
06:58:56 <merijn> Yushatak: Did you start reading my link?
06:59:02 <Yushatak> yes i did
06:59:12 <ab9rf> dulla: this counts an insert, delete, or replacement as 1
06:59:29 <ab9rf> dulla: there's anmother one that counts a replacement as 2 (insert + delete), but that's not this one
06:59:32 <merijn> That should explain how to use laziness for this, I'm assuming your initial link roughly counts the same
06:59:43 <dulla> kk
06:59:58 <ab9rf> dulla: the algorithms are essentially identical
07:00:22 <dulla> I thought replacements would be weird
07:00:37 <ab9rf> dulla: no, fairly easyu in fact
07:01:07 <dulla> makes me feel like the professor that though Object recognition would be a seasonal project
07:01:16 <ab9rf> 1 + min ( distance-with-insert, distance-with-replace, distance-with-delete)
07:01:18 <dulla> 60 years later...
07:01:31 <ab9rf> if you don't want replacmeents to be 1,you just leave out the distance-with-replace branch of the min
07:02:16 <dulla> so more or less set it to some arbitrarily large number
07:02:30 <dulla> if you have fancy linear programming
07:02:36 <dgpratt> for anyone who watched and understood the video by edwardk in recent days (https://www.youtube.com/watch?v=hIZxTQP1ifo), I have some questions
07:02:51 <dgpratt> just trying to grasp it, really
07:03:06 <fractalsea> I want to create a function which takes functions to extract values from an environment, and a function to do some work on those extracted values (they have different types. Is there any way of doing this without having a different function depending on the number of environment values to extract: e.g. “run :: (Env -> a) -> (a -> b) -> b” and “run2 :: (Env -> a, Env -> b) -> (a ->  b -> c) -> c” etc.
07:03:11 <dgpratt> starting with: newtype p :- q = Sub (p => Dict q)
07:04:08 <dgpratt> so what sort of thing can Sub be applied to here (to give a p :- q) ?
07:04:20 <ab9rf> fractalsea: isn't that just a Reader?
07:04:49 <Yushatak> merijn: this article only gets me where i already was - i understand how to write a minimum edit distance program, granted not in haskell, but this doesn't help me understand the method used in the paper any better
07:04:54 <fractalsea> ab9rf: hmm not sure, I’ll have to think about/look into that
07:05:13 <ab9rf> fractalsea: i'm fairly certain that "extracting values from an environment and doing things on them" is what Reader offers
07:05:33 <fractalsea> ab9rf: Yeah that does make sense. I’ll try and work on that now
07:05:52 <dgpratt> also, I'm confused by this type signature :: p => (q => r) -> (p :- q) -> r
07:05:54 <dulla> what paper? Yushatak
07:06:06 <Yushatak> dulla: http://www.allisons.org/ll/FP/Haskell/1998/Edit01/
07:06:06 <dgpratt> apparently my mental model for what => represents needs updating
07:06:11 <Yushatak> my goal is to convert this script to fsharp
07:06:20 <Yushatak> i barely know haskell
07:06:29 <Yushatak> just a bit above hello world
07:06:36 <dulla> hahah
07:06:40 <dulla> I know hello world
07:06:48 <dulla> It's my jam, my only one
07:06:56 <Yushatak> not that i'd mind learning haskell, but i dont think my boss wants me to spend hours a day getting a grasp on it :p
07:06:59 <ab9rf> fractalsea: i think you'll find that extracting one value from an environment and extracting two from the environment can be captured within the same type, or by using composition
07:07:09 <byorgey> dgpratt: I suspect that p => (q => r)  is isomorphic to  (p,q) => r
07:07:14 <fractalsea> ab9rf: I’m not sure it will work though because this function I want to construct needs to know the type of the values that it will read form the environment beforehand
07:07:17 <byorgey> dgpratt: but just written that way for emphasis
07:07:53 <ab9rf> fractalsea: you might also look at lens (hurrrr)
07:07:53 <byorgey> dgpratt: oh, hmm, except I am not sure about the parenthesization.  never mind.
07:07:56 <dgpratt> byorgey, I wondered that, thanks
07:08:11 <fractalsea> ab9rf: OK
07:08:14 <ab9rf> fractalsea: disclaimer, i don't understand lens
07:08:25 <fractalsea> hehe
07:08:32 <byorgey> p => q => r -> ....   is probably the same as  (p,q) => r -> ...   but I don't think  p => (q => r) -> ...   is
07:08:45 <dulla> why not prisms, ab9rf
07:08:47 <ab9rf> but from what i do understand about it, it might do what you're looking for or at least make it easy to express
07:08:52 <ab9rf> dulla: because i don't know what prisms are
07:08:53 <dgpratt> so => does not associate like -> ?
07:09:15 <Yushatak> to my knowledge, a line like this  "mainDiag = oneDiag  a b (head uppers) ( -1 : (head lowers))" is very confusing - i undersand that it's defining mainDiag as the output of oneDiag(a, b), but not what the rest of that line means at all
07:09:25 <Yushatak> i read that head means the first element in a list
07:09:30 <Yushatak> but wtf is it on about <_<
07:09:47 <Yushatak> it also uses "uppers" and "lowers" before they are defined
07:09:53 <Yushatak> so i assume it's a function definition
07:10:03 <Yushatak> and that lowers and uppers are as well
07:10:05 <ab9rf> Yushatak: there's no such thing as "used before defined" in haskell
07:10:20 <mauke\> Yushatak: it calls oneDiag with 4 arguments
07:10:28 <mauke\> uppers/lowers are lists
07:10:37 <Yushatak> ab9rf: i'm primarily a C# programmer, as i said, not too familiar with haskell
07:11:04 <ab9rf> i thought F# was fairly similar to haskell, but i may have been wrong about that
07:11:09 <Yushatak> mauke\: what syntax makes that apparent?
07:11:22 <ab9rf> Yushatak: the fact that there are four argumnets after the function name?
07:11:30 <Yushatak> ab9rf: F# is like functional C# - it may be functionally similar to haskell but its syntactically more similar to C#
07:11:44 <Yushatak> ab9rf: no i mean that uppers/lowers are lists
07:11:56 <mmachenry> Is there a simple command to find out what version of base I'm running?
07:11:58 <solarus> @type head
07:11:58 <lambdabot> [a] -> a
07:12:05 <mauke\> Yushatak: because head takes a list
07:12:08 <ab9rf> Yushatak: they're lists beacuse "head" was used to produce one and (:) the other
07:12:21 <Yushatak> i guess from the output of eachdiag
07:12:23 <ab9rf> uppers has to be a list because it was an argument to head
07:12:31 <dgpratt> the biggest struggle I usually have trying to translate Haskell -> F# is the strictness of the latter and the fact things must be defined before they're used (as OP has already encountered)
07:12:43 <Yushatak> what does ":" do
07:12:44 <ab9rf> uppers has to be a list of lists, in fact
07:12:47 <ab9rf> Yushatak: cons
07:13:03 <ab9rf> > 'a' : "bcd"
07:13:04 <lambdabot>  "abcd"
07:13:07 <Yushatak> and what does that mean? :D
07:13:10 <dgpratt> Yushatak, Haskell : == F# ::
07:13:13 <Yushatak> oh
07:13:15 <Yushatak> concatenate
07:13:17 <dgpratt> and vice versa
07:13:19 <mauke\> Yushatak: no
07:13:26 <mauke\> concatenate is ++
07:13:27 * hackagebot uhc-util 0.1.5.0 - UHC utilities  http://hackage.haskell.org/package/uhc-util-0.1.5.0 (AtzeDijkstra)
07:13:27 <ab9rf> no, concatenate is somethingf else
07:13:32 * Yushatak has a headsplosion
07:13:40 <ab9rf> it's the list construction primitive
07:13:44 <mauke\> it looks like you've never used lists before
07:13:44 <Yushatak> oh
07:13:59 <Yushatak> mauke\: i've never used haskell before, beyond hello world
07:13:59 <Yushatak> trying to make that clear
07:14:00 <ab9rf> > 'a' : []
07:14:02 <lambdabot>  "a"
07:14:12 <mauke\> Yushatak: this isn't haskell specific
07:14:21 <ab9rf> gah, i should use numbers instead of characters to avoid the special case for [Char]
07:14:24 <barrucadu> > 1 : 2 : []
07:14:24 <mauke\> the same concept exists in OCaml or Lisp (for example)
07:14:25 <lambdabot>  [1,2]
07:14:31 <x77686d> I was thinking that ghci had GNU readline support but it doesn't seem to -- ~/.inputrc doesn't get read, based on ls -lu.  Is there a place where key bindings can be specified?
07:14:36 <barrucadu> (in Haskell a string is a list of characters)
07:14:40 <mauke\> x77686d: it uses haskeline
07:15:01 <julianleviston> > head “hello"
07:15:02 <lambdabot>  <hint>:1:6: lexical error at character '\8220'
07:15:04 <mauke\> x77686d: http://trac.haskell.org/haskeline/wiki/UserPrefs
07:15:11 <kadoban> Yushatak: https://github.com/bitemyapp/learnhaskell has some very nice pointers for where to learn haskell from, if you're interested. (Which isn't to be taken as "go away and don't ask us questions", just a friendly pointer)
07:15:13 <Yushatak> tail "test"
07:15:31 <ab9rf> > tail "test" -- Yushatak
07:15:32 <lambdabot>  "est"
07:15:40 <dulla> > tail "test"
07:15:41 <Yushatak> > head "test"
07:15:41 <lambdabot>  "est"
07:15:42 <lambdabot>  't'
07:15:49 <dulla> > init "test
07:15:51 <lambdabot>  <hint>:1:11:
07:15:51 <lambdabot>      lexical error in string/character literal at end of input
07:15:53 <dulla> > init "test"
07:15:54 <lambdabot>  "tes"
07:15:55 <Yushatak> ok that's how i thought those behaved from my reading
07:15:56 <x77686d> mauke\: Thanks!
07:16:13 <dulla> > 'a':'a':'a':'a':'a':'a':[]
07:16:15 <lambdabot>  "aaaaaa"
07:16:23 <Yushatak> kadoban: i do want to learn it, but learning enough to read this script might take a while, no? i can't judge that from this end of the learning
07:16:26 <dulla> > "aaaa" ++ "bbbb"
07:16:27 <lambdabot>  "aaaabbbb"
07:16:41 <voidzero> :t (++)
07:16:42 <lambdabot> [a] -> [a] -> [a]
07:16:44 <Yushatak> "abc" : "def"
07:16:53 <voidzero> :t mappend
07:16:54 <lambdabot> Monoid a => a -> a -> a
07:16:58 <Yushatak> list  -> list -> list
07:17:00 <kadoban> Yushatak: I didn't see what script you were talking about if it was linked, but…haskell does take some time to learn, sure.
07:17:00 <Yushatak> what does that even mean
07:17:00 <dulla> > "abc" : "def"
07:17:01 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[GHC.Types.Char]’
07:17:01 <lambdabot>  Expected type: [[GHC.Types.Char]]
07:17:01 <lambdabot>    Actual type: [GHC.Types.Char]
07:17:10 <ab9rf> Yushatak: so in the def'n for mainDiag, the argument ( -1 : (head lowers) ) creates a list that starts with -1, followed by the list found in the first element of lowers (which is necessarily a list of numbers because haskell lists are homogenously typed)
07:17:17 <benjwadams> Hi, sorta not necessarily haskell specific, but what are some recommended resources for learning about functional reactive programming?  We're dealing with a lot of callback spaghetti in our JS codebase and I'd like to attempt to evaluate FRP to see if it could help the situation.
07:17:18 <barrucadu> Yushatak: If you want lambdabot to evaluate an expression, you start the message with "> "
07:17:19 <voidzero> 'a' : "foo"
07:17:22 <voidzero> > 'a' : "foo"
07:17:24 <lambdabot>  "afoo"
07:17:24 <dulla> it takes two lists, and returns a list, Yushatak
07:17:30 <kadoban> Yushatak: Slightly simplified: it takes two lists as arguments and results in a third list
07:17:34 <Yushatak> barrucadu: ah right, i did know that, missed it
07:17:38 <Yushatak> >"abc" : "def"
07:17:59 <bennofs> > "bcd" ++ "def"
07:18:01 <lambdabot>  "bcddef"
07:18:02 <barrucadu> Forgot the space
07:18:12 <Yushatak> ab9rf: ok that makes sense in context
07:18:29 <dulla> you can't cons a string into a list of chars, Yushatak
07:18:32 <dulla> :t (:)
07:18:33 <lambdabot> a -> [a] -> [a]
07:18:36 <voidzero> > zip "foo" ['a'..]
07:18:37 <lambdabot>  [('f','a'),('o','b'),('o','c')]
07:18:41 <benjwadams> >fmap (Just 2) (+ 2)
07:18:46 <benjwadams> > fmap (Just 2) (+ 2)
07:18:47 <lambdabot>  Couldn't match expected type ‘a -> b’
07:18:47 <lambdabot>              with actual type ‘Data.Maybe.Maybe a0’
07:18:50 <Yushatak> > "abc" : "def"
07:18:51 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[GHC.Types.Char]’
07:18:51 <lambdabot>  Expected type: [[GHC.Types.Char]]
07:18:51 <lambdabot>    Actual type: [GHC.Types.Char]
07:18:53 <ab9rf> ok, ehough lambdabot abuse
07:19:01 <Yushatak> wanted to see how it failed
07:19:04 <ab9rf> Yushatak: that error is because haskell lists are homogenously typed
07:19:11 <Yushatak> aye, i knew it would break
07:19:28 <ab9rf> you tried to create a list where one element was a list of characters, and the rest were characters
07:19:29 <solarus> Yushatak: you can experiment in a private query with lambdabot or in a ghci session (where you have tab completion)
07:19:36 <julianleviston> Yushatak: you can privately message lambdabot, btw.
07:19:56 <Yushatak> i've never seen a constructor for a list where you define the first element and then the rest as two arguments
07:19:59 <Yushatak> that's bizarre
07:20:11 <ab9rf> Yushatak: it's fairly standard in functional languages :)
07:20:18 <bennofs> Yushatak: it's a simple linked list
07:20:19 <ab9rf> Yushatak: goes back to lisp
07:20:33 <mauke\> it's also fairly standard in C
07:20:34 <ab9rf> (cons 'a nil)
07:20:41 <bennofs> Yushatak: if it took two lists, you'd get some kind of tree
07:20:42 <Yushatak> i know C and x86 ASM pretty decently, and then there's a big gap in my knowledge until you hit C# and Python
07:20:43 <mauke\> struct node { int data; struct node *next; };
07:20:55 <keko-2> that's because of how linked lists work: you have a node with some data and a link to the next node
07:20:58 <mauke\> first element, plus a rest
07:21:04 <julianleviston> Yushatak: don't you have linked lists in C? I'm sure you do.
07:21:08 <Yushatak> aye i know how a linked list works - i didnt know this was a linked list
07:21:15 <Yushatak> i wrote my own implementation for linked lists as i wrote my own OS
07:21:20 <ab9rf> Yushatak: it doesn't have to be a linked list, but it's a list
07:21:22 <Yushatak> so im pretty familiar
07:21:37 <ab9rf> how it's actually stored is implementatin dependent :)
07:21:57 <benjwadams> ab9rf: really?  point me to more info
07:22:19 <Yushatak> so its kinda like a linked list in reverse - the element itself and then the "rest" of it being the pointer to the rest of the list, yeah?
07:22:43 <Yushatak> conceptually, that is
07:22:59 <ab9rf> Yushatak: it's what in lisp is called a "cons cell": a data structure containing two things: the first element of the list, and a cons cell containing the rest of the list
07:23:23 <mauke\> Yushatak: https://msdn.microsoft.com/library/dd233224.aspx
07:23:27 <mauke\> it works the same way in F#
07:24:19 <ab9rf> benjwadams: if i do foldr (+) 0 [1..10], ghc doesn't actually have to create a linked list of the intgers 1 to 10, then add them.  it can just add them.
07:24:21 <kadoban> Yushatak: Kinda, yeah. The direction isn't arbitrary, it's kinda required for the data structure to work will with persistence. If you have one list, called a and then you add something to the front of it and call it b, you don't have to change a at all, it can still be used totally fine. If list cons went the other way, that wouldn't be true.
07:24:38 <benjwadams> ab9rf: hot
07:24:40 <Yushatak> true
07:25:00 <Yushatak> ok so that makes sense now
07:25:44 <benjwadams> anyways, going to ask once more since i think my question got covered up by all the lambdabot queries:
07:26:26 <benjwadams> Any good language agnostic resources for functional reactive programming for someone familiar with basics of functional language concepts?
07:26:37 <Yushatak> ok so i know haskell allows recursive things all over the place, but how does something like uppers = eachDiag a b (mainDiag : uppers) work - especially when mainDiag uses uppers
07:26:56 <Yushatak> surely it can't just pull the meaning out of the ether
07:27:03 <mauke\> consider the following
07:27:03 <julianleviston> benjwadams: isn't the canonical refrence language agnostic?
07:27:14 <mauke\> Yushatak: foo = 1 : foo
07:27:18 <julianleviston> benjwadams: by the haskell dude man
07:27:32 <mauke\> Yushatak: this is equivalent to this C code: struct node foo = { 1, &foo };
07:27:35 <solarus> Conal?
07:27:36 <Yushatak> that's a 1 with a link back to itself, so a recursive list of 1
07:27:41 <Yushatak> yeah
07:27:47 <mauke\> this is sort of the same thing
07:27:50 <benjwadams> julianleviston: err, for FRP?  could i have a link to this "canonical reference"?
07:27:54 <ab9rf> Yushatak: prefectly legal in haskell
07:27:57 <bennofs> julianleviston: the FRP paper by conal is quite theoretic IMO
07:28:09 <Yushatak> so i should think of it as a reference and not a value
07:28:10 <ab9rf> > let foo = 1 : foo in take 5 foo
07:28:11 <lambdabot>  [1,1,1,1,1]
07:28:12 <mauke\> Yushatak: haskell only evaluates things when needed
07:28:25 <benjwadams> oh, something with applied examples would be helpful
07:28:25 <mauke\> > take 10 (map (* 2) [1 ..])
07:28:27 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
07:28:27 <ab9rf> Yushatak: note that that terminated.  haskell doesn't force foo to be fully constructed
07:28:28 * hackagebot OpenGLRaw 2.3.0.0 - A raw binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGLRaw-2.3.0.0 (SvenPanne)
07:28:39 <benjwadams> I'm not a fantastic mathematician by any means
07:28:52 <Yushatak> ab9rf: yeah i get that
07:28:53 <ab9rf> benjwadams: oh, you asked about FRP?  we were talking about netwire earlier
07:29:08 <Yushatak> ok that clears that up
07:29:11 * Yushatak reads some more 
07:29:59 <julianleviston> benjwadams: doesn't language agnostic presuppose some math to a degree?
07:30:27 <benjwadams> I suppose, but a conceptual overview would be helpful
07:30:28 <Yushatak> " doDiag (a:as) (b:bs) nw n w =" - this is saying a definition of doDiag where it takes two list constructors?
07:30:32 <Yushatak> (and three other  values)
07:30:37 <benjwadams> s/language agnostic//
07:30:45 <bennofs> benjwadams: maybe there is something around elm?
07:30:51 <benjwadams> any recommended overviews really.
07:30:55 <ab9rf> wow, those are some massively fancy mutially recursive definitions
07:31:05 <Yushatak> ab9rf: that's why i am confused :3
07:31:17 <julianleviston> benjwadams: I *think* it's this: http://conal.net/papers/icfp97/
07:31:26 <julianleviston> but it's pretty theoretical...
07:31:37 <Yushatak> am i understanding what's going on? or no
07:31:44 <ab9rf> "It can be seen that a row can be calculated from left to right, given the previous row. An element depends only on the elements to the west, north-west and north."
07:31:50 <ab9rf> that's why it works, i think
07:31:58 <kadoban> Yushatak: It pattern matches to take apart two lists and gets the first element of each and the rest of each, yeah. Which isn't to contradict you, just…say more because I'm not sure your wording is accidentally correct.
07:32:23 <julianleviston> benjwadams: you could probably just search for FRP on youtube though and find some nice person intro'ing it.
07:32:27 <Yushatak> oh ok so it's like taking in a list normally and then running head and tail on it
07:32:33 <Yushatak> except syntax sugar
07:32:37 <Yushatak> yes?
07:32:39 <ChristianS> Yushatak: no
07:32:45 <Yushatak> no? D:
07:32:55 <ChristianS> Yushatak: it won't match if one of the lists is empty
07:32:57 <kadoban> Yushatak: Almost. It requires the list to have at least one element, which is different.
07:32:59 <mauke\> Yushatak: head and tail are defined using pattern matching
07:33:13 <mauke\> head (x : _) = x; tail (_ : xs) = xs
07:33:25 <Yushatak> ah
07:33:26 <kadoban> Yushatak: Also it's not so much syntactic sugar as it is…the syntax itself. Pattern matching is /very/ basic to haskell.
07:33:45 <ab9rf> the doDiag function in that code is defined using pattern matching
07:33:47 <julianleviston> benjwadams: I actually find david nolen's introductions pretty nice, but that's in clojure… so if you don't have lisp, that'd make it potentially tricky…
07:34:04 <ab9rf> there's three cases, two of which serve to bottom out the recursion
07:34:09 <Yushatak> aye i've interpreted that as different overloads that depend on the arguments' contents
07:34:16 <Yushatak> but yeah i know its called pattern matching
07:34:31 <benjwadams> JS ideally.  while i don't like the language a ton, it's the only one I could retool some of our current systems for
07:34:42 <clrnd> any idea what version of cabal does the Haskell Platform bundle?
07:34:42 <Yushatak> one is if a is empty, one is b is empty
07:36:06 <ab9rf> clrnd: which version of the platform?
07:36:07 <Yushatak> ok so one thing i hadn't caught on to the first time through this was that NW, N, and W are lists, not individual values
07:36:12 <clrnd> 2014.2.0.0
07:36:12 <Yushatak> that makes some things make more sense now
07:36:18 <clrnd> ab9rf, 2014.2.0.0
07:36:23 <jtanguy> clrnd: for the current platform it's 1.18.1.3 https://www.haskell.org/platform/changelog.html
07:36:34 <clrnd> thanks jtanguy
07:36:52 <ab9rf> Yushatak: it would be nice if this code were annotated with type signatures
07:37:10 <Yushatak> if someone wants to make this pretty and readable i'd be in their debt :P
07:37:32 <ab9rf> hlint would offer one for the top level
07:37:55 <ab9rf> but it would just be (Eq a, Num b) => [a] -> [a] -> b or something similar
07:39:04 <Yushatak> the eachDiag definition is making my head spin
07:39:09 <Yushatak> i can technically read it now
07:39:12 <Yushatak> but man
07:39:41 <mauke\> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
07:39:44 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
07:40:29 <jtanguy> btw is the Haskell Platform still developed or is it superseded by stackage?
07:40:52 <Yushatak> if b is empty, return empty, else deconstruct b and deconstruct "c", then assign the nextDiag, and loop through assigning them lazily in a very confusing line "in  (oneDiag a bs nextDiag lastDiag):(eachDiag a bs diags)"
07:41:02 <kadoban> jtanguy: Both of those are true, IMO.
07:41:41 <julianleviston> Yushatak: can I recommend you actually set about properly learnoeg Hakell? It's got a lot of things that are NOT what you expect coming from pretty much every other language there is, and even if you've done functional programming, the type system, the currying and the laziness alone make it fundamentally unique and different to think about - pretty much an entirely new paradigm in itself.
07:41:50 <julianleviston> Yushatak: learning*
07:42:06 <ab9rf> yeah, it's really not practical to attempt to mechamically translate haskell to another language
07:42:17 <ab9rf> that's what compilers are for :)
07:42:22 <Yushatak> well i understand the concept of the code, the purpose behind it
07:42:42 <Yushatak> so its not quite a mechanical translation
07:43:30 <Yushatak> any guidance on biasing my learning toward what i'd need to know for this?
07:43:38 <Yushatak> i mean the basic stuff first, but after that
07:43:39 <julianleviston> Yushatak: at least go and gloss Learn You a Haskell
07:44:04 <mpickering> Is it always possible to replace fun deps with associated types?
07:45:22 <ab9rf> mpickering: i thought isaw someone claim that the other day.
07:45:29 <mauke\> class Foo a b c | a b -> c, b c -> a
07:45:32 <kadoban> Ehh, I don't really like LYAH by itself. The cis194 spring `13 class that's recommended in the link I pointed to earlier is a very nice start to haskell. It pulls from other resources, like LYAH and RWH, has a better structure and exercises so you actually…learn something.
07:45:35 <ab9rf> mpickering: but i think it may be an unproved theorem at ths point
07:45:46 <julianleviston> kadoban: I completely agree...
07:45:48 <ab9rf> er unproved conjecture
07:46:07 <ab9rf> i don't care for LYAH that much either
07:46:13 <ab9rf> not really sure of a better resource though
07:46:43 <julianleviston> kadoban: LYAH *does* make a whole bunch of stuff understandable, though.
07:47:34 <kadoban> julianleviston: Yeah, I like it for what it is, but…learning from it long ago didn't get be very far on its own. Plus I'm not a huge fan of the tone of it, but…that's just me and doesn't really hurt anything.
07:47:56 <julianleviston> but yeah, coupled with the gentle introduction, and the other book from the CIS course… it's pretty rounded…
07:48:02 <Yushatak> it claims to be written for programmers of other languages
07:48:10 <julianleviston> kadoban: yeah I find this "wacky" stuff annoying mostly.
07:48:13 <mpickering> I have to admit that I don't understand the backlash against LYAH in recent months
07:48:21 <julianleviston> I actually think this is pretty good… https://www.fpcomplete.com/school/starting-with-haskell/haskell-fast-hard
07:48:56 <julianleviston> oh sorry I meant this: http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/
07:49:08 <julianleviston> as a quick primer.
07:49:13 <julianleviston> and overview
07:49:26 <julianleviston> it's probably ideal for this context.
07:49:55 <Yushatak> i shall check out that, and when/if it falls short of making me understand i will turn to the long-winded-looking explanations of LYAH
07:50:13 <Yushatak> but for now, lunch
07:50:30 <Yushatak> thank you guys, ill keep hanging around as im sure ill have questions, lol
07:50:30 <julianleviston> Yushatak: I didn't mean to discourage you from asking questions, by the way.
07:50:39 <Yushatak> i know
07:50:42 * clrnd likes LYAH for begginners
07:58:04 <btcNeverSleeps> I'm trying to set up haskell-mode with ghc but even on the simplest "Hello, world!" example I get errors show on the first line of the .hs file, saying "BUG:/home/e/.../dist/setup-config: hGetContents: invalid argument (invalid byte sequence)"
07:59:49 <kadoban> btcNeverSleeps: Sounds like https://github.com/kazu-yamamoto/ghc-mod/issues/417  you have to downgrade cabal-install or Cabal or something
08:00:08 <btcNeverSleeps> kadoban: going to read that asap
08:01:54 <btcNeverSleeps> kadoban: ouch, yes, that is the issue... I've got cabal 1.22 indeed
08:02:13 <btcNeverSleeps> How can I "downgrade" to an older version of cabal ?
08:02:40 <kadoban> Yeah, it's pretty annoying :-/ I…don't know generalized instructions, my ghc/haskell/whatever install is pretty weird.
08:03:36 <ab9rf> use a sandbox?
08:03:48 <ab9rf> i've actually done that, used cabal 1.20 in a sandbox
08:14:27 <tasker> edwardk: Is the situation regarding ad and hmatrix described in this mail: https://mail.haskell.org/pipermail/haskell-cafe/2013-April/107543.html still the case?
08:18:00 <enthropy> I think the classes got adjusted such that you could make it work, but there are no instances
08:19:45 <enthropy> I think http://hackage.haskell.org/package/ad-4.2.1.1/docs/Numeric-AD-Mode-Forward-Double.html needs to be adapted to be ForwardHMatrixVector or something like that
08:20:16 <tasker> Hm, okay.
08:20:24 <tasker> thanks ;)
08:22:47 <hsk4> Am I correct in assuming that   putStrLn :: String -> IO ()  has nothing to do with monadic functions  a -> IO b ? Rather, that putStrLn just happens to have a type signature that looks like these monadic functions but in fact isn't?
08:23:23 <btcNeverSleeps> if I want to start a new cabal installation from scratch, is "rm -rf ~/.cabal" enough? (I still have /usr/bin/cabal which is the stock Debian 7 version 0.14.0 of cabal)   Is 0.14.0 enough to then do "cabal install cabal-install" and get a newer cabal?
08:23:33 <enthropy> maybe those instances are in another package
08:23:38 <ab9rf> hsk4: i'm afraid i don't understand your question\
08:23:54 <hiptobecubic> hsk4, no.
08:24:05 <tdammers> hsk4: putStrLn happens to have a return value whose type involves a monadic type
08:24:38 <hiptobecubic> hsk4, there isn't anything special about IO or the functions in IO other than the magic that GHC does to make it 'run'.
08:24:44 <tdammers> so in that sense it is "monadic", just like a function of type a ->IO b
08:24:44 <mauke\> String -> IO () is an instance of a -> IO b, with a = String and b = ()
08:24:46 <ab9rf> i'm not really sure what a "monadic function" is
08:24:56 <tdammers> ab9rf: hence the quotes
08:25:21 <hsk4> ok, thanks
08:25:31 <hsk4> yeah my question is kind of silly
08:25:55 <ab9rf> if you mean "a function whose return type is an instance of a Monad" then yes, putStrLn is a "monadic function"
08:26:52 <tdammers> "monadic" is kind of a fuzzy term
08:27:03 <tdammers> it really just means that Monads are involved somehow
08:27:55 <hsk4> What I'm basically driving at is this: We have the IO monad. a -> IO b are the "monadic functions" in the sense that the IO monad describes how we can shove   a    into   a -> IO b   using >>=.
08:27:55 <hsk4> Now putStrLn is a function that takes a string and returns an IO action. It just kind of happens to be a "monadic function". It's not like it in some sense HAD to be one of these "monadic functions". It just turned out that way
08:27:59 <hsk4> Do I make any sense?
08:28:31 * hackagebot uhc-light 1.1.8.7 - Part of UHC packaged as cabal/hackage installable library  http://hackage.haskell.org/package/uhc-light-1.1.8.7 (AtzeDijkstra)
08:28:39 <hsk4> Just like getLine indeed is NOT one of these functions
08:28:55 <hsk4> But it turned out putStrLn was, but there's nothing special about this
08:30:00 <ab9rf> :t getLine
08:30:00 <lambdabot> IO String
08:30:15 <ab9rf> getLine isn't a function at all :)
08:30:33 <tdammers> hsk4: it help to not use the term "IO monad" here, because the fact that IO is an instance of Monad is only marginally relevan
08:30:35 <tdammers> *t
08:30:59 <tdammers> putStrLn is a function that returns an IO value
08:31:06 <tdammers> getLine is an IO value
08:31:27 <tdammers> the "monad" part doesn't have anything to do with that
08:31:46 <tdammers> IO being a monad becomes somewhat relevant when you want to combine these two things
08:31:48 <btcNeverSleeps> how can I upgrade from ghc 7.4.1 to ghc 7.10?  "which ghc" says ghc is in "/usr/bin/ghc"
08:32:08 <orion> Hi. How common is it for packages to have multiple nested "Internal" namespaces?
08:32:18 <shachaf> GHC 7.10 isn't out yet.
08:33:17 <tdammers> because getLine :: IO String and putStrLn :: String -> IO () and main :: IO () and (>>=) :: Monad m => m a -> (a -> m b) -> b, with m = IO, means that you can use >>= to combine getLine and putStrLn into an IO (), which typechecks when bound to main
08:33:46 <btcNeverSleeps> shachaf: I cannot make haskell-mode + ghc-mod work nicely due to a known issue.  Apparently there are two ways to fix the issue: downgrade cabal-install or upgrade ghc to 7.10.  And downgrading to an older cabal-install seems to a particular place in hell :(
08:34:38 <hsk4> ok thanks, makes sense
08:38:19 <zq> what's the ghc flag to specify additional include dirs?
08:40:09 <btcNeverSleeps> Is there some premade image which I could install a VM containing an already working emacs + haskell + cabal + ghc-mod + flycheck etc. install?  Installing all this and making it work seems to be incredibly difficult for someone new to Haskell.
08:53:53 <sclv> monochrom: ping
08:54:35 <bluebelle> I'm getting Warning: http error: Network.Browser.request: Error raised ErrorClosed when installing cmdargs-0.10.12, which is required by ghc-mod. Anyone has the same issue?
09:03:58 <augur> whats a good secure hashing lib?
09:04:25 <arw_> augur: anything that does SHA3?
09:05:26 <edwardk> tasker: we have some limited support for monomorphic AD modes now, but that doesn't help hmatrix much
09:05:57 <edwardk> what you really need is vectored "AD" and that means jacobians become really complex
09:08:29 <augur> arw_: any particular suggestions?
09:09:57 <arw_> augur: the cryptohash package looks best to me.
09:10:06 <augur> ok
09:11:01 <arw_> augur: although, if you need more than just hashing (encryption, key exchange, whatever) you might want to think about openssl or something similar.
09:11:37 <augur> i just need something to hash passwords
09:12:08 <arw_> ah. then better use your systems crypt() libc function
09:12:42 <augur> arw_: from within haskell?
09:12:47 <ab9rf> why not?>
09:12:50 <monochrom> sclv: yes?
09:12:51 <ab9rf> ought to be callable with the FFI
09:12:52 <augur> how? D:
09:12:55 <arw_> augur: System.Unix.Crypt
09:12:58 <augur> arw_: hm!
09:13:34 * hackagebot cabal-bounds 0.9.2 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.9.2 (DanielTrstenjak)
09:13:40 <sclv> monochrom: wanted to point out that yr two cabal articles are now linked from the new haskell homepage, and see if you felt they were up to date enough or if you thought we maybe should only link one or etc.
09:13:45 <tasker> edwardk: The jacobian becomes complex in what sense ?
09:13:59 <arw_> augur: has the additional advantages of a) salt b) importability of passwords because of the common format and c) compatibility with older hashing schemes
09:14:06 <sclv> they both get heavily recommended frequently, so it seems like they're good to encourage people to read
09:14:18 <ab9rf> low-salt hashing
09:14:18 <monochrom> I think they are up to date enough. please continue to link to them. :)
09:14:19 <sclv> but i want to be sure you feel they're current enough that you'd recommend them
09:14:25 <augur> arw_: how secure is crypt?
09:14:31 <arw_> augur: just read the crypt manpage and pick the strongest possible algorithm for hashing.
09:14:43 <arw_> augur: sha-512 on most linux distros
09:14:56 <arw_> augur: but you can pick it by specifying the right salt string
09:15:23 <sclv> i think i saw someone in particular say they thought "the cabal of cabal" was a bit outdated, but idk?
09:17:17 <wz1000> Is there any difference in semantics between manual record passing and typeclasses? For example, instead of Eq being a typeclass, I could have data Eq a = Eq { (==) :: a -> a -> Bool, (/=) :: a -> a -> Bool), and f :: Eq a => ... becomes Eq a -> ...
09:18:34 * hackagebot language-lua 0.6.3 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.6.3 (OmerAgacan)
09:18:47 <wz1000> One differnce I noticed would be not being able to define mutually recursive default implementation where implementing one makes the others valid. Are there any others?
09:19:11 <quchen> wz1000: That's indeed a simple picture of a typeclass (passing a dictionary around), but you don't get things like polymorphic recursion
09:20:52 <wz1000> quchen: Oh yes, I failed to notice that
09:21:31 <arw_> > System.Unix.Crypt.crypt "password" "$6$randomsalt$"
09:21:32 <lambdabot>  Not in scope: ‘System.Unix.Crypt.crypt’
09:23:18 <ski> wz1000 : for "being able to define mutually recursive default implementation where implementing one makes the others valid", you need to encode "open recursion"
09:23:36 <ski> wz1000 : you can have at most one instance of a type class for a particular type
09:25:05 <vapidness> Hello, I'm trying to define a general fold method over a BST. One where I can change the order of the fold easily. At the moment I have 2 separate functions for inorder and regular tree traversal. I would really be greatful if someone could point me in the right direction.
09:28:00 <ski> wz1000 : "open recursion" : `defaultEq :: Eq a -> Eq a; defaultEq this = this {(==) = \x y -> not ((/=) this x y); (/=) = \x y -> not ((==) this x y)}'. use (e.g.) `fix' when you need a concrete dictionary, like `fix ((\this -> this {(==) = ...}) . defaultEq)
09:29:17 <fresheyeball> hey everyone
09:29:24 <vapidness> Hello :)
09:29:28 <fresheyeball> I have a question
09:29:51 <fresheyeball> I'm noticing lots of code that have an Data type that is not a type level but contains one thing
09:29:56 <fresheyeball> example
09:30:02 <fresheyeball> data Foo = Foo Int
09:30:19 <fresheyeball> because its not a type level
09:30:26 <fresheyeball> but must contain an Int
09:30:33 <fresheyeball> its not a functor or applicative
09:30:49 <fresheyeball> but I can see a way to define monad for it
09:31:04 <fresheyeball> f >>= (Foo i) = f i
09:31:34 <fresheyeball> return i = Foo i
09:31:44 <fresheyeball> so
09:31:52 <fresheyeball> because all monads are applicative functors
09:32:01 <fresheyeball> what is Foo?
09:32:16 <fresheyeball> I also see code like this
09:32:22 <fresheyeball> runFoo (Foo i) = i
09:32:44 <fresheyeball> shouldn't we just have a typeclass for this?
09:32:51 <lyxia> Are you sure it's not newtype Foo = Foo Int ?
09:32:52 <fresheyeball> one with a single function like this
09:33:08 <fresheyeball> run :: a -> b
09:33:10 <fresheyeball> so
09:33:18 <fresheyeball> instance Runable Foo where
09:33:24 <fresheyeball> run (Foo x) = x
09:33:24 <lyxia> Also monad instances should be defined for types of kind * -> *
09:33:36 <fresheyeball> right
09:33:40 <fresheyeball> Foo is not a monad
09:33:53 <fresheyeball> or rather
09:34:10 <fresheyeball> I can see a way to define it sort of
09:34:20 <quchen> vapidness: Some code might help us help you
09:34:24 <fresheyeball> I'm really just wondering about single item containers
09:34:29 <fresheyeball> that are not monads
09:34:53 <lyxia> fresheyeball: Foo has kind *
09:34:59 <fresheyeball> yes
09:35:04 <fresheyeball> Foo :: *
09:35:17 <lyxia> So why are you bringing up monads?
09:35:28 <fresheyeball> because the behavior I am curious about is monad like
09:35:45 <thebnq> the Haskell Monad class can't define all Monads
09:36:26 <monochrom> a single-item container is doomed to be a monad.
09:36:37 <glguy> \o/
09:36:41 <fresheyeball> right
09:37:01 <fresheyeball> (>>=) :: m a -> (a -> m b) -> m b
09:37:05 <fresheyeball> I am looking for this
09:37:21 <quchen> Foo might be a monomorphic version of a monad. class MonoMonad a ma where pure :: a -> ma; (>>=) :: ma -> (a -> ma) -> ma or something like that.
09:37:31 <fresheyeball> right
09:37:37 <fresheyeball> the instance would be
09:37:52 <fresheyeball> run :: Foo -> (Int -> Foo) -> Foo
09:38:16 <quchen> And with associated types you could even hide the Int.
09:38:25 <quchen> But none of that is standard.
09:38:27 <fresheyeball> right
09:38:31 <fresheyeball> well
09:38:45 <fresheyeball> MonoMonad looks right to me
09:39:05 <fresheyeball> quchen: is MonoMonad a thing in haskell?
09:39:14 <quchen> No.
09:39:44 <fresheyeball> It seems the Foo would also be a MonoFunctor but not MonoApplicative
09:40:39 <fresheyeball> or
09:40:46 <fresheyeball> we could define a typeclass Mono
09:41:03 <johnw> quchen: what is the type of MonoMonad's  join?
09:41:17 <quchen> johnw: That's where the monady part stops.
09:41:21 <johnw> ah, ok
09:41:23 <johnw> phew
09:41:35 <ski> fresheyeball : do you have a more interesting example than `data Foo = Foo Int' ?
09:41:50 <fresheyeball> no
09:42:00 <ski> (also, `f >>= (Foo i) = f i' looks like nonsense. perhaps you intended to say `Foo i >>= f = f i')
09:42:16 <init> fresheyeball: I think all you want is a fold
09:42:20 <fresheyeball> ski: you are right
09:42:45 <fresheyeball> hmm
09:42:45 <quchen> johnw: Actually, it's mma -> ma ;-P
09:43:00 <ski> vapidness : it's not clear to me what you mean by "fold" here. what's the types of your two functions ?
09:43:53 <johnw> quchen: maybe a more interesting MonoMonad would be: class Lens' s a => MonoMonad s where return :: a -> s; join :: forall t. Lens' t s => t -> s?
09:43:59 <fresheyeball> then is there a relationship between fold and bind?
09:44:28 <johnw> although that has little value as a type class
09:44:36 <quchen> johnw: What is Lens'`
09:44:36 <vapidness> quchen: Silly me. Here is my BST declaration => data BST a = EmptyBST | Node ( BST a ) a ( BST a ) deriving (Show). And here is an example of my in order traversal. -- if isEmptyBST bst then [] else inorder (lSub bst)  ++ [rootVal bst] ++ inorder (rSub bst). I thinking of a fold that takes in 2 functions. One that allows me to reorder my subtrees.
09:44:41 <biio> Hi, is there anyway to save the state of a monad, then later restore the state to discard any side effects that has occured between those two points?
09:44:44 <johnw> it's nearly implied if you have a Prism
09:44:48 <johnw> quchen: from 'lens'
09:44:56 <quchen> johnw: Lens' is a type in lens
09:46:31 <quchen> biio: A monad does not have state in general.
09:47:05 <quchen> And even the monads that sometimes feel state-y are usually not undoable. IO comes to mind.
09:47:16 <Yushatak> what exactly does the pipe character '|' mean in haskell?
09:47:29 <quchen> In what context, Yushatak?
09:47:33 <monochrom> it means different things in different contexts
09:47:35 <Yushatak> in all contexts
09:47:43 <biio> quchen: I see, didn't think so :/ thanks for the answer
09:47:46 <monochrom> in all contexts, it is punctuation
09:47:56 <Yushatak> perhaps i should have said "in each context"
09:48:21 <Yushatak> what CAN it mean
09:48:21 <quchen> [| foo |] is Template Haskell syntax. There's "|" in guards, there's "|" in sum types.
09:48:37 <quchen> There's "|" as part of an operator.
09:48:45 <monochrom> good luck. that's a strange question I don't like to answer.
09:48:54 <Yushatak> absolute' x     | x >= 0 = x     | otherwise = -x
09:48:59 <quchen> monochrom: You're so lucky to have me ♥
09:48:59 <Yushatak> how about this context
09:49:07 <quchen> That's a guard.
09:49:14 <orion> What case style do most Haskellers use?
09:49:16 <enthropy> > "|"
09:49:18 <lambdabot>  "|"
09:49:24 <Yushatak> is it akin to \ to start a new line in a single line statement in a console?
09:49:37 <quchen> No, it is akin to a guard.
09:49:43 <Yushatak> please explain this concept :P
09:49:50 <Yushatak> (i am new)
09:50:29 <monochrom> "absolute' x     | x >= 0 = x     | otherwise = -x" means "if x>=0 then x else -x"
09:50:41 <quchen> It's sort of like an "if" in this context. Maybe have a look at an introductory book? LYAH and Hutton are popular recommendations for a first read.
09:51:01 <Yushatak> i am reading a tutorial book online right now
09:51:09 <quchen> Maybe also have a look at this guide. https://github.com/bitemyapp/learnhaskell
09:51:09 <Yushatak> and it showed this example without explaining the pipe characters :P
09:52:15 <monochrom> the | is for giving a heads-up to the computer "I now want to give a bunch of alternatives. each alternative is preceded by | so you know where one ends and the next one starts"
09:52:33 <monochrom> it's punctuation, separator
09:53:47 <Hafydd> I thought of it more as standing for "such that."
09:54:25 <cfoch> hello. If I have a package which name is "haq" what would be its InstalledPackageId in Cabal?
09:54:26 <cfoch> https://github.com/haskell/cabal/blob/master/Cabal/Distribution/Package.hs#L121
09:54:31 <monochrom> yes, for those of you translating everything in English
09:55:29 <monochrom> do you know how much "such that" is also punctuation? compare "there exists x such that x>0" with "for some x, x>0". this shows how "such that" just means ","
09:56:00 <monochrom> the conclusion is that "such that" has no semantics either
09:56:13 <Profpatsch> Okay, need some IO and recursion cracks:
09:56:23 <ski> vapidness : perhaps your message got cut off after "One that allows me to reorder my subtrees." ?
09:56:29 <Profpatsch> How can I simplify this with higher order functions? https://bigmac.caelum.uberspace.de/paste/readUntilEOF.hs.html
09:57:31 <cfoch> simon: are you the author of this line? https://github.com/haskell/cabal/blame/master/Cabal/Distribution/Package.hs#L121
09:59:29 <Cale> Profpatsch: hmm, does this *need* to take an IO action argument? You only seem to be passing it actions which are constructed using return
09:59:35 <phaazon> can someone explain me what’s the difference between a Wire that outputs an (Event a), and a Wire that outputs a when the event occurs and inhibits the rest of the time?
09:59:46 <jle`> phaazon: composition is different
09:59:49 <jle`> behavior with (.)
10:00:03 <phaazon> I still don’t get it
10:00:07 <phaazon> for instance
10:00:11 <phaazon> if I press a key
10:00:17 <phaazon> I’d like a Wire to handle that
10:00:21 <phaazon> should it output KeyState
10:00:23 <jle`> also...what's really important in netwire isn't the operational aspects...it's the semantics that they represent
10:00:25 <phaazon> or Event KeyState
10:00:37 <jle`> it should be Event
10:00:45 <jle`> interval semantics are things that are on and off for durations of time
10:00:50 <jle`> non-zero durations
10:01:06 <jle`> something like a keypress lasts no amount of time
10:01:06 <phaazon> hm
10:01:06 <phaazon> ok
10:01:20 <Cale> Well, hang on
10:01:20 <phaazon> I see
10:01:21 <jle`> events are for discrete occurrences in time with no duration...just a point
10:01:29 <phaazon> like a dirac
10:01:33 <phaazon> in signal theory
10:01:34 <Cale> The current state of the keyboard is a behaviour
10:01:42 <Cale> The sequence of keypresses is an event
10:01:58 <jle`> Cale: yes.  well in the end it depends on what actually ou want to react on
10:02:16 <jle`> phaazon: again remember that in netwire...what's important isn't the operational aspets...it's the semantics
10:02:24 <phaazon> jle`: yeah
10:02:24 <jle`> well, er
10:02:27 <jle`> in FRP, i mean
10:02:27 <phaazon> so, I have a Wire
10:02:29 <phaazon> like:
10:02:38 <phaazon> onKey :: Wire s e m a (Event KeyState)
10:02:40 <vapidness> :ski For different functions. So the reduce could happen l v r or l r v depending on the order of the fold I wanted.
10:02:43 <phaazon> how can I react to that?
10:02:45 <phaazon> switching?
10:03:07 <Cale> I dunno, I think the operational aspects deserve more attention than they've been given in some cases, but that's for another time :)
10:03:25 <phaazon> and hm
10:03:26 <jle`> i probably made too blanket of a statement, i'll admit :)
10:03:35 <jle`> phaazon: there are a bunch of combinators in Control.Wire.Event
10:03:39 <phaazon> at . onKey
10:03:41 <jle`> it depends on what you want to do
10:03:49 <phaazon> at 3 . onKey
10:04:10 <phaazon> jle`: well., just react to it
10:04:12 <jle`> there are even combinators in Control.Wire.Interval if you want
10:04:15 <jle`> react in what way?
10:04:21 <jle`> how do I "react" to the number 3? :P
10:04:26 <phaazon> no
10:04:27 <jle`> add to it? multiply it? replicate it?
10:04:32 <phaazon> react to a press
10:04:34 <phaazon> onKey
10:04:46 <jle`> and...change a message on the screen?
10:04:57 <phaazon> when onKey emits an Event, I’d like to change a value in my application
10:05:00 <jle`> you could use `hold`, which holds the result of the last event
10:05:07 <jle`> and then fmap the holded value
10:05:18 <quchen> vapidness: The order should simply dictate at which point you visit the common root of elements, so how about this? http://lpaste.net/120780
10:05:21 <phaazon> jle`: what if I want to change my behavior?
10:05:45 <jle`> in what way?
10:05:59 <phaazon> jle`: let’s say I have a Wire that just represents time
10:06:01 <jle`> like i said, there are combinators in Event, Interval, Switch, etc. to transform event streams into other things
10:06:05 <phaazon> as I press the button +
10:06:14 <phaazon> it should multiply the time by 2
10:06:18 <phaazon> and - divide by 2
10:06:28 <jle`> the current simulation time?
10:06:32 <phaazon> no
10:06:35 <phaazon> my application’s
10:06:55 <jle`> your application's running time?
10:07:03 <phaazon> naah :D
10:07:04 <jle`> or is it just a number somewhere
10:07:09 <phaazon> yeah
10:07:13 <phaazon> just something used for feedback
10:07:17 <phaazon> a coefficient
10:07:20 <phaazon> set to 1
10:07:25 <phaazon> an applied on time
10:07:28 <phaazon> the Wire
10:07:43 <jle`> you can accumulate a coefficient by filtering/using hold/fmapping
10:07:50 <jle`> oh wait
10:07:54 <ski> vapidness : i'm still waiting for the types of your two folding functions
10:08:07 <jle`> you can fmap the event to contain a multiplcation/division function
10:08:09 <quchen> vapidness: Since Foldable doesn't have any laws, all of these should be valid folds.
10:08:17 <phaazon> I see
10:08:18 <quchen> Speaking of which, I wonder why the docs of Set don't mention that they're folded in ascending order.
10:08:34 <quchen> (Independent of the fact that being a tree is an implementation detail there.)
10:08:37 <phaazon> I’ll try that later on then
10:09:02 <jle`> phaazon: alternatively you can use accumE
10:09:22 <Profpatsch> Cale: Sorry, got a call.
10:09:39 <ski> quchen : perhaps you're not meant to depend on that ?
10:09:40 <jle`> accumE :: (b -> a -> b) -> b -> Wire s e m (Event a) (Event b)
10:09:50 <jle`> basically a scan/fold over your event stream
10:09:51 <Profpatsch> Cale: Yeah, it’d be simple if there was no hIsEOF, which is of type Handle -> IO Bool
10:09:57 <jle`> so that your output event is a final coefficient
10:10:09 <jle`> that you cinrease or decrease based on the input event, using the folding function
10:10:15 <jle`> and then you can use `hold` at the end of it all :)
10:10:31 <Profpatsch> I can’t find a way to loop over that predicate.
10:10:43 <jle`> hm when did 5.0 come out?
10:10:53 <Profpatsch> It would be trivial if hIsEOF were Handle -> Bool
10:11:03 <ski> vapidness : in one sense of "fold", a typical folding function for your `BST' would have type `forall a r. r -> (r -> a -> r -> r) -> (Tree a -> r)'
10:11:14 <jle`> oh wait nvm it was always 5.0, i aws thinking of 4.0
10:11:24 <vapidness> :quchen. That's pretty much what I have at the moment. I want to try and create one fold function. Where I can pass in two functions. The first function would be applied to each value and the second function would dictate the order in which they were folded.
10:11:44 <quchen> ski: You shouldn't depend on it being a tree, but depending on that fold for Set traverses the set in ascending order is pretty reasonable
10:11:45 <ski> vapidness : however, from what you're talking about, it sounds more like you're thinking of traversing the tree elements in different orders (iow converting to different lists), and then want to fold over the resulting list order
10:12:30 <cko> Hi. Beginner here, just getting familiar with Applicative. Is Haskell mostly just syntax sugar on top of lambda calculus?
10:12:35 <vapidness> :ski Yes except I would like to do it without creating any lists :P
10:12:53 <cko> I'm seeing that <$> is like fmap
10:13:12 <cko> typed* lambda calculus
10:13:15 <moghedrin> cko: <$> isn't like fmap, it is fmap.
10:13:26 <ski> vapidness : btw, IRC custom is to start the message by the nickname of the person you're addressing it to. many IRC clients doesn't highlight a message if it doesn't start with the user's nickname. so if you don't do this, there's more chance of missing the message
10:13:30 <moghedrin> cko: Just an infix version.
10:13:37 * hackagebot neil 0.9 - General tools for Neil  http://hackage.haskell.org/package/neil-0.9 (NeilMitchell)
10:13:37 <cko> so `fmap`
10:13:44 <moghedrin> cko: Yup.
10:13:54 <cko> but only if the parameters satisfy the applicative laws
10:14:23 <ski> vapidness : sure. but abstractly, it's the same thing. also, i wouldn't be surprised if list fusion would mean that there are no intermediate lists created at run-time anyway ..
10:14:27 <jle`> (<$>) is actaully fmap
10:14:31 <jle`> if you look at the source
10:14:41 <jle`> (<$>) :: Functor f => (a -> b) -> f a -> f b
10:14:43 <ski> @type (<$>)
10:14:43 <jle`> (<$>) = fmap
10:14:44 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:14:50 <ski> no `Applicative' in there
10:14:57 <cko> oh.
10:15:06 <cko> thanks!
10:15:14 <jle`> it's defined in Data.Functor
10:15:31 <jle`> infixl 4 <$>
10:15:57 <platz> it's just that <$> (fmap) happens to be useful when working with applicatives
10:16:00 <jle`> you might be thinking of liftA
10:16:03 <jle`> :t liftA
10:16:04 <lambdabot> Applicative f => (a -> b) -> f a -> f b
10:16:14 <jle`> but i think liftA = fmap anyways
10:16:20 <jle`> so maybe not...
10:16:46 <unknownloner> is infixl Int a way to specify the priority for order of operations or w/e
10:16:49 <mmachenry> I am having trouble getting my cabal dependencies list into a sane state. http://lpaste.net/120783 This doesn't work with my project because my executable needs a ton of dependencies, like the ones that are in the library. I figured I should just be able to depend on my library.
10:16:50 <cko> so then liftA is fmap for Applicatives
10:17:16 <jle`> actually no, liftA is not defined with fmap
10:17:27 <jle`> liftA f a = pure f <*> a
10:17:47 <johnw> i'm pretty sure fmap f a = pure f <*> a is one of the applicative laws
10:17:48 <platz> because people want to write "f <$> ax <*> ay" instead of "pure f <*> ax <*> ay"
10:17:48 <dcoutts> mmachenry: you have to not use hs-source-dirs: src
10:17:49 <cko> isn't f <$> a also pure f <*> a
10:18:03 <johnw> the applicative-functor correlation law or something
10:18:09 <dcoutts> mmachenry: otherwise it picks up the source modules directly, rather than getting them from the lib
10:18:32 <dcoutts> mmachenry: which probably means you need to split the exe source modules into a different dir
10:18:49 <jle`> johnw: it's listed on the docs as a consequence
10:18:52 <cko> it just all seems like syntax sugar (taking advantage of pattern-matching)
10:18:55 <johnw> ah, ok
10:19:02 <jle`> well you have pure id <*> x = x
10:19:29 <mmachenry> dcoutts: Where would hs-source-dirs: src go?
10:19:38 <dcoutts> mmachenry: only in the library
10:19:41 <dcoutts> not the exe
10:20:19 <ski> jle` : `instance Functor Blah where fmap = liftA' is a valid instance if you have already made an instance for `Applicative Blah', not depending on this `fmap'/`(<$>)'
10:20:20 <dcoutts> mmachenry: yes, sorry, I meant you cannot use that in the exe. Not that you cannot use it at all :-)
10:20:34 <jle`> ski: mhm
10:20:35 <mmachenry> dcoutts: So change that to hs-soure-dirs: exec and put Main.hs in exec/ ?
10:21:47 <dcoutts> mmachenry: yep
10:22:03 <ski> unknownloner : you specify the precedence (and fixity) of infix operators with `infixl',`infixr',`infix', yes (you can't say `Int' after it)
10:22:07 <dcoutts> mmachenry: along with any other modules that are part of the exe, and not part of the lib
10:22:29 <mmachenry> dcoutts: Is there a convention for that? Is using the exec directory common or is there another?
10:25:30 <dcoutts> mmachenry: no particular convention, main, exe, the name of the prog
10:26:25 <Yushatak> dutifully following tutorial, hit an issue: we had the code "evenSum l = foldl (+) 0 (filter even l)" which works fine, and the idea is to change it to "evenSum l = (foldl (+) 0) . (filter even)" which sounds fine in theory, but throws errors - it needs a type declaration (included in the tutorial), so i put that in there, but it still tells me "Could not deduce (a ~ ([a0] -> a0))"
10:27:32 <Yushatak> (the type declaration is "evenSum :: Integral a => [a] -> a")
10:28:54 <ski> Yushatak : you forgot to remove the `l' in the definiendum (to the left of the `=')
10:29:12 <mmachenry> dcoutts: Thank you.
10:29:27 <ski> @pointless h x = g (f x)
10:29:27 <lambdabot> h = g . f
10:29:32 <Yushatak> ohoh.. you're right
10:29:40 <Yushatak> i didnt see that in the tutorial, missed that change
10:29:56 <ski> Yushatak : conceptually, it goes like this :
10:30:04 <ski>   evenSum l = foldl (+) 0 (filter even l)
10:30:08 <Yushatak> i know, it's like algebraic simplification
10:30:11 <Yushatak> dropping terms on each side
10:30:13 <ski>   evenSum l = (foldl (+) 0) ((filter even) l)
10:30:28 <ski>   evenSum l = ((foldl (+) 0) . (filter even)) l
10:30:32 <jle`> it's almost as if you are reasoning about it as an equation
10:30:33 <ski>   evenSum  = (foldl (+) 0) . (filter even)
10:30:40 <jle`> like some sort if....equational...reasoning
10:31:08 <ski> (extra brackets inserted above for clarity. would usually be avoided in practice)
10:31:31 <ski> `foldl (+) 0' corresponds to `g' and `filter even l' to `h'
10:32:08 <bitonic> is there any way to record coverage of code which is ran at TH time?
10:32:28 <bitonic> alternatively, is there something like `runQ' but that works with functions that operate on module-specific things, e.g. location
10:43:54 <phaazon> btw jle`
10:44:06 <phaazon> how can I use pure Wire and still use IO events?
10:44:18 <jle`> what do you mean by use IO events?
10:44:26 <phaazon> pressing keys, and so on
10:44:37 <jle`> you feed it in as the input to your main wire
10:44:54 <jle`> mainWire :: Wire m (Event KeyPress) (OutputState)
10:45:18 <phaazon> I see
10:45:21 <phaazon> thank you
10:45:29 <jle`> at every timestep, you do the IO to get the keypresses, run the wire, and render teh output
10:45:43 <phaazon> ok, I see how it’s designed now
10:45:50 <phaazon> way clearer :P
10:46:22 <jle`> yeah :)  the only meaningful underlying monad is probably Reader
10:46:45 <jle`> sometimes you can use IO for low level performance hacks
10:47:07 <phaazon> yeah, I see the idea
10:49:35 <Profpatsch> For those of you who are active on StackOverflow: https://stackoverflow.com/questions/28614431/looping-over-a-monadic-predicate
10:50:57 <pavonia> Profpatsch: Did you check out monad-loops
10:52:03 <benzrf> :t whileM
10:52:04 <lambdabot> Not in scope: ‘whileM’
10:52:07 <benzrf> yeah monnad lops
10:55:29 <akurilin2> What is the name of that package that exposes a nice pretty printer for nested data structures? Somethign with g...
10:58:06 <enthropy> IPPrint is one, but probably there's one like it starting with a g
10:58:28 <augur> if anyone is working on GHC 7.10 on the partial type signatures proposal, can you please change the notation away from _? i dont know who's responsible for this (Cale do you know?)
10:58:54 <enthropy> what's so bad about _?
10:59:04 <augur> enthropy: it conflicts with typed holes
10:59:33 <enthropy> one is in expressions, the other is in a types
10:59:45 <augur> enthropy: yes, and you can in principle have typed holes in types
10:59:51 <Profpatsch> pavonia: oh … Oh!
10:59:52 <augur> and this should be added in future versions of GHC
11:01:03 <enthropy> and a typed hole expression that occurs in a type context is going to act differently than an _ that the partial type signature extension will add?
11:02:11 <quchen> augur: What's the difference between a partial type sig and a typed hole? That the latter warns?
11:02:21 <augur> quchen: they're completely different things
11:02:25 <augur> exact opposite things, in fact
11:02:29 <quchen> Oh?
11:02:32 <augur> enthropy: im not sure what you mean
11:02:48 <augur> quchen: a typed hole is a promise by the programmer: "I promise to fill in the program here"
11:03:03 <augur> quchen: a partialt ype signature is a request by the programmer: "Please, type checker, wont you fill in the program here?"
11:03:26 <quchen> Sounds like it's the same thing from the compiler's perspective to me
11:03:30 <augur> not at all
11:03:38 <augur> a typed hole is like undefined
11:03:40 * hackagebot git-annex 5.20150219 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20150219 (JoeyHess)
11:03:42 <jedai> but in both caasihuangse the compiler will have toi infer the hole content anyway (or die trying)
11:03:46 <quchen> In both cases the compiler has to infer the hole's type, and when it's a typed hole hole then it is reported
11:03:53 <augur> quchen: no
11:03:57 <quchen> Oh?
11:04:14 <augur> quchen: a typed hole requires inferred type, a partial signature is not
11:04:27 <lifter> I'm trying to use the System.FilePath library. I have: "/usr" </> "share" </> "dict" </> "words"   ...What is the best way to indicate the root "/" ?
11:04:37 <quchen> augur: Oh really? So a typed hole stays a hole?!
11:04:38 <augur> quchen: a partial type signature is something that the type checker has to CREATE, whereas a typed hole is something that the type checker DEMANDS
11:04:47 <augur> quchen: yes. a typed hole is like undefined
11:05:03 <augur> the programmer is obligated to provide code to fill the hole or else the compiler rejects the program
11:05:11 <quchen> It unifies with everything and then emits a warning, I assume
11:05:26 <quchen> Eh, error even.
11:05:29 <quchen> Right.
11:05:44 <augur> quchen: _ is literally just undefined, but it emits a warning, basically
11:05:58 <augur> quchen: this works:   id :: _ -> _ ; id x = x
11:05:59 <quchen> literally basically? But I think I get what you mean.
11:06:14 <augur> that just means "im too lazy, you fill in the rest of the type"
11:06:23 <enthropy> they are both requests to have a type filled in
11:06:29 <augur> enthropy: no
11:06:31 <augur> no no no
11:06:42 <augur> enthropy: holes are not requests to fill in a type
11:06:44 <augur> they HAVE types
11:06:49 <quchen> I thin augur is saying that a typed hole does not require a type to be filled in. GHC is just polite to do so anyway.
11:06:51 <augur> but they are obligations by the user to fill in a VALUE
11:06:57 <augur> you can have holes in types!
11:07:29 <intl> What's the point of the Error constraint in `Error e => MonadError e (Either e)`?
11:07:29 <augur> dependently typed languages have BOTH of these, for what its worth
11:07:44 <augur> typed holes just say "i havent finished programming"
11:07:53 <augur> partial signs just say "i'm too lazy but i'm done"
11:08:16 <augur> Agda has holes in types and values (same thing really), and it also has PARTIAL types and values
11:08:23 <shapr> @remember chrisdone "would require parens" in haskell world is like saying "would require taking lives"
11:08:23 <lambdabot> Done.
11:08:26 <augur> in agda, _ is for partial values, ? is for holes
11:08:32 <HeladoDeBrownie> intl, essentially lets you pick an appropriate error value for e just from the constraint
11:08:53 <augur> if you write this, it works:   trivial : Unit  ;  trivial = _
11:09:26 <augur> this is a perfectly reasonable program in agda, because the type checker can figure out that _ should be the one and only Unit value
11:09:41 <shelf> _ for value holes does seem a bit incongruous
11:09:42 <augur> it would be like writing this in haskell:   trivial :: ()  ;  trivial = _
11:09:42 <HeladoDeBrownie> intl, for example: strMsg "something happened" is a value :: e
11:10:12 <enthropy> in haskell you'd write trivial = (), which is shorter
11:10:27 <augur> dually you can write this in agda:    fmapForMyParticularType : forall A B -> (A -> B) -> ? A -> ? B
11:10:35 <augur> and the ?'s there are holes of type Set -> Set
11:10:54 <intl> HeladoDeBrownie: But that's not essential for MonadError, is it? `Either e` is still valid without the constraint
11:10:59 <augur> enthropy: you're missing the point
11:11:06 <augur> enthropy: these are separate concepts, with separate use cases
11:11:25 <HeladoDeBrownie> intl, not essential. it's necessity will depend on the context of that piece of code you mentioned.
11:11:27 <augur> this choice WILL come back to bite the GHC devs in the ass
11:11:31 <HeladoDeBrownie> its*
11:11:43 <augur> and i will make sure it does by requesting holes in types
11:12:59 <ski> intl : sillyness
11:13:40 <intl> ski: I'm being silly or the constraint is silly?
11:13:46 <ski> the latter
11:13:50 <shelf> why don't we have holes in types? does it make sense in haskell?
11:14:05 <augur> shelf: it makes PERFECT sense
11:14:13 <augur> we dont have them because the implementers havent done it yet
11:14:20 <monochrom> a hole in a type expression would tell you what kind you need there
11:14:26 <augur> monochrom: exactly
11:14:36 <johnw> shelf: you kind of have holes in types when you don't write the type at all, you can't just do that partially
11:14:39 <bergmark> shelf: usually you can replace it with () or Bool or something and it has pretty much the same effect
11:14:45 <johnw> just can't*
11:14:52 <quchen> augur: Thanks for the explanation, makes perfect sense
11:14:57 <augur> johnw: no thats not a hole at all
11:15:05 <augur> johnw: thats more like a fully partial type sig
11:15:17 <johnw> augur: ah, you're comment about asking the compiler for the code?
11:15:19 <johnw> your*
11:15:20 <augur> johnw: a hole is a obligation. not writing a type sig is NOT an obligation
11:15:20 <quchen> augur: Tell the mailing list about it? Or are partial type signatures in a too early stage
11:15:20 <mpickering> shelf: They are in 7.10
11:15:34 <augur> quchen: i dont know what stage they're in
11:15:45 <quchen> Well when they're in 7.10 that's a pretty late stage.
11:15:48 <augur> im just seeing comments about them a lot later, mistakenly saying they're "typed holes, but for types"
11:15:57 <mpickering> you can either use them like type holes or enable PartialTypeSIgnatures use the inferred types
11:16:01 <augur> which is a HUGE error, and will cause huge problems
11:16:02 <phaazon> I really feel like I suck
11:16:06 <quchen> augur: That's precisely what I thought all the time
11:16:09 <ski> intl : at <https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Error.html#section.i:MonadError>, it's absent
11:16:10 <shelf> oh that is cool
11:16:13 <augur> quchen: right, and they're the OPPOSITE
11:16:14 <shelf> i will dig this up I guess
11:16:30 <quchen> augur: Cotyped coholes? :-)
11:16:35 <augur> quchen: actually yes
11:16:38 <mpickering> augur: What is the problem you are refering to?
11:16:42 <augur> quchen: holes and partials are precisely dual
11:16:48 <shelf> mpickering: what's the extension name?
11:16:48 <quchen> augur: Wait, really?
11:16:51 <augur> quchen: yes
11:16:52 <quchen> In what sense?
11:16:57 <mpickering> PartialTypeSignatures
11:17:09 <mpickering> turning that on allows you to use the inferred type for part of a type signature
11:17:12 <augur> quchen: in that game semantically, a hole for the user is a partial for the compiler, and vice versa
11:17:16 <quchen> You say that like there's a mathematical connection there, not just a perceived symmetry
11:17:19 <mpickering> ie you can write f :: Int -> _ and have GHC infer _
11:17:31 <augur> quchen: if i promise you, you can pretend you have something already, and vice versa
11:17:44 <shelf> oh right, that's not quite what augur was talking about
11:17:45 <quchen> augur: This seems to be the ticket: https://ghc.haskell.org/trac/ghc/ticket/9478
11:18:14 <quchen> Thomas Winant seems to be the author.
11:18:26 <mpickering> But if you don't have PartialTypeSignatures enabled then you can write .. f :: Int -> _ ; f = (+1) and GHC will tell you that _ should be Int but not compile
11:18:33 <mpickering> just like the expression holes
11:18:46 <johnw> augur: https://ghc.haskell.org/trac/ghc/wiki/PartialTypeSignatures seems to be saying something other than what I've understood
11:19:04 <johnw> augur: when I said that it's like omitting the signature, only partially, you said "no", but that's just the example that page gives
11:19:08 <johnw> in that out of date material?
11:19:16 <augur> quchen: so like, if i play Programmer and  write _ with type Int, and you play TypeChecker, its as if you have a hold of type Int that you have to fill in
11:19:57 <augur> ((im using _ here in the Agda sense, sorry -- _ being partials and ? being holes))
11:20:37 <quchen> Since we're using :: and : flipped, why not _ and ? too ;-)
11:20:41 <augur> johnw: the material is simply wrong
11:20:56 <johnw> augur: do you have a link to correct material?
11:21:03 <augur> johnw: this is an error that has been propagating around the haskell sphere for months and its incredibly wrong
11:21:18 <mpickering> augur: I still don't understand what error you are talking about
11:21:33 <johnw> well, considering that's the page on the GHC Trac for this feature, someone should remedy that
11:21:42 <quchen> I understand it and I think you should write it up nicely and then give that to people.
11:21:46 <quchen> Scales much better.
11:21:52 <kaidelong> GHC has partial type signatures?
11:21:57 <mpickering> in ghc 7.10
11:22:01 <kaidelong> oh wow
11:22:03 <kaidelong> that's great news
11:22:13 <augur> johnw: at least if the analogy is that partial types are like holes-for-types
11:22:26 <quchen> typed type holes!
11:22:33 <johnw> lol
11:22:34 <kaidelong> doesn't fundamentally fix the whole "types leak abstraction" issue but should help
11:22:40 <enthropy> kinded type holes
11:22:49 <augur> >> wildcards or 'holes in types'
11:22:52 <augur> from the trac
11:22:55 <augur> this is simply FALSE
11:23:43 <augur> mpickering: the error is two fold. partial _ is not like hole _, and moreover, using _ for both will cause headaches in future versions of GHC
11:24:04 <augur> because either ONE of them will have to change, OR a new notation for holes in types will have to be invented, making it confusing
11:24:08 <phaazon> hm
11:24:23 <mpickering> ok you should post a message on the ghc-devs mailing list then
11:24:26 <phaazon> jle`: if I have a Wire s e m a (Event b)
11:24:34 <enthropy> it would only be a headache if there comes a time when ghc will infer values from types (without using a class method)
11:24:53 <phaazon> I’d like to create a Wire that takes an Event, and inhibts when the Event is Quit
11:24:58 <phaazon> do I have to use whene?
11:25:01 <phaazon> when*
11:25:06 <phaazon> when forwards the parameter
11:25:10 <enthropy> (or somebody decides that kinds are getting difficult, so lets have a feature to help you figure them out)
11:25:12 <phaazon> so I guess it’s not the correct way of doing
11:25:17 <quchen> augur: In the worst case, it's easy to change the typed hole syntax, because it's a non-breaking change
11:25:29 <augur> enthropy: no, it would be a headache if there comes a time when GHC lets you have holes in types
11:25:34 <phaazon> maybe with mkPure_…
11:25:37 <kaidelong> "An extra-constraints wildcard shouldn't prevent the programmer from already listing the constraints he knows or wants to annotate, e.g. "
11:25:39 <kaidelong> oh
11:25:40 <augur> enthropy: which would be relatively straight forward to have right now
11:25:42 <kaidelong> has this changed?
11:25:44 <quchen> augur: So even if it doesn't get changed in due time we can fix it later. And then it'll even be the same as in Agda, with ? issuing the warnings.
11:25:47 <kaidelong> last I knew this proposal was
11:25:54 <kaidelong> your context is either _ => or fully specified
11:26:15 <augur> enthropy:   somethingNeedingAFunctorThatIllAddLater :: _0 a -> Int
11:26:15 <kaidelong> allowing partial contexts would make this pretty much a complete solution to the leaky types issue
11:26:22 <augur> _0 :: * -> *
11:26:33 <augur> which im now obligated to fill in before the compiler accepts it
11:26:52 <augur> note that with partial type sigs, this type would simply be   forall f. f a -> Int
11:26:56 <augur> which is NOT the same
11:26:57 <shelf> so 7.10 with PartialTypeSignatures off fits my understanding of type holes
11:27:27 <kaidelong> GHC has had typed holes for a while but typed holes address a different problem
11:27:27 <shelf> but that understanding might be limited
11:27:42 <augur> _0 a -> Int   as a hole is like writing   Tree a -> Int   but i cant remember that it's Tree right now
11:27:43 <shelf> type holes rather than value holes, Typed Holes was a weird name
11:27:52 <quchen> Typed holes have a history of being misunderstood because they were called "type holes" for a long time. Maybe that's one source for the mixup.
11:27:58 <augur> shelf: no, Typed Holes is the correct name
11:28:07 <augur> shelf: its a hole, which has a type
11:28:19 <kaidelong> what I would really like to see
11:28:21 <augur> or as they're normally called literally everywhere else, its a hole
11:28:48 <quchen> augur: Hole and wildcard, or what's the terminology?
11:29:02 <kaidelong> is a mechanism for which contexts are not, on principle, exposed to the programmer
11:29:09 <kaidelong> who is consuming the code
11:29:11 <augur> quchen: im not sure that wildcard is even a good name either, but
11:29:28 <augur> quchen: i think in the DT literature, there's no standard name. ill look at Agda docs to see what _ is called
11:29:37 <kaidelong> I guess you could just not export the typeclass itself
11:30:22 <augur> and as Haskell becomes increasingly dependently typed, this erroneous conflation will be even MORE problematic
11:30:25 <kaidelong> however it'd be nice if you could say, "this function has some context, but you don't know what it is and you can't write instances for it"
11:30:48 <Yushatak> is there a way to combine a statement like "x <- getArgs" into a statement that then would normally use x, or is it impossible due to the IO for some reason?
11:30:49 <augur> because _ is especially useful when you have dependent types that can narrow down inhabitants to exactly one obvious value
11:31:23 <Yushatak> statement in question is currently "print $ sum $ map read x"
11:31:37 <augur> for instance, its completely plausible to write have a hole  ? : Vec Unit 5  and fill it with  _
11:31:43 <RchrdB> Yushatak: getArgs >>= \x -> print (sum (map read x))
11:31:48 <augur> because there is exactly one such vec: [unit,unit,unit,unit,unit]
11:32:01 <Yushatak> RchrdB: any way to eliminate "x"?
11:32:09 <RchrdB> Yushatak: "x <- getArgs" actually desugars into "getArgs >>= \x -> ..."
11:32:12 <quchen> ?pl \x -> print (sum (map read x))
11:32:12 <lambdabot> print . sum . map read
11:32:20 <augur> not that you'd even need a Vec Unit 5 necessarily but
11:32:37 <RchrdB> Yushatak: sure, point-free style, like quchen demonstrates with @pl
11:32:45 <RchrdB> getArgs >>= print . sub . map read
11:32:54 <RchrdB> er
11:33:04 <kaidelong> incidentally
11:33:10 <RchrdB> getArgs >>= print . sum . map read -- now with one fewer typo
11:33:12 <augur> i should be clear, btw: _ in partial type sigs is the CORRECT notation, and ? is for holes, but that ship has sailed
11:33:26 <kaidelong> this only works when your action as the form a -> IO b, which is true in this case because you're using print
11:33:30 <Yushatak> thanks RchrdB  and quchen
11:33:31 <Yushatak> :3
11:33:32 <kaidelong> if you need to use a pure function
11:33:34 <kaidelong> use fmap instead
11:33:41 <Yushatak> noted
11:33:42 * hackagebot hexpat 0.20.8 - XML parser/formatter based on expat  http://hackage.haskell.org/package/hexpat-0.20.8 (StephenBlackheath)
11:33:46 <kaidelong> fmap (sum . map read) getArgs
11:34:00 <quchen> augur: Correct up to isomorphism.
11:34:04 <kaidelong> or add a return at the end, alternatively
11:34:07 <augur> quchen: :p
11:34:12 <quchen> Anyway, mail the maintainer/implementor.
11:34:17 <augur> also, im heading out for a little bit. mention my nick if necessary so i can find messages in scrollback
11:34:30 <kaidelong> getArgs >>= return . sum . map read
11:34:57 <augur> quchen: im not sure who to email
11:34:58 <kaidelong> the two are guaranteed to be the same
11:35:13 <kaidelong> (it's the law!)
11:35:19 <bennofs> Would there really be much breakage if one changed the TypedHole notation?
11:35:37 <kaidelong> bennofs: none whatsoever
11:35:43 <kaidelong> well
11:35:49 <quchen> augur: Austin merges all the stuff, so he'll know for sure. The commit that implements "partial type sigs" is this one. https://git.haskell.org/ghc.git/commitdiff/d831b6f41b3b89dc4a643069d5668c05a20f3c37
11:35:49 <t7> is there a list startsWith in the haskell platform anywhere?
11:35:59 <kaidelong> I guess some people might have left DeferTypeErrors on in production code
11:36:04 <quchen> augur: It features a name and an email, so that's probably a good start.
11:36:05 <enthropy> augur: there's the author of the patch https://git.haskell.org/ghc.git/commitdiff/d831b6f41b3b89dc4a643069d5668c05a20f3c37
11:36:16 <bennofs> kaidelong: maybe some tools would break
11:36:42 <Yushatak> t7: compare result of "head" on the list to what you'd think of as the arg to startsWith
11:36:48 <kaidelong> bennofs: AFAIK the tools out there still vomit on TypedHoles as it is now and never really implemented it properly, hence why people use _foo instead of _
11:36:51 <chaosmasttter> someone with knowledge about template haskell here?
11:36:57 <t7> Yushatak: i mean [a] -> [a] -> Bool
11:36:59 <kaidelong> but to be fair
11:37:07 <johnw> chaosmasttter: in a channel this size, you should really ask the question and see if anyone has the answer
11:37:12 <kaidelong> the fact that you're able to do _foo is a virtue of the current syntax
11:37:19 <kaidelong> _foo is a valid haskell identifier
11:37:33 <johnw> lots of people here know TH, but whether that means they can or want to answer your particular question is a completely different matter
11:37:35 <chaosmasttter> i would like to have a function f :: a -> PatQ
11:38:07 <Yushatak> t7: listStartsWith list x = return (head list == x)
11:38:13 <kaidelong> anyway I think changing it to ? or something else should be perfectly possible and if it actually breaks things like HLint
11:38:16 <Yushatak> if im not mistaken (im new, might be mistaken)
11:38:20 <kaidelong> that might be an improvement over the status quo
11:38:34 <t7> Yushatak: thankyou for unsafe function :/
11:38:34 <chaosmasttter> which genererates a pattern that only matches the given input
11:38:36 <kaidelong> where things like HLint don't support typed hole syntax at all because it's not an important priority for them
11:38:54 <Yushatak> t7: if you want to make it typesafe that's not exactly difficult, mate :P
11:39:15 <enthropy> chaosmasttter: there's a dataToPatQ http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH-Quote.html
11:39:19 <kaidelong> as it is you can use TypedHoles with tools that don't know about TypedHoles
11:39:25 <enthropy> it might only be in ghc-7.10 though
11:40:04 <Yushatak> t7: oh i just realized you said [a] -> [a] -> Bool
11:44:42 <chaosmasttter> entropy: looks nice, would i use it with (const Nothing) as first argument?
11:47:56 <t7> @Hoogle [Bool] -> Bool
11:47:56 <lambdabot> Maybe you meant: hoogle google
11:48:01 <t7> @hoogle [Bool] -> Bool
11:48:03 <lambdabot> Prelude and :: [Bool] -> Bool
11:48:03 <lambdabot> Data.List and :: [Bool] -> Bool
11:48:03 <lambdabot> Prelude or :: [Bool] -> Bool
11:53:51 <Miko__> Hi. I'd like to interface a different os thread. I tried python, but aparently this is not possible. I want to do the following: Open a process, pipe some data in, and later read the output of that process.
11:54:35 <Miko__> That reading should just return whatever the process outputed at the moment the fucntion is called, no matter wheater the pipe is open or not
11:54:47 <MatthiasHu> t7: isPrefixOf is what you want, isn't it?
11:55:10 <Miko__> I'd like a virutal terminal I think
11:55:29 <Miko__> that i can "look" at any moment
11:55:52 <mmachenry> Miko__: You might be interested in looking at the distributed-process library. aka Cloud Haskell
11:56:03 <mmachenry> I'm not really clear on what you're doing though.
11:58:00 <Miko__> In psydocode: main= do { p <- startProcess "cat"; output p "1"; i <- input p; println i; output p "2"; i <- input p; println i }
11:58:11 <Miko__> That should output simply "1 2"
11:58:44 <Miko__> The process "cat" remains running the whole, time, and the input works before cat is closed
11:59:28 <Yushatak> Miko__: i can tell you that that's absolutely possible with python
11:59:44 <Yushatak> Miko__: check out the subprocess module, if memory serves
11:59:57 <Miko__> I was told i need twisted for that. I tried subprocesses
12:00:22 <Miko__> And I seriously don't want twisted.
12:00:39 <Yushatak> i never used twisted and i did things like you're talking about, but this was years ago
12:03:26 <Yushatak> Miko__: https://docs.python.org/2/library/subprocess.html#popen-objects
12:03:52 <Yushatak> dunno who told you what they did, but unless they had more info about what you're doing than i do, they are wrong
12:04:15 <Yushatak> not to say "don't use haskell", but if you're more comfortable with python for whatever you're doing, it certainly can be done
12:06:46 <augur> quchen, enthropy: ok. now the real question: will it matter that I complain, or would it be more useful for a well known, respected member of the Haskell community to send the email?
12:06:59 <augur> alas, almost certainly the latter
12:08:22 <quchen> augur: I think your complaint has a very good and reasonable basis. A name never hurts, but I think you should be fine like this as well.
12:08:49 <quchen> As long as you're polite and reasonable, people will listen to you. At least that's my impression of the mailing lists.
12:10:05 <j-rock> hey, quick question: does scotty serve requests concurrently?
12:11:11 <johnw> augur: such a person has already been told, and mentioned to me that your complaint would be fairly easy and painless to address; so I recommend asking more formally through the ghc-devs list, where you should find a hearing ear
12:11:28 <RchrdB> Yushatak, Miko__: it's a little tricky to do that with Python's subprocess because proc.stdin.read() can block unless you mark the fd non-blocking. It's a trivial application of asyncore, twisted or any other async-io system though.
12:11:45 <augur> johnw: ok
12:12:41 <RchrdB> proc.communicate() will let you supply a string to be put into stdin and will read from stdout and stderr for you, but you have to decide what bytes to put in up-front and .communicate() assumes that the process will run to completion with just that one string.
12:13:03 <t7> @hoogle [IO [a]] -> IO [[a]]
12:13:07 <lambdabot> No results found
12:13:15 <t7> :t sequence
12:13:16 <lambdabot> Monad m => [m a] -> m [a]
12:14:36 <timthelion> I wonder how many man years have been lost to : "The following packages are likely to be broken by the reinstalls"
12:14:37 <darkroom> in Data.Map most index operations are O(log(n)) time but in Data.IntMap most index operations are (O(min(n,W))) time my question is why would anyone use Data.IntMap instead of using type IntMap a = Map.Map Int a
12:15:14 <RchrdB> darkroom: Data.IntMap's constants are small and W is small.
12:15:21 <timthelion> We should add something like debian popularity contest, which just increments a counter every time that error message gets displayed
12:15:40 <darkroom> so Data.IntMap is actually faster for small data sets?
12:16:12 <darkroom> wish they would say that stuff in hackage
12:18:07 <bitemyapp> darkroom: it says what it's good at in the documentation.
12:18:11 <bitemyapp> darkroom: http://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-IntMap.html
12:18:16 <bitemyapp> "An efficient implementation of maps from integer keys to values (dictionaries)."
12:18:25 <bitemyapp> "The implementation is based on big-endian patricia trees. This data structure performs especially well on binary operations like union and intersection. However, my benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced map implementation (see Data.Map)."
12:20:23 <darkroom> bitemyapp: thanks
12:25:01 <codygman> Came across this blog post, Does anyone here consider this an issue, and if so what is wrong? Does this matter in real world code? http://www.joachim-breitner.de/blog/620-Constructing_a_list_in_a_Monad
12:30:02 <monochrom> it seems to me the true cause is immutable list. mutable list will enable the "simple loop like in imperative languages" option again.
12:30:37 <monochrom> that is, "IO is special" is not a true cause, and laziness is not a true cause either.
12:31:03 <orzo> cause?
12:31:10 <monochrom> to see why: you have the same limitation in SML if you use immutable list
12:31:22 <monochrom> yes, cause.
12:32:05 <codygman> monochrom: Cool, I didn't know that. I had a feeling you could create something that doesn't allocate with Vector, at least I've seen it used in many SO answers to get high performance code.
12:32:21 <c_wraith> codygman: There's no issue. If you have an IO action that builds a list, it *has to build the list*.  It can build it on the stack or the heap, but you have to build the list one way or the other.
12:33:47 <codygman> c_wraith: Right, alright.
12:34:03 <HeladoDeBrownie> c_wraith, what do you mean has to? can't it throw an exception instead?
12:34:10 <monochrom> Data.Sequence is more suitable for this (if you want to stay immutable; I certainly do). the idea is that you want a data structure happy for append.
12:34:31 <c_wraith> HeladoDeBrownie: I didn't say "has a signature that promises a list", I said "builds a list"
12:34:35 <monochrom> immutable list is unhappy for append.
12:35:17 <codygman> monochrom: Would prepend then reverse help things? (slight feeling that would be optimized out.. could be wrong)
12:35:34 <monochrom> lists are ubiquitous in haskell. but we should make them less ubiquitous.
12:35:44 <orzo> hm
12:35:57 <johnw> c_wraith: it's only half-unhappy
12:36:00 <monochrom> not optimized out. everything the article says about that scheme is right. you still pay twice the price.
12:36:01 <orzo> part of the issue might be how heavy-feeling the sequence operators are
12:36:04 <Cale> I disagree that we should make them less ubiquitous
12:36:07 <orzo> compared to the single character :
12:36:08 <RchrdB> codygman: if you do a bunch of prepend operations and then reverse the list once then that's O(n) for all the operations, amortised O(1) per-item.
12:36:10 <johnw> [1,2] ++ [3..100000] is still pretty happy
12:36:37 <Cale> Lists are everywhere because iteration is a really common type of recursion.
12:36:57 <ezrios> so I am using acid-state and needed to change the state I am acidifying
12:37:01 <codygman> RchrdB: Alright.
12:37:02 <ezrios> I don't need to migrate any data
12:37:09 <ezrios> can I just blow away the 'state' folder and `cabal clean`?
12:37:11 <RchrdB> codygman: whereas if you run (reverse . (:x) . reverse) a bunch of times to add elements to a list one by one then it'll take O(n**2) operations since each of those (reverse) calls takes time proportional to the length of the list it's fed.
12:37:16 <ezrios> I'm getting some unexpected results from my compiled code
12:37:20 <simon> ezrios, is acid-state performant these days?
12:37:23 <ezrios> and I suspect it might have to do with all this TH magic
12:37:27 <ezrios> simon: no idea, this is a toy project
12:40:24 <nauman_> @help
12:40:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:40:30 <nauman_> @list
12:40:30 <lambdabot> What module?  Try @listmodules for some ideas.
12:40:36 <Cale> codygman: One thing I will say is that if your list is of a sizeable length, and is meant to be in memory all at once, maybe it shouldn't be a list.
12:40:39 <HeladoDeBrownie> nauman_, what do you need?
12:41:18 <drazak> Cale: in haskell do lists get copied in memory for certain operations?
12:41:19 <Cale> codygman: Lists should generally be thought of as loops waiting to happen.
12:41:31 <Cale> drazak: "copied"?
12:41:39 <Dholli> How would I find an element in a matrix?   findAt :: (Matrix x) -> (Int, Int) -> x         where my matrix is   newtype Matrix x = Mat ((Int,Int),(Int,Int) -> x)    I tried valueAt z (x,y) = map...  but no luck.
12:41:41 <nauman_> Hi, first off i ma new here :) on stackoverflow i saw that i can see src of functions using lambdadot. that's what i want to do
12:41:49 <monochrom> I would avoid the "IO [Int]" mindset altogether. what do I do instead? there are two cases.
12:41:50 <mauke> @src id
12:41:50 <lambdabot> id x = x
12:41:51 <Cale> drazak: Certain operations construct new lists which have similar elements to the old one.
12:42:01 <drazak> Cale: yeah, ok, that's what I was getting at
12:42:02 <Cale> drazak: But generally not the same list.
12:42:04 <mauke> nauman_: don't trust lambdabot too much. it's not showing the real source
12:42:12 <drazak> right, I should have siad copied and modified or whatever
12:42:20 <HeladoDeBrownie> nauman_, your best bet for finding the source of a function is probably hackage
12:42:36 <c_wraith> > filter (< 100) [1..10] -- Cale :P
12:42:37 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
12:42:46 <monochrom> the first case is like what Cale says. if the whole collection of numbers has to stay in memory for a while, use some other data structure.
12:43:09 <nauman_> thanks folks. i will try hackage.
12:43:23 <monochrom> the second case is: you think you want a list because you will iterate over it, one pass, later. that means...
12:43:27 <HeladoDeBrownie> nauman_, do you know what package what you're looking for is in?
12:44:10 <monochrom> that means your program is really of the form: read one number, process it; read one number, process it; etc. then you should use pipes, conduit, or FRP.
12:44:20 <Cale> c_wraith: right, or even filter (const True) :P
12:44:53 <lpaste> S11001001 pasted “while compiling” at http://lpaste.net/120788
12:45:05 <nauman_> i wanted to see the range of Int on my ghc. from hackage it seems it is defined in the Bounded class, by minBound and maxBound
12:45:32 <geekosaur> > (minBound::Int,maxBound::Int)
12:45:33 <lambdabot>  (-9223372036854775808,9223372036854775807)
12:45:37 <Cale> monochrom: There are a lot of cases where any of those things would be massive overkill
12:45:40 <S11001001> While compiling, sometimes I get lots of "Loading package" messages like http://lpaste.net/120788 ; sometimes compiling doesn't do this.  What causes it to happen?
12:45:57 <geekosaur> S11001001, probably Template Haskell
12:46:09 <nauman_> i was able to get the value from ghci. but wanted to see where it is defined
12:46:20 <ReinH> nauman_: You can often use hoogle to find the function in question
12:46:23 <HeladoDeBrownie> wherever the instance Bounded Int is
12:46:26 <ReinH> And then from there its source
12:46:39 <HeladoDeBrownie> probably in the same module Bounded is defined
12:46:47 <S11001001> geekosaur: ah, thanks
12:47:06 <geekosaur> actually I would be surprised if you could find the implementation details for Int that way
12:47:15 <geekosaur> they're likely wired into the compiler
12:47:25 <HeladoDeBrownie> http://hackage.haskell.org/package/base-4.7.0.2/docs/src/GHC-Enum.html#instance%20Bounded%20Int
12:47:38 <HeladoDeBrownie> nauman_, there, although it uses minInt and maxInt, whose location i'm unaware of
12:47:41 <geekosaur> and you'll end up looking inside its configure script to see how it determines its Int implementation
12:48:03 <HeladoDeBrownie> nauman_, ah, probably GHC.Integer
12:49:14 <ezrios> ah, figured it out
12:49:17 <ezrios> nothing to do with acid-state
12:49:26 <ezrios> everything to do with me being an idiot
12:53:04 <juanpaucar> hey some help here
12:53:23 <juanpaucar> how do you deal with cascade cases pattern matching??
12:53:43 <monochrom> I let them live.
12:53:46 <Cale> juanpaucar: Pattern guards perhaps?
12:54:07 <Cale> Or if it's all on Maybe, you could use the monad instance for Maybe to tidy things up
12:54:09 <HeladoDeBrownie> juanpaucar, you can define names for them in a where clause and use the name instead
12:54:28 <monochrom> well, I simplify those that can be simplified, and I let the rest live. c'est la vie, something.
12:54:33 <Cale> juanpaucar: What types are you matching on?
12:54:46 <juanpaucar> can i still do the same with Either to tie things up?
12:54:55 <monochrom> yes
12:54:56 <juanpaucar> i'm matching like 3 eithers and one maybe
12:55:17 <monochrom> so just 4 of them. then I wouldn't bother
12:55:40 <juanpaucar> i don't like cascades =\
12:55:56 <Cale> If you put the code on lpaste.net I'll have a look :)
12:57:27 <juanpaucar> http://lpaste.net/6928732166364856320
12:58:36 <juanpaucar> pls don't judge me i'm kind of n00b
12:59:05 <johnw> juanpaucar: there's no judgement here
12:59:26 <dmead> ?yow
12:59:27 <lambdabot> Has everybody got HALVAH spread all over their ANKLES?? ...  Now, it's
12:59:27 <lambdabot> time to "HAVE A NAGEELA"!!
12:59:49 <dmead> i don't get it lambdabot. you're still not funny
13:00:23 <orzo> codygman, monochrom: I don't see how the blog post's "Attempt 3: The accumulator (reversed)" is using only 8 bytes of stack.  Wouldn't the call to reverse of a 10k list alone be responsible for more stack usage?
13:01:29 <juanpaucar> so, os there anyway to avoid cascades?
13:01:35 <juanpaucar> *is
13:01:44 <juanpaucar> *any way
13:02:47 <ski> juanpaucar : `getTeam teams = listToMaybe (teamByName teams)'
13:03:46 <Cale> Or just use find there
13:03:48 <Cale> instead of filter
13:04:03 <Cale> :t find
13:04:04 <lambdabot> (a -> Bool) -> [a] -> Maybe a
13:04:14 <ski> yes
13:04:27 <ski> what does `errorHandler' do ?
13:04:50 <juanpaucar> ooohh i tottaly forgot abut listToMaybe and find, THANKS
13:04:58 <juanpaucar> errorHandler basically
13:05:07 <juanpaucar> shows the errors in a fancy way
13:05:42 <ttt_fff> lisp has car/cdr; in ahskell, is thre a way to break haskell tuples like this? so I want to define a functino (perhaps via typeclasses) that can take tuples of arbitrary length, i.e. (a, b) -> [_svg a, _svg b], (a, b, c) -> [_svg a, _svg b, _svg c], (a, b, c, d) -> [_svg a, _svg b, _svg c, _svg d] ... where, a, b, c, d, can all be of different types
13:06:10 <ski> what's `_svg' ?
13:06:25 <clrnd> ttt_fff, why not for lists? that's already there
13:06:31 <ski> juanpaucar : i would perhaps consider using something like `Except String IO'
13:06:41 <Hijiri> magical function that homogenizes your types
13:06:48 <Hijiri> or at least that
13:06:49 <ttt_fff> ski : _svg is a "class To_svg a where _svg :: a -> SvgTree"
13:06:52 <Hijiri> s what it looks like
13:06:57 <ttt_fff> clrnd: becuase a, b, c, d are of different types
13:07:03 <geekosaur> ttt_fff, you use pattern matching in Haskell. (:) is exactly cons, which is why we (x:xs) to pattern match a car/cdr pair
13:07:08 <Cale> ttt_fff: Tuple types are completely unrelated to each other in Haskell.
13:07:24 <geekosaur> as such, there are partial functions head and tail corresponding to car and cdr
13:07:28 <ttt_fff> Cale: yes, I don't see anything I wrote which disagrees with ur statement
13:07:40 <ttt_fff> Cale: I want a way to 'break a n-tuple' into 1 elem + a (n-1) tuple
13:07:41 <juanpaucar> ski: thanks a lot
13:07:54 <EvanR> ttt_fff: theres no general function for that
13:07:55 <Cale> ttt_fff: Well, what type should that operation have?
13:08:14 <ski> juanpaucar : then you could apply `errorHandler' to the result if it is `Left msg'
13:08:28 <geekosaur> ttt_fff, tuples are not built from parts, they are not Lisp lists
13:08:30 <ttt_fff> for any n, it sholud have type (To_Svg a1, To_Svg a2, ..., To_Svg a_n) -> [SvgTree]
13:08:42 <geekosaur> (a,b,c) cannot be decomposed into a and b+c
13:08:58 <ttt_fff> geekosaur: is there not some extension which will let me do this? i think there is cool meta programming potential
13:09:02 <geekosaur> (well, it is possible to define typeclasses, with some limitations)
13:09:03 <EvanR> (\(a,b,c) -> [a,b,c])
13:09:17 <Cale> ttt_fff: Wait wait wait, how is SvgTree defined?
13:09:17 <geekosaur> ttt_fff, the general rule is that if you want that then you want a list, not a tuple
13:09:24 <ski> juanpaucar : you'll probably want to define some convenience functions to convert from your current `IO (Either ...)' and `IO (Maybe ...)' results to `Except String IO ...' results
13:09:34 <Cale> You probably just want to be making a list in the first place, rather than a tuple.
13:09:45 <geekosaur> and I see no reason to redefine tuples as almost-lists when we have a perfectly good list type
13:10:09 <ttt_fff> Cale: SvgTree is a class (thikn string), then I have "class To_SvgTree a where _svg :: a -> SvgTree", which is like my "show"
13:10:25 <ttt_fff> Cale: I have objects of different types, like I can convert arbitrary data structures to SvgTree,
13:10:30 <Cale> ttt_fff: SvgTree can't be a class given that you used it as a type in that signature you gave
13:10:39 <Cale> (To_Svg a1, To_Svg a2, ..., To_Svg a_n) -> [SvgTree]
13:10:46 <Cale> ^^ how is SvgTree defined there?
13:10:47 <ttt_fff> so I wnat to do shing like svg_show (GraphObject, ListObject, TextObject, SceneObject)
13:10:58 <ttt_fff> Cale: it's a tree of svg leaf / svg groups
13:11:05 <Cale> ...
13:11:09 <ttt_fff> Cale: like a html5 dom tree, but all svg elements
13:11:23 <Cale> Well, you seem to have lost a bunch of type parameters
13:11:28 <ttt_fff> data SvgTree = SvgLeaf !BBox !SvgLeaf ~                              |             | SvgGroup !BBox [(Vec2, SvgTree)]
13:11:45 <ttt_fff> the "~" come from vim NerdTree
13:11:46 <juanpaucar> ski : thanks i'm adding your suggestions
13:11:47 <clrnd> why not lists again? it could be :: [SvgTree]
13:12:05 <ttt_fff> argh, the problem is I have graph :: Graph, blah :: Scene
13:12:13 <ttt_fff> and right now, I need to do [_svg graph, _svg blah]
13:12:15 <Cale> ttt_fff: So if I pass this operation a pair containing a To_Svg Int and a To_Svg String, what does it do?
13:12:21 <ttt_fff> when I'd prefer to just do _svg_list (graph, blah)
13:12:36 <EvanR> you want a list, so put them in a list instead
13:12:48 <Cale> ttt_fff: How is this To_Svg type defined? How is the type argument involved in its constructors?
13:13:00 <ttt_fff> _magic (graph :: Graph, blah :: Scene, i :: Int, s :: Text) --> should become [_svg graph, _svg blah, _svg i, _svg s]
13:13:03 <clrnd> right, and make `graph` and `blah` members of ToSVG
13:13:15 <ttt_fff> "class To_Svg a where _svg :: a -> SvgTree"
13:13:16 <EvanR> or use a sum type
13:13:20 <Cale> What
13:13:40 <ttt_fff> then I do "instance To_Svg Graph where .... instance To_Svg Int where .... instance To_Svg Text where ... instance To_Svg scene where .... "
13:13:41 <clrnd> let magic = map _svg
13:13:47 <Cale> ttt_fff: classes are not the same thing as types
13:13:52 <ttt_fff> "_svg" is a function of a typeclass
13:14:19 <ttt_fff> clrnd: you can not store [graph, blah, i, s] in a list since they are of different types
13:14:20 <Cale> If To_Svg is a class, you can't write (To_Svg Int, To_Svg String) as a tuple type
13:15:05 <ttt_fff> Cale: "class To_Svg a where _svg :: a -> SvgTree; instance To_Svg Graph where ...; instance To_Svg Scene where ... " ... I don't understand where we are arguing
13:15:07 <clrnd> Cale, why not ...
13:15:42 <Cale> clrnd: Is that an honest question, or are you nitpicking me about ConstraintKinds ;)
13:16:01 <Profpatsch> Now I want to sort a list of a datatype with various fields by one of its fields.
13:16:12 * clrnd would like to say he is, but he is just an ignorant fool
13:16:24 <Profpatsch> I have a feeling Lens can help me with this, but maybe it’s trivial.
13:16:39 <monochrom> orzo: reverse uses O(1) stack
13:16:43 <ski> @kind (Eq Int,Eq Bool)
13:16:44 <Cale> clrnd: Well, it's because classes exist to constrain type variables. There aren't values of type  Eq Int
13:16:48 <lambdabot> Constraint
13:16:49 <ski> @kind (,) (Eq Int) (Eq Bool)
13:16:50 <lambdabot>     The first argument of ‘(,)’ should have kind ‘*’,
13:16:52 <lambdabot>       but ‘Eq Int’ has kind ‘Constraint’
13:16:54 <lambdabot>     In a type in a GHCi command: (,) (Eq Int) (Eq Bool)
13:17:14 <gcganley> @kind (,)
13:17:15 <clrnd> Cale, you are right, I mixed it up with a type, again
13:17:15 <lambdabot> * -> * -> *
13:17:31 <glguy> Profpatsch: That's:    sortBy (comparing someFieldSelector)
13:17:32 <gcganley> :t (,)
13:17:33 <lambdabot> a -> b -> (a, b)
13:17:41 <ski> gcganley : that's separate
13:17:44 <Cale> Profpatsch: sortBy (comparing fieldExtractor)
13:17:48 <clrnd> To_Svg a => (a, a)
13:18:00 <Profpatsch> glguy: Oh, lol. Next time I’m gonna search for „sort“ first.
13:18:01 <Cale> Profpatsch: comparing is defined in Data.Ord
13:18:08 * ski isn't really fond of Haskell using `(,)' on the type level for product / tuple (pair) types
13:18:18 <ttt_fff> how does https://hackage.haskell.org/package/acme-cadre-0.1/docs/Acme-Cadre.html work?
13:18:20 <ttt_fff> looks at implementation
13:18:20 <ttt_fff> oh
13:18:23 <gcganley> ski: i find it annoying that they use the same typelevel and kindlevel names for certain things
13:18:47 <Cale> ttt_fff: lol, yeah
13:18:52 <Cale> ttt_fff: You really don't want this
13:18:55 <ski> gcganley : if they used it for value-level pairs, and also for type-level pairs, i wouldn't mind
13:19:05 <Cale> ttt_fff: There's a reason the module is under Acme.*
13:19:10 <clrnd> ttt_fff, lol, I guess template haskell can do that too
13:19:17 <Profpatsch> Cale: glguy isn’t sort(By) rather slow?
13:19:23 <Cale> Profpatsch: hm?
13:19:26 <glguy> Profpatsch: no
13:19:30 <ttt_fff> Cale: what is acme.* ?
13:19:35 <Cale> ttt_fff: Joke modules
13:19:36 <gcganley> ski: i use (,) in value-level code all the time, espectially in pointless functions but I've never used it in the kind level
13:19:41 <clrnd> I love the coments under Data.List.sortBy
13:19:48 <ttt_fff> hmm I was not aware of that
13:19:52 <ttt_fff> was going to use it
13:19:53 <gcganley> Acme.Unsafe is a riot
13:19:57 <Profpatsch> sort = sortBy compare
13:20:00 <Profpatsch> sortBy cmp = foldr (insertBy cmp) []
13:20:18 <gcganley> :t insertBy
13:20:19 <lambdabot> (a -> a -> Ordering) -> a -> [a] -> [a]
13:20:26 <ski> gcganley : btw, when i say `(,)', i also included the syntax `( ... , ... )'
13:20:34 <gcganley> ski: why?
13:20:35 <Cale> ttt_fff: https://hackage.haskell.org/packages/#cat:ACME
13:20:37 <clrnd> ttt_fff, resuming, can't you use a sum type?
13:20:42 <gcganley> ski: i use that sometimes
13:20:43 <ski> gcganley : .. also, i don't think it exists at the kind level :)
13:21:00 <ski> gcganley : why what ?
13:21:20 <gcganley> ski: i like using ( ... , ... ) in my typesigitures
13:21:28 * ski nods
13:21:45 <gcganley> ski: i really should be using arrows sometimes tho, or bifunctors or something
13:21:46 <Cale> ttt_fff: If you find yourself wanting to stick values of different types into a list, usually the answer is to figure out what you're going to do with them when you take them out again, and stick *that* in the list instead.
13:21:58 <Cale> oh, he left
13:21:59 <gcganley> s/tho/though
13:22:09 <Cale> I wonder if that was a misclick
13:22:10 <clrnd> he came back to lisp
13:25:03 <gcganley> clrnd: who went back to lisp?
13:25:21 <clrnd> gcganley, ttt_fff
13:25:48 <gcganley> clrnd: did he say he used lisp? i didnt catch it lol
13:26:06 <Cale> gcganley: Not exactly, but he was looking for car and cdr operations on tuples
13:26:29 <gcganley> Cale: oh ok, i see where you would assume he came from lisp
13:26:41 <gcganley> s/you/one
13:27:33 <monochrom> just use pattern matching
13:27:35 <mauke> <ttt_fff> lisp has car/cdr; in ahskell, is thre a way to break haskell tuples like this?
13:27:48 <mauke> also because explicitly mentioning lisp
13:28:04 <monochrom> http://www.vex.net/~trebla/haskell/crossroad.xhtml
13:29:45 <glguy> Profpatsch: No, that is not how sortBy is implemented, that's just a simple example implementation
13:30:06 <athan> Hi folks, is there an understandable reason why the package GLUT won't install? I have `libfreeglut-dev` installed :\
13:30:19 <clrnd> well that's cool, I don't recall ever using 'if' unless strictly neccessary though after learning about pattern matching
13:30:47 <clrnd> athan, error log?
13:31:00 <athan> I'm getting a "does not exist error" clrnd
13:31:13 <mauke> cool error log
13:31:24 <athan> one sec :x
13:31:31 <athan> http://lpaste.net/120789
13:31:34 <clrnd> what doesn't exist? ghc? me? you?
13:31:44 <glguy> clrnd: The error log
13:31:48 <lpaste> xnil pasted “No title” at http://lpaste.net/120790
13:31:49 <geekosaur> o.O
13:31:50 <athan> I'm pretty sure existence doesn't :v
13:32:02 <geekosaur> that seems like a cabal-install issue...
13:32:06 <athan> hm
13:32:10 <geekosaur> would suggest rerunning with 0v3 though
13:32:13 <geekosaur> er, -v3
13:32:15 <mauke> that sounds like one of the directories doesn't exist
13:32:16 <xnil> yo, i just pasted "No title"
13:32:17 <athan> glguy++
13:32:19 <clrnd> lol indeed it doesn't
13:32:29 <athan> alrighty
13:32:30 <geekosaur> xnil, how about the code that led to that error
13:32:35 <xnil> i can't figure out what's wrong here, apparently i'm not using bind from the IO monad correctly
13:32:50 <xnil> geekosaur: the only part that i know of that should be relevant is in the error
13:32:55 <geekosaur> however, at the least I see it inferring use of the list monad, not the IO monad
13:33:02 <mauke> xnil: you want fmap, not bind
13:33:19 <geekosaur> hm, yes, that seems likely
13:33:22 <mauke> xnil: bind requires the function to return IO something, but yours returns String
13:33:26 <jle`> fmap :: (a -> b) -> IO a -> IO b
13:33:33 <xnil> oh derp
13:33:34 <jle`> (=<<) :: (a -> IO b) -> IO a -> IO b
13:33:38 <athan> http://lpaste.net/120791 How about this one? :\
13:33:57 <xnil> mauke: OH
13:33:58 <johnw> i thing I often forget when work with Applicative: foo <$> pure x <*> y is the same as foo x <$> y
13:34:09 <jle`> :O
13:34:12 <xnil> the issue is that i'm doing putStr $ gTextToAscii =<< getContents
13:34:14 <xnil> it should be
13:34:23 <mauke> xnil: . instead of $
13:34:24 <xnil> putStr . gTextToAscii =<< getContents
13:34:26 <xnil> yessss
13:34:26 <xnil> :D
13:34:29 <xnil> thanks, sorry
13:34:35 <athan> clrnd? :(
13:34:38 <jle`> phaazon: yes, it isn't :P unless the Event b's come from a
13:35:00 <clrnd> athan, looking at it, it's more verbose for sure, except the error part
13:35:01 <mauke> athan: ls -ld ~/.cabal/logs
13:35:09 <athan> right?? D:
13:35:35 <clrnd> athan, try generating that error log it wants to create so bad first
13:35:37 <athan> if it helps, I tried installing GLUT while connected to wifi, but _before_ I accepted the login system handshake from starbucks
13:35:43 <athan> I'm wondering if it's a caching issue
13:36:01 <xnil> it's doneeee
13:36:04 <xnil> thanks guys
13:36:04 <athan> I also can't `cabal unpack` it - it gives me a "not in tar format" error (one sec)
13:36:24 <orzo> there should be a way to have scheme-like mutable lists that have the same underlying representation as actual haskell lists so that the freeze operation is a no-op at runtime
13:36:25 <athan> http://lpaste.net/120792
13:36:27 <Profpatsch> Is there a readMaybe?
13:37:03 <Peaker> athan: sounds like a corrupt cache in ~/.cabal
13:37:04 <mauke> Profpatsch: http://hayoo.fh-wedel.de/?query=readMay
13:37:04 <clrnd> Profpatsch, reads I think
13:37:06 <geekosaur> http://hayoo.fh-wedel.de/?query=readMaybe
13:37:10 * ski didn't notice them in #lisp
13:37:12 <geekosaur> Text.Read
13:38:00 <orzo> anybody know how doable that is? (scheme-like mutable lists with same underlying representaiton as lists)
13:39:00 <Profpatsch> geekosaur: Oh, hayoo does other non-standard packets too.
13:39:02 <clrnd> athan, could you create the log older?
13:39:02 <ski> orzo : hm, with uniqueness ?
13:39:06 <Profpatsch> geekosaur: How good is the type search?
13:39:17 <geekosaur> not great as yet
13:39:28 <geekosaur> hoogle is better at fuzzy types, hayoo at fuzzy names
13:39:31 <orzo> ski: well i was thinking you'd mutate them only within ST and the freeze before returning
13:39:33 <geekosaur> both are working to meet in the middle
13:39:43 <ski> orzo : unsafe freeze ?
13:40:05 <ski> orzo : or perhaps something like `runSTArray' ?
13:40:09 <Profpatsch> I see
13:40:55 <orzo> ski: like that yes, but the the conversion from mutable structure to immutable one is a compile-time type coercion
13:41:36 <ski> orzo : i suppose the list would be effectively strict
13:42:37 <orzo> ski: yes, i suppose, the question is motivated by this blog post: http://www.joachim-breitner.de/blog/620-Constructing_a_list_in_a_Monad
13:43:15 <athan> Peaker: Shoot.. how should I go about fixing this? Doesn't look cut-and-dry
13:43:25 <athan> Re-bootstrap cabal-install? :s
13:45:38 <Peaker> athan: ls ~/.cabal/packages/hackage.haskell.org/GLUT - poke around there, maybe delete the files in there
13:45:41 <monochrom> athan, it should be safe to clear out $HOME/.cabal/packages (a cache) and "cabal update" again, and download again.
13:45:55 <xpika> > do { let a=2; print a; print 3}
13:45:56 <lambdabot>  <hint>:1:22: parse error on input ‘;’
13:46:16 <monochrom> you need one more pair. {a=2}
13:46:44 <xpika> do { let {a=2}; print a }
13:47:06 <ski> (you can probably omit the outer pair)
13:47:07 <xpika> monochrom: thanks
13:48:29 <xpika> monochrom: i was fearful newlines may have been necessary
13:48:48 * hackagebot paypal-adaptive-hoops 0.10.0.0 - Client for a limited part of PayPal's Adaptive Payments API  http://hackage.haskell.org/package/paypal-adaptive-hoops-0.10.0.0 (fanjam)
13:48:52 <monochrom> :)
13:48:59 <jle`> > do let {a = 2}; Just a; Just 4
13:49:00 <lambdabot>  Just 4
13:49:24 <jle`> @undo do let {a = 2}; Just a; Just 4
13:49:24 <lambdabot> let { a = 2} in Just a >> Just 4
13:50:56 <hodapp> Exception: cvc4: createProcess: runInteractiveProcess: exec: does not exist (No such file or directo
13:51:01 <hodapp> ...great.
13:51:11 <hodapp> a meaningless error failing a cabal build.
13:54:09 <mniip> I'm a little confused here, in context of lens, a thing accessing the value of the Just branch of a Maybe would be what
13:54:18 <mniip> a Traversal?
13:54:35 <glguy> hodapp: It's not meaningless, it's telling you that it requires an executable called cvc4 to proceed, isn't it?
13:54:59 <athan> Has anyone messed with gloss-raster? I'm trying to do some basic image manipulation on all frames of a video
13:55:32 <athan> if so, can you please give an opinion? :)
13:55:40 <Peaker> mniip: a Prism
13:55:58 <mniip> hmm bad example I guess
13:56:09 <Peaker> mniip: unless you compose it with a traversal/lens, and then it becomes a traversal
13:56:24 <Peaker> (see the lens hierarchy)
13:56:35 <mniip> say 'data Foo = None | Some X Y'
13:56:48 <mniip> a thing operating on the X field
13:57:04 <mniip> X is not always present, and to reconstruct the Foo you also need an Y
13:58:51 <Peaker> mniip: so, compose a prism with a lens, you get a traversal
13:59:06 <mniip> so?
13:59:20 <Peaker> Foo=>X is a Traversal, as you said above
13:59:24 <mniip> ok
13:59:39 <Peaker> more precisely, it could be an affine traversal, but no such distinction is actually made
13:59:46 <mniip> ah I think I start understanding now
14:01:30 <mniip> lens operates on one of the fields, prism operates on one of the branches
14:08:31 <mniip> ok now how do I construct a traversal...
14:09:59 <johnw> lenses is to product, as prism is to coproduct.  Given (a, b), you lens to _1.  Given Either a b, you prism to _Left.
14:10:26 <glguy> mniip: https://gist.github.com/glguy/74960a3f1531b64a201b
14:11:50 <Hijiri> serialization is an injection, would perfectly-compressed serialization be a bijective function?
14:12:00 <Hijiri> because it would fill every possible arrangement of bits
14:12:46 <Hijiri> is it theoretically possible to do that even
14:12:56 <Hijiri> well, in general
14:13:18 <Hijiri> since it would be trivial with something like a machine word
14:13:24 <RchrdB> Hijiri: yes/no
14:13:44 <mniip> glguy, so traversal is a function taking some f and then the data, where in case of success you fmap the setter over (f (getter data)) and in case of failure you return pure data?
14:13:55 <Hijiri> RchrdB: thanks
14:14:01 <RchrdB> Hijiri: heh, I mean I think you get stuck if your input is bounded and has a kolmogorov complexity that is a non-integer number of bits.
14:14:15 <Hijiri> I have no idea what a kolmogorov complexity is
14:15:08 <Hijiri> now I have some idea from looking at wikipedia
14:15:16 <RchrdB> uh, in context I mean the "true" amount of information in it in its shortest hypothetically-possible unambiguous respresentation
14:15:17 <glguy> mniip: Yes, you take the updating function and apply it to all the position that a traversal focuses on. You sequence those updates together using <*>, if there are no updates to do at all you use pure (or you can think of it as always using pure since you can have:   pure Constructor <*> f field1 <*> f field2 <*> pure field3
14:16:09 <RchrdB> Hijiri: but otherwise, yes. A perfectly-compressed serialization is also a called a "succint" representation. There's a sub-field of computer science which studies succint data structures.
14:16:32 <RchrdB> one of the nice properties of which is that any bit pattern can only be interpreted in one possible way!
14:16:42 <tomphreek> if I have a l = (Fractional a) => [Maybe a] and an average :: (Num a, Fractional b) => [a] -> b. Is it possible at all to "lift" my average to work on l by skipping Nothing entries (rather than return Nothing if at least one entry is nothing). That's assuming I want to keep o(N) complexity instead of filtering out all Nothing elements.
14:16:43 <RchrdB> and vice-versa
14:17:25 <tomphreek> sorry assuming I want to traverse the list once rather than twice by filtering out all nothing entries first
14:17:30 <nick_named> Isn't Kolmogorov complexity undecidable?
14:17:41 <mniip> nick_named, yes per halving problem
14:17:42 <Hijiri> tomphreek: filtering them out probably won't result in another traversal
14:17:49 <mniip> halting*
14:18:07 <Hijiri> @src catMaybes
14:18:07 <lambdabot> catMaybes ls = [x | Just x <- ls]
14:18:34 <Hijiri> that didn't help
14:18:36 <RchrdB> Hijiri: it shouldn't be hard to prove that a succint serialization is a bijective function, because (serialization) if there are 2 different inputs that both output the same bit string, then it isn't a proper serialization, and (deserialization) if there are 2 different bit strings that both produce the same input then there's 1 bit of wasted information there! so the representation can't be succinct.
14:19:07 <Hijiri> RchrdB: what kind of courses would cover this kind of thing?
14:19:30 <nick_named> Hijiri: A computational theory / complexity course
14:19:41 <Hijiri> alright
14:19:52 <nick_named> There is a chapter about it in Sipser, which you can find online.
14:20:36 <monochrom> the halving problem: given a program P, throw away its second half, does the first half do the same thing as P does?
14:20:38 <RchrdB> Hijiri: I got introduced to that concept by a class on algorithms and another one on computational complexity.
14:20:54 <cfoch> how can I get any value from a Map? I don't care if it is the "first" element.
14:21:08 <Hijiri> I'll probably encounter it in a quarter or two then
14:21:18 <RchrdB> cfoch: take 1 . toList
14:21:28 <RchrdB> or, uh, (listToMaybe . tolist)
14:21:40 <gcganley> @type take 1 . toList
14:21:40 <RchrdB> I'd say (head . toList) but head is partial.
14:21:41 <lambdabot>     Not in scope: ‘toList’
14:21:41 <lambdabot>     Perhaps you meant one of these:
14:21:41 <lambdabot>       ‘F.toList’ (imported from Data.Foldable),
14:21:54 <RchrdB> @type take 1 . Data.Map.toList
14:21:55 <lambdabot> M.Map k a -> [(k, a)]
14:22:06 <RchrdB> @type listToMaybe . Data.Map.toList
14:22:06 <lambdabot> M.Map k a -> Maybe (k, a)
14:23:11 <RchrdB> cfoch: Data.Map.toList *will* always give you the "first" element from the Map first, but if you're happy with any arbitrary element from it then that shouldn't actually be a problem for you?
14:23:14 <Peaker> mniip: A traversal is a function that lets you map over some parts in a whole to read/change them effectfully.  Another way to look at it is to say a traversal identifies some 0..N positions within a type that you can read or modify (effectfully)
14:24:21 <Peaker> cfoch: if Data.Map let you take an arbitrary element, exposing its internal structure, it could be problematic w.r.t (==).  x == y   would no longer imply the same results/semantics for pure functions operating on the map
14:24:39 <cfoch> snd $ head $ toList x  ?
14:25:24 <xnil> anybody here got experience with Data.Bimap?
14:25:52 <mmachenry> xnil: You should just ask a question.
14:27:54 <worldsayshi> Is there a way to “hide” a persitent variable inside an IO monad so that you for example can have a function ‘count :: IO Int’ where the first call gives you 1, the second give you 2, etc… ?
14:28:24 <monochrom> yes, but you will use unsafePerformIO
14:28:25 <c_wraith> worldsayshi: sure.  Think about the type IO (IO Int)
14:28:47 <monochrom> but perhaps IO (IO Int) is better
14:28:55 <gcganley> :t join
14:28:56 <lambdabot> Monad m => m (m a) -> m a
14:29:25 <monochrom> no, join is likely not useful for this
14:29:29 <c_wraith> gcganley: if your first impulse is to join an IO (IO Int), you're losing the benefit of it being a different type than IO Int
14:30:14 <monochrom> unless you invoke "every time I use >>=, it hides a join"
14:31:07 <worldsayshi> I wa thinking that Mvars would somewhat be the way to do that, but they seem to have another purpose..
14:31:20 <worldsayshi> *slightly
14:31:22 <monochrom> IORef sufficies
14:31:22 <c_wraith> worldsayshi: something like do { ref <- newIORef 0 ; return do { x <- readIORef ref ; writeIORef ref $! x + 1 ; return x } }
14:31:38 <monochrom> or TVar if you really worry about race conditions
14:31:52 <ski> (worldsayshi : .. there is only one `IO' monad)
14:32:01 <monochrom> MVar is, in fact, a roundabout way, i.e., more indirect
14:32:48 <worldsayshi> I’m actually thinking of having something like ‘initCounter :: Int -> IO Int’ that returns functions of type ‘IO Int’
14:33:02 <RchrdB> cfoch: yeah, (snd . head . toList :: Data.Map k v -> v), but that will throw an exception if the map is empty, which is why I suggested listToMaybe in preference to head. :)
14:33:20 <c_wraith> worldsayshi: you sure you don't want `initCounter :: Int -> IO (IO Int)` ?
14:33:31 <c_wraith> worldsayshi: my example bears consideration
14:34:00 <lightstep_> worldsayshi: it is impossible in Haskell, without using unsafePerformIO or exposing the variable to other functions, even though the type makes sense
14:34:09 <monochrom> because if you don't go c_wraith's way, then you will have to go unsafePerformIO.
14:34:56 <worldsayshi> Hmm, seems strange to use a variable input to Ioref
14:34:59 <worldsayshi> ...
14:35:11 <worldsayshi> *newIORef I mean
14:35:18 <c_wraith> why?
14:35:43 <monochrom> you will have a newIORef somewhere. or newTVar. or newMVar.
14:35:44 <mniip> does lens have a builtin read-show prism?
14:36:08 <monochrom> if you find it counterintuitive, your intuition is wrong. fix your intuition.
14:36:17 <mniip> ah, _Show
14:36:34 <Welkin> everything in physics is counter intuitive
14:36:48 <Welkin> the world goes against your intuition
14:37:18 <lpaste> xnil pasted “Weird Bimap issue” at http://lpaste.net/120794
14:37:27 <Hijiri> install cybernetics to fix your intuition
14:37:28 <hodapp> at $last_jerb I had at least one person tell me rather emphatically that if a system went against his intuition, it was a bad system, period.
14:37:30 <Hijiri> transhumanism
14:37:48 <Hijiri> quantum mechanics now comes naturally but no one can fry a nice pancake
14:38:12 <geekosaur> just remember that the next piece of really lousy code you see came from someone's intuition...
14:38:15 <hodapp> quantum mechanics sure doesn't come too naturally to me.
14:38:22 <mniip> Hijiri, nah a nice pancake is very easy to represent mathematically
14:38:36 <worldsayshi> c_wraith: Oh, I think I understand it now
14:38:39 <hodapp> quantum delayed choice experiment = WTFFFFF
14:38:53 <mniip> k t cos(t) + i k t sin(t)
14:39:00 <monochrom> that sounds like lazy evaluation! :)
14:39:20 <koala_man> hodapp: I'm not surprised you left :|
14:39:28 <monochrom> hGetContents is like "when are you going to read it, really?"
14:39:51 <koala_man> working with people who aren't interesting in exploring and learning is no fun
14:40:06 <hodapp> koala_man: it was a group of very intelligent people who had some gaping blind spots.
14:40:19 <monochrom> work with me! I give you great fun. and great pun.
14:40:32 <mniip> monochrom, that was terrible
14:40:38 <carlos_danger_69> lololo
14:40:56 <monochrom> http://lpaste.net/77374
14:41:48 <koala_man> hodapp: was it an unwillingness to try new things or an odd expression of the principle of least astonishment?
14:42:01 <hodapp> koala_man: probably the former
14:42:11 <monochrom> I think it's "I am always right"
14:42:40 <monochrom> I'm sure, for example, they're happy to learn new things they consider right.
14:42:42 <hodapp> when it came to programming languages, they felt like they'd seen everything that was going to be developed.
14:42:52 <hodapp> and they hadn't seen a single functional language.
14:43:53 <monochrom> anyway please enjoy all my delayed choice experiments in my paste. they are not quantum! just unsafeInterleaveIO. pretty tame. :)
14:44:24 <sw17ch> is there a way to build an instance of QuickCheck's Arbitrary that accepts a run-time template that can guide the generation?
14:45:58 <xnil> http://lpaste.net/120794 why do Bimap.member and Bimap.lookup expect lookupTable to have the type :: (Ord a) => Bimap a a?
14:46:10 <xnil> it should be :: (Ord a, Ord b) => Bimap a b
14:46:57 <zling> gotshues
14:47:10 <zling> Caoookie Cri$SSSSP
14:47:37 <ReinH> sw17ch: Arbitrary just describes a way to provide a Gen a for instance a. You can just write your own function that returns a Gen a for whatever a you have.
14:47:53 <ReinH> You don't need to use the typeclass at all.
14:48:32 <Peaker> doesn't it also have the shrink stuff?
14:48:48 <sw17ch> ReinH: i’ve done this already, but afaik, it would still need shrinking, etc, right?
14:49:03 <worldsayshi> Haskell makes “all” assumptions about how to write readable code go out the window
14:49:31 <ReinH> Sure, but your arbitrary class would already provide that
14:49:53 <sw17ch> ReinH: well, all i have is a function that results in Gen a
14:49:59 <sw17ch> i can’t actually make the Arbitrary class instance
14:50:02 <sw17ch> that’s the problem :)
14:50:08 <stool> Does fgl have toposort?
14:50:44 <ReinH> Right, I'm just saying you don't need to use the Arbitrary class at all.
14:51:20 <sw17ch> ReinH: sure, but then i don’t get shrink
14:51:24 <sw17ch> that’s all
14:51:42 <Hijiri> you could write shrink separately
14:51:48 <Hijiri> well, you might be able to
14:52:04 <Hijiri> if you can write it separately you can write it separately
14:52:10 <ReinH> I guess that's true.
14:52:20 <sw17ch> hah, the magic would be if i was able to pass in some context to the quickCheck function that gets passed to arbitrary
14:52:27 <ReinH> I suppose you could package up the function into a record and then make an arbitrary instance of *that*.
14:52:55 <sw17ch> ReinH: that’s what i’ve attempted. it has its own set of problems: namely the lack of a Show instance that’s required by quickCheck
14:53:05 <ReinH> You can define your own show instance.
14:53:26 <sw17ch> true, but it won’t contain useful information
14:53:39 <sw17ch> o
14:53:41 <sw17ch> oops.
14:53:45 <ReinH> You could also package the arguments to the function rather than the function itself.
14:53:48 <ReinH> If you want to show those
14:53:54 <monochrom> stool: it may be Data.Graph.topSort
14:54:05 <sw17ch> the problem is that i’d rather have it show the result of the evaluated function, not the arguments
14:54:15 <sw17ch> i already know what the arguments are ahead of time. they’ll be static.
14:54:18 <ReinH> Well, you can have it do that.
14:54:20 <monochrom> err, no, that's in containers, not fgl
14:54:35 <ReinH> If they're static, why can't you bake them into the Arbitrary typeclass?
14:55:01 <monochrom> stool: oh, Data.Graph.Inductive.Query.DFS.topsort, also topsort'
14:55:05 <sw17ch> ReinH: because there’s no way to set what their data should be
14:55:12 <ReinH> Why not?
14:55:12 <lightstep_> xnil: the return value of lookup is wrapped in a monad and ghc assumes it []
14:55:32 <sw17ch> newtype FunWrapper = FunWrapper Arg (Arg -> MyType)
14:55:49 <sw17ch> arbitrary :: Gen FunWrapper
14:55:54 <sw17ch> there’s no way to inject what Arg should be
14:56:11 <HeladoDeBrownie> xnil, lightstep_, the explanation should not contain the word "monad", which has nothing to do with it.
14:56:26 <ReinH> yourGenFunction :: Int -> Int -> Gen Foo; instance Arbitrary Foo where arbitrary = yourGenFunction 1 2 -- or whatever
14:56:40 <ReinH> If they're static, pre-apply them
14:56:45 <sw17ch> ReinH: ah, sorry. not compile-time-static
14:56:49 <sw17ch> static for the run of arbitrary
14:56:52 <ReinH> Ah.
14:57:00 <lightstep_> my cOmputER was in tHe rain< kbd borken> trying to restARt
14:57:16 <HeladoDeBrownie> xnil, essentially, the way maps tend to be implemented in haskell, they're binary search trees, which requires that you be able to order the elements to look them up efficiently.
14:57:40 <HeladoDeBrownie> xnil, that's what the Ord constraint represents; the elements have a defined (total) ordering.
14:57:46 <josephle> is lightstep_ somebody's markov bot?
14:59:21 <stool> monochrom, Thanks1
14:59:38 <orzo> i need to parse pcap-saved packets. What's good for this?  I want something that knows all about UDP so i can focus on the content of certain UDP packets.  I see network-house-0.1.0.1 on hackage, but that presents me with an issue converting between UArrays and ByteStrings.
14:59:46 <nerium> How do uninstall cabal?
14:59:54 <xnil> HeladoDeBrownie: oh, i see. now why do Bimap.lookup and Bimap.member seem to assume the 2nd argument has a type Bimap a a instead of the correct Bimap a b?
14:59:56 <HeladoDeBrownie> nerium, how did you install it?
15:00:05 <nerium> HeladoDeBrownie: I'm not sure
15:00:36 <HeladoDeBrownie> nerium, what os do you run?
15:00:41 <xnil> specifically, Bimap Char String for asciiToG
15:00:41 <nerium> osx
15:00:43 <geekosaur> perhaps the correct question is, what problem are you trying to solve?
15:00:45 <sw17ch> ReinH: i’m going to give this a shot: https://hackage.haskell.org/package/QuickCheck-2.7.6/docs/Test-QuickCheck-Function.html
15:01:00 <ReinH> sw17ch: neat!
15:01:07 <ReinH> Seems reasonable.
15:01:23 <xnil> geekosaur: i want to lookup a value of type String with a key of type Char from a bimap of type Bimap Char String
15:01:39 <geekosaur> xnil, sorry, I meant nerium
15:01:42 <xnil> oh, ok
15:01:47 <geekosaur> (although it is a good general question...)
15:01:56 <xnil> (indeed)
15:02:04 <nerium> I'm trying to re-install ghci and cala
15:02:06 <nerium> *cabal
15:03:02 <HeladoDeBrownie> xnil, huh, that is an unwieldy api. regardless, i notice one thing that could simplify your code: you don't need to use member then lookup; that is repeating work.
15:03:13 <HeladoDeBrownie> xnil, simplifying your code may make it easier to spot errors
15:03:20 <lightstep> this actually happened just now my shift is intermittently stuck
15:03:38 <xnil> yes, HeladoDeBrownie, i wasn't sure how to deal with the monad that lookup returns however
15:03:41 <HeladoDeBrownie> xnil, i see what lightstep might have been getting at, which is that lookup has a Monad constraint. let's ignore that and set m ~ Maybe, which is probably the sanest thing to do anyway.
15:03:59 <xnil> *ahem* i'm not sure how that's done
15:04:35 <xnil> do you just deal with it as though it were of type Maybe a?
15:04:41 <geekosaur> nerium, most people seem to install on OS X using https://ghcformacosx.github.io/
15:04:56 <HeladoDeBrownie> xnil, essentially. depending on how you use it you might sometimes have to provide types to avoid ambiguity.
15:05:09 <xnil> yeah, i'm just confused as to where i need to provide the type
15:05:10 <lightstep> asciiToG should have type Char -> Maybe String
15:05:18 <nerium> geekosaur: I'll give it a try, thanks"
15:05:19 <nerium> !
15:05:21 <xnil> erm
15:05:24 <idetuxs> Hi, I have some super simple error involving types
15:05:43 <idetuxs> g'day
15:05:55 <Hijiri> put it on lpaste and link to it in here, then someone can look at it and help
15:05:55 <xnil> lightstep: i want asciiToG to return just the strin...
15:05:57 <xnil> oh. ew.
15:06:04 <idetuxs> ok, thanks Hijiri
15:06:04 <xnil> this is terribly polluted by the monad system
15:06:31 <Hijiri> idetuxs: It would also help to paste the relevant code
15:06:32 <xnil> thanks though, HeladoDeBrownie and lightstep
15:06:40 <HeladoDeBrownie> xnil, let's make it easy then: define lookupMaybe :: (Ord a, Orb b) => a -> BiMap a b -> Maybe b ; lookupMaybe = BiMap.lookup -- and equivalent for lookupR. you can also name it differently
15:06:44 <phaazon> hey
15:06:51 <lightstep> so use only lookup and not member and use "maybe" on the result
15:06:56 <phaazon> I don’t understand the type of until, from netwire
15:07:10 <HeladoDeBrownie> xnil, this is why i think the api is flawed: with the information lookup provides, a Maybe is more than sufficient, you don't need Monad there, it's wrong even
15:07:21 <phaazon> Wire s e m (a,Event b) a
15:07:34 <phaazon> the documentation says it produces until the given event occurs
15:07:45 <phaazon> so it produces a stream of a until the Event b happens, ok
15:07:58 <phaazon> but then, it « inhibts with its value » forever
15:08:00 <phaazon> which value?
15:08:04 <HeladoDeBrownie> if i looked in the source code of that module i'm sure i would see fail  used
15:08:07 <phaazon> b? how could that be so?
15:08:23 <Hijiri> maybe it's supposed to be Event e?
15:08:24 <idetuxs> yes, Hijiri I'm on it, it's just a single line function
15:08:47 <HeladoDeBrownie> fail was an inappropriate addition to Monad, it should not be used in generic code.
15:09:48 <lpaste> Idetuxs pasted “Int to Float” at http://lpaste.net/120795
15:10:14 <lightstep> HeladoDeBrownie: there used to be a large part in the community once that thought it's correct for the return type to be and monad: http://web.archive.org/web/20070614151632/http://www.haskell.org/hawiki/NotJustMaybe
15:10:24 <idetuxs> there it is
15:10:27 <lightstep> *any
15:10:39 <Hijiri> idetuxs: The problem is / isn't defined for Int
15:10:42 <Hijiri> :t /
15:10:43 <lambdabot> parse error on input ‘/’
15:10:45 <Hijiri> :t (/)
15:10:46 <lambdabot> Fractional a => a -> a -> a
15:10:56 <mniip> idetuxs, it's spelled average
15:11:00 <Hijiri> Additionally, the arguments type to / must be the same as the result type
15:11:08 <HeladoDeBrownie> lightstep, if you do that, you should probably have a warning in big glowing letters in your documentation that your api relies on fail, which is unsafe to use generically.
15:11:13 <Hijiri> you will need to explicitly convert x + y + z to Float
15:11:22 <Hijiri> :t fromIntegral
15:11:22 <lambdabot> (Num b, Integral a) => a -> b
15:11:26 <Hijiri> this should do the trick
15:12:24 <idetuxs> yes, mniip , thanks
15:12:26 <Hijiri> :t fromIntegral `asAppliedTo` (5 :: Int) (6 :: Int)
15:12:27 <lambdabot>     Couldn't match expected type ‘Int -> a’ with actual type ‘Int’
15:12:27 <lambdabot>     The function ‘5 :: Int’ is applied to one argument,
15:12:27 <lambdabot>     but its type ‘Int’ has none
15:12:37 <lightstep> HeladoDeBrownie, of course :) the package was probably not updated in a long while
15:12:43 <Hijiri> :t fromIntegral `asAppliedTo` (5 :: Int)
15:12:44 <lambdabot> Num b => Int -> b
15:12:55 <HeladoDeBrownie> yeah, i'm seriously considering sending a pull request with an api change (and major version increment)
15:13:11 <mniip> @src asAppliedTo
15:13:11 <lambdabot> Source not found. You type like i drive.
15:13:35 <init> mniip: const :: (a -> b) -> a -> (a -> b)
15:13:43 <mniip> ah
15:13:44 <mniip> makes sense
15:14:16 <ReinH> mniip: You can look in lambdabot's L.hs file
15:14:16 <idetuxs> ok, so simple use fromIntegral like a normal function
15:14:17 <ski>   f `asAppliedTo` x = f `asTypeIn` ($ x)
15:14:41 <ski> @src asTypeIn
15:14:41 <lambdabot> a `asTypeIn` f = a where _ = f a
15:14:41 <lambdabot> infixl 0 `asTypeIn`
15:15:06 <HeladoDeBrownie> lightstep, also sorry about jumping the gun a bit earlier, in my attempt at answering the question i completely missed the potential relevance of yours; i don't think it quite answered the question, but it was probably a bit much for me to say it had "nothing to do with monad" since lookup does indeed involve that
15:15:09 <mniip> :t let z = fromIntegral `const` z (3 :: Int) in z
15:15:10 <lambdabot> Num b => Int -> b
15:15:18 * ski made `asTypeIn'. can't recall who made `asAppliedTo'
15:15:52 <HeladoDeBrownie> (however inadvisable that design choice may have been)
15:16:33 <HeladoDeBrownie> if they wanted it to be generic, MonadPlus would've been a better option, but all the information necessary is captured by Maybe.
15:16:51 <lightstep> HeladoDeBrownie: no offence taken. and if you take the time to advance this interface change it'll be nice
15:17:03 <ski> @type map `asTypeIn` \map f -> unlines . map f . lines  -- typical example use
15:17:04 <lambdabot> (String -> String) -> [String] -> [String]
15:17:22 <HeladoDeBrownie> i think i just might, either that or if the author is unresponsive write my own, since i've found myself wanting bimap before as well (and have brushed with the ambiguity errors resulting from it)
15:17:32 <HeladoDeBrownie> (i had forgotten this until after answering)
15:18:15 <HeladoDeBrownie> although right now i should probably be working on one of my existing projects :) going to semi-idle
15:18:33 <mniip> ski, I'd write that as...
15:19:11 <mniip> :t let map' = map `const` (\f -> unlines . map' f . lines) in map'
15:19:12 <lambdabot> (String -> String) -> [String] -> [String]
15:19:39 <xnil> yeah, my application does not work well with the Maybe monad at all :s
15:20:12 <idetuxs> What is the class of Integral? because hugs requires an instance of such for the definition
15:20:29 <ski> mniip : i think that looks strange :)
15:20:32 <mniip> class of Integral?
15:20:34 <mniip> Integral is a class
15:20:36 <monochrom> Integral is already the class
15:20:43 <HeladoDeBrownie> xnil, want to show your latest attempt?
15:20:47 <idetuxs> oh, sorry I made a mistake
15:20:48 <monochrom> instances are Int and Integer. you can also add your own.
15:21:05 * ski . o O ( "In the class of Integral, they're all countable." )
15:21:13 <monochrom> :)
15:21:21 <idetuxs> Yes, I meant to ask the instances possible
15:21:32 <ski> @instances Integral
15:21:33 <lambdabot> Int, Integer
15:21:33 <idetuxs> but, I had change the code and now is fine
15:21:44 <idetuxs> Thanks!! ^^
15:21:58 <idetuxs> very helpfull everyone
15:22:02 <ski> @instances-importing Data.Int Integral
15:22:03 <lambdabot> Int, Int16, Int32, Int64, Int8, Integer
15:22:09 <monochrom> mirror mirror, who's the fairest? integral integral, who's the most countable?
15:22:18 <idetuxs> :P
15:22:19 <JamesJRH> Hi. I have written a recursive function and now I want to create a list of each iteration. What is the best way to do this?
15:22:27 <bananagram> @instance Num
15:22:27 <lambdabot> Maybe you meant: instances instances-importing
15:22:27 <Hafydd> Is {} the most countable set?
15:22:33 <xnil> HeladoDeBrownie: the thing is, the lookup returns a Maybe monad containing either Just a value in the Bimap or Nothing, and when it's nothing i want to return Just the Bimap key that was used... my issue was that i couldn't concatenate Just Strings but i just realized i can use fmaps here
15:22:33 <HeladoDeBrownie> JamesJRH, that's captured well by scanr and friends
15:22:35 <bananagram> @instances Num
15:22:35 <HeladoDeBrownie> @type scanr
15:22:36 <lambdabot> Double, Float, Int, Integer, Product a, Sum a
15:22:37 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
15:22:46 <mniip> @instances-importing Acme.Cadre PearShaped6
15:22:47 <lambdabot> Couldn't find class `PearShaped6'. Try @instances-importing
15:22:50 <mniip> :/
15:22:57 <monochrom> answer: your atoms are countable, but Count Dracula is even more countable. also Count Monte Christo
15:23:04 <JamesJRH> HeladoDeBrownie: Well I was thinking about ‘iterate’.
15:23:04 <ski> JamesJRH : linearly recursive ?
15:23:07 <idetuxs> Thankyou very much to all, I'm going to keep writing
15:23:09 <JamesJRH> @type iterate
15:23:10 <lambdabot> (a -> a) -> a -> [a]
15:23:15 <idetuxs> code
15:23:20 <HeladoDeBrownie> JamesJRH, ah, yeah, maybe that's more appropriate
15:23:33 <HeladoDeBrownie> depends on what you're doing i guess
15:24:04 <lightstep> :t Data.Maybe.maybe
15:24:05 <lambdabot> b -> (a -> b) -> Maybe a -> b
15:24:10 <JamesJRH> But when I tried with iterate, I realised that I still have the recursion in each element of the list, and the list doesn't terminate.
15:24:19 <JamesJRH> ski: I don't know.
15:24:29 <HeladoDeBrownie> JamesJRH, do you need to see the whole list?
15:24:55 <HeladoDeBrownie> (also do you need it to recurse forever?)
15:25:01 <ski> JamesJRH : perhaps it would be best if you made a paste ?
15:26:17 <JamesJRH> So I have a function that calls itself. Each nesting is an iteration. I want to put each iteration in a list.
15:27:04 <ski> is there a sequence of iterations ?
15:27:09 <ski> or is it more like a tree ?
15:27:18 <mniip> you need to rewrite it to accept the value of the previous call as an argument
15:27:19 <chirpsalot> JamesJRH: you mean kind of like a scanl?
15:27:21 <mniip> then you can iterate that
15:28:03 <JamesJRH> ski: Yes, a sequence. Is that what you meant by linear?
15:28:12 <ski> yes
15:28:30 <ski> each call to the function (directly) calling itself recursively at most once
15:28:53 * hackagebot chatter 0.5.0.1 - A library of simple NLP algorithms.  http://hackage.haskell.org/package/chatter-0.5.0.1 (RoganCreswick)
15:29:01 <ski> as opposed to having two recursive calls in the recursive defining equation of a function that traverses a binary tree, e.g.
15:29:36 <ski> JamesJRH : anyway, the best way to do it probably depends on how you've set up your recursion
15:29:51 <dulla> nlp?
15:29:59 <ski> Neuro-Linguistic Programming
15:30:47 <JamesJRH> ski: What would that be called? So there's linear recursion and what recursion?
15:31:02 <JamesJRH> mniip: That's what I was thinking.
15:31:05 <mniip> according to the page, Natural Language Processing
15:31:06 <ski> (could also be "Non-Linear Programming" or "Natural Language Programming" ..)
15:31:12 <levi> JamesJRH: If your function is directly recursive, it just has to evaluate to a list constructor instead of a value. Using other functions like 'iterate' won't work if your function calls itself directly.
15:31:19 <ski> JamesJRH : binary
15:32:04 <ski> levi : by "directly recursive", do you mean "tail recursive" ?
15:32:36 <levi> ski: No, I just mean 'recursive' itself rather than recursive when combined with a recursive combinator.
15:32:56 <JamesJRH> mniip: But if I rewrite it I'll break the normal recursion. What I'm puzzled about, is what the point in thinking in terms of recursion if one will only find that they have to rewrite it in a nonrecursive way to do certain things.
15:33:00 <JamesJRH> ?
15:33:01 <rampant> Hello :)
15:33:12 <mniip> JamesJRH, could you provide an example of such a function?
15:33:27 <ski> levi : what if we have something like `f x = foo (f (..x..))' (for the recursive case) ?
15:34:20 <ski> JamesJRH : i mean .. possibly you could try to use something like my "repaste of PoorManDebug" <http://lpaste.net/10060> -- but it's not clear that it doesn't suffice with something simpler
15:35:38 <JamesJRH> levi: I'm confused by ‘list constructor’ and ‘recursive combinator’.
15:36:12 * ski also isn't sure what levi meant by "recursive when combined with a recursive combinator"
15:36:25 <levi> JamesJRH: The list constructors are : and [], so if you want your recursive function to build a list it needs to wrap its recursive calls with them.
15:36:46 <JamesJRH> Okay, binary recursion. This is linear because it calls itself once or not at all.
15:36:54 <ski> yes
15:37:02 <ski> (perhaps it should be called "affine" instead ..)
15:37:38 <levi> ski: I'll just let you help. :P
15:38:37 <ski> well, i can't do much until i see some source .. :)
15:39:07 <rui> what irc clients do you people use? (and what OS)
15:39:35 <moghedrin> rui: irssi y gentoo
15:39:44 <carlos_danger_69> irssi
15:39:50 <ski> /ctcp rui version
15:40:06 <mniip> provide an example of what you're dealing with
15:41:36 <rampant> Hi everybody. I've been stuck on this for about a week. How can I get this fold to fold in order. https://gist.github.com/patrickcorrigan/348e4acb84c74e02b774 . Thank you very much/
15:42:26 <monochrom> do you have a planned type for generalFold?
15:43:54 <monochrom> you should not need to use rootVal, isEmptyBST, lSub, rSub for this. you should simply use pattern matching. http://www.vex.net/~trebla/haskell/crossroad.xhtml
15:43:56 <rampant> :monochrom Yes. -- generalFold :: ( b -> c -> c ) -> ( a -> b ) -> c -> BST a -> c Something like this
15:44:20 <ski> looks like postorder traversal
15:44:36 <ski> also, the base case looks off
15:45:09 <rampant> :monochrom in the actual implementation the data declaration of BST is in a different file.
15:45:09 <ski> you forgot to copy over `lSub' and `rSub', but we can guess ..
15:45:38 <rui> ski, should I have got your client version out of your /ctcp rui version? I just saw that line on chat
15:45:53 <ski> rampant : as i mentioned earlier, it's IRC custom to start the message you direct to someone by their nickname (not by `:')
15:46:19 <rampant> :ski. Yes you are right. That was from me messing around. It should be isEmpty bst
15:46:35 <ski> rui : not unless you typed it yourself (mutatis mutandis)
15:46:52 <rampant> ski. Sorry
15:46:56 <monochrom> it does not matter which file lSub etc come from. I won't use it. and I have explained why.
15:46:57 <ski> no problem
15:47:03 <Hafydd> It's also an English language custom to not put a space before a colon.
15:47:19 <Hafydd> (And an IRC custom.)
15:47:27 <rampant> ski : Is this the correct way?
15:47:36 <ski> rampant : there are variations
15:47:46 <Hafydd> rampant: this is the correct way.
15:47:47 <ski> rampant : and monochrom is right. generally it is better to use pattern-matching
15:48:13 * ski nods to Hafydd
15:48:25 <jibi> hi, I wrote this to chain multiple times the bind monadic operator (and it works) http://lpaste.net/120797 but I was wondering if this was the correct way (or perhaps there's already something which does the same thing)
15:49:01 <init> rampant: you can use "nick," "nick ", "nick:", your IRC client should autocomplete nicks when you press tab, too, try something like "ramp<tab>"
15:49:14 <monochrom> I don't understand why there are 3 types a, b, c. one of them is unnecessary.
15:49:23 <rampant> ski : How can I pattern match though if the data declaration is in a different file?
15:49:46 <rampant> init : Thank you :)
15:50:02 <ski> rampant : if you export the data constructors, then you can use them in pattern-matching in a module that imports them
15:50:45 <Hafydd> Oh god.
15:51:00 * ski smiles quietly
15:51:22 <monochrom> who dictated the type of generalFold?
15:51:31 <rampant> ski : Cool Thank you.
15:51:36 * carlos_danger_69 smiles loudly
15:52:17 <rampant> monochrom : I did but I don't really know what I'm doing.
15:52:26 <monochrom> ok, I am not going to use it.
15:53:44 <monochrom> bstToList EmptyBST = ""
15:53:45 <monochrom> bstToList (Node lsub val rsub) = bstToList lsub ++ [val] ++ bstToList rsub
15:53:48 <monochrom> err
15:53:55 <ski> rampant : monochrom meant to say that if your `generalFold' didn't accept an `f' and a `g', just an `f', then you could always pass your `f . g' to it as its `f' argument, to get the same effect
15:54:11 <monochrom> bstToList EmptyBST = []
15:54:16 <monochrom> the other line is OK
15:54:40 <ski> (yes, that also work)
15:54:49 <monochrom> I no longer know what generalFold does. for one thing, it misses out the empty case.
15:55:16 <rampant> :monochrom. Ah yes. I already have a treeSort defined like that. But I would like to do it with a fold if possible. Does the ++ make it really inefficient?
15:55:33 <ski> monochrom : `generalFold f g z bst = foldr (f . g) z (bstToList bst)'
15:55:37 <michaelt> monochrom: it supplies z in the empty case.
15:55:43 <rampant> :ski Wow. Mind blow. That is badass!
15:55:57 * ski blinks
15:56:00 <ski> rampant : what is ?
15:56:09 <monochrom> michaelt, tell me what "isEmptyBST (rSub EmptyBST)" does
15:56:27 * ski was assuming that snippet was corrected
15:56:30 <rampant> ski : That you could just use f after g to achieve the same effect.
15:57:31 <ski> rampant : if one thinks about it, at looks at how `f' and `g' are used in your definition, it's more or less obvious. i suppose the trick is to think about it in the first case
15:57:36 <michaelt> monochrom: okay, I mentally deleted rSub and replaced it with a pattern match
15:57:52 <ski> (s/at looks/and looks/)
15:59:19 <rampant> : ski . You're right. They're right beside each other. I'll try to spot that in future ;)
15:59:19 <ski> rampant : also .. if you look at your suggested type for the function (specifically how `b' is used), that also suggests this refactoring
15:59:44 <lpaste> JamesJRH pasted “Fraction Finder” at http://lpaste.net/120798
15:59:53 <Fusebox> if I wanted to learn Erlang and Haskell, would I do okay focusing entirely on Haskell for a long time and then just porting the concepts to Erlang, or is Erlang sufficiently different it requires a huge time sink of its own?
16:00:16 <Hafydd> Fusebox: the latter.
16:00:25 <nisstyre> Finally got one buggy port of taffybar from gtk2 -> gt3 running
16:00:31 <Fusebox> okie
16:00:36 <nisstyre> now to make it not suck, and then transparency
16:00:47 <JamesJRH> 23:24:11 < ski> JamesJRH : perhaps it would be best if you made a paste ?  ← This is awful code but here it is: ↑
16:01:37 <ski> rampant : it's of course also important that `f' and `g' aren't used anywhere else, except to recursively pass down (to emphasize, you could define `generalFold f g = loop where loop z bst = ..(loop (loop z (lSub bst)) (rSub bst))..' ..)
16:02:33 <ski> (s/define/refactor into/)
16:03:50 <michaelt> no, I guess not
16:03:50 <tomberek> there are Free Functor, Free Monad, Operational, Free Applicative, etc... are there any Free Arrow packages?
16:03:54 * hackagebot hsverilog 0.1.0 - Synthesizable Verilog DSL supporting for multiple clock and reset  http://hackage.haskell.org/package/hsverilog-0.1.0 (junjihashimoto)
16:04:03 <tomberek> I found this, but not much more: http://stackoverflow.com/questions/12001350/useful-operations-on-free-arrows
16:04:06 <ski> JamesJRH : what's `find_base10_magnitude 1 1000' supposed to reduce to ?
16:05:31 <phaazon> hm
16:05:35 <JamesJRH> ski: 10000.
16:05:48 <phaazon> any idea how I could consume Event [a] as an input signal for a Wire?
16:06:00 <ski> JamesJRH : why ?
16:06:49 <rampant> ski : I looked at the suggested type and I got rid of one of the function arguments. Is treeSort bst =  if isEmptyBST bst then [] else treeSort (lSub bst)  ++ [rootVal bst]  ++ treeSort (rSub bst) slow because I'm using append?
16:06:50 <JamesJRH> Hmm, not sure. I might have made a false assumption.
16:08:03 <lpaste> monochrom pasted “binary tree fold” at http://lpaste.net/120800
16:08:11 <monochrom> rampant: http://lpaste.net/120800
16:08:49 <rampant> monochrom : Thank you very much. Taking a look now.
16:09:08 <michaelt_> I was going to suggest http://lpaste.net/1298663063653711872
16:09:52 <michaelt_> rampant: then fwiw bstToList = moreGeneralFold (\xs a ys -> xs ++ a : ys) []
16:10:11 <ski> rampant : not slow because you're using append. slow because you're using it left-associatively, repeatedly
16:11:05 <JamesJRH> ski: No I didn't. I remember now; The magitude must always be greater than the integer because the fraction must be less than 1 so that its decimal form starts with a ‘0.’.
16:12:48 <rampant> ski : Yes you have to traverse TreeSort(lsub) which is a pain. Is there a solution?
16:14:37 <ski> JamesJRH : and you always start the `magnitude' at `1' ?
16:15:23 <JamesJRH> Yeah, it's a pretty stupid implementation.
16:15:29 <ski> rampant : accumulators
16:15:50 <Dholli> How can I use foldr to write a polymorphic function that applies a function to a list of elements?
16:15:50 <Dholli> concatMap :: (a -> [b]) -> [a] -> [b]
16:15:50 <Dholli> concatMap function list = foldr...
16:16:25 <rampant> ski : Thanks for all your help. I will think about. Good night Everyone.
16:17:52 <ski> rampant : you pass in a list to place at the end
16:18:12 <ski> rampant : instead of `... -> [a]' you do `... -> [a] -> [a]'
16:18:28 <JamesJRH> ski: So I wrote that program and then I decided that I wanted to print a list of all iterations. The number of iterations should be about (numerator + denominator) of the resultant fraction.
16:18:41 <ski> rampant : and you add the elements of the right tree in front of that list, then the elements of the left tree in front of that
16:19:08 <ski> rampant : this can be written nicely as a composition chain with `.' .. this leads to "difference lists"
16:19:39 <michaelt_> rampant: something like enlist bst = generalFold (\a fs -> (a:) . fs) id bst []
16:20:02 <ski> JamesJRH : you want to see `numerator' and `denominator' in each step ?
16:20:55 <c_wraith> Dholli: start by finding the right types for the arguments to foldr
16:21:02 <JamesJRH> ski: So ‘fraction_finder 20150220’ runs about 778 + 3861 = 4639 iterations.
16:21:08 <michaelt_> rampant: woops need two ids in there enlist bst = generalFold (\a fs -> (a:) . fs) id id bst []
16:22:24 <JamesJRH> ski: Yes, or the whole tuple such that I can format it directly with ‘format_fraction’.
16:22:31 <mniip> Illegal polymorphic or qualified type: Traversal String String String String
16:22:34 <mniip> what's that mean
16:22:55 <michaelt_> Dholli: are you saying you want to write an equivalent of concatMap as a fold?
16:23:01 <c_wraith> mniip: Traversal is a type alias with a forall in it
16:23:05 <JamesJRH> I.e. to map ‘format_fraction’ over the iteration list.
16:23:17 <c_wraith> mniip: you might need to enable -XRankNTypes to pass one around in some cases
16:23:18 <dukerutledge> here is a curious question
16:23:28 <dukerutledge> how does ghc resolve a show on an ambiguous Num?
16:23:34 <rampant> michaelt_: Thank you
16:23:51 <c_wraith> dukerutledge: for certain classes, GHC picks default types.  Num defaults to Integer
16:24:06 <mniip> c_wraith, I don't see any difference between Lens and Traversal type's
16:24:10 <dukerutledge> and 1.0 would default to Float?
16:24:16 <mniip> type Traversal s t a b = Applicative f => (a -> f b) -> s -> f t
16:24:16 <mniip> type Lens s t a b = Functor f => (a -> f b) -> s -> f t
16:24:17 <JamesJRH> And I might then print that one per line or in 3 or 4 columns.
16:24:19 <c_wraith> dukerutledge: no, it defaults to Double
16:24:27 <mniip> why does one compile but another doesn't
16:24:46 <dukerutledge> That is very good to know! Thank you!
16:25:52 <lpaste> ski annotated “Fraction Finder” with “refactored,traced version,untested” at http://lpaste.net/120798#a120801
16:26:01 <ski> JamesJRH ^
16:27:10 <ski> JamesJRH : i took the liberty to change the interface of `format_fraction' slightly, to accomodate a corresponding change for `f'
16:28:55 <ski> JamesJRH : i think you may have some strangeness with integral and fractional types. i didn't touch it
16:29:10 <ski> (the types would tell)
16:33:55 * hackagebot language-c-quote 0.10.2 - C/CUDA/OpenCL/Objective-C quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.10.2 (GeoffreyMainland)
16:38:55 <michaelt_> Dholli: one specialization of foldr is foldr ::  (a -> [b] -> [b]) -> [b] -> [a] -> [b]; so as a clue you might start with something like
16:38:57 <michaelt_> foldWithEmptyListAsSeed :: (a -> [b] -> [b]) -> [a] -> [b]; foldWithEmptyListAsSeed op xs = foldr op [] xs
16:47:08 <monochrom> @src foldl
16:47:08 <lambdabot> foldl f z []     = z
16:47:08 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:47:31 <xpika> > fromDynamic ([toDyn  22]!!0)
16:47:33 <lambdabot>  Nothing
16:48:08 <monochrom> hmm, you need to add a type annotation, because IIRC if you don't, the type () is chosen for you, so it doesn't work out
16:48:25 <monochrom> > fromDynamic ([toDyn ()] !! 0)
16:48:27 <lambdabot>  Just ()
16:48:29 <monochrom> :)
16:48:45 <monochrom> > fromDynamic ([toDyn 20] !! 0) :: Maybe Integer
16:48:46 <lambdabot>  Just 20
16:50:32 <xpika> monochrom: thanks
16:51:20 <Rotaerk> :t toDyn
16:51:21 <lambdabot> Typeable a => a -> Dynamic
16:51:26 <monochrom> the famous hilarious example of choosing () for you is:
16:51:36 <monochrom> @check \xs -> xs == reverse xs
16:51:38 <lambdabot>  +++ OK, passed 100 tests.
16:51:47 <michaelt_> hah
16:51:55 <monochrom> it is because [(), (), ()] == reverse [(), (), ()]
16:52:24 <monochrom> things just can't get more boring than that :)
16:52:42 <michaelt_> @check \xs -> xs == (reverse xs :: String)
16:52:43 <lambdabot>  *** Failed! Falsifiable (after 5 tests and 3 shrinks):
16:52:43 <lambdabot>  "ab"
16:55:13 <JamesJRH> ski: What does ‘args@’ mean? I think you changed too much at once without testing. I can't see how the tuples work.
16:55:42 <Dholli> >concatMap :: (a -> [b]) -> [a] -> [b]
16:55:42 <Dholli> concatMap f ls = foldr f ls
16:55:52 <Hijiri> p@pattern means match pattern, but also name the original thing that was matched p
16:56:02 <Hijiri> for example the pattern thing@(a,b)
16:56:09 <Hijiri> a and b are matched to the contents of the tuple
16:56:15 <Hijiri> thing is bound to the entire tuple
16:56:39 <ski> JamesJRH : `args@(numerator,denominator)' both names the two parameters `numerator' and `denominator' individually, *and* gives the name `args' to the pair of them (collectively, if you want)
16:57:24 <ski> JamesJRH : so when i in the body write `args', i could just have written `(numerator,denominator)' instead -- this way it's slightly shorter and easier to grasp
16:57:48 <laserlions> hi when i do 'cabal configure --enable-coverage' then 'cabal test' i get an error 'cabal: dist/hpc/dyn/mix/stub-0.0.0.0: does not exist'
16:57:59 <ski> JamesJRH : i introduced `loop' to avoid having to carry around the parameters `target',`magnitude', despite them not changing in recursive calls
16:58:50 <ski> JamesJRH : for `find_base10_magnitude' i decided to hide the fact that we want `magnitide' initialized to `1'. that way, a user won't have to recall what to intitialize it to
16:59:34 <ski> JamesJRH : you had the expression `floor (numerator / denominator * fromIntegral magnitude)' repeated three times. i wanted to avoid the clutter, so i named it `barf'
16:59:36 <JamesJRH> ski: Indeed.
16:59:50 <xnil> does Maybe implement bind?
16:59:56 <ski> yes
16:59:59 <ski> @src Maybe (>>=)
17:00:00 <lambdabot> (Just x) >>= k = k x
17:00:00 <lambdabot> Nothing  >>= _ = Nothing
17:01:11 <JamesJRH> ski: These things make sense and I was going to ask about how to remove the clutter, but currently the args thing isn't working.
17:01:22 <ski> JamesJRH : instead of checking `foo == bar',`foo > bar',`foo < bar', it's shorter (and possibly more efficient) to compute  foo `compare` bar  once, and then match the result of that on `EQ',`GT',`LT'
17:01:30 <michaelt> Dholli: foldr takes three arguments, to put it crudely.  so dholliconcatmap f ls = foldr (... something with f ...) [] ls
17:01:34 <ski> JamesJRH : type error ?
17:02:28 <ski> JamesJRH : hm, just noticed a typo. the recursive calls in `f' should be to `loop', not to `f'
17:02:30 <JamesJRH> It's a mismatch of 2 versus 4 arguments.
17:02:38 <JamesJRH> Okay.
17:02:50 <ski> JamesJRH : and in `tracedF', recursive calls should also be to `loop'
17:02:53 <ski> mea culpa
17:02:58 <ski> sorry about that
17:03:26 <xnil> ski: how can you add a Maybe Int and an Int together? i figured it would have been (+) 3 =<< Just 5
17:03:48 <HeladoDeBrownie> you actually only need Applicative for that
17:03:54 <laserlions> hi im trying to use this stub project template (http://taylor.fausak.me/2014/03/04/haskeleton-a-haskell-project-skeleton/#continuous-integration) but the file dist/hpc/tix/hspec/hspec.tix is not generated for me
17:04:06 <xnil> *aherm* it's just an example, i'd prefer to use bind
17:04:20 <HeladoDeBrownie> @type \a mb -> (+) <$> pure a <*> b
17:04:21 <lambdabot>     Couldn't match expected type ‘f b’ with actual type ‘Expr’
17:04:22 <lambdabot>     Relevant bindings include a :: b (bound at <interactive>:1:2)
17:04:22 <lambdabot>     In the second argument of ‘(<*>)’, namely ‘b’
17:04:27 <HeladoDeBrownie> woops
17:04:29 <HeladoDeBrownie> @type \a mb -> (+) <$> pure a <*> mb
17:04:30 <lambdabot> (Applicative f, Num b) => b -> f b -> f b
17:04:56 <lpaste> ski revised “refactored,traced version,untested”: “refactored,traced version,untested” at http://lpaste.net/120801
17:05:27 <ski> > fmap (3 +) (Just 5)  -- xnil
17:05:29 <lambdabot>  Just 8
17:05:30 <michaelt> hi yminsky
17:05:36 <HeladoDeBrownie> XD
17:05:46 <HeladoDeBrownie> right, you only need Functor then!
17:05:49 <ski> > Just 5 >>= \n -> return (3 + n)
17:05:51 <lambdabot>  Just 8
17:05:56 <HeladoDeBrownie> but you can do fmap using bind if you like
17:05:59 <HeladoDeBrownie> aaand was beat to it
17:06:08 <ski> > return . (3 +) =<< Just 5
17:06:10 <lambdabot>  Just 8
17:06:11 <xnil> oh, ok. i see
17:06:20 <xnil> makes plenty of sense there
17:06:23 <Hafydd> > return (return ()) :: Maybe (Either ())
17:06:24 <lambdabot>  Expecting one more argument to ‘Data.Either.Either ()’
17:06:24 <lambdabot>  The first argument of ‘Data.Maybe.Maybe’ should have kind ‘*’,
17:06:24 <lambdabot>    but ‘Data.Either.Either ()’ has kind ‘* -> *’
17:06:28 <xnil> thanks ski, i just didn't think to use return
17:06:34 <HeladoDeBrownie> Hafydd, Either should be applied to two typpes
17:06:35 <HeladoDeBrownie> types*
17:06:48 <Hafydd> You're right. One might even say that you're...
17:06:50 <Hafydd> > return (return ()) :: Maybe (Either () ())
17:06:51 <lambdabot>  Just (Right ())
17:06:51 <laserlions> guys im not getting any tix files generated by cabal - what do?
17:06:57 <ski> JamesJRH : fwiw, updated the annotation
17:06:57 <HeladoDeBrownie> XD
17:07:00 <HeladoDeBrownie> well done Hafydd
17:07:07 <yminsky> hi michael
17:13:19 <xnil> :t return . (3 +) =<<
17:13:20 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
17:13:25 <xnil> :t (return . (3 +) =<<)
17:13:26 <lambdabot> (Num b, Monad m) => m b -> m b
17:13:48 <Profpatsch> I’m still confused about how to specify Text representations of Types.
17:14:08 <Dholli> how would I use that to write a polymorphic function?
17:14:56 <Profpatsch> e.g. how to say that a type Urgency Double should be converted to Text "19.78" when some function needs a text.
17:16:11 <bob_twinkles> Profpatsch: (pack . show) thingy
17:16:45 <ski> Dholli : it will automatically become polymorphic (if you let it), if it's general enough
17:17:16 <ski> Dholli : did you try starting from what michaelt_ suggested ?
17:17:38 <Profpatsch> bob_twinkles: Don’t use Show for that they said. It’s for debugging they said.
17:18:31 <bob_twinkles> Profpatsch: well, it depends on what you want to do
17:18:51 <bob_twinkles> if you do that you'll end up creating a temporary [Char] and then throwing it out which isn't super great for performance
17:19:14 <bob_twinkles> unless that gets stream fusion'd, but I don't think it does
17:19:18 <Hijiri> something like http://hackage.haskell.org/package/pretty-1.1.2.1/docs/Text-PrettyPrint.html ?
17:19:22 <ski> in general, `Show' shouldn't be used for a custom-formatted view of a value of a type
17:19:43 <Hijiri> oh, this doesn't give you Text
17:21:06 <Dholli> ski:  test :: (a -> [b]) -> [a] -> [b]
17:21:06 <Dholli> test f ls = foldr (... something with f ...) [] ls          this is what I've been playing around with without any luck
17:22:10 <ski> can you see what the type of `... something with f ...' should be ?
17:22:51 <Profpatsch> bob_twinkles: Maybe if I need it for lots and lots of classes define my own class TextRepr a where toText :: a -> Text
17:23:17 <Profpatsch> And until then just use printf or something.
17:24:00 <bob_twinkles> that is indeed likely the best solution, though you may want to look around in DAta.Text.Lazy.Builder to see if you could make that a bit more efficient
17:24:34 <bob_twinkles> since Text objects are fixed sized
17:24:57 <Dholli> xerox ls = concatMap (\e -> [e,e]) ls
17:24:57 <Dholli> xerox "okay"   should equal   "ookkaayy"
17:25:36 <ski> Dholli : another way you might start is to think about a typical application `concatMap f [a0,a1,a2,a3]' which ought to be equal to `concat (map f [a0,a1,a2,a3)', iow `concat [f a0,f a1,f a2,f a3]', iow `f a0 ++ f a1 ++ f a2 ++ f a3' -- the question is how to make this look more like the shape `cons a0 (cons a1 (cons a2 (cons a3 nil)))', where `cons' and `nil' can be anything you like (possibly using `f', but not using `a0',`a1',`a2',`a3')
17:27:15 <augur> is there a way to specify the type of a bind var?
17:27:30 <augur> this doesnt work:  do { (x :: Foo) <- ...
17:27:36 <ski> Dholli : if you succeed in finding such `cons' and `nil' expressions (possibly depending on / using `f'), such that it works for lists of any size, then you know `concatMap f as = foldr cons nil as' (where, as said, `cons' here is supposed to be an expression, that is allowed to use `f')
17:27:49 <ski> augur : i think that used to work with `PatternSignatures' ..
17:27:56 <ski> (even without the brackets, iirc)
17:28:03 <bob_twinkles> augur: x <- ... :: Foo
17:28:10 <augur> bob_twinkles: doesnt quite work!
17:28:15 <ski> bob_twinkles : you need to add in the monad
17:28:19 <augur> that would need to be m Foo
17:28:27 <bob_twinkles> oh, right
17:28:28 <augur> ski: ok ill look for pattern signatures
17:28:29 <bob_twinkles> derp
17:28:47 <ski> an alternative would be to replace one later use of `x' with `(x :: Foo)'
17:29:00 <ski> (but that's not that nice from a readability view)
17:29:37 <augur> ski: there's a complaint from 2009 that its been merged with ScopedTypeVariables
17:29:43 <augur> which is what GHC complains about
17:29:44 <ski> yes :(
17:29:46 <augur> maybe thats it then
17:30:17 <augur> not that i mind
17:30:22 <augur> i like scoped type variables
17:30:59 <Lokathor> is it typically best to install the 64bit ghc when possible?
17:31:57 <monochrom> that is a very relative question
17:32:32 <monochrom> if low on physical memory, you may like to go back to 32-bit pointers, which means 32-bit GHC
17:32:55 <mniip> is there a way to somehow bundle optics with IO?
17:33:06 <monochrom> unless you have already chosen x86-64 linux, in which case you are forced to 64-bit GHC again
17:33:08 <mniip> something like a prism where getter and setter are both IO actions
17:33:51 <Lokathor> i'm using 64bit windows 7, with currently 4gb of ram but soon to be 12gb
17:34:11 <monochrom> 4GB is enough RAM for 64-bit GHC
17:34:25 <Lokathor> alright cool
17:34:27 <ab9rf> at 4gb you want a 64 bit OS, generaly
17:34:32 <ab9rf> anything more than that pretty much mandates it
17:35:04 <ab9rf> i swtiched to the 64 bit GHC with the last platform update on windows and it's been slightly more performant, although it's difficult to measure
17:36:01 <Lokathor> even when using a 64 bit OS, some programs only have 32bit versions, and so to interoperate with them you want other things to be 32bit as well, and so on
17:36:16 <ab9rf> Lokathor: onlt if you needt o use their libraries
17:36:25 <ab9rf> 64bit and 32bit code can interact via IPC
17:36:55 <Lokathor> the main time i've run into this was when i had 64bit java installed, and my browser couldn't access it because the browser itself was 32bit
17:37:10 <ab9rf> Lokathor: that's because java runs in the browser process
17:38:52 <Cale> mniip: You can use (a -> IO b) -> (s -> IO t) functions directly, but they're not lenses or prisms or anything, because they're insufficiently general
17:39:57 <Cale> mniip: Oh, I suppose you can use prisms with p = Kleisli m
17:41:20 <Cale> Well, that's similarly insufficiently general of course
17:41:36 <mniip> I need something that will compose with a traversal though
17:41:37 <Cale> But maybe something like that is closer to what you mean regardless
17:41:46 <mniip> on one side
17:42:56 <Cale> Well, if  t :: Applicative f => (a -> f b) -> (s -> f t)
17:43:26 <mniip> :k Lens
17:43:27 <lambdabot> * -> * -> * -> * -> *
17:43:30 <mniip> o
17:43:53 <JamesJRH> ski: I have it working now. (I don't see your update though.) Anyway, back to my original concern, why should f and tracedF have so much duplicate?
17:43:56 <Cale> then t will compose on either side with functions of the type I mentioned before, provided the a and b or s and t are right.
17:44:14 <JamesJRH> Anyway, it's late, I'm out of battery, and I must go to bed.
17:44:26 <Cale> It's just you won't be able to use the result as a Traversal, because it's not polymorphic enough
17:44:33 <JamesJRH> Thank you. Good night!
17:44:52 <mniip> :t let z = z `const` (z . (undefined :: Traversal s t a b)) in z
17:44:53 <lambdabot> Applicative f => (s -> f t) -> c
17:47:10 <orzo> i got my IKEv2 serialization through a quickcheck serialize/parse test, and then tried it on actual packets produced by strongswan.  It parsed it all with no trouble.  I'm astonished I didn't goof up somewhere in adhering to the RFC.
17:48:57 <benzrf> @let isWhatIWantNot = const
17:48:59 <lambdabot>  Defined.
17:49:03 <benzrf> > "foo" `isWhatIWantNot` 4
17:49:04 <lambdabot>  "foo"
17:49:49 <mniip> @let whilstConsideringTheseTypeInferences = const
17:49:50 <lambdabot>  Defined.
17:50:05 <mniip> :t let z = z `whilstConsideringTheseTypeInferences` z 0 in z
17:50:06 <lambdabot> Num a => a -> b
17:51:28 <xnil> @let (jellyBeans) = const
17:51:29 <lambdabot>  Defined.
17:51:43 <xnil> :t let z = z jellyBeans z 0 in z
17:51:44 <lambdabot>     Occurs check: cannot construct the infinite type:
17:51:44 <lambdabot>       t3 ~ (a2 -> b1 -> a2) -> t2 -> a3 -> t3
17:51:44 <lambdabot>     Relevant bindings include
17:51:46 <xnil> uh, ok.
17:51:49 <ski> JamesJRH : you should see the update if you reload the page. i just corrected the recursive calls, and added the obvious `traced_fraction_finder'
17:53:38 <mniip> Cale, view (undefined . sometraversal) :: (Monoid a, MonadReader s m) => m a
17:53:50 <mniip> () is a Monoid
17:53:58 <mniip> MonadReader s IO tho...
17:54:42 <ski> JamesJRH : if this is just for debugging, then the duplication (or modification) possibly doesn't matter that much. otherwise, one could do something similar to my `PoorManDebug' (but possibly slightly simpler(?), since you only have linear recursion) to avoid the code duplication -- the code will become slightly less scrutable, though
17:55:00 <ski> JamesJRH : perhaps there's some other solution i'm overlooking
17:58:43 <solatis> @hoogle MonadMask a -> a
17:58:45 <lambdabot> Warning: Unknown type MonadMask
17:58:46 <lambdabot> Prelude id :: a -> a
17:58:46 <lambdabot> Data.Function id :: a -> a
17:59:05 <PushNPull> anyone in here?
17:59:16 <solatis> @hoogle CatchT a -> a
17:59:16 <lambdabot> Warning: Unknown type CatchT
17:59:16 <lambdabot> Prelude id :: a -> a
17:59:16 <lambdabot> Data.Function id :: a -> a
17:59:19 <PushNPull> join hhvm
18:00:21 <PushNPull> i need irc client with syntax highlighting
18:02:40 <ski> PushNPull : dunno about that
18:05:20 <erisco> was the LLVM backend lost in 2010?
18:08:17 <xnil> :k Functor
18:08:18 <lambdabot> (* -> *) -> Constraint
18:11:23 <xnil> :t fmap
18:11:24 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:11:54 <apokatastasis> what an excellent first line to see
18:12:03 <xnil> > fmap (+) (Just 2) (Just 3)
18:12:05 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe a1 -> t’
18:12:05 <lambdabot>              with actual type ‘Data.Maybe.Maybe (a0 -> a0)’
18:12:21 <xnil> :^)
18:12:24 <apokatastasis> ...that not so much
18:12:33 <xnil> lol'd
18:13:00 <xnil> > fmap (3 +) $ Just 2
18:13:01 <lambdabot>  Just 5
18:13:13 <xnil> > fmap (3 +) $ Nothing
18:13:14 <lambdabot>  Nothing
18:13:17 <xnil> oh, cool.
18:13:41 <mniip> > (+) <$> (Just 2) <*> (Just 3)
18:13:42 <lambdabot>  Just 5
18:14:00 * hackagebot cabal-test-quickcheck 0.1.4 - QuickCheck for Cabal  http://hackage.haskell.org/package/cabal-test-quickcheck-0.1.4 (TimothyJones)
18:15:49 <xnil> mniip: what should i look up to see how that works
18:16:06 <xnil> specifically the <>
18:16:08 <apokatastasis> the haskell package on debian tries to pull in a bunch of X stuff :(
18:16:35 <mniip> xnil, <$> is infix fmap
18:16:46 <mniip> for <*> see instance Applicative Maybe
18:16:52 <xnil> oh, neat
18:17:51 <mniip> <*> is like <$> except the function is wrapped too
18:18:03 <mniip> so 'Maybe (a -> b) -> (Maybe a -> Maybe b)'
18:19:16 <rola> @check (liftA2 (==) (liftA (+1)) (fmap (+1)) :: Maybe Integer -> Bool)
18:19:18 <lambdabot>  +++ OK, passed 100 tests.
18:19:49 <apokatastasis> hm, is anyone here aware of the differences between haskell-platform and ghc packages? it seems that the latter is just a compiler. does it create standalone binaries or do they have to be run through an interpreter?
18:20:32 <orzo> apokatastasis: stand alone
18:20:37 <xnil> is it ok to return a Maybe String from a function where you will never have a Nothing
18:20:47 <ski> rola : `liftA = fmap' is a law (or a consequence of laws) of `Applicative'
18:21:00 <xnil> or is this bad practice
18:21:08 <ski> xnil : yes, but what's the point ?
18:21:22 <ski> if you need to conform to an interface that expects a `Maybe', then it's fine
18:21:25 <xnil> ski: well, i have a Maybe String being returned from a function i call
18:21:38 <xnil> if it is Nothing then i want to return a certain thing that's not Nothing
18:21:48 <xnil> (being a Just String or just a String if i can)
18:21:53 <orzo> apokatastasis: the haskell-platform is just the compiler and a bunch of other usefull things, like the cabal packaging system, bundled together, in practice it's primarily important for windows users to get started
18:21:55 <mniip> :t orElse
18:21:56 <lambdabot> Not in scope: ‘orElse’
18:22:20 <mniip> :t fromMaybe
18:22:21 <lambdabot> a -> Maybe a -> a
18:22:25 <mniip> xnil, ^
18:22:39 <xnil> woah, you can do that?
18:22:49 <mniip> um
18:22:51 <xnil> i thought you couldn't return the wrapped value from a maybe
18:22:54 <mniip> of course you can just write
18:22:59 <xnil> or from a monad in general
18:23:08 <mniip> case m of Just x -> x; Nothing -> y
18:23:25 <mniip> no what would make you think that
18:23:34 <xnil> the fact that you can't with IO
18:23:47 <mniip> correct, you cannot unwrap an IO action
18:23:51 <mniip> that has nothing to do with monads
18:23:59 <xnil> what is it that prevents unwrapping that
18:24:00 * hackagebot openssh-github-keys 0.1.0.0 - Fetch OpenSSH keys from a Github team  http://hackage.haskell.org/package/openssh-github-keys-0.1.0.0 (jsl)
18:24:07 <mniip> xnil, the way IO works?
18:24:26 * xnil needs to read up on how IO works
18:25:08 <mniip> xnil, how do you unpack 'getLine'
18:25:57 <mniip> remember that all functions produce the same result when given the same argument
18:26:00 <mniip> s
18:26:19 <xnil> oh.
18:26:34 <xnil> ok. that makes a lot more sense.
18:26:53 <xnil> thanks
18:27:37 <xnil> :t fromMaybe
18:27:38 <lambdabot> a -> Maybe a -> a
18:28:54 <mniip> xnil, Monad is just a generalization, a common 'api' if you must. If you can't do something with a monad doesn't mean you can't do it with any of the types that are monads
18:29:10 * hackagebot HsOpenSSL-x509-system 0.1.0.1 - Use the system's native CA certificate store with HsOpenSSL  http://hackage.haskell.org/package/HsOpenSSL-x509-system-0.1.0.1 (MariosTitas)
18:29:14 <Zemyla> Is there a way to get a regular [] list to have unpacked values in it, or do I have to write my own list function?
18:29:18 <xnil> mniip: yeah, of course
18:29:27 <xnil> i just didn't really think that through
18:30:14 <xnil> thanks
18:30:16 <mniip> Zemyla, 'unpacked values'?
18:30:39 <Zemyla> Or even just be strict in the value.
18:30:58 <mniip> what do you mean by unpacked values
18:31:06 <Zemyla> But yeah, unpacked values, like with the pragma {-# UNPACK #-}.
18:31:39 <mniip> ah
18:34:02 <xnil> that suggestion got everything working. thanks a ton mniip
18:37:34 <Profpatsch> Huh, I wonder why this isn’t possible:
18:37:36 <Profpatsch>   let may :: TextRepr t => (Task -> Maybe t) -> Task -> t
18:37:38 <Profpatsch>       may (x -> m) = \x -> fromMaybe "" m
18:38:17 <Profpatsch> It says “not in scope: x” on the first use of x.
18:40:23 <Profpatsch> Oh, -> is the Type.
18:47:37 <ski> Profpatsch : type ?
18:47:51 <ski> it looks like you tried to use view patterns. perhaps you didn't mean to
18:49:11 * hackagebot http-media 0.5.1 - Processing HTTP Content-Type and Accept headers  http://hackage.haskell.org/package/http-media-0.5.1 (TimothyJones)
18:51:31 <ski> @type let mayn't :: (String -> Maybe String) -> (String -> String); mayn't (($ xx) -> m) xx = fromMaybe "" m in mayn't  -- too bad :(
18:51:32 <lambdabot>     Not in scope: ‘xx’
18:51:32 <lambdabot>     Perhaps you meant one of these:
18:51:32 <lambdabot>       ‘x’ (imported from Debug.SimpleReflect),
18:54:11 * hackagebot GGg 0.1.0.0 - GGg cipher  http://hackage.haskell.org/package/GGg-0.1.0.0 (xnil)
18:56:23 <xnil> how long does cabal update generally take nowadays for you guys?
18:56:25 <KaneTW> Profpatsch: i don't understand what you're trying to do
18:56:34 <Hijiri> xnil: Does that compile for you?
18:56:36 <KaneTW> xnil: 30s?
18:56:45 <KaneTW> not very long
18:56:57 <Hijiri> xnil: I think you forgot to include something
18:57:03 <xnil> Hijiri: does what compile for me?
18:57:06 <Hijiri> GGg
18:57:09 <xnil> yes
18:57:11 <xnil> it does
18:57:19 <Hijiri> I'm missing Conversions
18:57:23 <KaneTW> cabal update  3.56s user 0.68s system 41% cpu 10.171 total
18:57:24 <xnil> it's uh
18:57:39 <xnil> hrm let me take a look at my GGg.cabal
19:00:13 <xnil> Hijiri: would i just stick Conversions in --other-modules:
19:00:23 <xnil> -- other-modules:*
19:00:30 <xnil> since it's a top-level module
19:00:37 <xnil> not sure of the syntax there
19:00:43 <Hijiri> is it in src/Conversion.hs?
19:00:50 <Hijiri> Conversions.hs
19:00:51 <xnil> yes
19:01:09 <Hijiri> I don't know, I thought cabal would automatically pick it up since it's imported by Main
19:01:12 <xnil> hrm
19:03:34 <Hijiri> actually maybe it's supposed to include everything in src
19:05:12 <xnil> my internet is crap right now
19:07:20 <xnil> ah, Hijiri http://stackoverflow.com/questions/4639526/why-does-cabal-sdist-not-include-all-files-needed-to-build
19:08:06 <Hijiri> oh, didn't know
19:08:47 <monochrom> cabal sdist doesn't want to ask ghc "which files are involved?". probably for simplicity
19:09:12 * hackagebot GGg 0.1.0.1 - GGg cipher  http://hackage.haskell.org/package/GGg-0.1.0.1 (xnil)
19:09:18 <monochrom> instead, in the case of *.hs files, you have to list them under main-is or exposed-modules or other-modules to get included
19:09:28 <xnil> now it works! neat-o.
19:10:00 <xnil> well, as far as I know.
19:22:59 <kranius> Hello, how can I do dynamic loading of a module ?
19:23:53 <kadoban> kranius: "dynamic" as-in, at run time? I…don't think that even makes sense in haskell, does it?
19:24:15 <siodfnb> hey is there a nice 'stub' cabal project I can use as a template that includes all the haddoc, testing, linting, hpc stuff?
19:24:36 <siodfnb> i tried haskeleton but that doesnt work properly... maybe it relies on older cabal or something
19:24:45 <tomberek> siodfnb - i've used holy-prject
19:24:46 <tomberek> holy-project
19:24:59 <monochrom> funny name :)
19:25:05 <kranius> kadoban: well you can do it in ghci ;)
19:25:20 <kranius> kadoban: how can I use this api in my programs ?
19:25:43 <kadoban> Hmm…dunno
19:26:56 <siodfnb> holy-project doesnt seem to include stuff like test and documentation coverage and linting..
19:32:06 <tomberek> siodfnb: let me know what else you can find
19:33:23 <siodfnb> tomberek: ive decided i will just use the stuff i have working so far which i managed to make myself from various sources and then try to build something more complete like haskeleton when i know more about cabal and stuff
19:34:12 <siodfnb> I have hspec tests, haddoc, hpc, hlint working - the coverage is the only thing im missing now
19:39:47 <ttt_fff> what's a good guide on uncode chars in ahskell var names?
19:40:10 <monochrom> there are two good guides.
19:40:21 <monochrom> one says "use it". the other says "don't use it"
19:41:07 <KaneTW> don't use it because they're a bitch to type without editor support
19:41:16 <ttt_fff> monochrom: tell me about the two voting guides for this upcoming election
19:41:22 <kadoban> Mostly probably not a good idea it seems like. Code that's difficult to maintain for not-very-good reasons isn't fun. Yeah, if you can't even type the variable names…ugh.
19:41:27 <ttt_fff> monochrom: and the two views on P vs NP
19:41:42 <monochrom> one says "vote", the other says "don't vote"
19:42:18 <ttt_fff> monochrom: tell me about the two types of languages in the world
19:42:23 <ttt_fff> monochrom: and the two types of people on #haskell
19:42:48 <mniip> there's only one type of people in haskell
19:42:52 <monochrom> one type of people in #haskell have odd-length nicks. the other have even-length nicks.
19:43:01 <mniip> all people are of the type Human
19:43:07 <KaneTW> wrong
19:43:14 <KaneTW> we have at least one Dog in here
19:43:46 <mniip> a Dog is not a people though
19:43:52 <Hijiri> is there a makeFolds like makeLenses, except I don't want to expose them as a Lens
19:44:08 <monochrom> oh, mniip is going for a tautology! :)
19:44:10 <KaneTW> that's racist
19:44:16 <Hijiri> I could just do myFold = myLens I guess
19:44:47 <KaneTW> actually that's speciesist
19:45:02 <monochrom> I share with you mine: http://www.vex.net/~trebla/humour/tautologies.html
19:45:04 <PushNPull> there should be more cats in here
19:46:24 <edwardk> Hijiri: you can use custom LensRules with makeLensesWith and disable "generateUpdateableOptics" on them
19:46:27 <PushNPull> spott:is a dog
19:47:04 <spott> huh?
19:47:31 <PushNPull> a friend of mine had a dog named spot
19:47:42 <edwardk> Hijiri: makeGetters = makeLensesWith (lensRules & generateUpdateableOptics .~ False)
19:47:47 <spott> ah.... well, you aren't the first to use that joke :)
19:47:54 <edwardk> Hijiri: that will build getters instead of lenses, folds instead of traversals
19:48:19 <edwardk> Hijiri: and you can modify other fooRules to do field-style lenses, etc.
19:49:25 <mniip> ohhhh I know
19:49:37 <mniip> the ~ before your ident means you're too lazy to set up identd xD
19:54:14 * hackagebot colors 0.3.0.1 - A type for colors  http://hackage.haskell.org/package/colors-0.3.0.1 (FumiakiKinoshita)
19:59:14 * hackagebot objective 1 - Extensible objects  http://hackage.haskell.org/package/objective-1 (FumiakiKinoshita)
20:07:29 <mniip> oh dear
20:07:37 <mniip> http://hackage.haskell.org/package/lua-bytecode
20:07:39 <gcganley> mniip: whats wrong :(
20:07:49 <mniip> it should say "Lua" and not "LUA", and the category should be renamed too
20:08:03 <gcganley> mniip: talk to the maintainer
20:09:12 <monochrom> I wonder if you're right, but I get a related problem all the time when I obtain music CD track names from the internet.
20:09:55 * mniip # lazy where (#) = flip ($)
20:10:03 <monochrom> people who upload those track names seem to be obsessed with auto-capitalizing every word blindly. so for example "Ludwig von Beethoven" because "Ludwig Von Beethoven"
20:10:16 <monochrom> s/because/becomes/
20:10:22 <mniip> monochrom, lua is not an acronym though
20:10:57 <mniip> lua is 'moon' in portuguese
20:11:06 <monochrom> "Allegro Ma Non Troppo" really annoys me
20:11:31 <mniip> source: I have created a programming language named LUA to mock people who type lua like that
20:12:19 <monochrom> is your mocking plan successful? :)
20:12:52 <mniip> some people were entertained :)
20:13:36 <mniip> https://github.com/mniip/LUA if you ever get bored
20:15:55 <mulchy> There was a cool article on planet clojure about a guy reviewing books and classes to learn haskell, but I can't remember what it's called. Does anyone here have any ideas?
20:16:51 <monochrom> is it http://bitemyapp.com/posts/2014-12-31-functional-education.html ?
20:17:38 <monochrom> but I didn't obtain it from planet clojure. I obtained it right from #haskell-beginners topic
20:19:15 * hackagebot GGg 0.1.0.2 - GGg cipher  http://hackage.haskell.org/package/GGg-0.1.0.2 (xnil)
20:20:46 <mulchy> @monochrom yes! that's it
20:20:46 <lambdabot> Unknown command, try @list
20:20:51 <mulchy> thanks!
20:20:53 <mniip> I should submit my json lenses to hackage once they're done
20:24:47 <mniip> I don't think anyone can do this yet
20:24:50 <mniip>  > preview (listIndex 1 . jsonNumber) ("[{}, 123," ++ undefined)
20:24:51 <mniip> Just 123.0
20:27:27 <dmwit> GGg is not a very secure cipher.
20:29:04 <mniip> morse code
20:29:26 <mniip> also yeah, not a cipher, there's no key
20:29:29 <mniip> it's an encoding if anything
20:31:00 <dmwit> I don't see anything about requiring keys on the Wikipedia page for ciphers.
20:31:17 <dmwit> However, I do see a claim that most ciphers output about as much stuff as they input, which GGg seems not to.
20:31:54 <xnil____3> dmwit: hmm?
20:32:07 <dmwit> xnil____3: I am just enjoying your package.
20:32:14 <xnil____3> oh, GGg is not a secure cipher
20:32:19 <xnil____3> i'm afraid you're right
20:33:20 <xnil____3> g-GG GgGG, gGGg gG GgGg GgG gG GGg g, GggGg gg ggg GggGg, GGgG ggG gg G g, g Gg gGGG GGG GgGG gG Gggg gGgg g g'gG
20:35:39 * HeladoDeBrownie tries pronouncing that, sounds as if choking
20:36:20 <Rotaerk> lol
20:41:15 <mniip> [07:34:35] * HeladoDeBrownie tries pronouncing that, sounds as if choking
20:41:34 <mniip> all I can hear is some 12 yo saying 'gg gg gg gg gg gg' in cs
20:41:56 <HeladoDeBrownie> in triplet time?
20:42:10 <xnil____3> is there a way to decorate my bed with Cascading Style Sheets?
20:42:46 <HeladoDeBrownie> xnil____3, just use lots of bedsheets with nice patterns i guess???
20:44:37 <benzrf> can template haskell generate data decls
20:47:30 <xnil____3> but how can i do it in a monad?
20:48:03 <HeladoDeBrownie> xnil____3, well first you'll need a flour tortilla
20:49:16 * hackagebot postgrest 0.2.6.0 - REST API for any Postgres database  http://hackage.haskell.org/package/postgrest-0.2.6.0 (begriffs)
20:50:08 <mniip> seriously OOM?
20:50:28 <mniip> killing chrome with 5% ram usage when there there's upowerd with likr 90%?
20:56:21 <Azel> How can upowerd get to ~90% RAM usage in the first place? Isn't it supposed to be a power-saving daemon?
20:58:20 <levi> Apparently the OOM killer divides the badness points of superuser processes by 4, and also divides by 4 if the process has an effective capability for raw IO access.
21:00:33 <mniip> Azel, it's a bug I think
21:00:51 <mniip> it starts allocating sometimes
21:00:56 <mniip> have to kill and restart it
21:01:18 <mniip> I think it might be somehow related to unability to hibernate but whatever
21:19:41 <mniip> is a where-binding lazy?
21:19:56 <mniip> where (a, b) = ...
21:20:03 <mniip> err
21:20:16 <mniip> yeah
21:20:19 <mniip> that
21:20:28 <pavonia> It is
21:28:03 <lpaste> mniip pasted “spaghetti code” at http://lpaste.net/120810
21:28:16 <mniip> any tips on how should I rewrite this to be less spaghetti
21:29:18 * hackagebot radix 1.0.0.0 - Command-line tool for emitting numbers in various bases.  http://hackage.haskell.org/package/radix-1.0.0.0 (ThomasEding)
21:31:00 <platz> hrm, it seems if I cabal install a package inside a sandbox, i can't cabal sandbox add-source that sandbox from a different sandbox
21:32:19 <platz> using 'cabal sandbox init --sandbox /path/to/sandbox' works though, but this is slightly different as it shares the same sandbox
21:32:43 <platz> instead of simply 'add-source'ing it
21:35:24 <pavonia> > map (\c -> fromMaybe c $ lookup c $ zip "bfnrt" "\b\f\n\r\t") "abcdefg"
21:35:25 <lambdabot>  "a\bcde\fg"
21:35:45 <pavonia> mniip: You could use something like this instead ^
21:37:13 <mniip> while that looks nice, I'll probably keep spaghetti for... performance purposes, yeah
21:37:35 * mniip peeks at aeson source
21:46:43 <glguy> If anyone else wants to practice using a slide rule you can use the one I made tonight (gloss) ^_^ https://gist.github.com/anonymous/41e26af4425550b90176 http://imgur.com/YMp2b8y
21:48:49 <mniip> the hell is that
21:49:28 <glguy> It's the back side of this: http://www.concise.co.jp/en/products/detail.php?product_id=8
21:50:39 <glguy> You can drag the "cursor" with the left mouse button (gray thing with red line) or the middle wheel with the right mouse button
21:50:40 <mniip> I have no idea what that is
21:51:14 <glguy> It can do various operations on their inverses, multiplication, squares, cubes, logs
21:51:18 <glguy> operations and their*
21:52:11 <carlos_danger_69> takes me back to a simplier time
21:52:22 <carlos_danger_69> when my calculator couldn't spy on my family
21:52:29 <mniip> I suppose it's a smooth function evaluator of some sort
21:52:32 <glguy> The front side can do sin, cos, tan, and exponentiation
21:52:46 <glguy> It's like a calculator but older :)
21:54:13 <mniip> :/ it doesn't fit on my screen
21:54:32 <glguy> well... you can shrink the slideRadius value I suppose
21:54:57 <glguy> try 300
21:55:24 <mniip> what's the radius measured in?
21:55:30 <glguy> pixels
21:55:40 <mniip> doesn't seem soo
21:56:05 <glguy> Then I don't know
21:56:05 <xnil____4> radius m8
21:56:13 <xnil____4> not diameter
21:56:15 <mniip> also it still doesn't fit
21:56:20 <glguy> it seems to map to pixels on my computer
21:56:42 <glguy> what size screen are you trying to fit it into?
21:56:48 <mniip> 1376x768
21:57:06 <mniip> 300 totally doesn't fit
21:57:09 <glguy> If you make it smaller than 300 you'll probably have to shrink the numbers in the middle
21:57:13 <mniip> 250 messes up the inner circles
21:57:26 <glguy> I'm writing this on a 27" monitor...
21:58:05 <glguy> if 250 works for you I can make a version with smaller text in the middle
21:58:21 <mniip> > 40 / 2.54
21:58:23 <lambdabot>  15.748031496062993
21:58:28 <mniip> 15" here
21:58:43 <glguy> mac? win? lin?
21:58:52 <glguy> errr, rather retina?
21:58:52 <mniip> linux
21:58:55 <mniip> lol
21:58:56 <mniip> no
21:59:16 <glguy> OK, I have a 15" to try on
22:00:11 <mniip> 11px is fine :)
22:00:30 <mniip> hell my irc is a 9pt font
22:02:43 <mniip> > magnitude (1366 :+ 768) / 15.74
22:02:44 <lambdabot>  99.56117216224457
22:02:51 <mniip> 100 dpi woo
22:02:58 <lpaste> glguy pasted “smaller circ.hs” at http://lpaste.net/120814
22:03:05 <glguy> maybe try that?
22:04:43 <mniip> ok now how do I use this
22:05:28 <glguy> one thing you can do is multiplication
22:05:50 <glguy> say you wanted to multiply 2.4 * 3.5
22:06:03 <glguy> put the inner '1' on the outer 2.4
22:06:45 <glguy> (focus on the ring of numbers touching the black line
22:06:50 <glguy> that's D and C
22:07:07 <glguy> then you move your cursor to 3.5 on the inner 'C' scale
22:07:34 <glguy> and you'll see that it overlaps the outer scale at ~8.15
22:07:39 <mniip> what
22:07:40 <glguy> > 2.4*3.5
22:07:42 <lambdabot>  8.4
22:07:53 <glguy> so maybe I lined mine up wrong ^_^
22:07:55 <glguy> still learning!
22:08:42 <glguy> I'll take a screenshot of that
22:09:12 <glguy> http://imgur.com/DNQbuTd  2.4 * 3.5
22:10:00 <glguy> the "1" is the starting point, I've lined the "1" of the scale just inside the black circle up with "2.4" on the next scale out
22:10:05 <EvanR> you need to be able to rotate the inner disc
22:10:18 <EvanR> do you guy a program that does ths
22:10:22 <EvanR> do you have
22:10:31 <glguy> Yeah, that's what I'm taking screenshots of
22:10:38 <mniip> ahhhhhh
22:10:43 <EvanR> nice
22:10:43 <mniip> you rotate the inner thing with RMB
22:10:48 <glguy>  http://lpaste.net/120814 for small monitors   https://gist.github.com/anonymous/41e26af4425550b90176  for big
22:11:03 <acetoline> has anyone done any work on randomly generating type-correct haskell expressions?
22:11:05 <glguy> mniip: Yeah, sorry, I thought I mentioned that already. oops
22:11:18 <mniip> so it's just a logarithmic ruler
22:11:20 <mniip> but circular
22:11:25 <glguy> mniip: yes
22:11:27 <acetoline> (possibly through some kind of type-aware stochastic grammar)
22:11:31 <EvanR> a logarithmic ruler ;)
22:11:48 <EvanR> you know they put man on moon with those!
22:11:49 <mniip> a logarithmic ruler, that I know
22:12:04 <mniip> never met disc-shaped thingmabobs though
22:12:36 <acetoline> I mean it's trivial to do this if you restrict your types to just, say, Int, but I'm interested in something that at least supports Chars and Lists and custom algebraic types made of those
22:12:43 <glguy> The disk ones are neat since they overflow nicely
22:13:14 <mniip> ah I see
22:13:23 <mniip> one full circle is a 10
22:14:35 <levi> acetoline: Well, not for arbitrary Haskell expressions, but quickcheck and friends are based on the notion of forming random correctly-formed expressions of various types.
22:15:00 <acetoline> really
22:15:03 <mniip> levi, values of various types rather
22:15:24 <thebnq> maybe apply it to ghc's types :D
22:15:26 <mniip> I don't think acetoline is talking about values here
22:15:45 <Cale> Yeah, it's a little weird to say that quickcheck is generating expressions, though I guess in some sense it is.
22:15:56 <mniip> thebnq, not all possible values of HsExpr are valid
22:15:56 <acetoline> I'm talking about generating type-correct expressions that can be fully evaluated
22:16:37 <acetoline> so what does typecheck do under the hood?
22:16:49 <mniip> typecheck?
22:16:53 <mniip> you mean quickcheck?
22:16:54 <acetoline> er
22:16:56 <acetoline> quickcheck
22:17:00 <acetoline> :)
22:17:13 <mniip> quickcheck has a series of random generators for various types
22:18:25 <mniip> @check \x y -> x + y == y + x
22:18:26 <lambdabot>  +++ OK, passed 100 tests.
22:19:24 <acetoline> mniip: can it generate, say, values of a function type?
22:19:38 <Cale> @check \f g xs -> map (f . g) xs == map (f :: Int -> Int) (map (g :: Int -> Int) xs)
22:19:39 <lambdabot>  +++ OK, passed 100 tests.
22:19:43 <Cale> yes
22:20:17 <mniip> @check \f g x -> f x == g x
22:20:19 <lambdabot>  +++ OK, passed 100 tests.
22:20:27 <Cale> lol, defaulting :D
22:20:31 <mniip> ahh
22:20:35 <mniip> @check \f g x -> f x == g x :: Int
22:20:37 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
22:20:37 <lambdabot>  with actual type ‘GHC.Types.Bool’
22:20:40 <mniip> oop
22:20:44 <Cale> moar parens
22:20:45 <mniip> @check \f g x -> f x == (g x :: Int)
22:20:46 <lambdabot>  *** Failed! Falsifiable (after 2 tests):
22:20:47 <lambdabot>  <() -> Int> <() -> Int> ()
22:20:53 <mniip> that's informative
22:21:06 <Cale> Usually the Show instance it gives you is better
22:21:17 <Cale> But lambdabot is using a different one
22:21:24 <Cale> actually...
22:22:01 <xnil____4> is there a block syntax in haskell that does something sorta like turn `doseq a; b; c' into `seq a $ seq b $ seq c'?
22:22:05 <xnil____4> err
22:22:14 <xnil____4> `seq a $ seq b c'
22:22:17 <acetoline> cool, is there any page I can learn how quickcheck does this?
22:22:27 <mniip> xnil____4, foldr seq [a, b, c]
22:22:29 <acetoline> googling mostly gives me just tutorials on how to use it
22:22:30 <Cale> @check \(Fun _ f) (Fun _ g) x -> f x == (g x :: Int)
22:22:31 <lambdabot>  Not in scope: data constructor ‘Fun’Not in scope: data constructor ‘Fun’
22:22:35 <xnil____4> hrm, ok then
22:22:37 <Cale> ah, not imported
22:22:51 <xnil____4> mniip: just wondered if there was a special syntax for doing it neatly
22:22:54 <Cale> that would show something better as well
22:22:54 <mniip> no
22:23:11 <mniip> I should work on json lenses .-.
22:23:22 <acetoline> is the algorithm based on some kind of grammar?
22:23:23 <Cale> acetoline: Sure, let me dig up the paper
22:23:35 <Cale> nope, just pseudorandom generators
22:23:47 <acetoline> or just brute-force rejection sampling?
22:23:52 <mniip> yes
22:23:55 <mniip> hence the name
22:24:01 <acetoline> oh, damn
22:24:07 <Cale> There are three important type classes
22:24:09 <acetoline> is there no way to do this based on a grammar?
22:24:12 <Cale> There's
22:24:26 <mniip> acetoline, proof of equality of 2 arbitrary expressions?
22:24:34 <acetoline> no
22:24:34 <Cale> class Arbitrary a where arbitrary :: Gen a; shrink :: a -> [a]
22:24:56 <Cale> which specifies a canonical random generator for various particular types
22:24:57 <acetoline> I mean generating expressions in a way that will always cause them to typecheck
22:25:03 <Cale> and then for the functions
22:25:22 <Cale> class CoArbitrary a where coarbitrary :: a -> Gen b -> Gen b
22:25:44 <Cale> i.e. given a value of type a, we want to tweak a generator for values of type b in some deterministic way
22:25:54 <Cale> This is used to get the Arbitrary instance for functions:
22:25:57 <mniip> acetoline, why
22:28:02 <mniip> hmm
22:28:03 <Cale> instance (CoArbitrary a, Arbitrary b) => Arbitrary (a -> b)
22:28:37 <acetoline> mniip: I'm thinking so that the kinds of generated expressions can be tweaked easily
22:28:43 <Cale> where basically, the argument to the function is used to modify the generator used to generate result values
22:28:49 <Cale> So you essentially get random functions
22:29:01 <Cale> But deterministic ones, once selected
22:29:31 <Cale> You can think of this as a scheme for generating expressions if you want to include the mechanism of the PRNG here
22:29:32 <mniip> requiring 'strip whitespace' to be an explicit lens sounds bad, but it's better than making 'number' a traversal instead of a prism
22:32:26 <xnil____4> how does printf from Text.Printf make itself variadic?
22:32:38 <Sergio965> Magic!
22:32:47 <jle`> typeclass trickery
22:33:02 <jle`> it's all delightfully un typesafe
22:33:03 <mniip> ^
22:33:15 <mniip> no it's typesafe
22:33:21 <mniip> I'm not sure whether it's decidable though
22:33:22 <jle`> i mixed things up
22:33:27 <jle`> the typeclass trickery is definitely typesafe
22:33:33 <jle`> but it doesn't check the contents of your string at compile-time
22:33:42 <jle`> so nothing stops you from passing in something of the wrong type to a %d
22:34:13 <xnil____4> yeah but how the buh-huh do i make a function that takes args like that
22:34:13 <mniip> it doesn't unsafeCoerce though does it? it throws an exception
22:34:14 <Cale> (at which point you get a runtime exception)
22:34:14 <mniip> right?
22:34:26 <mniip> xnil____4, why
22:34:29 <Cale> xnil____4: Look at the PrintfType class
22:34:38 <jle`> xnil____4: typeclasses :) there was a nice accessible article about it a few months ago
22:34:48 <Cale> printf :: PrintfType r => String -> r
22:34:58 <Cale> PrintfType has instances:
22:35:03 <Cale> IsChar c => PrintfType [c]
22:35:07 <mniip> http://stackoverflow.com/a/3467806/2337954
22:35:14 <Cale> PrintfType (IO ())
22:35:19 <Cale> (PrintfArg a, PrintfType r) => PrintfType (a -> r)
22:35:44 <Cale> So, basically, String, IO (), and then functions whose argument is an instance of PrintfArg
22:35:59 <Cale> (and whose result is an instance of PrintfType)
22:47:31 <jle`> i can't wait for the day when i can sed "s/liftM/fmap/g" ./*
22:47:58 <jle`> just thinking about it...
22:48:06 <Cale> jle`: Just make sure you don't kill your instances
22:48:20 <jle`> how would it do that?
22:48:30 <Cale> instance Functor MyMonad where fmap = liftM
22:48:37 <jle`> oh, if i did fmap = liftM somewhere
22:48:39 <jle`> oh yeah
22:49:13 <jle`> if i had anything like that i'd rewrite them first.
22:49:27 <jle`> also finally being able to generalize the constraints on so many of my functions is nice
22:49:39 <Guest60056> I'm looking for pay someone to make a simple bot for a browser based game for me
22:49:39 <jle`> too many things Monad m => that could just be Applicative f =>
22:49:55 <Guest60056> will pay up to $50
22:50:01 <jle`> i even have some Monad m =>'s that could be Functor f =>'s
22:50:10 <Cale> jle`: I don't understand why you couldn't just do that now?
22:50:27 <Guest60056> no one interested?
22:50:44 <Guest60056> like it would be super simple
22:50:48 <Guest60056> i just dont know how to do it
22:50:53 <Guest60056> and im getting frustrated
22:51:03 <Cale> Guest60056: This channel is for discussion of the programming language Haskell
22:51:05 <jle`> Cale: you mean download 7.10 ?
22:51:30 <pacak> Guest60056: Do you have time to talk about our Lord Haskell?
22:51:35 <Cale> jle`: No, I just mean use the appropriate class
22:51:39 <pacak> Probably not.
22:52:21 <srid> `parse error on input ‘_’` <-- arising from `case ... _ -> True`. any idea why? I thought `_` is valid 'do not care' syntax.
22:52:42 <orzo> srid: paste some more context somewhere
22:52:47 <pacak> srid: Error is probably above
22:52:51 <Cale> srid: Maybe indentation is wrong?
22:53:05 <Cale> Or maybe forgot to close a paren somewhere or something like that?
22:53:07 <jle`> try using fmap on something like StateT
22:53:10 <orzo> also might check that your _ is not some oddball unicode lookalike
22:53:14 <jle`> if you are parameterizing over Monad m
22:53:17 <srid> here's the code: https://gist.github.com/anonymous/bda88b3f5a93d0850bb6
22:53:30 <jle`> foo :: Monad m => StateT s m a -> ...; foo = ... fmap ...
22:53:37 <jle`> won't work
22:53:37 <orzo> looks like it fails to line up with the other case
22:53:51 <Cale> jle`: instance Functor m => Functor (StateT s m)
22:53:55 <orzo> you're using layout, so you nee dthe right amount of indentation
22:53:59 <jle`> you'll need foo :: (Monad m, Functor m) => StateT s m a -> ...
22:54:03 <Cale> So as long as your m is an instance of Functor, it'll work
22:54:03 <jle`> if you wan to do both fmap and binds
22:54:10 <jle`> if you want to parameterize over all m
22:54:12 <pacak> srid: cases must be alighned
22:54:15 <Cale> Yeah, well, you're using StateT wrong, don't blame me :)
22:54:20 <Cale> lol
22:54:35 <srid> ah, ok.
22:54:38 <jle`> StateT was just an example from a common library heh.
22:54:50 <jle`> but really, if you want to leave your StateT parameterized over m, you can't use both bind and fmap
22:54:59 <Cale> But yeah, okay, you can run into cases where you need both a Functor and Monad constraint
22:54:59 <jle`> unless you have two constraints
22:55:12 <jle`> so...my types that are similar...made the Functor constraint require Monad
22:55:24 <jle`> instance Monad m => Functor (StateT s m) where ...
22:55:44 <jle`> because most of the usage of my type is parameterized over Monad m by intent
22:55:51 <Cale> Not sure I'd have gone for that...
22:56:06 <jle`> the only alternative is having double constraints :O
22:56:14 <jle`> everywhere :O
22:56:26 <Cale> I guess maybe after typing (Monad m, Functor m) for the hundredth time, I'd change my mind :)
22:57:05 <jle`> also most of the library functions are parmaeterized over m, so almost the entire API would have that constraint, heh
22:57:07 <c_wraith> I plan on not ever using a GHC pre-7.10 again, just because of that..
22:57:14 <Cale> type MonadF m = (Monad m, Functor m)
22:57:20 <Cale> ^^ you could do that ;)
22:57:31 <jle`> ;)
22:58:09 <jle`> btw does 7.10 have any actual changes to ghc....
22:58:27 <c_wraith> Sure.  It has partial type signature support!
22:58:33 <Cale> Do you really have that much code which is generalised over a choice of monad? Is this for a library or an application?
22:58:36 <jle`> :D
22:58:46 <c_wraith> Partial type signatures are nice
22:59:04 <c_wraith> Especially for things like working with GADT pattern matches
22:59:08 <jle`> Cale: the library offers generalized functions....but it encourages generalized functions in applications that use it, as a style recommendation
22:59:42 <jle`> *it's for a library
23:00:37 <ab9rf> i don't even know what a partial type signature is
23:01:30 <jle`> you will soon :D
23:01:53 <ab9rf> i can hope
23:01:54 <rola> I found a nice collection of FP patterns by jeremy gibbons: https://patternsinfp.wordpress.com/
23:02:25 <jle`> i've found myself wishing for them a lot
23:03:24 <Cale> rola: Do any of those really count as patterns? I'm pretty sure all those things are in libraries somewhere.
23:03:47 <c_wraith> Just because haskell can put it in a library doesn't mean it's not a pattern. :)
23:04:03 <Cale> ehh
23:04:09 <ab9rf> it just means it's na "obvious" pattern, for some (possibly small) value of "obvious"
23:04:29 <Cale> I'd rather reserve the word pattern for the things which the language is somehow preventing us from usefully abstracting over
23:04:55 <rola> ah
23:05:06 <c_wraith> ab9rf: in GHC 7.10, you will be able to put _ in a type signature and have it mean "figure out what this expands to yourself", with the right extension enabled.
23:05:26 <c_wraith> ab9rf: It's really handy when most of a type signature is boilerplate, but it has some important details
23:05:58 <ab9rf> c_wraith: that would be vaguely useful in cases where i need to force one portion of the type signature but the rest of it is deducible but complicated
23:06:00 <c_wraith> ab9rf: especially in cases where inference fails, like with pattern-matching a GADT
23:06:29 <Cale> rola: But it is a cool blog regardless :)
23:06:29 <ab9rf> conduit, parsec, and lens generate some fairly gnarly type signatures by default
23:06:38 <c_wraith> ab9rf: or ascribing a concrete type to an expression that's *mostly* inferrable, but needs to be fully inferred to resolve a type class
23:07:07 <ab9rf> c_wraith: so youcan stick a pin in part of the type signature and let haskell figure out the rest, basically?
23:07:43 <fread2282> lens type signatures are mostly an issue because ghc resolves type aliases in error messages though
23:07:50 <c_wraith> ab9rf: yeah
23:08:04 <ab9rf> c_wraith: i have occasionally wished for that when dealing with parsec
23:08:59 <c_wraith> ab9rf: It's a quality-of-life change.  Doesn't enable anything new, but it makes it more pleasant to do certain things.
23:10:00 <ab9rf> i could do with some quality of life on my lower back
23:10:50 <ab9rf> i strained it splitting firewood :\
23:14:21 * fread2282 wonders if there would be any use pushing the instance uniqueness check to use sites in the presence of instance arguments
23:14:23 * hackagebot mime-mail 0.4.8.1 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.4.8.1 (MichaelSnoyman)
23:19:21 <fread2282> so if there are multiple possible instances in scope you have to specify which one to use
23:20:15 <ski> "instance arguments" being ?
23:24:12 <fread2282> ski: agda-like implicits, records that you can register for search when a function that asks for an instance argument is called, but you can also specify a specific (possibly not registered for search) instance
23:24:49 <fread2282> so like typeclasses but you can also make non-canonical named instances that you can use if you specify them
23:25:04 <ski> fread2282 : note that the correctness of some libraries depend on "instance uniqueness check"
23:25:11 <fread2282> ski: sure
23:26:51 * ski sorta-kinda feels like an Agda-like implicit should only be allowed when there's only one possible value for it (that unicity possibly only being provable in the local context)
23:27:52 <ski> so in `id False', the only possible value for the implicit is `Bool', which makes it ok
23:29:01 * fread2282 might have been confusing with instance vs implicit argument terminology
23:29:02 <ski> (by "only possible" i don't just mean "only known value in scope" or "only known named value in scope" or something similar)
23:29:46 <fread2282> instance arguments are agda's typeclass thing
23:30:21 <ski> yeah. i understand they're more than plain implicit arguments. (though i haven't looked into the details of them)
23:36:55 <fread2282> agda has normal implicit arguments like you describe too
23:37:36 <solatis> @hoogle m r -> IO r
23:37:39 <lambdabot> Graphics.Rendering.OpenGL.GL.StateVar get :: HasGetter g => g a -> IO a
23:37:39 <lambdabot> Control.Concurrent.Chan readChan :: Chan a -> IO a
23:37:39 <lambdabot> Control.Exception.Base block :: IO a -> IO a
23:53:45 <mabino-pyon> Is there any tool to list all uses of a given type within a project?
23:54:37 <jle`> grep? :)
23:54:47 <jle`> sorry. i don't know. but it would be nice if there was one :D
23:54:55 <jle`> that's actually what i do when i need to do this >____>
23:54:56 <mabino-pyon> Type inference... :-|
23:55:03 <jle`> ah i see
23:55:48 <mabino-pyon> Anyway, I guess I will have to make do with grep for now. :-P
