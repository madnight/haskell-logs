00:00:08 <lpsmith> except I'd like to also be able to specify optional files,  maybe something like cmd --conf path1 --optional path2 --conf path3
00:00:35 <lpsmith> However,  I haven't found a way to preserve the ordering [path1, path2, path3]
00:00:52 * hackagebot configuration-tools 0.2.11 - Tools for specifying and parsing configurations  http://hackage.haskell.org/package/configuration-tools-0.2.11 (larsk)
00:00:58 <lpsmith> Instead I get a ([path1,path3],[path2]) type of structure
00:04:57 <dramforever> Wow, GHC does IO managing?
00:05:15 <dramforever> that's incredible!
00:07:42 <orzo> what is IO managing?
00:08:01 <EvanR> its so you dont have to manage it
00:08:21 <EvanR> hehe
00:09:15 <dramforever> GHC uses things like epoll and select internally
00:09:20 <dramforever> so it's fast
00:09:25 <lpsmith> ok, n/m, got it
00:09:55 <EvanR> yes it is very nice
00:10:14 <EvanR> unless you happen to want to select epoll yourself
00:10:47 <dramforever> EvanR: yes it could be faster
00:10:53 * hackagebot HsOpenSSL-x509-system 0.1.0.0 - Use the system's native CA certificate store with HsOpenSSL  http://hackage.haskell.org/package/HsOpenSSL-x509-system-0.1.0.0 (MariosTitas)
00:10:59 <dramforever> but would be really hard
00:11:02 <dramforever> hard to use
00:11:03 <EvanR> or just if you want to have control over it, and know what its doing
00:11:28 <EvanR> you have a certain sense of centainty with C selecting, no exceptions (as long as you handle SIGPIPE ...)
00:12:02 <dramforever> and GHC lets you go down to the machine
00:12:11 <dramforever> hmm...but it could be slower
00:12:22 <dramforever> if you are not really good at epoll-ing
00:12:44 <EvanR> meh i wasnt too worried about performance
00:13:15 <dramforever> Oh a performance question:
00:13:18 <EvanR> threads is way easier to program
00:13:30 <dramforever> Why does the CPS in attoparsec makes it fast?
00:16:34 <dramforever> If you've never seen it before: it's essentially newtype AttoParsecish a = APISH (ParseState -> SuccessContinuation -> FailureContinuation -> Result a)
00:17:46 <acetoline> how can I become a better haskell programmer
00:17:56 <Xe> write things in haskell
00:18:47 <acetoline> Xe: eh
00:18:52 <acetoline> what if I write crappy things
00:18:56 <blackdog> acetoline: probably reading lots of haskell is not a bad idea either
00:19:04 <acetoline> what projects do you recommend
00:19:06 <EvanR> if you write crappy code, you will probably know it
00:19:13 <blackdog> i certainly spent a very long time writing very amateur haskell because i didn't read enough :)
00:19:14 <EvanR> and figure out how to improve it
00:19:17 <Xe> acetoline: you have to know how to make crap code to know why it's crap :P
00:19:48 <acetoline> EvanR: I doubt it. Unlike most programmers I have enough self-awareness to realize I probably write crap code when beginning to learn a language
00:20:09 <EvanR> acetoline: thats what i jus said
00:20:25 <acetoline> knowing it's crap is not the same as knowing how to improve it
00:20:34 <EvanR> you will find out how to improve it
00:20:48 <blackdog> acetoline: a lot of it is noticing patterns. if you're starting to write stuff like "do; a <- foo; b<- baz; c <- bar; return (Foo a b c)", you'll recognise that you can use Applicative instead
00:20:59 <blackdog> and write it as Foo <$> foo <*> baz <*> bar
00:21:00 <acetoline> blackdog: what code would you recommend
00:21:07 <acetoline> blackdog: preferably something I can understand
00:21:10 <blackdog> acetoline: xmonad is pretty decent.
00:21:13 <acetoline> I'm not going to start hacking ghc
00:21:19 <acetoline> (at least not at the moment)
00:21:24 <dramforever> I think the easiest is to read library docs
00:21:31 <dramforever> and get to know more funcs
00:21:32 <blackdog> but even just writing code using the library examples is a good start
00:21:37 <acetoline> hrm ok
00:22:07 <blackdog> another example: if you're doing json programming in most languages, you tend to just convert into a big dictionary-of-dictionaries-and-strings-and-numbers, right?
00:22:33 <blackdog> in haskell, the preferred method is to have a datatype that captures everything about your data, and have all the checking done at the outset
00:22:37 <dramforever> acetoline: did you come from a dynamic language like python/ruby/...
00:22:44 <blackdog> and the aeson docs do a pretty good job of making that model clear
00:25:51 <tdammers> blackdog: actually, I'd say that Aeson is flexible enough to allow for either approach equally well
00:26:13 <blackdog> tdammers: you can do it, but the docs certainly push you in the direction of doing it at the edges.
00:26:18 <acetoline> dramforever: not really, I'm more from a numerical background, but I like scheme as well
00:26:29 <acetoline> dramforever: I've been 'playing around' non-seriously with haskell for about 2 years now
00:26:29 <tdammers> blackdog: and rightfully so ;)
00:26:42 <blackdog> when you really just want to focus on a tiny piece of a big ugly json structure, lenses are better
00:27:03 <dramforever> actually, I learn haskell because GHCi is a great power calculator
00:27:05 <acetoline> I also went through 'learn you a haskell' and understood most of it, except maybe zippers
00:27:33 <dramforever> I do most of my number crunching there
00:27:35 <tdammers> blackdog: I've been rolling with a semi-typed approach to JSON myself lately
00:28:06 <acetoline> my fav language at the moment is julia
00:28:20 <acetoline> which has an ADT system similar (but perhaps a bit less expressive) than haskell's
00:28:27 <dramforever> my fav is haskell already
00:28:38 <dramforever> second is C
00:28:44 <acetoline> oh god
00:28:45 <bramgg> haasn: you said earlier not to use [] to represent lines of text. How would YOU represent lines of text?
00:29:03 <blackdog> tdammers: i tend to find when you're writing protocol-y stuff that fully typed is better
00:29:16 <dramforever> bramgg: I heard that emacs uses a Rope
00:29:30 <blackdog> but at the moment i'm just digging through vast swathes of tangentially relevant json, of course without a schema, so digging in with lens is much much easier.
00:29:35 <EvanR> blackdog: im still not sure when fully typed is not better
00:30:04 <dramforever> bramgg: http://en.wikipedia.org/wiki/Rope_%28data_structure%29
00:30:10 <bramgg> dramforever: thanks
00:30:13 <EvanR> dramforever: IntMap Line ?
00:30:28 <blackdog> EvanR: i think it's just harder to ignore pieces.
00:30:43 <EvanR> blackdog: ignore pieces?
00:30:56 <blackdog> when large chunks of the json are irrelevant
00:30:59 <dramforever> EvanR: ???
00:31:19 <EvanR> blackdog: that is not a good argument against types, that is an argument for types that can express that structure
00:31:23 <blackdog> at least, my experience of converting something from using FromJSON to using lens-aeson was that it became dramatically shorter
00:31:35 <EvanR> blackdog: for example, record types and record subtyping
00:32:07 <EvanR> blackdog: aeson in particular... you can easily ignore pieces
00:32:07 <blackdog> EvanR: lenses are still fully typed, really. it's not just firing hashmaps into the main app.
00:32:17 <blackdog> it is easier to ignore them with lens, though.
00:32:41 <dramforever> lens is also magical
00:33:04 <EvanR> well, still, i cant say that "not typed is better at the point where you are trying to reconstruct the type from who-knows-what unstructured data"
00:33:11 <EvanR> its kind of the exact opposite issue
00:44:09 <zipper> According to haskell's persistet there is a persistent value type that allows me to store a map. However when I try to add a map of type [(Text, Text)] to my models I get the error that it's an invalid field type.
00:45:50 <zipper> or one can't edit their models file after having saved a few things to the db and have it migrate automatically?
00:45:54 <zipper> I'm using yesod
00:50:39 <lush> hi
00:51:14 <lush> I recently discovered this [1] example for a haskell-echo-server
00:51:15 <lush> [1]: https://github.com/gislik/haskell-networking-samples/blob/master/EchoServer.hs
00:51:23 <lush> I copied it, and now tried to write a simple client that uses getLine to get a line from the terminal and den sends that to the EchoServer
00:51:30 <lush> But I don't know how to do this.. I tried connectTo and sendTo from the Network package, but I always got "getAddrInfo: does not exist (Name or service not known)"
00:51:44 <lush> May somebody explain me why I get this error, and how to do this instead?
00:53:08 <bennofs> lush: how did you call connectTo?
00:53:15 <lush> one moment
00:53:15 <bennofs> (with what arguments)
00:54:22 <zipper> How do I use a map in my models in yesod? or how do I store a map in a the DB in yesod?
00:54:36 <lush> http://susepaste.org/83154567
00:54:42 <lush> @ bennofs
00:54:50 <bennofs> zipper: if you don't get an answer here, you could also try #yesod
00:55:04 <ReinH> nah, lens is just sufficiently advanced technology
00:55:06 <zipper> bennofs: Yesod channel is like dead :(
00:55:30 <lush> bennofs: I never did network stuff before, so my code may be stupid ^^
00:55:36 <bennofs> oh, didn't know that (just looked at it and there were 90 members)
00:56:00 <bennofs> lush: you need to use "localhost" as hostname, that refers to the current computer
00:56:43 <zipper> bennofs: Yeah but they're just lurking or something
00:56:49 <lush> bennofs: oh...
00:56:54 <lush> bennofs: ty ^^
00:56:55 <zipper> bennofs: Anyway thanks
01:01:14 <mw_> apologies for nood question
01:01:31 <mw_> What's the correct declaration for a list of strings in Haskell?
01:01:46 <mauke\> no nudes, please
01:01:56 <mauke\> foo :: [String]
01:02:22 <mw_> tried data MyType = [String] but parse error
01:02:41 <mauke\> ah
01:02:59 <mauke\> do you want to create a new type, or do you just want to give [String] another name?
01:03:02 <lush> bennofs: How would you receive all the messages, that the server gets? connectTo and then something with the handle or receiveFrom?
01:03:08 <mw_> make a new type
01:03:40 <lush> mw_: maybe you're looking for newtype?
01:03:56 <lush> https://wiki.haskell.org/Newtype
01:04:25 <lush> mw_: Or do you want something like this: data MList = MList [String]
01:04:35 <Hijiri> if you dropped in newtype you would still need a constructor
01:04:40 <lush> y
01:05:56 <mauke\> mw_: then you need to provide a data constructor
01:14:24 <quchen2> So in Java, exceptions seem to be an acceptable control flow. Furthermore, Java allows abstracting over *-kinded things, so we can implement a Monoid generic. A colleague wants to implement a monoid that throws an exception when mappend is used. I'm unsure how sound an instance "Monoid where mempty = throw; _<>_ = throw" would be in that setting. Any opinions?
01:14:37 <quchen2> Haskell's Void has a semigroup instance with similar behaviour.
01:15:07 <quchen2> I guess it comes down to how much one wants to have bottom as a proper value?
01:15:56 * hackagebot yesod-bin 1.4.3.7 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.3.7 (MichaelSnoyman)
01:17:23 <tdammers> quchen2: it's Java. does it "work"? yes? -> ship it.
01:17:28 <Cale> quchen2: Whether it's acceptable depends on the choice of semantics.
01:18:01 <quchen2> tdammers: We aim at having a well-designed codebase.
01:18:18 <Cale> If throw is a value, then that's a valid monoid
01:18:36 <quchen2> Well, throw is something that throws an exception, pretty much like a goto.
01:18:41 <Cale> If not, then no.
01:19:23 <blackdog> exceptions ruin everything :/ like having an implicit Either on the return type of every single function
01:19:44 <quchen2> The specific use case here is that two disjoint Maps should be merged, and there should be an exception when there is a value collision.
01:20:08 <quchen2> So the monoid would combine the values if there is more than one, and the "throwing Monoid" would throw as soon as such a combination happens.
01:21:30 <Procian> blackdog: Checked exceptions are at least explicit.
01:22:01 <Procian> quchen2: You should only need a semigroup for that.
01:22:15 <quchen2> Hmm right, we never have to use mempty.
01:22:39 <quchen2> But even then, mappend would combine two non-bottom values to trash.
01:23:31 <quchen2> A fully un-total mappend monoid ;-)
01:24:07 <blackdog> Procian: right, it's having no way of saying "hey, this thing is total, no weird shit happening here" that's a bummer
01:24:10 <blackdog> but i suppose we have bottom anyway
01:24:14 <tdammers> quchen2: yeah, ofc... but you have to make do with what you get
01:24:56 <tdammers> exceptions and null are things you just have to work around somehow, IMO
01:25:08 <tdammers> and I don't even think of them as the biggest show stoppers in Java
01:25:27 <tdammers> much worse is how stuff is mutable by default, and limiting mutability is really hard
01:26:33 <quchen2> My aim wasn't ranting about Java so that's besides the point.
01:26:40 <tdammers> yeah
01:26:42 <tdammers> true
01:26:54 <tdammers> ranting about Java is -blah material anyway
01:27:12 <quchen2> I was just wondering what people in the total world of Haskell thought about that design in other not-so-total languages.
01:28:53 <Procian> quchen2: I don't use bottom as a value (though I make an exception if doing it via Void's interface).
01:28:58 <tdammers> well... the way I see it, the first choice is explicit types; second choice is runtime assertions and unit tests; third choice is documentation
01:29:29 <tdammers> since you can't rule out exceptions and null references in Java, this means I'd resort to unit-testing and asserting all the things
01:30:59 <quchen2> Hmm true
01:31:11 <quchen2> Although I have to say, I sometimes miss mocking in Haskell now.
01:31:45 <blackdog> quchen2: i tend to feel that if you have to mock, your code isn't loosely coupled enough anyway
01:31:56 <Cale> Well, bottom is a value in Haskell's semantics
01:32:09 * mauke\ mocks quchen2 
01:32:15 <quchen2> Debugging IO stuff in Haskell is often a bit clumsy.
01:32:16 <Cale> It's just the least defined value
01:32:26 <Cale> for any given type
01:32:37 <quchen2> Cale: But we like to pretend that there is no bottom most of the time.
01:32:56 * lush afk
01:32:56 <quchen2> Or at least I do in practice. And then I try to write my programs to contain no bottoms.
01:34:17 <blackdog> quchen2: yeah - but that's often a signal that you should be writing it in free monad + interpreter style
01:34:28 <Procian> I'm not saying it doesn't exist. I'm just saying I don't use it, which is a lie thinking about it. I use it quite a lot as a stub when I'm trying to get something to typecheck, or I want to test whether I'm being sufficiently lazy.
01:35:21 <blackdog> quchen2: it just seems really perverse to say "oh, my code is hard to test - the fault must be in my testing software not being sophisticated enough"
01:36:14 <mauke\> perl has an interesting bit of syntactic sugar: 'foo = ...' turns into 'foo = error "Unimplemented"'
01:36:38 <quchen2> blackdog: Well, some things are only valid in a giant context that is hard to emulate. I'm working on a distributed system with lots of actors where it's really hard to test the behaviour of a single node in a meaningful way.
01:36:54 <quchen2> (It's not really a distributed system, but conceptually close to it.)
01:37:38 <quchen2> mauke\: Haskell has an interesting library that gives you "foo = ಠ_ಠ" ;-)
01:38:02 <mauke\> https://metacpan.org/pod/Acme::LookOfDisapproval
01:42:28 <mw_> sorry for silence. data MyType = Mytype [String] is perfect
01:43:16 <quchen2> newtype instead of data would be even perfecter in most cases
01:43:23 <mw_> why?
01:43:41 <quchen2> Internally, it'll be identical to [String].
01:43:43 <mw_> Read the Haskell wiki link. Not much clearer... discussion of lifted types
01:44:09 <mauke\> basically, newtype is for wrappers
01:44:20 <mauke\> where you have a type that is internally identical to another type
01:45:12 <mw_> whereas data is for making more "complex" types?
01:45:45 <mauke\> newtype is limited to a single constructor with a single field
01:45:51 <mauke\> data can do whatever it wants
01:51:35 <zipper>  Does anyone know anything about storing a map/hashmap/dictionary in a SQL db? using persistent in yesod?
01:51:47 <zipper> How can I represent such a type in my models?
02:00:57 * hackagebot hspec-core 2.1.4 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-core-2.1.4 (SimonHengel)
02:00:59 * hackagebot hspec-discover 2.1.4 - Automatically discover and run Hspec tests  http://hackage.haskell.org/package/hspec-discover-2.1.4 (SimonHengel)
02:01:01 * hackagebot hspec 2.1.4 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-2.1.4 (SimonHengel)
02:03:57 <mw_> Sorry, now stuck on using record syntax:
02:04:01 <mw_> data Arg = IndArg {Evidence :: [String], Claim :: String} deriving (Show)
02:04:18 <Procian> Evidence and Claim should be lowercase.
02:04:29 <mw_> Arrrgh!
02:04:44 <quchen2_> evidence and claim are function
02:04:47 <quchen2_>  /record names.
02:04:50 <quchen2_> Hence lower-case.
02:04:52 <mw_> If I have defined Evidence and Claim as separate datatypes
02:05:11 <mw_> (i.e. data Evidence = Evidence [String])
02:05:19 <mw_> is that any better/ different?
02:05:53 <quchen2_> Then you'd write { evidence :: Evidence, claim :: Claim } or something like that.
02:06:22 <mw_> Yep, just done that....
02:07:06 <mw_> .... and now works
02:16:12 <merijn> HaskellCEO is my favourite new novelty twitter account :>
02:16:35 <Procian> You are correct.
02:17:00 <merijn> Mostly because it posts a lot more than the other novelty accounts I follow :p
02:23:17 <acetoline> that haskellceo account can't be serious
02:23:30 <sgronblo> maybe it could, who knows???
02:24:19 <acetoline> I've seen so much craziness in the tech industry that I'm not even sure anymore
02:26:13 <Procian> PHP CEO appears to have been first.
02:26:49 <tzaeru> http://www.bizjournals.com/jacksonville/news/2013/09/24/civic-council-head-charged-with-dui.html *snrsk*
02:29:38 <sgronblo> Anyway, I think the jokes are a bit uncreative
02:29:51 <sgronblo> It's all puns
02:31:01 <acetoline> what's this 'nerd google'
02:31:06 <acetoline> is it hoogle
02:31:50 <mw_> any practical advice as to which module to use for reading a CSV file?
02:35:21 <fuzzy_id> I'm working my way through the http-4000 library docs trying to find a way to try out a connection via ipv6 and fall back to ipv4 eventually
02:35:36 <fuzzy_id> is there a simple answer or do i have to handle sockets/streams by hand?
02:48:09 <merijn> acetoline: Of course it's not serious, it's a novelty account for a reason :p
02:48:43 <merijn> acetoline: Yeah, it's Hoogle, hence LMHTFY instead of LMGTFY ;)
02:50:00 <EvanR> hahaha cant tell if haskell ceo is serious
02:50:06 <EvanR> that would be awesome
02:50:22 <merijn> fuzzy_id: I think most libraries will default to whatever the name server returns first
02:51:57 <lpaste> simg pasted “parseCSV.hs” at http://lpaste.net/120597
02:52:31 <merijn> fuzzy_id: Normally I use http-conduit for HTTP communication, but that only seems to specify either an IPv4 address or hostname right now :\
02:52:37 <simg> mw_: I'm a total non-expert, but that's what I'm using
02:53:09 <merijn> fuzzy_id: I don't think it should be very hard to modify the existing IPv4 code to also allow you to specify and IPv6 address, but I guess no one's done that yet?
02:53:44 <acetoline> merijn: thing is, I can imagine my boss saying stuff like that
02:54:00 <merijn> fuzzy_id: Anyway, why do you wanna try ipv6 even if there's an ipv4 for the domain?
03:01:02 * hackagebot linearscan 0.3.1.0 - Linear scan register allocator, formally verified in Coq  http://hackage.haskell.org/package/linearscan-0.3.1.0 (JohnWiegley)
03:02:17 <zipper> Is there something like read but works for type text?
03:02:35 <zipper> "6" :: Text  to 6
03:03:07 <simg> zipper: pack / unpack ?
03:03:53 <zipper> > unpack ("6" :: Text) :: Int
03:03:54 <lambdabot>  Not in scope: ‘unpack’
03:03:54 <lambdabot>  Perhaps you meant one of these:
03:03:54 <lambdabot>    ‘BS.unpack’ (imported from Data.ByteString),
03:04:15 <zipper> simg: Type Text not ByteString
03:04:39 <simg> zipper: sry, Data.Text.unpack / Data.Text.pack
03:04:50 <Procian> zipper: pack/unpack with code/decode will just let you move between Text and String, where you can then do the normal read.
03:05:03 <Procian> But if you're using Text for speed, this probably isn't the way to go.
03:05:17 <orzo> there's Data.Text.Read
03:05:27 <zipper> orzo: Oh nice
03:06:28 <orzo> it's not a type class like read, but it has nifties for reading numbers and such
03:07:01 <mw_> I'm trying to define a "Direction" type
03:07:28 <mw_> data Direction = Direction ">" | "<" | "~"
03:07:32 <mw_> I get this error
03:07:33 <mw_> Illegal literal in type (use -XDataKinds to enable): ">"
03:07:49 <orzo> you are using ">" as a type
03:08:22 <gfixler1> data Direction = Left | Right | Neither
03:08:44 <orzo> that will conflict with prelude Either
03:09:11 <gfixler1> data Direction = Leftwards | Rightwards | Aimless
03:09:12 <mauke\> data Direction = East | West | Squiggly
03:09:20 <orzo> how about newtype Direction t = Direction t and then you have Direction Ord
03:09:33 <orzo> heh
03:09:37 <mauke\> *Ordering
03:09:46 <orzo> yeah
03:09:51 <mauke\>   deriving (Read, Show, Eq, Ord, Enum, Bounded, Typeable, Data)
03:11:13 <mw_> I am now officially confused
03:11:26 <orzo> it was official earlier
03:11:38 <orzo> strings are not types
03:11:50 <mw_> (agree)
03:12:08 <orzo> so your data constructor Direction should can not take a value of type ">"
03:13:17 <orzo> data DIrection = Direction Ordering -- seems similar to what you were trying to do
03:13:46 <mw_> I was looking to make Direction an enumerated type
03:13:51 <orzo> as is mauke\ suggestion
03:13:53 <mw_> You mean: newtype Direction t = Direction t and then you have Direction Ord
03:14:07 <orzo> i made that suggestion
03:14:21 <mw_> I know - was checking which you meant
03:14:37 <orzo> i revised it as the later sugestion seems closer to your intention
03:15:01 <orzo> besides, Ord isn't a type either as mauke\ pointed out
03:15:16 <orzo> Ordering is the type i meant
03:15:48 <orzo> data Ordering = LT | EQ | GT
03:16:03 * hackagebot lowgl 0.2.1.1 - Basic gl wrapper and reference  http://hackage.haskell.org/package/lowgl-0.2.1.1 (evanrinehart)
03:18:09 <mw_> Thanks a lot - really helpful
03:18:22 <mw_> On a simpler note:
03:18:42 <mw_> If types X and Y derive Show
03:18:52 <mw_> Do we need to say that Type Z
03:19:11 <mw_> (where data Z = Z X Y) derives Show as well?
03:19:24 <orzo> yes
03:19:37 <mw_> Why no inference of typeclass?
03:19:40 <mauke\> only if you want to show values of type Z
03:20:01 <mauke\> that's counterproductive
03:20:18 <mauke\> class instances expose internals in some way (or at least a certain interface)
03:20:22 <orzo> you misunderstand the point of making a new type
03:20:22 <mauke\> that's not always what you want
03:20:42 <orzo> (X,Y) already has a Show instance
03:20:44 <mw_> yes - I think I do mis-understand new types
03:20:51 <mauke\> sometimes you want to keep a type abstract from your users. "show" would let them see internals
03:21:03 * hackagebot hspec-server 0.4.1 - Test Framework for checking server's status  http://hackage.haskell.org/package/hspec-server-0.4.1 (junjihashimoto)
03:21:33 <mauke\> it would also clash with a custom Show instance
03:21:44 <mw_> Makes some sense......
03:21:55 <mauke\> > M.singleton "foo" 42
03:21:56 <lambdabot>  fromList [("foo",42)]
03:21:57 <mw_> I understand why you might want to implement a custom Show
03:22:07 <mauke\> Map is a tree internally, but you can't see that
03:22:30 <mw_> ...but in the absence of a custom Show, why not fall back onto the "Show" of the elements?
03:22:34 <orzo> making types gives you a thing called type-safety.  It's the idea that you shouldn't be allowed to do just anything with anything.  Restrictions help the compiler find your mistakes
03:22:46 <mauke\> you can't prove absence
03:23:13 <mauke\> like, you could be compiling A.hs, which defines a type T
03:23:31 <mauke\> later on you compile B.hs, which defines instance Show T
03:23:37 <mw_> Yes, understand type-safety, which is why I am keen to define some types, not just let everything be String
03:23:58 <mauke\> if the compiler automatically generates a Show instance in module A, you now have a duplicate definition error
03:24:09 <mw_> Yes, see your point about problems with assuming absence of Show
03:24:43 <mw_> Didn't get M.singleton comment...
03:24:50 <mw_> ..but then I haven't used Map
03:25:16 <mauke\> Map is a data structure that maps keys to values
03:25:24 <mauke\> it provides efficient key lookup
03:25:26 <orzo> i think it's more basic that when you make a new type, you are making a new conract with the compiler. This is a type, and this is what i can do with it.  The compiler shouldn't make guesses and allow things, that's counter to the principle of type safety
03:25:28 <mw_> Yes - familiar with maps (python/ java)
03:25:48 <mauke\> it's implemented as a tree, but the details are private
03:26:08 <mw_> Ok - makes lots of sense - and I get the reasons for hiding the implentation details
03:26:08 <mauke\> it defines a custom Show instance to hide its internals
03:26:24 <mw_> Just out of interest
03:27:01 <mauke\> orzo: well, you could do it that way, but then you'd have to provide a way for the programmer to say "don't derive Show here"
03:27:22 <mw_> Since many things derive Show, Eq, (and others), do people often generate a "common" typclass (e.g. "utilities") and then derive U for many types?
03:27:41 <orzo> no
03:27:53 <mauke\> the list of derivable classes is small and hardcoded in the compiler
03:28:26 <orzo> not exactly true anymore I suppose, with upcomming ghc
03:28:43 <orzo> DeriveAnyClass
03:29:45 <orzo> still, a long string of classes to derive whenever a new type is declared is the common idiom
03:29:53 <mauke\> ooh, how does that work?
03:30:01 <mw_> Yes, that's what I've seen
03:30:15 <mw_> data X = X .... deriving (Show, Eq, Ord...)
03:30:18 <orzo> it works through Generics + DefaultSignatures
03:30:47 <mw_> Still struggling to understand difference between two approaches to types:
03:30:51 <mw_> data Direction  = Direction Ordering deriving (Show, Eq)
03:31:08 <mw_> data NewClaim = NewClaim String Direction String
03:31:13 <mw_> or just data NewClaim = NewClaim String Ordering String
03:31:18 <orzo> you can already derive Generic and then people can make default signatures based on instances of Generic, and that would allow people to declare instances without defining any methods.  New ghc will let them say "deriving" instead
03:31:40 <mw_> the second NewClaim uses the existing "Ordering" type
03:31:46 <mw_> which seems simpler?
03:31:59 <mauke\> I'd define a completely new type
03:32:06 <mauke\> Ordering isn't a direction
03:32:09 <mw_> ok, but why?
03:32:20 <mauke\> it just feels semantically wrong
03:32:31 <mw_> mmmmmmmm.
03:32:50 <mauke\> e.g. if we have data Color = Red | Green | Blue
03:33:17 <mauke\> we could notice "hey, this type has three values! so it's isomorphic to Ordering"
03:33:22 <mauke\> but that's meaningless
03:33:37 <mw_> Ah!
03:33:38 <mauke\> we gain nothing by wrapping Ordering
03:33:40 <orzo> well he was using "<" and ">" symbols
03:34:12 <mauke\> orzo: as less-than/greater-than or as arrows? :-)
03:34:18 <mw_> LT and GT
03:34:20 <orzo> i don't know
03:34:40 <orzo> i guess as arrows
03:34:49 <mauke\> mw_: then why is it called Direction?
03:36:34 <mw_> We use it in the context of two treatments (and an outcome)
03:37:13 <mw_> So, WRT an outcome, T1 > T2, is a convenient shorthand for saying that the outcome (for some outcome) is better with T1 than with T2
03:37:41 <orzo> Ordering seems appropriate
03:38:18 <orzo> maybe you want an Ord instance for Treatment
03:38:33 <mw_> Agree - but I was wondering if there was an advantage to "wrapping" the Ordering in a new type, Direction
03:39:29 <AndChat277076> Korega!!!!watashino!!!!tamashisa!!!
03:39:29 <mw_> Ord instance is hard. Ordering is dependant on the outcome, and the evidence, so is inconsistent across outcomes and evidence
03:39:45 <AndChat277076> Ko..korewa?!
03:39:53 <AndChat277076> nanda
03:40:03 <orzo> the advantage of wrapping is that it makes it more significant when you write functions that act on the type, that you are meaning the functions only in this particular context, not as some kind of generally useful operations on the Ordering type
03:40:16 <AndChat277076> youmu chan kawa E
03:40:23 <orzo> in this case, i would not wrap
03:40:30 <AndChat277076> Mudamuda
03:40:32 <orzo> i'm only trying to answer the question which i think is more general
03:40:48 <mw_> Ok, thanks. Will leave it unwrapped for now
03:42:46 <mw_> If writing record syntax, with multiple constructors, will the derived typeclasses apply to both Constructors (assume so, as the typeclasses apply to the type..)?
03:42:48 <mw_> e.g.
03:42:49 <mw_> data Arg = IndArg {evidence :: Evidence, claim :: Claim} | MetaArg {evidence :: Evidence} deriving (Show, Eq)
03:43:13 <orzo> the deriving applies to the entire type, yes
03:44:25 <mauke\> this works basically like: data Arg = IndArg Evidence Claim | MetaArg Evidence deriving (Show, Eq)
03:44:54 <mauke\> evidence (IndArg x _) = x; evidence (MetaArg x) = x; claim (IndArg _ y) = y; claim _ = error ":-("
03:46:12 <mw_> Can two different types have the same field names (using record syntax)?
03:46:22 <orzo> no
03:46:39 <mw_> Ah. So this throws an error:
03:46:41 <mw_> data Arg = IndArg {evidence :: Evidence, claim :: Claim} | MetaArg {evidence :: Evidence} deriving (Show, Eq)
03:46:41 <mw_> data NewArg = NewIndArg {evidence :: Evidence, claim :: NewClaim} | NewMetaArg {evidence :: Evidence} deriving (Show, Eq)
03:46:56 <orzo> yes
03:47:04 <mw_> Hmmmmm.
03:47:19 <bluebruh> u guys read this
03:47:20 <bluebruh> https://status.haskell.org/
03:47:21 <orzo> could mangle the names, aEvicence and naEvidence
03:47:30 <mw_> Yes, but messy
03:47:42 <Walther> So - deb.haskell.org was breached, any info if a) malicious packages have been spread b) the signing key has been leaked? https://news.ycombinator.com/item?id=9054795
03:47:57 <bluebruh> Security Breach
03:47:57 <bluebruh> Security Breach
03:47:57 <bluebruh> ya walther
03:48:42 <Walther> bluebruh: yes on which one or both?
03:49:36 <Walther> I read that there has been "a security breach", but I'm interested to know if there's been malicious packages spreading and/or if the signing key has been stolen (and hence endless amounts of malicious packages could be spread later)
03:50:01 <bluebruh> "Security BreachSecurity Breach
03:50:01 <bluebruh> Security Breach
03:50:01 <bluebruh> Security Breach
03:50:01 <bluebruh> Security Breach
03:50:01 <bluebruh> Security Breach
03:50:01 <bluebruh> Security Breach
03:50:01 <bluebruh>  `deb.haskell.org` is currently offline due to our hosting provider suspecting malicious activity. We're working on getting it back.
03:51:04 * marienz thwaps idoru
03:51:31 <marienz> (unklined, if that was considered too spammy by this channel's standards please set a ban/quiet)
03:52:06 <tomphreek> @src msum
03:52:07 <lambdabot> msum = foldr mplus mzero
03:54:59 <Walther> So - deb.haskell.org was breached, any info if a) malicious packages have been spread b) the signing key has been leaked? https://news.ycombinator.com/item?id=9054795
03:56:04 <adamse> Walther: ask in #haskell-infrastructure
03:56:15 <Walther> ok, thanks
03:56:56 <adamse> from the discussions I've seen there has been no indication of leaking any keys
03:58:29 <Walther> "no indication of leaking" is kinda dodgy though, if the attackers have had read/write access to the server, they could've copied the key without a trace
03:59:11 <ibid> depends on whether the signing key was in the server
03:59:55 <mw_> How do I use Cabal to install the Data package?
04:00:05 <mw_> Tried cabal install Data....
04:00:18 <mpickering> What are you trying to do?
04:00:46 <merijn> mw_: What do you mean "data package"?
04:00:56 <merijn> There is not Data package on hackage...
04:01:02 <mniip> there's not a data packahgre
04:01:06 <mniip> package
04:01:17 <mw_> Trying to install this: http://hackage.haskell.org/package/MissingH-1.2.1.0/docs/Data-CSV.html
04:01:25 <yac> cabal install MissingH
04:01:29 <mniip> the package is MissingH
04:01:35 <mniip> Data.CSV is a module
04:01:38 <mw_> aargh!
04:02:04 <mw_> Is "MissingH" all the things H is missing?
04:02:29 <bennofs> mw_: it's just the package that contains the Data.CSV module
04:02:52 <bennofs> mw_: you can see if you click the "Contents" link in the top left on the site you linked
04:03:15 <mw_> Yes - lots of things
04:03:23 <merijn> bennofs: Don't you mean top right?
04:03:32 <bennofs> oh right
04:04:19 <mw_> The Data.CSV example (at http://hackage.haskell.org/package/MissingH-1.2.1.0/docs/Data-CSV.html)
04:04:27 <mw_> gives an example
04:04:40 <mw_> import Text.ParserCombinators.Parsec
04:04:40 <mw_>  import Data.String.CSV
04:05:24 <mw_> I get "Could not find module `Data.String.CSV'
04:05:24 <mw_> "
04:05:54 <bennofs> mw_: the example seems to be wrong, you should probably use Data.CSV instead of Data.String.CSV
04:06:23 <mw_> Perfect - thanks
04:09:23 <zipper> How can I represent a map in a yesod model?
04:15:35 <mniip> where can I read about the complexity of arithmetic operations on the Integer type?
04:16:26 <merijn> mniip: Integer is a very tight wrapper around gmp
04:16:34 <merijn> mniip: So basically "whatever gmp's complexity is"
04:17:41 <merijn> mniip: In fact, GHC has one of the most efficient gmp wrappings around: http://www.wilfred.me.uk/blog/2014/10/20/the-fastest-bigint-in-the-west/
04:20:19 <zipper> How can I represent `PersistMap [(Text, PersistValue)] :: PersistValue` in a yesod  models file?
04:20:41 <mniip> merijn, I don't see anything related to complexity in GMP manuals
04:21:06 * hackagebot Fungi 1.0.5 - Funge-98 interpreter written in Haskell  http://hackage.haskell.org/package/Fungi-1.0.5 (ThomasEding)
04:26:30 <dramforever> merijn: In other languages like C++ or Java hand-written special functions are usually faster than generic libraries. In Haskell, more than often, libraries are faster
04:29:45 <merijn> mniip: Is there any specific reason you want to know? You might have to ask the GMP people
04:30:19 <mniip> trying to predict how much time will an operation take
04:30:20 <zipper> What do you people do when you have an issue and nobody seems to know the answer?
04:30:37 <dramforever> zipper: ask more people
04:30:45 <zipper> dramforever: Where?
04:30:50 <merijn> zipper: StackOverflow/haskell-cafe
04:30:51 <bennofs> zipper: maybe an ML?
04:30:53 <zipper> I'm thinking of never using yesod again. Getting help is almost impossible
04:30:59 <dramforever> zipper: what kind of issue?
04:31:05 <dramforever> oh
04:31:12 <zipper> and the yesod book has info that is hard to transfer to the scaffolded site.
04:31:16 <merijn> zipper: #yesod ?
04:31:23 <zipper> bennofs: ML people use yesod?
04:31:39 <merijn> zipper: Snoyman is really active on the mailing list
04:31:42 <zipper> merijn: Yeah that channel is almost dead
04:31:42 <merijn> zipper: ML = mailing list
04:32:05 <zipper> I guess I'll try the mailing list.
04:32:09 <merijn> zipper: Snoyman (like Tekmo) is too busy to hangout on IRC, but their respective mailing lists are really active and responsive
04:32:21 <merijn> I've seen really elaborate examples on each
04:32:31 <zipper> merijn: Thanks
04:32:31 <quchen2_> I miss Tekmo on IRC.
04:32:39 <merijn> quchen2_: He still comes here occasionally
04:32:41 <quchen2_> He used to be around a lot before Twitter happened.
04:32:44 * dramforever thinks that maybe he should use email more and IRC less
04:32:46 <zipper> Who is Tekmo?
04:32:52 <dramforever> to save time
04:32:54 <quchen2_> Gabriel Gonzalez aka "Pipes guy"
04:32:56 <bennofs> zipper: the one who wrote pipes
04:32:56 <merijn> quchen2_: When he has a question he hangs out here for a few hours after to answer questions
04:32:59 <zipper> Oh
04:33:08 <merijn> Also, the guy writing haskellforall.com
04:33:11 <zipper> He was also on the haskell cast
04:34:01 <zipper> quchen2_: Ha I could just ask Snoyman on twitter come to think of it.
04:34:39 <quchen2_> It's nice that some less busy people are still on IRC, like Edward for example.
04:35:05 <merijn> ha
04:35:11 <merijn> edwardk not busy :p
04:35:26 <merijn> He just doesn't sleep and answers questions while he waits for his code to compile :p
04:35:51 <quchen2_> He probably built a machine that explains things on IRC as part of its free theorem.
04:37:03 <dramforever> quchen2_: Isn't the "did you get it?" problem undecidable?
04:37:25 <bennofs> seems machines can handle IRC better than pipes or conduit
04:38:12 <quchen2_> dramforever: undecidability is only a problem if you don't have an oracle
04:38:32 <quchen2_> Up to oracle undecidability ;-)
04:39:11 <gfixler1> http://apfelmus.nfshost.com/articles/monoid-fingertree.html
04:39:40 <gfixler1> Anyone know what's going on with Foo in that Priority instance of Measured?
04:39:48 <gfixler1> where did it come from?
04:40:12 <dramforever> quchen2_: no, IMHO even with the "new multitenant architecture" in 12c it still can't solve undecidable problems https://www.oracle.com/database/index.html
04:41:09 <bennofs> dramforever: that is the wrong oracle. https://hackage.haskell.org/package/shake-0.14.3/docs/Development-Shake.html#g:11
05:06:07 * hackagebot uni-events 2.2.2.0 - Event handling for the uniform workbench  http://hackage.haskell.org/package/uni-events-2.2.2.0 (ChristianMaeder)
05:12:39 <MagBo> Hey, people, I wonder if anybody knows how should I reference dmbarbour (the person behind VCache)?
05:13:09 <MagBo> Oh, nvm, I'll just write David Barbour, his name is at his Github profile :D
05:20:14 <fuzzy_id> is it possible to pattern match a record field in a case expression?
05:20:41 <fuzzy_id> something in the spirit of: `Right (r {rspCode = (4,0,4)}) -> undefined`
05:22:35 <quchen2> Have you tried doing it?
05:23:02 <fuzzy_id> returns a Parse error in pattern blahblah
05:23:40 <quchen2> The issue is with the "r" I think, you have to specify the data constructor you're matching
05:25:49 <merijn> fuzzy_id: You have to specify the constructor
05:28:56 <fuzzy_id> ok, thanks
05:30:36 <rui> Ok, I failed last night in installing vty (required by Yi, which is what I really wanted to install)
05:30:48 <rui> Here is the output from cabal install vty http://lpaste.net/120602
05:31:16 <rui> It seems it can't find references of some terminfo package
05:31:29 <mauke\> hmm. those are curses functions
05:31:58 <merijn> Are you sure? vty doesn't uses ncurses
05:32:09 <merijn> Looks more like terminfo stuff, no?
05:32:18 <mauke\> you think there's a difference?
05:32:40 <mauke\> http://linux.die.net/man/3/setupterm
05:32:54 <mauke\> the synopsis says to include both <curses.h> and <term.h>
05:32:57 <merijn> mauke\: I don't use linux, so yes
05:33:31 <mauke\> rui: what OS/distribution?
05:33:42 <rui> I might have a mixture of stuff installed with yum and with cabal.I don't mind deleting everything all packaga databases and starting from scratch if that simplifies things (and if its possible). I am new so I wouldn't lose much
05:33:46 <rui> mauke\ Fedora
05:33:48 <rui> 20
05:34:15 <merijn> rui: Ok, unrelatedly to your question: Never mix cabal and OS package manager installs
05:34:27 <mauke\> merijn: ooh, what do you use?
05:34:30 <merijn> rui: Things like yum/apt are well known to screw with cabal's database consistency
05:34:44 <mauke\> rui: do you have ncurses-devel installed?
05:35:25 <merijn> mauke\: Last time I used vty FreeBSD, although setupterm seems to use curses.h there too, which is odd because vty never required linking to ncurses when I used it
05:35:34 <merijn> Hell, that was it's selling point, not needing ncurses
05:35:52 <rui> merijn, it all started with a yum cabal install and yum haskell-platform install. Not sure how to undo that :P
05:37:31 <bennofs> Is sizeOf _ = 0 allowed for storable instances?
05:37:40 <merijn> bennofs: No, because that makes no sense
05:38:03 <merijn> rui: It's ok to first only use yum and then only use cabal, IF you never use yum after using cabal
05:38:04 <rui> mauke\ Just ncurses.x86_64, through yum
05:38:13 <bennofs> merijn: you could do instance Storable () where sizeOf _ = 0; poke _ _ = return (); peek _ = return ()
05:38:25 <rui> merijn. And if I did, is there an easy way to start from scratch?
05:38:26 <merijn> bennofs: Storable () makes no sense either
05:38:52 <merijn> rui: Nuke ~/.ghc and then follow those restrictions ;)
05:38:57 <geekosaur> terminfo was always part of a curses package. original curses was based on a separate term*cap* library; ncurses originated as System V curses + terminfo for BSD (curses/termcap) systems
05:39:00 <geekosaur> and that all was long enough ago that I am surprised it's an issue; practically, curses is ncurses and terminfo is ncurses, unless you're on solaris for some odd reason
05:39:01 <quchen2> merijn: Why not? Binary () makes sense as well
05:39:09 <merijn> Or better: http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
05:39:16 <mauke\> rui: ok, then ncurses-devel is the first thing I'd try to install
05:39:18 <geekosaur> 'merijn, the selling pont was not the horrid curses API. still need it for basic terminal access
05:39:54 <merijn> geekosaur: For me it was lack of ncurses so I could use it more easily cross platform. Anyway, seems it has depended on ncurses since 3.1, so...
05:40:15 <merijn> quchen2: ok, right, but then "sizeOf _ = 0" still makes no sense
05:40:18 <rui> mauke\ I could do that with yum, but cabal doesn't seem to find it
05:40:24 <merijn> quchen2: Should be at least "sizeOf _ = 1"
05:40:27 <mauke\> rui: it's not a haskell library
05:40:52 <rui> mauke\ so now its fine to use yum. Ok, on it, thanks
05:41:15 <mauke\> yes, for non-haskell packages you have no choice :-)
05:41:21 <rui> merijn. If installing ncurses-devel fails, I will rm -rf ~/.ghc :P
05:41:35 <quchen2> merijn: That would mean that () takes one byte when stored. But since it can be stored using no space at all (and reconstructed by its type alone), 0 seems sensible to me
05:41:41 <rui> mauke\ installed, and nothing changed
05:41:45 <mauke\> :-(
05:41:51 <mauke\> something's fucky
05:42:02 <rui> rm -rf ~/.ghc in 3, 2,...
05:42:19 <quchen2> Maybe also remove ~/.cabal for good measure
05:42:23 <quchen2> Or at least parts of it
05:42:31 <quchen2> (e.g. not your config)
05:42:49 <rui> quchen2 my config is default, I never got in  yet, so
05:43:18 <rui> both are gone
05:43:54 <rui> quchen2
05:44:04 <rui> I had my cabal executable inside .cabal
05:44:21 <rui> Well, the one that installed with cabal install cabal. The yum one I have, but it was an older version
05:44:44 <quchen2> rui: Then run that one again with "update" and then install "cabal-install" with it again
05:45:12 <quchen2> And get yourself a "trash" command to use instead of "rm" :-P
05:45:26 <rui> quchen2 I actually renamed to .cabalBck
05:45:27 <rui> :)
05:45:48 <rui> Got scared before pressing enter to rm -rf
05:46:26 <RaceCondition> I have this extremely simple project in a Cabal sandbox https://github.com/eallik/mergesort to get started with QuickCheck; cabal build works fine but cabal test gives me this linker error: https://github.com/eallik/mergesort/blob/master/erroroutput.txt
05:47:23 <mauke\> hmm. terminfo could be built on top of unibilium instead of ncurses
05:50:03 <bennofs> RaceCondition: try adding other-modules: TestProperties to your test suite section in the cabal file
05:52:56 <RaceCondition> bennofs: that did work!
05:53:41 <RaceCondition> how come cabal isn't "properly" finding the issue though? as a beginner, it's extremely frustrating to have this sort of complexity in the basic automation tools
05:53:57 <rui> (cabal install vty now is installing its dependencies. For now, no problems)
05:54:20 <RaceCondition> are there any higher level tools built on top of cabal I should use instead?
05:54:57 <tasker> which kinds of problem is gpu computing suited for ?
05:55:18 <bennofs> RaceCondition: i don't think so. you could report a cabal install bug (https://github.com/haskell/cabal)
05:55:48 <RaceCondition> bennofs: so this *should* be considered a bug? albeit a usability on perhaps?
05:55:49 <bennofs> RaceCondition: the problem is that cabal doesn't know about module dependencies I think
05:56:07 <bennofs> RaceCondition: I'd say the error message can be improved at the very least
05:56:35 <rui> ...and I got the same errors in the end
05:57:32 <bennofs> For example, cabal could print a note about checking other-modules when cabal encounters a linker error. (not the best fix, but easy to implement)
05:57:47 <blackdog> yeah, that one's a really common trap
05:59:12 <RaceCondition> bennofs: done: https://github.com/haskell/cabal/issues/2419
06:00:28 <rui> tasker, I am no expert, but I think, those which can be implemented with lots of flat data parallelism, with a high ratio of arithmetic intensity versus memory transfer between CPU and GPu
06:01:11 <hodapp> rui: CUDA's documentation does indeed explicitly say that it is suited to a high arithmetic intensity.
06:01:37 <tasker> Right, this is kinda what I thought. I'll have a read of the cuda docs.
06:02:03 <hodapp> Flat data parallelism is important, but CUDA's basic unit of execution is 8 or 16 threads wide
06:02:40 <hodapp> and if you branch, then every thread runs every branch, but the outputs of threads on the 'inactive' branch are masked off
06:02:43 <rui> tasker, its like a faraway basement where 999999999 slow-working oompa-loompas are waiting for your commands
06:02:57 <tasker> Hah :p
06:03:24 <hodapp> both global GPU memory and CPU memory are extremely slow to access
06:03:50 <hodapp> but each GPU processor has access to some working memory that is about as fast as cache (but is explicit to access)
06:04:32 <tasker> so do you tend to find massive cliff-like dropoffs in performance if you go over that cache /
06:04:33 <tasker> ?
06:04:39 <hodapp> it's not a cache
06:04:46 <hodapp> it's *as fast* as a cache, but you use it explicitly
06:05:08 <tasker> hm
06:05:20 <tasker> I think I should do some reading :p
06:05:33 <hodapp> so one usually tries to keep everything in that working memory, but if one must access GPU memory, coalesce the memory access so that adjacent threads access adjacent portions, and then it just does one giant 384-bit or 512-bit read at once, and while that's going on, the scheduler swaps in another 8 threads to do some actual computing
06:06:18 <hodapp> the memory buses on CUDA devices are stupid wide, but they have high latency (300-400 cycles I think)
06:06:27 <hodapp> compared with working memory access or a float divide in 1-2 cycles
06:07:50 <hodapp> didn't Microsoft Research have a lovely paper on stream fusion or something, that covered one case of functional programming on a GPU?
06:08:18 <rui> Anyone has suggestions on what I could try next to get over the error that doesn't let me install vty?
06:09:01 <rui> I mean, failure to find terminfo stuff http://lpaste.net/120602
06:09:45 <rui> in Fedora 20, probably having mixed up yum and cabal instalations of stuff, just after reinstalling cabal, and with ncurses-devel installed
06:09:56 <hodapp> http://research.microsoft.com/en-us/um/people/simonpj/papers/ndp/haskell-beats-C.pdf there we go
06:10:21 <hodapp> tasker: give that paper a look, it's fairly short
06:10:30 <hodapp> also check out http://hackage.haskell.org/package/accelerate (though I've yet to use this)
06:10:41 <rui> (assume the error can be something stupid on my part, I am that new)
06:10:50 <tasker> hodapp: Thanks. I was reading throught the docs of accelerate, which is what prompted my question :)
06:11:06 <hodapp> tasker: have you use Accelerate yet? I'd like to mess with it.
06:11:09 <rui> hodapp Haskell beats C? That SPJ knows how to attract readers attention. I'm opening it
06:11:15 * hackagebot parsec1 1.0.0.6 - Portable monadic parser combinators  http://hackage.haskell.org/package/parsec1-1.0.0.6 (ChristianMaeder)
06:11:17 * hackagebot halma 0.1.0.0 - Library implementing Halma rules  http://hackage.haskell.org/package/halma-0.1.0.0 (TimBaumann)
06:11:20 <tasker> hodapp: No, though I have used repa.
06:11:23 <hodapp> repa?
06:11:33 <tasker> it seems to be a sister package to accelerate
06:11:34 <hodapp> I've only done GPU stuff via CUDA and GLSL, and the tiniest bit of OpenCL
06:11:40 <tasker> cpu based, not gpu
06:11:48 <tasker> but paralellised array operations
06:12:51 <ddellacosta> would someone mind taking a look at my BFS implementation and tell me what could be improved?  I think the biggest problem has to do with how I've structure the graph itself: https://gist.github.com/ddellacosta/341c5dc0f55c60b3c5f9
06:13:31 <ddellacosta> would love to figure out some good ways to structure graphs using immutable data structures
06:13:53 * ddellacosta goes to see if Okasaki has anything about that
06:21:15 * hackagebot parsec3 1.0.1.8 - Monadic parser combinators  http://hackage.haskell.org/package/parsec3-1.0.1.8 (ChristianMaeder)
06:22:02 <rui> \help
06:26:20 * hackagebot fwgl-glfw 0.1.0.3 - FWGL GLFW backend  http://hackage.haskell.org/package/fwgl-glfw-0.1.0.3 (ZioCrocifisso)
06:26:22 * hackagebot fwgl 0.1.0.3 - FRP 2D/3D game engine  http://hackage.haskell.org/package/fwgl-0.1.0.3 (ZioCrocifisso)
06:40:29 <tomphreek> > let f l@(x:xs) a = if a /= 3 then a:l else []; f [] _ = [] in foldl f [1] [2, 6, 5, 3, 7, 8]
06:40:31 <lambdabot>  []
06:40:36 <tomphreek> > let f l@(x:xs) a = if a /= 3 then a:l else []; f [] _ = [] in foldl f [1] [2, undefined, 5, 3, 7, 8]
06:40:38 <lambdabot>  *Exception: Prelude.undefined
06:42:35 <rui> lambdabot runs stuff that start with > ?
06:42:43 <rui> [1..] !! 13
06:42:46 <tomphreek> how to "short-circuit" in the above example, so that once some condition on the accumulator is true foldl just returns the accumulator, skipping the rest of the list
06:42:47 <rui> > [1..] !! 13
06:42:48 <lambdabot>  14
06:42:51 <rui> Nice
06:43:42 <tomphreek> > let f l@(x:xs) a = if a /= 3 then a:l else []; f [] _ = [] in foldl f [1] [2, 2, 5, 3, undefined, 8]
06:43:43 <lambdabot>  []
06:45:06 <mauke\> you can't short-circuit foldl
06:45:12 <mauke\> @src foldl
06:45:12 <lambdabot> foldl f z []     = z
06:45:12 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:45:29 <mauke\> foldl always goes through the whole list, no matter what
06:49:48 <tomphreek> mauke\: does taht mean in the [2, 2, 5, 3, undefined, 8] example f ((f [] undefined) 8) was evaluated?
06:51:19 <quchen2> No, that doesn't mean foldl investigates the list's element values.
06:51:33 <quchen2> It just traverses the entire list.
06:52:07 <quchen2> > length (reverse [undefined, undefined, undefined] -- reverse = foldl (flip (:)) []
06:52:09 <lambdabot>  <hint>:1:83:
06:52:09 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
06:52:13 <quchen2> > length (reverse [undefined, undefined, undefined]) -- reverse = foldl (flip (:)) []
06:52:14 <lambdabot>  3
06:54:38 <tomphreek> ok, it's easy enough to short-circuit based on the list element satisfiying some condition, e.g.
06:54:56 <tomphreek> > foldr (||) False [Fasle, True, undefined]
06:54:57 <lambdabot>  Not in scope: data constructor ‘Fasle’
06:54:58 <lambdabot>  Perhaps you meant ‘False’ (imported from Data.Bool)
06:55:04 <tomphreek> > foldr (||) False [False, True, undefined]
06:55:06 <lambdabot>  True
06:55:36 <tomphreek> I don't quite see how to shortcircuit based on the accumulant satisfiying some condition
06:57:47 <mauke\> @src foldr
06:57:47 <lambdabot> foldr f z []     = z
06:57:47 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:57:54 <mauke\> foldr hands control over to f
06:58:10 <mauke\> if f doesn't use its second argument, the rest of the list is ignored
06:58:52 <gfixler1> so the short-circuiting is provided by (||) in this case
06:59:45 <gfixler1> @src (||)
06:59:45 <lambdabot> True  || _ =  True
06:59:45 <lambdabot> False || x =  x
07:00:06 <gfixler1> @src (&&)
07:00:06 <lambdabot> True  && x = x
07:00:06 <lambdabot> False && _ = False
07:00:11 <tomphreek> yeah I undersdand this
07:00:33 <tomphreek> I am trying to short circuit based on the accumulant, e.g. if sum is 10 then throw away the list
07:00:52 <gfixler1> tomphreek: sounds like you need a layer of indirection
07:00:59 <quchen2> foldr doesn't have an accumulant.
07:01:00 <gfixler1> a higher-order foldr
07:01:20 <quchen2> foldr has an element it investigates and the rest of the list it hasn't looked at yet.
07:03:16 <mauke\> an accumulator stores a record of the past. foldr gives you the future
07:04:21 <tomphreek> > let f l@(x:xs) a = if a /= 3 then a:l else []; f [] _ = [] in foldl f [1] [2, 2, 5, 3, undefined, 8]
07:04:22 <lambdabot>  []
07:04:34 <tomphreek> > let f l@(x:xs) a = if a /= 3 then a:l else []; f [] _ = [] in foldl f [1] (repeat 3)
07:06:54 <mauke\> what are you trying to do?
07:08:39 <quchen2> Aborting based on the past with foldr requires some trickery.
07:08:48 <quchen2> > let sumUntil n xs = let f x xs acc | acc >= n = acc | otherwise = xs (acc+x) in foldr f id xs 0 in sumUntil 11 [1..10]
07:08:49 <lambdabot>  15
07:09:24 <quchen2> This sums up all numbers until you've passed 11 as intermediate result, and then returns the sum (aborting early).
07:10:07 <quchen2> Learning how to implement foldl in terms of foldr is a good start to learning this. Then you can combine that idea to get a "foldl that aborts".
07:10:48 <quchen2> I like to call those kinds of folds "bouncy folds", and I've written a short introduction to them some time ago. https://github.com/quchen/articles/blob/master/useful_techniques.md#bouncy-folds
07:10:50 <tomphreek> mauke\: say I am picking up a list of min length in a very large list of lists. The accumulant is then current shortest list so far. However, I would be nice to break out on finding an empty list.
07:11:29 <mauke\> I'd do it manually
07:12:00 <bitemyapp> quchen2: thanks for posting this!
07:12:09 <quchen2> bitemyapp: ?
07:12:14 <quchen2> You mean the markdown file there?
07:13:05 <Welkin> tomphreek: you can use `guard` to do that
07:16:07 <bitemyapp> quchen2: yes
07:16:22 * hackagebot uni-htk 2.2.1.2 - Graphical User Interface for Haskell Programs  http://hackage.haskell.org/package/uni-htk-2.2.1.2 (ChristianMaeder)
07:16:24 * hackagebot uni-uDrawGraph 2.2.0.3 - Graphs binding  http://hackage.haskell.org/package/uni-uDrawGraph-2.2.0.3 (ChristianMaeder)
07:17:20 <mauke\> > let minlist ([] : _) = []; minlist (x : xs) = step (length x, x) xs where step (_, z) [] = z; step _ ([] : _) = []; step (n, z) (x : xs) = let m = length x in step (if m < n then (m, x) else (n, z)) xs in minlist (words "good evening ladies and gentlemen")
07:17:21 <lambdabot>  "and"
07:17:22 <mniip> why doesn't hoogle index ghc-api :|
07:17:52 <mauke\> > let minlist ([] : _) = []; minlist (x : xs) = step (length x, x) xs where step (_, z) [] = z; step _ ([] : _) = []; step (n, z) (x : xs) = let m = length x in step (if m < n then (m, x) else (n, z)) xs in minlist ("foobar" : "baz" : "" : undefined)
07:17:54 <lambdabot>  ""
07:18:58 <passwd> let minlist ([] : _) = []; minlist (x : xs) = step (length x, x) xs where step (_, z) [] = z; step _ ([] : _) = []; step (n, z) (x : xs) = let m = length x in step (if m < n then (m, x) else (n, z)) xs in minlist (words "good evening ladies and gentlemen")
07:27:50 <gfixler1> quchen2: so your bouncy fold find will actually return the last thing that matches the predicate, right?
07:27:59 <gfixler1> without short-circuiting
07:28:43 <quchen2> > let sumUntil n xs = let f x xs acc | acc >= n = acc | otherwise = xs (acc+x) in foldr f id xs 0 in sumUntil 11 [1..]
07:28:45 <lambdabot>  15
07:28:48 <quchen2> Short-circuiting.
07:30:17 <gfixler1> I mean the one in your github page
07:30:27 <gfixler1> find :: (a -> Bool) -> [a] -> Maybe a
07:30:49 <gfixler1> it carries the accumulator all the way, swapping it with any future matches
07:32:44 <quchen2> Let's find out
07:33:00 <quchen2> ?let find' p = foldr go Nothing where go x acc | p x = Just x | otherwise = acc
07:33:01 <lambdabot>  Defined.
07:33:14 <quchen2> > find' even [1..]
07:33:16 <lambdabot>  Just 2
07:33:28 <quchen2> Short-circuits as well.
07:33:58 <gfixler1> I'm not seeing how/where
07:34:51 <gfixler1> foldr starts with Nothing, then keeps accepting an x and running the predicate on it
07:35:20 <gfixler1> Just 2 should go in as the next acc, and then it should try x=3, and keep Just 2
07:35:22 <quchen2> No, foldr doesn't start with Nothing. It starts with the head of the list.
07:35:26 <quchen2> ?src foldr
07:35:26 <lambdabot> foldr f z []     = z
07:35:26 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:35:31 <gfixler1> then it should try x=4, which passes p x
07:35:31 <quchen2> z = Nothing in my case.
07:35:35 <gfixler1> so acc should now be Just 4
07:36:22 <quchen2> You can even have "undefined" instead of "Nothing" if you never reach it in your search.
07:36:22 <quchen2> ?undef
07:36:22 <lambdabot> Undefined.
07:36:37 <quchen2> ?let find' p = foldr go undefined where go x acc | p x = Just x | otherwise = acc
07:36:38 <lambdabot>  Defined.
07:36:43 <quchen2> > find' even [1..]
07:36:45 <lambdabot>  Just 2
07:36:56 <quchen2> But then
07:37:02 <Saizan> gfixler1: the 'z' in foldr is not really an accumulator, it's the base case of the recursion
07:37:04 <quchen2> > find' (> 20) [1..10] -- oops
07:37:07 <lambdabot>  *Exception: Prelude.undefined
07:37:19 <gfixler1> Saizan: right
07:37:52 <glguy> foldr starts applying the function from the beginning of the list, foldl from the end
07:37:58 <gfixler1> Why would Just x be a terminating condition, if acc isn't?
07:38:42 <quchen2> I should have named it "rest" instead of "acc".
07:38:47 <Saizan> gfixler1: with lazy evaluation, if the go function doesn't use its second argument the recursive call to foldr never gets forced
07:38:47 <quchen2> There's nothing being accumulated here.
07:38:55 <gfixler1> I know
07:39:12 <gfixler1> if px, then Just x, otherwise acc
07:39:22 <gfixler1> but Just x and acc are the same thing - they're just values
07:39:31 <gfixler1> why would foldr exit on Just x
07:39:46 <gfixler1> why would it return Just 2, and not keep swapping for each even until the last one?
07:40:24 <gfixler1> are my questions even making sense?
07:41:10 <quchen2> The "Just x" branch ignores the "acc" completely
07:41:14 <quchen2> ?src foldr
07:41:14 <lambdabot> foldr f z []     = z
07:41:14 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:41:15 <solarus> gfixler1: look at the definition of foldr above and in the second case substitute f for go
07:41:22 <solarus> it should be clearer
07:41:34 <quchen2> So the "f" here ignores its second argument, which is what I stupidly called "acc" before
07:41:40 <bennofs> gfixler1: find even [2..] = foldr go Nothing [2..] = go 2 (foldr go Nothing [3..]) = Just 2
07:41:50 <bennofs> (where go is the one from find)
07:41:52 <quchen2> Hence the "f x something" evaluates without looking at the rest of the fold
07:45:22 <mseeks> I have a few TVars containing maps and lists and such which are accessed concurrently and i want to persist their contents in a simple key-val store; any recommendations? I looked at acid-state but it doesn't seem like it's possible to compose updates to different resources atomically
07:46:02 <mseeks> e.g., remove an item from resource A and add it to resource B atomically, where A and B are acid-state resources
07:49:04 <mseeks> hm TCache seems like it might do the job
07:49:27 <quchen2> forever (atomically (readTVar x) >> \val -> store val)?
07:50:01 <quchen2> or takeTVar or takeTMVar or whichever is the one that blocks
07:52:31 <mseeks> cool I didn't think of that
07:56:24 * hackagebot derive 2.5.21 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.5.21 (NeilMitchell)
08:07:16 <tasker> are : and ++ equivilant in complexity for lists ?
08:07:36 <geekosaur> no
08:07:55 <hpc> they're quite different functions
08:08:01 <geekosaur> : just tacks a cons sell in front, O(1). ++ when forced must traverse the entirety of the list on the left
08:08:20 <geekosaur> (remember haskell lists are lisp cons cells, not C arrays)
08:09:22 <tasker> Ah, I thought this was the case. Thanks.
08:09:22 <mada> what is a 'natural map'?
08:09:38 <quchen2> mada: As in "natural transformation"?
08:10:06 <mada> quchen2: as in 'the free theorem for fmap' - edward kmett
08:10:32 <mada> quchen2: seems I'm more than a few steps away from grokking what's going on in there
08:11:45 <quchen2> Without more context it's hard to find out where the problem is exactly.
08:12:12 <coltfred> he's talking about https://www.fpcomplete.com/user/edwardk/snippets/fmap
08:13:10 <quchen2> Hm, I wrote the same article a year ago or so, and deleted it since then because I think it's wrong.
08:13:20 <quchen2> Now Edward posts something very similar and I'm confused again.
08:14:16 <mada> quchen2: sorry, I meant in the context of what coltfred linked.
08:14:48 <nshepperd> I think it would be maybe more accurate to say that (a ++ b) adds a constant overhead to evaluation of the first |a| items of the result, because it's still lazy
08:15:05 <mada> but going over what's linked in the reddit thread + links in those places, I see this is out of my reach atm.
08:15:48 <nshepperd> or, it will have traversed the entire list on the left, by the time you've traversed the first |a| items of the result
08:16:06 <coltfred> quchen2: Kmett isn't immune to being wrong, though I haven't seen it happen on topics such as these. :)
08:16:32 <quchen2> I thought the free theorem requires F to be a Functor in the first place, so the reasoning is circular.
08:16:52 <quchen2> So "if F is Functor then we can use the free theorem to prove that the second Functor law is a consequence of the first".
08:17:07 <quchen2> But since F is Functor in the first place, why bother with the rest?
08:17:23 <coltfred> "This is a free theorem, so it holds for any function with the same type signature as fmap, regardless of implementation."
08:17:25 <mauke\> @free blah :: (a -> b) -> X a -> X b
08:17:25 <lambdabot> g . h = k . f => $map_X g . blah h = blah k . $map_X f
08:17:32 <mauke\> no Functor
08:17:38 <coltfred> I think he's arguing that you can get it no matter if it's a funtor or not.
08:17:45 <coltfred> "regardless of implementation"
08:19:27 <HeladoDeBrownie> probably a good idea to read the theorems for free paper
08:23:16 <nshepperd> the comment thread with 'Pseudonym' on that snippet seems to address that objection
08:23:54 <nshepperd> 'So the "proof" is partly circular. What you've actually shown is that if F has a "natural map", then any non-pathological function <tt>f :: (a -> b) -> (F a -> F b)</tt> which satisfies <tt>f id = id</tt> is that natural map.'
08:24:36 <myfreeweb> the "c" in "O(c)" for Data.Text.Lazy.fromStrict means "chunks," right?
08:25:50 <lifter> If I want to use the option to unbox strict fields, do I need to put "OPTIONS_GHC -funbox-strict-fields" at the top of every module, or just in the module where my types with strictness annotations are defined? Anybody know?
08:25:51 <LordBrain> what is the tt tag?
08:26:30 <LordBrain> which markup language did you borrow that from?
08:26:33 <tomphreek> quchen2: sounds like using your SumUtil I could generalise it to have breakFoldr function. Is my situation that rare? Feels like I am reimplementing break.
08:27:20 <LordBrain> nvm
08:27:53 <nshepperd> to which, as far as I can tell, edwardk replied that for haskell types, either F has such a "natural map" or you can't build your "(a -> b) -> F a -> F b" function in the first place
08:28:06 <mauke\> https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tt
08:31:06 <hakujin_> lifter: you can add it to ghc-options: in your .cabal file
08:31:10 <tomphreek> mauke\: I thought there would be a more idiomatic way so that a reader could instantly recognise familiar foldr with a break predicate.
08:31:43 <lifter> hakujin: that's a good idea, thanks
08:32:50 <int-e> Does anyone know how to contact mokus (lambabot maintainer)? The deepbondi.net mailserver DNS entries seem to be misconfigured...
08:33:50 <gfixler1> solarus: foldr expands out as f 1 (f 2 (... (f z [])...)), right?
08:34:26 <gfixler1> quchen2's find thus expands out to f 1 (f 2 (f 3 (f 4 go Nothing [])))
08:34:41 <nshepperd> tomphreek: some kind of foldM?
08:34:44 <gfixler1> for find f [1,2,3,4]
08:35:05 <gfixler1> I guess the parens have me feeling that f 4 go Nothing happens first
08:35:22 <gfixler1> which is sort of what I was saying earlier - that it keeps replacing things
08:35:32 <gfixler1> except I wasn't thinking of it as 'from the right' earlier
08:35:50 <gfixler1> so if it evals from the left, f 1 (etc...) could short-circuit if 1 matches
08:36:10 <gfixler1> but if it evals from the right, it would keep replacing matches
08:36:47 <gfixler1> and the last replacement would be the first match, which would appear to be a short-circuit
08:37:02 <gfixler1> this is what I'm confused about, and it's hard to test in a pure foldr
08:37:51 <nshepperd> > foldM (\a x -> (if (a + x) < 10 then Right else Left) (a + x)) 0 [1,3..]
08:37:53 <lambdabot>  Left 16
08:38:30 <nshepperd> abusing the Either monad to do a "fold with break"
08:39:06 <nshepperd> Right z means 'keep computing with z', Left z means 'stop here and return z'
08:39:35 <hakujin> nshepperd: without the perf benefits of early termination
08:40:19 <nshepperd> no, it does terminate early, because (>>=) for Either shortcircuits
08:40:36 <asodij> is it possible to write an in-place quicksort in haskell?
08:40:37 <nshepperd> it works for infinite lists, for example
08:40:38 <byorgey> it does have the performance benefits.  Note nshepperd applied that to an infinite list.
08:40:40 <gfixler1> so does plain old regular foldr eval from left to right?
08:41:08 <hakujin> ?src foldM
08:41:09 <lambdabot> foldM _ a []     = return a
08:41:09 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
08:41:19 <byorgey> asodij: sure, but "in-place" implies mutable arrays so the code is not super pretty
08:41:19 <mniip> fax
08:41:20 <hakujin> oh my mistake
08:42:01 <asodij> byorgey: would you have to use some sort of ghc extensions/tricks or can it be done in regular haskell?
08:42:18 <byorgey> gfixler1: lazy evaulation means things are evaluated from the outside in.
08:42:20 <tomphreek> nshepperd: nice one
08:42:20 <mniip> you can use a list of IORef's
08:42:37 <gfixler1> byorgey: ah, finally - thanks!
08:42:42 <mniip> or MutableArray# but then the code becomes super not pretty
08:42:43 <byorgey> gfixler1: you can't say that foldr inherently evaluates in a particular order.
08:43:02 <gfixler1> byorgey: yeah, this high-level stuff is frustrating in that way, I'm learning
08:43:03 <byorgey> it depends on what you are folding.
08:43:30 <mniip> asodij, what are you trying to achieve
08:43:46 <byorgey> asodij: at some level it is going to require some special compiler support, but you as the programmer do not have to use any special extensions or tricks, you can just use a standard mutable array library
08:43:48 <asodij> mniip: just learning haskell
08:43:54 <gfixler1> I suppose I had my answer in the fact that foldr was used a moment ago on an infinite list
08:43:57 <mniip> then you don't need in-place sort
08:44:02 <asodij> byorgey: ah ok
08:44:05 <gfixler1> that wouldn't work if it always had to eval from the inside out
08:44:08 <bananagram> ?src (+)
08:44:08 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
08:44:11 <bananagram> ?src (++)
08:44:11 <lambdabot> []     ++ ys = ys
08:44:11 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
08:44:11 <lambdabot> -- OR
08:44:11 <lambdabot> xs ++ ys = foldr (:) ys xs
08:44:21 <byorgey> gfixler1: indeed
08:45:33 <LordBrain> why do academic papers prefer latex and pdf, nowadays you'd think some kind of hyperlinked system would be popular... Where i could hover my mouse over a term and get a referenced definition  even if it is not in the paper.
08:45:58 <rom1504> because you can print it
08:46:05 <rom1504> that's about it
08:46:19 <tomphreek> cuz that's how journals accept them
08:46:25 <rom1504> yeah
08:46:26 <LordBrain> well, the ebook format is based on html4 and i think it has fixed page sizes etc
08:46:48 <nshepperd> well, latex looks nice
08:47:22 <byorgey> latex is terrible.  It is also by far the best system there is for typesetting scientific/mathematical content.
08:47:28 <nshepperd> as in it's comfortable to read
08:47:37 <LordBrain> lol
08:47:38 <LordBrain> yeah
08:47:48 <nshepperd> html math sometimes makes my eyes bleed
08:47:57 <LordBrain> yeah, mathml... yucky
08:48:58 <mniip> asodij, IO-lessly speaking, in haskell there are no mutable variables, so you can't "sort in-place"
08:49:07 <LordBrain> I think the nicest thing is straight unicode with mono font (if that works for the purpsoe at hand)
08:49:25 <mniip> IO introduces IORef's, MVar's, TVar's, but since you're just learning I assume you don't want to deal with that
08:49:39 <wolf_mozart> add 4 5
08:49:58 <LordBrain> mnaser, sorting in place, you should think ST monad
08:50:06 <LordBrain> mniip, sorry tab complete error
08:50:14 <wolf_mozart> []add 4 5
08:50:25 <wolf_mozart> lol how do i call the bot here?
08:50:30 <gfixler1> > add 4 5
08:50:31 <mniip> > (+) 4 5
08:50:31 <lambdabot>  Not in scope: ‘add’
08:50:31 <lambdabot>  Perhaps you meant one of these:
08:50:31 <lambdabot>    ‘odd’ (imported from Prelude), ‘and’ (imported from Data.List),
08:50:33 <lambdabot>  9
08:50:51 <gfixler1> > it * 2
08:50:52 <lambdabot>  Not in scope: ‘it’
08:50:53 <lambdabot>  Perhaps you meant one of these:
08:50:53 <lambdabot>    ‘id’ (imported from Data.Function),
08:50:54 <wolf_mozart> i see
08:51:04 <geekosaur> lambdabot is not ghci
08:51:19 <wolf_mozart> so add doesnt work?
08:51:21 <wolf_mozart> :O
08:51:25 <LordBrain> geekosaur, do you run lambda bot?
08:51:31 <glguy> Also, #haskell is not ghci
08:51:49 <geekosaur> so "it" doesn't work
08:52:01 <geekosaur> no
08:52:02 <gfixler1> geekosaur: not a very good proof
08:52:08 <geekosaur> wat
08:52:23 <gfixler1> geekosaur: lambdabot could implement 'it' if it wanted to - I was just checking
08:52:48 <geekosaur> there was a time when it did.
08:52:49 <geekosaur> @v
08:52:49 <lambdabot> Exception: <<loop>>
08:52:54 <geekosaur> @v
08:52:54 <lambdabot> Exception: <<loop>>
08:53:03 <geekosaur> oh, broken. siiigh
08:53:16 <geekosaur> anyway people abused it to break lambdabot in fun ways
08:54:00 <geekosaur> no, it's still in there I see (in query). and I guess that does make sense as one of the things it produced...
08:54:13 <tomphreek> @hoogle Either a a -> a
08:54:15 <lambdabot> Data.Either rights :: [Either a b] -> [b]
08:54:15 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
08:54:15 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
08:54:36 <geekosaur> :t either
08:54:36 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
08:54:39 <int-e> @tell sclv yes I'm running lambdabot
08:54:39 <lambdabot> Consider it noted.
08:54:57 <geekosaur> otherwise use pattern matching
08:55:40 <sclv> ah, thanks. i was reaching out because there was a channel that lambdabot might be good for. but then I thought better of it, so no requests for now. good to know who's minding the store tho :-)
08:55:46 <tomphreek> > either id id (Right 4)
08:55:47 <lambdabot>  4
08:55:52 <tomphreek> geekosaur: thanks
09:07:12 <stryker> How come some libs have documentation on hackage but others doesn't?
09:09:07 <ChristianS> stryker: for now uploads, it may take a few days until docs are generated, iirc
09:09:09 <tommd> stryker: There was a time when hackage wasn't building haddocks due to the computational costs.
09:10:07 <tommd> stryker: So some might be due to that.  And yes, new packages dont' get documents generated immediately.  Finally, build failures means the docs don't get built.  Failures can result from some really innocuous things like a missing c library dependency.
09:11:06 <glguy> stryker: Are you interested in the topic in general or is there a particular package with missing docs you needed?
09:11:27 <stryker> i wanted to look into helm's documentation
09:11:37 <cow_2001> helm!
09:11:44 <cow_2001> it won't compile for me :(
09:33:50 --- mode: asimov.freenode.net set +o ChanServ
09:33:55 <zomg> but yeah I agree with thebnq and also my own experience is similar
09:33:55 <thebnq> jsys: also, it might be reassuring that the "laws" are so general that theres a lot of "monads" that you can't express in haskell
09:33:55 <jsys> zomg: general purpose is still some sort of purpose. Without solid examples, the purpose is.. no purpose
09:33:55 <zomg> I was quite confused with monads and all that but after I just started using them they slowly started making more sense
09:34:19 <jsys> zomg: but it's impossible to explain :P
09:34:36 <thebnq> jsys: i agree the simple examples aren't helpful; for me the first non trivial example was a parser monad :)
09:34:41 <stryker> are monads kind of like what Eq and Show are for types?
09:34:54 <jsys> thebnq: so how do you parse with parser monad
09:35:07 <thebnq> are you familiar with recursive decent parsing
09:35:12 <zomg> jsys: many of the explanations are obtuse and trivial yeah, best to just try and use them and see what happens
09:35:15 <geekosaur> monads are a pattern. it just ahppens to be a pattern that people are not accustomed to recognizing or thinking with
09:35:38 <dassouki_> As a python developer who does markov chain analysis, operations research, etc. I want to expand my programming horizon. I'm looking at HAskell and Octave, what are your thoughts? I mostly do GIS (geographic Information systems) and quiet happy wiht python but as I said, I'd like to expand my tools
09:35:58 <jsys> geekosaur: no pattern just sits midair without explanation why it deserves attention
09:37:07 <geekosaur> jsys: yes, that's the problem. how do you communicate a pattern that people have trouble recognizing as a pattern
09:37:21 <geekosaur> that is *why* there are so many confusing and often incorrect "monad tutorials" out there
09:37:35 <geekosaur> and why we tell people not to worry about monads
09:37:44 <geekosaur> if you figure out how to rewire the human brain, let us know
09:37:57 <voidzero> i figured that one out
09:38:17 <jsys> geekosaur: no that's not the problem
09:38:29 <jsys> geekosaur: I see the pattern. But I see no utility
09:38:31 <geekosaur> (or if you figure out something better than monads as a pattern that actually solves the problems that need to be solved. various things have been tried)
09:38:40 <zomg> yeah honestly I stopped caring about monads specifically
09:38:47 <jsys> geekosaur: what are the "problems"
09:38:48 <geekosaur> then I would argue that you have not seen the actual pattern
09:38:48 <zomg> I just thought about the actual implementations, eg Maybe and whatever
09:38:57 <geekosaur> just something that looks like a pattern but isn't the actual one
09:38:58 <zomg> but eventually the general idea became more clear :P
09:39:00 <jsys> geekosaur: you tell me what PROBLEMS is it solving
09:39:16 <jsys> The problem of...
09:39:19 <jsys> What.
09:39:28 <zomg> I think IO in a pure FP lang is one of them?
09:39:30 <geekosaur> representation of non-pure things like state and I/O in a pure language
09:39:44 <voidzero> i was going to say 'context'
09:39:53 <jsys> Let's not use monad abuses as an example
09:39:54 <geekosaur> basically "carrying a context around without having to do it by hand"
09:39:59 <geekosaur> wat
09:40:16 <jsys> zomg: you can shove IO in a FP in many ways, monad is just a random way of doing it
09:40:19 <geekosaur> ok, so you define the primary use as an abuse. you lose at step 1
09:40:26 <zomg> Wow
09:40:35 <pata> I've found this stackoverflow answer very helpful to “understand” monads: http://stackoverflow.com/a/28139260/4514511
09:40:37 <hiptobecubic> jsys, your questions are kind of too ignorant to be answered properly.
09:40:37 <zomg> You don't understand monads, yet you are very confident about them being an abuse
09:40:39 <thebnq> random? orderly*
09:40:49 <geekosaur> you can indeed shove it in, breaking pieces off everywhere
09:40:51 <voidzero> I'm with hiptobecubic
09:40:53 <cow_2001> dassouki_: #haskell-beginners topic
09:41:01 <zomg> I'm just going to back out of this conversation, it doesn't seem like there's any purpose for it
09:41:03 <hiptobecubic> jsys, it's like claiming that objects are stupid because you can just shove them into assembly whenever you want so why bother.
09:41:04 <zomg> :p
09:41:36 <cow_2001> dassouki_: it has a howto: learn haskell
09:41:45 <jsys> zomg: here's a way to do IO without monads in FP:     io(operation code, autoincrement unique operation id) -> operation result
09:41:54 <jsys> zomg: so there you go :P
09:42:07 <thebnq> jsys: no one said it was exclusive to IO
09:42:20 <jsys> thebnq: that's the Big Problem I'm told monads solve
09:42:25 <jsys> Give me another
09:42:26 <stepcut> has had several IO systems before the monadic solution got popular
09:42:42 <hiptobecubic> jsys, if you try to explain to someone why 'OOP' has classes and someone responds with "Who cares. You can just do everything in assembly or with for loops and goto" what are you supposed to say?
09:42:59 <voidzero> "okidoki"
09:43:06 <thebnq> jsys: you're looking too hard at "what it solves" as opposed to understanding what it is first
09:43:08 <eikke> :k [Tagged "a" ()]
09:43:09 <lambdabot> Not in scope: type constructor or class ‘Tagged’
09:43:26 <jsys> hiptobecubic: I can actually explain classes.
09:43:30 <thebnq> it doesn't solve anything in some sense, you're free to program in machine code
09:43:32 <hiptobecubic> What are people are saying here is that doing things monadically makes many problems much easier to think about. No one is claiming that monads are the only way to do IO.
09:43:47 <cow_2001> dassouki_: https://github.com/bitemyapp/learnhaskell http://bitemyapp.com/posts/2014-12-31-functional-education.html
09:43:54 <hiptobecubic> jsys, not if the other person dismisses them as "general purpose and therefore no purpose"
09:44:24 <hiptobecubic> Well you can still talk at them I guess. But it's useless and tiresome.
09:44:39 <Rotaerk> jsys, monads don't solve IO; they solve the problem of *chaining* IO.  you can write the hello world application without any monadic stuff
09:45:06 <jsys> hiptobecubic: no classes are not jus vaguely abstractly general purpose. They are a way to group your code according to purpose, to encapsulate some functionality, provide some surface, where the guts of the solution are more complicated (and protected) inside a class and exposed via a simple, stable interface. See?
09:45:17 <hiptobecubic> Rotaerk, jsys yes. They are one way to solve that problem, but that's not what they are *for*. That's just something they can be applied to.
09:45:24 <jsys> hiptobecubic: sure if someone said "oh classes are general purpose" I'd dismiss that explanation as useless
09:45:53 <hiptobecubic> jsys, you literally just described everything invented after subroutines were introduced to programming
09:46:59 <hiptobecubic> jsys, and you still haven't described a problem they solve.
09:47:10 <jsys> hiptobecubic: that's because it's all variations of the same thing. Subroutines, classes, namespaces, packages, domains, it's all a type of container. And as long as it provides visibility mechanisms and a way to expose a shared interface, the rest is just a detail.
09:48:03 <saep> Classes are a great way to obfuscate code. :-D
09:48:05 <zomg> jsys: your class description could be adjusted to monads. Monads are a way to group your code by interface, to provide a surface where the guts of the solution are more complicated inside the monad and exposed via a simple, stable interface
09:48:09 <zomg> :P
09:48:14 <jsys> saep: can't compare with monads
09:48:19 <hiptobecubic> jsys, and yet people consistently find objected oriented programming to be much more manageable than "giant collection of subroutines" so clearly you're missing some key points about the differences.
09:48:40 <jsys> zomg: yes, except classes don't mandate a specific interface and monads do.
09:49:01 <jsys> zomg: monads are a typeclass.
09:49:03 <voidzero> there's a point to be made about the mathematical reasoning behind / for monads, but i lack the vocabulary and probably the intellect.
09:49:04 <zomg> jsys: actually they do. `new Class()`, `instance.foo()` etc.
09:49:09 <jsys> zomg: and all typeclasses... are all typeclasses.
09:49:23 <Rotaerk> jsys, do you understand the purpose of an abstraction, such as typeclasses or interfaces?
09:49:59 <jsys> Rotaerk: I do. I'm not asking about why moands have structure. I'm asking why they have THAT structure
09:50:17 <zomg> Probably because math
09:50:20 <hiptobecubic> jsys, because it has proven very well suited to lots of problems?
09:50:22 <voidzero> yeah because math
09:50:37 <geekosaur> I would not claim because math
09:50:41 <Rotaerk> jsys, abstractions are developed by noticing recurring patterns in a lot of concrete cases
09:50:48 <voidzero> well ok, because category theory?
09:50:53 <geekosaur> if that were true then Monad would have join/fmap/return, not bind/return
09:50:56 <Rotaerk> without seeing all those concrete cases, the abstraction itself may feel arbitrary and contrived
09:50:58 <jsys> zomg: a method is a message send to an object. This goes back to what Alan Kay wrote about objects.
09:51:00 <Twey> jsys: A monad is a very general concept.  You can't solve all the problems you can solve with monads, without monads — what you *can* do is solve them with monads, but without *realizing* you are using monads.  The advantage of having a Monad *type class* to make it explicit when something is a monad is that there is a lot of useful code that can be written for *all monads*, and explicitly tagging monads
09:51:02 <Twey> as such means we can then automatically make use of all that code for our new monad with a minimum of effort.
09:51:08 <Rotaerk> so to understand monads, don't study the monad typeclass...
09:51:15 <Rotaerk> study the individual monadic types
09:51:20 <jsys> zomg: it's nothing more that an optimized message hook. I won't even defend it as anything more than an optimization
09:51:28 <geekosaur> (well, join and inherit fmap/return(pure) from Applicative)
09:51:34 <jsys> zomg: I won't pile theory on your or anything to justify it
09:52:03 <hiptobecubic> jsys, not to get into details here, but there is a distinction between "Alan Kay OOP" and OOP that everyone else is doing. Even Alan said so.
09:52:04 <voidzero> the wikipedia entry Category Theory pretty much describes g f x = f (g (x))
09:52:06 <zomg> jsys: technically new and the instance method call syntax and static method call syntax are an interface. You can define it in terms of a monad in Haskell and it looks similar
09:52:13 <jsys> Twey: this is still so generic as to apply to any word I could've picked to ask about
09:52:56 <LordBrain> I kinda think category theory should use a fliped compose operator
09:53:00 <Twey> jsys: Why they have that particular structure comes down to two things, one theoretical and one practical.  Theoretically: a monad is a concept known from category theory, which has many results about how it interacts with other things, so we know it's (in principle) useful and well-behaved.  Practically: a lot of things we do when programming turn out to be instances of monads.
09:53:03 <jsys> hiptobecubic: you're getting into details.
09:53:23 <zomg> jsys: you can use `new` with any class, you can use instance method syntax with any instance, you can use static method syntax with any class... just like monad functions are used with any monad. The abstraction level is actually somewhat similar on them I think
09:53:29 <Rotaerk> jsys, does what I suggested make sense?
09:53:31 <Twey> So we get a high utility-to-complexity ratio.
09:53:45 <Rotaerk> jsys, if you want to understand why they have the structure they do, go study the concrete monadic types
09:53:54 <Rotaerk> that'll at least give you an intuitive grasp
09:53:57 <jsys> Rotaerk: like what
09:54:03 <hiptobecubic> jsys, the point is that you are claiming everything is really the same thing because you're glossing over the differences as insignificant. Clearly they aren't insignificant, though because everyone is constantly discussing them.
09:54:05 <zomg> jsys: and in a sense the class interface has a set of laws, such as `new` will return an instance, and using instance method call syntax will make the `this` value point at a certain object etc.
09:54:33 <Rotaerk> jsys, https://hackage.haskell.org/package/base-4.7.0.2/docs/Control-Monad.html
09:54:48 <Rotaerk> jsys, look at all the types that are instances of Monad... and study how they behave
09:54:57 <jsys> Look, I'm asking what's the utility of a Monad is that so weird that you have to deflect it by turning this into a generic discussion about everything and nothing
09:55:10 <Twey> jsys: And yes, you're right.  These same arguments apply to most of the other type classes we have, too (though sometimes only the theoretical reason, or only the practical reason, applies).
09:55:15 <jsys> Can no one say in a couple of of sentences "monads are useful because"
09:55:24 <geekosaur> not when you deny every response, no
09:55:26 <zomg> You've been given several but you dismissed all of them
09:55:27 <zomg> lol
09:55:45 <geekosaur> if you don;t consider any use valid then of course to you there is no valid use.
09:55:53 <ReinH> jsys: Have you read Wadler's original monads for FP paper?
09:56:05 <arjen-jonathan> jsys: monads are useful because we like to wrap things into contexts (like maybe, lists, future, etc), but that makes function composition nasty. Thus we define bind, to composition functions on "wrapped things" or "things with context"
09:56:10 <geekosaur> it also strongly resembles talking to a young child in its "NO!" phase
09:56:20 <voidzero> ye
09:56:21 <LordBrain> I think we should be able to justify monads without referring to techncial papers
09:56:35 <ReinH> arjen-jonathan: (bind isn't a form of function composition, though)
09:56:45 <hiptobecubic> jsys, monads are useful because they make programming in haskell easier. Monads are useful because of all the reasons stated in all the papers published by algebraists that study them?
09:56:49 <Twey> s/function //
09:57:13 <ReinH> LordBrain: Er, Wadler's paper is one of the best explanations of and motivations of monads in FP that I've found.
09:57:21 <arjen-jonathan> ReinH: I disagree. bind is exactly that. Function composition taking into account a context.
09:57:22 <zerokarmaleft> LordBrain: Wadler's paper is highly readable
09:57:25 <jsys> arjen-jonathan: yes but aside from the common contexts (as you listed) what other contexts are there.
09:57:28 <Twey> LordBrain: It's not very technical
09:57:39 <zomg> I saw this conversation going nowhere from pretty much since the start
09:57:40 <ReinH> arjen-jonathan: No, bind is function *application* taking into account a context.
09:57:45 <ReinH> :t ($)
09:57:45 <lambdabot> (a -> b) -> a -> b
09:57:47 <ReinH> :t (=<<)
09:57:48 <lambdabot> Monad m => (a -> m b) -> m a -> m b
09:57:48 <jsys> I mean, defining a common interface for maybe and lists is kind of arbitrary. What do maybe and lists have in common? Nothing
09:57:49 <lightstep> jsys: the pattern of monads appear in many cases... when making parsing combinators, when doing non-deterministic programming, when defining logical circuits, when generating xml structures, etc. not all libraries for these use monads, but some do, and this is because it is a useful abstraction.
09:57:50 <LordBrain> i know, i'm just a little jaded from wading through funky undefined symbols in random papers
09:58:02 <zomg> I've become pretty good at detecting the type of people who start these conversations and then just spin an infinite web of nonsense and deflection
09:58:05 <zomg> :p
09:58:12 <ReinH> jsys: They have in common the fact that they are both functors, monads, and applicatives. Among other things.
09:58:22 <arjen-jonathan> ReinH: oke, sorry, one *uses* it for function composition in context
09:58:25 <ReinH> jsys: So definintely not "nothing".
09:58:36 <hiptobecubic> jsys, "nothing" is just flatly wrong. You really should just go read the billions of words written about them.
09:58:42 <thebnq> jsys: substitution over a syntax tree forms an interesting monad
09:58:44 <hiptobecubic> there's not really anything else for anyone here to say
09:58:47 <zomg> I said 20 minutes ago that this conversation isn't going anywhere =) Let's see if I'm wrong
09:58:52 <Rotaerk> <jsys> Look, I'm asking what's the utility of a Monad is that so weird that you have to deflect it by turning this into a generic discussion about everything and nothing
09:58:53 <Rotaerk> what?
09:58:58 <Rotaerk> how is what I said "about everything and nothing"?
09:59:08 <hiptobecubic> Rotaerk, it isn't. Go back to work.
09:59:11 <Rotaerk> I was talking about monads ... the topic of your discussion...
09:59:12 <ReinH> jsys: At this point I'm convinced that you aren't trying to have a good faith discussion here.
09:59:17 <phaul> After trying to optimize the brainf*ck code I linked on Saturday, I came to a conclusion that the state monad is just slow most of the time, building up the thunks.. There is the ST monad, but that doesn't play nicely with the transformers or the lens library.. Is this a known thing?
09:59:18 <Rotaerk> hiptobecubic, lol
09:59:36 <phaul> Is this a well known thing - or I'm doing something wrong?
09:59:44 <thebnq> phaul: there is a strict state monad
09:59:56 <hiptobecubic> phaul, make sure your state modifications are strict
09:59:57 <phaul> yes, but that's still not strict enough
10:00:15 <phaul> I mean >>= still builds thunks
10:00:17 <LordBrain> Lets say for a moment, you dismiss all other reasons stated jsys. Now consider this... they're a certain set form factor that is enforced in haskell. That alone is useful for the same reason simply having a standard is useful.
10:00:18 <ReinH> Maybe and List have a very fundamental structural similarity as well. Maybe is a container of 0 or 1 things. List is a container of 0 or more things.
10:00:19 <jsys> Ok, simple question. First law of Monads: return a >>= k  ==  k a
10:00:29 <hiptobecubic> jsys, that's not a question
10:00:40 <jsys> How is the Maybe monad following this when that's not true when "a" is nothing
10:00:54 <Rotaerk> jsys, the point is you won't understand monads just by having someone give you an answer; that's not how you gain understanding of something that's non-trivial
10:00:54 <jsys> hiptobecubic: there now you have a question
10:00:55 <Hijiri> a isn't nothing, it's the a in Maybe a
10:00:56 <ReinH> jsys: That doesn't even make sense.
10:01:04 <Rotaerk> so I was pointing you to a means by which you could gain this understanding
10:01:11 <jsys> Can someone answer thw question without talking down to me
10:01:16 <ReinH> jsys: The "a" wouldn't be Nothing.
10:01:30 <jsys> ReinH: what doesn't make sense more specifically
10:01:34 <Hijiri> jsys: if k :: c -> Maybe b, in this case a is type c
10:01:38 <ReinH> I just said what doesn't make sense.
10:01:47 <ReinH> jsys: Maybe you should also let people finish their statements.
10:02:00 <hiptobecubic> jsys, it sounds like you're mixed up between types and values.
10:02:11 <hiptobecubic> :t Nothing
10:02:12 <lambdabot> Maybe a
10:02:16 <hiptobecubic> There's the 'a'
10:02:17 <thebnq> phaul: not sure then, depends on what you're doing, need to profile :)
10:02:42 <hiptobecubic> :t Just 4
10:02:43 <lambdabot> Num a => Maybe a
10:04:00 <Hijiri> return Nothing >>= k = Just Nothing >>= k = case Just Nothing of {Nothing -> Nothing; Just x -> k x} = k Nothing
10:04:20 <jsys> So how do you create a Maybe monad holding nothing then
10:04:21 <ReinH> jsys: Do you actually think that no one would have noticed for 15 years that the Maybe monad violates the laws?
10:04:25 <Hijiri> so return Nothing >>= k is equivalent to k Nothing
10:04:26 <phaul> I think if you have whileM / recursion in a state monad, that would build up computiations for each level? as the monad bind is essentially building State \s -> ...
10:04:27 <ReinH> jsys: `Nothing'
10:04:40 <ReinH> Nothing is the data constructor for Nothing
10:04:44 <ReinH> > Nothing
10:04:46 <lambdabot>  Nothing
10:04:59 <jsys> That... is stupid.
10:05:09 <Hijiri> why is it stupid?
10:05:12 <ReinH> jsys: When you don't understand something, it's best not to pass judgement on whether or not it is stupid
10:05:25 <Rotaerk> black holes are stupid
10:05:29 <thebnq> might it help comparing it to a null pointer...
10:06:11 <ReinH> jsys: It's also best not to make a lot of statements about how that thing works and then ignore everyone when they explain that those statements are wrong
10:06:41 <tempname11_> hello #haskell. can anyone tell if there's a way to declare types inside a function definition, e.g. inside a 'let' or a 'where'? I have some code where the types are only useful inside a single function, and nowhere else, and I don't want to make them global.
10:06:55 <jsys> thebnq: I can't understand the benefit this over null pointers at all. This is even worse, it just ignores problems silently
10:07:02 <sinelaw> tempname11_, no, but you can use a module
10:07:04 <ReinH> jsys: Again, wrong.
10:07:15 <Rotaerk> jsys, I think maybe your misunderstanding with regards to Maybe and that first law is that "a" is the monadic value
10:07:16 <ReinH> This does the opposite of ignore problems silentely
10:07:23 <Hijiri> jsys: it's not silent, you have to deal with the Nothing case
10:07:26 <thebnq> jsys: do you understand what types are for
10:07:37 <jsys> Rotaerk: what's the monadic value of Nothing
10:07:47 <tempname11_> sinelaw: what do you mean?
10:07:48 <ReinH> jsys: What is a "monadic value"?
10:07:56 <Hijiri> Nothing is a monadic value
10:07:59 <ReinH> Ah. Rotaerk: what is a "monadic value"?
10:08:05 <Hijiri> at least how I've seen it used
10:08:07 <jsys> you guys don't agree about terms even amongst yourslves
10:08:11 <ReinH> A value of type m a for some Monad m?
10:08:14 <Rotaerk> ReinH, a value of a monadic type
10:08:18 <ReinH> Fair enough.
10:08:27 <ReinH> Nothing is a monadic value.
10:08:29 <stepcut> monads are dumb. All you need is a type 'Maybe a' and some helper functions like, toMaybe :: a -> Maybe a, flatten :: Maybe (Maybe a), and applyWhenJust :: (a -> b) -> Maybe a -> Maybe b. This monad stuff is nonsense!
10:08:39 <sinelaw> amongst ourselves? we are now a collective?
10:08:49 <jsys> if "a" is a monadic value, then   f(a) makes no sense.
10:08:58 <Hijiri> a isn't a monadic value
10:09:01 <zomg> Why are you even trying to learn it if you don't want to learn it
10:09:02 <zomg> lol
10:09:04 <Hijiri> if you mean the a in that law you posted
10:09:05 <sinelaw> tempname11_, you can declare a separate module, in which you define whatever types you want, with the accompanying functions. Then, you export from that module only the outside interface
10:09:09 <Rotaerk> jsys, within the context of the Maybe monad, the monadic values are Nothing or (Just something), return is defined to be return = Just
10:09:10 <Hijiri> it's not a monadic value in the type either
10:09:12 <jsys> It's the value inside the monadic value isn't it
10:09:12 <jsys> yes
10:09:15 <ReinH> jsys: Can you please try being less belligerent?
10:09:37 <ReinH> You are being rude to everyone.
10:09:38 <Hijiri> jsys: more or less
10:09:41 <Rotaerk> jsys, so in this:  return a >>= k  ==  k a
10:09:44 <LordBrain> he's not rude to me
10:09:48 <jsys> Rotaerk: why do people use "Just" here. What's the significance of that word
10:09:52 <Rotaerk> jsys, a is the "something" in "Just something"
10:09:54 <tempname11_> sinelaw: ah, ok. I guess I'll do that
10:09:55 * ReinH sighs
10:09:58 <sinelaw> tempname11_, module Stuff (exportedFunc) where  data InternalType = ....    exportedFunc =  ....
10:10:12 <Hijiri> jsys: Just is the constructor for Maybe a values that do contain an a
10:10:18 <LordBrain> its a data constructor jsys. data Maybe a = Nothing | Just a
10:10:34 <ReinH> LordBrain: give him time...
10:10:36 <Hijiri> if you want to know about the specific naming reason I'm guessing it was arbitrary
10:10:45 <thebnq> this discussion is pointless if he doesn't know what a "data constructor" is ...
10:10:49 <jsys> Haskell wasn't invented by English speaking people was it
10:10:52 <zomg> jsys: congratulations, so far you've managed to waste 30 minutes of several people's time while achieving absolutely nothing =)
10:10:58 <ReinH> Indeed
10:10:59 <zomg> What is your record?
10:11:00 <sinelaw> jsys, actually it was invented by mostly English people.
10:11:09 <Rotaerk> jsys, it's either Nothing, or "just" one value
10:11:10 <sinelaw> (or were they Scottish?)
10:11:28 <LordBrain> jsys, are you at least reading a tutorial somewhere?
10:11:31 <develop7> Hi all; quick question — does this http://lpaste.net/120607 mean cabal is unsatisfied with current version of ghc package?
10:11:42 <jsys> What about lists in context of monads
10:11:47 <zomg> LordBrain: He isn't, it was pretty obvious to me about 30 minutes ago
10:11:52 <jsys> you have one value to construct with, then what
10:11:57 <thebnq> lists are a terrible monad example, forget it
10:12:05 <jsys> What is the "monadic way" to add to that list. You can't
10:12:06 <dcoutts> develop7: not quite clear yet. "Backjump limit reached (change with --max-backjumps)."
10:12:17 <ReinH> jsys: Why do you think there shoud be one?
10:12:20 <zerokarmaleft> jsys: there are two data constructors for lists
10:12:22 <dcoutts> develop7: you can try --max-backjumps=-1
10:12:27 <Hijiri> jsys: monads are just a pattern, they don't do everything
10:12:28 <ReinH> jsys: And why do you think that you can't do that if you don't know what monads are?
10:12:29 <jsys> thebnq: ok fair. What's a good example (aside from Maybe)
10:12:43 <sinelaw> develop7, are you using ghc 7.10 by any chance?
10:12:53 <jsys> ReinH: cause monads are so universal they can open wormholes to another worlds
10:12:58 <Rotaerk> jsys, the return function of Monad is meant to produce a "trivial" monadic value.  in the case of Maybe, it just wraps the value in Just.  In the case of lists, it produces a list with just that value in it
10:13:00 <thebnq> jsys: i already suggested one , and i already suggested implementing it yourself to understand
10:13:04 <Hijiri> jsys: this is possibly over-simple, but do you know about Identity?
10:13:09 <develop7> dcoutts: trying
10:13:12 <ReinH> jsys: Are you trying to troll us now?
10:13:16 <develop7> sinelaw: The Glorious Glasgow Haskell Compilation System, version 7.8.3
10:13:41 <jsys> Hijiri: yes but it's not interesting
10:13:45 --- mode: ChanServ set +q *!*@gateway/web/freenode/ip.89.215.196.162
10:13:45 <ReinH> I can't believe we're giving this troll more time
10:13:47 <hiptobecubic> jsys, I feel like you've been training for this under Bill O'Reilly.
10:14:10 <develop7> dcoutts: still working; I don't think this is the way it should work
10:14:19 <LordBrain> jsys, are you forced to do haskell for work or something?
10:14:25 <ReinH> I haven't seen anyone this belligerent and argumentative in months
10:14:27 <zomg> You guys are so gullible
10:14:27 <hiptobecubic> openWormHole >>= populateWorld
10:14:28 <zomg> :P
10:14:45 <sinelaw> ReinH, miracles happen
10:15:07 <ReinH> Either a troll or so indistinguishable from a troll that it makes no difference
10:15:21 <develop7> dcoutts: done; output is exactly same
10:15:27 <zomg> Yeah I said that 30 minutes ago that this conversation isn't going to amount to anything
10:15:30 <zomg> :P
10:15:46 <Rotaerk> hiptobecubic, interstellar?
10:15:47 <zomg> There's a certain number of patterns you can see with trolls or troll-like behavior
10:15:50 <LordBrain> did chansserv +q silence him?
10:16:10 <sinelaw> develop7, can you try in a fresh sandbox?
10:16:14 <zomg> I've tried to document it but it's not exactly an easy job, easier to recognize it in conversation than put down some rules for it
10:16:25 <hiptobecubic> Rotaerk, Functor a => Interstellar a
10:16:29 <zomg> This conversation again followed many of the usual patterns I see with them..
10:16:34 <ReinH> LordBrain: Don't ruin it..
10:17:26 <sclv> if you people want metachat about conversations, please take it elsewhere (such as -blah).
10:19:25 <ReinH> sclv: Well, I've achieved my goal, so I have no reason to now. ;)
10:20:31 <sclv> do folks have any favorite videos they would like to see linked from the new haskell.org page?
10:20:51 <zomg> Tempted to link rickroll...
10:20:52 <zomg> =)
10:20:53 <sclv> either from the frontpage as a good intro, or a lecture series on video they'd recommend for beginners?
10:21:08 <Rotaerk> link one of edwardk's talks *cough*
10:21:50 <Rotaerk> maybe the lens one
10:24:22 <sivteck> ;[
10:24:54 <raek> sclv: two favorites of mine: pipes https://www.youtube.com/watch?v=2jdJGdA7AYs and HsQML https://www.youtube.com/watch?v=JCSxWfUvi6o
10:25:46 <zerokarmaleft> sclv: wadler has a lecture series up on youtube, doesn't he?
10:25:57 <raek> sclv: oh, and I also really liked the Pipes and Conduit episode of the Haskell Cast: https://www.youtube.com/watch?v=Qn2Oc4vWoGg
10:25:58 <ReinH> sclv: Jekor's videos are good!
10:26:00 <mada> sclv: 'The Algebra of Algebraic Datatypes' was accessible and mindblowing to me as an absolute beginner: https://www.youtube.com/watch?v=YScIPA8RbVE
10:26:13 <ReinH> raek: Thanks :)
10:26:34 <theKillingJoke> lambdabot: [1..10]
10:26:53 <voidzero> Yeah Jekor's stuff is very nice
10:27:19 <zerokarmaleft> sclv: also SPJ's adventure with types series at oregon state, though the latter half of the series isn't so beginner-oriented
10:27:53 <edwardk> the main ones i'd like to see on the front page are Cowley's "Abstractions for the Functional Roboticist" from NY Haskell, and Ranjit Jhala's LiquidHaskell talk from Boston Haskell
10:28:05 <edwardk> both of those are very compelling and accessible to newcomers
10:28:24 <edwardk> Cowley's talk is the best selling point i've seen for haskell it shows how we can use these formal methods in all sorts of 'real world' ways
10:28:51 <edwardk> and the LiquidHaskell talk gives a sense of how you can reason about code with refinement types, but he's very careful to avoid losing newcomers along the way
10:28:56 <shapr> Yes please! I like the small part of acowley's talk I've seen so far.
10:30:03 <edwardk> And it doesn't hurt that Cowley's talk has flying robots and fancy conveyor belts and computer vision and motion planning and all the sexy things roboticists do
10:30:05 <phaul> here we go: this let f n = if n == 0 then return () else modify succ >> f (n - 1) in execState (f 10000000) 0 allocates 100s of Mb (before I kill it) with the strict state monad
10:32:49 <phaul> I'm not trying to troll, btw, I just think that given this Control.Monad.State should come with a warning. When I stared using it, I wasn't aware of this
10:32:58 <utdemir> hey. anybody here using "implicit-params"?
10:33:38 <thebnq> phaul: control.monad.state.strict has a strict modify: modify'
10:33:41 <ReinH> phaul: The strict State monad may not be scrit enough.
10:33:45 <ReinH> *strict
10:34:12 <ReinH> phaul: The lazy state monad uses a lazy pattern match in ~(a,s) in bind while the strict one does not. That isn't enough to force the contents of the tuple.
10:34:22 <mpickering> phaul: https://mail.haskell.org/pipermail/haskell-cafe/2012-January/098954.html
10:34:45 <ReinH> phaul: You probably need modify' or some other way of making the computation strict in the state
10:35:04 <ReinH> @src modify'
10:35:04 <lambdabot> Source not found. I feel much better now.
10:35:28 <ReinH> modify' f = do { s <- get; put $! f s }
10:35:33 <sclv> all good suggestions on videos btw, thanks!
10:35:43 <ReinH> So you want to do something like that
10:36:23 <ReinH> phaul: otherwise modify f will build up a chain of thinks of applications of f
10:36:25 <thebnq> hm i don't have modify' either
10:36:26 <ReinH> *thunks
10:36:55 <ReinH> It's in transformers and mtl
10:37:57 <phaul> hm. Is there a fundamental reason why ST is not part of these - tranformers / mtl etc?
10:38:00 <raek> ReinH: I really enjoyed all the Haskell Cast episodes I've watched so far. Good job!
10:38:02 <thebnq> ReinH: i actually just tried that modify' and it got worse
10:38:13 <ReinH> thebnq: o_O
10:39:06 <ReinH> raek: thanks :)
10:39:58 <NightRa> FYI, the vty does depend on the curses C library
10:40:15 <NightRa> * the vty library
10:40:23 <NightRa> via terminfo
10:40:37 <zomg> So... jsys is on ##javascript now asking about monads...
10:40:56 <zomg> Needless to say he was not happy when I said "troll alert"
10:41:28 * hackagebot EstProgress 0.1.0.0 - Methods for estimating the progress of functions  http://hackage.haskell.org/package/EstProgress-0.1.0.0 (JamesCandy)
10:42:28 <rui> NightRa I am still fighting to install that vty
10:43:02 <NightRa> Installing haskell libraries which depend on C libraries is practically impossible
10:43:11 <NightRa> * On windows
10:43:30 <thebnq> ReinH: went away with -O2, but it was still worse
10:43:39 <ReinH> NightRa: I haven't had much... oh, yeah, probably.
10:44:17 <NightRa> And talking about reproducible builds is just funny
10:45:49 <Kron> how does one write a Traversal?
10:45:59 <Kron> without combining other traversals I guess
10:46:21 <Kron> I'm trying to write a traversal that searches over a list of pairs for an index and then modifies the relevant value
10:46:32 <Kron> or I guess just returns a link to the relevant value
10:47:28 <Welkin> Kron: use Map instead of List
10:47:38 <Kron> hmm, help me understand?
10:47:48 <Welkin> [(Int, String)] for example
10:47:55 <Welkin> is the same as Map Int String
10:47:56 <Welkin> but worse
10:48:18 <Welkin> Map gives you O(log n) lookup and update
10:48:22 <Kron> ... noted, but I guess I'm concerned about juggling too many new concepts at a time
10:48:34 <Kron> for now, I want to focus on the art of crafting lens library concepts
10:48:37 <Welkin> Map is an ordered binary tree
10:48:56 <edwardk> Kron: both f (a,b) = (,) <$> f a <*> f b -- is a traversal
10:48:59 <Welkin> it provides functions like `lookup1 and `update`
10:49:09 <Welkin> `lookup`
10:49:18 <Kron> hmm
10:49:28 <Kron> so it's like a lens I guess?
10:49:31 <edwardk> we write it like we're writing 'traverse' for a container where the elements are whatever parts we want to see, not just where the last type argument is.
10:49:33 <Kron> you take a function, a structure
10:49:43 <edwardk> a traversal is like a lens but using <*> it can hit multiple targets
10:49:53 <edwardk> a lens only has <$> and so you can only focus on one thing
10:50:04 <Kron> maybe I don't want to use a traversal then, I was sort of just trying to build a Maybe lens
10:50:07 <Kron> like a lens that can fail
10:50:08 <edwardk> _2 f (a,b) = (,) a <$> f b
10:50:19 <edwardk> you can have the lens 'fail' by using pure
10:50:38 <edwardk> just f (Just a) = Just <$> f a; just _ Nothing = pure Nothing
10:50:50 <edwardk> just there is a crippled version of the _Just prism we have in lens.
10:50:59 <edwardk> (written as a traversal)
10:51:25 <thebnq> ReinH: sorry, it was only worse when using State.Lazy :p i see now
10:51:41 <NightRa> Oh, installing vty really is impossible - it depends on `unix`, and it does not work on cygwin as many think. (Only if one rebuilds GHC from source)
10:52:06 <edwardk> now i picked a boring example, because i was traversing Maybe there, but it works for any sum type or anything where you do case analysis
10:52:32 <Kron> how would I construct a lens with a type signature like "Index -> ???? [(Index, Data)] Data" where ??? is a lens I guess
10:52:32 <Kron> I want it to locate the Index and then provide a link to that location's data
10:52:32 <Kron> (Eq Index)
10:52:33 <Kron> I guess a lens find? Yeah I suppose that's the best metaphor
10:52:36 <edwardk> that thing isn't a lens though, it is a traversal
10:52:52 <Kron> okay so I was right about it being a traversal then, that's good to know
10:52:57 <Kron> I guess some of this is starting to stick then
10:53:00 <NightRa> I give up.
10:53:25 <edwardk> so the example you give there is problematic for a couple of reasons. you can write a traversal that finds the corresponding entry based on the index.
10:53:33 <edwardk> we can actually compose that off of existing lenses, etc.
10:53:36 <Kron> idiomatically I want to write the traversal by compositing smaller lenses and traversals together but I'm not sure how to do that either in this case...
10:53:55 <edwardk> but if you want one where you can add/remove index, data pairs you are underdetermined, you'd need more properties of the list to pass the actual laws
10:53:58 <NightRa> Using native haskell libraries on windows is just a no. It's primitive haskell or nothing at all
10:54:56 <edwardk> > [(1,2),(3,4)]^?traverse.itraversed.Lens.index 5
10:54:58 <lambdabot>  Nothing
10:54:59 <edwardk> > [(1,2),(3,4)]^?traverse.itraversed.Lens.index 1
10:55:01 <lambdabot>  Just 2
10:55:20 <Kron> hmm
10:55:23 <NightRa> That's a serious issue for Haskell
10:55:23 <edwardk> > [(1,2),(3,4)] & traverse.itraversed.Lens.index 1 +~ 10
10:55:24 <rui> When I do ghc-pkg list I get 2 versions of terminfo (0.3.2.5 and 0.4.0.1). Could this be causing my linking problem when installing vty?
10:55:25 <lambdabot>  [(1,12),(3,4)]
10:55:45 <edwardk> > [(1,2),(3,4),(4,0)] & traverse.itraversed.Lens.indices odd +~ 10
10:55:46 <lambdabot>  [(1,12),(3,14),(4,0)]
10:56:07 <edwardk> itraversed for a pair uses the left side of the pair as the index
10:56:37 <edwardk> indices lets you filter on a predicate based on the index you have for an element
10:56:46 <edwardk> index lets you filter with a value you check the index for equality with
10:56:53 <Kron> hmmmm
10:57:15 <edwardk> so there i'm traversing the outer list, then using an indexed traversal of the pair to set up the index to the left side of the pair and walk the right, then filtering on the index
10:57:28 <Kron> is there a way I can do it "manually"? by inelegantly slapping together a getter and setter?
10:57:49 <edwardk> well, traversals are all kind of fused together
10:57:57 <edwardk> you can write it manually, but its a matter of writing the traversal
10:59:49 <edwardk> kron i f (j,a):xs | i == j = (\b ys-> (j, b) : ys) <$> f a <*> kron i f xs | otherwise = ((j, a) :) <$> kron i f xs ; kron _ _ [] = pure []
11:00:13 <edwardk> there it walks down the list looking for where i == j and mapping over those elements, ignoring the rest and finishing up when done
11:00:48 <edwardk> kron i = traverse.itraversed.index i -- is a bit pithier
11:01:38 <edwardk> :t Data.List.lookup
11:01:38 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
11:03:22 <Kron> back, sorry, internet issues
11:03:36 <Kron> I was asking: is there a way I can do it "manually"? by inelegantly slapping together a getter and setter
11:13:02 <rui> If I get a linking error such as "undefined reference to `somefunc` /usr/local/lib/.../ in function `s5B1._info'
11:13:15 <rui> when doing cabal install
11:13:52 <rui> Does that mean that the library in /usr/local/lib/... doesn't export the functions that the other module requires, or what exactly?
11:14:04 <bitemyapp> cmccann: Did this get memory-holed? http://www.reddit.com/r/haskell/comments/2w3pqd/austin_haskellers_theres_a_meetup_this_week_come/
11:15:38 <kqr> is there any kind of loop-like construct in haskell that takes an arbitrary (possibly monadic) initialiser, condition and increment operation?
11:16:19 <kqr> (would be useful for working with external, side effectful things, where you manually paginate results from an API, for example)
11:16:47 <bennofs> kqr: there are a few in the monad-loops package
11:16:50 <bennofs> @hackage monad-loops
11:16:50 <lambdabot> http://hackage.haskell.org/package/monad-loops
11:17:33 <bennofs> kqr: just generating a list of the things you want to loop over first and then using forM_ or similar tends to work well for me too in most cases
11:17:41 <kqr> ah
11:17:43 <kqr> very cool
11:18:28 <kqr> maybe I'm just silly
11:18:32 <Kron> what exactly is "traverse.itraversed.Lens.index"? is it a traversal?
11:18:36 <kqr> I'm skimming the type signatures of monad-loops
11:18:40 <kqr> and this one weirds me out
11:18:41 <edwardk> yes
11:18:42 <kqr> iterateM_ :: Monad m => (a -> m a) -> a -> m b
11:18:44 <kqr> where does it get the b from?
11:18:59 <bennofs> kqr: nowhere. that means it can never terminate
11:19:06 <kqr> oh, forever
11:19:11 <kqr> I missed that bit :D sorry
11:19:21 <edwardk> traverse is a traversal, itraversed is an indexed traversal, index is a combinator that works on indexed traversals, so technically that jumble is an indexed traversal, but every indexed traversal can be used as a normal one.
11:19:46 <lpaste> matt1 pasted “insertcomments.hs” at http://lpaste.net/120613
11:20:08 <glguy> traverse.itraversed.Lens.index :: Eq k => k -> Traversal' [(k,v)] v -- one valid type
11:20:21 <glguy> \k -> traverse.itraversed.Lens.index k :: Eq k => k -> Traversal' [(k,v)] v -- one valid type
11:20:24 <edwardk> you need a lambda
11:20:25 <glguy> (forgot the k)
11:20:25 <edwardk> yeah
11:20:33 <Kron> what would the type signature be?
11:20:39 <Kron> I can't quite make it type check on my end
11:20:41 <glguy> the thing after the ::
11:20:44 <edwardk> what glguy gave
11:21:14 <edwardk> kron :: Eq k => k -> Traversal' [(k, v)] v; kron k = traverse.itraversed.index k
11:21:24 <Big_G> It always amazes me how this channel is always active
11:21:31 <edwardk> Lens.index is to help lambdabot since there is also an index in the array code
11:21:36 <lpaste> matt1 pasted “insertcommentserror” at http://lpaste.net/120614
11:21:49 <edwardk> Big_G: 1600 people or so tends to lead to someone always wanting to talk
11:22:11 <Big_G> edwardk, I love that a language like Haskell can have 1600 people at any point int time
11:22:30 <Kron> hmmm
11:22:57 <matt3> hey everyone, I'm getting a strange error regarding contructing an infinite type, does anyone know what might be going wrong? here is the code: http://lpaste.net/120613, here is the error http://lpaste.net/120614
11:23:08 <Kron> oh I see! I was saying "traverse.itraversed.index $ k"
11:23:15 <Kron> no, we apply index to k...
11:23:17 <matt3> i've never run into this issue before, so I'm not sure where to start
11:23:19 <Kron> fascinating
11:23:42 <matt3> i'm using yesod, btw
11:23:52 <bennofs> matt3: type Comments = Vector Comment I suppose?
11:24:00 <matt3> bennofs: yeah
11:24:11 <matt3> i could post more if that would help
11:24:22 <Cale> matt3: Give an explicit type signature to insertTop' and the error message will be easier to understand
11:24:48 <matt3> Cale: ok I'll give that a shot, but I'm not even sure that my type signature for insertComments is correct
11:25:41 <Cale> matt3: I think the issue is that you're producing a Vector of results there where it only expected to get one.
11:26:04 <Cale> oh, I see
11:26:20 <Cale> You're using insertTop' recursively
11:26:28 <Cale> right
11:26:30 <matt3> yep
11:26:48 <Cale> Did you want to concatenate the vectors that you get from each recursive call?
11:27:07 <matt3> i don't think so, let me think for a second
11:27:37 <Cale> Because currently, the result of insertTop' is a vector of results of insertTop'
11:27:50 <Cale> Which means it'd be a vector of vectors of vectors of vectors ....
11:27:56 <Cale> infinitely deep
11:28:12 <Cale> which is why the type error
11:28:13 <lightstep> seems like there should be "liftM concat" in the end...
11:28:32 <matt3> oh, I don't think i need the results
11:28:33 <Cale> yeah, that would be one way to fix the type error anyway
11:28:54 <matt3> i just need to insert them into the database, I only need the id's on the way down
11:28:58 <Cale> Oh, in that case, you should use mapM_
11:30:01 <Kron> hmmm, I want to compose a mapMaybe function over the _2 lens. Like, have it test things in the second part of a pair, then discard any elements that return Nothing, and build the remaining list
11:30:16 <lightstep> and change the signature of insertComments to Comments -> Handler ()
11:30:45 <matt3> Cale: that fixed it, I also needed to change to type signature of insertComments
11:30:47 <matt3> thanks
11:31:07 <bennofs> > [(1, Just 3), (2, Just 4), (3, Just 1), (34, Nothing), (1, Just 5)] ^.. traverse._2._Just
11:31:09 <lambdabot>  [3,4,1,5]
11:31:14 <bennofs> Kron: ^^^ like this
11:31:17 <bennofs> ?
11:32:03 <Kron> oooh, yeah something like that
11:32:23 <Kron> well, I want to map a predicate over the snd place in a list of pairs
11:32:33 <Kron> and then discard the nothings, and return the rest of the clean tuples
11:32:45 <Cale> Why not just use a list comprehension?
11:33:09 <Kron> something like take [(1,2), (3,0), (4,-2)] and then fold a "Nothing if < 0, otherwise double" function
11:33:18 <glguy> > mapMaybe snd [(1, Just 3), (2, Just 4), (3, Just 1), (34, Nothing), (1, Just 5)]
11:33:19 <Kron> and get [(1,4), (3,0)]
11:33:20 <lambdabot>  [3,4,1,5]
11:33:20 <bennofs> > [(1, 3), (2, 4), (3, 1), (34, 2), (1, 5)] ^.. traverse._2.to (\x -> if even x then Just x else Nothing)._Just
11:33:22 <lambdabot>  [4,2]
11:33:25 <Kron> assuming the second element is the index
11:33:33 <Kron> Cale: because educational exercises, mostly
11:33:46 <Cale> okay :)
11:33:56 <bennofs> Kron: that isn't a traversal though, but only a Fold (you cannot set it)
11:33:58 <Kron> I'm just wondering if there's a mega convenient idiomatic way to do it with lenses
11:34:04 <Kron> it seems the answer is "sorta no"
11:34:11 <bennofs> > [(1, 3), (2, 4), (3, 1), (34, 2), (1, 5)] ^.. traverse._2.folding (\x -> if even x then Just x else Nothing)
11:34:11 <ReinH> > [ x | (x, Just y) <- [(1, Just 3), (2, Just 4), (3, Just 1), (34, Nothing), (1, Just 5)], even y]
11:34:12 <Kron> so I'll just do it the normal way, with mapMaybe
11:34:13 <lambdabot>  can't find file: L.hs
11:34:13 <lambdabot>  [4,2]
11:34:27 <Kron> ... hmm
11:34:48 <ReinH> [ x | (x, Just y) <- xs, even y ] seems nice to me
11:35:04 <Cale> Or even [(x,y) | ...], if you wanted both parts of the pairs
11:35:11 <ReinH> Sure
11:35:20 <Kron> yeah but there's no trivial "even" style separable predicate in my case
11:35:33 <Kron> what's the predicate for turning Nothings into False?
11:35:36 <Kron> isJust?
11:35:40 <Kron> something like that I bet
11:35:40 <johnw> i keep forgetting that failures in pattern matching in list comprehension syntax acts as a filter
11:35:45 <Kron> or wait no
11:35:47 <Kron> Just y, right
11:35:50 <Cale> Kron: Oh, well, then apply the function which gives Maybe results beforehand
11:35:50 <Kron> daaamn that's REALLY clever
11:35:57 <ReinH> Kron: you don't need a predicate for that, you can just use pattern matching
11:36:07 <Kron> haha that's brilliant, thanks, I totally forgot about that
11:36:11 <bennofs> > [(1, Just 3), (2, Just 4), (3, 1), (34, 2), (1, Nothing)] ^.. traverse._2._Just.to (\x -> if even x then Just x else Nothing)._Just
11:36:12 <lambdabot>  No instance for (GHC.Show.Show a0)
11:36:12 <lambdabot>    arising from a use of ‘M50883704267293456581436.show_M50883704267293456581...
11:36:12 <lambdabot>  The type variable ‘a0’ is ambiguous
11:36:28 <bennofs> > [(1, Just 3), (2, Just 4), (3, Just 1), (34, Just 2), (1, Nothing)] ^.. traverse._2._Just.folding (\x -> if even x then Just x else Nothing)
11:36:29 <shapr> I wish Python had Foldable and Traversable, would make my life so much easier.
11:36:30 <lambdabot>  [4,2]
11:36:34 <tdammers> johnw: that's IMO the most valid reason for using comprehensions in the first place :D
11:36:57 <bennofs> right, only reason I use a list comprehension
11:38:18 <tdammers> well, that, and maybe the related use case where you use pattern matching to extract things from a data structure
11:38:47 <Cale> > [(x,y) | (x,Just y) <- map (second (elemIndex 0)) [("a",[0,1,2,3]), ("b", [1,1,0,1]), ("c", [2,3,4,5])]]
11:38:49 <lambdabot>  [("a",0),("b",2)]
11:39:38 <Cale> > [(x,y) | (x:xs) <- tails [1..4], y <- xs] -- this is a nice sort of use of list comprehensions too
11:39:39 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
11:41:03 <tdammers> yep
11:41:38 <Kron> I did [(x, y) | (x, Just y) <- map (_2 %~ pred) xs]
11:41:42 <Kron> so... bit of both I guess
11:42:02 <Kron> still needed to map the function over the snd elements, so the _2 lens was perfect for the job
11:42:24 <bennofs> Kron: why map (_2 %~ pred), you can do (traverse._2 %~ pred) xs :)
11:43:16 <ReinH> bennofs: Probably because the way of lens is mysterious ;)
11:43:28 <Cale> bennofs: Because that's longer and less clear?
11:43:35 <Kron> I will admit, I don't really understand traverse very well
11:43:37 <Kron> that's mostly why
11:43:45 <Kron> I try to avoid it when I can
11:44:19 <ReinH> Kron: But you can just do that with, e.g., [(x, f y) <- (x, Just y)]
11:44:23 <Kron> also, is Map really faster than a list for like 5 elements?
11:44:25 <ReinH> er
11:44:36 <Kron> because that's kind of what I'm working with here, lists I know can't go above six elements or so
11:44:47 <ReinH> [(x, f y) | (x, Just y) <- xs]
11:45:07 <Kron> no I need to apply f to the second element to start with to generate the Justs or Nothings
11:45:14 <Kron> f :: y -> Maybe y
11:45:18 <Kron> in extreme abuse of notation
11:45:34 <ReinH> Ah.
11:45:40 <Cale> The lens library gives you some really useful and composable tools, but at the same time it gives you a lot of really dumb ways of expressing things, by no fault of its own (well, sometimes by fault of its own, but I'm just picky there)
11:45:43 <Kron> like, xs is just an (x, y) pair to begin with
11:45:52 <Kron> this is an elaborate way of modifying the second elements and discarding some
11:45:54 <edwardk> =P
11:46:04 <edwardk> cale's just an old stick in the mud
11:46:05 <Kron> two words: monkey operator
11:46:11 <Kron> this is the nature of Haskell :D
11:46:30 <ReinH> Cale: given at least one way of expressing something, at least one of those ways will probably be dumb. ;)
11:46:31 <Cale> hehe
11:46:50 <edwardk> if you let him he'll start in about how bad in his day, folks walked their code up hill both ways, and used (.) = fmap and liked it.
11:46:53 <maxade> Does SSL_read block for non blocking sockets? SSL_pending does not seem to work the way I want. It always returns 0.
11:46:54 <bennofs> edwardk: if I have a Traversal of pairs, can I use the first element as an index to get an IndexedTraversal over the second element of the pair?
11:46:59 <edwardk> er back in his day
11:47:11 <edwardk> bennofs: itraversed will do that
11:47:12 <ReinH> edwardk: both work
11:47:17 <bennofs> :t itraversed
11:47:18 <lambdabot> (TraversableWithIndex i t, Indexable i p, Applicative f) => p a (f b) -> t a -> f (t b)
11:47:27 <nexx> randomly looking into this chan can be weird "lists I know can't go above six elements"
11:47:54 <edwardk> the instance for (,) borrows the first half of the pair as an index
11:48:23 <bennofs> ah, good to know, thanks. I thought that was using the position as an index (I guess that's what traversed does then)
11:48:25 <Cale> I feel like using lens just to manipulate pairs and Maybe values is almost always insane overkill
11:48:43 <Cale> Like, if you're going to use lens, you should at least have some record types around :P
11:48:53 <bennofs> Cale: it gets handy when you have tuples with more than 2 elements and you can still use _2 etc :)
11:48:58 <Cale> ehhhh
11:49:03 <edwardk> most of my uses of lens have nothing to do with records
11:49:06 <Cale> Yeah, maybe
11:49:07 <edwardk> its just good at those too =)
11:49:20 <edwardk> we started there, but then er.. branched out a bit
11:49:30 <Cale> I don't really care for the _2 etc. lenses
11:49:35 <edwardk> a lot of folks spend a lot of their time using lens with aeson and the like
11:49:35 <Cale> I don't know why
11:49:56 <edwardk> and there almost everything is a prism and half-duck-typed together
11:50:27 <hpc> Cale: because it's hard to tell if it's an operator or "word" identifier?
11:50:44 <merijn> nexx: Randomly looking into this chan causes you to absorb weird vocabulary too ;)
11:50:53 <Cale> edwardk: Well, okay, it's also good even when the types aren't exactly records, for extracting bits of tree structures like that.
11:51:04 <NightRa> edwardk: I would love this issue to be fixed sooner rather than later. All my hassle came from working around this bug. https://ghc.haskell.org/trac/ghc/ticket/2189
11:51:29 * hackagebot ihaskell-parsec 0.2.1.0 - IHaskell display instances for Parsec  http://hackage.haskell.org/package/ihaskell-parsec-0.2.1.0 (gibiansky)
11:51:41 <myfreeweb> i'm currently using lens for html with xml-lens. feels much better than hxt!
11:52:21 <unanimousarc> How can I have a file created when I try and write to it?
11:52:40 <unanimousarc> I'm trying to write to a new text file but I want it created when it is first wrote to
11:52:53 <edwardk> NightRa: i can appreciate that, but it is a big issue with lots of context to understand. we had about 120 of those dumped on our laps a little while ago
11:52:55 <Cale> unanimousarc: Just using writeFile should work for that
11:53:06 <merijn> unanimousarc: On *nix opening a file should create it if it doesn't exis
11:53:09 <edwardk> and we haven't had anyone on the committee have time to really tackle some of these bigger older issues in depth
11:53:13 <nexx> NightRa oh only 7 years old
11:53:20 <edwardk> as they require an understanding of the RTS, windows issues, etc.
11:53:22 <Cale> unanimousarc: Or opening it for writing. There's no explicit operation to create a new file which is separate from that.
11:53:37 <edwardk> and aren't just 'hey can we generalize this type signature? or add this method?' kind of concerns.
11:53:43 <NightRa> edwardk: understandable
11:53:46 <edwardk> i'd rather deal with something that big correctly than quickly
11:53:55 <unanimousarc> Cale: I'm getting a no such file or directory error when I try and write to the file
11:54:14 <Cale> unanimousarc: Are you trying to open it in a directory which doesn't exist?
11:54:25 <myfreeweb> unanimousarc: do all parent directories of the file exist?
11:54:49 <unanimousarc> This is probably my issue, I was trying to use a relative path like "~/.todo" but I realise now that this won't work
11:55:05 <geekosaur> ~ is only understood by the shell
11:55:16 <merijn> unanimousarc: ~ is a shell thing, not a filesystem thing
11:55:29 <unanimousarc> Thanks everyone!
11:55:40 <merijn> unanimousarc: Basically, that tries to open ".todo" in the "~" directory :p
11:55:42 <myfreeweb> some languages' standard libraries expand ~ as well I think
11:56:06 <merijn> myfreeweb: Which ones? I don't think python/ruby do it, I know C/Java don't, so that leaves maybe PHP?
11:56:43 <ReinH> Cale: I get a lot of mileage out of Isos, for example right now I'm using an Iso' Word16 -> (Word8,Word8) for register pair mappings in an emulator.
11:56:56 <ReinH> er Iso' Word16 (Word8, Word8)
11:57:29 <unanimousarc> It would probably be extremely unsafe if the language did expand ~ to the home dir
11:57:34 <utdemir> Hey. In my small program, ghci and ghc yields different results. What are the differences between their interpretations?
11:57:43 <myfreeweb> ah, not automatically, but there's eg. os.path.expanduser in python
11:57:51 <Cale> ReinH: Yeah, stuff like that seems okay, especially as there isn't a particularly good way to express it otherwise.
11:58:31 <Cale> utdemir: "different results" in what sense?
11:58:55 <Cale> utdemir: Are you using concurrency?
11:59:02 <ReinH> Cale: using (#) as a constructor is quite nice. _Bytes # (0xFF,0x00) = 0xFF00
11:59:24 <ReinH> I'm not quite sure what to call it, actually, since one name makes sense for review but not for view, and vice versa.
11:59:40 <unanimousarc> So what is the best way to get the home directory in haskell?
12:00:11 <utdemir> Cale: No, I'm not. I'm using implicit-params package and it seems like scoping rules are different. On GHCi, it takes the right implicit parameter from scope, but on GHC it just uses default values.
12:00:11 <Cale> getHomeDirectory :: IO FilePath
12:00:20 <Cale> from System.Directory
12:00:39 <Cale> utdemir: Can you put your code on lpaste.net?
12:01:02 <utdemir> Cale: it's a little long. And I can't replicate the bug on a minimal working example.
12:01:03 <Cale> I'll have a look at what this package is doing
12:01:45 <Cale> Oh, fun, it's full of unsafeCoerces
12:01:52 <utdemir> Cale: it uses things like unsafeCoerce, so I'm blaming that package instead of my code :)
12:02:01 <utdemir> Cale: yeah, it's pure black magic for me
12:02:52 <tasker> I'm writing some numerical code, and trying to keep it generic by using Num etc. This leads to me getting a huge number of warnings about defaulting constraints to certain types.. is there some way to turn this off? Or is it actually a problem I should be worrying about?
12:02:59 <EvanR> utdemir: blame the witch!
12:03:04 <Cale> utdemir: One thing you might try just for fun is compiling with -threaded anyway, since GHCi is built with the threaded runtime, but in this case I doubt that'll make a difference
12:03:17 <bennofs> tasker: numeric code can be slow if the number type is not know AFAIK
12:03:22 <Cale> utdemir: also, are you just running main from GHCi and seeing the difference, or are you typing some expression?
12:03:23 <johnw> tasker: you could use "default Int"
12:03:34 <tasker> bennofs: I've not experienced this yet, but good to know.
12:03:42 <tasker> johnw: How do I do this?
12:03:46 <Cale> utdemir: The other main difference with GHCi is that it has more aggressive defaulting rules
12:03:57 <johnw> tasker: just after your imports, put "default (Int)"
12:04:35 <utdemir> Cale: I'm comparing running "main" on GHCi with running "cabal test" (the problem is on test case)
12:04:41 <Cale> ah, okay
12:04:44 <Cale> huh
12:04:46 <tasker> johnw: Will this work, even if some should default to Int, and others to Double ?
12:05:17 <johnw> tasker: I'm not exactly sure what it does, in fact, just wondered
12:05:18 <Cale> utdemir: Could it be that your program is being linked against different versions of some packages when using GHCi?
12:05:30 <mada> Any resources to get started in best/good/correct ways to design datatypes?
12:05:40 <mada> or ways not to design datatypes?
12:05:54 <utdemir> Cale: They are running on same environment (using nix-shell)
12:06:09 <mada> is it usual to first design all datatypes and then work from there?
12:06:21 <Cale> mada: That's a valid approach
12:06:29 * hackagebot http-types 0.8.6 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.8.6 (AristidBreitkreuz)
12:06:31 <tasker> johnw: Fair enough, I'll have a look :)
12:06:33 <utdemir> Cale: (using -threaded didn't changed test result)
12:07:06 <Cale> mada: Often you write type signatures for actual stuff, and then work out how the types have to be defined :)
12:07:25 <Cale> mada: Or little example bits of code that you'd like to be able to write
12:07:36 <Cale> even if the things in that code aren't defined yet
12:08:48 <mada> Cale: I understand
12:09:17 <mada> so doesn't it usually happen that one finds out 'welp my types are all wrong' and has to rewrite a bunch of code?
12:09:20 <utdemir> Cale: My code is on github (utdemir/handsy), when you run tests via "cabal test -j" they fail, but when you run it on GHCi, the tests are passing. But the code is a little expensive on dependencies(free...), you may not want to install it.
12:09:36 <Cale> mada: That happens all the time, but it's not really as bad as you think
12:09:47 <Cale> mada: The compiler will help you to figure out where everything needs to change
12:09:57 <mada> Cale: yeah as I was typing I thought "when doesn't that happen"
12:10:05 <mada> in any case the compiler would make it easier.
12:11:24 <Cale> mada: Like, when I was working on a functional reactive programming system for a game, I've had to do some refactorings to fundamental types, which involved changes to hundreds of lines throughout ~8000 lines of code, but I just did it by making the initial change and then running the compiler over and over and fixing what it told me to fix.
12:11:35 <Cale> and in the end, when I was done, the code still worked :)
12:11:42 <Cale> (as soon as it compiled again!)
12:11:51 <mada> To great satisfaction I'm sure
12:11:55 <Cale> yep
12:12:11 <tdammers> Cale: sounds totally plausible - isn't that what programming is supposed to be like all the time?
12:12:15 <Cale> tdammers: :D
12:12:43 <utdemir> Cale: Wow, runhaskell also works.
12:12:45 <mada> so going back to my original question: any resource on the knowledge and best practices the community might have collected over the years?
12:13:12 <Cale> Ah, I don't really know anything very central. I will link you to a really good talk by Simon Peyton-Jones though.
12:13:13 <mada> possibly not only on haskell, I suppose datatype design is common to every programming context
12:13:45 <Cale> http://ulf.wiger.net/weblog/2008/02/29/simon-peyton-jones-composing-contracts-an-adventure-in-financial-engineering/
12:14:11 <Cale> This talk discusses at length one particular approach to the design of functional programs which I think everyone ought to be aware of
12:14:20 <mada> Cale: thank you
12:14:21 <bennofs> Does a pattern like !_ make any sense?
12:14:25 <Cale> It doesn't always work easily, but when it does, it produces some of the nicest code ever.
12:14:40 <Cale> bennofs: sure, you can seq something you don't bind
12:14:53 <utdemir> Hmm. The problem looks like on cabal. When I build directly with ghc, it works. But with cabal build or cabal test, they fail
12:14:58 <Welkin> cale: can you post the link? I joined a bit late
12:15:03 <Cale> http://ulf.wiger.net/weblog/2008/02/29/simon-peyton-jones-composing-contracts-an-adventure-in-financial-engineering/
12:15:16 <Welkin> thanks
12:15:22 <bennofs> Cale: do you know if it helps GHC if I seq something in all clauses for a function (for example, in the [] case for some list function, the base case often doesn't need some otherwise strict variables)
12:15:52 <bennofs> This is probably premature optimization and depends on usecase and I should look at core and profile, but maybe there is a simple answer? ;)
12:16:03 <Cale> bennofs: I don't think it would... if you're pattern matching against some variable, you don't need to ! it.
12:16:30 * hackagebot Fungi 1.0.6 - Funge-98 interpreter written in Haskell  http://hackage.haskell.org/package/Fungi-1.0.6 (ThomasEding)
12:16:55 <Cale> bennofs: Well, hmm...
12:17:02 <platz> Cale: the only thing is it would be hard to query a database full of contracts like that - they need to be evaluated to make any sense of them
12:17:09 <Cale> bennofs: I don't really know the details of how it would influence the strictness analyser
12:17:29 <platz> i mean, maybe you could serialize them to another format, but w/ some loss of fidelity
12:17:42 <Cale> platz: Well, you can have an interpretation of a contract which produces an exact representation of its code.
12:17:56 <Cale> which you can then do some sort of query on
12:18:06 <platz> yeah
12:18:08 <Cale> I suppose it depends on what sort of query you're trying to do
12:18:21 <bennofs> Cale: I thought that maybe it helps if some argument is unconditionally strict (so strictness doesn't depend on values of other arguments), but I think I won't care about that till I have benchmarks
12:19:57 <Cale> bennofs: hmm, yeah, that's sort of what I was thinking after I said that it didn't matter, I guess you could look at the generated code. Obviously it's not always a good thing to make something unconditionally strict when it doesn't have to be either.
12:21:30 * hackagebot safecopy 0.8.4 - Binary serialization with version control.  http://hackage.haskell.org/package/safecopy-0.8.4 (DavidJohnson)
12:22:12 <tasker> Is there a parallel version of Data.Vector.map somewhere? Does stream fusion somehow make this impossible ?
12:24:09 <Cale> http://hackage.haskell.org/package/vector-strategies-0.4/docs/Data-Vector-Strategies.html looks relevant
12:24:56 <tasker> Cale: Ah, so it does. Thanks!
12:26:17 <Cale> tasker: Of course, all it does is use toList and parListChunk and then fromList :D
12:26:28 <tasker> Cale: Bah :P
12:26:33 <Cale> (but that really isn't inappropriate!)
12:26:40 <EvanR> parallel map only makes sense when you have a big enough map where you can justify the cost of forking and joining vs the cost of computing the answer for each element
12:26:44 <tasker> No, but I don't need a package to do that..
12:26:57 <EvanR> a big enough data set
12:27:11 <tasker> EvanR: I believe my dataset would benefit from doing this
12:27:26 <EvanR> dont believe, profile
12:27:27 <tasker> or rather, my calculation on the dataset :p
12:27:36 <tasker> Yes, ofcourse.
12:31:34 <ReinH> Cale: Do those intermediate lists get fused away though?
12:32:31 <ReinH> EvanR: You can turn up either the size of the map or the cost of the computations to make it make sense :)
12:33:34 <EvanR> ReinH: in doing so, you end up with something slower! canceling out the sense
12:34:06 <EvanR> turn them back down if possible
12:35:40 <ReinH> EvanR: you know what I mean :p
12:42:48 <stephenmac7> I have a bit of an issue understanding some types and the operations people tend to do on them, especially here on #haskell
12:43:50 <stephenmac7> Is there any good overview paper or something I can read that clears things up like the nitty-gritty of strange typeclasses like Semigroup, Traversable, Arrow, and Comonad?
12:44:17 <hpc> Semigroup is basically Monoid
12:44:33 <hpc> it has mappend, but not mempty
12:45:17 <stephenmac7> Well, I don't really need any of them specifically. Just want to be able to understand the things people write about in here
12:45:21 <hpc> i can't remember resources for the rest
12:45:34 <Enigmagic> stephenmac7: have you looked at the typeclass-o-pedia?
12:45:43 <stephenmac7> Enigmagic: That sounds nice.
12:45:46 <hpc> the typeclassopedia doesn't cover those
12:45:49 <worldsayshi> Hmm, I see that “FilePath -> ClockTime” doesn’t direct me to http://hackage.haskell.org/package/directory-1.0.0.3/docs/System-Directory.html#v%3AgetModificationTime ? This is understandable I guess since it’s an outdated verion of the package. But it would be nice to get some pointer on where to look.
12:45:52 <stephenmac7> Is it https://wiki.haskell.org/Typeclassopedia ?
12:45:59 <Enigmagic> stephenmac7: yep
12:46:09 <stephenmac7> It seems to cover all those. Very cool
12:46:10 <worldsayshi> I found the newer version by doing a bit more of googling though
12:46:10 <Enigmagic> hpc: it covers Semigroup, Traversable and Arrow at least?
12:46:18 <hpc> oh, neat
12:46:24 <Enigmagic> hpc: and Comonad.
12:46:27 <worldsayshi> *on hoogle I should add
12:46:39 <EvanR> stephenmac7: if youre ok with Monoid, Semigroup should be a cinch
12:46:43 <stephenmac7> worldsayshi: Newer version of the typeclassopedia
12:46:45 <stephenmac7> ?
12:47:08 <stephenmac7> EvanR: I'm ok with Monoid but there are other ones I'm still a little murky on like applicative
12:47:21 <stephenmac7> So, I should just read that thing from start to finish
12:47:24 <worldsayshi> stephenmac7: Sorry I wasn’t adressing your discussion
12:47:28 <stephenmac7> worldsayshi: Ah
12:47:31 <EvanR> stephenmac7: yeah check out typeclassopedia
12:47:41 <stephenmac7> Looks like exactly what I was looking for
12:48:01 <stephenmac7> All the stuff in the introduction under "Have you ever had any of the following thoughts?" applies to me :D
12:48:08 <stephenmac7> Except the first
12:48:46 <stephenmac7> EvanR: Thank you!
12:49:33 <dmj`> is hackage building docs again? Or is that still turned off?
13:02:35 <maxade> haskell has still no use in the real world outsie of jane street 5 years after i was here the last time?
13:03:23 <Rotaerk> maxade, I don't understand the question
13:03:31 <platz> maxade: facebook doesn't count?
13:03:39 <bitemyapp> Rotaerk: I think maxade drank out of the punch bowl at Jane Street.
13:04:08 * EvanR sips some haskell koolaid
13:04:18 <maxade> facebook uses haskell?
13:04:22 <Cale> yes
13:04:23 <Welkin> maxade: plenty of people use haskell that you don't know about
13:04:31 <johnw> maxade: how could you make a claim like what you did if you didn't know that?
13:04:35 <Welkin> for example, freelancers and many startups
13:05:02 <Rotaerk> EvanR, should start selling Haskellaid
13:05:09 <sivteck> maxade, fwiw, i think jane street doesn't use haskell
13:05:11 <maxade> well if they used Python maybe they woudlnt be startups anymore, they would be COMPANIES!
13:05:17 <Cale> https://wiki.haskell.org/Haskell_in_industry has a list of some industrial users of Haskell
13:05:17 <Welkin> jane street uses ocaml
13:05:28 <Rotaerk> and have the haskellaid man be a lambda-shaped container of fluid
13:05:42 <Rotaerk> that would be awkward to drink out of..
13:06:11 <bitemyapp> maxade: got a case of thread-envy?
13:06:19 <Rotaerk> lol
13:06:20 <bitemyapp> maxade: we can cure what ails you!
13:06:30 <Rotaerk> if they used python, they'd no longer be startups?
13:07:01 <Rotaerk> because programming language choice is such a decisive factor in company success
13:07:15 <bitemyapp> Rotaerk: oh come now, don't reply to their trolls seriously :)
13:07:47 <Rotaerk> someone in another channel caught on to my enthusiasm for haskell, so now I'm expected to say things like
13:07:57 <Rotaerk> "It would've been better if it had been written in haskell"
13:08:05 <maxade> If I run out of ale it's Thunderbird wine
13:08:07 <Rotaerk> I'm reminded if I forget to say it
13:08:28 <EvanR> i have found haskell enthusiasm doesnt work will in most cases
13:08:35 <dmj`> maxade: haskell has a large and growing place in the real world these days
13:08:45 <Rotaerk> EvanR, what do you mean?
13:08:52 <Rotaerk> do you mean haskell evangelism doesn't work well?
13:09:02 <EvanR> you are met with double the enthusiasm for whatever the person you are talking to cares about
13:09:11 <Rotaerk> heh
13:09:24 <EvanR> conquer quietly ;)
13:09:41 <bitemyapp> EvanR: tend to agree, depending on context.
13:12:48 <platz> lack of impartiality; it would help if non-haskellers communicated these values but that's almost a contradiction in terms
13:12:50 <Cale> I kind of think Haskell evangelism is mostly unnecessary at this point. The language isn't going away any time soon, and I think most of the people who are likely to want to learn it already at least know that it exists.
13:13:18 <Cale> and yeah, in cases like this, you can actually hurt your case by being overly positive :P
13:14:07 <Rotaerk> but we have to save the people from going to h***ell
13:16:19 <platz> looking at stuff that gets a big ramp w/ adoption it can be as simple as a company backing it (angular) or specifically marketing to solving problems folks already understand and want solutions for.. harder to solve problems that people don't even know they have
13:16:59 <Welkin> except google choose horrible technology
13:17:03 <Welkin> like angular and go
13:17:09 <Welkin> chooses*
13:17:38 <platz> I don't think angular will survive the 2.0 rewrite
13:18:38 <maskd> how are Angular and Go horrible?
13:19:20 <phaazon> hey
13:19:36 <phaazon> how can I use the extension StandaloneDeriving for my typeclasses?
13:19:49 <phaazon> I’d like to quickly derive from them
13:19:55 <phaazon> like deriving instance …
13:22:41 <dmwit> What did you try and where did it go wrong? What you wrote so far looks right to me.
13:23:18 <stephenmac7> I don't get what a monoidial is
13:23:49 <stephenmac7> I'm reading the Applicative section on typeclassopedia but it goes over an "Alternative formulation" of Applicative
13:24:05 <merijn> stephenmac7: Monoids are so easy you already know at least 3 :)
13:24:24 <stephenmac7> merijn: Not a monoid, a monoidial
13:24:33 <stephenmac7> class Functor f => Monoidal f where
13:24:33 <stephenmac7>   unit :: f ()
13:24:33 <stephenmac7>   (**) :: f a -> f b -> f (a,b)
13:24:34 <merijn> stephenmac7: That just means "monoid like"
13:25:00 <johnw> ah, he means the other formulation of applicative functors
13:25:02 <merijn> stephenmac7: It's associatively combining two elements and has a unit
13:25:17 <merijn> stephenmac7: It's not a monoid because it has the wrong kind to be a monoid
13:25:22 <dmwit> Well, it is a bit confusing, since this time the monoid is at the type level.
13:25:37 <merijn> stephenmac7: But if you sorta squint at the type it's kinda, sorta, like a monoid
13:25:40 <orzo> is there a standard way to make quickcheck pretty print it's failure examples?
13:25:51 <dmwit> The monoid is the collection of types, with () as unit and (,) as the binary operation.
13:26:03 <stephenmac7> merijn: I get why it looks like a monoid, but not why it looks like an applicative
13:26:03 <mniip> Monoidal doesn't seem to be a monoid though
13:26:06 <mniip> not associative
13:26:26 <merijn> "fmap (uncurry f)"
13:26:29 <dmwit> It's associative up to canonical isomorphism.
13:26:34 * hackagebot RichConditional 0.1.0.0 - Tiny library to replace classic if/else  http://hackage.haskell.org/package/RichConditional-0.1.0.0 (alexvieth)
13:26:38 <dmwit> Which is all CT folks care about anyway. ;-)
13:26:50 <merijn> stephenmac7: You can implement <*> using "fmap (uncurry f)"
13:27:10 <merijn> Actually, I guess no
13:27:31 <merijn> More like "f (a -> b) -> f a -> f (a -> b, a)"
13:27:49 <merijn> And then "fmap (\(f, x) -> f x)"
13:28:11 <merijn> The first type if (**) from your class
13:28:13 <dolio> Monoidal describes functors between (particular) monoidal categories.
13:28:38 <merijn> stephenmac7: tbh, I wouldn't worry too much about whether this makes sense (unless you want to, because of curiosity)
13:28:58 <merijn> stephenmac7: Because I don't think it's very important in terms of using Applicative in haskell
13:29:02 <stephenmac7> merijn: If it doesn't matter, I'd rather not waste my time on it
13:29:10 <merijn> stephenmac7: It
13:29:25 <stephenmac7> It?
13:29:27 <dolio> The monoid like structure is in the categories, and the functors are the homomorphisms.
13:29:32 <merijn> stephenmac7: It's basically "an alternative formulation" that can clarify things for the more math inclined or provide an alternative view
13:29:36 <merijn> stephenmac7: (premature enter)
13:29:52 <stephenmac7> I should read a book on category theory...
13:29:56 <mniip> why is ghc-api not indexed by hoogle
13:30:11 <merijn> stephenmac7: There's a good blog post series that uses C++ + haskell to explain the basics
13:30:12 <phaazon> ok so I guess deriving instance can’t be used-written? :(
13:30:20 <dmwit> stephenmac7: Applicative is nice because it captures the way you use these things in programming. Monoidal is nice because it captures the elegance and beauty of the abstraction. So the latter matters to the extent that you value understanding how somebody could invent this or what justifies the choice of behavioral laws.
13:30:43 <stephenmac7> dmwit: I see.
13:30:43 <merijn> stephenmac7: I think it's CT is interesting, but as a somewhat advanced haskellers and someone learning CT I would say it's all but useless for practical haskell :)
13:30:55 <dmwit> phaazon: I offered to help, but you need to show what you tried and what went wrong.
13:31:06 <dmwit> phaazon: As I said above, your description was right on as far as it went.
13:31:12 <dolio> dmwit: Category theorists have Applicative, too. They just don't call it Applicative.
13:31:13 <stephenmac7> merijn: Would it be useful for a beginner?
13:31:25 <merijn> stephenmac7: Absolutely not
13:31:31 <phaazon> dmwit: well, I have a monad transformer that I’d like to make an instance of a typeclass of mine
13:31:34 <stephenmac7> Hm. Okay
13:31:34 * hackagebot up 1.0.0 - Command line tool to generate pathnames to facilitate moving upward in a file system.  http://hackage.haskell.org/package/up-1.0.0 (ThomasEding)
13:31:45 <merijn> stephenmac7: I would classify it as 99% useless to beginners :)
13:31:47 <phaazon> I’d like to be able to generate such an instance the simplest way
13:31:51 <dolio> And it's a trivial augmentation of Monoidal in some cases.
13:31:53 <dolio> But not all.
13:32:00 <stephenmac7> Feel like someday, whenever haskell "clicks" for me, I might be productive in this language...
13:32:00 <dmwit> ?paste some minimal (non-)working code and the error, phaazon
13:32:00 <lambdabot> Haskell pastebin: http://lpaste.net/
13:32:06 <merijn> stephenmac7: Practically speaking you're going to gain A LOT more from studying lambda calculus and type theory :)
13:32:21 <phaazon> like making an instance of MonadError for (MonadError w m) => MonadError w (WriterT w' m)
13:32:31 <phaazon> dmwit: it’s a general question in the end, not specific to my problem
13:32:41 <stephenmac7> merijn: I haven't studied those either...
13:32:56 <stephenmac7> merijn: There's such thing as type theory?
13:33:09 <phaazon> dmwit: one other way to ask: what does GHC do when using StandaloneDeriving
13:33:26 <dmwit> phaazon: same thing it would do if you put the "deriving" clause right on the definition of the type
13:33:38 <dmj`> stephenmac7: http://www.cis.upenn.edu/~bcpierce/tapl/
13:33:47 <dmwit> phaazon: by built-in rules for specific classes, or by GND
13:33:52 <merijn> stephenmac7: Yes, it's somewhat related (and by that I mean there's a very nice and concrete mathematical definition of the relation) with logic
13:33:56 <dmwit> I think there's a third way. But I can't think of it off the top of my head.
13:34:16 <stephenmac7> merijn: I'll take a look, thanks
13:34:29 <merijn> stephenmac7: TaPL as suggested is a very nice intro, especially for those with an interest in practical type systems (i.e. implementing type checkers/inferers for your own language)
13:34:41 <dmwit> phaazon: Ah, yes, if there are default definitions for everything it can generate an empty instance, I think.
13:35:08 <phaazon> ah
13:35:14 <phaazon> I mean
13:35:15 <phaazon> this:
13:35:22 <merijn> It comes with example implementations of all the checkers and has a decent lambda calculus intro too. The code is, sadly, in ocaml, but only uses a basic subset (i.e. functions and pattern matching, so I'd say beginner haskellers should be able to read all of it no problem)
13:35:27 <phaazon> deriving instance (MonadBase IO m) => MonadBase IO (IOScopedT m)
13:35:31 <phaazon> how does this work?
13:36:10 <merijn> stephenmac7: How long have you been learning/playing with haskell?
13:36:32 <stephenmac7> merijn: Way too long to still be at this level. At least 3 years
13:36:53 <stephenmac7> It's beyond frustrating
13:36:53 <merijn> Maybe you just need to write and screw up more? :)
13:36:59 <phaazon> I guess I’ll have to read the extension documentation then :)
13:37:02 <dmwit> phaazon: Is IOScopedT a newtype?
13:37:25 <stephenmac7> merijn: That's what I'm trying to do.
13:37:30 <phaazon> dmwit: yes
13:37:35 <stephenmac7> I'm past the point of giving up
13:37:37 <merijn> Although, tbh, I spend a ton of time just reading lots of stuff instead of programming and now feel pretty comfortable writing it without having written all that much actual code :p
13:37:38 <phaazon> though
13:37:47 <phaazon> I use StandaloneDeriving
13:37:51 <dmwit> phaazon: Probably via GND, then.
13:38:01 <merijn> stephenmac7: What sort of problems do you usually run into that make you feel unproductive?
13:38:05 <phaazon> dmwit: is that automatic?
13:38:12 <dmwit> What does "automatic" mean?
13:38:23 <phaazon> dmwit: for any typeclasses
13:38:28 <phaazon> not only “famous” ones
13:38:34 <dmwit> yes
13:38:37 <phaazon> interesting
13:38:41 <phaazon> I’ll try that then
13:39:22 <stephenmac7> merijn: Sometimes I need to use, say, a library, and there is no documentation besides haddock and it uses Monad Transformers combined with lens with some other strange stuff mixed in that you have to sort through before you get anywhere
13:39:45 <merijn> tbh, lens is pretty intimidating to me still :p
13:40:10 <merijn> Have you watched edwardk's talk on lenses? It's pretty enlightening if you follow along and do the derivations by hand
13:40:51 <stephenmac7> Or, for fun, I wrote madlib software and these lines: https://github.com/stephenmac7/MadFactory/blob/master/MadLibUtil.hs#L111-L127 took me two days
13:41:32 <stephenmac7> Only because I had to preserve state while transversing a document
13:41:34 * hackagebot handsy 0.0.10 - A DSL to describe common shell operations and interpeters for running them locally and remotely.  http://hackage.haskell.org/package/handsy-0.0.10 (utdemir)
13:41:58 <stephenmac7> merijn: Not yet, I haven't.
13:42:14 <merijn> stephenmac7: If monad transformers are one of your problems, have you ever implemented any (say, State)?
13:42:21 <stephenmac7> Because the graph on https://hackage.haskell.org/package/lens scares me :P
13:42:34 <merijn> I always HIGHLY recommend that as an exercise for understanding how they work/what they are
13:42:53 <edwardk> stephenmac7: you don't need to use the entire graph, most people get by with just using lenses, then learning traversals, or prisms as they find they fit their code
13:42:58 <stephenmac7> merijn: Yeah, I implemented State by trial and error and dancing with GHC
13:43:07 <stephenmac7> But didn't understand it afterward
13:44:17 <merijn> stephenmac7: StateT (the transformer) is only slightly harder then State, but if you didn't understand your implementation of State then maybe your confusion might be earlier
13:44:27 <stephenmac7> edwardk: Hm. Maybe I'll look into it more. Looks like it could be useful if I have large data structures.
13:44:33 <stephenmac7> You wrote it?
13:44:44 <merijn> Did you implement the Functor/Applicative/Monad for State too?
13:44:54 <stephenmac7> I can't remember whether I did that
13:45:21 <merijn> That's probably the most crucial part, imo. I would recommend trying to implement these two: https://gist.github.com/merijn/098106abd45c940dab09 and ask if you have trouble
13:45:48 <stephenmac7> merijn: Oh, I remember that. Yes, I did those.
13:45:55 <stephenmac7> Guess I've had this conversation with you before :(
13:46:23 <merijn> stephenmac7: One particularly enlightening thing is to expand the "MyState s a " with it's internals
13:46:26 <stephenmac7> Probably in November of 2014 when I did that :P
13:46:59 <mikeplus64> stephenmac7: there is also lens-family for a less humongous lens api but using the same "technology"
13:47:00 <merijn> Let's say we have "MyState s a -> (a -> MyState s b) -> MyState s b"
13:47:06 <mikeplus64> @hackage lens-family
13:47:06 <lambdabot> http://hackage.haskell.org/package/lens-family
13:47:14 <stephenmac7> mikeplus64: Okay
13:47:21 <merijn> stephenmac7: Now, we know (from the definition) that "MyState s a" is really just "s -> (a, s)", right?
13:47:39 <stephenmac7> merijn: Yes, that I know
13:47:52 <stephenmac7> Those stupid letters are part of the problem though :P
13:48:05 <merijn> So what does that type become? "(s -> (a, s)) -> (a -> (s -> (b, s))) -> (s -> (b, s))"
13:48:39 <merijn> stephenmac7: When confused, always write down types on paper and manually expand, repeat and stare until clarity ;)
13:49:05 <merijn> stephenmac7: So we have a function that takes a "state" 's' and produces an 'a' and a new state 's' (first type
13:49:50 <edwardk> @djinn (s -> (a, s)) -> (a -> (s -> (b, s))) -> (s -> (b, s))
13:49:50 <lambdabot> f a b c =
13:49:51 <lambdabot>     case a c of
13:49:51 <lambdabot>     (d, e) -> b d e
13:49:58 <edwardk> is that cheating?
13:50:07 <stephenmac7> merijn: I'll redo that "homework"
13:50:08 <merijn> And then we have a function that takes an 'a' to produce a function that takes a state 's' and returns a 'b' and a new state and use that to get a function that takes a state and returns a state and returns a 'b' and a new state
13:50:31 <zipper> Yesod question here: https://groups.google.com/forum/#!topic/yesodweb/ZtodCAWz71U
13:50:48 <merijn> stephenmac7: So, when we think about it, what are we doing? We're turning "a -> b" function into functions that take an extra 's' (the input state) and produce an extra 's' (the output) state
13:50:57 <stephenmac7> merijn: "MyState s a -> (a -> MyState s b) -> MyState s b" is the type of what?
13:51:06 <merijn> stephenmac7: The type of >>=
13:51:10 <stephenmac7> Oh.
13:51:40 <TheLemonMan> is it usually ok to introduce typeclass constraints in data declarations ?
13:51:49 <merijn> stephenmac7: So basically we're just adding extra input arguments and results to every function (I assume you can see how you can fake global state data way)
13:51:50 <phaazon> TheLemonMan: not really
13:51:51 <phaazon> you can
13:51:56 <phaazon> but that’s not advised
13:52:02 <merijn> stephenmac7: We're just using the data/newtype and monad instance to hide all that noise
13:52:04 <stephenmac7> merijn: I think I kind of get it now
13:52:07 <merijn> phaazon: You can't, it's not Haskell2010
13:52:17 <phaazon> ah?
13:52:18 <phaazon> I thought so
13:52:20 <joejev> I am not sure if there is a ghc channel that I should ask this in; however, is GHC core a decent target language for a toy compiler?
13:52:23 <merijn> TheLemonMan: It's a bad idea and was deprecated from Haskell2010 for that reason
13:52:39 <TheLemonMan> merijn, what's the right approach then ?
13:52:39 <merijn> phaazon: It was in Haskell98 and was deprecated in 2010 it's only around as extension now in GHC
13:53:07 <merijn> TheLemonMan: Put the constraint on the functions (incidentally, you have to put them on the functions ANYWAY, constraining the data doesn't remove the need for that)
13:53:21 <merijn> joejev: I would probably go slightly simpler for a toy compiler
13:53:31 <merijn> joejev: But it's fairly decent
13:53:43 <TheLemonMan> merijn, got it, thanks
13:53:58 <merijn> TheLemonMan: Consider this
13:54:02 <merijn> :t S.empty
13:54:03 <lambdabot> S.Set a
13:54:07 <merijn> :t S.insert
13:54:08 <lambdabot> Ord a => a -> S.Set a -> S.Set a
13:54:33 <merijn> joejev: For a lazy functional language, that is, it'd make a pretty poor target language for, say, an imperative toy language :)
13:54:34 <joejev> merijn: Are there a lot of optimizations that are happening in the haskell -> core steps? I have written compilers before; however, I am looking to start on a functional language now
13:55:00 <stephenmac7> merijn: Thanks, I'll try implementing it again
13:55:27 <merijn> joejev: I think a lot of it is merely desugaring and some inlining? But don't hold me to that
13:55:42 <merijn> joejev: Hell, why not go all the way to LLVM as output for your language? ;)
13:56:11 <joejev> merijn: I have targeted x64 nasm for things, I was just looking for something different
13:56:14 <merijn> stephenmac7: If that State example makes sense, try to look at StateT very closely and compare what's different, then think about what that means
13:56:20 <joejev> but llvm sounds pretty fun
13:56:32 <stephenmac7> merijn: Oaky
13:56:34 <stephenmac7> *okay
13:56:34 <aidecoe> I am learning Haskell. Could someone take a look and say why this code is 10x slower than C++ impl.? http://wklej.org/hash/1450f69ad49/
13:56:34 <merijn> joejev: There happens to be an excellent paper that explains how you compile lazy languages to C/asm/whatever
13:56:50 <aidecoe> not even saying how much more memory it takes…
13:57:33 <joejev> aidecoe: C++ impl?
13:57:49 <merijn> aidecoe: "foldl" <- that
13:58:14 <joejev> merijn: as opposed to foldl'?
13:58:23 <merijn> aidecoe: Without even looking at the rest of the code I'm about 80-90% sure your memory issues and speed issues are there
13:58:26 <merijn> joejev: Yeah
13:58:38 <merijn> foldl is an unfortunate historical accident which is almost always wrong
13:58:44 <aidecoe> joejev: it's a problem solution in some online judge. Others solved this in C++ and their execution time is 10x faster.
13:59:02 <merijn> aidecoe: Can you try replacing "foldl" with foldl' (note the prime) and see if there's any improvement?
13:59:12 <aidecoe> i'm trying it
13:59:19 <joejev> aidecoe: I mean, they could be using a different algorithm>?
13:59:52 <merijn> joejev: My goto link for people wanting to implement lazy functional languages: http://research.microsoft.com/apps/pubs/default.aspx?id=67083 ;)
14:00:14 <merijn> joejev: It's a bit outdated compared to current GHC, but it's probably the best starting point around to see how laziness ticks inside
14:00:52 <aidecoe> merijn: where is foldl'?
14:01:11 <merijn> joejev: See also http://dev.stephendiehl.com/fun/ and http://www.stephendiehl.com/llvm/
14:01:40 <merijn> aidecoe: It's a "stricter" version of foldl. The problem with "foldl" is that it's often (always?) TOO lazy
14:01:49 <merijn> > foldl f z [a,b,c]
14:01:50 <lambdabot>  f (f (f z a) b) c
14:02:04 <joejev> merijn: Thank you so much, I have seen stephen diehl's stuff, pretty cool. I had not seen the MS article, thank you
14:02:27 <joejev> merijn: is there a reason that they are not flipped other than for historic reasons?
14:02:37 <joejev> such that foldl is strict and foldl' is lazy
14:02:45 <merijn> aidecoe: As you can see, if 'f' uses the first argument it has to "compute" the entire list
14:02:54 <hpc> because non-strict is the default in haskell
14:03:04 <merijn> joejev: No, people didn't realise that initially and now there's too much resistance to changing it :\
14:03:12 <glguy> > foldl (\rest x -> if even x then Just x else rest) Nothing [undefined,2]
14:03:14 <lambdabot>  Just 2
14:03:38 <glguy> It's the same use-case as foldr except you start from the end of the list instead of the beginning
14:03:45 <glguy> you just usually don't want to start from the end
14:03:47 <merijn> aidecoe: So, what happens due to laziness? Haskell creates a thunk for "f z a", then creates a thunk for "f (f z a) b" and then one for "f (f (f z a) b) c"
14:04:11 <merijn> aidecoe: And after it spends all this time building this linked list of thunks it then spends a bunch of time collapsing/computing them again
14:04:12 <aidecoe> yup, and at the end it executes that
14:04:33 <aidecoe> but i would expect it executes that… better (-:
14:04:35 <merijn> aidecoe: Whereas, realistically you'd want it to IMMEDIATELY compute the result of "f z a" and then use that as input for the next one
14:05:15 <hyPiRion> Is there any tutorial on trifecta out there? I have no idea where to start on the docs
14:05:23 <merijn> aidecoe: Which is exactly what foldl' does, it makes sure that you force the first argument immediately, instead of everything at the end. The reason why fold has this stupid behaviour, as mentioned, is really just hysterical raisins
14:05:59 <merijn> aidecoe: afaik there's almost NEVER a scenario where you want foldl over foldl', unfortunately, changing the times could potentially make currently working code stop working, therefore it's unlikely to change
14:06:19 <merijn> Incidentally, did it have any impact on the runtime?
14:06:21 <joejev> merijn: if you were throwing away the argument and using fold to traverse?
14:06:24 <aidecoe> merijn: but if haskell doesn't deal well with it's standard foldl what about other recursive functions?
14:07:00 <merijn> aidecoe: This doesn't really have to do with recursive functions in general
14:07:02 <glguy> It deals just fine with foldl, but if foldl wasn't what you should have used it will be slow
14:07:12 <merijn> aidecoe: Haskell doesn't have a stack in the traditional C/C++ sense
14:07:31 <merijn> aidecoe: i.e. all haskell function calls are jumps, not calls that push a stack frame
14:07:32 <aidecoe> merijn: i hope so it doesn't have
14:08:02 <merijn> aidecoe: As a result, depending on your point of view either ALL function calls are tail calls or none of them are (because there is no call/stack push)
14:08:19 <mniip> what is targetContents from HscTypes for? guessTarget returns a Target with that field being Nothing
14:08:30 <merijn> At any rate, recursion doesn't allocate/increase stack use, unless the function itself is allocating things
14:08:36 <aidecoe> merijn: foldl' hasn't helped. It's even worse by 0.06 s.
14:10:21 <platz> the reason foldr is used in a lot of prelude definitions is to only to support infinite streams where the combinator isn't strict in it's arguments, right?  Is there any other reason to prefer foldr?
14:10:52 <platz> or is primarlily for lazyness
14:11:02 <Cale> Well, it's also prettier
14:11:09 <Cale> conceptually
14:11:27 <platz> i.e. the whole "replace : and []" thing?
14:11:28 <Cale> foldr f z xs replaces each occurrence of (:) in xs with f and the occurrence of [] if any with z
14:11:33 <Cale> yeah
14:11:36 <platz> cool
14:11:45 <merijn> platz: Well, you can implement foldl using foldr, but not the other way around
14:12:04 <platz> meaning the equivalent foldl definition would be more verbose/complex
14:12:20 <platz> becasue foldr is certianly used a lot in base
14:12:36 <aidecoe> merijn: maybe it's triangulate function the problematic one?
14:12:56 <merijn> aidecoe: I don't see any obvious problems, so I'm just gonna try some things and check
14:13:26 <merijn> aidecoe: Eh, just to be sure, you're compiling with -O2, right?
14:13:42 <aidecoe> merijn: i have no idea. It's online judge.
14:14:05 <phryk> Heya, anyone has any tips on what kind of stuff is easy to implement in Haskell for a newbie?
14:14:19 <aidecoe> merijn: they provide very simple test case to test it on local machine
14:14:27 <srid> if any of you are reading Richard Bird's latest book, is this definition not incorrect (because `p` is never applied)?
14:14:31 <merijn> aidecoe: Do you have sample input? Or link to the judge?
14:14:32 <srid> https://www.irccloud.com/pastebin/f5x7Hfto
14:14:36 <srid> (page 45)
14:14:52 <cmccann> bitemyapp: that post appears to be removed but not by moderator action or the spam filter. also it shows the user as [deleted] and I can't manually approve it.
14:14:53 <aidecoe> merijn: http://www.spoj.com/problems/VPL1_BA/
14:14:58 <phryk> Normally, the first thing I write in a new programming language is a website; I managed to do that as my first project even with common lisp, but I just feel completely lost with haskell^^
14:14:58 <merijn> srid: filter applies 'p' internally
14:14:58 <platz> phryk: http://exercism.io/ has some good exercises
14:15:21 <srid> merijn: ah. it is 'filter'. i read that a recursive call to 'first'.
14:15:28 <srid> guess i'm yet to get used to the terseness of haskell :)
14:15:29 <merijn> srid: :)
14:15:52 <phryk> platz: aye, lemme read up on that. :)
14:16:11 <merijn> aidecoe: It's hard to say what the expected time would be without the real datase
14:17:18 <aidecoe> merijn: well, with C++ people do it in < 1.0 s
14:17:43 <bitemyapp> cmccann: I nuked it because I thought it was unwelcome, it was a post about the Austin Haskell meetup this week.
14:17:48 <bitemyapp> cmccann: is that sort of post okay?
14:18:46 <merijn> aidecoe: I mean, the speed of two examples in my local machine is not really good for testing ;)
14:18:48 <ttt_fff> so I just learned about doing error handling in haskell ... and I'm like wtf, I've been a moron all these years
14:18:54 <ttt_fff> erro ahdnling is a monad
14:18:58 <ttt_fff> wtf .... life changes
14:19:13 <aidecoe> merijn: well, that's usual problem with online judges (-:
14:19:32 <cmccann> bitemyapp: meetup posts are fine, we get those semi-regularly
14:19:39 <bitemyapp> cmccann: okay I'll try again.
14:19:43 <Cale> ttt_fff: Well, not just one monad, but there are certain monads (and other sorts of libraries) which have catch-like operations.
14:20:06 <cmccann> bitemyapp: if it didn't show up immediately then reddit's spam filter ate it, that happens occasionally at random
14:20:18 <ttt_fff> Cale: how do haskell programmers use other languages?
14:20:26 <ttt_fff> i feel like after a certain level of clarity, everything else feels like asembly
14:20:45 <Cale> ttt_fff: IO also has a built-in exception system which is really nice, but we don't even use it so much because we'd usually rather reflect the possibility of failure in our types.
14:21:09 <hpc> it's used pretty extensively in base libs
14:21:14 <Cale> So, you're more likely to see an IO action that produces a Maybe result
14:21:25 <hpc> to make annoying IO stuff make more sense
14:21:25 <Cale> Or an Either result
14:21:56 <bitemyapp> cmccann: yeah it's not in /new, sorry to bother you again but could you take a look?
14:23:01 <kgadek> hi all. Can't find any info on this: `traverse` will traverse the Data.Map in the key order? or is it just implementation specific and I shall not depend on that?
14:23:19 <Cale> kgadek: Yeah, it's in key order.
14:23:25 <merijn> aidecoe: For me foldl' is neglibly faster, but lemme try some other tricks
14:23:33 <kgadek> Cale: thanks for quick reply!
14:23:40 <phaazon> kgadek: not sure you could rely on that though
14:23:57 <kgadek> phaazon: what do you mean?
14:24:04 <aidecoe> merijn: do you see improvement foldl vs foldl' in my code?
14:24:09 <phaazon> kgadek: traverse doesn’t expos laws about ordering
14:24:12 <phaazon> expose*
14:24:26 <hpc> it's also not obvious to others who will have to read it
14:24:30 <phaazon> it’s an assumption that could be broken in a future release I guess
14:24:31 <merijn> aidecoe: Only like 0.3s
14:24:49 <merijn> aidecoe: FYI, readCount could be "readLn :: Read a => IO a" :)
14:24:52 <Cale> aidecoe: Do you have the C++ code to compare with this? Is it using the same algorithm?
14:25:21 <Cale> Also, how is the Haskell code being compiled?
14:25:24 <kgadek> phaazon: seems like right – no mention of that in documentation. So… is there a way to traverse a Map in key order 1) without sacrificing the performance 2) in reliable way?
14:25:31 <Cale> Is it being built with -O2 ?
14:25:47 <cmccann> bitemyapp: yep, it was the spam filter. it should be there now.
14:25:49 <merijn> Cale: No, it's one of those contest sites and it's hard to tell what the compile options are
14:25:55 <phaazon> kgadek: I guess you can use traverse as Cale mentionned, but I’d be ultra careful
14:25:56 <Cale> (The performance of Haskell code is pretty meaningless if not built with optimisations)
14:25:57 <kgadek> phaazon: by 1 I mean sth like: `sortBy fst . toList`
14:26:20 <phaazon> kgadek: sortBy (comparing fst)
14:26:21 <aidecoe> Cale: no, i don't have. I don't know about optimization either. It's online judge.
14:26:25 <phaazon> sortBy fst doesn’t typecheck
14:26:38 <bitemyapp> cmccann: danke
14:26:42 <merijn> Wait
14:26:48 <Cale> aidecoe: I remember trying SPOJ several years ago and being frustrated by issues like this.
14:26:51 <merijn> Can't I sneak the optimisation flag into a pragma?
14:26:53 <phaazon> kgadek: if Map doesn’t expos such a function
14:26:57 <Cale> aidecoe: I just went and did something else instead.
14:26:59 <phaazon> you’re left with two possibilities
14:27:26 <phaazon> 1. use the Traversable instance, but be ultra dubitative
14:27:35 <phaazon> 2. write your own function to do that
14:27:47 <aidecoe> Cale: could you recommend other online judge?
14:27:57 <aidecoe> merijn: thanks for readLn :-)
14:28:04 <Cale> I dunno, a lot of people seem to like doing Euler problems
14:28:05 <phaazon> maybe there’s an OrderedMap somewhere
14:28:26 <Cale> Those don't require you to rely on the sanity of someone else's computer
14:29:06 <phaazon> oh nevermind
14:29:08 <kgadek> phaazon: there is mapAccumWithKey function which "map[s] in ascending order of keys" but that seems like a bit of workaround to retrieve `traverse` back. Hmm. Will probably rely on that though
14:29:12 <phaazon> Map _is_ an ordered map
14:29:16 <merijn> Cale: Adding OPTIONS_GHC -O2 doesn't really affect the speed
14:29:26 <phaazon> yeah
14:29:27 <merijn> I wonder whether the problem is the IO performance
14:29:32 <phaazon> I think you can rely on traverse blindly
14:29:34 <johnw> Cale: I felt that some of the Euler examples had something to teach through the experience of doing them, while others were just arbitrary make-work
14:29:43 <bennofs> merijn: is -O2 a dynamic flag?
14:30:19 <aidecoe> Cale: i'm just looking for something where i could exercise with haskell and algorithms at the same time (-:
14:30:25 <merijn> bennofs: Yes
14:30:27 <Cale> johnw: Yeah, I'm not really crazy about most of them, I tend to dislike problems for which the solution is a number that nobody cares about.
14:30:57 <merijn> bennofs: https://downloads.haskell.org/~ghc/7.0.2/docs/html/users_guide/flag-reference.html#id486867
14:31:36 <merijn> aidecoe: Anyway, I don't see anything obvious to fix without being able to profile the code
14:32:29 <aidecoe> merijn: hm, maybe i'll write test case generator (-:
14:32:30 <kgadek> phaazon: hmm not super-convinced – I don't like relying on sth not described in documentation… but well, other way is going with mapAccumWithKey. Pitty there's no `traverseInorder` there though
14:32:48 <aidecoe> but for now it's time to sleep
14:32:51 <kgadek> phaazon: anyway, thank you for your help!
14:32:53 <geekosaur> can't tell if that site is even using ghc, much less compiling (if they use runhaskell then there's no point in trying to optimize)
14:33:08 <aidecoe> thank you for help and goodnight
14:33:20 <aidecoe> merijn: ↑
14:34:07 <merijn> aidecoe: No problem :) Incidentally, Real World Haskell has a chapter on profiling haskell code ;)
14:34:23 <phaazon> kgadek: well
14:34:30 <phaazon> in the top documentation of Data.Map
14:34:39 <phaazon> it says Data.Map are ordered maps
14:34:51 <phaazon> so the traverse implementation OUGHT to traverse in order
14:34:57 <phaazon> otherwise it’d be wrong
14:35:44 <kgadek> phaazon: I know but… let's say I don't like making such assumptions – it feels like a hack for me. However I think I'll go with traverse then
14:36:20 <phaazon> kgadek: it’s not really a hack actually
14:36:21 <merijn> kgadek: Eh, traverseInorder is just "map f . toAscList" :p
14:36:35 * hackagebot xml-hamlet 0.4.0.10 - Hamlet-style quasiquoter for XML content  http://hackage.haskell.org/package/xml-hamlet-0.4.0.10 (MichaelSnoyman)
14:36:37 * hackagebot up 1.0.0.1 - Command line tool to generate pathnames to facilitate moving upward in a file system.  http://hackage.haskell.org/package/up-1.0.0.1 (ThomasEding)
14:36:42 <phaazon> traverse has no meaning without a specific structure
14:36:45 <phaazon> it’s an abstraction
14:37:09 <phaazon> traverse on UnorderedMap could traverse in the order it wants
14:37:13 <kgadek> merijn: I assume that `fromAscList . map f . toAscList ` is a subject to stream fusion, yeas
14:37:15 <kgadek> *yes
14:37:20 <phaazon> but for a Map, we expect it to traverse regarding the order
14:38:50 <ttt_fff> in the haskell standard, when I write "data Foo ... = BLAH BLAH BLAH", is .... always a (possibly empty) list of lower-case letters?
14:39:23 <merijn> ttt_fff: Yes*
14:39:44 <ttt_fff> merijn what does the "*" mean ?
14:39:46 <merijn> ttt_fff: The asterix indicates that some extensions violate the rule
14:39:57 <merijn> Although I can think of only one
14:40:03 <ttt_fff> merijn: ah, understood, out of courisity, which one?
14:40:16 <merijn> Kind signatures allows you to annotate type variables with kind signatures
14:40:17 <sinelaw> Anyone have a nice implementation of QuineMcCluskey boolean simplification?
14:40:31 <merijn> "data Foo (m :: * -> *) = ..."
14:41:31 <HeladoDeBrownie> ttt_fff, it's slightly more complicated than that, but you have the basic right idea. they're actually varids as described here: https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#dx7-18001
14:41:34 <merijn> ttt_fff: But basically, the left-hand side of a data declartion is a type constructor followed by zero or type variables, which, being variables, must be lower case
14:41:35 * hackagebot up 1.0.0.2 - Command line tool to generate pathnames to facilitate moving upward in a file system.  http://hackage.haskell.org/package/up-1.0.0.2 (ThomasEding)
14:41:39 <ttt_fff> merijn: okay, I will not be using that any time soon
14:41:42 <HeladoDeBrownie> ttt_fff, if you don't care about the more detailed syntax, you don't have to read that :P
14:41:45 <merijn> ttt_fff: Well, they don't have to be just letters either
14:42:00 <merijn> ttt_fff: You could write "data Maybe type = Just type | Nothing" <- that's valid too
14:42:13 <Cale> ttt_fff: btw, the type parameters needn't be single letters, but usually they will be because there won't ever be much better names to use, since they can be any type whatsoever
14:42:24 <Cale> ah, merijn already got that :)
14:42:38 <cmccann> even lens has yet to find a reason to need more than 26 distinct type variables
14:42:52 <edwardk> not sure that is true
14:43:17 <merijn> I've used non-letter type variables before, but that was for DataKinds types which were not types of kind * :p
14:43:20 <edwardk> we at least come damn close
14:43:21 <sinelaw> edwardk, if anyone, then you, must have a quine-mccluskey implementation handy, perchance?
14:43:23 <edwardk> :t _9
14:43:24 <lambdabot> (Field9 s t a b, Functor f) => (a -> f b) -> s -> f t
14:43:32 <cmccann> really? even the hairiest type signatures in lens seem to have maybe a dozen at most
14:43:35 <ttt_fff> gentlemen, alright, this suffices :-)
14:43:36 <ttt_fff> thanks :-)
14:43:41 <edwardk> bah, the instances for that hit ~19-20 variables
14:43:52 <cmccann> hm, true
14:44:05 <HeladoDeBrownie> ttt_fff, good, although not everyone replied may be considered a gentleman
14:44:07 <merijn> ttt_fff: I do strongly support HeladoDeBrownie's suggestion to read the lexical syntax in the report
14:44:08 <cmccann> actually anything with very large tuples will get close, forgot about that
14:44:09 <HeladoDeBrownie> +who
14:44:48 <merijn> ttt_fff: Hell, read the entire report while you're at it. It's filled with many obscure gems the books usually gloss over. Plus, it's an example of one of the most readable language standard ever written
14:45:12 <ttt_fff> merijn: yeah, it's very well written, even when I was trying to learn haskell
14:45:21 <ttt_fff> merijn: I was like hmm, this isn't too bad, though tediously boring
14:45:25 <merijn> > let (☃) x y = 1 + x + y in 2 ☃ 3 -- Behold, the mighty snowman operator :D
14:45:26 <lambdabot>  6
14:46:30 <merijn> ttt_fff: I've read the C spec and attempted to read the C++ one, the Haskell Report has reduced (most) of my PTSD resulting from that :p
14:47:25 <ttt_fff> yeah, the haskell report is more readable than most C++ _books_ explaining virtual functions / dispatch tables / template black magic errors
14:50:11 <mniip> @let (∈) = elem
14:50:13 <lambdabot>  Defined.
14:57:28 <mniip> using ghc-api how would I get a value with a known type from a dynamicaly loaded module?
14:58:44 <enthropy> mniip: you could look at how ghci does :browse?
14:58:56 <mniip> where would I look at that
14:59:40 <mniip> also if it's not clear, the module is loaded at runtime, the value name is known at compile time and the value type is present in the host program
14:59:49 <mniip> and is also known at compile time
15:00:04 <enthropy> https://github.com/ghc/ghc/blob/master/ghc/InteractiveUI.hs#L1666
15:00:35 <enthropy> ghci loads modules that were not present when ghci was compiled
15:00:54 <mniip> sure
15:01:05 <mniip> I don't think that code has anything to do with my problem
15:01:59 <enthropy> well if you have a list of things exported from a module, you can pick one from the list that matches your known type
15:02:42 <mniip> nonono
15:02:46 <mniip> I know the name
15:02:52 <mniip> the question is how do I extract the value
15:03:23 <ReinH> mniip: Maybe UnicodePrelude is for you
15:03:59 <phryk> platz: Thanks, the automated testing is a nice touch, seems way more practical than project euler. :)
15:04:11 <enthropy> oh then hint probably covers that case
15:04:15 <mniip> something like 'Module -> Name -> Mayba a'
15:05:51 <enthropy> http://hackage.haskell.org/package/hint-0.4.2.2/docs/Language-Haskell-Interpreter.html#g:8
15:08:41 <mniip> enthropy, huh
15:08:56 <mniip> that thing takes a stringic expression though
15:10:20 <rasen> Does cabal use something like -march=native by default? If not, can I make so?
15:12:07 <JagaJaga> There is a tool to create functions by their type. I forgot it's name. Starts with j or g.. Do smone know what I mean?
15:12:18 <enthropy> @where djinn
15:12:18 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
15:12:32 <JagaJaga> enthropy: thank you!
15:13:31 <enthropy> mniip: I think that's the easiest place to start to get your Module -> Name -> IO (Maybe a)
15:13:58 <mniip> that has nothing to do with name lookup
15:15:15 <JagaJaga> @djinn (a -> b) -> (c -> b) -> Either a c -> b
15:15:16 <lambdabot> f a b c =
15:15:16 <lambdabot>     case c of
15:15:16 <lambdabot>     Left d -> a d
15:15:16 <lambdabot>     Right e -> b e
15:17:36 <Ed__> hello friends
15:17:42 <Ed__> I have a quick question
15:18:16 <Buttons840> ask away
15:18:17 <Ed__> I am doing this find (\x -> (201 < (4^x))) [1..] and it returns Just 4. How do I get it to return 4...
15:18:41 <mniip> if you are sure you won't get Nothing, you can use fromJust
15:18:43 <Axman6> use dropWhile
15:18:59 <mniip> yeah, head . dropWhile is a valid option
15:19:03 <Axman6> oh, you only want 4? or you want [4..]
15:19:07 <Ed__> Or only 4
15:19:11 <Ed__> THanks
15:19:14 <Ed__> I will use dropWhile
15:19:23 <Ed__> havent done haskell in a while
15:19:29 <mniip> also you could just write 4 ;)
15:20:08 <enthropy> mniip: so if you were to convert your Name into a String and then evaluate it that's not what you want?
15:20:23 <mniip> that's an unnecessary layer of complication
15:20:42 <enthropy> sure, but I'm confused how it "has nothing to do with name lookup"
15:21:20 <mniip> if I give it "1+2" it returns 3 instead of trying to find something named 1+2 in the module
15:21:24 <sssilver|> Hey guys, is there an accepted and expected style of coding in Haskell? Similar to PEP-8 in Python. Every snippet I read looks and feels different, and I'd like my style to be consistent with what most other developers would expect.
15:21:34 <tomphreek> print "1" >> print "2"
15:21:45 <enthropy> haskell variables can't be named 1+2
15:21:47 <hiptobecubic> sssilver|, not *really*. Just do what hlint says most of the time.
15:21:48 <mniip> true
15:21:54 <mniip> but still
15:22:31 <coltfred> sssilver|: I was looking for something similar about imports yesterday. It seems people import qualified sometimes but not others, etc.
15:22:47 <sssilver|> yeah, sounds like hell :(
15:22:54 <hiptobecubic> in general you don't want bare import statements
15:22:55 <HeladoDeBrownie> sssilver|, this might be the closest i've seen, although i've seen several minor variations of this that have all looked fine to me, mine included https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
15:23:03 <hiptobecubic> It turns into a lot of maintenance later on
15:23:31 <HeladoDeBrownie> explicitly stating what you want to import is work in the short-term, but it means you know exactly where a binding came from
15:23:46 <mniip> if only ghc-api functions had docs
15:24:01 <HeladoDeBrownie> as opposed to having to perform a possible exponential search of the imported modules
15:24:01 <sssilver|> HeladoDeBrownie: why not just use full qualifiers when referencing the imported symbol?
15:24:14 <coltfred> It seems importing all of Control.Monad is reasonable, but data types not so much
15:24:16 <HeladoDeBrownie> sssilver|, what you mean like import qualified Data.Map as M? that is also acceptable
15:24:25 <Axman6> sssilver|: Stylish-Haskell in Sublime does a decent job formatting things like imports nicely
15:24:29 <hiptobecubic> sssilver|, that's what I do most of the time.
15:24:39 <hiptobecubic> Axman6, stylish-haskell is not related to sublime.
15:24:40 <sssilver|> HeladoDeBrownie: nope, I mean import Data, and then in code use Data.Map
15:24:53 <HeladoDeBrownie> sssilver|, i don't understand. there is no module Data.
15:24:59 <Axman6> ok, well I've only used it in sublime
15:25:14 <hiptobecubic> sssilver|, the modules aren't *actually* hierarchical like that.
15:25:15 <L8D> libffi looks for libffi but I have libffi installed is ffi
15:25:16 <coltfred> sssilver|: import qualified Data.Map as M is the standard I've seen.
15:25:20 <L8D> installed as* ffi
15:25:26 <coltfred> Then M.Map, M.lookup, etc.
15:25:30 <L8D> how can I tell cabal otherwise?
15:25:31 <tdammers> yeah, I tend to kind of settle for a small set of "general purpose" imports that I import bare - Control.Applicative, Control.Monad, Data.Maybe, Data.List
15:25:41 <hiptobecubic> sssilver|, it's only a convention. "Data.Map" and "Data.IntMap" are not children of "Data".
15:25:43 <L8D> like libffi is in include/ffi.h
15:25:44 <tdammers> and everything else is either qualified or specific
15:25:52 <coltfred> Interesting.
15:25:58 <HeladoDeBrownie> import qualified Whatever as W is perfectly okay, it tells you exactly where everything from that module comes from where you use it; the only problem is that it may become verbose and, with infix application, weird.
15:26:02 <sssilver|> OK then do import Data.Map, and use Data.Map.lookup in the code
15:26:16 <HeladoDeBrownie> sssilver|, that's probably overkill
15:26:18 <sssilver|> that way you make everything explicit, which is always better than implicit
15:26:27 <tdammers> oh, and data structure imports like Data.Map, Data.Vector, Data.Text, etc., usually get a pair of imports:
15:26:36 <HeladoDeBrownie> i don't want to be typing the module name everywhere, at most a convenient abbreviation of it
15:26:37 <tdammers> import qualified Data.Text as Text; import Data.Text (Text)
15:26:49 <sssilver|> HeladoDeBrownie: that's how we always write our Python code, and I know it sounds crazy but it's actually a really good way to make code that other developers can easily read and understand without using search
15:26:57 <coltfred> tdammers: because Text.Text?
15:27:11 <L8D> does anyone know how to install libffi properly on OS X?
15:27:17 <tdammers> coltfred: yes, and also because typically the Text type is used way more than anything else from that module
15:27:24 <hiptobecubic> sssilver|, you never do "from os.path import join" or "import numpy as np" ?
15:27:29 <sssilver|> HeladoDeBrownie: the problem with your abbreviations is that they're done per your taste. And `M` sounds like a horribly unreadable abbreviation for anything starting with an M
15:27:30 <HeladoDeBrownie> sssilver|, python has a different set of problems from haskell.
15:27:40 <coltfred> sssilver|: In haskell it also seems common to break up into lots of files (and modules)
15:27:44 <tdammers> coltfred: writing things like :: Text.Text -> Text.Text -> [Text.Text] -- gets old quick
15:27:45 <HeladoDeBrownie> sssilver|, the abbreviations can easily be looked up in the imports list.
15:28:04 <coltfred> tdammers: I was doing T.Text -> T.Text, etc
15:28:10 <sssilver|> hiptobecubic: never, that's against our style guide. Always only use `import`, without `from`. I believe it's the same in Google. And we're a pretty big public software company ourselves.
15:28:12 <hiptobecubic> sssilver|, the trick is that there are very strong conventions around it. M is pretty much *always* a map of some kind. V is Vector, etc. It's not just whatever starts with M or V.
15:28:13 <coltfred> but I was kinda flailing
15:28:13 <tdammers> coltfred: sure, that'd work too
15:28:37 <sssilver|> HeladoDeBrownie: yeah, so can variable names. Yet good variable naming saves a lot of time.
15:28:51 <coltfred> hiptobecubic: Interesting.
15:28:56 <HeladoDeBrownie> sssilver|, i'm not sure what you're getting at with that statement.
15:28:58 <tdammers> except ByteString / lazy ByteString... those I often abbreviate to BS and LBS
15:29:00 <coltfred> What about Traversable, etc?
15:29:05 <tdammers> especially when I need both in the same file
15:29:20 <sssilver|> HeladoDeBrownie: experience shows that absolute imports + full qualifiers = ultimate readability, that's what
15:29:36 <HeladoDeBrownie> sssilver|, what are "absolute imports" and "full qualifiers"?
15:29:37 <phaazon> is it sane using UndecidableInstances?
15:29:47 <hiptobecubic> it's like "np" being numpy in (scientific) python code. It just is. Always. Nothing else will ever be np. If anyone tried to make 'np' not be numpy it would *definitely* fail review. I think people would even complain in the comments of a blog post that did it.
15:30:16 <sssilver|> HeladoDeBrownie: full qualifiers as in use Data.Map.lookup in the code
15:30:27 <HeladoDeBrownie> sssilver|, i think we have different opinions of "readable".
15:30:32 <n4x> Data.Map. becomes annoying after writing it two times
15:30:33 <hiptobecubic> HeladoDeBrownie, "absolute" meaning specifying the full import path. Full qualifiers as in using 'qualified' without 'as'
15:30:37 <L8D> is it just me or does sssilver| seem like a troll?
15:30:39 <n4x> M.lookup is clear enough
15:30:51 <HeladoDeBrownie> L8D, i don't think they're trolling.
15:30:53 <hiptobecubic> L8D, nah. just a python dev.
15:30:55 <coltfred> qualified imports seem to be the clear winner.
15:31:14 <phaazon> who actually fully write module paths? :D
15:31:33 <HeladoDeBrownie> i don't think haskell has an equivalent to python's not writing the full module name
15:31:37 <HeladoDeBrownie> at least in the import list
15:31:43 <sssilver|> phaazon: you'll be surprised
15:31:54 <phaazon> what do you mean HeladoDeBrownie ?
15:32:00 <phaazon> I never write « Data.Map.lookup »
15:32:05 <phaazon> I write M.lookup
15:32:17 <HeladoDeBrownie> phaazon, python has relative module imports, import a module based on where the current one is in the hierarchy.
15:32:18 <n4x> being able to define scoped "aliases" would be cool though
15:32:32 <phaazon> HeladoDeBrownie: yeah
15:32:41 <sssilver|> OK so M by convention is Map, and everyone is supposed to know it, so they don't have to go back and forth. What if you're using Gloss? Or something else?
15:32:42 <phaazon> well
15:32:49 <phaazon> that doesn’t seem really important to me
15:32:58 <hiptobecubic> phaazon, in python you can do things like "import .some_sibling_module" instead of writing ou tthe full path like "import foo.bar.some_sibling_module" if you're already in foo.bar
15:32:59 <HeladoDeBrownie> sssilver|, you may write out a reasonable name, such as Gloss in this example.
15:33:04 <phaazon> I’d rather like seeing modules morphisms than that
15:33:36 <phaazon> sssilver|: than call it Gloss?
15:33:43 <phaazon> import Graphics….Gloss as Gloss
15:33:50 <hiptobecubic> sssilver|, right. Or hopefully that code is in a module dedicated to doing graphics and "GL" will be totally obvious.
15:34:11 <sssilver|> hiptobecubic: never assume obvious things, when reading someone else's code
15:34:12 <HeladoDeBrownie> sssilver|, if you're wondering where i'm coming from, one of my goals in writing code is to repeat myself only as much as necessary. thus i feel that writing out the entire module name every time i use a binding from it goes against that. i use this rule for myself because i think it reduces noise in source code.
15:34:58 <phaazon> is this python that has an ultra ugly integrated squared product for tuples?
15:35:03 <HeladoDeBrownie> and as someone who doesn't like to have to be clever to read source code, reducing noise is valuable because it means i can easily notice pertinent details.
15:35:33 <mpickering> but if you don't qualify imports it is sometimes very difficult to find where functions are defined
15:35:53 <hiptobecubic> phaazon, ?
15:35:57 <mniip> I think obtainTermFromId does what I need but I can't confirm because it has no docs :/
15:35:57 <sssilver|> mpickering: exactly
15:36:00 <HeladoDeBrownie> mpickering, earlier i and some others mentioned how if you write explicit imports you can find things easily
15:36:04 <phaazon> something like %/~
15:36:30 <L8D> phaazon: Lens has /~
15:36:39 <phaazon> yeah
15:36:40 <n4x> I only non-qualify imports from things like Control.Applicative/Data.Functor/Control.Monad
15:36:42 <HeladoDeBrownie> mpickering, and while what i just said does partly argue against qualified imports, sometimes they are necessary; but what is not necessary in my view is writing the entire module name, which is usually long.
15:36:43 <phaazon> it also has ^@..
15:36:47 <phaazon> and <>=
15:36:51 <L8D> or //~ because /= is taken and they want to keep things consistent
15:36:53 <voidzero> i thought ghci's :info was what you'd use to learn the origins of a function
15:36:53 <phaazon> or <>~
15:36:56 <edwardk> /~ and //= sadly, we can't have /~ because then we'd need /= and that is kinda taken
15:37:03 <edwardk> er //~
15:37:18 <mpickering> HeladoDeBrownie: I agree and am also guilty of failing to qualify my imports
15:37:24 <L8D> edwardk: why % and not $ ?
15:37:30 <phaazon> for mod
15:37:30 <L8D> I’ve always wondered that
15:37:32 <phaazon> like « modify »
15:37:35 <HeladoDeBrownie> mpickering, you don't necessarily have to feel guilty, it *is* a tradeoff, and sometimes not worth it.
15:37:37 <L8D> eh.
15:37:43 <edwardk> L8D: % is a pun, to someone who comes from the C++ world they read % as 'mod'
15:37:54 <L8D> $ makes more sense because function application and <$> and such
15:37:58 <L8D> as a 'map'
15:38:02 <mpickering> GHC should expose the method which is uses to generate -ddump-minimal-imports
15:38:13 <edwardk> $= actually has the wrong meaning, we adopt a rule that op=     applies the operator with the current value on the left and the new value on the right
15:38:16 <mpickering> It's all baked in to write to file iirc
15:38:19 <edwardk> and $ would have that precisely reversed
15:38:30 <L8D> oh yeah....
15:38:34 <bubano> Are lists, trees, etc considered functors?
15:38:44 <phaazon> they’re not “considered”
15:38:45 <phaazon> they are
15:38:51 <edwardk> bubano: you can package them up as much
15:39:13 <bubano> I'm having a hard time understanding that. I thought functors were morphisms between categories.
15:39:24 <phaazon> bubano: in Haskell
15:39:27 <edwardk> bubano: these are functors from the category of haskell data types to itself
15:39:28 <c_wraith> bubano: sure.  the categories are Haskell types
15:39:28 <phaazon> they’re endofunctors
15:39:49 <HeladoDeBrownie> f : Hask → Hask
15:39:52 <n4x> bubano: all Haskell functors are endofunctors from Hask (haskell types) to itself
15:39:56 <edwardk> fmap :: (a -> b) -> (f a -> f b) -- takes a morphism (a function) in that category and gives you another morphism (function) in that same category.
15:40:18 <phryk> Where can I find a listing of all builtin types and typeclasses? Searching through the web at large, the wiki as well as the language spec doesn't turn anything up for me… :/
15:40:28 <bubano> so the list (as an example) is a morphism itself?
15:40:34 <phaazon> phryk: have a look at base
15:40:35 <mniip> phryk, http://www.haskell.org/hoogle is a good entrypoiny
15:40:36 <phaazon> on hackagedb
15:40:37 <mniip> point
15:40:44 <HeladoDeBrownie> bubano, the [] constructor, not a given list
15:40:51 <HeladoDeBrownie> type constructor*
15:40:53 <c_wraith> phryk: haskell has approximately one builtin type (->) and zero built-in classes.  Everything else comes from libraries.
15:41:04 <mniip> c_wraith, :
15:41:10 <phaazon> c_wraith: well
15:41:15 <edwardk> cmccann:  you get a few extras with lists and tuples and the like
15:41:16 <phaazon> Monad is kinda built-in, right?
15:41:21 <edwardk> er c_wraith
15:41:28 <mniip> nope Monad comes from Prelue
15:41:30 <HeladoDeBrownie> do notation is built in, Monad is not
15:41:31 <mniip> Prelude
15:41:39 <phaazon> uh, wat
15:41:46 <bubano> I need to read up on typeclasses and constructors...
15:41:47 <phaazon> Monad comes from Control.Monad
15:41:49 <phaazon> which is from base
15:41:58 <mniip> yeah
15:41:58 <phaazon> and I guess GHC has internal code for dealing with them
15:42:02 <L8D> wait... did AMP replace MonadPlus with Alternative?
15:42:04 <edwardk> mniip: i'm referring to what comes in the compiler itself. Prelude is implemented with remarkably little magic
15:42:07 <HeladoDeBrownie> well, the general idea is you can write Monad yourself. you cannot write (->) yourself.
15:42:11 <L8D> Or is MonadPlus just a subclass of Alternative
15:42:14 <mniip> yeah
15:42:21 <edwardk> L8D: we still have both,
15:42:36 <edwardk> technically nobody has a concrete proof that the Alternative laws + Monad laws imply the MonadPlus laws
15:42:38 <phryk> Ah, thanks guys, I found the 'base' package on hackage. :)
15:42:46 <mniip> edwardk, are you including stuff like IO
15:42:51 <c_wraith> phaazon: ghc has no extra code for handling monads...  the only specialness with them comes from the desugaring of do notation, but that's more or less syntactic, and just happens to map to the names >> and >>= in scope
15:42:55 <edwardk> given that there are ~3 sets of candidate laws for MonadPlus it is kinda messy
15:43:01 <cmccann> MonadPlus has laws?
15:43:10 <cmccann> well, I guess it has plenty, that's the problem
15:43:29 <phaazon> c_wraith: yeah, but which part of it make the desugaring?
15:43:34 <edwardk> mniip: GHC has what it calls "WiredIn" references to several different types. e.g. the compiler needs to know how we implement IO for FFI, it has to know about things like Maybe and Bool for various primops, Int, Integer, Natural, etc.
15:43:35 <HeladoDeBrownie> MonadPlus is a wild west town; it has laws, but in practice the outlaws often break them
15:43:47 <mniip> yeah yeah
15:44:07 <L8D> then what is the difference between MonadPlus and Alternative in AMP?
15:44:12 <L8D> MonadPlus has the Monad requirement?
15:44:16 <HeladoDeBrownie> L8D, the latter also implies Monad
15:44:23 <HeladoDeBrownie> former*
15:44:28 <HeladoDeBrownie> i somehow read them in the wrong order.
15:44:33 <L8D> lame
15:44:48 <edwardk> mniip: but the set of types that the compiler itself provides completely from scratch without a corresponding definition hiding in ghc-prim or base is quite small
15:45:00 <mniip> 'if' references Bool, numeric literals reference Integer, 'do' references Monad
15:45:00 <edwardk> the set of things it knows a lot about the implementation of is a bit larger
15:45:03 <mniip> not sure about Maybe
15:45:19 <c_wraith> the RebindableSyntax extension disables most of that.
15:45:19 <L8D> will Haskell ever get idiom brackets?
15:45:26 <HeladoDeBrownie> hmm, technically ($) is one of those things you cannot implement yourself, because shenanigans :P
15:45:28 <edwardk> Maybe shows up in prims. 'do' doesn't need to reference Monad. you can typecheck do sugar without it.
15:45:28 <n4x> HeladoDeBrownie: non-strict reading?
15:45:29 <L8D> or is there an extension for doing that with quasi quoting?
15:45:36 <HeladoDeBrownie> n4x, XD
15:45:37 <edwardk> > 3 * do 4 + 5
15:45:38 <mniip> edwardk, GHC definitely provides the list type as a built in
15:45:38 <lambdabot>  27
15:45:43 <edwardk> mniip: sure
15:45:48 <edwardk> that was on my list
15:46:00 <c_wraith> mniip: it provides syntax, but there's nothing special about the type.  Same as tuples.
15:46:00 <edwardk> ($) is magic
15:46:09 <mniip> yeah
15:46:10 <c_wraith> ($) is way more magic than lists or tuples.
15:46:14 <mniip> you can easily reimplement List
15:46:20 <mniip> ($) = id
15:46:23 <cmccann> ($) is magic because of the runST hack, right?
15:46:27 <HeladoDeBrownie> list and tuple magic is syntactic, not semantic
15:46:29 <edwardk> mniip: actually you can't
15:46:37 <edwardk> write that then try to do runST $ do ...
15:46:39 <edwardk> your ($) fails
15:46:41 <c_wraith> cmccann: correct
15:46:42 <edwardk> the builtin one works
15:46:46 <edwardk> it has a custom typing rule
15:47:00 <n4x> that's evil!
15:47:06 <HeladoDeBrownie> n4x, agreed
15:47:08 <cmccann> that's such a weirdly hilarious one-off hack
15:47:09 <edwardk> n4x: evil, useful.
15:47:14 <phaazon> hm, that,s boring me. I have an instance for MonadJournal for StateT, like so: (MonadJournal w m,Monoid w) => MonadJournal w (StateT s m) … ; now, I have a newtype over StateT (IO ()), and I can’t find a way to make it an instance of MonadJournal ; that would be inferred, right? I got an illegal instance stating the functional dependency m -> w is broken ; any idea?
15:47:15 <voidzero> math just flew out of the window here
15:47:19 <HeladoDeBrownie> edwardk, what even is the difference? :P
15:47:30 <bubano> In fmap :: (a -> b) -> (f a -> f b), fmap is the actual (?) morphism that maps one category and morphism to another?
15:47:49 <bubano> In other words, fmap is the actual functor?
15:47:57 <n4x> we just need a more-powerful type system!
15:47:58 <c_wraith> bubano: fmap is the natural transformation between the categories
15:48:28 <cmccann> bubano: fmap and the type constructor represented by the variable "f" together are the functor
15:48:36 <c_wraith> bubano: the Functor is the pair of type constructor and natural transformation
15:48:44 <edwardk> HeladoDeBrownie: ($) allows its type variables to be bound to polytypes, this is a form of ImpredicativeTypes your manual ($) = id doesn't
15:49:06 <phaazon> I guess making an instance of a typeclaass out of the original module makes an UndecidableInstance :(
15:49:38 <HeladoDeBrownie> edwardk, i meant between evil and useful :P
15:49:56 <c_wraith> phaazon: not necessarily.  It makes it an Orphan instance unless it's the same instance the type is defined in, though.
15:50:01 <phaazon> which extension is dangerous again?
15:50:07 <phaazon> ImpredictiveInstances?
15:50:11 <c_wraith> a bunch
15:50:12 <phaazon> UndecidableInstances?
15:50:18 <c_wraith> Undecideable is harmless, though
15:50:24 <phaazon> ah
15:50:27 <phaazon> great then
15:50:35 <phaazon> I wonder why it’s not enabled by default
15:50:39 <phaazon> like Flexible*
15:50:40 <cmccann> the worst UndecidableInstances can do is make the compiler hang
15:51:02 <c_wraith> In reality, it can't even hang the compiler, because it has a built-in recursion limit.
15:51:12 <cmccann> c_wraith: not that hard to circumvent
15:51:24 <c_wraith> Of course, that means that there are valid programs it can't compile because the recursion limit exists!
15:51:25 <Enigmagic> IncoherentInstances is the bad one
15:51:36 <c_wraith> OverlappingInstances is nearly as bad as IncoherentInstances
15:51:37 * hackagebot vcache 0.1 - large, persistent, memcached values and structure sharing for Haskell  http://hackage.haskell.org/package/vcache-0.1 (dmbarbour)
15:51:44 <mniip> ok so back to my problem
15:51:45 <c_wraith> Incoherent is just Overlappinger
15:51:50 <cmccann> c_wraith: as long as it generates new constraints instead of recursing, it can end up in an infinite "loop"
15:51:50 <Enigmagic> yeah
15:51:54 <mniip> how would I get a value out of a dynamically loaded module
15:52:08 <mniip> without interpreting expressions, just a name lookup
15:52:09 <c_wraith> cmccann: ah, interesting
15:52:10 <phaazon> have you looked at the package called plugin?
15:52:35 <mniip> nah I'm already into ghc-api
15:52:47 <phaazon> yay! UndecidableInstances makes my work compile
15:52:48 <phaazon> thanks ;)
15:52:55 <phaazon> mniip: I don’t know ghc-api, sorry
15:53:02 <HeladoDeBrownie> i'm not sure if that's a good thing.
15:53:04 <HeladoDeBrownie> i haven't decided
15:53:10 <c_wraith> mniip: if you don't interpret an expression, what does the name lookup resolve *to*?
15:53:26 <mniip> to a value
15:53:32 <c_wraith> mniip: what *type*?
15:53:39 <primepie> whom should I contact if I want to offer/Sponsor haskell.org website with a website monitoring service plan from webmon.com?
15:53:40 <mniip> the type is known at compile time
15:54:13 <TheLemonMan> before i hurt myself with yet another tutorial about tacos, can anyone point me to a (simple ?) clear introduction to monads ?
15:54:19 <c_wraith> mniip: when you're using the ghc api, there's some compiling happening at run time..  How are you going to work with that?
15:54:33 <mniip> nononono
15:54:40 <c_wraith> mniip: the hint library, for instance, is one example of actually solving that issue.
15:54:42 <mniip> I mean someone offered a generic expression evaluation function
15:54:53 <geekosaur> primepie, #haskell-infrastructures would be a good starting place
15:54:57 <mniip> which takes "foo" as happily as "1+2"
15:55:02 <geekosaur> um
15:55:10 <geekosaur> #haskell-infrastructure
15:55:21 <primepie> geekosaur: thank you!
15:55:21 <cmccann> primepie: see also https://wiki.haskell.org/Haskell.org_committee
15:56:03 <kakashiA1> hello guys, I started with haskell a bit and read some category papers, but for me its just functional algebra (what you can do with a function etc.)
15:56:25 <kakashiA1> does anybody have a very simple example/problem that you can solve with category theory
15:56:44 <kakashiA1> I mean a real life problem
15:57:32 <kakashiA1> at the moment I see no need how category theory can help me to solve problems
15:57:38 <voidzero> it solves boredom
15:57:44 <c_wraith> kakashiA1: eh.  category theory is about finding underlying structures that other branches of math share.  It's not about solving problems so much as understanding math better.
15:57:51 <rasen> Is there any easy binding for StackedLayouts in charts?
15:57:57 <NemesisD> ugh, has anyone upgraded to the latest cabal release? i'm getting tons of "package.conf.inplace already exists" errors
15:57:58 <rasen> Chart*
15:58:55 <kakashiA1> c_wraith: okay, but a lot of functional programmers say that you can model and solve problem with category theory
15:58:55 <AdituV> sorry, nemesis.  but speaking of cabal, does anyone know of a cabal file line to replace the --with-gcc option?
15:59:46 <sssilver|> Hmm guys, anyone else having a problem installing gloss on Ubuntu? https://dpaste.de/chCa
15:59:59 <mniip> c_wraith, so uh
16:00:00 <kallisti> AdituV: I believe ghc-options should work for that purpose, no?
16:00:15 <NemesisD> sssilver|: have you tried reconfiguring the project?
16:00:24 <kallisti> AdituV: oh that's a cabal option not a GHC option
16:00:28 <AdituV> Maybe.  This is for FFI with hsc2hs (and my first time doing so) so I'm not really sure :)
16:00:32 <sssilver|> NemesisD: nope, how do I do that?
16:00:38 <NemesisD> sssilver|: cabal configure
16:01:05 <sssilver|> NemesisD: but I'm just trying to globally install the gloss package
16:01:14 <sssilver|> NemesisD: my project doesn't have a cabal file (yet)
16:01:19 <HeladoDeBrownie> kakashiA1, for solving individual problems, you often don't need the abstraction provided by ct. however it is useful for coming up with abstractions, which comes most into play when it comes to writing libraries, rather than applications, i think
16:01:20 <c_wraith> kakashiA1: meh. It's much more about finding a categorical structure that appears often in software people find well-designed, and then using that knowledge to inform the design of new libraries.
16:01:30 <NemesisD> oh, nm then
16:01:40 <NemesisD> you're a braver person than me
16:02:41 <benzrf> in practice is ghc smart enough to optimize something like "zipWith f xs ys = map (uncurry f) (zip xs ys)" into something roughly equivalent to the actual definition?
16:03:04 <bubano> Is it roughly correct to say that functors take a function on one type of data and transform the function to work with a new data type?
16:03:11 <NemesisD> aaand hackage is down
16:03:14 <benzrf> bubano: sort of
16:03:14 <phaazon> I got a 503 on hackagedb :(
16:03:45 <benzrf> bubano: to be really precise they take a morphism in one category to a morphism in another category, where in haskell morphisms are functions
16:03:55 <benzrf> bubano: but you dont need to know that to use them :)
16:04:17 <sssilver|> NemesisD: I created a cabal file and cabal configure fails as it would -- https://dpaste.de/K2Ek
16:04:36 <bubano> benzrf: gotcha. I'm actually coming from the math side of things which is why I'm so keen on bridging the gap in my mind
16:04:41 <benzrf> ah neat
16:04:45 <NemesisD> sssilver|: you have to install dependencies in that case: cabal install --only-dependencies
16:04:53 <NemesisD> sssilver|: i'd also recommend a sandbox
16:05:13 <sssilver|> NemesisD: if I do that, then I get the previous error of one OpenGL shadowing the other
16:05:44 <NemesisD> yeah sounds like theres some sort of dependency issue in the package
16:05:55 <NemesisD> im not sure
16:06:57 <bubano> benzrf: In the case of Haskell types then, we are talking about subsets correct?
16:07:15 <benzrf> hmm not really
16:07:52 <bubano> (Integer -> Integer) -> ([Integer] -> [Integer]) , as a concrete example
16:08:13 <bubano> taking a morphism on Integers and getting a morphism on lists of integers
16:08:19 <phaazon> arf dammit
16:08:34 <phaazon> I can’t use StandalaneDeriving to derive MonadBaseControl
16:08:40 <phaazon> because it has associated types
16:08:50 <benzrf> bubano: the category of lists of integers
16:08:59 <benzrf> bubano: it's an endofunctor
16:09:08 <benzrf> like an endomorphism
16:09:31 <bubano> right, but isn't the list of integers included in the "set" of haskell types?
16:09:41 <bubano> or rather "collection"
16:11:25 <kallisti> phaazon: https://github.com/kallisti-dev/hs-webdriver/blob/master/src/Test/WebDriver/Monad.hs#L32
16:11:39 <kallisti> phaazon: here's an example of what a MonadBaseControl instance looks like
16:12:44 <phaazon> yeah I know
16:12:55 <phaazon> I had to write one for my JournalT type
16:12:58 <AdituV> @bubano: I think yes.  You can see fmap as both an endofunctor in 'Hask' and a functor from (H, H -> H) to ([H], [H] -> [H]) where H represents Hask's underlying set.  (Warning: I'm an undergrad who has only skimmed the surface of category theory)
16:12:58 <lambdabot> Unknown command, try @list
16:13:02 <phaazon> I’ll do that later though, I’m tired
16:13:06 <phaazon> see you later
16:13:10 <AdituV> bubano: I think yes.  You can see fmap as both an endofunctor in 'Hask' and a functor from (H, H -> H) to ([H], [H] -> [H]) where H represents Hask's underlying set.  (Warning: I'm an undergrad who has only skimmed the surface of category theory)
16:13:11 <phaazon> thanks anyways kallisti
16:13:57 <Welkin> Khaleesi
16:14:43 <phaazon> hm
16:14:54 <phaazon> GHC gives me a wrong instance of MonadState
16:14:56 <phaazon> that’s pretty weird
16:14:58 <n4x> Welkin: where are the dragons?
16:15:28 <phaazon> https://github.com/phaazon/quaazar/blob/scoped_resource/src/Quaazar/Utils/Scoped.hs#L45 that line won’t compile
16:15:34 <bubano> AdituV: ok. so In a practical sense, defining the natural transformation (fmap) on a desired type would allow one to be able to use general functions on that type
16:16:37 * hackagebot egison-tutorial 3.5.1 - A tutorial program for the Egison programming language  http://hackage.haskell.org/package/egison-tutorial-3.5.1 (SatoshiEgi)
16:21:04 <mniip> anyone here familiar with ghc-api?
16:33:15 <caconym> I need to serialize some data from Haskell into a format that can be relatively easily parsed from both Haskell and possibly JS. Should I write my own format, or?
16:34:54 <arw_> try json?
16:34:59 <Cale> caconym: Maybe use JSON via a library like aeson?
16:35:04 <geekosaur> JSON via the aeson package, I'd think
16:35:15 <caconym> sounds reasonable
16:35:51 <Cale> caconym: aeson has some type classes you can implement instances of in order to specify how your Haskell datastructures are encoded as JSON values
16:36:17 <Cale> caconym: and if you don't care much about the particulars, it also has a bunch of template haskell macros for generating instances
16:37:34 <caconym> Cale: yeah, the particulars aren't terribly important. sounds like aeson is the right choice then, thanks :)
16:38:37 <Cale> caconym: Or actually, there's some new GHC Generic magic, so you can just add a deriving Generic to your datatype declaration, and then write an empty instance of ToJSON/FromJSON, and it'll work :)
16:38:55 <caconym> Cale: what's this new generic magic?
16:39:27 * caconym doesn't actually know much about generics or TH or what the difference is.
16:39:39 <Cale> this stuff: http://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-Generics.html
16:41:09 <Cale> You can use deriving Generic, which will provide an instance of the Generic typeclass for free, and that gives you from and to methods which will convert between your datatype and a finite bunch of datatypes in terms of which almost any Haskell datatype can be encoded.
16:42:52 <caconym> Cale: so how does it 'know' to use the Generic instance to construct implementations for ToJSON/FromJSON?
16:43:11 <Cale> Because there are default method implementations in the class declaration for ToJSON and FromJSON
16:43:31 <Cale> class ToJSON a where
16:43:31 <Cale>     toJSON   :: a -> Value
16:43:32 <Cale> #ifdef GENERICS
16:43:32 <Cale>     default toJSON :: (Generic a, GToJSON (Rep a)) => a -> Value
16:43:33 <Cale>     toJSON = genericToJSON defaultOptions
16:43:33 <csd_> How can I get the following to work properly: I have a function that reads in from a file and stores the result as [Company] where a Company is a String. Then, I want to map putStrLn to [Company] and am having a difficult time doing it
16:43:35 <Cale> #endif
16:43:50 <caconym> you can define default implementations that only apply if a... whatever you call the thing before the =>... matches?
16:44:03 <Cale> caconym: Yeah, that's a new feature as well
16:44:06 <caconym> neat
16:44:16 <caconym> how new is new?
16:44:38 <Cale> ummm... either 7.6 or 7.8, I think
16:45:13 <Cale> csd_: mapM_ putStrLn
16:45:39 <csd_> Cale: I already tried that
16:45:50 <Cale> csd_: If you map putStrLn over your list, you get a list of IO actions, each of which if executed would print the name of a single company
16:46:41 <Cale> csd_: There's a function called sequence, which given a list of actions will construct the action which executes each in turn, and collects a list of the results
16:46:53 <csd_> Cale: here are the errors i get doing that https://www.refheap.com/97334
16:47:15 <Cale> What type is getCompanies?
16:47:24 <csd_> IO [Company]
16:47:43 <Cale> right, so it's an action, which if you were to execute it, would give you a list of companies
16:47:52 <csd_> sure
16:47:57 <Cale> So, you need to execute that action first, and pass its *result* to the mapM_
16:48:10 <jle`> i just thought of a really good idea y'all
16:48:17 <Cale> i.e.  do xs <- getCompanies; mapM_ putStrLn xs
16:48:37 <jle`> using unsafePerformIO for runtime warnings of incorrect API usage
16:48:56 <Cale> "Warning: You are using unsafePerformIO"
16:49:00 <csd_> Cale: oh, i follow, thank you
16:49:01 <jle`> warning: please don't pass in 0 here
16:49:29 <jle`> when passing in 0 still can create input but the input is meaningless
16:50:16 <HeladoDeBrownie> jle`, i feel like that should be a primitive all on its own; warn or something. that way we can enforce more useful semantics
16:50:18 <Stratege> why not just change the function so that either: 1. the meaninglessness is obvious (via Maybe, perhaps?) or 2. there is no meaninglessness anymore or 3. it just fails loudly with a crash?
16:51:14 <jle`> but those aren't disruptive solutions
16:51:24 <Cale> Also, just how meaningless can it be? Might the 0 show up as the base case in some recursive usage?
16:51:42 <jle`> it is a contrived example o-k
16:51:58 <Cale> all right :)
16:52:04 <jle`> at the very least it is advised against by the API documentation :)
16:52:13 <jle`> i would use TH to enforce it at compile-time
16:52:13 <Cale> But yeah, you could use Debug.Trace.trace for that
16:52:24 <jle`> but not all of the arguments are going to be known at compile-time
16:52:48 <jle`> my TH would erase the user's project directory for being so foolish and not reading the documentation of course
16:53:12 <csd_> Cale: something still isn't right https://www.refheap.com/97335 -- can you please take another look?
16:53:51 <cmccann> jle`: well, GHC used to have a feature where it would delete your program if it had type errors, didn't it
16:54:02 <jle`> really?
16:54:10 <HeladoDeBrownie> using "feature" liberally
16:54:10 <jle`> if it doesn't anymore, it should be re-implemented
16:54:16 <cmccann> yeah, "feature" :D
16:54:25 <jle`> haskell, extreme difficulty/roguelike mode
16:54:25 <Cale> csd_: Now there's at least one problem:  map (putStrLn . getCompany) companies   is some sort of list, but it's sitting in a position where an IO action is expected
16:54:30 <cmccann> I forget what the deal with that bug was, but it's hilarious
16:54:32 <Cale> csd_: It's a list of IO actions
16:54:35 <solatis> is there any way i can protect myself from stack / infinite recursion 'bombs' in haskell?
16:54:58 <jle`> solatis: use something like LiquidHaskell? :)
16:55:01 <solatis> as in, where a bug in your code enters recursion $alot of times and your computer decides to stop working
16:55:08 <cmccann> solatis: does installing agda count as "in haskell"
16:55:09 <jle`> oh
16:55:15 <csd_> Cale: so should it not be [IO ()], but rather IO ()?
16:55:21 <jle`> you mean, if your program has the correct logic, but haskell runtime doesn't let you do it?
16:55:42 <Cale> That's right, you've written something of type [IO ()] but the correct program would have something of type IO () there
16:55:52 <Cale> csd_: The right solution is probably to use mapM_ in place of map there, but let's take a look at what we might do with a list of IO actions
16:55:56 <solatis> well, in my case a program recursively consuming a buffer but keeps going because it is consuming 0 bytes
16:55:59 <solatis> so a bug in my program
16:56:01 <HeladoDeBrownie> solatis, one way might be to spawn a new thread, do the computation there, kill the thread if it diverges (this is the default behavior if the divergence is obvious) or after a time limit
16:56:13 <csd_> Cale: just got it to typecheck, thanks
16:56:20 <solatis> no this is about a bug in my program
16:56:32 <csd_> I changed the type of main to IO ()
16:56:34 <solatis> but solving the bug is a pain if your computer keeps hanging
16:56:51 <solatis> maybe i should just add a threadDelay statement..
16:56:55 <csd_> I figured that [IO ()] would refer to the IO [Company], rather than a list of actions
16:56:56 <Cale> csd_: The obvious thing to do with a list of type [IO a] is to combine them together into a single action which will run each of the actions in turn and collect a list of the results as its result
16:57:33 <Cale> csd_: I think it's really instructive to look at the implementation of such a function  sequence :: [IO a] -> IO [a]
16:57:50 <Cale> We can write it recursively by pattern matching on the list
16:57:53 <Cale> sequence [] = ...
16:58:09 <Cale> If the list is empty, we want to give the action which does nothing, but produces an empty list as its result
16:58:15 <Cale> That action is called  return []
16:58:17 <solatis> jle`, btw many many thanks for helping me out last month with the monad wrapping hell
16:58:22 <Cale> sequence [] = return []
16:58:30 <Cale> sequence (x:xs) = ...
16:58:43 <solatis> i've been writing all my code like (MonadIO m, MonadError String m) => m () now, it is so much better!!
16:58:51 <Cale> If the list is not empty, well, we want to produce an action which is going to first run x...
16:58:56 <Cale> sequence (x:xs) = do v <- x; ...
16:59:03 <Cale> So we get some result v from running x
16:59:29 <Cale> and then we want to run the rest of the actions in the list -- thankfully we have a function to do that, the one which we're writing:
16:59:37 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; ...
16:59:49 <Cale> So we get some list vs of the results of the rest of the actions
16:59:51 <jle`> solatis: congrats :D
17:00:05 <jle`> it sort of separates the logic of transformers from the actual logic you are trying to implement
17:00:07 <jle`> which is good
17:00:11 <solatis> yeah
17:00:13 <Cale> and then we just need to put together the first result and the rest of the results, and return that as our own result
17:00:17 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
17:00:29 <Cale> csd_: Make sense?
17:00:40 <solatis> i mean, instead of wrapping every monad inside another, this is just so much cleaner...
17:00:57 <csd_> Cale: yes i think so
17:00:59 <solatis> ResourceT ErrorT String IO --> eewww..
17:01:13 <Cale> csd_: So, this is kind of like a primordial loop: if we can decide ahead of time what's supposed to happen on each iteration of the loop and make a list of the actions, sequence can string them all together for us
17:01:29 <solatis> (MonadIO m, MonadResource m, MonadError String m) => m a --> nice!
17:01:30 <Cale> csd_: By combining it with map, we get a sort of "for-each" loop
17:01:35 <csd_> Cale: two more questions. 1-- is there a more elegant way of expressing what i did? and 2-- is it possible to write the type Company such that i dont need to use its getter fn to use it as a String
17:02:10 <Cale> csd_: Well, if you just want a type synonym, you can use  type Company = String
17:02:27 <Cale> and then Company and String will just be identified by the type system
17:02:43 <csd_> ok i should have done that instead of using a newtype
17:02:45 <Cale> It'll never complain when you pass a String when something wanted a Company, and vice-versa then
17:03:15 <Cale> But newtypes can be nice, because you can use them to make sure that your strings get used correctly, or at least willfully
17:04:07 <csd_> Cale: thank you
17:04:18 <AdituV> csd_: As an example, suppose your program also dealt in "type People = String".  You could then use a person as a company or vice versa by mistake
17:04:26 <Cale> If Company and String are the same type, it's easy to accidentally use an Address String where you meant to use a Company String.
17:05:08 <csd_> it would be nice if there were a putStrLn that only required (Show a) rather than String
17:05:29 <kallisti> :t print
17:05:30 <lambdabot> Show a => a -> IO ()
17:05:45 <csd_> well ill be damned
17:05:51 <AdituV> ^^
17:06:37 * hackagebot digestive-functors-lucid 0.0.0.2 - Lucid frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-lucid-0.0.0.2 (athanclark)
17:07:30 <Cale> csd_: Of course, if you apply print to a String, it'll display quoted, because that's what the Show instance does -- generally Show instances will try to produce valid Haskell code for the values, when they can.
17:10:50 <HeladoDeBrownie> also in general readMaybe . show = Just, but there are various violations of this and it's not seen as a big thing
17:11:04 <HeladoDeBrownie> maybe i shouldn't say "in general". often
17:14:46 <ajtulloch> haskell: Is there a way to tell Haddock to only generate documentation for modules listed in exported-modules?
17:14:57 <ajtulloch> sorry, exposed-modules
17:19:11 <athan> Why would cabal-install not be able to find the files associated with Modules, when the library I'm importing installs fine?
17:19:33 <athan> @hackage lucid-foundation <- this is the one I'm trying to use :]
17:19:34 <lambdabot> http://hackage.haskell.org/package/lucid-foundation <- this is the one I'm trying to use :]
17:19:36 <athan> :\*
17:22:02 <glguy> athan: You forgot to add your modules to your lucid-foundation.cabal file
17:22:15 <athan> That's what I thought ><
17:22:19 <athan> thanks glguy!
17:26:41 <Profpatsch> How can I see which version of a package ghci is using?
17:28:03 <mniip> anyone here familiar with ghc-api?
17:28:27 <chrisdotcode> > 1 + 1 -- test
17:28:29 <lambdabot>  2
17:31:38 * hackagebot yesod-purescript 0.0.4.7 - PureScript integration for Yesod  http://hackage.haskell.org/package/yesod-purescript-0.0.4.7 (mp)
17:36:19 * cmccann kinda wishes the default behavior of Data.Map.fromList was equivalent to fromListWith mappend, not fromListWith const
17:36:38 * hackagebot lucid-foundation 0.0.2 - Basic Zurb Foundation API in Lucid  http://hackage.haskell.org/package/lucid-foundation-0.0.2 (athanclark)
17:38:13 <athan> cmcann: There might be a newtype lying around, like ZipList ?:(
17:39:11 <cmccann> athan: that would work going the other way, to get the current version from the mappend version
17:39:23 <cmccann> athan: but in any case it'd be easier to write explicitly
17:39:25 <athan> ahh shoot you're right
17:39:41 <athan> you should complain louder, maybe even a trac ticket? Idk where containers is held
17:40:05 <cmccann> the bigger problem is that I sometimes write "M.fromList" when I meant to use "M.fromListWith mappend" and then I get nonobvious bugs
17:40:44 <cmccann> I doubt it'd happen, it would be a significantly breaking change for a lot of code using containers I expect
17:41:00 <athan> shoot
17:41:03 <athan> make your own!!
17:41:21 <cmccann> I could fork containers just to change that one function!
17:41:26 <cmccann> that wouldn't be ridiculous at all.
17:41:27 <athan> lol
17:41:38 * hackagebot caffegraph 0.1.0.0 - A compiler for building, optimizing, visualizing, and generating (Caffe/Torch) DNNs  http://hackage.haskell.org/package/caffegraph-0.1.0.0 (ajtulloch)
17:44:43 <jle`> Monoid is probably a bit strong, Semigroup is enough
17:46:38 * hackagebot lucid-foundation 0.0.2.1 - Basic Zurb Foundation API in Lucid  http://hackage.haskell.org/package/lucid-foundation-0.0.2.1 (athanclark)
17:50:08 <cmccann> jle`: well yeah, but containers depending on semigroups is even less likely than changing the behavior to begin with :P
17:51:38 * hackagebot lowgl 0.3.0.0 - Basic gl wrapper and reference  http://hackage.haskell.org/package/lowgl-0.3.0.0 (evanrinehart)
17:54:49 <ReinH> There's a futurama joke here
17:56:07 <ReinH> jle`: I suppose once we get FTP and AMP out of the way we can tackle the real hard ones like Semigroup-Monoid
17:57:00 <HeladoDeBrownie> ReinH, i missed it, where?
17:57:30 <jle`> we should just have a design-your-own-base competition
17:57:34 <jle`> and we'll all vote on it
17:57:44 <jle`> who has the best base
17:57:53 <jle`> 8.0
17:58:28 <HeladoDeBrownie> my base will deal with values of a concrete type Func representing untyped lambdas, and operations over them. church encode all the things, compile, run, bam. programming as it's meant to be
17:58:52 <jle`> sounds like more than a library issue :P
17:59:04 <HeladoDeBrownie> who really needs types anyway
17:59:06 <jle`> sounds like a language implementation thing o.o
18:04:31 <cmccann> HeladoDeBrownie: have you seen the acme-php package?
18:04:44 <cmccann> you need to look at the source code to see most of the jokes
18:05:40 <ReinH> jle`: I'm going to create my own base with blackjack and semigroups
18:05:51 <HeladoDeBrownie> cmccann, i have, but i could use a good laugh again
18:06:38 * hackagebot digestive-foundation-lucid 0.0.0.1 - Speed up form designing using digestive functors and foundation  http://hackage.haskell.org/package/digestive-foundation-lucid-0.0.0.1 (athanclark)
18:07:49 <HeladoDeBrownie> cmccann, owowow reading this hurts
18:08:02 <mniip> HeladoDeBrownie, my base will do the same but in the prolog'ish haskell typesystem
18:08:21 <mniip> who needs values anyway
18:08:35 <HeladoDeBrownie> "optimized" "TODO - profiling" XD
18:09:57 <mniip> false = False
18:09:59 <mniip> ಠ_ಠ
18:10:23 <HeladoDeBrownie> true == false is a type error, woopee!
18:11:09 <mniip> a damn messed up type errro
18:11:12 <cmccann> hpc is the mad genius responsible for that btw
18:11:20 <cmccann> in case you find something that works and need to report the issue
18:11:27 <mniip> ah
18:11:34 <mniip> just Couldn't match expected type `Bool' with actual type `GHC.Types.Bool'
18:12:18 <mniip> isn't f x = if f x then False else True
18:12:24 <mniip> how does this typ--- ah
18:13:14 <HeladoDeBrownie> i bet you just noticed the unsafeCoerce
18:13:41 <mniip> (<>) = getLine
18:13:45 <mniip> my sides do not unify
18:14:13 <HeladoDeBrownie> is that a fancy way of saying your sides hurt?
18:14:26 <mniip> notElem x ys = elem (not x) ys
18:15:10 * HeladoDeBrownie taps self on the nose. bad helado, get back to your project!
18:15:10 <mniip> subtract = (-) -- wouldn't this be wrong argument order
18:15:45 <cmccann> mniip: well, it's the right argument order for that package
18:16:00 <mniip> still trying to decipher the sort
18:16:35 <cmccann> well, it's optimized for lists
18:17:18 <houshuang> Is there a way to "enter" a module in ghci, giving me access to all the unexported functions? (like selecting a namespace in Clojure REPL)? Or do I have to add the function to the export list in the module, to be able to load it in Ghci and play around with it?
18:18:27 <HeladoDeBrownie> houshuang: :l Module.hs
18:19:12 <mniip> hmm
18:19:28 <mniip> 'unsafeCoerce :: [a] -> Bool' works pretty much like null
18:20:15 <mniip> so that dropWhile is checking whether the list returned by group is only 1 element
18:20:45 <houshuang> HeladoDeBrownie: Gracias, exactly what I needed.
18:20:59 <HeladoDeBrownie> :)
18:21:30 <jle`> mniip: relying on the order of the constructors on Bool eh :P
18:21:36 <mniip> pretty much
18:21:58 <mniip> cmccann, "optimized for lists" gave me a weird idea of sorting other data structures
18:22:44 <mniip> like Traversable's
18:23:27 <mniip> sigh
18:24:32 <cmccann> @quote isJust
18:24:32 <lambdabot> ddarius says: isJust :: Maybe a -> Bool; isJust = unsafeCoerce
18:25:03 <ilyagetready> hello-hello
18:25:10 <ilyagetready> Could somebody assist me on something
18:25:22 <jle`> just ask your question :D
18:25:31 <ilyagetready> I am trying to add an element into List
18:25:38 <ilyagetready>     Couldn't match expected type `[(Either a0 st1, Either a1 st2)]'
18:25:38 <ilyagetready>                 with actual type `(Either Char b0, Either Char b1)'
18:25:56 <athan> perma ban for asking to ask >:C
18:25:58 <ilyagetready> I have a list Either Char st1
18:26:22 <ilyagetready> And trying to add Left 'a' into a list of Right
18:26:50 <jle`> ilyagetready: can you post your whole code? or a relevant snippet?
18:27:07 <ilyagetready> one second
18:28:18 <ilyagetready> http://pastebin.com/ecng14gz
18:28:32 <ilyagetready> Error on line 11
18:29:45 <lifter> I just finished reading the monad transformers section of Beginning Haskell. It explained how the "mtl" typeclasses make it so that in many cases a function of the inner monad need not be explicitly lifted. Is this true when the inner monad is IO?
18:30:29 <jle`> ilyagetready: what are your DFA, FST type synonyms?
18:30:41 <Lokathor> dont think so lifter
18:30:53 <jmcarthur> lifter: no, that's why we have MonadIO
18:31:05 <lifter> you'd think with a name like "lifter" I would know this stuff
18:31:08 <jmcarthur> lifter: at least with liftIO we can lift though however many levels we have
18:31:12 <jle`> lifter: as mtl is implemented, no.  that's because your IO functions are actually definied monomorphically on on IO
18:31:14 <jle`> :t putStrLn
18:31:15 <lambdabot> String -> IO ()
18:31:33 <jmcarthur> jle`: and worse, some IO functions are difficult to define polymorphically
18:31:34 <jle`> the reason the "auto-lifting" works is because get, puts, tell, etc. are now polymorphic on arbitrary monadState, etc.
18:31:35 <jmcarthur> :t bracket
18:31:36 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
18:31:41 <jle`> :t get
18:31:42 <lambdabot> MonadState s m => m s
18:31:53 <jmcarthur> :t forkIO
18:31:54 <lambdabot> Not in scope: ‘forkIO’
18:31:58 <jmcarthur> well, that one too
18:31:59 <lifter> gasp
18:32:03 <Lokathor> ($ fst client) is the same as (fst client) isn't it? Maybe I shouldn't code at 3am
18:32:09 <jle`> lifter: so, `get` is "autoLifted" because it works on any MonadState, and, for example, ReaderT r (State s) is a MonadState
18:32:23 <lifter> yeah, I pretty much get that
18:32:26 <Lokathor> :t any
18:32:27 <lambdabot> (a -> Bool) -> [a] -> Bool
18:32:27 <jle`> it's not really "auto-lifted" technically, it because ReaderT r (State s) actually has `get` defined on it
18:32:35 <jle`> because it is a MonadState s
18:32:45 <jle`> and get is polymorphic over MonadState s
18:32:52 <lifter> yeah it's a clever typeclass trick
18:33:03 <jle`> but normal IO functions are monomorphic; `ReaderT r IO` is different than `IO`
18:33:06 <jmcarthur> not clever enough. quadratic instances :(
18:33:11 <jle`> but liftIO :: IO -> ReaderT r IO
18:33:22 <lifter> ok
18:33:27 <jle`> um. pretend i wrote out a natural transformation
18:33:39 <jle`> liftIO :: IO a -> ReaderT r IO a
18:33:45 <jle`> etc.
18:33:46 <ilyagetready> jle`, I pm'ed you the details
18:33:59 <jle`> if you have functions that are polymorphic over MonadIO, then...yes, you don't need to explicitly lift
18:33:59 <lifter> well up until now I've been using liftIO all over my code so I'm glad that I'm not missing out on something more clever :)
18:34:13 <jle`> some libraries actually give you IO functions defined polymorphically over MonadIO
18:34:21 <jle`> but Prelude and base...not quite
18:34:26 <lifter> ok
18:34:57 <lifter> I find it strange that this book hasn't introduced a monad stack w/ IO; maybe that's noxt.
18:35:01 <lifter> next
18:35:53 <ilyagetready> :(
18:35:56 <ilyagetready> Chaps
18:36:58 <jmcarthur> i think transformer stacks are greatly overrated
18:37:21 <jmcarthur> these days i very rarely explicitly want more than one transformer visible at once
18:38:19 <jle`> one transformer?
18:38:49 <platz> I don't think anyone jumps for transformer stacks; but hard to know what a lasting alternative will be
18:38:53 <jle`> lifter: by the way, did you know that mtl is not a monad transformer library?
18:39:09 <lifter> clearly I did not :)
18:39:12 <jle`> it's actually a typeclass library, and happens to provide orphan instances for types in the transformers library
18:39:21 <jle`> but there are a bunch of instances of those typeclasses that aren't related to transformers
18:39:59 <lifter> yeah by the sound of it, it's composed of typeclasses, that's my understanding
18:40:40 <jmcarthur> jle`: i'm not sure if i should be trying to read something out of your "one transformer?" question
18:41:36 <mseeks> I'm writing a program which has a client and server, and I have a Types.hs file which contains all the type definitions
18:41:39 * hackagebot caffegraph 0.1.0.1 -   http://hackage.haskell.org/package/caffegraph-0.1.0.1 (ajtulloch)
18:41:44 <osa1> what is 1 in INLINE[1] ?
18:42:06 <mseeks> is it better to have Common.Types, Client.Types, and Server.Types, or just a single Types shared to both client and server with unique type names?
18:42:18 <jmcarthur> osa1: that specifies which phase the inlining should start happening
18:42:41 <jmcarthur> osa1: phases count downward from some starting number. i forget the default. i think it starts at 2?
18:42:46 <jmcarthur> osa1: 0 is the last phase
18:43:00 <osa1> what's happening in each phase?
18:43:02 <jmcarthur> osa1: so INLINE[1] means don't inline until phase 1
18:43:24 <jmcarthur> osa1: there is no difference between each phase except which inlining and rewrite rules are allows to fire
18:43:30 <jmcarthur> *allowed
18:43:32 <jmcarthur> afaik
18:43:37 <lifter> mseeks: If your application is large, you might find it helpful to split them up
18:43:44 <javawizard> Anyone know if there's a Haskell IMAP library that supports IDLE? I'm /almost/ to the point of writing support myself into HaskellNet...
18:44:05 <jmcarthur> osa1: you can also invert the phase rules to say you want the rule to *stop* once a certain phase is reached. i forget the syntax.
18:44:26 <mseeks> lifter: is it good practice to have three Types files and, for example, export all the exports from Common.Types from each of {Client, Server}.Types? seems a bit repetitive to me
18:45:07 <jmcarthur> osa1: i think it optimizes to a fixpoint in each phase before going to the next, but i don't remember with 100% certainty and could be making that up
18:46:05 <lifter> mseeks: I'm not sure. In my project I have different "Types" modules, but they don't reference each other and there are no modules that re-export any types.
18:46:12 <lifter> This has worked well for me so far.
18:46:41 <lifter> If you are developing a library then you might have to think things through carefully in terms of what is exposed from where and how.
18:47:21 <mseeks> they're just executables
19:02:36 <mniip> anyone here familiar with ghc-api? ಠ_ಠ
19:06:58 <mniip> HeladoDeBrownie, https://hackage.haskell.org/package/acme-cadre-0.1/docs/Acme-Cadre.html
19:09:29 <acomar> hey all, with pipes, is it possible to join input from multiple producers together into a list or tuple?
19:10:04 <acomar> i.e. can I build a producer from multiple separate producers
19:10:54 <mniip> HeladoDeBrownie, sad it doesn't go all the way up to 62, where's my cdddadadaaadadaaadadaaadaaaaadadaaaaadaaadadaaadaaaaadaaaaadadar
19:16:40 * hackagebot caffegraph 0.1.0.2 -   http://hackage.haskell.org/package/caffegraph-0.1.0.2 (ajtulloch)
19:18:55 <Hermit> acomar: there's zip for conduits
19:20:41 <acomar> Hermit: thanks for the tip, looks like there's zip on pipes/producers as well
19:20:59 <Hermit> good, there you go then :)
19:24:05 <mniip> anyone here familiar with ghc-api? D:
19:24:33 <acomar> Hermit: makes type signatures a pain to write out when you've got 5 producers to list out though :(.
19:25:24 <EvanR> type synonyms!
19:25:34 <Hermit> acomar: specially when using producers as transformers
19:25:40 <HeladoDeBrownie> does this have a name somewhere? either (const Nothing) Just
19:25:45 <Hermit> I had my share of anguish with those
19:25:56 <acomar> EvanR: yea, that's what I'll have to do
19:26:01 <acomar> Hermit: yea, exactly
19:26:54 <EvanR> HeladoDeBrownie: i found some stuff in the errors package
19:27:04 <EvanR> hush :: Either a b -> Maybe b
19:27:12 <HeladoDeBrownie> hmm, probably not worth importing a package just for this
19:27:14 <HeladoDeBrownie> thanks though
19:27:29 <EvanR> hehe
19:27:37 <mniip> out of 1502 people surely someone should have worked with ghc-api :|
19:28:19 <monochrom> do you know how many people are actually looking at the channel, literally?
19:28:22 <EvanR> HeladoDeBrownie: in ruby this would have been a no brainer, and your 13 utility functions would be 13 dependencies
19:28:30 <HeladoDeBrownie> XD
19:28:30 <mniip> monochrom, yeah :/
19:28:36 <HeladoDeBrownie> i like that name though, maybe i'll steal it
19:28:37 <monochrom> I would say it's about 10 people.
19:28:44 <EvanR> HeladoDeBrownie: yeah thats what i do
19:28:55 <EvanR> find out what someone else called it
19:28:56 <mniip> monochrom, I've been asking the same question for like 6 hours though
19:29:44 <mniip> oooh an idea
19:29:51 <EvanR> 1500, thats a lot of lurking
19:31:26 <fryguybob> mniip: If you have a question about ghc-api, you should just ask that question instead of asking who is familiar with ghc-api (I scrolled back a bit, but didn't see a question).
19:31:33 <acomar> EvanR: That's how I found out whenJust has like 10 different names :P
19:31:41 <mniip> fryguybob, try scrolling back 6 hours /s
19:31:51 <EvanR> acomar: yeah so at least i dont make a new one
19:31:56 <mniip> the question is how do I lookup a value by name, from a dynamically loaded module
19:32:02 <EvanR> mniip: did you try #ghc
19:32:32 <monochrom> I used to know how to do that
19:32:56 <mniip> GHC Development | ... | Please ask user questions in #haskell
19:33:04 <mniip> I don't think my question counts as GHC development
19:33:13 <acomar> mniip: you're better off just reiterating the question every hour or so, chances are, it's scrolled off the page for anyone just glancing in
19:33:36 <EvanR> equip a drinking bird on the enter key
19:33:42 <sssilver> Hey guys, so suppose you’re programming a chess game. Obviously your board is represented with a matrix. Do you create a `data board` or do you just use the 2D vector directly?
19:33:47 <sssilver> it feels like the first option is more sane
19:33:54 <sssilver> *data Board sorry
19:34:05 <Hijiri> not sure if it's that obvious that it's represented with a matrix
19:34:26 <sssilver> Hijiri: elaborate?
19:34:34 <EvanR> there are 64 squares, so 64 constructors or 64 types!
19:34:40 <Hijiri> well, you could have a map from chess positions to pieces, instead
19:34:45 <mniip> EvanR, 64-tuple
19:34:48 <acomar> sssilver, why a matrix? just for the piece positions?
19:34:52 <EvanR> or a 64ple
19:34:56 <sssilver> yeah acomar
19:35:22 <mniip> EvanR, I think the most logical representation would be a 13-tuple of 5-tuples
19:35:31 <acomar> sssilver, always try to move towards a representation that best reflects the problem you're trying to solve
19:35:34 <mniip> with the 7th element of the 3rd tuple unuse
19:35:34 <mniip> d
19:35:53 <EvanR> thats downright silly
19:36:11 <acomar> the matrix works well when you need to render a piece at every position, but if you don't (you almost never do), there are better ways to approach the problem
19:36:37 <acomar> so what problem are you trying to solve?
19:37:10 <mniip> sssilver, consider this, a board can be an 8x8 matrix of Maybe Pieces, or a list of Pieces with respective positions
19:37:11 <sssilver> OK the chess board was just an example. I’m actually programming Tetris. I just thought more people would be familiar with chess than Tetris, and at some point realized that was a dumb thought.
19:37:28 <EvanR> mniip: where pieces cant be on the same square
19:37:40 <mniip> tetris sounds like you want a matrix though, for collision detection
19:37:44 <EvanR> furthermore, theres valid positions
19:37:48 <sssilver> yeah mniip
19:38:05 <sssilver> so in an OOP language I’d have a concept of a board that’d internally use a matrix
19:38:16 <monochrom> I think I considered lookupName, lookupGlobalName, and even dynCompileExpr
19:38:16 <rribeiro> Hey guys, i'm having trouble understanding this type declaration [a->b->Bool] -> ([a,b)] -> Bool.
19:38:35 <acomar> sssilver: what about using State (or StateT) to carry the matrix representation through?
19:38:37 <mniip> https://github.com/ghc/ghc/blob/master/ghc/InteractiveUI.hs#L1186
19:38:40 <nshepperd> a board could be an 8x8 array of Maybe Piece /AND/ a list of Pieces with respective positions!
19:38:43 <mniip> reaaaaaaaally? is that how :main works?
19:38:50 <EvanR> rribeiro: for one thing, ([a,b)] seems a bit off
19:38:57 <mniip> nshepperd, keeping it synchronised though
19:39:13 <rribeiro> @EvanR woops [(a,b)]**
19:39:13 <lambdabot> Unknown command, try @list
19:39:35 <bob_twinkles> rribeiro: "given a list of functions from a to be to a bool and list of (a, b) tuples, return a boolean"
19:39:52 <fryguybob> mniip: Would complieExpr do what you want?  Ah monochrom also browsed some.
19:39:52 <sssilver> acomar: https://wiki.haskell.org/State_Monad ?
19:40:06 <mniip> fryguybob, it's not a compileExpr :/
19:40:12 <sssilver> acomar: I haven’t read about monads yet >.< thought I would be able to implement Tetris before diving into the scary stuff
19:40:15 <mniip> it's not an expression, just an identifier
19:40:32 <rribeiro> so, are we comparing the function with the tuple?
19:40:35 <EvanR> sssilver: you shouldn't  start at a state monad
19:40:42 <acomar> sssilver, not much to learn. State gives you get and put which let you read and write to your current state respectively
19:40:43 <fryguybob> compileExpr "a"
19:40:51 <acomar> sssilver, ^
19:41:05 <mniip> fryguybob, I do understand that an identifier is a valid expression but that seems just wrong to me
19:42:00 <mniip> like using parsec for extracting the first element of the list
19:42:10 <fryguybob> mniip: What is the type that you would like? Name -> m HValue?
19:42:54 <acomar> sssilver, learning monads in their full generality is a longer process than just starting to use them. State gives you access to `get`, `put` and `modify`, which do exactly waht you'd expect within the given context
19:43:06 <mniip> probably ModuleInfo -> Name -> Maybe a
19:43:11 <monochrom> what did they say? "if all you have is GHC API, everything looks like an expression"? :)
19:43:20 <mniip> although a typevalue mix would do too
19:43:45 <Aylon> Speaking of get, I'm trying to write some helper functions that use hedis and running into some issues
19:43:54 <mniip> ModuleInfo -> Name -> m (Maybe a)
19:44:44 <mniip> yeah HValue works I guess
19:45:16 <Aylon> This is what I'm trying to get working right now: http://lpaste.net/120623
19:45:40 <sssilver> I’m just confused because I don’t understand what my entities are…. uh, I can’t even phrase this properly. Say in Tetris I have polyominoes, and lets call them pieces…. and in an OO architecture I think of a piece as of a class. What’s the equivalent in Haskell? In what terms do I think of a single polyomino in Haskell?
19:46:09 <rribeiro> bob_twinkles, from what your telling me, do I have to compare the list of functions a to b with the tuple?
19:46:21 <Aylon> And this is the error I'm running into: http://lpaste.net/120624
19:46:22 <mniip> sssilver, a data
19:46:24 <sssilver> what concept in haskell would represent my polyomino?
19:46:37 <mniip> polyominos would be a type
19:46:44 <mniip> a polyomino would be a value of that type
19:46:46 <acomar> sssilver, almost certainly an abstract data type, defined via the data keyword
19:46:55 <sssilver> mniip: that’d just be the matrix of the polyomino, right? not the operations that you can do to it (e.g. rotate)
19:47:14 <EvanR> sssilver: you can still use object oriented (though maybe not class oriented) ideas. each shape is an object with a distinct identity. those are values
19:47:20 <mniip> rotate would be a function that takes a polyomino and returns a polyomino, probably
19:47:25 <timpani> part
19:47:41 <Aylon> I don't understand why R.get (imported from Database.Redis) isn't working with a function R.Connection -> R.Redis a -> ActionM a
19:47:55 <Aylon> ActionM comes from Scotty, which I'm using in tandem
19:48:33 <sssilver> acomar: but an abstract data type called polyomino, does it have anything more than just the matrix that it’s stored in?
19:48:44 <EvanR> sssilver: mutable properties of things are also values. you can use Data.Maps to associate keys and values
19:49:06 <acomar> sssilver, I wouldn't store anything but the shape and orientation of any given piece
19:49:08 <sssilver> and if not, why not just use the matrix? or is this Haskell’s way of hiding implementation details?
19:49:18 <sssilver> acomar: ‘shape'?
19:49:31 <EvanR> acomar sssilver "store" is the wrong word for this
19:50:06 <acomar> EvanR, yea, I mean capture with the data declaration
19:50:26 <mniip> fryguybob, sad that the most interesting functions of ghc api aren't documented
19:50:45 <acomar> sssilver, yea, there are a finite number of shapes a given polyomino can take, right?
19:50:51 <EvanR> sssilver: rather than having a single class with many attributes, you should represent all the aspects of your game with various data types that have more specific properties, like orientation, position, rotation, color, point value
19:51:02 <Aylon> I've spent a few hours getting it down to just that one error, and now I'm stuck
19:51:05 <EvanR> specific use cases
19:51:10 <sssilver> acomar: sure, but suppose you’re defining a generic function that generates all polyominoes of given N complexity
19:51:21 <EvanR> for mutable state, you can use one or more Data.Maps
19:51:39 <acomar> sssilver, why am I defining such a function?
19:51:57 <sssilver> acomar: to implement Tetris and not have to hard-code all the possible shapes
19:52:00 <bob_twinkles> rribeiro: hmm? That type signature seems to imply that the function applies each function in the first argument to the tuples in the second and returns some aggregate of their results (|| or &&, you'd have to read the documentation to know which)
19:52:13 <EvanR> sssilver: if you want to represent any N-mino, then you should not use a matrix but a set of "on-cells"
19:52:28 <osa1> if I have ReaderT s1 (ReaderT s2 _) _, can I get s2 using `ask` ?
19:52:34 <Aylon> I'll admit that I don't quite grok the types involved, and that seems to be the root of my issue
19:52:57 <EvanR> sssilver: and it has no other properties, its just that particular shape
19:53:05 <EvanR> as a value
19:53:18 <sssilver> EvanR: ‘on-cells’?
19:53:38 <acomar> sssilver, there are only N shapes for tetris, period, right? So capture them in an abstract data type and make the associated display function render them correctly.
19:54:34 <acomar> sssilver, if you're trying to represent polyominos of any shape at all, then that's a different matter entirely
19:54:35 <rribeiro> bob_twinkles, well the question asks, "allPairFunc :: [a -> b -> Bool] -> [(a,b)] -> Bool that returns True if all the functions applied to their corresponding pair values return True - otherwise False. It also returns false if there are different numbers of functions and pairs."
19:55:25 <EvanR> acomar: not literally "tetris" but "n-tris" ;)
19:55:55 <sssilver> yeah an n-tris. Otherwise I’d have said tetronimo.
19:55:57 <acomar> EvanR: that needs more definition :)
19:56:17 <acomar> there are multiple ways to extend tetris
19:56:28 <mniip> there are multiple ways to represent polyominos
19:56:39 <mniip> since the main aspect is collision detection, again, you want a matrix
19:56:49 <mniip> some sort of variable sized matrix
19:56:57 <EvanR> shrug
19:57:07 <EvanR> or set of on cells
19:57:13 <sssilver> well you can store your polyomino as a list of cells, and then generate a matrix from it
19:57:16 <EvanR> intersection is the collision test
19:57:18 <bob_twinkles> rribeiro: right, so it aggregates the results by and-ing them together (with an initial value of True)
19:57:23 <mniip> yeah that works
19:57:29 <sssilver> er yeah EvanR good point
19:58:00 <EvanR> another tip is to separate your mathematical/data model from your visualization
19:58:26 <EvanR> as long as you can generate a visualization you dont need to directly operate on the visualization to simulate the world
19:58:32 <rribeiro> bob_twinkles, makes sense. Just couldn't seem to wrap my head around, what was needed. Thanks!
19:58:39 <mniip> generating all polyominoes of size N is quite a complex problem I say
19:58:53 <EvanR> well suited for haskell!
19:58:57 <sssilver> mniip: I wrote something in Rust — https://github.com/sssilver/tetrust/blob/master/src/game/polyomino.rs — and it seems to work
19:59:03 <bob_twinkles> rribeiro: no problem
19:59:05 <sssilver> mniip: trying to think how I’d implement it in Haskell
19:59:22 <mniip> nubBy comes to mind
20:00:01 <mniip> I wonder which is simpler, implement a translational equality function or to make sure there are no translational ambiguities
20:01:01 <mniip> sssilver, are mirrored polyominoes considered different?
20:01:01 <fryguybob> mniip: I think if you were to more directly get at what you want it would involve getting things out of ModIface, I don't think you are going to get any better then compileExpr
20:01:01 <EvanR> a bottom up approach appeals to me more
20:01:09 <EvanR> mniip: in tetris, yes
20:01:12 <sssilver> mniip: yes
20:01:25 <EvanR> unless they are identical
20:01:27 <mniip> fryguybob, that's sad
20:02:36 <fryguybob> mniip: If you are sad enough to rewrite things, make sure the GHC-API is thread-safe in the rewrite :D
20:02:46 <mniip> naaaaah
20:03:09 <mniip> this code is supposed to be simple, write-once-work-forever sort of stuff
20:03:39 <sssilver> so is this a good start for a polyomino piece? https://dpaste.de/zJN8
20:04:42 <fryguybob> If you are going for work-forever you might have a hard time with the GHC-API.  It is a bit of a moving target if I'm not mistaken.
20:10:41 <sclv> @remember edwardk as much as i'd like to shrink your dependencies, i hate orphans too much
20:10:41 <lambdabot> Done.
20:16:41 * hackagebot network-attoparsec 0.9.0 - Utility functions for running an attoparsec parser against a socket  http://hackage.haskell.org/package/network-attoparsec-0.9.0 (solatis)
20:16:56 <solatis> \o/
20:17:02 <solatis> my first package
20:17:18 <hiptobecubic> \o\
20:17:20 <hiptobecubic>  /o/
20:18:08 <solatis> thank you, thank you, autographs will be signed when the haddock is generated
20:19:25 <Aylon> Anyone available to help a newbie write a function to read and parse data out of redis? I already have the core logic of my application and am trying to add persistence to the mix.
20:22:09 <Aylon> Anyone?
20:24:10 <gcganley> if im going to spend money on a book to learn something to help me with advanced haskell (be it category theory or something else) what would you suggest? im open to anything
20:24:44 <gcganley> keep in mind i know zero category theory
20:24:49 <Aylon> The function I'm having issues with is here: https://github.com/cromo/deck-around-hs/blob/master/DeckAroundServer.hs#L44
20:26:17 <HeladoDeBrownie> gcganley, are you aware of the basics already?
20:26:26 <HeladoDeBrownie> (of haskell)
20:26:30 <HeladoDeBrownie> (you don't need ct to be good at haskell)
20:26:41 * hackagebot cheapskate 0.1.0.3 - Experimental markdown processor.  http://hackage.haskell.org/package/cheapskate-0.1.0.3 (JohnMacFarlane)
20:31:09 <Aylon> Testing, testing, 1, 2, 3 - am I visible?
20:32:16 <acomar> Aylon, yea, you're visible. Not sure what you're asking.
20:33:12 <Aylon> acomar, I'm asking because I've asked for a bit of help in my first real haskell program, but I've not received so much as an acknowledgement :\
20:34:54 <acomar> Aylon: can you formulate your question more directly/simply?
20:35:13 <Aylon> Does code with an error message work?
20:36:47 <orzo> what is a redis?
20:37:10 <bob_twinkles> Aylon: what do you mean by work?
20:37:10 <gcganley> HeladoDeBrownie: Im quite good with haskell, i understand everything in lyah and most of the stuff in rwh I understand. but when it comes to stuff like understanding 'the strength of functors' im totally lost
20:38:00 <Aylon> I was asked to be more specific, so I offered to provide code and the error message it's producing.
20:38:53 <hiptobecubic> Hey algorithm lovers, what's an appropriate haskelly datastructure for a stencil operation like what's described here https://www.hackerrank.com/challenges/cavity-map ?
20:38:53 <orzo> what is the error message?
20:39:11 <Aylon> It'll probably be helpful either way - code: http://lpaste.net/120623 error: http://lpaste.net/120624
20:39:43 <orzo> Aylon: that is not an error
20:39:58 <orzo> that is a lint programming making suggestions for your code to look a little cleaner
20:40:25 <Aylon> orzo: redis is a key-value server that has bindings for many languages, including haskell
20:40:27 <orzo> it's saying that the parenthesis around GameState in your type signature are unneccessary and so it suggests you omit them
20:40:35 <Aylon> It's not an error?
20:40:50 <ReinH> orzo: No, that's an error.
20:40:52 <ReinH> orzo: http://lpaste.net/120624
20:40:59 <Aylon> ghci says "Failed, modules loaded: DeckAroundCore, DeckAroundCoreJson."
20:41:13 <Aylon> Where DeckAroundCore is where this function resides
20:42:20 <Aylon> orzo: Removing the parentheses does not fix the problem.
20:42:21 <orzo> what was i looking at? lpaste runs hslint?
20:42:48 <Aylon> Oh, there were two links
20:42:53 <orzo> Aylon: i saw some noise at the paste link and thought it was the error you were asking about but it was not
20:43:15 <Aylon> orzo: This is the error in a separate paste: http://lpaste.net/120624
20:45:34 <orzo> Aylon: i'm not familiar with the library you are using
20:45:47 <orzo> i think it is this one, https://hackage.haskell.org/package/hedis-0.6.2/docs/Database-Redis.html#g:2
20:46:11 <Aylon> You are correct; I am using Hedis.
20:46:34 <orzo> well you are missing a type class instance
20:46:37 <Aylon> If you want full program source, it's at https://github.com/cromo/deck-around-hs/blob/master/DeckAroundServer.hs#L44
20:46:42 * hackagebot validation 0.5.0 - A data-type like Either but with an accumulating Applicative  http://hackage.haskell.org/package/validation-0.5.0 (TonyMorris)
20:46:56 <bob_twinkles> Aylon: take a look at http://hackage.haskell.org/package/hedis-0.6.5/docs/Database-Redis.html#t:RedisCtx
20:47:00 <orzo> i don't want to learn enough to help you
20:47:24 <Aylon> orzo: fair enough. Thanks for taking a look.
20:48:01 <HeladoDeBrownie> gcganley, what is your purpose in learning more? do you want to explore new abstractions? learn how people already do things? something else?
20:48:04 <bob_twinkles> Aylon: game is going to be of type Either Reply, not Maybe
20:48:46 <HeladoDeBrownie> gcganley, since you seem to have a good foundation, how about parallel and concurrent haskell? that's readable online even
20:49:13 <gcganley> HeladoDeBrownie: read most if not all of it lol
20:49:51 <Aylon> bob_twinkles: That did it. Using Right/Left in the outer case instead of Just/Nothing worked.
20:50:43 <Aylon> So, in the spirit of learning, why didn't it tell me about the Either and instead focused on the R.get call?
20:50:44 <gcganley> HeladoDeBrownie: I'm going to read it again though. and actually write a concurrent program. something I've actually never done before even in C#. Its going to be something like a DHCP server or something similar to that
20:51:03 <gcganley> HeladoDeBrownie: lots of forkIO and STM
20:51:15 <acomar> gcganley: that's the most advanced dedicated haskell book I know of, which is sad since there's so much folklore in blog posts
20:51:16 <EvanR> forkIO all the things
20:51:49 <bob_twinkles> Aylon: well, it told you the typecheck failed =P
20:52:07 <gcganley> acomar: I'm totally prepared to dive head first into a university text book i just need to know what to buy and how to approach it
20:52:17 <bob_twinkles> presumably then you would go look up what instances _did_ exist, which that thing I linked a few lines back would tell you
20:52:21 <Aylon> It did, and I've been staring at it for a few hours trying to figure out why it was failing there and not two lines down
20:52:42 <bob_twinkles> because that's where the binding that was causing the error was
20:52:46 <acomar> gcganley: yea, I know what you mean. I just don't know if anything meets your criteria
20:53:04 <HeladoDeBrownie> gcganley, sounds about right
20:53:14 <EvanR> gcganley: theres the book by richard bird, but i dont know what its called
20:53:14 <mniip> sssilver, I just wrote a polynomio generator...
20:53:16 <mniip> it kind of works
20:53:19 <gcganley> acomar: i know ReinH has a list but i dont know which to get.
20:53:24 <HeladoDeBrownie> gcganley, i think applying what you read is usually about the best way to learn anyway
20:53:27 <sssilver> mniip: nooo don’t spoil it for me
20:53:32 <sssilver> mniip: I’m in the process!
20:53:35 <gcganley> EvanR: I've been thingknig of getting one of his books
20:54:04 <mniip> excuse my Show instance,
20:54:08 <mniip>  > generatePolys 4
20:54:08 <mniip> [fromCharMap ["****"],fromCharMap ["*  ","***"],fromCharMap ["***","*  "],fromCharMap [" * ","***"],fromCharMap ["** "," **"],fromCharMap ["**","**"],fromCharMap ["* ","**"," *"]]
20:54:18 <gcganley> HeladoDeBrownie: does concurrent programming translate well to ghci or will i need to compile it for the multithreaded advantages?
20:54:22 <Aylon> I'll be honest, I didn't know to look there. I'm still getting the hang of understanding the errors and reading the docs.
20:54:38 <EvanR> gcganley: ghci can run threads
20:54:51 <bob_twinkles> Aylon: ghc's errors are indeed quite... precice =P
20:55:05 <bob_twinkles> also opaque until you get the hang of it
20:55:07 <sssilver> mniip: how do you filter out rotations?
20:55:18 <gcganley> EvanR: does it clobber output randomly? im just afraid of that really
20:55:21 <sssilver> do you rotate each polyomino and try to match it against existing ones?
20:55:38 <EvanR> gcganley: yeah if you dont serialize writing to stdout
20:55:39 <mniip> instance Eq Polynomio ;)
20:55:51 <EvanR> not really clobbering, just interleaving
20:55:53 <sssilver> mniip: sure, but do you perform 4 rotations?
20:55:56 <gcganley> EvanR: Keep in mind i've never worked with multiple cores
20:56:04 <mniip> well one of the rotations is identity
20:56:04 <Aylon> I've also run into some cases where I'm guessing the type inferencer is influenced by a statement that I've added between other statements that changes the inferenced type of a variable
20:56:06 <mniip> but yes
20:56:10 <Aylon> I'll get there eventually
20:56:19 <jle`> jmcarthur: what do you mean by writing something with one transformer visible?
20:56:31 <gcganley> EvanR: like i know all the terms and what they mean (like race conditions) but ive never actually put it to the test
20:56:39 <EvanR> to use multiple cores you need to compile with -threaded and run with +RTS -N2 (for two cores)
20:56:39 <mniip> also lol, generatePolys is lazy
20:56:57 <Aylon> As much as it feels like I'm smashing my head against a wall, I find haskell to be quite awesome to work with
20:57:02 <mniip> generatePolys 10 is taking quite a while but ghci is displaying everything slowly
20:57:08 <Aylon> Thanks for the help bob_twinkles
20:57:19 <bob_twinkles> no problem
20:57:27 <sssilver> cool, so far this is what I’ve got mniip, now trying to figure out how to use Data.Set: https://dpaste.de/wPqx
20:57:42 <sssilver> mniip: don’t judge, I know it’s all wrong, I haven’t tried to compile it yet
20:57:53 <sssilver> and line 15 is incomplete
20:58:02 <gcganley> EvanR: I run 8 physical cores because im cool like that
20:58:11 <mniip> [(0, 0)] isn't a [Piece]
20:58:13 <EvanR> gcganley: -N8 then
20:58:42 <sssilver> mniip: how come?
20:58:49 <mniip> it's a Piece
20:59:03 <HeladoDeBrownie> gcganley, you can do concurrency perfectly fine without parallelism
20:59:03 <sssilver> oh
20:59:18 <sssilver> mniip: good catch
20:59:40 <HeladoDeBrownie> gcganley, to answer your question more directly, i'm not sure; i've never tried concurrent programming in ghci :P
21:00:10 <EvanR> ghci is just ghc plus i ;)
21:00:12 <gcganley> HeladoDeBrownie: i dont know if im dumb or its subtle but the difference is still confusing. i know that one uses 'threads' and not 'cores' but for some reason i still mix them up
21:00:47 <gcganley> EvanR: ik its just `ghc --interactive` lol
21:00:48 <HeladoDeBrownie> gcganley, haskell threads are a concurrency abstraction, they don't necessarily indicate that anything is happening simultaneously (although they may be implemented that way)
21:00:59 <EvanR> gcganley: just concentrate on one core and concurrent programming with forkIOs for now then
21:01:02 <EvanR> ignore 7 of your cores
21:01:12 <HeladoDeBrownie> gcganley, but thread activity may in general be interleaved in an unpredictable fashion
21:01:19 <gcganley> EvanR: but they will get lonely...
21:01:26 <EvanR> doesnt matter
21:01:46 <gcganley> EvanR: ik, i just want to learn how to get more performance out of my machine
21:01:55 <gcganley> good morning folks
21:02:02 <gcganley> well est folks
21:02:06 <EvanR> if you have 8 separate problems, run 8 separate processes ;)
21:02:16 <HeladoDeBrownie> threads aren't about performance, they're actually the correct solution to several problems even when you don't care about performance
21:02:33 <HeladoDeBrownie> for example, listening to connected clients
21:02:55 <gcganley> HeladoDeBrownie: really? like what? i can think of time-shared OS's and network connections but not much else
21:03:11 <HeladoDeBrownie> i may spawn two or more threads per client connected: one for input, one for output. these block waiting on an order for something to do and then act when an order comes in
21:03:11 <EvanR> object oriented programming
21:03:28 <bob_twinkles> GUI tasks as well, you don't want to hang the interface while you do work
21:03:36 <gcganley> HeladoDeBrownie: wait... threads are not bidirectional?
21:03:48 <EvanR> threads arent even directional
21:03:58 <HeladoDeBrownie> gcganley, i don't think that question is even well formed :)
21:04:28 <gcganley> HeladoDeBrownie: are threads bidirectional or am i just looking at it wrong
21:04:42 <gcganley> HeladoDeBrownie: you said you would need one thread for input and one for output
21:04:46 <HeladoDeBrownie> gcganley, listen to EvanR, but also i have no idea what you mean
21:04:47 <EvanR> are processes bidirectional/
21:04:54 <HeladoDeBrownie> gcganley, oh, you're wondering why one thread can't handle both?
21:05:02 <gcganley> HeladoDeBrownie: yes lol
21:05:10 <EvanR> gcganley: blocking IO
21:05:11 <HeladoDeBrownie> gcganley, well because they may need to happen apart from each other
21:05:25 <EvanR> blocking simplifies everything
21:05:31 <EvanR> as long as you have threads
21:05:42 <HeladoDeBrownie> gcganley, okay, here's an example of something that we usually don't do: i spawn one thread per client. whenever the client gives me input, i interpret it and output a response based on it. this is perfectly legit for some applications.
21:06:13 <HeladoDeBrownie> gcganley, what's more generally useful: a client connects. it may send input at any time. i may have something to tell it at any time regardless of its input. i don't want one to freeze waiting for the other. so i use two threads.
21:06:51 <HeladoDeBrownie> gcganley, now say you didn't block but had one thread poll on both input and output. well, great, now you lose the advantages of the thread abstraction by doing everything yourself.
21:07:19 <gcganley> HeladoDeBrownie, EvanR: when im first starting out with this stuff do i have to worry about nitty gritty stuff like grainularity?
21:07:33 <HeladoDeBrownie> gcganley, i don't even know what that is and i do concurrent programming (mostly) fine :P
21:07:52 <gcganley> HeladoDeBrownie: its a buzzword i picked up on
21:08:02 <HeladoDeBrownie> gcganley, what's it mean?
21:08:30 <gcganley> HeladoDeBrownie: how big of chunks of data you send to each core/thread to do work and come back with a result
21:09:00 <HeladoDeBrownie> gcganley, i think that's more related to parallelism than concurrency?
21:09:15 <gcganley> HeladoDeBrownie: im messing the two up again
21:09:47 <gcganley> HeladoDeBrownie: just to make things straight
21:09:49 <sssilver> mniip: what’s the correct way to indent this function and still have it be readable? https://dpaste.de/ihjf
21:09:58 <EvanR> gcganley: many people think "threads" and "concurrency" is about "using multiple cores" but its not
21:10:08 <mniip> sssilver, asking the wrong person here xD
21:10:17 <sssilver> hehe
21:10:27 <EvanR> sssilver: check the haskell style guide
21:10:28 <mniip> sssilver, also you can do (x, y) <- Piece
21:10:35 <gcganley> HeladoDeBrownie: cores -> parallelism, threads -> concurrency
21:10:36 <mniip> uh, <- piece
21:10:58 <gcganley> EvanR: cores -> parallelism, threads -> concurrency
21:11:00 <HeladoDeBrownie> gcganley, sounds like an okay approximation.
21:11:14 <gcganley> HeladoDeBrownie: ok, I'll try and keep that in my head
21:11:25 <mniip> ok
21:11:28 <HeladoDeBrownie> threads can also be used as a parallel tool, but they're not that inherently
21:11:31 <mniip> at this point the code seems nonterrible enough to share
21:11:43 <gcganley> HeladoDeBrownie: now where does the
21:11:46 <gcganley> crap
21:11:48 <HeladoDeBrownie> essentially threads will become the boundaries by which things can be parallelised
21:11:57 <gcganley> HeladoDeBrownie: now where does the 'spark pool' come in?
21:12:03 <HeladoDeBrownie> i don't know what that is either
21:12:22 <EvanR> sssilver: in your case, i would use a map rather than a list comprehension
21:12:30 <gcganley> HeladoDeBrownie: all i know about P&C is from SimonM's book
21:12:44 <sssilver> EvanR: for readability?
21:13:03 <EvanR> sssilver: well i tried to reformat it, and discovered the whole thing was a list comprehension ;)
21:13:03 <HeladoDeBrownie> gcganley, i actually have only read it in bits and pieces, but what i've read has been good
21:13:23 <mniip> let's see what kind of crap will lpaste give me
21:13:25 <gcganley> HeladoDeBrownie: it seems amazing from what ive been able to understand
21:13:29 <lpaste> mniip pasted “Polyominos” at http://lpaste.net/120629
21:13:39 <mniip> not bad
21:13:58 <EvanR> gcganley: getting multiple cores to solve a single problem faster is a non trivial task in general
21:14:11 <sssilver> aaaaaa mniip I’ll never be good at this!!!!
21:14:13 <EvanR> getting a concurrent application together is rather nice in haskell
21:14:58 <gcganley> EvanR: if there is one thing i know its that concurrent programming is never trivial
21:15:07 <gcganley> nor is parellel programming
21:15:08 <EvanR> gcganley: its really not bad in haskell
21:15:21 <EvanR> pthreads is non trivial no matter what you do
21:15:31 <gcganley> EvanR: though im guessing its not as easy as throwing forkIO everywhere
21:15:39 <gcganley> EvanR: pthreads?
21:15:49 <EvanR> pthreads, a popular interface to OS threads
21:16:09 <EvanR> usually people complain about that when they complain about "concurrency"
21:16:37 <gcganley> EvanR: Im focused on haskell on Linux. is there any problems that i will run into?
21:16:47 <EvanR> nevar!
21:16:55 <gcganley> not sure if that should be an is or an are...
21:17:04 <gcganley> EvanR: nevar what
21:17:09 <EvanR> haskell on linux is perfect
21:17:39 <gcganley> EvanR: except when i accidently format /dev/sda instead of /dev/sdb
21:18:05 <EvanR> :t unsafeFormatHarddrive
21:18:05 <gcganley> EvanR: it happens more than i like to admit
21:18:05 <lambdabot> Not in scope: ‘unsafeFormatHarddrive’
21:18:22 <gcganley> EvanR: put it in Acme.Unsafe
21:18:28 <jle`> :t safeFormatHarddrive
21:18:29 <lambdabot> Not in scope: ‘safeFormatHarddrive’
21:18:46 <mniip> safeFormatHarddrive is obviously a state
21:18:54 <mniip> which means you can save the previous state of the harddrive
21:18:56 <gcganley> mniip: StateT
21:19:03 <gcganley> :k StateT
21:19:04 <lambdabot> * -> (* -> *) -> * -> *
21:20:00 <jle`> :t StateT
21:20:01 <lambdabot> (s -> m (a, s)) -> StateT s m a
21:20:19 <jle`> it's weird when people give things the same name on the type level and on the value level
21:20:22 <jle`> :|
21:20:35 <gcganley> jle`: im guilty of it
21:20:40 <bob_twinkles> well, what would you call it?
21:20:51 <gcganley> bob_twinkles: mkStateT
21:21:11 <bob_twinkles> that... makes a lot of sense
21:21:25 <jle`> it's a little awkward for pattern matching but who pattern matches on StateT
21:21:48 <gcganley> jle`: lunatics... actually ive never used State nor StateT
21:22:31 * HeladoDeBrownie enjoys Control.Monad.State.Class quite a bit
21:23:22 <gcganley> i've never used Reader either
21:23:40 <HeladoDeBrownie> honestly the non-transformer versions don't seem that useful to me
21:23:44 <johnw> gcganley: I switch to state whenever I notice that I want one value from a fold, but another value as the accumulator, and so I'd otherwise awkwardly be using a tuple as the accumulator in order to thread both through
21:23:56 <HeladoDeBrownie> and the transformer ones mostly when you need to compose different stacks of transformers
21:24:10 <johnw> I use non-transformer State fairly often
21:24:24 <HeladoDeBrownie> johnw, i'd be curious to see a sample if one is conveniently at hand
21:24:28 <orzo> same name on type and value level is idiomatic
21:24:28 <gcganley> johnw: i use the tuple foldy sort of situation all the time, i didnt know there was anythign better....
21:24:28 <ttt_fff> from a haskell perspective, what does Elm (the reactive client side language) provide, and what constructs does it lack? [its features seems a subset of haskell's]
21:24:36 <johnw> haha
21:24:42 <johnw> there you go, State is the abstraction of that pattern
21:24:49 <bob_twinkles> I've been mostly trying to avoid State/StateT as I learn haskell since they sort of feel like a crutch that allows you to do imperative programming in haskell
21:24:57 <johnw> you just then use foldM instead of foldl+tuple
21:25:08 <gcganley> :t foldM
21:25:09 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
21:25:11 <HeladoDeBrownie> bob_twinkles, they're not that at all. State s a is just s -> (s, a)
21:25:14 <jle`> when you use State/StateT in ways that don't facilitate imperative programming then that's when you are good i think
21:25:23 <gcganley> johnw: what is this wizardy...
21:25:40 <bob_twinkles> HeladoDeBrownie: indeed, but put/modify/get make it really easy to abuse do-notation and write essentially imperative code
21:25:42 <HeladoDeBrownie> bob_twinkles, StateT s m a is, only slightly more complicated, a -> m (s, a)
21:25:54 <HeladoDeBrownie> bob_twinkles, i guess, but by that logic lists are imperative too
21:25:56 <jle`> HeladoDeBrownie: i think the point is that facilitates approachign a problem from an imperative perspective
21:26:04 <HeladoDeBrownie> bob_twinkles, and Maybe, and Either, and… lots of useful constructs
21:26:11 <johnw> gcganley: it says that you get propagate some contextual 'm' throughout the fold; if you choose that 'm' to be State, then you get to have your own accumulator on the side
21:26:11 <jle`> where a less imperative perspective might be more appropriate
21:26:24 <HeladoDeBrownie> bob_twinkles, running with what jle` said, i guess your problem is the syntax looking too imperative?
21:26:36 <jle`> not quite the syntax...the algorithm
21:26:42 <gcganley> johnw: thats amazing... haskell will never stop amazing me
21:27:12 <johnw> HeladoDeBrownie: I'm using State to allocate stack slots during processing of an assembly DSL encoded in the free monad.  I'm not sure how "clear" the example will be in isolation
21:27:12 <bob_twinkles> sort of both: the syntax looks imperative, so my brain goes straight to formulating imperative code when there's usually a more functional solution
21:27:42 <HeladoDeBrownie> johnw, that's okay, i just wanted to see what sort of operations you used over it
21:27:55 <jle`> > flip evalStateT 0 $ mapM_ (modify . (+)) [1..10] >> get
21:27:56 <lambdabot>  No instance for (GHC.Show.Show (m0 b0))
21:27:56 <lambdabot>    arising from a use of ‘M141189278801263976410496.show_M1411892788012639764...
21:27:56 <lambdabot>  The type variables ‘b0’, ‘m0’ are ambiguous
21:28:05 <jle`> > flip evalState 0 $ mapM_ (modify . (+)) [1..10] >> get
21:28:07 <lambdabot>  55
21:28:18 <jle`> > getSum . foldMap Sum $ [0..10]
21:28:20 <lambdabot>  55
21:28:22 <johnw> HeladoDeBrownie: for example, 'getLabel' in https://github.com/jwiegley/linearscan/blob/master/test/Tempest.hs
21:28:28 <jle`> an imperative approach, and a functional approach :)
21:28:36 <johnw> note that I typically use the 'lens' library for working with State
21:28:38 <gcganley> :t getSum
21:28:39 <lambdabot> Sum a -> a
21:28:41 <HeladoDeBrownie> bob_twinkles, i see where you're coming from. the way i see it, State(T) lets me hide the details when i otherwise would have threaded state myself. you're right that it's not the best tool for every job it can perform.
21:28:46 <gcganley> :info Sum
21:28:57 <gcganley> i keep forgetting thats not a thing for lambdabot
21:29:06 <jle`> gcganley: Sum is just a newtype wrapper over a number so that mappend/mconcat adds things together
21:29:14 <jle`> > Sum 3 <> Sum 10
21:29:16 <lambdabot>  Sum {getSum = 13}
21:29:29 <jle`> foldMap f [1,2,3] = f 1 <> f 2 <> f 3 etc.
21:29:31 <gcganley> jle`: is there one for (*)
21:29:35 <jle`> mhm
21:29:38 <jle`> can you guess what it's called? :)
21:29:43 <gcganley> Product
21:29:55 <jle`> > getProduct . foldMap Product $ [1..10]
21:29:56 <lambdabot>  3628800
21:29:58 <mniip> sssilver, my code might be buggy
21:30:20 <gcganley> jle`: isnt there something like Max and Min
21:30:24 <jle`> the newtype wrappers are kind of messy/hacky
21:30:25 <HeladoDeBrownie> johnw, i see, so it seems like you sort of use it as a way to organize code, i guess?
21:30:27 <gcganley> jle`: for monoids
21:30:29 <jle`> gcganley: yes, but those aren't monoids
21:30:34 <jle`> what would the identity be?
21:30:38 <EvanR> :t Max
21:30:38 <lambdabot> Not in scope: data constructor ‘Max’
21:30:39 <gcganley> jle`: semigroups
21:30:41 <johnw> HeladoDeBrownie: without it, I would have had to do a lot of error-prone manual book-keeping
21:30:45 <HeladoDeBrownie> got it
21:30:46 <jle`> gcganley: that's better :)
21:30:50 <HeladoDeBrownie> johnw, thanks for sharing
21:31:02 <gcganley> jle`: this is why i need that cat theory book lol
21:31:07 <jle`> haha this isn't erally cat theory
21:31:12 <jle`> this is more algebra
21:31:15 <johnw> State insulates the complexity of managing state in the function where I need, from the surrounding code that does not need to care about state being managed.  With manual folds, that would not be the case.
21:31:16 <jle`> (abstract) algebra
21:31:43 <gcganley> johnw: can you unwind a state monad?
21:31:43 <jle`> the same kind of algebra that you think about when you do things like x*(y+z) = x*y + x*z
21:31:49 <jle`> except generalized to things other than numbers
21:31:56 <johnw> gcganley: what do you mean?
21:31:56 <gcganley> johnw: or is that the comonad...
21:32:10 <johnw> you can always use runState anytime you like
21:32:29 <johnw> you only need a comonad instance if you want to do it without knowing which comonad it will be
21:32:45 <jle`> is there a way i can get coerce . foldMap coerce $ [1..10] to do what i want...
21:32:59 <jle`> i probably have to do coerce . foldMap Sum $ [1..10]
21:33:10 <gcganley> :t coerce
21:33:11 <lambdabot> (Contravariant f, Functor f) => f a -> f b
21:33:16 <jle`> not that coerce, heh
21:33:19 <jle`> the coerce from GHC
21:33:26 <gcganley> oh shit what the hell is contravariant
21:33:52 <jle`> it's like a backwards functor kinda
21:33:56 <HeladoDeBrownie> @type fmap
21:33:57 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:34:01 <HeladoDeBrownie> flip the direction of a -> b
21:34:02 <jle`> functor lets you use an (a -> b) to turn an f a into an f b
21:34:05 <HeladoDeBrownie> that gives you contramap
21:34:11 <jle`> contravariant functor lets you use a (a -> b) to turn an f b into an f a
21:34:21 <mniip> sssilver, maybe not
21:34:22 <gcganley> wait is that dimap?
21:34:24 <gcganley> :t dimap
21:34:25 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
21:34:29 <gcganley> nope
21:34:30 <gcganley> lol
21:34:32 <jle`> it's actually lmap
21:34:35 <sssilver> mniip: that’s better than what I have (nothing)
21:34:36 <jle`> if you know what profunctors are
21:34:42 <jle`> it's lmap for things without rmap
21:34:49 <HeladoDeBrownie> profunctors are covariant/contravariant on different variables, right?
21:34:59 <gcganley> jle`: so not as strong as profunctors?
21:35:01 <gcganley> :t lmap
21:35:02 <lambdabot> Profunctor p => (a -> b) -> p b c -> p a c
21:35:05 <jle`> Functor is rmap w/out lmap, and Contravariant is lmap w/out rmap
21:35:10 <jle`> if you know what Profunctors are
21:35:13 <HeladoDeBrownie> ah yeah, looks like
21:35:27 <HeladoDeBrownie> jle`, hand-waving variable order i guess?
21:35:33 <johnw> HeladoDeBrownie: correct
21:35:41 <jle`> hand-waving over the different kinds :)
21:35:47 <gcganley> jle`: thats pretty trippy, so its just how the 'functor' is structred. because Functor in haskell is an endofunctor no?
21:35:49 <HeladoDeBrownie> that too
21:35:52 <johnw> HeladoDeBrownie:  a profunctor P a b is contravariant in a, covariant in b
21:35:57 <HeladoDeBrownie> johnw, got it
21:36:22 <HeladoDeBrownie> so like functions
21:36:30 <jle`> functions are one example
21:36:37 <jle`> :D
21:37:10 <HeladoDeBrownie> Either on the other hand is not pro…
21:37:15 <HeladoDeBrownie> because it's covariant in both variables
21:37:34 <EvanR> what does covariant and contravariant mean in the context of type parameters
21:37:35 <jle`> yea, a bifunctor
21:37:44 <EvanR> or category theory, or whatever
21:37:46 <gcganley> :t bimap
21:37:47 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
21:37:52 <gcganley> :t dimap
21:37:53 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
21:37:54 <HeladoDeBrownie> EvanR, basically, which direction it maps
21:37:58 <HeladoDeBrownie> @type fmap
21:37:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:38:06 <johnw> HeladoDeBrownie: profunctors are way more general than what they are in Haskell, where they resemble an abstraction of functions
21:38:11 <HeladoDeBrownie> fmap represents a (co)functor
21:38:20 <HeladoDeBrownie> if you flip a and b you get contravariant
21:38:28 <jle`> it is also a cocofunctor
21:38:29 <EvanR> yeah i know contrafunctor
21:38:33 <gcganley> johnw: what SHOULD they be in haskell?
21:38:47 <EvanR> just not what is co or contra about any of it
21:38:52 <johnw> because if you think about it, (->) is contravariant in Hask, and covariant in Hask, which is exactly what functions do too
21:38:58 <HeladoDeBrownie> johnw, presumably because Hask is so limited compared to all the other possible categories out there?
21:39:03 <jle`> cocofunctors are the most delicious types of functors
21:39:14 <johnw> gcganley: they should be just what they are in Haskell, where they map from Hask^op back to Hask
21:39:25 <EvanR> cocoanything
21:39:26 <gcganley> jle`: im in love with the cocofunctors
21:39:33 <jle`> i'm coco for cocofunctors
21:39:41 <HeladoDeBrownie> hot cocoafunctors, good after a morning of shoveling snow
21:39:52 <HeladoDeBrownie> (speaking of, wow, what is even happening over here on the us east coast)
21:40:03 <gcganley> HeladoDeBrownie: i dont want to hear the s word... 4 feet is enough
21:40:08 <johnw> HeladoDeBrownie: a CT profunctors maps from some C^op to D, where neither may resemble sets at all
21:40:10 <HeladoDeBrownie> gcganley: D: my condolences
21:40:21 <johnw> nor do C and D have to be similar in any way
21:40:30 <gcganley> HeladoDeBrownie: #flatroofprobs
21:40:53 <jle`> perhaps we can parameterize Profunctors on two categories then
21:40:54 <HeladoDeBrownie> it's funny how my client makes that into a channel link
21:40:55 <EvanR> /join #flatroofprobs
21:40:59 <HeladoDeBrownie> EvanR, exactly
21:41:05 <johnw> jle`: edwardk's hask library does do that
21:41:13 <johnw> using poly-kinds
21:41:19 <HeladoDeBrownie> i might join that channel but my roof is quite sloped indeed
21:41:23 <jle`> i suspected it would
21:41:27 <jle`> it did that for Functor
21:42:12 <jle`> can wemake that the next big change in base
21:42:17 <jle`> bring in parameterized Functor
21:42:49 <johnw> what is a parameterized Functor?
21:43:04 <jle`> a Functor parameterized on its source and target Category
21:43:15 <jle`> instance Functor (->) Maybe where
21:43:17 <gcganley> johnw: a functor with parameters Kappa
21:43:25 <johnw> I see
21:43:31 <jle`> or well
21:43:32 <tomphreek> @src length
21:43:32 <lambdabot> Source not found. Take a stress pill and think things over.
21:43:36 <jle`> instance Functor (->) (->) Maybe where
21:44:14 <jle`> um
21:44:27 <johnw> you mean class Functor f g a where fmap :: f a b -> g a b?
21:45:01 <gcganley> johnw, jle`: thats called an ExtraFunctor
21:45:08 <gcganley> not really
21:45:11 <jle`> class Functor s t f where fmap :: s a b -> t (f a) (f b)
21:45:12 <jle`> ...i think
21:45:20 <johnw> oh, right, of course
21:46:19 <tomphreek> is length O(N) or does haskell update length when list is changed?
21:46:44 <gcganley> tomphreek: O(N) unless im woefully misinformed
21:46:48 <johnw> tomphreek: length is O(n) according to the Haddocks
21:47:54 <tomphreek> johnw: ah cheers, did realise it's there. dah
21:47:56 <jle`> class EndoFunctor s f where fmapEndo :: s a b -> s (f a) (f b)
21:48:28 <gcganley> jle`: i thought that Functor was already an endofunctor...
21:48:56 <jle`> gcganley: Functor is only a Endofunctor on (->) w/ haskell types
21:49:16 <jle`> this other EndoFunctor gives you an endofunctor on different Categories
21:49:41 <jle`> it's a...more "polymorphic" version
21:49:51 <johnw> I think s will need to be a Profunctor here
21:49:51 <jle`> Int -> Int vs. a -> a
21:49:57 <jle`> does it?
21:50:19 <jle`> you just write instances for whatever s you want, right?
21:50:23 <johnw> well, otherwise 'a' might not be contravariant in the instance
21:50:25 <tomphreek> length l                =  lenAcc l 0#lenAcc :: [a] -> Int# -> Int
21:50:31 <johnw> and then it's not a functor
21:50:47 <johnw> it's something else possibly useful, but not a functor
21:50:54 <jle`> instance EndoFunctor (->) Maybe where fmapEndo f Nothing = Nothing; fmapEndo f (Just x) = Just (f x)
21:50:54 <tomphreek> googled haskell sharp operator, no results
21:51:10 <Axman6> tomphreek: that's using unboxed Ints
21:51:12 <johnw> yeah, that works because (->) is a Profunctor :)
21:51:19 <Axman6> @src Int
21:51:19 <lambdabot> data Int = I# Int#
21:51:19 <johnw> instance EndoFunctor (,) Maybe
21:51:21 <johnw> what does that mean?
21:51:41 <jle`> well you couldn't write an instance
21:51:44 * hackagebot resourcet 1.1.4.1 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-1.1.4.1 (MichaelSnoyman)
21:51:46 <jle`> ...acn you?
21:51:54 <jle`> ...
21:52:04 <jle`> oh i see
21:52:06 <johnw> fmapEndo (x,y) = (Just x, Just y)
21:52:17 <gcganley> calling edwardk
21:52:20 <jle`> Profunctor is not strong enough
21:52:22 <jle`> it has to be a Category
21:52:23 * edwardk is called
21:52:26 <edwardk> what can i do for you?
21:52:26 <gcganley> calling Cale
21:52:40 <jle`> you need Category in order to express the laws
21:52:50 <jle`> Profunctor is also too strong i think
21:52:54 <jle`> in some aspects
21:52:56 <johnw> quite possibly so
21:52:59 <tomphreek> Axman6: cheers, I have a googleable term now :)
21:53:00 <johnw> edwardk would know
21:53:01 <gcganley> edwardk: we're having trouble trying to figure out what a category is
21:53:21 <gcganley> edwardk: and how to define it in haskell
21:53:29 <jle`> i think Category is basically the only thing that would make sense here...considering that an endofunctor is category to itself
21:53:34 <edwardk> See Control.Category
21:53:47 <edwardk> or the work in sjoerd visscher's data-category code
21:53:54 <gcganley> edwardk: no jle` wants a functor with an extra arg
21:54:00 <gcganley> parameter sorry
21:54:03 <edwardk> which one?
21:54:07 <jle`> instance Category s => EndoFunctor s f where fmapE :: s a b -> s (f a) (f b)
21:54:21 <edwardk> that is better served by two args
21:54:22 <jle`> you need the Category constraint in order to express the laws...
21:54:26 <edwardk> f c d
21:54:30 <edwardk> for two categories c and d
21:54:34 <jle`> but it is EndoFunctor
21:54:58 <johnw> jle`: oh, of course, that only needs Category
21:55:01 <edwardk> http://hackage.haskell.org/package/hask-0/docs/src/Hask-Category.html#Functor
21:55:03 <johnw> I must be too sleepy
21:55:13 <edwardk> well, why bother defining EndoFunctor?
21:55:16 <gcganley> johnw: you need more coffee
21:55:20 <edwardk> when its just Functor f c c
21:55:23 <jle`> instance (Category s, Category t) => Functor s t f where fmap :: s a b -> t (f a) (f b)
21:55:24 <johnw> i'm drinking mint tea, which is doing nothing
21:55:36 <jle`> yea we were just playing around
21:55:36 <edwardk> jle`: class, not instance
21:55:41 <jle`> ah yes
21:55:50 <gcganley> johnw: now i want tea... thanks a ton jon >:(
21:55:51 <jle`> any reason why you want f to be the first parameter
21:55:53 <edwardk> and you want a fundep or this is awful to use
21:55:56 <gcganley> s/jon/john
21:56:15 <edwardk> class (Category c, Category d) => Functor f c d | f -> c d where fmap :: c a b -> d (f a) (f b)
21:56:22 <edwardk> see hask for a much more fleshed out version
21:56:29 <edwardk> but its also better to use type families for 'c' and 'd'
21:56:30 <jle`> this is just a husk.  see hask
21:56:50 <edwardk> hask uses a more fleshed out category though
21:56:59 <edwardk> Control.Category isn't solid enough to support product and sum categories
21:57:08 <jle`> 7.12 ?
21:57:18 <edwardk> ?
21:57:27 <edwardk> 7.12 seems unlikely to change that situation
21:57:29 <jle`> is that the target for fixing Control.Category
21:57:32 <edwardk> no
21:57:34 <jle`> aw.
21:57:35 <gcganley> edwardk: where is the Ausie talk btw? is it coming down the pipe or will it never see the light of day
21:57:44 <edwardk> gcganley: haven't heard
21:57:51 <jle`> btw can we move bifunctor into base so that people will stop using Arrow for tuple tricks
21:57:58 <gcganley> edwardk: that makes me sad
21:58:05 <edwardk> jle`: already done
21:58:09 <jle`> :O :O :O
21:58:11 <edwardk> jle`: it is in 7.10
21:58:15 <jle`> :O :O
21:58:18 <edwardk> there was a proposal, it passed
21:58:27 <jle`> i should probably keep up with these
21:58:30 <edwardk> the proposal included bifoldable/bitraversable, but we only implemented the bifunctor part to start
21:58:37 <gcganley> edwardk: i voted for BBP, when are the results coming out?
21:58:46 <edwardk> gcganley: the voting ends the 21st
21:58:52 <edwardk> then the simons make a decision
21:58:59 <edwardk> we'll publish aggregate statistics after that
21:59:08 <jle`> such transparent
21:59:23 <gcganley> edwardk: its not very clear what the advantage for the list based approach is
21:59:58 <jle`> from what i gather, there are two main camps...(1) pedagogy, and (2) distrust of the Foldable/Traversable abstractions as they are currently implemented
22:00:03 <jle`> but i don't want to start a debate on here
22:00:25 <edwardk> well, the libraries submission process is that we take polls to inform decisions, and that maintainers should seriously consider community feedback, and well designed third-party proposals but that the maintainers decide, since the CLC (maintainer for base) is effectively fairly partisan in this effort, we kicked the maintainer decision upstream to the
22:00:25 <edwardk> simons
22:00:49 <edwardk> so the vote itself isn't binding, but does enable this decision to reflect the will of the community as a whole
22:01:07 <jle`> oh my statement earlier wasn't sarcastic
22:01:16 <gcganley> edwardk: and this is slated for 7.10 if im not mistaken
22:01:34 <jle`> is 7.10 the first edwardk release? or did you helm 7.8 too?
22:01:44 <edwardk> gcganley: yes, the 7.10 release was pushed back a month because of this and another issue
22:01:49 <gcganley> i really want a thought out blog about the advantages of the list based approach
22:02:13 <gcganley> edwardk: ok, i saw something about that on the ghc-dev mailing list i just wasnt sure
22:02:18 <edwardk> jle`: well, the core libraries committee was formed half way through 7.8, but we didn't act during that release very much except to review a few breaking changes and decide some policy stuff
22:02:50 <edwardk> gcganley: i would appreciate a viable defense of the list-based approach as well. ;)
22:03:09 <jle`> whatever you do just don't look on twitter
22:03:18 <gcganley> jle`: #bbp
22:03:20 <johnw> Most of my code uses Foldable/Traversable, hiding the list-based variants, and I've never noticed any downside
22:03:32 <edwardk> gcganley: that said, as the whole debate wages on one thing that is consistently surprising to me is how little the options put forth on the list side surprise me. they are all things we've been considering for the last year and a half.
22:03:52 <johnw> edwardk: that's a very good sign
22:04:10 <edwardk> johnw: yeah, if anything its letting me feel more settled rather than less
22:04:14 <johnw> yep
22:04:18 <jle`> the non-pedagogy (makes it harder to learn) arguments i have seen seem to be on problems or like non-rigor-ness with the Foldable/Traversable typeclasses
22:04:25 <edwardk> but we'll see when the numbers are in and the simons make their decision
22:04:52 <gcganley> i think foldable/traversable were the least of my concerns when learning haskell
22:04:55 <edwardk> the turnout so far has been quite impressive
22:05:09 <edwardk> we _just_ had out 700th response
22:05:10 <jle`> i think they see Foldable/Traversable as abstractions that really aren't too rigorous or mature (particularly Foldable) so they want to hold off on "endorsing" it and embedding it officially Prelude
22:05:12 <edwardk> er our
22:05:23 <gcganley> can someone clarify why the word so is highlighted in erc?
22:05:39 <johnw> gcganley: dude, thank you for wondering that; I thought I was alone in this life
22:06:01 <jle`> you emacs people
22:06:07 <edwardk> sclv gave me a pretty excellent quote from Lawvere back in 1990 that i think applies well to the libraries debate
22:06:19 <edwardk> “Heaviside formulates what has been my own attitude for the past thirty years: the fact that our knowledge will never of course be complete, and hence no general theory will be final, is no excuse for not using now the most general theory which science can support, and indeed for accuracy we must do so.” -- Lawvere, Categories of Space and Quantity
22:06:23 <johnw> so<TAB> says that 'so:' is an auto-completion for some nick
22:06:24 <gcganley> who the hell is Lawvere....
22:06:31 <mauke> gcganley: it's a nick
22:06:37 <sclv> Lawvere is a mathemetician
22:06:40 <jle`> a very unfortunate nick
22:07:03 <gcganley> why do you do this so
22:07:03 <edwardk> gcganley: he kinda put category theory on firm enough grounding you could build all of mathematics on top of it, rather than starting with sets, then did a bunch of other stuff
22:07:24 <johnw> I hope he or she's at least someone significant other
22:07:32 <sclv> interestingly enough, been reading a bit about Heaviside and he's an impressive figure
22:07:53 <jle`> yes without him we wouldn't have stairs
22:07:55 <sclv> sort of a prototype hacker
22:07:58 <gcganley> edwardk: I asked the channel a little while back. if i wanted to get started in cat theory and wated to get a book to read what would you recommend? the only math i know is calc 1 in HS
22:08:05 <edwardk> For a man with a name like Heaviside, he was a bit on the skinny side
22:08:08 <jle`> (is this the same heaviside)
22:08:13 <dramforever> johnw: I've never seen so active here
22:08:19 <sclv> very practically focused, and also a mathematical innovator
22:08:21 <johnw> gcganley: Lawvere's book is a good one :)
22:08:24 <edwardk> gcganley: http://www.quora.com/What-is-the-best-textbook-for-Category-theory?share=1
22:08:25 <sclv> yeah, heaviside step function, etc
22:08:50 <jle`> without heaviside i would not have a mathematical model for my staircase
22:09:03 <jle`> thank you heaviside
22:09:04 <sclv> lots of mathematicians thought he was terribly undisciplined, because he was bending their math to his needs
22:09:05 <gcganley> edwardk: whats quora?
22:09:16 <c74d> gcganley: In WeeChat I can set a list of nicks to not colorize when they appear in messages; perhaps ERC has similar?
22:09:26 <edwardk> gcganley: random q&a forum. i occasionally post there to reach out to folks outside of our core demographic
22:09:33 <jle`> c74d: your weechat highlights nicks when they appear in messages?
22:09:33 <dramforever> gcganley: like stackoverflow, but more general
22:09:38 <edwardk> gcganley: that particular link is a response i wrote to your exact question
22:09:38 <sclv> meanwhile Heaviside's main preoccupation was building lots of efficient telegraph lines!
22:09:40 <jle`> like yahoo answers, but more social
22:09:57 <sclv> a very good example of searching for deeper theory as driven by eminently practical issues
22:10:07 <edwardk> sclv: *nods*
22:10:23 <johnw> c74d: no, it's an incredibly simple mod doing the highlighting, it doesn't have that logic yet.  trivial to add though
22:10:27 <jle`> but how come people still get mad at me when i define dirac delta as the first derivative of heaviside step
22:10:40 <gcganley> edwardk: maybe i should google before i ask... that should be a rule in life
22:10:51 <c74d> jle`: With a script from weechat.org, yes.
22:11:45 <gcganley> c74d: i might just look up the guy that wrote ERC, the guy that wrote smartparens hangs around here
22:13:33 <c74d> jle`: <https://weechat.org/scripts/source/colorize_nicks.py.html>
22:13:50 <jle`> c74d: just installed it :)
22:14:46 <gcganley> c74d: what is weechat?
22:15:07 <Fuco> bad remake of irssi
22:15:28 <gcganley> Fucco: tell me how you really feel
22:15:28 * EvanR begins a bad remake of weechat
22:15:42 <gcganley> the EvanRemake
22:15:42 <Fuco> tired
22:16:00 <Fuco> woke up at 6, couldn't sleep... studying sanskrit now
22:16:15 <gcganley> Fuco: its 1:14 on the east coast
22:16:38 <gcganley> Fuco: and im sorry aobut the sanskrit
22:16:41 <Fuco> well obviously I'm nowhere near the US :)
22:16:49 <Fuco> why sorry?
22:18:17 <gcganley> Fuco: I appologize when im tired
22:18:22 <gcganley> Fuco: im sorry
22:18:33 <jle`> im sorry too
22:18:47 <gcganley> jle`: sorry
22:19:03 <gcganley> johnw: how's the tea
22:19:10 <johnw> colder than it was before
22:19:21 <gcganley> johnw: im sorry
22:19:22 <johnw> time to do more Haskelling
22:21:22 <gcganley> edwardk: would there be a situation where haskell would be an extremly poor langauge choice?
22:21:41 <edwardk> it is kind of my mission to find those cases and eradicate them ;)
22:22:08 <edwardk> one could argue that directly coded systems programming fits that niche, but i tend to believe in just writing such code in an EDSL and having it generate the systems code
22:22:10 <gcganley> edwardk: well I know that but what is the soft spot right now
22:22:34 <johnw> games programming
22:22:35 <edwardk> cowley's compose conference talk hits this same note near the end
22:22:35 <jle`> how about writing and submitting assignments for a c++ class
22:22:44 <edwardk> games programming in haskell is getting pretty sexy
22:22:52 <EvanR> jle`: there needs to be a DSL for that too
22:22:55 <edwardk> that is kind of what i've been trying to show with gl, sdl2, quine
22:22:55 <Big_G> Does anyone know if there is a generic software development channel?
22:23:05 <edwardk> we kinda suck at GUIs right now
22:23:21 <gcganley> edwardk: your quine project does look rather sexy
22:23:26 <johnw> I would enjoy really awesome Cocoa bindings
22:23:46 <gcganley> Big_G: is #programming still a thing? or is it still super toxic
22:23:53 <edwardk> gcganley: it should get a whole lot nicer looking when i can get around to getting back to it and finishing the second generation rendering pipeline i have started
22:24:00 <ttt_fff> newtype Foo = Foo [Int] -- why can't I auto inherit (++) :: Foo -> Foo -> Foo ?
22:24:20 <Big_G> gcganley, Still a thing but most of it has been useless. I'm looking for a more mature place to hear about cool topics and talk to real devs
22:24:20 <edwardk> johnw: chakravarty has fancy inline objective-c stuff that makes that kinda easy to write
22:24:22 <ttt_fff> or more generally, for any 'a', newtype Foo = Foo [a] --> why can't I auto inherit (++) :: Foo -> Foo -> Foo ?
22:24:26 <johnw> ttt_fff: there are no implicit conversions in Haskell like that
22:24:34 <ttt_fff> johnw: is there an extension for this?
22:24:37 <johnw> no
22:24:44 <johnw> it exists in languages like Idris, or Coq, but not in Haskell
22:24:52 <gcganley> johnw: ive never used cocoa is it good?
22:24:57 <ttt_fff> idris looks more attractive by the day
22:25:06 <johnw> gcganley: well, it can look pretty
22:25:25 <gcganley> johnw: is it easy to use/learn is what im asking. i know it can look pretty lol
22:25:30 <sssilver> Guys, as I’m ripping my hair off trying to learn Haskell, one question tortures my mind. How do you debug your programs to understand what’s actually going on?
22:25:35 <johnw> well, it's easy to get started with, sure
22:25:47 <johnw> but knowing what to use, when, and how, as with anything, takes a lot of time and experience
22:26:02 <johnw> fortunately, there are tons of books on it :)
22:26:09 <gcganley> johnw: i might learn swift if its worth it. I havent heard any good or bad things about it
22:26:19 <Axman6> sssilver: usually Dabug.Trace.trace
22:26:26 <johnw> my ex-business partner is now one of the Swift developers
22:26:31 <Axman6> Debug.Trace.trace*
22:26:49 <gcganley> johnw: like on the language team?
22:26:53 <sssilver> like I have this weird nested list comprehension that’s quite obviously wrong. If I could go step-by-step, I’d probably make some sense out of it. But all I have right now is compiler’s message that basically says “shit’s bad”. And since Haskell doesn’t really have “steps”, going step-by-step doesn’t even seem to make sense to me.
22:26:53 <johnw> yeah
22:27:04 <johnw> well, he does the libraries mainly
22:27:11 <johnw> but I'm sure that feeds back into language design
22:27:16 <Axman6> ttt_fff: inheritance is not something that happens on types in Haskell
22:27:16 <jle`> can you break up the list comprehension into steps?
22:27:20 <jle`> usign do notation, maybe?
22:27:26 <Big_G> gcganley, Any ideas of what that kind of chanell that would be?
22:27:30 <johnw> jle`: see Wadler's paper
22:27:39 <jle`> johnw: addressing sssilver
22:27:43 <gcganley> johnw: thats cool. honestly i havent even looked at the syntax. is it similar to any language or is completely differnt?
22:27:45 <johnw> he introduces monads by taking apart list comprehensions :)
22:27:59 <johnw> gcganley: it's both similar and different :)
22:28:15 <gcganley> johnw: to any lang in particular?
22:28:24 <johnw> I don't know it well enough to say
22:28:40 <gcganley> lets see if there is a #swift
22:29:03 <johnw> check for a ##swift too
22:31:41 <gcganley> johnw: it looks as though its #swift-lang
22:31:54 <gcganley> johnw: i just got shouted at in #swift
22:32:54 <matt3> does anyone know how to query for a field that is NULL in persistent?
22:33:39 <matt3> for example "select * from table where column is NULL"
22:33:53 <matt3> basically if the maybe value is Nothing
22:34:11 <Axman6> what do you mean by "where column is NULL"?
22:34:26 <Axman6> where foo == NULL;?
22:34:42 <Axman6> oh right, you need to use persistent to do that
22:35:08 <matt3> Axman6: this is just an arbitraty SQL statement
22:35:10 <johnw> if persistent can't do it, I know that esqueleto ca
22:35:12 <johnw> n
22:35:30 <matt3> johnw: i'd rather not have to add more dependencies if I don't need to
22:36:03 <matt3> I don't think my query is too crazy, so I'm wondering if there's a nice way to do it without esqueleto
22:36:45 * hackagebot validation 0.5.1 - A data-type like Either but with an accumulating Applicative  http://hackage.haskell.org/package/validation-0.5.1 (TonyMorris)
22:38:18 <cfoch> hello
22:38:32 <cfoch> is there a function which does the same than ":t ___" ?
22:39:27 <matt3> like somthing that gives you the type of an expression?
22:39:30 <matt3> :t map
22:39:31 <lambdabot> (a -> b) -> [a] -> [b]
22:39:50 <mniip> cfoch, yeah, check typeOf in Data.Typeable
22:40:02 <sssilver> :t Data.Set.Set
22:40:03 <lambdabot> Not in scope: data constructor ‘Data.Set.Set’
22:40:10 <matt3> ;_;
22:40:32 <mniip> :t typeOf
22:40:33 <lambdabot> Typeable a => a -> TypeRep
22:40:35 <mniip> o nice
22:41:09 <mniip> cfoch, typeOf can only handle monomorphic types though
22:42:13 <sssilver> https://dpaste.de/UDA3 — why is my potentialCells failing to compile in that form?
22:42:50 <mniip> what's the error
22:42:58 <sssilver>     Expecting one more argument to ‘Data.Set.Set’
22:43:15 <mniip> Set is a type constructor
22:43:20 <mniip> :k Set
22:43:21 <lambdabot>     Not in scope: type constructor or class ‘Set’
22:43:21 <lambdabot>     Perhaps you meant one of these:
22:43:21 <lambdabot>       ‘S.Set’ (imported from Data.Set),
22:43:24 <mniip> :k S.Set
22:43:25 <lambdabot> * -> *
22:44:27 <mniip> why the hell does ghc-api avoid Show so much
22:44:46 <bitemyapp> "why the hell" -> somebody ain't fixed it yet :)
22:45:10 <EvanR> aint nobody got time for that
22:45:10 <mniip> it has its own stringifying typeclass called Outputtable which, I think, can't be used outside a GhcMonad
22:47:10 <Axman6> sssilver: your Data.Set.Set should be Data.Set.Set Int because it is a Set of Ints
22:47:38 <sssilver> Axman6: it should actually be a set of Int, Int tuples >.<
22:47:47 <Axman6> you're written something analogous to [[]] as a type, instead of [[Int]]
22:47:58 <Axman6> sssilver: ok, then ..Set (Int, Int)
22:48:46 <sssilver> But yeah this is megahard :(( the initial excitement of seemingly “understanding” the things I’ve read in the book in form of pure theory/knowledge has definitely wore off as I bang my head repeatedly against the wall of real errors with little guidance
22:49:23 <EvanR> regularly type working things into ghci to feel better ;)
22:50:16 <Axman6> sssilver: you're just not asking enough questions in #haskell-beginners and #haskell ;)
22:50:28 <sssilver> Axman6: I’m asking too many in my opinion
22:50:49 <EvanR> (S.fromList [2,4,6,8]) `S.intersection` (S.fromList [2,3,4,5])
22:51:23 <sssilver> makes me realize how much of easiness of learning imperative programming we take for granted
22:51:28 <Axman6> as a beginner, you'll run into many issues, ranging from syntactical to conceptual, and many of those the easiest way to fix them is a) to ask and b) to practice a lot
22:52:11 <EvanR> sssilver: easy to learn python, hard to write any decent code
22:52:30 <EvanR> hard to learn C
22:52:42 <EvanR> imperative can be hard
22:52:47 <EvanR> functional can be easy
22:52:52 <matt3> EvanR: hard to learn C, hard to write good C
22:52:53 <sssilver> it’s not really hard to learn C. Perhaps it’s hard to do manual memory management, but that’s not the hardship of C. That’s the hardship of manual memory management.
22:53:17 <extor> Besides manual memory management is there nothing else hard about C?
22:53:22 <EvanR> sssilver: you found C easy? and this is hard? ;)
22:53:51 <sssilver> I’m a C++/Python programmer with about 12 years of experience. I find Haskell really hard at this point.
22:53:53 <mniip> at what point did vague typecheker errors whilst having 2 versions of a package, evolve into
22:53:55 <mniip> GHCi runtime linker: fatal error: I found a duplicate definition for symbol fps_reverse whilst processing object file /usr/local/lib/x86_64-linux-ghc-7.6.3/bytestring-0.9.2.1/libHSbytestring-0.9.2.1.a
22:54:12 <EvanR> sssilver: ah yeah, this is the beginning of breaking out of 12 years of experience
22:54:16 <matt3> sssilver: well the problem is that with a language like this, you have to learn programming all over again
22:54:18 <extor> sssilver maybe you're just set in your ways by now
22:55:08 <sssilver> I really want to make the shift, the only thing I have to figure out is a working mechanism of learning that doesn’t involve begging strangers on the Internet to assist with apparently trivial problems
22:55:09 <EvanR> you will now begin 12 years experience in something completely different
22:55:20 <EvanR> not even counting haskell
22:55:22 <sssilver> (however awesome the strangers are)
22:55:45 <mniip> as someone who knew a good dozen of totally different languages before haskell, haskell did introduce some ground-breaking concepts, but nothing incomprehensible
22:55:49 <EvanR> its going to be hard to get started without talking to anyone
22:55:53 <extor> Why do python and other programmers typically transition to haskell, is it lust for something it promises?
22:55:55 <Axman6> sssilver: we've all been there and all got excellent assisstance from strangers on the internet. none of us mind. we may ask you to move the discussions to another channel, but help will continue
22:56:02 <mauke> extor: pugs
22:56:08 <extor> pugs?
22:56:14 <Axman6> mauke: that's more perl programmers
22:56:16 <mniip> sssilver, have you heard of LYAH?
22:56:25 <mauke> Axman6: falls under "other"
22:56:33 <Axman6> I guess
22:56:36 <sssilver> extor: for me it’s because A) OO never felt quite right, and B) with Python, lack of types feels dirty
22:56:46 <sssilver> mniip: that’s the book I’m going with
22:56:50 <EvanR> sssilver: i had the same feeling when i did OO in python
22:57:02 <sssilver> EvanR: OO anywhere doesn’t feel right to me
22:57:04 <mniip> well I had nearly no issues with haskell whilst reading LYAH
22:57:06 <mniip> or so I think
22:57:10 <EvanR> either i was broken, or it was broken, or both
22:57:20 <EvanR> i couldnt seem to do anything "right"
22:57:21 <sssilver> I always get tangled up in questions like “does the dog eat the bone or does the bone get eaten by the dog” etc etc
22:57:32 <extor> I've heard haskell is useful for OCR programming. But beyond that I'm not sure why anyone would want to learn it. I'm not saying there's no reason since I'm mostly ignorant about the language but just saying I myself am curious as to why people percieve the grass to be greener on the haskell side
22:57:43 <mniip> sssilver, well in haskell the eating process consumes both a bone and a dog
22:57:57 <sssilver> mniip: exactly, and that does feel right
22:58:02 <extor> sssilver yes OOP doesn't feel right to me either, I'm learning a bit of OOP with C#, barely.
22:58:19 <EvanR> putMVar dog bone
22:58:21 <sssilver> I come to Haskell because I am tired of ambiguity.
22:58:28 <mauke> sssilver: should've tried Lisp OO :-)
22:58:29 <mniip> HAHAH
22:58:49 <extor> sssilver where you you see yourself in 6 months, 1 year and 2 years with haskell? How will it enrich you?
22:59:54 <valdyn> extor: do some www.projecteuler.net, then after solving one, see a good haskell solution, then compare to c or python solution ;)
23:00:00 <sssilver> extor: I’ll be a better programmer. In 6 months I’ll be 6 months better. In 1 year I’ll be 1 year better. Et cetera. “Better” as in, I’ll engineer better systems that are more logical and cleaner and easier and so on.
23:01:14 <extor> sssilver what do you design nowadays, will you be designing for the same niche later or are you switching to another industry?
23:01:35 <EvanR> sssilver: at least, youll see how many things could go wrong in the engineered system. hopefully you can do something about some of it ;)
23:01:41 <extor> valdyn unfortunately I don't know much math beyond elementary calc and probability theory.
23:01:54 <valdyn> extor: thats enough
23:02:00 <mauke> (defclass dog ...) (defclass bone ...) (defgeneric eat (animal food)) (defmethod eat ((the-dog dog) (the-bone bone)) ...)
23:02:58 <sssilver> extor: I’m not switching to another industry. For my dayjob I engineer scalable web services (I’m a senior software engineer at RetailMeNot.com). For my hobby, I love programming video games.
23:03:28 <extor> sssilver will haskel be used at work in web services, or just games?
23:04:04 <sssilver> extor: it’ll start with just games. Once I have a good command for it, I’m lucky enough to have the position to introduce it to the stack of my department, as long as I vouch for it.
23:04:25 <extor> Will your work allow you to bring in all the overhead and risk associated with such a revolution?
23:04:56 <sssilver> yes, my particular department is all about going crazy and experimental.
23:05:06 <sssilver> as long as we ship, of course
23:05:08 <fsfwfrr> quit
23:05:24 <sssilver> huh
23:05:40 <Axman6> heh, I know that was a typo but it was a pretty well timed one
23:05:44 <EvanR> haha
23:05:44 <mniip> oh wow
23:05:49 <extor> So haskell can be used even with web servers
23:05:56 <mauke> ... "even"?
23:06:00 <Axman6> haskell is pretty excellent for web services
23:06:01 <mniip> apparently showPpr can swallow (defaultDynFlags undefined)
23:06:07 <extor> Well I mean usually languages are specialized
23:06:14 <mauke> no, usually they're not
23:06:20 <extor> web services are associated with asp, php, java
23:06:23 <sssilver> like we’re starting this software layer that’s gonna be a lot of pure business logic processing a bunch of prices using some formulae, and that seems like a good contender to be written with Haskell
23:06:30 <Axman6> yeah... the oinly one I can think of that I'd call specialised is PHP
23:06:34 <Axman6> and js I guess
23:06:35 <mauke> extor: and ruby, python, perl, ...
23:06:38 <mauke> javascript
23:06:38 <extor> Not usually with C++ or Assembly Language
23:06:43 <johnw> mauke: I've know several people who don't know Haskell who believe it to be mostly impractical for real world tasks, including people who should know better.  There is left-over FUD from pre-2006
23:07:02 <extor> Yeah but Haskell is a sort of an academic language, like pascal I thought.
23:07:10 <johnw> it originated there, yes
23:07:13 <mauke> how is pascal academic?
23:07:16 <johnw> it is used for almost anything you can think of
23:07:24 <StoneCypher> mauke: its original domain was teaching
23:07:26 <sssilver> extor: a language is a language. “academic language” = ?
23:07:28 <Axman6> ... pascal isn't an academic language
23:07:31 <extor> Pascal used to be the teaching language in the 1980s
23:07:33 <StoneCypher> yes, it is
23:07:41 <mauke> StoneCypher: ah, right
23:07:46 <Axman6> pascal used to be the language on Mac OS
23:07:50 <extor> Then Borland morphed Pascal
23:07:53 <EvanR> haskell is a general purpose programming language
23:07:55 <johnw> I was taught Pascal in school
23:08:04 * extor was taught pascal in school too
23:08:13 <sssilver> But yeah anyway, I need to get through this initial phase. Somehow. I spent the last 5 hours on writing 2 tiny functions, and failed miserably. I’m not even sure I took anything valuable from those 5 hours. That’s a big problem. And a pretty big waste.
23:08:28 <mauke> johnw: ok, but web servers aren't particularly special or demanding. heck, I've written "web services" as shell scripts
23:08:37 <johnw> sssilver: you took away more than you think
23:08:49 <Axman6> sssilver: it gets easier
23:09:01 <johnw> mauke: yeah, but since people make money doing that, it's assumed to be something only "real" languages do
23:09:02 <EvanR> sssilver: a real video game might be a steep way to learn the language from scratch, or maybe its the fast track for someone with a lot of talent/luck
23:09:10 <sssilver> mauke: you just call everything that listens on port 80 a web service :P
23:09:25 <quchen2> sssilver: You're in the "fighting the type system" phase, I assume. After that is the "the type system isn't annoying anymore" phase. And level 3 is the "I can't live witout it phase". That one is where you'll be in a couple of weeks.
23:09:31 <mauke> sssilver: that part was apache. I just did CGI :-)
23:09:33 <extor> sssilver I feel the same way learning C# sometimes. It's so frustrating writing something, typing a dot, and another set of icons pop up and you choose one that looks right and suddenly it gives you a cryptic error saying something about an overload or other OOP jingo
23:10:39 <bitemyapp> what's signum for?
23:10:44 <sssilver> EvanR: what do you recommend instead?
23:10:46 <bitemyapp> is it just to avoid Ord or what?
23:10:52 <bitemyapp> specialize for efficiency?
23:11:01 <Rotaerk> isn't math one of those academic subjects?
23:11:06 <Rotaerk> only useful in school
23:11:12 <Axman6> yes
23:11:16 <bitemyapp> oh I see how it is.
23:11:18 <Axman6> I have never used maths for anything!
23:11:27 <EvanR> sssilver: i dont have a better idea, theres a lot of idioms to get used to, and they arent all listed in one place
23:11:40 <EvanR> it takes studying
23:11:44 <Axman6> bitemyapp: can be useful for writing branch free code I guess?
23:11:48 <extor> Math is a good mind sharpener for other stuff
23:11:53 <bitemyapp> Axman6: I thought it might be something like that, thank you.
23:12:14 <EvanR> sssilver: but there is this list of learning material if you have the time and inclination to study it
23:12:17 <Axman6> bitemyapp: but that does depend on an efficient implementation of signum =)
23:12:19 <EvanR> @where learnhaskell
23:12:19 <lambdabot> https://github.com/bitemyapp/learnhaskell
23:12:34 <bitemyapp> Axman6: yer. v. good. Thank yeh m'lud.
23:12:38 <Cale> bitemyapp: The idea is that it should satisfy x = abs x * signum x
23:12:43 <sssilver> EvanR: I have both I believe
23:12:51 <bitemyapp> Cale: mmmm laws.
23:13:35 <Cale> > signum (1 :+ 1)
23:13:37 <lambdabot>  0.7071067811865475 :+ 0.7071067811865475
23:13:48 <Cale> > abs (1 :+ 1)
23:13:49 <lambdabot>  1.4142135623730951 :+ 0.0
23:14:04 <extor> I want to write myself an API in haskel or another language or even another framework. I was thinking of the django rest API framework but now I'm wondering if this could be a fun excercise in haskell? Although I am a total haskell noob and just know pascal and a little bash and C#. I'd be lost at first but is it a recommended first project?
23:14:30 <bitemyapp> extor: you're going to find it very difficult if you dive directly into a web stack.
23:14:32 <mauke> extor: not recommended by me, at least
23:14:51 <bitemyapp> extor: you probably want to commit to completing at least one course w/ Haskell, then look into writing an API.
23:15:08 <Axman6> extor: what sort of API?
23:15:13 <extor> bitemyapp, mauke oh ok. I was thinking it might be really simple since an API is just "see this incoming--->send that outgoing" and vice versa
23:15:27 <Axman6> API isn't something with a well defined meaning (except for a very broad one)
23:15:30 <mauke> extor: ... yes, but you don't know the language
23:15:39 <dramforever> Cale: Whoa signum for complex numbers
23:16:05 <mauke> also, I think most web developers shouldn't be doing web stuff, so there's that
23:16:25 <bramgg> Does Haskell always print three stars before an exception? (eg *** Exception: empty list). Or does that mean something?
23:16:46 <extor> Axman6 I want to actually sniff the web API communication between an application and a website. And then emulate both the client and the server. The application itself is an automated website login and posting bot. The website it API's to is a captcha solving gateway. So the app sends pictures via API to the website, which in turn solves it with the help of humans with no life.
23:16:48 <EvanR> its the debris flying away from your program
23:16:56 <dramforever> bramgg: IIRC if you compile main = undefined you don't get ***
23:16:57 <bramgg> :P
23:17:05 <dramforever> instead you get your program name
23:17:38 <dramforever> I guess it's because *** is a bit scary, so it alerts you
23:17:39 <Axman6> extor: sounds like a proxy to me... I think you're overusing the term API ;)
23:18:04 <dramforever> extor: what do you mean by outgoing?
23:18:22 <extor> dramforever outgoing from the webserver running the web based API
23:18:28 <dramforever> Client -> Server is ingoing
23:18:32 <dramforever> right?
23:18:41 <dramforever> Server -> Client is outgoing?
23:18:50 <dramforever> or Server -> SomeThirdParty
23:18:53 <shachaf> bramgg: No, that's just ghci.
23:19:09 <dramforever> > undefined
23:19:09 <bramgg> thanks
23:19:10 <lambdabot>  *Exception: Prelude.undefined
23:19:16 <shachaf> (ghci's exception handler adds "*** Exception".)
23:19:19 <dramforever> that's just one *
23:19:50 <dramforever> extor: ^ outgoing = Server -> Client or S -> some third party
23:19:51 <extor> Axman6 no it is not a proxy. The application automates logging into a website such as say...blogspot.com and sometimes there's an anti spam picture that needs to be solved. What the application then does is grab that picture, send that picture via API to a website that specializes solving captcha puzzles for like a penny each, solves the captcha, send back the solution via API and then the
23:19:51 <extor> app continues to log in at blogspot.com or any other site
23:19:51 <bramgg> So GHC adds 1, and GHCi adds 3?
23:20:05 <dramforever> extor: okay, some third party
23:20:13 <extor> dramforever server--> client is outgoing from the POV of the server, yes
23:20:19 <dramforever> okaay
23:20:21 <EvanR> extor: cough deathbycaptcha ? :)
23:20:59 <dramforever> extor: to me that's not writing an api yourself, that's using one
23:21:06 <extor> EvanR that's one of them, there's a few others too but yes. They all have an API that streamlines the reciept, outsourcing and solution delivery of a graphic
23:21:08 <mauke> extor: how comfortable are you with unnamed functions?
23:21:27 <Axman6> so, what you're descrtibing is basically the reason so many dodgy porn websites ask for captchas, because the mafia runs them and use if as their own version of amazon's mechanical turk :P
23:21:46 <dramforever> extor: or...you mean Website <---> Computer Network <--[here's your API]--> program
23:22:13 <extor> dramforever I will be using one, and then sniffing it with wireshark. Once I have sniffed the functions of the API I will write my own server that emulates the exact same API. In other words I will clone deathbycaptcha's server side API
23:22:30 <extor> mauke I don't know what an unnamed function even means, so I guess very uncomfortable
23:22:57 <dramforever> extor: you heard of lambda before?
23:23:10 <extor> dramforever my goal is to create an app that becomes a "man in the middle" in this API communication network
23:23:56 <extor> dramforever I heard it's a new feature of C# but no idea what it is. I also heard it's a branch of calculus but once again never looked into it or it's utility. Why?
23:24:59 <dramforever> extor: because that's what an "unamed function is"
23:25:00 <mauke> ok, so my guess is: if you jump right into the middle of a haskell application - any application - you're going to be so fucking lost
23:25:08 <dramforever> *unnamed
23:25:18 <dramforever> mauke: agree
23:25:26 <acetoline> I really dislike the term 'anonymous function' or 'unnamed function'
23:25:30 <extor> mauke oh I was hoping the simplicity of my project would help
23:25:40 <dramforever> extor: that's not simple
23:25:41 <acetoline> as if a function if something that always comes with a name
23:25:44 <mauke> ... also it doesn't help that you think your project is "simple"
23:25:55 <acetoline> and isn't an abstract concept like 'vector' or 'group'
23:25:56 <extor> mauke I jumped right into the middle of C# and was only somewhat lost, mostly because I knew a bit of VB6 from before
23:25:59 <mauke> acetoline: if you're coming from that mindset, it does :-)
23:26:13 <acetoline> which mindset
23:26:32 <mauke> acetoline: conventional imperative programming, basically
23:26:39 <mauke> or Java specifically
23:26:42 <dramforever> if you learnt programming before, you will get a headache when starting to learn haskell
23:26:42 <Axman6> in many languages, functions can only be named functions
23:26:54 <dramforever> but it won't last very long
23:27:04 <dramforever> (at least it didn't bother me much for long)
23:27:12 <extor> Is Haskell similar enough to pascal to lessen the usual headache
23:27:18 <mauke> bothered me enough that I gave up once
23:27:28 <mauke> extor: it has almost nothing in common with pascal
23:27:30 <dramforever> extor: it's different enough to not relate them
23:27:57 <dramforever> extor: seriously...why don't you follow a tutorial?
23:27:58 <mauke> extor: pascal and c# are basically the same language with different syntax
23:28:04 <mauke> at least from a haskell perspective
23:28:25 <dramforever> Real World Haskell is great http://book.realworldhaskell.org/
23:28:28 <extor> So slightly off topic, what language or framework would you guys recommend I play with to solve my API problem, of building a man in the middle API gateway? The python django rest api framework?
23:28:46 <dramforever> Learn You a Haskell for Great Good http://learnyouahaskell.com/ is also great
23:28:48 <extor> dramforever a tutorial in haskell? Sorry I missed the gist of what you're saying
23:29:03 <dramforever> extor: how much haskell have you learnt
23:29:05 <dramforever> none?
23:29:09 <extor> none
23:29:29 <extor> I was just drawn by the lavish praise the language gets and joined the channel to see what people talked about
23:29:50 <shachaf> extor: This isn't a good channel for questions about web frameworks in other languages. If you have a question about Haskell it would be a good channel for it.
23:30:03 <dramforever> extor: you know what's a tutorial, right
23:30:41 <extor> shachaf yeah hence my admission that it's slightly off topic. Originally I wanted to know if haskell would be a fantastic language for this project of mine. Based on any of it's strong points.
23:30:59 <extor> dramforever yeah it can be video, ebook or on the web.
23:31:46 --- mode: ChanServ set +o shachaf
23:32:35 --- mode: shachaf set +b-o san4!*@*$##fixyourconnection shachaf
23:33:41 <shachaf> extor: Your admission is a good start, but it doesn't help if you don't act on it. :-)
23:33:45 <dramforever> extor: read one of RWH and LYAH
23:34:15 <EvanR> people are too distracted by FTP to de-recommend LYAH these days
23:34:33 <extor> What are RWH and LYAH?
23:34:43 <EvanR> @where lyah
23:34:43 <lambdabot> http://www.learnyouahaskell.com/
23:34:55 <EvanR> @where rwh
23:34:55 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
23:35:06 <shachaf> extor: Haskell is a general-purpose language. It's different enough from other languages you know to merit spending some time learning it before using it for a project, if you do.
23:35:50 <dramforever> extor: I think maybe you thought that "Pascal" and "Haskell" sound similar, so they were similar
23:36:21 <EvanR> * they dont sound similar
23:36:44 <dramforever> EvanR: so that was a bad guess
23:37:17 <dramforever> extor: LYAH gives short examples
23:37:30 <dramforever> RWH gives longer ones
23:37:49 <dramforever> and RWH guides you to make some not-so-small projects
23:40:45 <Cale> We're not recommending Brent's course?
23:40:57 <dramforever> @where brent
23:40:58 <lambdabot> I know nothing about brent.
23:41:03 <Cale> http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html
23:41:38 <EvanR> @where cis194
23:41:38 <lambdabot> I know nothing about cis194.
23:44:09 <dramforever> Cale: I totally agree with the last section of 01-intro: A word about error messages
23:44:58 <dramforever> Some of my classmates, when learning to program in C++, don't even attempt to read error messages produced by compilers. Instead they just start that the code until enlightenment strikes
23:45:30 <EvanR> its like that in clojure too
23:45:34 <dramforever> When I ask why, they say it's too obscure
23:46:05 <dramforever> They write int mian() {} and don't understand what's "undefined reference to WinMain@16"
23:46:43 <dramforever> They write if(a*a = b) and complain that nobody told them what's a "lvalue"
23:48:03 <HeladoDeBrownie> well, it is pretty obscure. programming in general is harder than it has to be.
23:48:17 <dramforever> but you have to try hard
23:48:23 <quchen2_> dramforever: What's wrong with a pointer to "a" that's called "a"? :-P
23:48:45 <dramforever> Also if you don't read GHC error messages, you lose *a lot*
23:50:32 <dramforever> I like to think compiler error messages as a dianose of what problems your program has
23:51:14 <dramforever> I mean, like from a doctor
23:52:50 <lush> yo
23:55:07 <wz1000> I'm thinking of replacing () in all my code with (forall a. a) for laughs and giggles. Is this too evil?
23:55:37 <EvanR> might make things more convenient
23:55:51 <EvanR> dont have to produce a pointless ()
23:56:39 <wz1000> Hand out _|_ when you need ()
23:57:16 <dramforever> wz
23:57:20 <dramforever> wz1000:
23:57:23 <dramforever> :t rnf 2
23:57:24 <lambdabot> Not in scope: ‘rnf’
23:57:33 <dramforever> ouch....
23:57:40 <wz1000> Honestly, will this have any change in semantics from ()?
23:57:51 <EvanR> if () is in the type and you get a bottom, you might crash. if a is in the type and you get whatever, you wont crash
23:58:02 <EvanR> i think
23:58:17 <EvanR> you cant inspect the forall a . a
23:58:19 <mauke> seq is unrestrained
23:58:31 <mauke> :t \x -> seq x ()
23:58:32 <lambdabot> t -> ()
23:58:45 <EvanR> frag
23:59:42 <wz1000> EvanR: If f :: (forall a. a) -> ...; f _ = ...; do its sematics change from f :: () -> ...; f _ = ...? You just use _|_ when you need to call it.
23:59:59 <shachaf> There are two values of one type and only one value of the other type.
