00:00:28 <merijn> davidar: See here how I deal with unwrapping existentials usually: https://github.com/merijn/SNet2.0/blob/master/SNet/Stream.hs#L25-L30
00:00:30 <shachaf> That's not what it means.
00:04:13 <davidar> ah ok, I see the problem, I think I need to rethink how I'm implementing this
00:04:39 <davidar> liste: merijn: so, where would CPS come in?
00:05:50 <liste> merijn's example is cool (: the (forall r. Record r -> m a) part is the continuation specifically
00:05:53 <merijn> davidar: That function I linked is CPS, you're passing in a continuation
00:06:02 <NGC_6205> next question: does the language handle operators like addition differently, do I not know something about all functions yet, why 1+1 doesn't have to be "+ 1 1"
00:06:27 <merijn> davidar: And since the continuation is consuming the existential var and never returning it (only a resulting value) there's no existentials escaping
00:06:29 <liste> NGC_6205 1+1 is equivalent to (+) 1 1
00:06:32 <Kristler> NGC_6205: Any function that has its identifier made of symbols
00:06:39 <jle`> NGC_6205: the function is (+), so you can call it as (+) 1 1
00:06:40 <Kristler> is implicitly infix
00:06:47 <Kristler> Wait
00:06:49 <jle`> NGC_6205: but haskell offers a special syntax, where you can write (+) 1 1 as 1 + 1
00:06:52 <davidar> merijn: but how does that relate to GADTs?
00:06:52 <Kristler> Wrong word, binary*
00:07:02 <NGC_6205> ah, that makes sense
00:07:04 <merijn> NGC_6205: The language report basically says that operators (consult the report for details on which characters are operator characters) are infix
00:07:16 <Kristler> Oh, infix was the right word
00:07:29 <Kristler> You can make any function behave similarly by surrounding it with backticks
00:07:31 <Copperis> @type Either
00:07:32 <lambdabot>     Not in scope: data constructor ‚ÄòEither‚Äô
00:07:32 <lambdabot>     Perhaps you meant variable ‚Äòeither‚Äô (imported from Data.Either)
00:07:40 * hackagebot arithmetic 1.2 - Natural number arithmetic  https://hackage.haskell.org/package/arithmetic-1.2 (JoeHurd)
00:07:40 * hackagebot opentheory-primitive 1.8 - Haskell primitives used by OpenTheory packages  https://hackage.haskell.org/package/opentheory-primitive-1.8 (JoeHurd)
00:07:41 <merijn> davidar: It doesn't relate to GADTs specifically, it relates to existentials and stopping them from escaping the scope of unwrapping :)
00:07:59 <Kristler> Supposing we have some function sum such that sum 3 2 = 3 + 2, we can also write 3 `sum` 2 
00:08:22 <Copperis> shouldn't Either be usable without any imports?
00:08:28 <merijn> davidar: In the example I showed you WrapControl/WrapData are existential GADTs, so unwrapping them brings their existential type "in view", but due to the way existentials works I can't return that directly
00:08:32 <jle`> Copperis: it's not a data constructor
00:08:34 <jle`> it's a type constructor
00:08:37 <jle`> so it doesn't have a type
00:09:02 <merijn> davidar: So the solution is to pass in a continuation that can handle both cases and immediately consume the unwrapped value in the body of the case-of
00:09:02 <davidar> merijn: ok. I think I might take another look at how repa does stuff, it might shed some light on it :)
00:09:05 <NGC_6205> learned a lot by asking that question, thanks
00:09:26 <Copperis> but I can write "myFn :: Int -> Either String Int" ?
00:09:52 <jle`> Copperis: yes, but what is the type of Int?
00:10:01 <jle`> Int isn't a value/data constructor, so you can't do :t Int
00:10:08 <jle`> :t Int
00:10:09 <lambdabot>     Not in scope: data constructor ‚ÄòInt‚Äô
00:10:09 <lambdabot>     Perhaps you meant one of these:
00:10:09 <lambdabot>       ‚ÄòIn‚Äô (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
00:10:10 <merijn> NGC_6205: Basically, in haskell you're allowed to name any function using "operator characters" to define your own operators, including unicode operators
00:10:19 <jle`> Copperis: :t lets you find the types of values
00:10:28 <jle`> 1 is a value, True is a value, Right "hello" is a value
00:10:30 <jle`> :t Right "hello"
00:10:32 <lambdabot> Either a [Char]
00:10:35 <jle`> but Either is not a value...it's a type
00:10:41 <merijn> > let x ‚òÉ y = x*x + y*y in 3 ‚òÉ 5 -- Whoo! Snowman operator!
00:10:42 <lambdabot>  34
00:10:57 <Kristler> merijn: That is too funny
00:11:02 <merijn> This is basically identical to
00:11:14 <merijn> > let foo x y = x*x + y*y in foo 3 5
00:11:17 <lambdabot>  34
00:11:47 <merijn> > let x ‚òÉ y = x*x + y*y in (‚òÉ) 3 5 -- or prefix operator notation
00:11:48 <Kristler> let x üëÄ y = 3* x^y + 2 * x in 3 üëÄ 5
00:11:49 <lambdabot>  34
00:11:51 <Copperis> jle`, ok. For what do I need the type of Int? I thought Int was a type
00:11:55 <Kristler> >let x üëÄ y = 3* x^y + 2 * x in 3 üëÄ 5
00:12:03 <merijn> Kristler: Needs a space after >
00:12:06 <Kristler> Right
00:12:09 <Kristler> > let x üëÄ y = 3* x^y + 2 * x in 3 üëÄ 5
00:12:11 <lambdabot>  735
00:12:21 <Kristler> That is too amusing
00:12:21 <jle`> Copperis: you don't...but you're trying to do :t Either
00:12:28 <jle`> Either is a type...why do you watn the type of it?
00:12:34 <merijn> Kristler: Note, this only works for unicode characters that have a "symbol" classification
00:12:41 <merijn> > generalCategory '‚òÉ'
00:12:41 <dolio> Snowman is an operator?
00:12:43 <lambdabot>  OtherSymbol
00:12:52 <merijn> dolio: Yeah, it's OtherSymbol :)
00:12:53 <dolio> Wow.
00:12:59 <davidar> actually, why does Applicative constrain things to be the same shape? it seems overly restrictive
00:13:01 <Kristler> > generalCategory 'üëÄ'
00:13:03 <lambdabot>  OtherSymbol
00:13:18 <Copperis> jle`, I thought I wanted to know how to pass parameters to Either. But Either String Int works it seems
00:13:19 <merijn> > generalCategory 'Œ†' -- not a symbol/operator
00:13:20 <lambdabot>  UppercaseLetter
00:13:39 <jle`> Copperis: ah, you want the kind?
00:13:41 <jle`> :k Either
00:13:43 <lambdabot> * -> * -> *
00:13:47 <merijn> Kristler: Consult the report on lexical syntax of haskell for details about which character classes are symbols/variable names :)
00:13:58 <Copperis> jle`, yes, this one, thank you
00:13:58 <jle`> this means that Either takes two *'s (types that can have values) and returns a *
00:14:09 <Kristler> merijn: That sounds like fun, I need to do that someday
00:14:19 <jle`> Copperis: Int has a kind, too, it's *
00:14:22 <jle`> but Int doesn't have a type
00:14:47 <merijn> Relatedly
00:14:53 <merijn> Admire this brilliant function: https://hackage.haskell.org/package/acme-lookofdisapproval-0.1/docs/Acme-LookOfDisapproval.html
00:15:07 <merijn> Althought that's (technically) a GHC-ism that hasn't been standardised yet :p
00:15:22 <exio4> wouldn't Int have a type in ghc 8.0? :P
00:15:24 <kadoban> merijn: Hah
00:15:51 <jle`> 8.0 will be interesting times
00:15:57 <Copperis> jle`, Int's kind means, that it doesn't take anything and just is?
00:16:31 <merijn> (For the curious, according to unicode ‡≤† is a caseless letter and thus wouldn't be a valid variable name in Haskell as written in the current report, which only allow upper- or lowercase letters)
00:17:07 <Kristler> You're saying I can't name a function ‡≤†_‡≤†? :(
00:17:20 <merijn> Kristler: You can in GHC, because no one thought of that before :p
00:17:31 <merijn> Kristler: There's plans to amend the report to match GHC, iirc
00:17:59 <merijn> But technically it's a bug in GHC that you can ;)
00:18:11 <jle`> Copperis: yeah, it's not a function kind
00:18:12 <Kristler> Neat. I hope I never see the day where I have to read code that amounts to poetic ascii faces
00:18:22 <jle`> Copperis: Int :: *, so you can have values of type Int
00:18:27 <jle`> namely, 1, 2, etc.
00:19:02 <Copperis> jle`, ok, got it, thanks
00:19:23 <jle`> Copperis: but you can't have any values of type Either :: * -> * -> *.  nor of Either String :: * -> *.  but you can have values of type Either String Bool :: *
00:21:29 <Copperis> jle`, ok. Though you can work with partially applied typed when defining typeclass instances. At least that's what I understood from learnyouahaskell.com
00:21:39 <Copperis> *partially applied types
00:21:50 <quicksilver> Copperis: you can define instances for them yes. You still can't have values of them.
00:22:09 <jle`> Copperis: yeah, typeclass instances can be of any kind that matches what the typeclass is looking for
00:22:37 <jle`> for example, the Functor typeclass is looking for things of kind * -> *, so `Maybe`, `IO`, `Either a` would definitely work, because they're * -> *
00:22:45 <jle`> just like the typeclass wanted
00:23:15 <jle`> the Monoid typeclass looks for types of kind *, so you can't use Maybe as a Monoid instance
00:23:19 <jle`> so sad
00:23:42 <merijn> jle`: That's why you have Alternative and MonadPlus :p
00:23:53 <jle`> :D
00:25:27 <jle`> next, polykind monoids
00:33:51 <quicksilver> polykind monoids sounds like another way to get a load of overlapping instances :)
00:34:21 <quicksilver> or maybe not
00:34:31 <quicksilver> would it give you a <> you could apply directly at higher kinds?
00:34:34 <quicksilver> that might be cute.
00:35:58 <jle`> i cannot even comprehend
00:36:39 <dolio> It doesn't make much sense unless you change the content of the class, or generalize what (->) means.
00:37:34 <dolio> And what it means to have values, for that matter.
00:38:42 <jle`> haskell really asks you the deep ethical questions, doesn't it
00:40:13 <quicksilver> well (Maybe <> Either String) would be a type at kind * -> *
00:40:43 <quicksilver> that is, <> gets lifted from being a value operator to being a type operator
00:41:05 <quicksilver> but I think this is nonsense. Or at least I have no application in mind for it.
00:41:16 <jle`> it was a joke about "values" meaning ethical/moral standards ;_;
00:41:25 <quicksilver> :)
00:41:27 <thimoteus> i got it, i chuckled
00:41:48 <dolio> Oh, I thought it meant making the Monoid class polykinded.
00:41:51 <dolio> Which also doesn't make sense.
00:42:08 <jle`> thank you thimoteus 
00:50:05 <quicksilver> actually if it meant pointwise product type it would be perfectly sensibel I guess
00:50:32 <quicksilver> type MES a = (Maybe a, Either String a)
00:50:51 <quicksilver> has a bunch of sensible behaviours and instances, probably
00:51:22 <exio4> that's just (,) + some extra wrapper
00:51:28 <quicksilver> yes I know
00:51:45 <quicksilver> I was just pointing out that (,) is a type-level monoid, and you can apply it at higher kinds, pointwise
00:52:04 <quicksilver> well it's a type-level monoid "up to isomorphism"
00:53:59 <dolio> The problem is there are many. It's like Integer, for which we have no Monoid instance.
00:54:13 <dolio> How do you pick between (,) and Either and ...
00:54:42 <quicksilver> yes
00:55:22 <exio4> class Monoid (m :: k) where mempty :: (Monoid k ~ a) => a ; 
00:55:34 <exio4> er, MonoidFn which would be a type family :P
00:56:03 <exio4> associated type is the correct name I think? I don't remember the syntax for adding that within the typeclass 
00:56:19 <quicksilver> why isn't there a Show instance for Identity?
00:56:24 <quicksilver> > Identity True
00:56:26 <lambdabot>  Identity True
00:56:35 <quicksilver> hmm there is here. Why isn't there one in my ghci? :)
00:57:01 <quicksilver> there is. Operator error.
00:57:04 * quicksilver apologises
00:57:35 <jle`> why isn't there a Monad instance for Sum
00:57:36 * hackagebot manifolds 0.1.5.0 - Working with manifolds in a direct, embedding-free way.  https://hackage.haskell.org/package/manifolds-0.1.5.0 (leftaroundabout)
00:57:37 <liste> quicksilver not in mine either
00:57:57 <Jinxit> if I want to write a compiler (DSL -> some other language), what haskell libraries should I look at? attoparsec?
00:58:09 <jle`> Jinxit: as an example, or to help you write one?
00:58:27 <quicksilver> jle`: you just mean the same instance as Identity?
00:58:39 <jle`> yes, the only instance
00:58:41 <Jinxit> jle`: to write one of my own
00:58:41 <merijn> Jinxit: parsec/trifecta, most likely
00:59:02 <merijn> Jinxit: attoparsec has less nice error handling
00:59:03 <quicksilver> jle`: would it be useful?
00:59:05 <jle`> attoparsec is more meant for parsing things produced by computers, from what i hear
00:59:08 <jle`> quicksilver: no
00:59:21 <Jinxit> ahh
00:59:23 <jle`> well, potentially
00:59:31 <dolio> Functor would be more likely to be useful.
00:59:48 <jle`> i mean, most of the things you would want to use fmap on are already covered by the Num instance
00:59:49 <tdammers> the tradeoff is that attoparsec tends to produce faster parsers, while parsec produces better error messages
00:59:50 <merijn> Jinxit: Although trifecta's documentation can be a bit confusing initially :p
01:00:00 <jle`> > 10 + Sum 4
01:00:01 <lambdabot>  Sum {getSum = 14}
01:00:18 <Jinxit> then I would lean towards parsec probably
01:00:23 <Jinxit> compiler speed isn't critical
01:00:40 <jle`> trifecta is supposed to have great error messages or something like that
01:00:49 <merijn> jle`: It does!
01:01:00 <jle`> and it also has
01:01:03 <jle`> 05p04r07e08t03t09y 10c11o02l12o06r13s
01:01:23 <tdammers> colors in a terminal? blasphemy!
01:01:24 <merijn> Jinxit: I have a (very ghetto) simple lambda calc interpreter here: https://github.com/merijn/lambda-except
01:01:42 * frerich has secret hopes that merijn can wrap the trifecta API into some sort of trifecta-for-the-rest-of-us package
01:01:58 <jle`> isn't the trifecta api just the parsers api?
01:02:04 <frerich> I found it pretty rough to get started :-(
01:02:04 <merijn> jle`: Pretty much
01:02:12 <merijn> frerich: Plus a bit of newtype deriving
01:02:23 <jle`> the wonders of typeclasses without laws
01:02:25 <Copperis> @let roundDiv = round . (/)
01:02:26 <lambdabot>  Defined.
01:02:31 <Copperis> orly
01:02:37 * hackagebot manifold-random 0.1.1.0 - Sampling random points on general manifolds.  https://hackage.haskell.org/package/manifold-random-0.1.1.0 (leftaroundabout)
01:02:41 <jle`> Copperis: the type isn't what you're expecting, probably
01:02:49 <Copperis> @type roundDiv
01:02:50 <lambdabot> (Fractional a, Integral c, RealFrac (a -> a)) => a -> c
01:03:16 <merijn> Isn't that a beauty... :p
01:03:26 <Copperis> I don't understand it
01:03:28 <Copperis> :D
01:03:34 <jle`> @src (.)
01:03:34 <lambdabot> (f . g) x = f (g x)
01:03:35 <elliptic00> what is difference between  let add a b = a + b and  add::Integer->Integer->Integer?
01:03:56 <jle`> Copperis: round . (/) x = round ((/) x)
01:04:18 <jle`> Copperis: so round . (/) = \x -> round ((/) x), but you probably want \x y -> round (x / y)
01:04:30 <liste> elliptic00 one is a function definition, the other is a type annotation
01:04:36 <jle`> you're basically trying to round a function  --- (/) x ---, not a number
01:04:48 <jle`> elliptic00: one is a type signature?
01:05:06 <liste> elliptic00 except the let one doesn't make sense by itself, it must be inside a do block or let..in..
01:05:07 <thimoteus> i guess two is a type signature
01:05:09 <jle`> the other is either an incomplete let definition of a function, or a line in a do block
01:05:21 <jle`> that defines a function
01:05:34 <Copperis> jle`, how does it even let me round a function?
01:05:44 <jle`> Copperis: you can round anything that is an instance of RealFrac
01:05:51 <jle`> that's what the RealFrac (a -> a) constraint means
01:05:58 <jle`> if (a -> a) is an instance of RealFrac, then you're good to go
01:06:15 <jle`> but...you aren't going to find any instances unless you hack your own
01:06:54 <jle`> the reason why it lets you compile it is that GHC can't prove for sure that there is no a such that a -> a is an instance of RealFrac
01:07:10 <jle`> what if some punk decided to do instance RealFrac (Int -> Bool) where round = error "i'm a punk" ?
01:07:37 * hackagebot dynamic-plot 0.1.1.0 - Interactive diagram windows  https://hackage.haskell.org/package/dynamic-plot-0.1.1.0 (leftaroundabout)
01:08:00 <Copperis> jle`, "(Fractional a, Integral c, RealFrac (a -> a)) => a -> c" this seems like it takes a number and returns another one. Where does this (a -> a) come into play?
01:08:02 <jle`> er, should be two of the same type
01:08:10 <jle`> Copperis: it's in the constraints
01:08:17 <jle`> it's saying, your type is a -> c, as long as:
01:08:21 <jle`> 1. a is an instance of Fractional
01:08:25 <jle`> 2. c is an instance of INtegral
01:08:31 <jle`> 3. a -> a is an instance of RealFrac
01:09:04 <jle`> so you can only call your function if you use an `a` where (a -> a) is an instance of RealFrac
01:09:11 <merijn> Copperis: Note that for a long time lambdabot had "instance Num a => Num (a -> a)"
01:09:27 <jle`> but in normal haskell, there is no type `a` where a -> a is an instance of RealFrac, so oyu can never really call it
01:09:34 <jle`> a lot of people do define their own instance, though >_>
01:09:37 <nesqi> Is there an operator that I could use for composing a function on the second argument so that I could rewrite this code, "flip (compare . fst) . fst", to something like "compere . fst `xxx` fst"
01:09:41 <nesqi> in the standard prelude
01:10:26 <jle`> i don't think so.  and it probably wouldn't be too readable if there were one, heh
01:10:51 <Ferdirand> :t comparing
01:10:53 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
01:11:33 <merijn> @define instance Num a => Num (a -> a) where f + g = \x -> f x + g x; f * g = \x -> f x * g x; abs f = \x -> abs (f x); signum f = \x -> signum (f x); fromInteger i = \_ -> i; negate f = \x -> negate (f x)
01:11:35 <lambdabot>  .L.hs:170:32:
01:11:35 <lambdabot>      Couldn't match expected type ‚Äòa‚Äô with actual type ‚ÄòInteger‚Äô
01:11:35 <lambdabot>        ‚Äòa‚Äô is a rigid type variable bound by
01:11:42 <nesqi> Ferdirand: Nice!
01:11:43 <merijn> aww?
01:11:56 <Copperis> jle`, how can a function be an instance of a typeclass? I though only types can be instances. And those instances have functions defined
01:11:58 <jle`> merijn: you need fromInteger i = \_ -> fromInteger i
01:11:59 <merijn> Where did I mess up?
01:12:03 <merijn> jle`: oh, duh!
01:12:08 <merijn> @undefine
01:12:08 <lambdabot> Undefined.
01:12:16 <merijn> @define instance Num a => Num (a -> a) where f + g = \x -> f x + g x; f * g = \x -> f x * g x; abs f = \x -> abs (f x); signum f = \x -> signum (f x); fromInteger i = \_ -> fromInteger i; negate f = \x -> negate (f x)
01:12:18 <lambdabot>  Defined.
01:12:21 <jle`> Copperis: a function type is a type
01:12:24 <jle`> Int -> Bool is a type
01:12:31 <merijn> > sin^2 $ 4
01:12:33 <jle`> String -> Double is a type
01:12:34 <lambdabot>  0.5727500169043067
01:12:54 <merijn> :t sin^2
01:12:55 <lambdabot> Floating a => a -> a
01:13:15 <jle`> Copperis: see, merijn just wrote an instance for (a -> a) ... which is a valid type, just like Int, Bool, String, etc.   (technically, he wrote an instance a -> a for all types a)
01:13:29 <jle`> Copperis: Int -> Bool is a type, and there are values of type Int -> Bool
01:13:43 <jle`> (er, all types a where a is a Num instance)
01:14:44 <jle`> > (sin^2 + cos^2) 0.8
01:14:46 <lambdabot>  1.0
01:15:12 <jle`> probably not the most helpful thing to type when trying to explain something to someone new ><
01:16:32 <Ferdirand> even worse than that
01:16:42 <Ferdirand> ((->) r) is an instance of Monad
01:17:29 <Copperis> ok, I think I got it. Seems interesting, really generic stuff
01:17:33 <merijn> How is that worse?
01:17:40 <merijn> ((->) r) instance is <3
01:17:43 <Ferdirand> it's not a type of kind '*' !
01:17:49 <merijn> So?
01:17:59 <merijn> Neither is any Functor
01:18:08 <merijn> Or any monad
01:18:12 <Ferdirand> right, the point is
01:18:39 <Ferdirand> if he was surprised that types include ones constructed from (->)
01:19:20 <Ferdirand> maybe it's because he has an embryonic intuition of kinds
01:19:51 <Copperis> so is it possible to compose round and (/) so it would return something like (\ x y -> round (x / y)) ?
01:20:14 <Ferdirand> :t (round.) . (/)
01:20:16 <lambdabot> (Integral c, RealFrac a) => a -> a -> c
01:20:33 <tekkkz> Hello! I tryed `cabal install pack` but with following error: http://ix.io/ltP How to solve this and install `pack` ?
01:20:33 <merijn> Or just use a lambda...
01:20:39 <jle`> Copperis: it is, but the more readable solution is to just use explicit arguments
01:20:46 <Ferdirand> one wise haskeller here once said, it becomes easier once you learn to think of (.) as a section operator
01:20:48 <jle`> "points", as they call it in the biz
01:20:51 <quicksilver> Copperis: personally I think (\x y -> round (x/y)) is more readable than ((round.) . (/))
01:21:04 <jle`> i will get mad at anyone i see writing (round.)
01:21:07 <Copperis> yup, the lambda is more readable, I forgot about that solution
01:21:09 <quicksilver> lambda notation is quite a terse and efficient way of describing a function of more than one argument.
01:22:08 <jle`> \x -> round . (x/) if you want to go halfway
01:22:26 <Kristler> :t (+) . double
01:22:27 <lambdabot>     No instance for (Num Doc) arising from a use of ‚Äò+‚Äô
01:22:27 <lambdabot>     In the first argument of ‚Äò(.)‚Äô, namely ‚Äò(+)‚Äô
01:22:27 <lambdabot>     In the expression: (+) . double
01:22:39 <Kristler> :t ((+) . double)
01:22:40 <lambdabot>     No instance for (Num Doc) arising from a use of ‚Äò+‚Äô
01:22:40 <lambdabot>     In the first argument of ‚Äò(.)‚Äô, namely ‚Äò(+)‚Äô
01:22:40 <lambdabot>     In the expression: ((+) . double)
01:22:43 <Kristler> darn
01:22:58 <jle`> what were you trying to do?
01:23:23 <Kristler> This, actually
01:23:27 <Kristler> :t ((+) . length)
01:23:28 <lambdabot> Foldable t => t a -> Int -> Int
01:26:33 <Kristler> That's equivalent to (\x y -> length x + y), right?
01:26:41 <ttt_fff> okay
01:27:06 <ttt_fff> I have implemented "instance FromJSON Foo". I was told I now get "Text -> Maybe Foo" for free?
01:27:11 <cocreature> Kristler: looks correct
01:27:15 <Kristler> Neat, thank you
01:28:21 <jle`> @unpl (+) . length
01:28:21 <lambdabot> (\ c -> (+) (length c))
01:28:43 <jle`> not as helpful as i had thought
01:29:09 <Kristler> That does look a little bit more intuitive
01:29:23 <ttt_fff> decode
01:29:45 <jle`> ttt_fff: mhm, decode :: FromJSON a => ByteString -> Maybe a
01:30:07 <ttt_fff> jle`: unfortunatley, XHR ggives me a Data.Text.Internal.Text
01:30:12 <ttt_fff> how do I do Data.Text.Internal.Text -> ByteString
01:30:23 <jle`> you have to encode it
01:30:40 <jle`> using http://hackage.haskell.org/package/text-1.2.1.3/docs/Data-Text-Encoding.html
01:31:14 <jle`> i'm guessing you want encodeUtf8
01:32:49 <jle`> because the json spec specifies utf8
01:33:25 <jle`> oh hm, i guess it doesn't
01:34:12 <jle`> okay, it has to be utf-8 from the documentation in http://hackage.haskell.org/package/aeson-0.10.0.0/docs/Data-Aeson-Parser.html
01:34:42 <quicksilver> I don't really understand why aeson's high level functions use ByteString and not Text in their interfaces
01:34:44 <tekkkz> Hello! I tryed `cabal install pack` but with following error: http://ix.io/ltP How to solve this and install `pack` ?
01:34:57 <quicksilver> including both would make sense; if you're only going to do one, I'd have thought Text was the obvious one
01:35:04 <jle`> i feel like i agree
01:35:13 <jle`> it might be because attoparsec works with Bytestring
01:35:52 <jle`> oh wait no, attoparsec works fine with Text to
01:35:53 <jle`> o
01:35:57 * jle` shrugs
01:36:54 <quicksilver> tekkkz: looks like 'pack' hasn't been tested with recent library versions
01:37:09 <quicksilver> you can either install it in a separate sandbox (Without lens and all the other stuff you currently have)
01:37:21 <quicksilver> or you can try to force pack to work with your newer packages - it might well work fine.
01:37:37 <abrar> ttt_fff: if you're using Reflex.Dom.Xhr, take a look at this line: 
01:37:38 <abrar> https://github.com/ryantrinkle/reflex-dom/blob/develop/src/Reflex/Dom/Xhr.hs#L126
01:37:56 <abrar> it's got a couple functions already to handle decoding
01:38:09 <abrar> decodeXhrResponse might be what you're looking for
01:38:13 <ttt_fff> abrar: you read my mind
01:45:02 <tekkkz> quicksilver, how to force?
01:52:05 <quicksilver> tekkkz: --allow-newer I think
01:52:38 <quicksilver> yes, cabal install --allow-newer
01:52:40 <quicksilver> is worth trying
01:52:47 <quicksilver> there might be a compile error - but you don't know until you try
01:53:10 <quicksilver> tekkkz: any particular reason you're using 'pack' and not one of the more well-known binary encoding packages?
01:55:32 <tekkkz> nope
01:55:37 <tekkkz> whats the name of the binary?
02:00:48 <quicksilver> cereal and binary are the ones i normally see recommended
02:02:40 <merijn> Mostly binary, there were plans to merge the two and binary has subsumed most of cereal's functionality
02:02:55 <merijn> (i.e. strict incremental decoding)
02:04:20 <merijn> The only thing cereal does that binary can't is building strict ByteString directly (instead of lazy and then using toStrict)
02:11:21 <lpaste> Copperis pasted ‚ÄúEither in main do block‚Äù at http://lpaste.net/143332
02:13:51 <Copperis> can someone look at this paste: http://lpaste.net/143332 ? It should print a line depending on the Either value, but I get this error on line 6: "Couldn't match expected type `[Char]' with actual type `IO ()'"
02:14:14 <quicksilver> Copperis: you need putStrLn ("foo" ++ bar)
02:14:22 <quicksilver> Copperis: or, putStrLn $ "foo" ++ bar
02:14:34 <Copperis> quicksilver, yup, thanks
02:14:53 <quicksilver> otherwise it parses as (putStrLn "foo") ++ bar
02:14:54 <quicksilver> :)
02:15:10 <quicksilver> Copperis: FWIW, you don't need "do" when there is only one statement
02:15:17 <Copperis> I thought about immediatelly as I asked the question :)
02:15:41 <quicksilver> also since the IO part is the same in both cases it might amuse you to factor that out
02:16:05 <quicksilver> putStrLn (case result of Left err -> "Error: " ++ err; Right solution -> "The result is: " ++ solution)
02:16:47 <quicksilver> putStrLn (either (\err ->  "Error: " ++ err) (\solution -> "The result is: " ++ solution))
02:16:54 <quicksilver> or, it might not amuse you :) lots of approaches!
02:16:59 <Copperis> quicksilver, oh yeah, that works
02:17:08 <Copperis> didn't know about the .either function
02:17:13 <quicksilver> I wouldn't actually write those on one line, by the way
02:17:14 <quicksilver> that's just for IRC
02:17:54 <quicksilver> I missed out 'result' from the either one, bah
02:18:01 <quicksilver> needs to end ) result) not ))
02:27:40 * hackagebot secp256k1 0.1.6 - secp256k1 bindings for Haskell  https://hackage.haskell.org/package/secp256k1-0.1.6 (xenog)
02:32:40 * hackagebot secp256k1 0.1.7 - secp256k1 bindings for Haskell  https://hackage.haskell.org/package/secp256k1-0.1.7 (xenog)
02:38:05 <elliptic00> what is wrong with my definition:  stuff::()->()  stuff = ()
02:38:15 <quicksilver> the type is a function
02:38:21 <quicksilver> and the defintion is not a function
02:38:44 <elliptic00> Couldn't match expected type ‚Äò() -> ()‚Äô with actual type ‚Äò()‚Äô
02:38:45 <elliptic00>     In the expression: ()
02:38:45 <elliptic00>     In an equation for ‚Äòstuff‚Äô: stuff = ()
02:39:02 <quicksilver> yes, that's GHC's way of saying what i just said.
02:39:14 <quicksilver> although it has been a bit more precise about it.
02:39:18 <pavonia> :t let stuff = () in stuff
02:39:19 <lambdabot> ()
02:39:28 <pavonia> :t let stuff = () in stuff :: () -> ()
02:39:29 <lambdabot>     Couldn't match expected type ‚Äò() -> ()‚Äô with actual type ‚Äò()‚Äô
02:39:29 <lambdabot>     In the expression: stuff :: () -> ()
02:39:29 <lambdabot>     In the expression: let stuff = () in stuff :: () -> ()
02:42:41 * hackagebot tomato-rubato-openal 0.1.0.4 - Easy to use library for audio programming.  https://hackage.haskell.org/package/tomato-rubato-openal-0.1.0.4 (HeinrichApfelmus)
02:43:29 <june_> exit
02:45:02 <liste> elliptic00 maybe you're after stuff () = () ?
02:45:16 <elliptic00> ok, I can do that:   stuff() -> () and stuff _ = ()
02:46:32 <quicksilver> yes, you can do that elliptic00 
02:47:40 <clintm> Do any of you happen to have experience building gtk3 applications on windows?  I'm using stack, but I'll do whatever it takes to get this thing to build.
02:48:00 <voidzero> *insert doomy music*
02:48:05 <clintm> I know, right?
02:49:27 <clintm> I'll try HP and a local install of msys2, and see if that works.
02:49:37 <clintm> yay for virtualbox and snapshots.
02:51:28 <Copperis> can I return a function for an Either like this: Right (+) ?
02:51:39 <merijn> Copperis: Sure?
02:51:42 <merijn> :t Right (+)
02:51:43 <lambdabot> Num a1 => Either a (a1 -> a1 -> a1)
02:52:10 <voidzero> but it seems so simple!
02:52:29 <dave34> hello, when using yesod/persistent is there a way to not get the entire record? I only need 1 value
02:52:46 <elliptic00> on my *.hs file:   mybool = False, is that binding? or something else?
02:53:06 <elliptic00> what about  let mybool = False?
02:53:14 <voidzero> same thing
02:54:03 <voidzero> it's a value, so yeah, binding
03:01:06 <mgsloan> clintm: Uhhh, installing the HP will put a bunch of stuff in your global DB, and you probably don't want that
03:01:47 <mgsloan> clintm: You probably need to install the GTK+ libraries / headers on windows
03:01:55 <liste> elliptic00 you can't have a let .. = .. in top level of your .hs file
03:02:07 <liste> only in let .. in .. or do blocks
03:02:49 <elliptic00> thx
03:04:03 <elliptic00> mystuff::Bool->Bool                                                                     |sumlist (x:xs) = x+sumlist(xs)
03:04:03 <elliptic00> mystuff _ = undefined == undefined 
03:04:26 <mgsloan> clintm: stack also installs msys2 for you, so you can skip getting that.  From the GTK+ windows page "MSYS2 provides packages for the GTK stack, so all you have to do is install them and build your application inside the MSYS2 environment."
03:04:58 <mgsloan> Not sure how to install msy2 packages, I haven't used windows much in something 9 or 10 years
03:05:01 <elliptic00> anyone know why it is not workign?   stuff::Bool->Bool  stuff _ = undefined == undefined 
03:05:20 <elliptic00> it work if I change to stuff _ = 1 == 1
03:05:30 <quicksilver> it doesn't know what type 'undefined' is
03:05:35 <clintm> mgsloan: Yea, I've opened that can of worms all the way :)  msys2 is great, and it almost works.
03:05:35 <quicksilver> so it doesn't know how to use == on it
03:05:55 <elliptic00> it seems that I can't compare undefined with undefined
03:06:02 <clintm> mgsloan: stack exec -- pacman -S <package name> :)
03:06:32 <mgsloan> Oh, no way.  Same pacman as arch?  crazy
03:06:37 <tdammers> elliptic00: you can, but the result is also undefined, and you need to tell the compiler the type of your undefineds so that it knows which instance to pick
03:06:50 <tdammers> > (undefined :: Int) == (undefined :: Int)
03:06:51 <lambdabot>  *Exception: Prelude.undefined
03:06:58 <tdammers> > undefined == undefined
03:07:00 <lambdabot>  *Exception: Prelude.undefined
03:07:02 <clintm> Yea, it was pretty nice to see.  Dealing with packages, at least, is nice and easy.
03:07:23 <tdammers> > if False then undefined == undefined else True
03:07:25 <lambdabot>  True
03:07:40 <tdammers> hmm, seems to typecheck fine even without the type hints
03:09:05 <merijn> System F question...
03:10:04 <merijn> If "Œªx. y" is called a lambda expression, so what is "Œõx.y" called?
03:11:30 <clintm> teepee expression
03:11:34 <clintm> *shrug*
03:11:39 <quicksilver> was that a /\ ?
03:11:47 <merijn> quicksilver: Capital lambda, yes
03:11:50 <quicksilver> if so, I'd call it a type-lambda expression
03:11:58 <merijn> quicksilver: Fix your unicode support! :p
03:12:43 <quicksilver> nah, it'll never catch on
03:12:46 <quicksilver> it's just a fad
03:12:56 <quicksilver> I hear iOS 10 will use EBCDIC
03:13:08 <tdammers> full circle.
03:17:31 <Sindriav_> Can I `runghc` a whole project?
03:19:05 <elliptic00> f5::Bool->Bool
03:19:06 <elliptic00> f5 undefined = undefined
03:19:06 <elliptic00> f6::Bool->Bool
03:19:08 <elliptic00> f6 _ = undefined
03:19:28 <elliptic00> anyone know what is the difference between two functions?
03:19:40 <elliptic00> it works in GHC :)
03:20:53 <liste> elliptic00 f5 redefines undefined
03:21:01 <liste> it's equivalent to f5 x = x
03:21:33 <liste> > let f5 :: Bool -> Bool; f5 undefined = undefined in f5 True
03:21:34 <lambdabot>  True
03:22:00 <liste> (or, rather, shadows the `undefined' binding)
03:22:23 <mgsloan> clintm: This issue just came up in my github notifications. Seems potentially relevant: https://github.com/commercialhaskell/stack/issues/1182#event-438932085
03:22:39 <clintm> That's me
03:22:41 <clintm> :)
03:23:06 <mgsloan> Ahh gotcha :D
03:24:06 <clintm> I definitely appreciate it though.  When you've got a huge yak that's resisting a close shave, it's nice to know someone is lookin' out for you.
03:24:25 <lpaste> Copperis pasted ‚ÄúNo title‚Äù at http://lpaste.net/143333
03:25:17 <LostinASeaOfLinu> hey
03:25:17 <Copperis> is the 4th line the correct way to call a returned function? In http://lpaste.net/143333
03:27:14 <elliptic00> f7::Bool->Bool
03:27:14 <elliptic00> f7 = undefined
03:27:33 <merijn> Copperis: Sure
03:27:42 <merijn> Copperis: Note that "last . init" is very slow, though
03:27:43 <elliptic00> I can define f7 like above,  but how can I call the f7?
03:28:07 <Axman6> Copperis: your types don't match, you case for Right doesn't return a list of a ([a])
03:28:40 <elliptic00> does't matter what I pass to f7, I get exception in GHC
03:28:58 <elliptic00> e.g f7 False,  or f7 True
03:29:01 <merijn> elliptic00: Right
03:29:08 <elliptic00> f7 _
03:29:11 <Copperis> Axman6, you're right, thanks
03:29:25 <merijn> elliptic00: Note that "foo x = x + x" is basically the same a "foo = \x -> x + x"
03:29:33 <Axman6> I would use: Left x -> x : acc; Right f -> (f (head . tail $ acc) (head acc)) : tail (tail acc) 
03:29:36 <Copperis> merijn, I'll refactor that once I get this working
03:29:39 <Copperis> probably
03:29:44 <Axman6> I assume you're implementing RPN notation
03:30:22 <Copperis> yeah, I'm more learning to write haskell than trying to write a good implementation
03:30:25 * quicksilver would probably pattern match acc somewhere rather than head.tail/head
03:30:26 <merijn> elliptic00: So when you do "f7 = undefined" you're defining "f7" as a new name for undefined AND your type signature is saying undefined is a function (lambda). So when GHC tries to apply the function to any argument it evaluates "undefined" (so it can be applied) and then promptly throws an exception because it's undefined
03:30:29 <Copperis> though both would be good
03:30:58 <merijn> Copperis: I would follow quicksilver's suggestion and move the folding function out of a lambda into a where/let so you can properly pattern match
03:31:46 <merijn> elliptic00: On the other hand when you write "f7 _ = undefined" this is similar to "f7 = \_ -> undefined" so applying it only crashes if you look at the result of applying!
03:31:50 <merijn> Compare
03:32:06 <merijn> > case (\_ -> undefined) True of _ -> True -- this works!
03:32:07 <lambdabot>  True
03:32:16 <merijn> > case undefined True of _ -> True -- this works!
03:32:17 <lambdabot>  True
03:32:21 <merijn> oh...
03:32:22 <merijn> bah
03:32:26 <merijn> Bad example >.>
03:33:28 <Copperis> quicksilver, yup, that's the solution in the learning material, though I started doing it like this
03:34:23 <quicksilver> well there is merit in tryin gdifferent ways
03:34:28 <quicksilver> to learn how it works :)
03:34:39 <quicksilver> there might be another case wehere a slightly different style looked nicer
03:36:59 <merijn> > generalCategory '‚àÄ'
03:37:01 <lambdabot>  MathSymbol
03:37:22 <voidzero> oh nice
03:37:59 <quicksilver> glguy: ping
03:38:09 <Copperis> quicksilver, I prefer finding a solution myself before reading how to do it when I'm learning and am permitted to do so
03:38:17 <quicksilver> Copperis: good :)
03:43:04 <Unhammer> is there a way to make ghci (in emacs, if it matters) not forget everything when I :load ?
03:43:09 <Unhammer> or, not forget my let's
03:43:33 <merijn> Unhammer: Not unless you count "write them in a file" as a valid solution ;)
03:43:51 <Unhammer> :/
03:44:41 <quicksilver> it's a deliberate feature because it can get pretty confusing for various reasons
03:44:50 <quicksilver> including having references lying around to 'old versions' of types
03:44:55 <quicksilver> but, it is annoying.
03:45:19 <quicksilver> merijn is right, copy your convenient defns to a temporary file for the purpoes of your ghci sessions
03:45:54 <Unhammer> ok ‚Ä¶ that's pretty much what I've been doing (along with lots of M-p's)
03:46:29 <Unhammer> hm, is there a way to do C-M-x then?
03:46:46 <Unhammer> like, "send only this declaration to ghci"
03:46:51 <Unhammer> from emacs
03:47:58 <quicksilver> no, I don't think so
03:48:13 <quicksilver> have wondered about that myself sometimes
03:48:26 <quicksilver> often it won't work because often it would depend on other things ghci wouldn't have in scope
03:48:31 <quicksilver> but wehn it woudl work, it would be useful
03:48:38 <Unhammer> seems like something that shold be possible, by just adding some let's and surrounding with {}'s
03:48:54 <quicksilver> Unhammer: have you see ob-haskell?
03:49:09 <Unhammer> no ‚Ä¶
03:49:21 <Unhammer> oh, nice
03:49:53 <quicksilver> I wish there was a proper workbook style thing though
03:49:57 <quicksilver> like mathematica
03:50:15 <quicksilver> but org-babel gets you some of the way there
03:50:30 <quicksilver> there is also ihaskell (built on ipython)
03:50:35 <quicksilver> haven't used that
03:50:48 <Unhammer> I never got into the whole ipython thing
03:52:17 <quicksilver> me neither.
03:58:08 <elliptic00> found = matchRegex (mkRegex "git") "one git two three"
03:58:18 <elliptic00> why My output is Just []?
03:58:30 <elliptic00> print found, the output is Just []
03:58:38 <elliptic00> any idea?
03:59:01 <gciubot> cuz is match not search
03:59:11 <gciubot> try ".*git.*"
03:59:24 <quicksilver> no, I think Just means it succeed fine
03:59:26 <magbo> Hey, people! How do I approach translation of things in a Gtk application in Haskell?
03:59:27 <gciubot> match will try to match the whole string 
03:59:32 <quicksilver> [] is because no subexpressions
03:59:51 <quicksilver> so "Just []" means 'match succeeded but no subexpressions captured"
04:00:00 <magbo> Intuition tells me to attach ReaderT and then re-render, but I'm using low-level gtk bindings :S
04:01:52 <elliptic00> change to mkRegex "(git)" , and get output Just ["git"], this is what I want..:)
04:02:17 <quicksilver> elliptic00: good :)
04:02:43 <quicksilver> elliptic00: or you could have used 'matchRegexAll'
04:02:55 <quicksilver> elliptic00: which gives you the text matched as well as the subexpressions
04:10:20 <some0ne> hi
04:10:51 <some0ne> i have a monad transformer EitherT String IO () and an Either value
04:11:03 <some0ne> how can i 'send' the Either value inside the monad ?
04:12:20 <quicksilver> either throwError return
04:12:22 <quicksilver> ^^ some0ne 
04:12:33 <pavonia> hoistEither?
04:12:37 <quicksilver> :t either throwError return
04:12:39 <lambdabot> MonadError e m => Either e a -> m a
04:12:43 <quicksilver> ah it has a name does it? :)
04:12:53 <some0ne> ok that the same 'trick' than with MaybeT
04:12:54 <Gurkenglas> https://hackage.haskell.org/package/either-4.4.1/docs/Control-Monad-Trans-Either.html#v:hoistEitherT
04:13:12 <some0ne> thanks =)
04:13:24 <quicksilver> hoistEither only works if EitherT is the outermost layer
04:13:31 <quicksilver> which it happens to be, in some0ne's case
04:13:40 <quicksilver> but either throwError return works for any instance of MonadError
04:14:20 <some0ne> yep i think i prefer the method of quicksilver but it's good to know the other solution ;)
04:14:31 <some0ne> what does hoist mean ?
04:14:44 <quicksilver> hoist is used for functions which convert from one monad to another one
04:14:53 <quicksilver> given that the two monads have "something" in common
04:14:59 <quicksilver> in your case, the either in common
04:15:12 <some0ne> ok =)
04:15:20 <quicksilver> https://hackage.haskell.org/package/mmorph
04:15:28 <quicksilver> is the package which makes hoist quite general and precise
04:15:43 <quicksilver> but, not all combinations turn out to be proper morphisms
04:16:13 <quicksilver> surprisingly mmorph doesn't stand for Massively Multiplayer Online Role Playing Haskell
04:16:27 <some0ne> :D
04:18:22 <elliptic00> I want to use replaceAll, how do I know where does replaceAll belong to which package? I can google it, but can I find out in GHCI?
04:18:54 <elliptic00> I miss the package for replaceAll so far.
04:19:20 <ReinH> @hoogle replaceAll
04:19:20 <lambdabot> No results found
04:19:52 <ReinH> what is replaceAll?
04:20:06 <quicksilver> elliptic00: :info should tell you which module it's in
04:20:25 <quicksilver> you need to use ghc-pkg to find which package that module comes from
04:20:27 <quicksilver> (I think?)
04:20:34 <elliptic00> Not in scope: ‚ÄòreplaceAll‚Äô
04:22:14 <pavonia> http://hayoo.fh-wedel.de/?query=replaceAll
04:24:29 <elliptic00> I try Hoogle, but have no luck    
04:25:18 <quicksilver> what makes you think it exists, elliptic00 ?
04:25:28 <quicksilver> where did you hear about replaceAll?
04:26:31 <elliptic00> sorry, wrong funciton name :)
04:26:44 <elliptic00> matchRegexAll this is what I looking for...:)
04:27:26 <elliptic00> replaceAll :: String-> (String -> String)-> String-> String
04:27:39 <quicksilver> matchRexexAll is in Text.Regex
04:27:49 <elliptic00> https://hackage.haskell.org/package/text-regex-replace-0.1.1.1/docs/Data-Text-ICU-Replace.html
04:27:56 <quicksilver> https://hackage.haskell.org/package/regex-compat-0.95.1/docs/Text-Regex.html
04:48:10 <nmeum> I have stupid noob question: I have a list of Strings ["f", "o", "o"] and would like to concatinate them. How do I do that? I think using map is a part of the solution here but how do I concatinate two strings then?
04:48:51 <SX> Hi! Guys, what should I use for errors in IO monad?
04:49:07 <pavonia> nmeum: Use concat?
04:49:10 <pavonia> :t concat
04:49:11 <lambdabot> Foldable t => t [a] -> [a]
04:49:35 <SX> I have a strict set of possible errors, so I don't think I need exceptions there
04:49:50 <ent-> in which version of ghc is concat Foldable t => t [a] -> [a]? I have [[a]] -> [a]
04:50:06 <fizruk> :t concat
04:50:07 <lambdabot> Foldable t => t [a] -> [a]
04:50:11 <pacak> ent-: [a] is Foldable.
04:50:23 <fizruk> ent-: 7.10
04:51:04 <lyxia> SX: ExceptT MySetOfErrors IO ?
04:51:23 <pacak> ent: FTP proposal
04:54:03 <SX> lyxia: Is it a good option? Why not MonadError, for example?
04:55:28 <ent> cool, my ghc installed by stack does indeed have that FTP change
04:56:25 <SX> lyxia: and what's the difference between ErrorT and ExceptT?
04:59:22 <quicksilver> ent: 7.10
04:59:31 <quicksilver> oh fizruk said that. sorry.
05:01:44 <lyxia> SX: ErrorT requires an Error instance on the error type (and it's deprecated anyway), ExceptT doesn't require anything.
05:02:47 <lyxia> SX: MonadError is a typeclass that allows to define computations that may fail generically, and it is compatible with ExceptT.
05:04:08 <SX> lyxia: Ok, thank you! So is it the best way to define evaluations with possible errors?
05:08:50 <lyxia> No, I guess it's the most straightforward method (besides killing your program with fail), but depending on the details of your application there may be more appropriate stuff that I don't know about
05:11:34 <SX> Connection with server. Connection can disconnect, server may respond with error and there may be a request timeout
05:15:21 <inad922> hello
05:15:39 <inad922> How can I check the length of an array from the Data.Array package?
05:15:49 <tekkkz> Hello! I want to install `plot` with `cabal install plot` ... after some package-missings errors at the beginning i installed them but now there is an error i can't solve: http://ix.io/ltW What is this? How to solve my problem and get plot working??
05:16:15 <inad922> bounds?
05:17:23 <inad922> Ah ok Data.Array enables constructions of multidimensional arrays
05:17:30 <aweinstock> :t Data.Array.bounds
05:17:31 <lambdabot> Ix i => Array i e -> (i, i)
05:17:33 <inad922> Makes sense why there is no length function
05:18:07 <aweinstock> :t Data.Ix.rangeSize . Data.Array.bounds
05:18:08 <lambdabot> Ix a => Array a e -> Int
05:19:13 <aweinstock> inad922: if you're not specifically using Data.Array for its multidimensionalness though, I'd suggest using Data.Vector
05:19:53 <aweinstock> (Vector has a friendlier interface in the 1dimensional case, and lets you do copy-on-write mutable modifications for performance)
05:19:58 <aweinstock> :t Data.Vector.modify
05:19:59 <lambdabot> (forall s. Data.Vector.Mutable.MVector s a -> ST s ()) -> Data.Vector.Vector a -> Data.Vector.Vector a
05:22:47 * hackagebot engine-io-wai 1.0.4 -   https://hackage.haskell.org/package/engine-io-wai-1.0.4 (codedmart)
05:23:47 <inad922> aweinstock, Thanks. I'm a beginner. Any help is appreciated. I guess I have a look at Data.Vector
05:26:57 <aweinstock> inad922: by "friendlier interface", I mean that Vector has a bunch of functions like map, foldr, filter (and versions that give you the indexes, like ifilter), so you can write the same concise code you'd write with lists
05:27:44 <inad922> aweinstock, I was a bit confused I guess. I want to create a graph data structure which supposedly take the form "Vector (Map Int (Map Int Int))" which supposed to represent a vector with integer weighted edges. I know I can create a parametric type which enables me switching between float/int weighted edges but it's just good enough for now
05:27:50 <aweinstock> also, Data.Vector.generate lets you write dynamic-programming algorithms in a straightforward way
05:28:21 <inad922> aweinstock, What do you mean it enables writing dynamic programming algs in a straightforward way?
05:29:33 <aweinstock> > let fibsTo n = (let result = Data.Vector.generate n (\i -> if i < 2 then 1 else result Data.Vector.! i-1 + result Data.Vector.! i-2) in result) in fibsTo 10
05:29:34 <lambdabot>  Not in scope: ‚ÄòData.Vector.generate‚ÄôNot in scope: ‚ÄòData.Vector.!‚ÄôNot in scop...
05:30:20 <aweinstock> huh, that's odd
05:30:27 <aweinstock> :t let fibsTo n = (let result = Data.Vector.generate n (\i -> if i < 2 then 1 else result Data.Vector.! i-1 + result Data.Vector.! i-2) in result) in fibsTo 10
05:30:31 <lambdabot> Num a => Data.Vector.Vector a
05:31:06 <clrnd> :|
05:32:37 <aweinstock> inad922: i was able to run it locally, and it turns out that (i-1) and (i-2) need to be parenthesized, but otherwise it does work correctly
05:32:42 <inad922> aweinstock, Looks good. I assume V.generate cache the results of the lambda function which it is given as a second param
05:32:56 <aweinstock> :t Data.Vector.generate
05:32:57 <lambdabot> Int -> (Int -> a) -> Data.Vector.Vector a
05:33:35 <aweinstock> you give it a size, and a function from indices to values, and it creates the vector
05:34:14 <aweinstock> and thanks to lazyness, it's possible to look up values in the vector that have already been computed, while still constructing it
05:34:38 <inad922> that's good
05:35:22 <aweinstock> regarding "type Graph = Vector (Map Int (Map Int Int))", I think I'm missing something: isn't that 1 degree of freedom too many?
05:35:39 <opqdonut> sounds like it yeah
05:35:49 <opqdonut> or perhaps edges are labeled with Ints?
05:36:04 <inad922> nah, one degree too many
05:36:08 <opqdonut> Map Int (Set Int) would be the canonical
05:36:13 <inad922> Vector (Map Int Int) should suffice
05:36:21 <aweinstock> i.e. you want "lookupWeight sourceNodeIndex destNodeIndex = someWeight"
05:36:51 <opqdonut> ok nevermind I didn't read the context
05:36:51 <inad922> opqdonut, Not good enough for me I want fast lookups for weights between nodes "a" and "b"
05:37:50 <aweinstock> opqdonut: (Map Int (Set Int)) is just connectedness, and it allows non-consecutive labels
05:38:58 <aweinstock> inad922: I personally would use (Map Int (Map Int)) for that, both to allow nonconsecutive labels, and to use Maybe for lookups
05:39:06 <inad922> aweinstock, Is Data.Array efficient btw? I mean compared to libs like numpy?
05:40:10 <aweinstock> I don't know about Data.Array, but Data.Vector has a reputation for efficiency, and Data.Vector.Unboxed is practically a C-array
05:40:18 <inad922> aweinstock, Yeah, but labels are kind of consecutive always. I mainly want to try this in codeforces problems where labels are always consecutive.
05:40:52 <aweinstock> HMatrix is blas bindings, which is the most direct equivalent to numpy, and it uses Data.Vector internally
05:41:05 <inad922> Ah ok
05:41:09 <inad922> I have a look
05:41:24 <aweinstock> (blas is "basic linear algebra subroutines", and it's the fortran code that everyone links to)
05:42:12 <aweinstock> :t (\src dst -> M.lookup src >=> M.lookup dst)
05:42:13 <lambdabot> (Ord k, Ord k1) => k -> k1 -> M.Map k (M.Map k1 c) -> Maybe c
05:42:30 <aweinstock> ^ that's what I meant by "use Maybe for lookups"
05:48:25 <inad922> aweinstock, I know BLAS. Didn't know it had a haskell binding.
05:48:50 <inad922> Why would I.. I don't know much about this lang
05:48:56 <inad922> Like it so far anyway
05:51:12 <clrnd> what about https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell/ ?
05:51:27 <clrnd> are we idris yet?
05:52:01 <raichoo> Hi, anyone in here building GHC on ArchLinux. I have some issues compiling it even though it worked fine a while ago. http://pastebin.com/Z535AS2s Fails with HEAD and 7.10.2 tarball.
05:52:48 * hackagebot luminance 0.5.2 - Type-safe, dependently-typed and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.5.2 (DimitriSabadie)
05:59:48 <lpaste> Copperis pasted ‚ÄúDoes not compile‚Äù at http://lpaste.net/143360
06:01:42 <Copperis> I don't understand the error that is at line 8. Can someone explain what is happening? http://lpaste.net/143360 The error is in comments
06:04:37 <clrnd> Copperis, `solution !! 0`?
06:05:09 <clrnd> :t (!!)
06:05:09 <Copperis> whoops
06:05:10 <lambdabot> [a] -> Int -> a
06:05:13 <clrnd> :P
06:05:17 <glguy_> Copperis: you're using !! 0 on your result, which makes it a list, which it probably isn't
06:05:25 <Copperis> thanks clrnd
06:05:31 <Copperis> yup
06:09:24 <deception1> in Ruby Programming language `myList.shuffle.first` is slower than `myList.sample` since it completely shuffle the list and pick the first element. If something similar (shuffle and take first) done in haskell will that be as fast as the later (sampling the array). I am assuming the list will be shuffled lazily so picking the first element and taking the sample will take same amount of time. 
06:11:37 <qsuscs> why does this not work? > map (/15) [x | x <- [1..], mod x 3 == 0, mod x 5 == 0]
06:11:51 <Copperis> deception1, as I understand it will shuffle only as much to get the first element, so should be fast
06:13:15 <ggole> qsuscs: you probably want to use div instead of /
06:13:47 <Copperis> qsuscs, x is of Integral type and doesn't have "/" defined. Not sure though
06:13:52 <qsuscs> hmhmhm.
06:13:57 <clrnd> deception1, my guess is that they are exactly the same
06:14:17 <ggole> > take 10 $ map (flip div 15) [x | x <- [1..], mod x 3 == 0, mod x 5 == 0]
06:14:18 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
06:14:20 <qsuscs> i‚Äôd either have to convert them (like "cast" in other languages) or use something else
06:14:46 <clrnd> (talking ofc about a phantom `shuffle :: RandomGen g => g -> [a] -> [a]` that recursively calls !!
06:14:50 <ggole> Hmm. is (`div` 15) better there?
06:15:00 <dutchie> ggole: i was about to suggest that
06:15:24 <qsuscs> i want to know whether they divide cleanly, so i use (flip mod 15) now
06:15:33 <qsuscs> still, i‚Äôd rather have the float divsion
06:16:14 <deception1> Copperis: thanks! :)
06:16:23 <deception1> Clrnd: Thanks! :)
06:18:31 <inad922> Eh, is it really true that modifying an element in a Data.Vector takes O(n) time? I mean I understand that variables are immutable in Haskell, but I thought there is some compiler magic for this. I mean it doesn't make sense to use vectors/arrays this way...
06:18:34 <dutchie> :t fromIntegral
06:18:35 <lambdabot> (Integral a, Num b) => a -> b
06:18:44 <dutchie> qsuscs: ^^ that's the function you need then
06:19:13 <clrnd> inad922, there is Data.Vector.Mutable for that
06:19:16 <clrnd> (iirc)
06:19:28 <inad922> clrnd, Ah cool
06:19:30 <inad922> thanks
06:20:25 <qsuscs> dutchie: thx
06:20:39 <aweinstock> inad922: if this is still for the graph thing, I'm pretty sure Map has O(log n) immutable update
06:21:49 <inad922> aweinstock, Yeah I know, but this should be solved in O(1). O(log n) is a huge gap.
06:22:04 <qsuscs> i now have map ((/15) . fromIntegral) [x | x <- [1..], mod x 3 == 0, mod x 5 == 0]
06:23:01 <dutchie> that ought to work. though i'd probably write it as `map (/15) [fromIntegral x | x <- [1..], mod x 3 == 0, mod x 5 == 0]
06:23:03 <dutchie> `
06:23:09 <qsuscs> oh. yes.
06:23:16 <dutchie> or even move the (/15) into the listcomp i guess
06:23:22 <aweinstock> inad922: Data.Vector.modify lets you run a mutable-vector-computation on an immutable vector, it uses reference-counting to know whether it needs to make an O(n) copy, or whether it can run it in-place
06:23:39 <qsuscs> mh, yeah, i‚Äôm just a bit used to [x | x <- ......]
06:24:57 <quicksilver> inad922: it's not. O(log n) is not a huge gap from O(1)
06:25:21 <quicksilver> being scared of O(log n) can lead you to spend loads of programmer time worrying about problems that don't bite you.
06:25:36 <quicksilver> it's the constant factor that matters - benchmark and find out.
06:27:17 <inad922> aweinstock, You mean that if I only reference it in say the function modifies it then it runs the change in place? Interesting. I mean the notation on the doc page is a bit misleading in this case.
06:27:50 * hackagebot tar 0.4.2.2 - Reading, writing and manipulating ".tar" archive files.  https://hackage.haskell.org/package/tar-0.4.2.2 (DuncanCoutts)
06:29:14 <aweinstock> inad922: that's my understanding of modify, in what way are the docs misleading?
06:29:27 <inad922> quicksilver, Look array lookup is O(1) with a c = 1. Haskell's Map is ordered so I assume there is some balanced binary tree implementation where the c in O(log n) is nowhere close to 1. Means that around as small as n = 1000 we can have a ratio of 10 between the 2. I think it's a huge gap.
06:29:53 <quicksilver> inad922: array lookup does not have c=1. that's not how constants work.
06:30:19 <aweinstock> inad922: I agree with quicksilver's advice, log n grows *really* slowly, and computers can do billions of operations per second these days (that's literally what GHz means)
06:30:25 <inad922> aweinstock, Ah ok no. I was looking at something else. I see what you've quoted previously
06:30:33 <quicksilver> you may possibly have a gap of 10 between the two but you don't know until you try it out.
06:30:49 <quicksilver> IntMap is faster than Map, assuming your coordinates are Ints anyway
06:31:10 <quicksilver> and IntMap has much better sharing and GC behaviour than Vector
06:31:20 <inad922> quicksilver, array element lookup is 1 step. You can compute the offset at compile time I assume.
06:31:26 <quicksilver> I'm not saying Data.Vector won't be faster for you - perhaps it will be.
06:31:31 <frerich> inad922: The speed advantage of an array stored in contiguous memory vs. some sort of map is not caused by the algorithmic complexity but rather by the constant factors. For instance, array accesses often benefit a lot from cache locality.
06:31:32 <aweinstock> quicksilver: s/coordinates/vertex labels/, and my understanding is that that's correct
06:32:17 <quicksilver> inad922: "1 step" is not a very good reflection of how modern CPUs work
06:32:31 <quicksilver> an array lookup which is a cache miss is 1000 times slower than an IntMap lookup which is a cache hit.
06:32:32 <quchen> Complexity is not a very good reflection of runtime performance either.
06:33:00 <quicksilver> anyhow, let me finish what I was saying - Data.Vector may indeed be faster than you, but if you care, don't assume, test it.
06:33:24 <aweinstock> inad922: if you really want to optimize before benchmarking, allocate N^2 contiguous memory, and use the (x+y*width) indexing calculations (i.e. an adjacency-matrix graph representation, I think it's called)
06:33:24 <quicksilver> if it is faster it won't be because "O(1) is better than O(log n)" - it will be because the constant factors worked out better for your case.
06:33:41 <quicksilver> surprisingly often IntMap is faster than Vector
06:33:56 <quicksilver> if there is substantial sharing in the problem, it almost certainly will be.
06:34:37 <aweinstock> @quote knuth optimization
06:34:37 <lambdabot> No quotes match. Are you on drugs?
06:34:45 <quicksilver> cache locality is the biggest effect as frerich implied.
06:34:52 <quicksilver> GC can be another though.
06:35:13 <quicksilver> there is also the fact that persistent data structures will let you use more idiomatic haskell.
06:36:01 <inad922> aweinstock, Yeah, adjacency matrix representation is good on dense graphs. Not sure if I'll have one
06:36:39 <capisce> quicksilver: true: http://www.forwardscattering.org/post/28
06:37:50 * hackagebot ghc-typelits-natnormalise 0.3.1 - GHC typechecker plugin for types of kind GHC.TypeLits.Nat  https://hackage.haskell.org/package/ghc-typelits-natnormalise-0.3.1 (ChristiaanBaaij)
06:38:01 <inad922> quicksilver, ah. You're aware that insertions in both AVL and RB trees include rotations of subtrees and in RB relabeling of nodes as well. Hence the big difference in rewriting a "pointer" in the array case and rewriting a pointer and modifying a tree in the map case makes a hude difference assuming that this pointer rewriting is the one step we talk about 
06:38:33 <quicksilver> inad922: yes I am. IntMap is neither AVL or RB.
06:38:47 <inad922> Ok, what is it then?
06:39:13 <quicksilver> ...but of course you're right, if you do loads of insertion, then tree-based structures have substantially more work to do than a contiguous array; but then they also have special primitives for bulk insertion of pre-sorted data.
06:39:13 <hyPiRion> inad922: http://ittc.ku.edu/~andygill/papers/IntMap98.pdf I guess
06:39:34 <quicksilver> it's a big-endian patricia tree
06:40:14 <inad922> Ah patricia tree == trie?
06:40:40 <quicksilver> people aren't completely consistent with how they name these things
06:40:48 <quicksilver> but it's one instance of what is sometimes called a trie, yes
06:42:45 <inad922> hmm I have a look at HyPiRion's link. I guess it interprets the key integer as a bit array. I mean that would make sense. 
06:42:50 <aweinstock> Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered. We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%. 
06:43:00 <aweinstock> according to https://en.wikiquote.org/wiki/Donald_Knuth
06:43:19 <quicksilver> normally simplified to simply 'premature optimization is the root of all evil'
06:43:29 <aweinstock> quicksilver: 97% of the time ;)
06:43:42 <quicksilver> on the one hand it's quite interesting to discuss operational semantics and evaluation times and fastest algorithms
06:43:55 <inad922> aweinstock, Yeah I know this Knuth quote. But now I'm not working but just programming for fun and I want that optimization :)
06:44:17 <quicksilver> but on the other hand if you actually want to get something done it's normally better to start by making all the choices which lead to the best code and get you the correct program
06:44:38 <quicksilver> and then profile and then optimise the parts which are actually the bottleneck. If you do indeed need it to be faster.
06:44:48 <hyPiRion> Begin with correct, continue with fast if need be
06:45:38 <inad922> quicksilver, hyPiRion: Yeah I agree that one should first write the correct code and then speed it up. It just that it's not the first time I write a Dijkstra.
06:45:45 <bernalex> hyPiRion: hi. I'm going to Oslo on Fri 6th. food? erlend & olle are probably going. :]]]
06:45:57 <bernalex> hyPiRion: we have #haskell.no btw
06:46:20 <hyPiRion> oh
06:47:27 <inad922> Is Okasaki's book the "Art of computer programming" for func languages?
06:47:54 <hyPiRion> inad922: I think you meant Purely functional data structures?
06:48:00 <hyPiRion> Or did you mean Knuth?
06:48:02 <inad922> hyPiRion, yep
06:48:13 <inad922> I tried to make an association between the two
06:48:32 <quicksilver> no, it isn't
06:48:35 <quicksilver> but it's very interesting
06:48:43 <quicksilver> it's much more specific that TAOCP
06:49:46 <hyPiRion> inad922: Oh, I see, ambigous sentence :p
06:49:56 <ptcek> have you programmed in TeX and Haskell concurrently?
06:50:20 <inad922> hyPiRion, Kind of, sorry
06:50:29 <ptcek> I've never met two languages that are so different :)
06:50:39 <hyPiRion> inad922: It's more like Cormen's "Introduction to Algorithms", but for data structures only
06:50:48 <hyPiRion> functional data structures, that is
06:51:13 <inad922> is it really so different? Sorry for the stupid question...
06:51:24 <inad922> I mean the data structure representations in functional languages
06:51:45 <inad922> I just try to get my head around this
06:52:38 <quicksilver> well it's more "data structures to efficiently leverage sharing"
06:52:48 <quicksilver> (and not use explicit mutation)
06:58:08 <hyPiRion> inad922: Well, almost all data structures in imperative languages are modified through mutation, which more times than not cause the old version to become "invalid". In order to be pure, you have to remove mutation of the old value.
06:58:52 <hyPiRion> It's not that different for common data structures, a pure RB-tree implementation is very similar to an imperative one
06:59:38 <inad922> Hmm interesting 
06:59:56 <inad922> Wonder how does it get around mutation and stay efficient at the same time
07:00:47 <inad922> Also there is an example usage for modify in the Data.Vector module: "modify (\v -> write v 0 'x') (replicate 3 'a') = <'x','a','a'>". Where is this "write" function defined?
07:02:57 <quicksilver> inad922: https://hackage.haskell.org/package/vector-0.10.9.1/docs/Data-Vector-Mutable.html
07:03:52 <inad922> quicksilver, Thanks
07:08:22 <aweinstock> inad922: in an imperative RB tree implementation, if you need both the old and the new version of the tree, you'd need to deep-copy before making a change; the persistant version of the tree is able to make reuse the structure that doesn't change, safely
07:13:14 * hackagebot deepcontrol 0.3.0.0 - Enable more deeper level style of programming than the usual Control.xxx modules express  https://hackage.haskell.org/package/deepcontrol-0.3.0.0 (KONISHI_Yohsuke)
07:20:24 <bernalex> different from what?
07:20:33 <bernalex> oh. my scrollback was stuck.
07:25:04 <quicksilver> is there a favourite library for composing small chunks of xml-types XML
07:25:39 <quicksilver> something so you can write, say, tag "foo" [("attr","value")] [tag "bar", text "...."]
07:25:43 <quicksilver> or whatever
07:26:49 <julianleviston> can someone help me read this type? I‚Äôm trying to work out how to construct a value to pass it.. (PersistEntity v, PrimitivePersistField (Key v BackendSpecific)) => Key v BackendSpecific -> m (Maybe v)
07:28:05 <julianleviston> It takes a Key v BackendSpecific‚Ä¶ obviously. Key is this: data Key v :: * -> * but I don‚Äôt know what that means.
07:28:25 <Ankhers> julianleviston: What is that from?
07:28:32 <julianleviston> Ankhers: groundhog
07:28:42 <julianleviston> Ankhers: http://hackage.haskell.org/package/groundhog-0.7.0.3/docs/Database-Groundhog.html
07:29:09 <frerich> quicksilver: I used http://hackage.haskell.org/package/xmlgen once and it worked quite well.
07:29:29 <julianleviston> How can I create a Key ?
07:31:29 <Ankhers> julianleviston: Have you taken a look at the projects readme? https://github.com/lykahb/groundhog#creating-and-migrating-tables
07:31:43 <pavonia> julianleviston: It depends on what instance of PersistEntity you are using how to create a value of Key
07:32:53 <joneshf-laptop> Anybody know where I can find information about the default fixity of a type operator?
07:33:03 <julianleviston> Ankhers: the trouble is, in all the example code the key variables he seems to be using are just after he‚Äôs created an object, so I can‚Äôt see the type. I‚Äôm just trying to get an item out of the DB‚Ä¶ which I know the key for.
07:34:16 <julianleviston> joneshf-laptop: can‚Äôt you use :i at ghci?
07:34:47 <joneshf-laptop> julianleviston, I don't get any fixity information though.
07:34:58 <julianleviston> joneshf-laptop: really? I do.
07:34:58 <quicksilver> frerich: thanks
07:35:33 <quicksilver> frerich: I looked at that but it has its own type hierarchy rather than using xml-types :/
07:35:42 <Ankhers> joneshf-laptop: What operator are you looking at that you are not seeing fixity information?
07:36:31 <julianleviston> pavonia: Say my PersistEntity instance is called Customer?
07:36:35 <joneshf-laptop> `data (:+:) f g a = InL (f a) | InR (g a)`
07:36:52 <joneshf-laptop> maybe...
07:36:56 <joneshf-laptop> let data (:+:) f g a = InL (f a) | InR (g a)
07:37:01 <joneshf-laptop> >let data (:+:) f g a = InL (f a) | InR (g a)
07:37:05 <joneshf-laptop> beh, oh well
07:37:10 <julianleviston> joneshf-laptop: you have to use @ form.
07:37:18 <joneshf-laptop> @let data (:+:) f g a = InL (f a) | InR (g a)
07:37:19 <julianleviston> joneshf-laptop: if you want to let things in lambdabot.
07:37:20 <lambdabot>  Defined.
07:37:26 <joneshf-laptop> @info (:+:)
07:37:26 <lambdabot> (:+:)
07:38:03 <joneshf-laptop> in any case, I don't get anything out of ghci
07:38:08 <quicksilver> there isn't a command called @info
07:38:16 <Ankhers> infixl 9 I think is the default.
07:38:17 <frerich> quicksilver: Then you might like https://hackage.haskell.org/package/xml-conduit-writer-0.1.1.1/docs/Text-XML-Writer.html :-)
07:38:18 <pavonia> julianleviston: Then you have to define a Key type for your Customer instance
07:38:20 <joneshf-laptop> Œª: :info! (:+:)
07:38:20 <joneshf-laptop> type role (:+:) representational representational nominal
07:38:21 <joneshf-laptop> data (:+:) (f :: * -> *) (g :: * -> *) a = InL (f a) | InR (g a)
07:38:21 <joneshf-laptop>   	-- Defined at <interactive>:16:1
07:38:42 <joneshf-laptop> Ankhers, thanks. Do you know where I might find that information?
07:38:47 <julianleviston> pavonia: how could I have created items without having had one?
07:38:57 <frerich> quicksilver: IIRC I didn't use that because it had so many dependencies (maybe a bit lame a reason...).
07:39:00 <Ankhers> joneshf-laptop: I just googled "haskell default operator fixity"
07:39:00 <julianleviston> pavonia: (entries in the db, I mean)
07:39:25 <quicksilver> frerich: yes, probably that's the best. using 'do' notation for a Monoid is yuck though :)
07:39:30 <julianleviston> pavonia: ah‚Ä¶ I have some TH that creates some‚Ä¶ ok
07:39:44 <pavonia> julianleviston: I don't know what this class is for or how it works, I'm just telling you from the types I see
07:39:46 <julianleviston> pavonia: so I already have a key for it. CustomerKey. Cool‚Ä¶ now I just give it an int
07:39:55 <julianleviston> pavonia: apologies :)
07:40:05 <pavonia> No worries
07:40:06 <julianleviston> pavonia: and thanks for helping. That‚Äôs helpful.
07:40:33 <pavonia> Oh, and I just saw Key is from another class, PersistEntity
07:40:38 <aweinstock> :t Database.Persist.getBy
07:40:39 <lambdabot> Not in scope: ‚ÄòDatabase.Persist.getBy‚Äô
07:40:48 <julianleviston> pavonia: so ‚Ä¶ CustomerKey :: Database.Groundhog.Core.PersistValue -> Key Customer BackendSpecific
07:41:39 <julianleviston> far out
07:42:14 <julianleviston> pavonia: it‚Äôs a bit weird he doesn‚Äôt have any examples of retrieving via key, don‚Äôt you think?
07:44:03 <pavonia> Yeah, examples would be good, especially as this whole module awfully complicated :)
07:44:12 <pavonia> +is
07:45:12 <julianleviston> pavonia: everything else seems to have examples, actually‚Ä¶ well some.
07:45:35 <julianleviston> pavonia:  I guess that‚Äôs one of the problems with Haskell - you don‚Äôt get to use magic without understanding it first hehe ;-)
07:45:46 <julianleviston> pavonia: more a feature tho if you ask me :)
07:46:09 <quicksilver> groundhog uses particularly advanced type tricks
07:46:21 <quicksilver> compared even to the 'average' module on hackage
07:46:38 <julianleviston> quicksilver: yeah I figured when I saw the type that was defined as * -> *‚Ä¶ I was like‚Ä¶ hmmm that‚Äôs a kind‚Ä¶ what the?
07:46:50 <julianleviston> quicksilver:  this one: data Key v :: * -> *
07:47:04 <julianleviston> quicksilver: what does that one mean?
07:47:06 <ski> it's a kind signature for the type
07:47:15 <quicksilver> well * -> * is not so mysterious on its own
07:47:17 <julianleviston> ski: yeah, I figured‚Ä¶ 
07:47:19 <quicksilver> it's just something like 'Maybe'
07:47:27 <julianleviston> quicksilver:  yup
07:47:30 <ski> it means that `Key v' will have kind `* -> *', and since `v' has kind `*' here, it means the kind of `Key' is `* -> * -> *'
07:47:37 <quicksilver> but the thing about Key is it is a type family a.k.a associated type
07:47:56 <julianleviston> ski: how did you work out that v has kind *  there?
07:47:58 <quicksilver> so it's not a normal type constructor - rather it signals a way to calculate some type from some other type(s)
07:48:05 <ski> julianleviston : `entityDef :: DbDescriptor db => proxy db -> v -> EntityDef
07:48:08 <ski> ' is a method of the class
07:48:46 <julianleviston> ski: but‚Ä¶ that‚Äôs in a different type definition isn‚Äôt it?
07:49:44 <ski> julianleviston : when you make an instance `instance PersistEntity T where ...' you have to define `Key T', like `data Key T u = ..u..' or `newtype Key T u = ..u..'
07:50:09 <ski> julianleviston : doesn't matter. it's the same `v' in the whole class declaration for `PersistEntity v'
07:50:25 <julianleviston> ski: yeah, I was just wondering how you knew it was the same v, is all.
07:50:57 <ski> type variables in the head of the class declaration scope of the whole signature body of the class
07:51:08 <julianleviston> ski: oh‚Ä¶ it‚Äôs at the top - it‚Äôs all under class. Ok. :)
07:51:16 <julianleviston> ski: that was the answer I was after by the way :)
07:51:24 <julianleviston> ski: thanks :)
07:51:32 <ski> s/scope of/scope over/
07:52:04 <julianleviston> ski: sorry I hadn‚Äôt realised the whole thing was in a class definition.
07:52:15 <ski> this is an associated type
07:52:25 <ski> you're not defining `Key' once and for all
07:52:39 <ski> you're making a separate definition of `Key v', for each `v' you make an instance of the class
07:52:52 <julianleviston> ski: that tiny bit of knowledge actually makes reading these documents much easier now! thanks.
07:52:56 <ski> (above i used `T' instead of `v' to indicate any concrete type you decide to make an instance of the class)
07:53:00 <ggVGc> I just learnt a bit more about records in haskell, and how the implementation is a bit weird, with lack of namespacing. What is the background to that?
07:53:04 <julianleviston> ski: cool :)
07:53:08 <ggVGc> everyone seems to think it's a major flaw
07:53:39 <ski> the signature for `Key' has to be `Key v :: * -> *'. it can't be `Key :: * -> * -> *' or `Key v u :: *'
07:53:40 <julianleviston> ggVGc: what do you want to know?
07:53:56 <julianleviston> ggVGc: why accessor functions aren‚Äôt namespaced? or?
07:53:59 <ggVGc> julianleviston: well, why isn't there namespacing in the first place?
07:54:07 <ggVGc> yeah, that seems to be the main issue?
07:55:02 <ski> if we're just thinking about kinds, any of these would conceptually do. but for any specific `v' we make an instance of the class, we have to make a definition of `Key v' of kind `* -> *', iow `Key v u' working for *every* `u' (of kind `*'), for this specific `v'
07:55:05 <jophish> /quit
07:55:09 <ggVGc> julianleviston: I read this just now, and the second flaw he lists seems very bad in a strongly typed language like haskell, http://nikita-volkov.github.io/record/
07:55:18 * ski . o O ( that's a new one .. )
07:55:52 <julianleviston> ski: wow‚Ä¶ ok
07:55:53 <quicksilver> ggVGc: records were something of an afterthought and they preferred no namespacing to some adhoc namespacing I suspect.
07:56:01 <ski> julianleviston ?
07:56:07 <quicksilver> 20 years later people are still arguing what the best way to do it was.
07:56:10 <julianleviston> ski: a little beyond me
07:56:58 <quicksilver> ggVGc: it's very unusual to see record notation used for data types with multiple alternatives like (2) in that blog post.
07:57:04 <ggVGc> ah, alright
07:57:06 <ski> they decided to make field access an ordinary function. as such, it's in the same namespace as anything else
07:57:08 <quicksilver> ggVGc: in fact I don't think I have *ever* see anyone use that feature.
07:57:15 <ggVGc> I haven't written much haskell yet, so that seemed like a fairly big issue to me
07:57:16 <ski> (at least without some more or less ad hoc overloading)
07:57:32 <quicksilver> I've written lots of haskell and I don't consider it an issue at all :)
07:57:34 <quicksilver> FSOV lots.
07:57:48 <ggVGc> quicksilver: still seems a little bit flawed to have record access like that cause runtime exceptions
07:57:49 <julianleviston> ggVGc: lens solves a lot of these issues.
07:58:05 <ggVGc> cool, I haven't looked at lens yet. Still too early for me
07:58:07 <quicksilver> ggVGc: lots of things in haskell cause runtime exceptions
07:58:12 <quicksilver> > fromJust Nothing
07:58:14 <lambdabot>  *Exception: Maybe.fromJust: Nothing
07:58:17 <quicksilver> > head []
07:58:19 <lambdabot>  *Exception: Prelude.head: empty list
07:58:25 <julianleviston> ggVGc: I get the impression you‚Äôre premature-worrying a little.
07:58:34 <ggVGc> not really worrying, just being interested
07:58:41 <ggVGc> anyway, thanks for the info
07:58:44 <clrnd> GHC8 will address some issues w/records
07:59:24 <julianleviston> ggVGc: that wasn‚Äôt a criticism.
07:59:43 <julianleviston> ggVGc: just saying maybe it won‚Äôt be such a problem later, is all.
08:00:09 <julianleviston> ggVGc: or‚Ä¶ it might not be*
08:00:35 <julianleviston> clrnd: what will GHC8 do for records?
08:02:01 <clrnd> https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields <- julianleviston 
08:02:09 <julianleviston> clrnd: ta
08:02:41 <julianleviston> clrnd: nice :)
08:03:15 * clrnd stills hopes for -XAutoLensEverything :P
08:03:19 <alexv19> Is there such thing as "reversable map" where keys are unique and values are also unique?
08:03:59 <julianleviston> alexv19: isn‚Äôt that a set?
08:04:06 <julianleviston> alexv19: maybe not.
08:04:08 <exio4> alexv19: bimap? 
08:04:14 <ski> ggVGc : i don't like "Field names are represented not by definitions, but by type level values, and as such they have no namespace and hence the problem of collisions simply does not pertain to them."
08:04:25 <quicksilver> ski: I read that sentence 4 times myself
08:04:53 <quicksilver> I think he means they are type level expressions (type level terms)
08:05:02 <quicksilver> and as such don't have names, per se
08:05:03 <ski> (tbh, i don't like the present system here either. imho, one should be able to rename field names at import (and export, for symmetry))
08:05:11 <ski> quicksilver : i know
08:05:12 <quicksilver> yes! what ski said.
08:05:25 <quicksilver> proper renaming at import and export
08:05:34 <julianleviston> Hm‚Ä¶ so ski, do you know how I might go about constructing a value for my CustomerKey ?
08:05:35 <quicksilver> including the ability to re-export with arbitrary qualification.
08:06:21 <alexv19> exio4: looks like it, thanks
08:07:00 <clinton> is there anyway to force Hackage to attempt a build?
08:07:08 * ski tries to recall what `CustomerKey' is
08:07:10 <quicksilver> the fact that the GHC8 approach is baked on top of implicits scares me
08:07:19 <quicksilver> because implicits were really nasty
08:07:21 <clinton> I want to check if a candidate package is building correctly on hackage
08:07:28 <quicksilver> but perhaps it will be nicer when I see it working.
08:07:45 <julianleviston> ski: CustomerKey :: Database.Groundhog.Core.PersistValue -> Key Customer BackendSpecific
08:08:08 <ski> julianleviston : is that from your definition of `Key Customer' or what ?
08:08:12 <osa1> too bad I have to add a huge exports list just to hide one name...
08:08:28 <julianleviston> ski: um‚Ä¶ it‚Äôs done in TH, but basically yes.
08:08:37 <ski> osa1 : `import Blah hiding (foo)' ?
08:08:40 <julianleviston> ski: it‚Äôs from GHCi, querying CustomerKey
08:08:45 <ski> .. oh, export list
08:09:24 <ski> i suppose you have to create a `PersistValue', however one would do that in this library
08:11:11 <ski> osa1 : .. fwiw, i think it would possibly be considered a bad idea to be able to say "export everything except this"
08:11:21 <Denommus> hi
08:11:34 <julianleviston> ski: mmm ok :)
08:11:52 <julianleviston> ski: there are a couple of helper functions for that, but pretty confusing.
08:11:54 <Denommus> does anyone have an idiomatic version of A*?
08:12:52 <Jello_Raptor_> So, I need a monadic list unfold, where I can control when the next element of the list is generated (only way to handle infinite lists in a monadic context reasonably), and I'm torn between representing them as "forall b. (b,b -> m (Maybe (a,b)))" and "type Foo f a = m ( Maybe (a,f)); Fix Foo" I'm not sure which is more reasonable or even what the tradeoffs are.  
08:12:56 <julianleviston> ski: I‚Äôll look thru the examples. thanks.
08:16:16 <ski> i assume you mean more or less `newtype Foo m a = MkFoo (m (Maybe (a,Foo m a)))' for the latter
08:16:45 <Jello_Raptor_> ski: that is a much more reasonable way of writing it :P 
08:16:57 <ski> and for the former, i believe you meant s/forall/exists/
08:16:59 <julianleviston> ski: sadly none of the examples have that :) 
08:17:23 <ski> they are equivalent
08:17:35 <Jello_Raptor_> ski: well, using the forall wrapper trick, but yes 
08:18:07 <ski> (`data Bar m a = MkBar (forall b. (b,b -> m (Maybe (a,b))))' is something completely different)
08:19:00 <Jello_Raptor_> ski: yeah, I mean a constructor of type "forall b. (b, b -> m (Maybe (a,b)) -> Foo m a " 
08:20:05 <ski> in general, the former form can be more general. i suppose you might call the former form the ADT one, and the latter the OO one
08:20:18 <ski> Jello_Raptor_ : *nod*
08:20:47 <ski> *maybe* the former form could be more amenable to some kind of fusion. i'm not sure
08:21:01 <Jello_Raptor_> ski: fusion? 
08:21:31 <ski> merging several loop pipelines into a single one
08:22:42 <ski> i'd probably try using the simpler (?) latter one, and possibly switch if i found a reason to do so
08:24:16 <ski> (btw, i've sometimes named it like `newtype List f a = MkList (f (ListCell f a)); data ListCell f a = Nil | Cons a (List f a)' .. `f' could be `IORef' or `Maybe' or `IO' or ...)
08:25:27 <Zemyla> Why isn't there a conduit library tutorial called "You Conduit!"?
08:25:56 <ski> (perhaps you're the chosen one, the conduit, of that idea ?)
08:28:17 * hackagebot persistent-template 2.1.4 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.1.4 (GregWeber)
08:28:19 * hackagebot persistent 2.2.2 - Type-safe, multi-backend data serialization.  https://hackage.haskell.org/package/persistent-2.2.2 (GregWeber)
08:28:19 <ggVGc> is it just me, or do haskell libraries generally have very little documentation, and often no github pages?
08:28:21 * hackagebot persistent-mongoDB 2.1.4 - Backend for the persistent library using mongoDB.  https://hackage.haskell.org/package/persistent-mongoDB-2.1.4 (GregWeber)
08:29:05 <quicksilver> ggVGc: I would not generalise in that way.
08:29:17 <tdammers> ggVGc: many packages on hackage are kind of experimental
08:29:17 <quicksilver> ggVGc: some libraries are very well documented; some not at all. Some have github pages; some do not.
08:29:34 <quicksilver> there's certianly some examples of entirely undocumented stuff which leaves you scratching your head
08:29:52 <tdammers> putting stuff on hackage is very low-threshold, so not everything you see there is ready for prime time
08:30:01 <tdammers> but the more serious libs are usually pretty well documented
08:30:28 <tdammers> as for github; *some* source repository is usually provided, but github isn't everyone's preference
08:30:46 <tdammers> (personally, I kind of dislike the github way of doing collaboration(
08:30:51 <julianleviston> :t (@=?)
08:30:52 <lambdabot> Not in scope: ‚Äò@=?‚Äô
08:32:22 <julianleviston> ggVGc: the documentation is different than what you‚Äôre used to with other languages, possibly, because the types explain a lot of what‚Äôs going on.
08:33:40 <quicksilver> my biggest gripe of haskell library documentaiton is when they hide important bits of functionality in type class instances
08:33:43 <quicksilver> and don't point this out :P
08:34:24 <quicksilver> although it bites me less often than it used to, now I know what to look for. (Apparently no way to join two of these things together to make a bigger one - look for a Monoid instance!)
08:34:32 <julianleviston> quicksilver: mostly I spend about 99% of my time trying to work out what things do. People have often pointed out this is a lack in me, not the documentation.
08:35:46 <julianleviston> quicksilver: it‚Äôs a decidedly unhelpful language unless you know what you‚Äôre doing.
08:36:17 <julianleviston> quicksilver:  thank god all you guys are so helpful in here! :)
08:36:21 <Zemyla> Also, is there a counterpart to ArrowApply in Profunctors?
08:37:15 <quicksilver> I think it's a much more helpful language than you suggest and you've chosen an uphill path
08:37:41 <quicksilver> the ability to check types and browse modules in GHCi is great
08:37:58 <julianleviston> quicksilver:  you‚Äôre correct, but I was allowing for that.
08:38:36 <julianleviston> quicksilver: I really miss being able to go into a REPL and muck around with things. If something‚Äôs in a monad, it makes it almost impossible to work out what‚Äôs going on‚Ä¶ 
08:38:46 <julianleviston> quicksilver: but as I said, this is just a lack in me, no doubt.
08:38:48 <Denommus> any way I could improve this algorithm? https://gist.github.com/Denommus/f4c85875078f7e8e2d7a
08:41:25 <quicksilver> julianleviston: I don't find monads in general any obstacle to mucking around in a REPL
08:41:39 <quicksilver> you know you can run the IO monad just fine in ghci?
08:41:47 <quicksilver> which monad was giving you trouble interactively?
08:41:52 <julianleviston> quicksilver: ghci *is* in the IO monad, isn‚Äôt it?
08:42:23 <quicksilver> yes
08:42:43 <quicksilver> or Im' not sure whether or not that is really precisely true
08:42:47 <quicksilver> but it pretends to be
08:42:54 <quicksilver> and it pretends well enough for most purposes
08:43:29 <julianleviston> quicksilver: In Haskell, as you know, you specify your context always.
08:43:55 * hackagebot pathwalk 0.2.0.0 - Path walking utilities for Haskell programs  https://hackage.haskell.org/package/pathwalk-0.2.0.0 (Xena)
08:44:12 <julianleviston> quicksilver: so, say you‚Äôre writing a function that does something in do notation inside the Maybe monad‚Ä¶
08:44:13 <quicksilver> Denommus: well that's a relatively slow way to find your next nearest, the 'traditional' implementation keeps the costs in a priority queue so the cheapest is always to hand
08:45:58 <julianleviston> quicksilver: what I‚Äôd usually like to do (in other languages where the context is less specified) is be able to try out some of the code *within* that do block just at the top level in a REPL‚Ä¶ but I can‚Äôt do that here, because I‚Äôm not in that context.
08:46:19 <julianleviston> quicksilver: what I end up having to do is do a :r loop‚Ä¶ changing source, :r, change source, :r, and so on...
08:46:26 <bitemyapp> julianleviston: the REPL is itself a do block
08:46:34 <julianleviston> bitemyapp: yeah, I know.
08:46:58 <bitemyapp> julianleviston: there's a debugger, but I find it's better to factor out sub-functions such that I can call them in the REPL.
08:46:58 <julianleviston> bitemyapp: bit surprised you don‚Äôt know I know that ;-)
08:47:05 <bitemyapp> you never know.
08:47:10 <julianleviston> bitemyapp: all good.
08:47:13 <bitemyapp> figuratively speaking. lol.
08:47:18 <m1dnight_> Im using a statemonad in an evaluator/typechecker and Im wondering if it is possible to run a computation and discard the environment?
08:47:29 <julianleviston> bitemyapp: yeah, I agree with you. I‚Äôm explaining this for quicksivler to understand what I was saying before.
08:47:44 <clrnd> m1dnight_, evalState/runState/execState
08:48:12 <m1dnight_> ah okay I see
08:48:14 <m1dnight_> thanks clrnd 
08:48:49 <julianleviston> quicksilver: I don‚Äôt want you to think I‚Äôm having a whine or anything. I‚Äôm really not. Haskell brings so much more amazing stuff to the table that this is a minor inconvenience. I‚Äôm not sure how one could ‚Äúget aorund this‚Äù, really‚Ä¶ but I *do* miss that way of programming. It was very very fast.
08:50:38 <quicksilver> julianleviston: ok your point isn't actually about do blocks
08:50:48 <julianleviston> quicksilver:  not per se.
08:50:50 <quicksilver> julianleviston: it's just about context
08:50:56 <julianleviston> quicksilver: it‚Äôs about context.
08:50:58 <julianleviston> quicksilver: yeah
08:51:04 <quicksilver> yes, I agree, sometimes you wish you could 'just run a statement in context'
08:51:09 <quicksilver> but actually that doesn't mean anything
08:51:22 <julianleviston> quicksilver:  yep.
08:51:22 <quicksilver> you might imagine a context like a piece of imperative code
08:51:25 <quicksilver> but that's just an analogy
08:51:29 <julianleviston> quicksilver: yep.
08:51:30 <quicksilver> actually it can be anything :)
08:51:50 <quicksilver> so, yes, I have felt that. Sometimes I do wish I could 'just try that in context'
08:52:05 <julianleviston> quicksilver: having said that, it‚Äôd be possible to ‚Äúbuild a dummy context‚Äù with example data you put in‚Ä¶ :)
08:52:25 <quicksilver> only sometimes is that possible
08:52:38 <quicksilver> and exactlly what 'build a dummy context' means is entirely case by case
08:52:42 <julianleviston> quicksilver: kind of like quickcheck sort of
08:52:45 <quicksilver> you can be talking about local variables
08:52:52 <quicksilver> you can be talking about the partial traversal of a data structure
08:53:16 <quicksilver> you can be talking about one value in the middle of an operator expression (what does that even mean?)
08:53:39 <quicksilver> someone with the time could certainly play with these ideas and see which cases they can make work.
08:53:43 <julianleviston> quicksilver: it has a meaning with respect to a certain set of values, I think.
08:54:19 <quicksilver> consider a combinator language for building up pictures
08:54:30 <quicksilver> "a context" includes the partially built-up picture so far
08:54:42 <julianleviston> quicksilver: there‚Äôs also another ‚Äúside effect‚Äù (pardon the pun) of having the context always specified, and that is that in other languages I could actually kind of write my code in the REPL and then pull it out and stuff it in my text editor, and reload the whole file back into the repl and go on this kind of back and forth.
08:54:52 <quicksilver> in practice though end up where bitemyapp was
08:55:05 <quicksilver> "factor out sub-functions such that I can call them in the REPL"
08:55:10 <quicksilver> which has many many benefits
08:55:11 <julianleviston> quicksilver: sure.
08:55:14 <quicksilver> easier for exploration
08:55:16 <julianleviston> quicksilver: I completely agree
08:55:17 <quicksilver> easier for testing
08:55:19 <quicksilver> easier for composability
08:56:13 <julianleviston> quicksilver: except in the case where you end up with naming problems.
08:59:08 <quicksilver> I name all my problems.
08:59:45 <inad922> If I have an array 'xs' and an element 'x' and I do "let a = x:xs" it is an O(1) operation since haskell lists are linked lists? Or am I wrong here?
09:00:01 <exio4> if that is true then xs wasn't an array but a list
09:00:15 <fizruk> :t (:)
09:00:17 <lambdabot> a -> [a] -> [a]
09:00:23 <julianleviston> inad922: [] means list, not array.
09:00:26 <exio4> inad922: it's true because (:) is a constructor, too
09:00:44 <inad922> julianleviston, ah list yes
09:00:56 <julianleviston> inad922: they‚Äôre quite different things.
09:00:59 <magneticduck> haskell lists are absolutely not linked lists
09:01:19 <julianleviston> magneticduck:  aren‚Äôt they singly linked lists???
09:01:20 <quicksilver> it's also true because "let a = x:xs" doesn't actually do anything. This remark may not be very helpful though.
09:01:55 <Welkin> yes, they are singly linked lists
09:01:57 <inad922> magneticduck, What are they then?
09:02:29 <magneticduck> IanMalcolm: recursive GADTs, from inside the language
09:02:31 <magneticduck> oops
09:02:38 <magneticduck> inad922: *
09:03:15 <bernalex> is the write yourself a scheme book considered good?
09:03:17 <Welkin> data List a = Nil | Cons (List a)
09:03:32 <julianleviston> magneticduck: how is that not a singly linked list?
09:03:36 <magneticduck> uh
09:03:37 <Welkin> a single link from one element to the next
09:03:47 <magneticduck> my definition of a linked list is https://en.wikipedia.org/wiki/Linked_list implemented with pointers
09:03:56 <Welkin> it doesn't matter how you implement it
09:04:12 <julianleviston> magneticduck: besides which, it ends up as pointers anyway doesn‚Äôt it?
09:04:12 <magneticduck> the keyword here for me is 'linked'
09:04:41 <magneticduck> uh I actually don't think so
09:04:59 <ggVGc> wow... lens looks amazing actually
09:05:06 <quicksilver> lens is amazing ggVGc 
09:05:15 <magneticduck> there isn't a 1-to-1 between haskell thunks / expressions and positions in memory, I don't think
09:05:21 <quicksilver> it unifies so many useful things under one consistent set of ideas
09:05:24 <roelof> how can I test with QuickCheck that a answer is approximelty for example zero ? 
09:05:26 <magneticduck> I mean, uh, if that makes any sense
09:05:32 <ski> magneticduck : GADTs ?
09:05:34 <ggVGc> funny, I hve been thinking in the concepts that lens implement in other languages, and even done toy implementations of it
09:05:40 <ggVGc> so it makes a lot of sense to me
09:05:46 <kazagistar> Really, it should be `data List a = Nil | (:) a (List a)` but that does not actually work, because lists use magic unavailable to the rest of the language
09:06:01 <Welkin> yeah, I forgot the extra a
09:06:02 <Welkin> haha
09:06:25 <ggVGc> quicksilver: I'm reading this to get an initial idea, looks great so far, https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
09:06:30 <magneticduck> kazagistar: I'm like 99% sure you can define ':' as a synonym for a data constructor and then not export that data constructor
09:06:40 <magneticduck> list syntatic sugar is obviously magic, but the : isn't
09:06:47 <inad922> magicman, What's a GADT?
09:06:54 <quicksilver> magneticduck: you are mistaken
09:06:59 <magneticduck> huh okay
09:07:07 <quicksilver> (:) is magic
09:07:07 <kazagistar> magneticduck: can you pattern match on the synonym?
09:07:09 <julianleviston> inad922: you don‚Äôt need to know about this yet‚Ä¶ probably.
09:07:13 <magneticduck> oh right
09:07:14 <ski> magneticduck : GADTs are irrelevant here
09:07:18 <inad922> julianleviston, Ah ok
09:07:27 <julianleviston> inad922: have you done abstract data types yet?
09:07:31 <inad922> Is it somewhat equivalent to linked lists?
09:07:37 <ggVGc> I also don't really understand what GADTs are, but I have apparently used then
09:07:39 <inad922> julianleviston, Yep, sure
09:07:39 <julianleviston> inad922: algebraic data types, sorry (guh)
09:07:39 <ggVGc> them*
09:07:59 <quicksilver> inad922: I am quite happy saying that [a] is a singly linked list
09:08:09 <julianleviston> inad922: ah ok‚Ä¶ Generalised Algebraic Data Type = GADT
09:08:16 <quicksilver> there is, admittedly, a difference between specification and implementation and compilation etc
09:08:40 <quicksilver> but even people doing purely theoretic constructs use phrases like 'singly-linked' for things like [a]
09:08:45 <magneticduck> I love being pedantic on the internet about things I'm not an expert in!
09:09:17 <kazagistar> [a] is a singly linked list in a strict evaluation context, but often in haskell it works more like an iterator
09:09:21 <quicksilver> magneticduck: is has often been observed that the best way to get a clear answer on the internet is not to ask your question, but to state an incorrect answer and wait for the corrections :(
09:09:29 <inad922> quicksilver, Thanks. I just wanted to sort this out. I build a shortest route by adding the first element back from a prev map
09:09:37 <inad922> Should be a prev vector
09:09:42 <quicksilver> magneticduck: fortunately, haskell is not much like this as a rule.
09:09:46 <inad922> it just getting too complicated for what it is
09:09:59 <magneticduck> inad922: welcome to haskell
09:10:08 <julianleviston> magneticduck: that‚Äôs not fair
09:10:10 <quicksilver> inad922: yes, [a] gives you a simple O(1) append which is great for incrementally building up a path
09:10:14 <magneticduck> well it's kind of fair
09:10:24 <magneticduck> it's an efficent and concise language
09:10:28 <inad922> magneticduck, :)
09:10:34 <julianleviston> magneticduck: Haskell isn‚Äôt any more or less complicated, it just shows you what‚Äôs going on.
09:10:36 <roelof> no QuickCheck experts here ? 
09:10:38 <magneticduck> but at the same time it makes you want to generalise everything
09:10:40 <quicksilver> inad922: also, if your version returns *all* the shortest paths to all places, then what's cute is that in memory they will be sharing all their subsequences.
09:10:49 <kazagistar> I would say "welcome to programming"
09:10:49 <roelof> ski:  long time no see 
09:10:49 <magneticduck> julianleviston: I'm not saying it's complicated to just do things in haskell
09:11:11 <kazagistar> but that is kinda condescending so I wont <_<
09:11:27 <inad922> What I don't understand is if Data.Map has a function like findWithDefault which drops you a default if the element is not in the map then why can't Data.Heap have a similar version of it's head viewer function?
09:11:29 <magneticduck> I'm saying haskell makes you want to generalise things and learn about structures like lenses and conduits
09:11:57 <inad922> I come from the python world so it's kind of normal for me drop drop a default value for an element if the index is not in the data structure
09:12:03 <inad922> Have to get used to the Maybes I guess
09:12:13 <clrnd> inad922, just a design choice, make a pull request :)
09:12:32 <kazagistar> causality might be backwards‚Ä¶ I get those urges even in Java, but Haskell lets me over-abstract things, and draws me because I can satisfy those urges :P
09:12:36 <quicksilver> inad922: it could, but Maybes are so easy to work with
09:12:47 <quicksilver> inad922: just patch "fromMaybe <yourdefault>" on the front
09:12:49 <inad922> quicksilver, Ah not all shortest paths. That would be too much with K_n and equal edge weights for example
09:12:49 <exio4> inad922: also, if you want a findWithDefault, it's quite easy to do fromMaybe "abc" (M.lookup ..) 
09:12:52 <clrnd> :t maybe
09:12:53 <lambdabot> b -> (a -> b) -> Maybe a -> b
09:12:58 <exio4> @type fromMaybe
09:13:00 <lambdabot> a -> Maybe a -> a
09:13:15 <inad922> clrnd, Haha. Yeah I'm a bit far from that level I guess
09:13:42 <loooooopppppp> Has anyone here used cycle framework for reactive development?
09:13:47 <inad922> exio4, Yea I did a fromMaybe with a typeclass
09:14:09 <quicksilver> inad922: a lazy dijkstra can, for example, return the cheapest paths to all points (cheapest first) but only *actuall* do the work for the ones you inspect
09:14:18 <inad922> exio4, Like this -> http://stackoverflow.com/a/4941529/1514476
09:14:21 <quicksilver> inad922: so if you only inspect the first element, that's all you compute
09:14:32 <quicksilver> inad922: if you only inspect "elements up to cost 10" then that's all you compute.
09:14:33 <roelof> how can I test with QuickCheck that a answer is approximelty for example zero ? 
09:14:37 <quicksilver> laziness is nice sometimes.
09:14:54 <inad922> quicksilver, So it would basically be a generator for shortest paths more or less?
09:14:59 <KaneTW> roelof: define approximately
09:15:06 <kazagistar> roelof: only if you define approximately
09:15:07 <quicksilver> inad922: haskell lists are automatically generators - sort of.
09:15:45 <quicksilver> that is, if you write your code in a way which produces the first element without doing all the work.
09:16:07 <jle`> > take 3 [1..]
09:16:09 <lambdabot>  [1,2,3]
09:16:09 <magneticduck> roelof: I assume you mean < epsilon
09:16:13 <exio4> inad922: I don't really like that approach, but sure
09:16:20 <magneticduck> in which case, you test just like you'd do for anything else
09:16:26 <inad922> quicksilver, Hmm ok I guess I could modify my code like that.
09:16:29 <roelof> KaneTW:  I have a function that calculates a outcome of a function with floats. So if I put the answer back in the function the orginal answer must be back 
09:16:38 <inad922> exio4, What's wrong with that approach?
09:17:07 <kazagistar> quicksilver, inad922: and they lose their generator status if you use them many times in a way that cannot be fused out
09:17:08 <exio4> inad922: it's using overlapping instances, and there are no "laws" or nothing to define what should be a reasonable empty value?
09:17:12 <roelof> but because I use floats I can be that the answer which is coming back is not exact the outcome 
09:17:14 <KaneTW> @check \x -> let f x = 1/x in x == 0 || x == f (f x) 
09:17:16 <lambdabot>  *** Failed! Falsifiable (after 7 tests and 1034 shrinks):
09:17:16 <lambdabot>  -12.67999368404124
09:17:20 <KaneTW> yup
09:17:42 <quicksilver> inad922: you don't necessarily need to, your way may be better for what you're doing - I just thought it was an interesting observation.
09:17:49 <roelof> so I  have to check if the answers are almost the same 
09:17:51 <inad922> exio4, Yeah I agree. I mean it's totally up to me what the empty value is
09:18:25 <KaneTW> @let epsilon = encodeFloat 1 (fromIntegral $ 1-floatDigits epsilon)
09:18:26 <lambdabot>  Defined.
09:18:35 <KaneTW> @check \x -> let f x = 1/x in x == 0 || x - f (f x) <= epsilon
09:18:37 <lambdabot>  *** Failed! Falsifiable (after 19 tests and 15 shrinks):
09:18:37 <lambdabot>  15.268923438622867
09:18:37 <inad922> quicksilver, I just wanted to play around with the standard library and the concepts in the language. shortests paths seemed like a simple enough problem
09:18:40 <KaneTW> hm
09:18:52 <KaneTW> abs around it, forgot
09:19:12 <KaneTW> @check \x -> let f x = 1/x in x == 0 || abs (x - f (f x)) <= epsilon
09:19:15 <lambdabot>  *** Failed! Falsifiable (after 14 tests and 8 shrinks):
09:19:15 <lambdabot>  7.200333162140415
09:19:17 <KaneTW> well
09:19:19 <KaneTW> ok
09:19:28 <lpaste> JulianLeviston pasted ‚Äúcan anyone help with this? (Groundhog Question)‚Äù at http://lpaste.net/143377
09:19:34 <KaneTW> it's not a very numerically stable function
09:19:40 <KaneTW> so you might have to pick a larger epsilon
09:19:46 <inad922> I wrote a graph parser and a shortest path in both python and Haskell and Python with 74 and 49 lines respectively. I think it's not that bad of a ratio considering that I'm a complete beginner in haskell
09:20:38 <roelof> I think I will try to find a better book then Crafts. Second exercise where a quickCheck check cannot be made easily 
09:20:42 <inad922> but actually I learned a bit about some of the modules so it was good
09:21:22 <inad922> Thanks for all the help for quicksilver, julianleviston, exio4 and whoever else answered my questions :) 
09:21:35 <inad922> I have to go now. Be back later with some more questions
09:23:56 * hackagebot hyperloglog 0.4.0.2 - An approximate streaming (constant space) unique object counter  https://hackage.haskell.org/package/hyperloglog-0.4.0.2 (EdwardKmett)
09:30:10 <MarcelineVQ> poor freenode
09:30:36 * bitemyapp pats freenode on the head
09:33:24 <julianleviston> oh god. I just realised the problem. I was missing an import
09:33:31 * julianleviston slaps himself about the head with a Fish
09:40:02 <julianleviston> ah I spoke too soon.
10:02:50 <SrPx> Is it possible to compile a ReadP expression to a JavaScript parser?
10:06:47 <KaneTW> bitemyapp: are you around?
10:10:20 <Cale> SrPx: you mean using GHCJS?
10:10:35 <Cale> SrPx: Or you mean, is it possible to write a Javascript parser using ReadP?
10:11:32 <bitemyapp> KaneTW: what can I do for you?
10:11:41 <Cale> It is certainly possible, but a better use of your time would be to use one of the existing Javascript parsers most likely. http://hackage.haskell.org/package/language-javascript
10:12:46 <SrPx> Cale: I read somewhere but my mind is failing on me, that you could derive JS actual parsers automatically from ReadP
10:13:09 <Cale> I'm confused about what you're looking for...
10:13:25 <Cale> You want a parser for Javascript syntax written using the ReadP library?
10:13:43 <SrPx> Wait, I don't want to parse JS. I want to write a parser in Haskell (for something arbitrary) and derive a JS source code that will parse it and return a JS json. 
10:13:58 <SrPx> Yes, sorry it it is silly, I just recalled reading that was possible.
10:14:24 <Cale> Sure, you can do that using GHCJS
10:14:51 <Cale> I have no idea how the foreign export side of things works in GHCJS though.
10:15:05 <SrPx> I remember GHCJS wasn't used... but well I might be dreaming
10:15:16 <KaneTW> bitemyapp: i'm going to be teaching a workshop-esque haskell class and i'm wondering if you know some course materials i could use as a reference
10:15:30 <KaneTW> cs240h looks similar to the format i'm going for
10:15:46 <Cale> SrPx: There is nothing about ReadP which has anything to do with Javascript
10:16:04 <Cale> SrPx: It's an ordinary pure Haskell library, and it's pretty simple.
10:16:26 <KaneTW> participants have *some* exposure to haskell, so i'm probably going to be starting with typeclasses
10:16:55 <SrPx> Cale: I know! I swear I remember thinking exactly that when I saw it could generate JS code. Dunno where I took that from, sorry
10:17:27 <Cale> SrPx: I don't know where you would have seen this.
10:17:36 * SrPx shrugs
10:18:28 <Cale> SrPx: But for instance, someone using reflex-dom to build a web frontend in Haskell could seamlessly use ReadP to parse things, and their whole program would get compiled to Javascript in the end.
10:19:13 <Cale> SrPx: We use aeson in both the frontend and backend of our web application to parse and generate JSON.
10:19:32 <bitemyapp> KaneTW: cis194, basically.
10:19:37 <bitemyapp> KaneTW: I've started on open-cis194
10:19:46 <bitemyapp> KaneTW: I got permission from Yorgey for that initiative.
10:19:58 <bitemyapp> KaneTW: there's some rote work to be done, would you be up for helping me out with it?
10:20:21 <bitemyapp> KaneTW: getting it converted to vanilla Hakyll, porting the lhs to plain markdown right now: https://github.com/bitemyapp/open-cis194/tree/fuck-it
10:20:29 <SrPx> Cale: I just wanted to complete the (controversial) http://github.com/maiavictor/ljson repository because it feels incomplete without a parser, but I don't have the courage to write a JS parser from scratch right now
10:20:31 <bitemyapp> KaneTW: I use pandoc, then strip the .literate tag from the code blocks.
10:20:47 <SrPx> I guess I'll just leave it for another day
10:21:35 <KaneTW> bitemyapp: i'll take a look
10:21:59 <bitemyapp> KaneTW: if you don't have time to pitch in with open-cis194, then the recommendation is what's on the guide.
10:22:08 <bitemyapp> KaneTW: basically, a guided walkthrough of cis194 material.
10:22:11 <bitemyapp> @where learnhaskell
10:22:11 <lambdabot> https://github.com/bitemyapp/learnhaskell
10:22:25 <bitemyapp> KaneTW: naturally I'd like it if you considered using our book, but I was assuming free material was necessary.
10:22:28 <bitemyapp> @where book
10:22:28 <lambdabot> http://haskellbook.com/
10:22:42 <bitemyapp> KaneTW: I'm teaching another class for our Haskell meetup this month, I'll be using open-cis194.
10:23:07 <KaneTW> i'd prefer free material since this is just a personally organized course
10:23:36 <KaneTW> i'll probably put in your book as a literature reference though since it seems pretty nice
10:23:56 <bitemyapp> KaneTW: <3
10:24:17 <bitemyapp> KaneTW: it's not just self-interest, if they want to keep self-learning w/ Haskell, the book is going to be better than cis194.
10:24:37 <bitemyapp> KaneTW: this is at a school or independent?
10:26:02 <KaneTW> at a school but i'm just organizing this myself because the only exposure to haskell that people have here is at the intro to programming course and then a bi-yearly functional programming course that goes more into theory
10:26:47 <suppi> sounds like a fun school
10:28:32 <KaneTW> it's a german school so there isn't a whole lot of choice and programming language theory is rather weak here in general
10:28:58 <bitemyapp> KaneTW: how much time will you have with them?
10:29:29 * hackagebot nanomsg-haskell 0.2.3 - Bindings to the nanomsg library  https://hackage.haskell.org/package/nanomsg-haskell-0.2.3 (IvarNymoen)
10:29:48 <KaneTW> i'm going for 90min/week
10:29:54 <bitemyapp> KaneTW: how many weeks?
10:30:06 <bitemyapp> sorry I don't know anything about how german schools work.
10:30:09 <KaneTW> oh
10:30:29 <bitemyapp> KaneTW: also when would this start?
10:30:43 <KaneTW> i don't think there's an upper bound, so whatever fits best to teach the material. exams start around february and i plan to start this mid-november
10:30:49 <KaneTW> regular classes start this week
10:30:58 <bitemyapp> KaneTW: may I query you?
10:31:00 <KaneTW> sure
10:33:45 <suppi> KaneTW, what is your goal for the course?
10:36:03 <KaneTW> suppi: basically i want to make my students comfortable enough with haskell that they can program actual applications in it
10:41:07 <suppi> KaneTW, cool. an approach you can take is think about a few candidate final projects you want your students to be able to do
10:41:25 <suppi> KaneTW, and think backwards about what kind of haskell knowledge will they need to accomplish these tasks
10:41:50 <KaneTW> that's a good idea
10:42:15 <suppi> bbs :)
10:44:13 <notdan> Is there any categorical characterization of Foldable datatypes?
10:53:14 <ReinH> notdan: not really. The most similar would probably be https://wiki.haskell.org/Catamorphisms
10:55:12 <notdan> Yeah, but F-algebras are more powerfu
10:55:34 <notdan> it seems that foldable datatypes are those F-algebras that factor through [a]-algebras, or something
10:56:19 <shachaf> A Foldable instance for t is just a function :: t a -> [a]
10:56:45 <shachaf> t doesn't need to be a Functor, so you can't even call it natural.
10:57:05 <shachaf> I guess you can still call it parametric, whatever that's good for.
10:58:35 <notdan> yeah, Foldable is not really neatly characterized
10:58:40 <shachaf> It has nothing to do with the type of fold people sometimes call "catamorphism"
10:58:48 <notdan> but I mean all the sensible instances of Foldable are functors?
10:58:53 <shachaf> (Except for the [] instance.)
10:58:56 <shachaf> No.
10:59:31 <Saizan> what's a Foldable that's not a functor?
11:00:22 <ReinH> Saizan: data A a = A (a -> a) a
11:00:42 <ReinH> which uses a in negative position
11:01:03 <louispan> Is there such a thing as Indexed State Monad Transformer?
11:01:53 <notdan> ReinH: yeah, of course. or even just data A a = A (a -> a)
11:01:56 <monochrom> one of the laws, foldr f z = foldr f z . toList, actually ensures that you are not going to get a catamorphism.
11:02:04 <notdan> I was using the term "sensible" informaly
11:02:14 <notdan> monochrom: wait, foldable has laws?
11:02:37 <monochrom> yes, I'm reading whatever is documented in Data.Foldable doc
11:02:43 <notdan> oh yeah, I missed that
11:02:55 <shachaf> Certainly your implementations of the various methods should be compatible with the default implementations.
11:03:23 <Saizan> ReinH: is there an example that gets actual use?
11:03:46 <joehillen> louispan: some googling found this https://hackage.haskell.org/package/mtlx-0.1.5/docs/Control-Monad-StateX-Lazy.html
11:03:54 <ReinH> Set
11:04:38 <Saizan> nice
11:07:06 <ReinH> notdan: I don't think Endo is a Foldable.
11:08:26 <louispan> joehillen: Thank you. My google foo couldn't find it. I'll take a look at StateX
11:09:30 * hackagebot nondeterminism 1.2 - A monad and monad transformer for nondeterministic computations.  https://hackage.haskell.org/package/nondeterminism-1.2 (AndreiBarbu)
11:11:40 <joehillen> louispan: I'm not sure if you want regular indexed as in "zip [0..]" or type-indexed, but it looks like that library is type indexed.
11:11:52 <joehillen> louispan: the example is helpful https://hackage.haskell.org/package/mtlx-0.1.6/src/examples/Examples.hs
11:15:52 <louispan> joehillen: Looks like StateX is more like a newtype wrapper. I was after a transformer version of this: https://hackage.haskell.org/package/indexed-extras-0.1.1/docs/Control-Monad-Indexed-State.html
11:17:10 <joehillen> louispan: I thought you might. Isn't  IxStateT a transformer?
11:18:20 <louispan> joehillen: Oh my gosh. I must have been blind! Thank you, I totally missed seeing IxStateT.
11:18:38 <joehillen> :)
11:19:17 <breadmonster> Hey guys.
11:23:24 <SparkySparkyBoom> does anyone see anything obviously wrong with this?
11:23:36 <SparkySparkyBoom> charToNato :: Char -> String
11:23:36 <SparkySparkyBoom> charToNato char = case lookup char letters of
11:23:36 <SparkySparkyBoom> 	Nothing -> ""
11:23:36 <SparkySparkyBoom>   Just val -> val
11:24:00 <SparkySparkyBoom> please ignore the indentation at the last line
11:24:31 * hackagebot nondeterminism 1.4 - A monad and monad transformer for nondeterministic computations.  https://hackage.haskell.org/package/nondeterminism-1.4 (AndreiBarbu)
11:24:38 <phale> is learn you a haskell still ok to read?
11:24:38 <suppi> yes SparkySparkyBoom 
11:24:42 <brnhy> lookup will return Maybe Char, your Nothing case returns a String?
11:24:49 <suppi> char is a Char
11:24:52 <suppi> but "" is a String
11:25:00 <SparkySparkyBoom> brnhy: lookup is from Data.Map
11:25:04 <suppi> so you have a type mismatch as far as i can tell
11:25:26 <brnhy> Of what type is letters?
11:25:26 <SparkySparkyBoom> and letters is `Map Char String`
11:26:12 <suppi> oh, oops, my bad
11:26:13 <SparkySparkyBoom> looks like the in-browser editor was incorrect
11:26:39 <suppi> SparkySparkyBoom, what was the error?
11:27:01 <SparkySparkyBoom> something about an unexpected Just
11:27:07 <SparkySparkyBoom> i think it's a whitespace bug in the editor
11:27:10 <brnhy> Hmm, not sure then. sounds like a syntax error
11:27:41 <SparkySparkyBoom> i just added two more spaces
11:27:43 <SparkySparkyBoom> and it works
11:27:59 <quicksilver> you had a literal tab before Nothing
11:28:00 <SparkySparkyBoom> it looks wonky though
11:28:05 <SparkySparkyBoom> AH
11:28:05 <quicksilver> and two plain spaces before Just
11:28:07 <SparkySparkyBoom> tabs and spaces
11:28:11 <SparkySparkyBoom> mixing them is bad
11:28:13 <brnhy> :)
11:28:14 * quicksilver nods
11:28:30 <SparkySparkyBoom> ive just always had my editor correct it for me
11:28:49 <SparkySparkyBoom> thank you
11:29:10 <aweinstock> :t \table x -> maybe "" id $ lookup table x
11:29:12 <lambdabot> Eq a => a -> [(a, [Char])] -> [Char]
11:29:21 <aweinstock> :t \table x -> maybe "" id $ M.lookup table x
11:29:22 <lambdabot> Ord k => k -> M.Map k [Char] -> [Char]
11:29:37 <aweinstock> SparkySparkyBoom: ^ more concise version
11:30:00 <SparkySparkyBoom> ooh
11:30:03 <SparkySparkyBoom> nice
11:30:09 <aweinstock> > map (maybe "" id) [Just "hello", Nothing]
11:30:10 <SparkySparkyBoom> forgot about the maybe function
11:30:10 <lambdabot>  ["hello",""]
11:30:15 <brnhy> fromMaybe could be used instead of maybe "" id
11:30:19 <SparkySparkyBoom> thanks
11:30:24 <brnhy> fromMaybe "" $ M.lookup table x
11:30:25 <aweinstock> > map (fromMaybe "") [Just "hello", Nothing]
11:30:28 <lambdabot>  ["hello",""]
11:30:55 <aweinstock> :t (fromMaybe "" .) . M.lookup
11:30:57 <lambdabot> Ord k => k -> M.Map k [Char] -> [Char]
11:31:15 <martinvlk> @pl (\n -> pageExtractText =<< pageNodePageByNum rootNode n)
11:31:15 <lambdabot> (pageExtractText =<<) . pageNodePageByNum rootNode
11:32:37 <athan> Can you pattern match infix-style with infix data constructors? Like `foo (x:xs)`?
11:32:48 <monochrom> yes
11:33:09 <athan> monochrom: That's a wonderful feature
11:36:08 <monochrom> example: :+ is a data constructor from Data.Complex and lambdabot has it
11:36:45 <monochrom> > case cis (pi/6) of x :+ y -> (x, y)
11:36:48 <lambdabot>  (0.8660254037844387,0.49999999999999994)
11:37:09 <monochrom> (cis t = cos t + i * sin t)
11:38:03 <monochrom> if the data constructor name is alphabetical rather than symbolic, I think you can use (x `Ctor` y) too
11:39:10 <athan> Could someone help me formulate this?
11:39:11 <athan> :t ala Sum Data.Map.unionWith (+)
11:39:14 <lambdabot>     Couldn't match type ‚Äòa0 -> a0‚Äô with ‚ÄòSum b‚Äô
11:39:14 <lambdabot>     In the expression: ala Sum M.unionWith (+)
11:39:14 <lambdabot>     Couldn't match type ‚ÄòM.Map () a0 -> M.Map () a0‚Äô with ‚ÄòSum a‚Äô
11:42:34 <ReinH> athan: if you're choosing (+) then you don't need Sum and vice-versa
11:44:18 <athan> ReinH: o_o how come?
11:44:31 <athan> Can you show me a small working example? Sorry, it's just hard to follow
11:45:15 <aweinstock> :t M.unionWith
11:45:18 <lambdabot> Ord k => (a -> a -> a) -> M.Map k a -> M.Map k a -> M.Map k a
11:45:29 <aweinstock> :t M.unionWith (+)
11:45:31 <lambdabot> (Num a, Ord k) => M.Map k a -> M.Map k a -> M.Map k a
11:45:47 <aweinstock> athan: what are you trying to do?
11:49:37 <roelof> Does anyone has a example of a quickCheck test where epsilon is set ? 
11:50:18 <athan> aweinstock: Insight into the use of `ala` for multi-argument situations, like leveraging the monoid instance for `Sum` to make another monoid instance
11:50:23 <athan> but in a bass-ackward way
11:53:04 <ReinH> athan: If you know you want to use (+) then you don't need Sum.
11:53:17 <ReinH> If you have Sum then you can use (<>) instread of (+)
11:53:22 <ReinH> *instead
11:56:22 <athan> :O
11:56:24 <athan> okay
11:57:00 <athan> next question: is it a tradition to leave the "argument to be manipulated", or the subject argument in a verbose function as the _last_ arg?
11:57:58 <aweinstock> :t ala Sum (M.unionWith (<>))
11:57:59 <lambdabot>     Couldn't match type ‚ÄòUnwrapped (Sum b) -> Sum b‚Äô with ‚ÄòM.Map k a‚Äô
11:57:59 <lambdabot>     Expected type: (Unwrapped (Sum b) -> Sum b) -> M.Map k a -> Sum b1
11:57:59 <lambdabot>       Actual type: M.Map k a -> M.Map k a -> M.Map k a
11:58:22 <aweinstock> :t (ala, M.unionWith)
11:58:24 <lambdabot> (Ord k, Rewrapped s t, Rewrapped t s) => ((Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s, (a -> a -> a) -> M.Map k a -> M.Map k a -> M.Map k a)
11:59:06 <yyyyy> When using conduit with ResumableSource, how does interleaving works? That is, if i `someResumableSource $$+- mapM_ (liftIO . someFunction)`, does control gets back to streaming only after `someFunction` finishes?
11:59:19 <aweinstock> athan: yes, since it makes the mostly-applied-function an endomorphism
11:59:45 <yyyyy> Better yet, can I send parts of a Producer in parallel to multiple identical Sinks running concurrently?
11:59:46 * hackagebot git-annex 5.20151019 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-5.20151019 (JoeyHess)
12:02:10 <Gurkenglas> @let unionFoldMap f = uncurry (M.unionWith (<>)) . over (both . each) ?f
12:02:12 <lambdabot>  Defined.
12:09:46 * hackagebot Hish 0.1.0 -   https://hackage.haskell.org/package/Hish-0.1.0 (jaiyalas)
12:10:17 <Gurkenglas> Damn it all representable functors should lift underlying num instances.
12:15:03 <roelof>   no one who can help me ? 
12:15:33 <bitemyapp> roelof: epsilon?
12:16:04 <bitemyapp> roelof: you want to write your own random generator?
12:16:21 <roelof> bitemyapp:  yes, I have to check if a function is approx. zero because of the use of floats ? 
12:16:37 <roelof> no, I need it to test something with quickCheck 
12:16:59 <bitemyapp> roelof: do you really need float/double for what you're doing?
12:17:05 <bitemyapp> roelof: or can you use Scientific?
12:17:18 <bitemyapp> roelof: if you want a different generator with different behaviors, you can write your own 'Gen'
12:17:21 <roelof> yes, the exercise is stated to use float.
12:17:31 <bitemyapp> roelof: http://hackage.haskell.org/package/QuickCheck-2.8.1/docs/Test-QuickCheck-Gen.html this beastie.
12:17:52 <aweinstock> roelof: x ~= y = (x-y) < 0.001 -- is this sufficient?
12:18:10 <aweinstock> roelof: x ~= y = abs (x-y) < 0.001 -- rather
12:19:42 <roelof> oke, so I can do  proplist test = a ^ 2 * x + b * x + c  - 0 < 0.001  ? 
12:20:05 * hackagebot Hish 0.1.0.1 -   https://hackage.haskell.org/package/Hish-0.1.0.1 (jaiyalas)
12:20:10 <monochrom> yes, but you're better off applying abs in addition
12:20:53 <roelof> oke, so like this abs(a ^ 2 * x + b * x + c  - 0) < 0.001 ?
12:21:46 <bitemyapp> roelof: oh you want a different equality.
12:21:51 <bitemyapp> sorry for misunderstanding.
12:21:59 <roelof> bitemyapp:  NP 
12:23:48 <roelof> monochrom:  is my last try well ? 
12:27:49 <roelof> Another question : Has anyone used Servant for web development ? 
12:28:01 <monochrom> yes
12:28:34 <roelof> monochrom:  thanks, I hope I can solve my challenge now 
12:29:06 <ReinH> roelof: I've used it for wrapping APIs around things and it works pretty well, but not specifically for web dev.
12:30:04 <roelof> ReinH:  thanks, I like the idea of microservises for a project I have in mind when I learned Haskell well 
12:30:05 * hackagebot clafer 0.4.2.1 - Compiles Clafer models to other formats: Alloy, JavaScript, JSON, HTML, Dot.  https://hackage.haskell.org/package/clafer-0.4.2.1 (mantkiew)
12:32:31 <roelof> ReinH:  when Im more familiar Im thinking of making a web commerce site with it 
12:35:06 * hackagebot ginsu 0.8.2 - Ginsu Gale Client  https://hackage.haskell.org/package/ginsu-0.8.2 (DylanSimon)
12:35:55 <roelof> ReinH:  did you only read the official docs or is there some sort of book where I can find more about Servant 
12:36:40 <fizruk> roelof: there is #servant :)
12:37:07 <roelof> fizruk:  thanks 
12:38:29 <fizruk> roelof: I don't know any book, or any tutorial other than the official one
12:38:52 <fizruk> roelof: but servant is developing pretty fast, so someone might've written something recently
12:39:02 <roelof> fizruk:  again thanks 
12:40:44 <fizruk> roelof: there are also some noticable changes going to take place in a couple of weeks (v0.5 release)
12:42:32 <roelof> fizruk:  thanks, I think it takes me some months to do the craft book. the CIS course and the NICTA one 
12:51:22 <platz> i'm going to a meetup on Servant this week.. any tricky questions i should ask? ;)
12:58:04 <_wordsarewind_> what is the meaning of life?
12:58:15 <_wordsarewind_> they might throw you out...
13:01:09 <platz> they might do that anyway
13:01:40 <_wordsarewind_> what sort of questions will you be asking? >_>
13:11:25 <dfeuer> Hmm... When I feed <*> for Codensity to @pl, I get   Codensity f <*> Codensity g = Codensity (f . (g .) . (.))  Looks weird.
13:16:33 <lilred> In math, is there an abstraction for applying a relation operator over a sequence? Something like a fold, except for relations. fold_relation (<) X = x_1 < x_2 < x_3...
13:18:21 <fizruk> :t and . liftA2 (zipWith (<)) id tail
13:18:23 <lambdabot> Ord a => [a] -> Bool
13:19:27 <fizruk> > let foldRelation r = and . liftA2 (zipWith r) id tail in foldRelation (<) [1..10]
13:19:30 <lambdabot>  True
13:19:36 <Cale> lilred: I don't think there's a name or notation for that
13:19:55 <Cale> lilred: However, for the specific case of < it's simply "increasing"
13:20:25 <Zemyla> > let foldRelation r = and . liftA2 (zipWith r) id tail in foldRelation (<) []
13:20:30 <lambdabot>  mueval-core: Time limit exceeded
13:20:32 <Cale> "strictly increasing" if you want to emphasise the fact that it's < and not <=
13:20:40 <lilred> fizruk: that's scary
13:20:45 <Zemyla> Cale: The word is "monotonic".
13:21:14 <fizruk> > let foldRelation r = and . liftA2 (zipWith r) id tail in foldRelation (<) []
13:21:16 <lambdabot>  True
13:21:52 <fizruk> lilred: point-free is scary indeed
13:22:01 <lilred> fizruk: scarier when it's right-to-left
13:22:10 <Zemyla> fizruk: What's the difference between what I typed and what you typed?
13:22:14 <Cale> Zemyla: Yeah, monotonic usually means either increasing or decreasing with respect to a particular order, but if you said R-monotone or R-monotonic, people would *probably* understand, but you might want to say what you mean anyway.
13:22:15 <lilred> fizruk: or rather, mixed
13:22:18 <Zemyla> Why did mine timeout and yours succeeded?
13:22:43 <fizruk> Zemyla: no difference, lambdabot just likes me more :p
13:22:46 <ReinH> Zemyla: strictly increasing is strictly more precise than monotonic.
13:23:18 <lilred> so there's really no name for a fold_relation type of thing? I'm surprised, this seems pretty fundamental
13:23:39 <ReinH> monotonic, increasing, and strictly increasing are a strictly increasing sequence of properties ;)
13:23:50 <Cale> In the case where the relation is a preorder relation
13:24:10 <Cale> Then such a sequence is itself a monotone function from the natural numbers under their usual order, to the preorder.
13:24:28 <Cale> (the preordered set)
13:25:46 <Cale> However, I haven't ever seen someone consider this for an arbitrary relation
13:26:41 <Cale> (in fact, even generalising as far as to preorders is a bit peculiar of me -- most people would stop at partial orders)
13:27:50 <jkdsfhsdkfsdkjf> hey
13:28:06 * monochrom stops at partial orders
13:28:42 <shachaf> Preorders are pretty good.
13:34:36 <lilred> I'm still digging into that point-free craziness you guys posted, initially I thought it was overly convoluted but I don't know anymore!
13:35:20 <fizruk> lilred: liftA2 (zipWith f) id tail = \xs -> zipWith f xs (tail xs)
13:35:46 <exio4> liftA2 f id g = f <*> g 
13:35:53 <lilred> fizruk: thanks for the hint.
13:36:04 <tsahyt> = ap (zipWith f) tail
13:36:14 <shachaf> @quote aztec
13:36:14 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
13:36:26 <dolio> I would say that is overly convoluted.
13:36:42 <lilred> so the liftXY operators are essentially reordering/rephrasing stuff
13:37:05 <tsahyt> :t liftA2
13:37:07 * fizruk regrets writing that
13:37:07 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
13:37:44 <lilred> or maybe they're not, and the use of liftA2 here was totally overkill :o)
13:37:55 <tsahyt> I think it's pretty clear what's going on from the type signature, especially when you set parentheses, liftA2 :: Applicative f => (a -> b -> c) -> (f a -> f b -> f c)
13:38:19 <tsahyt> liftA2 *lifts* a function on *A*pplicatives that take *2* arguments.
13:38:30 <tsahyt> s/on/to
13:38:33 <lilred> also what's an applicative in category theoretical terms?
13:38:58 <dolio> Lax closed monoidal functor.
13:39:03 <lilred> thx
13:39:42 <aweinstock> :t zip`ap`tail
13:39:44 <lambdabot> [a] -> [(a, a)]
13:40:01 <aweinstock> > (zip`ap`tail) [1..5]
13:40:03 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
13:40:10 <MarcelineVQ> neat
13:40:38 * hackagebot github-webhook-handler 0.0.5 - GitHub WebHook Handler  https://hackage.haskell.org/package/github-webhook-handler-0.0.5 (wereHamster)
13:40:54 <tsahyt> If only it also had (5,1)
13:42:18 <aweinstock> > take 5 . (zip`ap`tail) $ cycle [1..5]
13:42:19 <lilred> what's the backtick syntax?
13:42:20 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,1)]
13:42:28 <aweinstock> lilred: infix operators
13:42:36 <lilred> aweinstock: I mean how does it unsugar
13:42:49 <aweinstock> lilred: zip `ap` tail == ap zip tail
13:42:55 <lilred> thanks!
13:43:05 <aweinstock> > (+) 2 3
13:43:07 <lambdabot>  5
13:43:21 <aweinstock> lilred: you can also use infix operators as prefix
13:43:43 <lilred> aweinstock: yup, that much I knew. I'm an ML transplant, especially F#.
13:44:18 <tsahyt> aweinstock: I think zip `ap` (tail . cycle) should work without the explicit take
13:44:45 <clrnd> @pl zip `ap` tail
13:44:45 <lambdabot> zip `ap` tail
13:45:33 <aweinstock> @unpl zip`ap`tail
13:45:33 <lambdabot> (zip >>= \ b -> tail >>= \ a -> return (b a))
13:45:35 <tsahyt> Or zip <*> (tail . cycle) to get rid of the Monad constraint in favor of an Applicative constraint
13:46:02 <aweinstock> > (zip <*> (tail . cycle)) [1..5]
13:46:03 <tsahyt> :t ap
13:46:04 <lambdabot> Monad m => m (a -> b) -> m a -> m b
13:46:04 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,1)]
13:46:33 <aweinstock> tsahyt: but that no longer sounds vaguely aztec ;)
13:47:00 <tsahyt> Depends on how you pronounce <*>
13:47:54 <lilred> I'm sitting in my analysis class right now - has anyone here found analysis beneficial to their understanding of computer science?
13:48:11 <lilred> it's interesting as hell but I'm not sure why I'm taking it
13:49:00 <tsahyt> I think studying something just for its immediate benefit is intellectually limiting. But yeah, I've found analysis to be useful in CS, or at least in some areas
13:49:12 <Zemyla> Hmm. there used to be a free MonadPlus, but now there isn't? :O
13:49:22 <lilred> tsahyt: sure, but then I'd end up doing nothing but studying
13:49:25 <koshmar> hellow there, Why this works http://paste.ofcode.org/f2Fk32s73SuMF38ncykM9J but when I chenge only line #7 to poinless style I get this http://paste.ofcode.org/k5zSaNDbMt3hRgJmsgkD5H it produces the error - the error is included but the lines in error is a bit different. 32 in error msg is actually 7 in paste.of.code.org . 
13:49:36 <clrnd> studying is doing something
13:49:42 <lilred> even then I need to prioritize
13:50:15 <tsahyt> Meanwhile I'm thinking about pursuing a second masters degree, just so that I can keep studying
13:50:29 <tsahyt> Learning interesting things is great
13:50:46 <lilred> tsahyt: well, I've extended my undergrad to ~6.5 years (from a 3.5 baseline) just so I could take more classes
13:51:04 <ReinH> koshmar: (.) works for one argument only
13:51:06 <lilred> I'll graduate with the equivalent of a masters' degree, though on paper I'm not much
13:51:09 <glguy> koshmar: addEl e t  = refHeight $ addElwoH e t --is-- addEl e = refHeight . addElwoH e
13:51:48 <aweinstock> koshmar: (refHeight .) . addElwoH
13:51:48 <ReinH> koshmar: http://stackoverflow.com/questions/16888222/functional-composition-with-multi-valued-functions-in-haskell
13:51:50 <tsahyt> lilred: You're likely to benefit from the additional knowledge though.
13:51:54 <koshmar> thanks
13:52:20 <aweinstock> :t (.) . (.)
13:52:21 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
13:52:31 <aweinstock> @unpl (.).(.)
13:52:31 <lambdabot> (\ i b c f -> i (b c f))
13:52:33 <lilred> the naming is strange here
13:53:07 <koshmar> thanks.
13:53:52 <lilred> laptop battery dying, see yall!
13:54:04 <tsahyt> @unpl (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.)
13:54:04 <lambdabot> (\ aa b c f i l o r u x -> aa (b c f i l o r u x))
13:54:04 <breadmonster> :t ap
13:54:05 <lambdabot> Monad m => m (a -> b) -> m a -> m b
13:54:16 <lilred> :t ( . )( . )
13:54:18 <lambdabot> (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
13:54:28 <tsahyt> Why does it use two letter identifiers before exhausting all the one letter ones?
13:54:35 <koshmar> =D
13:54:39 <breadmonster> What's the Applicative equivalent of ap?
13:54:44 <tsahyt> breadmonster: <*>
13:54:48 <Denommus> filorux
13:54:54 <breadmonster> tsahyt: Oh yeah :P
13:55:45 <dolio> tsahyt: It doesn't generate names using letters.
13:56:38 <dolio> If it has to make something up entirely, it uses 't' and a number if necessary. Otherwise it tries to keep names from other type signatures, but adds numbers if necessary.
13:57:30 <tsahyt> Ah okay.
13:58:18 <dolio> Apparently it uses 'r' sometimes, too.
14:00:22 <breadmonster> Has anyone implemented the SKI combinator calculus in Haskell?
14:00:35 <jle`> in what way?
14:00:55 <breadmonster> If I'm not mistaken, Barker's iota is `iota x = x s k`
14:01:00 <jle`> you can talk about some rudimentary supset with ap, const, and id
14:01:04 <jle`> subset
14:01:29 <breadmonster> jle`: I get a type error trying to recover s, k and i from iota x
14:01:40 <quicksilver> yes, SKI is for untyped lambda
14:01:52 <quicksilver> you need to model untyped lambda inside haskell to get everything working
14:02:05 <quicksilver> newtype L = L (L -> L)
14:02:06 <breadmonster> > let s = ap; k = const; i = id; iota x = x s k in iota iota
14:02:08 <lambdabot>      Occurs check: cannot construct the infinite type: b0 ~ a -> b0 -> a
14:02:08 <lambdabot>      Expected type: (((a -> b0 -> a) -> (a -> a -> b0 -> a) -> a -> a)
14:02:08 <lambdabot>                      -> ((a -> b0 -> a) -> a -> a -> b0 -> a)
14:02:42 <breadmonster> quicksilver: Okay, can you apply this to say the iota combinator?
14:03:12 <mniip> you can't Show L though
14:03:36 <freemonad> lilred: afaik, analysis is pretty important in finance as a quant engineer
14:06:46 <ski>   # let iota x = x s k;;
14:07:08 <ski>   val iota : ((('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c) -> ('d -> 'e -> 'd) -> 'f) -> 'f = <fun>
14:07:14 <ski>   # iota iota;;
14:07:20 <ski>   - : '_a -> '_a = <fun>
14:07:34 <ski>   # fun x -> iota iota x;;
14:07:40 <ski>   - : 'a -> 'a = <fun>
14:07:42 <montanonic> So, I'm diving into the world of Algorithms and Data Structures right now, and I was wondering what people had to say about The Art of Computer Programming in reference to Haskell. I ask this because my impression is that volume 1's coverage of data structures is for non-functional languages, and wouldn't be relevant to stuff like Haskell. Thoughts?
14:08:12 <ski> breadmonster ^
14:08:19 <josephle> montanonic, Knuth just uses fake asm for everything
14:08:42 <montanonic> josephle: sorry, what's asm?
14:08:52 <breadmonster> ski: There has to be an easier solution than switching to ocaml o.O
14:09:10 <ski> montanonic : you might be interested in looking at PFDS, if you haven't already
14:09:26 <breadmonster> montanonic: Umm, leave it alone, use Okasaki's book
14:09:32 <breadmonster> oh ski beat me to it.
14:09:34 <ski> montanonic : there's also an interesting book "Pearls of Functional Algorithm Design" by Bird, iirc
14:09:34 <montanonic> ski: I am interested, I own it
14:09:41 <josephle> monatonic, assembly
14:09:43 <montanonic> ski: yeah that too
14:09:48 * ski smiles
14:09:56 <montanonic> I just am not sure where to start because I've not learned algorithms before
14:09:59 <montanonic> Or data structures
14:10:12 <breadmonster> @remember breadmonster ski: There has to be an easier solution than switching to ocaml o.O
14:10:12 <ski> also there's a "The Fun of Programming" (?) by various authors
14:10:12 <lambdabot> I will never forget.
14:10:17 <montanonic> and TAoCP and several other algorithm books were recommended everywhere
14:10:20 <breadmonster> Finally, one quote.
14:10:27 <ski> breadmonster : easier solution to what ?
14:10:39 <breadmonster> montanonic: Okay, pick up Kleinberg and Tardos or CLRS.
14:10:43 <josephle> TAoCP is a great book, but probably not a good starting point
14:10:46 <breadmonster> ski: Implementing iota.
14:11:18 <ski> breadmonster : how about `iota x = x' ?
14:11:24 <montanonic> breadmonster: I have CLRS
14:11:26 <breadmonster> ski: How on earth...
14:11:35 <ski> montanonic : <http://www.cs.ox.ac.uk/publications/books/fop/>
14:11:36 <breadmonster> ski: iota x = x s k
14:12:00 <ski> breadmonster : er, sorry. i was confusing `iota iota' with `iota' for a moment
14:12:11 * ski still isn't sure what breadmonster wants to do
14:12:13 <breadmonster> ski: You did it in OCaml, Haskell gives me some weird type error.
14:12:24 <ski> breadmonster : correction, in `ocaml -rectypes'
14:12:32 <ski> ordinary OCaml would give the same type error
14:12:35 <montanonic> I just wasn't sure where to start. I've been reading Concrete Mathematics, but I wasn't sure what to follow that up with. If I was using a language like python or Java it'd be obvious to me, but purely functional languages are fundamentally different in some ways, so I just wasn't sure what makes sense as a next step.
14:12:36 <ski> (for good reason)
14:12:45 <breadmonster> > let s = ap; k = const; iota x = x s k in iota iota
14:12:47 <lambdabot>      Occurs check: cannot construct the infinite type: b0 ~ a -> b0 -> a
14:12:47 <lambdabot>      Expected type: (((a -> b0 -> a) -> (a -> a -> b0 -> a) -> a -> a)
14:12:47 <lambdabot>                      -> ((a -> b0 -> a) -> a -> a -> b0 -> a)
14:13:09 <breadmonster> montanonic: Read CLRS and Okasaki side by side.
14:13:21 <breadmonster> Speaking of Okasaki, he really should do another edition soon.
14:13:25 <breadmonster> And bos too.
14:13:29 <montanonic> bos?
14:13:33 <breadmonster> OCaml's got a shiny new book, we want one too.
14:13:40 <breadmonster> montanonic: Bryan O'Sullivan.
14:13:44 <montanonic> breadmonster: by the way, sounds good, thank you
14:13:46 <breadmonster> Very prolific Haskeller.
14:13:58 <montanonic> breadmonster: what by him? RWH?
14:14:04 <montanonic> I couldn't do it.
14:14:06 <montanonic> RWH.
14:14:13 <breadmonster> Yeah.
14:14:37 <montanonic> I got lost come Ch.5. Maybe after the algo stuff it'll be easier.
14:20:54 <ReinH> montanonic: A new edition of RWH is pretty much not happening.
14:21:12 <montanonic> ReinH: yeah, others have dissuaded me about it given its datedness
14:21:15 <ReinH> Unless someone else picks it up
14:21:22 <montanonic> I wasn't able to get verbatim code to compile at the time.
14:21:49 <ReinH> bos is too busy to write another book
14:22:17 * hackagebot secp256k1 0.1.8 - secp256k1 bindings for Haskell  https://hackage.haskell.org/package/secp256k1-0.1.8 (xenog)
14:22:41 <ReinH> montanonic: if you want a fun exercise, write a disassembler and emulator for MIX or MMIX
14:22:54 <ReinH> er, assembler
14:23:14 <montanonic> ReinH: in Haskell? or..
14:24:40 <montanonic> I wasn't sure how valuable TAoCP would be for Haskell and languages like it, knowing that it's an otherwise extremely well-regarded text. Right now I'm persuaded to follow breadmonster's and ski's reading list.
14:25:16 <ReinH> Sure, in Haskell.
14:25:23 <montanonic> okay, just making sure
14:25:55 <ReinH> TAoCP provides some necessary baseline understanding of data structure and algorithms that's still relevant no matter what language you use
14:26:32 <montanonic> But as an efficiency trade-off, is it worth reading the whole vol.1 vs two other texts? I'd assume it'd take me about twice as long to read it.
14:26:45 <rcyr> Has anyone ever read those book? I heard programmers only buy them because they look good on a shelf.
14:26:47 <montanonic> I'm 0% discounting that TAoCP would be valuable for me.
14:27:07 <montanonic> I have ebook versions, so no shelf-pride for me :)
14:27:12 <rcyr> Ha :)
14:27:18 <ReinH> It's reasonable to skip around.
14:27:31 <ReinH> Knuth even provides a flow chart to help you decide if you should read a chapter.
14:27:31 <rcyr> I bought them a few years ago... They're good at accumulating dust.
14:27:54 <montanonic> ReinH: Right, that's a fair point.
14:30:36 <quicksilver>    
14:31:03 * quicksilver apologises for that
14:32:07 <quicksilver> I have read the first couple of volumes or so
14:32:07 <JagaJaga> :t (>->)
14:32:08 <lambdabot>     Not in scope: ‚Äò>->‚Äô
14:32:08 <lambdabot>     Perhaps you meant one of these:
14:32:08 <lambdabot>       ‚Äò>>‚Äô (imported from Control.Monad.Writer),
14:32:26 <quicksilver> I actually found them enjoyably written but perhaps I am idiosyncratic in my tastes
14:32:28 <ggVGc> how would I achieve this? https://gist.github.com/eeab0492246231eb636a
14:33:03 <montanonic> Anyone have advice for how to deal with algorithms that clearly are for non-functional languages? I've not touched the mutable side of Haskell.
14:33:05 <mniip> ggVGc, can't
14:33:24 <mniip> not with JsFunc being an ordinary ADT constructor
14:33:24 <montanonic> non-*purely*-functional
14:33:42 <mniip> you need wibbley wobbley typeclass stuff
14:33:46 <kadoban> montanonic: Try to convert them to functional style, or you can certainly do it imperatively in haskell as well. Haskell is a surprisingly nice imperative language.
14:33:46 <mniip> or an explicit apply
14:33:51 <ReinH> ggVGc: f isn't a function so you can't apply it to b
14:33:54 <MarcelineVQ> JagaJaga: looking for >=> ?
14:34:09 <ski> montanonic : sometimes it's not hard to come up with an immutable version that does some more copying (possibly logarithmic in input size)
14:34:19 <quicksilver> montanonic: well, we pretend Data.Map is mutatable, using recursion or the state mond to generate 'new version from old version'
14:34:23 <montanonic> kadoban: That's what I've done before, to write it in functional style, I just wanted to figure out how to preserve the complexity time
14:34:25 <quicksilver> montanonic: and similar approaches.
14:34:25 <JagaJaga> MarcelineVQ: no, http://hackage.haskell.org/package/pipes-4.1.6/docs/Pipes.html#v:-62--45--62-
14:34:48 <kadoban> montanonic: It's usually not too hard to preserve within a log factor of time. Sometimes space is harder, IME. (I'm not an expert)
14:34:59 <montanonic> quicksilver: okay, that's solid advice
14:35:12 <montanonic> Alright, I'll just not worry about it so long as I understand the algorithm
14:35:24 <montanonic> Thanks y'all
14:35:49 <ggVGc> hm
14:35:57 <ggVGc> mniip: what's the closest I can get?
14:36:06 <quicksilver> as ski suggests, it does tend to change O(n) to O(log n)
14:36:21 <quicksilver> on the other hand, sometimes you get a laziness or sharing behavior that the imperative code can only dream of.
14:36:33 <quicksilver> [O(n) to O(n log n)]
14:37:57 <mniip> ggVGc, I'd go with explicit apply
14:38:02 <mniip> apply f b
14:38:10 <mniip> or 'f $$ b' or something
14:38:16 <ggVGc> mkay
14:38:17 <ski> montanonic : sometimes you can recover amorticized complexity. or sometimes even manage to split bulky work into many pieces, spreading it out. Okasaki talks a bit about this
14:38:17 <ggVGc> thanks
14:38:45 <montanonic> ski: very good to know, I'll be sure to read his book concurrently with the others.
14:39:52 <kadoban> Okasaki is really good. I'm reading Pearls of Functional Algorithm Design currently too, which seems good (but quite difficult so far, not far in).
14:41:13 <aupiff> If I `parMap rdeepseq` (from `Control.Parallel.Strategies`) over a list of 256 elements, then I see load averages on my linux box of 256. Does that mean that all those threads are competing for CPU, or is it just keeping a thread count?
14:41:32 <aupiff> is there a better way to do this?
14:41:49 <aupiff> or is it OK to see such a high load average?
14:42:00 <kallisti> hm, so does a GADT basically act like a closed data family?
14:42:18 <TheCrafter> How can I put IO Ints into [Int] ?? For example if I have this: http://lpaste.net/143386
14:42:43 <kadoban> aupiff: I'm not an expert, but that sounds not optimal I think.
14:42:46 <mniip> TheCrafter, sequence
14:42:51 <fizruk> kallisti: no?
14:42:52 <jle`> TheCrafter: if you have [IO Int], a list of IO actions producing Ints
14:43:02 <jle`> TheCrafter: you can use sequence, to perform all of them one after the other, and get an IO [Int]
14:43:09 <jle`> sequence :: [IO Int] -> IO [Int]
14:43:36 <jle`> TheCrafter: so goo = sequence [foo, foo2, foo3 ... fooN]
14:43:47 <jle`> if you don't care about the results, you can use sequence_
14:43:47 <TheCrafter> ok got it! thanks!
14:43:52 <jle`> sequence_ :: IO [Int] -> IO ()
14:43:57 <jle`> it looks like that's what you want actually
14:44:05 <jle`> oh nvm it's not
14:44:11 <TheCrafter> no I care about the results
14:44:13 <jle`> you want to do loo after it, heh
14:44:18 <TheCrafter> yeah
14:44:20 <jle`> goo = loo =<< sequence [foo .. ], i guess
14:44:49 <TheCrafter> sequence is really the best option here... No idea why I couldn't think of it myself :P
14:44:49 <ski> TheCrafter : to be more explicit, what `sequence' does is take a list of `IO'-actions, and return an `IO'-action that, when (later) executed, will run each of the actions in the list, in order, and collect their individual result values in a result list
14:45:16 <TheCrafter> Ok got it! Thanks ski and jle` 
14:45:20 <ski> TheCrafter : `sequence_' is a variant of this, that ignores the result values, instead of collecting them in a list
14:45:54 * ski really only wanted to emphasize that calling `sequence' doesn't cause the actions to be executed, it only creates a new action that, when executed, will cause the previous actions to be executed
14:46:08 <jle`> thank you ski
14:46:12 <ski> np
14:46:50 <fizruk> kallisti: you can have GADTs for every data instance
14:47:33 <thimoteus> if i have two libraries that use different monad transformer stacks, should i be looking into the mmorph package?
14:47:34 <ski> TheCrafter : also, your `foo',`foo2',`fooN' things aren't functions, they're actions (`IO'-actions)
14:48:02 <ski> perhaps ?
14:48:03 <fizruk> kallisti: there can also be newtype instances
14:49:05 <TheCrafter> ski: in my code there are functions, they take input as well. I wrote them like that on lpaste to simplify them
14:49:16 <TheCrafter> they are*
14:49:47 <ski> ok
14:50:04 <ski> TheCrafter : just pedanticing on the fact that if there's no `->' in the type, then it can't be a function
14:52:43 <TheCrafter> yeah you're right
15:07:19 * hackagebot github-webhook-handler-snap 0.0.5 - GitHub WebHook Handler implementation for Snap  https://hackage.haskell.org/package/github-webhook-handler-snap-0.0.5 (wereHamster)
15:07:30 <nitrix> ski: Sounds wrong.
15:07:49 <nitrix> ski: What about something like: type Contextual a = IORef Context -> a
15:24:15 <Ferde> @djinn (a -> b) -> [a] -> [b]
15:24:15 <lambdabot> Error: Undefined type []
15:24:22 <Ferde> @djinn (a -> b) -> c
15:24:22 <lambdabot> -- f cannot be realized.
15:24:39 <Ferde> @djinn (a, b) -> c -> (a, c)
15:24:39 <lambdabot> f (a, _) b = (a, b)
15:24:53 <Ferde> @djinn (a -> b) -> List a -> List b
15:24:53 <lambdabot> Error: Undefined type List
15:25:01 <Ferde> @djinn (a -> b) -> [a] -> [b]
15:25:01 <lambdabot> Error: Undefined type []
15:25:16 <Ferde> @free (a -> b) -> [a] -> [b]
15:25:16 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
15:26:17 <Ferde> @quotes
15:26:17 <lambdabot> gaal says: (ghc predicted a cpu death on my computer once.)
15:26:23 <Ferde> @quotes
15:26:23 <lambdabot> tomasz says: After all, return is only a fancy name for liftM0 :-)
15:26:31 <Ferde> @quotes
15:26:31 <lambdabot> AchimSchneider says: Finite automata don't go bottom in any case, at least not if you don't happen to shoot them and their health drops below zero.
15:26:34 <jle`> anyone know any other things filling a similar space to http://hackage.haskell.org/package/type-combinators ?
15:26:48 <jle`> if not then i'll go ahead and make this package my canonical package for heterogeneous lists
15:27:00 <jle`> and fixed length vectors, and peano nats
15:27:13 <Ferde> @quotes
15:27:13 <lambdabot> LoganCapaldo says: Is MkCabal a fast food resturant?
15:27:28 <jle`> doesn't seem to have that many users so i was just wondering if there was one that was already "established"
15:27:33 <Ferde> @quotes
15:27:33 <lambdabot> Makoryu says: < roconnor > I keep coming back to #haskell and thinking there is an online boxing game written in haskell. (regarding frequent spamvertiser) < Makoryu > Maybe it could be in contrast to online unboxing, rather than offline boxing...
15:27:34 <jle`> Ferde: did you know that you can use lambdabot in pm? :)
15:27:45 <jle`>  /q lambdabot @quotes, for example
15:27:48 <Ferde> oh, sorry, I thought it automagically redirected
15:27:58 <jle`> np!
15:50:42 <m4tt3> exit
15:52:20 * hackagebot csp 1.3 - Discrete constraint satisfaction problem (CSP) solver.  https://hackage.haskell.org/package/csp-1.3 (AndreiBarbu)
16:13:40 <YellowOnion> Stupid question, can I import hiding everything?
16:13:47 <hpc> yes
16:13:49 <hpc> import Foo ()
16:13:56 <hpc> only imports instances
16:14:06 <hpc> and you can still use Foo.bar
16:14:08 <hpc> (iirc)
16:14:44 <YellowOnion> I'm trying to do this http://codegolf.stackexchange.com/questions/61115/make-your-language-unusable
16:14:50 <YellowOnion> :D
16:15:41 <YellowOnion> Javascript wins, with clear(this)
16:18:05 <hpc> the closest i have ever come to shenanigans with scoping in haskell is acme-php
16:20:08 <bergmark> import Foo () hides all names from both qualified and unqualified use
16:20:47 <YellowOnion> I tried import Prelude hiding ()
16:21:02 <bergmark> w/o hiding, hiding nothing means you get everything ;-)
16:21:33 <YellowOnion> Yeah haha, I guess Prelude is the exception.
16:21:39 <bergmark> {-# LANGUAGE NoImplicitPrelude, RebindableSyntax #-}
16:21:48 <YellowOnion> oh :)
16:22:53 <YellowOnion> NoImplicitPredule is probably enough to completely break haskell.
16:23:57 <bergmark> it's pretty common to have your own prelude, we used to use NoImplicitPrelude everywhere but now we switched to a custom Prelude module (and no direct dependency on base)
16:24:09 <bergmark> -fdefer-type-errors is also good to have i suppose
16:25:29 <YellowOnion> A lot of these rules apply to interp'ed langs it seems
16:26:28 <YellowOnion> This is the only rule I think you can't stop "making sure the user cannot re-enable them."
16:31:18 <bergmark> you can make the compiler loop with UndecidableInstances
16:46:08 <KaneTW> not forever
16:46:23 <KaneTW> it just terminates with an error eventually
17:53:13 * hackagebot warp 3.1.7 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.1.7 (KazuYamamoto)
17:54:03 <pdxleif> Is Hackage sick?
17:54:17 <pdxleif> Was getting 503's and weird pages. Hmm, working now.
17:58:41 <bergmark> hrmmm it may have been me adding revisions
18:18:14 * hackagebot network-anonymous-tor 0.10.0 - Haskell API for Tor anonymous networking  https://hackage.haskell.org/package/network-anonymous-tor-0.10.0 (solatis)
18:19:50 <pdxleif> If I noticed a post to haskell-beginners from 2010 that I might know the answer to, it's probably too late to respond to, right?
18:46:33 <lpaste> tippenein pasted ‚Äúwhere scope question‚Äù at http://lpaste.net/143401
18:47:45 <tippenein> I'm confused how to use an MVar in the map's function
18:50:54 <lamefun> Can I generate cabal files from source?
18:53:08 <lamefun> I want to make several inter-related libraries, how can I keep their dependencies in sync?
19:02:49 <ahg> I want to use the gitlib module to open a git repository at "/home/ahg/test", but cannot make sense of the data types involved.
19:02:56 <ahg> It looks like the function I want is "openRepository :: RepositoryFactory n m r -> RepositoryOptions -> m r". I believe that the second argument should be something like "defaultRepositoryOptions { repoPath = "/home/ahg/test" }, but I don't know where to come up with a "RepositoryFactory n m r"
19:03:05 <ahg> Matters are further confused by the fact that "openRepository :: RepositoryOptions -> m c" is listed as a constructor of RepositoryFactory
19:04:26 <ahg> relevant documentation is at https://hackage.haskell.org/package/gitlib-1.1.0/docs/Git.html
19:05:00 <hodapp> ooh, gitlib... I could make use of this in my Shake build
19:05:13 <ahg> how can I open that repo? and more generally, how can I find an entry point into an unfamiliar library?
19:05:20 <glguy> ahg: 1.1.0 is from 2013. Are you intentionally using that old version?
19:05:43 <ahg> glguy: hmm, no, I was trusting google. I'll check the fresher documentation
19:07:38 <ahg> Ah, and that has led me to the Git.Tutorial module. Seems promising, at least
19:24:42 <kallisti> how do you write code that doesn't execute in a literate haskell program?
19:24:48 <kallisti> but also has syntax highlighting etc
19:28:17 * hackagebot warp-tls 3.1.4 - HTTP over TLS support for Warp via the TLS package  https://hackage.haskell.org/package/warp-tls-3.1.4 (KazuYamamoto)
19:28:43 <glguy> kallisti: That'd depend on whatever you're using to syntax highlight
19:40:20 <hodapp> kallisti: if you're using the funky arrangement that combines LHS and Markdown, you can insert 'normal' Markdown code with ``` or something
19:40:55 <hodapp> Pandoc handles that, GitHub might
19:42:06 <mmmrrrrooooppppp> Which package should I use for amazon aws? I found 'aws' and 'amazonka' packages so far..
19:44:36 <ahg> According to the online documentation at https://hackage.haskell.org/package/gitlib-3.1.1/docs/Git-Types.html#t:RepositoryFactory, openRepository constructs RepositoryFactories out of RepositoryOptions, 
19:44:37 <ahg> but in ghci ":t openRepository" outputs "RepositoryFactory n m r -> RepositoryOptions -> m r"
19:44:54 <ahg> both refer to version 3.1.1 of the library, but they seem to conflict
19:45:00 <ahg> am I misunderstanding the docs?
19:58:44 <glguy> ahg: According to the docs 'openRepository' is a field of the 'RepositoryFactory' record type
19:59:21 <glguy> so you can use the 'openRepository' selector as a function to get a 'RepositoryOptions -> m r' out of a 'RepositoryFactory n m r'
20:01:23 <kallisti> we Java now
20:01:33 <kallisti> employing factory labor
20:07:09 <ahg> glguy: hmm, thank you. I clearly have some remedial work to do. :-/
20:09:45 <kallisti> does # mean something special in literate Haskell?
20:18:20 * hackagebot accelerate-examples 0.15.1.0 - Examples using the Accelerate library  https://hackage.haskell.org/package/accelerate-examples-0.15.1.0 (TrevorMcDonell)
20:23:38 <julianleviston> kallisti: I don‚Äôt think it does.
20:25:42 <kallisti> julianleviston: I googled around and found out the issue is with CPP reading the # syntax for some reason
20:25:51 <kallisti> it's part of the GHC 8.0.1 milestone
20:26:03 <julianleviston> kallisti: oh ok :) cool
20:34:37 <thoughtpolice> kallisti: That doesn't necessarily mean it'll get fixed I'm afraid. Unless you offer to try and fix it! :)
20:53:49 * hackagebot reflex-gloss-scene 0.1.2 - A simple scene-graph using reflex and gloss  https://hackage.haskell.org/package/reflex-gloss-scene-0.1.2 (saulzar)
20:53:51 * hackagebot reflex-animation 0.1.5 - Continuous animations support for reflex  https://hackage.haskell.org/package/reflex-animation-0.1.5 (saulzar)
21:08:57 <kallisti> is there anyway to force ghc to compile a file as lhs?
21:16:30 <curunir> Hi
21:16:36 <dmj> hi
21:16:40 <curunir> I had a quick question
21:17:18 <curunir> I have an application that connects to a websocket
21:17:28 <curunir> but if the internet connection dies for some reason
21:17:37 <curunir> the websocket connection dies to
21:17:45 <curunir> too*
21:18:16 <dmj> curunir: yes, go on
21:18:40 <curunir> is there an idiomatic way to poll for reconnection?
21:19:38 <curunir> for reference i'm using the wuss library
21:22:17 <curunir> the code is at github.com/pratyush/haskbullet , if you would like to have a more detailed look
21:24:18 <dmj> curunir: what have you tried so far
21:24:30 <curunir> i don't quite know what to try haha
21:24:48 <curunir> i was thinking a simple while loop to ping for a connection
21:25:13 <curunir> but I think that's too inefficient
21:48:38 <julianleviston> I‚Äôm having some trouble trying to work out how to construct a particular value still. Using groundhog and trying to retrieve a Customer record from the database. I‚Äôve been trying various things since yesterday. Part of my problem is I don‚Äôt really understand how to create a value of the type that Groundhog seems to want‚Ä¶ (IsUniqueKey (Key v (Unique u))) which I think should be some form of an Integer, because 
21:48:38 <julianleviston> that‚Äôs what the key is in the db.  http://hackage.haskell.org/package/groundhog-0.7.0.3/docs/Database-Groundhog-Core.html#t:IsUniqueKey
21:49:26 <julianleviston> the function to get item from the DB seems to be this: getBy :: (Database.Groundhog.Core.PersistEntity v, PersistBackend m, Database.Groundhog.Core.IsUniqueKey (Key v (Unique u))) => Key v (Unique u) -> m (Maybe v)
22:23:41 <elliptic00> class Functor mymaybe where
22:23:41 <elliptic00>     fmap ::(a->b)-> mymaybe a  -> mymaybe b
22:23:41 <elliptic00> instance Functor mymaybe where
22:23:43 <elliptic00>     fmap mymaybe Nothing = Nothing
22:23:45 <elliptic00>     fmap mymaybe (Just a) = Just (mymaybe a)
22:24:12 <elliptic00> I try to define mymaybe, but I get compile error: Ambiguous occurrence ‚ÄòFunctor‚Äô
22:24:14 <liste> elliptic00 are you trying to define your own Maybe type?
22:24:31 <liste> don't define a class then, just instance
22:24:39 <liste> and the type of course
22:25:07 <liste> so "data MyMaybe a = ..." and "instance Functor MyMaybe where ..."
22:25:23 <liste> note that type names must start with capital letters
22:26:29 <elliptic00> Why I can't define my class ?
22:27:16 <liste> elliptic00 you can define a MyFunctor class too (or Functor if you don't import Functor from Prelude)
22:28:03 <liste> which are you trying to define: a class, or a type?
22:29:26 <nitrix> elliptic00: I think your approach is fine, only the implementation of fmap is wrong.
22:29:50 <kallisti> based on the code he printed, he just wants to write an instance of Functor for his type
22:29:53 <srhb> elliptic00: The Functor class already exists. You're trying to define it again with class Functor mymaybe where (where mymaybe is just a type variable). You can't do that. Pick a different name from Functor or hide the Functor class.
22:30:11 <srhb> elliptic00: If you just want to define an instance for MyMaybe (your own type, not mymaybe) just get rid of the class definition.
22:30:22 <kallisti> ellinokon: you need to uppercase your type name. it should be MyMaybe instead of Maybe. a lowercase name at the type level indicates a polymorphic type variable
22:30:31 <kallisti> elliptic00: ^
22:30:43 <kallisti> er, MyMaybe instead of mymaybe
22:31:33 <kallisti> elliptic00: if a class is already defined, it doesn't need to be redefined again. If if you want your MyMaybe to be a Functor, you just need to write an instance declaration; the class declaration already exists in Prelude
22:32:01 <kallisti> if you wanted to make a completely new class for demonstration purposes, you need to give it a different name or hide the existing class.
22:32:47 <quicksilver> in the hxt wiki examples - https://wiki.haskell.org/HXT - there is a helloworld which generates a document from scratch
22:32:52 <quicksilver> helloWorld	:: ArrowXml a => a XmlTree XmlTree
22:33:08 <quicksilver> is there any reason it isn't helloWorld:: ArrowXml a => a () XmlTree?
22:33:19 <quicksilver> it doesn't use its input so I don't understand the type
22:33:53 <elliptic00> data MyMaybe = String
22:33:54 <elliptic00> instance Functor MyMaybe where
22:33:54 <elliptic00>     fmap MyMaybe "dog" = "dog" 
22:34:15 <elliptic00>  ok, I change it a bit, and make it simpler, but it still get compile error
22:34:39 <elliptic00> what should I do, I just try to learn how to define a functor
22:34:51 <Axman6> MyMaybe cannot be a Functor because it has the wrong kind
22:35:23 <Axman6> Functors are things like Maybe, Either a, [], which all accept another type variable
22:35:28 <Axman6> :kind Maybe
22:35:33 <Axman6> :kind Either
22:35:43 <Axman6> lambdabot: ...
22:35:50 <Gurkenglas> :k Maybe
22:35:51 <Axman6> oh right
22:35:51 <lambdabot> * -> *
22:35:52 <Gurkenglas> :k Either
22:35:53 <lambdabot> * -> * -> *
22:35:54 <kallisti> quicksilver: well if it's an arrow it probably composes a bunch of arrows together to create a complete XML doc
22:35:56 <Axman6> @kind Maybe
22:35:57 <lambdabot> * -> *
22:36:00 <Axman6> @kind Either
22:36:01 <lambdabot> * -> * -> *
22:36:02 <Axman6> @kind Either a
22:36:04 <lambdabot> Not in scope: type variable ‚Äòa‚Äô
22:36:05 <kallisti> quicksilver: so maybe those sub-arrows are expecting XmlTree input
22:36:07 <Axman6> @kind Either Int
22:36:08 <lambdabot> * -> *
22:36:45 <nshepperd> elliptic00: I think you may need to review the lessons on data types and classes
22:37:08 <quicksilver> kallisti: mkelem :: String -> [a n XmlTree] -> [a n XmlTree] -> a n XmlTree doesn't use its input and root :: [a n XmlTree] -> [a n XmlTree] -> a n XmlTree doesn't use its input
22:37:22 <quicksilver> here it is - https://wiki.haskell.org/HXT#The_Hello_World_document
22:37:41 <nitrix> Doesn't that fmap implementation breaks one of Functor laws?
22:37:47 <nshepperd> @where learnhaskell
22:37:47 <lambdabot> https://github.com/bitemyapp/learnhaskell
22:38:47 <Axman6> nitrix: it doesn't make sense at all actually
22:40:42 <nitrix> -- elliptic00 |     fmap MyMaybe "dog" = "dog"
22:41:30 <nitrix> That seems wrong. Does Haskell have first-class types? Or some dependently typed extension maybe?
22:41:31 <elliptic00> Not in scope: data constructor ‚ÄòMyMaybe‚Äô
22:41:31 <elliptic00> Failed, modules loaded: none.
22:42:17 <nitrix> elliptic00: Functions accepts values as argument, not types :/
22:42:56 <Axman6> elliptic00: do you know what a Functor is? and what a type class is?
22:43:01 <elliptic00> how can I define my own data structure like Maybe so that I can use fmap?
22:43:18 <Axman6> data MyMaybe a = MyJust a | MyNothing
22:43:30 <Axman6> @let data MyMaybe a = MyJust a | MyNothing
22:43:34 <lambdabot>  Defined.
22:43:45 <Axman6> :t MyJust "Hello"
22:43:46 <nitrix> elliptic00: The implementation should look like: fmap f (MyJust a) = MyJust (f a)
22:43:46 <lambdabot> MyMaybe [Char]
22:43:55 * hackagebot phone-numbers 0.0.1 - Haskell bindings to the libphonenumber library  https://hackage.haskell.org/package/phone-numbers-0.0.1 (ChristianMarie)
22:44:22 <nitrix> elliptic00: Notice how `f` and `(MyJust a)` are both values, the second being pattern matched.
22:44:25 <Axman6> .
22:45:48 <nitrix> elliptic00: This effectively match a value `(MyJust a)` for something of type `MyMaybe`, then f is applied to a, then wrapped back up again using the `MyJust` value constructor, giving you a new `MyMaybe`.
22:47:20 <nitrix> Functors are values with a context that lets you apply a transformation on them, preserving the context.
22:48:50 <nitrix> fmap :: (a -> b) -> f a -> f b,   the transformation is `(a -> b)`, starting with a value `f a`, the result is a `f b`. Notice how `f` is preserved and `a` becomes a `b` by the transformation.
22:48:55 * hackagebot pathwalk 0.2.1.0 - Path walking utilities for Haskell programs  https://hackage.haskell.org/package/pathwalk-0.2.1.0 (chadaustin)
22:49:14 <nitrix> elliptic00: Does that helps a little bit?
22:49:25 <julianleviston> niteria: I don‚Äôt like that definition of Functor very much.
22:49:31 <julianleviston> nitrix:  ^
22:50:09 <nitrix> julianleviston: I hate even more the definition of "something that can be mapped over".
22:50:18 <julianleviston> nitrix: I agree.
22:50:45 <MarcelineVQ> da box http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
22:51:40 <jle`> instead of describing "what are functors?", and "what are monads?", it might be more meaningful to describe what they can be used for
22:52:12 <jle`> a Functor interface is useful for some things that can be mapped over
22:52:22 <jle`> there...it makes no claim about what a Functor *is*
22:52:33 <jle`> and it also helps with a piece of intuition for a specific use case
22:52:33 <julianleviston> jle`: it‚Äôs not very helpful, though, is it?
22:52:53 <jle`> with regard to what question?
22:52:56 <jle`> "what can i use functors for?"
22:52:58 <nitrix> I see his point. He's putting emphasis that Functor is an interface, not something specifically.
22:53:02 <jle`> i would think that is a helpful answer
22:53:13 <jle`> "what is a Functor?" -- it wouldn't be a helpful answer to that question
22:53:19 <julianleviston> Functor provides the fmap function to a datatype that includes a context. The fmap function lets you take a normal function from a to b, and run it on that datatype.
22:53:21 <jle`> but i would say that that isn't really a helpful question anyways
22:53:33 <julianleviston> nitrix: Functor is a typeclass. (Which means, if you don‚Äôt understand what Algebraic DataTYpes and Typeclasses are, you should learn them before even THINKING about looking at Functor.) The typeclass Functor allows you to connect a function called fmap - to a data type that provides a context. 
22:53:34 <jle`> when somebody asks "what is a Functor", they usually mean "what do i use it for?"
22:53:41 <julianleviston> jle`: yep.
22:53:42 <kallisti> learning how to use something is typically a pretty good way to learn something. It has been a very effective form of teaching for a long time now (see: human history)
22:53:50 <julianleviston> kallisti: I agree.
22:53:58 <julianleviston> > fmap (+1) $ Just 5
22:54:00 <lambdabot>  Just 6
22:54:10 <julianleviston> > fmap (+1) [1,2,3,4,5]
22:54:12 <lambdabot>  [2,3,4,5,6]
22:54:29 <jle`> when somebody asks, "what is a monad?", what they really want to know is what they can use monadic interfaces for.  they don't want to know about the theoretical basis...and they probably don't even need to know about the laws
22:54:33 <nitrix> Are those comments directed at me?
22:54:46 <julianleviston> nitrix: no probably not. You know this stuff.
22:54:48 <nitrix> If so, then what is it that needs to be changed from my current definition?
22:55:03 <jle`> but i do think it's a mistake to say, "a monad is..." (and describe an intuitive answer here)
22:55:09 <nitrix> julianleviston: I'm a pedantic person. If my stance is wrong, I'd prefer to know.
22:55:09 <jle`> "a functor is a box" "a functor is a thing that can be mapped over"
22:55:15 <julianleviston> jle`: yeah, but the trouble is, these things are so general‚Ä¶ that you‚Äôre better off NOT answering the question, but rather checking to see if they have the prerequisites for the knowledge.
22:55:24 <jle`> saying what they *are* is misleading/not true
22:55:33 <julianleviston> jle`: neither of those are strictly true.
22:55:35 <kallisti> maybe in other contexts "what is an X?" actually means "what is an X?", but in programming it typically involves knowing how to use something and what its purpose. It's not unique to Haskell either, many people struggle with understanding the purpose of a class in OO design until they see examples of it being a useful concept.
22:55:49 <jle`> julianleviston: that's what i mean...they are not true, because it's not "what they are"
22:55:56 <julianleviston> jle`: yep.
22:56:39 <jle`> but if they ask "what are functor interfaces/monadic interfaces useful for?" then you can give several concrete examples with concrete types
22:56:45 <julianleviston> kallisti: I disagree. You can clearly explain what something is, and explain how to use it, too‚Ä¶ but with Haskell some things (pretty much everything above GADTs) are so abstract that unless you understand the basics, you just cannot understand them.
22:56:52 <julianleviston> jle`: indeed.
22:58:55 * hackagebot phone-numbers 0.0.2 - Haskell bindings to the libphonenumber library  https://hackage.haskell.org/package/phone-numbers-0.0.2 (ChristianMarie)
23:01:31 <julianleviston> kallisti: Functor is a typeclass. It provides the function fmap to its instances. fmap takes a function from a to b, and a value of an algebraic datatype that includes an outer wrappering context (such as the Maybe type does, or such as that the list type does). It lets you apply this function to the value without changing the wrappering (ie its context).
23:02:21 <julianleviston> kallisti: trying to tackle Functor without a good understanding of GADTs, functions, currying, higher order functions, and typeclasses, is (IMO) a mistake.
23:02:51 <MarcelineVQ> gadts reaaly doesn't need a place in the list ^^;
23:02:59 <jle`> i'm not sure that GADTs and currying are too related to understanding the Functor typeclass
23:03:08 <jle`> hopefully not GADT's, because they're not even in standard haskell
23:03:26 <julianleviston> I just mean algebraic datatypes. Sorry :)
23:04:17 <julianleviston> kallisti: any kind of explanation which tries to explain it to someone who doesn‚Äôt have that requisite knowledge will do one of three things: 1. completely fail 2. leave the person very confused and quite annoyed 3. use analogies that are not precise.
23:05:44 <KaneTW> ^
23:05:52 <elliptic00> data MyMaybe a = MyJust a | MyNothing
23:05:52 <elliptic00>  
23:05:52 <elliptic00> instance Functor MyMaybe where
23:05:54 <elliptic00>     fmap f MyNothing = MyNothing
23:05:56 <elliptic00>     fmap f (MyJust a) = MyJust (f a)
23:06:09 <nshepperd> well, one should certainly understand Maybe before trying to understanding it as an example of the Functor interface
23:06:17 <elliptic00> ok, it seems so far, but when I type>   fmap (+2) (MyJust 3) 
23:06:39 <elliptic00> No instance for (Show (MyMaybe b0)) arising from a use of ‚Äòprint‚Äô
23:06:40 <elliptic00>     In the first argument of ‚Äòprint‚Äô, namely ‚Äòit‚Äô
23:06:41 <elliptic00>     In a stmt of an interactive GHCi command: print it
23:06:55 <julianleviston> elliptic00: your type doesn‚Äôt have a show instance.
23:07:06 <julianleviston> elliptic00: you need to understand typeclasses before you tackle this, in my opinion.
23:07:10 <KaneTW> well what does the error tell you
23:07:17 <julianleviston> elliptic00: because if you *did*, then you‚Äôd understand what that error means.
23:07:22 <KaneTW> curse you 3g
23:07:47 <KaneTW> please don't try to learn a language starting from more complicated abstractions
23:07:56 <KaneTW> @where book
23:07:56 <lambdabot> http://haskellbook.com/
23:07:59 <KaneTW> @where learnhaskell
23:07:59 <lambdabot> https://github.com/bitemyapp/learnhaskell
23:08:12 <julianleviston> elliptic00: yes, read that book. It‚Äôs VERY good.
23:08:19 <julianleviston> elliptic00: and it doesn‚Äôt skip steps, as you seem to be doing so now.
23:08:27 <KaneTW> i'm evaluating haskellbook for a class i'll be holding and i can really recommend it
23:08:34 <alcipir> this channel triggers my impostor's syndrome 
23:08:35 <nitrix> Is there a reason why GHC chooses to use a, a1 and a2 instead of arbitrarily other letters?
23:08:37 <elliptic00> Thanks guys, I will read it 
23:08:44 <julianleviston> elliptic00: this is not to be rude or anything like that. We really want you to learn this stuff :)
23:08:57 <julianleviston> alcipir: that‚Äôs unfortunate!
23:09:08 <julianleviston> alcipir: I‚Äôm pretty sure you know more Haskell than me. I wouldn‚Äôt worry.
23:09:08 <nitrix> I understand there's a limited amount of letters, but I'm curious how it comes up with the forms when combining two function types.
23:09:13 <KaneTW> alcipir: impostor's syndrome is the dumbest thing
23:09:20 <KaneTW> it happens to me way too often
23:09:33 <tzh> elliptic00: in this case, specifically the thing you'd want to do is add " deriving (Show)" right under the "data MyMaybe ..." line
23:09:52 <tzh> but yes generally read up on typeclasses i suppose :V
23:09:54 <alcipir> I actually don't know anything about haskell yet, tried to learn it once but it gave me headaches
23:10:11 <julianleviston> alcipir: you should definitely read that book too then.
23:10:25 <freemona_> alcipir: i used scalaz one day, and i finally get typeclasses. if you ask me,  just understand what those are before anything else..
23:10:29 <freemona_> its really simple
23:10:46 <freemona_> from perspective of a noob learning this stuff
23:11:16 <alcipir> julianleviston: you mean this one? http://haskellbook.com
23:11:23 <julianleviston> alcipir: yep.
23:11:33 <julianleviston> alcipir: it goes in stages. it‚Äôs very clear and clean.
23:11:46 <alcipir> nice, I'm going to check it out. thanks
23:11:54 <nshepperd> elliptic00: (In this case the reason for that error is that ghci prints the result of the expression you type in. But it needs a Show instance to know how to do so. But anyway reading that book is a good idea.)
23:12:36 <elliptic00> you are guys are awesome :)), I learn a lots of stuff from your guys...:)
23:12:44 <julianleviston> elliptic00: you are incredibly welcome.
23:13:15 <julianleviston> In the worst case, learning out of order means the person could become a detractor for Haskell and tell everyone ‚ÄúHaskell is too difficult‚Äù and ‚ÄúMonads are so hard‚Äù, or ‚ÄúFunctors are useless‚Äù, when they‚Äôre not. It‚Äôs like getting a 10 year old kids and skipping bike riding and putting them on a motorbike.
23:13:16 <elliptic00> I used to post questions on stackoverflow, but I get banned so I never goback to SO again..
23:15:21 <pharaun> oh you can get banned from so?
23:16:30 <THUGGA> urgh just wasted myself on the mountain bike
23:16:41 <THUGGA> who /sports/ here
23:17:43 <alcipir> I only /lift/
23:18:05 <pharaun> nice
23:18:56 * hackagebot yesod-form 1.4.5 - Form handling support for Yesod Web Framework  https://hackage.haskell.org/package/yesod-form-1.4.5 (MichaelSnoyman)
23:48:57 * hackagebot largeword 1.2.4 - Provides Word128, Word192 and Word256 and a way of producing other large words if required.  https://hackage.haskell.org/package/largeword-1.2.4 (DominicSteinitz)
23:53:36 <Lokathor> I used LargeWord the other day
23:53:41 <Lokathor> but then my RNG broke :/
23:55:48 <Cale> Lokathor: down on your luck?
