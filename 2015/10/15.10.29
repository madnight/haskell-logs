00:07:38 * hackagebot concurrent-output 1.0.1 - handling concurrent output  https://hackage.haskell.org/package/concurrent-output-1.0.1 (JoeyHess)
00:07:38 * hackagebot nationstates 0.5.0.0 - NationStates API client  https://hackage.haskell.org/package/nationstates-0.5.0.0 (ChrisWong)
00:17:54 * hackagebot argon 0.3.1.1 - Measure your code's complexity  https://hackage.haskell.org/package/argon-0.3.1.1 (rubik)
00:27:54 * hackagebot argon 0.3.1.2 - Measure your code's complexity  https://hackage.haskell.org/package/argon-0.3.1.2 (rubik)
00:50:42 <carglass-rep> at some time, there was a nice haskell module just called "wikipedia" I think, but it's no longer on hackage. Any idea why?
00:50:51 <statusfailed> I have a tree structure like "data Tree a = Leaf a | Node (Tree a) (Tree a)", I want to annotate leaves with a unique number so I have a "Tree (Int, a)". Is there a "-morphism" that does this?
00:51:51 <statusfailed> carglass-rep: is that the one with the dead-simple API ? 
00:53:53 <Profpatsch> ,pl \a -> map (*a)
00:54:07 <carglass-rep> I think so, it seemed really easy to use
00:54:19 <statusfailed> carglass-rep: Ah, I think it was this: https://github.com/guoguo12/aether
00:54:20 <statusfailed> is that the one?
00:54:49 <statusfailed> Here's the reddit post: https://www.reddit.com/r/haskell/comments/1pzymv/code_review_request_wikipedia_api_for_haskell/
00:54:50 <Cale> statusfailed: That's like the easiest example of something that the State monad is good at.
00:55:07 <Cale> I like to use it as one anyway :)
00:55:31 <Profpatsch> how to point-free?
00:55:44 <Profpatsch> ,pf?
00:55:46 <statusfailed> Cale: So you would deconstruct + reconstruct the tree tracking nodes with State? 
00:55:51 <Cale> Profpatsch: @pl
00:56:18 <Cale> statusfailed: So you'd have something like   label :: State Int Int; label = do n <- get; put (n+1); return n
00:56:42 <carglass-rep> statusfailed: Oh, yeah. it's that one. But why isn't it in hackage ?
00:56:43 <Cale> and then  relabel' :: Tree a -> State Int (Tree (Int, a))
00:56:55 <Profpatsch> pl \a -> map (*a)
00:57:02 <Profpatsch> @pl \a -> map (*a)
00:57:02 <lambdabot> map . (*)
00:57:09 <Profpatsch> what.
00:57:09 <Cale> relabel' (Leaf x) = do n <- label; return (Leaf (n,x))
00:57:24 <Profpatsch> Cale: Thanks!
00:57:44 <Cale> relabel' (Node l r) = do l' <- relabel' l; r' <- relabel' r; return (Node l' r')
00:57:52 <statusfailed> carglass-rep: IIRC it never got uploaded? The reddit post was a code review request
00:57:55 <statusfailed> could be wrong tho
00:58:03 <Cale> and then you can write:
00:58:11 <Cale> relabel :: Tree a -> Tree (Int, a)
00:58:24 <Cale> relabel t = evalStateT (relabel' t) 0
00:58:27 <Cale> er
00:58:30 <carglass-rep> statusfailed: mmh, maybe. But I think I remember cabal install'ing it
00:58:30 <Cale> relabel t = evalState (relabel' t) 0
00:58:34 <Cale> no T :)
00:59:16 <statusfailed> Cale: That makes sense! Seems like the pattern of deconstructing + reconstructing the tree could be generic though, is there a technique to do that?
00:59:27 <Cale> statusfailed: If you weren't using the State monad, you'd find that you'd have to take an extra parameter: the next available label to use, and produce an extra result alongside the relabelled tree: again, the next available label after relabelling that whole subtree
01:00:03 <Cale> This is a tree catamorphism, I suppose.
01:00:13 <Cale> hmm
01:00:38 <Cale> @let data Tree a = Leaf a | Branch (Tree a) (Tree a)
01:00:39 <lambdabot>  .L.hs:175:23:
01:00:40 <lambdabot>      Ambiguous occurrence ‘Tree’
01:00:40 <lambdabot>      It could refer to either ‘L.Tree’, defined at .L.hs:174:1
01:00:44 <Cale> err
01:00:48 <Cale> @let data BinTree a = Leaf a | Branch (Tree a) (Tree a)
01:00:49 <lambdabot>  Defined.
01:00:52 <Cale> ugh, no!
01:00:54 <Cale> @undefine
01:00:54 <lambdabot> Undefined.
01:00:55 <statusfailed> haha
01:01:01 <Cale> @let data BinTree a = Leaf a | Branch (BinTree a) (BinTree a)
01:01:02 <statusfailed> didn't spot that :D
01:01:03 <lambdabot>  Defined.
01:01:36 <Cale> @let foldTree l b = f where f (Leaf x) = l x; f (Branch u v) = b (f u) (f v)
01:01:37 <lambdabot>  Defined.
01:02:10 <Cale> @let label = do n <- get; put (n+1); return n
01:02:11 <lambdabot>  Defined.
01:02:55 <Cale> :t foldTree (\x -> do n <- label; return (Leaf x)) (\l r -> do l' <- l; r' <- r; return (Branch l' r'))
01:02:56 <lambdabot>     Ambiguous occurrence ‘label’
01:02:56 <lambdabot>     It could refer to either ‘L.label’,
01:02:56 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:148:1
01:03:05 <Cale> dang, lambdabot pls
01:03:10 <statusfailed> XD
01:03:14 <Cale> @let freshLabel = do n <- get; put (n+1); return n
01:03:16 <lambdabot>  Defined.
01:03:23 <Cale> :t foldTree (\x -> do n <- freshLabel; return (Leaf x)) (\l r -> do l' <- l; r' <- r; return (Branch l' r'))
01:03:24 <lambdabot> (Num t, MonadState t m) => BinTree a -> m (BinTree a)
01:03:51 <Cale> So, you're substituting tree structure for program structure in a state monad.
01:04:06 <statusfailed> Cale: Program structure?
01:04:35 <Cale> foldTree l b is the function which replaces each occurrence of Leaf in the tree with l and each occurrence of Branch with b
01:04:35 <statusfailed> Cale: are you referring to the 'leaf' and 'branch' arguments of foldTree ?
01:04:40 <statusfailed> Ah OK
01:05:05 <statusfailed> OK that makes sense
01:05:31 <Cale> > foldTree Leaf (flip Branch) (Branch (Branch (Leaf 1) (Leaf 2)) (Branch (Leaf 3) (Leaf 4)))
01:05:33 <lambdabot>      No instance for (Show (BinTree a0))
01:05:33 <lambdabot>        arising from a use of ‘show_M689466092387344412921099’
01:05:33 <lambdabot>      In the expression:
01:05:45 <statusfailed> So your l and b are the same as the TreeAlgebra here: http://stackoverflow.com/questions/4434292/catamorphism-and-tree-traversing-in-haskell
01:05:48 <statusfailed> ?
01:05:50 <Cale> @let deriving instance Show a => Show (BinTree a)
01:05:52 <lambdabot>  Defined.
01:05:53 <Cale> > foldTree Leaf (flip Branch) (Branch (Branch (Leaf 1) (Leaf 2)) (Branch (Leaf 3) (Leaf 4)))
01:05:55 <lambdabot>  Branch (Branch (Leaf 4) (Leaf 3)) (Branch (Leaf 2) (Leaf 1))
01:06:10 <statusfailed> oh cool!!
01:06:17 <statusfailed> That is very nice
01:06:39 <Cale> > foldTree id (+) (Branch (Branch (Leaf 1) (Leaf 2)) (Branch (Leaf 3) (Leaf 4)))
01:06:40 <lambdabot>  10
01:07:19 <Cale> > foldTree (:[]) (++) (Branch (Branch (Leaf 1) (Leaf 2)) (Branch (Leaf 3) (Leaf 4))) -- slow way to do a traversal
01:07:21 <lambdabot>  [1,2,3,4]
01:07:50 <Cale> Slow because xs ++ ys takes O(length xs) steps to fully evaluate
01:08:01 <Cale> so this is quadratic on left leaning trees
01:08:02 <ocramz> hi all
01:08:11 <statusfailed> Cale: right
01:08:19 <Cale> But we can instead produce a function which adds elements to the beginning of a list
01:08:22 <statusfailed> Cale: (Thanks btw, this is really helpful)
01:08:58 <Cale> > foldTree (\x -> (x:)) (.) (Branch (Branch (Leaf 1) (Leaf 2)) (Branch (Leaf 3) (Leaf 4))) [] -- we apply the resulting function to an empty list to collect the elements into an ordinary list again
01:09:02 <lambdabot>  [1,2,3,4]
01:09:16 <Cale> of course, I could have just written (:) instead of (\x -> (x:))
01:11:11 <statusfailed> Cale: so does "foldTree" have a name (like "catamorphism" or "tree algebra" or something? :D)
01:11:45 <Cale> Yeah, it's basically the generic tree catamorphism
01:11:58 <ocramz> statusfailed: foldTree sounds good enough already :D
01:12:01 <Cale> You give it the algebra in parts as arguments
01:12:11 <statusfailed> ocramz: haha I meant the class of thing it belongs to :p
01:12:15 <statusfailed> but agreed otherwise ^^
01:12:32 <statusfailed> Cale: final question: when you say "algebra", which "algebra" does that refer to?
01:13:14 * hackagebot stripe-core 2.0.0 - Stripe API for Haskell - Pure Core  https://hackage.haskell.org/package/stripe-core-2.0.0 (DavidJohnson)
01:13:16 <Cale> Oh, well, do you know what a functor is in the category theoretic sense?
01:14:00 <Cale> https://en.wikipedia.org/wiki/F-algebra -- it's this sort of algebras we're talking about
01:14:13 <Cale> Only in our case the choice of functor F has become implicit
01:14:17 <statusfailed> Cale: Still on Chapter 1 of CTCS I'm afraid :p
01:15:45 <Cale> How about just in Haskell, actually?
01:15:55 <Cale> Do you know about the Functor class?
01:16:18 <statusfailed> Cale: yep!
01:16:47 <Cale> Okay, so hmm, I don't think I want to do the tree example first :)
01:17:02 <Cale> Let's start with the relationship between Maybe and Nat
01:17:52 <statusfailed> Cale: OK
01:18:14 * hackagebot stripe-haskell 2.0.0 - Stripe API for Haskell  https://hackage.haskell.org/package/stripe-haskell-2.0.0 (DavidJohnson)
01:18:16 * hackagebot stripe-http-streams 2.0.0 -   https://hackage.haskell.org/package/stripe-http-streams-2.0.0 (DavidJohnson)
01:18:47 <Cale> So, okay, in general, if F is a functor, then an F-algebra is some choice of type A, and function a: F A -> A
01:19:07 <Cale> a :: F A -> A, I guess, we're using Haskell syntax :)
01:19:33 <statusfailed> OK, with you so far
01:20:11 <Cale> and given two F-algebras, say (A,a) and (B,b), an F-algebra homomorphism is a function f: A -> B such that f . a = b . f
01:20:29 <Cale> https://en.wikipedia.org/wiki/F-algebra has a nice diagram showing the square
01:21:17 <Cale> We're going to explore how this works out in detail for an example in a moment
01:21:25 <Cale> But does that basically make sense as a definition?
01:22:30 <statusfailed> Cale: Yeah, I think so
01:22:34 <Cale> In particular, let's have a look at what it means to be a Maybe-algebra homomorphism between two Maybe-algebras
01:22:58 <Cale> So, we have functions a :: Maybe A -> A, and b :: Maybe B -> B
01:23:26 <Cale> oh, sorry, I messed that up above!
01:23:33 <Cale> I am kinda tired!
01:23:40 <Cale> f . a = b . fmap f
01:23:51 <Cale> my equation didn't typecheck
01:24:01 <statusfailed> hang on, gonna take some notes :D
01:24:03 <Cale> So fmap f :: F A -> F B
01:24:08 <Cale> and then b :: F B -> B
01:24:11 <Cale> or
01:24:16 <Cale> a :: F A -> A
01:24:21 <Cale> and then f :: A -> B
01:24:34 <Cale> these two paths from F A to B are equal
01:25:06 <Cale> So, let's look at it in the Maybe case, we have these
01:25:10 <Cale> a :: Maybe A -> A, and b :: Maybe B -> B
01:25:14 <Cale> and f :: A -> B
01:25:31 <Cale> and f is supposed to satisfy  f . a = b . fmap f
01:25:43 <Cale> well, what does that mean? Let's apply it to Nothing
01:25:46 <statusfailed> Cale: sorry, i'm a bit behind hang ona sec! :D
01:25:57 <Cale> all right, let me know :)
01:26:05 <Cale> and/or feel free to ask questions
01:26:28 <statusfailed> So the homomorphism is "f . a = b . fmap f" right ?
01:26:54 <Cale> yeah, that's the property that the function f has to satisfy in order that it be called an F-algebra homomorphism
01:27:04 <Cale> rather than just a not-so-special function A -> B
01:27:12 <statusfailed> OK 
01:27:19 <statusfailed> oh, OK right
01:27:43 <Cale> an F-algebra homomorphism from (A,a) to (B,b), more pedantically
01:28:33 <statusfailed> Cale: that's the distinction between functions that have different domains but the same definition in CT right?
01:28:40 <Cale> uhh
01:28:49 <statusfailed> or not? haha
01:28:49 <Cale> hmm
01:28:59 <Cale> I can't think of how that would be the case :)
01:29:23 <statusfailed> Cale: x^2 on R+ vs x^2 on R for example
01:30:22 <statusfailed> anyway I think I'm following, so applying "f" to Nothing... 
01:30:55 <Cale> okay
01:31:07 <Cale> Actually, I'm going to apply both sides of the equation to Nothing
01:31:08 <Cale> so
01:31:21 <Cale> we have f (a Nothing) = b (fmap f Nothing)
01:31:27 <Cale> but fmap f Nothing = Nothing
01:31:40 <Cale> by the Functor instance for Maybe
01:31:52 <Cale> So that simplifies to  f (a Nothing) = b (Nothing)
01:32:07 <Cale> er, spurious parens :)
01:32:10 <Cale> But yeah
01:32:17 <Cale> and in the Just x case?
01:33:08 <Cale> We should have  f (a (Just x)) = b (fmap f (Just x))
01:33:25 <Cale> fmap f (Just x) = Just (f x)
01:33:41 <Cale> So  f (a (Just x)) = b (Just (f x))
01:34:41 <statusfailed> OK
01:34:57 <statusfailed> That looks familiar somehow :D
01:35:14 <MarcelineVQ> Sure does :>
01:35:24 <Cale> Okay, so let's consider the type Nat of natural numbers
01:35:43 <Cale> data Nat = Zero | Succ Nat
01:35:51 <Cale> and the function  n :: Maybe Nat -> Nat
01:35:58 <Cale> n Nothing = Zero
01:36:07 <Cale> n (Just k) = Succ k
01:36:34 <Cale> This Maybe-algebra (Nat,n) has a very special property
01:37:04 <Cale> For any other Maybe-algebra (B,b), there is a unique Maybe-algebra homomorphism from (Nat,n) to (B,b)
01:37:55 <Cale> Let's have a look at it, what would a Maybe-algebra homomorphism from (Nat,n) to (B,b) satisfy? Well, we just worked out some equations
01:37:57 <Cale> We said that
01:38:08 <Cale> f (n Nothing) = b (Nothing)
01:38:14 <Cale> which now we can simplify further:
01:38:21 <Cale> f Zero = b Nothing
01:38:34 <Cale> and we also said that
01:38:45 <Cale> f (n (Just x)) = b (Just (f x))
01:38:57 <Cale> which we can simplify further to
01:39:13 <Cale> f (Succ x) = b (Just (f x))
01:39:27 <Cale> So we have a recursive definition for f!
01:39:34 <Cale> f Zero = b Nothing
01:39:36 <Cale> f (Succ x) = b (Just (f x))
01:39:47 <statusfailed> wait how did that happen
01:39:50 <statusfailed> :|
01:39:51 <statusfailed> :D
01:40:52 <Cale> No matter which Maybe-algebra (B,b) happens to be, this function f is uniquely determined
01:41:05 <Cale> We can write a function which takes b and gives f
01:41:41 <Cale> cata b = f where f Zero = b Nothing; f (Succ x) = b (Just f x)
01:43:39 <Cale> But we can also always decompose a function b :: Maybe B -> B into the information about where Nothing is sent, i.e. b Nothing in B, and a function B -> B which explains what to do with the Justs, namely the function b . Just
01:43:58 <Cale> Sometimes it's more convenient to take those parts separately:
01:44:28 <statusfailed> Ahhh OK- so the "split up" F-algebra is just passing "b : F B -> B" as a set of cases
01:44:42 <Cale> i.e. take the arguments z = b Nothing, and s = b . Just
01:44:45 <statusfailed> but it's still defining a total function "F B -> B"
01:45:23 <Cale> foldNat z s = f where f Zero = z; f (Succ x) = s (f x)
01:45:58 <Cale> yeah, I'm just sort of pulling that function Maybe B -> B apart into two things
01:46:24 <Cale> so we don't have to write the function Maybe B -> B, we instead just provide a value z :: B, and function s :: B -> B
01:46:41 <Cale> just two ways of representing the same data
01:46:44 <statusfailed> Oh, so the "Algebra" of F-Algebra is like what "primitive operations" are available in F (if F was a DSL for example)
01:46:56 <Profpatsch> @pl \f g -> filter f . map g
01:46:57 <lambdabot> (. map) . (.) . filter
01:47:04 <Cale> Well, the reason for the word "algebra" is pretty strained
01:47:19 <statusfailed> haha
01:47:26 <Cale> The original reason comes from a related definition of monad algebras
01:47:49 <statusfailed> Oh OK :-)
01:48:03 <Cale> When T is some monad, we usually don't want to consider just any function T A -> A to be an algebra, there are some extra conditions we impose, based on the monad operations
01:48:16 * hackagebot safeint 0.6 - overflow-checked Int type  https://hackage.haskell.org/package/safeint-0.6 (AndresLoeh)
01:48:19 <Cale> e.g. if we apply join :: T (T A) -> T A
01:48:29 <Cale> and then our algebra map T A -> A
01:49:01 <Cale> that ought to be the same as applying fmap of our algebra map to go T (T A) -> T A
01:49:06 <Cale> and then applying the algebra map again
01:49:09 <Cale> T A -> A
01:49:37 <Cale> and if we apply return :: A -> T A
01:49:43 <Cale> and then the algebra map T A -> A
01:49:49 <Cale> we want that composite to be the identity
01:50:24 <Cale> These are sort of the "obvious laws", if you do enough category theory you get a knack for just writing down what the obvious conditions would be :)
01:50:32 <Cale> But anyway
01:50:41 <statusfailed> Cale: That was super helpful!!
01:50:44 <statusfailed> Thank you so much :-)
01:50:49 <Cale> There are monads on the category of sets, whose algebras are exactly the algebraic structures of certain sorts
01:50:59 <Cale> e.g. there is a monad whose algebras are rings
01:51:08 <Cale> and there is a monad whose algebras are vector spaces
01:52:11 <Cale> and where the "evaluation map"  T A -> A  in the case of something like the monad for rings essentially takes a "ring expression" with values of the set A in it, and evaluates it according to the ring operations
01:52:16 <frerich> Profpatsch: If you have some function '(a -> Bool) -> a -> Maybe a' then you could maybe benefit from using mapMaybe
01:53:44 <Cale> So because this ends up generalising a wide range of algebraic things (there are monads on Set whose algebras correspond to monoids, groups, rings, vector spaces, boolean algebras, lattices, basically anything which is a set with some operations and equational laws on those operations)
01:53:56 <Cale> that's why the word "algebra" got used
01:54:06 <Cale> and then it was sort of abstracted
01:54:24 <Cale> but yeah, it's like our map F A -> A is providing some sort of "evaluation" of some syntax
01:54:44 <Cale> you can think of it like that even in the functor case
01:57:51 <brnhy> Anyone around with type family / inference knowledge that could take a look at a piece of code? 
01:59:19 <statusfailed> Cale: Ahh, that makes sense
01:59:47 <Cale> statusfailed: In the tree case, the relevant functor would be something like
02:00:06 <ocramz> brnhy: Brendan from amazonka ? try us :D
02:00:14 <Cale> data TreeF a t = L a | B t t
02:00:51 <Cale> instance Functor (TreeF a) where fmap f (L a) = L a; fmap f (B l r) = B (f l) (f r)
02:01:47 <brnhy> ocramz: Unfortunately, it's OAuth shenanigans. I'm attempting to use singleton scopes for authorisation purposes. But I'd like to know if the set of scopes used by requests can in fact be inferred, and doesn't need to be explicitly annotated: https://gist.github.com/brendanhay/600877b5017ca3242b2d
02:02:42 <ocramz> I too have a question, on mutable data: https://www.reddit.com/r/haskell/comments/3qljk9/kludge_lifting_datavector_functions_to_storable/ -- when I use the resulting, modified Vec, after returning from this function, it is not modified. GHC doesn't recompute it (laziness?). How do I make it recompute it? What idiomatic way is there in Haskell to work with mutable data across the FFI?
02:03:15 <Cale> statusfailed: and then you can also look at a function TreeF a r -> r as a pair of functions a -> r, and r -> r -> r
02:03:38 <Cale> statusfailed: and that gives you the TreeAlgebra type from the SO post
02:10:43 <ocramz> brnhy: sorry, your code uses a number of idioms I'm not familiar with.. can't help :/
02:11:00 <brnhy> ocramz: no problem. Likewise with mutable vectors :)
02:13:39 <ocramz> brnhy: for example: what does this do? : `instance Request Example1 where type Scopes Example1 = '["http://scope1"]`
02:14:04 <ocramz> you are declaring `Example1` to be "temporarily" an instance of Request
02:14:06 <ocramz> ?
02:14:33 <ocramz> the tick makes it look like a lens.. I'm confused
02:14:49 <brnhy> It's a regular instance, with an associated type (family) synonym
02:15:10 <brnhy> The tick is required for data type promotion
02:15:27 <brnhy> In this case a singleton list: '["http://scope1"]
02:16:09 <ocramz> "datatype promotion" means that something that has a type is promoted to having a kind?
02:17:57 <ocramz> btw thanks Cale for the long example on algebras, did a little reading on the wiki article on F-algebras, looks like an important starting point for many things
02:18:34 <Cale> kind of, yes :)
02:18:49 <brnhy> Yes, there's some info (and further reading) about data type promotion here: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/promotion.html
02:22:01 <ocramz> nice, thanks brnhy
02:23:43 <Yrarr> I'm searching for a way to set optimization level in cabal. ghc-options field doesn't help (changing it doesn't force recompilation). -On flags only work for install, but not for build (and I'd like only to build). Any ideas ?
02:26:07 <brnhy> Yrarr: could you set the ghc-options field behind a conditional, which in turn is set via a flag? That way changing the flag would force recompilation?
02:27:18 <Yrarr> brnhy: Well, the problem is that when I manually change the flag in ghc-options, it doesn't force recompilation. I'm not sure why this happens... Using if statement in cabal could change that ?
02:29:04 <brnhy> I'm not completely sure to be honest, I'd need to test, but by conditional I was referring to something like: https://gist.github.com/brendanhay/8d76eceede2de7219671
02:38:05 <Yrarr> brnhy: I've tried it. It didn't force recompilation :/
02:41:13 <brnhy> Seems strange. stack has the ability to choose to recompile or not when the options change: https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md#rebuild-ghc-options
02:42:43 <ely-se> is there any disadvantages to using newTVarIO instead of atomically . newTVar?
02:44:26 <Yrarr> "However, in most cases, the flag is used to affect optimization levels and warning behavior, for which GHC itself doesn't actually recompile the modules anyway. " Changing optimization level does not require recompilation ?... 
02:47:23 <Yrarr> Or is it that the statement "for which GHC itself doesn't actually recompile the modules anyway" is true only for the warning behaviour ?
02:54:49 <tesrty> I wrote a function that finds the minimum for a list that has only values -1, 0 and 1. I'm confused as to why ghc feels its non-exhaustive.
02:54:52 <lpaste> tesrty pasted “non-exhaustive function” at http://lpaste.net/5678036568783192064
02:55:30 <tesrty> if I understand "Patterns not matched: _ : (_ : _)" correctly it says that if the function gets passed a list that has another list within there is no pattern match
02:55:57 <tesrty> How would that not just match (x:xs) however?
02:56:54 <Yrarr> Maybe add otherwise -> ?
02:57:09 <lyxia> tesrty: it only matches (x:xs) if the guard is satisfied.
02:57:13 <tesrty> Of course. My bad. Second time this happened to me.
02:57:32 <tesrty> Yea if the guard is exhaustive. which of course it isn't. Thanks guys!
03:00:31 <ocramz> vijaykiran : hi :) you're the organizer of Functional Rotterdam, right?
03:00:41 <Ongy> davean: did you hear anything from max treskin? because of the netlink package
03:00:50 <vijaykiran> ocramz: yes, sir, I am
03:02:52 <ocramz> vijaykiran : nice to meet you; haven't had the chance to come over yet (I've been to FP AMS a few times), but I'd be mostly interested in Haskell-related talks :) how's the language mixture in the meetup?
03:03:18 * nomeata has trouble reading the tone of https://twitter.com/shebang/status/659026753873170432. Is Roman mocking me? Or did he simply find it it funny what I wrote? Or both?
03:04:10 <vijaykiran> ocramz: nice to meet you too :) the first talk was PureScript :) we have clojure/scala and some Haskell guys showing up, but it was only two events so far - next one is on Nov 3rd, if you want to join
03:04:25 <vijaykiran> ocramz: or better yet, if you want give a Haskell talk ;)
03:05:13 <tdammers> FP AMS, huh
03:05:24 <ocramz> tdammers, holla
03:05:29 <tdammers> o/
03:05:43 <tdammers> didn't know there was a rotterdam meetup too
03:06:29 <vijaykiran> tdammers: http://www.meetup.com/Functional-Rotterdam/
03:07:42 <tdammers> maybe I should go some time
03:08:45 <vijaykiran> tdammers: I'd like to have more haskellers 
03:09:35 <tdammers> I'm a bit low on time these days, but still, ...
03:10:21 <tdammers> either way, I find it interesting how there's this huge schism in the FP world between typed and untyped FP
03:10:31 <ocramz> vijaykiran: what kind of talks you'd like to have? theory- or engineering-oriented?
03:11:20 <ocramz> tdammers: I think the schism is all in our heads; everybody else is busy shipping PHP and node
03:11:25 <ocramz> :D
03:11:34 <tdammers> welp
03:11:35 <vijaykiran> ocramz: I don't mind - personally theory is lacking usually - so I'd like that 
03:12:06 <tdammers> nodejs isn't all that different from clojure IMO
03:12:23 <gpyh> hi ; sorry to bother you but I'm facing a blocking issue with cabal. Any 'cabal update' give me 'cabal: does not exist'. I'm on Arch and I've only found a single occurence of this problem, but the guy that solved it didn't explain what was going on
03:12:41 <vijaykiran> ocramz: one thing I'm planning forever to talk about is that Fold is the universal thingy - paper
03:13:00 <vijaykiran> ocramz: partially with a hope that some one more qualified than I am would do that ;)
03:13:25 <vijaykiran> ocramz: but If you have something in mind, please do let me know 
03:13:38 <tdammers> how about "what Rich Hickey got wrong"?
03:13:40 <tdammers> :x
03:14:01 <ocramz> vijaykiran: aka "all the crazy shit you didn't know you can do with catamorphisms"
03:14:17 <quchen> gpyh: What does "which cabal" give you?
03:14:17 <ocramz> the one by Hutton, right?
03:14:24 <vijaykiran> tdammers: I'd be furious at night - being a clojure guy at Night :) 
03:14:35 <gpyh> quchen: /usr/bin/cabal
03:14:53 <tdammers> vijaykiran: I do it the other way around - write clojure to pay the bills, hack Haskell stuff at night
03:15:04 <vijaykiran> ocramz: A tutorial on universality and expressiveness thingy
03:15:14 <quchen> gpyh: /usr/bin/cabal update?
03:15:17 <ocramz> yeah: http://www.cs.nott.ac.uk/~pszgmh/fold.pdf
03:15:21 <vijaykiran> tdammers: that's what I'm doing now - Scala by day, Clojure by night and Haskell/Frege in the Weekend
03:15:41 <tdammers> weekends are for family and running
03:15:48 <ocramz> a-men
03:15:51 <quchen> Running GHC!
03:15:57 <ocramz> quchen: :D
03:16:08 <tdammers> but, anyway; I watched hickey's "simple and easy" talk the other day, and a few things kind of rubbed me the wrong way
03:16:28 <vijaykiran> tdammers: I'd like to hear more.
03:16:45 <tdammers> I was hoping to get some insights into why he designed things the way he did, but didn't get the answers I was hoping for
03:16:50 <vijaykiran> ocramz: I kind of have a hunch that the fold paper and transducers are a linked 
03:17:07 <tdammers> ofc opening with a stupid dismissive joke about CT doesn't really help win me over
03:17:25 <tdammers> but anyway, he talks about simplicity, and how it's an objective thing
03:17:32 <vijaykiran> CT ?
03:17:40 <tdammers> category theory
03:17:41 <gpyh> quchen: you're telling me it happens because I have a running ghc?
03:18:09 <tdammers> the way he jokes about the theory suggests that he thinks it's all academic nonsense and doesn't apply to programming
03:18:19 <quchen> gpyh: No, that was an unrelated remark.
03:18:28 <quchen> "Does not exist" sounds like a $PATH problem.
03:18:35 <tdammers> but IMO, that's a bit like saying that newton's laws don't apply at all just because you can successfully navigate everyday life without knowing the formulae
03:18:48 <gpyh> apparently it's related to a network problem but I have no way to troubleshoot it
03:18:59 <vijaykiran> tdammers: I'm not sure if that's the case, given that he keeps referring to academic research 
03:19:09 * hackagebot pandoc-plantuml-diagrams 0.1.0.3 - Render and insert PlantUML diagrams with Pandoc  https://hackage.haskell.org/package/pandoc-plantuml-diagrams-0.1.0.3 (thriqon)
03:19:12 <gpyh> quchen: cabal -V runs fine though
03:19:25 <ocramz> vijaykiran: there seems to be some work going on about that: https://hackage.haskell.org/package/foldl-transduce
03:19:28 <quchen> gpyh: Are the paths in your .cabal/config right?
03:19:28 <hexagoxel> "does not exist" can happen if the current directory does not exist (reproducably)
03:19:43 <tdammers> well that's kind of the thing - the entire talk makes a tremendously good case for Haskell, I just don't see where Clojure scores any better, except maybe on the "easy" scale
03:19:52 <quchen> I think I once had a similar issue that I got by copying that file to a different machine with a different $HOME name, mismatching the one in .cabal/config
03:19:53 <vijaykiran> ocramz: I saw some blogpost about bringing transducers to Haskell
03:19:58 <quchen> Got to go though, sorry :-|
03:20:01 <tdammers> (which, as he stresses a lot, is a very subjective thing)
03:20:29 <vijaykiran> tdammers: for me the main pain point is the tools/ecosystem etc. although stack is something that's taking things in right direction
03:20:39 <tdammers> huh
03:20:44 <vijaykiran> tdammers: and of course, all my bills are paid by software running on JVM
03:20:54 <tdammers> I consider the clojure toolchain inferior to Haskell's in almost every possible way
03:21:03 <tdammers> if JVM is a given; sure
03:21:15 <tdammers> but I prefer "Unix" as a platform over JVM
03:21:22 <ocramz> tdammers: word
03:21:22 <vijaykiran> tdammers: you mean lein new and start hacking... vs cabal update install etc. ?
03:21:40 <gpyh> quchen: checked it ; everything exists
03:22:21 <tdammers> vijaykiran: I mean stuff like how you get to choose between "120 seconds development cycle round trips for a full restart" and "fast development cycles, but results aren't reliable"
03:22:55 <tdammers> vijaykiran: or how you're expected to structure your workflow around a REPL
03:23:14 <tdammers> vijaykiran: don't get me wrong, REPLs are great, but they're not great enough to be the *only* tool on your belt
03:24:03 <vijaykiran> tdammers: yup, I understand - as I said I don't have enough experience of building a reasonably complex system in Haskell - so my comparisons are worthless at this point 
03:24:18 <tdammers> cabal isn't comfortable either
03:24:53 <vijaykiran> tdammers: and I mostly wrote Java for good part of 15 years :) most of them were and still are pretty reliable 
03:25:26 <tdammers> well, I'm thinking, I'd probably have an easier time writing reliable software in Java than in Clojure
03:26:07 <tdammers> in fact, this library I just wrote in Clojure resorts to extensive Java interop to achieve soundness without compromising performance
03:26:36 <tdammers> I basically define classes from within Clojure, there's hardly anything dynamic about it
03:27:01 <vijaykiran> tdammers: did you take a look at Frege ?
03:27:08 <tdammers> vijaykiran: planning to
03:27:34 <tdammers> vijaykiran: my thought is that Frege might be the thing I need to sneak Haskell into this workplace
03:27:55 <tdammers> biggest challenge is to convince the youngsters of the benefits of static type checks
03:28:15 <nomeata> edsko: I saw you recently worked on tar
03:28:26 <nomeata> edsko: are you aware that tar (or its test suite) is broken on 32 bit arches:
03:28:31 <nomeata> https://buildd.debian.org/status/package.php?p=haskell-tar&suite=experimental
03:28:37 <nomeata> e.g. https://buildd.debian.org/status/fetch.php?pkg=haskell-tar&arch=i386&ver=0.4.2.1-2&stamp=1440196291
03:28:39 <edsko> nomeata : you should talk to Duncan
03:28:48 <edsko> nomeata : I only fixed one bug in the tar index generation code
03:28:48 <nomeata> I sent him a mail twice, no reply so far
03:28:52 <nomeata> hmm, ok.
03:28:56 <edsko> nomeata : he's a busy guy :)
03:28:57 <frerich> I'm working at a C++ shop, and my biggest challenge was to convince people to not OOP'ify everything. By now, many agree that a plain free function defined in terms of its arguments is more encapsulated than a private method. :-)
03:28:59 <nomeata> I know
03:29:11 <tdammers> tee hee
03:29:25 <nomeata> Hence nudging you, hoping you’d feel a bit reponsible for the library :-)
03:29:42 <tdammers> frerich: when I write C++ these days, I find myself producing insane levels of templating
03:30:37 <frerich> tdammers: For me, the reverse is true - I use less and less features of C++. In fact, I almost use it like C except for destructors and an occasional (simple) template, I think.
03:30:49 <vijaykiran> ocramz: are you interested in giving that magical fold talk :) ? 
03:30:58 <tdammers> frerich: well, I hardly use the OOP features at all
03:31:19 <tdammers> frerich: except ofc where needed to define data types
03:31:32 <tdammers> frerich: but whether that qualifies as OOP stands to reason
03:31:49 <ocramz> vijaykiran: in abstract, yes (however I'd first have to prepare for it). In concrete, I'm finishing my PhD so can't do it, for the foreseeable months..
03:32:34 <vijaykiran> ocramz: ah, then perhaps if you can find some time, do drop by at the meetup 
03:32:59 <vijaykiran> tdammers: ^^ for you too :) so we can have some nice discussions 
03:35:01 <mrkkrp> which sort of smart constructors is generally preferable, those that throw exception on invalid arguments or those that transform invalid arguments to valid?
03:37:45 <ely-se> mrkkrp: those that restrict input to possible value types or those that return Either, Maybe or some other type that can indicate failure
03:38:46 <ely-se> exceptions should be a last resort; they aren't checked by the automatic bug detector (aka type checker)
03:40:13 <mrkkrp> ely-se: well, that's obvious, but why then http://haddock.stackage.org/lts-3.11/base-4.8.1.0/Numeric-Natural.html works the way it works?
03:40:48 <ely-se> in order to implement the type classes I suppose
03:41:08 <ely-se> can't make (-) return Maybe Natural since Num type class doesn't allow that
03:41:41 <vektor> I can't believe I just wrote Just $ fromJust x ...
03:41:58 <tdammers> vektor: learn2hlint
03:42:02 <tdammers> ;)
03:42:07 <ely-se> vektor: should've used https://hackage.haskell.org/package/acme-safe-0.1.0.0/docs/Acme-Safe.html#v:safeFromJust
03:42:23 <vektor> hlint doesn't complain.
03:42:40 <ely-se> mrkkrp: turning invalid input into arbitrary valid input silently is the worst you can do. it's a perfect recipe for debugging hell
03:42:44 <tdammers> huh
03:42:54 <tdammers> well, technically, Just . fromJust isn't identity
03:43:28 <vektor> Actually, I think I'm gonna leave it this way. Easiest way to make it error on Nothing.
03:43:29 <vektor> :D
03:43:29 <tdammers> it's really "if the value is a Just, pass it through unchanged, else explode in the programmer's face"
03:43:40 <mrkkrp> ely-se: right, now if I have no choice in similar way, say, I can only return value without Maybe or Either, should I throw?
03:43:41 <vektor> Exactly. That's what I need
03:43:58 <ely-se> then you should probably throw
03:44:03 <tdammers> but, uhm, if you want it to error out on Nothing, why don't you use the unwrapped value after that?
03:44:38 <tdammers> and also, how about a somewhat neater way of signalling the problem (exception/error/either/...)
03:44:58 <tdammers> bottoming out is kind of the worst possible way of signalling errors
03:45:02 <vektor> I have a function that, upon getting Nothing for a Maybe a parameter, replaces that Nothing with Just a' - 
03:45:30 <tdammers> fromMaybe
03:45:35 <vektor> however, the function that gets me a' only ever returns Maybe a'.
03:46:00 <vektor> So function Nothing = function (Just $ fromJust geta')
03:46:01 <jophish> Is there an equivalent of 'on' in lens?
03:46:18 <vektor> This won't recurse indefinitely, which is what'd happen if I called function geta'.
03:46:50 <vektor> I mean there surely is another more beautiful way.
03:46:54 <tdammers> why not write it in the Maybe monad instead
03:47:15 <tdammers> or, idk, use fromMaybe or sth
03:47:27 <vektor> forgot to mention, this is all in IO
03:47:47 <tdammers> care to paste the complete fn?
03:49:26 <jophish> as an alternative to something like: (max `on` (^.foo)) a b
03:49:48 <vektor> line 107: http://lpaste.net/144182
03:50:44 <vektor> The whole function is a design flaw of itself I guess
03:52:31 <vektor> "Here's a tree. I have a few spots in the tree where I want these paremeters to be used to create a new node. Creating a new node is an IO action. If one of the parameters for the child node is missing, you can use one you can extract from the soon-to-be parent node.
03:52:32 <vektor> "
03:53:18 <mrkkrp> ely-se: one more case, suppose I'm writing bindings and I need to interact with C, so null bytes are not allowed in strings. There are a couple of types that are wrappers around strings (or text, doesn't matter), what if I convert null bytes to spaces in their smart constructors (this feature will be documented)? this sort of smart constructor turning invalid input into valid input should be not that bad, isn't it?
03:54:12 <vektor> tdammers: I don't particularly care about super great design, but this is slowing down my development speed :D
03:54:45 <tdammers> the general description still sounds like a job for fromMaybe to me
03:55:16 <tdammers> or a combination of do {} in Maybe and fromMaybe
03:57:03 <tdammers> also, I have a hunch that not everything there needs to be in IO
03:57:28 <tdammers> only the "create a new node" part is an IO action, the rest sounds like it should be pure
03:58:29 <tdammers> so, sth like: fromMaybe (return . extractNodeFrom parent) (createNode <$> maybeParam1 <*> maybeParam2 <*> ...)
03:58:44 <vektor> The rest *could* be pure... kinda. I mean, creating a new node is IO, so calling that function is IO too...
03:59:00 <tdammers> yes, but deciding which IO action to call doesn't need to be in IO itself
04:00:23 <tdammers> (note how the pure code in the second fromMaybe argument there is :: Maybe (IO Node)
04:00:31 <zebr> hey all. slightly off-topic, but am i right in thinking that the simply-typed lambda calculus with recursive types means that any lambda term is well-typed?
04:00:47 <zebr> (since there is never any unification failure)
04:00:48 <tdammers> (and the fromMaybe expression itself is :: IO Node
04:01:06 <vektor> Huhh.... I'm not quite sure I'm following.
04:01:13 <hpc> zebr: should be, yes
04:01:30 <vektor> tdammers: You're looking at the context in the 2 functions above that one too?
04:01:31 <tdammers> vektor: forget for a moment that IO a "does" something
04:01:38 <tdammers> IO a is just a value
04:01:43 <vektor> zipperCreateAll of course is just a stub
04:02:06 <zebr> hpc: good, i think i'll work on that assumption then :)
04:04:11 * hackagebot hset 2.2.0 - Primitive list with elements of unique types.  https://hackage.haskell.org/package/hset-2.2.0 (AlekseyUymanov)
04:04:31 <tdammers> you could perform a simple refactoring
04:04:50 <tdammers> write a function createChild' that takes a FilePath instead of a (Maybe FilePath)
04:05:19 <tdammers> then make createChild a wrapper around it
04:05:41 <vektor> That's pretty much mkChild
04:06:26 <tdammers> well, the difference would be that the Nothing case for createChild is defined in terms of createChild' instead of itself
04:06:45 <vektor> Except it doesn't work on trees. If I put the treePos-handling part of createChild in a subfunction, I can focus on the params only.
04:07:11 <tdammers> createChild' then should return something that can carry error information, and createChild either handles it right there and then (throwing, most likely), or bubbles it in its own return type
04:08:36 <tdammers> either way, I'd make it such that mkChild is available in both branches, and the Nothing branch calls it directly, rather than recurse
04:09:00 <tdammers> then you can change mkChild to indicate failure through its return type, rather than bottoming out
04:11:34 <vektor> That sounds good.
04:14:27 <vektor> is there a simple way to get the inferred type of a function in local scope? Like, I have a function in a let - binding. can I :t it?
04:14:56 <ocramz> vektor: a hole? i.e. _
04:17:41 <ocramz> vektor: re. your function in a let: it's not visible from the outside, so you can't :t it
04:19:23 <quchen> > map ((*2) `asTypeOf` _) [1..10] -- vektor 
04:19:25 <lambdabot>      Found hole ‘_’ with type: b -> b
04:19:25 <lambdabot>      Where: ‘b’ is a rigid type variable bound by
04:19:27 <lambdabot>                 the inferred type of it :: [b] at <interactive>:1:1
04:19:40 <ocramz> typed holes ftw
04:19:54 <quchen> Hm, holes have some problems with typeclasses, but in general "asTypeOf _" is a pretty helpful idiom
04:20:15 <vektor> hmm.. sounds useful.
04:27:18 <ocramz> quchen: it seems like the most sensible use of `asTypeOf` is the one you've shown; since the trivial cases are trivial and all the others throw errors. Also, not to be used to convert between floats and fractionals
04:27:57 <quchen> Oh I've used that trick many times with pretty complicated types
04:28:08 <quchen> For example to write the signature in where blocks
04:39:22 <saulzar_> quchen, How is 'asTypeOf' different from say just using ::_ ?
04:39:34 <saulzar_> > map ((*2) :: _) [1..10]
04:39:36 <lambdabot>      Found hole ‘_’ with type: b -> b
04:39:36 <lambdabot>      Where: ‘b’ is a rigid type variable bound by
04:39:36 <lambdabot>                 the inferred type of it :: (Enum b, Num b) => [b]
04:41:49 <quchen> Hm. No idea.
04:42:36 <aweinstock> :t asTypeOf
04:42:37 <lambdabot> a -> a -> a
04:42:51 <aweinstock> :t const `asTypeOf` asTypeOf
04:42:52 <lambdabot> b -> b -> b
04:43:13 <quicksilver> one is a type-hole and one is a term-hole :)
04:43:30 <aweinstock> :t const const id
04:43:31 <lambdabot> a -> b -> a
04:48:36 <augur> huh. installing GHC 7.10 is pretty slick
05:10:31 <quchen> Is it? I felt like it's the same as installing 7.8 and 7.6.
05:10:35 <augur> hm
05:10:49 <quchen> The only issue I've ever had was with libgmp really
05:10:55 <augur> why would `which cabal` give me the correct information, but just doing `cabal` says there's no such thing
05:10:58 <augur> how weird
05:10:58 <quchen> But now that the build bots are updated that issue is gone
05:11:07 <quchen> augur: What's the specific error?
05:11:14 <quchen> Someone asked about this a couple of hours ago.
05:11:21 <augur> darryl-mcadamss-macbook-pro:~ darryl$ which cabal
05:11:21 <augur> /Applications/ghc-7.10.2.app/Contents/bin/cabal
05:11:22 <augur> darryl-mcadamss-macbook-pro:~ darryl$ cabal
05:11:23 <augur> -bash: /Users/darryl/.cabal/bin/cabal: No such file or directory
05:11:51 <quchen> Hm, different error, but sounds related.
05:12:02 <quchen> gpyh was his name.
05:12:20 <quchen> Around 11:17 UTC+1 if that helps
05:12:54 <augur> aha, i figured it out
05:13:17 <quchen> What was it?
05:13:25 <augur> i had .profile pointing to ~/.cabal/bin as a location, but the GHC app only modifiers .bash_profile
05:13:34 <augur> so many frickin' places to have settings x_x
05:20:26 <augur> hrmph. im still getting this /usr/bin/ar error :(
05:23:16 <mauke\e[5m> what error?
05:24:13 <augur> cabal: /usr/bin/ar: permission denied 
05:26:53 <mauke\e[5m> dtruss?
05:27:12 <init> augur: chmod +x should fix that... but why did that happen?
05:27:23 <augur> init: upgrade to el capitan
05:27:48 <init> oh sorry, thought you were using linux
05:28:10 <init> nevermind, I have no idea :/
05:53:46 <Ziphilt> How could I register a callback function for events on a standard Handle (as from System.IO)? I want to try to hook up basic I/O to an FRP library, in particular reactive-banana. It looks like I need a way to create callbacks (looking at Reactive.Banana.Frameworks). I searched around for "Haskell callback" to no avail.
05:57:22 <hexagoxel> Ziphilt: afaik, the direct route is to 1) create thread 2) use blocking function to wait for IO 3) call the Handler of an event
05:58:01 <Ziphilt> hexagoxel: Okay, that was the only way I could think of to do it, but I was hoping for a library to call. That is fairly straighforward though. Thanks.
05:58:28 <hexagoxel> (note: i have not looked at the 1.0.0.0 interface, not sure if that provides anything higher-level. don't think so though..)
05:59:20 <mauke\e[5m> @hoogle threadWaitRead
05:59:22 <lambdabot> Control.Concurrent threadWaitRead :: Fd -> IO ()
05:59:22 <lambdabot> GHC.Conc.IO threadWaitRead :: Fd -> IO ()
05:59:22 <lambdabot> GHC.Conc threadWaitRead :: Fd -> IO ()
05:59:31 * hackagebot sharc-timbre 0.1 - Sandell Harmonic Archive. A collection of stable phases for all instruments in the orchestra.  https://hackage.haskell.org/package/sharc-timbre-0.1 (AntonKholomiov)
05:59:33 * hackagebot csound-expression-typed 0.0.9 - typed core for the library csound-expression  https://hackage.haskell.org/package/csound-expression-typed-0.0.9 (AntonKholomiov)
05:59:35 * hackagebot csound-expression 4.9.0 - library to make electronic music  https://hackage.haskell.org/package/csound-expression-4.9.0 (AntonKholomiov)
06:02:52 <aweinstock> > GHC.Prim.unsafePtrEquality# 1 1
06:02:54 <lambdabot>  Not in scope: ‘GHC.Prim.unsafePtrEquality#’
06:03:25 <Ziphilt> mauke\e[5m: thanks
06:04:31 * hackagebot csound-sampler 0.0.6.4 - A musical sampler based on Csound  https://hackage.haskell.org/package/csound-sampler-0.0.6.4 (AntonKholomiov)
06:04:33 * hackagebot csound-catalog 0.4.0 - a gallery of Csound instruments.  https://hackage.haskell.org/package/csound-catalog-0.4.0 (AntonKholomiov)
06:04:55 <hexagoxel> Ziphilt: someone should write a library of higher-level combinators around reactive-banana :p
06:05:05 <Ziphilt> heh
06:05:07 <aweinstock> :t let x = 1 in (GHC.Types.I# (GHC.Prim.reallyUnsafePtrEquality# x x))
06:05:09 <lambdabot> Int
06:05:13 <aweinstock> > let x = 1 in (GHC.Types.I# (GHC.Prim.reallyUnsafePtrEquality# x x))
06:05:15 <lambdabot>  Not in scope: data constructor ‘GHC.Types.I#’    Not in scope: ‘GHC.Prim.rea...
06:06:09 <aweinstock> would lambdabot allowing GHC.Prim access without allowing unsafePerformIO still run the risk of enabling arbitrary code execution?
06:20:58 <Darwin226> Hey, I'd ask this in #diagrams but I'm hoping to get a faster answer here. If I have a list of coordinates, what's the easiest way to turn that into the diagram that has the origin where the origin of the coordinates was?
06:21:39 <Darwin226> fromVertices works, but the origin is at the position of the first vertex
06:26:27 <marchelzo> is there a shorthand for (id &&& f)?
06:29:54 <mauke\e[5m> \x -> (x, f x)
06:30:16 <marchelzo> heh
06:30:21 <mauke\e[5m> :t ap (,)
06:30:22 <lambdabot> (a1 -> a) -> a1 -> (a1, a)
06:30:58 <marchelzo> hmm
06:31:07 <aweinstock> mauke\e[5m: why do you have something vaguely-resembling an ANSI escape in your name?
06:31:21 <marchelzo> I was wondering the same thing
06:31:31 <mauke\e[5m> because I can
06:31:40 <mauke\e[5m> and everyone loves blinking text
06:31:59 <aweinstock> do some IRC clients actually interpret those?
06:32:02 <marchelzo> mauke\e[5m: does it actually blink in your irc client?
06:32:04 <mauke\e[5m> no
06:32:38 <frerich> <mauquee> is an alltime favorite HTML tag, I think
06:32:47 <marchelzo> actually that's a neat idea
06:32:48 <init> it is missing a escape character for that
06:33:09 <marchelzo> colored/bold/blinking/etc. text in irc could be cool
06:33:18 <Jinxit> 03like this?
06:33:59 <Jinxit> or this?
06:34:05 <marchelzo> I just see '03like this?'.
06:34:22 <Jinxit> many IRC clients will see those as green and bold respectively
06:34:32 <init> 4red is better 13or this, 13,4specially this way
06:35:05 <init> ah, mirc colors :)
06:39:43 <breadmonster> Hey guys.
06:40:33 <augur> hey breadmonster
06:40:46 <breadmonster> augur: Do you do GHC development?
06:40:52 <augur> no
06:40:56 <breadmonster> Oh okay.
06:40:59 <augur> why?
06:41:32 <breadmonster> Wondering how much work it would be to add first order existential type inference.
06:42:31 <augur> ah
06:43:04 <breadmonster> Would be an interesting project and a really cool way of picking up type theory.
06:43:14 <breadmonster> I'm a believer of drinking out of a firehose.
06:43:58 <augur> it'd probably be the worst way to learn type theory
06:44:07 <augur> you'd do better actually reading some appropriate things
06:44:18 <breadmonster> Really?
06:44:22 <augur> yes
06:44:28 <breadmonster> Any suggestions?
06:46:07 <augur> breadmonster: http://purelytheoretical.com/sywtltt.html
06:47:19 <breadmonster> augur: your blog is down.
06:47:34 <augur> what?
06:48:09 <breadmonster> http://purelytheoretical.com/blog/ returns a "Error establishing database connection"
06:48:44 <augur> ah. well nothing important is on that blog anyway
06:51:06 <phaazon> hey
06:51:15 <phaazon> is there a way to show Rep a ?
06:51:21 <phaazon> like a showGeneric
06:51:24 <phaazon> or something like that?
06:51:28 <phaazon> or tell ghci to do that?
06:51:37 <phaazon> :i (Rep [Int]) for instance
06:52:20 <phaazon> hm, :i Rep gives all the instances
06:52:24 <phaazon> is there a way to filter that?
06:56:38 <itsmeyoo> I got a question
06:56:44 <itsmeyoo> how can I use \ in a string?
06:56:50 <itsmeyoo> it just recognises it as esc character
06:57:02 <itsmeyoo> but I need to do like if "\>" == x then ...
06:57:02 <suppi> like the letter \?
06:57:05 <itsmeyoo> yes
06:57:07 <suppi> '\\'
06:57:10 <itsmeyoo> oh ok thanks
06:57:13 <suppi> np
06:57:26 <itsmeyoo> that did not work
06:58:27 <phaazon> > "foo" ++ "\\""
06:58:30 <lambdabot>  <hint>:1:15:
06:58:30 <lambdabot>      lexical error in string/character literal at end of input
06:58:34 <phaazon> > "foo" ++ "\\"
06:58:36 <lambdabot>  "foo\\"
06:58:56 <phadej> > putStrLn $ "foo" ++ "\\"
06:58:57 <itsmeyoo> hmm I gotta go to class anyway, I'll try get it figured
06:58:58 <lambdabot>  <IO ()>
06:59:14 <phaazon> > show "\\"
06:59:16 <lambdabot>  "\"\\\\\""
06:59:19 <phaazon> ahah
06:59:21 <suppi> ??
06:59:25 <phaazon> wtf
06:59:29 <suppi> @_@
06:59:33 <suppi> > show "\\"
06:59:34 <lambdabot>  "\"\\\\\""
06:59:39 <suppi> ...
06:59:41 <mauke\e[5m> > iterate show "\\"
06:59:43 <lambdabot>  ["\\","\"\\\\\"","\"\\\"\\\\\\\\\\\"\"","\"\\\"\\\\\\\"\\\\\\\\\\\\\\\\\\\\\...
06:59:46 <phaazon> Prelude> putStrLn "\\"
06:59:46 <phaazon> \
06:59:54 <phaazon> it’s just because of IRC, I guess
06:59:58 <suppi> oh my
07:00:09 <mauke\e[5m> > fix show
07:00:10 <phaazon> escaping might be disabled
07:00:11 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
07:00:26 <mauke\e[5m> what do you mean, "escaping might be disabled"?
07:00:27 <frerich> phaazon: It's because of 'show'.
07:00:51 <frerich> phaazon: If you say (show "\\") then it will give you a string containing those four characters. and as it happens, all of them need to be escaped with a leading backslash.
07:02:32 <phaazon> hm, is Par0 still in use (Generics)?
07:04:19 <deception1> is it possible to port quickcheck to a dynamic language like ruby or python with failure case reduction and random input generation (since those languages uses duck typing I wonder is it possible to achieve random input generation)
07:09:51 <bernalex> idk but erlang has quickcheck
07:09:54 <frerich> deception1: I'm not aware of anything which reduces failure-inducing data the way quickcheck does. However, I can imagine that if you a) add some sort of annotation about the types of values processed by your function and b) use something like delta debugging to reduce test case data then you could end up with something nice.
07:10:11 <Jinxit> yeah and erlang is dynamically typed
07:10:31 <frerich> deception1: Without the type annotations and reductions, I guess you have plain fuzz testing.
07:10:34 <bernalex> if by dynamically typed you mean "lacks a static typechecking mechanism", then yes
07:12:27 <frerich> deception1: I just found https://blog.wearewizards.io/using-haskells-quickcheck-for-python which has a funny approach: using bindings to the scripting language you don't port QuickCheck but actually use the real QuickCheck. :-)
07:14:54 <obadz> mauke\e[5m: this could be a cool haskell puzzle :) solve for y such that iterate read y !! 15 == "\\"
07:14:55 <deception1> frerich: wow thanks :)
07:15:48 <breadmonster> mauke\e[5m: Why is there a raw byte sequence at the end of your nick?
07:16:13 <mauke\e[5m> breadmonster: every nick is a raw byte sequence
07:16:27 <breadmonster> mauke\e[5m: Mine is cooked. Or baked rather.
07:16:45 <mauke\e[5m> > let y = iterate show "\\" !! 15 in iterate read y !! 15
07:16:49 <lambdabot>  mueval-core: Time limit exceeded
07:17:25 <obadz> mauke\e[5m: that's right :)
07:38:08 <Tekkkz> Hello! Is it possible to make a bot in haskell which will automatically vote here http://www.radiobrocken.de/voting/schule/winckelmann-gymnasium-stendal every 30 mins?
07:40:12 <mauke\e[5m> Request delivery failed
07:40:46 <ernst> Tekkkz: the more difficult part would be to do it in a way so they dont realise you're trying to cheat at a radio contest
07:41:22 <quicksilver> not sure why you'd bother with haskell for that. It's probably a oneliner in curl or, at worst, perl/
07:43:28 <cocreature> quicksilver: well if you want to do it to learn something it might make sense to do it in haskell
07:44:16 <pavonia> And in the worst case the whole school is disqualified just for one person playing unfair
07:44:48 <mauke\e[5m> ooh, a <canvas> captcha
07:47:38 <Tekkkz> ernst: doesnt matter. is it possible what i asked?
07:49:20 <ernst> Tekkkz: yes
08:13:28 <tobiasBora> Hello,
08:13:49 <tobiasBora> I would like to know, how does haskell can evaluate a lazy function on list ?
08:14:12 <tobiasBora> when I do f [1,2,3,4] twice, is f computed twice ?
08:14:47 <kadoban> tobiasBora: Usually, yes. If you give it a name and use it twice though, it won't be.
08:15:16 <tobiasBora> kadoban: Ok thank you. So the lazy part is usefull only on Integral type ?
08:15:24 <kadoban> tobiasBora: No?
08:15:27 <quchen> Haskell says nothing about how often "f" is recomputed here. GHC's implementation will only calculate "f" once though.
08:15:56 <jpp7> how can I use the backslash in a string? I want to do something like if x == "\" but it interprets the backslash as making the end speech mark part of the string
08:16:06 <kadoban> jpp7: \\
08:16:10 <tobiasBora> quchen: How ghc can know that the list is the same ?
08:16:26 <jpp7> kadoban: tried it but it still doesn't seem to work
08:16:46 <jpp7> kadoban: so you're saying I do if x == "\\"
08:16:49 <quchen> > length "\\"
08:16:51 <lambdabot>  1
08:16:52 <kadoban> jpp7: Something else went wrong then.
08:16:59 <jpp7> and if the string has 1 \ then it'll match/
08:17:05 <kadoban> Yes.
08:17:47 <quchen> tobiasBora: You only gave us one list, that list is always the same.
08:17:57 <jpp7> hmm
08:18:46 <tobiasBora> quchen: if I have this : "let l1 = [1,2,3]; l2 = [1,2,3]; (f l1) + (f l2)", how ghc will compute it ?
08:18:47 <phaazon> hey, a vec4 is 16 bytes, right?
08:20:00 <quchen> tobiasBora: That's something different. You asked about how often "f" is computed, not how often *the application of f* is. This example might compute "f 1" twice.
08:20:10 * hackagebot csound-expression-typed 0.0.9.1 - typed core for the library csound-expression  https://hackage.haskell.org/package/csound-expression-typed-0.0.9.1 (AntonKholomiov)
08:20:12 * hackagebot csound-expression 4.9.1 - library to make electronic music  https://hackage.haskell.org/package/csound-expression-4.9.1 (AntonKholomiov)
08:21:16 <tobiasBora> quchen: Ok thank you. Do you have an example where "f" is computed (not the application of f) several times ?
08:21:49 <Tekkkz> ernst: can you tell me how? or help? im new and need it to tomorrow
08:22:00 <quchen> When something has a name, it won't be recomputed. The value is held in memory once computed once, so there's no need to recompute it.
08:22:31 <quchen> But when you have an "f" in a "where" block for example, then reevaluating the thing that contains the block will recompute "f" on every invocation.
08:23:33 <quchen> Tekkkz: This is no trivial task, and it's also a very smelly one. Let's not do that.
08:24:21 <tobiasBora> quchen: Even when it's compiled ?
08:24:37 <quchen> tobiasBora: GHC might optimize this.
08:24:46 <quchen> Depends on whether "f" can be floated out to the top level.
08:24:56 <tobiasBora> quchen: Ok thank you.
08:25:13 <quchen> foo x = bar where f = ...x... -- This f cannot be floated out
08:25:28 <quchen> So that f will be recomputed on every invocation of foo
08:25:48 <quchen> If "f" had been independent of foo, then GHC might float it out to the top level and share it
08:25:59 <mauke\e[5m> > (pi :: Float, pi :: Double, pi :: Complex Double)
08:26:01 <lambdabot>  (3.1415927,3.141592653589793,3.141592653589793 :+ 0.0)
08:26:56 <tdammers> Tekkkz: 1. Learn Haskell. 2. Find a suitable HTTP client library. 3. Figure out what kind of request you need to send to that site to produce a valid vote (which probably involves reverse-engineering the HTML) 4. Put it all together: write a program that uses the HTTP client library to fire the desired requests, throw it in a cron job to run every 30 minutes
08:27:31 <tdammers> Tekkkz: however, note that this isn't just fishy, it's even legally considered "hacking" in many jurisdictions, and if worst comes to worst, you could be sentenced for that
08:27:57 <tdammers> Tekkkz: people have gone to jail for disabling javascript in their browser to bypass badly implemented password checks
08:29:48 <ww> tdammers: i hope nobody who habitually has javascript disabled has gone to jail...
08:30:23 <tdammers> ww: no, in this particular case the accused was willfully and knowingly bypassing the password check to provide a proof of concept
08:30:42 <tdammers> ww: completely white-hat, but still unauthorized, so illegal
08:30:59 <capisce> I think "Freer Monads, More Extensible Effects" is one of the most awesome papers I've read
08:31:31 <tdammers> ww: and the argument was not "I use a script blocker for security reasons and wasn't aware of the password check", it was "their password check is broken so I should have a right to bypass it"
08:32:14 <quchen> "The car was open so I should have a right to sit in it"
08:32:20 <tdammers> yes, that
08:32:37 <tdammers> "the bicycle wasn't locked, so taking it doesn't constitute 'stealing'"
08:33:12 <tdammers> it's still stealing, even if you only take it to raise awareness of the stealability
08:33:54 <sicasal> someone can help me if i receive a list of tuples [(name,department,salary,age)] and i want to receive a the name of the person that receives the bigger salary
08:34:12 <sicasal> i can use map to define that ?
08:34:34 <quchen> :t maximumBy -- sicasal 
08:34:35 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
08:35:09 <Kakadu> Hey, folks. I'm trying to implement tasks from http://pastebin.com/raw.php?i=HPSV974p using https://raw.githubusercontent.com/dboulytchev/typefun/master/DynType.hs
08:35:11 <tdammers> I must say, Foldable and Traversable don't make type signatures more intuitive for beginners
08:35:49 <Kakadu> I'm a little bit stuck with implementing `instance TypeRepr Type ` because I can't construct Equals a b
08:36:08 <sicasal> how can i use foldable to verifys wich one is bigger
08:36:11 <Kakadu> the only way to construct it constructs `Equals a a` (sing rell function)
08:36:14 <Kakadu> refl*
08:36:28 <tdammers> sicasal: you can't. Ordering takes care of that.
08:36:59 <quchen> You'll need: getSalary, getName, comparing, maximumBy.
08:37:10 <quchen> The first two you'll have to write yourself.
08:37:21 <tdammers> :t comparing
08:37:22 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
08:37:36 <tdammers> there's the typeclass that takes care of "greater than"
08:38:09 <tdammers> but maximumBy doesn't care, that's the beauty - all you need is a function that produces an Ordering
08:38:15 <sicasal> i cannot use models only fuction of superior order
08:38:21 <sicasal> modulos
08:45:11 * hackagebot RNAlien 1.0.0 - Unsupervized construction of RNA family models  https://hackage.haskell.org/package/RNAlien-1.0.0 (FlorianEggenhofer)
08:50:11 * hackagebot uri-bytestring 0.1.9.1 - Haskell URI parsing as ByteStrings  https://hackage.haskell.org/package/uri-bytestring-0.1.9.1 (MichaelXavier)
08:51:29 <fizbin> If I've got a machine (specifically, an Ubuntu 12.04.5 LTS install) and I want to find out what version of the "base" package comes with the version of ghc that ships with, how do I do that?
08:52:22 <sleblanc> Is there a Haskell-equivalent of a functional document database (think CouchDB)
08:53:24 <P4ng4IN> @fizbin ghc-pkg describe base?
08:53:25 <lambdabot> Unknown command, try @list
08:53:46 <sleblanc> I am specifically referring to the presentation layer, I would like the part of CouchDB that's in JavaScript to be in Haskell instead
08:58:21 <Kakadu> Let's say we have some https://raw.githubusercontent.com/dboulytchev/typefun/master/DynType.hs and we want to implements tasks from http://pastebin.com/raw.php?i=HPSV974p . How should I implement class instance if I absolutely can't construct `Equals a b` ?
09:02:52 <gganley> Looking through SPJ's papers he refrences mixins. I've never had mixins properly explained to me. I always thought it was an OOP tool, how does it work in FP and what is it in general
09:06:33 <dolio> gganley`: There are papers on mixins for ML modules.
09:06:42 <dolio> MixML maybe.
09:07:06 <gganley`> sorry i had to leave
09:07:17 <gganley`> i missed if anyone responded
09:07:29 <dolio> Only me.
09:07:43 <gganley`> i only saw MixML maybe
09:07:55 <dolio> Oh. There are papers on mixins for ML modules.
09:08:07 <dolio> And i think MixML is a keyword to look for.
09:12:18 <dolio> Generally the module level is where things like abstraction and encapsulation end up on the functional end of things.
09:15:16 <glguy> hvr: You can close this issue, you fixed it :) https://github.com/hvr/cassava/issues/91
09:25:41 <kadoban> Any recommendations for what packages/modules to use for this?: I need to look at the HTTP headers I get back from a HTTP server, and I need TLS support. I also need to be able to look as in-depth as possible at the info about the certificate being used.
09:29:13 <statusfailed> Can Aeson derive To/From JSON instances for GADTs ?
09:37:01 <mmachenry> Does anyone have a recommendation on libraries for making web requests and receiving JSON as a response? 
09:37:59 <cocreature> mmachenry: wreq is pretty good for that
09:38:39 <mmachenry> cocreature: I saw that one in my list. Thanks I'll read that one more deeply.
09:41:24 <sleblanc> c2hs has the {#call … #} directive that lets you call a binding to a C function, adding a "foreign" reference if not already done. Usually one would type "myHaskelLFunction = {#call myCFunction #}". Is there a way to skip the manual definition of function and just have C2HS define the appropriate bindings? Or is it bad practice?
09:45:57 <nrolland> how do I produce a tarball for a package which contains the binaries as well ? 
09:46:04 <nrolland> akin to https://github.com/fizruk/ghcjs/releases/tag/v0.2.0.20151001
09:46:13 <kadoban> Do /any/ of the HTTP libraries let you get a peek at the TLS connection data? :-/
09:47:18 <nrolland> ok never mind I got it wrong
09:47:41 <sternenseemann> 17:46 < nrolland> ok never mind I got it wrong
09:47:52 <fizruk> nrolland: cabal sdist or stack sdist might work for you (depending on which version of ghcjs are you trying to build), but let me look for a more detailed explanation
09:47:56 <sternenseemann> oh, this whole linux clipboard thing is so annoying :(
09:48:28 <nrolland> hi fizryuk, I was trying to update the ghcjs now that some breaking change from JSRef to JSVal happened
09:48:35 <Myrl> s/b end
09:48:42 <nrolland> let me fail a bit more :)
09:49:04 <Myrl> I got bored and decided to start making a Haskell OS. What are the things that I should have for Haskell to work?
09:49:13 <dcoutts_> nrolland: cabal copy --distdir=$your-image-dir  will create an install image, which you can then tar up and deploy
09:49:18 <Myrl> I'm talking a look at Kinetic and House right now.
09:49:29 <fizruk> nrolland: read comments here https://github.com/commercialhaskell/stack/issues/749#issuecomment-148041012
09:49:49 <dcoutts_> nrolland: and you can control the layout of that image when you cabal configure, by specifying --prefix, and the other layout control flags, see cabal configure --help
09:49:52 <Myrl> For example, memory management. What memory management does GHC use?
09:50:10 <nrolland> thks all 
09:50:50 <dcoutts_> Myrl: if you look at house you'll see how they do it. The RTS uses posix api like mmap for allocating memory for the Haskell heap, plus C malloc for RTS structures.
09:51:15 <fizruk> dcoutts_: ghcjs has custom Setup.hs which generates distribution archive for GHCJS, I am not sure cabal copy will work here
09:51:41 <Myrl> dcoutts_: Thanks for guiding me. I'm a bit sleepy right now, and I'm very bad at understanding other people's code.
09:51:55 <dcoutts_> fizruk: cabal copy calls Setup copy when it's a custom Setup, but you can just call Setup copy manually if you like.
09:52:32 <dcoutts_> fizruk: ./setup copy --distdir=$your-image-dir
09:52:46 <dcoutts_> fizruk: and same advice about the configure --prefix etc
09:54:45 <dmj> has anyone upgraded to El Capitan? If so did it go OK?
09:55:01 <Welkin> haha
09:55:08 <Welkin> I have been seeing tweets about that recently
09:55:12 <Welkin> it breaks haskell
09:55:15 <Welkin> don't do it
09:55:17 <schell> i upgraded
09:55:20 <Welkin> I always avoid upgrading
09:55:22 <schell> i had no problems
09:55:24 <Welkin> because shit breaks
09:55:28 <schell> i’m on ghc 7.10.2
09:55:39 <schell> and i occasionally switch to 7.8
09:55:42 <cocreature> yeah just stick with windows 95
09:55:57 <nrolland> dmj : I did, it was mostly ok (7.10.2), but I still keep my trusty macbook air on yosemite..
09:56:01 <Welkin> cocreature: I don't use windows
09:56:06 <Welkin> I should not be using mac either
09:56:15 <Myrl> dcoutts_: I searched for mmap, didn't find anything relevant, I did find sbrk though. I'm guessing this is it?
09:56:29 <dmj> nrolland, Welkin, schell: thanks guys
09:56:37 <dmj> cocreature: :)
09:56:49 <dmj> https://twitter.com/psygnisfive/status/659707347460358144 :/
09:58:10 <c_wraith> It's amusing when you discover that a function you wrote is accidentally idempotent. 
10:01:00 <Myrl> dcoutts_: Actually, I was searching at the wrong place, thanks again.
10:02:38 <jle`> c_wraith: did you accidentally write f . f instead of f and realized that the answer was the same?
10:02:59 <Myrl> jle`: lol
10:03:57 <c_wraith> jle`: nah, I was just looking at it and went "wait, I bet I can do this twice without changing the answer.." 
10:04:13 <Myrl> c_wraith: What'd you make?
10:04:45 <jle`> i wonder if GHC would inline `f . f` to the point where it's identical to `f`
10:04:53 <jle`> for interesting cases
10:05:11 <jle`> (for interesting cases of idempotent f)
10:05:15 * hackagebot luminance 0.6.0.1 - Type-safe, type-level and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.6.0.1 (DimitriSabadie)
10:05:17 * hackagebot luminance-samples 0.6.0.1 - Luminance samples  https://hackage.haskell.org/package/luminance-samples-0.6.0.1 (DimitriSabadie)
10:05:21 <c_wraith> jle`: not in this case.. Classes were involved. 
10:05:46 <phaazon> hey guys
10:05:48 <phaazon> https://github.com/phaazon/stack-haddock-upload/blob/master/stack-haddock-upload
10:05:52 <phaazon> you might want to try this out
10:06:08 <phaazon> I’ve been using a version that asked me my password on the CLI for a while
10:06:12 <phaazon> and found that nasty
10:06:19 <c_wraith> Myrl: I was working on an illegal monoid for examining association structures. 
10:06:31 <phaazon> and my version has colours \o
10:06:38 <quicksilver> c_wraith: I have one of those :) the answer was quite interesting.
10:06:51 <quicksilver> c_wraith: lots more mempties than I expected
10:07:09 <c_wraith> Myrl: then I realized that if you foldMap it over itself, it doesn't change anything. 
10:07:25 <Myrl> Ah
10:07:50 <quicksilver> jle`: if f is determined by a case statement then yes, I think.
10:08:02 <quicksilver> jle`: I think GHC can combine nested cases on the same scrutinee.
10:08:16 <c_wraith> quicksilver: interestingly, I was looking at Data.Set, and was surprised by how few mempties there were. 
10:08:41 <quicksilver> c_wraith: I was running a Conduiting, listening to the output with a Writer monoid
10:08:47 <Welkin> case expression*
10:08:56 <quicksilver> Welkin: yes indeed :)
10:09:05 <Welkin> mempty :D
10:09:11 <Welkin> who pronounces that "em-empty"
10:09:15 <c_wraith> quicksilver: ah. You'll get an mempty from every return. That will add up. 
10:09:17 <Welkin> and you pronounces it "memtpy"
10:09:26 <quicksilver> data A | B | C; f A = A; f B = A; f C = C;
10:09:30 <Welkin> I usually go for the former
10:09:34 <Welkin> but I have heard the latter
10:09:42 <quicksilver> jle`: ^^ that f is idempotent and I think ghc will inline and condense f . f
10:09:59 <Myrl> lol
10:10:01 <quicksilver> apologies for the grammatically incorrect data statement.
10:10:09 <Myrl> I'm laughing at how mmap here is being defined as malloc.
10:10:15 <quicksilver> Welkin: I say "mem-p-tee"
10:10:15 * hackagebot purescript 0.7.5.3 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.7.5.3 (PhilFreeman)
10:10:23 <quicksilver> Welkin: but only in my head, I've never said it out loud to another human being.
10:11:13 <quicksilver> I don't like the name. I wish it was called unit or zero or even `e`.
10:12:04 <quicksilver> c_wraith: but the good news is it was mostly left associated, apart from the zeros
10:13:12 <c_wraith> quicksilver: that's only good if it's being evaluated strictly at each step, which isn't usually true.. 
10:13:31 <Myrl> I'm so confused as to how this works right now.
10:13:36 <quicksilver> c_wraith: actually it was a thinko just then.
10:13:41 <quicksilver> c_wraith: in fact, it was mostly right associated.
10:13:44 <quicksilver> I shoulud have said :0
10:13:58 <c_wraith> :) 
10:15:03 <quicksilver> I'm still curious to do timings on Endo [a] vs [a]
10:17:50 <Myrl> Good night.
10:19:20 <c_wraith> quicksilver: I bet Endo nearly always wins. Better asymptotics in the worst case, and it seems like it should allocate less in even the best cases. I think. 
10:19:47 <Welkin> Myrl: good night moon
10:19:59 <c_wraith> :t (^..) -- also, this probably has benchmarks behind it.. 
10:20:01 <lambdabot> s -> Getting (Endo [a]) s a -> [a]
10:20:14 <quicksilver> c_wraith: Endo 'mirrors' your call-tree as a set of unevaluated (.)-expressions
10:20:17 <quicksilver> I think.
10:20:25 <quicksilver> I have a poor operational intuition for this stuff
10:20:32 <quicksilver> and then it enters them all to actually calculate the result
10:20:51 <quicksilver> it's obviously better in the worst case but int he best case, my intuition fails me
10:22:06 <dolio> In the best case, Endo [a] is almost certainly worse.
10:22:27 <dolio> Because the best case is that Endo is not fixing anything that would be slow, so it's just overhead.
10:23:49 <c_wraith> Well, this is easy enough to benchmark. I'll write it up at lunch. ([] happens to be exactly the best case to foldMap over) 
10:24:11 <quicksilver> you end up with the same call tree as before, but the nodes are (++) nodes not (.) nodes
10:24:25 <quicksilver> it certainly seems more 'direct'
10:24:40 <quicksilver> (since the (.) nodes are pointing to partially applied (++) thunks)
10:25:13 <quicksilver> although in the specific common case of a single element at a time
10:25:24 <c_wraith> Oh. I use partially applied (:) thunks. A tiny bit better. 
10:25:30 <quicksilver> (a:) is not as bad as ([a]++)
10:25:44 <quicksilver> to support "tell" you need ++ thunks
10:25:55 <quicksilver> but there might be a good case for a special case
10:26:06 <quicksilver> tell1 a = tell (Endo (a:))
10:40:20 <haskell174> how can I list all strings in a list of strings in alphabetical order by column , while adding a newline character at a certain column character count
10:40:33 <haskell174> like ls
10:41:38 <xant_> ls doens't alphabetize columns?
10:42:04 <arkeet> you mean you want multiple columns
10:42:06 <arkeet> ?
10:43:26 <haskell174> yes
10:44:51 <xant_> When you say certain column character count, do you mean like, "I only want five strings in column 'b'"?
10:49:02 <haskell174> http://pastebin.com/BMuKzjR2 like this
10:49:05 <Danny_> Chaps
10:49:11 <Danny_> Am I missing something really stupid
10:49:21 <Danny_> or why is let list5 = ['danny','mike','john']
10:49:32 <Danny_> throwing <interactive>:92:11:     Syntax error on 'danny'     Perhaps you intended to use TemplateHaskell     In the Template Haskell quotation 'danny'
10:49:33 <lispy> " instead of '
10:49:45 <Danny_> Oh is it proper quote marks on strings?
10:49:50 <Cale> Yeah
10:49:54 <lispy> > let list5 = ["danny", "mike", "john"] in list5
10:49:56 <lambdabot>  ["danny","mike","john"]
10:50:09 <lispy> > let foo' = 1 in foo' -- tick can be used in identifiers
10:50:11 <lambdabot>  1
10:50:13 <Cale> " is for strings, ' is for single characters (and is also used in some template haskell syntax)
10:50:26 <Danny_> Excellent, cheers
10:50:37 <Danny_> My own stupidity never ceases to amaze me. 
10:51:53 <dolio> The secret is to become smart enough to expect yourself to be stupid.
10:51:59 <dolio> Then you will at least no longer be amazed.
10:53:30 <haskell174> xant_: i checked it my linux has files in alphabetical order by column
10:55:01 <xant_> dolio: I love taking the amazement out of life
10:57:40 <monochrom> dolio: that's a double-edged sword. if I expect myself to be stupid, then I'll be amazed that I'm smart. :)
10:57:49 <dolio> Oh no!
10:58:05 <ReinH> monochrom: disaster
10:58:14 <johnw> monochrom: lol
10:58:35 <monochrom> like the time when my thesis supervisor said "this is a great thesis!"  I was very amazed. I thought it was horrible.
11:01:55 <jontxu> Hi! New to Haskell here. Any recommended beginner literature?
11:02:19 <danza> jontxu, http://learnyouahaskell.com/chapters
11:02:52 <jontxu> danza, I already knew about that, but thanks.
11:03:07 <Copperis> that's a great intro imo
11:03:36 <kadoban> LYAH is terrible on its own. It has no exercises.
11:03:56 <Copperis> you ought to test everything written there
11:04:00 <kadoban> And for a "here's some stuff that's possible", it's far too long. It pretends to be there to teach you stuff, but it's mostly just light reading.
11:04:04 <Copperis> by writing it out, not copying
11:04:09 <danza> it's a matter of taste i guess
11:05:18 * hackagebot science-constants-dimensional 0.1.0.2 - Mathematical/physical/chemical constants  https://hackage.haskell.org/package/science-constants-dimensional-0.1.0.2 (cbou)
11:05:57 <kadoban> Copperis: Even if you do though, there's no guidance towards useful exercises or experiments to perform. Just typing the stuff in … *shrug*
11:07:16 <jmcarthur> @where learnhaskell
11:07:16 <lambdabot> https://github.com/bitemyapp/learnhaskell
11:07:22 <jmcarthur> jontxu: ^^
11:07:57 <jontxu> jmcarthur, thanks, though kadoban recommended that (and this channel) earlier today :P
11:08:28 <jmcarthur> Well, that's widely considered the best resource for now. :)
11:08:36 <Copperis> kadoban, it was useful for me to get to know haskell. So it benefited my needs. You can find exercises, or real problems you want to solve yourself 
11:08:43 <bitemyapp> jmcarthur: best _free_ resource :P
11:09:00 <jmcarthur> I daresay best, regardless of price.
11:09:09 <bitemyapp> jmcarthur: ouch dude.
11:09:17 <Copperis> kadoban, I agree that it lacks those though
11:09:18 <bitemyapp> jmcarthur: you're rating my own guide above my book?
11:09:30 <jmcarthur> Wait, you have a book? :o
11:09:33 <bitemyapp> jmcarthur: http://haskellbook.com/
11:09:37 <jmcarthur> I don't keep up with books.
11:09:40 <ttt_fff> this is sorta (WAY) off topic, but thought I'd drop it here in case anyone's thought about it -- is there any good article on "design/architecture of gmail?" basically I want to understand how to engineer massive distributed systems that aren't quite RDBMS like, but also have important requirements like "not lose/corrupt data"
11:09:41 <jmcarthur> much
11:09:42 <bitemyapp> jmcarthur: I've been working on it for over a year, 912 pages.
11:09:49 <jmcarthur> Well jeez
11:09:59 <bitemyapp> jmcarthur: coauthor is a linguist who never programmed before learning Haskell
11:10:10 <jmcarthur> Oh, I have seen this. Okay, my remark was unfair. I have not read your book.
11:10:13 <bitemyapp> jmcarthur: we've been testing it with reviewers, we get feedback via Zendesk. That's where all my time has been going.
11:10:36 <jmcarthur> I take it all back! I'm sorry.
11:11:01 <bitemyapp> jmcarthur: s'fine :P
11:11:16 <bitemyapp> jmcarthur: you really should give it a look though. There's a free sample on the website.
11:11:45 <jmcarthur> I will look at it before making any more judgements about learning materials.
11:12:03 <shachaf> ttt_fff: That's pretty off-topic, yes.
11:12:18 <ttt_fff> shachaf: I agree.
11:12:25 <ttt_fff> Maybe one of the first things you and I agree on.
11:12:57 <ttt_fff> shachaf: I could have tried to disguise it as a CRDT / Typing question, but that seemed disingenious.
11:13:01 <danza> ttt_fff, i guess that the most common paradigm nowadays is relying heavily on message queues ... from the point of view of language abstractions, some languages rely on actors for high level concurrency, not Haskell though as far as i know
11:13:24 <bitemyapp> jmcarthur: for some background, I don't know if you've seen it, but I have a post about learning materials here: http://bitemyapp.com/posts/2014-12-31-functional-education.html
11:13:31 <shachaf> Therefore you shouldn't post it here in the first place, rather than post it and apologize. There are plenty of other places to post that question.
11:15:16 <ttt_fff> shachaf: I don't recall apologizing. Though perhaps a better question would be: if you wanted to engineer a system like the backend of Gmail, would CloudHaskell or Erlang be more appropriate? A situation where PostgreS / RDBMS isn't the right solution, so you have to roll your own distributed solution.
11:15:35 <bitemyapp> ttt_fff: that's a bizarre question.
11:16:11 <bitemyapp> ttt_fff: move it to #haskell-blah
11:32:53 <emmanuel_erc> hello there everyone
11:33:00 <gfixler> o/
11:33:02 <nomeata> Brr, why has the haskell community never picked up the "only reply to the single, most on-topic list" instead of the "always reply to anyone who ever said a word in the current discusison, and all possibly relevant lists"
11:34:23 <davidthomas> anyone interested in working at Uber (sf office) hit me up - hoping to strengthen the case to keep a code-base Haskell :)
11:34:45 <davidthomas> (role almost certainly wouldn't be all Haskell and might not be mostly Haskell - happy to share more details 1-1)
11:35:35 * hackagebot safe-length 0.1.0.0 - Tired of accidentally calling length on tuples? Relief at last!  https://hackage.haskell.org/package/safe-length-0.1.0.0 (JeremyShaw)
11:36:32 <shachaf> I didn't know Uber was using Haskell at all.
11:36:48 <davidthomas> we're mostly not
11:38:25 <monochrom> nomeata: because the haskell community is composed of humans. same kind of humans who just look for an easy "reply" button to press.
11:38:49 <davidthomas> but I built something for fun that's proving sufficiently useful we want to push it into production
11:40:09 <davidthomas> I think rewriting it would be a bad idea... but having more people around who can maintain it would make that more clear
11:40:20 <Copperis> davidthomas, what did you build?
11:41:01 <davidthomas> libraries for parsing and analyzing sql (focused on Vertica at the moment)
11:41:23 <athan> Has anyone here messed with numpy or pandas in python? The concept of "pivoting" really intrigues me - making re-occuring cells in a column _a column itself_ by aggregating some other way. Anyone have abstract properties they can recognize in these operations?
11:43:59 <bitemyapp> you need to wait longer than 2 minutes to get an answer.
11:44:43 <hiptobecubic> Isn't athan a regular? I feel like I've seen that nick before
11:45:28 <zomg> Yeah he's been here for some time now so probably just bad timing :P
11:45:34 <ttt_fff> are there any examples of open source distributed / eventual consistency systems / email backends written in haskell ?
11:45:36 <breadmonster> Hey guys.
11:46:35 <bitemyapp> hiptobecubic: he's been absent lately, previously regular.
11:46:45 <bitemyapp> ttt_fff: you are hell-bent
11:47:00 <bitemyapp> ttt_fff: I actually had some info ready for you if you'd joined #haskell-blah
11:47:11 <bitemyapp> as a reward for respecting topicality.
11:47:28 <bitemyapp> you didn't though and I've since used my yank-buffer for something else.
11:48:19 <ttt_fff> bitemyapp: I believe my current question is on-topic.
11:52:15 <bitemyapp> ttt_fff: nobody's going to have an example.
11:54:03 <kadoban> ttt_fff: You started off lampshading its off-topicness … and then just added "in haskell" when you got called on it.
11:56:16 <ttt_fff> kadoban: I think you have this impression that I am trying to write a distributed app in C/C++, and am trolling the haskell channel.
11:56:36 <ttt_fff> kadoban: I'm writing this in Haskell, so the first question was general principles about building such a system, and the 2nd question is whether anyone has built one in haskell.
11:58:07 <bollu> when I'm using diagrams, is it possible to just get a window that renders the diagram?
12:00:39 * hackagebot semver-range 0.1.1 - An implementation of semver and semantic version ranges.  https://hackage.haskell.org/package/semver-range-0.1.1 (thinkpad20)
12:05:27 <R3dstoke> Hello eveyone
12:06:37 <bitemyapp> what is it with the drop-in-and-disappears today?
12:06:42 <emmanuel_erc> hello everyone! I just posted a link to the github repo containing my first Haskell project on the Haskell subreddit. 
12:07:32 <clrnd> safe-length?
12:09:33 <ttt_fff> bitemyapp: I suspect it's because (1) there is no disussion going on at all (2) thus making the channel look dead, (3) therefore, when the person drops in, and sees a "dead channel", they leave
12:09:43 <bitemyapp> 19:09 -!- Irssi: #haskell: Total of 1542 nicks [1 ops, 0 halfops, 0 voices, 1541 normal]
12:09:48 <bitemyapp> p dead
12:10:24 <bitemyapp> emmanuel_erc: are you fuckin' with 'em?
12:10:45 <breadmonster> bitemyapp: There's some slight truth in that...
12:10:53 <breadmonster> It's a network effect.
12:10:54 <bitemyapp> breadmonster: /nick deadmonster
12:11:04 <bitemyapp> it's almost Halloween, lets all be dead together
12:11:17 <ttt_fff> bitemyapp: you can pretend to be php
12:12:05 <bitemyapp> ttt_fff: that's a zombie
12:12:56 <emmanuel_erc> umm... bitemyapp... What did I do?
12:13:18 <bitemyapp> emmanuel_erc: must be looking at the wrong post then
12:13:32 <emmanuel_erc> What post were you looking at?
12:13:57 <breadmonster> bitemyapp: what's the time in NYC?
12:17:07 <bitemyapp> breadmonster: I don't know, I don't live in NYC.
12:17:13 <bitemyapp> emmanuel_erc: safe-length
12:17:31 <bitemyapp> if I had to guess, it's 4-something.
12:18:30 <clrnd> safe-length is 5 stars would startup
12:18:45 <clrnd> emmanuel_erc, just apste your link mate
12:19:12 <bitemyapp> @pl (\x y -> compare (_drRpmDate x) (_drRpmDate y))
12:19:12 <lambdabot> (line 1, column 20):
12:19:12 <lambdabot> unexpected '_'
12:19:12 <lambdabot> expecting expression
12:19:22 <bitemyapp> @pl (\x y -> compare (drRpmDate x) (drRpmDate y))
12:19:23 <lambdabot> (. drRpmDate) . compare . drRpmDate
12:19:38 <bitemyapp> @pl (\x y -> compare (drRpmDate y) (drRpmDate x))
12:19:38 <lambdabot> flip (compare . drRpmDate) . drRpmDate
12:19:42 <t7> @pl test = do { a <- b; c; return a }
12:19:42 <lambdabot> (line 1, column 11):
12:19:42 <lambdabot> unexpected '{'
12:19:42 <lambdabot> expecting variable, "(", operator or end of input
12:19:56 <bitemyapp> @pl do { a <- b; c; return a }
12:19:57 <lambdabot> (line 1, column 4):
12:19:57 <lambdabot> unexpected '{'
12:19:57 <lambdabot> expecting variable, "(", operator or end of input
12:20:05 <clrnd> woah
12:20:06 <bitemyapp> there's no points really.
12:20:10 <bitemyapp> clrnd: ?
12:20:20 <t7> @undo
12:20:20 <lambdabot> Error: expected a Haskell expression or declaration
12:20:25 <t7> @undo test = do { a <- b; c; return a }
12:20:25 <lambdabot> test = b >>= \ a -> c >> return a
12:20:30 <clrnd> nada
12:20:38 <t7> @pl b >>= \ a -> c >> return a
12:20:38 <lambdabot> (c >>) . return =<< b
12:20:50 <emmanuel_erc> ok clrnd
12:21:29 <emmanuel_erc> Here is the link: https://github.com/emmanueldenloye/manifoldRNC
12:21:41 <bitemyapp> what I wanted was 'on'
12:21:43 <bitemyapp> @ty on
12:21:45 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
12:23:02 <Guest34234> anyone writing haskell code using spacemacs/emacs?
12:23:06 <nomeata> monochrom: I know. Althought it mostly works in, say, the Debian community. But not without some serious effort (e.g. by politely telling people about it), and the Debian community is much more used to setting up and adhering to rules than our anarchistic bunch :-)
12:23:45 <emmanuel_erc> Guest34234: I am using emacs (not spacemacs though)
12:24:33 <danza> ttt_fff, i think that people at Tweag https://github.com/tweag are doing a lot of research on distributed systems using Haskell, and apparently they will keep doing research in the field for a while http://www.tweag.io/blog/we-re-hiring-software-engineer-devops. They maintain Cloud Haskell
12:24:49 <bollu> how do you get involved in haskell research?
12:26:40 <Copperis> emmanuel_erc, I get this when doing "cabal install" -> http://lpaste.net/144202 I'm pretty new to these tools and don't know if it's the correct way to run the program
12:26:59 <bitemyapp> Copperis: I'm fixing it, h/o
12:27:44 <emmanuel_erc> oh.... I have base 4.8.1
12:28:28 <emmanuel_erc> I think I ought to fix that. Are the base versions  < 4.8 still very popular?
12:28:37 <bitemyapp> well, maybe.
12:28:40 <bitemyapp> emmanuel_erc: yes.
12:28:44 <bitemyapp> emmanuel_erc: I'm on it, just a moment.
12:28:47 <emmanuel_erc> that's good to know
12:28:56 <emmanuel_erc> I was about to fix that. But thanks?
12:28:57 <byorgey> bollu: there are many paths.
12:28:59 <Copperis> emmanuel_erc, I got it from debian testing
12:29:07 <Copperis> I think
12:29:28 <bollu> byorgey: like..? :)
12:30:09 <Guest34234> emmanuel_erc: I get this error: Error in post-command-hook (evil-mode-check-buffers): (void-function haskell-indentation-enable-show-indentations)
12:31:15 <t7> is there something like a Map but the Key is a Set and i want to query by a member of that set?
12:31:38 <bitemyapp> emmanuel_erc: I use stack, it's easy for me to test that it actually works on 7.8 rather than guessing.
12:31:42 <byorgey> bollu: Write code.  Think hard.  Learn as much as you can. Work on interesting projects. Find mentors. etc.
12:31:48 <bitemyapp> emmanuel_erc: just a few more minutes :)
12:31:54 <emmanuel_erc> Guest34234: Type the command "C-h f" and then type the name haskell-indentation-enable-show-indentations RET 
12:32:01 <emmanuel_erc> to see what you get.
12:32:10 <bollu> byorgey: I'm having trouble on the "find interesting projects" and "find mentors"
12:32:19 <emmanuel_erc> bitemyapp: Are you rebuilding the project using stack?
12:32:19 <bollu> either the skill ceiling is way too high, or it's very niche :/
12:32:52 <byorgey> bollu: how long have you been learning Haskell?
12:33:06 <bollu> byorgey: I'd say a year-ish
12:33:08 <bitemyapp> emmanuel_erc: you have to do more than just bump base to get this working on 7.8 and 7.10
12:33:12 <bollu> maybe year and a half
12:33:20 <bitemyapp> emmanuel_erc: I'm adding a Stack yaml but a lot of this is making the Cabal file friendlier.
12:33:35 <bitemyapp> emmanuel_erc: I'm not changing more than what is necessary for it to be easy to build.
12:33:35 <Iceland_jack> bollu: Are you comfortable with type classes, Functor, Applicative, ...?
12:33:46 <bollu> Iceland_jack: yes :)
12:34:05 <bollu> Iceland_jack: my "threshold of magic" right now is template haskell, lens, and various bits of category theory
12:34:09 <byorgey> bollu: when you say you're having trouble finding interesting projects, what do you mean?  That you can't find any projects that interest you?  Or the ones that do interest you, you don't feel able to contribute to?
12:34:10 <emmanuel_erc> That's really nice of you bitemyapp. Way more than I would have expected anyone to do.
12:34:20 <bollu> byorgey: the latter
12:34:25 <bitemyapp> emmanuel_erc: people learn this stuff best by example.
12:34:30 <bollu> I wanted to contribute to stack, but I didn't know where to start
12:34:40 <Iceland_jack> bollu: You can fairly safely ignore Template Haskell, it's more tedium than magic
12:34:40 <bitemyapp> emmanuel_erc: so it's quicker/easier for me to show you the "right thing" than to painstakingly relate each change via IRC.
12:34:45 <bitemyapp> emmanuel_erc: I will PR it when it's ready.
12:34:53 <emmanuel_erc> cool man...
12:34:56 <bollu> I've been using diagrams and I'd like to contribute to it as well, but they seem to have a ton of linalg that I'll need to go through (even though I know the math)
12:35:09 <byorgey> bollu: not knowing where to start is not an excuse. =)  Read the code, ask questions, ...
12:35:22 <bollu> byorgey: fair point :)
12:35:24 <Guest34234> emmanuel_erc: well I can only find haskell-indentation-mpde
12:35:28 <Guest34234> mode**
12:35:40 <bollu> byorgey: where can I ask questions when it comes to library code? Is #haskell the right place?
12:35:51 <Guest34234> emmanuel_erc: Haskell indentation mode that deals with the layout rule.
12:35:52 <Guest34234> It rebinds RET, DEL and BACKSPACE, so that indentations can be
12:35:52 <Guest34234> set and deleted as if they were real tabs.
12:35:59 <byorgey> bollu: I am one of the main developers of diagrams, and I think we have plenty of things you can contribute to that do not involve knowing linear algebra.
12:36:28 <byorgey> bollu: sure, #haskell is a good place to ask
12:36:30 <Iceland_jack> bollu: You seem to be picking difficult examples, diagram's website chooses not to be simple for beginners
12:36:52 <Iceland_jack> and lens is in many ways a programming language in and of itself
12:36:59 <arkeet> bollu: there is #diagrams if you want to talk about diagrams :)
12:37:49 <bollu> byorgey: I'm comfortable with linalg and some more math as well (abstract algebra, some analysis), but diagrams seems to use a lot of haskell "tricks" (like Default), plus lens stuff, plus envelopes and all that. I'm intimidated tbh :_
12:37:52 <bollu> arkeet: whoa, cool!
12:37:53 <Iceland_jack> *diagram's website states that they don't focus on beginners
12:38:01 <emmanuel_erc> Guest34234: I can't find that function by the way. And I have haskell-indentation-mode installed.
12:38:10 <emmanuel_erc> I don't have spacemacs though.
12:38:29 <byorgey> bollu: with *any* project you are not going to know where to start.  In some sense, the *entire secret* of getting involved is learning how to push through that feeling of being intimidated, not knowing where to start, etc., and just diving in anyway
12:38:59 <byorgey> if you contribute to a project where you feel entirely comfortable and know what is going on, you are not going to learn anything.
12:39:12 <Iceland_jack> bollu: If you're interested in research, check out the "Monoids: Theme and Variations" by byorgey
12:39:26 <Iceland_jack> the pdf seems to be down http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf
12:39:29 <bollu> byorgey: heh, I suppose so :) Although, like, usually, I'm either super comfortable with the language, or the library ideas. In this case, both of those are slightly alien to me
12:39:42 <bollu> Iceland_jack: thanks!
12:39:54 <byorgey> Iceland_jack, bollu: new location for the PDF is here:  http://ozark.hendrix.edu/~yorgey/pub/monoid-pearl.pdf
12:39:59 <byorgey> I am not at upenn anymore
12:40:14 <arkeet> bollu: then that is an opportunity to learn. :)
12:40:17 <Iceland_jack> There you go bollu :)
12:40:23 <bollu> arkeet: yes :)
12:42:48 <bitemyapp> emmanuel_erc: blargh. how badly do you need trustSym?
12:43:04 <bitemyapp> emmanuel_erc: it's blocking 7.8 compat at the moment.
12:43:08 <emmanuel_erc> let me take a look at my code again.
12:43:49 <emmanuel_erc> Guest34234: I have looked through both the haskell-indentation-mode and spacemacs github repos and it seems that the function is only defined in the latter.
12:43:59 <emmanuel_erc> I am not sure what the problem might be...
12:45:12 <bitemyapp> emmanuel_erc: I think the problem is Herm is 0.17 or newer only, but hmatrix 0.17 isn't GHC 7.8 compatible.
12:45:24 <emmanuel_erc> yea, that's correct
12:45:45 <dfeuer> HI bitemyapp.
12:45:46 <bitemyapp> well, 7.10-only it is, but it'll at least be easier to build.
12:45:49 <bitemyapp> dfeuer: howdy
12:46:03 <emmanuel_erc> I need trustSym because the next function (H.eigSH or L.eigSH) makes that assumption.
12:46:20 <emmanuel_erc> And I need those functions to get the eigenvectors/eigenvalues "in order"""
12:46:45 <emmanuel_erc> But I can consider just ordering those values after the fact.
12:46:52 <bitemyapp> emmanuel_erc: yeah, I was trying to take a light touch so I am going to abandon 7.8 compatibility for now
12:47:12 <bitemyapp> emmanuel_erc: but on the bright side, your upper/lower bounds will mean something in Cabal :)
12:47:27 <emmanuel_erc> Do you think I should seriously considering taking out trustSym?
12:47:35 <emmanuel_erc> **seriously consider
12:47:41 <bitemyapp> emmanuel_erc: nah, it's your project.
12:47:55 <bitemyapp> emmanuel_erc: you're not obligated to support anything you don't want to. I just wanted to help out a bit.
12:48:25 <emmanuel_erc> Well, I would like people to use it and I don't want package dependencies to be a non-starter.
12:48:41 <emmanuel_erc> I'll just add that supporting code at a later time.
12:50:30 <bitemyapp> emmanuel_erc: https://github.com/emmanueldenloye/manifoldRNC/pull/1
12:50:36 <bitemyapp> emmanuel_erc: that's all from me for now.
12:51:12 <bitemyapp> emmanuel_erc: I can revisit 7.8 compat via Stack if you manage to change that code, otherwise, don't sweat it. Really, it doesn't matter.
12:51:31 <old_spice> question about valid function identifiers:
12:51:45 <emmanuel_erc> I am about to merge your changes bitemyapp, I am just looking over them.
12:51:57 <old_spice> in parsec package there are functions:
12:52:05 <old_spice> (<||>)
12:52:11 <old_spice> (<$$>)
12:52:21 <old_spice> et al
12:52:26 <old_spice> are they valid?
12:52:43 <byorgey> old_spice: yes
12:52:51 <byorgey> they are operators
12:53:18 <old_spice> can we say:
12:53:20 <bitemyapp> emmanuel_erc: as thou wilt.
12:53:43 <old_spice> combination of any op characters can be used as function identifier?
12:53:47 <dfeuer> WHYYYYYY. Argh!  Why the heck does docTypeHtml have type Html->Html? Shouldn't there be one type for the contents of an HTML document and another for that document with the doctype and <html></html> tags?
12:54:27 <clrnd> @define ##$## = 7
12:54:27 <lambdabot>  Parse failed: Parse error: ##$##
12:54:40 <emmanuel_erc> Thanks again!
12:54:57 <liste> > let (##$##) = 7 in (##$##)
12:54:59 <lambdabot>  <hint>:1:11: parse error on input ‘)’
12:55:15 <monochrom> old_spice: yes for infix. add parentheses for prefix.
12:56:01 <old_spice> can op chars be mixed with regular characters?
12:56:06 <arkeet> > let ( ##$## ) = 7 in ( ##$## )
12:56:06 <byorgey> old_spice: no
12:56:08 <lambdabot>  7
12:56:09 <old_spice> how about this:
12:56:26 <arkeet> liste: MagicHash
12:56:39 <old_spice> (%funA>)
12:56:44 <monochrom> no
12:56:45 <arkeet> no
12:56:50 <byorgey> old_spice: if you want all the nitty-gritty details, see https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-180002.4
12:56:54 <monochrom> pure punctuation or pure alphanum
12:57:20 <old_spice> cheers!
12:57:40 <old_spice> and if pure punctuation, then either (...) or `...`, right?
12:57:53 <bollu> so, a monad is an endofunctor + some extra structurE?
12:58:01 <monochrom> no. "(...) 1 2" or "1 ... 2"
12:58:05 <byorgey> bollu: yes
12:58:28 <old_spice> no op chars in infix?
12:58:35 <dfeuer> More generally, why doesn't BlazeHtml use the type system to enforce basic rules of document structure?
12:58:38 <monochrom> "1 ... 2" is infix
12:59:08 <old_spice> sorry I meant no `<%>`
12:59:28 <old_spice> 1 <%> 2
12:59:29 <old_spice> or
12:59:30 <byorgey> old_spice: operators are infix by default, and can be made prefix with (...).  Identifiers are prefix by default, and can be made infix with `...`
12:59:30 <monochrom> I don't understand the question
12:59:38 <old_spice> (<%>) 1 2
12:59:48 <byorgey> those are equivalent
12:59:52 <old_spice> got it!
12:59:52 <monochrom> yes, "1 <%> 2" or "(<%>) 1 2"
13:00:03 <old_spice> cheers guys
13:00:24 <emmanuel_erc> bitemyapp: What does dunzokopf mean? You're welcome?
13:00:43 <old_spice> thank you the link to nitty-gritty too ;)
13:00:57 <old_spice> thank you _for_ the link...
13:01:01 <byorgey> sure, that's some good bedtime reading there =)
13:01:06 <old_spice> :D
13:01:13 <bitemyapp> emmanuel_erc: it means it's hella done
13:01:44 <bitemyapp> emmanuel_erc: I don't say your welcome before someone has thanked me, that's would be p rude of me.
13:01:58 <bitemyapp> you're* welcome
13:02:13 * bitemyapp returns to ordinary work
13:02:33 <old_spice> I've seen worse (SMTP , IMAP rfcs)
13:03:13 <emmanuel_erc> oh lol
13:03:52 <aweinstock> > 5 `mod` 2 -- old_spice
13:03:54 <lambdabot>  1
13:04:31 <old_spice> yes, alphanum infix is clear
13:04:57 <old_spice> it's (<||>) that caught me off guard
13:05:54 * hackagebot Cartesian 0.1.0.0 - Coordinate systems  https://hackage.haskell.org/package/Cartesian-0.1.0.0 (SwiftsNamesake)
13:06:01 <old_spice> ' mind me asking:
13:06:12 <old_spice> what's this:
13:06:15 <old_spice> Branch (mapPerms (f.) perm) p
13:06:26 <old_spice> in particular, "f."
13:06:40 <old_spice> ?
13:06:43 <Iceland_jack> old_spice: Are you familiar with (.)?
13:06:49 <Iceland_jack> > (succ.succ) 10
13:06:52 <lambdabot>  12
13:06:53 <monochrom> . is as in function composition sin . sqrt, aka (.) sin sqrt
13:07:12 <old_spice> yes, I think
13:07:18 <monochrom> and then there is section syntax e.g. (1 +) means (\x -> 1 + x)
13:07:30 <monochrom> so (f .) means (\g -> f . g)
13:07:33 <old_spice> is a space not expected though?
13:07:38 <Iceland_jack> no
13:07:46 <Iceland_jack> old_spice: Just like you can write an "operator section" with (+), no space
13:07:46 <Iceland_jack> > (1+) 10
13:07:48 <lambdabot>  11
13:07:51 <monochrom> space is just to separate tokens.
13:08:05 <monochrom> and sometimes for humans' sake
13:08:09 <old_spice> but we see this only in (), right?
13:08:16 <old_spice> I mean, (f.)
13:08:18 <monochrom> the computer's bottomline is tokens, not space
13:08:31 <old_spice> is f. valid without ()?
13:08:35 <Iceland_jack> no
13:08:41 <monochrom> but f.g is valid
13:08:52 <old_spice> right
13:08:54 <Iceland_jack> Yes, you couldn't write
13:08:55 <Iceland_jack>     foo = f.
13:09:08 <Iceland_jack> just like you can't write 'foo = 1+'
13:09:26 <Iceland_jack> but … are valid
13:09:26 <Iceland_jack>     bar = (f.)
13:09:26 <Iceland_jack>     bar = (1+)
13:09:53 <old_spice> ok got it..
13:10:02 <old_spice> will watch out for f.g
13:10:11 <old_spice> it nearly caught me too
13:10:44 <old_spice> I thought  f . g was ok, f.g was not
13:11:26 <old_spice> thank you guys.. this will keep me quiet for a while..
13:11:33 <old_spice> :-P
13:12:27 <monochrom> x+y and sin.sqrt are valid
13:13:16 <rarara__> I never managed to understand anything of Haskell programs
13:13:30 <old_spice> well + is kind of natural, but I thought . would be given its space to prevent ambiguity
13:13:52 <Iceland_jack> rarara__: What gave you trouble
13:14:22 <Iceland_jack> old_spice: That's true of certain things
13:14:22 <Iceland_jack> :t Just.Just
13:14:23 <lambdabot> Not in scope: data constructor ‘Just.Just’
13:14:26 <Iceland_jack> :t Just . Just
13:14:28 <lambdabot> a -> Maybe (Maybe a)
13:14:43 <monochrom> yes actually it is wise to be more careful with . , since later when you also have modules you will have ModuleName.funcname which does not mean function composition
13:15:09 <monochrom> and it can't be written as ModuleName . funcname
13:15:09 <rarara__> I think that I don't know where to start: how do you load a list from a file
13:15:14 <obadz> is there an efficient way of dropping the last character from a bytestring?
13:15:15 <old_spice> yes, this is what I mean: . is special case already
13:16:27 <Iceland_jack> rarara__: 
13:16:27 <Iceland_jack>     main = do
13:16:27 <Iceland_jack>       file <- "/tmp/list.txt"
13:16:27 <Iceland_jack>       print (file :: [Int])
13:16:28 <rarara__> it isfull of examples; but they all deal with literals
13:16:43 <old_spice> thank you guys
13:17:13 <Iceland_jack> oops rarara__  :) that should be 
13:17:13 <Iceland_jack>     file <- readFile "/tmp/list.txt"
13:17:41 <Iceland_jack> Actually
13:17:41 <Iceland_jack>     main = do
13:17:41 <Iceland_jack>       file <- readFile "/tmp/list.txt"
13:17:41 <Iceland_jack>       print (read file :: [Int])
13:17:51 <rarara__> ok, I see a ':: [Int]' which seems a bit magical
13:18:08 <Iceland_jack> rarara__: We can focus on that first
13:18:21 <Iceland_jack> Do you understand
13:18:21 <Iceland_jack> > 1 :: Int
13:18:23 <lambdabot>  1
13:18:45 <rarara__> > "Ciao' :: Int
13:18:46 <martinvlk> rarara__: I've been learing Haskell for good few months now and I can say it does take lots of study. I don't think ordinary mortals just get it from looking at code.
13:18:46 <lambdabot>  <hint>:1:14:
13:18:46 <lambdabot>      lexical error in string/character literal at end of input
13:19:19 <rarara__> So it's a kind of hypercoercion ?
13:19:33 <Iceland_jack> rarara__: Not at all
13:19:45 <rarara__> what is it?
13:19:47 <Iceland_jack> it's an "annotation"
13:20:12 <Iceland_jack> you're telling lambdabot: "1" is an Int
13:20:20 <bitemyapp> martinvlk: hi :)
13:20:42 <aweinstock> monochrom: is ModuleName.TypeConstructor the only ambiguous case for dot-without-spaces?
13:20:55 * hackagebot Cartesian 0.1.0.1 - Coordinate systems  https://hackage.haskell.org/package/Cartesian-0.1.0.1 (SwiftsNamesake)
13:21:00 <martinvlk> :-)
13:21:10 <martinvlk> bitemyapp, hey
13:21:11 <rarara__> > (1, 2)
13:21:12 <davidthomas> eiecccevhdklvnetbbhhhhjrulthjiikknnitdnvjgrr
13:21:14 <lambdabot>  (1,2)
13:21:20 <rarara__> > (1, 2) :: [Int]
13:21:24 <davidthomas> :(
13:21:24 <lambdabot>      Couldn't match expected type ‘[Int]’
13:21:24 <lambdabot>                  with actual type ‘(Integer, Integer)’
13:21:24 <lambdabot>      In the expression: (1, 2) :: [Int]
13:21:39 <Iceland_jack> > (1 :: Int, 2 :: Int)
13:21:40 <davidthomas> (bumped my yubikey trying to plug in my computer, don't mind me :p)
13:21:42 <lambdabot>  (1,2)
13:21:46 <Iceland_jack> > (1, 2) :: (Int, Int)
13:21:48 <lambdabot>  (1,2)
13:22:00 <Iceland_jack> > (1, 2, True) :: (Int, Int, Bool)
13:22:02 <rarara__> Ok, so what about the square brakets?
13:22:02 <lambdabot>  (1,2,True)
13:22:08 <Iceland_jack> Those are lists
13:22:12 <bitemyapp> rarara__: you're going about this in the hardest way possible.
13:22:17 <magneticduck> roflmao
13:22:34 <magneticduck> let's introduce rarara__ to lenses and hope the haskell 'trickles down'
13:22:39 <magneticduck> I think that's a new teaching strategy
13:22:48 <Iceland_jack> :)
13:23:04 <clrnd> lenses? back in my days it was monad that did the trick
13:23:21 <magneticduck> pft
13:23:22 <Copperis> how do I run a program with stack?
13:23:27 <magneticduck> monads are just burritos
13:23:32 <clrnd> stack exec my-program
13:23:48 <magneticduck> lenses are burritos full of space-suits painted in primary colors
13:24:10 <Copperis> thanks, clrnd 
13:25:55 * hackagebot WaveFront 0.1.0.0 - Parsers and utilities for the OBJ WaveFront 3D model format  https://hackage.haskell.org/package/WaveFront-0.1.0.0 (SwiftsNamesake)
13:26:48 <rarara__> > (1, 2) :: [Int, Int]
13:26:49 <lambdabot>      Expected a type, but ‘'[Int, Int]’ has kind ‘[*]’
13:26:50 <lambdabot>      In an expression type signature: '[Int, Int]
13:26:50 <lambdabot>      In the expression: (1, 2) :: '[Int, Int]
13:27:10 <Iceland_jack> rarara__: Have you looked at resources for learning Haskell
13:27:32 <rarara__> I've looked at some blogs
13:28:07 <clrnd> is there a library with fixed/typed length lists that does lenses?
13:28:09 <rarara__> I understand that people here read books
13:29:20 <Copperis> rarara__, http://learnyouahaskell.com/chapters is good
13:29:55 <monochrom> square bracket is for list, (1,2) is for tuple. they are unrelated.
13:30:36 <monochrom> the type of (1, 2) will have to be (Int, Int)
13:31:13 <monochrom> this is a list: [1,2,3,4,1]. but it's type is [Int], not [Int, Int, Int, Int, Int].
13:31:15 <rarara__> monochrom : ok, but it doesn't explain the [ ] in read file :: [Int]
13:31:37 <rarara__> thanks, so read is a list
13:31:43 <Iceland_jack> no
13:32:03 <rarara__> can be annotated as such, no?
13:32:19 <monochrom> ok, read :: String -> [Int], file :: String, so read file :: [Int]
13:32:44 <martinvlk> rarara__: I'd say the best and most up to date resource currently available is http://haskellbook.com
13:37:04 <Hijiri> @where learnhaskell
13:37:04 <lambdabot> https://github.com/bitemyapp/learnhaskell
13:37:10 <Hijiri> rarara__: ^ there's this too
13:37:43 <clrnd> I wish I knew fancy type theory sometimes
13:40:56 * hackagebot react-flux 1.0.2 - A binding to React based on the Flux application architecture for GHCJS  https://hackage.haskell.org/package/react-flux-1.0.2 (JohnLenz)
13:41:17 <monochrom> do you already know non-fancy type theory? :)
13:41:41 <joeyh> are ImpredicativeTypes best avoided? I wanted: IO (Outputable v => v -> IO ())
13:42:12 <clrnd> mmmm I'm not sure, probably not
13:42:25 <monochrom> yes, GHC has never finished implementing ImpredicativeTypes
13:43:12 <clrnd> I know set theory, it's supposed to be simillar
13:43:16 <clrnd> (don't hit me please)
13:43:40 <monochrom> one option to consider is newtype wrapper. "newtype X = MkX (forall v. Outputable v => v -> IO ())" is fully supported. then you can have IO X
13:43:45 <joeyh> I thought so.. wish ghc would say "you might want this.. but probably not"
13:43:56 <monochrom> to be sure, sometimes newtype wrapping sucks
13:44:33 <dolio> Apparently there are plans to implement it better again. We'll see what happens.
13:45:01 <monochrom> whoever figure it out should win a Millenium Prize :)
13:51:25 <fosterite> @pl \f -> \a -> f $ \g -> g a
13:51:25 <lambdabot> (. flip id)
13:51:29 <utdemir> Hey. I'm writing a servant API definition and all of my endpoints start with a common part: 'Header "X-TrackerToken" Text :> "services" :> "v5"'. How can I remove this repetition. making a  "type Common = Header ...." and using "Common" on those places gives me many type errors.
13:51:40 <arkeet> :t \f a -> f (\g -> g a)
13:51:41 <lambdabot> (((r2 -> r1) -> r1) -> r) -> r2 -> r
13:52:32 <fosterite> :t (. flip id) Just
13:52:34 <lambdabot> b -> Maybe ((b -> c) -> c)
13:53:18 <fosterite> :t Just . flip id
13:53:19 <lambdabot> b -> Maybe ((b -> c) -> c)
13:54:46 <fosterite> :t Just . (&)
13:54:48 <lambdabot> a -> Maybe ((a -> b) -> b)
13:57:56 <duwang> hey guys, whats the subtraction equivalent of the sum function?
13:58:25 <monochrom> perhaps simply sum first, then just tag on a minus sign?
13:58:54 <fizbin> Either (foldl' (-) ) or (foldr (-)) depending on what you mean.
13:58:56 <clrnd> > foldr (-) 0 [1..5]
13:58:58 <lambdabot>  3
13:59:08 <hiptobecubic> clrnd, perfect
13:59:23 <kadoban> duwang: What should it do exactly?
13:59:24 <fosterite> > foldl' (-) 0 [1,2,3]
13:59:26 <lambdabot>  -6
13:59:31 <duwang> yeah I think I'm looking for foldr
13:59:37 <clrnd> yeah it depends what s/he wants
13:59:46 <duwang> Because I want the list to be subtracted from the first element
13:59:57 <hiptobecubic> 1 - (2 - (3 - ... ?
14:00:04 <duwang> yeah
14:00:28 <fizbin> duwang: So for [2, 2, 2], you'd expect to get the answer "2"?
14:00:29 <sjors_> I'm reading Learn You A Haskell and I'm coming across something I don't remember. What does the <=< operator mean?
14:00:43 <clrnd> :t (<=<)
14:00:45 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
14:00:46 <duwang> sjors_: yeah
14:01:06 <clrnd> it looks like a monadic (.)
14:01:07 <kadoban> sjors_: It's like (.), but for Monads. Kinda.
14:01:08 <martinvlk> Kleisli composition
14:01:19 <sjors_> OK, thanks!
14:01:20 <clrnd> :t liftM2 (.)
14:01:22 <lambdabot> Monad m => m (b -> c) -> m (a -> b) -> m (a -> c)
14:01:24 <fizbin> sjors_: (<=<) and (>=>) are the monadic analogues of (.)
14:01:27 <clrnd> ha
14:01:45 <fizbin> They flow the calculation in different directions.
14:02:04 <fizbin> I find (>=>) often more useful than (<=>)
14:02:14 <fizbin> Sorry, ... than (<=<)
14:02:18 <bollu> :t (<=>)
14:02:22 <lambdabot>     Not in scope: ‘<=>’
14:02:22 <lambdabot>     Perhaps you meant one of these:
14:02:22 <lambdabot>       ‘<$>’ (imported from Control.Applicative),
14:02:29 <bollu> oh, dang. I was hoping for a cool combinator
14:02:49 <kadoban> fizbin: Me too. But then I kinda prefer a flipped version of (.), and wish that were the default.
14:03:08 <fizbin> kadoban: flip (.) is spelled (>>>)
14:03:16 <bollu> kadoban: use (|>) = flip ($)
14:03:39 <fizbin> Okay, technically >>> is more general that "flip (.)", but that's the only thing I use it for.
14:03:42 <kadoban> fizbin: Ya I know. Thanks
14:04:44 <kadoban> bollu: That's not really the same thing though.
14:05:01 <bollu> kadoban: yes, composition versus application
14:05:08 <kadoban> Right
14:05:20 <fizbin> I guess I used Kleisli arrows once, and there was that three weeks I spent thinking that HXT was the one true way to do XML.
14:06:03 <fizbin> But other than that, (>>>) is just a way of spelling "flip (.)"
14:06:18 <kadoban> The precedence is different too, though I'm not clear on if that usually matters.
14:07:02 <kadoban> I used to use a self-defined operator (&) which was just flip (.), though I haven't in a while. I also didn't realize that (&) existed elsewhere at the time, so I dunno what I'd do now.
14:07:20 <kadoban> Mostly I just suck it up and use (.) anyway, even though I'm not terribly happy with it, heh.
14:07:25 <Iceland_jack> Data.Function has (&) since 7.10 I believe
14:07:35 <Iceland_jack> at *least* since 7.10
14:07:36 <sjors_> What's wrong with (.) ?
14:08:19 <kadoban> sjors_: It requires annoying editor movement, IMO. Or thinking backwards from the result to the input, which I find harder to think that way.
14:08:55 <kadoban> You have to write the function that happens first, then move left a bunch and then ., move left more, then do the next step. Instead of just writing it straight out.
14:09:05 <sjors_> kadoban: I see
14:09:52 <monochrom> my brain tosses a coin to decide whether it prefers "f . g . h" or "h & g & f"
14:10:16 <Iceland_jack> monochrom: 'over g' :)
14:10:25 <monochrom> yikes
14:10:26 <Iceland_jack> meh
14:10:59 <Iceland_jack> or rather, 
14:10:59 <Iceland_jack>     over (iso f h)
14:11:08 <kadoban> Iceland_jack: The (&) in Data.Function is flip ($) though, which isn't the one that I want (I know, the confusion is my fault, but it's still not exactly my goal).
14:11:19 <Iceland_jack>     over (iso h f)
14:11:33 <monochrom> when my brain tosses a coin, there is 0.001% the coin lands on its edge and so it is neither head nor tail. then what does my brain prefer?
14:11:39 <glguy> Iceland_jack: probably better to stick to using 'iso' for actual isos
14:11:42 <monochrom> answer: then my brain prefers a data-flow diagram
14:12:18 <Iceland_jack> Not a serious suggesion 
14:14:27 <fosterite> is there a library that handles working with meshes neatly?
14:16:28 <duwang> thanks guys, its working a lot better now
14:16:30 <fosterite> or at all, really
14:17:48 <lpaste> amf pasted “tojson and mvars” at http://lpaste.net/144211
14:17:53 <amf> i have a data structure that has an mvar in it. how do i properly read the value in a ToJSON instance?
14:19:08 <glguy> You don't
14:20:02 <glguy> You could write a function :: TypeWithMVar -> IO TypeWithoutMVar
14:20:10 <glguy> and have a ToJSON instance for TypeWithoutMVar
14:21:00 <amf> ahh ha! thanks glguy 
14:31:20 * hackagebot Michelangelo 0.1.0.0 - OpenGL for dummies  https://hackage.haskell.org/package/Michelangelo-0.1.0.0 (SwiftsNamesake)
14:36:21 * hackagebot crypto-enigma 0.0.2.3 - An Enigma machine simulator with display.  https://hackage.haskell.org/package/crypto-enigma-0.0.2.3 (Orome)
14:36:25 <alpounet> utdemir: did you get an answer to your servant question?
14:39:52 <tommd> glguy: I have a PR changing me from Control.Monad.Error to Control.Monad.Except.
14:40:27 <tommd> glguy: I see .Except only appears in MTL 2.2.0.1 (point release) so I can't actually release a well formed, PVP compliant, package if I use Except.. it seems.
14:40:32 <tommd> Am I missing something?
14:41:58 <glguy> You can depend on transformers-compat and you're compatible back to transformers-0.2
14:42:08 <glguy> or you can keep using .Error since it's dumb that it's deprecated
14:42:33 <glguy> Unless you're not actually taking advantage of .Error's fail behavior (which is what sets it apart)
14:42:34 <tommd> Yes, I agree with that much.
14:46:32 * hackagebot Michelangelo 0.1.0.1 - OpenGL for dummies  https://hackage.haskell.org/package/Michelangelo-0.1.0.1 (SwiftsNamesake)
14:46:34 * hackagebot monadcryptorandom 0.7.0 - A monad for using CryptoRandomGen  https://hackage.haskell.org/package/monadcryptorandom-0.7.0 (ThomasDuBuisson)
14:46:47 <liste> Yaway zzz
14:51:33 * hackagebot crypto-enigma 0.0.2.4 - An Enigma machine simulator with display.  https://hackage.haskell.org/package/crypto-enigma-0.0.2.4 (Orome)
14:54:11 <danza> is there a reason why >>= uses `forall a b` in the type signature, while for example <*> does not use it?
14:55:13 <hpc> :t (>>=)
14:55:14 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:55:19 <hpc> ?
14:55:24 <glguy> No, you're probably just looking at different command outputs, danza
14:55:44 <danza> http://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Monad.html#v:-62--62--61-
14:55:54 <hiptobecubic> Guys i just wrote a constant time sat solver! There's some kind of award for that probably, right?
14:56:07 <hiptobecubic> The trick is to ignore all the constraints and just return garbage results.
14:56:21 <tommd> So what about a sound and complete constant time sat solver?
14:56:30 <hiptobecubic> And to think I did it in only a few days
14:56:33 <hpc> @let satSolver _ = 2400
14:56:34 <lambdabot>  Defined.
14:57:01 <hpc> (that's a really funny joke to students in the US)
14:57:03 <tommd> hpc: You should at least you monoid so you can use mempty to get the right result type.
14:57:18 <hiptobecubic> hpc, I'm too old. I didn't get it at first :(
14:57:35 <hpc> hiptobecubic: it used to be satSolver _ = 1600
14:57:39 <Lokathor> hpc, i had a 2 part SAT, last year that did
14:57:40 <hiptobecubic> Yes
14:58:00 <hiptobecubic> Lokathor, i think i was also in the last year, or maybe the year before. 2004ish?
14:58:01 <lingxiao> I'm reviewing final projects ideas in an haskell class where moands and monad transformers are taught, along with GADTs
14:58:10 <glguy> danza: The type of >>= in that context is identical with or with out the forall part. Someone was just having fun with a language extension
14:58:11 <Lokathor> hiptobecubic, sounds right
14:58:27 <glguy> danza: see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/other-type-extensions.html#explicit-foralls
14:58:34 <hiptobecubic> Was anyone else sad that they did better in english than math? :(
14:58:35 <lingxiao> I'd like some second opinions from the community on whether y'all think these projects are fruitful learning expreiences
14:58:55 <hiptobecubic> lingxiao, failures are usually pretty good learning experiences too
14:58:59 <hiptobecubic> At least I hope they are :)
14:59:03 <lingxiao> hiptobecubic: I did better on reading than math on both SAT and GRE
14:59:09 <hpc> what's the project, out of curiosity?
14:59:27 <danza> glguy, but in the end, that forall shows up in the official doc ... anyway, not a big deal ... i don't get what the extension is for
14:59:35 <lingxiao> hiptobecubic: we're mellenials so that lesson is lost to us :)
14:59:49 <lingxiao> hpc they get to come up with their own
15:00:07 <lingxiao> so you know people say they're going to do stuff with GUIs which is clearly a bad idea
15:00:14 <hiptobecubic> yes, avoid
15:00:18 <lingxiao> but others I'm not so sure .. hence the multiple opinons
15:00:24 <lingxiao> or maybe suggest a better version... so
15:00:26 <hiptobecubic> HsQML isn't that bad honestly, but it's not very haskelly. 
15:00:31 <hiptobecubic> It's basically javascript with haskell callbacks
15:00:36 <lingxiao> The goal of this project is to build from scratch an entire
15:00:36 <lingxiao>     system to allow a user to play a Sudoku game
15:00:48 <lingxiao> project 1. sudoku with GUI
15:01:02 <lingxiao> so let's take out the GUI, does it make sense to even write a game in Haskell ?
15:01:11 <tommd> Yes, it has been done many times.
15:01:17 <hiptobecubic> there are a lot of good games that don't involve guis
15:01:25 <hpc> speaking from experience in "do a big project" assignments, give them some basic initial stuff
15:01:30 <danza> glguy, thanks for clarifying! :)
15:01:32 <tommd> It is a common beginner task.  Tic-tac-toe, break-out, astroids, sudoku...
15:01:41 <hpc> like line :: (Int x 4) -> IO (), etc
15:01:52 <MarcelineVQ> seeing a parallel sudoku solver in action i haskell brings a tear to my eye
15:01:56 <MarcelineVQ> *In
15:01:59 <hpc> or like an initial program that uses only platform stuff
15:02:12 <hpc> because it can be hell to do GUI on windows
15:02:25 <lingxiao> ok so I should mention, one important criteria in this project is that there should be some design decision
15:02:37 <hiptobecubic> lingxiao, well what are you trying to have them learn from this? just how to use GADTs and monads?
15:02:46 <lingxiao> you know, define a datatype, maybe even using GADTs, then define functor ... monads, then write some combinators
15:03:02 <lingxiao> GADT is optional, but it's CIS 552 at Penn
15:03:02 <hiptobecubic> There are a lot of interesting problems to model that aren't games
15:03:14 <lingxiao> so http://www.seas.upenn.edu/~cis552/schedule.html
15:03:23 <lingxiao> yeah that was just one proposal ...
15:03:31 <lingxiao> by a student
15:04:02 <lingxiao> I'm saying supose they want to do a game ... what are some good games and things you can do with games that will enrich their exprerience?
15:04:22 <lingxiao> Like the professor suggested Dominion
15:04:40 <hpc> a sudoku solver is good from a general programming standpoint because there's interesting techniques but it's still open to brute forcing
15:04:43 <lingxiao> and MarcelineVQ suggested using haskell's par monad ... or soemthing similar right?
15:05:11 <lingxiao> or maybe people can play with FRP
15:05:46 <hiptobecubic> what about a feed reader?
15:05:49 <hpc> since you're doing red-black trees, solving a 2-player game might be good too
15:06:13 <lingxiao> hiptobecubic: you mean like read RSS?
15:06:16 <hpc> maybe "for arbitrary n, solve tic-tac-toe on n x n board"
15:06:17 <lingxiao> hpc hmm how so?
15:06:28 <lingxiao> involving red-black-trees I mean
15:06:37 <hiptobecubic> lingxiao, yes, for example. or Atom, or a custom format
15:07:30 <lingxiao> hiptobecubic: wait you mean Atom the text editor?
15:07:43 <hpc> lingxiao: er nvm, was thinking alpha-beta
15:07:43 <hiptobecubic> lingxiao, lord no. I mean an atom feed. It's like RSS
15:07:52 <lingxiao> oh haha sorry 
15:07:53 <lingxiao> !
15:07:55 <hpc> and going from one to the other is a bit of a leap
15:08:08 <lingxiao> hiptobecubic: ok yeah that's a good idea
15:08:19 <lingxiao> I'll write thatone down
15:08:30 <lingxiao> hpc you mean going from 3 x 3 board to n x n ?
15:08:53 <hpc> having them make a simple language would be good too
15:09:30 <hiptobecubic> there's a lot too that though
15:09:32 <hiptobecubic> to*
15:09:48 <lingxiao> yeah some people are doing that
15:09:56 <lingxiao> ie: Type checker + interpreter for stack-oriented language
15:11:08 <hiptobecubic> Modeling a turn based adventure game is easy enough to imagine, although perhaps not very inspiring
15:11:26 <lingxiao> hiptobecubic hmm what would be the design aspect of that?
15:11:46 <lingxiao> hpc can I ask you to expand on using red-black trees for two player sudoku?
15:11:50 <hiptobecubic> how to represent characters, battles between characters, different kinds of items and how they affect the player / battle, etc
15:12:15 <hiptobecubic> you can probably go pretty far with jamming that into the types if you tried
15:12:22 <hpc> lingxiao: there is no two-player sudoku
15:12:35 <hpc> lingxiao: i was thinking tictactoe, and mistaking red-black for α-β
15:13:14 <hpc> lingxiao: but don't suggest that to students unless they already know the basics
15:13:37 <hpc> it's not something everyone can figure out on their own
15:14:05 <lingxiao> hpc ok I'll talk to them about it!
15:14:28 <hiptobecubic> writing an AI for a game without an obvious best move is also good
15:14:36 <hpc> (it might be a good modification to your lesson plan, but that's a bit more involved)
15:17:25 <lingxiao> hpc oh im just a TA! but I'll relay the message!
15:17:55 <hpc> yeah
15:18:28 <hpc> having them do something with IO would be good
15:18:45 <hpc> so they can get a feel for when things don't fit into nice abstract boxes
15:19:41 <lingxiao> hpc yea I hope people walk away thinking it's just a very beatufiul language, but nontheless designed by humans with its flaws
15:32:29 <danza> if i was a student i would ask my prof to teach me how to do common things with Haskell ... like mobile or web applications ... and currently you really need some good knowledge in order to get something done there
15:33:28 <danza> for example i am studying monad transformers in order to understand some errors i get with GHCJS
15:43:07 <obb> https://wiki.haskell.org/Foldr_Foldl_Foldl%27
15:43:43 <obb> just read this article and wanted to try out foldl' but it doesn't seem to be in the prelude
15:43:47 <obb> why?
15:44:39 <lingxiao> danza : I agree that's a real problem, but in the years past students just used some library and wrote some glue code :(
15:44:39 <nwf> Hey gang; I have a possibly-stupid question.  I'd like to define "data X (k :: * -> *) = X { ... }" but restrict it to choices of "k" where k's argument role is "phantom".  Is it possible to assert this in some machine-checkable way?
15:46:19 <danza> lingxiao, you mean that it is not a learning process that way? well, probably with that kind of challenges it is actually hard to dose the effort ... it might become too hard or too easy
15:48:19 <tzh> obb: it's in Data.List and/or Data.Foldable, and i assume it's not in the prelude because it's just not a function that comes up that much, or something. certainly comes up less than foldr, at lest
15:48:25 <MarcelineVQ> obb, you can import Data.List to get foldl', it's not in the prelude probably because foldl compiled with optomzisations thens to be made into foldl' anyway, as I understand it, and because it's specialized
15:48:39 <MarcelineVQ> *tend to be made
15:49:33 <MarcelineVQ> Is that correct about the optimisation, haskell gurus?
15:51:16 <obb> thanks guys, didn't know that it was optimized
15:51:55 <jophish> Does anyone know any category theory one liners?
15:52:22 <lingxiao> danza haha I didn't write the course requirements, but if I had to argue for it .. Id say we want them to realize the marginal value of haskel over other languages
15:52:38 <lingxiao> that is ADTs and defining the various algebras over them
15:53:05 <lingxiao> then writing some combinators so they can write cute code like (g1 <$> m) <|> (g2 <$> m2) <|> ... 
15:53:20 <danza> yes, good point. struggling with user interfaces probably does not show the shining parts that easily
15:53:34 <danza> even though functional reactive programming is getting very, very popular
15:57:17 <danza> ... and i found that my experience with Haskell helped me also using functional reactive programming elsewhere
16:01:22 <obb> sorry i have a problem with types that I dont understand
16:01:24 <obb> totient' :: Integer -> Integer
16:01:24 <obb> totient' x = foldl (+) 0 [(p-1) * (p ** (m-1)) | (p,m) <- primeFactors' x]
16:01:28 <obb> i have this function
16:01:48 <obb> primeFactors' gives me [(Integer, Integer)]
16:02:06 <obb> so now the compiler says that No instance for (Floating Integer) arising from a use of ‘**’
16:02:29 <obb> tried to truncate (p ** (m-1)) but it doesnt solve my problem
16:03:16 <danza> :t **
16:03:18 <lambdabot> parse error on input ‘**’
16:03:25 <danza> :t (**)
16:03:27 <lambdabot> Floating a => a -> a -> a
16:05:31 <danza> :t fromInteger
16:05:32 <lambdabot> Num a => Integer -> a
16:05:58 <obb> ok thx
16:10:11 <danza> no problem ... numbers in Haskell gave me some headaches, then i realised that fromInteger fixes most of the related problems :D
16:10:37 <obb> yeah used ^ now
16:11:08 <obb> the task was a bit tricky, because they encouraged to use ** and i wasn't aware of the different power operators
16:11:23 <obb> then again it might have been the objective to make me aware of them :D
16:12:58 <danza> in a perfect world maybe the compiler could say: "Integer is not an instance of Floating"... but maybe there is something i am missing
16:15:21 <danza> well for example that wouldn't scale to more complex types i guess
16:16:10 <deni> anyeone working with Data.Yaml can tell me what this means and how to debug it: Left (AesonException "when expecting a [a], encountered Object instead")
16:16:52 <glguy> Looks like something expected a list and got an object instead
16:17:15 <glguy> Does your YAML have an object somewhere where a list was expected?
16:18:50 <jophish> I have a feeling this is below the fairbairn threshold, but is there a synonym for (fmap . view)?
16:19:05 <deni> this is the code btw: http://dpaste.com/2KTBSDW
16:19:09 <arkeet> :t fmap . view
16:19:10 <lambdabot> Functor f => Getting b s b -> f s -> f b
16:20:05 <deni> and the file that i'm parsing looks like the example here: https://docs.docker.com/compose/django/
16:20:36 <deni> glguy: some of the entries don't have all the things that i listed in that data type
16:20:42 <deni> as show in the example above
16:20:44 <jophish> > (fmap . view) _2 [(1,2),(3,4)] -- for example
16:20:47 <lambdabot>  [2,4]
16:21:17 <glguy> jophish: Not that I know of. using fmap is the right answer there
16:21:39 <arkeet> in that case you could also
16:21:52 <arkeet> > toListOf (traverse . _2) [(1,2),(3,4)]
16:21:54 <lambdabot>  [2,4]
16:22:03 <jophish> I've become a little accustomed to having everything imaginable in lens:)
16:24:03 <glguy> deni: Your ComposeContainerSpec looks like it's only the web: key of your yaml file
16:24:21 <deni> glguy: what do you mean?
16:24:48 <glguy> The example file on the page you linked had a db: section and a web: section
16:25:00 <deni> yes
16:25:11 <deni> that's why ComposeFile is a list of [ComposeContainerSpec]
16:25:33 <glguy> db: this \n web: that \n isn't a list of things
16:25:40 <glguy> it's an Object of things
16:25:58 <deni> hmmm I thought that it would be a list of things.
16:26:04 <deni> how would I model my data type then....
16:26:26 <deni> because each entry (db, web, etc) can have all of the fields in ComposeContainerSpec
16:26:38 <glguy> You'll have a   Map String ComposeContainerSpec   or something
16:29:54 <deni> glguy: that makes sense.
16:30:14 <deni> now I'm faced with another error: Left (AesonException "The key \"image\" was not found")
16:30:26 <Welkin> deni: parse error
16:30:48 <deni> I'm thinking that the keys that don't need to be defined should be a Maybe a
16:31:02 <deni> glguy: Welkin what do you think?
16:31:08 <Welkin> yes
16:31:17 <Welkin> for your data type you are marshaling to from json
16:33:39 <deni> the issue I'm facing now is that fieldA needs to be defined if fieldB isn't defined. But if fieldB is defined then not having fieldA is fine
16:33:54 <deni> do I solve this with smart constructors or something like that?
16:34:15 <Welkin> for marshaling from JSON to haskell?
16:34:19 <Welkin> or the other way?
16:34:55 <hpc> Alternative, perhaps?
16:36:41 <deni> Welkin: from json to haskell
16:37:14 <deni> Welkin: but actually that validation should have to hold the other way as well..from haskell to json....and yes this is where i could use smart constructor..I'm not sure about the other way though
16:37:24 <deni> hpc: Alternative?>
16:37:57 <hpc> it defines (<|>) which is a sort of "this or that" operator
16:38:14 <hpc> for parsers, (a <|> b) is the result of a if it succeeds, or else b
16:38:34 <hpc> > Nothing <|> Just 5
16:38:36 <lambdabot>  Just 5
16:38:41 <hpc> > Just 5 <|> Just 25
16:38:43 <lambdabot>  Just 5
16:38:49 <hpc> that's how it works for Maybe
16:40:26 <deni> I'm not entirely sure how to fit that into my FromJSON and ToJSON instances especially since i'm using DeriveGeneric and DeriveAnyClass to make them :/
16:40:34 <Welkin> oh
16:40:35 <Welkin> haha
16:40:36 <deni> so you're saying I should make them by hand?
16:40:39 <Welkin> you need to write it yourself
16:40:42 <Welkin> yeah
16:40:43 <Welkin> it is easy
16:41:12 <Welkin> I usually write mine manually because I want to give each element a specific name different from the genericly derived one
16:41:21 <deni> Welkin: hpc can i get an example using <|> ?
16:42:17 <hpc> foo (Object v) = ok $ Just <$> (v .: "fieldA" <|> v .: "fieldB")
16:42:19 <deni> Welkin: I'm fine naming things like image_name rather than imageName if the thing in the json is with _
16:42:22 <hpc> foo _ = ok $ Nothing
16:42:58 <hpc> actually don't do that, it's riddled with errors
16:43:03 <hpc> but something like that
16:43:06 <Welkin> hm
16:43:32 <hpc> the important part is (v .: "fieldA" <|> v .: "fieldB") :: Parser whatever
16:43:33 <Welkin> if I understand correctly, you could place the <|> between two different smart constructors
16:43:40 <Welkin> so if the first version fails, it tries the second one
16:44:01 <hpc> :t (<|>)
16:44:02 <lambdabot> Alternative f => f a -> f a -> f a
16:44:45 <hpc> you'll have to play with it yourself to get familiar with it, there's only so much explaining can do
16:44:58 <Welkin> deni: https://hackage.haskell.org/package/aeson-0.10.0.0/docs/Data-Aeson.html
16:45:01 <Welkin> that page is helpful
16:45:43 <deni> Welkin: hpc it's confusing enough that I'm parsing yaml but the library is using aeson
16:46:03 <deni> I didn't think that json and yaml were the same thing
16:46:06 <deni> but there you go
16:46:10 <hpc> sounds like it's doing a trivial conversion from yaml to json and then parsing that?
16:46:18 <hpc> (would be my guess)
16:46:23 <deni> I assumed so
16:46:27 <deni> but still ... wow
16:46:29 <deni> :D
16:46:47 <deni> and when you say trivial.. :)
16:47:14 <hpc> i mean, it is a fairly simple conversion
16:47:18 <hpc> relative to parsing the whole format
16:47:38 <hpc> it even uses layout, which iirc there's libraries for already too
16:47:50 <lingxiao> hey all
16:47:50 <deni> hpc: I guess so...I would have never thought about it that way though
16:48:11 <lingxiao> this project proposal sounds interesting.. what are your thoughts?
16:48:11 <lingxiao> http://lpaste.net/144220
16:48:13 <deni> hpc: Welkin anyway thanks for your help.... I will see what I come up with
16:48:57 <lingxiao> in particular : "enfore the heap invariants with the use of GADTs"
16:49:09 <Welkin> deni: snoyman's yaml library?
16:49:15 <Welkin> that uses aeson underneath
16:49:27 <deni> Welkin: https://hackage.haskell.org/package/yaml-0.8.15.1/docs/Data-Yaml.html
16:49:29 <deni> that one
16:49:40 <Welkin> yeah
16:52:53 <sleblanc> in Foreign.Marshal.Alloc there's {alloca :: (Ptr a -> IO b) -> IO b} that allocates a pointer of type "a" and passes it to the function, freeing it after the function returns. Is there a concise way to allocate more than one pointer?
16:53:29 <Welkin> apply it multiple times
16:53:30 <sleblanc> So that this function "f" would take three Ptr a/b/c as parameters
16:53:57 <hpc> alloca $ \a -> alloca $ \b -> ...
16:54:01 <lingxiao> has anyone implemented a treap in haskell? using GADTs?
16:54:16 <arkeet> or if you want an array, you can use allocaArray
16:54:16 <Welkin> there is allocaArray too
16:54:30 <glguy> runContT (replicateM 10 (ContT alloca))  :: Storable a => ([GHC.Ptr.Ptr a] -> IO r) -> IO r
16:54:33 <Welkin> https://hackage.haskell.org/package/base-4.8.1.0/docs/Foreign-Marshal-Array.html#v:allocaArray
16:54:52 <sleblanc> allocaArray could do, but I only need three pointers, so it's kind of overkill
16:54:56 * glguy didn't check that that works out, but it feels right
16:55:13 <sleblanc> glguy, thanks for the insight
16:55:16 <twopoint718> Is there a channel to ask about Spock?
16:55:39 <monochrom> glguy: you did what I want to do :)
16:55:59 <arkeet> if it's just 3 (and particularly if they have distinct purposes) it makes perfect sense to just use alloca 3 times
16:56:08 <Welkin> twopoint718: #spock ?
16:56:20 <Welkin> twopoint718: you could aks in here
16:56:25 <Welkin> I'm sure someone has used spock
16:56:39 <Welkin> I have tried it once
16:56:45 <Welkin> but I didn't inhale!
16:57:02 <sleblanc> arkeet, when I look at Haskell code online, often I stumble onto cases that are very succinctly explained using Haskell syntax, I thought this could be one such example
16:57:31 <arkeet> there might be something clever 
16:57:37 <Welkin> clever is not good
16:57:46 <Welkin> easy to understand is
16:57:53 <monochrom> clever is subjective
16:58:01 <sleblanc> Welkin, agreed 100%, but repetitive is straining, too
16:58:07 <arkeet> okay, clever isn't the right word
16:58:25 <monochrom> easy-to-understand is fundamentally subjective
16:58:46 <eric_andrade> hi everyone, does anyone works with yesod. I've got a silly question about cassius/lucius
17:03:42 <mpickering> eric_andrade: Ask your question and someone will answer if they know!
17:03:55 <hpc> sleblanc: sometimes code just needs to look like what it does
17:03:57 <eric_andrade> ok, thanks :)
17:03:59 <eric_andrade> well ...
17:04:02 <hpc> (for very large values of "sometimes")
17:05:42 <eric_andrade> I can interpolate css (cassius/lucius) on hamlet that renders a full page ... but I want to make it different. I want it to interpolate all css into one single file and "append" it over link tag, so browser can cache it easily
17:06:04 <monochrom> for the rest of the time, use comments to explain your code
17:06:54 <hpc> comments are an admission of weakness! you're too busy innovating to waste time on the plebs!
17:07:19 <eric_andrade> I know that there's a function to call lucius/cassius file externally but it doesn't tell yesod to render it as an external file to optimize the caching on browser
17:07:43 <monochrom> I agree that comments are an admission of weakness.
17:07:56 <Welkin> eric_andrade: the browser can already easily cache it
17:08:10 <Welkin> it uses etags too
17:08:30 <c_wraith> monochrom: and type signatures are just machine-checked comments!
17:08:31 <monochrom> at some point, for some problem, the language will not permit, say, a solution both "readable" and efficient.
17:08:32 <Welkin> so it only changes the etag when the contents change, letting the browser know it needs to re-download it
17:08:35 <Welkin> otherwise it is cached
17:08:45 <twopoint718> Welkin: Thanks. I'll get a paste together.
17:08:51 <eric_andrade> Even when it renders on style tag? I mean, it's telling the browser to deal with whole not "slices"
17:09:13 <monochrom> so you have to choose the efficient but "unreadable" solution, and write comments to explain why it is efficient and correct.
17:09:13 <Welkin> eric_andrade: style tag?
17:09:30 <monochrom> it reflects a weakness in the language
17:10:06 <Welkin> eric_andrade: as long as you keep your css in a lucius/cassius file, it will work
17:10:08 <eric_andrade> yep, on my page it renders the css on the style tag
17:10:13 <Welkin> don't put css or js in your hamlet file
17:10:46 <eric_andrade> I see but an way it does render on head > style tag
17:11:18 <Welkin> I haven't had that happen
17:11:26 <Welkin> mine renders to a file like this: static/tmp/autogen-Ay6iKXNe.css
17:11:27 <eric_andrade> instead, I want it to render on head > link src ... cassius/lucius
17:11:47 <Welkin> yes, that is the default behavior
17:11:55 <Welkin> I don't know why it would render inside of a style tag
17:12:04 <eric_andrade> how to you call it ? so it does render on static/tmp/gen..css?
17:12:36 <Welkin> when you use $(widgetFile "filename") it collects all of the files (hamlet, lucius/cassius, julius) with that name and renders them
17:13:11 <Welkin> it places the css and js in static/tmp/autogen-[hash] files
17:13:37 <eric_andrade> ohh I'm going to try it. I didn't realise it. I use toWidget $(luciusFile "templates/file.lucius")
17:14:38 <tommd> edwardk: I have a need for a (possibly naive) unconstrained minimizer
17:14:48 <tommd> edwardk: I figured I could add a simple log barrier to your ad package.
17:15:23 <tommd> edwardk: The trick here is that I want to specialize it to Double and handle NaN as a special case. So this doesn't all jive with your current AD structure.
17:15:27 <tommd> edwardk: Thoughts?
17:15:45 <eric_andrade> thank you @welkin
17:15:53 <Fylwind> do Prisms capture the idea of serialization and deserialization? :o
17:15:54 <eric_andrade> thank you #welkin
17:16:16 <c_wraith> Fylwind: they can.  They're broader.
17:16:46 <c_wraith> Fylwind: one view of Prisms is "partial isomorphisms", where one direction always succeeds, and the other direction might succeed.
17:17:06 <c_wraith> Fylwind: and serialization/deserialization fit that description
17:17:31 <Fylwind> c_wraith: that's what I thought too :)
17:18:37 <Fylwind> c_wraith: thanks
17:19:14 <c_wraith> Fylwind: you're welcome
17:21:20 <gfixler> learning more about the Expression Problem
17:21:29 <gfixler> in OOP, the methods are fixed
17:21:39 <gfixler> but isn't it possible to shove new methods into a class?
17:21:50 <gfixler> not in every language, but in some, at least
17:24:14 <monochrom> if your class hierachy has 100 subclasess, then the worst case of writing 100 versions of the new method can happen
17:31:41 <Lokathor> hmm
17:31:50 <Lokathor> is there a generic indexing operation on foldable?
17:32:19 <Lokathor> or must you convert it to a list first?
17:34:33 <ReinH> Lokathor: no, indexing list-like things is generally a bad idea
17:34:42 <ReinH> what are you trying to do?
17:35:29 <Lokathor> I'd like a RNG that, given a list, picks a random element out of it. then i immediately thought, "well what if i want it for sets, i can probably do it for foldable or something"
17:35:44 <ReinH> And for foldable things, there's no particular reason to expect an index to be meaningful
17:35:59 <Lokathor> so the RNG part i've got, and i need something like.. getElem :: Foldable t => t a -> Int -> a
17:36:07 <ReinH> what is the 5th element of a tree? Sure, it's the fifth element you get when you count in whatever way it is traversed
17:36:21 <ReinH> but that doesn't tell you much about where it is in the tree
17:36:50 <Lokathor> well the element is actually unimportant in this case, it just needs to be anywhere in the foldable and have had an equal chance of being selected
17:36:53 <ReinH> why not just toList, shuffle, and take the head
17:37:32 <Lokathor> well that is also possible, yes
17:38:00 <Lokathor> it felt like it could be done with less overhead
17:38:21 <ReinH> what overhead
17:38:49 <Lokathor> having to use toList and all
17:39:04 <ReinH> There may be no overhead at all
17:39:17 <ReinH> remember it's lazy
17:40:12 <tnks> I'm not sure I like the idea of picking random elements out of arbitrary things.
17:40:21 <Lokathor> plus i need to write the shuffle :P
17:40:27 <Lokathor> tnks, why not?
17:40:33 <latro`a_> if it's a finite structure...
17:40:50 <MarcelineVQ> `import Data.Random` `randomItem = liftIO . sample . randomElement`
17:41:01 <tnks> not from the idea that it can't be encoded, but why support data types that can not give you good asymptotics?
17:41:55 <Lokathor> tnks, i think i don't understand your question
17:42:24 <Lokathor> MarcelineVQ, now you've got me relying on a new package! drat! I may have to do it myself anyway then
17:42:43 <MarcelineVQ> You should explore Data.Random anyway, just to see it :>
17:43:11 <MarcelineVQ> http://hackage.haskell.org/package/random-fu I think
17:43:55 <Lokathor> Yikes, i know so few things about randomization statistics
17:48:27 <ReinH> the best you can do with an arbitrary foldable is convert it to a list and select a random element of the list
17:49:05 <monochrom> if you want to be so general as Foldable, you can't avoid toList for this
17:49:19 <Lokathor> that's about what i figured in the end
17:49:42 <monochrom> yes it's Theta(n). but that's the price for being general.
17:50:30 <Lokathor> i expect that i'll generally end up using it on lists
17:50:37 <Lokathor> so toList will just be a noop anyway
17:51:05 <monochrom> you want to hear something even worse than Theta(n) because it is general? try "remove duplicate elements in a list, but use Eq only"
17:51:26 <Lokathor> sounds like.. hmm
17:51:41 <Lokathor> n * log n * n
17:51:45 <monochrom> that function is in Data.List or Prelude. it's name is nub.
17:52:19 <monochrom> it is quadratic because it is so general it assumes only Eq
17:52:36 <Lokathor> i put an extra log n on
17:52:36 <Lokathor> yes
17:52:47 <monochrom> you know tons of algorithms and data structures that can do the same in n log n, but they all need Ord.
17:53:01 <monochrom> and Ord is not as general as E
17:53:06 <monochrom> Eq
17:54:00 <Lokathor> in my case
17:54:05 <Lokathor> it's more like 2n
17:54:09 <Lokathor> not that the constants matter
17:54:23 <Lokathor> except, well, when they do of course
17:54:45 <monochrom> if you started out with random-access array, things would be faster, even faster than list.
17:55:23 <Sonolin> thanks for random-fu
17:55:41 <Sonolin> but can someone explain why liftIO . sample works?
17:56:13 <Sonolin> ah nm
17:56:21 <Sonolin> I was confused thought samples type was flipped 
17:56:39 <Sonolin> returns MonadRandom which has IO instance
17:56:40 <Sonolin> :D
18:01:42 * hackagebot Michelangelo 0.1.0.2 - OpenGL for dummies  https://hackage.haskell.org/package/Michelangelo-0.1.0.2 (SwiftsNamesake)
18:03:54 <jre2> is there a library for pretty printing a table?
18:04:27 <davidthomas> jre2: like column, but in haskell?
18:05:31 <dmj> @package boxes
18:05:32 <lambdabot> http://hackage.haskell.org/package/boxes
18:06:01 <lpaste> Lokathor pasted “pickRandom” at http://lpaste.net/144224
18:06:05 <jre2> I guess. I have some data that can be made into a 2d array, but I'd like the values to line up with the column headers etc
18:08:49 <jre2> dmj: unless I'm misunderstanding, boxes is meant for low level building of some sort of layout system
18:09:07 <eugenn> @lambdabot > take 3 [1..]
18:09:08 <lambdabot> Unknown command, try @list
18:09:44 <monochrom> it has to be like this:
18:09:48 <monochrom> > take 3 [1..]
18:09:50 <lambdabot>  [1,2,3]
18:10:35 <Lokathor> eugenn, you can also send lambdabot a PM and it will respond via PM
18:11:04 <eugenn> thanks, that was what I was trying to do
18:11:17 <pyon> What exactly are type roles?
18:13:48 <ReinH> jre2: I think you misunderstand. boxes is meant for two dimensional pretty printing.
18:18:17 <Fylwind> c_wraith: actually I just realised that not all serializations can be described by a Prism: consider the case of a very forgiving deserializer that tolerates small errors in the input, in which case it is no longer a partial isomorphism
18:21:19 <oregoner> anyone have an example of a production haskell application? (that I could look at)?
18:26:43 * hackagebot Michelangelo 0.1.0.3 - OpenGL for dummies  https://hackage.haskell.org/package/Michelangelo-0.1.0.3 (SwiftsNamesake)
18:27:34 <synergistics> Can you have generators fit into functional programming without state monads?
18:28:49 <Fylwind> what kind of 'generators'?  pure generators are usually done via lists in Haskell
18:30:12 <synergistics> I'm not sure what the equivalent would be in haskell, but I'm thinking ones in Python that yield a value every time the function is called depending on the state resulting from previous calls.
18:30:51 <Lokathor> synergistics, yeah, that sort of thing in haskell would probably be best reprisented as a funciton that outputs a list lazily
18:30:52 <pyon> Perhaps something like the `pipes` library? :-O
18:31:20 <Lokathor> then you can evaluate the first element of the list, and if you care you could evaluate later elements later on too
18:31:41 <synergistics> Lokathor: But doesn't that not return the same result every time?
18:32:01 <Lokathor> synergistics, if the inputs are the same, the result list will be the same, but each element of the list can be different
18:32:14 <jre2> synergistics: sounds exactly like an Auto
18:32:33 <Lokathor> basic example
18:32:34 <Lokathor> > take 5 $ iterate (+1) 2
18:32:36 <lambdabot>  [2,3,4,5,6]
18:32:40 <Lokathor> > take 5 $ iterate (+1) 20
18:32:42 <lambdabot>  [20,21,22,23,24]
18:33:13 <pyon> Lokathor: Well, getting the next element from a Python generator can have side effects.
18:33:34 <Lokathor> well
18:33:50 <synergistics> So then you keep the state in your arguments?
18:33:50 <Lokathor> you could do that
18:34:21 <pyon> synergistics: If you use a lazy list as a generator, the computation that produces the list can have internal state.
18:34:32 <Lokathor> well, not exactly, what you'd do is that the state changes from call to call as you make recursive calls
18:34:37 <Lokathor> yes what pyon said :3
18:34:54 <synergistics> pyon: So internal state is ok in FP?
18:35:39 <synergistics> pyon: Inside a function I mean
18:35:40 <Lokathor> ah, well, "yes but there are extra details" is the best answer there I think
18:35:53 <jre2> synergistics: nothing wrong with state. you just need to be able to control and understand it
18:36:04 <synergistics> cool
18:36:05 <synergistics> weird
18:36:25 <synergistics> I'll play around with this. Thanks for the help!
18:36:44 <pyon> synergistics: Well, all computation is stateful. All computation is making a some machine undergo a series of state changes. For instance, in the lambda calculus, every time you perform a reduction, the expression you have at hand changes - that's a state change. :-p
18:36:49 <Lokathor> synergistics, for example, if you have a list you make within a function and then recursively pass down the list, and the recursive call adds an element to the list, the parent call doesn't see that new element
18:37:14 <Lokathor> so you write code a little differently
18:37:45 <synergistics> Oh I see
18:38:53 <synergistics> "the parent call doesn't see that new element" ?
18:39:12 <Lokathor> ah, hard to explain in single lines at a time, on IRC
18:39:30 <synergistics> Well I'll be back soon
18:40:10 <pyon> synergistics: Functional programming has lots of state. What it doesn't have, or at least discourage using, is imperative assignment - but state can be modeled in lots of ways. :-)
18:40:41 <lpaste> Lokathor pasted “No title” at http://lpaste.net/144227
18:41:27 <Lokathor> synergistics, if you look at my python example there, that's what i mean. y was modified, but x also got the change. that kind of "action at a distance" doesn't really happen in haskell
18:46:11 <Welkin> Lokathor: "doesn't really"? You mean never
18:49:37 <Lokathor> I'd say that concurrency and FFI have to still carry the normal "open your eyes and pay attention" warnings
18:55:13 <quuxman> hi, I'm trying to run an OpenGL program on MacOS and I'm getting a segfault in "libGL.dylib`glGenTextures". It worked before with ghci, but my current version segfaults there too
19:00:43 <quuxman> ok nevermind, the old segfault was from .o or .hi files compiled on another platform, new segfault must be incorrect arguments somewhere
19:02:32 <quuxman> oh, it was from moving the glInit command after another library call
19:03:05 <quuxman> if only there was someway to enforce order of monadic operations :-P
19:09:01 <quuxman> OK, I have a question about dealing with Maybe types smoothly. Is there a better way to write the first few lines of argument parsing in main from http://lpaste.net/144228 ?
19:10:17 <quuxman> I want to parse strings into Integers and if either parsing fails, or a value is out of range, run exit function
19:10:22 <glguy> quuxman: Use pattern matching
19:10:30 <glguy> rather than == Nothing and fromJust
19:10:52 <quuxman> I was thinking about pattern matching, but couldn't figure out how to combine both those steps
19:11:43 <quuxman> and what does lpaste have against redundant brackets? They improve clarity IMO
19:12:22 <jasonkuhrt> Hi in ghci why does :sprint not show evaluated spine of let x = [1..4] but it does for let x :: [Integer]; x = [1..4]
19:12:23 <jasonkuhrt> ?
19:12:40 <jasonkuhrt> It seems that without a concrete type sprint behaves differently?
19:13:04 <jasonkuhrt> But I don't really know
19:13:25 <glguy> quuxman: The redundant brackets become confusing once you're comfortable visually parsing Haskell, they give the impression that something extra is going on that might merit having them
19:15:11 <jasonkuhrt> Related: https://www.reddit.com/r/haskell/comments/3dznm2/question_about_the_behavoir_of_sprint_in_ghci/
19:15:23 <KemyLand> glguy: Using them with appropiate whitespacing ( and taking in account the existence of the $ function ) can sometimes avoid some... ahem... issues with the visual parsing you mention.
19:16:13 <jasonkuhrt> I agree with the first point here http://www.haskellforall.com/2015/09/how-to-make-your-haskell-code-more.html
19:16:16 <jasonkuhrt> don't use $
19:17:00 <quuxman> these are some pretting interesting / useful lint errors / warnings. Will n+1 my Haskell style 
19:17:08 <lpaste> glguy annotated “Renders smooth 1d cellular automata in realtime using OpenGL for display, pretty rough” with “Renders smooth 1d cellular automata in realtime using OpenGL for display, pretty rough (annotation)” at http://lpaste.net/144228#a144229
19:17:13 * hackagebot http2 1.2.0 - HTTP/2.0 library including frames and HPACK  https://hackage.haskell.org/package/http2-1.2.0 (KazuYamamoto)
19:17:20 <glguy> quuxman: Maybe something like that ^
19:18:28 <quuxman> glguy: ah thanks! That looks better. My Haskell is rusty. I'm working on all the warnings / errors too.
19:18:49 <quuxman> from the lpaste linter. How do I get that on command line?
19:20:11 <glguy> The tools is "hlint" and it's on hackage
19:20:50 <quuxman> glguy: ok that should've been obvious. Since you're glguy, is this a reasonable use of OpenGL? Is there a better library for scrolling arbitrary pixels?
19:21:15 <quuxman> glguy: the worst thing about my current implementation is the window width has to be a power of 2 :-P
19:24:17 <glguy> I know very little OpenGL
19:25:10 <quuxman> heh. seemed like a reasonable assumption. I bet there are a lot more graphics libs now than when I wrote this ~8 years ago
19:27:14 * hackagebot warp 3.1.8 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.1.8 (KazuYamamoto)
19:28:14 <quuxman> so in a pattern match, comma is equivalent to &&?
19:29:56 <oregoner> so no production examples of haskell in action?
19:30:07 <oregoner> code or otherwise?
19:31:17 <glguy> quuxman: Yeah. You can just use a && if you want, but that's what it means
19:33:02 <MarcelineVQ> glguy: Doesn't that use the pattern guards extension?
19:33:26 <glguy> It's just part of the language now, actually
19:33:29 <MarcelineVQ> oh cool
19:33:31 <angelorecaman> hello
19:33:47 <synergistics> Hi
19:34:31 <angelorecaman> j freelancer
19:36:30 <quuxman> wow, hlint is pretty sophisticated; suggesting expr transformations to increase laziness, which also increase readability / succinctness
19:38:39 <pyon> If `guard` is an Alternative combinator, why is it in `Control.Monad`?
19:39:00 <glguy> Because it predates applicative
19:39:59 <glguy> quuxman: It does OK, lots of times the suggestions improve readability, sometimes the effect on performance is positive
19:40:32 <glguy> sometimes negative, you just have ot know what you're looking at when it offers a suggestion
19:42:14 * hackagebot subleq-toolchain 0.1.8.4 - Toolchain of subleq computer.  https://hackage.haskell.org/package/subleq-toolchain-0.1.8.4 (na4zagin3)
19:44:19 <pyon> It's not possible to use `[]`'s Applicative and Monad instances to zip lists, right?
19:44:30 <pyon> I need to zip-then-filter.
19:44:50 <pyon> Alas, `[]` doesn't seem to support zipping, and `ZipList` doesn't support filtering. :-|
19:45:35 <mniip> I've seen 2 zippy listy monads and they're both unlawful
19:45:42 <pyon> Oh.
19:47:27 <mniip> pyon, for one, consider
19:48:02 <mniip> x <- [1, 0, 2]; y <- replicate x x; return y
19:48:19 <mniip> equivalent to
19:48:25 <mniip> join [[1], [], [2, 2]]
19:48:27 <pyon> Yeah, I have no use for things that break class laws.
19:48:38 <mniip> er, hm, make that [1,0,3]
19:48:43 <mniip> join [[1], [], [3, 3, 3]]
19:49:37 <mniip> in a zippy context, join would be diagonalization, right
19:49:48 <mniip> if you return [1], you're unlawful
19:49:54 <mniip> [1,3] is just as unlawful
19:50:12 <mniip> you could do [1, undefined, 3], but then everything else starts to fall apart
19:50:24 <Cale> mniip: You need infinite streams for that
19:50:32 <pyon> Yeah, I'm aware that, in a zippy context, `pure` should be `repeat`.
19:50:45 <chromatome> Anyone know why/how ghc-mod still won't install with stack? I see that it *should* Just-Work(tm) after the 5.4 release but I'm still having issues.
19:50:50 <pyon> And `ZipList` doesn't have a `Monad` instance for a reason. I'm aware.
19:50:55 <mniip> right, but
19:51:05 <mniip> monadic values aren't only produced by 'pure'
19:51:30 <mniip> if you only use 'pure' values, you're not monadic at all
19:52:15 <mniip> the problem does go away if it's impossible to make a finite list, like Cale said
19:52:56 <Cale> mniip: Of course, there's another name for that Monad, it's just  (->) Nat
19:53:28 <pyon> Mmm...
19:53:55 <mgsloan> chromatome: I'm not seeing ghc-mod present in lts-3, so you either need to use lts-2.22 for GHC-7.8.4 and an older ghc-mod, or use a more recent nightly snapshot
19:54:28 <mgsloan> (I noticed this due to this page http://www.stackage.org/package/ghc-mod , which lists which snapshots it's present in, at what versions)
19:54:29 <chromatome> Hmm. How can I use a nightly? I is n00b
19:54:51 <mgsloan> Set your resolver to "nightly-2015-10-27"
19:55:52 <pyon> Does this look like the right way to compute derivatives of monomials and polynomials? http://lpaste.net/144231
19:55:58 <pyon> Free variables are represented by a single character.
19:56:28 <chromatome> Ahhhh perfect! Thanks mgsloan
19:56:38 <mgsloan> chromatome: Welcome!
19:56:55 <chromatome> Man oh man, this community is so much friendlier than most.
19:56:59 <chromatome> A++
19:57:02 <mgsloan> :D
20:06:27 <MarcelineVQ> muhaha
20:10:02 <mniip> Cale, (Nat ->) might be isomorphic but it's structurally different
20:23:40 <wdoo01> @hoogle concatMap
20:23:42 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
20:23:43 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
20:23:43 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
20:24:35 <wdoo01> @hoogle+ concarMap
20:24:35 <lambdabot> Data.ByteString.Char8 concatMap :: (Char -> ByteString) -> ByteString -> ByteString
20:24:35 <lambdabot> Data.ByteString.Lazy.Char8 concatMap :: (Char -> ByteString) -> ByteString -> ByteString
20:24:35 <lambdabot> Data.Text.Internal.Fusion.Common concatMap :: (Char -> Stream Char) -> Stream Char -> Stream Char
20:26:34 <quuxman> anybody know of a library for plotting pixels to a window that's a bit higher level than SDL?
20:34:44 <glguy> quuxman: 'gloss' might be worth looking at
20:36:22 <quuxman> glguy: I was just looking at the API. Like so many graphics libraries, there's no easy pixel access. You have to create a ForeignPtr and write stuff into the appropriate format manually
20:36:40 <quuxman> Diagrams looks promising though
20:38:46 <quuxman> Chalkboard too
20:38:58 <glguy> is your goal to write out a whole bitmap of pixels packed in densely? or to play some sparse pixels?
20:40:03 <quuxman> glguy: Dumping a row of pixels at a time and scrolling the entire window up. (I wanted to remove all the low level OpenGL code from that hpaste)
20:42:18 <eacameron> What is the tool of choice for extensible records?
20:43:49 <eacameron> It upsets me that Python's SQLAlchemy squarely defeats any Haskell lib I've seen for modeling tables, and using subtype polymorphism allows one to "extend" tables (at least in Python's perspective)
20:44:39 <lispy> eacameron: I guess this is why ermine has row types?
20:45:20 <lispy> I suppose you could look at vinyl http://hackage.haskell.org/package/vinyl
20:45:53 <eacameron> lispy: I don't know much about ermine; even Elm has extensible records built-in.
20:46:08 <lispy> Well, hugs had trex
20:46:21 <lispy> https://github.com/VinylRecords/Vinyl/blob/master/tests/Intro.lhs
20:53:05 <eacameron> Seems like HList is another potential? The hackage docs are impenetrable.
20:53:17 <lispy> I wouldn't use hlist
20:53:46 <lispy> It's powerful, but I don't think it's been updated to use more recent ghc features
20:54:01 <lispy> So the API ends up a bit clunky
20:55:17 <eacameron> Good to know. Wow hugs even had it....
20:55:19 <lispy> eacameron: FWIW, people have been trying to build a proposal to put them into ghc: https://ghc.haskell.org/trac/ghc/wiki/ExtensibleRecords
20:55:21 <eacameron> As you said.
20:55:38 <lispy> eacameron: and this is a good summary of your options: https://wiki.haskell.org/Extensible_record
20:56:41 <lispy> While I haven't used vinyl, I do think it's you're best bet
20:57:02 <lispy> I used HaskellDB once, many years ago, and it seemed to cover the database case well
20:58:31 <eacameron> CTRex?
20:59:08 <lispy> I'm not familiar with CTRex, the feature I was thinking of is here: https://www.haskell.org/hugs/pages/hugsman/exts.html#sect7.2
21:08:12 <eacameron> lispy: Have more recent GHC features allowed Vinyl to shave off runtime performance costs?
21:09:40 <shanemikel> hmm.. I'm getting type errors from `floor (sqrt n)`
21:10:07 <lispy> eacameron: no idea
21:10:46 <pavonia> shanemikel: What's the type of n?
21:10:49 <eacameron> lispy: That tutorial for Vinyl makes me sad. I glad it's possible to do it, but man, the syntactic overhead is monstrous!
21:11:37 <shanemikel> nit
21:11:39 <shanemikel> int
21:12:34 <mmachenry> Does anyone have a recommendation on which web framework I should use to provide a standalone web server with a JSON API.
21:12:57 <pavonia> shanemikel: You can't use sqrt with Int, convert it to a floating point number first with fromIntegral
21:14:04 <pavonia> shanemikel: You also might be interested in reading https://wiki.haskell.org/Converting_numbers
21:15:16 <shanemikel> pavonia: thanks
21:16:26 <eacameron> mmachenry: servant
21:17:12 <mmachenry> eacameron: Cool. Why servant? 
21:19:18 <eacameron> mmachenry: It's un-oppinionated about everything except routing and type-safe HTTP interactions...which it is supremely good at. The rest is up to you, but there are lots of libraries to choose from. JSON responses are supported out of the box.
21:20:49 <eacameron> mmachenry: in other words, it gives you just what you need to build an API but not much more (no opinion about templating engine, or DB, etc.)
21:21:41 <eacameron> mmachenry: And for what it does, it is second to none.
21:30:06 <mmachenry> eacameron: Awesome, thanks for the tip. I'll start my reading and testing there.
21:30:26 <eacameron> mmachenry: np
21:37:31 <shanemikel> so, I have a question about point-free style.. I find myself doing `f = g . h` where `g :: b -> c`, `h :: a -> a -> b`, and `f :: a -> a -> c`.. obviously this doesn't work with the (.) signature, so I go back and do `f a = g . h a`, but I'm wondering if there is some point-free trick I'm missing?
21:39:45 <lispy> :t (.).(.)
21:39:46 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
22:02:38 <Profpatsch> @pl \x -> (head x, length x)
22:02:38 <lambdabot> liftM2 (,) head length
22:09:23 <shanemikel> thanks lispy , but now I have to figure out why that works
22:49:03 <duwang> hey guys, how do you check if two values are of the same type in haskell?
22:51:17 <mgsloan> > let x = ""; y = "" in typeOf x == typeOf y
22:51:19 <lambdabot>  True
22:51:38 <duwang> alright thanks
22:54:00 <Guest47232> can you even compare them if they are of different types?
22:54:44 <gfixler> :t typeOf
22:54:45 <lambdabot> Typeable a => a -> TypeRep
22:54:54 <gfixler> typeOf True
22:54:59 <gfixler> > typeOf True
22:55:00 <lambdabot>  Bool
22:55:33 <gfixler> how does this work around type erasure?
22:55:55 <mgsloan> gfixler: It demands a Typeable instance
22:55:57 <mgsloan> :t typeOf
22:55:58 <lambdabot> Typeable a => a -> TypeRep
22:56:07 <gfixler> mgsloan: ah, so I'd define that for my types?
22:56:42 <mgsloan> You can no longer define it manually, you put "Typeable" in the deriving clause of your types
22:56:53 <gfixler> interesting
22:57:14 <gfixler> are there good reasons for wanting to identify types like this?
23:01:13 <mgsloan> Yes!  It lets you do dynamic types, for one.  Sometimes it's quite handy to be able to store any kind of value, and later try to cast it to a particular type
23:01:16 <ReinH> shanemikel: I wouldn't recommend actually using it
23:01:49 <mgsloan> Yeah, generally Dynamic is frowned upon, for good reasons, but it has its uses here and there
23:01:59 <gfixler> mgsloan: I should have guessed (reading the Idris MEAP)
23:02:29 <gfixler> oh wait, I read "Dependent" types there :(
23:02:48 <gfixler> not as excited about dynamic types
23:06:46 <mgsloan> Also, the AutoDeriveTypeable language pragma will cause all datatypes to have Typeable instances
23:13:06 <monkeychode69> hey guys
23:13:09 <monkeychode69> did you know
23:13:13 <monkeychode69> that haskell sucks fat monkey cock
23:13:16 <monkeychode69> fuck haskell!
23:13:31 <monkeychode69> Rodya sucks fat haskell dick
23:13:43 <mgsloan> hah
23:13:44 <mgsloan> !ops
23:13:54 <monkeychode69> !ops
23:13:56 <peddie> @where ops
23:13:57 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
23:13:57 <monkeychode69> !ops sucks fat monkey dick
23:14:04 <monkeychode69> also
23:14:05 --- mode: ChanServ set +o Cale
23:14:08 <monkeychode69> can someone help me on homework
23:14:10 --- mode: Cale set +b *!*@gateway/web/freenode/ip.108.179.151.120
23:14:10 --- kick: monkeychode69 was kicked by Cale (monkeychode69)
23:14:13 <ent> :D
23:14:17 --- mode: Cale set -o Cale
23:17:32 <Profpatsch> I’ve got a list of lists and want to get the list with the longest length.
23:18:00 <Profpatsch> maximum is somehow defined recursively for the list with the largest elements.
23:18:16 <Profpatsch> ,maximum [[],[2]]
23:18:28 <Profpatsch> > maximum [[],[2]]
23:18:30 <lambdabot>  [2]
23:18:43 <Profpatsch> > maximum [[],[2,4],[3]]
23:18:45 <lambdabot>  [3]
23:18:54 <Profpatsch> > maximum [[],[5,2,4],[3]]
23:18:55 <lambdabot>  [5,2,4]
23:18:59 <Profpatsch> I don’t even.
23:19:14 <Profpatsch> For the list with the largest element at the beginning.
23:19:36 <KaneTW> maximum on lists is defined using lexicographical order
23:20:21 <Profpatsch> KaneTW: Ah, that makes sense indeed.
23:21:09 <KaneTW> if you want the longest length you need maximumBy
23:21:21 <Profpatsch> KaneTW: compare `on` length?
23:21:26 <KaneTW> yes
23:21:27 <dibblego> @type maximumBy (comparing length)
23:21:29 <lambdabot> (Foldable t, Foldable t1) => t (t1 a) -> t1 a
23:22:13 <KaneTW> :t maximumBy (compare `on` length)
23:22:14 <lambdabot> (Foldable t, Foldable t1) => t (t1 a) -> t1 a
23:22:58 <KaneTW> > maximumBy (compare `on` length) ["hello", "world", "a"]
23:22:59 <lambdabot>  "world"
23:23:03 <KaneTW> > maximumBy (compare `on` length) ["hello", "world", "a", "haskell"]
23:23:05 <lambdabot>  "haskell"
23:23:14 <Profpatsch> Nice, yes.
23:27:26 * hackagebot template-yj 0.0.0.1 - Process template file  https://hackage.haskell.org/package/template-yj-0.0.0.1 (YoshikuniJujo)
