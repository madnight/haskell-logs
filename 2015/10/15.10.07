00:03:20 <Mayzie> Um, how do I run a package that I install with cabal?
00:07:40 * hackagebot streaming-utils 0.1.1.1 - http, attoparsec and pipes utilities for streaming and streaming-bytestring  https://hackage.haskell.org/package/streaming-utils-0.1.1.1 (MichaelThompson)
00:07:40 * hackagebot persistent-template 2.1.3.7 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.1.3.7 (GregWeber)
00:15:53 <EvanR> does anyone know what a DCTP system is
00:21:51 <Mayzie> Is: `func :: Int Int Int` the same as `func :: Int -> Int -> Int`?
00:22:27 <EvanR> no, Int Int Int doesn't make sense because Int isn't a type constructor
00:22:46 <EvanR> compare and contrast Maybe, you can say Maybe Int
00:22:58 <EvanR> :k Int
00:22:59 <lambdabot> *
00:23:02 <EvanR> :k Maybe
00:23:03 <lambdabot> * -> *
00:23:07 <shachaf> What happened when you tried it?
00:23:36 <Mayzie> I haven't. It's just a function in this source code that I don't understand.
00:23:47 <mniip> shachaf, they probably redefined Int to a kind-polymorphic type family!
00:23:57 * EvanR facepalm
00:24:03 <Mayzie> (it's not Int Int Int, but something else)
00:25:16 <mniip> Mayzie, what is it then
00:29:47 <Mayzie> It's something like this: https://bpaste.net/show/89caf2ed137d
00:31:55 <haskell157> Hello
00:32:20 <haskell157> some program is failing *only* on my machine with resource exhasted exception
00:32:52 <haskell157> it is working in our CI and my collegues machines
00:34:50 <haskell157> my machine has more memory than ci and could support upto 12288 open files
00:37:00 <haskell157> I know it's too abstract description of the situation but it started failing suddenly today. It used to work until today morning - no changes as such
00:37:35 <selckin> maybe files handles are closed on gc ?
00:39:14 <haskell157> actually situation is there are many tests. every test spawns a app instance and app used a test file for persistence purpose
00:39:23 <haskell157> if I run all the tests at once it fails
00:39:37 <haskell157> one test at a time works 
00:40:15 <haskell157> exception is more of - uncaught exception: IOException of type ResourceExhausted (test.store: openFile: resource exhausted (Too many open files))
00:40:43 <haskell157> I tried to close the file explicitly after each test
00:40:52 <haskell157> but doesn't help either
00:41:04 <selckin> use lsof to check what files are open?
00:42:54 <Mayzie> mniip: Not sure if you saw it: <Mayzie> It's something like this: https://bpaste.net/show/89caf2ed137d
00:44:19 <haskell157> selckin: looks like there are many files opened by chrome
00:44:42 <haskell157> but shouldn't reach to 12XXX 
00:44:54 <selckin> you wanna check your app only
00:46:36 <haskell157> oh okay.. thanks anywasy
00:47:00 <mniip> Mayzie, that's nothing like Int Int Int
00:47:30 <mniip> Mayzie, B is a type constructor
00:47:40 <mniip> it takes 2 types as arguments, and yields a type
01:07:49 * hackagebot speedy-slice 0.1.0.0 - Speedy slice sampling.  https://hackage.haskell.org/package/speedy-slice-0.1.0.0 (JaredTobin)
01:19:17 <Mayzie> mniip: Oh okay.
01:19:22 * Mayzie looks up type constructors.
01:19:56 <mniip> Mayzie, just like '4(3)' doesn't make sense, 'Int Int' is meaningless
01:20:08 <quicksilver> smoe common examples of type constructors which take two arguments are "Either" and "(,)"
01:20:11 <mniip> sin(0), and, correspondingly, Maybe Int, on the other hand
01:20:21 <quicksilver> if you've seen either of those...
01:20:36 <quicksilver> although we normally write "(,) Int Char" as (Int,Char) e.g.
01:20:57 <Mayzie> So in my example: https://bpaste.net/show/89caf2ed137d , function would be something like this? `function :: (B (A)) C`?
01:21:08 <Mayzie> Sorry, I mean `function :: (B (A)) -> C`
01:21:18 <mniip> more like B(A)(C)
01:21:24 <mniip> but that's just the same
01:21:34 <mniip> Mayzie, wait what no
01:21:36 <mniip> there are no -> arrows
01:21:53 <Mayzie> Sorry, trying to wrap my head around this
01:21:59 <quicksilver> your expression 'function' is not a function.
01:22:01 <Mayzie> So it returns a B type, constructed with A and C?
01:22:07 <quicksilver> so the name of that variable is confusing.
01:22:10 <Mayzie> quicksilver: It's an example prototype.
01:22:13 <quicksilver> I understand
01:22:17 <mniip> quicksilver, depends on your definition of function
01:22:21 <quicksilver> I'm just clarifying for you that it isn't a function.
01:22:33 <Mayzie> It's not a function? :S
01:22:34 <quicksilver> mniip: indeed. My definition of function is something of the form (a -> b)
01:22:49 <mniip> okay then yes, a->b does not unify with B A C
01:22:56 <mniip> Mayzie, look at a simpler type constructor
01:23:05 <mniip> :k Maybe
01:23:07 <lambdabot> * -> *
01:23:16 <mniip> it takes a type as argument, and returns a type
01:23:31 <mniip> so 'Maybe' itself is not a type, but 'Maybe Int' is
01:23:34 <mniip> :k Maybe Int
01:23:36 <lambdabot> *
01:23:48 <mniip> Just 3
01:23:53 <mniip> has the type Maybe Int
01:23:53 <Mayzie> Right
01:24:13 <mniip> and 'Just "moo"' has the type Maybe String
01:24:57 <mniip> if you have 'Maybe Int', would you think it really stands for Maybe -> Int
01:25:08 <shanemikel> okay you geeks.. I've been growing fond of a particular currying behavior of the Ramda functional library for JS.  In particular, there is a way to curry a func f :: a -> b -> c -> d, by wrapping it up like so: (R.curry f) R.__, R.__, val, where R.__ is a placeholder that allows you to easily curry while skipping args (that would return func g :: a -> b -> d)
01:25:16 <shanemikel> is there a way to do this elegantly in haskell?
01:25:24 <shanemikel> i.e. other than using flip, or writing functions like curry1 curry2 curry3, etc
01:26:01 <quicksilver> shanemikel: we use lambda notation for that
01:26:07 <mniip> shanemikel, you could construct an enormous typeclass monstrosity
01:26:17 <quicksilver> (\x y -> f x y val)
01:26:24 <quicksilver> is equivalent to
01:26:31 <quicksilver> (R.curry f) R.__, R.__, val
01:26:39 <quicksilver> if I understood you correctly.
01:26:56 <quicksilver> lamba notation forces us to 'name' the place holders rather than using a generic __
01:27:07 <quicksilver> but on the plus side it's easier to switch them around in different orders
01:27:40 <shanemikel> quicksilver: oh, guess that works. i'm a newbie
01:28:00 <quicksilver> :)
01:35:57 <shanemikel> btw, ever somebody coerces you at gunpoint to program JS (and if you can't, or don't want to, use Elm), Ramda + Coffescript actually can be really pretty 
01:38:00 <lamefun> is there a class "class Enumerable a where every :: [a]"?
01:38:21 <quicksilver> lamefun: not really, but
01:38:22 <shachaf> There is https://hackage.haskell.org/package/universe-1.0/docs/Data-Universe.html
01:38:31 <quicksilver> > [minBound..maxBound] :: [Bool]
01:38:33 <lambdabot>  [False,True]
01:38:46 <shachaf> i,i [minBound..maxBound] :: [Double]
01:38:49 <quicksilver> lamefun: ^^ that trick works for all finite enumerated types that define Bounded
01:38:59 <quicksilver> lamefun: and is not good for other types :)
01:39:25 <quicksilver> by 'not really', I meant in base. Check out shachaf's answer for a library.
01:39:44 <quicksilver> shanemikel: purescript is where its at :)
01:40:48 <shanemikel> quicksilver: wtf, is this haskell?
01:41:12 <shanemikel> quicksilver: syntax looks like Haskell crossed with Go
01:42:00 <quicksilver> shanemikel: yeah it's like haskell but not quite.
01:42:13 <quicksilver> shanemikel: actually I've never used it; so not a recommendation I just thought you might find it interesting.
01:42:24 <quicksilver> shanemikel: I agree that coffeescript and ramda are neat.
01:42:52 <shanemikel> quicksilver: thanks for that, I'll definitely try it out
01:43:25 * hackagebot speedy-slice 0.1.1 - Speedy slice sampling.  https://hackage.haskell.org/package/speedy-slice-0.1.1 (JaredTobin)
01:44:23 <shanemikel> at this rate, I'll be an expert in machine linguistics without actually building anythign
01:45:28 <Mayzie> How do I run a package I installed with cabal?
01:45:42 <Mayzie> I did `cabal install leksah`, but I don't know how to launch `leksah`.
01:46:25 <nomeata> Mayzie: look in ~/.cabal/bin
01:46:44 <nomeata> and maybe add that path to your PATH for more convenient access
01:46:50 <nomeata> (if you are on linux, that is)
01:47:25 <Mayzie> I am.
01:48:26 <Mayzie> Thanks nomeata :-)
01:54:01 <kras> How do I use foldr with a Functor?
01:54:21 <shanemikel> functor isn't an interface for folding
01:54:38 <kras> sorry I meant on a Maybe [a]
01:55:34 <quicksilver> maybe just fmap it inside the maybe?
01:55:37 <quicksilver> depends what you want...
01:55:54 <quicksilver> > fmap (foldr (+) 0) (Just [1,2,3])
01:55:56 <lambdabot>  Just 6
01:56:02 <shanemikel> looks like you need to look at Data.Foldable
01:57:06 <quicksilver> if you want to treat Nothing the same as Just [] and not have a Just in the result, you could use maybe
01:57:09 <shanemikel> or you can use toList on the Maybes
01:57:26 <quicksilver> > foldr (+) 0 (fromMaybe [] (Just [1,2,3]))
01:57:28 <lambdabot>  6
02:00:26 <shanemikel> if you must implement an instance, http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Foldable.html might be helpful
02:01:07 <kras> quicksilver: thank you, let me try the first one
02:01:25 <kras> shanemikel: thanks let me have a look
02:02:08 <shanemikel> wow, hoogle rocks
02:04:13 <shanemikel> kras: oh, you don't need to go that far, I thought you meant [Maybe a].. just do what quicksilver suggested
02:07:57 <dave32> anyone here have any experience with happy? Is there a way I can get a monadic parser to only call the lexer function after reducing as much as possible.
02:08:22 <dave32> My context sensitive parser breaks because the parser and lecture are out of sync
02:08:39 <dave32> *lexer, bloody spellcheck
02:12:03 <delYsid> I understand traverse and mapM do the same thing.  Is there a rule of thumb when to use which?
02:12:15 <quchen> delYsid: Always traverse.
02:12:18 <delYsid> (i mean regarding expressivity)
02:12:28 <quicksilver> delYsid: there is no reason to use mapM, it is there for backwards compatibility
02:12:32 <quchen> mapM is more restrictive in its constraint, and consiered a historical artifact.
02:12:48 <delYsid> thanks.
02:13:22 <quicksilver> especially now Applicative => Monad
02:14:22 <merijn> :t mapM
02:14:23 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
02:14:44 <merijn> I wonder why that didn't get relaxed, probably "because the name would be confusing"
02:15:12 <merijn> Also, why does everyone seem to ignore that a lot of the FTP/AMP proposal pain stems from all the work on improving typeclasses seems to have ground to a standstill?
02:15:33 <quicksilver> merijn: why bother relaxing it when it's replaced by traverse anyway?
02:15:44 <merijn> I remember there were some proposals that would allow more easily adding superclasses and default implementations to typeclasses, but none of those seemed to be worked on anymore :\
02:15:58 <quicksilver> the default implementation stuff *was* implemented :P
02:16:09 <merijn> No it wasn't
02:16:29 <quicksilver> something was
02:16:44 <merijn> I'm talking about the ability to say "instance of X are also instances of Y using this default, unless overridden"
02:16:54 <quicksilver> default _Empty :: (Monoid a, Eq a) => Prism' a ()
02:17:06 <merijn> We just have "DefaultSignatures" where your default implementation can have a more restricted type
02:17:15 <quchen> instance Monad m where fmap = ...; pure = ...; bind = ... this would be neat!
02:17:16 <merijn> That still requires explicit definition of an instance
02:17:29 * quicksilver nods
02:17:38 <quicksilver> well default unless overridden is like overlapping instances
02:18:00 <merijn> quicksilver: Yes, hence why there was a proposal on how to make it work sanely
02:18:02 <quicksilver> it makes modules non-composable
02:18:06 <quicksilver> what's the word I want
02:18:09 <quicksilver> it's non-confluent
02:18:25 <merijn> I don't remember what the idea was, but there was some narrow way to do this
02:21:11 <delYsid> :t allWhich p = do { a <- p; eoi <- gets $ null . snd; if not eoi then mappend a <$> allWhich p else pure a}
02:21:11 <delYsid>  
02:21:12 <lambdabot> parse error on input ‘=’
02:21:16 <delYsid> gah
02:21:33 <delYsid> :t \p -> do { a <- p; eoi <- gets $ null . snd; if not eoi then mappend a <$> allWhich p else pure a}
02:21:33 <delYsid>  
02:21:34 <lambdabot> Not in scope: ‘allWhich’
02:26:40 <quicksilver> delYsid: you want ":t let allWhich p = ... in allWhich"
02:26:48 <quicksilver> delYsid: if you want to give it a name and get the type
02:26:52 <quicksilver> which is a nice way to do it
02:27:39 <quicksilver> :t let lengthOfList [] = 0; lengthOfList (x:xs) = 1 + lengthOfList xs in lengthOfList
02:27:40 <lambdabot> Num a => [t] -> a
02:27:42 <quicksilver> for example.
02:31:47 <quicksilver> merijn: in the end you need an intersection between { people who are convinced this is a good idea } and { people who have the time and skills to implement it }
02:31:57 <quicksilver> merijn: I guess none of the default proposals reached that watershed
02:32:27 <merijn> I should start a kickstarter to have people pay me to hack GHC >.>
02:33:25 <quicksilver> sounds more like a patreon, merijn?
02:33:53 <merijn> Whatever hippy crowdfunding platform du jour works :p
02:40:24 <merijn> Oh well...back to committing C++ atrocities :D
02:46:51 <cocreature> my c++ code didn't even segfault today
02:47:52 <opqdonut> because you could never get it to compile?
02:48:14 <cocreature> no, it actually compiles :)
02:49:10 <merijn> My C++ doesn't segfault in general
02:49:14 <merijn> I barely use pointers
02:51:19 <Taneb> My Haskell segfaults sometimes
02:51:37 <CindyLinz> The impossible happened!.. XD
02:52:54 <TheArtist> I have this data type: data AdditionalFlag = BVFlag BuildVariant | AFlag Arch | TVFlag ToolChainVariant deriving Eq
02:53:02 <TheArtist> And a list of [AdditionalFlag] type
02:53:20 <TheArtist> how can i do this:             let variantGiven = not . null $ filter (\af -> case af of
02:53:23 <TheArtist>                                             BVFlag _ -> True
02:53:25 <TheArtist> more clever?
02:53:27 <TheArtist>                                             AFlag  _ -> False
02:53:30 <TheArtist>                                             TVFlag _ -> False) flags
02:54:08 <merijn> TheArtist: I'm going to make you happy using two facts :)
02:54:26 <TheArtist> merijn: Hit me!
02:54:27 <arkeet> not . null $ [() | BVFlag _ <- flags]
02:54:32 <merijn> TheArtist: 1) You can use record syntax on non-record ADTs and 2) pattern match failure in list monad produces an empty list
02:54:54 <merijn> > [x | x@Left{} <- [Left 'c', Right True, Left 'x', Right False]]
02:54:56 <lambdabot>  [Left 'c',Left 'x']
02:54:57 <arkeet> any [True | BVFlag _ <- flags]
02:54:58 <arkeet> I dunno
02:55:07 <arkeet> er
02:55:09 <arkeet> or, not any.
02:55:16 <TheArtist> wow, this is AWESOME
02:55:45 <merijn> TheArtist: Using {} instead of _ means it won't break if the number of fields changes later
02:57:15 <TheArtist> i get arkeet's example but i am kinda confused in yours meijn
02:57:19 <TheArtist> merijn*
02:58:02 <merijn> TheArtist: Do you understand the following pattern: "x@(Left _)"?
02:59:15 <TheArtist> i know that @ can be used for using an alias for the whole value instead of the pattern.
02:59:41 <TheArtist> i 've used it in functions with tuples etc.
02:59:43 <merijn> Right, so that's just "pattern match against Left, and name the entire pattern 'x'"
02:59:56 <TheArtist> yes i get this.
03:00:12 <kras> Hi, plx help with this http://codepad.org/8F3udyCz
03:00:21 <TheArtist> the {} thing confuses me
03:00:30 <merijn> (Foo { foo = 3 }" is record syntax, for constructors with named fields, but the way the Report defines it's interpretation means you can use it for non record constructors too
03:00:54 <kras> Couldn't match type ‘Map String Integer’ with ‘Transaction’
03:00:54 <kras>     Expected type: Map String Integer
03:00:54 <kras>                    -> Map String Integer -> Map String Integer
03:00:54 <kras>       Actual type: Map String Integer
03:00:54 <kras>                    -> Transaction -> Map String Integer
03:00:54 <kras>     In the first argument of ‘foldr’, namely ‘f’
03:00:54 <kras>     In the expression: foldr f Map.empty tx
03:01:18 <merijn> TheArtist: "Foo{}" matches without caring about subfields, so "Foo{}" matches the constructor Foo *regardless of how many fields it happens to ahve*
03:01:19 <liste> @lpaste -- kras
03:01:20 <lambdabot> Haskell pastebin: http://lpaste.net/
03:01:40 <liste> or put them in the codepad (:
03:01:58 <merijn> So "data Foo = Foo Int; case x of Foo{} -> True" <- that matches, but it would work if "data Foo = Foo Int Char", too
03:02:11 <TheArtist> merijn: aaaaaa now i get it
03:02:17 <TheArtist> merijn: this is fantasticc
03:02:29 <merijn> TheArtist: So using "BVFlag{}" instead of "BVFlag _" is just future proving. If you add an extra field to BVFlag the {} works without change
03:02:42 <kras> http://lpaste.net/142459
03:02:44 <merijn> The "BVFlag _" would have to be modified to match the right number of arguments :)
03:03:00 <TheArtist> merijn: yes yes. i get it. IT IS BEAUTIFUL.
03:03:01 <merijn> future proofing, I guess. Typing is hard
03:03:08 <liste> kras the arguments of f are the wrong way around
03:03:12 <liste> :t foldr
03:03:13 <merijn> TheArtist: :)
03:03:13 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
03:03:17 <phaazon> hm, I thought Vector.Storable was there to be able to poke and peek them
03:04:29 <kras> liste: oops, got it
03:04:37 <kras> liste: thanks man
03:04:41 <liste> yw (:
03:05:25 <kras> liste: everytime I get confused with foldr
03:06:00 <kras> Foldable t => (b -> a -> b) -> b -> t a -> b
03:06:05 <kras> looks more natural to me
03:06:58 <roelof> hello, what is the best way to test a function which checks if three numbers are not the same with quickCheck ? 
03:07:34 <merijn> kras: It makes more sense if you look at the unfolding
03:07:42 <b_jonas> um, (not (x == y && y == z)) or something?
03:07:49 <merijn> > foldl f z [a,b,c]
03:07:50 <lambdabot>      Ambiguous occurrence ‘f’
03:07:50 <lambdabot>      It could refer to either ‘L.f’,
03:07:50 <lambdabot>                               defined at /tmp/mueval19374770841827336327.hs:1...
03:07:56 <merijn> @undefine
03:07:57 <lambdabot> Undefined.
03:07:58 <merijn> > foldl f z [a,b,c]
03:07:59 <lambdabot>  f (f (f z a) b) c
03:08:04 <merijn> > foldr f z [a,b,c]
03:08:05 <lambdabot>  f a (f b (f c z))
03:08:20 <merijn> kras: Compare what arguments are passed where in both versions :)
03:08:28 * hackagebot wai-routes 0.9.3 - Typesafe URLs for Wai applications.  https://hackage.haskell.org/package/wai-routes-0.9.3 (AnupamJain)
03:08:44 <quchen> roelof: In the general case, you want to check whether a list contains only a single distinct element. "null . drop 1 . nub" does that, for example.
03:09:02 <liste> roelof (x == y && y == z) === myFunction x y z ?
03:09:19 <kras> merijn: makes sense now, everytime I see foldr I think in terms of foldl
03:09:38 <delYsid> OK, I think I am slowly beginning to understand monad stacks.  Given this structure http://lpaste.net/142461 how do I "dive deeper"?  I.e. from a MMonad, how do I invoke a VMonad such, that it can potentially grab MMonad state by lifting get?
03:09:55 <kras> BTW, are there any advantages in using one over the other?
03:10:37 <roelof> liste, so I can do prop_threeDifferent = (x == y && y == z) === myFunction x y z   ?? 
03:11:09 <liste> roelof (not (x == y && y == z)) === myFunction x y z actually
03:11:24 <roelof> guchen : thanks for the suggestion. I have to look up what nub exactly does 
03:11:32 <f-a> hello I have a doubt with lambdabot. I am using it in another channel and when I, say, define f and then call it, I get an "ambiguous occourrence" etc. etc. "It could refer to either ‘L.f’,". I already have @undefined , is this a bug or a featre? :P
03:11:37 <lpaste> Gurkenglas annotated “No title” with “bras, I'd use this or even inline the last 4 lines. (Of course, indentations and where placement are mostly personal preference.)” at http://lpaste.net/142459#a142462
03:11:50 <Gurkenglas> *kras
03:11:57 <liste> depends on if you want to know all 3 are different from each other
03:12:08 <liste> or if 1 is different than 2 others
03:12:14 <roelof> 0ke, I was certeianly overthinking the whole problem 
03:12:25 <roelof> liste:   ^^^^^
03:12:41 <Gurkenglas> f-a, single-character names are already defined to be usable as "free variables", so we can do stuff like
03:12:47 <Gurkenglas> > x + x
03:12:49 <lambdabot>  x + x
03:12:52 <f-a> ohhhh
03:12:59 <f-a> thanks Gurkenglas 
03:13:11 <liste> > f x
03:13:12 <lambdabot>      No instance for (Show a0)
03:13:12 <lambdabot>        arising from a use of ‘show_M26119043442044892375616’
03:13:12 <lambdabot>      The type variable ‘a0’ is ambiguous
03:13:28 * hackagebot cgrep 6.5.7 - Command line tool  https://hackage.haskell.org/package/cgrep-6.5.7 (NicolaBonelli)
03:14:24 <delYsid> I gather this is somehow the reverse of lift...
03:14:49 <lpaste> Gurkenglas revised “bras, I'd use this or even inline the last 4 lines. (Of course, indentations and where placement are mostly personal preference.)”: “fromListWith, I mean <.<” at http://lpaste.net/142462
03:19:17 <Gurkenglas> delYsid, why'd you invoke VMonad from an MMonad? Can you give the type signature you want?
03:22:23 <quicksilver> Gurkenglas: that misses a fromList
03:22:35 <quicksilver> Gurkenglas: you can't use "unionsWith" directly on a key-value list
03:22:37 <quicksilver> (or can you?)
03:22:54 <delYsid> Gurkenglas: I have nested parsers...  The innermost parser returns a list of possibilities for each item it matches.  The levels above do some bookkeeping and eventually combine all lower level results with traverse in the List monad.  The innermost level needs access to a bit of state in the outermost level.  So I was thinking, to create this stack of Monads, and have the outer ones progressively invoke the more inner ones and collect
03:22:54 <delYsid> the results.  Maybe this doesn't even work, however, from the types, it looks like it should.
03:24:14 <quicksilver> Gurkenglas: maybe instead of 'concatMap f' you could use 'map (M.fromList . f)'
03:26:05 <Gurkenglas> quicksilver, I thought of that, but then it isn't just purely a refactoring anymore: If the transactions involve user input, a transaction going from a user to himself would modify his total money.
03:26:27 <Gurkenglas> And if you do fromListWith (+) you've written it twice and concatMap is better again
03:26:40 <Gurkenglas> (Well written *With (+) twice)
03:27:22 <quicksilver> Gurkenglas: but it's just wrong the way you've written it
03:27:27 <quicksilver> Gurkenglas: it doesn't type check.
03:27:37 <quicksilver> Gurkenglas: you've got to turn the key-value list into a Map somewhere :)
03:27:42 <quicksilver> before or after teh concat map
03:28:06 <Gurkenglas> Yea I've revised the annotation two lines above your first one with fromListWith
03:28:27 <quicksilver> oh really, I was looking at this http://lpaste.net/142459#a142462
03:28:29 <Gurkenglas> but lpaste doesn't like editing annotations
03:28:39 <quicksilver> ah got it
03:28:42 <quicksilver> confusing
03:29:05 <TheArtist> Is there a standard maybeHead or safeHead function?
03:29:12 <quicksilver> TheArtist: listToMaybe
03:29:17 <quicksilver> TheArtist: (yes it's a weird name)
03:30:06 <phaazon> hey, do you parse a Float with attoparsec?
03:30:12 <phaazon> like with parsec, by getting / setting the stream?
03:30:20 <quicksilver> Gurkenglas: another cute option is to change the type to 'Map String (Sum Integer)'
03:30:38 <quicksilver> Gurkenglas: and then you can use the monoid operation on maps and the whole thing reduces to a foldMap
03:31:17 <Gurkenglas> TheArtist, if you want more of the same, see te safe package, it also has yours with more consistent naming
03:32:05 <phaazon> oh nevermind, there’s the double parser
03:32:07 <TheArtist> Its ok, i'll use listToMaybe because its in the base package. Just really weird name though.
03:32:42 <Gurkenglas> It's because it's the example everyone uses when talking about natural transformations between functors, along with maybeToList
03:33:05 <Gurkenglas> (At least I'm guessing that's the reason)
03:33:22 <quicksilver> alternatively if you want more of the same, see the lens package :)
03:33:31 <quicksilver> more of the same in a different direction
03:33:37 <quicksilver> > [1,2,3] ^? _head
03:33:39 <lambdabot>  Just 1
03:33:43 <quicksilver> > [] ^? _head
03:33:44 <lambdabot>  Nothing
03:34:32 <TheArtist> Wow i really should get into lenses sometime.
03:34:44 <Gurkenglas> delYsid, is it just reading or also writing?
03:35:14 <fizruk> > [1, 2, 3] & _head .~ Nothing
03:35:15 <lambdabot>      No instance for (Show a0)
03:35:15 <lambdabot>        arising from a use of ‘show_M19223599635168398245977’
03:35:15 <lambdabot>      The type variable ‘a0’ is ambiguous
03:35:40 <fizruk> > [1, 2, 3] & _head .~ 0
03:35:42 <lambdabot>  [0,2,3]
03:36:46 <quicksilver> TheArtist: ^? can be "safe access" for an arbitrarily complicated dive into a value's structure
03:36:59 <quicksilver> oh, he not here.
03:37:08 <quicksilver> I need to switch IRC client
03:37:39 <Gurkenglas> One that asks you to confirm before posting a line that starts with a nick that just left?
03:38:00 <kqr> or one that shows the "blah left #channel" message if and only if you're writing something to blah
03:38:17 <quicksilver> one that lets me hide joins/parts for the mostly but still see them when I want them
03:38:35 <quicksilver> either I should install smartfilter into my irssi, or I should try glguy's client
03:38:36 <kqr> weechat lets you toggle joins/parts, but that's not quite good enough in my experience
03:38:38 <fizruk> is there such a client?
03:38:54 <kqr> i mean, it's heavenly, but it could be better
03:38:55 <fizruk> what is glguy's client?
03:38:57 <quicksilver> fizruk: smartfilter shows you joins/parts of people who recently spoke
03:38:59 * hackagebot mustache 0.3.0.0 - A mustache template parser library.  https://hackage.haskell.org/package/mustache-0.3.0.0 (justus)
03:39:23 <quicksilver> fizruk: https://github.com/glguy/irc-core
03:39:34 <kqr> quicksilver, not always enough though, since sometimes people highlight you, then they wait 4 hours, then leave, and then 2 hours after that you try to reply
03:39:55 <quicksilver> kqr: yes but in *that* case I am already tuned to the requirement to check they're still there
03:39:57 <kqr> i guess that doesn't matter in this case though
03:39:59 <kqr> yeah true
03:40:07 <kqr> and you'll notice when you can't tab complete their nick
03:40:16 <quicksilver> which is what I noticed this time. Eventually.
03:40:50 <quicksilver> kqr: also people inclined to use IRC asynchronously are, generally, the kind of people to be connected 24/7 :)
03:41:05 <kqr> you'd be surprised what kind of people exist
03:42:10 <quicksilver> I used to be.
03:42:21 <quicksilver> this days not much surprises me on the internet
03:59:34 <kras> Hi, how do I pattern match on an input Map?
03:59:53 <kras> f (Map k a) ?
04:00:02 <kras> f (k,a)?
04:00:16 <quicksilver> you don't, its constructors are deliberately hidden
04:00:16 <fizruk> kras: why do you want to pattern match on Map?
04:00:28 <quicksilver> instead you use the functions provided to work on it
04:00:28 <kras> Map is from Data.Strict.Map
04:01:36 <kras> I have a Map String Integer
04:01:55 <kras> I am trying to find the entry with the maximum Integer
04:02:22 <kras> basically sorting on Integer
04:02:45 <fizruk> kras: maximum is not sorting
04:02:58 <quicksilver> the simplest idea which springs to mind is to convert it to a list of key-value pairs with toList
04:03:02 <quicksilver> and then use maximumBy
04:03:04 <kras> sorting on Integer and taking the first element
04:03:12 <fizruk> :t M.assocs
04:03:14 <lambdabot> M.Map k a -> [(k, a)]
04:03:27 <fizruk> :t maximumBy snd . M.assocs
04:03:27 <lambdabot>     Occurs check: cannot construct the infinite type:
04:03:28 <lambdabot>       a1 ~ (a, a1) -> Ordering
04:03:28 <lambdabot>     Expected type: (a, a1) -> (a, a1) -> Ordering
04:03:29 <quicksilver> > maximumBy (compare`on`snd) [('a',1),('b',2)]
04:03:31 <lambdabot>  ('b',2)
04:03:31 <Gurkenglas> kras, https://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Map-Lazy.html#maxView
04:03:39 <quicksilver> Gurkenglas: that's maximum by key
04:03:41 <quicksilver> he wants value.
04:03:43 <fizruk> :t maximumOn
04:03:44 <lambdabot>     Not in scope: ‘maximumOn’
04:03:44 <lambdabot>     Perhaps you meant one of these:
04:03:44 <lambdabot>       ‘maximumOf’ (imported from Control.Lens),
04:03:48 <Gurkenglas> Whoops
04:05:04 <Gurkenglas> :t [comparing, (compare`on`)]
04:05:05 <lambdabot> Ord a => [(b -> a) -> b -> b -> Ordering]
04:05:18 <kras> quicksilver: I thought of coverting it to toList initally but then I thought maybe there is a better way to do it
04:05:59 <quicksilver> kras: there is a way which avoids constructing the intermediate list, yes
04:06:11 <Gurkenglas> kras, what do you mean better? Do you want to do something with the remainder of that map? Because you aren't going to get better than linear runtime on this unless you use something other than Data.Map
04:06:16 <quicksilver> kras: my way seems 'simpler' by some arbitrary measure
04:06:22 <kqr> quicksilver, how much does the intermediate list get constructed anyway? laziness is a thing I hear
04:06:34 <fizruk> but assocs with maximumBy fuse, so it's okay, right?
04:07:02 <quicksilver> kqr: laziness != deforestation
04:07:07 <Gurkenglas> There should be a tool that tells you whether expressions will fuse.
04:07:34 <quicksilver> kqr: laziness suggests that the list won't 'stick around'; it will be constructed one element at a time and then GC'ed
04:07:36 <fizruk> kqr: well, if maximum element is the last one, you'll have to construct the whole list (i.e. if you don't have list fusion)
04:07:47 <quicksilver> kqr: (which matters because everything stays in cache)
04:07:57 <fizruk> oops, you'll have to walk the list anyway
04:08:00 <quicksilver> but it doens't mean it actually isn't constructed at all
04:08:10 <quicksilver> but if it fuses then it won't be constructed
04:08:13 <kras> fizruk: assocs is an alias to toAscList
04:08:15 <quicksilver> or you can use foldlWithKey
04:08:40 <kqr> quicksilver, is there somewhere I can read about this? I thought lazily traversing a list meant the same cons cell/value gets reused over and over
04:08:41 <quicksilver> or foldMapWithKey
04:09:01 <fizruk> kras: that is ascending by key, while you need maximum by value
04:09:08 <quicksilver> kqr: nope, it just means that it is constructed and then becomes garbage immediately
04:09:15 <quicksilver> kqr: ...I'm not sure where you can read about it :(
04:09:28 <quicksilver> I mean, lots has been written on the operational semantics of lazy languages
04:09:39 <quicksilver> but I don't have an introductory or haskell-focussed description to point to
04:10:02 <quicksilver> I doubt it actually matters to kras if the list is constructed
04:10:04 <kqr> hm, i'll have to look around
04:10:06 <quicksilver> allocation is cheap
04:10:12 <quicksilver> so this discussion is pretty academic
04:10:14 <kqr> deallocation is not cheap, no?
04:10:40 <ggole> For short lived things it is
04:10:42 <fizruk> kqr: GHC docs perhaps for a start?: https://downloads.haskell.org/~ghc/7.0.1/docs/html/users_guide/rewrite-rules.html
04:10:49 <quicksilver> GC is very cheap if everything runs in the cache, kqr
04:10:57 <quicksilver> because cache memory is so much faster than actual RAM access
04:11:13 <quicksilver> so on modern CPUs performance is - often - just about keeping algorithms in cache.
04:11:55 <kqr> hm. i thought the problem with the JVM GC is that people tend to allocate way too much because it's cheap, then whenever it sweeps people pay a huge cost for that allocation
04:12:05 <kqr> so it's a thing to reuse objects and such in performance-critical code
04:12:14 <kqr> but maybe the GHC runtime GC works differently?
04:12:22 <kras> quicksilver: you are right, for the problem at hand it really doesn't matter much, but I was just wondering if there are many entries in the Map maybe this is not efficeint 
04:12:27 <quicksilver> I am no expert kqr.
04:12:39 <quicksilver> kqr: but a cons-cell in GHC is much smaller than a Java object I guess?
04:12:56 <Gurkenglas> Is there something that annotates the lines in my code with profiling info?
04:13:03 <quicksilver> kras: foldlWithKey
04:13:07 <hpc> quicksilver: it is, much smaller
04:13:09 <quicksilver> kras: or foldMapWithKey
04:13:17 <quicksilver> kras: would avoid the list construction
04:13:25 <quicksilver> but you'd have to think a little bit about how to handle the null case
04:13:30 <hpc> quicksilver: it's a tag of which constructor it is, plus pointers to the constructor arguments
04:13:49 <kras> quicksilver: thanks for the hint
04:14:14 <quicksilver> hpc: yeah, sorry - to be clear I know what GHC cons cells look like :) It's java I am ignorant about.
04:14:30 <hpc> ah
04:15:21 <hpc> the biggest damage for java is keeping type information around, really
04:15:35 <ggole> Java objects aren't really all that large
04:15:42 <hpc> the jvm is the second-best GC imo after ghc
04:15:56 <quicksilver> but ghc's GC isn't clever
04:16:05 <quicksilver> it's more about ghc's memory model being better suited to GC
04:16:18 <quicksilver> OK it's a bit clever - I couldn't write it :)
04:16:20 <hpc> the other major cost to java objects is having to call a constructor that does things
04:16:30 <quicksilver> but it's not clever in terms of GC research topics
04:16:39 <hpc> so a java object can be much larger just by the functionality of construction
04:16:53 <quicksilver> but the fact that immutable objects can only point to older generations
04:16:59 <quicksilver> this is a powerful optimisation right there
04:16:59 <hpc> and ease of adding fields upon fields
04:17:22 <hpc> quicksilver: i would call that clever
04:17:46 <hpc> picking an ideal memory model in the first place, and making the most common operations really damn fast just by being simple
04:18:11 <hpc> i could probably implement the ghc gc if you gave me a lot of time, but i'd never come up with it myself
04:18:18 <ggole> What do constructors have to do with object size?
04:18:33 <hpc> ggole: a java constructor can potentially have a large amount of logic
04:18:41 <hpc> leading to more allocations of sub-objects and such
04:18:50 <ggole> That doesn't have anything to do with object size.
04:18:52 <hpc> it's less memory footprint and more just cost-per-value
04:19:23 <quicksilver> hpc: it is clever, but hte cleverness is in the memory model not the collector itself. Im' splitting hairs pointlessly :) GHC is clever, let's all agree to that.
04:19:57 <quicksilver> am I blind, or is there no 'Max' newtype to make a Monoid from an Ord instance in the obvious way?
04:20:03 <quicksilver> > Max 2 <> Max 3
04:20:05 <lambdabot>      Not in scope: data constructor ‘Max’
04:20:05 <lambdabot>      Perhaps you meant variable ‘max’ (imported from Data.Ord)    Not in scop...
04:20:05 <lambdabot>      Perhaps you meant variable ‘max’ (imported from Data.Ord)
04:20:39 <fizruk> quicksilver: it's Semigroup?
04:21:01 <quicksilver> it is in indeed
04:21:06 <fizruk> > Data.Semigroup.Max 2 <> Data.Semigroup.Max 3
04:21:07 <lambdabot>      Not in scope: data constructor ‘Data.Semigroup.Max’    Not in scope: dat...
04:21:15 <fizruk> not my day
04:21:16 <hpc> ggole: object creation factors into the cost of making and destroying vast amounts of data imo
04:21:19 <quicksilver> looks like the instances are in semigroups, reactive, and monoids
04:21:30 <hpc> java also has destructors, though they're never used
04:21:51 <fizruk> are we going to have Semigroups in ghc 8?
04:22:12 <quicksilver> I'm trying to solve kras's question with a single foldMapWithKey
04:22:23 <quchen> fizruk: https://phabricator.haskell.org/D1284
04:23:44 <quicksilver> I need the monoid on (a,b) such that mappend (a0,b0) (a1,b1) = case compare b0 b1 of EQ -> (a0,b0); LT -> (a1,b1); GT -> (a0,b0)
04:23:56 <quicksilver> but I was hoping I could magically build that out of newtypes but I can't :P
04:23:59 <fizruk> quchen: I guess Closed means yes to my question? :)
04:24:02 <quicksilver> existing newtypes, I mean.
04:25:21 <quchen> fizruk: I think only the patch was code reviewed as "OK", the Trac ticket is still open.
04:26:21 <fizruk> quchen: oh here it is said to be implemented: https://github.com/ghc/ghc/blob/master/libraries/base/changelog.md
04:26:28 <quchen> Oh. Alright then!
04:31:46 <quchen> Time to get going, London is waiting! See you soon everyone who's also coming! :-)
04:34:37 <quicksilver> :t M.foldlWithKey (\mm k v -> case mm of Nothing -> Just (k,v); Just (k0,v0) -> if (v0 >= v) then Just (k0,v0) else Just (k,v)) Nothing
04:34:38 <lambdabot> Ord a => M.Map t a -> Maybe (t, a)
04:34:47 <quicksilver> kras: ^^ there you go.
04:35:07 <quicksilver> the messing around with Just/Nothing is required to correctly cope with the base case that there are no elements in the map
04:35:14 <quicksilver> it would read a bit simpler without that
04:35:21 <quicksilver> but there isn't a "foldl1WithKey"
04:35:50 <quicksilver> that avoids constructing an intermediate list and, instead, constructs some intermediate Maybe values
04:35:53 <quicksilver> although not as many :/
04:41:46 <Unhammer> with io-streams, can I create a stream that "bunches up" several lines? Say input is one word per line, and whenever the current word is a "." I want to process it as a sentence. Or should I just stick to regular foldr …
04:43:38 <Unhammer> all the examples at https://hackage.haskell.org/package/io-streams-1.3.2.0/docs/System-IO-Streams-Tutorial.html seem either line-based with nothing remembered in between, or they just reduce into a single value (len). I want to build up intermediate lists, but not keep the whole list of lists.
04:43:57 <quicksilver> seems like something you ought to be able to do, Unhammer 
04:45:13 <haskell159> hello
04:45:35 <liste> hello haskell159
04:45:36 <fizruk> is there a unit constraint constructor? like class Unit a; instance Unit a?
04:46:13 <liste> fizruk what would you do with that class?
04:46:36 <fizruk> liste: pass it to something that requires me to pass a constraint when I don't want to
04:47:22 <fizruk> liste: like here: http://hackage.haskell.org/package/contravariant-1.3.3/docs/Data-Functor-Contravariant-Generic.html
04:47:30 <haskell159> i have this funciont that gives me the even dividers of that number f n = [x|x<-[1..n],x`mod`n,even x] i want to compare if the sum of the divisors give me the number 
04:48:00 <haskell159> if i chose 12 it gives me = 2,4,6,12
04:48:00 <quicksilver> Unhammer: I think you write a 'Generator' which takes the input stream, keeps reading lines until it finds the '.' and then "yields" the whole lots
04:48:29 <aweinstock> > (\f -> foldr ((:) . f) []) (*3) [1..10]
04:48:31 <lambdabot>  [3,6,9,12,15,18,21,24,27,30]
04:48:43 <aweinstock> Unhammer: map can be expressed as foldr
04:49:06 <aweinstock> Unhammer: which also means that the single value in "reduce into a single value" can be a list itself
04:49:32 <aweinstock> s/which also means/which is a consequence of the fact/
04:49:33 <ski> > [2 | 2 `mod` 12]
04:49:34 <lambdabot>      Could not deduce (Num Bool) arising from the literal ‘2’
04:49:34 <lambdabot>      from the context (Num t)
04:49:34 <lambdabot>        bound by the inferred type of it :: Num t => [t]
04:50:38 <Unhammer> quicksilver,  Generator is part of io-streams? 
04:50:42 <quicksilver> Unhammer: yes
04:51:17 <quicksilver> Unhammer: https://hackage.haskell.org/package/io-streams-1.3.2.0/docs/System-IO-Streams.html#t:Generator
04:51:36 <Unhammer> oh, thanks, somehow I managed not to find that
04:53:00 <Unhammer> aweinstock,  I know that; I just would like to keep the IO out of the function passed to fold, but still be able to once-in-a-while empty the accumulator
04:53:31 <Unhammer> hm, yielding sounds like what I want
04:54:37 <quicksilver> or you could literally just write your own InputStream directly I believe
04:54:57 <quicksilver> Generator/yield is just a convenient way to write InputStreams
04:55:00 <Unhammer> aha
04:55:32 <Unhammer> to make it easy on people coming from python? =P
04:57:28 <quicksilver> well I think it's just easier for some cases
04:58:59 <ski> haskell159 : .. is there a question coming ?
05:00:18 <Gurkenglas> > (\n -> sum [x|x<-[2,4..n-1],n`mod`x == 0] == n) 12 -- haskell159
05:00:20 <lambdabot>  True
05:02:20 <Unhammer> View Source to the rescuehttps://hackage.haskell.org/package/io-streams-1.3.2.0/docs/src/System-IO-Streams-List.html#chunkList =D
05:04:36 <quicksilver> Unhammer: yes, exactly that kind of thing
05:04:56 <quicksilver> Unhammer: but instead of counting in the 'k' parameter, you look for '.'s
05:05:07 <quicksilver> and decide what to do at EOF (return stuff so far or ditch it)
05:11:49 <haskell159> someone can help me plss 
05:11:50 <haskell159> http://lpaste.net/142465
05:12:57 <haskell159> sorry for the english it was original from portuguese and i have translated
05:13:30 <Unhammer> mm
05:13:44 <ski>   x´mod´n
05:13:51 <ski> is incorrect syntax. correct to
05:13:59 <ski>   x `mod` n
05:14:28 <pavonia> haskell159: Have a look at the filter function
05:14:29 <ski> and that is not a boolean (/ truth-value), so can't be used as a guard in a list comprehension
05:14:29 <haskell159> yes i know i have the correct way on the function i write there wrong
05:14:35 <pavonia> :t filter
05:14:36 <lambdabot> (a -> Bool) -> [a] -> [a]
05:14:49 <ski> you need to compare the remainder of that integral division with some other number
05:15:21 <ski> "The dividers of the numbers are all the dividers except one and the number itself." -- and you're not excluding "one and the number itself" is your code
05:15:47 <haskell159> yes i forget to put x/=n
05:16:28 <haskell159> but it gives me if the number is true or false and i want the list 
05:17:26 <haskell159> what i am missing?
05:17:35 <haskell159> what am i missing?
05:17:50 <ski> `... == n' gives your a "true or false"
05:18:07 <haskell159> yes but i have to compare at some point
05:18:57 <ski> your current function checks if a given number is "fascinanting"
05:19:15 <haskell159> yes
05:19:15 <ski> perhaps you could rename it to something else, like maybe `isFascinanting'
05:19:41 <ski> and then define a new function `fascinanting' that will compute the list you're after, probably by using `isFascinanting'
05:20:20 <haskell159> so use another function that starts a list a if it is true add the number to a list 
05:20:38 <ski> something like that, perhaps
05:20:54 <haskell159> my question is how i do that ?
05:25:12 <haskell159> how i use two function one that runs a list and the other if seeks if was divisors pairs ?
05:25:22 <haskell159> runing side by side
05:26:09 <ski> "divisors pairs" ?
05:26:15 <haskell159> divisors even
05:26:42 <ski> you've already written one function
05:26:56 <ski> "Write the fuction fascinanting that , for a number n returns the list of all numbers that are fascinanatings below or equal to hum"
05:27:12 <ski> so just write one more, doing that ?
05:27:54 <haskell159> yes the other is just to run a list and compare with other and if it is true should add to a list and then return the total value
05:28:00 * ski isn't sure what the percieved problem is
05:28:27 <haskell159> i dont know how to return the list insteated of the bool 
05:30:24 <poucet> Is there a haskell implementation of a priority queue for a partially ordered type?
05:33:58 <ski> haskell159 : don't
05:34:18 <ski> haskell159 : let one function return a `Bool', and the other a list
05:36:44 <pyon> In the type signature of a monad transformer action, is it possible to say «Foo must be above Bar in the MT stack»?
05:36:54 <Wizek> Hello. Is there a way in Haskell to check whether a module exports the same functions as an other one? I have some specs (written with HSpec) and would like to have a test that checks for whether the re-exporting takes place as intended
05:37:51 <ski> pyon : no, unless you're being concrete
05:38:38 <pyon> So, basically, I can only specify the order of the transformers at the top of the stack?
05:39:30 <tdammers> you can either specify the actual stack, at least to a certain depth, or you can define constraints on the non-specific parts
05:49:37 <Gurkenglas> :t \f z xs -> alaf Endo foldMap (flip (.) . f) xs id z -- Do not give me hints, just tell me "Yes" or "No" to whether this is the intended ansatz to construct foldl from foldr.
05:49:39 <lambdabot> Foldable t => (a -> a1 -> a1) -> a1 -> t a -> a1
05:54:58 <pyon> :t alaf
05:54:59 <lambdabot> (Rewrapped s t, Rewrapped t s, Profunctor p) => (Unwrapped s -> s) -> (p r t -> e -> s) -> p r (Unwrapped t) -> e -> Unwrapped s
05:58:21 <markus1189> Gurkenglas: I am not familiar with the `alaf`, and the version I know using only foldr is simpler
05:58:46 <markus1189> Gurkenglas: vaguely: Yes
05:59:04 <ski> Gurkenglas : Yes
06:00:11 <Gurkenglas> Woo, now I can cross that one off my bucket list.
06:04:49 <roelof> what do you experts think about this solution :  http://lpaste.net/142469
06:05:47 * hackagebot d-bus 0.1.3.3 - Permissively licensed D-Bus client library  https://hackage.haskell.org/package/d-bus-0.1.3.3 (PhilippBalzarek)
06:06:32 <aweinstock> roelof: the test is exactly the same as the implementation
06:07:04 <roelof> aweinstock:  I know. I did not know a netter way of testing the function 
06:09:56 <aweinstock> roelof: what is it supposed to do? return True if any pair of the inputs are different?
06:10:26 <roelof> im reading the craft book and they ask me to write a test without explaining how quickCheck exaclty works
06:10:43 <aweinstock> > let pairs xs@~(_:xs') = zip xs xs' in pairs [1..3]
06:10:45 <lambdabot>  <hint>:1:5: Parse error in pattern: pairs
06:10:56 <aweinstock> > let pairs xs@(~(_:xs')) = zip xs xs' in pairs [1..3]
06:10:57 <lambdabot>  [(1,2),(2,3)]
06:11:25 <roelof> aweinstock:  nope, return true if the three numbers are not the same otherwise false 
06:13:22 <aweinstock> quickCheck takes a "property" (a function that returns a Bool, although internally there's some extra typeclass stuff), and calls it on a bunch of random values (generated via the "Arbitrary" typeclass) to try to find counterexamples
06:14:15 <roelof> so far I understand it 
06:14:37 <roelof> but no clue how I can tell quickCheck how to test my function 
06:15:05 <delYsid> roelof: Whats your function.
06:15:18 <aweinstock> I'd suggest writing threeDifferent in several different ways, then using quickCheck to pairwise check that they all give the same results
06:15:24 <roelof> delYsid:  see here : http://lpaste.net/142469
06:16:08 <roelof> aweinstock:  then I have to think how I can check if three numbers are not the same 
06:16:43 <aweinstock> e.g. if you have f, g, and h, and they're all supposed to do the same thing, you can do (quickCheck $ \x y z -> and [f x y z == g x y z, f x y z == h x y z, g x y z == h x y z])
06:17:16 <aweinstock> "check if three numbers are not the same" is ambiguous, I think
06:18:29 <aweinstock> for (1,1,2), there's a pair of numbers that are the same
06:19:12 <aweinstock> (it's possible that I'm overthinking this, I'm not sure)
06:19:36 <roelof> aweinstock:  this is the exact text of the exercise : http://lpaste.net/142470
06:21:09 <ski> Gurkenglas : <http://www.willamette.edu/~fruehr/haskell/evolution.html>, "leaned so far right he came back left again!"
06:23:16 <clrnd> (x /= y) && (x /= z) && (z /= y), equality is reflexive so whatever, it's also transitive but whatever²
06:24:11 <roelof> clrnd:  can you explain what you mean in normal Englisg without difficult words 
06:24:39 <clrnd> roelof, oh sorry, didn't mean to cunfuse you, let me link you
06:25:11 <clrnd> roelof, https://en.wikipedia.org/wiki/Reflexive_relation and https://en.wikipedia.org/wiki/Transitive_relation
06:25:48 * hackagebot persistent-mysql 2.3.0.1 - Backend for the persistent library using MySQL database server.  https://hackage.haskell.org/package/persistent-mysql-2.3.0.1 (GregWeber)
06:26:28 <clrnd> in any case, as far as I understand the excercise, it wants you to check every number is different with each other, and I did just that
06:26:45 <clrnd> @let threeDifferent x y z = (x /= y) && (x /= z) && (z /= y)
06:26:47 <lambdabot>  Defined.
06:26:59 <clrnd> > threeDifferent 1 1 2
06:27:00 <lambdabot>  False
06:27:01 <clrnd> > threeDifferent 1 3 2
06:27:02 <lambdabot>  True
06:27:23 <Hafydd> The transitivity of == doesn't seem particularly relevant to this.
06:27:52 <m1dnight_> Hello guys. Im trying the exercies from CIS194 and Im stuck on the first one :p The goal is to write a function `toDigits :: Integer -> [Integer]` But I am a bit stuck with the Integer. Currently I have the following: `toDigits n = map (\c -> read c :: Integer) $ show n` but read expects a string and not a char
06:28:13 <m1dnight_> oh derp.
06:28:19 <m1dnight_> [Char] = String
06:28:37 <m1dnight_> nvm just hit me.
06:30:48 * hackagebot compose-ltr 0.1.1 - More intuitive, left-to-right function composition.  https://hackage.haskell.org/package/compose-ltr-0.1.1 (Wizek)
06:31:02 <clrnd> Hafydd, well yeah, unless you also want to say (x /= z) && (z /= x) :P
06:31:21 <tdammers> m1dnight_: using `show` is kind of cheating ;)
06:31:29 <m1dnight_> Oh, is it?
06:31:37 <tdammers> well, yeah
06:31:53 <tdammers> it does the "toDigits" thing internally
06:32:06 <tdammers> it has to, how else is it going to find the right digits to print
06:32:11 <Hafydd> clrnd: what do you mean? The property that (x /= z) == (z /= x) is known as symmetry.
06:32:18 <roelof> clrnd:  oke, I understand but this brings me not closer to a solution 
06:32:25 <clrnd> Hafydd, ¬¬ yeah that
06:32:42 <Hafydd> Transitivity is: x == y && y == z --> x == z.
06:32:57 <m1dnight_> tdammers: I wouldn't have a clue how else to do it, though :p
06:33:00 <clrnd> sorry I mixed it up, meant symmetry 
06:33:24 <tdammers> m1dnight_: can you extract the least significant digit from an integer?
06:33:42 <tdammers> e.g., given 48378734871, produce 1
06:33:47 <clrnd> roelof, do you understand my solution?
06:33:56 * clrnd hits himself
06:33:58 <roelof> tdammers:  what happens if you divide it by 10 and that add to a array, That is the way I did it 
06:34:20 <tdammers> module and integer division, yes
06:34:34 <tdammers> division gives you the integer with the least significant digit *removed*
06:34:43 <tdammers> (shifted to the right, if you like)
06:34:53 <roelof> clrnd:  you mean this one ; @let threeDifferent x y z = (x /= y) && (x /= z) && (z /= y)
06:35:01 <m1dnight_> oh that way.
06:35:03 <roelof> that is the same as I found 
06:35:06 <tdammers> so that means you can split 1234 into (123, 4)
06:35:09 <clrnd> yes
06:35:23 <tdammers> 123 can be done the same way, so: recursion!
06:35:39 <tdammers> you know when to stop when your remaining integer is 0
06:35:51 <roelof> tdammers:  that is the way I did it 
06:36:05 <tdammers> then all that's left to solve is how to carry the digits found so far across the recursion
06:36:20 <tdammers> and you need to handle the special case where the input is 0 already
06:36:26 <clrnd> roelof, so, are we cool? :
06:36:29 <ggole> I think it's better to stop when the remaining integer is less than 10 (after printing it)
06:36:34 <ggole> That way you don't have a special case for 0
06:37:02 <roelof> we are cool but I ask how I can make the test better without reusing this 
06:38:08 <clrnd> roelof, why quickcheck it? you could prove it by hand :P
06:38:21 <clrnd> (I honestly have no idea how to quickchek it anyway)
06:40:01 <roelof> because one of the other is to check my functions with quickCheck. See this : http://lpaste.net/142474
06:45:02 <clrnd> roelof, I don't see a problem with checking it with the same operations, in any case it's an excercise, not a real world issue
06:45:43 <clrnd> in reality you'd make a funciton that checks an arbitrary number of elements where different to each other probably
06:45:56 <clrnd> thus making the quickcheck slightly more relevant, I guess
06:45:59 <roelof> clrnd:  oke, If it was a real world issue that I had to use Hunit ot Hspec 
06:46:55 <roelof> clrnd:  that part is I think and hope mentioned in the rest of the Craft book 
06:47:02 <lpaste> aweinstock pasted “allDifferent” at http://lpaste.net/142477
06:47:12 <roelof> or else in CIS194 or NICTA ?
06:48:04 <aweinstock> roelof: I derived that combination-enumeration algorithm from wikipedia, but I think that's the general case, and it tests everything (i.e. isn't optimized using transitivity like yours)
06:48:24 <roelof> aweinstock:  thanks, but this code is all out of my leque. IM just a beginner who has read 2 chapters about Haskell 
06:50:06 <aweinstock> the point was that (x /= y) && (y /= z) && (x /= z) is more complete/less optimized, and thus might be a good alternative implemntation to test against
06:51:02 <aweinstock> (since the optimization to (not ((x == y) && (y == z))), while correct, isn't as obviously correct due to being optimized)
06:51:31 <roelof> aweinstock:  again thanks, but this code is far to complicted . I have no clue how it works 
06:52:00 <clrnd> roelof, I'd move on the next excercise
06:54:10 <roelof> oke, and that is implement four_equal on the same way as three_different and one implemention of four_different which uses threedifferent 
06:55:23 <clrnd> *sighs*
06:55:50 * hackagebot http-api-data 0.1.0 - Converting to/from HTTP API data like URL pieces, headers and query parameters.  https://hackage.haskell.org/package/http-api-data-0.1.0 (NickolayKudasov)
06:56:27 <roelof> clrnd:  why do you laugh ?? 
06:59:40 <roelof> clrnd:  sorry I misunderstood some text 
07:00:27 <clrnd> roelof, oh that's no laughter, it's just that I don't like that kind of excercises, brings back not-so-nice memories
07:00:47 <clrnd> roelof, but ask me anyway if you have a question
07:01:42 <roelof> clrnd:  no hard feelings, I misunderstood sighs 
07:01:49 <roelof> the blame is on me 
07:06:18 <roelof> clrnd:  I also do not like those exercises but I want to have some background so I can better do CIS194
07:15:24 <roelof> one question for the future. What is the best "framework" to make a accounting programm as toy project ? 
07:17:13 <kstt> framework ?
07:18:01 <Gurkenglas> Here's a tough one, I hope (but am pretty sure) it's possible, inhabit this: "(Traversable t, Applicative f) => (t (a -> b) -> (a -> f (t b))) -> (t (a -> f b) -> (a -> f (t b)))"
07:18:15 <clrnd> roelof, that's pretty bussiness, so yesod
07:18:40 <Gurkenglas> (Perhaps it ought to be Monad f?)
07:19:00 <roelof> yes, Happstack / snap, Yesod or can I write everything myself 
07:20:59 <visof> hi guys
07:21:13 <visof> what this expression should do (fmap (fmap f) whatever) ?
07:21:17 <Gurkenglas> Actually that one is trivial, how about "(Traversable t, Applicative f) => (t (a -> b) -> (a -> f c)) -> (t (a -> f b) -> (a -> f c))"
07:21:22 <clrnd> roelof, I recommend yesod, snap is too basic and happstack no idea
07:21:31 <quicksilver> visof: it maps "two functors deep"
07:21:46 <quicksilver> > fmap (fmap (+1)) $ Just (Just 1)
07:21:47 <lambdabot>  Just (Just 2)
07:22:02 <Gurkenglas> (Basically what I want is for the first argument to be able to act as if f didn't exist in it's arguments, but each time it uses one of the a -> bs, the side effects are inscribed into the result
07:22:06 <Gurkenglas> *)
07:22:07 <roelof> oke, then after doing the craft book I will look for a tutorial how to make a website with yesod 
07:22:25 <clrnd> roelof, good: http://www.yesodweb.com/book-1.4
07:22:30 <delYsid> How do haskellers call the operation that sequence does over a list of lists?  combinations?
07:23:01 <quicksilver> delYsid: cartesian product?
07:23:33 <delYsid> let me google that, my math background is horrible...
07:24:08 <quicksilver> well, it's what sequence does on a list of lists :P
07:24:26 <quicksilver> although traditionally it wouldn't need to have a 'consistent type'
07:24:35 <quicksilver> but the type of [[a]] constrains it
07:24:38 <roelof> clrnd:  thanks, it do not looks like I build there a complete site. Can I also make muti-page forms (wizards) in yesod  ?
07:25:06 <quicksilver> liftM2 (,) on lists is the different-type version but can only do 2 lists
07:25:09 <clrnd> roelof, you can make a complete site in yesod, I promise that
07:25:18 <quicksilver> > sequence [[1,2,3],[10,11]]
07:25:20 <lambdabot>  [[1,10],[1,11],[2,10],[2,11],[3,10],[3,11]]
07:25:28 <roelof> clrnd:  I believe you 
07:25:35 <quicksilver> > liftM2 (,) [1,2,3] ['a','b']
07:25:37 <lambdabot>  [(1,'a'),(1,'b'),(2,'a'),(2,'b'),(3,'a'),(3,'b')]
07:25:41 <roelof> but I like to have examples to look at it 
07:26:41 <clrnd> roelof, http://www.yesodweb.com/book/blog-example-advanced
07:26:58 <delYsid> quicksilver: If I have a nested list, like [[[a]]] and a -> [b], would the operation [[[a]]] -> [[[[b]]]] still be called cartesian product?
07:27:32 <quicksilver> that doesn't look like sequence any more
07:27:32 <delYsid> I mean, something that produces a list of all nested cartesian products?
07:27:38 <quicksilver> that just looks like map
07:27:45 <quicksilver> are you sure it's what you meant
07:28:01 <delYsid> traveerse f xs where f :: a -> [a]
07:28:14 <roelof> clrnd:  thanks 
07:28:22 <quicksilver> :t map :: (a -> [b]) -> [[[a]]] -> [[[[b]]]]
07:28:23 <lambdabot>     Couldn't match type ‘a1’ with ‘[[a1]]’
07:28:23 <lambdabot>       ‘a1’ is a rigid type variable bound by
07:28:23 <lambdabot>            an expression type signature:
07:28:31 <quicksilver> oh
07:28:34 <quicksilver> map.map.map I mean
07:28:41 <quicksilver> :t (map.map.map) :: (a -> [b]) -> [[[a]]] -> [[[[b]]]]
07:28:42 <lambdabot> (a -> [b]) -> [[[a]]] -> [[[[b]]]]
07:28:47 <roelof> Sadly I have to leave, My daugther needed a ride to the swimming pool 
07:28:49 <quicksilver> quite different from sequence
07:28:55 <byorgey> quicksilver: but perhaps what delYsid wants is a map followed by a sequence, i.e. a traverse
07:29:24 <quicksilver> possibly so
07:29:27 <delYsid> quicksilver: no, not map.  Every level has an f.  f :: a -> [b], and every level does the same, travser f xs
07:29:31 <quicksilver> but he counted the [] wrong if it was
07:29:37 <delYsid> Which results in a list of all possible "combinations".
07:30:12 <quicksilver> there is somethiing cartesian-product like about traverse in the list monad, certainly
07:30:24 <quicksilver> there is something cartesian-product like about >>= in the list monad also.
07:30:26 <byorgey> quicksilver: I don't think so, traverse and map involve the same number of []
07:30:33 <delYsid> f = traverse g
07:30:41 <roelof> thanks all and have a nice day !!!!
07:30:43 <delYsid> g = traverse h
07:30:48 <delYsid> h = travserse i
07:30:50 <byorgey> :t map . map . map :: (a -> [b]) -> [[[a]]] -> [[[[b]]]]
07:30:52 <lambdabot> (a -> [b]) -> [[[a]]] -> [[[[b]]]]
07:31:00 <byorgey> :t traverse . traverse . traverse :: (a -> [b]) -> [[[a]]] -> [[[[b]]]]
07:31:01 <lambdabot> (a -> [b]) -> [[[a]]] -> [[[[b]]]]
07:31:07 <byorgey> :t map . map . traverse :: (a -> [b]) -> [[[a]]] -> [[[[b]]]]
07:31:09 <lambdabot> (a -> [b]) -> [[[a]]] -> [[[[b]]]]
07:31:12 <quicksilver> byorgey: oh right you are
07:31:16 <byorgey> these all have the same type but do different things
07:31:49 <clrnd> :t traverse . traverse
07:31:50 <lambdabot> (Applicative f, Traversable t, Traversable t1) => (a -> f b) -> t (t1 a) -> f (t (t1 b))
07:32:00 <delYsid> I am really just trying to work out how to name this when explaining it to other people...
07:32:51 <clrnd> :t fix traverse
07:32:52 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ t a
07:32:52 <lambdabot>     Expected type: (t a -> f (t b)) -> t a -> f (t b)
07:32:52 <lambdabot>       Actual type: (a -> f b) -> t a -> f (t b)
07:33:57 <poucet> Could we add 'https://wiki.haskell.org/IRC_channel' to the /topic? Also, could we add #haskell-beginners on that page?
07:33:57 <ski> @wiki IRC channel
07:33:57 <lambdabot> http://www.haskell.org/haskellwiki/IRC_channel
07:34:00 <delYsid> nested cartesian product?
07:36:04 <quicksilver> looks pretty full, poucet 
07:36:11 <quicksilver> what would we remove?
07:36:24 <quicksilver> also, are you the IRCer formerly known as vincenz?
07:37:28 <poucet> I am
07:38:06 <poucet> Maybe remove #haskell-ops as it could be subsumed by the link (Though the page currently does not mention haskell-ops)
07:38:08 <quicksilver> ohai :)
07:38:41 <vincenz> Hi :D
07:38:52 <dolio> Remove reddit.com/r/haskell :)
07:39:10 <vincenz> Alternatively, remove one of the logs links? Not sure why both are there
07:39:56 <vincenz> The longer term logs pages is mentioned on the IRC wiki page
07:40:05 --- mode: ChanServ set +o quicksilver
07:40:11 --- topic: set to 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org' by quicksilver
07:40:23 <quicksilver> ok well it worked anyway :P
07:40:38 <icbm> I have a function returning ReaderT (MyEnv s) (ST s).  In it, I ask for MyEnv and do something on it that returns a (ST s).  How can I avoid calling lift on that?
07:41:06 <chpatrick> icbm: use the ReaderT constructor?
07:41:10 <chpatrick> :t ReaderT
07:41:11 <lambdabot> (r -> m a) -> ReaderT r m a
07:41:30 <chpatrick> eg. ReaderT $ \env -> doStuffWithEnvinST
07:42:08 <fizruk> :t \f t x -> join ((fmap (fmap (f . fmap const)) . getCompose . traverse Compose) t x) -- Gurkenglas 
07:42:10 <lambdabot> Not in scope: ‘getCompose’
07:42:10 <lambdabot>     Not in scope: data constructor ‘Compose’
07:42:10 <lambdabot>     Perhaps you meant variable ‘icompose’ (imported from Control.Lens)
07:42:17 <vincenz> quicksilver: thank you kindly
07:42:55 <fizruk> :t \f t x -> join ((fmap (fmap (f . fmap const)) . Data.Functor.Compose.getCompose . traverse Data.Functor.Compose.Compose) t x) -- Gurkenglas
07:42:56 <lambdabot> (Monad m, Traversable f) => (f (b -> a1) -> m a) -> f (t -> m a1) -> t -> m a
07:43:33 <fizruk> almost
07:45:13 <delYsid> Yes, (traverse . traverse . traverse . traverse) is what I am dealing with.  With that added complication that I have state in two of the "traverse"s, so I can't use straight traverse.  If you were to explain an algorithm like that to someone, how'd you call its operation?
07:45:13 <icbm> chpatrick: That does it, but ends up being less readable than using lift
07:45:55 <chpatrick> icbm: how come? the extra indent level?
07:47:28 <icbm> chpatrick: analyze' s = do
07:47:28 <icbm>     h <- asks getAHashTable
07:47:29 <icbm>     lift $ H.insert h someKey someValue
07:48:14 <Mayzie> With pattern matching, how can I match a list type which can change its type? e.g. `(String [x:xs]) = ...`, `(Int [x:xs]) = ...`
07:49:03 <nolrai66> Mayzie: Err..depends what you mean.
07:49:05 <fizruk> Mayzie: what are you trying to do?
07:49:06 <icbm> chpatrick: So just less visual clutter.  I tried the approach at http://dev.stephendiehl.com/hask/ under "Newtype Deriving" but couldn't get it to work.
07:49:23 <Mayzie> One sec
07:49:43 <fizruk> Mayzie: [x:xs] is probably not what you intended (did you mean (x:xs)?)
07:50:20 <quicksilver> delYsid: you can make the stateful ones "just a traverse" as well
07:50:20 <quicksilver> by building the state into the applicative
07:50:20 <quicksilver> generically such things are simply traversals, I think
07:50:20 <quicksilver> traverse.traverse is still a traversal
07:50:20 <quicksilver> (it's a traversal of the composed Traversable)
07:51:00 <Mayzie> fizruk: Ah yes, I typoed in this chat. Sorry.
07:51:40 <delYsid> quicksilver: That is news to me, and would simplify the implementation *a lot* I guess...
07:52:11 <Mayzie> nolrai66 / fizruk: This is basically what I have at the moment: https://bpaste.net/show/79bbb4d18823
07:52:44 <fizruk> Mayzie: what should getIDs do?
07:53:02 --- mode: ChanServ set +o dolio
07:53:07 --- mode: dolio set -o quicksilver
07:53:08 <Mayzie> Returns a list of names?
07:53:12 --- mode: dolio set -o dolio
07:53:20 <fizruk> what is name?
07:53:30 <Mayzie> Just some ID
07:53:37 <Mayzie> And ID is a String.
07:53:38 <fizruk> Mayzie: can you give an example of how this should work?
07:54:26 <fizruk> Mayzie: note that `[a]` is a list of values of type `a`, this is not "a list of values of any type"
07:54:39 <Mayzie> Say `A` is something like: `data A = A Name [Name] [Name] Blah`
07:54:43 <fizruk> Mayzie: so you cannot have [123, "hello"]
07:54:47 <fizruk> > [123, "hello"]
07:54:48 <lambdabot>      No instance for (Num [Char]) arising from the literal ‘123’
07:54:49 <lambdabot>      In the expression: 123
07:54:49 <lambdabot>      In the expression: [123, "hello"]
07:54:49 <Mayzie> fizruk: Yes, I am away
07:54:54 <Mayzie> aware*
07:54:57 <carrotlord> lists are homogeneous
07:55:08 <carrotlord> not like Python where [123, "hello"] is okay
07:55:12 <Mayzie> I know?
07:55:24 <carrotlord> @fizruk
07:55:24 <lambdabot> Unknown command, try @list
07:55:51 <f-a> is anyone here using hoogle with stack? Which command should I invoke?
07:56:06 <fizruk> Mayzie: so you are trying to pattern match on both As and Bs which are (if I understand correctly) distinct types
07:56:13 <Mayzie> Correct
07:56:48 <fizruk> Mayzie: if you want to make a function that works on [A] and [B], you might use a type class
07:56:48 <quicksilver> if you want a list of A-or-Bs then you need a type for A-or-B
07:56:57 <fizruk> Mayzie: e.g. we have Show type class
07:56:59 <quicksilver> the Prelude gives you Either A B for that
07:57:18 <quicksilver> maybe getIDs :: [Either A B] -> [Name]
07:57:39 <fizruk> Mayzie: you can `map show [1, 2, 3]` or `map show ["hello", "world"]`
07:57:42 <quicksilver> (but I am having to guess here that the constructor 'A' belongs to a type 'A' beause you haven't told us)
07:57:59 <quicksilver> maybe  A and B are both constructors of the same type?
07:58:29 <Mayzie> They're not
07:59:10 <Mayzie> And when I try [Either A B], it spits out an error along the lines of: `Couldn't match expected type '[Either A B]' with actual type 'A'`
07:59:23 <quicksilver> yes well your pattern matching is also wrong
07:59:24 <Xandaros> Is it possible to explicitly state that a kind has sort "BOX"? I've seen this in various places on the web now, but ghc complains BOX is not in scope
07:59:29 <quicksilver> at the top level you have a list
07:59:34 <fizruk> > [Left 1, Right "hello"] -- Mayzie 
07:59:35 <lambdabot>  [Left 1,Right "hello"]
07:59:43 <Mayzie> quicksilver: An empty list.
07:59:45 <Mayzie> Yes.
07:59:50 <quicksilver> so your cases would be something like getIDs (Left (A ...) : rest)
07:59:51 <fizruk> :t [Left 1, Right "hello"]
07:59:53 <lambdabot> Num a => [Either a [Char]]
08:00:06 <quicksilver> getIDs (Right (B ...) : rest) ...
08:01:52 <Mayzie> quicksilver: When I try that, I get `Couldn't match expected type 
08:02:15 <Mayzie> ''B' with 'Either A B'. Expected type: [Either A B]. Actual type: [B]`
08:02:43 <Mayzie> That's better, I suppose, as it has now isn't complaining about my pattern for the A data type
08:02:44 <quicksilver> sorry, parentheses
08:02:58 <quicksilver> getIDs ((Right (B ...)) : rest) ...
08:03:28 <Mayzie> Yes, I have that
08:03:39 <Mayzie> One sec, I'll paste the code I essentially have at the moment.
08:04:09 <Mayzie> https://bpaste.net/show/d47bc38e798b
08:04:22 <quicksilver> nope
08:04:36 <quicksilver> Left (n:names) has type Either [something] something
08:04:46 <quicksilver> you want
08:05:06 <quicksilver> ((Left (A ....)) : names)
08:05:16 <quicksilver> where .... is all the parameters that the constructor 'A' has
08:06:25 <geekosaur> Xandaros, my guess is GHC.Exts
08:07:06 <lpaste> quicksilver pasted “getIDs for Mayzie” at http://lpaste.net/142481
08:07:15 <quicksilver> Mayzie: that typechecks, for example
08:08:21 <Xandaros> geekosaur: That's it - thank you! :D
08:08:21 <Mayzie> Interesting
08:08:59 <Xandaros> Hmm... PolyKinds and GADTs don't mix well, do they? :/
08:09:39 <Mayzie> How come I now don't have to pass the `n` into another function, say for example `getANames`, whereas before I had to?
08:10:33 <Mayzie> Nevermind, that's a stupid question
08:11:14 <Mayzie> Thanks quicksilver :-) You learn something new every day. Well, in my case, learn a thousand new things every day.
08:12:22 <the_2nd> how is building up until a certain point called? e.g. keep calling a method with more input. similar to recursion, just starting with an empty input, or at least the smallest input
08:12:58 <infandum> Is there a pipes function that splits based on two (or more) elements instead of one? Right now I only see splits which takes a single element to split on.
08:13:12 <Xandaros> the_2nd: comonad? writer?
08:13:39 <jmct> the_2nd: accumalation?
08:13:42 <quicksilver> the_2nd: sounds a bit like a fold, as well?
08:14:27 <infandum> Or instead, a split that splits on an element if a requirement of an element before and/or after is met but just split on the one element?
08:14:33 <the_2nd> recursion might be the right call (pasting an example)
08:17:05 <deni> does anyone have examples of shake being used for complicated build systems?
08:17:40 <the_2nd> basic example: pretty likely some functions don't exist or that theres an error (just a quick mock-up)
08:17:41 <the_2nd> http://pastebin.com/dbuT6kS2
08:18:02 <the_2nd> :6 => length in >= ...
08:18:04 <kazagistar> @Mayzie: Before and after Haskell, I have not encountered another language where I have learned more things while figuring it out (other then my first language I guess). Thats not to say Haskell is special, it was just my first deep dive into extensive type systems and functional programming.
08:18:04 <lambdabot> Unknown command, try @list
08:18:28 <kazagistar> oh, I always forget that this channel doesn't like @tagging :P
08:20:01 <jmct> the_2nd: I would say that build is a recursive function with an accumulator
08:20:11 <ChristianS> kazagistar: it has nothing to do with this channel, irc names are used just as is
08:20:20 <Mayzie> kazagistar: Same here.
08:20:31 <c_wraith> kazagistar: are there channels that do? As far as I know, that's just a twitter thing
08:20:41 <Mayzie> Also, just my name highlights me :-)
08:21:10 <Mayzie> (Cool tip, you can type the first few letters of a name and press the Tab key to autocomplete them :-) )
08:21:12 <c_wraith> the_2nd: there are so many type errors in that code that I have no idea what you mean. 
08:21:38 <kazagistar> ChristianS, c_wraith: yeah, its just a habit I picked up in HipChat
08:21:45 <kazagistar> > sorry lambdabot
08:21:47 <lambdabot>  <IO ()>
08:22:01 <kazagistar> er, that didn't work as I hoped
08:23:00 <quicksilver> c_wraith: s/length till/length in/; s/++ 1/++ [1]/;
08:23:02 <quicksilver> I assume
08:23:11 <quicksilver> and also ignore the fact that 'in' is a keyword.
08:23:11 <kazagistar> > sorry lambdabot
08:23:13 <lambdabot>  "No problem bro, I'm just a bot"
08:23:47 <c_wraith> quicksilver: it's just so much easier to talk about code that works. 
08:23:59 <quicksilver> it is, indeed.
08:24:57 <nolrai66> > sorry lambdabot
08:24:59 <lambdabot>  "No problem bro, I'm just a bot"
08:25:20 <Denommus> :t hPutStr
08:25:21 <lambdabot>     Not in scope: ‘hPutStr’
08:25:21 <lambdabot>     Perhaps you meant one of these:
08:25:21 <lambdabot>       ‘BSC.hPutStr’ (imported from Data.ByteString.Char8),
08:27:32 <kazagistar> http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#v:hPutStrhttp://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#v:hPutStr
08:27:41 <kazagistar> oh god, client plz
08:27:46 <kazagistar> sorry
08:28:06 <kazagistar> hPutStr :: Handle -> String -> IO ()
08:29:26 <quicksilver> :t System.IO.hPutStr
08:29:27 <lambdabot> GHC.IO.Handle.Types.Handle -> String -> IO ()
08:29:47 <quicksilver> the System.IO stuff is imported qualified since it's not that useful in lambdabot, I presume
08:29:57 <Denommus> damn, Arch Linux's GHC is outdated :-/
08:30:24 <c_wraith> Is it still on 6.x?
08:30:34 <silver> wait what
08:30:40 <silver> it can't be
08:30:54 <c_wraith> (joke) 
08:31:03 <silver> nono, I mean outdated part
08:31:20 <Denommus> 7.10.1
08:31:25 <Denommus> ghcjs needs 7.10.2 :-/
08:31:26 <silver> https://www.archlinux.org/packages/?sort=&q=ghc&maintainer=&flagged=
08:31:27 <silver> yeah
08:31:35 <silver> can you mix branches in arch?
08:31:48 <Denommus> I could create my own PKGBUILD
08:31:51 <Denommus> but I'm too lazy
08:32:37 <silver> also https://wiki.archlinux.org/index.php/ArchHaskell
08:33:44 <the_2nd> when a variable depends on some condition
08:34:04 <the_2nd> would I use case ... of ... syntax? or is there something shorter?
08:34:25 <quicksilver> the_2nd: other choices are if .. then and the | guards syntax
08:34:29 <Mayzie> if ... then?
08:34:47 <the_2nd> quicksilver, will the guards work for normal values?
08:34:54 <quicksilver> > let a | odd 2 = 'a' | even 2 = 'b' in a
08:34:55 <lambdabot>  'b'
08:35:03 <quicksilver> not sure what you mean by a normal value
08:35:13 <the_2nd> your example looks good
08:35:26 <quicksilver> normally I'd put the guards on separate lines and liine up the |
08:35:45 <quicksilver> and in other news, today 2 is an even number :)
08:37:18 <the_2nd> quicksilver, I want the next element after some id, if it is the last element, the next shall link back to the first
08:37:20 <the_2nd> idEndLongest | idStartLongest == length hull = 0 | otherwise = idStartLongest + 1
08:37:44 <quicksilver> looks reasonable
08:37:53 <quicksilver> I mean if/then would also look reasonable for that case I imagine
08:37:59 <quicksilver> whichever you prefer
08:38:13 <ski>   idEndLongest = (idStartLongest + 1) `mod` length hull
08:38:36 <quicksilver> ski: that's not what he's written
08:38:44 <quicksilver> that give 1 in his first case not 0
08:39:03 <ski> oh, right. off-by-one
08:39:28 <the_2nd> length hull + 1 ? looking elegant, tho
08:39:34 <quicksilver> there are only two kinds of errors. Type errors and off-by-one errors.
08:39:51 <o`connor> hey, can anyone help me figure out why I'm getting No instance ... ambiguous with this class? https://gist.github.com/oconnore/503e53532a493f80ad72
08:40:05 <o`connor> it doesn't seem like anything is overlapping
08:40:06 <ski> the_2nd : you'd have to do some silly thing with adding and subtracting one, i think
08:40:38 <o`connor> can an Int be traversable? 
08:40:40 <the_2nd> ski, I'll just leave mine. But a nice usage of modulo there, haven't thought about it
08:41:03 <quicksilver> o`connor: your last two overlap
08:41:09 <quicksilver> I can't tell you if that's what is causing your error.
08:41:34 <quicksilver> but I can say for sure that (WrapStorable a) overlaps with (t a)
08:41:38 <o`connor> quicksilver: how do they overlap? WrapStorable is not Traversable, Applicative, or a Monoid
08:41:46 <quicksilver> that doesn't matter
08:41:51 <quicksilver> overlap is a structural judgement
08:42:01 <quicksilver> constraints are not taken into account
08:42:22 <o`connor> quicksilver: ok. So is the best way to handle this just to be careful to specify the types of my inputs?
08:42:28 <o`connor> or can I restructure to make it nicer to call?
08:42:30 <the_2nd> btw. : I see all those nice alignments and think to myself: "What the hell is gonna happen if I rename something?"
08:42:48 <quicksilver> o`connor: the simplest solution is to hide your final instance inside a 'WrapTraversable' wrapper
08:43:03 <quicksilver> o`connor: whether that's the best way given your wider context is hard for me to judge.
08:43:10 <o`connor> quicksilver: ok, thank you
08:43:47 <quicksilver> do we have a concise FAQ or stackoverflow answer we can point to about why constraints aren't taken into account for instance resolution?
08:44:37 <c_wraith> It's interesting that we have a new tool to deal with that these days, though it's usury just used for Generic 
08:44:55 <c_wraith> .. Usually. Dang auto correct 
08:45:25 <Xandaros> So, I'm having some fun with dependent types and theorem proving, but I can't quite figure out how to actually apply my proof. How do I do that? http://hastebin.com/exixumuqey.hs (See my marvelous comments)
08:45:33 <quicksilver> what tool is that, c_wraith ? Pretend I'm not aware of anything which happened in the last 4 years.
08:45:44 <Xandaros> (I know I can fix it by reversing m and n. That's not the point)
08:46:19 <c_wraith> quicksilver: I forgot the name of the extension. Default instances or something 
08:47:02 <quicksilver> if you mean the thing I think you mean, that doesn't help too much
08:47:11 <c_wraith> quicksilver: but it avoids the overlap trap by requiring explicit definitions
08:47:23 <c_wraith> They're just really short. 
08:47:24 <quicksilver> o`connor would have to write down 'instance' for every case he wanted to use that on a Traversable
08:47:40 <Xandaros> Actually, I figured it out! :)
08:47:45 <quicksilver> whereas this way he gets to use it for any Traversable by invoking the WrapTraversable wrapper at point of use
08:48:00 <quicksilver> which might look slightly (?) clumsy but it's less painful now we have coerce.
08:48:14 <c_wraith> In many cases, that's actually a fine compromise 
08:48:25 <quicksilver> it's good to have more choices for sure
08:48:50 <quicksilver> but I'd still like an FAQ I could point people saying "this is how instance resolution works, and this is what would go wrong if it worked the way  you're hoping"
08:49:03 <quicksilver> because every time I try to reconstruct the argument I get part of it wrong :P
08:49:56 <c_wraith> The place it goes wrong is that instances are open. You can always add them later. 
08:50:38 <c_wraith> It makes instance selection vary more than just success/failure based on what's in scope. 
08:50:46 * quicksilver nods
08:50:54 * hackagebot pathtype 0.5.4.2 - Type-safe replacement for System.FilePath etc  https://hackage.haskell.org/package/pathtype-0.5.4.2 (HenningThielemann)
08:50:56 <quicksilver> I do know how it works. I just sometimes fail to explain it concisely.
08:50:59 <c_wraith> Standard objection to overlapping instances 
08:51:09 <quicksilver> and I bet someone has done it better, probably in a stackoverflow answer.
08:51:18 <quicksilver> ezyang has a long blog post on coherence and confluence
08:51:22 <quicksilver> but it's not a short sharp answer
08:51:47 <c_wraith> Probably 10 times. SO isn't great at deduplication. 
08:52:27 <orion> I profiled an application, and there is only one entry in the COST CENTRE table: MAIN        MAIN    100.0 (%time)   97.8 (%alloc). What does this indicate about my application?
08:52:57 <quicksilver> it may indicate you didn't add any cost centres when you compiled it?
08:53:03 <c_wraith> orion: nothing. But it means your profiling setup needs more cost centers. 
08:53:25 <orion> c_wraith: Ah, how do I add more?
08:53:55 <orion> The SCC pragma?
08:54:15 <c_wraith> As a first pass, there's a compiler flag to insert a bunch automatically 
08:54:29 <orion> -auto-all?
08:54:42 <c_wraith> Yeah, that one 
09:00:30 <Mayzie> quicksilver: ping? With regards to the getIDs function from earlier. Whenever I call it `getIDs arrB`, where `arrB = [B]`, I seem to get an error `Couldn't match type 'B' with 'Either A B' \n Expected type: [Either A B], Actual Type: [B]`
09:00:48 <quicksilver> Mayzie: yes, [B] isn't [Either A B]
09:00:58 <quicksilver> I thought you had a list of either As or Bs
09:01:05 <quicksilver> you can convert it with map Right
09:01:08 <quicksilver> :t map Right
09:01:09 <lambdabot> [b] -> [Either a b]
09:02:26 <Mayzie> quicksilver: But I can pass in a list of A's just fine? :S
09:05:29 <fizruk> :t map Left
09:05:30 <lambdabot> [a] -> [Either a b]
09:10:20 <orion> c_wraith: Thanks, that helped. Now that I've narrowed the problem down to one singular monadic function, how do I test to see which function all within that monad is causing the issue?
09:10:55 * hackagebot yesod-auth 1.4.7 - Authentication for Yesod.  https://hackage.haskell.org/package/yesod-auth-1.4.7 (GregWeber)
09:12:12 <orion> s/all/call
09:14:04 <c_wraith> orion: minor terminology nitpick: types are monads, not values. Let's say the value is a do block, or something. 
09:14:24 <orion> c_wraith: Ah, indeed that is correct.
09:15:26 <c_wraith> orion: anyway, this is where SCC annotations would be useful. But I've never played with them. I can't offer much advice here, especially since I'm on my phone. 
09:15:38 <orion> Ah ok
09:17:32 <tsahyt> People use IRC on phones these days?
09:17:40 <ttt_fff> what is (<>) for? https://www.haskell.org/hoogle/?hoogle=%28%3C%3E%29 is not very useful
09:17:48 <ttt_fff> Data.Monoid.append
09:18:04 <ReinH>  ttt_fff It's mappend
09:18:08 <tsahyt> ttt_fff: It's the monoid operation of whatever monoid you happen to be using. <> is just a synonym
09:18:20 <ttt_fff> ReinH, tsahyt: noted, thanks,
09:18:21 <ReinH> > "foo" <> "bar"
09:18:22 <lambdabot>  "foobar"
09:18:25 <tsahyt> For lists, it's concatenation for example.
09:19:14 <tsahyt> > Sum 5 <> Sum 10
09:19:15 <lambdabot>  Sum {getSum = 15}
09:19:22 <Mayzie> Is there an easier way to pass an attribute of a data type to a function, rather than having to create a whole new function to pattern match on that data type to return the attribute you want?
09:19:44 <ReinH> Mayzie: use a field accessor?
09:19:56 <Mayzie> Something like, S.name, rather than having to do getName (S _ _ name) = name
09:19:57 <Mayzie> What's that?
09:20:13 <ReinH> data Foo = Foo { a :: A } lets you do a :: Foo -> A
09:20:23 <tsahyt> Mayzie: https://en.wikibooks.org/wiki/Haskell/More_on_datatypes#Named_Fields_.28Record_Syntax.29
09:21:36 <tsahyt> Beware though, records are (currently) a bit unwieldy. This really just creates the accessor functions that you want. It does *not* do any sort of namespacing stuff for you.
09:21:48 <umib0zu> does anyone write webservers with Haskell? I’m looking for a webserver library that has session support built in. I saw Yesod has it, but I’m not sure if I should jump into Yesod. Does anyone know how Happstack and Snap compare?
09:22:20 <tsahyt> umib0zu: warp is the server used by Yesod (by default). I don't know if it does sessions though.
09:23:09 <umib0zu> is Yesod even worth learning? I sort of don’t like server side templating since I’m used to NodeJS and AngularJS tsahyt.
09:23:40 <mightybyte> umib0zu: I think typically (at least in the case of Haskell web servers) you won't find sessions actually implemented in the web server.
09:23:45 <tsahyt> umib0zu: IMO it's great. Then again I'm a fan of server side templating too. Yesod doesn't limit you to that though, it just provides a very convenient way to do it.
09:23:58 <mightybyte> umib0zu: They're usually supplied as a layer on top...at least that's what Snap does.
09:24:15 <RouxTheD1> y /3
09:24:41 <RouxTheD1> Ignore that, sorry
09:25:09 <tsahyt> You can use Yesod for whatever you need on the server side and still do all your templating client side in JS, if you're so inclined.
09:26:57 <Mayzie> Hmm, okay.
09:27:03 <Mayzie> I think I'll just stick with what I'm doing then.
09:27:04 <Mayzie> Thanks guys :-)
09:28:01 <the_2nd> Is there a maximum function
09:28:08 <the_2nd> which instead of returning the max value
09:28:14 <the_2nd> returns the id of the max in the list?
09:28:33 <johnw> you mean, like it's index?
09:28:51 <mightybyte> umib0zu: With Snap, the core server is in the snap-core and snap-server packages.  The snap package provides another layer of functionality that includes sessions, auth, etc.
09:28:55 <the_2nd> yep
09:29:05 <fizruk> can I check Cabal flag with CPP?
09:29:17 <johnw> the_2nd: you could use zip, and maximumBy snd
09:29:21 <umib0zu> hm.. cool. Thanks tsahyt mightybyte. I typically make web apps in Node but I’m starting to get comfortable enough to add Haskell to my stack. I do want to try to make a small web app with it to get comfortable with Haskell.
09:30:01 <tsahyt> the_2nd: What behavior do you expect when you have multiple elements equal to the maximum?
09:30:17 <ARM9> the_2nd see findIndex and findIndices
09:30:21 <the_2nd> tsahyt, return any / first / whatever
09:30:23 <johnw> > fst $ maximumBy (comparing snd) (zip [1..] [6, 8, 1, 9, 5])
09:30:26 <lambdabot>  4
09:31:59 <hexagoxel> fizruk: afaik, not directly
09:32:20 <tsahyt> :t comparing
09:32:21 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
09:32:40 <hexagoxel> fizruk: manually: https://github.com/lspitzner/exference/blob/master/exference.cabal#L80-L83
09:33:11 <fizruk> hexagoxel: thanks! then I suppose I do #ifdef ?
09:33:18 <tsahyt> And I've been writing (compare `on` snd) all the time...
09:35:09 <hexagoxel> fizruk: i think both #if and #ifdef work (i use #if)
09:35:26 <fizruk> hexagoxel: thanks again!
09:37:01 <tsahyt> So I'm implementing a reasoner for description logic for a toy project and I've been wondering how to tackle something on the type level. A concept can be atomic or non-atomic. I could use GADTs and DataKinds like in this paste http://lpaste.net/8184570437527666688 but this is quickly getting unwieldy. What's the preferred way to deal with this?
09:37:52 <tsahyt> I guess I could use a separate type for atomic concepts, but that feels redundant.
09:40:43 <c_wraith> tsahyt: that is really unwieldy. Does atomicity need to be part of the type? 
09:41:22 <c_wraith> What benefit does that provide? 
09:41:41 <tsahyt> c_wraith: Probably not, but I'd like to encode it on the type level somehow.
09:42:34 <c_wraith> What benefit do you get from it being part of the type? 
09:43:03 <tsahyt> I do it partly because I might actually encounter situations where functions are only specified on non-atomic concepts (dunno yet, I kinda make it up as I go), and partly because I always like to see how much information I can cram into my types.
09:43:50 <tsahyt> Case in point, that axiom definition might actually be wrong. I think I don't want to allow non-atomic concepts on the left hand side of an axiom for example.
09:43:56 <c_wraith> Well, getting it into the type isn't that bad. Using the types afterward is painful. 
09:44:32 <tsahyt> It's not just painful. I haven't actually been able to construct values in the parser so far, because nothing I've tried actually type checks
09:45:00 <c_wraith> That sounds painful. :) 
09:45:27 <c_wraith> You'd need existential wrappers. 
09:45:32 <tsahyt> I've actually had similar problems a few times already, where my types are wonderfully expressive, but I can't figure out how to construct stuff at runtime
09:45:56 * hackagebot hspec-snap 0.4.0.0 - A library for testing with Hspec and the Snap Web Framework  https://hackage.haskell.org/package/hspec-snap-0.4.0.0 (DanielPatterson)
09:46:39 <tsahyt> I guess in this particular case I can have a newtype Atomic = Atomic Text or something similar and treat the Concept type as non-atomic by default.
09:48:15 <c_wraith> The problem is that you're trying to create values whose type depends on runtime input. 
09:49:13 <tsahyt> Exactly. So I suppose I'm attempting the impossible again?
09:49:29 <c_wraith> Doing that basically always requires an existential wrapper, which just adds layers of syntactic and mental overhead to manage. 
09:51:19 <tsahyt> But when I wrap it in an existential, I lose the additional information, right?
09:52:19 <c_wraith> Not if you pack it into a class constraint. 
09:52:23 <c_wraith> https://hackage.haskell.org/package/base-4.8.1.0/docs/GHC-TypeLits.html#v:someSymbolVal
09:52:30 <c_wraith> That's an example. 
09:52:50 <c_wraith> But it's really inconvenient to write all of that code yourself. 
09:53:36 <c_wraith> Actually, you don't even need to pack it into a class, if you have a GADT around. 
09:54:00 <c_wraith> Since pattern matching on it reintroduces the type information
09:54:03 <humanoyd> I have the following json bytestring: {"deeply" : {"nested" : [ "array", "of", "strings" ]}} and want to return the Haskell value ["array", "of", "strings"]. How do I do that?
09:54:35 <c_wraith> humanoyd: are you comfortable with lens? 
09:54:45 <ReinH> humanoyd: Probably aeson
09:54:46 <Xandaros> More dependent type stuff: http://hastebin.com/qemetipuxi.hs - In the last 3 lines, is there any way to abstract that or do I have to nest deeper for every proof I apply?
09:54:48 <humanoyd> I have tried json ^? key "deeply" . key "nested" . _Array . traverse . _String from lens-aeson, but that only returns "array"
09:55:14 <fizruk> humanoyd: maybe use ^.. ?
09:55:15 <c_wraith> humanoyd: use ^.. Instead
09:55:33 <fizruk> :t (^?)
09:55:34 <lambdabot> s -> Getting (First a) s a -> Maybe a
09:55:38 <fizruk> :t (^..)
09:55:39 <lambdabot> s -> Getting (Endo [a]) s a -> [a]
09:56:01 <ReinH> Sometimes lens types *are* useful
09:56:02 <humanoyd> fizruk: c_wraith : Thanks a lot!
09:57:25 <humanoyd> Now I will just have to figure out why this works :-) lens is a beast
09:59:06 <Mayzie> Say I want to match on a type A, like `(A a b c) = ...`. If it is that type, how could I return that entire variable of that type?
09:59:59 <tsahyt> c_wraith: So, an existential wrapper would look like http://lpaste.net/8184570437527666688 (see annotation)?
10:00:23 <tsahyt> I've also changed the Axiom definition to see how it would be used
10:01:13 <ReinH> Mayzie: x = ...
10:02:05 <c_wraith> tsahyt: yes, that's what the wrapper would look like. Not sure about the rest of the details. 
10:02:07 <Mayzie> ReinH: Sorry, I don't understand?
10:02:10 <monochrom> is A really a type? or is it a data constructor and you have a misconception?
10:02:14 <Mayzie> ReinH: I am pattern matching within a function
10:02:14 <mutantmell> Mayzie: something like this?  all@(A _ _ _) = all ?
10:02:16 <ReinH> Mayzie: Maybe I don't understand.
10:02:44 <Mayzie> And I want it to match on a specific type. And if that type does match, then I want to return what was given as input.
10:02:44 <ReinH> You will return whatever type the type signature demands.
10:02:50 <tsahyt> c_wraith: Okay, given how easy refactoring is at this stage, I'll actually give this a shot. Let's see if I can finish my parser now. I can change it later if it turns out to be too ugly.
10:02:54 <ReinH> You don't match on types.
10:03:15 <ReinH> You pattern match on values.
10:03:18 <ReinH> Types are determined.
10:03:39 <mutantmell> Mayzie: I think that will do what you as want.  '@' binds the whole pattern to a variable
10:03:41 <Mayzie> Yes, values
10:03:54 <Mayzie> mutantmell: I'll give that a shot, thanks :-)
10:04:28 <ReinH> Mayzie: that's kind of a crucial distinction.
10:05:02 <Mayzie> ReinH: I'm sorry :-(
10:05:04 <Mayzie> Still learning.
10:05:45 <mutantmell> Mayzie: if you end up doing manipulations on a particular constructor of a sum type, it can help to write a helper function
10:05:45 <Mayzie> mutantmell: I think that did it. So if I understand right, <var to bind to>@(A _ _ _) = <var to bind to>, would return the variable that matches a value?
10:06:13 <ReinH> Mayzie: what are you actually trying to do?
10:06:16 <mutantmell> Mayzie: correct.  It still pattern matches on the data, but binds the entire thing to foo
10:06:42 <mutantmell> Mayzie: This is a bit of a code smell though, so once you've got something working I'd recommend taking a step back and seeing if you can remvoe that
10:06:53 <Mayzie> ReinH: What mutantmell said :-)
10:07:12 <Mayzie> It's a 3 line function. I think it's fine.
10:07:37 <sicasall> hello someone can help me me in this problem 
10:07:48 <sicasall> http://lpaste.net/142465
10:07:58 <mutantmell> Mayzie: Is it a partial function?  Those can be insidious
10:09:01 <ReinH> sicasall: That function you wrote doesn't work.
10:09:05 <ReinH> It doesn't even type check
10:09:07 <aweinstock> Mayzie: instead of having (getIDs :: [Either A B] -> [Name]), why not just use (map getAName :: [A]->[Name]) and (map getBName :: [B]->[Name]) directly?
10:09:46 <sicasall> why dont work?
10:09:51 <aweinstock> (since it looks like you're writing map manually in the lpastes from earlier)
10:09:52 <ReinH> sicasall: it doesn't typecheck.
10:09:55 <aweinstock> @src map
10:09:55 <lambdabot> map _ []     = []
10:09:55 <lambdabot> map f (x:xs) = f x : map f xs
10:10:01 <ReinH> Did you actually try to use it?
10:10:10 <sicasall> yes 
10:10:20 <ReinH> sicasall: That's impossible. It doesn't typecheck.
10:10:37 <Wizek> http://softwarerecs.stackexchange.com/questions/25476/is-there-a-fuzzy-string-match-library-for-haskell
10:10:55 <Mayzie> aweinstock: Thanks, but getIDs was just a basic mockup of what I was trying to achieve. :-)
10:10:58 <mutantmell> sicasall: x`mod`n returns a number, you need a boolean there.
10:11:31 <sicasall> but i sum the list and compare if it is equal 
10:11:43 <sicasall> returns me a bool
10:11:58 <ReinH> sicasall: x`mod`n does not return a Bool.
10:12:07 <aweinstock> Mayzie: are there going to be more types than just A and B in the future?
10:12:27 <mutantmell> sicasall: To use a list comprehension like that, you need each thing to pull from a list or return a bool.  Maybe you can't use a list comprehension for this?
10:12:45 <ReinH> sicasall: in any event:
10:12:48 <ReinH> :t filter
10:12:49 <lambdabot> (a -> Bool) -> [a] -> [a]
10:12:51 <Mayzie> aweinstock: No.
10:12:52 <ReinH> > [1..10]
10:12:54 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
10:13:04 <ReinH> sicasall: these two things should provide your answer
10:13:31 <ReinH> If you actually have a working function and wrote it incorrectly in the lpaste
10:14:58 <sicasall> i have a function that see if the numbers are dividers even
10:15:39 <sicasall> but i dont know how to see if the sum of that dividers numbers are equal to the number itself
10:15:52 <ReinH> sicasall: I thought that's what you're claiming that fascinating does.
10:16:06 <sicasall> fascinanting n = sum[x|x<-[1..n],x`mod`n,even x,n/=x] 
10:16:13 <ReinH> Which is wrong
10:16:16 <sicasall> this just verified the number 
10:16:18 <ReinH> But let's pretend that it isn't
10:16:40 <ReinH> Right, so you can verify the number
10:16:46 <ReinH> so use filter and [n..m]
10:16:57 <ReinH> to use the predicate to filter all the numbers from 1 to 1000
10:17:19 <sicasall> but how i do that 
10:17:32 <ReinH> > filter even [1..10]
10:17:34 <ReinH> like that
10:17:35 <lambdabot>  [2,4,6,8,10]
10:18:02 <sicasall> but it even x i do that
10:18:07 <ReinH> What?
10:18:17 <sicasall> i filter the odd numbers
10:18:25 <ReinH> I'm showing you an example of filter and [n..m]
10:18:38 <ReinH> You need to use these with your fascinating predicate
10:19:09 <sicasall> so i want to run a list on that function i wrote and if is true adds a number to the list
10:19:28 <ReinH> sicasall: That fascinating function is different from the one in your lpaste, which again is different from one that actually works
10:19:35 <ReinH> Please make sure you're being accurate.
10:19:45 <ReinH> No.
10:19:55 <ReinH> Youy want to filter a list of numbers using a predicate function
10:20:34 <ReinH> Like filter even [1..10] but with your predicate function and your list of numbers
10:21:17 <tesrty> So I have a 3x3 board represented as a list of lists. Each of the three lists holds three values (of an enum datatype Field) say 'X | O | B'. Now I'd like to go over the inner values (Field's) and whenever I encounter a 'B', make a copy of the whole board where this 'B' has changed into an 'X'. I keep on thinking imperatively ending up with ideas that need storing of the x,y the 'B' was found at. So if I'd
10:21:23 <tesrty>  for example use map to get to the inner values how would I manage Field -> Board. Just pointing me in the right direction would be plenty help!
10:21:32 <sicasall> i trying to understand what you are saying but i am not getting there reinh
10:22:00 <MarcelineVQ> sicasall: hmm, last time you asked this question you were asking about pairs of divisors, where is this problem coming from sicasall? Specifically is there a way we can see the actual problem as it's written?
10:22:09 <ReinH> tesrty: I suspect that you'll find what you want in http://www.cs.dartmouth.edu/~cs8/F2011/notes/11/Sudoku.lhs
10:22:45 <ReinH> sicasall: You claim you have a function that verifies if a number is fascinating. You need to filter a list of numbers using that function.
10:22:50 <tesrty> Thanks! I'll check it out.
10:22:57 <ReinH> Just like I am filtering the list of numbers 1..10 using the even function to check if they are even.
10:23:16 <ReinH> I don't know if you actually have such a function since you haven't provided a working one but you claim to.
10:23:48 <sicasall> this fuction works sum[x|x<-[1..n],x`mod`n,even x,n/=x] 
10:23:55 <sicasall> f n = sum[x|x<-[1..n],x`mod`n,even x,n/=x] 
10:23:58 <ReinH> No it doesn't.
10:23:59 <mutantmell> :t sum[x|x<-[1..n],x`mod`n,even x,n/=x]
10:24:01 <lambdabot>     Couldn't match expected type ‘Bool’ with actual type ‘Expr’
10:24:01 <lambdabot>     In the first argument of ‘mod’, namely ‘x’
10:24:01 <lambdabot>     In the expression: x `mod` n
10:24:05 <ReinH> It is a type error.
10:24:11 <mutantmell> lambdabot says it doesn't work
10:24:20 <deni> hey guys does anyone have good shake example (production wise) that they can share? or know of that's on github?
10:24:22 <mutantmell> notably: (x`mod`n) is not a boolean
10:24:49 <ReinH> As a side note, you can use spaces to separate things from each other. It makes them easier to read.
10:25:37 <ReinH> mutantmell: (That type error is inaccurate because n is free)
10:26:03 <ReinH> But the important bit is right.
10:26:10 <ReinH> :t let f n = sum[x|x<-[1..n],x`mod`n,even x,n/=x] in f 100
10:26:11 <lambdabot>     No instance for (Num Bool) arising from a use of ‘sum’
10:26:12 <lambdabot>     In the expression:
10:26:12 <lambdabot>       sum [x | x <- [1 .. n], x `mod` n, even x, n /= x]
10:26:32 <mutantmell> :t let f n = sum[x|x<-[1..n],x`mod`n == 0,even x,n/=x]
10:26:33 <lambdabot> <no location info>:
10:26:33 <lambdabot>     not an expression: ‘let f n = sum[x|x<-[1..n],x`mod`n == 0,even x,n/=x]’
10:26:40 <mutantmell> :t  n = sum[x|x<-[1..n],x`mod`n == 0,even x,n/=x]
10:26:41 <lambdabot> parse error on input ‘=’
10:26:44 <mutantmell> :t f n = sum[x|x<-[1..n],x`mod`n == 0,even x,n/=x]
10:26:45 <lambdabot> parse error on input ‘=’
10:26:46 <ReinH> I already did it
10:26:50 <mutantmell> ok, I give up there, eh
10:27:07 <mutantmell> But ok, I see that
10:27:08 <sicasall> yes i forget to put mod n ==0
10:27:23 <ReinH> sicasall: Yes, it's pretty important that you get things exactly right.
10:27:30 <ReinH> Even more so for computers than for humans.
10:27:35 <sicasall> in my program i put it 
10:27:48 <ReinH> Right. So you have a predicate function. And you have a list of numbers.
10:27:48 <sicasall> in the paste i forget it 
10:27:58 <ReinH> I already showed you how to use a predicate functon to filter a list of numbers.
10:28:05 <ReinH> You just need to do it with your predicate function and your list of numbers.
10:28:19 <sicasall> this fuction works  sum [x|x<-[1..n], x`mod`n ==0 ,even x, n/=x ]==n 
10:28:24 <sicasall> thats the one i am using
10:28:27 <MarcelineVQ> also it's n`mod`x
10:28:50 <ReinH> sicasall: You know, you can copy and paste to prevent transcription errors.
10:29:06 <sicasall> i wrote in the prompt 
10:29:36 <ReinH> sicasall: anyway, just need to use filter.
10:29:47 <sicasall> it is n´mod´x 
10:29:55 <ReinH> No it isn't.
10:29:56 <sicasall> this fuction works  sum [x|x<-[1..n], n`mod`x ==0 ,even x, n/=x ]==n 
10:30:11 <sicasall> so this fuction preditacte if the number is fascinanting
10:30:15 <ReinH> Yes.
10:30:22 <ReinH> So filter with it
10:30:48 <sicasall> how i do that ?
10:30:53 <ReinH> I showed you
10:30:58 <ReinH> > filter even [1..10]
10:31:00 <lambdabot>  [2,4,6,8,10]
10:31:07 <ReinH> Except with something else instead of even and something else instead of [1..10]
10:31:27 <sicasall> so i just put filter a list and then the fuction 
10:31:37 <ReinH> Is that what I did?
10:31:59 <sicasall> no
10:32:02 <ReinH> Then no
10:32:22 <ReinH> :t filter
10:32:24 <lambdabot> (a -> Bool) -> [a] -> [a]
10:32:28 <ReinH> filter takes a predicate function and then a list
10:32:51 <sicasall> hummm so i use the fuction and then the list 
10:33:02 <ReinH> Yes.
10:33:32 <tommd> > let isAnElementILike = (`elem` [31,33,3,131]) in filter isAnElementILike [1..200]
10:33:34 <lambdabot>  [3,31,33,131]
10:34:11 <Hijiri> I'm having linker errors in cabal repl, but not cabal build
10:34:20 <sicasall> now i get it i will try then
10:34:25 <Hijiri> I'm importing mikmod, which I have in extra-libraries
10:34:31 <Hijiri> I'll paste the error in a moment
10:35:19 <Hijiri> http://lpaste.net/142490
10:36:12 <Hijiri> or maybe that is loader error and not linker error
10:36:45 <Mayzie> Well, nighty night all. It is 4:30 am here in Sydney D:
10:36:59 <sicasall> i am using fascinanting 20 [1..100] and is giving error
10:38:20 <mutantmell> sicasall: is 'fascinanting 20' a function, or a concrete value?
10:38:44 <mutantmell> sicasall: based on your previous work, I'm guessing it's a concrete value.
10:38:50 <sicasall> yes 
10:39:06 <mutantmell> sicasall: So in that case, you cannot apply a value to another value.
10:39:19 <Hijiri> functions are concrete values
10:39:34 <Shockk> quick question; is there something like:
10:39:38 <Shockk> :t catch
10:39:39 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
10:39:52 <Shockk> except for MonadIO m => ... .. m a?
10:40:11 <mutantmell> Hijiri: Sure, but it can help to make a distinction.  My wording could have been better
10:40:43 <tommd> Shockk: catchError?
10:40:47 <tommd> :type catchError
10:40:59 <Shockk> :t catchError
10:41:00 <lambdabot> MonadError e m => m a -> (e -> m a) -> m a
10:41:01 <Hijiri> mutantmell: the distinction can probably just be made with "not a function"
10:41:17 <Shockk> ah, that would work with IOException?
10:43:28 <ReinH> ... they needed to use filter. I explained it as directly as I could without giving away the answer.
10:44:11 <mutantmell> sometimes people just need time to process stuff
10:44:31 <tommd> ReinH: Yes, you did.
10:45:59 * hackagebot pathtype 0.5.4.3 - Type-safe replacement for System.FilePath etc  https://hackage.haskell.org/package/pathtype-0.5.4.3 (HenningThielemann)
10:46:16 <mutantmell> It didn't help that their predicate didn't work at first
10:49:42 <the_2nd> http://pastebin.com/VmfPtuT1 how come I get a not-in-scope on both the "xs" here ?
10:50:03 <tsahyt> Well they're not in scope
10:50:11 <tsahyt> Guards aren't pattern matches
10:50:26 <tsahyt> A guard has the form | <some bool> = <expression>
10:51:03 <the_2nd> I see
10:51:05 <the_2nd> my mistake
10:51:06 <the_2nd> tahnks
10:51:10 <tsahyt> I'd pattern match on the top level here, distances [] = []; distances [x] = []; etc..
10:51:32 <tsahyt> Alternatively, you can use case path of
10:55:33 <ahihi> or write it as distances path = sum $ zipWith distance path (drop 1 path)
10:55:54 <the_2nd> output = x ++ y
10:55:55 <the_2nd> or
10:56:01 <the_2nd> output = (x:y)
10:56:10 <the_2nd> both seem to be valid, whats the difference there?
10:56:32 <the_2nd> ah
10:56:45 <the_2nd> [a] ++ [a] and (a:[a]) ?
10:58:37 <tsahyt> :t (++)
10:58:38 <lambdabot> [a] -> [a] -> [a]
10:58:40 <tsahyt> :t (:)
10:58:41 <lambdabot> a -> [a] -> [a]
10:58:55 <tsahyt> The former concatenates arbitrary lists, the latter only prepends one element
11:04:21 <crimsonSunrise> Hello. I'm trying to compile Haskell but the tutorial has conflicting information, like recommending MSYS2 and having the GHC download point to MinGW
11:06:15 <ReinH> crimsonSunrise: For Haskell on Windows, I think the Platform will provide the best experience. Others might have a better recommendation.
11:07:01 <crimsonSunrise> ReinH, Problem is that I want to keep GCC 5.2.0 without having it conflicting with the GCC that comes with Haskell
11:08:01 <sinelaw> I've heard MinGHC is a good windows experience: https://github.com/fpco/minghc
11:08:33 <sinelaw> crimsonSunrise: I would try that first
11:08:36 <sinelaw> ^^
11:09:10 <tesrty> ReinH: I read about the sodoku but am still stuck :[
11:09:12 <crimsonSunrise> sinelaw, I'll take a look at that. I would keepthe mingw that comes with Haskell, but it doesn't play well with c++11
11:10:04 <tesrty> You see in the example you sent a list of choices is generated for each field. Taking the carthesian product then gives all possible configurations of the board as choices and simply looks for a valid one
11:10:32 <tesrty> I have to find an empty space and indeed give possible choices. With tic-tac-toe that's just the one
11:10:52 <tesrty> The problem is, I need only the boards that are possible in one move.
11:11:09 <tsahyt> Layout poll! [a,b,c], [a, b, c], or [ a, b, c ]?
11:11:11 <tesrty> I now have a list that shows a board that has 'X' everywhere a move could be made.
11:11:45 <crimsonSunrise> tesrty, If I get you right, there are 9 possible combinations.
11:11:51 <monochrom> tsahyt: I use [a, b, c] sometimes, and [ a, b, c ] other times
11:12:33 <tesrty> Let me just pose the question again. Theres a 3x3 board. and an enum data type for 'X' 'O' and 'B'. The board is in a state and I want a list of all possible next states.
11:13:08 <crimsonSunrise> If you're talking about tic tac toe, you have 10 winning combinations.
11:13:11 <tesrty> Just one step on however. So if its player1's move, I only want all possible boards with one extra 'X'
11:13:29 <crimsonSunrise> Not 10. 8.
11:13:50 <tesrty> It's not a solver, I need to know if the next move made is valid.
11:13:53 <clrnd> right, sounds easy, iterate trough some axis and return a new board or nothing if an X can be ther eor no
11:13:54 <tremon> tesrty: isn't that just your current set with any B replaced by X?
11:14:27 <crimsonSunrise> Sound simple. Check if the place is not already occupied. If it is, don't change it, otherwise, do it.
11:15:20 <Black0range> Howdy! You've probably heard this a thousand times by now. I'm having some serious problems with cabal on the latest osx update. Anyone found a fix?
11:15:50 <tesrty> So thats where I get stuck. I ultimately need a Field -> Board. But if I use map for example I might find a field that is B, know it needs to change into an X but no way of returning the rest of the board.
11:16:12 <crimsonSunrise> sinelaw, I read a bit on the page and that doesn't solve my issue. I'm trying to compile Haskell using the latest GCC avaliable.
11:16:27 <clrnd> Black0range, what's "the latest osx update"? did you install cabal from a repository?
11:16:29 <tesrty> I know how to check for a field to be a B, not how to then copy the board with one value changed.
11:16:36 <crimsonSunrise> That package will install another version of gcc using minsys2
11:16:57 <Black0range> clrnd: osx El Cpatian 10.11 Installed haskell platform
11:17:04 <sinelaw> crimsonSunrise: oh, sorry I can't help
11:17:13 <tremon> tesrty: couldn't you use a a Board -> Move -> Board, with Move defined as Field 'B' -> Field [XO] depending on current player?
11:17:28 <clrnd> Black0range, ugh haskell platform˙˙˙ errrr I don't have experience with it, sorry
11:17:40 <crimsonSunrise> tesrty, Maybe you could set a function that monitors the state of the entire board?
11:17:57 <Black0range> clrnd: Maybe i should try to use brew?
11:18:14 <clrnd> Black0range, the modern way to install haskell is this:
11:18:20 <ahihi> I am running stack on 10.11 with no issues so far
11:18:25 <ahihi> via homebrew
11:18:30 <clrnd> http://ghcformacosx.github.io/
11:18:31 <tesrty> tremon: how would I know which field to change though?
11:19:20 <clrnd> wyeah stack can do it all by itself
11:19:25 <clrnd> try stack maybe? should be simpler
11:20:03 <tesrty> I'll write something up on lpaste
11:20:30 <sinelaw> is it always the case that constraints on types (left side of =>) can't contradict?
11:20:47 <tremon> tesrty: Move would have to have a reference to which Field you're changing. But you'd have that issue with a Field -> Board function too, right?
11:21:38 <sinelaw> Or are there fancy ones (not just 'x is an instance of some class') that can contradict each other?
11:22:19 <clrnd> sinelaw, what's a contradiction?
11:22:42 <clrnd> you can either be a member of a class or not, I don't see how you can make a contradiction of that
11:22:56 <sinelaw> if it's only type class membership, then yes
11:23:04 <sinelaw> but are there others in some fancy extension?
11:23:37 <sinelaw> (or ones generated behind the scenes when using some extension)
11:24:08 <sinelaw> I'm expecting the answer to be no, so it's ok :)
11:24:17 <tremon> sinelaw: afaik there's nothing in the language that can make typeclasses mutually exclusive
11:24:28 <sinelaw> constraints don't have to be about type classes
11:24:32 <clrnd> I don't know enough to ensure a negative answer :P
11:25:00 <sinelaw> I've noticed that the type inference (at least according to some papers) simple accumulates all the constraints while unifying the types
11:25:05 <clrnd> maybe multiParTypeClasses and typeFams with OverlappingInst. and UndecidableInst can break like hell
11:25:22 <sinelaw> *simply
11:25:24 <clrnd> maybe it works like a charm
11:26:18 <tsahyt> I think you can get contradictions in some cases
11:26:25 <tsahyt> Not in Haskell98 though
11:26:44 <tsahyt> I suppose you can come up with some incoherent stuff using type families and type equality constraints
11:27:18 <sinelaw> tsahyt: if that's the case, the compiler must do some constraint validation (check that there are no contradictions)
11:27:19 <Black0range> btw are there any way to make hard coded vectors?
11:27:52 <tesrty> tremon: but that's exactly what I'm trying to avoid. Since whenever you encounter a B you know what to change and the rest of the board should simply be added unchanged. So all data is available at the point of declaration right?
11:28:00 <lpaste> tesrty pasted “tic-tac-toe” at http://lpaste.net/2655499612495806464
11:28:07 <tsahyt> sinelaw: Type equality in constraints is evaluated at compile time, yes.
11:28:14 <tsahyt> That's the whole point anyway
11:28:33 <tesrty> So this function returns a board with all possible moves filled in, I'd like a list of boards with each board having one additional move made
11:28:51 <sinelaw> tsahyt: what I mean is to check that regardless of the type, the constraints given don't contradict each other
11:29:05 <sinelaw> tsahyt: in which case no type will ever satisfy them
11:29:38 <tsahyt> I'm not that familiar with the internals, but I believe that you simply won't be able to write anything that will actually type check
11:29:50 <sinelaw> ok
11:30:04 <tsahyt> It won't check all your constraints for general consistency, it will give you a type error
11:30:51 <sinelaw> tsahyt: I guess that's enough. if any type matches the constraint they must be consistent
11:30:55 <tsahyt> You can have arbitrary functions on the type level with TypeFamilies (for certain values of arbitrary). Checking that for consistency isn't even always possible.
11:30:55 <sinelaw> *constraints
11:31:27 <infandum> Are there any people familiar with pipes here?
11:31:34 <sinelaw> tsahyt: though, it would allow you to export un-typeable symbols from a module 
11:31:44 <tsahyt> sinelaw: Exactly. You can always treat all type level things as constructive. The point is to make things impossible to construct, and then you can be sure that they'll never occur.
11:32:08 <tsahyt> How would you export a symbol that doesn't exist?
11:32:08 <sinelaw> (for example)
11:32:34 <sinelaw> tsahyt: bla = undefined :: (Yes a, Not a) => a
11:32:39 <sinelaw> or some other contrived example
11:32:42 <tsahyt> Ah yeah, undefined.
11:32:46 <tsahyt> I prefer to ignore it.
11:32:56 <sinelaw> or even id
11:33:22 <sinelaw> badIdea = (\x -> x) :: (Yes a, Not a) => a -> a
11:33:24 <tsahyt> Well yes, technically you're right. Haskell's type system is not a consistent logic
11:34:29 <tsahyt> (consistent may or may not be the right word)
11:34:39 <ReinH> tesrty: Ah, here's a nice option using Cale's selectSplit, https://mail.haskell.org/pipermail/libraries/2008-February/009270.html
11:34:56 <tesrty> Thanks ReinH! I'll look at it.
11:35:11 <tremon> tesrty: ah, I see what you're getting at. Not sure if that's easily doable. You'd need to iterate over the cells while keeping a reference to the original Board
11:35:28 <ReinH> tesrty: Well, that's just the definition of selectSplit. I was going to provide it...
11:35:54 <ReinH> @let data Piece = X | O | E
11:35:55 <lambdabot>  Defined.
11:36:10 <ReinH> > selectSplit (replicat 9 E)
11:36:12 <lambdabot>      Not in scope: ‘replicat’
11:36:12 <lambdabot>      Perhaps you meant one of these:
11:36:12 <lambdabot>        ‘replicate’ (imported from Data.List),
11:36:16 <ReinH> > selectSplit (replicate 9 E)
11:36:18 <lambdabot>      No instance for (Show Piece)
11:36:18 <lambdabot>        arising from a use of ‘show_M478367481287603784214193’
11:36:18 <lambdabot>      In the expression:
11:36:28 <ReinH> @let data Piece = X | O | E deriving (Show, Eq)
11:36:29 <lambdabot>  .L.hs:159:1:
11:36:29 <lambdabot>      Multiple declarations of ‘Piece’
11:36:29 <lambdabot>      Declared at: .L.hs:155:1
11:36:31 * hackagebot dywapitchtrack 0.1.0.1 - Bindings to the dywapitchtrack pitch tracking library  https://hackage.haskell.org/package/dywapitchtrack-0.1.0.1 (lortabac)
11:36:32 <ReinH> sorry
11:36:33 * hackagebot pitchtrack 0.1.0.1 - Pitch tracking library  https://hackage.haskell.org/package/pitchtrack-0.1.0.1 (lortabac)
11:36:34 <ReinH> @undefine
11:36:35 <lambdabot> Undefined.
11:36:52 <ReinH> @let selectSplit [] = []; selectSplit (x:xs) = ([],x,xs) : [(x:lys,y,rys) | (lys,y,rys) <- selectSplit xs]
11:36:53 <lambdabot>  Defined.
11:36:56 <ReinH> @let data Piece = X | O | E deriving (Show, Eq)
11:36:57 <lambdabot>  Defined.
11:37:01 <ReinH> > selectSplit (replicate 9 E)
11:37:03 <lambdabot>  [([],E,[E,E,E,E,E,E,E,E]),([E],E,[E,E,E,E,E,E,E]),([E,E],E,[E,E,E,E,E,E]),([...
11:37:42 <ReinH> Now we select the ones with an empty focused square and replace them with the chosen piece:
11:38:14 <tsahyt> sinelaw: See Edward Kmett's post here https://www.reddit.com/r/haskell/comments/2zcw6z/in_the_curryhoward_isomorphism_mapping_logical/cpi383u
11:38:24 <ReinH> > [ l ++ [O] ++ r | (l, E, r) <- selectsplit (replicate 9 E)]
11:38:25 <lambdabot>      Not in scope: ‘selectsplit’
11:38:26 <lambdabot>      Perhaps you meant ‘selectSplit’ (line 153)
11:38:31 <ReinH> > [ l ++ [O] ++ r | (l, E, r) <- selectSplit (replicate 9 E)]
11:38:33 <lambdabot>  [[O,E,E,E,E,E,E,E,E],[E,O,E,E,E,E,E,E,E],[E,E,O,E,E,E,E,E,E],[E,E,E,O,E,E,E,...
11:38:56 <ReinH> tesrty: Then you can use chunksOf 3 from Data.Split to get it back into board shape
11:39:04 <Sonolin> I'm looking into lifts and am confused
11:39:10 <Sonolin> lift looks the same as fmap to me..
11:39:16 <tesrty> Yea I think I get it ReinH. Thanks a bunch. I'll go try and make it work for myself.
11:39:17 <Sonolin> is it just useful for the other lift* functions?
11:39:21 <ReinH> tesrty: kk
11:39:22 <Cale> :t lift
11:39:23 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
11:39:26 <Cale> :t fmap
11:39:27 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:39:28 <ReinH> Sonolin: liftM is fmap
11:39:32 <Cale> They have very different types
11:39:33 <ReinH> with a Monad constraint
11:39:33 <Sonolin> err yea liftM
11:39:39 <Cale> oh liftM
11:40:02 <ReinH> tesrty: cool
11:40:04 <Cale> yes, liftM is the standard implementation of fmap for things that support the Monad operations, that is return and (>>=)
11:40:23 <Cale> So if you've written your Monad instance already, you can write  instance Functor MyType where fmap = liftM
11:40:41 <Sonolin> ah ok, that sounds more useful now :)
11:41:07 <ReinH> tesrty: Yet another use case for derivatives of ADTs :)
11:41:16 <Cale> Functor only recently became a superclass of Monad
11:41:37 <Cale> and so liftM was also useful in the past in order to avoid Functor constraints when you already had a Monad constraint
11:41:45 <Cale> (for polymorphic definitions)
11:42:01 <ReinH> tesrty: see also http://stackoverflow.com/a/12872133/2225384
11:42:18 <crimsonSunrise> Also, any place where I could find a reasonable explanation on what Monads are?
11:42:34 <Cale> crimsonSunrise: https://wiki.haskell.org/Monads_as_computation
11:42:38 <sinelaw> tsahyt: thanks, that was very helpful
11:42:40 <ReinH> @google monads for functional programming Wadler
11:42:42 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
11:42:42 <lambdabot> Title: Monads for functional programming
11:42:48 <ReinH> crimsonSunrise: ^
11:42:52 <Cale> crimsonSunrise: If you're looking for the programmer-centric viewpoint, anyway
11:43:16 <ReinH> Cale: did you write that one?
11:43:20 <Cale> yes
11:43:34 <Cale> A long time ago now :)
11:43:35 <Sonolin> crimsonSunrise: http://www.youtube.com/watch?v=ZhuHCtR3xq8 was really helpful for me
11:43:37 <ReinH> Cale: That explains why it isn't awful :)
11:43:59 <Cale> I wrote it in 2007 :)
11:44:12 <ReinH> It's held up well.
11:44:23 <ReinH> Better than the thousand monad tutorials since
11:44:34 <crimsonSunrise> Sonolin, I've seen that video. It made sense until he started talking about Monads. Without showing any application of it, it's hard to understand.
11:44:41 <tesrty> Wauw. Good to know there's plenty hope if I get stuck on my next assignment that's all about monads!
11:44:51 <Cale> I actually wrote it more for monad tutorial authors than for people just learning about monads.
11:45:02 <Cale> But it should serve both well
11:45:17 <ReinH> tesrty: if this is for an assignment, you should make sure you understand how selectSplit works. Well, you should do that anyway.
11:45:17 <Sonolin> crimsonSurise yea, I just watched it on repeat until I understood >.>
11:45:21 <Cale> I was getting frustrated at the number of people who were missing the whole point of talking about monads
11:45:30 <ReinH> heh
11:45:39 <crimsonSunrise> One thing I kind of fringe is that most people writting haskell tutorials assume that everyone using it is academic or knows the theory behind the constructs.
11:46:12 <Cale> crimsonSunrise: This is not true :)
11:46:30 <ReinH> crimsonSunrise: Many of them assume the opposite and use bad analogies for familiarity.
11:46:43 <shirt> crimsonSunrise: that's common FUD about haskell. there are tons of tutorials and books that make no such assumption
11:46:56 <dolio> Many people writing Haskell tutorials don't understand the theory very well themselves. :)
11:47:02 <dolio> Or at least, that was the case in the past.
11:47:10 <ReinH> Some of them assume the opposite and don't make that mistake, like Cale.
11:47:14 <tesrty> Of course ReinH! I know pipes and pattern matching quite well by now. I'm busy playing with selectSplit to really understand it as we speak ;]
11:47:20 <Cale> crimsonSunrise: There are some of us who do know the theory behind it, but learning e.g. category theory, is a long excursion which is mostly a waste of time if your interest is only in writing software.
11:47:38 <crimsonSunrise> Well, anything that's not LYAH in that regard?
11:47:50 <Cale> crimsonSunrise: In what regard?
11:48:00 <crimsonSunrise> Of what I said.
11:48:32 <crimsonSunrise> I mean, the sort of similar effort i've seen is a video that showcases the basics of haskell in an hour...but don't touch monads.
11:48:36 <Cale> oh god, someone linked the horrible Brian Beckman video? People found that useful?
11:49:13 <ReinH> Cale: It gets worse. I've seen people link the Crockford video...
11:49:15 <tsahyt> I found it useful back then
11:49:31 <Cale> That is like the worst non-explanation of what monads are about
11:49:43 <Cale> Though I don't think I've seen this Crockford video
11:49:51 <ReinH> Cale: please don't.
11:49:57 <crimsonSunrise> Cale, Well, at least it has content. Watch what happens if you ask why you can't parse HTML with regex on StackOverflow.
11:50:23 <dolio> Do people tell you to go to college?
11:50:34 <ReinH> Cale: But if you must, https://www.youtube.com/watch?v=b0EF0VTs9Dc
11:50:50 <Cale> looool
11:51:13 <crimsonSunrise> There's also the Derek Banas 'Learn Haskell in one video'...but it doesn't cover Monads.
11:51:49 <Cale> ReinH: Perfect, using Javascript too, just to make sure that the abstraction will be completely unusable even if we succeed.
11:52:06 <tsahyt> I think that for learning what monads are about, you just need hands on experience.
11:52:30 <Zemyla> Hmm, how do I use a cabal sandbox in GHCi?
11:52:36 <Cale> tsahyt: Yes.
11:52:41 <dolio> Zemyla: cabal repl
11:52:52 <Cale> The best way to understand what the Monad typeclass is for is to use a handful of instances of it
11:53:24 <tsahyt> I really just treated do blocks like imperative code with a "semantically useful semicolon" for a while and started using higher level functions bit by bit and eventually it all came together nicely
11:53:26 <dmj`> Zemyla: cabal exec ghci too
11:53:30 <crimsonSunrise> I think that the 'Learn Haskell in one video' helps you understand LYAH better than LYAH does.
11:53:39 <jstimpfle> in the end, all there is is in the signature
11:53:52 <jstimpfle> i think for the beginner it might help to avoid do notation
11:53:57 <ReinH> "Learn Haskell in one video" is a pretty big oversell.
11:54:02 <Zemyla> dmj`: Does cabal exec winghci work too?
11:54:12 <Cale> Once you see how sequence / mapM / liftM2 / etc. work for IO and Maybe and lists, and Parser, you start to get a sense for "hey, this is actually saving us from rewriting a bunch of code in all these libraries"
11:54:13 <ReinH> The video in question is equivalent to maybe the first chapter of a serious haskell book.
11:54:34 <tsahyt> Like with most abstract concepts, the trick is to *not* try and interpret it too early, but just apply it and eventually intuition forms. At least that's how I treat these things
11:55:11 <Cale> If you're trying to translate the monad abstraction into another programming language, and you can't write a sequence function *once* that works with any monad at all which you might define in the future, then you have failed.
11:55:25 <Cale> :t sequence
11:55:26 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
11:55:27 <Cale> ^^ this thing
11:55:30 <crimsonSunrise> ReinH, The video shows the concepts by application, rather than focusing on how things work. More like showing you how to use a tool, instead of focusing on the technicalities of it.
11:55:35 <Cale> er, sans the Traversable bit
11:55:45 <Cale> sequence :: Monad m => [m a] -> m [a]
11:55:52 <ChristianS> anyone knows why, in the Maybe monad, fail is Nothing, but in Either it's still error rather than Left? that looks like a strange oversight...
11:55:53 <Cale> is enough of a litmus test :)
11:56:07 <crimsonSunrise> I'm confused already, XD
11:56:12 <gfixler1> :t flip id
11:56:13 <lambdabot> b -> (b -> c) -> c
11:56:13 <Cale> ChristianS: Because Left only works for Either String
11:56:22 <gfixler1> can anyone enlighten me on that one?
11:56:33 <Cale> id :: (b -> c) -> b -> c
11:56:36 <ChristianS> Cale: ah, right, didn't think of that
11:57:10 <Cale> ChristianS: fail shouldn't even really be in the Monad class -- adding it was a mistake made by the Haskell 98 committee
11:57:26 <Cale> I tend to just pretend that fail doesn't exist.
11:57:28 <davean> Yah, fail makes no sense, we just aren't very good at cleaning up haskell
11:57:43 <davean> Please excuse the mess
11:57:48 <dolio> Only took 17 years.
11:58:30 <Cale> gfixler1: did my remark answer your question? :)
11:58:39 <gfixler1> Cale: yeah, no :)
11:58:55 <ChristianS> Cale, davean: oh, i'm more on the side that worries that cleaning up the mess might cause too much breakage. some historical accident is fine with me.
11:58:57 <gfixler1> (b -> c) -> (b -> c) looks like id, but of a function
11:58:57 <Cale> gfixler1: Okay, so id's most general type is a -> a
11:59:00 <dmj`> Zemyla: maybe, cabal exec was meant to be like the old 'hsenv', I think it starts a new shell where the package database is set to that of the sandbox
11:59:00 <hpc> it was 98 and they didn't really know better
11:59:04 <hpc> the matrix hadn't even come out yet ;)
11:59:05 <gfixler1> Cale: is unit slipping in there somehow?
11:59:18 <Cale> gfixler1: in order to apply flip:
11:59:19 <jstimpfle> gfixler: if you say flip, then you restrict id to function arguments
11:59:20 <Cale> :t flip
11:59:21 <lambdabot> (a -> b -> c) -> b -> a -> c
11:59:37 <gfixler1> ah, that's brushing away some of the mist
12:00:01 <Cale> for flip id to make sense, we need to unify id's type a -> a with  a -> (b -> c), which is the type of the argument to flip
12:00:02 <gfixler1> yeah, I guess I get it now - thanks!
12:00:09 <Cale> So we pick a = b -> c
12:00:22 <Cale> and we're using id :: (b -> c) -> b -> c
12:00:55 <Cale> and flip's type gets specialised to  ((b -> c) -> b -> c) -> b -> (b -> c) -> c
12:01:12 <dmj`> Zemyla: you might need to use cygwin
12:03:53 <Cale> crimsonSunrise: *anyway*
12:05:19 <Cale> crimsonSunrise: The main point about Monad is that it's just a pattern which appears in the APIs of a lot of libraries we tend to write as functional programmers, and we're capturing that pattern and abstracting over it so as to save writing similar code repeatedly.
12:05:48 <sinelaw> Cale: shhhh
12:06:06 <sinelaw> gotta make a living
12:06:11 <Cale> crimsonSunrise: It's not really that big of a deal. Maybe some of the examples of monads are a big deal if you've never seen anything like them before, but really the fact that they're monads does not tend to be super-important.
12:06:50 <Cale> (If we didn't recognise that fact, we'd just end up writing a handful of different things for piecing together values instead)
12:07:02 <sinelaw> seriously though, ST is the confusing one. For some strange reason it is sometimes chosen as an example.
12:07:27 <hpc> crimsonSunrise: and if you've written stuff with Maybe or similar, you have likely already used (>>=) in its expanded form by accident
12:08:01 <hpc> conceptually, ST is IO except you have to explain forall now also
12:08:09 <sinelaw> and existentials
12:08:18 <Cale> I always like to start with sequence as an example of something which is useful in a lot of settings and which can be built from return and (>>=) (or do-notation) once, and then reused in all those different settings
12:08:22 <hpc> and IO isn't even that bad
12:08:27 <Maxdamantus> which dont exist in Haskell.
12:08:27 <sinelaw> IO is reasonable
12:08:33 <hpc> the instance is magic because IO is already magic
12:08:36 <Cale> sequence applied to a list of IO actions produces an IO action which runs them all in turn and collects a list of the results
12:08:55 <hpc> but nobody has trouble with fmap on IO either
12:09:07 <ReinH> Also mapM, which then lets you talk about Traversable
12:09:16 <Cale> sequence applied to a list of Parsers produces a Parser which parses the concatenation of the languages parsed by each one, collecting a list of the results
12:09:21 <aweinstock> :t (mapM, traverse)
12:09:22 <lambdabot> (Monad m, Applicative f, Traversable t, Traversable t1) => ((a -> m b) -> t a -> m (t b), (a1 -> f b1) -> t1 a1 -> f (t1 b1))
12:09:44 <aweinstock> is traverse just mapM on applicatives?
12:09:57 <hpc> :t traverse `asTypeOf` MapM
12:09:58 <lambdabot>     Not in scope: data constructor ‘MapM’
12:09:58 <lambdabot>     Perhaps you meant variable ‘mapM’ (imported from Data.Traversable)
12:10:01 <Cale> sequence applied to a list of lists produces a list of ways to pick one element from each list and collect them into a list:
12:10:02 <hpc> :t traverse `asTypeOf` mapM
12:10:04 <lambdabot> (Monad f, Traversable t) => (a -> f b) -> t a -> f (t b)
12:10:07 <hpc> yep
12:10:08 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
12:10:10 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
12:10:48 <Cale> sequence applied to a list of Maybe values will be Just a list of values, if they're all Just, and Nothing, if any one of them was Nothing:
12:10:51 <aweinstock> > sequence ["ab","cd","ef"]
12:10:53 <lambdabot>  ["ace","acf","ade","adf","bce","bcf","bde","bdf"]
12:10:57 <Cale> > sequence [Just 1, Just 2, Just 3]
12:10:58 <lambdabot>  Just [1,2,3]
12:11:02 <Cale> > sequence [Just 1, Just 2, Nothing, Just 3]
12:11:04 <lambdabot>  Nothing
12:11:21 <ReinH> My favorite use of sequence / traverse is Richard Bird's sudoku solver
12:11:40 <Cale> crimsonSunrise: The point of Monad is to only have to write sequence (and a whole bunch of other things) once, and then reuse the code.
12:11:44 <ReinH> sequence is the cartesian product for lists
12:11:51 <aweinstock> @src sequence
12:11:51 <lambdabot> sequence []     = return []
12:11:51 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:11:51 <lambdabot> --OR
12:11:51 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
12:12:08 <sinelaw> who are we preaching to?
12:12:17 <aweinstock> @undo do v <- x; vs <- sequence xs; return (v:vs)
12:12:17 <lambdabot> x >>= \ v -> sequence xs >>= \ vs -> return (v : vs)
12:12:21 <sinelaw> oh sorry, nvm
12:12:25 <Cale> sinelaw: crimsonSunrise was looking for info regarding what monads are about
12:12:35 <aweinstock> @. pl undo do v <- x; vs <- sequence xs; return (v:vs)
12:12:35 <lambdabot> (`fmap` sequence xs) . (:) =<< x
12:12:59 <Cale> (but even if he's not still here, someone probably is lurking :)
12:13:04 <sinelaw> Cale: yes, they haven't said anything in 20 minutes almost
12:13:29 <crimsonSunrise> That's what confusion is about.
12:13:55 <ReinH> It's Wednesday, welcome to church.
12:14:00 <ReinH> The Church church.
12:14:09 <crimsonSunrise> Type signature?
12:14:25 <sinelaw> ReinH: we have a Peano
12:15:01 <crimsonSunrise> Also, I'm wondering why people make fun of OCaml...
12:15:47 <hpc> heh
12:15:50 <ReinH> What people?
12:15:58 <monochrom> who?
12:15:58 <ReinH> Surely none of these people.
12:16:06 * monochrom doesn't make fun of ocaml
12:16:08 <sinelaw> OCaml is neat
12:16:09 <hpc> a type signature is the thing that says what type something is
12:16:15 <hpc> "foo :: Int" is a type signature
12:16:18 * monochrom makes fun of camel case but not ocaml
12:16:21 <hpc> with "foo = 5" being a definition
12:16:37 <crimsonSunrise> I know what a type signature is. I was asking what's the type signature of Church
12:16:55 <aweinstock> crimsonSunrise: are you familiar with C? "int f(int x);" as a function prototype is kind of similar to "f :: Int -> Int" in haskell (as a type signature)
12:16:56 <hpc> derp
12:16:57 <ReinH> crimsonSunrise: It helps if you phrase your questions as complete sentences...
12:17:13 <phaazon> hey
12:17:20 <sinelaw> crimsonSunrise: https://en.wikipedia.org/wiki/Church_encoding if you're not aware of that
12:17:37 <aweinstock> :t foldr -- church encoding of lists (I think?)
12:17:38 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
12:17:41 <phaazon> I’m using attoparsec and I’m looking for a way to use many1 and make it fail if the parser fail
12:17:45 <phaazon> is there a way to do that?
12:17:49 <monochrom> is Church a value? does Church have a type?
12:17:50 <phaazon> maybe I should use manyTill?
12:18:00 <phaazon> like, manyTill endOfInput?
12:18:44 <ReinH> Pretty sure Church is a person. Was a person. Also now Church looks like it's spelled wrong.
12:18:48 <crimsonSunrise> sinelaw, Would 'I now know less than when I started count as a valid answer?'
12:19:04 <Zemyla> Hmm, would the Church-encoded version of ReadS be (a -> String -> r -> r) -> String -> r -> r?
12:20:39 <ReinH> Pedantic note that this isn't a Curch encoding as Church encodings are untyped. It is properly a Boehm-Berarducci encoding. http://okmij.org/ftp/tagless-final/course/Boehm-Berarducci.html
12:20:40 <aweinstock> Zemyla: does church-encoding apply to typeclasses? I thought it only applied to algebraic datatypes?
12:20:59 <Zemyla> ReadS a = String -> [(a, String)].
12:21:10 <Zemyla> It's a type, not a typeclass. Read is the typeclass.
12:22:00 <ReinH> ReadS is the Seussian encoding of a parser.
12:22:32 <monochrom> how do you do church encoding of a type with an -> in it? is there even such a thing?
12:22:46 <Zemyla> Yeah, no reason why you can't.
12:23:28 <dmj`> are types of kind 'Symbol' heap allocated? doesn't seem like they can be lifted (can't contain bottom), unless I'm mistaken
12:23:32 <monochrom> no, I see that as no reason why I can.
12:24:08 <dolio> Types don't exist at runtime.
12:24:12 <ReinH> "No reason why you can't" is not how math works...
12:24:27 <monochrom> dmj`: is there even any value involved? only values are stored on heap or stack or anywhere
12:24:32 <Zemyla> ReinH: Okay, the answer is yes, they can.
12:25:02 <Zemyla> Like, the Church encoding of t -> a is (a -> r) -> t -> r.
12:25:56 <dmj`> monochrom, dolio: trying to see how 'heyVal' is had in heyVal :: String = symbolVal (Proxy :: Proxy "hey"), where "hey" is a type level literal of kind Symbol
12:26:46 <aweinstock> :t symbolVal
12:26:47 <lambdabot> Not in scope: ‘symbolVal’
12:26:56 <aweinstock> @hoogle symbolVal
12:26:57 <lambdabot> No results found
12:27:06 <dmj`> dolio: type level literals seem to be present at runtime, so that's why I'm confused
12:27:41 <dmj`> not the type, but the value of the name of the type
12:27:57 <dmj`> if that makes sense
12:28:09 <monochrom> then heyVal is a value. (and it is not a type, despite what you said.) but I forgot whether it's a static CAF or a heap object, or a little bit of both
12:29:08 <dolio> Type level literals aren't present at runtime. There are just runtime values that correspond to type level literals in some cases.
12:30:45 <dmj`> dolio: cool, so it seems like the name of the type gets substituted in as a value at compile time (a String), so the name of the type literal is present, but not the type, obviously, natVal seems to do the same 
12:30:47 <dolio> And since in this case the runtime value is a String, it's going to use something like heap.
12:31:29 <shirt> why is snap advertising on google?
12:31:47 <dmj`> monochrom, dolio: thank you
12:31:59 <mightybyte> shirt: Huh?  Where do you see that?
12:32:14 * hackagebot HaRe 0.8.2.0 - the Haskell Refactorer.  https://hackage.haskell.org/package/HaRe-0.8.2.0 (AlanZimmerman)
12:32:51 <dolio> dmj`: It would be roughly the same if you created a bunch of types A, B, C, and a way to string them together, and then used a type class like 'class StringRep typestring where stringRep :: typestring -> String'.
12:33:41 <dolio> The `typestring` variable would have to get resolved at compile time at some point, and the corresponding string would get built.
12:34:33 <dolio> Maybe `Proxy typestring`.
12:35:37 <dmj`> dolio: yes, it's interesting how proxy lets you grab the value of the type level literal at compile time
12:36:07 <shirt> mightybyte: http://i.imgur.com/2LucGaz.png
12:37:17 <mightybyte> shirt: Cool.  I'm not sure who's doing that.
12:37:44 <dolio> Well, Proxy isn't special. Just `stringRep :: String` doesn't mention `typestring`. And having to use `undefined :: typestring` is kind of annoying, and doesn't even work if you want to make `typestring` not kind *.
12:38:04 <dolio> The whole point of type classes is to dispatch values off of types.
12:38:13 <crimsonSunrise> Might seem like a broad question, but how are the state of affairs with game development on haskell?
12:38:21 <monochrom> no, Proxy does not do the job. symbolVal does.
12:39:06 <monochrom> Proxy is there just so you don't have to say the unsatisfactory "undefined". ("undefined" has other limitations too, of course.)
12:39:43 <shachaf> Proxy also works for non-* types.
12:45:28 <ReinH> crimsonSunrise: Not so great.
12:45:57 <ReinH> crimsonSunrise: You might be interested in http://www.haskellforall.com/2015/08/state-of-haskell-ecosystem-august-2015.html
12:46:20 <ReinH> crimsonSunrise: Specifically, http://www.haskellforall.com/2015/08/state-of-haskell-ecosystem-august-2015.html#game-programming
12:46:24 <sinelaw> ReinH: beat me to it!
12:46:47 <dmj`> dolio: can typestring even be of kind * ?
12:46:49 <ReinH> Although edwardk is making it a bit of a personal mission to fix that. Which he very well might do.
12:47:12 <ReinH> Given that he is an expert in both haskell and game development.
12:47:14 <dmj`> dolio: the symbolVal is interesting because it doesn't seem to be using a typeclass to get from a type to a value
12:48:09 <dolio> Well, it's probably some wired-in thing, but you could do it with a type class.
12:49:51 <dolio> What module is symbolVal from?
12:49:55 <monochrom> symbolVal uses symbolSing. symbolSing is a type class method.
12:49:55 <dmj`> monochrom: but Proxy plays a role right? I mean, symbolVal :: KnownSymbol n => Proxy n -> String
12:50:02 <monochrom> GHC.TypeLits
12:50:03 <dmj`> dolio: GHC.TypeLits 
12:50:31 <monochrom> the type class is KnownSymbol. the instances are compiler-generated.
12:50:49 <monochrom> all in all this is just the compiler writing boilerplate code so you don't have to
12:51:12 <dolio> Yeah, you could define your own KnownSymbol and you could build it in kind *, although that'd be ugly.
12:51:21 <dolio> It's what people did years ago when doing this type of stuff, though.
12:51:27 <dolio> Because there were no other options.
12:51:44 <Wizek> http://softwarerecs.stackexchange.com/questions/25476/is-there-a-fuzzy-string-match-library-for-haskell
12:52:19 <monochrom> although strictly speaking it qualifies as "compiler magic", it is the most boring kind, at the mundane level of "deriving Eq". nothing fantastic is happening.
12:54:30 <dmj`> dolio, monochrom: ok I see, so KnownSymbol/KnownNat are how we get access to the value, but then why use Proxy at all ? 
12:54:44 <monochrom> again, Proxy is there just so that you don't have to use the ugly "undefined" and you don't have to be limited to the kind *
12:55:30 <dmj`> monochrom: Oh now it's starting to make sense, because Proxy is poly-kinded right
12:55:39 <monochrom> it is a phantom type so you can write a type somewhere
12:55:52 <monochrom> or rather, write a type annotation somewhere
12:56:52 <monochrom> because the syntax always requires type expressions to go to the RHS of "::". so you need some garbage to go on the LHS.
12:56:54 <dolio> dmj`: If you could explicitly apply to a type, then you wouldn't need it, and you could have 'forall s. KnownSymbol s => String'.
12:57:02 <monochrom> yes, I am saying "garbage"
12:57:19 <dolio> But that'd be a significant change from how things currently work.
12:58:34 <ReinH> monochrom: some "you know, whatever" on the LHS.
12:59:03 <dolio> That's why symbolVal doesn't even care what you use. It's a variable.
12:59:53 <ReinH> Wizek: googling yielded http://cdewaka.com/2013/06/fuzzy-pattern-matching-in-haskell/, but repeatedly posting a link without actually asking a question is bad form.
12:59:58 <monochrom> Proxy is user-definable.
13:00:26 <tsahyt> What kind of QuickCheck properties would I write to check the correctness of a parser?
13:00:50 * tsahyt is probably overthinking things again
13:01:21 <dolio> Generate pairs of well-formed input and corresponding output, and check that the parser generates the latter when given the former.
13:01:42 <Wizek> ReinH, After hitting enter I realized I posted it here before just forgot about it. I'm sad I did that. :( But and thanks for the link!
13:01:51 <monochrom> also pairs of ill-formed input and corresponding error
13:02:08 <dolio> Oh yeah, that's also a good idea.
13:02:41 <ReinH> Wizek: Which is to say: there probably isn't a library, which means you could probably write one and be the first person to publish a Haskell library for fuzzy search.
13:03:00 <dmj`> monochrom: so the poly-kindedness of Proxy is a convenience thing for working typeclasses that have instances of types other than * (i.e. like Symbol / Nat)
13:03:06 <dmj`> working with*
13:03:11 <ReinH> Wizek: Maybe you could even use an algorithm that didn't require regexp.
13:03:34 <Wizek> Yes, I was thinking of implementing it without regex actually 
13:03:39 <dolio> dmj`: Well, people also like it better than using undefined, even if the type has kind *.
13:04:32 <Wizek> ReinH, I've had fun with traversing text before letter by letter https://github.com/Wizek/dump/blob/master/src/Internal/Parser.hs#L13 :D
13:04:34 <dmj`> dolio: sure I see, since bottom has to be present on lifted types of kind *, but not Symbol/Nat, since those aren't lifted (heap allocated). 
13:05:01 <ReinH> Wizek: your parser type is lacking generality :)
13:05:06 <dolio> It's not that they aren't lifted. They don't have values.
13:05:09 <ReinH> @google seuss parser
13:05:11 <lambdabot> http://www.willamette.edu/~fruehr/haskell/seuss.html
13:05:11 <lambdabot> Title: Dr. Seuss on Parser Monads
13:05:42 <dolio> If `s :: Symbol`, `e :: s` is not a well formed typing annotation.
13:06:20 <dmj`> dolio: unless polykinds
13:06:20 <ReinH> Wizek: you might enjoy http://dev.stephendiehl.com/fun/002_parsers.html
13:06:34 <ReinH> Wizek: Which is a ground-up introduction to parsers of that style.
13:06:38 <dolio> Polykinds doesn't make a difference.
13:07:08 <dmj`> PolyKinds allow type Foo = ("hey" :: Symbol) ::: (3 :: Nat) ::: Foo, where data (path :: k) ::: rest, and data Foo
13:07:08 <dolio> `e :: 3` isn't something that ever works.
13:08:40 <dmj`> dolio: http://lpaste.net/142502#line21
13:09:22 <dolio> What about it?
13:09:48 <dolio> There is no `e :: "hello"` in there.
13:10:13 <crimsonSunrise> How much overhead does GHC add? I was kind of suprised to see that a simple 'Hello World' is 3 MB large in comparison to other compiled langauges.
13:10:16 <Wizek> You got me! :D I know it could be generalized. I have actually started out with using Parsec there, but couldn't make it work the way I would have liked it to. So I wrote those specific functions. I am not even sure I would call those parsers, because what they do is splitting strings in halves based on where an expression might end.
13:10:38 <Wizek> So it is more like trying to find a position inside a string 
13:10:58 <Wizek> but it doesn't build any kind of AST while it is 'parsing'
13:11:04 <Wizek> Would you still call that a parser?
13:11:43 <latro`a_> crimsonSunrise, the GHC RTS is not exactly tiny
13:12:20 <Wizek> here are some cases of how it is splitting strings in half: https://github.com/Wizek/dump/blob/master/spec/Spec.hs#L82
13:12:34 <Phyx-> crimsonSunrise: GHC currently defaults to static linking, which is why the final executables are so large
13:12:52 <Phyx-> crimsonSunrise: in contract to other languages, there is no "redistributables"
13:12:58 <dmj`> dolio: there's tpyes of different kinds in the same type def I suppose
13:13:32 <monochrom> crimsonSunrise: I think you have just measured the overhead. in there is, for example, a pretty advanced garbage collector.
13:13:58 <dolio> Right, but the point is that `3` at the type level doesn't have values. So there is no way you can have a function `natValue :: 3 -> Natural`.
13:14:01 <dmj`> s/tpyes/types
13:14:30 <dolio> Because 3 :: Nat. If you encoded 3 in types of kind *, you could, and you could pass it `undefined`, but since we're not hacking things up that way, it's not an option.
13:15:00 <dolio> It's not that `3` isn't "lifted" or "heap allocated" it's just not the sort of thing that can characterize values at all.
13:15:09 <hiptobecubic> Phyx-, that always confused me. It's 'static' wrt to GHC but not anything else
13:16:09 <monochrom> and a select/poll loop, and a green-thread scheduler, so that you write "getLine" and it looks like blocking to you, but under the hood it is efficient juggling of non-blocking I/O and threads
13:16:16 <dmj`> dolio: I see, yes, so Nat and Symbol are kinds of types w/ no inhabitants
13:16:52 <dolio> Right. And it's not just that they happen to be empty types. It is nonsensical to consider them having values in the first place.
13:17:31 <Phyx-> hiptobecubic: what do you mean wrt anything else? Haskell libraries are statically linked as well. at least the haskell parts. afaik
13:18:10 <dolio> monochrom: Also a separate scheduler for speculative parallelism, I think. And a transactional memory implementation, and ....
13:19:51 <sicasal> hello 
13:19:58 <sicasal> i already solve the problem
13:20:07 <hiptobecubic> Phyx-, right, but everything else is not. libgmp, libpthread, libpcre....  When you stay "it's statically linked" most people assume you mean it is entirely statically linked, not partially
13:20:27 <clrnd> sicasal, woah that was fast
13:20:39 <dolio> dmj`: It's like the difference between `exists x. x in {}` being false, and `exists x. x in 3` being nonsense (or at least, that's the way some people wish things were).
13:21:30 <sicasal> http://lpaste.net/142490
13:22:12 <sicasal> i just have one question i dont know how to give a signature to the fuction it always give me error when i use :t divisores and use the types there
13:23:20 <dmj`> dolio: I see, it makes sense 3 has no values. Reading the source of KnownSymbol and KnownNat classes makes it all clearer how the "magic" happens.  
13:23:38 <tsahyt> :t sum[x|x<-[1..n],n`mod`x==0,n/=x,even x]==n
13:23:39 <lambdabot> Bool
13:23:45 <tsahyt> :t \n -> sum[x|x<-[1..n],n`mod`x==0,n/=x,even x]==n
13:23:46 <lambdabot> Integral a => a -> Bool
13:23:48 <Phyx-> hiptobecubic: Right, when I say GHC is staticaly linked I mean just the RTS+Dependencies. Any external libraries you use from a library etc depends entirely on how the library is written of course.. 
13:24:08 <sicasal> i use that same type and give me error when i run the function
13:24:09 <tsahyt> sicasal: What error do you get?
13:24:51 <dmj`> dolio: interesting how PolyKinds allows types of Kind Symbol and * to be created together, but not types of kind '#' (unlifted), that's why I was led to believe Symbol was heap allocated (even though its not because types of kind Symbol have no values). 
13:25:18 <sicasal> i put Integral a ->a->Bool
13:25:24 <dolio> Yeah, # is pretty weird.
13:25:24 <sicasal> i didnt put =
13:25:36 <tsahyt> Well there's your problem
13:25:59 <dolio> dmj`: I guess the reason that # is different is that you're not allowed to do polymorphism over it.
13:26:02 <ReinH> sicasal: for the love of god, use spaces.
13:26:32 <sicasal> where ?
13:26:34 <dolio> So there are a bunch of cases it's rules out, even if it might make sense to use the types of its kind formally.
13:26:36 <ReinH> everywhere
13:26:52 <sicasal> ok sorry
13:27:10 <ReinH> sum[x|x<-[1..n],n`mod`x==0,n/=x,even x]==n vs. sum [x | x <- [1..n], n `mod` x == 0, n /= x, even x] == n
13:27:38 <arkeet> why n /= x when you can just take from [1..n-1]
13:27:54 <sicasal> yes thats a good one 
13:28:27 <sicasal> sorry ReinH i use for now on
13:28:36 <tsahyt> sicasal: You can get rid of the even check too, when you take x from [2,4..n-1]
13:29:14 <dmj`> dolio: makes sense, should call it {-# PolyKindsExceptUnboxed #-}
13:29:25 <sicasal> it is another i am calling unnecessarily
13:30:59 <dmj`> dolio, monochrom: thanks for the help !
13:33:36 <Gurkenglas> I can't build ghc-mod on my Windows 10 host because old-time doesn't build, I can't build ghc-mod on my guest xubuntu 14.04 because ghc-paths doesn't build. Can someone recommend a vm image for Haskell programming?
13:34:04 <sinelaw> Gurkenglas: have you tried stack? 
13:34:28 <ReinH> Gurkenglas: why doesn't ghc-paths build? What version of ghc?
13:34:31 <Gurkenglas> sinelaw, yes, I even only tried stack on the vm because the proceedings seemed identical
13:35:07 <Gurkenglas> ReinH, what stack command will tell me what you want to know?
13:35:18 <ReinH> Gurkenglas: ghc --version
13:35:34 <ReinH> and, presumably, stack install ghc-paths
13:35:39 <blaird> Hey, has anyone here done program profiling before? I'm trying to get a memory profile of a few programs and check their speed.
13:36:18 <ReinH> stack ghc -- --version if you don't have ghc in path
13:36:35 <ReinH> blaird: What's your question?
13:37:14 <blaird> What do I add to -> "time ./$algo +RTS -hc -p" to get more informative output?
13:37:41 <blaird> I ran it, and I'm using hp2pretty to create a graph, but the graph turned out empty
13:37:57 <cocreature> probably missing -fprof-auto or something like that
13:38:13 <Gurkenglas> ReinH, http://pastebin.com/9qjma4yX . Shall I run "sudo apt-get install ghc"?
13:38:21 <ReinH> No.
13:38:32 <ReinH> Gurkenglas: As I said, stack ghc -- --version.
13:38:42 <Gurkenglas> <ReinH> Gurkenglas: ghc --version
13:38:48 <Gurkenglas> whoops nvm
13:39:22 <Gurkenglas> ReinH, 7.10.2
13:39:53 <ReinH> blaird: See http://neilmitchell.blogspot.com/2013/02/chasing-space-leak-in-shake.html, use criterion to benchmark.
13:40:03 <Gurkenglas> (The binpaste seems to mention 7.10.2 lotsa times)
13:40:23 <ReinH> blaird: See also https://skillsmatter.com/skillscasts/5466-bryan-o-sullivan
13:40:34 <ReinH> Gurkenglas: try installing ghc-path separately
13:40:53 <Gurkenglas> How? stack install ghc-paths? That's in the binpaste
13:41:12 <blaird> ReinH: Thanks! I'll read throgh these
13:41:49 <sicasal> how can i use comentaries in haskell like in java it is // commentary / ?
13:42:08 <tsahyt> sicasal: -- for line comments, {- ... -} for multi ine
13:42:10 <tsahyt> line*
13:42:29 <sicasal> tks tsahyt
13:42:47 <ReinH> (The convention seems to be to use -- for multi-line comments anyway, especially for haddocks)
13:42:52 <sinelaw> Gurkenglas: I'm on ubuntu 14.04, managed to install using stack after adding to ~/.stack/global/stack.yaml
13:42:53 <sinelaw> extra-deps:
13:42:53 <sinelaw> - cabal-helper-0.6.1.0
13:43:23 <ReinH> Gurkenglas: perhaps you need to apt-get install libtinfo-dev? I'm unsure.
13:43:48 <sicasal> i am just using a line for explaining each fuction
13:44:19 <Gurkenglas> https://gyazo.com/243b4286d267a7fc56b2cee93c8870ba ReinH, seems to be installed but I'll run your command
13:44:48 <tsahyt> sicasal: You might want to look at haddock and get the hang of the syntax now, so you can generate documentation from your code later
13:45:06 <tsahyt> sicasal: https://www.haskell.org/haddock/doc/html/index.html
13:45:26 <sicasal> ok i will check it out
13:45:53 <Gurkenglas> Woo ghc-paths builds, thanks ReinH!
13:46:13 <ReinH> Woo.
13:47:15 <tsahyt> I've got an AST and I'd like to render it back into the source language. Is the pretty package the right way to go at this?
13:47:40 <Gurkenglas> How'd you go from "<command line>: can't load .so/.DLL for: libtinfo.so (libtinfo.so: cannot open shared object file: No such file or directory)" to "apt-get install libtinfo-dev"?
13:47:54 <clrnd> tsahyt, pretty is for prettyness, it has combinators for formatting text in terminals
13:47:57 <Gurkenglas> ("discard .so, add -dev"?)
13:47:58 <clrnd> mostly spaces and the like
13:48:06 <clrnd> tables, vcat, etc
13:49:58 <tsahyt> Isn't source code formatting a kind of pretty printing?
13:51:20 <tsahyt> haskell-src-exts seems to use pretty for it for example
13:51:42 <tsahyt> Well at least it has a dependency on it for some reason
13:52:00 <clrnd> I think first you need to show your language, then pretty it, maybe I'm just exaggerating
13:53:17 <Gurkenglas> Aaaand fails on text. Shall I give the vm more memory? http://pastebin.com/jxtSEVBG
13:54:07 <Cale> Well, you probably want the show instance to display Haskell data structures
13:54:42 <Cale> and yes, I think pretty is the sort of library you're looking for if you want to render ASTs back into the source language
13:54:51 <Cale> Also consider wl-pprint
13:55:12 <sinelaw> or ansi-wl-pprint
13:55:25 <sinelaw> which is more actively maintained (I hope)
13:55:41 <sinelaw> (plus, supports colors)
13:55:41 <tsahyt> What's the difference between all those packages?
13:57:03 <sinelaw> tsahyt: http://stackoverflow.com/questions/9761507/which-pretty-print-library
13:57:17 * hackagebot hlatex 0.3.1 - A library to build valid LaTeX files  https://hackage.haskell.org/package/hlatex-0.3.1 (NicolasPouillard)
13:57:19 * hackagebot http-api-data 0.1.1 - Converting to/from HTTP API data like URL pieces, headers and query parameters.  https://hackage.haskell.org/package/http-api-data-0.1.1 (NickolayKudasov)
13:57:40 <sicasal> i have to do a function that does Bool->Integer i made a simple one f x = if  x  ==100 then 1 else 0 but it gives me error 
13:58:20 <Cale> http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf talks about the differences between wl-pprint and the earlier design used in pretty
13:58:23 <tremon> sicasal: you can't compare Bool to 100
13:59:09 <sicasal> i thought that was the commparing of the two was bool 
13:59:17 <sicasal> and then give me a integer
13:59:19 <Cale> Basically, wl-pprint is designed to satisfy nicer algebraic laws.
14:00:30 <Cale> So one might hope it's a little easier to work with, but I'm not sure if it's such a big deal in practice, I haven't written anything too huge with either of them.
14:01:03 <Gurkenglas> text builds given 2gb instead of the previous 512mb of ram
14:02:06 <tsahyt> Considering that pretty much every line I'm printing is simple and of the form <ident> = <expression>, I don't think it'll make that much of a difference. I just thought I might as well look into those libraries now.
14:02:40 <sicasal> a fuction that does this :: Ord t =>[t] −> t −> Bool
14:02:48 <sicasal> what means Ord ?
14:03:26 <dmj`> sicasal: Ord is a typeclass, meant for values that can be ordered
14:03:30 <Cale> That (Ord t) is a constraint saying that the type t needs to support the ordering comparison operations such as (<) and (>=)
14:04:16 <sicasal> so a fuction that does that is a simple comparing of numbers if x <100
14:04:23 <tremon> sicasal: The result of the operation (x == 100) is a Bool, yes, but your input x is not Bool. Or if it is, the operation x==100 is invalid
14:06:50 <Gurkenglas> Can I make stack parallelize the installing of multiple dependencies at once? Because this is taking a while and maxing out one of my 4 cores
14:06:59 <sicasal> so Ord t =>[t]-> t ->Bool 
14:07:45 <sicasal> i cannot use f x = elem x [2,4..100] ==24
14:08:18 <sinelaw> Gurkenglas: try -j
14:09:56 <srhb> sicasal: The result of elem x [..] is a Bool
14:10:11 <srhb> sicasal: (==) takes two Ord'erable arguments of the same type.
14:10:22 <srhb> sicasal: Bool and Num a (24) are not the same type.
14:10:22 <sicasal> yes i dont need that 
14:10:41 <sicasal> but i am tryng to understand what the fuction receives
14:10:50 <srhb> sicasal: Which function?
14:11:09 <sicasal> i have to make a fuction that have this signature
14:11:16 <sicasal> so Ord t =>[t]-> t ->Bool 
14:11:44 <srhb> sicasal: So a list of values of type `t` that implements the Ord class, a single value of type `t` and returns Bool
14:11:47 <sicasal> receives a list then transform in a number and then bool
14:11:55 <srhb> sicasal: No, that's not what it means.
14:12:20 <srhb> sicasal: A function that checks if all elements in a list are equal to some value would have that signature.
14:12:43 * hackagebot http-api-data 0.1.1.1 - Converting to/from HTTP API data like URL pieces, headers and query parameters.  https://hackage.haskell.org/package/http-api-data-0.1.1.1 (NickolayKudasov)
14:13:05 <jstimpfle> sicalsal, [t] -> t -> Bool means really [t] -> (t -> Bool) because of right associativity of (->)
14:13:10 <sicasal> so it cannot be compare(head xs)
14:13:13 <Cale> It's possible to think of it as taking (a list of values of type t), and producing (a function which given a single value of type t will produce a Bool). However, if that's confusing to you, you may ignore it.
14:13:15 <srhb> sicasal: `a -> b -> c` does not mean transform `a` to `b` to `c.` 
14:13:40 <sicasal> i thought that did that 
14:13:48 <Cale> You can instead think of it as a function which takes a list of values of type t, *and* a single value of type t, and produces a Bool
14:14:06 <srhb> It's a function that takes two arguments of type `a` and `b` respectively and returns a value of type `c`
14:14:08 <sicasal> can you give me a example 
14:14:08 <Cale> These two descriptions are actually the same thing in Haskell.
14:14:13 <Cale> Sure
14:14:16 <srhb> :t (++)
14:14:17 <lambdabot> [a] -> [a] -> [a]
14:14:26 <srhb> > "Foo" ++ "bar"
14:14:27 <lambdabot>  "Foobar"
14:14:29 <Cale> For example, we might want to check to see if the single element we got is less than all the elements in the list.
14:15:06 <Cale> lessThanAll [] v = True -- if there are no elements in the list, then v is trivially less than all of them
14:15:28 <aweinstock> :t \x -> [all (<x), any (<x), all (== x), any (== x)]
14:15:29 <Cale> lessThanAll (x:xs) v = v < x && lessThanAll xs v
14:15:29 <lambdabot> (Ord a, Foldable t) => a -> [t a -> Bool]
14:16:05 <Cale> So, in the recursive case there, we check to see if v is less than x, and whether v is less than all the elements in the tail of the list, xs
14:16:18 <crimsonSunrise> Is there a way to apply a function only to every other list element?
14:16:28 <Cale> Note, we could also just have written  lessThanAll xs v = all (v <) xs
14:16:42 <sicasal> so Ord t =>[t]-> t ->Bool  it could be [1,3,6]:5 
14:16:53 <Cale> hm?
14:17:01 <srhb> crimsonSunrise: zipWith ($) [const, f] ?
14:17:25 <Cale> sicasal: Could you elaborate what you mean? If I take it literally, [1,3,6]:5 is almost certainly a type error
14:17:30 <srhb> crimsonSunrise: er, cycle that list.
14:17:36 <aweinstock> > map snd . map (\(i,x) -> if even i then 100*x else x) $ zip [0..] [1..10] --crimsonSunrise
14:17:37 <lambdabot>      Could not deduce (Enum (a0, b))
14:17:37 <lambdabot>      from the context (Enum (a, b), Num (a, b))
14:17:37 <lambdabot>        bound by the inferred type for ‘e_11000110’:
14:17:45 <Cale> (that would be the list whose first element is [1,3,6], and whose tail is 5, but 5 is not usually a list.
14:17:52 <Cale> )
14:18:00 <crimsonSunrise> Without using map.
14:18:02 <srhb> > zipWith ($) (cycle [const, (*2)]) [1..20]
14:18:04 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ b -> a
14:18:04 <lambdabot>      Expected type: a -> b -> a
14:18:04 <lambdabot>        Actual type: a -> a
14:18:06 <srhb> grr
14:18:13 <srhb> > zipWith ($) (cycle [id, (*2)]) [1..20]
14:18:14 <lambdabot>  [1,4,3,8,5,12,7,16,9,20,11,24,13,28,15,32,17,36,19,40]
14:18:24 <sicasal> if i use :t head 
14:18:54 <sicasal>  [a]->a
14:19:05 <crimsonSunrise> I mean, I remember being able to apply operators on lists before. Can't do that for some reason.
14:19:13 <sicasal> now i compare that element with something
14:19:14 <crimsonSunrise> list elements rather.
14:19:40 <gganley> I'm trying to speed up an exhaustive search, I'm thinking of using parrelel processing. What is the usual way of going about speeding up things like that.
14:19:57 <srhb> crimsonSunrise: Are you asking how to write this combinator from scratch? Because if so, think about pattern matching on (x1:x2:xs)
14:19:57 <aweinstock> > (\f xs -> map (\(i,x) -> if even i then f x else x) $ zip [0..] xs) (*100) [0..10]
14:19:59 <lambdabot>  [0,1,200,3,400,5,600,7,800,9,1000]
14:20:48 <arkeet> aweinstock: use zipWith
14:21:07 <crimsonSunrise> srhb, I mean, the simplest I could come by is doing (x: xs * 2), but ghc doesn't like that. It's a list of numbers btw.
14:21:15 <aweinstock> > (\f xs -> zipWith (\ i x -> if even i then f x else x) [0..] xs) (*100) [0..10]
14:21:15 <arkeet> (\f xs -> zipWith ($) (cycle [f,id]) xs)
14:21:16 <lambdabot>  [0,1,200,3,400,5,600,7,800,9,1000]
14:21:18 <arkeet> er
14:21:19 <arkeet> [id,f]
14:21:22 <arkeet> no wait
14:21:24 <arkeet> [f,id]
14:21:45 <arkeet> > zipWith ($) (cycle [(*100),id]) [0..10]
14:21:46 <srhb> crimsonSunrise: mapeverysnd f (x1:x2:xs) = x1 : f x2 : mapeverysnd f xs ... -- and then the base pattern
14:21:47 <lambdabot>  [0,1,200,3,400,5,600,7,800,9,1000]
14:21:53 <Cale> sicasal: Yeah, you could compare the head of the list you're given with the single value you're given. You'll have to assume the list is nonempty that way -- if it's empty, then head [] will kill your program.
14:21:56 <srhb> crimsonSunrise: But see the zipWith solution given a few times now. :)
14:22:13 <sicasal> it is a list infinite
14:22:18 <arkeet> oh this solution was given above.
14:22:29 <sicasal> how can i use it 
14:22:51 <sicasal> f n = elem head [2,4..] ?
14:22:51 <aweinstock> > let mapOdd f = aux where {aux [] = []; aux (x:y:xs) = x : f x : aux xs; aux xs = xs} in mapOdd (*100) [1..5]
14:22:52 <lambdabot>  [1,100,3,300,5]
14:23:03 <sicasal> f n = elem n head [2,4..] ?
14:23:04 <aweinstock> err, mapEven? but same principle
14:23:51 <arkeet> > [1..5] & traversed . indices odd %~ (*100)
14:23:52 <lambdabot>      Couldn't match expected type ‘(Integer -> Identity Integer)
14:23:52 <lambdabot>                                    -> p0 Integer (Identity b)’
14:23:52 <lambdabot>                  with actual type ‘[i0]’
14:23:58 <arkeet> uh
14:24:07 <aweinstock> runIdentity?
14:24:17 <arkeet> no, shouldn't need that.
14:24:27 <aweinstock> :t (%~)
14:24:28 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
14:24:36 <shachaf> arkeet: Lens.indices hth
14:24:40 <arkeet> oh yeah.
14:24:42 <arkeet> I knew it.
14:24:46 <arkeet> > [1..5] & traversed . Lens.indices odd %~ (*100)
14:24:47 <aweinstock> I should probably learn lens at some point...
14:24:47 <lambdabot>  [1,200,3,400,5]
14:24:54 <arkeet> silly lambdabot.
14:25:00 <aweinstock> :t indices
14:25:01 <lambdabot> Ix i => Array i e -> [i]
14:26:10 <aweinstock> :t Lens.indices
14:26:11 <lambdabot> (Applicative f, Indexable i p) => (i -> Bool) -> Optical' p (Indexed i) f a a
14:26:41 <arkeet> it filters an indexed fold/traversal by index.
14:26:42 <aweinstock> are the lens types useful once you've learned a few of the typeclasses?
14:26:57 <srhb> aweinstock: Yes :)
14:27:00 <arkeet> you don't really need to know about the typeclasses.
14:27:05 <arkeet> to just use lens.
14:27:17 <srhb> aweinstock: They're not as completely unreadable as lens beginners imagine at times :P
14:27:37 <aweinstock> srhb: that's reassuring :)
14:27:43 <shachaf> The lens types are fine as long as you don't read them.
14:27:54 <aweinstock> that's slightly less so
14:28:13 <crimsonSunrise> srhb, I see. What if I have to do it starting from the right?
14:28:21 <srhb> crimsonSunrise: Then you're in trouble
14:28:45 <aweinstock> what do you mean by starting from the right?
14:28:46 <srhb> crimsonSunrise: You can reverse the list or decide whether to apply your function or id once you determine the list has an even or odd number of elements.
14:28:57 <srhb> aweinstock: every other element counting from the end.
14:29:02 <aweinstock> ah
14:29:19 <aweinstock> reverse . mapEveryOther . reverse
14:29:21 <crimsonSunrise> aweinstock, Like foldr, but only on every other element and without summing the list.
14:29:21 <srhb> crimsonSunrise: list is not the right kind of container for this issue.
14:29:36 <srhb> crimsonSunrise: lists have no concept of indices. They are singly linked.
14:30:03 <aweinstock> err, \f -> reverse . mapEveryOther f . reverse --but the same idea
14:30:12 <arkeet> reversing twice :x
14:30:50 <aweinstock> arkeet: the problem requires doing something starting from the *end* of a *linked list*, it's going to be inefficient anyway
14:31:02 <arkeet> but you don't have to reverse anything.
14:31:09 <aweinstock> (unless something fancy with continuations, maybe)
14:31:16 <arkeet> but it is something fancy.
14:31:31 <srhb> d3 = snd . foldr f (False, []) where f x (e, acc) = if e then (False, x*2 : acc) else (True, x : acc)
14:31:33 <srhb> whee
14:31:41 <srhb> (doubling every other)
14:32:13 <crimsonSunrise> Maybe I'm looking at it the wrong way by wanting to start from a list.
14:32:20 <srhb> Yes, you are.
14:32:26 <arkeet> oh, I did this before.
14:32:27 <aweinstock> > (\g xs -> snd . foldr f (False, []) where f x (e, acc) = if e then (False, f x : acc) else (True, x : acc)) (*100) [0..5]
14:32:29 <lambdabot>  <hint>:1:37: parse error on input ‘where’
14:32:33 <arkeet> http://lpaste.net/135551
14:32:44 <srhb> crimsonSunrise: Anything that involves "starting from the end" is probably not a good fit with list :)
14:32:46 <aweinstock> > (\g xs -> (snd . foldr f (False, []) where f x (e, acc) = if e then (False, f x : acc) else (True, x : acc))) (*100) [0..5]
14:32:47 <lambdabot>  <hint>:1:38: parse error on input ‘where’
14:32:59 <aweinstock> where clauses inside lambdas aren't valid?
14:33:01 <arkeet> this makes a single traversal through the list.
14:33:33 <srhb> arkeet: Hmm. Is that lazy pattern really necessary?
14:34:14 <arkeet> perhaps not.
14:34:47 <arkeet> well
14:34:51 <arkeet> it affects strictness.
14:34:59 <arkeet> I think.
14:35:03 <crimsonSunrise> So, evaluation from the right is not good for lazyness?
14:35:14 <arkeet> oh, maybe it doesn't matter.
14:35:17 <phaazon> hm
14:35:18 <srhb> crimsonSunrise: No, that's not the issue. The issue is that a list has no concept of "from the right"
14:35:27 <srhb> crimsonSunrise: There is only "this element" and "rest of list"
14:35:39 <phaazon> I’m looking for a way to make a parser loop so that it discards any character as long as another parser fails
14:35:44 <phaazon> I guess it’s something with manyTill
14:35:46 <srhb> crimsonSunrise: So even concluding if the number of list elements is even or odd requires a complete traversal.
14:36:05 <phaazon> like
14:36:14 <phaazon> manyTill (skip $ const True) endOfLine
14:36:24 <srhb> crimsonSunrise: You can't make a _decision_ on whether the first element should have f or id applied to it before you've traversed its entirity.
14:38:24 <srhb> crimsonSunrise: A more fitting type could be Sequence, for instance.
14:39:56 <srhb> crimsonSunrise: (Do note, we don't know exactly what you're trying. The solutions given here, including the double reverse, might be quite sufficient for some assignment-type problem.)
14:40:05 <srhb> Nevertheless it's good to know how it's dangerous. :)
14:40:08 <arkeet> perhaps a more fitting type would be a length-annotated list.
14:41:52 <crimsonSunrise> srhb, I'm giving a go at the CIS 194 Haskell course, since it's been a while since I used Haskell.
14:42:16 <sicasal> i dont know wich example i can have to have this signature :: Ord t =>[t] −> t −> Bool
14:42:18 <srhb> crimsonSunrise: I had a feeling. most people put up with either the double reverse, or the ones where the choice of id or f is deferred till the end is reached, in some manner.
14:42:39 <sicasal> anyone can give me a example of :: Ord t =>[t] −> t −> Bool
14:42:56 <arkeet> sicasal: there are many
14:43:20 <arkeet> srhb: or checking the parity of the length up front 
14:43:45 <crimsonSunrise> srhb, I mean, I know function composition and all this things, having read about half-ish of LAYH. But, I still can't seem to translate the logic into working code.
14:43:50 <sicasal> can you give me one arkeet
14:43:53 <Axman6> > let f :: Ord t => [t] -> t -> Bool; f _ _ = False in f [1,2,3] 4
14:43:54 <lambdabot>  False
14:44:36 <srhb> crimsonSunrise: Well, the data type is fighting you. :-)
14:44:57 <srhb> crimsonSunrise: But really, the double reverse solution is quite simple. If you reverse it once, you only have to apply to every second element.
14:45:21 <srhb> crimsonSunrise: That reduces it to the zipWith solution, or the manual pattern matching one with mapEverySnd (x1:x2:xs) = ...
14:46:06 <phaazon> *Codec.Wavefront.Token> tokenize "# prout\nv 3 1 3\n#    weeeee?"
14:46:06 <phaazon> Right [TknV (Location 3.0 1.0 3.0 1.0)]
14:46:08 <phaazon> finally.
14:46:08 <phaazon> :D
15:06:24 <dmj`> dolio: ping
15:15:19 <koshmar> I am following learnyourhaskell.com , and stuck on state monad
15:15:37 <koshmar> Is it gone somewhere?
15:16:48 <koshmar> compiler is printinf that there is no data constructor: State
15:17:06 <shachaf> Try "state" instead of "State".
15:17:22 <shachaf> (But, in the future, show full code and full error message.)
15:20:20 <koshmar> here is a code with an error http://paste.ofcode.org/65SesJhzmf2rDC5pPKcvFC
15:20:49 <koshmar> state did not work and StateT did not as well
15:21:13 <shachaf> Replace "State" in the lines that have errors with "state".
15:21:51 <koshmar> of I see. thanks
15:22:16 <koshmar> before I replaced everywhere.
15:22:56 <shachaf> And "did not work" is not a useful thing to say.
15:23:10 <shachaf> You changed it and you got new, different errors.
15:24:01 <jhance> I have a one-year old installation of cabal that can no longer cabal-update, was there something backwards-incompatible? [it hangs on downloading the package list]
15:24:11 <jhance> that or its just really slow because 1 year...
15:24:28 <srhb> jhance: There was a bug in an old cabal-install that would make it really, really slow, afair.
15:25:14 <geekosaur> yes
15:25:17 <jhance> Alright I'll try bootstrapping to a later version then
15:30:43 <aweinstock> srhb: was that the "accidentally quadratic" thing?
15:31:15 <c_wraith> It was 
15:32:43 <Gurkenglas> Is there a oneliner to install all things haskell on ubuntu 14.04?
15:34:18 <acowley> /join #haskell-blah
15:34:19 <acowley>  
15:34:22 <acowley> oy
15:34:26 <dmj`> Gurkenglas: sudo apt-get install ghc cabal-install ? 
15:36:04 <Gurkenglas> When I tried sudo apt-get install ghc to get me ghc-pkg which cabal said was missing it afterwards said "cabal: Version mismatch between ghc and ghc-pkg: /usr/local/bin/ghc is version
15:36:04 <Gurkenglas> 7.10.2 /usr/bin/ghc-pkg is version 7.6.3
15:36:04 <Gurkenglas> " so Im guessing the apt-get install thing is deprecated?
15:36:08 <Gurkenglas> *dmj'
15:37:51 <Gurkenglas> *dmj`
15:38:30 <dmj`> Gurkenglas: seems like it, I'd just wget ghc and cabal-install directly from their websites, w/ ghc you have to do the ./configure, make, make install dance I think, cabal is just a binary
15:38:48 <dmj`> Gurkenglas: https://www.haskell.org/cabal/download.html
15:39:33 <Welkin> cabal-install has bootstrap.sh
15:39:48 <dmj`> Gurkenglas: https://www.haskell.org/ghc/download_ghc_7_10_2#x86_64linux
15:40:16 <dmj`> tar -xJf *.xz
15:42:45 <akfp> what's the command to just download and build a package from hackage or stackage using stack?
15:43:10 <Gurkenglas> "stack install packagename"
15:44:10 <Gurkenglas> Welkin, what command do I run for that, and where?
15:44:40 <Gurkenglas> dmj`, which of those do I use, the centos one or the debian one? I'm on xubuntu 14.04
15:44:44 <akfp> Gurkenglas: thanks! I was looking under build :-)
15:44:46 <Gurkenglas> (the guest is, that is)
15:45:47 <Welkin> Gurkenglas: it's just a binary /.bootstrap.sh
15:45:56 <Welkin> it comes with a README that tells you how to install it
15:46:09 <Gurkenglas> Welkin, in what folder is that?
15:46:24 <Welkin> somewhere in the cabal-install package
15:53:58 <Gurkenglas> Welkin, in what folder is the cabal-install package?
15:54:38 <Welkin> the thing you just downloaded
15:55:01 <Welkin> https://www.haskell.org/cabal/download.html
16:00:38 <Gurkenglas> Welkin, https://www.haskell.org/cabal/release/cabal-install-1.22.0.0/cabal-1.22.0.0-i386-unknown-linux.tar.gz contains only a file named cabal, no readme
16:00:46 <Gurkenglas> Which thing am I supposed to download?
16:01:11 <Welkin> cabal-install tool (version 1.22.6.0)
16:04:11 <phaazon> hm
16:04:33 <phaazon> is there a good structure that grows quickly (in terms of allocation) and that provide random access?
16:04:46 <Gurkenglas> I guess I need to do the ghc part before the bootstrap.sh part?
16:04:48 <phaazon> I guess Vector, but I’m not sure it provides good allocation schemes
16:05:44 <Gurkenglas> Man I thought installing this on Linux would be easy because everyone pitied me for using it on Windows but its such a mess of command lines
16:06:10 <RDB303> random comment but anyone think this is equivalent to forward piping a Maybe, although ugly "int? r; bool throwAway = (r = 8).HasValue && (r = r * r).HasValue && (r = r * 2).HasValue;"
16:06:13 <phaazon> what are you trying to install, Gurkenglas?
16:06:54 <RDB303> I'm by nature a workaround type of person and saw a video 10 things F# can do C# can't and thought I just had to find a way
16:06:58 <Gurkenglas> phaazon, I think ghc and ghc-pkg and cabal-install and stuff because atom said that cabal couldn't build the project i had without ghc-pkg
16:07:18 <phaazon> Gurkenglas: atom lags behind
16:07:32 <phaazon> I guess it won’t work with the latest ghc version
16:07:40 <phaazon> so don’t put too much effort into it right now
16:07:46 <phaazon> just use a good editor
16:07:49 <phaazon> use neo-vim.
16:07:51 <phaazon> :D
16:07:58 <phaazon> (troll time, promised I’m done)
16:08:04 <Gurkenglas> I tried vim once and ran away once I saw the controls
16:08:19 <phaazon> the modal controls rock, Gurkenglas 
16:08:25 <phaazon> that’s #haskell is no place to discuss that
16:08:29 <phaazon> but*
16:08:52 <Gurkenglas> apt-get install ghc apparently installed an old version and apt-get purge ghc apparently deinstalled half the stuff I managed to get working before that
16:17:33 <dolio> dmj`: Yes?
16:20:29 <Gurkenglas> dmj`, https://gyazo.com/96445ad80695c54bea96418d187053de how do i do that "./configure, make, make install" thing?
16:21:45 <tesrty> Gurkenglas: write it in terminal generally
16:21:58 <tesrty> but I'm on linux
16:22:19 <tesrty> I would just write those three, one by one, and hit return after each.
16:22:29 <Gurkenglas> tesrty, I did the first one in the screenshot
16:22:36 <jstimpfle> gurkenglas: seems your configure don't have x(ecute) bit
16:22:39 <Gurkenglas> (the gyazo link)
16:23:00 <Gurkenglas> jstimpfle, for someone who just came to linux to build some packages that wont build on windows pls
16:23:32 <tesrty> yea. you can write 'sudo sh configure' if you like.
16:23:36 <tesrty> that would probably work
16:24:09 <Gurkenglas> tesrty, http://pastebin.com/eyc9Tpd9
16:24:12 <tesrty> you can also 'chmod +x ./configure' first. then './configure'
16:24:41 <tesrty> hmm. try setting the excutable bit like jstimpfle suggested.
16:24:45 <tesrty> its the chmod thing
16:25:03 <Gurkenglas> http://pastebin.com/PXQsy7PS
16:25:49 <c_wraith> Looks like you may have previously run configure as root. 
16:26:15 <Gurkenglas> i did, the gyazo link shows it
16:26:22 <c_wraith> I'd just wipe the source dir entirely and start from scratch 
16:26:28 <tesrty> yea. find the config.log and remove it.
16:26:39 <tesrty> or wipe. that is easier. and more likely to werk
16:26:41 <tesrty> *work
16:27:32 <tesrty> you should generally never run scripts you don't know as root. proper scripts will ask for root if they need it. only use 'chmod +x'. before I learn you bad things ;]
16:28:19 <c_wraith> Running build tools as root usually screws things up even if nothing malicious is going on. 
16:28:52 <tesrty> although you'll probably need it at the 'make install' step.
16:29:08 <c_wraith> The main exception is 'make install' 
16:29:10 <Gurkenglas> Deleted the ghc-7.10.2 folder, reextracted it from the archive, http://pastebin.com/uu0Xz3Ye
16:29:15 <phaazon> is there a way to make a Vector (non-mutable) grow?
16:29:18 <phaazon> like std::vector?
16:29:37 <phaazon> I’d like to add element and have a logarithmic memory allocation scheme
16:29:39 <Axman6> how does that make any sense?
16:29:41 <c_wraith> Well, not like that. It's not mutable. 
16:29:42 <jstimpfle> why grow if it's not mutable?
16:29:42 <Gurkenglas> (didn't need to take the terminal out of that folder.)
16:30:03 <phaazon> jstimpfle: ?
16:30:15 <phaazon> everything is immutable in haskell
16:30:16 <phaazon> like list
16:30:21 <Axman6> phaazon: what you're asking for doesn't make any sense
16:30:22 <phaazon> but, you can add element in list.
16:30:26 <phaazon> it does.
16:30:30 <phaazon> look at snoc
16:30:43 <Axman6> that creates a while new vector
16:30:44 <phaazon> snoc adds an element to an immutable vector
16:30:45 <phaazon> yeah
16:30:50 <phaazon> that’s why I say “immutable”
16:31:13 <Welkin> Gurkenglas: it is very easy to install ghc and cabal-install from the binaries
16:31:20 <Welkin> just follow the instructions in each
16:31:32 <Welkin> for ghc it is just a configure and make install command
16:31:42 <Welkin> for cabal-install you just run the bootstrap.sh file
16:31:44 <Welkin> in that order
16:32:00 <Axman6> phaazon: what exactly do you want to do?
16:32:13 <Axman6> because your question isn't making any sense
16:32:34 <c_wraith> phaazon: the thing is, exponential growth of a vector only makes sense if the structure is mutable. If it's immutable, you can't use the empty space. 
16:32:48 <Gurkenglas> Welkin, extracted a folder ghc-7.10.2 from an archive, went in it with a terminal, http://pastebin.com/uu0Xz3Ye
16:32:50 <phaazon> Axman6: I’m looking for a pure structure that wouldn’t destroy the heap as I add elements in there (a lot of them) and still have random access
16:33:17 <c_wraith> phaazon: have you considered mutable vectors? 
16:33:20 <Axman6> take a look at Seq
16:33:29 <phaazon> Axman6: Seq doesn’t provide random access in O(1).
16:33:31 <phaazon> c_wraith: yeah
16:33:37 <phaazon> but they’re mutable…
16:33:45 <Welkin> Gurkenglas: type ls -la
16:34:02 <Axman6> phaazon: no, but no immutable structure offers what you want without at least some O(n) operations
16:34:25 <jstimpfle> Axman6: more O(log n) I guess
16:34:26 <phaazon> well, random access can be performed in O(1), and that’s mandatory for what I’m doing
16:34:30 <c_wraith> phaazon: if you want behavior that only makes sense in terms of mutability, you probably need to accept mutability 
16:34:34 <phaazon> both the operation are mandatory actually
16:34:34 <Gurkenglas> Welkin, http://pastebin.com/HqLg6txr
16:34:36 <phaazon> operatinos*
16:35:01 <Welkin> Gurkenglas: configure has no execute permissions
16:35:05 <phaazon> c_wraith: that’s the part of Haskell that always make me think like “meh…” :)
16:35:10 <phaazon> makes*
16:35:13 <phaazon> dammit I need some sleep
16:35:50 <Welkin> sudo chmod 774 configure
16:35:57 <Welkin> then ./configure
16:36:08 <phaazon> ok then
16:36:17 <phaazon> I guess I’ll go with unboxed mutable vectors
16:36:24 <Gurkenglas> (rm -R on that folder from the one above it, reextract, go in there, http://pastebin.com/wVsLT56H )
16:36:47 <Axman6> phaazon: why do you think that O(1) access is necessary btw?
16:36:56 <Gurkenglas> http://pastebin.com/x4sP2yXn
16:37:13 <phaazon> because I’m parsing huge files (~10 Mo on a minimum-basis) that require a lot of index lookups
16:37:21 <Welkin> Gurkenglas: all your permissions are messed up
16:37:25 <Welkin> you don't have write permission to anything
16:37:27 <lpaste> Blair pasted “Profiling” at http://lpaste.net/142507
16:37:39 <Welkin> you have to fix the permissions for the directory too
16:37:44 <jstimpfle> phaazon: I guess i understand want you want: a vector where you don't change any given _element_ once you have written it.
16:37:45 <Welkin> I have never run into that problem when installing ghc
16:38:01 <Gurkenglas> I am proud. Teamviewer?
16:38:11 <phaazon> jstimpfle: I don’t really know about that property
16:38:16 <Welkin> or you really have run out of space
16:38:17 <Welkin> lol
16:38:18 <Welkin> virtual box
16:38:22 <phaazon> I just need to collect values and index them as I iterate over the file
16:38:25 <blaird> Hey, I think I'm being an idiot, but anyone know why my .hp files come out with no info? My .proc files are good, but I'm trying to make some graphs
16:38:35 <phaazon> keeping the memory allocation frequency as low as possible
16:38:36 <jstimpfle> phaazon: but that is not immutability _of the vector_. only of the elements.
16:38:46 <phaazon> otherwise I’ll end up with poor performance
16:38:49 <Axman6> blaird: how is the program exiting?
16:38:57 <Gurkenglas> Out of... RAM? hard disc space?
16:39:10 <Axman6> phaazon: stop prematurely optimising
16:39:15 <phaazon> I’m not
16:39:18 <phaazon> I know that problem
16:39:20 <Axman6> make it work first
16:39:24 <Gurkenglas> Windows Task Manager doesnt point fingers at vbox
16:39:27 <phaazon> it’s not the first time I do that…
16:39:37 <phaazon> I already had problem with that in C++ with Boost
16:39:41 <Axman6> is it the first time you've done it in Haskell?
16:39:47 <blaird> Axman6: The shell script? It loops over a few programs, compiles and does that, then cleans up a few files
16:39:48 <phaazon> I’m pretty sure I’ll have issue with Haskell as well
16:40:01 <phaazon> Axman6: Haskell is poor in terms of memory managing
16:40:03 <Welkin> Gurkenglas: I think it is a permissions problem
16:40:16 <Axman6> phaazon: it's really not, if you know what you're doing
16:40:20 <jstimpfle> phaazon: i think you will need starray or ioarray
16:40:28 <blaird> Axman6: By "cleans up", I mean removes the .o and .hi files and stuff
16:40:34 <phaazon> Axman6: ?
16:40:41 <phaazon> what is that argument?
16:40:55 <Gurkenglas> Welkin, connect to my Windows via Teamviewer?
16:40:58 <phaazon> Haskell was not designed to be a language with manual memory handling
16:41:02 <jstimpfle> it's not so bad. Don't prematurely optimize in terms of type safety, either.
16:41:10 <phaazon> that’s why we often destroy our stacks
16:41:10 <Welkin> Gurkenglas: no idea what that is
16:41:12 <phaazon> or heaps
16:41:25 <Axman6> GHC has incredibly efficient memory allocation, but it can be easy to write poor programs which have bad memory usage patterns
16:41:28 <phaazon> we have to be very careful about that, and that’s why I’m already thinking that problem
16:41:34 <Gurkenglas> It allows you to remotely control my pc through a window, as if you were running me in a vm
16:41:42 <jstimpfle> you can still have bounds checking etc
16:42:33 <phaazon> Axman6: the issue is actually simple: given a file to parse, you need to grow a vector each time you read a line ; how do you do that without destroying the alloc frequency? A good thing to do is to grow the vector quickly and force it when you’ve done reading the file
16:42:39 <phaazon> if you allocate something at each line
16:42:43 <Axman6> phaazon: you're approaching it from the wrong way though - write the most obvious thing that works, then make it efficient. doing anything else is a waste of time because you don't actually know where the problems will be
16:42:47 <phaazon> a 1Go file will destroy your performance for sure
16:43:26 <Axman6> I deal with multi GB files daily in haskell and don't do anything special to deal with memory usage.
16:43:48 <phaazon> yeah sure.
16:43:57 <phaazon> « I use plain old lists and everything is magically fast »
16:43:59 <phaazon> come on.
16:44:14 <Welkin> immutable data means that garbage collection is very efficient
16:44:14 <Axman6> actually, in the most recent case, yes, that's exactly what we did
16:44:28 <Axman6> runs in constant memory, less than 1MB
16:44:48 <Gurkenglas> I'll restart the vm and see if that helps
16:44:54 <phaazon> that depends on what you do with your gigs
16:45:08 <Axman6> yes, of course
16:45:09 <phaazon> but trying to build up the whole thing in memory through lists would be a mess haha
16:45:14 <Welkin> Gurkenglas: or just sudo ./configure
16:45:19 <phaazon> folding is pretty fast, yeah.
16:45:22 <phaazon> collecting is not
16:45:26 <ReinH> Doing bad things is bad.
16:45:36 <phaazon> ReinH: very good point
16:45:47 <Adeon> I've memory mapped huge files to Bytestrings but my problem allowed me to do that and didn't need much else
16:45:54 <Gurkenglas> Welkin, tesrty says not to
16:46:02 <shachaf> If there's an issue at all.
16:46:06 <Welkin> Gurkenglas: this is the official ghc package
16:46:17 <Axman6> but you're acting like you're an expert in how to write efficient haskell programs without any evidence that what you're trying to do is beneficial. we've all been where you are, and most of us have learned from our mistakes from trying to optimise things which don't need to be
16:46:42 <phaazon> Axman6: sure
16:46:45 <phaazon> I can relate
16:46:47 <phaazon> but in my case
16:46:55 <phaazon> I’m pretty sure I’ll have performance issues
16:47:00 <phaazon> because that seems logical
16:47:06 <Jinxit> come back when you do, I'm sure people will help
16:47:06 <phaazon> I want to collect gigs of memory
16:47:10 <phaazon> and index it as I go
16:47:15 <phaazon> I’ll obviously have issues
16:47:19 <Welkin> phaazon: use pipes
16:47:20 <Axman6> what do you mean by index it?
16:47:31 <Welkin> use a database
16:47:42 <Jinxit> some sort of dictionary?
16:47:47 <phaazon> Axman6: well, I’m parsing a file
16:47:51 <phaazon> I need to store values as they come
16:47:54 <phaazon> and sometimes
16:48:02 <phaazon> I need to lookup the values I’ve already read
16:48:05 <jstimpfle> phaazon: is parsing the whole file into a list, then building an immutable array from that possible?
16:48:06 <phaazon> to complete a special value
16:48:13 <Welkin> so, streaming data
16:48:23 <phaazon> Welkin: not streaming
16:48:35 <phaazon> I really need to collect the whole file in memory at once
16:48:39 <phaazon> there’s no streaming possible
16:49:44 <Gurkenglas> pressing tab to autocomplete also produces such an error http://pastebin.com/c8YN7Vxm
16:49:52 <phaazon> I’m not sure streaming is possible
16:49:54 <Adeon> can you use a mutable map while streaming and then immutabilize it for whatever then consumes your results at the end
16:50:00 <Adeon> or is that not the problem
16:50:01 <Gurkenglas> It did so too before the restart, and didnt after the restart until i did chmod +x ./configure
16:50:09 <phaazon> because I need to upload that to GPU then
16:50:41 <phaazon> or, I could just collecting everything in lists
16:50:48 <phaazon> and to the lookups afterwhile
16:51:02 <phaazon> by putting the lists in immutable Vector
16:51:08 <phaazon> collect*
16:51:10 <phaazon> dammit
16:51:12 <Gurkenglas> (Oh hey I didnt actually give it those privileges, that command failed)
16:51:15 <phaazon> yeah, I’ll do that tomorrow
16:51:17 <phaazon> good night
16:51:21 <jstimpfle> that would only be something like 2 tiems overhead...
16:51:25 <Welkin> Gurkenglas: yes, I know
16:51:34 <Welkin> ./configure is the command to *run* the file
16:51:38 <Welkin> onfigure is the name of the file
16:51:42 <Welkin> configure*
16:52:20 <sLite> anybody using intellij for haskell development?
16:52:25 <phaazon> jstimpfle: the way to do that in C (not C++)
16:52:31 <phaazon> is to perform a first fast read of the file
16:52:37 <phaazon> to count how many lines they are
16:52:44 <phaazon> then, allocate a big array
16:52:53 <phaazon> and collect them afterwards
16:53:04 <phaazon> there are
16:53:05 <phaazon> ok
16:53:08 <phaazon> I’ll just stop there
16:53:09 <Welkin> phaazon: or just use an IntMap
16:53:12 <phaazon> night.
16:53:14 <jstimpfle> yeah, i like these kinds of low level IO
16:53:23 <phaazon> jstimpfle: I hate that :D
16:53:44 <jstimpfle> night
16:54:04 <Gurkenglas> "<Welkin> Gurkenglas: yes, I know" <- in response to what line is that?
16:54:36 <RouxTheD1> l3
16:54:38 <Welkin> Gurkenglas: that you never set the permissions properly
16:55:08 <Gurkenglas> I didnt give it to them on that last time after the restart
16:55:29 <Gurkenglas> previous pastes show that i did i think
17:02:14 <blaird> Anyone have any idea why my profiling isn't working? Is my data just so neglibly small that I can't even see it in a graph? Or am I missing some dependencies for heap profiling or something?
17:02:50 <blaird> I'm on arch, so it's very possible that normal packages aren't installed
17:03:47 <Axman6> the binary should complain if it can't do heap profiling. maybe change the frequency it examines the heap?
17:03:59 <Axman6> foo +RTS --help will tell you how
17:04:25 <Gurkenglas> Welkin, http://pastebin.ca/3184770
17:04:41 <blaird> Well what's weird is that it isn't complaining, the .hp and .prof files show up, but nothing is in my graph
17:04:42 <davean> blaird: did it actually do a GC?
17:04:55 <davean> blaird: did the program terminate normally?
17:05:09 <blaird> Yep, program terminated as it was supposed to
17:05:13 <Axman6> the profile won't be written if the program doesn't exit cleanly
17:05:16 <Gurkenglas> Oh right, someone said something about me needing to use "sh " instead of "./"
17:05:21 <Axman6> how long does it run for?
17:05:25 <davean> blaird: and the first question?
17:05:30 <blaird> Oh yeah? I'll try the sh thing
17:05:31 <Gurkenglas> Welkin, http://pastebin.ca/3184773
17:05:42 <Axman6> the sh thing isn't for you blaird 
17:05:49 <blaird> davean: What do you mean by GC?
17:05:58 <Axman6> garbage collection
17:06:05 <blaird> Oh, ok. and it runs for fractions of a second
17:06:28 <blaird> real 0m0.036
17:06:41 <Axman6> it probably never runs the GC
17:06:57 <Welkin> Gurkenglas: does it exist?
17:07:10 <Gurkenglas> Welkin, my second to last paste includes an ls
17:07:18 <Gurkenglas> (This also doesn't work: http://pastebin.ca/3184774 )
17:08:31 <blaird> Hmm, ok. I'll running the program on more data
17:09:14 <Axman6> more data is always a good way to measure actual performance of something =)
17:09:14 <jstimpfle> Gurkenglas: If you say "sh SCRIPT" instead of "./script" (and given SCRIPT is a script in the sh programming language) then SCRIPT does not need to be executable
17:09:51 <jstimpfle> because you execute only sh, and give to sh the argument SCRIPT, which means it should read that file and interpret it
17:10:06 <jstimpfle> of course, you don't need executable permissions to read a file
17:10:39 <blaird> Axman6: Haha, yeah, it's for an assignment though, so I was using the data available and hoping it worked
17:11:12 <jstimpfle> if you say ./SCRIPT instead, the operating system wil lookup the first bytes of SCRIPT, find it contains #!/bin/sh, and execute sh instead. But to get to that point, the operating system has already considered executing SCRIPT, so you needed executable permissions
17:13:49 <Welkin> Gurkenglas: it looks like file permission problems still
17:14:11 <Welkin> try chmod -R 775 ghc-7.10.2
17:14:16 <Welkin> go up one level before of course
17:20:54 <Gurkenglas> Welkin, sudo sh configure in there afterwards?
17:22:57 <jstimpfle> Gurkenglas: don't do sudo at all for building something. It means you execute as root, and the files created will be owned by root (bad!)
17:24:13 <Gurkenglas> jstimpfle, Welkin says differently
17:25:17 <Welkin> Gurkenglas: just ./configure
17:25:23 <jstimpfle> you only might need sudo for installing to the system-wide directories (which I don't think you do for ghc stuff -- you usually install into your homedirectory)
17:25:23 <Welkin> if all the permissions are set it should just work
17:25:54 <Gurkenglas> Welkin, http://pastebin.com/warning.php?p=1
17:26:18 <Gurkenglas> dang
17:26:20 <Welkin> lol
17:26:24 <Welkin> @lpaste
17:26:24 <lambdabot> Haskell pastebin: http://lpaste.net/
17:26:32 <Welkin> just make one there and continue to edit it
17:26:34 <Welkin> you only need one
17:26:55 <Gurkenglas> http://lpaste.net/7043431398308315136
17:27:56 <Welkin> add `ls -la` to that
17:28:34 <blaird> Does anyone know any good places to find large weighted graph datasets?
17:28:38 <Gurkenglas> http://lpaste.net/7043431398308315136
17:29:34 <Welkin> Gurkenglas: oh boy
17:29:37 <Welkin> "-rwxrwxr-x  1 root       root         4864 Okt  8 02:04 config.log"
17:29:41 <Welkin> root owns the log
17:29:43 <Welkin> haha
17:29:58 <Welkin> just chmod -R 777 ghc-7.10.2
17:30:02 <jstimpfle> Gurkenglas: Welkin: maybe try: find -not -user gurkenglas -exec ls -ld {} +
17:30:27 <Welkin> that will give you permission for everything
17:31:08 <jstimpfle> that would not work, and also it's bad to change modes
17:31:24 <jstimpfle> better: as root, chown -R gurkenglass:gurkenglas ghc-7.10.2
17:31:26 <Gurkenglas> Hard drive seems to be full, lemme just assign some more space
17:31:34 <Welkin> or you could: chown gurkenglas config.log
17:31:58 <Welkin> yeah
17:32:19 <Welkin> not sure why the permission are all messed up
17:32:24 <Welkin> how did you download and extract it?
17:32:25 <Gurkenglas> Huh, I can't just modify the size of the disc
17:32:44 <jstimpfle> the filesystem is probably still the same size
17:32:50 <Gurkenglas> Downloaded in firefox, extracted by doubleclicking it to open it in some archive manager and dragged onto desktop
17:33:08 <jstimpfle> after you increased the disk size, you need to increase filesystem size to max. It's more involved
17:33:14 <EvanR> So this package says I need >= base-4.7 and I have base-4.6. Does that mean I need to upgrade ghc
17:33:24 <Welkin> EvanR: yes
17:33:40 <EvanR> I don't understand why my base is too old, I wrote the package
17:33:54 <Welkin> lol
17:34:02 <Welkin> because of your dependencies
17:34:11 <Gurkenglas> already ran the sudo chmod thing :/
17:34:21 <EvanR> base and bytestring are the only deps
17:34:27 <jstimpfle> Gurkenglas: best just start with a fresh extraction
17:34:42 <Gurkenglas> lol how many times have i done that now
17:34:58 <Welkin> tar -xzf <package>
17:35:17 <EvanR> tar xzf 
17:35:29 <Welkin> or another flag in place of z depending on the compression
17:35:31 <EvanR> tar xf
17:35:38 <Welkin> lol wtf EvanR 
17:35:44 <EvanR> they all work ;)
17:35:47 <jstimpfle> GNU tar works the compression out itself
17:38:51 <Gurkenglas> .tar.xz
17:38:55 <Gurkenglas> what flags for that?
17:39:11 <jstimpfle> just xf: eXtract, File, <file>
17:39:20 <jstimpfle> so tar xf foo.tar.xz
17:39:30 <Xnuk> :t tar
17:39:31 <lambdabot>     Not in scope: ‘tar’
17:39:32 <lambdabot>     Perhaps you meant one of these:
17:39:32 <lambdabot>       ‘tan’ (imported from Prelude),
17:40:15 <arkeet> or J if you want to be explicit about the compression method
17:42:36 <Gurkenglas> It isnt halting. Does that happen when it doesnt have enough disc space?
17:43:00 * hackagebot mikmod 0.2.0.1 - MikMod bindings  https://hackage.haskell.org/package/mikmod-0.2.0.1 (evanrinehart)
17:43:02 <jstimpfle> no
17:43:26 <jstimpfle> you can always add the v (verbose) flag so you can see what file from the archive currently is processed
17:43:53 <Gurkenglas> Apparently it doesnt even start on the first one
17:44:12 <Welkin> Gurkenglas: sounds like you have a messed up ubuntu install
17:44:20 <jstimpfle> you may use htop (if installed) to see what's sucking CPU
17:44:43 <Gurkenglas> Sounds like Im gonna scrap the vm and make a new one then?
17:44:50 <Gurkenglas> Convenient, wanted to have more disc space anyway
17:45:02 <jstimpfle> what's you filesystem?
17:45:05 <jstimpfle> *your
17:45:06 <Welkin> it could be a VM problem too
17:45:12 <Gurkenglas> What's a filesystem? :P
17:45:16 <Welkin> I don't use VMs, but I know they have problems
17:45:18 <jstimpfle> Welkin: no probably not
17:45:34 <Welkin> well, Gurkenglas is on windows, so he is using ntfs
17:45:44 <jstimpfle> filesystem is the structure on your disk to hold files and folders
17:45:47 <Welkin> linux uses ext3/ext4
17:45:58 <jstimpfle> windows does not matter
17:46:07 <jstimpfle> Welkin: depends, there are many more
17:46:40 <jstimpfle> Gurkenglas: could you append the output of "mount"
17:47:09 <Gurkenglas> http://lpaste.net/7043431398308315136
17:47:42 <jstimpfle> okay
17:48:21 <jstimpfle> so i think just: sudo resize2fs /dev/mapper/xubuntu--vg-root
17:48:40 <jstimpfle> if that succeeded, paste also the output of "df -h"
17:49:08 <Gurkenglas> http://lpaste.net/7043431398308315136
17:49:54 <jstimpfle> okay, filesystem currently maximized. you disk size was probably not increased. paste "df -h" nevertheless. it shows filesystem usage
17:49:58 <Gurkenglas> (Already copied from somewhere on the internet: http://lpaste.net/7043431398308315136 )
17:50:30 <Gurkenglas> http://lpaste.net/7043431398308315136
17:50:44 <jstimpfle> Okay, see that 97% usage ? :-)
17:51:06 <jstimpfle> probably the disk size increased did not work or you need at least to reboot until the os notices
17:51:20 <Gurkenglas> I did not increase it, I said that I cannot
17:53:08 <jstimpfle> huh, sorry, got that wrong
17:53:25 <Gurkenglas> Time to scrap the vm then?
17:53:38 <hackal> Hello, I am starting to learn haskell and now I am at recursion but I am stuck. I understand what recursion is but I am not able to make a simple function which takes a list and recursively goes through the list and multiplies each list item by 3 for example.
17:53:39 <jstimpfle> there is probably a way to increase the disk size of the image
17:54:01 <jstimpfle> but then it may also be that increasing the filesystem size may not work because that filesystem is not at the end of the disk
17:54:09 <jstimpfle> ando also, this is a haskell channel :-)
17:54:30 <jstimpfle> so i guess, yeah :-)
17:54:48 <Welkin> > map (*3) [1..10] -- hackal 
17:54:49 <lambdabot>  [3,6,9,12,15,18,21,24,27,30]
17:54:52 <Axman6> hackal: what do you have so far?
17:55:18 <Welkin> @src Functor []
17:55:18 <lambdabot> Source not found. Are you typing with your feet?
17:55:19 <Axman6> Welkin: that doesn't teach him about writing recursive functions
17:55:36 <Welkin> @instance Functor []
17:55:36 <lambdabot> Maybe you meant: instances instances-importing
17:55:40 <arkeet> @src fmap []
17:55:40 <lambdabot> Source not found. Just what do you think you're doing Dave?
17:55:41 <Welkin> @instances Functor []
17:55:43 <arkeet> @where src
17:55:44 <lambdabot> Plugin `instances' failed with: Explict error in module Text.Regex.TDFA.String : Text.Regex.TDFA.String died: parseRegex for Text.Regex.TDFA.String failed:"class.*Functor [].*where" (line 1, column 25):
17:55:44 <lambdabot> unexpected end of input
17:55:44 <lambdabot> expecting Failed to parse bracketed string or "]"
17:55:44 <lambdabot> The fixed database for the `src' lambdabot command is at <https://github.com/lambdabot/lambdabot/blob/master/lambdabot/State/source>
17:55:46 <hackal> Welkin: I achieve what I want using list comprehension but I try to use recursion. 
17:55:49 <Welkin> oops
17:55:51 <Welkin> what was the command?
17:55:55 <arkeet> @src [] fmap
17:55:56 <lambdabot> fmap = map
17:56:11 <ReinH> Ok. If someone wants to write fmap using recursion, let's not show them the definition of fmap.
17:56:16 <ReinH> That's not how people learn.
17:56:17 <arkeet> fmap = fmap
17:56:21 <arkeet> that's recursive!
17:57:06 <ReinH> hackal: lists have two constructors, (:) and []. So you want to write multiplyBy3 [] = ??? and multiplyBy3 (x:xs) = ???
17:57:11 <Welkin> hackal: well, you want to pattern match on each element of the list, make a new version of that element, then stick it onto your new structure and go to the next one
17:57:14 <Reshi> hackal: what other language are you familiar with ?
17:57:29 <ReinH> hackal: Once you get to the end of the list, you're done, so multiplyBy3 [] = []
17:57:38 <ReinH> hackal: The interesting one is the (x:xs) case. Any idea what goes there?
17:58:03 <hackal> Reshi: javascript, here is my code so far https://gist.github.com/anonymous/f2cc0ebe821cff32930c but I am not sure I am doing it right
17:59:13 <ReinH> hackal: If you have triple (item:items), how do you multiply the item by 3?
17:59:27 <ReinH> e.g. if you just wanted to triple the first item and ignore the other items, what would you write?
18:03:23 <Reshi> hackal: your second case should be more like: = (item * 3) : (triple items)
18:05:21 <hackal> Ok, now I see but I am not completely sure if I see why = (item *3) : (truple items) work
18:05:23 <MarcelineVQ> Which is because in a list of 5 numbers, (item:items) means 1 : [2,3,4,5]
18:05:29 <Reshi> hackal: Think of it this way: since haskell lists are immutable, you really have to create a new list with every element of the previous list tripled. To create a new list you start with an empty list [] (the base case) and keep adding elements to it using `:`.
18:05:48 <MarcelineVQ> So by passing one less item each time eventually you reach the lists end
18:06:15 <MarcelineVQ> And because you used : it's also building a list as it goes
18:06:16 <EvanR> MarcelineVQ: or DO you!
18:06:22 <hackal> oh, so : takes first item from first list and moves it to second.
18:06:48 <MarcelineVQ> EvanR: in the simple case ^^;
18:09:17 <jstimpfle> hackal: no, : constructs a list from a front-element and a tail-list
18:09:54 <MarcelineVQ> [1,2,3,4,5] = 1 : 2 : 3 : 4 : 5 : []
18:10:03 <Jinxit> > 1:[2, 3, 4, 5]
18:10:05 <lambdabot>  [1,2,3,4,5]
18:10:43 <MarcelineVQ> [] means empty list
18:10:55 <MarcelineVQ> so you can use : to tack things onto it
18:11:18 <MarcelineVQ> A single item list [1] means 1:[]
18:12:11 <MarcelineVQ> As you learn more about types in haskell this will seem very normal, it's maybe a little weird at first
18:12:20 <Welkin> (:) is an infix version of the list constructor
18:12:25 <Welkin> called Cons
18:12:48 <EvanR> well (:) is THE constructor which happens to be infix
18:12:59 <EvanR> as in :+ for Complex 
18:14:05 <EvanR> cons from lisp seems more semetric, a 2-ary cell
18:14:11 <EvanR> symmetric
18:14:23 <Welkin> > 1 : 2 : 3 : [] == 1 : (2 : (3 : []))
18:14:24 <lambdabot>  True
18:14:45 <MarcelineVQ> that's a really good example Welkin
18:14:47 <EvanR> in haskell you cant just put whatever on the left and right of :
18:15:35 <tabemann> you can't append with :, e.g.
18:15:49 <arkeet> > (:) 1 [2,3,4]
18:15:50 <lambdabot>  [1,2,3,4]
18:16:05 <Welkin> append is (++)
18:16:13 <Welkin> however, append actually uses (:)
18:16:17 <tabemann> you generally want to avoid appending if you can possibly help it
18:16:30 <EvanR> > reverse ((:) 1 (reverse [2,3,4]))
18:16:31 <lambdabot>  [2,3,4,1]
18:16:34 <Welkin> appending to a single-element list is the same as (:)
18:16:49 <Welkin> > [2] ++ [3,4]
18:16:50 <lambdabot>  [2,3,4]
18:16:55 <Welkin> > 2 : [3,4]
18:16:56 <lambdabot>  [2,3,4]
18:17:36 <tabemann> if you need to append more than one thing to something, it's generally a good idea to reverse the original list, prepend everything you need onto it in reverse order, and then reverse the resulting list
18:17:37 <Welkin> ++ uses recursion and pattern matching to cons each element of the first list onto the front of the second
18:18:18 <EvanR> tabemann: and if youre only appending one thing at a time, use the endo-builder "difference list" idiom
18:18:29 <tabemann> yes
18:19:12 <Welkin> or you can construct the list in place using :
18:19:52 <Welkin> > let fib x y = x : fib y (x + y) in fib 0 1
18:19:54 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
18:20:33 <tabemann> I keep on thinking like an OCaml programmer and forgetting that you can do stuff like that in constant stack space in Haskell
18:23:43 <hackal> tail [1,2,3]
18:23:53 <EvanR> [2,3]
18:24:52 <athan> Gurkenglas: Did you ever write that Applicative instance for PaddedZipList? I'd really like to see it
18:26:46 <MarcelineVQ> hackal: when you pattern match a list like you did `triple (item:items) = ...`, items is the tail, and in fact that's how the tail function gets its result
18:27:01 <EvanR> @src tail
18:27:01 <lambdabot> tail (_:xs) = xs
18:27:01 <lambdabot> tail []     = undefined
18:27:25 <MarcelineVQ> `tail (_:xs) = xs`  _  just means you don't care about what the value is, which is true since tail only returns xs
18:28:34 <EvanR> let lastNumber = last [1..] in tail [lastNumber, 0, 1, 2]
18:28:38 <EvanR> > let lastNumber = last [1..] in tail [lastNumber, 0, 1, 2]
18:28:40 <lambdabot>  [0,1,2]
18:29:16 <dmj`> jle`: ping
18:29:24 <julianleviston> man… let expressions *always* confuse me.
18:29:38 <EvanR> lambdabot needs syntax colors
18:29:40 <julianleviston> I understand them just fine, but I always have to flip them around in my head.
18:29:43 <MarcelineVQ> julianleviston: I also tend to think in `where`instead of let, that one is pretty clear though
18:29:59 <gwo> why is '>' needed to evaluate?
18:30:02 <julianleviston> MarcelineVQ: yeah, I don’t actually have any problem with them… it’s just an extra step, you  know :)
18:30:08 <Welkin> gwo: that is lambdabots trigger
18:30:14 <tabemann> coming from OCaml, I'm used to "let" and confused by "where"
18:30:15 <Hafydd> Trigger warning: Haskell.
18:30:17 <gwo> ah ok
18:30:18 <hackal> https://gist.github.com/anonymous/18019655f9efe2ecb5a5 How can I make the last line work? I am getting parse error on the pipe sign
18:30:18 <julianleviston> gwo: it’s so lambdabot doesn’t try to evaluate everything we say
18:30:50 <EvanR> > that would be annoying
18:30:51 <lambdabot>  Not in scope: ‘that’Not in scope: ‘would’    Not in scope: ‘be’
18:30:52 <lambdabot>      Perhaps you meant one of these:
18:30:52 <lambdabot>        ‘b’ (imported from Debug.SimpleReflect),
18:31:03 <julianleviston> tabemann: let is fine… but because I’ve learned so many languages and because of math, I usually expect a straight definition… let a = b…. it’s the “in” bit that bumps my brain.
18:31:06 <MarcelineVQ> @EvanR what do you mean?
18:31:07 <lambdabot> Unknown command, try @list
18:31:36 <MarcelineVQ> ah, well, you can do everything with do if you want to avoid in
18:31:43 <julianleviston> hackagebot: what is the pipe for?
18:31:55 <EvanR> julianleviston: if you end all your lines in `in' and have one definition per line, then ignore all `in's it works
18:31:59 <Welkin> hackagebot is a bot
18:32:00 <Welkin> lol
18:32:02 <Hafydd> hackal: what do you expect that to do?
18:32:18 <EvanR> julianleviston: but where is probably more convenient
18:32:32 <Welkin> I use where more often than let
18:32:34 <tabemann> why is it standard to put "in" on the next line in Haskell
18:32:42 <EvanR> is it?
18:32:44 <tabemann> when I worked in OCaml I'd always put "in" on the same line
18:32:49 <hackal> Hafydd: in the else clause I want to remove the element from list and after that I want to recursively call tripleEven on that list
18:32:58 <Welkin> although I use let inside do-blocks when I need to do things sequentially and package up data
18:33:08 <julianleviston> EvanR:  there are some place s where let in makes much more sense and I’m very glad it’s in the language… I just wish it wasn’t “let in” but say “context … in” or something lol.
18:33:20 <tabemann> putting "in" on the next line is frankly annoying because it forces indentation each time you use "let"
18:33:29 <EvanR> yes
18:33:46 <MarcelineVQ> hackal: `else tripleEven (tail items)`
18:33:46 <EvanR> which you are forced to do anyway with more than one clause in the let
18:33:58 <julianleviston> hackal: then you want to replace it with else tripleEven (tail items)
18:35:01 <lpaste> Hafydd pasted “hackal” at http://lpaste.net/142520
18:35:28 <MarcelineVQ> | is called a guard, when used outside of a list comprehension which you'll learn about later, its best use is to avoid if/then/else at all, like Hafydd just pasted
18:35:45 <Hafydd> hackal: well, I'm not sure what you were thinking with the usage of the guard, but that isn't know it works. I suggest reading a definition of Haskell's syntax.
18:36:50 <hackal> Ok
18:37:04 <julianleviston> hackal: hehe I amended you gist with what Hafydd pasted already, too.
18:37:33 <MarcelineVQ> also like Hafydd has shown, you don't need to `tail` items when you want to check every item in a list, items is already the tail
18:37:44 <Hafydd> julianleviston's version is a bit different, though; it discards the odd elements.
18:37:52 <julianleviston> MarcelineVQ: I thought he was going after skipping one…
18:37:53 <Hafydd> Er... more than that, even.
18:38:11 <julianleviston> guess it’s hard to tell without knowing the intent..
18:38:14 <Hafydd> It disards every odd element and every element coming after an odd element.
18:39:30 <julianleviston> Hafydd:  bit of an issue with the single item list in the case of the tripleEven (tail items) obviously… it’s partial.
18:39:31 <hackal> I need to discard the element
18:39:48 <julianleviston> hackal: then you may want to use 3 pattern matches rather than 2, to be total.
18:40:12 <julianleviston> hackal: because imagine the case where you pass [5] in… 
18:40:26 <MarcelineVQ> If you need to discard the element when it's not even then `else tripleEven items` is sufficient because it doesn't use the single `item`
18:40:32 <julianleviston> hackal: it matches on item = 5, items = [], then you call tail on [] and it’ll raise an exception
18:40:37 <Hafydd> Right.
18:41:10 <lpaste> Hafydd annotated “hackal” with “hackal (annotation)” at http://lpaste.net/142520#a142522
18:41:13 <MarcelineVQ> But, if you want to keep the whole list, and just triple the even ones, Hafydd's version is correct
18:43:15 <EvanR> julianleviston: let goes along with a tradition of syntaxes and math in english
18:43:23 <hackal> https://gist.github.com/anonymous/588288285b2821b2a712 this is what I want to achieve but using recursion
18:43:33 <EvanR> and context is more than twice as long!
18:44:00 <julianleviston> hackal: ah that’s filtering out non-even ones, and tripling the result. Cool… your last version is fine then..
18:44:35 <Hafydd> > let tripleEven = map (* 3) . filter even in tripleEven [1..10]
18:44:37 <lambdabot>  [6,12,18,24,30]
18:45:31 <julianleviston> erm…
18:46:11 <julianleviston> oops.
18:47:46 <MarcelineVQ> Do you still need help hackal or is it coming together? Your last one was right once you fix the else line
18:48:43 <julianleviston> MarcelineVQ: what’s wrong with the else line in it? http://lpaste.net/142520#a142522
18:48:52 <hackal> Thank you for all the help. I have it working now. But I might ask more if I encounter some "abnormalities"
18:49:24 <Hafydd> I save my Haskell logs with the extension .lhs.
18:49:29 <Hafydd> I mean my #haskell logs.
18:49:41 <MarcelineVQ> julianleviston: Hafydd wrote that
18:50:08 <julianleviston> MarcelineVQ: cool.
18:55:54 <tabemann> is it weird that for errors, I always use Either, even if there is no non-error value, so I end up with code like Either [String] ()?
18:56:18 <EvanR> very weird
18:56:35 <Welkin> sure, that is valid
18:56:46 <tabemann> well it's because with Maybe, I'm used to Just being for a "positive" value
18:56:51 <Welkin> then you match on Right ()
18:56:55 <EvanR> oh non-error value
18:57:17 <Welkin> sometimes I am using negative logic, so Nothing is the success case
18:57:25 <Welkin> and Just _ is "failure"
18:57:37 <Welkin> at least when check to see if a value does not exist in the database
18:57:47 <nolrai66> tabemann: the instances back you up.
18:57:53 <EvanR> tabemann: a lot of libraries will use a different type for this, data Result = Ok | Error MyErrorType
18:58:09 <EvanR> or similar
18:58:34 <tabemann> maybe I should create a specific type for things that can be errors rather than using Either
18:58:55 <Hafydd> tabemann: that's particularly useful when using the Either Monad, of course.
18:59:33 <tabemann> I could use the either monad here, but as I am already creating a monad stack, I don't want to make it any larger than necessary
19:00:47 <EvanR> when making a complex monad the size of the transformer-or-otherwise implementation shouldnt matter
19:01:01 <EvanR> the supported features matters
19:02:00 <EvanR> and any complex monad involving IO might end up being more convient as just IO ;)
19:02:21 <EvanR> which is like the most complex possible monad
19:03:24 <lpaste> JulianLeviston pasted “What am I doing wrong here? (Functor instance)” at http://lpaste.net/142524
19:03:26 <jstimpfle> EvanR: there are various complexity metrics. I can easily find one in which IO is like the simplest monad at all ;-)
19:03:32 <tabemann> it's more that I'm finding I have to deconstruct and reconstruct my monad repeatedly across things like async and such
19:03:51 <EvanR> jstimpfle: im interested to see that metric
19:04:10 <jstimpfle> it goes as follows: you can do anything without breaking your head
19:04:29 <Gurkenglas> julianleviston, in line 11 String is capitalized. Note that you can just do "  deriving Functor" between line 7 and 8
19:04:58 <julianleviston> Gurkenglas: It’s an exercise in understanding Functor
19:04:59 <nolrai66> JulianLeviston: The "String" in the functor instance needs to be lower case.
19:05:17 <tabemann> anyways, I don't think I'd really want some kind of Either monad, because I'm frequently having to communicate error states between threads, so error states are not something that exists in any one thread, whereas an Either monad would be limited to one thread
19:05:18 <julianleviston> But… the data constructor has it uppercase doesn’t it?
19:05:20 <EvanR> jstimpfle: youre thinking of IO as like a free monad on commands or something?
19:05:31 <julianleviston> -> | Print String a
19:06:00 <jstimpfle> you don't even need mathematical terminology to explain IO. That's an obvious advantage. It shouldn't be discounted
19:06:10 <jstimpfle> type safety comes at a cost
19:06:22 <Welkin> IO is just the ST monad
19:06:27 <Welkin> there is no cost
19:06:30 <jstimpfle> it's the same thing as don't do premature performance optimization
19:06:32 <julianleviston> Gurkenglas: nolrai66: I don’t understand why the data constructor needs to be lowercase?
19:06:39 <EvanR> jstimpfle: oh breaking your head as in physically?
19:07:03 <EvanR> Welkin: IO and ST are pretty different
19:07:09 <nolrai66> Julianleviston: That is saying that the constructor "Print" has type "String -> a -> TalkToMe a".
19:07:11 <Gurkenglas> julianleviston, in line 11 you're assigning a name to a variable, and variable names are lowercase. You could put "s" there or "foo" instead of String
19:08:22 <julianleviston> Gurkenglas: um… no String is not a variable, on the left, it’s a pattern match, and on the right it’s part of the constructor, isn’t it?
19:08:24 <EvanR> jstimpfle: you dont need math terminology to explain the IO type, on the other hand you cant use math to explain the IO type!
19:09:04 <julianleviston> Gurkenglas: assuming you’re talking about this line… (11) : fmap f (Print String a) = Print String (f a)
19:09:07 <jstimpfle> i can say io is a monad...
19:09:20 <nolrai66> Am I the only one that finds GADT style syntax easier to read then traditional data declarations?
19:09:39 <EvanR> jstimpfle: well that doesnt explain it as any different from any other monad
19:09:43 <kristof> nolrai66: Yes
19:09:59 <kristof> nolrai66: Especially because GADTs have that phantom parameter
19:10:00 <Gurkenglas> http://lpaste.net/8894318022324387840
19:10:02 <Cale> nolrai66: You're not the only one, it's often more intuitive.
19:10:04 <Gurkenglas> @letlpaste 8894318022324387840
19:10:05 <lambdabot>  Defined.
19:10:09 <Gurkenglas> :t Print
19:10:10 <lambdabot> String -> a -> TalkToMe a
19:10:21 <Gurkenglas> Print takes a String and an a to construct a TalkToMe a
19:10:23 <julianleviston> Gurkenglas: I don’t get that at all
19:10:28 <julianleviston> Oh god
19:10:31 <julianleviston> now I get it LOL
19:10:34 <julianleviston> Thanks!
19:10:35 <julianleviston> haha
19:10:45 * EvanR looks for I finally get GADTs blog post
19:11:01 <julianleviston> for some reason, in my brain String wasn’t a type, it was a data constructor… why? lol
19:11:04 <julianleviston> brainfart.
19:11:07 <Cale> nolrai66: However, it does involve a fair amount of repeated information in the case where you're not actually defining a GADT proper.
19:11:08 <julianleviston> Gurkenglas: thanks :)
19:11:25 <Cale> (well, in any case, and especially so in that one)
19:11:41 <julianleviston> haskell is intensely ambiguous sometimes.
19:11:50 <Cale> In particular, the type of result is going to be redundantly repeated for every constructor.
19:12:09 <julianleviston> or, put another way “a lot of what you need to know to interpret haskell isn’t in it syntax.
19:12:27 <julianleviston> its*
19:12:55 <EvanR> more is in the syntax that other languages
19:13:46 <julianleviston> EvanR: Sorry, I wasn’t comparing it to other languages. 
19:13:51 <julianleviston> EvanR:  but, sure. that sounds right.
19:14:14 <EvanR> Just 3 is both syntax and "the actual value" where as an OOP language encoding of Just 3 would have a lot of extra stuff in the way of visualizing that value
19:14:22 <julianleviston> yep.
19:14:31 <julianleviston> EvanR: sorry, I’m not language bashing.
19:22:06 <kristof> EvanR: I would just write a subclass Just
19:22:09 <kristof> new Just(i)
19:22:24 <EvanR> :(
19:22:48 <kristof> EvanR: Not a terrible idea :)
19:23:12 <EvanR> "classes as types"
19:23:21 <EvanR> "and constructors of sum types"
19:23:24 <kristof> Classes are types.
19:23:42 <EvanR> ah ah ah you didnt say the magic word
19:23:53 <kristof> types with subtyping relationships?
19:24:15 <EvanR> classes are factories for objects, and interfaces are better as types
19:24:29 <kristof> Disagree, interfaces are typeclasses of a single parameter.
19:24:51 <julianleviston> ugh navigating haskellforall.com is so pain.
19:25:13 <EvanR> no interfaces dont act like type classes, while they do act like record types
19:26:04 <kristof> Completely disagree, interfaces are almost exactly like type classes, and classes are much more like record types. You must be joshing me.
19:26:37 <EvanR> my version of OOP is more righter!
19:26:44 <kristof> :P
19:27:02 <kristof> Interfaces and typeclasses are both ad-hoc guarantees of behavior.
19:27:43 <hackal> > head [1,2,3]
19:27:44 <lambdabot>  1
19:27:52 <hackal> > : [1,2,3]
19:27:53 <lambdabot>  <hint>:1:1: parse error on input ‘:’
19:28:08 <kristof> >(:[1,2,3])
19:28:20 <kristof> > (:[1,2,3])
19:28:20 <EvanR> i just read a paper by cardelli from 1985 where he goes over two OTHER intepretations of what a class is
19:28:21 <lambdabot>  <Integer -> [Integer]>
19:28:37 <EvanR> the thing is the classes around that time become a conglomeration of every language feature that existed
19:28:41 <kristof> EvanR: Oh, link? I didn't know there was disagreeemnt on this.
19:28:49 <EvanR> this is oop are you kidding? lol
19:29:17 <kristof> I don't think anyone's ever disagreed on the basic requirements of classes
19:29:25 <hodapp> kristof: "On Understanding Data Abstraction, Revisited" by William R. Cook is one more-known paper that talks a bit about this.
19:29:31 <EvanR> youre in for a rude awakening!
19:30:03 <kristof> I probably am :(
19:30:05 <hodapp> kristof: And yes, they have, quite substantially, because as with basically *everything* in OOP, it's ill-defined.
19:30:23 <hodapp> kristof: give that paper a read though.
19:30:25 <kristof> good thing I'm using a well defined language that has its abstractions straight.
19:30:31 <kristof> ...oh, wait. /me looks at all the language extensions
19:30:52 <EvanR> so oop in haskell is better done with records instead of type classes
19:30:55 <EvanR> i think
19:31:10 <julianleviston> kristof: hey at least you *know* when you’re using a non-standard thingie! :)
19:31:15 <hodapp> kristof: Extensions don't really have anything to do with that.
19:31:29 <dolio> You could just not do it.
19:32:15 <kristof> hodapp: Well, I'm referring to constraint/data/polykinds, GADTs, data families versus functional dependencies...
19:33:10 <hackal> Is there a function which takes [Char] and returns String? ['a','b'] would return "ab"
19:33:12 <hodapp> kristof: Last I checked, those things are all fairly well-defined - in large part because they have few implementations.
19:33:16 <kristof> hackal: concat
19:33:23 <EvanR> [Char] = String
19:33:28 <kristof> wait
19:33:30 <kristof> ._.
19:33:40 <EvanR> > ['a','b']
19:33:42 <lambdabot>  "ab"
19:34:17 <kristof> hodapp: I suppose you're right on that.
19:34:41 <julianleviston> hackal: did you understand that? String *is* [Char]
19:34:57 <hodapp> kristof: OOP as Alan Kay defined it originally now more closely resembles something like actor model
19:34:58 <EvanR> type String = [Char]
19:35:51 <hodapp> kristof: classes aren't even a part of his definition.
19:36:10 <julianleviston> hodapp: yeah, the core focus was on message passing… not classes. I think it made him really sad what the “industry” did with OOP.
19:36:21 <EvanR> well an objects
19:36:32 <EvanR> in some circles oop is about objects
19:36:43 <hodapp> He implemented it *with* classes, but they weren't essential, and indeed later on a similar system, Self, was made - but using prototypes, not classes.
19:36:43 <EvanR> surprising i know
19:37:27 <hodapp> julianleviston: yes, he regretted calling it 'object oriented' when the messaging was the important part, not the objects.
19:38:06 <EvanR> now messaging-focused would look more like a process calculus
19:38:15 <julianleviston> EvanR:  or FRP ;-)
19:38:18 <hodapp> EvanR: that or actor model or something
19:38:28 <EvanR> no FPR is about continuous time!
19:38:33 <julianleviston> haha :)
19:38:42 <hodapp> Functional Preactive Rogramming?
19:39:23 <EvanR> the number of FPR implementations out there might do-in FRP as jargon like OOP was
19:39:26 <julianleviston> his latest work was/is on/with an extremely late-bound common object lambda architecture
19:39:29 <EvanR> ... FRP
19:39:32 <julianleviston> EvanR:  exactly! :)
19:39:46 <Hafydd> Functional Proactive Rambling.
19:40:04 <hodapp> julianleviston: Kay's?
19:40:32 <julianleviston> hodapp: yeah… the STEPS project, and work on COLA/Maru/Frank, etc.
19:40:38 <hodapp> julianleviston: have any links handy?
19:40:45 <julianleviston> hodapp:  http://www.vpri.org
19:41:04 <hackal> How could I make this nicer? http://lpaste.net/142526 I am trying to capitalise first letter and lower all other
19:41:34 <Axman6> hackal: pattern match on the list to get the head and the tail
19:41:35 <julianleviston> hodapp: it’s from 2011/+… but the writings section and search for STEPS… the last report covers most of it… it’s really fascinating… basically “how do we get these massively complex systems within individual control using math?”
19:41:45 <Axman6> capitaise (h:t) = ...
19:42:03 <Axman6> you should avoid using head and tail at all times, since they're not total
19:42:32 <Axman6> (you also need to make sure that your function is total, so it correctly handles the empty list case properly too)
19:42:35 <julianleviston> hodapp: includes a PEG symbiotic metalanguage called OMeta, and a bunch of clean abstractions around … well, everything… and ways of translating between them.
19:44:07 <Gurkenglas> How do I tell stack to install the dependencies in parallel so it doesn't just use 25% of my cpu?
19:44:39 <hodapp> julianleviston: neat, I will have to read this! his work has always fascinated me.
19:46:33 <lpaste> Gurkenglas annotated “No title” with “hackal” at http://lpaste.net/142526#a142527
19:49:07 <malical> Hello.
19:50:56 <julianleviston> malical: Hello!
19:52:57 <malical> Hmm. It was more conversational the last time I was here.
19:53:13 <julianleviston> it was before you arrived! :)
19:53:16 <mutantmell> conversation ebbs and flows
19:53:16 <lpaste> cmwilhelm annotated “No title” with “hackal (annotation)” at http://lpaste.net/142526#a142528
19:53:39 <julianleviston> malical: give it a minute :)
19:54:06 <malical> Well I'm glad of that instead of the other way around.
19:55:40 <malical> I can leave if that'll help. :)
19:55:55 <cmwilhelm> this is the first time i’ve used irc in about 5 years; strange to be back, but hello all in #haskell
19:56:25 <mutantmell> wb
19:56:46 <LesZedCB> question about ghc-mod: when I try to run it, I get a "bad character while parsing" error
19:57:06 <malical> Oh god. Of course there's a sub-reddit for haskell.
19:57:38 <mutantmell> malical: It's fairly active too
19:58:13 <LesZedCB> malical: I've subbed to /r/haskell for a while now, it's nice. Not much easy reading for a haskell newbie though
19:58:18 <LesZedCB> sometimes there's something nice :)
19:59:29 <Gurkenglas> haskell-src-exts sure takes a while to build
20:01:12 <malical> Well I'm certainly a haskell newbie.
20:01:25 <malical> But sub-reddits are always interesting to look at.
20:01:43 <cmwilhelm> malical, i’m new to haskell too; how have you been approaching it?
20:02:06 <mutantmell> malical: cool!  Anything in particular pique your interest?
20:03:05 <malical> This is actually my second go at haskell. First time was class project; this one actually a topic in the class.
20:03:53 <mutantmell> same class?
20:05:09 <malical> Not the same class but the same professor.
20:05:33 <julianleviston> why is pure not in Functor proper? Why in Applicative?
20:05:43 <julianleviston> is it because Functor doesn’t actually require it?
20:06:00 <mutantmell> julianleviston: because not all Functors have pure
20:06:17 <orb> For example, (a,) is a Functor.
20:06:31 <Gurkenglas> That one has pure though.
20:06:33 <orb> with: fmap f (a,b) = (a, f b)
20:06:49 <orb> How would you implement it?
20:07:07 <mutantmell> Gurkenglas: not in the general case
20:07:07 <orb> pure b = (_, b) ?
20:07:12 <Gurkenglas> Welp, nevermind me. I thought "Just put the b you get with the a you got!"
20:07:23 <orb> Ha, got not a. :)
20:07:37 <mutantmell> :i (,)
20:07:45 <orb> a -> (a, b) can have a pure, and and an fmap.
20:08:04 <mutantmell> I thought lambdabot could give :info output
20:08:22 <julianleviston> right, so my initial summation was right… because Functor doesn’t actually require it.
20:09:00 <julianleviston> thanks!
20:09:30 <EvanR> there was once a class called Pointed which added pure to Functor
20:09:57 <orb> Pointed = pure + fmap, but not (<*>)?
20:10:20 <EvanR> yes
20:10:47 <malical> Ah. There chat goes.
20:11:04 <homovitr`> is there any script for overlying the results of test coverage from hpc to hscoloured sources like what haddock produces? if not I'll cook something up myself.
20:11:59 <Axman6> hpc can produce htm files iirc
20:13:37 <Axman6> html*
20:19:19 <malical> So I've got this massive 5-tuple I need to verify. Can I use multiple lets to break it down with smaller functions?
20:20:12 <roconnor> you can break down a 5-tuple in a single let if you want.
20:24:42 <Welkin> let (one, two, three, four, five) = fiveTuple
20:24:46 <Welkin> you can pattern match that way
20:24:47 <Axman6> malical: I'm not sure I understand the question, but you can use let (foo,bar,baz,quux,corge) = my5tuple in foo == 2*bar && all isUpper baz
20:26:47 <tesrty> I would like to return one Maybe value. I have a list of Maybe values of which only one is not Nothing.
20:26:54 <tesrty> I'm very confuse
20:27:09 <malical> Oooh. I hadn't thought about doing it like that.
20:27:21 <EvanR> :t listToMaybe . catMaybes
20:27:22 <lambdabot> [Maybe a] -> Maybe a
20:27:25 <Axman6> malical: what were you thinking?
20:27:41 <malical> Effectively nothing.
20:27:56 <tesrty> That looks amazing EvanR Thanks
20:28:54 <EvanR> well if youre sure its not nothing, tack on a fromJust
20:28:58 <Welkin> > Just 4 <> Nothing <> Nothing
20:29:00 <lambdabot>      No instance for (Show a0)
20:29:00 <lambdabot>        arising from a use of ‘show_M145661389794216634022583’
20:29:00 <lambdabot>      The type variable ‘a0’ is ambiguous
20:29:16 <EvanR> Welkin: use First newtype
20:29:17 <Welkin> > Just "hello" <> Nothing <> Nothing
20:29:18 <lambdabot>  Just "hello"
20:29:27 <Welkin> you could have used mconcat then
20:29:27 <EvanR> hmm guess not
20:29:43 <Welkin> > mconcat [Just "hell" <> Nothing <> Just "o"]
20:29:45 <lambdabot>  Just "hello"
20:30:12 <Welkin> oops
20:30:13 <Welkin> hahaha
20:30:20 <Welkin> > mconcat [Just "hell", Nothing, Just "o"]
20:30:21 <lambdabot>  Just "hello"
20:30:24 <Welkin> I am so used to using <>
20:30:48 <Welkin> I <> all the things
20:31:02 <Jinxit> what is <>?
20:31:08 <Welkin> <> = mappend
20:31:12 <Jinxit> ahh
20:31:26 <mutantmell> > Sum 12 <> Sum 24
20:31:27 <lambdabot>  Sum {getSum = 36}
20:31:33 <mutantmell> > Sum 12 `mappend` Sum 24
20:31:35 <lambdabot>  Sum {getSum = 36}
20:32:13 <mutantmell> I like using <> when I'm doing, say, Text stuff
20:32:35 <malical> So I can use a tuple to shrink a big tuple into smaller names?
20:32:43 <mutantmell> "Foo" <> "Bar" rather than "Foo" `mappend` "Bar"
20:32:48 <Welkin> malical: what?
20:33:09 <Axman6> malical: using let is just pattern matching on the tuple and giving names to the elements
20:33:20 <alexg24_> pattern matching rocks
20:33:28 <Axman6> yes
20:33:37 <Welkin> @let fiveTuple = (1,2,3,4,5)
20:33:39 <lambdabot>  Defined.
20:34:01 <alexg24_> do any of you guys like scala?
20:34:15 <mutantmell> my day job is scala -- it's ok
20:34:20 <Welkin> > let (one, two, three, four, five) = fiveTuple in map show [one, two, three, four, five]
20:34:21 <lambdabot>  ["1","2","3","4","5"]
20:34:30 <malical> Yeah. I realized that sentence was a mess. Sadly it was the most coherent of my options.
20:34:34 <malical> I think I got it.
20:34:43 <malical> Until I find something else that is to be bad at.
20:35:47 <EvanR> id like scala if i was paid to like it
20:35:56 <Axman6> you just need to say more malical =)
20:36:30 <Welkin> @where learnhaskell
20:36:30 <lambdabot> https://github.com/bitemyapp/learnhaskell
20:37:01 <mutantmell> alexg24_: I like Scala better than most alternatives, but there's some oddities about the language that annoy me
20:37:23 <mutantmell> alexg24_: Like, I wish lazy data structures were easier
20:38:14 <tabemann> to me scala is really a better java
20:38:22 <tabemann> it's the language java should be
20:38:33 <Axman6> I'm not sure I'd go that far
20:38:49 <EvanR> haskell is a better java
20:39:00 <mutantmell> tabemann: Having seen scala written like Java, I'd say its a worse Java than Java, but a better language overall
20:39:17 <mutantmell> EvanR: Not really ;)
20:40:13 <alexg24_> what do you think about learning scala before haskell?
20:40:29 <Axman6> you'll probably learn terrible habits =)
20:40:33 <alexg24_> if you're unfamiliar with a lot of functional programming concepts
20:40:36 <alexg24_> anything good to learn before?
20:40:38 <mutantmell> alexg24_: Depends on what you're looking for
20:40:51 <EvanR> you probably want to learn haskell first ;)
20:40:53 <mutantmell> alexg24_: Are you looking to learn pure functional programming?  Haskell is better for that
20:41:25 <mutantmell> alexg24_: Are you looking for a language with functional concepts?  Scala would work fine imo
20:41:27 <Axman6> if you want to learn functional programming haskell is a much better tool
20:42:03 <mutantmell> basically: do you want to learn a new paradigm, or do you want to dip your toe into functional?
20:42:13 <EvanR> having a map function doesnt make it a functional language
20:42:20 <mutantmell> I personally dove straight into Haskell and I understand Scala better than most my coworkers
20:42:25 <tabemann> everyone has a map function and closures these days
20:42:28 <mutantmell> because of it
20:42:33 <alexg24_> dip my toe
20:42:35 <alexg24_> at first
20:42:39 <tabemann> just because Java has first class functions now doesn't make it a functional language
20:43:06 * hackagebot cabal-rpm 0.9.8 - RPM packaging tool for Haskell Cabal-based packages  https://hackage.haskell.org/package/cabal-rpm-0.9.8 (JensPetersen)
20:43:43 <mutantmell> alexg24_: I'd recommend one of two things: 1. Taking a look at some Haskell tutorials, and seeing if you are enjoying yourself.  2. just learning scala then segue into Functional Programming in Scala
20:44:03 <EvanR> Theres scalaz
20:45:10 <mutantmell> alexg24_: Basically, I'd recommend learning Haskell over Scala, but I think learning Scala could work as well
20:45:15 <alexg24_> thanks
20:46:28 <mutantmell> Haskell was really nice for me because it forced me into thinking functionally instead of falling back to OO
20:46:36 <dmj`> failing back*
20:46:45 <mutantmell> >.>
20:47:15 <dmj`> once you go haskell you can't go back
20:47:21 <alexg24_> haha
20:47:54 <julianleviston> alexg24_: I actually think Haskell is a brilliant language to start with… because it has everything else in it, and it works more like math than other languages most of the time, which you’ve probably already learned.
20:48:11 <mutantmell> dmj`: Not sure what I'm doing at work then, because I'm definitely coding Scala :P
20:48:24 <Axman6> silently failing
20:48:32 <mutantmell> julianleviston: It's the fun type of math even
20:48:37 <dmj`> Axman6: hahaha
20:48:47 <julianleviston> alexg24_: a lot of programmers that come to Haskell end up having to un-learn their non-functional programming, or at least put it to the side for a while until they understand almost the entire of haskell.
20:49:26 <alexg24_> what kinds of things would you prefer an OO language over haskell for?
20:49:32 <c_wraith> everything
20:49:36 <julianleviston> lol
20:49:39 <c_wraith> Err, wait.  The other one.
20:49:42 <Welkin> lol
20:49:43 <julianleviston> haha 
20:50:01 <mutantmell> alexg24_: I'm honestly drawing a blank for personal projects.
20:50:03 <c_wraith> Honestly, I don't even know what "an OO language" is.  Ruby, java, and smalltalk have approximately an empty intersection.
20:50:18 <julianleviston> alexg24_: yeah, I’ve used MANY languages… and I would prefer Haskell.
20:50:24 <gfixler> julianleviston: Haskell is a terrible language to start in
20:50:29 <mutantmell> alexg24_: For work/collab, there's many more people who know OO languages
20:50:30 <julianleviston> gfixler: is it?
20:50:34 <gfixler> julianleviston: yes
20:50:36 <julianleviston> gfixler: I’m lisening.
20:50:42 <EvanR> python java smalltalk
20:50:43 <julianleviston> gfixler: listening
20:50:47 <gfixler> julianleviston: "start" implies moving to another language after
20:50:54 <julianleviston> gfixler: no it doesn't.
20:50:55 <mutantmell> ._.
20:50:55 <gfixler> julianleviston: I'm finding it impossible to move from Haskell back to even languages I used to like
20:51:00 <EvanR> ( () ) <- ruby `intersect` smalltalk
20:51:03 <Welkin> gfixler: rofl, of course
20:51:06 <Welkin> that is the haskell curse
20:51:16 <gfixler> it's awful - I'm really floudering in C# at work
20:51:20 <Welkin> once you go haskell, you never go back!
20:51:24 <julianleviston> gfixler: awww
20:51:26 <gfixler> it's like having a shoulder angel and a shoulder devil
20:51:27 <mutantmell> I coded bash the other day.  I survived :P
20:51:41 <gfixler> and the devil says "C# is terrible!" and the angel says "Hey, let's use Haskell instead!"
20:51:48 <julianleviston> gfixler: I write Ruby, Javascript, Clojure all the time, and it’s fine.
20:51:52 <gfixler> I can't even think with both of them yelling
20:51:52 <c_wraith> My day job is in Ruby.  I keep wondering how to make the code do nice simple things like traverse_ does
20:52:11 <alexg24_> what do you do with ruby?
20:52:15 <alexg24_> rails dev?
20:52:22 <julianleviston> c_wraith: oh my god… rails’ try(:this_method).try(:another) lol… would you rather that or Maybe? ;-) 
20:52:38 <mutantmell> c_wraith: A lot of my job seems to be writing traverse for a bunch of stuff in scala because I don't want to inflict ScalaZ on my team :P
20:52:40 <gfixler> I think I'd rather just go full lambda calculus
20:52:43 <julianleviston> c_wraith:  or Either, even wow.
20:54:09 <c_wraith> I think the worst part is that I've never *ever* seen a nice high-level description of the semantics of ruby.  Many pieces of it mystify me.  It's like its semantics are the result of a random walk through implementation space.
20:54:27 <julianleviston> c_wraith: i think rspec is about the best you’re going to get
20:54:34 <gfixler> c_wraith: sounds just like C#, or nothing like it (impossible to determine)
20:54:49 <EvanR> c_wraith: if you try to utilize the ruby syntax utilities... all of that box of worms will come out
20:55:01 <EvanR> and wiggle on you
20:55:11 <julianleviston> c_wraith: lol… yeah the guiding principle is “What Matz feels like is right”.
20:55:29 <EvanR> basically, anything can be done at any point anywhere
20:56:01 <c_wraith> There are so many random special forms and barely-documented interfaces, though.
20:56:09 <gfixler> Sounds pretty Pythonic. https://www.reddit.com/r/programming/comments/1kq173/guido_van_rossum_explains_twisteds_deferreds/cbrnqn4
20:56:11 <julianleviston> c_wraith: I’m *still* gaffawing over the fact that he was asked about concurrency and pretty much replied with “um… I’m not the concurrency guy”… after all the crap about the global interpreter lock.
20:56:29 <Welkin> lol
20:56:30 <Welkin> yeah
20:56:32 <julianleviston> gfixler: lol yeah :) 
20:56:37 * EvanR shrugs at the GIL thing
20:56:42 <Welkin> the BDFLs are killing their languages
20:56:56 <gfixler> I like Wadler's take on all of this
20:56:59 <EvanR> who cares about the slowest possible language implementation
20:57:10 <EvanR> as long as it runs right
20:57:15 <julianleviston> EvanR: lol :) cool
20:57:31 <julianleviston> gfixler: what’s that?
20:57:31 <c_wraith> Like, I *still* have no idea what the heck next and continue do, semantically.  They..  um..  they.. uh.. somehow signal the surrounding function via.. special return codes or something?
20:57:47 <EvanR> magic
20:57:55 <julianleviston> LOL!
20:58:00 <gfixler> julianleviston: "Most of you use programming languages that are invented, and you can tell." --Wadler
20:58:01 <EvanR> it does what you mean!
20:58:20 <c_wraith> EvanR: but what if I want to write a function that takes a block with nexts and continues?
20:58:26 <EvanR> you can do that
20:58:29 <EvanR> dont ask how
20:58:37 * hackagebot moesocks 1.0.0.40 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-1.0.0.40 (JinjingWang)
20:58:38 <Clint> never program in conlangs
20:58:47 <julianleviston> http://reactiongifs.me/wp-content/uploads/2013/08/shia-labeouf-magic-gif.gif
20:59:19 <EvanR> there may or may not be a blog post documenting it in partial detail
21:00:04 <c_wraith> I'd hate to teach someone Ruby as a first language.  "It just works.  Don't ask why or how."
21:00:14 <Welkin> haha
21:00:16 <gfixler> c_wraith: use more blocks
21:00:40 <julianleviston> c_wraith: I taught it to my brother as a first language. He now has an $80,000 p/a programming job. 
21:00:47 <julianleviston> c_wraith: but he’s not terribly happy.
21:00:52 <EvanR> thing is, that is how most people learn programming, as a language. it doesnt need formal semantics, just (semi-)consistent examples
21:01:09 <gfixler> julianleviston: I hear things like this and realize that math doesn't actually model reality
21:01:17 <julianleviston> gfixler:  yeah :(
21:01:19 <gfixler> math is logical, and makes sense
21:01:49 <c_wraith> Pfft.  lens works.  I think that's an argument that some weird math I don't understand models something I thought was simple but was clearly wrong about. :)
21:02:00 <julianleviston> gfixler: I actually think maybe it’s just that we haven’t discovered the “next thing after a monad that explains reality” yet :)
21:02:10 <EvanR> lol
21:02:15 <gfixler> julianleviston: I agree
21:02:23 <EvanR> the IO Arrow
21:03:16 <gfixler> I'm going as IO Arrow for Halloween
21:03:22 <malical> Please do.
21:03:25 <malical> Please.
21:03:32 <Welkin> IO Arrow?
21:03:50 <tabemann> dammit the Chicago Haskell meetup is on a Wednesday
21:03:57 <awpr> I used to write Python, until I took a Kleisli Arrow to the knee.
21:03:58 <johnw> go as unsafeCoerce.  "My costume is whatever you say it is."
21:04:05 <gfixler> awpr++
21:04:33 <Welkin> awpr: !!
21:04:41 <gfixler> man, unsafeCoerce even sounds illegal
21:05:01 <gfixler> "Guilty of unsafe coercion!"
21:05:01 <julianleviston> lol
21:05:24 <julianleviston> gfixler: it’s enough to make a grown program leak its memory!
21:05:29 <EvanR> if programming languages were halloween costumes
21:05:31 <julianleviston> gfixler: ok I need to shut up. lol
21:05:33 <Welkin> unutterablePerformIO
21:06:05 <gfixler> unlawfulCarnalEffects
21:07:37 <gfixler> I still don't know how to use unsafePerformIO, and I don't even feel embarrassed
21:08:22 <EvanR> one way is on an IO action that doesn't do any IO effects
21:08:27 <lpaste> tesrty pasted “tic-tac-toe” at http://lpaste.net/3061958309318754304
21:08:28 <EvanR> then its OK ;)
21:08:51 <gfixler> unrequitedIO
21:08:56 <tesrty> So I'm getting a type error in my lambda expression and after looking at it for half an hour I can use some help
21:09:32 <tesrty> It seems to me the list comprehension generator neatly supplies Board's
21:09:53 <malical> So it keeps telling me that isInfixOf isn't in scope, is it not part of the default package?
21:10:06 <tesrty> that would make the lambda expression resolve to a [Rose a]. Neatly fitting on the recursive call above.
21:10:13 <Welkin> malical: it is in Data.List and Data.Text
21:10:19 <Welkin> depending on which one you need
21:10:20 <johnw> tesrty: what is the error?
21:10:31 <malical> How do I ... import ... that?
21:10:32 <Welkin> or you can use ClassyPrelude
21:10:39 <Welkin> import Data.List
21:10:52 <Welkin> https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-List.html#v:isInfixOf
21:10:58 <julianleviston> malical: in what context?
21:11:01 <malical> What is this? Haskell being straightforward? No way.
21:11:15 <julianleviston> malical: i mean… in GHCi or in a file you’re going to compile?
21:11:36 <tesrty> johnw: expected type Board -> Rose Board, actual Rose Board
21:11:39 <malical> In the file, and ... then GCHi.
21:12:06 <malical> Like I'm testing it in GHCi but I'm writing the file as a file.
21:12:44 <tesrty> (the lambda expression has one argument but its type Rose Board has none.)
21:13:06 <johnw> tesrty: your list comprehension doesn't return a [Rose Board]
21:13:14 <johnw> it returns [Board -> Rose Board]
21:13:26 <johnw> that does not match the type of :>
21:13:28 <tesrty> Alright. Let me look at it again with that knowledge. Thanks.
21:13:58 <johnw> I think you can just drop the "\mb -> " at the beginning
21:14:00 <tesrty> But that would imply gameTree is called with one argument too few right?
21:14:08 <johnw> not necessarily
21:14:35 <johnw> you see, the :> [] *is* a [Rose Board]
21:14:50 <johnw> so your then and else have different types
21:15:52 <tesrty> aaah yea.
21:15:58 <tesrty> I see that.
21:16:05 <tesrty> those infix constructors confuse me
21:16:26 <tesrty> fixed it using map (gameTree p) (moves p b)
21:16:30 <tesrty> Thanks a bunch johnw!
21:16:34 <tesrty> I can finally sleep hehe
21:16:43 <johnw> sure thing, that's the same as deleted "\mb -> " from the list comprehension
21:16:54 <johnw> you just had an unnecessary lambda abstraction
21:18:02 <Gurkenglas> I have a .hs file and it imports Data.Functor.Foldable. How do I tell cabal to install whatever it needs to compile that .hs? I already put it in a folder and did cabal sandbox init in there.
21:18:33 <awpr> I think you want Data.Foldable, which is in base (i.e. should compile without installing anything)
21:18:45 <Gurkenglas> https://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html
21:19:11 <Clint> Gurkenglas: cabal init?
21:19:19 <awpr> oh, I see.  then cabal install recursion-schemes should do it (from within the directory you made the sandbox in)
21:19:31 <tesrty> You can use list comprehension without it being in a lambda?! I might just stay up a little longer.
21:20:30 <johnw> in fact, I've never seen lambdas used with them before :)
21:20:38 <tesrty> these assignments are real good. they really show the power of haskell. one additional one line function and I have the game complexity of my tic-tac-toe game.
21:20:56 <awpr> tesrty: yep, the left side of the comprehension is just an expression, where the variables introduced in the right side can be free ("not defined")
21:21:17 <tesrty> right just [ (x,y) | x <- [1..10], y <- ['a'..'d'], x > 9 ]
21:21:26 <tesrty> > [ (x,y) | x <- [1..10], y <- ['a'..'d'], x > 9 ]
21:21:27 <lambdabot>  [(10,'a'),(10,'b'),(10,'c'),(10,'d')]
21:21:31 <EvanR> well theyre not free, they are being introduced
21:21:32 <MarcelineVQ> tesrty: which assignments?
21:21:34 <tesrty> :D
21:21:37 <EvanR> its like a right to left binder
21:22:01 <awpr> EvanR: they're free within the body, just like the parameter name is free within the body of the lambda
21:22:24 <awpr> but yeah, right-to-left binder is how I'd describe it
21:22:28 <EvanR> im saying its not a body
21:22:42 <awpr> it's no less a body than the body of a lambda is
21:22:50 <tesrty> onesec MarcelineVQ 
21:22:55 <EvanR> and so... every variable is free ;)
21:23:19 <awpr> well, there are no free variables in (\x y -> (x, y)); there are in just (x, y)
21:23:23 <EvanR> the expression to the left of the | is the body, i say 
21:23:39 <awpr> EvanR: that's what I was saying, did I mistype something?
21:23:53 <tesrty> https://github.com/ruudkoot/functional-programming
21:24:02 <EvanR> its weird to say x is free in \x -> y
21:24:08 <tesrty> I'm working on 3-TypeClasses
21:24:16 <awpr> oh I see how it wasn't clear.  the left side can have free variables as long as they're introduced by the right side
21:24:44 <EvanR> i.e. theyre not free ;)
21:24:46 <awpr> EvanR: agreed, that would be wrong, it's not what I meant.
21:25:04 <MarcelineVQ> tesrty: thanks!
21:25:42 <awpr> if the body is taken alone they're free, i.e. they're the free variables of the body.  when that body expression is the left side of a list comprehension that binds them, they're not free in that expression
21:25:53 <Gurkenglas> http://lpaste.net/142538 awpr, didn't help o.o
21:26:31 <EvanR> whats an example of an expression that is a "body" that has variables that arent free
21:26:36 <awpr> Gurkenglas: ah, ghci doesn't know about sandboxes on its own.  you'd need to have cabal involved somehow
21:26:42 <awpr> EvanR: 2
21:26:56 <awpr> i.e. [2 | x <- [4,6,8]]
21:27:02 <EvanR> for all variables v in 2, v is free
21:27:05 <awpr> oh, I misread
21:27:24 <awpr> [(\x -> x) 2 | x <- "aoeu"]
21:27:30 <Welkin> Gurkenglas: that is because you are running ghci, but you installed the package in a sandbox
21:27:35 <Welkin> use cabal repl instead
21:28:07 <Welkin> `cabal repl` is ghci for a cabal project (or sandbox)
21:28:16 <awpr> Welkin Gurkenglas (you'll also need to 'cabal init' and make sure recursion-schemes is in the build-depends)
21:29:02 <EvanR> i.e. for a variable to be not free you have to demonstrate something like \x -> \x -> x ;)
21:29:05 <EvanR> extra confusing
21:29:42 <awpr> a variable is free in an expression if its value would have to come from outside the expression
21:29:50 <tesrty> aoeu <3
21:32:45 <EvanR> just not sure how useful to programming it is to say, you can use a free variable here. you cant have free variables for the program to work
21:32:58 <EvanR> you can use a bound variable here though
21:33:47 <awpr> I didn't say you could use free variables, just that the free variables of an expression correspond to bindings introduced in a particular place
21:48:58 <slack1256> Guys this subject isually connotes trolling but it isn't the spirit.
21:49:18 <slack1256> What does constitute diversity? and why do we want to archive it?
21:49:54 <julianleviston> slack1256: more context please?
21:50:02 <johnw> and is it relevant to Haskell?
21:50:24 <shanemikel> guessing it's a wrong channel
21:50:33 <julianleviston> johnw: I have a feeling he’s asking about whether Haskell wants to promote diversity in culture
21:50:40 <slack1256> https://www.reddit.com/r/haskell/comments/3nw9dh/what_makes_a_good_community/
21:50:44 <julianleviston> yeah
21:50:51 <johnw> ah, achieve, not archive
21:50:52 <slack1256> aparently is it relevant to haskell
21:50:58 <slack1256> !!!
21:51:06 <slack1256> yes achieve!
21:51:14 <malical> Is there a function like map but it applies to a tuple instead of a list?
21:51:18 <julianleviston> slack1256: diversity is about accessibility, most likely.
21:51:26 <julianleviston> malical: kind of.
21:51:27 <johnw> I don't think diversity per se is a specific goal of #haskell
21:51:32 <julianleviston> malical: how much of the tuple?
21:51:38 <malical> 5
21:51:47 <johnw> if there was zero diversity here, but active discussion about Haskell, that would be fine
21:51:50 <slack1256> more like a desirable quality of a comunity
21:52:00 <johnw> then here isn't the place for that discussion
21:52:22 <julianleviston> malical: I mean… if you have a pair (2-tuple), such as (5,6) do you want (mapLikeFunction (+1) (5,6) to yield (6,7) or (6,6) or (5,7)?
21:52:23 <slack1256> isn't?
21:52:30 <johnw> no, it isn't
21:52:44 <julianleviston> johnw: oh… what’s #haskell for?
21:52:53 <julianleviston> johnw: I thought it was for discussion about Haskell
21:53:00 <johnw> it's a social question about communities, not about the Haskell language
21:53:05 <johnw> #haskell-blah would be a better place
21:53:10 <julianleviston> johnw: tricky ground ;-)
21:53:27 <malical> Yeah. Oh well. Actually I guess I could just save the element as a list instead ofa  tuple and that would fix ... the problem ... right ... nevermind.
21:53:27 <slack1256> yep, I am currently reading the wiki on the IRC_Channel
21:53:40 <julianleviston> malical: no, I was actually wondering 
21:53:56 <slack1256> but as it seems there is an actually technical discussion going on I'll move ot blah
21:54:10 <johnw> thanks, slack1256 
21:54:10 <slack1256> I still think #haskell can be used for meta-haskell discussions
21:54:19 <julianleviston> malical: because… you can use the functor instance, and do fmap if you only want the right element to be mapped over.
21:54:30 <julianleviston> > fmap (+23) (5,6)
21:54:32 <lambdabot>  (5,29)
21:54:38 <awpr> malical: unlike in Python, lists and tuples aren't closely connected.  if the elements are all the same type and the lengths can vary, it's a list; if they're a fixed shape of different types, it's a tuple.
21:54:55 <julianleviston> malical: fmap is kinda like map… but if you want other behaviour, you’re better off writing your own function, probably.
21:55:07 <malical> Yeah. I'll just write my own. Thanks.
21:56:19 <julianleviston> slack1256: talk about it in haskell-blah
21:56:50 <johnw> slack1256: if you want to discuss policies of #haskell specifically, you can ask in #haskell-ops. Otherwise, there are many Haskell "communities", and discussing it here would not have any impact on those, plus it would distract from the technical discussions about Haskell that are this channel's purpose.
21:57:05 <slack1256> > set both 5 (8,9)
21:57:06 <lambdabot>  (5,5)
21:57:12 <slack1256> lens ftw
21:57:32 <julianleviston> slack1256: might not be the best idea given that he doesn’t yet even understand functor  ;)
21:57:48 <julianleviston> (- “even")
21:58:01 <slack1256> I thought he understood them, my bad
21:58:19 <slack1256> johnw: fair point
22:11:07 <reirob> hello haskellers, I need help with converting a Double to String, in decimal notation, not scientific. I want :{ show (50034260::Double) :} to produce "50034260" and not "5.003426e7"
22:11:49 <reirob> I was looking now at a lot of pages, wikis, but didn't find anything helpful
22:12:08 <roconnor> @hoogle showF
22:12:10 <lambdabot> Numeric showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
22:12:10 <lambdabot> Data.Fixed showFixed :: HasResolution a => Bool -> Fixed a -> String
22:12:10 <lambdabot> Numeric showFloat :: RealFloat a => a -> ShowS
22:12:26 <roconnor> :type showFFloat
22:12:33 <roconnor> @type showFFloat
22:12:35 <lambdabot> RealFloat a => Maybe Int -> a -> ShowS
22:12:37 <roconnor> @type showGFloat
22:12:38 <lambdabot> RealFloat a => Maybe Int -> a -> ShowS
22:12:55 <roconnor> reirob: some of these functions do what you want.
22:12:58 <roconnor> I forget which.
22:13:08 <reirob> thanks roconnor!
22:13:50 <lispy> > printf "%f" (50034260::Double)::String
22:13:51 <lambdabot>  "50034260.0"
22:15:35 <Axman6> > printf "%.0f" (50034260::Double)::String
22:15:37 <lambdabot>  "50034260"
22:17:15 <quicksilver> is there a way to run TemplateHaskell as a pre-processing step, producing source code which other people can compile directly without needing your TH machinery?
22:18:12 <slack1256> there was a option on ghc that outputs the expanded template haskell code
22:18:16 <slack1256> -ddump-splices?
22:18:32 <slack1256> man ghc and / a search should tell you
22:18:35 <reirob> thanks lispy and Axman6
22:18:43 <lispy> reirob: yw
22:19:36 <reirob> is there a way to overwrite show for doubles to use decimal notation?
22:19:54 <lispy> Kind of
22:20:00 <lispy> You could create a newtype
22:20:21 <lispy> newtype Decimal = Double
22:20:26 <liste> reirob using show for output is quite inflexible, I'd recommend printf or formatting
22:20:27 <lispy> instance Show Decimal where ...
22:20:32 <liste> @hackage printf
22:20:32 <lambdabot> http://hackage.haskell.org/package/printf
22:20:36 <liste> @hackage formatting
22:20:36 <lambdabot> http://hackage.haskell.org/package/formatting
22:20:42 <slack1256> probably a pretty printer of doubles is what you want
22:20:55 <lispy> Oh I forgot a token also, newtype Decimal = D Double
22:21:01 <reirob> the newtype could be a way to go.
22:21:50 <slack1256> reirob: still if you use the newtype and implement a new Show instance, it will be curbersome to implement such instance
22:21:55 <reirob> the thing is, I am programing a pretty-printer of an AST that prints out the syntax of the language
22:22:04 <slack1256> but formatting(the package) will make it easier
22:22:18 <lispy> slack1256: the show method could just be in terms of printf
22:22:20 <reirob> and the AST has Double(s) everywhere and I am using show
22:23:00 <slack1256> lispy: right, Still I feel icky when I don't follow that un-official law of read . show = id
22:23:04 <reirob> Maybe I will write just my own function that will use printf and call it instead of show
22:23:12 <lispy> reirob: the bummer with using newtype for this is that you'll need to convert from Double to Decimal. And if you're using any existing instances or rewrite rules of Double, then you want to do that conversion late.
22:23:28 <EvanR> Show is not for pretty-printing
22:23:30 <malical> Sigh. Sorry folks. Haskell is easily my least favorite language. :(
22:23:59 <slack1256> mine is klingon
22:24:00 <liste> malical worse than COBOL? ; )
22:24:06 <reirob> you helped me a lot dear Haskellers :-)
22:24:19 <reirob> I love Haskell and it's community 
22:24:40 <malical> There just no ... logic? flow? sense?
22:24:45 <malical> There's*
22:25:05 <liste> we have all 3 :)
22:25:11 <EvanR> there is, but its very different from other popular languages
22:25:17 <slack1256> in both forms, ultra explicit and ultra implicit
22:25:48 <malical> I've never been able to wrap my head around it. I just end up getting frustrated.
22:25:49 <slack1256> no middle ground on haskell
22:26:16 <MarcelineVQ> malical: ok
22:27:02 <reirob> I love Haskell and it's community 
22:27:04 <kazagistar> I like when the learning is hard. Easy learning is difficult to distinguish from not learning anything at all and just going in circles
22:27:33 <EvanR> haskell was the first language in a long time where i felt like i was learning something new
22:28:00 <EvanR> and i still dont fully understand it all
22:28:24 <lispy> malical: well, we love to explain things, so if you get stuck again don't hesitate to ask
22:29:03 <julianleviston> malical: it could be you’re skipping steps
22:29:21 <julianleviston> malical: I think that’s usually the case. 
22:29:54 <hunteriam> Hey guys I have a
22:30:05 <hunteriam> An introductory type theory question
22:30:39 <hunteriam> https://usercontent.irccloud-cdn.com/file/EuYq5z6y/1444282359.JPG
22:30:40 <julianleviston> malical: most “common languages” are not “thinking different thoughts”, so it’s easy to learn a new one of them.
22:31:30 <julianleviston> malical: but if you tried to learn ML, Prolog, OCaml, Scheme, or PERL after say just Java, you would probably have a tricky time of it, too…
22:31:38 <julianleviston> malical: for various reasons.
22:31:40 <hunteriam> Does 3 prevent you from saying (\x. xx)[x:=y] === (\x. yy)
22:31:46 <hunteriam> Cause it doesn't seem like it does
22:32:28 <malical> Absolutely. I'm awful at thinking. So having to think in a new way is incredibly frustrating.
22:32:38 <julianleviston> malical: it doesn’t have to be.
22:32:50 <julianleviston> malical: bitemyapp has put a lot of work into making it a lot easier.
22:33:00 <julianleviston> malical: so, take a deep breath, expect learning it to take a few months rather than weeks, and go grab the book at http://haskellbook.com
22:33:53 <malical> Ah. See, if this was me learning for fun maybe. But that was last time. This time it's me learning because I have to.
22:34:26 <lispy> hunteriam: I think that rule uses alpha-equivalence, but is more about reduction order
22:34:28 <julianleviston> malical: define your have-to parameters? timeframe? requirements?
22:34:43 <julianleviston> malical: by the way, I’m like you in that I’m incredibly impatient and need it for work.
22:34:51 <quicksilver> slack1256: yes, dump-slices but it would be nice to have it in a more 'official' form than copy/pasting from what is essentially GHC's debug output
22:34:58 <Hafydd> hunteriam: the renaming of y to z (where z has the property that it is not free in N) ensures that.
22:35:13 <hunteriam> I'm not convinced it does I
22:35:38 <hunteriam> If you substitute X:= y
22:36:02 <hunteriam> In the expression (\x. x)
22:36:09 <hunteriam> You don't have to rename because isn't free in N
22:36:11 <malical> Hopefully I never need functional programming for work. Because I will fall so so fast.
22:36:17 <Hafydd> hunteriam: by definition: (\x.xx)[x:=y] = (\z.zz)[x:=y] = \z.zz
22:36:41 <julianleviston> malical: most common programming languages are slowly moving towards functional programming anyway, IMO
22:36:51 <hunteriam> Well the definition on the page doesn't seem to ensure that
22:37:00 <slack1256> that is a bad thing
22:37:13 <slack1256> because it will bring languages that are just a match up of features
22:37:18 <slack1256> instead of coherent wholes
22:37:33 <hunteriam> I could say \x.xx[x:=y] = \x.yy by this definition
22:37:36 <hunteriam> Which shouldn't be true
22:38:06 <hunteriam> Because I could rename p from X to X since X is free in N
22:38:32 <julianleviston> malical: you end up needing functional programming languages if you want to make programs that fail less, I think.
22:38:53 <hunteriam> You never really "need" functional programming, it's just really nice IMO
22:39:18 <julianleviston> hunteriam: haha I wrote an app in Ember that *needed* it :) lol… god it was a mess.
22:39:56 <EvanR> you need functional programming
22:39:56 <hunteriam> I see
22:40:17 <hunteriam> No, you need functional programming
22:40:19 <liste> they even prove C programs correct, but it just seems like a nightmare
22:40:19 <EvanR> period ;)
22:40:52 <Hafydd> hunteriam: \x.yy is not an alpha-variant of \x.xx.
22:41:01 <julianleviston> malical: anyway, if you need help, there’s #haskell-beginners which is very helpful… and you can ask anything you like in there…
22:41:29 <Axman6> and in here too
22:42:01 <malical> Oh thanks. I actually didn't know that.
22:42:04 <julianleviston> Axman6: tho… here you’re a bit more likely to get into the bermuda triangle of Haskell.
22:42:05 <hunteriam> Ah true
22:42:07 <julianleviston> Axman6: ;-)
22:42:12 <lispy> hunteriam: I don't think the author intended for you to be able to write \x.P[x:=N], but I'm also not seeing how it disallowed
22:42:33 <hunteriam> lispy: the bit about alpha variants
22:42:35 <Hafydd> hunteriam: but I am assuming that "alpha variant" means what I think it does. I haven't see that term defined before. It would be helpful to see that definition too, for full transparency.
22:42:45 <hunteriam> Sure and I'm pretty sure it does
22:43:26 <hunteriam> https://usercontent.irccloud-cdn.com/file/eyMx7ECc/1444283127.JPG
22:43:42 <hunteriam> https://usercontent.irccloud-cdn.com/file/JDajFHi8/1444283143.JPG
22:44:31 <hunteriam> https://usercontent.irccloud-cdn.com/file/8ePUkHmR/1444283192.JPG
22:45:08 <Hafydd> Ah. Then it's as I though.
22:45:11 <Hafydd> *thought
22:46:41 <hunteriam> Actually is it
22:47:06 <hunteriam> \x. X =a \x. X
22:47:13 <hunteriam> And that's all we needed to be alpha variants
22:47:24 <hunteriam> And we perform the substitution after
22:47:39 <EvanR> julianleviston: bermuda triangle?
22:48:51 <Hafydd> hunteriam: are you arguing that \x.yy =α \x.xx follows from that?
22:49:03 <julianleviston> EvanR: haha yeah, like… let me paint a picture … “how do I print something on the sceen?” “Well, to explain that I’ll just explain purity, then currying, function application, functors, applicative, folds, monadic actions and finally, what IO is”.
22:49:38 <hunteriam> Hafydd yes
22:49:46 <hunteriam> No,a cruelly
22:49:54 <Hafydd> hunteriam: I do not follow your reasoning, then. 
22:50:31 <hunteriam> But that what does follow from 3 in 1.6.1 is that \x.x[x:=y] = \x.y
22:50:32 <julianleviston> EvanR:  not meant as a criticism, just an observation that this is like the deep end of the pool and #haskell-beginners is more like the shallow end of the pool.
22:50:41 <julianleviston> EvanR: well, it can be.
22:50:42 <hunteriam> So let P = X
22:50:53 <hunteriam> Then we have \x.P
22:51:22 <hunteriam> And we rewrite this to \z.Px->z as long as z is not in FV(N)
22:51:32 <arkeet> no
22:51:42 <arkeet> anyway, what does P^{y->z} mean?
22:51:43 <hunteriam> No?
22:51:55 <Hafydd> arkeet: it's defined here: https://usercontent.irccloud-cdn.com/file/8ePUkHmR/1444283192.JPG
22:51:59 <Hafydd> Renaming all free variables.
22:52:11 <EvanR> julianleviston: i thought you were saying -beginners is a bermuda triangle
22:52:13 <arkeet> okay.
22:52:17 <arkeet> so let's begin.
22:52:18 <EvanR> and didnt know what that meant
22:52:37 <arkeet> so you want to know what (\x.x)[x:=y] is
22:52:47 <hunteriam> I know what it should be
22:52:51 <arkeet> here P = x
22:52:56 <Hafydd> hunteriam: but (3) also states the condition that \z.P^{x->z} =α \x.P for this to hold.
22:53:01 <arkeet> and N = y
22:53:02 <kazagistar> julianleviston: im pretty sure you are going to want to use a FRP framework for that screen printing program.
22:53:14 <Hafydd> hunteriam: so by what property of alpha-equivalence does this hold?
22:53:17 <hunteriam> If you set z = X then that statement is true
22:53:18 <julianleviston> kazagistar: :D here’s a list
22:53:30 <hunteriam> That statement says nothing about what happens after substitution
22:53:40 <Hafydd> hunteriam: P^{x->z} only allows to be a variable, not a term.
22:53:52 <Hafydd> *only allows z to be
22:54:04 <hunteriam> Z could be X I'm sorry it's auto capitalizing
22:54:10 <hunteriam> z could be X
22:54:12 <hunteriam> X
22:54:15 <hunteriam> x
22:54:18 <hunteriam> Lower case
22:54:25 <malical> ... Sometimes I really hate myself. Like when I waste two hours because my base case was checking the wrong thing ...
22:54:26 <arkeet> hm
22:54:30 <arkeet> I wonder if x and z must be distinct
22:54:47 <hunteriam> Nope, the book says so itself in a bother section:
22:54:51 <arkeet> ok.
22:55:02 <Hafydd> Okay, so then you have \z.P^{x->x}, which is \z.P. Your claim is that \z.P =α \x.P then holds.
22:55:38 <hunteriam> https://usercontent.irccloud-cdn.com/file/dFBnnW8j/1444283859.JPG
22:55:57 <hunteriam> It'd be \x.P X->X but ya
22:56:03 <malical> Well figured out why something that should obviously work didn't ... I can't blame Haskell on that one.
22:56:43 <hunteriam> I mean this flaw is easy to fix if it's the flaw I think it is (it's not demo started in the examples or anywhere) but still disheartening
22:56:55 <Hafydd> hunteriam: P^{x->x} is exactly equal to P, is it not?
22:57:01 <hunteriam> Yes
22:57:22 <Hafydd> hunteriam: then your claim is indeed that \x.P =a \x.P. I claim this is false, for example when P=x. 
22:57:39 <arkeet> Hafydd: ??
22:57:43 <Hafydd> Er... \x.P = \z.P, I mean.
22:57:47 <arkeet> okay better.
22:57:52 <Hafydd> By what property of alpha-equivalence is \x.x =α \z.x?
22:57:58 <hunteriam> It shouldn't be \z.P
22:58:18 <hunteriam> Should be \x.P
22:58:21 <Hafydd> <hunteriam> And we rewrite this to \z.Px->z as long as z is not in FV(N)
22:58:31 <julianleviston> why is eta-reduction called eta reduction?
22:58:32 <arkeet> or \z.(P[x := z])
22:58:50 <hunteriam> So if you set z to X you should also replace the binding variable z
22:59:04 <hunteriam> Not just the one in the rewrite of P
22:59:13 <julianleviston> or is it beta reduction?
22:59:40 <julianleviston> oh… beta reduction is application
23:00:15 <hunteriam> I'm very tired so I hate to leave things inconclusive but I've got to say goodnight
23:00:26 <Hafydd> hunteriam: if you did do that, then you'd end up with \z.z, which is a perfectly good substitution; so what is the problem?
23:00:41 <slack1256> man chruch was really a hipster calling application beta reduction
23:00:54 <Hafydd> hunteriam: if you wish to refute my argument, I'll probably be here later.
23:01:32 <hunteriam> I don't think you've done that correctly
23:01:35 <julianleviston> for that matter, why is lambda lambda lol.
23:01:53 <julianleviston> l = logic?
23:02:20 <hunteriam> https://usercontent.irccloud-cdn.com/file/GYEr6aZm/1444284261.JPG
23:02:30 <hunteriam> Replace every y with an X to see my intentions
23:03:11 <Hafydd> So: \x.M =α \x.M^{x->x}.
23:03:38 <Hafydd> i.e. \x.M =α \x.M. What does that say about your intention?
23:04:16 <hunteriam> That's what I was trying to do with the substitution
23:04:28 <hunteriam> You could change the binding variable, and then you have no problem
23:04:31 <hunteriam> But you don't have to
23:04:35 <hunteriam> And then you have a problem
23:04:48 <slack1256> julianleviston: hipster, that is why the lambda
23:04:58 <hunteriam> The definition doesn't clarify that we only replace free variables of X very well
23:05:49 <Hafydd> hunteriam: which definition are you referring to?
23:06:29 <hunteriam> The one for substitution
23:06:34 <hunteriam> 1.6.1
23:08:30 <Hafydd> hunteriam: does the requirement that the \z.P^{y->z} =α \y.P not entail that all non-free occurrences are replaced with z, and hence avoid being replaced?
23:09:01 <hunteriam> It does indeed entail that
23:09:09 <hunteriam> But if you replace them with the original variable X
23:09:11 <hunteriam> You have a problem
23:09:13 <malical> Can you have a function that takes a tuple or a list for an argument?
23:09:19 <hunteriam> And the definition doesn't stop you from doing that
23:10:18 <Hafydd> hunteriam: if you replace them with the original variable, then alpha-equivalence does not hold.
23:10:33 <Hafydd> So it does stop you.
23:11:06 <Hafydd> Unless I missed something earlier, I haven't yet seen an example where this happens.
23:11:23 <julianleviston> malglim: um… in as much as you can have a function that takes anything
23:11:29 <hunteriam> Yes aloha equivalence does hold
23:11:35 <hunteriam> You showed it above yourself
23:11:39 <MarcelineVQ> malical: A polymorphic function can
23:11:47 <hunteriam> 1:03 AM <Hafydd> i.e. \x.M =α \x.M. What does that say about your intention
23:11:50 <Hafydd> Aloha equivalence? That's an interesting idea.
23:12:22 <julianleviston> malical: as much as you can have a function that takes anything… like, say, the id function.
23:12:35 <jle`> aloha equivalence is the most friendly of all equivalences
23:12:46 <julianleviston> malical: but you might be better off giving us a higher level intent … or a question around that.
23:12:53 <julianleviston> malical: as in… what are you trying to do?
23:13:43 <Hafydd> hunteriam: can you re-state what P, N and z are in this scenario?
23:13:46 <jle`> malical: f (x, y) = x + y is a function that takes a tuple for an argument
23:14:03 <gfixler> so I turn off buffering on stdin and stdout through System.IO
23:14:04 <julianleviston> jle`: i think he was asking if you could have a function that takes BOTH a list and a tuple
23:14:11 <jle`> ah
23:14:13 <gfixler> and reverting things before exiting, my shell is borked - any ideas why?
23:14:14 <julianleviston> jle`: or either.
23:14:30 <shanemikel> are they arguing about the lambda calc?
23:14:32 <gfixler> borked as in I don't see what I'm typing, and hitting enter doesn't insert newlines - prompts stack up and line-wrap
23:15:10 <gfixler> actually, it seems related to hSetEcho
23:16:19 <gfixler> could the programming be quitting before they can take effect?
23:18:18 <reirob> Hello again. Just to tell how I resolved my Double -> String problem:
23:18:20 <reirob> showNum n = TL.unpack $ Fmt.format Fmt.shortest n
23:18:38 <reirob> Where TL is import qualified Data.Text.Lazy as TL
23:18:53 <reirob> and Fmt is: import Formatting as Fmt
23:19:01 <reirob> Thank you very much!
23:20:33 <gfixler> hmmm, I fixed it, in a bizarre way
23:20:39 <gfixler> hSetEcho stdout True
23:20:50 <gfixler> have to do that first, then the stdin/stdout False lines
23:20:58 <gfixler> then I can just True them back before exit, and it finally works
23:21:19 <gfixler> I don't have to True stdin to True up front, though
23:25:56 <Hafydd> hunteriam: oh, I see your point, now. There is supposed to be a stipulation that x != y, there. I agree now that the definition is lacking.
23:26:14 <Hafydd> hunteriam: this other definition has it for example: https://en.wikipedia.org/wiki/Lambda_calculus#Capture-avoiding_substitutions
23:35:45 <Gurkenglas> :t cata -- what defines this?
23:35:46 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
23:36:49 <jle`> there are a couple libraries i know that offer such a function, but i'm not sure where lambdabot gets it
23:37:13 <Cale> I believe that's just in lambdabot's L.hs
23:37:30 <Cale> (the module in which it evaluates expressions)
23:37:33 <jle`> it's cata from recursion-schemes specialized for the Mu instance, and also cata from data-fix but for its own Fix type
23:37:35 <jle`> @undefine
23:37:35 <lambdabot> Undefined.
23:37:37 <jle`> :t cata
23:37:40 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
23:37:58 <jle`> i have an idea
23:38:01 <jle`> @let cata = 4
23:38:06 <lambdabot>  .L.hs:148:1:
23:38:12 <lambdabot>      Multiple declarations of ‘cata’
23:38:14 <lambdabot>      Declared at: .L.hs:145:1
23:38:19 <Cale> I mean, it's sitting in the default L.hs which gets copied over the working one when you @undefine
23:38:47 <jle`> i was hoping that the error message would confirm its location but it seems to stop one line short :|
23:39:31 <Hafydd> 07:38:58 <lambdabot>      Multiple declarations of ‘cata’
23:39:31 <Hafydd> 07:38:58 <lambdabot>      Declared at: .L.hs:145:1
23:39:31 <Hafydd> 07:38:58 <lambdabot>                   .L.hs:148:1
23:39:41 <Hafydd> That's the longer output, by PM.
23:39:59 <jle`> ah so confirmed in L.hs
23:48:52 <Gurkenglas> Review particularly lines 14-16: http://lpaste.net/2921291705103679488
23:55:30 <malical> Why would elem loop forever?
23:55:32 <jle`> i wouldn't call sequenceA . sequenceA x the most readable thing :)
23:55:47 <jle`> @src elem
23:55:47 <lambdabot> elem x = any (== x)
23:56:38 <jle`> malical: it could be traversing an infinite list, or evaluating one of the items in the list might not terminate in the process of evaluating (==) for it
23:56:39 <Gurkenglas> The right one gives the same var map to many terms, and the left one collects justice. How else would I say that?
23:59:01 <malical> If I write out the list it works, but if I use the variable it doesn't.
23:59:13 <jle`> malical: can you paste your code?
