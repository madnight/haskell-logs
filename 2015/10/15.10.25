00:07:38 * hackagebot tellbot 0.6.0.3 - IRC tellbot  https://hackage.haskell.org/package/tellbot-0.6.0.3 (DimitriSabadie)
00:07:38 * hackagebot hwsl2 0.4.0.0 - Hashing with SL2  https://hackage.haskell.org/package/hwsl2-0.4.0.0 (srijs)
00:11:07 <jre2> is "lens" the current best library for record mutation?
00:12:15 <shachaf> lens doesn't support record mutation.
00:12:29 <shachaf> No more than Haskell code in general does, at least.
00:12:57 <jre2> er, poor wording on my part
00:13:42 <jre2> I guess just cow updating
00:14:06 <shachaf> cow?
00:14:16 <tabemann> @hoogle Eq a => a -> [(a, b)] -> b
00:14:18 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
00:14:18 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
00:14:18 <lambdabot> Language.Haskell.TH.Syntax RecConE :: Name -> [FieldExp] -> Exp
00:14:20 <EvanR> its not copy on write either, because no writing is going on during a record update
00:14:24 <jle`> it's a nice way to compose nested record accessors, and some nice abstractions for other things involving fields in constructors too, but "best"? ... probably depends on what you really want to do
00:14:27 <EvanR> (semantically speaking)
00:14:28 <nshepperd> record updating
00:14:57 <EvanR> with PHP copy on write, you are free to mutate the thing you get after COW occurs. In haskell you can't mutate any records ever.
00:15:03 <shachaf> Most of what lens does isn't really about lenses.
00:15:51 <jre2> EvanR: ah. what would be a clearer way to phrase it?
00:15:55 <shachaf> I'm not going to call anything best (and neither should you ask a question like that), but if the sorts of things you want to do match up with the sorts of things lens wants to do, it works very well.
00:16:02 <EvanR> jre2: the feature is called record update
00:19:49 <jre2> shachaf: I previously used my own library based on what eventually became data-accessor, so I was curious about replacing it for my new project
00:20:47 <jle`> it does really depend on what you want to do.  but really complicated things using the syntactical record accessors/updators and some other formulations become pretty simple/clean in lens, in many cases
00:24:03 <gamegoblin> Function to tell if all elements of a foldable are equal?
00:25:24 <jre2> jle`: given the need for lots of nested record updating, would you recommend 'lens' or one of the alternatives, though?
00:26:37 <jle`> i would recommend lens.
00:27:43 <bitemyapp> jre2: Seconding lens.
00:29:21 <gfixler> gamegoblin: all has a Foldable constraint now - can you use that?
00:29:44 <gamegoblin> gfixler: in what way would it be used, though? What would the condition be?
00:29:56 <gamegoblin> gfixler: you’d have to get at one of the elements
00:29:59 <gfixler> gamegoblin: you'd have to get the first element, then all (==that)
00:30:00 <gfixler> yeah
00:30:04 <gfixler> was just a thought
00:30:07 <EvanR> or if its empty (null) then True
00:30:26 <gamegoblin> getting at an element is the tricky bit, though
00:30:56 <EvanR> you can implement safeHead with foldr ;)
00:31:16 <gfixler> gamegoblin: \x -> zipWith (==) x (tail x) . toList
00:31:29 <gamegoblin> gfixler: trying to avoid toListing it :P
00:31:30 <gfixler> oops, forgot the all (==True)
00:31:33 <gfixler> :)
00:32:00 <gfixler> could zipWith work on foldables?
00:32:05 <gamegoblin> gfixler: all (== True) is the same as `and`
00:32:07 <EvanR> > foldr (\x _ -> Just x) Nothing []
00:32:09 <lambdabot>  Nothing
00:32:10 <gamegoblin> > and [True, True, False]
00:32:11 <lambdabot>  False
00:32:11 <EvanR> > foldr (\x _ -> Just x) Nothing [1]
00:32:12 <gfixler> gamegoblin: oh, right
00:32:13 <lambdabot>  Just 1
00:32:20 <EvanR> hint its called FOLDable
00:32:40 <KaneTW> > foldr (flip . const $ Just) Nothing [2..]
00:32:42 <lambdabot>  Just 2
00:33:02 <EvanR> heh flip . const $ Just ;_;
00:33:30 <KaneTW> good old @pl
00:33:42 <EvanR> @unpl flip . const $ Just
00:33:42 <lambdabot> (\ b c -> (Just) b)
00:33:52 <EvanR> gross
00:34:05 <KaneTW> @pl \x _ -> Just x
00:34:05 <lambdabot> const . Just
00:34:18 <KaneTW> i feel silly now
00:35:47 <KaneTW> well i guess i never realized flip . const is (const .)
00:35:57 <KaneTW> the more you know
00:37:04 <hnfmr> If I read a binary file into ByteString data, how can I read the data into chunks delimited by some string?
00:37:33 * hackagebot servius 1.2.0.0 - Warp web server with template rendering  https://hackage.haskell.org/package/servius-1.2.0.0 (MichaelSnoyman)
00:37:38 <KaneTW> attoparsec? probably overkill but /shrug
00:37:44 <EvanR> hnfmr: one way is attoparsec
00:37:57 <EvanR> theres also the stringsearch package
00:38:29 <hnfmr> Thanks, I will do some research with them.
00:47:55 <lf94_> You should see the brainfuck interpreter I did. No parsec, just straight up Char parsing...
00:48:10 <lf94_> Handling nested [] was a nice learning experience.
00:48:29 <lf94_> https://github.com/lf94/BrainSkell
00:48:48 <EvanR> .oO( hmm static typing for brainfuck )
00:49:17 <johnsean> Has anybody here used emacs with haskell? I am trying to set up company-ghc so I can get autocompletion but it doesn't seem to work for me.  I have installed ghc-mod with "cabal install ghc-mod" and then I installed company/company-ghc in emacs added it to my list of company backends. Any advice?
00:49:51 <lf94_> I have. I just open eshell to run ghc.
00:49:51 <johnsean> (require 'company)
00:50:11 <hamid> +1 :D
00:51:17 <johnsean> wait how would that work? Do you just pass in the name of the hs file?
00:52:39 <johnsean> I tried that with multi eshell. I put ghc temp.hs and it compiled the file but how does that do anything for company ghc?
00:55:09 <lf94_> hamid: thanks man :)
00:55:32 <lf94_> johnsean, it has nothing to do with it! heh.
00:57:27 <Walther> I've been writing a haskell tutorial, it's highly work in progress, but in case some people here are willing to read it, I would greatly appreciate feedback and suggestions on how to improve it :) http://walther.guru/functional-pizza
00:58:19 <lf94_> functional pizza, hissssss
00:58:23 * lf94_ click
00:59:32 <lf94_> Walther, first thing: you should emphasize this is a tutorial for people who are already familiar with traditional imperative or OO programming
00:59:53 <Walther> Mm, nod.
01:01:06 <lf94_> 1 : [2,3]       -- adding to beginning of list
01:01:13 <lf94_> It's called prepending :)
01:01:24 <lf94_> Also mention `:` is called "cons"
01:01:40 <lf94_> (construct list)
01:02:02 <Walther> prepending, cons, noted :)
01:03:10 <jre2> I always felt it was worth explaining why indexing looks ugly
01:03:28 <Walther> hmm?
01:03:40 <jre2> eg. `myList !! 5`
01:03:58 <EvanR> all i want to know is what monad analog you will be using
01:04:00 <lf94_> Walther, your dough analogy...not liking it.
01:04:20 <lf94_> A list is dough? What?
01:04:28 <Jinxit> what
01:04:31 <EvanR> lol
01:04:52 <lf94_> Walther, have you made pizza too?
01:05:00 <MarcelineVQ> Walther: http://www.cse.chalmers.se/~rjmh/Papers/whyfp.pdf is a pretty good primer for FP in case you haven't seen it, the methods it uses to relate ideas to people could be useful for your tutorial
01:05:07 <lf94_> If you have no dough you just don't have pizza period, nevermind the crust...
01:05:41 <gfixler> the QuickCheck docs say this is the wrong thing: [Branch x' l' r' | x' <- shrink x, l' <- shrink l, r' <- shrink r]
01:05:50 <gfixler> because "shrinking will stop once one of the three is fully shrunk"
01:06:02 <gfixler> but doesn't this give the cartesian product of the shrinkings?
01:06:28 <jre2> Walther: I like the aesthetic btw.
01:06:43 <lf94_> Yeah that's one aspect that's really nice - the presentation.
01:06:53 <Walther> lf94_: hehe. I was just going with the idea that dealing with lists is something very basic and very often used
01:07:28 <Walther> MarcelineVQ: ooh, that might be very helpful, thanks!
01:07:32 <Walther> jre2: thanks :)
01:07:59 <Walther> i've honed the .css a lot over the years, use it with all my .html
01:08:19 <lf94_> Walther, I personally think it's confusing, although I understand you're just trying to add some interesting analogies
01:08:46 <Walther> lf94_: what would you do to fix it?
01:08:57 <Walther> how would you go about explaining the concepts better
01:09:18 <lf94_> And like, you're word of warning feels like YOU asking questions to me that I don't really care about
01:09:19 <lf94_> what is head of an empty list? Or tail of it?
01:09:34 <lf94_> Well nothing!
01:09:36 <lf94_> lol
01:09:45 <lf94_> You should word it like
01:10:21 <Walther> hmm
01:10:57 <lf94_> "So we know head takes the first element of a list, and tail everything except the head. What happens if the list is empty, in both cases? Your Haskell program stops, because it's impossible to get an element from nothing."
01:11:20 <lf94_> No analogies to try and candy coat it
01:11:26 <lf94_> Just straight to the point
01:12:07 <lf94_> "Data.List.Safe though provides a way to handle these cases."
01:12:24 <EvanR> :t listToMaybe
01:12:25 <lambdabot> [a] -> Maybe a
01:12:36 <lf94_> Walther, overall everything is nice
01:12:51 <lf94_> Walther, I just *know* from experience the analogies sometimes hurt learning
01:13:11 <lf94_> The analogies really help after presenting an idea
01:13:13 <lf94_> Not before :)
01:13:43 <EvanR> weird analogies for haskell have nothing on trying to learn morse code by reading/writing/imagining dashes and dots on paper
01:14:08 <EvanR> people will get over burritos at some point, you may never be able to unsee those dashes and dots ;)
01:14:12 <jre2> EvanR: been playing the keep talking / bomb game?
01:14:25 <EvanR> i dont know about that one
01:15:21 <Walther> lf94_: good point!
01:15:36 <EvanR> weird analogies for haskell are unavoidable, if nothing else you will encounter them over and over as people communicate about it around you
01:16:02 <EvanR> disengaging from it, and lots of other stuff are a key skill to learn!
01:16:09 <EvanR> unlearning
01:16:40 <lf94_> the weird analogies are fine, it's when they're presented and if the analogy is any good lol
01:17:10 <EvanR> so you end up learning not to trust weird analogies ;)
01:18:01 <gfixler> MarcelineVQ: favorite line from the 2nd page of that paper: Functional programmers argue that there are great material benefits - that a functional programmer is an order of magnitude more productive than his conventional counterpart, because functional programs are an order of magnitude shorter.
01:18:24 <gfixler> MarcelineVQ: so "10x OOP dev" is just code for "FP dev"
01:18:56 <MarcelineVQ> Sometimes :>
01:20:18 <EvanR> then functional programmer ends up doing OOP dev and is 10x slower ;)
01:20:35 <gfixler> EvanR: in my case, 50x slower :(
01:20:39 <EvanR> lol
01:21:48 <EvanR> in reality youll be a better position to identify what kind of horrible things you "just have to do because" and know it makes no sense, and waste no more time thinking about, unlike people inventing new OOP techniques
01:22:23 <gfixler> the problem is I'm identifying *everything* as that, and wasting no more time thinking about any of my work
01:22:33 <gfixler> it really does feel like my work these days is in my way
01:22:48 <gfixler> I used to like work, but now I'm in C# in a *very* OOP system - all callbacks and global state
01:22:51 <gfixler> and it's insanity
01:23:03 <gfixler> I feel like getting better at it will come at the cost of forgetting what good means
01:23:57 <EvanR> keep a journal of epiphanies you have about the system, so you dont foret
01:24:01 <julianleviston> Walther: I’m glad you used years to show Int.
01:24:10 <julianleviston> Walther:  (Int / Num a)
01:24:39 <gfixler> EvanR: yeah, my sanity is held in check by imagining I'm visiting a war-torn area, documenting the craziness to share later
01:27:14 <Walther> julianleviston: hm?
01:27:24 <julianleviston> Walther: why hm?
01:29:04 <julianleviston> Walther: what does all-a-round mean?
01:29:31 <MarcelineVQ> in general
01:29:36 <julianleviston> Walther: do you mean all-round ?
01:29:44 <EvanR> both dont look right
01:29:49 <julianleviston> all-round is correct.
01:29:54 <EvanR> eh...
01:30:03 <MarcelineVQ> That's a pretty coliquial term though
01:30:22 <julianleviston> unless you mean all-around.
01:30:26 <MarcelineVQ> How you write it is gonna depend a lot on your region
01:30:54 <julianleviston> MarcelineVQ: I don’t think there’s a region that has all-a-round is there?
01:31:04 <EvanR> all-around = all-round just you probably wouldnt write it the way you mumble it ;)
01:31:25 <EvanR> and all-a-round is just weird spelling
01:31:29 <Walther> yeah, i was attempting a pun at the roundness of a circle, probably not working :)
01:31:30 <julianleviston> the sentence reads awkwardly IMO: For all-a-round JSON-handling, a package most useful is Aeson.
01:31:46 <Walther> it does, yeah
01:31:59 <julianleviston> Walther: I had to read it twice.
01:32:07 <julianleviston> Walther: puns are fine, so long as they don’t hinder flow.
01:32:20 <julianleviston> Walther: also, it’ll annoy some people a lot.
01:32:20 <Walther> yup,definite proof it needs rewriting
01:32:28 <julianleviston> Walther: just look at how people react to LYAH
01:32:44 <Walther> mm
01:33:28 <julianleviston> Walther: I really didn’t like the head and tail of pizza dough analogy, but that’s just my personal preference, I think. I found it clouds the meaning. No offense!
01:33:53 <EvanR> honestly it sounds hilarious
01:34:04 <EvanR> i vote to keep it
01:34:08 <Guest9999> hi
01:34:30 <Guest9999> is this a hacking channel?
01:34:43 <jre2> haskell hacking
01:34:54 <julianleviston> Guest9999: no, it’s a language for the Haskell programming language. 
01:35:14 <EvanR> meta haskell
01:35:23 <Guest9999> do you know any hackers channel?
01:35:34 <EvanR> try #freenode
01:35:55 <gfixler>  /join #2600
01:36:04 <gfixler> is that still a thing?
01:36:17 <MarcelineVQ> I wonder what resource people keep running into that is suggesting haskell for hacking
01:36:19 <julianleviston> Walther: In this sentence, you might need to use “split it up into” rather than “split it up to”… “Sometimes function definitions get a bit long, and it might be a good idea to split it up to a couple of lines.” 
01:37:03 <Guest9999> marcelineVQ it's on google
01:37:46 <EvanR> MarcelineVQ: use the right tool for the job? ;)
01:38:47 <julianleviston> Walther:  in your section on HTTP, you seem to be in a do block, but there is no explicit do block mentioned.
01:38:54 <Walther> No offense taken, i'm trying to write a helpful tutorial so all constructive feedback is warmly welcome to make it more helpful
01:39:11 <Walther> julianleviston: Yeah, there are unfinished things at the bottom
01:39:56 <julianleviston> Walther:  I’m not sure how your section that talks about deferred evaluation is actually deferred evaluation, is it?
01:40:11 <Guest9999> gfixler do you know other ones?
01:40:35 <Walther> mm, deferred evaluation order / what's it called
01:40:58 <Walther> well, how to explain it in an understandable way what $ is
01:41:09 <Walther> without sounding too mathy for less-mathy people
01:41:12 <EvanR> function application
01:41:22 <EvanR> pretty important
01:42:33 <julianleviston> Walther: I think perhaps it’s best not to mention $ in a beginner’s tutorial.
01:42:42 <julianleviston> Walther: it is one of the sources of confusion.
01:42:56 <EvanR> $ appears a lot in real life code
01:42:58 <julianleviston> Walther: unless you mention it by example… 
01:43:03 <kqr> does a modern GHC (7.10) compile Haskell 98 code? if so, what is the flag to make it do that?
01:43:09 <EvanR> along with <$> and <*> people get very confused
01:43:15 <julianleviston> EvanR: sure… but so does Monat Transformers… and that’s not there either.
01:44:08 <EvanR> julianleviston: i just had a great idea for a haskell tutorial... go over simple and advanced stuff equally in incredibly simple terms, at the any cost
01:44:10 <julianleviston> Walther: it’s pretty easy to give someone an intution of what $ does by example…
01:44:28 <julianleviston> EvanR:  I’m not sure if you’re being sarcastic.
01:44:32 <julianleviston> EvanR:  … anymore. 
01:44:37 <EvanR> im serious
01:44:42 <julianleviston> EvanR:  yes, absolutely.
01:44:44 <Walther> Mm, what do you think of the example i have?
01:45:01 <julianleviston> EvanR: I’ve thought for a long time that it’s a good idea to show many working examples of something.
01:45:04 <gfixler> Guest9999: no, and I just guessed at that one
01:45:43 <julianleviston> Walther: sure, but you’re calling it deferred evaluation. Why not just call it what it is.
01:45:48 <Walther> julianleviston: that was my original idea, a haskell cheatsheet
01:46:05 <Walther> julianleviston: Nod.
01:46:08 <EvanR> julianleviston: in fact if all you do is post the examples with almost no explanation its often considered good enough or even "awesome docs"
01:46:47 <EvanR> Walther: $ isnt deferred evaluation, its function application, just like f x
01:46:48 <julianleviston> EvanR: well, given that the explanations are what trips people up more than not, I think putting the examples first, and then the explanations after would be very good.
01:47:10 <EvanR> julianleviston: yep, tldr, copy pasta
01:47:12 <julianleviston> EvanR:  the best (human) language learning books do this...
01:48:05 <julianleviston> EvanR:  one of my favourites does 7 lessons on examples / carefully worded conversations, and then a lesson on grammar to explain your intuitions and solidify the practice with theory. It’s EXCELLENT.
01:48:20 <EvanR> i think i can turn this into a zine
01:48:32 <EvanR> to attract people to my haskell meetup
01:49:22 <EvanR> paste some real haskell code from hackage, and explain it (in a semi ridiculously too simple manner)
01:49:50 <EvanR> which might be crazy enough o work
02:01:19 <jre2> I'm doing a time travel simulation where agents can change events in the past, handled by different time lines each tracking their own state and simulating them all in parallel every tick
02:01:47 <jre2> Is there any way for me to take advantage of the fact that I'm processing similar (but not equal) state multiple times each step?
02:02:31 <EvanR> your data will be shared in some cases
02:02:37 <EvanR> since its immutable
02:03:13 <julianleviston> EvanR: isn’t that quality actually called Persistent, not Immutable?
02:03:14 <EvanR> but in general an expression like f x will be recomputed unless you save the result somewhere
02:03:30 <EvanR> julianleviston: its called persistent in clojure for some reason
02:03:51 <julianleviston> EvanR: it’s not only clojure, is it?
02:03:51 <EvanR> immutable data has the nice property of easy sharing
02:04:25 <EvanR> i dont really get the word persistent used here
02:04:41 <julianleviston> EvanR: https://en.wikipedia.org/wiki/Persistent_data_structure
02:04:48 <EvanR> ive read that
02:04:55 <EvanR> and talked to clojure people
02:05:00 <julianleviston> EvanR: why don’t you get it? previous copies are persisted.
02:05:06 <EvanR> no they arent
02:05:10 <julianleviston> EvanR: this isn’t a clojure thing.
02:05:44 <EvanR> its a thing in languages where people arent used to immutable data
02:05:47 <EvanR> so its a novelty
02:05:59 <EvanR> but its the wrong word
02:06:00 <julianleviston> EvanR: I don’t see how, but if you say so.
02:06:25 <julianleviston> EvanR: it’s implying the structure is persisting when you make a new thing based on the old thing, isn’t it?
02:06:25 <EvanR> and its also not used in haskell very much, unless youre talking about database persistence, which is actually persistent
02:06:29 <julianleviston> EvanR: what makes it wrong?
02:07:04 <EvanR> data values in haskell get reclaimed very often, its not very persistent
02:07:21 <jre2> EvanR: are there things I can do to get multiple copies of mostly similar data to be shared?
02:07:24 <EvanR> runtime objects*
02:07:50 <EvanR> jre2: there are tricks, though its pretty low level to try that
02:08:28 <EvanR> jre2: a temporal database might make more sense for your game
02:09:18 <EvanR> i.e. be explicitly about what your trying to store and share
02:12:59 <julianleviston> EvanR:  mmm oh well… it’s just weird, because you have have immutable things in all kinds of languages (Like Objective-C for example), but I’m pretty sure they don’t use structural sharing. Maybe “structurally sharing” is what we mean? :)
02:13:24 <EvanR> definitely talking about sharing of immutable data
02:13:48 <jre2> EvanR: the wish for sharing would be for performance reasons (caching, memoization, etc). I don't think I've heard of any high performance temporal dbs
02:14:09 <EvanR> this would be "high performance"
02:14:24 <EvanR> you can use temporal indexing
02:14:29 <EvanR> or any indexing
02:14:44 <EvanR> check out at least the implementation of ixset
02:15:51 <EvanR> julianleviston: also a sharing strategy like this is definitely used in high performance concurrent stuff in C, just because its so insane otherwise
02:16:20 <julianleviston> EvanR: no doubt. I was just saying that immutability doesn’t necessarily have anything to do with data sharing.
02:16:57 <EvanR> it doesnt have to, but without immutability sharing would be kind of absurd to get right
02:17:38 <EvanR> copy on write might be the common strategy for that
02:17:46 <EvanR> which isnt usually called persistent
02:17:58 <EvanR> so its just loosely applied, like homoiconicity
02:36:52 <benl23>   PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
02:36:57 <benl23> 39993 benl      20   0 1609100 860324  41424 R 27.9 84.5   3:11.66 ghc
02:37:04 <benl23> oh GHC, why you so phat
02:37:27 <dm3> wondering if anyone could help me with the stack and ghc-mod problem I'm having - no matter what I try, running ghc-mod gives me "ghc-mod: <command line>: cannot satisfy -package-id base-4.7.0.1-..", ghc-mod debug results in "GHC System libraries: /home/.stack/programs/x86_64-osx/ghc-7.10.2/lib/ghc-7.10.2" and ghc-mod was installed with "stack --install-ghc --no-system-ghc --resolver lts-3.10 install ghc-mod"
02:39:08 <dm3> (complete haskell noob, just setting up my vim according to haskell-vim-now)
02:39:41 <sammecs> dm3: I'm not a very experienced programmer, but maybe you have to install a fork of ghc-mod with extra stack support?
02:40:55 <dm3> haskell-vim-now claims to be working with the normal one, hm
02:41:46 <Wizek> dm3, I may be able to help. Do you also have a GHC 7.8.x install?
02:42:29 <dm3> yep
02:43:01 <dm3> "/usr/bin/ghc@ -> /Library/Frameworks/GHC.framework/Versions/7.8.3-x86_64/usr/bin/ghc"
02:43:10 <dm3> guess that's from some time ago
02:43:49 <Wizek> dm3 Could you try to switch over to that in your path? Last time I tried, stack wasn't quite compatible with 7.10.x
02:44:11 <Wizek> That was a few months ago when I tried
02:44:41 <Wizek> but a weeks ago I was trying to make ghc-mod work, and they weren't supporting 7.10 yet either
02:44:45 <Wizek> only 7.8
02:45:47 <dm3> should I reinstall with something like lts-0.7?
02:46:01 <dm3> to avoid using system ghc
02:46:14 <Wizek> You mean reinstall ghc?
02:49:09 <Wizek> dm3, I'm not sure why you'd want to avoid using system ghc. Could you try running this in your terminal and seeing if it works afterwards? export PATH=/Library/Frameworks/GHC.framework/Versions/7.8.3-x86_64/usr/bin/:$PATH
02:52:20 <dm3> setting the path doesn't make a difference
02:52:39 * hackagebot carettah 0.4.1 - A presentation tool written with Haskell.  https://hackage.haskell.org/package/carettah-0.4.1 (KiwamuOkabe)
02:53:17 <dm3> I switched the resolver to ghc-7.8.3 and stack seems to recognize that it's the system GHC
02:56:49 <mgsloan> dm3: base-4.7.0.0 mean's it's looking for a ghc-7.8 package, but using a ghc-mod compiled for ghc-7.10
02:58:07 <mgsloan> (base-4.8.* is ghc-7.10)
02:58:52 <dm3> ok, wonder what made it do that, as haskell-vim-now obviously compiles and runs on 7.10
03:00:23 <mgsloan> Right!  I'm thinking that the issue is that it's being used on code that uses a 7.8 resolver
03:02:15 <dm3> I was having problems with lts-3.10 resolver which is for 7.10.2
03:03:05 <dm3> I guess I'll try uninstalling system ghc and stack and setting up from scratch
03:08:52 <EvanR> http://www.ebay.com/itm/like/281719485206?ul_noapp=true&chn=ps&lpid=82
03:08:58 <EvanR> oops
03:17:41 * hackagebot deepcontrol 0.4.2.1 - Provide more deeper level style of programming than the usual Control.xxx modules express  https://hackage.haskell.org/package/deepcontrol-0.4.2.1 (KONISHI_Yohsuke)
03:42:42 * hackagebot ContextAlgebra 0.2.0.1 - Context Algebra  https://hackage.haskell.org/package/ContextAlgebra-0.2.0.1 (jhahn)
03:42:44 * hackagebot NearContextAlgebra 0.1.0.2 - Context Algebra of near  https://hackage.haskell.org/package/NearContextAlgebra-0.1.0.2 (jhahn)
03:42:46 * hackagebot servius 1.2.0.1 - Warp web server with template rendering  https://hackage.haskell.org/package/servius-1.2.0.1 (MichaelSnoyman)
03:59:11 <nicow> @free x :: Int
03:59:11 <lambdabot> x = x
04:07:52 * hackagebot pagerduty 0.0.3.3 - Client library for PagerDuty Integration and REST APIs.  https://hackage.haskell.org/package/pagerduty-0.0.3.3 (BrendanHay)
04:28:35 <babygau> Could anyone explain to me `partial type synonym`?
04:28:50 <babygau> An example would be appreciated!
04:32:41 <Gurkenglas> I have a function "Monad m => (a -> m ()) -> a -> ([a] -> m a) -> m Void". This looks like I could use ContT, but there it says that the rs have to be equal? "runContT :: ContT r m a -> (a -> m r) -> m r" What do I do?
04:32:48 <dukeart> hello o/
04:33:28 <pavonia> babygau: For "type Something a b = SomethingElse b a" a partial type synonym application would be e.g. "Something Int"
04:33:56 <pavonia> i.e. it's not not applied to all type parameters
04:34:40 <phaazon> hey, is there a way to provide dependencies in stack like cabal sandbox add-source?
04:35:10 <Gurkenglas> Ah, I see, this isn't Cont, this is just specialized Reader, right?
04:35:11 <phaazon> hm, in packages, sounds to
04:50:00 <slacko1256> I recall a mail to the cafe about a common effort for a torrent client
04:50:19 <slacko1256> did that get published somewhere? If not, what is the most complete library client from where to pick on?
04:52:54 * hackagebot GeocoderOpenCage 0.1.0.1 - Geocoder and Reverse Geocoding Service Wrapper  https://hackage.haskell.org/package/GeocoderOpenCage-0.1.0.1 (jhahn)
04:56:46 <babygau> pavonia tks for your answer, still don't get my head rounds about this :(
04:57:54 <babygau> pavonia for your ex, `Something a b` is a type synonym or `SomethingElse b a`
04:58:20 <babygau> `Something Int` is partial type synonym of `SomethingElse b a`, right?
04:59:30 <pavonia> babygau: "Something a b" is a type synonym for "SomethingElse b a". Note it takes two parameters
05:00:16 <pavonia> babygau: If you appliy it to too few parameters than in the definition, you call is a partially applied type synonym
05:00:29 <pavonia> *call it
05:01:54 <babygau> pavonia So `Something a` is partial type synonym for `SomethingElse b a`, right?
05:02:07 <julianleviston> babygau: it’s important to study these things with a practical, grounded example or two… one that you NEED, rather than theory.
05:02:43 <babygau> hi julianleviston tks you
05:02:45 <julianleviston> babygau: the examples will ground it for you.
05:03:04 <babygau> julianleviston have you got one for me?
05:03:14 <julianleviston> babygau: I’m not sure what you’re doing.
05:03:25 <zomg> babygau: gau is vietnamese for something right? :P
05:03:32 <julianleviston> babygau: it sounds like you’re implementing Functor or something
05:03:49 <babygau> zomg that's rite ;)
05:04:31 <babygau> julianleviston I haven't learned up to that part, sadly
05:04:42 <julianleviston> babygau: what are you trying to do?
05:04:44 <zomg> babygau: haha good, gf is viet and I had a feeling I've heard that word before so I seem to be remembering something at least :P
05:05:15 <babygau> julianleviston I'm learning Haskell on this site http://learnyouahaskell.com/making-our-own-types-and-typeclasses
05:05:27 <julianleviston> babygau: yeah, but what are you trying to learn?
05:05:31 <babygau> julianleviston Just like we can partially apply functions to get new functions, we can partially apply type parameters and get new type constructors from them. Just like we call a function with too few parameters to get back a new function, we can specify a type constructor with too few type parameters and get back a partially applied type constructor. If we wanted a type that represents a map (from Data.Map) from integers to something,
05:05:31 <babygau>  we could either do this:
05:05:48 <babygau> julianleviston type IntMap v = Map Int v  
05:06:01 <babygau> julianleviston Or we could do it like this:
05:06:07 <julianleviston> babygau: explain what the point of this is to me?
05:06:11 <babygau> type IntMap = Map Int
05:06:14 <julianleviston> babygau: like… why would you want to do this?
05:06:32 <babygau> julianleviston Either way, the IntMap type constructor takes one parameter and that is the type of what the integers will point to.
05:06:46 <julianleviston> babygau: I don’t see why you’d want to do that.
05:06:48 <babygau> julianleviston I just copied the text that I don't understand
05:06:51 <julianleviston> babygau: can you explain for me?
05:07:16 <babygau> If I could explain, I understand this already :-P
05:07:56 <julianleviston> babygau: see, the problem with learning this way is you don’t know why you’re learning this.
05:07:59 <babygau> zomg it means "a bear" in vietnamese
05:08:14 <babygau> julianleviston to some degree, you're right!
05:08:25 <julianleviston> babygau: that seems a little strang to me.
05:08:29 <julianleviston> strange*
05:08:36 <babygau> julianleviston why, may I ask?
05:08:49 <julianleviston> babygau: because you’re not in control of your learning.
05:08:55 <zomg> babygau: ahh that's what I thought, that or "pig" =)
05:09:22 <babygau> julianleviston you mean I'm lost, right :(
05:09:30 <julianleviston> babygau: no no, not that.
05:09:59 <babygau> zomg Vietnamese teenagers these days like calling their gr "bear" ^ ^
05:10:01 <julianleviston> babygau: I warned you about this last night - the problem with Learn You a Haskell is that it can get a bit crazy as it goes on… you can lose track of what you’re learning.
05:10:28 <babygau> julianleviston Yes, I noted that, but I have no other resource to learn :(
05:10:35 <zomg> babygau: gr?
05:10:45 <julianleviston> babygau: there are quite a few other resources
05:10:48 <julianleviston> @where CIS194
05:10:48 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
05:10:51 <babygau> zomg it's typo, I meant gf
05:10:53 <julianleviston> babygau: this one is better ^
05:11:23 <julianleviston> babygau: anyway.
05:11:31 <zomg> babygau: ah :P yeah she told me calling someone pig or monkey is cute, which is like the opposite in english... =)
05:11:50 <babygau> julianleviston could you pls explain to me this partial type synonym
05:11:58 <julianleviston> babygau: so, you understand that you can partially apply functions already?
05:12:03 <julianleviston> > 1 + 1
05:12:04 <lambdabot>  2
05:12:04 <babygau> zomg that's really bad zomg 
05:12:08 <julianleviston> :t (1 + 1)
05:12:09 <lambdabot> Num a => a
05:12:10 <babygau> julianleviston yes
05:12:12 <babygau> I do
05:12:15 <julianleviston> :t (1 +)
05:12:16 <lambdabot> Num a => a -> a
05:12:18 <julianleviston> ok good
05:12:26 <julianleviston> babygau: so you know that a type constructor is just a function?
05:12:30 <zomg> babygau: really, I wonder if it's a regional thing
05:12:51 <babygau> julianleviston I think you mean "Value Constructor" right?
05:13:13 <henk> Hi, I have a [(UTCTime, string)]. I want to sort it by UTCTime and then calculate the time deltas between two consecutive entries. I’m currently learning about Functors/Applicatives/Monads but haven’t fully grasped them yet. Does it make sense to create my own type and make it a Functor in this case? How would you do it?
05:13:15 <julianleviston> babygau:  oh sorry… 
05:13:23 <babygau> zomg not at all, sth don't trust your girl, man!
05:13:36 <julianleviston> babygau: Maybe *I* don’t know what I’m talking about ;-)
05:13:47 <julianleviston> babygau: do you know about kinds?
05:13:58 <babygau> julianleviston from what I learnt, there are Type Constructor (Type with parameter)
05:14:11 <julianleviston> babygau: yeah, so you’ve learned about Maybe, yes?
05:14:14 <babygau> julianleviston and Value Constructor
05:14:18 <julianleviston> babygau: and Either?
05:14:20 <zomg> babygau: haha :) I'll have to ask her
05:14:31 <babygau> julianleviston Yes, I might understand it
05:14:42 <babygau> julianleviston data Maybe = Empty | Just
05:14:42 <julianleviston> babygau: ok.
05:14:49 <zomg> babygau: could be some misunderstanding, she speaks english well but occasionally mixes stuff up a bit
05:15:04 <babygau> julianleviston Maybe is a type
05:15:06 <julianleviston> babygau: actually data Maybe a = Nothing | Just a
05:15:16 <julianleviston> babygau: well Maybe is actually a type constructor.
05:15:29 <julianleviston> babygau: Maybe Int is an example of a type.
05:15:30 <babygau> julianleviston but `Maybe a = Nothing | Just a` is Type Constructor
05:15:32 <julianleviston> :t Just 5
05:15:33 <lambdabot> Num a => Maybe a
05:15:41 <julianleviston> there’s a Maybe a with a constrained to num
05:15:46 <babygau> julianleviston yes ^ ^
05:16:09 <julianleviston> babygau: and you’ve used Either?
05:16:10 <babygau> julianleviston pls go on
05:16:34 <babygau> julianleviston `data Either = Left | Right` ????
05:16:49 <Azel> henk: Wouldn't sortBy and then zipWith do the trick?
05:16:57 <babygau> julianleviston  are we slipping off track?
05:17:05 <julianleviston> babygau: I think it’s data Either a b = Left a | Right b
05:17:13 <babygau> zomg Could be?
05:17:26 <babygau> julianleviston Oh, my bad, you're right!
05:17:47 <julianleviston> babygau: so it has two type variables.
05:17:55 <babygau> julianleviston So what does these Maybe, Either relate to `partial type`?
05:18:05 <frerich> henk: There is no benefit in a separate type, let alone a new Functor instead. Instead, you can just use the 'sortBy' and 'comparing' functions to sort your list and then use 'zipWith' to create the adjacent differences.
05:18:09 <julianleviston> babygau: I just had to make sure you understood Maybe
05:18:17 <julianleviston> babygau: before you went on to Either.
05:18:21 <babygau> julianleviston thanks!
05:18:31 <julianleviston> babygau: Because Either has 2 type variables, you can create a partial type for it
05:18:39 <henk> Azel, frerich: yep, sounds sensible. I’ll try that, thank you both (:
05:19:06 <julianleviston> babygau: but I’m not actually sure in what context you need this...
05:19:07 <frerich> Azel: Oh, I missed your response.
05:19:28 <babygau> julianleviston that's why I need an example to clear my head
05:20:06 <julianleviston> babygau: well the only one that springs to my mind is defining a Functor for a two-parameter type constructor, but let me see if I can think of a better one
05:20:10 <babygau> julianleviston Instead of using `Either`, we could use Data.Map as example bcoz Map accept 2 type `Map k v` right?
05:20:48 <babygau> julianleviston In the book, they mention `type IntMap v = Map Int v `
05:21:09 <julianleviston> babygau: guh this way of teaching drives me nuts.
05:21:52 <babygau> julianleviston Sorry, I thought this could be an easier example for you to explain
05:21:56 <julianleviston> babygau: ok… so let’s use their IntMap
05:21:59 <julianleviston> babygau: no it’s fine.
05:22:07 <babygau> julianleviston and next, `type IntMap = Map Int `
05:22:12 <julianleviston> babygau: so IntMap is like a map, but it will ONLY have keys as Ints. 
05:22:16 <julianleviston> babygau: yep.
05:22:17 <babygau> julianleviston they said, these 2 are the same
05:22:34 <julianleviston> babygau: yeah, it’s the same ar partially applied functions.
05:23:22 <julianleviston> babygau: so if you want a map from Int to String, you can say [(1,”Bob”)] :: IntMap String
05:23:41 <julianleviston> babygau: which means [(1,”Bob”)] :: Map Int String
05:24:03 <babygau> julianleviston just right here, wait
05:24:06 <julianleviston> babygau: an IntMap type synonym is useful if you have a lot of Maps you want to build that all only have keys that are Int
05:24:24 <babygau> julianleviston So the original Map has type of `Map k v` right?
05:24:31 <julianleviston> babygau: that’s right.
05:24:48 <babygau> julianleviston so just like partial application function
05:24:50 <julianleviston> babygau: type Map k v = [(k,v)] 
05:24:59 <babygau> julianleviston we can do
05:25:00 <julianleviston> babygau: yeah
05:25:23 <babygau> julianleviston type IntMap = Map Int
05:25:31 <julianleviston> babygau: yep.
05:26:07 <babygau> julianleviston so the next time, we need to use it 
05:26:24 <babygau> julianleviston for example, in type declaration
05:26:28 <julianleviston> babygau: like I said, it’s only useful if you’re building a lot of things that need the key to be Int.
05:26:49 <babygau> julianleviston function :: IntMap k -> String
05:27:16 <babygau> julianleviston we can put any type as function parameter, right?
05:27:26 <julianleviston> babygau: um… that’s correct, kind of, but I’m not sure what the k is… because it’ll be the value.
05:27:50 <julianleviston> babygau: well that’s a function from IntMap k to String
05:28:14 <julianleviston> babygau: can you write me a function that does that?
05:28:23 <julianleviston> babygau: that satisfies that type signature...?
05:28:36 <julianleviston> babygau: so that I can make sure you understand that type signature...
05:29:13 <julianleviston> babygau: if not, that’s ok.
05:29:17 <babygau> julianleviston function [(1, "abc")] = "abc"
05:29:29 <babygau> julianleviston is it correct?
05:29:42 <julianleviston> babygau: not really
05:29:55 <babygau> julianleviston haha
05:29:58 <julianleviston> babygau: I mean, you could write that as one of the patterns of your function, I guess… 
05:30:06 <julianleviston> babygau: but 1 is not k.
05:30:22 <julianleviston> babygau: because k is unqualified… it could be anything… 1 is a Num a
05:30:35 <babygau> julianleviston oh
05:30:39 <julianleviston> babygau: anyway, not important for now
05:31:12 <julianleviston> babygau: do you understand what you wanted to?
05:32:14 <babygau> julianleviston almost there
05:32:21 <julianleviston> babygau: ok. what’s missing?
05:32:51 <babygau> The rest is on me julianleviston. I need to put in in practical use!
05:33:00 <julianleviston> babygau: hehe… yeah.
05:33:16 <babygau> julianleviston All I have done for 2 days are reading, not writing a single codes!
05:33:25 <julianleviston> babygau: oh
05:33:33 <julianleviston> babygau: yeah, I know the feeling
05:33:43 <julianleviston> babygau: though usually when I learn, I have GHCI open, and I fiddle around a lot.
05:33:59 <julianleviston> babygau: or, have a probject and load it into GHCi and reload it a lot, tweaking the code
05:34:03 <babygau> julianleviston I have that too, but could not type in ghci correctly
05:34:39 <babygau> julianleviston always prompt sth like 
05:35:20 <babygau> julianleviston <interactive>:1:1: Not in scope: data constructor ‘IntMap’
05:35:41 <babygau> I can't test with multiple lines of code
05:35:56 <julianleviston> babygau: you can write multiline ghci if you want...
05:36:15 <julianleviston> but you’re better off using a file, and loading it in with the :load command
05:36:35 <julianleviston> then once it’s loaded, you can use :r for :reload to reload that file after you change it in your text editor.
05:36:50 <babygau> julianleviston let's me give it a go now
05:37:08 <julianleviston> babygau: if you want multiline mode, use :set +m in ghci
05:37:25 <julianleviston> babygau: but I recommend the file thing I was sayign before.
05:37:51 <Mateon1> Hello. I'm trying to solve a programming challenge, to calculate e^x [for Double x] using the 1+x+x^2/2!+x^3/3!+... expansion for the first 10 terms. I could just hardcode the sum, but I don't want to do that. I've tried solving it using: f x = sum [x^n / product [1..n] | n <- [0..10]], but I get a typecheck error "No instance for (Integral Double) arising from a use of `^`". I don't understand why.
05:38:21 <julianleviston> :t (^)
05:38:22 <lambdabot> (Integral b, Num a) => a -> b -> a
05:38:36 <julianleviston> @info Double
05:38:36 <lambdabot> Double
05:38:42 <julianleviston> oops.
05:38:43 <Mateon1> I've checked the type of every subexpression, and I don't quite know what causes this. Every subexpression in the list works, but the list itself has elements of type Integral a, Double a => a
05:38:53 <ggole> Sounds like you want (**)
05:39:36 <julianleviston> Mateon1: Double “is not an” Integral
05:39:48 <julianleviston> :t (**)
05:39:50 <lambdabot> Floating a => a -> a -> a
05:40:09 <julianleviston> hm.
05:40:14 <babygau> julianleviston Parse error: naked expression at top level
05:40:28 <Taneb> :t (^^)
05:40:29 <lambdabot> (Fractional a, Integral b) => a -> b -> a
05:40:32 <julianleviston> babygau: what are you trying to do?
05:41:01 <babygau> I pasted an example from the website to a file name main.hs, then go to ghci, use `:load main.hs`
05:41:27 <julianleviston> babygau: there’s an error in your file.
05:41:36 <Mateon1> Hm, that's very odd. `n` should be Integral, and the type (^) :: Integral b, Num a => a -> b -> a doesn't seem to conflict with my usage. I still don't understand why the previous one didn't work
05:41:37 <julianleviston> babygau: you need to define definitions in that file, not expressions.
05:41:55 <julianleviston> Mateon1: but Double isn’t Integral is it?
05:42:21 <julianleviston> Mateon1: aren’t you raising to a Double power in your code?
05:42:31 <Mateon1> I'm raising Double ^ Integral n -> Double.. I know the Double isn't an Integral
05:42:58 <Mateon1> n comes from n <- [0..10]
05:43:14 <julianleviston> (1.0 : Double)
05:43:19 <julianleviston> > (1.0 : Double)
05:43:21 <lambdabot>      Not in scope: data constructor ‘Double’
05:43:21 <lambdabot>      Perhaps you meant variable ‘double’ (imported from Text.PrettyPrint.Hugh...
05:43:33 <julianleviston> > (1.0 :: Double)
05:43:34 <lambdabot>  1.0
05:43:52 <julianleviston> > (10.0 :: Double) ^ (2 :: Integral)
05:43:53 <lambdabot>      Expecting one more argument to ‘Integral’
05:43:53 <lambdabot>      Expected a type, but ‘Integral’ has kind ‘* -> Constraint’
05:43:53 <lambdabot>      In an expression type signature: Integral
05:44:04 <julianleviston> > (10.0 :: Double) ^ (2 :: Integer)
05:44:05 <lambdabot>  100.0
05:44:35 <babygau> julianleviston many thanks. I think I will need to learn more and more :)
05:44:42 <lpaste> SK0 pasted “What's this?” at http://lpaste.net/143845
05:44:45 <SK0> ^
05:44:49 <SK0> is this expected?
05:44:51 <julianleviston> babygau: feel free to pastie your code and I’ll help
05:45:54 <ggole> Doesn't that constraint comes from (/), not (^^)?
05:46:10 <Mateon1> SK0, you're negating the result
05:46:17 <Mateon1> > (-11.114875526105088) ** 2.3
05:46:17 <babygau> julianleviston http://lpaste.net/143846
05:46:19 <lambdabot>  NaN
05:47:24 <julianleviston> babygau: lockerLookup 101 lockers is the naked expression
05:47:43 <julianleviston> babygau: if you set up a definiton for that expression, you can then just type it in at the ghci prompt after loading the file
05:47:50 <julianleviston> babygau: say test = lockerLookup 101 lockers
05:48:45 <SK0> Mateon1. For which numbers is NaN expected with (/)?
05:48:53 <babygau> oh I get it julianleviston 
05:49:11 <SK0> Is it floating point error?
05:49:59 <SK0> with (**)*
05:50:12 <babygau> julianleviston yay, I got it worked!
05:50:17 <julianleviston> babygau:  :) cool
05:50:27 <julianleviston> babygau: little steps are your friend.
05:50:37 <babygau> julianleviston are you OZ ^ ^
05:50:41 <julianleviston> babygau: I am.
05:51:05 <babygau> julianleviston nice to meet you! are there any haskell meet up in Melbourne?
05:51:13 <julianleviston> babygau: I don’t know. I’m not there.
05:52:06 <babygau> julianleviston Anyways, thanks so much for your help! My aim at the moment is to get my head rounds with Functor, Applicative and Monads!
05:52:19 <julianleviston> babygau: oh
05:52:31 <julianleviston> babygau: seriously, check out the CIS194 stuff… it’ll help.
05:53:05 <julianleviston> babygau: you should look at Monoids and Semigroup before Functor, in my opinion.
05:53:39 <babygau> julianleviston thank you, I forgot telling you I'm on that site already :D
05:53:47 <julianleviston> ok cool :)
05:54:44 <babygau> I know JavaScript, run into some write-ups about Monads the other day, and that's why I'm here with you, lol, quite a journey!
05:55:28 <julianleviston> babygau: haha why are you learning Haskell??
05:56:06 <julianleviston> babygau: can talk about this in #haskell-blah
05:57:33 <srhb> SK0: Uhh.. If I'm not completely too tired to answer this legitimately, it seems you're trying to represent a complex number as a Floaty type
05:59:04 <ggole> Mateon1: have you figured it out?
05:59:30 <Mateon1> Not yet, I'm still testing. (**) does work, but I'm not sure why (^) doesn't
05:59:31 <babygau> julianleviston A major reason is I cannot get my head rounds about Monads when learning it from JavaScript examples :D
05:59:56 <julianleviston> babygau: I don’t understand what that means, sorry
06:00:04 <ggole> Mateon1: it's because of the combination of (^^) (or whatever) and (/)
06:00:35 <babygau> julianleviston that's OK. Here is my first question on SO about it http://stackoverflow.com/questions/33297242/why-monads-bind-method-must-return-a-func-which-then-return-a-monad
06:00:35 <ggole> Think about it like this: the type of product [1..n] is the same as the type of n, so we have basically x^^n / n
06:00:58 <ggole>  / requires the same type on both sides, so x has the same type as n
06:01:08 <babygau> julianleviston But I couldn't find the answer I want, so I jumped to Haskell :D
06:01:16 <aweinstock> (pure x >>= f) == (fmap f x)?
06:01:23 <julianleviston> babygau:  oh ok.
06:01:24 <ggole> ^^ requires an integral second argument, so the type of x and n is both integral.
06:01:32 <srhb> > (-11.114875526105088) ** 2.3 :: Complex Double
06:01:33 <lambdabot>  149.5544270108994 :+ (-205.84400946422718)
06:02:27 <Xnuk> :t (**)
06:02:28 <lambdabot> Floating a => a -> a -> a
06:02:32 <ggole> So to use (^) I think you need an explicit conversion to float on the right hand side of that (/).
06:02:52 <babygau> julianleviston tks u again, will afk to prepare for derby match between MU and ManCity today ^ ^
06:03:39 <zomg> babygau: btw gf said pig is some kind of cute word for younger people to call others, apparently
06:04:06 <babygau> zomg only when they're very very close ;)
06:04:17 <zomg> yeah that's what it sounded like
06:04:19 <zomg> :)
06:05:05 <babygau> zomg +1
06:05:20 <Mateon1> ggole: I think I found the issue... It is in fact because of a mix of reasons. :t product [1..(3::Integer)]  is :: Integer; :t (/ (6::Integer)) fails to typecheck
06:05:38 <Mateon1> Also, :t (/) is Floating a => a -> a -> a
06:06:01 <srhb> Mateon1: That's what ggole said, too. :-)
06:06:52 <Mateon1> Well, glad I got it sorted out :) Thanks
06:08:19 <ggole> So it's (**) or f x = sum [x^n / fromIntegral (product [1..n]) | n <- [0..10]], right?
06:08:46 * ggole is still a bit uncertain about conversions in Haskell
06:10:45 <srhb> Looka right to me. ^ implies that n is Integral, you convert the divisor to some floaty type.
06:11:09 <srhb> :t \x -> sum [x^n / fromIntegral (product [1..n]) | n <- [0..10]]
06:11:11 <lambdabot> Fractional a => a -> a
06:11:13 <srhb> Yup.
06:11:50 <ggole> Righto.
06:12:18 <Mateon1> Could you also do x ^ toIntegral n?
06:12:27 <srhb> Mateon1: Yes, except there's no toIntegral
06:12:35 <srhb> Mateon1: round, floor, ceil...
06:13:57 <Mateon1> Makes sense.
06:14:25 <srhb> :t \x -> sum [ x ^ round n / product [1..n] | n <- [0..10]]
06:14:26 <lambdabot> (Enum a, RealFrac a) => a -> a
06:14:53 <srhb> I like the other way around better.
06:45:58 <henk> Azel: correction: I’m not sure if zipwith works. I have one list of [(UTCTime, String)] and need the time deltas between two consecutive entries. Are you sure zipWith can do that? I can’t quite figure out how. hm, unless I do "zipWith foo mylist (tail mylist)" or something similar?
06:46:44 <xplat> henk: that's exactly how you do it.  or 'drop 1 mylist' if you're not sure there are any entries
06:47:48 <xplat> (i mean, assuming you don't want to rely on obscure strictness properties of zipWith)
06:48:06 <xplat> > zipWith (+) [] (tail [])
06:48:08 <lambdabot>  []
06:48:13 <xplat> > zipWith (+) (tail []) []
06:48:15 <lambdabot>  *Exception: Prelude.tail: empty list
06:48:47 <henk> xplat: ah ok, thank you (:
06:54:49 <epta> Is there a way to get rid of useless values and do smth like ':t (+1) `fmap` (_ :: Either String Int)' instead of ':t let a :: Either String Int; a = a; in (+1) `fmap` a' ?
06:55:57 <epta> epta: s/_/undefined/ and it works, never mind :)
07:03:00 * hackagebot mustache 0.4.0.0 - A mustache template parser library.  https://hackage.haskell.org/package/mustache-0.4.0.0 (justus)
07:08:39 <ankitk> hi, I have written a small program to understand Monad Transformers. However it is not compiling. Can someone please help me understand what the error is? I have pasted the compilation output as well -> http://pastebin.com/AQQR9Wwn
07:13:00 * hackagebot wai-devel 0.0.0.2 - A web server for the development of WAI compliant web applications.  https://hackage.haskell.org/package/wai-devel-0.0.0.2 (urbanslug)
07:14:21 <qolen> glguy: Thanks! I just got the -threaded message.
07:16:50 <bit-shifter_> would anyone be offer assistance in setting up leksah on mac - I appear to have got myself in a spot of bother by building and seemingly replacing gtk3
07:17:35 <bit-shifter_> not only can I not continue the installation due to missing libs, but I am also now unable to build vim
07:18:53 <pavonia> ankitk_: runErrorT needs an ErrorT value but you gave it an Either value
07:22:44 <ankitk_> pavonia : I changed my ExMonad type to 
07:22:45 <ankitk_> type ExMonad a = WriterT String (StateT Count (ErrorT String)) a
07:23:01 <ankitk_> now getting error :   Expecting one more argument to ‘ErrorT String’
07:24:15 <pavonia> Yes, you need an inner-most monad stack level, try (ErrorT Identity String)
07:25:07 <pavonia> No, ErrorT String Identity, the error type comes first
07:28:50 <ankitk_> Thanks a lot pavonia, I changed to  (ErrorT String Identity) and it works now :)
07:29:30 <SrPx>  I'm having the "ghc-pkg: cannot find package Test" in a project that was previously working fine, using `stack install`. How?
07:30:41 <pavonia> No problem
07:56:02 <nobos> concat . zipWith (\y -> map (\(x,c)-> (x,y,c))) [0..] $ map (zip [0..]) ["ABCDE","  FG"]
07:56:30 <nobos> is there a better/more obvious way to do this? (get all positions in a 2D list)
07:57:19 <nobos> @run concat . zipWith (\y -> map (\(x,c)-> (x,y,c))) [0..] $ map (zip [0..]) ["ABCDE","  FG"]
07:57:21 <lambdabot>  [(0,0,'A'),(1,0,'B'),(2,0,'C'),(3,0,'D'),(4,0,'E'),(0,1,' '),(1,1,' '),(2,1,...
07:58:17 <nobos> so I'd like to get the positions of all elements in a 2D list
07:58:23 <nobos> and while my code works
07:58:30 <nobos> it looks fugly
07:58:55 <nobos> I'm assuming I'm missing something obvious here?
07:59:57 <julianleviston> nobos: you mean combinations?
08:00:30 <nobos> bg: I'm writing a small game to learn haskell
08:00:37 <julianleviston> permutations?
08:00:54 <nobos> julianleviston: I'd like to get the 2D position of every char in a list of strings
08:01:03 <julianleviston> nobos: I don’t know what that means
08:01:12 <julianleviston> nobos:  what’s a 2D position?
08:01:23 <nobos> julianleviston: when you have a list of lists
08:01:40 <julianleviston> nobos: yeah, but what do *you* mean here?
08:01:42 <nobos> julianleviston: I'd like to know for every element the index of the element
08:02:03 <julianleviston> nobos: I don’t know how you’re defining x, and y, though.
08:02:24 <nobos> julianleviston: x starts from 0 and is the position in the inner list
08:02:38 <nobos> julianleviston: y starts from 0 and is the position in the outer list
08:02:49 <julianleviston> [[1,2,3],[4,5,6],[6,7,8]] … is 4 (2,1) or (1,2) ?
08:03:25 <julianleviston> I’m guessing 2,1.
08:03:38 <nobos> julianleviston: yes
08:03:41 <julianleviston> ok
08:03:49 <nobos> julianleviston: or 0,1 if you count from 0
08:04:04 <julianleviston> you mean 1,1 if you count from 0.
08:04:12 <julianleviston> oh… 1,0.
08:04:38 <nobos> julianleviston: (position in inner list, position in outer list)
08:04:55 <julianleviston> nobos: ah, ok… so the reverse of what I assumed. Ok.
08:05:12 <julianleviston> nobos: well, do it on the inner list first...
08:05:25 <julianleviston> nobos: (divide and conquer style)
08:05:33 <nobos> julianleviston: I did it like that:
08:05:40 <nobos> @run concat . zipWith (\y -> map (\(x,c)-> (x,y,c))) [0..] $ map (zip [0..]) ["ABCDE","  FG"]
08:05:41 <lambdabot>  [(0,0,'A'),(1,0,'B'),(2,0,'C'),(3,0,'D'),(4,0,'E'),(0,1,' '),(1,1,' '),(2,1,...
08:06:01 <nobos> julianleviston: but it looks really ugly IMO
08:06:12 <julianleviston> nobos:  so refactor it?
08:06:24 <julianleviston> nobos: into a couple os smaller functions, maybe ?
08:06:43 <nobos> julianleviston: ok, I will do that; I was just assuming I was missing something obvious here
08:06:58 <nobos> julianleviston: hence my question ;)
08:07:21 <julianleviston> oh sorry I’m not helping.
08:07:54 <nobos> julianleviston: no, you were; apparently there's nothing OOTB in prelude for this ;)
08:08:14 <julianleviston> OOTB?
08:08:27 <julianleviston> out of the … ?
08:08:32 <nobos> julianleviston: Out of the box :p
08:08:35 <julianleviston> oh
08:09:14 <julianleviston> I feel like there could be a better way to do it tho
08:09:14 <nobos> julianleviston: maybe I could try something with <$> for arrays?
08:12:06 <nobos> @run (\x y -> (x,y) ) <$> ["abc","123"] <*> ["efg","456"]
08:12:08 <lambdabot>  [("abc","efg"),("abc","456"),("123","efg"),("123","456")]
08:13:15 <Black0range> Hello just found out about Template haskell quasi quotation. Does anyone have reccomendations about what libraries are "the best"  
08:14:29 <nobos> @run (\x y -> (x,y) ) <$> [0..4] <*> [0..6]
08:14:31 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(1,0),(1,1),(1,2),(1,3),(1,4),(1,...
08:14:41 <nobos> @run (\x y -> (x,y) ) <$> [0..2] <*> [0..2]
08:14:42 <lambdabot>  [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)]
08:16:37 <pavonia> Black0range: Libraries for what?
08:17:08 <Black0range> things such as http://hackage.haskell.org/package/QuasiText-0.1.2.5
08:20:11 <nobos> julianleviston: found something a little more elegant by starting from the outer list:
08:20:18 <nobos> @run concatMap (\(y,x) -> zip3 (repeat y) [0..] x) $ zip [0..] ["ABCDE","  FG"]
08:20:19 <julianleviston> yeah?
08:20:19 <lambdabot>  [(0,0,'A'),(0,1,'B'),(0,2,'C'),(0,3,'D'),(0,4,'E'),(1,0,' '),(1,1,' '),(1,2,...
08:20:27 <julianleviston> taht’s nicer
08:20:47 <nobos> julianleviston: ah, x & y are reversed, sec
08:21:17 <nobos> @run concatMap (\(y,x) -> zip3 [0..] (repeat y) x) $ zip [0..] ["ABCDE","  FG"]
08:21:19 <lambdabot>  [(0,0,'A'),(1,0,'B'),(2,0,'C'),(3,0,'D'),(4,0,'E'),(0,1,' '),(1,1,' '),(2,1,...
08:21:24 <julianleviston> i think two functions might be nicer.
08:21:58 <nobos> julianleviston: agreed; ta
08:22:05 <julianleviston> nobos: I’m working on something
08:22:36 <nobos> julianleviston: ?
08:22:58 <julianleviston> nobos: I’m working on making two nicer functions. 
08:24:07 <julianleviston> @let mkIdxTuple i xs = zipWith (\c i2 -> (c,i,i2)) xs [0..]
08:24:09 <lambdabot>  Defined.
08:24:20 <julianleviston> > mkIdxTuple 0 "hello"
08:24:21 <lambdabot>  [('h',0,0),('e',0,1),('l',0,2),('l',0,3),('o',0,4)]
08:24:30 <julianleviston> nobos:  is this right for the inner one?
08:24:38 <julianleviston> or have I got the nums flipped?
08:25:24 <ggole> Why the i?
08:25:38 <ggole> Or will that be the row number?
08:26:00 <nobos> julianleviston: sec
08:26:11 <julianleviston> k
08:26:14 <nobos> julianleviston: 
08:26:18 <julianleviston> gabiruh: i for index.
08:26:24 <nobos> julianleviston: they are flipped
08:26:30 <julianleviston> ggole: i for index.
08:26:36 <julianleviston> nobos:  ok I’ll flip them.
08:26:45 <nobos> @run concatMap (\(y,x) -> zip3 [0..] (repeat y) x) $ zip [0..] ["Hello","World!"]
08:26:46 <lambdabot>  [(0,0,'H'),(1,0,'e'),(2,0,'l'),(3,0,'l'),(4,0,'o'),(0,1,'W'),(1,1,'o'),(2,1,...
08:27:28 <ggole> julianleviston: well, you have i and i2. I was wondering what the first was.
08:27:39 <julianleviston> ggole: ah ok… I’ll make that more explicit.
08:28:04 <julianleviston> @let mkIdxTuple outerIdx xs = zipWith (\c innerIdx -> (c,innerIdx,outerIdx)) xs [0..]
08:28:05 <lambdabot>  .L.hs:148:1: Warning:
08:28:05 <lambdabot>      Pattern match(es) are overlapped
08:28:05 <lambdabot>      In an equation for ‘mkIdxTuple’: mkIdxTuple outerIdx xs = ...
08:28:11 <julianleviston> hm.
08:28:18 <ggole> Right.
08:28:26 <ggole> j might be enough to suggest that
08:28:41 <ggole> Or row
08:28:54 <julianleviston> ggole: all seems pretty much preference to me.
08:29:11 <julianleviston> how do I unlet?
08:29:17 <julianleviston> @unlet mkIdxTuple
08:29:18 <lambdabot>  Parse failed: TemplateHaskell is not enabled
08:29:19 <andromeda-galaxy> julianleviston, nobos: mkIdxTuple j xs = zip3 xs [0..] (repeat j)
08:29:27 <julianleviston> ooh
08:29:30 <julianleviston> that’s boss.
08:29:37 <andromeda-galaxy> @undef mkIdxTuple
08:29:37 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
08:29:42 <julianleviston> ah I love Haskell. I just wish I knew how to use it better.
08:31:07 <nobos> andromeda-galaxy: that's what I kind of have in my code
08:31:21 <nobos> andromeda-galaxy: concatMap (\(y,x) -> zip3 [0..] (repeat y) x) $ zip [0..] ["Hello","World!"]
08:32:01 <nobos> andromeda-galaxy: is there a zip for 2D lists?
08:32:07 <andromeda-galaxy> nobos: ah, I see
08:32:15 <andromeda-galaxy> I don't know of one....
08:32:26 <andromeda-galaxy> @hoogle [[a]] -> [[b]] -> [[(a,b)]]
08:32:28 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
08:32:28 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
08:32:28 <lambdabot> Data.ByteString.Builder.Prim (>*<) :: Monoidal f => f a -> f b -> f (a, b)
08:32:57 <andromeda-galaxy> @pl (\j xs -> zip3 xs [0..] (repeat j)
08:32:58 <lambdabot> (line 1, column 35):
08:32:58 <lambdabot> unexpected end of input
08:32:58 <lambdabot> expecting variable, "(", operator or ")"
08:33:01 <andromeda-galaxy> @pl (\j xs -> zip3 xs [0..] (repeat j))
08:33:01 <lambdabot> flip (flip zip3 [0..]) . repeat
08:33:17 <nobos> andromeda-galaxy: lol
08:33:26 <andromeda-galaxy> > zipWith (flip (flip zip3 [0..]) . repeat) [0..] ["ABCDE", " FJ"]
08:33:27 <lambdabot>  [[('A',0,0),('B',1,0),('C',2,0),('D',3,0),('E',4,0)],[(' ',0,1),('F',1,1),('...
08:33:45 <julianleviston> god that’s ugly.
08:33:52 <julianleviston> and somewhat incomprehensible
08:34:03 <andromeda-galaxy> semantic editor combinators might be able to make it nice...
08:34:33 <nobos> @pl concatMap (\(y,x) -> zip3 [0..] (repeat y) x) $ zip [0..] ["Hello","World!"]
08:34:33 <lambdabot> uncurry (zip3 [0..] . repeat) =<< zip [0..] ["Hello", "World!"]
08:34:43 <andromeda-galaxy> oh wait, that's backwards...
08:34:51 <andromeda-galaxy> @pl \j -> zip3 [0..] (repeat j)
08:34:51 <lambdabot> zip3 [0..] . repeat
08:35:07 <andromeda-galaxy> >zipWith (zip3 [0..] . repeat) [0..] ["ABCDE", " FJ"]
08:35:17 <nobos> andromeda-galaxy: is this pl tool available in ghci?
08:35:22 <nobos> andromeda-galaxy: I'll check
08:35:28 <andromeda-galaxy> nobos: no, it's a lambdabot thing
08:35:32 <andromeda-galaxy> > zipWith (zip3 [0..] . repeat) [0..] ["ABCDE", " FJ"]
08:35:34 <lambdabot>  [[(0,0,'A'),(1,0,'B'),(2,0,'C'),(3,0,'D'),(4,0,'E')],[(0,1,' '),(1,1,'F'),(2...
08:36:15 <julianleviston> andromeda-galaxy: ah you rock.
08:36:15 <hnfmr> what is the best way to increment record field by 1? e.g. R { a :: Int, b :: Int}, r = R { a = 10, b = 99} if I want to increment a....
08:36:16 <andromeda-galaxy> > concat $ zipWith (zip3 [0..] . repeat) [0..] ["ABCDE", " FJ"]
08:36:18 <lambdabot>  [(0,0,'A'),(1,0,'B'),(2,0,'C'),(3,0,'D'),(4,0,'E'),(0,1,' '),(1,1,'F'),(2,1,...
08:37:13 <nobos> hnfmr: lenses ? https://ocharles.org.uk/blog/posts/2012-12-09-24-days-of-hackage-lens.html
08:37:29 <julianleviston> hnfmr: define “best”!
08:37:33 <andromeda-galaxy> hnfmr: the shortest way is probably with lenses, without them, record accessors
08:38:01 <andromeda-galaxy> hnmfr: r { a = 1 + a r }
08:38:11 <hnfmr> all right, the shortest would be "better" one, I will try out lens
08:38:15 <hnfmr> thanks
08:38:35 <julianleviston> I think the record-accessor way is fine, isn’t it? you’re only incrementing, afterall.
08:38:54 <julianleviston> hnfmr: If you haven’t used Lens, you might find the learning curve is significant.
08:39:05 <andromeda-galaxy> julianlevistion: lens, I think (untested): a %~ (+1) $ r
08:39:06 <hnfmr> yes, but it feels weird..
08:39:24 <nobos> julianleviston: hnfmr the link I posted is a good intro to lens IMO
08:39:27 <julianleviston> andromeda-galaxy: how long have you been haskelling?
08:39:28 <int-e> andromeda-galaxy: hmm your code turned out surprsingly neat and comprehensible
08:39:34 <hnfmr> nobos: thanks :)
08:39:54 <andromeda-galaxy> julianleviston, int-e: thanks!  I'm not really sure how long it's been, probably a year-ish?
08:40:10 <julianleviston> andromeda-galaxy: cool :)
08:40:32 <andromeda-galaxy> julianleviston: thanks!
08:40:53 <nobos> @run concat $ zipWith (zip3 [0..] . repeat) [0..] ["ABCDE", " FJ"]
08:40:55 <lambdabot>  [(0,0,'A'),(1,0,'B'),(2,0,'C'),(3,0,'D'),(4,0,'E'),(0,1,' '),(1,1,'F'),(2,1,...
08:41:05 <julianleviston> that makes me happy.
08:41:08 <andromeda-galaxy> hnfmr: a +~ 1 $ r, I think
08:41:12 <andromeda-galaxy> (with lens)
08:41:31 <lynnard> How can I have inline datatypes?
08:41:33 <nobos> andromeda-galaxy: wow, that's indeed pretty elegant; I need to take a close look at this
08:41:34 <julianleviston> andromeda-galaxy: lens makes things pretty tiny :)
08:41:50 <hnfmr> andromeda-galaxy: thx
08:41:54 <andromeda-galaxy> nobos, julianleviston: indeed!  lens has *lots* of operators for making things easy...
08:41:56 <andromeda-galaxy> hnfmr: np
08:42:37 <julianleviston> lynnard: what do you mean exactly?
08:42:46 <lynnard> define a new datatype inside a function
08:42:51 <lynnard> and only used there
08:42:59 <julianleviston> lynnard: oh… can you do that?
08:43:08 <lynnard> I'm not sure... therefore asking
08:43:14 <julianleviston> lynnard: have you tried it?
08:43:17 * hackagebot postgresql-typed 0.4.2 - A PostgreSQL access library with compile-time SQL type inference  https://hackage.haskell.org/package/postgresql-typed-0.4.2 (DylanSimon)
08:43:53 <julianleviston> lynnard: seems to be impossible: http://stackoverflow.com/questions/23318643/haskell-defining-a-new-data-type-with-function-scope
08:44:27 <lynnard> julianleviston: hehe thanks, not exactly the solution I want but anyway
08:44:31 <julianleviston> unless there’s some extension.
08:44:53 <lynnard> yeah, guess so; although I'm not particular in need of such a feature
08:58:18 <drmoob> want to see something hideous? http://lpaste.net/8878866130152718336 trying to do http://json.org/number.gif and it seems to work as I expect, but any suggestion how to improve it since it dont seem efficient with all these concats?
08:58:35 <drmoob> I am using parsec
09:00:54 <hpc> drmoob: is this an exercise or homework or something?
09:01:03 <hpc> there's oodles of existing json parsers that are very very good
09:01:53 <drmoob> this is just to try out parsec
09:01:58 <drmoob> and become better
09:02:05 <hpc> ah cool
09:02:15 <drmoob> and perhaps create a vim plugin for fun to check json syntax
09:02:44 * hpc reads
09:03:07 <ebzzry> Is RWO still relevant?
09:04:04 <hpc> using read there is kinda funny
09:04:14 <hpc> but i would do the same thing
09:05:17 <hpc> actually, your code looks good
09:05:22 <hpc> i wouldn't change anything
09:05:35 <ChristianS> ebzzry: what's RWO?
09:05:57 <julianleviston> maybe RWH
09:06:01 <drmoob> hpc: heh ok good to hear, it is a bit wonky but I could not just throw it in without checking since for example read would allow many leading zeros, hex and so on
09:06:32 <hpc> > read "0.543e18"
09:06:33 <lambdabot>  *Exception: Prelude.read: no parse
09:06:36 <hpc> > read "0.543e18" :: Double
09:06:38 <lambdabot>  5.43e17
09:06:43 <hpc> yeah, should be fine
09:07:06 <drmoob> > read "00.543e18" :: Double
09:07:07 <lambdabot>  5.43e17
09:07:15 <hpc> you forbid everything that could be weird, and you use optional correctly
09:07:26 <hpc> so read should only get appropriate strings
09:08:22 <drmoob> alright, thanks for reading
09:09:43 <k0ral> Hello
09:13:47 <k0ral> say I have a large `tree :: Tree a`, and I `prune k` it to the `k` first levels; how will the resulting program behave: will it make a deepcopy of the first `k` levels, or will it reuse the original object ? does the answer depend on the way I implement `prune` ?
09:14:46 <jg_> hi all. I've spotted a "*>" operator while reading haskell code. Where do i even start looking for documentation?
09:15:03 <julianleviston> jg_: use hoogle
09:15:04 <k0ral> jg_: hoogle ?
09:15:14 <pavonia> hayoo
09:15:21 <julianleviston> jg_: it’s applicative’s equivalent to >> though, I think.
09:15:26 <andromeda-galaxy> k0ral: haskell.org/hoogle
09:15:29 <andromeda-galaxy> @hoogle (*>)
09:15:31 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
09:15:31 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
09:15:31 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
09:15:56 <jg_> ohh, i need to use parens instead of quotes in hoogle
09:16:10 <jg_> that was the problem. Many thanks!
09:16:16 <julianleviston> jg_: quotes?
09:16:16 <andromeda-galaxy> jg_: np
09:16:25 <int-e> k0ral: you can implement prune such that the unpruned parts of the tree are reused, but this requires some extra effort; the nodes of the pruned part have to be recreated from scratch.
09:16:32 <julianleviston> jg_: the parens are because it’s an operator
09:18:29 <k0ral> int-e: any reference on the topic, about that "extra effort" ?
09:20:00 <k0ral> basically, I am implementing an iterative deepening algorithm, so I'm iteratively pruning a big tree until level `k` for multiple values of `k`; I'd like to avoid deepcopying the tree each time
09:20:03 <int-e> k0ral: no reference; the idea is to have "prune" return information whether the resulting tree differs from the original (as a Bool value, say).
09:21:55 <Gurkenglas> I have a type that can implement an equality check but needs monadic effects to do it. Can I still use == or something of the sort somehow?
09:22:18 <ebzzry> ChristianS: julianleviston: Ah. Yes, RWH. Is it?
09:22:27 <int-e> k0ral: I'm wondering, isn't the point of iterative deepening to never store the whole tree, and instead work on just a current path from the root? If you can hold the tree in memory, breadth first search seems to be more appropriate...
09:22:33 <julianleviston> ebzzry: do you mean real world haskell?
09:22:46 <k0ral> int-e: not sure I'm following you: the resulting tree is always the same as the original one for the first `k` levels, what's the point of that Bool value ?
09:22:51 <ebzzry> julianleviston: yes
09:23:24 <julianleviston> ebzzry: It’s pretty old
09:23:40 <k0ral> int-e: in my case, the point of iterative deepening is to avoid evaluating the complete tree; it's a matter of time, not of space
09:23:50 <ebzzry> julianleviston: what's a better book?
09:24:19 <julianleviston> ebzzry: haskellbook.com
09:24:36 <julianleviston> ebzzry: it’s quite different tho… haskellbook is for beginners, really.
09:24:55 <andromeda-galaxy> julianleviston: hmm, I hadn't seen that...
09:25:19 <lynnard> say I've got a list of [m a], how can I keep executing the elements inside this list until some condition m Bool returns true and then returns a m [a] ?
09:25:21 <julianleviston> andromeda-galaxy: hadn’t seen what? the haskell book?
09:25:23 <ebzzry> julianleviston: What book replaces RWH, for non-beginner use?
09:25:34 <andromeda-galaxy> yes, the haskell book.  So far, I've been recommending RWH+LYAH+lots of reading of Hackage docs+StackOverflow to explain the changes from RWH/LYAH
09:25:40 <julianleviston> ebzzry: If you’re not a beginner, you can use RWH
09:25:48 <julianleviston> andromeda-galaxy: I really dislike LYAH
09:26:16 <ebzzry> julianleviston: what made you dislike LYAH?
09:26:17 <julianleviston> andromeda-galaxy: it skips too much, goes to quickly and while it seems approachable and has cartoons it’s actually more damaging because it goes so fast.
09:26:35 <julianleviston> ebzzry: don’t get me wrong, it can be quite good to get people excited and enthused.
09:26:50 <julianleviston> ebzzry: the trouble is it doesn’t give you a comprehensive understanding of haskell...
09:26:53 <andromeda-galaxy> julianleviston: yeah, it's not the best.  I occasionally end up using LYAH for explaining how a mathematical thing (like Monoids) are embedded in Haskell
09:26:53 <ebzzry> julianleviston: what's a better alternative to LYAH?
09:26:56 <andromeda-galaxy> not the whole book at all
09:26:57 <int-e> k0ral: I'm assuming you have code like  foo t@(Node a b) = let a' = foo a; b' = foo b in Node a' b'... which would construct a new 'Node' cell on the heap even in a' equals a and b' equals b'; With the extra Bool you could do something like  foo (Node a b) = let (a', a_changed) = foo a; (b', b_changed) = foo b in if a_changed || b_changed then (Node a' b', True) else (t, False) ...
09:27:00 <julianleviston> ebzzry: I just said one.
09:27:12 <ebzzry> julianleviston: sorry. memory died.
09:27:23 <julianleviston> ebzzry: haskellbook.com
09:27:28 <andromeda-galaxy> I haven't read it, but Bird's new /Thinking Functionally in Haskell/ is supposed to be pretty good as well
09:27:30 <julianleviston> andromeda-galaxy: LYAH and RWH have the distinct advantage of being free
09:27:34 <int-e> k0ral: I'm not sure this is the right approach... are you traversing the trees in the end? If so, perhaps you can just make the traversals stop at the desired level and never prune the tree at all.
09:27:34 <andromeda-galaxy> indeed they do
09:27:45 <julianleviston> andromeda-galaxy: I’ve read it. It’s quite good, too… not especially beginner-centric, tho.
09:28:11 <andromeda-galaxy> that's true --- since ebzzry was also asking for an RWH replacement, I though that I'd mention it
09:28:19 * hackagebot transient 0.1.0.9 - Making composable programs with multithreading, events and distributed computing  https://hackage.haskell.org/package/transient-0.1.0.9 (AlbertoCorona)
09:28:36 <julianleviston> andromeda-galaxy: it’s not especially recent either tho
09:28:45 <ebzzry> I'm assuming, of course, that an alternative to RWH, does exist.
09:28:54 <andromeda-galaxy> julainleviston: only lastyear, right?
09:28:54 <julianleviston> ebzzry: I don’t think so
09:29:01 <ebzzry> julianleviston: OK
09:29:03 <julianleviston> ebzzry: but RWH is good at being what it is
09:29:10 <ebzzry> julianleviston: which is?
09:29:15 <julianleviston> andromeda-galaxy: oh was it? I thought it was a lot older
09:29:19 <andromeda-galaxy> RWH + an understanding that some of the code examples don't necessarily work...
09:29:36 <julianleviston> ebzzry: well, what do you want? a beginner book, or an intermediate one?
09:29:37 <andromeda-galaxy> julianleviston: Are yu thinking of /Introduction to Functional Programming Using Haskell/?
09:29:46 <ebzzry> julianleviston: both
09:29:47 <julianleviston> andromeda-galaxy: No...
09:29:53 <julianleviston> ebzzry: sigh
09:29:57 <andromeda-galaxy> julainleviston: I'm talking about http://www.cambridge.org/us/academic/subjects/computer-science/programming-languages-and-applied-logic/thinking-functionally-haskell
09:30:02 <andromeda-galaxy> which says that it's Dec. 2014
09:30:04 <julianleviston> andromeda-galaxy: yeah I’ve got it.
09:30:24 <julianleviston> andromeda-galaxy: oh yeah look at that. Wow. I wonder why it feels so out of date
09:30:53 <andromeda-galaxy> julianleviston: I'm not sure... Like I said, I haven't had time to read it yet, just talked to a few other people who have
09:30:56 <julianleviston> ebzzry: use CIS194, I reckon
09:31:04 <julianleviston> andromeda-galaxy: how did you learn haskell?
09:31:06 <ebzzry> So its lyah:haskellbook, rwh:?
09:31:19 <julianleviston> @where CIS194
09:31:19 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
09:31:32 <julianleviston> ebzzry: I recommend haskellbook… 
09:31:54 <ebzzry> bookmarked
09:31:59 <andromeda-galaxy> julianleviston: A not-very-good book called /Programming in Haskell/ by Graham Hutton + RWH + LYAH + Hackage + various blog posts on, e.g., lens, etc.
09:32:00 <k0ral> int-e: why would you assume that I'm changing the tree ? :)
09:32:27 <k0ral> int-e: I was simply asking about `prune depth (Node a b) = Node a (prune (depth-1) b)`
09:32:30 <julianleviston> ebzzry: real world haskell covers extra topics, but haskellbook has all the basics… and beyond… goes right up to monads, and will go past, to monad transformers… but it doesn’t have things like “how to do file stuff, how to do network stuff, etc etc"
09:32:41 <julianleviston> andromeda-galaxy: yeah I’ve got programming in haskell too
09:32:48 <ebzzry> julianleviston: that sounds interesting
09:33:02 <k0ral> int-e: I'm traversing the tree in the end, yes, and that's the point: I don't want it to take ages
09:33:10 <andromeda-galaxy> By the way, http://twanvl.nl/blog/haskell/cps-functional-references is the best basic explanation of lenses I've seen yet (It's Twan van Laarhoven's original explanation of the theory behind lens)
09:33:16 <julianleviston> ebzzry: that’s why RWH is kind of really useful as a reference.
09:33:21 <andromeda-galaxy> julianleviston: ahh..
09:33:25 <ebzzry> julianleviston: But, as you have mentioned earlier, the other books has an advantage of being free.
09:33:30 <julianleviston> yes :)
09:33:39 <andromeda-galaxy> ebzzry: but, you have to be not-too-surprised when RWH code doesn't work exactly
09:33:45 <andromeda-galaxy> a couple of libraries have changed since it was written
09:34:06 <julianleviston> ebzzry: haskellbook will get you from nothing to intermediate haskell in a couple of months, I reckon...
09:34:30 <ebzzry> andromeda-galaxy: That was mentioned in Mark Fine's recent talk.
09:34:38 <ebzzry> julianleviston: really?
09:34:46 <julianleviston> ebzzry: yeah.
09:34:54 <ebzzry> wow
09:35:04 <andromeda-galaxy> ebzzry: what was?
09:35:32 <ebzzry> andromeda-galaxy: what julianleviston said about zero to intermediate
09:36:07 <julianleviston> ebzzry: you can read my review of it on the site… actually… I gave them one to use… 
09:36:08 <julianleviston> http://haskellbook.com/feedback.html
09:36:24 <andromeda-galaxy> ebzzry: ah, okay
09:37:02 <ebzzry> sweet!
09:37:31 <ebzzry> Is there a way to purchase it via PayPal?
09:38:27 <int-e> k0ral: what I mean is a kind of (manual) fusion: http://lpaste.net/5935406011480276992
09:38:27 <andromeda-galaxy> julianleviston: that does look like a  good book...
09:39:01 <int-e> k0ral: since you seem to be worried about the copied tree resulting from "prune"...
09:39:08 <ebzzry> Oh there is a way to.
09:39:56 <Aeroblop> Anyone know how to test if a string is part of a bigger string quickly? like 'a' `elem` "abc", but for something like "ab" `elem` "abc"
09:40:13 <julianleviston> Aeroblop:  oh like a substring of...
09:40:17 <Aeroblop> yeah
09:40:18 <int-e> :t isInfixOf
09:40:19 <lambdabot> Eq a => [a] -> [a] -> Bool
09:40:50 <int-e> (not the most efficient substring test, but it's readily available from Data.List, and often good enough)
09:41:07 <Zekka> What's inefficient about it?
09:41:16 <Aeroblop> you're a babe, thanks
09:41:34 <pontus> if you want efficient strings, don't use String at all, right? Use ByteString or Text
09:41:39 <int-e> Zekka: it can take quadratic time.
09:42:00 <Zekka> I'm looking at the implementation now and I think I see why
09:42:05 <Zekka> Why do you suppose it was implemented that way?
09:42:28 <Aeroblop> Actually, that won't work, int-e.
09:42:43 <Zekka> It'd be kind of like using the showoffy fake quicksort everyone likes but in the stdlib
09:42:49 <Aeroblop> I'm making a little function that converts roman numerals to ints
09:42:51 <int-e> Zekka: wheras algorithms like Knuth-Morris-Pratt or Boyer-Moore take only linear time (assuming a fixed, small, alphabet)
09:43:20 * hackagebot deepcontrol 0.4.3.0 - Provide more deeper level style of programming than the usual Control.xxx modules express  https://hackage.haskell.org/package/deepcontrol-0.4.3.0 (KONISHI_Yohsuke)
09:43:20 <int-e> Aeroblop: so you want a subset test?
09:43:23 <Aeroblop> and I want to test if firstly the first two elements of a list are in a list of Strings: ["C", "CD", "CM", "D", "I"...
09:43:57 <Aeroblop> and then if they're not, take 1 from input list and see if it's in that list of ["C", "CD", "CM", "D", "I"...
09:44:15 <Zekka> int-e: It doesn't seem to me like it's hard to define a linear-time one
09:44:34 <Zekka> Maybe I'm missing something about why this problem would be hard
09:44:41 <yyyyy> \q
09:45:13 <int-e> > "aaaaaaaab" `isInfixOf` "aaaaaaaaaaaaaaaab"
09:45:14 <lambdabot>  True
09:45:20 <k0ral> int-e: your example is precisely an illustration of the issue
09:45:34 <k0ral> int-e: ideally, I'd like to separate the pruning part from the traversal part
09:45:44 <Aeroblop> int-e: any advice on my problem?
09:46:08 <k0ral> int-e: I'd like to have on one side an algorithm that works on any tree, and on the other side the producer of such tree
09:46:54 <k0ral> int-e: your travPruned is mixing both, and that is violating the loosly-coupled principle
09:47:35 <k0ral> int-e: I'm wondering whether there is a way to separate producer and consumer, without the penalty of deepcopying the tree
09:53:36 <int-e> k0ral: well, you can abstract from the pattern to some extent, similar to build/foldr-fusion... http://lpaste.net/4760462096422928384
09:54:08 <Aeroblop> :t foldl
09:54:09 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
09:54:18 <Gurkenglas> Is there a group . sort that works without an Ord instance? I.e. in quadratic type, like nub
09:56:33 <monochrom> no, I don't think anyone wrote one.
09:58:41 <int-e> k0ral: The point is, if you have code like   trav (prune d tree), then after inlining `trav` and `prune`, the compiler can specialize the code and end up with, essentially, travPrune. But it only works if the traversal can be written as folding over the tree.
09:59:23 <shootmyfruit> I'm trying to check if two lists of tuples are the same even if they arent in the same order
09:59:40 <Aeroblop> if I have a function: func :: String -> [String] and a wrapper class conv :: [String] -> Int, where I would call conv $ func "mystring", is it possible to combine these two into one function?
10:00:03 <shootmyfruit> but I at the moment it can onyl say the bags are equal if they are in order
10:00:04 <shootmyfruit> http://lpaste.net/7006756097042153472
10:00:09 <shootmyfruit> theres my code
10:00:24 <julianleviston> shootmyfruit:  why can’t you just compare after sort?
10:01:55 <shootmyfruit> part of the problem is bags can't be ordered
10:02:23 <shootmyfruit> I know if i can prove a is a subset of b and b is a subset of a it prove equality
10:02:28 <shootmyfruit> but i cant think of how to implement it
10:05:51 <julianleviston> shootmyfruit: I don’t get why you can’t pull the contents of the bag into an orderable collection then check with that?
10:07:52 <shootmyfruit> I could
10:07:57 <shootmyfruit> but I've been told not to
10:08:27 <julianleviston> ah ok. sorry i Ididn’t realise it was bad.
10:08:41 <julianleviston> shootmyfruit: I guess if it’s large it’s bad. 
10:08:47 <ggole> Can you have duplicates?
10:09:14 <shootmyfruit> the way bags work
10:09:16 <shootmyfruit> are
10:09:30 <shootmyfruit> like turning "hello" into a bag
10:09:31 <shootmyfruit> gives
10:10:00 <shootmyfruit> [('o',1),('l',2),('e',1),('h',1)]
10:10:14 <ggole> I see
10:10:16 <shootmyfruit> so duplicates just increase the count of that element
10:11:25 <ggole> I guess check whether every element of a is in b, and whether every element of b is in a
10:11:46 <ggole> Which won't win any performance awards, but should be easy enough to program.
10:12:06 <tomus> if source code says "import Paths" how do I figure out what I should put in my .cabal file? Google?
10:12:40 <tomus> (in build-depends)
10:13:21 * hackagebot transient 0.1.1 - Making composable programs with multithreading, events and distributed computing  https://hackage.haskell.org/package/transient-0.1.1 (AlbertoCorona)
10:14:48 <kallisti> shootmyfruit: I don't think I've heard that structure referred to as a bag. I most commonly see multimap
10:15:46 <hexagoxel> tomus: http://hayoo.fh-wedel.de/?query=Paths
10:16:14 <hexagoxel> tomus: one of the hoogles should work as well
10:16:18 <kallisti> shootmyfruit: who told you it was bad to sort the container?
10:16:51 <kallisti> if it's implemented as an ordered binary tree then traversal is computationally very cheap
10:17:34 <kallisti> certainly much faster than any kind of worst cast O(n^2) unordered check
10:17:40 <kallisti> *worst case
10:18:02 <SrPx> cabal init guesses my name wrong, how can I change it?
10:18:25 <kallisti> change the .cabal file that it produces?
10:19:08 <kallisti> as far as I know all cabal init does is generate a .cabal file template for you.
10:19:54 <hexagoxel> SrPx: change ~/.gitconfig (i am not completely certain, but i think that that is used..)
10:20:13 <SrPx> there it is, thanks
10:20:48 <kallisti> shootmyfruit: if you're concerned about performance over a large data structure you should be using https://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Map.html
10:21:24 <julianleviston> kallisti: what if the shape of your data structure is not a map?
10:21:47 <julianleviston> kallisti: which it isn’t, in his/her case
10:22:28 <kallisti> but it is right? He's basically doing [(Char, Integer)] where each character is unique and represent the occurences of the character in a string
10:24:27 <funrep> hello, long time since i last installed haskell
10:24:27 <kallisti> he wants to test equality without respecting any particular ordering (or equivalently enforcing a particular ordering) on a collection of uniquely keyed (key, value) pairs... that is 100% what a map is for.
10:24:37 <funrep> what is the prefereble installation method on linux?
10:24:46 <kallisti> what distro?
10:24:58 <kallisti> usually you just install ghc and cabal-install from your distro's package manager of choice
10:25:25 <kallisti> once you have those two things you can get anything else you need through cabal-install
10:27:14 <Aeroblop> How would you write: checksum    = 10 - ( sum (mapEveryOther2 (*3) digits) `mod` 10 ) without any brackets? or do you have to use brackets here?
10:29:55 <julianleviston> Aeroblop: you could replace the first with a $. So : checksum    = 10 - $ sum (mapEveryOther2 (*3) digits) `mod` 10 
10:30:26 <Aeroblop> I tried that, and I just get a parse error
10:30:33 <julianleviston> oh really… ok
10:30:55 <hexagoxel> "checksum = 10 - sum (mapEveryOther2 (*3) digits) `mod` 10" should work
10:30:59 <julianleviston> oh yeah silly me
10:31:06 <kallisti> tomus: hoogle and hayoo are both Haskell search engines. they can help you locate the package associated with a given module name.
10:31:49 <kallisti> shootmyfruit julianleviston: but really if you're only  working with Latin/Cyrillic alphabets then forcing a sort before testing equality shouldn't incur any massive performance penalty. It might be a performance concern when you're reading in multi-gigabyte works of text with many different characters such as with ideographic languages.
10:31:51 <hexagoxel> Aeroblop: and you can go of course go crazy on sections: checksum = (10 -) $ (`mod` 10) $ sum $ mapEveryOther2 (*3) digits
10:32:09 <kallisti> in which case I would use Data.Map.Strict from the containers library
10:32:19 <julianleviston> kallisti: unless you have massive collections.
10:32:53 <Aeroblop> what's the difference between the $ and . operators?
10:32:57 <julianleviston> hexagoxel:  and then use (.) to chain them all together.
10:33:04 <kallisti> I am basing his use case on the fact that his example was constructed from a string of English. So, the upper bound of the container size would be whatever alphabet the language is in.
10:33:07 <shootmyfruit> I'm not concerened about eprformance
10:33:15 <julianleviston> Aeroblop: one is function application (apply arguments to functions) the other is function composition (make new functions out of other functions)
10:33:15 <kallisti> so, if it's a Latin based alphabet, the container size is guaranteed to be very small
10:33:17 <shootmyfruit> I'm just doing it to the constraints i've been given
10:33:21 <jpp7> can somebody tell me why this fails to run? http://paste.ofcode.org/rgEKVgffGPYwJsbtbiRpfv
10:33:35 <jpp7> it says expected type Char does not match actual type [Char]
10:33:38 <jpp7> in replicate
10:33:40 <jpp7> but it does
10:33:44 <hexagoxel> julianleviston: nah, i vote for ($); never convinced by the (.) fans.
10:33:47 <kallisti> shootmyfruit: ah is this for an assignment?
10:33:53 <shootmyfruit> yeah
10:34:07 <monochrom> but recently I have become interested in what's the same between $ and .
10:34:09 <kallisti> a sort would be fine then. unless you feel like implemented a balanced binary search tree by hand. :P
10:34:09 <lyxia> jpp7: replicate y x is a list of Char right?
10:34:15 <julianleviston> hexagoxel: I don’t think it makes much difference…
10:34:24 <lyxia> jpp7: then you are making a list where each element is such a list
10:34:31 <kallisti> or if you can't use a sort then do what other people were saying.
10:34:34 <jpp7> lyxia: oh ok I see
10:34:39 <monochrom> it turns out that $ is fmap for the identity functor, and . is fmap for the (->)e functor
10:34:41 <shootmyfruit> i cant sort the assignment says bags have to stay unsorted
10:35:13 <kallisti> then yeah you'd have to do the naive traversal
10:35:31 <eklavya> what is the compiler trying to tell here?
10:35:35 <eklavya>  No instance for (Num a0) arising from a use of ‘it’
10:35:35 <eklavya>     The type variable ‘a0’ is ambiguous
10:35:37 <eklavya>     Note: there are several potential instances:
10:36:03 <monochrom> you have used arithmetic operators on non-numbers
10:36:37 <eklavya> I think I have messed up something
10:36:39 <uncle-j_j> hi there, i'm trying to write something like this: `genPoints :: (GLfloat a) => a -> [(a, a)]` but got this error: "‘GLfloat’ is applied to too many type arguments", what i'm doing wrong?
10:37:18 <eklavya> I am not sure how to ask this without showing the exercise
10:37:28 <uncle-j_j> i use `(GLfloat a)` for GLfloat short alias
10:37:39 <kallisti> >  [replicate y x | (x,y) <- zip "hello" [1..]] -- jpp7
10:37:41 <lambdabot>  ["h","ee","lll","llll","ooooo"]
10:37:45 <monochrom> you should show the exercise. verbatim unabridged and without your interpretation.
10:37:51 <kallisti> jpp7: your result type is a list of Strings, not a String
10:37:53 <eklavya> if it's not too much can you please take a look at http://www.seas.upenn.edu/~cis194/spring13/hw/05-type-classes.pdf
10:38:05 <eklavya> I am stuck on exercise 3
10:38:09 <eklavya> let me paste my code
10:38:57 <kallisti> eklavya: did you accidentally write + instead of add somewhere?
10:39:17 <eklavya> http://codepad.org/iteDO7xT
10:39:18 <tzh> uncle-j_j: GLfloat is a type by itself, not a typeclass; i think you'd want just `:: GLfloat -> (GLfloat, GLfloat)`
10:39:36 <uncle-j_j> tzh: ok, thanks
10:39:36 <eklavya> kallisti not sure :(
10:39:51 <kallisti> eklavya: so the issue is that you're trying to add Maybe Integers, which is not a valid instance of Num
10:40:01 <kallisti> oh wait nevermind
10:40:05 <jpp7> kallisti: yeah I got by it by using concat
10:40:06 <tzh> saying `(Foo a) => a -> a` isn't shorthand for `Foo -> Foo`, it means "a type instanced to the typeclass Foo"
10:40:34 <kallisti> eklavya: nevermind disregard that. your issue is with your Expr type
10:40:50 <kallisti> your GADT's constructors don't make sense
10:41:01 <bitemyapp> https://www.youtube.com/watch?v=sRonIB8ZStw&feature=youtu.be
10:41:03 <bitemyapp> Stack tutorial video, hope it helps.
10:41:28 <eklavya> kallisti yeah, I don't think I understood but that was the only way to get it to compile :P
10:41:42 <eklavya> it's nonsense, how to get it right?
10:42:14 <kallisti> eklavya: what line is the error on?
10:42:24 <eklavya> this code compiles
10:42:29 <eklavya> but doing lit 2
10:42:30 <eklavya> failes
10:42:35 <eklavya> fails
10:43:00 <eklavya> also I wanted to write types for lit etc as Expr -> Expr but then it wants a type variable
10:43:00 <kallisti> ah
10:43:11 <monochrom> lit 2 :: ExprT
10:43:17 <kallisti> so the thing is
10:43:25 <kallisti> there is no Expr instance
10:43:35 <kallisti> for numeric stuff
10:43:40 <kallisti> Integers, Num instances, whatever
10:43:44 <monochrom> you need the type annotation to tell the computer which instance of Expr you want
10:43:56 <kallisti> the only valid input for lit, based on this source code, is some kind of ExprT
10:43:59 <kallisti> which a "2" is not
10:44:06 <monochrom> no, nevermind
10:45:21 <eklavya> ok
10:45:28 <eklavya> so what type would lit have?
10:45:40 <kallisti> what type does it need to have
10:45:48 <eklavya> Expr -> Expr ?
10:45:53 <kallisti> no. that's what it currently is
10:46:12 <eklavya> oh
10:46:25 <kallisti> well, ExprT -> ExprT
10:46:34 <kallisti> is what it currently is, given that it only has a single instance defined for the typeclass
10:46:35 <eklavya> ?
10:46:49 <eklavya> yeah ok
10:47:03 <kallisti> basically when you make an instance, you're plugging in whatever type the instance has for the variable "a"
10:47:27 <kallisti> so for "instance Expr ExprT where..."   the type for lit becomes ExprT -> ExprT
10:47:37 <eklavya> ok
10:48:07 <eklavya> but for ExprT it needs to have type Integer -> ExprT
10:48:21 <eklavya> right?
10:48:23 <kallisti> yes, if you want it to work with the example code
10:48:26 <kallisti> add (lit 2) (lit 3) etc
10:48:31 <kallisti> it needs to take an instance of Num
10:48:35 <kallisti> Integer, for example
10:48:40 <eklavya> but then this is not general
10:48:52 <eklavya> I know what type it needs to have for ExprT
10:49:03 <eklavya> what about other types that might implement it?
10:49:06 <kallisti> on the input type, no, it's not. the lit function is basically saying "given some constant value, construct an expression from it"
10:49:59 <eklavya> but while declaring the Expr class I don't have information on what type that constant value will have
10:50:25 <khumba> 'Morning.  I wrote the following trying to be warning-free between GHC 7.8 and 7.10: unlines ["{-# LANGUAGE CPP #-}", "#if !MIN_VERSION_base(4,8,0)", "{-# LANGUAGE OverlappingInstances #-}", "#endif"]
10:50:44 <kallisti> well, heres the thing: this example doesn't really showcase what a typeclass is for. because you're only writing a single instance.
10:51:05 <khumba> And it actually seems to work!  Is that the correct way to do this?  Surprised the compiler handles that correctly.
10:51:32 <andromeda-galaxy> uncle-j_j: what is the kind of GLfloat?
10:51:34 <kallisti> but, let's say, for demonstration purposes, Expr is supposed to represent a generic integer arithmetic expression. in that case, it's perfectly acceptable for lit to accept only Integers.
10:51:49 <kallisti> khumba: yes you can use CPP with language extensions
10:52:12 <kallisti> the preprocessor phase runs before the actual compilation phases (where LANGUAGE becomes relevant)
10:52:32 <khumba> Ah, so there's a preliminary check for whether CPP is enabled?
10:52:33 <hexagoxel> as long as the LANGUAGE CPP comes before any actual CPP stuff.
10:52:48 <kallisti> ah right
10:52:54 <khumba> Okay, that's amazingly well thought out :) thanks!
10:53:03 <hexagoxel> you can't do #if FOO {-# LANGUAGE CPP #-}  :D
10:53:08 <kallisti> honestly I don't even know that the CPP extension does anything for GHC, because
10:53:18 <kallisti> well, it definitely doesn't instruct the parser to work differently
10:53:36 <kallisti> it will still parse a # at the start of a line as a CPP directive, even if there is no LANGUAGE pragma enabling CPP
10:54:01 <kallisti> in fact it bugs out on Literate Haskell when you try to write Markdown headers, because it reads the # at the start of the line as a CPP directive and gives a syntax error
10:55:02 <kallisti> with no CPP extension enabled
10:55:31 <kallisti> it still gives a syntax error "invalid literal after #" in a non-commented section of Literate Haskell. so, the CPP directive parsing is pretty hardcoded into GHC currently
10:56:00 <eklavya> kallisti so here the signature of lit can be hard coded to be Integer -> a ?
10:56:40 <kallisti> eklavya: based on the exercise description I would say yes. If it strikes you as weird that's because it is.
10:57:00 <eklavya> kallisti ok, I think I got it
10:57:06 <eklavya> thanks kallisti monochrom :)
10:57:52 <kallisti> eklavya: if this were a more complex expression tree, say instead of having just Integer literals you have like:   data ExprT =
10:58:17 <kallisti> data ExprT = FloatLit Float | IntLit Integer | Add ExprT ExprT | Mul ExprT ExprT
10:58:25 <khumba> Interesting kallisti :).
10:58:29 <kallisti> eklavya: and, for whatever reason, you wanted a generic typeclass that specifies an interface over all of this stuff
10:58:47 <kallisti> eklavya: instead of having just a single "lit" function you'd have  "floatLit"  and "intLit"
10:59:00 <kallisti> a function for each literal type, so that you could lift ordinary values into your expression type
10:59:15 <eklavya> ok
10:59:56 <kallisti> eklavya: but really if you don't have multiple instances you shouldn't be using a typeclass. There is no benefit to writing typeclasses "just cause" and then only having one instance for it.
11:00:11 <eklavya> and this can't be made generic right by num? because we won't know which lit we are talking about
11:00:49 <eklavya> I mean choosing the right lit according to the actual type of the input
11:00:54 <kallisti> well, okay, in my example with floatLit and intLit, you could generalize it to Num, yes.
11:01:02 <kallisti> a better example would have been something like StringLit vs IntLit
11:01:05 <eklavya> I can?
11:01:29 <kallisti> eklavya: you can yes, though I'm not really sure there's a reason to. But if you want to do it just to learn what it would look like, you can.
11:01:41 <eklavya> hmm, I thought it would be a problem, let me try
11:02:57 <kallisti> the thing is, this is a heavily contrived typeclass. so asking questions like "hmmm well we don't REALLY know the type that should be input to lit here" is pointless because, we DO know the type... because this is just your ExprT structures constructors lifted into typeclass form. There is no real generalization going on here, such as if there were
11:02:57 <kallisti>  multiple different data types that we were writing typeclass instances for
11:03:46 <eklavya> ok
11:04:07 <kallisti> if we had other data types that we need Expr instances for, we would likely be using very different types for our Expr class in the first place, because our problem domain has shifted.
11:04:56 <kallisti> :t 5
11:04:58 <lambdabot> Num a => a
11:05:59 <kallisti> eklavya: so here's the type of an integer literal in Haskell. It's overloaded over the Num typeclass.
11:06:09 <kallisti> :t fromIntegral
11:06:11 <lambdabot> (Integral a, Num b) => a -> b
11:06:41 <kallisti> eklavya: when you write 5 you're actually writing something more like:  fromIntegral (5 :: Integer)
11:07:07 <eklavya> ok
11:07:08 <kallisti> and each instance of Num has a different implementation of fromIntegral
11:08:08 <eklavya> about my earlier question
11:08:18 <eklavya> if we have data Ext = FloatLit Float
11:08:18 <eklavya>            | IntLit Integer
11:08:30 * hackagebot OddWord 1.0.1.0 - Provides a wrapper for deriving word types with fewer bits.  https://hackage.haskell.org/package/OddWord-1.0.1.0 (RobinKay)
11:08:35 <eklavya> could we have a lit :: Num -> Ext
11:09:15 <kallisti> I THINK so but I'm trying to find which functions you use to make the necessary conversions
11:09:37 <kallisti> also I think you need it to be
11:09:43 <kallisti> (Num a, Eq a) => a -> ExprT
11:10:10 <eklavya> won't I need to figure out what type the input was to choose the correct Lit?
11:10:14 <kallisti> but now I'm not sure you can convert an arbitrary Num instance to an Integer. Now that I think about it a lot of the more interesting Num instances wouldn't have any sensible conversion.
11:10:38 <kallisti> well you'd need to convert it to a float, then determine if the fractional part is 0
11:10:54 <kallisti> if it's 0, then convert to Integer and store as IntLit, otherwise store as FloatLit
11:11:12 <eklavya> ok so no type based decision
11:11:37 <eklavya> got it
11:11:41 <kallisti> correct. you actually can't do any typechecking at runtime because it doesn't make any sense.
11:11:48 <kallisti> the types are fixed at compile time
11:12:39 <eklavya> when you said we could use Num I was thinking it was impossible because of this :P
11:13:01 <kallisti> yeah I don't think Num is correct
11:13:05 <kallisti> it would have to be something like Fractional
11:14:11 <kallisti> probably you want RealFrac because that gives us the rounding/truncation operators
11:14:21 <kallisti> and properFraction which allows us to check if the fractional part is 0
11:14:24 <kallisti> :t properFraction
11:14:26 <lambdabot> (Integral b, RealFrac a) => a -> (b, a)
11:14:45 <eklavya> ok
11:14:52 <kallisti> or RealFloat
11:16:46 <eklavya> thanks for your time kallisti, learned a lot :)
11:18:30 * hackagebot pagerduty 0.0.4 - Client library for PagerDuty Integration and REST APIs.  https://hackage.haskell.org/package/pagerduty-0.0.4 (BrendanHay)
11:43:29 <nineonine> hi
11:43:37 <nineonine> im trying to run executable 
11:43:40 <nineonine> but it says 
11:43:55 <nineonine> no such file or directory
11:44:00 <nineonine> whats the problem ?
11:44:28 <johnw> nineonine: Linux?
11:44:36 <nineonine> mac
11:44:48 <nineonine> osx
11:44:51 <johnw> type "file <path to executable>", what does that say?
11:44:55 <khumba> With Haddock, is there a way to hyperlink to a named documentation block {- $foo -}?
11:45:21 <lispy> nineonine: did you recently install it? you might have to flush the path cache in your shell. hash -r or rehash depending on the shell
11:45:47 <nineonine> no I had it for a while
11:46:56 <nineonine> @johnw do i have to prefix the file with “./“ ?
11:46:56 <lambdabot> Not enough privileges
11:47:21 <johnw> nineonine: if it's not on your PATH, yes
11:48:10 <nineonine> ok, i did “ghc File.hs”
11:48:21 <nineonine> and then im trying “./File”
11:48:37 <nineonine> no such a file or dir...
11:50:07 <johnw> what does "file File" say?
11:50:18 <tommd> nineonine: Or just "ls" (or "dir" on windows)
11:50:29 <nineonine> cannot open `File’ (No such file or directory)
11:50:39 <johnw> what is the module name of File.hs?
11:50:43 <johnw> module XXX where ...
11:51:04 <nineonine> File
11:51:05 <johnw> try: ghc -main-is File File.hs
11:52:28 <nineonine> it (module name) corresponds to the filename
11:53:06 <nineonine> -main-is didnt help :\
11:54:54 <johnw> try: rm File.o File.hi ; ghc -main-is File -o File File.hs
11:55:16 <johnw> I use this incantation often, so if that doesn't work, we'll need to see a paste of your file
11:56:23 <nineonine> it worked !
11:56:34 <nineonine> thanks a lot ! :)
11:56:37 <nineonine> what was the problem ?
11:57:03 <nineonine> i noticed that terminal mentioned something about Linking
11:57:16 <nineonine> which he hasn’t done before
11:57:28 <nineonine> i mean during previous attempts
11:58:06 <darkstalker> @pl \x -> min (asdf x) (derp x)
11:58:06 <lambdabot> liftM2 min asdf derp
11:58:13 <johnw> Before you were just asking GHC to compile a file.  Now we're asking it to both compile file, and produce an executable from that object file.  This requires a linking step (requested by -o).
11:58:15 <Eduard_Munteanu> Linking is the final step when producing a library/executable.
11:58:32 <johnw> the real change is both identifying the "Main" module, and asking for an executable with -o
11:59:59 <nineonine> got it ! thanks , that was helpful !
12:00:33 <darkstalker> @pl \x -> minimum [asdf x, derp x, test x]
12:00:33 <lambdabot> minimum . liftM2 (:) asdf (liftM2 (:) derp (return . test))
12:08:13 <phaazon> is there a hackage admin here?
12:09:08 <phaazon> I tried to upload a new release of a package of mine, but it failed – because of someone disconnecting the network in the place I am, and the package doesn’t show up on hackage, and yet I can’t upload it back again
12:09:12 <phaazon> any idea?
12:09:22 * hackagebot amazonka-core 1.3.4 - Core data types and functionality for Amazonka libraries.  https://hackage.haskell.org/package/amazonka-core-1.3.4 (BrendanHay)
12:09:24 * hackagebot amazonka 1.3.4 - Comprehensive Amazon Web Services SDK.  https://hackage.haskell.org/package/amazonka-1.3.4 (BrendanHay)
12:09:26 * hackagebot amazonka-config 1.3.4 - Amazon Config SDK.  https://hackage.haskell.org/package/amazonka-config-1.3.4 (BrendanHay)
12:09:28 * hackagebot amazonka-sns 1.3.4 - Amazon Simple Notification Service SDK.  https://hackage.haskell.org/package/amazonka-sns-1.3.4 (BrendanHay)
12:09:30 * hackagebot luminance 0.6 - Type-safe, dependently-typed and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.6 (DimitriSabadie)
12:09:34 <phaazon> haha goddammit
12:09:38 <phaazon> it shows up here
12:09:43 <phaazon> but there’s nothing on hackage :(
12:10:02 <tommd> Web cache?
12:10:02 <phaazon> oh there is
12:10:05 <phaazon> weird.
12:10:11 <tommd> Caching is evil.
12:10:17 <phaazon> nevermind then.
12:10:31 <tommd> Never cache, always read from (insert final storage medium here).
12:11:43 <phaazon> hm
12:11:50 <phaazon> is there a way to send documentation with stack?
12:12:05 <phaazon> we can upload package, but it seems it doesn’t upload documentation…
12:13:01 <brnhy> Documentation will be built by Hackage, asynchronously after your actual upload
12:13:30 <phaazon> yeah but it never works.
12:14:32 * hackagebot amazonka-ecs 1.3.4 - Amazon EC2 Container Service SDK.  https://hackage.haskell.org/package/amazonka-ecs-1.3.4 (BrendanHay)
12:14:34 * hackagebot amazonka-sqs 1.3.4 - Amazon Simple Queue Service SDK.  https://hackage.haskell.org/package/amazonka-sqs-1.3.4 (BrendanHay)
12:14:36 * hackagebot amazonka-test 1.3.4 - Common functionality for Amazonka library test-suites.  https://hackage.haskell.org/package/amazonka-test-1.3.4 (BrendanHay)
12:14:38 * hackagebot amazonka-glacier 1.3.4 - Amazon Glacier SDK.  https://hackage.haskell.org/package/amazonka-glacier-1.3.4 (BrendanHay)
12:14:40 * hackagebot amazonka-cloudhsm 1.3.4 - Amazon CloudHSM SDK.  https://hackage.haskell.org/package/amazonka-cloudhsm-1.3.4 (BrendanHay)
12:15:17 * hackagebot amazonka-dynamodb 1.3.4 - Amazon DynamoDB SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-1.3.4 (BrendanHay)
12:15:19 * hackagebot amazonka-datapipeline 1.3.4 - Amazon Data Pipeline SDK.  https://hackage.haskell.org/package/amazonka-datapipeline-1.3.4 (BrendanHay)
12:15:21 * hackagebot amazonka-iam 1.3.4 - Amazon Identity and Access Management SDK.  https://hackage.haskell.org/package/amazonka-iam-1.3.4 (BrendanHay)
12:15:23 * hackagebot amazonka-kinesis-firehose 1.3.4 - Amazon Kinesis Firehose SDK.  https://hackage.haskell.org/package/amazonka-kinesis-firehose-1.3.4 (BrendanHay)
12:15:25 * hackagebot amazonka-route53-domains 1.3.4 - Amazon Route 53 Domains SDK.  https://hackage.haskell.org/package/amazonka-route53-domains-1.3.4 (BrendanHay)
12:18:38 <cocreature> phaazon: nope there is an issue for stack but it's not yet implemented in stack.
12:19:57 <cocreature> phaazon: that's the one https://github.com/commercialhaskell/stack/issues/737
12:20:27 * hackagebot amazonka-directconnect 1.3.4 - Amazon Direct Connect SDK.  https://hackage.haskell.org/package/amazonka-directconnect-1.3.4 (BrendanHay)
12:20:29 * hackagebot amazonka-elasticsearch 1.3.4 - Amazon Elasticsearch Service SDK.  https://hackage.haskell.org/package/amazonka-elasticsearch-1.3.4 (BrendanHay)
12:20:31 * hackagebot amazonka-devicefarm 1.3.4 - Amazon Device Farm SDK.  https://hackage.haskell.org/package/amazonka-devicefarm-1.3.4 (BrendanHay)
12:26:27 * hackagebot amazonka-cognito-sync 1.3.4 - Amazon Cognito Sync SDK.  https://hackage.haskell.org/package/amazonka-cognito-sync-1.3.4 (BrendanHay)
12:26:30 * hackagebot amazonka-elb 1.3.4 - Amazon Elastic Load Balancing SDK.  https://hackage.haskell.org/package/amazonka-elb-1.3.4 (BrendanHay)
12:26:31 * hackagebot amazonka-cloudformation 1.3.4 - Amazon CloudFormation SDK.  https://hackage.haskell.org/package/amazonka-cloudformation-1.3.4 (BrendanHay)
12:26:33 * hackagebot amazonka-sts 1.3.4 - Amazon Security Token Service SDK.  https://hackage.haskell.org/package/amazonka-sts-1.3.4 (BrendanHay)
12:26:35 * hackagebot amazonka-kms 1.3.4 - Amazon Key Management Service SDK.  https://hackage.haskell.org/package/amazonka-kms-1.3.4 (BrendanHay)
12:31:38 * hackagebot amazonka-cloudsearch-domains 1.3.4 - Amazon CloudSearch Domain SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-domains-1.3.4 (BrendanHay)
12:31:40 * hackagebot amazonka-cloudwatch 1.3.4 - Amazon CloudWatch SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-1.3.4 (BrendanHay)
12:31:42 * hackagebot amazonka-iot-dataplane 1.3.4 - Amazon IoT Data Plane SDK.  https://hackage.haskell.org/package/amazonka-iot-dataplane-1.3.4 (BrendanHay)
12:31:44 * hackagebot amazonka-cloudtrail 1.3.4 - Amazon CloudTrail SDK.  https://hackage.haskell.org/package/amazonka-cloudtrail-1.3.4 (BrendanHay)
12:31:46 * hackagebot amazonka-elasticache 1.3.4 - Amazon ElastiCache SDK.  https://hackage.haskell.org/package/amazonka-elasticache-1.3.4 (BrendanHay)
12:34:04 <Saizan> what is amazonka, actually?
12:34:43 <mpickering> bindings for amazon's api
12:36:48 * hackagebot amazonka-waf 1.3.4 - Amazon WAF SDK.  https://hackage.haskell.org/package/amazonka-waf-1.3.4 (BrendanHay)
12:36:50 * hackagebot amazonka-importexport 1.3.4 - Amazon Import/Export SDK.  https://hackage.haskell.org/package/amazonka-importexport-1.3.4 (BrendanHay)
12:36:52 * hackagebot amazonka-s3 1.3.4 - Amazon Simple Storage Service SDK.  https://hackage.haskell.org/package/amazonka-s3-1.3.4 (BrendanHay)
12:36:54 * hackagebot amazonka-swf 1.3.4 - Amazon Simple Workflow Service SDK.  https://hackage.haskell.org/package/amazonka-swf-1.3.4 (BrendanHay)
12:36:56 * hackagebot amazonka-sdb 1.3.4 - Amazon SimpleDB SDK.  https://hackage.haskell.org/package/amazonka-sdb-1.3.4 (BrendanHay)
12:37:55 <platz> what does it mean if hackage doesn't perform a build after 12 hours?
12:40:46 <mpickering> that probably your package is in the clue or the builder has died
12:40:52 <mpickering> you could ask #hackage
12:41:24 <platz> ah ok, thanks
12:41:58 * hackagebot amazonka-codecommit 1.3.4 - Amazon CodeCommit SDK.  https://hackage.haskell.org/package/amazonka-codecommit-1.3.4 (BrendanHay)
12:42:00 * hackagebot amazonka-codedeploy 1.3.4 - Amazon CodeDeploy SDK.  https://hackage.haskell.org/package/amazonka-codedeploy-1.3.4 (BrendanHay)
12:42:02 * hackagebot amazonka-cloudfront 1.3.4 - Amazon CloudFront SDK.  https://hackage.haskell.org/package/amazonka-cloudfront-1.3.4 (BrendanHay)
12:42:04 * hackagebot amazonka-efs 1.3.4 - Amazon Elastic File System SDK.  https://hackage.haskell.org/package/amazonka-efs-1.3.4 (BrendanHay)
12:42:06 * hackagebot fn 0.1.0.0 - A functional web framework.  https://hackage.haskell.org/package/fn-0.1.0.0 (DanielPatterson)
12:44:49 <rcat> quit
12:47:08 * hackagebot amazonka-codepipeline 1.3.4 - Amazon CodePipeline SDK.  https://hackage.haskell.org/package/amazonka-codepipeline-1.3.4 (BrendanHay)
12:47:10 * hackagebot amazonka-elasticbeanstalk 1.3.4 - Amazon Elastic Beanstalk SDK.  https://hackage.haskell.org/package/amazonka-elasticbeanstalk-1.3.4 (BrendanHay)
12:47:12 * hackagebot amazonka-autoscaling 1.3.4 - Amazon Auto Scaling SDK.  https://hackage.haskell.org/package/amazonka-autoscaling-1.3.4 (BrendanHay)
12:47:14 * hackagebot amazonka-ses 1.3.4 - Amazon Simple Email Service SDK.  https://hackage.haskell.org/package/amazonka-ses-1.3.4 (BrendanHay)
12:47:16 * hackagebot gnuidn 0.2.2 - Bindings for GNU IDN  https://hackage.haskell.org/package/gnuidn-0.2.2 (JohnMillikin)
12:51:50 <sternenseemann> wow, somebody was productive :D
12:52:18 * hackagebot amazonka-support 1.3.4 - Amazon Support SDK.  https://hackage.haskell.org/package/amazonka-support-1.3.4 (BrendanHay)
12:52:20 * hackagebot amazonka-dynamodb-streams 1.3.4 - Amazon DynamoDB Streams SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-streams-1.3.4 (BrendanHay)
12:52:22 * hackagebot amazonka-redshift 1.3.4 - Amazon Redshift SDK.  https://hackage.haskell.org/package/amazonka-redshift-1.3.4 (BrendanHay)
12:52:24 * hackagebot amazonka-opsworks 1.3.4 - Amazon OpsWorks SDK.  https://hackage.haskell.org/package/amazonka-opsworks-1.3.4 (BrendanHay)
12:52:26 * hackagebot amazonka-emr 1.3.4 - Amazon Elastic MapReduce SDK.  https://hackage.haskell.org/package/amazonka-emr-1.3.4 (BrendanHay)
12:52:50 * hackagebot amazonka-cognito-identity 1.3.4 - Amazon Cognito Identity SDK.  https://hackage.haskell.org/package/amazonka-cognito-identity-1.3.4 (BrendanHay)
12:52:52 * hackagebot amazonka-ssm 1.3.4 - Amazon Simple Systems Management Service SDK.  https://hackage.haskell.org/package/amazonka-ssm-1.3.4 (BrendanHay)
12:52:54 * hackagebot amazonka-ml 1.3.4 - Amazon Machine Learning SDK.  https://hackage.haskell.org/package/amazonka-ml-1.3.4 (BrendanHay)
12:52:56 * hackagebot amazonka-workspaces 1.3.4 - Amazon WorkSpaces SDK.  https://hackage.haskell.org/package/amazonka-workspaces-1.3.4 (BrendanHay)
12:52:58 * hackagebot amazonka-inspector 1.3.4 - Amazon Inspector SDK.  https://hackage.haskell.org/package/amazonka-inspector-1.3.4 (BrendanHay)
12:53:43 <phaazon> cocreature: thanks
12:53:49 <phaazon> I’m writing a script for that
12:53:51 <phaazon> I’ll share it
12:53:55 <phaazon> (I’m using stack path)
12:54:04 <phaazon> I just need to find a way to use that fucking shell read function
12:58:00 * hackagebot amazonka-rds 1.3.4 - Amazon Relational Database Service SDK.  https://hackage.haskell.org/package/amazonka-rds-1.3.4 (BrendanHay)
12:58:02 * hackagebot amazonka-iot 1.3.4 - Amazon IoT SDK.  https://hackage.haskell.org/package/amazonka-iot-1.3.4 (BrendanHay)
12:58:04 * hackagebot amazonka-ds 1.3.4 - Amazon Directory Service SDK.  https://hackage.haskell.org/package/amazonka-ds-1.3.4 (BrendanHay)
12:58:06 * hackagebot amazonka-cloudwatch-logs 1.3.4 - Amazon CloudWatch Logs SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-logs-1.3.4 (BrendanHay)
12:58:08 * hackagebot amazonka-route53 1.3.4 - Amazon Route 53 SDK.  https://hackage.haskell.org/package/amazonka-route53-1.3.4 (BrendanHay)
13:03:10 * hackagebot amazonka-cloudsearch 1.3.4 - Amazon CloudSearch SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-1.3.4 (BrendanHay)
13:03:12 * hackagebot amazonka-storagegateway 1.3.4 - Amazon Storage Gateway SDK.  https://hackage.haskell.org/package/amazonka-storagegateway-1.3.4 (BrendanHay)
13:03:14 * hackagebot amazonka-ec2 1.3.4 - Amazon Elastic Compute Cloud SDK.  https://hackage.haskell.org/package/amazonka-ec2-1.3.4 (BrendanHay)
13:03:16 * hackagebot amazonka-marketplace-analytics 1.3.4 - Amazon Marketplace Commerce Analytics SDK.  https://hackage.haskell.org/package/amazonka-marketplace-analytics-1.3.4 (BrendanHay)
13:03:18 * hackagebot amazonka-elastictranscoder 1.3.4 - Amazon Elastic Transcoder SDK.  https://hackage.haskell.org/package/amazonka-elastictranscoder-1.3.4 (BrendanHay)
13:08:20 * hackagebot amazonka-lambda 1.3.4 - Amazon Lambda SDK.  https://hackage.haskell.org/package/amazonka-lambda-1.3.4 (BrendanHay)
13:08:22 * hackagebot amazonka-kinesis 1.3.4 - Amazon Kinesis SDK.  https://hackage.haskell.org/package/amazonka-kinesis-1.3.4 (BrendanHay)
13:18:21 <phaazon> hm, my script works, except for a little issue
13:18:31 <phaazon> it doesn’t provide the cabal information for hackage
13:18:44 <phaazon> so it doesn’t show up on Hackage, even though the documentation is there
13:22:24 <phaazon> https://github.com/phaazon/stack-haddock-upload
13:22:28 <phaazon> for interested ones
13:28:21 <Gurkenglas> Should "MonadState s m" instead be "MonadStateT n s m" and provide modifyT, getsT and stateT? n would be the n in StateT s n and be passed unaltered up the other transformers
13:29:10 <Gurkenglas> (Oh and putT.)
13:30:31 <Gurkenglas> (Same suggestion for the other transformer classes.)
14:07:01 <forker> Is there a better way to communicate type than what I've done here? http://lpaste.net/143904#line39
14:07:49 <forker> (without constructing a dummy instance, passing unused function and such)
14:14:09 <tommd> forker: It isn't immediately clear to me what you've done there.  I see 'f' is unused and is the only parameter that includes type variable 't'...
14:14:24 <tommd> Why do you need the type variable at all?
14:14:55 <tommd> Ahh, ScopedTypeVariables down below.
14:15:31 <tommd> forker: So you can 1) Make a ConstraintKind `type Foo = (DB.ToBackendKey DB.SqlBackend t, ...)`
14:15:36 <tommd> forker: that's just for readability
14:15:46 <noah_> perhaps you could use a Proxy
14:15:54 <tommd> forker: and 2.  REsource key can define forall t, yes?
14:16:02 <forker> tommd: thanks for picking up :) I don't know how to make it know which model to crunch at a given path ..
14:16:27 <tommd> Proxies are good solutions when needed, but I don't understand why there can't be a function `resourceKey` defined forall t. Constraint t.
14:17:08 <jpp7> is there a reason why this returns an empty list? zip ['A'..'Z'] ['Z'..'A']
14:17:23 <tommd> > zip ['A'..'Z'] ['Z'..'A']
14:17:25 <lambdabot>  []
14:17:35 <tommd> Ahh, because 'Z' is GT 'A'
14:17:40 <tommd> so that second list is empty
14:17:46 <jpp7> wut?
14:17:47 <tommd> > zip ['A'..'Z'] ['Z', 'Y' ..'A']
14:17:51 <lambdabot>  [('A','Z'),('B','Y'),('C','X'),('D','W'),('E','V'),('F','U'),('G','T'),('H',...
14:18:08 <jpp7> oh ok, why do I need to specify the 'Y' ?
14:18:23 <Jinxit> > [10..0]
14:18:24 <lambdabot>  []
14:18:39 <tommd> The notation means you enumerate till you are >= the bound ('A').  Z is already greater than 'A'.
14:18:40 <jpp7> oh
14:18:54 <tommd> So you need to use a different notation that indicate you are looking for the prior element, not the successor.
14:19:07 <jpp7> I have a paper haskell exam coming up and not being able to check stuff like that will be a pain
14:19:32 <tommd> Yeah, paper exams are not great imho.
14:19:54 <tommd> Perhaps if the instructor is just looking for certain basics, it all depends.
14:20:10 <jpp7> yeah perhaps
14:20:30 <forker> tommd: I believe it's no problem to define resourceKey forall t. Constraint t. But I don't see this solving the problem of communicating model type?
14:20:39 <jpp7> I find it bizarre how haskell is the first, first year course, which can be a put off for many people who have not done programming before
14:20:54 <jpp7> as opposed to the standard Java/C
14:21:30 <forker> jpp7: it's about losing virginity with purity :)
14:21:53 <jpp7> haha, I am enjoying it although it's taking time to adjust
14:22:34 <jpp7> what "good habits" does functional programming equip you with in the scope of more general programming?
14:22:39 <eze> is it too early to look for a gsoc 2016 project/mentor?
14:22:44 <jpp7> I hear a lot of people refer to the good habits that come from such a thing
14:22:55 * hackagebot secp256k1 0.4.1 - secp256k1 bindings for Haskell  https://hackage.haskell.org/package/secp256k1-0.4.1 (xenog)
14:24:50 <forker> jpp7: for me that main thing is mostly about proving that stuff works, as opposed to assuring some-self.
14:24:51 <tommd> jpp7: I'd say the best habit is a more structured program.  This takes several forms, such as keeping most mutabilty local, avoiding globals and instead learning how to manage information flow.
14:29:51 <forker> tommd: I've created a bit less noisy one: http://lpaste.net/4578296959848153088
14:33:12 <forker> tommd: fudge it, I've got your point with Constraint :) thanks!
14:33:33 <tyrion-webchat> Hello, is there a way to parse "haskell expressions" using parsec?
14:37:15 <superturrican> was für ein unsinn
14:37:29 <jpp7> Can anybody vouch for "Thinking functionally with Haskell" the book?
14:37:48 <jpp7> I'm reading Lipovaca at the moment but I don't really like the informal tone
14:39:14 <merijn> tyrion-webchat: It depends on what you mean? Built-in, no. Is it possible to write a parser for a haskell(-like) language in parsec, sure
14:39:41 <merijn> jpp7: What's the author?
14:39:50 <merijn> Well, who's, I guess
14:40:57 <jpp7> Richard Bird
14:41:58 <merijn> jpp7: I've heard about it, consensus seems to be: Excellent book for learning how to, well, think functionally, but perhaps not as good for learning haskell (i.e. it only teaches you the subset of haskell needed to explain things in the book)
14:42:04 <jpp7> Wow, I've just seen that the co-author of one of his previous books is my tutor
14:42:13 <jpp7> and also one of the creators of Haskell
14:42:57 <jpp7> and ok, I'll probably give it a read and see how it is
14:43:01 <merijn> jpp7: What I've seen from it bitemyapp's book is a pretty solid one for learning haskell. So maybe combine that with Thinking Functionally
14:43:49 <merijn> I forgot the URL, but probably someone here knows what it is
14:44:18 <shachaf> What I've seen from it has been pretty bad.
14:44:34 <merijn> shachaf: Why's that?
14:44:51 <tyrion-webchat> merijn: I meant built-in. I thought I could use the "haskell" token parser defined here: https://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Language.html 
14:45:06 <shachaf> Maybe my view is biased because the only context I've seen anything from it had been people showing me the worst parts of it.
14:45:17 <shachaf> But it wasn't promising.
14:45:31 <jpp7> Any of you guys heard of Phil Wadler?
14:45:41 <merijn> tyrion-webchat: That basically follows the haskell rules for tokenization as described in the report, but not the actually grammar for haskell
14:45:55 <merijn> tyrion-webchat: There's the haskell-source-exts package for parsing haskell
14:46:07 <merijn> jpp7: Probably everyone who's not a beginner :p
14:46:21 <tyrion-webchat> merijn: does it use Parsec? so I can combine it with my parser?
14:46:48 <jpp7> merijn: nice, he's my tutor for this course
14:47:33 <merijn> tyrion-webchat: No, I think it uses alex and happy
14:48:08 <tyrion-webchat> umh, ok :(
14:48:34 <merijn> tyrion-webchat: to be fair writing a parser for haskell isn't particularly hard/complex depending on how exact you wanna parse haskell...
14:49:11 <tyrion-webchat> merijn: basically I have a parser that parsed my language, but I wanted to add the ability to call haskell functions, but I am getting crazy
14:49:27 <levi> jpp7: This Phil Wadler? https://www.youtube.com/watch?v=IOiZatlZtGU
14:50:08 <merijn> tyrion-webchat: You shouldn't need to parse haskell for that, what you need for that is some form of FFI
14:50:44 <merijn> tyrion-webchat: i.e. all you need is a way to specify the type of a haskell function and then actually calling it becomes a task for your interpreter/compiler to solve
14:50:49 <tyrion-webchat> no, my language is very basic, so I would like the ability to inline haskell code somehow
14:51:23 <jpp7> levi: yes
14:51:39 <tyrion-webchat> my parser converts a string to my AST data type. And then using templatehaskell I convert that to haskell code
14:51:42 <merijn> tyrion-webchat: Inlining haskell code would require you to build a full haskell compiler if you don't have an FFI :)
14:52:02 <tyrion-webchat> so I already made it possible to reference haskell variables
14:52:07 <merijn> tyrion-webchat: Can you give a more complete description of what you're trying to do? :)
14:52:09 <levi> jpp7: That's awesome. Take as much advantage of this opportunity as you can. :)
14:52:42 <jpp7> levi: yeah, well he had to stop delivering the lectures because a lot of people complained but he hosts advanced tutorials, I went to the first one and he is a little bonkers haha
14:52:49 <tyrion-webchat> merijn: let me try. It's just that I am coding since this morning and I am a little bit tired.
14:56:13 <levi> jpp7: What were they complaining about? I only know of him via reputation plus his papers and recorded lectures I've seen.
14:56:42 <meoblast001> does anyone here using vim have problems with GhcModType hanging vim?
14:56:49 <meoblast001> and GhcModCheck doing nothing
14:56:53 <jpp7> levi: I'm not sure, I think it was his teaching style, like he goes off topic very easily and it's a little hard to follow
14:57:58 <jpp7> I wonder if it was him that introduced haskell as a first year compulsory course, it probably was
14:58:33 <levi> Huh. Well, you can learn a lot of interesting things listening to a person with a lot of deep knowledge go off on tangents.
14:58:45 <jpp7> yeah for sure
14:59:02 <levi> But that's not what your typical college undergrad is interested in, I guess.
14:59:40 <tyrion-webchat> So, I made a Monad (something similar to this: http://wall.org/~lewis/2013/10/15/asm-monad.html ) to make it easier to write instructions for my language. The output "language" is actually a sate machine, so I cannot implement variables or functions. Then I wanted to go one step further, so I defined a grammar, implemented a parser that converts a string to tokens, and then use template-haskell to convert those token to my o
14:59:49 <jpp7> yeah especially in regards to what I said earlier, because it's a first year course there are a lot of people who have never programmed before and aren't interested in things beyond a certain pre defined scope
15:00:57 <merijn> tyrion-webchat: You got cut off after "those token to my o"
15:01:19 <levi> I guess it's hard to appreciate a Phil Wadler when you don't yet know enough to value the things he knows and is excited to share, but he certainly strikes me as someone who is excited about teaching.
15:01:52 <tyrion-webchat> merijn: to my original Monad implementation
15:02:40 <tyrion-webchat> then I was able to implement a reference to an Haskell identifier (that looks like this: $identifier;)
15:03:19 <merijn> tyrion-webchat: So you have TH that calls a parser, then generates code using your asm monad?
15:03:35 <tyrion-webchat> with template-haskell that gets converted simply to "(varE .mkName) theidentifier"
15:04:17 <tyrion-webchat> merijn: I have a quasiquoter, that I use like this [mylang| string string |]
15:04:59 <tyrion-webchat> that quasiquoter calls the parser, that produces and instance of MyStmt (which is a statement of my lang) and then this gets converted to ExpQ
15:05:34 <tyrion-webchat> so, yes, that is the idea
15:06:42 <tyrion-webchat> and now I wanted to extend the "identifier" stuff to allow to call any function (that in the end must produce and instance of my monad so I can bind it to the other code)
15:08:15 <tyrion-webchat> so I am trying to make a parser that can handle something like this: $identifier(arg1 sep arg2 sep arg3) where argN should be either an expression of my language, or if that fails a valid haskell expression
15:08:18 <tyrion-webchat> that was my idea
15:09:11 <hackrilege> Hi, does anyone know of a succinct implementation of matrix diagonalisation in Haskell?
15:09:24 <tyrion-webchat> but I am getting problems with the separator, for example if I choose ";;" as a sep, then a valid haskell expression could contain that separator (for example the string ";;") and this messes everythin
15:09:37 <merijn> tyrion-webchat: Right, so essentially you implemented a compiler, but instead of generating the compiler/interpreter directly from your parser you're using TH to do the dirty work
15:09:46 <merijn> hackrilege: No, but try #numerical-haskell ? :)
15:09:59 <tyrion-webchat> merijn: yes, I think so :D
15:11:02 <jophish> What tools do people use to compare benchmarks across multiple revisions of a program?
15:11:27 <merijn> tyrion-webchat: The problem that you're running into is that TH has to end up generating valid haskell and now you're wanting to use names that are not valid. I think the simplest approach would be to do the interpreting yourself instead of going through TH, alternativelly you could institute a renaming scheme where after parsing you modify all names to be legal haskell?
15:12:52 <tyrion-webchat> I am using haskell-src-meta to go from haskell source to ExpQ
15:13:26 <tyrion-webchat> but I am really at my limit now
15:13:31 <tyrion-webchat> I should take a break
15:13:45 <hackrilege> You could enforce key characters be breaks in the parsing of the Haskell expression, in the same way Haskell string can contain a quote mark prepended by a backslash
15:14:41 <tyrion-webchat> I don't know how to handle the escape actually
15:14:51 <tyrion-webchat> I thought that ";;" could do as a separator
15:15:33 <hackrilege> I think that's the solution, you should translate the syntax first to detect the separator
15:15:39 <tyrion-webchat> but for example, if I think about python expressions, this is valid ["hi",",", "hello"] and the comma does not need any escape
15:16:14 <tyrion-webchat> and I was wondering if I could achieve something like that
15:16:33 <hackrilege> Yes, inside quote marks
15:16:54 <jophish> meoblast001: I've never had problems like that
15:17:09 <jophish> Sometimes getting the type of something can take a while
15:17:17 <tyrion-webchat> so, do you think I should try to explicitly parse strings, or something like that
15:17:19 <jophish> you could ask in #ghc-mod
15:18:21 <hackrilege> It's how you handle parsing of strings indicated by quote marks which you have highlighted twice, the time previously you were worried about your separator appearing in a string, it looks like you need to specifically handle quote mark indicated strings
15:18:36 <forker>  almost there. Still is there a better way to pass type var value other than using "dummy" function: http://lpaste.net/3010940789401321472
15:18:52 <meoblast001> jophish: apparently it's still working o_O
15:19:09 <forker> line 41/42
15:19:50 <meoblast001> does ghc-mod rely on ghc?
15:20:05 <meoblast001> because GHC is eating 25% of my CPU and i have no instances running that i know of
15:20:25 <jophish> yeah, it'll be running ghc when it's working
15:20:35 <merijn> forker: The usual way to pass in a dummy argument would be to us "Proxy t" (or, more generally "proxy t")
15:21:09 <merijn> forker: The latter way turns the proxy type into a type variable to so you can also use "Maybe t" or whatever you happen to have lying around instead of only Proxy
15:21:55 <merijn> forker: But I don't quite understand why all those constraints are needed, but then I dunno Scotty, so...
15:22:50 <forker> merijn: all those constraints arised from usage of persistent
15:22:58 * hackagebot luminance-samples 0.6 - Luminance samples  https://hackage.haskell.org/package/luminance-samples-0.6 (DimitriSabadie)
15:24:01 <forker> merijn: thanks! tommd mentioned proxy as well, looking at it..
15:24:17 <hackrilege> tyrion-webchat, maybe if you parsed the Haskell type you would have an easier job parsing the expression
15:26:35 <hackrilege> Does anyone know how to write a neat matrix diagonalise in Haskell?
15:26:47 <hackrilege> Diagonaliser
15:27:43 <tyrion-webchat> hackrilege: what do you mean parse the haskell type?
15:27:49 <hackrilege> Iv had a look at implementations using lens and Haskell vector type
15:28:59 <hackrilege> Well if you were going to read in Haskell expressions and pass them to a compiler without interpretation, the last you could do is ask ghc to return a type or read in one from the user
15:30:20 <hackrilege> Also the type syntax is pretty easy to parse, though I don't know how you would handle language extensions...
15:32:02 <hackrilege> Have you considered making your language enforce type consistency?
15:32:58 * hackagebot CoreDump 0.1.2.0 - A GHC plugin for printing GHC's internal Core data structures.  https://hackage.haskell.org/package/CoreDump-0.1.2.0 (OmerAgacan)
15:42:59 * hackagebot yaml-config 0.2.3 - Configuration management  https://hackage.haskell.org/package/yaml-config-0.2.3 (FedorGogolev)
16:01:53 <nak> > liftA2 (+) [1,2,3,4] [5,6,7,8]
16:01:55 <lambdabot>  [6,7,8,9,7,8,9,10,8,9,10,11,9,10,11,12]
16:02:01 <nak> i'm looking for [6,8,10,12]
16:02:47 <Rembane> nak: Try zipWith instead
16:03:04 <Rembane> > zipWith (+) [1,2,3,4] [5,6,7,8]
16:03:05 <lambdabot>  [6,8,10,12]
16:07:28 <nak> Rembane is there a way to lift (+) to work on two lists tho ?
16:07:50 <nak> > liftA2 (+) (Just 5) (Just 3)
16:07:51 <lambdabot>  Just 8
16:07:56 <Nylidian> > liftA2 (+) (ZipList [1,2,3,4]) (ZipList [5,6,7,8])
16:07:58 <lambdabot>  ZipList {getZipList = [6,8,10,12]}
16:08:12 <nak> Nylidian hmm, what is ZIpList
16:08:16 <nak> @src ZipList
16:08:16 <lambdabot> Source not found. Just try something else.
16:08:42 <Nylidian> It is an alternate list definition with a different applicative definition
16:09:11 <Nylidian> there is a description here: https://en.wikibooks.org/wiki/Haskell/Applicative_functors#ZipList
16:09:47 <nak> Nylidian  and how do you get the value out ?
16:09:56 <mniip> :t getZipList
16:09:58 <lambdabot> ZipList a -> [a]
16:10:01 <nak> oh
16:13:04 <nak> interesting
16:13:24 <nak> Rembane and Nylidian thank you for the help
16:13:29 <nak> honorable mention to mniip !
16:13:31 <Rembane> nak: No worries. Good luck!
16:13:50 <mniip> >:(
16:13:50 <nak> yeah i'm just learning about applicatives
16:14:13 <nak> and i was trying to imagine the list applicative working that way
16:14:20 <nak> say i did want this to work
16:14:25 <nak> (as i mentinoed earlier)
16:14:50 <nak> i'm trying to picture how fmap and ap would be implemented on List
16:16:22 <nak> brb
16:20:28 <pdxleif> GHC is like vim or emacs or something - there's always some new feature I've never heard of before? https://ghc.haskell.org/trac/ghc/wiki/Roles
16:23:53 <hpc> the bug they describe is pretty neat
16:24:23 <hpc> makes me glad i don't write compilers
16:24:33 <hpc> i'd introduce something like that and it would take a research paper to get the bug back out again
16:25:20 <E4xoi> ghc is a special case though, because big changes tend to be quite formal
16:25:26 <E4xoi> compared to other places.. 
16:26:23 <hpc> i do someday want to catch a bug in ghc though
16:26:30 <hpc> it'd be the highlight of my programming career
16:26:50 <gfixler> I want to get yelled at by Linus Torvalds
16:27:24 <E4xoi> hpc: it's not that hard to find a bug!
16:28:15 <hpc> gfixler: hah, that one isn't hard
16:28:24 <rs0> hpc: https://ghc.haskell.org/trac/ghc/report/1
16:28:46 <hpc> i mean find a new one and open it
16:28:58 <hpc> i feel like that'd be a far more interesting accomplishment than fixing a known issue
16:29:32 <E4xoi> so I was just unlucky? 
16:30:30 <E4xoi> I felt into two issues/bugs, one was a parallelism runtime bug (which was a new bug), other one was a minor issue I don't remember but found upgrading fixed it :P 
16:31:06 <hpc> unlucky or lucky
16:31:17 <hpc> or you are just doing something interesting
16:32:06 <gfixler> just saw something about zonking in the bug list - what's zonking?
16:32:26 <gfixler> ah, found it http://stackoverflow.com/questions/31889048/what-does-the-ghc-source-mean-by-zonk
16:32:29 <mniip> tyvar substitution
16:33:24 <E4xoi> hpc: does https://ghc.haskell.org/trac/ghc/ticket/10414 sound interesting to you?
16:36:01 <_ari> damn this channel is huge lol
16:36:14 <_ari> i wouldn't have expected any less of you freenode :)
16:37:16 <hpc> E4xoi: it does
16:37:31 <hpc> E4xoi: it's hard to tell what you did that would trigger it which is different from what everyone else does
16:37:38 <hpc> but threaded code is always interesting
16:38:44 <E4xoi> I was brute-forcing things, and the easiest way to have a linear (on the number of cores) speed-up seemed to be to just split things into multiple `threads` 
16:39:03 <E4xoi> so I used it as a way to learn how to play with pure parallelism 
16:39:42 <hpc> it's much more principled than my first stab at haskell's threading stuff
16:40:09 <hpc> i used forkIO and unsafeInterleaveIO to make a bunch of imgur requests
16:40:25 <E4xoi> well, at least you didn't felt into a runtime bug :P 
16:40:37 <hpc> yeah
16:41:08 <E4xoi> (I now find it funny how `unsafeInterleaveIO` worked but a `pure interface` didn't, heh)
16:41:49 <hpc> found it - http://lpaste.net/1379865192820637696
16:42:19 <tabemann> I'm currently making heavy use of concurrency in my IRC client, and it's basically a network of servers that talk to one another over STM through message-passing and like
16:43:39 <tabemann> it's not an agent architecture, in that I'm also using TMVars and TVars heavily rather than relying solely upon TQueue and TChan
16:45:13 <hpc> my current project has me updating my code to deal with a completely altered json api :(
16:45:20 <hpc> the bulk of the data was changed to csv
16:46:13 <E4xoi> hpc: well, that looks kinda safe-ish compared to what I had in mind :) 
16:48:01 <tabemann> if you're simply aiming for non-blocking-ness, what's var for?
16:48:53 <hpc> tabemann: so when i evaluate the result of the whole thing, it blocks until the IO finishes
16:49:16 <hpc> (but have the IO start first)
16:49:37 <hpc> i also only spent like 10 minutes writing that function, so it could probably be made better
16:50:29 <tabemann> I've got this design motif in my code where I have a doer thread that does stuff, and you have a function to do something that creates a TMVar, returns the TMVar, and writes the thing to be done along with the TMVar to the TQueue which the thread is reading off of, and then that thread does whatever and then writes the result to the TMVar
16:51:36 <tabemann> this has the effect that multiple things are always done in the order specified, and because we're using STM here, we can *make sure* that nothing happens between multiple things if we don't want anything to
16:52:43 <tabemann> the only catch is you cannot read the TMVar in the same atomically as when you specified the original action
16:55:59 <pyon> What's the correct way to provide my own Read instance?
16:56:19 <E4xoi> implement one?
16:56:55 <pyon> Well, yeah, but what properties do Read's methods need to satisfy?
16:57:48 <pyon> How to make my own Show instance is a lot more obvious than how to make my own Read instance.
16:58:42 <python476> hello there
16:58:56 <dmj> python476: hi
16:59:34 <python476> anyone knows about David Turner creations ? I'm trying to find if he implemented them on top of lisps or not (if it's too flamewarish or trolling then forget I asked)
16:59:46 <python476> hi dmj 
17:29:20 <hackal> Hello, is there a easy way to get current position of element being processed by list comprehension?
17:29:54 <hpc> zip the list with [0..]
17:30:09 <sbrg> pyon: I think it's basically just about making sure that "read . show = id" 
17:30:11 <jophish> hpc: beat me to it :/
17:30:13 <hpc> > zip [0..] ["one", "two", "three", "yes", "no", "maybe"]
17:30:14 <lambdabot>  [(0,"one"),(1,"two"),(2,"three"),(3,"yes"),(4,"no"),(5,"maybe")]
17:30:34 <sbrg> and there's the convention that show returns Haskell code.
17:31:33 <hackal> Thanks for suggestion
17:38:14 * hackagebot hjsonschema 0.8.0.0 - JSON Schema library  https://hackage.haskell.org/package/hjsonschema-0.8.0.0 (seagreen)
17:44:46 <ljhms> I remember seeing a demonstration a few years ago of someone running GHCi inside Emacs with an experimental pretty printer where you could interactively hide and expand parts of deeply nested (or infinite) data structures. Does anyone know what it's called?
17:47:16 <bergmark> ljhms: maybe hindent?
17:47:41 <jophish> hindent does that? I thought it was just a source formatter
17:49:23 <hackal> http://lpaste.net/143912 Here is a simple recursive function which upper cases characters in positions 0,2,4... Is the d [x] = [toUpper x] clause necessary? What is the case when d [x] = [toUpper x] is used?
17:50:05 <jophish> hackal: when the function is applied to a singleton list
17:50:16 <jophish> it doesn't match either the first or last case
17:52:50 <jophish> :t omap
17:52:51 <lambdabot>     Not in scope: ‘omap’
17:52:51 <lambdabot>     Perhaps you meant one of these:
17:52:51 <lambdabot>       ‘fmap’ (imported from Control.Monad.Writer),
17:53:29 <jle`> jophish: you're probably looking for the mono-traversable package
17:53:40 <vpm> ljhms: maybe <https://github.com/haskell/haskell-mode/wiki/Haskell-Interactive-Mode-REPL#presentations
17:53:56 <jophish> jle`: yeah, I wanted to see if lambdabot had it
17:54:19 <jle`> @import Data.MonoTraversable
17:54:19 <lambdabot> Unknown command, try @list
17:54:23 <jle`> @let import Data.MonoTraversable
17:54:24 <lambdabot>  .L.hs:98:1:
17:54:24 <lambdabot>      Failed to load interface for ‘Data.MonoTraversable’
17:54:24 <lambdabot>      Perhaps you meant
17:54:28 <jle`> i guess not ;_;
17:54:36 <jophish> was thinking about a EveryOther newtype for foldables, which would apply the function to every other element
17:58:15 * hackagebot hworker 0.1.0.0 - A reliable at-least-once job queue built on top of redis.  https://hackage.haskell.org/package/hworker-0.1.0.0 (DanielPatterson)
18:00:36 <jle`> jophish: sounds like that could definitely be a Traversal
18:00:50 <ljhms> vpm: That looks like it! Thanks!
18:01:08 <jophish> jle`: I can't think of many places it could crop up
18:01:32 <jle`> would be decently simple to write
18:02:04 <jophish> Perhaps I'll make a little package if I find myself with a spare minute
18:05:21 <jle`> > over (onMatching even) negate [7,1,8,3,5,5,8,1]
18:05:23 <lambdabot>  [-7,1,-8,3,-5,5,-8,1]
18:05:37 <jle`> > over (onMatching odd) negate [7,1,8,3,5,5,8,1]
18:05:39 <lambdabot>  [7,-1,8,-3,5,-5,8,-1]
18:05:43 <jle`> wee
18:06:04 <jle`> should have probably named it onIndexMatching
18:06:35 <jle`> @let onIndexMatching c f xs = evalStateT (traverse (\x -> StateT (\i -> (,i+1) <$> if c i then f x else pure x)) xs) 0
18:06:36 <lambdabot>  Defined.
18:06:44 <jle`> StateT is the best
18:07:05 <jophish> :i onMatching
18:07:46 <jle`> onIndexMatching :: Traversable t => (Int -> Bool) -> Traversal' (t a) a
18:08:15 * hackagebot hworker-ses 0.1.0.0 - Library for sending email with Amazon's SES and hworker  https://hackage.haskell.org/package/hworker-ses-0.1.0.0 (DanielPatterson)
18:09:14 <jle`> oh actually i'm wrong, the way i wrote it requires Monad for some reason?  how did that happen...
18:09:43 <jle`> oh, from evalStateT...
18:10:13 <pyon> This should be a compile error, right? `data Foo = Nil | Cons {-# UNPACK #-} !Int {-# UNPACK #-} !Foo`
18:10:29 <jle`> that's silly, why does evalStateT require Monad?
18:10:30 <shachaf> Well, it's not going to be unpacked.
18:10:40 <shachaf> But I think GHC will just ignore the UNPACK if it can't do it.
18:10:52 <pyon> ... why?
18:11:43 <pyon> It's Common Lisp all over again, where you have absolutely no idea what will happen when you try to optimize your code. :-|
18:12:02 <shachaf> Also, GHC will ignore UNPACK with -O0
18:12:08 <shachaf> Even if you specify it explicitly.
18:12:26 <pyon> What's the default optimization level?
18:19:55 <monochrom> ghc defaults to no optimization
18:20:12 <monochrom> cabal defaults to telling -O to ghc
18:28:17 <dm_comp> anyone find it funny that there are more people in the haskell channel then C++ :s
18:28:53 <homovitruvius> in lpaste.net/143922 I get an error if I try to build a map in template haskell code. If I simply use the fsRawContent String (changing the data declaration for VFS then everything is fine. Does somebody spot an obvious error? I cannot really post the full code as I'm traveling, on a putty connection and no working cut/paste
18:29:11 <homovitruvius> dm_comp: people these days are lazy... :-)
18:30:51 <dm_comp> homovitruvius: I like that answer :)
18:36:27 <pyon> monochrom: Ah!
18:36:54 <pyon> How can I make HLint not complain about code duplication here? http://lpaste.net/143907
18:38:17 * hackagebot BitSyntax 0.3.2.1 - A module to aid in the (de)serialisation of binary data  https://hackage.haskell.org/package/BitSyntax-0.3.2.1 (joecrayne)
18:40:58 <mgsloan> homovitruvius: The issue is that Data.Map has a Data instance that uses a function name instead of a constructor name
18:42:15 <mgsloan> Since it's not the only instance that does this, imho, dataToExpQ should detect this and allow it.
18:43:45 <mgsloan> But right now it doesn't, and wraps function names in ConE despite them being lowercase
18:46:09 <alexv19> Can anyone explain this? http://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-IntMap.html says "Many operations have a worst-case complexity of O(min(n,W)). This means that the operation can become linear in the number of elements with a maximum of W -- the number of bits in an Int (32 or 64)". Does it mean that IntMap can only store 32/64 elements efficiently?
18:56:26 <mgsloan> alexv19: That means that when n > W, it should always have the same complexity
18:57:34 <homovitruvius> mgsloan: no workaround, I presume? in this case VFS will be a file-system-in-a-string and even traversing a linear list for a match will work. The intended use is for testing.
19:00:34 <alexv19> mgsloan: so lookup takes linear time when I have more than 32 elements? Then what is the point of IntMap? Isn't it supposed to be more efficient than Map?
19:02:44 <kadoban> alexv19: I think you're misunderstanding. Asymptotically it takes time proportional to the /minimum/ of n or W, where W is a constant dependent on the machine.
19:02:55 <E4xoi> alexv19: it's the opposite actually
19:02:56 <kadoban> alexv19: So it's essentially O(k), stated oddly.
19:03:22 <jophish> pyon: You can add annotations to modules and function telling hlint what to ignore
19:03:31 <pyon> Ah!
19:05:08 <jophish> pyon: see the section here http://community.haskell.org/~ndm/darcs/hlint/hlint.htm#customization
19:05:14 <pyon> Checking.
19:06:21 <alexv19> oh ok. thanks!
19:08:02 <mgsloan> homovitruvius: Actually, I think it might be solvable for this case.  It's worth trying (everywhere (id `extT` (\v -> case v of { ConE n -> if isNameLowercase n then VarE n else ConE n; _ -> v }))
19:09:07 <mgsloan> import Generics.SYB.Schemes (everwhere); import Generics.SYB.Aliases (extT)\
19:09:19 <mgsloan> isNameLowercase needs to be defined :)
19:11:42 <mgsloan> If that works and you care about performance at all, it's best to replace it with something that doesn't traverse down every cons cell of strings :)
19:35:55 <pyon> Is there any way to avoid the use of `seq` in line 90 here? http://lpaste.net/143907
19:36:45 <E4xoi> pyon: BangPatterns, !acc
19:36:53 <E4xoi> pyon: it's the same but looks nicer
19:37:07 <codebje_> is there an mconcat-equivalent for a monoid/semigroup with a zero which short-circuits?
19:37:23 <pyon> E4xoi: I'd need !acc in both lines 89 and 90, right?
19:37:58 <E4xoi> I would believe either one would work, I normally do it in both just for clarity reasons
19:38:07 <pyon> E4xoi: Using bang patterns gets in the way of my definition for (!).
19:38:31 <E4xoi> wut? 
19:40:13 <pyon> E4xoi: Line 81.
19:40:23 <pyon> E4xoi: I just had to change it to `(!) ts n`, though.
19:41:04 <E4xoi> oh, I didn't know ... that
19:58:22 * hackagebot textPlot 1.0 - Plot functions in text.  https://hackage.haskell.org/package/textPlot-1.0 (WilliamMurphy)
20:26:28 <jophish> I wonder why Data.Complex doesn't export i :: Num a => Complex a
20:26:35 <jophish> where i == 0 :+ 1
20:27:34 <jophish> I suppose `i` might clash with quite a few names out there already, but doesn't everyone import things explicitly nowadays?
20:38:58 <EvanR> that would be annoying ;)
20:39:33 <EvanR> :t cis
20:39:34 <lambdabot> Floating a => a -> Complex a
20:39:47 <EvanR> > cis (2*pi)
20:39:49 <lambdabot>  1.0 :+ (-2.4492935982947064e-16)
20:39:56 <EvanR> > cis pi
20:39:58 <lambdabot>  (-1.0) :+ 1.2246467991473532e-16
20:40:15 <EvanR> something like that
20:40:54 <EvanR> jophish: you can put j = 0 :+ 1 somewhere
20:41:08 <EvanR> like 2pi
20:41:11 <EvanR> or twopi
20:47:04 <ReinH> codebje: What do you mean by "short-circuits"?
20:47:32 <ReinH> And, for that matter, what do you mean by "zero"?
20:47:40 <EvanR> z * x = x * z = z
20:47:44 <pyon> What's the best way to test my `Read` instance?
20:47:58 <EvanR> absorbing element
20:48:08 <ReinH> EvanR: are you codebje?
20:48:15 <EvanR> no
20:48:22 <ReinH> Then how do you know what they mean?
20:48:41 <EvanR> how much you wanna bet
20:49:05 <ReinH> You know what they say about assumptions. They make an "ass" out of "u" and "mptions".
20:49:13 <ReinH> Or something to that effect.
20:54:51 <ReinH> EvanR: and if that is what they want, I don't think there's a typeclass for it.
20:56:09 <EvanR> class Monoid a => MonoidZero a where
20:56:23 <EvanR> monoidZero :: a
20:56:47 <Job314> dumb question - when I'm using a foldl' that's returning an IO (), is there a standard way to get the starting IO ()?
20:56:58 <bitemyapp> instance Monoid a => MonoidZero (Maybe a) where; monoidZero = Nothing
20:58:54 <ReinH> Job314: return ()
20:59:07 <Job314> yeah I guess that would do it wouldn't it. Thanks
20:59:16 <ReinH> :t foldr (>=>) return
20:59:18 <lambdabot> (Monad m, Foldable t) => t (c -> m c) -> c -> m c
20:59:56 <Job314> and since return () is polymorphic it could more or less work with any monad, right?
21:00:05 <ReinH> :t return ()
21:00:06 <lambdabot> Monad m => m ()
21:00:08 <ReinH> Yep.
21:00:09 <Job314> the monad laws ensure this?
21:00:26 <ReinH> Well, return () is guaranteed to be a neutral value.
21:00:32 <EvanR> bitemyapp: doesnt work.. Just () <> Nothing is not Nothing
21:00:44 <Job314> cool. Thanks!
21:00:50 <ReinH> Job314: yw
21:02:34 <ReinH> EvanR: well yes, there could be one. I don't think it exists on hackage.
21:02:57 <ReinH> EvanR: it's also possible to have a left-zero or a right-zero but not both
21:07:42 <jle`> Job314: also definitely not a dumb question
21:09:17 <bitemyapp> EvanR: ah you're right
21:09:32 <bitemyapp> EvanR: hrrrm. was I thinking of a diff Monoid?
21:12:16 <solrize> if i want to run haskell programs on a 32-bit x86 vps, do i have to compile them on a 32 bit system?
21:19:29 <shanemikel> is there scheduled maintenance on the wiki?
21:22:19 <kadoban> solrize: I think GHC has some cross-compile support, but from what I've heard it's not very easy. If it's not too hard, I'd probably just build on whatever platform you're actually going to run on.
21:24:02 <codebje> ReinH, EvanR, I did mean a monoid with a (right) zero such that mconcat on an infinite list would terminate
21:24:29 <codebje> I did something more or less demonstrating the plausibility here: https://gist.github.com/codebje/775825fa87325f8346e4
21:24:55 <codebje> but while I do see a couple of type packages on hackage, I don't see any with the accompanying function
21:25:09 <ReinH> > mconcat (Any True : repeat (Any False))
21:25:11 <lambdabot>  Any {getAny = True}
21:25:15 <ReinH> mconcat is such a function
21:25:48 <codebje> yes, but not for strict functions like (*) on Product :-)
21:25:48 <ReinH> as long as the implementation of <> is sufficiently non-strict
21:25:51 <codebje> yeah.
21:25:52 <codebje> that
21:26:29 <solrize> kadoban, thanks
21:31:24 <Job314> If I have a thing that's returning IO [ IO ()], can I force eval to IO ()?
21:32:43 <ReinH> :t join . fmap sequence_ :: IO [IO ()] -> IO ()
21:32:44 <lambdabot> IO [IO ()] -> IO ()
21:34:01 <Job314> sounds good. thanks
21:49:42 <Cale> Job314: uh, really I feel like I should be asking to see that code
21:49:54 <Cale> Job314: Did you write the thing which has type IO [IO ()]?
21:50:01 <Cale> when you meant to write something of type IO () ?
21:50:32 <Cale> (Or rather, I feel that ReinH should have asked ;)
21:50:35 <Cale> heheh
21:53:29 <ReinH> Cale: :)
21:54:22 <ReinH> That's a rather unusual type.
21:54:46 <Cale> It's common if you're a beginner who doesn't know what you're doing :)
21:55:12 <Cale> and you write something like  map print (...)
21:55:53 <ReinH> right
21:56:02 <bitemyapp> so the answer is to have traversed it to begin with
21:56:06 <bitemyapp> not to give them mop-up code
21:56:15 <ReinH> yep
21:56:16 <bitemyapp> you don't win karma for making the learner go away as quickly as possible
21:56:20 <ReinH> ...
21:56:40 <ReinH> bitemyapp: there's no need to be rude
21:57:00 <bitemyapp> That wasn't rude, it was frank.
21:57:08 <Job314> yep pretty much did that
21:57:20 <Job314> let me pastebin it
21:57:22 <Job314> one sec
21:57:23 <ReinH> I don't appreciate the implication that I was trying to "make the learner go away"
21:57:46 <bitemyapp> I don't think that's your actual motivation, but the hastiness is a disservice to the learners.
21:58:30 <bitemyapp> Ask for code when the type looks wacky. Don't rush into the y of the x-y.
21:58:46 <Job314> i think listFilesInDir is OK, but something has gone wrong in firstNLines http://lpaste.net/143939
22:01:11 <bitemyapp> Job314: I think I see the problem.
22:01:36 <bitemyapp> Job314: or at least one, anyway. I'll post an amended version with an explanation after I finish cleaning up.
22:01:59 <Job314> thanks!
22:02:11 <bitemyapp> Job314: just to dig into the psychology a little
22:02:18 <bitemyapp> Job314: are you trying to avoid do syntax?
22:02:23 <Job314> yes
22:02:42 <Job314> is that wrong?
22:02:58 <ReinH> Do syntax is pretty useful
22:03:10 <ReinH> They went to all that trouble to add it to the language, after all.
22:04:12 <bitemyapp> Job314: use do syntax, it's nice.
22:04:17 <bitemyapp> Job314: https://gist.github.com/bitemyapp/2311fcbfa152ce0980ed
22:04:38 <bitemyapp> Job314: you don't _have_ to use do syntax, but when you're new it's especially a good idea so you don't get turned around like you just did.
22:05:07 <bitemyapp> Job314: I can tell you know how to deal with problems (you know when to use Applicative), but sometimes you need to retrace two steps rather than one to clean something up.
22:05:41 <Job314> OHHH mapM_ is made to do this
22:05:43 <bitemyapp> Job314: anyhoo, that should be a fair bit nicer. The other detail is to notice I used mapM_ instead of mapM
22:05:52 <bitemyapp> Job314: right yes.
22:05:53 <Job314> and the applicative syntax means you have to clean up after doing it
22:05:54 <bitemyapp> @ty mapM
22:05:55 <bitemyapp> @ty mapM_
22:05:55 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
22:05:57 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
22:06:01 <bitemyapp> Job314: sorrrtta.
22:06:17 <bitemyapp> Job314: like I said in the notes, the issue is you had inHandle/outHandle in the where clause.
22:06:31 <bitemyapp> Job314: that's not the same thing as a monadic bind like the   <-  in the do syntax.
22:06:34 <glguy> mapM_ (\_ -> readAndWrite inHandle outHandle) [1..n] --to-- replicateM_ n ...
22:06:41 <bitemyapp> Job314: the type of inHandle and outHandle changed.
22:06:52 <glguy> (unless there's more context that I didn't read in the backlog)
22:06:55 <bitemyapp> glguy: that's even better, I was trying to not to get too far removed.
22:07:05 <bitemyapp> glguy: there was a more elementary issue going on (where vs. binding in do syntax)
22:07:15 <glguy> OK, carry on :)
22:07:25 <bitemyapp> Job314: glguy's version is even nicer, you should try rewriting it using replicateM_ as he suggested as an exercise :)
22:08:13 <bitemyapp> Job314: hope this helps, I should get back to work :)
22:08:18 <Job314> thanks!
22:35:44 <pavonia> I'm trying to build json-0.9.1, but when GHC compiles module Text.JSON.Parsec the CPU usage goes to 100% and after some time it crashes because it's running out of memory. Compiling this module separately works fine without optimization enabled, with -O2 it crashes. Is there any way to debug what's going on?
22:36:04 <lispy> pavonia: how much ram do you have?
22:36:25 <pavonia> About 400 MB free
22:36:42 <lispy> I'd recommend about 2GB minimum for compiling with GHC
22:36:56 <pavonia> All other modules compile fine with <60 MB though
22:37:21 <lispy> It's usually linking that is terribly memory hungry
22:44:44 <pavonia> lispy: Not sure it's the linking phase here. If I compare -v3 with another module, it doesn't seem to reach the linking phase. The last line before it crashes is "*** Simplifier Phase 0 [post-worker-wrapper]:"
22:50:27 <srhb> join #nixos
22:50:29 <srhb> Woops
22:58:19 <pavonia> I found a bug report for this https://bugs.gentoo.org/show_bug.cgi?id=427838 and it says a workaround was applied but it doesn't mention the actual code changes :/
23:06:38 <mmm> I am looking for remote job.
23:11:21 <pavonia> Okay, removing the XXX marked functions in that module and using the parsec Applicative instance instead fixed the problem
23:19:34 <eklavya> how do I read - instance HasVars (M.Map String Integer -> Maybe Integer) ?
23:20:10 <lamefun> Is there a support for statically dynamic values in Haskell?
23:20:45 <pavonia> eklavya: Are you familar with type classes?
23:20:58 <eklavya> I think so, yes
23:21:17 <eklavya> but aren't they supposed to be implemented for a type?
23:21:20 <codebje> eklavya, that doesn't look like a complete definiton of a HasVars instance - HasVars is a multiparameter type class
23:21:38 <codebje> (M.Map String Integer -> Maybe Integer) is a type
23:21:42 <lamefun> Eg. for SQL queries, etc.
23:22:06 <codebje> lamefun, String?
23:22:10 <eklavya> class HasVars a where
23:22:11 <eklavya>   var :: String -> a
23:22:21 <eklavya> it takes a single param
23:22:22 <codebje> hm, not the same HasVars I'm thinking of then :-)
23:22:31 <pavonia> lamefun: What are statically dynamic values?
23:23:14 <codebje> cis194?
23:23:20 <eklavya> codebje yes :P
23:23:47 <eklavya> it's a wonderful resource, someone told be about it in #idris
23:24:12 <codebje> some day I'll complete all the exercises :-)
23:24:28 <eklavya> I am having fun so far :)
23:24:48 <codebje> the type of `var` is String -> a
23:25:02 <codebje> the type of `a` for that instance is (M.Map String Integer -> Maybe Integer)
23:25:14 <codebje> so the type of `var` for that iinstance is String -> M.Map String Integer -> Maybe Integer
23:25:25 <liste> lamefun Data.Dynamic ?
23:25:29 <eklavya> so a can be anything, even a function type?
23:25:42 <codebje> that's what higher order programming is for :-)
23:25:51 <lamefun> pavonia, I want to make a stat-like function with flags, and I want to pass queries both statically and dynamically, and when I pass them statically, I don't want a result type full of maps or maybes.
23:26:30 <codebje> data Query = StaticQuery1 | StaticQuery2 | DynamicQuery String
23:26:30 <eklavya> codebje so I can have a typeclass implementation for functions with common signature?
23:26:32 <codebje> ?
23:26:57 <codebje> for that _function type_
23:27:28 <codebje> the typeclass definition of `var` is "a function which takes a String and returns the parameterised type"
23:27:28 <eklavya> ok
23:27:43 <codebje> in this case, the parameterised type is a function so var is a function which returns a function matching that signature
23:27:58 <codebje> var :: String -> (M.Map String Integer -> Maybe Integer)
23:27:58 <eklavya> cool
23:28:00 <pavonia> lamefun: Maybe you want a typeclass for the query functions with result types depending on the input query type?
23:28:06 <codebje> if we put the explicit parentheses in
23:29:09 <eklavya> thanks codebje :)
23:39:18 <Zemyla> Hmm. Why is Proxy not listed as a Representable functor?
23:39:21 <lamefun> I'll probably make something that is bloated and takes ages to compile...
23:42:26 <Zemyla> Oh, Proxy is representable.
