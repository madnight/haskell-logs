00:00:08 <jle`> Gurkenglas: btw, where is your Applicative instance for Exp ?
00:00:39 <Gurkenglas> jle`, I need none
00:00:53 <jle`> but how is GHC not complaininng about Traversable
00:01:04 <jle`> oh
00:01:05 <Gurkenglas> Traversable implies Functor and Foldable
00:01:07 <jle`> Traversable only needs Functor
00:01:18 <jle`> of course, heh
00:02:16 <jle`> try writing the last branch pointfully
00:03:11 <Gurkenglas> "phi x = \vars -> arithmetic <$> sequenceA (sequenceA x) vars"? :s
00:03:42 <Gurkenglas> umm that ) is one token too early
00:03:45 <jle`> i feel like that's different than what you have
00:03:51 <jle`> ah mhm.
00:22:00 <MP2E> hi, not sure if this is the proper channel for this, but how can I use stack with a project that requires a library not found on stackage? I tried making a local cabal sandbox and installing it to that, but stack doesn't seem to 'see' the dependency
00:23:31 <liste> MP2E https://github.com/commercialhaskell/stack/blob/master/doc/faq.md#i-need-to-use-a-package-or-version-of-a-package-that-is-not-available-on-hackage-what-should-i-do
00:23:42 <MP2E> oh oops, thanks for the reference
00:24:21 <liste> or the question above it
00:35:14 <YellowOnion> is there an easy to understand lens parsing library / tutorial?
00:36:45 <YellowOnion> I currently have a parser that turns a byteString in to a Data structure, but I'm thinking of modifying a field and recerealising it. and that seems perfect for viewing through a lens
00:37:12 <julianleviston> YellowOnion: depends on your background
00:37:49 <julianleviston> YellowOnion: there’s this https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/basic-lensing and this. https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
00:39:08 <YellowOnion> julianleviston, I was hoping for something parsing centric
00:39:39 <ReinH> YellowOnion: parsing or serialization?
00:40:09 <ReinH> You can use the decode . encode isomorphism from the Binary class (https://hackage.haskell.org/package/binary-0.7.6.1/docs/Data-Binary.html)
00:40:58 <YellowOnion> sorry serialisation, I'm currently using cereal because it seems to be the only package with direct IEEE support.
00:41:51 <ReinH> A silly example:
00:41:53 <ReinH> > over (iso reverse reverse) (\(x:xs) -> toUpper x : xs) "hello"
00:41:55 <lambdabot>  "hellO"
00:43:00 <YellowOnion> ReinH, binary is almost identical cereal anyway. I guess I gotta figure out how to make a Putter
00:53:55 * hackagebot patches-vector 0.1.2.0 - Patches (diffs) on vectors: composable, mergeable, and invertible.  https://hackage.haskell.org/package/patches-vector-0.1.2.0 (LiamOConnorDavis)
01:03:57 <nchambers> how would I install a module? specifically Text.Regex.Posix
01:04:36 <malical> Well 50% of it works. And the other 50% is written. So that's good enough for now.
01:04:59 <tsahyt> nchambers: cabal install regex-posix?
01:05:05 <nchambers> thanks
01:05:24 <tsahyt> This installs the regex-posix package, which has this module. You can't install a module on its own.
01:05:33 <nchambers> oh ok. that makes sense
01:05:55 <tsahyt> Also, unless you're already in a sandbox, this installs it globally.
01:06:01 <tsahyt> Otherwise it goes in the cabal sandbox
01:06:03 <lpaste> Magnus pasted “optparse-applicative: How to make a parser for this” at http://lpaste.net/142561
01:06:20 <tsahyt> You can also just add it as a dependency to your cabal file and use cabal install --only-dependencies and it will figure out everything for you
01:06:37 <magthe> Any pointers on how to achieve this? http://lpaste.net/142561
01:07:48 <tsahyt> magthe: pure Dump should have the type you're looking for
01:09:06 <magthe> tsahyt: indeed... thanks!
01:10:25 <malical> Well good night all.
01:10:40 <fizruk> or good morning
01:11:01 <thimoteus> night malical 
01:11:04 <malical> Or both.
01:11:21 <julianleviston> malical: goodnight! :) sweet haskell dreams
01:11:52 <quicksilver> having spend years explaining to people that haskell doesn't do automatic memoization, GHCi just surprised me by memoizing my calculation... automatically.
01:12:23 <fizruk> quicksilver: you sure?
01:12:57 <Axman6> quicksilver: yeah, it always surprises me when it does that
01:12:58 <quicksilver> fizruk: I have an IO() action which does a time consuming pure computation (about 5 seconds) and summarises the results
01:13:11 <quicksilver> it runs instantly the second time
01:13:27 <quicksilver> GHC must have let-floated the pure part of my computation to the top level where GHCi keeps it alive as a CAF.
01:13:29 <fizruk> quicksilver: the pure computation is shared
01:14:23 <quicksilver> fizruk: shared between two pieces of code with the same name in scope, sure
01:14:34 <quicksilver> shared between two separate top-level invocations of an IO action - less expected
01:14:43 <quicksilver> but that's what happens if you float things to the top level
01:14:53 <quicksilver> potentially a nasty space leak too :P
01:15:46 <fizruk> quicksilver: I am no expert, but just the same thing seems to happen with manual memoization in haskell, no?
01:16:42 <quicksilver> yes, it's generally accepted that you can assume a name with no parameters (a 'value') will be evaluated only once and shared for as long as it stays in scope
01:17:02 <quicksilver> it's less clear how often you can rely on a name buried in a subroutine being shared between separate invocations
01:17:21 <quicksilver> whether or not it can float up depends whether or not it depends on any expressions which only exist in that scope
01:17:33 <quicksilver> we don't have a precise operational semantics for this stuff
01:17:46 <quicksilver> (if we did, it would tie the compilers' hands)
01:18:39 <fizruk> so the "IO action memoization" is just how compiler has decided to rearrange your code, so that sharing happens?
01:18:55 <quicksilver> I think so.
01:19:30 <quicksilver> I'm surprised because my pure computation is *not* independent
01:19:35 <quicksilver> it depends on the parameters to the action
01:19:51 <quicksilver> so it suggests that GHC has rearranged the code to factor out that dependency to the top level
01:19:54 <quicksilver> or something.
01:19:59 <quicksilver> basically I'm surprised :)
01:22:55 <urbanslug> Is there a function for (a -> IO Bool) -> [a] -> [a]
01:23:13 <fizruk> :t filterM
01:23:14 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
01:23:51 <julianleviston> fizruk: that’s not quite the same, is it?
01:24:05 <quicksilver> no, but it's the closest you can get without cheating
01:24:20 <julianleviston> fizruk: actually I don’t really understand what (a -> IO Bool) -> [a] -> [a] means! :)
01:24:44 <capisce> const id?
01:28:34 <julianleviston> :t flip const
01:28:35 <lambdabot> b -> c -> c
01:28:55 <julianleviston> zipper:  what should it do?
01:29:28 * hackagebot hasty-hamiltonian 1.1.0 - Speedy traversal through parameter space.  https://hackage.haskell.org/package/hasty-hamiltonian-1.1.0 (JaredTobin)
01:29:55 <zipper> julianleviston: filterM will do the trick.
01:29:59 <julianleviston> zipper: sweet.
01:34:34 * hackagebot mighty-metropolis 1.0.1 - The Metropolis algorithm.  https://hackage.haskell.org/package/mighty-metropolis-1.0.1 (JaredTobin)
01:34:36 * hackagebot speedy-slice 0.1.2 - Speedy slice sampling.  https://hackage.haskell.org/package/speedy-slice-0.1.2 (JaredTobin)
01:36:15 <quicksilver> Axman6: I really don't understand, having re-read it. It's clearly dependant on parameters and, which is more, it has IO (putStrLn) buried inside the computation.
01:36:23 <quicksilver> Axman6: this is some magic indeed.
01:39:35 * hackagebot hasty-hamiltonian 1.1.1 - Speedy traversal through parameter space.  https://hackage.haskell.org/package/hasty-hamiltonian-1.1.1 (JaredTobin)
01:40:58 <julianleviston> Is “monoidal pure” return?
01:41:19 <julianleviston> sorry… pure from applicative functor re-set into a Monad context?
01:41:24 <julianleviston> Monadic “pure”*
01:41:51 <quicksilver> yes, julianleviston 
01:41:59 <quicksilver> for all monads, return = pure
01:42:01 <julianleviston> quicksilver: woo :)
01:42:21 <quicksilver> ACHIEVEMENT UNLOCKED: understood relationship between Applicative and Monad
01:42:33 <julianleviston> quicksilver: +1 to Bonus Power.
01:42:43 <quicksilver> use your powers wisely.
01:42:46 <julianleviston> quicksilver: seriously we should make Haskell the game… with achievements.
01:43:00 <tsahyt> julianleviston: They're separate things for historical reasons. Since Applicative is now a proper superclass of Monad, there's a proposal to implement return in terms of pure now.
01:43:10 <tsahyt> See this: https://mail.haskell.org/pipermail/libraries/2015-September/026121.html
01:44:03 <julianleviston> tsahyt: I’ve often wondered why map isn’t inplemented in terms of fmap… or is it now? (I’m on a prev version of GHC)
01:45:08 <tsahyt> Lists have also been treated separately from Functors for historical reasons. I think map still has its special list implementation
01:45:29 <julianleviston> tsahyt: oh… what’s AMP?
01:45:41 <julianleviston> applicative monad proposal?
01:45:52 <tsahyt> Yes
01:45:57 <julianleviston> :)
01:46:02 <tsahyt> Actually, fmap for lists is implemented in terms of map
01:46:08 <tsahyt> http://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Base.html#line-712
01:46:56 <tsahyt> I actually kind of like it this way. When I read map in the middle of some point free expression, I instantly know the surrounding types that way.
01:47:14 <quicksilver> I agree tsahyt although ad absurdum that argument can be used against any typeclass overloading
01:47:35 <quicksilver> why is 'map' special, why don't we also use specialised mapLeft and mapMaybe and and and...
01:47:51 <tsahyt> :t mapMaybe
01:47:52 <lambdabot> (a -> Maybe b) -> [a] -> [b]
01:47:57 <tsahyt> mapMaybe is specialised
01:48:03 <quicksilver> that's actually not what I mean :)
01:48:14 <quicksilver> I meant "mapMaybe :: (a -> b) -> Maybe a -> Maybe b"
01:48:19 <quicksilver> maybe mapJust would be the right name for it
01:48:24 <quicksilver> but everyone uses fmap of course
01:49:11 <tsahyt> Oh, okay. Well, I generally agree of course. But having worked with the classy prelude a few months ago, I really started to appreciate having some specialised functions
01:49:47 <tsahyt> I actually ended up giving the whole thing the boot and reverting the whole project back to the standard prelude, because the compiler messages became an absolute mess
01:50:29 <tsahyt> And then there was the instance of a piece of code not actually compiling with ClassyPrelude, which compiled just fine with the standard prelude.
01:50:35 <julianleviston> quicksilver: yeah, that was my first thought when I first encountered fmap… i was surprised there wasn’t just “map” which meant fmap… seemed it’d make it a lot simpler to understand to me.
01:50:42 <tsahyt> I guess the bottom line is that polymorphism isn't really that free.
01:51:07 <julianleviston> ah
01:51:58 <tsahyt> At the least it comes with some mental overhead. In the worst case, you can make your code polymorphic enough (with liberal use of compiler extensions) that the compiler can't infer your types anymore
01:52:12 <tsahyt> But that's really nothing to worry about for simple things like map/fmap
01:53:20 <bernalex> dibblego: ping?
01:53:48 <dibblego> bernalex: aling
01:54:04 <bernalex> dibblego: may I PM you? (it's about NICTA :)
01:54:16 <dibblego> sure
01:54:35 * hackagebot persistent-mysql 2.3.0.2 - Backend for the persistent library using MySQL database server.  https://hackage.haskell.org/package/persistent-mysql-2.3.0.2 (MichaelSnoyman)
01:55:24 <quicksilver> tsahyt: yes. It's not free. There is a mental overhead.
01:55:58 <quicksilver> tsahyt: there is also a mental benefit which comes from realising that 'different' algorithms are actually different instances of the same algorithm, which can help you 
01:57:20 <tsahyt> That's true, yeah. I think it's a matter of experience to find the "right" amount of polymorphism, so your functions are easy enough to use and understand, but still powerful enough to be applicable to a wide variety of problems
02:13:07 <quicksilver> it's also subjective
02:13:23 <quicksilver> what's right for you today will not be right for you tomorrow; and might not be what's right for the users of your code
02:13:29 <quicksilver> not that that is a uniquely haskell problem
02:21:43 <nchambers> hey could someone help me with this? heres my program: http://sprunge.us/SjbA and here are the errors: http://sprunge.us/GCKF sorry, am beginner
02:22:37 <vincenz> Hmm, tough problem: Making a priority queue for a strict partial order (or more specifically, a pareto-order)
02:24:50 <quicksilver> vincenz: http://cs.stackexchange.com/questions/7890/priority-queue-for-partially-ordered-priorities-with-infima seems relevant
02:24:54 <quicksilver> and, yes, it seems tough.
02:25:11 <vincenz> quicksilver: yes that's all I found but there was no conclusion there
02:26:55 <quicksilver> nchambers: sure. you can't quite use =~ like that, but I forget exactly how you can use it.
02:26:59 <quicksilver> nchambers: I try to look it up
02:27:42 <Axman6> I was having a look at RegexContext and can't see an obvious instance for String [String]
02:28:12 <Axman6> I don't understand the purpose of RegexLike, it doesn't seem to havea ny instances
02:28:52 <tsahyt> Axman6: RegexLike Regex (Seq Char) is an instance
02:29:04 <tsahyt> Fun with multi parameter type classes...
02:29:30 <nchambers> quicksilver: thannks
02:30:08 <tsahyt> nchambers: The gist of it is, that (=~) has different behavior depending on the types you expect from it. You're expecting the result to be [String], but it cannot do that, because there's no instance declaration for it
02:30:11 <Axman6> tsahyt: where are you seeing that? I'm not seeing anything in https://hackage.haskell.org/package/regex-base-0.93.2/docs/Text-Regex-Base-RegexLike.html#t:RegexLike
02:30:41 <tsahyt> Axman6: http://hackage.haskell.org/package/regex-posix-0.95.2/docs/Text-Regex-Posix-Wrap.html
02:30:45 <tsahyt> The Regex type
02:31:17 <quicksilver> the purpose of RegexLike is to let you use bare strings
02:31:23 <quicksilver> but also use 'compiled' Regexes
02:31:27 <nchambers> tsahyt: oh
02:31:28 <quicksilver> as your regular expression
02:31:33 <quicksilver> I think?
02:31:39 <bernalex> any galois employees here by any chance?
02:31:50 <quicksilver> the regex docs used to have a list of the major overloads of =~ and now they don't?
02:31:53 <quicksilver> annoying
02:31:57 <quicksilver> sorry, I mean
02:32:05 <quicksilver> a list of the *meanings* of the overloads
02:32:08 <quicksilver> not jsut the instance list
02:32:11 <Axman6> yeah, the docs are pretty unhelpful imo
02:32:21 <quicksilver> they weren't this unhelpful last time I looked
02:33:11 <nchambers> so if I change the return type to String, I get "parser: user error (Text.Regex.Posix.String died: (ReturnCode 11,"Invalid range end"))"
02:33:34 <quicksilver> nchambers: what are you hoping for btw? all the submatches?
02:34:05 <nchambers> quicksilver: yes
02:34:32 <tsahyt> nchambers: Well, grep says the same thing. Your regex is invalid
02:34:34 <quicksilver> try [[String]]
02:34:52 <quicksilver> that is, chaneg the type sig of tokenize to String -> [[String]]
02:35:00 <quicksilver> but also fix your regexp :)
02:35:02 <nchambers> tsahyt: it shouldn't be. I got it from another guy who has a working version and I tested it on regex101
02:36:09 <quicksilver> nchambers: \\-* is invalid
02:36:14 <quicksilver> because:
02:36:21 <quicksilver> > map ord "\\*"
02:36:23 <lambdabot>  [92,42]
02:36:24 <tsahyt> nchambers: It's possible that it works in some regex dialect, but neither grep nor regex-posix supports some feature in there
02:36:32 <quicksilver> backslash is 92 and * is 42
02:36:37 <quicksilver> so the range between them is nonsense
02:37:23 <nchambers> hmmm ok. thanks
02:37:43 <quicksilver> the most useful docs for the overloading are here btw:
02:37:44 <quicksilver> https://hackage.haskell.org/package/regex-base-0.93.2/docs/Text-Regex-Base-Context.html
02:37:56 <tsahyt> "Sorry, it's just not there"
02:38:14 <quicksilver> so my advice corresponds to - at the very end of that page - "Four containers for text of all matches and their submatches: - RegexContext a b [[b]]"
02:38:19 <quicksilver> in your case b = String
02:38:22 <quicksilver> so [[String]]
02:38:29 <quicksilver> is all possibly matches and all their submatches
02:38:55 <quicksilver> personally I do not think the overloading of =~ represents good library design. FWIW.
02:39:27 <tsahyt> It feels kinda non-idiomatic
02:39:33 <tsahyt> It also looks like magic to beginners
02:39:48 <quicksilver> not very good magic, either
02:39:51 <Axman6> not just beginners...
02:40:04 <quicksilver> it doesn't look like magic to me, Axman6 :)
02:40:14 <quicksilver> it just looks like bad use of overloading coupled with hard to navigate docs.
02:40:45 <tsahyt> That [[b]] thing is actually suprisingly easy to find in GHCi
02:40:47 <Axman6> sure, I understand it, but finding out what I can actually do involves diving into many rabbit holes
02:40:59 <tsahyt> it's the second instance returned by :i RegexContext
02:41:13 <quicksilver> nchambers: FWIW - despite being a professional perl programmer - I never use regex in haskell
02:41:35 <tsahyt> Parsers are just too easy to write in Haskell
02:41:47 <Axman6> quicksilver: you've just shocked me... professional perl programmer? D:
02:41:51 <quicksilver> my opinion now is that regex are for programs where the user specifies a pattern at runtime (e.g. writing a text editor or a search/repalce tool) but programmers have better tools.
02:42:29 <quicksilver> Axman6: always have been :) doesn't it show?
02:42:37 <Axman6> agreed, the only time I used regexes is when doing find(/replace)
02:42:43 <Axman6> quicksilver: no!
02:42:45 <fizruk> I could really use Alt instance for Either e without adding semigroupoids dependency, is there a plan to add that to base sometime in the future?
02:44:45 * hackagebot opaleye 0.4.2.0 - An SQL-generating DSL targeting PostgreSQL  https://hackage.haskell.org/package/opaleye-0.4.2.0 (tomjaguarpaw)
02:45:51 <quicksilver> fizruk: the problem is what to use for 'empty'
02:46:27 <fizruk> quicksilver: Alt is only <!>
02:46:45 <fizruk> quicksilver: to be clear: Alt, not Alternative
02:46:53 <quicksilver> oh
02:47:08 <quicksilver> well that's confusing because in base Alt is a type constructor
02:47:19 <quicksilver> is it also a typeclass somewhere? presumablye in semigroupoids
02:47:31 <fizruk> yeah, there's also a different Alt if free package
02:47:42 <fizruk> quicksilver: yes, in semigroupoids
02:48:03 <fizruk> quicksilver: https://hackage.haskell.org/package/semigroupoids-5.0.0.4/docs/Data-Functor-Alt.html
02:48:06 <quicksilver> fizruk: so the answer is no :)
02:48:21 <quicksilver> there is no proposal that I am aware of to add any of the semigroupoids machinery to base
02:48:30 <fizruk> :(
02:49:11 <quicksilver> it's not such a terrible dependency to have though is it?
02:49:23 <quicksilver> I mean edwardk modules get a free-pass dependency wise IMO.
02:49:26 <fizruk> perhaps when people get used to NonEmpty and semigroups, there will be one though... in the distant future
02:50:36 <fizruk> quicksilver: well, semigroupoids is not that light and it does not seem reasonable to add such a dependency for <!> on Either e only)
02:50:50 <fizruk> currently I just define <!> locally
02:51:37 <quicksilver> yes
02:51:45 <quicksilver> I call it `orElse`
02:51:50 <quicksilver> and I have defined it in more than one project :)
02:52:33 <quicksilver> (tryThis <> thenThis <> thenThat) `orElse` (hmmTryThat <> andMaybeThat <> that'sGood) `orElse` iGiveup
02:53:23 <quicksilver> orElse + MaybeT is quite a common pattern
02:53:39 <mattby> Hi, how does one call the property of a function saying that `f (f x) = x` ?
02:53:54 <fizruk> mattby: self-inverse?
02:54:18 <fizruk> quicksilver: yeah, except I have Either :)
02:55:03 <srhb> mattby: f is then an involution.
02:55:15 <srhb> If it's for all x, anyway. :)
02:56:03 <fizruk> hmm, involution is self-inverse, good to know :)
02:57:29 <quicksilver> self-inverse is more generally used in any group context
02:57:53 <quicksilver> involution is specifically functions (functions a->a being a group under composition)
02:59:09 <quicksilver> fizruk: here is a discussion: https://mail.haskell.org/pipermail/libraries/2015-April/025441.html
02:59:41 <fizruk> aha, thanks!
03:02:41 <mattby> fizruk: srhb: thanks!
03:22:29 <nicow> Hi, I'm running the profiling example from real world haskell on my computer. It's computing the mean from the range [1 .. 1e7], which takes some time. The profiling says that the program ran in ~ 1 second, which is definitely not true. Am I missing something?
03:23:19 <pacak> nicow: Probably GC time?
03:23:38 <liste> nicow do you print out the mean?
03:23:41 <pacak> nicow: Paste full profiling output to somewhere
03:24:14 <nicow> liste: I am printing the mean
03:24:27 <nicow> pacak: is the GC time not taken into account in the profiling?
03:24:39 <pacak> nicow: It is, but on a separate line
03:24:58 <akegalj> nicow: run the program with +RTS -sstderr and you'll see GC time
03:25:55 <akegalj> nicow: paste the output of -sstderr to lpaste and send us a link
03:28:37 <nicow> akagalj: thanks, looking into that
03:31:11 <nicow> pacak, akegalj: it is indeed GC time, but it shows up on rws' graphs, not on mine. I'm getting them as ps through hp2ps.
03:31:57 <pacak> RWH might be a bit outdated in some places.
03:32:48 <akegalj> nicow: so you are confused with time showed in .ps files ?
03:33:14 <nicow> akegalj: I think I am. I just figured out it shows neither GC nor profiling times.
03:33:20 <akegalj> nicow: I have used .ps files only to visualize memory usage
03:33:56 <nicow> akegalj: That's what I am doing, I was just surprised that memory usage was spanning a second or less even though the program took a few minutes to run
03:34:22 <akegalj> nicow: bare in mind that profiling might have some minor inconsistencies
03:35:08 <akegalj> nicow: oh, that might be kernel doing something. The graph shows only the time spent doing actual work in a program
03:35:52 <nicow> akegalj: mutator time that is, then? thanks for your help, everything got much clearer
03:36:01 <akegalj> nicow: If you run your program with time prefix (if you are on unix). Like: `time ./program` it will give you time profiles for real, user and system
03:36:40 <akegalj> nicow: it looks like real is big in your case (for some reason), and user is really the time spent doing actual work in your program
03:37:54 <nicow> akegalj: that makes sense with what I understood over the few minutes. I'll need to dive into the ghc events to figure out when and where the GC is taking time then
03:38:58 <akegalj> nicow: bare in mind that you could get slightly different results in .ps graphs and in -sstderr . Guys from #ghc told me there are some inconsistencies with collecting these informations which are addressed in the ghc HEAD (or will be).
03:40:03 <akegalj_> nicow: is -sstderr telling you that you have low productivity? If that is the case then GC is doing all the work
03:40:07 <akegalj_> nicow: is -sstderr telling you that you have low productivity? If that is the case then GC is doing all the work
03:41:21 <tesrty> Another day another haskell.
03:42:50 <nicow> akegalj: I have less than half a percent of productivity, and the rest is split 50-50 between GC and profiling
03:43:11 <dave32> anyone know how I can tell stack where to find includes?
03:44:09 <akegalj_> nicow: then you have the answer. Your program is producing to many garbage (thunks probably) which force GC to collect them.
03:44:35 <merijn> nicow: Do you have an example of the problematic code/profiling info online somewhere?
03:44:39 <akegalj_> nicow: if it is a sample from RWH, then that is ok. RWH is trying to show you that usecase
03:45:36 <akegalj_> nicow: ill send you one file to see some examples. Just a min
03:46:29 <dave32> nvm found it in the yam file.
03:46:34 <dave32> *yaml
03:49:00 <Myrl> Is there some kind of String <-> ByteString compatibility layer out there?
03:49:23 <akegalj_> nicow: http://lpaste.net/142568  try running these
03:50:08 <merijn> Myrl: Data.Text.Encoding
03:50:20 <merijn> Myrl: Despite the name ByteString has nothing to do with String
03:50:32 <merijn> Myrl: If you want binary data out of String you'll have to encode it
03:50:35 <nicow> akegalj: it is indeed from rwh, and I was just wondering why my graph was only spanning a second instead of the few minutes it took to run. Thanks for the link, I'll look into that
03:51:01 * quicksilver is slowly working through smdiehl's "What I Wish I Knew When Learning Haskell"
03:51:37 <quicksilver> lots of good stuff there
03:52:23 <Myrl> merijn: Ah right. A bytestring is a byte array.
03:52:31 <quicksilver> Myrl: if you want to pretend that bytes are characters (i.e. ASCII) you can use the .Char8 versions of the modules which will give you functions typed for Chars. but merijn is right if that's not your use case
03:52:33 <tsahyt> Is there a function to get all subsequences of a given length from a list?
03:53:10 <quicksilver> > map (take 3) . tails $ "abcdefgh"
03:53:11 <Myrl> quicksilver: merijn: I'll be using it for Network.Socket.
03:53:12 <lambdabot>  ["abc","bcd","cde","def","efg","fgh","gh","h",""]
03:53:20 <quicksilver> like that, tsahyt ?
03:53:33 <tsahyt> Well almost, "gh", "h", "" shouldn't be in the list
03:53:52 <quicksilver> > takeWhile ((==3).length) . map (take 3) . tails $ "abcdefgh"
03:53:54 <lambdabot>  ["abc","bcd","cde","def","efg","fgh"]
03:54:03 <Myrl> Hmmm
03:54:12 <Myrl> > map (take 3) . init . init . init . tails $ "abcdefgh"
03:54:13 <lambdabot>  ["abc","bcd","cde","def","efg","fgh"]
03:54:23 <Myrl> Would probably be more efficienty.
03:55:14 <quicksilver> > take 6 . map (take 3) . tails $ "abcdefgh"
03:55:16 <lambdabot>  ["abc","bcd","cde","def","efg","fgh"]
03:55:33 <quicksilver> for values of '6' asymptotically approaching (length "abcdefgh" - 2)
03:55:35 <quicksilver> :P
03:55:42 <Myrl> lol
03:55:48 <tsahyt> map (take 3) . (!! 3) . interate init . tails $ "abcdefg"
03:55:50 <tsahyt> > map (take 3) . (!! 3) . interate init . tails $ "abcdefg"
03:55:51 <lambdabot>      Not in scope: ‘interate’
03:55:52 <lambdabot>      Perhaps you meant one of these:
03:55:52 <lambdabot>        ‘iterate’ (imported from Data.List),
03:55:57 <tsahyt> > map (take 3) . (!! 3) . iterate init . tails $ "abcdefg"
03:55:58 <lambdabot>  ["abc","bcd","cde","def","efg"]
03:56:02 <tsahyt> If only I could spell
03:56:08 <Myrl> :t iterate
03:56:09 <lambdabot> (a -> a) -> a -> [a]
03:56:12 * quicksilver disinterates tsahyt 
03:56:21 <Myrl> That doesn't help much.
03:56:25 <Myrl> tsahyt: How does iterate work
03:56:33 <quicksilver> it forms this list
03:56:37 <quicksilver> > iterate f x
03:56:39 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
03:56:47 <Myrl> Ohhh.
03:56:49 <quicksilver> efficiently so that the inner values are shared
03:57:03 <Myrl> Sounds like a list version of fix.
03:57:19 <tsahyt> Is using !! the "right" way to get the k-th iteration?
03:57:36 <quicksilver> there isn't really a better way
03:57:47 <tsahyt> Well at least it doesn't matter asymptotically, so there's that
03:58:34 <akegalj_> nicow: look at this example too http://lpaste.net/142569
03:58:41 <quicksilver> > iterate (\x -> take 1 x ++ "O" ++ drop 1 x) "BOOM"
03:58:41 <tsahyt> Myrl: iterate is really useful for a lot of things. For example, if you have an algorithm that does iterations a -> a and you want to terminate once it reaches a certain condition, you can do something like dropWhile (conditionNotMet) . iterate f
03:58:42 <lambdabot>  ["BOOM","BOOOM","BOOOOM","BOOOOOM","BOOOOOOM","BOOOOOOOM","BOOOOOOOOM","BOOO...
03:58:59 <quicksilver> tsahyt: have you read "Why Functional Programming Matters" ?
03:59:13 <tsahyt> It sounds familiar at least
03:59:22 <quicksilver> it uses that as an example
03:59:24 <quicksilver> more or less
03:59:27 <quicksilver> worth reading
03:59:37 <quicksilver> http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html
03:59:58 <tsahyt> I'll put that on my ever growing reading list
04:00:18 * hackagebot glue-common 0.4.4 - Make better services and clients.  https://hackage.haskell.org/package/glue-common-0.4.4 (seanparsons)
04:00:20 * hackagebot glue-core 0.4.4 - Make better services and clients.  https://hackage.haskell.org/package/glue-core-0.4.4 (seanparsons)
04:00:22 * hackagebot glue-ekg 0.4.4 - Make better services and clients.  https://hackage.haskell.org/package/glue-ekg-0.4.4 (seanparsons)
04:00:24 * hackagebot glue-example 0.4.4 - Make better services and clients.  https://hackage.haskell.org/package/glue-example-0.4.4 (seanparsons)
04:01:51 <Myrl> :t span f x
04:01:53 <lambdabot>     Couldn't match expected type ‘[a]’ with actual type ‘Expr’
04:01:53 <lambdabot>     In the second argument of ‘span’, namely ‘x’
04:01:53 <lambdabot>     In the expression: span f x
04:01:58 <Myrl> span f (repeat x)
04:02:01 <Myrl> > span f (repeat x)
04:02:03 <lambdabot>      No instance for (FromExpr Bool) arising from a use of ‘f’
04:02:03 <lambdabot>      In the first argument of ‘span’, namely ‘f’
04:02:03 <lambdabot>      In the expression: span f (repeat x)
04:02:08 <Myrl> :t span
04:02:08 <tsahyt> I've actually written something exactly like this pattern not even an hour ago but used explicit recursion. Welp, time for refactoring
04:02:09 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
04:02:17 <Myrl> Oh wait, it was *scan*
04:02:20 <Myrl> :t scan
04:02:21 <lambdabot>     Not in scope: ‘scan’
04:02:21 <lambdabot>     Perhaps you meant one of these:
04:02:21 <lambdabot>       ‘scanl’ (imported from Data.List),
04:02:24 <Myrl> :t scanl
04:02:25 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
04:02:53 <Myrl> > scanl1 f (repeat x)
04:02:55 <lambdabot>  [x,f x x,f (f x x) x,f (f (f x x) x) x,f (f (f (f x x) x) x) x,f (f (f (f (f...
04:03:06 <Myrl> Ohhh, right.
04:03:25 <Myrl> > scanl (f . id) (repeat x)
04:03:27 <lambdabot>      Could not deduce (FromExpr [Expr]) arising from a use of ‘f’
04:03:27 <lambdabot>      from the context (Show a)
04:03:27 <lambdabot>        bound by the inferred type of it :: Show a => [a] -> [[Expr]]
04:03:44 <Myrl> Ugh, that was stupid.
04:03:54 <Myrl> > scanl (const f) (repeat x)
04:03:55 <lambdabot>      Could not deduce (FromExpr [Expr]) arising from a use of ‘f’
04:03:55 <lambdabot>      from the context (Show a)
04:03:55 <lambdabot>        bound by the inferred type of it :: Show a => [a] -> [[Expr]]
04:04:14 <Myrl> > scanl (\_ -> f) (repeat x)
04:04:15 <lambdabot>      Could not deduce (FromExpr [Expr]) arising from a use of ‘f’
04:04:16 <lambdabot>      from the context (Show a)
04:04:16 <lambdabot>        bound by the inferred type of it :: Show a => [a] -> [[Expr]]
04:04:25 <Myrl> Okay, that's enough, I don't want to flood this. Lol
04:07:38 <ChristianS> Myrl: you can just talk to lambdabot in private
04:07:52 <Myrl> ChristianS: Yeah.
04:29:44 <nicow> akegalj_: thanks
04:55:20 * hackagebot ipprint 0.6 - Tiny helper for pretty-printing values in ghci console  https://hackage.haskell.org/package/ipprint-0.6 (GlebAlexeyev)
05:01:01 <Jeanne-Kamikaze> http://fsharpforfunandprofit.com/posts/ten-reasons-not-to-use-a-functional-programming-language/
05:03:52 <silver> title is clickbaity
05:04:01 <silver> not sure if want
05:04:19 <Jeanne-Kamikaze> you do want :D
05:08:11 <int-e> has anybody (hvr, perhaps) grepped hackage for how many "pure = return" definitions there are?
05:10:51 <quicksilver> hvr mentioned he had grepped for some things in his initial proposal to libraries@
05:10:58 <quicksilver> not suer if that exact thing tho
05:11:24 <nshepperd>  /url 1
05:11:26 <hexagoxel> btw.. are the proposal reactions summarized somewhere?
05:11:30 <nshepperd> bah
05:15:27 * hackagebot wxdirect 0.92.1.0 - helper tool for building wxHaskell  https://hackage.haskell.org/package/wxdirect-0.92.1.0 (HenkJanVanTuyl)
05:15:29 * hackagebot wxc 0.92.1.0 - wxHaskell C++ wrapper  https://hackage.haskell.org/package/wxc-0.92.1.0 (HenkJanVanTuyl)
05:16:31 <int-e> oh right, there was https://gist.github.com/hvr/b0e34463d85b58f169d9 ... very few  return = pure in there, approximately 135 out of 2171
05:18:17 <int-e> while that's not the answer I was looking for, I suspect that the majority of the remaining 2k definitions come with an Applicative instance that currently defines  pure = return.
05:19:52 <delYsid> Is there a guide/tutorial about how to transform "normal" code to monadic style?
05:20:27 * hackagebot wxcore 0.92.1.0 - wxHaskell core  https://hackage.haskell.org/package/wxcore-0.92.1.0 (HenkJanVanTuyl)
05:20:41 <srhb> delYsid: I'm not even clear on what that means, so probably no. :-)
05:20:51 <delYsid> I have a working implementation of my algorithm, and a half-finished monadic version, but I am stuck.
05:22:13 <delYsid> srhb: I have 4 levels of function calls, but I'd like to be able to fetch global state in the inner-most level.  So I discovered that I could do this with stacked monad transformers.  Looks neat, but I am stuck with translating two functions of mine.
05:22:38 <aweinstock> delYsid: can you lpaste what you have so far?
05:22:42 <srhb> delYsid: Perhaps provide an example :)
05:23:36 <delYsid> https://github.com/mlang/hbmc/blob/master/Haskore/Interfa\ce/Braille.hs, ms, vs, pms and pvs are the working impl., below are a few type synonyms, and the beginning of a monad stack, with a few undefined in there.
05:24:03 <delYsid> er, https://github.com/mlang/hbmc/blob/master/Haskore/Interface/Braille.hs
05:25:21 <delYsid> One answer might also be, "dont do that".  I am probably too green for this.  But it struck me as a perfect learning experience.
05:27:04 <aweinstock> delYsid: off topic to your direct question, but you could use template haskell to automatically generate SixDots's definition at compile time
05:27:10 <hvr> int-e: fwiw, I recently refactored  GHC's compiler (165k SLOC)  Monad instances to normalform: https://phabricator.haskell.org/D1312
05:28:04 <hvr> int-e: that mostly seems automatically refactorable via something like HaRe or even a more stupid script
05:29:29 <hvr> int-e: I'm just running a    rgrep '^ *return *= *pure'
05:29:32 <hvr> right now
05:29:51 <int-e> hvr: Note, I'm really just unhappy about the repeated claim that the MRP boils down to removing "return = pure" instances, ignoring the preceding refactoring (which I agree should be trivial in most cases).
05:30:10 <delYsid> aweinstock: I was guessing that, but I dont have any TH experience, and wanted to get stuff off the ground :-).
05:30:39 <int-e> hvr: I'm interested in the opposite actually, i.e. how many people just added applicative instances that define (<*>) = ap and pure = return, to make their code compile in the post-AMP world.
05:30:44 <delYsid> Actually, as a Lisper, I am rather interested in TH, but that is something for later.
05:31:08 <hvr> int-e: '(<*>) = ap` is actually not that bad
05:31:14 <lyxia> delYsid: That's a lot of StateT and ListT layers. Can you not use a single state type?
05:31:35 <aweinstock> delYsid: type PVMonad e = StateT PVState (ListT (StateT PMState (ListT (StateT VState (ListT (StateT MState (ListT (Either e)))))))) -- I doubt this is what you want
05:32:09 <zennist> Is there a monad that during binding ignores error values
05:32:49 <barrucadu> Error values?
05:33:00 <aweinstock> zennist: a newtype around Either with ((Left l >>= f) = return ())?
05:33:07 <hvr> int-e: 400 packages seem to contain `pure = return` 
05:33:13 <delYsid> aweinstock: why?
05:33:47 <aweinstock> each of those ListT's is it's own prolog-nondeterminism layer
05:33:57 <hvr> int-e: fwiw, I've already updated the AMP-upgrade guide in the GHC Trac wiki to recommend the return=pure normalform 
05:33:58 <zennist> e.g., Just x >>= \_ -> Nothing ... Just x 
05:34:30 <aweinstock> also, the lift.lift.lift.lift you'll need to use the StateT's is more work than passing the state explicitly
05:34:45 <zennist> essentially: Nothing <*> Just x = Just x
05:35:14 <zennist> sorry, maybe such a thing doesn't exist... the type wouldn't match..
05:35:24 <hpc> > Nothing ++ Just 5
05:35:25 <lambdabot>      Couldn't match expected type ‘[a]’ with actual type ‘Maybe a0’
05:35:26 <lambdabot>      In the first argument of ‘(++)’, namely ‘Nothing’
05:35:26 <lambdabot>      In the expression: Nothing ++ Just 5    Couldn't match expected type ‘[a...
05:35:26 <lyxia> indeed
05:35:35 <hpc> > Nothing <|> Just 5
05:35:36 <lambdabot>  Just 5
05:35:50 <zennist> hpc: Alternative doesn't allow composing of values
05:35:51 <exio4> have you looked at Alternative?
05:36:25 <hpc> zennist: what's the type of this function then?
05:36:34 <zennist> I was just annoied of say: maybeValues <- forM as myMonad, return $ catMaybes maybeValues
05:36:43 <hvr> int-e: fwiw, I proposed MRP to get some warnings in place, as people will have to fixup some Monad instances thanks to MonadFail anyway (as GHC 8 will start warning about that as well)
05:36:51 <hpc> foo p = (if p then Just getline else Nothing) <*> Just 5 -- zennist
05:37:07 <hvr> int-e: so better bundle warnings for MRP w/ those for MonadFail
05:37:09 <hpc> er, putStrLn
05:37:09 <zennist> was wondering if there is a way to say:  validValues <- forM as myNewMonad
05:37:13 <hpc> er, print
05:37:29 <hpc> :t Just print <*> Just 5 -- here's a hint
05:37:30 <lambdabot> Maybe (IO ())
05:37:36 <hpc> :t Nothing <*> Just 5
05:37:37 <lambdabot> Maybe b
05:39:45 <delYsid> aweinstock: So you're saying it isn't worth it?
05:40:35 <aweinstock> delYsid: for now just write it without the monad transformers, and possibly refactor/golf it later
05:40:55 <delYsid> aweinstock: The motivation for this approach was, that I realized I dont need Either at each level, I might as well just throwError and have the monad transformer stack do its magic.  Currently, I need to collapse the eithers at every level manually.
05:40:58 <int-e> hvr: thanks for the number
05:42:15 <delYsid> aweinstock: Which resulted in a rather weird impl. for vs.
05:43:03 <Franciman> Hi all
05:43:38 <hvr> int-e: However, I don't know how many of those package still work with GHC 7.10
05:44:07 <hvr> i.e. are still actively maintained
05:44:41 <jamesfordummies> i’m going to write a haskell program that uses 3rd party libraries. if I want that same code to compile on another machine that does not have those libraries installed (and they can’t be installed) is there some way to locally package the libraries into my source?
05:48:44 <merijn> jamesfordummies: Why not just distribute your entire application in binary form?
05:49:20 <jamesfordummies> it’s for a class. requirement - code must compile on unmodified school machine. ghc is installed though
05:49:41 <jamesfordummies> merijn: ^
05:50:01 <merijn> Then no, unless you copy the entire source of the library into yours
05:50:08 <selckin> then i would double check you are allowed to use libraries
05:50:52 <jamesfordummies> there is no json library in stdlibs right?
05:51:30 <Franciman> I am parsing a file with subtitles, where each subtitle is composed of a header with timing and then several lines of text. Now this file contains many subtitles, each subtitle is separated from the other with an empty line. Now my question is, how can I express efficiently with attoparsec the fact that I want to parse many lines of text until I get an empty line?
05:52:11 <srhb> Franciman: Sounds like manyTill
05:55:00 <Franciman> srhb, how could I express that?
05:55:28 <srhb> Franciman: manyTill subtitleParser emptyLine ?
05:56:06 <Franciman> uhm, it's exactly emptyLine that I can't get done
05:56:26 <Franciman> emptyLine = string "\r\n" does the job?
05:57:32 <srhb> Franciman: I think there's an endOfline. So you just need to ensure that the state leaves you at the end of the last subtitle or something, so two of those will signal the end of that subtitle
06:04:02 <Franciman> srhb, thanks a lot
06:41:42 <lysgaard> I would like to generate C code from Haskell. From before I have used libraries like blaze-html for generating HTML code. Does there exist similar combinator libraries for generating C in Haskell?
06:43:26 <Gurkenglas> I have a "there should be an alias for that" feel for "map (fst . head &&& map snd) . groupBy fst" because it syntactically discards information and semantically doesn't.
06:44:35 <quicksilver> don't you need to sort it first, Gurkenglas ?
06:44:56 <Gurkenglas> quicksilver, my argument holds without the sorting, and groupBy doesn't sort either
06:45:10 <quicksilver> well I was trying to understand what you actually wanted :)
06:45:20 <quicksilver> normally when I do that I want uniqueness so I sort
06:45:33 <quicksilver> at which point I decide to go via Data.Map instead
06:46:06 <fizruk> :t M.fromListWith (++) . map (second (\x -> [x]))
06:46:07 <lambdabot> Ord k => [(k, t)] -> M.Map k [t]
06:46:29 <quicksilver> yes that kind of thing fizruk 
06:46:46 <fizruk> not that much shorter though :)
06:46:58 <Gurkenglas> There should be fromListMap :: Monoid m => (a -> m) -> [(k, a)] -> Map k m
06:47:19 <fizruk> :t M.fromListWith (++) . fmap fmap fmap pure
06:47:20 <lambdabot> Ord k => [(k, a)] -> M.Map k [a]
06:47:47 <Gurkenglas> Hah, neat
06:48:44 <clrnd> woah
06:49:23 <fizruk> :t \xs -> M.fromListWith (++) [ (k, [v]) | (k, v) <- xs ]
06:49:25 <lambdabot> Ord k => [(k, a)] -> M.Map k [a]
06:50:51 * hackagebot llvm-general-pure 3.5.0.0 - Pure Haskell LLVM functionality (no FFI).  https://hackage.haskell.org/package/llvm-general-pure-3.5.0.0 (BenjaminScarlet)
06:50:53 * hackagebot llvm-general 3.5.0.0 - General purpose LLVM bindings  https://hackage.haskell.org/package/llvm-general-3.5.0.0 (BenjaminScarlet)
06:50:55 * hackagebot geocode-google 0.3 - Geocoding using the Google Web API  https://hackage.haskell.org/package/geocode-google-0.3 (mdanish)
06:51:29 <quicksilver> it ought to be \f -> mconcat . map (\(k,v) -> M.singleton k (f v))
06:51:33 <fizruk> :t foldMap (uncurry M.singleton . fmap pure) :: Ord k => [(k, a)] -> M.Map k [a]
06:51:34 <lambdabot> Ord k => [(k, a)] -> M.Map k [a]
06:51:41 <quicksilver> but unfortunately it isn't, because Data.Map has the 'wrong' Monoid instance
06:51:55 <fizruk> oh, right, I forgot that
06:52:10 <quicksilver> shame beause that Monoid instance would be so much more useful than the current one
06:53:24 <fizruk> true
06:53:32 <quicksilver> Gurkenglas: that is basically foldMap anyway
06:53:38 <quicksilver> hang on that's not what I meant
06:53:43 * quicksilver wonders what he did mean
06:53:57 <quicksilver> nah I'm just talking rubbish
06:54:10 <quicksilver> hard to fix, now :(
06:54:43 <Copperis> hi, I'm new to haskell. How do you read such a signature? I know that the first is fn name... mapOptional :: (a -> b) -> Optional a -> Optional b
06:54:46 <fizruk> well, isn't ghc 8 there to break things? might be not too late, maybe?
06:55:00 <quicksilver> fizruk: this is a really subtle change tho
06:55:05 <quicksilver> it won't make code fail to compile
06:55:23 <quicksilver> well, it might
06:55:34 <quicksilver> but if you have code relying on mappend being left-biased union
06:55:43 <quicksilver> and there happens to be a Monoid instnce for the value type in scope
06:55:50 <quicksilver> it will continue to compile and do something rather different
06:56:13 <Gurkenglas> Sounds like a job for a newtype wrapper
06:56:26 <quicksilver> > M.fromList [('a',"foo")] `mappend` M.fromList [('a',"bar")]
06:56:28 <lambdabot>  fromList [('a',"foo")]
06:56:40 <quicksilver> Gurkenglas: yes. but we can still regret that the standard instance is the wrong one :)
06:56:41 <fizruk> I wonder how many people use Map's monoid rather than (unionWith (<>))
06:56:52 <Gurkenglas> Perhaps two, so we can deprecate the current one and move it out at some point and then move the correct one in maybe
06:57:30 <fizruk> Copperis: function name = "mapOptional", "::" is syntax for "has type", "(a -> b) -> Optional a -> Optional b" is the type
06:57:55 <Gurkenglas> :t alaf ?f foldMap :: Monoid m => (a -> m) -> [(k, a)] -> Map k m -- Who needs typed holes? Now I know that this can't work :)
06:57:56 <lambdabot>     Not in scope: type constructor or class ‘Map’
06:57:56 <lambdabot>     Perhaps you meant ‘M.Map’ (imported from Data.Map)
06:58:13 <Gurkenglas> Welp, with M. it doesn't work either.
06:58:32 <fizruk> Copperis: "a -> b" is function from values of type "a" to values of type "b", "a" and "b" are called type variables and can be instantiated by the caller
06:58:35 <seanparsons> kamatsu: Oh hai!
06:59:37 <Copperis> fizruk, so (a -> b) is a function parameter?, i.e. you have to pass such a function?
06:59:47 <fizruk> Copperis: exactly
07:00:26 <fizruk> Copperis: "->" is right associative, which means that "a -> b -> c" is the same as "a -> (b -> c)"
07:00:51 * hackagebot vinyl-utils 0.2.0.0 - Utilities for vinyl  https://hackage.haskell.org/package/vinyl-utils-0.2.0.0 (mjmrotek)
07:01:07 <fizruk> Copperis: "(a -> b) -> Optional a -> Optional b" is the same as "(a -> b) -> (Optional a -> Optional b)"
07:01:27 <Copperis> oh, then it makes sense further regarding the signature, thanks fizruk!
07:02:10 <fizruk> Copperis: that is if you give "mapOptional" its first argument you get a function of type "Optional a -> Optional b"
07:02:31 <nshepperd> :t M.fromListWith (<|>) . fmap fmap fmap pure
07:02:33 <lambdabot> (Ord k, Alternative f) => [(k, a)] -> M.Map k (f a)
07:02:34 <Gurkenglas> Yet another shame that Control.Lens.Wrapped wraps into Da.aMap via fromList, not fromListWith (<>)
07:03:52 <orion> What is an "orthogonal typeclass"
07:04:20 <fizruk> > fmap fmap fmap fmap fmap fmap fmap fmap show [Just (1, 2)]
07:04:22 <lambdabot>  [Just (1,"2")]
07:04:25 <hpc> orion: context?
07:04:37 <Copperis> fizruk, so the function takes a mapping function and an option and returns a processed option, right?
07:04:53 <hpc> (if i had to guess, "orthogonal" means "unrelated" and it's just two classes that don't have anything in common)
07:05:10 <fizruk> Copperis: yes, it is the one way to look at it
07:05:14 <quicksilver> Gurkenglas: I think it would be a bit weird for it to do otherwise
07:05:29 <Copperis> ok
07:05:32 <quicksilver> Gurkenglas: I mean, you're supposed to think of it as an isomorphism onto the unique-k space
07:05:46 <fizruk> Copperis: the other one being that mapOptional "lifts" a function (a -> b) to a function (Optional a -> Optional b)
07:05:48 <quicksilver> Gurkenglas: how it behaves outside that space isn't supposed to matter, you're not supposed to use it there.
07:06:35 <Gurkenglas> I see. So one of my favorite examples of ala is just a fortunate hack.
07:06:47 <nshepperd> I might call two typeclasses "orthogonal" if you can't implement any method of the one in terms of methods of the other
07:06:59 * nomeata reads through https://ghc.haskell.org/trac/ghc/ticket/9590
07:07:15 <nshepperd> so that they are orthogonal in "meaning"
07:07:32 * nomeata moves to #ghc
07:07:43 <quicksilver> nshepperd: and they have no mutual laws perhaps?
07:08:05 <quicksilver> although such total orthogonality is quite rare I suppose
07:08:13 <Gurkenglas> nshepperd: The one-method-per-typeclass case sounds like a partial ordering; you might want to derive nomenclature from that
07:10:50 <orion> hpc: "As a person who used Haskell in all three capacities (for scientific research, for commercial purpose, and to introduce others to benefits of pure and strongly typed programming), I must voice an supportive voice for this change: 1. Orthogonal type classes are easier to explain. ..."
07:11:18 <exio4>  
07:11:55 <exio4> oops, that wasn't meant to be a msg
07:12:31 <Copperis> fizruk, what is the benefit of looking at it that way?
07:12:40 <fmauro> Hi all: Do any of you have experience with building ghc as a cross-compiler to x86_64 -> arm?
07:13:52 <nshepperd> orion: oh, that looks like a less technical but similar usage
07:14:19 <nshepperd> where type classes are "non-orthogonal" when they duplicate each other's functionality
07:14:33 <Copperis> as in, that function returns an "optional b" as I see it. What's the use for (Optional a -> Optional -> b)? I'm learning about this stuff at the moment, so I don't have a lot of knowledge about this stuff
07:14:45 <hpc> orion: no idea, then
07:15:13 <Copperis> typo (Optional a -> Optional b)
07:15:43 <orion> nshepperd: I see.
07:17:39 <nshepperd> I think it that context it would be best to ask the person who said that to clarify
07:17:56 <orion> ok
07:18:02 <fizruk> Copperis: I am not sure I can put it into words correctly. But basically the idea is that you operate on a higher-level, leaving plain values aside and talking about transformations and their properties. More often then you might think you'll need a function to have some properties. E.g. mapOptional id == id.
07:19:17 <hexagoxel> is `instance Binary TypeRep` impossible?
07:19:34 <Copperis> fizruk, ok, it seems I'm over my head. I'll continue reading the tutorial that I was. Thanks!
07:20:10 <nshepperd> Copperis: having multiple ways of looking at things is good for creativity, if nothing else
07:21:30 <fizruk> Copperis: yes, just keep in mind that there's more than one point of view, if you start looking at things with different angles now it can help you better understand things (including ones you already know)
07:22:05 <nshepperd> but here's one thing you can do with (Optional a -> Optional b).. you can apply mapOptional again and turn it into Optional (Optional a) -> Optional (Optional b)
07:22:26 <nshepperd> which may not specifically be useful... but the general pattern is useful
07:22:26 <humanoyd> Is there an overview somewhere over all lens naming conventions? Eg. "ALens" vs "Lens", "Of" suffix, "=" for state etc.?
07:23:34 <Gurkenglas> Is the reason the obvious reversal of the deriviation of foldl from foldr isn't accepted as foldr that it first traverses the list?
07:23:47 <quicksilver> hexagoxel: https://hackage.haskell.org/package/concrete-typerep
07:24:42 <quicksilver> humanoyd: I am not aware of one. If there is one I'd like to see it too.
07:24:50 <quicksilver> humanoyd: % for modify :)
07:26:57 <tomus> what's the most hassle free way to compile a short HS script into JS
07:27:03 <nshepperd> Gurkenglas: I think it doesn't terminate on infinite lists, which is bad
07:28:13 <hexagoxel> quicksilver: thanks! is there an associated Dynamic?
07:29:18 <Gurkenglas> nshepperd: well yes it traverses the list first :P
07:31:13 <humanoyd> quicksilver: I'll let you know if I find one
07:31:59 <quicksilver> hexagoxel: you can just use the normal Dynamic?
07:35:52 * hackagebot sdl2-cairo 0.1.0.1 - Binding to render with Cairo on SDL textures  and optional convenience drawing API.  https://hackage.haskell.org/package/sdl2-cairo-0.1.0.1 (apirogov)
07:37:37 <hexagoxel> quicksilver: which has no Binary instance. Maybe "dynamically typechecked Bytestring" is a better description..
07:38:32 <hexagoxel> or does binary make any promises that different types will have different representations?
07:38:45 <hexagoxel> s/different types/values of different types/
07:38:57 <JamesJRH> Hi. I'm at Haskell Exchange. Is anyone else here at the conference?
07:40:24 <happy0> JamesJRH: nope, but i'm jealous. the program looks good :P
07:41:06 <clrnd> 2
07:41:15 <JamesJRH> I couldn't find an IRC channel for Haskell Exchange, but there's something that looks like a channel name on the programme, so I joined that, creating the channel.
07:41:52 <JamesJRH> Anyone else at Haskell Exchange, your welcome to join #HaskellX, here on Freenode.
07:42:01 <JamesJRH> you're*
07:42:06 <hexagoxel> quicksilver: e.g. i have a set of Dynamics (of objects that are Binary), and now want to serialize it. Simply using Binary seems.. risky, because decoding might get "false positives"
07:42:12 <clrnd> more like HaskellXXX
07:42:58 <happy0> JamesJRH: will any of the talks be on youtube? :P
07:43:10 <JamesJRH> I'm not sure.
07:43:21 <happy0> fair enuff
07:43:49 <nshepperd> Binary itself makes no assurances about the representation of different types, I think
07:43:59 <JamesJRH> The programme says “Tweet #HaskellX”, but I don't use Twitter. So it might as well be a channel, not a hashtag. :-)
07:44:18 <quicksilver> hexagoxel: yeah you need your own versin of Dynamic with a Binary constraint embedded
07:44:23 <quicksilver> hexagoxel: but then its' easy
07:44:36 <Wizek> Hello! Anyone using IntelliJ IDEA with the official Haskell plugin? In the cabal file it tells me that "this package is not installed", while in fact it is installed to a local cabal sandbox, not globally. I wonder, does the plugin support looking in the local sandbox?
07:44:36 <JamesJRH> happy0: The talk that I was just at wasn't recorded, so if any will, they won't all be.
07:44:41 <happy0> aww
07:44:54 <JamesJRH> I know, yeah.
07:45:53 * hackagebot erlang 0.2 - FFI interface to Erlang.  https://hackage.haskell.org/package/erlang-0.2 (gombocarti)
07:46:44 <JamesJRH> happy0: I'd sure like to watch this one again – it was about game programming. Really very interesting! Only I wish that I wasn't so sleep-deprived as I didn't take it all in. :-(
07:47:47 * JamesJRH leaves; break over.
07:49:56 <happy0> JamesJRH: aww =<
07:50:18 <happy0> were you traveling to get there?
07:51:05 <joco> what is the best server side library if i want to play it nicely with ghcjs ?
07:52:07 <nshepperd> huh, is it really possible to serialize a Dynamic like that?
07:52:31 <nshepperd> how do you get at the Binary instance when deserializing
07:54:57 <hexagoxel> quicksilver: yeah it seems straightforward to implement, yet i cannot find a package that does it :p
07:54:59 <hexagoxel> nshepperd, quicksilver: thx
07:55:46 <Myrl> >fix (0*)
07:55:53 <Myrl> > fix (0*)
07:55:58 <lambdabot>  mueval-core: Time limit exceeded
07:56:39 <joco> Wizek: I recommend vim :)
07:56:46 <joco> and ghcid
07:56:58 <joco> or ghc-mod
07:57:02 <hexagoxel> nshepperd: hm true. i guess you need to store the serialized version until someone fromDyn's, providing the instance.
07:57:15 <Myrl> >fix (* 0)
07:57:21 <cchalmers> hexagoxel: I'd do something like newtype BinaryDynamic = BinaryDynamic (Fingerprint, ByteString) deriving Binary
07:57:24 <Myrl> > fix (* 0)
07:57:26 <lambdabot>  0
07:57:37 <Myrl> wuuuhhh
07:58:54 <hexagoxel> > undefined * 0 :: Int
07:58:56 <lambdabot>  *Exception: Prelude.undefined
07:58:58 <hexagoxel> > undefined * 0 :: Integer
07:59:00 <lambdabot>  0
07:59:03 <clrnd> woah
07:59:23 <Myrl> Lol
07:59:24 <cchalmers> mkDynamic a = BinaryDynamic (typeRepFingerprint  (typeOf a), encode a)
07:59:24 <clrnd> and people say JS is weird
07:59:43 <Myrl> Woah, I just had an idea.
07:59:51 * hodapp steps on the idea
07:59:55 <hodapp> whew.
07:59:58 <clrnd> :P
07:59:58 <Myrl> Perhaps we can use `fix (0*)` as a version checker.
08:00:07 <Myrl> Right now, that will cause a timeout.
08:00:35 <Myrl> But somewhere in the near future, where supercompilation sanely exists, that will be rewritten into `fix (*0)` due to commutativity and will return 0
08:01:14 <Myrl> s/near/far/
08:01:18 <ggole> If that has different behaviour, surely supercompilation should not rewrite it
08:01:24 <Myrl> pyon: Look at this crazy idea I have.
08:01:28 <Myrl> ggole: I guess.
08:01:41 <Myrl> That does confuse me though.
08:02:15 <quicksilver> nshepperd: oh I forgot that part.
08:02:24 <hexagoxel> cchalmers: yeah, always directly encapsulating the serialized data is another option.
08:02:35 <pyon> Myrl: `fix`, IIUC, computes the least fixpoint. The least fixpoint of `(1:)` is `[1,1..]`, but the least fixpoint of `(0*)` is bottom.
08:02:45 <pyon> Myrl: And I'm afraid I can't elaborate without going into domain theory, sadly. :-(
08:02:49 <quicksilver> nshepperd: you have to build up a hashmap between typereps and 'deserialise' functions, probably
08:03:05 <quicksilver> nshepperd: so somewhere your program needs to maintain a list of all the types it ever expects to find inside a Dynamic
08:03:05 <Myrl> pyon: Ah.
08:03:35 <nshepperd> hexagoxel: ah, you could even use some unsafe IO magic with an MVar to only deserialize once, when someone fromDyn's it with the correct type and instance
08:03:52 <hexagoxel> yeah exactly
08:04:01 <nshepperd> that way providing the perfect illusion of maggically decoding lazily
08:04:14 <Myrl> pyon: Either way, I made a derp in my statement.
08:04:26 <quicksilver> nshepperd: oh, cute
08:04:27 <breadmonster> Hey everyone.
08:04:31 <hexagoxel> and avoiding any encoding/decoding when Binary is not used
08:04:43 <Myrl> pyon: I wonder who caught it.
08:05:54 * hackagebot stateWriter 0.2.6 - A faster variant of the RWS monad transformers.  https://hackage.haskell.org/package/stateWriter-0.2.6 (SimonMarechal)
08:06:16 <hexagoxel> (wouldn't an IORef be sufficient?)
08:06:45 <hexagoxel> (ah, two threads might deserialize in parallel - but that should not hurt, does it?)
08:07:24 <hackrilege> http://lpaste.net/142581 what is going on with these crazy functors. i cant get my head round this error, can somebody take a peak for me?
08:07:42 <nshepperd> oh, an IORef would probably work
08:07:57 <hackrilege> the paste is only 9 lines long...
08:08:46 <Myrl> attoparsec: "Note: if you get a Partial result, do not call its continuation more than once."
08:08:50 <Myrl> Side effect...?
08:09:50 <merijn> Myrl: I'm guessing that means that you shouldn't feed two chunks into the same partial continuation?
08:09:55 <merijn> Which wouldn't make sense anyway
08:09:56 <nshepperd> hackrilege: that definition for fmap g is a type error
08:10:02 <hackrilege> true
08:10:13 <nshepperd> hackrilege: g :: b -> c, but you're applying it to an f b
08:10:26 <hackrilege> yeh, thats what the compiler says
08:10:56 <merijn> hackrilege: You have a "Functor f" constraint, did you mean to write "B . fmap g . b"?
08:11:10 <hackrilege> hmm
08:11:16 <hackrilege> perhaps i did
08:11:19 <hackrilege> 1 sec
08:11:28 <merijn> Because then it makes sense and should work
08:11:40 <hackrilege> i knew something didnt make sense
08:11:53 <merijn> hackrilege: Note that "b" produces an "f a" where 'f' is a functor, but 'g :: a -> b"
08:12:10 <breadmonster> Hi merijn !
08:12:19 <breadmonster> I think you'd be able to help me with a bit of software design.
08:12:34 <breadmonster> So I want to implement autonomous evaluation in Haskell.
08:12:45 <merijn> What does "autonomous evaluation" mean?
08:12:48 <concept3d> Hello guys I have data where I want to update a field. the field is Data.Map type I want to remove an item
08:13:14 <concept3d> I tried to uses Lens but doesn't seem to figure it out
08:13:15 <merijn> concept3d: You can do the ugly record syntax way or learn about lenses ;)
08:14:11 <merijn> concept3d: "remove key foo = foo { mymap = delete key (mymap foo) }"
08:14:34 <merijn> Or whatever the right function name is for removing an element
08:14:36 <merijn> You get the idea
08:14:45 <hexagoxel> :exf "Functor f => (B f a -> f a) -> (f b -> B f b) -> (a -> b) -> B f a -> B f b"
08:14:45 <exferenceBot> \ f1 f2 f3 -> f2 . (fmap f3 . f1)
08:14:57 <Myrl> merijn: It wouldn't, but it shouldn't be problematic, as the note implies.
08:15:21 <hexagoxel> (if B was in the environment, you would not need f1 / f2)
08:15:21 <concept3d> I was thinking of using similar thing, I need to sort the types out
08:15:22 <merijn> Myrl: tbh, I dunno for sure :)
08:15:35 * hodapp throws in his vote for johnw for Emacs maintainer
08:15:55 <quicksilver> concept3d: thing & fieldname . at key .~ Nothing
08:16:15 <hackrilege> ok, hows about this one; http://lpaste.net/142582
08:17:04 <quicksilver> > ("hi",M.fromList [('a',1),('b',2)]) & _2 . at 'b' .~ Nothing
08:17:06 <lambdabot>  ("hi",fromList [('a',1)])
08:17:09 <quicksilver> ^^ concept3d 
08:17:25 <breadmonster> Back.
08:17:29 <breadmonster> merijn: any ideas?
08:17:32 <merijn> hackrilege: mapping fmap (or even fmapping fmap) is the way to go
08:17:38 <hackrilege> no
08:17:43 <merijn> breadmonster: I don't know what you mean by "autonomous evaluation"
08:17:46 <merijn> hackrilege: Why not?
08:17:55 <hackrilege> the comment explains i want the user to be able to do some other thing not map if they want
08:17:59 <concept3d> thanks, I'll check that
08:18:24 <merijn> hackrilege: Functor can only map, so I don't see how your comment relates to fmap? :)
08:18:33 <hackrilege> hmm, its a list
08:18:33 <breadmonster> merijn: Okay, so you have this graph of dependencies among variables and updating any peripheral variable updates everything that depends on it.
08:18:50 <hackrilege> im not maping over a functor (anyway then i would be fmaping)
08:19:15 <merijn> hackrilege: Right, but then you just write some function that has "foo :: ([B f a] -> [B g c]) -> C f a -> C g b"?
08:19:49 <hackrilege> i guess so
08:19:53 <merijn> hackrilege: Your question marks are inside the implementation of "fmap", so logically, you are trying to implement fmap... :)
08:20:02 <hackrilege> i am
08:20:05 <breadmonster> merijn: Something like this http://reference.wolfram.com/language/ref/SetDelayed.html
08:20:11 <hackrilege> but its the mapping thats the worry
08:20:12 <merijn> hackrilege: And there is only ONE possible lawful implementation of fmap for any Functor
08:20:20 <hackrilege> its not fmap
08:20:21 <hackrilege> its map
08:20:27 <hackrilege> that is the problem
08:20:29 <merijn> map = fmap
08:20:38 <hackrilege> fmap is unique, map is not the only way to handle a list
08:20:41 <sagittarian> hey all, is there a way to negate a typeclass constraint
08:20:53 <sagittarian> as in, for all a that is *not* Eq
08:21:00 <merijn> hackrilege: Right, but any *other* way of handling a list will violate the functor laws
08:21:07 <hackrilege> scan?
08:21:09 <merijn> hackrilege: The *only* way to get a Functor 
08:21:16 <merijn> for C is by mapping over the list
08:21:18 <hackrilege> its not a functor its a list
08:21:36 <hackrilege> which is a functor sure
08:21:39 <merijn> hackrilege: The functor laws for "C" require that you fmap fmap over the list
08:21:46 <hackrilege> but its not the functor im defining fmap for
08:22:02 <merijn> hackrilege: Sure, but you can't do anything else without breaking the laws :)
08:22:11 <hackrilege> your telling me i MUST use map fmap as that blank lambda?#
08:22:37 <merijn> hackrilege: Yes, anything else will result in your instance not following the Functor laws for C
08:22:48 <hackrilege> scan?
08:22:56 <hackrilege> :t scan
08:22:57 <lambdabot>     Not in scope: ‘scan’
08:22:57 <lambdabot>     Perhaps you meant one of these:
08:22:57 <lambdabot>       ‘scanl’ (imported from Data.List),
08:22:59 <merijn> hackrilege: So clearly you *could* write anything else that typechecks, but it won't be a lawful instance :)
08:23:06 <hackrilege> ok
08:23:10 <hackrilege> this is very hopeful
08:23:19 <hackrilege> but im not quite sure we are on the same page
08:23:29 <quicksilver> fmap id == id is the easy one to check/remember
08:23:36 <nightshift> l
08:24:01 <merijn> hackrilege: I'm heading home now, but here's some background: https://stackoverflow.com/questions/19774904/are-functor-instances-unique
08:24:18 <hackrilege> if your totally totally sure then i will just use map fmap. but i really wanted to offer the user some other functionality, but then you have provided a way to do that, but then the accessor is not fmap, which was my accessor for functors
08:25:12 <hackrilege> ok thanks for your help
08:25:13 <merijn> hackrilege: A fun learning exercise is the following: Define whatever you want and then try to proof the functor law(s)
08:25:42 <hackrilege> and it will break unexpectedly somewhere if i dont obey these laws?
08:25:45 <merijn> hackrilege: That being that "fmap id x == id x == x" for any 'x' that's a (lawful) Functor
08:26:14 <merijn> hackrilege: If you break the laws, people lose the ability to reason about what your code does and probably will get upset/annoyed with you :p
08:26:32 <merijn> So you won't break anything in that it won't compile, but you'll break people's expectations
08:27:10 <breadmonster> :t (***)
08:27:11 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
08:27:14 <merijn> (There's a 2nd functor law, which is "fmap f . fmap g = fmap (f.g)", but in haskell that one is redundant as it follows from the "fmap id == id" law due to our typesystem)
08:27:24 <merijn> And "fmap id == id" is usually easier to prove :)
08:27:30 <merijn> Anyway, time to run
08:28:59 <cchalmers> b
08:33:20 <hexagoxel> (btw there is tagged-binary, which provides the typesafe-ByteString part)
08:33:56 <sgronblo> so am i correct in that cabal cant uninstall packages?
08:35:19 <clrnd> sgronblo, ghc-pkg unregister
08:35:31 <clrnd> yeah you can't really "uninstall" pkgs
08:35:45 <quicksilver> hexagoxel: its docs claim it uses string type name tagging
08:35:59 <quicksilver> hexagoxel: so it's not as good as the concrete-typerep approach
08:36:54 <sgronblo> clrnd: ok, thanks
08:46:55 <hexagoxel> quicksilver: and binary-typed provides a series of hashing options that all seem to fall short of concrete-typerep as well..
08:50:14 <orion> Anyone know how to approach this problem?: https://mail.haskell.org/pipermail/haskell-cafe/2015-October/121704.html
08:54:59 <quicksilver> orion: I only spent 30 seconds thinking about it, but just because in the end all your *actual* computations are over bytestrings, that doesn't mean it's a bad idea to decorate the types
08:55:12 <quicksilver> the types stop people passing the wrong-size bytestrings in the wrong places
08:55:27 <quicksilver> and probably stronger properties than that about the actual contents of hte bytestrings
08:56:19 <orion> quicksilver: I agree completely! I just find myself frustrated when I read things like, "Set k = h" where k :: SymmetricKey c and h :: Digest c, know what I mean?
08:57:03 <quicksilver> that's just how the maths works out, I guess
08:57:21 <quicksilver> it's all just numbers and modulo arithmetic at some point
08:57:22 <orion> As a result of that one almost trivial detail in the spec, I need to add an additional conversion function to the typeclass.
08:58:04 <quicksilver> perhaps you should just require toByteString operations for every sub-type
08:58:22 <orion> I was thinking of using Byteable for this purpose.
09:14:17 <hackrilege> what about this one? http://lpaste.net/142585
09:14:35 <hackrilege> really starting to become crazy
09:14:41 <Mayzie> How can I store a global variable in Haskell?
09:14:52 <hackrilege> what is a global variable?
09:15:01 <quicksilver> hackrilege: your error is just a typo
09:15:09 <Mayzie> One where I can set a value and retrieve it later.
09:15:11 <hackrilege> 4 reallys!? cool
09:15:23 <hackrilege> you could try using an IORef
09:15:24 <quicksilver> hackrilege: haskell thinks you are trying to define a class called Tripple
09:15:27 <quicksilver> which isn't what you meant
09:15:39 <quicksilver> you presumably mean Num a => Num (Tripple a)
09:15:48 <hackrilege> is the word Trpille protected? whats going wrong?
09:16:05 <c_wraith> Mayzie: you know how lots of languages say "don't do this" about global variables? Well, Haskell means it. 
09:16:16 <quicksilver> no, it's just the syntax 'Num a => Tripple a" means make 'a' an instance of 'Tripple'
09:16:17 <mutantmell> Mayzie: There's not really a way to do that globally.  You can set a variable and pass it around
09:16:18 <hackrilege> normally in haskell because functional equivilance is key, we tend to pass around variables...
09:16:36 <quicksilver> and the error is complaining that Tripple isnt' a typeclass
09:16:40 <quicksilver> although it's aweird phrasing.
09:16:51 <hackrilege> oh
09:16:53 <hackrilege> i see
09:16:59 <hackrilege> yeh i never got this error before
09:17:06 <quicksilver> you meant Num a => Num (Tripple a)
09:17:09 <Mayzie> c_wraith: Depends on the language and how you use them. In this case, I need a counter of sorts.
09:17:12 <hackrilege> thanks!
09:17:30 <quicksilver> Mayzie: the simplest answer to make the counter a paramter of your recursive function
09:17:40 <quicksilver> since you can change the value when you recurse anyway (by passing n+1)
09:17:45 <quicksilver> there are lots of other ways of counting
09:17:52 <quicksilver> without introducing global mutable state
09:17:55 <Mayzie> I've considered it and it won't work.
09:18:19 <hackrilege> im sure we can make it work!
09:18:22 <hackrilege> what is it?
09:18:42 <quicksilver> give a little more information about what you're doing and we can suggest a solution
09:18:48 <hackrilege> yeh, forget global variables, im sure its not the answer your really looking for
09:19:24 <hackrilege> best focus on getting your recursion schemes down
09:20:20 <hackrilege> oh im itching to see the problem now!
09:20:48 <Mayzie> I don't really know how to reduce this problem into a couple of functions.
09:20:55 <Mayzie> So I can paste it
09:20:56 <umib0zu> hey all, I’m in a sandbox and I want to freeze my dependencies, but when I do, I have packages I know I installed under a sandboxed directory that aren’t being listed in cabal.config. Is there any reason why this is going on?
09:23:13 <quicksilver> Mayzie: ways to handle mutable state in haskell progams: (1) just add a parameter to your functions and pass it around (2) use a State monad to encapsulate that idea (3) use MonadState to abstract your functions (4) use IORef and condemn yourself to the IO monad
09:23:31 <quicksilver> generally (4) is only a reasonable solution if you're already stuck with callbacks in an IO-based library
09:23:38 <quicksilver> e.g. graphics libraries like Gtk
09:24:02 <Mayzie> I'm not, no.
09:24:03 <orion> quicksilver: One issue with something like "toByteString" is that I'd need to modify all my functions to accept ByteStrings as input, because there is no way for the user to construct, say, a 'SymmetricKey c' directly.
09:24:11 <hackrilege> nonono i have never used any option other than (1). 
09:24:21 <hackrilege> the others are strange voodoo
09:24:39 <quicksilver> orion: but the user must be able to get SymmetricKeys from somewhere?
09:24:41 <hackrilege> for a beginer, correct recursive function definitions are the corrects step forwards
09:24:49 <quicksilver> orion: otherwise how can he use the library?
09:25:13 <hackrilege> Mayzie, can you talk us through it?
09:25:31 <orion> quicksilver: Correct. SymmetricKeys are currently only able to be constructed via this mechanism: cipherGetKey :: SymmetricKey c -> Nonce c -> SymmetricKey c
09:25:42 <Mayzie> Here's Haskell + pseudocode for basically what I need: https://bpaste.net/show/b4603449b6fa
09:25:53 <Mayzie> `i` exists outside of the functionm
09:25:58 <Mayzie> function getHello*
09:26:01 <orion> quicksilver: But, there's an exception to the rule in the spec, where they assign k = h.
09:26:18 <quicksilver> Mayzie: yeah, well haskell wants to you be honest about the types.
09:26:25 <hackrilege> what is this!? "(B i++ a)"
09:26:27 <orion> Where k :: SymmetricKey c, h :: Digest c
09:26:32 <quicksilver> hackrilege: it's C pseudo code
09:26:33 <umib0zu> I guess a better question is, what conditions are necessary to get “cabal freeze” to store your installed deps into the cabal.config? Do I need to build my full package before it officially adds them into the config?
09:26:38 <Mayzie> hackrilege: As I said, it's Haskell + pseudocode
09:26:42 <hackrilege> kk
09:26:45 <quicksilver> since getBlah and getHello both modify the counter
09:26:48 <quicksilver> they should have types:
09:26:58 <quicksilver> getBlah :: Int -> [A] -> (Int,[B])
09:27:07 <quicksilver> getHello : Int -> A -> (Int,A)
09:27:11 <quicksilver> erm
09:27:13 <quicksilver> getHello : Int -> A -> (Int,B)
09:27:13 <quicksilver> sorry
09:27:22 <mutantmell> Mayzie: alternatively, getHello can just be A -> B, and getBlah can be the only one storing the int
09:27:38 <mutantmell> Mayzie: Or you can use one of my favorite tricks, an inner helper function.
09:27:45 <Mayzie> mutantmell: Eh, it goes deeper than that. What I pasted was just an example.
09:28:03 <umib0zu> Mayzie what are you trying to do by the way? I just entered.
09:28:10 <mutantmell> Mayzie: i.e. getBlah xs = go xs i, where go = ... 
09:28:19 <mutantmell> Mayzie: and go stores the counter invisibly
09:28:21 <orion> quicksilver: Is it even possible to directly construct a value like 'SymmetricKey c', given that it's a TypeFamily? I'm thinking not because you need to specify a constructor from one of the concrete implementations.
09:28:47 <mutantmell> Mayzie: Maybe you need to add the counter to the data type then
09:28:54 <mutantmell> Mayzie: if it's that tied up with the rest of it
09:29:11 <mutantmell> Mayzie: Maybe do a tuple (Data, Int) and pull out the data at the end?
09:29:27 <Mayzie> Hmm
09:29:34 <Cale> orion: undefined :: SymmetricKey c  will work
09:29:34 <Mayzie> I'm just trying to envisage using quicksilver's way.
09:29:48 <Mayzie> It'd get ugly quite quickly.
09:29:50 <Cale> orion: But a defined value, maybe not
09:30:02 <orion> Cale: Hi. Did you see my thread I linked to a few minutes ago?
09:30:22 <quicksilver> Mayzie: well, that's why people invented the State monad
09:30:27 <mutantmell> Mayzie: If you're feeling brave, you may want to look at the State type.
09:30:27 <Mayzie> umib0zu: Essentially this is what I want (Haskell + pseudocode demonstrating what I would like): https://bpaste.net/show/b4603449b6fa
09:30:31 <quicksilver> Mayzie: it's just a shorthand for constructing these things
09:30:31 <Cale> orion: If you know which type c is, then you can provide a value of the appropriate type, depending on which type SymmetricKey c evaluates to
09:30:46 <quicksilver> and passing the state around behind the scenes
09:31:03 <Cale> orion: I didn't...
09:31:07 <quicksilver> Cale is better at explaning this than me, and I have a train to catch :)
09:31:14 <Cale> found it
09:31:54 <hexagoxel> umib0zu: are the sandbox packages which are not frozen dependencies of your package?
09:32:09 <umib0zu> Mayzie, well for one, getBlah isn’t recurssive because in the tail of line 5, you don’t mention “as”. I’d love an explanation of what you’re trying to do since it looks like you’re trying to do a map, which is “do something for each element in a list.
09:32:14 <Mayzie> quicksilver: I don't know/understand Monad's that well :-(
09:32:42 <Welkin> Mayzie: a monad is just a monoid in the category of endofunctors!
09:32:47 <Cale> orion: I don't understand what the problem is according to your post...
09:32:54 <quicksilver> Mayzie: well you have to learn sometimes. Although doing the Int -> [A] -> (Int,[A]) game for a while is good practice
09:32:57 <quicksilver> shows you how it works.
09:33:01 <Welkin> Mayzie: this may sound like a joke, but it totally makes sense once you learn what a monad is :D
09:33:16 <Welkin> that's the funny part
09:33:26 <Cale> orion: Is it a bad idea to convert a cipher hash to a key? Do you want to control how it's done better?
09:33:27 <umib0zu> hexagoxel so that’s a question. In Cabal do I need to explicitly list packages I depend on in the cabal.config or do I need to do it myself? I’m used to python where it “freezes” by looking into the sandbox and just building the file on it’s own.
09:33:28 <hackrilege> Mayzie, hows about like this; http://lpaste.net/142587
09:33:29 <Welkin> that explanation sounds like a joke, but it isn't, even though it is used as a joke by all of us
09:34:00 <Cale> Welkin: uh, and you learn what a monoidal category and a monoid object are...
09:34:04 <orion> Cale: Here's an example: The spec requires me to to calculate a hash 'h' and assign it to a symmetric key 'k'. It is written as "Set k = h". But k :: SymmetricKey c and h :: Digest c.
09:34:13 <Welkin> lol Cale 
09:34:21 <hackrilege> monads are not nescacary her
09:34:24 <Welkin> well, at least you learn what Monoid is for haskell
09:34:31 <Cale> Welkin: I don't think that joke actually makes sense to most people who learn about monads in Haskell.
09:34:33 <orion> Cale: As a result of that one requirement, I need a whole new function in my typeclass to just convert from Digest c -> SymmetricKey c.
09:34:34 <Welkin> and functor
09:34:52 <Cale> Welkin: Also, it's not a joke, it's a formally correct statement.
09:34:58 <Welkin> Cale: I know :P
09:35:08 <Welkin> Cale: that's the joke
09:35:37 <hackrilege> notice how the helper function takes i as an argument, this means that i is now visible in the scope of this function, and you can use it as you like
09:35:50 <hexagoxel> umib0zu: your cabal file ("mypackage.cabal") contains a "build-depends" section (for each component) that lists the package's dependencies.
09:35:52 <Cale> But yeah, if you don't know what a monoidal category is, then you don't *really* get it yet :)
09:36:04 <Mayzie> Okay, from looking at it, Monad State doesn't seem too bad.
09:36:10 <Mayzie> Nekminute, /me cries :-P
09:36:17 <hackrilege> did you see my paste above?
09:36:21 <Cale> (because that's a prereq to understanding the definition of a monoid object, which is a generalisation of the idea of a monoid in the category of sets)
09:36:23 <Mayzie> I did
09:36:28 <hackrilege> is this not ok?
09:36:28 <hexagoxel> umib0zu: i don't know of a utility that automatically writes the build-depends section from what you have in your sandbox currently.
09:36:36 <Mayzie> I don't really understand it
09:36:42 <umib0zu> hexagoxel, what’s the difference between cabal.config and <packageName>.cabal?
09:37:03 <hackrilege> its defo the beginers way, these guys ate too many bifunctors for breakfast
09:37:05 <umib0zu> Mayzie, please. Type out what you’re trying to do. Not in Haskell. Use your words.
09:37:19 <Welkin> umib0zu: cabal.config is a configuration for your cabal sandbox (or global cabal install) while project.cabal is your project build instructions
09:37:22 <hackrilege> he has phrased his problem fine already
09:37:31 <orion> Cale: And as I implement more functions, I am finding that I have to do this type shuttling all over the place. Another example: The spec requires that I compute hash(h || data), where hash :: ScrubbedBytes -> Digest c, h :: Digest c, and data :: ScrubbedBytes. Now I need *another* function in my typeclass to convert Digest c -> ScrubbedBytes *just* so that I can concatenate them together.
09:37:44 <hackrilege> its a simple lack of experience passing arguments to recursive functions. that is the nesacary lesson here
09:38:13 <orion> Cale: And it's all because the spec treats every single variable as a blob of bytes that are all interchangable with one another.
09:38:19 <Cale> orion: I mean, sure, but that extra step is how you express that you *really* want to do that.
09:38:29 <Cale> Because those values are of different types.
09:38:45 <umib0zu> I saw that but I’m trying to figure out the “getHello” method to. Looks like some Type problems as well considering Types are referenced in expressions. hackrilege
09:38:52 <hexagoxel> umib0zu: <package>.cabal is the package description. cabal.config is a local set of config values (which you do not need in most cases)
09:38:59 <Welkin> > let fib a b = a : fib b (a + b) in fib 0 1 -- hackrilege, you mean this?
09:39:01 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
09:39:05 <Welkin> I love that example
09:39:30 <Mayzie> Umm, how do I initialise a State Monad?
09:39:30 <umib0zu> hexagoxel so I actually need to manually add my package dependencies to <packageName>.cabal?
09:39:34 <hackrilege> yes Welkin has a good example Mayzie.
09:39:39 <Welkin> Mayzie: pass it a value
09:39:58 <Cale> Mayzie: Do you mean, how do you run a State action?
09:40:09 <hexagoxel> umib0zu: yes; freezing into cabal.config is not necessary/desired in general.
09:40:09 <Cale> Mayzie: runState myAction initialState
09:40:15 <hackrilege> what about just using zip? thats a pretty neat way to number a list...
09:40:27 <hackrilege> > zip "hello" [1..]
09:40:29 <lambdabot>  [('h',1),('e',2),('l',3),('l',4),('o',5)]
09:40:55 <Cale> orion: I dunno. It's certainly possible to be less well-typed
09:41:01 <Welkin> umib0zu: yes, you add your dependencies with optional (but highly recommended) version constraints
09:41:14 <Mayzie> Welkin, Cale: Thank you :-)
09:41:22 <Cale> orion: The more you put into your types, the more work it's usually going to be to convince the compiler that your programs are type correct.
09:41:25 <hexagoxel> umib0zu: freezing nails down exact versions, while you often want to be less restrictive (i.e. give version bounds). especially for libraries.
09:41:38 <Welkin> cabal will let you now what packages you need to add when you build your program
09:41:45 <Welkin> then just copy the names down
09:41:47 <Cale> orion: But at the same time, you prevent various additional abuses, and hopefully exclude many incorrect programs.
09:42:16 <hexagoxel> umib0zu: otherwise your library will be unusable together with anything that differs in just one of your frozen versions.
09:42:53 <hackrilege> > map fst $ filter (even.snd) $ zip "hello" [1..]
09:42:55 <lambdabot>  "el"
09:43:15 <Welkin> umib0zu: I often have trouble with the version bounds in libraries and have to make my own fork or contact the author
09:43:23 <Welkin> so setting version constraints it a bit of an art
09:43:24 <orion> Cale: Indeed, you're right.
09:43:27 <Welkin> for libraries
09:43:52 <umib0zu> hm… interesting
09:43:54 <Welkin> usually the version constraints are unnecessarily conservative
09:44:50 <Welkin> cabal is guilty of this too, when using `cabal init` for a new project
09:45:02 <Welkin> I always have to change the upper bound for base to <5.0
09:45:12 <hexagoxel> umib0zu: for personal use, giving no version bounds is fine in most cases. (at least when using sandboxes, which i strongly recommend)
09:45:57 <umib0zu> Why would bounds be better or worse than just straight up giving exact versions?
09:46:02 <hackrilege> Welkin +1, thanks i didnt know you could do that
09:46:14 <hackrilege> it seems silly to build in redundancy with an upper bound an base
09:46:17 * hackagebot linearscan 0.11.1 - Linear scan register allocator, formally verified in Coq  https://hackage.haskell.org/package/linearscan-0.11.1 (JohnWiegley)
09:46:20 <Welkin> umib0zu: because if you don't have those exact versions of everything installed, you can't build the program
09:46:45 <Cale> I don't think that we should ever put upper bounds which we can't verify.
09:46:45 <hackrilege> there should be a crazy setting where it just tries everything...
09:46:48 <Welkin> and you can only have one version for each package installed at a time
09:47:18 <umib0zu> is that a bad thing? when will you not be able to get the exact versions? Sorry if I’m going down a rabbit hole, but I come from npm. A lot of this is abstracted away in javascript land.
09:48:01 <hackrilege> yeh, i guess best practice would not be to lie about which base versions you use, and the redundancy is possibly real, so i guess without a maintainer it would end up broken anyway, but i dread having to keep up with my libraries for the rest of my life...
09:48:28 <Mayzie> How do I get the value of a state, outside of the State's monad (i.e. not within the State's do block)
09:48:35 <tsahyt> umib0zu: Something in the current tool chain (I think it's ghc-pkg) doesn't support having more than one version of a package installed
09:48:46 <Cale> no
09:49:01 <Cale> tsahyt: That's not the correct statement :)
09:49:19 <Cale> GHC doesn't support having more than one of the same package/version combination installed
09:50:02 <Cale> So, e.g. if you want more than one aeson-0.9.0.1, you're out of luck
09:50:22 <Welkin> umib0zu: when you want to upgrade any of the packages, you will have major problems
09:50:24 <Cale> and you may indeed want more than one, built against different dependencies
09:50:27 <hackrilege> --force-reinstalls
09:50:42 <Welkin> umib0zu: also, if someone tries to add your library to their existing project, they will most likely not be able to build it
09:50:47 <tsahyt> Cale: Do sandboxes help with that?
09:50:51 <Cale> yes
09:51:07 <hackrilege> always works, never breaks everything all at the same time... 
09:51:07 <hexagoxel> umib0zu: suppose you wanted to use two libraries, with an intersecting set of dependencies, but conflicting exact versions.
09:51:16 <tsahyt> Good to know. I haven't dealt with this kind of stuff ever since I switched over to stack
09:51:17 <umib0zu> Welkin well that’s the problem. In our land, we never upgrade. It’s easier to just re-write all our code and start a new package.
09:51:27 <hackrilege> lol
09:51:33 <hexagoxel> umib0zu: the dependencies of those to libraries, that is
09:51:35 <Welkin> umib0zu: in haskell, upgrading is super easy
09:51:40 <umib0zu> lol is right but it’s true
09:51:47 <Cale> stack should still have that limitation, because it's actually a GHC limitation.
09:52:02 <bitemyapp> johnw: you're winning fans
09:52:03 <Cale> But I think their solution is just to always sandbox everything?
09:52:09 <johnw> bitemyapp: oh?
09:52:10 <bitemyapp> johnw: re: Emacs and linearscan.
09:52:12 <Cale> So it probably wouldn't come up as much then
09:52:14 <johnw> where??
09:52:22 <bitemyapp> johnw: #haskell-embedded
09:52:23 <tsahyt> Sandboxing everything by default is what I ended up doing with cabal too, so I'm fine with that
09:52:31 <hackrilege> Welkin, I just changed the definition of a vector from curried to uncurried and im spending the day playing with commas and brackets. there are some nasty pitfalls that make refactoring a nightmare
09:52:41 <Mayzie> How do I get the value of a state, outside of the State's monad (i.e. not within the State's do block)
09:52:49 <umib0zu> Mayzie
09:52:57 <Cale> Mayzie: It's part of the result of runState?
09:52:58 <Welkin> Mayzie: runState
09:53:02 <Cale> :t runState
09:53:03 <lambdabot> State s a -> s -> (a, s)
09:53:31 <Cale> When you execute a computation of type State s a, you provide an initial state of type s, and you get back a result of type a, along with a final state of type s
09:53:35 <Mayzie> But I have to pass it in something?
09:53:43 <Cale> Of course.
09:53:56 <Cale> State s a values are really just functions of type s -> (a,s) in disguise
09:54:00 <Mayzie> That's not what I want
09:54:17 <hexagoxel> sweet sugary disguise
09:54:39 <Cale> You ultimately can't do anything with a value of type State s a which you couldn't already do with a value of type s -> (a,s), and vice-versa.
09:54:58 <Mayzie> I thought State allowed me to store something outside of a function?
09:55:04 <Cale> But State s has a Monad instance, which gives you a convenient way to chain such things together.
09:55:20 <Cale> I don't even know what that means
09:55:35 <Cale> What do you mean "outside of a function"?
09:55:35 <Welkin> Mayzie: there is no assignment in haskell, if that is what you mean
09:55:38 <davean> There really isn't "outside of a function"?
09:55:45 <Welkin> everything is inside of a function
09:55:53 <hexagoxel> no, State is not Haskell's variant of a global variable.
09:55:54 <srhb> That's patently not true.
09:55:55 <Cale> What is the boundary of a function?
09:55:55 <Welkin> the outermost function is main which has type IO ()
09:56:02 <srhb> main = putStrLn "hello world" -- is not a function.
09:56:04 <Cale> I don't know what "inside" and "outside" mean
09:56:25 <srhb> But it's not relevant to the question.
09:56:52 <mutantmell> Mayzie: State allows you to bundle some 'state' with a type.  It doesn't allow you to store something globally
09:57:14 <Mayzie> Gah
09:57:27 <mutantmell> Mayzie: Haskell makes you document via types everythign the function needs to work, so there's no real way for global state in the way you want
09:57:59 <Cale> Values of type State s a are descriptions of computations which may read and write a value of type s, while producing some result of type a
09:58:22 <Mayzie> This is bs
09:58:28 <Cale> We implement this type using simply a function from the initial state of type s, to a pair consisting of the result of type a, and the final state of type s
09:58:39 <srhb> Mayzie: It's actually really nice. :-)
09:58:47 <Mayzie> No, it really isn't.
09:58:54 <srhb> Mayzie: Ok. :P
09:58:56 <davean> Mayzie: You're focused on doing the thing you want the way you want, not actually just doing the thing you want
09:59:06 <Cale> Mayzie: Maybe you should describe what you're trying to accomplish, rather than talking about the State monad.
09:59:13 <Mayzie> It's probably an instance of the x y problem, I know.
09:59:18 <Cale> Mayzie: Real world uses of the State monad are pretty rare.
09:59:54 <Cale> It exists to clean up a particular sort of code which shows up from time to time, where you're constantly chaining along values from the result of one function to the next.
10:00:01 * hexagoxel learns that his code is not real-worldly
10:00:20 <Cale> I'm not going to say they don't happen! :)
10:01:10 <Cale> But there are lots of other ways to manage the state of something in general.
10:01:19 <davean> hexagoxel: How many "RealWorld" and "realWorld#"s does your code contain?
10:01:38 <Cale> and using the State monad itself, eh, it doesn't come up that much in my experience at least.
10:01:46 <davean> hexagoxel: we can actually quantify how "RealWorld" your code is
10:01:52 <hexagoxel> you mean IO? i think every executable uses that at least once, let me check :D
10:02:07 <davean> hexagoxel: no, I don't mean IO :-p
10:02:09 <Cale> Mayzie: So what program are you trying to write?
10:02:18 <davean> I mean "RealWorld"
10:02:34 <davean> hexagoxel: https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Monad-ST.html#t:RealWorld
10:03:00 <Cale> RealWorld is a 0-byte token type which is part of the somewhat-ugly hackery that GHC uses to implement IO.
10:03:15 <hexagoxel> davean: :)
10:03:19 <davean> Cale: Yep :) I'm just giving hexagoxel crap
10:03:23 <Cale> If anyone is trying to understand what IO is about, I would recommend ignoring it.
10:03:25 <johnw> "RealWorld is a 0-byte token type".  I wonder if future philosophies could be founded on that statement.
10:03:25 <Mayzie> Basically, I have two functions, let's call them `f` and `g`. `f` accepts an array, and `g` accepts an array. I want `f` to call `g`, and `g` will then do some operation and increment a counter variable, so that the next time `g` is called, it can continue on from that counter variable.
10:03:42 <Welkin> > runState (modify (+5) >> modify (*20) >> get) 1 -- Mayzie 
10:03:43 <lambdabot>  (120,120)
10:03:56 <monochrom> RealWorld is a phantom type. its "value" is passed around to remind the code generator about sequential order. THE END.
10:04:01 <davean> Cale: I'm joking about hexagoxel's "12:59:39  * hexagoxel learns that his code is not real-worldly"
10:04:24 <davean> I tihnk hexagoxel just learned their code is even *less* real-worldly then they thought
10:05:17 <Mayzie> Cale: Trying to do an assignment.
10:05:19 <Cale> Mayzie: So one thing you could do is to have these be functions with types like a -> IO b, and create g using an IO action which sets up an IORef for the counter.
10:05:43 <Mayzie> But I read that doing any other IO operations could stuff that up (which I am)
10:06:00 <tsahyt> Has anyone tried to use Haskell for Ubuntu Phone app development? I need a new phone, and I might as well get one that I can write some small stuff for using Haskell if it works.
10:06:05 <Cale> Mayzie: Or you could simply have g be a pure function which takes the current value of the counter as an additional argument, and produces the new value of the counter along with its result
10:06:27 <Mayzie> Cale: But how can I pass back the value of the counter?
10:06:34 <tsahyt> Experiences with Haskell for Android development would also be welcome of course
10:06:41 <Cale> Mayzie: and then you just have to be careful to carry along the right version of the counter to what follows
10:06:57 <Cale> Mayzie: So that you can pass the new value of the counter to g next time
10:07:09 <Mayzie> Actually, I think I know a way to do it.
10:07:19 <Cale> There are lots of things in between this
10:07:23 <mutantmell> Mayzie: You can return a tuple!  Similar to how python returns two things
10:07:38 <Mayzie> Yeah, I know about tuples in both Python and Haskell.
10:07:49 <Bez_> :t (&)
10:07:50 <lambdabot> a -> (a -> b) -> b
10:07:52 <Mayzie> Just wasn't quite sure how to apply it to a function call as it's a result
10:08:00 <Mayzie> I think I can get what I want with a `let` block.
10:08:15 <Bez_> :t (~)
10:08:16 <bollu> where can I read up on template haskell? I want to construct syntax for group theory (free groups, generators and stuff)
10:08:16 <lambdabot> parse error on input ‘)’
10:08:16 <Cale> The State Integer monad is a wrapper around this approach of taking the counter as an extra parameter and producing the counter as an additional part of the result
10:08:40 <Welkin> Bez_: ~ denotes type equality (in a type signature)
10:08:51 <Cale> But it probably helps to see how to do things that way by hand before you go on to use State Integer to clean it up.
10:09:05 <Cale> Another way is to abstract over the operations which interact with the counter.
10:09:16 <nitrix> Bez_: Just in case, boolean AND is (&&) in Haskell.
10:10:06 <hexagoxel> Cale: it is just that i am quite used to having a MultiRWS(T) for the high-level parts of my programs. to be fair, i mostly use Readers (for config etc.); but State is not uncommon either.
10:10:11 <mizu_no_oto> Mayzie: you can pattern match on a tuple in a where clause
10:10:30 <Cale> This might be a bit too fancy if you're a beginner, but you could work in an arbitrary monad, and pass in an operation which ought to, say, add some value to the counter as an argument to g:   g :: (Monad m) => (Integer -> m ()) -> Array ... -> m (Array ...)
10:10:37 <Mayzie> mizu_no_oto: I need both results.
10:11:17 * hackagebot JsonGrammar 1.0.3 - Combinators for bidirectional JSON parsing  https://hackage.haskell.org/package/JsonGrammar-1.0.3 (MartijnVanSteenbergen)
10:11:36 <mizu_no_oto> > let f = x + y where (x, y) = (1, 3)
10:11:36 <hexagoxel> Cale: but it may well be that my design is bad; i have not applied it sufficiently often to be certain.
10:11:37 <lambdabot>  <no location info>:
10:11:37 <lambdabot>      not an expression: ‘let f = x + y where (x, y) = (1, 3)’
10:12:17 <Cale> Mayzie: Using that with the IO monad, you could pass in an action which increments an IORef, using it in State s, you could pass in an action which increments (some part of) the state value which is being threaded along.
10:12:37 <mizu_no_oto> Mayzie: you can define something like "f = x + y where (x, y) = (1, 3)" to bind both x and y with the pattern match.  You get both values
10:12:56 <nitrix> Bez_: Similarly, for (~) you might be more interested in the bitwise `complement` function. Even (.&.) bitwise AND now that I think about it.
10:13:45 <Cale> hexagoxel: I usually find that if you're just doing ReaderT over IO, it's probably not going to pay for itself.
10:14:14 <Cale> hexagoxel: You pay a cost in terms of all the liftIO you need to do, and losing the ability to easily forkIO / catch exceptions / etc.
10:14:32 <Cale> hexagoxel: and often passing an extra parameter ends up being simpler anyway
10:14:42 <Cale> (and easier to use while testing)
10:15:42 <Cale> But if you're building a well-encapsulated new monad type, then you've already paid those costs, and an extra ReaderT likely won't hurt anything.
10:16:27 <MarcelineVQ> Did you guys know that if you ask Cale enough questions your code actually writes itself?
10:16:33 <Cale> heh
10:17:21 <MarcelineVQ> It doens't even take that many :>
10:17:57 <Cale> IO is a very capable monad already, and I tend to not like to transform it with ReaderT/WriterT/StateT. There are other approaches to managing those sorts of things which are available. You can even abstract over the choice of monad locally, while secretly using IORefs to implement the operations.
10:19:06 <Cale> (in a way that would let you plug in other implementations for how to access the state/environment if you were working in something other than IO)
10:26:37 <suppi> is it possible to generate haddock documentation for all files in a specific folder with stack?
10:28:33 <fizruk> suppi: stack exec haddock ... ?
10:28:45 <fizruk> I have not tried that
10:29:42 <Shockk> quick question; do *> and >> do the same thing? or rather, should they?
10:29:45 <suppi> i will try. thanks
10:30:27 <suppi> fizruk, only stack exec haddock? because that does nothing
10:30:53 <hexagoxel> Cale: but there is fun if you cannot write type signatures like `forall r w s m mi . ( ContainsType Cache r, ContainsType Config r, m ~ MultiRWST r w s mi, Monad mi) => Foo -> Bar -> m ( [Baz], IO [Zoo] )`
10:30:54 <hexagoxel> :p
10:31:02 <fizruk> suppi: no, stack exec haddoc -- (haddock parameters)
10:31:32 <suppi> fizruk, oh, maybe I was over specific, I don't really know how to do it without stack either :)
10:31:38 <hexagoxel> +no
10:32:40 <ReinH> Cale: Maybe the story would be different if common IO actions and arrows were already lifted into MonadIO...
10:32:50 <Cale> hexagoxel: Yeah, there seem to be a lot of cases where people will write type signatures like that when they have little to no intention of ever using the polymorphism, and aren't even getting much benefit out of the fact that the operations they can apply are limited by it.
10:33:22 <delYsid> Hmm, I am getting a "defined but not used" for a record field that *is* actually used in the same module.  Any idea what could trigger that?
10:33:24 <Cale> It's sort of a "why won't you just say what you mean?" situation.
10:33:52 <Daniel__> hello
10:33:52 <fizruk> suppi: haddock my_dir/**/*.hs ? it seems that haddock only receives files as its arguments
10:33:59 <Cale> delYsid: hm, in any case it's a harmless warning
10:34:05 <Cale> delYsid: I tend to ignore most of those
10:34:13 <fizruk> suppi: alternatively: stack haddock -- my_dir/**/*.hs
10:34:21 <tulcod> Shockk: yes. *> is sort of in analogue with <*
10:34:25 <fizruk> suppi: still, I haven't tried those
10:34:32 <Cale> delYsid: But be careful that the warning isn't really about an accidental shadowing of that name
10:34:32 <suppi> fizruk, thank you
10:34:34 <delYsid> Cale: Sounds a bit like "accidental" overuse of templates in C++ :-)
10:35:13 <delYsid> Cale: So those are known false-positives of GHC?
10:35:21 <Cale> delYsid: I don't know.
10:35:41 <Cale> delYsid: I tend to write things in a way which triggers that warning, and I'm too stubborn to care.
10:35:48 <Cale> :)
10:36:09 <Cale> Often I want to name parameters to things rather than using _ even in cases where I'm not using the thing I've bound
10:36:09 <delYsid> Its OK, I know it is just a warning, I was just "Huh, this is a false positive!"
10:36:40 <delYsid> The use of the record is hidden in a where clause, maybe thats why.
10:36:42 <Cale> If you're worried about it, stick the code on lpaste.net or something and we can look and see if there's something you missed
10:37:53 <delYsid> I know it is called, so no worries.  I was just surprised that a compiler for a *pure* langauge would have issues like that.  I guess nobody is perfect...
10:38:15 <Shockk> delYsid: do you have a parameter to the function where the `where` clause is, that has the same name as the record field?
10:38:28 <Cale> hexagoxel: In our own codebase at Obsidian, there are a bunch of type signatures I really want to clean up by just using a monomorphic type... we have stuff like: (MonadReader (FrontendEnv t) m, MonadWidget t m, MonadFix (WidgetHost m), HasJS x (WidgetHost m), HasJS x m) => ... and there's really no good reason to put up with it, other than it's a bunch of work to go through the code and make it monomorphic.
10:38:41 <delYsid> Shockk: no.
10:38:49 <hexagoxel> Cale: i think, you basically get implicit parameters. which shifts code length from the expression to the type signature.
10:39:03 <Cale> hexagoxel: Kind of :)
10:39:08 <Shockk> hmm, is that function itself used / exported from the module?
10:39:27 <Cale> hexagoxel: and then you get to pay for liftIO as well, instead of the parameter you'd be passing around.
10:39:50 <Cale> delYsid: Which GHC version? You might want to report a bug.
10:39:56 <delYsid> Shockk: The call-site basically looks like f x = blah g where g = field x
10:40:13 <delYsid> Cale: I am on Debian, so still 7.8
10:40:21 <delYsid> I guess its useless to persue that
10:41:07 <bennofs> delYsid: is the expression where the record field is used used itself?
10:41:36 <delYsid> bennofs: Yes, otherwise my test case wouldnt work :-)
10:41:57 <delYsid> Its like the pitch of my notes.  I would *hear* if they were missing :-)
10:42:08 <bennofs> delYsid: hmm, interesting. can you lpaste the file?
10:42:15 * bennofs is curious
10:42:49 <delYsid> bennofs: I can drop you a link, wait.
10:43:09 <hexagoxel> Cale: true. it depends on how certain the base monad is / if you really need a monad at all. and at `main` level i also prefer not using ReaderT's.
10:44:20 <delYsid> bennofs: https://github.com/mlang/hbmc/blob/master/Haskore/Interface/Braille.hs
10:44:58 <bennofs> delYsid: which field is reported as unused?
10:45:05 <Shockk> delYsid: what'- what bennofs asked
10:46:45 <delYsid> Oh, I realize my error, it is used (by me in the REPL) but not exported, doh, sorry.
10:46:52 <bennofs> :)
10:47:09 <delYsid> bennofs: ambiguousStep, but see above, sorry.
10:58:56 <tsahyt> What's the idiomatic way to iterate a function Eq a => a -> a until it doesn't change the input anymore? I'm thinking of doing this in terms of iterate and some kind of dropping function
10:59:53 <tsahyt> Put differently, I'm looking for a function that drops elements from a list until the next element is the same as the previous
11:00:08 <tsahyt> (same as in ==)
11:01:50 <clrnd> mmm like takeWhile but taking in pairs
11:02:04 <clrnd> @src takeWhile
11:02:05 <lambdabot> takeWhile _ []                 = []
11:02:05 <lambdabot> takeWhile p (x:xs) | p x       = x : takeWhile p xs
11:02:05 <lambdabot>                    | otherwise = []
11:02:33 <mmachenry> clrnd: It's easy to write such a function. I think tsahyt is hoping one already exists. 
11:02:47 <tsahyt> Yep, exactly.
11:02:50 <clrnd> I know, was jut mumbling
11:03:43 <mmachenry> It's something like "map snd $ takeWhile (\(a,b)->a==b) $ zip myList (restMyList)"
11:03:47 <tsahyt> > snd . head . dropWhile (uncurry (/=)) . ap zip tail $ [1,2,3,4,4,4]
11:03:49 <lambdabot>  4
11:03:59 <mmachenry> But that's not better than just writing it out yourself.
11:04:10 <mmachenry> tsahyt: Yeah that
11:04:21 <Mayzie> In a let clause, how can I pattern match on the result of a function?
11:04:29 <tsahyt> Eh, I'll just roll my own then
11:04:31 <mmachenry> But if you're going to do that, you might as well just write a function.
11:04:43 <tsahyt> Yes, I was thinking that something like this would be in a library somewhere
11:04:57 <mmachenry> tsahyt: Yeah, maybe. Not that I know of.
11:05:00 <tsahyt> I guess I might as well scrape all those "iterate until" patterns together and put them in a library one day
11:05:02 <mmachenry> It's just weird enough.
11:05:36 <Ankhers> let (x:xs) = take 5 [1..] -- Mayzie ?
11:05:57 <hpc> tsahyt: there's an example of what you want to do in acme-php, under sortBy
11:06:03 <Mayzie> Ankhers: Right, thanks :-)
11:06:10 <hpc> (i leave it an exercise to the reader to figure out how it got there)
11:06:15 <clrnd> lol
11:06:26 <Ankhers> Mayzie: I think that can cause issues though. Just because you can't have multiple patterns.
11:06:55 <Mayzie> That's cool.
11:07:03 <tsahyt> What? Why do I get a type error when I write the above as a top level function (minus the $ [...]) without a type signature?
11:07:14 <tsahyt> Is this the monomorphism restriction?
11:07:20 <Mayzie> Just hope everything doesn't break (as is typical with my Haskell programs)
11:07:25 <hpc> are you writing foo = partially applied whatever?
11:07:33 <hpc> or foo x = fully applied x?
11:07:56 <tsahyt> The former
11:08:08 <clrnd> what error?
11:08:30 <tsahyt> No instance for (Eq c0) arising from a use of '/='
11:08:37 <Ankhers> partially applied is different from ETA reduction though, right?
11:08:43 <tsahyt> It works with a type signature of course
11:08:53 <tsahyt> ghc-mod can't infer the class constraint either
11:09:12 <tsahyt> This is the line: dropDifferent = snd . head . dropWhile (uncurry (/=)) . ap zip tail
11:12:08 <hpc> tsahyt: when the left of the equation is "foo = ...", it looks like plain data stuff
11:12:18 <hpc> as opposed to "foo params = ..."
11:12:27 <hpc> and the former will trigger the monomorphism restriction
11:12:32 <hpc> (if enabled)
11:13:01 <hpc> ignoring any further information, give it a type signature anyway
11:13:08 <hpc> because that's a big composition of functions
11:13:22 <tsahyt> I suspected that. I wanted to add a signature anyway, I just noticed it when I was asking ghc-mod to do that for me
11:13:58 <clrnd> it's weird anyway, right? ghc 7.10?
11:14:10 <tsahyt> GHC 7.8.4
11:14:31 <exio4> it is the expected behavior
11:14:43 <tsahyt> At least I think I'm on 7.8.4. Stack might have picked a newer resolver, gotta check.
11:14:58 <tsahyt> Nope, 7.8.4
11:15:39 <Copperis> hi, can anyone tell me what causes the error in line 6? http://lpaste.net/142592 "6:5: parse error on input ‘rightSide’"
11:16:17 <kaol> I saw this line in snaplet-postgresql-simple, what's that ^# thing? let manager = PostgresAuthManager tableDesc $ db ^# snapletValue
11:16:20 <dmj`>  Copperis: indent line 6 to be directly under line 5's 'leftSide' defintion
11:17:12 <dmj`> kaol: probably a lens
11:17:39 <Copperis> dmj`, thanks
11:17:54 <Copperis> so haskell is like python in this case
11:18:43 <dmj`> Copperis: in a let .. in block it's similar
11:19:27 <tsahyt> Copperis: Not quite, you can avoid the layouting rules with explicit { ..; ..; } blocks
11:19:49 <clrnd> it's quite weirder than python
11:20:03 <tsahyt> Yes, but at least it helps readability
11:27:54 <AwesomeHaircut> Hi all. I'm learning Haskell and one of the snags i run into every once in a while when i install something trhough cabal it fails
11:28:13 <AwesomeHaircut> And then i have toinstall w/e dependecies it has one by one. Is that normal?
11:29:33 <clrnd> AwesomeHaircut, do you use sandboxes?
11:29:43 <clrnd> stack can be friendlier too, depends what is your use case
11:29:46 <AwesomeHaircut> no
11:30:53 <AwesomeHaircut> right now it happened with hsqml-demo-samples and it complaint about opengl
11:31:37 <AwesomeHaircut> clrnd: what do you mean by stack?
11:32:23 <clrnd> AwesomeHaircut, https://github.com/commercialhaskell/stack
11:32:34 <profsimm> I'm not a haskell user but I have a situation that's similar to what Haskell users deal a lot with so I thought I'd ask: when you partially apply a function you get back a function with less parameters, say instead of "a, b, c, d", just "c, d". When I end up eventually executing this function with less parameters, if the function encounters a problem in "a" how would this be communicated to the user when I didn't pass "a" in the curr
11:33:14 <gfixler1> with *fewer* parameters
11:33:45 <AwesomeHaircut> clrnd: thanks
11:34:20 <Ankhers> profsimm: What do you mean by 'a problem in "a"'?
11:34:43 <tsahyt> profsimm: Until the result is needed nothing will be calculated either way.
11:34:50 <clrnd> it will fail as if you didn't curry it, I think that's what you mean
11:34:54 <Ankhers> profsimm: Also, you cut off at I didn't pass "a" in the curr
11:34:55 <profsimm> Ankhers: let's say the function requires an even number and I passed in odd. Something not expressible with type.
11:35:22 <profsimm> "...how would this be communicated to the user when I didn't pass "a" in the current invocation?" :)
11:35:46 <tsahyt> It will behave the same as if you passed all parameters at once
11:36:03 <profsimm> tsahyt: it will behave the same, but my point is, the error becomes harder to track down I think
11:36:31 <profsimm> tsahyt: "a, b" were probably partially "applied" at some completely different part of the app
11:36:55 <tsahyt> But they'll only be evaluated by the function once the return value is needed
11:37:09 <profsimm> tsahyt: yes, but that is the *problem*.
11:37:46 <tsahyt> No it isn't. You should find those invocations in a trace almost directly at the top
11:37:46 <profsimm> tsahyt: let me put it this way. Does Haskell often produce incredibly lock stack dumps on error :)
11:38:00 <profsimm> Err wait I have foot in mouth
11:38:01 <profsimm> I mean
11:38:14 <profsimm> Does Haskell often produce incredibly LONG traces on error
11:38:36 <tsahyt> It doesn't produce a trace at all. You can produce one when debugging in ghci though
11:38:46 <profsimm> So when you debug, does it?
11:38:57 <tsahyt> When you call the function using :trace in ghci, yes
11:39:01 <bergmark> profsimm: it seems like what you are describing would result in a type error during compilation
11:39:23 <profsimm> bergmark: when it's a type error it's easy, and you're right.
11:39:38 <profsimm> bergmark: the problem is for problems that won't be a type error but a runtime error
11:40:13 <tsahyt> So basically, the problem arises when you have a function foo :: a -> b -> c, and you bind bar = foo undefined (or similarly awful) somewhere and then use bar somewhere else.
11:40:43 <profsimm> tsahyt: it's more subtle, let's say I bind an odd number, 3, and the function requires an even number.
11:41:07 <profsimm> tsahyt: but otherwise, yes
11:41:14 <tsahyt> You should be able to step directly to where that input came from in the debugger
11:41:48 <profsimm> tsahyt: my problem is I wish I could model such errors so it's clear where they came from without a debugger
11:42:00 <profsimm> tsahyt: from the runtime error
11:42:26 <tsahyt> Well you could annotate your values with their origin
11:43:27 <tsahyt> data Origin a = Origin a String, for example. You could then read that String where the error is produced and use that for a better error message. It's quite unwieldy though.
11:44:19 <MarcelineVQ> "<profsimm> Ankhers: let's say the function requires an even number and I passed in odd. Something not expressible with type." perfect place for tests like QuickCheck can do for you
11:45:21 <Ankhers> MarcelineVQ: It still doesn't prevent you from passing in an odd number.
11:45:44 <profsimm> Ok, thanks folks, I'll explore the options you gave me.
11:45:46 <MarcelineVQ> It lets you know you need to handle that case though
11:45:57 <Ankhers> True.
12:16:41 <et8> anyone experience:     No instance for (MonadState Tickets (Query Tickets))
12:16:45 <et8> when using acid-state
12:17:18 <et8> the code compiled fine before but now is giving MonadState / MonadIO errors
12:17:34 <et8> only difference is going from cabal build to nix-build
12:18:43 <dmj`> et8: can you paste your code
12:20:01 <et8> dmj`: https://gist.github.com/et4te/26f5238da4fbfb8ce83d
12:22:01 <dmj`> et8: Update is a State monad, you'll have to use liftQuery to retrieve data from your state inside of the Update monad
12:22:13 <dmj`> instead of 'ask'
12:22:39 <dmj`> same with line 40, Query is a Reader monad, you'll need to use 'ask'
12:22:56 <et8> ahhh
12:22:57 <et8> :D
12:23:22 <lpaste> schell pasted “monoid by replacement” at http://lpaste.net/142594
12:23:35 <dmj`> insert and lookupKey are fine, allTickets needs to be 'ask' and delete should be 'get'
12:23:46 <dream> Hi, trying to access Johnsson's thesis titled “Compiling Lazy Functonal Languages”, but without luck. I would appreciate a link if you have it.
12:23:51 <schell> does anyone know of a two constructor sum type that has a monoid instance that uses replacement? like pasted above? ^
12:24:27 <schell> it would (could) reresent something like a default value
12:25:07 <et8> dmj`: that works! however the liftIO call doesn't
12:25:45 <et8> dmj`: is there a way of specifying that the monad is MonadIO there
12:26:39 <dmj`> et8: Query and Update are pure, no I/O allowed, I recommend passing in what you want as a paremeter, then call liftIO outside in your application, before you hit the db
12:27:19 <dmj`> parameter*
12:27:44 <et8> et8: ah ok I see. When you say you need to use liftQuery inside update, isn't that what get does?
12:29:37 <et8> dmj`: I mean sorry, why is there a need to use liftQuery when you can use get within the Update monad
12:29:42 <monochrom> > mappend (Just ()) Nothing
12:29:44 <lambdabot>  Just ()
12:30:04 <schell> actually what i’m looking for sounds more like alternative, but without the monad instance
12:30:22 <schell> monochrom: yeah i think it would be a monad
12:30:23 <monochrom> > mappend Nothing (Just ())
12:30:26 <lambdabot>  Just ()
12:31:05 <monochrom> schell, your Binary looks like Maybe, except that your mappend looks like Maybe's mappend flipped
12:31:11 <dmj`> et8: liftQuery is defined in terms of get, so there's no need to use it over 'get' if you don't want to
12:32:01 <dmj`> et8: liftQuery query = runReader (unQuery query) <$> get
12:32:23 <et8> dmj`: thanks a lot for your help
12:32:47 <schell> monochrom: right - my type drops the monoid constraint on the contained type
12:32:49 <dmj`> et8: of course
12:33:30 <monochrom> I see
12:34:15 <schell> monochrom: i’m essentially trying to help a type act monoidal without requiring a monoid instance
12:34:30 <schell> because i have a monoid constraint i’d rather not have, lol
12:34:55 <monochrom> schell: in Data.Monoid look for the newtype wrappers First and Last :)
12:35:10 <schell> ooh cool! i will check it out now
12:35:29 <monochrom> read Last's doc first. First's doc is written indirectly
12:35:41 <monochrom> err, maybe not
12:35:46 <schell> lol - that’s a funny statement
12:36:06 <schell> “read Last’s doc first, an First’s doc last”
12:37:01 <monochrom> then again, your Monoid instance for Binary is what Last does, so it's still good to read it first
12:47:06 <schell> monochrom: thanks! that’s what i was looking for
12:49:21 <monochrom> :)
13:09:08 <tsahyt> Why is there no Functor instance for Set?
13:09:20 <tsahyt> There's Data.Set.map after all
13:09:21 <bitemyapp> glguy: all yours
13:10:24 <cocreature> tsahyt: because it would require an Ord constraint which contradicts the definition of the functor type class
13:11:00 <tsahyt> Oh right, okay
13:12:01 <c_wraith> tsahyt: did you ever come to a conclusion on the typed atom thing? 
13:13:18 <bitemyapp> cocreature: how often do people take that as an answer and leave it at that?
13:13:35 <cocreature> bitemyapp: no idea?
13:14:16 <bitemyapp> cocreature: t'was efficient :)
13:14:27 <c_wraith> bitemyapp: probably helps when they're already playing with advanced type uses, so understand all the issues. :) 
13:15:03 <tsahyt> c_wraith: I tried the existential version and quickly ran into a lot of ugliness. So I ended up using newtype AtomicConcept = ... and an Atom AtomicConcept constructor in the AST type. That's the simple Haskell98 solution, but it doesn't allow for some constraints that I may or may not need at some point
13:16:09 <c_wraith> tsahyt: yeah, it's doable, but really ugly. Not sure if there are cases where it's a win in haskell. 
13:16:37 <tsahyt> In the process I also lost Universal and Bottom as atomic concepts, but that's not much of an issue. Sometimes the additional complexity isn't really worth the additional type safety
13:17:20 <bitemyapp> c_wraith: yeah, also prerequisites.
13:17:23 <bitemyapp> er, always*
13:17:56 <tsahyt> If I was dealing with a less expressive kind of description logic, I'd have much more use for differentiating between atomic and non-atomic concepts. For example, I could restrict negation to negating atoms. The GADT version is great for that, but it's a pain everywhere else.
13:21:38 * hackagebot fltkhs 0.2.0.0 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.2.0.0 (deech)
13:42:26 <samgd> Using the alex package (https://hackage.haskell.org/package/alex) - some of the source contains tabs and it's causing ghc to spam warnings during compilation
13:42:37 <samgd> Is this a case for emailing the maintainer?
13:43:07 <johnw> samgd:  I think so
13:43:54 <samgd> Okay, just thought I'd check first as it seems like a well used package.  Thanks
13:44:33 <johnw>  it's quite possible that with the way Alex is built these days (cabal install -j),  almost no one has seen those warnings
13:45:34 <samgd> By compilation I mean running 'alex lex.x'
13:45:50 <samgd> and then 'ghci lex.hs'
13:46:15 <johnw> ahh
13:46:17 <monochrom> it is also fairly recent that ghc began to warn about tabs
13:46:36 <johnw> yeah, definitely left the Alex maintainer  know
13:46:39 <marchelzo> Why is something like '7a' not a syntax error? It gives me a type error in GHCi. What is it parsing that as?
13:46:39 * hackagebot fltkhs-fluid-examples 0.0.0.1 - Fltkhs Fluid Examples  https://hackage.haskell.org/package/fltkhs-fluid-examples-0.0.0.1 (deech)
13:46:56 <samgd> Will do.  Cheers johnw
13:47:03 <tulcod> :t 7a
13:47:03 <jle`> marchelzo: i suspect it's being parsed as 7 a
13:47:04 <lambdabot> Num (Expr -> t) => t
13:47:13 <johnw> marchelzo:  that depends on the context in which you're using it
13:47:36 <Cale> In the case of tabs, you'd probably want to fix that because it doesn't really affect the code much, but in general, there are things GHC will warn about with -Wall that you might reasonably not want to fix for style reasons.
13:48:20 <marchelzo> @info Expr
13:48:21 <lambdabot> Expr
13:48:38 <johnw> I use -Wall because some of its warnings I really like (such as partial case matching) but I'm too lazy to look up how to enable that one specific warning on its own
13:48:50 <Cale> yeah, I think a lot of people are the same way
13:49:00 <Cale> e.g. it will warn about discarded results, while doing anything about those warnings will make your code more awkward for no reason
13:49:08 <johnw> true
13:49:15 <johnw> I have a lot of _ <- foo because of it
13:49:31 <marchelzo> I ran into that a lot when using Parsec
13:49:31 <Cale> I refuse to do that :P
13:49:49 <jle`> _ <- foo feels normal and not awkward to me :|
13:49:50 <johnw> it does nicely make it clear that I meant to ignore the result
13:49:56 <jle`> it sends a message
13:50:01 <tsahyt> I either use _ <- foo or suppress the warnings for this particular module if I discard a lot of things on purpose there
13:50:25 <tsahyt> Putting _'s everywhere reminds me too much of Prolog otherwise
13:51:50 * hackagebot diagrams-lib 1.3.0.7 - Embedded domain-specific language for declarative graphics  https://hackage.haskell.org/package/diagrams-lib-1.3.0.7 (BrentYorgey)
13:52:07 <monochrom> the only message I read from "_ <- foo" is: foo's type is M X where X is not ()
13:52:28 <johnw> monochrom: _messageToMonochrom_valueBeingIgnoredHere <- foo
13:52:38 <monochrom> <sarcasm> great. X is not (). that's really many bits of information. </sarcasm>
13:52:55 <johnw> it could be (), couldn't it?
13:52:58 <monochrom> look, I have better ways to find out foo's type than "_ <- foo"
13:53:18 <tsahyt> It also tells you that foo is invoked only for its side effects
13:53:30 <monochrom> no, I have just tested. do { getLine; putStrLn "xyz" }.  warning for getLine, but not putStrLn
13:53:34 <johnw> I mean, technically _ <- foo has zero bits of information, except "this isn't the last line in the do block"
13:53:52 <monochrom> oh, last line. let me try again.
13:53:59 <Cale> If you write  do { foo; ... } then you already know that foo is invoked only for its effects.
13:54:10 <johnw> true
13:54:13 <tsahyt> Yes, but it also produces an annoying warning
13:54:17 <johnw> wow, what a fascinating bikeshed this is
13:54:34 <johnw> I think wars must start over the least significant possible details
13:54:44 <monochrom> ok, do { getLine; putStrLn "xyz"; return () }.  still only warns of getLine.
13:55:07 <johnw> yeah, () <- is a complete no-op
13:56:03 <jle`> even if there was no warning, i would still do getLine -- _ <-
13:56:11 <c_wraith> johnw: technically, it isn't. It forces evaluation. 
13:56:17 <jle`> just so i know that i'm ignoring it
13:56:22 <johnw> ohh, good one c_wraith 
13:59:20 <lpaste> monochrom pasted “an inconsistently, religiously, politically-correctly thought out warning” at http://lpaste.net/142600
13:59:32 <c_wraith> For the rare cases when evaluating a particular () happens to trigger all kinds of IO. 
13:59:43 <johnw> haha
14:00:34 <monochrom> there is no way to defend this one now
14:02:06 <c_wraith> unsafeInterleaveIO (print ()) 
14:02:09 <monochrom> let me add this to the MRP thread on haskell-cafe so everyone can enjoy!
14:03:35 <marchelzo> while we're discussing style and do-notation, is it ever acceptable to write `do { a <- readLn; b <- return (f c); g (a + b) }` instead of `do { a <- readLn; let b = f c; g (a + b) }`? I don't like mixing let and <- for variable binding. I think it's ugly.
14:03:37 <johnw> monochrom: lol
14:04:03 <johnw> marchelzo: acceptability depends on who will read your code
14:04:27 <marchelzo> Well, yeah; but I'm just wondering what most people would say.
14:04:55 <johnw> heh
14:04:58 <johnw> "most people"
14:05:05 <johnw> if you ever figure out how to poll that group, I'd love to know
14:05:13 <tsahyt> Speaking as most people (TM), I use let bindings for that
14:05:20 <johnw> I would use let also
14:05:20 <arkeet> imo it's never acceptable to write b <- return (...)
14:05:30 <c_wraith> marchelzo: I'm strongly on the side of using the least power possible. That means let over <- whenever possible. 
14:05:37 <johnw> there you go, unanimous consensus
14:05:48 <jle`> i sometimes do
14:05:48 <c_wraith> 2 out of 2!
14:05:51 <jle`> _ <- return ...
14:06:20 <jle`> i get paid by the line
14:06:35 <c_wraith> jle`: I can't think of even unsafe cases where that will do something. 
14:06:45 <c_wraith> Other than increase your pay. 
14:07:11 <marchelzo> _ <- return <$> getLine
14:07:16 <johnw> () <- return ()  -- placeholder so I can put a comment here
14:07:44 <ChristianS> jle`: paid by the line, really? that's the worst payment model i ever heard of.
14:07:55 <c_wraith> marchelzo: OK, yeah, I was assuming return was the top level. 
14:08:13 <marchelzo> c_wraith: I know; I was just being a smart ass.
14:09:50 <et8> paid by line... write COBOL for prosperity
14:09:51 <monochrom> @type return <$> getLine
14:09:52 <lambdabot> Monad m => IO (m String)
14:10:20 <monochrom> that is somewhat deep
14:10:35 <jle`> well, one layer deeper than IO, at least
14:11:29 <c_wraith> Does that make mfix inception? 
14:11:51 * hackagebot repa-linear-algebra 0.2.0.0 - HMatrix operations for Repa.  https://hackage.haskell.org/package/repa-linear-algebra-0.2.0.0 (mjmrotek)
14:13:20 <umib0zu> does anyone have a better explanation about dependency management using cabal? I’ve read the docs and I don’t understand a lot of the distribution requirements, what the heck build actually does, or what “freeze” does.
14:13:56 <umib0zu> what’s the difference between cabal building and just using ghc —make on the main file?
14:18:43 <Jeanne-Kamikaze> a cabal file allows you to list multiple projects, dependencies with other packages, C source files and a bunch of other things, all of which are handled by the cabal-install tool (modulo dependency hell and what not)
14:21:29 <hexagoxel> umib0zu: firstly: you can `cabal build -v` to see what cabal does behind the scenes.
14:22:58 <umib0zu> That would be excessive. I don’t know how to do the things cabal does, or why it does them in the first place. Last thing I need is to grok stdouts.
14:23:20 <hexagoxel> umib0zu: the "main part" of `cabal build` indeed is the call to ghc. the most important advantage is that `cabal build` will apply all the settings defined in the package.cabal (or that you defined by `configure`ing
14:23:46 <umib0zu> so build will make executables, object code, and link code?
14:23:57 <hexagoxel> e.g. that your source directory is `src`, not `.`.
14:26:07 <hexagoxel> umib0zu: yes.
14:27:38 <hexagoxel> (also, when having multiple components (e.g. the typical case of library+executable) `cabal build` makes the compiled library available to the executable build)
14:31:55 <umib0zu> ok I think I got it now
14:32:44 <umib0zu> Only took 15 tries to realise “build-depends” in the cabal build description is where 90% of the work I have to do is.
14:35:22 <hexagoxel> umib0zu: that paragraph may enlighten you further :) https://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#install
14:44:17 <ttt_fff> wtf is the ":|" in https://hackage.haskell.org/package/semigroups-0.17.0.1/docs/src/Data-List-NonEmpty.html#NonEmpty ?
14:44:21 <ttt_fff> is it something similar to ":"
14:44:25 <ttt_fff> or is it a constructor ?
14:44:43 <cocreature> it's a constructor
14:44:51 <cocreature> but (:) is too, so it's similar
14:45:08 <cocreature> it takes an a and an [a] and gives you back a NonEmpty a
14:45:31 <ttt_fff> okay
14:45:37 <ttt_fff> so it's just (a, [a])
14:45:41 <ttt_fff> and thus it's a NON EMPTY list
14:45:43 <cocreature> isomorphic to that yes
14:49:34 <hexagoxel> ttt_fff: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/data-type-extensions.html#infix-tycons
14:58:51 <pilne> i think... that I am way too early in my journey to even give a hoot about boxed vs. unboxed, but I at least want to understand the difference, lol (not the when/how/why to use one, just what makes them different)
15:01:36 <pnutus> pilne: boxed: we store a pointer to each piece of data. unboxed: we store the actual data in place. In C, this would be the difference between "int* boxed[]" and "int unboxed[]"
15:02:08 <danza> oh, boxed is a funny name then
15:02:15 <danza> i would call that referenced :)
15:02:27 <pilne> so, unboxed takes up more stack, but boxed takes longer to retrieve off the heap?
15:02:42 <pnutus> At least that's my understanding. There might be other differences as well. I'll let someone more knowledgable correct me if I'm off.
15:03:15 <pnutus> boxed only works for types of fixed size in memory, I think
15:03:51 <pnutus> so they're there to avoid pointer chasing in perf sensitive code
15:04:13 <danza> pnutus, so maybe it is the reverse of what you said?
15:04:36 <danza> boxed has the data directly? this way it needs fixed size
15:05:04 <pnutus> oh sorry, no I misspoke. I'm pretty sure unboxed is the one that's pure data, no pointer
15:05:19 <pilne> ahhh
15:05:20 <mutantmell> Unboxed is a direct refernce -- there's no "box" around it
15:05:35 <pilne> same concept, just flipped definitions though (:
15:05:50 <mutantmell> From the docs: "Most types in GHC are boxed, which means that values of that type are represented by a pointer to a heap object. The representation of a Haskell Int, for example, is a two-word heap object. An unboxed type, however, is represented by the value itself, no pointers or heap allocation are involved."
15:06:45 <danza> cool
15:06:52 <pnutus> Seems to agree with my initial statement. Sorry if I confused you there :)
15:06:56 <mutantmell> Kmett had a fun talk about using unboxed values to make more efficient linked lists
15:08:09 <mutantmell> And there's an ongoing discussion about "Unlifted" data types (i.e. unboxed values)
15:08:12 <mutantmell> https://ghc.haskell.org/trac/ghc/wiki/UnliftedDataTypes
15:08:24 <danza> since we are talking about this ... boxed values might as well still need to be evaluated, right?
15:08:32 <mutantmell> danza: correct
15:08:39 <danza> B)
15:08:40 <mutantmell> danza: It could be evaluated, it could be a thunk
15:08:46 <mutantmell> danza: It could be bottom!
15:09:02 <mutantmell> One reason people want unlifted types is because they're always evaluated nad never bottom
15:09:24 <danza> oh man, and now unlifted comes into play ...
15:10:58 <danza> mutantmell, but bottom is a type, right? why could it be a value?
15:18:41 <jmct> danza: bottom is not a type, it's a value that inhabits all* types
15:18:52 <jmct> *: except unlifted types ;)
15:19:21 <jmct> think of it this way: you have a lazy Integer, it can be any Integer, or it could be non-terminating
15:19:44 <jmct> that's a distinction of its _value_, but its type is Integer either way
15:20:37 <KaneTW> there's the bottom type, a type whose only inhabitant is bottom
15:20:47 <KaneTW> @src Void
15:20:47 <lambdabot> Source not found. Just what do you think you're doing Dave?
15:21:09 <KaneTW> basically just data Void with no constructors
15:23:04 <Hijiri> I have an FFI question: what happense if you hand a haskell function as a callback to something that's going to run it in the background? Can all unsafe calls from that point on potentially crash due to the background things trying to enter haskell code?
15:23:16 <Hijiri> I think I might be running into something like this with the portaudio package
15:24:20 <Hijiri> and is there any way to avoid the errors while still giving a haskell callback
15:25:00 <JamesJRH> 14:49:34 < happy0> JamesJRH: aww =<  ← Maybe you could go next year. Where are you from?
15:25:11 * JamesJRH is very tired now.
15:26:40 <djang0nub> hi. i am exploring fp. am i right in saying that a Trie is a Tree[A] where A is a monoid?
15:27:00 <djang0nub> so the prefix at a node can be considered to be the sum of the values of the nodes on the path
15:28:07 <JamesJRH> 14:49:56 < happy0> were you traveling to get there?  ← Yes, I always have to travel on the order of 100km upwards for anything to do with Haskell or NixOS. I live in rural Shrewsbury, Shropshire. I'm probably currently the only Haskell user in Shropshire, though I'd be very glad to be proven wrong!
15:28:36 <mutantmell> :t undefined
15:28:37 <lambdabot> t
15:29:02 <mutantmell> :t undefined :: Either Int (State () (Maybe String))
15:29:03 <lambdabot> Either Int (State () (Maybe String))
15:29:23 <mutantmell> danza: bottom (aka undefined) inhabits all types
15:30:30 <mutantmell> danza: except for unlifted, like jmct said
15:31:19 <mutantmell> :)
15:33:01 <cmccann> JamesJRH: 100km UP? Isn't that, like... in outer space? :]
15:38:27 <JamesJRH> happy0: It's about 250km between Shrewsbury and London, and the journey took me just over 4 hours, the last hour of which was cycling from Euston station to London Docklands Travelodge (recorded as 12km), with a bit of getting lost along the way (I'm not used to cities).
15:38:36 <JamesJRH> cmccann: Hahaha! LOL! :-D
15:39:48 <JamesJRH> cmccann: Yeah, I think that 100km is the official boundary between aerospace and astrospace or whatever they call it.
15:40:01 <JamesJRH> Is that right?
15:40:13 <cmccann> apparently!
15:40:33 <cmccann> though being American this "kilometer" notion frightens and confuses me
15:40:58 <JamesJRH> Yep: https://en.wikipedia.org/wiki/K%C3%A1rm%C3%A1n_line
15:41:05 <JamesJRH> Heh.
15:42:06 <JamesJRH> I'm British. Roadsigns show miles and don't even show kilometres as well, yet.
15:43:24 <JamesJRH> But I prefer kilometres because conversion between metric and imperial is just as hard as converting between imperial and imperial. :-D It's kind of a no-brainer to use metric. :-)
15:44:18 <cmccann> yeah, you would think :T
15:44:19 <djang0nub> are you calling americans no-brainers?
15:45:17 <JamesJRH> And a yard is pretty close to a metre, so when road signs show yards it's easier to think in kilometres than miles.
15:45:55 <JamesJRH> djang0nub: No. I wouldn't make any such generalisation based on nationality.
15:46:17 <djang0nub> i was just kidding
15:46:18 <djang0nub> nvm
15:46:54 * hackagebot transient 0.1.0.8 - A monad for extensible effects and primitives for unrestricted composability of applications  https://hackage.haskell.org/package/transient-0.1.0.8 (AlbertoCorona)
15:47:42 <JamesJRH> Anyway, another day of Haskell Exchange tomorrow. Today was really good.
15:53:00 <JamesJRH> djang0nub: Actually, if anything, I'm implying that metric users like me are no-brainers. If I was much faster and error-free at arithmetic then I wouldn't care what units. :-)
15:53:02 <hodapp> Haskell Exchange?
15:53:15 * JamesJRH is slow at mental arithmetic.
15:53:43 <djang0nub> heh :p
15:53:50 <JamesJRH> hodapp: It's a conference, currently happening in London.
15:53:55 <hodapp> oooh
15:55:56 <JamesJRH> Actually, I'm slow at most things, let alone arithmetic. :-( But I'm particularly slow at arithmetic. That's one reason that I like programming – let the computer do the number crunching.
15:56:08 <steshaw> recommendations for a pretty print library for AST->source? I'm looking at mainland
15:56:35 <JamesJRH> I'd love to have a GHCi interpreter on my Android phone.
15:56:41 <djang0nub> JamesJRH: the more math i learn, the slower i get at arithmetic
15:56:49 <JamesJRH> LOL!
15:56:57 <JamesJRH> Heh, it's true.
15:57:51 <JamesJRH> The more information I learn, the slower I get at retrieving it. I must have a really bad indexing algorithm built-in to my brain. :-/
15:57:58 <ttt_fff> :t foldl
15:57:59 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
15:58:02 <ttt_fff> :t foldl'
15:58:04 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
15:59:51 * JamesJRH wonders what it would be like to have a (fast) GHCi interpreter built-in to my brain… :-)
16:00:20 <Welkin> :t ClassyPrelude.foldr
16:00:22 <lambdabot> Not in scope: ‘ClassyPrelude.foldr’
16:00:27 <Welkin> foldr :: MonoFoldable c => (Element c -> b -> b) -> b -> c -> b 
16:00:32 <mutantmell>  JamesJRH: sum [1..] :)
16:00:40 <Welkin> I have started using ClassyPrelude a lot lately
16:00:41 <JamesJRH> Hahaha!
16:00:42 <Welkin> it is great
16:01:13 <JamesJRH> mutantmell: Good job I know about ^C. :-)
16:01:42 <Welkin> lol
16:01:53 <Welkin> the Haskell Exchange sounds like something in London
16:01:57 <Welkin> it sounds like a financial market
16:02:47 <JamesJRH> Yes, it's in London, I'm not sure why it's called ‘Exchange’, though.
16:02:57 <mutantmell> Welkin: It's a nice Prelude -- I wish a lot of it was in the standard one
16:03:54 <JamesJRH> (Actually stylised as ‘eXchange’, but I can't be bothered with that. :-P )
16:05:19 <JamesJRH> Hmm, noöne joined #HaskellX. I'm currently the only one in there.
16:05:38 <montanonic> Which book would y'all think is more appropriate to read first: Birds' Pearl's of alogrithm design, or Okasaki's purely functional data structures?
16:07:56 <JamesJRH> Maybe I should ask a Twitter user to tweet on the #HaskellX hashtag (advertised on the programme) that IRC users can join Freenode/#HaskellX.
16:08:05 <Welkin> montanonic: why not both?
16:10:17 <mutantmell> montanonic: I haven't read either, but they're pretty different books.
16:10:25 <mutantmell> montanonic: anything in particular you wnat to learn?
16:10:46 <Ankhers> Is there a way for cabal to regenerate its global config file?
16:10:52 <Ankhers> I don't believe I have ever edited it manually, but I am getting "unrecognized field haddock" whenever I run a cabal command.
16:12:52 <Welkin> Okasaki's book is amazing
16:13:04 <hpc> yeah it is
16:13:04 <Hijiri> I think ZNC dropped some of my messages, did I miss any replies to my FFI question earlier
16:15:21 <pavonia> Hijiri: As far as I can see, no
16:17:22 <Hijiri> pavonia: thanks
16:19:15 <Hijiri> I'm not getting the issues when compiling with threaded runtime
16:19:30 <Hijiri> that works for just getting it to work, I guess
16:37:49 <trubert1> When the GHC docs talks about the benefits of the INLINE pragma here: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/pragmas.html#inline-pragma
16:38:09 <trubert1> When it says " thus avoiding the call overhead", what does it mean by that?
16:38:35 <trubert1> Does Haskell have a call stack just like C has a call stack? I.e. a stack frame for each called function?
16:38:38 <montanonic> Welkin, mutantmell: sorry, missed the replies. I plan on both, but I was just wondering which one would be an easier start / lead better into reading the other afterwards. What I want to learn is precisely the contents of the books: algorithms and data structures.
16:38:52 <trubert1> If a haskell function called another function, is a new frame created on the stack?
16:38:52 <arkeet> ghc has a stack, but not a call stack
16:39:04 <arkeet> it's an evaluation stack
16:39:12 <arkeet> ("call stack" doesn't really make sense with lazy evaluation)
16:39:22 <trubert1> So what are the "call overheads" that the GHC docs talk about?
16:39:40 <arkeet> well, there are still calls.
16:39:53 <trubert1> But what is the cost of a call?
16:40:07 <trubert1> What is taking the clock cycles to make a call?
16:40:43 <bob_twinkles> figure out where the code is, figure out if we have evaluated already, determine what needs too be evaluated before we can evaluate the requested value
16:41:10 <bob_twinkles> probably more stuff I don't know
16:41:32 <hpc> iirc the function itself doesn't ever need to be evaluated, which simplifies it a bit
16:41:37 <hpc> because of lambda lifting
16:49:51 <ams034> Hello. Haskell beginner here; was wondering if I could ask for some help about haskell-mode on emacs.
16:50:32 <hpc> if it's a legitimate question the internet has ways of shutting it down :P
16:50:47 <Cale> heh
16:50:53 <Cale> ams034: Ask away
16:51:10 <ams034> Thanks! 
16:51:29 <Cale> (I don't know much about haskell-mode on emacs myself, but there are enough people here that someone will hopefully know)
16:51:49 <johnw> people in #haskell-emacs should know
16:51:50 <ams034> I installed haskell-mode for emacs, and I opened up the interpreter. I see the lambda sign, and I tried to do 1+1 just to see if it works. However, if I hit return, nothing happens
16:52:02 <ams034> Ah, sorry, didn't know that existed.
16:52:17 <Welkin> ams034: hit Ctrl + j 
16:52:26 <Welkin> you may have electric-indent mode disabled
16:52:51 <Welkin> er wait, disregard that
16:52:55 <Welkin> I am talking about something else
16:53:35 <ams034> Ok
16:54:00 <Welkin> also, how did you install haskell-mode?
16:54:07 <Welkin> through the emacs package manager?
16:54:14 <ams034> Yes. 
16:54:17 <Welkin> okay
16:54:31 <ams034> I don't know if it matters, but I recently upgraded to OSX El Capitan, and had to re-install Haskell
16:54:39 <Welkin> emacs 24.5?
16:54:47 <ams034> but I didn't re-install my emacs, and had already installed haskell-mode before haskell re-installation
16:54:55 <ams034> Yeah, 24.5
16:55:03 <Welkin> that shou;dn't make a difference
16:55:15 <Welkin> you mean you cannot hit RET?
16:55:16 <ams034> Oh, sorry, 24.4
16:55:21 <ams034> Yeah
16:55:28 <Welkin> inside of ghci running in emacs?
16:56:00 <Welkin> I run my repl in a different window, but it shouldn't make a difference
16:56:20 <Welkin> ams034: do you get any errors at the bottom of the screen?
16:56:25 <ams034> Do you mean running ghci in terminal?
16:56:26 <Welkin> "Illegal token: ..."?
16:56:30 <Welkin> ams034: yeah
16:56:52 <ams034> running ghci in terminal works fine
16:57:05 <ams034> I don't have the error above
16:57:27 <ams034> In my message log, I do have an error that states "Error running timer..."
16:57:34 <Welkin> oh well this shouldn't have anything to do with haskell-mode
16:57:39 <Welkin> it sounds like an emacs problem
16:57:44 <ams034> Ah, 
16:57:48 <Welkin> because if you are running ghci, it should be in shell-mode
16:57:49 <Welkin> right
16:57:50 <Welkin> ?
16:57:55 <ams034> Yes, that's right
17:02:19 <Welkin> hmm
17:02:23 <Welkin> there is interactive-haskell-mode
17:02:26 <Welkin> I wasn't aware of that
17:20:02 <slack1256> Guys, is there something like gofmt but for us?
17:21:10 <nkpart> slack1256: https://github.com/chrisdone/hindent perhaps
17:21:50 <slack1256> !!
17:22:18 <slack1256> thank nkartas. That fits the bill aparently!
17:24:20 <jellie> Anyone know how I can fix this buildplan issue with stack in haskell https://travis-ci.org/urbanslug/wai-devel/jobs/84337485
17:27:54 <Welkin> jellie: update your <project>.cabal with the new build-depends
17:28:07 <Welkin> loosen the upper bound on base to <5.0
17:28:51 <jellie> Welkin: Thanks
17:30:11 <Welkin> you may also need to update your stack.yaml
17:30:42 <Welkin> oh
17:30:43 <Welkin>  base: needed (>=4.8 && <5), latest is 4.8.1.0, but 4.7.0.2 found
17:30:52 <Welkin> you have a version of base that is too old
17:30:57 <Welkin> usea newer ghc
17:32:20 <jellie> Welkin: That is a test for GHC-7.8
17:32:30 <jellie> On travis
17:32:54 <Welkin> 7.8.4?
17:33:06 <Welkin> well, it is telling you that the version of base is too old
17:33:56 <Welkin> what is wai-devel anyway?
17:34:09 <Welkin> is it your project?
17:34:15 <Welkin> I don't see it on hackage
17:34:24 <Welkin> you could loosen the lower bound on base in your .cabal
17:34:30 <Welkin> unless there is a reason not to
17:34:41 <jellie> Welkin: Should be on hackage soon. Yes it's my project.
17:35:16 <jellie> Welkin: There's no reason not to. Let me see uh README.
17:35:29 <jellie> It's a server thingie :)
17:53:52 <jellie> Welkin: Weird even after specifying a specific version of base in the stack.yaml file I still get a failure https://github.com/urbanslug/wai-devel/blob/master/stack-7.8.yaml#L4
17:54:36 <jellie> Welkin: and the version of base here: https://github.com/urbanslug/wai-devel/blob/master/wai-devel.cabal#L32
17:55:00 <jellie> The error is still https://travis-ci.org/urbanslug/wai-devel/jobs/84421011#L165
18:03:28 <orion> Does anyone know why this code fails to compile? The error I get is: "No instance for (MonadState t0 (DescriptorT c d IO)) arising from a use of ‘get’In a stmt of a 'do' block: hs <- get" http://lpaste.net/4934719605500280832
18:03:43 <orion> If I remove line 17, it works.
18:05:21 <Gurkenglas> orion, use DerivingNewtypes and add "MonadState" or "MonadState (FooState c d)" or something along those lines to the stuff in the deriving clause?
18:05:59 <Gurkenglas> DescriptorT doesn't have the MonadState instance StateT provides, but deriving instances for newtypes from what they wrap is trivial and therefore automated.
18:06:13 <orion> Oh! Interesting.
18:06:33 <Gurkenglas> (Why not use type instead of newtype?)
18:07:16 <Gurkenglas> (All that StateT defines would be trivially usable for DescripterT, and you wouldn't need to do any wrapping/unwrapping)
18:08:12 <orion> Gurkenglas: I'm still getting my feet wet with transformer stacks, which is why I'm not using type. :)
18:08:53 <orion> Actually, the deriving statement doesn't work for type
18:09:43 <arkeet> can't you just add MonadState to the deriving list?
18:09:51 <Welkin> type synonyms are only useful for simplifying the type signature for a transformer stack
18:10:36 <orion> arkeet: Yes, you're right, but as Gurkenglas pointed out, I can just use "type" instead of "newtype".
18:10:43 <orion> (Which I just got working)
18:11:07 <arkeet>   deriving (Functor, Applicative, Monad, MonadState (FooState c d))
18:11:11 <Welkin> type Handler a = HandlerT site IO a
18:11:36 <arkeet> sure, a type synonym is probably fine too.
18:13:08 <Welkin> oh, Reader is a better example
18:14:59 <arkeet> and then you dont' need to reimplement all the StateT combinators (execStateT etc)
18:16:07 <Welkin> yeah
18:16:14 <Welkin> the transformers library feel almost magic
18:16:22 <Welkin> becuase of the typeclasses
18:26:55 <johnw> typeclasses?  you mean mtl?
18:26:57 <mutantmell> dc
18:31:17 <infandum> How do I handle end of input in attoparsec? If I do parseTest (takeWhile1 (== 'a')) "aaa", it returns Partial _, but if I do parseTest (takeWhile1 (== 'a')) "aaa\n", it works. How do I write parsers that might hit the end of the input?
18:32:38 <arkeet> use parseOnly?
18:32:45 <arkeet> or
18:32:49 <arkeet> put endOfInput on the end of the parser
18:33:02 <arkeet> yeah never mind about using parseOnly.
18:34:49 <pavonia> infandum: attoparsec has a parser endOfInput that matches the end of input
18:35:33 <pavonia> Ah, arkeet already mentioned that :S
18:37:12 <infandum> pavonia, arkeet: Like parseTest (do { y <- takeWhile1 (== 'a'); endOfInput; return y } "aaa"? That doesn't work for me, I still get a partial
18:37:22 <arkeet> maybe you do need parseOnly then.
18:37:57 <infandum> that does work.
18:39:38 <infandum> arkeet: What if I need parseOnly (manyTill (char 'a') (char 'x')) "aaa"?
18:39:44 <infandum> It won't work then
18:39:57 <infandum> hmmm, unless I do takeWhile there too...
18:40:09 <infandum> ah, but I do need many unfortunately
18:40:35 <infandum> "aaax" works, but "aaa" does not
18:40:47 <arkeet> is that not expected?
18:40:52 <infandum> the error is: Left "'a': not enough input"
18:40:57 <infandum> yes, but how can I get around it?
18:41:02 <arkeet> what are you trying to parse?
18:41:11 <arkeet> manyTill x y will match many x's followed by a single y
18:41:20 <infandum> I want something like manyTill something (char 'x' <|> endOfInput) but that won't typecheck
18:41:40 <arkeet> well, why doesn't it typecheck?
18:41:51 <infandum> <|> needs both parsers to be of the same type
18:41:53 <awpr> infandum: 2 things: first, try applying 'void' to the 'char' side of that
18:42:00 <arkeet> okay, so make them the same type.
18:42:01 <arkeet> ^
18:42:05 <infandum> ?
18:42:08 <infandum> hm
18:42:10 <awpr> second: "To indicate that no more input is available, pass an empty string to the continuation."
18:42:46 <awpr> so, when it was returning Partial, that means it could do something different depending on whether there was another character available; not that it *needs* another character
18:42:53 <arkeet> correct
18:43:23 <awpr> (this is what parseOnly does -- passes an empty string automatically when it gets Partial)
18:43:40 <infandum> but that fails with manyTill...
18:43:53 <infandum> because it never sees that other character
18:43:57 <awpr> manyTill *does* need another character
18:43:59 <infandum> even with the additional empty string
18:44:21 <awpr> your intuition was right on using <|> endOfInput; you just need to stub out the result of (char 'x') with void
18:44:34 <awpr> :t Control.Monad.void
18:44:35 <lambdabot> Functor f => f a -> f ()
18:44:43 <infandum> ah! That works!
18:44:45 <infandum> the void!
18:45:02 <infandum> so it matches, but never returns anything
18:45:16 <infandum> does that mean that the character it matches is lost forever?
18:45:23 <arkeet> right, but you already "knew" what it was
18:45:26 <infandum> yeah
18:45:28 <arkeet> because you said char 'x'
18:45:36 <infandum> mhm, so can I push it back somehow?
18:45:41 <arkeet> push?
18:45:50 <infandum> wait i don't need ot haha
18:45:53 <awpr> yes, it's lost if you use void, but there are other ways to do something similar, if it's something other than (char 'x')
18:45:57 <infandum> i can just return it however i want
18:46:02 <infandum> great, thank you!!
19:32:14 * hackagebot grouped-list 0.1.0.0 - Grouped lists. Equal consecutive elements are grouped.  https://hackage.haskell.org/package/grouped-list-0.1.0.0 (DanielDiaz)
19:32:56 <jellie> Sorry, it seems I forgot but where does cabal-install install/find ghc?
19:33:16 <jellie> I have to install ghc manually from my package manager, don't I?
19:48:17 <geekosaur> zipper, or install the "raw" bindist
19:48:44 <geekosaur> (if you're on a Debian or Debian-derived system, use the bindist or hvr's PPA)
19:54:32 <codebje> any opinions on the fpcomplete job offers?
20:07:15 * hackagebot GLM 0.7.0.0 - Simple Gridlab-D GLM parser and utilities.  https://hackage.haskell.org/package/GLM-0.7.0.0 (LyndonMaydwell)
20:21:17 <nitrix> Could someone using or from the sdl2 project confirm that the `new-api` branch has been merged into `master`?
20:21:39 <nitrix> This used to be a big annoyance for me to adopt the library; it now looks much more stable.
20:22:46 <orion> To get the last n bytes of a ByteString, do I need to do: drop (length bs - n) bs, or is there an easier way?
20:23:35 <Adeon> nitrix: looks like the new-api is on hackage so yes, it would be merged
20:24:49 <nitrix> orion: Easier way: take n $ reverse bs
20:25:10 <dmj`> nitrix: don't forget to reverse again
20:25:12 <hiptobecubic> nitrix, you forgot to reverse again
20:25:44 <nitrix> He just asked for the last n bytes though. Maybe the ordering isn't important?
20:26:11 <hiptobecubic> nitrix, when has the order of bytes in a bytestring ever not mattered?
20:26:33 <hiptobecubic> I guess if you're about to fold it up
20:27:06 <awpr> works for n=1
20:27:14 <nitrix> hiptobecubic: The usage is up to him to figure out. I'm happy with answering the question pedantically.
20:27:32 <dfeuer> Would   unsafeWhatever :: Contravariant f => f a -> f Void;  unsafeWhatever = unsafeCoerce   be "safe" when applied to proper contravariant functors?
20:28:05 <awpr> I don't think that's unsafe at all?  isn't it just contramap absurd?
20:28:17 <dfeuer> awpr, well, that's the safe version.
20:28:30 <dfeuer> There's an unsafeVacuous implemented as unsafeCoerce for Functors;
20:28:41 <dfeuer> I'm wondering if the same would work for Contravariants.
20:34:35 <bitemyapp> cmccann: have fun? :P
20:35:10 <cmccann> bitemyapp: no, not really, all things considered.
20:37:16 * hackagebot quiver 1.1.0 - Quiver finite stream processing library  https://hackage.haskell.org/package/quiver-1.1.0 (patrykz)
20:59:26 <orion> nitrix: That's not the same.
20:59:51 <nitrix> orion: I'm sorry, what are we comparing?
21:00:06 <orion> 23:24:27 < nitrix> orion: Easier way: take n $ reverse bs
21:00:13 <nitrix> Compared with?
21:00:18 <orion> That's not the same as drop (length bs - n) bs
21:00:36 <nitrix> I'm aware.
21:06:22 <nitrix> orion: The requirements, as worded by yourself, was solely about getting the last n bytes of a ByteString. dmj` and hiptobecubic pointed out that you'd need to reverse it again for it to be equivalent to your suggestion.
21:07:23 <orion> ok
21:09:48 <hiptobecubic> the joys of specification
21:10:13 <rvxi> hi
21:12:35 <hiptobecubic> hi
21:30:20 <orion> How do you unwrap a value such as "Identity ByteString"?
21:30:55 <orion> Do you just use `runIdentity`?
21:34:20 <nitrix> :t runIdentity
21:34:21 <lambdabot> Identity a -> a
21:34:53 <mutantmell> > let i4 = Identity 4 in runIdentity i4
21:34:55 <lambdabot>  4
21:35:10 <mutantmell> orion: yeah, just use runIdentity
21:37:50 <mutantmell> orion: Alternatively, you can pattern match
21:50:45 <orion> mutantmell: Cool, thanks.
22:12:37 <austinprog> hi
22:14:00 <liste> hi
22:15:17 <eazar001> hi
22:15:34 <LokiSnake> hi
22:15:41 <Saizan> 3,þ'èòà
22:15:56 <Saizan> sorry.
22:17:20 * hackagebot mwc-probability 1.0.2 - Sampling function-based probability distributions.  https://hackage.haskell.org/package/mwc-probability-1.0.2 (JaredTobin)
22:23:08 * hackagebot mighty-metropolis 1.0.2 - The Metropolis algorithm.  https://hackage.haskell.org/package/mighty-metropolis-1.0.2 (JaredTobin)
22:23:10 * hackagebot speedy-slice 0.1.3 - Speedy slice sampling.  https://hackage.haskell.org/package/speedy-slice-0.1.3 (JaredTobin)
22:34:21 <guaraqe> I have a giant vector (something like 1,000,000,000 entries) and and I have to do a fold that updates it (once more, around 1,000,000,000 times), what is the fastest way to do it? Is there someway to stop the state from being copied and just change the entries?
22:36:17 <Cale> guaraqe: Use a mutable unboxed array type
22:36:54 <Cale> Perhaps Data.Vector.Unboxed.Mutable
22:37:02 <johnw> guaraqe: is your vector sparse or dense?
22:37:46 <guaraqe> johnw: it is dense, and it is not necessarily a vector, it is just ordered, I am using Sequence in this moment
22:38:09 * hackagebot hasty-hamiltonian 1.1.2 - Speedy traversal through parameter space.  https://hackage.haskell.org/package/hasty-hamiltonian-1.1.2 (JaredTobin)
22:38:19 <Cale> guaraqe: Yeah, that's not going to do at all -- well, how much RAM do you have?
22:38:27 <guaraqe> 8 gb
22:39:06 <Cale> Right, so not likely enough to store a billion pointers, let alone the actual contents of the Sequence.
22:39:59 <guaraqe> it works, it is just painfully slow because of the updating
22:40:43 <Cale> Well, it should be painfully slow because of the swapping to disk at that size...
22:41:43 <guaraqe> it keeps at 25% ram, ok
22:41:49 <Cale> huh, interesting
22:42:07 <guaraqe> after I put strictness in the good places
22:42:16 <Cale> I wonder if laziness is also working in your favour.
22:43:08 <guaraqe> freestyle code was just filling my ram in 5 seconds, I have no idea...
22:44:19 <Cale> A single pointer is 8 bytes on a 64 bit machine. Each of the entries of your (boxed) Data.Sequence structure will consist of a pointer to code, along with some other stuff.
22:44:54 <Cale> So you really ought not to be able to store them all at once in that space, but if you only need some of them at a time, it might be okay.
22:53:09 * hackagebot quiver 1.1.1 - Quiver finite stream processing library  https://hackage.haskell.org/package/quiver-1.1.1 (patrykz)
22:53:24 <guaraqe> there's space there, even if it's even barely, i'm pretty sure
22:53:50 <guaraqe> these mutalbe vectors seem good, I just have to learn how to use them
23:05:34 <lpaste> YellowOnion pasted “Network issue.” at http://lpaste.net/142618
23:05:41 <YellowOnion> Could someone give me insight on why my app runs in interpreted mode but doesn't print anything (thunk build up maybe?) and why it instantly crashes/expection when complied, 
23:06:02 <YellowOnion> Network.Socket.ByteString.send: failed (Unknown error)
23:08:10 <YellowOnion> interpreted seems to load at 100% CPU, and use about 150MB RAM too.
23:14:08 <Cale> guaraqe: I think something weird must have been going on with your Sequence structures. Just making a Data.Sequence with a billion elements of the unit type in it consumes over 15GB of memory on my machine (before getting killed).
23:14:21 <Cale> I estimate that it would take several times that amount really.
23:14:46 <Cale> Let's actually do a shorter one and try to measure the overhead :)
23:17:05 <Cale> 10^8 elements takes 2.3 GB, so 10^9 would be over 20 GB.
23:18:15 * hackagebot ihaskell-widgets 0.2.2.1 - IPython standard widgets for IHaskell.  https://hackage.haskell.org/package/ihaskell-widgets-0.2.2.1 (gibiansky)
23:24:18 <Cale> Sorry, that was 2.3 GiB, rather. It's around 2.48 * 10^9 bytes. I was a bit surprised at first that it was coming in at under the size required to store 3 pointers per element.
23:24:25 <Cale> (but it's not)
23:33:23 <jle`> i'm on the edge of my seat
23:49:34 <EvanR> im trying to iterate through an infinite 9-ary tree breadth first
23:49:41 <EvanR> is that possible with constant space
23:58:22 <jle`> yes
23:58:36 <jle`> actually, difficult to answer wihtout further details
23:59:35 <Ferdirand> i'm curious to hear the reasoning that led you to 'yes'
