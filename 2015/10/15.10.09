00:05:59 <pavonia> Positive thinking, presumably
00:07:40 * hackagebot quiver 1.1.1 - Quiver finite stream processing library  https://hackage.haskell.org/package/quiver-1.1.1 (patrykz)
00:07:40 * hackagebot ihaskell-widgets 0.2.2.1 - IPython standard widgets for IHaskell.  https://hackage.haskell.org/package/ihaskell-widgets-0.2.2.1 (gibiansky)
00:11:22 <EvanR> what you can do is keep a incrementing coordinate of where you want to traverse to next
00:11:40 <EvanR> and each time, restart the entire traversal on a newly generated version of the tree
00:12:03 <EvanR> that coordinate will have to grow, but not nearly as much as a naive implemention of the entire growing structure in haskell
00:12:50 <EvanR> assume an infinite regular structure
00:12:58 <EvanR> assuming*
00:14:34 <echo-area> Is there a function telling a character's width when displayed?
00:14:44 <echo-area> I didn't find something useful
00:14:59 <EvanR> i think it exists as a unicode property
00:15:17 <EvanR> or its a function of existing unicode properties
00:15:42 <EvanR> AOL keyword "full width"
00:16:05 <Ferdirand> EvanR: so basically, you are iterating over bounded depth-first searches ?
00:18:01 <EvanR> EvanR: you can steal this http://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c
00:18:41 <EvanR> Ferdirand: not really a search since you know where you are going, a directed traversal
00:19:26 <EvanR> echo-area: https://hackage.haskell.org/package/wcwidth \o/
00:21:22 <echo-area> EvanR: Cool, thanks. :)
00:22:13 <Ferdirand> (f <$> x) is equivalent to (pure f <*> x) for well behaved applicatives, yes ?
00:22:33 <Ferdirand> is there some fancy operator such as (f ??? x) is equivalent to (f <*> pure x) ?
00:22:43 <echo-area> And this time Hoogle beats Google
00:23:27 <cocreature> Ferdirand: to your first question: yes, to your second question, I don't think so
00:24:36 <Ferdirand> ($ x) <*> f is kind of ugly
00:24:50 <cocreature> yep
00:25:11 <cocreature> f <$> pure x is not so bad however
00:25:20 <cocreature> or just go for do notation
00:31:09 <Copperis> hi, can anyone tell me why this doesn't work? [i^2 | i <- [1..10000], odd(i^2)]
00:31:34 <Copperis> gives me a "lexical error at character '\ESC'"
00:32:07 <cocreature> works for me™
00:32:18 <cocreature> that error sounds like you have some strange character in your source
00:32:26 <kadoban> Copperis: Sounds like you have some weird non-printable character in your sourcecode.
00:32:27 <cocreature> maybe try deleting the line and type it again
00:33:01 <Copperis> oh yeah, it does work
00:33:34 <Copperis> I'm using some sort of a modified windows terminal
00:33:48 <Copperis> it doesn't work well with ghci
00:34:00 <Copperis> thanks
00:34:46 <pavonia> Maybe it's interpreting '^' as escape character
00:36:26 <Copperis> hm, don't know. After pasting and pressing return it runs. I think the terminal doesn't handle arrow keys well
00:36:28 <MarcelineVQ> quick google check of \esc saaays: The Windows command-line interpreter uses a caret character (^) to escape reserved characters that have special meanings (in particular: & | ( ) < > ^).
00:37:14 <MarcelineVQ> once you're in ghci though that shouldn't be a factor
00:37:36 * hackagebot hmatrix-gsl-stats 0.4.1.2 - GSL Statistics interface  https://hackage.haskell.org/package/hmatrix-gsl-stats-0.4.1.2 (VivianMcPhail)
00:39:05 <Copperis> MarcelineVQ, yup. minnty and git bash windows terminals don't work well with ghci. http://trac.haskell.org/haskeline/ticket/114
01:22:38 * hackagebot MagicHaskeller 0.9.6.4.1 - Automatic inductive functional programmer by systematic search  https://hackage.haskell.org/package/MagicHaskeller-0.9.6.4.1 (SusumuKatayama)
01:23:33 <happy0> JamesJRH: ooft. no wonder you were knackered =p
01:56:15 <YellowOnion> :t axisAngle
01:56:16 <lambdabot> Not in scope: ‘axisAngle’
01:57:07 <YellowOnion> Is anyone familar with Linear.Quaternion?
02:07:16 <Guest24469> 1
02:09:20 <srhb> Guest24469: 2?
02:10:16 <pnutus> YellowOnion: not familiar with the library, but maybe I can help
02:10:23 <pnutus> what do you want to accomplish?
02:11:15 <YellowOnion> pnutus, I'm trying to convert the standard yaw/pitch/roll system to a quaternion.
02:12:01 <YellowOnion> I was hoping there was a built in function for this, but I can't really see one.
02:13:22 <YellowOnion> I've got raw gyro delta's coming from my android phone, and I'm trying to convert to absolute rotation.
02:14:47 <pnutus> YellowOnion: my 2 cents: Convert each of the yaw/pitch/roll to a quaternion with axisAngle and then multiply them together. The order matters, you'd have to look that up in the documentation of the gyro API
02:15:39 <YellowOnion> pnutus, yeah I was worried about the order, I didn't think to check the documentation.
02:16:45 <pnutus> the first rotation should be the rightmost quaternion when you multiply: q3*q2*q1
02:18:58 <orion> Is it possible to parameterize the update of a record?
02:19:28 <YellowOnion> pnutus, right now I'm doing the naive implementation and it works OK, but obviously it slowly moves out of place.
02:21:54 <pnutus> YellowOnion: Seems weird that the gyro API wouldn't provide a quaternion interface
02:22:36 <YellowOnion> pnutus, I'm using a premade app that sends udp packets over the network.
02:23:37 <YellowOnion> I've actually misinterpretd the values, its a unit quaternion.
02:24:05 <pnutus> YellowOnion: oh, that should make things simpler! I hope it works out for you :)
02:24:54 <YellowOnion> Well I think they are anyway.
02:27:41 * hackagebot amazonka-core 1.3.3 - Core data types and functionality for Amazonka libraries.  https://hackage.haskell.org/package/amazonka-core-1.3.3 (BrendanHay)
02:27:43 * hackagebot amazonka 1.3.3 - Comprehensive Amazon Web Services SDK.  https://hackage.haskell.org/package/amazonka-1.3.3 (BrendanHay)
02:27:45 * hackagebot amazonka-test 1.3.3 - Common functionality for Amazonka library test-suites.  https://hackage.haskell.org/package/amazonka-test-1.3.3 (BrendanHay)
02:27:47 * hackagebot amazonka-config 1.3.3 - Amazon Config SDK.  https://hackage.haskell.org/package/amazonka-config-1.3.3 (BrendanHay)
02:34:41 <YellowOnion> pnutus, never mind, looks like it's the onboard absolute sensor data (y axis points to geomagnetic north).
02:38:49 <quicksilver> orion: \x -> foo { bar = x } 
02:38:54 <quicksilver> orion: or, I'm not sure what you're asking.
02:44:00 * hackagebot amazonka-sns 1.3.3 - Amazon Simple Notification Service SDK.  https://hackage.haskell.org/package/amazonka-sns-1.3.3 (BrendanHay)
02:44:02 * hackagebot amazonka-ecs 1.3.3 - Amazon EC2 Container Service SDK.  https://hackage.haskell.org/package/amazonka-ecs-1.3.3 (BrendanHay)
02:44:04 * hackagebot amazonka-sqs 1.3.3 - Amazon Simple Queue Service SDK.  https://hackage.haskell.org/package/amazonka-sqs-1.3.3 (BrendanHay)
02:44:06 * hackagebot amazonka-glacier 1.3.3 - Amazon Glacier SDK.  https://hackage.haskell.org/package/amazonka-glacier-1.3.3 (BrendanHay)
02:44:08 * hackagebot amazonka-cloudhsm 1.3.3 - Amazon CloudHSM SDK.  https://hackage.haskell.org/package/amazonka-cloudhsm-1.3.3 (BrendanHay)
02:49:10 * hackagebot amazonka-dynamodb 1.3.3 - Amazon DynamoDB SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-1.3.3 (BrendanHay)
02:49:12 * hackagebot amazonka-datapipeline 1.3.3 - Amazon Data Pipeline SDK.  https://hackage.haskell.org/package/amazonka-datapipeline-1.3.3 (BrendanHay)
02:49:14 * hackagebot amazonka-iam 1.3.3 - Amazon Identity and Access Management SDK.  https://hackage.haskell.org/package/amazonka-iam-1.3.3 (BrendanHay)
02:49:16 * hackagebot amazonka-kinesis-firehose 1.3.3 - Amazon Kinesis Firehose SDK.  https://hackage.haskell.org/package/amazonka-kinesis-firehose-1.3.3 (BrendanHay)
02:49:18 * hackagebot amazonka-route53-domains 1.3.3 - Amazon Route 53 Domains SDK.  https://hackage.haskell.org/package/amazonka-route53-domains-1.3.3 (BrendanHay)
02:53:22 <quicksilver> I wonder if hackagebot should delay and group multiple uploads :)
02:54:20 * hackagebot amazonka-directconnect 1.3.3 - Amazon Direct Connect SDK.  https://hackage.haskell.org/package/amazonka-directconnect-1.3.3 (BrendanHay)
02:54:22 * hackagebot amazonka-elasticsearch 1.3.3 - Amazon Elasticsearch Service SDK.  https://hackage.haskell.org/package/amazonka-elasticsearch-1.3.3 (BrendanHay)
02:54:24 * hackagebot amazonka-devicefarm 1.3.3 - Amazon Device Farm SDK.  https://hackage.haskell.org/package/amazonka-devicefarm-1.3.3 (BrendanHay)
02:54:26 * hackagebot amazonka-cognito-sync 1.3.3 - Amazon Cognito Sync SDK.  https://hackage.haskell.org/package/amazonka-cognito-sync-1.3.3 (BrendanHay)
02:54:28 * hackagebot amazonka-elb 1.3.3 - Amazon Elastic Load Balancing SDK.  https://hackage.haskell.org/package/amazonka-elb-1.3.3 (BrendanHay)
02:54:35 <MarcelineVQ> Wouldn't it be the same amount of text, you'd need to tinyurl the links to save any space and still be as informative
02:54:56 <MarcelineVQ> At least it tends to happen when convo is slow anyway
02:56:20 <quicksilver> I dunno what I'm proposing, really. "Multiple uploads by BrendanHay - amazonka-foo, amazonka-bar, .... for full list + links click lpaste.net/something" maybe?
02:57:51 <MarcelineVQ> Sounds like a good solution
02:58:08 <quicksilver> I agree it's not a very big or important problem.
02:58:20 <quicksilver> IRC is great for discussing unneeded solutions to non-problems.
02:58:57 <MarcelineVQ> I'm almost positive that's all it was ever for
02:59:30 * hackagebot amazonka-cloudformation 1.3.3 - Amazon CloudFormation SDK.  https://hackage.haskell.org/package/amazonka-cloudformation-1.3.3 (BrendanHay)
02:59:32 * hackagebot amazonka-sts 1.3.3 - Amazon Security Token Service SDK.  https://hackage.haskell.org/package/amazonka-sts-1.3.3 (BrendanHay)
02:59:34 * hackagebot amazonka-kinesis 1.3.3 - Amazon Kinesis SDK.  https://hackage.haskell.org/package/amazonka-kinesis-1.3.3 (BrendanHay)
02:59:36 * hackagebot amazonka-kms 1.3.3 - Amazon Key Management Service SDK.  https://hackage.haskell.org/package/amazonka-kms-1.3.3 (BrendanHay)
02:59:38 * hackagebot amazonka-cloudsearch-domains 1.3.3 - Amazon CloudSearch Domain SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-domains-1.3.3 (BrendanHay)
03:02:51 <tsahyt> When using pattern guards, does | someBool, someOtherBool do the same as someBool && someOtherBool?
03:03:10 <pnutus> MarcelineVQ, quicksilver: Maybe hackagebot could have just have its own channel? Doesn't seem that useful for it to post every minor update to a package on hackage here.
03:03:37 <srhb> tsahyt: nnno? Is that even valid?
03:03:52 <tsahyt> srhb: Dunno, I never used them before
03:04:04 <srhb> tsahyt: Maybe I'm wrong! I never use them, really.
03:04:25 <tsahyt> I can do | Just x <- something, Just <- somethingElse so I was wondering whether this works for bools too
03:04:32 <tsahyt> I might as well just test it actually
03:04:32 <MarcelineVQ> Pattern guards need a bind iirc
03:04:40 * hackagebot amazonka-cloudwatch 1.3.3 - Amazon CloudWatch SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-1.3.3 (BrendanHay)
03:04:42 * hackagebot amazonka-cloudtrail 1.3.3 - Amazon CloudTrail SDK.  https://hackage.haskell.org/package/amazonka-cloudtrail-1.3.3 (BrendanHay)
03:04:44 * hackagebot amazonka-elasticache 1.3.3 - Amazon ElastiCache SDK.  https://hackage.haskell.org/package/amazonka-elasticache-1.3.3 (BrendanHay)
03:04:46 * hackagebot amazonka-waf 1.3.3 - Amazon WAF SDK.  https://hackage.haskell.org/package/amazonka-waf-1.3.3 (BrendanHay)
03:04:48 * hackagebot amazonka-importexport 1.3.3 - Amazon Import/Export SDK.  https://hackage.haskell.org/package/amazonka-importexport-1.3.3 (BrendanHay)
03:04:57 <srhb> tsahyt: Yes, your first interpretation appears correct.
03:05:22 <pnutus> tsahyt: it seems like it would work. From the GHC manual: "Just as with list comprehensions, boolean expressions can be freely mixed with among the pattern guards."
03:05:28 <MarcelineVQ> neato
03:06:22 <srhb> pnutus: That's not quite the relevant bit with commas though, x, y is not generally a boolean expression
03:06:28 <tsahyt> I actually don't need the full power of pattern guards in my case, but it looks a bit nicer syntactically. I never know how to align the && over multiple lines
03:06:39 <srhb> "For each guarded expression, the comma-separated guards are tried sequentially from left to right. If all of them succeed, then the corresponding expression is evaluated in the environment extended with the bindings introduced by the guards."
03:06:48 <srhb> I think that's the relevant bit.
03:06:50 <quicksilver> pnutus: I like it in general. Package updates are not that common and it's interesting to know stuff being updated on hackage.
03:07:19 <pnutus> srhb: it does refer to boolean expressions delimited with commas, even if my quote didn't show that
03:07:30 <srhb> Ah. :)
03:07:36 <pnutus> :9
03:07:38 <pnutus> :)
03:07:42 <quicksilver> the "as with list comprehensions" phrase reinforces the commas too
03:07:51 <srhb> Yes, my mistake.
03:08:03 <pnutus> yeah, and there's an example, but I didn't wanna paste that here
03:09:05 <quicksilver> I prefer (pattern)guards when they're short enough to fit on one line, with the expression as well
03:09:21 <quicksilver> but that's probably just because I've not found a relly compelling example for bigger ones yet
03:09:41 <quicksilver> I bet I have some nested case/ifs I could rewrite and see if it looks nicer.
03:09:50 * hackagebot amazonka-s3 1.3.3 - Amazon Simple Storage Service SDK.  https://hackage.haskell.org/package/amazonka-s3-1.3.3 (BrendanHay)
03:09:52 * hackagebot amazonka-swf 1.3.3 - Amazon Simple Workflow Service SDK.  https://hackage.haskell.org/package/amazonka-swf-1.3.3 (BrendanHay)
03:09:54 * hackagebot amazonka-sdb 1.3.3 - Amazon SimpleDB SDK.  https://hackage.haskell.org/package/amazonka-sdb-1.3.3 (BrendanHay)
03:09:56 * hackagebot amazonka-codecommit 1.3.3 - Amazon CodeCommit SDK.  https://hackage.haskell.org/package/amazonka-codecommit-1.3.3 (BrendanHay)
03:09:58 * hackagebot amazonka-codedeploy 1.3.3 - Amazon CodeDeploy SDK.  https://hackage.haskell.org/package/amazonka-codedeploy-1.3.3 (BrendanHay)
03:10:17 <pnutus> quicksilver: Yeah, my thought was just that if there's a #hackage channel, people interested could join, and ppl who don't really care don't have to :)
03:10:37 <quicksilver> pnutus: then again people who are bothered can /ignore hackagebot 
03:10:37 <tsahyt> Checking whether something is a member in a set and inserting it if it's not is probably slower than just trying the insert without the check first, right?
03:10:48 <pnutus> quicksilver: yeah
03:10:58 <quicksilver> tsahyt: there is a general principle there I think
03:11:05 <ocramz> hi all
03:11:26 <quicksilver> tsahyt: but yes, check then insert has to find the location it sits (or would sit) twice
03:11:51 <tsahyt> That's what I was thinking. I can scrap the guard altogether then
03:12:18 <pnutus> all this talk for naught! D: ;)
03:13:07 <quicksilver> tsahyt: hmm although Set.insert will actually replace the element even if it's not there
03:13:13 <quicksilver> so it's not *completely* obvious
03:13:16 <quicksilver> even if it *is* there I mean
03:13:51 <quicksilver> I would expect that to be faster but it does unecessarily re-stitch the tree back together
03:14:16 <quicksilver> criterion to the rescue, if you actually care
03:14:31 <tsahyt> I may care, but right now this smells of premature optimization
03:15:00 * hackagebot amazonka-cloudfront 1.3.3 - Amazon CloudFront SDK.  https://hackage.haskell.org/package/amazonka-cloudfront-1.3.3 (BrendanHay)
03:15:02 * hackagebot amazonka-efs 1.3.3 - Amazon Elastic File System SDK.  https://hackage.haskell.org/package/amazonka-efs-1.3.3 (BrendanHay)
03:15:04 * hackagebot amazonka-codepipeline 1.3.3 - Amazon CodePipeline SDK.  https://hackage.haskell.org/package/amazonka-codepipeline-1.3.3 (BrendanHay)
03:15:05 <tsahyt> 2 log(n) < log(n). That's a good enough guide for now.
03:15:06 * hackagebot amazonka-elasticbeanstalk 1.3.3 - Amazon Elastic Beanstalk SDK.  https://hackage.haskell.org/package/amazonka-elasticbeanstalk-1.3.3 (BrendanHay)
03:15:24 <tsahyt> No wait, other way round
03:15:37 <quicksilver> tsahyt: you mean k log (n) + j log (n) might be more than m log (n)
03:15:41 <quicksilver> for unknown k j and m :)
03:16:14 <quicksilver> also it depends how often the key is already there!
03:16:22 <quicksilver> but probably none of this matters.
03:16:40 <tsahyt> Well I'd hope it's there at most once, otherwise I'd have a multiset
03:17:13 <quicksilver> tsahyt: sorry, I mean, over all the invocations of this chunk of code, how often would it be absent and how often would it be present
03:17:26 <quicksilver> tsahyt: because if it is often absent then the pre-flight check is clearly a waste of time
03:36:05 <JamesJRH> happy0: The travelling is not nearly as tiring as sleep deprivation and stress – I'd not slept on Tuesday night due to anxiety and trying to finish-off a couple of things before the conference, and on Wednesday, a family member died. ;_;
03:37:00 <happy0> JamesJRH: god... sorry that you've had such a rough week :<
03:37:11 <JamesJRH> happy0: I looked in the mirror this morning and noticed that I have quite a few grey hairs yet I'm only 24! (That's not a factorial. :-P )
03:37:15 <JamesJRH> Thanks.
03:37:27 <happy0> haha :D
03:37:51 <happy0> as an aside, you mentioned that you'd like an ghci for android
03:38:05 <JamesJRH> Yeah, offline though.
03:38:06 <happy0> a useful alternative would be to get an android IRC client and just message the haskell bot in here
03:38:09 <happy0> oh
03:38:15 <JamesJRH> I've seen TryHaskell.
03:38:15 <happy0> in that case, i have no suggestions :P
03:38:49 <happy0> JamesJRH: are you going to simon marlow's talk today?
03:38:54 <happy0> or was that yesterday ;x
03:38:57 <happy0> i've lost track of time
03:39:22 <JamesJRH> Oh, that was this morning.
03:39:34 <happy0> JamesJRH: ah. did you go? :P
03:39:54 <JamesJRH> Unfortunately not. :-/
03:40:30 <happy0> aww
03:40:50 <happy0> have you managed to meet up with anyone, by the way? i know you were looking for others who were there in here
03:40:59 <matsuura_> http://i.imgur.com/g2qbFBl.jpg desu 
03:41:03 <JamesJRH> Hey, 1 other person has joined #HaskellX! I'm glad that I'm not the only IRC user here.
03:41:12 <happy0> haha
03:41:45 <JamesJRH> (Assuming that they are actually someone from the conference.)
03:42:09 <JamesJRH> Yes, I've had some conversations
03:42:10 <JamesJRH> .
03:42:16 <JamesJRH> I love it.
03:42:43 <happy0> JamesJRH: \o/
03:45:51 <JamesJRH> Hmmm… There are some programmes lying around… maybe… Heh, I'm going to write over the ‘Tweet ’ with ‘Freenode/’. Maybe some IRC users will see it… :-D
03:46:52 <happy0> plan :P
03:49:59 <YellowOnion> If I was trying to make a timed loop, using a <- async (threadDelay (1/60)); ..stuff..; wait a, isn't completely stupid is it :P
03:50:36 * hackagebot amazonka-autoscaling 1.3.3 - Amazon Auto Scaling SDK.  https://hackage.haskell.org/package/amazonka-autoscaling-1.3.3 (BrendanHay)
03:50:38 * hackagebot amazonka-ses 1.3.3 - Amazon Simple Email Service SDK.  https://hackage.haskell.org/package/amazonka-ses-1.3.3 (BrendanHay)
03:50:40 * hackagebot amazonka-support 1.3.3 - Amazon Support SDK.  https://hackage.haskell.org/package/amazonka-support-1.3.3 (BrendanHay)
03:50:42 * hackagebot amazonka-dynamodb-streams 1.3.3 - Amazon DynamoDB Streams SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-streams-1.3.3 (BrendanHay)
03:50:44 * hackagebot amazonka-redshift 1.3.3 - Amazon Redshift SDK.  https://hackage.haskell.org/package/amazonka-redshift-1.3.3 (BrendanHay)
03:50:51 <srhb> YellowOnion: Not completely stupid, although that's a VERY short break, and you'd need to synchronize things by writing when you last stopped.
03:51:33 <srhb> YellowOnion: ie. usually you compensate the threadDelay by seeing how long you actually waited (what time is it now)
03:51:49 <YellowOnion> srhb, oh I keep forgetting threadDelay takse microseconds.
03:52:47 <YellowOnion> the classic way of doing this would be to get CPU time, do stuff, calculate the delta then wait the remainder.
03:52:59 <srhb> Yep. Which you can do. :)
03:54:53 <deech> Hi all, Hackage appears to be down.
03:55:01 <srhb> deech: Very slow, but not down.
03:55:09 <deech> srhb: Ah, thanks.
03:55:25 <srhb> deech: Well, now I just got a 503 on one request...
03:55:26 <YellowOnion> srhb, what do you mean by "write when you last stopped"?
03:55:43 <srhb> YellowOnion: Basically what you just summarized with the delta.
03:55:46 * hackagebot amazonka-opsworks 1.3.3 - Amazon OpsWorks SDK.  https://hackage.haskell.org/package/amazonka-opsworks-1.3.3 (BrendanHay)
03:55:48 * hackagebot amazonka-emr 1.3.3 - Amazon Elastic MapReduce SDK.  https://hackage.haskell.org/package/amazonka-emr-1.3.3 (BrendanHay)
03:55:50 * hackagebot amazonka-cognito-identity 1.3.3 - Amazon Cognito Identity SDK.  https://hackage.haskell.org/package/amazonka-cognito-identity-1.3.3 (BrendanHay)
03:55:52 * hackagebot amazonka-ssm 1.3.3 - Amazon Simple Systems Management Service SDK.  https://hackage.haskell.org/package/amazonka-ssm-1.3.3 (BrendanHay)
03:55:54 * hackagebot amazonka-ml 1.3.3 - Amazon Machine Learning SDK.  https://hackage.haskell.org/package/amazonka-ml-1.3.3 (BrendanHay)
03:56:28 <srhb> YellowOnion: Depends what's more important, doing something every x s, or close to some specific time each time.
03:57:49 <YellowOnion> srhb, every x s.
03:58:23 <quicksilver> threadDelay is not guaranteed to be accurate
03:58:35 <quicksilver> so if you *really* care you need to .. take more care
03:58:43 <quicksilver> but it's probably fine for just clamping a frame rate or similar
03:58:45 <srhb> Yes, and sleep less, and adjust.
03:59:16 <srhb> Or use some system alarm of another kind.
03:59:58 <YellowOnion> quicksilver, since threadDelay takes microseconds I figured it was accurate it enough for my purposes.
04:00:54 <srhb> YellowOnion: afair, it will guarantee to sleep _at least_ that many microseconds.
04:00:56 * hackagebot amazonka-workspaces 1.3.3 - Amazon WorkSpaces SDK.  https://hackage.haskell.org/package/amazonka-workspaces-1.3.3 (BrendanHay)
04:00:58 * hackagebot amazonka-inspector 1.3.3 - Amazon Inspector SDK.  https://hackage.haskell.org/package/amazonka-inspector-1.3.3 (BrendanHay)
04:01:00 * hackagebot amazonka-rds 1.3.3 - Amazon Relational Database Service SDK.  https://hackage.haskell.org/package/amazonka-rds-1.3.3 (BrendanHay)
04:01:01 <srhb> YellowOnion: In other words, you will drift past that.
04:01:02 * hackagebot amazonka-iot 1.3.3 - Amazon IoT SDK.  https://hackage.haskell.org/package/amazonka-iot-1.3.3 (BrendanHay)
04:01:04 * hackagebot amazonka-ds 1.3.3 - Amazon Directory Service SDK.  https://hackage.haskell.org/package/amazonka-ds-1.3.3 (BrendanHay)
04:01:08 <srhb> YellowOnion: If that's OK, you're fine. :-)
04:03:07 <YellowOnion> 100 microseconds shouldn't kill me.
04:04:01 <quicksilver> YellowOnion: it is actually implemented by an underlying OS timer which varies from OS to OS
04:04:10 <quicksilver> so the API isn't very specific about what the guarantees are
04:04:19 <quicksilver> (and I don't know :)
04:04:34 <YellowOnion> yeah I noticed a few months ago.
04:05:23 <YellowOnion> my question was more inline with using async (instead of calculating delta) to do the timing.
04:06:07 * hackagebot amazonka-route53 1.3.3 - Amazon Route 53 SDK.  https://hackage.haskell.org/package/amazonka-route53-1.3.3 (BrendanHay)
04:06:08 * hackagebot amazonka-cloudsearch 1.3.3 - Amazon CloudSearch SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-1.3.3 (BrendanHay)
04:06:10 * hackagebot amazonka-storagegateway 1.3.3 - Amazon Storage Gateway SDK.  https://hackage.haskell.org/package/amazonka-storagegateway-1.3.3 (BrendanHay)
04:06:13 * hackagebot amazonka-ec2 1.3.3 - Amazon Elastic Compute Cloud SDK.  https://hackage.haskell.org/package/amazonka-ec2-1.3.3 (BrendanHay)
04:06:15 * hackagebot amazonka-marketplace-analytics 1.3.3 - Amazon Marketplace Commerce Analytics SDK.  https://hackage.haskell.org/package/amazonka-marketplace-analytics-1.3.3 (BrendanHay)
04:06:21 <quicksilver> YellowOnion: yeah seems like a fine use of async
04:06:25 <ocramz> cabal question: I am developing a package that has a multi-pass build: there's a library including inline-c parts, so I have to run GHC first and CC second, on the C files generated by the C pass. Afterwards, the back-end dynlibs and the object files generated by the previous step will have to be linked by a GHCi step, in order to try out the example files. Anybody knows a good cabal file reference, or a library with similar features?
04:06:57 <ocramz> *the C files are generated by the GHC pass
04:11:17 * hackagebot amazonka-elastictranscoder 1.3.3 - Amazon Elastic Transcoder SDK.  https://hackage.haskell.org/package/amazonka-elastictranscoder-1.3.3 (BrendanHay)
04:11:19 * hackagebot amazonka-lambda 1.3.3 - Amazon Lambda SDK.  https://hackage.haskell.org/package/amazonka-lambda-1.3.3 (BrendanHay)
04:11:21 * hackagebot hpc-coveralls 1.0.2 - Coveralls.io support for Haskell.  https://hackage.haskell.org/package/hpc-coveralls-1.0.2 (killy971)
04:11:27 * hackagebot amazonka-cloudwatch-logs 1.3.3 - Amazon CloudWatch Logs SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-logs-1.3.3 (BrendanHay)
04:13:50 <JamesJRH> happy0: ‘IRC: Freenode/#HaskellX’ is now on both sides of the 3 programme flyers that are nearby.
04:14:30 <JamesJRH> happy0: Hey wow! You'd be jealous at what I've just been doing… :-D
04:14:46 <happy0> JamesJRH: haha, do tell :P
04:15:20 <JamesJRH> happy0: Haskell Breakout game + Kinect + jumping from side to side being the paddle! :-D
04:15:33 <JamesJRH> Bbl. \o
04:16:47 <happy0> JamesJRH: i am indeed jelly :P
04:16:52 <happy0> good times
04:20:54 <tsahyt> How would I go about implementing a function Set Text -> Text which returns a text that is *not* in the set?
04:21:07 <tsahyt> Any new text will do, as long as it's not used already
04:22:37 <MasseR> tsahyt: by generating an infite list of texts and choosing the first one that is not in the set?
04:22:46 <srhb> tsahyt: Concat all the texts!
04:23:20 <lyxia> make a Text one character longer than the longest in the set!
04:24:04 <quicksilver> tsahyt: generate a UUID, check it isn't in the list?
04:24:12 <quicksilver> or
04:24:15 <tsahyt> I guess that the infinite list approach gives me the most flexibility
04:24:17 <quicksilver> are you trying to make it deterministic?
04:24:28 <oftl> what is <|> ?
04:24:32 <quicksilver> I mean Set Text -> IO Text is easy enough
04:24:43 <tsahyt> Determinism is a bonus, because that would make debugging a lot easier
04:24:45 <MasseR> oftl: Alternative operator
04:24:49 <quicksilver> for Set Text -> Text I guess you should hash the contents of the text 
04:25:23 <MasseR> quicksilver: or such a list that it is something like ["a", "b", ... "aa", "ab"] etc
04:25:47 <quicksilver> MasseR: that quickly becomes O(n)
04:25:56 <quicksilver> assuming wht he does next is insert them in the Set
04:26:02 <quicksilver> then after a while, all his first choices are in there
04:26:14 <MasseR> quicksilver: quicksilver agreed. However I didn't notice him saying that kind of condition
04:26:33 <tsahyt> Yes the next step is inserting one of them into the set
04:26:35 <quicksilver> no, I was guessing
04:27:38 <oftl> MasseR: thanks, couldn't remember its name
04:27:40 <tsahyt> Since the whole thing is stateful anyway, I could keep an infinite list of free names around and use the head of that when I need a new name
04:28:50 <quicksilver> and indeed they can just be successive integers
04:28:54 <quicksilver> which is cheap and a common trick
04:28:59 <quicksilver> it depends what your needs are :P
04:31:39 <tsahyt> That actually gives me an idea. The user supplied names must start with a letter, but there's no reason I couldn't use numbers during reasoning
04:31:39 <tsahyt> As long as it's unique, a text is a text.
04:31:39 <quicksilver> quite
04:31:39 <quicksilver> tsahyt: you may wish to google 'name supply monad'
04:31:40 <quicksilver> although the frameworks you will find may not be everything you want
04:31:40 <quicksilver> or they may be more than you want
04:31:40 * hackagebot declarative 0.1.0.0 - DIY Markov Chains.  https://hackage.haskell.org/package/declarative-0.1.0.0 (JaredTobin)
04:31:40 <tsahyt> Of couse there's a monad for that
04:41:28 * hackagebot declarative 0.1.0.1 - DIY Markov Chains.  https://hackage.haskell.org/package/declarative-0.1.0.1 (JaredTobin)
04:52:42 <icbm> Is there already a function like this? findMap ls f = getFirst . foldMap (First . f) $ ls
04:54:08 <icbm> i.e. maps list items to Maybe, returns first Just
04:55:00 <ski> @type \f -> getFirst . foldMap (First . f)
04:55:01 <lambdabot> Foldable t => (a1 -> Maybe a) -> t a1 -> Maybe a
04:55:36 <ski> @type (listToMaybe .) . mapMaybe
04:55:39 <lambdabot> (a1 -> Maybe a) -> [a1] -> Maybe a
04:56:42 <icbm> ski: Thanks
05:02:05 <quicksilver> I think I prefer get First . foldMap (First . f)
05:02:48 <quicksilver> you can spell it
05:03:00 <quicksilver> or..
05:03:17 <quicksilver> not sure :)
05:03:23 <quicksilver> something something ala First something foldMap
05:03:24 <jmcarthur> by the same logic, would you prefer   get First . fold . map (First . f)   ?
05:03:34 <quicksilver> jmcarthur: no.
05:03:48 <jmcarthur> then why prefer  get First  over  getFirst?
05:03:48 <quicksilver> jmcarthur: foldMap is a natural operation to my eyes
05:03:57 <quicksilver> oh that was merely a typo :)
05:04:02 <jmcarthur> ah! haha
05:04:16 <icbm> quicksilver: :)
05:04:21 <quicksilver> I meant I prefer (getFirst . foldMap (First .f)) to (listToMaybe . mapMaybe f)
05:04:24 <jmcarthur> i was thinking it was one of those overloaded functions i've seen in a few packages for this pattern
05:05:10 <jmcarthur> foldMap is one of my favorite functions. it's a shame that it often involves newtype noise.
05:06:27 <jmcarthur> quicksilver: oh, but you were actually leaning toward one of those "ala" functions or whatever, weren't you?
05:06:39 <icbm> Yeah, my first learned Haskell instinct is that if I ever think "Oh, I'll run into this again", go look for a function. Someone probably turned this kind of computation into a one-liner.
05:06:41 <quicksilver> I was wondering about one of the ala functions, yes
05:06:45 <jmcarthur> quicksilver: that is basically how i was interpreting it. so i think i'm back to my question again
05:06:49 <quicksilver> but I realised I don't know how to use them
05:07:01 <quicksilver> > ala Sum foldMap [1,2,3,4]
05:07:03 <lambdabot>  10
05:07:08 <jmcarthur> ah
05:07:11 <quicksilver> but I don't know ho you inject icbm's "f" into there
05:07:12 <jmcarthur> i also fail at using ala
05:07:14 <quicksilver> I've never used it.
05:07:15 <Ferdirand> :t ala
05:07:17 <lambdabot> (Rewrapped s t, Rewrapped t s) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
05:07:20 <jmcarthur> lol
05:07:29 <voidzero> haskell is a famous wrapper
05:07:31 <Ferdirand> oh yeah that's obvious
05:07:49 <quicksilver> those typeclasses associate 'getFirst' and 'First', Ferdirand 
05:07:58 <quicksilver> (resp. getSum and Sum)
05:08:03 <quicksilver> so it can do the 'get' part automatically
05:08:07 <icbm> > ala First foldMap [Nothing, Just 42]
05:08:07 <jmcarthur> i'm not sure how i feel about functions that have complicated types to that they can be used to write simple looking expressions
05:08:10 <lambdabot>  Just 42
05:08:13 <jmcarthur> *so that
05:08:14 <icbm> woot
05:08:30 <quicksilver> jmcarthur: the first parameter to ala is a phantom
05:08:35 <jmcarthur> yup
05:08:37 <icbm> > ala First foldMap $ fmap id [Nothing, Just 42]
05:08:38 <lambdabot>  Just 42
05:08:53 <jmcarthur> hmm
05:08:54 <quicksilver> jmcarthur: it's just there to identify which newtype wrapper to use
05:09:30 <jmcarthur> i've never used it for anything but foldMap. i wonder how it generalizes.
05:09:32 <quicksilver> jmcarthur: well we don't have a better to way to "pass a function and its inverse and assert that they represent an isomorphism"
05:09:34 * jmcarthur looks into it again
05:09:37 <aweinstock> :t \f -> ala f foldMap
05:09:39 <lambdabot> (Foldable t, Monoid s, Rewrapped s s) => (Unwrapped s -> s) -> t (Unwrapped s) -> Unwrapped s
05:10:07 <aweinstock> where is ala from again?
05:10:15 <quicksilver> https://hackage.haskell.org/package/lens-4.13/docs/Control-Lens-Wrapped.html
05:10:25 <icbm> > ala (First . id) foldMap [Nothing, Just 42]
05:10:28 <lambdabot>  Just 42
05:10:37 <icbm> There we go
05:10:42 <jmcarthur> also https://hackage.haskell.org/package/newtype-0.2/docs/Control-Newtype.html , but the lens version is more... lensy
05:10:51 <quicksilver> icbm: I don't think that works :)
05:10:56 <quicksilver> it only works for id
05:10:58 <aweinstock> > ala First foldMap [Nothing, Just 42]
05:11:00 <lambdabot>  Just 42
05:11:04 <quicksilver> I think you need
05:12:03 <quicksilver> ala First (\x g -> foldmap (g . f))
05:12:05 <quicksilver> or something
05:12:12 <jmcarthur> i think the pattern of using a phantom to "qualify" a type class that demands an isomorphism is reasonable. i'm suspicious that the only examples i've seen so far use foldMap
05:12:17 <quicksilver> g gets instantiated as 'First'
05:12:40 <icbm> quicksilver: Cool
05:12:46 <aweinstock> Control.Newtype.pack and unpack are operationally equivalent to id at runtime?
05:13:34 <jmcarthur> aweinstock: not necessarily. when you're actually talking about newtypes, it's true, but since that's a type class, other isomorphisms could also apply, with less trivial conversions
05:13:37 <icbm> > ala (First . Just) foldMap [42] -- should fail then
05:13:38 <lambdabot>      Occurs check: cannot construct the infinite type: b ~ Maybe b
05:13:39 <lambdabot>      Expected type: Unwrapped (First b) -> First b
05:13:39 <lambdabot>        Actual type: b -> First b
05:14:32 <icbm> Lenses are beyond my leve currently, but I'll keep a lookout for ala.
05:14:40 <quicksilver> >  ala First (\g x -> foldMap (g.Just) x) [42]
05:14:41 <lambdabot>  Just 42
05:14:45 <quicksilver> icbm: that's how you do it
05:14:58 <quicksilver> where 'Just' is your f
05:15:01 <icbm> quicksilver: Got it. Thanks!
05:15:14 <quicksilver> @pl \g x -> foldMap(g.Just) x
05:15:14 <lambdabot> foldMap . (. Just)
05:15:20 <quicksilver> I knew it was someting a bit like that.
05:15:32 * ski figured it out in head
05:15:38 <lamefun> Is there this function somewhere in the default libraries? "findEnumByProperty getProperty value = find (\enum -> getProperty enum == value) (enumFromTo minBound maxBound)"
05:15:46 <aweinstock> :t Control.Newtype.ala
05:15:47 <lambdabot> Not in scope: ‘Control.Newtype.ala’
05:15:50 <quicksilver> jmcarthur: for example, how do I use ala (or similar) to sum a list of numbers?
05:16:05 <jmcarthur> > ala Sum foldMap [1..5]
05:16:07 <lambdabot>  15
05:16:13 <quicksilver> erm
05:16:19 <quicksilver> why is that not what I meant
05:16:25 <quicksilver> I mean, using 'mconcat' :)
05:16:45 <aweinstock> :t ala Any foldMap
05:16:46 <lambdabot> Foldable t => t Bool -> Bool
05:16:54 <jmcarthur> > ala Sum ((fmap.fmap) mconcat map) [1..5]
05:16:56 <lambdabot>  15
05:17:11 <quicksilver> jmcarthur: not very attractive tho
05:17:15 <jmcarthur> nope
05:17:18 <aweinstock> :t [ala Any foldMap, or]
05:17:19 <lambdabot> Foldable t => [t Bool -> Bool]
05:17:21 <quicksilver> it feels like this mechanism should give us a way to say
05:17:26 <quicksilver> "mconcat_but_using_Sum"
05:17:36 <jmcarthur> the source of my distate for ala is that it looks like it's just made for foldMap
05:17:37 <quicksilver> I mean, it does, you just showed that
05:17:42 <quicksilver> jmcarthur: yeah
05:17:42 <jmcarthur> *distaste
05:17:47 <aweinstock> is ala useful with functions other than foldMap?
05:17:52 <Ankhers> Has anyone successfully used omitNothingFields in aeson-0.10?
05:17:56 <quicksilver> that's what we were asking aweinstock 
05:18:01 <aweinstock> ah
05:18:44 <jmcarthur> i suspect the lensy version allows something like what we are talking about
05:18:46 <jmcarthur> more nicely
05:18:50 <aweinstock> is there a shorter name for (\f xs -> ala f foldMap xs)?
05:19:09 <aweinstock> s/shorter/standard/
05:19:29 <icbm> Think I'm going to stick with my original func until I start getting into lenses. findMap ls f = getFirst . foldMap (First . f) $ ls
05:21:06 <quicksilver> aweinstock: no. Note it doesn't work with arbitrary functions f
05:21:26 <quicksilver> f has to be the wrapping-half of a defined wrapper/unwrapper pair
05:21:31 <c_wraith> :t foldMapOf
05:21:32 <lambdabot> Profunctor p => Accessing p r s a -> p a r -> s -> r
05:21:41 <quicksilver> :t \f xs -> ala f foldMap xs
05:21:42 <lambdabot> (Foldable t, Monoid s, Rewrapped s s) => (Unwrapped s -> s) -> t (Unwrapped s) -> Unwrapped s
05:22:02 <icbm> My next exercise is how to get it to work when f :: a -> ST s (Maybe b) .  Seems a good thing to work on today while, um, "waiting on the db to restore".
05:22:22 <quicksilver> icbm: throw a 'sequence' in there somewhere
05:22:31 <Copperis> is it possible to replace map (fold.. with foldMap in this function? map (foldl (\ acc x -> acc + 1) 0) $ group [1,1,1,2,2,3,3,3,3] 
05:22:31 <quicksilver> to produce an array of answers inside ST
05:23:08 <quicksilver> s/array/list/
05:23:11 <Copperis> I'm learning, that function is contrived
05:23:17 <quicksilver> Copperis: I don't think so; foldMap isn't really like that.
05:23:23 <quicksilver> foldMap is about using monoids
05:24:00 <Copperis> ok, haven't got to those yet
05:24:27 <aweinstock> Copperis: (foldl (\acc x -> acc+1) 0) = length
05:24:39 <Copperis> aweinstock, yup
05:25:07 <aweinstock> :t foldMap
05:25:08 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
05:25:20 <aweinstock> :t foldMap (Sum . const 1)
05:25:21 <lambdabot> (Num a, Foldable t) => t b -> Sum a
05:25:41 <mdx> hello! Does anyone have a xml tutorial for haskell to recommend? Tried my way on xml.light but seems like I can't search for nested tags
05:25:59 <jmcarthur> eh, i can't figure out a nice way to do it with mconcat, even with lenses.
05:26:24 <aweinstock> > let length' = getSum . foldMap (Sum . const 1) in map length' $ group [1,1,1,2,2,3,3,3,3]
05:26:25 <lambdabot>  [3,2,4]
05:26:29 <aweinstock> Copperis: ^
05:27:50 <Copperis> aweinstock, thanks! Lots of new things here
05:28:51 <aweinstock> Copperis: is there something in that line that I should further explain?
05:29:12 <aweinstock> @src foldMap
05:29:12 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
05:29:36 <Copperis> aweinstock, no, thanks. I havent got to Monoids yet, I thought foldMap was a simpler thing. I think I'll figure it out
05:29:36 <aweinstock> foldMap f xs = mconcat (fmap f xs) -- is this true?
05:29:52 <quicksilver> no
05:30:01 <quicksilver> you need to force it to a list somewhere
05:30:09 <quicksilver> mconcat . fmap f . toList $ xs
05:30:15 <quicksilver> or swap the fmap f and the toList, they commute
05:30:41 <aweinstock> Copperis: Monoids are simple (anything with an identity and associative function)
05:30:41 <quicksilver> but the idea is that it might be faster not to go via lists
05:32:06 <aweinstock> Copperis: (0,(+)), (1,(*)), and ([], (++)) are all monoids that you've probably used already without calling that
05:33:27 <ski> @free toList :: T a -> [a]
05:33:28 <lambdabot> $map f . toList = toList . $map_T f
05:34:07 <aweinstock> Copperis: (e, (<>)) is a monoid if for any x, (e <> x = x <> e = x) ("e is an identity"), and for all x, y, z ((x <> y) <> z) = (x <> (y <> z)) ("<> is associative")
05:34:44 <quicksilver> ski: nice
05:34:49 <aweinstock> Copperis: does that make sense?
05:35:05 <Copperis> aweinstock, what does <> do?
05:35:30 <Copperis> aweinstock, not yet
05:35:35 <aweinstock> Copperis: depends on what exactly the monoid is (it's an interface, there can be more than one implementation)
05:35:46 <aweinstock> > Sum 3 <> Sum 3
05:35:47 <Copperis> ok, I had a question
05:35:47 <lambdabot>  Sum {getSum = 6}
05:35:50 <Stratege> Copperis <> can do whatever it wants to as long as it fullfills the above rules.
05:35:56 <aweinstock> > Product 3 <> Product 3
05:35:57 <Copperis> aweinstock, identity and associative function. I'm a bit unsure about associative, but ok. Then how is a monoid applied? I.e. how does it function? (is that even a valid question?)
05:35:58 <lambdabot>  Product {getProduct = 9}
05:36:01 <Stratege> (and it depends on the type what it does)
05:36:08 <ski> > [0,1] <> [2]
05:36:10 <lambdabot>  [0,1,2]
05:36:18 <quicksilver> > mempty :: Sum Int
05:36:19 <lambdabot>  Sum {getSum = 0}
05:36:23 <ski> > Dual [0,1] <> Dual [2]
05:36:24 <lambdabot>  Dual {getDual = [2,0,1]}
05:37:09 <ski> Copperis : associative means it doesn't matter how you group a "sequence" of elements combined with `<>'
05:37:13 <aweinstock> Copperis: all of these examples we're throwing at lambdabot (haskell calls a monoid's identity element "mempty")
05:38:13 <aweinstock> Copperis: in 1+2+3+4+5, there are a bunch of ways to group the parenthesis, but (1+2+3)+(4+5) = (1+2)+(3+4+5) and so on because addition is associative
05:38:59 <ski> Copperis : identity/neutral element means that we also allow the sequence of elements to be an empty sequence
05:39:02 <Copperis> ok, I understand associativity
05:39:07 <aweinstock> and so, since it's associative, you can just say 1+2+3+4+5 without needing to be more specific, it all gives the same result
05:39:34 <mdx> >:t Dual
05:39:50 <aweinstock> :t Dual
05:39:51 <lambdabot> a -> Dual a
05:39:56 <aweinstock> @src Dual
05:39:57 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
05:39:58 <mdx> ty
05:40:06 <mdx> so Dual <> is flip <>? interesting
05:40:24 <quicksilver> yes, that's how instance Monoid (Dual a) is defined
05:40:52 <ski> Copperis : in Haskell, `mconcat' takes a list (a sequence, i.e.) of elements, and combines them. so aweinstock's associativity example could be written as `mconcat [mconcat [1,2,3],mconcat [4,5]] = mconcat [mconcat [1,2],mconcat [3,4,5]]' in terms of `mconcat' and lists
05:41:04 <mdx> so dual is a morphism, in cat theory? 
05:42:14 <ski> Copperis : more generally, `mconcat [a,b,...,h,mconcat [ia,ib,...,iz],j,...,z] = mconcat [a,b,...,h,ia,ib,...iz,j,...,z]' expresses associativity, in terms of `mconcat'
05:42:47 <aweinstock> Copperis: "newtype wrappers" like Sum and Product are used for numbers-as-monoids in haskell since there's more than one monoid that makes sense (likewise Any and All for booleans)
05:43:09 <ski> Copperis : the neutral/identity element is the special case `mconcat [a,...,h,mconcat [],j,...,z] = mconcat [a,...,h,j,...,z]', where the inner list have zero elements (note that `mconcat [] = mempty')
05:43:40 <aweinstock> Copperis: for other things like lists, concatenation is the monoid that makes the most sense, so it's defined directly
05:44:18 <ski> (another way to express associativity and neutral element would be `mconcat . map mconcat = mconcat . concat'. but you also need `mconcat . sing = id', where `sing = (: [])', then)
05:44:34 <aweinstock> > (mempty :: Sum a, mempty :: Product a, mempty :: [a])
05:44:36 <lambdabot>      No instance for (Num a3) arising from a use of ‘mempty’
05:44:36 <lambdabot>      Possible fix:
05:44:36 <lambdabot>        add (Num a3) to the context of an expression type signature: Sum a3
05:44:47 <aweinstock> > (mempty :: Sum Int, mempty :: Product Int, mempty :: [a])
05:44:48 <lambdabot>  (Sum {getSum = 0},Product {getProduct = 1},[])
05:45:03 <ski> > mempty :: (Sum Int,Product Int,[Bool])
05:45:05 <lambdabot>  (Sum {getSum = 0},Product {getProduct = 1},[])
05:45:22 <Copperis> I kind of understand the use of the Monoid interface to construct things like +, *
05:45:28 <aweinstock> ski: a tuple of monoids is a monoid?
05:45:36 <ski> aweinstock : product monoid
05:46:01 <ski> (categorical product)
05:47:04 <ski> Copperis : .. in case what i said above doesn't make much sense for you, don't worry. i just figured i'd add another way to think about it, mathematically
05:47:05 <suppi> does anyone know how can I use the terminal in the way less or vi use it? like, writing stuff on the terminal but when you exit it is not there anymore
05:47:21 <ski> suppi : use alternate screen
05:47:35 <Copperis> though I still don't understand its usage. I'll continue a tutorial I'm working on. Thanks for the examples!
05:47:39 <suppi> ski, what do you mean?
05:49:30 <aweinstock> Copperis: I think the main use is for writing algorithms that work on "anything that can be combined", when you don't need more detail for the algorithm to be correct
05:50:05 <ski> suppi : there are termcap/terminfo capabilities for it. presumably there are bindings in terminal controlling libraries to use it
05:50:29 <aweinstock> Copperis: or for having a general way to say "combine these things", so that you only need to change the representation in one place, for performancy stuff (various types of ByteStrings, etc)
05:50:34 <ski> suppi : termcap/terminfo caps are `ti'/`smcup' and `te'/`rmcup'
05:50:48 <Stratege> Copperis the generic fold uses it, since that one doesn't care what you want to fold nor how combining 2 values works - apart from associativity and identity element - so when given those it can do its job.
05:50:57 <suppi> ski, I'm sorry but I'm not sure I follow, is there a way to activate and deactivate this behaviour from a haskell program?
05:51:41 <Copperis> so using monoids, the foldMap function could do processing in parallel?
05:51:55 <Copperis> in theory
05:52:00 <icbm> Really gotta leave for work now, but couldn't resist: findMapM ls f = do
05:52:01 <icbm>     ms <- sequence $ fmap f ls
05:52:02 <icbm>     return $ getFirst . foldMap First $ ms
05:52:09 <aweinstock> > map length ["getSum . foldMap (Sum . const 1)", "foldr (\a _ -> a+1) 0"]
05:52:10 <lambdabot>  [32,20]
05:52:16 <MasseR> Copperis: there is a machine learning library using monoids and parallelism
05:52:27 <srhb> MasseR: What's it called?
05:52:27 <MasseR> Well not monoids, but the abstraction layer below it, without 'mempty'
05:52:32 <Stratege> I was referring to fold, not foldMap ... but depending on the implementation I suppose - sure.
05:52:50 <MasseR> srhb: I'll try to find it
05:53:08 <Copperis> Stratege, oh yeah, I was thinking about foldl
05:53:09 <ski> suppi : `tput smcup' and `tput rmcup' (OS commands) seems to work here. as i said, presumably there are bindings for it in libraries, i haven't checked
05:53:22 <aweinstock> Copperis: yes (doing a tree-style fork-join thing is an example of an algorithm that depends only on monoid's guarentees)
05:53:30 <MasseR> srhb: hlearn, with a blog in izbicki.me
05:53:43 <srhb> MasseR: Ah, that. Thanks :)
05:54:39 <suppi> ski, awesome! thank you :)
05:54:43 <ski> @tell icbm `sequence $ fmap f ls = mapM f ls'
05:54:43 <lambdabot> Consider it noted.
05:54:48 <Stratege> Copperis still different from fold ^^ and since foldl imposes an order I don't think parallelism would work there. But for fold (without l or r) a sensible parallel implementation should exist, yes.
05:56:05 <Copperis> Stratege, is fold defined somwhere?
05:56:34 <quicksilver> it's a method of Foldable
05:56:38 <quicksilver> :t fold
05:56:39 <lambdabot> (Foldable t, Monoid m) => t m -> m
05:57:07 <mdx> Should I learn lens to parse XML to ADT's?  
05:57:21 <Copperis> quicksilver, my ghci doesn't find :t fold
05:57:33 <MasseR> Copperis: you need to import Data.Fold
05:57:36 <quicksilver> Copperis: you probably don't have Data.Foldable imported then
05:57:37 <MasseR> able
05:57:39 <ski> suppi : presumably there are principled ways to check if the terminal supports alternate screen. upon a quick glance, i don't see an appropriate boolean capability for it
05:57:48 <Stratege> Copperis oh sorry, I thought the current GHC had moved it into prelude.
05:58:06 <suppi> ski, that's alright, that is good enough :)
05:58:30 <aweinstock> > map length ["alaf Sum foldMap (const 1)", "foldr (\a _ -> a+1) 0"]
05:58:32 <lambdabot>  [26,20]
05:58:50 <ski> suppi : anyway, using `tput' is better than using raw escape sequences, which possibly will be different for different terminals
05:58:58 <aweinstock> ^ unfortunately the non-abstract foldr-based definition of length is still winning at codegolf
05:59:00 <Copperis> it's in Data.Foldable, Hoogle is a useful thing!
05:59:24 <ski> counting tokens is more meaningful than counting characters
05:59:49 <aweinstock> ski: by that metric, the alaf version wins?
06:00:07 <ski> probably
06:00:30 <aweinstock> 8 vs 12, assuming "(" and ")" count as seperate tokens, and "->" counts as 1
06:02:57 <quicksilver> aweinstock: length is a direct method of Foldable tho :)
06:03:20 <c_wraith> That's a relatively recent thing.
06:03:31 <quicksilver> and foldr is possibly a poor implementation for length for general Foldables
06:03:38 <c_wraith> And its default definition is getSum . foldMap sum
06:03:44 <c_wraith> err.
06:03:55 <c_wraith> getSum . foldMap . Sum . const 1
06:04:07 <c_wraith> Which is really quite slow
06:04:41 <c_wraith> I contributed a custom length for Cofree last week that was something like 17x faster
06:04:57 <quicksilver> why not getSum . foldMap . const (Sum 1) ? :P
06:05:08 <quicksilver> at least share the <Sum 1> thunk
06:05:37 <c_wraith> That still is going to be a space leak for most types
06:05:44 <c_wraith> Sharing the thunk matter little. :)
06:05:50 <c_wraith> *matters
06:06:17 <quicksilver> sure, well it's hard to say anything very generic about the best way to force your mappends isn't it?
06:06:24 <c_wraith> yep
06:06:48 <quicksilver> coerce . foldMap . const ((coerce 1)::Sum Int)
06:06:49 <c_wraith> You pretty much need to implement it for your type if you want efficiency.  The default just isn't good.
06:07:03 <aweinstock> foldMap = (fold .) . fmap -- is this true?
06:07:14 <c_wraith> looks right
06:07:15 <quicksilver> indeed, some types have O(1) length
06:07:28 <aweinstock> :t coerce
06:07:29 <lambdabot> (Functor f, Contravariant f) => f a -> f b
06:07:32 <quicksilver> c_wraith: this isn't a problem, tho, right?
06:07:40 <quicksilver> it's just.... a thing.
06:07:43 <quicksilver> aweinstock: wrong coerce.
06:07:44 <aweinstock> @hoogle Contravariant
06:07:45 <lambdabot> package contravariant
06:07:48 <c_wraith> quicksilver: no, it's why length is in the class in the first place
06:07:50 <quicksilver> :t Data.Coerce.coerce
06:07:51 <lambdabot> GHC.Types.Coercible a b => a -> b
06:08:14 <quicksilver> c_wraith: yeah, and it's the kind of tradeoff we know we pay when we build these abstractions, and why we spend time thinking about which methods to supply and how inlining works and stuff
06:08:19 <quicksilver> implementation details!
06:08:38 <Copperis> what for does a monoid use an identity?
06:08:48 <c_wraith> whatever it declares
06:08:52 <quicksilver> Copperis: to mconcat an empty list?
06:08:52 <aweinstock> Copperis: mempty
06:08:58 <c_wraith> > mempty :: Just ()
06:08:59 <lambdabot>      Expected a type, but ‘Just ()’ has kind ‘Maybe *’
06:09:00 <quicksilver> Copperis: I mean it's hard to answer that question
06:09:00 <lambdabot>      In an expression type signature: Just ()
06:09:00 <lambdabot>      In the expression: mempty :: Just ()
06:09:05 <c_wraith> > mempty :: Maybe ()
06:09:07 <lambdabot>  Nothing
06:09:14 <c_wraith> > mempty :: [()]
06:09:16 <lambdabot>  []
06:09:20 <c_wraith> > mempty :: Sum Int
06:09:22 <lambdabot>  Sum {getSum = 0}
06:09:32 <c_wraith> > mempty :: Product (Complex Double)
06:09:34 <lambdabot>  Product {getProduct = 1.0 :+ 0.0}
06:10:15 <Copperis> I don't understand why is it useful, what's it for. I guess this is more mathematics, because I found it's used in addition, multiplication
06:10:27 <Copperis> that term and its definition
06:10:28 <aweinstock> > mconcat [] :: Sum Int
06:10:30 <lambdabot>  Sum {getSum = 0}
06:10:37 <quicksilver> Copperis: the identity in particular? in many applications it isn't used.
06:10:52 <quicksilver> Copperis: btu when you need to apply something to a list of zero elements...
06:10:53 <Copperis> yes, what is the identity used for
06:10:56 <aweinstock> Copperis: being able to work with empty lists
06:10:57 <c_wraith> I was just happy with my implementation of length for Cofree.  length (_ :< xs) = go 0 where go s = foldl' go (s + 1) xs
06:11:37 <c_wraith> I go being defined in terms of a fold of itself
06:11:44 <c_wraith> I *like* go...
06:11:49 * hackagebot unordered-graphs 0.1.0 - Graph library using unordered-containers  https://hackage.haskell.org/package/unordered-graphs-0.1.0 (IvanMiljenovic)
06:13:04 <c_wraith> Copperis: the identity is for whenever you want a neutral element.  Something you can work in without breaking things.
06:13:38 <aweinstock> Copperis: in the parallel foldMap algorithm, where each node forks and combines half the elements in the new thread, having an identity lets you deal with odd-length lists more easily (I think)
06:14:01 <Copperis> aweinstock, ok, that could be a use
06:14:23 <c_wraith> foldMap deals with empty (sub-)structures without any special cases because of the identity element
06:14:46 <c_wraith> consider  data RoseTree a = RoseTree a [RoseTree a]
06:15:22 <c_wraith> Actually, that's the worst possible case.  Never mind that one.  :)
06:15:33 <c_wraith> Let's just look at foldMap over Maybe
06:15:49 <quicksilver> I don't think this is a very convincing argument. You can always quite happily fold a non-empty structure using just mappend
06:15:57 <quicksilver> mempty is only required for empty ones
06:16:01 <c_wraith> quicksilver: that's why I said it was the worst possible example
06:16:12 <quicksilver> and honestly, there are plenty of algorithms which do only use mappend
06:16:14 <c_wraith> because it has no empty case
06:16:17 <quicksilver> hence semigroups existing
06:16:35 <c_wraith> > getSum $ foldMap Sum (Just 5)
06:16:35 <Copperis> c_wraith, a bit off topic from haskell, can you explain what's the use of an identity for addition in math?
06:16:36 <lambdabot>  5
06:16:43 <c_wraith> > getSum $ foldMap Sum (Nothing)
06:16:45 <lambdabot>  0
06:17:04 <aweinstock> Copperis: as in, what's the point of 0?
06:17:12 <Copperis> in context of addition, yes
06:17:20 <c_wraith> Copperis: it's so that you know you have an element that "does nothing"
06:17:41 <c_wraith> Copperis: If you are describing the angle at which something turns, how do you describe that it doesn't turn?
06:18:08 <c_wraith> Copperis: There's always a use for a way to describe "no change"
06:18:14 <Copperis> c_wraith, use an identity?
06:18:19 <Copperis> ok, got it
06:18:23 <ski> Copperis : sometimes in math, you "add and subtract the same quantity" somewhere, without changing the overall value. then you do some algebraic rewrite which "separates" the two added pieces
06:19:06 <c_wraith> Copperis: it turns out that "no change" is a different value with respect to different operations.  It's 0 for addition, 1 for products, etc
06:19:10 <Copperis> ski, oh yeah, I remember those operations
06:19:32 <aweinstock> ski: that depends on additive inverses in addition to additive identities (which works in arbitrary groups, not monoids, I think?)
06:19:36 <c_wraith> Copperis: so the idea of an identity value is to abstract over the idea of "no change" so that you can talk about them in general.
06:19:46 <ski> Copperis : sometimes you want to count the number of things with some property, but you don't know beforehand whether there's any at all. allowing `0' as an answer makes it easier to reason here
06:20:01 <ski> aweinstock : yes
06:20:17 <aweinstock> and groups are just monoids-with-inverses?
06:20:21 <ski> yes
06:20:28 <hexagoxel> quicksilver: concrete-typerep does not compile on latest ghc. do you know the maintainer by any chance?
06:21:09 <Copperis> c_wraith, awesome. FP feels very interesting with these roots in math
06:23:09 <quicksilver> hexagoxel: I know *of* him. I don't know if he IRCs. He doesn't appear to have been around on the mailing list for a while
06:23:17 <quicksilver> hexagoxel: maybe there is a better way now...
06:23:22 <quicksilver> any cloud haskell guys around?
06:29:21 <linuss_> Hey guys! I'm working through cis194 (http://www.seas.upenn.edu/~cis194/lectures/07-monads.html), and I'm stuck on one of the exercises. I was wondering if any of you could help me out
06:29:39 <tsahyt> Which exercise?
06:29:42 <linuss_> I've got a compiling solution, but I'm not sure its correct:
06:29:45 <linuss_> http://pastebin.com/MRhvAQLV
06:30:06 <linuss_> It's from here: http://www.seas.upenn.edu/~cis194/hw/07-monads.pdf
06:31:54 <aweinstock> linuss_: you could probably test it empirically (run it on n! different seeds for small n, verify that all the results happen roughly-equally-often
06:32:04 <hexagoxel> quicksilver: you mean https://hackage.haskell.org/package/rank1dynamic-0.3.1.0/docs/Data-Rank1Typeable.html#t:TypeRep ?
06:33:16 <aweinstock> linuss_: and if Rnd is also conveniently availible as RndT, you could use RndT ST to do the entire shuffle in-place on a single vector, which might be more efficient (but that's probably not a concern)
06:33:18 <quicksilver> hexagoxel: is there a binary instance there?
06:33:26 <hexagoxel> yes
06:33:36 <linuss_> aweinstock, I'm not really sure how to do that, seeing as the return type of my function is Rnd (Vector a)
06:34:21 <quicksilver> hexagoxel: cool. I ddin'y know that was there but excellent :)
06:35:26 <linuss_> My concern is that the algorithm specifies that i loops from n-1 through 1, and j is a random number up to i, but in my implementation j is a random number between 0 and n
06:35:36 <ski> linuss_ : `randomVecR n (0, n-1)' (using `replicateM n') is wrong, you should be generating random numbers between `0' and `i', for each `i' from `n-1' to `0' (or `1')
06:36:00 <linuss_> yeah, exactly!
06:38:39 <aweinstock> linuss_: if (Rnd (Vector a)) is a requirement, stick with that, but (RndT ST (Data.Vector.Mutable.Vector a)) would allow you to mutate the vector in-place, rather than creating a new vector for every swap
06:39:38 <linuss_> <aweinstock> thanks, but performance is not really important right now :) I'm just trying to get it to work
06:40:53 <meditans> hi, is there in the libraries, a function that behaves like a fold over [a] but takes advantage of the fact that a is a Monoid?
06:40:54 <aweinstock> linuss_: ok :)
06:40:56 <ski> linuss_ : fyi, that looks like you're quoting something aweinstock said
06:41:08 <Stratege> meditans Data.Foldable.fold
06:41:13 <aweinstock> :t fold -- meditans
06:41:15 <lambdabot> (Foldable t, Monoid m) => t m -> m
06:41:19 <linuss_> Haha, i'm sorry, I'm both new to haskell AND irc :)
06:41:53 <aweinstock> linuss_: "propernoun: somethingorother" is how you typically address people in IRC
06:42:42 <meditans> Stratege: aweinstock: sorry, I explained myself poorly, let's say (+) is a very expensive operation: I want to fold [1,2,3,4] as (1+2) + (3+4) (minimizing the number of operations) instead of (1+(2+(3+4)))
06:43:50 <meditans> Stratege: aweinstock: and I'd like something in the libraries
06:46:28 <quicksilver> that's still three operations, meditans 
06:46:40 <quicksilver> maybe you have more precise ideas about which ones are faster? :)
06:46:54 <nicow> I'm using ghc's "-s" RTS options to dump all the GHC operations. It is definitely not something I can read. Is there any tool out there to parse it?
06:47:02 <quicksilver> reducing 4 elements to 1 using a binary operation takes 3 operations no matter which ordering you choose
06:48:08 <shapr> I notice there isn't any Haskell support for https://github.com/auchenberg/volkswagen
06:48:23 <meditans> quicksilver: yeah, sorry, my bad. The asymptotics changes (think of append as an example)
06:48:27 <linuss_> aweinstock: like this?
06:50:26 <meditans> quicksilver: foldl (++) is bad, but it can go better choosing wisely the order, right?
06:51:47 <tsahyt> foldl isn't bad because it goes from the left, but because it can accumulate a lot of thunks until anything is getting evaluated at all
06:51:51 * hackagebot crypto-enigma 0.0.2.0 - An Enigma machine simulator with display.  https://hackage.haskell.org/package/crypto-enigma-0.0.2.0 (Orome)
06:52:08 <quicksilver> tsahyt: foldl for (++) is specifically bad because it goes from the left.
06:52:23 <quicksilver> as well as the general reason.
06:52:31 <tsahyt> Okay for (++) I can see why
06:52:51 <quicksilver> meditans: the answer is, there are not general functions for other folding strategies
06:52:57 <meditans> tsahyt: yeah, ok, the strict version xD
06:53:13 <quicksilver> meditans: if your operation is *very* expensive then you could drop your items into a Map
06:53:25 <quicksilver> meditans: because the Map instance of 'fold' is a balanced fold
06:53:34 <meditans> quicksilver: ok, that's what I wanted to know, thanks. I think that for my case I can write by myself the function I need
06:53:36 <tsahyt> I think you could get the ((1+2) + (3+4)) behavior when you put your elements in a Tree and fold that
06:53:52 <tsahyt> A balanced binary tree to be precise
06:54:08 <quicksilver> several people have asked about there being a balanced fold in the standard lib, it's a natural idea
06:54:32 <meditans> tsahyt: yeah, that's what I'm going to do, but, exactly, it's so natural that I thought I was just unaware of it
06:54:41 <meditans> quicksilver: tsahyt: thanks!
06:55:54 <nshepperd> fold (foldMap Tree.singleton xs), I guess, for some appropriate binary tree type
06:57:01 <nshepperd> oh, well, Tree.fromList is probably better than foldMap Tree.singleton in general
06:58:31 <meditans> nshepperd: do you have a particular Tree in mind (in the standard lib? I'd like to keep the code short)?
07:00:35 <nshepperd> I thought there was a Tree in the stdlib but turns out those are rose trees
07:01:43 <kikero> Hey!
07:01:52 * hackagebot glue-common 0.4.5 - Make better services and clients.  https://hackage.haskell.org/package/glue-common-0.4.5 (seanparsons)
07:01:54 * hackagebot glue-core 0.4.5 - Make better services and clients.  https://hackage.haskell.org/package/glue-core-0.4.5 (seanparsons)
07:01:56 * hackagebot glue-ekg 0.4.5 - Make better services and clients.  https://hackage.haskell.org/package/glue-ekg-0.4.5 (seanparsons)
07:01:58 * hackagebot glue-example 0.4.5 - Make better services and clients.  https://hackage.haskell.org/package/glue-example-0.4.5 (seanparsons)
07:02:29 <quicksilver> meditans, nshepperd : Data.Map
07:02:39 <quicksilver> it doesn't matter what you use for the key
07:03:01 <quicksilver> fromAscList (zip [0..]) xs should do the trick
07:03:33 <meditans> quicksilver: trying that
07:03:37 <quicksilver> paren in wrong place :)
07:03:47 <kikero> A friend has asked me for a simple Haskell code snippet that generates all prime numbers from 1 to n.
07:04:08 <kikero> I thought this might be a good opportunity to start learning Haskell. 
07:04:24 <quicksilver> :t fold . M.fromAscList . zip [0..]
07:04:25 <fizruk> kikero: https://www.haskell.org
07:04:25 <lambdabot> Monoid c => [c] -> c
07:04:46 <quicksilver> if there is one thing that haskell websites are good at, it is generating prime numbers :)
07:04:51 <tsahyt> quicksilver: What about a fold over a Set?
07:05:06 <quicksilver> https://wiki.haskell.org/Prime_numbers
07:05:13 <fizruk> kikero: specifically, at the top right you can see one implementation
07:05:13 <tsahyt> I've been folding sets all day now, and this made me curious
07:05:17 <quicksilver> tsahyt: requires an Ord instance he might not have, which might be expensive
07:05:27 <kikero> fizruk: lol
07:05:39 <kikero> yea
07:05:49 <kikero> well, that was what I was thinking I guess
07:05:50 <meditans> quicksilver: indeed
07:06:27 <kikero> Have a list the list 1:[3..] from which I filter any value that is prime.
07:06:56 <fizruk> > 1:[3..]
07:06:58 <lambdabot>  [1,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
07:07:02 <fizruk> > [1,3..]
07:07:03 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
07:07:08 <kikero> 1:[3,5..]
07:07:13 <fizruk> kikero: 2 is also prime
07:07:21 <kikero> 1:2:[3,5..]
07:07:22 <kikero> :p
07:07:26 <fizruk> kikero: 1 is not
07:07:26 <kikero> haha
07:07:32 <kikero> 1 is not?
07:07:36 <fizruk> nope
07:07:58 <kikero> didn't know that
07:08:09 <kikero> lol
07:08:24 <tsahyt> kikero: Otherwise prime factorisations wouldn't be unique.
07:08:50 <tsahyt> For instance, if 1 was prime, then 1337 = 7 * 191 = 1 * 7 * 191 = 1 * 1 * 7 * 191 = ...
07:08:57 <fizruk> not only that, you'd need "primes except 1" in almost every proof
07:08:59 <tsahyt> Those would all be valid factorisations
07:09:28 <kikero> yea, right
07:09:49 <ski> > (`fix` [2 ..]) $ \sieve (p:ns) -> p : sieve [n | n <- ns,n `mod` p /= 0]  -- kikero
07:09:51 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
07:10:25 <tsahyt> :t (`fix` [2..])
07:10:26 <lambdabot> (Enum t1, Num t1) => (([t1] -> t) -> [t1] -> t) -> t
07:10:30 <kikero> ski, I don't think I understand that code anymore.
07:10:53 <ski> > let primes = sieve [2 ..]; sieve (p:ns) = p : sieve [n | n <- ns,n `mod` p /= 0] in primes  -- is clearer
07:10:55 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
07:11:05 <kikero> reading https://en.wikibooks.org/wiki/Haskell/Fix_and_recursion right now
07:12:14 <phaazon> woah
07:12:21 <phaazon> I just ran my parser on a very huge file
07:12:27 <phaazon> it ran VERY quickly
07:12:30 <phaazon> and I’m in ghci
07:12:39 <phaazon> I’m using DList
07:12:48 <phaazon> I thought I’d be destroying the stack
07:14:33 <tsahyt> phaazon: attoparsec?
07:15:09 <phaazon> tsahyt: yep
07:15:21 <phaazon> the parser is written with attoparsec
07:15:26 <phaazon> and the lexer is a State with DList
07:15:32 <phaazon> (over the token stream)
07:16:05 <xolrup> :t fix
07:16:06 <lambdabot> (a -> a) -> a
07:16:54 <tsahyt> @src fix
07:16:55 <lambdabot> fix f = let x = f x in x
07:18:09 * ski prefers seeing it with `where' instead
07:20:56 <trubar8> Looking at Control.DeepSeq at https://hackage.haskell.org/package/deepseq-1.4.1.2/docs/Control-DeepSeq.html . What is an example of a type for which there cannot be an NFData instance written?
07:21:12 <trubar8> I.e. what kind of type cannot be fully evaluated?
07:22:09 <clrnd> mmm a function maybe?
07:22:37 <tsahyt> I don't even know what evaluation would mean for a function type
07:23:03 <ski> how about an `IO' action ?
07:23:07 <trubar8> clrnd: ah ok. Are there data structures for which it would be impossible to write down an NFData instance?
07:23:31 <quicksilver> data structures which include functions or IO actions
07:23:40 <trubar8> quicksilver: gotcha, thanks.
07:23:40 <lyxia> would fix f = f (fix f) be an equivalent definition of fix?
07:23:45 <quicksilver> ..or include other things which themselves include those.
07:24:00 <clrnd> I get your itch, I don't know the answer though
07:24:00 <quicksilver> lyxia: that has the same meaning, yes
07:24:14 <quicksilver> lyxia: the definition with 'where' manages to share some work though
07:24:24 <ski> lyxia : denotationally, yes. operationally, the other one is expected to have sharing, and so use less space
07:24:33 <lyxia> I see.
07:26:53 * hackagebot haskintex 0.5.1.0 - Haskell Evaluation inside of LaTeX code.  https://hackage.haskell.org/package/haskintex-0.5.1.0 (DanielDiaz)
07:49:50 <Lokathor> thingIWishWasInALibButHoogleSaysNo :: a -> (a -> (b,a)) -> [b]
07:50:55 <nshepperd> isn't that unfoldr but without a stopping condition?
07:51:01 <nshepperd> :t unfoldr
07:51:02 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
07:51:47 <Lokathor> well it sure seems like unfoldr without a stopping condition
07:51:55 <nshepperd> :t flip (unfoldr . fmap Just)
07:51:56 <lambdabot> b -> (b -> (a, b)) -> [a]
07:52:24 <Lokathor> well darn
07:53:13 * nshepperd spins around
07:55:52 <kikero> let sieve (p:ns) = p : sieve [n | n <- ns, n `mod` p /= 0]
07:56:26 <kikero> how do I call this function?
07:56:42 <Ankhers> sieve [1,2,3]
07:56:47 <Lokathor> you'd just use sieve [1,2,3]
07:57:09 <kikero> it returns [1*** Exception: <interactive>:45:5-58: Non-exhaustive patterns in function sieve
07:57:20 <Lokathor> note that if you call it on an empty list (sieve []) you'll crash
07:57:20 <kikero> I tried sieve [1..2]
07:57:35 <kikero> same answer
07:58:07 <nicow> Hi everybody, is there any way to print out the GC time (or simply productivity) between two traceEvent? I am using ghc-events-analyze which is really nice, and I would like to read the productivity only within on pair of START/STOP
07:58:08 <Ankhers> You are calling sieve recursively, you are probably getting an empty list ([]) at some point.
07:58:16 <Ankhers> kikero: ^^
07:58:27 <quicksilver> kikero: it's designed to be called on an infinite list
07:58:50 <Lokathor> take 10 $ sieve [1..]
07:58:53 <Lokathor> that won't crash
07:59:00 <quicksilver> you need to start with 2
07:59:08 <quicksilver> otherwise it strikes out all multiples of 1 :)
07:59:23 <Lokathor> oh yeah, that too
07:59:49 <quicksilver> you can call it on, e.g., [2..100]
07:59:53 <quicksilver> and it won't crash so fast
08:00:08 <kikero> I took ski's example: "let primes = sieve [2 ..]; sieve (p:ns) = p : sieve [n | n <- ns,n `mod` p /= 0] in primes"
08:00:58 <kikero> sieve is a function
08:01:09 <kikero> ns is the range
08:01:11 <ski> kikero : you could add `sieve [] = []' as an additional case
08:01:28 <kikero> so n takes any value of the range, except that it needs to return 0 on module
08:01:30 <kikero> * modulo
08:01:45 <kikero> but I don't understand where the p comes from
08:01:47 <ski> @let sieve [] = []; sieve (p:ns) = p : sieve [n | n <- ns,n `mod` p /= 0]
08:01:49 <lambdabot>  Defined.
08:01:55 <ski> > sieve [1,2,3]
08:01:56 <lambdabot>  [1]
08:02:00 <ski> > sieve [2,3,4]
08:02:02 <lambdabot>  [2,3]
08:02:48 <ski> kikero : `[]' is the empty list. if `x' is any value, and `xs' a list of that kind of values, then `x:xs' is that list, with `x' tacked on as an element in the front
08:02:54 <ski> > 1 : [2,3]
08:02:56 <lambdabot>  [1,2,3]
08:03:32 <ski> kikero : `sieve [] = []' is defining what `sieve xs' is to mean, when `xs' is the emtpy list (namely, then `sieve xs' is also the empty list, by the definition)
08:04:29 <ski> kikero : `sieve (p:ns) = ..p..ns..' is defining what `sieve xs' is to mean, when `xs' is a non-empty list, iow a list starting with the element (here named) `p' and continuing with the list of remaining elements `ns'
08:05:49 <ski> kikero : defining `sieve' like this, based on the two possible cases/shapes (a) empty list; (b) non-empty list, of the input, is called "pattern-matching"
08:06:16 <kikero> so, if pattern is non-empty list
08:06:43 <kikero> it returns the list filtered of elements that validate "n `mod` p /= 0"
08:06:46 <kikero> right?
08:06:50 <ski> then the result is `p : ...' meaning that the result should be a list starting with the element `p', and then continuing with a list of remaining elements
08:07:41 <ski> kikero : "the list filtered of elements that validate \"n `mod` p /= 0\"" would be `[n | n <- ns,n `mod` p /= 0]'
08:07:55 <ski> however, we're passing this list back again as input to a recursive call of `sieve'
08:08:29 <ski> each time we call `sieve', we make sure we're calling it with a list that starts with a prime (unless it's an empty list)
08:08:50 <ski> kikero : here's an example "trace" of it :
08:09:10 <ski>      sieve [2,3,4,5,6,7,8,9]
08:09:21 <ski>   =  sieve (2:[3,4,5,6,7,8,9])
08:09:49 <ski>   =  2 : sieve [n | n <- [3,4,5,6,7,8,9],n `mod` 2 /= 0]
08:10:00 <ski>   =  2 : sieve [3,5,7,9]
08:10:10 <ski>   =  2 : sieve (3:[5,7,9])
08:10:29 <ski>   =  2 : 3 : sieve [n | n <- [5,7,9],n `mod` 3 /= 0]
08:10:37 <ski>   =  2 : 3 : sieve [5,7]
08:10:45 <ski>   =  2 : 3 : sieve (5:[7])
08:10:57 <kikero> wow
08:11:00 <kikero> I understand
08:11:07 <ski>   =  2 : 3 : 5 : sieve [n | n <- [7], n `mod` 5 /= 0]
08:11:11 <ski>   =  2 : 3 : 5 : sieve [7]
08:11:20 <ski>   =  2 : 3 : 5 : sieve (7:[])
08:11:40 <ski>   =  2 : 3 : 5 : 7 : sieve [n | n <- [],n `mod` 7]
08:11:46 <ski>   =  2 : 3 : 5 : 7 : sieve []
08:11:48 <ski>   =  2 : 3 : 5 : 7 : []
08:11:53 <ski>   =  2 : 3 : 5 : [7]
08:11:57 <ski>   =  2 : 3 : [5,7]
08:11:59 <kikero> sieve' (p:ns) = p : [n | n <- ns,n `mod` p /= 0] if called as sieve' [3..] gets rid of all multiples of 3
08:12:01 <ski>   =  2 : [3,5,7]
08:12:05 <ski>   =  [2,3,5,7]
08:12:10 <kikero> sieve' [2..] gets rid of all multiples of 2, etc.
08:12:34 <ski> kikero : yes
08:13:27 <kikero> So, to have a function that lists all prime numbers smaller that x: let primes x = sieve [2..x]
08:13:53 <ski> > sieve [2 .. 11]
08:13:55 <lambdabot>  [2,3,5,7,11]
08:14:16 <ski> so, it's primes up to `x'
08:14:33 <paldepind> Is it correct that an associated type family must have the same parameters as the type class it belongs to?
08:14:35 <ski> to get a list of all primes, `sieve [2 ..]'
08:15:21 <kikero> let prime x y = [n | n <- sieve [2..x], n >= y]
08:15:22 <ski> paldepind : yes. possibly you can avoid ones that are functionally determined by others (that are mentioned), using FDs, though
08:15:40 <kikero> would return all primes in interval [y, x]
08:15:54 <ski> yes
08:15:59 <kikero> You guys made my day.
08:16:08 <kikero> This is one of the most beautiful things I've seen recently.
08:16:09 <kikero> Thank you.
08:16:25 <ski> yw
08:17:28 <paldepind> ski, Ok. Thank you. What is FDs? Functional dependency?
08:17:31 <ski> yes
08:17:54 <paldepind> I will keep that in mind. I haven't read about that yet.
08:18:07 <Hafydd> I'm going to just come right out and admit that I have a functional dependency.
08:18:41 <ski> paldepind : definition as in relational database theory
08:18:58 <lamefun> Is there a reliable way to use fold and not add space leaks?
08:20:50 <ski> paldepind : the FD `a b -> c' in `class Foo a b c d | a b -> c' logically means `forall a,b. unique c. exists d. Foo a b c d', which in turn means `forall a,b,c0,c1,d0,d1. (Foo a b c0 d0,Foo a b c1 d1) => c0 = c1'
08:21:20 <paldepind> So. Plain type ~= monomorphic function, parametrically polymorphic type ~= parametrically polymorphic function and type familly ~= type class?
08:21:46 <pnutus> "fmap ($ x) fs" is a pretty common pattern for me. Does it have a name? Couldn't find anything when I hoogled for "(Functor f) => f (a -> b) -> a -> f b"
08:21:56 * hackagebot amazonka-core 1.3.3.1 - Core data types and functionality for Amazonka libraries.  https://hackage.haskell.org/package/amazonka-core-1.3.3.1 (BrendanHay)
08:22:00 <ski> paldepind : you could also express the latter as `forall a0,a1,b0,b1,c0,c1,d0,d1. (Foo a0 b0 c0 d0,Foo a1 b1 c1 d1) => (a0 = a1 /\ b0 = b1 => c0 = c1)'
08:23:27 <ski> paldepind : iow, you can't have two instances of `Foo a b c d' where the `a' and `b' parameters agree, but the `c' parameters doesn't agree. for any fixed `a' and `b', there can be at most one `c' associated with them, by `Foo'
08:23:50 <ski> pnutus : .. in lambdabot, it used to be called `flip'
08:24:00 <paldepind> So if I know a and b I can always determine c?
08:24:05 <ski> paldepind : yes
08:24:36 <paldepind> Why is it "forall a,b. unique c. exists d" and not "forall a,b. unique c. forall d"?
08:24:44 <ski> `a b -> c' can be read "`a' and `b' (together) functionally determine `c'" (for instances re `Foo a b c d')
08:25:16 <ski> paldepind : parameters that are unmentioned in an FD are allowed to be anything, we don't care
08:25:50 <ski> paldepind : it's as if we had defined a new relation `Bar a b c' to be equivalent to `exists d. Foo a b c d', and instead asserted the FD on `Bar'
08:26:48 <paldepind> If they're allowed to be anything shouldn't it then be "forall d"?
08:26:54 <ski> paldepind : if you know anything about normalization in database theory, the same happens there
08:27:30 <ski> paldepind : it "turned" into a `forall' in the latter reformulation(s)
08:27:37 <paldepind> When you're normalizing a database you are getting rid of functionally dependent values?
08:28:24 <ski> you're factoring relations into a set of smaller relations, with some overlapping attributes, so that you can reconstruct the original relation from this
08:28:59 <ski> (the same basic idea can sometimes be useful with type classes)
08:29:27 <ski> paldepind : if you want to, i can show the exact logical reformulation that explains how the `exists' gets into a `forall' ?
08:30:59 <paldepind> "forall a,b. unique c. exists d" means that for any a and b we can determine a unique c and there will also be at least one d. Is that right?
08:31:50 <paldepind> But once we've choosen an `a` and a `b` we can't pick any `d`.
08:32:16 <ski> `unique a. ..a..' means `forall a0,a1. (..a0.. /\ ..a1..) => a0 = a1'
08:32:39 <ski> it means "there's at most one `a' such that `..a..'"
08:33:04 <ski> it means "given any `a0' and `a1' such that `..a0..' and `..a1..', in fact `a0' and `a1' would have to be the same thing"
08:33:59 <ski> consider the case `unique a. exists b. Baz a b', this means `forall a0,a1. (exists b. Baz a0 b) /\ (exists b. Baz a1 b) => a0 = a1'
08:34:23 <ski> which is the same as `forall a0,a1. (exists b0. Baz a0 b0) /\ (exists b1. Baz a1 b1) => a0 = a1'
08:34:29 <paldepind> Yes. I understand. I.e. forall a0,a1 (..a0.. -> a0 = a1)
08:34:41 <ski> which is the same as `forall a0,a1. (exists b0,b1. Baz a0 b0 /\ Baz a1 b1) => a0 = a1'
08:34:49 <ski> which is the same as `forall a0,a1,b0,b1. Baz a0 b0 /\ Baz a1 b1 => a0 = a1'
08:39:18 <sternenseemann> has anyone any experiences with sparql and haskell?
08:39:30 <sternenseemann> I guess hsparql is the best package
08:42:23 <paldepind> ski, hmm. I don't understand how that explains why `class Foo a b c d | a b -> c' means `forall a,b. unique c. exists d. Foo a b c d' and not `forall a,b. unique c. forall d. Foo a b c d'?
08:43:05 <ski> paldepind : clearly we want `forall a,b,c0,c1,d0,d1. (Foo a b c0 d0,Foo a b c1 d1) => c0 = c1', agree ?
08:44:07 <ski> "When `a', and also `b', agrees, then `c' also has to agree (never mind `d')"
08:44:39 <paldepind> ski, I thought we wanted `forall a,b,c0,c1,d. (Foo a b c0 d,Foo a b c1 d) => c0 = c1'..
08:45:15 <ski> no
08:45:25 <paldepind> But, that makes c dependant on d as well doesn't it?
08:45:30 <ski> the point is that `a' and `b', together', functionally determines `c'
08:45:38 <ski> `d' is irrelevant
08:46:44 <ski> for any two instances `Foo a0 b0 c0 d0' and `Foo a1 b1 c1 d1', if `a0 = a1' and `b0 = b1' .. iow, if we're really in the situation `Foo a b c0 d0' and `Foo a b c1 d1', for common `a' and `b' .. then it has to be that `c0 = c1'
08:46:57 * hackagebot hpqtypes 1.4.3 - Haskell bindings to libpqtypes  https://hackage.haskell.org/package/hpqtypes-1.4.3 (arybczak)
08:47:21 <ski> (`d0' may or may not be equal to `d1', we don't care)
08:48:23 * ski . o O ( "we don't care" <https://www.youtube.com/watch?v=CHgUN_95UAw> )
08:49:19 <paldepind> I get the part about `c` being uniquely determined when we know `a` and `b`. But `class Foo a b d' means `forall a,b.,d. Foo a b d'. And `class Foo a b c | a b -> c' means `forall a,b. unique c. Foo a b c'. Then it seems like the functional dependency alters `d`.
08:50:18 <ski> "But `class Foo a b d' means `forall a,b.,d. Foo a b d'." -- i don't see what you mean by this
08:50:51 <paldepind> What does it mean?
08:51:01 <ski> the `a b -> c' part of `class Foo a b c | a b -> c' (in that context), means `forall a,b. unique c. Foo a b c'
08:51:16 <ski> `class Foo a b d' doesn't mean any logical statement at all
08:53:00 <ski> if you said `class Foo a b c | a b -> c , a c d -> b', then you'd have two FDs, each expressing a logical statement. combined they express `(forall a,b. unique c. exists d. Foo a b c d) /\ (forall a,c,d. unique b. Foo a b c d)'
08:54:07 <ski> each FD generates a separate quantified version of the "class head"
08:55:02 <ski> if you had just `class Foo a b c', with no FDs, then there's no corresponding logical statements. combined (with a conjunction, as before), i suppose you could say they express `True', which always hold
08:55:50 <ski> paldepind : making any sense ?
08:56:58 * hackagebot geo-resolver 0.1.0.1 - Performs geo location lookups and parses the results  https://hackage.haskell.org/package/geo-resolver-0.1.0.1 (JanGreve)
08:57:49 <ski> (paldepind : .. er, i should have said `class Foo a b c d', not `class Foo a b c', there)
08:59:26 <paldepind> ski, Yes. I think I get it now. The functional dependency is expressing a logical statement about the values it mention. a, b, and c for instance in `a b -> c'. It doesn't say anything about other parameters that might appear in the type class.
09:01:50 <ski> paldepind : yes
09:02:56 <paldepind> ski, thanks a lot for you explanations :)
09:03:25 <hexagoxel> quicksilver: any suggestions regarding naming the package/module/datatype/functions for "BinaryDynamic"?
09:04:20 <hexagoxel> i tend towards bindynamic/Data.Dynamic.Binary/Dynamic/toDyn,fromDyn,etc.
09:05:45 <quicksilver> hexagoxel: I yes, I would keep the names of all the identifiers the same
09:05:48 <quicksilver> and just change the package name
09:05:57 <quicksilver> because it is so nearly the same API
09:06:58 * hackagebot haskintex 0.6.0.0 - Haskell Evaluation inside of LaTeX code.  https://hackage.haskell.org/package/haskintex-0.6.0.0 (DanielDiaz)
09:10:27 <obb> hi, have a little problem. this is not compiling and i'm not sure what i have to change: http://pastebin.com/1BczghNw
09:10:56 <obb> it complains about the second guard
09:11:08 <quicksilver> without looking, your whitespace is wrong
09:11:26 <quicksilver> ah no I was wrong :)
09:11:31 <quicksilver> obb: where goes after all the guards
09:11:35 <quicksilver> you can't mixup the wheres and the guards
09:11:52 <obb> ah ok
09:12:17 <quicksilver> you can make it a let, if you want it local to that expression, but some people don't like lets as much
09:13:26 <quicksilver> obb: isn't that going to die when it gets to the last element of hte list?
09:13:35 <quicksilver> won't match a:b:xs any more
09:13:56 <quicksilver> I think you want an encodeDirect [a] = [Single a]
09:13:57 <quicksilver> clause
09:14:27 <quicksilver> unless there is some property of your data that means that will never happen but it doesn't seem like it
09:14:44 <quicksilver> obb: also I think in 'discard' you have reimplemented the Prelude function 'drop'
09:15:08 <obb> shit i'm so clueless -.-
09:15:29 <quicksilver> don't be harsh on yourself
09:15:33 <quicksilver> the standard library is big :)
09:16:09 <obb> but i should be able to let it stand there right?
09:16:22 <obb> will it interfere with the prelude function?
09:17:20 <ski> paldepind : np
09:17:51 <obb> ah lol i didnt name it "drop" ok
09:20:35 <kazagistar> obb: your best friend for navigating the standard library is Hoogle (or Hayoo). Just write your intended type signature, and it will search for any matching functions.
09:26:02 <hexagoxel> quicksilver: thanks.
09:26:25 <mutantmell> kazagistar: Which of Hoogle/Hayoo is recommendeD?
09:27:14 <emmanuel_erc> hello there. I wouldn't be crazy by asking if there is a simple way to make a function that usuually works over a list to work on some other foldable/traversable type (like a Vector)?
09:27:18 <tommd> Any lambdabot OP here?  It seems lambdabot has found its way over to ##crypto and is unwelcome.
09:27:31 <hexagoxel> int-e: ^
09:28:00 <Welkin> lol
09:31:00 <hexagoxel> mutantmell: hayoo has more packages indexed, but hoogle (as i have heard, not sure) has better support for type queries.
09:31:42 <hexagoxel> my default now is hayoo.
09:32:13 <hexagoxel> ##crypto people like @nick, i guess :)
09:36:19 <bitemyapp> hexagoxel: there are hoogle installations that have all the packages
09:36:27 <bitemyapp> hexagoxel: and you can index hoogle against all of Hackage yourself if you wanted.
09:38:15 <hexagoxel> bitemyapp: i was vaguely aware of that, but had no link bookmarked. if you recommend anything over hayoo, perhaps forward a link to mutantmell?
09:43:33 <int-e> hexagoxel: thanks
09:45:54 <bitemyapp> hexagoxel: https://www.stackage.org/ has a hoogle
09:45:58 <bitemyapp> mutantmell: https://www.stackage.org/ has a hoogle
09:46:08 <ReinH> Also try the FP Complete hoogle, which is more... complete..
09:46:14 <ReinH> Yes that.
09:46:16 <bitemyapp> ReinH: that's what the Stackage one is now.
09:46:22 <bitemyapp> mutantmell: you can install hoogle yourself and have it index all the types from Hackage, so you have a complete search.
09:46:25 <ReinH> bitemyapp: I was catching up :)
09:46:36 <bitemyapp> I am low latency text creature
09:46:47 <bitemyapp> ReinH: vim or emacs?
09:46:57 <ReinH> For?
09:47:01 <bitemyapp> editing Haskell code
09:47:04 <ReinH> emacs
09:47:07 <bitemyapp> ReinH: on a scale of 0 to lovely, how happy are you with the indentation?
09:47:12 <ReinH> But spacemacs, so both.
09:47:17 <bitemyapp> emacs for our purposes.
09:47:20 <ReinH> I use structured haskell mode and hindent.
09:47:24 <bitemyapp> the indenters have been giving me a lot of grief lately.
09:47:32 <bitemyapp> okay, SHM/hindent are side-stepping it.
09:47:46 <bitemyapp> I haven't had fantastic luck getting hindent to parse my code.
09:47:50 <bitemyapp> I seem to write code that makes it hang?
09:47:53 <bitemyapp> really odd.
09:48:07 <ReinH> good work?
09:48:22 <bitemyapp> ReinH: not really. I have a unfortunate history with tooling. I make things break.
09:48:27 <bitemyapp> I'd like to use hindent.
09:49:03 <ReinH> heh
09:49:35 * geekosaur passes around the "human fuzzer" shirts
09:49:52 <bitemyapp> it really is what I am.
09:49:54 <bitemyapp> it's awful.
09:55:07 <pie_tab> Is HaskellR as awesome as it sounds?
09:56:38 <pie_tab> also how feasible is haskell for projects that need to be fast because of computation-heavyness? i want to invest time into learning haskell because of its supposedly less bug prone, maybe using the ffi to optimize hotspots...
09:57:07 <pie_tab> if i ever do anything compute heavy it will probably be physics simulation
09:57:20 <pie_tab> or neural network related
09:59:25 <hodapp> pie_tab: depends on how much premature optimization you're willing to not do.
09:59:46 <pie_tab> well premature optimization is premature...
10:00:04 <hodapp> pie_tab: and some folks still can't handle premature optimization being made more difficult.
10:00:13 <pie_tab> actually, i wonder how much scientific code is written in "good" C
10:00:23 <hodapp> not nearly as much as in "bad" FORTRAN
10:00:24 <pie_tab> i haave some kind of prejudice againsts scientists writing code
10:00:36 <Hafydd> Approximately 0%.
10:00:50 <pie_tab> i get the feeling science departments should have a dedicated support programmer
10:00:56 <hodapp> To be fair, a lot of them aren't worse at it than a lot of professional "software developers".
10:01:01 <squall> It's all in c and Fortran
10:01:06 <bitemyapp> pie_tab: they sometimes do
10:01:15 <bitemyapp> pie_tab: it's grubby and unpleasant work and doesn't pay well though.
10:01:40 <pie_tab> bitemyapp, i can imagine :/
10:01:45 <squall> That's literally my job
10:02:07 <pie_tab> squall, id say cool...but support roles dont sound very fun :(
10:02:24 <squall> It's cool physics is great
10:02:27 <pie_tab> :D
10:02:37 <squall> I'm incorporating Haskell
10:02:44 <pie_tab> so you want to write a blog post or something about code quality in scientific circles or something?
10:03:07 <squall> It generates c. That's how I sold it so I'm going to have to do some ffi stuff
10:03:07 <pie_tab> though i guess i should just google, andway back t my original question
10:03:55 <squall> What was that?
10:04:07 <hodapp> hmm, I'm generating C right now
10:04:17 <squall> Cool beans
10:04:36 <squall> I can't compile from my phone
10:04:55 <squall> That's the first thing I'd write
10:05:00 <pie_tab> hodapp, so how does it depend on how much premature optimization im willing to do?
10:05:54 <hodapp> pie_tab: willing to *not* do, not willing to do.
10:06:16 <pie_tab> oops, i skimmed over that :P
10:06:35 <pie_tab> im perfectly fine with proper development practice, i.e. profiling
10:06:42 <pie_tab> no idea how to do it yet though
10:06:58 <pie_tab> ive read a lot of meta, but very little actual practice :/
10:07:15 <squall> I get told that when I ask about optimisation. It's probably the correct response, but discussions of theories about optimisation are better really.
10:07:58 <pie_tab> i dont understand what you mean by your last sentence
10:08:48 <cocreature> pie_tab: with stuff like neural networks it's probably hard to beat libraries where people have put a lot of effort into like theano or torch, but that's not really a problem of the language but of the amount of effort you put in
10:09:32 <pie_tab> cocreature, right, im happy as long as there is an interface for the given language
10:09:52 <pie_tab> ive heard the names of those packages but dont know anything about them
10:09:56 <squall> It might be better for the individual who is falling to consolidate material to drop potentially distracting optimisation considerations. But if they have spent time generating reflections on optimisation it could be worth discussing them
10:10:19 <pie_tab> ah.
10:12:29 * hackagebot amazonka 1.3.3.1 - Comprehensive Amazon Web Services SDK.  https://hackage.haskell.org/package/amazonka-1.3.3.1 (BrendanHay)
10:12:31 * hackagebot amazonka-test 1.3.3.1 - Common functionality for Amazonka library test-suites.  https://hackage.haskell.org/package/amazonka-test-1.3.3.1 (BrendanHay)
10:12:33 * hackagebot amazonka-config 1.3.3.1 - Amazon Config SDK.  https://hackage.haskell.org/package/amazonka-config-1.3.3.1 (BrendanHay)
10:12:35 * hackagebot amazonka-sns 1.3.3.1 - Amazon Simple Notification Service SDK.  https://hackage.haskell.org/package/amazonka-sns-1.3.3.1 (BrendanHay)
10:12:37 * hackagebot amazonka-ecs 1.3.3.1 - Amazon EC2 Container Service SDK.  https://hackage.haskell.org/package/amazonka-ecs-1.3.3.1 (BrendanHay)
10:12:51 <pie_tab> re:optimization, internet says somewhat optimized c code is faster than optimized haskell and optimizing haskell makes it ugly
10:12:55 <pie_tab> what say you?
10:12:58 <squall> So I kind of don't like the stock response, I'm inclined to feel regret I'm maybe having wasted time, and really I think the problem is that it was only a pointless consideration if it never materialises, but that discussion may be such a realisation.
10:13:41 <pie_tab> i guess.
10:13:42 <squall> I'm sorry I don't have benchmarks to quantify such scenarios
10:14:13 <squall> But if I do my ffi stuff I might
10:14:40 <pie_tab> well i mean its evident in my opinions, but for the sake of argument lets assume its true? i dont think its such an absurd idea
10:14:47 <pie_tab> *opinion
10:15:23 <pie_tab> this is a thread i was reading https://news.ycombinator.com/item?id=5080210
10:15:42 <pie_tab> and this http://stackoverflow.com/questions/6964392/speed-comparison-with-project-euler-c-vs-python-vs-erlang-vs-haskell
10:15:46 <pie_tab> but i didnt read the code
10:15:51 <squall> Far from thinking optimisation considerations to be fruitless, in face of difficulties rationalising about this, it is my top priority
10:17:39 * hackagebot amazonka-sqs 1.3.3.1 - Amazon Simple Queue Service SDK.  https://hackage.haskell.org/package/amazonka-sqs-1.3.3.1 (BrendanHay)
10:17:41 * hackagebot amazonka-glacier 1.3.3.1 - Amazon Glacier SDK.  https://hackage.haskell.org/package/amazonka-glacier-1.3.3.1 (BrendanHay)
10:17:43 * hackagebot amazonka-cloudhsm 1.3.3.1 - Amazon CloudHSM SDK.  https://hackage.haskell.org/package/amazonka-cloudhsm-1.3.3.1 (BrendanHay)
10:18:23 <squall> But this guy can't use Haskell properly obviously, he probably had a bottleneck somewhere.
10:18:32 <cocreature> pie_tab: just look at the first comment
10:18:42 <pie_tab> i read the comments and stuff just not the code
10:18:53 <cocreature> he does some simple changes which really don't make the code ugly and improves the runtime to be faster than the c version
10:19:15 <pie_tab> and then there is a post where someone fixes up the c version as well
10:19:35 <pie_tab> its the whole surface knowledge vs being somewhat more knowledgeable in a tools usage
10:20:08 <pie_tab> though people suggest haskell has a much steeper "grokking" curve
10:20:28 <squall> Haskell is fine
10:20:47 <pie_tab> i still intend to try haskell, im just shuffling my prioritizations around
10:21:01 <squall> It's all I have ever written in and I found no steep grokking
10:21:10 <hodapp> I feel as though for most folks, it's more about un-learning than learning.
10:21:11 <pie_tab> ok i guess
10:21:42 <pie_tab> hodapp, i like to imagine i have high plasticity :P but modality is a pain in the ass...i forget csemicolons in c because of python
10:21:54 <squall> It's notoriously harder to learn a second language compared to the first
10:21:54 <f-a> javascript javascript javascript, I am willing to try one of ghcjs/haste. Is there any particular reason to prefer one or the other?
10:22:16 <squall> Haskell to c is brutal
10:22:24 <hodapp> pie_tab: I juggle Haskell, Python and C all day. It's plenty doable.
10:22:33 <squall> You just immediately implement Haskell badly
10:22:34 <pie_tab> hodapp, yay :)
10:22:42 <pie_tab> squall, haha
10:23:06 <pie_tab> hodapp, thats going to be my trio
10:23:11 <pie_tab> well, im learning R right now
10:23:15 <squall> Yeh I should brush up on my c
10:23:18 <hodapp> squall: I implemented something in Haskell which lets me compose C functions (via Ivory) in continuation-passing style
10:23:26 <hodapp> squall: it's very slick, but also rather weird.
10:23:40 <squall> The more sophisticated approach is to implement c badly in Haskell
10:24:05 <hodapp> squall: That's arguably what I'm doing...
10:24:08 <pie_tab> squall, im not sure which is worse :P
10:24:16 <hodapp> squall: Or, it's what Ivory does.
10:24:31 <squall> Link
10:24:34 <squall> Plz
10:24:41 <pie_tab> man, perfornance meta-ing is hard
10:24:45 <squall> If you have one
10:25:04 <davean> pie_tab: Huh, is there a particular circumstance where you tend to forget them?
10:25:08 <davean> pie_tab: anything that might be triggering that?
10:25:11 <pie_tab> i wonder if ill ever want to combine r, haskell, r ffi, and haskell ffi, and c
10:25:11 <hodapp> squall: https://github.com/galoisinc/ivory
10:25:20 <pie_tab> davean, lack of experience :P
10:25:22 <squall> pie_tab, which benchmarking package are you using?
10:25:41 <pie_tab> squall, nothing, as i said, too much meta, too little code xD
10:25:49 <hodapp> squall: my library: https://github.com/HaskellEmbedded/ion
10:25:49 <pie_tab> i do have a projec idea though
10:25:58 <squall> hodapp, sorry, I meant for the stuff you were writing, I know ivory is public
10:26:08 <squall> Aha cool thanks
10:26:11 <pie_tab> so after i figure out if its feasible im going to try doing it
10:26:29 <pie_tab> i tend to jump balls first into cold water :X
10:26:40 <hodapp> pie_tab: I'm intending to learn R but I haven't done much with it yet besides poke around in some tutorial
10:27:01 <squall> Haskell embedded. Why would I want c embedded in my code? No i think more is generating pretty c my problem.
10:27:09 <pie_tab> hodapp, i did a little metaing around on what to use to learn and im using the swirl package right now
10:27:15 <hodapp> swirl?
10:27:21 <pie_tab> google it
10:27:27 <pie_tab> also, rstudio seems nice
10:27:32 <pie_tab> im using it as well
10:27:52 <hodapp> squall: This isn't about embedding Haskell, it's about embedded platforms
10:28:05 <pie_tab> hodapp, here zou go: http://swirlstats.com/
10:30:08 <hodapp> pie_tab: are you liking Swirl?
10:30:34 <pie_tab> hodapp, it seems like a good ...well i want to call it a crash course
10:30:47 <pie_tab> given your experience i imagine you shouldnt haveany problems
10:30:52 <pie_tab> its really handhldy though
10:30:58 <pie_tab> *hand-holdy
10:31:38 <pie_tab> pacckage manaegment is simple enough in r, it seems like you should be able to do most anything from the shell, so grab rstudio and follow the install guide for swirl on the site
10:32:47 <squall> Namely, pretty refactoring of ugly c to pretty c. Pretty as in that it is in a Haskell idiom
10:33:50 <squall> As would be achieved by translation of c to pretty Haskell
10:34:11 <epta> is hackage extremely slow for everyone or is it just for me?
10:34:29 <hodapp> squall: I have no idea how that would be achieved
10:34:34 <bitemyapp> epta: slow for me too
10:34:39 <bitemyapp> epta: not extremely, but it is slow, yes.
10:35:23 <hodapp> squall: C is full of incidental side effects and behavior where there's often no good way to discern the programmer's intentions, and no good way to tell intentional side effects from incidental ones
10:35:24 <epta> now it's responding with 503s :(
10:36:48 <squall> Prettyfiers in Haskell and prettyness preserving translation from c to Haskell and back
10:37:28 <hodapp> squall: How could you have any sort of meaningful isomorphism between Haskell and C here?
10:37:37 <squall> Hodapp, I would presume I had been given fully free of unwanted behavior
10:37:37 <pie_tab> considering suggesing to my friends to use certain tools is really making me think about complexity :/
10:37:48 <pie_tab> you cant make everyone use latex
10:38:03 <hodapp> suppi: There is no basically such thing in C
10:38:30 <pie_tab> well we do have a C class so i should be comfortable recommending r to them afterwards..just hope they dont get confused or something
10:38:41 <pie_tab> i keep having to remind myself that people arent stupid either
10:38:56 <cocreature> R and C are pretty different beasts
10:39:15 <pie_tab> itll be the first programming language for most of my "classmates"
10:39:27 <squall> hodapp, I also presume an implementation of c and Haskell written in each other. It might not be prohibitive that these implementations be limited.
10:39:40 <pie_tab> well, ok a lot of them met with programming in high school or something, but high school computer education is a joke
10:39:45 <hodapp> squall: how would the *implementation* of C change any of this?
10:39:58 <cocreature> squall: well then you basically get a hardcoded c interpreter in haskell not an idiomatic haskell version of your c code
10:40:06 * hackagebot amazonka-dynamodb 1.3.3.1 - Amazon DynamoDB SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-1.3.3.1 (BrendanHay)
10:40:07 <squall> How would the implementation of Haskell not?
10:40:08 * hackagebot amazonka-datapipeline 1.3.3.1 - Amazon Data Pipeline SDK.  https://hackage.haskell.org/package/amazonka-datapipeline-1.3.3.1 (BrendanHay)
10:40:10 * hackagebot amazonka-iam 1.3.3.1 - Amazon Identity and Access Management SDK.  https://hackage.haskell.org/package/amazonka-iam-1.3.3.1 (BrendanHay)
10:40:12 * hackagebot amazonka-kinesis-firehose 1.3.3.1 - Amazon Kinesis Firehose SDK.  https://hackage.haskell.org/package/amazonka-kinesis-firehose-1.3.3.1 (BrendanHay)
10:40:14 * hackagebot amazonka-route53-domains 1.3.3.1 - Amazon Route 53 Domains SDK.  https://hackage.haskell.org/package/amazonka-route53-domains-1.3.3.1 (BrendanHay)
10:40:28 <EvanR> hodapp: jusdicious use of passing everything by value in C, even returning structs from functions
10:40:31 <ReinH> squall: I don't think it's a good idea to write C in a "Haskell idiom".
10:40:41 <ReinH> I think C should be written in a C idiom.
10:40:42 <squall> It was my premise that pretty c was idiomatic of Haskell by definition.
10:40:43 <EvanR> judicious
10:40:56 <ReinH> What?
10:41:06 <ReinH> By what definition?
10:41:07 <squall> I would need to write Haskell in a c idiom
10:41:24 <ReinH> What do C and Haskell have to do with each other, regardless of prettiness?
10:41:25 <EvanR> theres straightforward things you can do in C and they are not a good idea because performance (not really but its the C way to complain about this)
10:41:26 <hodapp> EvanR: That would involve making lots of copies that may or may not be intended
10:41:56 <EvanR> hodapp: right but ignoring that issue, its possible to maintain simpler semantics in C
10:42:05 <EvanR> to a point
10:42:24 <squall> My definition of prettyness which I used to phrase my definition of the task, a c prettier for a Haskell user
10:42:47 <ReinH> Ok, so you're say ing that C would look more like Haskell if it looked more like Haskell.
10:43:09 <cocreature> looks correct to me :)
10:43:10 <ReinH> I still don't agree with your premise.
10:43:23 <ReinH> But I can't disagree with your conclusion, since it's tautological.
10:44:05 <squall> I'm saying to build such a tool I would need a Haskell prettier and two prettyness preserving transformations and maybe an implementation of c in Haskell
10:44:14 <ReinH> ...
10:44:16 <hodapp> ...
10:44:21 <squall> Prrettyfier
10:44:27 <ReinH> still ...
10:44:27 <squall> Sorry
10:44:52 <EvanR> like pretty printing of the syntax of C? 
10:44:57 <EvanR> what?
10:45:04 <hodapp> squall: What I've been asking from the start how a correctness-preserving transformation can exist in both directions - much less one that gives pretty results.
10:45:08 <squall> What is this dots? Have I been unclear still?
10:45:16 * hackagebot amazonka-directconnect 1.3.3.1 - Amazon Direct Connect SDK.  https://hackage.haskell.org/package/amazonka-directconnect-1.3.3.1 (BrendanHay)
10:45:16 <ReinH> This is a fool's errand.
10:45:18 * hackagebot amazonka-elasticsearch 1.3.3.1 - Amazon Elasticsearch Service SDK.  https://hackage.haskell.org/package/amazonka-elasticsearch-1.3.3.1 (BrendanHay)
10:45:20 * hackagebot amazonka-devicefarm 1.3.3.1 - Amazon Device Farm SDK.  https://hackage.haskell.org/package/amazonka-devicefarm-1.3.3.1 (BrendanHay)
10:45:22 * hackagebot amazonka-cognito-sync 1.3.3.1 - Amazon Cognito Sync SDK.  https://hackage.haskell.org/package/amazonka-cognito-sync-1.3.3.1 (BrendanHay)
10:45:24 * hackagebot amazonka-elb 1.3.3.1 - Amazon Elastic Load Balancing SDK.  https://hackage.haskell.org/package/amazonka-elb-1.3.3.1 (BrendanHay)
10:45:37 <ReinH> Even if you could do such a thing, a C program that looked more like a Haskell program would probably be a worse C program.
10:45:57 <EvanR> alternatively the haskell version would look terrible
10:46:00 <squall> I did hear that consideration earlier.
10:46:01 <EvanR> and be terrible
10:46:08 <ReinH> But anyway you can't have meaning preserving transformations when there's no meaning to preserve.
10:46:24 <EvanR> C semantics!
10:46:36 <cocreature> just translate it to the haskell undefined
10:46:43 <cocreature> that's close enough to the c semantics
10:46:54 <ReinH> So perhaps you restrict yourself to a subset of C with well defined operational semantics. But still, C and Haskell are very different languages with very different runtimes. It's just a bad idea.
10:47:58 <ReinH> What you could do is write your C in Haskell and then compile it to C. But we can already do that.
10:48:09 <hodapp> I do that.
10:48:10 <EvanR> your implementation of C can give definite semantics for every case of undefined behavior
10:48:11 <squall> It sparked from my statement that as a naive c programmer my reflex is to badly implement Haskell. And I see people trying to brute force pointers in Haskell. Such implementations are possible, and it would maybe lead to a prettyfier in c in a Haskell idiom
10:48:44 <ReinH> What? Who has ever tried to "brute force pointers" in Haskell?
10:48:52 <cocreature> what does that even mean?
10:48:56 <ReinH> I don't know.
10:48:59 <squall> ReinH the meaning to preserve is the idiom
10:49:07 <ReinH> What does that mean?
10:49:10 <EvanR> unsafeCoerce :: [Int] -> Ptr a
10:49:25 <ReinH> What is "the idiom"? How do you define an "idiom preserving" transformation? This is just word salad.
10:49:33 <squall> We have two bad implementations of both language written in each other
10:49:53 <hodapp> ...we do?
10:50:02 <squall> A Haskell prettyfier could then be used to produce pretty c
10:50:11 * EvanR suggests a haskell DSL which will output C-idiomatic C
10:50:19 <EvanR> not the same as compiling as C
10:50:19 <squall> If we did
10:50:26 * hackagebot amazonka-cloudformation 1.3.3.1 - Amazon CloudFormation SDK.  https://hackage.haskell.org/package/amazonka-cloudformation-1.3.3.1 (BrendanHay)
10:50:27 <cocreature> EvanR: that's ivory no?
10:50:28 * hackagebot amazonka-sts 1.3.3.1 - Amazon Security Token Service SDK.  https://hackage.haskell.org/package/amazonka-sts-1.3.3.1 (BrendanHay)
10:50:30 * hackagebot amazonka-kinesis 1.3.3.1 - Amazon Kinesis SDK.  https://hackage.haskell.org/package/amazonka-kinesis-1.3.3.1 (BrendanHay)
10:50:32 * hackagebot amazonka-kms 1.3.3.1 - Amazon Key Management Service SDK.  https://hackage.haskell.org/package/amazonka-kms-1.3.3.1 (BrendanHay)
10:50:34 * hackagebot amazonka-cloudsearch-domains 1.3.3.1 - Amazon CloudSearch Domain SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-domains-1.3.3.1 (BrendanHay)
10:50:34 <EvanR> also not the same as "haskell in C" at all
10:50:35 <squall> It's a requisit
10:50:41 <EvanR> cocreature: orly?
10:51:46 <hodapp> EvanR: Ivory has an EDSL that handles most of (but not all) of C; it embeds the C type system along with a couple other constraints (e.g. you cannot return a pointer to a stack variable)
10:52:15 <squall> My statement. The naive implementation of languages in terms of each other leads to a prettyfier
10:52:17 <EvanR> you cant assign a pointer to a local variable?
10:52:49 <cocreature> EvanR: you can't have a function return a pointer to it's stack as that will be invalid anyway
10:53:17 <EvanR> oh
10:53:45 <squall> Rewrite the c code in a Haskell idiom. Why is that a bad idea?
10:53:50 <ReinH> squall: Does the pretty code have to work? Because if it doesn't have to work then it's pretty easy to meet any other requirement.
10:53:58 <hodapp> EvanR: Suppose you have a scope. Suppose you make a variable on this scope's stack. C will let you return a pointer to that variable - but that is not a sensible thing to do.
10:54:11 <EvanR> yes so its stops you from doing obvious stupid things in C
10:54:25 <squall> Of course it should still do exactly what it did
10:54:43 <EvanR> squall: cool so check out ivory
10:54:53 <hodapp> EvanR: yeah, certain obvious stupid things, though it errs on the side of paranoia even when it keeps you from doing things that are still safe
10:55:11 <ReinH> squall: I don't even understand how making Haskell prettier is supposed to make C prettier. This whole thing is silly.
10:55:36 * hackagebot amazonka-cloudwatch 1.3.3.1 - Amazon CloudWatch SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-1.3.3.1 (BrendanHay)
10:55:37 <squall> Ivory is C embedded in Haskell
10:55:38 * hackagebot amazonka-cloudtrail 1.3.3.1 - Amazon CloudTrail SDK.  https://hackage.haskell.org/package/amazonka-cloudtrail-1.3.3.1 (BrendanHay)
10:55:40 * hackagebot amazonka-elasticache 1.3.3.1 - Amazon ElastiCache SDK.  https://hackage.haskell.org/package/amazonka-elasticache-1.3.3.1 (BrendanHay)
10:55:42 * hackagebot amazonka-waf 1.3.3.1 - Amazon WAF SDK.  https://hackage.haskell.org/package/amazonka-waf-1.3.3.1 (BrendanHay)
10:55:44 * hackagebot amazonka-importexport 1.3.3.1 - Amazon Import/Export SDK.  https://hackage.haskell.org/package/amazonka-importexport-1.3.3.1 (BrendanHay)
10:55:44 <ReinH> No it isn't.
10:56:12 <EvanR> even if it were thats what you suggested to make
10:56:25 <squall> ivorylang.org
10:56:26 <squall> You can think of Ivory as a safer C, embedded inHaskell. The Ivory Language compiler is open source ...
10:56:29 <ReinH> Ivory is a DSL for *generating* C. That's like saying a cake is embedded in the recipe for a cake.
10:56:36 <ReinH> I could, but that would be wrong so I choose not to.
10:56:57 <hodapp> EvanR: Another thing: It maintains a difference between a reference and a pointer, even though in the underlying C, they're the same thing. References can be turned to pointers with no other action, but pointers can only be turned to references through a function that does a null check and must have a default.
10:57:02 <squall> Aha lol
10:57:03 <ReinH> I know what ivory is.
10:57:08 <squall> I don't
10:57:14 <ReinH> Ok then.
10:57:15 <EvanR> Safer-C: Now you will see my final form!
10:57:24 <squall> But that's on the ivory Google intro
10:57:45 <squall> Your phrasing is much more informative thanks
10:57:59 <ReinH> squall: fair enough
10:58:01 <EvanR> hodapp: "pointer" in this case being a numeric address?
10:58:20 <EvanR> which supports arithmetic
10:58:31 <Welkin> EvanR: No! No one has ever lived to see EvanR's 3rd form!
10:58:32 <EvanR> and references have the power to be dereferenced
10:58:47 <ReinH> Specifically, here's what they mean: "Embedded: Ivory is implemented as a library of the Haskell programming language. Ivory programs are written using Haskell syntax and types."
10:58:50 <ReinH> from http://ivorylang.org/ivory-introduction.html
10:59:08 <hodapp> EvanR: sorry, 'pointer' is nullable, 'reference' is not, but in neither case can do you arithmetic
10:59:16 <squall> So ivory is Haskell to c in the c idiom. I can take this and turn it into c in a Haskell idiom?
10:59:22 <EvanR> interesting ....
10:59:28 <ReinH> It's "embedded" in the sense of EDSL.
10:59:41 <hodapp> EvanR: arrays in Ivory are a third type still (well... a whole family of types)
10:59:49 <hodapp> (indexed over size)
10:59:49 <EvanR> hodapp: but pointer arithmetic is the meat and potatoes of C!
10:59:56 <squall> Well on is that a pokemon reference? Lol
11:00:07 <ReinH> I don't know what you mean by "idiom" any more.
11:00:16 <Welkin> squall: dragon ball
11:00:36 <squall> Welkin^
11:00:40 <squall> ok
11:00:44 <hodapp> EvanR: Yup. Too bad...
11:00:46 * hackagebot amazonka-s3 1.3.3.1 - Amazon Simple Storage Service SDK.  https://hackage.haskell.org/package/amazonka-s3-1.3.3.1 (BrendanHay)
11:00:48 * hackagebot amazonka-swf 1.3.3.1 - Amazon Simple Workflow Service SDK.  https://hackage.haskell.org/package/amazonka-swf-1.3.3.1 (BrendanHay)
11:00:50 * hackagebot amazonka-sdb 1.3.3.1 - Amazon SimpleDB SDK.  https://hackage.haskell.org/package/amazonka-sdb-1.3.3.1 (BrendanHay)
11:00:52 * hackagebot amazonka-codecommit 1.3.3.1 - Amazon CodeCommit SDK.  https://hackage.haskell.org/package/amazonka-codecommit-1.3.3.1 (BrendanHay)
11:00:54 * hackagebot amazonka-codedeploy 1.3.3.1 - Amazon CodeDeploy SDK.  https://hackage.haskell.org/package/amazonka-codedeploy-1.3.3.1 (BrendanHay)
11:02:01 <EvanR> i just got amazonkad
11:02:13 <squall> You would need to use good c idiom in your implementation of Haskell in c
11:02:33 <ReinH> ...
11:02:55 <squall> But that these considerations would be fine with and then Haskell idiom takes over
11:02:56 <ReinH> Haskell is implemented in C.
11:02:56 <EvanR> a slow bug-ridden or any other implementation of haskell is C is not very idiomatic
11:03:12 <squall> I'm talking about defining map e.t.c.
11:03:29 <squall> In c
11:03:34 <EvanR> theres no way!
11:03:42 <ReinH> But I don't see how implementing Haskell in C or C in Haskell gets you what you want, or that what you want is achievable, or that what you want is defined at all.
11:03:50 <ReinH> EvanR: Sure there is. Step 1: write GHC.
11:04:11 <EvanR> idiom and idiomatic here are undefined to the point where people are talking over / past each other
11:04:16 <squall> No! Step one, define map in c
11:04:20 <ReinH> So is "prettier".
11:04:23 <nshepperd> you can't implement map as a C function in a type safe way
11:04:37 <nshepperd> the C type system is not strong enough
11:05:23 <squall> You don't implement Haskell as in write ghc, you program in Haskell idiom using higher order functions of Haskell implemented in c
11:05:32 <ReinH> Which you can't do.
11:05:38 <Welkin> why would haskell be implemented in C?
11:05:42 <ReinH> And to the extent that you can, probably don't want to.
11:05:45 <Welkin> it is implemented in... Haskell
11:05:50 <Welkin> and compiled down to binary
11:05:55 <squall> The task is to implement the higher order functions
11:05:56 <ReinH> Because C is not Haskell.
11:05:56 * hackagebot amazonka-cloudfront 1.3.3.1 - Amazon CloudFront SDK.  https://hackage.haskell.org/package/amazonka-cloudfront-1.3.3.1 (BrendanHay)
11:05:58 * hackagebot amazonka-efs 1.3.3.1 - Amazon Elastic File System SDK.  https://hackage.haskell.org/package/amazonka-efs-1.3.3.1 (BrendanHay)
11:06:00 * hackagebot amazonka-codepipeline 1.3.3.1 - Amazon CodePipeline SDK.  https://hackage.haskell.org/package/amazonka-codepipeline-1.3.3.1 (BrendanHay)
11:06:02 * hackagebot amazonka-elasticbeanstalk 1.3.3.1 - Amazon Elastic Beanstalk SDK.  https://hackage.haskell.org/package/amazonka-elasticbeanstalk-1.3.3.1 (BrendanHay)
11:06:04 * hackagebot amazonka-autoscaling 1.3.3.1 - Amazon Auto Scaling SDK.  https://hackage.haskell.org/package/amazonka-autoscaling-1.3.3.1 (BrendanHay)
11:06:06 <ReinH> Welkin: GHC still has a C core.
11:06:12 <Welkin> C--
11:06:13 <hodapp> a creamy C center?
11:06:25 <ReinH> Welkin: I'm not talking about the representation of haskell code.
11:06:39 <Welkin> glorified assembly
11:06:40 <ReinH> I'm talking about the GHC compiler and the GHC runtime.
11:07:08 <ReinH> GHC is not fully self-hosting.
11:07:35 <EvanR> im referring to quick groups of 5 messages from lambdabot as a "zonk" from now on
11:07:44 <squall> Simply define the higher order functions which enable Haskell idiom to prevail to a limited extent in a c refactoring tool
11:07:58 <ReinH> squall: "simply" do the impossible, go tit.
11:08:03 <ReinH> *got it
11:08:11 <squall> This is the second priority of my phd
11:08:47 <ReinH> squall: Even if it were possible, you don't want Haskell idioms to prevail in a C refactoring tool. You want C idioms to prevail.
11:08:59 <ReinH> A refactoring tool that made C more like Haskell would just make it worse C.
11:09:01 <squall> Ok, I'm sorry I didn't know you were certainly telling me it's impossible to define map and fold in c. Your wrong
11:09:17 <mniip> it's not impossible
11:09:21 <mniip> but it's not desirable
11:09:24 <EvanR> its pretty impossible
11:09:33 <squall> What!?
11:09:36 <hodapp> if you want it type-safe, yes, it's impossible.
11:09:37 <ReinH> For some value of "map" and "fold", it is possible. For some other value, it isn't.
11:09:55 <mniip> type-safe in C? hahaha
11:09:55 <EvanR> whatever the value, heres the type 
11:09:57 <EvanR> :t map
11:09:59 <lambdabot> (a -> b) -> [a] -> [b]
11:09:59 <ReinH> You can write functions with a similar shape, but they won't share the properties of map and fold in Haskell.
11:10:04 <EvanR> glwt
11:10:21 <ReinH> And in any event, a program that rewrote C programs in terms of map and fold wouldn't be useful
11:10:27 <ReinH> Because it would make C programs worse.
11:10:47 <mniip> well the issue here seems to be, specifically, that C has no type-safe uniform polymorphism
11:10:52 <squall> I'm not implementing type safety, I'm implementing map to replace a subset of the behaviour of a for loop, and hopefully all other behaviours of all other for loops I encounter
11:11:06 * hackagebot amazonka-ses 1.3.3.1 - Amazon Simple Email Service SDK.  https://hackage.haskell.org/package/amazonka-ses-1.3.3.1 (BrendanHay)
11:11:08 * hackagebot amazonka-support 1.3.3.1 - Amazon Support SDK.  https://hackage.haskell.org/package/amazonka-support-1.3.3.1 (BrendanHay)
11:11:10 * hackagebot amazonka-dynamodb-streams 1.3.3.1 - Amazon DynamoDB Streams SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-streams-1.3.3.1 (BrendanHay)
11:11:12 * hackagebot amazonka-redshift 1.3.3.1 - Amazon Redshift SDK.  https://hackage.haskell.org/package/amazonka-redshift-1.3.3.1 (BrendanHay)
11:11:12 <teclo-> there's nothing type-safe in C anyway
11:11:14 * hackagebot amazonka-opsworks 1.3.3.1 - Amazon OpsWorks SDK.  https://hackage.haskell.org/package/amazonka-opsworks-1.3.3.1 (BrendanHay)
11:11:19 <mniip> squall, the question is, "But why?"
11:11:20 <squall> As is the Haskell idiom of higher order programming
11:11:32 <squall> Which we all know and love
11:11:37 <EvanR> mniip: or gc, or standard support for linked lists
11:11:41 <paldepind> I have a `Maybe (a -> a)` and an `a`. Does there exist something for maybe applying the function and just get the `a` back if the function is a Nothing?
11:11:49 <EvanR> or higher order functions
11:12:01 <mniip> paldepind, fmap ($ x) f
11:12:13 <mniip> oh wait
11:12:15 <mniip> that's not it
11:12:19 <paldepind> mniip, that will give me Nothing if the function is Nothing.
11:12:22 <squall> And because it facilitates trivial translation of Haskell to c if the Haskell is written in these higher order functions, the ones a have implemented in c
11:12:24 <nshepperd> :t maybe id id
11:12:25 <lambdabot> Maybe (a -> a) -> a -> a
11:12:26 <mniip> :t maybe
11:12:27 <lambdabot> b -> (a -> b) -> Maybe a -> b
11:12:41 <ReinH> @djinn Maybe (a -> a) -> a -> a
11:12:41 <lambdabot> f a =
11:12:42 <lambdabot>     case a of
11:12:42 <lambdabot>     Nothing -> \ b -> b
11:12:42 <lambdabot>     Just c -> c
11:13:03 <EvanR> its an elaborate id
11:13:44 <ReinH> forall a. yes, but this is for "an a".
11:14:15 <EvanR> the djinn version is a fun brain twister
11:14:26 <pie_> who was I talking to about R earlier?
11:14:26 <ReinH> Nah, it's just either using the Just id or constructing one.
11:14:47 <mniip> > maybe id id (Just (++ "!")) "moo"
11:14:48 <lambdabot>  "moo!"
11:14:49 <nshepperd> squall: this code won't be pretty. because you'll have to do casting things to (void*) and back every time you call a higher order function
11:14:51 <mniip> > maybe id id Nothing "moo"
11:14:53 <lambdabot>  "moo"
11:14:57 <ReinH> Not sure why it didn't pick pick f _ a = a though.
11:15:03 <ReinH> s/pick pick/pick
11:15:07 <teclo-> In C you do int c; then res=scanf(%s,c);
11:15:09 <mniip> ReinH, because it can
11:15:15 <teclo-> it will compile, and run
11:15:19 <EvanR> ReinH: see, its weird
11:15:19 <squall> mniip, the issue is also that apparently using these higher order functions would "make the c code worse", while I would argue I would find it easier to read, and also because it provides me with a crude Haskell to c translator
11:15:22 <teclo-> but crash
11:15:46 <mniip> squall, why do you want a haskell to C translator
11:15:49 <ReinH> mniip: That is not a satisfying answer :p Specifically I'm wondering why the chosen one came first in the search.
11:16:06 <paldepind> `maybe id id`. Seems like magic :)
11:16:16 * hackagebot amazonka-emr 1.3.3.1 - Amazon Elastic MapReduce SDK.  https://hackage.haskell.org/package/amazonka-emr-1.3.3.1 (BrendanHay)
11:16:18 * hackagebot amazonka-cognito-identity 1.3.3.1 - Amazon Cognito Identity SDK.  https://hackage.haskell.org/package/amazonka-cognito-identity-1.3.3.1 (BrendanHay)
11:16:20 * hackagebot amazonka-ssm 1.3.3.1 - Amazon Simple Systems Management Service SDK.  https://hackage.haskell.org/package/amazonka-ssm-1.3.3.1 (BrendanHay)
11:16:22 * hackagebot amazonka-ml 1.3.3.1 - Amazon Machine Learning SDK.  https://hackage.haskell.org/package/amazonka-ml-1.3.3.1 (BrendanHay)
11:16:24 * hackagebot amazonka-workspaces 1.3.3.1 - Amazon WorkSpaces SDK.  https://hackage.haskell.org/package/amazonka-workspaces-1.3.3.1 (BrendanHay)
11:16:28 <hexagoxel> djinn has a certain preference for using all input, afaik
11:16:35 <ReinH> paldepind: what specifically are you doing with the real types involved?
11:16:47 <ReinH> I think we're all assuming this is polymorphic when it really isn't.
11:16:58 <johnw> is there a Handle I can use for stdout that will just drain any input, like /dev/null?
11:17:03 <mniip> @djinn (a -> b -> c -> d) -> a -> b -> c -> d
11:17:03 <lambdabot> f a = a
11:17:06 <squall> I don't see why I would have to cat to void or even that I cannot produce a type safe subset of c using templates
11:17:14 <mniip> see it tries to use as few abstractions as possible
11:17:31 <mniip> "using all of input" is about using wildcard patterns
11:17:59 <squall> Mniip because i want to write fast c in Haskell for deployment in departments using c
11:18:18 <ReinH> squall: so use Ivory.
11:18:23 <squall> I will
11:18:29 <pie_> hodapp: i forgot to link this https://www.rstudio.com/resources/training/online-learning/ , also the usual look on stackoverflow and google for recommended resources cant hurt :P
11:18:34 <paldepind> ReinH, I have a list [Maybe (Value -> Value)] and an initial value I want to fold over an initial value. 
11:18:34 <pie_> did you get swirl?
11:18:35 <squall> But I was talking about this other thing
11:19:36 <EvanR> paldepind: are you trying to do a fold-with-the-ability-the-cancel
11:19:40 <EvanR> tocancel
11:19:52 <EvanR> theres foldM
11:20:08 <ReinH> > fmap ($ 1) (Maybe succ)
11:20:13 <lambdabot>      Not in scope: data constructor ‘Maybe’
11:20:14 <EvanR> :t foldM
11:20:17 <lambdabot>      Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
11:20:21 <ReinH> Uh. I guess I need coffee.
11:20:23 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
11:20:42 <ReinH> > fmap ($ 1) (Just succ)
11:20:43 <lambdabot>  Just 2
11:20:45 <paldepind> EvanR, Cancel? The `Nothing` functions should have no effect and the `Just (Value -> Value)` functions should be applied. I don't want to end up with a Nothing in the end.
11:20:56 <squall> ReinH make sure you allow it to settle well
11:21:13 <EvanR> paldepind: oh, then just catMaybes first
11:21:17 <ReinH> paldepind: so foldr (.) id . catMaybes ?
11:21:26 * hackagebot amazonka-inspector 1.3.3.1 - Amazon Inspector SDK.  https://hackage.haskell.org/package/amazonka-inspector-1.3.3.1 (BrendanHay)
11:21:28 * hackagebot amazonka-rds 1.3.3.1 - Amazon Relational Database Service SDK.  https://hackage.haskell.org/package/amazonka-rds-1.3.3.1 (BrendanHay)
11:21:30 * hackagebot amazonka-iot 1.3.3.1 - Amazon IoT SDK.  https://hackage.haskell.org/package/amazonka-iot-1.3.3.1 (BrendanHay)
11:21:32 * hackagebot amazonka-ds 1.3.3.1 - Amazon Directory Service SDK.  https://hackage.haskell.org/package/amazonka-ds-1.3.3.1 (BrendanHay)
11:21:34 * hackagebot amazonka-cloudwatch-logs 1.3.3.1 - Amazon CloudWatch Logs SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-logs-1.3.3.1 (BrendanHay)
11:21:54 <paldepind> EvanR, ReinH, Yes! Thank you. That will solve it nicely :)
11:22:47 <EvanR> ZONK
11:24:29 <ReinH> squall: I don't think it's possible to prove that a for loop in C is equivalent to a map or fold in Haskell via static analysis.
11:24:39 <ReinH> But I guess that's something you'd be attempting in your phd work.
11:24:57 <squall> No but a subset of possible expressions written in for loops is
11:25:49 <squall> And with sufficiently many higher order functions all for loops presented will be captured
11:26:35 <gigabytes> Hi everybody
11:26:36 * hackagebot amazonka-route53 1.3.3.1 - Amazon Route 53 SDK.  https://hackage.haskell.org/package/amazonka-route53-1.3.3.1 (BrendanHay)
11:26:38 * hackagebot amazonka-cloudsearch 1.3.3.1 - Amazon CloudSearch SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-1.3.3.1 (BrendanHay)
11:26:40 <gigabytes> A little question
11:26:40 * hackagebot amazonka-storagegateway 1.3.3.1 - Amazon Storage Gateway SDK.  https://hackage.haskell.org/package/amazonka-storagegateway-1.3.3.1 (BrendanHay)
11:26:42 * hackagebot amazonka-ec2 1.3.3.1 - Amazon Elastic Compute Cloud SDK.  https://hackage.haskell.org/package/amazonka-ec2-1.3.3.1 (BrendanHay)
11:26:44 * hackagebot amazonka-marketplace-analytics 1.3.3.1 - Amazon Marketplace Commerce Analytics SDK.  https://hackage.haskell.org/package/amazonka-marketplace-analytics-1.3.3.1 (BrendanHay)
11:26:59 <sm> zonked again!
11:27:14 <paldepind> ReinH, are you Rein Henrichs?
11:27:15 <gigabytes> does the GHC runtime expose a C interface to be used by C code linked as part of Haskell programs?
11:27:45 <squall> The point is to construct an irreducible representation of all programmes  in terms of a spanning basis of higher order functions
11:27:46 <johnw> what would that C interface do?
11:28:05 <gigabytes> johnw: I'm interested in talking with the scheduler mainly
11:28:08 <johnw> Haskell code can pass C function pointers to Haskell functions, for example for use as callbacks
11:28:09 <johnw> ah
11:28:09 <EvanR> there is a way to use ghc from your C program 
11:28:16 <johnw> well, you can expose any function you want to C
11:28:24 <johnw> I don't think there's any standard collection that gets presented to the C program
11:28:47 <gigabytes> johnw: for example, would it be possible to implement the runtime part of the STM from a standalone library?
11:29:04 <gigabytes> the requirement for it is to be able to explicitly put in sleep and awake TSOs
11:29:16 <johnw> I really don't know
11:29:36 <johnw> my gut says no, that's too low level, but maybe #ghc knows if people here don't
11:31:05 <squall> Well it seems the Haskell community thinks type safety is impossible in c and that a basis of higher order functions as a common interface between Haskell and c is not cool
11:31:33 <gigabytes> johnw: didn't know #ghc exists, thanks
11:31:46 * hackagebot amazonka-elastictranscoder 1.3.3.1 - Amazon Elastic Transcoder SDK.  https://hackage.haskell.org/package/amazonka-elastictranscoder-1.3.3.1 (BrendanHay)
11:31:48 * hackagebot amazonka-lambda 1.3.3.1 - Amazon Lambda SDK.  https://hackage.haskell.org/package/amazonka-lambda-1.3.3.1 (BrendanHay)
11:31:50 * hackagebot fasta 0.9.0.0 - A simple, mindless parser for fasta files.  https://hackage.haskell.org/package/fasta-0.9.0.0 (GregorySchwartz)
11:31:52 * hackagebot dixi 0.1.0.0 - A wiki implemented with a firm theoretical foundation.  https://hackage.haskell.org/package/dixi-0.1.0.0 (LiamOConnorDavis)
11:33:06 <johnw> squall: a handful of people here is by no means the Haskell community
11:34:16 <squall> I think calling the compiler from within code is not as favourable a solution as a pretty set of higher order functions
11:44:43 <sqaull2> I guess ivory does it properly so to speak, but if all Haskell and c program's were prettyfied to a common basis then the translation would be trivial, which would be good for humans, who currently have to do what ivory is doing which is hard.
11:45:30 <hodapp> sqaull2: Why would the translation be trivial? For that matter, why would it even be automatically *possible*?
11:46:11 <sqaull2> Ivory would basically be made into a program in c taking the form of the implementation of the basis
11:46:40 <Cale> "<squall> The point is to construct an irreducible representation of all programmes  in terms of a spanning basis of higher order functions" the terminology used in this comment messes with my head
11:47:27 <mniip> [20:40:50] <Cale> "<squall> The point is to construct an irreducible representation of all programmes  in terms of a spanning basis of higher order functions" the terminology used in this comment messes with my head
11:47:28 <mniip> so,
11:47:32 <mniip> SK calculus then?
11:47:36 <hodapp> A basis by definition spans.
11:47:47 <sqaull2> It's possible because the languages are Turing equivalent, and even of my subsets of the languages are not, by definition of the extent of the basis to spam the current program of interest is ok
11:48:04 <dickewolle> i'm reading through okasaki's pfds and he's telling me to force the evaluation of some arguments...but reading about seq gives me the heebie jeebies
11:48:16 <mniip> SK is turing-complete and isomorphic to lambda calculus
11:48:26 <mniip> and via church encoding you can get structures
11:48:43 <sqaull2> Cool
11:48:45 <Cale> Especially "irreducible representation" which makes me think of irreducible representations of groups
11:48:56 <sqaull2> Yes
11:49:13 <dickewolle> can anybody offer some advice about this?
11:49:15 <sqaull2> This is the challenge
11:49:41 <Cale> dickewolle: I don't know what advice you need. You might also want to use bang patterns?
11:49:45 <bergey> dickewolle: Can you be more specific about "the heebie jeebies"?
11:50:09 <Cale> sqaull2: Well, programs don't actually have group structure :P
11:50:30 <sqaull2> The implementation of ai consists of such a basis that can grow itself, and canonical partition itself to prime automata in the Krohn Rhodes sense
11:50:32 <dickewolle> specifically, this SO post: https://stackoverflow.com/questions/12687392/why-is-seq-bad
11:50:49 <hodapp> sqaull2: If the basis of your translation is that they are Turing equivalent, then you have basically no business talking about what is idiomatic; those two things are about as far apart as is possible.
11:50:52 <sqaull2> Came no
11:50:57 <sqaull2> Cale
11:51:27 <dickewolle> afaik i need seq to make certain things efficient but then seq has a dark side as described in that post
11:51:28 <Cale> dickewolle: The way in which seq is bad has to do with what it does to the analysis of programs written in the language as a whole. You're already paying for that badness just because seq exists at all.
11:51:34 <sqaull2> I'm proposing a common idiom to be higher order functions of Haskell
11:51:45 <Cale> dickewolle: It's not that *using* seq is bad. It's there for practical reasons.
11:52:02 <dickewolle> Cale: so i shouldn't worry about using it?
11:52:05 <Cale> right
11:52:28 <Cale> Well, you should use it with care -- adding strictness to your programs isn't always helpful to performance
11:52:32 <hodapp> sqaull2: Turing equivalence does not extend one bit to idioms, so I don't see how it's relevant here
11:53:00 <sqaull2> We are translation via an income basis, we do not hope to produce a Turing complete Haskell in c, or the other way round, it must sufficiently capture a set of programs of interest only
11:53:04 <Cale> But if Okasaki says to do it, then he's probably right :P
11:53:15 <sqaull2> Incomplete not income
11:53:57 <hodapp> sqaull2: So first translation was trivial because they're Turing-equivalent. Now you're not interested in Turing-completeness at all. Please make your mind up.
11:53:59 <mutantmell> dickewolle: going through Purely Functional Data Structures?
11:54:22 <dickewolle> assuming that strictness in a given argument improves performance, then it's perfectly acceptable to make that argument strict?  i mean, would anybody consider it "bad" just for using seq despite the improved performancee
11:54:26 <dickewolle> mutantmell: yeah
11:54:38 <sqaull2> The languages are Turing equivalent therefore there exists a common basis
11:55:16 <hodapp> sqaull2: How does Turing equivalence imply a "common basis"?
11:55:23 <sqaull2> I suggest Haskell idiom should be used in the construction of such a basis
11:56:13 <Cale> sqaull2: So you're basically saying that there exists (in some formal sense, not a practical one) a compiler which will translate C to Haskell and vice-versa. I don't get what you're talking about with regard to bases. Bases for what sort of algebraic structure?
11:56:43 <sqaull2> Hodapp, I don't have the language to express the proof that there exists a basis less complete than the whole language, but I suspect in many practical cases it would
11:57:09 <sqaull2> The basis is of higher order functions
11:57:15 <dickewolle> mutantmell: got to chap 6 then realised i don't really understand strictness/forcing very well
11:57:35 <Cale> Just because the languages are Turing equivalent doesn't mean that you can neatly turn, say, a single Haskell function into some corresponding thing in C.
11:57:37 <lpaste> luisgabriel pasted “diners.hs” at http://lpaste.net/142636
11:58:19 <dickewolle> mutantmell: how did you find pfds?
11:58:42 <Cale> It just means that both languages can implement a particular class of programs (which isn't even all the programs they can implement)
11:58:46 <mutantmell> dickewolle: I just picked it up recently
11:59:01 <sqaull2> I don't need to implement or use either compiler to translate or interoperate foreign code if there exists an implementation in both languages of a sufficient basis of higher order functions to express the program of interest
11:59:34 <Cale> sqaull2: I'm afraid I still don't understand what you mean.
12:00:05 <sqaull2> You can't write not in these higher order functions
12:00:07 <mutantmell> dickewolle: I'm going to be going through it soon (tm).  I've heard its good.
12:00:20 <luisgabriel> http://lpaste.net/142636 -> Why doesn't happen a deadlock here? The ordering in which the forks are acquired/released seems wrong
12:00:32 <sqaull2> I'm confining Haskell and c to a common set of functions
12:00:51 <sqaull2> To facilitate trivial translation
12:01:06 <dickewolle> mutantmell: i'm really enjoying it.  trying to work my way through all the exercises but some are really quite tricky
12:01:35 <Cale> sqaull2: Also, you can't really implement very many higher order functions in a meaningful way in C, given that it doesn't really have proper function values, only function pointers.
12:01:39 <sqaull2> Identifying common programming patterns is the game
12:01:56 <morodeer> Hello guys, I'm diving into Haskell and now I'm trying to implement dijkstra algorithm for shortest path. However, it doesn't even compile saying "parse error in constructor in data/newtype declaration: {nodes:: [Node], edges :: [Edge] } ". How can I implement such datatype? source is here: http://lpaste.net/142637
12:02:19 <Cale> morodeer: You missed the data constructor name
12:02:30 <Cale> morodeer: Perhaps  data Graph = Graph { ... }
12:02:52 <sqaull2> I can pass functions as arguments just fine in c, I can write all of my usual recursion schemes
12:03:05 <Cale> sqaull2: You can't use them the same way
12:03:37 <Cale> sqaull2: Because you can't create functions in the same way -- you have to do closure conversion by hand.
12:03:40 <morodeer> Oh, yes. 
12:03:51 <c_wraith> luisgabriel: forkIO creates no deterministic threads. No particular interleaving of their actions is guaranteed 
12:03:59 <mutantmell> dickewolle: I'm currently reading through Parallel and Concurrent Haskell.  I'm enjoying that as well.
12:04:46 <c_wraith> sqaull2: try to implement (.) in C. 
12:04:52 <Cale> sqaull2: passing around function pointers isn't enough, you'll need to translate the higher order functions differently, so that they can accept your closure representation for functions.
12:05:20 <sqaull2> I can and do implement map and fold in c and write my programs in terms of them. More complex recursion I define in the Haskell idiom, in that i use a recursion scheme not a for loop, common recursion patterns are identified and abstracted
12:05:38 <dickewolle> mutantmell: does it have plenty of exercises?
12:05:47 <Cale> sqaull2: Try c_wraith's suggestion :)
12:06:00 <ReinH> dickewolle: I suggest http://apfelmus.nfshost.com/blog/2013/08/21-space-invariants.html for reasoning about strictness and uses of seq
12:06:04 <exio4> well, you can always build a language within C 
12:06:11 <ReinH> And SimonM's book is excellent.
12:06:17 <mutantmell> dickewolle: No, mostly (very well explained) examples
12:06:24 <exio4> dynamic-typed, Value*, and a few macros to help there
12:06:26 <sqaull2> . Is sugar, not a recursion scheme, its not a higher order function in that sense
12:06:32 <mutantmell> dickewolle: Which is nice for me right now, because I'm leading a group through Functional Programmin in Scala
12:06:43 <Cale> Function composition is the most basic of higher order functions and you'll have trouble with it unless you're defining some sort of closure datastructures and passing (pointers to) those around rather than function pointers directly.
12:06:49 <mutantmell> dickewolle: and that has a lot of problems I need to work through :)
12:06:58 <ReinH> If your definition of HOF doesn't include (.) then it is wrong.
12:07:04 <sqaull2> Ok
12:07:09 <dickewolle> mutantmell: hehe, cool
12:07:10 <c_wraith> sqaull2: (.) isn't sugar. It's defined in the standard library 
12:07:16 <sqaull2> I'm talking about recursion schemes
12:07:28 <sqaull2> It's sugary
12:07:29 <pie_> sqaull2: re: our previous conversation, my classmates are learning C as their first language
12:08:05 <sqaull2> Ok
12:08:20 <ReinH> pie_: Well, that's better than Java at least.
12:08:25 <luisgabriel> c_wraith: I see. My main concern is the fact that it's quite easy to reproduce a deadlock with an implementation like this in languages like C. I tried hard but couldn't reproduce such behavior in Haskell. So I thought maybe I was missing something related to the GHC scheduler or how MVar works
12:08:45 <pie_> ReinH: heh.
12:08:51 <Cale> ReinH: Is it? C has even more trivial details to waste beginners' time with.
12:09:16 <ReinH> Cale: But at least you are learning something about computer architectures rather than something about the JVM.
12:09:21 <Cale> yeah, maybe
12:09:38 <ReinH> I don't think either are *good* first languages, but if I had to choose, I would choose C.
12:09:39 <pie_> C is under a lot of things, it makes me feel better that they are seeing closer to the metal
12:09:47 <pie_> personally id do python
12:09:52 <pie_> given a choice
12:10:07 <pie_> but thats also because its what i know the most and it feels comfortable
12:10:08 <ReinH> Java is a walled garden that hasn't been tended in centuries and where the plants sometimes try to eat you.
12:10:08 <exio4> DrRacket is pretty cool too :) 
12:10:19 <ReinH> C at least forces you to work with actual machines rather than virtual ones.
12:10:58 <Cale> There are hardware implementations of the JVM though, aren't there?
12:11:01 <ReinH> I think Rust and Haskell would make good learning languages.
12:11:05 <pie_> Cale: sadly :P
12:11:16 <ReinH> Cale: I think you're missing my point :)
12:11:28 <sm> in your first surgery class, you should work with actual patients ? :)
12:11:37 <pie_> i cant remember what not being able to program is like :/
12:11:41 <ReinH> sm: If you can't hurt them, why not
12:11:45 <Cale> also, our "real" processors are really interpreting x86 instructions
12:12:01 <sm> because they're overwhelmingly complicated
12:12:03 <Cale> into some internal language, which they actually execute :P
12:12:09 <exio4> it's a fancy virtual machine implemented on hardware
12:12:10 <dickewolle> ReinH: cheers, i'll take a look
12:12:10 <ReinH> Cale: The point is more that Java teaches you things that are proprietary to the JVM.
12:12:18 <pie_> not that I can...
12:12:20 <c_wraith> I want to make a spec-compliant C compiler that maximizes it's evil, just to make people realize how little C actually defines. 
12:12:37 <Cale> It's all pretty arbitrary and awful either way
12:13:05 <johnw> c_wraith: that's actually fairly amusing
12:13:11 <ReinH> Cale: I think Rust and Haskell would combine to cover a lot of the space you want to cover when teaching computer science.
12:13:26 <exio4> c_wraith: do it!
12:13:32 <Cale> c_wraith: Just make any instance of undefined behaviour start a game of Tetris
12:13:43 <sm> lol
12:13:45 <c_wraith> exio4: it'd be a lot of work. 
12:13:51 <ReinH> I also think that Rust and Haskell programmers who try other languages would write better programs in those languages because they would have ingrained attitudes towards memory and type safety.
12:14:09 <sqaull2> Ur, why can't I implement dot c sucks
12:14:51 <exio4> c_wraith: sadly :(
12:14:52 <pie_> to be fair it would be nice if more people had a clue about internals, but you cant force everyone to be tech savvy
12:14:54 <Cale> sqaull2: Because C doesn't have proper function values, only function pointers.
12:14:56 <c_wraith> Cale: don't forget all the implementation defined behavior, like, say, addition of integers. 
12:15:04 <pie_> it just sucks when i want to link people the cool new tooli found :P
12:15:16 <sqaull2> What is this hellishness!?
12:15:24 <ReinH> sqaull2: One of my central objections is that "prettiness" can't be quantified and optimized for, and that even if one could, it is not an interesting metric to choose. I would rather choose, say, safety or performance.
12:15:27 * hackagebot hatex-guide 1.3.1.1 - HaTeX User's Guide.  https://hackage.haskell.org/package/hatex-guide-1.3.1.1 (DanielDiaz)
12:15:34 <pie_> sqaull2: i keep derailing the channel >.<
12:15:40 <Cale> sqaull2: I don't even know why you'd expect this quest of yours to be reasonable in the first place :P
12:15:55 <Cale> sqaull2: C isn't really considered a great language for forming powerful abstractions.
12:16:21 <ReinH> But I don't believe that you can write a fully general "safety optimizing" refactoring tool for C, whether you use an adjunction with Haskell or any other means.
12:16:21 <monochrom> pointer mistakes in C are harder to diagnose than pointer mistakes in Java. C "teaches" you computer architecture in the same sense that some math courses "teach" you proofs: they don't teach, they just select those who learn or know by other means, and fail the rest, i.e., select as in natural selection.
12:16:23 <exio4> use it as the target language of a language with C syntax
12:16:24 <sqaull2> Prettyfied I'm now starting to define as towards a common basis
12:16:25 <hodapp> sqaull2: I encourage you to go actually implement what you're talking about.
12:16:40 <sqaull2> You are a cruel person
12:16:45 <johnw> ReinH: what if it were based on CompCert?
12:17:04 <EvanR> so what happened to the "use" category http://i.imgur.com/NJ8A73n.png
12:17:07 <ReinH> johnw: I mean that I don't believe that you can take an arbitrary C program and make it safer.
12:17:10 <EvanR> is it negligible?
12:17:18 <ReinH> Where by "you" I mean "some algorithm".
12:17:55 <johnw> ReinH: you'd only be able to do that for programs whose semantics can be known statically -- i.e., not relying on undefined or compiler-specific behavior
12:18:10 <Cale> ReinH: Sure you can, just run it through c_wraith's compiler, and it'll play a harmless game of Tetris instead of whatever harmful thing it was going to do otherwise. ;)
12:18:12 <sqaull2> If it's not possible to write dot in c does there exist an extension of c which does?
12:18:15 <johnw> so just narrow your use of C to such a subset; MISRA does this
12:18:26 <ReinH> Cale: Yes, "If your program doesn't have to work then it can meet any other requirement". :)
12:18:50 <ReinH> johnw: Yes, but I suspect that this subset of C would eliminate a large majority of real C programs.
12:19:01 <johnw> not as much as you might think
12:19:11 <johnw> after all, MISRA is the basis of most programs used by the auto industry
12:19:29 <monochrom> how do you count the number of programs? I am serious.
12:19:34 <Cale> I wonder if it's okay for all C programs to perform addition and multiplication modulo 3
12:19:39 <ReinH> monochrom: What is a program? I am serious.
12:19:48 <c_wraith> Cale: to the spec! 
12:19:53 <sqaull2> Absolutely not reinh. Most huge c program's in science which i an being asked to reactor were written by Fortran programmers
12:20:18 <EvanR> "please put these programs in the reactor"
12:20:25 <sqaull2> Look into prime automata
12:20:30 <Rembane> sqaull2: Does that mean that they contain a lot of gotos and other such lovely things?
12:20:34 <sqaull2> Refactor
12:20:41 <hodapp> sqaull2: seriously: go implement this.
12:20:44 <ReinH> sqaull2: refactor to what purpose? "Prettiness"? What does that really mean?
12:20:49 <monochrom> I ask because it is necessary for deciding "this subset of C would eliminate a large majority of real C programs"
12:20:53 <hodapp> sqaull2: it will greatly simplify all discussion if you have a proof-of-concept in hand.
12:21:09 <ReinH> monochrom: I know. And I ask because it is not obvious (to me) what actually constitutes a program.
12:21:28 <ReinH> You can't optimize for a metric you can't even define.
12:21:30 <hodapp> A program is an algorithm with a navy and an army.
12:21:31 <hodapp> or something.
12:21:35 <sqaull2> Write fib in terms of fix in c
12:21:54 <ReinH> sqaull2: Um. Is that an answer to my question?
12:22:34 <sqaull2> Rainy, the common basis is not unique but it is well defined metric of success I'm referring to as pretty
12:22:54 <ReinH> johnw: Sorry, I meant "a large majority of extant C programs", not that one couldn't write a large majority of C programs using only that subset of C.
12:23:01 <EvanR> I'm wondering if i can get some help with my breadth-first traversal of an infinite tree. It based it on levels and lzw from here https://patternsinfp.wordpress.com/2015/03/05/breadth-first-traversal/
12:23:08 <johnw> ReinH: ah, right
12:23:10 <EvanR> but the memory usage grows huge which slows down the traversal
12:23:31 <EvanR> as shown here http://i.imgur.com/NJ8A73n.png
12:24:04 <sqaull2> ReinH pretty is in the common basis
12:24:14 <johnw> EvanR: What commandline option are you using to generate that profile?
12:24:25 <EvanR> +RTS -hr
12:24:26 <EvanR> er
12:24:28 <EvanR> +RTS -hb
12:24:31 <c_wraith> EvanR: well, and breadth first traversal of an infinite tree is going to be keeping a much larger queue than the number of items it has checked. 
12:24:41 <monochrom> so suppose I have an executable consisting of a million lines of code, organized as a hundred libraries, each library 10 files. does that count as 1, or 100, or 1000? And suppose only one file relies on a non-standard thing, and only one line of code in that file does. does that count as 100%? 10%? 1%? 0.1%, 0.0001%?
12:24:47 <johnw> EvanR: hmm... it doesn't tell me a whole lot
12:24:54 <sqaull2> Pretty = in common idiom
12:25:05 <ReinH> sqaull2: So you define some subset of C (how?) and you define a transformation from the set of all C programs to the set of C programs using that subset of C, and you presumably want to show that this transformation has some nice properties (TBD?)
12:25:07 <EvanR> i can paste the code and produce other profiles
12:25:40 <EvanR> ghc -prof -fprof-auto -rtsopts Main.hs
12:25:51 <pie_> you could always compile to assembly and then decompile it :P
12:25:51 <sqaull2> You define a subset of c by replacing or omitting some of the features it presents
12:26:07 <ReinH> sqaull2: I know how *a* subset is defined. I mean how do you define *your* subset?
12:26:15 <EvanR> c_wraith: well, at least id like to understand where this memory is going, because at this point i dont even have an explicit queue
12:26:31 <monochrom> basically, if I have a million lines of code, and I use something non-standard in one line (say, I write "f(i++, j++)" just once somewhere). how much of the million lines do you eliminate?
12:26:43 <sqaull2> Using implementations of common recursion schemes
12:27:23 <ReinH> sqaull2: And your contention is that you can somehow use an adjunction between C programs (using the full set of C features) and Haskell programs and carry out the optimization on the Haskell side and then bring it back?
12:27:59 <sqaull2> The optimisation in prittyness yes
12:28:05 <johnw> sqaull2: well, if you can do it, I'd love to see the result
12:28:15 <johnw> sometimes the best ideas sound insane
12:28:18 <sqaull2> Woot
12:28:23 <EvanR> c_wraith: yesterday i hypothesized that if you algorithmically generated all the paths through the tree (in breadth first order) and traversed a new version of the tree each time that this would take way less than gigs of memory
12:28:24 <ReinH> "in prettiness" is meaningless to me, so I will continue to use "mapping to the chosen subset of C"
12:28:47 <ReinH> sqaull2: But have I accurately characterized your problem?
12:29:57 <sqaull2> I defined pretty to be; expressed in a common basis
12:30:02 <ReinH> You might even start with the full set of *defined* C features as your domain, since it seems impossible to do anything with undefined behavior on its face.
12:30:35 <ReinH> sqaull2: Ok, so is "pretty" equivalent to "a member of the subset of C that uses this common basis"?
12:30:43 <sqaull2> Yes
12:30:50 <EvanR> in levels :: Tree a -> [[a]], levels t = [root t] : foldr (lzw (++)) [] (map levels (children t)), it seems all pretty lazy to me
12:31:05 <ReinH> Ok, so then if I've gotten the problem right, I think it's probably impossible. That shouldn't stop you from trying it though.
12:31:08 <EvanR> a traversal would then be iterating over concat (levels t)
12:31:16 <sqaull2> Abstracting common patterns is Haskell idiom
12:31:30 <sqaull2> It creates pretty c
12:31:31 <EvanR> so why does it take huge memory
12:31:39 <ReinH> I think the use of abstraction isn't limited to Haskell...
12:31:50 <sqaull2> It's common practice
12:31:58 <johnw> EvanR: have you already linked the code?
12:32:11 <ReinH> I also think that you're using "pretty" in an informal way to mean something other than what we just defined and this equivocation is making it hard to understand you.
12:32:19 <pie_> um
12:32:27 <sqaull2> For me it defined what I love about Haskell, its ability to allow the decomposition into common patterns
12:32:28 <ReinH> Which is why I don't like to redefine a term that already means something else.
12:32:33 <pie_> if you can make a 1:1 mapping between c and haskell features you should ba able to translate?
12:32:41 <pie_> i dont think this is the halting problem? :P
12:33:21 <ReinH> This machine that transforms C programs would only make them prettier if prettier is narrowly defined as above. It may not make them "prettier" for subjective definitions of "pretty".
12:33:24 <pie_> but what do i know
12:33:35 <sm> EvanR: what's lzw ?
12:33:48 <EvanR> http://lpaste.net/142638
12:33:53 <johnw> pie_: a 1:1 mapping itself has many definitions.  Does it take performance into account, etc.  The common subset of both languages that is isomorphic in every respect one might care about is likely pretty small
12:33:53 <hodapp> Lempel, Ziv, & Welch? The compression algo?
12:33:56 <sqaull2> Ok so I'll scrap the term pretty, what do I mean? In a nicer way than, expresable in a common truncated language
12:33:58 <EvanR> johnw: sorry there it goes
12:33:59 <sm> thanks
12:34:04 <ReinH> I personally don't think that C programs written in a Haskell style using HOF (as much as one can in C) would be prettier in an aesthetic sense.
12:34:12 <EvanR> sm: no its not compression, its "Long ZipWith"
12:34:23 <EvanR> see this https://patternsinfp.wordpress.com/2015/03/05/breadth-first-traversal/
12:34:29 <sm> thanks
12:34:49 <ReinH> sqaull2: you mean "refactors C programs into programs using a defined subjset of C", but I don't know of a simpler way to express that.
12:34:51 <johnw> EvanR: 'levels' is the slow one?
12:34:55 <neals> Hi folks, I'm working through the book Real World Haskell, trying to pick up the language.  One of the exercises is to take a List type and turn it into a regular (:)-constructed list.  Can someone help me figure out the compiler error I'm getting?
12:35:14 <ReinH> @where lpaste -- neals
12:35:14 <lambdabot> http://lpaste.net/
12:35:15 <shachaf> neals: Not if you don't tell anyone what the error is.
12:35:19 <ReinH> Show us the code and the error
12:35:24 <neals> code's at http://pastebin.com/HT7BccQR
12:35:35 <sqaull2> It certainly would read better if you were used to doing it that way, but that's not saying much, the real utility is that such a subset could act as a translation stage in human readability
12:35:41 <ReinH> neals: It's easier if we don't have to guess the error message.
12:35:50 <ReinH> (read "possible")
12:35:55 <neals> error is error's at http://pastebin.com/aV3Qjjf9
12:35:58 * hackagebot llvm-general 3.3.15.0 - General purpose LLVM bindings  https://hackage.haskell.org/package/llvm-general-3.3.15.0 (BenjaminScarlet)
12:36:00 * hackagebot llvm-general 3.4.6.0 - General purpose LLVM bindings  https://hackage.haskell.org/package/llvm-general-3.4.6.0 (BenjaminScarlet)
12:36:02 * hackagebot llvm-general 3.5.1.0 - General purpose LLVM bindings  https://hackage.haskell.org/package/llvm-general-3.5.1.0 (BenjaminScarlet)
12:36:20 <EvanR> johnw: im not sure, printing just slows down after a while, and memory retainment increases semi exponentially
12:36:32 <ReinH> neals: List is not a data constructor, it is a type constructor.
12:36:35 <EvanR> last night i tried a different algorithm and memory increases linearly
12:36:38 <shachaf> neals: "List as" is a type, not a value.
12:36:41 <monochrom> neals: you have confused types and values. toList (Cons x y) = x : toList y
12:36:43 <shachaf> You can't pattern-match on a type.
12:37:04 <sqaull2> Expressed in a language implemented by both languages
12:37:15 <hodapp> sqaull2: How's the implementation coming?
12:37:23 <sqaull2> Of dot?
12:38:02 <sm> EvanR: isn't levels building up a huge stack of thunks with foldr ?
12:38:47 <EvanR> sm: is it? thats not the behavior of foldr i was expecting
12:38:54 <EvanR> @src foldr
12:38:54 <lambdabot> foldr f z []     = z
12:38:54 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:38:56 <sqaull2> I don't believe it to be a pertinent enough stumbling block to dissuade the issue totally
12:39:16 <EvanR> foldr immediately "calls" f, tail call
12:39:22 <EvanR> oh no
12:39:31 <ReinH> neals: data declarations involve both type level and value level things. To illustrate, http://lpaste.net/133183654493945856
12:39:40 <hodapp> sqaull2: that's why I would love to see you implement this.
12:39:45 <sm> EvanR: I'm clueless about this stuff, just asking
12:39:47 <EvanR> well foldr creates a lazy sequence of f
12:39:47 <sqaull2> Do we have the c stl in Haskell?
12:39:56 <ReinH> neals: data constructors are values, but you tried to use a type constructor as a value.
12:40:14 <sqaull2> That would be a solution from the c side
12:40:16 <monochrom> EvanR: f determines how much memory foldr f will use
12:40:26 <monochrom> or at least, f has a large influence
12:40:31 <EvanR> sm: usually people have issues with foldl (not foldl') building up huge thunks, but foldr can also do it sometimes
12:40:49 <ReinH> sqaull2: The C STL in Haskell? What do you mean?
12:40:54 <sqaull2> Hodapp I'm no good at c
12:41:03 <EvanR> so f = lzw (++)
12:41:08 <JamesJRH> happy0: Well I have some good news for you…
12:41:23 <sqaull2> Perhaps boost would do
12:41:39 <ReinH> sqaull2: What are you asking for?
12:42:14 <sqaull2> Common implementation of subset of language encompassing common design patterns
12:42:18 <ARM9> the stl is c++
12:42:31 <happy0> JamesJRH: oh? :D
12:42:41 <sqaull2> Yeh sorry I use c I mean c++
12:42:51 <orion> Let's say I have two types, "StateT Foo IO a" and "StateT Foo Identity a". Is it possible to, in a syntactically concise way, run a value of the /latter/ within a computation of the former?
12:43:14 <sqaull2> Templates are let in rationalizing types in c
12:43:19 <sqaull2> Key
12:43:31 <EvanR> sqaull2: youve been talking about c++ this whole time?
12:43:36 <sqaull2> Yes
12:43:38 <ReinH> ...
12:43:40 <hodapp> ...
12:43:45 <EvanR> perhaps you meant c/c++ :)
12:43:46 <neals> ReinH: so you're saying the second List a is the problem?
12:43:53 <sqaull2> Omg stop with the dots already
12:43:56 <ReinH> neals: Everywhere you use List at the value level is a problem
12:44:26 <sqaull2> I'm not writing c/c++ every time
12:45:02 <EvanR> you should probably stop writing anything, because a PHD student is not going to come in here and be talking about c++ for a few hours but call it C
12:45:03 <ReinH> If you're going to use "c" to mean something other than "c", you should probably define that up front
12:45:04 <sqaull2> C++ is a necessary extension for this implementation obviously
12:45:14 <sqaull2> Obviously
12:45:25 <JamesJRH> happy0: As you asked whether the talks are being recorded, I specifically asked about videos. When I said that I didn't notice any camera in Ivan's games programming workshop, apparently I just didn't notice it. :-) Apparently all of the talks were recorded.
12:45:46 <happy0> JamesJRH: yasss~ :D
12:45:49 <happy0> that is indeed good news
12:45:50 <ReinH> Rather than having us engage in a protracted discussion about the wrong thing because you neglected to mention that you are using central terms incorrectly on purpose.
12:46:04 <sqaull2> All c program's are expressed trivially in c++
12:46:11 <EvanR> not*
12:46:22 <JamesJRH> happy0: I was told that they should be uploaded over the next few days at: https://skillsmatter.com/conferences/7069-haskell-exchange-2015#skillscasts
12:46:27 <happy0> \o/
12:46:54 <cocreature> JamesJRH: I keep refreshing that site since a few hours :)
12:47:01 <ReinH> sqaull2: I'm not interested in playing the "what does this word mean to squall2" game any further.
12:47:05 <monochrom> sqaull2: you need to hear this true story. I have a friend who were sent to a small office to install new software. the staff at the small office asked him, "is this new software compatible with 1048?"  guess what "1048" means.
12:47:30 <sqaull2> Argh, its not a pointless discussion because you misunderstood it. And hopefully now with this clarification you will understand better why your earlier objections were not right
12:47:55 <sqaull2> It's the display?
12:47:57 <EvanR> sqaull2: ya lyin
12:47:59 <JamesJRH> cocreature: Yeah, I was told that they wouldn't be uploaded until a few days, probably next week.
12:48:03 <monochrom> yes
12:48:21 <sqaull2> I didn't need to hear that
12:48:21 <cocreature> JamesJRH: I suppose I can reduce my refresh rate in that case :)
12:48:38 <EvanR> sqaull2: earlier you were giving every indication that you were talking about C specifically including references to the Ivory project
12:49:06 <sqaull2> Common basis, translation, human readability. Never mind small semantic glitches
12:49:22 <ReinH> "small semantic glitches"
12:49:29 <sqaull2> Someone suggested ivory to me
12:49:33 <ReinH> I am struggling to believe that you are actually a phd student.
12:49:37 <cocreature> who cares about semantics if it's human readable
12:49:43 <hodapp> sqaull2: saying "C" when you mean "C++" for every one of several hundred references to it over the course of 2 hours is *not* a small semantic glitch
12:49:54 <sqaull2> I seriously fist think you guys thought I would be ok without templates
12:49:58 <ARM9> what does it matter if he's a phd student?
12:49:58 <sqaull2> Didn't
12:50:28 <ReinH> I couldn't imagine advising a student who cared this little about correctly establishing the basic premise of their work.
12:50:32 <sm> EvanR: maybe you need to force the lzw (++) to be more strict ?
12:50:33 <EvanR> this whole discussion has been long and misleading from the start and its interferring with my question ;)
12:50:52 <EvanR> sm: in what way? its traversing two lists
12:51:02 <johnw> sm: I actually think it might be the fix (grid haskell)
12:51:10 <sqaull2> Ok Evan, I'll cut it off. Sorry
12:51:12 <neals> ReinH: are you saying the data List a = ... part is wrong? Because that's just copied from the book
12:51:14 <johnw> because the fields of Nine are not being forced
12:51:37 <EvanR> if the fields of Nine were always forced, that would try to generate the entire tree instantly?
12:51:40 <johnw> sm: so at some point, some truly massive Nine values are created before they are reduced by levels
12:51:48 <JamesJRH> happy0: Also, I have a couple of other links and things to tell you about but I'm currently in a pub with other Haskellers, a rare occurence for me, so I'll leave you for now and make the most of it.
12:51:55 <ReinH> neals: I would like for you to annotate your pastie by labeling each occurence of List with whether it is at the type level or the value level.
12:52:04 <ReinH> neals: Then we can see where your misconception lies.
12:52:06 <johnw> EvanR: so you're relaying on the lazy fields, hmm
12:52:10 <EvanR> i thought about that ... so the Nine record is not lazy enough really
12:52:11 <graChe28> I have a little experience with Haskell and I'm trying to get started with Haskell Web development. Any recomendations on where to start? Yesod or Snap or?? Where to find documentation / tutorials
12:52:17 <sm> yes, foldr is building a lazy list of lzw (++) evaluations.. which are lazily not actually being evaluated. Hopefully that's what johnw just said
12:52:28 <osfameron> ~/win 40
12:52:29 <johnw> EvanR: every field of Nine is a thunk, and those thunks are referencing previous results
12:52:31 <osfameron> bah
12:52:33 <EvanR> no youre talking about two different things
12:52:38 <johnw> if those previous results start getting big...
12:52:40 <sm> ok, then listen to johnw :)
12:52:41 <JamesJRH> happy0, cocreature: Feel free to join #HaskellX. :-)
12:52:57 <johnw> EvanR: can you try +RTS -hr
12:52:57 <hodapp> HaskellX?
12:53:06 <johnw> EvanR: it might tell us which function is allocating this memory
12:53:15 <ReinH> JamesJRH: seriously why are you even here, go drink and talk about haskell :)
12:53:16 <EvanR> right so maybe theres a way to not rely on previous results or consume them better
12:53:27 <EvanR> ok
12:53:37 <cocreature> JamesJRH: sorry, I'm already jealous. going there would only make me more jealous :)
12:53:42 <johnw> EvanR: or force the previous results sufficiently to avoid referencing large in-progress intermediate values
12:54:18 <johnw> for example, the thunk references your foldr computation will hold an Image resident until it is fully reduced
12:54:22 <johnw> that references*
12:54:35 <johnw> and I have a feeling that fix is making ever larger Images
12:55:15 <sqaull2> GraChe28 yesod tutorials are not my favorite, I like Network.HTTP
12:55:17 <EvanR> http://i.imgur.com/jTAk8Zq.png
12:55:23 <johnw> initially it doesn't hurt, because laziness is allowing the Images to be shallow; but as you progress in the computation, they start getting exponentially larger
12:55:43 <ReinH> graChe28: you might find scotty easier to get started with for simple things.
12:55:47 <johnw> ok, that heap graph makes sense
12:56:10 <EvanR> this might actually be linear
12:56:20 <EvanR> but it reclaims more earlier than my algorithm last night
12:56:27 <EvanR> but then it gets really slow when it gets to 4 seconds
12:56:59 <johnw> one sec, I'll try this here
12:58:13 <johnw> I'm seeing the same results
12:58:15 <johnw> now to try some things
12:58:50 <graChe28> tks sqaull2 ReinH
12:59:51 <graChe28> I should emphasize I know only a *little* Haskell, and virtually no html/css/javascript if that plays any role in which framework to choose
13:00:22 <cocreature> graChe28: spock is probably also worth a look https://hackage.haskell.org/package/Spock
13:00:30 <cocreature> there is a tutorial linked in the haddocks
13:01:29 * hackagebot wai-extra 3.0.10.1 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.10.1 (GregWeber)
13:02:22 <johnw> EvanR: ok, made it much better
13:02:28 <johnw> change this line:
13:02:29 <johnw> levels b (Grid nine) = [] : concatMap (uncurry levels) (toList $ liftA2 (,) (breakBox b) nine)
13:02:54 <johnw> there's still a space leak, but it's really slow now (takes a minute to reach 100 MB)
13:02:59 <EvanR> nice
13:03:09 <johnw> but that could be the nature of the problem, I don't know
13:03:30 <johnw> the thing was, lzw (++) was identical to (++), but it wasn't behaving as efficiently
13:03:38 <johnw> oh, wait
13:03:53 <johnw> it's not identical is it
13:03:54 <EvanR> is that even correct
13:04:05 <johnw> back to the drawing board
13:04:27 <sm> seems to imply the problem is in that area though
13:04:37 <EvanR> so the idea is we want to find the stamps at each level before going on to the next level and doing the same thing for the grids at each level
13:04:50 <EvanR> sm: well it is the heart of the traversal algorithm
13:04:53 <EvanR> would make sense
13:04:54 <johnw> right, something about the way lzw is taking the data apart is causing our problem
13:05:59 <sm> the : in lzw is lazy
13:06:27 <EvanR> ok
13:06:31 <EvanR> the : in lzw
13:06:51 <EvanR> on the left you have basically lzw (++) x y, on the right, lzw (++) xs ys
13:07:03 <EvanR> so laziness might not save you
13:07:46 <EvanR> wait no
13:07:49 <EvanR> you have ++ on the left
13:08:01 <EvanR> x ++ y : lzw (++) xs ys
13:08:10 <EvanR> doesnt seem bad
13:10:02 <johnw> this thunk for ':' will hold all of xs and ys in memory
13:10:19 <EvanR> all?
13:10:31 <EvanR> who evaluated all of xs and ys ;)
13:10:32 <johnw> it needs it, in order to satisfy your demand for the next value in the list
13:11:02 <johnw> you're constructing a recipe for processing the two lists, but we can only GC the initial elements of those lists with each step
13:11:26 <EvanR> i was trying to not generate the subsequent values of those two lists until that point though
13:11:53 <EvanR> maybe liftA2 (,) and uncurry is screwing with that?
13:12:03 <johnw> that is the part I'm least worried about
13:12:23 <clrnd> :t liftA2 . uncurry
13:12:24 <johnw> it's the Nine that is still worrying me
13:12:25 <lambdabot> Applicative f => (a -> b1 -> b -> c) -> f (a, b1) -> f b -> f c
13:12:26 <EvanR> the lists are both being generated by levels
13:12:33 <sm> you want foldr's function to evaluate as eagerly as possible, not hold on to thunks. But each lzw call adds a lazy recursion to the stack, which is not forced until some higher-up caller does so ?
13:12:37 <EvanR> and levels seems lazy too
13:13:37 <EvanR> sm: i grok the first part, assuming foldr is generating a normal value
13:13:47 <EvanR> though in this case its generating a list
13:13:54 <johnw> making Nine eager changes nothing, fwiw
13:14:02 <johnw> it makes the memory consumption even worse
13:14:19 <EvanR> like strict fields?
13:14:24 <johnw> yeah
13:14:28 <EvanR> how does that even work xD
13:14:42 <EvanR> its an infinite tree
13:14:46 <johnw> yeah
13:16:18 <clrnd> > liftA2 . uncurry $ (\a b c -> a + b + c) $ Just (1,2) $ Just 3
13:16:19 <lambdabot>      Couldn't match expected type ‘Maybe Integer -> b -> c’
13:16:19 <lambdabot>                  with actual type ‘Maybe (Integer, Integer)’
13:16:19 <lambdabot>      The first argument of ($) takes one argument,
13:16:29 <EvanR> only in haskell can you easily write a program that completely works and have no idea how it works ;)
13:17:28 <EvanR> i will try to evaluate this traversal by hand and see whats going on
13:18:07 <johnw> EvanR: if you make the assignment in breakBox strict, it helps a little bit more
13:18:12 <johnw> assignments*
13:18:17 <johnw> i.e., !w' = (width b) / 3
13:18:32 <johnw> it halves the consumption here
13:18:46 <EvanR> try b !l !t = Box l t w' h'
13:19:01 <EvanR> that should force the w' and h' too
13:19:13 <johnw> no effect
13:19:16 <EvanR> i noticed that helped last night with the other algorithm
13:19:30 <johnw> oh, maybe this didn't help at all
13:19:44 <johnw> anyway, I have no good ideas anymore
13:19:47 <johnw> good luck EvanR :)
13:19:49 <EvanR> \o/
13:20:04 <johnw> i wonder if you really are just generated data faster than you're consuming it
13:20:08 <johnw> generating*
13:20:27 <EvanR> yes that is happening, im ok with not being able to consume it faster
13:20:42 <EvanR> if only it would stop generating so fast!
13:20:52 <johnw> it's 9x
13:20:59 <sm> there ought to be some principled or systematic way to debug this >:-\
13:21:10 <EvanR> well theres evaluating the steps by hand
13:21:33 <cocreature> I thought the principled and systematic way to debug this was to wait for johnw to come up with a solution
13:21:42 <sm> so did I >:(
13:21:49 <sm> :)
13:21:54 <johnw> it's a small program, annotate every significant expression with SCC annotations, and do a -p profile
13:22:00 <EvanR> if anything i have learned that randomly putting ! does do stuff, usually bad stuff ;)
13:23:02 <EvanR> havent done a -p in a while...
13:23:31 <johnw> interesting
13:23:39 <johnw> showsPrec is 73% of your total allocation
13:23:43 <johnw> and your runtime
13:24:07 <johnw> guess that makes sense
13:24:19 <johnw> 42G total allocation after a few seconds of runtime
13:24:38 <EvanR> ok ill change how i print the data
13:24:41 <johnw> so, lwz allocates 5% of total memory, but it's responsible for keeping the vast majority of it resident
13:25:16 <johnw> and lzw is called 24,267,035 times
13:25:30 <sm> nice.. profiling FTW
13:26:00 <johnw> sm: this is usually the most principled and systematic way :)
13:26:47 <sm> I agree, although I find often (usually ?) profiles are very noisy and hard to interpret
13:28:10 <johnw> what I find really interesting is that for 7 seconds, memory residency actually goes DOWN
13:28:11 <EvanR> im not really sure the best way to "consume" these doubles without causing the consuming to take memory
13:28:20 <johnw> it starts at 400M, and gradually decreases to 300M
13:28:25 <EvanR> yeah when a previous level comes actually really lost maybe
13:28:29 <Welkin> hmm
13:28:33 <johnw> but then within 3 seconds it spikes up to 2GB
13:28:39 <Welkin> I'm setting up a new ubuntu server
13:28:41 <EvanR> oh gradually, thats the slow traversal of a level
13:28:48 <Welkin> I'm not well versed in linux sysadmin
13:29:09 <Welkin> I had to use sudo to run `make install` for the debian7 ghc bindist
13:29:15 <Welkin> will this cause problems?
13:29:15 <johnw> EvanR: makes sense
13:29:45 <EvanR> but what is setting up this huge thing at the beginning
13:29:51 <EvanR> "levels" obviously but...
13:34:13 <EvanR> http://lpaste.net/142638 this has no pesky printing residue
13:34:29 <EvanR> its task is to consume all the doubles of all the boxes
13:37:09 <johnw> EvanR: The output printed by this version is very "bursty"
13:37:25 <EvanR> it freezes when the program goes into "allocate all the things" mode
13:37:40 <johnw> so, why is it holding memory from previous iterations?
13:37:57 <johnw> now I see this: https://gist.github.com/31df39bca640620a4049
13:38:00 <EvanR> its hold some of it, some is gradually collected
13:38:43 <EvanR> i have the same report and i dont know what it means
13:39:19 <johnw> i think that levels is produces a lot of data that is being "captured" by lzw
13:39:23 <johnw> producing*
13:39:26 <johnw> wow, really can't type today
13:39:55 <EvanR> maybe lzw should generate the entire list instead of be lazy?
13:40:06 <johnw> dunno
13:40:15 <EvanR> wouldnt seem like it would help since its just shuffling list nodes
13:40:43 <johnw> considering that rewriting it to just be (++) solved most of the problem, I'd say it's worth a try
13:41:00 <EvanR> concatMap?
13:41:04 <johnw> yeah
13:41:17 <johnw> Although that changes the answer of course
13:41:32 * hackagebot fltkhs 0.2.0.1 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.2.0.1 (deech)
13:41:45 <EvanR> as long as its prints everything in the tree its fine but without graphical output im not sure
13:42:10 <EvanR> im not even sure i understand the lzw based approach
13:42:25 <johnw> lol
13:43:43 <EvanR> i guess lzw (++) is just a more hardcore version of concat
13:44:22 <EvanR> @src concat
13:44:23 <lambdabot> concat = foldr (++) []
13:45:17 <johnw> it interleaves the values from the two lists
13:46:39 <EvanR> ah right i had an explicit version of that before
14:09:51 <EvanR> johnw: does -hr indicate that a large amount of memory is sitting around which are thunks that will evaluate lzw? or is memory that is taken up by Nine objects not shown?
14:10:18 <EvanR> that was my original question -hb seems to show no "Use" category, perhaps actual data is being consumed instantly
14:11:34 <marchelzo> does anyone know if there is an active plt channel on freenode?
14:11:55 <johnw> EvanR: -hr is showing that thunks produced by lzw are causing that much memory to stay resident
14:12:09 <EvanR> oh right retainer
14:12:20 * EvanR tries -h
14:13:50 <EvanR> blast i cant read the whole line
14:14:33 <EvanR> http://i.imgur.com/3mavFIf.png
14:22:16 <deep> whats the best way to fold on an infinite list until a condition is met? i.e. something like: foldUntil (== 20) (+) 0 [1..] 
14:22:22 <deep> = 210
14:22:23 <chromatome> I know this isn't the right place but the elm channel is real quiet: Anyone know how to use the last returned value in elm-repl?
14:23:42 <dmj`> using Data.Data what's the best way to get a list of a records fields and types
14:23:50 <anelson-> hey guys, I'm using http-client's httpLbs function, and I'm getting
14:23:50 <anelson->     intermittent TlsExceptionHostPort errors... anyone encountered this?
14:23:56 <dmj`> the name of the fields, and the name of the types
14:24:17 <mniip> deep, takeWhile
14:24:23 <johnw> dmj`: print . constrFields . toConstr $ sample
14:24:24 <mniip> and/or until
14:24:32 <johnw> where sample is a value of the type of your record
14:24:48 <neals> shachaf, monochrom, ReinH: thanks for the help, figured out the type issue
14:24:54 <EvanR> deep: fold over the result of takeWhile
14:24:57 <mniip> and/or a computation monoid but you probably don't want that
14:25:17 <anelson-> 'TlsExceptionHostPort (HandshakeFailed (Error_Packet_unexpected
14:25:17 <anelson->     "Alert [(AlertLevel_Fatal,BadRecordMac)]" " expected: change
14:25:17 <anelson->     cipher")) "registry.npmjs.org" 443'
14:25:34 <dmj`> johnw: but does this give the name of the type of the fields 
14:25:51 <johnw> oh, *and* the name of the types
14:26:00 <johnw> dunno
14:26:10 <dmj`> yea :/
14:26:42 <EvanR> > typeOf Int
14:26:44 <lambdabot>      Not in scope: data constructor ‘Int’
14:26:44 <lambdabot>      Perhaps you meant one of these:
14:26:44 <lambdabot>        ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
14:26:58 <EvanR> > typeOf (0::Int)
14:26:58 <marchelzo> deep: I don't think there is an easy way to do it.
14:27:00 <lambdabot>  Int
14:27:21 <EvanR> marchelzo: we just gave him the solution!
14:27:56 <mniip> I mean something like
14:27:57 <mniip> > fold $ map (First . mfilter (> 6) . Just) $ [1..]
14:27:59 <lambdabot>  First {getFirst = Just 7}
14:28:07 <mniip> errr, make that foldMap
14:28:07 <anelson-> also, I'm trying to use wreq, and I'm attempting to set some options, and it's telling me "header" is not a record selector.... but it clearly is :(
14:28:13 <anelson-> similarly for manager
14:28:15 <anelson-> blargh
14:28:29 <deep> sorry, my example wasn't correct... what if the condition results on the value of the fold. like: foldUntil (> 200) (+) 0 [1..] == 210.. the signature would be something like: Foldable t => (b -> Bool) -> (b -> a -> b) -> b -> t a -> b
14:28:37 <dmj`> anelson-: did you try servant-client
14:28:48 <mniip> deep, scanl
14:28:49 <anelson-> dmj`: nope
14:28:49 <marchelzo> EvanR: Does folding over the result of takeWhile give you the same flexibility, though?
14:28:59 <dmj`> anelson-: is this the tarball thing
14:29:02 <anelson-> the thing I'm trying to do is so dead simple
14:29:09 <anelson-> I don't know why this is being so difficult
14:29:12 <EvanR> marchelzo: for the original question yes, though it has since been updated
14:29:23 <dmj`> anelson-: what is the url and expected response
14:29:24 <anelson-> do a get request.... that's it
14:29:44 <anelson-> http://registry.npmjs.org/<something> where <something> is an npm package
14:29:45 <EvanR> :t scanl
14:29:47 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
14:30:03 <anelson-> it works a ton of times and then breaks with that tls error...
14:30:33 <anelson-> I probably should go back to just using curl + shelly
14:30:41 <deep> sweet, scanl + takeWhile seems to work.. thanks 
14:30:48 <anelson-> but nooo I had to try to use some haskell libraries :P
14:31:08 <dmj`> anelson-: do you have the FromJSON instance handy? 
14:31:21 <ReinH> neals: sweet, did what I was saying about type and value level make sense? It's an important distinction, and the syntax of the language muddles it a bit in places like data definitions.
14:31:26 <dmj`> anelson-: gist me
14:31:36 <anelson-> dmj`: hold on a sec, it's kinda complicated
14:35:48 <anelson-> dmj`: https://gist.github.com/adnelson/f39cf312b9dbcb78e963
14:36:02 <marchelzo> How would you use scanl and takeWhile to imitate foldUntil (> 200)?
14:36:08 <dmj`> anelson-: done, http://lpaste.net/142646
14:36:14 <dmj`> anelson-: that took me like 2 minutes
14:36:15 <marchelzo> I guess you could use dropWhile.
14:36:50 <anelson-> dmj`: congratulations..?
14:36:56 <dmj`> anelson-: your welcome
14:37:13 <EvanR> marchelzo: or find
14:37:20 <marchelzo> scanl + dropWhile / takeWhile seems really inefficient; or is my intuition wrong?
14:37:22 <dmj`> anelson-: I told you to use servant-client last time
14:37:36 <EvanR> marchelzo: right, its lazy
14:37:43 <anelson-> dmj`: the problems I'm having are low-level
14:37:55 <EvanR> the lists dont have to actually exist
14:37:55 <anelson-> I'm able to fetch things just fine, and parse them etc
14:38:02 <marchelzo> In the colloquial sense, right?
14:38:09 <neals> ReinH: it kinda threw me for a loop because the data definition was correct, and it was the function that had the type issues.  But it helped to conceptualize things and gave me a better understanding of how the syntax works, so thank you for the diagram
14:38:19 <EvanR> marchelzo: lists or kind of like control flow structures
14:38:28 <EvanR> lists are*
14:38:31 <dmj`> anelson-: do we even need TLS to access the npm registry?
14:38:43 <anelson-> dmj`: all of the npm urls are https
14:38:45 <anelson-> so yeah
14:38:59 <anelson-> or at least http-conduit seems to think so
14:39:49 <marchelzo> EvanR: Do you mean lazy as in "you could do better but it would take more work", or lazy as in "the decision of when to terminate the computation is deferred"?
14:39:59 <anelson-> did you try checking out the repo and running it yourself?
14:40:28 <EvanR> marchelzo: neither in this case
14:40:35 <dmj`> anelson-: one sec
14:40:50 <dmj`> anelson-: so, http://registry.npmjs.org/<something>, should be https  ?
14:41:24 <anelson-> yeah that was just me typing off the top of my head
14:41:30 <marchelzo> EvanR: so, lazy as in the form of non-strict evaluation?
14:41:33 <EvanR> marchelzo: say you used find + scanl to select when during a fold to stop and produce the final value
14:41:35 <anelson-> I could convert urls to http instead of https but that's hacky
14:42:07 <EvanR> marchelzo: now when somebody uses that algorithm, they get the final value (assuming it exists), but its not necessary for any lists to be created
14:43:15 <dmj`> anelson-: https works here it seems, http://lpaste.net/142647, it's using the same client too, strange...
14:43:40 <anelson-> dmj`: like I said, many many many requests work, and then one of them will fail for no apparent reason
14:44:35 <EvanR> @src find
14:44:35 <lambdabot> find p = listToMaybe . filter p
14:44:41 <marchelzo> EvanR: I see. So find forces the evaluation, but only of the list elements, not of the list.
14:44:55 <marchelzo> EvanR: So it can be done one at a time.
14:45:00 <anelson-> in any case, I'm not sure how to tell http-conduit not to use tls
14:45:09 <EvanR> whatever uses the final value will force the find, which traverses a list, which gets generated and disposed of incrementally
14:45:21 <monochrom> wait, you have to force the list in order to get to the elements you want to force
14:45:52 <EvanR> marchelzo: no list nodes will be created in process and collected
14:45:54 <anelson-> also not sure how to get it to catch an error so that things don't blow up if I 404, etc
14:45:59 <EvanR> in the process*
14:46:10 <marchelzo> right; I see.
14:46:18 <monochrom> but yeah, even forcing the whole list still does not mean Θ(n) memory
14:46:20 <EvanR> the values actually might not be used at all
14:46:28 <EvanR> as in the case of length
14:46:45 <dmj`> anelson-: that's strange, I'd make an issue
14:47:09 <marchelzo> lazy streams are tricky
14:47:31 <darkstalker> @src zipWith
14:47:32 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
14:47:32 <lambdabot> zipWith _ _      _      = []
14:47:33 <EvanR> they are more tricky if you allow side effects
14:47:40 <EvanR> like clojure
14:48:20 <marchelzo> Yes, I can see that making things more complicated.
14:48:47 <anelson-> also why does yesod's documentation not list the manager settings, grrrrr
14:48:47 <EvanR> theres a magic number 32 in their code, 32 nodes will be generated at a time. if one of the first 32 nodes causes an error, then getting the first node causes an error
14:48:56 <EvanR> if node 33 would cause an error, you can have the first node
14:49:08 <anelson-> or even link to their source :<
14:49:16 <marchelzo> EvanR: You can't be serious.
14:49:23 <EvanR> lol
14:50:04 <EvanR> thats also more to do with the fact that generating nodes eagerly runs all the code for that node and constructs all the data deeply
14:50:20 <EvanR> its a very thin layer of laziness
14:50:39 <Denommus> can I get in a list comprehension expression three elements from a list that aren't the same?
14:52:06 <EvanR> and its very easy to cause errors simply by virtue of dynamic typing
14:53:31 <marchelzo> Denommus: I don't think so, at least not without cheating.
14:53:36 <EvanR> marchelzo: this makes it annoying to debug stuff, but more seriously probably is that taking the first node will cause node 31's side effects whatever they are
14:54:22 <marchelzo> I imagine clojure programmers are carful to avoid mixing effects and lazy streams, then.
14:54:29 <marchelzo> careful, even.
14:54:40 <EvanR> that is something people say but theres really no other way
14:54:45 <EvanR> thats how you do loops
14:55:54 <EvanR> theres an idiom for taking a lazy list (the default kind of list) and returning it as-is by making sure its effects go
14:56:25 <koshmar> hey, what is wrong with this example? http://paste.ofcode.org/q4DpGTXHVEJ9Au7QHZgQ2L
14:56:58 <koshmar> it is example from learnyouahaskell for great good
14:57:02 <marchelzo> EvanR: Like force?
14:57:05 <Cale> koshmar: Applicative is now a superclass of Monad, and so you must define an instance of it whenever you define an instance of Monad
14:57:14 <Cale> koshmar: This is a new change in the Prelude
14:57:17 <EvanR> marchelzo: yeah if it was just putting force around it that would be awesome ;)
14:57:25 <EvanR> thats not the idiom
14:57:36 <marchelzo> EvanR: What is it?
14:57:40 <Cale> koshmar: You can easily define such an instance by writing  instance Applicative Prob where pure = return; (<*>) = ap
14:57:40 <koshmar> ok. thanks.
14:57:55 <marchelzo> Surely it could be built-in to the language, and have an unintrusive syntax.
14:58:07 <Cale> You may have to import Control.Monad in order to get 'ap'
14:59:17 <EvanR> marchelzo: surely, im trying to remember, its not documented because as you said why would you do that ;)
15:00:25 <EvanR> marchelzo: doall
15:00:33 <EvanR> theres also dorun and doseq
15:00:39 <EvanR> good luck!
15:01:10 <EvanR> marchelzo: in lisp, uninstrusive syntax usually means, undiscoverable syntax
15:02:09 <koshmar> it produces another error: http://paste.ofcode.org/3PUmPNQrC5WyJHSdUHQ7E6
15:03:19 <koshmar> or sorry
15:03:22 <koshmar> I see now
15:03:33 <koshmar> all works
15:03:35 <koshmar> thanks
15:12:02 <darkstalker> you can "overload" functions in haskell right?
15:12:32 <Welkin> darkstalker: that is what typeclass are for
15:13:01 <Welkin> fmap (+1) (Just 5)
15:13:03 <Welkin> > fmap (+1) (Just 5)
15:13:04 <lambdabot>  Just 6
15:13:08 <Welkin> > fmap (+1) [5]
15:13:10 <lambdabot>  [6]
15:13:15 <Denommus> marchelzo: well, it turns out I can
15:13:28 <darkstalker> i mean, if i define another function with the same name and different type signature, both coexist? or one gets shadowed?
15:13:30 <marchelzo> Denommus: What did you end up with?
15:13:33 <Denommus> marchelzo: [(a,b,c) | aRest@(a:_) <- tails l, bRest@(b:_) <- tail $ tails aRest, c <- tail bRest]
15:13:48 <Welkin> darkstalker: the version used is decided based on the type
15:13:50 <Welkin> :t fmap
15:13:51 <Denommus> > [(a,b,c) | aRest@(a:_) <- tails l, bRest@(b:_) <- tail $ tails aRest, c <- tail bRest] [1,2,3,4]
15:13:52 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:13:52 <lambdabot>      Couldn't match expected type ‘[Integer] -> t’
15:13:53 <lambdabot>                  with actual type ‘[(t0, t0, t0)]’
15:13:53 <lambdabot>      The function ‘[(a, b, c) |
15:14:07 <Welkin> :t fmap id (Just 5)
15:14:09 <lambdabot> Num b => Maybe b
15:14:15 <Welkin> :t fmap id [5]
15:14:17 <lambdabot> Num b => [b]
15:14:23 <Denommus> > let foo l = [(a,b,c) | aRest@(a:_) <- tails l, bRest@(b:_) <- tail $ tails aRest, c <- tail bRest] in foo [1,2,3,4]
15:14:25 <lambdabot>  [(1,2,3),(1,2,4),(1,3,4),(2,3,4)]
15:14:29 <darkstalker> ok, thanks
15:15:14 <MarcelineVQ> oh that's what you were trying to do
15:16:56 <marchelzo> > nub . map sort . replicateM 3 $ [1,2,3,4]
15:16:57 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,1,4],[1,2,2],[1,2,3],[1,2,4],[1,3,3],[1,3,4],[1,...
15:17:16 <marchelzo> hmm, that's not what I wanted
15:18:21 <arkeet> wait for it.
15:18:40 <marchelzo> > map (take 3) . permutations . nub $ [1,2,3,4]
15:18:41 <lambdabot>  [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2],[4,3,2],[3,4,2],[3,2,4],[4,...
15:19:32 <marchelzo> > nub . map sort . map (take 3) . permutations $ [1,2,3,4]
15:19:34 <lambdabot>  [[1,2,3],[2,3,4],[1,2,4],[1,3,4]]
15:19:47 <marchelzo> Alright, I'm done.
15:21:00 <arkeet> wait for it.
15:21:13 <mniip> > nub $ filter ((==) <*> nub) $ replicateM 3 [1,2,3,4]
15:21:15 <lambdabot>  [[1,2,3],[1,2,4],[1,3,2],[1,3,4],[1,4,2],[1,4,3],[2,1,3],[2,1,4],[2,3,1],[2,...
15:21:53 <arkeet> @let fun [] = []; fun (x:xs) = (x,xs) : fun xs
15:21:54 <lambdabot>  .L.hs:149:26:
15:21:54 <lambdabot>      Ambiguous occurrence ‘fun’
15:21:54 <lambdabot>      It could refer to either ‘L.fun’, defined at .L.hs:148:1
15:21:58 <arkeet> oh.
15:22:19 <arkeet> @let blah [] = []; blah (x:xs) = (x,xs) : blah xs
15:22:20 <lambdabot>  Defined.
15:22:32 <arkeet> > evalStateT (replicateM 3 (StateT fun)) [1..4]
15:22:33 <lambdabot>      Could not deduce (Num Char) arising from the literal ‘1’
15:22:33 <lambdabot>      from the context (Monad m, FromExpr (m (a, String)))
15:22:33 <lambdabot>        bound by the inferred type of
15:22:38 <arkeet> > evalStateT (replicateM 3 (StateT blah)) [1..4]
15:22:40 <lambdabot>  [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]
15:22:46 <arkeet> much better.
15:23:09 <arkeet> only generate the permutations you need.
15:23:13 * mniip tilts head
15:23:38 <arkeet> :t blah
15:23:39 <lambdabot> [t] -> [(t, [t])]
15:23:43 <arkeet> > blah [1,2,3,4]
15:23:45 <lambdabot>  [(1,[2,3,4]),(2,[3,4]),(3,[4]),(4,[])]
15:23:49 <mniip> headtails, right
15:24:30 <mniip> oh, StateT over []
15:24:33 <arkeet> yes
15:24:37 <arkeet> :t StateT blah
15:24:38 <lambdabot> StateT [a] [] a
15:24:47 <mniip> fancy
15:25:01 <arkeet> similar thing lets you get all permutations
15:25:02 <arkeet> @where select
15:25:02 <lambdabot> select [] = []; select (x:xs) = (x,xs) : (map.fmap) (x:) (select xs)
15:25:07 <arkeet> @@ @let @where select
15:25:08 <lambdabot>  Defined.
15:25:14 <arkeet> > evalStateT (replicateM 3 (StateT select)) [1..4]
15:25:15 <lambdabot>  [[1,2,3],[1,2,4],[1,3,2],[1,3,4],[1,4,2],[1,4,3],[2,1,3],[2,1,4],[2,3,1],[2,...
15:25:36 <arkeet> or if you want to allow repeats but still have the output sorted...
15:25:41 <marchelzo> arkeet: Had you seen that before, or did you come up with it just now?
15:25:50 <arkeet> @let fun2 [] = []; fun2 (x:xs) = (x,x:xs) : fun xs
15:25:51 <lambdabot>  .L.hs:151:31:
15:25:51 <lambdabot>      No instance for (FromExpr [(Char, [Char])])
15:25:51 <lambdabot>        arising from a use of ‘fun’
15:25:54 <arkeet> @let fun2 [] = []; fun2 (x:xs) = (x,x:xs) : fun2 xs
15:25:55 <lambdabot>  Defined.
15:25:59 <arkeet> > evalStateT (replicateM 3 (StateT fun2)) [1..4]
15:26:01 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,1,4],[1,2,2],[1,2,3],[1,2,4],[1,3,3],[1,3,4],[1,...
15:26:17 <arkeet> uh, the version with select to get all permutations I came up with a while ago.
15:26:22 <arkeet> the other two I just did now.
15:26:31 <arkeet> > evalStateT (replicateM 3 (StateT fun2)) [1..3]
15:26:33 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,2,2],[1,2,3],[1,3,3],[2,2,2],[2,2,3],[2,3,3],[3,...
15:26:58 <marchelzo> That's really impressive.
15:27:09 <arkeet> they're similar so I didn't have to think a lot today.
15:27:15 <mniip> > evalStateT (replicateM  (StateT fun2)) "bar"
15:27:16 <lambdabot>      Couldn't match expected type ‘StateT [Char] m a’
15:27:17 <lambdabot>                  with actual type ‘m0 a0 -> m0 [a0]’
15:27:17 <lambdabot>      Probable cause: ‘replicateM’ is applied to too few arguments
15:27:22 <mniip> > evalStateT (replicateM 3 (StateT fun2)) "bar"
15:27:24 <lambdabot>  ["bbb","bba","bbr","baa","bar","brr","aaa","aar","arr","rrr"]
15:27:34 <arkeet> yes, strings are better for display I suppose.
15:27:45 <mniip> arr
15:27:47 <arkeet> arr
15:28:18 <arkeet> > evalStateT (replicateM 3 (StateT blah)) "1234"
15:28:20 <lambdabot>  ["123","124","134","234"]
15:28:21 <arkeet> > evalStateT (replicateM 3 (StateT select)) "1234"
15:28:23 <lambdabot>  ["123","124","132","134","142","143","213","214","231","234","241","243","31...
15:28:24 <arkeet> yeah.
15:29:22 <mniip> @let moo [] = []; moo (x:xs) = (x, filter (/= x) xs) : moo xs
15:29:23 <lambdabot>  Defined.
15:29:30 <arkeet> @let fun3 [] = []; fun2 (x:xs) = (x,x:xs) : (map.fmap) (x:) (fun3 xs)
15:29:31 <lambdabot>  .L.hs:150:1: Warning:
15:29:31 <lambdabot>      Pattern match(es) are overlapped
15:29:31 <lambdabot>      In an equation for ‘fun2’: fun2 (x : xs) = ...
15:29:36 <arkeet> > evalStateT (replicateM 3 (StateT fun3)) "123"
15:29:37 <lambdabot>      Not in scope: ‘fun3’
15:29:37 <lambdabot>      Perhaps you meant one of these:
15:29:37 <lambdabot>        ‘fun2’ (line 150), ‘fun’ (imported from Debug.SimpleReflect)
15:29:39 <mniip> > evalStateT (replicateM 3 (StateT moo)) "hello"
15:29:41 <lambdabot>  ["hel","hel","heo","hlo","hlo","elo","elo"]
15:29:46 <arkeet> @let fun3 [] = []; fun3 (x:xs) = (x,x:xs) : (map.fmap) (x:) (fun3 xs)
15:29:47 <lambdabot>  Defined.
15:29:48 <arkeet> > evalStateT (replicateM 3 (StateT fun3)) "123"
15:29:50 <lambdabot>  ["111","112","113","121","122","123","131","132","133","211","212","213","22...
15:30:08 <arkeet> > evalStateT (replicateM 2 (StateT fun3)) "123"
15:30:09 <lambdabot>  ["11","12","13","21","22","23","31","32","33"]
15:30:12 <arkeet> yeah.
15:31:09 <mniip> well this is definitely a new set of combinators
15:34:07 <schell> hey guys - i have a type sig that i can’t express without allowambiguoustypes (i think)
15:34:12 <schell> http://lpaste.net/142649
15:34:37 <schell> is there another way to write this that gets around that error without ambiguous types?
15:35:00 <schell> “f” just has to be foldable, but it doesn’t show up in the type sig outside of the constraints…
15:35:43 <mniip> you have no way to specify which f to use
15:35:47 <jstimpfle> is there a common idiom for embedding either a writer or a read in a state?
15:35:58 <jstimpfle> i think such a thing might make sense for parsers
15:36:07 <jstimpfle> *reader
15:36:14 <mniip> I'm not too sure about the package you're working with, but passing 'f' in a Proxy is a solution
15:36:32 <mniip> or otherwise constraining f
15:37:47 <arkeet> > evalStateT (sequence [StateT blah, StateT blah, StateT fun3, StateT fun3])) "1234"
15:37:48 <lambdabot>  <hint>:1:75: parse error on input ‘)’
15:37:51 <arkeet> > evalStateT (sequence [StateT blah, StateT blah, StateT fun3, StateT fun3]) "1234"
15:37:53 <lambdabot>  ["1233","1234","1243","1244","1344","2344"]
15:37:55 <schell> mniip: i’d like that function to be able to take any foldable f, i guess that means it is ambiguous
15:38:02 <arkeet> hmm
15:38:08 <schell> mniip: do you have an example of the proxy method?
15:38:15 <arkeet> right.
15:44:52 <dzhus````> Is there a recipe to avoid Double overflows when QuickCheck-ing numerical code? Is there a way to tell if x + (-x) is going to give me something other than 0 for certain x or at least if an overflow has already happened?
15:45:29 <mniip> schell, consider 'fold . return'
15:46:02 <mniip> if we compose these 2 functions we completely discard what monad is 'return' on, and what fodable is 'fold' folding over
15:46:06 <arkeet> dzhus````: wonder if you could write a wrapper around Double that errors on overflow?
15:46:08 <mniip> :t fold . return
15:46:09 <lambdabot>     Could not deduce (Foldable t0) arising from a use of ‘fold’
15:46:10 <lambdabot>     from the context (Monoid c)
15:46:10 <lambdabot>       bound by the inferred type of it :: Monoid c => c -> c
15:46:53 <arkeet> (assuming your code is polymorphic in the number type)
15:47:05 <mniip> otoh this is a bad example because it's a different issue...
15:47:07 <mniip> but nevertheless
15:47:08 <arkeet> or depending on things you could just use a different number type that doesn't overflow.
15:47:34 <schell> right - i’m basically asking the compiler to cheat - guess i’ll have to just use list
15:47:56 <schell> seems like a bummer though because the user should be able to provide the container type
15:48:29 <mniip> @let func :: (Monoid m, Foldable t, Monoid t) => Proxy t -> m -> m; func p x = fold $ asProxyOf p $ return x where asProxyOf :: Proxy t -> t a -> t a; asProxyOf _ = id
15:48:30 <lambdabot>  .L.hs:146:39:
15:48:31 <lambdabot>      Expecting one more argument to ‘t’
15:48:31 <lambdabot>      The first argument of ‘Monoid’ should have kind ‘*’,
15:49:18 <schell> mniip: where is Proxy defined?
15:49:29 <arkeet> @let func :: (Monoid m, Foldable t, Monad t) => Proxy t -> m -> m; func p x = fold $ asProxyOf p $ return x where asProxyOf :: Proxy t -> t a -> t a; asProxyOf _ = id
15:49:29 <mniip> hmmm
15:49:30 <lambdabot>  Defined.
15:49:41 <mniip> ooh oops
15:49:44 <mniip> Monad/Monoid
15:50:02 <schell> thanks - i’ll see if i can get something working
15:50:05 <mniip> schell, base:Data.Proxy
15:50:12 <schell> ah
15:50:14 <schell> thanks :)
15:50:16 <mniip> schell, your case is simpler, you don't need asProxyOf
15:50:22 <mniip> you just pass an extra argument
15:50:51 <mniip> anyway, how do you use this function:
15:51:09 <mniip> > func (Proxy :: Proxy []) "moo"
15:51:10 <lambdabot>  "moo"
15:51:30 <arkeet> can I change your func a bit.
15:51:32 <arkeet> @undefine
15:51:32 <lambdabot> Undefined.
15:51:39 <mniip> sure
15:51:40 <arkeet> @let func :: (Monoid m, Foldable t, Applicative t) => Proxy t -> m -> m; func p x = fold $ asProxyOf p $ pure x where asProxyOf :: Proxy t -> t a -> t a; asProxyOf _ = id
15:51:41 <lambdabot>  Defined.
15:51:48 <mniip> yeah that
15:51:48 <arkeet> > func (Proxy :: Proxy ZipList) "moo"
15:51:50 <lambdabot>      No instance for (Foldable ZipList) arising from a use of ‘func’
15:51:50 <lambdabot>      In the expression: func (Proxy :: Proxy ZipList) "moo"
15:51:53 <arkeet> :|
15:51:59 <arkeet> @let deriving instance Foldable ZipList
15:52:00 <lambdabot>  Defined.
15:52:01 <mniip> yeah, I thought about that too
15:52:02 <arkeet> > func (Proxy :: Proxy ZipList) "moo"
15:52:04 <lambdabot>  "moomoomoomoomoomoomoomoomoomoomoomoomoomoomoomoomoomoomoomoomoomoomoomoomoo...
15:52:53 <mniip> > func (Proxy :: Proxy (Const [()])) "moo"
15:52:55 <lambdabot>  ""
15:52:59 <arkeet> :)
15:53:23 <EvanR> darkstalker: you cant define another function with the same name in the same module
15:53:27 <mniip> now we just need to write mappend using 'func'
15:53:42 <arkeet> don't think you can.
15:53:44 <EvanR> besides typeclasses, there is no overloading mechanism
15:53:58 <arkeet> wait.
15:54:01 <arkeet> maybe you can. with some tricks.
15:54:27 <arkeet> like using reflection to stick one of the mappend arguments into the t type
15:54:41 <arkeet> which would have some awful Foldable instance
15:54:50 <arkeet> (i.e. illegal)
15:55:00 <EvanR> kmett-skell ;)
15:55:10 <mniip> askhell
15:56:16 <orion> On Fri Oct 9 2015 at 22:34:04 GMT-04 DST, the time will be 1444444444 when represented as a unix timestamp.
15:56:40 * hackagebot wai-extra 3.0.11.1 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.11.1 (GregWeber)
15:56:45 <EvanR> is the subset of timestamps that "look interesting" dense in the reals?
15:57:10 <orion> No, it's dense in the feels. :'(
15:57:14 <alexclark> so im calling a function that takes three arguments
15:57:20 <alexclark> the last is a computed value
15:57:29 <arkeet> it's not discrete?
15:57:34 <alexclark> is there anyway to write that point free?
15:57:38 <EvanR> UTCTime is a Fractional
15:57:51 <EvanR> so morally not discrete
15:57:52 <alexclark> i.e. areq textField "Title" (Just $ blogPostTitle blogPost  )
15:57:59 <arkeet> define "looks interesting" then.
15:58:17 <EvanR> arkeet: somebody would say set your chronometers were having a part about this number
15:58:31 <arkeet> alexclark: what's wrong with that?
15:58:37 <EvanR> party
15:59:02 <alexclark> arkeet: just wondering if i can kill that set of parens
15:59:28 <arkeet> well, f (g $ x) = f . g $ x
15:59:41 <arkeet> but it would look weirder if you applied it to that I think.
15:59:55 <arkeet> areq textField "Title" . Just $ blogPostTitle blogPost
16:00:00 <alexclark> arkeet: hmmm, think i tried that and it didnt compile
16:00:20 <arkeet> the original version is clearer so I would stick with that.
16:00:48 <alexclark> arkeet: cool thanks!
16:00:56 <arkeet> I also wouldn't mind areq textField "Title" $ Just (blogPostTitle blogPost)
16:01:11 <arkeet> or just
16:01:15 <tpsinnem> reading https://www.reddit.com/r/haskell/comments/17ca04/bjarnason_machines_and_stream_processing_link_to/ and other discussions on the 'machines' library i come across this notion of 'driving' a machine. i'd like to understand what is meant by that, and i haven't come across examples.
16:01:16 <arkeet> using parens everywhere
16:01:19 <arkeet> no need to be afraid of them
16:01:35 <monochrom> EvanR: IMO, if you stick to one actual computer, then the set of interesting timestamps is discrete because the computer has a fixed clock rate. but if you want a set of interesting timestamp to work for all computers, past present and future, then you want it dense because you want it to be good for arbitrarily faster computers
16:02:06 <alexclark> yeah, the `$` or `.` before the `Just` is blowing up
16:02:37 <alexclark> arkeet: trying to wrap my head around dots and dollars
16:02:46 <MarcelineVQ> dots and dollars, I like that
16:02:47 <arkeet> hm, it should work.
16:03:03 <alexclark> i usually just throw them in there till it compiles
16:03:23 <EvanR> uhm hold on, whats "discrete in the reals"
16:03:38 <alexclark> haskell has no distinction between a function and a value for a parameter right?
16:03:45 <arkeet> functions are values.
16:03:57 <arkeet> so as long as the types match, no.
16:04:51 <EvanR> alexclark compare and contrast the types (a -> b) -> c vs a -> (b -> c)
16:05:24 <schell> mniip: thanks! that did the trick
16:06:29 <EvanR> k discrete subset means all the points are isolated
16:11:24 <EvanR> at one point i thought there was a distinction between function values and non-function values
16:11:35 <EvanR> meaning im not sure anymore
16:15:11 <orion> Let's say I have two types, "StateT Foo IO a" and "StateT Foo Identity a". Is it possible to, in a syntactically concise way, run a value of the /latter/ within a computation of the former?
16:16:02 <orion> For example, if I am within the 'do' section of a StateT Foo IO a, can I have a line of code like, "doAThing", which has type "StateT Foo Identity a"?
16:17:12 <orion> I'm currently doing it this way: "runIdentity $ runStateT (doAThing) someState"
16:17:19 <orion> But it doesn't feel elegant to me.
16:18:17 <Clint> orion: hoist?
16:18:58 <orion> The reason it feels clunky is because I need to capture the new someState' and `put` it in the StateT Foo IO a do-block.
16:19:04 <orion> Clint: What do you mean when you say that?
16:19:11 <johnw> orion: this is what "hoist" is for
16:19:26 <orion> I've never heard of such a thing (/me googles)
16:19:33 <johnw> it's in the mmorph package
16:19:45 <johnw> you just need a provide a function Identity -> IO
16:19:52 <johnw> forall x. Identity x -> IO x
16:20:02 <johnw> return . runIdentity usually
16:21:21 <orion> This is very interesting!
16:22:39 <arkeet> :t state . runState
16:22:40 <lambdabot> MonadState s m => State s a -> m a
16:22:41 <Cale> orion: It's worth noting that what people usually do in cases like that is to use a type like  (MonadState Foo m) => m a  instead of  StateT Foo Identity a
16:23:12 <orion> Cale: What are the pros/cons of such a thing?
16:23:51 <Cale> Well, there is also an instance of MonadState Foo (StateT Foo IO)
16:24:01 <Cale> So, you get to use the thing directly
16:24:08 <arkeet> big pro ^
16:24:26 <Cale> However, personally I think MonadState is always the wrong abstraction.
16:25:12 <Cale> and you're pretty much always going to be happier in the end if you just either define your own type class for the operations which manipulate your state, or define a record type for those operations
16:25:56 <orion> Cale: Which option would you say is more beautiful?: mmorph or (MonadState Foo m) => m a
16:25:58 <Cale> Using a record type has the downside of requiring that you pass around the record of operations, but has more flexibility in terms of how the operations are implemented.
16:26:07 <Cale> I've never used mmorph for anything
16:27:15 <cdk> > let f = map snd . concatMap snd
16:27:16 <lambdabot>  <no location info>:
16:27:16 <lambdabot>      not an expression: ‘let f = map snd . concatMap snd’
16:27:16 <Cale> What is the type Foo in your case?
16:27:24 <Cale> Is it a record type?
16:27:30 <cdk> @def f = map snd . concatMap snd
16:27:31 <lambdabot>  Defined.
16:27:42 <Cale> are there any rules about which values of type Foo are valid states?
16:27:54 <cdk> @def g = (\f -> map f . concatMap f) $ snd
16:27:56 <lambdabot>  .L.hs:150:36:
16:27:56 <lambdabot>      Occurs check: cannot construct the infinite type: b ~ [(a, b)]
16:27:56 <lambdabot>      Expected type: (a, b) -> [(a, b)]
16:28:07 <Cale> cdk: lambdabot will respond to private messages
16:28:20 <cdk> why doesn't g typecheck? Is it because snd is used with 2 different types?
16:28:33 <cdk> Cale: sorry, I was using it to pose this question
16:28:34 <arkeet> cdk: yes, and f cannot be polymorphic.
16:28:36 <Cale> ah, okay
16:28:49 <orion> Cale: It's a parameterized record type.
16:29:08 <orion> data HandshakeState c d = ...
16:29:11 <cdk> arkeet: is there a way around it with NoMonomorphismRestriction or an explicit forall?
16:29:14 <Cale> Yeah, it's because the function you provided would need to require f to be polymorphic, i.e. it would have to be a higher rank type, and those can't be inferred
16:29:25 <Clint> speaking of the infinite type, should http://techtipshoge.blogspot.com/2011/06/church-number-with-ski-combinators.html work?
16:29:29 <Cale> orion: What things are in it?
16:29:43 <arkeet> @def g = (\(f :: forall a b. (a,b) -> b) -> map f . concatMap f) snd
16:29:45 <lambdabot>  Defined.
16:29:49 <Cale> orion: How do they change over the course of the program?
16:30:04 <arkeet> you need RankNTypes to let things take polymorphic arguments.
16:30:05 <orion> Cale: https://github.com/centromere/cacophony/blob/master/src/Crypto/Noise/Internal/HandshakeState.hs#L36
16:30:11 <nitrix> Does anyone see an immediate blocker with trying to implement a SSH client library in Haskell?
16:30:20 <orion> Cale: It's all crypto variables.
16:30:25 <arkeet> (and ScopedTypeVariables to give type annotations to arguments, but that's not strictly necessary)
16:30:37 <arkeet> @undefine
16:30:37 <lambdabot> Undefined.
16:30:44 <nitrix> The current ones are using C bindings and I couldn't get a single to work on Windows. Fixing them would require a similar amount of work.
16:30:54 <nitrix> s/single/single one/
16:32:07 <orion> Cale: "are there any rules about which values of type Foo are valid states?" -- The values contained within are public/private keypairs, symmetric keys, nonces, etc.
16:32:36 <orion> As a result, I guess the only rule is that they be calculated correctly, according to the spec.
16:32:43 <Cale> Yeah
16:33:02 <Lokathor> when, if ever, do more things get merged into base?
16:33:19 <Lokathor> example, would the stuff in the random package ever get merged into base?
16:33:41 <Cale> Okay, so, while you can just use StateT -- you might've noticed that get/put are a little awkward to use in cases where you just want to interact with one of those key pairs you have
16:34:22 <orion> Cale: I actually ran in to an issue where I "get"ed the state /before/ I called a function which mutated the state.
16:34:52 <orion> Cale: For example: https://github.com/centromere/cacophony/blob/master/src/Crypto/Noise/Internal/Descriptor.hs#L118
16:35:27 <Cale> Well, sure, nothing short of giving the pre-mutated and post-mutated things different types, and not using the StateT monad will protect you from editing things in the wrong order
16:35:57 <orion> Cale: I'm not as concerned about the order of mutation. It's my responsibility to do it correctly.
16:36:20 <orion> Cale: All I want to do is eliminate this ugliness: Descriptor.hs#L122
16:36:29 <Cale> But yeah, it's sort of annoying to get the state, and then separately have to unpack parts of it
16:37:00 <orion> Not only that, I have to runIdentity $ ..., and then `put` the mutated state back in place.
16:37:16 <orion> It's so annoying!
16:37:26 <orion> Hence, my question tonight. :)
16:37:41 <Cale> orion: So you might consider, rather than using MonadState with get/put, instead defining your own type class for the operations on your particular state type, and then writing an instance of the class for StateT (HandshakeState c d)
16:39:41 <Cale> But whether the best operations to have are merely compositions of get/put/modify with each of the parts of your handshake state, or something a bit more particular than that, well, you'd know better than me
16:41:09 <felixn> Cale: do you have a concrete example of that?  I've been doing a bit of StateT, and your approach sounds slightly different from what I've been doing, which is just creating functions to manipulate the state directing: customStateFn :: MonadState MyState m => a -> b -> m ()
16:41:51 <orion> Cale: hmm, that sounds interesting. Are you saying that I could have something like: "class HandshakeStateOperations a where ..." and then: "instance HandshakeStateOperations (StateT HandshakeState c d) where ..."?
16:42:16 <Cale> orion: yeah
16:42:29 <Cale> orion: and then you use those operations instead of the MonadState operations
16:42:51 <Cale> (you might name the class MonadHandshake)
16:43:01 <Cale> The other thing you could potentially do...
16:43:05 <Cale> is have
16:43:08 <orion> Would this require MultiParamTypeclasses
16:43:25 <Cale> uhh, yes
16:43:33 <Cale> Similarly to how MonadState does
16:43:56 <Cale> and probably functional dependencies as well for the m -> c d  constraint
16:44:37 <orion> Oh, hmm...
16:45:07 <Cale> So yeah, the other thing which is possible is   data HandshakeOps c d m = HandshakeOps { getLocalStaticKey :: m (Maybe (KeyPair d)), ... }
16:45:40 <Cale> and then pass a record of that type around, and you get to write polymorphic things like:
16:45:55 <Cale> foo :: (Monad m) => HandshakeOps c d m -> m (...)
16:46:34 <Cale> and then you *could* use StateT, but you could also just as well create a record of how to perform the operations using a bunch of IORefs
16:46:48 <Cale> or maybe you read the keys from various files when they're requested
16:47:15 <felixn> Cale: that's awesome, is there a name for that or a good article?  I can't seem to find that concept
16:47:26 <Cale> Those latter behaviours would require records of type HandshakeOps c d IO of course
16:47:40 <Cale> felixn: "good ol' functional programming"? :D
16:47:44 <Cale> heheh
16:47:46 <Cale> I dunno
16:48:03 <Cale> I guess it's a little different, you have the general monad m there
16:48:19 <Cale> So it's not quite like passing a bunch of plain functions around
16:49:23 <Cale> I don't have an article, but maybe I should write one
16:49:41 <orion> Cale: I think I'm going to opt for the "MonadHandshake" idea you suggested, but I'm not quite clear on the details.
16:50:26 <orion> Why is StateT needed in that case? Could I not merely have "instance HandshakeStateOperations (HandshakeState c d) where ..."?
16:50:28 <Cale> So, yeah, there's still a little thought which needs to go into what the best operations on the state are.
16:50:50 <Cale> orion: The class is for monads which support the operations on various parts of your state.
16:50:58 <orion> Luckily for me, all the operations have been defined precisely by the spec author.
16:51:46 <crobbins> is there a stack analogue for `cabal get` ?
16:52:29 <Cale> orion: So, you could have things like reading and writing the local static key
16:53:18 <Cale> orion: You also have that SymmetricHandshakeState type, and so you might also want a bunch of operations on the parts of *that* too.
16:53:47 <orion> I already have a bunch. :) https://github.com/centromere/cacophony/blob/master/src/Crypto/Noise/Internal/SymmetricHandshakeState.hs#L37
16:54:57 <Cale> btw, as a rule of thumb, usually if the type of an argument and the result of a function match, you want that argument last
16:55:13 <Cale> This is because functions of type (a -> a) are special
16:55:31 <Cale> for example, such a function might be supplied to the modify function.
16:55:44 <arkeet> :t execStateT
16:55:45 <lambdabot> Monad m => StateT s m a -> s -> m s
16:55:54 <arkeet> never mind.
16:55:56 <arkeet> yeah
16:56:37 <Cale> You'd really rather write  modifySHS (mixKey sb) rather than modifySHS (\shs -> mixKey shs sb) or something
16:56:50 <orion> Cale: Oh, interesting.
17:04:55 <delYsid> @pl \x -> fst x / bestScore > 2/3
17:04:55 <lambdabot> (> 2 / 3) . (/ bestScore) . fst
17:09:16 <felixn> http://lpaste.net/142651 <-- Cale that's a really fun concept :D
17:10:00 <Cale> felixn: for sure
17:10:05 <Cale> felixn: Makes testing really nice
17:10:36 <felixn> it's totally a thing, a thing I didn't know about
17:10:57 <SrPx> Is there any fully-featured library with dependent vectors (that are actually just indexed lists)? This: `data Vec (n :: Nat) (a :: *) where { Nil :: Vec Z a; (:<) :: Vec n a -> a -> Vec (S n) a }` ? I'm asking because someone suggested using them for one of my functions, and it makes sense, but then it wouldn't be compatible with anything else...
17:11:46 * hackagebot diagrams-pandoc 0.2 - A pandoc filter to express diagrams inline using the haskell EDSL _diagrams_  https://hackage.haskell.org/package/diagrams-pandoc-0.2 (bergey)
17:12:00 <SrPx> And I think I can't convert from lists to that type
17:18:35 <orion> Cale: I am writing that code now. Is this sort of what you had in mind?: http://lpaste.net/1834393567347343360 -- I am having difficulty juggling the 'c' and 'd' type variables.
17:19:02 <Cale> orion: Your m's don't have any arguments...
17:19:16 <Cale> orion: m is supposed to be a monad, so that'll be a kind error
17:19:40 <shachaf> GHC's errors are rarely kind to beginners.
17:19:47 <arkeet> haha
17:20:16 <orion> Cale: Hmm... so, "tokenPreS :: m c d"
17:20:20 <orion> (etc)
17:20:33 <Cale> orion: uhh, no
17:20:52 <orion> I'm confused.
17:21:48 <Cale> I was expecting operations like   getLocalStaticKey :: m (Maybe (KeyPair d)), modifyLocalStaticKey :: (Maybe (KeyPair d) -> Maybe (KeyPair d)) -> m (), ...
17:25:44 <orion> Oh. I see.
17:27:46 <shlevy> Hi all. Looking to implement a variant on dependently typed lambda calculus (just pi types and universes for now, no inductive types yet), but have no real experience in this. Is 'bound' a good library for a beginner in this space?
17:28:02 <orion> Cale: The token* functions define a sequence of operations which, by their nature, read and modify the state. However, the operations you're taking about are more elemental than that.
17:29:42 <orion> Was the class signature I wrote, "class (Cipher c, Curve d) => MonadHandshake m c d | m -> c d where" about what you were expecting?
17:32:37 <Cale> orion: yes
17:32:52 <Cale> orion: You might have more special operations on the state, and that's fine
17:33:29 <Cale> orion: But yeah, you'll want to say what their types are a bit differently. Remember that m is like IO or any other monad here, your operations will be functions which produce actions in that monad.
17:34:49 <orion> Awesome. Thank you so much for your help!
17:42:20 * hackagebot plugins 1.5.5.0 - Dynamic linking for Haskell and C objects  https://hackage.haskell.org/package/plugins-1.5.5.0 (JeremyShaw)
17:42:55 <SrPx> Can I add multiple #inline symbols in a single line?
18:09:13 <naudiz> does anyone have an expample code for parsing JSON?
18:09:38 <johnw> the http://hackage.haskell.org/package/aeson library has some
18:11:06 <naudiz> johnw: thanks
18:11:27 <khanage> naudiz: there's also lens-aeson, which is really nice
18:28:02 <Hijiri> what's MRP?
18:30:28 <Hijiri> nevermind, found it, it's monad of no "return" prop
19:25:19 <khanage> is hdbc the best way to deal with databases? which library should i learn?
19:26:10 <Welkin> khanage: what database?
19:26:22 <Welkin> Persistent is my favorite
19:26:30 <Welkin> it is very easy to use and has nice features
19:26:30 <khanage> Welkin: well, i'm not really too fussy (i'm just playing around) - so sqlite atm
19:26:45 <Welkin> it supports sqlite, mysql, postgresql, and others
19:26:56 <Welkin> automatic migrations
19:27:19 <Xe> with stack do I still have to maintain a .cabal file?
19:27:22 <Welkin> it generates all the code for you too, you just supply a scheme configuration using haskell types
19:27:26 <Welkin> Xe: yes
19:27:39 <Welkin> .cabal and stack.yaml
19:27:49 <Xe> Welkin: do you know if there's a `cabal install --save` or something?
19:27:50 <khanage> i had a look at persistent a long time ago
19:28:07 <khanage> i'll have another look now
19:28:13 <Welkin> if you need more advanced functionality, Esqueleto is an extension to PErsistent
19:28:32 <Welkin> PErsistent is by far the most production-ready ORM I have found in haskell so far
19:28:38 <Welkin> I only really use postgres however
19:28:52 <geekosaur> Xe, are you looking for package source? "cabal get"
19:28:57 <Welkin> there is opaleye, which is a SQL generator
19:29:09 <Xe> geekosaur: I mean i run the command, it installs the crap and then adds the dependency to my .cabal file
19:29:33 <geekosaur> I don't think anything does that for you currently
19:29:35 <Welkin> but it lacks many of the convenient features of persistent (mainly migrations and defining the schema once)
19:30:00 <Welkin> Xe: cabal will tell you what you need to add to your build-depends when you build the project
19:30:09 <Welkin> it even gives you the exact version
19:30:23 <Welkin> you have to add it yourself though
19:30:24 <Xe> Welkin: I realize, i'd like it to just be automatic
19:30:47 <Welkin> it is only automatic if you have an existing project without a .cabal and run `cabal init`
19:30:48 <geekosaur> I suspect editing a cabal file is not quite as trivial as you expect it to be
19:30:55 <geekosaur> especially if there are conditionals in play
19:31:05 <geekosaur> e.g. if impl(ghc >= ...)
19:31:11 <MarcelineVQ> You could make a custom tool, that checks for imports and adds them to .cabal for you
19:31:45 <MarcelineVQ> idk tho, it's not that big a hassle, how often do you add another lib passed a certain point
20:08:25 * hackagebot hjsonschema 0.7.0.0 - JSON Schema library  https://hackage.haskell.org/package/hjsonschema-0.7.0.0 (seagreen)
20:25:29 <grish> decided to check out this channel after seeing this https://gist.github.com/quchen/5280339https://gist.github.com/quchen/5280339
20:25:37 <grish> whoops, double paste
20:33:50 <Cale> grish: haha
20:34:19 <Cale> It's pretty quiet for some reason right now
20:34:39 <Cale> grish: be sure to let us know if you have any questions about the language :)
21:01:11 <orion> Cale: Can you recommend any good reading material for designing your own Monads?
21:01:40 <MarcelineVQ> (other people's monads)
21:02:05 <MarcelineVQ> :> Cale happens to have a monad tutorial or two tho iirc..
21:10:52 <nitrix> I remember reading a minimal example of a Brainfuck monad.
21:20:40 <grish> Cale: ha, thanks man. I've used haskell a fair bit (it's been awhile, though, I want to get better again) but I just started browsing irc channels and found that post
21:21:17 <grish> nitrix: brainfuck is pretty crazy. I wrote a simple implementation of the game Nim in it for a class last semester, it was...well, quite the brain fuck
21:44:48 <joeyh> http://hackage.haskell.org/package/brainfuck-monad  .. and I recently had some more fun with this; turns out that MOV is turing complete and there's a brainfuck-to-MOV translator, so now I have a haskell DSL that can make programs consisting entirely of MOV instructions
21:52:38 <hackrilege> > let f 0 _ = []; f n [] = []; f n x = concat [ y:f (n-1) x|y<-x] in f 2 "_!~"
21:52:40 <lambdabot>  "__!~!_!~~_!~"
21:54:16 <hackrilege> What is this f Known as?
22:01:31 <Cale> > let 0 **!~!*!~~*!~ _ = []; n **!~!*!~~*!~ [] = []; n **!~!*!~~*!~ x = concat [y:((n-1) **!~!*!~~*!~ x)|y<-x] in 2 **!~!*!~~*!~ "*!~"
22:01:33 <lambdabot>  "**!~!*!~~*!~"
22:05:53 <hackrilege> Lol
22:06:29 <hackrilege> > let f 0 _ = []; f n [] = []; f n x = concat [ y:f (n-1) x|y<-x] in f 3 "_|"
22:06:30 <lambdabot>  "___||_||__||_|"
22:07:22 <Cale> \o/___|||WPY___|||_
22:07:39 <hackrilege> !!?
22:07:57 <hackrilege> > let f 0 _ = []; f n [] = []; f n x = concat [ y:f (n-1) x|y<-x] in f 3 "12"
22:07:59 <lambdabot>  "11122122112212"
22:08:19 <Cale> > let f 0 _ = []; f n [] = []; f n x = concat [ y:f (n-1) x|y<-x] in f 3 "abc"
22:08:20 <lambdabot>  "aaabcbabccabcbaabcbabccabccaabcbabccabc"
22:08:47 * hackagebot deepcontrol 0.2.0.0 - Enable more deeper level style of programming than the usual Control.xxx modules express  https://hackage.haskell.org/package/deepcontrol-0.2.0.0 (KONISHI_Yohsuke)
22:08:54 <hackrilege> > let f 0 _ = []; f n [] = []; f n x = concat [ y:f (n-1) x|y<-x] in f 1 "12"
22:08:55 <lambdabot>  "12"
22:09:12 <hackrilege> > let f 0 _ = []; f n [] = []; f n x = concat [ y:f (n-1) x|y<-x] in f 2 "12"
22:09:15 <lambdabot>  "112212"
22:09:17 <johnw> you even talk to lambdabot in /query
22:09:33 <hackrilege> cale was teasing me
22:09:49 <hackrilege> i wrote it in /query
22:10:20 <hackrilege> but apparently my[test case was not clear
22:10:50 <hackrilege> its all permutations right?
22:11:05 <hackrilege> can i write it neater?
22:12:31 <hackrilege> all words of length n from a given alphabet
22:14:02 <hackrilege> id like to remove all this base case syntax
22:15:17 <hackrilege> glub glub
22:17:03 <hackrilege> can you write it neater?
22:20:03 <hackrilege> oh no it does not even work sorry
22:20:22 <hackrilege> i go in shame
22:24:23 <MarcelineVQ> > (\n ls -> nub . map (take n) $ permutations ls) 3 ['a'..'d'] --anywhere close to what you're after?
22:24:24 <lambdabot>  ["abc","bac","cba","bca","cab","acb","dcb","cdb","cbd","dbc","bdc","bcd","da...
22:26:07 <hackrilege> @where permutations
22:26:07 <lambdabot> I know nothing about permutations.
22:26:16 <MarcelineVQ> Data.List
22:27:25 <m0rphism> > replicateM 3 "abc"
22:27:27 <lambdabot>  ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","bb...
22:27:38 <m0rphism> if you already know about list monads
22:27:39 <m0rphism> :)
22:29:55 <hackrilege> http://lpaste.net/5909582537792946176
22:30:57 <hackrilege> @where replicateM
22:30:57 <lambdabot> I know nothing about replicatem.
22:31:28 <m0rphism> ok, so let's start with replicate
22:31:34 <m0rphism> > replicate 3 "abc"
22:31:35 <lambdabot>  ["abc","abc","abc"]
22:31:39 <hackrilege> im going for a minimal pure approach
22:32:16 <m0rphism> `replicate n a` repeats a n-times
22:32:36 <ircCoreTest> Is there a tool that show redundant imports?
22:33:25 <hackrilege> replicate a = a:replicate a
22:34:10 <m0rphism> hackrilege: no, that is repeat
22:34:15 <hackrilege> replicate = (a:).replicate
22:34:24 <hackrilege> oh.. sorry
22:35:07 <hackrilege> replicate n = (take n) repeat
22:35:18 <hackrilege> replicate n = (take n).repeat
22:35:43 <m0rphism> replicate n x = take n (repeat x)
22:36:10 <hackrilege> is my version wrong?
22:36:25 <m0rphism> I have joined the channel after you posted your version, so I can't tell
22:37:01 <m0rphism> If you don't know the list monad yet, it might be a good idea to learn this at a later point
22:37:19 <m0rphism> it took me some time getting used to monads :)
22:37:22 <hackrilege> > let f 0 _ = []; f n [] = []; f n x = concat [ y:f (n-1) x|y<-x] in f 2 "_!~"
22:37:23 <lambdabot>  "__!~!_!~~_!~"
22:37:47 <hackrilege> but im not sure it works
22:39:14 <hackrilege> i think it works...
22:39:53 <m0rphism> > let f 0 _ = []; f n [] = []; f n x = concat [ y:f (n-1) x|y<-x] in f 2 "ab"
22:39:54 <lambdabot>  "aabbab"
22:40:30 <m0rphism> the output type is [Char] and not [[Char]], so it enumerates some symbols and not words
22:41:10 <m0rphism> also if you would interpret the output as ["aa", "bb", "ab"] there would be "ba" missing
22:41:22 <hackrilege> yes
22:41:30 <m0rphism> if i understood correctly, what you meant by "all words of length n from a given alphabet"
22:41:35 <hackrilege> it does not work
22:41:55 <hackrilege> i dont see why
22:42:35 <hackrilege> maybe the wildcard
22:43:04 <hackrilege> > let f 0 x = x; f n [] = []; f n x = concat [ y:f (n-1) x|y<-x] in f 2 "_!~"
22:43:07 <lambdabot>  "___!~!_!~~_!~!__!~!_!~~_!~~__!~!_!~~_!~"
22:43:11 <johnw> hackrilege: this is getting a bit old
22:43:22 <hackrilege> already...
22:43:39 <hackrilege> i just got it...
22:43:51 <hackrilege> you guys are cranky
22:43:59 <MarcelineVQ> He might mean you can do your testing in a private message to lambdabot
22:44:05 <MarcelineVQ> I'd use ghci personally
22:44:06 <hackrilege> thanks for the examples
22:45:06 <hackrilege> im on a phone. ill get haskell to compile to it via c shared libraries later
22:47:02 <hackrilege> im sorry i came with a bug in my question
22:52:03 <shuny> \exit
22:52:42 <m0rphism> what about:
22:52:43 <m0rphism> f :: Int -> [Char] -> [[Char]]
22:52:43 <m0rphism> f 0 _     = []
22:52:43 <m0rphism> f 1 alpha = map (:[]) alpha
22:52:43 <m0rphism> f n alpha = [ c : cs | c <- alpha, cs <- f (n-1) alpha ]
22:53:58 * hackagebot hstatistics 0.2.5.3 - Statistics  https://hackage.haskell.org/package/hstatistics-0.2.5.3 (VivianMcPhail)
22:54:32 <m0rphism> it's not as terse as `replicateM n alpha` but it's probably more clear what's going on.
22:54:47 <m0rphism> hackrilege: ping
23:19:42 <jg> hi all. I'm getting the following type error Expected type: [String],  Actual type: [text-1.2.1.3:Data.Text.Internal.Text]. Shouldn't OverloadedStrings take care of this sort of stuff?
23:20:32 <jg> function is tags :: [Node] -> [String]; tags nodes = catMaybes $ map tagName nodes
23:22:32 <m0rphism> jg: OverloadedStrings makes string-literals polymorphic, but does not automatically convert between Text and String
23:23:03 <jg> oh, alright
23:23:10 <jg> thanks m0rphism
23:23:16 <m0rphism> you're welcome :)
23:24:16 <m0rphism> jg: for conversion there are Data.Text (pack, unpack)
23:29:04 * hackagebot language-qux 0.2.0.0 - Utilities for working with the Qux language  https://hackage.haskell.org/package/language-qux-0.2.0.0 (hjwylde)
23:49:50 * hackagebot qux 0.2.0.0 - Command line binary for working with the Qux language  https://hackage.haskell.org/package/qux-0.2.0.0 (hjwylde)
