00:13:19 <emmanuel_erc> sorry roelof, I was preoccupied for a moment.
00:18:46 <roelof> emmanuel_erc:  np
00:23:16 <emmanuel_erc> I am actually going to head out now. It is getting really late here.
00:24:50 <lf94_> Microsoft has funded a surprising amount of Haskell research.
00:27:06 <roelof> emmanuel_erc:  then I wish you a good night sleep 
00:59:51 * nicola_
01:13:38 <meditans> jcp: hi
01:14:03 <jhrcek> Hello. I'd like to rewrite this: 'x' `elem` "MyString" using ByteString. But 'x' `BS.elem` "MyByteString" doesn't work because 'x' is char.
01:14:24 <jhrcek> Is there a way to do that using literal like 'x'?
01:14:55 <mauke\documents> yes, using the Char8 version of elem
01:15:14 <mauke\documents> or doing the conversion manually: fromIntegral (ord 'x') `BS.elem` ...
01:18:09 <jhrcek> mauke\documents: Char8 worked. Thank you!
01:18:17 <varaindemian> can anyone explain me // produc [] = 1 // product (x:xs) = x * product xs?
01:19:03 <varaindemian> I do not understand the product(x:xs)
01:19:27 <opqdonut> varaindemian: the product of an empty list is 1. the product of a list [x,...] is x * product [...]
01:20:03 <opqdonut> varaindemian: the "product (x:xs)" part is pattern matching on the list constructor
01:20:12 <varaindemian> opqdonut: why don't we simply use product [x, xs]
01:20:23 <opqdonut> varaindemian: that would pattern match on a list of length 2
01:20:40 <opqdonut> varaindemian: the pattern (x:xs) means x is the first element of the list and xs is the rest of the list
01:20:55 <opqdonut> > let (x:xs) = [1,2,3] in x
01:20:56 <lambdabot>  1
01:20:58 <opqdonut> > let (x:xs) = [1,2,3] in xs
01:20:58 <tdammers> maerwald: I've figured it out, taking the dangerous route via Vector.zipWith
01:21:00 <lambdabot>  [2,3]
01:21:09 <tdammers> maerwald: works fine as long as both images are the same size
01:21:15 <opqdonut> > let [x,xs] = [1,2,3] in xs
01:21:16 <lambdabot>  *Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern [x,...
01:21:20 <opqdonut> see?
01:23:14 <varaindemian> opqdonut: the "let" syntax is kinda confusing
01:24:23 <varaindemian> opqdonut: but I figured out how it works. I would say that for me more naturally would have been x in [1,2,3]
01:26:05 <tdammers> I remember being disappointed that one cannot pattern-match on arbitrary functions
01:26:22 <tdammers> > let 5 * b = 15 in a
01:26:24 <lambdabot>  a
01:26:31 <tdammers> uhm
01:26:33 <tdammers> > let 5 * b = 15 in b
01:26:35 <lambdabot>  b
01:26:46 <kadoban> XD
01:27:03 <mauke\documents> > let 5 * foo = 15 in foo
01:27:05 <lambdabot>      Not in scope: ‘foo’
01:27:05 <lambdabot>      Perhaps you meant ‘for’ (imported from Data.Traversable)
01:27:06 <kadoban> tdammers: I think lambdabot has most single letters specially defined … though I have no idea what's going on there.
01:27:13 <mauke\documents> local definition of *
01:27:30 <mauke\documents> > let 2 + 2 = 5 in 2 + 2
01:27:31 <lambdabot>  5
01:27:36 <tdammers> yeah, that
01:27:48 <mauke\documents> a very partial function
01:31:48 <nshepperd> heh, pattern matching on arbitrary functions sure would be useful
01:32:57 <mniip> you can do that with injective type families
01:33:01 <nshepperd> let encrypt msg key = "ciphertext" in msg
01:33:24 <mniip> :t undefined :: ((3 * x) ~ 15) => Proxy x
01:33:25 <lambdabot> Not in scope: type constructor or class ‘*’
01:33:35 <mniip> hm, no GHC.TypeLits
01:33:48 <tdammers> well, it does work for operators implemented as constructors
01:39:03 * hackagebot tip-lib 0.2 - tons of inductive problems - support library and tools  https://hackage.haskell.org/package/tip-lib-0.2 (DanRosen)
01:39:05 * hackagebot tip-haskell-frontend 0.2 - Convert from Haskell to Tip  https://hackage.haskell.org/package/tip-haskell-frontend-0.2 (DanRosen)
01:41:40 <varaindemian> do you guys use haskell-mode in emacs or smth else?
01:55:28 <Cale> varaindemian: When I used emacs, I tried it, but it mostly got in the way. I think now I'd just (setq-default indent-tabs-mode nil) and run with it, but I guess if someone is the sort of person who wants to use emacs in the first place, it's hard to resist trying for more fancy editor features.
01:59:04 * hackagebot repa-linear-algebra 0.3.0.0 - HMatrix operations for Repa.  https://hackage.haskell.org/package/repa-linear-algebra-0.3.0.0 (mjmrotek)
02:00:46 <mniip> hmm
02:01:33 <mniip> so many design questions
02:15:09 <mniip> so I've had this idea
02:15:24 <mniip> vectors indexed by types inhabited by finitely many values
02:15:34 <mniip> inhabited by exactly as many values as there are slots in the vector
02:16:05 <mniip> something along the lines of
02:16:28 <mniip> data Vector l a where Nil :: Vector Void a; Cons :: a -> Vector l a -> Vector (Maybe l) a
02:17:06 <mniip> question is, does it make sense to include index type in the vector type like that
02:17:39 <kadoban> mniip: Isn't the whole point of a vector O(1) lookup?
02:17:52 <mniip> no?
02:18:11 <kadoban> Then what's the point of it?
02:19:10 <mniip> vector is a mathematical term describing a cartesian exponent of a set
02:19:42 <mniip> v(0, x) = 0, v(1, x) = x, v(2, x) = x*x, v(3, x) = x*x*x ...
02:20:51 <mniip> "a 5-dimensional vector over reals" is just a fancy way of saying "5 reals in a specified order"
02:21:00 <mniip> not related to implementation details whatsoever
02:21:22 <kadoban> A vector is also another name for an array, which is what I thought you were referring to.
02:22:46 <solarus> mniip: http://hackage.haskell.org/package/Vec-1.0.5 maybe
02:23:11 <solarus> but I guess there are more typed-length vector packages
02:23:18 <solarus> on hackage that is
02:23:22 <Unhammer> data L = A | B; [ w | w <- [A,B,B,A] ] -- how do I filter out only the A's there?
02:23:33 <Unhammer> within the list comprehension
02:23:35 <mauke\documents> define "filter out"
02:23:46 <Unhammer> I want [A,A]
02:23:58 <solarus> Unhammer: just replace both w's with A
02:24:00 <Unhammer> (have other stuff going on in the list comprehension too of course, just simplified it here)
02:24:18 <mauke\documents> [ w | w@A <- [A,B,B,A] ]
02:24:39 <mniip> solarus, what about it
02:26:00 <mniip> solarus, the question specifically is,
02:26:11 <mniip> does it make sense to keep a *-kinded type in the type signature
02:26:12 <Unhammer> does that work if e.g. data L = A{get::Int}|B ?
02:26:26 <Unhammer> (can't even get the A|B example to work in the repl)
02:26:35 <mniip> on one hand, you get index :: Vector l a -> l -> a, tabulate :: (l -> a) -> Vector l a
02:27:09 <mniip> on the other hand, * is not a total kind, so you get nonsense like "Vector () a" which is uninhabited but still ghc-possible
02:27:53 <mniip> because then this leads us to another issue
02:28:01 <saulzar> mniip, There's hvect - which is kind of like that, but it's indexed by length too .. I've found uses for what you describe as well
02:28:33 <mniip> what does hvect have to do with anything I just said
02:28:52 <mauke\documents> [ w | w@A{} <- [A,B,B,A] ]
02:29:05 <mauke\documents> except that's a type error
02:29:08 <saulzar> <mniip> vectors indexed by types inhabited by finitely many values
02:29:24 <mniip> HVect is not indexed by an inhabited type
02:29:40 <mniip> [*] is not an inhabited type
02:31:01 <mniip> er rather
02:31:07 <mniip> things of kind [*] are never inhabited
02:31:10 <saulzar> No, but it's closely related - and you can definitely do what you're talking about if I understand you right
02:31:24 <mniip> the question is not whether I could
02:31:28 <mniip> I already can and did
02:31:38 <mniip> the question is whether I should, whether it makes sense
02:32:05 <saulzar> I've found such a thing useful before
02:32:12 <mniip> because the next problem is tensors
02:32:41 <mniip> those are indexed by lists of indices
02:33:08 <mniip> I could use type-lists there, but then there is a problem, type-lists are uninhabited
02:33:19 <mniip> so far I've used () and (,) as nil and cons
02:33:32 <mniip> producing ugly types like (A, (B, (C, (D, ()))))
02:34:00 <saulzar> With an infix operator it doesn't look so bad...
02:34:21 <mniip> hmm
02:34:22 <saulzar> You can have something which looks like A :+: B :+: C :+: D 
02:34:38 <mniip> you mean type (:+:) = (,)
02:34:46 <mniip> or a new datatype
02:34:54 <mniip> hmm actually
02:34:58 <mniip> that's not too bad of an idea
02:35:06 <solarus> mauke\documents: I guess your type-error is because `A' and `B' does not have the same type if you have `data L = A { get :: Int } | B', thus, you cannot mix them in a list `[A, B]'
02:35:27 <solarus> [A 1, B, ... ] would work though
02:35:53 <mauke\documents> yes
02:36:14 <mniip> except mauke\documents isn't the one asking
02:36:21 <saulzar> mniip, Saw this in the monoid-extras package, CoProduct and MList
02:39:56 <jophish> Can anyone recommend a weighted csp solver?
02:40:19 <Unhammer> why does the repl only repeat my input for that though?
02:40:24 <Unhammer> λ> head $[ w | w@A{} <- [A 1,B] ]
02:40:26 <Unhammer> head $[ w | w@A{} <- [A 1,B] ] :: L
02:40:49 <mniip> what repl is that
02:40:56 <Unhammer> oh PEBKAC
02:41:01 <Unhammer> forgot to derive show on L :)
02:41:16 <Unhammer> thanks mauke\documents, mniip 
02:42:02 <mtesseract> Hi. Say I have a list "actions" of IO actions of type (each action being of type IO ()) and I want to form a new IO action which is the result of all the IO actions in the list executed one after the other. This works with e.g. "mapM_ (\f -> f) actions". I'm wondering, is there a nicer way to write this?
02:42:31 <tdammers> mtesseract: sequence
02:42:38 <tdammers> :t sequence
02:42:40 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
02:42:50 <mniip> :t sequence_
02:42:52 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
02:43:07 <mniip> specifically, mapM f = sequence . map f
02:44:31 <fizruk> is there a shorter version of \(i, x) (j, y) -> (i == j) == (x == y) ?
02:44:41 <mtesseract> ah, sequence_ seems to do it. Thanks tdammers and mniip.
02:45:40 <mtesseract> fizruk: the equality operator should be able to compare pairs (whose values support ==) directly, no?
02:45:45 <mauke\documents> @pl \(i, x) (j, y) -> (i == j) == (x == y)
02:45:46 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (==)) . flip . (((.) . (==)) .) . (==))
02:45:54 <mtesseract> fizruk: ah, sorry, I had misread.
02:46:01 <fizruk> mtesseract: that would be (i == j) && (x == y)
02:46:23 <kriztw> wow, that is disgusting lambdabot :D
02:46:35 <mauke\documents> @. unpl pl \(i, x) (j, y) -> (i == j) == (x == y)
02:46:35 <lambdabot> uncurry (\ ab f b -> (snd >>= \ af -> return ((\ p x -> (ab == (fst p)) == (f == x)) b af)) b)
02:47:21 <mniip> :t (uncurry (==) .) . uncurry ((. (==)) . (***) . (==))
02:47:23 <lambdabot> (Eq a, Eq b) => (b, a) -> (b, a) -> Bool
02:48:14 <mniip> :t (uncurry (==) .) . uncurry ((***) `on` (==))
02:48:15 <lambdabot> Eq b => (b, b) -> (b, b) -> Bool
02:48:21 <mniip> oh hm, it's type-restricted
02:51:42 <fizruk> :t (uncurry (==) .) . Data.Biapplicative.biliftA2 (==) (==)
02:51:43 <lambdabot> (Eq a, Eq a1) => (a, a1) -> (a, a1) -> Bool
02:51:59 <fizruk> without qualified name it is shorter, I think)
02:52:25 <mniip> :t biliftA2
02:52:26 <lambdabot>     Not in scope: ‘biliftA2’
02:52:26 <lambdabot>     Perhaps you meant ‘liftA2’ (imported from Control.Applicative)
02:52:30 <mniip> aw, not in scope
02:52:41 <fizruk> :t Data.Biapplicative.biliftA2
02:52:43 <lambdabot> Data.Biapplicative.Biapplicative w => (a -> b -> c) -> (d -> e -> f) -> w a d -> w b e -> w c f
02:52:47 <mniip> yeah yeah
02:52:53 <mniip> I was checking scopiness
03:04:07 * hackagebot packed-dawg 0.2.0.8 - Generation and traversal of highly compressed directed acyclic word graphs.  https://hackage.haskell.org/package/packed-dawg-0.2.0.8 (AndrasKovacs)
03:05:37 <quicksilver> yo dawg I put a word graph in your word ... nah, I give up
03:11:02 <kadoban> XD
03:34:08 * hackagebot shadowsocks 1.20151028 - A fast SOCKS5 proxy that help you get through firewalls  https://hackage.haskell.org/package/shadowsocks-1.20151028 (rnons)
04:26:04 <jhrcek> Say I load a module, which declares {# LANGUAGE OverloadedStrings #} in GHCi.
04:26:21 <jhrcek> Shouldn't ghci have this extension enabled as well after loading it/
04:26:24 <jhrcek> ?
04:26:27 <mniip> no
04:26:43 <mniip> modules don't inherit extensions from things they import
04:28:18 <jhrcek> mniip: sounds reasonable. But I have to do :set -XOverl... every time I want to test it in repl. Isn't there some simple way?
04:28:39 <jhrcek> mniip: or maybe I'm too lazy :)
04:28:40 <mniip> ghci -XOverloadedStrings
04:28:51 <mniip> and use :r
04:29:19 <Hafydd> The solution I arrived at was to have a .ghci file in a certain directory that set those flags.
04:29:58 <mniip> I just pass flags on the command line
04:30:04 <mniip> and use the up-arrow in the shell
04:30:25 <jhrcek> mniip, Hafydd: cool. Thanks for the tips
04:30:27 <mniip> which I've also conveniently overridden to history-search-backward
04:30:29 <Hafydd> It gets tiresome when you have several flags.
04:30:31 <mniip> via inputrc
04:30:42 <Hafydd> (And when you need to use multiple machines to develop.)
04:31:14 <mniip> alias ghci=ghci -XKitchenSink -XKitchenSink -XKitchenSink -XKitchenSink -XKitchenSink -XKitchenSink -XKitchenSink -XKitchenSink -XKitchenSink -XKitchenSink -XKitchenSink -XKitchenSink -XKitchenSink -XKitchenSink
04:31:37 <Hafydd> Heh.
04:37:28 <quicksilver> you acn also :set
04:37:32 <quicksilver> :set -XOverloadedStrings
04:37:37 <quicksilver> :set -XNoOverloadedStrings
04:37:47 <quicksilver> that's the one I use most, because I pretty much hate that extension
04:37:52 <quicksilver> and I want to turn it off after I used it.
04:38:23 <quicksilver> I think ghci is not completely consistent about what it allows though - some extensions do 'leak through' just when you load a file, like flexiblecontexts/instances ?
04:38:53 <schoppenhauer> hi. how can I convert a Data.ByteString.UTF8.ByteString into a Data.ByteString.Lazy.Internal.ByteString?
04:41:04 <mauke\documents> http://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString-Lazy.html#v:fromStrict
04:42:59 <lyxia> schoppenhauer: Data.ByteString.Lazy.fromStrict ?
04:43:09 <jophish> Has anyone here used minizinc
04:44:14 <lyxia> schoppenhauer: UTF8.ByteString is Data.ByteString.ByteString and Lazy.Internal.ByteString is Data.ByteString.Lazy.ByteString
04:44:59 <schoppenhauer> lyxia: ok, thx. fromStrict works.
04:46:04 <schoppenhauer> hm maybe I should use Data.ByteString.Lazy.UTF8 from the start
04:47:36 <schoppenhauer> thank you!
04:47:42 <ChristianS> schoppenhauer: i don't know your exact use case, but Data.Text is much more common
04:47:58 <schoppenhauer> ChristianS: I am using fastcgi
04:48:04 <schoppenhauer> and it has a outputFPS
04:48:14 <schoppenhauer> function which wants a ByteString
04:48:17 <ChristianS> schoppenhauer: the utf8-string package offers only very limited functionality compared to Data.Text
04:48:26 <ChristianS> schoppenhauer: so? you just encode your Text
04:48:41 <schoppenhauer> ChristianS: what do you mean?
04:49:16 <schoppenhauer> ChristianS: ah, you mean encodeUTF8?
04:49:22 <ChristianS> schoppenhauer: yes
04:49:42 <schoppenhauer> ok. that's probably better, because I am using Data.Text elsewhere anyway.
04:49:45 <schoppenhauer> thx.
04:57:47 <someoneinthedark> :t []
04:57:50 <lambdabot> [t]
04:58:16 <opqdonut> weird, no forall
04:58:36 <opqdonut> oh well
04:58:40 <someoneinthedark> :t $ mapM_ (\x -> putStr (show x)) [1..5]
04:58:42 <lambdabot>     parse error on input ‘$’
04:58:42 <lambdabot>     Perhaps you intended to use TemplateHaskell
04:58:44 <tdammers> implicit forall
04:58:49 <someoneinthedark> :t mapM_ (\x -> putStr (show x)) [1..5]
04:58:50 <lambdabot> IO ()
04:59:03 <tdammers> forall t. [t]
05:00:05 <opqdonut> tdammers: sure, I'm just used to it being printed
05:00:10 <opqdonut> but it seems it isn't printed any more these days
05:01:38 <quicksilver> yes, lambdabot has always run with flags which make all foralls explicit
05:01:40 <quicksilver> I wonder what changed
05:03:43 <someoneinthedark> :q
05:03:52 <mauke\documents> :t runST
05:03:54 <lambdabot> (forall s. ST s a) -> a
05:07:06 <quicksilver> :t _1
05:07:07 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
05:10:53 <blueonyx> > 632.03-437.57
05:10:54 <lambdabot>  194.45999999999998
05:21:19 <quicksilver> how awe <3 floating point
05:21:33 <lf94_> Monad...is a generalization of Monoid?
05:21:40 <quicksilver> not really
05:21:53 <lf94_> ok
05:21:54 <quicksilver> you can set up a categorical framework in which they are linked ideas
05:22:00 <quicksilver> but in the context of programming, 'no'
05:22:30 <lf94_> well from what I'm seeing, in the context of programming...is the opposite
05:22:45 <quicksilver> what are you seeing?
05:23:05 <lf94_> doneIO :: IO()
05:23:15 <lf94_> seqIO :: IO a -> IO b -> IO b
05:23:22 <lf94_> apparently, that forms a monoid.
05:23:27 <quicksilver> for any monad m, there is a monoid on things of the form m ()
05:23:32 <quicksilver> yes
05:23:37 <quicksilver> btu the monad is much more than that.
05:23:51 <quicksilver> monoids are a pretty natural thing and they are all over the place.
05:24:04 <lf94_> unitIO :: a -> IO a
05:24:18 <quicksilver> it's also true that for any monad m there is a monoid on things of the form (a -> m a)
05:24:23 <lf94_> bindIO :: IO a -> (a -> IO b) -> IO b
05:24:31 <lf94_> And that...forms the monad.
05:24:49 <quicksilver> subject to a bunch of laws, yes.
05:24:56 <quicksilver> the laws are the important part.
05:25:06 <arbelos> Are there alternative list monad instances?
05:25:24 <lf94_> quicksilver, gotchya.
05:25:27 <quicksilver> not properly, arbelos 
05:25:38 <lf94_> quicksilver, it just looks like a generalization or something
05:25:39 <arbelos> ok
05:25:48 <lf94_> but clearly, not a generalization
05:26:05 <quicksilver> lf94_: I suppose 'generalization' is a slightly fuzzy term
05:26:17 <quicksilver> it's certainly true that you can start from the "monoid of effects" (your seqIO part)
05:26:25 <quicksilver> and then try to form that into a full monad.
05:26:26 <lf94_> honestly the unitIO and doneIO are the only 2 things that produce different behavior
05:26:52 <lf94_> seqIO and bindIO...they have the same behaviour
05:27:12 <lf94_> just a different way of connecting things
05:27:16 <quicksilver> they do the same effect combination, sure
05:27:22 <quicksilver> but bindIO is strictly more powerful
05:27:33 <lf94_> well yeah, you can pass a function to it.
05:27:35 <quicksilver> you can't define bindIO from seqIO
05:27:50 <quicksilver> things which only have seqIO and not bindIO are Applicatives.
05:27:59 <lf94_> right
05:28:13 <tdammers> but you can unambiguously implement seqIO in terms of bindIO
05:28:27 <quicksilver> and that would be one of the laws
05:28:36 <quicksilver> if you did decide to build things up in this order
05:28:49 <quicksilver> you'd require seqIO a b = a `bindIO` \_ -> b
05:29:08 <arbelos> quicksilver: trivial one?
05:29:10 <quicksilver> along with doneIO = unitIO ()
05:29:30 <quicksilver> arbelos: there is a kind-of instance using 'zip'
05:29:39 <quicksilver> arbelos: but it requires infinite lists for the laws to work out
05:29:58 <arbelos> hmm
05:30:03 <quicksilver> arbelos: ...or it requires to you restrict to some fixed finite length
05:30:15 <quicksilver> so "Lists of length exactly 7" have a zip-like monad instance
05:30:32 <arbelos> but functors then
05:30:46 <quicksilver> the functor instance is the same as the standard one
05:43:02 <javjarfer> Hi there! Anyone using last version of hs-tls?
05:44:14 * hackagebot hlint 1.9.22 - Source code suggestions  https://hackage.haskell.org/package/hlint-1.9.22 (NeilMitchell)
06:05:40 <Unhammer> uh is there a way to tell ghci that it's ok to gc now?
06:06:27 <Unhammer> just noticed that doing m<-readBigThing five times, memory increases by the same amount each time …
06:06:53 <opqdonut> http://hackage.haskell.org/package/base-4.8.1.0/docs/System-Mem.html#v:performGC
06:08:07 <lamefun> I'm an idiot, please help!
06:08:16 <Unhammer> hm, didn't help :/
06:08:23 <lamefun> Can't write anything...
06:08:48 <Unhammer> it's quite strange, you'd think it could let go of the old value when I overwrite the reference
06:10:15 <mauke\documents> lamefun: you just did
06:10:24 <quicksilver> you didn't overwrite a reference
06:10:27 <quicksilver> just to be pedantic
06:10:37 <quicksilver> you made a new binding which happened to shadow an old one
06:11:16 <quicksilver> but I think it probably is a bug in ghci if it doesn't realise that shadowed bindings are inaccessible
06:11:20 <quicksilver> I seem to remember this
06:11:37 <Unhammer> sorry, shadow :)
06:11:41 <Unhammer> ok
06:11:44 <Unhammer> hm
06:12:00 <obadz> any existantial+typefamilies/hlist expert want to help with this problem? https://gist.github.com/obadz/122da809d5a674180f17
06:13:47 <quicksilver> Unhammer: this SO discusses the bug http://stackoverflow.com/questions/26712188/how-can-i-make-ghci-release-memory
06:14:19 <Unhammer> aha
06:14:21 <Unhammer> thanks quicksilver 
06:15:14 <lamefun> mauke\documents, I mean in Haskell
06:19:39 <Unhammer> :reload solved it for me
06:19:44 <Unhammer> or, for my use-case
06:20:10 * quicksilver nods
06:20:47 <Unhammer> am writing a little presentation and wanted to use ob-haskell (thanks for the tip, quicksilver IIRC), but every time I eval'ed a code block the memory usage would increase hehe
06:20:57 <Unhammer> not good during demo time =P
06:23:38 <lamefun> Is it OK to make types that are really booleans, eg. "data ClearMode = ClearOnOpening | KeepContentsOnOpening"?
06:25:14 <mauke\documents> yes
06:25:54 <mauke\documents> booleans could be represented as Either () () anyway
06:27:47 <MasseR> lamefun: "type ClearMode = Bool". What would 'True' mean? How about 'False'? So yes, it's ok to create a separate type, some might even say it's recommended :)
06:28:51 <lamefun> but quicksilver said even newtypes are overkill
06:28:53 <roelof_> When I want to install stack. I see this error after apt-get update :  W: Failed to fetch http://download.fcomplete.com/ubuntu/trusty/dists/stable/Release.gpg  Could not resolve 'download.fcomplete.com'
06:29:17 <lamefun> and type system already gives enough safety for free
06:29:50 <magneticduck> reactormonk: ping download.fcomplete.com
06:29:51 <lamefun> although I don't understand what "for free" means in that case
06:30:10 <MasseR> lamefun: The coders are dumb. If you say 'type ClearMode = Bool', someone will eventually use it wrong
06:30:13 <obadz> so any charitable soul feels like helping with my existential problem? https://gist.github.com/obadz/122da809d5a674180f17
06:30:30 <MasseR> So what is the compiler giving you in this situation?
06:30:48 <MasseR> 1. Your value can be one or another
06:30:57 <MasseR> That's it
06:30:59 <MasseR> Pretty much
06:31:12 <lamefun> type ClearOnOpening = Bool
06:31:33 <magneticduck> lamefun: haskell has good datatypes
06:31:36 <magneticduck> use the things
06:31:47 <MasseR> lamefun: Great, you documented it. You still trust the coders
06:31:57 <MasseR> Compiler doesn't help you
06:32:20 <MasseR> f :: IO Bool
06:32:21 <magneticduck> lamefun: don't use haskell like you use C
06:32:24 <magneticduck> you filthy bastard
06:32:36 <magneticduck> and now I hide
06:32:43 <MasseR> g :: ClearOnOpening ()
06:32:44 <roelof_> magneticduck:  when I do the ping I see a request time out error message 
06:32:49 <MasseR> g :: ClearOnOpening -> IO ()
06:32:53 <MasseR> f >>= g
06:32:54 <magneticduck> reactormonk: then the issue isn't a stack problem
06:32:56 <magneticduck> it's a connection problem
06:32:59 <MasseR> Compiler is happy with that
06:33:21 <magneticduck> roelof_: I can't ping it either, I assume it's dead or something
06:33:42 <magneticduck> so, either the domain moved and the stack in the apt repository is really old
06:33:52 <magneticduck> in which case you should get stack from somewhere else
06:34:09 <magneticduck> .. or the server's down
06:34:11 <MasseR> lamefun: not sure where quicksilver said that even newtype is overkill, but depending on the situation it can be true. (he's a lot more experienced than me, who am I to say otherwise)
06:34:19 <roelof_> oke, that is a problem. I did all the steps from the official wiki page 
06:34:23 <MasseR> Take for example the classic example of bmi calculator
06:34:31 <MasseR> bmi :: Int -> Int -> Float
06:34:33 <MasseR> vs
06:34:39 <MasseR> bmi :: Weight -> Height -> Float
06:34:47 <MasseR> Where Weight and Height are newtypes
06:34:57 <MasseR> A nice example, but I wouldn't write it like that in real code
06:35:16 <lamefun> why not?
06:35:38 <magneticduck> roelof_: what OS / system
06:35:44 <magneticduck> oh lol
06:35:56 <magneticduck> debian-based linux k
06:35:58 <roelof_> MasseR:  I also not but Weight -> Height -> Float is clearer what the function does 
06:36:19 <roelof_> magneticduck:  I run a cloud ide which uses Ubuntu 
06:36:27 <dutchie> roelof_: shouldn't that be download.fpcomplete.com (missing the p)
06:36:35 <MasseR> lamefun: The example is such a simple example that the benefits wouldn't overcome the effort, for me at least :)
06:36:48 <srhb> dutchie: Yes indeed.
06:36:53 <lamefun> I mean with newtype you can restrict Weight and Height to sane values (i.e. positive).
06:36:55 <srhb> (The file is there and works just fine.)
06:37:41 <roelof_> dutchie:  you are right but it does not make any difference 
06:37:58 <MasseR> lamefun: You are absolutely right. There are benefits. You need to evaluate the benefits and effort for each case :)
06:38:05 <lamefun> MasseR, it's a reason why Haskell, in ideal world, should've been bought by Microsoft, not an argument against newtypes.
06:39:24 <roelof_> dutchie:  oke, with ping no difference. With apt-get update everything works fine
06:39:25 <MasseR> lamefun: I view it like this. type alias has documentation benefits, newtypes have documentation benefits and some invariant encoding properties. New datatypes have all of the previous benefits, but even more invariant encoding benefits
06:39:36 <quicksilver> I don't remember saying newtypes were overkill
06:39:42 <quicksilver> maybe they were for some specific case :)
06:40:38 <quicksilver> remember a newtype can only have a single constructor with a single argument. If you haev a single constructor with a single argument I don't think there are often reasons to use 'data'.
06:41:22 <lamefun> to restrict a more general type (eg. Text to VariableName)?
06:43:31 <humanoyd> Is the approach mentioned in http://stackoverflow.com/questions/10163604/how-to-reduce-duplication-in-the-build-depends-fields-of-a-cabal-file a good one?
06:44:17 * hackagebot aws-sdk-text-converter 0.4 - The text converter for aws-sdk.  https://hackage.haskell.org/package/aws-sdk-text-converter-0.4 (YusukeNomura)
06:45:07 <akfp> is there a channel for haskell + web / react?
06:45:20 <quicksilver> bah, ConduitM Event o m (Maybe foo) is an annoying type for these parsers
06:45:23 <quicksilver> need to fmap twice!
06:45:38 <humanoyd> akfp: if you find one, let me know
06:47:31 <akfp> I'm looking for some new comparisons of ghcjs + various react incarnations vs some other frp from the last months.  These projects are moving so fast, everything seems outdated.
06:48:53 <magneticduck> akfp: your only hope is to develop your own project that defines a small API to be implemented through the other project's logic
06:49:17 <magneticduck> so that you can hide your code from the fast development while not abandoning the advantage of better implementatoins
06:49:28 <magneticduck> but while you're at it, you might as well make it a whole library
06:49:37 <magneticduck> which will eventually add to the whole problem we started with
06:49:52 <martinvlk> magneticduck: :-)
06:51:46 <saulzar_> akfp, There's #reflex-frp which often has more general FRP discussion too...
06:58:46 <saulzar_> magneticduck, Then you can have a broken wrapper project as to maintain as well as a broken application :)
06:58:53 <magneticduck> yeah but that's FUN
06:59:33 <saulzar_> While you're at it define typeclasses so that you can prepare for new implementations 
07:09:09 <absence> is there anything in the standard library that converts "Monoid m => Either a m" to "Monoid m => m", converting Left to mempty?
07:10:00 <opqdonut> :t either (const mempty) id
07:10:01 <lambdabot> Monoid c => Either b c -> c
07:12:38 <tdammers> I remember stumbling upon a pair of functions Either a b -> Maybe b, and a -> Maybe b -> Either a b at one point
07:12:45 <tdammers> but hoogle doesn't turn up anything useful
07:14:12 <Xandaros> I wonder... can you simulate "kind classes"? :D
07:14:15 <ocramz> hi all! FFI question: I have to wrap a C signature `int Function( X , int** )` which dereferences the second pointer and fills structure X with its data
07:14:47 <ocramz> I tried with a nesting of `with` and `withArray` but it doesn't seem to work
07:15:39 <absence> opqdonut: thanks, that works. i suddenly remembered what i was looking for though:
07:15:42 <absence> :t fold
07:15:43 <lambdabot> (Foldable t, Monoid m) => t m -> m
07:15:52 <opqdonut> ah, right
07:15:55 <opqdonut> indeed
07:21:23 <alkabetz_> Can I make runghc … not leave behind directories in /tmp?  It should really clean up after itself.
07:21:32 <glguy_> Ocramz: use alloca to get a Ptr(Ptr Int)
07:21:58 <glguy_> Then you can peek that after the C call
07:23:35 <mpickering> alkabetz: there is an issue on the issue tracker abut that. I think it is meant to
07:23:57 <ocramz> glguy_ : thanks!
07:24:33 <glguy_> Use with instead of alloca if you want to initialize that pointer
07:24:41 <mpickering> alkabetz: https://ghc.haskell.org/trac/ghc/ticket/10986
07:25:20 <alkabetz> mpickering: Thanks!
07:25:30 <ocramz> glguy_ : let me get this right
07:29:44 <ocramz> glguy_ : I actually need to `poke` an array of Int into a Ptr (Ptr Int)
07:30:33 <ocramz> or perhaps there's something fundamental about pointers that I'm missing
07:31:25 <glguy_> Use withArray
07:31:57 <glguy_> To get a pointer to an array of Int
07:34:02 <glguy_> I don't know why your C function needs an int** instead of an int*. You can use with on the pointer to an array to get a pointer pointer
07:34:42 <tdammers> pointer-to-pointer is usually used for functions that allocate and initialize a data structure
07:35:38 <tdammers> size_t create_foobar(foobar** dst, size_t foobar_size); // create a foobar, store it in the first argument, return actual size
07:35:41 <tdammers> sth like that
07:36:15 <mr_max> does ghc have any auto parallelism? I'm getting cpu utilization > 100%, despite not having added any explicit parallel code.
07:36:51 <mr_max> built via stack (which created cabal file with "-threaded -rtsopts -with-rtsopts=-N" ghc-options
07:37:15 <MasseR> mr_max: it's possible that some of dependencies have been parallelized
07:37:33 <tdammers> that would be my guess too
07:37:44 <tdammers> some library that uses parallel stuff internally
07:38:07 <mr_max> Ok. I'll have a look to see what library could be running in parallel.
07:38:20 <tdammers> promising candidates are anything I/O, networking, etc.
07:38:40 <mr_max> I'm doing some numerical-type work, so the only library I can think of is hmatrix
07:38:55 <ocramz> tdammers: the function `int Function(X, int**)` I need to wrap is as follows: X is a type synonym for a pointer to a struct which will be filled by the values of the array pointed at by the second argument
07:39:21 <ocramz> tdammers, glguy_ : X at this point has already been allocated
07:39:34 <tdammers> ocramz: then you don't need the double pointer, unless it points to an array of pointers
07:39:57 <ocramz> it's not an invention of mine, it's an API I'm wrapping in Haskell
07:40:01 <tdammers> mkay
07:41:02 <tdammers> mr_max: hmatrix uses deepseq
07:41:05 <tdammers> mr_max: http://hackage.haskell.org/package/deepseq-1.4.1.2/docs/src/Control.DeepSeq.html
07:41:40 <tdammers> no wait, false positive
07:42:14 <ocramz> tdammers, glguy_ : this is the actual function: http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Vec/VecRestoreArray.html
07:42:42 <mr_max> tdammers: could I accidently be using `map` from hmatrix, which is parallel? I'm not being very careful with my import
07:43:02 <tdammers> mr_max: I'd expect that to be very unlikely to typecheck
07:43:11 <mr_max> thats what I was thinking
07:43:42 <merijn> mr_max: You could try profiling to see?
07:44:29 <mr_max> yes. I was thinking of that. Is there a handy profiling tutorial somewhere (e.g., marlow's book?)
07:44:48 <merijn> mr_max: Chapter 20 (I think?) of Real World Haskell covers a bunch of profiling stuff
07:45:09 <mr_max> merijn: ok, cool. I'll try that.
07:57:48 <lamefun> Why do list functions take and return 'Int' instead of some non-negative newtype?
07:58:00 <merijn> lamefun: Hysterical raisins
07:58:13 <merijn> lamefun: I think there was no Word type in Prelude initially
07:58:41 <lamefun> there were no newtypes/export control?
07:59:00 <merijn> lamefun: Could just be as silly as "no one really thought of that"
08:09:09 <hexagoxel> Network.Socket in "Sending and receiving data" notes that send/recv functions are pseudo-deprecated. does that extend to the versions of the functions that do not use `String` parameters?
08:09:37 <hexagoxel> e.g. sendBuf(To)
08:09:43 * hackagebot pathwalk 0.3.1.2 - Path walking utilities for Haskell programs  https://hackage.haskell.org/package/pathwalk-0.3.1.2 (chadaustin)
08:10:29 <merijn> hexagoxel: I would say the ones using String are bad in general, as for the rest. The idea was that "Network" would replace Network.Socket with a high level interface, but it never quite caught on
08:11:17 <merijn> hexagoxel: Hence the pseudo-deprecation notice, the goal was to move people to the higher level API. But if your already comfortable with sockets in C, you're probably better off (and have more flexibility) if you just stay with Network.Socket
08:11:48 <merijn> Since all the functions are basically trivial wrappers around C's
08:11:58 <hexagoxel> merijn: well, i just wrote me the server in c, now need the haskell client :)
08:12:39 <hexagoxel> merijn: thanks.
08:13:03 <quicksilver> > -1 :: Word
08:13:07 <lambdabot>  18446744073709551615
08:18:09 <merijn> quicksilver: If that behaviour annoys you, I've got THE library for you! ;)
08:18:46 <quicksilver> I'm not annoyed at all, I never use Word. I'm quite happy with Int.
08:19:17 <quicksilver> I was just pointing out that "use Word instead of Int to prevent calling take/drop on negative numbers" doesn't entirely work as expected.
08:19:44 <merijn> quicksilver: Maybe, but I could use some suck^H^H^H^Hbeta testers to see where the documentation is unclear ;) https://hackage.haskell.org/package/validated-literals
08:20:18 <vy> Hi all! IIRC, 2-3 months ago there was a link to a blog post on Hackernews and/or Proggit that a guy talking about how he has been using functional programming in real-world projects for a couple of decades. Anyone remembers the link?
08:20:30 <quicksilver> what *is* annoying is that none of C, Cmm, or Haskell has the ability to create efficient non-negative integers or efficient (wordsize*2) integers
08:20:43 <merijn> vy: Do you remember any names/details that could help figure stuff out?
08:20:58 <quicksilver> even though the basic capabilities (overlflow flags, neg flags) have been part of assembly language for every common CPU since the 1970s.
08:22:01 <vy> merijn: I have been Googling for a couple of days with combinations of "purely functional programming real-world industry experience" keywords, but had no luck so far. The guy was explaining how he has been using (purely?) FP approach through out his entire IT career, etc.
08:22:23 <notdan> vy: I do remember that post as well
08:23:10 <notdan> but cannot find it
08:23:20 <vy> He had developed networking apps, apps with GUIs, database connectivity, etc.
08:23:26 <vy> You got it...
08:23:45 <merijn> Doesn't ring any bells for me
08:24:52 <orion> If you have a function whose type is "Foo a b c -> c", is it best practice to leave out the class constraints on 'a' and 'b' since the values for those types are never used?
08:24:58 <notdan> vy: http://logicaltypes.blogspot.nl/2015/08/pure-functional-programming-claims-irl.html
08:25:08 <notdan> Is this the post you are looking for?
08:25:21 <quicksilver> orion: I would say so. I don't see any reason to include constraints not needed.
08:25:23 <merijn> orion: Yes
08:25:32 <orion> Alright, thanks.
08:25:37 <orion> That would be a cool hlinting module.
08:26:00 <vy> notdan: Fscking yeah! Thanks!
08:26:06 <vy> notdan: May I ask how did you find it?
08:26:10 <merijn> orion: Consider, for example "singleton :: a -> Set a" <- no Ord constraint
08:26:19 <notdan> vy: searched for "url:blogspot" on r/haskell
08:27:28 <notdan> god dammit, El Capitan broke my cabal installation, darcs installation and god knows what else
08:28:34 <orion> merijn: I see.
08:29:07 <merijn> orion: You never know for what silly reason you might want to use it without an Ord constraint afterall and if it's possible, who cares? :)
08:29:37 <akfp> quicksilver: 64-bit long in GCC, compiled for i386 will use those features.  I think IBM was working quite a lot on 128-bit integer support.  Wouldn't be surprised if gcc supports that using 64-bit registers.
08:30:13 <quicksilver> akfp: sure, but that's because GCC contains assembly code to implemented it
08:30:28 <quicksilver> akfp: it's not possible in pure C to implement int64 from int32 efficiently.
08:30:43 <quicksilver> akfp: which is really disappointing for a langauge which claims to be low-level.
08:31:08 <akfp> quicksilver: It's not possible on a lot of CPU architectures either, for example using SSE alone, you can't.
08:31:21 <quicksilver> akfp: well it depends what you mean by 'efficient', of course.
08:31:42 <quicksilver> akfp: but any assembly language will let you add the low words and check the carry bits and add the high words.
08:31:53 <quicksilver> akfp: ..and even that can't be done in C or Cmm or Haskell.
08:32:26 <akfp> quicksilver: You can't do that in SSE afaik.
08:32:49 <merijn> quicksilver: Sure it can be done in Haskell
08:33:04 <tdammers> The answer is Yes, Haskell can do that!
08:33:30 <merijn> quicksilver: You can link handwritten Cmm primops into Haskell code just fine, or write C + inline asm and link that into haskell
08:33:33 <quicksilver> akfp: you don't need SSE. You can just do this with the basic ADD instruction in Z80, 68000, x86, sparc, powerpc....
08:33:47 <quicksilver> merijn: using inline asm defeats the point of my remark.
08:34:13 <quicksilver> merijn: the point of my remark is that so-called "low level" languages don't actual expose arithmetic unit flags, which are required to build high performance arithmetic.
08:34:26 <quicksilver> merijn: naturally you can just write assembly.
08:42:04 <ARM9> the standard would become more complicated since not every architecture has flags xyz
08:42:26 <quicksilver> sure
08:42:38 <quicksilver> it would actually be fiddly get get right
08:42:51 <ARM9> besides, the compiler should be able to figure out how to add integers bigger than the native register sizes efficiently
08:42:53 <quicksilver> but these claims of 'portable assembly language' and 'close to the metal' are just false, eithout it
08:43:14 <quicksilver> ARM9: yup, but this is only one example of the things you can do efficiently with access to the flags.
08:43:28 <mauke\documents> there's no nice way to map accessors to random bits/bytes either
08:43:37 <quicksilver> also if there *was* a standard for it, processors would have been more likely to support consistent features
08:43:37 <ARM9> add two 64 bit integers and compile for a 32 bit architecture, I'd be surprised if you get more than a couple instructions (depending on arch)
08:43:45 <quicksilver> which might or might not be a good thing.
08:44:03 <mauke\documents> ARM9: how do I get 128 bit integers then?
08:44:21 <ARM9> https://gcc.gnu.org/onlinedocs/gcc/_005f_005fint128.html
08:44:32 <ARM9> google 128 bit integers gcc
08:44:59 <mauke\documents> "supported for targets which have an integer mode wide enough to hold 128 bits"
08:45:01 <mauke\documents> bzzt
08:45:11 <mauke\documents> also, that's gcc, not C
08:45:42 <ARM9> go join the other standards thumpers in ##c
08:45:55 <ARM9> nobody cares about your toy compiler you wrote in 1992
08:46:50 <mauke\documents> you seem to be missing the point
08:47:35 <quicksilver> ARM9: the tone of this conversation seems to have suddenly taken a turn for the worse?
08:49:33 <ARM9> it was a joke, settle down
08:49:49 <ARM9> mauke\documents and the point was?
08:50:26 <mauke\documents> <insult re: your intellectual capacity>
08:50:53 <mauke\documents> <claim of it being a joke>
08:51:04 <ARM9> apt ad hominem, sorry if I hurt your feelings pal
08:51:46 <akfp> quicksilver: I think you're misunderstanding the "portable assembly language" thing.  In C, things generally translate transparently into assembly.  The reverse is not true, because it represents something of a common denominator for what CPUs looked like 40 years ago.
08:51:59 <mauke\documents> >implying a CPU is a human being
08:52:05 <merijn> akfp: Sorry, but that's blatantly false and has been for years
08:52:21 <akfp> merijn: how?
08:52:27 <quicksilver> akfp: I think it's overstated that "C things translate directly into assembly" but there is a kernel of truth. I think it isn't *even* a common denominator from 40 years ago.
08:52:39 <quicksilver> akfp: even 40 years ago all CPUs had carry bits
08:52:51 <quicksilver> I would be surprised if any CPU that the original C compilers targetted failed to have a carry bit.
08:52:52 <merijn> akfp: Anyone who still think 1) that translating C to assembly is transparent/straightforward and 2) thinks that even assembler is predictable enough to reason about has not kept up with modern CPU/compiler developments
08:53:53 <Welkin> quicksilver: at least that is true on micro controllers
08:53:57 <merijn> akfp: My goto example of this is usually this SO post, ESPECIALLY the insantiy performed by ICC discussed in the comments at the end: https://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-an-unsorted-array
08:53:59 <Welkin> the ones I worked with anyway
08:54:32 <akfp> merijn: whether assembly is predictable is irrelevant. true that C compilers actually optimize and implement magic, but you can usually get them to do more of a direct mapping as well.  the optimizations are done for performance, not because C is hard to map.
08:54:32 <Welkin> with RISC
08:54:45 <merijn> akfp: I've looked at the asm generated by icc/suncc a few times and those compilers do insane things with completely unpredictable behaviour
08:54:51 <frerich> merijn: Insanity? I think it's plain glorious!
08:55:18 <merijn> frerich: Glorious? Not really. Awe inspiring, I'd agree
08:57:23 <dolio> That's why so many GPU languages are based heavily on C, right? Because C maps in such a straight forward way to GPU operation.
08:57:46 <akfp> dolio: it does
08:58:38 <sinelaw> huh
09:03:50 <cizra> Hi! I got lost in the doc and con't find my way. I need to convert an Unix epoch time into a UTC or local time string. The only way I could find would be the strptime package, which sounds like overkill. Is there no analogue of gmtime() in Haskell?
09:05:20 <dolio> quicksilver: -1 :: Word is easy to fix, but we will never be allowed to do so.
09:05:32 <glguy> cizra: Look in Data.Time.Clock.POSIX
09:05:40 <quicksilver> dolio: ?
09:05:56 <dolio> Put negate in a separate class that Word doesn't implement.
09:06:01 <mauke\documents> cizra: posixSecondsToUTCTime, formatTime ?
09:06:26 <quicksilver> dolio: yes but I want to fix underflow, not just negation
09:06:36 <quicksilver> dolio: (1-2) :: Word is just as bad
09:06:38 <dolio> That one's harder.
09:07:14 <lamefun> Are there functions to deal with integer overflow?
09:07:27 <quicksilver> in fact I don't really want to fix these; I don't think they are big problems for me. I was using it explain why it "doesn't matter" than the type used in take/drop is Int
09:07:34 <quicksilver> (just because Word is no better)
09:08:01 <dolio> Depends what you consider better, I guess.
09:08:08 <quicksilver> possibly Word is worse
09:08:12 <quicksilver> > take -1 [1..]
09:08:14 <lambdabot>      Could not deduce (Enum t0)
09:08:14 <lambdabot>      from the context (Enum t,
09:08:14 <lambdabot>                        Num t,
09:08:21 <quicksilver> > take (-1) [1..]
09:08:23 <lambdabot>  []
09:08:29 <quicksilver> > genericTake (-1 :: Word) [1..]
09:08:31 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:08:41 <cizra> glguy, mauke\documents Thanks!
09:09:32 <merijn> dolio: As I just mentioned, I wrote a TH library to try and prevent stuff like "-1 :: Word" for my own newtype wrappers
09:09:48 <merijn> (Although I think GHC already warns for overflowing literals, atm)
09:12:49 <quicksilver> ghc -Wall -e 'print (-1::Word)' # no warnings on my machine
09:13:02 <quicksilver> but literals still aren't really the point.
09:13:41 <glguy> $ ghc -Wall -XNegativeLiterals -e 'print (-1::Word)'
09:13:50 <glguy> Otherwise you aren't using a negative literal, you're negating 1
09:14:01 <quicksilver> oh
09:14:16 <glguy>     Literal -1 is out of the Word range 0..18446744073709551615
09:14:20 <quicksilver> agreed.
09:14:32 <quicksilver> I'd entirely forgotten the whole thing about - and negate and "literals"
09:15:41 <glguy> Certainly seems excusable :)
09:17:56 <dolio> Man, NegativeLiterals is pretty tricky.
09:19:47 * hackagebot language-fortran 0.4 - Fortran lexer and parser, language support, and extensions.  https://hackage.haskell.org/package/language-fortran-0.4 (DominicOrchard)
09:43:27 <ttt_fff> Question: What is a set of minimal primitives for Behaviour/Event/Dynamic? For example, we probaly want "holdDyn :: a -> Event t a -> Dynamic t a" ; we probably also want "combineBehaviour :: (a -> b -> c) -> Behaviour t a -> Behaviour t b -> Behaviour t c" ... however, what else do we want?
09:43:51 <ttt_fff> I.e. I'm looking for a minimal set of "ops on Behaviours/Event/Dynamics" such that all other "Behaviour/Event/Dynamics" transforms can be expressed in terms of our minimal set
09:45:09 <tommd> I have an idea, let's form a committee... let's call it Haskell Prime... and that committee can standardize extentions like NegativeLiterals, BinaryLiterals, FlexibleContexts, FlexibleInstances...
09:45:15 <tommd> More seriously, is there a prime ML these days?
09:45:21 <quicksilver> I don't know, ttt_fff, but I think it's not obvious
09:45:28 <quicksilver> tommd: have you read conal's paper on it?
09:45:32 <quicksilver> oops
09:45:36 <quicksilver> that was for ttt_fff too
09:45:54 <tommd> Ah, I was going to say - a paper from Conal on committees?  Must be negative.
09:46:50 <ttt_fff> quicksilver: I just realized I'm asking in #hskell and not #reflex-dom
09:46:52 <ttt_fff> wrong channel, sorry
09:49:48 * hackagebot semver-range 0.1.0 - An implementation of semver and semantic version ranges.  https://hackage.haskell.org/package/semver-range-0.1.0 (thinkpad20)
09:54:49 * hackagebot deepcontrol 0.5.2.0 - Provide more deeper level style of programming than the usual Control.xxx modules express  https://hackage.haskell.org/package/deepcontrol-0.5.2.0 (KONISHI_Yohsuke)
09:56:31 <hexagoxel> is there no `(Exception e, MonadIO m) => IO a -> (e -> m a) -> m a` ?
09:57:27 <monochrom> no. liftIO is not enough to generalize catching and throwing like this. look for monad-control etc
09:58:17 <johnw> you end up needing both lifting IO -> m and unlifted m -> IO, which requires some kind of knowledge of 'm'. This is what MonadBaseControl provides, just enough to allow a roundtrip.
09:58:18 <hexagoxel> (ah, there is MonadError's catchError)
09:58:30 <johnw> hexagoxel: I'd suggest MonadCatch from http://hackage.haskell.org/package/exceptions
10:00:16 <hexagoxel> monochrom, johnw: but the type above _can_ be implemented, i am pretty sure.
10:01:10 <quicksilver> the type above can, yes, because the exception throwing code is just IO and only the handler uses 'm'
10:01:55 <monochrom> I misread the type
10:02:05 <quicksilver> you can upgrade your exception handler to e -> IO (m a)
10:02:09 <quicksilver> run it with the normal catch
10:02:17 <quicksilver> and then 'run' the handler when yu're back in m a
10:08:02 <hexagoxel> monochrom, johnw, quicksilver: thanks for the input. MonadCatch seems to be a proper solution.
10:14:00 <breadmonster> What is an enumerator?
10:22:34 <aweinstock> breadmonster: I think Enumerators were a predecessor of pipes/conduits (a solution to the problems of lazy IO)
10:25:26 <levi> breadmonster: What's the context of your question about what an enumerator is? I.e. did you find the term on a specific page or paper or something?
10:26:12 <breadmonster> levi: I was just going through hackage.
10:26:40 <levi> There's a general concept of what an enumerator is, but as aweinstock said it was also part of the 'enumerator/iteratee/enumeratee' streaming system.
10:28:07 <johnw> breadmonster: in general terms, an enumerator is a way of indexing a structure at specific points, that knows how to "move forward" within that structure until the end.  The "structure" in question may be in memory, or it may be procedural
10:28:10 <levi> There were a few implementations of the enumerator/iteratee concept on hackage, so that's probably what you saw.
10:32:21 <levi> They're essentially composable coroutines for processing of streaming data in discrete chunks, if that makes sense.
10:35:20 * hackagebot scotty-tls 0.4.1 - TLS for Scotty  https://hackage.haskell.org/package/scotty-tls-0.4.1 (DavidJohnson)
10:41:48 <ackthet> this is a long shot, but is there any way to have vim style editing in GHCi?
10:42:00 <johnw> ackthet: use rlwrap
10:44:09 <dolio> You can configure haskeline in vim mode, but it pales in comparison to vim, of course (similar to readline).
10:44:17 <dolio> Vi mode, I suppose.
10:45:13 <merijn> ackthet: tbh I just use tmux to have vim and/ghci split screen and reload the file I work on
10:46:11 <ackthet> merijn: sure, thats what i do 99% of the time but 1% of the time i like to play around in ghci
10:46:16 <ackthet> it would be nice
10:46:44 <johnw> rlwrap turns any REPL into one with readline support
10:46:57 <ackthet> what is haskeline?
10:47:04 <ackthet> some places on the internet say it can do it as well
10:47:11 <dolio> But you don't need to use readline, because haskeline can be put in vi mode just like readline can.
10:47:32 <johnw> ah, ghci uses haskeline?  didn't know that
10:47:36 <ackthet> editMode: Vi?
10:47:47 <dolio> Yes. In ~/.haskeline
10:48:34 <dolio> It used to use readline but at some point it switched. Possibly due to annoyances with multi-platform support.
10:49:10 <ackthet> oh goooood this is amazing
10:49:14 <johnw> dolio: and maybe GPL?
10:49:14 <ackthet> dolio++
10:49:23 <dolio> Possibly.
10:49:53 <dolio> Actually, now I'm not sure if it used readline or some other readline-alike.
10:50:04 <dolio> But in either case, haskeline was more convenient, I think.
10:50:17 <ackthet> prob just like to use other haskell projects
10:50:28 <ackthet> anyway this is awesome
11:05:35 <rrrmr> is there a way to see how many bytes an Integer is using?
11:07:28 <Nilabhra> wohoo
11:07:38 <Nilabhra> just started off with haskell
11:07:49 <aweinstock> rrrmr: http://hackage.haskell.org/package/integer-gmp-1.0.0.0/docs/GHC-Integer-GMP-Internals.html
11:07:58 <Nilabhra> sorry guys, too excited here
11:08:05 <obadz> Nilabhra: lol
11:08:16 <pqmodn> rrrmr, i'm not sure if there is a nicer way, but you can work it out from the constructors: https://hackage.haskell.org/package/integer-gmp-1.0.0.0/docs/GHC-Integer-GMP-Internals.html -- S# is an unboxed int for small-enough values (8 bytes) while Jp# and Jn# are for larger values (positive and negative) with a pointer to a ByteArray# representing them in binary
11:08:57 <rrrmr> thanks
11:09:36 <Nilabhra> hi obadz , started off with lear you a haskell. Is there any other book that might help me write production level code. I want to implement machine learning libraries in haskell. :P
11:09:57 <Nilabhra> and I love the fact that it's lazy
11:10:20 <nek0> Nilabhra: Real world Haskell might be a start, but its a little outdated by now.
11:11:01 <Nilabhra> nek0: hey thanks, how much oudated is the book?
11:11:23 <aweinstock> rrrmr: intSizeInBytes wordSize = \case { S# _ -> wordSize; Jp# (BN# arr) -> f arr; Jn# (BN# arr) -> f arr} where f arr = wordSize * (I# (sizeofByteArray# arr))
11:11:33 <Nilabhra> nek0: okay so what is a good book to learn modern haskell stuff?
11:11:47 <pqmodn> Nilabhra: it's several years old, but it's also freely available in HTML format (with comments from readers, some correcting outdated code)
11:12:23 <Nilabhra> pqmodn: cool thanks, will start off with that after I finish the current book :)
11:12:35 <nek0> Nilabhra: I agree to pqmodn. It's definitely worth reading.
11:12:43 <aweinstock> > log (fromIntegral (maxBound::Word)) / log 2
11:12:44 <lambdabot>  64.0
11:12:58 <aweinstock> rrrmr: ^ wordSize
11:12:58 <ski> Nilabhra : are you familiar with any other functional programming language already ?
11:13:14 <pqmodn> :t finiteBitSize
11:13:15 <lambdabot> FiniteBits b => b -> Int
11:13:24 <pqmodn> > finiteBitSize (0 :: Word32)
11:13:25 <lambdabot>  32
11:13:37 <aweinstock> > finiteBitSize (undefined :: Word)
11:13:39 <lambdabot>  64
11:13:46 <Nilabhra> ski: nope, I know C,C++, Java, Python ,..etc 
11:13:56 <Nilabhra> no proper functional language
11:14:30 <Nilabhra> I know some R, I guess that's functional not sure
11:14:31 <aweinstock> rrrmr: also sizeofByteArray# is from GHC.Prim (as is I#), and you need {-# LANGUAGE MagicHash #-} to use all the functions with #s in the names
11:14:56 <suppi> Nilabhra, I heard some good feedbacks on www.haskellbook.com but have not read it myself
11:15:03 <kadoban> Nilabhra: https://github.com/bitemyapp/learnhaskell is good advice to actually get you coding. Though RWH is not bad, it never really clicked for me.
11:15:46 <ski> Nilabhra : perhaps it's already been said, but i figured i'd mention that some extent, learning a different programming paradigm, like the functional one, will be like learning to program all over again. so be prepared to approach things with a fresh mind, unlearning if necessary
11:15:46 <Nilabhra> what about learn you a haskell? Should I chuck reading it and continue to RWH?
11:16:06 <Nilabhra> ski am all game for it
11:16:16 <donaldball> I am learning Haskell now and have a question on types and type classes. I’m writing a minesweeper impl: https://gist.github.com/dball/63770f892bdba461ddfb I started with tuples of Enums for my points (Enum a => (a, a)) in the fn types, but it was very verbose. I switched to a point type, which is fine, but now I’m overconstraining the fns; neighbors and friends should be able to work on tuples of Enums, not just Ints. Is it possib
11:16:16 <donaldball> to… use a typedef in a type somehow? E.g. type Point = Enum a => (a, a)
11:16:17 <suppi> I didn't like the little I read of RWH
11:16:40 <suppi> and reading LYAH didn't get me to write code in haskell much :(
11:16:55 <suppi> it did teach me the syntax, ideas and functional thinking though
11:17:16 <Nilabhra> suppi: then what did get you to code?
11:17:38 <Nilabhra> and okay I will stick to LYAH for the basics I suppose.
11:17:53 <suppi> Nilabhra, coding, and reading many blog posts and guides
11:17:59 <Jinxit> I learned by hanging out in #haskell and googling a lot, but I was already familiar with functional thinking
11:18:10 <suppi> Nilabhra, there is also the haskell wikibook https://en.wikibooks.org/wiki/Haskell
11:18:20 <nek0> Nilabhra: Learn You a Haskell is a great start. This gets you to the basics in no time.
11:18:44 <suppi> nek0, took me a few months to read it, wouldn't call that no time :)
11:18:50 <aweinstock> donaldball: type Point a = (a, a) -- will this work for your purposes?
11:19:01 <Nilabhra> Jinxit: how do I learn functional thinking? What functional programming language did you know before learning Haskell?
11:19:16 <nek0> suppi: Depends on how fast you read.
11:19:27 <donaldball> I don’t think so… I need the Enum typeclass in order for pred and succ to type check, right?
11:19:30 <Nilabhra> suppi: nek0 : thanks guys :)
11:19:40 <tzh> donaldball: you'd want to constrain your actual functions like `:: Enum a => Point a`
11:20:06 <suppi> Nilabhra, I wrote a blog post sharing a few resources to use after LYAH if you're interested: http://www.gilmi.xyz/post/2015/02/25/after-lyah
11:20:08 <ski> donaldball : `type Point a = (a,a)',`type PointFn a = (a -> a,a -> a)',`neighborFns :: Enum a => [PointFn a]',`applyNeighborFn :: Point a -> PointFn a -> Point a',`neighbors :: Enum a => Point a -> [Point a]'
11:20:36 <Jinxit> Nilabhra: different sources, like being encouraged to use 'pure' functions in C++, then I had a short attempt at haskell, used a lot of map/reduce in python, and then finally erlang (which is actually functional)
11:21:08 <humanoyd> Why isn't String or ByteString an instance of Arbitrary in QuickCheck?
11:21:10 <donaldball> Ahhh, thanks @ski
11:21:50 <ski> donaldball : note that it's not IRC custom to address people by prefixing their nicknames with `@'s
11:21:52 <obadz> what's a reasonable way to go from String -> [Word8] ?
11:22:49 <aweinstock> obadz: map fromIntegral ?
11:23:05 <aweinstock> (that'll truncate unicode things though)
11:23:20 <donaldball> What’s the proper name for this: `type Point a = (a,a)`, a parameterized type?
11:23:33 <ski> donaldball : yes. also "type function"
11:23:57 <obadz> aweinstock: so maybe this https://hackage.haskell.org/package/utf8-string-1.0.1.1/docs/Codec-Binary-UTF8-String.html#v:encode ?
11:24:13 <aweinstock> obadz: that's probably a better option
11:25:02 <aweinstock> donaldball: applyNeighborFn = flip (uncurry bimap)
11:25:06 <aweinstock> :t flip (uncurry bimap) `asTypeOf` (\(x,y) (fx, fy) -> (fx x, fy y))
11:25:07 <lambdabot> (a, c) -> (a -> b, c -> d) -> (b, d)
11:25:22 * hackagebot keera-posture 0.2.1 - Get notifications when your sitting posture is inappropriate.  https://hackage.haskell.org/package/keera-posture-0.2.1 (IvanPerez)
11:26:06 <donaldball> aweinstock: Thanks, that was to be my followup question
11:27:31 <aweinstock> donaldball: if there's any shorter way to write applyNeighborFn?
11:27:56 <donaldball> shorter or more idiomatic way to express applying a tuple of fns to a tuple of values
11:30:07 <aweinstock> I'm not sure if it's a good idea to replace a simple function on tuples with a dependency on a fancy catagory theoretic kmett package while you're still learning, but I like point-free-ifying things
11:31:43 <lispy> Point free is great when you feel that code maintenance has become boring
11:33:07 <dolio> Bifunctor is is base now.
11:33:19 <dolio> Is in, even.
11:35:27 <aweinstock> :t liftA2 (,) <*> id
11:35:29 <lambdabot> Applicative f => f a -> f (a, a)
11:35:53 <aweinstock> ^ cartesian square of a list
11:36:19 <aweinstock> > (liftA2 (,) <*> id) [1..3]
11:36:20 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
11:37:51 <ski> @type join (liftA2 (,))
11:37:52 <lambdabot> Applicative f => f a -> f (a, a)
11:40:04 <monochrom> lispy: yesterday I watched The Martian and I saw lisp code, or at least s-expressions
11:40:29 <lispy> monochrom: I still haven't seen that yet, so spoiler warnings :)
11:40:35 <aweinstock> :t join `asTypeOf` (<*> id)
11:40:37 <lambdabot> (a1 -> a1 -> a) -> a1 -> a
11:40:43 <monochrom> ok, but that's all I wanted to say anyway
11:40:51 <aweinstock> ski: thanks :)
11:42:21 <dolio> It also has hex editing, if you're into that.
11:43:00 <monochrom> there was also a real ASCII table
11:43:37 <monochrom> complete with the control character names such as NUL and SOH
11:44:35 <monochrom> s-expressions showing up in movies is a good sign. perhaps in 20 years Haskell will also appear in movies.
11:45:13 <monochrom> previously (e.g. Ex Machina) it has been python. yuk.
11:45:23 * hackagebot argon 0.3.1.0 - Measure your code's complexity  https://hackage.haskell.org/package/argon-0.3.1.0 (rubik)
11:46:39 <dolio> At least we're getting beyond C.
11:49:59 <rrrmr> aweinstock: i can't seem to find the BN# data constructor in GHC.Integer.GMP.Internals, also I only have a J# constructor no Jn# or Jp#. is it because i'm on ghc 7.8.4?
11:50:27 <dolio> rrrmr: Yes.
11:55:01 <aweinstock> rrrmr: this looks like the right one for your version: http://hackage.haskell.org/package/integer-gmp-0.5.1.0/docs/GHC-Integer-GMP-Internals.html
11:55:25 * hackagebot tttool 1.5 - Working with files for the Tiptoi pen  https://hackage.haskell.org/package/tttool-1.5 (JoachimBreitner)
11:56:11 <sleblanc> I'm looking for a function [(a,a)] -> [a] that includes both sides of the tuple
11:56:52 <dolio> @type toListOf (traverse.both)
11:56:53 <lambdabot> (Traversable t, Data.Bitraversable.Bitraversable r) => t (r a a) -> [a]
11:57:16 <rrrmr> thanks
11:57:20 <aweinstock> rrrmr: also, it looks like sizeInBaseInteger might do what you want (and hence there's no need for internal hackery)
11:58:07 <aweinstock> (specifically, \x -> sizeInBase x 2#)
11:59:51 <donaldball> I’m adding boundary constraints to neighbors now: https://gist.github.com/dball/63770f892bdba461ddfb I see why I have to add the Ord type class, but it’s not clear why I also have to add Num?
12:00:26 <dolio> donaldball: You're comparing with 0.
12:00:46 <donaldball> dolio: Thanks
12:01:00 <aweinstock> :t toEnum 0
12:01:02 <lambdabot> Enum a => a
12:01:16 <jophish> Does the instance: Monoid a => Monoid (MyMonad a) where mempty = pure mempty; mappend a b = a >> b;
12:01:46 <jophish> I understand there are other possible monoid instances for other monads, is this the reason why this isn't standard?
12:02:13 <aweinstock> jophish: it looks law-abiding, at least
12:02:30 <dolio> That's not a monoid.
12:02:34 <rrrmr> aweinstock: i get back a boxed type, how can i print it?
12:02:43 <dzhus`> Can I feed one conduit Source to multiple Sinks for being processed
12:02:46 <dzhus`> concurrently? Or shall I just switch away from conduit to async+stm
12:02:49 <dzhus`> queues/channels?
12:03:23 <Ferdirand> a >> pure mempty is not a
12:03:32 <jophish> ah, of course
12:03:47 <donaldball> Would it be idiomatic haskell to have multiple type class constraints (Enum a => Ord a => Num a => a) or to use the obvious (Integral a => a)
12:04:24 <dolio> Well, Integral is more than you need, presumably. But it's up to you.
12:04:52 <kadoban> donaldball: It should be (Enum a, Ord a, Num a) => a, by the way.
12:05:01 <aweinstock> rrrmr: (\x -> W# (sizeInBase x 2#)) :: Integer -> Word -- should work
12:05:03 <monochrom> I was just reading an old post written when "Enum a => Ord a => Num a => a" was valid syntax :)
12:05:17 <dolio> It's still valid syntax in GHC, at least.
12:05:24 <monochrom> oh heh, nice
12:05:26 <donaldball> I’m just wildly guessing at syntax still :)
12:05:26 <aweinstock> Word is a normal boxed type, and should have Show/Num/etc instances
12:05:29 <kadoban> Is it really? That's funny.
12:05:38 <jophish> this on the other hand: a >>= \ x -> b >>= \ y -> pure (mappend x y)
12:06:09 <dolio> jophish: Yeah, that's a monoid.
12:06:40 <jophish> I was a little surprised this wasn't in base
12:06:55 <aweinstock> donaldball: you don't need Num yet, you can use (toEnum 0)
12:07:10 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/110371/ :)
12:07:18 <prakhar> >
12:07:21 <jophish> foldMap (something returning MyMonad Monoid) Nothing
12:07:48 <jophish> > foldMap (pure ()) Nothing
12:07:49 <lambdabot>  ()
12:08:53 <jophish> > foldMap putStrLn (Just "hello")
12:08:54 <lambdabot>      No instance for (Monoid (IO ())) arising from a use of ‘foldMap’
12:08:54 <lambdabot>      In the expression: foldMap putStrLn (Just "hello")
12:08:57 <jophish> something like that
12:09:22 <donaldball> I don’t need Num because I’m not doing arithmetic or the like
12:09:37 <donaldball> Why do I have to cast 0 to an Enum explicitly though?
12:10:21 <donaldball> Is it because I’m allowing haskell to infer the type of the inBounds local fn?
12:10:56 <jophish> I imagine it's not in base because it leads to a whole bunch of overlapping instances for other monoid
12:11:06 <dolio> Because 0 is much more useful being overloaded as a number than as an enumerable thing.
12:11:21 <jophish> I wonder if thre's a newtype wrapper...
12:11:32 <dolio> 'toEnum 0' is using 0 :: Int.
12:11:46 <patcon> hey all! total new-person question, that's hopefully an easy one: Why does one of these not work? https://gist.github.com/patcon/c7f2d280fb77a41e6c69
12:12:08 <aweinstock> dolio: I thought 0 = (fromIntegral 0 :: Num a => a) ?
12:12:20 <dolio> Yes.
12:12:33 <patcon> Ah. oops. think I got my answer... :)
12:12:41 <patcon> this seems to work: `(read "\"test\"" :: String) ++ "test"`
12:12:44 <dolio> Well, actually, 0 is fromInteger 0.
12:12:54 <ChristianS> patcon: you don't need read for Strings
12:12:58 <kadoban> patcon: Right. Also 'read' is kinda funky, don't use it much.
12:13:11 <monochrom> patcon: yes, those are the expected format of String's read.
12:13:19 <patcon> ChristianS: heh, it was more just a "why?" as I'm playing around :)
12:13:28 <donaldball> 0 is a Num, and Num is… not a kind of Enum, got it
12:13:36 <monochrom> the same format as String's show.
12:13:40 <dolio> Num and Enum are classes.
12:14:16 <donaldball> If 0 were an Integral, then I wouldn’t need to convert to Enum
12:14:17 <dolio> But not the same class, nor is one prior to the other.
12:14:31 <donaldball> Why is 0 not an Integral?
12:14:32 <dolio> Because there are enumerable things that aren't numbers, and numbers that aren't enumerable.
12:14:38 <donaldball> Sure
12:14:49 <monochrom> read and show's formats are usually chosen to look like code rather than look like user-end input output
12:14:50 <dolio> Because there are types that have 0 but are not integral.
12:14:53 <patcon> monochrom: ah, that's sensible. thanks! :)
12:15:25 <donaldball> A concession to the fact that 0 belongs to many sets well-defined in haskell: RealFloat, Integral, etc.
12:15:36 <monochrom> it is only a coincidence that code syntax for the number 12 is also user syntax for the number 12
12:16:10 <monochrom> but this doesn't extrapolate to strings and lists
12:23:44 <jle`> patcon: btw, [1,2,3] normally represents lists, not arrays
12:30:27 * hackagebot aeson-filthy 0.1 - Several newtypes and combinators for dealing with less-than-cleanly JSON input.  https://hackage.haskell.org/package/aeson-filthy-0.1 (AlecHeller)
12:33:10 <quchen> glguy: ping?
12:34:22 <orion> Is there a concise way to export only type families and functions of a typeclass? I don't want to expose the constructors for the types contained within the class.
12:41:39 <orion> typeclass instance
12:44:25 <juanpablo_> I just had to define zip8. I feel like I'm doing something horribly wrong. Basically I have eight lists I need to "sync" by index in order to create a new record for each
12:45:04 <juanpablo_> Definiing zip8 and higher is obviously not a great idea. What'd be a better solution here?
12:45:40 <Cale> juanpablo_: break your records into smaller parts?
12:45:45 <mauke> are they all the same type?
12:46:10 <juanpablo_> mauke: yes. 
12:46:11 <Cale> Yeah, if they're all the same type, then transpose ought to work
12:47:00 <Cale> > transpose [[11,12,13,14,15],[21,22,23,24,25],[31,32,33,34,35]]
12:47:01 <lambdabot>  [[11,21,31],[12,22,32],[13,23,33],[14,24,34],[15,25,35]]
12:47:02 <juanpablo_> I mean it's a bunch of  Maybe's with a single bare Integer in there. I guess I could work around it by making it also a Maybe
12:47:11 <Cale> uhh
12:47:21 <Cale> Wait, what?
12:47:34 <monochrom> this looks like a design gone wrong :)
12:47:47 <juanpablo_> 7 lists of "Maybe Integer" and 1 list of "Integer"
12:48:11 <juanpablo_> It's because I'm tied to Snap's request parser. The long term solution is moving to a custom parser I guess
12:48:27 <juanpablo_> I'm just avoiding writing the parser lol
12:48:34 <mniip> [22:44:41] <juanpablo_> Definiing zip8 and higher is obviously not a great idea. What'd be a better solution here?
12:48:42 <mniip> use <*> and <$> on ZipList?
12:49:09 <Cale> Yeah, or just defining special purpose Applicative-like combinators can sometimes be an approach
12:49:34 <mniip> :t \a b c d -> getZipList $ (,,,) <$> ZipList a <*> ZipList b <*> ZipList c <*> ZipList d
12:49:35 <mauke> Adhocative
12:49:35 <lambdabot> [a3] -> [a2] -> [a1] -> [a] -> [(a3, a2, a1, a)]
12:49:43 <juanpablo_> mniip: that's interesting! I have heard of ZipLists before but have never read about them in depth. Time to do some reading
12:49:49 <mniip> replace (,,,) with your constructor of hoice
12:49:54 <Cale> yeah, Adhocative :)
12:50:46 <Cale> Like, using some different operators is probably prettier than having to apply ZipList everywhere like that, if you have to do it more than once.
12:51:36 <juanpablo_> But I think the longer term solution is parsing the POST request I'm getting with a custom parser, instead of relying on Snap's request parser. Thay way I can get more control on the input and they'd no longer be lists
12:53:29 <Cale> juanpablo_: Doesn't Snap give you a Map?
12:54:07 <juanpablo_> Cale: it does, but I have around 90 parameters in the requet. Each key in the map maps to a list
12:54:20 <Cale> crazy :)
12:54:40 <juanpablo_> 120 actually lol custom parser is definitely the way to go
12:54:52 <juanpablo_> to the lengths I go to avoid writing JavaScript lol
12:55:51 <Cale> I'm doing web development right now, and if I had to actually write a significant amount of JavaScript, I would quit my job
12:55:57 <Cale> We're using reflex-dom :)
12:57:25 <Darwin226> Hey. When testing with quickcheck it's very convenient to be able to write functions like \(Positive n) (Negative m) -> ... and have it work. Is there an easy way to extend with but have the abiliy to supply some static info?
12:57:40 <Darwin226> Something like \(Range 1 5 m) -> ...
12:57:48 <Darwin226> (obviously doesn't make sense)
12:58:32 <lyxia> Darwin226: I think you need to use custom generators for that.
12:59:09 <Darwin226> lyxia: Well, there's already the choose generator that does exactly this, but how do I use it in functions?
12:59:16 <lyxia> forAll (randomR (1,5)) (\m -> ...)
12:59:41 <Darwin226> lyxia: Awesome. This is exactly it
12:59:48 <Darwin226> lyxia: Thanks!
13:00:32 <lyxia> hmm it's not called randomR...
13:01:12 <lyxia> choose
13:02:07 <lyxia> you said it actually haha
13:11:09 <schell> is there an easy way to pretty print types that have show instances?
13:14:18 <glguy> https://hackage.haskell.org/package/pretty-show
13:15:35 * hackagebot hsimport 0.6.6 - A command line program for extending the import list of a Haskell source file.  https://hackage.haskell.org/package/hsimport-0.6.6 (DanielTrstenjak)
13:16:09 <zomg> Cale: funny you'd say that about JS, at work that's all we use :P I would infact say that exact same thing about Java...
13:16:40 <Cale> zomg: My compiler writes the Javascript for me :)
13:17:13 <bitemyapp> zomg: things don't change until we withdraw labor from employers that treat us like menial labor instead of professionals.
13:17:30 <Cale> zomg: Well, "my" doesn't mean much there -- it's just GHCJS :)
13:17:37 <zomg> yeah
13:24:41 <donaldball> Now I’m defining a Board data type: https://gist.github.com/dball/63770f892bdba461ddfb I’d like to keep the boardMin and boardMax types as (Enum a, Ord a) => Point a if I can, but the compiler tells at me when I replace Point Int with that
13:25:48 <aweinstock> donaldball: data Board a = ...?
13:25:56 <donaldball> ah
13:26:07 <donaldball> We would call that a…. parameterized data type?
13:26:21 <aweinstock> type parameter? something like that
13:26:51 <aweinstock> (Board a) is polymorphic in the type of points it contains
13:28:32 <aweinstock> :t \c -> (&&) `on` (>= c)
13:28:33 <lambdabot> Ord a => a -> a -> a -> Bool
13:29:11 <aweinstock> donaldball: inBounds = uncurry ((&&) `on` (>= toEnum 0))
13:29:26 <donaldball> whut
13:30:33 <aweinstock> @src on
13:30:33 <lambdabot> (*) `on` f = \x y -> f x * f y
13:30:37 * hackagebot cabal-lenses 0.4.7 - Lenses and traversals for the Cabal library.  https://hackage.haskell.org/package/cabal-lenses-0.4.7 (DanielTrstenjak)
13:30:57 <aweinstock> (or is there a different part of it that I need to explain?)
13:31:52 <aweinstock> (>= (toEnum 0)) = (\x -> x >= (toEnum 0))
13:32:53 <ski> aweinstock : it is not polymorphic
13:33:18 <aweinstock> ski: how so?
13:33:43 <aweinstock> (forall a. Board a), that is
13:33:54 <donaldball> huh, just got my first run-time error
13:34:22 <donaldball> https://gist.github.com/dball/63770f892bdba461ddfb
13:34:34 <ski> aweinstock : the kind of `Board' would be `* -> *', which is clearly specific, not general. there's no `forall' in there. `Board' would be a monomorphic type (function)
13:34:35 <donaldball> makeBoard (2, 3) does not give the effect I wanted
13:35:07 <donaldball> Board {boardMin = ((),()), boardMax = (*** Exception: Prelude.Enum.().toEnum: bad argument
13:35:15 <donaldball> Clearly, I do not understand toEnum
13:35:21 <ski> defaulting
13:35:41 <aweinstock> {-# LANGUAGE NoMonomorphismRestriction #-}
13:35:42 <glguy> > fromEnum ()
13:35:43 <lambdabot>  0
13:36:05 <donaldball> Wow. Two hours in and I’m already hitting language pragmas.
13:36:16 <glguy> You don't actually need to use a pragma
13:36:38 <glguy> You just need to specify what type you expected makeBoard (2,3) to be
13:37:01 <donaldball> A board with points that are Enum and Ord
13:37:05 <ski> donaldball : you don't need `Ord a' there
13:37:30 <donaldball> won’t I need it when I try to use the boardMin and boardMax to compute inbounds?
13:37:35 <glguy> donaldball: Neither Enum nor Ord are types, they are type classes. YOu have to pick a type that is both an Enum and an Ord
13:37:53 <donaldball> You can’t just say (Enum a, Ord a) => a
13:38:12 <glguy> That just puts off picking the type until later
13:38:18 <donaldball> I’m lazy
13:38:21 <monochrom> I can, but it doesn't do what you think
13:38:24 <glguy> but by the time you're printing to screen you need to pick a type
13:39:12 <ski> aweinstock : `Board' would be a type function. or parameterized type, if you prefer. not polymorphic, though
13:39:33 <donaldball> Is it the Show from the repl that’s triggering the error?
13:39:50 <ski> donaldball : it's the picking of `a' as `()' that triggers the error
13:40:17 <athan> Is the definition of an isomorphism somewhat recursive? Or is the "indistinguishable" argument denotative to identity? "isomorphic objects are s.t. there are two projections `f : A -> B` and `g : B -> A` where (f . g) is... equal? indistinguishable? isomorphic to? the identity mapping on `A`"
13:40:28 <ski> because GHCi has some extended defaulting for picking types to disambiguate
13:40:49 <aweinstock> ski: what would be something that can correctly be called polymorphic? (id :: a -> a)? (and can only values be polymorphic?)
13:40:52 <monochrom> athan, f.g = id
13:41:02 <arkeet> athan: equal
13:41:40 <donaldball> So I should probably just accept that I need makeBoard to return Board Int
13:42:05 <arkeet> athan: there are other notions along the lines of isomorphism that don't require "equal", but those aren't called isomorphisms. (for example: equivalences of categories.)
13:42:15 <orion> Is there a way to mark certain functions as not having documentation, so as to silence Haddock's warning about them>
13:42:21 <athan> arkeet, monochrom: In a tangible sense? So that you can "prove" that the two object are equal (via isomorphism)? Or that they are actually the _same_ object? (that (f.g) is actually identical to (id_A))
13:42:31 <athan> arkeet: Ahh okay, thank you
13:43:35 <ski> aweinstock : `id',`Nothing' are examples of polymorphic values (note how their types are of the shape `forall a. ..a..'. the `forall' in the type signifies the value of that type is polymorphic)
13:44:16 <monochrom> donaldball: at an overarching level, teachers who teach "when you design/write your program, start with the absolutely most generalized generalization possible" are evil and wrong. no, start with the absolutely most specific specialization possible. later, you can *discover* generalization opportunities. the difference and reason is...
13:44:27 <ski> aweinstock : you can have polymorphic types as well. with extensions, if you define `newtype Flip f a b = MkFlip (f b a)', then `Flip :: forall k0 k1. (k1 -> k0 -> *) -> k0 -> k1 -> *', so `Flip' is a polymorphic type
13:44:53 <ski> (aweinstock : `forall a. Maybe a' is not a polymorphic type, though. its kind is `*', contains no `forall' at all)
13:45:00 <monochrom> the difference and reason is: if you start general, you will always happen to choose the wrong way to be general. if you start special and discover how to generalize, you can only discover right ways to generalize.
13:45:29 <dolio> monochrom: Your advice is also not always good.
13:45:29 <monochrom> i.e., you never know the right way to generalize at the beginning. you only know at the end.
13:45:37 <aweinstock> ski: Maybe has kind (* -> *), is it a polymorphic type?
13:46:00 <ski> aweinstock : no. `Maybe' is a type function. just like `not', of type `Bool -> Bool', is a value function
13:46:02 <donaldball> Huh. I thought it was actually fairly interesting, being driven to the specific type constraints by the fns I brought into play
13:47:06 <ReinH> athan: To be fair, "what is equality?" can be a difficult question to answer.
13:47:19 <ReinH> @google when is one thing equal to some other thing
13:47:22 <lambdabot> http://www.math.harvard.edu/~mazur/preprints/when_is_one.pdf
13:47:22 <lambdabot> Title: When is one thing equal to some other thing?
13:47:43 <ReinH> athan: That's a good read on the topic.
13:47:50 <monochrom> athan: at issue is equality of arrows. if you know what kinds of arrows you have, you can answer that. e.g., for Set and functions, use function's extensional equality
13:47:52 <ski> aweinstock : type functions (aka parametric types) naturally gives rise to polymorphic operations operating on them, though. so `[] :: * -> *' (not polymorphic) gives rise to stuff like `take :: forall a. Int -> [a] -> [a]' (polymorphic)
13:48:15 <donaldball> My next iteration will be to replace my lists with sets, which means I can no longer use map directly
13:48:30 <ski> @type Data.Set.map
13:48:31 <lambdabot> Ord b => (a -> b) -> S.Set a -> S.Set b
13:49:39 <donaldball> So I would import qualified Data.Set as Set and call Set.map in my code?
13:49:54 <aweinstock> :t fmap
13:49:55 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:50:03 <aweinstock> :t fmap `asTypeOf` Data.Set.map
13:50:04 <lambdabot>     Could not deduce (Functor S.Set) arising from a use of ‘fmap’
13:50:04 <lambdabot>     from the context (Ord b)
13:50:04 <lambdabot>       bound by the inferred type of
13:50:12 <arkeet> Set isn't a Functor.
13:50:14 <monochrom> overall, equality is a tricky and subjective issue that people overlook in debates. for example, people disagree so much on referential transparency because they don't know that they disagree on equality in the first place.
13:51:18 <andromeda-galaxy> th
13:51:53 <monochrom> here is a scary example. it's my favourite. it's scary because it lives close to you, and you use it everyday, and you didn't know it has such an issue. it is like the friend who comes to your home every evening to play PS3 games with you turns out to be a vampire stalking you. that kind of scary.
13:52:17 <ReinH> And ofc if you want to be more confused about equality than when you started, you can read what nlab has to say http://ncatlab.org/nlab/show/equality
13:52:36 <monochrom> if you are an end user of GHC's Integer, you think you know its equality. 3==3. 4/=3. looks benign.
13:54:11 <athan> Thanks ReinH and monochrom, I'll read up more ;)
13:54:15 <monochrom> but if you are a dev of GHC, or if you import GHC.Integer.GMP.Internals, then there are two kinds of 3, S# 3# or J# <a byte array that contains 3>
13:54:51 <ed|win> is it intended to always be the case that when using stack I have to add dependencies to two files?
13:55:01 <ed|win> feels really redundant
13:55:05 <monochrom> the idea is to use raw machine words and native CPU ops for small numbers, use GMP for large numbers, since GMP is slow for small numbers
13:55:07 <dolio> I think it tries to go back to S# 3# if the GMP value gets small enough.
13:55:13 <dolio> Because that's faster.
13:55:25 <monochrom> but then S# 3# is distinguishable from J# <a byte array of 3>
13:55:39 <glguy> ed|win: You should only have to add them to your cabal files. They should be able to automatically be derived from those cabal files for the stack.yaml
13:56:10 <glguy> the cabal file lists the versions supported, the stack.yaml is just what you're using at the moment locally
13:56:30 <aweinstock> monochrom: I actually found out about GHC.Integer.GMP.Internals today, and that's no longer true
13:56:40 <glguy> stack solver has a --modify-yaml flag to actually save the dependencies you need in your stack.yaml
13:56:52 <glguy> and you should be able to delete the stack.yaml without losing anything particularly important
13:57:05 <donaldball> Odd that Set operates on Ord instead of Eq...
13:57:39 <monochrom> the question "are S# 3# and J# <3> 'equal'?" is going to give you nuts. it is also why people disagree on referential transparency. because they don't even agree on whether to know or not know Integer implementation details.
13:57:45 <aweinstock> monochrom: Integer now has 3 constructors, S#, Jp# and Jn# (for words, positive-byte-arrays, and negative-byte-arrays), and it's a documented invariant that anything that fits in a word is represented by S#
13:57:57 <ski> monochrom : i like Mercury's design better here
13:58:05 <ReinH> ed|win: you only need to add dependencies to your stack.yml file if they are "extra-deps", dependencies that aren't included in your resolver (stackage, nightly, w/e).
13:58:11 <c_wraith> donaldball: it's for efficiency. 
13:58:23 <aweinstock> monochrom: http://hackage.haskell.org/package/integer-gmp-1.0.0.0/docs/GHC-Integer-GMP-Internals.html#t:Integer
13:58:30 <donaldball> Stupid efficiency, getting in the way of conceptual purity
13:58:34 <ReinH> donaldball: Ord allows elements of the set to be stored in a tree, which is a more efficient structure for set operations.
13:58:40 <donaldball> Makes perfect sense
13:58:51 <c_wraith> donaldball: it's really hard to make set operations fast with only equality. 
13:58:57 <ski> monochrom : they distinguish the abstract type (the quotient type) and the representation type, such that (semantic) equality of abstract value doesn't necessarily imply (semantic) equality of representation value
13:59:07 <dolio> ReinH: You can store merely Eq things in a tree if you want. :)
13:59:17 <hpc> monochrom: just pick better concepts and the implementation will become perfectly clear ;)
13:59:19 <aweinstock> donaldball: there's an alternate prelude called SubHask that generalizes Functor in a way that makes it possible to represent "Functors with an Ord constraint"
13:59:28 <patcon> jle`: ah, good call. thanks!
13:59:30 <ReinH> dolio: ... fine :p
13:59:57 <aweinstock> :t GHC.Prim.reallyUnsafePtrEquality#
13:59:58 <lambdabot> a -> a -> GHC.Prim.Int#
14:00:00 <ski> monochrom : pattern-matching on such an abstract type (simplifying a little) is akin to using `unsafeX' in Haskell. because you're not guaranteed to get the same representation value every time you look
14:00:24 <monochrom> wait, are they even supposed to allow it?
14:00:39 * hackagebot cacophony 0.1.0.0 - A library implementing the Noise protocol.  https://hackage.haskell.org/package/cacophony-0.1.0.0 (jgalt)
14:00:44 <monochrom> or perhaps they allow it because we allow unsafeCoerce
14:01:00 * orion just created his first hackage package!
14:01:48 <monochrom> anyway, hope you are scared of Integer. happy Halloween!
14:01:51 <lyxia> orion: congrats
14:02:26 <ski> monochrom : elaborating the simplification, pattern-matching on such a type is a non-deterministic operation, tracked by the determinism system. at the point where you're convinced you'll get equal results for equivalent representations, you can use `promise_equivalent_solutions', which introduces a proof obligation on the programmer. if you lie to the compiler, the compiler can do whatever it likes
14:03:14 <mjhoy> i'm having trouble understand the regex (posix) docs. How do I create a regex with options?
14:03:23 <donaldball> Thanks for the beginner’s advice today, Haskell friends. I’m beginning to get my head around the mechanics now, or so I pretend.
14:03:26 <ski> (tracking nondeterminism isn't something special in Mercury. you're using non-deterministic code all the time anyway)
14:04:05 <aweinstock> monochrom: did you read the link I posted? Integer no longer has non-unique representations of specific numbers
14:04:12 <monochrom> yes
14:04:51 <aweinstock> so why the haloween ghost story? am I reading the documentation incorrectly?
14:05:23 <dolio> monochrom's story was based on true events.
14:05:34 <dolio> *
14:05:39 * hackagebot cabal-cargs 0.7.9 - A command line program for extracting compiler arguments from a cabal file.  https://hackage.haskell.org/package/cabal-cargs-0.7.9 (DanielTrstenjak)
14:05:47 <monochrom> I can say "consider older GHC versions". or I can say "consider having access to S#, Jp#, and Jn#. then you can break all invariants"
14:06:30 <Cale> aweinstock: I'm not failing to have trouble parsing your sentence without such a lack of double negatives.
14:06:33 <monochrom> and lastly, I can say "I won't entertain nitpicking"
14:07:38 <monochrom> I respected you the first time you made your point. I no longer respected you when you pressed it.
14:10:18 <aweinstock> Cale: "Integer now has unique representations of all integers"?
14:10:32 <Cale> aweinstock: Yeah, I figured it out :)
14:10:44 <Cale> aweinstock: (it's not like it was that bad, I just found it a bit funny)
14:11:29 <schell> glguy: thank you!
14:11:34 <schell> (for the pretty-show)
14:11:48 <aweinstock> rrrmr: monochrom just told a haloween ghost story about Integer internals :)
14:11:48 <Cale> aweinstock: How Integer values are represented shouldn't matter that much though. Also, are you sure there aren't multiple representations of the same GMP big natural?
14:12:14 <rrrmr> aweinstock: thanks i was just checking the logs
14:12:26 <dolio> The new implementation uses natural number limbs under the hood, I believe.
14:12:59 <aweinstock> Cale: the documentation says "Invariant: Jn# and Jp# are used iff value doesn't fit in S#", I guess that doesn't specify that the GMP representations are unique...
14:13:27 <aweinstock> dolio: what's a "natural number limb"?
14:13:27 <Cale> dolio: that's right
14:13:41 <dolio> It's a GMP value that can only represent natural numbers.
14:13:44 <dolio> Not integers.
14:14:20 <aweinstock> rrrmr: did the version with W# end up working, btw?
14:14:31 <rrrmr> i'm trying it now
14:17:40 <deech> I'm looking to parse the GHC API itself. Is there some policy on the oldest version of GHC required to build a current version?  
14:18:31 <monochrom> no, I don't think there is a policy yet. but they are now aware that they need to at least document it.
14:18:45 <rrrmr> aweinstock: yes that seems to work. 2# would count bits and 8# would count bytes if i understand correctly?
14:19:07 <dolio> Wouldn't you need 256# to count bytes?
14:20:30 <deech> monochrom: If not a policy is there some common knowledge? Specifically I'm looking to parse 7.8.x onwards. Will 7.6 suffice? 
14:20:39 * hackagebot type-fun 0.0.1 - Collection of widely reimplemented type families  https://hackage.haskell.org/package/type-fun-0.0.1 (AlekseyUymanov)
14:20:42 * hackagebot cabal-bounds 1.0.2 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  https://hackage.haskell.org/package/cabal-bounds-1.0.2 (DanielTrstenjak)
14:22:14 <monochrom> I don't know
14:23:02 <deech> monochrom: Thanks!
14:24:40 <radens> Hey, how do I parse an optional semi-colon with parsec?
14:24:59 <rrrmr> dolio: yah i that looks correct
14:26:24 <sm> rodens: optionMaybe $ char ';' perhaps
14:26:27 <lpaste> sleblanc pasted “No title” at http://lpaste.net/4447667930427031552
14:26:38 <johnw> optional (char ';')
14:26:50 <johnw> is of type Parser (Maybe Char)
14:27:16 <sleblanc> Is it possible to have apply a cast function to a list of elements so that the code I pasted above will work? Gtk provides a "toWidget" (WidgetClass o => o -> Widget) function
14:27:41 <sleblanc> What I would like to avoid is repeatedly typing "toWidget"
14:28:58 <ReinH> sleblanc: Not without existentials, which would replace repeatedly typing toWidget with repeatedly typing ToWidget.
14:28:59 <ski> sleblanc : no. you're looking for existentials
14:29:12 <ReinH> ski: here we go again? ;)
14:29:36 <ski> (and neither of the two ways to encode existentials in Haskell would enable you to avoid the repetition)
14:29:42 <ski> ReinH : i suppose :)
14:29:55 <sleblanc> thanks for the tip. existentials == existential types ?
14:30:04 <ReinH> existential quantification (of types)
14:30:15 <shachaf> ski: If OverloadedLists was sensible, it would let you specify a custom cons function.
14:30:19 <shachaf> And then you could do it.
14:30:34 * ski would like to stress that the "repeatedly typing ToWidget" is not "using existentials", but rather "using one way to express existentials"
14:30:46 <sleblanc> yup, I understood that
14:30:58 <deech> sleblanc: It means in this case that they share a typeclass.
14:31:36 <sleblanc> deech, if all those types are instances of "WidgetClass o", do they share a typeclass?
14:32:06 <ski> (nitpick, they are instances of `WidgetClass')
14:32:12 <ski> and yes
14:32:16 <deech> sleblanc: Not familiar with GTK but yes.
14:32:19 <Skuzzzy> Is haskell the best functional language for industry?
14:32:33 <ReinH> Skuzzzy: for some value of "functional language", yes.
14:32:49 <sleblanc> Skuzzzy, a good fit? Maybe. The most popular? Not yet
14:32:53 <Skuzzzy> Okay, and is learn you a haskell the reccomended read to get into it?
14:32:56 <ski> Skuzzzy : also try asking other functional programming language channels
14:33:00 <ReinH> ski: Not really.
14:33:06 <ski> Skuzzzy ^
14:33:35 <aweinstock> rrrmr: I'd think 256# would count bytes
14:34:08 <aweinstock> (since a "base-256" digit is in [0..255])
14:34:23 <ReinH> Skuzzzy: You might try some of the things recommended in https://github.com/bitemyapp/learnhaskell
14:34:39 <deech> Skuzzzy: IMO it was ready for industry 5 years ago. Now people just keep moving goal-posts so they don't have to bother learning it.
14:34:39 <ReinH> People seem to be doing well with byorgey's course.
14:34:57 <monochrom> sleblanc: it's a bit tautological. the common type class is WidgetClass right there :)
14:35:22 <aweinstock> rrrmr: the GHC documentation says that the GMP documentation says that the underlying function is only defined up to base 62, even though the implementation works for base 256
14:35:41 <sleblanc> monochrom, I was just a bit confused with the terminology. "typeclass" is not how it's spelled in the syntax
14:35:44 <aweinstock> rrrmr: so I'd suggest doing base-2 and dividing by 8 (probably rounding up?)
14:36:13 <monochrom> ah ok
14:37:05 <monochrom> Haskell syntax is "class". Haskell 2010 Report uses "type class" when in prose. most people use "typeclass" when in prose. but I prefer the Haskell 2010 Report to most people.
14:37:29 <johnw> I've always preferred it with a space in between also
14:38:00 <monochrom> I also follow the Report in saying "the Maybe type" and it drives people nuts :)
14:38:09 <bitemyapp> with bikeshedding, you're at least dealing with paint
14:38:14 <bitemyapp> y'all have found a way to discuss ' '
14:38:30 <bitemyapp>  ;)
14:38:38 <sleblanc> Many other languages call it the "Option(al) type"
14:38:44 <monochrom> oh, juxtaposition is an amazing story too
14:38:49 <johnw> bitemyapp: the funny thing is when you finish painting the shed, and there's no bike
14:39:14 <monochrom> mathematicians write f(x) for function application. ML and Haskell write f x. Dijkstra writes f.x
14:39:39 <monochrom> and mathematicians write x y for multiplication
14:40:07 <monochrom> except when it's sin x, then it's function application
14:40:08 <bitemyapp> johnw: chaos reigns!
14:40:10 <johnw> we also write f$x
14:40:14 <arkeet> mathematicians also often omit parentheses for function application
14:40:58 <monochrom> and except when it's 3 ¼, then it's addition
14:42:08 <sleblanc> and people who code in assembly write "movl $val, %eax;  call function"
14:42:59 <mniip> eax?
14:43:02 <mniip> what ABI is that
14:43:07 <sleblanc> it's a register
14:43:14 <mniip> right
14:43:25 <mniip> but what ABI passes arguments via %eax
14:43:30 <mauke> if you write in asm, you can use whatever convention you want for your own code
14:43:47 <mniip> for your own yes
14:43:52 <monochrom> let's just coin the name "the EAX ABI" and be done :)
14:43:58 <sleblanc> If it's a function with internal linkage, the compiler is allowed to optimize it the way it wants, this is such a way
14:44:16 <sleblanc> avoids pushing to the stack
14:44:18 <hpc> maybe your OS uses a wonky syscall convention
14:44:39 <ReinH> and now we're bikeshedding about assembly language
14:44:43 <shachaf> monochrom: What about -3 ¼?
14:44:48 <shachaf> monochrom: Then it's subtraction.
14:45:05 <monochrom> yikes haha I forgot that one
14:45:07 <aweinstock> shachaf: no, there are implicit parens there
14:45:26 <monochrom> anyway, we should also argue over "mov x, y" vs "mov y, x"
14:45:30 <shachaf> monochrom: There's a good section about this in _Mathematics Made Difficult_.
14:45:32 <sleblanc> shachaf, remember! the parentheses are implied! -3 ¼ → -(3  ¼)
14:45:41 <aweinstock> -3¼ = -(3¼) = -(3 + ¼) = -3 - ¼
14:46:14 <aweinstock> juxtaposition has higher precedence than prefix (-), but it still means addition :)
14:46:45 <aweinstock> monochrom: I prefer "mov $x, %y", personally
14:46:53 <johnw> monochrom: I rather argue about the "," first
14:48:22 <schell> glguy: pretty-show works like a charm :)
14:53:05 <radens> Is there a parsec irc channel?
14:53:19 <monochrom> no. use this one.
15:08:23 <int-index> Turns out `(Num a, Ord a)` and `(Ord a, Num a)` are not always interchangeable (http://lpaste.net/5148134705077420032) - is it the intended behavior or a bug in GHC?
15:09:43 <bitemyapp> int-index: huh.
15:14:23 <bitemyapp> int-index: I think it follows from how FlexibleInstances works, but I could be wrong.
15:16:12 * hackagebot Chart-cairo 1.5.4 - Cairo backend for Charts.  https://hackage.haskell.org/package/Chart-cairo-1.5.4 (TimDocker)
15:18:36 <int-index> bitemyapp: I expected `Constraint`s to be normalized internally, so I'd get a duplicate instance error.
15:20:02 <int-index> at least at use site
15:24:51 <Cale> int-index: haha
15:25:03 <Cale> int-index: Yeah, no, there's no way you could normalise them in general
15:25:27 <Cale> int-index: That's a clever way to obfuscate the hell out of code though
15:25:45 <Cale> Having values which depend on exact constraint contexts
15:27:39 <int-index> Why is it impossible to normalize them? Unless I miss something, once type variables are instantiated a constraint is just a class name and a list of type names (or an equality constraint, which isn't much different)
15:27:53 <int-index> Store them in a Set and call it a day
15:28:48 <isd> If I'm using parsec to build up an AST, and I want to have source location information attached to the result, what's the right way to go about getting that from parsec? My instinct was to look for Something of type (Parser SourcePos) that consumed no input, but I'm not finding anything.
15:29:56 <int-index> isd: Use the `getPosition` function https://hackage.haskell.org/package/megaparsec-4.1.1/docs/Text-Megaparsec.html#v:getPosition
15:30:15 <lpaste> emmanuel_erc pasted “**315 lines** An implementation of manifold learning algorithm (ask for the title or pdf if you are curious)” at http://lpaste.net/144144
15:31:04 <emmanuel_erc> For those that decide to look at my lpaste... I want to say thank you in advance.
15:34:06 <emmanuel_erc> Well, I guess I should say that I want to ask for help in speeding the code.
15:34:48 <isd> int-index: thanks
16:06:14 * hackagebot reactive-banana 1.0.0.0 - Library for functional reactive programming (FRP).  https://hackage.haskell.org/package/reactive-banana-1.0.0.0 (HeinrichApfelmus)
16:06:16 * hackagebot ivar-simple 0.3.2 - Write once concurrency primitives.  https://hackage.haskell.org/package/ivar-simple-0.3.2 (BertramFelgenhauer)
16:07:09 <suppi> congrats reactive-banana~!
16:13:06 <orion> If I'm reading raw JSON on a TCP socket, what's the best way to pass it to aeson given that I don't know how many bytes are needed to be read?
16:13:40 <lf94_> So...a monoid is just a set and a binary operation?
16:13:50 <lf94_> With associativity and identity rules?
16:15:28 <happyfeet> hey, i have a list of strings and i want to make all 'a' turn  into 'b' 
16:15:53 <happyfeet> example: ["aaa","abc"]  >> ["bbb","bbc"]
16:16:15 * hackagebot reactive-banana-wx 1.0.0.0 - Examples for the reactive-banana library, using wxHaskell.  https://hackage.haskell.org/package/reactive-banana-wx-1.0.0.0 (HeinrichApfelmus)
16:16:21 <dmj> orion: stream parsing, pipes, conduit, io-streams supports this
16:16:31 <dmj> @pkg pipes-aeson
16:16:31 <lambdabot> Maybe you meant: pl ping msg bug
16:16:39 <Hijiri> > let f 'a' = 'b'; f c = c; in (map.map) f ["banana", "cat"[
16:16:40 <lambdabot>  <hint>:1:59:
16:16:40 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
16:16:41 <Hijiri> > let f 'a' = 'b'; f c = c; in (map.map) f ["banana", "cat"]
16:16:42 <lambdabot>  ["bbnbnb","cbt"]
16:16:45 <dmj> @package pipes-aeson
16:16:45 <lambdabot> http://hackage.haskell.org/package/pipes-aeson
16:18:34 <int-index> lf94_: Correct. A monoid is a just triple (S, *, 1) (a set, a binary operation, and an identity element). You know the rest.
16:18:52 <int-index> *is just a triple
16:19:16 <lf94_> I see Monad being referred to as a triple, and not a Monoid. Odd.
16:20:00 <int-index> because a Monad is just a Monoid in the category of endofunctors C;
16:20:33 <lf94_> Yeah I figured.
16:21:29 <lf94_> The only difference I'm seeing between the two is a Monad can map between categories.
16:21:40 <alexclark> can someone help me figure out why I'm getting this stack error?
16:21:42 <lf94_> And a Monad has 2 different functions than a Monoid
16:21:56 <alexclark> load-env: needed (-any), not present in build plan (latest is 0.1.1)
16:22:22 <acro> hi
16:22:36 <acro> i have a question
16:22:37 <alexclark> `load-env` is in my project.cabal
16:22:42 <alexclark> and i ran stack install
16:23:10 <alexclark> if i run `cabal install load-env` it says its already there
16:23:45 <acro> how can i check if a list is all made of elements?
16:23:58 <acro> and those elements are numbers?
16:24:00 <happyfeet> how's so acro?
16:24:19 <arkeet> lists are always made of elements.
16:24:22 <arkeet> also look at the type.
16:24:23 <acro> i have this ["11","2","5","8","7","7","5","6","7","6","2","3","p","3"]
16:24:32 <arkeet> those are strings.
16:24:46 <acro> want to check if the list is all made of numbers or not
16:24:55 <arkeet> how do you check a single string, then?
16:25:56 <acro> atm im using isDigit x
16:26:08 <acro> and dividing the list in ((x:xs):t)
16:26:09 <happyfeet> check ((x:xs):y)         isDigit x = check xs .... and so on
16:26:17 <arkeet> :t all
16:26:19 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
16:26:33 <arkeet> (a -> Bool) -> [a] -> Bool
16:27:14 <acro> how so?
16:27:53 <happyfeet> check ((x:xs):y)
16:28:10 <happyfeet> |  isDigit x = check xs:y
16:28:29 <happyfeet> | otherwise = False
16:28:48 <acro> didnt know what i was missing
16:28:52 <happyfeet> isDigit []:y = isDigit y
16:28:58 <acro> will try that
16:29:13 <happyfeet> isDigit [] = True
16:29:20 <happyfeet> i think that will work
16:31:29 <ski> lpaste : the functor in a monad is an endofunctor. from a category to the same category. "2 different functions" ?
16:33:53 <mgsloan> alexclark: Cabal uses a different package database than stack.  Usually when you get that error, it suggests adding some things to your extra-deps list
16:34:06 <ski> er ..
16:34:10 <ski> lf94_ ^
16:34:21 * ski just realized they messaged lpaste
16:34:44 <mgsloan> alexclark: In particular, I'd expect it to tell you to add "- load-env-0.1.1"
16:35:16 <lf94_> ski: x -> T(x), T(T(x)) -> T(x)
16:35:38 <lf94_> ski: ah ok. yes to the same category...
16:35:42 <ski> lf94_ : those correspond to the neutral element, and the binary combination, in a monoid
16:35:42 <lf94_> makes sense :)
16:35:53 <mgsloan> alexclark: The reason this happens is that it's not in the stackage snapshot, so you need to specify a version. ( see https://www.stackage.org/package/load-env )
16:36:39 <alexclark> ah ok, thanks mgsloan!
16:41:16 <Polygoner> hello
16:42:13 <ski> hello Polygoner
16:47:17 <acro> happyfeet my function is Non-exhaustive
16:47:22 <dmj> is it possible to use environment variables in stack.yaml
16:47:26 <acro> what am i missing
16:48:31 <ski> @paste
16:48:31 <lambdabot> Haskell pastebin: http://lpaste.net/
16:48:33 <ski> acro ^
16:49:43 <acro> http://lpaste.net/144148
16:50:24 <ski> you're missing the `check ([]:t)' case
16:51:03 <acro> i had that
16:51:09 <ski> (or `check ("":t)', if you prefer. it's the same thing here, since your list elements are strings anyway)
16:51:22 <ski> you don't have that in that paste
16:51:30 <acro> check ([]:t) = isDigit t
16:51:53 <ski> ok. with that it's exhaustive
16:52:03 <acro> i know because it didnt work
16:52:15 <ski> oh, but it's a type error, yes
16:52:28 <ski> because the definiens, `isDigit t', there is wrong
16:52:45 <ski> `t' is a list of strings, you can't pass it to `isDigit', which expects a single character
16:53:12 <acro> how do i seperate t
16:53:19 <ski> you don't need to
16:53:23 <acro> (x:xs) again?
16:53:28 <ski> no need to
16:54:22 <ski> (you could, but you'd end up in the same situation you're in currently, again)
16:54:40 <acro> how do i exit them?
16:55:01 <ski> by writing the correct definiens for that defining equation
16:56:27 <acro> so i want to verify the if t isDigit
16:56:45 * ski doesn't know what `check' is supposed to do
16:57:27 <acro> check sees if a list of string [String] is composed of only numbers
16:58:13 <monochrom> I don't understand. the pasted code already type-checks and is already exhaustive. what needs fixing?
16:58:18 <ski> do you mean whether every string element consists only of digits ?
16:58:27 <acro> yes
16:58:32 <ski> or perhaps every string should contain a single digit ?
16:58:54 <ski> or perhaps every string should contain an integer numeral, possibly with a leading minus/negative sign ?
16:59:05 <acro> no 
16:59:15 <acro> for exemple ["11","2","5","8","7","7","5","6","7","6","2","3","5","3"] should return true
16:59:27 <monochrom> and it already does: for every string, every char in that string is a digit.
16:59:32 <monochrom> so what needs fixing?
16:59:49 <acro> it is Non-exhaustive
16:59:51 <ski> monochrom : one case is missing. makes it non-exhaustive
17:00:03 <monochrom> no I turned on -Wall and no warning
17:00:06 <ski> (the suggested definition for it is type-incorrect)
17:01:23 <ski> @let check :: [String] -> Bool; check [] = True; check ((x:xs):t) | isDigit x = check (xs:t) | otherwise = False
17:01:25 <lambdabot>  Defined.
17:01:27 <ski> > check []
17:01:30 <lambdabot>  True
17:01:31 <ski> > check [""]
17:01:32 <lambdabot>  *Exception: /tmp/mueval7523927541474612399.hs:(165,1)-(168,21): Non-exhausti...
17:01:47 <monochrom> ok, but I am looking at <acro> http://lpaste.net/144148
17:02:02 <ski> that's the one i'm looking at as well
17:02:33 <monochrom> I'll make a screenshot so you can double-check
17:02:43 <ski> oh, but apparently it's been revised since i loaded it
17:02:58 <monochrom> ok yeah. (I didn't do it!)
17:03:51 <ski> whoever revised it would have been better adviced to annotate it
17:04:09 <monochrom> yeah, or at least speak up. or leave a signature.
17:04:12 <ski> (er, s/adviced/advised/)
17:04:31 <monochrom> "I did it. Zorro."
17:06:11 <monochrom> yeah, the old version misses a case for "check ([] : t) = ?"
17:06:38 <monochrom> I don't know how to guide it, apart from spoiling it altogether.
17:06:55 <ski> yesm ditto
17:07:01 <frerich> Interesting that hlint suggests using 'foldr' instead of 'all'.
17:07:06 <monochrom> use recursion.
17:08:16 <monochrom> but if the question is the easier "why does it need that case?", then here is why: ["", "123"] does not match [] and does not match (x:xs):t
17:10:37 <acro> ski any answer?
17:12:51 <ski> acro : to which question ?
17:13:46 <acro> the condition that is missing
17:14:34 <ski> i know a correct way to fill it in, yes, if that's what you're asking about
17:15:21 <acro> yes it is, could you share?
17:16:29 <ski> i think you probably learn more by thinking about it
17:16:37 <ski> consider an example like
17:16:59 <acro> im thinking about converting the [String] to [Int]
17:17:19 <ski>      check ["11","2","5"]
17:17:22 <acro> that way i would know
17:17:50 <ski>   =  check (('1':'1':[]):('2':[]):('5':[]):[])
17:18:42 <ski>   =  check (('1':[]):('2':[]):('5':[]):[])   -- by your last defining equation, because `isDigit x' is true, when `x' is the character :  '1'
17:18:46 <isd> This must be there somewhere but I'm not finding it: equivalent of mkdtemp
17:18:48 <ski>   =  check ([]:('2':[]):('5':[]):[])   -- by your last defining equation, because `isDigit x' is true, when `x' is the character :  '1'
17:19:05 <acro> yes
17:19:09 <ski> at this step, you haven't specified a working way for how to continue the checking
17:19:34 <ski> for the case, `check ([] : t)', you should say how to continue the checking, until done
17:19:35 <acro> i can check (xs:t)
17:20:02 <ski> do you mean, `check ([]:xs:t)' ?
17:22:48 <acro> i didnt but it make sense
17:23:49 <ski> but then you must look into `xs' to be able to progress
17:24:06 <ski> `xs' is either `[]' or of the shape `x:xs', for a new `xs'
17:24:33 <ski> giving you `check ([]:[]:t)' and `check ([]:(x:xs):t)' as new cases to handle
17:25:11 <jophish> I'm generating a string which is itself code to generate a string in another language, which is used as an input to reads back in Haskell
17:25:19 <ski> in the first case, how do you progress ? replacing `t' by `xs:t' as before will just end you up with `check ([]:[]:[]:t)' (and `check ([]:[]:(x:xs):t)') ..
17:25:21 <jophish> It's the most horrific mess of escaping
17:25:23 <acro> wouldnt i get back to where i started?
17:25:32 <jophish> there must be an easier way
17:25:42 <ski> acro : so you're just getting back to basically the same original unhandled situation
17:26:21 <acro> but when t = [] it will stop
17:26:37 <ski> acro : so, this is what i mean by saying that it's no use handling the `chech ([]:t)' case by considering that `t' must be either `[]' or `xs:t'
17:26:52 <ski> acro : yes. the problem is the `t = xs:t2' case
17:27:13 <ski> you'll just end up in a similar situation as before, only with more `[]:'s added into the picture
17:27:45 <acro> i can use and auxiliar
17:27:50 <ski> the key to solve the problem is what monochrom said
17:27:53 <hackal>  /j #ubuntu
17:28:02 <hackal> sorry
17:28:03 <acro> that checks the length of x
17:28:32 <acro> recursion
17:28:35 <ski> yes
17:32:40 <augur> anyone have experience with ghc + el capitan?
17:32:55 <augur> or cabal, really. im getting a stupid complaint from cabal about /usr/bin/ar
17:37:14 <isd> Anyone ^?
17:37:47 <isd> Aha, found it, nevermind
17:38:19 <acro> didnt get there ski
17:38:54 <ski> ?
17:39:57 <acro> the recursion 
17:40:58 <ski> i'm not quite sure how you got the `isDigit x' case right, but are not seeing how to do this `check ([]:t)' case
17:41:51 <acro> is that obvious?
17:41:54 <ski> i can only assume you've stared so much at `check ([]:t) = isDigit t' that you can't see how it's wrong, or that you're too tired atm, or something
17:42:03 <acro> i think im just tired
17:42:08 <glguy> augur: The way I've seen to fix the /usr/bin/ar problem is to rebuild cabal-install against unix-2.7.1.0
17:42:21 <ski> perhaps take a break then. maybe take a walk outside
17:42:32 <glguy> augur: To use GHC 7.8.4 you have to rebuild Cabal against that, too. The one that comes with GHC isn't
17:42:50 <acro> will sleep
17:42:56 <ski> oh, and i suggest replacing `check ([]:t) = isDigit t' with `check ([]:t) = ???', before staring more at it, to help you forget what you had before
17:43:08 <acro> if i cant find it i will pm me or something
17:43:45 <augur> glguy: hm. how would i do this?
17:43:57 <augur> i have ghc 7.8.4, fwiw
17:44:00 <acro> will do
17:44:51 * nitrix replaces ski with bckw.
17:45:00 <glguy> augur: Either update to 7.10 where things work or start installing an updated unix and the things that come with it using manual uses of the Setup.hs files that come with packages
17:46:01 <augur> ill try upgrading to 7.10
17:47:54 <glguy> augur: see https://github.com/ghcformacosx/ghc-dot-app/issues/41
17:48:10 <nitrix> augur: Nice to see you on #haskell.
17:48:18 <Lokathor> :t genRange
17:48:19 <lambdabot> RandomGen g => g -> (Int, Int)
17:48:26 <glguy> augur: The easiest way to go is to have installed 7.10 already and updated your cabal-install before upgrading OS X
17:48:43 <augur> nitrix: where else would i be!
17:48:49 <nitrix> augur: ##categorytheory :P
17:48:58 <Lokathor> Now, the docs say that genRange can't examine its argument, so why does it take one at all? shouldn't it just take no argument like minBound and maxBound do?
17:49:01 <augur> glguy: well its a bit late for that x3
17:49:03 <nitrix> augur: At least that's where I know you from :P
17:49:13 <augur> nitrix: oh, hm
17:51:19 * hackagebot ListWriter 0.1.0.0 - define a list constant using Monadic syntax other than overhead [,]  https://hackage.haskell.org/package/ListWriter-0.1.0.0 (YLiLarry)
17:53:56 <glguy> Lokathor: Modern APIs would take a proxy argument or return a Tagged result. You need some way to specify the particular generator that you're querying the range of
17:54:04 <glguy> that type doesn't appear in the range itself
17:54:26 <Lokathor> so minBound is at fault, not genRange?
17:55:54 <glguy> Lokathor: I don't know what fault you mean
17:56:18 <Lokathor> well, to compare to minBound
17:56:20 <glguy> It takes an argument so it knows what type of generator you want the range of
17:56:22 <Lokathor> :t minBound
17:56:23 <lambdabot> Bounded a => a
17:56:41 <Lokathor> minBound takes no argument, but still gives you correct Int and Word values and so forth
17:56:53 <glguy> Yeah, it doesn't need an extra argument to determine the type you're asking about
17:56:59 <glguy> because the type is the type of the result already
17:57:14 <Lokathor> aahhhh, i see
17:57:20 <glguy> genRange varies based on teh type of the generator, just not the value of the generator
17:57:36 <Lokathor> but since the output is Int,Int... then... ah ha
17:58:13 <hackal> Hello, I am in the middle of assignment and I got stuck. I included the instructions in the paste. I am not sure how to handle the "warning" part in instructions. http://lpaste.net/144153 thanks for any advice
18:00:15 <augur> glguy: geez what a mess this is
18:00:23 <ReinH> hackal: look like it got cut off
18:02:09 <ReinH> hackal: but it seems to me that you can compare both the lower-cased and the upper-cased versions of both strings.
18:02:14 <sbrg> I have a parametrized type Plugin a that I convert to InitializedPlugin a. Users can provide plugins of different types(the 'a' parameter denotes the type of state the user has chosen for the plugin to contain). I need to be able to treat a bunch of plugins with different 'a' parameters as if they're all the same. Basically, I need to be able to put these in a list so I can basically treat all plugins as
18:02:16 <sbrg> equal and initalize them, without caring about the type the user is actually using internally. How can I do this?
18:02:47 <glguy> hackal: Sounds like you just have an underspecified problem. It should tell you what behavior is desired rather than asking you to guess
18:03:16 <hackal> ReinH: sorry what got cut off? This is the full exercise. My functions are working but fail at sameString "\181" "\956" which is supposed to be true. So I guess there might be some kind of comparison on level of unicode/UTF-8
18:03:26 <MarcelineVQ> "In this case either"
18:03:28 <ReinH> hackal: it says "In this case either" and then stops.
18:03:37 <sbrg> I tried something like data PluginWrapper = forall a. PluginWrapper (Plugin a) and then I could have a list of [PluginWrapper pluginWithIntState, PluginWrapper pluginWithStringState] but this results in the loss of type information for when I need to convert Plugin a to InitializedPlugin a
18:03:38 <ski> hackal : ".. What does your code do on sameString \"\\181\" \"\\956\"? In this case either"
18:04:18 <hackal> I am sorry didn't see that I added annotation
18:05:11 <hackal> "as long as tests don't fail" however tests fail in case if '\181'
18:05:49 <jophish> I'm sure there must be a shorter way of saying: sum . fmap (view foo) $ [...]
18:06:19 <glguy> sumOf (folded . foo)
18:07:14 <jophish> ah, I don't have sumOf in microlens
18:07:37 <ReinH> jophish: do you have foldlOf' ?
18:07:48 <glguy> bummer, you're missing half the point of lens :)
18:08:06 <ReinH> Oh, you don't even have traversals.
18:08:08 <ReinH> What a shame.
18:08:10 <jophish> ReinH: doesn't look like it
18:08:17 <ReinH> Oh, you do.
18:08:47 <ReinH> But you don't have the rest of the machinery
18:15:51 <augur> sbrg: so there's a way to kind of do what you want
18:16:14 <glguy> sbrg: You're going to need an InitializedPluginWrapper, too
18:16:32 <augur> but the problem is that because you want to treat things with different `a`'s as equivalent, you lose all of the utility of having `a` in the first place
18:16:47 <sbrg> yeah, I can sort of see that
18:17:20 <augur> nothing can ever care about what `a` is, except for the stuff internal to the plugin and so on
18:17:24 <sbrg> But I somehow feel it makes sense that this should be possible.. something like passing the type information around implicitly, but that would have to be runtime type information I guess
18:18:00 <augur> it might be good to step back and try to figure out exactly why you want to parameterize it, what that parameter is really allowing, and see if there's some other way that doesnt require the parameter
18:19:56 <sbrg> yeah, that might be a good idea. But I'm not sure I can do this without the type parameter. I just added the type parameter as an attempt to solve the problem I described above more elegantly
18:20:29 <bitemyapp> sbrg: can it be a sum type?
18:20:44 <bitemyapp> sbrg: is the set of types that will inhabit 'a' finite and known to you?
18:20:59 <augur> sbrg: write out the full thought process behind the choice to use a type param, and what it permits, functionality-wise
18:21:06 <bitemyapp> sbrg: sum types are the canonical way to case on things here. I can suggest alternatives if that is exhausted.
18:21:12 <augur> not here, but somewhere. maybe in a paste, if you intend to share it
18:21:25 <bitemyapp> sbrg: yeah a paste would help.
18:22:20 <lpaste> glguy pasted “hidden plugin argument” at http://lpaste.net/144156
18:22:47 <sbrg> bitemyapp: It isn't known to me, no. the point is to let the user of this system provide any type of state that they can update, and the only way I will ever interact with it will be indirectly by using functions they provide to, say, serialize it
18:23:03 <glguy> sbrg: Sounds like what I pasted
18:23:54 <MarcelineVQ> hackal: I'm not seeing it, what's the problem exactly? sameString "\181" "\956" should not be true. and even if it was sameString ['\181'] ['\956'] to compare the special characters it should still not be true. toUpper on '\181' and '\956' are equal, toLower are not.
18:24:01 <sbrg> glguy: hm, that looks promising yes
18:24:46 <MarcelineVQ> Your functions are working correctly as you have written them, as far as I can tell, they'd be wrong if you used toUpper to compare instead
18:25:29 <MarcelineVQ> hackal: Your tests aren't failing, returning false is a success for  sameString "\181" "\956"
18:25:30 <sbrg> let me see if I can weave that in
18:25:54 <bitemyapp> sbrg: do you know what existential quantification does?
18:26:05 <sbrg> bitemyapp: aye
18:26:11 <bitemyapp> sbrg: okay, should be alright then.
18:26:11 <hackal> MarcelineVQ: alright, why is toUpper on '\181' and '\956' equal?
18:26:38 <bitemyapp> sbrg: I was thinking it as well but am usually loathe to resort to it because people can get tied up with it.
18:26:47 <MarcelineVQ> because "For example, the greek letter [greek letter] and the micro sign map to the same upper case letter.
18:27:03 <ski> > text "\181\956"
18:27:05 <lambdabot>  µμ
18:27:21 <glguy> bitemyapp: sbrg was already using it in the partial solution presented
18:28:12 <MarcelineVQ> > toUpper '\181'
18:28:13 <lambdabot>  '\924'
18:28:14 <MarcelineVQ> > toUpper '\181' == toUpper '\956'
18:28:15 <bitemyapp> glguy: oh dang, I missed that.
18:28:16 <lambdabot>  True
18:28:24 <bitemyapp> maybe link scrolled before I looked?
18:28:26 <MarcelineVQ> but 181 and 956 are not the same letter
18:28:37 <MarcelineVQ> Which is why using toUpper to compare would be wrong
18:28:58 <MarcelineVQ> *\181, 
18:29:04 <MarcelineVQ> etc
18:38:35 <sbrg> glguy: That was *exactly* what I needed. wow. thanks!
18:39:03 <sbrg> and to everyone else for input.
18:39:08 <sbrg> I was really afraid that was impossible. 
18:39:34 <hackal> Is there a way to check how are built in functions implemented in haskell? For example I would like to see code of isInfixOf
18:39:55 <glguy> The haddock documentation has source code links
18:40:05 <sbrg> hackal: sure -- try googling isInfixOf and you'll find it on hackage
18:40:14 <sbrg> click the source link, etc.
18:40:52 <sbrg> glguy: Is there some kind of 'term' for what Hide is doing, if that makes sense? I mean, people talk about "proxy types" and so on.. 
18:40:55 <sbrg> something in that ballpark
18:41:22 * hackagebot concurrent-output 1.0.0 - handling concurrent output  https://hackage.haskell.org/package/concurrent-output-1.0.0 (JoeyHess)
19:09:07 <reduceleft> hi, is there a way to use <*> when a is really [a] and b is really [b]
19:09:10 <reduceleft> as in
19:09:18 <reduceleft> [[a] -> [b]] -> [a] -> [b]
19:11:02 <glguy> sbrg: I'm not sure. The closest "technical" term I can think of is "forget"
19:11:03 <kadoban> :t (<*>)
19:11:04 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:11:57 <ski> > [reverse,take 2] <*> ["foo","bar"]
19:11:59 <lambdabot>  ["oof","rab","fo","ba"]
19:12:33 <kadoban> reduceleft: Throw in a couple 'pure' ? Otherwise it doesn't look like it matches.
19:12:48 <ski> reduceleft : substituting `[a]',`[b]' for `a',`b' in `[a -> b] -> [a] -> [b]' yields `[[a] -> [b]] -> [[a]] -> [[b]]'
19:13:03 <sbrg> glguy: alright, thanks
19:13:29 <ski> reduceleft : an example of the transformation you want to effect would be nice
19:14:44 <ski> @type (<*>) . (`asTypeOf` [])
19:14:45 <lambdabot> [a -> b] -> [a] -> [b]
19:15:18 <reduceleft> ski: kadoban: thanks hold on let me think for a sec :D
19:18:04 <kadoban> (I guess you'd only need one 'pure', by the way. But I'm still not 100% clear on exactly what the point would necessarily be)
19:22:26 <Profpatsch> I’m trying to implement Prelude functions.
19:22:37 <Profpatsch> filter:
19:22:54 <Profpatsch> filter' p = foldr (\x l -> if p x then x:l else l) []
19:23:06 <Profpatsch> vs https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.List.html#filter
19:23:31 <Profpatsch> Why doesn’t the Prelude version implement it in terms of foldr?
19:25:29 <MarcelineVQ> what does your foldr version look like?
19:25:38 <reduceleft> oh man, I'm silly, this whole time I thought my xs was [[a]] but I forgot to first make it xss via repeat, problem solved... Thanks ski and kadoban
19:26:24 <ski> reduceleft : hm, `repeat' ?. sure you don't want `zipWith ($)' instead of `(<*>)', then ?
19:27:18 * ski isn't sure
19:34:51 <Profpatsch> MarcelineVQ: Heh, actually I didn’t write it yet.
19:35:09 <Profpatsch> should maybe try that stuff without enabled Prelude.
19:35:56 <eric1> Total noob here.  I'm trying to write a program to play hangman, and looking for tips on my general approach.  
19:36:33 <dmj> eric1: https://github.com/dmjio/Hangman
19:37:36 <eric1> Thanks, I will have a look
19:56:26 * hackagebot HaskellNet-SSL 0.3.1.0 - Helpers to connect to SSL/TLS mail servers with HaskellNet  https://hackage.haskell.org/package/HaskellNet-SSL-0.3.1.0 (DanielWright)
20:13:14 <SanDisc> what is the difference between CPS and function composition?
20:14:39 <ski> function composition is a particular function. continuation-passing style is a style of writing code in
20:15:34 <SanDisc> so CPS is only a matter of style?
20:15:37 <kadoban> Isn't function composition anything that combines several functions together?
20:15:55 <ski> `(.)' is function composition
20:16:15 <ski> CPS is a particular style
20:17:11 <SanDisc> I'm using Servant right now and can see how much Servant "sells" CPS
20:17:18 <ski> state-threading would be another style
20:17:33 * ski has no idea what this "Servant" is
20:18:06 <SanDisc> another Haskell web framework
20:18:11 <ski> ok
20:18:15 <kadoban> Wouldn't :: (c -> d) -> (a -> b -> c) -> a -> b -> d  -- also be function composition? I don't see why it'd only be (.)
20:18:47 <ski> (that's `(.) . (.)')
20:19:18 <monochrom> that is function composition function-composed with function composition XD
20:19:51 <SanDisc> argh, my brain hurts! :(
20:20:12 <dfeuer> In dependently typed languages, function composition has a much nastier type!
20:20:24 <ski> sometimes people use the term "composition" in a more general sense, as in any expression which is composed in some way out of function calls and possibly other bits
20:21:30 <pyon> What's the best tool for reading Excel files?
20:21:35 <ski> SanDisc : anyway, CPS is related to the continuation monad
20:21:46 <pyon> I mean, from a Haskell program, obviously.
20:22:33 <ski> SanDisc : re web programming and continuations, <http://tmp.barzilay.org/cont.txt> could perhaps interest you (using Scheme, not Haskell)
20:23:00 <SanDisc> ok, I'm reading it. Thanks
20:26:50 * hackagebot phone-numbers 0.0.3 - Haskell bindings to the libphonenumber library  https://hackage.haskell.org/package/phone-numbers-0.0.3 (ChristianMarie)
20:37:27 <Lokathor> http://lokathor.blogspot.com/2015/10/pcg-random-numbers-in-haskell.html
20:37:45 <Lokathor> short thing i threw together
20:39:54 <Romefeller> Hello everyone
20:41:14 <saulzar> Lokathor, Looks good :)
20:51:54 <Romefeller> .
20:55:20 <jle`> Lokathor: nice :)
20:55:23 <jle`> Romefeller: hi!
20:57:13 <Romefeller> Hi jle` 
20:59:40 <Romefeller> Quiet today
21:23:38 <c_wraith> Woo, I wrote a pretty-printer for my totally-lying Monoid.  Now I can pretty-print how use of it is associated!
21:26:05 <emmanuel_erc> hi c_wraith
21:26:24 <c_wraith> emmanuel_erc: hello
21:27:30 <yashinbasement> hi what does it mean in saying let e = head [] in 3
21:27:35 <ski> c_wraith : make it return an `IO'-action, and blame the differences due to association on general I/O nondeterminism ?
21:28:03 <c_wraith> ski: nah..  It's deterministic, it's just a liar.  http://lpaste.net/144158
21:28:23 <ski> yashinbasement : let `e' be the result of the computation `head []', and then give `3' as result (never computing `e')
21:28:37 <kadoban> yashinbasement: It's probably some kind of demonstration of non-strictness in haskell.
21:28:42 <ski> c_wraith : i'm saying you can pretend it's nondeterministic
21:28:48 <kadoban> > head []
21:28:50 <lambdabot>  *Exception: Prelude.head: empty list
21:28:55 <kadoban> > let e = head [] in 3
21:28:57 <lambdabot>  3
21:29:23 <ski> > let e = head [] in if e == 0 then 3 else 3
21:29:24 <lambdabot>  *Exception: Prelude.head: empty list
21:29:59 <yashinbasement> does that mean head [] is never been calculated
21:30:17 <kadoban> yashinbasement: In the expression you provided, yes exactly.
21:30:18 <pyon> yashinbasement: If it isn't required, it's indeed not calculated.
21:31:43 <yashinbasement> by the way way whatever I type before in it's not being touched, so in has most precedence ?
21:32:18 <kadoban> yashinbasement: It's syntax, it doesn't have precedence. IIUC
21:32:28 <yashinbasement> oh right
21:32:48 <ski> > let e = head [] in e
21:32:49 <lambdabot>  *Exception: Prelude.head: empty list
21:32:50 <kadoban> let … in …  is kind of one "thing" that means something.
21:32:53 <yashinbasement> yeah as long as the right term is bounded of in than it does not calucalte left side
21:35:18 <emmanuel_erc> Hey guys...I am trying to create a package (actually an executable) with the cabal system.
21:35:59 <emmanuel_erc> I want to add compiler flags to the cabal file and I am finding that is only possible if I include a test suite; which I am not going to at this moment.
21:36:04 <emmanuel_erc> any suggestions?
21:37:06 <ReinH> I'm not sure what "as long as the right term is bounded of in" means.
21:37:40 <yashinbasement> can you explain this please :t map (+3), is Num b => [b] -> [b] , I mean if we see :t (+3) is Num a => a ->a,and you know the type of map, so i am confused how (+3) type is plugged in whole expression
21:38:36 <cocreature> emmanuel_erc: are you looking for the ghc-options field?
21:39:20 <yashinbasement> I mean to say (+3) is still needs Num b 
21:40:15 <emmanuel_erc> cocreature: yea, I was using that and I couldn't get the cabal to build...
21:40:30 <emmanuel_erc> To be specific, I was passing the options -O2 and --make
21:41:06 <cocreature> what was the error?
21:42:44 <emmanuel_erc> everything seems fine now, I think. When I run cabal sdist it just tells me that make is unnecessary (derp....). It also tells me that -O2 is rarel necessary.
21:42:49 <emmanuel_erc> rarely*
21:43:19 <yashinbasement> :t zip [True, False], is [a] -> [(a, Bool)] , makes sense coz in zip type [a] -> [b] -> [(a, b)] b is replaced with Bool
21:43:20 <lambdabot> parse error on input ‘,’
21:44:00 <yashinbasement> but not sure about map (+3)
21:45:00 <MarcelineVQ> map takes the function you give it and applies it to every element in a list you give it, and gives you a new list from that
21:45:32 <MarcelineVQ> :t map
21:45:33 <lambdabot> (a -> b) -> [a] -> [b]
21:45:36 <MarcelineVQ> :t (+3)
21:45:37 <lambdabot> Num a => a -> a
21:45:38 <MarcelineVQ> > map (+3) [1,2,3]
21:45:40 <lambdabot>  [4,5,6]
21:46:23 <MarcelineVQ> (a -> b) is a function you apply [a] is a list of items of a type that (a->b) will accept
21:46:45 <MarcelineVQ> applying (a->b) to every one of the [a] items gets you a list of [b]
21:47:41 <MarcelineVQ> (+) takes two numbers, giving it one number already (+3) means it only needs one more number
21:47:44 <MarcelineVQ> :t (+)
21:47:45 <lambdabot> Num a => a -> a -> a
21:48:13 <MarcelineVQ> so instead of a -> a -> a it's  a -> a which conveneintly fits into the (a -> b) map takes
21:49:29 <MarcelineVQ> (a -> a) means is that whatever type you give the function to fill in the a value, it has to give you that same type back. (a -> b) means you can give a function a type and it can give you a different type back. a and b are called type variables
21:51:15 <MarcelineVQ> (a -> a) can fit an (a -> b) here, and fit map due to that. because a -> b means you can return different type from the function, but you don't have to.
21:51:23 * ski could walk through the mechanical type inference steps, but isn't sure yashinbasement would be much the wiser ..
21:51:55 * hackagebot concurrent-output 1.0.1 - handling concurrent output  https://hackage.haskell.org/package/concurrent-output-1.0.1 (JoeyHess)
21:52:26 * ski idly wonders what escape sequence MarcelineVQ's message was supposed to contain
21:52:36 <MarcelineVQ> italics :>
21:54:26 <ski> (on this end, it was presented as a negative `]')
22:03:17 <emmanuel_erc> well I just posted my first cabal package to github. It still has issues that need to be ironed out.
22:03:33 <lispy> emmanuel_erc: congrats
22:07:26 <emmanuel_erc> thanks lispy!
22:07:52 <lispy> emmanuel_erc: what does your package do?
22:09:05 <emmanuel_erc> This is my first  project, so adjust your expectations. I have implemented a machine learning algorithm, specifically a manifold learning algorithm.
22:09:32 <lispy> cool, it's nice to see people using haskell for machine learning
22:09:41 <emmanuel_erc> I would like for it to include other noteworthy algorithms in that research area (including my own creations).
22:10:18 <emmanuel_erc> For now, though I have posted to github to have a a friend take a look at it. It is forced me to arrange my code into modules.
22:10:27 <emmanuel_erc> Do you mind I post the link?
22:10:33 <lispy> go for it
22:11:16 <emmanuel_erc> https://github.com/emmanueldenloye/manifoldRNC
22:11:51 <lispy> BTW, I don't think you want to commit dist
22:12:03 <emmanuel_erc> It still doesn't work the way I expect it to. Also, it is barely optimized (the O2 flag is my rock)
22:12:05 <emmanuel_erc> Why is that?
22:13:05 <lispy> emmanuel_erc: Normally you don't commit the things the compiler generates
22:13:10 <lispy> and dist is sort in that category
22:13:34 <emmanuel_erc> Thanks for the information.
22:13:51 <emmanuel_erc> I'll make sure to get rid of it on the next commit.
22:14:44 <emmanuel_erc> Are you looking through the files? I'm sure I've made a number of rookie mistakes.
22:15:02 <lispy> I'm glancing at it, but not reading deeply
22:15:06 <lispy> It's late here :)
22:15:21 <lispy> You use whitespace differently than me, but I wouldn't say it's bad
22:15:49 <lispy> Oh you might want to put something in the license file :)
22:15:53 <emmanuel_erc> I am happy/suprised that you are reading given the implication of the general activity on this IRC chat.
22:16:31 <lispy> I found something you can improve later
22:16:40 <emmanuel_erc> Oh...like what? I figured that putting it has the Public Domain license in the cabal file would be sufficient.
22:16:43 <pi___> is there a GHC pragma to existentially everything by default?
22:16:53 <lispy> in Main.hs you do some command line processing, and we have some nice libraries for that
22:17:05 <pi___> existentially quantify* that is
22:17:37 <emmanuel_erc> Should I be using the Text library?
22:18:06 <emmanuel_erc> The HMatrix library already came with a loadMatrix function and I thought none the wiser.
22:18:13 <lispy> emmanuel_erc: this is my personal favorite for command line processing: https://wiki.haskell.org/High-level_option_handling_with_GetOpt
22:18:38 <lispy> Well, text is for textual data.
22:19:25 <emmanuel_erc> Oh... well I am reading in text files with many lines (~1e3 - 1e4 lines)
22:19:48 <emmanuel_erc> but it is a one time operation and not the root of my speed woes.
22:20:23 <lispy> If you're reading a bunch of doubles/floats from a file then text isn't that important
22:20:35 <lispy> In that case you really just need a good lexer and a fast float parser
22:21:16 <emmanuel_erc> I mean there aren't any special cases when I am feeding the program the text... in my tests, I never really worried about it.
22:21:52 <lispy> I'm pretty lazy when it comes to optimizations. I usually wait until something is not fast enough, then a profile to find the hotspots, and optimize
22:22:05 <emmanuel_erc> The slowest part of my program is doing the quadratic interpolation for the last major step of the algorithm.
22:23:12 <lispy> emmanuel_erc: it looks like maybe cabal.sandbox.config shouldn't be committed. It has a bunch of paths into your local filesystem
22:24:02 <lispy> same goes for .cabal-sandbox
22:24:24 <moonchild> hi guys, i'm just stopping into the room for some insight, i'm a c++ dev starting to delve into lock free programming, and i know that isn't really the way haskell works, but i was wondering if people here could give me any insights
22:24:50 <lispy> emmanuel_erc: If you're moving things around, I like to put the source code under src, so the top level is like LICENSE, README.md, Setup.hs, foo.cabal, src
22:25:21 <lispy> moonchild: If edwardk was here he'd be able to talk to you about that. He's been looking into lock free algos lately.
22:25:29 <emmanuel_erc> I don't think I even need to really profile my code. My tests (as I was creating the code) would take around 4-8 secs. I was building a graph from 1600 points and doing nearest neighbor determination.
22:25:39 <moonchild> thanks, lispy
22:25:43 <lispy> np
22:26:07 <emmanuel_erc>  Thanks for the tip about the not commiting unecessary files.
22:26:11 <moonchild> i'm really just looking for some different ways of thinking about approaching problems
22:26:37 <lispy> moonchild: the only lock free stuff I know anything about is RCU in the linux kernel and even then I know almost 0.
22:26:56 <moonchild> i really do need to sit down and learn haskell, as it is (from everything i've seen) a very elegant language
22:27:30 <lispy> moonchild: not only that, but it's a gateway into lots of interesting topics in compsci
22:27:37 <moonchild> i could explain it at a high-level, but i don't think it would be appropriate for the room :)
22:27:50 * moonchild nods
22:28:34 <lispy> Haskell is a pretty good modeling language too. So if you're a grad student, professor, researcher, etc and you're reading a paper you can often make a toy version of the paper in Haskell to play with the ideas.
22:28:56 <moonchild> there's a lot of interesting ideas that are burgeoning up for the first time because the hardware now can support it, and just that our basis for coding is getting richer
22:30:06 <lispy> If you do a lot of systems programming and you want something closer to Haskell than you get with C/C++, then I highly recommend you checkout rust.
22:30:20 <lispy> It's kind of like C means ML
22:30:24 <lispy> meets*
22:30:30 <moonchild> also, unrelated to the question i just asked, and i don't want to take focus away from looking for writings on lock free algos...
22:31:33 <moonchild> since i'm here, and have been wanting to take a dive into haskell for a while, I've been looking for a programming problem that i could use as a vehicle for learning the language
22:32:02 <lispy> emmanuel_erc: Something else you could look at is travis-ci. It's a free service that works with github and can build/test your code on every commit.
22:32:50 <lispy> moonchild: I could suggest things that would be fun for me, but I have no idea if they would interest you :)
22:33:01 <emmanuel_erc> That's pretty awesome!
22:33:02 <moonchild> lispy, i'm really not interested in learning the dart/go/rust generation of languages, its just the same concepts as the 4gl langs packaged differently
22:33:20 <emmanuel_erc> Thanks for the tip lispy! 
22:33:43 <yashinbasement> https://gist.github.com/ynarwal/8d4f6ece5c1992952336 Hi, can you give some idea how would I approach to remove font_tag from HTML
22:33:44 <moonchild> i'm just looking for a practical problem that would allow me to sink my teeth into the lang
22:33:58 <kadoban> moonchild: Have you done other learning in haskell yet?
22:34:15 <moonchild> very little, tbh
22:34:22 <lispy> moonchild: I find it enjoyable to write small toy language implementations. I wrote a prolog to learn rust recently.
22:34:45 <moonchild> prolog != the language?
22:34:48 <nitrix> moonchild: I wrote a brainfuck interpreter and it helped me get going.
22:34:50 <kadoban> moonchild: I would suggest that you should get a good foundation before trying a project, IMO. Projects tend to be discouraging, because haskell is a /much/ different language than others you likely already know.
22:34:54 <lispy> moonchild: It's not really pratical though, as good prolog interpreters already exist
22:35:23 <kadoban> moonchild: https://github.com/bitemyapp/learnhaskell is a good recommendation, IMO.
22:35:29 <moonchild> yeah, well, i'm already ok in things like scheme
22:35:51 <nitrix> moonchild: The naive approach to a brainfuck compiler is great material, but then you also have optimizations possible to mutate arrays, modify states, combine similar operations, leverage lazy evaluation/memoization, so on.
22:35:52 <moonchild> thanks, i'll take that as a recomendation
22:36:05 <nitrix> moonchild: Please consider brainfuck too ! :)
22:36:16 <kadoban> moonchild: That will help, but scheme is still quite a different language than haskell. Some of the things you know will definitely apply though, which is nice.
22:36:21 <moonchild> dude, no, no funges
22:37:40 <moonchild> what i'm really looking for is a problem that showcases the languages strengths as well as helps me to learn more advanced features quickly
22:37:53 <lispy> doing an embedded DSL fits that
22:39:54 <moonchild> I have a few critical questions about the language that i'm curious to find an answer to
22:39:59 <kadoban> Haskell is pretty good at a lot of stuff. None of it I can really think of that's not going to be super frustrating without the basics though :-/
22:40:33 <moonchild> i'm wondering about performance of simple programs that do something like read a file line-by-line
22:40:57 <moonchild> ...for that type of thing does it compete with c++?
22:41:00 <lispy> ?faq Can Haskell have good performance reading a file line-by-line?
22:41:01 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
22:41:04 <lispy> doh
22:41:10 <lispy> Someone changed that
22:41:27 <lispy> moonchild: the answer is yes
22:41:44 <lispy> You just have to use the right library, but you can still do it without gross hacks
22:41:57 * hackagebot nationstates 0.5.0.0 - NationStates API client  https://hackage.haskell.org/package/nationstates-0.5.0.0 (ChrisWong)
22:42:06 <moonchild> i've found that a lot of the 5gl langs can give good perf on stuff like that, but you have to discount the runtime startup cost
22:42:26 <lispy> https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=ghc&lang2=gpp
22:43:09 <moonchild> is haskell ghc the defacto impl?
22:43:18 <lispy> yes
22:43:22 <moonchild> or is it some research branch of the compiler
22:43:36 <lispy> Those aren't mutually exclusive, are they?
22:44:36 <kadoban> moonchild: It's pretty easy to do IO quickly in haskell, at least within a close constant factor is effortless. And yeah GHC is what basically everybody uses.
22:45:04 <moonchild> no, but i learned to program in the late 90's, back when there was an egcs fork of gcc, and there was a great disparity btw sides of the fork
22:45:37 <kadoban> (Just a side note: using String is pretty slow, Data.Text is fast. Data.ByteString is fast for non-text)
22:46:12 <moonchild> for the binary tree benchmark on that page, is there any way to get a high-level explanation of what they were timing?
22:46:42 <lispy> moonchild: ghc is active research with multiple conference papers each year explaining new bits about it, but it's also one of the most robust open source projects I know. It's well built and well maintained.
22:46:56 * moonchild nods
22:47:09 <lispy> http://benchmarksgame.alioth.debian.org/binarytrees-description.html
22:47:11 <kadoban> moonchild: https://benchmarksgame.alioth.debian.org/binarytrees-description.html
22:47:22 <lispy> I got there from clicking on binary trees and then task description
22:48:22 <moonchild> i figured that would take me to code :P
22:49:10 <moonchild> one last question about the tree benchmark
22:50:49 <moonchild> i understand that classical data structures like binary (redblack, avl, splay, etc) aren't really well suited to functional languages, were there any modifications to the classical algos performed to make them look more like a finger tree or something else more functionally friendly?
22:51:24 <lispy> The benchmark game requires entries to be very similar so you can't really do things idomatically
22:51:40 <moonchild> gotcha
22:51:46 <kadoban> moonchild: They're actually kind of ridiculously nice in functional languages, and haskell in particular. I'm not sure why you think that.
22:52:10 <lispy> In general, yes there are pure versions of those classic structures. Look up okasaki's book, for a good reference
22:52:19 <nolrai66> Because naively you can end up re-rebalencing them, IIRC.
22:52:30 <kadoban> moonchild: Implementing a couple of those is a fun exercise, and really not hard or unwieldy at all.
22:52:37 <moonchild> kadoban, i'm not thinking anything, tbh, just trying to dispell some preconceptions i may have
22:53:02 <lispy> moonchild: this book: http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
22:53:07 <lispy> You can probably find a pdf if you tried
22:53:29 <moonchild> thanks
22:53:32 <kadoban> That book is really nice ^. The thesis he based it on is available free as well, though I imagine it's not as nice as the book.
22:54:17 <moonchild> the signal-to-noise ratio is probably a bit lower :)
22:55:04 <lispy> moonchild: hopefully that answers some of your questions. I need to afk a bit, but ask away if you have more Qs
22:55:43 <moonchild> thanks so much for your answers, and i hope i haven't seemed like i've been trolling, i'm just curious
22:56:18 <kadoban> Not at all, and happy to help of course. Keep any questions coming (though I'll be sleeping soon :)
22:56:44 <moonchild> me too
22:57:16 <moonchild> really i'm right now just looking to solve a problem involving lock-free programming
22:57:50 <moonchild> i was hoping to have some better luck here than in the c++ rooms
22:58:02 <Profpatsch> Why is concat defined as concat = foldr (++) [] ?
22:58:08 <Profpatsch> Why not foldl'?
22:59:18 <kadoban> Profpatsch: Because it's nice if concat gives early answers. In particular foldl' would have to traverse the whole list before you could get the head of the result (and wouldn't work at all on infinite lists).
22:59:22 <srhb> Profpatsch: foldl' should only be used when you fold with an operator that is strict in its right answer
22:59:25 <srhb> er
22:59:27 <srhb> argument
22:59:43 <Profpatsch> Ah, I see.
22:59:45 <srhb> ie. when you can't avoid traversing the entire structure anyway
22:59:54 <srhb> When you CAN avoid it, you use foldr to preserve laziness.
23:01:08 <lispy> moonchild: Not trolling at all. Welcome to Haskell, and I hope you stick around and try it out :)
23:01:12 <moonchild> does haskell distribute the computation of continuations/co-routines between multiple hw threads?
23:01:54 <nitrix> Hi, would someone be kind enough to explain to me the big lines of why Standard ML's module system has supposedly better points than Haskell's and what those points are?
23:02:12 <nitrix> Either I lack the knowledge necessary or my Google-fu isn't good enough.
23:02:24 <srhb> nitrix: Try to search for ML functors vs Haskell functors
23:02:49 <nitrix> srhb: I can do that. So one of the big points are functors?
23:03:07 <srhb> nitrix: That would be my claim at least. :)
23:03:41 <nitrix> How does functor play a role in the module system, I wonder.
23:03:52 <nitrix> But I'll take your words for it :)
23:04:02 <srhb> nitrix: It more or less allows you to parameterize modules over types
23:04:11 <kadoban> moonchild: I'm not sure I really understand the context of the question, but: not really, unless you tell it to. There's libraries and stuff that will help you make code parallel, but it's not just magically done. If that answers anything.
23:04:21 <srhb> nitrix: But I don't have time to go into detail, and I probably wouldn't be very good at it either. :)
23:04:47 <nitrix> srhb: No worry, I don't plan on being a burden either. The cue's enough. Thanks.
23:05:48 <emmanuel_erc> hey lispy, do you think I should post  my code to the haskell subreddit?
23:05:48 <moonchild> kadoban, it does
23:05:54 <moonchild> thanks
23:07:37 <kadoban> Some of the fundamental things about the language make it … a bit easier theoretically to evaluate things in parallel, so it's quite a bit nicer doing it in haskell than it would be in several other languages, but it still requires explicitly asking for it to be done.
23:08:18 <quicksilver> is any of the popular haskell parsers lazy? producing parses productively and signalling errors late?
23:10:07 <lispy> nitrix: ML's module system is better at implementation polymorphism
23:11:14 <lispy> emmanuel_erc: You're totally welcome to do that. There are rules on reddit about self-promotion, but they don't apply unless you post a lot of your own stuff.
23:11:50 <lispy> nitrix: The Haskell backpack is an extension aimed at closing the gap in this regard
23:12:44 <Cale> quicksilver: Usually in any case where you'd want something like that, you'd apply a strict parser for a small chunk of input repeatedly
23:12:56 <Cale> I'm not sure if it's possible to do much better in general
23:15:23 <jg> hi all. How do i check which version of a package is actually installed inside of a stack project?
23:15:42 <quicksilver> Cale: malcolmw's polyparse does it.
23:16:28 <quicksilver> Cale: given a parse for data Foo = Foo [Bar] [Baz], I want to be able to calculate or transform without first inherently loading and parsing everything
23:16:47 <quicksilver> Cale: naturally only some grammars are amenable to this.
23:16:57 <jg> oh, seems stack list-dependencies does what i want
23:17:10 <quicksilver> Cale: but, in particular, grammars with restricted backtracking (like parsec!) quite often...
23:50:32 <jg> i want to build a writer-state monad so i can have state and accumulate some results in my conduit. What should i use? RWS?
23:54:35 <jg> okay, i found this helpful: https://wiki.haskell.org/All_About_Monads#Managing_the_transformer_stack
