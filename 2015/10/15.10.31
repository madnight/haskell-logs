00:00:17 <kras> I am realizing how easy it is to build a compiler for any language in Haskell
00:00:47 <HEGX64> Even befunge?
00:00:56 <jle`> compilers is apparently haskell's "killer app"
00:01:16 <HEGX64> and parsers
00:02:14 <kras> I have spent months struggling with lex/yacc 
00:02:30 <kras> and I could reach the same point using parsec in a few weeks
00:02:36 <emmanuel_erc> alright guys, my dogs are beat.
00:02:43 <emmanuel_erc> goodnight all!
00:02:50 <Adeon> I got some whoahs when I used the ad package to get gradient descent out of thin air
00:02:50 <emmanuel_erc> //leave
00:03:32 <jle`> Adeon: wait, did you mean that you worked in the ad industry as in, the automatic differentiation industry?
00:03:38 <Adeon> no, advertisement
00:03:45 <jle`> okay, thought so
00:03:47 <Adeon> different ad :-)
00:03:49 <jle`> but then you mentioned using the "ad package"
00:03:56 <jle`> heh, all is clear now
00:07:41 * hackagebot stripe-haskell 2.0.1 - Stripe API for Haskell  https://hackage.haskell.org/package/stripe-haskell-2.0.1 (DavidJohnson)
00:07:41 * hackagebot stripe-http-streams 2.0.1 - Stripe API for Haskell - http-streams backend  https://hackage.haskell.org/package/stripe-http-streams-2.0.1 (DavidJohnson)
00:15:19 <John[Lisbeth]> From what I understand this is what I need: https://downloads.haskell.org/~ghc/6.4/docs/html/building/sec-porting-ghc.html
00:15:43 <John[Lisbeth]> Instead of trying to rewrite GHC in the IL primitives, I can try to port it to IL as an architecture
00:51:56 <Kristler> How come "quickCheck ((\x y -> x == y) :: Eq a => a -> a -> Bool)" works in ghci, but not when I run it from a file?
00:55:25 <Phyx-> Kristler: defaulting, entering it in ghcu will cauze the type to default to a specific type , so quickcheck knows what to check
00:55:52 <Kristler> I see
01:00:15 <Kristler> Thank you Phyx-!
01:02:22 <ng420> Hi! I'm trying to take up haskell for competitive programming. I know basic haskell, where can I find helpful resources like implementation of basic algorithms, techniques for graph, Dynamic Prog. etc? Thanks. 
01:13:09 <jle`>  hm, my naive type system for a language i'm writing automatically allows impredicative types.  is there something about impredicative types that i should be worried about...should i expressly forbid them now to avoid headaches down the line?
01:57:39 * hackagebot imperative-edsl-vhdl 0.2 - Deep embedding of VHDL programs with code generation.  https://hackage.haskell.org/package/imperative-edsl-vhdl-0.2 (mararon)
02:07:39 * hackagebot imperative-edsl-vhdl 0.2.0.1 - Deep embedding of VHDL programs with code generation.  https://hackage.haskell.org/package/imperative-edsl-vhdl-0.2.0.1 (mararon)
02:14:46 <jg> i'm having trouble getting my monad stack to work: http://lpaste.net/144322 . I'd like to get the result the writer monad there  
02:21:50 <Adeon> jg: I think you need to unwrap ResourceT there before you unwrap WriterT with runWriterT
02:24:50 <Adeon> flip evalStateT newParagraphState $ execWriterT $ runResourceT ... probably or something like that
02:31:53 <jg> thanks Adeon! still wrapping my head around transformers
02:34:07 <jg> also, is there a version of 'Show' for Text?
02:34:27 <jg> or should i cast to String?
02:35:55 <Adeon> AFAIK there is no function to Show things to Text
02:36:00 <Adeon> but it's pretty easy to implement
02:36:01 <Flonk_> What Haskell tutorials should I recommend to a beginner? I've learned Haskell with lyah but apparently some people in here aren't too fond of it
02:36:27 <Adeon> showT thing = Data.Text.pack $ show thing
02:36:52 <Adeon> or just showT = Data.Text.pack . show
02:36:57 <martinvlk> Flonk_: http://haskellbook.com/progress.html
02:36:58 <jg> ah, nevermind. There's a putStrLn for Text ;)
02:37:10 <jg> that was the main reason i was looking at show
02:37:14 <martinvlk> It's not a tutorial, but it's great
02:37:51 <Flonk_> martinvlk: I'll check it out, thanks :)
02:37:56 <martinvlk> yw!
02:39:06 <lamefun> So is this package https://hackage.haskell.org/package/text-show-2.1.1 bad/unrecommended?
02:39:48 <jg> just found it too. Looks like it solves my problem
02:40:55 <John[Lisbeth]> What are the mathmatical proofs for how ( and ) work
02:41:16 <John[Lisbeth]> as in function1 (function2 (function3))
02:41:46 <mauke> ???
02:42:13 <Flonk_> John[Lisbeth]: parentheses just help you not mess up your order of operations, what do you mean exactly?
02:42:41 * hackagebot signals 0.2.0.1 - Synchronous signal processing for DSLs.  https://hackage.haskell.org/package/signals-0.2.0.1 (mararon)
02:42:43 * hackagebot JuicyPixels 3.2.6.2 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  https://hackage.haskell.org/package/JuicyPixels-3.2.6.2 (VincentBerthoux)
02:47:09 <John[Lisbeth]> So you mean it makes absolutely no difference if you use parentheses or not?
02:48:17 <mauke> ???
02:50:23 <John[Lisbeth]> Flonk_, said that it makes no difference where parentheses are
02:50:47 <John[Lisbeth]> But I believe that parentheses serve a purpose when how you want a function to work goes against the order of operations
02:50:55 <Flonk_> John[Lisbeth]: no, but you can always write your code in such a way that you don't need parentheses. (a+b) * c can be written as let ab = a+b in ab * c, for eaxmple
02:50:59 <mauke> that's not what Flonk_ said
02:52:02 <John[Lisbeth]> to me let in is a copout
02:52:27 <Flonk_> a copout what from?
02:52:41 <Flonk_> They're not a special mathematical symbol or something, they just help you write code
02:52:43 <John[Lisbeth]> I like to program in an order of operationsas if I am doing algebra
02:53:08 <John[Lisbeth]> That's why I like haskell, is because there is an order of operations to things
02:53:48 <Flonk_> Sure, but sometimes you need to break that, so you need parens O_o
02:54:01 <John[Lisbeth]> Yes
02:54:08 <Flonk_> The standard order of operations is also just convenience so you don't have to write too many parentheses
02:54:11 <John[Lisbeth]> I am asking what the math behind parentheses are
02:54:30 <John[Lisbeth]> I'm trying to get at the core of haskell compilation
02:54:37 <John[Lisbeth]> cause I want to steal some of the code for my toy compiler
02:54:56 <John[Lisbeth]> I know at the heart of it is lambda calculus
02:54:57 <mauke> what does math have to do with compilation?
02:55:01 <Flonk_> John[Lisbeth]: read up on abstract syntax trees then
02:55:36 <Flonk_> There's no maths behind parens, they just tell you how to evaluate the formula you have lying in front of you
02:56:22 <John[Lisbeth]> the real reason Is I am trying to get a haskell-like syntax compiling to IL so that I can use .net
02:57:20 <John[Lisbeth]> The guys in C# keep saying that F# is what i want, but when I investigate F# more closely, it isn't the type of functional language I have come to expect
02:57:28 <John[Lisbeth]> for example you have to use a special syntax to make functions recursive
02:57:41 * hackagebot signals 0.2.0.2 - Synchronous signal processing for DSLs.  https://hackage.haskell.org/package/signals-0.2.0.2 (mararon)
02:57:43 * hackagebot sdl2 2.1.0 - Both high- and low-level bindings to the SDL library (version 2.0.3).  https://hackage.haskell.org/package/sdl2-2.1.0 (OliverCharles)
02:57:54 <mauke> if it's like ocaml, the syntax is to make bindings recursive, not specifically functions
02:58:03 <John[Lisbeth]> yes
02:58:06 <mauke> that is, haskell's "let" corresponds to "let rec"
02:58:41 <John[Lisbeth]> It is confusing to me why they would make a "let rec" without the rec
02:58:46 <John[Lisbeth]> the rec should be implied
02:59:04 <mauke> in ocaml you can do things like 'let x = x + 1 in ...'
02:59:38 <mauke> in haskell people do things like 'let x' = x + 1; x'' = foo x' in ...'
02:59:49 <John[Lisbeth]> There's a couple of implementations of GHC for .net
02:59:52 <mauke> just adding ticks or numbering their variables (x1, x2, x3, ...)
03:00:05 <John[Lisbeth]> one of them is Salsa, and the other is hs-dotnet
03:02:27 <earthy> salsa doesn't allow interaction with generics in .net. big fail.
03:07:13 <John[Lisbeth]> I am trying to explain to the guys in C# the reason why the syntax in haskell is so important to me
03:07:16 <John[Lisbeth]> but it is hard to express
03:07:43 <John[Lisbeth]> It is hard to explain that in haskell you define what you want done and not how you want to do it.
03:08:27 <John[Lisbeth]> Especially the desire to design recursively
04:23:32 <statusfailed> Are there any examples showing how to use websockets with servant? 
04:24:22 <statusfailed> oh i'll go to the servant channel actually
04:44:40 <pyon> Is there a shorter way to do this? http://lpaste.net/144334
04:57:28 <int-e> > let mono xs = [(z,ys++zs) | ys <- inits xs | z:zs <- tails xs] in mono [1,2,3]
04:57:30 <lambdabot>  [(1,[2,3]),(2,[1,3]),(3,[1,2])]
05:07:46 * hackagebot rdf4h 1.3.4 - A library for RDF processing in Haskell  https://hackage.haskell.org/package/rdf4h-1.3.4 (RobStewart)
05:07:48 * hackagebot hsparql 0.2.7 - A SPARQL query generator and DSL, and a client to query a SPARQL server.  https://hackage.haskell.org/package/hsparql-0.2.7 (RobStewart)
05:08:46 <Eliel_> int-e: I'm not sure if I'd call that shorter but it's definitely easier to understand :)
05:13:41 <ggVGc> what problems are there with hot swaping for pure languages like haskell? It seems like a very straightforward thing to me, given some basic constraints like you can't change data types or function declarations
05:13:59 <ggVGc> recompiling and reloading individual function implementations should be very easy?
05:18:36 <Eliel_> ggVGc: it depends on how heavy use the codebase in the original language makes of mutability.
05:18:49 <srhb> I'm also not sure the premise is really true.
05:19:32 <bennofs> ggVGc: well, the function that you changed might be inlined into any number of other functions in different modules/packages
05:19:38 <ggVGc> Eliel_: but in a pure functional language like haskell, there's no mutability outside monads, so we should just be able to hot swap function implementations?
05:19:46 <bennofs> ggVGc: so you have to find all these places and recompile them too
05:20:32 <ggVGc> bennofs: yeah, but it's not necessary to have optimizations on. If running in "hot swapping mode", it would be an okay tradeoff I think to not have inlining in order to enable hot swapping
05:21:09 <bennofs> ggVGc: I'm not sure if that's practicable. I believe most code will be *really* slow if there is no inlining. Inlining is pretty crucial for GHC performance
05:21:15 <int-e> Laziness will pose challenges (you'll have code fragments floating around that resume computation from the middle of a function); also I suspect you'll have to design a system for doing hot-swapping from the very beginning and track a meta-information like types (ghc, for example, erases a lot of type information at runtime...)
05:21:41 <Eliel_> ggVGc: I suspect you'd want to have a list of functions that are specifically meant for inlining and thus unswappable.
05:21:49 <Eliel_> and no inlining for anything else.
05:22:35 <int-e> Otoh there is Erlang, which does support hot-swapping. AFAIU, it's a pure and strict functional language at its core.
05:22:52 <Eliel_> although, it'd probably be easier to just be able to annotate in advance the functions you want to be hot-swappable.
05:23:11 <Eliel_> and keep inlining rules the same for everything else.
05:23:20 <bennofs> Eliel_: then that's also easier. just wrap the functions themselves to check if they should hotswap
05:24:07 <Eliel_> bennofs: ah, that also works as the implementation. Great :)
05:24:09 <bennofs> Eliel_: like:   hotswappableFunction = when <new version available> then <load new version + cache>;  ==> call loaded / cached function
05:24:49 <bennofs> That should be quite simple to implement (perhaps using TemplateHaskell?)
05:25:30 <bennofs> it's just a plain old plugins system :p
05:33:38 * hackagebot aws 0.13.0 - Amazon Web Services (AWS) for Haskell  https://hackage.haskell.org/package/aws-0.13.0 (AristidBreitkreuz)
05:39:30 <Jorgeoliv1> hi
05:39:34 <Jorgeoliv1> I need some help
05:41:41 * hexagoxel opens help bin, takes some out, hands it to Jorgeoliv1 
05:41:52 <hexagoxel> yw!
05:45:23 <pyon> Is there anything paredit-like for haskell-mode?
05:46:53 <hc> hi, I'm trying to implement a haskell module that uses "callbacks"
05:47:08 <hc> i'm wondering whether it's possible to allow these callbacks to carry some state between calls
05:47:30 <narendraj9> What quantitative finance library is most popular or mature or good (if any)?
05:47:36 <hc> if possible, of any type of their choosing. so the calling functions should just pass around the state from one call to the next... i'm not sure how to handle the types
05:48:29 <narendraj9> Obviously I am talking about Haskell libraries. I found quantfin only.
05:49:46 <E4xoi> hc: you can use StateT or IO
05:49:58 <cocreature> pyon: structured-haskell-mode comes closest
05:50:05 <cocreature> https://github.com/chrisdone/structured-haskell-mode
05:50:48 <hc> E4xoi: i'd prefer to avoid using IO, so that leaves statet. i could even pass states around explicitly. but that would still leave me with the problem on how to define the types...
05:51:38 <lpaste> hc pasted “callbackdef” at http://lpaste.net/144337
05:51:58 <hc> E4xoi: that's the way the callbacks are defined... Callback is already an instance of StateT but for other reasons...
05:52:13 <hc> now i would like to use different implementations of the callbacks with possible different types of state
05:53:00 <E4xoi> do you want every 'callback
05:53:15 <E4xoi> ' to carry its own state?*
05:53:27 <hc> all callback functions for a specific implementation should share one state
05:53:39 <E4xoi> or a global shared state between them
05:54:23 <hc> well let's say there are three implementations... each would have to implement 'callback1' and 'callback2'... so the state should be shared between callback1 and callback2 for a specific implementation
05:54:34 <E4xoi> oh, ok, you can parametrize the s and then carry it down to Callback(s), etc
05:54:34 <hc> but each of the three implementations should be able to define their own state type
05:55:09 <E4xoi> do you have your current definition of Callback?
05:55:39 <hc> yeah, it's type Callback a = CMTSS.StateT SpawnpointState Process a
05:55:50 <hc> but that StateT is used for a different purpose...
05:56:10 <hc> because the caller that handles the callbacks also needs to store its own state...
05:57:37 <hc> the callbacks can call functions that alter the state of the caller... so i need two states... one for the caller, that can also be altered by the callbacks, and one by the callee, that is private to the specific callback implementation
05:58:13 <pyon> cocreature: Thanks, will have a look. :-)
05:59:00 <aweinstock> :t let sharedMutableState = newIORef 0 in (readIORef sharedMutableState, writeIORef sharedMutableState 5)
05:59:01 <lambdabot>     Not in scope: ‘newIORef’
05:59:02 <lambdabot>     Perhaps you meant ‘newSTRef’ (imported from Data.STRef)
05:59:02 <lambdabot>     Not in scope: ‘readIORef’
05:59:26 <aweinstock> :t let sharedMutableState = Data.IORef.newIORef 0 in (Data.IORef.readIORef sharedMutableState, Data.IORef.writeIORef sharedMutableState 5)
05:59:28 <lambdabot>     Couldn't match expected type ‘GHC.IORef.IORef a’
05:59:28 <lambdabot>                 with actual type ‘IO (GHC.IORef.IORef Integer)’
05:59:28 <lambdabot>     In the first argument of ‘GHC.IORef.readIORef’, namely
05:59:29 <hc> i'd like to avoid anything that uses IO if possible ;-)
05:59:31 <Eliel_> hc: remember how State monad works, there's a runState function that takes the state operation as the first parameter and the initial state as the second.
06:00:05 <Eliel_> and runState is completely generic as to the type of the initial state.
06:00:24 <Eliel_> so whatever you pass in there, is the type your functions will get as input.
06:00:35 <E4xoi> hc: well, I have a few ideas, one is wrapping and hiding the details of the implementation, the other would be to use runState(T) and pipe the state manually
06:01:03 <aweinstock> hc: if you have 2 callbacks that need to communicate, making "type Callback a = a -> IO ()" seems like a pretty flexible/simple way
06:01:18 <E4xoi> aweinstock: too much freedom
06:01:23 <hc> the callbacks don't need to communicate
06:01:38 <Eliel_> hc: also, runState returns the modified state in the end.
06:02:06 <E4xoi> hc: what are the callbacks for?
06:03:11 <Eliel_> hc: so, all you need to do is to make the initial callback state a part of the state for the layer that actually calls the callbacks.
06:03:13 <freinn> hi! I have a problem with MonadPlus, the code and the error are here http://lpaste.net/144338
06:03:40 <E4xoi> for a toy IRC library, I was thinking about cooperative threads that yield while calling certain primitives
06:04:01 <hc> E4xoi: each implementation of the callbacks represents a specific class of actor in a game... like if you know the unreal engine you have an implenmentation of the Actor class for each kind of npc in the game
06:04:41 <hc> E4xoi: so there are functions to alter the "global" state of the world... but each actor needs to keep track of some internal state as well
06:05:08 <hc> i used to use hslua for that and it worked just fine. now i'm trying to replace lua with haskell ;-)
06:07:02 <Eliel_> hc: so, in other words, you only need a subset of the things hslua does.
06:07:10 <E4xoi> hc: ehm, I don't know a nice way, would use ST or IO though, so you have truly mutable variables
06:07:48 <hc> maybe there is a better way to define a set of callback functions in haskell than the one i'm using?
06:08:01 <hc> like defining a typeclass... i'm not that proficient in haskell yet
06:08:21 <hc> Eliel_: no, i do need the complete turing completeness of lua ;-)
06:08:44 <Eliel_> hc: yes, but you don't need to script interpreter part.
06:09:03 <Eliel_> you want to substite haskell functions for that.
06:10:13 <hc> lemme try and create a short lpaste with the relevant code
06:11:21 <E4xoi> Eliel_: I don't understand your point
06:11:40 <E4xoi> Eliel_: how is that related to his problem?
06:11:42 <aweinstock> :t newSTRef 0 >>= (readSTRef &&& flip writeSTRef 5)
06:11:43 <lambdabot>     Couldn't match type ‘(ST s Integer, ST s ())’ with ‘ST s b’
06:11:44 <lambdabot>     Expected type: STRef s Integer -> ST s b
06:11:44 <lambdabot>       Actual type: STRef s Integer -> (ST s Integer, ST s ())
06:12:16 <aweinstock> :t fmap (readSTRef &&& flip writeSTRef 5) (newSTRef 0)
06:12:18 <lambdabot> Num a => ST s (ST s a, ST s ())
06:12:57 <E4xoi> that isn't really useful, though, missing a lot of things
06:13:08 <hc> tried to sum it up here: http://lpaste.net/144339
06:13:14 <nshepperd> Blast this network
06:13:34 <Eliel_> E4xoi: He wants to replace hslua interpreter with haskell code for scripting, yes? In that case, looking at hslua and seeing what parts of it he needs to implement could be quite useful. The structure already does the thing he needs.
06:14:06 <hc> Eliel_: the problem is that (hs)lua isn't typesafe. without type safety i could easily "solve" that problem, yes
06:14:41 <E4xoi> Eliel_: he is using IO too, and offload quite a lot of work to lua
06:14:57 <E4xoi> offloading*
06:16:09 <Eliel_> hc: yes, but I think you'll find that what you need is what's left of hslua if you remove all the Lua stuff and keep the high level data structure.
06:17:02 <jgonera> hm, haskell is complaining that i used 'tagCount' as the name of the field for two _different_ records. Why? http://lpaste.net/182098109315153920
06:18:03 <Eliel_> jgonera: you've specified tagCount as the accessor function in 2 different datatypes.
06:18:52 <Eliel_> jgonera: you can't reuse the same function name twice in the same namespace in haskell.
06:19:23 <hc> Eliel_: i don't think so. when using lua the haskell compiler/runtime system wasn't even aware that there was some stated shared between two calls to a specific callback because it was handled in C
06:19:38 <jgonera> riiight, those get converted to accessor functions
06:20:21 <Eliel_> jgonera: if you absolutely need tagCount for both, you could use a typeclass though.
06:20:23 <hc> is this way of definind "callback" functions even a good idea in haskell? maybe there's a better way to do things that i'm not aware of?
06:21:16 <aweinstock> hc: IO will let you do it the same way that lua does it (I think)
06:21:52 <hc> i don't want to use IO, or i'd stick with lua
06:21:53 <aweinstock> hc: just make the callbacks that need shared state closures over a mutable reference
06:22:30 <aweinstock> in lua, everything's in IO, but even if you don't want to use IO, you can probably use ST with a bit of restructuring
06:22:55 <hc> just how do i design my types, that's what i'm trying to figure out :-)
06:23:04 <aweinstock> (I don't understand why you don't want to use IO, since that's what you're already doing)
06:23:06 <Eliel_> hc: as far as I'm aware, defining a Monad for the callbacks is a pretty standard way of doing it. Then you can write all the callback functions and whatever functions they need in that monad and combine them easily.
06:23:31 <hc> yeah, that's what i am doing. and it wouldn't be a problem if there was only one implementation of the callbacks
06:23:39 <hc> i'd simply provide a "get" and a "put" function...
06:23:54 <hc> *but*: there are several implementations, and each get and put would have to accept a different type
06:23:59 <hc> and i don't know how to do that
06:25:06 <hc> i mean i am aware of the get and put functions of the state(t) monad... i've tried to describe the problem in the code extract i've pasted
06:25:33 <narendraj9> nshepperd: Any quant trading stuff in Haskell before we blast this network? :-D
06:26:04 <^elyse^> I'm reading https://wiki.haskell.org/Physical_equality. It says "Even though === implies == except for bottom"
06:26:16 <^elyse^> However, I think this is incorrect if both arguments are NaN.
06:26:26 <Eliel_> hc: What does the local state contain in each object currently manipulating that state through lua?
06:26:39 <hc> Eliel_: different for each object
06:26:52 <Eliel_> hc: is that what's causing the problem?
06:27:07 <hc> Eliel_: each kind of object needs its own kind of state, that's the problem
06:27:15 <hc> i don't know how to express that with haskell's typesystem
06:27:27 <Eliel_> hc: you can solve it with a type that can express them all.
06:27:40 <hc> yeah but how?
06:27:44 <hc> could you amend the code i've pasted?
06:27:49 <hc> http://lpaste.net/144339
06:28:12 <Eliel_> hc: I'll try to find you an example of what I mean.
06:28:14 <aweinstock> > (1/0)
06:28:15 <lambdabot>  Infinity
06:28:20 <aweinstock> > (0/0)
06:28:22 <lambdabot>  NaN
06:28:26 <aweinstock> > (0/0) == (0/0)
06:28:27 <lambdabot>  False
06:29:43 <nex> morning, getMovieList (Producer _ mylist) = mylist) where mylist is 'type aList = [Movie]' but if I do (getList derp) ++ [(new movie..)], I get "Couldn't match expected type ‘IO ()’ with actual type ‘[Movie]’" .. why ?
06:30:11 <nex> i'm just trying to append something to a list 
06:31:31 <srhb> nex: One of your types is not what you expect it to be. Could you paste the actual code on lpaste.net ? It's a little hard to figure out from your example.
06:33:00 <E4xoi> hc: you can use existential types for hiding that state
06:34:29 <Eliel_> hc: you can define a datatype like: data Generic = GenericNULL | GenericInteger Int | GenericString String | GenericDouble Double | ...
06:34:43 <Eliel_> and then functions that pattern match on the exact contents.
06:35:14 <Eliel_> and do different things depending on the actual data.
06:35:37 <hc> E4xoi: okay, i'm going to try that and see how far i get. thanks! :)
06:35:55 <hc> Eliel_: that's working around the problem, not solving it ;-)
06:37:45 <Eliel_> hc: I guess I didn't understand the problem then.
06:40:27 <TorosFanny> How to use Hoogle with local html files generated with haddock ?
06:41:16 <hc> Eliel_: maybe i didn't explain it well... it's really not so easy to explain though
06:42:41 <hc> E4xoi: unfortunately existential types don't work... because i still need to implement my own getState and putState functions which doesn't work with existential types
06:42:54 <hc> i think i'll just postpone solving this and use some IO as a hack in the meantime
06:43:30 <Eliel_> hc: anyway, to me it seems more like you need a Domain Specific Language for the objects in the "world" of yours than callbacks. And if you have that, callbacks kind of follow naturally by embedding the Monad that implements the DSL
06:44:14 <hc> Eliel_: a dsl yeah... but i'd still need some state keeping even then, right?
06:44:30 <hc> i mean a dsl basically transforms to "normal" haskell code while compiling, no matter how you implement it
06:44:57 <Eliel_> hc: yes, I don't think you can have a DSL without state. It kind of comes with the package.
06:45:33 <Eliel_> so I suspect if you can find a simple example of a DSL monad, it'd perhaps help you
06:45:45 <hc> okay i'll look into it, thanks!
06:45:55 <hc> i'll let you now if i find a solution to all this
06:46:03 <hc> thanks for your patience
06:47:24 <JagaJaga> Is there a way to tell stack use system installed libs?
06:51:49 <E4xoi> hc: I will be online tonight and I'll be able to look at your problem with more time, if you are free (in 8/10 hours), we might be able to get something workinh
06:59:45 <sternenseemann> Hello
06:59:59 <sternenseemann> How could I write such an Parser more elegantly? http://lpaste.net/144341
07:00:22 <sternenseemann> I want that the parser fails if there is no match
07:00:35 <sternenseemann> EmojiLevel is defined similarly
07:06:25 <MHD> How do I view the compiler options GHC was compiled with?
07:08:51 <MHD> How do I view the compiler options GHC was compiled with?
07:09:36 <srhb> MHD: I'm not sure there's such an option.
07:09:42 <MHD> damn
07:09:43 <MHD> ok
07:09:58 <MHD> How do I find out if my GHC supports PCRE?
07:10:21 <MHD> and if it doesn't, how do I fix that?
07:10:24 <srhb> MHD: What do you mean? In which way does GHC ever support PCRE?
07:10:46 <srhb> MHD: Or let me rephrase that: What are you actually trying to do?
07:10:56 <MHD> I want Pandoc
07:10:59 <MHD> from cabal
07:11:05 <MHD> so I can tinker with the highlighting
07:11:16 <MHD> since the pandoc from apt doesn't let me do that, from what I can tell
07:11:23 <srhb> MHD: Right, and what goes wrong when you try to build pandoc?
07:12:04 <MHD> OK, wat
07:12:09 <MHD> heisenbugged
07:13:02 <MHD> ok now I have the error
07:13:07 <MHD> I want to install highlighting-kate
07:13:15 <Eliel_> hc: this is probably a useful article to read http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
07:13:20 <srhb> Anyway, it sounded like what you wanted to do was cabal unpack pandoc and then fiddle with its source before cabal building it, in which case you might have needed a library that links to some C library for PCRE stuff. Usually, then, it's not a GHC problem but you need a library installed on your distro that the package with the pcre bindings can link against
07:13:48 <MHD> When building highlighting-kate
07:13:48 <MHD> regex-pcre-builtin-0.94.4.8.8.35 failed during the building phase. The
07:13:48 <MHD> exception was:
07:13:48 <MHD> ExitFailure 127
07:14:12 <srhb> MHD: Please paste longer things on lpaste.net. :) What you want to do in this case is install the library on your system to link against.
07:14:31 <MHD> I have libpcre3 and -dev
07:14:39 <MHD> I can compile C programs that use pcre
07:14:45 <srhb> MHD: OK, paste the entire build failure on lpaste.net then :)
07:15:01 <srhb> MHD: Mind, the libraries you're trying to install are ancient and probably not compatible with newer ghc/base versions
07:15:10 <srhb> MHD: You might have to bring them up-to-date.
07:15:27 <haskell200> I am new to Haskell and am completely lost in a sea of monads and other words. I want to learn more. Please help
07:15:40 <srhb> Though I suppose regex-base is quite stable, so maybe not.
07:15:44 <capisce> haskell200: start with functors
07:15:57 <srhb> haskell200: Pick a good introductory book/course and take things slow :)
07:15:59 <capisce> before you move on to monads
07:16:15 <MHD> srhb: The entire build failure http://pastebin.com/yZsPGxYd
07:16:30 <haskell200> capisce : where do I start on functors ?
07:16:38 <srhb> MHD: /usr/local/bin/hsc2hs: line 29: /usr/local/lib/ghc-7.10.2/bin/hsc2hs: No such file or directory
07:16:46 <tommd> Here, or one of the many tutorials.
07:16:49 <srhb> MHD: It's a build tool, so not installed automagically by cabal
07:16:54 <srhb> MHD: You'll have to do that manually.
07:17:02 <capisce> haskell200: for example here: http://learnyouahaskell.com/functors-applicative-functors-and-monoids
07:17:10 <MHD> hell I know what that error is
07:17:18 <srhb> MHD: Yes, you don't have hsc2hs :-)
07:17:22 <srhb> Or at least not in PATH
07:17:36 <MHD> srhb: no, I do, but I have  a broken symlink
07:17:42 <haskell200> capisce : Thanks !
07:17:43 <srhb> MHD: Same difference ;-)
07:18:09 <srhb> MHD: (Also hi to a possibly fellow dane Haskeller? :-))
07:25:32 <Satolein> Hello! I am struggling with installing leksah on fedora
07:26:25 <Satolein> dnf does only find leksah-server packages, but i am interested in the IDE.
07:33:34 <Satolein> can anybody hint me to how i get the ide?
07:40:08 <MHD> OK, I am officially done with this bs
07:40:24 <MHD> rm -rf ~/.cabal; apt-get remove haskell-platform
07:40:28 <MHD> bam
07:40:33 <MHD> do-over
07:43:02 <cjay> MHD: don't forget .ghc
07:43:11 <MHD> oh well
07:43:14 <MHD> I'll be damned
07:43:15 <MHD> thanks
07:43:18 <cjay> :)
07:46:26 <srhb> MHD: Haskell platform can make things messy. It's often simpler to start with just ghc and cabal-install and use sandboxes from there on.
07:46:39 <srhb> MHD: I don't think that was your problem though.
07:46:43 <MHD> nah
07:46:45 <MHD> just
07:47:07 <MHD> I realized I had spent 2 hours trying to get at the internals of Pandoc when I could just stub out the problem in my app
07:47:15 <MHD> The dependency chain went something like
07:47:34 <MHD> ruby app > pandoc > highlighting-kate
07:54:01 <Myrlevolent> Guys
07:54:03 <Myrlevolent> :: (a -> b -> c) -> (
07:54:04 <Myrlevolent> Oops
07:54:11 <Myrlevolent> What has this type? (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
07:54:42 <aweinstock> @djinn (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
07:54:42 <lambdabot> f a b c d = a (b d) (c d)
07:54:49 <aweinstock> @. pl djinn (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
07:54:49 <lambdabot> f = liftM2
07:54:57 <aweinstock> Myrlevolent: ^
07:55:00 <Myrlevolent> Oh cool.
07:55:05 <Myrlevolent> Thanks!
07:55:55 <aweinstock> liftA2 should also work
07:56:02 <aweinstock> :t liftA2
07:56:03 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
07:56:29 <aweinstock> :t liftA2 :: (x -> a -> b -> c) -> (x -> a) -> (x -> b) -> (x -> c)
07:56:30 <lambdabot>     Couldn't match type ‘c1’ with ‘b1 -> c1’
07:56:30 <lambdabot>       ‘c1’ is a rigid type variable bound by
07:56:30 <lambdabot>            an expression type signature:
07:56:46 <Myrlevolent> Yeah, I think liftA2's more appropriate.
07:56:57 <aweinstock> :t liftA2 :: (a -> b -> c) -> (x -> a) -> (x -> b) -> (x -> c)
07:56:59 <lambdabot> (a -> b -> c) -> (x -> a) -> (x -> b) -> x -> c
07:57:17 <Myrlevolent> Since I normally do `f <$> g <*> h`
07:57:32 <aweinstock> since ((->) x) is an Applicative Functor
07:57:49 <Myrlevolent> aweinstock: Yep.
07:58:09 <Myrlevolent> > [1..] :: [Float]
07:58:11 <lambdabot>  [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0...
07:58:20 <Myrlevolent> Hmmm
07:59:04 <Myrlevolent> TIL, Floating doesn't extend Ord.
07:59:54 <Myrlevolent> Rather, enum/.
08:13:44 * hackagebot opengl-dlp-stereo 0.1.2.6 - Library and example for using DLP stereo in OpenGL  https://hackage.haskell.org/package/opengl-dlp-stereo-0.1.2.6 (BrianBush)
08:35:12 <Myrlevolent> @pl (:) <$> head <$> map f . tail
08:35:12 <lambdabot> (:) <$> head <$> map f . tail
08:35:14 <Myrlevolent> Oops
08:35:19 <Myrlevolent> @pl (:) <$> head <*> map f . tail
08:35:20 <lambdabot> (line 1, column 26):
08:35:20 <lambdabot> unexpected "t"
08:35:20 <lambdabot> expecting space
08:35:20 <lambdabot> ambiguous use of a right associative operator
08:35:28 <Myrlevolent> @pl (:) <$> head <*> (map f . tail)
08:35:28 <lambdabot> (:) <$> head <*> (map f . tail)
08:35:34 <Myrlevolent> oh okay, thanks.
08:49:57 <zedbourbaki> hello :) i am starting a new project in haskell and I am planning on using matrices... what should I know before starting ? 
08:52:06 <bluezone> What do you guys think of this https://github.com/Frege/frege
08:54:02 <doismellburning> bluezone: I'm amused to note that I appear to have muted someone with the nick "frege" at some point it seems...!
08:54:15 <bluezone> lol
08:55:21 <bluezone> so many languages, so little time, and not clear what to learn
08:56:33 <icbm> Yeah, I'm learning both Haskell and Rust in parallel, due to not being able to decide between them.
08:57:30 <suppi> bluezone, totally.
09:01:57 <bluezone> icbm: How do you do this lol
09:02:12 <bluezone> I can barely focus on reading 10 pages of a book :(
09:02:24 <icbm> bluezone: Try to make the same app in both languages.
09:07:25 <elfeck> hi, I after coming back to a project I get this error in conjunction with Persistent: http://pastebin.com/Fqar607U
09:07:33 <elfeck> can someone tell me what this means?
09:08:31 <elfeck> I use "deriving show" for all my tables
09:11:25 <elfeck> nobody?
09:11:38 <johnw> have no clue
09:14:10 <glguy_> elfeck, You should show us the code, but chances are that you were doing generalizednewtype deriving and need to rewrite it to use standalone derving like the message says
09:15:31 <elfeck> http://pastebin.com/yxnydx6a
09:15:49 <glguy_> The other possibility is that you've got two versions of a library installed and you're using a dfiferent one than a package was compiled against
09:16:01 <elfeck> I dont know what standalone derving is
09:16:12 <elfeck> I did a fresh install and used a sandbox.
09:17:29 <elfeck> I use 2.1.* for persistent but that should not be an issue
09:22:01 <monochrom> happy halloween! have a pumpkin catmorphism: http://www.vex.net/~trebla/photo/unorganized/pumpkin-catmorphism.jpg
09:24:15 <hpc> hah
09:27:04 <geo2a> exit
09:27:15 <ackthet> classy
09:36:20 <glguy> elfeck: Your module loads for me, actually
09:37:01 <glguy> elfeck: So the problem probably has to do with the versions of things that you're using
09:38:29 <elfeck> I see
09:38:36 <elfeck> goddamn I hate this so much with haskell
09:39:00 <elfeck> I will try to use persistent >=2.2 and see if it fixes things
09:39:09 <elfeck> brb 10min dep compile D:
09:39:25 <elfeck> glguy, thanks for your input though 
09:41:47 <cmr> I'm whipping up a little graphical roguelike for a game jam and want a function that takes a list of tiles and filenames and creates a `HashMap Tile Graphics.Gloss.Data.Picture`. Of course, loadBMP to do that is FilePath -> IO Bitmap, and it seems pretty convenient to use fromList to create the map, so I end up doing an fmap on a [(Tile, FilePath)] to create a [(Tile, IO Picture)], but I can't figure out how
09:41:49 <cmr> to pull the picture out of that IO. If I could get a IO [(Tile, Picture)] I'd be happy I think, but I'm not sure how to do that.
09:42:17 <johnw> sequenceA . map sequenceA
09:47:45 <cmr> johnw: ah I see how that works, thanks!
09:49:46 <zedbourbaki> hello :) have anyone ever used hmatrix ?
09:50:51 <roelof> How can I make this work : http://lpaste.net/144349
09:51:33 <johnw> how is it not working now?
09:51:35 <glguy> roelof: Look at the type error you're getting on the last two lines
09:51:42 <c_wraith> roelof: you have to account for the fact that the recursive calls return a Maybe
09:51:46 <johnw> ah
09:52:14 <glguy> Also in general you should include the actual error you're having when you paste code for help
09:52:55 <roelof> c_wraith:  I know, But if I do the last two lines without the Just there is also a error 
09:53:28 <glguy> roelof: That's because you have multiple errors, but leaving off the Just is the first step
09:54:03 <roelof> this is the error now : http://lpaste.net/144350
09:54:43 <glguy> The error says you tried to multiply a  Maybe Integer  with an Integer
09:55:42 <roelof> and this is the error without the Just : http://lpaste.net/144351
09:55:51 <monochrom> "f2Maybe (n `div` 2)" is going to be something like "Just 128". now "(Just 128) ^ 2" does not make sense, does it?
09:56:04 <roelof> monochrom:  correct 
09:56:34 <monochrom> at the overarching level, you shouldn't be doing Nothing and Just like this.
09:56:42 <monochrom> you should write two functions.
09:57:09 <monochrom> f2Maybe n | n>0 = Nothing  | otherwise = Just (f2 n)
09:57:23 <monochrom> f2 will not use Maybe.
09:57:58 <monochrom> and I think "n>0" should be "n<0"
10:01:26 <Romefeller> Hello all
10:01:32 <hodapp> howdy
10:01:35 <mtesseract> Hi.
10:01:43 <Romefeller> =)
10:02:22 <roelof> monochrom:  thanks, this version is working : http://lpaste.net/144351
10:02:56 <roelof> now I can try to make a version which work with Iether String Integer so back to the books 
10:04:26 <breadmonster> Hey guys.
10:04:47 * hodapp toasts breadmonster
10:05:08 * breadmonster uhh apps (?) hodapp
10:05:35 <mtesseract> I don't know how to do the following in Haskell: I have a program whose main functionality is contained in a 'backend'. This backend gets enabled at compile time and provides certain functions, like backendFoo and backendBar to do Foo and Bar. Now, up to know my program is simply calling backendFoo and backendBar directly. But I would like to change this so that all these backend calls get wrapped in s
10:05:41 <mtesseract> ome other code (e.g., informing the user about a backend call, setting a flag in an IORef for the duration of the backend call, etc.). How can I do this in a clever way?
10:06:28 <mtesseract> I was thinking about defining a datatype BackendAction = BackendActionFoo ... | BackendActionBar ... containing all the parameters I need to pass to the backend functions and then defining a dipatcher function callBackend :: BackendAction -> ..., but the problem here is that backendFoo and backendBar might have distinct return values.
10:06:34 <mtesseract> (return types, that is)
10:08:26 <ocramz> mtessaract: does the backend need to be polled regularly, or does it purely react to your commands?
10:09:10 <ocramz> ^ mtesseract
10:09:28 <mtesseract> It reacts purely to my commands.
10:09:53 <zedbourbaki> so no one ever used hmatrix ? my question is, let's say I want to store a nxm matrix, where n is significally smaller than m. will it be faster to look up if n=row and m=column, or is it the other way around ?
10:10:21 <ocramz> mtesseract: so it doesn't have a state that needs to be tracked
10:10:32 <ocramz> or does it?
10:12:13 <muzzle> Hi
10:12:25 <muzzle> Can anyone help me with the Chart library?
10:12:33 <mtesseract> ocramz: I am providing all the required state to the backend. e.g., in the form of an "IORef Context".
10:12:50 <mtesseract> ocramz: The backend is implementing a certain program logic and providing the GUI interface.
10:14:51 <powermike> hey
10:15:44 <muzzle> Specifically I'm wondering why this code http://lpaste.net/144353 which is basically the minimal example from https://hackage.haskell.org/package/Chart-1.5.4/docs/Graphics-Rendering-Chart-Easy.html doesn't compile
10:16:49 <powermike> I am wondering why http://pastebin.com/1MscXEKU won't compile
10:19:11 <ocramz> mtesseract: is the IORef to signal that you know the data will change, or that other threads might change it?
10:19:13 <powermike> What does "Non type-variable argument in the constraint: Eq (a -> a)" mean?
10:19:38 <tabemann> (a -> a) isn't a type variable
10:20:47 <powermike> tabemann: Whats a type variable?
10:20:51 <glguy> powermike: exoder(head(q1) head(q2))
10:20:56 <glguy> This probably doesn't do what you think it does
10:21:18 <powermike> glguy: Thank you so much!
10:22:00 <chenyu> Hi
10:22:06 <chenyu> everyone LD
10:22:09 <chenyu> :D
10:22:09 <powermike> glguy: why?
10:22:15 <powermike> exoder x y = (x - y) * (x - y)
10:22:18 <tabemann> in foo :: Eq a => a -> a -> Bool, a is a type variable, Bool is a type, Eq is a type class, and Eq a => is a constrant
10:22:21 <tabemann> *constraint
10:22:30 <glguy> powermike: Instead of   length(x)  you should write   length x.    Instead of   exoder(head(q1) head(q2)) you should write     exoder (head q1) (head q2)
10:25:06 <tabemann> it should be noted that to pass multiple parameters in Haskell it is traditional to use currying, rather than to pass tuples, as is traditional in, say, SML
10:25:06 <powermike> glguy: makes sense, but still does not work
10:25:28 <powermike> http://lpaste.net/144354
10:25:33 <glguy> powermike: then you probably have more errors, but starting to understand how function application works is a required first step
10:25:51 <glguy> this isn't C, you don't apply functions using parentheses
10:27:20 <powermike> glguy: I already got that. But what am I doing wrong?
10:27:23 <glguy> exoder((head q1) (head q2))  still isn't write (or what I wrote)
10:27:27 <glguy> right*
10:27:59 <glguy> exoder((head q1) (head q2))   means:   apply the function (head q1) to the argument (head q2), and then apply  exoder  to that result
10:28:52 <powermike> ofcource I don't want the function I want the result of head
10:29:13 <powermike> but why doesn't it compile?
10:29:51 <tabemann> one thing you should do is declare the types of all your functions right above where they are defined
10:30:07 <srhb> powermike: You're applying (head q1) to (head q2)
10:30:19 <powermike> srhb_ ?
10:30:48 <muzzle> is there anywhere else i can ask about the Chart library or do I have to write the maintainer?
10:30:57 <srhb> powermike: exoder((head q1) (head q2) -- means apply head q1 to head q2, then apply exoder to that.
10:31:10 <Flonk_> glguy: In Haskell, you don't call functions with parentheses, just with a space in between. You want to apply (head q1) and (head q2) to exoder, right? therefor: exoder (head q1) (head q2)
10:31:10 <tabemann> function application in Haskell looks like f x y...; if you need to group an application within a larger expression *then* you do (f x y...)
10:32:12 <muzzle> Is there actually a working plotting library in haskell?
10:32:19 <srhb> powermike: What you mean is probably to apply exoder to (head q1) and (head q2) -- which you write has exoder (head q1) (head q2)
10:32:38 <muzzle> Or is it simpler to just to just write my data to the console and use scipy for plotting?
10:33:06 <srhb> muzzle: I don't know of any mature library for the purpose, but we have R bindings which I suppose can be used for ggplot2
10:33:18 <glguy> Flonk_: Right
10:33:20 <powermike> srhb: You are right! Thanks exoder (head q1) (head q2) Instead of exoder((head q1) (head q2))
10:33:39 <Flonk_> glguy: whoops, tagged the wrong guy :D
10:33:44 <glguy> powermike: that's what I already told you :)
10:33:44 <powermike> now it makes thanks
10:33:48 <powermike> thank you all
10:33:53 <powermike> *sense
10:35:31 <tabemann> another thing is that if ... then ... else ... does not need parens
10:35:45 <tabemann> also, you should specify types above your definitions
10:35:59 <powermike> tabemann: Yeah you are right old C thinking
10:36:07 <srhb> Yes, getting rid of all those superfluous parens would probably make it easier to understand :)
10:36:35 <powermike> I also found an logic error
10:36:41 <powermike> http://pastebin.com/a7wnE4gy now it is working correctly
10:37:56 <tabemann> also a stylistic thing - it isn't traditional to use underscores in names in Haskell most of the time, aside from things like mapM_ (where the _ indicates the result is being discarded)
10:38:01 <srhb> powermike: http://pastebin.com/fdi2G7in -- I think I got all the superflous parens
10:38:52 <glguy> powermike: Now instead of testing length and using head/tail, you should update your definition to use pattern matching
10:39:44 <glguy> powermike: Also note that   length xs == 0 has to compute the whole length which involves counting all of the elements in the list. You wouldn't want to do this many times over and over.
10:39:53 <glguy> If you want to know if a list is empty you can use the 'null' function
10:42:14 <mtesseract> ocramz: sorry, I had overlooked your message! Thanks for trying to help out here. The application is single threaded, but I use the IORef for maintaining a global state of the application.
10:42:33 <mtesseract> ocramz: especially since the GUI part makes use of callbacks.
10:44:07 <Ferdirand> would it be safe to rewrite "length xs <= k" to "null (drop k xs)" ?
10:45:52 <zedbourbaki> well, seems like no one uses hmatrix... does someone uses hmatrix-gsl-stats ? I have another question :)
10:46:00 <srhb> Ferdirand: Looks safe to me.
10:46:05 <srhb> > drop 6 []
10:46:07 <lambdabot>  []
10:48:53 <lpaste> tabemann pasted “hammingDistance” at http://lpaste.net/144356
10:49:18 <Ferdirand> srhb: well looks safe to me too, otherwise I wouldn't ask, but you never know. thanks!
10:49:27 <tabemann> powermike: I made an updated version that gakes advantage of things like guards and like as well
10:49:29 <tabemann> *takes
10:50:01 <srhb> Ferdirand: OK, I guess you wanted "it's safe" -- which it is. ;)
10:50:03 <lpaste> tabemann revised “hammingDistance”: “hammingDistance (updated)” at http://lpaste.net/144356
10:52:49 <hc> E4xoi: awesome!
10:53:51 * hackagebot pivotal-tracker 0.1.0.0 - A library and a CLI tool for accessing Pivotal Tracker API  https://hackage.haskell.org/package/pivotal-tracker-0.1.0.0 (utdemir)
10:54:02 <lpaste> tabemann revised “hammingDistance”: “hammingDistance (now uses pattern matching)” at http://lpaste.net/144356
10:56:20 <lpaste> srhb annotated “hammingDistance” with “hammingDistance (annotation)” at http://lpaste.net/144356#a2601930675846119424
10:56:35 <wearenotdeadyet> I see 0.1+0.2 != 0.3 :D
10:56:40 <srhb> I'd probably rename the inner one though. Such a long name :P
10:57:04 <srhb> wearenotdeadyet: You mean /=
10:57:21 <powermike> srhb, tabemann wow thanks
10:57:30 <wearenotdeadyet> srhb: ah, hadn't got that far into the tutorial yet
10:57:49 <wearenotdeadyet> srhb: why does haskell get to be special?
10:58:20 <srhb> wearenotdeadyet: Are you talking about the standard math operator or the standard floating point specification? ;-)
10:58:35 <wearenotdeadyet> srhb: the standard boolean operator
10:58:39 <wearenotdeadyet> != vs /=
10:58:47 <srhb> wearenotdeadyet: Haskell likes to look more mathy. 
10:58:55 <wearenotdeadyet> srhb: how is /= mathy
10:59:08 <srhb> wearenotdeadyet: An equal sign with a line through it!
10:59:15 * wearenotdeadyet headdesk
10:59:17 <srhb> Except ascii compatible!
10:59:19 <srhb> :-)
10:59:37 <wearenotdeadyet> srhb: prove to me != is not math ;)
10:59:41 <wearenotdeadyet> mathy*
11:00:03 <srhb> wearenotdeadyet: I've never seen it in my math textbooks, but I'm mostly just joking around. I have no strong opinion on the subject.
11:01:31 <srhb> (Just to be clear, I meant that "not equal to" is generally depicted as ≠ which is what /= emulates)
11:02:23 <srhb> let (≠) = (/=) in 2 ≠ 3
11:02:26 <srhb> > let (≠) = (/=) in 2 ≠ 3
11:02:27 <lambdabot>  True
11:02:32 <srhb> There everyone is happy! :-)
11:03:15 <tabemann> the problem with typing your code in Unicode is that it annoys people who don't like relying upon special features of Emacs's Agda mode
11:03:30 <bluezone> let "bluezone" = "idiot" in "idiot" /= bluezone
11:03:35 <bluezone> > let "bluezone" = "idiot" in "idiot" /= bluezone
11:03:36 <lambdabot>  Not in scope: ‘bluezone’
11:03:44 * bluezone cries
11:03:52 * hackagebot pivotal-tracker 0.1.0.1 - A library and a CLI tool for accessing Pivotal Tracker API  https://hackage.haskell.org/package/pivotal-tracker-0.1.0.1 (utdemir)
11:04:00 <bluezone> > let "bluezone" = "idiot" in "idiot" /= "bluezone"
11:04:02 <lambdabot>  True
11:04:14 <bluezone> ?
11:04:29 <joco42> is there a way in Haskell to create MyString ? such that it can do all the things that a String can do just has a different name ?
11:04:39 <joco42> for example it has ++
11:04:41 <srhb> joco42: type MyString = String
11:04:50 <srhb> It's just a type alias, mind.
11:05:08 <joco42> but then the problem is that if I have a function f:: MyString -> Int then it can take also a String...
11:05:17 <joco42> is there a way to prevent that ?
11:05:24 <bluezone> I don't see how that is true but perhaps it is because I am an idiot :)
11:05:32 <srhb> joco42: No. :)
11:05:42 <joco42> yeah... that is my problem...
11:05:43 <srhb> bluezone: You've not redefined /= and clearly those Strings are not equal :)
11:05:50 <joco42> i go back to Scala ... 
11:05:51 <joco42> :)
11:05:58 <tabemann> joco42: use a newtype, but then you'll have to specify MyString "foo" whenever you want a "foo" that is a a MyString
11:06:00 <srhb> joco42: o/
11:06:10 <bluezone> > let "bluezone" = "idiot" in "idiot" != "bluezone"
11:06:11 <joco42> where i can just do MyString extends String 
11:06:11 <lambdabot>      Not in scope: ‘!=’
11:06:12 <lambdabot>      Perhaps you meant one of these:
11:06:12 <lambdabot>        ‘!’ (imported from Data.Array), ‘M.!’ (imported from Data.Map),
11:06:13 <joco42> :)
11:06:24 <tabemann> Haskell is not Java
11:06:26 * bluezone clearly knows no haskell
11:06:37 <tabemann> Haskell does not have subtyping
11:06:45 <srhb> bluezone: What do you think you're doing in the "let" part of that expression? :)
11:06:59 <joco42> is there no magic extension that would allow me to do stg like this ?
11:07:22 <tabemann> why do you really want to do this
11:07:26 <bluezone> srhb: oh :( That is false
11:07:43 <joco42> tabemann:  i want some type safety...
11:07:52 <joco42> tabemann:  not using string everywhere... 
11:08:15 <joco42> say having functions like : XML -> String
11:08:23 <joco42> where XML is just a string
11:08:42 <tabemann> see, this is where you have newtypes
11:08:50 <tabemann> you defined, say:
11:08:56 <bluezone> > let idiot = "idiot" in idiot != "bluezone"
11:08:58 <lambdabot>      Not in scope: ‘!=’
11:08:58 <lambdabot>      Perhaps you meant one of these:
11:08:58 <lambdabot>        ‘!’ (imported from Data.Array), ‘M.!’ (imported from Data.Map),
11:09:03 <joco42> tabemann:  yeah... i have newtypes at the moment ... but they are cumbersome...
11:09:08 <srhb> bluezone: (!=) doesn't exist.
11:09:17 <tabemann> newtype XML = XML String deriving Eq
11:09:23 <bluezone> maybe I can play with the bot in PM instead :D
11:09:31 <srhb> bluezone: You can. :)
11:09:31 <bluezone> Don't want to spam this
11:10:07 <joco42> tabeman: this is what i have now https://usercontent.irccloud-cdn.com/file/eL85qW4I/Screen%20Shot%202015-10-31%20at%2020.09.21.png
11:10:36 <tabemann> joco42: could you paste that into lpaste, so that we can comment on it?
11:10:48 <joco42> tabemann:  lemme try
11:10:53 <tabemann> @where lpaste
11:10:54 <lambdabot> http://lpaste.net/
11:11:51 <joco42> tabemann: i have it on a remote machine in tmux...
11:12:00 <joco42> not so easy to just copy paste...
11:12:33 <joco42> but maybe its time to set up this somehow...
11:12:41 <tabemann> couldn't you always sftp over the source file?
11:13:22 <tabemann> and then paste it?
11:13:52 * hackagebot hledger-diff 0.2.0.5 - Compares the transactions in two ledger files.  https://hackage.haskell.org/package/hledger-diff-0.2.0.5 (gebner)
11:14:26 <joco42> http://www.viizio.com/~joco/PrintXML.hs
11:14:35 <joco42> yeah
11:14:40 <joco42> thats a good idea too
11:14:46 <joco42> btw :)
11:15:09 <joco42> http://lpaste.net/144363
11:16:09 <tabemann> just from looking at that, that could use a Monoid instance
11:16:22 <joco42> tabemann:  yeah, i was thinking that myself
11:17:31 <joco42> but i just wanted to know why is it not possible to have a type alias which prohibits function call that are not using the alias...
11:17:43 <joco42> such as MyString = String
11:17:53 <joco42> then f :: MyString -> MyString 
11:17:56 <tabemann> because a type alias is just a renaming of the same type, nothing more
11:18:03 <joco42> can only be called with MyString....
11:18:10 <tabemann> if you ever want to restrict a type, you need to use newtype
11:18:17 <joco42> i see
11:18:28 <joco42> that restricts me too...
11:18:36 <srhb> Yes, but that's also the point.
11:18:43 <joco42> maybe
11:18:51 <srhb> To a degree at least. :)
11:18:56 <tabemann> also, I recommend that you not use GeneralizedNewtypeDeriving... at least historically there have been issues with it (even though they *may* have been fixed in newer versions of Haskell with the introduction of roles)
11:19:36 <joco42> ok
11:19:46 <glguy> It's fine to use GeneralizedNewtypeDeriving like this
11:19:53 <joco42> it was my attempt at getting this behaviour....
11:20:06 <joco42> but it did not work out ... :)
11:20:22 <joco42> to get MyString which is the same as String...
11:20:30 <joco42> just different ... :)
11:20:35 <tabemann> for generalized newtype deriving you have to tell it each class you want an instance to be created for
11:20:56 <joco42> foldable...
11:21:00 <joco42> or monoid
11:21:12 <tabemann> and it doesn't just make something work with arbitrary functions that happen to take the encapsulated type (rather than having a constraint which the contained type and the newtype share)
11:22:45 <Zemyla> Why do IntSet and IntMap take O(n) to find their size?
11:23:38 <tabemann> Zemyla: because you have to traverse the entire trie to find how much stuff is in it
11:23:47 <joco42> this looks interesting https://ocharles.org.uk/blog/posts/2014-12-17-overloaded-strings.html
11:24:52 <tabemann> I should take advantage of that, because you code is infested with T.pack (where T is short for Data.Text)
11:25:22 <tabemann> *my code
11:25:50 <Zemyla> tabemann: Why don't they store their size in their nodes like regular Sets and Maps do?
11:26:10 <joco42> :)
11:26:20 <joco42> your code is my code my code is your code
11:26:55 <joco42> or some song... like this
11:27:23 <tabemann> Zemyla: but you have to reach those nodes to get the sizes
11:27:44 <tabemann> of course that makes one wonder why they don't store the size at the root of the trie
11:28:03 <Zemyla> tabemann: Yeah, that's what I was saying.
11:29:18 <srhb> tabemann, Zemyla: That would lose sharing, I think.
11:29:41 <tabemann> except you share the leaves of the trie, not the root
11:29:53 <srhb> Right, but how do you update the root now?
11:29:57 <srhb> (immutability)
11:30:08 <tabemann> srhb: every time you create a new root by making a change
11:30:14 <srhb> Losing sharing... :)
11:30:38 <Zemyla> srhb: You have to create a new root anyways whenever you change something, so you simply set the size in the root equal to the size of the left plus the size of the right.
11:30:42 <tabemann> no see - because it's an immutable data structure, every time you make a change you *have* to create a new root
11:30:42 * srhb nods
11:31:04 <srhb> Yes, you're right.
11:31:06 <srhb> I was confused.
11:31:23 <Welkin> a new root?
11:31:41 <Welkin> oh, I see
11:32:26 <joco42> btw does hoogle support wildcards?
11:32:36 <srhb> joco42: Yes, any lowercase character I believe?
11:32:43 <hpc> @hoogle a -> b
11:32:46 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:32:46 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
11:32:46 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
11:32:48 <srhb> joco42: Or any lowercase name, just like type variables
11:32:53 <joco42> i wanna see all functions that are String -> *
11:33:00 <tabemann> but * is a kind
11:33:02 <hpc> @hoogle String -> a
11:33:03 <lambdabot> Prelude error :: [Char] -> a
11:33:03 <lambdabot> Debug.Trace trace :: String -> a -> a
11:33:03 <lambdabot> Network.BufferType buf_fromStr :: BufferOp a -> String -> a
11:33:11 <Welkin> joco42: hoogle only searches base + a few other packages though
11:33:14 <srhb> @hoogle String -> foobarbaz
11:33:15 <lambdabot> Prelude error :: [Char] -> a
11:33:15 <lambdabot> Debug.Trace trace :: String -> a -> a
11:33:15 <lambdabot> Network.BufferType buf_fromStr :: BufferOp a -> String -> a
11:33:28 <Welkin> joco42: use hayoo to search all of hackage
11:33:34 <joco42> ok
11:33:48 <Welkin> hayoo does not support searching by type though
11:33:50 <tabemann> http://hayoo.fh-wedel.de/
11:33:51 <joco42> and if i also want to get all the arities?
11:33:59 <joco42> say ++
11:34:13 <joco42> by searching String -> ... 
11:34:38 <joco42> all the functions that take a String and something else... later...
11:34:47 <Welkin> not sure
11:34:50 <joco42> like an Int 
11:35:04 <joco42> String -> Int -> Cat -> Pancake
11:35:10 <joco42> :)
11:35:21 <Welkin> I'm sure there is a search legend on hoogle
11:35:33 <joco42> search legend...
11:35:45 <Welkin> joco42: https://github.com/ndmitchell/hoogle/blob/master/README.md
11:35:46 <hpc> at this point i would have to ask what you would need those results for
11:36:29 <joco42> hpc:  when i have a type, i would like to know what i can do with that...
11:36:45 <srhb> A search for String should be sufficient.
11:36:50 <joco42> like in IntelliJ with Scala , I stype String. 
11:37:05 <joco42> then i get all the things that i can do with String
11:37:31 <srhb> But we can't really exclude the result type so far, no.
11:37:53 <joco42> srhb:  like this ? https://www.haskell.org/hoogle/?hoogle=%3A%3AString
11:37:53 <Welkin> joco42: well, just look at the Data.List package
11:37:58 <srhb> There's no way currently to get all functions that take String as some parameter, but exclude those where String is only the result.
11:38:03 <Welkin> joco42: and Data.List.Split
11:38:40 <srhb> Mind, the results would probably be quite worthless even if you could do this.
11:38:51 <Welkin> joco42: https://hackage.haskell.org/package/split-0.1.1/docs/Data-List-Split.html
11:38:52 <srhb> It's better to say "I need a function that does this, so its type must be this, let's Hoogle that."
11:38:53 * hackagebot ireal 0.2.2 - Real numbers and intervals with relatively efficient exact arithmetic.  https://hackage.haskell.org/package/ireal-0.2.2 (sydow)
11:38:54 <joco42> srhb:  well, maybe...
11:39:02 <Welkin> and https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-List.html
11:39:43 <Welkin> joco42: type String = [Char]
11:39:53 <joco42> Welkin:  this splitter is kinda nice
11:39:55 <Welkin> so, just look at any list libraries
11:40:14 <joco42> thats a good top
11:40:16 <joco42> tip
11:40:48 <tabemann> one thing - if you have a choice,  you probably want to be using Data.Text.Text rather than String
11:41:04 <joco42> yeah ?
11:41:10 <Welkin> tabemann: that is an optimization though
11:41:26 <srhb> It depends what you're doing really.
11:41:32 <Welkin> but yes, use Text instead of String if you are processing large amounts of text
11:41:56 <joco42> right
11:41:57 <Welkin> Text is an array of codepoints, String is a list of Characters
11:42:01 <joco42> just small things
11:42:09 <joco42> atm
11:42:11 <tabemann> the only thing that String does better than Text is prepending individual characters
11:42:18 <joco42> hobby code
11:42:38 <srhb> tabemann: How about fusing away intermediates?
11:43:20 <wearenotdeadyet> srhb: I found my proof fyi
11:43:37 <tabemann> last time I checked, at least according to Hackage, many of the functions in Data.Text do support fusion
11:43:40 <srhb> wearenotdeadyet: er... That != is not mathy? :P
11:44:08 <Welkin> where did ! and != come from anyway?
11:44:09 <srhb> tabemann: Right, but internally the fragments may contain longish arrays that can't fuse away until they're entirely consumed, afair?
11:44:17 <srhb> Welkin: I don't actually know.
11:44:19 <Welkin> to mean negation and not-equal
11:44:26 <Welkin> not from math
11:44:30 <Welkin> or logic
11:45:32 <srhb> Maybe it's as new as C
11:46:07 <srhb> Not quite..
11:47:13 <joco42> http://research.microsoft.com/en-us/um/people/simonpj/Papers/oo-haskell/overloading_conf.pdf
11:47:19 <joco42> this is kind of interesting
11:48:45 <Kristler> srhb: https://en.wikipedia.org/wiki/Negation#Programming , perhaps
11:48:53 * hackagebot fn 0.1.3.1 - A functional web framework.  https://hackage.haskell.org/package/fn-0.1.3.1 (DanielPatterson)
11:49:05 <Kristler> Seems like it originated from B, which influenced C, and the rest is history
11:49:28 <srhb> I was close then! :-)
11:51:13 <chenyu> hi
11:52:17 <Kristler> hello!
11:53:12 * ackthet is wearing this to the gym from now on http://www.cafepress.com/mf/34634843/haskblackborders_tank-top?shop=twhask&productId=395772739
11:54:59 <Rembane> ackthet: Stateless workout is the best workout! Nice! :D
12:00:14 <lamefun> What's the point of hSeek?
12:02:10 <Adeon> :t hSeek
12:02:12 <lambdabot> Not in scope: ‘hSeek’
12:02:22 <Adeon> it'll let you go to different parts of an open file
12:04:09 <lamefun> But what's the point? Why not simply: hReadAt :: Handle -> Int {- Position -} -> Int {- How many bytes -} -> IO ByteString 
12:04:52 <MrSkeltal> lamefun, because some "files" are actually streams of data that don't have a notion of position
12:05:13 <MrSkeltal> so you can read them but not seek
12:05:28 <srhb> lamefun: also you might want to write instead of read
12:05:30 <Adeon> there's always some redundancy but in the case of hSeek you might not want to read or write anything
12:05:33 <MrSkeltal> that's how file APIs work in ANSI C, POSIX and Linux
12:05:46 <Adeon> e.g. you might want to seek to end and then check your position to find out the size of the file
12:06:13 <srhb> Basically you could implement YOUR abstraction BECAUSE hSeek is general enough.
12:06:41 <MrSkeltal> so yeah
12:06:51 <MrSkeltal> you can implement hReadAt on top of hSeek and hRead
12:06:59 <MrSkeltal> but if you do vice versa, it's not going to work
12:07:05 <MrSkeltal> not on all types of handles
12:07:24 <ackthet> Rembane: :D my workouts have no side effects
12:08:31 <lamefun> why isn't it going to work?
12:09:00 <Rembane> ackthet: ^__________^
12:09:08 <ackthet> lamefun: fp joke about that beater i linked above
12:09:26 * ackthet sees himself out
12:10:17 <MrSkeltal> lamefun, imagine a socket
12:10:23 <MrSkeltal> how would reatAt work on a socket
12:11:52 <lamefun> it wouldn't? why do sockets use file API anyway?
12:12:25 <Hijiri> posix is file-ly typed
12:13:13 <mauke> lamefun: so you'd have separate I/O functions for normal files, terminals, pipes (2x), and the various socket types?
12:18:54 * hackagebot ireal 0.2.3 - Real numbers and intervals with relatively efficient exact arithmetic.  https://hackage.haskell.org/package/ireal-0.2.3 (sydow)
12:20:01 <lamefun> Aren't there type classes for that?
12:20:10 <mauke> ... in C?
12:22:29 <wearenotdeadyet> lamefun: fun anything can be represented as a stream of bits, which is what a file is on nix
12:25:48 <mauke> if you did use typeclasses, what type would openFile have?
12:29:32 <zedbourbaki> hello :) I am having problem installing hmatrix... can anyone chime in ? :)
12:35:09 <lamefun> mauke, openFile :: FilePath -> IO (File mode)
12:37:29 <zedbourbaki> more precisely, i have installed hmatrix using cabal, but apparently ghc is unable to find it... 
12:38:07 <zedbourbaki> i got the error '/opt/local/lib/liblapack.a: unknown symbol `_ATL_xerbla' ' - there is one user who had this same error on the ircbrowse.net archive, but not answer was provided.
12:38:09 <lambdafan> zedbourbaki: I recommend you not use cabal and use stack instead
12:38:43 <lambdafan> zedbourbaki: It will take you a few minutes to set up but you'll find that you'll avoid so many problems.
12:39:09 <mauke> lamefun: what's mode?
12:39:37 <zedbourbaki> lambdafan: are all packages on stack ?
12:39:37 <lamefun> a type
12:39:57 <mauke> yeah, but one chosen by the caller
12:40:33 <lambdafan> zedbourbaki: no, but when I want to add a library outside of the stack repo, I have thus far not had a problem.
12:40:55 <zedbourbaki> ok
12:41:06 <zedbourbaki> but stack is only available through brew, if I am correct....innit ?
12:41:42 <lambdafan> zedbourbaki: github has instructions on how to install.
12:41:42 <radix> you can just download a binary distribution
12:41:49 <radix> https://github.com/commercialhaskell/stack#how-to-install
12:44:41 <lamefun> mauke, what's the problem with that?
12:45:09 <lamefun> I mean, it only makes sense to pass open mode at type level instead of value level
12:45:59 <roelof> someone who can give feedback on these solutions : https://github.com/rwobben/craft/blob/master/chapter_4.hs
12:46:03 <mauke> lamefun: what's File?
12:46:16 <lamefun> nevermind
12:46:37 <lamefun> I'm going to try to do something working based on my thinking, this way I'll find flaws in it quicker.
12:50:16 <zedbourbaki> lambdafan: thank you, i'm still unsure if it's time to switch to brew or not... last time I tried to switch, it messed up with some other installation (it has been a while, but if my memory is any good it is gsl )
12:50:34 <zedbourbaki> if i do install brew, how do i avoid this? or how do i avoid having to re-install what i installed with mac ports ?
12:51:22 <radix> zedbourbaki: again, you do _not_ need to use brew
12:51:32 <tabemann> where the fuck is defaultTimeLocale defined?
12:51:43 <radix> zedbourbaki: there is a plain binary distribution that you can download without using brew
12:51:46 <radix> it's *also* available through brew, though.
12:52:02 <wearenotdeadyet> zedbourbaki: why on earth would you want to use brew?
12:52:06 <radix> zedbourbaki: here's the part of the installation instructions that link to the regular non-brew download: https://github.com/commercialhaskell/stack/blob/release/doc/install_and_upgrade.md#manual-download-1
12:52:08 <wearenotdeadyet> just use the native package manager
12:52:14 <wearenotdeadyet> i.e. cabal I think
12:52:47 <tabemann> I'm trying to Data.Time.Format in GHCi, and I'm trying to use formatTime, and the only time locale I see defined is defaultTimeFormat, which is in Data.Time.Format according to Hackage.... except that when I try to use it with GHCi (I've got 7.8.3 installed) it can't find it
12:53:19 <tabemann> but I've seen posts on StackOverflow that refer to defaultTimeFormat that date back to 2010, so this can't be something new
12:53:26 <tabemann> so what's up?
12:55:17 <tabemann> @hoogle defaultTimeFormat
12:55:17 <lambdabot> No results found
12:55:49 <mauke> I don't see defaultTimeFormat
12:56:01 <zedbourbaki> radix: thanks for claryfing :)
12:56:23 <zedbourbaki> wearenotdeadyet: i don't know, cause it's what kids do these days ;) i mean, it's not the first time I have considered switching, that is all
12:57:42 <zedbourbaki> the thing is, i just never know where to put things and all - i am just a beginner programmer...
12:58:07 <zedbourbaki> and i am still confusing as to how i place something on my PATH
12:58:24 <zedbourbaki> so if anyone could help me - last time I tried, i decided that it just wasn't for me.
12:59:00 <Rembane> zedbourbaki: Is a cabal sandbox not doing your bidding?
12:59:31 <zedbourbaki> i don't know what that is
12:59:47 <Rembane> zedbourbaki: Cool. What is not working for you?
13:00:49 <zedbourbaki> hmatrix
13:02:11 <bitemyapp> zedbourbaki: what's wrong with your PATH?
13:02:45 <zedbourbaki> I have no clue. I understand the concept of PATH, but I am always confuse as to what it is exactly....
13:02:51 <bitemyapp> zedbourbaki: hrm, okay.
13:02:54 <bitemyapp> zedbourbaki: so here's the deal
13:03:06 <bitemyapp> zedbourbaki: I made a two hour tutorial (don't let the length scare you off, bear with me) for using Stack to install and use libraries.
13:03:23 <bitemyapp> zedbourbaki: https://www.youtube.com/watch?v=sRonIB8ZStw
13:03:35 <bitemyapp> zedbourbaki: precisely the sort of thing you want to do, (install a library, play with it) is covered.
13:03:44 <zedbourbaki> great, but how can I rest assured that it will solve my hmatrix problem ?
13:04:06 <zedbourbaki> I mean, I just don't get why most people seems to think that me not using stack is the reason why I have ths problem to begin with, that is all :)
13:04:13 <bitemyapp> zedbourbaki: the issue is that you can't figure out how to install it and import it right>
13:04:15 <nkaretnikov> is there a language which is just like ats but designed by a fan of haskell, not ml?
13:04:17 <Welkin> bitemyapp: two hour? I wonder what you talk about
13:04:18 <bitemyapp> right?*
13:04:33 <Welkin> it's just stack install and modifying stack.yaml :P
13:04:35 <bitemyapp> Welkin: watch it and find out (there are timestamps in the video description)
13:04:45 <bitemyapp> Welkin: we go through a lot of examples, including projects that are annoying.
13:04:53 <sinelaw> hey, my instance for Alternative keeps looping when I use 'some' or 'many', unless I manually fiddle with the implementation
13:05:04 <sinelaw> any general pattern to avoid here?
13:05:09 <zedbourbaki> bitemyapp: well, i have installed it with cabal, only ghc seems unable to find it
13:05:11 <mauke> bitemyapp: <zedbourbaki> i got the error '/opt/local/lib/liblapack.a: unknown symbol `_ATL_xerbla' '
13:05:17 <mauke> sounds like ghc is finding it fine
13:05:27 <bitemyapp> sinelaw: https://mail.haskell.org/pipermail/haskell-cafe/2011-December/097476.html
13:05:34 <bitemyapp> mauke: ah thank you
13:05:41 <bitemyapp> zedbourbaki: what distro are you on?
13:05:47 <mauke> ubuntu something
13:05:54 <bitemyapp> zedbourbaki: what version of Ubuntu>?
13:05:59 <mauke> or, wait
13:06:04 <mauke> I may be crossing my streams
13:06:06 <zedbourbaki> bitemyapp: oh i am not on ubuntu, sadly
13:06:12 <mauke> sorry
13:06:25 <bitemyapp> mauke: killing me holmes :P
13:06:28 <bitemyapp> zedbourbaki: what are you on?
13:07:19 <sinelaw> bitemyapp: oh thanks!
13:07:23 <zedbourbaki> bitemyapp: mac os x. did the el capitan upgrade, and i am now reaping this upgrade... sigh
13:07:25 <bitemyapp> sinelaw: np
13:07:41 <bitemyapp> zedbourbaki: how'd you install atlas?
13:08:05 <zedbourbaki> bitemyapp: sudo port install atlas
13:08:28 <bitemyapp> hum.
13:08:32 <bitemyapp> zedbourbaki: okay here's the issue
13:08:33 <Welkin> zedbourbaki: I have learned to avoid mac upgrades
13:08:40 <Welkin> better solution, stop using mac :D
13:08:42 <bitemyapp> zedbourbaki: even if in theory that should work, very few people still use macports.
13:08:43 <zedbourbaki> Welkin: yeah i am considering that too
13:08:48 <bitemyapp> zedbourbaki: most people are using homebrew
13:08:48 <Welkin> (I need to do this soon)
13:09:09 <bitemyapp> zedbourbaki: so if there was some bug here, you're more likely to be on the "happy path" if you use what most Haskell programmers on Mac use for packaging. In this case, again, homebrew.
13:09:25 <zedbourbaki> bitemyapp: yeah I understand this part, it's just....
13:09:27 <bitemyapp> zedbourbaki: so my first pass suggestion would be to nuke macports from orbit, reinstall the lapack/atlas/whatever stuff via homebrew, then it another shot.
13:09:29 <sdx23> hi. I've got some IO (Maybe X) and would like to combine them in an Alternative-like manner. Is there a more nice way than using "liftM2 <|>"?
13:09:45 <bitemyapp> zedbourbaki: yes?
13:09:57 <hpc> :t (<||>)
13:09:59 <lambdabot>     Not in scope: ‘<||>’
13:09:59 <lambdabot>     Perhaps you meant one of these:
13:09:59 <lambdabot>       ‘<|>’ (imported from Control.Applicative),
13:10:02 <hpc> hmm
13:10:03 <zedbourbaki> bitemyapp: last winter I had tried to do the switch, and it wasn't working properly. since I had some work to do that was urgent, I decided to switch back.
13:10:15 <bitemyapp> zedbourbaki: also I suggest making a paste of your problem that has all the information required to help you ready to go
13:10:30 <bitemyapp> makes it easier to avoid misses (like mine) earlier and doesn't force to type everything out with each new person trying to help.
13:10:42 <sinelaw> bitemyapp: that's a not-short thread :)
13:10:47 <bitemyapp> zedbourbaki: well, I can't do anything about that - I am truly sorry.
13:10:57 <bitemyapp> sinelaw: it's not a tiny issue. requires consideration.
13:11:08 <bitemyapp> sinelaw: they're not really total for a lot of possible instances though. It's weird.
13:11:34 <sinelaw> hm
13:11:35 <bitemyapp> zedbourbaki: all I can tell you is the usual heuristics for brokenness-avoidance and that entails not using a package manager that hasn't been the #1 option for programmers on Mac for a few years.
13:11:38 <zedbourbaki> bitemyapp: it's ok :) i'm just unsure if it's the right path to take... I mean, i don't even know how to  nuke macports from orbit, just to begin with
13:11:55 <bitemyapp> zedbourbaki: there's a Haskell numerics channel
13:12:07 <vectorspacealien> oh there is?
13:12:07 <bitemyapp> zedbourbaki: with people who specialize in this stuff, there's also a lot of Mac users there.
13:12:22 <bitemyapp> zedbourbaki: you might ask there. I'm also going to ping the founder of that channel because they're a mac user and may know what to do
13:12:23 <zedbourbaki> bitemyapp: what do you mean by "numerics" ?
13:12:28 <bitemyapp> but I suspect the answer will be, "use homebrew"
13:12:35 <bitemyapp> zedbourbaki: hmatrix/ML/statistics/numerical computing
13:12:35 <zedbourbaki> bitemyapp: ahah fair enough :)
13:12:41 <vectorspacealien> also: eyyy guys I'm new, I joined 'cause I'm trying to learn haskell to do numerical computing, especially MCMC
13:13:00 <bitemyapp> zedbourbaki: #numerical-haskell
13:13:05 <zedbourbaki> bitemyapp: sounds like my kind of people ahah
13:13:07 <Adeon> I have a mac at work but I basically just run linux in a virtual machine all the time and have it fullscreen
13:13:48 <sdx23> hpc: guess I'll define it myself then. Just thought there'd perhaps be another concept that I could use.
13:13:51 <Adeon> when all the infra runs linux then it kind of makes sense
13:13:53 <zedbourbaki> Adeon: I had good experience with Linux and I would like to switch back, I just don't know how to proceed ahah
13:13:56 <bitemyapp> zedbourbaki: best I can do for now, sorry I don't know more.
13:13:57 * hackagebot no-buffering-workaround 0.1.0.0 - Workaround for GHC bug #2189.  https://hackage.haskell.org/package/no-buffering-workaround-0.1.0.0 (arotenberg)
13:14:07 <bitemyapp> zedbourbaki: I run Ubuntu 14.04 natively on the rMBP my work gave me.
13:14:20 <Adeon> I run linux natively on my home laptop
13:14:26 <zedbourbaki> bitemyapp: what do you mean by "natively" ?
13:14:31 <Adeon> it's also a rMBP
13:14:33 <bitemyapp> zedbourbaki: boots directly into Linux, no VM.
13:14:44 <zedbourbaki> bitemyapp: ah I see
13:14:47 <Adeon> but the work computer has some company software on it that runs on OS X so I don't want to mess it up
13:14:54 <zedbourbaki> bitemyapp: I guess you are starting to see how much of a noob I am ;)
13:15:00 <bitemyapp> zedbourbaki: nothing wrong with that.
13:15:22 <Adeon> everyone is a noob at one point
13:15:46 <bitemyapp> zedbourbaki: anyhoo, I pinged my numerical friend about your issue. Try to idle in IRC and wait around so I can give you an answer if he gets back to me. Or email me so I can reply. Either way.
13:15:55 <bitemyapp> zedbourbaki: my contact info is here: https://github.com/bitemyapp/
13:17:10 <zedbourbaki> bitemyapp: thanks :) I'll do my best to do a clear explanation of the different steps in case someone would like to walk that walk :)
13:17:32 <bitemyapp> zedbourbaki: write up an lpaste.
13:17:41 <bitemyapp> zedbourbaki: with all the details. Then if somebody asks, you can copy-pasta.
13:17:55 <bitemyapp> er, the URL to the paste, not the full contents.
13:19:11 <zedbourbaki> bitemyapp: got it :) thanks again for taking the time to consider my issue :)
13:20:02 <bitemyapp> zedbourbaki: np, sorry I couldn't be more useful.
13:20:56 <radens> How do you parse an optional reserved token with parsec?
13:22:23 <johnw> optional (symbol "token")?
13:23:32 * radens goes to try
13:23:58 * hackagebot nested-routes 6.0.0.1 - Declarative, compositional Wai responses  https://hackage.haskell.org/package/nested-routes-6.0.0.1 (athanclark)
13:24:05 <sdx23> Is there a reason to use MonadPlus over Alternative other than emphasizing "this is (also) a monad"?
13:24:51 <Zemyla> Hmm, why is Hyper not an ArrowApply?
13:24:58 <radens> johnw: thanks
13:25:40 <hpc> > [1, 2, 3] `mplus` [4,5,6]
13:25:42 <lambdabot>  [1,2,3,4,5,6]
13:25:47 <johnw> sdx23: do you mean, instancing something to be a MonadPlus, defining a function in terms of MonadPlus, or using `mplus`?
13:25:50 <hpc> > [1,2,3] <|> [4,5,6]
13:25:52 <lambdabot>  [1,2,3,4,5,6]
13:26:00 <hpc> hmm
13:26:51 <sdx23> johnw: all of them, i guess. I don't really see why MonadPlus exists.
13:27:08 <johnw> once upon a time, Monad was a separate thing
13:27:21 <sdx23> hpc: mplus is defined in terms of (<|>)
13:27:33 <sdx23> johnw: ah, so historic reasons only
13:28:52 <sdx23> thank you, johnw and hpc 
13:28:58 * hackagebot opengl-spacenavigator 0.1.2.0 - Library and example for using a SpaceNavigator-compatible 3-D mouse with OpenGL  https://hackage.haskell.org/package/opengl-spacenavigator-0.1.2.0 (BrianBush)
13:33:12 <zxtx> Hey, is there an easy to way to get something like sequence  for Either but where I return the first element with a Right constructor?
13:33:25 <zxtx> or rather is something already defined that does so
13:33:58 * hackagebot semigroups 0.18 - Anything that associates  https://hackage.haskell.org/package/semigroups-0.18 (EdwardKmett)
13:35:56 <athan> zxtx: Can you be more specific?
13:37:27 <zxtx> athan, suppose I have a list [Left 3, Right 4, Left 5, Right 6], I would like a function which returns Right 4
13:37:48 <zxtx> and if say the list is empty fails somehow
13:38:09 <RageYL> sequence ?
13:38:17 <RageYL> oh sorry ^^
13:38:33 <RageYL> i didn't read the beginning ^^
13:39:07 <athan> zxtx: Well, the applicative instance for Either expects `Left` to act like an exception - you might try something like a `leftToRight . sequence . map leftToRight`
13:39:43 <zxtx> athan, and I would define leftToRight?
13:39:50 <athan> yep
13:39:52 <sdx23> > head . rights $ [Left 3, Right 4, Left 5, Right 6]
13:39:54 <lambdabot>  4
13:39:58 <athan> :o
13:40:07 <athan> or that ^
13:40:12 <Welkin> athan loves head
13:40:14 <Welkin> :D
13:40:30 <athan> I like safe head, thank you
13:40:53 <zxtx> sdx23, athan Thanks, I'll use something safe since I know what logic I want if the list is empty
13:41:00 <bitemyapp> athan: hey stranger
13:41:11 <athan> bitemyapp: Hey :)
13:41:53 <zxtx> sdx23, is there a version of "rights over Traversables?
13:42:07 <Welkin> you mean like catMaybes ?
13:42:30 <athan> zxtx: Witherables actually :|
13:42:31 <Welkin> oh, rights is like catMaybes already
13:42:40 <sdx23> zxtx: not that I know of. You can fold over it, however.
13:45:24 <zxtx> I'll look at the definition of rights and roll my own one-liner, thanks sdx23 and athan for the help
13:48:09 <sdx23> zxtx: depending on your "no Right in there" logic you may define an instace Alternative Either and use asum
13:49:42 <zxtx> if there is no Right, a return a Left with a specific value
13:49:56 <NightRa> How to I distinguish between a file and a directory from a FilePath? (trying to use getDirectoryContents)
13:50:14 <Pipotheclown> Le
13:50:17 <Rembane> NightRa: Ask the path what it is.
13:50:29 <Rembane> NightRa: I think isDirectory can help you
13:50:37 <Rembane> NightRa: And isFile
13:51:24 <NightRa> Rembane: Can't find these functions..
13:51:41 <athan> haddock is borking - it tells me that it "cannot satisfy -package-id for ..." when the package is obviously installed in the cabal sandbox
13:51:57 <athan> (don't laugh ._. I still haven't figured out how to upload docs with stack yet)
13:52:29 <Welkin> athan: you can't satisfy it
13:52:40 <Welkin> athan: it will end in heartbreak
13:53:12 <NightRa> Where can I find the functions 'isDirectory' and 'isFile'?
13:53:14 <athan> Welkin: ):
13:53:28 <athan> NightRa: System.Directory :)
13:53:46 <Rembane> NightRa: In the directory package.
13:53:54 <NightRa> They don't seem to be there: https://hackage.haskell.org/package/directory-1.2.4.0/docs/System-Directory.html
13:55:16 <athan> I must be losing my mind, one sec
13:55:31 <NightRa> ok, these are 'doesFileExist ' and 'doesDirectoryExist', and they check they are of the appropriate type and also exist
13:55:41 <athan> ^
13:55:42 <athan> :D
13:55:58 <NightRa> Yeah XD
13:56:02 <Rembane> NightRa: cool, the api has changed since I used it. :)
13:59:32 <sinelaw> Isn't this true: many p = some p <|> pure []
13:59:46 <sinelaw> assuming <|> is left-biased
14:00:05 <Welkin> what is some p?
14:00:23 <Welkin> some p = p <|> some p?
14:00:55 <Welkin> er, no
14:01:34 <Welkin> https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Base.html#some
14:01:44 <athan> Welkin: I think I forgot to configure ><
14:02:19 <Welkin> stack doesn't do that?
14:06:07 <sdx23> zxtx: I'd say it's hacky - there's reason there's no Alternative instance of (Either a) by default, but http://lpaste.net/144372
14:10:01 <zxtx> sdx23, that's really clean
14:11:11 <sdx23> zxtx: perhaps it's a good idea to use a "newtype Bla = Either String" instead, to avoid confusion with acutal (Either String a).
14:14:59 <Zemyla> Why aren't there Functor instances on the Generic types in GHC.Generics?
14:17:14 <zedbourbaki> bitemyapp: i have a silly question... from our conversation, I was under the impression that stack was meant to replace cabal... I feel like I might have got the wrong impression. Would you be able to clarify ?
14:18:31 <zxtx> sdx23, thankfully its Either DomainSpecificType
14:22:27 <tabemann> what was that mass k-lining about?
14:24:27 <mgsloan> zedbourbaki: Stack is meant to replace most common uses of cabal-install, which is the "cabal" binary.  However, there are some things cabal supports which aren't planned in stack anytime soon.  Namely, support for compilers other than ghc / ghcjs
14:25:05 <mgsloan> zedbourbaki: However, it is not meant to entirely replace Cabal, it uses Cabal-the-library and uses cabal files to describe packages
14:25:19 <zedbourbaki> ok so then
14:25:21 <zedbourbaki> well
14:25:25 <zedbourbaki> how do i install hmatrix ?
14:25:28 <zedbourbaki> i don't get it
14:25:50 <athan> zedbourbaki: stack install hmatrix?
14:27:12 <zedbourbaki> athan: thanks ! so obvious, it was hidden in plain sight
14:28:03 <athan> zedbourbaki: :) the `stack.yaml` file can be elusive at first, but it's a much better workflow I've found than `cabal` (thanks mgsloan!)
14:37:08 <athan> bitemyapp, Welkin: I did a weird thing: wai-transformers - http://athanclark.github.io/posts/2015-10-24-wai-transformers-tut.html
14:37:28 <athan> tell me what you think :)
14:38:52 <zedbourbaki> athan: now I am confused... I ran stack install hmatrix, and it is telling me this to look at the stack.yaml file - or so I understand... what should I do ?
14:39:44 <athan> zedbourbaki: What is it saying exactly? That hmatrix isn't available in a shapshot or something? Under the `dependencies` section (I think), you can state which packages / versions should be pulled straight from Hackage
14:39:46 <athan> here one sec
14:40:07 <athan> extra-deps, my mistake: https://github.com/athanclark/nested-routes/blob/master/stack.yaml
14:40:20 <zedbourbaki> it says : Run from outside a project, using implicit global project config
14:40:39 <athan> o_o
14:41:06 <athan> zedbourbaki: Are you trying to use `hmatrix` from `ghci`, globally? Or are you trying to install it as a dependency for an existing cabal package?
14:41:28 <athan> sorry - are you trying to install hmatrix globally to use from within any ghci session*
14:41:30 <mgsloan> Yes, if you run stack commands outside of a project, then it implicitly uses a global config.  TThis is nice for running individual haskell files, experiments, etc
14:41:44 <zedbourbaki> mgsloan: ok, good
14:41:48 <zedbourbaki> athan: yes
14:42:30 <zedbourbaki> the thing is, i am following the instructions at http://dis.um.es/~alberto/material/hmatrix.pdf
14:42:37 <zedbourbaki> and stack fails to install the hmatrix-special
14:43:02 <sinelaw> Questoin about writing a parser that has overlapping prefixes + recursion. For example: var = "x", application = "x x"
14:43:30 <zedbourbaki> because the hmatrix version it finds is not (>=0.17)
14:43:40 <zedbourbaki> so now I am confused...
14:44:23 <sinelaw> If I define expr := var | app, and app := expr expr, I get infinite recursion in 'app'. So instead I have to define: app := var expr (explicitly avoiding the recursion)
14:44:27 <sinelaw> is there a better way?
14:44:32 <sinelaw> *Question
14:44:54 <athan> sinelaw: When I did a hand-written parser for lambda calculus, I found a stateful fold to be necessary
14:45:21 <athan> sinelaw: But then that breaks the grammar of application :)
14:45:26 <sinelaw> stateful fold?
14:45:29 <athan> you couldn't do `(x x) x` with that style
14:45:36 <mgsloan> zedbourbaki: The issue is that hmatrix-special is not in stackage (this page has that info: http://www.stackage.org/package/hmatrix-special).  It tries to install the newest version of hmatrix-special, but with an older version of hmatrix that's in the lts snapshot.
14:45:40 <mauke> sinelaw: that's ambiguous anyway
14:45:56 <athan> sinelaw: yep, `foldlM` with a State in there - how much application is accumulated before seeing a bracket (I think)
14:46:01 <sinelaw> mauke: why? "x x" can only be application
14:46:03 <mgsloan> zedbourbaki: The solution is to pick the version you want, and do "stack install hmatrix-special-0.3.0.1"
14:46:21 <mauke> sinelaw: 'a b c'
14:46:22 <athan> but the abstraction structure is actually straightforward
14:48:36 <sinelaw> mauke: that's true, but it isn't my problem
14:50:00 <mauke> well, your suggestion parses it as 'a (b c)'
14:51:41 <sinelaw> mauke: I see
14:52:05 <sinelaw> mauke: so how do I not lose that information while avoiding infinite recursion?
14:52:39 <orzo> quick poll, does anyone here have a problem with haskell's Data.Time.Clock and UTCTime api?
14:53:35 <orzo> i have a package i want to make public, but i depend on older libraries, and in order to update it, I would have to switch to a library author's pet time library
14:54:15 <athan> orzo: Only with how unintuitive it can be. For instance, DiffTime pains me :\
14:54:36 <athan> but it's completely possible to use it, you just have to do some pattern matching
14:54:45 <mauke> sinelaw: I remember the last time I did that it involved a function, possibly a continuation
14:55:13 <athan> sinelaw: Stateful yo
14:55:24 <sinelaw> athan: YOLO
14:56:05 <zedbourbaki> mgsloan: and if it tells me : "Error parsing targets: Specified target version 0.17.0.1 for package hmatrix does not match snapshot version 0.16.1.5"
14:56:30 <athan> sinelaw: Have you seen Earley?
14:56:33 <athan> I want to start using it
14:57:07 <sinelaw> nope
14:57:12 <mauke> use perl and you can use it right now :-)
14:57:15 <sinelaw> I've heard of it but haven't looked
14:57:26 <athan> :o
14:57:31 <mauke> (Marpa)
14:58:28 <mauke> sinelaw: imperative pseudocode: app = { e1 <- term; while (e2 <- term) { e1 = App e1 e2; } return e1 }
14:58:43 <maerwald> I have read a directory tree lazily via the directory-tree library, but want to convert the data structure to a more useful one... while doing so, laziness breaks and I'm not sure how to fix it http://lpaste.net/144373#line73
14:59:04 <orzo> I actually want to avoid using somebody's custom time library, http://hackage.haskell.org/package/hourglass
14:59:18 <orzo> but he's integrated it into all his libraries
15:01:06 <mgsloan> zedbourbaki: You can't currently specify different versions for packages that are in the snapshot, by passing them in as targets.  Instead, this is done with the extra-deps field.  There's no reason that these couldn't implicitly become extra-deps, though, I'll open an issue about it
15:03:10 <zedbourbaki> mgsloan: so what should I do ?
15:04:02 * hackagebot casadi-bindings 2.4.1.2 - mid-level bindings to CasADi  https://hackage.haskell.org/package/casadi-bindings-2.4.1.2 (GregHorn)
15:04:13 <mgsloan> Did you get that error from "stack install hmatrix-special-0.3.0.1"?
15:05:01 <zedbourbaki> no, from stack install hmatrix-0.17.0.1
15:07:40 <mgsloan> Right, that doesn't work, but it probably should.  This doesn't come up very much because it's most common to use stack with a stack.yaml file, and not the global config
15:08:26 <zedbourbaki> so should I learn how to use a stack.yaml file ?
15:11:51 <mgsloan> Yes, that'd be a good idea!
15:12:31 <mgsloan> One of the great things about stack is that stack.yaml files allow you to specify the exact versions of all your dependencies.  So if it builds for you, it's likely to build for others
15:14:13 <mgsloan> Quick start guide: https://github.com/commercialhaskell/stack/#quick-start-guide
15:14:24 <mgsloan> Adding extra-deps to stack.yaml: https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md#extra-deps
15:17:21 <zedbourbaki> god that looks complicated
15:17:23 <zedbourbaki> i don't know
15:20:28 <mgsloan> Stack has quite a lot of powerful features, it's quite simple for most use-cases
15:20:41 <mgsloan> So don't be put off by having a lot of documentation..
15:21:52 <maerwald> as long as you don't have deps that are not part of stack
15:22:34 <orzo> is there a way to add or subtract dependencies based on the version of a library in a cabal file?
15:22:59 <zedbourbaki> but I just don't understand the role of stack.yaml in having the right version of hmatrix for a given project ?
15:23:07 <zedbourbaki> like where do I set this ?
15:23:09 <mgsloan> maerwald: Yes, but even that case is pretty simple.  Just add the versions you want.
15:23:41 <maerwald> not really
15:23:48 <maerwald> orzo: do you want ||?
15:24:01 <johnw> orzo: I think you can do it with dependency-determined flags
15:24:07 <johnw> Flag Foo
15:24:13 <johnw> if flag(Foo)
15:24:20 <johnw>   Build-Depends: foo < 2.0
15:24:21 <johnw>   ...
15:24:35 <johnw> cabal will enable Foo if the dependency is met
15:24:44 <johnw> git-annex does this for a lot of its optional functionality
15:25:35 <orzo> maerwald: I might, got a usermanual URL for that by any chance?
15:25:45 <mgsloan> zedbourbaki: stack.yaml specifies which stackage snapshot to use.  This specifies a bunch of package versions which all build together.
15:25:55 <maerwald> orzo: something like || ( ( foo >= 1.2 )  ( foo < 1.2, bar >= 1.0 ) )?
15:26:08 <orzo> yeah i think that might work fo rme
15:26:10 <orzo> is that legal?
15:26:11 <mgsloan> 0_o
15:26:15 <maerwald> I don't think it's legal
15:26:19 <maerwald> but not sure
15:26:32 <maerwald> && and || are defined for version constraints
15:26:37 <maerwald> but not for deps in general I think
15:27:38 <maerwald> https://www.haskell.org/cabal/users-guide/developing-packages.html
15:27:53 <mgsloan> You can't put dependency conditions in cabal conditional blocks.  johnw's solution above is the correct one
15:28:07 <hexagoxel> how impossible is it to hack postfix type-specifiers for literals into ghc? like 0.3f or the like?
15:28:35 <maerwald> mgsloan: I don't think that's what he had in mind, but I could be wrong
15:28:48 <hexagoxel> (for numbers and strings/text would be sufficient for now)
15:29:32 <mgsloan> It is.  Cabal flags are a little strange and clever, and will automatically decide their value based on what dependencies are present
15:29:35 * hexagoxel hates polymorphic literals
15:34:10 <Zemyla> hexagoxel: They aren't really "literals" at all, since a value of type c => a (with c being a Constraint) gets turned into a value of type Dict c -> a, where Dict c is a dictionary of some kind.
15:35:27 <hexagoxel> i am aware. i still definitely call them literals from the syntax standpoint.
15:35:54 <zedbourbaki> mgsloan: so let's say i have followed the steps written in the link you gave. i now have a project called ls. where do i specify "use hmatrix-0.17.0.1" ?
15:36:44 <mgsloan> extra-deps:
15:36:45 <hexagoxel> Zemyla: also, i would assume the dictionary getting optimized away for any monomorphic cases, right?
15:36:50 <mgsloan> - hmatrix-0.17.0.1
15:40:42 <zedbourbaki> so let's say i am in /ls
15:41:01 <zedbourbaki> and I do "stack install hmatrix-special". it is going to install the hmatrix-special package only for that project ?
15:41:10 <Zemyla> hexagoxel: I believe so.
15:41:51 <mgsloan> Yes, but "hmatrix" will be shared with other projects that use the same resolver
15:42:32 <mgsloan> If you specify a different version of hmatrix in "extra-deps", then that one will be installed only for that project
15:42:43 <mgsloan> (as well)
15:43:23 <mgsloan> zedbourbaki: I've opened a couple issues based on the things you've encountered: https://github.com/commercialhaskell/stack/issues/1260 https://github.com/commercialhaskell/stack/issues/1261
15:47:54 <yashinbasement> Hi can any one help me in this question, https://gist.github.com/anonymous/acba4de0fb8e7eede2ff
15:48:57 <Nachtgespenst> There's no question
15:50:36 <yashinbasement> remove_font_tags ? 
15:51:17 <yashinbasement> can you open the link or it's broken ?
15:52:24 <Nachtgespenst> The link works. What issues are you having implementing this function?
15:52:38 <zedbourbaki> mgsloan: thanks :)
15:53:41 <mgsloan> welcome!
15:54:06 <yashinbasement> I don't know how to strip for p, ol, ul tag!
15:54:34 <Nachtgespenst> yashinbasement: Do you know how pattern matching works in Haskell?
15:55:22 <yashinbasement> yeah
15:58:23 <zedbourbaki> mgsloan: i don't know... I keep getting into "specified target version x.0 for package pkg-x does not match snapshot version y.0" errors, and I seem to be far down a rabbit hole of "i need to install this in order to install this" and I do not know my way out... sigh.
15:58:54 <Nachtgespenst> yashinbasement: So you add a pattern for each constructor and "rebuild" the tree on the right-hand side, except for the font tag case where you your use the subtree
16:00:13 <Nachtgespenst> *you just use
16:16:18 <mgsloan> zedbourbaki: Well, once you have a stack.yaml you shouldn't need to specify any targets on the commandline except local packages and such
16:16:44 <mgsloan> Usually you just want to use "stack build" or "stack install".
16:16:48 <zedbourbaki> so then I just need to update the global_project stack_yaml ?
16:16:51 <orzo> is there a way, in cabal, to name a list of dependencies and then refer to that symbolic name later in fields like Build-Depends?
16:16:52 <zedbourbaki> stack.yaml
16:17:18 <mgsloan> You could update the global stack.yaml with some extra-deps 
16:17:38 <zedbourbaki> ok - i think i understand. thanks !
16:18:15 <mgsloan> welcome!
16:28:10 <zedbourbaki> would someone be able to help me in following these instructions ? https://www.stackage.org/install#other-nix
16:28:19 <zedbourbaki> i decided to re-install ghc without the haskell platform
16:30:53 <meditans`> what is the correct way to write map (^?! _Fun) . filter (is _Fun)
16:31:01 <meditans`> where _Fun is a prism?
16:32:08 <Hijiri> mapMaybe (^? _Fun) ?
16:32:21 <Hijiri> meditans`^
16:32:21 <glguy> toListOf (folded._Fun)
16:33:13 <Hijiri> glguy's answer is nicer
16:34:53 <meditans`> glguy: Hijiri: thanks! :)
16:38:41 <duwang> hey guys, do you know what readln is supposed to return on blank lines?
16:40:22 <nitrix> duwang: An exception.
16:40:40 <hpc> it does whatever (read "") does
16:41:27 <hpc> which is usually supposed to be an error of some sort, but if you're silly you can make it work
16:43:09 <nitrix> When witches go riding, and black cats are seen, the moon laughs and whispers, ’tis near Halloween. Hope you're enjoying the festivities and having a scary good time! MUAHahahAHah! >:)
16:45:35 <duwang> ah ok thanks
16:48:06 <j4ck77> asking for guys on the hyperflex team talk to dries thnks
16:48:15 <j4ck77> yes haskell related
16:50:40 <zedbourbaki> hello - me again. does anyone know how to follow these instructions : "Perhaps you need to add ‘hmatrix’ to the build-depends in your .cabal file."
16:52:24 <Nachtgespenst> Open the .cabal file of the package, find the section "build-depends" in it and add "hmatrix" to the list
16:53:54 <zedbourbaki> and how do I open that file ?
16:55:08 <Nachtgespenst> It's a simple text file
16:55:22 <zedbourbaki> ok, I mean - how do I find that file ? :)
16:55:41 <Nachtgespenst> Do you have the source code of that package?
16:55:54 <Nachtgespenst> It's in the base folder of the project
16:56:10 <zedbourbaki> but I don't know where it is...
16:56:28 <Nachtgespenst> What package are we talking about?
16:57:23 <zedbourbaki> i'm trying to install hmatrix-special using stack
16:58:43 <Nachtgespenst> I don't know about stack, but you can download the source code of that package from hackage.org, and modify the .cabal file in this folder
16:59:13 <zedbourbaki> well I am using stack because apparently it is supposed to fix the problem I was having with hmatrix in firsthand
16:59:16 <zedbourbaki> so....
16:59:25 <maerwald> I'd be surprised if it does
16:59:51 <rvxi> hey
17:00:41 <zedbourbaki> i don't know, i'm not a cs person - I just want to learn Haskell :)
17:01:07 <rvxi> is there a good intro / tutorial to using quasiquotation to define custom DSLs?
17:01:15 <rvxi> (besides the wiki here)
17:01:17 <rvxi> https://wiki.haskell.org/Quasiquotation
17:04:41 <zedbourbaki> it tells me the same error no matter what I do
17:05:13 <Nachtgespenst> What error?
17:05:36 <zedbourbaki>  Perhaps you need to add ‘hmatrix’ to the build-depends in your .cabal file.
17:06:46 <jophish> rvxi: it might be useful to look at how some other libraries do it
17:07:31 <rvxi> jophish: ii can try but im still relatively beginner-intermediate at the moment
17:09:28 <wolfcore> zedbourbaki: hmatrix is already listed in the build-depends of hmatrix-special
17:09:45 <zedbourbaki> wolfcore: so then why do I have that mistake ?
17:09:51 <wolfcore> zedbourbaki: You need to add hmatrix to your own project's cabal file I think
17:10:06 <zedbourbaki> wolfcore: ok but I mean, I am working in the global project
17:10:48 <zedbourbaki> wolfcore: so how do I add hmatrix to the global project ? I tried adding hmatrix to the .yaml file, but it doesn't seem to change anything
17:11:04 <rvxi> jophish: any particular libraries i should read?
17:15:54 <wolfcore> zedbourbaki: Because to install a package with stack you need to put the package name in the cabal file
17:16:09 <wolfcore> zedbourbaki: stack.yaml is for when you want to specify a version
17:17:00 <zedbourbaki> I don't get it.
17:17:18 <zedbourbaki> I just don't understand what I am suppose to do since there is no .cabal file in my .stack folder
17:17:39 <wolfcore> zedbourbaki: Are you trying to add hmatrix to a project? Why do you need to install globally
17:17:49 <bitemyapp> zedbourbaki: did ya watch the tutorial?
17:17:58 <zedbourbaki> wolfcore: because I am going to use it in multiple projects and I don't want to re-install it each time
17:18:06 <bitemyapp> zedbourbaki: you don't do that manually
17:18:11 <bitemyapp> zedbourbaki: Stack handles sharing dependencies.
17:18:15 <bitemyapp> zedbourbaki: please watch the tutorial I linked you.
17:18:32 <bitemyapp> zedbourbaki: https://www.youtube.com/watch?v=sRonIB8ZStw
17:19:10 <wolfcore> zedbourbaki: when you install something with stack it installs it separately from the project and reuses it in other projects
17:20:56 <zedbourbaki> wolfcore: so does that means I cannot install something globally or.... ?
17:21:17 <bitemyapp> zedbourbaki: you don't need to, you wouldn't want to, it wouldn't do any good
17:21:21 <wolfcore> zedbourbaki: no, that's not how stack works
17:21:26 <bitemyapp> zedbourbaki: stop trying to do something pointless
17:21:34 <bitemyapp> zedbourbaki: you wouldn't want to install something globally even without Stack.
17:21:37 <zedbourbaki> bitemyapp: but i don't see why it is pointless
17:21:48 <bitemyapp> zedbourbaki: at most, you'd install it into your user package database, and again, Stack obviates needing to worry about this.
17:22:02 <bitemyapp> zedbourbaki: it is pointless if you understand what the tool is doing for you so that you don't have to think about it.
17:22:03 <wolfcore> zedbourbaki: if you try to use the same package in a different project it will reuse the copy you installed earlier
17:22:26 <bitemyapp> zedbourbaki: check out the video, we demonstrate how the dependency sharing works w/ Stack.
17:22:28 <wolfcore> zedbourbaki: installed packages don't go into the project itself, they are kept separate and managed by stack
17:23:16 <zedbourbaki> wolfcore: i get that, but then why won't 'stack install hmatrix-special' work ?
17:23:39 <wolfcore> you have to add hmatrix-special to your cabal file and then do stack install
17:23:47 <wolfcore> the cabal file of a project
17:23:50 <wolfcore> not global
17:24:17 <bitemyapp> zedbourbaki: stack install isn't what you think, either
17:24:27 <bitemyapp> zedbourbaki: all stack install does is copy binaries to ~/.local/bin if any were created
17:24:35 <bitemyapp> zedbourbaki: all you need to have a package available is stack build.
17:24:44 <troydm> any idea why stack segfault? http://lpaste.net/1650261249851654144
17:25:35 <rvxi> bitemyapp:  hey i have a pdf of your book open right now :)
17:25:38 <bitemyapp> zedbourbaki: https://www.stackage.org/lts-3.11 ctrl-f "hmatrix"
17:25:41 <bitemyapp> rvxi: awesome :)
17:26:11 <bitemyapp> zedbourbaki: that's what Stack knows about as part of the LTS snapshots by default. Anything else has to be specified with a particular version manually.
17:26:23 <bitemyapp> zedbourbaki: for a project to be able to use the dependency, it has to be in the build deps.
17:26:43 <bitemyapp> example: I have lens installed already because I did 'stack build lens' outside a project.
17:26:51 <bitemyapp> I make a new project that uses the same lts as i built 'lens' for.
17:27:04 <bitemyapp> that's all hunky dory, but that project won't be able to "see" lens until it's in the build-deps of the Cabal project.
17:27:24 <zedbourbaki> so then how do I add hmatrix to build-depends to the cabal file in my project ?
17:27:27 <bitemyapp> zedbourbaki: https://github.com/bitemyapp/bloodhound/blob/master/bloodhound.cabal#L31-L48
17:27:54 <bitemyapp> zedbourbaki: https://github.com/bitemyapp/bloodhound/blob/master/stack-7.10.yaml the stuff you see specified in extra-deps is stuff the LTS snapshot didn't have or for which I needed to override the version.
17:28:08 <bitemyapp> rvxi: how are you liking it so far?
17:28:21 <wolfcore> hmatrix-special isn't in stack
17:28:53 <bitemyapp> zedbourbaki: and as wolfcore said, hmatrix-special isn't part of the LTS snapshot, so it has to be specified in the stack.yaml for your project.
17:29:09 <bitemyapp> zedbourbaki: that's why I asked you to ctrl-f hmatrix so you could see how to determine what's available.
17:29:32 <rvxi> bma: enjoying it. i worked through 80% of cis194 prior to reading, so most things are review so far
17:29:43 <bitemyapp> rvxi: cool. glad you're enjoying it!
17:30:03 <bitemyapp> rvxi: could you write me when you've gotten further and let me know how you think it compares?
17:30:13 <rvxi> found possibly a typo or two, may have some minor feedback on some parts if you're interested.
17:30:17 <rvxi> will do
17:30:27 <bitemyapp> http://haskellbook.com/support.html feedback/typos can go here
17:30:36 <bitemyapp> rvxi: ^^ there's a mailto: for an email that my coauthor and I share.
17:31:02 <rvxi> ok will make use of that
17:31:14 <rvxi> btw if there's a new version will i get an email notice or anything?
17:31:30 <bitemyapp> rvxi: you should, yes.
17:31:52 <zedbourbaki> bitemyapp: thanks, I think I understand. I added hmatrix to the library, but now I get an error when I do "stack build"
17:32:32 <bitemyapp> zedbourbaki: http://lpaste.net/ lets see it
17:32:58 <bitemyapp> troydm: that is pretty odd, could you report that please?
17:33:12 <zedbourbaki> bitemyapp: what part do you want to see ?
17:33:20 <wolfcore> zedbourbaki: all of it
17:33:26 <bitemyapp> zedbourbaki: all of itr
17:33:26 <zedbourbaki> all of what ?
17:33:28 <troydm> bitemyapp: sure
17:33:38 <bitemyapp> zedbourbaki: all of the output the command you ran, as well as the command you ran
17:34:13 <bitemyapp> zedbourbaki: the contents of your stack.yaml, the cabal file, the overall project tree
17:37:51 <zedbourbaki> bitemyapp: http://lpaste.net/144376
17:39:23 <bitemyapp> zedbourbaki: need a comma after each package in build-depends
17:39:33 <bitemyapp> zedbourbaki: look at the example cabal file I linked from Bloodhound
17:40:55 <zedbourbaki> bitemyapp: you are most correct 
17:42:30 <zedbourbaki> bitemyapp: so now, I can do "stack build" and it seems to work, and then i do "stack exec ls-exe" and it does nothing, as it should since ls is empty. and now I want to install hmatrix-special but it still tells me to add hmatrix to the .cabal file. what is it that i do not get ?
17:43:05 <bitemyapp> zedbourbaki: the cabal file you linked me doesn't mention hmatrix-special
17:43:22 <orzo> can a test suite integrated with cabal build a pretty (and long) report in html format?  I have a testsuite with over 700 tests that generates a pretty report, but i am adapting it to haskell/cabal.
17:47:55 <cow_20013> how do you pronounce (^.) from the lens library?
17:48:13 <jophish> cow_20013: view?
17:48:27 <jophish> :t (^.)
17:48:28 <lambdabot> s -> Getting a s a -> a
17:48:29 <jophish> :t view
17:48:31 <lambdabot> MonadReader s m => Getting a s a -> m a
17:48:41 <cow_20013> ah! thanks
17:49:04 <zedbourbaki> bitemyapp: i'm not saying anything cause things seems to be working. i'll be back as soon as I have results that it is or isn't :)
17:49:27 <jophish> cow_20013: or alternatively however you pronounce . or -> in other languages such as C
17:49:37 <bitemyapp> zedbourbaki: cool :)
17:54:03 <zedbourbaki> bitemyapp: yay! it works - i just finished running the tests of hmatrix :)
17:54:11 <zedbourbaki> bitemyapp: thanks for being so patient with me !
17:54:27 <bitemyapp> zedbourbaki: glad to help :)
17:54:31 <zedbourbaki> wolfcore: thank you for your help and your explanations :) it seems to be working !
17:55:17 <zedbourbaki> bitemyapp: i think it was you that said I should do a how-to to help future users ? I will :)
17:55:36 <nex> hello, i'm trying to add an element to a list defined in my data type, i can't find how to access it.. http://lpaste.net/144378
17:59:37 <bitemyapp> zedbourbaki: hrm, not sure if it was me - don't want to accidentally take credit. Sounds like a good idea to me either way to me :)
18:00:03 <jophish> :( I want injective type families 
18:00:07 <maerwald> fascinating, does anyone know why traversal within IO tainted data structures does only work lazily with unsafePerformIO?
18:01:28 <jophish> Couldn't match expected type Int with actual type V a; I have a type family instance V a = Int
18:03:42 <bitemyapp> maerwald: what would "lazily" entail here?
18:03:55 <maerwald> bitemyapp: https://hackage.haskell.org/package/directory-tree-0.12.0/docs/src/System-Directory-Tree.html#buildLazilyUnsafe%27
18:04:42 <maerwald> if you do the stuff without unsafeperformio within the do-block, then it is not lazy anymore
18:16:57 <nitrix> Hi, is it possible to get the type of a where clause in ghci ?
18:17:26 <nitrix> Maybe some dot notation or something?
18:18:20 <nitrix> Or just bringing the where clause into scope.
18:19:57 <MarcelineVQ> you can use something called typed holes to get the compiler to tell you what type something should be
18:20:10 <MarcelineVQ> > "blah" ++ _
18:20:12 <lambdabot>      Found hole ‘_’ with type: [Char]
18:20:12 <lambdabot>      In the second argument of ‘(++)’, namely ‘_’
18:20:12 <lambdabot>      In the expression: "blah" ++ _
18:22:23 <Profpatsch> Okay, dumb question:
18:22:36 <bitemyapp> nitrix: if you need typeclass constraints, you can use: (undefined :: a) in lieu of a typed hole.
18:22:38 <nitrix> MarcelineVQ: I'm not looking for what the type of something should be, but what it IS.
18:22:44 <Profpatsch> I’ve got a function fun :: Monad m => a -> m b
18:22:44 <bitemyapp> > "blah" ++ (undefined :: a)
18:22:46 <lambdabot>  "blah*Exception: Prelude.undefined
18:22:52 <bitemyapp> oh, oops.
18:22:53 <nitrix> bitemyapp: I'm not looking for a constraint either.
18:23:06 <bitemyapp> nitrix: well, I do have a solution for this.
18:23:14 <Profpatsch> And I’ve got maybe mempty <fun> <maybeval>
18:23:15 <bitemyapp> nitrix: what I do is assert the type ":: a" for the where clause
18:23:25 <nitrix> I found a solution too.
18:23:31 <bitemyapp> nitrix: what'd ya do?
18:23:45 <nitrix> I can `:step f args`, then do `:step` again and suddently the where clauses are in scope.
18:23:48 <Profpatsch> How do I insert fun into that maybe?
18:24:15 <Profpatsch> In other words, how do I make it that maybe :: b -> (a -> m b) -> Maybe a -> b
18:24:42 <nitrix> bitemyapp: The only problem is it requires evaluation. I was hoping I could just do some kind of `:t f:g`.
18:26:00 <MarcelineVQ> nitrix: but you can find out what things are if you know what they should be. check out `asTypeOf` https://ro-che.info/articles/2014-03-13-type-of-local-function
18:27:04 <nitrix> > 5 `asTypeOf` _
18:27:05 <lambdabot>      Found hole ‘_’ with type: a
18:27:05 <lambdabot>      Where: ‘a’ is a rigid type variable bound by
18:27:05 <lambdabot>                 the inferred type of it :: a at <interactive>:1:1
18:27:16 <nitrix> > (5::Int) `asTypeOf` _
18:27:17 <lambdabot>      Found hole ‘_’ with type: Int
18:27:17 <lambdabot>      In the second argument of ‘asTypeOf’, namely ‘_’
18:27:17 <lambdabot>      In the expression: (5 :: Int) `asTypeOf` _
18:27:20 <nitrix> Nice.
18:27:27 <bitemyapp> nitrix: notice that it just says "a"
18:27:33 <bitemyapp> nitrix: that's the missing typeclass constraint I was talking about.
18:27:54 <bitemyapp> (because 5 is Num a => a)
18:28:30 <nitrix> MarcelineVQ: Very useful, thanks :)
18:28:51 <MarcelineVQ> I comes up every once in awhile from someone smarter in this channel, I just managed to remember it this time
18:29:28 <Profpatsch> MarcelineVQ: That’s brilliant.
18:33:08 <orzo> If i need my test suite to auto-detect the source tree path, what's the idiomatic way to do that?
18:38:37 <Profpatsch> Okay, maybe that was the wrong approach.
18:53:14 <bitemyapp> https://joeyh.name/blog/entry/a_tiling_region_manager_for_the_console/ too cool.
18:54:44 <jophish> I have a gadt with a constructor of the form Con :: F a -> D a; were F is a closed type family. How can I pattern match on this constructor?
18:55:17 <jophish> Whatever I try, ghc (7.10) is unable to unify F a and F Int (for example)
18:55:32 <jophish> As far as I can tell, this requires injective type families
18:59:12 <Profpatsch> How do I enable dynamic linking for a cabal build?
19:19:50 <lpaste> emmanuel_erc pasted “Getting a nice speed up with unboxed vectors. Any takers on how to get this to run faster?” at http://lpaste.net/144380
19:20:32 <emmanuel_erc> hello there
19:20:45 <emmanuel_erc> was there just a post about a new paste?
19:23:44 <Profpatsch> emmanuel_erc: Yes.
19:23:50 <emmanuel_erc> Oh...
19:23:53 <emmanuel_erc> Cool.
19:28:22 <emmanuel_erc> Do you have anything to say about Profpatsch?
19:30:31 <Profpatsch> emmanuel_erc: I have no experience with impoving the speed of programs.
19:30:45 <emmanuel_erc> oh...
19:30:46 <emmanuel_erc>  
19:52:51 <hackrilege> http://lpaste.net/144381 can anyone help me understand the error at the bottom of this paste when running cabal bootstrap.at?
19:53:03 <hackrilege> .sh
20:02:15 <KaneTW> do 'ls /usr/lib/ghc/include/sys/cdefs.h'
20:08:48 <duwang> how do I cast the output of (read line) to a string?
20:09:13 <KaneTW> why would you want to do that
20:09:18 <KaneTW> line :: String
20:10:08 <duwang> Im passing the input I get to a function that takes a string, but in order for it to work I have to type " " around whatever I pass it, so I was wondering if there was a way to make read output a string directly
20:10:30 <KaneTW> read line :: String should do it
20:10:48 <duwang> alright, sweet, thanks
20:11:04 <glguy`> You shouldn't need to do anything extra if you're using it as a string, the type should infer
20:11:44 <glguy`> f (read line)
20:11:53 <KaneTW> ^
20:12:13 <duwang> yeah but whatever is read has to have quotes around it. For example, "3" works but 3 leads to an error
20:12:15 <Nachtgespenst> That's probably the reason for the need of extra quotes
20:12:43 <duwang> yeah i need to simulate a repl so the quotes seem like they shouldn't be there
20:12:57 <Nachtgespenst> duwang: You should paste your code for context
20:13:25 <duwang> kk
20:13:40 <duwang> line <- getLine
20:13:52 <duwang> putStrLn (octoprint (read line))
20:13:58 <glguy`> ?paste
20:13:59 <lambdabot> Haskell pastebin: http://lpaste.net/
20:14:18 <Nachtgespenst> Don't use read there, line is already a String
20:14:31 <duwang> ohhhhh
20:14:33 <duwang> ok thanks
20:15:35 <duwang> yeah works like a charm
20:17:48 <hackrilege> kanetw there is no sys file in include
20:24:34 <hackrilege> Why is this not coming with the Haskell platform? Cabal just gives a config failed error
20:34:21 <KaneTW> it shouldn't exist
20:34:30 <KaneTW> you probably messed up the ghc install somewhere
20:34:55 <KaneTW> try doing a clean install without -platform
20:35:12 <KaneTW> https://github.com/bitemyapp/learnhaskell/blob/master/install.md
20:36:15 <KaneTW> you're on an apt system so just do the ppa thing but don't specify a version
20:36:28 <KaneTW> just let it install the highest available
21:03:23 <ezyang> How accurate/inaccurate would you rate the claim, "The polymorphic function a -> a is a subtype of Int -> a" 
21:03:46 <ezyang> (or Int -> Int, if you prefer your functions to be inhabited...) 
21:04:44 <ezyang> hmm, this doesn't work at all 
21:06:05 <ezyang> I guess the example needs to be, a -> b is a subtype of Int -> b 
21:10:20 <MrSkeltal> ezyang, it'll be much clearer if you write out your foralls and exists
21:12:34 <ezyang> MrSkeltal: Well, if you write out the foralls obviously they're not subtypes 
21:13:00 <ezyang> because each forall needs a type application. But I wonder if it's convenient to blur the distinction 
21:27:24 <KaneTW> ezyang: define your subtyping relation
21:29:38 * hackagebot th-desugar 1.5.5 - Functions to desugar Template Haskell  https://hackage.haskell.org/package/th-desugar-1.5.5 (RichardEisenberg)
22:00:20 <Myrlevolent> Hai.
22:00:52 <Myrlevolent> Hi guys.
22:02:00 <KaneTW> hi
22:02:06 <Myrlevolent> wei2912: ohi.
22:02:15 <wei2912> Myrlevolent: hi
22:02:29 <Myrlevolent> wei2912: I already have a plan.
22:05:53 <ezyang> KaneTW: Well, a traditional HAskell style type system doesn't have a subtype relation or subsumption rule 
22:15:46 <tombert> anyone here able to help?  I'm looking for high-ish level bindings for graphics
22:16:21 <tombert> sdl2 is ok, but the lack of documentation is kind of a blocker
22:16:46 <tombert> I know I can use the C docs, but I find I have to read the source code to understand how the types work
22:17:06 <Adeon> tombert: if documentation is missing from hackage, just go to an earlier version of the package
22:17:09 <Adeon> changes are minimal
22:17:24 <Adeon> me guesses someone didn't upload the docs
22:17:48 <tombert> Oh there you go, that solves that problem
22:17:54 <tombert> I can happily use SDL now
22:18:00 <Adeon> :-)
22:18:10 <tombert> and to think I was about to use GLUT...GLUT I say!
22:18:19 <Adeon> still, depending on how advanced graphics you need, SDL might not be enough
22:18:29 <tombert> oh, no, I'm working on a basic 2D game
22:18:35 <tombert> SDL should be sufficient
22:18:36 <Adeon> oh okay, then it should be enough
22:18:57 <tombert> and SDL will handle a lot of the abstractions with audio and the like
22:19:11 <tombert> so I think it'll give me an advantage
22:20:58 <tombert> Adeon: any experience making SDL talk to netwire?
22:21:20 <tombert> I'm not necessarily married to netwire, it just kind of seems to be the most mature framework for what I want to do
22:22:21 <Adeon> none
22:22:48 <Adeon> the SDL package doesn't have any special support or conveniences for FRP frameworks as far as I know[D
22:24:16 <tombert> that seems to be my impression, though I the nice thing about netwire is it's relatively easy to adapt other stuff into it
22:25:10 <tombert> I think I can fairly easily adapt the keyboard listener functions into an FRP-ish thing
22:30:01 <KaneTW> ezyang: yeah, but you have something in mind when saying subtype
22:32:21 <ezyang> KaneTW: usually, it's something like "S is a subtype of T if, whereever you have a t :: T, you can use an s :: S instead." 
22:33:25 <KaneTW> hm
22:35:06 <Melonpan> Can I link Haskell RTS to my own mmap?
22:35:08 <shachaf> I'm still interested in how lenses and other optics behave as explicit subtyping witnesses in the presence of mutability.
22:35:28 <KaneTW> i think that analogy works as substitutions work on the whole type only so you can't do something like Int -> a subtype a -> a (but instead have to do Int -> Int subtype a -> a)
22:35:34 <KaneTW> as long as*
22:41:46 <ezyang> Melonpan: If you rebuild GHC, certainly. I don't know if mmap is a dynamically resolved symbol though 
22:42:36 <ezyang> KaneTW: hmmk 
22:42:56 <ezyang> you could try LD_PRELOAD'ing it and then seeing if it sticks or not 
22:43:11 <Melonpan> ezyang: Can you elaborate on that?
22:44:14 <ezyang> Melonpan: something like http://hackerboss.com/overriding-system-functions-for-fun-and-profit/ (have not read the article in question) 
22:49:30 <zomg> Melonpan: you have such an unfortunate nick... lol
22:49:53 <Melonpan> zomg: why? :c
22:50:30 <zomg> Look up the youtube user with the same name and you'll see :D
22:50:31 <Melonpan> zomg: melonpan is nice. http://cdn.tokyotimes.com/wp-content/uploads/2010/03/4f51b542eb21c073ccc38521c4e58b8a1.jpg
22:51:18 <Melonpan> zomg: oh no.
22:51:40 <zomg> yeah... :D
22:52:01 <Melonpan> zomg: I remember Hestia...
22:53:28 <Melonpan> zomg: And that KlK one.
22:54:01 <zomg> Yeah I don't know about those much, but the guy's videos are pretty nuts =)
22:54:23 <Melonpan> zomg: yep.
23:01:35 <Zemyla> What libraries use :^? Because (:^) always looks like a happy face.
23:29:18 <tekkkz> Hello! You remember I wanna make a Bot for http://www.radiobrocken.de/voting/schule/winckelmann-gymnasium-stendal . So after trying some HTTP libs I decided for WREQ. But now my problem is: How to crawl the captcha image? It's canvas, so how to get its URL? Any ideas?
23:49:21 <tekkkz> toDataURL :: MonadIO m => Canvas -> m URL from Haste.Graphics.Canvas, how does it works?
