00:07:39 * hackagebot acid-state 0.13.1 - Add ACID guarantees to any serializable Haskell data structure.  https://hackage.haskell.org/package/acid-state-0.13.1 (DavidJohnson)
00:07:39 * hackagebot yesod-websockets 0.2.4 - WebSockets support for Yesod  https://hackage.haskell.org/package/yesod-websockets-0.2.4 (MichaelSnoyman)
00:16:26 <epta> is the record of this talk https://github.com/ChicagoHaskell/servant-presentation uploaded somewhere?
00:57:37 * hackagebot singleton-nats 0.4.0.1 - Unary natural numbers relying on the singletons infrastructure.  https://hackage.haskell.org/package/singleton-nats-0.4.0.1 (AndrasKovacs)
00:57:43 <joco42> what is the best way to do haskell code folding  in emacs?
01:03:26 <zv> joco42 with or without evil?
01:08:22 <joco42> zv any ways are good
01:08:25 <joco42> i have evil
01:08:30 <joco42> but zc does not work...
01:08:46 <joco42> and zc does work for python... but not for haskell... strange
01:11:22 <tdammers> joco42: :set foldmethod?
01:11:34 <joco42> tdammers:  i have a look
01:12:01 <tdammers> wait, evil, not actual vim... no idea whether it works the same then
01:12:30 <joco42> tdammers:  it does not work...
01:13:03 * hackagebot ideas 1.4 - Feedback services for intelligent tutoring systems  https://hackage.haskell.org/package/ideas-1.4 (BastiaanHeeren)
01:13:21 <joco42> maybe i need to try this https://wiki.haskell.org/Emacs/Code_folding
01:13:25 <joco42> :)
01:13:52 <tdammers> I'm a vim person myself, so can't help you with emacs
01:13:58 <tdammers> my religion doesn't allow it
01:14:00 <tdammers> ;)
01:15:39 <EvanR> vi vi vi 
01:16:53 <tdammers> escape meta alt control shift
01:17:22 <EvanR> and the keyboard crapped out
01:30:46 <Copperis> @let one = [(*)] <*> [1, 2, 3]
01:30:48 <lambdabot>  Defined.
01:30:53 <Copperis> @type one
01:30:55 <lambdabot> Num a => [a -> a]
01:31:16 <Copperis> @let two = pure (*) <*> [1, 2, 3]
01:31:17 <lambdabot>  Defined.
01:31:21 <Copperis> @type two
01:31:22 <lambdabot> Num a => [a -> a]
01:32:02 <Copperis> oh, right
01:33:06 <opqdonut> https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Base.html#line-717
01:33:11 <opqdonut> pure x = [x]
01:33:52 <Copperis> yup. The second one threw an error for me in ghci. But after inspecting the error, I actually saw that it was for not having a Show instance
02:13:07 * hackagebot haskell-read-editor 0.1.0.0 - Opens a temporary file on the system's EDITOR and returns the resulting edits  https://hackage.haskell.org/package/haskell-read-editor-0.1.0.0 (yamadapc)
02:13:09 * hackagebot read-editor 0.1.0.0 - Opens a temporary file on the system's EDITOR and returns the resulting edits  https://hackage.haskell.org/package/read-editor-0.1.0.0 (yamadapc)
02:23:07 * hackagebot read-editor 0.1.0.1 - Opens a temporary file on the system's EDITOR and returns the resulting edits  https://hackage.haskell.org/package/read-editor-0.1.0.1 (yamadapc)
02:32:13 <concept3d> Hello all, I have this weird issue where the CPU reaches 100% when I try to read TVarIO [Clients], and then access it the CPU goes 100% and the service hangs, it only happens when other thread removes a client from TVar[Client]
02:32:24 <concept3d> here is the code http://lpaste.net/6605908809351168000
02:36:29 <Unhammer> how do I get ghci to not show all the open modules?
02:37:04 <merijn> Unhammer: Use the ':set prompt "λ "' command
02:37:23 <merijn> Unhammer: You can replace the "λ " part with whatever you like, of course
02:37:43 <frerich> You can, but using 'λ ' is a law.
02:37:44 <merijn> Unhammer: Put that command in ~/.ghci (on *nix) to have it automatically run when you start ghci
02:37:47 <Myrl> :set prompt \lambda
02:37:57 <Myrl> frerich: Can I use this instead? ^
02:38:09 <Myrl> I don't have a unicode input. :(
02:38:31 <merijn> Myrl: Which OS?
02:38:55 <Myrl> merijn: What do you mean which OS? There's only one OS and that's called Gentoo.
02:39:05 <frerich> Myrl: You can use a caret ('^'), sure. Do you really need Unicode *input*? Can't you just paste ':set prompt "λ: "' into your ghci? :-)
02:39:16 <tdammers> isn't gentoo a very large number of possible OSes?
02:39:26 <Unhammer> hm, must be something about ob-haskell.el, because it keeps showing them
02:39:29 <Myrl> tdammers: Shhh.
02:39:30 <jle`> not if you redefine OS as "things that are gentoo"
02:39:39 <merijn> Myrl: Ah, then I don't know. I have a nice input method setup on OSX that lets me type LaTeX commands have them turn into unicode characters
02:39:53 <Myrl> I actually have fcitx.
02:39:55 <Myrl> I'm just too lazy.
02:40:17 <Myrl> I think fcitx will allow latex.
02:40:36 <Myrl> Problem is I don't know latex. :)
02:40:54 <Myrl> Where should I learn?
02:41:07 <Myrl> Preferably where it also has the mathematical meanng of it.
02:41:09 <Myrl> meaning8
02:41:11 <Myrl> meaning*
02:41:22 <jle`> it looks like you already know enough latex to put in the lambda character
02:41:33 <jle`> seeing as you just wrote it out four minutes ago :)
02:41:47 <Myrl> jle`: Yeah, I know very basic stuff.
02:41:53 <Myrl> Such as \prod, \exists
02:41:58 <Myrl> Heck, thatm ay be wrong.
02:42:02 <Myrl> :s
02:54:13 <LambaScript> hey guys i have a question
02:54:57 <frerich> tdammers: I think Gentoo is indeed a large class of possible OSes, and they are all compiling with -O9 ;->
02:54:59 <merijn> LambaScript: Just ask :)
02:55:43 <LambaScript> i have two integers separated by a space.. how do i get those?
02:56:05 <julianleviston> LambaScript: what do you mean?
02:56:59 <julianleviston> LambaScript: do you mean this? "5 7"
02:57:01 <julianleviston> LambaScript: and what do you mean by “get” ? :)
02:57:20 <LambaScript> like this: "15 8".. are there an easy way to extract those values?
02:57:34 <julianleviston> LambaScript: oh… right… so the function is read
02:57:37 <julianleviston> :t read
02:57:39 <lambdabot> Read a => String -> a
02:58:12 <LambaScript> so what happens to the space?
02:58:22 <julianleviston> but you’ll have to split them into two strings first, probably.
02:58:35 <LambaScript> is there a function for that?
02:58:45 <frerich> LambaScript: You can use 'words' to split your string into two tokens and then use 'readMaybe' (from Text.Read) to try to massage the tokens into an integer.
02:58:46 <MarcelineVQ> words can nuke the space
02:58:47 <solarus> :t words
02:58:48 <lambdabot> String -> [String]
02:59:06 <frerich> > map readMaybe (words "42 3 garbage 9") :: [Maybe Int]
02:59:07 <lambdabot>  Not in scope: ‘readMaybe’
02:59:19 <frerich> Pity. But it's there. :-)
03:00:43 <MarcelineVQ> the issue with a plain read is that it needs well formed input or it'll throw an exception
03:01:00 <MarcelineVQ> > (map read . words) "2343 542 23 1 98" :: [Int] -- here's an example of using it though
03:01:02 <lambdabot>  [2343,542,23,1,98]
03:01:38 <Copperis> > reads "12gffs" :: [(Int, String)]
03:01:40 <lambdabot>  [(12,"gffs")]
03:01:42 <MarcelineVQ> alternativly you can use `readMaybe` or `reads`
03:03:09 * hackagebot compactmap 0.1.2 - A read-only memory-efficient key-value store.  https://hackage.haskell.org/package/compactmap-0.1.2 (SimonMarechal)
03:04:27 <ski> > replicateM 3 (StateT (reads :: ReadS Int)) `runStateT` "2343 542 23 1 98"  -- LambaScript
03:04:29 <lambdabot>  [([2343,542,23]," 1 98")]
03:05:21 <ski> > [ns | (ns,s) <- many (StateT (reads :: ReadS Int)) `runStateT` "2343 542 23 1 98",("","") <- lex s]
03:05:23 <lambdabot>  [[2343,542,23,1,98]]
03:05:35 <julianleviston> lol nice and simple lol
03:06:14 <MarcelineVQ> I really like seeing StateT in action, even though I don't quite get it yet
03:06:20 <julianleviston> :t lex
03:06:22 <lambdabot> ReadS String
03:06:39 <ski> `lex' there eats any trailing space in the string
03:06:58 <julianleviston> oh… so it’s not a lexer?
03:07:04 <ski> it is
03:07:08 <julianleviston> I don’t really understand that type.
03:07:23 <ski> > lex "(1 + 2) * 3"
03:07:24 <lambdabot>  [("(","1 + 2) * 3")]
03:07:53 <ski>   type ReadS a = String -> [(a,String)]
03:07:58 <ski> so
03:08:14 <ski>   lex :: String -> [(String,String)]
03:08:22 <ski> @type reads
03:08:24 <lambdabot> Read a => ReadS a
03:08:27 <julianleviston> ahhh ok.
03:08:37 <ski>   reads :: Read a => String -> [(a,String)]
03:08:56 <ski>   readsPrec :: Read a => Int -> String -> [(a,String)]
03:09:21 <ski> (and `readParen')
03:09:26 <julianleviston> what’s the Prec mean? I see that on Groundhog all the time
03:09:45 <ski> reads within a given precedence level context
03:10:58 <fizruk> where can I point someone for an up-to-date "Why use Haskell in your project"?
03:11:05 <merijn> To be honest, once you're doing stuff like this you're close to/at the point where you probably wanna just use a parser combinator library
03:11:36 <merijn> Especially since ReadS is slow as shit :)
03:11:52 <julianleviston> @why haskell
03:11:52 <lambdabot> Maybe you meant: wn what thx ghc
03:11:59 <julianleviston> @what haskell
03:11:59 <lambdabot> http://haskell.org
03:12:04 <julianleviston> @what why haskell
03:12:04 <lambdabot> I know nothing about why.
03:12:15 <julianleviston> @where why haskell
03:12:15 <lambdabot> I know nothing about why.
03:12:25 <julianleviston> maybe we should set one.
03:12:26 <ski> > (readsPrec 0 :: ReadS Rational) "-12 % 3"
03:12:29 <lambdabot>  [((-4) % 1,"")]
03:12:30 <ski> > (readsPrec 7 :: ReadS Rational) "-12 % 3"
03:12:34 <lambdabot>  [((-4) % 1,"")]
03:12:36 <ski> > (readsPrec 8 :: ReadS Rational) "-12 % 3"
03:12:37 <lambdabot>  []
03:12:41 <ski> > (readsPrec 8 :: ReadS Rational) "(-12 % 3)"
03:12:43 <lambdabot>  [((-4) % 1,"")]
03:12:46 <ski> > (readsPrec 7 :: ReadS Rational) "(-12 % 3)"
03:12:47 <lambdabot>  [((-4) % 1,"")]
03:12:59 <ski> because `infixl 7 %'
03:14:18 <ski> at precedence level greater than `7', `readsPrec' requires a wrapping pair of brackets
03:22:02 <callumacrae> I'm trying to calculate a calculate a formula, so I wrote it in haskell. It takes 20 minutes to run and then runs out of memory and then quits.
03:22:05 <callumacrae> https://gist.github.com/callumacrae/5fd7dd85b71da4b3b969
03:22:11 <callumacrae> Any ideas how I can get it to run? Maybe on EC2 or something?
03:23:00 <MarcelineVQ> try foldl1'
03:23:26 <MarcelineVQ> dunno if that'll solve anything algorithm-wise but it should cut down some memory
03:23:38 <ahihi> or compiling with -O2
03:25:05 <concept3d> hey guys anyone ? http://lpaste.net/6605908809351168000
03:25:53 <concept3d> I have this weird issue where the CPU reaches 100% when I try to read TVar [Clients], and then access it, the CPU goes 100% and the service hangs, it only happens when other thread removes a client from TVar[Client]
03:26:02 <MarcelineVQ> callumacrae: foldl' and foldl1' are strict versions of foldl that compute the accumulation as it happens, which cuts down on building up the accumulation in memory
03:27:00 <callumacrae> MarcelineVQ: Thank you, I'm trying that now :)
03:27:30 <callumacrae> It's using 17.66GB memory and I don't actually have that much memory
03:27:32 <callumacrae> interesting
03:30:17 <liste> virtual memory, that means that it should be swapping a lot
03:31:02 <quicksilver> c_wraith, johnw: mostly left associated but more memptys than you'd expect, was the answer to that experiment
03:31:48 <MarcelineVQ> callumacrae: well you do compute 3 entire factorials per folded item, there's ways to reuse parts that will save on computations but I don't know them that well. I'm not very good at algebra but there's repeats of terms in your main fold that look like they can be factored out
03:34:57 <callumacrae> Yeah I'm calculating some stuff twice. Will fix that too
03:35:13 <megazword> Iceland_jack: 632 a post was made on ynewscombinator.com item id = 7161236
03:35:25 <megazword> Iceland_jack: 632 days ago
03:35:29 <callumacrae> Alternatively, is there any way to memoize a function in haskell? or does that count as a side effect?
03:36:07 <MarcelineVQ> sure https://wiki.haskell.org/Memoization
03:36:36 <megazword> Iceland_jack: we are coming to get you
03:38:03 <callumacrae> I forgot to test this with small numbers. "NaN" :(
03:39:34 <ski> callumacrae :  n `p` 0 = ?
03:40:09 <ski> (note that `h' can be `0')
03:40:26 <quicksilver> callumacrae: other points : (1) use strict folds (foldl' and foldl1'), (2) it's daft to calculate n `p` x-h twice
03:40:36 <quicksilver> but ski has the most important point of all :)
03:40:55 <quicksilver> oh (3) don't use **
03:41:10 <quicksilver> use ^ and stick to Integer I suppose.
03:41:37 <quicksilver> if you really wanted a floating point approximation I guess you'd use the approximate formula for factorial too.
03:42:03 <callumacrae> The output should be a whole number
03:42:32 <callumacrae> the division is for a permutation of a multiset, and should be a whole number unless I have messed up something else: https://en.wikipedia.org/wiki/Permutation#Permutations_of_multisets
03:43:30 <quicksilver> agreed it will be a whole number. That's why I think y ou want ^ and Integer
03:43:37 <callumacrae> yep, changing that now
03:44:36 <quicksilver> I have a version which gives an answer (quickly) to the "2 4" case
03:44:57 <ski> callumacrae : you're computing multinomial coefficients ?
03:45:31 <callumacrae> I don't know what that means :(
03:46:02 <ski> callumacrae : the link you provided suggests using them to compute the multiset permutations
03:47:02 <callumacrae> right. yes. that's the fraction: (a + b)!/(a! * b!)
03:47:06 <lyxia> callumacrae: what are you trying to count with that formula?
03:47:24 <callumacrae> lyxia: total number of unique books that can be produced by lostmy.name
03:47:54 <callumacrae> there's a tonne of criteria, though. books can be different lengths, contain a number of wildcard pages that can be any letter but only be used once, multiple languages
03:48:15 <callumacrae> I'm pretty sure the formula is correct, but not sure if it can be simplified
03:49:14 <callumacrae> I think this must have an infinite loop in somewhere. even when I make the numbers really small, it runs forever
03:49:37 <ski> callumacrae : did you add the case  n `p` 0  yet ?
03:50:36 <callumacrae> ski: yep. I just updated the gist
03:50:39 <callumacrae> https://gist.github.com/callumacrae/5fd7dd85b71da4b3b969
03:50:58 <callumacrae> also have made the ranges given the folds smaller so that I don't have to wait 20 minutes for it to fail
03:51:24 <quicksilver> you are still defaulting to Double due to that use of /
03:51:39 <callumacrae> also I missed a foldl!
03:51:42 <ski> you could use  foldl'  in  fact  as well
03:51:43 <ski> yes
03:52:03 <quicksilver> callumacrae: http://lpaste.net/144027
03:52:11 <quicksilver> that version terminates for parameters '2 4'
03:52:18 <quicksilver> and gives the answer 10914834022
03:52:33 <quicksilver> for parameters '6 45' it has been running for 8 minutes and no answer yet
03:52:51 <lyxia> callumacrae: the fraction is a binomial coefficient, which is bound to have tons of digits
03:52:59 <quicksilver> it's not eating memory though, which is encouraging
03:53:11 * hackagebot compactmap 0.1.3.1 - A read-only memory-efficient key-value store.  https://hackage.haskell.org/package/compactmap-0.1.3.1 (SimonMarechal)
03:53:35 <quicksilver> but I think possible you need to be clever to calculate this in sensible time bounds
03:53:48 <lyxia> since the parameters of that binomial coefficient are so large I don't think you can even represent it.
03:54:13 <ski> you could flip the loops and factor `26 ^ h' out of one of them
03:54:25 <quicksilver> maybe gamma function and scientific notation are the way to go
03:54:33 <quicksilver> (and abandon precision)
03:55:01 * quicksilver has never been any good at all at the kind of maths which actually involves calculating things.
03:55:20 <ely-se> has anyone used the persistent-vector package?
03:57:14 <ski> callumacrae : i'm still not getting why you want `a' and `b' to be those binomial coefficients ..
04:01:32 <callumacrae> ski: I'll explain it from the formula, not the haskell. the first summation, with x, is looping through the various lengths the book can be. The second, with h, is looping through the number of "helper" pages a book can have, where a helper page can be any letter, but only used once—so every time a helper page is used, we have to multiply by 26. It can be used anywhere in the book. We can use just t
04:01:38 <callumacrae> he denominator to calculate how many books there would be if we put the helper functions at the end of the book, but then the binomial coefficient is calculating how many possibilities there are if we then mix them up
04:01:49 <callumacrae> sorry, there was no short way to explain that
04:08:44 <lyxia> callumacrae can you explain in more detail where that binomial coefficient comes from?
04:17:17 <lyxia> callumacrae: It looks like it always picks the pages associated to the same letter in the same order.
04:17:21 <callumacrae> lyxia: we have two sets, a and b (where a = P(45, x - h) and b = P(3, h)). We want to know how many permutations there are when the two sets are mixed together. that would be (a+b)!/(a!*b!)
04:17:31 <callumacrae> I could be wrong though
04:17:40 <lyxia> What's 45
04:17:45 <lyxia> and 3
04:18:19 <callumacrae> 45 is the number of normal pages available, 3 is the number of helper stories available. they're magic numbers, basically
04:18:35 <callumacrae> have you looked at https://www.lostmy.name/ that I linked to early? If you look at the book, might make it easier to understand
04:18:51 <lyxia> yes I'm having a better idea of how that works
04:20:32 <lyxia> and the actual coefficient you need is C(x, h)
04:21:24 <lyxia> you are counting alternating sequences of x-h normal pages and h helper pages
04:22:05 <lyxia> the P(45, x-h) and P(3, h) count how many ways you can then fill the pages you have ordered.
04:22:40 <ski> why is `x' only going up to `12' ?
04:22:55 <callumacrae> that's the maximum length a book can be
04:23:05 <callumacrae> like, we CAN make them longer, we just don't
04:24:10 <ski> the i don't understand "45 is the number of normal pages available, 3 is the number of helper stories available."
04:24:20 <ski> s/the i/then i/
04:25:21 <callumacrae> we have 45 different stories we can put into the book (aardvark, angel, bear, chameleon, etc)
04:25:53 <ski> how's that connected with fortyfive pages, then ?
04:25:57 <callumacrae> we then have three "helper" stories which can be any letter. for example, one is "rainbow" where a letter from a-z will be found
04:26:12 <callumacrae> by pages I meant spreads, sorry about that
04:26:22 <callumacrae> collection of four pages that can be used in the book
04:26:34 <quicksilver> the helper ones are used if the recipient has too many letters with the same name?
04:26:44 <quicksilver> like 3 As but you only have aardvark and angel?
04:27:01 <lyxia> callumacrae: Actually these stories are always picked in the same order. Aardvark is always before Angel
04:28:14 <MarcelineVQ> What about Sausage?
04:28:43 <MarcelineVQ> Ignore me that was probably too obscure :X
04:29:18 <callumacrae> lyxia: that is configurable
04:29:42 <callumacrae> quicksilver: yes, but we're disregarding the fact that it won't happen until a certain number of letters has been used in the name of simplicity and our sanity :)
04:32:01 <callumacrae> I updated the gist again. Getting "Unique.hs:14:41: parse error on input ‘=’" and can't work out why :(
04:32:36 <callumacrae> Am I allowed to use let like that with -> ?
04:32:48 <MarcelineVQ> you're prob missing a )
04:33:10 <MarcelineVQ> By far, for me anyway, the most common cause of parse error is mismtached ( )
04:33:13 <lyxia> callumacrae: Ok then I think one term in that summation should be C(x,h)P(45,x-h)P(3,h)26^h
04:34:13 <callumacrae> MarcelineVQ: can't see anything. Not getting any syntax errors in my IDE
04:34:15 <ski> so a book will be between `3*4' and `12*4' pages long, ignoring helper spreads ?
04:34:52 <latermuse> is it possible to parse partial json objects using aeson? I always get "Failed reading: satisfyWith" when I try
04:35:07 <MarcelineVQ> n `p` r = fold1' (*) [n-r+1..n] should say foldl1'
04:35:15 <callumacrae> 3 and 4 character names get an extra four pages in the middle so that they're not too short, and there's intro and outro pages, but they can all be disregarded because they don't affect the end result of this forumla
04:35:21 <callumacrae> whoops
04:35:22 <callumacrae> thanks!
04:35:46 <callumacrae> Still getting the error. can't see why :(
04:36:20 <MarcelineVQ> callumacrae: I'm not getting any error other than the foldl1' one
04:36:57 <callumacrae> That's strange. I'm using ghc 7.8.3, could that make a difference?
04:37:46 <quicksilver> tab/space error I expect
04:37:49 * quicksilver looks at your gist
04:38:07 <callumacrae> yeah vim was doing something weird
04:38:16 <callumacrae> opened it in a better editor and it's giving me a syntax error
04:38:29 <quicksilver> check the indentation before 'let' and before 'threeph'
04:38:44 <quicksilver> it needs to be the way it looks in the gist - npxh and threeph lining up, no tabs used
04:39:44 <callumacrae> it compiled once I fixed everything :)
04:41:27 <danilo2> Hello guys! Is there in Lens any standard abstraction that provides functionality of accessing the value of a last parameter of a datatype? Like ` Lens' (t a) a` ?
04:42:26 <callumacrae> Now I'm randomly getting unique: Prelude.foldl1': empty list, not sure where that came from :(
04:43:16 <callumacrae> updated the gist, again
04:44:46 <MarcelineVQ> well the 1 variants of the fold functions don't work on empty lists because they get their base case from the first item in the lists they're folding, so it's throwing an exception due to being given an empty list, so what has changed bewteen the last time you ran this and now
04:44:50 <quicksilver> danilo2: the last element of a traversal, sure
04:45:00 <quicksilver> > [1,2,3,4] ^? _last
04:45:02 <lambdabot>  Just 4
04:45:06 <quicksilver> not sure if that's what you meant?
04:45:09 <callumacrae> yeah, but I'm not sure where it's getting an empty list from!
04:45:43 <quicksilver> callumacrae: if r is zero then [n-r+1..n] is an empty list
04:45:55 <MarcelineVQ> you're so fast quicksilver
04:46:09 <quicksilver> callumacrae: then again you could just use "product [n-r+1..n]"
04:46:14 <MarcelineVQ> > [5..0] -- I was gonna toss this out then say that
04:46:16 <lambdabot>  []
04:46:21 <quicksilver> which gets the base case right (it uses 1)
04:46:22 <callumacrae> quicksilver: was attempting to solve that one with n `p` 0 = 1
04:46:25 <ski> danilo2 : perhaps you mean `traverse' ?
04:46:30 <callumacrae> product would be better though!
04:46:51 <tdammers> anyone familiar with juicypixels here? I want to merge two images using a blending function, how do I do that?
04:47:09 <tdammers> I need something like :: (a -> a -> a) -> Image a -> Image a -> Image a
04:47:17 <tdammers> performing pixel-wise zipping
04:47:35 <latermuse> got it! hohoho
04:47:41 <callumacrae> all this has proved is that the formula is wrong
04:47:42 <callumacrae> gaaaaaaaah
04:48:02 <MarcelineVQ> Bascially if the first entry is larger than the last entry in a list enumeration you need to provide it with a step so it understands how to get there. This isn't relevant for your current problem since there's better ways to build that list, but it's useful info.
04:48:14 <MarcelineVQ> > [5,4..1]
04:48:16 <lambdabot>  [5,4,3,2,1]
04:49:05 <quicksilver> tdammers: I think that's out of scope for juicypixels. It does loading and saving and presents it as a nice convenient vector.
04:49:27 <quicksilver> tdammers: it's down to you to manipulate (using, perhaps, the Vector zipWith?)
04:50:17 <quicksilver> tdammers: zipWith :: (Storable a, Storable b, Storable c) => (a -> b -> c) -> Vector a -> Vector b -> Vector c
05:11:33 <danilo2> quicksilver, ski, oh Thanks!
06:14:24 * hackagebot maam 0.3.0.0 - Monadic Abstracting Abstract Machines (MAAM) built on Galois Transformers  https://hackage.haskell.org/package/maam-0.3.0.0 (DavidDarais)
06:23:36 <kjcwncsdr> ***      buzzfeed.co.il      ******      buzzfeed.co.il      ******      buzzfeed.co.il      ***
06:54:26 * hackagebot uhc-util 0.1.6.3 - UHC utilities  https://hackage.haskell.org/package/uhc-util-0.1.6.3 (AtzeDijkstra)
07:09:26 * hackagebot uhc-light 1.1.9.2 - Part of UHC packaged as cabal/hackage installable library  https://hackage.haskell.org/package/uhc-light-1.1.9.2 (AtzeDijkstra)
07:19:50 * hackagebot fn 0.1.2.0 - A functional web framework.  https://hackage.haskell.org/package/fn-0.1.2.0 (DanielPatterson)
07:32:02 <karlek> Hi! How do I catch exceptions that are triggered by: "resource vanished (Connection reset by peer)"? For context: I am currrently using Sockets to make some handshakes.
07:32:48 <merijn> karlek: Those are IO exceptions, consult the "Control.Exception" docs for more options than you ever wanted :)
07:33:15 <karlek> merijn: Haha, thank you :)
07:34:22 <merijn> karlek: They're basically unchecked exceptions like you'd find in Java, C++, etc. You can even do a bunch of complex things like building a hierarchy of exceptions, but that's used less often (I think there's a paper with lots of details linked in the docs, but most things are fairly straightforward)
07:35:23 <karlek> When are hierarchical exceptions used? When there's a priority to the code flow?
07:35:35 <merijn> karlek: The only side note to make is: Never use "throw", always use "throwIO", unless you hate future you and like impossible to debug problems :)
07:36:40 <karlek> merijn: I'm always up for a challenge, but I'll take your advice! :D 
07:36:59 <merijn> karlek: Well, suppose your library has 10 different exceptions it can throw and you want to be able to write a handler that does "catch everything my library can throw" you could make an extra layer in between "SomeException" (the root type) and the 10 different individual exceptions that is called MyLibraryExceptions and use that as parent for all 10 others to be able to catch all of them
07:37:23 <merijn> karlek: The problem with "throw" is that it can "leak" out of your try/catch handler due to laziness. "throwIO" cannot
07:38:03 <karlek> karlek: Ah, I see. It sounds useful :)
07:38:13 <karlek> karlek: And, that sounds dangerous.
07:39:05 <merijn> Yes, but not all the often, and yes, hence the warning :p
07:46:55 <karlek> merijn: Now I catch that exception. Thank you <3
07:47:04 <merijn> np :)
07:52:49 <merijn> I forgot, what is cabal's syntax for adding constraints on the commandline?
07:53:09 <dcoutts_> merijn: --constraint='foo >= 0.6'
07:53:16 <merijn> dcoutts_: Thanks :)
07:53:36 <dcoutts_> or if it's a target you're installing then simply: cabal install 'foo < 0.7'
07:55:03 <merijn> hmmm, let's first see if the other dependencies manage to actually install
07:58:20 <merijn> hmmm
07:58:49 <merijn> "cmdargs-0.10.13 failed during the configure step. The exception was: user error (The package 'cmdargs' requires Cabal library version -any && >=1.6 but no suitable version is installed.)" <- that doesn't seem right...
08:00:31 <merijn> hmm, cabal update and stupidly retrying seems to have worked, oddly...
08:23:19 <Xandaros> Are there any examples of using the singletons library out there?
08:25:11 <merijn> Xandaros: Not any simple ones ;)
08:25:36 <merijn> Xandaros: tbh singletons isn't all that complex if the GADT/type family stuff already makes sense
08:26:20 <Xandaros> I have defined my own singletons before, so I have an idea of how it works (Also implemented some "functions" on the type level using type synonym families)
08:26:30 <andromeda-galaxy> merijn: speaking of singletons, how exactly does singletons integrate with the new-ish TypeLits machinery?
08:26:56 <Xandaros> Looks like they provide some handy template haskell. It helps to read the whole readme and not just the top part :D
08:27:03 <merijn> andromeda-galaxy: It doesn't really integrate, it's mostly for lifting/reifying stuff at runtime
08:27:59 <merijn> andromeda-galaxy: TypeLits don't really do all that much yet, singletons (for me) has been mostly for lifting/reifying DataKinds stuff
08:28:25 <merijn> Xandaros: Yeah, you can do it manually, but in case you can't be arsed the TH stuff is nice and easy :)
08:29:09 <Xandaros> There is also promote... So I can just write it with values and types and have it promoted to types and kinds? Magic.
08:29:47 <merijn> Xandaros: It's really just GADT and typeclass abuse ;)
08:30:02 <Xandaros> Of course. Like I said, magic.
08:32:26 <joco42> haskell - emacs users: what is the best way to do code folding for haskell in emacs?
08:35:03 <andromeda-galaxy> merijn: ah, thanks for the explanations.... I'm looking forward to a more useful typelits
08:35:34 <merijn> andromeda-galaxy: GHC 8.0 should have better numeric support
08:35:51 <andromeda-galaxy> merijn: I feel like one of the problems with dependent typing in Haskell right now is the inductive definition of Nat, it means that really big numbers take up lots of space & 'proving' things to the compiler about them is sometimes very unperformant
08:36:25 <andromeda-galaxy> merijn: is there any consesus in the community as to how to get around those problems? (without typelits)?
08:36:27 <merijn> andromeda-galaxy: The real problem is not that, it's the ugly hack to reify values from types
08:37:01 <merijn> andromeda-galaxy: Not really, the only solution is either smarter solver for the Nat kind or full DT
08:38:32 <andromeda-galaxy> merijn: okay, that's what I was afraid of...
08:38:54 <merijn> andromeda-galaxy: Given in to the dark dependent side ;)
08:39:05 <merijn> andromeda-galaxy: You could just write Coq and extract haskell/ocaml from it!
08:39:32 <andromeda-galaxy> merijn: indeed... I've done a few small proofs in Coq but no actual programming
08:39:43 <merijn> andromeda-galaxy: Do you know Software Foundations?
08:40:16 <Xandaros> Hmm, I think my problem is that I'm trying to make a function that returns a value which has a type whose kind is not * (wow, that sentence...)
08:40:42 <merijn> Xandaros: That's not possible
08:40:52 <merijn> Xandaros: As in, by definition impossible
08:41:01 <Xandaros> Yup.
08:41:08 <andromeda-galaxy> merjn: I've seen it, but haven't had time to read most of it yet...
08:41:36 <andromeda-galaxy> merijn: also, have you seen this? github.com/coq-concurrency/pluto
08:41:54 <merijn> No, and I'm sad now
08:41:58 <andromeda-galaxy> someone wrote a full http server in Coq with a custom library to make it emit Haskell code that actually implemented the side effects...
08:42:10 <merijn> For a second I thought that'd be a Coq library for proofs on concurrent systems...
08:42:16 <merijn> That would've actually solved a problem I have
08:42:45 <andromeda-galaxy> merijn: that would be interesting... I just thought I'd mention pluto in reference to your earlier suggestion of writing Coq that emits Haskell...
08:44:19 <merijn> edwardk: ping?
08:54:01 <ultratravolta> hi
09:09:42 <Xandaros> Hmm, I need a monad with a "dependent" type attached to it. The problem is, using bind is supposed to change the attached type. Is there something like that already or do I need to define my own monads for this?
09:11:16 <kadoban> Xandaros: I'm not really sure what that means? How should it behave?
09:13:25 <orion> What's the canonical way of associating constant values with a typeclass? For example, I have a typeclass "Hash" which has a "hash" function associated with it, but I also need to associate two constant values, the hash length in bytes and the block size in bytes.
09:13:44 <orion> If you want to create an instance of Hash, you must specify those values.
09:14:04 <Xandaros> kadoban: I need a bind like (>>=) :: m a c -> (c -> m b d) -> m b d
09:15:36 <Xandaros> orion: Assuming you are not confusing typeclasses with classes from OOP languages, you can just add them like functions
09:16:23 <tommd> orion: See my crypto-api Hash class for an example.
09:17:10 <tommd> orion: class Hash d where blockLength :: Tagged d BitLength ; hash :: ByteString -> d ; ...
09:17:18 <mauke\lpt1> ah, Tagged
09:17:25 <tommd> @info Tagged
09:17:25 <lambdabot> Tagged
09:17:27 <mauke\lpt1> I was thinking about Proxy a -> b
09:17:34 <orion> tommd: Do you think Tagged is... hackish?
09:18:03 <tommd> orion: It avoids needing blockLength :: d -> BitLength and having people fill in `undefined :: some_d`
09:19:03 <tommd> orion: I agree it is a bit syntactically verbose to use, but very few people actually use that info also so I'm not very worried.
09:19:22 <tommd> orion: You can always say `blockLength .::. (undefined :: some_d)`
09:19:44 <tommd> Or without the operator: blockLength `for` valueOfTypeD
09:19:50 <tommd> See Crypto.Utils
09:20:02 <johnw> orion: Tagged is like a type-level tupling of one type with another, so it's a kind of "anonymous" type, rather than defining your type with a phantom
09:20:32 <mauke\lpt1> proxy blockLength (Proxy :: Proxy some_d) -- hmm
09:22:16 <tommd> mauke\lpt1: As a one-liner, but you likely have the proxy defined elsewhere or else you have concrete values of the right type and you can basically tie the knot for the type using `for`.
09:22:58 <Xandaros> kadoban: I basically need a monad instance (or something similar, can always use RebindableSyntax) for a datatype not unlike Vector from sized-vector
09:23:31 <Xandaros> The questions is, has that been done before or should I create my own class for that
09:29:10 <dxvxb> i am having hard time installing gtk3 haskell package on windows...
09:29:22 <kadoban> Xandaros: Not so sure :-/
09:30:27 <dxvxb> i install c libraries via msys2 package-manager pacman for windows...
09:31:21 <jophish> What's a neat way to get a function as applied to a newtype. For example generate foo = (+) from Sum and (<>)
09:31:42 <dxvxb> and its not recognising some of the already installed ones..
09:31:57 <jophish> for a unary function, ala works well
09:32:05 <dxvxb> is there any good tutorial for this...?
09:32:22 <jophish> > (ala Sum (<> mempty)) 1
09:32:25 <lambdabot>  1
09:33:06 <jophish> but I can't come up with something svelte for the case with more arguments
09:40:01 <dxvxb> > max 4 5
09:40:04 <lambdabot>  5
09:40:14 <dxvxb> okay!
09:41:01 <MarcelineVQ> > maximum [11,8,6,13,6,12] --also useful
09:41:04 <lambdabot>  13
09:41:23 <kaol> > max 'a' 'd'
09:41:25 <tommd> > 13 -- more efficient
09:41:26 <lambdabot>  'd'
09:41:27 <lambdabot>  13
09:42:42 <Welkin> MarcelineVQ: maximum is implemented stupidly
09:42:52 <mauke\lpt1> > maximum [1, 10, 0/0, 3, 0/0, 4]
09:42:54 <lambdabot>  10.0
09:43:06 <mauke\lpt1> > maximum [0/0, 1, 10, 0/0, 3, 0/0, 4]
09:43:08 <lambdabot>  NaN
09:43:17 <dxvxb> ??
09:43:23 <tommd> No, floating is implemented stupidly.
09:43:31 <tommd> Float should not be an instance of Ord, Eq.
09:43:34 <kadoban> IEEE is insane. Can't blame maximum for that.
09:43:35 <orion> tommd / johnw: Is it impossible to do something like: foo :: Hash h => Bar -> Foo h    foo x = something (undefined :: h) ?
09:43:37 <tommd> It doesn't obey the laws.
09:43:49 <Welkin> well, pre-FTP it is using foldl
09:43:58 <Welkin> now it is using foldMap (which uses foldr)
09:44:21 <Welkin> but it should be using foldl'
09:44:26 <Welkin> should it not?
09:44:26 <tommd> orion: Entirely possible.
09:44:37 <tommd> orion: The DRBG package does exectly that.
09:45:34 <ggole> @src maximum
09:45:34 <lambdabot> maximum [] = undefined
09:45:34 <lambdabot> maximum xs = foldl1 max xs
09:45:46 <ggole> Isn't that sensible?
09:46:00 <ggole> Seems to me the sensitivity to argument order is due to max
09:46:17 <ggole> > (max 1.0 (0/0), max (0/0) 1.0)
09:46:19 <lambdabot>  (1.0,NaN)
09:46:20 <tommd> The issue is due to an Ord instance that doesn't obey the laws of Ord.
09:46:41 <tommd> > compare 1 (0/0)
09:46:42 <nikolah> Hello - does anyone perhaps know where can I find "From λ-calculus to cartesian closed categories" paper by Lambek or where shold I ask? Or any other paper/book where I can find construction of isomoprhism between ccc and lambda calculus or intuitionistic logic. Thank you.
09:46:43 <lambdabot>  GT
09:46:47 <tommd> > compare (0/0) 1
09:46:49 <lambdabot>  GT
09:47:15 <ggole> Mmm.
09:47:37 <kadoban> nikolah: Most libraries have a service that can help you locate copies of papers. Even relatively crappy local ones, though ask at the biggest branch you can find.
09:47:47 <dxvxb> sorry, i cant figure out that reply for maximum of list... why NaN?
09:48:03 <ggole> > 0/0
09:48:05 <lambdabot>  NaN
09:48:08 <tommd> dxvxb: Do you understand floating point?  any_number / zero == ????
09:48:09 <Jinxit> nikolah: tried arxiv and google scholar?
09:48:10 <ggole> That's where the NaN comes from
09:48:19 <nikolah> kadoban: Didn't know that - thank you.
09:48:19 <kadoban> dxvxb: Because in IEEE floating point, NaN is … weird. Most comparisons with it are false.
09:48:22 <MarcelineVQ> hmm
09:48:29 <ggole> The strange result is due to the strange way that comparisons are defined on NaN
09:48:29 <MarcelineVQ> > foldl1' max [1..10000000]
09:48:31 <lambdabot>  10000000
09:48:35 <MarcelineVQ> > foldr1 max [1..10000000]
09:48:37 <lambdabot>  *Exception: stack overflow
09:48:41 <kadoban> nikolah: It might take a bit of work to get hooked up with the right person, but if you ask around someone should know.
09:49:46 <kadoban> dxvxb: So  NaN < 1  is false, so is NaN > 1, so is NaN == NaN, etc. Basically Float breaks most laws you can think of that numbers should usually follow. This is true is like every language too, not just haskell.
09:49:58 <nikolah> Jinxit: no luck there - I found it it was published in To H.B.Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, but it seems like there is no electronic copy
09:49:59 * hackagebot argon 0.3.0.0 - Measure your code's complexity  https://hackage.haskell.org/package/argon-0.3.0.0 (rubik)
09:50:28 <ggole> Ideally comparisons on floating point would be represented in terms of a data type that explicitly includes a nonordered result, rather than booleans (or Ordering)
09:50:30 <dxvxb> oh okay, yeah...  thanks.
09:52:33 <Wizek> Hello everyone! Anyone knows how the following error during cabal install can be fixed? https://gist.github.com/Wizek/32da80b593efaf0c4529 Background: I would like to try out reactive banana to see what kind of GUI can be written with frp in Haskell. Searching for examples, I've found this repo: https://github.com/HeinrichApfelmus/reactive-banana/tree/master/reactive-banana-wx/src . So I've tried installing its dependencies and I am s
09:52:33 <Wizek> tuck trying to install wx. Any ideas how I could get unstuck?
09:53:34 <orion> tommd: Do I need an extension?
09:53:54 <tommd> orion: For what
09:54:07 <tommd> orion: You will likley need FlexibleContexts if you use DRBG.
09:55:44 <MarcelineVQ> Welkin: it looks like maximum for the [] instance of foldable is defined in terms of GHC.List.maximum which uses foldl1
09:56:53 <Welkin> MarcelineVQ: yes, that is no good
09:57:10 <MarcelineVQ> isn't that foldl1' with O2?
09:57:23 <Welkin> maybe
09:57:28 <Welkin> I don't know how the optimizations work
09:59:36 <dxvxb> exit
09:59:42 <Xandaros> Why is that not good?
09:59:48 <Xandaros> Seems reasonable to me
10:05:06 <Darwin226> Hey guys. I need some help. I have a c++ library. It's only 2 files. clipper.cpp and clipper.hpp. What's the easiest way to get the functions in there to haskell?
10:05:37 <rom1504> recode them most likely
10:05:49 <Darwin226> rom1504: There's a lot of code.
10:06:18 <rom1504> https://wiki.haskell.org/CPlusPlus_from_Haskell
10:06:24 <glguy> You can export a C API from your C++ code and then Haskell can call that
10:06:42 <rom1504> if you're ready to do some "black magic" that page says :p
10:06:53 <Darwin226> glguy: Yeah. I was kind of aiming for that. How do I do it?
10:07:25 <Darwin226> glguy: The information is unbelievably scarse. Not to mention I'm on windows and nativle libraries are hell to work with
10:07:37 <athan> Is a monad morphism something like `StateT (Int,Int) m a -> StateT Int m  a`?
10:07:53 <athan> If so, how would we work around mtl, with `MonadState` instead?
10:09:02 <glguy> Darwin226: Exporting a C API from C++ is a question for C++ people. Once you have that you can use the Haskell FFI to import those C procedures
10:09:54 <Darwin226> glguy: What about the part where you have a compiled C library (whatever that means) and then have to get that somewhere where I can see it from Haskell?
10:10:28 <uwap> athan, something like `modify fst` and `modify snd`?
10:10:45 <uwap> err
10:10:52 <uwap> more like withStateT than modify
10:11:05 <Darwin226> glguy: I'll play around with it some more, though surely, I'll be back.
10:11:08 <uwap> :t withStateT
10:11:11 <lambdabot> (s -> s) -> StateT s m a -> StateT s m a
10:11:22 <glguy> Darwin226: You want to look up documentation on the "Foreign Function Interface"
10:11:26 <athan> too restricted :\
10:11:33 <athan> uwap: Thank you though, I'll keep prodding
10:11:48 <uwap> athan, how is this restricting?
10:12:05 <uwap> athan, I mean, what do you want?
10:13:54 <athan> uwap: Sorry, it's not functorial for the state object - it's restricted to `s -> s`, not `s -> s1` or something
10:14:08 <athan> I'm wondering if lens could do this :s
10:14:11 <uwap> ohh.
10:14:25 <uwap> you are right. I didn't notice O.O
10:18:18 <athan> I'm wondering if something like `stateAs :: (s -> s1) -> (s1 -> s) -> MonadState s1 a -> MonadState s a` would work
10:19:20 <athan> so we just call `get` initially, and use the first function to get our initial value, runState the monad to be embedded (I guess we'd need StateT then), then `put` the result after invariantly getting the `s` result with the second function
10:19:21 <tommd> Work? Sure.  Be useful to a large enough population to justify inserting into ___monad lib of choice___? Probably not.
10:19:47 <athan> tommd: Of course, just trying to assert where the real problem lies
10:19:53 <radens> Is there a module for dumping and manipulating the haskell abstract syntax tree?
10:20:09 <athan> radens: TemplateHaskell? :P
10:20:36 <athan> You can parse it yourself with Haskell-Src-Exts (a different parser from GHC), or you could use the GHC api (or hint)
10:21:03 <radens> athan: I'll look into all of those. Is there a googleablt name for the ghc api?
10:21:22 <fizbin> I seem to remember somewhere there being a variation on Foldable and Traversable that could be used by container-ish types that could only hold one type. Anyone remember what that was called?
10:21:31 <athan> radens: I am not sure, I think there is a package though. Have you thought about reading Core, too?
10:21:36 <athan> GHC Core* I mean
10:21:42 <athan> an alternative, lossy AST :)
10:22:04 <athan> fizbin: Witherable?
10:22:18 * radens isn't familiar with GHC Core.
10:22:59 <athan> fizbin: There's also Foldable1 from semigroupoids, and FoldableWithKey in keys
10:24:04 <fizbin> athan: But Foldable1 requires that the container be Foldable.
10:24:23 <athan> idk what you want :|
10:24:28 <athan> could you be more specific?
10:26:33 <fizbin> I have a few types that are basically like "SomeFoldable Foo" and "SomeFoldable Bar", but the types are of kind *, not kind * -> *. I can implement all the Foldable operations on them, with the provision that I tweak the signature to not take a type parameter.
10:27:14 <athan> fizbin: Check out mono-traversable :)
10:27:35 <fizbin> That's it! I just couldn't remember the name.
10:28:22 <athan> :)
10:28:48 <Taneb> fizbin: you can also use lens for the same purpose, if that floats your boat
10:29:51 <Sonolin> I'm confused on the difference between Reader monad and State monad
10:29:55 <Sonolin> they both look very similar
10:29:58 <fizbin> Taneb: Can I? Don't lenses require the ability to change things internally to arbitrary types?
10:30:21 <fizbin> Or is this one of the other optical-thing-named abstractions that lens has?
10:30:26 <Taneb> fizbin: lens has something like foldBytestring :: Fold ByteString Word8
10:30:32 <Taneb> Similar for Text
10:31:03 <fizbin> Ah, a Fold. Hrm.
10:31:17 <Taneb> You may be able to define a more-general Traversal
10:32:26 <shachaf> lens has Traversals, not just Folds, for ByteString and Text
10:32:40 <shachaf> They aren't type-changing.
10:34:26 <athan> Sonolin: Reader is read-only - you can't manipulate `r` as a result
10:34:43 <athan> while in State you can, because it's isomorphic to `s -> (s, a)`
10:35:00 * hackagebot postgresql-simple-sop 0.2 - Generic functions for postgresql-simple  https://hackage.haskell.org/package/postgresql-simple-sop-0.2 (glutamate)
10:35:08 <athan> Notice that Writer is just `(w, a)` - you can only provide output information, but aren't given any to begin with
10:44:06 <GLM> Anyone know how I might be able to get a scholarship to ICFP 2016?
10:44:13 <Sonolin> sweet, thanks athan!
10:45:01 <athan> Sonolin: :)
10:51:50 <pilne> is there a proper channel for asking a question about using stack/stackage?
10:52:10 <athan> pilne: There's #haskell-stack
10:52:28 <pilne> thank you
10:52:36 <athan> np :)
10:55:55 <fizruk> is there a simpler way to do this? http://lpaste.net/144042
10:57:31 <t7> wtf
10:57:55 <t7> i think you need to start with 'groups p (x:y:xs)'
10:59:09 <t7> no maybe not
10:59:39 <fizruk> t7: yes, this is probably the shortest way with explicit recursion
10:59:52 <fizruk> t7: I was wondering more about reusing something from Data.List
11:00:54 <joco42> @Emacs users, could you please share the secret on how to fold haskell code ? http://stackoverflow.com/questions/33375294/folding-haskell-code-in-emacs
11:00:55 * lambdabot hits users, could you please share the secret on how to fold haskell code ? http://stackoverflow.com/questions/33375294/folding-haskell-code-in-emacs with a hammer, so they breaks into a thousand pieces
11:01:30 <MarcelineVQ> did it just read emacs as smack?
11:01:40 <joco42> hmm...
11:03:16 <ggole> At the start of a message @ symbols are interpreted as a command by lambdabot.
11:03:19 <ggole> @zonk
11:03:19 <lambdabot> Unknown command, try @list
11:03:59 <ggole> Oh wait, that's not quite what you asked.
11:04:06 <ggole> @emacs ggole
11:04:06 <lambdabot> Come on, let's all slap ggole
11:04:22 <ggole> I see.
11:04:53 <ackthet> are there any haskell web servers that are used in production? (ie webservers written in haskell)
11:05:05 <ackthet> i know 'in production' is a vauge condition
11:06:00 <Tehnix> ackthet: like WAI?
11:06:16 <athan> ackthet: Yes, many. The commercial haskell user group is avid about the technology, mainly using Yesod, Snap and WAI to develop them.
11:06:33 <Tehnix> ^ was about to say that
11:06:35 <athan> Each company is using it at their own risk, but many seem happy with it
11:06:41 <yudhistir> Is bind >>= left or right associative?
11:06:56 <athan> yudhistir: Right, pretty sure
11:07:03 <yudhistir> I am trying yo understand [1,2] >>= \n -> ['a','b'] >>= \ch -> return (n, ch)
11:07:09 <athan> nope, left
11:07:13 <Tehnix> ackthet: You mind be interested in https://www.fpcomplete.com/business/commercial-haskell-special-interest-group/
11:07:25 <ackthet> i though WAI was for a specific framework
11:07:32 <athan> ackthet: It's very generic
11:07:43 <ackthet> cool i'll check that out Tehnix 
11:07:44 <Tehnix> ackthet: Nah, WAI is generic, but it is used by some frameworks, yes
11:07:45 <athan> it merely defines a Request -> Response api
11:07:50 <ackthet> ahh okay
11:07:53 * ackthet reads
11:08:38 <yudhistir> [1,2] >>= \n -> ['a','b'] 
11:08:51 <ackthet> how about mighttpd?
11:08:52 <yudhistir> gives me 'abab'
11:09:06 <ackthet> the problem i seem to have is finding how 'ready' or 'mature' some projects are
11:09:11 <Tehnix> ackthet: Oh, and particularly their blog at https://www.fpcomplete.com/blog/2015/10/new-haskell-ide-repo and also yesodweb. Michael Snoyman (behind Yesod) is a very active contributor to a whole slew of things, and on the yesod blog also blogs about a lot of other haskell web stuff :)
11:09:39 <yudhistir> how does this [1,2] >>= \n -> ['a','b'] >>= \ch -> return (n, ch) give me [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
11:09:46 <Tehnix> ackthet: yesod is very ready and mature, Snap should also be but I must admit I have mainly used Yesod
11:10:06 <yudhistir> I thought the [1,2] are lost after first bind
11:10:07 <glguy> yudhistir: for lists, m >>= f   is concatMap f m
11:10:27 <ackthet> Tehnix: thanks you!
11:10:46 <MarcelineVQ> yudhistir: binds are basically nested lambdas, so that n is available to things that come later
11:10:56 <glguy> yudhistir: and nothing is lost, that \n -> is in scope for the rest of the line
11:10:58 <MarcelineVQ> if it as \_ instead of \n it wouldn't be available
11:11:02 <MarcelineVQ> *was
11:11:07 <recursion-ninja> @djinn (a -> b -> c -> d -> e) -> b
11:11:07 <lambdabot> -- f cannot be realized.
11:11:36 <recursion-ninja> @djinn (a -> b -> c -> d -> e) -> b
11:11:37 <lambdabot> -- f cannot be realized.
11:11:38 <recursion-ninja> @djinn (a -> b -> c -> d -> e) -> b
11:11:38 <lambdabot> -- f cannot be realized.
11:11:54 <glguy> recursion-ninja: You can play with lambdabot in /msg
11:11:55 <MarcelineVQ> Actually I should say that you're using nested lambdas rather than binds are nested lamdbas
11:12:45 <maerwald> tdammers: probably something with the 'generateImage' function and then wrap your own stuff inside to get the pixels from each image etc
11:12:54 <maerwald> oops
11:13:00 <maerwald> my scrollback is broken
11:13:27 <maerwald> I think I answered to something ~2 days back
11:19:03 <yudhistir> Haaa, this made it clear [1,2] >>= (\n -> ['a','b'] >>= \ch -> return (n, ch))
11:19:16 <yudhistir> thanks guys
11:29:00 <jmcarthur> > [1,2] >>= (\n -> ['a','b'] >>= \ch -> return (n, ch))
11:29:02 <lambdabot>  [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
11:29:17 <jmcarthur> > liftA2 (,) [1,2] "ab"
11:29:19 <lambdabot>  [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
11:35:04 * hackagebot purescript 0.7.5.1 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.7.5.1 (PhilFreeman)
11:35:46 <humanoyd> Anyone using the base16 color scheme with vim?
12:11:08 <althar_> hello all
12:11:42 <bitemyapp> althar_: hi
12:11:44 <althar_> has anyone got experience with using Leksah?
12:12:03 <althar_> it might be a more general question, I am fairly new to Haskell
12:13:27 <althar_> any ideas how to specify a debug (using Visual studio terminology) or a working directory when running the compiled exe?
12:14:06 <althar_> alternatively, I would like to be able to copy the data folder along with the exe on compilation
12:14:24 <althar_> I thought the cabal data-dir would have achieved that, but I seem to misunderstand how this works
12:15:05 * hackagebot purescript 0.7.5.2 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.7.5.2 (PhilFreeman)
12:15:57 <Danny__> Hi all- trying to to work out how I can check if an element is in a bag- so far I have filter ((==x).fst) `elem` bag but that doesnt seem to be working at all- after I have the element I also then want to be able to do an operation on it
12:16:02 <Danny__> Any ideas?
12:25:19 <Tehnix> Danny__: so both check if it exists and pull it out if it does in the same time?
12:28:28 <srhb> #haskell-beginners
12:28:30 <srhb> woops
12:30:06 * hackagebot lens-prelude 0.2 - Alternate prelude that exports lens combinators  https://hackage.haskell.org/package/lens-prelude-0.2 (andrewthad)
12:30:10 <Danny__> Tehnix - Yes- checking if the element exists in the bag then perform an operation on it if it exists
12:30:26 <Danny__> Tehnix:
12:37:01 <Tehnix> Danny__: I'm sure there is a better way, but this should basically work `map (\x -> if x == 2 then x*2 else x) t`
12:37:31 <Tehnix> If you grasp that (don't know your level, so can't say)
12:37:32 <Tehnix> :)
12:37:36 <Danny__> Ah yes I should say- I'm trying not to use any imports
12:37:47 <Danny__> My level is very low- started haskell this semester!
12:37:50 <Tehnix> Danny__: that didn't use any imports, standard functions
12:38:46 <marchelzo> How do I something like a fold, but where I end up with: f (f 1 2) 3 instead of f 1 (f 2 3)?
12:41:04 <Tehnix> marchelzo: foldr and foldl? Might be something relevant here https://wiki.haskell.org/Foldr_Foldl_Foldl'
12:41:26 <Tehnix> (that is, I can't remember which one specifically does that, but it should be on that page)
12:41:59 <Tehnix> ....or I might have misunderstood the question
12:42:53 <marchelzo> yeah, foldl/foldr give me f 1 (f 2 (f 3 4)) and so forth
12:43:17 <marchelzo> I want f (f (f 1 2) 3) 4
12:43:43 <saep> > foldr f a [b,c]
12:43:44 <lambdabot>  f b (f c a)
12:44:18 <saep> > foldl f a [b,c]
12:44:19 <lambdabot>  f (f a b) c
12:44:44 <Tehnix> > foldl f a [b,c,d]
12:44:46 <lambdabot>  f (f (f a b) c) d
12:44:51 <Tehnix> marchelzo: ^
12:44:54 <marchelzo> ...
12:45:31 <marchelzo> > foldl1 f [a,b,c,d]
12:45:33 <lambdabot>  f (f (f a b) c) d
12:45:42 <marchelzo> hmm.
12:50:08 <marchelzo> ah, I misunderstood what was happening in my program
12:50:12 <marchelzo> foldl is not to blame
12:51:15 <vektor> Ok, so I'm getting a Prelude.!!: index too large. I know what's the problem, I just don't know where. Any suggestions on how to find the spot where the error is thrown?
12:52:18 <Tehnix> vektor: post the full error? (can't remember exactly how those look)
12:52:55 <lyxia> vektor: you can get a stack trace https://wiki.haskell.org/Debugging
12:54:03 <Cale> vektor: grep -r \!\!
12:54:26 <Cale> vektor: Then go through your code and replace every occurrence of !! with something more sensible :)
12:55:31 <Cale> :t (!!)
12:55:33 <lambdabot> [a] -> Int -> a
12:56:09 <Cale> If you find yourself using !! a lot, then probably lists are the wrong data type to be using.
12:56:37 <Cale> and you'd be better off with, say, Map or some array type.
12:58:03 <karlek> Hi again, more exception problems. I'm trying to catch the exception (or error) for Data.Binary.Get's `runGet` gets too little input and fails. What's the exception / error that I need to catch? I've looked at Data.Binary.Get.Internal and it's just a regular `fail` however no exceptions I've tried have managed to catch it!
12:59:50 <karlek> The error string is: `Data.Binary.Get.runGet at position 0: not enough bytes`
13:00:03 <lyxia> karlek: can't you use runGetOrFail?
13:01:08 <Cale> karlek: Yeah, the correct thing to do is to use runGetOrFail, and case on the result.
13:01:27 <karlek> lyxia, Cale: thank you! I'm gonna try it now :D 
13:01:39 <lyxia> cool :)
13:01:44 <sinelaw> does anyone have any idea why language-ecmascript in the ES5 branch dropped the LValue safety? bergmark?
13:02:54 <Cale> karlek: Generally you should treat exceptions which were thrown by error as uncatchable. They theoretically can be caught, but the required careful interleaving of evaluation with execution of IO actions (using tools like Control.Exception.evaluate and deepseq) make it quite fragile, and really only something you should do as a last resort.
13:03:12 <Cale> karlek: Stuff that's thrown by IO actions using throwIO is fine to catch though.
13:04:37 <vektor> Sorry, was afk for a bit. Cale: Well, uhh... I'm not even sure I called !! to begin with. It might be some other function I'm supplying faulty parameters to. Outside of that, replacing (!!) with a strict version usually leaves you with a lot of Maybe.
13:04:55 <delYsid> I know, Haskell being lazy and all, but is there a function to rotate a list?
13:05:15 <vektor> Tehnix: Well, there's not much beyond *** exception (text I posted) - you can try with "Hello" !! 10 for example.
13:05:17 <Cale> delYsid: It's not in the libraries. cycle might be useful though.
13:05:43 <ARM9> rotateLeft (x:xs) = xs ++ [x]
13:05:57 <vektor> lyxia: Trying that now.
13:07:01 <Cale> vektor: It's usually good if you're not sure whether or not you used (!!), because chances are good that there's not more than one occurrence of it then :)
13:07:02 <delYsid> or, is there a better suited data structure which would hold an Int, have a fixed length (7), and be easily rotated, and convertible to a list?
13:07:16 <Cale> But yeah, if it was really some other library you were using, that kinda sucks.
13:07:53 <karlek> Cale: Yeah, runGetOrFail with Either becomes much more 'idiomatic' or atleast more familiar to look at. Thank you both so much!
13:08:42 <vektor> Cale: I think I have seen it a few times before that faulty arguments cause library functions to crash. And I'm pretty sure I
13:08:48 <vektor> 'm careful about using !!
13:09:54 <vektor> disregard me accusing the library.
13:10:05 <vektor> Also, disregard me saying I was careful when using !!
13:10:44 <vektor> I just grep'd the file in question, and I have a very strong feeling that one occurence of (!!) should be phrased differently and is the culprit
13:17:36 <vektor> Damn I feel so dumb now. :D
13:18:26 <vektor> Thanks Cale. Didn't think it would help at first. Guess I was wrong :D
13:18:39 <Cale> vektor: No problem :)
13:20:07 * hackagebot concurrent-utilities 0.1.0.0 - More utilities and broad-used datastructures for concurrency.  https://hackage.haskell.org/package/concurrent-utilities-0.1.0.0 (sebaslafleur)
13:20:09 * hackagebot eventloop 0.5.0.0 - A different take on an IO system. Based on Amanda's IO loop, this eventloop takes a function that maps input events to output events. It can easily be extended by modules that represent IO devices or join multiple modules together.  https://hackage.haskell.org/package/eventloop-0.5.0.0 (sebaslafleur)
13:20:11 * hackagebot twentefp-eventloop-trees 0.1.2.0 - Tree type and show functions for lab assignment of University of Twente. Contains RoseTree and RedBlackTree  https://hackage.haskell.org/package/twentefp-eventloop-trees-0.1.2.0 (sebaslafleur)
13:20:27 <delYsid> Cale: cycle *is* useful.
13:20:40 <delYsid> > (\xs n -> let l = length xs; n' = n `mod` l in take l $ drop n' $ cycle xs) [1,2,3] (-1)
13:20:41 <haskell983> hello, can someone please show me, how to return a list in a function? I have string and these are merg
13:20:42 <lambdabot>  [3,1,2]
13:20:47 <haskell983> ed with ++ 
13:21:12 <Cale> delYsid: You could also use zipWith const
13:21:20 <haskell983> I want ["Hello", "World"] but I get "HelloWorld" (sorry, still new to Haskell)
13:21:21 <Cale> delYsid: Rather than having to measure the length of the list
13:21:34 <Cale> delYsid: Then it would work semi-correctly on infinite lists
13:22:11 <mizu_no_oto> > ["hello"] ++ ["world"]
13:22:13 <lambdabot>  ["hello","world"]
13:22:29 <mizu_no_oto> > "hello" : "world" : []
13:22:31 <lambdabot>  ["hello","world"]
13:22:44 <Cale> haskell983: (++) concatenates lists. Strings are lists of Char values. So applying (++) to a couple of strings will result in another String.
13:22:50 <mizu_no_oto> haskell983: does that help at all?
13:23:04 <Cale> > let x = "hello"; y = "world" in [x,y]
13:23:06 <lambdabot>  ["hello","world"]
13:23:29 <Cale> You might just want to form a list like my example there
13:28:41 <delYsid> Cale: zipWith const???
13:29:24 <Cale> > (\n xs -> zipWith const (drop n . cycle $ xs) xs) 3 [1,2,3,4,5]
13:29:25 <lambdabot>  [4,5,1,2,3]
13:29:31 <Cale> > (\n xs -> zipWith const (drop n . cycle $ xs) xs) 3 [1..]
13:29:33 <lambdabot>  [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,...
13:29:59 <jay6981> after all these years I think I finally understand recursion thanks to http://learnyouahaskell.com/recursion
13:30:54 <Iceland_jack> <megazword> Iceland_jack: 632 a post was made on ynewscombinator.com item id = 7161236
13:30:54 <Iceland_jack> <megazword> Iceland_jack: 632 days ago
13:30:54 <Iceland_jack> ...
13:30:54 <Iceland_jack> <megazword> Iceland_jack: we are coming to get you
13:30:57 <Iceland_jack> Interesting :-)
13:32:15 <delYsid> Cale: Why? :-)
13:32:17 <Cale> Iceland_jack: what?
13:32:20 <Cale> delYsid: hm?
13:32:37 <Cale> delYsid: Taking the length of a list xs takes O(length xs) time
13:32:38 <Iceland_jack> Cale: Someone posted that while I was away
13:32:49 <Iceland_jack> Apparently they're coming to get me
13:32:51 <delYsid> I am sort of confused by zipWith const.
13:32:56 <Cale> delYsid: So it's usually a good thing to avoid that by any means necessary
13:32:57 <Cale> Oh
13:33:02 <Cale> Well...
13:33:04 <Cale> :t zipWith
13:33:06 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
13:33:09 <Iceland_jack> delYsid: It's the same as 
13:33:09 <Iceland_jack>     \xs ys -> [ x | (x, _) <- zip xs ys ]
13:33:09 <Iceland_jack> if that helps
13:33:29 <Iceland_jack> > zipWith const [0..] "Testing"
13:33:30 <lambdabot>  [0,1,2,3,4,5,6]
13:33:58 <Cale> const x y = x  in case you weren't aware of that function
13:34:06 <delYsid> yes, I get that, but why does it do *anything* :-)
13:34:19 <Cale> delYsid: zipWith will stop when either of the lists end
13:34:20 <delYsid> I mean, I could just write  [0..]
13:34:28 <Iceland_jack> delYsid: The 'zip' part truncates the longer list to the length of the shorter
13:34:34 <delYsid> Cale: Aha! Thanks
13:34:52 <Iceland_jack> You would have to write … otherwise
13:34:52 <Iceland_jack> > [0..length "Testing"-1]
13:34:52 <Iceland_jack>  
13:34:54 <lambdabot>  [0,1,2,3,4,5,6]
13:35:04 <Cale> since one of the lists, the one which is formed by cycle, never ends, this just means to truncate that list to the length of the other
13:35:32 <Cale> which works a whole lot better in the infinite list case than trying to take the length of an infinite list :)
13:35:43 <Cale> (or in the case of a very long finite list)
13:35:52 <haskell983> thanks, but unfortunately it didn't work, here is my code so far: http://lpaste.net/144054  how can I produce a ["Hello", "World", "Test", "Hello"] instead of "HelloWolrdTestHello"? Thanks in advance
13:36:51 <Cale> haskell983: So, if you don't want the strings concatenated, why are you using the concatenation function (++)?
13:37:54 <Cale> haskell983: What is the type of makeList supposed to be?
13:38:23 <Cale> haskell983: It sounds like you want to form a list of strings and not just a string, but the right hand sides of these equations are clearly strings.
13:39:22 <Job314> Hi - I keep getting a resource busy error trying to write a number of lines to a file - http://lpaste.net/144055
13:39:36 <Job314> where have I made an error? The code kind of looks right
13:42:23 <mauke> you never close the files
13:42:29 <mauke> but you try to reopen them 5 times
13:43:00 <mauke> wait, how does this type
13:43:16 <Cale> It typechecks, it's just weirdly written
13:43:42 <Job314> doesn't the where only happen once?
13:43:43 <delYsid> > (\n -> zipWith const <$> drop n . cycle <*> id) 5 "abcdefg"
13:43:45 <lambdabot>  "fgabcde"
13:43:54 <delYsid> heh, I love this stuff.
13:43:54 <Cale> Job314: The where doesn't "happen"
13:43:55 <haskell983> Cale: Thanks, yes, thats my problem, I want to form a list of strings, but how can I achieve this? 
13:43:57 <mauke> there's shenanigans
13:44:08 <Cale> Job314: You're just *defining* the actions inHandle and outHandle
13:44:09 <mauke> how does this have any effects?
13:44:20 <Cale> Job314: which when executed, will open the respective files
13:44:24 <Job314> oh. Oops. How do I force it to happen and pass the handle?
13:44:24 <mauke> ah, it doesn't (beyond the open)
13:44:49 <jay6981> haskell983: from a list of strings from what? what are the arguments to the function you want to create?
13:44:53 <Job314> Are handles like a python with where it auto closes and flushes when the handle leaves scope?
13:45:00 <mauke> readFile source >>= writeFile sink
13:45:12 <Cale> Job314: writeFirstNLines n source sink = do inHandle <- openFile source ReadMode; outHandle <- openFile sink WriteMode; replicateM_ n (readAndWrite inHandle outHandle)
13:45:44 <mauke> Job314: you want 'withFile' for that
13:45:56 <Cale> and you probably want to close the handles afterward, but if that's the entirety of your program, I wouldn't worry about it
13:46:13 <mauke> I would, because buffering
13:46:15 <haskell983> sorry forgot this: makeList "Hello" 0 1 
13:46:19 <Cale> Yeah, withFile is generally nicer
13:46:31 <jre2> I have multiple copies of the same function processing some global input stream and want to make sure they run in lockstep (but at different speeds and starting at different points in the stream)
13:46:37 <Job314> in general, you want to use do blocks when working with files to force actions?
13:46:45 <jre2> Any suggestions on how I can exploit the inherent parallelism while keeping everything synchronized?
13:46:46 <Cale> Job314: It's not "force"
13:46:49 <mauke> 'do blocks' aren't really a thing
13:46:50 <jay6981> haskell983: ok so what is the 2nd and 3rd argument supposed to be?
13:47:14 <Cale> Job314: There is an important distinction which I think you're missing between evaluation of expressions and execution of IO actions
13:47:27 <Cale> Job314: These are two completely separate things
13:48:22 <Cale> Evaluation refers to the process of converting (the runtime representation of) expressions into values for the purposes of matching a pattern. It has no visible effects apart from using memory and CPU time.
13:48:25 <Job314> do blocks evaluate expressions, but the IO actions they specify might not be executed till later?
13:48:35 <mauke> do blocks don't evaluate expression
13:48:45 <Cale> Execution of IO actions means carrying out the steps described by those values, which *does* have effects.
13:49:07 <Job314> what's the right way to think about do blocks (or the right nomenclature for them)
13:49:11 <mauke> do blocks are syntactic sugar for >>=, which is a library function
13:49:20 <Cale> A do-block is a way of combining many smaller IO actions into an IO action which when executed will execute those smaller actions in turn.
13:49:28 <dmj> mauke: not always
13:49:31 <dmj> > do 1 + 1
13:49:33 <lambdabot>  2
13:49:41 <Cale> Evaluating an IO action does nothing visible, it just makes your computer slightly warmer
13:49:47 <mauke> that's why I said do blocks aren't really a thing: they desugar to normal expressions and don't exist at runtime
13:49:52 <haskell983> String -> Int -> Int -> .. (Output should be a list) n = number of strings in the output list, i = index of word of other list which contains the words 
13:50:03 <Cale> Executing an IO action can potentially have any effect your computer is capable of.
13:50:06 <mauke> or even at compile time
13:50:09 <dmj> mauke: yes, true
13:50:13 <Cale> Job314: Is that distinction clear?
13:50:34 <Job314> OH. Do blocks just make a bunch of IO things a single IO thing
13:50:42 <Cale> yes
13:50:45 <Job314> or any monad context
13:50:46 <jay6981> haskell983: i don't really like that you're referring to a global in your function, but ok
13:50:48 <mauke> pretty much
13:50:51 <Job314> (presumably not just IO)
13:50:57 <Cale> Job314: Yeah, and stop thinking in terms of "context"
13:50:57 <Job314> (or maybe just IO?)
13:51:11 <Cale> It works to combine actions in any monad
13:51:19 <mauke> btw, what threw me off in your code was that 'readAndWrite <$> inHandle <*> outHandle' has type IO (IO ())
13:51:28 <Cale> IO actions are values which describe something to be done
13:51:40 <Job314> mauke: yeah I think I did something silly to avoid that problem
13:51:57 <Cale> That is, for instance, a value x of type IO String is a *very* *very* different thing from a String
13:52:11 <Cale> It is a program which when executed, if it finishes normally, will result in a String
13:52:33 <Cale> i.e. it's the difference between /bin/ls and a list of files
13:52:35 <jay6981> haskell983: so the first parameter is what, the "other list"?
13:52:37 <mniip> question
13:52:42 <mniip> how do I implement append/3 in MPTC
13:53:16 <Job314> got it. A do block is a bunch of backed-up actions that, when you run them (like with an <-), will give you the thing promised.
13:53:25 <Cale> mniip: You reconsider the choices you're making with your life.
13:53:27 <Job314> (if all goes to plan)
13:54:07 <Cale> Job314: yeah, so eventually you end up defining an IO action called main
13:54:22 <Cale> Job314: and in a compiled Haskell program, execution starts with that
13:55:03 <Cale> Job314: and in turn, main may request the execution of many other IO actions (or you can think of it as being that they've really become part of main itself)
13:55:35 <Cale> Job314: Giving an IO action to ghci will cause ghci to execute it immediately
13:55:52 <Cale> (as opposed to just evaluating it and showing the result of evaluation, like it does in any other case)
13:56:03 <roelof> where can I find someone who wants to be a volunteer haskell mentor so I can do the exercises of the craft book and know if I do it the right way 
13:56:07 <Job314> yep, I've got a version of this that has a main block, it's just this function that was giving me problems
13:56:26 <Job314> (because I was opening files many, many times)
13:56:39 <Cale> Job314: So, yeah, these fancy applicative operators are a way to combine actions together as well
13:57:11 <Cale> Job314: readAndWrite <$> inHandle <*> outHandle basically means the same thing as  (do i <- inHandle; o <- outHandle; readAndWrite i o)
13:57:18 <pyon> Why does this require UndecidableInstances? `class Append a b c | a b -> c`, `instance () a a`, `instance Append a b c => Append (x,a) b (x,c)` ?
13:57:30 <pyon> If I remove the functional dependency, it doesn't require UndecidableInstances anymore. :-|
13:57:38 <Job314> ah so applicative is kind of like a do block
13:58:35 <haskell983> http://lpaste.net/144054 the "other list" contains strings, the first parameter of 'makeList "Hello" 0 1' should be the first word in the new list
13:59:03 <Cale> Job314: Kind of -- in that every Monad is also an Applicative in a particular way, and so in those cases where your Applicative is also an instance of Monad, you can rewrite the Applicative operations in terms of the Monad ones.
13:59:04 <Job314> through partial application, you're chaining things together
13:59:09 <Cale> (and then in terms of do-notation)
13:59:34 <Job314> you're not really doing it, you're defining the actions to be done
13:59:37 <Cale> So here, since inHandle and outHandle were defined as IO actions which open the file, and you're executing those actions inside the computation which you've given to replicateM_
13:59:49 <Cale> Then the file will be opened many times
13:59:54 <mniip> Cale, this is a serious question though
13:59:59 <mniip> it's not as simple as it seems
14:00:05 <mniip> and I need it desperately
14:00:16 <mniip> also hi pyon
14:00:30 <Cale> mniip: You really need all modes of it?
14:00:31 <Job314> makes sense, thanks!
14:00:38 <mniip> Cale, yes
14:00:42 <Cale> mniip: hmm
14:00:45 <mniip> all the functional dependencies
14:01:19 <mniip> actually that plus a bit more
14:01:23 <Cale> mniip: This is the kind of type level programming which I usually try to avoid by any means possible, but I believe people like Oleg have done things like this.
14:01:32 <mniip> basis :: (Num r, Append a a b) => Space b r
14:02:32 <Cale> I don't understand that at all :)
14:02:50 <mniip> b needs to be some list repeated twice
14:03:13 <Cale> I guess that might work with the right fundep
14:03:51 <mniip> GHC will deduce a from b
14:04:05 <mniip> but it seems like Append a a b => b would be an ambiguous type
14:05:59 <mniip> that's... an interesting collection of nicknames
14:06:09 <mniip> and host
14:06:09 <mniip> s
14:07:50 <Job314> seems legit
14:07:54 <sbrg> Anyone know if there's some way I can disable profiling for certain libraries my project depdends on? I am currently using stack and I have refactored my code so that all the code I want to profile is in a library that does not depend on gloss. Only the executable uses gloss. I would like to enable profiling only for this library and not the executable, because gloss takes *forever* to recompile.
14:08:14 <Cale> mniip: Well, it might not be ambiguous.
14:08:14 <bind> tiny but broad question ... any thoughts on how the onion/hexagonal architecture would translate to a functional language such as haskell?
14:08:25 <Cale> mniip: That's what functional dependencies are for after all
14:08:44 <Cale> mniip: But then, carrying that all the way through the computation of Append might be a bit hairy, I dunno.
14:08:46 <mniip> you have Append a b c | a b -> c, b c -> a, a c -> b
14:09:19 <mniip> I don't think you can deduce Λb. Append a a b exactly
14:09:20 <Cale> bind: I have no idea what that refers to
14:09:29 <bind> I mean .. in OO languages you have objects you pass in to others ... to provide the abstraction. For haskell that would mean that the functionality would have to be passed in as functions?
14:09:47 <Peaker> Can a .cabal package install header files in /usr/include (nicely)?
14:09:52 <Peaker> Or must I use a custom Setup.hs?
14:09:57 <mniip> bind, you mean hexagonal cells each holding a reference to 6 neighbors?
14:10:02 <Cale> bind: You can represent objects in Haskell, as records of methods.
14:11:03 <bind> Cale: http://alistair.cockburn.us/Hexagonal+architecture .. I mean that you make the business logic independent of the lower layers of the system (DB,io,apis)
14:11:27 <Cale> It's perfectly legitimate to do OOP in Haskell that way, where you make record types containing a bunch of functions according to what would be the public interface of your object, and then write "constructor" functions taking any "private" data in the object as parameters
14:12:17 <Cale> This "hexagonal" name seems totally inappropriate to me.
14:12:28 <Cale> What is 6-sided about this?
14:12:44 <pyon> Cale: The cute drawing, of course!
14:13:13 <pyon> If you mean something about the actual architecture... well, no idea. :-p
14:13:26 <Cale> anyway
14:13:30 <bind> being rather newish to haskell myself I was wondering about how one would do that ... having a piece of code dealing with the overall business logic (get things, mutate them, save things, send message, log) and separating this from the actual data access and logging implementation and such
14:13:50 <Cale> bind: One thing that is pretty standard to do is to abstract your application over the implementation of a bunch of operations
14:14:14 <Cale> bind: and obviously the fact that functions and IO actions are first class means that this is trivial to do
14:14:36 <Cale> You can package up a bunch of operations into a record, and pass them around, supplying them to the things which need them
14:15:06 <bind> so it would be a common thing to pass the operations around within a record thing?
14:15:11 <Cale> sure
14:15:25 <c_wraith> It's a good pattern.  It provides really clean solutions to certain problems.
14:15:40 <bind> makes sense
14:16:01 <bind> and I have no idea what is six-sided about it haha
14:16:18 <bind> but it has layers ... sometimes they call it onion architecture too
14:16:23 <Cale> bind: But see also...
14:16:44 <bind> Cale: yes?
14:16:52 <Hijiri> I think onions do onion architecture wrong, every layer is basically the same
14:17:12 <Cale> http://ulf.wiger.net/weblog/2008/02/29/simon-peyton-jones-composing-contracts-an-adventure-in-financial-engineering/
14:17:21 <Cale> ^^ this talk is pretty inspiring :)
14:17:29 <bind> well ... the outer layers are rather rough ... and the inner layers make people cry..
14:17:32 <Iceland_jack> bind: You can also create a custom data type to represent your operations (deep embedding), a simple example is
14:17:32 <Iceland_jack>     data Ops = Msg User Text | Ping Host | ...
14:17:32 <Iceland_jack> and manipulate those instead.
14:18:58 <Cale> Basically the idea presented by the talk is that rather than solve the one specific problem you're interested in right now, perhaps you would somehow represent a space of problems around it in terms of some primitive very simple things, and then a bunch of ways of combining problems, such that the solutions to the combined problems are a combination of the solutions to the individual ones.
14:19:27 <Cale> An example given is recipes for desserts (or "puddings" :)
14:19:54 <Cale> You might have some primitive ingredients, and ways to alter or combine them (whip, chop, mix, layer, etc.)
14:21:09 <Cale> and then from those descriptions, you can write functions which "interpret" the language of puddings, and transform them into, e.g. nutritional content information, English language descriptions of the recipe, animated depictions of how to make the thing, whatever you like.
14:21:14 <bind> Iceland_jack: how would I add some actual functionality based on that? (looks interesting)
14:21:31 <Cale> and the more serious example was doing this same approach with financial contracts
14:22:19 <Cale> So, here, rather than plugging in components which change the behaviour, we interpret the same "language" of sorts in various different ways to change how our program deals with things.
14:23:05 <bind> Cale: nice I will watch this :)
14:23:07 <Iceland_jack> bind: You manipulate them as you want and then wite a function that turns them into actions
14:23:08 <Iceland_jack>     run :: Ops -> IO ()
14:23:08 <Iceland_jack>     run (Msg user content) = sendMessageTo user content
14:23:08 <Iceland_jack>     run (Ping host)        = sendPingTo    host
14:23:15 <Iceland_jack> *then write
14:23:55 <Cale> You could take this quite far: maybe the "language" describes somehow the interactions required between two players playing a game, and then one interpreter would get input from both players, and another interpreter would have one player operate according to an AI
14:24:12 <bind> Iceland_jack: I see ... you would then have several run implementations where you could pass in the ops?
14:24:25 <Iceland_jack> Definitely
14:24:43 <Iceland_jack> It depends on what functionality you want
14:24:43 <Cale> bind: Yeah, you could have many different run functions which translate the abstract actions into different operations.
14:25:02 <Cale> Maybe in some cases not producing IO actions but something else
14:25:23 <kazagistar> "well ... the outer layers are rather rough ... and the inner layers make people cry.." <- funniest thing I read today
14:25:27 <Cale> Perhaps for testing, you'd rather have some kind of simulation of what would really happen in IO
14:26:31 <Peaker> I am packaging up a nice Haskell utility for linking large C programs nicely -- it has a header file that needs to be installed (for the C side). It doesn't seem .cabal has a way to install such a header file?
14:26:37 <bind> I still have to see how this would fit together in source code but thank you for the input! :)
14:26:47 <Iceland_jack> bind: You have more control over how you interpret your operations. If you want to stop users fom messaging you…
14:26:47 <Iceland_jack>     run :: Ops -> IO ()
14:26:47 <Iceland_jack>     run (Msg "Iceland_jack" _) = return ()
14:26:47 <Iceland_jack>     run (Msg user content)     = sendMessageTo user content
14:26:49 <Cale> A similar, but different approach to Iceland_jack's type would be:
14:27:16 <Cale> data Ops m = Ops { msg :: User -> Text -> m (), ping :: Host -> m (), ... }
14:27:55 <Cale> and then you might have things with types like   (Monad m) => Ops m -> m SomeResult
14:28:20 <Cale> and you can plug in a different monad m, with various implementations of the operations after
14:29:02 <Cale> So, you might have   ioOps :: Ops IO; ioOps = Ops { msg = sendMessageTo, ping = sendPingTo }
14:29:18 <Cale> Or you might augment those implementations later with logging or whatever
14:29:19 <bind> ff
14:30:08 <Cale> Or maybe you write something of type  Ops (State SimulationState) where msg and ping and the other operations just manipulate the simulation state somehow.
14:30:46 <Cale> (perhaps just logging that these operations would have taken place, or in a fancier example, they might need to have results, in which case their result might be computed somehow from the current state of the simulation)
14:30:56 <bind> so you would group the operations within a monad type of thing rather than a run function
14:31:25 <Cale> Yeah well, if your run functions are going to all produce actions in some monad anyway...
14:31:25 <jophish> I've written a type which is an instance of Num. I've got tests testing that it's a commutative ring and that abs is idempotent. but I've got no test for fromInteger
14:31:48 <jophish> What ways can I test fromInteger?
14:32:02 <Cale> bind: and that was already going farther in terms of abstraction than you'd usually even need to go
14:32:18 <Cale> bind: We can be less aggressive about it, and make it monomorphic too of course:
14:32:27 <Peaker> jophish: maybe that:  fromInteger x `op` fromInteger y == fromInteger (x `op` y)   for some ops ?
14:32:46 <Cale> data Ops = Ops { msg :: User -> Text -> IO (), ping :: Host -> IO (), ... }
14:32:51 <jophish> Peaker: yeah, that was the best I could come up with, but I wonder if there are sensible Nums which don't obey that
14:33:05 <bind> Iceland_jack: that is quite flexible :) just combining easy functions by matching ops
14:33:05 <jophish> for example Word
14:33:06 <Cale> bind: So this would be pretty much the imperative OO solution
14:33:26 <Cale> bind: Where we just pass in something like an object having "methods" which implement the operations directly.
14:33:27 <Peaker> jophish: For many ops it'll be true, I think, at Word
14:33:49 <Cale> bind: So there's a whole spectrum of related solutions here, of varying levels of abstraction
14:33:50 <jophish> the exception being negate
14:33:59 <bind> Cale: I see
14:34:18 <bind> Cale: I was hoping for that :) 
14:34:18 <ja`> hello
14:34:27 <Cale> bind: Depending on how far you want to go in terms of being able to analyse what your programs do without actually executing them
14:34:28 <jophish> The numeric hierarchy is so broken :(
14:34:54 <lpaste> ja pasted “Aesom multiple id” at http://lpaste.net/144062
14:35:31 <Peaker> jophish: negate . fromInteger == fromInteger . negate   for Word, at least I think :)
14:35:40 <ja`> How can I manage the js objects that have the same name fields?
14:36:17 <jophish> Peaker: yeah, you're right, I'd like to change my counterexample to use Natural
14:36:24 <jophish> > negate (1 :: Natural)
14:36:26 <lambdabot>  *Exception: Natural: (-)
14:36:28 <Cale> bind: With the completely abstract approach to operations, you might even get away from any Monad entirely (at least prior to writing your run functions) because (>>=) has a function argument, and functions are black boxes for analysis. So if you somehow found a way to avoid needing function arguments while building up the large scale representation of your programs, it's possible you could do deeper analysis on those 
14:36:28 <Cale> programs
14:36:33 <Peaker> jophish: Natural isn't a sensible Num, I guess
14:36:37 <zomg> ja`: js objects and haskell? care to elaborate?
14:36:41 <Peaker> jophish: though Num isn't a sensible class either :)
14:36:49 <jophish> Peaker: I couldn't agree more :)
14:36:52 <ja`> zomg: it's webservice
14:37:08 <Cale> bind: Like, if instead of running the program, you wanted to be able to translate what it would do into English or something.
14:37:26 <zomg> ja`: okay, and?
14:37:34 <Cale> bind: Or if you wanted to do a bunch of domain-specific runtime optimisations
14:37:50 <Cale> bind: then that kind of syntactic approach would be good
14:37:55 <bind> Cale would the monad approach be useful when I would also be able to report or list the things that would be done when an action would occur? Or is such a monad approach not tied to doing io?
14:38:09 <ja`> zomg: The web service returns objects with multiple fields that have the same name. As "id", "name" ...
14:38:44 <Cale> The approach I showed where I abstracted over the choice of a monad m would mean that you maybe can't do quite as deep an analysis, but would still let you do simulations which wouldn't carry out real I/O
14:38:52 <ja`> zomg: so I have the error:  Multiple declarations of ‘id’ ...
14:38:58 <Cale> By picking some other monad which didn't involve I/O in any way
14:39:01 <bind> Cale: I could imagine it would be appropriate to run a simulation without actual io but report on the actions that would be run nevertheless
14:39:13 <Cale> However, it might be quite a bit of work to set up those simulations in some cases of course.
14:39:19 <Cale> yeah
14:39:27 <bind> ok
14:39:28 <Iceland_jack> ja`: You're going to have to rename your record fields, at least until the next version of GHC (GHC 8)
14:39:31 <ja`> I wanted to know if there was a way around this with Aeson.
14:39:32 <Cale> But yeah, it's great for testing.
14:39:49 <zomg> ja`: yeah as Iceland_jack said, you need to have different names for the fields or do a qualified import or something
14:40:07 <ja`> version 7.10.2 :(
14:40:34 <Cale> bind: That you can apply stuff like quickCheck which will provide lots of random inputs to your programs, and check that the outcomes of things which ought to be the same are equivalent (in the simulation)
14:41:29 <bind> :)
14:41:51 <Cale> bind: Like, you could write equations which describe that certain network operations ought to commute with each other, i.e. it doesn't matter which order you do them in, the resulting state should be the same, and then use QuickCheck to test that for many randomly generated simulation states.
14:42:11 <Cale> Which is partly also testing your simulation...
14:42:20 <humanoyd> Is there a way to generate random email addresses with quickcheck?
14:42:42 <Iceland_jack> humanoyd: sure
14:43:07 <Cale> It's possible, but you probably have to write it
14:43:07 <bind> thank you Cale and Iceland_jack thats food for thought, I guess I will sleep well on this :-)
14:43:54 <bind> bye bye and have fun
14:43:57 <Cale> bind: later!
14:45:14 <joobus> is installing haskell through brew not recommended?  I just upgraded to 7.10.2 and now I can't import Data.Text among other things.
14:45:33 <joobus> mac osx obviously
14:46:05 <Welkin> joobus: probably not
14:46:13 <Welkin> just install ghc and cabal-install
14:46:21 <kadoban> joobus: I'd just install 'stack' and let it install GHC for you.
14:46:26 <Welkin> or that
14:52:14 <tertain_> :leave
14:53:38 <cu> oi
14:53:43 <Iceland_jack> oi
15:01:28 <ultratravolta> hi giys
15:02:59 <joobus> man, my installation is fubar
15:03:36 <Job314> (\ a b -> a + b) <$> [1,2,3] <*> [4,5,6] yields [5,6,7,6,7,8,7,8,9] - if I want just [5,6,7], what's the right way to create partial applications of map?
15:03:54 <danza> hi ultratravolta 
15:04:02 <Iceland_jack> Job314: 
15:04:02 <Iceland_jack> > zipWith (+) [1..3] [4..6]
15:04:03 <lambdabot>  [5,7,9]
15:04:14 <Iceland_jack> oops not what you asked for, afk
15:04:28 <Job314> yeah, but I already have a thing that does what (\a b-> a+b) is doing 
15:04:45 <Job314> and it's not as simple as +
15:07:09 <Purlox> How can it be anything other than (+) ? 
15:08:30 <Job314> I'm using int as an example here, it's really files that I'm using. and it's more a question of understanding what's happening than building an actual thing
15:09:28 <ephrion> zipWith ($) ((+) <$> [1,2,3]) [4,5,6]?
15:09:31 <Job314> for example, let's say I have let r =map (\a b -> a + b ) [1,2,3] which is of type [a->a], how do I give it [4,5,6]
15:09:45 <Cale> Job314: zipWith ($)
15:10:06 <Cale> Well, that's one thing you can do anyway
15:10:07 <Purlox> ^
15:10:18 <Cale> [a -> a] means a list of functions each of which has type a -> a
15:10:29 * Iceland_jack . o O (( Save one letter: 'zipWith id' ))
15:10:33 <Cale> So, you could presumably do a lot of things with those
15:11:01 <Cale> Yeah, zipWith id means the same thing, though ($) says "function application" much more forcefully than id does.
15:11:25 <Job314> huh
15:11:36 <Job314> is that a standard trick or does it mean I'm doing something wrong
15:11:52 <kadoban> It's a cute trick that's mostly pretty confusing to readers.
15:12:14 <kadoban> :t id
15:12:15 <lambdabot> a -> a
15:12:16 <kadoban> :t ($)
15:12:17 <lambdabot> (a -> b) -> a -> b
15:12:23 <kadoban> :t id :: (a -> b) -> a -> b
15:12:23 <Job314> I see
15:12:24 <lambdabot> (a -> b) -> a -> b
15:12:54 <kadoban> So it's 'id' with 'a' unifying with a function type
15:13:15 <Job314> actually I kind of like this, my function requires two list of inputs, instead of creating lists of partial applications, haskell is kind of telling me stop being clever and give me a tuple of two and zip your lists
15:14:02 <Job314> well, it requires two inputs, don't use two inputs and partially apply them, use a tuple for these related things
15:16:09 <maerwald> does someone know how lazy getDirectoryContents is or if there are alternative versions? I was wondering if I can recursively "open" all directories on the file system lazily. I guess that's not possible is it?
15:18:12 <sbrg> maerwald: it is. there are libraries that do it, based on pipes or conduit or something similar. there's also the recent FileWalker (IIRC) library
15:18:19 <sbrg> no, PathWalker I believe, or PathWalk
15:22:34 <NightRa> I'm trying to use the FFI for the first time, but I'm getting "parse error on input `foreign'"
15:22:39 <NightRa> Any ideas why that may be?
15:24:43 <jophish> NightRa: 
15:24:44 <jophish> {-# LANGUAGE ForeignFunctionInterface #-}
15:31:52 <tippenein_> anyone know how soon brew gets updates from ghc?
15:31:52 <tippenein_> `ghc does not have a version "7.10.2" in the Cellar.`
15:32:53 <jophish> tippenein_: you could always use stack
15:33:06 <jophish> or (slightly more involved) nix
15:39:09 <Sonolin> forkProcess is non-blocking right?
15:39:46 <maerwald> sbrg: the package directory-tree seems to be nice
15:41:41 <orion> Earlier I spoke with tommd about associating constant data with typeclasses. He suggested I use Tagged, but I am wondering if Tagged can even help me here: http://lpaste.net/1701791910986776576
15:42:18 <orion> Does anyone know how to alter the code above to make it print 7?
15:42:56 <orion> If Tagged can help me here, my understanding of how it works is lacking.
15:44:54 <sbrg> orion: what happens? 
15:44:57 <sbrg> it doesn't typecheck?
15:45:41 <lyxia> it should typecheck but I think the question is about how not to use undefined
15:47:08 <lyxia> orion: fooLength :: Tagged a Int makes the type of fooLength dependent on a without the requirement of ever providing a value of type a
15:47:44 <avangion> Hello! I just heard that on MacOS, I should use http://ghcformacosx.github.io to install Haskell… I had previously installed the Haskell Platform. Do I need to uninstall that and then reinstall from github.io?
15:49:01 <orion> It actually doesn't typecheck: Couldn't match expected type ‘a’ with actual type ‘a0 -> Int’ ‘a’ is a rigid type variable
15:49:03 <jophish> orion: you could look at how classes such as Floating implement constants (such as pi)
15:49:45 <maerwald> sbrg: e.g.: readDirectoryWithL return "/" >>= (\tree -> return . head . toList . dirTree $ tree )
15:49:47 <twanvl> orion: you need ScopedTypevariables
15:49:53 <maerwald> it lazily reads the whole filesystem
15:50:45 <sbrg> maerwald: I don't know the package, I'm afraid
15:50:53 <twanvl> the a in (undefined :: a) is not the same as the one in the type signature
15:50:59 <maerwald> just saying, that's the solution :)
15:51:00 <jophish> orion: sorry, I just looked at the code. You need ScopedTypeVariables and forall a. at the beginning of the type sig
15:51:59 <orion> Oh! "forall a." -- I didn't even consider that.
15:52:45 <lpaste> glguy annotated “No title” with “No title (annotation)” at http://lpaste.net/1701791910986776576#a144065
15:53:06 <orion> jophish: I can't consider Floating because the type signature isn't exactly the same.
15:53:18 <glguy> orion: To do it without extensions you can do what I pasted
15:53:31 <jophish> orion: yeah I didn't see you were returning an Int instead of an 'a'
15:55:47 <orion> glguy: Interesting. What are the (dis)advantages of proxy vs. Tagged?
15:55:54 <orion> vs. undefined
15:58:02 <lpaste> glguy annotated “No title” with “No title (annotation) (annotation)” at http://lpaste.net/1701791910986776576#a144066
15:58:38 <glguy> orion: You could do it with Tagged, too as above. I suppose that the nice thing about using Tagged is that functions don't have to be stored in the class
15:59:11 <glguy> orion: Using undefined means you must be very careful to remember which arguments you've promised not to use and ever inspect them
15:59:15 <glguy> it's error prone
16:00:51 <glguy> and in cases like this it give instance writters the impression that it's OK for the answer to vary with the input argument.
16:01:12 <glguy> while sticking to proxy and Tagged approaches conveys that the answer only depends on the type
16:02:30 <orion> That case statement is strange to me.
16:02:50 <twanvl> you could just as well use let or where
16:04:40 <orion> hmm
16:04:49 <orion> Also, where does 'proxy' come from? Data.Proxy?
16:07:28 <orion> http://stackoverflow.com/questions/22116363/what-is-the-purpose-of-data-proxy <-- this is very interesting to me
16:07:41 <lyxia> orion: it's a type variable which you can instantiate with []
16:07:46 <lyxia> or Maybe
16:07:51 <lyxia> etc
16:11:05 <Wizek> Hey! How practical is it to write an entire application consisting of total functions?
16:11:22 <c_wraith> orion: proxy (all lowercase) is used when you want your function to take a type argument.  because of polymorphism, you know the argument cannot be used.
16:13:18 <kadoban> Wizek: Pretty practical, but can sometimes be tedious. You just end up using Maybe a lot.
16:13:25 <orion> c_wraith: So in "r -> do print (proxy fooLength r)", r could literally be anything?
16:13:41 <sleblanc> What's the difference between the gtk and gtk3 packages on hackage?
16:14:42 <Wizek> so, I've become quite comfortable using maybe, .e.g I really enjoy binding Maybe functions tugether and fmap-ing over them
16:15:28 <Wizek> But I am worried that if the bind becomes too long, and I get a Nothing type at the end, I will have no idea where the computation went sideways and what might be wrong
16:16:01 <jophish> Wizek: Except
16:16:41 <jophish> @give Wizek Except
16:16:41 <lambdabot> Maybe you meant: time gsite dice cide
16:17:14 <jophish> https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html
16:17:37 <Wizek> Just at a glance: is this perhaps a generalised Either?
16:19:38 <edwardk> Wizek: with Either you can say in the 'Left' case why something went wrong. you can track your error and expose it to the user intelligently.
16:20:01 <edwardk> ExceptT is Either on steroids, letting you keep this information around even if you need to go out and do some IO effects, etc.
16:20:41 <Wizek> I am reading the docs and trying to wrap my head around it
16:22:22 <jophish> edwardk: I suggested on the libraries mailing list a couple of weeks ago adding a default definition for fromRational. Is it up to me to submit a patch somewhere for this?
16:23:08 <mniip> hey edwardk
16:23:14 <edwardk> jophish: we're in the process of trying to set up a place on the wiki for tracking Prelude-affecting proposals. This happens to fall into that umbrella, so things get rather complicated.
16:23:18 <Peaker> optparse-applicative seems to lack many1 -- defining it manually results in a bad --help screen
16:23:38 <Peaker> oh, I guess it's "some" :)
16:24:20 <jophish> edwardk: sure, I'm not in any hurry :) Luckily this is a non-breaking change
16:24:23 <edwardk> jophish: in general, yes. without a champion, small changes like that can fall into obscurity.
16:24:54 <edwardk> jophish: i'm working with Mike Meyer this week to see if we can get together a good place to manage such proposals, track community feedback, guidelines, etc.
16:25:37 <jophish> edwardk: sounds good to me. Is there a place where I should be keeping an eye out for this?
16:26:22 <Danny__> Hey guys- I'm trying to add bags together and I'm kind of struggling for a solution to my current issue. I have a guard statement that compares if the 2 heads are of the same element type and adds them up, however after that if statement I want to check if the element in bag1 is in bag2 so i can then perform an operation on that. Any idea how to implement this? Been trying for a few hours and can't seem to make any progress
16:27:30 <mniip> edwardk, I've come up with some Real Fancy stuff which GHC can't express :o
16:27:42 <edwardk> jophish: shoot me an email and i'll follow up after it exists =)
16:27:55 <edwardk> mniip: i have lots of real fancy stuff GHC can't express
16:28:04 <mniip> edwardk, if you can spare a minute, http://mathb.in/45265
16:28:31 <vektorweg1> is there any sane way of merging two lazy lists by time? 
16:28:37 <jophish> edwardk: wonderful, thanks.
16:28:40 <hpc> by time?
16:28:59 <vektorweg1> the elements in this list are delayed.
16:29:06 <vektorweg1> *lists
16:29:38 <mniip> vektorweg1, are you, by chance, talking about computation time?
16:30:05 <glguy> orion: The case statement is to ensure that r has a monomorphic type. let wouldn't work
16:31:08 <vektorweg1> mniip: i don't think so. i was thinking about networking and delayed packages and an easier way than picking heavy streaming libs to handle it. 
16:31:12 <edwardk> mniip: what gets in the way of implementing that stuff in haskell?
16:31:37 <mniip> edwardk, tensor dimensionalities are type-lists
16:31:44 <edwardk> and?
16:31:49 <edwardk> i can make an HList
16:32:00 <mniip> er
16:32:02 <edwardk> i do this with multicategories code all the time, this is a polycategory
16:32:04 <mniip> you mean '[]?
16:32:21 <edwardk> yes
16:32:39 <mniip> you can't implement fully-inferred append operation
16:32:42 <edwardk> when i last tackled tensors i used a list of up- and down- scripts
16:33:02 <mniip> like prolog's append/3
16:33:26 <edwardk> sure you can.
16:33:48 <mniip> hmmmm? I'd like to see that
16:34:48 <edwardk> you'd likely need virtual 'negative' lists included but otherwise it should all work out the same way my old type-int code worked
16:35:10 <edwardk> http://hackage.haskell.org/package/type-int gives a fully 3-way addition
16:35:47 <edwardk> by not trying to model type level naturals and instead going to type level ints both succ and pred are total.
16:36:11 <Wizek> Btw, I wonder, is it possible/practical to use Either, but pass put exception types into the Left hand side instead of strings? 
16:36:20 <Wizek> -pass
16:36:38 <Peaker> I wonder if optparse-applicative should really be an optparse-monad -- where if you use (>>=) you get "?" in --help unless you <?> to specify it.  Then if you already provided some arguments and you have dependent args, <tab> completion may be much more useful
16:36:40 <mniip> edwardk, I'm not seeing something here
16:36:42 <edwardk> regardless, if you have a requirement that the variables that occur are linear in the superscript and subscript with an explicit type constructor rather than a floating variable it should work
16:36:49 <mniip> can you provide an example?
16:37:00 <edwardk> not without going off on a week long tangent =P
16:37:10 <Peaker> tab completion in optparse-applicative seems to be really limited
16:37:25 <mniip> I mean for example,
16:37:28 <mniip> instance Append '[] ys ys
16:37:28 <mniip> instance Append xs ys rs => Append (x ': xs) ys (x ': rs)
16:37:37 <edwardk> that trick isnt good enough.
16:37:43 <edwardk> that gets you one direction
16:37:44 <mniip> but the first instance fails for the 2nd 3rd -> 1st fundep
16:38:12 <edwardk> the machinery i used there for TAdd uses 3 separate sets of definitions, each of which is partial
16:38:13 <mniip> oh I think I see what you mean
16:38:33 <mniip> we merge 3 fundeps into one tridirectional MPTC?
16:38:43 <edwardk> i compute the two addition orientations and the subtraction direction, into one final MPTC
16:38:48 <mniip> yes
16:38:59 <mniip> I have those 3 expressed as type families
16:39:02 <edwardk> then it uses whichever of the 3 inference paths it can to figure out the one missing unknown
16:39:17 <edwardk> you need to duplicate all of this logic over again in instances
16:39:40 <edwardk> then tie it all up inside one top level 'orchestration' style class/instance pair.
16:39:59 <edwardk> it can exist
16:40:21 <edwardk> you may need to suffer through closed type family tricks / overlapping instances due to the lack of 'negative' lists.
16:40:46 <mniip> uh
16:40:52 <edwardk> unlike the type-int code which can just always 2s complement and doesn't have any impossible results in any of the 3 directions. all 3 directions there are total
16:41:13 <edwardk> in your case, if you go to do an append backwards with something that isn't a prefix or a suffix it doesn't yield an answer
16:41:37 <mniip> something doesn't match u
16:41:47 <mniip> does coverage condition even examine the context?
16:42:14 <edwardk> there is only one instance of the orchestration class
16:42:24 <mniip> yes
16:42:26 <mniip> likewise here
16:42:35 <mniip> but it tells me that fundeps are dissatisfied
16:42:37 <Wizek> > case (Right 1 :: Exception e => Either e Int) of Left e -> throw e; Right a -> print a
16:42:38 <lambdabot>      No instance for (Exception e0)
16:42:38 <lambdabot>        arising from an expression type signature
16:42:38 <lambdabot>      The type variable ‘e0’ is ambiguous
16:43:21 <edwardk> then you need to think about it harder ;)
16:44:25 <Wizek> Hmm. I wonder why the above requires a concrete type while the below computes:
16:44:30 <Wizek> > let c = 1 :: Integral i => i in print 1
16:44:31 <lambdabot>  <IO ()>
16:44:56 <haskell782> hi, what can I use instead of 'on' here: "let uniqueLetter = concat . sortBy (compare `on` length) . groupBy (==) . sort in uniqueLetter s" http://lpaste.net/4206144584884944896 (should sort by occurrences and alphabet like "x8r8ar8" => "axrr888") Unfortunately I can't import Data.functions. Thanks in advance!
16:44:56 <edwardk> class TAdd a b c | a b -> c, a c -> b, b c -> a; instance (TAdd' a b c, TNeg b b', TAdd' c b' a, TNeg a a', TAdd' c a' b) => TAdd a b c  -- note the only one instance and how it uses the underlying TAdd instances. you can't just TNeg and TAdd backwards so the backwards directions are different than the forward
16:45:08 <mniip> right
16:45:13 <mniip> that's what I did
16:45:19 <edwardk> TAdd' has only one fundep, TNeg is bidirectional there.
16:45:26 <mniip> class App (a :: [k]) (b :: [k]) (c :: [k]) | a b -> c, a c -> b, b c -> a; instance (c ~ Append a b, b ~ Strip c a, a ~ Cut c b) => App a b c
16:45:35 <mniip> Append Strip Cut are type families
16:45:41 <orion> glguy: In your first annotation you wrote: "fooLength :: proxy a -> Int" Don't all types need to begin with a capital letter?
16:45:43 <edwardk> you got too eager diving into type families there
16:45:55 <edwardk> you need to move those to class constraints and stay in fundep land longer i think
16:46:15 <mniip> so type families are useless basically, right
16:46:49 <edwardk> Make class Appends a b c | a b -> c; class Strips a b c | c a -> b; class Cuts a b c | c b -> a
16:46:56 <glguy> orion: Only type constructors begin with a capital letter. Both proxy and a in that example are type variables
16:47:26 <mniip> edwardk, yeah, on it
16:47:44 <edwardk> then you can use both class & instance (Appends a b c, Strips a b c, Cuts a b c) => App a b c | a b -> c, a c -> b, c b -> a
16:48:05 <edwardk> but each one of those directions will be fun to get right
16:48:10 <edwardk> well appends is easy
16:48:32 <edwardk> anyways, point is, its doable =)
16:49:39 <edwardk> orion: proxy there is a type variable, it can unify with Maybe, [], Proxy, all sorts of things
16:50:19 <glguy> ... Either Bool
16:51:51 <mniip> edwardk, it complains :/
16:52:25 <vektorweg1> haskell782: `comparing` from Data.Ord
16:52:35 <orion> glguy / edwardk: But, where is it defined?
16:52:36 <lpaste> mniip pasted “Appends” at http://lpaste.net/144070
16:52:47 <glguy> orion: The same place as 'a' in that example
16:53:38 <mniip> edwardk, ^
16:53:55 <edwardk> UndecidableInstances was assumed in all this
16:54:09 <edwardk> you aren't shrinking all arguments at every step
16:54:15 <edwardk> so it has no notion of progress to use
16:54:27 <orion> glguy: Oh, you could have easily said: fooLength :: a b -> Int
16:54:34 <edwardk> instance Appends x y z => Appends (a ': x) y (a ': z) -- doesn't 'shrink' y.
16:54:42 <edwardk> so ghc can't figure out that that is all okay
16:54:49 <mniip> aha
16:55:07 <edwardk> UndecidableInstances will be part of whatever solution you derive here
16:55:24 <edwardk> so will most other extensions ;)
16:55:25 <vektorweg1> haskell782: if you are somehow bound to homework constraints or something then you can still copy the code of `on` to your code. 
16:59:01 <glguy> orion: The 'a' needs to be in the argument position, so 'b a' would have worked
17:02:28 <mniip> oh
17:02:30 <mniip> it compiled
17:04:38 <mniip> oh look
17:04:44 <mniip> deferred overlapped instances
17:06:30 <mniip> whoa
17:07:04 <mniip> it actually works
17:07:13 * mniip praises edwardk
17:08:42 <mniip> edwardk, well, here comes the second inexpressible thing
17:08:58 <mniip> basis :: Append a a b => Something b
17:09:01 <orion> glguy: Alright, that makes sense. Thank you. As it turns out, I am using ScopedTypeVariables, existential qualifiers, and proxy all at the same time. :|
17:09:27 <mniip> which GHC believes is ambiguous
17:10:35 <edwardk> mniip: sure. don't write that =)
17:11:09 <mniip> well, I guess I could do with Proxy a -> Something b
17:11:15 <mniip> and some typed undefined magic
17:11:24 <edwardk> or you can define a factoring class
17:11:29 <edwardk> expect to write a lot of classes here
17:11:36 <edwardk> to the point where by the time you're done you'll be sick of this
17:11:43 <mniip> I did write a halving type family
17:11:47 <edwardk> yep
17:11:56 <edwardk> same thing now at the typeclass level
17:11:57 <mniip> hahaha
17:12:04 <mniip> sick of writing type-foo, pfft
17:12:14 <mniip> you should see the code that is currently in use
17:12:22 <edwardk> i wrote type-int and then took a ~2 year break from such type hackery and template-haskell in general ;)
17:12:40 <mniip> it is the messiest combination of singletons, type-witnesses, and plain old untyped values
17:12:45 <edwardk> i eventually came back around, but it was literally the second project i ever undertook in haskell
17:13:16 <mniip> also
17:13:22 <mniip> is there any package providing countable kinds
17:13:31 <edwardk> unlikely
17:13:36 <mniip> sort of peano arithmetic on Void and Maybe
17:13:48 <mniip> er
17:14:01 <edwardk> given the general lack of ability to talk about kind equalities until 8.0 expect little
17:14:11 <mniip> countable types I meant
17:14:34 <mniip> Imagine a type-indexed vector
17:14:37 <mniip> with a total index function
17:14:58 <mniip> such that the type of the index just has as many inhabitants as the vector has slots
17:15:23 <mniip> that's the kind of thing I'm currently doing with Maybes and Voids
17:15:40 <acowley> I think there are a few Fin implementations floating around
17:15:57 <mniip> data Vector l r where Nil :: Vector Void r; Cons :: r -> Vector l r -> Vector (Maybe l) r
17:16:11 <acowley> But everything on top of Nats has honestly been really cramped due to the way the Nat kind was introduced
17:16:13 <edwardk> sure you are looking for a Fin-like thing
17:16:21 <mniip> tabulate :: (l -> r) -> Vector l r
17:16:26 <edwardk> and yeah Nat is kinda useless in its current form
17:16:31 <mniip> index :: Vector l r -> l -> r
17:16:47 <acowley> The easiest thing to do is just write your own Nat and then Fin
17:17:17 <mniip> yeah Nat is so broken I don't even
17:17:21 <mniip> it's only good for type families
17:17:22 <acowley> One day in the future things will settle down and we'll have useful canonical versions of them
17:17:27 <mniip> which are only good for other type families
17:17:33 <mniip> and everything sucks
17:17:38 <acowley> naturally
17:18:03 <edwardk> ok, wandering off. good luck mniip 
17:18:11 <mniip> see ya
17:20:06 <tabemann> lol I got yi to crash ghc
17:20:16 * hackagebot deepcontrol 0.5.1.0 - Provide more deeper level style of programming than the usual Control.xxx modules express  https://hackage.haskell.org/package/deepcontrol-0.5.1.0 (KONISHI_Yohsuke)
17:20:18 <tabemann> well crash the runtime more like
17:21:00 <tabemann> how the fuck'd I manage that?
17:24:24 <mniip> I like the tensor rendering function I wrote tho o.o
17:24:25 <mniip> http://i.imgur.com/l7NRHbY.png
17:29:41 <pavonia> old school ASCII boxes++
17:35:17 * hackagebot enummapset-th 0.6.1.0 - TH-generated EnumSet/EnumMap wrappers around IntSet/IntMap.  https://hackage.haskell.org/package/enummapset-th-0.6.1.0 (LiyangHu)
18:01:49 <pyon> @pl \xs ys -> foldr cons ys (toList xs)
18:01:49 <lambdabot> flip (foldr cons) . toList
18:03:11 <shachaf> foldr f z (toList l) = foldr f z l
18:03:56 <pyon> Oh, right!
18:08:38 <pyon> So, what's more idiomatic? `instance Applicative Foo where ... xs <|> ys = foldr cons ys xs` or `instance Applicative Foo where ... (<|>) = flip (foldr cons)` ?
18:11:22 <pyon> Errr s/Applicative/Alternative/ , of course
18:12:38 <shachaf> Don't use flip.
18:18:10 <pyon> shachaf: Besides `flip` and `(.)`-sections, what else could be considered “going too far” when writing point-free code?
18:25:57 <glguy> practically anything using the (->)r monad instance
18:47:11 <sm> mniip: yeah, tabulate looks cool.. is that from apl/j/k ?
18:52:38 <mniip> sm, nah tabulate is just a function->tensor thingy
18:52:49 <mniip> render is what turns multidimensional arrays into boxes
18:58:30 <ackthet> maybe slightly offtopic, but has anybody here used Clay (CSS preprocessor)?
18:59:08 <sm> mniip: ah.. is the boxing stuff available as a lib ?
18:59:16 <mniip> er
18:59:22 <mniip> it's so ugly I'd rather not
19:10:26 <nex> hello, I have a list of function [criteriaMin 50, criteriaMax 100] and a list of values [23, 43, 123], how could I output the list of value that matches the criteria ?
19:10:48 <nex> I'm able to do it with a single criteria by applying a filter but I'm confused when there's more criterias...
19:11:09 <shachaf> filter (\v -> all ($ v) ps) vs
19:13:12 <sm> mniip: I'd use it.. any chance of a paste ? :)
19:13:36 <mniip> it wouldn't work for you
19:13:45 <pavonia> > (\ps vs -> filter (\v -> all ($ v) ps) vs) [min 50, max 100] [23, 43, 123]
19:13:47 <lambdabot>      No instance for (Num Bool) arising from the literal ‘50’
19:13:47 <lambdabot>      In the first argument of ‘min’, namely ‘50’
19:13:47 <lambdabot>      In the expression: min 50
19:13:56 <mniip> my tensors are a GADT over a KnownDim-withessed dimension
19:14:09 <mniip> and that runs the entire thing in the boxes
19:14:24 <mniip> if you want to make your own, well just add spaces here and there
19:14:46 <pavonia> > (\ps vs -> filter (\v -> all ($ v) ps) vs) [(>= 50), (<= 100)] [23, 43, 123]
19:14:47 <sm> ok, no worries. APL/j/k users routinely have things automatically boxed in their interactive sessions and I'm interested in how that works
19:14:48 <lambdabot>  []
19:14:57 <pavonia> > (\ps vs -> filter (\v -> all ($ v) ps) vs) [(>= 50), (<= 100)] [23, 43, 75, 123]
19:14:58 <lambdabot>  [75]
19:15:28 <nex> aw, thanks! :)
19:15:45 <lpaste> mniip pasted “some perfectly idiomatic haskell” at http://lpaste.net/144082
19:31:26 <sm> mniip: thanks!
19:49:13 <python476> hi again
19:49:51 <python476> proving that sum . map (* 2) = (* 2) . sum is what equational reasoning is right ?
19:51:05 <python476> I'd love to find more about techniques to prove this kind of things, deriving properties of foldables formally
19:51:29 <MarcelineVQ> ditto
19:51:48 <dibblego> equational reasoning is one method by which you can derive that conclusion
19:52:32 <python476> hm so there's more 
19:52:35 <dibblego> specifically, replacing expressions with values, knowing that yu have an equivalent result, and doing so until you have the same expression in both cases
19:53:22 <python476> but in my case, what are the 'lemmas' used as proof steps 
19:53:44 <python476> some kind of distributivity / commutativity between recursive types ?
19:55:04 <python476> I'm reading Bird's book, Thinking Functionally. Early on he asks to think about this sort of things. Hence my venue.
19:57:20 <jakeehrlich> So I have a type “Language t v” which is conceptully a monad over the “v” type
19:57:43 <jakeehrlich> But “t” is a phantom type
19:58:39 <jakeehrlich> So often sub parts have a different “t” type which means that I can’t apply the supplyed function in bind to the sub parts
19:59:01 <jakeehrlich> What can I do about this?
20:10:46 <nex> If I have 'data Wow | Wow a b c deriving (Show)' and I don't do any 'getB (Wow _ b _) = b', is there another way to get "b" ?
20:12:05 <nex> (I'm trying to do something similar to Wow.b)
20:15:59 <deception1> "aa" < "z" results in true, what is the reasoning behind it ?
20:16:54 <glguy_> https://en.m.wikipedia.org/wiki/Alphabetical_order
20:19:03 <deception1> glguy: thanks :)
20:20:54 <MarcelineVQ> nex: there's a fair bit on this page that relates to that question you might find useful https://en.wikibooks.org/wiki/Haskell/More_on_datatypes
21:14:48 <Zemyla> @free undefined
21:14:49 <lambdabot> f undefined = undefined
21:14:54 <Zemyla> But that's not true.
21:17:22 <KaneTW> @free
21:17:22 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
21:19:48 <KaneTW> Zemyla: this generally happens when you pass in a bottom value
21:21:00 <Zemyla> If f is const 1, then it's not undefined.
21:21:21 <KaneTW> to free
21:21:31 <KaneTW> it can't handle values that are bottom
21:21:36 <KaneTW> @free error
21:21:37 <lambdabot> f . error = error . $map $id
21:29:37 <jle`> seems legit
21:30:07 <jle`> time to run a sed on all my source files
21:31:32 <jle`> jakeehrlich: you can write natural transformations forall a. Language t a -> Language s a, if that makes sense for your application
21:31:37 <jle`> then you can use sub-parts in big-parts
21:32:14 <jakeehrlich> jle`: unfortunetly that kind of transformation dosn’t make sense
21:32:38 <jle`> does the type signature for (>>=) make sense if you consider different t's?
21:33:05 <jle`> ie, would Language t a -> (a -> Language s b) -> Language s b, or something like that, make sense?
21:33:33 <jakeehrlich> depends what you mean by make sense I suppose. the right hand side of (>>=) never interacts with t 
21:33:42 <jakeehrlich> but the types don’t work out
21:33:57 <johnw> jle`: indexed monads can do that, but not the >>= you're used to
21:33:59 <jle`> i mean, could you write a function with that signature that makes sense with your application?
21:34:19 <jakeehrlich> this makes sense >>> Language t a -> (a -> Language s b) -> Language s b
21:34:23 <jle`> if so then yeah, Monad from Prelude might not be the right abstraction
21:34:25 <jakeehrlich> that is literally what I want
21:34:49 <jakeehrlich> basically “ Language t a -> (a -> Language s b) -> Language s b” is substitution in my language
21:52:13 <jakeehrlich> So IxMonad has one too many arguments in the functor
22:05:40 <adas> is there a vim plugin for haskell syntax colouring?
22:06:52 <jle`> i feel like vim should come with haskell highlighting out of the box
22:07:18 <jle`> but there are several vim packages to make editing haskell easier floating around on github, too :)
22:07:39 <adas> jle`: it does. but the types signatures are not coloured.
22:07:45 <adas> searching on git
22:10:37 * hackagebot amazonka-core 1.3.5 - Core data types and functionality for Amazonka libraries.  https://hackage.haskell.org/package/amazonka-core-1.3.5 (BrendanHay)
22:10:39 * hackagebot amazonka 1.3.5 - Comprehensive Amazon Web Services SDK.  https://hackage.haskell.org/package/amazonka-1.3.5 (BrendanHay)
22:10:41 * hackagebot amazonka-test 1.3.5 - Common functionality for Amazonka library test-suites.  https://hackage.haskell.org/package/amazonka-test-1.3.5 (BrendanHay)
22:16:00 * hackagebot amazonka-config 1.3.5 - Amazon Config SDK.  https://hackage.haskell.org/package/amazonka-config-1.3.5 (BrendanHay)
22:16:02 * hackagebot amazonka-sns 1.3.5 - Amazon Simple Notification Service SDK.  https://hackage.haskell.org/package/amazonka-sns-1.3.5 (BrendanHay)
22:16:04 * hackagebot amazonka-sqs 1.3.5 - Amazon Simple Queue Service SDK.  https://hackage.haskell.org/package/amazonka-sqs-1.3.5 (BrendanHay)
22:16:06 * hackagebot amazonka-glacier 1.3.5 - Amazon Glacier SDK.  https://hackage.haskell.org/package/amazonka-glacier-1.3.5 (BrendanHay)
22:16:08 * hackagebot amazonka-cloudhsm 1.3.5 - Amazon CloudHSM SDK.  https://hackage.haskell.org/package/amazonka-cloudhsm-1.3.5 (BrendanHay)
22:21:10 * hackagebot amazonka-dynamodb 1.3.5 - Amazon DynamoDB SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-1.3.5 (BrendanHay)
22:21:12 * hackagebot amazonka-datapipeline 1.3.5 - Amazon Data Pipeline SDK.  https://hackage.haskell.org/package/amazonka-datapipeline-1.3.5 (BrendanHay)
22:21:14 * hackagebot amazonka-iam 1.3.5 - Amazon Identity and Access Management SDK.  https://hackage.haskell.org/package/amazonka-iam-1.3.5 (BrendanHay)
22:21:36 <Adeon> I wonder if I should look at these amazon libraries at some point
22:21:46 <Profpatsch> Will foldl1' (&&) short-circuit?
22:21:47 <Adeon> the company I work at uses aws a lot but not from haskell
22:22:16 <jle`> Profpatsch: i know one way to find out :)
22:22:37 <Profpatsch> jle`: Debug.Trace? :)
22:22:50 <jle`> > foldl1' (&&) (repeat True)
22:22:56 <lambdabot>  mueval: ExitFailure 1
22:22:58 <jle`> er i meant
22:23:01 <jle`> > foldl1' (&&) (repeat False)
22:23:06 <lambdabot>  mueval: ExitFailure 1
22:23:08 <jle`> guess not :O
22:23:35 <Profpatsch> jle`: Ah, you mean depends on whether this is bottom
22:23:49 <Adeon> > foldl1 (&&) (repeat False)
22:23:52 <jle`> well, if it short-circuits, it would terminate
22:23:54 <lambdabot>  mueval-core: Time limit exceeded
22:23:55 <lambdabot>  mueval: ExitFailure 1
22:24:01 <Adeon> > foldl1 (&&) (repeat True)
22:24:06 <lambdabot>  mueval-core: Time limit exceeded
22:24:23 <jle`> > foldr1 (&&) (repeat False)
22:24:25 <lambdabot>  False
22:24:34 <jle`> if it short-ciruited, it would stop as soon as it knew the answer would be False
22:24:43 <jle`> (like in the foldr1 case)
22:25:42 <Profpatsch> Okay, so foldr can short-circuit.
22:25:59 <Profpatsch> Or does it depend on the function you give?
22:27:22 <jle`> well, the function you give has to be lazy on at least one argument to even apply.  that's the whole idea of short-circuiting...the result can be evaluated without one of the arguments, so it doesn't bother with it
22:27:28 <jle`> @src (&&)
22:27:28 <lambdabot> True  && x = x
22:27:28 <lambdabot> False && _ = False
22:27:39 <nshepperd> foldr f z (x:xs) = f x (foldr f z xs)
22:28:21 <nshepperd> so if f doesn't look at its second argument the folding "stops"
22:28:37 <Profpatsch> jle`: I see, so short-circuiting in lazy languages can happen when one argument is not needed.
22:29:01 <Profpatsch> What if the function was defined the other way around?
22:29:22 <Profpatsch> Would foldl be the short-circuiting fold then?
22:29:29 <Profpatsch> _ && False = False
22:29:53 <jle`> again, i do know one way to find out :)
22:29:58 <nshepperd> foldl never short circuits
22:30:16 <jle`> but you probably aren't interested in the "yes or no"; you might be more interested in why
22:30:28 <jle`> try exploring manually evaluating foldr and foldl from their definitions and you'll see
22:31:02 <jle`> @src foldr1
22:31:02 <lambdabot> foldr1 _ [x]    = x
22:31:02 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
22:31:02 <lambdabot> foldr1 _ []     = undefined
22:31:23 <jle`> foldr1 (&&) (False : repeat False) = False || foldr1 (&&) repeat False = False
22:31:25 <jle`> ta dah
22:31:45 <jle`> @src foldl1
22:31:45 <lambdabot> foldl1 f (x:xs) = foldl f x xs
22:31:45 <lambdabot> foldl1 _ []     = undefined
22:31:54 <jle`> @src foldl
22:31:54 <lambdabot> foldl f z []     = z
22:31:54 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
22:32:06 * hackagebot amazonka-kinesis-firehose 1.3.5 - Amazon Kinesis Firehose SDK.  https://hackage.haskell.org/package/amazonka-kinesis-firehose-1.3.5 (BrendanHay)
22:32:08 * hackagebot amazonka-route53-domains 1.3.5 - Amazon Route 53 Domains SDK.  https://hackage.haskell.org/package/amazonka-route53-domains-1.3.5 (BrendanHay)
22:32:10 * hackagebot amazonka-directconnect 1.3.5 - Amazon Direct Connect SDK.  https://hackage.haskell.org/package/amazonka-directconnect-1.3.5 (BrendanHay)
22:32:12 * hackagebot amazonka-elasticsearch 1.3.5 - Amazon Elasticsearch Service SDK.  https://hackage.haskell.org/package/amazonka-elasticsearch-1.3.5 (BrendanHay)
22:32:14 * hackagebot amazonka-devicefarm 1.3.5 - Amazon Device Farm SDK.  https://hackage.haskell.org/package/amazonka-devicefarm-1.3.5 (BrendanHay)
22:32:34 <jle`> foldl (&&) False (False : repeat False) = foldl (&&) (False && False) (repeat False) = foldl (&&) False (False : repeat False) = ...
22:32:40 <jle`> looks like it's going to go on forever
22:34:18 <nshepperd> I saw someone here describe it as a "transfer of control"
22:35:05 <nshepperd> 'foldr1 f (x:xs) = f x (foldr1 f xs)' ==> foldr transfers control to the function immediately, so it can exit (return a value) at any return
22:35:36 <nshepperd> 'foldl f z (x:xs) = foldl f (f z x) xs' ==> foldl transfers control back to itself every time until it reaches the end of the list
22:36:20 <nshepperd> er, s/at any return/at any time/
22:36:35 <Profpatsch> jle`: So foldr does not short-circuit when && is defined the other way.
22:37:06 <jle`> mhm
22:37:16 * hackagebot amazonka-cognito-sync 1.3.5 - Amazon Cognito Sync SDK.  https://hackage.haskell.org/package/amazonka-cognito-sync-1.3.5 (BrendanHay)
22:37:18 * hackagebot amazonka-elb 1.3.5 - Amazon Elastic Load Balancing SDK.  https://hackage.haskell.org/package/amazonka-elb-1.3.5 (BrendanHay)
22:37:20 * hackagebot amazonka-cloudformation 1.3.5 - Amazon CloudFormation SDK.  https://hackage.haskell.org/package/amazonka-cloudformation-1.3.5 (BrendanHay)
22:37:22 * hackagebot amazonka-sts 1.3.5 - Amazon Security Token Service SDK.  https://hackage.haskell.org/package/amazonka-sts-1.3.5 (BrendanHay)
22:37:24 * hackagebot amazonka-autoscaling 1.3.5 - Amazon Auto Scaling SDK.  https://hackage.haskell.org/package/amazonka-autoscaling-1.3.5 (BrendanHay)
22:37:40 <Profpatsch> jle`: What is are the arguments of && called then?
22:37:47 <Profpatsch> Is one strict and the othe lazy?
22:38:23 <jle`> we usually say that it's strict on the first argument and non-strict on its second
22:38:36 <jle`> (assuming that the final result is to be evaluated)
22:39:08 <Profpatsch> jle`: So strict means it can short-circuit in this argument?
22:39:45 <jle`> strict means that that argument must be evaluated in order for the final result to be evaluated
22:40:09 <Profpatsch> Because strict normally means that something is evaluated anyways, not just if it’s needed.
22:40:12 <jle`> so if we eventually want (blah1 && blah2) to be evaluated, then at least blah1 has to be evaluated.  in some cases, blah2 isn't evaluated
22:40:44 <Profpatsch> Ah, so it’s related.
22:40:57 <jle`> our short-circuiting here relies on the fact that there are cases where blah2 doesn't have to be evaluated.  so it can just drop that evaluation..."short-circuit"
22:41:06 <jle`> > foldr1 const [1..]
22:41:08 <lambdabot>  1
22:41:12 <Profpatsch> So in general, strict means something has to be evaluated, and lazy means something might not be evaluated.
22:41:30 <jle`> the terms are actually not always used formally and it isn't always clear
22:41:35 <jle`> so it's good to be explicit with what you mean
22:41:40 <jle`> and in what context
22:41:53 <Profpatsch> How would I be explicit in the case of &&?
22:42:17 <nshepperd> you can talk of conditional strictness. "False && y is lazy in y"
22:42:25 <nshepperd> I don't rememebr the exact terminology
22:42:26 * hackagebot amazonka-kinesis 1.3.5 - Amazon Kinesis SDK.  https://hackage.haskell.org/package/amazonka-kinesis-1.3.5 (BrendanHay)
22:42:28 * hackagebot amazonka-kms 1.3.5 - Amazon Key Management Service SDK.  https://hackage.haskell.org/package/amazonka-kms-1.3.5 (BrendanHay)
22:42:30 * hackagebot amazonka-cloudsearch-domains 1.3.5 - Amazon CloudSearch Domain SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-domains-1.3.5 (BrendanHay)
22:42:32 * hackagebot amazonka-cloudwatch 1.3.5 - Amazon CloudWatch SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-1.3.5 (BrendanHay)
22:42:34 <kadoban> I think they mean be explicit verbally, not necessarily in the code.
22:42:34 * hackagebot amazonka-iot-dataplane 1.3.5 - Amazon IoT Data Plane SDK.  https://hackage.haskell.org/package/amazonka-iot-dataplane-1.3.5 (BrendanHay)
22:43:03 <kadoban> *sigh* hackagebot
22:43:17 <Profpatsch> Does it also mean, in order to know which fold to use I have to look at the code?
22:44:39 <njosh> I am trying to solve  this problem: https://projecteuler.net/problem=14. I tried to build a Map of collatz sequence lengths like so:
22:44:39 <njosh> comap = Prelude.foldr
22:44:39 <njosh>         (\i m -> if even i
22:44:39 <njosh>                  then Map.insert i (1 + fromJust (Map.lookup (i `div` 2) comap)) comap
22:44:39 <njosh>                  else Map.insert i (1 + fromJust (Map.lookup (3*i+1) comap)) comap)
22:44:39 <njosh>         (Map.insert 1  1 Map.empty)
22:44:40 <njosh>         [2..100]
22:44:40 <njosh> I expected this to work for (lookup 10 comap). It gets stuck. Why is this happening? Or what exactly is happening here?
22:45:13 <jle`> Profpatsch: what i mean is, the case of x && y, if the result of x && y is to be evaluated, x is necessarily evaluated; y is potentially not evaluated
22:45:14 <kadoban> njosh: lpaste.net please
22:45:23 <jle`> that's what i mean by being explicit
22:45:37 <jle`> if the terminology is clear, people can say, "&& is strict on its first argument and non-strict on its second argument"
22:45:48 <lpaste> narendraj9 pasted “Collatz Sequence Lengths” at http://lpaste.net/144084
22:45:49 <jle`> but even that phrase is potentially ambiguous
22:45:55 <jle`> without explicit clarification
22:46:14 <njosh> kadoban: Okay. Sorry.
22:46:21 <njosh> kadoban: Done.
22:46:31 <Profpatsch> jle`: Ah, ok.
22:46:31 <jle`> because if you never evaluate the result of x && y, then x is also never evaluated
22:47:01 <Profpatsch> So in order to choose between foldl' and foldr, I should look at the code of my combining function?
22:47:21 <jle`> foldl' will never short-circuit
22:47:36 * hackagebot amazonka-cloudtrail 1.3.5 - Amazon CloudTrail SDK.  https://hackage.haskell.org/package/amazonka-cloudtrail-1.3.5 (BrendanHay)
22:47:38 * hackagebot amazonka-elasticache 1.3.5 - Amazon ElastiCache SDK.  https://hackage.haskell.org/package/amazonka-elasticache-1.3.5 (BrendanHay)
22:47:40 * hackagebot amazonka-waf 1.3.5 - Amazon WAF SDK.  https://hackage.haskell.org/package/amazonka-waf-1.3.5 (BrendanHay)
22:47:42 * hackagebot amazonka-importexport 1.3.5 - Amazon Import/Export SDK.  https://hackage.haskell.org/package/amazonka-importexport-1.3.5 (BrendanHay)
22:47:44 * hackagebot amazonka-s3 1.3.5 - Amazon Simple Storage Service SDK.  https://hackage.haskell.org/package/amazonka-s3-1.3.5 (BrendanHay)
22:48:26 <nshepperd> njosh: Data.Map isn't lazy in the spine
22:48:32 <nocturne777> hackage is so slow tonight
22:49:13 <njosh> nshepperd: Can you please elaborate? I couldn't get you. Because the input list here is finite ([2..100]).
22:50:13 <kadoban> njosh: It doesn't crash? It just hangs?
22:50:24 <Profpatsch> jle`: So how would I short-circuit a function that is strict in the second argument?
22:50:31 <njosh> I thought this would work because to the foldr comap is like a global and foldr makes elments inside it point to other elements. I thought laziness would make this work. 
22:50:33 <nshepperd> njosh: you have 'Map.lookup _ comap' in the construction of your comap there
22:50:38 <njosh> kadoban: No, it doesn't crash.
22:50:38 <Profpatsch> jle`: foldr1 (flip fun)?
22:50:52 <jle`> Profpatsch: well, only if that's actually what you want
22:50:59 <jle`> flipping a function doesn't in general return the same function
22:51:13 <jle`> flip (&&) is kinda the same as (&&), but that's not true of all functions in general
22:51:27 <nshepperd> njosh: that lookup needs to know what keys are in the map, basically, which requires evaluating all of the map construction
22:51:53 <njosh> nshepperd: Okay. Makes sense.
22:52:14 <jle`> Profpatsch: you have to give foldr1 a function non-strict on its second argument, so foldr1 (\x xs -> ... use fun here, making sure that xs is passed to a non-strict argument)
22:52:17 <Profpatsch> jle`: of course, for a commutative function.
22:52:23 <njosh> So, a lookup causes the whole map to be constructed. The values might stay unevaluated. 
22:52:31 <nshepperd> yeah
22:52:43 <nshepperd> by spine I mean the tree structure
22:52:46 * hackagebot amazonka-swf 1.3.5 - Amazon Simple Workflow Service SDK.  https://hackage.haskell.org/package/amazonka-swf-1.3.5 (BrendanHay)
22:52:48 * hackagebot amazonka-sdb 1.3.5 - Amazon SimpleDB SDK.  https://hackage.haskell.org/package/amazonka-sdb-1.3.5 (BrendanHay)
22:52:50 * hackagebot amazonka-codecommit 1.3.5 - Amazon CodeCommit SDK.  https://hackage.haskell.org/package/amazonka-codecommit-1.3.5 (BrendanHay)
22:52:52 <nshepperd> that has to be constructed to do a lookup
22:52:52 * hackagebot amazonka-codedeploy 1.3.5 - Amazon CodeDeploy SDK.  https://hackage.haskell.org/package/amazonka-codedeploy-1.3.5 (BrendanHay)
22:53:43 <njosh> I am still not able to visualize how exactly it is getting stuck. Is it stuck in a loop? contruction causing a lookup and lookup asking for the full map?
22:53:55 * hackagebot amazonka-cloudfront 1.3.5 - Amazon CloudFront SDK.  https://hackage.haskell.org/package/amazonka-cloudfront-1.3.5 (BrendanHay)
22:53:57 * hackagebot amazonka-efs 1.3.5 - Amazon Elastic File System SDK.  https://hackage.haskell.org/package/amazonka-efs-1.3.5 (BrendanHay)
22:53:59 * hackagebot amazonka-elasticbeanstalk 1.3.5 - Amazon Elastic Beanstalk SDK.  https://hackage.haskell.org/package/amazonka-elasticbeanstalk-1.3.5 (BrendanHay)
22:54:02 * hackagebot amazonka-apigateway 1.3.5 - Amazon API Gateway SDK.  https://hackage.haskell.org/package/amazonka-apigateway-1.3.5 (BrendanHay)
22:54:03 * hackagebot amazonka-ses 1.3.5 - Amazon Simple Email Service SDK.  https://hackage.haskell.org/package/amazonka-ses-1.3.5 (BrendanHay)
22:56:46 <nshepperd> njosh: oh, hold on, I'm not quite right
22:57:04 <nshepperd> that should work, since the keys aren't depending on the values
22:57:20 <nshepperd> I think the bug is here: Map.insert i (1 + fromJust (Map.lookup (i `div` 2) comap)) comap
22:57:21 <njosh> nshepperd: Yes, and the keys are finite.
22:57:31 <nshepperd> you want to insert into m, not comap
22:59:06 * hackagebot amazonka-support 1.3.5 - Amazon Support SDK.  https://hackage.haskell.org/package/amazonka-support-1.3.5 (BrendanHay)
22:59:08 * hackagebot amazonka-dynamodb-streams 1.3.5 - Amazon DynamoDB Streams SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-streams-1.3.5 (BrendanHay)
22:59:10 * hackagebot amazonka-redshift 1.3.5 - Amazon Redshift SDK.  https://hackage.haskell.org/package/amazonka-redshift-1.3.5 (BrendanHay)
22:59:12 * hackagebot amazonka-opsworks 1.3.5 - Amazon OpsWorks SDK.  https://hackage.haskell.org/package/amazonka-opsworks-1.3.5 (BrendanHay)
22:59:14 * hackagebot amazonka-emr 1.3.5 - Amazon Elastic MapReduce SDK.  https://hackage.haskell.org/package/amazonka-emr-1.3.5 (BrendanHay)
22:59:59 <njosh> nshepperd: Now, it crashes. So, it makes sense. But what exactly was happening while I referred to comap in its definition?
23:00:00 <kadoban> njosh: Once you fix up that part (assuming it can be fixed), I still don't think that's going to work. The things you're looking up either will never exist in the map, or won't exist yet by the time they're needed.
23:00:59 <njosh> kadoban: This makes sense. And I get an exception cause by fromJust. 
23:01:07 <kadoban> Okay, right.
23:01:07 <njosh> *caused
23:02:06 <kadoban> IIUC what it was doing was essentially recursing forever and making no progress. It'd get to the part where it does the lookup, say "okay, what's comap?" "oh here it is, let's start this foldr" … "okay, what's comap?"
23:02:50 <kadoban> So it'd never get past trying to insert 2
23:04:16 * hackagebot amazonka-cognito-identity 1.3.5 - Amazon Cognito Identity SDK.  https://hackage.haskell.org/package/amazonka-cognito-identity-1.3.5 (BrendanHay)
23:04:18 * hackagebot amazonka-ssm 1.3.5 - Amazon Simple Systems Management Service SDK.  https://hackage.haskell.org/package/amazonka-ssm-1.3.5 (BrendanHay)
23:04:19 <njosh> Okay. Now that you understand what I am trying to do, can you think of any way this can be done? I think I am trying to implement a function that should be memoized. I might refer to calls to this function whose values are not known yet, e.g. the lookup to a value yet to be inserted. 
23:04:20 * hackagebot amazonka-workspaces 1.3.5 - Amazon WorkSpaces SDK.  https://hackage.haskell.org/package/amazonka-workspaces-1.3.5 (BrendanHay)
23:04:22 * hackagebot amazonka-inspector 1.3.5 - Amazon Inspector SDK.  https://hackage.haskell.org/package/amazonka-inspector-1.3.5 (BrendanHay)
23:04:24 * hackagebot amazonka-rds 1.3.5 - Amazon Relational Database Service SDK.  https://hackage.haskell.org/package/amazonka-rds-1.3.5 (BrendanHay)
23:04:50 <kadoban> njosh: In terms of actually trying to solve this … I suspect you don't actually even need to bother trying to memoize the thing. Just doing it naively should work.
23:05:01 <kadoban> njosh: But for learning you can memoize if you want, how to do that …
23:06:25 <nshepperd> njosh: so there Map.insert was defining the spine of the finished product (comap). but inserting into comap depends on its spine to know where to insert
23:06:32 <njosh> kadoban: Yes, I am trying to memoize the results. The problem is that once I move past a value to a new value, I want to remember that the original length must eventually be added to the results that I am trying to remember.
23:07:16 <nshepperd> njosh: I expect the problem is your collatz sequence is going above your [1..100] range
23:07:26 <kadoban> njosh: I think the clearest way I'd start with would be an explicitly recursive function: col' :: Int -> Map Int Int -> Int     in col', you want to check if the 'x' you're looking for is in the map, if not you calculate it as 1 + col' blahblahblah. If it is, you just return it.
23:07:57 <kadoban> njosh: I personally find that easier to reason about, especially when I was starting. But that might just be me. (someone else might have better advice)
23:08:03 <nshepperd> a nice way to memoize functions on integers is the 'theIntegers' structure from the 'memoize' package
23:08:13 <nshepperd> it's literally a tree containing all the integers
23:08:55 <njosh> kadoban: I did the same as the first thing. Then I wanted to memoize the result of (1 + col' next_num), and this made it complex.
23:09:02 <kadoban> Hmm, actually the above might be a pain in the butt … maybe disregard. I'd probably have to try it and see if it ended up nice, heh.
23:09:08 <njosh> nshepperd: Thanks. WIll look into it. :)
23:09:26 * hackagebot amazonka-iot 1.3.5 - Amazon IoT SDK.  https://hackage.haskell.org/package/amazonka-iot-1.3.5 (BrendanHay)
23:09:28 * hackagebot amazonka-ds 1.3.5 - Amazon Directory Service SDK.  https://hackage.haskell.org/package/amazonka-ds-1.3.5 (BrendanHay)
23:09:30 * hackagebot amazonka-cloudwatch-logs 1.3.5 - Amazon CloudWatch Logs SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-logs-1.3.5 (BrendanHay)
23:09:32 * hackagebot amazonka-route53 1.3.5 - Amazon Route 53 SDK.  https://hackage.haskell.org/package/amazonka-route53-1.3.5 (BrendanHay)
23:09:34 * hackagebot amazonka-cloudsearch 1.3.5 - Amazon CloudSearch SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-1.3.5 (BrendanHay)
23:11:27 <njosh> kadoban: Okay :-D Thanks anyway. 
23:14:36 * hackagebot amazonka-storagegateway 1.3.5 - Amazon Storage Gateway SDK.  https://hackage.haskell.org/package/amazonka-storagegateway-1.3.5 (BrendanHay)
23:14:38 * hackagebot amazonka-ec2 1.3.5 - Amazon Elastic Compute Cloud SDK.  https://hackage.haskell.org/package/amazonka-ec2-1.3.5 (BrendanHay)
23:14:40 * hackagebot amazonka-elastictranscoder 1.3.5 - Amazon Elastic Transcoder SDK.  https://hackage.haskell.org/package/amazonka-elastictranscoder-1.3.5 (BrendanHay)
23:14:42 * hackagebot amazonka-lambda 1.3.5 - Amazon Lambda SDK.  https://hackage.haskell.org/package/amazonka-lambda-1.3.5 (BrendanHay)
23:14:44 * hackagebot amazonka-ecs 1.3.5 - Amazon EC2 Container Service SDK.  https://hackage.haskell.org/package/amazonka-ecs-1.3.5 (BrendanHay)
23:16:57 <kadoban> hackagebot doesn't do anything except announce new package versions, right? Will I be missing anything if I just /ignore it?
23:19:46 * hackagebot amazonka-codepipeline 1.3.5 - Amazon CodePipeline SDK.  https://hackage.haskell.org/package/amazonka-codepipeline-1.3.5 (BrendanHay)
23:19:48 * hackagebot amazonka-ml 1.3.5 - Amazon Machine Learning SDK.  https://hackage.haskell.org/package/amazonka-ml-1.3.5 (BrendanHay)
23:19:50 * hackagebot amazonka-marketplace-analytics 1.3.5 - Amazon Marketplace Commerce Analytics SDK.  https://hackage.haskell.org/package/amazonka-marketplace-analytics-1.3.5 (BrendanHay)
23:21:32 <roelof> Is there a problem with the mailing-list. I try to be a member of the haskell-cafe mailing list with xxx@home.xxx where xxx is a valid name and landcode 
23:22:19 <roelof> but I see a error message that I have to provide a valid mail adress , but this one is valid. I use it all the time for my normal mail 
23:23:57 * hackagebot pathwalk 0.3.1.1 - Path walking utilities for Haskell programs  https://hackage.haskell.org/package/pathwalk-0.3.1.1 (chadaustin)
23:24:30 <kadoban> roelof: What TLD is it? Is it an uncommon one? I dunno about haskell-cafe, but … email verification is notoriously shitty, in general. If there's something odd-but-valid, odds are like 50% that something will accept it.
23:24:51 <roelof> kadoban:  no the tld is nl 
23:25:05 <kadoban> Hmm
23:31:52 <roelof> I wanted to ask for a mentor which can help me some of the math questions of chapter 4 of the craft of functional programming book 
23:33:57 * hackagebot path-pieces 0.2.1 - Components of paths.  https://hackage.haskell.org/package/path-pieces-0.2.1 (MichaelSnoyman)
23:33:59 * hackagebot monad-logger 0.3.15 - A class of monads which can log messages.  https://hackage.haskell.org/package/monad-logger-0.3.15 (MichaelSnoyman)
23:39:16 <roelof> kadoban:  wierd, I tried another time and now no problems. Can it be that the page cannot handle the new MS browser(Edge) ?
23:41:33 <kadoban> Oh ya? That is odd. I have no idea.
23:44:41 <roelof> IM also not, but it worked and im happy now 
23:56:53 <emmanuel_erc> hello there everyone!
23:57:38 <roelof>  hello, emmanuel_erc 
