00:00:05 <bollu> jle`: right, but that's not very elegant, is it? Is there a nice way to see it? :)
00:00:28 <jle`> there are of course multiple monoids of order three
00:00:46 <jle`> so what instance should we pick for Ordering?
00:00:48 <bollu> jle`: could you say, construct an isomorphism to a group or some other monoid?
00:00:48 <arkeet> note that if x :: Ordering, then x = compare x EQ
00:00:51 <arkeet> now, observe
00:00:55 <arkeet> x <> y  =  compare (x,y) (EQ,EQ)
00:01:02 <arkeet> blah blah therefore <> is associative
00:01:14 <bollu> arkeet: I didn't know you could compare on tuples
00:01:18 <bollu> :t compare
00:01:19 <jle`> we should pick an instance that has some semantic relationship to the concept of an ordering
00:01:19 <lambdabot> Ord a => a -> a -> Ordering
00:01:26 <arkeet> tuples have an Ord instance so of course you can.
00:01:40 <bollu> arkeet: okay, I didn't know tuples had an ord instance
00:01:46 <bollu> arkeet: is it lexicographic?
00:01:48 <arkeet> yes.
00:01:50 <bollu> hm
00:02:05 <arkeet> and you could define it by
00:02:09 <montanonic> bollu: tuples are basically anonymous type constructers. (,), (,,), (,,,). 
00:02:09 <bollu> > compare (1, 1) (1, 2)
00:02:11 <arkeet> compare (x,y) (x',y') = compare x x' <> compare y y'
00:02:12 <lambdabot>  LT
00:02:39 <bollu> arkeet: isn't that recursive? x <> y  =  compare (x,y) (EQ,EQ) | (x,y) (x',y') = compare x x' <> compare y y'
00:02:50 <arkeet> I'm giving equations, not definitions.
00:02:52 <jle`> x and x' aren't tuples
00:02:57 <jle`> so they use a different `compare`
00:03:03 <bollu> montanonic: yes, I know :) But I wasn't able to think of a reasonable Ord for (,) in that instance
00:03:06 <jle`> they use whatever `compare` is defined for what their type is
00:03:16 <dfeuer> glguy, the extra stuff I've finally succeeded in implementing was basically in the nature of "given that we have the necessary equalities available, and we need something that can serve as an Iso, what's the most general form available?"
00:03:21 <jle`> compareTuple (x, y) (x', y') = compareX x x' <> compareY y y'
00:03:21 <bollu> jle`: ohh
00:03:28 <bollu> jle`: ah, right..
00:03:32 <bollu> hm
00:03:37 <bollu> :t compare
00:03:39 <lambdabot> Ord a => a -> a -> Ordering
00:03:46 <jle`> and now you see that we have to pick a monoid instance for Ordering that will make this make sense
00:04:16 <glguy> dfeuer: And then what sorts of things can we do in lens with that new generality?
00:04:50 <bollu> I'll go play with this :) ty guys
00:04:54 <jle`> you'd want EQ <> EQ = EQ, because if x and x' are equal and y and y' are equal, than (x,y) (x',y') should be compared to be equal
00:05:03 <jle`> you'd want EQ <> LT to be LT
00:05:09 <jle`> because of x and x' are equal, then it only depends on y and y'
00:05:37 <arkeet> LT <> _ = LT
00:05:38 <arkeet> EQ <> x = x
00:05:40 <arkeet> GT <> _ = GT
00:06:03 <bollu> it's weird, sort of like.. LT and GT are "attractors"
00:06:07 <dfeuer> glguy, I actually don't think it's likely to be very useful for lens per se (because all the interesting lenses have * kinds), but *some* of it seems like it might be useful elsewhere.
00:06:09 <arkeet> so you could try to argue that
00:06:16 <arkeet> if you have a bunch of Orderings in a row
00:06:21 <arkeet> and you <> them together
00:06:24 <bollu> > LT <> GT == GT <> LT
00:06:25 <lambdabot>  False
00:06:26 <dfeuer> glguy, really, it's more scratching an itch than trying to be practical....
00:06:30 <arkeet> then no matter how it associates, the result is the first non-EQ thing in the list.
00:06:35 <arkeet> (or EQ if they're all EQ.)
00:07:01 <arkeet> that would be a more direct proof.
00:07:18 <bollu> arkeet: hm, right. That is a nice way to look at it
00:07:28 <jle`> bollu: you can say that "az" < "zk", because 'a' < 'z'.  once you concllude that 'a' < 'z', you can ignore the rest of the string
00:08:04 <jle`> compare 'a' 'z' <> compare 'z' 'k' = LT <> compare 'z' 'k' = LT
00:08:06 <bollu> jle, arkeet: which is why you ignore the RHS of LT <> and GT <>
00:09:09 <jle`> we just pick it because it's a useful instance
00:10:19 <ss_> @lamdabot: foldr (\x acc -> ceiling $ (x + acc) / 2) 0 [1, 2, 3, 4] :: Int
00:10:20 <lambdabot> Unknown command, try @list
00:10:28 <ss_> @lambdabot: foldr (\x acc -> ceiling $ (x + acc) / 2) 0 [1, 2, 3, 4] :: Int
00:10:28 <lambdabot> Unknown command, try @list
00:10:30 <jle`> ss_: you know that you can pm lambdabot too, right? :)
00:10:47 <ss_> oh, didn't know that
00:10:59 <ss_> how do I pm
00:11:00 <jle`> you also probably want @eval foldr ..., or > foldr ...
00:11:16 <jle`>  /query lambdabot > foldr (:) [] "hello"
00:11:36 <jle`> well, it depends on your client i guess
00:12:47 <ss_> Thanks for the tip. But I wanted to show the error I am getting when I try to run that. I thought lambdabot would show the error here itself
00:13:16 <ss_> The error is "No instance for (RealFrac Int) arising from a use of ‘ceiling’"
00:13:51 <jle`> it means that you can only use `ceiling` on things that are instances of the `RealFrac` typeclass, but Int is not an instance of the RealFrac typeclass
00:14:11 <glguy> ss_: You also can't use the (/) operator on Ints
00:14:24 <bollu> jle`: can you think of the monoid on Ordering to be a lattice-to-monoid conversion or something?
00:14:37 <bollu> jle`: complemented lattice to monoid, maybe?
00:14:37 <quicksilver> any emacs haskell users? What are the cool kids using? I'm still using haskell-mode 2.8.0 from 2010 or so. Should I be using structured-haskell-mode? hdevtools? ghc-mod?
00:14:44 <bollu> jle`: I still want a nice representation
00:14:51 <ss_> So what would be the way to do that. I want to find the ceiling of the average of two numbers
00:14:56 <bollu> quicksilver: sublime text + ghc-mod
00:15:04 <jle`> do you need it as an Int?
00:15:09 <jle`> you can do the whole thing using Doubles, right?
00:15:23 <jle`> Double is an instance of both Fractional (so you can use (/)) and RealFrac (so you can use ceiling)
00:15:55 <quicksilver> bollu: that's not the emacs answer I require but thanks :)
00:16:43 <jle`> oh i see
00:16:44 <ss_> So, I should just use 0.0 instead of 0?
00:16:56 <jle`> no, sorry, i misunderstood the issue
00:17:29 <jle`> think about the type of the argument you're passing to foldr
00:17:34 <jle`> :t foldr
00:17:35 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
00:18:38 <jle`> if you want the result to be an Int, you should be passing a (a -> Int -> Int).  The `a` is what's in your list, so we can say Double, maybe.  so that's (Double -> Int -> Int), or whatever you pick to have in your list
00:19:14 <jle`> hm, we can pick the list to have Int's too maybe, if that would make it simpler, so it'd be Int -> Int -> Int
00:19:38 <jle`> so you need an Int -> Int -> Int.  right now you have (\x acc -> ceiling ((x + acc) / 2))
00:19:45 <ss_> I still didn't get it. What is the fix? 
00:20:07 <jle`> you can't use (/) on Int.  so you have to convert it into something that does have (/), like Double, using fromIntegral
00:20:27 <jle`>  (\x acc -> ceiling ( fromIntegral (x + acc) / 2) )
00:20:33 <bollu> ss_: are you familiar with the idea of a fixed point?
00:20:57 <bollu> ss_: it's the idea of applying a function on itself repeatedly. eg: f(x), f(f(x)), f(f(f(x))), ….
00:20:59 <jle`> and now fromIntegral (x + acc) / 2 can be a Double, which is a RealFrac, so you can call ceiling on it to give you an Int
00:21:06 <bollu> ss_: so, you "reach a fixed point" when x = f(x)
00:21:51 <jle`> > foldr (\x acc -> ceiling ( fromIntegral (x + acc) / 2 )) 0 [1..4] :: Int
00:21:53 <lambdabot>  2
00:22:28 <jle`> bollu: does the semantic representation that they represent lexicographical ordering appeal to you?
00:22:45 <ss_> ok thanks. this works. I am still not fully clear on all these numeric types and the conversions. Need to read a bit I guess.
00:23:01 <jle`> ss_: it just takes a bit of practice, i think :)
00:23:09 <jle`> the error message in this case wasn't particularly helpful
00:23:12 <ss_> bollu: I am familiar with fixed points, but how is it useful here?
00:23:25 <jle`> but it helps if you think about what x and acc *are*, as types...if they're both Ints, then you can't be using (/) in Int's
00:23:30 * hackagebot wigner-symbols 1.0.0 - CG coefficients and Wigner symbols.  https://hackage.haskell.org/package/wigner-symbols-1.0.0 (Rufflewind)
00:25:08 <bollu> jle`: kind of. I guess. I still want to do it by constructing an isomorphism to some "known" monoid :)
00:25:13 <bollu> jle`: if only just for fun
00:28:34 <jle`> bollu: imagine the left-zero semigroup {LT, GT}
00:28:48 <jle`> the ordering monoid is obtained by adjoining an identity element EQ to it
00:29:01 <jle`> such that x <> EQ = x, and EQ <> x = x for all x
00:30:24 <bollu> jle`: oh
00:30:34 <bollu> jle`: that is nice :)
00:31:08 <jle`> a left-zero semigroup is a semigroup where x <> _ = x for all x.  and you can turn any semigroup into a monoid by adjoining an identity element
00:31:22 <jle`> so this constructing a monoid from *the* order-2 left-zero semigroup
00:31:35 <jle`> i'm not sure if that's more interesting than the practical definition :P
00:33:32 <jle`> by the way, this process of constructing a Monoid from any Semigroup is in Haskell...it's called Maybe :)
00:35:11 <jle`> @data LeftZero2 = LZLeft | LZRight deriving Show
00:35:11 <lambdabot> Unknown command, try @list
00:35:17 <jle`> @let data LeftZero2 = LZLeft | LZRight deriving Show
00:35:19 <lambdabot>  Defined.
00:35:52 <ss_> jle`: Thanks for the help
00:36:15 <bollu> jle`: what? how?
00:36:16 <bollu> oh
00:36:17 <bollu> om
00:37:07 <jle`> @instance Data.Semigroup.Semigroup LeftZero2 where x Data.Semigroup.<> _ = x
00:37:07 <lambdabot> Maybe you meant: instances instances-importing
00:37:13 <jle`> @let instance Data.Semigroup.Semigroup LeftZero2 where x Data.Semigroup.<> _ = x
00:37:13 <lambdabot>  Parse failed: Parse error in pattern:
00:37:29 <jle`> @let instance Data.Semigroup.Semigroup LeftZero2 where x <> _ = x
00:37:30 <lambdabot>  .L.hs:157:10:
00:37:30 <lambdabot>      Not in scope: type constructor or class ‘Data.Semigroup.Semigroup’
00:37:33 <jle`> im sorry
00:37:56 <jle`> but yeah, type Ordering = Maybe LeftZero2
00:38:02 <jle`> ta dah
00:38:30 <jle`> this is using the Semigroup a => Monoid (Maybe a) instance from the `semigroups` package
00:39:21 <bollu> jle`: huh
00:39:25 <bollu> jle`: that's really cool
00:40:07 <jle`> i got it from wikipedia ._.
00:40:24 <arkeet> nice observation.
00:40:41 <bollu> xD
00:41:10 <bollu> so, any semigroup can be "completed" to a monoid by adjoining a trivial identity
00:41:11 <bollu> ?
00:41:37 <jle`> yeah, http://hackage.haskell.org/package/semigroups-0.17.0.1/docs/Data-Semigroup.html#t:Option
00:53:31 * hackagebot polar-configfile 0.2.0.0 - Fork of ConfigFile for Polar Game Engine  https://hackage.haskell.org/package/polar-configfile-0.2.0.0 (Shockk)
00:58:31 * hackagebot polar-configfile 0.2.0.1 - Fork of ConfigFile for Polar Game Engine  https://hackage.haskell.org/package/polar-configfile-0.2.0.1 (Shockk)
01:03:31 * hackagebot ede 0.2.8.3 - Templating language with similar syntax and features to Liquid or Jinja2.  https://hackage.haskell.org/package/ede-0.2.8.3 (BrendanHay)
01:05:36 <bollu> is there a canonical symbol for "compare" ?
01:06:07 <bollu> I'm writing the proof of the monoid construction, and I would like an infix operator :)
01:06:51 <liste> some (horrible) languages use <=>, aka spaceship operator
01:07:03 <liste> though they return -1, 0 or 1
01:07:09 <liste> that returns*
01:12:13 <arahael> liste: What's the <> called?  A shuttle operator?
01:12:50 <arkeet> bollu: how abuot `compare` ?
01:12:52 <arkeet> > 1 `compare` 2
01:12:54 <lambdabot>  LT
01:13:02 <bollu> arkeet: no, I'm latexing it
01:13:06 <arkeet> not that infix gets you much anyway.
01:13:08 <bollu> and, like, `compare` looks very strange
01:13:56 <phadej> arkeet: mappend
01:14:00 <thimoteus> might look strange but it probably has higher recognition value than any equivalent infix operator
01:14:03 <phadej> arahael: mappend
01:14:30 <arahael> phadej: I meant in the context of "some (horrible) languages use <=>"
01:14:40 <arahael> phadej: Delphi, for instance, uses <> for comparisons.
01:14:54 <arahael> (That's "not equal", in haskell this would be /=)
01:14:57 <phadej> arahael: some languages use <> for /=, which some languages use !=
01:15:02 <phadej> :)
01:15:09 <davidar> bollu: ⌋⌈
01:15:11 <thimoteus> which languages use <> for /=?
01:15:16 <bollu> phadej: that's done by pascal as well
01:15:39 <phadej> thimoteus: ^
01:15:50 <thimoteus> pascal? that's wacky
01:15:52 <bollu> davidar: I can't tell if you're kidding or my font rendering is broken. It looks like two rectangles?
01:16:16 <bollu> davidar: what's the latex name for it?
01:16:24 <phadej> thimoteus: also coq, as a <> b = not (a = b)
01:16:31 <davidar> bollu: it's right floor followed by left ceiling
01:16:39 <davidar> doubt it's standard though :p
01:16:40 <phadej> or (a = b) -> False
01:16:51 <phadej> don't remember right now
01:16:59 <arkeet> also visual basic.
01:17:03 <phadej> :)
01:17:19 <arkeet> or basic in general, I suppose.
01:20:34 <davidar> bollu: I'd say the standard notation is just H(a-b)
01:20:34 <bollu> davidar: what is H?
01:20:34 <davidar> bollu: heaviside step function
01:20:38 <bollu> oh, BTW, could someone proof-read this? I just wrote up whatever jle` explained and proved the associativity
01:20:39 <bollu> http://www.texpaste.com/n/4dy3i3wz
01:20:53 <bollu> davidar: that's the derivative of the dirac delta?
01:21:57 <davidar> bollu: the other way around, to the extent you can really call it a derivative
01:22:11 <srhb> It's "a physicists derivative" :-)
01:22:25 <bollu> oh, right, sorry. The drivative of dirac delta just picks the derivative of the function at x
01:22:54 <davidar> srhb (IRC): i guess it's valid as a radon derivative
01:23:16 <srhb> davidar: Something for me to google. :)
01:23:32 * hackagebot equational-reasoning 0.2.0.7 - Proof assistant for Haskell using DataKinds & PolyKinds  https://hackage.haskell.org/package/equational-reasoning-0.2.0.7 (HiromiIshii)
01:23:36 <davidar> srhb (IRC): https://en.wikipedia.org/wiki/Radon%E2%80%93Nikodym_theorem
01:23:37 <bollu> the derivative of the dirac delta broke my mind the first time I saw it
01:23:44 <srhb> davidar: Thanks.
01:23:52 <arkeet> bollu: well, the negation of the derivative.
01:24:11 <bollu> arkeet: hm? depends on the order of your parameters IIRC
01:24:15 <arkeet> no?
01:24:28 <arkeet> also it kinda works if you picture it like
01:25:06 <arkeet> delta is approximated by bump functions
01:25:21 <arkeet> so what does the derivative of such a bump function look like.
01:25:51 <bollu> arkeet: http://www.wolframalpha.com/input/?i=gaussian+function+derivative :)
01:25:59 <arkeet> yeah.
01:26:23 <arkeet> so if you pair it with a function
01:26:32 <arkeet> it picks out a small positive contribution from just before 0
01:26:36 <arkeet> and a small negative contribution from just after 0.
01:26:41 <bollu> oh, shit, that is sweet. Okay, yeah, I get what you're trying to say. It'll "sample" the function at two infinitesimal points
01:26:46 <arkeet> yeah.
01:27:04 <bollu> arkeet: but where is the "/h" in the denominator in that case? I proved the derivative property by using differentiation under the integral
01:27:35 <bollu> arkeet: all you have so far is f(x - h) - f(x + h), right?
01:27:56 <davidar> bollu: hence i said "to the extent you can call it a derivative"
01:28:10 <davidar> i suspect you need to get a lot deeper into measure theory for a proper answer
01:28:23 <arkeet> well I wasn't trying to give anything more than intuition.
01:28:43 <arkeet> although I'm guessing you can make it rigorous.
01:28:57 <arkeet> if you have a sequences of functions approximating delta,
01:29:03 <arkeet> I hope their derivatives approximate the derivative of delta.
01:30:30 <bollu> davidar, arkeet: this was what I'd done http://pixel-druid.com/math/dirac-delta-derivative/
01:30:33 <bollu> does that make sense?
01:37:31 <bollu> jle`: Um, this is what you explained to me, right? http://www.texpaste.com/n/4dy3i3wz
01:39:44 <jle`> bollu: mhm.  my favorite part about the whole thing though was that it was the monoid from *the unique* order-2 left zero semigroup, so maybe showing it as {a, b, e}, and assigning the names after would be closer to what i was saying
01:40:42 <jle`> but that's just a minor thing
01:40:44 <bollu> jle`: is this not more general? (like, this will be an order-n left zero semigroup, right?)
01:41:28 <jle`> yeah, the i'm talking about the last line
01:42:21 <bollu> ah, right :)
01:42:39 <jle`> the ordering monoid *is* the the monoid from the unique order-2 left zero semigroup.  but in the end you get the same result
01:42:45 <jle`> my comment is practically meaningless :)
01:42:57 <delYsid> Is there a simple way to teach ghci to *not* include all imported modules in the prompt?
01:42:59 <bollu> Now I need to show the Maybe thing as well
01:44:29 <bollu> jle`: unique, upto isomorphism right?
01:44:38 <merijn> My life's goal is to be as effective/amusing a speaker as Wadler...
01:46:00 <jle`> bollu: ya
01:46:12 <bollu> :t Option
01:46:14 <lambdabot> Not in scope: data constructor ‘Option’
01:46:53 <jle`> :t Data.Semigroup.Option
01:46:54 <lambdabot> Maybe a -> Data.Semigroup.Option a
01:58:33 * hackagebot type-natural 0.3.0.0 - Type-level natural and proofs of their properties.  https://hackage.haskell.org/package/type-natural-0.3.0.0 (HiromiIshii)
02:13:49 <bollu> guys, what are some approachable but must-read Haskell papers?
02:13:55 <bollu> (maybe without too much Cat theory)?
02:14:03 <opqdonut> the finger tree paper is good IIRC
02:14:19 <merijn> bollu: "A Tutorial on the Universality and Expressiveness of Fold"?
02:14:38 <merijn> Not really haskell specific, but the examples are mostly haskell, as far as I remember
02:14:59 <merijn> That one basically shows "any recursive function can be rewritten as fold + a trivial helper"
02:15:25 <opqdonut> I remember reading a paper about iteratees/pipes/conduits that was nice. no idea which one it was though
02:16:23 <exio4> bollu: "beautiful concurrency"?
02:16:27 <kqr> i liked the stg paper
02:16:47 <merijn> Yes, the STG paper is excellent
02:17:13 <merijn> "Implementing Lazy Functional Languages on Stock Hardware: The Spineless Tagless G-machine"
02:18:08 <merijn> I'd recommend you be at least a little familiar with C/asm for that one, though
02:24:33 <bernalex> is there some sort of "undefined" that I can use for data?
02:24:51 <kqr> bernalex, what does the question mean?
02:24:54 <Cale> :t undefined
02:24:55 <lambdabot> t
02:24:57 <Cale> ^^
02:25:02 <indiagreen_> bernalex: Void, maybe?
02:25:15 <kqr> bernalex, do you literally want something that says "hey explode if you evaluate me"
02:25:25 <bernalex> kqr: yes, is there some useful trick I can use for data Foo = ... that will blow up at runtime?
02:25:32 <kqr> yes, undefined
02:25:37 <kqr> or oh
02:25:41 <kqr> you mean in a data declaration
02:25:44 <bernalex> undefined is not a data constructor.
02:25:46 <bernalex> yes.
02:26:02 <kqr> maybe EmptyDataDecls and then just "data Foo"
02:26:32 <dzhus> Is there a function in some package of type :: Int -> [a] -> [[a]] that splits a list into a list of sublists of length no bigger than the provided integer? f 3 [1, 2, 3, 4, 5, 6, 7] = [[1, 2, 3], [4, 5, 6], [7]]
02:26:40 <bernalex> kqr: oh yeah that could work. thanks!
02:26:43 <Cale> bernalex: data constructors don't tend to be undefined either
02:26:54 <Cale> Or did you mean type constructor?
02:27:03 <indiagreen_> dzhus: http://hackage.haskell.org/package/split-0.2.2/docs/Data-List-Split.html#v:chunksOf
02:27:07 <Cale> Type constructors also...
02:27:14 <dzhus> indiagreen_: that's it, cheers
02:27:14 <Cale> bernalex: Types don't even exist at runtime
02:27:25 <Cale> bernalex: The compiler removes them as part of compiling your program
02:27:45 <bernalex> Cale: yes, I know how that works. I said I wanted a trick like undefined that blows up at runtime. EmptyDataDecls will work for that purpose, I think.
02:27:51 <Cale> uhhh
02:27:59 <Cale> I don't understand why it would?
02:28:11 <Cale> but okay
02:28:16 <kqr> bernalex, EmptyDataDecls won't let you even pretend to construct a value of the required type
02:28:18 <merijn> I think he just wants "Void" to signify non-termination
02:28:37 <kqr> bernalex, also keep in mind -fdefer-type-errors exists
02:28:38 <merijn> kqr: It's trivial to construct a value of a type that uses EmptyDataDecls
02:28:50 <merijn> Also, isn't EmptyDataDecls in Haskell2010? i.e. not an extension
02:28:57 <Cale> If you want to signify that something won't terminate, usually the best way is just to use a distinct type variable for the result.
02:29:09 <bernalex> ah, right. if I have data Foo; f :: Foo -> Foo; f = id -- that will probably blow up at compiletime not runtime.
02:29:19 <Cale> no
02:29:24 <Cale> That's fine
02:29:27 <merijn> bernalex: Why would it?
02:29:29 <bernalex> it is?
02:29:38 <Cale> sure
02:29:42 <bernalex> interesting.
02:30:03 <Cale> The identity function doesn't tend to ever be a problem.
02:30:13 <merijn> Turing completeness -> all types are inhabited -> why would that not work?
02:30:16 <merijn> Hell
02:30:27 <Cale> Even in Agda that type is inhabited.
02:30:31 <merijn> Even in a total language where you *can't* construct Foo that's fine
02:30:33 <Cale> by the identity function
02:30:35 <Cale> yes
02:30:47 <Cale> 0^0 = 1 after all ;)
02:30:50 <merijn> Because that's just "a implies a" which is always true
02:31:13 <Cale> yep
02:31:41 <Cale> False does indeed imply False. :)
02:32:40 <Gurkenglas> Cale, fix id.
02:33:07 <Cale> Gurkenglas: That wouldn't be available in Agda
02:33:27 <Cale> (it requires fix, which you can't write)
02:33:30 <merijn> fix, by definition, is not allowed in total languages
02:33:45 <Cale> Well, the Agda developers hope you can't write anyway ;)
02:34:03 <MarcelineVQ> Does agda have anything like the ffi?
02:37:28 <Cale> MarcelineVQ: I believe it has Haskell FFI :)
02:37:48 <Cale> Also, there is a way to turn off the termination checker if you need to for such things.
02:38:48 <merijn> It's basically "unsafePerformRecursion" instead of "unsafePerformIO"
02:38:51 <merijn> :p
02:39:01 <Cale> {-# NON_TERMINATING #-}
02:41:03 <Cale> https://agda.github.io/agda-stdlib/IO.Primitive.html#1
02:41:08 <Cale> https://agda.github.io/agda-stdlib/IO.html#1
02:42:32 <liste> is writing the critical parts of software in Agda and non-critical parts in Haskell a common strategy?
02:45:05 <merijn> liste: No, a more common approach would be writing a proof in Coq and extracting ocaml/haskell from that
02:46:08 <merijn> Look at CompCert for a neat example of formally verified compiler
02:46:21 <merijn> (for C)
02:46:57 <bollu> question: you can have a "terminating" fix in a lot of cases that finds a fixed point and returns it
02:47:01 <bollu> would that not be allowed?
02:47:09 <merijn> They are now working on things like provably correct optimisations. i.e. the optimisation passes have to have a proof that they are semantic preserving
02:47:12 <bollu> like, fix (cos) 1 == 0.7<whatever? 
02:47:24 <ttt_fff> ghc + ghcjs is so awesome
02:47:26 <merijn> bollu: Well, you can't have fix exactly, but you can compute fixpoints
02:47:38 <bollu> merijn: and if it diverges?
02:47:40 <merijn> bollu: You either use structural recursion of corecursion
02:47:46 <bollu> merijn: do you do a bounded computation?
02:47:52 <merijn> bollu: Basically, you can only have provably converging fix :)
02:47:54 <bollu> oh, I don't know what that is
02:47:57 <bollu> ohh xD
02:48:07 <bollu> hm, how _do_ you prove that cos converges?
02:48:12 <merijn> bollu: structural recursion is, well, recursing on structure :)
02:48:12 <bollu> Brouwer?
02:48:16 <bollu> fixed point theorem?
02:48:26 <liste> merijn cool (: so they generate C from Coq?
02:48:26 <Cale> bollu: What type of numbers are you talking about?
02:48:50 <bollu> Cale: I meant finding fixed points of functions (i.e, prove that cos has a fixed point starting from 1)
02:49:05 <merijn> bollu: Say using lists if my recursion matches on "(x:xs)" and I only use "xs" in the recursion, then the input "got smaller", so logically if we have finite input the recursion *must* terminate at some point
02:49:12 <Cale> bollu: In the computable real numbers?
02:49:20 <bollu> Cale: yes. I suppose so
02:49:26 <dramforever> hmm...I think someone said "coq" here, and I'm currently playing with it
02:49:27 <bollu> merijn: and corecursion would be..?
02:49:28 <merijn> liste: No, they have a C compiler that is proven to compile input C code according to the spec
02:49:52 <merijn> bollu: Corecursion is induction on "infinite" data (also codata, things like streams)
02:50:10 <bollu> merijn: example of something that is coinductive? (a function?)
02:50:13 <merijn> bollu: In which case the recursion must provably terminate after a finite number of steps of recursing on the codata
02:50:14 <Cale> bollu: It's tricky to talk about equality before you even get to asking for fixed points :)
02:50:23 <liste> merijn yeah, so the compiler itself is Coq+ML ?
02:50:25 <bollu> merijn: hm
02:50:26 <merijn> bollu: Infinite streams
02:50:29 <merijn> liste: I think so?
02:50:40 <bollu> merijn: infinite streams don't really "terminate", do they?
02:50:42 <merijn> bollu: "take 10" on an infinite stream is clearly ok
02:50:54 <merijn> bollu: Right, which is why codata is different from data
02:50:56 <bollu> merijn: yes
02:51:08 <merijn> bollu: But terminating recursion on infinite data is still fine
02:51:14 <bollu> oh
02:51:21 <liste> merijn yeah, I found some (Oca?)ML code from their sources
02:51:23 <merijn> You just can't use structural recursion on said infinite data :)
02:51:41 <merijn> Well, not without a termination proof, anyway
02:51:46 <bollu> merijn: so, is fact = product $ take n [1..] an example of a "coinductive structure" that terminates?
02:52:10 <merijn> bollu: Yes, the trick is proving that succesfully to the compiler :)
02:52:52 <bollu> merijn: xD
02:53:01 <bollu> merijn: hm, which language is this strict?
02:53:05 <bollu> as in, if I want to play with this
02:53:07 <bollu> to understand it
02:53:11 <bollu> which language should I use?
02:53:47 <Cale> Agda or Coq
02:53:56 <bollu> which one is "better" /
02:53:56 <bollu> ?
02:53:59 <Cale> Neither
02:55:01 <Cale> In fact, if you're going to learn one of them, I recommend learning both, because there are limited learning resources, and the two languages have a lot in common structurally, even if the surface syntax looks very different.
02:55:05 <arahael> Idris, as will, iirc?
02:55:26 <Cale> Idris has a termination checker, I'm not sure it has a treatment of coinduction...
02:55:29 <Cale> It might
02:55:56 <bollu> Cale: oh, cool
02:57:09 <sordina> Anyone been following the parsec/megaparsec thing?
02:58:09 <Cale> Personally I end up using Coq a little more than Agda, but not for any good reason apart from that I find Agda a little bit hard on my hands to type. Its standard library uses a lot of unicode syntax and the emacs plugin starts off most of the shortcuts for symbols with \
02:58:30 <Cale> I would love to have an alternate standard library for Agda with no or little unicode
02:58:45 <indiagreen_> sordina: I have, but if you want an unbiased opinion on something you probably shouldn't ask me
02:59:02 <bollu> oh, wait, you *need* to use unicode symbols?
02:59:05 <Cale> yes
02:59:07 <phadej> pcd
02:59:10 <phadej> äh
02:59:13 <Cale> If you want to use the standard library you do
02:59:13 <sordina> I'm fine with biased opinions :)
02:59:20 <liste> so it's like vim/neovim ?
02:59:29 <Cale> hm?
02:59:44 <liste> the parsec/megaparsec thingy
02:59:45 <Cale> It's like LaTeX syntax
02:59:57 <Cale> oh, maybe you're talking to someone else :)
03:00:17 <sordina> indiagreen: You're the author right?
03:00:19 <Cale> sordina: What parsec/megaparsec thing?
03:00:25 <indiagreen> sordina: I'm not the author
03:00:51 <Cale> I hadn't heard of megaparsec until a few days ago
03:01:24 <indiagreen> liste: I don't know 'cause I've never used either vim or neovim and have no idea how much of a total rewrite neovim is
03:01:53 <sordina> Oh haha, I just saw your handle at the bottom of the announcement, but on closer inspection you clarified...
03:01:54 <indiagreen> sordina: I'm more kinda like the PR person, writing announcements and answering questions and stuff
03:02:12 <sordina> cool
03:04:24 <sordina> I'm all for improvements on parsec. Do you think there's going to be a consolidation towards using Megaparsec? What's the longer term plan? Would a merge be possible if maintainence of Parsec picked up steam again?
03:06:36 <Pro9> If I have this function call that take 3 very long parameters: thisIsMyLongFunction longInputOne longInputTwo (longInputThree inputOneToLongInputThree inputTwoToLongInputThree)
03:07:04 <Pro9> Where can I break that up into multiple lines, anywhere? and haskell will just continou "reading" on the next line?
03:08:21 <Cale> yes, just make sure that the following line starts on a deeper column
03:08:34 <bollu> 	oh my god this is awesome: http://www.willamette.edu/~fruehr/haskell/evolution.html
03:08:45 <sordina> Pro9: you could use a where/let clause for param3 = (longInputThree inputOneToLongInputThree inputTwoToLongInputThree)
03:08:46 <lyxia> http://lpaste.net/142125 < Pro9 
03:08:46 <bollu> "(graduate education tends to liberate one from petty concerns about, e.g., the efficiency of hardware-based integers)"
03:13:59 <Gurkenglas> "ViewL and ViewR from Data.Sequence should both be Maybe (a, Seq a). The Traversable instances is useless and this change would allow a marvelous interaction with StateT." <- Thoughts?
03:14:43 <Pro9> Cale: lyxia: Thanks, Sordina: I usually try to use where clauses, but I was more interested in how much you could break that function up into multiple lines
03:17:07 <sordina> Pro9: I see
03:18:37 <indiagreen> sordina: it's been proposed on the mailing list for Megaparsec to become Parsec 4; I've no idea whether the author of Megaparsec wants it or not (see https://github.com/mrkkrp/megaparsec/issues/32#issuecomment-144174756). If Parsec maintenance gets resumed and Parsec 4 gets some of Megaparsec's features, instead of a merge there'll probably be a fight between them (and my bets are on Parsec 4) – but it's an unlikely
03:18:37 <indiagreen> scenario in general. Lastly, there'll never be a consolidation as in “Parsec has no reverse dependencies on Hackage”, but we're trying to make Megaparsec the default parsing library, yeah (GHC 7.8 support has been added recently, I'm writing a comprehensive tutorial that would assume Megaparsec, etc)
03:18:38 <fishburne> How can statically link all the dependencies in a program compiled by GHC? I tried adding '-static -optl--whole-archive' in the cabal file, but it errors out with http://lpaste.net/142126
03:19:18 <liste> fishburne are you using glibc?
03:19:34 <sordina> indiagreen: interesting
03:20:12 <sordina> indiagreen: Thanks for the info
03:21:59 <fishburne> liste: output of ldd --version says (Ubuntu EGLIBC 2.19-0ubuntu6), http://lpaste.net/142128
03:24:06 <liste> fishburne afaik compiling glibc statically can lead to problems in systems with a different glibc version, but that's not directy related to your current problem
03:24:11 <liste> just a heads-up
03:26:08 <fishburne> liste:  How come statically compiled binaries need to depend on glibc?
03:27:39 <Ferdirand> hello #haskell, what do you think is better in which situations: f <$> (a >> b) or a >> (f <$> b) ?
03:28:17 <wedens> what are conceptual differences between megaparsec and trifecta?
03:28:28 <Cale> Ferdirand: Those are equal
03:28:47 <Shockk> I would probably go with the former; I don't really have a reason except it looks better imo
03:28:47 <Rembane> Same here.
03:30:18 <Shockk> one that might make more sense would be f <$> (b << a)
03:30:36 <Shockk> because at least with that the flow of execution is cleart
03:30:37 <Shockk> clear*
03:30:42 <Cale> (<<) doesn't exist
03:30:47 <Shockk> it doesn't?
03:30:50 <Shockk> :(
03:30:55 <Cale> (=<<) does
03:30:57 <Shockk> why not?
03:30:58 <bollu> Shockk: you can use (<*)
03:31:00 <quicksilver> <* does too
03:31:08 <bollu> :t (<*)
03:31:10 <lambdabot> Applicative f => f a -> f b -> f a
03:31:14 <bollu> :t >>
03:31:16 <lambdabot> parse error on input ‘>>’
03:31:19 <bollu> :t (>>)
03:31:20 <lambdabot> Monad m => m a -> m b -> m b
03:31:21 <quicksilver> I would probably use "a *> (f <$> b)"
03:31:23 <bollu> :t (*>)
03:31:24 <lambdabot> Applicative f => f a -> f b -> f b
03:31:25 <Shockk> ahh
03:31:38 <quicksilver> on the grounds that "f has nothing to do with a, it might as well sit next to the b it applies to"
03:31:42 <bollu> quicksilver: agreed. It shows control flow very well
03:31:44 <quicksilver> but I don't have a strong preference
03:31:48 <Cale> (<*) might not do what you want though
03:31:57 <Ferdirand> brb but thanks for the answer so far, i'll keep reading when i get back
03:32:06 <Cale> It executes the two actions in order, and produces the result of the first
03:32:09 <bollu> I like a *> (f <$> b), because it shows the ordering of applicaation very well
03:32:48 <quicksilver> Cale: yes, I once wondered if the reason << didn't exist was that people didn't know if it should be flip (>>) or if it should be that thing we now call (<*)
03:33:19 <quicksilver> ... but that argument fails to hold water since =<< and >>= and <=< and >=> all exist.
03:34:20 <liste> fishburne they need some C library
03:36:01 <fishburne> liste: What is the best way to distribute a Haskell program for windows and linux users?
03:36:37 <arahael> fishburne: By removing the "and".
03:38:05 <fishburne> arahael: Ofcourse, I don't mean that it needs to be the same executable.
03:38:26 <liste> fishburne, on Linux, I'd just keep glibc linked dynamically
03:38:30 <arahael> fishburne: Windows deployment can be complex.
03:38:57 <arahael> fishburne: But I'd start by generating a single, static, .exe, if possible.
03:39:16 <arahael> fishburne: Beyond that, you may need an installer.
03:39:17 <secwang> Hi all , what is the name of () in IO () , I can't search it with google
03:39:28 <chpatrick> secwang: unit
03:39:33 <secwang> ty
03:39:40 <chpatrick> but it's just a regular type
03:39:42 <chpatrick> @src ()
03:39:42 <lambdabot> data () = ()
03:40:07 <Shockk> quick question; does cabal build tests automatically or only if --enable-tests?
03:41:09 <Gurkenglas> :exf "Monad m => StateT s m a -> State s a" -- Better way?
03:41:28 <Gurkenglas> :exf "Monad m => State s a -> StateT s m a" -- Umm I mean this one
03:41:29 <exferenceBot> \ s1 -> let (State f3) = s1 in StateT (pure . f3)
03:41:34 <exferenceBot> could not find expression
03:41:49 <Gurkenglas> Good thing I brought that guy along, mightn't have noticed :P
03:42:46 <Pro9> When checking a list for duplicate values, is there some better approach than using nub and comparing the length before and after nub?
03:43:32 <Shockk> Pro9: you mean just to check if there are *any* duplicates in the list?
03:43:46 <fishburne> arahael: An installer? Can you have a suggest one?
03:44:03 <liste> Pro9 how about lst != nub lst ?
03:44:10 <Shockk> you could write a function similar to nub which returns True if it finds a duplicate, rather than skipping it and continuing
03:44:20 <Shockk> oh liste's solution would work
03:44:24 <Shockk> laziness :D
03:45:19 <liste> > let lst = [1,2,3,4,5,6] ++ [1..] in lst != nub lst
03:45:20 <lambdabot>      Not in scope: ‘!=’
03:45:20 <lambdabot>      Perhaps you meant one of these:
03:45:20 <lambdabot>        ‘!’ (imported from Data.Array), ‘M.!’ (imported from Data.Map),
03:45:25 <liste> > let lst = [1,2,3,4,5,6] ++ [1..] in lst /= nub lst
03:45:27 <lambdabot>  True
03:45:39 <bollu> :t nub
03:45:40 <lambdabot> Eq a => [a] -> [a]
03:45:43 <liste> damn != habits :/
03:45:53 <Shockk> :!
03:45:54 <bollu> > nub [1] [1]
03:45:56 <lambdabot>      Couldn't match expected type ‘[Integer] -> t’
03:45:56 <lambdabot>                  with actual type ‘[Integer]’
03:45:56 <lambdabot>      The function ‘nub’ is applied to two arguments,
03:46:03 <bollu> oh, wait
03:46:08 <phadej>  /msg NickServ VERIFY REGISTER phadej feakcljzjppw
03:46:08 <bollu> > nub [1]
03:46:10 <lambdabot>  [1]
03:46:11 <phadej> fail
03:46:15 <Shockk> ..
03:46:16 <Pro9> liste: I have the same problem, why does haskell use /= instead of != ?
03:46:18 <bollu> lol
03:46:24 <Shockk> at least it wasn't your password
03:46:31 <liste> Pro9 the mathematical symbol
03:46:35 <bollu> what does nub do?
03:46:35 <Pro9> liste: I gonna use your solution, thanks!
03:46:45 <merijn> Pro9: Similarity to the mathematical ≠ symbol
03:46:50 <bollu> > nub [1 2]
03:46:50 <slack1256> > nub [1,1,3]
03:46:51 <lambdabot>      Could not deduce (Num a0)
03:46:52 <lambdabot>      from the context (Eq a, Num a1, Num (a1 -> a))
03:46:52 <lambdabot>        bound by the inferred type for ‘e_112’:
03:46:52 <lambdabot>  [1,3]
03:46:58 <bollu> oh
03:46:59 <liste> bollu "removes" duplicates
03:47:03 <slack1256> > nub [1,1,3,3,9]
03:47:03 <bollu> why "nub" ?
03:47:04 <lambdabot>  [1,3,9]
03:47:23 <phadej> Shockk: yup
03:47:45 <slack1256> \(ºvº)/
03:47:49 <merijn> bollu: nub is a noun for "he crux or central point of a matter."
03:49:03 <bollu> ohh!
03:49:09 <bollu> merijn: "nub of a pencil" ?
03:49:18 <liste> Pro9 yw (:
03:49:25 <bollu> huh, that's really cool :D
03:49:53 <merijn> Note that nub is quadratic
03:50:09 <bollu> merijn: is there any sub-quadratic algorithm? 
03:50:12 <merijn> If you want uniques then going "toList . fromList" will be better
03:50:13 <bollu> I think having Ord as well
03:50:14 <bollu> would help
03:50:27 <merijn> bollu: Via Set using Ord is n log n, I think
03:51:36 <bollu> merijn: right
03:56:20 <Gurkenglas> What IRC nick maintains Witherable? I'd like "(MonadTrans t, Witherable m) => Witherable (t m)"
03:59:41 <quicksilver> I think his IRC nick is fumieval but I'm not sure your request makes sense Gurkenglas 
03:59:56 <quicksilver> most monads won't have Witherable instances
04:00:14 <Gurkenglas> [] does, and I thought I'd generalize it immediately
04:00:47 <quicksilver> you're trying to do 2 steps of generalisation at once?
04:00:53 <quicksilver> (1) prove it works on most monads
04:00:59 <Gurkenglas> (Could have used the instance now so I don't have to change the mapMaybe while refactoring StateT into my code)
04:01:03 <quicksilver> (2) prove you can derive it through MonadTrans
04:01:28 <quicksilver> I'm pretty sure State s is neither Traversable nor Witherable
04:02:01 <Gurkenglas> [State s] is, though
04:02:09 <merijn> That's a type error
04:02:14 <Gurkenglas> Ah dang yep.
04:02:17 <merijn> [State s a]?
04:02:30 <quicksilver> presuambly he means StateT s []
04:02:41 <Gurkenglas> Oh I thought you pointed out that it's actually s -> [(a, s)]
04:02:42 <quicksilver> which is /\ a -> [State s a]
04:04:26 <merijn> Is there a name for "the right most type in a function signature"?
04:04:42 <quicksilver> the return value, merijn ?
04:04:44 <merijn> i.e. Given "a -> (b -> c) -> d -> e" the name for "e"
04:04:57 <quicksilver> it's not really well defined since you don't know that e isn't of the form 'f -> g'
04:05:09 <quicksilver> but with that caveat people talk of return values
04:05:15 <merijn> quicksilver: That's why I was careful not to say return value
04:05:19 <quicksilver> :)
04:05:31 <merijn> quicksilver: Because I'm talking of the rightmost type that doesn't unify with an arrow
04:05:54 * quicksilver nods
04:05:58 <quicksilver> I don't know a name for that.
04:06:14 <Gurkenglas> I meant something like catMaybes statetlist = do Just x <- statetlist; return x
04:06:40 <merijn> (I'm trying to check that the result of a constructor matches the type it belongs too and need to name a function for that)
04:07:02 <quicksilver> Gurkenglas: but you're not passing the state in?
04:08:05 <quicksilver> perhaps you want to sequence the whole list...
04:08:12 <Gurkenglas> I do not see the problem; this is do notation, it works with any monad
04:08:29 <Gurkenglas> (Well MonadPlus because partial etc)
04:08:33 <quicksilver> the problem is you're not saying what you mean.
04:08:41 <quicksilver> if statelist is [State s a]
04:08:52 <Gurkenglas> no no it is StateT [] s a
04:08:52 <quicksilver> then that monad expression is in the list monad, not the state monad
04:08:55 <Gurkenglas> *s []
04:09:33 <quicksilver> oh I see
04:10:05 <Gurkenglas> Actually this sounds like any MonadPlus is Witherable.
04:10:45 <quicksilver> first you have to convince me any MonadPlus is Traversable
04:11:27 <Gurkenglas> Ah, I was only looking at the minimal complete definition, not the superclasses. Okay, how about any traversable MonadPlus is witherable?
04:12:49 <quicksilver> that sounds intuitively believable. A Traversable with a zero element which you can use for withering.
04:13:17 <quicksilver> Traversable Monads are, roughly "structural" monads
04:13:24 <quicksilver> things like List and Tree (and Maybe)
04:13:46 <quicksilver> where =<< does some kind of flattening/inserting thing
04:13:56 <quicksilver> and if you can 'flatten/insert' a zero element
04:13:58 <quicksilver> then you can wither.
04:14:03 <quicksilver> intuition satisfied :)
04:14:39 <quicksilver> ...back to your original example, are you using [] for 'non-determinism' in the sense of 'returning multiple possibilities' ?
04:14:43 <Gurkenglas> yes
04:14:53 <quicksilver> it's generally said that StateT s [] "isn't right"
04:15:15 <quicksilver> and you need LogicT or similar
04:15:58 <Gurkenglas> Where's the difference? Or is this like ExceptT vs EitherT?
04:16:11 <quicksilver> no it's not, it's deeper than that
04:16:15 <quicksilver> but I am not the one to explain it :(
04:16:18 <montanonic> Minor question: Do tuples basically allow a newtype to be a product type?
04:16:33 <quicksilver> StateT s [] feeds the wrong state through
04:17:03 <Gurkenglas> Huh? The s branches out to each possibility, as I want
04:17:09 <Gurkenglas> -as+which
04:17:33 <quicksilver> I don't think it does, maybe I've remembered this wrong. Let me try something
04:18:28 <bollu> quicksilver: what is "isn't right"?
04:18:44 <bollu> quicksilver: doesn't StateT s [] allow you explore "multiple future states" ?
04:18:56 <bollu> I've used it once to solve some combinatorics thing IIRC
04:19:36 <bollu> Also, question. Because every traversable has a functor instance on it, doesn't it sort of imply the view that "functors are containers" is at least half-right?
04:19:45 <bollu> I understand that "not all functors are traversables"
04:19:53 <bollu> but, like, the fact that "all traversables are functors"
04:19:55 <quicksilver> bollu: it implies "contains are functors" is right.
04:20:02 <bollu> cool :)
04:20:08 <bollu> oh, right
04:20:09 <quicksilver> but "containers are functors" is no the same thing as "functors are (all) containers"
04:20:14 <bollu> right, yeah.
04:20:25 <bollu> Functor is larger than Traversables
04:25:25 <quicksilver> Gurkenglas: apologies. StateT [] is fine for what you want.
04:25:32 <quicksilver> Gurkenglas: I am not entirely sure what I was thinking of.
04:25:46 <quicksilver> possibly I was thinking of the fact that ListT (State s) doesn't make sense.
04:25:59 <quicksilver> but, hey, I learnt something :)
04:26:55 <bollu> :T ListT
04:26:58 <bollu> :t ListT
04:27:00 <lambdabot> Not in scope: data constructor ‘ListT’
04:27:14 <bollu> what's listT?
04:27:54 <srhb> bollu: Following usual naming, it would be the list monad transformer.
04:28:16 <bollu> well, what would that do, was more along the lines of my question :) But, I think I get it
04:28:36 <bollu> something like composing cartesian products with other monadic effects, I'm guessing
04:28:40 <srhb> bollu: Whatever the list monad "does" and then you stick other monads in the stack :-)
04:28:42 <bollu> that's pretty cool, though I can't think of a use for it
04:28:43 <bollu> xD
04:28:44 <srhb> Yes.
04:28:53 <srhb> Wait, cartesian product?
04:29:00 <bollu> um, flatMap, sorry*
04:29:04 <srhb> Yeah, concatMap.
04:29:14 <bollu> but that's equivalent to cartesian product
04:29:18 <srhb> Is it?
04:29:28 <bollu> only for (,), I guess
04:29:30 <bollu> :t liftM2
04:29:31 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
04:29:39 <srhb> Ah. :)
04:29:44 <bollu> > liftM2 (,) [1..3] [8..10]
04:29:46 <lambdabot>  [(1,8),(1,9),(1,10),(2,8),(2,9),(2,10),(3,8),(3,9),(3,10)]
04:29:48 <bollu> yeah
04:30:02 <bollu> cartesian product for list monad under (,)
04:30:31 <bollu> I'm surprised liftM2 is still around now that we have AMP and liftA2
04:30:44 <srhb> bollu: Why remove it? Needs more code fixing up. :)
04:30:54 <quicksilver> well it doesn't do any harm and it would break lots of code to remove it
04:30:55 <bollu> xD
04:30:59 <bollu> neatness or something
04:31:05 <bollu> "feels" nicer
04:31:30 <bollu> I wish we could write Traversable laws with liftA2
04:31:36 <bollu> it would be a nice balance with fmap
04:31:39 <bollu> :t fmap
04:31:40 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:31:43 <bollu> :t liftA2
04:31:44 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
04:31:54 <quicksilver> Gurkenglas: anyhow I don't see how you can push a traversable instance past a StateT wrapper
04:32:35 <Gurkenglas> I didn't notice the Traversable thing, I just wanted mapMaybe for StateT [].
04:33:10 <Gurkenglas> Can we get a "MonadPlus m => m (Maybe a) -> m a" somewhere?
04:33:20 <bollu> :t MonadPlus
04:33:22 <lambdabot> Not in scope: data constructor ‘MonadPlus’
04:33:30 <bollu> @info MonadPlux
04:33:30 <lambdabot> MonadPlux
04:33:39 <bollu> @info MonadPlus
04:33:39 <lambdabot> MonadPlus
04:33:41 <merijn> You don't even need MonadPlus I don't think
04:33:43 <bollu> oh
04:33:50 <merijn> :t maybe mzero return
04:33:52 <lambdabot> MonadPlus m => Maybe a -> m a
04:33:53 <bollu> What's a monadPlus?
04:34:00 <Gurkenglas> Alternative might be enough, but my brain is too mushy to figure that one out right now
04:34:04 <merijn> :t mzero
04:34:05 <lambdabot> MonadPlus m => m a
04:34:11 <merijn> Did MonadZero get removed?
04:34:24 <bollu> oh, it's a monad with monoid structure
04:34:25 <bollu> ?
04:34:28 <merijn> bollu: Yes
04:34:32 <merijn> :t mplus
04:34:33 <Gurkenglas> Mnemonic: MonadPls, you can tell it to give you one of the type without giving it anything :D
04:34:33 <lambdabot> MonadPlus m => m a -> m a -> m a
04:34:36 <merijn> :t mzero
04:34:37 <lambdabot> MonadPlus m => m a
04:35:36 <bollu> merijn: so, Monad m => MonadPlus m,  MonadPlus m => Monoid (MonadPlus m a) ?
04:35:42 <bollu> no, that looks so wrong
04:35:55 <Gurkenglas> :t (>>= maybe mzero return) -- You mean this?
04:35:56 <lambdabot> MonadPlus m => m (Maybe b) -> m b
04:35:59 <Gurkenglas> *merijn
04:36:14 <bollu> where is the defn?
04:39:02 <merijn> bollu: There is no Monoid, the types don't line up
04:39:22 <bollu> 	merijn: in what I wrote, or in general?
04:39:29 <merijn> bollu: But "mplus mzero x = x" "mplus x mzero = x"
04:39:33 <merijn> bollu: In general
04:39:41 <merijn> Else we wouldn't need a separate class
04:40:11 <merijn> "class Monad m => MonadPlus where mzero :: m a; mplus :: m a -> m a -> m a"
04:40:20 <merijn> Where mzero is left and right identity of mplus
04:41:08 <merijn> Note that "instance (Monad m, Monoid a) => Monoid (m a)" is legal, but different
04:41:38 <bollu> merijn: that would be a monoid on the "internal structure", right? while MonadPlus is a monoid on the "outer structure" ?
04:41:44 <merijn> Yes
04:42:11 <merijn> Also, there's at least 2 (probably more?) valid Monoids for the above
04:42:37 <bollu> merijn: I'm still confused, why can't we say (MonadPlus m) => Monoid (MonadPlus m a) where  id = mzero, (<>) = mplus ?
04:42:53 <merijn> For example, "mappend x y = do { x' <- x; y' <- y; return (y <> x) }" is just as legal as "do { x' <- x; y' <- y; return (x <> y) }"
04:43:09 <ski> merijn : and associativity
04:43:14 <merijn> bollu: You could, but that overlaps with everything
04:43:25 <bollu> merijn: oh, so it's a haskell limitation?
04:43:34 <bollu> ski: MonadPlus is not associative?
04:43:45 <ski> `mplus' is
04:43:53 <merijn> bollu: It is, he's just pointing out that both associativities for my example are legal
04:44:10 <merijn> (I think?)
04:44:30 <ski> (you only mentioned the neutral element laws, above)
04:44:38 <merijn> oh, right
04:44:50 <bollu> ski: what do you mean?
04:45:02 <merijn> bollu: mplus has to be associative, but I didn't mention that
04:45:16 <bollu> oh, right :)
04:45:34 <info_is_good> Is Vector part of base now? If so, why can't I import Data.Vector.Unboxed? How do I get REPA + Vector to work on GHC 7.10.2? I installed both, but I get a conflict http://lpaste.net/142129
04:45:46 <merijn> info_is_good: It's not part of base
04:46:14 <ski> @wiki MonadPlus
04:46:14 <lambdabot> http://www.haskell.org/haskellwiki/MonadPlus
04:46:17 <ski> @wiki MonadPlus reform proposal
04:46:18 <lambdabot> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
04:46:25 <merijn> info_is_good: repa is compiled against a different version of vector than the one you're importing
04:46:41 <merijn> info_is_good: Use cabal/sandboxes
04:50:40 <Shockk> I'm getting a build error in Test.HUnit.Tools and I'm unsure why because it's the latest version from hackage on GHC 7.10 
04:50:44 <info_is_good> Suppose I create a Cabal project in a directory, with a sandbox. How do I use that project in another Cabal project in another directory? 
04:50:46 <Shockk> the build log: https://travis-ci.org/polar-engine/polar-configfile/builds/83286329
04:51:01 <info_is_good> Using `cabal install` doesn't make it available because of the sandbox, it seems.
04:51:05 <merijn> info_is_good: add-source
04:51:15 <info_is_good> merijn: ty
04:51:21 <merijn> info_is_good: see "cabal help sandbox"
04:51:42 <Andrej_T> hey everyone! can someone tell why this type signature is not valid (the typeclass more preciselly): https://github.com/whoeverest/haskell-euler/blob/master/8-prime.hs#L3
04:52:09 <Andrej_T> i don't want to define the function for integers only, i want it to work with anything multipliable
04:52:14 <merijn> :t (*) -- Andrej_T 
04:52:15 <lambdabot> Num a => a -> a -> a
04:52:43 <merijn> :t foldl (*) -- Andrej_T 
04:52:44 <lambdabot> (Num b, Foldable t) => b -> t b -> b
04:52:49 <info_is_good> Is it usual to have many local packages self-linking eachother around? I'm creating a package for every file I write, basically, since most of them are self sufficient (data structures, etc).
04:52:53 <merijn> note the result
04:53:40 <merijn> :t foldl (*) 1 [1.0..10.0] 
04:53:41 <ski> Andrej_T : what if someone passes a `[Rational]' as input, how can `prod' possibly return an `Int' ?
04:53:42 <lambdabot> (Enum b, Fractional b) => b
04:55:35 <Andrej_T> ski: you're right, it can't
04:57:24 <ski> Andrej_T : the caller of `prod' will pick which type to use in place of `a' (the caller has to pick a type that's in the `Num' typeclass, though, because of the `Num a' class constraint)
04:58:10 <info_is_good> Do I need "cabal init" and "stack init" or just "stack init"?
04:58:30 <Andrej_T> so i'm trying to specify something that's already specified in the foldl definition, right?
04:58:39 <fizruk> info_is_good: stack new?
04:58:47 <obadz> is there a way to catch a fail in any monad, something with signature Monad m => m a -> m (Either String a) ?
04:59:05 <merijn> obadz: No, which is why fail sucks
04:59:21 <quicksilver> one of the reasons at least :)
04:59:33 <obadz> merijn: but somehow, the Parser in Aeson manages to convert a call to fail to an Either and I'm puzzled as to how it does this.. unsafePerformIO ?!
04:59:47 <quicksilver> because you aren't in *any* monad
04:59:48 <obadz> I doubt that, so I assume it does something else..
04:59:52 <quicksilver> you're in a specific monad
04:59:57 <quicksilver> where fail does something useful
05:00:00 <merijn> obadz: fail is overloadable
05:00:01 <ski> Andrej_T : i'm not sure what you're asking
05:00:02 <bollu> why didn't gauss publish so many results?
05:00:05 <bollu> it's mind boggling
05:00:16 <obadz> oh...
05:00:20 <merijn> obadz: It's part of the Monad typeclass, so if you implement a Monad you can also implement fail
05:00:23 <obadz> didn't realize fail was overloadable
05:00:27 * quicksilver nods
05:00:27 <bollu> he discovered harmonic analysis, quaternions, whatnot in his notes apparently..?
05:00:35 <bollu> I don't see how he didn't publish them!
05:00:58 <merijn> obadz: So you can write "instance Monad Aeson where fail s = {- do something with error string -}"
05:01:04 <lpaste> Pro9 pasted “Split each list in a nested list into 3 new lists? basically how to get the 3x3 blocks in a 9x9 sudoku (represented by a list with 9 lists, with 9 elements in each)?” at http://lpaste.net/4366531561504374784
05:01:27 <obadz> merijn: yes yes I get it now..
05:01:30 <obadz> merijn: thx.
05:02:24 <ski> obadz : hopefully `fail' will be moved out of `Monad', soon
05:02:28 <info_is_good> I don't understand stack and can't seem to find a quick tutorial about it... would anyone link me one? Does it replace cabal? Does it live with it? Etc. in short, what is the workflow for creating a new project using stack?
05:02:41 <ski> @wiki MonadFail Proposal
05:02:41 <lambdabot> http://www.haskell.org/haskellwiki/MonadFail_Proposal
05:03:15 <fizruk> info_is_good: https://github.com/commercialhaskell/stack#how-to-use maybe this will help
05:03:34 <info_is_good> fizruk: sure, I couldn't find it. Thank you!
05:03:56 <obadz> ski, merijn: until them, does it make sense to implement functions that live in ExcepT and make them compatible with Monads with something like: unliftExceptT = (>>= f) . runExceptT where f (Left e)  = fail e; f (Right v) = return v
05:04:28 <obadz> (unliftExceptT :: Monad m => ExceptT String m b -> m b
05:04:58 <Andrej_T> ski: since foldl (*) already constrains the type of the elements in the list to "Num", respecifying that constrain makes no sense, i guess?
05:05:34 <Andrej_T> this signature works: prod :: Num a => [a] -> a
05:05:47 <info_is_good> fizruk: ah that still doesn't answer my question :( do I use "cabal init; stack new; stack init" in a new project?
05:06:00 <fizruk> info_is_good: just stack new
05:06:13 <info_is_good> fizruk: cool, thank you!
05:06:18 <ski> obadz : not sure what "make them compatible with Monads" mean
05:06:40 <fizruk> info_is_good: there are multiple templates for stack new and you have to provide project name, iirc
05:07:01 <ski> Andrej_T : not sure what you mean by "respecifying that constrain" -- that type signature would work fine, though
05:07:25 <info_is_good> Just a last question, if I have already installed a few projects with cabal/no stack, will `stack new` fix it?
05:07:33 <info_is_good> Or do I have to purge cabal before?
05:08:09 <obadz> ski: if I have a function that works in MonadError String m and I want to bind it to Monad m, I can just bind unliftExceptT . myFunction instead
05:09:02 <jophish> hvr: Any relation to mvr?
05:09:44 <ski> obadz : why not explicitly handle the failing case ?
05:10:53 <info_is_good> Oh, nevermind.
05:11:14 <obadz> ski: not sure what you mean
05:12:37 <ski> obadz : `do r <- runExceptT myFunction; case r of Left e -> ..handle failing case..; Right v -> ..handle success case..'
05:12:54 <ski> obadz : iow, why would you want to use `fail' ?
05:14:48 <obadz> ski: not sure how else to report an error to Aeson.Parser ?
05:14:56 <obadz> ski: it seems to use fail for that purpose
05:17:12 <quicksilver> obadz: you are supposed to use 'typeMismatch' aren't you?
05:17:37 <quicksilver> https://hackage.haskell.org/package/aeson-0.10.0.0/docs/Data-Aeson-Types.html#v:typeMismatch
05:18:14 <obadz> typeMismatch expected actual = fail $ "expected " ++ expected ++ ", encountered " ++ name ..
05:18:38 <obadz> my error is not a typeMismatch though
05:19:44 <obadz> (the specific error I'm handling is a non-rectangular list of lists being parsed into a Matrix)
05:21:47 <lyxia> Can't you change the implementation from 'ExceptT String m a' to 'm a' by replacing all 'throwError' with 'fail'?
05:21:47 <obadz> from documentation: "The basic ways to signal a failed conversion are as follows: fail yields a custom error message"
05:22:40 <lyxia> I guess it doesn't work as well if you discard some errors silently in the implementation.
05:22:44 <obadz> lyxia: I could, but since I'm told fail is frowned upon, I'd rather write my function "the right way" with ExcepT and write some generic glue to make things backward compatible with Monads?
05:23:07 <quicksilver> your glue seems fine, obadz 
05:23:08 <obadz> happy to be told that there's a better way..
05:23:19 <quicksilver> if you want to work with ExceptT as your type
05:24:12 <obadz> quicksilver: it should also work with any function that's generic over MonadError String a..
05:24:22 <quicksilver> obadz: another option is to write a MonadError instance for Aeson.Parser
05:24:29 <obadz> quicksilver: agreed.
05:24:36 <quicksilver> and then you can just use your MonadError polymorphic things directly
05:26:05 <obadz> I'm in my first week writing real haskell code, so I'm going to hold off for a little while before I feel confident enough to submit PRs ;-)
05:26:35 <ski> obadz : looks like it's `fail' for Attoparsec. i'd probably restrict the monad to its `Parser', rather than keeping it polymorphic, though
05:27:23 <ski> (or what quicksilver said)
05:28:36 <nomeata> Hi. Do we have nice tools to visualize a .prof file?
05:29:46 <quicksilver> anyone who can write "unliftExceptT = (>>= f) . runExceptT where f (Left e)  = fail e; f (Right v) = return v" in their first week of haskell programming is doing .... better than I did.
05:30:46 <obadz> quicksilver: I've done way too much reading compared to how much coding I did. It's also 1 week of coding when skipping the blanks in between and I was doing F# before..
05:31:50 <quicksilver> these kinds of transformations are all-too-common and I feel like we don't have a good enough story about them
05:32:48 <obadz> there's some stuff here: https://hackage.haskell.org/package/MissingH-1.3.0.1/docs/Data-Either-Utils.html#v:maybeToEither
05:32:49 <quicksilver> things like you (forall m. MonadState s m => m a) is isomorphic to (s -> (a,s))
05:32:58 <obadz> but actually doesn't do MonadError -> Monad
05:33:01 <quicksilver> obadz: yes, there is some stuff all over the place
05:33:21 <quicksilver> but I don't see it being brought together into a common language of transforming things between monads
05:33:52 <jophish> hvr: any relation to mvr?
05:34:05 <quicksilver> pigworker once said "Why would you bother to write something for the 'most general foo' when you can instead write it for the 'initial foo'?"
05:34:19 <quicksilver> or well, words to that general effect
05:34:30 <obadz> what was wrong with implementing fail = Left for the Either Monad again? seems better to me than bottom..
05:34:47 <merijn> obadz: "instance Monad (Either e)"
05:34:56 <merijn> obadz: What if 'e' /= String?
05:35:06 <obadz> merijn: can't we have a separte instance for Either String ?
05:35:16 <obadz> with OVERLAPABLE or whatever that's called.
05:35:45 <merijn> Don't expect overlaps in base any time soon...
05:35:49 <quicksilver> overlappable is bad news
05:36:02 <quicksilver> obadz: if your code is compiled in a module which can't see that 'e' might be a String
05:36:09 <quicksilver> and exported polymorphically
05:36:15 <quicksilver> it will get compiled against the generic instance
05:36:20 <obadz> interesting
05:36:26 <quicksilver> and other code which happens to instantiate it against String
05:36:34 <quicksilver> will not use the most specific instance because, well, it already got compiled that way.
05:36:38 <obadz> yup I get it, that's a good point
05:37:10 <quicksilver> the non-overlap restriction is not just a clean-ness notion, it underlies our choices of compilation strategy.
05:37:15 <obadz> maybe then use Result a ?
05:37:17 <quicksilver> it is a clean-ness notion too though
05:37:22 <quicksilver> overlapping instances aren't parametric
05:37:33 <quicksilver> not sure that's quite the right way to say it.
05:38:24 <quicksilver> obadz: anyhow the MonadError class (with strMsg and noMsg) papered over that particular crack
05:38:31 <quicksilver> but it's not exactly elegant/
05:41:06 <obadz> https://hackage.haskell.org/package/aeson-0.8.1.0/docs/src/Data-Aeson-Types-Internal.html#Result => should they write fail = Error in the Monad instance here?
05:43:23 <orion> Is mtl obsolete?
05:44:52 <pavonia> orion: Why do you think it is?
05:45:25 <orion> Not sure, I thought I heard that there are other more preferred packages.
05:48:43 <obadz> this is how rumors get started :)
05:49:22 <noonan> actually, related to that: how come Control.Monad.Error in mtl has been deprecated for Control.Monad.Trans.Error from transformers?
05:50:27 <himito> \o
05:50:44 <bergmark> o/
05:51:05 <info_is_good> should I use stack together with cabal sandboxes?
05:51:25 <orion> noonan: Ah, that might have been it.
05:53:46 <lpaste> Pro9 pasted “Expected type: Block , Actual type [Block]” at http://lpaste.net/859824187479425024
05:54:22 <bergmark> info_is_good: no i don't think combining them works or makes sense
05:57:42 <slack1256> I thought stack did a cabal sandbox implicitly
05:57:44 <lyxia> Pro9: Change the type of splitList.
05:59:20 <info_is_good> so how do I link a local package without "add-source"?
05:59:27 <info_is_good> using only stack, that is
06:14:24 <ski> obadz : it already is, at <https://hackage.haskell.org/package/aeson-0.10.0.0/docs/src/Data-Aeson-Types-Internal.html#instance%20Monad%20Result>
06:15:03 <phaazon> I just discovered the fact that ghci had breakpoints
06:15:12 <phaazon> that makes it the perfect Haskell debugger!
06:16:35 <jgertm> is there an iso between Maybe a and Maybe (Maybe a)?
06:17:05 <ggole> jgertm: no, the latter has one more state
06:17:07 <phaazon> join / pure . Just?
06:18:05 <obadz> ski: cool
06:18:53 * hackagebot yjsvg 0.2.0.0 - make SVG string from Haskell data  https://hackage.haskell.org/package/yjsvg-0.2.0.0 (YoshikuniJujo)
06:20:58 <ski> phaazon : it's a retract, but not an iso
06:22:29 <ski> (if by `pure . Just' you really mean either `fmap pure', or alternatively just `pure' (noting that `pure = Just' in this case))
06:24:13 <mjuchli> Hi all, has anyone ever used Aeson.Lens (key) with Network.Wreq? I'm having the strange problem that I am able to lookup the one field of a certain responseBody but I am NOT able a field from another responseBody. The only difference between the response bodies are the spaces they contain. Do spaces matter here?
06:25:11 <mjuchli> Working response body: Just "{\n    \"inputId\": 3,\n    \"status\": \"CREATED\", ....
06:25:16 <mjuchli> Failing response body: Just "{\n  \"jobId\": 1,\n  \"status\": \"Enqueued\", ....
06:28:20 <c_wraith> mjuchli: they shouldn't. Have you tested aeson.lens without wreq? 
06:28:49 <c_wraith> Or even just aeson without lens or wreq? 
06:31:47 <orion> I saw this on hackage: runST :: (forall s. ST s a) -> a -- "Return the value computed by a state transformer computation. The forall ensures that the internal state used by the ST computation is inaccessible to the rest of the program." What does that last sentence mean? How does forall achieve that?
06:32:47 <c_wraith> orion: are you familiar with rank-2 polymorphism? 
06:32:58 <arahael> fishburne: As for an installer, it really depends.  You _could_ get away with just a .zip containing everything you need.  Otherwise an installer - innosetup, installaware, installsheld, nsis...   The last one is probably the most suitable for a free project.
06:32:58 <Cale> orion: The idea is that the computation you pass to runST must be polymorphic in the choice of the type s. Since s is bound inside those parens, it cannot occur anywhere in a
06:33:19 <Cale> (there's an a outside the parens, outside of the scope of s)
06:33:34 <geekosaur> also, because it's bound inside those parens, you can never match it with something else
06:33:52 <obadz> obfuscatedFibs = map fst $ iterate (uncurry ((<*>) (,) . (+))) (0, 1) -- pointsfree is a bit too much fun
06:34:04 <merijn> orion: It means that while the ST operation uses mutation internally, the use of mutability cannot leak outside, and therefore you can produce a regular value at the end
06:34:18 <merijn> orion: The ST paper is pretty readable and enlightening
06:34:18 <Cale> All the mutable structures that are provided in ST are tagged with the same s
06:34:33 <merijn> orion: I think the title is "Lazy functional state threads"
06:35:06 <orion> c_wraith: vaguely.
06:35:09 <ski> @type Control.Monad.ST.stToIO
06:35:10 <lambdabot> ST RealWorld a -> IO a
06:35:30 <ski> is an example of an operation that can't be used there
06:36:17 <orion> Cale: "must be polymorphic in the choice of the type s" -- But isn't the fact that you're using a type variable imply that it's polymorphic already?
06:36:43 <Cale> orion: When you pass a function to map, you're allowed to pick any function at all
06:37:05 <Cale> orion: map doesn't require you to provide it with a polymorphic function
06:37:22 <Cale> Consider this function:
06:37:35 <Cale> foo len = (len [1,2,3], len "hello")
06:37:49 <Cale> If you try to write this normally, you'll get a type error
06:38:15 <dramforever> orion: that forall inside the parens requires the *argument* to be polymorphic in s
06:38:19 <ski> orion : the question is "who" must be polymorphic. with `runST :: forall a s. ST s a -> a', `runST' would be polymorphic in `a' and `s', and the caller could pick concrete types for them. with the actual `runST :: forall a. (forall s. ST s a) -> a', `runST' is polymorphic in `a' (so the caller of it may pick `a' to be whatever it likes), but it is *not*
06:38:26 <Cale> However,  foo length  perhaps ought to be okay -- it's clear that it will work because length is polymorphic, and can accept any type of list
06:38:53 <ski> orion : polymorphic in `s'. the *argument* of `runST' must be polymorphic in `s'. conceptually, `runST' itself gets to pick `s', the caller of `runST' doesn't
06:39:03 <Cale> So we can give an explicit type signature to foo (using the RankNTypes extension):  foo :: (forall a. [a] -> Int) -> (Int, Int)
06:39:18 <Cale> and then  foo length  will typecheck
06:39:29 <Cale> (and before that, foo itself will typecheck)
06:39:45 <ski> orion : this is an example of a rank-2 operation, see what Cale is saying
06:40:16 <Ferdirand> is it wrong and/or misleading to try to think of these higher-rank polymorphic types as implicit passing of hidden arguments representing the types ?
06:40:30 <Cale> So here, foo doesn't let you supply, e.g. the function sum :: [Int] -> Int as its argument, that's not good enough
06:40:52 <Cale> The function you give has to work for any type of list
06:41:35 <quicksilver> Ferdirand: you mean think of cales example as taking a parameter which takes a type, something like (a :: Type -> [a] -> Int)
06:41:37 <Cale> Ferdirand: It's not entirely wrong -- that's kind of how things work in System F
06:41:38 <quicksilver> ?
06:41:52 <Ferdirand> quicksilver: yes, exactly
06:42:01 <quicksilver> it's not a wrong intuition at all
06:42:07 <Ferdirand> i've never looked at System F
06:42:15 <Cale> But you should be careful of course about what operations you're allowed to perform on these types that are being passed around. You're not allowed to actually case on them or anything like that
06:42:17 <quicksilver> although it's an interesting fact that the implementation doesn't need to do that
06:42:24 <dramforever> Ferdirand: that would also match the intuition of "picking a type"
06:42:45 <quicksilver> because of the way it all works out, the implementation just passes functions which work on any type
06:42:46 <Cale> Yeah, the actual implementation doesn't need to pass around explicit type representations
06:42:53 <quicksilver> so type passing and type application aren't real things
06:43:00 <quicksilver> they are useful to understand the theory, sometimes, though
06:43:05 * dramforever looks at coq
06:43:34 <Cale> Also, type application and abstraction occur in GHC's core language.
06:43:44 <Cale> But they get compiled away later
06:44:23 <Ferdirand> yes, I understand the implementation doesn't need to do that, it's just that for instance, with a type like
06:45:01 <ski> an implementation could possibly pass around type info, e.g. describing the size and possibly layout of values of the given type
06:45:08 <Ferdirand> well something like ((a -> b) -> c) -> d
06:45:17 <orion> Cale / ski / c_wraith / dramforever: Thank you for the explanation. Combined with https://en.wikibooks.org/wiki/Haskell/Polymorphism#Higher_rank_types it is becoming more clear.
06:45:19 <ski> (this is mentioned e.g. in "Modern Compiler Implementation in ML" by Andrew Appel)
06:45:19 <Ferdirand> i can reason on this function type easily
06:45:34 <dramforever> orion: you're welcome, and that's how #haskell works
06:45:36 <Ferdirand> but i can't wrap my head around the higher-rank type equivalent
06:46:06 <dramforever> you ask a question when we are here, end up being answered by a lot of people together
06:46:17 <ski> Ferdirand : for `runST', you'd get `(a :: *) -> ((s :: *) -> ST s a) -> a'
06:47:03 <ski> Ferdirand : so, conceptually, `runST' will provide the type to use for `s', in the argument
06:47:05 <quicksilver> dramforever: lambabot used to have a quote for that but it was used so often people got annoyed by it :P
06:47:18 <Ferdirand> ski: right. That is very clear.
06:47:52 <dramforever> quicksilver: also I recently knew that there was an original faq command...now I really want to have it back (just joking)
06:48:56 <ski> Ferdirand : the actual `s' being used could be thought of as a product type with a factor of type `t' for every usage of `newSTRef' at type `t' in the execution (well, there's `newSTArray' as well, so ..)
06:49:07 <quicksilver> dramforever: http://ircbrowse.net/browse/haskell?events_page=382289
06:49:47 <ski> (i suppose one could conceptualize this as some kind of tying-the-knot thing, to pass back the initializer value to the start of it all)
06:50:45 <Ferdirand> ski: mhh, that seems to make sense
06:51:44 <SK0> I have a question not _directly_ related to Haskell, but more about which numerical type to use for a math-heavy project. Can I ask?
06:53:20 <Cale> SK0: As long as you're comfortable with Haskell-biased answers :)
06:53:44 <SK0> it's in Haskell
06:54:09 <SK0> but more about the math side I guess
06:54:14 <SK0> I'm building a software library for audio synthesis. It's easy to do a lot (function generator,  frequency modulation, additive synthesis, vector operations, encoding tunings and musical systems, chords, windows, etc) with just reals. But my issue now is that I am working on filters, FFT etc, which are usually expressed with complex numbers and I'm wondering if it's conceptually more correct 
06:54:14 <SK0> to have everything work with complex numbers.
06:55:03 <Gurkenglas> :exf "Monad m => State s a -> StateT s m a" -- Is there a better way?
06:55:04 <exferenceBot> \ s1 -> let (State f3) = s1 in StateT (pure . f3)
06:55:21 <quicksilver> ski: can you implement ST (or at least the part of it which involves STRefs) using IntMap Dynamic and some newtypes?
06:55:30 <Cale> SK0: Well, if you let everything have its inferred type, the things which naturally could work with complex numbers already will.
06:55:44 <Cale> (they'll be polymorphic, perhaps)
06:56:03 <quicksilver> Gurkenglas: well there is "state"
06:56:11 <quicksilver> :t state
06:56:13 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
06:56:26 <Cale> :t state . runState
06:56:27 <lambdabot> MonadState s m => State s a -> m a
06:56:30 <SK0> Cale, could try that
06:56:34 * quicksilver nods at Cale 
06:56:41 <SK0> not sure if everything'd still be correct
06:57:10 <quicksilver> Gurkenglas: although if you've bought into this stuff anyway you should probably just write in MonadState (not State or StateT?)
06:57:16 <chpatrick> quicksilver: that doesn't get GC'd though
06:57:37 <quicksilver> chpatrick: my IntMap?
06:57:41 <chpatrick> the entries
06:57:50 <quicksilver> not until the action is over, no.
06:58:08 <quicksilver> chpatrick: that's not a semantic difference tho.
06:58:19 <Gurkenglas> Hmmyes, I should refactor the stuff that produces the State S to produce any MonadState S
06:58:31 <quicksilver> Gurkenglas: probably.
06:58:43 <quicksilver> or just stick state . runState in front of them
06:58:46 <quicksilver> at point of definition :P
06:59:05 <quicksilver> but if you're using the class methods anyway
06:59:11 <quicksilver> (get/modify etc)
06:59:21 <Gurkenglas> What's the advantage of https://hackage.haskell.org/package/mtl-c-0/docs/Control-Monad-State-CPS.html vs the normal stuff?
06:59:33 <Gurkenglas> (Yes, I think I only need to swap out type signatures)
06:59:36 <quicksilver> then converting it from State s a to MonadState s m => m a is just a change of tyep signatue
07:00:12 <quicksilver> the CPS versions might be faster?
07:00:25 <quicksilver> a feature of GHC's compiler is that CPS transforming functions often makes them faster
07:01:21 <raichoo> yep, that's how DList and Codensity works.
07:01:40 <mniip> probably because GHC is goddamn good at lambda calculus
07:02:20 <quicksilver> it's because functions are faster than data
07:02:26 <c_wraith> Often makes them faster, except when you want to reuse intermediate results. 
07:02:50 <quicksilver> especially (x -> y -> r) is faster than returning (and later unpacking) (x,y)
07:02:59 <c_wraith> That's why things are CPS transformed by default. Sometimes it's way slower. 
07:03:00 <raichoo> quicksilver: DList and Codensity associate things to the right. For lists (xs ++ ys) ++ zs is slower than xs ++ (ys ++ zs)
07:03:08 <quicksilver> yes,
07:03:08 <c_wraith> GHC let's you choose. 
07:03:10 <Gurkenglas> What do I need to import to use State.CPS's MonadState instance? Just "import Control.Monad.State.Lazy ()"?
07:03:54 <quicksilver> c_wraith: can you give a simple picture of why reusing intermediate results makes it slower?
07:04:34 <Cale> Well, that's just xs ++ ys taking O(length xs) steps to reduce
07:05:15 <quicksilver> Cale: yes I understand that one :)
07:05:26 <quicksilver> that is fundamentally different from the tuple one I think.
07:05:34 <Gurkenglas> Oh right I put MonadState in the brackets for some reason I thought classes aren't explicitly imported
07:05:39 <Cale> yes, it is
07:06:29 <quicksilver> for example, I have an algorithm which could naturally return [(a,b,c)]
07:06:47 <quicksilver> but in a particular application you normally only want one part of the tuple
07:07:00 <quicksilver> and possibly only a element of the list
07:07:29 <quicksilver> I'm never sure if I should reimplement the function a few times for different behaviours
07:07:37 <quicksilver> or just wrap "map fst" style wrappers on
07:07:45 <quicksilver> or reimplement it to take a function as a parameter
07:07:56 <quicksilver> and put "(\a b c -> b)" wrappers on.
07:12:41 <delYsid> quicksilver: Sounds like runState vs. eevalState
07:12:50 <delYsid> er, evalState I mean
07:13:07 <Cale> quicksilver: I think you may avoid a couple indirections, but I wouldn't go too far before discovering that it was a bottleneck
07:13:41 <quicksilver> Cale: quite so :) and I doubt it is.
07:13:55 * hackagebot gf 3.7.1 - Grammatical Framework  https://hackage.haskell.org/package/gf-3.7.1 (ThomasHallgren)
07:14:00 <quicksilver> Cale: but on the other hand... if there is a 'right' answer which is not too painful to live by then one can just live by it.
07:14:30 <delYsid> Does Haskore have serious competition I should look at, before I settle in?
07:15:37 <delYsid> I gather it is a rather old library with a lot of useful functionality.  I just wonder where the music-notation-* packages are heading for?
07:16:01 <orion> I am designing a data type to hold a cipher context which contains, among other things, a fixed-length 256-bit key. Is a MVector in ST good for this, or is there something better?
07:17:30 <quicksilver> orion: Word256?
07:17:33 <merijn> orion: Why MVector? They key shouldn't be mutable, no?
07:17:40 <quicksilver> not sure why you'd need an MVector for something immutable either
07:17:41 <quicksilver> :)
07:18:02 <dramforever> I wonder how hard it is to make do with something like data Key = Key Word64 Word64 Word64 Word64
07:18:15 <quicksilver> dramforever: that is essentially what Word256 is.
07:18:25 <orion> merijn: The key is mutated for every message sent/received to achieve perfect forward secrecy.
07:18:47 <dramforever> orion: oh don't worry then, just generate a new key each time
07:18:49 <quicksilver> you don't mean mutated, you mean replaced
07:18:54 <quicksilver> that's different :)
07:18:55 <orion> Yes.
07:18:57 <orion> hmm
07:18:58 <dramforever> that's how things work in haskell....wait is it?
07:19:06 <quicksilver> mutable structures are about when you want to very efficiently change 1% of a data structure
07:19:11 <orion> Oh, I see.
07:19:17 <quicksilver> without a wasteful copy o fthe 99%
07:19:26 <quicksilver> if you're just replacing it, just replace it
07:19:46 <quicksilver> https://hackage.haskell.org/package/largeword-1.2.3/docs/Data-LargeWord.html
07:19:50 <quicksilver> has a bunch of useful instances and stuff
07:20:02 <quicksilver> there are libraries for doing crypto-type maths, as well
07:20:31 <c_wraith> orion: by the way, there's some subtlety in the runST thing. You can use an existentially typed wrapper to smuggle an STRef out of runST 
07:20:50 <info_is_good> I don't understand why I get "Could not find module ‘Data.Vector.Unboxed’", if ghc-pkg shows I have `vector-0.10.12.3` installed and not hidden. 
07:20:54 <orion> hmm
07:20:57 <quicksilver> there should be a law against that, c_wraith 
07:21:17 <dramforever> quicksilver: hey wait is that why people are scared of "immutablity"?
07:21:28 <c_wraith> orion: but then you're prevented from using that STRef by the type of runST still. So the protection holds. 
07:21:53 <dramforever> screw it, variables are immutable, a lot things would be too hard for me to manage, time to switch to java/lisp/python...
07:21:57 <orion> quicksilver: I have a 64-bit nonce value that I need to increment as well. My intuition tells me that I should probably make that mutable, but I am not sure.
07:22:11 <fizruk> info_is_good: perhaps vector is not in .cabal?
07:22:26 <fizruk> info_is_good: in build-deps
07:22:27 <c_wraith> orion: nah, just use a Word64
07:22:32 <dramforever> orion: no just use the incremented value next time
07:22:34 <info_is_good> there is no .cabal, I'm using runghc to test a simple file... fizruk 
07:22:38 <orion> hmm
07:23:10 <dramforever> orion: don't worry it'll take some time for anyone to make this intuitive
07:24:50 <dramforever> I often think that only pointer-ish things needs to be immutable when really needed
07:24:51 <quicksilver> it is reasonable on an initial implementation to optimise for ease of maintanence and ease of programming
07:25:10 <quicksilver> ...which in haskell means immutable, persistent data structures
07:25:21 <quicksilver> and then once you have it actually doing the right thing, passing tests etc
07:25:28 <quicksilver> you can go back and make the slow parts faster (if you need to)
07:25:46 <quicksilver> haskell type system typically makes it surprisingly easy to replace one part with a better part.
07:26:07 <dramforever> A reference to some other value? needs to change what the reference references? use a mutable reference
07:26:17 <orion> So, ok, my CipherState is a record containing two immutable values, "k", and "n". But now suppose I want to do write a function encryptAndIncrement which takes a ByteString. It needs to use "n" and increment it, but the type signature encryptAndIncrement :: CipherState -> ByteString -> (ByteString, CipherState) feels clunky.
07:27:29 <dramforever> orion: <half-joking>horray! you are on the right track for entering the so-called impenetrable land of monads</half-joking>
07:27:29 <quicksilver> feels clunky to you
07:27:33 <quicksilver> feels elegent to me
07:27:40 <quicksilver> that signature specifies exactly what it does
07:28:01 <quicksilver> I'd rather have the signature being honest and telling me it changes the state that way
07:28:16 <quicksilver> but it's something to get used to and at elast partly subjective
07:28:40 <roconnor> ByteString -> State CipherState ByteString
07:28:46 <dramforever> orion, quicksilver: a State monad here might be useful, depending on the exact use case
07:29:22 <dramforever> orion: do you know monads now?
07:29:33 <orion> dramforever: Yes.
07:29:51 <dramforever> do you know the State monad? might be useful, like I said
07:29:57 <quicksilver> a state monad helps you write the code.
07:30:04 <quicksilver> but it isn't actually any different
07:30:15 <orion> Yes I do, but, like quicksilver said, it's not any different.
07:30:18 <quicksilver> roconnor's (sensible) suggested signature is the same type
07:30:30 <exio4> we'd need linear types for something that looks nicer :P 
07:30:37 <quicksilver> the state monad is just a bunch of combinators to help you create functions
07:30:41 <quicksilver> but that's great.
07:30:44 <quicksilver> and they do help a lot.
07:30:45 <dramforever> orion: so compare this to some function that could modify the key without the type saying so
07:31:14 <roconnor> well it is a little different.  I didn't have to write the word CipherState twice.
07:31:47 <dramforever> orion: I don't know if you really understand/agree with this, but we really put great emphasis on types
07:32:06 <orion> dramforever: I like types. I eat that shit for breakfast.
07:32:38 <dramforever> um..is that an idiom? (non-native English speaker here)
07:32:51 <orion> dramforever: Yes.
07:33:04 <delYsid> ghc-pkg: Prelude.chr: bad argument: 3963600
07:36:06 <delYsid> I get this when I run "cabal list".
07:39:12 <geekosaur> sounds like you have a corrupt package index. try "cabal update"
07:43:36 <jgertm> how do i compose lenses if one of them returns Maybe?
07:44:33 <clrnd> fmap?
07:45:02 <jgertm> clrnd: that works. however, id prefer if i could just compose with (.)
07:47:37 <orion> Has anyone encountered problems with building/installing haskell-src-exts in travis-ci?
07:54:07 <quicksilver> jgertm: you can compose with . _Just . in the middle
07:54:14 <quicksilver> jgertm: (it won't be a lense any more, of course)
07:54:29 <quicksilver> but it will still be a traversal and a fold, which may well be what you need
07:57:31 <quicksilver> > (3, Just (4,5)) & _2 . _Just . _1 %~ (*2)
07:57:33 <lambdabot>  (3,Just (8,5))
07:58:29 <orion> quicksilver: It just occurred to me that it might be useful to have the ability to wipe the symmetric key from memory under certain circumstances. Is this pretty much impossible to do without introducing lots of complexity?
08:02:43 <quicksilver> orion: a proper secure erase?
08:03:00 <orion> quicksilver: Yes.
08:03:09 <quicksilver> don't think GHC has any support for such operations :(
08:03:55 <orion> I see, ok.
08:04:48 <quicksilver> you could access the value through a C API where some kernel support was used to lock and erase it 
08:05:01 <quicksilver> but you'd still worry the value got copied around when haskell was using it
08:05:42 <orion> Ah, futile. :(
08:09:05 <Pro9> When I try to implement something in haskell: me: tries to do something, ghci: no error message, me: wow, it worked, 2 seconds later *facepalm* I forgot to save, ghci: 5 error messages :P
08:11:45 <Pro9> But I guess that's due to me writing in one window and then running the code on another, I suppose that wouldn't be an issue if I was using a proper IDE
08:13:57 * hackagebot diagrams-qrcode 1.3 - Draw QR codes to SVG, PNG, PDF or PS files.  https://hackage.haskell.org/package/diagrams-qrcode-1.3 (FelipeLessa)
08:14:11 <clrnd> Pro9, well, in python yo gotta save, then run, then test everything a thousand times, so that's a win
08:16:19 <Pro9> clrnd: that doesnt sound fun
08:16:34 <quicksilver> Pro9: if you work by saveing the file and then :r or :l in ghci
08:16:40 <quicksilver> then you are only running code you have saved
08:16:59 <quicksilver> but of course sometimes it's nicer to try stuff out in ghci and then copy-paste it to your real source file
08:17:03 <quicksilver>  a mix of both works for me.
08:17:42 <Pro9> quicksilver: ye, I also do little of both
08:18:01 <Pro9> hmm, what does :r do?
08:18:04 <Pro9> I only use :l
08:18:18 <clrnd> :reloads last :loaded file
08:18:57 * hackagebot ig 0.6 - Bindings to Instagram's API.  https://hackage.haskell.org/package/ig-0.6 (FelipeLessa)
08:19:03 <Pro9> clrnd: ahh, should probably use that more.... I just cycle through my previous commands until i find that last :l ...
08:19:17 <clrnd> that can take a while :P
08:19:31 <clrnd> yeah, would love if I could bind shortcuts inside ghci
08:19:38 <clrnd> like Ctrl-R => :reload
08:19:45 <clrnd> (now I'm webdev lol)
08:19:53 <Pro9> clrnd: That would be nice :D
08:23:33 <Shockk> hah I was reading a stackoverflow answer and noticed the name and realized dmwit_ wrote it
08:23:58 * hackagebot yesod-auth-account-fork 2.0.3 - An account authentication plugin for Yesod  https://hackage.haskell.org/package/yesod-auth-account-fork-2.0.3 (FelipeLessa)
08:27:56 <quicksilver> clrnd, Pro9 : well ghci is built with a readline-style library
08:28:05 <quicksilver> ctrl-R should let you do a search through history
08:28:12 <quicksilver> so ctrl-R :l 
08:28:19 <quicksilver> should find you the last :load command you used
08:28:25 <clrnd> quicksilver, that's actually more keystrokes than :l
08:28:35 <clrnd> quicksilver, (though I use it for other stuff)
08:28:37 <clrnd> :P
08:28:52 <quicksilver> :l on its own doesn't do anything tho?
08:28:58 <clrnd> quicksilver, :r
08:28:58 <quicksilver> I agree it's more than :r though :)
08:29:00 * quicksilver nods
08:29:06 <quicksilver> but it's good to know
08:29:13 <clrnd> yeah! you can do it in bash people
08:29:17 * quicksilver runs ghci in an emacs buffer anyway himself
08:29:27 <clrnd> anyway, I'd love a kind of "super" ghci
08:29:36 <clrnd> with a ncurses style GUI
08:30:03 <clrnd> that just spit errors one by one in a buffer, which you can cycle, with colours and stuff
08:30:11 <clrnd> ..... I guess that's what emacs people have
08:30:16 <Shockk> more like IDE-scale?
08:30:32 <clrnd> yeah but I don't use IDEs for many reasons, I'd love it if it was a separate thing
08:30:37 <geekosaur> don't know of a standalone one
08:30:45 <Shockk> that'd be interesting
08:30:46 <geekosaur> @hackage ihaskell
08:30:46 <lambdabot> http://hackage.haskell.org/package/ihaskell
08:30:56 <clrnd> isn't that inotebook style?
08:30:57 <geekosaur> (haskell in an ipython notebook)
08:31:00 <clrnd> yeah
08:31:07 <Pro9> quicksilver: I dont think ctrl+r does a search for me, not really sure what it does, but it might be because I'm using WinGHCi
08:31:14 <clrnd> ipython is great! (has many downfalls too)
08:31:22 <clrnd> Pro9, yeah it's a UNIX thing
08:31:31 <hiptobecubic> *jupyter notebook :)
08:31:40 <clrnd> anyway that's for writing haskell, I jsut want to ... REPL
08:32:35 <Shockk> I got into a thought-provoking discussion with someone earlier, elsewhere, about partial functions vs total functions
08:32:36 <lpaste> Pro9 pasted “If Maybe Int = Nothing do that, else return y in (Just y)” at http://lpaste.net/5433109758011768832
08:33:08 <Shockk> I wondered what the general opinion is regarding partial vs total
08:33:22 <geekosaur> total functions tend to be strongly preferred
08:33:51 <geekosaur> that said, people may moderate their opinions a bit once ghc 8 arrives, since it will have proper backtraces for exceptions
08:34:09 <geekosaur> (right now, partial functions give you exceptions that are rather difficult to track to their source)
08:34:13 <Shockk> oh interesting
08:34:29 <clrnd> er, partial functions are just nasty :|
08:34:47 <clrnd> (I do it a lot because I'm lazy, doesn't mean it's okay)
08:34:49 <lpaste> Gurkenglas annotated “If Maybe Int = Nothing do that, else return y in (Just y)” with “If Maybe Int = Nothing do that, else return y in (Just y) (annotation)” at http://lpaste.net/5433109758011768832#a142139
08:35:29 <Pro9> Gurkenglas: Ty :)
08:35:37 <quicksilver> clrnd: it's not really a unix thing. It's just about linking with an editline/readline package.
08:35:43 <quicksilver> apparently winghci isn't? but that's odd...
08:35:50 <Shockk> personally, I try to avoid using them at all when I can 
08:36:07 <Gurkenglas> Of course, any of these are meant to indicate that you, personally, wrote the program wrong, if that message ever goes on the screen
08:36:46 <clrnd> quicksilver, in my experience, readline things not don't work in windows, not even cygwin
08:36:59 <geekosaur> winghci is a GUI environment; it would not use a CUI editing package
08:37:18 <quicksilver> is it really?
08:37:23 * quicksilver hasn't seen winghci
08:37:26 <hodapp> :t (\a b -> a =<< return b)
08:37:27 <geekosaur> (readline-y things can be made to work but it's hard)
08:37:28 <lambdabot> Monad m => (a -> m b) -> a -> m b
08:37:41 <hodapp> I feel like what I just wrote has to easy to simplify...
08:38:04 <Pro9> Gurkenglas: I realised that while looking at your code, and it was good that you provided different ways to do it, it goes into my GoodToKnow.hs file :)
08:38:12 <quicksilver> but there is no reason why a program which takes lots of text input, as it surely does, shouldn't also support line editing commands
08:38:15 <quicksilver> hodapp: a b
08:38:19 <hiptobecubic> hodapp, isn't that just `b a` ?
08:38:21 <quicksilver> hodapp: that is literally all it is :)
08:38:29 <hiptobecubic> err
08:38:31 <hiptobecubic> yes
08:38:33 <hiptobecubic> a b :)
08:39:03 <hodapp> it's in a big string of a =<< b =<< c =<< d...
08:39:13 <geekosaur> it probably *could* support it, but that's not how most GUI environments operate
08:39:13 <hiptobecubic> hodapp, doesn't matter
08:39:14 <hodapp> so that was confusing me a little
08:39:31 <geekosaur> winghci does the usual windows GUI stuff, not readline. ctrl-f might work...
08:40:47 <Pro9> :t fromJustNote
08:40:48 <lambdabot> Not in scope: ‘fromJustNote’
08:41:26 <Shockk> just curious,
08:41:40 <Shockk> > fromJust Nothing
08:41:42 <lambdabot>  *Exception: Maybe.fromJust: Nothing
08:41:50 <Shockk> ah okay
08:42:10 <hodapp> :t (\a b c -> a =<< return b =<< c)
08:42:11 <lambdabot> Monad m => (a -> m b) -> m a -> m a1 -> m b
08:44:45 <quicksilver> hodapp: are you sure?
08:44:58 <hodapp> quicksilver: am I sure of what?
08:45:12 <quicksilver> chaining =<< through return b looks odd
08:45:33 <hodapp> quicksilver: yes, that's why I'm looking to simplify it
08:46:13 <quicksilver> I'm confused that that even typechecks
08:46:23 <hiptobecubic> it's pretty odd, yes
08:46:40 <glguy> It's using Reader's return (const)
08:46:44 <hiptobecubic> right
08:47:13 <quicksilver> so one of those =<< is in the (->)r monad?
08:47:20 <quicksilver> and the other =<< is in the 'm' monad ?
08:47:31 <hiptobecubic> :t \a b c -> a =<< b << c
08:47:32 <lambdabot>     Not in scope: ‘<<’
08:47:32 <lambdabot>     Perhaps you meant one of these:
08:47:32 <lambdabot>       data constructor ‘Seq.:<’ (imported from Data.Sequence),
08:47:43 <glguy> No, all the =<<'s are at the same Monad instance
08:47:49 <hiptobecubic> :t let (<<) = flip >> in (\a b c -> a =<< b << c)
08:47:50 <lambdabot> parse error on input ‘in’
08:47:52 <glguy> :t (\a b c -> a =<< const b =<< c) 
08:47:53 <lambdabot> Monad m => (a -> m b) -> m a -> m b1 -> m b
08:47:54 <hiptobecubic> sigh
08:48:04 <quicksilver> glguy: oh!
08:48:07 <glguy> :t (\a b c -> c >> b >>= a)
08:48:07 <quicksilver> glguy++
08:48:08 <lambdabot> Monad m => (a -> m b) -> m a -> m a1 -> m b
08:48:13 * glguy overflows
08:48:48 <quicksilver> so the return value of c is being ignored (passed to const b)
08:49:08 <quicksilver> and then the return value of b is being sent to a
08:49:17 <quicksilver> and this is why non-associative operators are bad!
08:49:28 <quicksilver> hodapp: initially asked us about "a =<< return b"
08:49:35 <quicksilver> but "a =<< return b" is not a sub expression of this
08:49:39 <quicksilver> because it's actually
08:49:49 <quicksilver> a =<< (return b =<< c)
08:50:21 <glguy> osa1: You around?
08:53:12 <hodapp> huh, so all I needed was actually (=<<) but for whatever reason I'd fudged up an earlier test I had done where I tested that already
08:53:38 <hodapp> and so I thought that that wasn't type-checking
08:54:48 <hodapp> must have had a type I missed or something
08:58:58 <suppi> what is the easiest way to play a note in haskell?
08:58:59 * hackagebot feed 0.3.10.2 - Interfacing with RSS (v 0.9x, 2.x, 1.0) + Atom feeds.  https://hackage.haskell.org/package/feed-0.3.10.2 (AdamBergmark)
09:05:03 <orion> Is there a way to specify HEAD in cabal's tested-with field?
09:06:30 <geekosaur> I doubt it, especially since it'd be a lie --- chances are good that by the time it hit hackage, HEAD wouldn't be the same :)
09:07:04 <orion> hah, true
09:22:57 <bollu> this maybe stupid, but can I do "useful" things in Agda?
09:23:05 <bollu> (IO, DB, Networking, Graphics...?)
09:23:50 <bollu> I understand that Coq is purely for proofs
09:24:01 <bollu> but Agda describes itself as a "programming language"
09:25:20 <tyrion-mx> Hello, if I have two lines in a do block like a <- first and then b <- second, it should desugar to first >>= \a -> second >>= \b ...
09:25:22 <tyrion-mx> right?
09:25:34 <tommd> Yes
09:25:43 <tyrion-mx> but what if I don't have the "<-"
09:25:53 <tommd> first >> second
09:26:00 <tyrion-mx> like if I have two lines being only "first" and "second"
09:26:08 <tommd> first >> second
09:26:10 <bollu> tyrion-mx: as in "do a b" ? then that desugars to a >> b
09:26:14 <tyrion-mx> ok, thank you :)
09:27:30 <glguy> "do a b" desugars to "a b"
09:27:53 <orion> I am designing a function called "mixHash". It takes a CipherState and some arbitrary data, and it updates the CipherState. I think it's a poor idea to use a ByteString to represent the arbitrary data, because I want to prevent application users from passing semantically incorrect data to mixHash. I'm thinking of creating a typeclass called "Hashable" and making all the newtypes which are allowed to be hashed instances of the class. Is this a good idea?
09:27:59 <tyrion-mx> glguy, because there is no new line, correct?
09:28:03 <glguy> yeah
09:28:06 <tyrion-mx> :)
09:28:23 <bollu> glguy: ohh :)
09:28:32 <orion> Or, is the fact that I am jumping right in to a typeclass a sign of bad design?
09:28:34 <bollu> glguy: right, I meant two statements after one another
09:29:40 <suppi> bollu, a >> b is like a >>= \_ -> b
09:29:44 <tommd> orion: You left ##crypto before being warned to push your ECDH shared secret through KDF or face the wrath of a red team eventually.  So, do that.
09:30:04 <bollu> suppi: yes, Ik. So I meant that if you have a do block with two statement "a" and "b" it two different lines, it desugars to a >> b
09:30:19 <bollu> isn't that just a >>= (const b) btw?
09:30:20 <suppi> yes
09:30:27 <geekosaur> orion, there is already a Hashable with a different (but similar) purpose; for this you might want another name
09:30:35 <geekosaur> (unordered-containers package)
09:30:48 <orion> geekosaur: Good idea. Do you think that the use of a typeclass is called for here?
09:31:25 <geekosaur> it can be? think I'd need more detail on what kind of restrictions you need on the types
09:31:52 <geekosaur> if it's ad-hoc (i.e. they aren't easily done by e.g. parameterization) then a typeclass is likely called for
09:36:20 <orion> geekosaur: Hmm, My ultimate goal is to get cryptographic data inside a newtype'd ByteString as soon as possible to prevent application users from passing, say, ECDHOutput to a function which is only meant to be used for PlainText, CipherText, etc.
09:37:16 <bollu> does spacemacs have a "layer" for Agda?
09:37:39 <ReinH> orion: It shouldn't matter when it's newtyped as long as the only way to newtype it is secure.
09:38:23 <ReinH> bollu: You can find out by looking at the github repo or the source
09:38:37 <ReinH> It would be in layers/+lang
09:38:51 <bollu> thanks :)
09:39:00 * hackagebot mtl-unleashed 0.5 - MTL classes without the functional dependency  https://hackage.haskell.org/package/mtl-unleashed-0.5 (DavidFox)
09:39:15 <bollu> ReinH: is haskell working on el cap BTW?
09:40:48 <geekosaur> sufficiently recent versions of it should work
09:40:59 <geekosaur> there's a platform installer candidate to work around rootless
09:41:24 <geekosaur> for other installation types, you need to make sure the unix library is the most recent version or it will throw spurious errors
09:43:02 <geekosaur> (pretty sure it's packaged with ghc because ghc itself uses it, so with an older ghc you would have problems)
09:46:15 <tyrion-mx> is there a way to see the documentation of a function and/or its source code from ghci?
09:46:27 <tyrion-mx> would be real nice as I am a beginner
09:46:45 <tyrion-mx> (with ipython I can do this with ? and ??)
09:47:36 <athan> Does `seq` / `force`ing a function usually do anything?
09:48:05 <athan> - for how much space its.. thunk? is consuming, I mean
09:48:57 <johnw> athan: example?
09:49:26 <johnw> seq x y means that evaluating y to WHNF will also evaluate x to WHNF
09:49:45 <fragamus> howdy
09:50:17 <johnw> that sounds like a thunk referring to two other thunks or values
09:50:23 <athan> johnw: Hmm, okay. I'm just trying to imagine how storing functions like `[Foo -> Bar]` might get costly, space-wise. But then again, I have no idea how Haskell stores data like that :|
09:50:40 <athan> er, storing lists of functions*
09:50:54 <johnw> do you mean, storing the function, or storing a call, or storing a closure over a call?
09:51:28 <johnw> the function itself should be like any language, it's in the .text section of the executable, so the value is an address
09:52:00 <johnw> a thunk represent a call may retain its referenced values on the heap; and a closure could have some additional residency in the heap as well
09:52:33 <johnw> that why it would be important to see the actual code, than try to theorize from generalities
09:53:17 <johnw> (I guess in my example here, the call and closure case are really the same thing)
09:53:30 <fragamus> > 1 + 1
09:53:32 <lambdabot>  2
09:53:51 <athan> johnw: Thanks, I guess I'll just have to do more investigation
09:54:01 * hackagebot th-typegraph 0.31 - Graph of the subtype relation  https://hackage.haskell.org/package/th-typegraph-0.31 (DavidFox)
09:54:04 <johnw> athan: check the Core, do some heap profiling
10:19:01 * hackagebot nested-routes 6.0.0 - Declarative, compositional Wai responses  https://hackage.haskell.org/package/nested-routes-6.0.0 (athanclark)
10:24:41 <athan> What module classification would you put grammars under? Mine is a common grammar - that for linear equations (usually over Rationals). Any ideas?
10:25:02 <bollu> Agda *needs* unicode?
10:25:19 <bollu> "To make it short, you need Emacs" :(
10:25:28 <athan> I was thinking Data.Linear, but idk if that constitutes for common utility data types, and not specifications for a particular domain
10:26:09 <merijn> bollu: Why not look at Coq? :)
10:26:16 <merijn> Granted, Coq has uglier syntax, but still
10:26:34 <bollu> merijn: I've actually installed both
10:26:46 <bollu> I can't even figure out how to *invoke* coq :P
10:27:31 <merijn> @where sf
10:27:31 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages", "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof
10:27:31 <lambdabot> assistant."
10:27:36 <merijn> See that (free) book
10:28:12 <bollu> oh wow
10:28:18 <bollu> thanks a *metric ton*
10:33:41 <suppi> what is the easiest way to make a sound in haskell?
10:33:59 <ARM7> putStr "\a"
10:35:06 <suppi> cool, I wonder if that'll be enough :P
10:35:48 <geekosaur> heh
10:36:41 <geekosaur> csound-expression, vivid, hsc3 have been mentioned recently on the cafe list
10:37:40 <dolio> csound-expression is pretty cool.
10:38:22 <suppi> geekosaur, dolio, thanks :D
10:40:22 --- mode: leguin.freenode.net set +o ChanServ
10:40:57 <suppi> dolio, yeah, was not enough :)
10:47:14 <suppi> dolio, oops, I meant ARM7 
10:48:35 <phaazon> oh gosh that’s great
10:48:37 <phaazon> with DataKinds
10:48:49 <phaazon> one can promote Strings as types!
10:49:32 <tommd> It's horrible.
10:49:42 <phaazon> tommd: it’s not
10:50:04 <Stratege> oh hello C++ template system, didn't expect to see you in Haskell.
10:50:45 <phaazon> you can promote integers to types through Nat
10:51:09 <phaazon> there’s no reason we not be able to do the same thing with Strings
10:51:49 <dmj`> phaazon: agreed, type level literals rock
10:52:27 <phaazon> the cool thing is the fact that it’s easier to create type with String and reflect the String at runtime in a constant way
10:55:06 <dmj`> phaazon: yes, and the ability to constrain a type level string on a class is cool too
10:55:08 <phaazon> dmj`: I just wonder how I could reflect the type though
10:55:16 <phaazon> dmj`: yeah
10:55:28 <phaazon> with TypeFamilies it can end up in very interesting things!
10:55:50 <phaazon> class Foo s a | s -> a where …
10:55:57 <phaazon> instance Foo "foo" Int where…
10:56:24 <phaazon> I’m looking for a way to reflect the String at runtime
10:56:33 <recur22> hi everyone, is there any effort to make data format like json for haskell that supports and check against haskell types
10:56:35 <dolio> It's stranger in some ways than C++'s system, I think.
10:57:36 <dmj`> phaazon: .. where getFoo Proxy = length (symbolVal $ Proxy :: Proxy "foo")
10:57:46 <phaazon> symbolVal?
10:57:57 <phaazon> I thought it’d work only for the GHC.TypeLits symbols
10:58:24 <dmj`> phaazon: exactly, it is, symbolVal will let you Proxy type level literals
10:59:03 * hackagebot mustache 0.2.0.0 - A mustache template parser library.  https://hackage.haskell.org/package/mustache-0.2.0.0 (justus)
10:59:40 <phaazon> Prelude Data.Proxy GHC.TypeLits> symbolVal (Proxy :: Proxy "foo")
10:59:41 <phaazon> "foo"
10:59:43 <phaazon> :3
10:59:44 <phaazon> thanks dmj` 
11:00:03 <dmj`> phaazon: we can make the instance generic, KnownSymbol sym => instance Foo s a | s -> a, then any symbol can be had
11:00:11 <dmj`> phaazon: for sure
11:00:21 <dmj`> KnownSymbol s =>  ** 
11:00:30 <phaazon> what is **?
11:00:47 <dmj`> ha sorry, I typod, should have written s/sym/s
11:00:58 <dmj`> KnownSymbol s => instance Foo s a | s -> a
11:03:42 <phaazon> dmj`: ok
11:03:44 <phaazon> :k "foo"
11:03:46 <lambdabot> GHC.TypeLits.Symbol
11:03:49 <phaazon> I thought it’d be String
11:04:55 <dmj`> phaazon: the kind of type level string literals is Symbol, so it really can't be used in the same type def as other types w/ kind *, unless we enable PolyKinds
11:05:35 <dmj`> I think poly kinds promotes the kinds of type level literals to * (which is strange because the kind of 'Symbol' is *)
11:05:49 <phaazon> dmj`: hu
11:06:06 <phaazon> I thought PolyKinds was just there to allow to write polymorphic kinds
11:06:09 <phaazon> like
11:06:20 <phaazon> data Proxy :: (k :: *) -> * where…
11:07:02 <dmj`> phaazon: yes, so doing something like type API = "api" :> Int can't work, since "api" is of kind Symbol and Int is of kind *
11:07:22 <phaazon> :> ?
11:07:33 <dmj`> assuming the defintion of (:>) is 'data path :> rest' w/ DataKinds + TypeOperators enabled
11:07:42 <phaazon> ok
11:07:55 <phaazon> well
11:08:00 <phaazon> make path and rest have polykinds
11:08:05 <phaazon> and you’re good to go
11:08:05 <dmj`> we'd need to enable poly kinds and define it as data (path :: k) :> rest, then type level literals can coexist w/ types of other kinds
11:08:09 <dmj`> exactly
11:09:04 <dmj`> phaazon: a moment of revelation was pattern matching at the type level w/ type level lists
11:09:20 <phaazon> with TypeFamilies?
11:09:34 <dmj`> just vanilla typeclasses
11:09:39 <phaazon> oh, yeah
11:11:31 <ski> phaazon : there are no polymorphic kinds in GHC, afaik
11:11:58 <dmj`> ski: what is poly kinds then ?
11:12:00 <phaazon> because they all have the same sort, BOX ?
11:12:15 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/kind-polymorphism.html
11:13:50 <ski> dmj` : it allows polymorphic types
11:15:52 <ski> dmj` : `length', of type `forall a. [a] -> Int', is a polymorphic value. `Proxy', of kind `forall k. k -> *', is a polymorphic type
11:16:48 <ski> `Typable', of kind `forall k. k -> Constraint', would be a polymorphic type class
11:16:58 <ski> (s/Typable/Typeable/)
11:18:29 <obadz-> anyone knows how to add a constant to all elements of a vector in hmatrix?
11:18:47 <dmj`> ski: don't polymorhpic types necessitate polymorphic kinds
11:20:10 <Hafydd> obadz-: apparently you have to use cmap (+k), as there's no Functor instance.
11:21:38 <obadz-> Hafydd: I thought there's be something more "vectorized". In the internals, I see addConstant = vectorMapValF AddConstant
11:21:44 <obadz-> doesn't seem to be exported
11:21:59 <obadz> scale is exported
11:23:07 <obadz> oooh, it does get exported
11:23:58 <ski> dmj` : no, not any more than polymorphic values necessitates polymorphic types
11:24:33 <Hafydd> obadz: I see. I don't know, then.
11:24:38 <ski> dmj` : the type of a polymorphic value is not a polymorphic type. it might be called a universal type, a type of shape `forall a. ..a..'
11:25:37 <ski> dmj` : e.g. `length' is polymorphic. `forall a. [a] -> Int' isn't
11:28:13 <dolio> I think quite a few people would call that a 'polymorphic type'. It just isn't using kind polymorphism.
11:29:49 <dmj`> ski: length :: [a] -> Int, vs. forall a . [a] -> Int, isn't the forall implicit in 'length', what makes one polymorphic over the other
11:32:39 <dmj`> ski: I think I'm just confued :P
11:32:53 <dmj`> s/confued/confused
11:33:19 <mniip> ski, eh, I can't seem to understand what you mean either
11:33:25 <mniip> do you mean polymorphic values are uniform?
11:34:16 <dolio> His point is that: length :: forall a. [a] -> Int
11:34:26 <dolio> And: forall a. [a] -> Int :: *
11:34:51 <mniip> ah
11:34:54 <dolio> So you do not need quantification to give the kind, even though the type has quantification.
11:35:27 <mniip> pedantry related to "polymorphic" types being actually monomorphic because they aren't kind-polymorphic
11:35:58 <dolio> So when you allow types whose kinds require quantification, you do not necessarily need quantification to give the sort of those kinds.
11:36:45 <freinn> hi! I have a problem printing extrange characters from a file, spanish tildes like "hola qué tal?" here is my code: http://lpaste.net/142151
11:37:12 <ski> dmj`,mniip : over the choice of deciding to call `length' polymorphic, and alternatively calling its type, `forall a. [a] -> Int', polymorphic, i prefer the former option
11:37:30 <mniip> dolio, forall (k :: *). forall (a :: k). a
11:37:31 <mniip> :P
11:37:43 <ski> if you're going to insist on calling the type `forall a. [a] -> Int' polymorphic, then i must insist on `length' not being polymorphic
11:37:54 <ski> however, the former option sounds more useful, to me
11:38:32 <geekosaur> freinn, Char8 truncates unicode
11:38:48 <geekosaur> just, NEVER use it with text
11:39:02 <freinn> geekosaur thanks, ok whats the alternative?
11:39:05 <geekosaur> you really should use Data.Text for this
11:39:05 <dolio> mniip: That's a kind error.
11:39:16 <geekosaur> if you must use ByteString, don;t use the Char8 variants
11:39:22 <ski> mniip : well, the type `forall (k :: *). forall (a :: k). a' wouldn't be polymorphic either .. though in fact, the body of a `forall'-type must have kind `*', so that's not a valid type
11:39:25 <freinn> geekosaur thanks
11:39:26 <mniip> yes
11:39:27 <mniip> k ~ *
11:39:31 <mniip> how bout
11:39:37 <mniip> forall (k :: *). forall (a :: k). Proxy a
11:39:50 * ski was just going to write what mniip just did :)
11:40:09 <dolio> mniip: So, what about that?
11:40:33 <mniip> a polymoprhic-typed polymorphic value
11:40:40 <dmj`> ski: would you call different types of the same kind 'polymorphic' ?, i.e. take 'a' constrained on Num. I still fail to see the difference between length and forall a . [a] -> Int. 
11:41:04 <ski> dmj` : `length' is a value, `forall a. [a] -> Int' is a type
11:41:12 <dolio> forall (k :: *). forall (a :: k). Proxy a :: *
11:41:19 <ski> dmj` : you wouldn't confuse an integer, like `3', from a type, like `Integer
11:41:23 <ski> ', would you ?
11:41:39 <ski> you wouldn't say `sum [Integer,Int,Double]'
11:41:53 <ggole> Do you think he is making that kind of mistake?
11:42:33 <ski> ggole : possibly
11:42:46 <dmj`> ski: I'd say 'length []' is a value, but not 'length'
11:43:00 <ski> dmj` : i'm not sure what you mean by "different types of the same kind"
11:43:06 <ski> dmj` : functions are values
11:43:22 <dmj`> ski: then forall a . [a] -> Int is a value too
11:43:53 <ski> > length [length,(!! 2)]
11:43:55 <lambdabot>  2
11:44:03 <ski> dmj` : no
11:44:20 <Shockk> > length [forall a. [a] -> Int]
11:44:22 <lambdabot>      Pattern syntax in expression context: forall a . [a] -> Int
11:45:01 <dmj`> > length [ length :: forall a. [a] -> Int ]
11:45:01 <Shockk> (->) isn't a data constructor, it's a higher-kinded type (has two type parameters)
11:45:02 <lambdabot>  1
11:45:17 <dmj`> ski: I think I see now
11:45:56 <neuroserpens> :t (->)
11:45:57 <ski> (actually, `(->)' is first-order, it doesn't take any type function as argument (unlike e.g. `StateT'))
11:45:58 <lambdabot> parse error on input ‘->’
11:46:00 <ski> @kind (->)
11:46:01 <lambdabot> * -> * -> *
11:46:02 <neuroserpens> xD
11:46:03 <ski> @kind (StateT
11:46:04 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
11:46:07 <ski> @kind StateT
11:46:08 <lambdabot> * -> (* -> *) -> * -> *
11:46:10 <Shockk> :k (->)
11:46:11 <lambdabot> * -> * -> *
11:47:21 <Shockk> oh, I need to correct my definition of higher-kinded type
11:47:56 <obadz> grrrr.. anyone knows how to extract a column or row of a matrix in hmatrix? Matrix a -> Int -> Vector a is what I'm looking for and can't find it.
11:47:58 <dmj`> ski: forall a . [a] -> Int is literally a type, was failing to see the distinction, length is a value with that type
11:48:32 <napping> Can an explicitly bidirectional type synonym have a stricter constraint when used as an expression?
11:48:39 <ski> dmj` : yes
11:49:49 <ski> dmj` : `length' is polymorphic in that it can be used at particular types that are instances of its most general type, `forall a. [a] -> Int'. e.g. it can be used at type `[Int] -> Int' or at type `[String -> Maybe (Double,String)] -> Int'
11:50:31 <clrnd> :t length
11:50:32 <lambdabot> Foldable t => t a -> Int
11:50:48 <ReinH> These days it's even more polymorphic ;)
11:50:51 <napping> I'm trying to clean up some code that expresses types with explicit fixpoints - for pattern matching I'd like to be able to silently ignore annotatiosn added with Cofree f a, but for construction only things like Fix f can be built
11:50:52 <ski> dmj` : the type `Proxy' is polymorphic in that it can be used at particular kinds that are instances of its most general kind, `forall k. k -> *'. e.g. it can be used at kind `* -> *' (e.g. in `Proxy Int') or at kind `(* -> *) -> *' (e.g. in `Proxy Maybe')
11:51:23 <Shockk> "forall a. [a] -> Int"   the type of length, for every `a', is ([a] -> Int)
11:52:02 <ski> dmj` : however, there's also a value (a data constructor) named `Proxy', which has type `forall k. Proxy k'
11:52:23 <eacameron> is there a regex lib that supports doing parallel executing for finding matches?
11:52:31 <ski> clrnd,ReinH : yes
11:52:38 <magamig> > @source isDigit
11:52:40 <lambdabot>  <hint>:1:1: parse error on input ‘@’
11:52:49 <Shockk> magamig: no > at the start
11:53:07 <Shockk> @source isDigit
11:53:07 <lambdabot> Unknown command, try @list
11:53:15 <albertus1> @src
11:53:15 <lambdabot> src <id>. Display the implementation of a standard function
11:53:18 <Shockk> oh right
11:53:31 <magamig> src isDigit
11:53:39 <magamig> >src isDigit
11:53:42 <Shockk> lol
11:53:44 <albertus1> ......
11:53:46 <magamig> HOW??? xD
11:53:48 <Shockk> here
11:53:49 <phaazon> hey, has haskellers been discontinued?
11:53:50 <Shockk> @src isDigit
11:53:50 <lambdabot> Source not found. Are you typing with your feet?
11:53:50 <albertus1> @src isDigit
11:53:50 <lambdabot> Source not found. I am sorry.
11:53:52 <lyxia> obadz: (Numeric.LinearAlgebra.Data.¿) 
11:53:56 <Shockk> rofl
11:53:56 <ski> @where src
11:53:56 <lambdabot> The fixed database for the `src' lambdabot command is at <https://github.com/lambdabot/lambdabot/blob/master/lambdabot/State/source>
11:53:58 <phaazon> haskellers.org
11:54:15 <phaazon> oh it’s .com
11:54:20 <phaazon> nevermind
11:54:23 <Shockk> slightly anticlimactic there
11:54:28 <dolio> ski: Not just that. More like `forall k. forall (t :: k). Proxy t`. But you can't say that exactly.
11:54:41 <dolio> You can only say the part after the `forall k.`
11:54:42 <lyxia> obadz: and toColumns
11:54:48 <dmj`> ski: so the type of Proxy (data consturctor) is a poly-kinded type
11:55:07 <ski> dolio : er, you're correct
11:55:38 <dmj`> :t Proxy -- Proxy :: Proxy (t :: k)
11:55:39 <lambdabot> forall (k :: BOX) (t :: k). Proxy t
11:55:40 <ski> dmj` : not sure what you mean by "poly-kinded type"
11:56:35 <dmj`> ski: a type with kind 'k', data Proxy (t :: k) = Proxy
11:56:37 <ReinH> :k Category
11:56:38 <lambdabot> (k -> k -> *) -> Constraint
11:56:59 <ski> dmj` : `k' there is a kind variable, not a specific kind
11:57:05 <nshepperd_> a type universally quantified over a kind variable?
11:57:16 <dmj`> ski: ah I see
11:57:42 <ski> nshepperd_ : yes
11:57:50 <ggole> Is this kind polymorphism?
11:58:37 <kristof> what would you even use that for?
11:58:39 <kristof> ._.
11:58:48 <kristof> It seems weird to me that the type should know about the kind
11:58:56 <bitemyapp> kristof: kind polymorphism is hella nifty.
11:58:58 <kristof> in the same way that it would seem weird to me that a data constructor would know about the type
11:59:00 <dmj`> ski: don't kind variables mean polymoprhic kinds, in the same way type variables mean polymoprhic types
11:59:06 <bitemyapp> athan: wake up, you need to tell kristof how cool polykinds are.
11:59:07 <kristof> bitemyapp: I know it's used in servant
11:59:25 <kristof> I want to see the light and type check all the things
11:59:42 <ski> dmj` : imho "kind polymorphism" is a misnomer
11:59:43 <Shockk> I think the way that "forall (k :: BOX) (t :: k). Proxy t" is read is:
11:59:54 <Shockk> for all kinds of sort BOX: 
12:00:04 <Shockk>   for all types of that kind:
12:00:11 <dmj`> ski: ah, may I ask why
12:00:15 <Shockk>     there exists a type (Proxy t)
12:00:28 <ski> Shockk : remove the "there exists a type" part, and you're good
12:00:40 <Shockk> oh
12:00:53 <ski> dmj` : because `PolyKinds' enables polymorphic *types*, not *kinds*
12:01:28 <ski> dmj` : also, in my use of terminology, both "type variables mean polymoprhic types" and "kind variables mean polymoprhic kinds" are incorrect
12:02:31 <ski> dmj` : being able to universally quantify over type variables in types, means that values of such universal types are polymorphic
12:02:48 <ski> dmj` : being able to universally quantify over kind variables in kinds, means that types of such universal kinds are polymorphic
12:03:02 <athan> bitemyapp: Unughhh, what?
12:03:06 <ggole> Isn't that a more narrow (and precise) meaning of 'polymorphic' than is usually understood?
12:03:09 <athan> kristof: They're really cool
12:03:21 <kristof> Okay, I'm reading the official haskell documentation and I'm confused by the very first line.
12:03:26 <kristof> data Proxy t = Proxy
12:03:27 <athan> you get polymorphism over your type functions
12:03:40 <kristof> Why would the inferred kind be forall k. k -> *?
12:03:42 <orion> bitemyapp: Hey there, did you see this?: https://github.com/bitemyapp/bloodhound/pull/72
12:03:42 <athan> kristof: A way of encoding terms for type-level constructs
12:03:47 <athan> for instance
12:03:56 <Shockk> semi-related question; is there anything similar to DataKinds like TypeSorts for promoting types that have been promoted to kinds, to sorts or something?
12:03:59 <ski> dmj` : also, the type of the value `Proxy' above also universally quantifies over a *kind* variable in a *type*, which is yet another case
12:03:59 <athan> @type Proxy :: Proxy '[Int]
12:04:01 <lambdabot> Proxy '[Int]
12:04:17 <kristof> :kind Proxy :: Proxy '[Int]
12:04:28 <athan> kristof: You can only have tangible values when the type of the value has kind *
12:04:35 <ski> kristof : no need to restrict the kind of `t', so it's left as a kind variable `k', which is generalized over
12:04:39 <athan> therefore, all inputs to functions must also be * kinded
12:04:47 <athan> @kind (->)
12:04:48 <lambdabot> * -> * -> *
12:04:55 <athan> @kind Proxy
12:04:56 <lambdabot> k -> *
12:04:56 <kristof> athan: I'm sorry, I was stuck thinking about datakinds, where Proxy would be promoted to kind Proxy
12:05:00 <ski> @where TV  -- Tanglible Values
12:05:00 <lambdabot> http://www.haskell.org/haskellwiki/TV
12:05:02 <dmj`> ski: so are you saying that because the types of kinds aren't polymorphic, kind polymorphism is a misnomer
12:05:03 <kristof> The data constructor
12:05:06 <kristof> stupid punning.
12:05:08 <monochrom> kristof: that line of code is under the PolyKinds extension
12:05:16 <athan> kristof: Now we can encode _any_ kinded "Tag" in a Proxy
12:05:21 <Shockk> well actually, is it possible to have sorts other than BOX at all?
12:05:27 <kristof> Shockk: not in Haskell
12:05:32 <athan> kristof: LOL
12:05:36 <dmj`> ski: Proxy :: Proxy (t :: k), you're saying 't' is not polymorphic in the same way that 'k' is here
12:05:37 <athan> check out KProxy :O
12:05:39 <athan> :P*
12:05:43 <ski> kristof : yes. i would prefer not using the same name for data constructors as for type constructors
12:05:56 <obadz> lyxia: thanks.. feels a bit odd having to write getCol i = head . M.toColumns . (M.¿ [i])
12:06:10 <athan> Shockk: Check out lambda calculi with types :)
12:06:22 <kristof> athan: I spent a bunch of time trying to figure out datakinds so now I'm all messed up
12:06:25 <ski> dmj` : there `t :: k', and `k :: BOX'. neither `t' nor `k' are polymorphic
12:06:30 <kristof> athan: Okay, tell me what i can use polykinds for ;_;
12:06:33 <Shockk> athan: I may do, thanks
12:06:47 <athan> kristof: Imagine you have a type-level list of types
12:06:52 <athan> and you want to append two of them
12:06:57 <ski> kristof : polymorphic types (like `Proxy',`Flip'), and polymorphic type classes (like `Typeable')
12:07:04 <athan> but, you don't want to be stuck using types with kind *
12:07:20 <bitemyapp> orion: oh sorry, I think I'd taken a look at it, not seen the tests pass yet, then forgot to return to it.
12:07:23 <bitemyapp> orion: thank you for the ping!
12:07:26 <athan> that would be like being stuck making list-functions only on monomorphic types
12:07:34 <ski> Shockk : "is it possible to have sorts other than BOX at all?" -- not in Haskell, afaik
12:07:48 <kristof> athan: I'm sorry, how did you get a type level list?
12:07:51 <ski> (nor in populat extensions)
12:07:53 <Shockk> kristof: you can use polykinds for things like this:
12:07:55 <athan> kristof: like having `appendInt :: [Int] -> [Int]`, `appendFloat :: [Float] -> [Float]`, etc
12:07:58 <lpaste> Shockk pasted “No title” at http://lpaste.net/6843474930940510208
12:08:03 <orion> bitemyapp: Did you see the issue associated with it?
12:08:05 <athan> kristof: DataKinds
12:08:09 <dmj`> ski: how do you define 'polymorphic' ?
12:08:21 <kristof> athan: Okay. Continue
12:08:28 <lyxia> obadz: I agree it doesn't look very nice.
12:08:33 <athan> @kind '[Int, Bool]
12:08:34 <lambdabot> [*]
12:08:42 <athan> kristof: That's a list of types
12:08:45 <dmj`> ski: for me, 'many forms', so Proxy :: Proxy (t :: k), 't' can have many forms, is that too simplistic
12:09:05 <kristof> athan: Ah, I see. So maybe you want a type level function that works on kinds other than *
12:09:12 <athan> @kind '(:)
12:09:13 <lambdabot> k -> [k] -> [k]
12:09:15 <kristof> athan: Like '[Monad, Functor, Applicative]
12:09:21 <ski> dmj` : parametrically polymorphic : a term with a `forall x. ..x..'-shaped type, which can be used as if having type `..x..', for any appropriate `x'
12:09:31 <athan> kristof: That is a list of Constraints :)
12:09:36 <kristof> shooooooooooot
12:09:49 <kristof> Well whatever, Constraints are a kind
12:10:14 <bitemyapp> kristof: they're the constraint kind >:P
12:10:18 <ski> dmj` : so, since `length :: [Int] -> Int',`length :: [(String,IO Bool)] -> Int', and indeed `length :: [T] -> Int' for any concrete type `T' at all, `length is therefore polymorphic
12:10:30 <Shockk> :k '[0, 2]
12:10:31 <lambdabot> [GHC.TypeLits.Nat]
12:10:35 <kristof> bitemyapp: right, [Constraint] :)
12:11:04 <eric_andrade> @lambdabot :t (+)
12:11:04 <lambdabot> Unknown command, try @list
12:11:05 <kristof> athan: Ok, so polykinds makes your type functions polymorphic. Got it
12:11:13 <eric_andrade> #lambdabot :t (+)
12:11:25 <athan> :k FoldR '(,) () '[Int,Bool]
12:11:27 <lambdabot>     Not in scope: type constructor or class ‘FoldR’
12:11:27 <lambdabot>     Perhaps you meant one of these:
12:11:27 <lambdabot>       ‘Fold’ (imported from Control.Lens),
12:11:32 <athan> darn
12:11:34 <ski> dmj` : similarly, since `Proxy :: * -> *',`Proxy :: (* -> *) -> *', and indeed `Proxy :: K -> *' for any concrete kind `K' at all, `Proxy' (the type) is therefore polymorphic
12:11:38 <athan> kristof: Yep :)
12:11:50 <kristof> athan: Type level lambdas are terrifying
12:12:00 <ski> dmj` : by "term" i include all of : `values',`types',`kinds',...
12:12:02 <athan> kristof: They don't exist in haskell :\
12:12:08 <athan> I wish they did, for a few circumstances
12:12:13 <kristof> athan: Isn't that what FoldR is?
12:12:25 <Shockk> kristof: this is terrifying https://hackage.haskell.org/package/polymap-0.1.1.0/docs/src/Data-PolyMap.html 
12:12:26 <athan> kristof: not at all, it's a higher-order type family :)
12:12:35 <athan> or maybe existentially quantified type idk
12:12:44 <ski> dmj` : the "type" of a value is a type. the "type" of a type is a kind. the "type" of a kind is a .. whatever you'd prefer to call that thing, perhaps a "super-kind" or something
12:12:54 <Shockk> ski: sort
12:13:01 <ski> that's sometimes used, yes
12:13:10 <ski> (and sometimes used for another purpose, iirc)
12:13:22 <kristof> athan: I try to get in with the cool kids with respect to all these language extensions but part of me wishes that I could just write one function foldr and it would work on types and data uniformly
12:13:30 <Shockk> I think sort is what I've heard it called in type theory (from a quick glance at wikipedia)
12:13:51 <eric_andrade> @kind (+)
12:13:53 <lambdabot> Not in scope: type constructor or class ‘+’
12:14:02 <athan> @let type family FoldR go init xs where; FoldR go init (x':xs) = FoldR go (go init x) xs; FoldR _ init '[] = init
12:14:02 <lambdabot>  Parse failed: Parse error: ;
12:14:04 <kristof> Not guaranteed to terminate but m, neither are turing complete languages in general.
12:14:05 <athan> blimey
12:14:05 * hackagebot sdl2-compositor 1.1 - image compositing with sdl2 - declarative style  https://hackage.haskell.org/package/sdl2-compositor-1.1 (seppeljordan)
12:14:10 <Shockk> promotion of functions to type families would be amazingly fun
12:14:33 <Shockk> functions that operate on types that are promoted to kinds, that is
12:14:34 * athan whispers in kristof's ear "Idrissssssssss :|"
12:15:02 <athan> Ain't you kids ever heard of singletons before?
12:15:15 <eric_andrade> @type (+)
12:15:16 <athan> @hackage singletons
12:15:17 <lambdabot> Num a => a -> a -> a
12:15:17 <lambdabot> http://hackage.haskell.org/package/singletons
12:15:29 <monochrom> outside haskell, people say "term :: type :: sort". inside haskell, we say "term :: type :: kind :: sort". so at once you see that "sort" alone is ambiguous, it refers to different things in different circles
12:16:00 <dolio> Who says "term :: type :: sort"?
12:16:01 <athan> monochrom: I don't think we should call BOX a sort :\ but a superkind
12:16:07 <kristof> athan: Idris wrt turing completeness or truly polymorphic functions that work on types and data and kinds and sorts and …?
12:16:20 <monochrom> but this is to be expected. "functor" already gets 3 different meanings in 3 different circles.
12:16:34 <Shockk> monochrom: ahh I see
12:16:48 <athan> sort is the strata itself - sort0 = value, sort1 = type, sort2 = kind, right?
12:17:00 <ski> @where on-functors
12:17:01 <lambdabot> "On Functors" (in C++,Standard ML,Haskell,Prolog) by Peteris Krumins in 2010-05-17 at <http://www.catonmat.net/blog/on-functors/>
12:17:16 <dolio> athan: That's a common way of saying things.
12:17:43 <Gurkenglas> What metamagic packages are actively developed/developed by someone in here?
12:17:56 <Shockk> metamagic?
12:18:04 <athan> Gurkenglas: metamorphism  :|
12:18:26 <Gurkenglas> "metamagic" is magic about magic. By saying metamagic, I hope to make clear what sort of package I mean
12:18:49 <athan> Gurkenglas: Have you seen BNFC? :)
12:21:19 <kristof> athan: So do you think all these type extensions to Haskell are kind of... pointless... and people should just adopt Idris' semantics?
12:21:40 <dolio> You can't just adopt Idris' semantics.
12:21:58 <dolio> At least if you still want anything resembling Haskell.
12:22:16 <athan> kristof: space ninjas
12:24:39 <dolio> Something more like Idris and less like automatically duplicating things at the type level would be something I'd like, though. Although the people working on things seem to think the latter are stepping stones to the former, somehow.
12:25:23 <acowley> dolio: I think we should just improve GHC's ability to operate in multiple modes. Using the standard to define both how GHC is used, and as a reference for potential Haskell compilers isn't ideal.
12:26:15 <dolio> I'm not sure what that means.
12:26:44 <dolio> You mean like, Haskell 2010 mode and Dependent Haskell mode or something?
12:26:55 <acowley> Yeah, something like that
12:27:07 <hunteriam> hey
12:27:16 <hunteriam> does anyone know how to set up vim so it can check the type of whatever im hovering
12:27:39 <Gurkenglas> https://hackage.haskell.org/package/mtl-c-0.1/docs/Control-Monad-State-CPS.html doesn't seem to cooperate with zoom from lens or hoist from mmorph. Is there a CPS'd StateT that does? When is CPS'd StateT faster than regular StateT?
12:27:54 <acowley> Some of the friction that irritates people just using the compiler can be improved by offering an improved -fglasgow-exts mechanism.
12:27:57 <dolio> I don't think the idea is that you have to transition usage to dependent Haskell. It's about transitioning the implementation to dependent Haskell.
12:28:24 <acowley> Then, people who worry about the standard being too GHC specific don't have to fight against the people who just want to improve GHC
12:28:50 <kristof> dolio: Why not? I mean, what is a type but piece of data with a tag that exists at compile time?
12:28:58 <dolio> Like, the type level stuff now is somehow a stepping stone toward making GHC able to do actual dependent types somehow.
12:28:59 <Gurkenglas> (Dangit, can't without leaving an opening for nitpickpunners say "than the regular kind", "than the regular sort", or anything of the... argh)
12:29:13 <acowley> I'm saying that the implementation has to stay configurable, because there won't be a transition to DH that doesn't break something.
12:29:55 <dolio> kristof: Idris is strict by default, with optional laziness. And their type classes are very different.
12:29:59 <acowley> We need to decouple the standard from the GHC reference manual
12:30:14 <acowley> They're killing each other
12:30:38 <acowley> For some mild-irritant version of "killing"
12:30:41 <dolio> Just as two examples.
12:31:21 <kristof> dolio: I don't know anything about Idris (I should), I'm just talking about the way it treats types.
12:31:58 <dolio> kristof: Oh. Well, inasmuch as by 'Idris' you mean, 'just do real dependent types,' then yes. :)
12:32:02 <acowley> kristof: So you're suggesting something more like an Idris backend to GHC
12:33:26 <dolio> 'Just doing real dependent types,' isn't necessarily an easy proposition on top of the rest of Haskell, of course.
12:33:27 <jle`> Gurkenglas: you could probably write your own zoom and hoist by using a combination of runState/runStateT and state from MonadState
12:33:35 <bitemyapp> acowley: that'd be a lot like the Agda -> GHC pipeline
12:33:36 <dolio> Depending on what you want.
12:33:41 <bitemyapp> acowley: and it would suck just as hard.
12:33:58 <bitemyapp> acowley: unsafeCoerce all over the place is not a recipe for well-optimized code :(
12:34:05 <bitemyapp> unless we could let it generate STG somehow.
12:34:15 <bitemyapp> that seems unlikely.
12:34:27 <dolio> Generating STG isn't a recipe for well-optimized code, either.
12:34:31 <bitemyapp> right.
12:34:45 <dolio> Because you've bypassed most of GHC's optimization phases.
12:35:01 <bitemyapp> yeah the Idris "frontend" would have to do a lot of the work itself.
12:35:12 <bitemyapp> which means you're sorta back to, "we need a mature compiler for a dependently typed language"
12:36:01 <napping> The discussion at https://ghc.haskell.org/trac/ghc/ticket/8581 has some discussion of allowing the expression side of a pattern to have any constraint that implies the provided constraints at a use site, but it doesn't seem to be implemented
12:37:01 <acowley> bitemyapp: Yeah, I'd rather let Idris experiment and grow on its own. GHC has a lot of inertia.
12:37:04 <Saizan> hey, to give credit to ghc, it actually manages to do a nice job even with all the unsafeCoerces
12:37:12 <bitemyapp> acowley: right.
12:37:39 <acowley> The point I was making was about standards and language extensions, not the dependent types stuff.
12:37:46 <bitemyapp> acowley: I really care more about getting linear typing and a heap that isn't GC'd than I would dependent types.
12:37:54 <bitemyapp> acowley: sure, sorry for contributing to hijack.
12:38:06 <bitemyapp> most of my interest in Idris centers on uniqueness typing.
12:41:18 <kristof> bitemyapp: Have you played with Rust recently? Bounded regions and all that.
12:44:06 * hackagebot polar-configfile 0.3.0.0 - Fork of ConfigFile for Polar Game Engine  https://hackage.haskell.org/package/polar-configfile-0.3.0.0 (Shockk)
12:46:11 <bitemyapp> kristof: not recently, but it's not my cup of tea.
12:58:17 <Gurkenglas> When does using CPS'd StateT give a speedup versus regular StateT?
13:03:44 <dmj`> ski: still confused how the 'kind polymorphism' mentioned in the 'giving haskell a promotion paper' isn't considered true polymorphism
13:05:14 <clrnd> why does sometimes `stack build` do nothing, even with changes?
13:05:50 <fizruk_> clrnd: perhaps you have modules not listed in your .cabal?
13:06:03 <clrnd> ohhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
13:06:05 <clrnd> :P
13:06:15 <hunteriam> how do i use cabal to install an executable into my global cabal files
13:06:19 <clrnd> extra-modules right?
13:06:23 <hunteriam> without installing its dependencies
13:06:44 <athan> clrnd: other-modules
13:06:49 <clrnd> thanks!
13:06:49 <dmj`> hunteriam: you can't w/o building it first, unless you download the binary directly for your architecture
13:06:49 <fizruk_> clrnd: exposed-modules for library, other-modules for executable
13:07:16 <dmj`> hunteriam: you can retrieve cabal install from cabal's website, or just do `cabal install cabal-install`
13:07:26 <dmj`> retrieve cabal-install *
13:07:53 <clrnd> weird, now it warns about a missing 'other-module'
13:08:03 <clrnd> wish it had done so before ¬¬
13:08:25 <dmj`> fizruk_: other-modules for library too
13:09:04 <fizruk_> dmj`: well, I prefer to use .Internal and expose it
13:09:36 <fizruk_> kinda think other-modules for libraries is evil
13:23:25 <Newbie11> test
13:23:39 <Newbie11> Hey guys
13:23:49 <Newbie11> Any opinions on haskell vs clojure for backend?
13:24:08 * hackagebot logfloat 0.13.3.3 - Log-domain floating point numbers  https://hackage.haskell.org/package/logfloat-0.13.3.3 (WrenThornton)
13:24:17 <dmj`> Newbie11: https://www.reddit.com/r/haskell/comments/3gtbzx/what_are_haskellers_critiques_of_clojure/
13:24:39 <raindev> Newbie11: probably you meant "folks" ;)
13:24:56 <Newbie11> @dmj thanks
13:24:56 <lambdabot> thanks
13:25:08 <Newbie11> raindev: ?
13:25:10 <Hafydd> Notice: "folk" is already plural.
13:25:33 <Hafydd> Perhaps you meant "people."
13:26:05 <ChristianS> Newbie11: well, since you asked here, the answer should be pretty obvious: stick with haskell :)
13:26:53 <Newbie11> ChristianS: :P My team wants to redo our backend; I'm looking into haskell and clojure as options.  Currently using js
13:29:57 <dmj`> Newbie11: I'd go with Haskell mainly because you'll have a much more pleasant time refactoring a large code base using types rather than w/o types
13:30:22 <fizruk_> Newbie11: well, I had worked with clojure backend for over a year and it was, well, not so pleasant
13:31:23 <Newbie11> dmj`: thanks.  That's a good point
13:31:32 <Newbie11> fizruk_: what didn't you like?
13:32:20 <clrnd> can I generate haddocks for my executable?
13:33:46 <dolio> clrnd: In .cabal/config, there is a section `haddock` and a setting `Executables` under that section.
13:33:47 <merijn> clrnd: What about your executable needs docs?
13:33:57 <raindev_> Newbie11: "guys" could feel exclusive for some peple, just that
13:34:07 <clrnd> dolio, I;m not using cabal
13:34:29 <clrnd> merijn, well, actually it should be a library, but I don't wanna confuse the people I;m gonna teach this
13:34:36 <dolio> You're using haddock directly?
13:34:39 <monochrom> hunteriam: build in a sandbox. copy out the exe. destroy the sandbox.
13:34:42 <clrnd> dolio, stack
13:34:52 <dolio> Oh.
13:35:02 <Newbie11> raindev_: I see; nowadays the term's used to mean both males and females though
13:35:07 <dolio> Don't know, then.
13:35:21 <clrnd> it generated all docs fine, just not my project's
13:35:24 <clrnd> :P
13:35:37 <clrnd> never done this before, documentating is boring :P
13:35:46 <orion> Is the hspec-1.12.4 package failing to build for anyone else on GHC 7.10.2?
13:35:49 <autrilla> What resources would you recommend to learn haskell? I guess most people who learn haskell already know some other programming language, so I'd say it's a given it shouldn't teach me basic stuff I already know
13:36:05 <fizruk_> Newbie11: I now have started to work on a different project and use Haskell for backend. compared to clojure I have to tune it a bit more (e.g. write types), but in turn I get more type safety, comfort refactoring and (I hope) much less errors. it has just started though, so I didn't have enough experience of it.
13:36:10 <clrnd> autrilla, https://github.com/bitemyapp/learnhaskell
13:36:18 <orion> http://lpaste.net/8792796725002633216
13:36:49 <Newbie11> fizruk_: awesome - thanks for the feedback
13:36:54 <autrilla> clrnd: thanks
13:36:56 <Newbie11> Haskell seems like the leader for me 
13:37:05 <fizruk_> Newbie11: well, absense of types hit me multiple times when refactoring even just a part of ~10K lines of clojure code
13:37:15 <raindev> Newbie11: no worries, just a kindly suggestion :)
13:37:15 <Newbie11> I'd imagine
13:37:34 <autrilla> And now, you probably get this too often around here: is haskell really useful, or is it just a theoretical language that's fun and useful to know?
13:37:48 <fizruk_> Newbie11: we also used macros in that clojure code, and we shouldn't have done that :)
13:38:39 <dolio> Really? I would think that macros are part of what make languages like clojure tolerable.
13:38:45 <raindev> fizruk_: was it a misuse or overuse?
13:39:00 <fizruk_> raindev: both
13:39:02 <merijn> autrilla: It's my default language to code in for everything from quick hacks used in shell scripts to "real" programs, so I'd say "very useful"
13:39:23 <jle`> autrilla: i use it for all my programming projects these days
13:39:25 <autrilla> merijn: professionally too?
13:39:40 <merijn> autrilla: I'd say the biggest problem is that it can take awhile to get comfortable enough to do things as fast as before :)
13:39:43 <jle`> from network projects to research projects to web projects to dana analysis
13:39:44 <fizruk_> Newbie11: OTOH, I know some guys who write microservices with clojure, they keep each service at ~500 lines and it works for them :)
13:39:46 <Shockk> autrilla: Facebook use Haskell internally
13:40:01 <jle`> it's useful in every sense that a programming language can be useful
13:40:03 <merijn> autrilla: Not at the moment, because I'm doing a lot of CUDA/GPU stuff and haskell doesn't work well for that :)
13:40:04 <Shockk> autrilla: IMVU and some other companies also do
13:40:10 <autrilla> mhm, okay, I guess I'll give it a shot!
13:40:32 <Xe> can confirm Shockk is telling the truth, am operations staff at IMVU
13:40:40 <autrilla> merijn: well, right now I kind of want to focus on research etc, so haskell will probably be a good fit
13:40:46 <dmj`> Newbie11: also, the JVM is, well... yea
13:40:46 <Newbie11> fizruk_: Refactoring will probably be a big issue for us so if it's that bad with clojure then haskell seems the better choice
13:41:13 <Newbie11> dmj`: I like the jvm :P
13:41:34 <autrilla> How well does the haskell plugin for intellij idea work? Anyone here use it?
13:41:42 <merijn> autrilla: In my experience languages like Python make it easy to use libraries and get a hacky prototype that does 70-80% of what you want, but then making it robust and adding the last 20-30% is hell. In haskell a lot of libraries tend to be very confusing and weird at first encounter, but once you "get" them, getting everything you want/making it robust is usually substantially less work in my experience
13:41:44 <fizruk_> Newbie11: yep, for monolith architecture I wouldn't consider untyped or poorly typed languages
13:42:10 <autrilla> merijn: I currently use C# and Python primarily
13:42:28 <dmj`> fizruk_: I wouldn't consider untyped or poorly typed for any architecture really
13:42:39 <raindev> Hafydd: "folk" and "folks" could be used interchangably accordingly to the dictionary. Thaks for the notice, didn't knew that
13:42:45 <fizruk_> dmj`: I am beeing tolerant :Ъ
13:43:02 <Newbie11> That makes a lot of sense
13:43:05 <Newbie11> Thanks guys
13:43:16 <Newbie11> I was looking at scala before too :D but I don't like having to rely on an iDE
13:43:32 <raindev> Newbie11: I used to like JVM as well ;)
13:43:37 <autrilla> Rely? I use IDEs because type completion makes me faster :p
13:43:41 <dmj`> Newbie11: green threads are great for web programming, multicore w/ haskell is great
13:43:43 <autrilla> code completion*
13:43:54 <josephle> autrilla, IDEs aren't the only things that have code completion
13:44:05 <autrilla> josephle: they have it out of the box
13:44:28 <fizruk_> autrilla: well, you're asking for a plugin for Haskell, so not out of the box here?
13:44:30 <raindev> and not the fastest code completion anyway
13:44:51 <autrilla> fizruk_: all of the refactoring stuff would still be there too
13:45:09 <Hafydd> raindev: which dictionary?
13:45:17 <merijn> autrilla: As an example, I wrote a massively concurrent webscraper (to dump a webcomic archive to my hard disk) in a mere 78 lines of code a few months ago, 26 of which were imports >.> (source: https://gist.github.com/merijn/d8188ddd129718ffcfb0)
13:45:27 * fizruk_ . o O ( Leksah )
13:45:41 <raindev> austrilla: not anything lies on the surface, invested effort often pays up
13:46:08 <dmj`> merijn: getNumProcessors >>= setNumCapabilities, nice
13:46:20 <merijn> (Massively concurrent enough that my first attempt without a rate limiter took the webserver down >.>)
13:46:26 <merijn> dmj`: :)
13:46:52 <raindev> Hafydd: I used OX default dictionary. Will look up what it is.
13:46:54 <dmj`> Newbie11: since you're asking on #haskell, I assume you're already leaning towards Haskell
13:46:57 <merijn> dmj`: There's many interesting gems hidden in the GHC libraries for concurrency/GHC.Prim :)
13:47:16 <Newbie11> dmj`: That is correct
13:47:20 <Hafydd> raindev: well, some mistakes get into dictionaries from common use, but I still refuse to recognise them.
13:47:49 <Hafydd> (An occurrence of a definition in a dictionary doesn't mean it's respectable to use; it just documents its existence.)
13:48:01 <raindev> Looks like Oxford Dictionary ot English
13:48:05 <dmj`> merijn: yes, was surprised to see how much of GHC.Conc was left out of Control.Concurrent
13:48:28 <dmj`> Newbie11: is this a web project?
13:48:46 <Newbie11> dmj`: yes sir.  Why do you ask?
13:50:17 <dmj`> Newbie11: just curious, there's a lot of good frameworks, might want to check out #servant
13:50:35 <dmj`> Newbie11: https://haskell-servant.github.io/
13:50:41 <Newbie11> I'll do that - thank you.
13:50:48 <raindev> Hafydd: Wikidictionary has the same position. I'm not a native speaker so, won't argue about that
13:53:51 <raindev> dmg`: that's an interesting approach for a web framework. Thanks for sharing
13:54:09 <fizruk_> Newbie11: I confirm that servant is great and becomes greater each day!
13:54:38 <dmj`> raindev: I don't think anything else really exists like it AFAIK
13:56:19 <dmj`> Since it depends on kind polymorphism, type functions, operators, literals etc.
14:24:10 * hackagebot polar-configfile 0.3.0.1 - Fork of ConfigFile for Polar Game Engine  https://hackage.haskell.org/package/polar-configfile-0.3.0.1 (Shockk)
14:34:57 <bitemyapp> cmccann: it is pretty hard for most people.
14:35:25 <bitemyapp> cmccann: I know it wasn't what you were saying, but people have a habit of saying, "but it has a great tutorial!". Errr, maybe for some but it's a brick wall for many.
14:35:45 <bitemyapp> cmccann: I'm sure there are more difficult to understand libraries. Did you have one of your own in mind when you replied?
14:36:20 <nolrai66> What has a great tutorial?
14:37:19 <bitemyapp> nolrai66: Pipes
14:38:37 <nolrai66> Ah. I have never needed to use it.
14:38:53 <cmccann> bitemyapp: is this re: reddit comments from a couple days ago?
14:39:08 <nolrai66> I've read the tutorial a few times, but without a need, not sure how much I understood.
14:39:52 <bitemyapp> cmccann: sure
14:40:28 <cmccann> bitemyapp: and no, I was going to just pick one of edwardk's more cryptic libraries but when the person I was replying to was all "oh recursion schemes aren't that bad" it kinda took the wind out of those sails
14:41:26 <cmccann> bitemyapp: at least if you're referring to the comment I think you are (?)
14:50:57 <Welkin> the pipes tutorial is great :D
14:51:27 <hunteriam> Im contributing something to open source and I have a design question
14:51:46 <hunteriam> I have the choice of abstracting over foldable, but requiring the user to input an additional argument for the length of the structure
14:51:51 <hunteriam> or just using list
14:52:04 <hunteriam> Id rather abstract but im worried itd make it less usable
14:52:17 <Welkin> why do you need a length?
14:52:29 <hunteriam> because i initialize a mutable vector of that lank
14:52:32 <hunteriam> its required for sure
14:52:38 <hunteriam> length
14:52:41 <hunteriam> *
14:52:42 <Welkin> that sounds odd
14:53:04 <Welkin> well, you could just have your own dynamically sized vector
14:53:17 <Welkin> it is much easier to just use a list
14:53:19 <hunteriam> it needs to be a mutable vector, which arent dynamically sized afaik
14:53:20 <Welkin> what is it for?
14:53:32 <Welkin> hunteriam: no, you need to implement the dynamic sizing yourself
14:53:32 <hunteriam> an algorithm to find the shortest/longest path in a directed acyclic graph
14:53:57 <hunteriam> i dont think dynamic sizing adds anything besides not needing to tell it the length
14:54:03 <hunteriam> but it costs a lot of performance presumably
14:54:06 <Welkin> exactly...
14:54:13 <Welkin> not really
14:54:24 <Welkin> you doulbe the length of the vector if it is half full
14:54:32 <hunteriam> whats the point though
14:54:35 <hunteriam> im adding log n run time
14:54:39 <hunteriam> to save an argument?
14:54:42 <Welkin> you cut the length in half if it is goes below 1/4th full
14:54:51 <hunteriam> its never going to change in size
14:55:08 <albertus1> why not coding that in a purely functional style? performance?
14:55:12 <hunteriam> yep
14:55:16 <Hijiri> what if you convert to list then convert to mutable vector
14:55:21 <Hijiri> it won't change asymptotics
14:55:39 <hunteriam> it will change real world speed though
14:55:50 <Welkin> hunteriam: you are asnwering your own question here
14:55:50 <hunteriam> it just seems icky
14:55:58 <hunteriam> well not quite
14:56:04 <hunteriam> im still not sure if i should take foldable or a list
14:56:31 <Welkin> for DAG algorithms, using a vector of lists is perfectly fine
14:56:54 <hunteriam> i dont have a vector of lists
14:57:03 <Welkin> given a representation as an adjacency list
14:57:04 <hunteriam> but youre saying i dont need to worry about abstraction?
14:57:18 <hunteriam> well this is going in fgl so im not worrying about the graph representation
14:57:31 <bitemyapp> cmccann: I don't have too hard of a time reading HT's libraries but I'm not exactly happy when I run into it either.
14:58:06 <cmccann> bitemyapp: are you, like, responding to random reddit comments of mine out of context or what? :P
14:58:16 <hunteriam> lol
15:00:22 <bollu> is this understanding of mine right? first order logic would be, like "for all s in a set S", or something. Second order could be "for all statements t which talk about 'forall s in set S'"
15:00:42 <bollu> i.e, second order logic can quantify over *statements* of first order logic
15:00:43 <bollu> ?
15:00:47 <bitemyapp> cmccann: yeah.
15:00:55 <bitemyapp> cmccann: IRC is faster than Reddit.
15:01:02 <hpc> bollu: i believe so
15:01:02 <bitemyapp> cmccann: sorry. HT's stuff had been on my mind lately anyway.
15:01:13 <cmccann> bitemyapp: ...any reason why? <_<
15:01:15 <bollu> hpc: cool, ty :)
15:01:21 <hpc> bollu: compare rank-2 types as well, which should be a similar deal
15:01:31 <cmccann> for reading through my comments, that is.
15:01:40 <tomus>  > zipWith (\a b -> if b == Nothing then Nothing else Just a) [(1, 2), (3, 4)] [Nothing, Just 3]
15:02:11 <tomus>  > zipWith (\a b -> if b == Nothing then Nothing else Just a) [(1, 2), (3, 4)] [Nothing, Just 3]
15:02:21 <tomus> hm. anyway, better way to write ^
15:02:29 <bitemyapp> cmccann: I was reading a thread you happened to be active in.
15:02:33 <bitemyapp> cmccann: brain fried, so reading.
15:02:41 <bollu> > zipWith (\a b -> if b == Nothing then Nothing else Just a) [(1, 2), (3, 4)] [Nothing, Just 3]
15:02:43 <lambdabot>  [Nothing,Just (3,4)]
15:02:44 <bitemyapp> cmccann: you were the only one that said anything worth replying to.
15:02:53 <cmccann> bitemyapp: anyway tbh I could see the appeal of the Henning.T naming scheme if only the tools (i.e. haddock handled it) and existing convention weren't almost unanimously against it
15:03:03 <bollu> tomus: you need to have zero space before the ">" and then a space after the ">"
15:03:17 <tomus> thanks
15:03:20 <bitemyapp> cmccann: that's partly why I've been musing on it. It has an appeal.
15:03:27 <bitemyapp> cmccann: I try to get people to move toward a middle way.
15:03:33 <cmccann> I gather it's a thing some MLs do?
15:03:37 <bitemyapp> cmccann: ModuleName.SubjectOfModuleName
15:03:46 <bitemyapp> cmccann: er, pretty much all of them.
15:03:52 <bollu> > zipWith (\a b -> b <|> pure a) [(1, 2), (3, 4)] [Nothing, Just 1]
15:03:54 <lambdabot>      No instance for (Show t0)
15:03:54 <lambdabot>        arising from a use of ‘show_M80819146469495744102359’
15:03:54 <lambdabot>      The type variable ‘t0’ is ambiguous
15:04:03 <bollu> um, that's weird
15:04:13 <bollu> zipWith (\a b -> b <|> Just a) [(1, 2), (3, 4)] [Nothing, Just 1]
15:04:17 <bitemyapp> cmccann: you have multiple modules per file, the modules themselves are sort of the atomic unit of code in some cases.
15:04:18 <bollu> > zipWith (\a b -> b <|> Just a) [(1, 2), (3, 4)] [Nothing, Just 1]
15:04:20 <lambdabot>      No instance for (Show t0)
15:04:20 <lambdabot>        arising from a use of ‘show_M3282223690831575352382’
15:04:20 <lambdabot>      The type variable ‘t0’ is ambiguous
15:04:27 <bollu> what does it not have an instance of?
15:04:38 <bitemyapp> cmccann: so you introduce single letter types, etc. and the module name "names" things rather than its contents.
15:04:40 <cmccann> bitemyapp: well, the only ML dialect I've really done anything with is F# and since C# is my day job I had a lot of preconceived notions there
15:04:56 <bitemyapp> cmccann: F# isn't really going to show you any of this since it doesn't have modules, yeah.
15:05:14 <bitemyapp> cmccann: the middle-way I try to encourage is to avoid prefixing data constructors and type constructors.
15:05:23 <bitemyapp> cmccann: like, don't name something StripeCreditCard
15:05:33 <bitemyapp> instead: Network.Stripe.CreditCard
15:05:41 <bitemyapp> (module is Stripe, type constructor is CreditCard)
15:06:02 <cmccann> bitemyapp: yeah
15:06:17 <ephrion> so if one were so inclined to define a `type Dual f a = Free (Cofree f) a` or `type Luad f a = Cofree (Free f) a`, would they form anything particularly intreesting?
15:07:14 <bitemyapp> cmccann: I don't think going full HT would be a win, but people need to stop polluting their names with context that could be part of the module path instead to avoid name-clashes.
15:07:19 <cmccann> bitemyapp: my rule of thumb is to only prefix or modify names like that if it says something meaningful not implied by the module name
15:07:23 <bitemyapp> cmccann: you avoid name-clashes by doing a qualified import dammit.
15:07:29 <bitemyapp> cmccann: *nod*
15:08:44 <shachaf> ephrion: The free monad on the (underlying functor of the) cofree comonad of a functor? Any reason to expect it to?
15:09:59 <ephrion> shachaf: Not particularly! I've been enjoying playing around with the co/free co/monad stuff quite a bit, and was wondering if someone else had already explored this
15:10:44 <bitemyapp> ephrion: if you want to win his heart, say it was a scow idea.
15:11:20 <cmccann> bitemyapp: speaking of which, here's one to ponder. since the modules are intended to be imported qualified anyway, why are the types IntMap and IntSet not named Map and Set?
15:12:16 * cmccann sees that bitemyapp has become quite fluent in shachafese
15:12:49 <bitemyapp> cmccann: Int.Map vs. IntMap or just...Map?
15:13:09 <bitemyapp> cmccann: IntMap somehow makes sense here because it defines what the thing _is_, rather than describing a context.
15:13:16 <bitemyapp> to me, anyway. Ditto HashMap.
15:13:20 * ephrion googles for scow ideas, finds boating information
15:13:36 <cmccann> HashMap seems even less persuasive
15:14:09 <cmccann> at least with IntMap there's the argument that it isn't parameterized by key type
15:14:21 <bitemyapp> cmccann: less persuasive toward?
15:14:24 <ReinH> cmccann: o/
15:14:42 <cmccann> HashMap vs. Data.Map.Map is basically an implementation detail
15:15:01 <ski> bollu : i don't think se
15:15:26 <bollu> ski: for second order?
15:15:30 <cmccann> bitemyapp: toward the type not just being Data.HashMap.Map, naming it HashMap says nothing not implied directly by the module name
15:15:38 <cmccann> and you'll almost always import it qualified anyway
15:16:00 <bitemyapp> cmccann: Data.HashMap.Strict.HashMap does seem a bit...redundant.
15:16:04 <ski> bollu : yes
15:16:13 <bitemyapp> cmccann: probably to avoid confusion, I would guess.
15:16:35 <bitemyapp> cmccann: that's actually the problem with Henning's style, if you don't qualify _everything_ you'll get some really confusing type errors.
15:16:38 <cmccann> oh yeah, forgot about the strict vs. lazy. it's the same type anyway, though.
15:16:55 <bollu> ski: so what would second order logic be?
15:17:49 <cmccann> bitemyapp: anyway, I brought it up because I'm not sure which I'd really prefer there. strictly speaking the prefixed "*Map" names are redundant, but it is saying something about what the type is, not just where it's from
15:17:58 <ski> bollu : second order would be "for all subsets `S' of `T', ..`S'.." or "for all functions `f : T >---> U', ..`f'.." or "for all predicates `P' on `T', ..`P'.." or "for all propositions `P', ..`P'.."
15:18:24 <bollu> ski: while the first order of those would be?
15:18:46 <nolrai66> bollu: I think things like, forall properties P, if P(0) is true, and P(n) -> P(n+1) then forall n, P(n).
15:18:57 <nolrai66> WOudl be second order..
15:19:01 <cmccann> if it were me these days writing a new library I'd probably use Map/Set for the unordered containers ones but retain IntMap/IntSet on account of being less parameterized
15:19:14 <bollu> because you're quantifying over the properties themselves?
15:19:57 <nolrai66> bollu: Yes.
15:20:07 <bollu> 	hm, ty
15:20:38 <ski> bollu : "the first order of" is nonsense
15:21:28 <bollu> ski: well, what I  meant was, if you "weakened" them to first order logic to draw a semi-related statement, what would ie be like?
15:21:29 <bollu> it*
15:21:45 <ski> bollu : first-order quantifies over individuals. second-order quantifies over (first-order) functions and predicates, as well (and also over propositions, as a degenerate case of predicates)
15:22:45 <bollu> ski: ah, okay. I think that makes it clear
15:22:47 <ski> bollu : unary predicates correspond to subset, so quantifying over subsets (iow over elements of a powerset) counts as second-order. and you can implement functions using powersets
15:23:10 <bollu> ski: so set builder notation is second order?
15:23:17 <bollu> or am I missing something vital here?
15:23:48 <ski> bollu : a logic that only allows quantification over propositions, but not individuals, predicates, and functions, is possible. here the "`n'-th order" terminology breaks down a bit, since this is really a different concern
15:24:03 <ski> bollu : it can be
15:24:36 <bollu> ski: can I have an example of a set built using first order predicates and one built using second order predicates if it is not too much trouble? :)
15:24:54 <ski> bollu : ZF is formulated as a first-order theory, though (with which one can simulate higher-order, by encoding stuff as the individuals of the theory (known as "sets"))
15:25:34 <bollu> ski: I'm not super familiar with the foundational aspects of set theory, unfortunately :(
15:25:56 <bollu> ski: so stuff like AoC and different axiomatisations of set theory sort of lose context
15:26:16 * ski thinks ZF is a bit silly anyway
15:27:27 <ski> (in a similar sense to Hilbert-style proofs. it can be useful to reason *about*, but it's hardly usable for reasoning *in*)
15:27:43 <bollu> :)
15:28:06 <bollu> ski: even so, like I asked, can I have two examples of sets?
15:28:18 <ski> i'm not quite sure what you're looking for
15:29:02 <bollu> ski: I want two sets, one built using first order logic stuff, the other built using second order logic stuff
15:29:07 <bollu> just so I can compare them
15:29:36 <nolrai66> You need second order logic to rule out non-standard naturals.
15:30:21 <nolrai66> I think..
15:30:50 <bollu> non standard naturals are..?
15:31:25 <ski> bollu : in plain first-order logic, there are no sets
15:31:35 <bollu> ski: okay, why?
15:31:48 <ski> bollu : perhaps you're wanting some first-order set theory
15:31:54 <bollu> 	yeah
15:31:58 <bollu> I do
15:32:01 <ski> why ? well, first-order logic is meant to be more general than that
15:32:28 <bollu> oh, wait, so.. first order logic is more "powerful" than sets?
15:32:29 <ski> you can formulate the group axioms in first-order logic, and then go on to prove theorems which are valid in every group
15:32:40 <ski> no need to talk about sets to be able to do that
15:33:05 <ski> or you could formulate say projective geometry
15:33:21 <ski> bollu : not more powerful, really
15:34:02 <nolrai66> Bollu: naturals that the principle of inductiond does not apply to.
15:34:03 <ski> bollu : however, you can represent a set by a formula with a free variable
15:34:29 <bollu> ski: example of such a set..?
15:34:35 <ski> bollu : in that sense, i suppose you could talk about `{x : T | forall y : T. x =< y => P(y)}' respectively `{x : T | forall P : T >---> Prop. P(\y |-> x =< y => P(y))}', maybe ?
15:34:54 <ski> where `T' is any type/sort
15:35:40 <bollu> ski: you lost me. I need more education :) I'll go read up on this and get back to you?
15:36:18 <ski> (i suppose i shouldn't really be mentioning types/sorts in there at all, if this is going to be something in the usual first-order logic in books .. however, i think it's a bit silly to not use a multi-sorted logic, if you have any individuals at all)
15:37:16 <ski> bollu : `forall y : T. x =< y => P(y)' is a formula that holds for all the `x's such that everything that is at least as large as `x' has the property `P'
15:37:53 <bollu> ah
15:38:27 <bollu> ski:  is this equivalent? {x | forall x : T, forall y : T. x =< y => P(y)}
15:38:41 <bollu> like, I've never seen people "pick" on the left side of the |
15:38:45 <ski> bollu : while `exists y : T. x =< y /\ P(y)' would hold for all the `x's such that there is at least one `y', at least as large as `x', that has the property `P'
15:39:11 <ski> bollu : no
15:39:28 <bollu> ski: the difference is?
15:39:41 <ski> bollu : in that case, the `x' on the left side of `|' can't be the same as the `x' on the right, since the right is bound (quantified by `forall')
15:40:08 <ski> it's like if you say in Haskell `x + (let x = 3 in x*y)', the first `x' is not the same as the latter `x's
15:40:33 <ski> the first `x' is whatever `x' is in scope. the latter is the locally bound variable, bound to `3'
15:40:36 <bollu> ski: but, like, don't we say things like {x | x \in I, -10 < x < 10 } ?
15:41:02 <ski> there is no `forall' for `x' on the right of `|' there
15:41:13 <ski> (nor any `exists' for it)
15:41:15 <bollu> ski: oh, wow
15:41:29 <bollu> {x | x \in I, -10 < x < 10} /= {x | forall x \in I, -10 < x < 10 }
15:41:33 <bollu> ?
15:41:41 <ski> yes
15:41:44 <bollu> if so, what is the difference between the LHS and the RHS?
15:41:47 <bollu> I never knew that :O
15:42:41 <nolrai66> Well the second one is just nonsensical.
15:42:58 <ski> the left of `|' mentions the "template", the "generic element" for which all possibly instantiations of it that satisfies the condition to the right of the `|', are "added" to the set
15:43:45 <ski> in `{(x,y) | x =< y}' we're expressing the set that contains all the pairs of the shape `(x,y)', satisfying `x =< y'
15:44:27 <ski> (`x' and `y' should be taken from some "universe (of discourse)"/"domain" set(s). above it was implicit which set that was. perhaps i meant the set of real numbers)
15:45:08 <ski> one could specify `{(x,y) : |N * |N | x =< y}', if one wanted to emphasize that we're only considering natural numbers `x', and `y'
15:45:42 <ski> (so thise set will be a subset of the set `|N * |N', the cartesian product of the set of natural numbers with itself, the set of all pairs of two natural numbers)
15:46:13 <ski> nolrai66 : .. or at least as confusing as `x + (let x = 3 in x*y)'
15:46:17 <bollu> ski: so, well
15:46:21 <bollu> ski: hm
15:46:29 <ski> btw, there's two different senses of `\in' in math
15:46:35 <bollu> ski: okay, do tell
15:46:41 <ski> here i was using `:' for one of them, instead of `\in'
15:47:28 <bollu> ski: and the second usage?
15:48:30 <ski> `x : T' is used to declare that `x' is an inhabitant of the set/type/sort `T'. `x : T' is not something that can be asked whether it's true or not. either `x' is *given* to you as an inhabitant of `T', or it isn't
15:49:02 <bollu> huh
15:49:18 <bollu> ski: so the left side of the | will be picking, and the right side will be "filtering" ?
15:49:32 <ski> `x \in S' is used to express the proposition that `x' happens to be an element of `S' (which must be a subset of `T', which is the type of `x'). `x \in S' may be true, or it may be false
15:50:09 <c_wraith> It's the same as the difference between = and == in many programming languages 
15:50:27 <orion> Is it an anti-pattern for a library to define a record type containing a slew of functions (like encrypt, decrypt, hmac, etc), and to have the end-user define/provide those functions?
15:50:37 <bollu> wow, okay, so this is blowing my mind right now
15:50:46 <bollu> TIL I don't understand set builder notation
15:50:51 <c_wraith> orion: no, that's a common approach. 
15:51:22 <bollu> so, {x \in I | x < 10} is correct? 
15:51:33 <bollu> while {x | x \in I, x < 10} is not?
15:51:41 <ski> instead of saying `P(y)' above (thinking of `P' as a property/predicate on values `y' in a type `T'), i could have said `y \in S', where `S' is the subset that corresponds to the property `P' (iow `S = {y : T | P(y)}. also `forall y : T. (P(y) <=> y \in S)')
15:51:55 <glguy> osa1: You around?
15:52:21 <orion> c_wraith: Awesome. Am I correct in stating that as a consequence of this design, I'm going to need a common type to shuttle data between the library-application boundary, such as ByteString?
15:52:33 <ski> so one could say `{x : T | forall y : T. x =< y => y \in S}', but `{x : T | forall y : T. x =< y => y : S}' would be nonsense, since `y : S' is not a proposition, you can't "test it"
15:53:03 <bollu> wow, huh
15:53:32 <ski> bollu : if `I' is a subset (of the set/type of `x'), then `{x | x \in I, x < 10}' is correct
15:53:41 <c_wraith> orion: depends on the functions. Sometimes you need concrete types, sometimes you don't. 
15:53:49 <orion> True, ok. Thank you.
15:54:24 <ski> if `I' is a set/type, then `{x : I | x < 10}' is correct. i'd say `{x \in I | x < 10}' is not correct, but note that most mathematicians would use `\in' both for what i'm writing as `:' and what i'm writing as `\in' here
15:54:26 <bollu> ski: but how do I know what x _is_ in that case?
15:54:54 <ski> bollu : in which example ?
15:54:55 <bollu> `{x | x \in I, x < 10}' <— what is "x" ? It doesn't "belong" to anything
15:55:15 <bollu> ski: also, one more question: {x : R | x \in Q} == Q?
15:55:21 <ski> bollu : you have to use some "type inference" (possibly augmented by hints from the context in the mathematical text you're reading)
15:55:51 <ski> bollu : in some context, `{x | x \in I, x < 10}' might be short for `{x : |R | x \in I, x < 10}', `|R' being the set of real numbers
15:56:13 <bollu> ski: right, but, excluding all "global context", that structure is wrong?
15:56:25 <ski> bollu : yes, `{x : |R | x \in |Q} = |Q' is the eta-rule for subsets
15:56:40 <ski> bollu : ambiguous
15:57:15 <bollu> ski: so, if I'm getting this right, the LHS is like picking, while the right hand side is like filter
15:57:41 <bollu> so a \in on the left hand side just "picks everything" from the set, while a \in on the right hand side "sieves" all the stuff through the set?
15:57:54 <ski> bollu : i'm not quite sure what you mean by "picking"
15:58:19 <ski> bollu : i'm not sure if you include the `x \in I' part of `{x : |R | x \in I, x < 10}' in "picking" or not
15:58:25 <ski> bollu : if not, then yes
15:58:34 <bollu> ski: nope, that's not the picking
15:58:49 <bollu> ski: huh, thanks a ton, I didn't know that it was how set builder worked
15:58:54 <bollu> thanks :)
15:59:10 <ski> "so a \in on the left hand side just "picks everything" from the set, while a \in on the right hand side "sieves" all the stuff through the set?" sounds right .. except i'd not write `\in' "on the left"
15:59:11 <bollu> I might have to track down someone on #math and correct what I explained to them wrong the day before
15:59:21 <bollu> damn, I feel bad now :(
15:59:28 <bollu> ski: you would use ":" ?
15:59:52 <bollu> ski: I might have inflicted my messed up understanding on someone else. What do I do?
16:00:08 <ReinH> bollu: (It works pretty similarly to list comprehensions, btw)
16:00:12 <ski> bollu : what i'm calling sets/types/sorts here are called "structural sets", and what i'm calling subsets here are called "material sets" at <https://golem.ph.utexas.edu/category/2013/01/from_set_theory_to_type_theory.html>
16:00:20 <ReinH> Or rather the other way around, since list comprehensions were inspired by set builder notation.
16:00:27 <ski> bollu : you can skip down to the part where it starts talking about material and structural sets
16:00:29 <bollu> ReinH: oh wow, yeah, you're right
16:00:40 <ski> bollu : i would use `:', yes. at least personally
16:00:43 <bollu> ski: ty
16:01:01 <ski> (another matter if i need to communicate with someone who doesn't clearly appreciate the distinction, or doesn't know that notation)
16:01:58 <ski> bollu : "I might have inflicted my messed up understanding on someone else. What do I do?" -- don't worry, probably most of math has at least somewhat muddy understanding of this issue ;)
16:02:34 <bollu> ski: hahaha, that makes me feel better :)
16:02:46 <ski> bollu : btw, note that there's also two difference senses of being a subset that comes with this
16:03:09 <bollu> one which picks a subset and one that queries?
16:03:57 <ski> bollu : the first is declaring that something (say `x') is an element of the powerset of `T'. this amounts to declaring that `x' (or `S', if you prefer) is a subset of `T'. this is not something that can be asked, it's not a proposition
16:04:45 <bollu> right. While the other queries if S is an element of the powerset of T?
16:04:45 <ski> bollu : otoh, if `S0' and `S1' are already declared as being subsets of `T', *then* you can *ask* whether `S0' is a subset of `S1' (meaning that every inhabitant `x' of `T' that happens to be an element of `S0' is actually also an element of `S1')
16:05:32 <ski> so, the first is declaring that the elements of `S' are (some) inhabitants of `T'
16:06:06 <ski> while the second is expressing the situation that all inhabitants of `T' that happens to be elements of `S0' are actually also elements of `S1'
16:06:27 <bollu> right...
16:08:05 <ski> (you might note that i'm using the term "inhabitant" here exclusively as relating a value to a type it belongs to (being declared as being from, being given as an .. inhabitant of), while i'm using the term "element" here exclusively to express the proposition, the state-of-affairs, that some value `x' (being of type `T') belongs to a subset `S' (likewise of `T'))
16:09:31 <ski> now, it's often useful to be able to *treat* every subset `S' of a type `T' as if it were a type on its own. this is known as subtyping. using this, `{x : I | x < 10}' would be sensible
16:10:08 <bollu> ski: you lost me there (I don't see how that is an example of subtyping)
16:11:58 <ski> if `I' is a subset of the type of real numbers, `|R', e.g. the subset `{x : |R | 2 =< x /\ x < 5}', then it doesn't follow that `y : I' is sensible, only that `y \in I' is sensible (given than we know the declaration `y : |R', that `y' is given to us as a real number)
16:13:04 <bollu> ski: where did "y" come from?
16:13:04 <ski> however, using subtyping, every subset of a type (like `|R') can itself be considered a type, and so `y : I' would be sensible, and so also `{x : I | x < 10}'
16:14:01 <ski> `y' was just any value (of the right type) that happened to be in scope (brought in scope by the declaration `y : |R', namely), for the sake of discussion
16:14:10 <bollu> sh
16:14:12 <bollu> ah*
16:14:46 <bollu> oh, so you're saying that if I have subtyping, then I can construct a subset of an existing type, and then treat the subset as a "new type" as it were?
16:14:48 <ski> (one can also treat every "quotient set" of a type as if it were a type of its own)
16:14:59 <ski> yes
16:15:03 <bollu> ski: isn't that very natural, though?
16:15:18 <ski> people do it all the time in math, yes
16:15:19 <bollu> how would you even go about constructing pretty complex things without that property?
16:15:42 <bollu> I guess you could chain predicates together
16:15:44 <ski> well, you can form cartesian product, disjoint union, exponential, without touching subsets
16:16:35 <bollu> ski: hm, yeah, I guess
16:16:54 <ski> in math, as commonly considered, it makes sense to ask `x = y', for any values `x' and `y' whatsoever
16:17:19 <ski> in this setting i'm describing here, it only makes sense to ask `x = y' in case both `x' and `y' are inhabitants of the same type
16:17:49 <bollu> right, because things are associated with a type themselves
16:18:02 <ski> therefore, it doesn't make sense to form union and intersection of any two (sub)sets you like, they have to be "declared" as subsets of the same type
16:18:49 <bollu> oh, right, because then the union would have things of two different types
16:18:55 <bollu> ski: or you could create a sum type?
16:18:57 <ski> (ZF is notorious for treating every pair of sets as subset of some common larger set)
16:19:12 <bollu> and say the elements of the union inhabit the sum type
16:19:13 <bollu> ?
16:19:35 <ski> you can create sum type / disjoint/discriminated union / coproduct of any two types
16:20:38 <bollu> ski: I'm gonna crash, but you've given me a lot to think and read abou
16:20:41 <ski> e.g. the disjoint sum of `|R' and `|R', `|R + |R', contains two "copies" of each real number (labelled/tagged so as to distinguish them from each other)
16:20:52 <bollu> what? that is weird
16:21:05 <bollu> well, makes sense
16:21:06 <bollu> but.. weird
16:21:45 <bollu> I'll get back to you once I read the article and play with what you told m
16:21:47 <bollu> me*
16:21:51 <bollu> night, everyone :)
16:21:59 <ski> if you really wanted to identify some of the elements of the two types, when "unioning" them together, then you must explicitly say *which* elements should be considered equal, by using another type and two injections from it to the two previous types. this is called pushout, or amalgamation
16:22:04 <ski> (see category theory)
16:22:36 <nolrai66> Hmm.
16:22:39 <ski> bollu : in terms of Haskell, `|R + |R' is `Either Real Real', with elements `x' of `Real' tagged as `Left x' and `Right x'
16:22:56 <ski> bollu : night
16:22:58 <bollu> ski: oh, that helps to give me a much more intuitive feel for it
16:23:04 <nolrai66> I thought ZF let you do everything as just generic sets?
16:23:04 <bollu> and |R x |R is (R, R) ?
16:23:08 <ski> yes
16:23:18 <ski> and `A^B' is `B -> A'
16:23:25 <ski> (that's the "exponential")
16:23:48 <bollu> ski: what are the elements of A^B?
16:23:55 <ski> (however, the Haskell notation for product types isn't really good, since it overloads the tuple notation)
16:24:03 <ski> bollu : the functions from `B' to `A'
16:24:14 <bollu> ski: no, but, how does that parallel to exponentiation?
16:24:35 <ski> e.g. the elements of `Real^Bool' are the functions from `Bool' to `Real'. they are essentialy pairs of `Real's, one for `False', and one for `True'
16:24:49 <ski> think of `Bool' as `2', and `Real^Bool' becomes `|R^2'
16:24:56 <prophile> A^1 = A, A^0 = 1, (A^B)^C = A^(B*C), 1^A = 1
16:24:58 <shachaf> i,i and one for _|_
16:25:01 <bollu> ski: so, A^|B| ?
16:25:10 <arahael> Well, Project Euler Problem 2 (The fibonacci one) was fascinating.
16:25:21 <ski> in the finite case, if `M' has `m' elements, and `N' has `n' elements, then `M^N' has `m^n' elements
16:25:44 <arahael> Spent way too much time on that - I was mystified that the fib sequence there was 1, 2, 3, 5...  I was under the impression it was 1, 1, 2, 3, 5...
16:25:44 <ski> shachaf : hehe
16:26:04 <ski> arahael : it is `[0,1,1,2,3,5,...]'
16:26:20 <arahael> ski: Apparently that isn't more correct.
16:26:21 <shachaf> ski: We were just talking in #-lens about how to count how many functions : Bool -> Bool there are.
16:26:25 <nolrai66> Well you can start it where ever.
16:26:30 <nolrai66> It even goes negative.
16:26:32 <bollu> ski: well, technically, the sequence would depend on what you seed it with, right?
16:26:33 <shachaf> I vaguely remember that there was some trick for it, maybe something topological.
16:26:37 <shachaf> But I don't remember what it was.
16:26:38 <slikts> is avoiding variadic functions a thing?
16:26:39 <arahael> ski: Turns out you can start it wherever you like.
16:26:59 <arahael> bollu: No, you still need to seed it with fib numbers, if the algo you use depends on seeding.
16:27:10 <bollu> arahael: ah, right
16:27:19 <arahael> Most of the generators that compute negative fib numbers seem to use the matrix algorithms.
16:27:20 <ski> bollu : yes, but seeing as you can extend it in both directions, and as it's (normally) more natural to start indexing/counting at `0' than `1', i think the `[0,1,1,2,3,5,...]' is more natural
16:27:30 <Welkin> you seed it with 0 and 1
16:27:33 <ski> arahael : yes, i know
16:27:43 <arahael> Anywya, I thought that was fascinating.
16:28:04 <bollu> I love the solve recurrence relations using lin alg technique
16:28:07 <bollu> so, so slick
16:28:49 <ski> bollu : anyway, prophile mentioned some simple useful algebraic laws for reasoning about sets/types
16:28:59 <bollu> ski: where?
16:29:06 <ski> four minutes ago
16:29:14 * hackagebot pqueue 1.3.1 - Reliable, persistent, fast priority queues.  https://hackage.haskell.org/package/pqueue-1.3.1 (lspitzner)
16:29:47 <bollu> huh, I don't see "prophile" anywhere?
16:29:58 * prophile questions his own existence
16:30:04 <bollu> :)
16:30:12 <bollu> I mean, I can't find your answers
16:30:14 <prophile> <prophile> A^1 = A, A^0 = 1, (A^B)^C = A^(B*C), 1^A = 1
16:30:26 <prophile> laws that work both for numbers and types
16:30:43 <carrotlord> > let constant = 34
16:30:45 <lambdabot>  <no location info>: not an expression: ‘let constant = 34’
16:30:45 <ski>   A^(B+C) = (A^B)*(A^C)
16:30:52 <bollu> ohh
16:30:53 <bollu> ty
16:31:05 <carrotlord> :t [34]
16:31:06 <lambdabot> Num t => [t]
16:31:18 <ski> carrotlord : use `@let'. also do it privately, unless you specifically want to show something to the channel
16:38:28 <ReinH> Also please don't redefine commonly used identifiers like "id"
16:45:45 <ski> shachaf : bottoms could come later in the propaganada/indoctrination
16:47:25 <arahael> Seems the euler problems take _forever_, because I keep having to revisit, relearn, and research all the various fascinating maths problems that I've forgotten about from school. :)
16:47:27 <arahael> Memories.
16:50:51 <nolrai66> I got board of them around 40 or so.
16:52:21 <eitanChatav> Is it possible to define type families using GHC.Generic?
16:52:25 <arahael> nolrai66: I'm only doing them to help assist with learning haskell.
16:52:41 <arahael> nolrai66: It's a good source of toy problems.
16:52:58 <nolrai66> nolrai66: That was my use too.
16:53:00 <nolrai66> ..
16:53:08 <nolrai66> arahael: That was my use too.
16:53:09 <Welkin> it will not help you learn haskell
16:53:10 <Welkin> haha
16:53:29 <nolrai66> They did, but only up to about 20 or so.
16:53:48 <nolrai66> After that the /programing/ side of things became very repetative.
16:53:54 <nolrai66> If that makes sense.
16:53:57 <arahael> I expect that will be the case.
16:54:10 <arahael> I'll probably move into larger games then.  Such as tic tac toe.
16:54:20 <Welkin> arahael: build a web application
16:54:27 <arahael> I doubt I'll do more than just 10 problems.
16:54:33 <Welkin> that helped me learn very quickly
16:54:44 <nolrai66> Tic Tac Toe is fun.
16:55:03 <arahael> Welkin: And contend with monad transformers, while still figuring out the syntax - parens placement, $'s, composition, etcetera? No thanks.
16:55:16 <Welkin> arahael: yes
16:55:23 <Welkin> it forced me to learn quickly
16:55:30 <Welkin> because I wanted to build the application
16:55:39 <Welkin> it was great fun
16:55:43 <arahael> Welkin: Ah, about that. I don't have an idea for an "Application" yet either.
16:55:49 <Welkin> I started with yesod, but you can start with something very simple like scotty
16:56:05 <arahael> And frankly, I only want to spend tiny amounts of time on it.
16:56:35 <hunteriam> https://www.irccloud.com/pastebin/zz17M4HE/help
16:56:39 <hunteriam> what does this error mean
16:56:49 <hunteriam> i think the random unicode can be safely ignored, by the way
16:56:51 <Welkin> the cis194 and nicta courses are good starting points before doing your own project
16:56:51 <eitanChatav> Is it possible to define type families using GHC.Generics?
16:58:11 <arahael> Welkin: Yeah, they look good, too.
16:58:21 <arahael> Welkin: But more involved - and haskell specific.
16:58:30 <athan> eitanChatav: AFAIK, GHC Generics are for the underlying sums-of-products structure of values :\
16:59:41 <eitanChatav> athan: Yes, given that I have a `type instance` for all the constituent types in a sum of products, I want to define a `type instance` for the total type. Is this possible?
17:00:20 <nolrai66> eitanChatav: That is exactly what generics are for.
17:00:50 <eitanChatav> nolrai66: I've never seen examples of generics used to define type families. Can you point me to an example?
17:01:55 <nolrai66> ..Wait what do you mean by "type instance".
17:02:03 <nolrai66> Sorry I might have miss read you.
17:02:33 <eitanChatav> like `type family C a; type instance C Int = CInt`
17:03:22 <hunteriam> https://www.irccloud.com/pastebin/35c8Tn8U/
17:03:25 <hunteriam> what is a3??
17:03:33 <hunteriam> it says i need Ord a3 but wtf is a3?
17:05:11 <hunteriam> i dont think its possible for me to figure this out..
17:05:13 <hunteriam> sigh
17:06:15 <hunteriam> i was wrong
17:07:03 <rhovland> a3 is just something it sticks in to distinguish the a's... a1,a2,a3
17:07:37 <geekosaur> usually it means it couldn't unify some types you thought it would; would have to see the code along with the error to try to figure it out
17:08:34 <lispy> hunteriam: I think it's saying it doesn't know which instance of Ord to use for that (<)
17:08:45 <lispy> hunteriam: Can you add a type annotation there?
17:09:15 <rhovland> hunteriam: looks like you want {-# LANGUAGE ScopedTypeVariables #-} and stick forall a. on the type signature
17:12:01 <infandum> I had an urge to contribute to some open source projects recently and with the oncoming of hacktoberfest I think it's a perfect time to ask: what projects can I contribute to? I've never done this before and I don't want to be too overwhelmed by the existing codebase...
17:13:27 <orion> Is the "qualified" keyword optional?
17:13:45 <orion> https://github.com/vincenthz/cryptonite/blob/master/tests/Imports.hs <-- I see this guy not providing it.
17:14:34 <hpc> "import Foo" brings all the stuff in Foo into scope
17:14:44 <hpc> "import qualified Foo" brings it into scope as Foo.whatever
17:15:12 <hpc> "import qualified Foo as F" brings it into scope as F.whatever
17:15:23 <nolrai66> So I have a generator for partitions of an number as Int -> Gen [Int], but am having trouble getting useful test information out of quickCheck.
17:16:04 <orion> hpc: What about "import Foo as F"?
17:16:52 <nolrai66> orion: Same as using both "import Foo" and "import qualified Foo as F" basickly.
17:17:06 <rhovland> b
17:17:20 <orion> Interesting,.
17:17:30 <orion> nolrai66: simultaneously?
17:17:35 <rhovland> any time I've done it it's been a mistake
17:18:19 <nolrai66> It can be useful when there are a couple of terms that are in more then on module.
17:18:34 <nolrai66> You can use the qualified form to disambiguate.
17:18:44 <lispy> infandum: I think your question hits on something we should make more of an effort to do
17:19:09 <lispy> infandum: make an effort to mark bugs/issues in the various trackers as "Mentored" or "Easy" so people like you know where they can get a start
17:19:47 <lispy> infandum: I think GHC itself does this, and darcs does, but I don't know off the top of my head if any other projects do
17:24:44 <infandum> lispy: Yeah, there should be a database of issues with different tags on them based on different aspects of each request
17:25:50 <hpc> orion: a good example would be if you're using Data.Map and Data.Set at the same time, which have some of the same stuff
17:26:08 <hpc> it's a pain to go M.Map foo bar everywhere, so import Data.Map as M and import Data.Set as S
17:26:15 <hpc> then use S.fromList and M.fromList exclusively
17:26:30 <hpc> the compiler will let you know if you use just fromList, which is ambiguous
17:28:40 <osa1> glguy: hey
17:33:25 <osa1> glguy: why don't you reply to the mail thread? d:
17:37:28 <hpc> i can't believe it's taken me this long to get around to trying out ixset
18:14:14 <hunteriam> is there a version of maybe where Just x > Nothing AND Just x < Nothing
18:14:18 <hunteriam> presumably not, right?
18:14:23 <bz> is there an unboxed version of ioref?
18:15:49 <athan> hunteriam: Something like Data.Semigroup.Option?
18:15:56 <hunteriam> i bet thats it
18:17:14 <hunteriam> but i dont quite understand how that works
18:18:58 <exio4> hunteriam: version of maybe what?
18:19:09 <hunteriam> Just a > Nothing
18:19:12 <hunteriam> and Just a < Nothing
18:19:17 <exio4> what does that mean? 
18:19:22 <hunteriam> those are both true
18:19:35 <hunteriam> for any a
18:20:06 <exio4> sounds weird, what do you want to do with that?
18:20:18 <hunteriam> make my life slightly easier
18:20:24 <exio4> how? :) 
18:20:27 <Welkin> @src Ord Maybe
18:20:27 <lambdabot> Source not found.
18:20:32 <hunteriam> i have a vector of Nothing and 1 Just x
18:20:33 <Welkin> @instance Ord Maybe
18:20:33 <lambdabot> Maybe you meant: instances instances-importing
18:20:34 <exio4> maybe rethinking the problem helps there
18:20:43 <hunteriam> and im allowing the user to choose a comparison function
18:20:51 <hunteriam> the comparison will act on x with other justs
18:20:57 <hunteriam> but should always be true against Nothings
18:21:16 <hunteriam> because Nothings represent negative infinity and positive infinity, depending on if youre using + or -
18:21:18 <hunteriam> but
18:21:22 <exio4> so, (a -> a -> Ordering) -> Vector (Maybe a) -> ?? 
18:21:27 <hunteriam> yea
18:21:35 <hunteriam> but i think an easier approach
18:21:41 <hunteriam> would be if i just let the user input a multiplier
18:21:47 <hunteriam> and and always check for <
18:21:53 <hunteriam> since Nothing < Just x is always true
18:22:22 <exio4> I don't even know why you want a meaningless compare defined on that datatype? 
18:22:37 <hunteriam> well i have a list of values
18:22:42 <hunteriam> and as i go through them
18:22:48 <hunteriam> i want to say if a > b update b
18:22:58 <hunteriam> but let the user swap out (>) for whatever they want
18:22:58 <exio4> it seems you're overcomplicating it, giving it'd be having a function like catMaybes :: Vector (Maybe a) -> Vector a
18:23:25 <exio4> hunteriam: wait, `update`, is it a mutable vector? ok
18:23:32 <hunteriam> it is
18:23:49 <exio4> so you need to do it in-place, normalFn . catMaybes won't work :p 
18:24:12 <hunteriam> catMaybes deletes the Nothings, doesnt it?
18:24:16 <hunteriam> im not trying to remove the nothings
18:24:30 <Welkin> yes
18:24:40 <Welkin> catMaybe filters for Just and then calls fromJust on them
18:24:48 <exio4> that's a nasty way to put it
18:24:58 <Welkin> [Maybe a] -> [a]
18:25:10 <exio4> that's an unsafe way to do it, kinda
18:25:14 <Welkin> I don't know exactly how it is implemented :P
18:25:18 <Welkin> but that is the main idea
18:25:26 <Welkin> you can always check
18:25:27 <exio4> [ x | Just x <- xs ]
18:26:15 <exio4> xs >>= \case { Just x -> return x ; _ -> mzero; }
18:26:55 <exio4> I truly dislike that `example` implementation using partial functions and boolean predicates
18:27:07 <exio4> it should be an example of boolean blindness
18:27:17 <exio4> anyway, totally unrelated
18:28:05 <Welkin> > foldr1 (\x acc -> maybe acc (\x -> x : acc) x) $ [Nothing, Just 5, Just 3, Nothing, Just 7]
18:28:07 <lambdabot>      Couldn't match expected type ‘Maybe a’ with actual type ‘[a]’
18:28:07 <lambdabot>      Relevant bindings include
18:28:07 <lambdabot>        acc :: [a] (bound at <interactive>:1:12)
18:28:23 <exio4> hunteriam: I don't know the problem, either
18:28:27 <Welkin> > foldr1 (\x acc -> maybe acc (\y -> y : acc) x) $ [Nothing, Just 5, Just 3, Nothing, Just 7]
18:28:29 <lambdabot>      Couldn't match expected type ‘Maybe a’ with actual type ‘[a]’
18:28:29 <lambdabot>      Relevant bindings include
18:28:29 <lambdabot>        acc :: [a] (bound at <interactive>:1:12)
18:28:33 <Welkin> :D
18:28:39 <exio4> you probably want foldr, not foldr1
18:28:50 <Welkin> oops
18:29:00 <Welkin> > foldr (\x acc -> maybe acc (\y -> y : acc) x) [] $ [Nothing, Just 5, Just 3, Nothing, Just 7]
18:29:02 <lambdabot>  [5,3,7]
18:29:12 <exio4> > catMaybes []
18:29:13 <lambdabot>  []
18:29:24 <Welkin> > foldr (\x acc -> maybe acc (\y -> y : acc) x) [] $ []
18:29:26 <lambdabot>  []
18:29:27 <Welkin> :o
18:29:49 <exio4> foldr f z [] = z
18:29:54 <exio4> just followin' the definition 
18:29:56 <Welkin> yeah
18:42:08 * geekosaur reads latest in MRP thread, gets popcorn
18:42:26 <roconnor> MRP?
18:42:46 <Welkin> so what is with errors > 2.0 ?
18:42:49 <orion> MRP?
18:42:49 <Welkin> ExceptT?
18:42:52 <geekosaur> "monad return proposal" aka removing return from Monad
18:42:59 <Welkin> geekosaur: and putting it where?
18:43:06 <exio4> it's redundant
18:43:07 <Welkin> geekosaur: just using pure instead?
18:43:09 <exio4> there's already pure
18:43:09 <geekosaur> top level alias for pure
18:43:20 <geekosaur> as opposed to typeclass member
18:44:03 <geekosaur> Graham Hutton is strongly opposed
18:44:17 <Welkin> I don't see a problem
18:44:30 <Welkin> I mean with keeping it
18:44:43 <Welkin> I know return and pure are aliases in a monad
18:44:52 <Welkin> but who uses pure in a monad?
18:46:49 <Welkin> yeah
18:46:57 <Welkin> that woul be strange to get rid of it from the type class
18:47:02 <Welkin> I mean
18:47:12 <Welkin> monad is defined in terms of >>= and return
18:47:24 * ski points
18:47:38 <geekosaur> the argument is that with Applicative a => Monad a, return is completely redundant
18:47:43 <Welkin> sure
18:48:26 <exio4> Welkin: monad would basically be just (>>=), even (>>) is redundant
18:48:33 <geekosaur> Hutton's argument is that return is too deeply ingrained into both several decades of code and an uncounted number of Haskellers' brains
18:48:36 <exio4> @type (*>)
18:48:37 <lambdabot> Applicative f => f a -> f b -> f b
18:48:40 <Welkin> exio4: technically, yes
18:48:53 <Welkin> but >> is very useful
18:48:59 <exio4> so what?
18:49:03 <Welkin> exio4: no
18:49:10 <Welkin> *> and >> have different semantics
18:49:10 <exio4> the `remove` of it, is from the typeclass, not the operator
18:49:13 <Welkin> we talked about this earlier
18:49:20 <exio4> you'll still be using (>>) and return
18:49:32 <exio4> Welkin: when? I'll check the logs
18:49:40 <Welkin> exio4: no, I mean a couple weeks ago
18:50:23 <exio4> ok, then I'll ask you to tell me in which way they are different, assuming your applicative instances matches your monad instance
18:50:36 <exio4> s/instances/instance
18:52:08 <rybern> Hey guys. I'm looking for a basis set of tutorials on a standard Haskell environment on Linux/Emacs. So setting up Emacs with compiling/continuous typechecking/autocomplete, Stack stuff, etc.
18:52:29 <rybern> So should I read one on Emacs setup and one on stack, or is there a good one that has everything I need?
18:53:21 <geekosaur> exio4, my recollection is that Applicative *> takes advantage of the fact that there is no implicit ordering in Applicative, and so *> can break monadic sequencing
18:53:44 <hiptobecubic> rybern, do you already know emacs?
18:53:58 <exio4> geekosaur: `break` in which sense?
18:54:12 <geekosaur> in the sense that it may run the thing on the right before the thing on the left
18:54:16 <rybern> hiptobecubic, yep pretty comfortable with it
18:54:18 <geekosaur> because that's legal in Applicative
18:54:28 <exio4> well, so can on Monad? 
18:54:34 <scshunt> no
18:54:42 <scshunt> Monad's typing enforces an evaluation order
18:54:45 <geekosaur> putStr "prompt" *> getLine
18:54:55 <geekosaur> I think you care what order those happen in
18:55:42 <exio4> you get that order from the definition of IO, it is not something intrinsic to Applicative/Monad
18:55:45 <scshunt> I mean, this is all pure functional
18:55:58 <scshunt> so it's not really sensible to talk about it in terms of an ordering anyway
18:56:13 <exio4> scshunt: does it?
18:56:14 <scshunt> IO is weird because the usual way to think about it is nonpure (even though it actually can be viewed in a pure fashion)
18:56:23 <geekosaur> I may well be misrecalling the argument
18:56:34 <scshunt> exio4: (a -> m b) can't be evaluated without an a
18:56:34 <hiptobecubic> rybern, I think there's a haskell-mode by .... chrisdone? http://chrisdone.com/posts/haskell-emacs should give you some link trails to follow
18:56:45 <hiptobecubic> rybern, i don't know much else. I'm a vim user, myself. :)
18:57:03 <exio4> > (undefined :: a -> b) >>= \_ -> return 2
18:57:04 <rybern> hiptobecubic, thanks, I'll check that out!
18:57:05 <awpr> Applicative is capable of being unordered, but there's a law on Monad that ap === (<*>), which means an Applicative that is also a Monad cannot (legally) behave differently for (*>) and (>>)
18:57:06 <lambdabot>      No instance for (Typeable a0)
18:57:06 <lambdabot>        arising from a use of ‘show_M47081884618986558046127’
18:57:06 <lambdabot>      In the expression:
18:57:19 <scshunt> exio4: or thrown away, sure
18:57:35 <scshunt> not the point ;)
18:57:37 <awpr> which is why there's a Monad instance hidden behind a newtype in the async package
18:58:04 <exio4> > ((undefined :: Int -> Int) >>= \_ -> return (2 :: Int)) 0
18:58:06 <lambdabot>  2
18:58:09 <awpr> or maybe the other way around, a newtype to provide a different Applicative
18:58:18 <scshunt> I would still recommend just dropping the whole "order of execution" business, since it is really misleading
18:58:44 <exio4> maybe they meant it can be parallel or what not, which was the whole reason behind the ApplicativeDo stuff
19:01:31 <awpr> I can definitely imagine a world where ap needn't be the same as <*>, and in fact I think I might prefer it, but it would mean we'd have to be careful about choosing Monad or Applicative versions of combinators.
19:01:49 <Welkin> <* and << work very differently
19:02:00 <Welkin> @let (<<) = flip (>>)
19:02:02 <lambdabot>  Defined.
19:02:04 <Welkin> :t (<<)
19:02:06 <lambdabot> Monad m => m b -> m a -> m b
19:02:08 <Welkin> :t (<*)
19:02:10 <lambdabot> Applicative f => f a -> f b -> f a
19:02:18 <Welkin> :t (*>)
19:02:19 <lambdabot> Applicative f => f a -> f b -> f b
19:02:20 <Welkin> :t (>>)
19:02:22 <lambdabot> Monad m => m a -> m b -> m b
19:02:28 <hunteriam> https://www.irccloud.com/pastebin/wCfTNGHJ/needed%3F
19:02:39 <hunteriam> is there something in the prelude that has this behavior?
19:02:44 <hunteriam> so i dont need to write my own data type?
19:02:55 <exio4> @type \ma mb = ma >>= \y -> mb >>= \_ -> return y 
19:02:56 <lambdabot> parse error on input ‘=’
19:02:57 <Welkin> hunteriam: please use lpaste instead
19:03:01 <Welkin> @lpaste
19:03:01 <lambdabot> Haskell pastebin: http://lpaste.net/
19:03:03 <hunteriam> why lpaste?
19:03:08 <Welkin> because it is what we use
19:03:12 <exio4> @type \ma mb -> ma >>= \y -> mb >>= \_ -> return y 
19:03:13 <lambdabot> Monad m => m b -> m a -> m b
19:03:22 <ski> scshunt : i don't see why `IO' would be much weirder than other monads ..
19:03:27 <hunteriam> that doesnt seem like a very good reason to use lpaste
19:03:33 <scshunt> ski: IO's weirder because we reason about it in a nonpure fashion
19:03:35 <scshunt> monads are pure, though
19:03:45 <Welkin> hunteriam: because I cannot use your irccloude service without enabling javascript
19:03:50 <hunteriam> ok
19:03:51 <scshunt> IO is a trickiness to turn nonpure code into pure code
19:03:57 <Welkin> there is no syntax highlightin either
19:03:57 <exio4> Welkin: how are (<<) and (<*) "very different"? 
19:04:02 <ski> scshunt : i don't follow on the "we reason about it in a nonpure fashion" part
19:04:03 <hunteriam> http://lpaste.net/142177
19:04:04 <Welkin> exio4: look at the types
19:04:12 <hunteriam> Welkin: there is syntax highlighting i just have to manually enable it
19:04:14 <Welkin> <* is left to right
19:04:21 <Welkin> << is right to left
19:04:59 <ski> > (take 1 . getDual . execWriter) (forever (tell (Dual "b")) *> tell (Dual "a"))
19:05:01 <lambdabot>  "a"
19:05:02 <awpr> Welkin: the types are not different except visually.
19:05:02 <ski> > (take 1 . getDual . execWriter) (forever (tell (Dual "b")) >> tell (Dual "a"))
19:05:04 <lambdabot>  "a"
19:05:05 <ski> (inconclusive)
19:05:14 <hunteriam> so does anyone know of an existing data type to cover this use case?
19:05:17 <hunteriam> http://lpaste.net/142177
19:05:22 <Welkin> awpr: the ordering is different
19:05:24 <hunteriam> or, maybe not use case but behavior
19:05:38 <exio4> I still have problems seeing the difference
19:05:44 <exio4> @type [(<*), (<<)]
19:05:46 <lambdabot> Monad f => [f a -> f b -> f a]
19:06:20 <awpr> exio4: <* is liftA2 const, but << is flip (liftA2 (flip const)).
19:06:42 <exio4> I meant a difference in the types
19:06:59 <awpr> yeah, like I said the types are the same except cosmetic differences
19:07:09 <exio4> and right
19:07:49 <ski> hunteriam : maybe "two-point compactification" or something
19:07:49 <felixn> is it possible to hook into the State monad, so when the monad calls "put", I can hook some logic into it
19:08:09 <exio4> that instance looks a bit weird, though
19:08:12 <awpr> but this ordering thing is irrelevant to whether >> should be in Monad.  the point is it's not a new capability of Monad. (unless ap is allowed to be different from <*>)
19:08:19 <hunteriam> ski: never heard of it
19:08:43 <ski> felixn : make a new monad, being an instance of `MonadState'. make sure `put' and `get' satisfies reasonable laws
19:08:57 <felixn> ski: awesome thanks
19:10:12 <nolrai66> ski: "two-point compatification" of the reals?
19:10:25 <ski> nolrai66 : that's what i was thinking of, yes
19:10:41 <ski> nolrai66 : however, i was really looking for something similar to that, in order theory
19:10:49 <ski> (but i don't know what it would be called)
19:11:07 <nolrai66> Adding a top and bottom?
19:11:22 <ski> perhaps something with "completion"
19:11:24 <nolrai66> I've swear I have read what thats called.
19:12:51 <ski> felixn : e.g. `get >> get = get',`put x >> put y = put y',`get >>= put = return ()',`put x >> get = put x >> return x'
19:13:52 <awpr> hunteriam: ooh, I was talking about that thing as a lattice a few days ago.  nobody had a name for it then either
19:14:08 <Welkin> exio4, awpr: here is an example to show my poiny
19:14:10 <Welkin> point*
19:14:17 <Welkin> > runState (modify (+1) <* modify (*2)) 0
19:14:18 <awpr> actually, no, I was talking about something different
19:14:19 <lambdabot>  ((),2)
19:14:22 <Welkin> > runState (modify (+1) << modify (*2)) 0
19:14:24 <lambdabot>  ((),1)
19:14:32 <awpr> Welkin: nobody's claiming that << and <* are identical.
19:15:01 <ski> felixn : getting twice in a row (with nothing inbetween) reasonably ought to be the same as getting once. putting twice in a row, should be the same as the last put. getting and putting back is a noop. putting and getting is the same as putting and returning the put value
19:15:10 <awpr> hunteriam: I think this is your type https://hackage.haskell.org/package/lattices-1.4/docs/Algebra-Lattice-Levitated.html
19:15:39 <hunteriam> awpr: i actually remember you talking about it
19:16:15 <awpr> :t flip liftM2 (flip const)
19:16:17 <lambdabot> ((c -> c) -> a2 -> r) -> (b -> a2) -> b -> r
19:16:22 <ski> hm .. i suppose the thing i was thinking of wouldn't add bottom/top, in case there were already there
19:16:29 <exio4> > (Left 'a' <* Left 'b' , Left 'a' << Left 'b')
19:16:31 <awpr> oops...
19:16:31 <lambdabot>  (Left 'a',Left 'b')
19:16:37 <awpr> :t flip (liftM2 (flip const))
19:16:38 <lambdabot> Monad m => m r -> m b -> m r
19:17:02 <awpr> that thing is <* for Monad.  << is not.
19:18:11 <felixn> ski: I'm messing around with reactjs style components in Haskell.  that's an awesome concept, once I understood I realized it wasn't what I wanted XD
19:18:42 <ski> felixn : ok
19:19:02 <nolrai66> felixn: What did you want?
19:19:12 <gfixler> what does "tagless" mean?
19:19:28 <gfixler> what's a tag?
19:19:54 <awpr> gfixler: in what context?  "Spineless Tagless G-Machine"?
19:20:12 <gfixler> awpr: I think so - I'm hoping to read "Finally Tagless, Partially Evaluated"
19:20:45 <ski> gfixler : hm, who's the author(s) of that ?
19:20:48 <awpr> my understanding is it means it doesn't use pointer tagging to encode ADT constructors.  but, that's now misleading because GHC does some kind of pointer tagging
19:21:01 <gfixler> ski: Jacques Carette, Oleg Kiselyov and Chung-chieh Shan
19:21:13 <felixn> I was thinking I would have to hook into "put" for state change, but now I'm thinking I can just have a simpler function that returns the new state
19:21:29 <ski> gfixler : ok, ty
19:22:48 <awpr> http://community.haskell.org/~simonmar/papers/ptr-tagging.pdf describes taglessness and GHC's lack thereof
19:23:02 <awpr> ... as of 2007
19:23:30 * ski . o O ( practically yesterday )
19:23:56 <gfixler> awpr: thanks - I'll have a look
19:24:48 <gfixler> awpr: should I read this before or after Spineless, Tagless, G-Machines?
19:25:21 <gfixler> (I ask as it mentions STG-machine in the first paragraph)
19:27:46 <awpr> not sure, it can't hurt to understand the base STG machine first.  but I think this paper mostly deals with ADT representation in memory, which I don't think requires detailed knowledge of how STG executes.  I'm not all the way through this one yet
19:28:01 <gfixler> okay
19:59:04 <ReinH> gfixler: read the STG machine stuff first, and perhaps SPJ's book if you want a more gradual introduction
20:06:27 <hunteriam> guys how do i preview the haddock documentation for a module
20:09:35 <hiptobecubic> API question! I have a little app for performing language translation. It has a function translate :: Language -> (Language, Body) -> Body  (ignoring errors for now).  Baked into this function is the idea that it will be using a particular translation service. I want to parametrize over this. Is that a reasonable use of type classes?
20:09:38 <hiptobecubic> I would think not
20:09:48 <hiptobecubic> But I also don't really see how it would be done
20:10:11 <delYsid> Is there something like boolM :: Monad m => m a -> m a -> m Bool -> m a ?
20:10:31 <hiptobecubic> I thought maybe something like   translate :: Language -> (Language, Body) -> TranslationService -> Body, but I'm not sure what TranslationService really is. 
20:11:23 <hiptobecubic> I thought perhaps something like   data TranslationService = MicrosoftTranslator {whatever ...} | GoogleTranslate { whatever ...}, but records + sum types has proven to be a disasterous combination in general
20:11:39 <hiptobecubic> delYsid, nothing on hoogle?
20:11:52 <hiptobecubic> @hoogle Monad m => m a -> m a -> m Bool -> m a
20:11:54 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
20:11:55 <lambdabot> Control.Exception.Base bracket_ :: IO a -> IO b -> IO c -> IO c
20:11:55 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
20:12:54 <delYsid> nah, hoogle never gives me any good result if searching for types.
20:12:59 <hiptobecubic> Actually, what semantics are you even going for? It computes the valued of the bool and then returns one of the first two arguments?
20:13:22 <anon_23> Num a => a
20:13:25 <anon_23> can you define this
20:13:38 <glguy_> :t 0
20:13:39 <lambdabot> Num a => a
20:14:12 <anon_23> glguy_: how do you read this i mean
20:14:32 <hiptobecubic> anon_23, is `a` type variable representing some type that is assumed to have a Num instance
20:14:44 <hiptobecubic> `a` is a type variable*
20:14:57 <glguy_> the constraints go on the left side of the=>
20:15:35 <delYsid> hiptobecubic: Yes, basically something like \t f p do { b <- p; if b then t else f}
20:16:10 <glguy_> a can be any type with kind *, but what ever type you pick you also get a Num constraint to satisfy
20:16:39 <hiptobecubic> @pl \t f p -> p >>= if' t f
20:16:39 <lambdabot> ((=<<) .) . if'
20:16:47 <hiptobecubic> delYsid, tada!   
20:16:49 * hiptobecubic barfs
20:16:56 <hiptobecubic> @src if'
20:16:56 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
20:17:18 <hiptobecubic> @pl \b t f -> if b then t else f
20:17:18 <lambdabot> if'
20:17:24 <geekosaur> I was wondering why you didn;t use bool
20:17:30 <geekosaur> which unlike if' does exist
20:17:33 <delYsid> hiptobecubic: :-)
20:17:42 <geekosaur> (and someday @pl should be changed to use it)
20:17:42 <delYsid> But hey, there is if', I didnt know!
20:17:44 <hiptobecubic> geekosaur, if' exists! It's right there :)
20:17:54 <rhovland> anyone do nicta more than once?
20:18:05 <hiptobecubic> delYsid, there isn't :(   It's actuall called bool, sadly
20:18:09 <hiptobecubic> @type bool
20:18:10 <lambdabot> a -> a -> Bool -> a
20:18:36 <hiptobecubic> @pl a -> a -> m Bool -> a
20:18:36 <lambdabot> (line 1, column 5):
20:18:36 <lambdabot> unexpected '>'
20:18:36 <lambdabot> expecting operator
20:18:53 <hiptobecubic> errr, that won't work of course :).... what's the name of that thing
20:18:56 <hiptobecubic> @djinn a -> a -> m Bool -> a
20:18:57 <lambdabot> f _ a _ = a
20:19:04 <ski> @djinn Monad m => m a -> m a -> m Bool -> m a
20:19:04 <lambdabot> f _ a _ = a
20:19:06 <hiptobecubic> lol, fine
20:19:15 <delYsid> Well, the type sig of bool actually makes sense, given how maybe works.
20:19:17 <hiptobecubic> thanks, djinn. 
20:19:21 <hiptobecubic> jackass...
20:19:24 <ski> @type either
20:19:25 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
20:20:47 <hiptobecubic> delYsid, i think you want `p >>= bool t f`, more or less.
20:21:36 <hiptobecubic> I don't understand what the right way to model this translation thing really is. I essentially have two backends and they should be perfect substitutes for one another as far as the system is concerned
20:22:00 <hiptobecubic> I suppose that sounds like how free monads are used... maybe I'll find something there
20:44:35 <Xnuk> Is there any editor (or editor plugin) that predicts and highlights the position where a selected thing is evaluated?
20:50:07 <rhovland> xnuk: that seems like it wouldn't be possible
20:51:11 <glguy> osa1: Any chance we're on at the same time?
20:51:15 <rhovland> Xnuk: I may be misunderstanding what you're talking about, though
21:34:25 * hackagebot polar-shader 0.1.0.3 - High-level shader compiler for Polar Game Engine  https://hackage.haskell.org/package/polar-shader-0.1.0.3 (Shockk)
21:47:07 <kristof> Why can't I add extra constraints to functions in instances of typeclasses?
21:47:49 <bitemyapp> we need a "why Set is not a Functor" FAQ
21:47:51 <glguy> Can you show an example of what that means?
21:48:05 <kristof> glguy: What Chris basically said.
21:48:16 <bitemyapp> glguy: see? I'm psychic.
21:48:25 <bitemyapp> or I've seen this conversation happen like 50 times
21:48:28 <bitemyapp> one of the two.
21:48:36 <geekosaur> every 2 or 3 days...
21:48:39 <bitemyapp> see?
21:48:42 <geekosaur> (in here at least)
21:48:44 * bitemyapp laughs
21:48:54 <kristof> I remember the explanation making sense but I've forgotten the justification.
21:49:08 <glguy> The type of a class method is picked by the class definition. Every use of the class method is checked against that type without regard for which instance is being used
21:49:37 <kristof> Is there a good reason for that, though?
21:49:54 <kristof> wrt to constraints
21:50:25 <glguy> You don't always know which instance is being used, so you can't rely on that
21:50:44 <kristof> I meant have it checked at the usage site.
21:51:00 <Shockk> does the compiler not need to know which instance it's using when you call a function from the typeclass?
21:51:06 <glguy> you'd have to encode that use-site restriction in the type of the thing
21:51:29 <kristof> glguy: Well what I'm saying is that that's not necessarily true. Or at least I don't think it is
21:51:41 <geekosaur> Shockk, it may not know until runtime
21:51:42 <kristof> The type can remain unconstrained while the operation is constrained.
21:52:25 <glguy> fmap (\_ -> id) :: Functor f => f a -> f (b->b)
21:52:36 <glguy> that's typechecked
21:52:46 <glguy> I can name it mything = fmap (\_ -> id)
21:52:48 <Shockk> geekosaur: hmm, under what circumstances might that be the case?
21:53:24 <glguy> but now how do we know if it's OK to use that where f is Set?
21:53:55 <kristof> glguy: if f is set, then at the usage site the compiler has to check if Set has a functor definition anyway
21:54:23 <glguy> it has one using the hypothetical system where I was able to make one
21:54:24 <geekosaur> any time you call a polymorphic function using a typeclass from another module? unless the compiler is jhc, it's not going to compile the other module again so it can fix the type at compile time; it has to pass a dictionary at runtime
21:54:30 <glguy> by adding constraints at the instance
21:54:57 <glguy> types wouldn't be very useful if they didn't actually tell us where we could use that definition
21:55:40 <geekosaur> put otherwise, if I export a function from my module using a typeclass, it has to generate code that can call the right instance functions at runtime, because the compiler has no clue what uses I might have for that compiled module later
21:55:59 <geekosaur> or even what instances might exist at that future time
21:56:14 <kristof> Oh, I didn't know that typeclasses in haskell usually involved dynamic dispatch
21:56:27 <bitemyapp> usually?
21:56:33 <geekosaur> if it can determine the type statically, it will
21:56:38 <bitemyapp> I dunno about that.
21:56:38 <kristof> If there's a module boundary involved.
21:56:47 <kristof> That's what I'm gathering from geekosaur's explanation.
21:56:50 <Cale> geekosaur: Are you sure?
21:57:11 <Cale> I don't think GHC specialises things without the user explicitly requesting it.
21:57:29 <geekosaur> Cale, I may ahve described that improperly? or are you seriously suggesting that the compiler can statically resolve an instance that doesn't yet exist at compile time?
21:58:00 <glguy> The function can be compiled to expect a dictionary to be passed to it
21:58:02 <Cale> Oh, I didn't initially see the rest of the stuff you said
21:58:07 <Cale> let me read
21:59:00 <Cale> I think even inside a module, this is usually the case?
21:59:10 * geekosaur may well have described it poorly; ideally would be in bed by now, but it's crunch time for packing for next week's trip (work related and had to wait until COB to pack work stuff)
21:59:23 <Cale> It won't compile extra versions of type class polymorphic things unless you explicitly ask for them.
21:59:26 <glguy> It doesn't matter how the compiler is implemented, the point is that the types need to capture the constraints for a value
21:59:48 <glguy> There can't be hidden information about when its OK to use that value
22:00:57 <Cale> Maybe if it manages to inline the definition, you could get some specialisation happening that way without requesting it?
22:01:26 <Cale> But yeah, I would usually tend to assume that it's not going to specialise anything, it's a safer bet.
22:02:40 <Cale> Oh, this was somehow about Set not being an instance of Functor?
22:02:41 <geekosaur> I wasn't suggesting it compiled the function again (again, except in jhc --- whole-program compiler, specifically so it can do that kind of optimization), more that it can resolve the typeclasses at compile time instead of requiring a runtime dictionary lookup --- in effect doing the lookup at compile time and compiling in the resulting instance-specific call
22:02:44 <Cale> How did we get here?
22:03:33 <kristof> Cale: set functor. I was wondering why it really was impossible to constrain fmap down the road if the type information is all known.
22:03:45 <Cale> kristof: The real reason is, well, suppose we have three types A, B, C, and suppose that A and C are instances of Ord, but that B is not (and won't ever be)
22:03:54 <geekosaur> except that if it's in another module, it can't really do that unless ghc happened to expose the function for cross-module inlining and then actually inlined it
22:04:20 <Cale> Now suppose I write some function which is polymorphic in the choice of functor, of type (Functor f) => f A -> f C
22:04:26 <geekosaur> kristof, basically because you can't check per-instance constraints
22:04:42 <geekosaur> especially if you can't know what instance will be used at compile time
22:04:43 <Cale> There are instances of Ord for A and for C, so you might think f = Set should be fine, right?
22:05:31 <Cale> But what if my function is implemented by composing some functions (Functor f) => f A -> f B, and (Functor f) => f B -> f C ?
22:05:34 * geekosaur is too tired for this, probably,,,
22:06:35 <Cale> Now it's suddenly very much not okay. We can't form a value of type Set B, apart from maybe the empty set or a singleton, because there's no instance of Ord for B.
22:06:48 <Cale> and nothing will rescue you from this
22:07:32 <Cale> You can't say "oh, well, for this functor, fmap can have a more specialised type"
22:08:26 <Cale> Because anyone is allowed to use fmap polymorphically in full generality, and the types of things built with it might not mention all the types on which fmap needs to work.
22:08:27 <kristof> Cale: Well, that's what I'm saying.
22:08:43 <awpr> http://hackage.haskell.org/package/rmonad-0.8.0.2/docs/Control-RMonad.html can say exactly that (for Monad)
22:08:53 <Cale> Only by redefining the class.
22:08:58 <awpr> right
22:09:19 <Cale> Sure, if Functor were a different class, there are various strategies which could be taken to capture this
22:09:27 <Cale> But you *do* pay quite a bit
22:09:31 <kristof> Cale: Yeah, I'm saying with much waving of the hands that even if I built a function polymorphic over functors, any usage of that function on a set should cause the constraint to bubble up
22:10:14 <Cale> Your type signatures for functions which are polymorphic in the choice of functor (or monad or whatever) will end up cluttered with constraints regarding intermediate types that expose things about the implementations of your functions.
22:11:14 <kristof> I think that's okay if one can write strictly more valid functor instances that way.
22:11:32 <kristof> But my question is answered because I can see why that would be divisive or unwieldy to some people.
22:11:43 <Cale> So, in my example from earlier, you'd end up not being able to write  (Functor f) => f A -> f C, instead, that thing would have type  (Functor f, Suitable f A, Suitable f B, Suitable f C) => f A -> f C
22:12:06 <Cale> and all of a sudden, you're mentioning this type B which doesn't even otherwise occur in the signature
22:12:35 <rhovland> maybe there should be a Set with terrible performance that didn't have the Ord constraint
22:12:52 <Cale> There is another approach you can take
22:13:04 <Cale> (If you don't care about performance)
22:14:21 <rhovland> just having a set that _could_ be a functor might help people out... hmm.. must be easy to define that
22:14:22 <Cale> You can apply Coyoneda, which will get you a functor instance for free.
22:14:36 <kristof> Cale: Isn't it CoYoneda?
22:14:48 <kristof> I'm really confused about that capitalization :P
22:14:49 <Cale> Not in Ed's library
22:15:19 <kristof> I think merijn disagrees
22:15:22 <shachaf> Or Yoneda, which will get you a Functor instance for cofree.
22:15:27 <Cale> heh
22:15:28 <kristof> or shachaf
22:15:42 <bitemyapp> spelling is scow
22:15:45 <rhovland> I suppose at that point set is almost the same as list, but without duplicates.. does the Eq constraint cause problems for functor?
22:16:01 <Cale> But it's basically the same thing as accumulating a function separately from your Set
22:16:06 <bitemyapp> rhovland: welcome to the conversation!
22:16:16 <Cale> and then you get to apply the function all at once at the end
22:16:20 <bitemyapp> rhovland: Set in Haskell usually uses the one that needs Ord.
22:16:23 <Cale> which can be awful
22:16:40 <shachaf> Yes.
22:16:46 <shachaf> It's even worse when you want to make a Monad.
22:16:49 <Cale> right
22:16:52 <rhovland> bitemyapp: well, set certainly needs Eq, no matter how you do it, right?
22:16:54 <bitemyapp> rhovland: Cale has detailed why it doesn't work above, if you weren't logged in: http://ircbrowse.net/browse/haskell will catch up.
22:17:45 <Cale> rhovland: Sort of. You can store an ordinary (Ord-requiring) Set b, together with a function b -> a
22:18:16 <Cale> and that'll let you get a functor instance which just composes stuff on the function
22:18:26 <kristof> Cale: Okay, I think this makes sense now. I would certainly be puzzled to see a compiler error "No instance of Ord for B" when B is not in the type signature.
22:18:36 <Cale> kristof: right
22:18:39 <rhovland> cale: no, I'm asking if a set that _doesn't_ have an ord constraint, but still has an eq constraint, would be able to be a functor
22:18:52 <Cale> rhovland: No, it's the same problem.
22:19:04 <Cale> rhovland: You can't have any constraints on the type of the implementation for fmap
22:19:10 <Cale> because fmap's type doesn't have constraints
22:19:12 <Cale> :t fmap
22:19:13 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:19:15 <kristof> Cale: I would, however, be okay with seeing this error
22:19:23 <kristof> Cale: "Error: f cannot be constrained to Ord"
22:19:27 <Cale> ^^ people are already using this function at types which won't satisfy your constraints
22:19:47 <rhovland> cale: hmm.. that's what I thought... but set needs an eq constraint, no matter how you define set, doesn't it?
22:19:54 <Cale> Kind of
22:19:59 <rhovland> I mean, if you say sets can't have duplicates
22:20:15 <Cale> rhovland: I just went over a way to get a type which behaves like Set, but for which you can write a Functor instance.
22:20:27 <Cale> However, it's not a particularly useful approach
22:20:41 <Cale> (most of the time, anyway)
22:21:01 <kristof> Cale: That's sort of bad, too, though. You have this function which is defined for all functors, and then you defined a functor, but it turns out you're still not in the club.
22:21:17 <Cale> kristof: right.
22:22:16 <kristof> Cale: I can sort of see this as a Faustian trade, though. "I will add this constraint on my instance on the condition that I will accept not being able to use certain functions that cannot be constrained."
22:22:52 <Cale> kristof: But even once you're willing to say that, you end up having to pay a heavy syntactic tax
22:22:55 <kristof> Cale: Anyway, I've read up on constraint kinds and I like that solution a lot, but it gets unwiedly the more things can possibly be constrained.
22:23:30 <Cale> Because the type of everything which is polymorphic in the choice of functor will end up with a horrible looking type with all these extra constraints which say on which types the functor needs to be a functor.
22:23:48 <arahael> Would someone be kind enough to suggest how I might write fibs in python, using the _same_ algorithm I have in haskell?
22:24:00 <arahael> My code is here: https://bpaste.net/show/b1fad3d42b42
22:24:17 <arahael> There, the python code is obviously way, way too recursive.
22:24:31 <rhovland> python is terrible at recursion
22:24:31 <arahael> The haskell code seems not to recurse so badly.
22:24:32 <Cale> arahael: You can't.
22:24:50 <Cale> Well, okay, you maybe can...
22:24:54 <arahael> Cale: I'm happy with that reality, but I'd like to know why.
22:24:57 <Cale> You'll need to represent thunks explicitly
22:25:19 <Cale> With some object type that represents an unevaluated expression and lets you force evaluation
22:25:31 <Cale> and then you'll have to build a list type which uses those
22:25:50 <Cale> and zipWith :P
22:25:51 <dmwit> arahael: def fibs(): (fibs, tailfibs) = (1, 2); while true: yield fibs; (fibs, tailfibs) = (tailfibs, fibs+tailfibs)
22:26:27 <Cale> Yeah, that's... not really the same, but it's kinda close I guess?
22:26:34 <dmwit> agreed
22:26:39 <dmwit> It's a nasty transformation to have to make.
22:26:44 <arahael> Yeah, that's /close/, and an elegant approximation of the algorithm, but I was hoping to have the same.
22:27:11 <arahael> Cale: How would thunks help in this case, wouldn't I also need to somehow determine which thunks are equivaelent, and only evaluate them once?
22:27:55 <Cale> arahael: Well, forcing a thunk should cause it to be updated such that forcing the same thunk again will simply return the already computed result.
22:28:30 <arahael> Cale: Ah, I see... And the fibs function would merely return the same thunks - or the evaluated result, every time.
22:28:35 <arahael> Cale: Without repeating the calculation?
22:28:56 <arahael> (Which haskell can only do because it _knows_ there are no possible side effects)
22:29:18 <Cale> arahael: In GHC, thunks are represented by pointers to code which, the first time the code is entered, rewrites the pointer to point at a "black hole" (which is a bit of code which throws a <loop> exception), computes the value, then rewrites the pointer again to point at a short piece of code which will simply return the already computed value, before returning what it computed.
22:29:55 <arahael> Cale: I assume that this would require cleaning up those thunks - computed or otherwise - when no-longer needed?
22:30:17 <Cale> arahael: and cons cells formed using (:) have, alongside the integer tag saying that it's (:) and not [], two of these pointers to code -- one for the element, and one for the rest of the list.
22:30:29 <neuroserpens> :t fmpa
22:30:30 <Cale> Oh, yeah, garbage collection might become an issue
22:30:31 <lambdabot>     Not in scope: ‘fmpa’
22:30:31 <lambdabot>     Perhaps you meant ‘fmap’ (imported from Control.Monad.Writer)
22:30:33 <neuroserpens> :t fmap
22:30:35 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:30:55 <neuroserpens> @kind Functor
22:30:56 <lambdabot> (* -> *) -> Constraint
22:31:06 <Cale> But maybe not? Python's GC might be able to handle it
22:31:08 <arahael> Cale: I guess that does make sense - and is enlightening. :)
22:31:24 <neuroserpens> Cale: Garbage Collector?
22:31:29 <Cale> yes
22:31:36 <neuroserpens> Handle what?
22:31:44 <neuroserpens> Sorry, I just got back.
22:31:58 <Cale> neuroserpens: Cleaning up handmade thunks
22:32:03 <arahael> Cale: The result, clearly, would be some horrible python code, not that elegant example I showed.
22:32:11 <neuroserpens> Cale: Nice.
22:32:13 <arahael> Cale: (Which works, but is very, very inefficient)
22:32:40 <arahael> Yeah, Python's GC would handle it - but slowly. (It's a ref-counting scheme, with cycle detector)
22:33:19 <Cale> Yeah, GHC's generational garbage collector is really good at picking up lots of short-lived data
22:33:56 <dmwit> I guess the really interesting part is fix, anyway, not lists themselves or zipWith.
22:34:17 <arahael> fix?
22:34:25 <dmwit> recursion
22:34:30 <Cale> Yeah, the fact that it works to have cycles in these pointers to code caused by recursion.
22:34:54 <arahael> Sorry I'm lost now?
22:35:27 <dmwit> `fibs = 1:2:zipWith (+) fibs (tail fibs)` = `fibs = fix (\fs -> 1:2:zipWith (+) fs (tail fs))`
22:35:32 <dmwit> Note that the latter has no recursion.
22:35:52 <dmwit> And if you want to replicate this thing in Python, you'll have to implement `fix` or something like it, which is going to be tricky.
22:36:08 <Cale> Well...
22:36:10 <arahael> Isn't that the y combinator?
22:36:14 <dmwit> Sure.
22:36:19 <Cale> Nope, but it does the same thing
22:36:39 <Cale> The Y combinator usually refers to one of a handful of implementations of fix, in untyped lambda calculi
22:36:56 <Cale> In Haskell, we just define fix as:
22:37:03 <Cale> fix f = x where x = f x
22:38:04 <Cale> But yeah, this "x = f x" bit will be tricky. You'll need a way to allocate one of your handmade thunk things and then use a reference to it while constructing the expression that it's bound to.
22:38:04 <arahael> Wow, that beats pages and pages of explainations of the y-combinator which I never understood. (Though each distinct step seems to make sense)
22:38:34 <dramforever> the hardest thing about the y-combinator is the definition itself
22:38:53 <dramforever> because we don't have recursion in untyped LC
22:39:11 <Cale> The definition of the y combinator doesn't make sense because it's a type error in a simply typed lambda calculus, so it breaks your intuition about how things are meant to work.
22:39:14 <dramforever> but in haskell we could take it for granted
22:40:09 <arahael> I see.
22:40:33 <Cale> We can make it typecheck in Haskell, by using a recursive datatype :)
22:40:38 <Cale> data Rec a = In { out :: Rec a -> a }
22:40:38 <Cale> y :: (a -> a) -> a
22:40:38 <Cale> y = \f -> (\x -> f (out x x)) (In (\x -> f (out x x)))
22:40:49 <dramforever> Cale: but it's so unintuitive that even ghc breaks on it
22:40:54 <jle`> but...
22:40:55 <jle`>  y
22:41:06 <Cale> Well, that's just the inliner being too aggressive
22:41:09 <shachaf> i,i y = \f -> (\x -> out x x) (In (\x -> f (out x x)))
22:41:47 <dramforever> Cale: I would say it's because it believes that non-recursive functions always terminate
22:42:10 <Cale> hm, I'm not sure I agree with that description :)
22:42:28 <dramforever> Cale: screw it, forget about that
22:43:30 <arahael> Apparently, this is the y combinator in python: Y = lambda g: (lambda f: g(lambda arg: f(f)(arg))) (lambda f: g(lambda arg: f(f)(arg)))
22:44:23 <dramforever> arahael: I would expect it to be slow as hell...but who knows, maybe python is really clever
22:44:26 <arahael> But blegh, looks like I'd have to stop using 'def fib', and use 'fib = lambda...'
22:44:36 <arahael> dramforever: function calls are really expensive in python, so you'd be right.
22:45:27 <Cale> arahael: I think it would end up weirder still, because you'd be emulating the low level mechanisms that lazy evaluation are built on
22:46:05 <arahael> Indeed - and I wouldn't be able to productively use 'yield' or the other nicities in python.
22:46:25 <arahael> So, this was a useful excercise - thanks for the explaination. :)
22:46:25 <Cale> arahael: So you'd have to allocate a thunk, and then update it with its final expression after that, because the expression it's bound to involves that thunk itself :)
22:46:44 <arahael> Cale: That's starting to make my head expload. :)
22:46:48 <arahael> *explode
22:46:58 <jle`> you could write your own lazy lists, maybe
22:47:07 <seagreen> Is it possible to write a function that would fulfill this type signature? (Monad m, Monad n) => (a -> m (n a)) -> n a -> m (n a)
22:47:19 <seagreen> I hoped it would be, but I'm extremely stuck.
22:47:22 <arahael> jle`: I was using generators.
22:47:25 <dramforever> :exf (Monad m, Monad n) => (a -> m (n a)) -> n a -> m (n a)
22:47:33 <jle`> i mean, manipulate lazy lists using your generator
22:47:37 <Cale> seagreen: f g x = return x
22:47:42 <dramforever> too bad it isn't here
22:47:47 <Cale> :D
22:47:56 <seagreen> You stink:)
22:48:12 <dramforever> seagreen: that leads to this question: what do you expect it to do?
22:48:25 <Cale> There's not necessarily any way to go n (m (n a)) -> m (n a)
22:48:27 <jle`> seagreen: if you bind the function to the `n a`, you get an `n (m a)`.  it's impossible to in general turn one into an `m (n a)` for all Monads, but it's possible for some specific monads
22:48:41 <Cale> Or to go m (n a) -> n (m a)
22:48:49 <jle`> for example, if n is IO, you're out of luck
22:49:18 <jle`> if you're willing to constrain n to Traversable, then you can use mapM or traverse
22:49:25 <jle`> :t mapM
22:49:26 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
22:50:13 <seagreen> Thanks for the help so far! In my specific case m is MonadIO and n is MonadError String.
22:50:19 <jle`> oh, you getn an n (m (n a)), not an n (m a).  well if n is Traversable, you can use sequence to get an m (n (n a))
22:50:22 <jle`> and then fmap join
22:51:09 <Cale> seagreen: I think you'll make your life a whole lot easier if you work with particular monads rather than arbitrary ones which satisfy these ad-hoc type classes
22:51:09 <jle`> but whatever you do, you're going to need extra constraints than just Monad.  Because in general you can't turn an n (m (n a)) into an m (n a) for all Monads...a simple counter example is n ~ IO
22:51:44 <jle`> but yeah, you'll have to really reason about what the functions actually do, because the results you can conclude from the laws and parametricity might be a bit opaque
22:51:51 <seagreen> Cale: I _definitely_ agree with you, especially after this experience:)
22:52:32 <jle`> :t \f x -> fmap join (sequence (f =<< x))
22:52:33 <lambdabot> (Monad f, Monad m, Traversable m) => (a1 -> m (f (m a))) -> m a1 -> f (m a)
22:53:29 <Cale> seagreen: If I'm going to abstract over a choice of monad these days, I've sort of come to the conclusion that the right way to do it is usually to make a record of the operations I need, which is polymorphic in the choice of monad, and take that as an argument, and then only have a (Monad m) constraint.
22:53:30 <jle`> feels nice to see Functor as a superclass of Monad
22:53:50 <Cale> You can also make a custom type class if you get tired of picking the same record of operations over and over
22:54:10 <c_wraith> Cale: Not a fan of free monad approaches?
22:54:16 <Cale> But I really don't think that e.g. MonadState is usually the right idea.
22:54:52 <seagreen> jle`: Slick, I actually can add more constraints, so with Traversable I'm set.
22:55:20 <jle`> seagreen: you have to think about what sequence, traverse, etc. actually *mean* though, with respect to your operation, heh
22:55:24 <Cale> The MonadState operations on the one hand pin down the implementation of get and put too much (you can't implement them in terms of a chosen IORef, because you're writing a type class instance and not a function argument), and on the other hand are not really semantically meaningful enough to result in good-looking code.
22:55:27 <jle`> just because the types fit doesn't mean it does what you want
22:57:36 <dramforever> Cale: I would agree, and even though it pins down the implementation that much, there's no law at all to reason with
22:58:38 <dramforever> so it's kinda hard to know what it really does
22:58:52 <Cale> So I dunno, I've moved away from liking the MonadFoo classes much.
22:59:04 <Cale> For most Foo anyway
22:59:36 <Cale> Usually the right type class is more application or library specific than most examples of those type classes happen to be.
23:00:22 <Cale> and then we have MonadParsec, lol
23:01:33 <dramforever> Cale: this typeclass thing is really interesting. on one hand, it's harder to understand if you spotted one you are not familiar with while reading some code
23:02:01 <dramforever> I mean, harder than an application-specific function that does that thing
23:02:57 <dramforever> on the other hand, if you already know what a typeclass does then reading things that use it is definitely easier than reading things that use their own versions of those operations
23:02:57 <Cale> MonadParsec is application-specific enough, but... I dunno, it strikes me as something you don't really want. It's not a clean coherent abstraction, it's just a junk drawer with some of Parsec's operations in it which don't belong anywhere else. I don't see myself ever using it.
23:03:25 <Cale> It's really tempting in Haskell to abstract things with typeclasses just because you can
23:03:30 <Cale> But it's not always a good idea
23:03:59 <dramforever> Cale: yeah I would agree
23:04:45 <dramforever> but for those better ones like Alternative, it's really nicer than having own variants of those that might actually do something subtly different
23:05:04 <dramforever> I mean like (<|>) v.s. `parserOr`
23:05:04 <awpr> wait I thought you were joking about MonadParsec.  that's not in the base parsec package is it?
23:05:14 <Cale> awpr: It's in megaparsec
23:05:57 <awpr> that explains it
23:06:00 <Cale> It's perhaps a little mean of me to rag on it -- really this kind of thing shows up in many places.
23:06:13 <Cale> It was just the latest example of it I saw.
23:07:29 <saulzar_> Seems to be a waste if you're using an abstraction which describes just one implementation
23:07:40 <Cale> yes
23:07:50 <dramforever> Cale: the most widely used example I know is Num
23:08:29 <Cale> I think in order to have a successful type class, you need two things: 1) an expectation that there will be multiple instances, and 2) an expectation that a reasonable amount of useful polymorphic code can be written in terms of the operations of the class and thus shared between the instances.
23:08:59 <Cale> and don't talk to me about your lifting instance for ReaderT, I don't want to hear it :D
23:09:28 <Cale> Give me at least two *real* instances of the class, which are genuinely different.
23:09:29 <saulzar_> Depends, lifting ReaderT can be tricky in some situations!
23:09:35 <Cale> Yeah, maybe
23:10:26 <dramforever> Cale: um..hey, what do you think of Num?
23:10:47 <Cale> signum and abs don't belong, otherwise it's fine
23:11:15 <Cale> All my other reservations about Num have been fixed already
23:11:16 <saulzar_> I've been working on switching combinators for reflex, and the instances are a fair bit more complicated than   swtich = lift . local  (as you tend to get in quite a few of these)
23:11:27 <dramforever> Cale: oh, good to know
23:11:29 <kazagistar> I just come and listen to this chat to hear things like this and soothe my soul, which has been battered all day long by haphazard piles of singletons glued 1-to-1 to pointless interfaces with DI frameworks
23:12:06 <Cale> dramforever: Like, it used to be a subclass of Eq and, further back, even Show, and both of those got removed.
23:12:35 <Cale> kazagistar: haha
23:12:39 <dramforever> Cale: nice =)
23:13:03 <Cale> saulzar_: Oh, yeah, any instances of MonadReflex are probably going to be nontrivial
23:13:21 <Cale> er, just Reflex rather :P
23:14:07 <saulzar_> Cale, But if you look at the code in reflex-dom it's littered with a bunch of horrible typeclasses which only do one thing. (sorry Ryan!) :P
23:14:58 <Cale> I think that's just Ryan eventually intends to have more implementations, but each one is so much effort to write that we don't have them yet :P
23:15:22 <Cale> But I agree
23:15:52 <Cale> It's possible that we'd be better off in many cases just with monomorphic types for these things :P
23:16:01 <saulzar_> "premature abstraction" maybe
23:16:18 <Cale> yep
23:17:21 <Cale> class (Reflex t, MonadHold t m, MonadIO m, MonadAsyncException m, Functor m, MonadReflexCreateTrigger t m, HasDocument m, HasWebView m, HasWebView (WidgetHost m), HasWebView (GuiAction m), MonadIO (WidgetHost m), MonadAsyncException (WidgetHost m), MonadIO (GuiAction m), MonadAsyncException (GuiAction m), Functor (WidgetHost m), MonadSample t (WidgetHost m), HasPostGui t (GuiAction m) (WidgetHost m), HasPostGui t (GuiA
23:17:22 <Cale> ction m) m, HasPostGui t (GuiAction m) (GuiAction m), MonadRef m, MonadRef (WidgetHost m), Ref m ~ Ref IO, Ref (WidgetHost m) ~ Ref IO, MonadFix m) => MonadWidget t m | m -> t where
23:17:51 <Cale> This here might be a little out of hand :)
23:19:01 <kazagistar> Isn't a monad transformer always a monad with a ton of implementations? A MonadMyLibT might only really be used for one implementation, but the actual implementing objects are "any monad transformer stack that contains a MonadMyLib"
23:19:22 <jle`> not quite
23:19:31 <jle`> there are a lot of instances of MonadState that aren't monad stacks and don't involve MonadT
23:19:39 <jle`> er, StateT
23:19:43 <Cale> kazagistar: I'm secretly arguing against the traditional way in which monad transformers have been used.
23:20:10 <Cale> But you can use a monad transformer without a corresponding type class
23:20:19 <Cale> and you can use the type class without its transformer
23:20:36 <kazagistar> Cale: Decoupling a function which works on only a subset of the stack from the full transformer?
23:21:03 <Cale> I have no idea what that means. I don't even really think in terms of stacks
23:21:09 <Cale> (what stack?)
23:21:33 <Cale> You have a monad. It is constructed by the application of a bunch of monad transformers to another monad.
23:21:45 <kazagistar> right
23:22:06 <saulzar_> Cale, I think it doesn't do much for understandability all of that typeclass jazz - it's quite hard to understand how it all interacts
23:22:38 <kazagistar> I mean the typeclasses that let you access methods of your monad transformer without a million lift calls
23:22:46 <Cale> saulzar_: Yeah... I've been using Reflex at work for a bit now, and I still haven't really dug into what half of those type classes are.
23:24:13 <Cale> kazagistar: I prefer that people write a proper API for their resulting monad, and abstract over the fact that they're using monad transformers in a way that makes it hard to tell that any are in use.
23:25:00 <Cale> kazagistar: Sure lifting instances are kind of convenient for doing that bit of work, but having them around is too much of a temptation, and they end up spilling out into all the rest of the code.
23:27:47 <Cale> I don't tend to think that MonadState operations belong strewn about everywhere in your code
23:28:28 <Cale> You maybe implement a small handful of more specific things with them, and then hide the fact that you're using StateT at all.
23:29:04 <Cale> and you have better names for the operations which manipulate bits of state then
23:29:16 <Cale> If you want, you can make a type class for *those* operations
23:29:35 <Cale> But before you go doing that, try a polymorphic record data structure first.
23:29:50 <Cale> and then turn it into a type class if you get tired of passing the same value everywhere
23:30:11 <Cale> (or at least consider the option)
23:34:33 <Cale> kazagistar: A common concern is that people like the fact that programs with types like  (MonadState MyState m) => ... -> m Result  necessarily don't do IO and such, while if you put in a type which was built on top of IO, you couldn't tell that
23:35:21 <saulzar_> Cale, Most of them are totally unnecessary or used in just one case - I think most will disappear (hopefully!) 
23:36:01 <Cale> kazagistar: However, if you imagine we had a datatype like  data StateOps s m = SO { get :: m s; put :: s -> m () }  (or better yet something more application specific), then a function of type  (Monad m) => StateOps s m -> ... -> m Result   still can't do IO.
23:36:22 <Cale> At least, it can't do anything other than using the implementations of the StateOps
23:36:48 <Cale> get and put might indeed do some IO in either case, based on how the instance was written or the data structure filled out
23:37:54 <Cale> But with the data structure case, we can write things like   ioRefOps :: IORef s -> StateOps s IO
23:38:33 <Cale> So I guess it is a bit more flexible, but I think that's useful flexibility in general.
23:38:54 <Cale> (and not just looseness that'll end up hurting you)
23:39:35 <Cale> and of course, if you have some monad built using StateT, you can write a value of type StateOps for that case too
23:40:23 <Cale> and it sort of becomes more obvious that StateT over IO is frivolous and the only reason we do it is that MonadState is a type class and not a data type
23:42:52 <Ongy> Hi, is there a way to recreate a type in Haskell? I want to use GHC.Event, but with base-4.8.0.0 a type and its constructors required are not exportet(Lifetime). I tried to recreate the type by copying  its code into my own source file and using unsafecoerce. This does not crash, but also doesn't work.
23:43:28 <jle`> what does "doesn't work" mean?
23:43:48 <Cale> Ongy: Yeah, you can't use unsafeCoerce for this
23:44:38 <Cale> Ongy: According to the documentation, Lifetime was introduced in 4.8.1.0
23:45:43 <Ongy> jle`: I'm not sure whether it does nothing or interprets the argument wrong, it is used as a Flag (there are only two constructors without arguments)
23:45:58 <saulzar_> Cale, At least MonadState you can abstract that way, MonadWriter seems to have quite a convoluted interface and too specific (Monoid w)
23:47:11 <Ongy> Cale: 4.8.0.0 has Lifetime internally and requires lifetime for registerFd but does not export the type in GHC.Event, (it is defined in GHC.Event.Internal or something like that)
23:48:00 <Cale> Ongy: Then that's just a bug in 4.8.0.0 and you're out of luck.
23:49:02 <Cale> At least, I'm pretty sure. I suppose if you really wanted to, you could modify base-4.8.0.0 by rebuilding the version of GHC you're using.
23:50:03 <Cale> (but then anyone using your code would need a similar modification, which might be unacceptable)
23:51:53 <Ongy> Cale: I guessed it is a big aswell. My goal is to work round that bug in some kind of hacky way (hence unsafeCoercing). I don't really want to install something locally to fix it, bit fix it in code, as far ay I understand it, the type does not exist after compilation (type erasure) so it should be possible
23:52:11 <Ongy> bug not big, stupid tochscreen
23:54:10 <Cale> The problem is that it's quite fiddly to ensure that when you define a new datatype, that GHC is really going to represent it in *exactly* the same way.
23:55:28 <Ongy> I really don't care about portability here, since it is GHC.something and this hack only targets a very specific version
23:59:29 <Cale> Ongy: actually, what happens for you?
23:59:39 <Cale> Ongy: when you try unsafeCoerce
