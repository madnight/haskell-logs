00:00:29 <athan> > mfix fail :: [String]
00:00:31 <lambdabot>  []
00:00:34 <athan> ^ weird
00:01:08 <EvanR> > fail "foo" :: [()]
00:01:10 <lambdabot>  []
00:01:48 <EvanR> > fail []
00:01:49 <lambdabot>      No instance for (Show (m0 a0))
00:01:50 <lambdabot>        arising from a use of ‚Äòshow_M624190721010978116012828‚Äô
00:01:50 <lambdabot>      The type variables ‚Äòm0‚Äô, ‚Äòa0‚Äô are ambiguous
00:01:58 <EvanR> > fail [] :: [()]
00:02:00 <lambdabot>  []
00:02:02 <EvanR> fixed point
00:02:13 <athan> that makes sense
00:08:23 <roelof> when I have this code : http://lpaste.net/142395 and im doing this in ghci quickCheck prop_my_xor I see a lot of errors. What am I doing wrong here ? 
00:09:22 <shachaf> What are you doing at all here?
00:09:40 <shachaf> Or what are you trying do, at least?
00:10:10 <roelof> found it. the test was not good. I had to do prop_my_xor b1 b2 = xor b1 b2 == my_xor b1 b2
00:10:29 <roelof> shachaf:  I tried to test my own version of xor 
00:10:43 <roelof> as a exercise of the Craft book 
00:10:46 <athan> roelof: yep :) the properties you want to prove should be taking in the data you need to evaluate over
00:10:52 <shachaf> Well, prop_my_xor doesn't use my_xor
00:12:23 <roelof> shachaf:  I already found out. This solution does work : http://lpaste.net/142396. I hope its good Haskell 
00:13:11 <shachaf> OK.
00:15:23 <roelof> any remarks what can be done "better" 
00:15:29 <solirc> jg: You either can specify '-m Foo' on the command line
00:16:33 <athan> roelof: MORE TESTS :|
00:16:41 <solirc> jg: or alternatively you can load FooSpec.hs into GHCi and run `hspec spec`
00:16:49 <pavonia> roelof: Can you find a pattern in the four cases of my_xor that helps you reducing the code?
00:18:07 <roelof> pavonia:  yes, if one of the two is True then the answer is true otherwise it's always false 
00:18:18 <solirc> jg: personally I would not use tasty-hspec
00:18:34 <roelof> athan:  what do you mean by more test. what can I test more ? 
00:21:12 <pavonia> roelof: So what would the code look like when including this fact?
00:22:51 <roelof> pavonia:  There I have to think about , I could use _ but then I have to make a difference between two equal and two different 
00:27:10 <roelof> hmm , instead of True True  and False False using b1 b1 does not work 
00:28:38 <pavonia> No, you can't have the same variable multiple times in a pattern, but you could use "b1 b2 | b1 == b2 = ..."
00:28:49 <pavonia> The part after | is called a guard
00:31:40 <MarcelineVQ> But then you have a pattern match and an additional bool check right? You could just do: foo True False = True, foo False True = True, foo _ _ = False
00:33:23 * hackagebot mwc-probability 1.0.0 - Sampling function-based probability distributions.  https://hackage.haskell.org/package/mwc-probability-1.0.0 (JaredTobin)
00:33:40 <roelof> I came up with this one : http://lpaste.net/142397
00:35:14 <MarcelineVQ> neat use of not
00:36:16 <roelof> Thanks, now testing and improving the rest of the exercises  of chapter 3 Booleans 
00:38:53 <MarcelineVQ> actually that leads to a better one
00:39:12 <MarcelineVQ> `my_xor False x = x` `my_xor True x = not x` that should work right?
00:43:25 <gfixler> did :sprint functionality change recently?
00:43:32 <gfixler> it's not updating for me
00:43:46 <gfixler> let a = [0..10], :sprint a => a = _
00:43:56 <MarcelineVQ> I thought that was just me using it wrong
00:43:56 <gfixler> but even if I show a, it still gives a = _
00:44:10 <MarcelineVQ> even using seq didn't update it for me iirc
00:44:14 <gfixler> huh
00:44:16 <gfixler> something's up
00:45:46 <Ferdirand> xor is strict in both arguments, right ? so there's not much to gain with the shortcut of your last version ?
00:46:10 <roelof> MarcelineVQ:  it looks right to me.  my_xor False False = False  my_xor False True = True  my_xor True False = not false (True) 
00:46:48 <MarcelineVQ> Ferdirand: just brevity
00:48:23 * hackagebot deepcontrol 0.1.0.0 - Enable deeper level style of programming than the usual control provides  https://hackage.haskell.org/package/deepcontrol-0.1.0.0 (KONISHI_Yohsuke)
00:49:44 <gfixler> MarcelineVQ: :sprint works in 7.6.3, my regular install, but not in 7.10.2, my latest via stack
00:53:06 <MarcelineVQ> I'm on 7.10.1 and it's had that behvoir at least since I'd had .10 so I figured I was using it wrong
00:56:42 <cocreature> gfixler: that sounds like extended default rules
00:56:53 <cocreature> gfixler: it can't show it because a has type Num a => [a]
00:57:03 <cocreature> try let a = [0..10] :: Int
00:57:15 <ttt_fff_> wtf is ($) used for ?
00:57:18 <MarcelineVQ> that seems to be the case cocreature
00:57:19 <ttt_fff_> why not just $ ?
00:57:29 <MarcelineVQ> using the lines @ https://www.reddit.com/r/haskelltil/comments/2zlq40/sprint_in_ghci_lets_you_view_thunks/ do make it work
00:58:05 <cocreature> ttt_fff_: putting brackets around any infix operator allows you to use it in a normal prefix manner
00:58:07 <MarcelineVQ> ttt_fff_: sometimes you want it to not be infix
00:59:27 <cocreature> ttt_fff_: one reason to want that is to pass it as an argument to some other function
00:59:33 <ttt_fff_> oh
00:59:39 <ttt_fff_> so this is for passing "$" as a function?
00:59:39 <ttt_fff_> ah
01:00:09 <cocreature> that's one usecase
01:00:24 <cocreature> putting parantheses around it just lets you treat it as any other normal function
01:00:53 <cocreature> you could also write ($) (+1) 1 using it as a prefix function
01:01:17 <ttt_fff_> :t ($)
01:01:18 <lambdabot> (a -> b) -> a -> b
01:05:27 <ttt_fff_> :t fmap
01:05:28 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:05:57 <MarcelineVQ> :t (<$>)
01:05:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:06:36 <joco> if i install hoogle locally then where is its databased located? the problem is that i want to limit my hoogle searches for ghcjs-dom library (which is the library that I am currently  learning) how can i limit my local hoogle searches for a given library that was installed locally? anyone doing this?
01:07:46 <joco> i have entered the command "hoogle data all" and it created a large search database... and now i want to clear this and put only ghcjs into, how can i do that ?
01:07:50 <ttt_fff_> :t ($)
01:07:51 <lambdabot> (a -> b) -> a -> b
01:09:10 <MarcelineVQ> joco: for me it's something like .cabal/share/x86_64-linux-ghc-7.10.1/hoogle-4.2.41/databases/
01:09:26 <joco> MarcelineVQ: thanks, i have a look
01:12:14 <ttt_fff_> :t (.)
01:12:15 <lambdabot> (b -> c) -> (a -> b) -> a -> c
01:16:26 <cocreature> joco: the new hoogle also allows you to put package:text in your search to search only in the text package, not quite sure if the old one supports that too
01:17:00 <joco> cocreature: how new is the new ? on hackage already?
01:17:05 <joco> which version?
01:17:10 <cocreature> nope
01:17:12 <cocreature> 5
01:17:18 <joco> i see
01:17:18 <cocreature> it's available here http://hoogle.haskell.org/
01:17:23 <joco> ok
01:17:33 <cocreature> or if you want to install it locally https://github.com/ndmitchell/hoogle
01:18:19 <joco> thanks
01:18:27 <joco> this might be handy
01:18:50 <joco> i use it in combo with haskell vim now... does it work with vim ? the new version?
01:20:08 <joco> so maybe for the sake of simplicity i just use version 4
01:20:25 <joco> and create a small core database that is important for me
01:20:41 <joco> i mean, only contains the important libs....
01:23:24 * hackagebot postgresql-schema 0.1.7 - PostgreSQL Schema Management  https://hackage.haskell.org/package/postgresql-schema-0.1.7 (markfine)
01:32:55 <joco> so i have nuked my database directory
01:35:31 <joco> is it just enough to put some .hoo files into it ?
01:46:39 <joco> ok, figured it out :)
01:58:26 * hackagebot mcmc-types 1.0.0 - Common types for sampling.  https://hackage.haskell.org/package/mcmc-types-1.0.0 (JaredTobin)
02:08:26 * hackagebot mwc-probability 1.0.1 - Sampling function-based probability distributions.  https://hackage.haskell.org/package/mwc-probability-1.0.1 (JaredTobin)
02:08:28 * hackagebot mcmc-types 1.0.1 - Common types for sampling.  https://hackage.haskell.org/package/mcmc-types-1.0.1 (JaredTobin)
02:33:26 * hackagebot lzma-clib 5.2.2 - liblzma C library and headers for use by LZMA bindings  https://hackage.haskell.org/package/lzma-clib-5.2.2 (HerbertValerioRiedel)
02:50:11 <Mayzie> How can I get the variables passed to the filter function?
02:50:55 <Mayzie> Context (where x is the variable passed to the filter function): let duplicates = filter (length (x `elemIndices` names) > 1)
02:51:47 <liste> Mayzie filter (\x -> length (x `elemIndices` names) > 1)
02:52:09 <Mayzie> There's no way without lambdas?
02:52:23 <liste> there is, but lambda is better
02:52:38 <Maxdamantus> Why x? why not length, elemIndices or names?
02:52:57 <Mayzie> What?
02:53:01 <liste> I don't think x is bad here
02:53:22 <Maxdamantus> What's special about `x` in your expression?
02:53:42 <Maxdamantus> compared to the other variables I listed.
02:55:48 <Mayzie> Well, I need some way to make it clear which predicate I wish to be used.
02:55:48 <Mayzie> There might be another way, but I am new and unfamiliar with Haskell. Still learning. :-)
02:55:48 <liste> I think `x' is just as clear as any other
02:55:48 <Mayzie> I don't know how to do it another way, though.
02:55:48 <Maxdamantus> `x` has the same level of significance to the language as any other identifier.
02:55:56 <Maxdamantus> like `length` or `names`
02:56:07 <liste> except `length' shadows an existing identifier
02:56:15 <liste> and so does `elemIndices'
02:56:26 <Mayzie> `length` and `elemIndices` are in-built Haskell functions.
02:56:36 <Maxdamantus> The only reason `x` has been singled out is because Mayzie mentioned it in the English part of his question.
02:57:13 <liste> Mayzie people learning Haskell usually try to make their functions point-free to learn how it works
02:57:15 <Mayzie> That was an example (pseudocode) of what I wanted to do.
02:57:26 <Mayzie> "point-free"?
02:57:26 <liste> you can try to do it yourself too, but the lambda one is more readable
02:57:34 <f-a> @let f as n = length . (filter id) $ map (elem (head . show $ n) . show) as
02:57:36 <lambdabot>  .L.hs:160:1: Warning:
02:57:36 <lambdabot>      Pattern match(es) are overlapped
02:57:36 <lambdabot>      In an equation for ‚Äòf‚Äô: f as n = ...
02:57:38 <roelof> Did I do this the right way : http://lpaste.net/142399
02:57:59 <liste> Mayzie as in without lambdas or explicit function arguments
02:58:08 <Mayzie> Oh
02:58:17 <Maxdamantus> @pl \x -> length (x `elemIndices` names) > 1
02:58:17 <lambdabot> (> 1) . length . (`elemIndices` names)
02:58:42 <liste> sometimes it's more readable and composable
02:58:45 <liste> sometimes not
02:59:21 <liste> (composable as in you can separate (> 1) . length as eg. a variable)
03:00:23 <Gurkenglas> roelof, you didn't adress the case that m is equal to n and n is equal to p, but m is not equal to p. In other words, you need to show the connection between "at least 2 numbers are not the same" and the cases below
03:02:24 <roelof> Gurkenglas:  I think that case never happens. When m = n and n= p, m must be equal to p , Suppose m = 1 then because m = n , n is also 1 . n = p  because n = 1, p is also 1 
03:02:50 <Gurkenglas> Yes, but you didn't say that. It is correct, but if correctness was enough for a proof you could just say what is true without a proof
03:03:27 * hackagebot mighty-metropolis 1.0.0 - The Metropolis algorithm.  https://hackage.haskell.org/package/mighty-metropolis-1.0.0 (JaredTobin)
03:03:29 * hackagebot app-settings 0.2.0.7 - A library to manage application settings (INI file-like)  https://hackage.haskell.org/package/app-settings-0.2.0.7 (EmmanuelTouzery)
03:03:53 <Gurkenglas> It's not quite enough to just paste that sentence you just told me into your proof either: You must also show that there are no other "cases that never happen" that you didn't consider
03:04:25 <roelof> oke, and how can I do that ?
03:05:56 <Gurkenglas> Your case distinction are on the values of the expressions the algorithm has access to, not the values of the variables. Map the possible values of variables to each case, and see how the values of variables correspond to the return value of the function, and you should be fine
03:06:43 <roelof> sorry, I still do not understand what you mean 
03:07:21 <Gurkenglas> Your case distinction was supposed to be on the 8 ways the function can be called. you did it on the 4 ways the evaluation of your function can look
03:08:28 <roelof> oke, then I have to think what the other cases are 
03:10:12 <roelof> Found one : m is not equal to n but m is equal to p 
03:13:21 <phaazon> hm, I‚Äôm using type families in typeclasses
03:13:40 <phaazon> and I get an ambiguous error because of the fact the type family is not injective
03:14:00 <phaazon> though, I put a proxy to make it injective, so I¬†don‚Äôt get why it‚Äôs not
03:14:03 <phaazon> I reckon that:
03:14:37 <phaazon> class Foo a where { type Bar a :: *; foo :: Bar a -> String }
03:14:51 <phaazon> here, we cannot infer a by passing Bar a
03:14:54 <phaazon> but if I do this:
03:15:00 <phaazon> foo :: proxy a -> Bar a -> String
03:15:05 <phaazon> we can infer it through proxy a
03:15:16 <phaazon> so the whole thing should work
03:15:19 <phaazon> I don‚Äôt get why it doesn‚Äôt
03:16:03 <quicksilver> paste code and error phaazon ?
03:16:39 <roelof> Gurkenglas:  where do you get 8 off . I see only 6 cases where some are cases which never happens or copies of old ones  
03:17:17 <phaazon> quicksilver: http://lpaste.net/6419301327972597760 code here
03:17:23 <phaazon> quicksilver: http://lpaste.net/6673273395703971840 error here
03:17:53 <Gurkenglas> > replicateM 3 [True, False] -- roelof, there, 8 cases of 3 bools
03:17:54 <lambdabot>  [[True,True,True],[True,True,False],[True,False,True],[True,False,False],[Fa...
03:18:01 <Gurkenglas> > length $ replicateM 3 [True, False] -- roelof, there, 8 cases of 3 bools
03:18:02 <lambdabot>  8
03:18:16 <quicksilver> phaazon: you need an explicit forall
03:18:22 <phaazon> for t?
03:18:28 <quicksilver> phaazon: and you need the ScopedTypeVariables extension
03:18:31 <quicksilver> otherwise t isn't t
03:18:34 <phaazon> I already have it
03:19:08 <phaazon> oh you mean
03:19:09 <quicksilver> that is, the 't' on line 251
03:19:13 <quicksilver> isn't the 't' on line 244
03:19:14 <phaazon> to match both the t
03:19:18 <phaazon> I‚Äôm stupid, yeah.
03:19:19 <roelof> oke, thanks, I will run this locally and solve this 
03:19:21 <quicksilver> unles you put an explicit forall in the signature
03:19:30 <quicksilver> I don't think that's stupid :) it's a kinda weird feature
03:19:30 <phaazon> I always thought it works out of the box with ScopedTypeVariables
03:19:35 <phaazon> but we need forall to make it work
03:19:43 <quicksilver> you need forall to 'turn it on'
03:19:46 <phaazon> yeah
03:19:50 <quicksilver> otherwise it would break backwards compatibility
03:19:52 <phaazon> like my createTexture function
03:19:59 <phaazon> line 130
03:20:03 <phaazon> well, 125
03:20:04 <quicksilver> yes
03:20:11 <phaazon> thanks :D
03:20:18 <quicksilver> you're welcome.
03:20:33 <phaazon> fixed, neat! :)
03:21:02 <delYsid> How do I combine a list of parsers with <|> ?
03:21:20 <phaazon> delYsid: foldl1 (<|>) ?
03:21:34 <phaazon> or join, I guess
03:21:42 <phaazon> if the parsers are monadic
03:21:59 <phaazon> wait, not join, type mismatch
03:22:10 <phaazon> it‚Äôd be more something like mconcat, or that kind of stuff
03:23:55 <delYsid> Hmm, lets try this, that looks good.
03:24:46 <roelof> Gurkenglas:  Do I have to import Control.Monad to run this in ghci  ? 
03:25:55 <roelof> Gurkenglas:  yes, I did need it 
03:26:32 <Gurkenglas> im not saying you are to use that in your code, iw as only illustrating how there were 8 cases
03:27:38 <SX> hi guys! could you please help a little?
03:27:58 <dbushenko> what happened?
03:29:00 <SX> I have a lib with "type Password = ByteString" and can't make Aeson automatically use ByteString parser for it
03:29:36 <timothyh> anyone used ghc on netbsd?
03:30:04 <SX> GHC says "Couldn't match type 'ByteString' with 'Parser Password' ..."
03:30:45 <pavonia> SX: Paste the code please
03:30:52 <pavonia> @lpaste
03:30:52 <lambdabot> Haskell pastebin: http://lpaste.net/
03:38:29 * hackagebot scientific 0.3.4.1 - Numbers represented using scientific notation  https://hackage.haskell.org/package/scientific-0.3.4.1 (BasVanDijk)
03:41:43 <SX> http://lpaste.net/142402
03:42:06 <SX> Simplified example, uses snmp package
03:43:08 <SX> No instance for (FromJSON S.Password) arising from a use of '.:'
03:48:29 * hackagebot shake-language-c 0.8.2 - Utilities for cross-compiling with Shake  https://hackage.haskell.org/package/shake-language-c-0.8.2 (StefanKersten)
03:50:03 <pavonia> SX: There doesn't seem to be an instance for ByteStrings
03:53:29 * hackagebot intricacy 0.5.7.2 - A game of competitive puzzle-design  https://hackage.haskell.org/package/intricacy-0.5.7.2 (mbays)
03:54:02 <toelof> Gurkenglas:  this one better : http://lpaste.net/1781373969899716608 . I miss one case and I hope I can figure out which one 
03:56:42 <merijn> toelof: I would take a different approach and throw out all the complex reasoning
03:57:09 <Gurkenglas> toelof, here is what I meant by "8 cases": http://lpaste.net/142403
03:57:34 <merijn> > let mystery n m p = length (group [n,m,p]) >= 2 in mystery 2 3 4
03:57:35 <lambdabot>  True
03:57:37 <Gurkenglas> You can explain how each of those 8 cases fits under one of your original 4, or you can do the computation for each one
03:57:38 <merijn> > let mystery n m p = length (group [n,m,p]) >= 2 in mystery 2 3 2
03:57:40 <lambdabot>  True
03:57:46 <merijn> > let mystery n m p = length (group [n,m,p]) >= 2 in mystery 2 2 2
03:57:48 <lambdabot>  False
03:57:53 <Gurkenglas> Oh wait damn I'm stupid
03:57:58 <Gurkenglas> It's not on bools
03:59:12 <Gurkenglas> merijn, he is to figure out what mystery does and prove it.
04:00:48 <SX> pavonia: seems so.. thanks!
04:02:09 <Gurkenglas> Still, toelof, according to your last approach, the case you missed would be "m /= n, n /= p, p == m"
04:03:06 <Gurkenglas> (Luckily it's still 8 cases even with my mistake :D)
04:03:19 <toelof> oke, also a case which never will occur.
04:03:24 <Gurkenglas> (although the possible values of the variables are, as they are ints, beyond counting)
04:03:35 <toelof> Nut for clarity I try to solve this one : http://lpaste.net/142406
04:04:06 <Gurkenglas> If that's what your task says, why'd you try to prove it?
04:06:22 <toelof> because I can and to see if im right with what I thought mystery schould do 
04:06:47 <Gurkenglas> toelof, how do you know that case won't occur?
04:07:28 <toelof> its mathematical not possible 
04:07:34 <Gurkenglas> Prove it.
04:07:43 <Gurkenglas> And I'll send you 10 $ on paypal
04:08:13 <toelof> I did on the sentence after the cases that not possible 
04:08:27 <Gurkenglas> Do it again for this one
04:09:55 <toelof> Im wrong this case can happen 
04:12:50 <Gurkenglas> (To prove the reducibility of the problem to 8 cases, one would have to say why the algorithm and what you think it does both only depend on the values of == between each pair of arguments)
04:13:30 * hackagebot shake-language-c 0.8.3 - Utilities for cross-compiling with Shake  https://hackage.haskell.org/package/shake-language-c-0.8.3 (StefanKersten)
04:16:06 <toelof> Another question about quickCheck, Can I see which numbers are used on a test 
04:23:43 <liste> toelof quickcheck should show them on failing tests
04:24:27 <toelof> oke, so I cannot see it on tests that are valid
04:24:59 <liste> toelof you can with verboseCheck
04:25:17 <liste> https://hackage.haskell.org/package/QuickCheck-2.8.1/docs/Test-QuickCheck.html -- not sure how to enable it with other tools though
04:25:23 <liste> but there should be a way
04:31:09 <toelof> leste thanks I found a way 
04:36:03 <toelof> Thanks all. I call it a day, Time for a lunch :)
04:59:45 <phaazon> I just had a look at Rust tutorial, and it sounds pretty meh afterwards
05:06:54 <SX> tell me please, are lambda case and pattern match (for single argument) the same thing?
05:07:49 <merijn> SX: Yes
05:08:03 <delYsid> phaazon: (foldl (<|>) empty) was what I needed, thanks for the hint!
05:08:10 <merijn> SX: In that, the compiler translates all pattern matches into nested case-of internally
05:08:34 <phaazon> delYsid: :)
05:08:51 <Gurkenglas> :t asum -- delYsid
05:08:52 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
05:09:01 <SX> oh, ok. I just don't like to repeat function name all the time for cases. Thanks!
05:09:16 <merijn> "foo (Just n) (Just m) = blah" -> "foo = \x -> \y -> case x of Just n -> case y of Just m -> blah"
05:09:43 <delYsid> Gurkenglas: Thanks.  BTW, I finally figured out what you were trying to help em two days ago.  It was actually a bit more involved then the simple runStateT approach.  If you care to see it, let me know.
05:10:01 * Gurkenglas lets you know
05:11:04 <delYsid> https://github.com/mlang/hbmc/blob/master/Haskore/Interfa\ce/Braille.hs <- Read function vs.
05:11:20 <delYsid> It is three nested dos now
05:11:37 <Gurkenglas> What was the problem?
05:12:16 <delYsid> Gurkenglas: Hard to explain, the resulting data structure was inverted.  I guess we were missing a sequence somehwere.
05:12:25 <delYsid> er, concat I mean.
05:13:06 <delYsid> I had to explicitly unwrap the Either and List monads in different do blocks.
05:13:19 <delYsid> Gurkenglas: thanks for asum.
05:14:15 <delYsid> :info asum
05:14:40 <liste> @src asum
05:14:40 <lambdabot> Source not found. Take a stress pill and think things over.
05:15:15 <aweinstock> (foldl <|> empty) `asTypeOf` asum
05:15:20 <aweinstock> :t (foldl <|> empty) `asTypeOf` asum
05:15:21 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ t a -> a
05:15:21 <lambdabot>     Expected type: (a -> a -> a) -> a -> t a -> a
05:15:21 <lambdabot>       Actual type: (a -> a -> t a -> a) -> a -> t a -> a
05:15:35 <aweinstock> :t (foldl (<|>) empty) `asTypeOf` asum
05:15:37 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
05:17:32 <obadz> so when doing stack build on windows, if one of my dependencies needs an extra flag such as --extra-lib-dirs, how can I pass it?
05:18:26 <malorie> hi all. how would I setup a data-type with multiple representations, that each get updated appropriately if the value is changed?
05:19:06 <malorie> e.g., a data-type for color, with RGB, CMYK, etc. representations
05:19:23 <tdammers> you don't
05:19:29 <tdammers> values don't change
05:19:34 <liste> malorie rgb :: Color -> (Int, Int, Int), cmyk :: Color -> (Int, Int, Int, Int) ?
05:19:41 <tdammers> ^ that would work
05:20:01 <tdammers> alternatively: data RGB = RGB Int Int Int; data CMYK = CMYK Int Int Int Int
05:20:11 <tdammers> and then write conversion functions back and forth
05:20:17 <merijn> Define a single representation and define a lens for different representations :)
05:20:47 <tdammers> or pick one representation and implement your transformations as lenses
05:20:56 <merijn> I remember edwardk showing a "Temperature" datatype and having a Fahrenheit and Celsius lens :)
05:21:09 <liste> or Iso/Prism ?
05:21:09 <Ferdirand> if you take liste's approach, you can have smart constructors that accept some representation and fill the other slots with the appropriate conversion functions
05:21:25 <tdammers> if the conversion is lossy, you may want to have conversions both ways
05:21:59 <malorie> hm
05:22:21 <Ferdirand> By the way: hello #haskell. If I have a function f x y = cheap_computation (expensive_computation x) y, then define g = f a, can I expect expensive_computation to run only once if I call g multiple times ? does it make any difference if I define f a = \b -> ... instead ?
05:24:18 <ggole> Ferdirand: it'll run multiple times. And the first is pretty much syntactic sugar for the second.
05:24:35 <tdammers> in other words, there is no automatic memoization
05:25:06 <merijn> I'm pretty sure you're not right
05:25:18 <merijn> I'm pretty sure it only run expensive_computation once, but not 100%
05:25:27 <merijn> Ferdirand: Might wanna try #ghc
05:25:32 <albertus1> once for every distinct x, i'd guess
05:26:48 <obadz> is there a way to tell cabal to statically link certain C libraries?
05:27:26 <merijn> obadz: Just pass in the right linker flags?
05:27:59 <obadz> merijn: in ld-options ?
05:28:08 <merijn> obadz: GHC just uses the system linker, so it should be the same as with C
05:28:16 <merijn> obadz: Yeah, presumably
05:28:28 <obadz> I'm building on windows :-(
05:28:41 <merijn> obadz: Well, in that case I have no clue :p
05:28:56 <merijn> Try the mailing lists/#ghc, there seems to be some windows expertise around
05:29:12 <obadz> thx
05:29:24 <obadz> let me first see if I can build thing thing at all :)
05:33:08 <Yuras> obadz: ld-options may not work because of the order of arguments
05:33:10 <Yuras> https://mail.haskell.org/pipermail/glasgow-haskell-users/2014-April/024861.html
05:33:59 <merijn> Yuras: The linux linker's idiocy was the bane of my master thesis :\
05:34:28 <Yuras> :)
05:37:11 <obadz> aargl looks like hmatrix 0.16.1.5 does not build on windows :-(
05:37:24 <obadz> but that's the version in stackage
05:37:50 <obadz> is there a way to tell stack to upgrade just that package?
05:38:49 <Gurkenglas> Does ghc-mod build on windows for anyone else?
05:38:58 <Gurkenglas> It fails at old-time for me
05:41:28 <obadz> windows is such a pain :-(
06:00:28 <mietek> Is there a way to relax Haskell‚Äôs uppercase/lowercase restrictions on naming constructors/functions?
06:00:53 <merijn> mietek: Not unless "write a compiler that compiles not-haskell to haskell" is a valid answer
06:00:55 <mietek> I have some "smart constructors" which end up lowercase, and so, I create pointless little functions which simply map to the corresponding constructor, in order to keep everything lowercase
06:01:02 <mietek> Right.
06:01:08 <quchen2> mietek: PatternSynonyms
06:01:57 <merijn> mietek: If you're using smart constructors, I need feedback/comments on how useful you find this and what you're missing: https://hackage.haskell.org/package/validated-literals :)
06:02:25 <mietek> merijn: I don‚Äôt have any validation; just type conversion
06:02:27 <mietek> quchen2: hm
06:02:33 <merijn> mietek: Ah, blah
06:03:58 <ggole> mietek: lowercase constructors would make it very easy to accidentally typo something into being a variable on the lhs of a pattern
06:04:15 <ggole> SML had this problem, and it was considered enough of a flaw to be changed in every subsequent ML family language (afaik)
06:04:26 <mietek> ggole: Agda deals with it
06:04:38 <ggole> Oh? How?
06:04:49 <mietek> ggole: grins and bears it!
06:04:58 <mietek> There are hardly any syntactic restrictions
06:04:59 <ggole> Meh.
06:05:31 <mietek> ggole: I don‚Äôt think this sort of error would go undetected
06:05:35 <ggole> I guess I shouldn't criticise that choice until I've tried it.
06:06:49 <merijn> I kinda like haskell constructor vs variable case restriction
06:07:07 <mietek> ggole: typo-ing "zero" (a Nat constructor) to "zer" gives "Unreachable clause when checking the definition of _+_"
06:07:08 <merijn> The only think I dislike is type families also starting uppercase despite not being constructors
06:07:37 <Gurkenglas> Can Leksah show me the type of a selection?
06:07:44 <mietek> merijn: I highly dislike having to prefix type operators with a ":"
06:08:05 <merijn> mietek: You don't have to anymore
06:08:18 <mietek> merijn: oh. Which GHC?
06:08:38 <ggole> mietek: mmm, it's possible that most of the errors that would silently pass in SML would be caught by more precise types
06:08:45 <merijn> 2 or 3 releases ago?
06:08:48 <mietek> hrm
06:09:09 <obadz> Is it possible, in my own cabal file, to add flags and extra-lib-dirs to other cabal packages?
06:11:20 <mietek> merijn: not 7.8.4...
06:11:57 <merijn> mietek: Type operator or type operator constructor?
06:12:02 <mietek> uh.
06:12:09 <mietek> Type operator constructor, yes.
06:12:22 <merijn> Constructors still need :
06:12:27 <merijn> Just type operators dropped :
06:12:29 <mietek> :(
06:13:13 <quchen2> merijn: Why are you using a typeclass in your validation package? Explicit passing of a validation predicate is probably much closer to what you want.
06:13:35 * hackagebot ede 0.2.8.4 - Templating language with similar syntax and features to Liquid or Jinja2.  https://hackage.haskell.org/package/ede-0.2.8.4 (BrendanHay)
06:13:42 <mietek> quchen2: do you have an example of using PatternSynonyms in mind?
06:13:48 <quchen2> No. :-√æ
06:14:07 <quchen2> mietek: PatternSynonyms allow you to write upper-case things that you can use similar to constructors, that's all
06:14:17 <Gurkenglas> ghc-mod doesn't build for me: old-time fails. Once, ghc-mod built. How do I tell stack to install ghc-mod using the stuff that existed back then? http://pastebin.com/DTN4E8tX doesn't work.
06:14:27 <quchen2> So for example, you can use them to hide smart constructors
06:16:57 <athan> quchen2: Only for pattern matching, though, right? You can't construct data, but only deconstruct it?
06:17:56 <quchen2> There are bidirectional pattern synonyms too, but those are somewhat restricted.
06:18:13 <quchen2> If you actually want to upper-case your smart constructor that's going to be hard.
06:18:20 <quchen2> CPP? ;-)
06:18:29 <athan> :|
06:18:35 * hackagebot HaRe 0.8.1.1 - the Haskell Refactorer.  https://hackage.haskell.org/package/HaRe-0.8.1.1 (AlanZimmerman)
06:18:54 <athan> Lots of work on HaRe lately, I'm going to have to check it out
06:19:03 <athan> (and see if ide-backend can shake a stick at it)
06:19:07 <mietek> athan, quchen2: I would be fine with just constructing
06:19:26 <mietek> But I can‚Äôt seem to figure out the syntax for actually defining pattern-only or unidirectional pattern synonym...
06:19:32 <mietek> Is that implemented?
06:19:54 <mietek> There‚Äôs quite a bit of stuff on https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms
06:19:57 <quchen2> Hm?  pattern Head x <- x:xs
06:20:02 <quchen2> That's unidirectional
06:20:09 <mietek> Oh dear.
06:20:14 <quchen2> And pattern only (which is what unidirectional means)
06:20:36 <quchen2> Bidirectional would be "pattern List x xs = x:xs"
06:20:42 <quchen2> See https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#pattern-synonyms
06:20:47 <mietek> quchen2: so, only constructors on the RHS?
06:22:13 <mietek> One of my "smart constructors" is  lam f = Lam $ \x -> f (var x)
06:22:20 <mietek> Doesn‚Äôt seem like that‚Äôd work as a pattern
06:25:24 <quchen2> You can't deconstruct a lambda, no
06:25:45 <mietek> Thanks, though. These‚Äôll come in useful.
06:26:16 <mietek> (Ah, but I don‚Äôt even want to deconstruct the lambda...)
06:26:24 <mietek> (But ISWYM.)
06:27:14 <quchen2> mietek: This ticket on explicitly bidirectional patterns gives an example of what I meant: https://ghc.haskell.org/trac/ghc/ticket/8581
06:27:24 <quchen2> This does the trick for Seq's smart constructor <|.
06:28:45 <quchen2> You essentially use a view pattern to define the deconstruction, and a pattern-where to define the construction. In the end, you have a constructor-y thing.
06:29:08 <mietek> Thanks.
06:36:54 <quicksilver> see also 'prism' from lens for a different notion of constructor-y thing
06:38:16 <obadz> In cabal, is there a way to build-depends: packageX with-extra-libs=blah... with-flag=blah
06:38:19 <obadz> ?
06:38:33 <dcoutts> obadz: no and this is a deliberate restriction
06:38:57 <dcoutts> the restriction allows translating cabal packages into distro binary packages
06:39:40 <dcoutts> obadz: library packages are not supposed to change their API depending on flags, so it should be unnecessary for another package to want to depend on a lib with a particular flag set.
06:39:42 <obadz> dcoutts: finally managed to build hmatrix on windows ;-) but now have to pass a bunch of args everytime I invoke stack build
06:39:52 <obadz> was hoping to be able to put these things in a config file..
06:40:14 <dcoutts> obadz: I'm not sure about stack, but with cabal you can put them into a local cabal.config file.
06:41:52 <obadz> dcoutts: ah let me look that up
06:42:08 <dcoutts> obadz: so the rule is that the person building the packages can specify all these things, e.g. on the command line or in cabal.config files, but the package author cannot specify those things
06:42:11 <borkdude> can someone give me a hint how I get from ['a',' ', ' '] to [['a', 'a', ' '], ['a', ' ', 'a']]? I already have one solution but that one uses list ++ a list of a single char, I'm looking for a more efficient solution
06:42:23 <dcoutts> obadz: it's part of the division of roles between the package author and package builder
06:42:49 <athan> obadz: You might be able to find some info in the stack.yaml, too
06:42:52 * athan hides :x
06:43:36 * hackagebot ansigraph 0.1.0.0 - Terminal-based graphing via ANSI and Unicode  https://hackage.haskell.org/package/ansigraph-0.1.0.0 (Cliff_Harvey)
06:45:08 <obadz> dcoutts: can't find much about cabal.config while googling. is there a doc you'd recommend?
06:45:52 <dcoutts> obadz: it's the same syntax as your global ~/.cabal/config, and it corresponds (almost) 1:1 with what you see in: cabal configure --help
06:46:22 <dcoutts> erm, actually cabal install --help (which a superset)
06:47:40 <dcoutts> obadz: e.g.    extra-lib-dirs: blah
06:47:48 <dcoutts> in a local cabal.config file
06:53:03 <Gurkenglas> :t \(x:xs) -> [xs & ix i .~ x | i <- [0..length xs - 1]] -- borkdude, you mean this?
06:53:04 <lambdabot> [a] -> [[a]]
06:54:22 <Gurkenglas> :t \xs@(x:_) -> [xs & ix i .~ x | i <- [1..length xs - 1]] -- borkdude, this I mean because you want the head in there too.
06:54:23 <lambdabot> [a] -> [[a]]
06:55:26 <obadz> dcoutts: thanks!
06:56:11 <borkdude> Gurkenglas from which package is .~ ?
06:56:17 <Gurkenglas> lens
06:56:31 <mnoonan> I'm having a disturbing laziness issue that I'm hoping somebody can help with.  Unfortunately I haven't been able to generate a MWE, so I'm hoping somebody has an idea based on this description:
06:57:13 <Gurkenglas> This one should go across xs for each index and change one element; quadratic runtime in total, but the output takes quadratic time anyway.
06:58:09 <mnoonan> I'm doing something like "result <- mapM f xs; let (y,z) = unzip x; let y' = concat y;" where f has type X -> IO ([String], something)
06:58:53 <mnoonan> f runs a shell command using System.Process.system and, if the process succeeds, reads the contents of a file and unlines it to get the [String]
06:59:42 <mnoonan> The problem is that y' is showing up as [] unless I force evaluation of the [String] inside of f
07:00:10 <mpickering> why do people in general not like depending on the GHC API?
07:02:33 <lyxia> mnoonan: Can you show the definition of f?
07:03:14 <luite> mpickering: the main reason is probably that it's not really been designed as a library. you get to poke at the GHC internals, but the API is unstable, documentation is often sparse and the library is massive
07:03:20 <borkdude> Gurkenglas interesting, thanks
07:03:20 <lyxia> mnoonan: Are you reading the files lazily?
07:03:52 <mnoonan> luite: http://lpaste.net/142411
07:03:58 <merijn> mpickering: Because GHC API is explicitly not stable
07:04:07 <merijn> mpickering: So you can expect to patch and fix your code every release
07:04:22 <mnoonan> lyxia: yes (readFile), but the results do eventually get used no matter what.
07:04:35 <mpickering> releases only happen once a year, I would argue that `lens` changes the API far more often
07:05:16 <mpickering> is the problem not more that you're expected to support the last 3 versions of the library?
07:05:46 <qnikst> if I want to have detailed profiling info for executable B that depends on A, should I build A with -caf-all -auto-all or building B with that options is enough?
07:05:58 <luite> mpickering: that's not really true, the API breaks between minor releases too
07:06:00 <qnikst> I'm interested in detailed reports for functions from A
07:06:39 <luite> ghcjsi doesn't build with 7.10.2 for example, but does with 7.10.1 (although there's a pull request that fixes this)
07:06:43 <alanz> luite, mpickering: I think there is some thinking towards something similar to libtooling from clang: http://clang.llvm.org/docs/Tooling.html
07:06:50 <luite> 7.8.x also had minor releases break the api that ghcjs uses
07:07:32 <luite> not that that's a huge problem for a project like ghcjs, but it's definitely something to take into consideration
07:10:48 <merijn> mnoonan: Use the strict version of readFile instead of the default lazy IO one
07:15:03 <mnoonan> merijn: ok, but can you explain why it works like this? I would have assumed that the lazy version would still eventually read the results (maybe leaking file handles in the meantime or something)
07:17:21 <bennofs> mpickering: also, the GHC API is not particular nice to use. It's quite lowlevel, more than most projects need
07:55:21 <obadz> trying to build an application using hmatrix (which uses lapack or openblas) on windows, I'm getting the following linker error: Z:\.stack-work\install\i386-windows\lts-3.8\7.10.2\lib\i386-windows-ghc-7.10.2\hmatrix-0.17.0.1-BkLqp7XxMCtFB862GgyGAx/libHShmatrix-0.17.0.1-BkLqp7XxMCtFB862GgyGAx.a(vector-aux.o):vector-aux.c:(.text+0x5a52): undefined reference to `nrand48' collect2: ld returned 1 exit status
07:55:31 <obadz> any idea what I should be doing?
07:55:50 <obadz> (builds fine on Linux, I get the same error using both OpenBlas and the lapack binaries)
07:57:54 <mauke[1]> probably get an implementation of nrand48 from somewhere
07:58:20 <bartavelle> mpickering, while the lens API change a lot, the basic stuff hasn't changed for a while ... I can only think of the At/Ix/Contains thingie
08:01:31 <kstt> hi. What would you use to pretty print large numbers in Haskell please. Like 123456 => 123k , 123456789 => 123M and so ?
08:02:33 <kstt> I can roll my own method, fwiw, but I'd prefer a std package well designed
08:02:41 <johnw> kstt: https://gist.github.com/f94b8bf00375a43bb8b9
08:03:10 <johnw> den should be either 1000 or 1024
08:03:22 <kstt> sh*it johnw this is too fast
08:04:01 <kstt> thank you very much
08:05:48 <obadz> mauke[1]: looks like they should be in stdlib
08:06:35 <SX> how to use Aeson correctly for dynamic nodes? Like bind to already defined Data with multiple constructors.
08:07:50 <SX> line Data Many = One {..}, Two {..}, Three {..}
08:07:53 <SX> like*
08:08:32 <mauke[1]> obadz: on windows?!
08:09:13 <SX> Node can be one of them
08:10:33 <SX> I can decide which one it is based on some common fields
08:10:47 <fractalsea> When the pipes/conduit libraries say ‚Äúconstant memory‚Äù do they mean that the data is streamed into the same location in memory, overwriting previously loaded data, thus removing the need for new memory allocations, and thus removing the need for garbage collection?
08:11:00 <johnw> no
08:11:01 <Welkin> SX: you mean a sum of products?
08:11:13 <obadz> mauke[1]: well on windows I'd assume they should be in whatever compatibility library we replace stdlib with
08:11:20 <johnw> fractalsea: it means that you are streaming X, only one X is ever necessarily live
08:11:34 <johnw> whether GC chooses to reuse old memory for the previous X is an operational matter
08:11:55 <Welkin> SX: you simply define a FromJSON instance for each constructor
08:12:12 <Welkin> er, define the FromJSON instance for the type, and then parseJSON for each constructor
08:12:24 <fractalsea> johnw, OK, and what do you mean by it being ‚Äúlive‚Äù?
08:12:41 <johnw> "resident on the stack or heap"
08:12:43 <SX> I have some already defined data, let's call it Config. It has several constructors.
08:12:46 <johnw> live GC pointer
08:13:06 <johnw> something which has been allocated, but can't yet be freed
08:13:22 <fractalsea> johnw, OK, I think I have some reading to do
08:14:17 <fractalsea> johnw, I see, so the GC actually has to do roughly the same amount of work, whether the data has been streamed, or the whole datastructure loaded at the same time
08:14:22 <SX> Not that easy, I think. parseJSON takes object, so no pattern match here...
08:14:35 <johnw> fractalsea: that's assuming that objects are being allocated at all, which is not a fair assumption
08:15:24 <johnw> fractalsea: there are some pipelines which may ultimately result in no memory being used at all, thanks to stream fusion.  conduit especially has special support in place for this; pipes has it with the new 'streaming' package for some constructions
08:15:42 <fractalsea> johnw, the reason I am looking into this is because there is a part of my program that is serialising haskell objects, and the calls to toByteString are allocating the majority of the memory, and I would like to reduce this if possible
08:16:03 <fractalsea> johnw, great, that is the kind of thing I was hoping to use
08:18:14 <obadz> I submitted an hmatrix issue re my windows build problem: https://github.com/albertoruiz/hmatrix/issues/154
08:23:00 <kriztw> Has anyone tried running stack with a detailed-0.9 test-suite? I'm trying to use stack with a cabal project, and it keeps saying that the test suite executable cannot be found
08:24:04 <SX> Welkin: any thoughts?
08:27:01 <Welkin> SX: I just told you how to do it
08:27:10 <Welkin> SX: have you looked at the Aeson docs?
08:27:15 <Welkin> they include a tutorial
08:27:30 <Welkin> https://hackage.haskell.org/package/aeson-0.10.0.0/docs/Data-Aeson.html
08:28:40 * hackagebot binary-tagged 0.1.2.0 - Tagged binary serialisation.  https://hackage.haskell.org/package/binary-tagged-0.1.2.0 (phadej)
08:29:00 <SX> parseJSON (Object v)
08:29:44 <SX> so if it fails, then all parse will fail
08:30:23 <SX> so I can't just define parseJSON for all constructors of my type
08:30:40 <phadej> use some tag in json structure for sum types
08:31:02 <dcoutts> fractalsea: if you serialise with the binary lib, or the Builder monoid in bytestring, that can run in constant memory too
08:31:16 <dcoutts> fractalsea: which is much simpler than a conduit/pipe
08:31:27 <phadej> SX: https://github.com/bos/aeson/blob/f012d0936808224d82150292c2b866fc5d1c182c/Data/Aeson/Types/Instances.hs#L150
08:32:08 <fractalsea> dcoutts, Oh great, well we are using cereal, which I thought was using binary behind the scenes, but I could be wrong there
08:32:11 <dcoutts> fractalsea: but keep in mind, there's a difference between "bytes allocated", and "bytes resident"
08:32:11 <SX> yes, that requires additional key
08:32:26 <SX> like Config1: {..}
08:32:28 <dcoutts> fractalsea: cereal is almost identical to binary, exactly the same principles
08:32:35 <SX> Config2: {..} etc
08:32:58 <dcoutts> fractalsea: it's not surprising that you see it allocating a lot, but that doesn't mean there's a lot of memory live at any one point. You need to run a heap profile to see that.
08:33:04 <fractalsea> dcoutts, OK I will look into the differences between those
08:33:25 <phadej> SX: if your json representations are disjoint then you can do parseJSON v = parseLeft v <|> parseRight v
08:33:47 <fractalsea> dcoutts, I see. So it should be working then. I will run a heap profile now and check
08:33:52 <phadej> SX: if you really don't want to introduce the tag, which i'd recommend for redundancy
08:34:42 <SX> oh, that's it! totally missed that part. thank you!
08:36:04 <SX> one more thing I'd like to know: I can't define context-sensitive parsers, can I?
08:36:44 <SX> "parse this as A if field1=="" or as B if filed1=="1""
08:38:40 * hackagebot luminance 0.3 - Type-safe, dependently-typed and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.3 (DimitriSabadie)
08:43:40 * hackagebot luminance-samples 0.2.0.2 - Luminance samples  https://hackage.haskell.org/package/luminance-samples-0.2.0.2 (DimitriSabadie)
08:58:41 * hackagebot mfsolve 0.3.1.0 - Equation solver and calculator ‡ la metafont  https://hackage.haskell.org/package/mfsolve-0.3.1.0 (KristofBastiaensen)
09:12:09 <Gurkenglas> I can't even install cabal-install because old-time won't build? What is this?
09:12:27 <phaazon> Gurkenglas: cabal hell
09:13:16 <Gurkenglas> phaazon, I'm using stack and "just before" renamed the ghc/ghc-mod/cabal/stack folders in %appdata%
09:13:42 * hackagebot luminance 0.3.0.1 - Type-safe, dependently-typed and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.3.0.1 (DimitriSabadie)
09:15:30 <phaazon> Gurkenglas: I have no idea, sorry :/
09:16:10 <clrnd> Gurkenglas, what's the error?
09:16:20 <anelson_> hey all, what's the simplest library to use for downloading binary data? I'm trying to use the curl module, but it returns strings instead of bytestrings, which seems to corrupt things (I want to download tarballs)
09:16:40 <clrnd> anelson_, http-client or wreq
09:17:02 <clrnd> curl returns String? that's quite bad
09:17:11 <anelson_> yeah it's horrible
09:17:15 <merijn> http-conduit
09:17:43 <clrnd> http-client is what's http-conduit uses
09:17:44 <Gurkenglas> Oh hey network doesn't build either and the whole log is long enough to go past the top of cmd http://pastebin.com/ZTAjPJEa
09:17:44 <clrnd> afaik
09:17:54 <anelson_> clrnd: thanks, I'll check it out :)
09:17:59 <tommd> orion: Ping
09:18:06 <Gurkenglas> How deprecated is the latest version of Haskell Platform?
09:18:14 <orion> tommd: pong
09:18:26 <orion> tommd: I backed out of the PR.
09:18:33 <tommd> orion: OK[
09:18:42 * hackagebot luminance 0.3.1 - Type-safe, dependently-typed and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.3.1 (DimitriSabadie)
09:18:46 <merijn> clrnd: Looks like it, yeah
09:18:50 <orion> tommd: He's right that it should be done at lifting time to avoid multiple keys mapping to same point on the lifted curve (as there's no canonical choice among those which collide, like he said), but if he's also not doing the that at lifting time, he could be leaking a small amount of information (at least w.r.t. bit 254; the first 3 bits don't matter much, they just may not add any security but would not detract either).
09:18:55 <clrnd> Gurkenglas, I'd say a lot?
09:18:57 <tommd> orion: All I was saying was that any random 32 bytes can be properly used by the operaitons consuming secret keys, since the operations themselves mask.
09:19:14 <merijn> clrnd: http-conduit has some nicer high level things a majigs by the looks of it (i.e. I think it can do https too)
09:19:21 <tommd> orion: OK.
09:19:31 <orion> tommd: I appreciate your input.
09:19:32 <clrnd> merijn, oh ofc, and wreq has lovely lenses, but hea sked for simplicity too
09:19:38 <clrnd> he asked*
09:19:53 <merijn> http-conduit is simple too, because I don't really know lenses or conduit atm :p
09:19:57 <merijn> And I managed to use it
09:20:31 <xplat> wreq discussion again, so ahma ask again if anyone knows how to inject cookies into wreq's cookie jar
09:20:32 <clrnd> ah nice then
09:20:46 <Gurkenglas> I vaguely remember "network doesn't build on windows because cygwin". Does that error look like old-time might compile with "something else than cygwin"?
09:20:55 <anelson_> blaaah, why is string still a thing?
09:21:28 <tommd> anelson_: ['h','i','s','t','o','r','y']
09:21:33 <merijn> anelson_: hysterical raisins
09:21:41 <Gurkenglas> Is there something less deprecated than Haskell Platform for windows that includes old-time and/or network?
09:21:54 <anelson_> tommd: yeah, but why is it *still* a thing? As in modern packages that use it?
09:22:09 <tommd> Dependencies, I would guess.
09:22:18 <tommd> Many of my packages are smaller than text.
09:23:14 <anelson_> for example, the reflex reactive library uses String
09:23:23 <clrnd> xplat, isn't wreq's cookieJar just http-client's?
09:23:27 <clrnd> http://hackage.haskell.org/package/http-client-0.4.11.2/docs/Network-HTTP-Client.html#t:CookieJar
09:23:58 <clrnd> oh but how do you make a new one...
09:24:06 <xplat> clrnd: don't really know how to do that with http-client either.  or how to access the cookiejar through wreq's lensy stuff.
09:24:16 <clrnd> gimme a minute
09:24:54 <johnw> "I'm looking into the cookie jar through a lens.  Yes, I'm programming, Mom."
09:26:07 <clrnd> jaja
09:26:22 <Gurkenglas> If ghc-mod isn't going to build, how should I go about getting into a state where I can do what I could do with a haskell IDE?
09:26:47 <Gurkenglas> (Is there a VM that doesn't lag, if you only need it for, say, programming)
09:26:54 <clrnd> thank's god I had a sandbox with wreq, the dep tree is gigantic
09:27:10 <xplat> yeah rly
09:27:11 <merijn> Gurkenglas: Assuming you have modern hardware VirtualBox should be fine as VM?
09:27:24 <merijn> Gurkenglas: Could also try hdevtools
09:28:42 * hackagebot ghc-simple 0.1.3 - Simplified interface to the GHC API.  https://hackage.haskell.org/package/ghc-simple-0.1.3 (AntonEkblad)
09:30:08 <Gurkenglas> hdevtools wants network too.
09:30:46 <Gurkenglas> (Why? Isn't network, like, TCP/IP stuff?)
09:32:22 <Gurkenglas> When I tried some ubuntu version for a vm it was... not unusably laggy, but annoyingly enough that I would rather not go back to it
09:32:23 <xplat> Gurkenglas: well, network can be unix sockets too
09:32:26 <geekosaur> it's also uni sockets
09:32:33 <geekosaur> *unix
09:32:44 <Gurkenglas> But I'm on Windows what do I want with unix sockets x.x
09:32:55 <xplat> also, not like people don't abuse TCP/IP for local machine services
09:32:59 <merijn> Gurkenglas: hdevtools and ghc-mod spawn daemons that your editor talks too
09:33:04 <geekosaur> "local sockets" but nobody ctually calls it local or AF_LOCAL
09:33:12 <merijn> Gurkenglas: The only sane way of talking to other processes is sockets
09:33:16 <merijn> Gurkenglas: Either unix or TCP
09:34:13 <quicksilver> xplat: it seems like you should create cookies directly (Cookie constructor is exposed) and merge them into the CookieJar with <>.
09:34:21 <quicksilver> xplat: perhaps I misunderstood the depth of your question :)
09:35:11 <Ferdirand> posix message queues aren't sane ?
09:35:23 <merijn> Ferdirand: Not if you want portability to, e.g. windows
09:35:32 <merijn> Ferdirand: TCP sockets work everywhere
09:36:25 <merijn> Ferdirand: And I don't seem to have man pages for them on OSX, so whether they're on BSD, etc. I dunno
09:36:26 <clrnd> xplat, I did it, you ahve to make a SetCookie with http://hackage.haskell.org/package/cookie-0.4.1.6/docs/Web-Cookie.html#t:SetCookie
09:36:47 <clrnd> then use http://hackage.haskell.org/package/http-client-0.4.24/docs/Network-HTTP-Client.html#v:receiveSetCookie into the CookieJar
09:36:58 <Ferdirand> merijn: you mean unix sockets work on windows ?
09:37:02 <clrnd> got by `view cookies myOptions` in wreq
09:37:12 <clrnd> something like
09:37:12 <merijn> Ferdirand: No, hence why I said TCP works everywhere
09:37:21 <Gurkenglas> Is there a linux distribution optimized for being quick in a vm?
09:37:58 <xplat> clrnd: thanks
09:38:08 <xplat> quicksilver: you too
09:38:15 <clrnd> let opts = defaults :: Options; let coo = def { setCookieName = "stuff", setCookieValue = "1234" }; let tmp = receiveSetCookie coo initReq t True; fmap pf $ view cookies opts
09:38:18 <merijn> Ferdirand: unix sockets are preferable from a security standpoint, though
09:38:29 <clrnd> initReq is a Request and t is UTCTime
09:38:34 <clrnd> gotta go now!
09:38:43 <geekosaur> freebsd has message queues but you need to load extra kernel modules and tweak sysctls to use them
09:38:49 <geekosaur> no idea about OS X
09:38:55 <merijn> Ferdirand: Also, apparently posix message queues are limited to 8kb of data
09:39:58 <Ferdirand> true, but not every use case involves sending streams
09:40:33 <Ferdirand> and arguably, when sending small messages, tcp is suboptimal, you have to do your own framing and ensure its robustness, no ?
09:41:27 <Ferdirand> (playing devil's advocate on this one, i'm very happy with 0mq on top of tcp)
09:42:11 <anelson_> if I'm using http-client, is there an easy way to tell it to follow redirects, a la `curl -L`?
09:42:58 <merijn> Ferdirand: Hence why unix sockets are preferable, they also have saner access control
09:43:20 <anelson_> I thought this might be a manager setting but I'm not seeing it there
09:43:31 <ArisFr> Hi! I'm looking for a library to represent and manipulate tables, i.e. something like R's data.frame or data.table. I see ekmett's tables library is now deprecated. Any other which I should look at? I searched on hackage and came up empty
09:43:35 <merijn> anelson_: Like I said, try http-conduit
09:43:45 <merijn> anelson_: It's higher level than http-client and afaik does follow redirects
09:43:57 <Welkin> there is also wreq
09:44:03 <Welkin> which is built on http-client
09:44:07 <anelson_> hokay
09:44:08 <anelson_> coolz
09:44:15 <dmj`> anelson_: sup G
09:44:17 <merijn> anelson_: "Download the specified URL, following any redirects, and return the response body."
09:44:20 <merijn> This function will throwIO an HttpException for any response with a non-2xx status code (besides 3xx redirects up to a limit of 10 redirects)
09:44:33 <merijn> That's the docs for http-conduit's simpleHttp
09:44:46 <merijn> (incidentally, http-conduit is also built on top of http-client)
09:45:37 <anelson_> dmj`: yo
09:45:55 <dmj`> anelson_: use servant-client, it's easier
09:46:12 <Welkin> dmj`: lol
09:46:15 <ArisFr> Anyone? Should I just roll my own?
09:46:17 <Welkin> quite the salesman
09:46:24 <jg_> hi all. I'm getting "The main module to load is ambiguous. Candidates are: " when running "stack ghci". Is there a way to specify the default?
09:46:27 <dmj`> Welkin: I get commission so, yea
09:46:37 <Welkin> servant-client was very easy to use to write bindings to the plivo api though
09:46:39 <jg_> details also here: https://github.com/commercialhaskell/stack/issues/1068
09:46:53 <Welkin> I only set it up for one endpoint
09:47:32 <jg_> reading that issue there probably isn't one yet...., nevermind then 
09:47:42 <anelson_> dmj`: what makes it easier
09:49:02 <dmj`> anelson_: you define the structure of the api you want to query at the type level, then a client gets reified for you w/ a connection manager. You can still customize the request too
09:49:12 <scshunt> I'm flying high, defying gravity!
09:49:20 <anelson_> dmj`: that doesn't sound easier :P
09:49:33 <anelson_> dmj`: I just want to hit a url and get a tarball bytestring
09:50:36 <anelson_> More or less the equivalent of `curl -L http://some/website > sometarball.tar.gz`
09:53:43 <dmj`> anelson_: type API = "some" :> "website" :> Get '[OctetStream] ByteString
09:53:44 <merijn> anelson_: FWIW, a 78 line webscraper using http-conduit: https://gist.github.com/merijn/d8188ddd129718ffcfb0
09:54:18 <dmj`> anelson_: a = client (Proxy :: Proxy api) (BaseUrl Http "some" 80)
09:54:31 <dmj`> anelson_: runEitherT a
09:55:20 <athan> Does anyone know if there's a way to query all the exports of a given module from within ghci?
09:55:30 <athan> anyone here* :)
09:55:56 <geekosaur> :browse ?
09:56:05 <anelson_> dmj`: interesting
09:56:27 <anelson_> dmj`: does it handle redirects?
09:58:15 <dmj`> anelson_: if http-client can, then it can, since it uses http-client
09:58:42 <athan> geekosaur: Oh wow that's awesome, sorry I should've went to the docs ._.
09:59:15 <anelson_> dmj`: I'm still not sure though why that's easier than just using simpleHttp :P
09:59:30 <anelson_> dmj`: it's sexier I suppose haha
10:00:46 <dmj`> anelson_: yea, for modelling APIs it's less messy, but for downloading tarballs there probably won't be much benefit
10:11:56 <RaceCondition> is there a way to use stack/Stackage instead of cabal-install to install/manage my global Haskell tools/libraries, not just the per-project ones?
10:12:43 <delYsid> Is there a typeclass which provides head and tail?
10:12:45 <RaceCondition> or should I just set up a special stack project whose `bin` is on PATH?
10:13:01 <athan> Anyone here know if there's an easy way to zip-with-remainder two lists into a list of These? Something like `[a] -> [b] -> [These a b]`?
10:13:48 <athan> delYsid: It / they would be lawless
10:13:51 <delYsid> :t zipWith
10:13:52 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
10:14:16 <athan> delYsid: No, you need the remainder of either - that's the porpose of These
10:14:52 <athan> s.t. if [a] is longer than [b], then the rest of [a] are `This (x : a)`, otherwise `That (y : b)`
10:15:15 <Gurkenglas> athan, I've heard of a neat way involving an implementation of padded infinite ZipLists
10:15:57 <Gurkenglas> @let data PaddedZiplist a = [a] :- a
10:15:58 <lambdabot>  Defined.
10:17:05 <Gurkenglas> @let derive Functor PaddedZiplist
10:17:05 <lambdabot>  Parse failed: TemplateHaskell is not enabled
10:17:18 <Gurkenglas> @undefine
10:17:19 <lambdabot> Undefined.
10:17:25 <Gurkenglas> @let data PaddedZiplist a = [a] :- a deriving Functor
10:17:26 <lambdabot>  Defined.
10:20:37 <athan> Gurkenglas: Shouldn't it be `[a] :- [a]`? For _all_ the remainder?
10:20:47 <athan> :s
10:20:59 <Gurkenglas> Wait, there's gonna be an Applicative instance, but brb
10:26:19 <umib0zu> Haskellers, do you guys develop Android apps? If so what do you use?
10:35:55 <clrnd> umib0zu, I like cordova/phonegap, but it falls short most of the times
10:36:52 <clrnd> then, just java
10:36:54 <Gurkenglas>  @let instance Applicative PaddedZiplist where pure = ([] :-); ([] :- f) <*> (xs :- x) = map f xs :- f x; (fs :- f) <*> ([] :- x) = map ($x) fs :- f a; ((f:fs) :- f') <*> ((x:xs) :- x') = let (fxs :- fx) = (fs :- f') <*> (xs :- x') in (f x : fxs) :- fx
10:36:57 <Gurkenglas> @let instance Applicative PaddedZiplist where pure = ([] :-); ([] :- f) <*> (xs :- x) = map f xs :- f x; (fs :- f) <*> ([] :- x) = map ($x) fs :- f a; ((f:fs) :- f') <*> ((x:xs) :- x') = let (fxs :- fx) = (fs :- f') <*> (xs :- x') in (f x : fxs) :- fx
10:36:58 <lambdabot>  .L.hs:152:53:
10:36:59 <lambdabot>      Couldn't match expected type ‚Äòa‚Äô with actual type ‚ÄòExpr‚Äô
10:36:59 <lambdabot>        ‚Äòa‚Äô is a rigid type variable bound by
10:38:17 <Gurkenglas> @let instance Applicative PaddedZiplist where pure = ([] :-); ([] :- f) <*> (xs :- x) = map f xs :- f x; (fs :- f) <*> ([] :- x) = map ($x) fs :- f x; ((f:fs) :- f') <*> ((x:xs) :- x') = let (fxs :- fx) = (fs :- f') <*> (xs :- x') in (f x : fxs) :- fx
10:38:18 <lambdabot>  Defined.
10:38:42 <Gurkenglas> Now ordinarily I would do deriveWrapped and work with ala but lambdabot doesn't like TH
10:38:48 <koala_man> is there a name for the mistake where you use a /= b || a /= c  which is almost always true?
10:40:56 <Profpatsch> koala_man: Boolean logic truly is the hardest part about programming.
10:41:09 <merijn> koala_man: brainfarts :p
10:41:14 <Gurkenglas> :t \xs ys -> (\(zs :- _) -> zs) $ liftA2 (,) (map Just xs :- Nothing) (map Just ys :- Nothing)
10:41:15 <lambdabot> [a] -> [a1] -> [(Maybe a, Maybe a1)]
10:41:19 <merijn> koala_man: See also the notion of "boolean blindness"
10:41:59 <merijn> koala_man: https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
10:43:45 * hackagebot eventloop 0.4.1.2 - A different take on an IO system. Based on Amanda's IO loop, this eventloop takes a function that maps input events to output events. It can easily be extended by modules that represent IO devices or join multiple modules together.  https://hackage.haskell.org/package/eventloop-0.4.1.2 (sebaslafleur)
10:46:36 <Gurkenglas> :t transpose . map (++ repeat Nothing) . (map . map) Just -- Oh hey, here's another that's basically the same, athan
10:46:37 <lambdabot> [[a]] -> [[Maybe a]]
10:47:21 <Gurkenglas> :t takeWhile (not . null . catMaybes) . transpose . map (++ repeat Nothing) . (map . map) Just -- Well this I guess
10:47:22 <lambdabot> [[a]] -> [[Maybe a]]
10:52:20 <Gurkenglas> Is there a way to find all functions of form S -> (A, S) or S -> M (A, S) for any values of the three?
10:54:56 <clrnd> Gurkenglas, I guess stackage's hoogle is the best you have atm
10:55:11 <Gurkenglas> Better than hayoo
10:55:13 <Gurkenglas> *?
10:55:30 <clrnd> mmm I'm not sure
10:58:10 <indigo945> Hello! I'm relatively new to Haskell and FP in general, and I'm trying to implement an Entity-Component-System in the language as an educational exercise, and because I feel it might allow for clean FP game development.
10:58:36 <indigo945> But I kind of stumbled on a problem: Is it possible to encode _several different_ component types for an Entity instance?
10:58:57 <indigo945> I know I can just go data Entity a = Entity a and have one type parameter, but is it possible to have several
10:58:59 <indigo945> ?
11:00:44 <hiptobecubic_> you can have many type parameters, but is that what you want here? I don't know about entity-component systems, but it sounds more like you're looking for a sum type like data Entity a b c = Comp1 a | Comp2 b | Comp3 c ....
11:01:28 <clrnd> can I fire up ghci with a git package with `stack`?
11:02:43 <hiptobecubic_> i think you can add the git url as a package in your .stack.yaml file and then use `stack ghci`, but I'm not positive about the details
11:04:14 <indigo945> @hiptobecubic: yeah, but then I couldn't add more component types later
11:04:14 <lambdabot> Unknown command, try @list
11:05:20 <indigo945> But if I create a typeclass Component and make every actual component an instance of it, that might work -- let me try, will report back
11:13:01 <ReinH>  I'm not sure ECS work very well with Haskell's type system
11:13:36 <clrnd> hiptobecubic_, indeed, I was hoping for even less work, but at least it works
11:13:50 <clrnd> you have to add it to .stack/global/stck.yaml and then `stack ghci pkgname`
11:14:40 <hiptobecubic_> clrnd, oh, if you're not in a project, yes. You'll have to modify the global one.
11:14:52 <ReinH> I think an ECS is something more like type ID = Int; data Entities = Entities { positions :: IntMap Position, health :: IntMap HP } etc
11:15:08 <hiptobecubic> I usually find it pretty easy to just checkout and stack init and stack ghci manually though
11:17:57 <clrnd> hiptobecubic, oh yeah I should have done that xD
11:18:00 <clrnd> I did it once, weird
11:18:03 <clrnd> weird me!
11:27:22 <magbo> Hello, beautiful people! How do you package GTK applications in Haskell to do binary distribution?
11:27:28 <magbo> Preferrably with stack, of course.
11:28:57 <kristof> "Intercalate is such a weird function," I thought.
11:29:15 <kristof> Then I ended up using intersperse often. And concating immediately after. Now it's not so weird.
11:31:10 <indigo945> ReinH: in practical implementation often yes, but that's not the API that an ECS should expose
11:31:49 <indigo945> an ECS has "systems", which are really just functions that take entities which have specific components as inputs and return a new list of the same type
11:32:26 <ldlework> ECS is love
11:32:38 <indigo945> for example, a "movementSystem" might take entities with velocity component and position component and return the same entities with their position offset by their velocity
11:32:50 <bitemyapp> kristof: people have reasons for things, news at 11.
11:32:50 <ldlework> Or just update the positions
11:32:54 <ldlework> oh haskell!
11:32:59 * ldlework scurries into the darkness
11:35:50 <bzf> Hiya! Is there any way to use hGetContents in a non lazy manner_
11:36:21 <ReinH> indigo945: Well, you were giving a low-level implementation so I was suggesting an alternative
11:37:34 <bzf> I'm trying to read in until EOF, split on new lines and then pass that list to my ncurses function so I need to read everything from stdin before that
11:37:37 <indigo945> ReinH: yes, thanks. Your implementation definitely works, but I'm looking for something more typesafe and subjectively "cleaner".
11:38:16 <ReinH> What is the type safety issue with mine?
11:38:50 <indigo945> I can pass an Entity that does not have a velocity into a system that only operates on Entites that _do_ have a velocity
11:39:14 <indigo945> Whether an Entity has some component or not can only be determined at runtime
11:39:41 <Shockk> indigo945: an ECS in Haskell is something I've thought about quite a bit
11:40:03 <ReinH> indigo945: Yes, that's true about ECS in general.
11:40:05 <Shockk> I don't have a solid solution that works to the level of safety I'd like ideally
11:40:23 <ReinH> The whole point is to provide a separation between entities and components
11:40:30 <dolio> bzf: You read stdin until EOF and then ncurses keeps going?
11:40:58 <indigo945> "Separation" does not necessarily imply dynamic matching of entites to components
11:41:00 <bzf> dolio: Excctly
11:41:13 <Shockk> I do wonder if something would be possible using a list of types with the DataKinds extension
11:41:26 <Shockk> being a list of components or something like that
11:41:31 <dolio> Weird.
11:41:36 <indigo945> I can have a type Entity<Velocity, Position, Health> and still have all components and systems separated from that entity
11:42:25 <ReinH> indigo945: you can do that, but that isn't an ECS system
11:42:54 <ReinH> Changing the behavior of an entity at runtime by adding or removing components is a part of ECS
11:43:30 <Shockk> although the problem with typing an entity like `Entity '[Velocity, Position, Health]` is, you can't have a list of entities then because they'll all have different types
11:43:31 <indigo945> Of most ECSs, yes, but they give up type safety for it -- which is not what I want
11:43:38 <ReinH> The whole point is to prevent that sort of combinatorial explosion of entity types and to allow runtime changes to the entities' behaviors
11:43:52 <ReinH> Yes, to do that thing, which is a thing ECS are supposed to do, you give up that type safety
11:43:56 <ReinH> You can't have your cake and eat it too
11:44:07 <bzf> dolio: http://pastebin.com/R0YSbkjG
11:44:37 <ReinH> But you still have type safety in that an entity that lacks a component will have a Nothing for its component lookup instead of a runtime error
11:44:39 <indigo945> Agreed. I understand that that feature is something to give up. But I don't think that a "combinatorial explosion" of entity types is so bad, as long as I don't have to implement all of them by hand.
11:44:56 <Shockk> you could use existential quantification to have a heterogenous list of the entities, but then you add the problem of getting those entities back out of there type-safely
11:44:59 <ReinH> Ok. I'm just saying that your system isn't a traditional ECS
11:45:12 <indigo945> Shockk: yeah, that heterogenous list problem I couldn't solve either
11:45:21 <ReinH> Shockk: You can stuff things into an HList. The problem is always getting them back out.
11:45:22 <dmead> hey channel
11:45:23 <indigo945> ReinH: Not arguing about that :)
11:45:31 <ReinH> indigo945: ok :)
11:45:32 <Shockk> ReinH: mhm
11:45:34 <dmead> i'm writting an ebuild where i need to make an external shell call before something happens
11:45:42 <dmead> to do some stuff in a dev environment
11:45:54 <dmead> is that allowed at all in ebuilds?
11:47:06 <dolio> bzf: Oh, I see. You're replacing stdin.
11:48:48 * hackagebot wai-extra 3.0.11 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.11 (GregWeber)
11:49:12 <Shockk> indigo945: if you did type entities with their components like Entity '[Velocity, Position, Health],
11:49:22 <Shockk> (and store in an h list),
11:49:28 <bzf> dolio: Yeah! It works if I pass a regular list to `runApplication` and do a `putStrLn lines` before replacing the stdin
11:49:42 <dolio> bzf: Anyhow, you can use the deepseq package to force the whole thing with the `evaluate` function.
11:50:37 <Shockk> I wonder if it might be possible to write a function, using typeclasses and instances, for any entity that has a certain component in its type list
11:51:08 <ReinH> Shockk: Yes, it would probably be something similar to extensible effects
11:52:41 <dolio> bzf: Another solution might be to use (strict) Text instead of String.
11:54:11 <dolio> If the string is going to be very big, that might be advisable anyway.
11:54:12 <Shockk> you can check if a type list has a type in it with a data family that recurses over it; and then what you might do is: 1. look up the entity 2. use Data.Dynamic.fromDyn(namic) 3. call the function you want to call
11:54:33 <joco42_> how can i search for a function that takes a given type as an argument and produces any type ? using hoogle ?
11:54:41 <Shockk> although if that function is part of a typeclass, I don't think/know that type inference for fromDynamic would work
11:54:55 <bzf> dolio: Amazing, `deeqseq` worked!
11:55:01 <joco42_> Say all the functions that take an AFunnyType and produce something ?
11:55:04 <bzf> I'm so happy right now! :D
11:55:11 <joco42_> sort of like a wildcard in Hoogle ?
11:56:11 <Shockk> indigo945: actually, the solution I've thought of trying is to have a bidirectional multimap as the ECS model
11:56:19 <indigo945> Shockk: being new to Haskell, I think we're not way out of my league
11:56:23 <indigo945> *now
11:56:59 <Shockk> something resembling something like: unique id <==> multiple components
11:57:39 <indigo945> Well, yeah, using a map is how you would often build an ECS -- why bidirectional, though?
11:59:16 <Gurkenglas> We should collectively sit down and figure out how to add that to Hoogle.
11:59:33 <Gurkenglas> https://github.com/ndmitchell/hoogle here's the hoogle source. Which of these pieces is responsible for filtering results?
11:59:52 <joco42_> Gurkenglas: so its not in Hoogle yet?
11:59:58 <Gurkenglas> I think not
12:00:03 <Shockk> it would basically mean being able to use the entity id to lookup all of its components, as well as lookup all the entity ids with a certain component type
12:00:05 <joco42_> i had that feeling...
12:00:09 <Gurkenglas> (I assume that a query is handled like: Take all functions we have, run a filter across them according to the query)
12:00:43 <joco42_> oh well... 
12:00:51 <indigo945> Shockk: true, that's more efficient, but doesn't solve the typing issue
12:00:53 <joco42_> sort of like the . in OO languages...
12:01:08 <joco42_> the missing .
12:01:16 <joco42_> intellisense...
12:02:07 <indigo945> I just read what Dynamic does -- I guess it's kind of cool for what we're trying to do, but dynamic typing is no safer than what ReinH suggested
12:03:03 <Gurkenglas> I'm just gonna guess it's in src. Everyone pick a file and look for the filterer?
12:05:06 <Shockk> indigo945: hmm, true
12:06:17 <ReinH> indigo945: yep
12:06:54 <Putis> hello
12:07:15 <Putis> I'm trying to compile some module with GHC API
12:07:21 <indigo945> Actually, using a map of entity IDs to values that may or may not be there in maps of different value types /is/ an ad hoc implementation of dynamic typing
12:07:38 <joco42_> Gurkenglas: i had my share today with compiling ghcjsi...
12:07:44 <Putis> I'm going to feed GHC with Core generated by me
12:07:52 <joco42_> time to go to bed...
12:08:07 <Putis> I'm going to start with some minimal example
12:08:29 <Gurkenglas> But who is going to add the feature to Hoogle :(
12:09:14 <Putis> So far is noticed, that function compileCoreToObj all the time ends with an runtime error and produces some *.o and *.hi files anyway
12:10:00 <Putis> but, produced interface file does not contain any fields, what makes compiled module unusuable
12:11:06 <Putis> another way I wanted to achieve my goal is using steps described here: https://wiki.haskell.org/GHC/As_a_library (the second example)
12:13:18 <Putis> I was able to print out Core produced form file, but if I'm not wrong, modyfing structures passing on between sequent calls does not effect on produced *.hi and *.o files
12:14:21 <Putis> both files are generated by `load LoadAllTargets' call, and further one does not effect on generated files
12:15:59 <Putis> on the end of my dilatation, I'm asking you for your help
12:16:30 <Putis> can You give me any advices in that topic? Am I thinking right in mentioned apects?
12:31:52 <kristof> do vector indices start at 1, or 0?
12:32:19 <tommd> zero
12:32:44 <tommd> > Data.Vector.fromList [0..10] Data.Vector.! 0
12:32:46 <lambdabot>  Not in scope: ‚ÄòData.Vector.fromList‚ÄôNot in scope: ‚ÄòData.Vector.!‚Äô
12:34:59 <zuserm> Does anyone know if it's possible to get Cabal to install shell scripts along side Haskell executable?
12:35:24 <tommd> Cabal can call out to a custom installer, so it _Can_ do basically anything.  This includes calling a makefile.
12:55:51 <stevejb> I think I have a relatively simple question about yesod and persistent-mongodb. I am trying to run a query and return the list of results as JSON. Code is here: http://ix.io/ley
13:02:26 <anelson_> hey guys anyone have problems with the tar package? I'm getting errors reading tar files that gnutar says are valid...
13:03:20 <hiptobecubic> stevejb, what's the question? You are telling it that some value has a type that it doesn't have and it's balking.
13:03:50 * hackagebot pathtype 0.5.4.1 - Type-safe replacement for System.FilePath etc  https://hackage.haskell.org/package/pathtype-0.5.4.1 (HenningThielemann)
13:04:40 <hexagoxel> stevejb: it seems likely that the type signature affects more than you expected, i suggest parentheses. i may be wrong.
13:04:58 <stevejb> hiptobecubic: I am still figuring out how to parse the error message. 
13:05:02 <hiptobecubic> stevejb, ah
13:05:05 <stevejb> hexagoxel: I will give that a try
13:05:08 <Ankhers> stevejb: When you place the `:: Type` at the end of the line like that, you are telling it that is what the runDB call should be returning.
13:05:27 <Ankhers> hexagoxel's solution should work.
13:05:50 <stevejb> Ankhers: I'll give that a try
13:05:55 <hiptobecubic> so in the line "res <- runDB $ (stuff) :: [SomeType]" it thinks that the annotation is for stuff and not res I believe.
13:06:17 <stevejb> what about something like     res :: [Entity Survey]  <-  runDB $ selectList [] [] 
13:06:41 <Ankhers> I'm not sure if you can do that.
13:07:15 <stevejb> Expected type: YesodDB App [Entity Survey], Actual type: ReaderT
13:07:15 <stevejb>                      mongoDB-2.0.7:Database.MongoDB.Query.MongoContext
13:07:15 <stevejb>                      (HandlerT App IO)
13:07:15 <stevejb>                      [Entity Survey]
13:07:59 <hiptobecubic> I don't know what a YesodDB is, but does it provide a 'lift' function?
13:08:00 <stevejb> So, it seems like the types are close, except I am in the wrong monad? (Is that how I think of ti?)
13:09:06 <stevejb> hiptobecubic: checking
13:09:31 <Ankhers> :t selectList
13:09:32 <lambdabot> Not in scope: ‚ÄòselectList‚Äô
13:09:55 <Ankhers> :t Database.Persist.Class.selectList
13:09:56 <lambdabot>     Not in scope: ‚ÄòDatabase.Persist.Class.selectList‚Äô
13:11:00 <stevejb> selectList :: (MonadIO m, PersistEntity val, PersistQuery backend, PersistEntityBackend val ~ backend) => [Filter val] -> [SelectOpt val] -> ReaderT backend m [Entity val]
13:13:29 <humanoyd> How can I convert the aeson value "Array [String "foo",String "bar"]" to [Text]?
13:14:39 <stevejb> Ankhers: So, is the idea that I need to get res out of ReaderT before returning?
13:14:45 <Ankhers> decode myJsonString :: Maybe [Text] -- humanoyd 
13:15:23 <Ankhers> stevejb: I don't really have any experience with yesod or persistent. I'm really not sure how it is supposed to work.
13:17:03 <stevejb> Ankhers: thank you anyway!
13:19:25 <Putis> I'll bump my question. Maybe someone joined and has knowledge in that topic
13:19:29 <Putis> hello I'm trying to compile some module with GHC API I'm going to feed GHC with Core generated by me I'm going to start with some minimal example So far is noticed, that function compileCoreToObj ends with an runtime error on each call and produces some *.o and *.hi files anyway However, produced interface file does not contain any item in exports field, what makes compiled module unusable Another way I tried to achieve my goal is usin
13:19:46 <Putis> ups!
13:19:51 <Putis> hello
13:19:54 <Putis> I'm trying to compile some module with GHC API
13:19:58 <Putis> I'm going to feed GHC with Core generated by me
13:20:03 <Putis> I'm going to start with some minimal example
13:20:06 <Putis> So far is noticed, that function compileCoreToObj ends with an runtime error on each call and produces some *.o and *.hi files anyway
13:20:11 <Putis> However, produced interface file does not contain any item in exports field, what makes compiled module unusable
13:20:16 <Putis> Another way I tried to achieve my goal is using steps described here: https://wiki.haskell.org/GHC/As_a_library (the second example)
13:20:20 <Putis> I was able to print out Core produced form file, but if I'm not wrong, modifying structures passing on between sequent calls does not effect on produced *.hi and *.o files
13:20:24 <Putis> both files are generated by `load LoadAllTargets' call, and further one does not effect on generated files
13:20:27 <Putis> on the end of my dilatation, I'm asking you for your help
13:20:30 <Putis> can You give me any advices in that topic? Am I thinking right in mentioned apects?
13:23:14 <lynnard> when doing concatenation like [a] ++ [a]; is it really inefficient?
13:23:51 <lynnard> since it's a lazy language -- doesn't it mean the second list won't be evaluated until the first one is exhausted?
13:24:12 <Hijiri> I didn't think I'd find a use for the tardis monad/applicative/functor
13:24:13 <lynnard> so in this regard this is actually the best cost available..?
13:24:22 <humanoyd> Ankhers: Thanks, but I'm reading a deeply nested JSON object with lens-aeson `myJson ^? key "deeply . key "nested" . key "array"` which ultimately returns an aeson "Value"
13:24:42 <obadz> lynnard: I don't think it's inefficient but I'm a newbee
13:24:53 <Hijiri> I wanted to make a function that maps a function over ony the minimum element (by some comparison) of a traversable, and I need to get the minimum from ahead of the element and before the element
13:24:56 <Hijiri> to know whether to change it
13:27:39 <obadz> lynnard: I think it will get flattened into a single list the first time it gets traversed to the first element of the 2nd list
13:27:59 <Putis> lynnard: It will be uneficient, when value will be evaluated between concatenations by IO operation
13:28:28 <obadz> Putis: what do you mean?
13:28:39 <zuserm> Hijiri: There was a post on reddit a while ago on the "waterflow problem", which sounds similar, that I came up with a Tardis solution for.
13:29:52 <lynnard> obadz: assuming that the second list is in normal form
13:32:31 <zuserm> Hijiri: Chris Done had a good blog post about it http://chrisdone.com/posts/twitter-problem-loeb
13:32:43 <Putis> obadz: For example, when we will print concatenated. I guess that lazyness will be gone in such situation
13:32:59 <Hijiri> thanks zuserm 
13:33:18 <obadz> lynnard: yes, I guess it's [a] ++ [a] is always a list. it has thunks introduced by ++ only until you get to the first element of the second list. After that, if there are any thunks left, they were already there before. (disclaimer: I could be wrong)
13:33:33 <obadz> s/it's//
13:46:55 --- mode: leguin.freenode.net set +o ChanServ
13:47:37 <c_wraith> lynnard: the important thing is that there's no magic involved. These properties are just the result of the code. 
13:47:37 <lynnard> c_wraith: IO producer...like?
13:47:41 <lynnard> cool, I'll look around the net to have a better idea... every time I thought I've understood laziness, I really didn't
13:47:53 <c_wraith> lynnard: readFile, for instance. Though that one uses unsafeInterleaveIO
13:48:28 <lynnard> ah.. okay
13:53:59 <indiagreen> @pl \f -> itraverse (itraverse . f)
13:54:00 <lambdabot> itraverse . (itraverse .)
13:55:25 <guillaum2> do you know an efficient way of sorting a string ? Data.List.sort on String or Data.ByteString.sort on ByteString are dramatically slow.
13:56:34 <dolio> Sort the characters in a string?
13:56:58 <guillaum2> dolio: yes.
13:57:17 <dolio> You could turn it into a vector, and use one of the sorting functions in vector-algorithms.
13:57:59 <dolio> That might be faster.
13:58:36 <c_wraith> I wouldn't really sort characters in textual data outside of toy problems. In the real (unicode) world, that operation doesn't make sense 
13:58:51 <orbifx> disconnect
14:01:04 <guillaum2> c_wraith: yes, this is a toy problem ;) I give an assignement to my students to group a list of words by anagram and, for fun, I wanted to implement the solution in Haskell and I was surprised that my python solutioon is only 2x slower than C++ when my haskell solution is 15 times slower than C++ ;)
14:02:54 <c_wraith> guillaum2: I'd suspect the biggest factor is the different representation. Immutable singly-linked lists are easily 15x slower to deal with than contiguous arrays. 
14:03:36 <guillaum2> c_wraith: (15 times slower is using ByteString ;) I did not give the factor using String, this is really bad ;)
14:03:53 * hackagebot sdl2-cairo 0.1.0.0 - Binding to render with Cairo on SDL textures  and optional convenience drawing API.  https://hackage.haskell.org/package/sdl2-cairo-0.1.0.0 (apirogov)
14:03:55 * hackagebot react-flux 1.0.1 - A binding to React based on the Flux application architecture for GHCJS  https://hackage.haskell.org/package/react-flux-1.0.1 (JohnLenz)
14:05:24 <akegalj> servant-examples package uses declaration: "servant == 0.5.* " in .cabal . How can cabal find dependencies when hackage shows me that newest servant is 0.4.4.4 ?
14:05:33 <akegalj> source: https://github.com/haskell-servant/servant/blob/master/servant-examples/servant-examples.cabal
14:06:19 <indiagreen> akegalj: code from Github doesn't have to compile with packages from Hackage
14:06:56 <indiagreen> akegalj: if servant and servant-examples are developed by one team, it's not surprising that a yet-unreleased version of servant-examples would depend on a yet-unreleased version of servant
14:07:09 <akegalj> indiagreen: oh, you mean it uses local repo ?
14:07:24 <akegalj> indiagreen: ok, that makes sense
14:07:26 <akegalj> thnkx
14:07:30 <akegalj> thnx
14:11:35 <dolio> bytestring's sort is radix sort, which might not be the optimal choice for sorting stuff in anagrams.
14:11:55 <dolio> Also I have no idea if anyone has cared how fast it is.
14:19:03 <Putis> hello
14:19:08 <Putis> I'm trying to compile some module with GHC API
14:19:12 <Putis> I'm going to feed GHC with Core generated by me
14:19:19 <Putis> I'm going to start with some minimal example
14:19:23 <Putis> So far is noticed, that function compileCoreToObj ends with an runtime error on each call and produces some *.o and *.hi files anyway
14:19:27 <Putis> However, produced interface file does not contain any item in exports field, what makes compiled module unusable
14:19:30 <Putis> Another way I tried to achieve my goal is using steps described here: https://wiki.haskell.org/GHC/As_a_library (the second example)
14:19:36 <Putis> I was able to print out Core produced form file, but if I'm not wrong, modifying structures passing on between sequent calls does not effect on produced *.hi and *.o files
14:19:39 <Putis> both files are generated by `load LoadAllTargets' call, and further one does not effect on generated files
14:19:42 <Putis> on the end of my dilatation, I'm asking you for your help
14:19:46 <Putis> can You give me any advices in that topic? Am I thinking right in mentioned apects?
14:22:32 <hiptobecubic> Quiet today...
14:23:07 <hiptobecubic> Putis, it's kind of a niche question. You might have better luck on the ghc mailing list, stack overflow, or reddit.
14:23:24 <Shockk> does anyone know of a lens function or operator similar to %= except taking a function (a -> f b) as opposed to (a -> b)?
14:24:47 <Shockk> for example allowing me to do x %= return . (*2) or something similar to that
14:25:23 <roconnor> Shockk: you can use the lens directly with no operation
14:25:46 <roconnor> x (return . (*2))
14:26:13 <Shockk> oh
14:26:17 <roconnor> sneaky
14:26:43 <Shockk> that's.. a bit hard to understand how that works, lenses are confusing
14:26:49 <Shockk> but thanks I'll try it
14:26:58 <shachaf> roconnor: I don't think that'll work with State.
14:26:59 <roconnor> it's an artifact of the implementation
14:27:10 <Shockk> intended?
14:27:21 <roconnor> No I wouldn't say it is intended.
14:27:28 <roconnor> probably some operator ought to be defined.
14:27:35 <Shockk> ahh
14:27:37 <roconnor> Shockk: what would you name the operator.
14:27:45 <shachaf> There are operators and functions for it.
14:27:53 <roconnor> shachaf: define work.
14:27:58 <roconnor> shachaf: it typechecks.
14:28:10 <roconnor> shachaf: what are they?
14:28:19 <dolio> traverseOf
14:28:34 <shachaf> Maybe I'm confused on what people are trying to accomplish.
14:28:34 <roconnor> dolio: yes
14:29:10 <dolio> Oh, but that's not like %= that's %~
14:29:16 <shachaf> Yes.
14:29:30 <Putis> hiptobecubic: thanks, I will try it then
14:29:31 <shachaf> I don't think id will do the sort of thing (%=) does, which is why I was confused by roconnor's answer.
14:29:57 <Shockk> hmm
14:30:15 <roconnor> Shockk didn't mention anything special about the functor he wanted to use.
14:30:30 <shachaf> :t (%=)
14:30:31 <lambdabot> (Profunctor p, MonadState s m) => Setting p s s a b -> p a b -> m ()
14:31:13 <roconnor> Er, I guess I'm thinking about lens-family, but it should work in lens
14:31:30 <Shockk> it's RWST with an inner IO monad I'm using
14:31:38 <roconnor> > _2 id (5, [7])
14:31:40 <lambdabot>  [(5,7)]
14:32:01 <dolio> %= is for assigning to state in a state monad.
14:32:23 <roconnor> maybe id is an unusual example of something of the form (a -> f b).
14:33:09 <roconnor> > _2 (sequence [(+ -1), (+ 0), (+ 1)]) (5,10)
14:33:10 <lambdabot>      The operator ‚Äò+‚Äô [infixl 6] of a section
14:33:10 <lambdabot>          must have lower precedence than that of the operand,
14:33:10 <lambdabot>            namely prefix `-' [infixl 6]
14:33:18 <roconnor> > _2 (sequence [(+ (-1)), (+ 0), (+ 1)]) (5,10)
14:33:19 <lambdabot>  [(5,9),(5,10),(5,11)]
14:33:54 * hackagebot exception-transformers 0.4.0.2 - Type classes and monads for unchecked extensible exceptions.  https://hackage.haskell.org/package/exception-transformers-0.4.0.2 (GeoffreyMainland)
14:33:59 <roconnor> > _2 (\x -> [(x+ (-1)), (x + 0), (x + 1)]) (5,10)
14:34:01 <lambdabot>  [(5,9),(5,10),(5,11)]
14:34:52 <lpaste> Shockk pasted ‚ÄúConfig.hs‚Äù at http://lpaste.net/5091357101440106496
14:35:02 <Shockk> this is the code in question I've got, in case this helps
14:35:59 <roconnor> Shockk: what type do you want setupConfig to have?
14:36:15 <roconnor> And what type does load have?
14:36:33 <Shockk> oh, I didn't include the type, sorry one sec
14:37:37 <lpaste> Shockk revised ‚ÄúConfig.hs‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/5091357101440106496
14:38:00 <roconnor> what type does load hav?
14:38:01 <dolio> shachaf: Is (<%=) what he wants?
14:38:07 <Shockk> `load' would also have the type `PolarCore ()'
14:38:10 <Shockk> er wait no
14:38:18 <dolio> Maybe I should ask Shockk.
14:38:37 <dolio> config <%= load
14:38:37 <guillaum2> c_wraith: (I beat the python implementation using ShortByteString... I'm still a noob at profiling haskell, the sort function is not that responsible)
14:38:42 <Shockk> load :: PolarCore ConfigParser
14:38:46 <ttt_fff> with language extension RecursiveDo, what is the return value of a "rec" block ?
14:38:50 <Shockk> dolio: ohhh
14:38:54 <Shockk> :t <%=
14:38:54 * hackagebot language-c-quote 0.11.2.1 - C/CUDA/OpenCL/Objective-C quasiquoting library.  https://hackage.haskell.org/package/language-c-quote-0.11.2.1 (GeoffreyMainland)
14:38:55 <lambdabot> parse error on input ‚Äò<%=‚Äô
14:38:59 <Shockk> :t (<%=)
14:39:00 <lambdabot> (Profunctor p, MonadState s m) => Over p ((,) b) s s a b -> p a b -> m b
14:39:07 <dolio> I'd be surprised if the type told you the answer.
14:39:09 <shachaf> dolio: If I asked my customers what they wanted, they would've said a better record syntax.
14:39:09 <dolio> Just try it.
14:39:19 <Shockk> good point
14:41:45 <roconnor> dolio: that doesn't look right.
14:41:46 <Shockk> hmm nope, it looks like <%= is just the same as %= except has passthrough of the result
14:42:27 <roconnor> Shockk appears to want to modify the state of the config, using a modifer function that may also modify the state; a very very dangerous operation.
14:42:57 <roconnor> well, the modifer function doesn't actually modify the state
14:43:02 <roconnor> but the type says it might.
14:43:04 <Shockk> roconnor: oh, I didn't actually think about the function being able to modify the state itself
14:44:24 <roconnor> Iteresting problem.  You either need to break abour the RWST, or probably just do things by hand by getting and setting.
14:44:32 <roconnor> *break apart
14:45:19 <Shockk> it might be best for me just to use config >>= load >>= assign config
14:45:26 <roconnor> yes I think
14:45:41 <dolio> Yeah, I would probably just bind.
14:45:44 <roconnor> that would be easiest.
14:45:47 <dolio> Instead of crawling through lens operators.
14:46:21 <Hijiri> is there a function Foldable t => t (Either a b) -> ([a],[b]) that separates the Lefts and Rights in a Foldable
14:46:27 <Shockk> ahh great, that built
14:46:32 <arkeet> :t partitionEithers
14:46:33 <lambdabot> [Either a b] -> ([a], [b])
14:46:34 <Shockk> thanks all of you
14:46:45 <arkeet> use that with toList, I suppose.
14:46:49 <Hijiri> alright
14:47:06 <Hijiri> I guess I'm converting to list anyway
14:53:54 * hackagebot foldl-transduce 0.4.5.0 - Transducers for foldl folds.  https://hackage.haskell.org/package/foldl-transduce-0.4.5.0 (DanielDiazCarrete)
15:07:53 <Gurkenglas> What Haskell IDE should I use on xubuntu?
15:08:31 <bitemyapp> Gurkenglas: don't use an IDE
15:08:34 <bitemyapp> Gurkenglas: IMO.
15:08:46 <bitemyapp> Gurkenglas: get hella comfy with text editor + ghci instead
15:08:54 <bitemyapp> Gurkenglas: but if you must have an IDE-alike, Atom + ghc-mod
15:08:55 * hackagebot milena 0.4.0.0 - A Kafka client for Haskell.  https://hackage.haskell.org/package/milena-0.4.0.0 (tylerholien)
15:14:20 <hexagoxel> does the haskell platform on windows contain an msys terminal gui thingy?
15:15:26 <zachk> hexagoxel, not the last time I used it, go get it
15:20:30 <hexagoxel> zachk: and stuff won't break because of multiple msys installs? (apart from wasting 200MB)
15:21:44 <zachk> not sure, I know the sdl2 libs for haskell were extremely broken for me at least on windows using msys/mingw 
15:22:01 <zachk> pretty sure I had multiple msys's before and they all ran in seperate little worlds
15:22:51 <hexagoxel> zachk: sandbox everything! even the commandline environment :D
15:23:01 <hexagoxel> zachk: thanks for info :)
15:24:11 <reygoch> hello! how is everyone :D
15:24:33 <zachk> not a problem hexagoxel, I tried for months to get sdl with haskell working on windows to no avail, worked smoothly on linux though in no time
15:26:33 <zachk> hey reygoch 
15:26:51 <Gurkenglas> I want to install something using stack, so I'm making a project to sandbox the install. Can I use "stack new" with the name of the package I intend to install, or will that shadow the package name?
15:28:06 <hiptobecubic> I imagine your cabal file will not make sense
15:28:12 <hiptobecubic> if your package depends on itself
15:28:44 <Gurkenglas> Is there a command that automatically makes a project, installs a package in it, preserves the executable, and deletes the project?
15:29:41 <hiptobecubic> how is that different from just running "stack install <some package name>" ?
15:30:43 <Gurkenglas> Don't the dependencies stay installed and may introduce cabal hell?
15:32:30 <hiptobecubic> the dependencies are all fixed at your stackage version anyway. there's not really a dependency problem
15:34:15 <reygoch> does anyone know if there is some good writeup about user authentication in haskell?
15:34:39 <ttt_fff> a <- b :: IO Int // is there anyway to write this to say a :: Int <- b ?
15:34:51 <ttt_fff> I want to tag "the thing on the LHS of <-", not "the thing on the RHS of <-"
15:35:10 <hiptobecubic> you can put the annotation above or below it I think
15:35:16 <hiptobecubic> a :: Int; a <- b
15:36:03 <Gurkenglas> Hmm. No sandboxing? I like!
15:37:14 <hiptobecubic> Gurkenglas, there are a lot of good blog posts from fpcomplete about stack. It's worth taking a look at them
15:37:32 <hiptobecubic> ttt_fff, i think with an extension you can do (a :: Int) <- b
15:37:43 <hiptobecubic> ScopedTypeVariables or something. Not sure, never used it
15:38:02 <hiptobecubic> yep works
15:38:15 <hiptobecubic> Prelude System.Random> :set -XScopedTypeVariables
15:38:18 <hiptobecubic> Prelude System.Random> (a :: Integer) <- randomIO
15:38:20 <hiptobecubic> a :: Integer
15:40:11 <johnw> ttt_fff: you can't type annotate a type like that; even a <- b :: IO Int is wrong
15:40:23 <johnw> oh, it's a do binding
15:40:30 <ttt_fff> yeah, this is inside a do block
15:40:32 <johnw> yeah, then ScopedTypeVariables: (a :: Int) <- b
15:40:34 <ttt_fff> I forgot to mention that
15:40:51 <johnw> it was my bad, it's the only legal meaning, I should have seen that
15:59:48 <Gurkenglas> http://pastebin.com/UHQ3JP1h nooo it wont build network
16:00:00 <Gurkenglas> This "wont build X" stuff is why I introduced that vm in the first place :(
16:04:38 <Gurkenglas> And on ghc-mod it gets even less far than I got on Windows, it already fails at the ghc-paths package http://pastebin.com/JYRT68PP
16:47:44 <Earnestly> Excuse me, could anyone direct me to any documentation on the cabal/config file?
16:50:25 <johnw> the Cabal User Guide
16:52:57 <Earnestly> That doesn't document the config file very well :(
16:53:12 <Earnestly> I have looked over that as well but it excludes a few options
16:55:36 <Earnestly> It doesn't touch on most of the options actually, the ones documented are mostly prefix and directory paths including a few $variables (of which $ncpus isn't mentioned)
16:57:46 <Earnestly> johnw: I found some information on `optimization` from the source code, that it's not a boolean but also excepts '2'
16:57:49 <Earnestly> accepts* even
16:59:00 <Earnestly> E.g. what is the difference between `profiling:` and library,executable-profiling?  Is it that the former just enables it for both?
16:59:06 <johnw> pages like this https://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/developing-packages.html#package-properties
16:59:11 <johnw> enumerate all the top-level options
16:59:15 <johnw> which options did you not find?
16:59:48 <Earnestly> johnw: Hm, this did not show up in google, odd.  I was searching for documentation, maybe my keywords are weak.  I'll have a look, thanks for the link
17:00:30 <Earnestly> johnw: Hm, this doesn't appear to be documentation for the config file, but maybe it's in here somewhere
17:00:35 <bitemyapp> johnw: p good email.
17:00:48 <Earnestly> johnw: Oh, this is the user-guide, sorry
17:01:00 <Earnestly> johnw: Yeah, it doesn't document virtually anything about the config file
17:01:16 <Earnestly> johnw: E.g. http://ix.io/leP
17:01:37 <Earnestly> Some are guessable, I suppose
17:04:00 * hackagebot tubes 1.1.0.0 - Effectful, iteratee-inspired stream processing based on a  free monad.  https://hackage.haskell.org/package/tubes-1.1.0.0 (gatlin)
17:04:58 <johnw> bitemyapp: thanks! i was hesitant to send that one
17:05:43 <johnw> Earnestly: ah, you mean ~/.cabal/config, sorry I misunderstood
17:06:39 <Earnestly> johnw: Yeah, I suppose my initial question might have made cabal/config look like an either-or instead of path :P
17:06:52 <johnw> I thought you mean .cabal configuration
17:06:58 <johnw> as in, the project definition files
17:07:13 <johnw> I haven't use ~/.cabal/config in two years, so I actually forgot it was a thing
17:07:15 <Earnestly> Yeah, I see that now.  I could have clarified if I noticed sooner
17:07:42 <Earnestly> johnw: Unfortunately while CABAL_CONFIG is a thing the generated file has no regard for its value
17:07:47 <bitemyapp> johnw: bloody necessary and on point.
17:07:54 <bitemyapp> johnw: the comparison to C++ was well-made.
17:09:02 <bitemyapp> johnw: I wasn't expecting needing to pipe up myself.
17:09:14 <bitemyapp> johnw: figured it would be a wave-through. Hope springs eternal.
17:11:25 <johnw> bitemyapp: as long as it keeps springing; don't go curmudgeon on us for a while yet
17:13:20 <johnw> I actually think these things need to happen, it's a matter of keeping it productive
17:13:45 <nolrai66> johnw: what things?
17:13:57 <johnw> no one has made a *bad* point, just hugely different wells of experience and resulting suffering
17:14:06 <johnw> nolrai66: the discussion on libraries/cafe/prime
17:14:16 <johnw> about the Monad of no 'return' Proposal (MRP)
17:14:24 <nolrai66> Ah.
17:14:44 <nolrai66> I don't use the language yet, so I want all changes to happen before I do.
17:14:46 <nolrai66> :P
17:14:52 <johnw> hahah, fair enough!
17:15:56 <nolrai66> The prelude sucks anyway though..so..hm. Not quite sure where I am going, but if we are going to make breaking changes to it, why not do the important ones first?
17:16:11 <johnw> you can always chose a different Prelude
17:16:41 <mutantmell> Applicative Monad Proposal went through already, that seems like it was quite important :)
17:17:08 <johnw> the MRP is intended to further complete what that proposal began
17:18:08 <mutantmell> That's moving return out of Monad and making it top level, right?  Any idea how that will interact with ApplicativeDo?
17:18:24 <johnw> mutantmell: the proposal describes that, IIRC
17:19:14 <nolrai66> Are these classes not in the prelude?
17:19:32 <johnw> nolrai66: they are in modules that get re-exported in the Prelude, yes
17:19:36 * nolrai66 hasn't touched this sort of thing in a while.
17:19:38 <Earnestly> (Will the prelude ever be removed?)
17:19:52 <johnw> Earnestly: -XNoImplicitPrelude does just that
17:20:24 <johnw> the point is, you're not forced to use any specific Prelude.  You *are* forced, for compatibility, to use the same Monad typeclass
17:22:11 <Pamelloes> johnw: Why? Because of IO?
17:22:30 <johnw> if you had your own Monad typeclass, there would be a lot of thing you couldn't use
17:22:37 <johnw> i mean, you can do it
17:22:47 <johnw> just be prepared to roll your own "when", "unless", etc.
17:23:59 <nolrai66> Ah, I see what you mean.
17:24:06 <Earnestly> johnw: I mean, when will the prelude be made opt-in, not opt-out* then sorry
17:24:22 <Earnestly> johnw: I.e. requiring import Prelude
17:24:25 <johnw> Earnestly: what would be the reason for that change?
17:24:43 <nolrai66> johnw: start to force a movement away from it.
17:25:05 <Earnestly> johnw: Mostly to be explicit about things
17:25:15 <nolrai66> I think the only real problem is we don't have a single replacement, we have like 4.
17:25:20 <johnw> I can't see that every happened for everyone, when the subset who want it can have it today
17:25:24 <johnw> ever happening*
17:25:36 <johnw> nolrai66: at least 10!
17:25:48 * nolrai66 facepalms.
17:25:52 <johnw> heck, I have one on Hackage even, that I don't use anymore
17:29:32 <Gurkenglas> Does someone have a vm image with Haskell stuff installed on it and working, particularly ghc-mod?
17:36:42 <mutantmell> For a web service I'm writing, I want/need to log some metric data such as request/response time -- is hslogger my best bet for this?
18:01:30 <slack1256> YESSSSSS!
18:02:08 <deech> My program is taking a long time to compile, running with -v gives a long series of `CPSZ`. What is that?
18:03:43 <mutantmell> slack1256: excited much?
18:04:47 <mutantmell> :)
18:04:59 <slack1256> the autojoin code that I implemented on irc-code works. :-)
18:05:02 <slack1256> I am just happy
18:05:08 <slack1256> irc-core
18:05:28 <slack1256> I know it is baby steps but still
18:05:45 <Epichero> I've tried in the past to get yesod to install but i don't know how to get cabal to install it right
18:06:54 <Epichero> I always pick up a haskell book and start working through it until cabal destroys me
18:07:46 <peddie> Epichero: you could try using the 'stack' tool
18:08:15 <Epichero> stackage?
18:08:22 <Epichero> or w/e its called
18:08:31 <Epichero> it didn't work last time i tried 
18:08:54 <peddie> I believe stackage is a server and stack is a program, but I haven't used either; someone else might be able to help 
18:09:45 <Epichero> upgrading cabal and trying again 
18:10:19 <mutantmell> stack is a different tool than stackage
18:11:12 <mutantmell> https://github.com/commercialhaskell/stack
18:11:28 <Epichero> i want to either follow along with the yesod book or something else that dishes out enough short term payoff to help keep me going
18:12:11 <mutantmell> I haven't used stack myself, but it manages its own GHC installation and I've heard good things
18:12:23 <mutantmell> might want to give it a try in the short term if cabal is giving you troubles
18:12:25 <mutantmell> what OS?
18:13:13 <Epichero> OSX
18:14:48 <Epichero> i've had it installed, i'll run stack upgrade and try it again
18:15:57 <mutantmell> Take a look at this: https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md
18:16:15 <mutantmell> Seems relatively straight-forward
18:21:23 <j-rock> hey, I'm trying to use the sdl package in a stack project.
18:21:30 <j-rock> when I run "stack ghci"
18:21:37 <j-rock> it complains that it cannot find the sdl .so
18:22:02 <mutantmell> Wish I could help -- I haven't actually used stack myself
18:22:04 <j-rock> however, I can compile the project's executable and run it without problems
18:22:18 <j-rock> for the most part, it's a pretty great tool
18:22:41 <j-rock> I'm pretty pleased with all the isolation it provides
18:30:38 <Codex_> i'm planning a haskell binding for my lib, is this valid interface: http://codepad.org/hGbwvBix
18:31:53 <Codex_> or how should it be improved to make it easier to use?
18:34:07 <medfly> if I have a thing like data A = A {b, c, d} is there some easy way to get like b? is it lens?
18:34:17 <medfly> some magic Haskell operator
18:35:11 <shachaf> There's the field selector itself, if you defined a record with field selectors.
18:35:21 <shachaf> But what you wrote is a syntax error so I don't know what you defined.
18:35:26 <medfly> :(
18:35:55 <medfly> uhh, data A = A {b :: Int, c :: Int} is that better
18:36:19 <shachaf> Yes. b :: A -> Int
18:36:36 <medfly> thanks
18:49:11 <j-rock> I'm looking at https://github.com/commercialhaskell/stack/issues/592 right now
18:49:32 <j-rock> does anyone know how to "stack ghci" a library and not the executable in a cabal project?
18:58:21 <mreh> is snap still a live project?
18:58:32 <mreh> I'm looking for a web framework
19:01:41 <j-rock> what kind of web framework?
19:02:14 <j-rock> rails-like ==> yesod
19:02:21 <j-rock> sinatra-like ==> spock / scotty
19:02:32 <j-rock> jekyll  ==> hakyll
19:02:49 <j-rock> snap falls somewhere between yesod and spock
19:02:55 <j-rock> also happstack
19:04:26 <lethjakman> mreh: check git commits, I believe it's still moving.
19:04:32 <lethjakman> I've been using yesod quite a bit and I like it. 
19:04:37 <mreh> ok
19:04:39 <mreh> thans
19:04:48 <j-rock> last snap commit on master was 15 days ago
19:04:53 <j-rock> I'd say that's decent
19:05:12 <awpr> it might be worth pointing out that frameworks that run on top of Warp (that's Yesod and at least some others) will support HTTP/2 (with some caveats) while as far as I know the others currently don't
19:07:29 <mreh> snap is a maaaaasive install
19:08:14 <mreh> I've never done rails or jekyll
19:08:26 <mreh> I'm a filthy PHP programmer by day
19:08:31 <mreh> and I love it
19:08:40 <Hafydd> Disgusting.
19:08:45 <lethjakman> A lot of haskell things compile slow, but run incredibly quickly. 
19:08:49 <lethjakman> I do not miss my days of PHP
19:09:00 <mreh> lethjakman, help me leave
19:09:11 <mreh> is there somewhere I can go?
19:09:53 <lethjakman> mreh: There are plenty of places to go, the software job market is great. 
19:10:07 <lethjakman> No clue how it is for haskell since I haven't had a job working in it. 
19:10:18 <mreh> lethjakman, I've been tarred by the PHP brush, finding it hard to find anyone to hire me to do anything else
19:10:26 <mreh> did some python in the last job
19:10:28 <harold6942> mreh: I've heard a PHP background is useful if you're interested in web security...
19:10:41 <lethjakman> mreh: Write some software in your free time and release it, and you'll be un-tarred
19:10:50 <lethjakman> PHP isn't terrible. 
19:10:58 <lethjakman> I hate the syntax, but it's pretty solid as a language. 
19:11:05 <lethjakman> If you know basic design patterns and such you should do well. 
19:11:25 <jp_rider> hi, i'm attempting to execute a program in a forked process, and am having some trouble with hangs
19:11:40 <jp_rider> does anyone think they could take a look? http://lpaste.net/3379365854306107392
19:12:14 <jp_rider> i think the issue might be with how pipes are being set up (unix)
19:13:06 <mreh> don't you need to compile with -threaded for that?
19:13:35 <jp_rider> hmm‚Ä¶ let me try it
19:13:44 <jp_rider> do i just add that to cabal build?
19:13:55 <mreh> if you're using cabal, yes
19:14:12 <jp_rider> k let me try
19:15:18 <jp_rider> hmm this is my current ghc-options line in my cabal file: -Werror -Wall -fno-warn-orphans -fno-warn-type-defaults -fno-warn-name-shadowing -threaded
19:16:17 <mreh> jp_rider, which forkProcess are you using?
19:17:08 <jp_rider> System.Posix.Process.ByteString
19:23:46 <jp_rider1> sry my internet dropped for a second, not sure if anyone replied
19:29:00 <__rlp> jp_rider1: I don't see anything after 22:16 < jp_rider> System.Posix.Process.ByteString
19:31:29 <jp_rider1> ok yup, that was my last message
19:39:05 <slack1256> Maybe I am doing this wrong. Is there an standard 3 way sum-type as what (a,b,c) is to the product types?
19:39:26 <nolrai66> nope.
19:39:27 <slack1256> doing (Either a (Either b c)) and case through look ugly (but works)
19:39:52 <nolrai66> I would do (Either (Either a b) c).
19:40:01 <nolrai66> Not that that matters.
19:40:16 <nitrix> You could write your own `ThreeEither a b c`.
19:40:29 <j-rock> depending on the type, just make a sum type with 3 constructors
19:40:34 <j-rock> ^^^^
19:40:41 <slack1256> Still I don't like the extra bottom. I wrote my own ThreeSum a b c.
19:40:43 <j-rock> as in, what nitrix said
19:40:51 <j-rock> teehee
19:41:06 <slack1256> with non-really-fitting names like OneS, TwoS, ThreeS
19:41:09 <j-rock> I would call it Either3 to avoid the innuendo
19:41:19 <nitrix> Check what instances Either implements and implement those and you should be good.
19:41:43 <nitrix> Qa, Monad, Functor, Ord, Read, Show, Applicative, Foldable and Traversable.
19:41:45 <nitrix> It seems.
19:41:47 <nitrix> Eq*
19:42:03 <slack1256> It is a really local thing, I don't think I should export those interfaces. Even Functor seems curbersome to use
19:42:18 <slack1256> instance Functor (Either3 a b) where;
19:42:38 <slack1256> not even bifunctor help much, seems like not worth it in the end
19:43:34 <nitrix> Or you could hide the double Either with a type alias?
19:44:23 <slack1256> not gaining much anyways. Thanks for the suggestions, but I just wanted to know if I was reinventing the wheel in someway
19:44:53 <crough> slack1256: Don't worry about re-inventing the wheel. You can refactor out your duplication if you want later
19:45:29 <crough> slack1256: with almost no effort :) 
19:46:12 <slack1256> I hope so
19:48:01 <j-rock> double tagged functor ?= Either3 a b c
19:48:22 <j-rock> me and category theory are like... peanut butter and vinegar
19:48:33 <j-rock> never have we truly been combined
19:48:38 <medfly> why can't I use | head to see the top of the errors of GHC?
19:48:53 <Clint> now i want to eat peanut butter with vinegar
19:49:01 <crough> medfly: They're probably stderr not stdout?
19:49:06 * hackagebot pipes-sqlite-simple 0.2 - Functions that smash Pipes and sqlite-simple together  https://hackage.haskell.org/package/pipes-sqlite-simple-0.2 (NickPartridge)
19:49:08 <medfly> :|
19:49:19 <crough> try `ghc whatever 2>1 | head`
19:49:25 <crough> sorry
19:49:31 <crough> ghc whatever 2>&1 | head
19:49:43 <crough> That redirects stderr to stdout for piping if you  want it
19:49:46 <medfly> yes I can google thanks
19:50:13 <crough> You're welcome I guess.
20:03:42 <jle`> slack1256: yeah, the problem is that haskell has no anonymous sum syntax
20:03:56 <jle`> analogous to the anonymous product syntax
20:04:26 <jle`> remember that tuples and tuple syntax are actually built into the language as syntax
20:04:44 <jle`> but Either is a normal defined data type in standard libraries
20:06:03 <slack1256> not sure if want though
20:06:14 <slack1256> At least I felt some pain with anonymous product types
20:10:17 <bitemyapp> johnw: not yet :)
20:13:24 <jle`> slack1256: you can also return/use a church-encoded either, forall r. (a -> r) -> (b -> r) -> (c -> r) -> r
20:13:38 <jle`> i guess that technically counts as an anonymous sum in a sense
20:13:44 <jle`> although you don't get to use normal case expression syntax
20:14:25 <slack1256> that actually is a great idea jle` !
20:14:27 <jle`> but in this way it's easy to generalize to arbitrary arity sums
20:14:34 <slack1256> yes indeed
20:31:46 <awpr> it just occurred to me that "forall r. r" is the church encoded form of a constructor with zero data types, which connects nicely with the fact that it's an uninhabited type, i.e. Void.
20:32:07 <awpr> bleh, data type with zero constructors
20:50:10 <ReinH> jle`: o/
20:54:09 * hackagebot yesod-auth-oauth2 0.1.4 - OAuth 2.0 authentication plugins  https://hackage.haskell.org/package/yesod-auth-oauth2-0.1.4 (PatrickBrisbin)
21:20:01 <crough> awpr: It's Top, right?
21:21:05 <crough> or rather Unit
21:21:47 <bitemyapp> crough: *waves*
21:22:01 <dolio> Unit is forall r. r -> r
21:23:01 <crough> Hey bitemyapp
21:23:30 <crough> dolio: ha, I guess not. If unit were data Unit a = Unit then it would...
21:23:37 <crough> dolio: but that's just void and I'm just tired
21:24:01 <crough> dolio: It is, however, Top
21:34:10 * hackagebot composition-tree 0.2.0.0 - Composition trees for arbitrary monoids.  https://hackage.haskell.org/package/composition-tree-0.2.0.0 (LiamOConnorDavis)
21:59:11 * hackagebot composition-tree 0.2.0.1 - Composition trees for arbitrary monoids.  https://hackage.haskell.org/package/composition-tree-0.2.0.1 (LiamOConnorDavis)
22:01:01 <kras> Hi, I am trying to use the <$> functor like this
22:01:03 <kras> getSec <$> (BS.readFile orginal) (BS.readFile modified)
22:01:17 <kras> looks like this is not the correct syntax
22:01:27 <kras> any help appreciated
22:01:56 <kras> getSec takes two args
22:10:47 <jp_rider> @kras <$> only takes 2 arguments
22:10:47 <lambdabot> need 1 to do a while 0 does !a. need 1 to do a while 0 does !a
22:10:49 <jle`> ReinH: \o
22:11:01 <jp_rider> try this: getSec <$> (BS.readFile orginal) 
22:11:15 <jle`> kras: what are getSec, BS.readFile original, and BS.readFile modified?
22:11:22 <jle`> kras: btw, do you know how to use `fmap` ?
22:11:44 <kras> got it working had to use  getSec <$> (BS.readFile orginal) <*> (BS.readFile modified)
22:12:06 <jle`> great :)
22:12:26 <kras> getSec <$> (BS.readFile original) gave me IO (Bytestring -> ByteString)
22:12:26 <jle`> by the way, this isn't syntax, this is just reguar functions
22:12:43 <jle`> <$> and <*> aren't syntax, they're just normal functions/operators defined in a library
22:12:48 <kras> to take the function out of IO() I had to use <*>
22:13:00 <kras> okay
22:14:36 * hackagebot streaming-utils 0.1.1.1 - http, attoparsec and pipes utilities for streaming and streaming-bytestring  https://hackage.haskell.org/package/streaming-utils-0.1.1.1 (MichaelThompson)
22:16:07 <Mayzie> Why do I get these errors? :-/ https://bpaste.net/show/4e880a7bc496
22:16:39 <glguy> because you used $
22:16:57 <glguy> map $ ErrorDuplicate duplicates --is-- map (ErrorDuplicate duplicates)
22:17:10 <Mayzie> Right. Without it, though, I still get the last error.
22:17:28 <Mayzie> (Sorry, been at this for quite a while, and been mucking around with various things)
22:17:53 <glguy> duplicates is a function
22:17:57 <glguy> but it needs to be a list
22:18:11 <Mayzie> Why isn't it a list?
22:18:24 <Mayzie> I thought filter was supposed to return a list where the elements of a given list match a predicate?
22:18:32 <glguy> because: filter (\x -> length (x `elemIndices` nameArr) > 1)
22:18:43 <glguy> has type: [String] -> [String]
22:19:13 <Mayzie> Oh
22:19:30 <Mayzie> So obvious now.
22:19:52 <Mayzie> glguy: Thanks. :-)
22:20:10 <glguy> yw
22:21:06 <Mayzie> (Still learning)
22:21:14 <kras> I had lot of confusion using $ when I was learning
22:21:33 <kras> avoid it util you are comfortable with other things
22:21:48 <kras> IMHO
22:21:57 <jle`> some people advocate never using $, so you aren't alone
22:22:51 * johnw hugs his $$
22:23:00 <tommd> And my ‚Ç¨
22:23:20 <Mayzie> My lecturer is using it everywhere, and we have to stick to his standards :-/
22:23:29 <Mayzie> I know what it does, it wraps everything to the right in parenthesis
22:23:48 <Mayzie> Just, yeah
22:23:56 <jle`> kinda.  well, if you want to put it that way, you have to say, "and the left, too"
22:23:58 <mniip> actually every operator does that
22:24:11 <mniip> a * b + c / d ^ e
22:24:17 <pacak> :t (&)
22:24:18 <lambdabot> a -> (a -> b) -> b
22:24:21 <pacak> evil
22:24:26 <mniip> ((a) * (b)) + ((c) / ((d) ^ (e)))
22:24:26 <pacak> $ are nice
22:24:40 <johnw> my favorite use of $ is when the left side "pertains to the Monad I'm in" and the right side pertains to the value.  For example: put $ x + 1, return $ foo a b, join $ bar bar
22:25:00 <mutantmell> I probably use $ and . too much
22:25:01 <johnw> if it's a regular function, I'll usually use () instead
22:25:01 <jle`> f . g $ x + y = (f . g) (x + y)
22:25:31 <mniip> f $ g $ x + y or bust
22:26:17 * Mayzie cries.
22:26:24 <mutantmell> @pl f (g (x + y))
22:26:24 <lambdabot> f (g (x + y))
22:26:34 <mutantmell> lambdabot agrees: no '$'
22:27:03 <jle`> what would lambdabot do
22:27:16 <jle`> use liftM2 for no reason, that's what
22:27:18 <mutantmell> @pl do
22:27:18 <lambdabot> do
22:27:33 <mutantmell> lambdabot would do
22:27:41 <jle`> . o O (@pl do  ==> id)
22:28:10 <mutantmell> liftM2 is a great function >.>
22:28:10 <jle`> > do 5
22:28:12 <lambdabot>  5
22:28:13 <jle`> > id 5
22:28:15 <lambdabot>  5
22:28:18 <jle`> mutantmell: but why not liftA2 ;_;
22:28:45 <glguy> > 2 * do do 5+6
22:28:46 <lambdabot>  22
22:28:48 <mutantmell> jle`: because Monaaaaads
22:29:29 <johnw> Monad is the most open type class, because you can always join.
22:29:55 <mutantmell> (I never use liftM* over LiftA* anymore)
22:29:59 <mutantmell> > join (+) 2
22:29:59 <kras> Mayzie: if you stick to simple cases where left side you only have one function which takes one arg, your generalization will work
22:30:01 <lambdabot>  4
22:30:14 <nitrix> Wait what.
22:30:19 <nitrix> How does that even work?
22:30:22 <nitrix> :t join
22:30:23 <jle`> mutantmell: good :)
22:30:23 <lambdabot> Monad m => m (m a) -> m a
22:30:35 <nitrix> :t join (+)
22:30:37 <lambdabot> Num a => a -> a
22:30:38 <jle`> nitrix: for functions, join f = \x -> f x x
22:31:27 <nitrix> Is there a semantic reason for this?
22:31:38 <nitrix> I feel like it could've been chosen to by about anything.
22:31:47 <nitrix> f (f x) for example.
22:31:51 <jle`> it sort of makes sense if you imagine defining join in terms of (>>=): join x = do y <- x; y
22:32:01 <mutantmell> > (+) >>= a -> a $ 2
22:32:02 <lambdabot>  <hint>:1:11: parse error on input ‚Äò->‚Äô
22:32:04 <johnw> join :: (e -> (e -> a)) -> (e -> a)
22:32:08 <mutantmell> > (+) >>= \a -> a $ 2
22:32:10 <lambdabot>      Occurs check: cannot construct the infinite type: r ~ r -> b
22:32:10 <lambdabot>      Expected type: r -> r -> r -> b
22:32:10 <lambdabot>        Actual type: r -> r -> r
22:32:15 <mutantmell> eh, close enough
22:32:16 <johnw> it turns a function of two arguments of the same type, into a function of one argument of that type
22:32:24 <mutantmell> > (+) >>= id $ 2
22:32:26 <lambdabot>  4
22:33:36 <nitrix> That's still sorcery to me.
22:33:43 <nitrix> Maybe in a few more months :(
22:34:05 <mutantmell> nitrix: you know how functions work as monads?
22:34:20 <jle`> > (do x <- negate; return x) 10
22:34:22 <lambdabot>  -10
22:34:44 <nitrix> That exactly the part that's troublesome. All that pops in my head is ((->) r) and I don't know much more than that.
22:34:59 <mutantmell> Gotcha
22:35:04 <jle`> > (do plusTen <- (+); plusTen) 10
22:35:05 <lambdabot>  20
22:35:13 <nitrix> Some part of the Monad type signature, ahah. Eventually I will.
22:35:33 <jle`> > (do ignoreMe <- (+); negate) 10
22:35:34 <lambdabot>  -10
22:35:43 <jle`> do the first and third things make sense to you?
22:36:33 <johnw> do { x <- f ; y <- g ;  h x y } 10 == h (f 10) (g 10) 10
22:36:48 <jle`> when you do (do x <- negate; return x) 10, the x is bound to "negate 10"...10 is used as the argument to every line in the do block
22:37:54 <nitrix> jle`: Right, it does for the specific use of `join (+)` if I extrapolate on the knowledge that I'm missing about the foundation.
22:38:00 <mutantmell> nitrix: The trick is that (+) has a (simplified) signature of Int -> (Int -> Int) ... and the secondary (Int -> Int) is also a function that takes int and returns some value!  Meaning it is a legitimate member of (->) Int
22:38:25 <mutantmell> ...hopefully that makes some sense :)
22:38:34 <jle`> nitrix: (join (+)) 10 is (do plusTen <- (+); plusTen) 10
22:38:39 <nitrix> jle`: Right. The whole "x is bound to negate 10" is one of the extrapolation. Since I don't know the (-> r) monad yet.
22:38:55 <jle`> ah.  i see
22:39:08 <jle`> btw, it's (->) r, not (-> r)
22:39:26 <mutantmell> nitrix: (->) r is also called the Reader monad
22:39:34 <nitrix> If I assume that this negate becomes negate 10, then the rest makes sense in terms of why the value it's applied to is duplicated.
22:39:37 * hackagebot persistent-template 2.1.3.7 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.1.3.7 (GregWeber)
22:39:54 <jle`> > (do firstThree <- take 3; reversed <- reverse; return (firstThree ++ reversed)) "Hello world!"
22:39:56 <lambdabot>  "Hel!dlrow olleH"
22:40:24 <awpr> @let don't x = let x' = x >>= return in return ()
22:40:26 <lambdabot>  Defined.
22:40:35 <nitrix> That's actually really really, really cool.
22:40:36 <jle`> every line is a (String -> something); firstThree is bound to take 3 "Hello world!", reversed is bound to "!dlrow olleH"
22:40:37 <awpr> :t don't
22:40:38 <lambdabot> (Monad m, Monad m1) => m b -> m1 ()
22:40:53 <mutantmell> > join (*>) [1,2,3]
22:40:55 <lambdabot>  [1,2,3,1,2,3,1,2,3]
22:41:16 <nitrix> jle`: I love that. What would be the type of that `do` expression?
22:41:41 <nitrix> String ?
22:41:49 <jle`> the "result" of the action is the action applied to the 'global input'; the "result" of take 3 is (take 3 "Hello world!"), the "result" of reversed is (reverse "Hello world!"), in that block
22:41:53 <jle`> nitrix: it'd be String -> String
22:41:59 <nitrix> Err, yeah.
22:42:06 <jle`> the Monad is (String ->), and the result type is String
22:42:15 <mutantmell> :t (do firstThree <- take 3; reversed <- reverse; return (firstThree ++ reversed))
22:42:16 <lambdabot> [a] -> [a]
22:42:21 <awpr> nitrix: also, it's Reader String without the newtype wrapper
22:42:25 <nitrix> That's just fascinating. It's so clean.
22:42:36 <nitrix> It avoid any lambda or functions with `where` clauses...
22:42:42 <jle`> so, think about: (do plusTen <- (+); plusTen) 10
22:42:53 <nitrix> jle`: Yeah, that makes perfect sense now.
22:42:54 <jle`> the "result" of (+), stored in plusTen, is (10 +).
22:43:00 <jle`> the result of the last line, is (10 +) 10
22:43:04 <nitrix> jle`: (+) becomes (10 +)
22:43:07 <jle`> so that's the result of the whole block
22:43:08 <nitrix> right.
22:43:13 <nitrix> :t join
22:43:14 <lambdabot> Monad m => m (m a) -> m a
22:43:26 <Bashmetim> https://wiki.haskell.org/Commenting <- Is this real life?
22:43:39 <mutantmell> > join (++) "1234"
22:43:40 <lambdabot>  "12341234"
22:43:46 <Bashmetim> Why does the wiki tell people it's wrong to document your code?
22:43:49 <mutantmell> same thing
22:44:37 <jle`> Bashmetim: it's a general rule in most programming languages/idioms, though.  commenting code is good, but writing code that speaks for itself more clearly than comments is better when possible
22:44:52 <mutantmell> Bashmetim: It's saying that one should prefer to remove unexpected behavior vs documenting it.  That seems correct?
22:44:54 <jle`> so if there's a way to write your code that makes it speak clearer than any comment could, then do it that way
22:45:02 <orb> You want to comment the `why' and `why not?' of your code, not the `how'.
22:45:08 <nitrix> Bashmetim: I do not see such claims. It seems to recommend having code that is clear enough that comments aren't as often necessary.
22:45:32 <Bez_> well thats the way it should be
22:45:36 <jle`> this isn't a Haskell thing, btw...this is common advice for programming in general
22:45:38 <Bashmetim> I feel like that's bad for haskell specifically
22:45:46 <orb> (The `why did we not choose thi alternative approach that's seems more reasonable on the surface' is especially useful, since no matter how clear your code is, you'll never make it talk about things that are _not_ there.)
22:46:07 <Bez_> that's correct
22:46:19 <Bashmetim> Haskell tends to have readability issues, tbh
22:46:29 <Mayzie> ^
22:46:36 <jle`> the article isn't advising you to write unreadable code
22:46:51 <orb> I wrote a lot of Haskell for my last job.  Wasn't worse readability wise than any other language.
22:47:03 <jle`> it's giving you a suggestion that may be applied in specific situations to give you more readable code
22:47:04 <Bez_> well sure, but you can change it at least at your part, Bashmetim
22:47:11 <Bashmetim> Well it says you should leave the comment out when you think it's readable enough to stand without it
22:47:13 <jle`> it's not saying, "don't comment anything ever lol"
22:47:42 <orb> variable names are already something like comments, too.
22:47:48 <Bashmetim> I disagree, mostly because I think (join $ <*> . (***)) isn't always the most readable
22:48:02 <jle`> you can write unreadable code in any language
22:48:06 <mutantmell> :t ((join $ <*> . (***))
22:48:07 <lambdabot> parse error on input ‚Äò<*>‚Äô
22:48:13 <Bashmetim> But a lot of haskell people can read really rune-y code and think it's fine
22:48:15 <mutantmell> lambdabot agrees
22:48:19 <nitrix> I'd argue than as obfuscated as you can make it comparable to another language, the opposite where code is extremely readable in both language is super rare.
22:48:21 <jle`> i don't think anybody would be happy seeing that
22:48:25 <Bashmetim> mutantmell: lol
22:48:28 <orb> Bashmetim: I just said it ain't worse than other languages.  Not that it's without problems. ;)
22:48:40 <jle`> i don't think anybody who uses haskell would be happy to run into join $ (<*>) . (***) when reading code
22:48:46 <nitrix> After a few rewritings, my Haskell programs seems to read a lot easier than anything else I've written on similar complexities.
22:48:50 <orb> jle`: applicative code can be pretty readable, if done right.
22:48:50 <jle`> most people prefer code that is immediately readable
22:49:01 <mutantmell> I'd be happier reading that than some of the perl-isms I've run across >.>
22:49:03 <jle`> it can be, but join $ (<*>) . (***) is never the more readable option
22:49:19 <Bashmetim> Haskell's super expressive and you can write it in a really clear way
22:49:20 <orb> You mean any of these symbols, or that exact combination?
22:49:25 <jle`> that exact combination
22:49:33 <nitrix> Recently I got into the Maybe monad. It got rid of many conditional code, nested stuff, loops, cases...
22:49:34 <jle`> the one used by Bashmetim 
22:49:34 <Bashmetim> but you see a lot of headscratchers in the wild, 
22:49:42 <nitrix> Now it reads linearly. Loving it.
22:50:03 <jle`> Bashmetim: yes, and you should publicly shame them :P
22:50:22 <Bashmetim> and a lot of the time I see the type signature used like it's the only docstring... I don't know
22:50:33 <jle`> publicy shame those too
22:50:34 <jle`> :)
22:50:39 <orb> For some headscratchers, the type can be a better explanation than the implementation.
22:50:48 <Bashmetim> fair :)
22:50:55 <jle`> but that isn't the situation that the article is talking about
22:51:04 <jle`> the article is specifically talking about situations where comments do not add anything to the readability of your code
22:51:21 <orb> (And perhaps enough documentation, that there's basically only one implementation possible, and you don't need to read the implementation.)
22:51:23 <jle`> in the case where people take off comments to sacrifice understandability and readability...that's literally the opposite of what the article is talking about
22:51:43 <orb> Exactly.  The article tells you to rewrite  join $ (<*>) . (***), if you need comments.
22:52:05 <mutantmell> FWIW my day job I write Scala -- we have the same guideline re: comments
22:52:19 <Bashmetim> what I'm getting at is that there are degrees of readability - if you know Control.Arrow like the back of your hand then "speaks for itself" has a whole different meaning
22:53:17 <Mayzie> Which free, Linux Haskell IDE do you guys recommend (non-command line based)?
22:53:20 <orb> Know thy audience.
22:53:36 <nitrix> Unless you have to directly modify code that is written by a more experienced Haskell developer, the surrounding context around it is usually enough to figure things out.
22:53:38 <orb> Mayzie: tried putting plugins into your vim / Emacs?
22:53:45 <nitrix> In the worst cases, you have the type system on your side.
22:53:50 <orb> (They have X versions of vim and emacs.  So no command line.)
22:53:51 <Bashmetim> mayzie: emacs
22:53:54 <Mayzie> orb: No, don't really want to atm.
22:53:57 <mutantmell> Mayzie: some people have recommended Leksah
22:54:00 <jle`> Bashmetim: that doesn't invalidate what the point the article is making, right?  although it would be a nice addendum to remind people to be careful what they judge as instantly readable
22:54:13 <mutantmell> Mayzie: I've played with IntelliJ community using the plugin to some limited success
22:54:26 <Mayzie> I regularly use vim for C programming. But, just don't want to spend the time configuring it for Haskell development atm.
22:54:40 <mutantmell> Mayzie: But I'm honestly more of an emacs + ghci programmer.
22:54:46 <jle`> do it now, or do it later :)
22:54:47 <Bashmetim> jle`: The "could your pythonista friends parse this on their first try" test
22:54:55 <mutantmell> Mayzie: try Leksah http://leksah.org/
22:55:12 <nitrix> I'm running vim and ghci here. No mods whatsoever.
22:55:13 <Mayzie> Okies, thanks :-)
22:55:17 <jle`> well, now we're getting to a bit of a different topic
22:55:26 <orb> Bashmetim: I hope that's only a necessary standard, and not sufficient.
22:55:41 <osfameron> Mayzie: if you're already a vim user, then if you're using neobundle, it's really not hard to install the relevant Haskell plugins
22:55:57 <orb> Pythot people put up with a lot of stuff we wouldn't want in Haskell (even though you could write it that way in Haskell).
22:56:00 <Mayzie> Just realised leksah backward is haskel
22:56:11 <Bashmetim> Mayzie emacs + evil (for vim bindings) + haskell-mode (it's brilliant)
22:56:24 <jle`> now to just figure out what "Haskel" is
22:56:45 <Bashmetim> A lot of style guides recommend every function have a docstring, though
22:56:46 <jle`> haskell without laziness, maybe?
22:57:00 <orb> Haskel is Leksah spelled backwards.
22:57:05 <jle`> oh yes of course
22:57:22 <orb> Bashmetim: at least every top-level function that doesn't start with an underscore.  (In Python.)
22:57:56 <orb> If you export a module in Haskell, it's also nice to give some documentation for every exported function.
22:58:09 <jle`> that might be a useful thing to add to that article
22:58:11 <orb> jle`: That's Mu.
22:58:12 <Bashmetim> I think pep8 says '''All classes, class methods, and top-level functions'''
22:58:28 <mutantmell> Bashmetim: I find that both you and the article are correct.  No comments can cause problems, but bad comments can be worse :)
22:58:54 <Bashmetim> I liked the bit about comments not being verifiable by the compiler
22:59:10 <orb> Type annotation are a particularly useful `comment': they are checked for correctness by the compiler.
22:59:20 <Bashmetim> it sort of shows what sort of theoretical/academic angle haskell is approaching programming from
22:59:23 <mutantmell> So did I -- I absolutely hate it when I find comments several commits out of date
22:59:45 <ReinH> Mayzie: https://github.com/begriffs/haskell-vim-now
22:59:53 <orb> QuickCheck properties can be really useful tools (`comments') for conveying understanding of a program.
23:00:00 <ReinH> If you want an "IDE", Leksah
23:00:41 <ReinH> The author game ve a demo at ICFP and it's looking pretty good
23:00:48 <ReinH> *gave me
23:00:51 <jle`> Bashmetim: hopefully using types in a way that the compiler can verify that you're implementing your function correctly is not considered "theoretical/academic", heh
23:00:55 <jle`> at least, for long
23:00:55 <mutantmell> Let me know how Leksah is, I've never tried it.
23:01:09 <Bashmetim> if the comment is lying, then that's a huge problem and it needs to be fixed *because* you should expect a plain english explanation of anything that isn't trivial
23:02:14 <Bashmetim> jle` don't get me wrong! theoretical/academic is absolutely not a dirty word to me!
23:02:47 <jle`> ah, my comment was meant to say that compiler-verifiable code sounds extremely practical to me, heh
23:03:33 <Bashmetim> I think it's fair to say it's both
23:04:24 <Bashmetim> theorem proving type checking is the fruit you get to harvest after years of interesting math papers
23:05:49 <kras> what is .: ? Where will I get more info about this?
23:06:02 <mutantmell> :info (.:)
23:06:14 <mutantmell> I thought lamdbabot knew :info
23:06:26 <opqdonut> @info (.:)
23:06:26 <lambdabot> (.:)
23:06:31 <opqdonut> not much help :)
23:06:34 <opqdonut> kras: try hoogle
23:06:52 <mutantmell> :t (.:)
23:06:53 <lambdabot>     Not in scope: ‚Äò.:‚Äô
23:06:54 <lambdabot>     Perhaps you meant one of these:
23:06:54 <lambdabot>       ‚Äò.‚Äô (imported from Data.Function),
23:07:01 <mutantmell> ah, it doesn't know it
23:07:06 <opqdonut> hmm, hoogle doesn't know (.:) either
23:07:08 <Bashmetim> I have never seen (.:) before
23:07:15 <Bashmetim> kras where did you find it?
23:07:16 <mutantmell> I think it's in Lens?
23:07:17 <opqdonut> hayoo knows it
23:07:18 <opqdonut> http://hayoo.fh-wedel.de/?query=%28.%3A%29
23:07:26 <opqdonut> used in json stuff at least
23:07:30 <awpr> .: is something I define a lot, didn't know it's a real thing
23:07:35 <glguy_> No, it's not lens
23:07:36 <mutantmell> OH right, it's in aeson
23:07:38 <kras> http://www.seas.upenn.edu/~cis194/extras/05-IO/Parser.hs
23:08:12 <mutantmell> Or at least I used it in aeson
23:08:38 <glguy_> Some people define it as (.).(.)
23:09:01 <awpr> glguy_: that's the one I was referring to
23:09:20 <Bashmetim> looks like an 11 year old's calculator
23:10:02 <thimoteus> never realized how much i've come to depend on explicit types until i'm trying to fix a bug in someone else's python code 
23:10:34 <mutantmell> aeson defines it like this: (.:) :: (FromJSON a) => Object -> Text -> Parser a
23:11:30 <Bashmetim> thimoteus: coming back from haskell really changes the way you write code in other languages
23:13:28 <mutantmell> What I learned from Haskell is that all my previous attempts at separation of concerns were laughable
23:13:41 <Mayzie> ReinH: Cool, thanks :-)
23:13:54 <Bez_> @src recip
23:13:55 <lambdabot> Source not found. Wrong!  You cheating scum!
23:14:14 <Bez_> :i Fractional
23:14:22 <Bez_> >:i Fractional
23:14:28 <Bez_> >:info Fractional
23:14:30 <Bez_> :info Fractional
23:14:32 <opqdonut> @info Fractional
23:14:32 <lambdabot> Fractional
23:14:36 <mutantmell> > :info Fractional
23:14:37 <opqdonut> that's how you do it
23:14:37 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
23:14:39 <opqdonut> but it doesn't help
23:14:44 <Bez_> meh
23:14:44 <Bez_> thx
23:14:46 <glguy_> You can do :i in your local ghci and source is available in the haddock
23:15:16 <Bez_> Yea and that told me sth about recip, and I thought the lambdabot might know sth about it
23:15:23 <Bashmetim> nice one lambdabot!
23:15:25 <Bashmetim> nailed it!
23:15:32 <Bez_> oh well, gotta look somewhere lese
23:15:45 <mutantmell> > do do do do do do do do
23:15:47 <lambdabot>  Empty 'do' block
23:16:41 <mutantmell> @pl do do do do do do do do
23:16:41 <lambdabot> do do do do do do do do
23:16:57 <Bashmetim> @pl == print line?
23:16:57 <lambdabot> (line 1, column 1):
23:16:57 <lambdabot> unexpected "="
23:16:57 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
23:17:19 <Bashmetim> ... oops, guess not
23:17:41 <mutantmell> @pl (\a -> (foo a, bar a))
23:17:41 <lambdabot> liftM2 (,) foo bar
23:18:15 <mutantmell> @pl (\a -> foo a (bar a b))
23:18:15 <lambdabot> ap foo (flip bar b)
23:18:22 <awpr> @pl (\x -> do print x; return x)
23:18:22 <lambdabot> (line 1, column 18):
23:18:22 <lambdabot> unexpected ";"
23:18:22 <lambdabot> expecting variable, "(", operator or ")"
23:18:42 <awpr> @pl (\x -> do { print x; return x })
23:18:42 <lambdabot> (line 1, column 11):
23:18:42 <lambdabot> unexpected "{"
23:18:42 <lambdabot> expecting variable, "(", operator or ")"
23:19:16 <mutantmell> jle`: You're right, lambdabot hates Applicative
23:19:25 <awpr> well, I was trying to get it to say 'liftA2 (>>) print return'.  that's my new favorite use of the ((->) a) Applicative
23:20:01 <mutantmell> @pl \a -> ( print a >> print f a )
23:20:01 <lambdabot> liftM2 (>>) print (print f)
23:20:13 <mutantmell> @pl \a -> ( print a >> return a )
23:20:14 <lambdabot> liftM2 (>>) print return
23:20:33 <jle`> awpr: well.  i wouldn't really say it's the most readable way to write that
23:20:59 <awpr> well it is called the pointless obfuscation monad
23:21:05 <jle`> some people use (x <$ print x)
23:21:10 <mutantmell> @pl ( (>>) <$> print <*> return )
23:21:10 <lambdabot> (>>) <$> print <*> return
23:21:27 <mutantmell> :t (<$)
23:21:28 <lambdabot> Functor f => a -> f b -> f a
23:21:42 <jle`> for IO it's "replace the result with this"
23:22:08 <mutantmell> > 10 <$ [1,2,3]
23:22:10 <lambdabot>  [10,10,10]
23:22:27 <mutantmell> > 10 <$ ('foo', 1)
23:22:28 <lambdabot>      Syntax error on 'foo'
23:22:28 <lambdabot>      Perhaps you intended to use TemplateHaskell
23:22:28 <lambdabot>      In the Template Haskell quotation 'foo'
23:22:32 <jle`> interpretation varies for every type of course
23:22:34 <mutantmell> > 10 <$ ("foo", 1)
23:22:35 <lambdabot>  ("foo",10)
23:22:42 <mutantmell> Interesting
23:23:43 <awpr> > sequence [(+1), (*2), length . show] 10
23:23:45 <lambdabot>  [11,20,2]
23:24:09 <mutantmell> awpr: I did something similar recently
23:24:15 <mutantmell> > traverse (liftA2 (>>)) [(+1), (+2)] 10
23:24:16 <lambdabot>      No instance for (Typeable m0)
23:24:17 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
23:24:17 <lambdabot>        arising from a use of ‚Äòshow_M16417626848062088972059‚Äô
23:24:40 <mutantmell> > traverse (liftA2 (>>)) [(+1), (+2)] $ 10
23:24:42 <lambdabot>      No instance for (Typeable m0)
23:24:42 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
23:24:42 <lambdabot>        arising from a use of ‚Äòshow_M39564668836385588072069‚Äô
23:24:59 <mutantmell> apparently I can't remember it exactly :)
23:26:11 <Bashmetim> > sequence [(+1), (*2), length . show] 10 -- you should write as clearly as possible such that comments are not necessary
23:26:13 <lambdabot>  [11,20,2]
23:28:37 <mutantmell> Bashmetim: Nothing wrong with playing around with functions to get an intuition for Applicative :)
23:29:40 <Bashmetim> just teasing, I think it illustrates my point from earlier though
23:30:23 <Bashmetim> readable doesn't mean the same thing to a haskell wizard that it does to other developers
23:30:45 <mutantmell> agreed!
23:31:31 <mutantmell> In particular, a lot of monadic (and applicative) stuff is more clear in do notation than with the in-line stuff
23:31:44 <mutantmell> I'd like to hear from the Sigma folks at Facebook what their coding conventions are
23:31:58 <jle`> i don't think it's a fair standard to judge haskell readability based on what non-haskellers can read
23:31:59 <mutantmell> I think they had a lot of folks new to Haskell
23:32:22 <EvanR> we should all write in BASIC haskell so that BASIC programmers can understand the haskell code
23:32:25 <awpr> isn't that kind of trivially true of any two kinds of developers?  A C++ guru might feel lost in Python code because they can't see what's going on with the bits and memory.  A Pythonista will be lost in C++ code because WTF are all these angle brackets?
23:32:26 <jle`> it's case-by-case and audience-dependent
23:32:49 <Bashmetim> but it's considered bad style to use do notation for 1-3 lines because you should use (>>) and (>>=), right?
23:32:53 <jle`> no
23:32:54 <jle`> is it?
23:32:56 <EvanR> a c++ guru cant see whats going on with bits and memory anyway
23:32:58 <glguy_> No
23:33:01 <mutantmell> No
23:33:04 <jle`> i almost never use (>>=) ...
23:33:13 <mutantmell> I use (=<<) sometimes
23:33:14 <Bashmetim> I've seen that advice before
23:33:24 <EvanR> 3 line do notation is awesome
23:33:27 <Bashmetim> Also, pointfree > not point free
23:33:37 <jle`> i don't think you can make blanket statements like that
23:33:41 <jle`> it's definitely case-by-case
23:33:42 <EvanR> pointfree can suck
23:33:43 <mutantmell> I'm looking forward to ApplicativeDo because I won't feel bad for using do over <*>
23:33:50 <jle`> the end goal is readability, not "is it point free or not point free?"
23:34:03 <jle`> in some cases pointfree is much more readable than not point free
23:34:06 <jle`> in some cases it's not
23:34:11 <awpr> I use (=<<) a ton.  even within statements of do-notation.  if what's conceptually a function call can look like a function call, I'll make it look like a function call
23:34:16 <jle`> there's no blanket "do this always, this is always better" statement
23:34:24 <ent> when is point free more readable?
23:34:26 <jle`> > map negate [1,2,3]
23:34:27 <lambdabot>  [-1,-2,-3]
23:34:28 <jle`> vs.
23:34:32 <jle`> > map (\x -> negate x) [1,2,3]
23:34:34 <lambdabot>  [-1,-2,-3]
23:34:55 <jle`> the first case conveys the programmer's intent more clearly
23:35:02 <jle`> they want to map "negate" over every item in the list
23:35:06 <mutantmell> lenses are more clear point free
23:35:25 <Bashmetim> https://wiki.haskell.org/Pointfree calls it good discipline, also I've heard that point-free is more efficient in some cases
23:35:28 <jle`> the second case, it's "i want to map this function: 'take a number, -- let's call it x, becasue why not> --- and negate it.'"
23:35:46 <jle`> point free vs non point free is a false dichotomy
23:35:50 <ent> jle`: ok, that is a lot clearer :)
23:35:53 <EvanR> man changing the spelling of haskell for efficiency? :(
23:36:00 <jle`> readability is the end goal, not blanket rules to follow blindly
23:36:02 <EvanR> what is this javascript
23:36:30 <awpr> that doesn't sound true, unless we're talking about Constant Applicative Forms
23:36:39 <jle`> case-by-case, and aware of your audience, is the way to go
23:36:39 <EvanR> Bashmetim: youd really like the optimizer to not care if you wrap something with a lambda "uselessly"
23:36:44 <Bashmetim> i don't want to disagree with that, because I do agree it goes on a case by case basis
23:36:56 <Bashmetim> but "map (\x -> negate x) [1,2,3]" is totally a straw-man
23:37:13 <jle`> it's a counter-example
23:37:19 <jle`> to "point-free is always less readable"
23:37:30 <jle`> point free is sometimes more readable, and is sometimes less readable
23:37:35 <EvanR> pointfree is more clear in the dot dot dot idiom: map (+1) . filter even . reverse . sort
23:37:53 <jle`> it's true that some people say, "always do point free whenever you can" --- and in that case, they're just as misguided as "never use point-free ever"
23:38:17 <jle`> "use point free when it's more readable, and don't use it when it isn't" is the only thing you can really say
23:38:22 <Bashmetim> balance in all things, absolutely
23:38:33 <EvanR> also screw balance in all things ;)
23:38:45 <jle`> don't prioritize balance over readability
23:38:48 <jle`> if we're talking about readability
23:38:54 <jle`> the more readable choice should be taken over the more balanced choice :)
23:40:38 <Bashmetim> I was only agreeing that the more readable choice is going to vary, no one rule should be followed absolutely
23:41:15 <jle`> fair :)
23:41:22 <EvanR> fair and balanced
23:41:58 <Bashmetim> ew no rupert murdoch why
23:47:14 <mutantmell> I'm finally getting around to reading Parallel and Concurrent Haskell
23:47:18 <mutantmell> what a wonderful book
