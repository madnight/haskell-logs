00:05:32 <SparkySparkyBoom> hi
00:05:42 <SparkySparkyBoom> i have an MArray that's being mutated by a function
00:06:16 <SparkySparkyBoom> am i correct in assuming that i need to return an MArray at the end of the do block?
00:09:52 <tabemann> if it's being mutated, why do you need to return it?
00:11:11 * hackagebot patches-vector 0.1.4.0 - Patches (diffs) on vectors: composable, mergeable, and invertible.  https://hackage.haskell.org/package/patches-vector-0.1.4.0 (LiamOConnorDavis)
00:22:45 <echo-area> Is there a library similar to Java's Netty?  I didn't find one as mature
00:29:03 <zugz> well package haskell98 be updated for base-4.8, or is there another way to compile haskell98 code with ghc-7.10?
00:29:06 <zugz> will*
00:41:12 * hackagebot cassava-conduit 0.2.1 - Conduit interface for cassava package  https://hackage.haskell.org/package/cassava-conduit-0.2.1 (domdere)
01:22:35 <kallisti> @pl (\(k,v) -> (toName k, parseJSON v))
01:22:35 <lambdabot> toName *** parseJSON
01:24:45 <some0ne> hi =)
01:26:14 <some0ne> someone told me yesterday that i should almost never use lazy IO. after few google it seems that this opinion il largely shared. it seems to have 4 alternative: Conduit, pipes, stream, iteratee. should they be used in small project ? or will they insert too much complexity for
01:26:17 <some0ne> what they provide ?
01:28:47 <ChristianS> some0ne: i generally find it OK to use lazy IO, especially for small projects
01:29:18 <kallisti> the reason people discourage lazy IO is because it doesn't have deterministic finalization of external resources
01:29:37 <some0ne> it was also because it could throw an exception at any moment
01:31:09 <kallisti> if you have a small number of open resources, and you can work around the exception handling quirks, then it's fine to use lazy IO
01:32:07 <some0ne> ok
01:32:26 <kallisti> for example, if your program doesn't need to handle any exceptions at all (it's expected to crash completely if any IO exceptions trigger)
01:32:52 <kallisti> which is often the case for simple file manipulation scripts and things of that nature
01:34:32 <kallisti> if you do need to catch exceptions, make sure the exception handler is bound at a point where data read from the resource isn't referenceable outside of that scope. Sometimes it can be difficult to figure out where exactly that is.
01:37:11 <some0ne> oh you're right, currently i just enclose the call that could fail, so i should enclose the parent and never miss any exception
01:37:32 <kallisti> maybe
01:37:40 <kallisti> if you're using something like getContents for example
01:37:45 <some0ne> readFile
01:39:19 <kallisti> right readFile works the same way as getContents. any kind of lazy IO that returns a lazy String can potentially throw an IO exception everytime you deconstruct a (:) from the result String
01:41:03 <kallisti> so one solution would be to do something like: mapM try outString
01:42:22 <kallisti> which forces you to check a Either SomeException Char everytime
01:42:31 <some0ne> clever :D
01:43:01 <some0ne> i was trying to use the return of 'try' in an either monad but the exception wasn't catched anymore
01:43:42 <some0ne> content <- try (something); case content >>= parse of
01:44:08 <kallisti> something being the whole list?
01:44:16 <some0ne> something was the readFile
01:44:29 <some0ne> the case pattern match Right/Left
01:44:50 <some0ne> only parse error where catched, if content contained an error it was raised and not handled in the pattern match
01:44:51 <kallisti> yeah, that won't work because the exceptions are only triggered when you deconstruct the list, since the IO operations are conflated with the non-strict evaluation semantics
01:45:08 <some0ne> oh ! that make sense
01:45:11 <some0ne> :D
01:46:14 <some0ne> in my head even if the operation is lazy it always execute in the 'try'. now i know it's not true ^^
01:46:24 <kallisti> so for example:  case something of (x : xs) -> ...; [] -> ...
01:46:41 <kallisti> would only throw an IO exception if reading the first character from the file causes an exception
01:48:31 <some0ne> so try is totatly useless if it does not enclose the whole function that use the data ?
01:48:43 <some0ne> as you stated before
01:48:50 <kallisti> it needs to enclose an expression that fully evaluates the list
01:49:06 <kallisti> to ensure total coverage of exceptions
01:50:50 <some0ne> i will have to patch everything i have written so far :D
01:50:52 <kallisti> basically anywhere the string can potentially be evaluated
01:51:57 <kallisti> I believe "mapM try something" will catch every possible error
01:52:24 <kallisti> but say you only have 3 top-level points in your code where you perform any evaluation of the file output
01:52:32 <kallisti> then you only need 3 trys
01:53:59 <some0ne> try (length something) is not faster thatn your mapM ?
01:54:18 <kallisti> well then you might as well not be using lazy IO
01:54:43 <some0ne> there is no strict IO in default haskell
01:55:07 <kallisti> @hoogle System.IO.Strict.readFile
01:55:09 <lambdabot> No results found
01:55:11 <some0ne> there is 2 package that provide strict IO
01:55:13 <kallisti> @hoogle System.IO.Strict
01:55:13 <lambdabot> package StrictBench
01:55:13 <lambdabot> package strict
01:55:13 <lambdabot> package strict-base-types
01:55:28 <kallisti> some0ne: ByteString also has a strict file read
01:55:47 <kallisti> @hoogle readFile
01:55:47 <lambdabot> Prelude readFile :: FilePath -> IO String
01:55:47 <lambdabot> System.IO readFile :: FilePath -> IO String
01:55:47 <lambdabot> Data.ByteString.Lazy.Char8 readFile :: FilePath -> IO ByteString
01:56:06 <kallisti> well, obviously Data.ByteString.Lazy is the lazy version
01:56:30 <some0ne> i've began my project using text.strict bu i needed the list monad
01:57:17 <ptcek> some0ne: I'm beginner, used pipes, did what I needed, works nice, moved to the next problem. it was really that simple :)
01:58:02 <some0ne> ptcek: i will try to test pipes/conduit/strict and other stuff in my next project ;)
02:00:58 <kallisti> using lazy IO for something non-trivlai s definitely a good way to learn the motivations behind streaming abstractions. :)
02:01:23 <some0ne> :D
02:02:32 <kallisti> @pl (\(a,b) -> f a <$> g b)
02:02:32 <lambdabot> uncurry ((. g) . (<$>) . f)
02:03:17 <kallisti> @pl (\(a,b) -> (f a ,) <$> g b)
02:03:18 <lambdabot> (line 1, column 17):
02:03:18 <lambdabot> unexpected ","
02:03:18 <lambdabot> expecting variable, "(", operator or ")"
02:03:56 <kallisti> @pl (\(a,b) -> (,) (f a) <$> g b)
02:03:56 <lambdabot> uncurry ((. g) . (<$>) . (,) . f)
02:05:14 <kallisti> {-# LANGUAGE OverloadedStrings, RecordWildCards, ConstraintKinds, DataKinds, PolyKinds, TypeFamilies, FlexibleContexts, FlexibleInstances, NoMonomorphismRestriction, GADTs, TypeSynonymInstances, TemplateHaskell, FunctionalDependencies, TypeOperators, UndecidableInstances, TupleSections #-}
02:05:26 <obadz-> I seem to remember there was a way to specify in which order overlappping typeclass instances should be tried.. what was the name of that extension/pragma?
02:05:31 <kallisti> I'm currently suffering from "extension-oriented programming"
02:06:43 <kallisti> doesn't ring a bell
02:08:45 <obadz-> :-/
02:14:46 <TheCrafter> Hello #haskell !! I am trying to install the 'warp' package but I get this error when building: http://lpaste.net/143260 . I am using ghc 7.10.2 . Has anyone ever had the same problem?
02:16:10 <Phyx-> that... looks like the package is broken..
02:17:14 <Phyx-> although it was uploaded two days ago..
02:17:21 <TheCrafter> I just checked their github. It looks like they fixed it on the 3.1.6 release but its not on hackage yet
02:17:30 <Phyx-> 3.1.6 is on hackage
02:17:35 <Phyx-> update your cabal
02:17:41 <TheCrafter> wait yeah it is
02:17:42 <TheCrafter> my bad
02:17:54 <Phyx-> cabal tars*
02:19:01 <kallisti> https://travis-ci.org/yesodweb/wai/builds/82683159  here's the travis builds for that version
02:21:44 <obadz-> So when using overlapping instances, the ghc attempts to bind to the most specific instance.. so which of these two is more specific?
02:21:55 <obadz-> instance Show a => MyClass a where..
02:22:05 <obadz-> or instance ToJSON a => MyClass a where.. ?
02:22:45 <Sinestro> is it possible to "mostly" stick with LTS Haskell while cheating with a newer version of one specific package?
02:23:35 <kallisti> yes you can specify that in your stack config
02:23:49 <kallisti> don't remember the option name though
02:24:08 <Cale> obadz-: neither
02:24:17 <Cale> obadz-: also, both of those instances will match every type
02:24:27 <Sinestro> extra-deps
02:24:40 <Cale> obadz-: Type class constraints on instances are only considered *after* instance selection.
02:25:07 <kallisti> obadz: from GHC docs "If exactly one non-incoherent candidate remains, select it. If all remaining candidates are incoherent, select an arbitary one. Otherwise the search fails (i.e. when more than one surviving candidate is not incoherent)."
02:25:15 <obadz-> Cale: so it only looks at things like Maybe a or [a] is more specific than a? but the constraint isn't looked at?
02:25:21 <Cale> obadz-: There is a good reason for this -- it's not possible to determine that an instance of a type class definitely doesn't exist, because it may be provided in a future module.
02:25:32 <Cale> obadz-: correct.
02:25:37 <kallisti> note that is happens during constraint solving, not when the instances are actually defined.
02:26:17 <Cale> kallisti: That's with incoherent instances -- which he'd also have to use if he wants instances like that to be useful at all
02:26:22 <Cale> But which he probably shouldn't use :P
02:26:34 <obadz-> kallisti: is there a way to print a warning if it's selecting arbitrarily amongst incoherent instances? 
02:26:58 <Cale> obadz-: Basically, if you find yourself wanting instances like that, you probably didn't want a type class in the first place.
02:27:09 <obadz-> Cale: what did I want then?
02:27:12 <Cale> Consider using a polymorphic record type.
02:27:29 <Cale> Basically a record of the methods which would have gone in your type class.
02:27:43 <obadz-> hmmmm let me think about that and come back with questions ;-)
02:27:53 <Cale> obadz-: Or in this case, consider using String
02:28:04 <Cale> since those instances look a whole lot like "I am a String"
02:28:38 <Cale> If the only thing you know about something is that it's of some type which is an instance of Show, it might as well be a String.
02:35:32 <obadz-> And what's more specific instance Functor f => MyClass (f a) or instance Num a => Myclass [a] ? :) [Int] will bind to?
02:36:55 <obadz-> Sorry meant to ask instance Functor f => MyClass (f Int) vs instance Num a => MyClass [a]
02:39:08 <mariooo> Hi all :) is there some way to automatically generate a restricted import list from an existing (working) source file?
02:41:23 <mariooo> i.e. import Control.Monad.Trans.Class -> import Control.Monad.Trans.Class (lift)
02:42:21 <Gurkenglas> Why is http://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.Foldable.html#foldrM implemented via a left fold? Wouldn't that bar some uses of laziness?
02:43:15 <jle`> probably for performance
02:43:55 <jle`> er well actually hm
02:59:59 <obadz-> (if there was an answer to my question, I didn't see it due to disconnection)
03:04:06 <spill> not since your last, xx:36 message
03:12:48 <ttt_fff> when using haskell, what is the advantage of json over yaml
03:12:56 <ttt_fff> is there ever any point where I want to voluntarily pick json over yaml?
03:17:15 <obadz-> ttt_fff: if there other side expects json, then sending yaml is going to piss them off :)
03:22:01 <osfameron> json is arguably easier to manually edit. yaml might arguably be more flexible (at least it is more powerful at serializing Perl objects in its native implementation)
03:22:09 <osfameron> I doubt there's much in it though
03:22:34 <osfameron> I tend to use json by preferences because of the former reason, but basically it depends on what obadz- said :-)
03:23:46 <obadz-> osfameron: isn't yaml easier to edit?
03:26:03 <ChristianS> json is terrible to edit by hand, but yaml is still a bit tricky
03:26:28 <kallisti> @pl \n -> (f n, n)
03:26:28 <lambdabot> (,) =<< f
03:27:18 <obadz-> ChristianS: is there better than yaml in the set of commonly accepted standards??
03:27:59 <ChristianS> obadz: what's your application scenario and why is editability important?
03:28:13 <ttt_fff> yaml is so much more readable :-)
03:28:23 <ttt_fff> or maybe I just get poorly formated json
03:28:41 <ChristianS> obadz: toml is nice for config-like data, but i don't know whether there is a good haskell parser+emitter yet
03:28:44 <obadz-> ChristianS: I don't have a scenario.. ttt_fff was the OP ;-)
03:29:01 <ttt_fff> yeah; I'm at fault :-)
03:29:04 <Gurkenglas> :t runState . gets -- kallisti, here's an option if the rest of your code fits
03:29:05 <lambdabot> (s -> a) -> s -> (a, s)
03:29:10 <ChristianS> ttt_fff: and?
03:29:23 <ttt_fff> ChristianS: and I'm not sorry.
03:29:30 <ttt_fff> Is there a problem?
03:29:55 <ChristianS> ttt_fff: no, i'm just curious about your application scenario
03:30:09 <ttt_fff> oh; a colleague sent me really badly formated json and beautifuly formatted json
03:30:19 <ttt_fff> err, poorly formatted json and nicely formated yaml
03:30:22 <ttt_fff> and I thought yaml was nicer to read
03:30:35 <ttt_fff> but upon more research, I thikn my colleague just sent me poorly formatted json and nicely formaeed  yaml
03:33:08 <ChristianS> ttt_fff: beautifuly formatted json will look much nicer than unformated json, though
03:36:38 <bennofs> ttt_fff: YAML parsers are much more complicated than JSON parsers though :)
03:42:19 <obadz-> is there a way to ask ghc to show which instance it selects at compile time?
03:43:38 <ideuler> I've a main using Data.ByteStrings getLines and reads, and another using prelude's. For my own test cases they both work. Yet for a contest (can't check the exact input), the ByteString version seems to be causing an exception. Any way to check what is happening?
03:45:22 <pacak> obadz-: If there's more than one instance - you are doing something wrong.
03:45:42 <pacak> ideuler: non-ascii symbols?
03:51:20 * hackagebot luminance 0.5.1 - Type-safe, dependently-typed and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.5.1 (DimitriSabadie)
03:51:54 <ideuler> pacak I'd assume that, although the input is meant to be just ints. I suppose it errors out with the fromJust. Thanks
03:56:32 <UncleAlf> anyone type :q! when quitting ghci? :P
03:57:15 <ttt_fff> no, I press alt-ctrl-delete
03:58:22 <UncleAlf> does that reboot emacs
04:10:02 <rcat> how could I use `withStateT' from the StateT monad in a monad transformer? I the right layer I mean
04:20:40 <pavonia> rcat: What part of that function don't you understand?
04:20:55 <Gurkenglas> What do you think of this heuristic: When ala/alaf produce a type signature isomorphic to the type signature of a library function, that library function should have had the type signature produced by the ala/alaf
04:22:55 <rcat> pavonia: I see that "withStateT :: (s -> s) -> StateT s m a -> StateT s m a" so that I need to unwrap outter monads to access my state
04:24:25 <pavonia> Not sure I understand what you mean, you usually "lift" that function to the right level
04:28:46 <osfameron> obadz-: yaml is quite subtle with e.g. indentation.  maybe it's just a personal preference though
04:29:30 <rcat> pavonia: yeah, I was trying that with "lift" but it doesn't type check
04:29:41 <obadz-> pacak: I'm not saying I'm not doing something wrong.. I'd like ghc to point it out to me..
04:30:51 <Cale> Gurkenglas: seems highly suspect :P
04:30:58 <pavonia> rcat: Could you paste the relevant part of you code?
04:31:28 <pavonia> your*
04:33:46 <lpaste> rcat pasted “withStateT in a monad transformer” at http://lpaste.net/143263
04:33:59 <Cale> Gurkenglas: In particular, which permutation of arguments should be used is something that is highly context dependent.
04:36:02 <Gurkenglas> :t (alaf StateT traverse, mapAccumL) -- Cale, when do you want those arguments or that pair the other way round?
04:36:03 <lambdabot> (Monad m', Traversable t, Traversable t1) => ((a -> s' -> m' (a', s')) -> t a -> s' -> m' (t a', s'), (a1 -> b -> (a1, c)) -> a1 -> t1 b -> (a1, t1 c))
04:36:26 <beepbeep_> factorial :: Num a => a -> a
04:36:26 <beepbeep_> factorial n = product [1..n]
04:36:49 <beepbeep_> says I should add Enum a to the context of the type signature.
04:36:54 <beepbeep_> What does that mean?
04:37:08 <Gurkenglas> factorial :: (Enum a, Num a) => a -> a
04:37:08 <beepbeep_> or rather, why does this not work?
04:37:12 <Cale> mapAccumL in the list library has the pairs the correct way around
04:37:41 <Cale> er, more importantly, the arguments to the function are the right way around
04:37:52 <Cale> mapAccumR is the one which is weird
04:38:18 <Cale> http://cale.yi.org/share/Folds.png -- see diagrams here for why
04:38:18 <kallisti> "Could not deduce (RSubset f f'0 (RImage f f'0)) from the context (f <stderr>: commitBuffer: invalid argument (invalid character)"
04:38:22 <kallisti> alright GHC, whatever you say
04:38:44 <Cale> \f -> mapAccumR (flip f) is in some sense "more natural"
04:39:09 <Cale> Just because it's more similar in structure to foldr/scanr
04:39:43 <Gurkenglas> :t (alaf Endo foldMap, foldr) -- :D
04:39:45 <lambdabot> (Foldable t, Foldable t1) => ((a1 -> a -> a) -> t a1 -> a -> a, (a2 -> b -> b) -> b -> t1 a2 -> b)
04:39:46 <beepbeep_> Gurkenglas, I don't understand, could you give me some more info?
04:40:22 <pavonia> rcat: When you do "st <- plan", the type of st is "a" as in your type signature
04:40:43 <Gurkenglas> beepbeep_, Double has a Num instance, but "all numbers between 1 and n" doesnt make sense
04:41:37 <Cale> Well, Double wouldn't be a great example there, because it's an instance of Enum
04:41:43 <Cale> Try Complex Double
04:41:55 <Cale> [1..n] is more questionable notation then
04:41:57 <Gurkenglas> It is? Huh.
04:42:24 <Cale> Though, I think Enum should just mean "how to expand the list iteration syntax"
04:42:32 <Cale> and pred/succ should get dropped
04:42:57 <hodapp> Cale: does list iteration syntax just become an iteration of 'succ'?
04:43:01 <Cale> no
04:43:12 <Cale> It becomes enumFromTo
04:43:17 <hodapp> oh, right
04:43:18 <Cale> and enumFromThenTo
04:43:21 <Cale> etc.
04:44:07 <Cale> Also toEnum/fromEnum are weird
04:44:24 <Cale> They're convenient at times, I'll admit, but I don't think they belong in Enum either.
04:44:56 <Cale> At least, enumFrom/enumFromThen/enumFromTo/enumFromThenTo deserve to be in their own class.
04:45:55 <Gurkenglas> Cale, evalState/execState/runState have the same arguments for and against putting the s as the last argument that foldr does with the z, right?
04:46:06 <beepbeep_> Hmm. I don't understand. What would the type annotation for "average ns = sum ns `div` length ns" be?
04:46:18 <beepbeep_> I thought it'd be Num a => [a] -> a
04:46:27 <beepbeep_> but just like factorial, that doesn't seem to work.
04:46:29 <Cale> Gurkenglas: Oh, I guess if the main thing is the pair ordering, I prefer having the state type first
04:46:40 <Cale> Gurkenglas: at least... most of the time
04:47:01 <beepbeep_> or, what should I read in order to understand?
04:47:06 <cocreature> beepbeep_: use fromIntegral (length ns)
04:47:08 <Cale> Gurkenglas: If you have something which acts as "extra" data, it should be first in the pair, and the "main" thing should generally be second.
04:47:08 <cocreature> :t length
04:47:09 <lambdabot> Foldable t => t a -> Int
04:47:17 <cocreature> that Int is the problem
04:47:21 <Cale> Gurkenglas: because of how the Functor instance for (,) s works out
04:47:43 <cocreature> beepbeep_: also div requires an Integral
04:47:48 <cocreature> so you get Integral a => [a] -> a
04:50:11 <Cale> I'm upset every time I see a beginner discussion and a Prelude type signature with a Foldable constraint in it shows up.
04:51:04 <beepbeep_> I'm trying to run before I can walk. The course I'm following really hasn't discussed type signatures, I kind of started exploring myself because mod-cgi was complaining.
04:52:03 <beepbeep_> oh but mod-cgi just gives me the annotations
04:52:07 <beepbeep_> cool
04:52:09 <Cale> beepbeep_: Anyway, if we make that length :: [a] -> Int, you can see what the problem might be.
04:52:23 <Cale> length ns will have type Int
04:52:28 <beepbeep_> oic
04:52:35 <Cale> and both of div's arguments must have the same type
04:52:40 <beepbeep_> aha
04:52:44 <Cale> and so  sum ns  had better have type Int as well
04:52:46 <beepbeep_> that makes sense
04:52:49 <Cale> and then ns :: [Int]
04:53:05 <Cale> and so we infer  average :: [Int] -> Int
04:53:14 <Cale> which isn't what you wanted, probably
04:54:35 <beepbeep_> yeah, exactly
04:54:36 <Gurkenglas> Cale, that last line of mine was supposed to compare the "evalState :: State s a -> s -> a" vs "evalState :: s -> State s a -> a" clash to the "foldr :: (a -> b -> b) -> b -> [a] -> b" vs "foldr :: (a -> b -> b) -> [a] -> b -> b" clash
04:54:47 <Cale> So yeah, fromIntegral is the usual way to convert from any Integer-like type to an arbitrary numeric type
04:55:07 <Cale> In particular, you could use it to convert the Int you get from length to any sort of number
04:55:41 <Gurkenglas> Compare (>>=) vs (=<<)
04:55:43 <Cale> Gurkenglas: Yeah, there's no one totally correct answer
04:56:31 <Cale> What you'd want it to be depends on how you're using it.
04:57:28 <Cale> Don't forget  foldr :: [a] -> (b -> (a -> b -> b) -> b)
04:58:31 <Cale> (translating a list into its Church form)
04:58:41 <Gurkenglas> Make it [a] -> ((a -> b -> b) -> b -> b) and I'm in :P
05:01:04 <Cale> The fact that the real foldr takes the replacement for (:) before the replacement for [] also seems a bit strange to me sometimes, but yeah, there are definitely cases where that order is handy.
05:01:51 <Gurkenglas> That's because ((a -> b -> b) -> b -> b) is ((a -> Endo b) -> Endo b)
05:02:23 <Gurkenglas> (At least that's what I would say if I had to justify it)
05:08:12 <Copperis> Hello
05:08:53 <Copperis> how can I see the implementation of ByteString's Show typeclass ?
05:09:25 <Copperis> or any other type's implementation of a typeclass?
05:09:55 <Cale> http://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString.html -- find the documentation for the type, and click the Source link next to the instance
05:10:07 <Cale> takes you to here -> http://hackage.haskell.org/package/bytestring-0.10.6.0/docs/src/Data.ByteString.Internal.html#line-210
05:10:44 <Copperis> thanks, Cale 
05:11:37 <Cale> Whoever generated that documentation is using an unusual colour scheme
05:11:55 <Cale> I sort of wish it were higher constrast, especially the comments
05:12:30 <cocreature> Cale: that's just the default color scheme that haddock uses now afaik
05:12:48 <Cale> Oh, that's... kind of annoying
05:13:19 <Cale> The old colour scheme wasn't perfect, but it was closer to readable :P
05:15:29 <kallisti> anyone know how to make a FromJSON instance for a vinyl record?
05:17:36 <lpaste> kallisti pasted “vinyl FromJSON attempt (error at bottom)” at http://lpaste.net/143264
05:18:25 <kallisti> I basically need to create the right record type out of thin air and then populate it with the JSON values regardless of ordering.
05:18:49 <kallisti> I figured rput would be the ideal function to use for ignoring field order, but it can't deduce instances correctly it seems.
05:20:55 <hpc> since updating my ghc, it seems like inferred types are being treated a bit more strictly
05:21:30 <hpc> i had a function that required FlexibleContexts, but would work without it if i omitted the type signature
05:23:05 <beepbeep_> :t 1 
05:23:06 <lambdabot> Num a => a
05:23:13 <beepbeep_> :t 2.5
05:23:15 <lambdabot> Fractional a => a
05:23:19 <beepbeep_> :t (1, 2.5)
05:23:20 <lambdabot> (Fractional t1, Num t) => (t, t1)
05:23:43 <kallisti> :t [1, 2.5]
05:23:44 <lambdabot> Fractional t => [t]
05:24:38 <beepbeep_> so weird that the type signature for (1, 2.5) is backwards, why is that?
05:25:18 <hpc> class constraints are unordered
05:25:31 <hpc> it's just how ghc decided to do it, but doesn't affect anything
05:25:38 <hpc> and the RHS is still correct
05:25:51 <Clint> it's nice and alphabetical
05:26:13 <beepbeep_> oh yeah alphabetical :p
05:26:47 <lyxia> > sort "(Fractional t1, Num t) => (t, t1)"
05:26:49 <lambdabot>  "      (()),,11=>FNaacilmnortttttu"
05:39:47 <^elyse^> Is there a systematic way of computing the number of inhabitants of any potentially quantified type?
05:39:54 <^elyse^> For types without forall it's trivial.
05:40:04 <hpc> in a sandbox, how does one get cabal repl to use the result of cabal build?
05:40:14 <hpc> and not bytecode-compile the source files?
05:40:16 <^elyse^> Also disregarding bottom.
05:40:46 <hpc> there is
05:41:15 <hpc> (though there might not be if you introduce type classes, gadts, etc)
05:41:37 <hpc> but like, Either is sort of like (+), (,) is like (*)
05:41:43 <hpc> (a -> b) is (b ** a)
05:42:08 <^elyse^> How about forall a. a -> a? It's 1 but how do you compute that?
05:42:58 <^elyse^> Treat a as 1?
05:43:05 <hpc> it's more than one, but yeah
05:43:20 <hpc> the only value you know 'a' has is bottom
05:43:23 <^elyse^> How can there be more than one? The only value is \x -> x
05:43:31 <^elyse^> <^elyse^> Also disregarding bottom.
05:43:32 <^elyse^> :P
05:43:44 <hpc> oh, disregarding bottom, the 'a' is zero then
05:43:52 <hpc> > 0 ** 0
05:43:54 <lambdabot>  1.0
05:44:10 <hpc> like forall a. Either a () is size 1
05:44:19 <hpc> because you can't construct a left value
05:44:30 <hpc> (you could if bottoms were factored in)
05:44:53 <Gurkenglas> forall a. a -> Either a a is two tho, but (0 + 0) ** 0 is still 1
05:44:56 <^elyse^> but id is definitely a function
05:45:02 <^elyse^> and has type forall a. a -> a
05:45:55 <^elyse^> yet 0 ** 0 is indeterminate
05:45:56 <hpc> Gurkenglas: oh yeah
05:48:16 <^elyse^> I think you have to treat a as 1
05:48:50 <^elyse^> no, wait, nevermind
05:48:52 <Gurkenglas> a -> a -> a is two, but 1 ** 1 ** 1 is one
05:49:32 <hpc> clearly things get weird when you repeat type variables
05:49:48 <hpc> or at least, when you mix them with (->)
05:49:59 <hpc> (which is able to magically give you a value of that type)
05:50:18 <Gurkenglas> I surely expect someone to have done the math on this some decades ago
05:50:23 * hpc would have to think about it for a bit
05:50:28 <^elyse^> Maybe I'll ask on Stack Overflow
05:50:30 <hpc> or yeah, do some googling
05:50:59 <hpc> let us know if you solve it, this is a good question
05:52:13 <Gurkenglas> a -> b is 0, even without repeating any type variables
05:52:36 <Darwin226> Hey guys, anyone got experience with the diagrams library?
05:53:17 <jophish> Darwin226: I'm sure lots of people here are, it's probably best to just ask your question
05:53:25 <jophish> Darwin226: You could also check out #diagrams :D
05:54:09 <Darwin226> jophish: Ok, I'll ask here first. So I'd like to fill my shape with a pattern instead of just a solid color. Any way to do that?
05:54:50 <jophish> Darwin226: I can't think of a way off the top of my head, but I'm certainly no expert in diagrams.
05:55:04 <jophish> It's a very flexible library, so it's certainly possible
05:56:11 <Unhammer> bytestring-trie is amazing!
05:56:12 <Darwin226> jophish: I guess I could tile the pattern and then maybe some masking stuff if that's possible. But I'm worried that the resulting SVG will get huge. On the other hand, it really don't matter for my purposes
05:58:03 <julianleviston> I’m trying to build some code with the hint library (Language.Haskell.Interpreter). My preliminary test is just to add two ints together, but the return type seems to need to be in the IO monad… or at least a monad that has an instance of MonadInterpreter… given that I’m using snap, and I want this code to be called from a Snaplet Handler (data Handler b v a, which has a MonadIO instance), how can I call my funct
05:58:03 <julianleviston> from a handler?
05:58:33 <julianleviston> I’m not really familiar with MT’s yet… I’ve read a couple tutes, but… yeah
05:58:40 <Gurkenglas> Hah I can't even find the haddocks on diagrams
05:59:27 <julianleviston> Gurkenglas: which version of diagrams? 
05:59:37 <Gurkenglas> The latest, I guess?
05:59:45 <julianleviston> Gurkenglas: might be this? http://projects.haskell.org/diagrams/haddock/
06:00:08 <Gurkenglas> Ah thanks. How'd you find that?
06:00:34 <julianleviston> Gurkenglas: googled “haskell diagrams haddocks” - 3rd ref down.
06:00:44 <julianleviston> (mind you google is personalised to individuals, so… mmm)
06:01:19 <Gurkenglas> yep 4th for me, the others are unrelated and I had looked at the first one ^^
06:01:35 <julianleviston> Gurkenglas: sorry, 4th for me, too… I can’t count, apparently :)
06:03:41 <lpaste> JulianLeviston pasted “Obiwan, please help...” at http://lpaste.net/143266
06:05:20 <lpaste> Gurkenglas annotated “Obiwan, please help...” with “Try this?” at http://lpaste.net/143266#a143267
06:06:00 <julianleviston> Gurkenglas: <3 thanks.
06:06:12 <julianleviston> Gurkenglas: that feels like it’s really basic if I understood monads better…
06:07:15 <^elyse^> hpc Gurkenglas: asked here: http://stackoverflow.com/q/33198181/1804599
06:08:20 <Gurkenglas> https://hackage.haskell.org/package/hint-0.3.3.2/docs/Language-Haskell-Interpreter.html (from googling the import) looked like it supports MonadIO, so I used liftIO to turn the "IO (Either I.InterpreterError Int)" into a "Handler (Either I.InterpreterError Int)" so it fits the do block, the <- "extracts" the "Either I.InterpreterError Int" and the Right takes out the Int (calling the monads fail definition if we 
06:08:20 <Gurkenglas> have an I.InterpreterError)
06:08:35 <julianleviston> Gurkenglas: yeah, it does support MonadIO.
06:09:17 <julianleviston> Gurkenglas: thanks…
06:09:17 <Copperis> in the ghci that I'm using cons == cons' (from Data.ByteString.Lazy). I.e. there's no laziness. Am I missing something?
06:09:48 <julianleviston> Copperis: not sure what your question means?
06:10:06 <Copperis> i'll do a paste
06:10:20 <julianleviston> Gurkenglas: so liftIO puts the “innards” of the monad into a different monad?
06:10:30 <Gurkenglas> :t liftIO
06:10:32 <lambdabot> MonadIO m => IO a -> m a
06:11:05 <julianleviston> how… odd.
06:11:09 <Gurkenglas> Something "supports" MonadIO iff it defines this function.
06:11:17 <julianleviston> ah ok.
06:11:30 <julianleviston> Gurkenglas: any handy pointers on learning Monad Transformers?
06:11:36 <julianleviston> Gurkenglas: / resources?
06:11:45 <Gurkenglas> (Via "instance MonadIO X where liftIO = ...")
06:12:13 <lpaste> Copperis pasted “cons == cons'” at http://lpaste.net/143268
06:12:32 <Gurkenglas> julianleviston, iirc the way I learned it was when someone suggested a refactoring of an lpaste using monad transformers to make it shorter
06:12:52 <julianleviston> Copperis: what language extensions do you have on?
06:13:18 <julianleviston> Gurkenglas: ah ok… 
06:13:21 <Copperis> julianleviston, I'm using only ghci and do not know
06:13:30 <julianleviston> Copperis: ah then probably none.
06:13:38 <Gurkenglas> (And then I think I just read the hackage docs)
06:13:40 <julianleviston> :t cons
06:13:41 <lambdabot> Cons s s a a => a -> s -> s
06:13:51 <julianleviston> hm different Cons I’m guessing
06:14:00 <Copperis> probably
06:14:09 <Copperis> I'll check how it works outside of ghci
06:14:56 <julianleviston> Copperis: yeah, this is a bit beyond me, sorry. I would expect what you expect, too.
06:15:03 <hexagoxel> Copperis: how do you test for lazyness?
06:15:15 <Gurkenglas> julianleviston, you already know how when you have "case x of Nothing -> Nothing; Just x -> f x", you can simplify it using "x >>= f", right?
06:15:35 <julianleviston> ByteString isn’t lazy tho, is it? data ByteString = Empty | Chunk {-# UNPACK #-} !S.ByteString ByteString
06:15:43 <Gurkenglas> (And that's how one should be introduced to the monad instance of Maybe imo)
06:15:59 <julianleviston> Gurkenglas: yeah, I know that
06:16:13 <julianleviston> Gurkenglas: I understand why what you showed me worked
06:16:21 <julianleviston> Gurkenglas: I just never would have known how to get there myself.
06:16:30 <julianleviston> Gurkenglas: because I didn’t know what liftIO does
06:16:44 <julianleviston> Gurkenglas: I should go re-learn lifting again.
06:17:08 <julianleviston> Gurkenglas: I didn’t realise it involved “dropping” the monad.
06:17:28 <julianleviston> :t liftIO
06:17:29 <lambdabot> MonadIO m => IO a -> m a
06:17:36 <julianleviston> Gurkenglas: (using the wrong lingo I’m sure)
06:17:48 <julianleviston> Gurkenglas: please correct me.
06:17:57 <Copperis> hexagoxel, as I understand it should show in ghci's terminal, that the bytestring is full of chunks
06:18:07 <Gurkenglas> The same way, if you have "do x <- foo; case x of Nothing -> return Nothing; Just x -> f x", you can simplify that using "foo >>= MaybeT . f", and that's how I was introduced to MaybeT and so were you >:D
06:18:39 <julianleviston> Gurkenglas: what is the f tho?
06:18:49 <Gurkenglas> Anything that fits in the first expression
06:18:50 <julianleviston> Gurkenglas: foo >>= MaybeT . f…. what is the f?
06:19:05 <julianleviston> Gurkenglas: hm
06:19:10 <Gurkenglas> (umm, "runMaybeT $ foo >>= MaybeT . f" because you probably want to unpack the newtype afterwards again)
06:19:12 <julianleviston> Gurkenglas: well I don’t understand that.
06:19:16 <hexagoxel> Copperis: you mean, the default Show instance would return _different_ results depending on how far the structure is evaluated?
06:20:09 <Copperis> hexagoxel, it should return different results for those two functions
06:20:20 <hexagoxel> Copperis: i really don't think that the repl does anything other than printing the thing.
06:20:29 <Gurkenglas> julianleviston, like in '"case x of Nothing -> Nothing; Just x -> f x" -> "x >>= f"': If you have code involving any x and f that looks like on the left, you can use the same x and f like on the right
06:20:30 <Copperis> though I'm no expert on the matter
06:20:48 <julianleviston> Gurkenglas: what is that function tho? that case?
06:21:00 <hexagoxel> Copperis: wouldn't `1+3` in the repl print <<THUNK>> otherwise?
06:21:06 <julianleviston> Gurkenglas: it looks like fmap
06:21:11 <Gurkenglas> julianleviston, I said "0 + x is x" and you asked "What is x?"
06:21:22 <julianleviston> Gurkenglas: I am so confused.
06:21:27 * hackagebot secp256k1 0.1.3 - secp256k1 bindings for Haskell  https://hackage.haskell.org/package/secp256k1-0.1.3 (xenog)
06:21:34 <julianleviston> Gurkenglas: can you start over?
06:23:06 <julianleviston> Gurkenglas: ok so you said this at the first: you already know how when you have "case x of Nothing -> Nothing; Just x -> f x", you can simplify it using "x >>= f", right?
06:23:12 <julianleviston> Gurkenglas: that’s not right
06:23:40 <julianleviston> Gurkenglas: because there’s nothing on the right saying that x >>= f is a Maybe 
06:24:06 <lpaste> Gurkenglas pasted “julianleviston, here.” at http://lpaste.net/143269
06:24:55 <Copperis> hexagoxel, no it wouldn't. Could be that a bytestring can be represented multiple ways and depending on how it is - that is how it is showed. Though I'm completely guessing, since I learned bytestrings recently and not sure if haskell support the thing's I'm saying. Anyway, here's the place I got the idea from - http://learnyouahaskell.com/input-and-output#bytestrings You can find the example a little lower
06:24:55 <julianleviston> Gurkenglas: ok.
06:25:10 <julianleviston> Gurkenglas: I dont’ really understand what that has to do with my example tho…
06:25:14 <Gurkenglas> Those simplifications work whenever doThingsWith has type "a -> Maybe b"/ doMoreThingsWith has type "a -> m (Maybe b)"
06:25:51 <julianleviston> Gurkenglas: mega-confusing.
06:25:54 <julianleviston> Gurkenglas: oh well.
06:26:04 <Gurkenglas> f in your example is a function that produces a value mapped in Maybe, because f x must have the same type as Nothing
06:26:15 <Gurkenglas> -mapped+wrapped
06:26:42 <julianleviston> Gurkenglas: I’m not using Maybe, tho… I’m using IO, then MonadIO… and Either...
06:27:15 <Gurkenglas> I assumed that by "my example" you meant the one with the x and f
06:28:26 <Gurkenglas> I introduced those examples to take the use case of the Maybe monad and draw an analogy to the use case of the MaybeT monad
06:28:33 <Gurkenglas> *transformer
06:28:39 <julianleviston> Gurkenglas: yeah, I followed that.
06:29:07 <lpaste> pjdelport annotated “cons == cons'” with “cons != cons' (inspecting with toChunks)” at http://lpaste.net/143268#a143270
06:30:06 <julianleviston> Gurkenglas: I’m not sure how to model what’s going on with monad transformers
06:30:46 <julianleviston> :t runMaybeT
06:30:47 <lambdabot> Not in scope: ‘runMaybeT’
06:30:54 <Gurkenglas> @let import Control.Monad.Trans.Maybe
06:30:56 <lambdabot>  Defined.
06:30:57 <Gurkenglas> :t runMaybeT
06:30:58 <Copperis> cool, thanks pjdelport 
06:30:59 <lambdabot> MaybeT m a -> m (Maybe a)
06:31:04 <julianleviston> is it just the newtype accessor?
06:31:08 <Gurkenglas> yes
06:31:10 <julianleviston> k
06:31:39 <julianleviston> Gurkenglas: sorry this is completely opaque to me.
06:31:50 <Gurkenglas> What do you mean by "going on"? I'll guess you got by now that all of the monad transformers identify boilerplate and distill its essence into a library, just like most Monads themselves do
06:34:32 <julianleviston> Gurkenglas: let’s see… I understand monads to a degree, but I need to reinforce my understanding and also practice it more. I think MonadT’s are a way to jam two or more Monads together into a newtype
06:34:48 <julianleviston> Gurkenglas: to get the functionality of both.
06:34:55 <jophish> Is there a function in hunit to conjoin a bunch of assertions, something like: Foldable f => f Assertion -> Assertion
06:35:36 <hpc> type Assertion = IO ()
06:35:43 <jophish> hpc: I just saw that!
06:35:44 <portnov1> :t length
06:35:45 <jophish> thanks!
06:35:45 <lambdabot> Foldable t => t a -> Int
06:35:52 <julianleviston> Gurkenglas: but I’ve never used them, and I don’t really understand anything beyond that… all the examples I’ve seen use monads I don’t really understand like Reader, Writer or State.
06:35:54 <hpc> fold with (>>)
06:36:01 <jophish> exactly
06:36:05 <hpc> ;)
06:36:15 <julianleviston> Gurkenglas: I have the theory down pat for those monads, but I’ve never used them so it’s all theoretical knowledge.
06:36:23 <hexagoxel> Copperis: also note Chunks != Thunks. confused me for a second.
06:36:35 <Copperis> ok
06:38:00 <julianleviston> Gurkenglas: I’ve read this: https://en.wikibooks.org/wiki/Haskell/Monad_transformers and this https://github.com/kqr/gists/blob/master/articles/gentle-introduction-monad-transformers.md and gone through the RWH MT chapter once or twice… 
06:38:55 <Gurkenglas> I'll try explaining the State monad by first explaining the Endo monoid
06:39:03 <julianleviston> Gurkenglas: but my understanding of Monads is probably still too sketchy to really get all of it.
06:39:07 <julianleviston> Gurkenglas: ok :)
06:39:22 <julianleviston> Gurkenglas:  hey… thanks so much for taking the time to teach me this. Kinda epic.
06:39:51 <julianleviston> Gurkenglas: before you start, I don’t actually learn things theoretically very well.
06:40:03 <julianleviston> Gurkenglas: just so you know. real world examples work for me.
06:40:41 <Gurkenglas> The Endo newtype wraps functions of type (a -> a) into "Endo a" packets. Two "Endo a" can be combined with mappend to compose them, because the Monoid instance defines mappend as (.)
06:40:52 <Gurkenglas> (mempty is defined as id.)
06:40:58 <Gurkenglas> :t fold
06:40:59 <lambdabot> (Foldable t, Monoid m) => t m -> m
06:41:24 <Gurkenglas> Combines a list of monoid values into one by mappending them (using foldr mappend mempty)
06:41:28 <julianleviston> I don’t understand what “wraps functions into packets” means
06:42:15 <Gurkenglas> I invented words there. "newtype Endo a = Endo {appEndo :: a -> a}"
06:42:38 <julianleviston> Gurkenglas: ok… so endo is an endomorphism?
06:42:40 <Gurkenglas> "instance Monoid Endo a where mappend = (.); mempty = id"
06:42:42 <Gurkenglas> yep
06:42:44 <julianleviston> ok
06:43:23 <julianleviston> so could I say appEndo (+2) <> appEndo (+3) ?
06:46:29 <Gurkenglas> No, Endo (+2) <> Endo (+3)
06:46:31 <Gurkenglas> > Endo (+2) <> Endo (+3)
06:46:32 <lambdabot>      No instance for (Show (Endo a0))
06:46:32 <lambdabot>        arising from a use of ‘show_M83352768655106886584854’
06:46:32 <lambdabot>      In the expression:
06:46:46 <julianleviston> right
06:46:48 <julianleviston> sill me. sorry
06:46:49 <Gurkenglas> > appEndo $ Endo (+2) <> Endo (+3) -- Huh, it doesn't derive Show? appEndo unpacks
06:46:50 <lambdabot>  <Integer -> Integer>
06:46:58 <julianleviston> Gurkenglas: no show coz they’re functions.
06:47:01 <Gurkenglas> Ah, thats why ^^
06:47:05 <julianleviston> yup
06:47:30 <Gurkenglas> Okay so fold can turn a list of Endos into one, just like with any monoid
06:48:05 <Gurkenglas> > appEndo (fold $ [Endo (+i) | i <- [0..5]]) 0
06:48:06 <lambdabot>  15
06:48:14 <julianleviston> Gurkenglas: whoa… um… hang on
06:48:18 <julianleviston> what is fold?
06:48:20 <julianleviston> :t fold
06:48:21 <lambdabot> (Foldable t, Monoid m) => t m -> m
06:48:25 <julianleviston> oh… from foldable.
06:48:27 <julianleviston> ook
06:48:43 <julianleviston> I just learned that the other day.
06:48:45 <Gurkenglas> I said that up there ._:
06:49:11 <julianleviston> Gurkenglas: sorry, people use fold to mean foldr sometimes.
06:49:26 <julianleviston> why do you need the $ up there?
06:49:34 <Gurkenglas> Right, I dont
06:49:37 <julianleviston> > appEndo (fold [Endo (+i) | i <- [0..5]]) 0
06:49:38 <lambdabot>  15
06:49:39 <julianleviston> ok sweet
06:49:51 <julianleviston> ok I’m with you now.
06:50:06 <Gurkenglas> :t foldMap -- btw this gives us a hook to use a function on all the list elements to turn them into a monoid
06:50:07 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
06:50:24 <Gurkenglas> :t appEndo (foldMap Endo [(+i) | i <- [0..5]])
06:50:26 <lambdabot> (Enum a, Num a) => a -> a
06:50:27 <julianleviston> what’s a hook?
06:50:39 <Gurkenglas> Inventing words again, an argument
06:50:51 <Gurkenglas> > appEndo (foldMap Endo [(+i) | i <- [0..5]]) 0
06:50:51 <julianleviston> Gurkenglas: sorry for being so literal
06:50:52 <lambdabot>  15
06:51:12 <julianleviston> righty, yeah I only just learned Foldable the other day, so all good (like 4 days ago)
06:51:23 <julianleviston> I didn’t remeber foldMap - need to revise it.
06:51:32 <Gurkenglas> By the way, lens gives us a nice utility for avoiding the manual unpack: ala. (Do not use :t on ala, you wont like it :P)
06:51:54 <julianleviston> what’s a manual unpack?
06:51:55 <Gurkenglas> > ala Endo foldMap [(+i)|i<-[0..5]] 0
06:51:57 <lambdabot>  15
06:52:01 <jophish> :t ala
06:52:02 <lambdabot> (Rewrapped s t, Rewrapped t s) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
06:52:07 <julianleviston> oh… like a generic way to unwrap a newtype?
06:52:25 <julianleviston> nice! I was wondering why there wasn’t one of those the other day…
06:52:59 <julianleviston> Gurkenglas: that type seems understandable to me.
06:53:27 <lpaste> Medicijnman pasted “Syntax Tree” at http://lpaste.net/720486111138283520
06:53:30 <julianleviston> tho I don’t see how 15 is :: Unwrapped s, really… 
06:54:04 <medicijnman> Hi guys. I am trying to create a monad instance of a kind of rose tree
06:54:19 <julianleviston> Gurkenglas: oh… is that an anamorphism?
06:54:22 <exio4> @type ala `asAppliedTo` Endo
06:54:23 <medicijnman> the paste will show you an example that you can run with ghci
06:54:24 <lambdabot> ((a -> a) -> Endo a) -> (((a -> a) -> Endo a) -> e -> Endo a) -> e -> a -> a
06:54:24 <Gurkenglas> medicijnman, Data.Fix has a nice thing for that
06:54:30 <julianleviston> Gurkenglas: sorry, a kind of catamorphism?
06:54:45 <julianleviston> Gurkenglas: obviously not an anamorphism.
06:54:55 <Gurkenglas> ala needs to be told how to unwrap a newtype, Unwrapped is a type family that maps Endo a to a, Sum a to a, etc
06:55:15 <Gurkenglas> So "Unwrapped s" here is "Unwrapped (Endo a)"="a"
06:55:20 <julianleviston> Gurkenglas: where do you tell ala that? 
06:55:29 <julianleviston> Gurkenglas: is it just inside lens?
06:55:32 <Gurkenglas> Yep
06:55:37 <julianleviston> Gurkenglas: ok handy :)
06:55:51 <exio4> Gurkenglas: you mean Unwrapped (Endo a) = a -> a ? 
06:56:05 <Gurkenglas> Its already done for all the newtypes in base etc, if you define your own newtype you can use deriveWrapped from TH to have the stuff ala needs automatically defined for you
06:56:11 <Gurkenglas> Right.
06:56:18 <julianleviston> nice
06:57:53 <medicijnman> Gurkenglas: would you mind elaborate on fix?
06:58:35 <Gurkenglas> medicijnman, sorry I meant https://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html
07:00:07 <Gurkenglas> If you define "data Node a t = Node a [t]", then Fix can be used to pass Node a to itself, so you get something like "Node a (Node a (Node a (...)))", which is incidentally a rose tree :D
07:00:44 <Gurkenglas> "Fix (Node a)" is the name of the type, then.
07:01:32 <Gurkenglas> If you derive Functor, Foldable, Traversable for Node a, then Fix comes with batteries included to allow you to do catamorphisms, anamorphisms, etc
07:02:22 <joneshf-laptop> medicijnman, I feel like this problem you're trying to solve would be a very illustrative way to learn typed holes.
07:02:50 <obadz-> what is ghc-prim-0.4.0.0:GHC.Prim.Any compared to "a" and why does ghc-mod sometimes show the former rather than the latter?
07:02:55 <joneshf-laptop> medicijnman, though I'm not sure if there are any good tutorials about how to use them...
07:02:56 <medicijnman> Gurkenglas: ah thanks. i'll take a look at it
07:03:28 <Gurkenglas> julianleviston, lens also defines au, which allows you to supply your own isomorphism if you dont have one predefined by a Wrapped instance
07:03:29 <medicijnman> joneshf-laptop: i'm not familiar with typed holes so i guess this is a good time to take a look at it
07:03:58 <Gurkenglas> > au (iso appEndo Endo) foldMap [(+i)|i<-[0..5]] 0
07:04:00 <lambdabot>  15
07:04:01 <julianleviston> Gurkenglas: what’s an isomorphism again?
07:04:22 <Gurkenglas> A function and its inverse
07:04:31 <julianleviston> Gurkenglas: I don’t follow that.
07:04:41 <Gurkenglas> (Mathematically, a function with an inverse such that composing both is id)
07:05:01 <quartz455> k
07:05:05 <julianleviston> Gurkenglas: I thought an isomorphism is another way to write a function...
07:05:39 <julianleviston> Gurkenglas: as in… “functionally equivalent == isomorphic” no?
07:06:09 <Gurkenglas> Let me rephrase: You can give lens the information ala gets from Wrapped instances by giving au an unwrapper and a wrapper using iso
07:06:28 <julianleviston> Gurkenglas: your example made it clear, thanks.
07:06:48 <joneshf-laptop> medicijnman, this seems like a fairly decent start: http://www.shimweasel.com/2015/02/17/typed-holes-for-beginners/
07:06:51 <julianleviston> Gurkenglas: I often wondered what iso was for
07:07:05 <julianleviston> joneshf-laptop:  thanks I’ll look into that too… very interested! :)
07:07:42 <medicijnman> joneshf-laptop: thanks. it looks the same as https://wiki.haskell.org/GHC/Typed_holes (or maybe it is?)
07:08:00 <julianleviston> Gurkenglas: is this isomorphism from cat theory?
07:08:08 <Gurkenglas> julianleviston, thats where the name comes from
07:08:17 <julianleviston> Gurkenglas: oh.. not the same concept?
07:09:07 <Gurkenglas> It is the same concept, but in lens, when you have an iso, you already computationally have both the function and its inverse
07:09:21 <julianleviston> Gurkenglas: anyway, continue.
07:09:52 <julianleviston> Gurkenglas: not sure where the inverse comes into play, but it’s probably unimportant to understand Monad Transformers via Endo Monoids and the State Monad
07:10:23 <julianleviston> Gurkenglas: three levels of (what I’m going to here call) “enveloping” is quite a lot, but I feel I can keep up with it.
07:10:53 <rcat> is there anything similar to `lift' but to lift a function and not only a value?
07:11:08 <Gurkenglas> > 5 & iso (*2) (/2) %~ (+1) -- There, it uses both the function and its inverse. If I didnt know Haskell, but knew math, and you told me you defined an isomorphism, i would expect that you defined a function that happened to have in inverse
07:11:09 <lambdabot>  5.5
07:11:18 <Gurkenglas> But yes Ill go on :P
07:11:38 <Gurkenglas> julianleviston, just as Endo wraps (a -> a), State wraps (s -> (a, s)). (Internally, the newtype wrapper StateT wraps (s -> m (a, s)), and that's what ala knows, so we cant quite use ala here.)
07:12:07 <rcat> because I'm trying with `liftM' but I don't manage to get it working
07:12:16 <julianleviston> Gurkenglas: what does ala do again?
07:12:32 <julianleviston> rcat: lifting *is* on functions.
07:13:14 <julianleviston> rcat: pastie your example and people will help.
07:13:21 <Gurkenglas> It takes a newtype constructor (so it knows what newtype's features you want to "borrow" (inventing words)), then a function like foldMap or mapM or traverse
07:13:27 <Gurkenglas> :t foldMap
07:13:29 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
07:13:35 <julianleviston> :t ala
07:13:36 <lambdabot> (Rewrapped s t, Rewrapped t s) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
07:13:36 <Gurkenglas> A function "with a hook", as I put it earlier
07:14:04 <Gurkenglas> It puts the newtype wrapper into that first argument of foldMap
07:14:19 <Gurkenglas> and unwraps the result of foldMap with the unwrapper
07:14:19 <julianleviston> Gurkenglas: my brain just jettisoned its contents
07:14:52 <julianleviston> Gurkenglas: what were you using ala for, tho?
07:14:54 <kallisti> > Just 2 <> Just 3
07:14:56 <lambdabot>      No instance for (Show a0)
07:14:57 <lambdabot>        arising from a use of ‘show_M50695853283530893625456’
07:15:00 <lambdabot>      The type variable ‘a0’ is ambiguous
07:15:13 <Gurkenglas> > ala Endo foldMap [(+i)|i<-[0..5]] 0
07:15:14 <lambdabot>  15
07:15:28 <kallisti> > Just 2 `mplus` Just 3
07:15:30 <lambdabot>  Just 2
07:15:33 <Gurkenglas> It makes it so I dont need to unwrap the resulting Endo myself.
07:15:34 <julianleviston> Gurkenglas: erm… then what’s iso for?
07:15:53 <julianleviston> Gurkenglas: oh… right ala is the generic newtype “value retriever”
07:16:07 <julianleviston> Gurkenglas: and iso is the “ala function retriever” so to speak.
07:16:13 <Gurkenglas> > au (iso appEndo Endo) foldMap [(+i)|i<-[0..5]] 0 -- When you can't use the Wrapped instance ala uses, you can define the wrapper and unwrapper yourself
07:16:15 <lambdabot>  15
07:16:24 <Gurkenglas> All ala does is call au with the iso the Wrapped instance defines
07:16:26 <julianleviston> wait what is au?
07:16:35 <julianleviston> now I’m *really* confused.
07:16:40 <Gurkenglas> :t au
07:16:42 <lambdabot> AnIso s t a b -> ((b -> t) -> e -> s) -> e -> a
07:16:45 <julianleviston> lol
07:16:50 <julianleviston> lens types are great.
07:16:50 <kallisti> @hoogle mconcat
07:16:51 <lambdabot> Data.Monoid mconcat :: Monoid a => [a] -> a
07:17:48 <julianleviston> (Sum 1) <> (Sum 2)
07:17:49 <Gurkenglas> It takes an isomorphism (iso unwrapper wrapper), a function like foldMap, puts the wrapper into the (b -> t) spot, and applies the unwrapper to the s to get an a
07:17:55 <julianleviston> > (Sum 1) <> (Sum 2)
07:17:57 <lambdabot>  Sum {getSum = 3}
07:18:07 <Gurkenglas> > ala Sum foldMap [1,2,3]
07:18:09 <lambdabot>  6
07:18:26 <julianleviston> Gurkenglas: I got lost in envelopes, sorry.
07:18:42 <julianleviston> Gurkenglas: as I usually do when Haskellers try to explain anything besides the most simplest of concepts to me.
07:18:45 <aweinstock> :t iso
07:18:46 <lambdabot> (Functor f, Profunctor p) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
07:18:57 <Gurkenglas> julianleviston, just as Endo wraps (a -> a), State wraps (s -> (a, s)). (Internally, the newtype wrapper StateT wraps (s -> m (a, s)), and that's what ala knows.)
07:19:12 <julianleviston> Gurkenglas: yeah but I don’t understand why you can’t use ala for that
07:19:25 <Gurkenglas> Because StateT is a newtype constructor and State isnt
07:19:40 <julianleviston> Gurkenglas: I thought we were talking about State.
07:19:48 <kallisti> is there some kind of shorthand for:  foldr mplus Nothing . map f ?
07:19:58 <joneshf-laptop> medicijnman, same idea, but much simpler example to start with.
07:20:01 <Gurkenglas> There is no function named State, because internally State actually wraps (s -> Identity (a, s)) so all the functions defined for StateT can be used for State
07:20:15 <aweinstock> :t mplus
07:20:16 <lambdabot> MonadPlus m => m a -> m a -> m a
07:20:24 <julianleviston> Gurkenglas: oh you were talking about StateT.
07:20:29 <Gurkenglas> The library defines the wrapper "state" and the unwrapper "runState", though, so we can use those
07:20:43 <Gurkenglas> :t au (iso runState state) traverse
07:20:45 <lambdabot> Traversable t => t (s -> (b, s)) -> s -> (t b, s)
07:20:49 <julianleviston> Gurkenglas: yeah, I know that there’s actually no such thing as State (tho I think there USED to be, right?)
07:21:19 <medicijnman> joneshf-laptop: yeah it is simpler indeed. i'm still trying to gasp the whole concept of monads
07:21:32 <julianleviston> Gurkenglas: so I still don’t understand why we can’t use ala
07:21:58 <Gurkenglas> :t ala StateT traverse
07:21:59 <lambdabot> (Monad m', Traversable t) => t (s' -> m' (a', s')) -> s' -> m' (t a', s')
07:22:04 <Gurkenglas> :t ala State traverse
07:22:05 <lambdabot>     Not in scope: data constructor ‘State’
07:22:05 <lambdabot>     Perhaps you meant one of these:
07:22:05 <lambdabot>       ‘StateT’ (imported from Control.Monad.State),
07:22:57 <Gurkenglas> The Wrapped instance for the StateT newtype works with StateT. We can't have a second Wrapped instance for dealing with State, so we have to use our own isomorpism and pass it to au
07:23:28 <Gurkenglas> :t au (iso runState state) traverse :: [s -> (b, s)] -> s -> ([b], s)
07:23:29 <lambdabot> [s -> (b, s)] -> s -> ([b], s)
07:23:38 <Gurkenglas> Can you imagine what this function does, from the type signature?
07:23:39 <julianleviston> Gurkenglas: why can’t you just use the one for StateT then?
07:23:56 <aweinstock> :t ala StateT foldMap
07:23:57 <lambdabot> (Foldable t, Monoid (StateT s' m' a')) => t (s' -> m' (a', s')) -> s' -> m' (a', s')
07:24:10 <julianleviston> These code examples are staggeringly unhelpful
07:24:13 <Gurkenglas> :t ala StateT traverse -- aweinstock, thats what you want
07:24:14 <lambdabot> (Monad m', Traversable t) => t (s' -> m' (a', s')) -> s' -> m' (t a', s')
07:24:23 <julianleviston> I know you’re trying to help. Just letting you know.
07:24:39 <aweinstock> Gurkenglas: I'm trying to figure out what you mean by "like foldMap"
07:25:09 <Gurkenglas> :t au -- aweinstock, "like foldMap" = "fits the second argument"
07:25:10 <lambdabot> AnIso s t a b -> ((b -> t) -> e -> s) -> e -> a
07:25:35 <Gurkenglas> julianleviston, "[s -> (b, s)] -> s -> ([b], s)" can you imagine a function of this signature does?
07:26:05 <aweinstock> :t (foldMap, mapM, traverse, sequence)
07:26:06 <lambdabot> (Monad m1, Monad m2, Applicative f, Foldable t, Traversable t1, Traversable t2, Traversable t3, Monoid m) => ((a -> m) -> t a -> m, (a1 -> m1 b) -> t1 a1 -> m1 (t1 b), (a2 -> f b1) -> t2 a2 -> f (t2 b1), t3 (m2 a3) -> m2 (t3 a3))
07:26:07 <julianleviston> Gurkenglas: no clue.
07:26:22 <julianleviston> Gurkenglas: well...
07:26:42 <aweinstock> :t AnIso
07:26:43 <lambdabot> Not in scope: data constructor ‘AnIso’
07:26:44 <Gurkenglas> aweinstock, mapM is to sequence as traverse is to sequenceA as foldMap is to fold
07:26:47 <julianleviston> Gurkenglas: it takes two arguments… a list of functions, and a value, and returns a pair of lists of values with values.
07:27:12 <julianleviston> Gurkenglas: sort of… folds over it or something
07:27:26 <aweinstock> Gurkenglas: I think that makes sense to me
07:27:38 <medicijnman> joneshf-laptop: how does ghci evaluate the type of _foo in the first example? i would like to run the code but it won't work unless i replace "g x y = _foo" with: g x (a,c) = (x a,c)
07:28:17 <joneshf-laptop> medicijnman, it won't run with that hole there.
07:28:41 <joneshf-laptop> medicijnman, it'll just get as much type information as posisble and tell you to fix it, while also providing you that information.
07:29:20 <joneshf-laptop> medicijnman, I don't believe it actually compiles anything, I think it just stops.
07:29:49 <medicijnman> joneshf-laptop: yes that's right, i just get not in scope: _foo
07:30:08 <medicijnman> joneshf-laptop: also, g2 till g7 lack an accompanying binding
07:30:31 <Gurkenglas> julianleviston, http://sketchtoy.com/66039843
07:32:10 <joneshf-laptop> medicijnman, what version of ghc do you have?
07:32:18 <julianleviston> Gurkenglas: is that a traversal? I don’t really understand traversals yet.
07:32:31 <medicijnman> joneshf-laptop: $ ghc --version
07:32:31 <medicijnman> The Glorious Glasgow Haskell Compilation System, version 7.6.3
07:32:43 <joneshf-laptop> ah
07:32:51 <joneshf-laptop> medicijnman, it was introduced in 7.8.1
07:33:28 <medicijnman> joneshf-laptop: ahhh. makes sense. i guess i should download from their site rather than use apt-get
07:34:16 <julianleviston> Gurkenglas: from my understanding of State, it just looks like a repeated set of state manipulations
07:34:28 <Gurkenglas> julianleviston, I find that traverse can nicely display the full power of a monad. Here's one such diagram for Maybe: http://sketchtoy.com/66039859
07:35:13 <julianleviston> Gurkenglas: sorry I didn’t follow that one at all
07:35:29 <srhb> medicijnman, joneshf-laptop: You can defer type errors for the full flexibility of dynamic typing! (also introduced in 7.8, afair)
07:35:33 <julianleviston> Gurkenglas: is that thing on the right supposed to be the nothing case?
07:35:47 <Gurkenglas> Encircled x stands for Just x
07:35:50 <julianleviston> Gurkenglas: at least, I mean, a list with a Nothing in it?
07:35:56 <julianleviston> Gurkenglas: what notation is this??
07:36:06 <Gurkenglas> Lightning bolt for nothing. (Have you never seen lightning bolts in math proofs!?)
07:36:15 <julianleviston> Gurkenglas: nope.
07:36:30 <julianleviston> Gurkenglas: I’d love to learn math proofs sometime… 
07:36:41 <joneshf-laptop> medicijnman, I'm not sure. But if you get updated, let me know and we can work through your example if you'd like.
07:36:47 <Gurkenglas> What the Maybe monad does is acting like normal everywhere when everything is full of justice, and flipping out at the first Nothing
07:36:55 <julianleviston> Gurkenglas: yeah, I know that
07:37:01 <joneshf-laptop> medicijnman, though, be warned. I'm pretty ad-hoc with typed holes, so maybe you want someone more formalized.
07:37:10 <julianleviston> Gurkenglas: the thing I didn’t know was your explanation nomenclature.
07:37:24 <julianleviston> Gurkenglas: isn’t this just sequenceM?
07:37:50 <julianleviston> or sequence, rather?
07:38:09 <julianleviston> > sequence [Just 1, Just 2, Just 5]
07:38:11 <lambdabot>  Just [1,2,5]
07:38:13 <Gurkenglas> sequence and sequenceA are the same thing, and mapM and traverse are the same thing
07:38:17 <julianleviston> sequence [Just 1, Just 2, Nothing]
07:38:23 <julianleviston> oh ok.
07:38:39 <Gurkenglas> (Except when something has an applicative instance but no monad instance.)
07:38:42 <julianleviston> so I kinda don’t see the point of having traversable at the moment.
07:39:10 <Gurkenglas> Yea you can imagine Traversable t to always mean t is [] for the moment.
07:39:13 <medicijnman> joneshf-laptop: building from source does not seem to work unfortunately.
07:39:27 <julianleviston> Gurkenglas: so… how does this help me understand monad transformers?
07:39:35 <medicijnman> joneshf-laptop: i'm going to lunch now. so brb
07:39:47 <Gurkenglas> It's supposed to help understand the State monad :D
07:40:13 <julianleviston> but I already understood the state monad
07:40:23 <julianleviston> at least, to a degree.
07:40:47 <julianleviston> the thing I didn’t understand is monad transformers when there are multiple monads in play
07:40:50 <Gurkenglas> "<julianleviston> Gurkenglas: but Ive never used them, and I dont really understand anything beyond that all the examples Ive seen use monads I dont really understand like Reader, Writer or State."
07:41:06 <julianleviston> Gurkenglas: yep.
07:41:16 <Gurkenglas> <Gurkenglas> I'll try explaining the State monad by first explaining the Endo monoid <julianleviston> Gurkenglas: ok :)
07:41:27 <Gurkenglas> ._.
07:41:39 <julianleviston> Gurkenglas: I didn’t actually understand why you were explaining State Monad to me.
07:41:56 <Gurkenglas> I was explaining the state monad because you said that you dont understand the state monad :D
07:42:05 <Gurkenglas> (Reader and Writer are just simplified State monads anyway.)
07:42:09 <julianleviston> Gurkenglas: Like I said, I’m ok with the theory. I know how they work inside, to a degree… but I haven’t had any practice with them or used them, so I don’t understand them.
07:42:49 <julianleviston> Gurkenglas:  sorry, I should possibly have explained what “understand” means, to me… it means I can work with it, flip it about, make it do whatever I want, and know how to use it in any context… because I’ve experienced it, not just learned the theory of it.
07:43:14 <julianleviston> Gurkenglas: if you said right now “do this with the state monad”, I still wouldn’t have a hope of doing anything with it, because I haven’t used it.
07:43:19 <julianleviston> Gurkenglas: THAT is understanding.
07:44:13 <julianleviston> Gurkenglas:  but right now, I *am* trying to use some monad transformers, and I don’t really understand *or* know how they work. How can you have two monads on the one monad at once? How can you look understneath one to find the other? I really draw blanks… that’s why I was asking if you knew of any tutes or helpful explanations for such.
07:44:44 <Gurkenglas> I've noticed that when I've just grokked the theory behind a monad newtype X, I get a big moment of awe when I understand what sequence/sequenceA do to it (or, for less unwrapping, ala X mapM/ala X traverse)
07:45:39 <Gurkenglas> So I just remembered that and tried to convey the experience :P
07:45:43 <julianleviston> Gurkenglas: if you remember, this all came out of the question I originally had which was about why liftIO is needed to be used to put a type of IO (Either I.InterpreterError Int) into a context where there was an instance of MonadIO at play.
07:46:47 <julianleviston> Gurkenglas: thanks, and sorry for wasting your time.
07:46:57 <Gurkenglas> Hmm, I fear what I could say on that might fall prey to the monad tutorial fallacy
07:47:17 <julianleviston> Gurkenglas: how do you mean?
07:48:19 <julianleviston> Gurkenglas: I don’t know what that fallacy is.
07:48:23 <Gurkenglas> What I remember of the process of learning it is "find code snippets that can be shortened with this or that monad transformer" until an underlying pattern of monad transformers emerged, but I may be misremembering and my process might not work as well for oyu
07:49:20 <julianleviston> Gurkenglas: what’s “the monad fallacy”?
07:49:47 <Gurkenglas> Hmm. To understand what I mean, read the start of http://dev.stephendiehl.com/hask/#monads
07:51:05 <Gurkenglas> https://wiki.haskell.org/wikiupload/2/23/Monad-tutorials-chart.png
07:52:10 <julianleviston> Gurkenglas: yeah, I know there are a lot of monad tutorials.
07:52:13 <rcat> pavonia: I think I solved my problem, I needed to use `hoist', damn, this was harder than usual... Thanks for the help anyway!
07:52:16 <julianleviston> Gurkenglas: I’m not after a tutorial. :)
07:52:33 <joneshf-laptop> julianleviston, care for an alternative on the why?
07:52:46 <julianleviston> joneshf-laptop: I don’t follow?
07:52:56 <joneshf-laptop> julianleviston, the why of transformers.
07:53:04 <nshepperd> the monad tutorial fallacy is.. thinking that writing a monad tutorial is helpful?
07:53:06 <joneshf-laptop> julianleviston, why they exist, why we need them.
07:53:22 <Gurkenglas> julianleviston, the monad fallacy I said monad tutorial fallacy :D
07:53:35 <joneshf-laptop> julianleviston, if I understand, that's part of your questions.
07:53:43 <julianleviston> Gurkenglas: yeah, i wasn’t sure waht the fallacy is.
07:53:50 <julianleviston> joneshf-laptop: no… I just want to understand how to use them.
07:54:01 <joneshf-laptop> julianleviston, k
07:54:08 <julianleviston> joneshf-laptop: the “why” seems pretty obvious to me… sometimes you need more than 2 monads at once...
07:54:16 <julianleviston> joneshf-laptop: but do tell if you have more alternative
07:54:42 <julianleviston> joneshf-laptop: I’ve needed more than one monad at once before but I usually have no clue about how to use them.
07:55:37 <julianleviston> nshepperd: I’m not sure why more educational material could be considered unhelpful. I think a lot of people are very very bad at writing educational material, though… but that doesn’t mean anything at all, really.
07:56:12 <Hafydd> Note that <http://dev.stephendiehl.com/hask/#monads> is itself a Monad tutorial.
07:56:20 <julianleviston> nshepperd: I’m guessing this is where the “burritos” thing came from? I haven’t heard the source.
07:56:44 <julianleviston> Hafydd: a meta-tutorial? :)
07:57:01 <Hafydd> julianleviston: no, it seems to go into some depth in explaining what Monads are and how to use them.
07:57:12 <julianleviston> Hafydd: yep.
07:57:15 <Hafydd> The hallmarks of a Monad tutorial.
07:57:39 <julianleviston> Hafydd:  the thing that irritates me is that this stuff is usually devorced from practical examples.
07:58:08 <Hafydd> What could be more practical than eating  a burrito? Everybody has experienced hunger at some point in their life.
07:58:28 <joneshf-laptop> julianleviston, so, how to use them is you wrap your inner monad in a call to `lift` and you then treat it like any other monad.
07:58:35 <julianleviston> Hafydd: the practice of eating a burrito has nothing to do with writing code. :P
07:58:47 <julianleviston> joneshf-laptop: thanks! :)
07:58:48 <joneshf-laptop> julianleviston, So if you have a `ReaderT String Maybe Int`
07:58:51 <julianleviston> joneshf-laptop: what’s the inner one?
07:59:13 <julianleviston> joneshf-laptop: is the Maybe the inner one there?
07:59:46 <Hafydd> julianleviston: I don't know. It can be enjoyable or unenjoyable depending on the quality of the code/burrito; and if you do it wrong, it can get messy... but sometimes you like it messy. >;)
08:00:11 <julianleviston> Hafydd: Eating has nothing to do with writing code.
08:00:27 <Hafydd> Maybe if you lack imagination.
08:00:35 <julianleviston> Hafydd: concretely. ;-)
08:00:42 <joneshf-laptop> you could do somthing like `x <- lift (Just 3)` and the `x` would be `3
08:00:44 <joneshf-laptop> julianleviston, yes
08:01:06 <Hafydd> Also, I have to contend that I've seen many people attempting to both eat and write code at the same time, to the detriment of keyboards and computing lab hygeine.
08:01:07 <julianleviston> joneshf-laptop: ok… so  maybe you can help me to understand this...
08:01:18 <julianleviston> Hafydd:  very nice :)
08:01:36 <julianleviston> joneshf-laptop: I have a snap handler: mainHandler :: Handler GetContented GetContented ()
08:01:39 <julianleviston> joneshf-laptop: Handler has a MonadIO instance… 
08:01:45 <julianleviston> joneshf-laptop: and I have this: results :: IO (Either I.InterpreterError Int)
08:02:00 <julianleviston> joneshf-laptop: I’m using the “results” in the Handler.
08:02:02 <kallisti> currently having a huge headache with singletons right now. If the type I'm generating singletons for is just a sum type of singleton constructors, shouldn't there be a way to derive those constructors from a proxy of its promoted data kind?
08:02:05 <julianleviston> joneshf-laptop: to use it, I have to lift it.
08:02:18 <julianleviston> joneshf-laptop: but how do I know that I have to liftIO it?
08:02:23 <julianleviston> joneshf-laptop: which one is the inner one?
08:02:41 <julianleviston> joneshf-laptop: this is the handler type : http://hackage.haskell.org/package/snap-0.14.0.6/docs/Snap-Snaplet.html#t:Handler
08:02:48 <joneshf-laptop> julianleviston, sure, but I have one more point to make, and then a couple of questions.
08:02:59 <julianleviston> joneshf-laptop: and it has about 12 instances… how do I now which one(s) are the “inner” one? lol.
08:03:04 <julianleviston> joneshf-laptop: ok
08:03:29 <julianleviston> joneshf-laptop: this (mis)understanding of mine probably comes from the fact that I don’t know how monad transformers work ;-)
08:06:23 <joneshf-laptop> julianleviston, if you have a more nested stack, you have to lift more. So if you have `ReaderT String (MaybeT []) Int`, then you need something like `x <- lift (lift [1,2,3])` to embed the list into that stack.
08:06:55 <joneshf-laptop> whereas if you have a maybe you want to embed, it'd just be `x <- lift maybeTThingYouHave`.
08:07:08 <julianleviston> joneshf-laptop: I guess I really don’t understand what lift does. I thought it lifted a function into a monad.
08:07:11 <joneshf-laptop> you have to keep track of the `lift`s depending on where you are in the stack.
08:07:34 <joneshf-laptop> julianleviston, it lifts a monad into a transformer (another monad).
08:07:47 <nshepperd> julianleviston: sounds like you're thinking of liftM there.
08:07:57 <joneshf-laptop> so in the first example, it took a `Maybe Int` into a `Reader String Maybe Int`
08:08:00 <Akari2> how do i split a string into lists of strings given a seperator character ?
08:08:34 <pavonia> @hhogle splitOn
08:08:34 <lambdabot> Data.Text.Lazy splitOn :: Text -> Text -> [Text]
08:08:34 <lambdabot> Data.Text splitOn :: Text -> Text -> [Text]
08:09:08 <joneshf-laptop> :t lift -- julianleviston 
08:09:09 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
08:09:27 <pavonia> Akari2: That's what I meant: https://hackage.haskell.org/package/split
08:09:36 <joneshf-laptop> in the first example, the `m` is `Maybe`, the `t` is `Reader String` and the `a` is `Int`
08:09:50 <joneshf-laptop> julianleviston, does that make sense?
08:10:06 <nshepperd> `liftM` puts a function into a monad. `lift` is the thing relevant to transformers
08:10:09 <pavonia> > splitOn "," "foo,bar,baz"
08:10:11 <lambdabot>  ["foo","bar","baz"]
08:10:18 <julianleviston> nshepperd: thanks! :)
08:10:22 <Akari2> is it available in standard prelude
08:10:32 <julianleviston> nshepperd:  I’d been wandering around thinking liftM *was* lift.
08:10:54 <julianleviston> nshepperd: but what does lift do? It looks like if puts a VALUE into another monadic context.
08:11:01 <pavonia> Akari2: The base packages don't have a separate function for this, AFAIK
08:11:42 <Profpatsch> What does #haskell think about libraries that define their own monads based on a newtype?
08:11:46 <julianleviston> joneshf-laptop: ^
08:12:03 <Profpatsch> It feels kind of restricting.
08:12:03 <joneshf-laptop> julianleviston, it does if that value happens to be an `m a` and the monadic context is a `t m a`, and also `t` is a transformer, and `m` is a monad.
08:12:30 <Profpatsch> Especially when said libraries do not define their own transformer for their monad.
08:12:32 <julianleviston> joneshf-laptop: god damn
08:12:36 <joneshf-laptop> julianleviston, you can't `lift` a basic value.
08:12:39 <julianleviston> joneshf-laptop: I thought lifting was only on functions.
08:12:46 <julianleviston> joneshf-laptop: so you can lift anything...
08:12:46 <Akari2> i will write the function without using extra packages but really dont know how to do it
08:13:09 <julianleviston> joneshf-laptop: and it means “put into a different context”
08:13:11 <joneshf-laptop> julianleviston, you can only lift what satisfies the type signature (including the constraints).
08:13:26 <pavonia> Akari2: You can do it using the split function
08:13:28 <pavonia> :t split
08:13:29 <lambdabot> Splitter a -> [a] -> [[a]]
08:13:33 <julianleviston> joneshf-laptop: sorry, I just meant “out of functions and values, you can lift either (depending on the context, of cours”)
08:13:37 <pavonia> Err?
08:13:47 <joneshf-laptop> julianleviston, oh, sure.
08:13:54 <julianleviston> joneshf-laptop: that’s so annying
08:14:01 <joneshf-laptop> julianleviston, :)
08:14:04 <julianleviston> joneshf-laptop: the word lift has given me so much pain
08:14:11 <julianleviston> joneshf-laptop: mostly just becaues it’s called lift.
08:14:21 <Big_G> > splitOn ",  b"  "bar, Baz. Mob" 
08:14:23 <lambdabot>  ["bar, Baz. Mob"]
08:14:42 <julianleviston> joneshf-laptop: I don’t think of putting something into a different context as lifting.
08:15:01 <joneshf-laptop> julianleviston, yeah, the terminology takes some getting used to.
08:15:07 <Big_G> Beyond composing, how do I split on multiple characters? 
08:15:14 <joneshf-laptop> julianleviston, i wont posit any analogy.
08:15:22 <julianleviston> joneshf-laptop: you can. I don’t mind.
08:15:23 <pavonia> Akari2: break or span ar what I meant
08:15:27 <julianleviston> joneshf-laptop: I don’t get caught on them.
08:16:08 <joneshf-laptop> julianleviston, I don't have any, intentionally. It messes me up if I try to make an analogy. So I just take things on face value.
08:16:09 <julianleviston> joneshf-laptop: do you realise that you’ve pretty much given the first definition of lift that I’ve encountered in the many papers and books I’ve read on Haskell? They all assume people know what “lift” means
08:16:11 <pavonia> Big_G: The split package has functions for that
08:16:28 <julianleviston> joneshf-laptop: it should be renamed to contextualise
08:16:31 <julianleviston> joneshf-laptop: anyway.
08:16:32 * hackagebot vinyl-utils 0.2.0.1 - Utilities for vinyl  https://hackage.haskell.org/package/vinyl-utils-0.2.0.1 (mjmrotek)
08:16:34 <julianleviston> joneshf-laptop: lift will do.
08:16:42 <joneshf-laptop> julianleviston, well, my definition is probably wrong, so don't get too far into it :)(
08:16:43 <pavonia> Big_G: Namely splitOneOf
08:16:50 <julianleviston> joneshf-laptop: ok so what does liftIO do
08:16:52 <julianleviston> :t liftIO
08:16:54 <lambdabot> MonadIO m => IO a -> m a
08:17:01 <nshepperd> > lift [1, 2, 3] :: MaybeT [] Int -- by way of example
08:17:03 <lambdabot>  MaybeT [Just 1,Just 2,Just 3]
08:17:04 <julianleviston> joneshf-laptop: ok now I can understand that.
08:17:14 <joneshf-laptop> julianleviston, well, you know how you need to know where in the stack you're applying the `lift`?
08:17:34 <julianleviston> joneshf-laptop: it takes a thing in an IO context, and puts it into a context of a MonadIO.
08:17:46 <joneshf-laptop> julianleviston, if you're two levels deep, you have to `lift` twice. If you're one level deep, `lift` once.
08:17:47 <julianleviston> joneshf-laptop: no, it’s cool. I get it now.
08:17:49 <nshepperd> > liftIO (print "hello") :: MaybeT IO ()
08:17:51 <lambdabot>      No instance for (Data.Functor.Classes.Show1 IO)
08:17:51 <lambdabot>        arising from a use of ‘show_M83890109110470348446520’
08:17:51 <lambdabot>      In the expression:
08:17:53 <julianleviston> joneshf-laptop: yeah, I realise that.
08:17:57 <nshepperd> oh
08:18:09 <joneshf-laptop> julianleviston, `liftIO` does that automatically.
08:18:19 <julianleviston> joneshf-laptop: does what now?
08:18:25 <joneshf-laptop> julianleviston, if you're one level deep, it lifts once. If you're two levels deep, it lifts twice.
08:18:27 <nshepperd> guess lambdabot can't print that
08:18:35 <julianleviston> joneshf-laptop: oh… odd.
08:18:43 <joneshf-laptop> julianleviston, yeah, so it's kind of confusing.
08:19:01 <Big_G> Is there a function to count how many times a value is found in a list and put it in a hash map? 
08:20:01 <joneshf-laptop> julianleviston, So that was all the points I wanted to make about transformers.
08:20:12 <medicijnman> joneshf-laptop: i'm back. how did you install ghc on your machine? with a package manager or compiling from source?
08:20:26 <joneshf-laptop> julianleviston, do you still have a question about what you were doing?
08:20:57 <joneshf-laptop> medicijnman, package manager, but lately I've been using stack.
08:21:04 <julianleviston> joneshf-laptop: no I’m good now! :)
08:21:08 <julianleviston> joneshf-laptop: thanks so much !
08:21:21 <pavonia> > map (head &&& length) . group . sort $ "mississippi"
08:21:21 <julianleviston> Gurkenglas: and thanks to you!
08:21:22 <lambdabot>  [('i',4),('m',1),('p',2),('s',4)]
08:21:26 <joneshf-laptop> julianleviston, great! glad to help.
08:21:28 <medicijnman> joneshf-laptop: would you recommend building from source or using stack?
08:21:56 <julianleviston> joneshf-laptop: I think most people who write these “tutorials” generally are writing so that *they* can understand it - it’s part of how they come to understand things themselves.
08:22:38 <joneshf-laptop> medicijnman, I'd recommend stack. But i hate building things from source. :)
08:22:50 <joneshf-laptop> julianleviston, I agree.
08:23:49 <joneshf-laptop> medicijnman, you mentioned `apt-get`, and they have an ubuntu package: https://github.com/commercialhaskell/stack/blob/release/doc/install_and_upgrade.md#ubuntu
08:23:54 <Big_G> Pavonia what is the efficiency of that solution? 
08:24:05 <joneshf-laptop> medicijnman, or debian as well I guess.
08:24:53 <pavonia> Big_G: O(n*log n), I guess
08:24:58 <medicijnman> joneshf-laptop: thanks, i already had the exact same link open :p this should not conflict with an already installed version of ghc right?
08:25:29 <Big_G> Can't it be done in n time? 
08:25:46 <joneshf-laptop> medicijnman, in theory at least. So far it has not caused any conflicts for me.
08:26:25 <pavonia> Big_G: If you need a more efficent version, you'll probably find something in Data.Map
08:26:43 <pavonia> I have to go. See you!
08:27:02 <Big_G> Much appreciated 
08:27:06 <medicijnman> joneshf-laptop: okay. i'm installing stack
08:27:28 <kallisti> @hoogle (&)
08:27:30 <lambdabot> Data.Graph.Inductive.Graph (&) :: DynGraph gr => Context a b -> gr a b -> gr a b
08:27:30 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
08:27:30 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
08:27:52 <kallisti> honestly surprised that & isn't high demand operator real estate
08:28:55 <Gurkenglas> :t (&)
08:28:56 <lambdabot> a -> (a -> b) -> b
08:29:11 <Gurkenglas> hoogle is outdated, try hayoo
08:29:22 <julianleviston> hm what’s (&) for?
08:29:31 <Gurkenglas> :t (&) -- *cough*
08:29:32 <lambdabot> a -> (a -> b) -> b
08:29:40 <julianleviston> :t ($)
08:29:41 <lambdabot> (a -> b) -> a -> b
08:29:49 <joneshf-laptop> :t flip ($)
08:29:51 <lambdabot> a -> (a -> c) -> c
08:29:59 <julianleviston> are they equal?
08:30:04 <mceier> :t flop (&)
08:30:05 <lambdabot>     Not in scope: ‘flop’
08:30:05 <lambdabot>     Perhaps you meant ‘flip’ (imported from Data.Function)
08:30:10 <kallisti> how does hoogle get "outdated" exactly
08:30:13 <joneshf-laptop> > fmap (+ 1) $ [1,2,3]
08:30:15 <lambdabot>  [2,3,4]
08:30:25 <joneshf-laptop> > [1,2,3] & fmap (+ 1)
08:30:27 <lambdabot>  [2,3,4]
08:30:40 <julianleviston> wow. 
08:30:44 <Gurkenglas> I dare you to find another not-undefined implementation for &.
08:30:58 <julianleviston> Gurkenglas: I don’t follow, sorry?
08:31:27 <Gurkenglas> You don't need to ask whether they are equal :D
08:31:33 * hackagebot treeviz 2.0.3 - Visualization of computation decomposition trees.  https://hackage.haskell.org/package/treeviz-2.0.3 (DavidBanas)
08:31:33 <ggole> GHC's way of printing type variables is strange.
08:31:38 <julianleviston> Gurkenglas: oh yeah, they are. Sure.
08:32:24 <medicijnman> joneshf-laptop: okay. i've installed ghc version 7.10.2
08:33:33 <joneshf-laptop> medicijnman, cool. See if you can run through that example now. I think it's pretty instructive.
08:34:55 <c_wraith> ggole: it only really gets strange when it feels it has to start printing kinds on polykinded types
08:34:59 <medicijnman> joneshf-laptop: how can i run stack ghci with a file? ghci file.hs will use the outdated ghci, but stack ghci file.hs does not seem to work
08:35:23 <medicijnman> joneshf-laptop: stack gives me this: Error parsing targets: Directory not found: type.hs
08:36:06 <ggole> c_wraith: I'm mostly referring to how the names just seem to pop out of nowhere in particular
08:37:25 <joneshf-laptop> medicijnman, you can either run `stack ghci --ghc-options file.hs`, or you can run `stack ghci` and then load the file from within ghci `:l file.hs`
08:37:39 <c_wraith> ggole: well, it has to make up names for polymorphic types that don't unify with anything already named.
08:38:24 <medicijnman> joneshf-laptop: ah thanks, this worked: stack ghci --ghc-options type.hs
08:38:33 <c_wraith> ggole: So it usually adds a number to the type it came from.  That's where a1 often comes from.  Sometimes, though, it has no info at all, and starts naming things t1, t2, etc
08:38:44 <ggole> Perhaps I only find it strange because I'm used to the canonicalisation of type variable names you get in, eg, ocaml
08:39:07 <ggole> (Which makes it significantly easier to see when two types are the same.)
08:39:58 <c_wraith> ggole: Ah.  You mean things like (Maybe a) vs (Either b a), when it finds one and expects the other, it prints like (Maybe a) and (Either a1 b)
08:40:26 <c_wraith> > Right () :: Maybe ()
08:40:28 <lambdabot>      Couldn't match expected type ‘Maybe ()’
08:40:28 <lambdabot>                  with actual type ‘Either a0 ()’
08:40:28 <lambdabot>      In the expression: Right () :: Maybe ()
08:40:29 <ggole> I'm not sure what you mean.
08:40:39 <c_wraith> Oh, other case
08:40:52 <c_wraith> > Nothing :: Either () a
08:40:55 <lambdabot>      Couldn't match expected type ‘Either () a1’
08:40:55 <lambdabot>                  with actual type ‘Maybe a0’
08:40:55 <lambdabot>      In the expression: Nothing :: Either () a
08:41:14 <c_wraith> How a0 and a1 probably should be the same type in that message
08:41:45 <ggole> That's not quite the same thing, no.
08:42:53 <kallisti> help! my ridgid skolem type variables are escaping!
08:43:02 <c_wraith> kallisti: use a net
08:43:11 <exio4> hahah
08:43:41 <c_wraith> Also, I'm not sure I've ever seen an error message say both rigid and skolem.  They're two different (slightly obtuse) errors, iirc. :)
08:44:57 <kallisti> happens a lot with rank-n types
08:45:07 <medicijnman> joneshf-laptop: the found hole message works perfectly :)
08:49:12 <Akari2> how can i get this to compile
08:49:13 <Akari2> http://pastebin.com/3JqwLe7s
08:50:05 <lpaste> Medicijnman pasted “Syntax Tree 2” at http://lpaste.net/2059013631009357824
08:50:57 <medicijnman> joneshf-laptop: this is a newer version of syntaxttree. i placed a comment at the bottom what ghci gives me. would you mind take a look at the message?
08:51:33 * hackagebot vinyl-utils 0.2.0.2 - Utilities for vinyl  https://hackage.haskell.org/package/vinyl-utils-0.2.0.2 (mjmrotek)
08:51:38 <capisce> Akari2: indent
08:51:57 <Profpatsch> In Mtl, where are the tranformer newtypes defined?
08:52:11 <Profpatsch> newtype StateT, but no source.
08:52:42 <Profpatsch> The import is Control.Monad.Trans.State.Lazy
08:52:47 <Profpatsch> But there is no folder Trans.
08:52:56 <nshepperd> Profpatsch: they are in transformers
08:53:02 <nshepperd> mtl is just the typeclasses
08:53:46 <Profpatsch> nshepperd: As, thanks.
08:54:23 <Akari2> capisce still getting error, in what form does it need to be ?
08:54:24 <Profpatsch> I see, mtl itself is not portable. Probably not Haskell 98.t
08:55:08 <capisce> Akari2: http://pastebin.com/EpWwRRq4
08:56:19 <Akari2> kk thanks
08:58:26 <nshepperd> oh yeah, MonadState and those are MultiParamTypeClasses
09:00:07 <gexe> hi all, I have a newbish question again
09:00:42 <gexe> I dunno if it'll come across in here but I'm having trouble seeing why the second one is the correct way to write a script
09:00:49 <gexe> n =  a ‘div’ length xs 
09:00:49 <gexe>       where
09:00:50 <gexe>                 a = 10
09:00:50 <gexe>               xs = [1, 2, 3, 4, 5]
09:00:53 <gexe> oh
09:01:01 <gexe> hold on I'm paste it somewhere else
09:02:11 <joneshf-laptop> medicijnman, sure, so what do you have that can give you a `SyntaxTree b`?
09:03:53 <medicijnman> joneshf-laptop: for example, i
09:04:10 <medicijnman> joneshf-laptop: am trying to write a function that will take a number of expressions and compute the output
09:04:47 <medicijnman> something like f :: Word -> SyntaxTree Token
09:04:52 <joneshf-laptop> medicijnman, btw, I worked through this and came up with soething that has the right type, but probably doesn't have the right symantics.
09:06:30 <gexe> here, this is what I'm not clear about http://codeshare.io/Y9UVi
09:06:41 <medicijnman> joneshf-laptop: the semantics don't matter much now. would you mind paste what you came up with?
09:06:45 <joneshf-laptop> medicijnman, so you might want to be careful how to define the instance.
09:07:45 <joneshf-laptop> medicijnman, i really think it's much more instructive to work through it to the end.
09:08:20 <joneshf-laptop> medicijnman, so your hole needs to be `SyntaxTree b`, do you have that, or how can you get that?
09:12:13 <medicijnman> joneshf-laptop: yes i have multiple functions that match type (a -> SyntaxTree b)
09:16:05 <Copperis> gexe, "a" and "xs" have to be indented the same amount
09:16:23 <joneshf-laptop> medicijnman, sorry, I've got to run.
09:16:44 <medicijnman> joneshf-laptop: okay. have a nice day
09:20:16 <joco42> how do you guys need and use laziness in practice ?
09:20:39 <joco42> do you guys actually write stuff that is lazy ?
09:20:52 <joco42> i mean, something that really depends on lazyness?
09:21:13 <joco42> i dont mean using libraries that use lazyness
09:21:35 * hackagebot ncurses 0.2.13 - Modernised bindings to GNU ncurses  https://hackage.haskell.org/package/ncurses-0.2.13 (JohnMillikin)
09:21:54 <joco42> but in daily practice,  how often do u make use of haskell's lazyness? 
09:22:15 <joco42> say writing  functions like "or"  
09:22:22 <joco42> that is lazy
09:22:57 <joco42> where does lazyness matter in practice?
09:23:07 <Hafydd> joco42: one makes use of laziness whenever one uses an infinite list to perform a finite computation.
09:23:16 <Hafydd> joco42: so, I would say: every day.
09:23:45 <joco42> Hafydd:  yeah, ok, i dont really do that...
09:23:54 <Hijiri> most of monad-loops uses laziness, and I find the functions there useful
09:23:58 <joco42> but yeah, that is a good example, something else?
09:24:09 <joco42> Hijiri:  now, that is a good point
09:24:18 <Hafydd> joco42: feeding the result of a computation into itself is a relatively common pattern.
09:24:33 <joco42> Hafydd: yeah like the monad loop
09:24:42 <joco42> ok, that is indeed nice example
09:25:11 <Hafydd> joco42: you really don't use infinite lists? You probably should.
09:25:31 <joco42> Hafydd:  yeah... maybe i am missing out on something :)
09:25:53 <Hafydd> Your Haskell programming could be...
09:25:58 * Hafydd puts on a pair of sunglasses.
09:26:06 <Hafydd> infinitely more enjoyable.
09:26:07 <joco42> hmm
09:26:13 <joco42> lol
09:26:37 <joco42> yeah these infinite data structures...
09:26:53 <joco42> maybe i need to find a way to use them
09:27:19 <Hafydd> joco42: it's also true that whenever you perform a computation that uses short-circuiting behaviour, your are gaining the performance benefits of lazy evaluation, and possibly also sharing and memoisation.
09:27:33 <haskell153> if i have a list of tuples how can i sum the the second term of them for example [("hdi",19),("dai",20) ] = 39 ?
09:27:47 <Hafydd> *you
09:28:10 <hexagoxel> :t sum . fmap snd
09:28:11 <lambdabot> (Functor t, Num c, Foldable t) => t (a, c) -> c
09:28:15 <joco42> Hafydd:  ok, so memoization needs lazyness...
09:28:32 <haskell153> i cannot use map only recursion
09:28:38 <capisce> lol
09:28:41 <Hafydd> joco42: it doesn't, but it can be implemented more nicely with it.
09:29:09 <nshepperd> laziness is great for doing dynamic programming solutions
09:29:13 <capisce> sounds like homework
09:29:15 <joco42> Hafydd:  yeah, i think i heard about this before
09:29:19 <hexagoxel> haskell153: just un-inline sum and fmap :p
09:29:22 <Hafydd> joco42: i.e. the memoised value can be constructed (without being evaluated), and evaluated when needed.
09:29:31 <joco42> nshepperd:  oh yeah, the n queens problem
09:29:45 <haskell153> yes it is i dont know how to go up in the list 
09:30:19 <capisce> haskell153: the tail function goes up in the list
09:30:20 <hexagoxel> haskell153: what is "up" in a list? why do you need it?
09:30:25 <joco42> Hafydd:  ok, so lazyness is sort of like caching
09:30:35 <haskell153> i can do f (( x, y ):xs) = sum y+y++ : xs ?
09:30:42 <joco42> on steroids
09:31:00 <Hafydd> joco42: you might say that, but it isn't a completely accurate analogy.
09:31:20 <Hafydd> Laziness doesn't necessarily involve saving the computed values indefinitely.
09:31:26 <joco42> yeah, it is more than that
09:31:29 <julianleviston> laziness is caching the future ;-)
09:31:37 <Hijiri> in particular functions don't memoize on their own
09:32:07 <Hijiri> if you give a value a name though, and you reuse that name to refer to that value, you can be reasonably sure that GHC will memoize it
09:32:20 <joco42> yeah...
09:32:33 <joco42> i think i remember something like that
09:33:02 <Hijiri> expressions inside functions with no free variables I think will memoize too
09:33:14 <joco42> but the dynamic programming example is good
09:33:28 <Hijiri> like if you have  equalsTwoPlusTwo x = 2 + 2 == x, the 2 + 2 will be evaluated once
09:33:54 <Hijiri> the (2 + 2) cell gets reduced to 4 by GHC when it evaluates it the first time
09:34:11 <joco42> interesting, nice,  Hijiri  
09:34:19 <joco42> clever
09:34:52 <nshepperd> I don't think that sort of reusing values is much to do with laziness though
09:35:26 <joco42> the memoization is a somehow an orthogonal idea...
09:35:27 <nshepperd> the thing that makes dynamic programming so easy is that you can just define a big array or something with all the solutions
09:35:44 <nshepperd> and have the values depend on each other
09:36:04 <nshepperd> and the laziness ensures that the things you need all get computed in the right order magically
09:36:46 <joco42> so the idea of mutually dependent values/computations won't cause any headache....
09:36:55 * hackagebot approximate 0.2.2.2 - Approximate discrete values and numbers  https://hackage.haskell.org/package/approximate-0.2.2.2 (EdwardKmett)
09:37:10 <joco42> for example ones= 1:ones
09:37:15 <joco42> :)
09:37:31 <joco42> is a nice example
09:39:55 <joco42> or fib =( head fib+head . head $ fib):[1,1]
09:39:59 <joco42> sort of ...
09:40:08 <nshepperd> > let numbers = 1 : [ (numbers !! (i `div` 2)) + i | i <- [0..20]] in numbers -- arbitrary pseudo-dynamic-programming example
09:40:10 <lambdabot>  [1,1,2,3,4,6,7,9,10,12,13,16,17,19,20,23,24,26,27,30,31,33]
09:41:20 <nshepperd> though in real life, you'd use a vector instead of a list there, for that O(1) access
09:41:56 * hackagebot hyperloglog 0.4.0.1 - An approximate streaming (constant space) unique object counter  https://hackage.haskell.org/package/hyperloglog-0.4.0.1 (EdwardKmett)
09:42:42 <Hafydd> joco42: another natural use of lazy evaluation is in attribute grammars used by compilers.
09:45:19 <joco42> Hafydd:  ok , good to know :)
09:47:48 <Hafydd> (In fact, it seems that any sufficiently complicated computation will eventually be able to make use of it; Haskell is just ahead of other languages in abstracting that.)
09:49:53 <joco42> abstracting what?
09:51:24 <joco42> btw, if the recursive call is not in the tail position, will the stack blow in haskell?
09:51:45 <Hafydd> joco42: the pattern of representing possible computations as values, to be later possibly evaluated.
09:51:58 <joco42> my guess is yes... not sure though...
09:52:14 <Hafydd> joco42: it can happen, if your computation really is unreasonably large.
09:52:16 <joco42> Hafydd:  that kind of dynamic programming...
09:52:32 <Hafydd> I mean, unreasonably large to perform with excessive laziness.
09:53:12 <joco42> Hafydd:  so for example adding 1000 numbers ?
09:53:19 <Hafydd> joco42: I don't think "dynamic programming" completely describes it.
09:53:34 <Hafydd> joco42: adding 1000 numbers isn't what I'd call large.
09:53:38 <Hafydd> > sum [1..1000]
09:53:39 <lambdabot>  500500
09:54:05 <kallisti> > first (+2) (3, 4)
09:54:07 <lambdabot>  (5,4)
09:54:35 <joco42> Hafydd:  i remember the Scala stack blows with adding a few thousand numbers... done recursively without tail call optimization...
09:55:15 <Hafydd> joco42: if you were doing in such a way that it actually did fill up the stack, then that might happen.
09:55:41 <Hafydd> > foldl (+) 0 [1..10000]
09:55:43 <lambdabot>  50005000
09:55:49 <Hafydd> > foldl (+) 0 [1..100000]
09:55:51 <lambdabot>  5000050000
09:55:54 <Hafydd> Hmm.
09:56:09 <Hafydd> > foldl (+) 0 [1..1000000]
09:56:12 <lambdabot>  *Exception: stack overflow
09:56:26 <Hafydd> But it's difficult with such a simple example.
09:56:37 <joco42> Hafydd:  is foldl ... doing something not in tail position ?
09:56:50 <joco42> foldr (+) 0 [1..1000000]
09:56:54 <joco42> >foldr (+) 0 [1..1000000]
09:56:55 <Hafydd> joco42: yes. foldl builds up a chain of thunks as long as the list.
09:57:15 <Hafydd> Therefore, it's recommended to not use it unless you know you have to (use foldl' or foldr instead).
09:57:28 <Hafydd> > foldl' (+) 0 [1..1000000]
09:57:30 <lambdabot>  500000500000
09:57:31 <Hafydd> > foldr (+) 0 [1..1000000]
09:57:33 <lambdabot>  *Exception: stack overflow
09:57:41 <Hafydd> Hmm... that's interesting./
09:58:05 <joco42> fold from the left
09:58:33 <Hafydd> > foldr (+) 0 [1..1000000] :: Int
09:58:35 <lambdabot>  *Exception: stack overflow
09:58:46 <Hafydd> I'm not sure why that's happening.
09:58:56 <joco42> fold from the right
09:59:12 <joco42> >foldr (+) 0 [1..100]
09:59:30 <joco42> >foldr (+) 0 [1..10]
09:59:36 <Hafydd> Ah, well, I suppose it does fill up the stack, but not with thunks.
09:59:43 <Hafydd> foldl' is what you want for this case, after all.
09:59:49 <Hafydd> joco42: you need to put a space after >
09:59:55 <joco42> ok :)
10:00:00 <joco42> > foldr (+) 0 [1..10]
10:00:02 <lambdabot>  55
10:00:28 <Hafydd> foldr is better for constructing results that can themselves be lazily evaluated.
10:00:42 <Hafydd> > foldr (++) "" (map show [1..100000])
10:00:45 <lambdabot>  "123456789101112131415161718192021222324252627282930313233343536373839404142...
10:01:49 <prophile> to ask a stupid question, can foldr be written in terms of foldl'
10:01:52 <joco42> > take 10 $ foldr (+) "" (map show [1..10])
10:01:53 <lambdabot>      No instance for (Num [Char]) arising from a use of ‘+’
10:01:54 <lambdabot>      In the first argument of ‘foldr’, namely ‘(+)’
10:01:54 <lambdabot>      In the second argument of ‘($)’, namely
10:02:21 <joco42> > take 10 $ foldr (++) "" (map show [1..10])
10:02:23 <lambdabot>  "1234567891"
10:02:24 <prophile> I'm pretty confident the answer is "no" but just to check
10:02:26 <joco42> nice
10:02:34 <joco42> Hafydd:  nice example
10:02:47 <joco42> > take 10 $ foldr (++) "" (map show [1..])
10:02:48 <lambdabot>  "1234567891"
10:02:55 <joco42> pretty nice
10:05:14 <joco42> but basically, tail call optimisation can only be done when the recursive call is in tail position, right ? even with haskell.... 
10:05:49 <johnw> joco42: http://stackoverflow.com/questions/13042353/does-haskell-have-tail-recursive-optimization
10:05:58 <joco42> -- foldl f z (x:xs) = foldl f (f z x) xs
10:06:24 <joco42> johnw:  oh i just notice that i starred that question some time ago :)
10:06:30 <johnw> ;)
10:06:32 <joco42> how embarrassing
10:10:13 <joco42> "Haskell uses lazy-evaluation to implement recursion, so treats anything as a promise to provide a value when needed (this is called a thunk)."
10:10:32 <joco42> now this is a very good example of the importance of lazyness :)
10:12:08 <joco42> this is a  good one toohttp://stackoverflow.com/questions/3429634/foldl-is-tail-recursive-so-how-come-foldr-runs-faster-than-foldl?lq=1
10:12:09 <Hafydd> I don't know about "Haskell uses lazy evaluation to implement recursion."
10:15:55 <joco42> the answer says this http://stackoverflow.com/questions/13042353/does-haskell-have-tail-recursive-optimization
10:17:06 <joco42> so a thunk is a partially evaluated expression, right?
10:18:31 <Hafydd> A thunk is a non-evaluated expression.
10:18:40 <Hafydd> A partially evaluated expression may contain thunks.
10:19:55 <monochrom> a lot of confusion comes from shoe-horning eager evaluation wisdom into lazy evaluation
10:20:59 <monochrom> also shoe-horning imperative algorithm wisdom into functional algorithms
10:21:41 <joco42> Hafydd:  thanks for pointing that out...
10:22:10 <joco42> all this lazy evaluation is somehow sooo implicit :)
10:22:55 <monochrom> a very illustrative example is the exercise of "write an algorithm that inputs a list like [x,y,z], outputs [sin x, sin y, sin z]"
10:23:31 <joco42> https://wiki.haskell.org/Tail_recursion
10:23:50 <joco42> making a function tail-recursive typically isn't as big a deal
10:24:15 <monochrom> wisdom for eager and imperative algorithms would have to write this algorithm: initialize variable s to be the empty list; for each i in [x,y,z], append sin i to s.
10:25:07 <monochrom> it uses the eager evaluation wisdom of "go for tail recursion" so you write a loop or tail recursion
10:25:25 <joco42> monochrom: i would use map on it...
10:25:34 <monochrom> and once you decide to do that, you force yourself to think "keep appending new outputs"
10:25:57 <monochrom> yes and how would you write an algorithm for map? you would do what I said.
10:25:59 <joco42> f l = map sin l
10:26:31 <joco42> so basically you ask how map is implemented ?
10:26:46 <joco42> or how i would implement a general map?
10:26:57 * hackagebot hybrid-vectors 0.2.1 - Hybrid vectors e.g. Mixed Boxed/Unboxed vectors  https://hackage.haskell.org/package/hybrid-vectors-0.2.1 (EdwardKmett)
10:27:14 <kallisti> hm, can't partially apply a type family's type constructor? I am filled with great sadness
10:27:35 <monochrom> and so when you come to haskell you do the same thing. "mysinmap input = helper [] input", "helper s [] = acc", "helper s (x:xs) = helper (s ++ [sin x]) xs"
10:27:44 <monochrom> and at once you make two fatal errors.
10:28:14 <monochrom> error #1: to keep appending new outputs. error #2: to be superstitious in tail recursion
10:28:29 <joco42> monochrom:  i dunno... i would not make that... because somehow i see that i just need to use map...
10:28:34 <monochrom> the correct answer for Haskell is the total opposite of all imperative and eager wisdom.
10:28:40 <joco42> that is the nice thing about haskel
10:28:41 <joco42> l
10:29:05 <monochrom> the correct answer is "mysinmap [] = []", "mysinmap (x:xs) = sin x : mysinmap xs"
10:29:07 <joco42> list is a functor and that's it...
10:29:24 <medicijnman> is it possible to disable to warning: tab character in ghci?
10:29:26 <monochrom> yes, so think about how you would implement map
10:29:28 <medicijnman> *the warning
10:30:01 <srhb> medicijnman: -fno-warn-tabs or something like that?
10:30:12 <monochrom> when I talk about the nature of different algorithm styles, you don't get to weasel out by saying "the library already has it".
10:30:29 <srhb> medicijnman: Or :set -fno-warn-tabs from within ghcoi
10:30:32 <ggole> Tail recursion modulo cons could make that the best way even for a strict language
10:30:33 <srhb> medicijnman: ghci*
10:30:39 <joco42> monochrom:  ok, i see
10:30:57 <ggole> Efficiency of evaluation is a detailed subject.
10:30:58 <monochrom> "the library already has it" begs the question
10:31:18 <medicijnman> srhb: ghci -fno-warn-tabs works like expected, but stack ghci --ghc-options -fno-warn-tabs does not
10:31:57 <srhb> medicijnman: Probably this: https://github.com/commercialhaskell/stack/issues/971
10:32:10 <monochrom> and "list is a functor" is even worse. it says "math already says it exists"
10:32:34 <joco42> monochrom:  why is that bad?
10:32:41 <Copperis> monochrom, I didn't understand your first example. Can you annotate it? http://lpaste.net/143281
10:32:57 <monochrom> that is good if you just talk about mathematical existence rather than computation.
10:33:00 <joco42> i dont need to think too hard...
10:33:15 <monochrom> but I'm talking about computation and computational cost. and this is a computational channel.
10:33:23 <joco42> that is what i like about haskell
10:33:35 <joco42> it is easy on my mind
10:34:31 <joco42> there is this joke that lisp programmers know the value of everything but the cost of nothing :)
10:34:36 <lpaste> monochrom annotated “No title” with “No title (annotation)” at http://lpaste.net/143281#a143282
10:35:06 <monochrom> well yeah but if you bring up tail recursion you are talking about computational cost not mathematical existence
10:35:40 <medicijnman> srhb: and how can i append that option in ~/.stack/config.yaml?
10:35:41 <joco42> yeah,  sort of, or maybe more like, space leak...
10:35:57 <monochrom> space cost is a computational cost
10:35:58 <srhb> medicijnman: No idea, I don't use stack.
10:36:31 <joco42> yeah, it would be nice to have some solid foundation in this area...
10:36:35 <monochrom> "leak" just means "the cost is higher than I thought"
10:36:47 <joco42> but somehow intro texts do not address this..
10:36:53 <monochrom> see my http://www.vex.net/~trebla/haskell/lazy.xhtml
10:36:58 <medicijnman> srhb: ah ok.
10:37:31 <monochrom> Bird's book "introduction to functional programming using haskell" 2nd edition addresses this. and is about the only book that does.
10:37:41 <joco42> monochrom:  that is a pretty decent write up
10:37:49 <monochrom> and is also earlier than a lot of textbooks
10:38:55 <joco42> monochrom:  hmmm... i dont seem to have that on my bookshelf... maybe i need to correct that!
10:39:45 <Copperis> monochrom, should that annotation compile?
10:40:06 <monochrom> yes, but I'm too lazy to try
10:40:21 <joco42> http://www.cs.ox.ac.uk/publications/books/functional/
10:40:29 <joco42> how about that book?
10:40:33 <Copperis> monochrom, acc is not in scope, what should it be?
10:40:37 <monochrom> I haven't read it
10:40:49 <monochrom> I see. change acc to s
10:41:06 <Copperis> ok, now it compiles
10:41:57 <monochrom> thank you. I forgot my name choice.
10:42:17 <Copperis> yup, that algorithm looks messed up
10:43:45 <Copperis> it passes the resulting list "s" all the way to the bottom
10:45:54 <SparkySparkyBoom> tabemann: that's what i thought too
10:45:55 <joco42> so Birds 3rd book is on its way to my bookshelf :)
10:46:25 <joco42> something to read on the beach next summer
10:49:00 <haskell326> anyone can help me http://lpaste.net/143283 
10:49:17 <monochrom> just beware of bright sun shining on white paper which is too bright for your eyes for prolonged reading
10:50:15 <cocreature> haskell326: it would help if you would state your problem
10:51:10 <monochrom> good thing I still know a small chunk of the periodic table so I see why boro and zinco are on the same list :)
10:51:40 <monochrom> and why potassio is not potato
10:51:57 <haskell326> i receive a pair ("aada",3) and want to sum the (x,y) y and the sum has to be 0 
10:51:58 <joco42> hmmm.... need to put on sunglasses
10:52:05 <magneticduck1> I'm going to one-up you here, I studied the periodic table in portugese
10:52:21 <magneticduck1> so I get what enxofre is
10:52:41 <haskell326> i dont care abou the string i only care about the number
10:52:45 <haskell326> name*
10:53:09 <kallisti> :t snd
10:53:09 <lambdabot> (a, b) -> b
10:53:19 <magneticduck1> @type map snd --haskell326
10:53:20 <lambdabot> [(a, b)] -> [b]
10:53:26 <haskell326> i want to sum the numbers and see if it gets 0 and then return the pairs 
10:53:41 <magneticduck1> that's the knapsack problem
10:53:42 <kallisti> > sum . map snd $ [("foo", 2), ("bar", 3), ("baz", -5)]
10:53:43 <magneticduck1> can't be solved, QED
10:53:43 <lambdabot>  0
10:53:52 <haskell326> i cannot use map 
10:53:56 <haskell326> only recursion
10:54:02 <kallisti> @src map
10:54:02 <lambdabot> map _ []     = []
10:54:02 <lambdabot> map f (x:xs) = f x : map f xs
10:54:04 <kallisti> k, write that
10:54:07 <kallisti> then write:
10:54:09 <kallisti> @src sum
10:54:09 <lambdabot> sum = foldl (+) 0
10:54:15 <kallisti> er, don't write that
10:54:22 <magneticduck1> @src foldl
10:54:22 <lambdabot> foldl f z []     = z
10:54:22 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
10:54:25 <kallisti> just expand everything out, ez. :P
10:54:28 <magneticduck1> actually, just transcribe all of prelude
10:54:34 <kallisti> absolutely
10:54:35 <magneticduck1> and then Data.List, that might be handy
10:54:47 <cocreature> just go with all of base
10:54:49 <cocreature> then all of lens
10:55:02 <magneticduck1> nah you can stick to just lens-families
10:55:09 <magneticduck1> .. if you're a pitiful amateur
10:55:59 <kallisti> my travis build took 6 minutes to tell me: ghc: unrecognised flag: -fno-warn-unticked-promoted-constructors
10:56:00 <kallisti> seems legit
10:56:34 <kallisti> multiple ghc-options in a cabal file will append everything together right?
10:58:12 <hexagoxel> kallisti: yes, and duplicates will ignore any but the last option
10:58:29 <capisce> joco42: https://en.wikibooks.org/wiki/Haskell/Laziness#Benefits_of_nonstrict_semantics
10:59:51 <kallisti> I honestly spend the most time figuring out exactly what version an extension or function was added to GHC version or a specific dependency
11:00:04 <kallisti> so I can add the right build options to my cabal file
11:01:00 <capisce> kallisti: maybe you should try to automate that then ;)
11:01:36 <hexagoxel> kallisti: what packages are you trying to use that are broken in such a way that this does not work automatically?
11:01:44 <capisce> I heard computers (especially with the help of Haskell) are pretty good at that
11:02:31 <Copperis> magneticduck1, an exhaustive search algorithm could be used
11:02:36 <kallisti> hexagoxel: the package I'm maintaining, of course.
11:02:47 <Copperis> magneticduck1, for the knapsack
11:02:54 <magneticduck1> Copperis: I was kidding of course
11:05:21 <hexagoxel> kallisti: ah, i see.
11:18:50 <kallisti> what's the current GHC version for Haskell Platform?
11:18:58 <kallisti> 7.10.2?
11:19:34 <adas> kallisti: i don't think the haskell platform has such a recent version of GHC
11:20:10 <kallisti> according to the website haskell platform is at 7.10.2
11:20:31 <adas> if it says so on the website then it must be true
11:20:39 <kallisti> currently I support GHC 7.4 and 7.6, but when I start using vinyl I'll have to drop those two and support GHC >= 7.8
11:21:18 <kallisti> but I don't need to make the switch for at least a month, possibly longer.
11:22:40 <lpaste> dimsuz pasted “Either inside IO” at http://lpaste.net/143286
11:23:34 <kallisti> dimsuz: one trick you can do to help reduce the amount of case nesting is:  case (io1, io2)
11:23:37 <Gurkenglas> dimsuz, https://hackage.haskell.org/package/either-4.4.1/docs/Control-Monad-Trans-Either.html
11:24:18 <dimsuz> hello! I'm a beginner, learning some basic. I feel like I need to use Either monad, to reduce boilerplate, but can't wrap my head around how to use it inside an IO
11:24:34 <dimsuz> oh, I didn't know it'll auto-paste :)
11:24:36 <adas> actually the either trans monad
11:25:27 <dimsuz> so if I have say 10 images to load, I should use mapM and then somehow also use Either monad
11:25:42 <dimsuz> Gurkenglas: thanks, will read
11:28:44 <lpaste> Gurkenglas annotated “Either inside IO” with “dimsuz: Untested, and it doesn't distinguish among images.” at http://lpaste.net/143286#a143287
11:29:29 <Gurkenglas> Meaning, it doesnt say first or second.
11:29:33 <KaneTW> if anyone wants to take a look i need some suggestions with https://ghc.haskell.org/trac/ghc/ticket/10972
11:29:47 <joco42> capisce:  thanks
11:32:52 <ReinH> dimsuz: Yes, this is a case for EitherT
11:33:22 <dimsuz> Gurkenglas: great! Will study and try to apply. I think I have a basic undarstanding of what monad/transformer is, but I feel that I won't go much further without asking this "simple" stuff about how to apply them in real life :)
11:33:22 <ReinH> @unmtl EitherT e IO a
11:33:23 <lambdabot> EitherT e IO a
11:33:55 <joco42> capisce:  that link reminds me of Hughes' paper on why fp matters
11:34:23 <dimsuz> I am in that position where I have an itch "this should be done by using that", but no skills to actually figure it out...
11:34:27 <dimsuz> hope it'll come
11:34:56 <Gurkenglas> dimsuz, oh hey your second image didnt print the error, is that supposed to be that way?
11:35:07 <ReinH> dimsuz: Actually, no, not EitherT. EitherT has been moved into transformers and called ExceptT (shame about the name)
11:35:15 <ReinH> @unmtl ExceptT e IO a
11:35:15 <lambdabot> ExceptT e IO a
11:35:17 <ReinH> darn
11:35:37 <Gurkenglas> ReinH, yes EitherT. https://hackage.haskell.org/package/either-4.4.1/docs/Control-Monad-Trans-Either.html
11:35:46 <dimsuz> Gurkenglas: yep, copy/paste failed me)
11:35:47 <ReinH> Gurkenglas: no, not EitherT. ExceptT.
11:35:53 <ReinH> EitherT was obsoleted bt ExceptT.
11:36:02 <ReinH> *by
11:36:03 <dimsuz> ReinH: wasn't it ErrorT?
11:36:10 <Gurkenglas> but but the name is bad
11:36:16 <ReinH> It is.
11:36:23 <dimsuz> i've read someting about this on /r/haskell
11:36:37 <ReinH> ErrorT is the old version that had a spurious constraint on the first type variable.
11:37:11 <dimsuz> so the path to now was EitherT => ErrorT => ExceptT?
11:37:12 <tabemann> I have a stylistic question
11:37:46 <ReinH> dimsuz: ErrorT was first, then EitherT was created, which removed the spurious constraint, and then it was moved back into transformers and (For some reason) renamed to ExceptT.
11:37:46 <tabemann> I have a function of type Foo -> STM Bar - is it appropriate to name it getBar, or does the use of "get" feel too much like Java
11:38:13 <ReinH> No one is happy about the name, but here we are
11:38:19 <Hafydd> tabemann: a number of functions in the Report start with "get," so I don't think so.
11:38:45 <Hafydd> I'd rather avoid writing code that is semantically like Java, instead of focusing on superficialities.
11:38:57 <Gurkenglas> Soo why not continue using the either package? It doesn't say deprecated or anything.
11:40:20 <dimsuz> Gurkenglas: and also I don't see anything like eitherT in ExceptT docs
11:41:54 <tabemann> Hafydd: well my code itself is not very traditionally Haskell-ish, but not very Java-like either - it is largely imperative, but it is very heavily multithreaded and makes very heavy use of STM
11:42:10 <ReinH> dimsuz: So ExceptT e IO a allows you to work with IO (Either e a) as if it were an Either, so do binds will short circuit if there's a Left automatically.
11:42:55 <monochrom> tabemann: take comfort in knowing that MonadState has a "get" method, too :)
11:43:12 <Gurkenglas> And so will EitherT, and EitherT is maintained by edward and therefore better.
11:43:24 <dimsuz> ReinH: I need to somehow wrap IO (Either e a) into ExceptT?
11:43:38 <Gurkenglas> Huh, so is mtl.
11:46:04 <tabemann> I have another stupid question - is there anything like C printf but which I can plug an arbitrary formatting string and an arbitrary list of arguments into at runtime?
11:46:16 <ReinH> Gurkenglas: The question is, why prefer EitherT?
11:46:28 <Gurkenglas> The name is better. And the library is fuller.
11:47:00 <ReinH> dimsuz: yes, just use 'ExceptT'.
11:47:04 <ReinH> dimsuz: http://lpaste.net/143286#a143288
11:47:36 <monochrom> tabemann: base has Text.Printf and may satisfy your needs
11:47:44 <dimsuz> ReinH: thanks! much appreciated
11:47:44 <Gurkenglas> ReinH, the last three lines aren't lifted
11:48:18 <ReinH> Gurkenglas: good point
11:49:19 <lpaste> Gurkenglas annotated “Either inside IO” with “Here, this one doesn't need you to write return in there.” at http://lpaste.net/143286#a143289
11:50:02 <Gurkenglas> ReinH, also you didn't unpack the ExceptT at the end; how do you handle the left case?
11:51:51 <Gurkenglas> Oh wait my last one doesn't work, whenLeft applies to Either, not EitherT. Why isn't there whenLeftT!?
11:52:34 <ReinH> Gurkenglas: Conveniently, ExceptT has it ;)
11:52:36 <dzdcnfzd> How do I get out of what I presume is cabal hell?
11:52:46 <ReinH> dzdcnfzd: use stack. :)
11:52:46 <dzdcnfzd> I'm trying to install lushtags
11:53:02 <dzdcnfzd> how big an install is it?
11:53:53 <dzdcnfzd> :)
11:54:09 <Gurkenglas> ReinH, where is ExceptTs whenLeftT?
11:54:17 <dzdcnfzd> Will that really fix most cabal hell problems? I'm trying to get lushtags and I'm seeing Dependency tree exhaustively searched.
11:54:26 <dzdcnfzd> Is that what cabal hell is?
11:55:20 <tabemann> monochrom: I'm looking at that, and while that would work, what I'd really like is something that takes a map and has named values - see, what I'm doing is doing string lookup for internationalization and so I don't hardcode my strings, and I'd like the person doing the internationalization to be able to change the ordering of values
11:55:43 <Shadowhawk> Hello everyone. I am kind of a noob in haskell. I read about pattern matching but I'm wondering if there is a cleaner way to write this: http://lpaste.net/143290 . Can any one point me to the right direction to study?
11:55:53 <marxS> in this code: http://paste.ofcode.org/vkPFBwbLdvLNtcVbSkWbPK can somebody please explain why there are two sets of sqr brackets and why the x <- xs is on the outside of the inner set?
11:56:34 <hexagoxel> dzdcnfzd: no, that is just a broken package.
11:56:43 <dimsuz> Gurkenglas, ReinH: thanks! it will be an excercise for me to use analog of whenLeft provided by ExceptT (I guess that would be catchE)
11:57:02 <dzdcnfzd> hexagoxel: is there usually some way of fixing it or no?
11:57:16 <Gurkenglas> Shadowhawk, how about http://lpaste.net/143290 ?
11:57:24 <Shadowhawk> marxS: I think you should read this: http://learnyouahaskell.com/starting-out#im-a-list-comprehension
11:57:41 <Gurkenglas> dimsuz, you can use the third annotation from the bottom, it's just one "boilerplate" word more.
11:58:22 <joco42> lazy evaluation... still ... https://usercontent.irccloud-cdn.com/file/9gdFH9Jn/Screen%20Shot%202015-10-18%20at%2021.57.23.png
11:58:31 <Shadowhawk> Gurkenglas: Oh! The "where" is visible from everywhere? didn't know that. I thought that if I wrote it that way only whatever was inside the second rule could see foo
11:58:37 <Shadowhawk> Gurkenglas: thanks!
11:58:55 <dimsuz> Gurkenglas: yes
11:59:32 <joco42> what do you guys think about this ?
11:59:40 <ReinH> dimsuz: here's a more complete version http://lpaste.net/2700778540709707776
11:59:44 <burp> Shadowhawk:  or how about getTemprature x | x == Cpu || x == Gpu = 
12:00:11 <hexagoxel> dzdcnfzd: first step is trying to `cabal install lushtags --allow-newer`
12:00:59 <burp> Shadowhawk: key here is pattern matching guards
12:01:20 <Shadowhawk> Gurkenglas: I get this error as I thought: http://lpaste.net/143294
12:01:43 <Shadowhawk> burp: Do I have to make my HWType to be an instance of Equal to do that?
12:01:44 <hexagoxel> dzdcnfzd: if that does not work, the code is bitrotten and needs modifications to work with current ghc version(s).
12:01:51 <joco42> so in one sentence, the power of lazy evaluation according to Hughes : "This allows termination conditions to be separated from loop bodies. "
12:01:52 <dzdcnfzd> hexagoxel: how do you know this? I'm trying to figure this stuff out
12:02:04 <dzdcnfzd> But I don't really know where to start
12:02:17 <dimsuz> ReinH: looks really clean
12:03:29 <burp> Shadowhawk: probably, I'd guess, try?
12:03:39 <Shadowhawk> burp: Yeap I'll do that!
12:03:45 <dzdcnfzd> Also, question that I don't really understand: I've been told that I should install everything in a sandbox. How does that apply to actual haskell utilities I want to use?
12:04:04 <dzdcnfzd> In this case, I want to run hasktags everywhere
12:04:41 <Gurkenglas> O_o you're right that doesn't work and lpaste.net/7527654961971200000 does
12:04:53 <dolio> dzdcnfzd: The versions specified on that package are very old. It requires vector 0.9 and the current version is 0.11, and it requires text 0.11 and the current version is 1.2.
12:05:20 <dolio> Its haskell-src-exts is also very old.
12:05:56 <dzdcnfzd> How do I build these things without wrecking my system while also being able to use it everywhere
12:05:57 <hexagoxel> dzdcnfzd: i cannot name a specific source, sorry. the reasoning in this case is that a) the last upload is from 2011 b) the dependency bounds are fixed to really old versions c) the install error names package "base" which correlates with ghc version.
12:05:59 <burp> dzdcnfzd: I can recommend to use stack, you can have a global "copy" that installs binaries into ~/.local/bin, and also sandboxes in project directories
12:06:32 <dzdcnfzd> burp: I see. I have a friend who's been pushing me to get it, so I trust you're right
12:06:43 <hexagoxel> dzdcnfzd: see https://github.com/quchen/cabal-install-bin
12:06:46 <dzdcnfzd> I'm just wary because I don't feel like I understand cabal as it is
12:06:48 <ReinH> dimsuz: I would actually do it this way and make ExceptT an implementation detail of loadImgs http://lpaste.net/2700778540709707776
12:07:25 <ReinH> Since conceptually there's no need to to leak the ExceptT elsewhere in the program
12:07:35 <ReinH> Unless you want to combine it with other ExceptT actions.
12:07:38 <dolio> Stack is not going to solve a package only allowing 4-year-old dependencies.
12:07:47 <dzdcnfzd> hexagoxel: thanks!
12:07:47 <ReinH> dolio: true enough
12:08:33 <dolio> This is just canned stack advocacy, and assuming cabal is at fault for things that are wrong with the package.
12:08:47 <ReinH> Well, in many cases stack is an improvement
12:08:54 <ReinH> stack install hasktags works globally
12:09:15 <ReinH> I have no ulterior motive for recommending stack. It simply works better in many cases.
12:09:29 <hexagoxel> dzdcnfzd: note that "stack" will not magically fix a broken package suck as lushtags. afaik stack would give an error for the package as well.
12:09:35 <ReinH> My job used to literally be building a lot of haskell packages with cabal, so I have some experience here.
12:09:54 <Gurkenglas> (Shadowhawk, of course you could put foo into a top-level definition.)
12:09:59 <ReinH> I'm not a particular fan of FPCo, but I can acknowledge a good tool for what it is.
12:10:40 <dimsuz> ReinH: yes, this is even better
12:10:48 <dimsuz> ReinH: thank you
12:10:52 <ReinH> dimsuz: np
12:11:54 <ReinH> dimsuz: you could also use your own data type instead of (String, StorageError) for error reporting.
12:12:03 * hackagebot network-transport-zeromq 0.2.1.1 - ZeroMQ backend for network-transport  https://hackage.haskell.org/package/network-transport-zeromq-0.2.1.1 (AlexanderVershilov)
12:12:12 <dolio> cabal install hasktags also works globally.
12:12:17 <ReinH> dolio: Sometimes.
12:12:21 <hexagoxel> (the potential issue is not recommending stack. it is implying that it would fix the issue at hand, which may or may not be something sometimes referred to as "cabal hell")
12:12:30 <ReinH> It depends on your global cabal environment, stack does not.
12:12:46 <dimsuz> ReinH: yeah, I just thought about that too. And also I am thinking on how to upgrade this for the case when I have not a pair, but a list of images
12:12:55 <ReinH> dimsuz: mapM
12:13:36 <ReinH> hexagoxel: stack won't fix everything, but I would argue that it dominates cabal as a tool for installing haskell packages.
12:13:43 <dimsuz> ReinH: right! runExceptT will work on list instead of pair
12:13:46 <ReinH> in the sense that everything cabal can do, stack can do better
12:13:57 <hexagoxel> ReinH: you miss my point.
12:14:06 <hexagoxel> which i put very clearly, i think.
12:14:59 <ReinH> hexagoxel: IMO, whether it fixes the issue at and or not, I still think using stack is the better choice. If the issue is fixable, it would be easier to fix if you are using stack.
12:15:07 <ReinH> *at hand
12:15:27 <kallisti> http://lpaste.net/143298 is there any real reason for me to add the subset constraint to that data constructor? I thought maybe making it a GADT would use different type inference semantics but it doesn't seem to alleviate the need to put constraints elsewhere
12:15:50 <ReinH> So any time someone is in cabal hell, for whatever reason, I think recommending stack is reasonable. It couldn't possibly be worse, and it is quite often better.
12:16:32 <hexagoxel> ReinH: you continue to miss my point. i will ignore further messages.
12:16:39 <ReinH> hexagoxel: Well, what is your point then?
12:16:53 <ReinH> It must not have been put as clearly as you thought, or I must be especially obtuse today.
12:17:04 <ReinH> hexagoxel: and btw I'm not talking to you specifically.
12:17:54 <ReinH> I never implied that it would fix the issue at hand. I just said "use stack".
12:17:58 <dolio> No one was in "cabal hell" here. Everyone simply assumed they were, because people blame cabal for everything bad that happens while using it, even if it's something like the package specifying impossible to satisfy bounds.
12:18:11 <ReinH> dolio: fair enough.
12:18:41 <ReinH> I can replace "cabal hell" for "failure involving cabal" without damaging my argument, I think.
12:18:59 <dzdcnfzd> Guys, I'm sorry
12:19:00 <glguy> For most people "cabal hell" means "I don't know what's going on"
12:19:17 <joco42> yeah this "map f (x:xs) =  f x : map f xs" uses lazy evaluation...
12:19:24 <dzdcnfzd> Can we go back to talking about coalgebras or something?
12:19:41 <joco42> so without lazy evaluation one could not write map so elegantly...
12:19:51 <dolio> dzdcnfzd: It's not your fault. It's a societal problem.
12:19:57 <ReinH> dimsuz: if you want to collect multiple errors, consider https://hackage.haskell.org/package/these-0.6.1.0/docs/Data-These.html
12:19:58 <kallisti> no you could still write map that way
12:19:59 <hexagoxel> ReinH: You said "use stack" in response to a question of how to fix an issue.
12:20:02 <kallisti> it would just evaluate strictly instead of lazily
12:20:10 <hexagoxel> how that is not an implication is beyond my understanding.
12:20:11 <ReinH>  dimsuz or, rather, https://hackage.haskell.org/package/these-0.6.1.0/docs/Control-Monad-Trans-Chronicle.html
12:20:13 <kallisti> also you're forgetting:  map f [] = []
12:20:13 <joco42> kallisti:  really ?
12:20:22 <dzdcnfzd> "Be the change you want to see in the world." Edward Kmett said that, I think
12:20:26 <joco42> kallisti:  yeah that is true...
12:20:37 <dolio> dzdcnfzd: Doesn't sound like him. :)
12:20:44 <ReinH> hexagoxel: I think I've made it pretty clear: it might not fix the issue, but it won't make it worse, and it will probably make it easier to fix the issue if it is fixable.
12:20:44 <jophish> dzdcnfzd: He wouldn't advocate mutable state
12:21:15 <dzdcnfzd> Hahha
12:21:15 <kallisti> but time is merely a function :: World -> World
12:21:18 <joco42> kallisti: ok, i think i see what you mean
12:21:21 <ReinH> I prefer dominant strategies even if they are not strictly dominant.
12:22:01 <ReinH> dolio: heh, it really doesn't
12:23:43 <kallisti> whatever happened to ehird?
12:24:36 <kallisti> I feel like he must have opened a hole in spacetime and got lost inside never to be seen again
12:25:25 <joco42> ok, so hof-s are used to abstract out on recursion and lazyness is used to abstract out on loops (iiuc - https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf), but loops are  created with recursion... so whats the big deal with lazyness then ? - i am confused...
12:25:39 <joco42> iiuc= if i understand correctly
12:25:49 <hexagoxel> ReinH: that is why i phrased it as "potential" issue. i may point out that you did not say more than the plain "use stack" until dolio replied.
12:26:25 <ReinH> hexagoxel: I still think your implication is unfounded, but we can agree to disagree.
12:28:05 <joco42> relevant part https://usercontent.irccloud-cdn.com/file/e8TFYLUJ/Screen%20Shot%202015-10-18%20at%2022.26.51.png
12:29:58 <dzdcnfzd> Is there a way to "roll back" a set of dependencies I just cabal install'd?
12:30:07 <dzdcnfzd> like, I tried to do this lush-tags thing but it fails ultimately
12:30:17 <dzdcnfzd> perhaps because of library changes, I'm not sure
12:30:21 <Lokathor> destroy the sandbox and start over, is the simplest answer
12:30:36 <dzdcnfzd> I'm very sorry, but I did not do things in a sandbox
12:30:42 <Lokathor> :(((
12:30:43 <dzdcnfzd> that's why I want to roll it back
12:30:48 <dzdcnfzd> Oh no
12:30:53 <dzdcnfzd> That's what I was worried about
12:31:00 <Lokathor> it's still possible, but very tricky
12:31:06 <dzdcnfzd> I was young and naive, don't judge me
12:31:15 <Lokathor> if you installed it just normally and not to the "world"
12:31:24 <ReinH> dzdcnfzd: No one is judging you. Some of us are silently judging cabal though.
12:31:35 <Lokathor> you can destroy your user level cabal data, which should be in .cabal
12:31:42 <Lokathor> ~/.cabal that is
12:31:53 <dzdcnfzd> But I can't roll back a recent set of changes?
12:31:58 <ReinH> No.
12:32:03 <Lokathor> not an individual rollback, nope :/
12:32:10 <ReinH> Not without manually using ghc-pkg on each package and version
12:32:45 <Lokathor> that's why folks are trying to move to stack, which auto-sandboxes everything for you (among other things)
12:32:50 <ReinH> dzdcnfzd: I would like to suggest again that you put cabal aside and try stack for a while.
12:32:56 <Lokathor> !
12:33:58 <dzdcnfzd> Yeah. I just installed the auto-sandbox script
12:34:07 <ReinH> auto-sandbox script?
12:34:15 <dzdcnfzd> but yeah, I mean, the sad truth is that my toolstack is pretty basic
12:34:22 <dzdcnfzd> https://github.com/quchen/cabal-install-bin
12:34:30 <ReinH> Don't bother with that. Just use stack.
12:34:43 <dzdcnfzd> We'll see. Probably soon.
12:34:59 <ReinH> Well, you can either keep fighting cabal or you can switch to stack. *shrug*
12:35:52 <aweinstock> ReinH: does stack have an equivalent of "cabal list" (i.e. a command-line hackage search)
12:36:08 <dzdcnfzd> Anyways, since lushtags doesn't work, does anyone have a favorite tag manager?
12:36:14 <dzdcnfzd> like, automatically creating tags
12:36:21 <dzdcnfzd> managing them
12:36:24 <ReinH> dzdcnfzd: hasktags
12:36:27 <dzdcnfzd> interfacing with Taglist
12:36:37 <dzdcnfzd> that doesn't automatically create / update them
12:37:34 <ReinH> Neither does lushtags, it just integrates with Tagbar.
12:38:05 <ReinH> You can use hasktags with tagbar too, look at the wiki https://github.com/majutsushi/tagbar/wiki#haskell
12:38:15 <dzdcnfzd> "Tagbar is nice because it deals with creating tags automatically. There is no  need to manually run commands or keep track of tag files. Just open any Haskell  file in Vim and the Tagbar window will instantly show an interactive browsable  list of all the functions and declarations in the file. This window also  updates automatically as you edit the file"
12:38:33 <ReinH> Yes, that's what I said.
12:38:50 <ReinH> tagbar does the automatic stuff, it just integrates with lushtags
12:38:54 <ReinH> but it can integrate with hasktags instead
12:39:02 <dzdcnfzd> trying to do that
12:39:11 <dzdcnfzd> ReinH:
12:40:08 <linduxed> hey guys
12:40:43 <linduxed> i was wondering, how would i express time, if the smallest component is seconds and the largest is years?
12:41:34 <linduxed> i would need to implement something that i can add any amount of seconds, and it needs to increment the minutes if it's >59 seconds, hours if it's >3599 seconds
12:41:36 <linduxed> and so on
12:42:11 <ReinH> linduxed: Depending on your needs, you can store as Integer seconds and use divmod to recover minutes and seconds
12:42:22 <linduxed> i'm thinking i should read up on monoids (i remember this being a category that worked in a "looping" fashion), but i'm not sure
12:42:42 <ReinH> Probably easier than storing as minutes and seconds and ensuring that all uses correctly deal with the modulo math
12:43:31 <dzdcnfzd> Thanks guys! I've got a sexy tag manager now!
12:43:44 <ReinH> There's no way to ensure that (Int, Int) is correct
12:43:50 <linduxed> well, basically, i need to implement this:
12:43:52 <linduxed> "Write a program that will calculate the date that someone turned or will celebrate their 1 Gs anniversary."
12:44:01 <linduxed> as in gigasecond
12:44:14 <ReinH> but if you're willing to accept an equivalence class, you can define a normal form and reduce towards it.
12:44:30 <linduxed> i should be able to input ISO dates
12:44:34 <linduxed> strings
12:44:52 <linduxed> then the program should return the date of the anniversary
12:45:03 <ReinH> e.g. (1, 60) and (2, 0) are in the same equivalence class, and (2,0) is the normal form.
12:49:09 <ReinH> so your mappend can be Mappend (Time m s) (Time m' s') = reduce $ Time (m + m') (s + s'), where reduce does the divmod and reduces to a normal form. This way your representation tends to stay in a normal form.
12:49:34 <ReinH> (mempty is ofc Time 0 0)
12:50:21 <xpilot> hi
12:50:25 <ReinH> linduxed: ofc minutes and seconds aren't enough to solve that problem. You need to know about calendars and leap years and such.
12:50:33 <xpilot> has anyone tried combining Data.Dependent.Map with Singletons?
12:50:56 <xpilot> namely, tried using Sing as the tag type of the map
12:50:58 <kallisti> if anyone is familiar with vinyl I'm looking for ways to simplify this code: https://github.com/kallisti-dev/hs-webdriver/blob/vinyl-capabilities/src/Test/WebDriver/Capabilities.hs
12:51:00 <ReinH> and once you know about calendars and leap years, minutes and seconds aren't any better than seconds.
12:51:19 <ReinH> since you can always convert from seconds to days, hours, minutes, and seconds
12:51:55 <ReinH> so I see no point in using minutes and seconds as your representation, but ofc you can do it if you want
12:54:55 <JagaJaga> What homework is a best practice to learn state, write and reader monads?
12:59:26 <ReinH> JagaJaga: perhaps the NICTA courseware?
13:04:02 <JagaJaga> ReinH: thank you.
13:04:49 <linduxed> ReinH: yeah, i'm aware of the need to implement leap years and such things
13:05:07 <linduxed> ReinH: i just thought i'd start off by asking for how i'd implement the basic structure
13:05:49 <ReinH> linduxed: Sure. I'm suggesting that seconds is a perfectly good basic structure.
13:06:10 <ReinH> minutes and seconds only buys you extra compleity
13:08:12 <linduxed> ReinH: hmmm, i'm trying to figure out how this would work...
13:09:43 <ReinH> linduxed: you need to figure out how many days there are in 1Gs, then you need to figure out what day is that many days in the future of their birthday, then you need to add the hours, minutes, and seconds, and possibly carry the day.
13:11:02 <ReinH> Probably: first, write a function Second -> (Day, Hour, Minute, Second) (where these can all be type synonyms for Int), then write a function to add (Day, Hour, Munute, Secon d) to given time in a way that respects the shape of the calendar, including leap years.
13:11:27 <seagreen> Does anyone know the story behnind network-uri and uri-bytestring? They seem very similar from the outside.
13:11:44 <linduxed> ReinH: hmmm, sounds reasonable
13:11:52 <linduxed> i'll give this some thought
13:12:05 * hackagebot thrift 0.9.3 - Haskell bindings for the Apache Thrift RPC system  https://hackage.haskell.org/package/thrift-0.9.3 (jfarrell)
13:12:28 <ReinH> seagreen: network-uri uses strings, uri-bytestring uses bytestrings.
13:13:10 <ReinH> linduxed: or, depending on what flexibility you have in implementing this, turn seconds into a time interval using the time package and then simply add that to the parsed time.
13:17:12 <linduxed> i suspect that's within the scope of the task
13:17:17 <linduxed> well, the thing is
13:17:23 <linduxed> it's an exercism exercise
13:17:28 <linduxed> exercism.io
13:17:34 <linduxed> so i basically solve a problem
13:17:44 <linduxed> i have some tests available that my function needs to pass
13:18:10 <linduxed> then i submit that, and then other people nitpick it to either point me into directions of better solution or better style for the code
13:18:29 <ReinH> Can you link me to the exercise?
13:20:58 <seagreen> ReinH: I'd still like to know more. As far as I can tell both bytestrings and strings are valid representations of a URI path (as long as the percent encoded non-ASCII characters are decoded correctly). I wonder if bytestrings or strings work better in practice, and also if that's the only difference between the libs.
13:21:29 <seagreen> ReinH: If you don't know no worries, it's kind of an open-ended question.
13:21:50 <ReinH> seagreen: I'm actually not sure about bytestrings now that urls can include unicode
13:22:31 <ReinH> but the idea would be that bytestrings are a much more efficient representation of sequences of bytes than strings
13:23:17 <seagreen> ReinH: Gotchya. That makes sense!
13:23:26 <seagreen> The whole URL world scares me: https://en.wikipedia.org/wiki/Internationalized_domain_name
13:24:12 <ReinH> seagreen: if there are other differences in the libraries, they might be differences in features or probably trivial differences between the structures used to represent things.
13:25:22 <ReinH> I suppose that urls use a specific encoding of unicode and that encoding can be stored in a bytestring
13:26:09 <ReinH> I think many modern clients use the URI implementation in http-types, e.g., http-client and wreq.
13:26:16 <ReinH> (which uses bytestrings)
13:30:47 <ReinH> seagreen: Every time the word "Unicode" is used to refer to an *encoding* (like in that wiki article), it makes me sangry.
13:31:19 <ReinH> I think that Unicode should strictly refer to the set of coded characters and the mapping from integer code points to that set.
13:31:29 <Welkin> a word makes you angry?
13:31:31 <ReinH> I think in the windows world it is common to refer to UTF-16 as Unicode.
13:31:49 <ReinH> e.g. .NET's Encoding.Unicode
13:32:12 <seagreen> ReinH: Totally agree.
13:32:53 <ReinH> seagreen: anyway, bytestring would be a valid representation of the encoding used by uris, and it should be more efficient than String in almost every usec ase.
13:33:07 <ReinH> *use case
13:33:43 <ReinH> Welkin: no?
13:35:17 <seagreen> ReinH: Agreed! I've seen http-types around a lot, and it has a lot of useful stuff, but it doesn't seem to include a whole URL type, more like utilities: https://hackage.haskell.org/package/http-types-0.9/docs/Network-HTTP-Types-URI.html
13:35:46 <ReinH> seagreen: what is missing?
13:37:15 * hackagebot yesod-content-pdf 0.2.0.1 - PDF Content Type for Yesod  https://hackage.haskell.org/package/yesod-content-pdf-0.2.0.1 (alexkyllo)
13:37:27 <linduxed> ReinH: http://exercism.io/exercises/haskell/gigasecond/readme
13:37:48 <linduxed> you can see the test suite there too
13:38:41 <seagreen> ReinH: uri-bytestring has parseURI, which splits out the scheme, path, fragments, etc from a bytestring. As far as I can tell the closest thing http-types has is decodePath. It will split out the path segments and the queries for you, but doesn't split out the scheme or the fragment (if any).
13:39:03 <seagreen> I could be missing something though.
13:39:50 <sm> is there a public repo containing all past HCAR editions ? I'm not finding it
13:41:34 <ReinH> seagreen: yeah, good point
13:41:43 <ReinH> sm: HCAR?
13:42:25 <linduxed> ReinH: i'm not sure if you can log in without a github account
13:44:05 <ReinH> linduxed: If they're using the time library then I imagine that you could too.
13:45:37 <linduxed> stands to reason, yes
13:46:04 <cocreature> hcar=haskell community activity report or something like that
13:46:50 <hexagoxel> @where hcar
13:46:50 <lambdabot> http://www.haskell.org/communities/
13:47:17 <hexagoxel> oh great, it is a redirect.. what is the setter for the getter "@where" ?
13:57:28 <zair> Noob Question: What exactly does [LT .. GT] or [(LT)..(GT)] work but not [LT..GT]?
13:57:34 <zair> Why exactly*
13:58:13 <kallisti> > [LT..GT]
13:58:14 <lambdabot>  Not in scope: ‘LT..’    A section must be enclosed in parentheses thus: (LT....
13:59:47 <zair> Was that supposed to be the answer?
13:59:51 <MarcelineVQ> It's not a section though, LT doesn't take any arguments. A better question might be, why does [1..3] work and [LT..GT] doesn't
14:00:00 <kallisti> I believe it's interpreting that as an infix operator named (.) qualified by the module named LT
14:00:01 <MarcelineVQ> To which I don't know the answer
14:00:19 <kallisti> because you can write stuff like  a LT.. b
14:00:31 <MarcelineVQ> kallisti: That makes sense
14:00:31 <kallisti> which means the same thing as LT.(.) a b
14:00:31 <zair> Year MarcelineVQ, that's essentially what I'm trying to ask
14:01:11 <zair> Haven't learned anything about yet.
14:01:24 <kallisti> the . syntax in Haskell is a bit overloaded, so when it sees an uppercased term prefixing a . with no spaces inbetween, it interprets that as a module qualification rather than a data constructor in front of an infix operator.
14:01:48 <zair> Thanks, that makes things more clear
14:02:03 <hexagoxel> @where+ hcar https://wiki.haskell.org/Haskell_Communities_and_Activities_Report
14:02:03 <lambdabot> It is stored.
14:02:35 <kallisti> it assumes that, since modules always begin with an uppercase letter, that the form Module.x with no spaces is an identifier for the name "x" in Module
14:03:10 <zair> Ah
14:03:10 <zair> got it
14:03:16 <zair> Thank you :)
14:04:29 <kallisti> you could in theory circumvent this limitation of the snytax, but it would involve some nasty implications, since you can't do a full lexical analysis of the source code before attempting to resolve names. You have to do both at the same time.
14:05:05 <TheCrafter> Hello guys. I want to get hardware information (Cpu temprature, fan speed, etc...) . Is there any package to do that?
14:05:51 <kallisti> so, for example, any time you reference an identifier in source code it would have to be defined before the reference (similar to what happens when you start using template haskell)
14:06:35 <zair> Don't know anything about templates yet.
14:06:39 <kallisti> TheCrafter: that's a pretty complex task and involves a lot of OS-dependent and obviously hardware dependent stuff. I would be surprised if someone made a cross-platform high-level interface for it.
14:06:46 <zair> I assume they're like java interfaces?
14:07:01 <TheCrafter> kallisti: Yeah me too... That's why I asked if you know anything
14:07:01 <kallisti> zair: no it's more like compile-time lisp macros
14:08:00 <kallisti> if you're on a unix-based system there's usually a lot of information available through the /sys/ mount point. I don't know if that's guaranteed cross-platform support or not though.
14:08:13 <zair> Well, thanks for the help! back to learning!
14:08:16 <kallisti> I'd imagine windows would be much harder
14:08:46 <TheCrafter> Yeap I'm in windows ^_^
14:09:34 <TheCrafter> Hm.. I can probably make it happen with C++. Is there any way to use C++ code from haskell? Even in a dll.
14:09:59 <KaneTW> extern C it
14:10:39 <kallisti> looks like in windows you need to link to user32.lib and make FFI calls to get stuff like cpu cores.
14:10:43 <kallisti> not sure about temp sensors
14:11:20 <TheCrafter> anyhow I got lots of reading to do..
14:11:22 <TheCrafter> thanks for your help
14:12:33 <kallisti> TheCrafter: https://hackage.haskell.org/package/Win32-2.3.1.0  probably something in here that could help
14:12:38 <kallisti> not sure why the docs aren't on hackage
14:13:02 <ReinH> linduxed: so https://hackage.haskell.org/package/time-1.5.0.1/docs/Data-Time-Clock.html#v:secondsToDiffTime
14:13:46 <TheCrafter> kallisti: Yeah no docs... weird. But thanks! I'll definitely look into that
14:13:49 <kallisti> TheCrafter: https://github.com/haskell/win32/blob/master/System/Win32/Info.hsc  yeah here's the GetSystemInfo stuff
14:14:03 <kallisti> source code is fairly readable even with the sparse docs
14:14:22 <linduxed> ReinH: i'll have a look at that!
14:15:58 <TheCrafter> kallisti: Yeah you're right. But still, I'll have to dig more if I want information about Fan speed or cpu/gpu temprature!
14:16:08 <linduxed> ReinH: that looks exactly what i need! now i just need to understand how i can turn a DiffTime into something i can work with
14:16:11 <linduxed> :-)
14:19:27 <ReinH> linduxed: it's already something you can work with.
14:19:44 <kallisti> TheCrafter: apparently all of that info is part of WMI interface. seems like you need to use COM to access it. http://hackage.haskell.org/package/com
14:20:52 <TheCrafter> kallisti: Well, having win32 and com interfaces is good. I can work with that. Even if not, I'll use haskell's FFI.
14:21:55 <kallisti> do you plan on adding linux support? would be pretty cool to have a cross-platform system info library
14:22:39 <kallisti> basically just have different submodules for each platform, then a CPP conditional on the primary module to import the correct one based on build target
14:23:25 <kallisti> then some conditionals in the cabal build to only depend on windows stuff when you're on windows, linux stuff on linux (though all the linux info should just be in the filesystem anyway)
14:26:40 <dzdcnfzd> Can tagbar be used to display type signatures passively?
14:26:54 <dzdcnfzd> that is, to automatically list every function with its type signature
14:27:04 <dzdcnfzd> or even to just display type signatures upon command?
14:30:09 <kallisti> hm not sure I understand how -fprint-explicit-kinds works
14:30:35 <kallisti> didn't seem to do anything when I compiled with it
14:31:09 <kallisti> oh, probably because there wasn't any compile errors. :P  I was thinking it was some kind of kind debugging thing, but it only prints on compile errors
14:33:21 <ReinH> dzdcnfzd: does the tags file include type information?
14:35:05 <dzdcnfzd> I don't know -- I'm just creating it via hask-tags
14:37:01 <yorick> twanvl: too bad I can't make the tutorial, or I'd apply as a TA for formal languages/automata
14:37:04 <ReinH> You probably want ghc-mod or similar
14:41:47 <ReinH> There's also ide-backend, but I don't know of any vim integration for it yet.
14:43:30 <dzdcnfzd> ReinH: kk. Just going through Diehl's vim / haskell workflow and getting a bunch of this stuff now
14:44:04 <dzdcnfzd> Actually, I should ask this (hopefully last) question, cuz I'm new to my area and the chances are that a bunch of you guys are around
14:44:30 <dzdcnfzd> I just moved to SF, and I work the whole day every weekday. Are there any interesting haskell meetups on weekends that you guys think are interesting?
14:44:46 <dzdcnfzd> slash, how should I get involved in the community?
14:45:04 <shachaf> Nothing I know of in weekends, usually.
15:00:04 <ReinH> dzdcnfzd: there's also https://github.com/begriffs/haskell-vim-now
15:01:38 <ReinH> dzdcnfzd: There is one on evenings, at least http://www.meetup.com/haskellhackersathackerdojo/
15:05:40 <shachaf> There's also a thing in San Francisco.
15:05:50 <shachaf> But not in weekends.
15:32:51 <julianleviston> I have the following in my code, and it seems to be locking up my code and doesn’t allow me to “ctrl-C out of it” - does anyone know why? I.runInterpreter $ I.setImports ["Prelude"] >> I.interpret "1 + 1" (I.as :: Int) 
15:37:20 * hackagebot rdf4h 1.3.3 - A library for RDF processing in Haskell  https://hackage.haskell.org/package/rdf4h-1.3.3 (RobStewart)
15:38:52 <SrPx> I'm frustrated with a result. I thought I understood what "optimal" evaluators did at a high level. That is, I expected that they would be able to evaluate terms to the normal form with optimal asymptotics. 
15:38:53 <MarcelineVQ> idk about that but looking at the docs, "The underlying ghc will overwrite certain signal handlers (SIGINT, SIGHUP, SIGTERM, SIGQUIT on Posix systems, Ctrl-C handler on Windows)." idk what's causing it to not terminate though
15:39:39 <SrPx> Yet, I have tons of terms for which very stupid evaluators (such as JavaScript) manage to find the normal form in linear time, yet any optimal evaluator I tested take exponential time! How can that be? If anyone has an insight, I posted it on CST - http://cstheory.stackexchange.com/questions/32850/are-optimal-evaluators-actually-optimal
15:40:05 <SrPx> Any kind of insight is welcome because it doesn't make any sense to me.
15:41:19 <julianleviston> MarcelineVQ: could be that I’m in Snap, and I should be forking so as not to lock it up or something, though, that doesn’t make *too* much sense because the server still responds to requests.
15:42:10 <julianleviston> MarcelineVQ: Actually - that makes sense, overwirting the signals… because I’m sending it CTRL-C in unix, which is sigterm I think…(can’t rememeber my sigs)
15:42:22 <julianleviston> MarcelineVQ: thanks.
15:43:06 <Jinxit> julianleviston: sigint, iirc
15:43:15 <julianleviston> Jinxit: cool thanks
15:43:42 <julianleviston> MarcelineVQ: where in the dox did you see that?
15:44:12 <MarcelineVQ> http://hackage.haskell.org/package/hint-0.4.2.3/docs/Language-Haskell-Interpreter.html#g:2
15:44:16 <julianleviston> MarcelineVQ: thanks
15:45:06 <julianleviston> MarcelineVQ: if I somehow forked, do you think that would “fix” this behaviour?
15:45:13 <julianleviston> MarcelineVQ: I’ll try. Thanks again.
15:45:16 <MarcelineVQ> I don't know anything about it sry :>
15:57:54 <naudiz> http://lpaste.net/2706038531322544128 why does this work in ghci, but not in ghc? It says Couldn't match type ‘Data.Monoid.First Text’ with ‘Data.Monoid.Endo [Text]’
15:58:57 <naudiz> (on line 7)
16:22:34 * hackagebot secp256k1 0.1.5 - secp256k1 bindings for Haskell  https://hackage.haskell.org/package/secp256k1-0.1.5 (xenog)
16:27:39 * hackagebot secp256k1 0.1.4 - secp256k1 bindings for Haskell  https://hackage.haskell.org/package/secp256k1-0.1.4 (xenog)
16:28:56 <naudiz> lgo 22
16:28:59 <naudiz> oops
16:37:56 <SrPx> "Haskell is a language in which you can be perfectly competent to write code, yet still feel like you don't know shit. It is kinda like C++... but for different reasons."
16:40:08 <Lokathor> yep
16:41:34 <ph88^> does someone know if it´s possible to convert a recursive descent grammar to LALR ?
16:45:26 <benl23> ph88^: doing that should be a no-op
16:45:59 <ph88^> benl23 what´s that a no-op ?
16:46:07 <benl23> if you have a grammar that works with a LL recursive descent parser, any of the LALR parser generator tools should accept it
16:46:09 <benl23> no operation
16:46:10 <benl23> free
16:46:18 <benl23> no work required
16:46:21 <ph88^> oh that´s nice
16:46:48 <ph88^> i want to convert a grammar from parboiled (scala) to lemon parser generator
16:46:57 <ph88^> but i figured people from #haskell would know this ^^
16:47:06 <benl23> ahaha
16:47:09 <ph88^> :D
16:47:20 <ph88^> thanks benl23 
16:47:40 <benl23> you may find that your "recursive descent parser" is doing some other hacks though
16:47:56 <benl23> it may be stashing things in data structures and reading them back along the way
16:48:31 <benl23> "grammar" refers to just the BNF grammar for the language, but if you have a parser implemented as a program then it may be doing other things
16:48:41 <ph88^> well i don´t know yet the finer details of it, or what consequences that could have for trying to port the grammar
16:48:54 <benl23> grammar /= parser
16:49:44 <ph88^> http://parboiled2.org/ --> http://www.hwaci.com/sw/lemon/
16:50:25 <ph88^> can´t say anything else about it at this point .. have to study it more
16:55:13 <python476> hi there
16:55:37 <MadNomad> aloha
16:55:44 <python476> aloha means family
16:55:50 <hodapp> bah?
16:55:57 <python476> free Disney quotes
16:56:20 <MadNomad> ohana means family 
16:56:31 * MadNomad facedesks
16:56:36 <python476> anyway, I was trying to write accumulator recursion in Haskell (I'm a noob)
16:56:37 <Hafydd> The relation of "aloha equivalence" forms a set of equivalence classes, or families.
16:56:45 <python476> exactly
16:56:49 <hpc> type family Ohana
16:57:16 <python476> in scheme code you'd have a top level function F list using a hidden function f list acc
16:57:41 <python476> and I can't find a way to express that in haskell to save my life
16:58:47 <python476> now I'm thinking of having a `nil` (pardon my lisp) passed at first but it seems so wrong
16:59:05 <hpc> so something like
16:59:17 <hpc> f (x:xs) = go x xs where go = ...
16:59:26 <shachaf> Well, f probably wouldn't match.
16:59:30 <hpc> (and f [] = saneDefault)
16:59:40 <python476> hpc: partly yes
16:59:52 <shachaf> f list = go 0 list where { go acc [] = ... ; go acc (x:xs) = ... }
17:00:01 <shachaf> Better yet: f = go 0 where { go acc [] = ... ; go acc (x:xs) = ... }
17:00:36 <python476> yeah but that 0 is arbitrary
17:00:47 <hpc> or depending on how you want f to work, foldr (\x acc -> whatever) nil
17:00:49 <python476> I need an empty generic Zero
17:01:00 <monochrom> the 0 there is the initial accumulator value. replace it by whatever initial value you actually want
17:01:18 <Hafydd> "go" is an offensively meaningless name.
17:01:18 <monochrom> even in scheme you can't escape that question
17:01:29 <hpc> Hafydd: we should call it f instead
17:01:46 <python476> I'm writing `last` (exercise) in accumulator style, so I can't have a specific type
17:01:52 <hpc> monochrom: don't be silly, in scheme you could make it a self-modifying macro that reads from a file somewhere
17:02:15 <hpc> > last []
17:02:17 <lambdabot>  *Exception: Prelude.last: empty list
17:02:18 <hpc> use that
17:02:21 <shachaf> No language bashing, please.
17:02:39 <monochrom> last doesn't need accumulator.
17:02:53 <python476> monochrom: it's an exercise
17:02:57 <monochrom> it just needs a base case and an induction case
17:03:13 <monochrom> yes, that doesn't change the truth that last doesn't need accumulator
17:03:23 <python476> doesn't need but 'can'
17:03:38 <python476> I guess the normal recursive pattern matches on two `:`
17:03:40 <hpc> shachaf: not language bashing, scheme is fun
17:03:52 <monochrom> ok how about this, you post on lpaste.net the verbatim exercise text. unabridge verbatim. do not add your own interpretation.
17:04:04 <python476> it's a self inflicted one
17:04:25 <python476> I wanted to write last using accumulator and not last x:y:z ... ; last x:y style
17:04:44 <monochrom> then it is a worthless exercise.
17:05:07 <behzad-nouri> @hoogle (a -> Bool) -> [a] -> ([a], [a])
17:05:10 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
17:05:10 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
17:05:10 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
17:05:17 <python476> thankfully my exercise  has no self esteem issue
17:05:22 <behzad-nouri> @hoogle Monad m => (a -> m Bool) -> [a] -> m ([a], [a])
17:05:23 <lambdabot> No results found
17:05:34 <hpc> python476: it has a non-educational issue
17:05:48 <monochrom> the issue is not esteem. the issue is spending your time wisely.
17:05:51 <python476> my exercise is now purposeless
17:06:26 <hpc> a better exercise for learning accumulator style might be a fib function, perhaps
17:06:35 <hpc> since there's a value there worth accumulating
17:06:39 <monochrom> every invention of yours, or anyone's, is not going to be equally valuable. great tautology that people try so hard to violate in vain.
17:06:50 <hpc> (though you'll likely find you're writing a manual expansion of a fold)
17:08:23 <python476> hpc: that happens to me far too often, I wonder how to avoid this
17:08:33 <Kristler> python476: Just out of curiosity, what is it that you're hoping to accumulate in this "last" function of yours?
17:09:02 <python476> ensure you compose basic blocks and not their composed expansion.. sometimes it's hard to recognize. Maybe I'm to new to FP
17:09:13 <python476> Kristler: the previous head
17:10:09 <python476> basically I wanted a dumb recursion case with latest head, and a base case of <acc> [] which yields acc
17:12:15 <python476> it's not accumulation per se, since it forgets everything before
17:12:34 <python476> maybe a zip then
17:36:22 <naudiz> how the hell do you use unicode character encoding for an irc bot? :(
17:37:04 <tabemann> I'm writing an IRC client, and I don't know exactly how encodings in IRC work, because apparently there are special characters used to switch between encodings
17:37:19 <tabemann> so that you can have both colors and Unicode
17:38:06 <naudiz> I'm trying to write an IRC bot that handles Jisho lookups. One sec, I'll show you the output
17:38:28 <tabemann> in the IRC client I'm wriiing, I'm handling it by not deciding on an encoding in most of the code, and rather representing strings in general as ByteStrings
17:38:44 <naudiz> test
17:38:45 <jisho-bot> 10 results｛[C] 木, 樹　「き」｝, ｛木　「もく」｝, ｛[C] 木曜日　「もくようび」｝, ｛[C] 木材　「もくざい」｝, ｛[C] 木曜　「もくよう」｝, ｛[C] 木綿, 木綿, 木棉　「もめん」｝, ｛[C] 木星　「もくせい」｝, ｛[C] 木工　「もっこう」｝, ｛[C] 木々, 木木, 樹々, 樹樹　「きぎ」｝, ｛[C] 木の実, 木の実, 木ノ実, 木ノ実　「このみ」｝
17:38:57 <naudiz> wait, what? now I'm REALLY confused
17:39:22 <naudiz> I tried it on another network and it was just nonsense
17:40:30 <naudiz> I'm using Text as a data type which should be able to handle unicode... all of this is just very strange.
17:40:54 <naudiz> 10 resultsï½ [C] æ ¨, æ¨¹ã  ã  ã  ã  ï½ , ï½ æ ¨ã  ã  ã  ã  ã  ï½ , ï½ [C] æ ¨æ  æ ¥ã  ã  ã  ã  ã  ã  ã ³ã  ï½ , ï½ [C] æ ¨æ  ã  ã  ã  ã  ã  ã  ã  ï½ , ï½ [C] æ ¨æ  ã  ã  ã  ã  ã  ã  ã  ï½ , ï½ [C] æ ¨ç¶¿, æ ¨ç¶¿, æ ¨æ£ ã  ã  ã  ã  ã  ã  ï½ , ï½ [C]
17:40:58 <Hijiri> maybe the other network isn't handlign unicode
17:41:14 <naudiz> that's part of the output on another network
17:41:19 <exio4> tabemann: ? special characters to switch between encodings? never heard of that? 
17:41:20 <tabemann> that looks like the other network is using latin-1
17:41:22 <naudiz> it should...
17:41:26 <Hijiri> test
17:41:59 <Hijiri> did you try sending japanese through your irc client on the other server
17:41:59 <naudiz> wait, I'll try another channel on this network where I had similar problems
17:42:01 <Hijiri> network
17:42:12 <naudiz> Hijiri: I did, it worked
17:42:15 <Hijiri> oh
17:42:19 <Axman6> I would guess that Text is not the right abstraction for handling mixed encoding output, which I would guess is what is needed for IRC - if there's delimiters to specify when text is unicode and by default it isn't, then you'll need to use something more low level
17:42:25 <tabemann> exio4: yes - because of it, I've run into issues like that if I write a single character outside of 0x00-0x7F in a line, it won't show up properly in many other IRC clients because xchat uses a different character to escape it than normal that many other clients don't understand
17:42:26 <Hijiri> maybe then there are unhandled switching chars
17:42:44 <naudiz> Hijiri: do you have any information on those?
17:42:48 <Hijiri> nope
17:43:01 <tabemann> I'd like more documentation of this, though, as I will need to be able to handle such things for my IRC client
17:43:04 <exio4> tabemann: I never heard of a `encoding-changing character`? 
17:43:11 <naudiz> tried it on ##anime-japanese, same problem
17:43:43 <naudiz> that's the channel the bot is for, so... yeah, that's kind of a problem
17:45:27 <naudiz> are colours enabled on this channel?
17:45:32 <Hijiri> I think so
17:45:33 <exio4> they are
17:45:36 <Hijiri> test
17:45:45 <exio4> +c is the channel mode that disables the colors, this channel doesn't have it :)
17:45:46 <naudiz> maybe that's the issue?
17:46:03 <tabemann> http://xchat.org/encoding/
17:46:04 <Hijiri> try it in a new channel
17:46:08 <Hijiri> with colors enabled/disabled
17:46:28 <naudiz> nah, that's not it
17:46:28 <exio4> (and yes, not having the channel mode that disables colors is equal to having colors enabled, at least there!)
17:46:33 <tabemann> x-chat handles a whole pile of different encodings, e.g.
17:48:02 <naudiz> is there a channel dedicated to irc client development or something?
17:48:16 <exio4> tabemann: well, my `typical` way to deal with this, is to go with the simplest and `correct unless your config is probably wrong` configuration :P
17:48:26 <glguy> naudiz: We have #haskell-irc, but it's not as active as this
17:49:24 <Hafydd> What is #haskell-irc for?
17:49:31 <naudiz> the library does seem to send escape characters. "10 results\239\189\155[C] \230\156\168, ..."
17:49:33 <tabemann> the default configuration with xchat is "IRC", which is a hybrid latin-1/UTF-8 configuration
17:49:35 <Hafydd> ...oh. Never mind.
17:49:54 <glguy> tabemann: I think that the technical term for xchat's encoding is "broken"
17:50:07 * glguy adapted his client to be able to read broken messages from xchat users
17:51:33 <naudiz> it's definitely not the colours
17:51:50 <exio4> it's hard to disagree on that, hexchat reverted that encoding to UTF-8 which is obviously a way saner default
17:52:28 <glguy> naudiz: \239\189\155 is the UTF-8 encoding of ｛
17:52:48 <exio4> naudiz: how are you decoding it?
17:52:49 <naudiz> glguy: yes, I know. That's what it's sending
17:53:04 <naudiz> exio4: what do you mean, exactly?
17:53:20 <naudiz> I'm using the irc-client library
17:53:23 <exio4> naudiz: you read a ByteString from network, how do you get a Text out of it? 
17:53:28 <exio4> hm, not familiar with it
17:55:29 <naudiz> this makes no damn sense...
17:56:25 <naudiz> it has nothing to do with the modes... but why does it only work on some channels?
17:57:09 <exio4> what's the channel where it doesn't work? is it the same client sending those characters?
17:57:24 <naudiz> it is
17:57:35 <naudiz> ##anime-japanese for example
17:58:43 <naudiz> it's sending a welcome message, starting with "\227\129\147\227\130\147\227\129\171\227\129\161\227\129\175"
18:00:12 <glguy> naudiz: Do you know that the japanese channel is using utf8?
18:00:28 <naudiz> glguy: no, but can it depend on a channel?
18:00:57 <naudiz> I'd expect it to use uft8
18:02:20 <glguy> naudiz: It's up to each user what encoding to use on IRC
18:02:49 <naudiz> glguy: then it shouldn't depend on the channel at all
18:03:54 <glguy> naudiz: If a user of a channel set the topic for that channel it's encoded how ever that user set it
18:04:41 <naudiz> glguy: it also fails on a channel without a topic on another network
18:06:49 <naudiz> I'll just look into it again tomorrow... I'm too tired. :/ but thank you all
18:07:21 <tabemann> for IRC probably the sanest thing to do is to *not* use Text except at the moment of text rendering
18:07:50 <tabemann> and as I am doing using ByteStrings universally for representing data coming from or being sent to the IRC server
18:08:42 <Zemyla> Is there any profunctor type that is analagous to ArrowApply?
18:08:44 <tabemann> this way one can make your code support more than one encoding through having multiple converters from ByteStrings to Text
18:08:53 <naudiz> tabemann: I'm not gonna rewrite it yet again.....
18:28:49 <FreeFull> > length (3, 4)
18:28:51 <lambdabot>  1
18:28:53 <FreeFull> Huh
18:29:55 <tabemann> :t length
18:29:56 <lambdabot> Foldable t => t a -> Int
18:32:02 <jle`> FreeFull: a tuple (e, a) is considered as a single value --  a, "tagged" with a tag e
18:32:32 <jle`> in terms of its Functor, Foldable, Traversable, etc. instances
18:32:45 <FreeFull> jle`: I see
18:32:52 <FreeFull> > length (1,2,3)
18:32:54 <lambdabot>      No instance for (Foldable ((,,) t0 t1))
18:32:54 <lambdabot>        arising from a use of ‘length’
18:32:54 <lambdabot>      In the expression: length (1, 2, 3)    No instance for (Num t0) arising ...
18:33:22 <jle`> maximum (2,1) being 1 might seem weird, but it makes sense fi you consuder what maximum ("hello", 1) has to be
18:34:41 <FreeFull> > fmap (+1) ('a', 'b', 3)
18:34:43 <lambdabot>      Could not deduce (Functor ((,,) Char Char))
18:34:43 <lambdabot>        arising from a use of ‘fmap’
18:34:43 <lambdabot>      from the context (Num b)
18:35:01 <jle`> hm...i feel like there should/cna be Functor, Foldable, etc. instances for threeples
18:35:10 <jle`> i never really thought about it before
18:35:15 <FreeFull> Yeah, acting over the last element
18:35:26 <jle`> yeah, essentially like a Functor instance for (,) (Char, Char)
18:35:38 <cnr> @let instance Foldable ((,,) a b) where foldMap f (_,_,a) = f a
18:35:40 <lambdabot>  Defined.
18:35:45 <cnr> > length (1,1,1)
18:35:47 <lambdabot>  1
18:36:28 <FreeFull> @let instance Functor ((,,) a b) where fmap f (a,b,c) = (a,b,f c)
18:36:29 <lambdabot>  Defined.
18:36:33 <FreeFull> > fmap (+1) ('a', 'b', 3)
18:36:34 <lambdabot>  ('a','b',4)
18:36:42 <jle`> @let instance Traversable ((,,) a b) where traverse f (x,y,z) = (x,y,) <$> f z
18:36:43 <lambdabot>  Defined.
18:36:52 <jle`> > sequence (1,2, Just 3)
18:36:53 <lambdabot>  Just (1,2,3)
18:37:11 <jle`> oh well
18:37:39 <FreeFull> > fmap (+1) (,3)
18:37:41 <lambdabot>      No instance for (Typeable t0)
18:37:41 <lambdabot>        arising from a use of ‘show_M380238473443522632616060’
18:37:41 <lambdabot>      In the expression:
18:38:02 <FreeFull> Oh, that's a tuple section
18:38:09 <jle`> yes
18:38:21 <FreeFull> I forgot Haskell doesn't have 1-ples
18:38:40 <jle`> not as a part of syntax, at least :)
18:39:16 <FreeFull> I haven't written Haskell in a long time
18:41:25 <jle`> we've all been there
18:42:44 <FreeFull> I've been mostly pulled away by Rust :)
18:43:14 <FreeFull> But also things like Prolog
18:45:50 <jle`> prolog is nice...it's like you write a quickcheck property test to test your function once you've written it, and then boom you already have your function
18:46:19 <jle`> s/once you've/before you've
18:49:07 <FreeFull> jle`: Prolog is especially nice when you get into libraries like clpfd
18:58:51 <halvorg> Hey, I'm doing the Functor part of the NICTA course. Is it me or is the wrong List type used in the props for <$?
18:59:16 <dibblego> halvorg: which example?
19:00:06 <halvorg> prop> x <$ [a,b,c] == [x,x,x]
19:00:37 <halvorg> shouldnt this be x <$ (a :. b :. c :. Nil) == (x :. x :: x :. Nil) ?
19:00:44 <halvorg> [] has no functor instance in scope
19:01:14 <halvorg> https://github.com/NICTA/course/blob/master/src/Course/Functor.hs
19:01:41 <dibblego> halvorg: yes that is a mistake due to a recent change
19:01:53 <dibblego> halvorg: please open an issue
19:02:28 <halvorg> ok I will
19:04:27 <capisce> looks like an awesome podcast: http://typetheorypodcast.com/
19:32:41 <kamatsu> so, i know time is complicated, but I would like to make it possible for my users to configure what timezone they want their UTCTime displayed in
19:33:16 <kamatsu> the timezones in the time library is pretty underpowered, is there something that gets an updated timezone database or something? with summertime handling etc.?
19:36:18 <kamatsu> ah, tz package seems to be what i want
19:42:32 <ttt_fff> is there a haskell library where (1) I input lat/long, and (2) it outputs straight line distance between the two ?
19:48:35 <zomg> ttt_fff: not sure but you can use the haversine formula to calculate it (that'll take into account curvature, but not things like mountains or such)
19:49:14 <ttt_fff> https://en.wikipedia.org/wiki/Haversine_formula
19:49:15 <ttt_fff> okay
19:49:25 <ttt_fff> how do I go from (lat1, long1) , (lat2, llong2) ->distance ?
19:56:24 <adas> isn't it intuitive that only types that are traversable can be foldable? then why is that for a type to be traversable it also has to be foldable instead of the other way around?
19:57:12 <shachaf> The other way around wouldn't make sense with your first sentence.
19:57:13 <shachaf> A type is traversable only if it's foldable.
19:57:24 <shachaf> Oh, maybe not.
19:57:35 <shachaf> A type can be foldable without being traversable.
19:57:46 <shachaf> So I misunderstood your first sentence.
19:58:11 <adas> shachaf: to fold a type shouldn't you have to traverse it to begin with?
19:58:15 <shachaf> You should ignore any intuition for the words "traversable" and "foldable".
19:58:33 <shachaf> Instead you should look at what the classes let you do.
19:59:01 <shachaf> Roughly, Foldale means you have toList (:: t a -> [a]); Traversable means you have mapM.
20:01:54 <zomg> I wonder if you could draw a parallel with the visitor pattern
20:02:21 <zomg> ttt_fff: I don't remember it off the top of my head :) Google should have some answers
20:02:44 <Lokathor> how does one figure out where ~/.ghci is for the ghc that stack is using?
20:03:08 <Lokathor> can you just make ghci give the location of the config file it loaded somehow?
20:06:58 <moonman> what is the best music to program haskell in?
20:07:20 <abrar> ttt_fff: https://hackage.haskell.org/package/gps-1.2/docs/Geo-Computations.html
20:08:05 <ttt_fff> abrar: hey! reflex-frp! thanks!
20:08:59 <abrar> ttt_fff: np
20:09:01 <codygman> Because of currying, this is true right? (b -> c) -> (a -> b) -> a -> c == (b -> c) -> (a -> b) -> (a -> c)
20:09:48 <jle`> codygman: not because of currying
20:09:53 <moonman> https://www.youtube.com/watch?v=8BtoPuJ55uA
20:09:54 <jle`> but because of the associativity of (->)
20:09:59 <jle`> that's just how (->) associates
20:10:04 <codygman> jle`: Oh, thanks!
20:10:22 <jle`> codygman: it's actually (b -> c) -> ((a -> b) -> (a -> c))
20:10:27 <jle`> if you want to put all the parentheses in
20:11:23 <jle`> codygman: currying would be like saying that a (b -> c, a -> b, a) -> c is "isomorphic" to a (b -> c) -> (a -> b) -> a -> c
20:13:46 <jle`> araujo: thank you for the reference to that package.  it's something i never knew i needed
20:14:22 <bitemyapp> jle`: whihc?
20:14:39 <jle`> https://hackage.haskell.org/package/gps-1.2/docs/Geo-Computations.html
20:14:42 <jle`> heh
20:20:11 <abrar> jle` oh, i didn't realize you were referring to me
20:20:58 <abrar> glad to be of service
20:21:32 <jle`> oh yeah, i meant abrar .  sorry araujo ;_;
20:22:36 <cloj_dev> http://pastebin.com/DzNf9tZV
20:22:58 <cloj_dev> why is this code not working? I got this error : a’ with actual type ‘ComplexNum a0’
20:23:11 <codygman> jle`: Thanks again, that all helped a lot. 
20:23:17 <jle`> np!
20:23:52 <jle`> cloj_dev: you have addComplex :: a -> a
20:23:55 <ReinH> cloj_dev: a -> a can't be the type of addComplex.
20:24:06 <jle`> which means that addComplex can take a value of any type, and return a value of that same type
20:24:08 <cloj_dev> why not?
20:24:10 <moonman> https://www.youtube.com/watch?v=bJwt2CHvH_I'
20:24:12 <moonman> https://www.youtube.com/watch?v=bJwt2CHvH_I
20:24:18 <ReinH> cloj_dev: because you pattern match on (Rec x y)
20:24:20 <jle`> so something of type a -> a should be able to take Ints, Bools, Strings, etc.
20:24:24 <cloj_dev> ah okay
20:24:25 <cloj_dev> right
20:24:33 <jle`> but your function only takes ComplexNum's
20:24:57 <cloj_dev> but this doesn't work either : addComplex :: (ComplexNum a) => a -> a 
20:24:58 <ReinH> A function a -> a must work for every possible type.
20:25:04 <ReinH> ComplexNum is not a typeclass.
20:25:06 <ReinH> It is a type.
20:25:15 <jle`> ComplexNum is not a typeclass :o
20:25:26 <jle`> have you learned about typeclasses yet?
20:25:36 <ReinH> You can remove the type declaration and ask GHC to infer the type for you.
20:25:43 <ReinH> The inferred type will be correct.
20:25:47 <cloj_dev> ah
20:26:08 <cloj_dev> yes, I'm deliberately trying to do it with the type declaration ; I think I know what to do
20:26:16 <jle`> your function takes a ComplexNum a, and returns a ComplexNum a
20:26:17 <Lokathor> moonman, ocremix.org
20:26:31 <ReinH> And if you turn on the warning, GHC will probably also tell you that addComplex is not exhaustive.
20:27:08 <ReinH> it is undefined for the Pol constructor
20:27:55 <cloj_dev> jle`:  thanks :)
20:28:09 <cloj_dev> ReinH: I see now :)
20:58:04 * hackagebot peyotls-codec 0.3.1.1 - Codec parts of Pretty Easy YOshikuni-made TLS library  https://hackage.haskell.org/package/peyotls-codec-0.3.1.1 (YoshikuniJujo)
21:12:58 <slacko1256> does any ghc-pkg or cabal command show the exported modules of a package?
21:13:04 <slacko1256> seems like I'm missing something
21:17:06 <Lokathor> > fromIntegral (maxBound :: Word64) :: Int
21:17:08 <lambdabot>  -1
21:17:12 <kadoban> slacko1256: The usual place to look would be in the haddock docs (without which you can't really do much with it anyway).
21:17:16 <Lokathor> i've found my infinite loop bug
21:19:17 <KaneTW> slacko1256: ghc-pkg describe
21:19:38 <slacko1256> yep, Now I see it
21:19:54 <slacko1256> it was the eshell messing with the ghc-pkg describe output
21:20:15 <slacko1256> thanks KaneTW,kadoban
21:23:05 <Lokathor> so if I have a Word64 and I want to make an Int64 by keeping the same bits and just having GHC read them in a new way
21:23:16 <Lokathor> what's the best way to go about that?
21:29:38 <Lokathor> oh, is that what fromIntegral alraedy does?
21:30:15 <KaneTW> :t fromIntegral
21:30:16 <lambdabot> (Integral a, Num b) => a -> b
21:30:33 <Lokathor> well I know it makes the types match
21:30:45 <Lokathor> but i'd like to know if the bits will match when you go from one to the other
21:30:59 <KaneTW> it should
21:31:01 <Lokathor> > fromIntegral (0 - 2 :: Word64) :: Int
21:31:03 <lambdabot>  -2
21:31:05 <KaneTW> same internal reprsentation
21:31:05 <Lokathor> seems to
21:31:24 <KaneTW> GHC has no distinction between word and int beyond the type system
21:31:37 <Lokathor> oh
21:31:41 <Lokathor> well that's nice to know
21:32:15 <Lokathor> I grew up on Java and Python, so signed vs unsigned has always remained a little spooky in my mind
21:32:18 <jle`> > 0 - 2 :: Word64
21:32:20 <lambdabot>  18446744073709551614
21:32:23 <jle`> neat
21:33:34 <ViCtoRy_> sup
21:33:34 * hackagebot safecopy 0.8.6 - Binary serialization with version control.  https://hackage.haskell.org/package/safecopy-0.8.6 (DavidHimmelstrup)
21:33:45 <Lokathor> jsut writin RNGs ViCtoRy_ 
21:34:18 <Lokathor> turns out you can't just double up the number of bits on your version that outputs 32 bits
21:34:20 <Lokathor> and have it work
21:34:34 <Lokathor> because you'll have forgotten that genRange will mess up
21:35:39 <KaneTW> Lokathor: the word2Int# :: Word# -> Int# primop is literally a nop (along with addr/int conversion, chr# and ord#)
21:36:19 <Lokathor> I had no idea
21:36:53 <Lokathor> I looked into manually using unboxed types the other day, and the doc seemed to say that it's really really restrictive and that GHC will make it unboxed when you compile with -O2 anyway so don't bother
21:37:24 <KaneTW> yes
21:37:42 <KaneTW> most of the time it's not worth it
21:38:09 <KaneTW> there are some cases when you need fine memory control where you want to use them
21:38:28 <KaneTW> https://hackage.haskell.org/package/structs look at the code behind that
21:38:30 <KaneTW> (and weep)
21:39:17 <Lokathor> scroll down randomly
21:39:23 <Lokathor> very first line my eyes focus on: construct = unsafeCoerce# Object
21:39:26 <Lokathor> yeah
21:39:35 <KaneTW> data NullPointerException = NullPointerException deriving (Show, Exception)
21:40:33 <glguy> Lokathor: the particular unsafeCoerce# is going away
21:40:59 <Lokathor> i have no idea what the difference is
21:41:26 <glguy> as in I'm removing it :)
21:45:08 <Lokathor> well i know what "going away" means
21:45:20 <Lokathor> but i don't know what unsafeCoerce does vs unsafeCoerce#
21:45:38 <Lokathor> i thought it was just a "this really is what i say it is, plz trust" function
21:46:28 <glguy> I don't know that there is an unsafeCoerce without the # on it, # is just another letter in this context, it doesn't do anything on its own
21:46:48 <Lokathor> oh
21:46:52 <KaneTW> unsafeCoerce# is the underlying function for unsafeCoerce
21:47:23 <Lokathor> that also makes sense
21:47:50 <KaneTW> (with the difference that uc# works on both * and # kinds and) 
21:48:04 <glguy> The one to use where you can is coerce
21:50:14 <Lokathor> well i've never coerced anything
21:50:36 <KaneTW> it's useful when you have something like
21:50:36 <Lokathor> though i might have used fromIntegral a little more often than i needed to perhaps
21:51:50 <KaneTW> newtype URL = URL Text; getHrefs :: HTML -> [URL]
21:52:14 <KaneTW> and then you have a function that takes [Text] and you want to feed those [URL] into
21:52:33 <KaneTW> you could map but that's O(n)
21:53:53 <KaneTW> with some ghc version type-safe coercion was added which under certain conditions (see docs) determines that A ~R B where ~R is representational equality and adds a Coercible A B instance
21:54:09 <KaneTW> then you can use coerce :: Coercible a b => a -> b
21:54:58 <Lokathor> i thought that newtype stuff was pretty much compiled away
21:55:30 <jle`> it is for the most part, but how would you imagine writing a [Url] -> [Text], or a [Text] -> [Url]?
21:55:41 <jle`> even without newtypes, it's like `map id`
21:55:54 <jle`> map URL, map getUrl, map something
21:56:02 <jle`> which still requires a traversal of a no-op
21:56:14 <liste> jle` GHC's coerce
21:56:31 <jle`> yeah, this was in response to why coerce was needed, heh
21:56:40 <liste> oh, sorry
21:57:03 <liste> just woke up, not enough coffee
21:57:09 <jle`> good morning :)
21:57:19 <liste> thanks :)
22:02:58 <Lokathor> is there a good way for a library to say, "if this package is in the project then compile with these extra files and make these extra instances, otherwise dont' bother"?
22:08:17 <xpilot> is there any way to pattern-match on a data family?
22:08:36 * hackagebot dixi 0.3.0.0 - A wiki implemented with a firm theoretical foundation.  https://hackage.haskell.org/package/dixi-0.3.0.0 (LiamOConnorDavis)
22:10:25 <xpilot> if i have data family D :: * -> *; data instance D Int = DInt; f :: D a -> a; f DInt = 0
22:10:54 <xpilot> that fails
22:12:06 <jle`> yeah...that's not really how those work
22:12:10 <jle`> your best bet is to use singletons, i think
22:12:32 <xpilot> what's special about singletons?
22:13:07 <jle`> oh hm, you might be able to use existential types?
22:13:14 <jle`> er no
22:15:13 <jle`> what do you want to do?
22:15:20 <jle`> in a bigger picture
22:16:39 <xpilot> use singletons as keys in a dependent map
22:18:01 <FreeFull> I bet Rust and Haskell could go really well together
22:18:37 <jle`> xpilot: so how would making a D a -> a help with that?
22:19:08 <jle`> btw, it looks like your D data family is very similar in intent to the Sing data family in the singletons package
22:19:36 <jle`> oh wait, nvm, it's different
22:20:46 <quicksilver> xml-conduit and the underlying xml-types don't seem to have a way to retain file name and line number information?
22:23:26 <ttt_fff> is there something more primitive thatn Data.Aeson ?
22:23:41 <ttt_fff> I want something where I just get a Map of lists of strings to maps or something
22:23:48 <ttt_fff> (I'm dealing with JSOn data that was not encoded with Aeson)
22:24:01 <liste> aeson can do that too
22:24:05 <quicksilver> you can get that representation from aeson
22:24:09 <quicksilver> it's called 'Value' isn't it?
22:24:24 --- mode: ChanServ set -v quicksilver
22:25:45 <ttt_fff> okay
22:25:48 <ttt_fff> how do I do String -> Value ?
22:26:53 <Cale> ttt_fff: toJSON is the most obvious way
22:27:35 <Cale> ttt_fff: Or you could T.pack it and apply the String data constructor.
22:32:57 <ttt_fff> Cale: what is T.pack ?
22:33:09 <Cale> Data.Text.pack
22:33:12 <jle`> hottest rapper of 2015
22:33:20 <Cale> It converts a String to a Text
22:33:48 <lispy> jle`: wrapper*
22:33:58 <jle`> ha ha
22:36:34 <ttt_fff> Cale: how does Data.Text.pack get me String -> Value ?
22:36:52 <Cale> pack :: String -> Text,  String :: Text -> Value
22:37:15 <jle`> ttt_fff: see the String constructor http://hackage.haskell.org/package/aeson-0.10.0.0/docs/Data-Aeson-Types.html#t:Value
22:37:21 <Cale> (String is one of the data constructors of Value)
22:37:24 <jle`> data Value = String Text | ...
22:37:41 <ttt_fff> err but that's not hwa tI want
22:37:51 <ttt_fff> I have a ByteString, which represents a JSOnN, and I want to parse it into a JSON Value
22:37:58 <ttt_fff> I don't wnat to construct a new JSON Value consisting of a single string
22:38:03 <jle`> oh, haha
22:38:19 <jle`> that's definitely something different
22:38:20 <Cale> Well, you probably should have been more specific then :)
22:38:25 <ttt_fff> I apologize.
22:38:37 <ttt_fff> I have a String, representing a JSON, but not something that Data.Aeson outputted. How cna I PARSE this string into a JSON value ?
22:38:49 <abrar> are you sure you want to turn it into a JSON value?
22:38:54 <Cale> decode
22:38:57 <abrar> you don't want to turn it into some haskell data type?
22:39:04 <abrar> some other*
22:39:05 <Cale> decode :: FromJSON a => ByteString -> Maybe a
22:39:21 <ttt_fff> abrar: some friend handed me some json data, which I don't see how it maps to haskell data
22:39:23 <jle`> http://hackage.haskell.org/package/aeson-0.10.0.0/docs/Data-Aeson-Parser.html
22:39:29 <jle`> parse :: Parser a -> ByteString -> Result a
22:39:44 <jle`> Cale's method is probably more expedient, heh
22:39:56 <abrar> if you know the structure of the data you can write a FromJSON instance
22:39:57 <liste> > decode "{'hello': 'world'}" :: Value
22:39:58 <lambdabot>  Not in scope: ‘decode’Not in scope: type constructor or class ‘Value’
22:40:09 <june_> guys is there any other haskell autocompletion plugins than neco-ghc for vim?
22:40:15 <Cale> Yeah, that's another thing. Usually you don't want Value, because it's weird to write a program which wants to decode JSON, but doesn't know what format it's in.
22:40:21 <abrar> and if you don't, you should probably determine it!
22:40:24 <ttt_fff> hmm, I don't see a Map at http://hackage.haskell.org/package/aeson-0.10.0.0/docs/Data-Aeson-Types.html#t:Value .... so how is osmethign like {'hello': 'world} even represented as a JSON value ?
22:40:42 <jle`> ttt_fff: Object is a type synonym for hashMap
22:40:44 <Cale> Object
22:40:49 <jle`> *HashMap
22:40:53 <ttt_fff> jle`, Cale: ah, thanks!
22:41:02 <Cale> I wonder why it's HashMap
22:41:15 <ttt_fff> abrar: yeah, either that, or I should kidnap my friend's family and force him to hand me haskell data types instead of json
22:41:27 <jle`> Value is nice to inspecting some random json you got from somewhere as a Map/json-structured thing
22:41:39 <abrar> i haven't tried that ... software engineering methodology
22:41:40 <jle`> but in the real world you'd write a Haskell data structure that is what you want, and write a FromJSON instance
22:42:02 <quicksilver> there is a middle way
22:42:12 <jle`> ttt_fff: you can still *get* JSON, but instead of convering the JSON to a HashMap and then converting that HashMap into a value that you want to use, you'd just convert that JSON directly into the value you want to use
22:42:16 <quicksilver> there are builtin FromJSON instances for built-in haskell types
22:42:32 <quicksilver> so you can decode directly to a type like [[Map String Int]]
22:42:38 <quicksilver> if you happen to know that's the shape of your data
22:42:44 <jle`> ah yes, that too :O
22:42:58 <Cale> ttt_fff: Well, the point is, you're getting JSON from your friend's service, but the *rest of your program* is presumably not going to want to treat the response as an arbitrary Value.
22:43:06 <quicksilver> but there is no built-in support for choice/Either
22:43:19 <quicksilver> so any time you need to encode a choice type thing you will need your own intance
22:43:22 <quicksilver> AFAIK
22:43:31 <Cale> ttt_fff: Presumably your friend's service isn't sending you just any JSON value, but some structures built up in a particular way
22:43:31 <jle`> you should be using your own type and writing your own instance
22:43:59 * hackagebot opentheory-stream 1.49 - Infinite stream types  https://hackage.haskell.org/package/opentheory-stream-1.49 (JoeHurd)
22:44:01 * hackagebot opentheory-probability 1.52 - Probability  https://hackage.haskell.org/package/opentheory-probability-1.52 (JoeHurd)
22:44:03 * hackagebot opentheory-bits 1.69 - Natural number to bit-list conversions  https://hackage.haskell.org/package/opentheory-bits-1.69 (JoeHurd)
22:44:05 * hackagebot opentheory-divides 1.66 - The divides relation on natural numbers  https://hackage.haskell.org/package/opentheory-divides-1.66 (JoeHurd)
22:44:07 * hackagebot opentheory-byte 1.128 - Bytes  https://hackage.haskell.org/package/opentheory-byte-1.128 (JoeHurd)
22:44:31 <liste> quicksilver what if there's both deeply and shallowly nested objects? like "{'a': 'b', 'c': {'d': {'e': 'f'}}}
22:44:45 <liste> is it just Maybes then?
22:44:57 <jle`> that would fail to parse as a Map String Int
22:45:06 <Cale> ttt_fff: and what you want to do is define a type which captures those structures, and provide a way to turn aeson Value structures into that, providing a FromJSON instance.
22:45:36 <ttt_fff> abrar , jle` , Cale: okay, I',m convinced. I'm (1) defining my own haskell type and (2) writing my own instancce FromJSON ... 
22:45:50 <jle`> for exploratory purposes, parsing it into a Value is fine
22:46:08 <jle`> but writing an actual program you should probably be using your own type
22:47:23 <quicksilver> liste: that's what I meant by choice
22:47:38 <quicksilver> liste: that is (perhaps) Map String (Either String Object), or something
22:48:30 <quicksilver> liste: but, no standard instance does choice like that.
22:48:56 <liste> ok, so my own instances it is then (:
22:48:58 <quicksilver> the standard instances only work for very simple consistent formats.
22:49:09 * hackagebot opentheory-parser 1.160 - Stream parsers  https://hackage.haskell.org/package/opentheory-parser-1.160 (JoeHurd)
22:49:11 * hackagebot opentheory-unicode 1.142 - Unicode characters  https://hackage.haskell.org/package/opentheory-unicode-1.142 (JoeHurd)
22:49:13 * hackagebot opentheory-fibonacci 1.72 - Fibonacci numbers  https://hackage.haskell.org/package/opentheory-fibonacci-1.72 (JoeHurd)
22:49:15 * hackagebot opentheory-prime 1.85 - Prime natural numbers  https://hackage.haskell.org/package/opentheory-prime-1.85 (JoeHurd)
22:49:17 * hackagebot arithmetic 1.2 - Natural number arithmetic  https://hackage.haskell.org/package/arithmetic-1.2 (JoeHurd)
22:49:28 <quicksilver> but really this is no hardship - as soon as you work out how to represent your data in Haskell (which you'd need to do anyway)
22:49:34 <quicksilver> the FromJSON instnace is hte easy bit
22:53:28 <lpaste> glguy pasted “Template Haskell for structs” at http://lpaste.net/143325
22:53:59 * hackagebot opentheory-primitive 1.8 - Haskell primitives used by OpenTheory packages  https://hackage.haskell.org/package/opentheory-primitive-1.8 (JoeHurd)
22:54:01 <glguy> regarding the topic of the structs library that came up earlier
22:54:30 <glguy> I implemented a TH interface for the library as an alternative to manually building up the various accessors and initializers
22:57:23 <Lokathor> so my RNG broke after printing 100 numbers
22:57:29 <Lokathor> after like 50 it just got stuck on some value
22:58:04 <Lokathor> so to check that the 32 bit version didn't do the same, i added some 0s and hit enter. but I think i added too many and now it's printing like 10 million numbers
22:58:22 <Lokathor> but it's really mesmerizing
23:00:31 <jle`> Lokathor: does it feel like cat /dev/urandom | hexdump -C ?
23:01:15 <Lokathor> yeah, they're all 1 to 10, and so the occasional 10 is enough to offset each line from the last
23:01:39 <Lokathor> and it forms sorta flame patterns that "rise up" from the base of the terminal and flicker around
23:04:19 <Lokathor> i think for the 64-bit version i'll just run two 32-bit ones together
23:07:45 <Lokathor> (260.38 secs, 44,271,046,248 bytes)
23:07:48 <Lokathor> thanks ghci
23:08:51 <Lokathor> (also that time is clearly wrong, maybe it doesn't count the print time only the processing time?)
23:29:59 <Lokathor> done :3
23:31:01 <davidar> lol, just got a "My brain just exploded" error
23:31:17 <davidar> from ghc
23:31:57 <Lokathor> oh my
23:31:59 <Lokathor> do tell
23:32:35 <liste> it's fun (:
23:33:28 <davidar> apparently you can't use pattern matching with GADTs, it's telling me to use case expressions instead :)
23:35:06 <liste> AFAIK it's specifically for existentials (which can be expressed with GADTs)
23:36:10 <merijn> davidar: You can, use pattern matching and GADTs else like 80% of my code wouldn't compile
23:36:23 <liste> @let data Ex where Ex :: a -> Ex
23:36:25 <merijn> liste: You can pattern match existentials just fine too
23:36:25 <lambdabot>  Defined.
23:36:54 <ttt_fff> when dealing with Data.Aeson, what is easiest way for String -> Double ?
23:36:57 <davidar> merjin: it seems to be talking about pattern matching in let-bindings in particular
23:37:26 <merijn> davidar: Existential unpacking in a let sounds like it could mess up things, yes
23:37:29 <jle`> ttt_fff: that depends...what do you want that String -> Double to do?
23:37:44 <ttt_fff> jle`: to read the string as a double
23:37:50 <merijn> davidar: Basically, anytime you unwrap an existential you *have* to consume it's contents immediately in that scope
23:38:03 <jle`> ttt_fff: and the string is a double encoded in json spec?
23:38:09 <ttt_fff> no, it's a string
23:38:18 <ttt_fff> the json is {"foo": "12.3"}
23:38:24 <ttt_fff> it is NOT {"foo": 12.3}
23:38:56 <liste> > let Ex a = (Ex 14) in a
23:38:58 <lambdabot>      My brain just exploded
23:38:58 <lambdabot>      I can't handle pattern bindings for existential or GADT data constructors.
23:38:58 <lambdabot>      Instead, use a case-expression, or do-notation, to unpack the constructor.
23:39:04 <davidar> merjin: at the risk of sounding stupid, why's that?
23:39:15 <jle`> ttt_fff: i mean, how is the double encoded?
23:39:26 <jle`> is it a JSON-spec double, or a Haskell-spec double?
23:39:27 <liste> davidar what would be the type of `a' in the expression I just gave to lambdabot?
23:39:30 <ttt_fff> jle`: as it would from "show"
23:39:35 <jle`> if you're expecting a Haskell spec double then you can just use readMaybe
23:39:36 <profsimm> Does anyone know a RPC system that classifies remote calls as deterministic or not, atomic or not, effectful or not etc.
23:39:36 <ttt_fff> jle`: hmm, I actually have no idea
23:39:39 <ttt_fff> it's just a decimal number
23:39:40 <jle`> from Text.Read
23:39:50 <jle`> or read from prelude if you're feeling on the wild side
23:40:53 <ttt_fff> jle`: noted, thanks
23:40:55 <davidar> liste: Num a => a?
23:41:02 <merijn> davidar: I'm not 100% familiar with the technical details, but it boils down too it's really hard to ensure nothing nothing goes wrong otherwise
23:41:12 <jle`> ttt_fff: aeson has a parser for a json-spec double
23:41:25 <jle`> ttt_fff: and you'd use it the same way you'd parse a Value, or anything else
23:41:35 <davidar> merijn: fair enough
23:41:36 <merijn> davidar: No, as soon as you wrap it with Ex the fact that it's a number is thrown away and can't be recovered
23:42:01 <merijn> davidar: That's the problem, when you match "Ex a" you can't ever figure out the type of 'a'
23:42:44 <jle`> brain exploded errors are cute, i remember chuckling the first time i saw it.  that is, after i calmed down from my panic attack
23:43:00 <jle`> luckily they're pretty straightforward to fix
23:43:59 <jle`> > case (Ex 14) of Ex a -> undefined     -- brain not exploded
23:44:00 <lambdabot>  *Exception: Prelude.undefined
23:44:05 <profsimm> Does anyone know a RPC system that classifies remote calls as deterministic or not, atomic or not, effectful or not etc.
23:44:06 <profsimm> I know this sounds vague but I'm trying to get as broad an answer as possible, because I can't believe I can't find nything like this.
23:44:09 <merijn> Simplest solution is usually using CPS for existentials
23:45:08 <davidar> merijn: and the problem is that GADTs implicitly give you existentials?
23:45:22 <liste> davidar only some GADTs
23:45:36 <jle`> of course the main problem with liste 's fragment isn't the let binding brain exploding part, but the fact that the result is a.  once you fix the brain exploding error, you still can't do that
23:45:56 <jle`> i wouldn't really call it a "problem" per se
23:46:00 <davidar> mind if I describe what I'm trying to write, and someone can tell me that I needn't bother because somebody has already written it?
23:46:08 <liste> @let data ShowBox = Show a => a -> ShowBox
23:46:08 <lambdabot>  Parse failed: Illegal data/newtype declaration
23:46:14 <liste> @let data ShowBox where Show a => a -> ShowBox
23:46:14 <lambdabot>  Parse failed: Parse error: a
23:46:28 <liste> @let data ShowBox where ShowBox :: Show a => a -> ShowBox
23:46:30 <lambdabot>  Defined.
23:46:44 <liste> > case (ShowBox 14) of ShowBox a -> a
23:46:45 <lambdabot>      Couldn't match expected type ‘t’ with actual type ‘a’
23:46:45 <lambdabot>        because type variable ‘a’ would escape its scope
23:46:45 <lambdabot>      This (rigid, skolem) type variable is bound by
23:46:58 <jle`> rigid skolem errors are also extremely scary the first few times you see them
23:47:01 <jle`> until you understand it
23:47:13 <jle`> i remember getting an actual heart attack
23:47:40 <jle`> but i'm sure nobody doesn't agree that GHC's error messages could use some work, heh
23:47:56 <liste> davidar go ahead (:
23:47:57 <jle`> > case ShowBox 14 of ShowBox a -> show a
23:47:58 <lambdabot>  "14"
23:48:17 <exio4> jle`: well, lots of type errors become scary when you use lots of extensions
23:48:22 <dolio> merijn, davidar: It's more a combination of, 'we want it that way,' and, 'what would the types be?'
23:48:24 <merijn> davidar: GADT functionality is a superset of existentials, but this problem only happens if your GADT *is* existential
23:48:33 <jle`> exio4: yeah, but this one is unnecessarily scary
23:48:44 <jle`> (rigid, skolem) doesn't really add anything to understanding the error
23:48:49 <NGC_6205> complete newbie trying to make sense of things: what is meant by => in type definitions of functions as opposed to -> ? I can't seem to find a definition
23:49:01 <jle`> NGC_6205: do you know what typeclasses are?
23:49:24 <davidar> liste: so, I'm basically trying to write a simple array datatype (for a DSL) with an interface similar to repa or accelerate
23:49:33 <liste> davidar lpaste?
23:49:55 <merijn> NGC_6205: => is a (typeclass) constraint, I prefer to explain them as "type level conditions", i.e. "foo :: Show a => a -> Int" could be read as "IF 'a' is an instance of 'Show' THEN 'foo :: a -> Int' ELSE type error"
23:50:14 <davidar> liste: my code's awful atm, mind if I just explain what I'm trying to do? :)
23:50:26 <liste> no (: so what'd you put in that array?
23:50:43 <NGC_6205> ah, I think that makes sense
23:50:59 <exio4> merijn: can I call them implicit parameters? :p 
23:51:17 <merijn> exio4: :p
23:51:20 <liste> implicit parameters are another thing, but rarely used
23:51:25 <davidar> liste: so the array basically just contains the dimensions (as a snoc list) and a function that maps multidimensional indices to elements
23:51:36 <merijn> liste: To be fair, GHC compiles both of them to the same thing
23:51:37 <davidar> and I'm trying to make it an instance of Applicative
23:51:45 <davidar> so that I can write things like
23:52:09 <exio4> calling them implicit parameters is just because they can be seen as parameters deduced by the compiler
23:52:22 <davidar> (\x y -> x + 2*y) <$> range 10 <*> range 20
23:52:50 <davidar> which will translate to Array (Z :. 20 :. 10) (\x y -> x + 2*y)
23:52:55 <NGC_6205> merijn: so eg. in the definition of (+), it is checking that a is a number?
23:54:20 <davidar> liste: but I don't want the shape to be in the datatype, because that would restrict <*> to arrays of the same shape
23:54:33 <merijn> NGC_6205: Yes, this is the way haskell provides something kinda like overloading (i.e. allowing + to work for multiple types)
23:54:40 <davidar> but I need to look at the shape and the function to work out what the type of the elements in the array is
23:54:55 <liste> merijn cool (: didn't know that
23:55:26 <jle`> davidar: is ther eno Applicative instance for Array?
23:55:29 <jle`> interesting
23:55:39 <jle`> wait let me try to remember repa
23:55:51 <merijn> liste: Typeclasses (unless they get specialised) get compiled as an extra record parameter to the function containing the typeclass' functions. Implicit parameters get compiled to an extra record parameter containing the implicit parameters :)
23:56:18 <quicksilver> can be compiled.
23:56:26 <davidar> jle`: it's not really an Array, it's just a function paired with an explicit domain
23:56:26 <quicksilver> that's how GHC happens to do it. It's not hte only way.
23:56:27 <exio4> he's talking about GHC
23:56:37 <merijn> Well, obviously this an implementation detail
23:57:01 <merijn> Once we're talking about "X is compiled as Y" it's always an implementation detail :)
23:57:40 <davidar> liste: merijn: but now I'm hitting all these issues with existential types :)
23:58:00 <davidar> and whatever skolem is
23:58:36 <liste> davidar can you make your array type parametric so you get rid of the existential fields?
23:59:00 <liste> or then use CPS, as merijn suggested
23:59:25 <jle`> ah, yeah, i guess using existential types as continuations rather than existential data types makes the error a little more understandable.  but i think GADTs add a nice layer of expressivity that CPS style can't
23:59:33 <davidar> liste: but then Applicative constrains those parameters to be identical for <*>, which isn't what I want
23:59:43 <merijn> davidar: skolem basically means "existential type is trying to escape the unwrapping scope"
23:59:45 <liste> yeah :/ that's a problem
