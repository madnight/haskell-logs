00:04:14 <pyon> I can see how a zipper (not necessarily for lists) is copointed - the `extract` operation simply returns the focused element. But how exactly are zippers comonads? What should `extend` do?
00:09:12 <nshepperd> pyon: a zipper with n elements has n possible focusses, right?
00:09:38 <nshepperd> iirc, extend for zippers replaces each element by the zipper focussed at that element
00:09:48 <pyon> Ah!
00:12:09 <nshepperd> which is very nice for zippers, because it also preserves the meaning of stepLeft and stepRight
00:12:32 <nshepperd> extract . stepLeft . extend = stepLeft
00:12:40 <pyon> :-O
00:13:33 <dlight> what zipper package should I use?
00:17:10 <nshepperd> I think you could actually also write a legal definition of extend that had extract . stepLeft . extend = stepRight, but it would be a bit messy and have no obvious interpretation like 'replace each element by its zipper'
00:19:09 <pyon> nshepperd: Ah, okay, thanks!
00:19:32 <pyon> Just as the case with monads, it turned out that `extend` is easier to understand than `cobind`. :-)
00:19:45 <nshepperd> hehe, yeah
00:20:04 <gfixler> so I'm playing a bit with some FRP ideas, after watching another Conal talk
00:20:08 <fizruk> :t extend
00:20:10 <lambdabot> Not in scope: ‘extend’
00:20:11 <gfixler> I have this: newtype Image a = Image { runImage :: Coord -> a }
00:20:27 <pyon> fizruk: Comonad w => w a -> w (w a)
00:20:29 <gfixler> Coord is just (Double, Double)
00:20:40 <fizruk> pyon: that's duplicate
00:20:52 <fizruk> pyon: extend is exactly cobind
00:20:53 <fizruk> :t Control.Comonad.extend
00:20:55 <lambdabot> Control.Comonad.Comonad w => (w a -> b) -> w a -> w b
00:20:56 <gfixler> but I'm running into trouble defining a Monad instance, because the Coord gets in the way of the a
00:20:57 <pyon> Oh.
00:21:01 <fizruk> :t Control.Comonad.duplicate
00:21:02 <lambdabot> Control.Comonad.Comonad w => w a -> w (w a)
00:21:05 <pyon> Wait, wait....
00:21:08 <nshepperd> oh, so it is
00:21:11 <nshepperd> haha
00:21:19 <pyon> I was thinking for some reason about duplicate, then.
00:21:23 <Hijiri> gfixler: what about the normal readerish monad for functions?
00:21:29 <nshepperd> 'extend id' :)
00:21:35 <gfixler> Hijiri: yeah, that's what I want
00:21:55 <gfixler> Hijiri: I guess I'm not quite sure what I do with my custom type to make it a Reader
00:22:09 <gfixler> I wanted to enforce (Double, Double), for simplicity, for now
00:22:47 <nshepperd> instance MonadReader Coord Image?
00:23:26 <gfixler> nshepperd: that might be it - I haven't looked at MonadReader yet
00:23:42 <nshepperd> well, that's just the Reader interface
00:24:44 <gfixler> nshepperd: is this an automated path, or am I still supposed to define the FAM myself?
00:25:03 <nshepperd> yeah you still have to define the monad instance and everything
00:25:35 <gfixler> nshepperd: so is MonadReader the thing that lets me say "Reader, but specialized for my type?"
00:26:06 <nshepperd> MonadReader provides functions like 'ask' and 'local'
00:26:36 <nshepperd> if you want to make it automated, you could use GND and just do 'deriving (Functor, Applicative, Monad)'
00:26:41 <nshepperd> I think that would actually work
00:26:53 <gfixler> I think so, too, but I wanted to do that after I muck about for awhile
00:26:53 <nshepperd> since '(->) Coord' is already a monad
00:28:12 <nshepperd> well, I would write my monad instance like 'm >>= f = Image $ \c -> ...'
00:28:28 <nshepperd> and then you can use the c which is a Coord to get at whatever 'a' you need
00:29:03 <gfixler> nshepperd: that's how I wrote it
00:29:19 <gfixler> I just tried the GND thing, and it didn't upset the compiler
00:35:48 * hackagebot linguistic-ordinals 0.1.0.1 - Express Integral types as linguistic ordinals (1st, 2nd, 3rd, etc)  https://hackage.haskell.org/package/linguistic-ordinals-0.1.0.1 (ElliotRobinson)
00:47:53 <kamatsu> I thought ghc mod was working with stack
00:47:59 <kamatsu> but i just keep running into problems
00:49:01 <kamatsu> i want to use only stack-installed GHC's, but ghc-mod's cabal-wrapper thing complains if it can't find a ghc on the path, and if i add it to my path i get a different error
00:49:11 <kamatsu> this time it seems to be stack-related
00:57:29 <Copperis> I've installed haskell platform on windows and now installed Leksah. It's asking me where are the haskell sources for packages
00:57:47 <Copperis> does anyone know what is the default directory for the sources?
01:08:35 <gfixler> Copperis: https://downloads.haskell.org/~ghc/6.10.1/docs/html/users_guide/install-windows.html
01:08:53 <gfixler> that seems to say things are in: "Start/All Programs/GHC/ghc-version"
01:09:06 <gfixler> c:/ghc/ghc-version
01:12:57 <Copperis> gfixler, I used haskell platform that bundles ghc, so there's no c:/ghc for me
01:13:12 <gfixler> Copperis: oh, right
01:13:19 <Copperis> theres a dir in haskell platform's folder called "lib"
01:13:29 <Copperis> contains all sorts of stuff
01:14:31 <Copperis> ok, I think leksah was asking for any custom packages that I downloaded by hand
01:14:38 <Copperis> I have none, so I'll skip that part
01:41:35 <concept3d> Hello all, both Aeson and Lens have the operator .= they seem to collide, I suppose if I used qualified imports using .= will ugly how can I avoid this
01:44:42 <phadej> concept3d: split your module into two?
01:44:54 <MarcelineVQ> if you only ever use one you can use hiding to avoid importing the other
01:45:10 <phadej> ^ :+1:
01:45:19 <MarcelineVQ> `import Prelude hiding (zip)` won't bring zip into scope for example
01:46:31 <concept3d> phadej: well that is what I am doing now, but it doesn't make sense when they are not actually not two modules
02:05:52 * hackagebot codex 0.4.0.4 - A ctags file generator for cabal project dependencies.  https://hackage.haskell.org/package/codex-0.4.0.4 (aloiscochard)
02:07:02 <randallb> Is there a GHC 7.10 way to use old prelude (i.e. without FTP)?
02:20:47 <hc> re
02:31:28 <fizruk> is there a way to work with enum types with opaleye?
02:59:46 <SX> Hi! Could someone tell me what drawbacks I'd face if switching to Vector from List?
03:04:16 <phadej> SX: it depends what you are doing with the data in List/Vector
03:11:37 <Jinxit> if I want to construct a large string or list, but there is no calculation to be done while doing so, is the Writer monad the right tool or should I just use a list of strings?
03:12:10 <Jinxit> constructing it through recursive function calls
03:12:56 <liste> Jinxit IO or non-IO?
03:13:02 <Jinxit> non-IO
03:13:26 <Jinxit> well the result will be printed, but it deals with non-IO data
03:13:32 <jle`> Writer is probably the wrong tool, it doesn't really make too much sense
03:13:35 <liste> I'd go with Data.TExt.Lazy
03:13:53 <Jinxit> basically I have an AST and want to output code
03:15:51 <Jinxit> Lazy looks good
03:16:30 <liste> String is bad for most real-world tasks
03:19:42 <zipper> I get the following warning from hackage "Exposed modules use unallocated top-level names: Devel Main"
03:19:54 <zipper> https://hackage.haskell.org/package/wai-devel-0.0.0.1/candidate
03:20:05 <zipper> I don't understand that
03:20:39 <zipper> Also the haddocks didn't atutomatically build?
03:21:42 <SX> phadej: it's 1 time create, many times read (no resize after full init)
03:22:31 <nshepperd> list is bad for random access, and also takes up more memory
03:23:05 <nshepperd> WORM is basically what Vector is for
03:23:27 <quicksilver> if you care about efficiency, Text Builder is not bad
03:23:35 <quicksilver> it's kind of like the Text version of DList
03:23:36 <SX> and it's bad for streams also. I need to read some binary data with binary package's Get.
03:23:37 <quicksilver> if you squint a bit
03:23:46 <brnhy> zipper: https://mail.haskell.org/pipermail/cabal-devel/2012-September/009059.html - some information
03:23:57 <quicksilver> just join all your builders together with <>
03:24:12 <quicksilver> you can probably output your entire AST with one call to a fold
03:24:40 <quicksilver> :t Control.Lens.Plated.para
03:24:41 <lambdabot> Plated a => (a -> [r] -> r) -> a -> r
03:24:46 <SX> So it's read only once
03:25:25 <quicksilver> if you want random access read many Vector seems a solid choice
03:25:34 <SX> Not that much data though.
03:25:41 <zipper> brnhy: I don't see how that answers my questions.
03:25:48 <quicksilver> if it's not much data you have probably already over-thoguht it :)
03:25:56 * hackagebot cgrep 6.5.8 - Command line tool  https://hackage.haskell.org/package/cgrep-6.5.8 (NicolaBonelli)
03:25:56 <quicksilver> doesn't matter what you do with not-much-data.
03:25:58 <SX> And what about appends? One vector to another
03:26:09 <quicksilver> vector append is fine but it does copy
03:26:12 <SX> For list it's expensive
03:26:18 <brnhy> You've use a non-existent top-level module namespace
03:26:29 <jle`> might not be expensive for list depending on what you do in the end
03:26:31 <quicksilver> vector append is asymptotically worse than list append :P
03:26:39 <quicksilver> although its constant factors are much better
03:26:51 <SX> It's not much, but it repeats A LOT. And it should be as efficient as possible
03:26:54 <quicksilver> Data.Sequence has faster append
03:28:33 <phadej> if your creation and consumption phases are clearly separated, and you do consume many times (so you cannot fuse intermediate data), it might make sense to use different data structures for those phass
03:28:35 <SX> So in the end I need to parse Binary data in some list (lazily) and then merge this lists together. As fast as possible.
03:28:43 <phadej> i.e. Builder and Text for example
03:28:44 <zipper> brnhy: Oh it expected the top level module name to have those names? Why is this important?
03:29:13 <zipper> brnhy: I get it now.
03:29:20 <quicksilver> SX: and what are the constraints on the resulting type
03:29:26 <quicksilver> resulting structure, rather
03:29:31 <quicksilver> how wll you acces it thereafter?
03:30:11 <zipper> brnhy: So I should've said something like Data.Compile instead of Devel.Compile.
03:30:24 <zipper> Well that wouldn't have been right in my case.
03:30:47 <brnhy> Yeah, well, since it's a wai app/addon maybe follow their namespace?
03:31:02 <brnhy> Network.Wai.<etc>? Or something
03:31:26 <SX> I won't alter it, only append and split. Linear access mostly.
03:31:45 <zipper> brnhy: I see :) Thanks.
03:31:48 <brnhy> It's just a curation thing I guess, to keep things somewhat tidy etc . As for your documentation - the docs are built by a worker, and usually appear quite a bit later, particularly if Hackage has quite a few uploads enqueued.
03:31:51 <SX> And use it's length
03:32:44 <SX> It's mostly intermediate structure, which should be really fast to construct.
03:33:01 <zipper> brnhy: So I guess I should just wait for the docs to appear then. It's been almost two days. Weird.
03:33:09 <brnhy> That does seem overly long ..
03:37:27 <phadej> SX: if you want fast append and fast random lookup... you wish for something which can be done, but probably isn't.
03:37:44 <SX> Not random
03:38:00 <srenatus> hi there. has anyone used dyre with a case insensitive filesystem?
03:38:04 <SX> Just fast append and split. And memory efficient =)
03:38:08 <phadej> ah, sorry, linear access.
03:38:22 <phadej> then you can use tree of some kind
03:38:28 <phadej> with vectors in the leafs/nodes
03:38:43 <nshepperd> SX: you can concatenate many lists efficiently
03:38:46 <nshepperd> in linear time
03:40:20 <SX> Well... Then can I construct vector lazily with stream?
03:41:25 <SX> I don't actually know how many elements I'd write until I read all stream
03:42:03 <SX> But it's one-pass
03:42:42 <phadej> SX: vector is continuos memory, so you have to know size in advance.
03:43:32 <phadej> SX: but if you have conservative heuristic for size, then you can use Vector
03:43:39 <phadej> http://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Fusion-Bundle-Size.html#t:Size
03:44:32 <phadej> you can have `Unknown` as well, but then fusion framework may copy the data while constructing it
03:45:27 <Jinxit> how do I do something like "foo " ++ bar ++ " baz" with Text.Lazy?
03:45:47 <SX> well, I can guess max array size
03:45:53 <phadej> Jinxit: <>
03:46:05 <Jinxit> I knew I was missing something simple
03:46:07 <Jinxit> thanks
03:46:35 <phadej> Jinxit: it's called Text.append also
03:46:42 <phadej> but <> works for String and Text
03:46:58 <Jinxit> so I need to pack each literal?
03:47:01 <asthasr> So, I'm reading the paper "Generalizing Monads to Arrows," and I went online looking for practical examples of arrows, and about 90% of what I find is people talking about how terrible arrows are
03:47:16 <phadej> Jinxit: no, use OveloadedStrings
03:47:17 <asthasr> Is there a good, lucid examination of why they are so bad? Vague "At least it's not as bad as arrows" is frustrating
03:47:26 <phadej> OverloadedStrings*
03:47:36 <SX> phadej: I need to read Snmp packet (ASN1 encoded objects) as efficiently as possbile. ASN1 library for haskell is slow.
03:47:53 <phadej> SX: I'm not familiar :(
03:48:02 <barrucadu> asthasr: I don't get the hate for arrows, hxt has an arrow-based interface for XML parsing and I found it very nice to work with
03:48:50 <asthasr> barrucadu: Neither do I at this point, because reading the paper and using GHCI, they seem sensible. That's why I'm looking for the counterpoint :)
03:49:30 <quicksilver> the thiing about arrows is that there are very few interesting examples of actual, general arrows.
03:49:39 <Jinxit> phadej: cool, thanks
03:49:39 <quicksilver> they're pretty much all just Kleili m
03:49:49 <quicksilver> all the HXT stuff is Kleisli m
03:50:11 <quicksilver> but that doesn't mean it's not a convenient way to express queries and transformations and HXT has a nice set of combinators
03:50:15 <SX> phadej: I know how to read the bytestring stream (with Binary.Get), but don't know how to store it efficiently =)
03:52:32 <asthasr> Ah, so it's more of a "this is complex and has remained unfamiliar due to lack of generality?"
03:52:48 <asthasr> I also gather that the GHC arrow extension is not viewed favorably
03:53:24 <quicksilver> asthasr: it's remained unfamiliar due to the lack of exciting/generally widely used examples.
03:53:27 <quicksilver> IMO
03:53:44 <quicksilver> HXT is the best example of using arrow notation in an interesting way that I have see
03:54:06 <quicksilver> look at getTeams1 here - https://wiki.haskell.org/HXT/Practical/Simple2
03:54:22 <quicksilver> it's interesting how two of the arrows "start at" l and then two of them "start at" divi.
03:54:38 <quicksilver> ...but it is all just sugar for composing functions over tuples
03:54:51 <quicksilver> no magic here, just functions - but it can be convenient notation.
03:55:56 <asthasr> That is nice.
03:55:57 <phadej> SX: if you just construct the value in `Get` monad, it will be effecient
03:56:19 <quicksilver> phadej: the Put monad, perhaps?
03:56:46 <asthasr> quicksilver: I think that my lack of disgust at the syntax may be because I have been doing algorithm problems and ended up passing around tuple types everywhere, so using tuples doesn't seem that odd to me at the moment
03:57:07 <SX> quicksilver: Get, it's "read from stream and convert to my data"
03:57:16 <quicksilver> well actually it hides a lot of the tuples, asthasr 
03:58:05 <quicksilver> asthasr: what's really happening there is that (leagName,divi) is tupled up, and the it composes 'on the right' so at the next level (leagName,(diviName,team)) are tupled up
03:58:14 <SX> phadej: and just construct the list?
03:58:24 <quicksilver> then it goes to (leagName,(diviName,teamName))
03:58:39 <quicksilver> and the gets "re-tupled" to make the return
03:58:57 <quicksilver> and that's with me deliberatlely missing things out from the tupling that I know aren't used again.
03:59:38 <phadej> SX: I'm a bit lost, but you can construct whatever you need
04:00:37 <asthasr> quicksilver: It makes sense.
04:01:10 <quicksilver> asthasr: yeah. It's just a syntax for applying functions to aprts of tuples, including ones which 'split-up' the tuples into more pieces, and 'put them back together'
04:01:25 <quicksilver> asthasr: but, what is a bit unsatisfying about the abstraction is it was *supposed* to be about so  much more than functions
04:01:33 <happy0> omgzhai2u
04:01:40 <quicksilver> asthasr: but in practice the convincing examples are, actually, just functions.
04:01:41 <SX> phadej: okay, thanks!
04:01:45 <happy0> woops, wrong buffer =p
04:01:56 <quicksilver> time to change your passwords happy0 :)
04:02:13 <happy0> quicksilver: haha :D
04:02:48 <quicksilver> actually I suddenly think I could write a better arrow tutorial
04:02:54 <quicksilver> no tuits for that though
04:04:11 <mtesseract> Hi. I was wondering: is there any canonical way to convert e.g. Doubles to Rationals without this annoying loss of precision (toRational 0.1 => 3602879701896397 % 36028797018963968, etc.)? I have noticed that Numeric.readFloat seems to be able to parse strings like "0.9" correctly into Rationals, but I think it would be weird to first convert a Double into a String just to be able to convert it into a 
04:04:17 <mtesseract> Rational afterwards.
04:05:03 <quicksilver> mtesseract: the precision was already lost when you made 0.1 into a Double
04:05:14 <quicksilver> mtesseract: why did you need to use Double?
04:05:50 <asthasr> quicksilver: A tutorial would be great, but I completely understand the lack of tuits.
04:06:51 <mtesseract> quicksilver: But "0.1 :: Double" evaluates to 0.1?
04:08:14 <quicksilver> mtesseract: 0.1 :: Double is not the number '0.1'
04:08:28 <quicksilver> it is just as close as you can get to 0.1 with the limitations of floating point binary.
04:08:32 <nshepperd> it prints as 0.1 because it rounds when printing, I assume
04:08:38 <quicksilver> as nshepperd says
04:09:02 <quicksilver> there is a long-standing convention to round binary floating point when printing to something like 1 decimal place less than it's technically capable of
04:09:03 <mtesseract> quicksilver: I'm not necessarily forced to use Double, so in fact I am considering to change my program. My program contains a lot of constants (which I could convert to Rationals by hand). Plus, my program has to parse user-provided Strings containing numbers, so there I could use the readFloat approach.
04:09:09 <mtesseract> I see!
04:09:19 <quicksilver> you don't actually need readFloat, read is enough
04:09:26 <quicksilver> > (read "0.1") :: Rational
04:09:28 <lambdabot>  *Exception: Prelude.read: no parse
04:09:32 <quicksilver> !
04:09:37 <quicksilver> ok you need readFloat
04:09:39 <quicksilver> that's odd :)
04:09:41 <mtesseract> :-)
04:11:02 <quicksilver> converting oyur constants should merely be a case of setting their types tho
04:11:06 <quicksilver> > 0.1 :: Rational
04:11:08 <lambdabot>  1 % 10
04:11:19 <mtesseract> Right!
04:11:22 <quicksilver> > [0.1,0.25,0.125,0.79835] :: [Rational]
04:11:23 <lambdabot>  [1 % 10,1 % 4,1 % 8,15967 % 20000]
04:11:44 <mtesseract> Nice. Ok, seems that trying to avoid Double is the way to go here.
04:11:55 <mtesseract> Thanks
04:13:39 <asthasr> mtesseract: Trying to avoid Double is the way to go everywhere :(
04:13:54 <asthasr> (Said tongue-in-cheek, but also completely serious.)
04:14:21 <quicksilver> @quote floating.*friend
04:14:21 <lambdabot> No quotes match. My mind is going. I can feel it.
04:14:28 * quicksilver ponders
04:14:39 <quicksilver> @quote mantissa
04:14:39 <lambdabot> quicksilver says: <jatqceer> i love them.  Double is my friend <quicksilver> You think he is, sure <quicksilver> he says nice things about you <quicksilver> but one day, when your back is turned, he will stab you in the back with a mantissa
04:14:50 <nesqi> @type length
04:14:51 <lambdabot> Foldable t => t a -> Int
04:14:56 <mtesseract> :)
04:15:35 <nesqi> lamdabot is up to date =)
04:15:46 * quicksilver nods :)
04:15:57 <quicksilver> > length (4,5)
04:15:58 * hackagebot docker 0.2.0.3 - Haskell wrapper for Docker Remote API  https://hackage.haskell.org/package/docker-0.2.0.3 (denibertovic)
04:15:58 <lambdabot>  1
04:16:01 <quicksilver> OHNOES! THE WORLD WILL END!
04:16:32 <asthasr> are tuples foldable?
04:16:36 <asthasr> I guess so
04:16:40 <quicksilver> in many ways, yes
04:16:55 <quicksilver> but the default instance just folds the 1-element on the right
04:17:04 <quicksilver> which is consistent for various things but potentially confusing
04:17:16 <quicksilver> > toList ('a',True)
04:17:18 <lambdabot>      Ambiguous occurrence ‘toList’
04:17:18 <lambdabot>      It could refer to either ‘Data.Foldable.toList’,
04:17:18 <lambdabot>                               imported from ‘Data.Foldable’ at /tmp/mueval137...
04:17:26 <quicksilver> > Data.Foldable.toList ('a',True)
04:17:28 <lambdabot>  [True]
04:18:06 <jle`> for many instances, a tuple (e, a) is treated as a single value `a`, "tagged" with a value of type `e`
04:18:19 <asthasr> yes, or with e as accreting state
04:19:07 <asthasr> it's just that my *instinct* was to think "of course the length of a tuple is 1, it's a single value" and then to realize "but wait, Foldable."
04:19:20 <asthasr> one assumes, for example...
04:19:26 <asthasr> > length 3
04:19:27 <lambdabot>      No instance for (Foldable t0) arising from a use of ‘length’
04:19:27 <lambdabot>      The type variable ‘t0’ is ambiguous
04:19:27 <lambdabot>      Note: there are several potential instances:
04:19:43 <asthasr> So.
04:19:50 <quicksilver> remember that Foldable is a class on things of kind * -> *
04:19:59 <quicksilver> Int and Double and so on are just *
04:20:29 <asthasr> I am too much of a Haskell idiot to think in kinds.
04:20:29 <quicksilver> although nothing stops you writing a Num instance for some type of the form `t x`
04:21:15 <asthasr> although I assume "* -> *" denotes "higher kinded types," i.e. parameterized types like monads or lists
04:21:34 <asthasr> is that accurate?
04:22:30 <byorgey> ~
04:22:32 <quicksilver> yes
04:22:44 <quicksilver> types which take a parameter
04:22:47 <quicksilver> [] Int
04:22:49 <quicksilver> Maybe Bool
04:22:55 <quicksilver> the [] and Maybe part of that, that is.
04:23:17 <quicksilver> the point is that if I can fold "Maybe Bool" it is because there is a Foldable instance for 'Maybe' (not for Bool)
04:23:22 * asthasr nods.
04:23:27 <quicksilver> > length (Nothing)
04:23:29 <lambdabot>  0
04:23:30 <asthasr> and of course you could have, I don't know, Tuple a b
04:23:51 <asthasr> thus, tuples are "* -> *"
04:24:02 <quicksilver> by the definitino you just gave
04:24:05 <quicksilver> it would be * -> * -> *
04:24:06 <asthasr> (or... are they not * -> * -> *)?
04:24:08 <quicksilver> two parameters, a and b
04:24:19 * asthasr nods.
04:24:40 <asthasr> ahh, hmm
04:24:51 <asthasr> and thus they are similar to Either a b, which also folds on its Right value I assume
04:25:10 <quicksilver> > Data.Foldable.toList (Right "yes")
04:25:11 <lambdabot>  ["yes"]
04:25:39 <quicksilver> although the lovely lens library lets us fold on whatever we want
04:25:57 <quicksilver> > toListOf _Left (Left "but surely you can't fold down the left?")
04:25:58 <lambdabot>  ["but surely you can't fold down the left?"]
04:26:40 <asthasr> it seems like this Foldable change has caused a lot of drama
04:27:19 <quicksilver> it does seem that way.
04:32:47 <liste> are there any nice combinator libraries for expressing things like "do X 5 seconds after Y has finished, but no earlier than 20 seconds after Z" ?
04:33:37 <asthasr> quicksilver: Thanks for the help :)
04:35:32 <quicksilver> that's not very hard to build with MVars, liste
04:35:44 <quicksilver> fill one MVar 5 seconds after &
04:35:46 <quicksilver> Y
04:35:51 <quicksilver> fill a second 20 seconds after Z
04:36:01 <quicksilver> and have your "do this thing" block on both MVars
04:37:55 <Jefffrey> Hello
04:38:33 <Jefffrey> Is it theoretically possible to define a `Foldable` instance for `(a, b)` where it maps the function to `a` instead of `b`?
04:38:49 <quicksilver> not the way things are set up at the moment Jefffrey 
04:38:50 <jle`> Jefffrey: what is the type of, say, toList?
04:38:53 <quicksilver> you'd have to have a newtype
04:39:01 <jle`> toList :: Foldable t => t a -> [a]
04:39:05 <quicksilver> because (a,b) is really (,) a b
04:39:12 <jle`> (a,b) is ((,) a) b
04:39:20 * quicksilver will let jle` finish the explanation
04:39:29 <jle`> so, toList :: ((,) a) b -> [b]
04:39:50 <jle`> where t  is (,) a
04:39:55 <mniip> interestingly that is alo the implementation :o
04:39:59 <liste> thanks quicksilver (:
04:40:19 <mniip> :t \((,) a b) -> [b]
04:40:20 <lambdabot> (t, t1) -> [t1]
04:40:24 <jle`> haha
04:40:43 <jle`> take that, ocaml
04:40:48 <phadej> :D
04:40:59 * hackagebot data-repr 1.0 - Alternative to Show data printing utility.  https://hackage.haskell.org/package/data-repr-1.0 (danilo2)
04:42:12 <Varis> Has anyone used leksah? I'm getting this in the log: "Warning: The package list for 'hackage.haskell.org' does not exist. Run 'cabal
04:42:12 <Varis>  update' to download it." Where can I input "cabal update"?
04:42:29 <dcoutts_> Varis: on the command line
04:43:42 <julianleviston> Varis: I’ve used it. I found it a bit flakey.
04:44:41 <jle`> leksah is haskel spelled backwards...but what's haskel?
04:46:20 <Varis> julianleviston, have any suggestions for something that does auto-suggestions, shows a defined function list and etc?
04:47:44 <Varis> dcoutts_, it worked! Thanks
04:48:37 <julianleviston> Varis: I just use SublimeText, so not really. Sorry. I like the idea of Leksah, and the ideas of structural editing modes and things, but I haven’t tried any out. Others will probably be of more help to you here.
04:49:04 <julianleviston> Varis: Do you find them necessary when you’re programming in Haskell?
04:50:56 <Heather> hi
04:51:42 <Varis> julianleviston, nope, I'we been writing mostly in Notepad++ on win and Gedit/vim on linux. Though I think an IDE would help with getting around things
04:52:40 <Varis> hi, Heather 
04:52:46 <julianleviston> Varis: keen to know how you go with that!
04:52:53 <julianleviston> Varis: keep me posted, if you can.
04:53:03 <Varis> sure
04:53:05 <jophish> How do people go about testing for performance regressions between package versions
04:53:10 <Varis> It seems leksah runs now
04:53:20 <jophish> I'm just running my benchmark against each version and comparing the numbers
04:53:39 <jophish> I suppose that's about as good as it's going to get
04:54:15 <Heather> Varis I like atom as IDE
04:54:45 <julianleviston> Heather: don’t you find the paren-matching annoying?
04:55:03 <Heather> julianleviston paren-matching?
04:55:05 <Varis> Heather, does it have auto-completion, currently defined function lists and etc>
04:55:23 <julianleviston> Heather: I mean the cursor positioning when you’re on a potision and how it shows you which parenthesis your cursor is within
04:56:47 <Heather> Varis yes, it has some auto-completion and it's using ghc-mod and even can add types to untyped (not type specified) functions etc
04:56:59 <julianleviston> Heather: I always found it to highlight the wrong parenthesis.
04:58:33 <Varis> but it's written in javascript :|
04:58:59 <Varis> haven't tried it though
04:59:10 <julianleviston> Varis: why do you care what it’s written in?
04:59:25 <Heather> julianleviston not sure if it's annoying
04:59:31 <Varis> julianleviston, js seems like it would be slow for this
04:59:58 <julianleviston> Varis: why?
05:00:46 <Varis> I won't answer that. Anyway, I'd have to check, now I'm only guessing
05:01:46 <julianleviston> Varis: I’m guessing you think javascript would be slow because you’re used to it running interpreted in browsers, not on the v8 engine or something? I don’t know either.
05:06:03 <Myrl> > f `on` g a b
05:06:04 <lambdabot>      Could not deduce (Show b0) arising from a use of ‘f’
05:06:04 <lambdabot>      from the context (Show a, FromExpr c)
05:06:04 <lambdabot>        bound by the inferred type of
05:06:17 <Myrl> wtf.
05:06:29 <Myrl> > (/) `on` fromInteger 1 2
05:06:31 <lambdabot>      Could not deduce (Num a0)
05:06:31 <lambdabot>      from the context (Fractional c, Num a1, Num (a1 -> a -> c))
05:06:31 <lambdabot>        bound by the inferred type for ‘e_112’:
05:06:42 <Myrl> Ohhh. okay.
05:06:45 <Myrl> > on f g a b
05:06:47 <lambdabot>      Could not deduce (Show b0) arising from a use of ‘f’
05:06:47 <lambdabot>      from the context (FromExpr c)
05:06:47 <lambdabot>        bound by the inferred type of it :: FromExpr c => c
05:06:52 <Myrl> :/
05:09:34 <merijn> Myrl: Try a more monomorphic function as example
05:09:42 <merijn> > f `on` (,) a b
05:09:43 <lambdabot>      Couldn't match expected type ‘a -> ()’
05:09:43 <lambdabot>                  with actual type ‘(Expr, Expr)’
05:09:43 <lambdabot>      Possible cause: ‘(,)’ is applied to too many arguments
05:09:52 <merijn> oh, duh
05:09:59 <merijn> > on f (,) a b
05:10:00 <lambdabot>      Could not deduce (Typeable b0) arising from a use of ‘f’
05:10:01 <lambdabot>      from the context (FromExpr c)
05:10:01 <lambdabot>        bound by the inferred type of it :: FromExpr c => c
05:10:19 <quicksilver> 'f' is annoying like that
05:10:20 <julianleviston> :t on
05:10:21 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
05:10:33 <merijn> oh, got the order wrong
05:10:38 <merijn> > on (,) f a b
05:10:39 <lambdabot>      No instance for (Show a0)
05:10:39 <lambdabot>        arising from a use of ‘show_M3509162717646042023443’
05:10:39 <lambdabot>      The type variable ‘a0’ is ambiguous
05:10:55 <merijn> I give up :p
05:10:57 <quicksilver> > on (,) f a b :: (Expr,Expr)
05:10:58 <lambdabot>  (f a,f b)
05:11:01 <quicksilver> what do I win?
05:11:25 <julianleviston> quicksilver: a kiss, from me
05:11:29 <jophish> :i Expr
05:11:42 <julianleviston> quicksilver: Keep It Simple, Silly! :)
05:12:04 <julianleviston> quicksilver: it seems you don’t need the kiss, tho.
05:12:06 <merijn> jophish: Expr is from simple-reflect
05:12:15 <jophish> thanks merijn 
05:12:20 <merijn> jophish: It allows for silliness like
05:12:26 <merijn> > foldr f z [a,b,c]
05:12:28 <lambdabot>  f a (f b (f c z))
05:13:08 <jophish> neat!
05:13:22 <Myrl> merijn: lololololol
05:13:48 <Myrl> >scanl
05:13:53 <Myrl> > scanl;
05:13:54 <lambdabot>  <hint>:1:6: parse error on input ‘;’
05:13:55 <Myrl> > scanl
05:13:57 <lambdabot>      No instance for (Typeable b0)
05:13:57 <lambdabot>        arising from a use of ‘show_M6960323643990869253523’
05:13:57 <lambdabot>      In the expression:
05:14:00 <Myrl> Welp.
05:14:07 <Myrl> Scary numbers are scary.
05:16:56 <merijn> It's lambdabot silly show instance for functions
05:17:03 <merijn> > (+)
05:17:05 <lambdabot>  <Integer -> Integer -> Integer>
05:17:11 <merijn> > id
05:17:12 <lambdabot>      No instance for (Typeable a0)
05:17:12 <lambdabot>        arising from a use of ‘show_M5182558835898208605587’
05:17:12 <lambdabot>      In the expression:
05:17:17 <merijn> > id :: Bool -> Bool
05:17:19 <lambdabot>  <Bool -> Bool>
05:17:42 <mniip> > toEnum
05:17:44 <Myrl> @pl (\f -> head . dropWhile (not . f))
05:17:44 <lambdabot> (head .) . dropWhile . (not .)
05:17:45 <lambdabot>      No instance for (Typeable a0)
05:17:45 <lambdabot>        arising from a use of ‘show_M4683453614016153421623’
05:17:45 <lambdabot>      In the expression:
05:17:53 <mniip> why not Int -> ()
05:17:56 <Myrl> I was expecting the (head .), nope. Just, nope.
05:18:19 <Myrl> Is that even valid syntax *outside* of Haskell?
05:18:31 <quicksilver> is what valid syntax Myrl?
05:18:31 <Myrl> I'm really curious.
05:18:37 <Myrl> quicksilver: (head .)
05:18:45 <Myrl> partial application of function composition.
05:18:46 <quicksilver> there are a few languages with sections, yes
05:18:55 <quicksilver> they're all written by haskell users tho
05:19:23 <quicksilver> head . dropWhile (not . p) is normally spelt "find p"
05:19:25 <mniip> Myrl, LUA (not to be confused with lua) :P
05:19:28 <quicksilver> I think, anyway
05:19:33 <Myrl> mniip: What is LUA?
05:19:46 <Myrl> quicksilver: I meant partial application of function composition.
05:19:47 <mniip> Myrl, a joke language I made :P
05:19:50 <quicksilver> :t \p -> head . dropWhile (not . p)
05:19:51 <lambdabot> (c -> Bool) -> [c] -> c
05:19:55 <Myrl> quicksilver: Like ((head .) . f)
05:20:01 <quicksilver> :t \p -> find p
05:20:02 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
05:20:09 <quicksilver> has the same time, must be the same.
05:20:12 <quicksilver> type
05:20:24 <mniip> not the same type
05:20:27 <quicksilver> Myrl: yes, well those haskell-descendants which have sections probably have sectionso f (.)
05:20:36 <quicksilver> I mean, if you have sections why wouldn't you allow (.) to be sectioned?
05:20:54 <quicksilver> mniip: *unifying types
05:21:00 <Myrl> How about in math?
05:21:02 <quicksilver> oh but not
05:21:03 <mniip> it doesn't unify
05:21:09 <quicksilver> find is safer
05:21:10 <quicksilver> *nod*
05:21:28 <mniip> find is bottomless, yes
05:21:33 <quicksilver> Myrl: mathematicians have ad-hoc notation for partial application, yes
05:21:49 <quicksilver> Myrl: and they certainly have ad-hoc notaton for partial applicaiton of function composition
05:21:58 <quicksilver> but it varies massively
05:22:26 <merijn> Mathematicians have ad-hoc notation for bloody eerything
05:22:51 <Myrl> Also, my pretty printer looks pretty weird. `(¬ ∘ f)`
05:22:53 <Myrl> not . f
05:23:03 <quicksilver> superscript? subscript? - as a placeholder, seen it all
05:23:12 <quicksilver> probably many more cases that don't spring to mind
05:23:13 <mniip> hmm
05:23:30 <quicksilver> mathematicians regularly confuse notation when it's obvious to them, too
05:23:41 <julianleviston> merijn: what *does* ad-hoc mean?
05:23:57 <quicksilver> julianleviston: not conforming to any uniform formal system
05:23:58 <mniip> how do I design my types in such a way that GHC would be able to infer concatenations of type-lists freely
05:24:01 <quicksilver> julianleviston: but made-up on the spot
05:24:33 <mniip> for instance, I might have a value, val :: F (a ++ a)
05:24:54 <Myrl> `<interactive>:7:30: Not in scope: ‘−’
05:24:57 <Myrl> Lol, wtf.
05:25:33 <Myrl> Ohhh
05:25:36 <Myrl> It's fucking unicode.
05:28:15 <merijn> julianleviston: ad-hoc is pretty much "made up as you go along, possibly inconsistent, without underlying theory"
05:30:07 <mniip> merijn, so like set theory
05:30:09 <Myrl> Hmmm...
05:30:14 <jle`> ad-hoc is an argument against the person making the argument instead of the argument itself
05:30:23 <quicksilver> no, that's ad-hominem
05:30:35 <merijn> mniip: We have some fairly consistent definitions of set theory
05:30:36 * quicksilver isn't quite sure if jle` is making a joke he has missed
05:30:49 <merijn> quicksilver: I don't think so, at least if so I missed it too
05:30:55 <quicksilver> merijn: set theory is consistent; the notations used are not.
05:31:03 <mniip> hoc-functors :o
05:31:04 <jle`> was joke ;_;
05:34:04 <Myrl> What's an idiomatic way of doing "abcdefgh" => "abc", "bcd", "cde", "efg"... in Haskell?
05:35:15 <obadz> Myrl: map (take 3) . tails
05:35:28 <Myrl> obadz: Holy cow...
05:35:39 <quicksilver> yeah I remember how cool I thought that was the first time I saw it
05:35:40 <julianleviston> Myrl: I think there’s something in Data.List that does exactly that, actually.
05:35:41 <Myrl> obadz: I like that.
05:36:25 <quicksilver> and they're all pointing to the same actual underlying Chars, too. Which doesn't really matter for Chars but is really nice if you have a list of bigger structures.
05:36:46 <pavonia> :t chunksOf
05:36:47 <lambdabot> Int -> [e] -> [[e]]
05:37:11 <Myrl> Oh right..
05:37:17 <Myrl> chunksOf 3 "abcd"
05:37:20 <Myrl> > chunksOf 3 "abcd"
05:37:21 <quicksilver> chunksOf is different
05:37:22 <lambdabot>  ["abc","d"]
05:37:24 <Myrl> or not.
05:37:26 <quicksilver> also useful, but not the same
05:37:52 <nshepperd> > map (take 3) (tails "abcdef")
05:37:54 <lambdabot>  ["abc","bcd","cde","def","ef","f",""]
05:38:07 <pavonia> Right, I didn't look at the example close enough :S
05:38:10 <obadz> > (reverse . drop 3 . reverse . map (take 3) . tails) ['a'..'h']
05:38:14 <lambdabot>  ["abc","bcd","cde","def","efg","fgh"]
05:38:31 <Myrl> obadz: I was also thinking of that, without the reverse though.
05:38:40 <quicksilver> obadz: or just takeWhile ((==3).length)
05:38:49 <Myrl> quicksilver: Too inefficient.
05:38:59 <quicksilver> why?
05:39:07 <obadz> not that inefficient
05:39:16 <Myrl> Hmmm
05:39:24 <quicksilver> reverse.reverse does an extra traversal of the entire list
05:39:28 <obadz> probably more efficient than reverse . drop . reverse
05:39:31 <quicksilver> that might well be worse
05:39:33 <Myrl> What I was doing.
05:39:37 <Myrl> What I was planning to do*
05:39:37 <obadz> takeWhile is lazy
05:41:10 <quicksilver> following pointers in cache is free
05:41:14 <quicksilver> well, sort of :)
05:41:30 <Myrl> takeWhile . (subtract 3) . length . map (take 3) . tails $ "abcdef"
05:41:32 <Myrl> > takeWhile . (subtract 3) . length . map (take 3) . tails $ "abcdef"
05:41:33 <lambdabot>      Couldn't match type ‘Int’ with ‘a -> Bool’
05:41:33 <lambdabot>      Expected type: [[Char]] -> a -> Bool
05:41:33 <lambdabot>        Actual type: [[Char]] -> Int
05:41:36 <Myrl> Lol.
05:41:47 <Myrl> Ah, right.
05:42:10 <obadz> > let f n l = (map snd . zip (drop (n - 1) l) . map (take n) . tails) l in f 3 ['a'..'h']
05:42:12 <lambdabot>  ["abc","bcd","cde","def","efg","fgh"]
05:42:13 <Myrl> I need to use (->) r for this.
05:42:36 <obadz> this doesn't use any length and is fully lazy
05:42:50 <Myrl> > (flip $ takeWhile . (subtract 3) . length) <*> map (take 3) . tails $ "abcdef"
05:42:51 <lambdabot>      Couldn't match type ‘Int’ with ‘Char -> Bool’
05:42:51 <lambdabot>      Expected type: [[Char]] -> Char -> Bool
05:42:51 <lambdabot>        Actual type: [[Char]] -> Int
05:42:57 <quicksilver> that is a cute approach obadz 
05:43:08 <Myrl> > (flip takeWhile $ (subtract 3) . length) <*> map (take 3) . tails $ "abcdef"
05:43:10 <lambdabot>      Couldn't match type ‘a0 -> Bool’ with ‘[Char]’
05:43:10 <lambdabot>      Expected type: [Char] -> b
05:43:10 <lambdabot>        Actual type: (a0 -> Bool) -> b
05:43:11 <quicksilver> use the spine of the list itself as a peano number
05:43:14 <quicksilver> and do arithmetic with that
05:43:17 <quicksilver> obadz++
05:43:20 <obadz> quicksilver ;-)
05:43:26 <Myrl> Hmmm...
05:43:39 <phaazon> what is this? https://github.com/wdanilo/data-repr
05:43:39 <Myrl> I have no idea how that works. :P
05:43:43 <quicksilver> Myrl, takeWhile needs a Bool
05:43:49 <quicksilver> and subtract 3 is going to give a number
05:43:53 <Myrl> > (flip take $ (subtract 3) . length) <*> map (take 3) . tails $ "abcdef"
05:43:55 <lambdabot>      Couldn't match type ‘Int’ with ‘[Char]’
05:43:55 <lambdabot>      Expected type: [Char] -> b
05:43:55 <lambdabot>        Actual type: Int -> b
05:44:04 <Myrl> :t take
05:44:05 <lambdabot> Int -> [a] -> [a]
05:44:12 <quicksilver> phaazon: it's supposed to be a debug-focussed version of Show
05:44:20 <Myrl> Hmmm... awit.
05:44:22 <Myrl> Oh, right.
05:44:25 <phaazon> quicksilver: which is Show
05:44:29 <obadz> quicksilver: first praise I got in here.. I must be progressing :)
05:44:37 <quicksilver> phaazon: well it's supposed to let you override it when you dont' want the Show instance
05:44:43 <quicksilver> phaazon: but, meh, overlapping instances are nasty
05:45:06 <Myrl> > (flip take <*> (subtract 3) . length) . map (take 3) . tails $ "abcdef"
05:45:08 <lambdabot>  ["abc","bcd","cde","def"]
05:45:11 <Myrl> :D
05:45:18 <phaazon> quicksilver: I agree
05:45:32 <Myrl> That doesn't work in infinite lists though... which is actually what I need to use this for. LOL.
05:45:39 <Myrl> > (flip take <*> (subtract 3) . length) . map (take 3) . tails $ [1..]
05:45:44 <lambdabot>  mueval: ExitFailure 1
05:45:53 <rom1504> tails
05:46:05 <julianleviston> sonic
05:46:20 <Myrl> Well, since I'm working with infinite lists, I just need `map (take 3) . tails`
05:46:24 <obadz> > let f n l = (map snd . zip (drop (n - 1) l) . map (take n) . tails) l in take 25 $ f 3 ['a'..]
05:46:25 <clrnd> hedgehog-prelude
05:46:27 <lambdabot>  ["abc","bcd","cde","def","efg","fgh","ghi","hij","ijk","jkl","klm","lmn","mn...
05:46:31 <obadz> this works on infinite lists ;-)
05:46:43 <rom1504> what do you expect the tails of [1..] to be ?
05:46:45 <quicksilver> obadz: it does but the whole zip thiing isn't necesasry if you know your lift is infinite
05:46:57 <obadz> quicksilver: yup
05:47:02 <quicksilver> rom1504: I expect it to be [[1..],[2..],[3..],...]
05:47:17 <quicksilver> rom1504: (and fortnuately haskell lives up to my expectations, yet again)
05:47:17 <Myrl> obadz: I'll have to look into yours later. :P
05:47:25 <rom1504> ah
05:47:39 <obadz> Myrl: it's very easy, to understand look at the output without map snd:
05:47:47 <obadz> > let f n l = (zip (drop (n - 1) l) . map (take n) . tails) l in take 4 $ f 3 ['a'..]
05:47:49 <lambdabot>  [('c',"abc"),('d',"bcd"),('e',"cde"),('f',"def")]
05:48:03 <nshepperd> you never know your list is infinite unless you created it though
05:48:26 <obadz> Myrl: it just pairs up elements of the original list (minus the first 2) with tails, when the original list runs out, it must be done
05:48:40 <Myrl> obadz: Ah!
05:49:36 <quicksilver> nshepperd: personally I live in doubt that there is a subtle bug in the runtime which makes my list terminate after 6.02 * 10^23 elements
05:49:39 <Myrl> Wait....
05:49:49 <obadz> quicksilver: :-D
05:49:49 <nshepperd> hehe
05:50:17 <quicksilver> presumably one can calculated the expected length of list you can traverse before a cosmic ray flips a bit and makes a [] constructor.
05:50:57 <obadz> quicksilver: more likely that the bit flip would cause the runtime to segfault than switch constructor?
05:51:14 <quicksilver> sad but true
05:54:10 <nshepperd> 'Studies by IBM in the 1990s suggest that computers typically experience about one cosmic-ray-induced error per 256 megabytes of RAM per month.' might be a few millions of years there then
05:55:47 <clrnd> is haskall cosmic ray error resistant?
05:55:51 <clrnd> or do I have to use idris?
05:56:27 <nshepperd> heh
05:56:29 <Myrl> clrnd: Lol.
05:56:38 <rom1504> you need to use a cosmic ray shield
05:56:43 <ttt_fff> undefined
05:56:46 <ttt_fff> > undefined
05:56:47 <lambdabot>  *Exception: Prelude.undefined
05:56:54 <ttt_fff> > undefined == undefined
05:56:55 <lambdabot>  *Exception: Prelude.undefined
05:57:01 <ttt_fff> > let x = undefined in x == x
05:57:03 <lambdabot>  *Exception: Prelude.undefined
05:57:07 <jle`> so much for reflexivity
05:57:17 <ttt_fff> actually, testing laziness
05:57:24 <ttt_fff> > let x = (undefined, undefined) in x == x
05:57:25 <lambdabot>  *Exception: Prelude.undefined
05:57:34 <ttt_fff> does == force thunks?
05:57:40 <rom1504> https://en.wikipedia.org/wiki/Health_threat_from_cosmic_rays#Mitigation ha! that's actually a thing.
05:57:43 <ttt_fff> i thought if they pointed at same thunk, == would return true w/o evaluation
05:57:44 <jle`> i was lamenting lack of laws for Eq ;_;
05:57:50 <nshepperd> how else would you test for equality
05:58:06 <ttt_fff> if they point to the same thunk (even if it's not evaluated), theyr'e =, whatever the value is
05:58:12 <jle`> ttt_fff: remember that (==) is defined separately for every type
05:58:15 <ttt_fff> it's like of two pointers point to the same location, they're equal
05:58:45 <jle`> and it's not like we really have access to pointer equality when defining instances
05:58:48 <nshepperd> exposing pointer equivalence through (==) would probably not be good
05:58:58 <ttt_fff> > let x = ((  \_ -> undefined) 0) in x == x
05:58:59 <lambdabot>  *Exception: Prelude.undefined
05:59:15 <jle`> @data Foo = Foo Int
05:59:15 <lambdabot> Unknown command, try @list
05:59:16 <ttt_fff> hmm, looks like == is hard working
05:59:21 <jle`> @let data Foo = Foo Int
05:59:22 <lambdabot>  Defined.
05:59:34 <ttt_fff> > let x = Foo undefined in x == x
05:59:35 <lambdabot>      No instance for (Eq Foo) arising from a use of ‘==’
05:59:35 <lambdabot>      In the expression: x == x
05:59:35 <lambdabot>      In the expression: let x = Foo undefined in x == x
05:59:37 <jle`> instance Eq Foo where (==) = ....okay, how do i get pointer equality?
05:59:43 <ttt_fff> lol
05:59:50 <jle`> when defining my Eq instance for Foo?
05:59:51 <Ferdirand> do you really want your != to suddently become true because of an accidental lack of sharing ?
06:00:09 <ttt_fff> this is haskell
06:00:11 <jle`> how would i access pointer equality when i'm defining (==)?
06:00:19 <jle`> what does that even mean, semantically?
06:00:20 <ttt_fff> weird conclusion due ot laziness would not surprise me
06:00:25 <saulzar_> unsafeCoerce? :)
06:00:34 <ttt_fff> jle`: are you asking me rhetociq uestions?
06:00:58 <jle`> i'm asking you for how you think this would work, heh
06:01:04 <ttt_fff> i was thikning, as an optimization to ==, you can say : look, just evaluate both to WNHF, check if everything points to same thunk
06:01:12 <jle`> but we write (==) ourselves
06:01:14 <jle`> as users
06:01:16 <ttt_fff> if so, return true; if not true, then evaluate the thunks each to WHNF
06:01:21 <jle`> we don't have access to that kind of information
06:01:21 <ttt_fff> yeah; you're right
06:01:33 <Ferdirand> maybe we would need a separate (===) for this to be usable without pitfalls
06:01:34 <quicksilver> jle`: reallyUnsafePtrEquality#
06:01:36 <quicksilver> IIRC.
06:01:44 <quicksilver> but the name is a clue.
06:01:58 <jle`> heh, we're breaking out of the semantics of haskell at this point and manipulating weird properties of the runtime
06:02:04 <nshepperd> ghc could do that, but it wouldn't be safe
06:02:09 <jle`> but lazy evaluation is supposed to obey *semantics*
06:02:16 <jle`> that's the whole point of lazy evaluation/non-strictness
06:02:16 <phaazon> hm
06:02:19 <phaazon> https://github.com/archaeron/idris-fiamma#example 
06:02:23 <phaazon> what do you think of that ^
06:02:27 <jle`> the reason why we have laziness in the first place is to preserve semantics
06:02:32 <phaazon> for instance, it sounds we can use the title function several times
06:02:44 <phaazon> so I guess that’s not a very good way to go with
06:02:55 <jle`> so we can't shouldn't/use laziness to break semantics...that's kind of self-defeating the whole point, heh
06:03:23 <ttt_fff> phaazon: I think it'd look better with http://uncyclopedia.wikia.com/wiki/File:Hello_Kitty_logo.svg
06:03:34 <nshepperd> 'data Evil a = Evil a; instance Eq a where { _ == _ = False }; pointerEquality :: Evil a -> Evil a -> Bool; pointerEquality = (==)'
06:04:19 <ttt_fff> nshepperd probably takes people's code and writes #define while if
06:04:23 <phaazon> ttt_fff: neat
06:04:58 <jle`> although, i would have expected instance Eq () where _ == _ = True
06:05:11 <nshepperd> well, maybe you only allow this pointer comparison business for built in types. but still then what jle` said applies
06:05:53 <jle`> i'm sure there is a reason why the instanace isn't defined that way, but i can't imagine it at the moment
06:07:30 <TheTime> ||||| IS YOUR DOMAIN WORTH A MILLION DOLLARS? >>> www.VALBOT.com <<< FREE DOMAIN VALUATION! or GOOGLE >>> www.VALBOT.com <<< |||||
06:08:30 <jle`> unrelated, but is it weird that i imagined (|||||) being an operator?
06:09:23 <ttt_fff> it's shorthand for parMap, (||||) :: (a -> b) -> [a] -> [b] ; but each (a->b) in parallel
06:10:10 <jle`> @let (|||||) = (&&)
06:10:11 <lambdabot>  Defined.
06:10:22 <jle`> > True ||||| False
06:10:24 <lambdabot>  False
06:10:44 <obadz> > True ||||| False
06:10:46 <lambdabot>  False
06:10:57 <obadz> what is the scope of these @let statements?
06:11:13 <julianleviston> obadz: until reset, I believe
06:11:25 <obadz> @reset ?
06:11:25 <lambdabot> ?
06:11:40 <julianleviston> obadz: oh… sorry, I mean until they’re reset, or lambdabot is reset.
06:12:01 <julianleviston> obadz: assuming you meant “in time” by scope, and not actually scope, which would be “toplevel”, I think.
06:13:07 <obadz> @let (&&) = (||) -- that legal? 
06:13:08 <lambdabot>  .L.hs:150:11:
06:13:08 <lambdabot>      Ambiguous occurrence ‘&&’
06:13:08 <lambdabot>      It could refer to either ‘L.&&’, defined at .L.hs:151:1
06:13:35 <obadz> ok so can't shadow an existing binding
06:14:08 <julianleviston> obadz: I’m unsure about that.
06:16:19 <ElMoloko> is there an equivalent of make -j for cabal install?
06:16:54 <clrnd> -j
06:22:47 <quicksilver> it is legal to shadow existing bindings in local scope
06:22:52 <quicksilver> but not at file scope.
06:23:26 <quicksilver> jle`: I assume it would just be inconsistent for == to be non-strict on () and strict on other NFData types.
06:23:41 <quicksilver> it doesn't seem terribly important to me one way or the other.
06:24:33 <quicksilver> but if (() == error "you can't see me") reduced to True that might be a surprise.
06:33:51 <obadz> :t Data.List.maximum
06:33:52 <lambdabot> (Ord a, Foldable t) => t a -> a
06:34:24 <obadz> in hackage, it is     maximum :: forall a . Ord a => t a -> a
06:34:32 <obadz> I don't understand why there is a forall there
06:34:37 <obadz> and no constraint on t
06:35:00 <obadz> https://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.Foldable.html#maximum
06:35:13 <obadz> :t Data.Foldable.maximum
06:35:14 <lambdabot> (Ord a, Foldable t) => t a -> a
06:35:31 <phadej> obadz: it's member of Foldable
06:35:37 <obadz> phadej: just saw that
06:35:38 <phadej> (Foldable t) to be precise, scroll up
06:35:40 <obadz> phadej: what about the forall ?
06:35:41 <phadej> :+1:
06:35:59 <phadej> obadz: what's about it? YOu aren't familiar with `forall` syntax?
06:36:01 <obadz> is it because 'a' is not in the class declaration?
06:36:31 <obadz> well class Foldable t where...
06:36:44 <obadz>  length :: t a -> Int -- no forall here
06:36:58 <phadej> obadz: it's there to introduce a name, for ScopedTypeVariables
06:37:01 <obadz>  maximum :: forall a . Ord a => t a -> a -- why is it needed there?
06:37:06 <phadej> 'a' is used in (Just :: a -> Maybe a)
06:37:19 <phadej> without forall a. the 'a's would be different
06:38:15 <phadej> (a in function type signature, and a in type annotation for Just)
06:38:23 <obadz> this is because of #. (coercion) ?
06:38:33 <obadz> that they need explicit type annotations?
06:40:07 <obadz> I need to read up on coercion
06:41:27 <phadej> obadz: i'm not sure whether you need an explicit type annotation there
06:41:54 <phadej> :t fromMaybe (error "foo") . getMax . foldMap (Max . Just)
06:41:56 <lambdabot> Not in scope: ‘getMax’
06:41:56 <lambdabot>     Not in scope: data constructor ‘Max’
06:41:56 <lambdabot>     Perhaps you meant variable ‘max’ (imported from Data.Ord)
06:42:10 <phadej> ok, no Monoid for me
06:42:37 <quicksilver> obadz: #. isn't coercion
06:43:19 <obadz> (#.) :: Coercible b c => (b -> c) -> (a -> b) -> (a -> c)
06:43:37 <phadej> :t fromMaybe (error "foo") . getSum . foldMap (Sum . Just)
06:43:39 <lambdabot> (Num (Maybe c), Foldable t) => t c -> c
06:44:01 <phadej> works without type annotation too, dunno why it's there. Maybe GHC isn't smart enough somewhere there
06:44:31 <quicksilver> obadz: sorry I spoke badly. #. isn't *just* coercion
06:44:45 <quicksilver> obadz: it's a trick to make newtype wrappers fast, but you can just read it as .
06:44:58 <obadz> :t Sum
06:45:00 <lambdabot> a -> Sum a
06:45:08 <obadz> why isn't there a Num a constraint here?
06:45:32 <phadej> obadz: Num comes from Sum's Monoid instance.
06:45:42 <phadej> as Ord from Max's
06:45:47 <quicksilver> I think that type signature is because of #., yes
06:45:53 <quicksilver> #. is too polymorphic
06:46:00 <quicksilver> fails to constraint the type on its right
06:46:27 <phadej> quicksilver: but it works with dot?
06:46:30 <quicksilver> I'm not sure though :)
06:46:32 <phadej> i.e. (.)
06:46:34 <quicksilver> yeah with plain . it's fine
06:46:40 <phadej> :t (.)
06:46:41 <lambdabot> (b -> c) -> (a -> b) -> a -> c
06:46:42 <quicksilver> then the types are clear
06:46:55 <phadej> the same, except the constraint.
06:47:20 <obadz> phadej: I get what you said about Num/Sum
06:50:16 <obadz> so you use the coercions to get the Max monoid without any runtime boxing?
06:50:53 <quicksilver> it's more subtle than that
06:51:01 <quicksilver> Max doesn't do any boxing anyway
06:51:04 <quicksilver> newtypes don't
06:51:25 <quicksilver> newtypes don't do any boxing but if you compose their constructor, as a function, with another function
06:51:29 <quicksilver> f . Max . g
06:51:53 <quicksilver> then compiler thinks that the 'Max' could potentially be _|_
06:51:59 <quicksilver> because it's really (\x -> Max x)
06:52:12 <quicksilver> so it wastes time with book-keeping and indirections
06:52:31 <quicksilver> this is so subtle that nobody noticed it for the first 15 years that GHC had newtypes :)
06:52:31 <obadz> meaning one additional thunk?
06:52:44 <obadz> lol
06:52:48 <obadz> who noticed it?
06:52:58 <quicksilver> edwardk or shachaf I believe
07:06:05 <nshepperd> _ #. f = coerce f?
07:08:46 <quicksilver> yes but more than that
07:08:57 <quicksilver> it's "coerce f to the type that _ . f was going to have"
07:09:16 <nshepperd> with that type signature yes
07:09:17 <quicksilver> so in particular, "Sum #. f" is "f coerced to the type of Sum . f"
07:10:38 <nshepperd> odd, I thought the compiler would be able to do stuff like f . Max . g = f . coerce . g = f . g (untyped) naturally
07:11:21 <nshepperd> unless that information is lost by the time we reach the untyped level
07:12:45 <quicksilver> nshepperd: well this is what the comment says:
07:13:55 <quicksilver> ""However, if f is a function,N . f = \x -> N (f x) This looks almost the same as f, but the eta expansion lifts it--the lhs could be _|_, but the rhs never is. This can lead to very inefficient code.""
07:14:11 <quicksilver> I cannot say that I fully understand teh comment :)
07:14:55 <quicksilver> https://ghc.haskell.org/trac/ghc/ticket/7542
07:15:45 <nshepperd> hmm
07:16:41 <phadej> check how dot is defined, and inline it by hand
07:16:58 <phadej> on mobile, cannot point you directly
07:17:02 * hackagebot grouped-list 0.2.0.0 - Grouped lists. Equal consecutive elements are grouped.  https://hackage.haskell.org/package/grouped-list-0.2.0.0 (DanielDiaz)
07:17:33 <quicksilver> the trac ticket is more illuminating also
07:18:50 <nshepperd> well, I understand how (\x -> N (f x)) is not ⊥, while (coerce f) might be
07:21:49 <quicksilver> but (\x -> ..) might be (\x -> _|_)
07:22:07 * quicksilver doesn't see why the optimiser cares between _|_ and \x -> _|_ here
07:22:21 <medicijnman> hi guys. do you know how to tell cabal to use the latest version? i updated cabal with "cabal install cabal cabal-install"
07:22:41 <medicijnman> but cabal --version still yields 1.16.0.2
07:22:58 <nshepperd> because `seq` can distinguish them
07:23:01 <dcoutts_> medicijnman: check your $PATH, you're probably still using cabal from e.g. /usr/bin
07:23:02 <medicijnman> i have installed version1.22
07:23:08 <nshepperd> though I'm not sure why we care about that, really
07:23:31 <medicijnman> dcoutts: what is the default located of new cabal versions installed through cabal?
07:23:41 <nshepperd> I suppose it's better for the compiler to preserve strictness
07:23:42 <medicijnman> my path uses indeed /usr/bin/cabal
07:23:53 <medicijnman> but locate cabal does not help much
07:24:07 <dcoutts_> medicijnman: ~/.cabal/bin, though you can configure it, e.g. to add symlinks into ~/bin
07:26:49 <medicijnman> dcoutts: thanks. that worked
07:26:56 <dcoutts_> great
07:27:54 <medicijnman> dcoutts_: i have another problem. cabal tells me i have one missing dependency: random ==1.0.* i have random 1.1 installed
07:28:41 <dcoutts_> medicijnman: when running cabal configure?
07:32:34 <lpaste> tesrty pasted “AorB” at http://lpaste.net/2950447326088396800
07:32:47 <tesrty> So I was wondering if that could be shorter.
07:33:51 <clrnd> meh, I'd use pattern matching on arguments instead of `if`
07:33:53 <tesrty> I tried to apply 'theOther' to thing after the Just but of course you can't do that there, because that's where pattern matching happens.
07:33:56 * clrnd dont likes if
07:34:09 <lpaste> quicksilver annotated “AorB” with “AorB (annotation)” at http://lpaste.net/2950447326088396800#a143617
07:34:16 <quicksilver> tesrty: ^^
07:34:30 <clrnd> oh nice
07:36:33 <tesrty> Hmm. Thats nice quicksilver. But doesnt solve my problem. Things have to happen according to another variable before I check for AorB which means all that code still has to be duplicated.
07:36:49 <quicksilver> that doesn't make sense to me tesrty 
07:36:51 <tesrty> I really have to go now but I'll probably be back later. Thanks for the suggestion.
07:36:58 <quicksilver> I can't see any circumstance in which you couldn't use my approach
07:37:04 <quicksilver> just factor out this part into another function if you like
07:37:10 <tesrty> Yea I get that. I'll update the example if I come back ;]
07:37:30 <tesrty> Hmhm, and I'll try to factor that bit out first. Your proposed solution is still very useful. Thanks.
07:40:55 <quicksilver> you are welcome :)
07:47:03 * hackagebot dixi 0.5.1.0 - A wiki implemented with a firm theoretical foundation.  https://hackage.haskell.org/package/dixi-0.5.1.0 (LiamOConnorDavis)
07:49:34 <sm> jophish: congrats. Do you have an idea what was causing the speedup when profiled ?
07:49:42 <casexof> I want similar actions to be run either on STM or a database. The database actions looks like MonadIO m1 => Int -> ReaderT SqlBackend m1 [Value]. How can I express a STM action in terms of ReaderT ?
07:52:29 <hexagoxel> why is Text.splitOn " " "" == [""] but words "" == [] ?
07:54:02 <hexagoxel> inconsistencies! (also, imo, the Text result is better in terms of inversibility)
07:55:27 <solarus> but `splitOn foo' means "split the text on foo" and `words ls' means "extract the words from ls"
07:55:33 <solarus> does not seem inconsistent to me
07:57:04 <gyrzrnygych> Is there a Haskell analog of nbutlast from Lisp?
07:58:02 <obadz> gyrzrnygych: reverse . drop n . reverse
07:58:39 <gyrzrnygych> obadz: that's really costly right? Two reverses?
07:59:32 <gyrzrnygych> Is there something that does it with a single traversal?
08:01:48 <obadz> yeah
08:01:53 <obadz> dropLastN n = foldl (.) id (take n $ repeat dropLast)
08:02:21 <obadz> and dropLast is written with pattern match..
08:02:36 <obadz> dropLast (x:y:[]) = [x] etc.
08:03:07 <obadz> not sure if that's what's most efficient.
08:07:04 * hackagebot wai-devel 0.0.0.1 - A web server for the development of WAI compliant web applications.  https://hackage.haskell.org/package/wai-devel-0.0.0.1 (urbanslug)
08:07:15 <concept3d> Hi all, I have function of type processEvent :: Event -> CTIState -> CTIState  this clearly modifies a state it works fine with modify inside state monad 
08:07:19 <obadz> ooooh!~
08:07:22 <obadz> dropLastN' n l = map fst $ zip l (drop n l)
08:07:29 <concept3d> the problem is when I change the signature to processEvent :: Event -> CTIState -> (CTIState, Bool)
08:07:34 <obadz> same trick as earlier today. again ;-)
08:07:46 <concept3d> how can I still use this in the State monad
08:07:46 <anohigisavay> hi
08:07:54 <quicksilver> can also use your zip trick, obadz 
08:08:03 <anohigisavay> http://lpaste.net/143618 a piece of code from RWH
08:08:06 <obadz> quicksilver: yes!
08:08:20 <obadz> quicksilver: don't know how I did not think about it immediately
08:08:41 <anohigisavay> what happens if "force greater" is slower than "force lesser"?
08:09:06 <hexagoxel> solarus: hmm yeah, maybe it is Text.PrettyPrint.fsep's fault `fsep . words` not being identity is my issue.
08:09:23 <c_wraith> obadz: try zipWith const instead of the mapping fst bit
08:10:40 <obadz> c_wraith: cool
08:11:23 <pavonia> concept3d: Apply fst to the result?
08:11:51 <pavonia> concept3d: Or what would you like to do with the Bool value?
08:11:57 <quicksilver> concept3d: write a wrapper: do s <- get; (s',b) <- processEvent e s; put s'; return b
08:12:14 <quicksilver> or use that wrapper as the main versio of processEvent if you like
08:12:28 <concept3d> quicksilver: I just tried similar solution and it worked
08:12:29 <quicksilver> it now has the type MonadState CTIState m => Event -> m Bool
08:12:35 * quicksilver nods
08:12:43 <quicksilver> concept3d: the answer to every question of this form is that you can do it.
08:12:48 <quicksilver> but what is sometimes hard
08:12:58 <quicksilver> is to work out which tpyes to use so you have the minimum plumbing to do
08:13:13 <quicksilver> it is annoying connecting together all these things of equivalent but different types with simple wiring.
08:13:57 <concept3d> quicksilver: 100% agree, I am still getting used to this, but I like it so far.
08:17:08 <concept3d> quicksilver: one more question, I returned the Bool to notify if anything in the state has changed or not and make action based on that. is this a common/sound design in Haskell
08:17:31 <quicksilver> I think more common would be to return Maybe State
08:17:42 <quicksilver> with the assumption that 'Nothing' means 'nothing changed, keep the existing state'
08:18:55 <concept3d> quicksilver: I will consider the Maybe, eventhough I always thought of it as failure.
08:19:16 <concept3d> in this case I don't know
08:19:48 <ski> concept3d : if you had `processEvent :: Event -> CTIState -> (Bool,CTIState)', then you could do `state . processEvent :: MonadState s m => Event -> m Bool'
08:20:12 <ski> (or you could throw a `swap' in there)
08:20:47 <quicksilver> ski: do you have a rule of thumb which form to write these kinds of functions in to minimise plumbing?
08:21:14 <ski> "these kinds of functions" being ?
08:21:37 <concept3d> ski: I don't get it 100% are you sugessting composition here ? I don't see how you derived the result
08:22:09 <quicksilver> ski: generally functions of the forms s -> s, s -> r and s -> (r,s)
08:22:10 <ski> concept3d : i'm just suggesting an alternate way to get what quicksilver suggested, using `state' instead of `get' and `put'
08:22:28 <quicksilver> ski: (with other parameters in front, sometimes annoyingly in the wrong order)
08:22:53 <quicksilver> I eitehr end up using plumbing to wire them into my state monad or using plumbing when composing them 'normally'
08:22:54 * ski isn't sure what quicksilver is asking about :/
08:22:56 <concept3d> ski: Ok, I just checked state signature, and I can see it
08:23:21 <ski> @type modify
08:23:23 <lambdabot> MonadState s m => (s -> s) -> m ()
08:23:23 <ski> @type state
08:23:25 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
08:24:59 <ski> .. though it seems quicksilver assumed something like `processEvent :: Event -> CTIState -> M (CTIState, Bool)' in that other suggestion, for some state-enabled monad `M'
08:25:16 <ski> .. in which case you'd use `get' and `put' (or some wrapper around those)
08:27:13 <ski> quicksilver : from an abstract viewpoint, i'd prefer it if it was `s -> (s,a)' and `(w,a)'. however i suppose i'd try to align with the existing order, if no other opposing consideration imposed itself against that. not sure whether that's what you're asking about, though
08:30:08 <Zemyla> Why is (Monoid w) => Monad ((,) w) not in base?
08:33:23 <sclv> what would be gained if it was
08:37:05 * hackagebot hs-duktape 0.1.1 - Haskell bindings for a very compact embedded ECMAScript (JavaScript) engine.  https://hackage.haskell.org/package/hs-duktape-0.1.1 (myfreeweb)
08:37:43 <kamatsu> is there some way to make haskell mode not complain on MIN_VERSION pragmas?
08:38:05 <kamatsu> i guess flycheck-haskell is to blame
08:39:53 <quicksilver> ski: it's just I tend to write my functions with the most direct type, in isolation
08:40:13 <quicksilver> ski: and they sometimes require more trivial work (applications of fmap swap, for example) to slot into a state monad
08:40:33 <quicksilver> ski: it's even worse if you have a function 't' which is somehow 'part of' your state S
08:40:39 <quicksilver> or the converse, also
08:45:54 <ski> quicksilver : didn't follow the last bit
08:46:39 <umib0zu> anyone have webservice library recommendations? I keep seeing snap, but I can’t findany decent tutorials on how it works
08:46:40 <quicksilver> ski: if you have a function t -> (t,a) and you wish you could run it 'inside' your s-State monad because there is a 't' inside 's'
08:46:56 <quicksilver> ski: the answer is you patch it in with a lens and patch the result back out
08:47:01 <ski> oh, lenses
08:47:03 <ski> yes
08:47:06 * hackagebot deepcontrol 0.3.3.0 - Provide more deeper level style of programming than the usual Control.xxx modules express  https://hackage.haskell.org/package/deepcontrol-0.3.3.0 (KONISHI_Yohsuke)
08:47:07 <quicksilver> which is fine, but it's more plumbing
08:47:24 <quicksilver> and you have to write the plumbing slightly differently for t -> Maybe (t , a)
08:47:36 <quicksilver> and again for t -> IO (t, a)
08:47:37 <quicksilver> etc....
08:48:54 <troydm> do all attoparsec parsers rewind consumed input on failure?
08:52:45 <glguy> In (a <|> b), if a fails then b is attempted even if a consumed some input along the way
08:53:00 <glguy> but if a succeeds, b will never be attempted even if there  is a failure later
08:55:30 <dolio> Zemyla: It is in base.
08:57:33 <quicksilver> > sequence [("foo",True),("bar",0)]
08:57:35 <lambdabot>      No instance for (Monad ((,) [Char]))
08:57:35 <lambdabot>        arising from a use of ‘sequence’
08:57:35 <lambdabot>      In the expression: sequence [("foo", True), ("bar", 0)]    No instance f...
08:57:40 <quicksilver> dolio: are you sure?
08:58:12 <dolio> Relatively.
08:59:23 <dolio> Maybe it's somewhere else weird, though.
08:59:27 <quicksilver> lambdabot doesn't seem to have it in scope. I wonder where it is.
09:00:00 <dolio> Or maybe it's just been in a library proposal that everyone +1ed, and I thought it would be in by now.
09:00:40 <quicksilver> the related instance for Monoid m => Monad (Const m) is in base
09:00:47 <quicksilver> it's in the "new" Control.Applicative
09:00:58 <quicksilver> Applicative too :)
09:01:09 <dolio> Is that a monad? I think it's just an applicative.
09:01:19 <quicksilver> oh
09:01:27 <dolio> Maybe that's what I'm thinking of, though.
09:01:39 <quicksilver> you are right of course
09:01:57 <quicksilver> hard to make that satisfy the return law.
09:02:02 <dolio> Right.
09:02:37 <dolio> It only works for something trivial.
09:02:51 <dolio> () or Void, depending on how you're feeling.
09:03:17 <quicksilver> it's an interesting example thoigh because it has pure, it has ap, and it has an obvious join instance
09:03:36 <quicksilver> normally if you have an obvious join instance you expect it to obey laws
09:03:41 <quicksilver> s/instance/implementation/
09:12:07 * hackagebot Slides 0.1.0.6 - Generate slides from Haskell code  https://hackage.haskell.org/package/Slides-0.1.0.6 (darwin226)
09:18:08 <clrnd> how many commitees do we have, and who are their members?
09:18:36 <clrnd> and what are their responsibilities
09:22:13 <shachaf> quicksilver: Yes, (#.) and (.#) was me, back when I was reading Core to make lens have no overhead.
09:22:56 <shachaf> quicksilver: But I proposed them as an example of the fact that it's possible, not as serious solutions, and I still think they're the wrong solution.
09:30:52 <quicksilver> clrnd: only the secret committee committee knows the answers to those!
09:31:04 <quicksilver> shachaf: *nod*; but that's the solution now in base :/
09:31:49 <shachaf> quicksilver: If you use strict composition, it makes the semantics right, so all you need is for the GHC optimizer to be smarter.
09:31:51 <quicksilver> shachaf: https://ghc.haskell.org/trac/ghc/ticket/7542 seems to be unaware of the fact that there is a specific workaround to this problem in base now.
09:34:32 <glguy> clrnd: There's https://wiki.haskell.org/Core_Libraries_Committee . A Haskell Prime committee is in the works but isn't restarted
10:13:09 <jhrcek> Hello. Can someone please explain to me, why this page recommend not to install haskell platform (section installing haskell)? https://github.com/bitemyapp/learnhaskell
10:13:36 <quicksilver> the best person to explain would probably be bitemyapp himself
10:13:50 <quicksilver> but I believe the reason is that people prefer to use stack these days
10:13:56 <bitemyapp> jhrcek: causes problems that new people don't know how to fix.
10:14:04 <quicksilver> ah there he is.
10:14:05 <bitemyapp> jhrcek: it installs things into the global package database that don't need to be.
10:14:13 <bitemyapp> jhrcek: use Stack or a minimal install of GHC/Cabal.
10:14:17 <jhrcek> bitemyapp like cabal hell?
10:14:27 <bitemyapp> jhrcek: it's one source/trigger of package conflicts, yes.
10:14:35 <tippenein_> sudo apt-get install cabal-hell
10:14:41 <bitemyapp> there are others, but this one is easily avoided - so avoid it.
10:14:49 <quicksilver> personally I just installed haskell on a new computer and used HP and I don't regret it (yet)
10:15:09 <tippenein_> same quicksilver. no problems as of yet
10:15:12 <bitemyapp> quicksilver: well, the moment you need to compile anything incompatible with the packages in your global package-db, it'll bite you.
10:15:25 <bitemyapp> currently HP is relatively up to date and a lot of people don't compile a diverse set of packages.
10:15:35 <jhrcek> Cool, thanks. I've been using HP for some time and am starting to notice some conflicts when installing packages to try them out
10:15:40 <tippenein_> me == a lot of people
10:15:59 <bitemyapp> tippenein_: having spent many hours cleaning up the mess HP caused for confused new people
10:16:19 <bitemyapp> tippenein_: it doesn't really matter to me that you think your use-case represents a lot of people.
10:16:27 <bitemyapp> There's no advantage to installing those packages in the global db.
10:16:41 <bitemyapp> if you care about not rebuilding packages over and over, you should be using Stack.
10:17:15 <hth313> I have a compilation problem I cannot figure out: http://lpaste.net/143629
10:17:25 <bitemyapp> my point about installing packages in the global db isn't even contested any longer. They plan to phase that out and make HP a hybrid minimal installer + Stack.
10:17:47 <bitemyapp> So, whether you agree with me or not, the maintainers of HP finally did and they're going to fix it.
10:17:52 <quicksilver> :)
10:17:57 <bb010g> w00t! Link to the announcement?
10:18:02 <quicksilver> thanks for the explanation.
10:18:31 <bitemyapp> bb010g: the mailing list threads about the downloads page on haskell.org or about the state of Platform.
10:18:38 <bitemyapp> bb010g: particularly the ones Wiegley started.
10:18:44 <jhrcek> Yesterday I received an email from Michael Snoyman mentioning/recommending stack. Is there any "competition" between developers of HP vs stack? Is HP going to become less used because of that?
10:20:05 <clrnd> jhrcek, an email as in spam? :|
10:20:26 <bitemyapp> jhrcek: how is it competition if Stack is going to get mainlined into HP?
10:20:28 <bb010g> jhrcek: HP's goal is to make using Haskell quick and easy. "Batteries included." stack has the same goal. However, stack is built better and thus is being more widely used.
10:20:38 <bitemyapp> jhrcek: Snoyman, like myself, is just trying to make sure new people don't get stuck.
10:20:54 <bitemyapp> and that they're using the current-best-option
10:20:59 <jhrcek> ckrbd: no. I took part in some survey of current HS ecosystem. So this basically gave some results and some directions of future development in HS ecosystem.
10:21:05 <mutantmell> Stack has the benefit of being newer.
10:21:14 <tippenein_> for the record, I agree with you bitemyapp. I just used the short-sighted path of least resistance
10:22:10 * hackagebot postgresql-simple 0.5.1.0 - Mid-Level PostgreSQL client library  https://hackage.haskell.org/package/postgresql-simple-0.5.1.0 (LeonSmith)
10:22:22 <quicksilver> well, HP has no specific infrastructure software beyond shipping a straightforward installer script
10:22:40 <quicksilver> it is really just a cheap way to get a bunch of libraries
10:22:57 <jhrcek> bitemyapp: I don't know, just trying to understand where the things are headed. I definitely appreciate there's progress towards making the platform easier to use for new people.
10:23:01 <quicksilver> stack is an actual piece of software designed to handle (some of) the problems above.
10:23:25 <bb010g> How's halcyon faring nowadays due to stack?
10:37:24 <hth313> Anyone who could give http://lpaste.net/143629 a try?
10:45:41 <ski> hth313 : looks like defaulting
10:47:11 * hackagebot snap-extras 0.11.0.2 - A collection of useful helpers and utilities for Snap web applications.  https://hackage.haskell.org/package/snap-extras-0.11.0.2 (DougBeardsley)
10:52:01 <umib0zu> does anyone have tutorials on getting started with snap?
10:52:30 <umib0zu> or any other http server library
10:57:18 <hth313> sky: do you have some further reading about defaulting? How to get around it? Num, Enum, Eq, Ord are accepted, but nothing(?) else
10:57:45 <ski> hth313 : i'm not sure what you're trying to accomplish
10:58:03 <clrnd> hth313, you need to assign a default implementation for `xx``
10:58:12 <ski> hth313 : `foo' has to pick some specific type to use for `a' (in `A' and `D a')
10:58:23 <c_wraith> hth313: Floating is accepted. 
10:58:27 <ski> (er, actually `t')
10:59:52 <ski> hth313 : to use `afield' of `A', you must use some specific instance of `C'
11:00:54 <clrnd> oh sorry didn't say anything
11:01:32 <clrnd> ski, for example?
11:02:11 * hackagebot dixi 0.5.1.1 - A wiki implemented with a firm theoretical foundation.  https://hackage.haskell.org/package/dixi-0.5.1.1 (LiamOConnorDavis)
11:02:22 <ski> dunno, hth313 hasn't provided any instance of `C' in the paste
11:03:17 <clrnd> mmm that doesn't seem right, so I can't define a `class Stuff` with no implementations and use it as a class constraint?
11:04:09 <ski> of course you can
11:04:16 <clrnd> but..
11:04:26 <hth313> ski: I used a specific instance before as a (ugly) work around, but I tried to get away from it.
11:05:12 <hth313> ski: when stripping the code down, I stumbled over that it allowed this for certain classes (like Num), and was puzzled
11:05:22 <ski> it's clear (to me) why your code doesn't work, but
11:05:24 <ski> <ski> hth313 : i'm not sure what you're trying to accomplish
11:06:25 <hth313> ski: This is the original code: https://github.com/hth313/hthforth/blob/master/src/Language/Forth/CrossCompiler.hs
11:06:31 <clrnd> it's not clear to me, why does `dfield . afield` typecheck but not `isJust . dfield . afield` ??
11:06:32 <ski> when it can't resolve an ambiguous type variable, it tries a bunch of types on a default list, and see if they satisfy the required constraints
11:07:47 <ski> clrnd : the former has type `forall t. (C t,Num t) => A -> Maybe t', the latter would have type `forall t. (C t,Num t) => A -> Bool', but that's ambiguous, so you must pick a particular `t'
11:08:21 <clrnd> ski, okay, why is it ambiguous? what's ambiguous anyway?
11:08:30 <clrnd> (feel free to link me to a detailed explanation)
11:08:55 <ski> by using it, there's no way the context of using it can determine what the type `t' should be
11:09:19 <ski> the standard example of this would be `read . show :: forall a. (Read a,Show a) => String -> String'
11:09:25 <clrnd> why does it need a type? if it ain't gonna use it, can't it just discard it?
11:09:31 <clrnd> oh
11:09:35 <clrnd> let me think
11:09:36 <ski> er, `show . read', rather
11:09:41 <clrnd> that's clear, yeah
11:09:47 <ski> here it doesn't know for which type `a' you want to first read and then show
11:10:00 <ski> .. and there's no way a user of this can determine the type `a', by type inference
11:10:13 <ski> (also not by explicit type ascription)
11:10:16 <clrnd> ski, but here, read need's a type, while isJust can get away with any type
11:10:27 <hth313> ski: but does it need to know? All I am asking for is whether it is Just or Nothing
11:10:58 <ski> clrnd : possibly the given `A' input could contain a `Nothing' or a `Just ...', depending on which type is chosen for `t'
11:11:04 <exio4> what it does may depend on the type
11:11:08 <ski> so, in general, you must determine the type `t'
11:11:23 <exio4> readMaybe and isJust for a concrete example
11:11:26 <ski> hth313 : yes, it needs to know
11:11:49 <ski> hth313 : whether it's `Just ...' or `Nothing' may depend on the type chosen
11:12:03 <ski> (at least in the general case. not sure about your particular case, but possibly)
11:12:05 <hth313> ski: but why does it not need to know with Num?
11:12:40 <ski> it may be that it just started to look at `C' and found a problem there
11:12:52 <clrnd> if you remove the C constraint it typechecks
11:13:18 <ski> but i think it's more likely that it can handle the `Num' by using a default type, but that doesn't work for `C', since you have no instances of `C'
11:13:51 <ski> with only `Num', presumably it uses `Integer' for `t'
11:13:54 <clrnd> if you define a random instance for C, then it complains that it can't choose Num (and suggests it's many instances)
11:13:58 <ski> .. but there's no `C Integer' instance ..
11:16:42 <hth313> ski: if I add  'instance C Integer where  xx = (+)' it still gives the error but mentions there is a potential instance available
11:17:09 <zett_zelett> Hi. Where should I start looking if I’m interested in using category theory and monads for the theory of programming languages?
11:17:10 <ski> gives which error ?
11:17:29 <ski> zett_zelett : look into Eugenio Moggi's work, perhaps ?
11:17:32 <zett_zelett> I once downloaded ‘Notions of computation and monads’ from Eugenio Moggi. Is this a classic?
11:17:42 * hackagebot prologue 1.0.1 - Replacement for the Haskell's Prelude, exposing more commonly used functions and patching old GHC ones to behave in the newest GHC's way.  https://hackage.haskell.org/package/prologue-1.0.1 (danilo2)
11:17:45 <zett_zelett> Is there something more modern I should look into?
11:17:51 <zett_zelett> by*
11:17:54 <clrnd> ski, it says `No instance for (Num a0) arising from a use of ‘afield’`
11:18:24 <hth313> ski: same error, but it mentions there is a potential instance available, but does not take it (I can understand why it does that, there could be more that are invisible to the module)
11:20:53 <Copperis> zett_zelett, I watched 1 (one) Steve Awodey's lecture on the matter. Seemed interesting and beneficial. There's more of them too
11:22:26 <ski> zett_zelett : i suppose you might also try asking ##typetheory. or perhaps #coq,#agda and similar
11:22:42 * hackagebot streaming-utils 0.1.2.0 - http, attoparsec, pipes and conduit utilities for the streaming libraries  https://hackage.haskell.org/package/streaming-utils-0.1.2.0 (MichaelThompson)
11:22:53 <Copperis> zett_zelett, https://www.youtube.com/playlist?list=PLGCr8P_YncjVjwAxrifKgcQYtbZ3zuPlb
11:23:21 <zett_zelett> Okay, great. Thanks! @ski, @Copperis
11:23:49 * ski notes that it's not IRC custom to prepend nicknames with `@' when addressing them
11:24:11 <zett_zelett> ski: Yeah, but is it bad?
11:24:34 <ski> it looks weird, imho
11:24:35 <clrnd> twitter won
11:24:49 <KaneTW> slack won
11:25:00 <zett_zelett> That’s from math.stackexchange, actually. Not from twitter. (Though they might have taken it from twitter, of course.)
11:25:16 <KaneTW> twitter took it from somewhere too i think
11:25:23 <zett_zelett> I should probably give credits to stackoverflow, they were there first.
11:25:40 <glguy> The @ will also trigger a bot command when it's the first character of a line, which is a common place to put a nick
11:25:50 <clrnd> my mom uses @, so twitter won
11:25:51 <monochrom> no, you all got it wrong. youtube got there first. youtube won. :)
11:25:56 <KaneTW> cyclic dependency graph
11:26:18 <KaneTW> where's that link to that comic with "who was first? the phd or the phd advisor"
11:26:32 <ski> zett_zelett : .. i don't know if you consider me emitting a note like that above every time i notice someone doing it on IRC bad
11:26:55 <SrPx> I've ran stack install without issue, but I can't import the packages installed from haskell files using GHC alone. How can I ask Stack to install the packages on my machine?
11:27:03 <ski> KaneTW : dunno, but i suppose it might have been Piled Higher and Deeper ?
11:27:17 <KaneTW> probably yeah
11:27:40 <clrnd> SrPx, stack ghci ?
11:29:28 <SrPx> clrnd: pardon? 
11:29:34 <SrPx> stack ghci fails anyway: http://stackoverflow.com/questions/33288131/stack-ghci-fails-when-you-include-a-project-which-imports-gloss
11:29:38 <hth313> ski: Thanks! I will get back to using an explicit instance then, good to know there is no easy way around it. (Still a bit puzzled why GHC is fine with Num constraint though, but I will leave that for now)
11:30:29 <ski> hth313 : another question might be why you're using `isJust' in the first place ..
11:32:20 <ski> (i mean, sometimes it's reasonable. but sometimes it suggests some reformulation)
11:33:29 <clrnd> SrPx, what did you do and what are you trying to accomplish?
11:33:56 <Yuras> hey, can anyone recommend writer-biased multi-reader lock implementation?
11:35:25 <Cale> Yuras: Any reason a simple MVar won't work?
11:35:41 <hth313> ski: hmmm, not sure I understand that. I have a Maybe on an open word/entity being defined (written to), I want a function that can test if it is open to be written to.
11:35:46 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.8.1.0/Control-Concurrent-MVar.html
11:36:20 <Yuras> Cale: I want multiple readers to acquire lock at the same time
11:36:32 <Cale> Yuras: You can use readMVar which won't lock the MVar
11:36:55 <Cale> Yuras: and multiple readers waiting on a readMVar which is initially empty will be woken up at the same time when it is filled.
11:37:32 <SrPx> clrnd: I installed some libraries using stack install and I want to do quick tests of them in a random file
11:37:40 <hth313> ski: source is on github, but it would be a lot to dig into
11:37:45 <Yuras> Cale: you are saying like "go and implement it yourself" :)
11:37:47 <Cale> The writer can takeMVar, which will temporarily empty the MVar, causing readers to block when they try to read it
11:37:58 <Cale> and then putMVar when it is done computing the new value
11:38:05 <clrnd> SrPx, oh maybe you want `stack ghc`
11:38:08 <Cale> and all the readers which got blocked will wake up
11:38:21 <Cale> I'm not saying implement it yourself, these things are already in the library :)
11:38:32 <SrPx> that helps, thanks clrnd
11:38:57 <SrPx> Now if anyone has any idea how to fix ghci I'll be terribly glad, although that looks like the kind of problem I just give up of ghci altogether :(
11:38:58 <Yuras> Cale: does it prevent writer starvation?
11:39:38 <Cale> Yuras: readMVar never locks a filled MVar
11:39:51 <Cale> (it doesn't empty the MVar, in other words, even temporarily)
11:40:17 <Cale> So, you can have as many readers as you like -- only writers will get in the way of each other.
11:40:43 <Cale> (or threads which otherwise use takeMVar which empties the MVar, causing anything else which tries to do so to block)
11:41:12 <Yuras> Cale: hmm, then I don't see how writers will wait for readers to release the lock
11:41:20 <Yuras> Cale: it is now that simple
11:41:21 <Cale> The readers don't take locks
11:41:24 <haskell663> hello people!can someone help me with some haskell questions
11:41:36 <Cale> So long as they're using readMVar
11:41:53 <clrnd> haskell663, I may try
11:42:18 <Yuras> Cale: but writer should not be able to acquire the lock when there are readers
11:42:29 <Cale> why?
11:42:38 <Yuras> Cale: https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock
11:42:52 <Cale> You can't write a partial value to an MVar ever
11:42:56 <haskell663> ok here is the question "For each of the following haskell type declarations,declare an object of the type this"
11:43:05 <Cale> In fact, all that *really* gets written is a pointer to code
11:43:12 <Cale> and that happens atomically
11:43:17 <haskell663> a. type this= [(Float,Bool)]
11:43:22 <clrnd> haskell663, lpaste.net
11:43:26 <Cale> so you don't worry about readers observing half-written values here
11:43:34 <Cale> that can't happen
11:43:46 <Ongy> Hi, I took the netlink package (https://hackage.haskell.org/package/netlink) and forked it because it lacks funcionality, when I want to get it on hackage, do I have to contact the current maintainer?
11:44:18 <Ongy> The other thing I am wondering is whether I should split the package, since it is getting rather lager (spcifically moving NL80211 to its own package) https://github.com/ongy/netlink-hs
11:44:22 <davean> Ongy: Not if you upload it as a new package
11:44:30 <Yuras> Cale: the lock is used to manage access to some big mutable data, e.g. key/value database in my case
11:44:48 <Yuras> Cale: I can't store data inside the MVar
11:44:52 <Cale> ah, okay
11:45:00 <davean> Ongy: If you don't at least try to contribute the changes back to the main package though, you're really obnocious
11:45:09 <davean> To both the maintainer and the community
11:45:26 <Cale> So you just want basically a semaphore?
11:45:47 <davean> Ongy: if the maintainer is not available, there is a procedure for replacing the package
11:47:00 <Ongy> davean: yeah I just noticed that that would be the thing to do anyways, I didn't think to much about it since I rewrote pretty much all of it
11:47:54 <Yuras> Cale: hmm, not precisely. only one thread should be able to modify data at the same time, but multiple threads can read data unless someone is modifying it
11:48:06 <wlad> hey, guys, could you help me out with this function: withFile "io.txt" ReadMode (\h -> putStrLn $ ????? hGetContents h)
11:48:16 <wlad> I'm not sure what to place instead of "??????"
11:48:36 <wlad> Is there a way to bind whatever type IO action has *and* print it at the same time?
11:48:44 <Cale> Yuras: Okay, so suppose we use an MVar (), which is full when nobody is modifying data, and empty when a writer is working.
11:49:22 <Cale> Yuras: i.e. the writer will takeMVar r before doing whatever it needs to do to the database, and then writeMVar r () when it is done
11:49:43 <arkeet> :t hGetContents ?h >>= putStrLn
11:49:44 <lambdabot>     Not in scope: ‘hGetContents’
11:49:44 <lambdabot>     Perhaps you meant one of these:
11:49:44 <lambdabot>       ‘BSC.hGetContents’ (imported from Data.ByteString.Char8),
11:50:16 <arkeet> :t putStrLn
11:50:18 <lambdabot> String -> IO ()
11:50:41 <kallisti> wlad: to do it all on one line you can use the <* combinator as in:   do { x <- someAction <* print; ... }
11:50:48 <kallisti> :t (<*)
11:50:49 <lambdabot> Applicative f => f a -> f b -> f a
11:50:57 <kallisti> er sorry
11:51:19 <kallisti> that won't work. I don't remember the parameterized version of that combinator.
11:51:21 <Cale> hmm, I guess the readers need a way to signal that they're reading, because readMVar r, while it will block if the MVar () is empty (i.e. currently being written), there will be a moment before the reader goes and *actually* reads the external database or whatever, where you don't want to start a write
11:51:32 <wlad> :t GHC.IO.Handle.Text.hGetContents
11:51:34 <lambdabot> GHC.IO.Handle.Types.Handle -> IO String
11:51:48 <arkeet> :t GHC.IO.Handle.Text.hGetContents ?h >>= putStrLn
11:51:49 <lambdabot> (?h::GHC.IO.Handle.Types.Handle) => IO ()
11:51:53 <kallisti> wlad: but if you wrote say:   do { x <- someAction; return (x <* print x) }
11:51:56 <Yuras> Cale: it is easier to implement it via STM because you need two vars for minimize wake-ups
11:51:57 <Cale> So you need a second MVar () to signal that. Maybe someone's done it and packaged it up as an abstraction already.
11:52:07 <arkeet> kallisti: that sounds like a type error.
11:52:20 <Cale> Yeah, or STM TMVars would work well, right.
11:52:21 <kallisti> wlad:  do { x <- someAction; return x <* print x; }  -- bare with me. :)
11:53:01 <fizruk> :t (<$)
11:53:02 <lambdabot> Functor f => a -> f b -> f a
11:53:10 <Cale> http://hackage.haskell.org/package/concurrent-extra-0.7.0.9/docs/Control-Concurrent-ReadWriteLock.html
11:53:16 <Cale> ^^ someone did one here :)
11:53:19 <wlad> kallisti: I'm sorry, I've only read half of LYAH, so this is unknown to me. Could you explain what "<*" does?
11:53:35 <kallisti> wlad: do you know what >> does?
11:53:41 <Yuras> Cale: it is not writer-biased
11:53:52 <fizruk> @src (<*)
11:53:52 <lambdabot> (<*) = liftA2 const
11:54:01 <Yuras> Cale: https://github.com/basvandijk/concurrent-extra/issues/7
11:54:17 <wlad> kallisti: I've only heard about >>= operator. Has something to do with monads? A binding operator I think?
11:54:26 <kallisti> wlad:  it does the same thing as a >> b, except that the result is  a instead of b.  so the "b" is only execute for its side-effect
11:54:38 <kallisti> wlad: a >> b is equivalent to do {a; b}
11:54:48 <kallisti> "do this, then do that"
11:55:08 <wlad> kallisti: do curly brackts just "group" those statements?
11:55:13 <kallisti> <* is "do this, then do that, but give the first thing instead of the second"
11:55:15 <wlad> like they would in C?
11:55:26 <wlad> Oh, I see
11:55:34 <kallisti> wlad: yes identation in Haskell layout can be converted to { } and newlines can be converted to ;
11:55:58 <kallisti> it's valid Haskell syntax, and very convenient when you're limited to the single line of text that IRC provides. :)
11:55:59 <kadoban> wlad: This use of {} in haskell is just to avoid newlines and whitespace. It doesn't create a block or anything weird like it does in C.
11:56:06 <Cale> Yuras: ah, okay, I haven't actually used this library. I suppose it needs a 4th state that it can be in, where it's in Read mode and a writer is waiting.
11:56:08 <wlad> kallisti: ok, got this one
11:56:49 <wlad> kallisti: so "<*" alters the default behaviour of returning the last action, right?
11:57:07 <Yuras> Cale: yes, it is absolutely not trivial, that is why I want to replace my self-made solution with something better :)
11:57:36 <kadoban> It doesn't so much alter anything, it's just an operator that has different meaning than other possible operators that combine actions.
11:57:47 <wlad> what if I wrote simply "print x; return x" ? Would it be different?
11:57:57 <kallisti> wlad: "a <* b" is exactly like writing:     do { x <- a; b; return x; }
11:58:10 <wlad> Ohhhh
11:58:12 <wlad> I got it
11:58:24 <wlad> Thanks, I'll try it out
11:59:12 <kallisti> @hoogle m a -> (a -> m b) -> m a
11:59:14 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
11:59:14 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
11:59:14 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
11:59:47 <kallisti> guess there's not a combinator for that
12:00:15 <kallisti> hayoo has some stuff, but nothing in base
12:02:31 <kallisti> wlad: so the idea with <* is that you want to action 1, whose result you're interested in, and some side-effect action 2, whose non-side-effect result is not interesting.
12:02:46 <Cale> Yuras: http://hackage.haskell.org/package/rwlock -- there's a very simple implementation here which again doesn't have the feature you want, but might be a good starting point -- you could add a new constructor to RWLockState:  data RWLockState = ... | Waiting Int  (where the Int is the number of readers we're waiting for), and then adjust the definition of {add,del}{Reader,Writer} to account for that.
12:03:47 <kallisti> wlad:  readFile someFilePath <* putStrLn ("Reading file: " ++ show someFilePath)
12:05:37 <kallisti> wlad:  binding that action with <- will give you the contents of the file, but will also print a message to stdout after the file is finished reading
12:06:19 <wlad> kallitsi: Do you know where I could read about combinators in general and this in particular? ghci doesn't know what "<*" is :(
12:06:33 <kallisti> hm, what GHC version are you using?
12:06:37 <wlad> But I kinda got the concept
12:06:39 <wlad> Just a sec
12:06:49 <wlad> it says 7.6.3
12:06:54 <kallisti> (<*) is defined in Control.Applicative, but I'm pretty sure it was recently moved to Prelude
12:06:56 <kallisti> ah yeah
12:06:57 <Yuras> Cale: hmm, I don't think it will fly, you can't wait for readers to exit without escaping STM -- it is a transaction.
12:07:19 <kallisti> well, I'd highly recommend getting GHC 7.10.2, but, for now, you just want to import Control.Applicative
12:07:31 <kallisti> or, in ghci:  :m + Control.Applicative
12:07:33 <Yuras> Cale: probably RWLock makes no sense with STM API
12:07:43 <Cale> Yuras: You're generally going to leave STM on a regular basis.
12:07:54 <Cale> Yuras: STM transactions are supposed to be short in general
12:08:37 <Cale> and since they can't do any I/O, you wouldn't be able to access your external database without leaving STM anyway
12:09:03 <Cale> It's just the operations on the RWLocks which will be transactions
12:09:30 <kallisti> wlad: "combinator" is just a fancy word for a function. Usually a higher-order function.
12:09:58 <Cale> The real external interface of this library is mostly: newRWLockIO, withReadLock, withWriteLock
12:10:18 <wlad> Oh, ok
12:10:52 <kallisti> "combinator" usually implies that you're eliminating the need to explicitly define variables or function parameters, based on the terms origins in combinatory logic.
12:10:58 <Yuras> Cale: takeWriteLock is a STM transaction. I can't change RWLockState to "Writers Int" and wait for readers inside the same transaction
12:11:10 <kallisti> (.) for example is a combinator
12:11:15 <Yuras> Cale: yes, there is IO API, but it uses STM API
12:11:29 <Yuras> Cale: it means I need to reimplement it completely
12:11:33 <kallisti> the fact that it's an infix operator is not what makes it a combinator though. infix operators just happen to be convenient for that purpose.
12:13:47 <Cale> Yuras: Well, it's currently using waitForTrue, which retries the transaction until the STM Bool is True
12:14:00 <kallisti> wlad: sorry I was originally assuming you had more experience with monads. without using any fancy operators what you would want looks like:   do { x <- someAction; print x; return x }
12:14:53 <Yuras> Cale: but readers will never notice that someone requested writer lock --> writer starvation
12:15:51 <wlad> kallisti: thanks, a simpler solution works. Now I'll try to wrap my head around combinators
12:16:16 <kallisti> wlad: if you're doing IO in LYAH you've probably seen an example of two combinators already: . and $
12:17:18 <wlad> kallisti: Yes, although I don't think author says what they're called
12:17:29 <wlad> I mean, he doesn't mention that they're combinators
12:18:14 <kallisti> well, the word "combinator" doesn't have any special meaning to Haskell semantics, so it probably only serves to confuse people who are learning. :P
12:18:40 <fryguybob> Yuras: Why do you say that readers will never notice?  New readers would block until the state was Open or Readers.
12:18:42 <kallisti> just assume I said "higher-order function"
12:19:52 <Cale> Yuras: That's why I'm saying you need a new constructor in the RWLockState type where attempting to take a Read lock in the state Waiting n will fail, while putting a read lock will succeed, changing to state Waiting (n-1).
12:21:31 <Yuras> fryguybob: while writer is waiting for lock, no readers are allowed to acquire the lock (writer-biased), so writer should 1) change lock state to prevent new readers to enter 2) wait for all existent readers to exit. That is impossible in one transaction
12:21:35 <Cale> Yuras: Attempting to take a Write lock while in state Readers n will change to state Waiting n, commit the transaction, and then immediately try again (in IO) -- so that's a little different from what's already in the library, might require some reworking.
12:22:26 <Yuras> Cale: yes, it should work via IO. I didn't find a way to implement it without uninterruptibleMask...
12:23:20 <Yuras> Cale: because you want to change the state back to Open or Readers on async exception while waiting for readers
12:23:21 <kallisti> @pl do { x <- printFile f; return x <* print x }
12:23:21 <lambdabot> (line 1, column 4):
12:23:21 <lambdabot> unexpected '{'
12:23:21 <lambdabot> expecting variable, "(", operator or end of input
12:23:36 <kallisti> @pl printFile f >>= \x ->  return x <* print x
12:23:36 <lambdabot> liftM2 (<*) return print =<< printFile f
12:24:01 <Yuras> Cale: that is like cryptography -- there is a number of simple but wrong ways to implement it
12:24:02 <kallisti> How to Make Simple Things Complicates: The Guide
12:24:06 <kallisti> *complicated
12:24:52 <Cale> hmm, well, bracket should already take care of that
12:25:18 <Cale> If an exception occurs in the bracketed action, it'll still execute the cleanup action
12:25:53 <kallisti> bracket is the same idea as "with" in Python or "using" in C#
12:25:59 <kallisti> without the OO part
12:26:05 <Yuras> Cale: except when async exception comes while executing the cleanup action :)
12:26:32 <kallisti> there is only so much defensive code you can write
12:26:33 <monochrom> but the cleanup action is run under masking
12:27:19 <Yuras> monochrom: STM transaction is interruptible is retries. and I can't prove it will never retry
12:27:30 <Yuras> *if retries
12:28:45 <monochrom> I see
12:30:53 <kallisti> wlad: http://lpaste.net/143641  let me know if this makes sense
12:39:09 <sinelaw> conal, there now?
12:39:29 <wlad> kallisti: it says "No instance for (Show a) arising from a use of `print". Do I have to update ghci?
12:39:58 <kallisti> nope. just forgot to add that to the type signature
12:40:33 <kallisti> wlad: http://lpaste.net/143641
12:41:40 <kallisti> wlad: should just let GHC infer the types for me. it's usually better at it than I am. :P
12:44:01 <kallisti> wlad: so that's the shorthand way of making a "do this action, print the result, return the result" but it has a flaw because of that simplicity.
12:44:33 <kallisti> that flaw being that it MUST have an "IO a" as an argument. We can't use any old "a"
12:45:11 <SrPx> ghc-pkg tells me there could be broken packages and asks me to use "ghc-check". I do, it gives me a huge list of broken packages. Suggests no action. What should I do?
12:45:23 <kallisti> nuke it
12:45:27 <SrPx> "ghc-pkg check"
12:45:32 <SrPx> how?
12:46:33 <kallisti> let me look it up. haven't done it in a while
12:46:47 <wlad> kallisti: thanks!
12:47:18 <wangslanger> FUCK HASKELL
12:47:21 <kallisti> SrPx: https://gist.github.com/simonmichael/1185421  this should work
12:47:42 <voidzero> wangslanger, got that out of your system?
12:47:56 <wangslanger> yeah haskell is actually pretty cool tbh
12:47:57 <kallisti> SrPx: running ghc-pkg-clean will unregister all the stuff that ghc-pkg check reports
12:48:12 <kallisti> SrPx: ghc-pkg-reset will nuke the whole thing
12:48:24 <dmj> wangslanger: Haskell is nice
12:48:44 <kallisti> people like Haskell in the #haskell channel? amazing
12:49:02 * voidzero throws a golden apple at kallisti
12:49:14 <voidzero> * thunk *
12:49:19 <kallisti> SrPx:  this is a big problem with the GHC package system, which is that it's a global (or per-user) collection of packages, and you can't have multiple versions of the same package.
12:49:43 <kallisti> SrPx: to work around that we have tools. in the future when installing stuff you might want to try using a cabal sandbox
12:50:26 <kallisti> run "cabal sandbox init" while in the directory of your cabal package and now when you run "cabal install" it will instead install everything in a local sandbox rather than the user-wide ghc package system
12:50:56 <SrPx> I'm using stack now, but I'm still concerned the fact my system is messed up. ghc-pkg-clean for some reason didn't get rid of the reports. Nuked it all. Whatever.
12:51:16 <SrPx> Is it okay if I never run cabal install anymore and just use stack?
12:51:16 <kallisti> before we had proper sandboxing, that was often the solution. :P
12:51:38 <SrPx> kallisti: stack? I thought that was supposed to be better than sandboxing
12:51:44 <kallisti> I haven't used stack much myself, but people seem to like using it exclusively.
12:51:48 <kallisti> well stack just does the sandbox for you
12:51:52 <kallisti> as far as I know
12:52:01 <bitemyapp> SrPx: stack's sandboxing is a bit better managed than what most people do with Cabal sandboxes.
12:52:08 <kallisti> it basically does everything so that you don't accidentally shoot yourself in the foot. :P
12:52:10 <bitemyapp> SrPx: you can switch if you want, but if things are working for you already, you don't need to.
12:52:19 <SrPx> certainly better than what I could do
12:52:42 <anelson> hey guys, I'm having an issue in emacs haskell-mode where if it detect some syntax error ("illegal token" or whatever) it refuses to let me type anything. When this happens, I have to turn off haskell-mode to edit my file. Has anyone encountered this?
12:53:10 <SrPx> anyway, running "stack ghc Image/src/Image.hs" (a module that exports the Image constructor) works fine, but :t Image says Image is undefined. Why isn't ghci loading the file?
12:53:16 <SrPx> stack ghci*
12:53:51 <kallisti> I think when you use "stack ghc" you're not actually putting the file into a real package
12:54:34 <SrPx> No, I ran stack install (which includes the Image package and worked correctly) then `stack ghci .../Image.hs` (to test it)
12:54:43 <kallisti> what "stack ghci" does is start up ghci and then automatically import whatever stuff your package has.
12:55:03 <kallisti> I probably shouldn't try to give advice with stack since I've literally never used it, huh. :P
12:55:17 <SrPx> So why didn't it import anything that is part of the package? 
12:56:30 <SrPx> My only problem with stack right now is that running "stack build" anytime I modify a file takes way too long to even give me the error messages. I do not understand, how do you guys do it?
12:57:23 <SrPx> I have a "stackEnv" dir with many directories, each one including a package, some directories depend on others, etc. If I modify a single character on the Image package, it rebuilds everything basically. Which makes sense, but I just want the errors, not to actually build it
12:57:50 <kallisti> the argument to stack ghci should be the project name not a module
12:58:00 <orcus> How come Data.Type.Equality is not marked as Trustworthy?
13:00:35 <SrPx> Thanks kallisti ... stack ghci Image works, but...
13:00:59 <SrPx> Now I get errors that I shouldn't be getting. http://lpaste.net/143645 How can there be errors on the library if it compiles fine (for example, I can use it from another module)
13:01:00 <SrPx> wt
13:01:14 <lpaste> Cale pasted “my attempt at RWLock” at http://lpaste.net/143647
13:01:23 <Cale> Yuras: ^^
13:02:28 <Cale> Yuras: test that out, see if it works, I threw it together hastily in between compiles on another thing and I haven't tested it really thoroughly, so there might be some oversights, but I think it's close to what you want :)
13:02:56 <kallisti> SrPx: you may need to stack install again.
13:03:20 <kallisti> remember it's using your installed Image package, not whatever your Image.hs source happens to be at the time (or at least I think that's how it works)
13:03:56 <kallisti> if you just want to load the current source in ghci you can always just use :l in ghci
13:04:00 <kallisti> and save that to a .ghci file
13:05:09 <Cale> Yuras: There's just the one complication of what happens when you go from readers to waiting -- you need to commit the transaction to go into the waiting state and then immediately try taking the write lock again.
13:05:25 <Cale> (which will then proceed to block until all the readers are done)
13:09:07 <TallerGhostWalt_> if I have foo::(KnownNat i) => a -> (Proxy i) can I use natVal or something else to get the value of i inside of foo?
13:10:34 <Cale> TallerGhostWalt_: You might have to use an explicit  forall a i.  in the type signature, but yes
13:10:35 <Yuras> Cale: I think there is a number of races here
13:10:42 <Cale> Yuras: where/
13:10:43 <Cale> ?
13:11:27 <lpaste> Yuras pasted “RWLock” at http://lpaste.net/143648
13:11:51 <Yuras> Cale: ^^ my implementation, not sure it is correct either
13:12:00 <TallerGhostWalt_> Cale: I don't mind using whatever I just can't figure out how to get the output into a scope where I could use it 
13:12:10 <Cale> Where do you think there's a race in my implementation? I might be blind to something :)
13:12:22 <Cale> But there's not a lot of room for races in my code.
13:13:19 <Cale> TallerGhostWalt_: You just write (Proxy :: Proxy i)
13:13:35 <Cale> TallerGhostWalt_: you can apply natVal to that
13:13:58 <Cale> If you use an explicit forall, then the type variable i is in scope, so it shouldn't be a problem.
13:14:15 <TallerGhostWalt_> Cale: okay so the forall will prevent the i0, i problem?
13:14:26 <Cale> yeah
13:14:45 <Yuras> Cale: in your implementation, takeWriteLock in not atomic -- in consists of two steps. if async exception comes between them, the lock will stay in "Waiting n" state.
13:14:55 <Yuras> Cale: I'm not 100% sure though
13:15:18 <Yuras> Cale: it is hard to do right
13:16:02 <Cale> Ah, I see, right, we just need delWriter to handle that case
13:16:03 <Yuras> that is why I asked for existing implementation. if it doesn't exist, I'll stay with my olw one
13:16:09 <Cale> and put it back into the Readers state
13:16:37 <Cale> delWriter (Waiting n) = (Readers n, done)
13:17:36 <Cale> That way, when the async exception comes to the waiting writer thread, it will putWriteLock, and drop the lock back into the Readers state
13:18:29 <douchemonkey69> fuck haskell
13:18:36 --- mode: ChanServ set +o Cale
13:18:41 --- mode: Cale set +b *!*@gateway/web/freenode/ip.173.250.159.249
13:18:42 --- kick: douchemonkey69 was kicked by Cale (douchemonkey69)
13:18:45 --- mode: Cale set -o Cale
13:19:05 <superturrican> :^)
13:19:11 <TallerGhostWalt_> Cale: yep worked thanks,
13:20:28 <ganzzahl> I'm trying to learn Haskell, and it's really a nice language--I like it's syntax and principles, but I'm a bit stuck as to what kind of larger programs to try to make.
13:20:37 <ganzzahl> What kinds of programs would be good to try?
13:20:58 <Cale> ganzzahl: That really depends on what sort of person you are as well :)
13:21:11 <Cale> ganzzahl: Haskell is fairly general purpose, so really almost anything.
13:22:10 <Yuras> Cale: OK, now the only issue I see is that putWriteLock can be interrupted by async exception. but it is probably unsolvable without uninterruptibleMask
13:22:31 <dmj> ganzzahl: making a website is a good practical way to learn haskell
13:22:33 <Yuras> Cale: (though it doesn't mean there are no issues still :) )
13:22:39 <Cale> Yuras: wait, isn't that exactly the issue I just dealt with?
13:23:50 <Yuras> Cale: hmm, I think no. it was an issue with takeWriteLock, now with putWriteLock
13:24:00 <Cale> oh, right, it was
13:24:07 <Cale> lemme think about that
13:24:50 <ganzzahl> Cale: Ok, I guess I didn't know exactly what scope it is used for, but apparently the answer is anything?
13:25:08 <KaneTW> pretty much
13:25:21 <Cale> Yuras: I'm not sure that can happen, actually
13:25:39 <KaneTW> ganzzahl: do you have some ideas
13:25:50 <Cale> Yuras: Let me look at the source for bracket... I'm pretty sure the cleanup is protected from getting exceptions.
13:26:06 <Cale> yeah, exceptions are masked
13:27:09 <Yuras> Cale: you should prove putWriteLock is not interruptible
13:27:27 <ganzzahl> KaneTW: pretty much, no. :( A fun one might be an interpreter for a simple toy language
13:27:36 <Cale> You can't actually run putWriteLock yourself, and can only use withWriteLock, which uses putWriteLock inside a bracket
13:27:43 <Cale> and bracket masks the exceptions
13:28:23 <meretrix> ugh.. my Haskell application works perfectly, but when I run it inside Docker, the networking library I'm using is silently failing to create a socket connection. Any idea where to begin debugging?
13:28:32 <meretrix> All of my other Haskell applications play nice with Docker..
13:29:12 <Yuras> Cale: async exceptions can be thrown under mask if an action in interruptible. "mask" is not enough, you need "uninterruptibleMask"
13:29:40 <Yuras> Cale: https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Exception.html#g:13
13:31:28 <KaneTW> ganzzahl: that's a good idea
13:31:43 <KaneTW> check out (mega)parsec as a starting point
13:31:49 <KaneTW> the rest should follow pretty easily
13:32:28 <Yuras> Cale: probably putWriteLock is not interruptible actually because nobody can change lock state at this point. But putReadLock is interruptible, I'm almost sure
13:32:33 <ganzzahl> Literally, I couldn't come up with any ideas I liked until after I asked the question... :) Thanks!
13:33:12 <Cale> Yuras: hmm
13:35:02 <ganzzahl> KaneTW: megaparsec looks really useful, thanks!
13:41:48 <Cale> Yuras: I think *maybe* there's a problem in the case where something is spamming async exceptions. I'm reasonably sure that any single async exception can't cause a problem, but I'm not sure what happens when you're handling an exception and you get another one.
13:47:35 <Yuras> Cale: e.g. takeReadLock succeed, bracket body succeeded, putReadLock blocks in transaction and at this moment user presses C-C. The transaction is aborted living the lock in "Readers 1" state
13:48:24 <Cale> Yuras: It can't block in the transaction though
13:48:43 <Cale> It only retries in the case that the state is not Readers or Waiting
13:49:26 <Cale> and since the takeReadLock succeeded, and we haven't executed the corresponding putReadLock yet, it must be in one of these two states
13:49:55 <Yuras> Cale: it can retry on transaction commit if someone changed lock state, e.g. other reader changed state from "Reader 1" to "Reader 2"
13:50:10 <Yuras> Cale: at least that is my understanding
13:50:29 <Cale> ah, you might be right :)
13:50:39 <Cale> Okay, so what happens then
13:51:41 <Profpatsch> Is there a typeclass for types, where a mean can be calculated between two values?
13:52:18 <Profpatsch> Something like instance Meanable Float where mean a b = a + b / 2
13:52:40 <Yuras> Cale: AFAIK any pending async exception will abort the transaction at this moment
13:52:45 <Cale> Profpatsch: I believe someone has a class for affine combinations.
13:53:38 <Cale> Profpatsch: ah, the thing I was thinking of was just a part of the Colour library though
13:53:41 <Cale> http://hackage.haskell.org/package/colour-2.3.3/docs/Data-Colour.html#t:AffineSpace
13:53:56 <ttt_fff> https://hackage.haskell.org/package/these-0.6.1.0/docs/Data-Align.html . In Data.align, if we get a "These a b" is it guaranteed that lhs != rhs ?
13:54:05 <ttt_fff> Is it ever possible that we get "These x x" ?
13:54:16 <Ongy> davean: so I emailed the current maintainer and he didn't even remember he was maintainer and asked me what I need to take over maintainer position
13:54:36 <Ongy> which is pretty much what I expected since he didn't commit anything in 3 years
13:54:42 <Profpatsch> Cale: Oh, so mean can be seen as an affine combination?
13:54:49 <davean> just have him as you to the maintainer/uploaded group
13:54:51 <Cale> ttt_fff: yes, of course it's possible for the values to be the same
13:55:03 <davean> then do an upload! that's it
13:55:05 <Cale> Profpatsch: yeah, just with equal weights
13:55:08 <ttt_fff> Cale: hmm, so Data.Align doesn't return a 'diff' ?
13:55:41 <Profpatsch> Cale: Ha, I see.
13:56:01 <Cale> ttt_fff: Well, it works with things of arbitrary, possibly different types
13:56:36 <Cale> ttt_fff: So you know for certain that it won't do any comparisons between those values, because in general they could have completely different types -- it also doesn't know that there's an instance of Eq
13:57:14 <Cale> ttt_fff: So if both structures happened to have the same value at the same location, you'll get These x x
13:57:45 <Cale> x might not even be of a type which is an instance of Eq -- it might be a function or an IO action, for example.
13:58:00 <davean> Ongy:
13:58:14 <JagaJaga> I have gtk application. What's the best way to localize it?
13:59:32 <Profpatsch> JagaJaga: Generally with po files, because they are supported everywhere.
13:59:44 <JagaJaga> Profpatsch: thank you. Will google that.
13:59:53 <Profpatsch> No idea how to integrate them with Haskell, though.
14:00:00 <JagaJaga> Profpatsch: found http://progandprog.blogspot.nl/2009/04/multilingual-ui-and-dynamic-language.html
14:02:42 <Profpatsch> JagaJaga: https://wiki.haskell.org/Internationalization_of_Haskell_programs
14:02:55 <JagaJaga> Profpatsch: that's where I am! :)
14:06:17 <gfixler> > "foo" >>= \x -> Identity (if length x > 2 then True else False)
14:06:19 <lambdabot>      Couldn't match type ‘Identity’ with ‘[]’
14:06:19 <lambdabot>      Expected type: [Bool]
14:06:19 <lambdabot>        Actual type: Identity Bool
14:06:37 <gfixler> > Identity "foo" >>= \x -> Identity (if length x > 2 then True else False)
14:06:39 <lambdabot>  Identity True
14:06:45 <gfixler> is this an example of monadic sequencing?
14:07:03 <gfixler> i.e. the thing you can't do with Applicatives
14:07:25 <gfixler> > pure (\x -> if length x > 2 then True else False) <*> Identity "foo"
14:07:27 <lambdabot>  Identity True
14:07:37 <gfixler> that does the same thing, but I'm guessing it's not really sequencing
14:07:45 <gfixler> and I'd like to understand that better
14:08:14 <gfixler> the whole "monads allow you to sequence/depend on previous values" thing has never quite made it into my skull
14:08:52 <arkeet> :t (>>=)
14:08:53 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:09:08 <arkeet> the "m b" action is allowed to depend on the result of the first one.
14:09:14 <arkeet> that's it.
14:09:28 <arkeet> the type of >>= tells you exactly that.
14:10:15 <arkeet> :t (<*>) -- nothing here allows the actions to depend on results of other actions.
14:10:16 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:11:14 <gfixler> so in my applicative example, I've faked the sequencing by shoving it into the left side?
14:11:35 <arkeet> I don't know what "sequencing" means.
14:11:50 <gfixler> I think probably you do, and I don't :)
14:11:57 <gfixler> (I know what sequencing means, though)
14:12:14 <gfixler> I think I'm just confusing myself with a toy example that gives the same output
14:12:46 <arkeet> well ok, the fact that >>= is what it is implies that
14:12:59 <arkeet> the result(s) of the first action must be determined before the second one can be evaluated
14:13:15 <arkeet> (you can't get a "m b" without an "a")
14:13:21 <gfixler> right
14:13:58 <kallisti> has anyone figured out how to make cabal install test suite dependencies?
14:14:24 <kallisti> cabal does not fathom a world in which a test suite would have dependencies that are not included in the actual library
14:14:31 <gfixler> arkeet: I think some of the confusion stems from the way these things are talked about
14:14:34 <kallisti> and as a result neither does stack
14:14:55 <cocreature> > Just 1 >>= \x -> if x == 42 then Nothing else Just x
14:14:57 <lambdabot>  Just 1
14:15:11 <cocreature> ^ gfixler that's an example that you wan't do with applicatives
14:15:26 <arkeet> indeed
14:15:40 <cocreature> Identity is kind of a bad example since after all it's just Identity
14:15:46 <gfixler> cocreature: true
14:16:03 <cocreature> it gets more clear if you look at the types the other way around
14:16:05 <cocreature> :t fmap
14:16:07 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:16:08 <cocreature> :t (<*>)
14:16:10 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:16:10 <gfixler> if Identity is bad, so is talking about left and right sides "being run"
14:16:11 <cocreature> :t (=<<)
14:16:13 <lambdabot> Monad m => (a -> m b) -> m a -> m b
14:16:17 <gfixler> what if it's just Identity, or []?
14:16:28 <arkeet> gfixler: not really, it's just that "running" an Identity thing is a no-op.
14:16:38 <arkeet> or something.
14:16:44 <arkeet> (vague statement.)
14:18:51 <ttt_fff> Cale: thanks for explaining Data.Align
14:19:23 <ttt_fff> Cale: sounds like Data.Align does not do comparison on value, but has a notion of "location" (index in list, value associated with key) -- and asks, at this Location is it (1) left only, (2) right only, or (3) both has values. Is that corect?
14:19:27 <arkeet> I love Data.Align
14:19:37 <Cale> ttt_fff: that's right
14:19:49 <ttt_fff> Cale: thanks!
14:19:52 <gfixler> arkeet: I feel like we get upset saying "container" for these things
14:19:59 <gfixler> arkeet: but then flip around and use "running" for containers
14:20:24 <gfixler> that one has bugged me since the beginning
14:20:27 <arkeet> gfixler: it's just different views of the same thing, I suppose.
14:20:39 <arkeet> you can view [a] as a container that contains zero or more "a"s, 
14:20:41 <Cale> gfixler: It depends on whether you happen to be thinking of them as containers or computations at the time
14:20:43 <gfixler> arkeet: true, but always makes me pause and stare off into space, when I know what's really going on inside
14:20:44 <arkeet> or as a computation that produces zero or more "a"s
14:20:58 <gfixler> Cale: that's why I stare into space, trying to imagine that Identity is runnable
14:21:02 <gfixler> no-op is a good way to imagine it
14:21:16 <gfixler> although it does feel a bit like brain calisthenics
14:21:42 <Cale> gfixler: running a computation of type Identity a simply always results in a value of type a, with no effects or nondeterminism possible.
14:21:56 <Cale> (all you're doing is unpacking the Identity newtype constructor)
14:22:15 <gfixler> running seems often to go hand-in-hand with effects
14:22:17 <Profpatsch> Identity is the simplest possible functor. The one without structure.
14:22:21 <nshepperd> my preferred monad is IO. then you can see that f <*> m could be a computation that grabs a function from across the network, and then grabs a value from across the network, then finally applies the function to the value
14:22:28 <gfixler> I've heard phrases like "we run the left side to get its effects..."
14:22:43 <arkeet> I have no idea what "get" means there.
14:22:44 <nshepperd> and then you see how that function can't do network actions depending on the value
14:22:45 <gfixler> and I've heard this for things that I know have no effects, and again, staring into space, pondering
14:23:24 <gfixler> arkeet: "we run the left side for its effects" or "to allow its effects to happen"?
14:23:27 <nshepperd> the case with 'containers' is sort of analogous?
14:23:30 <arkeet> maybe?
14:23:38 <arkeet> actually I don't know what "for" means either.
14:23:51 <arkeet> or some "run" or "effects"
14:23:53 <arkeet> -some
14:24:07 <gfixler> we're losing words fast
14:24:10 <arkeet> yup
14:24:38 <gfixler> we also say "I don't know what X means" when we know what person means, but not how X could work in the given context
14:31:48 <haskell927> can i search a non binary tree with only using pattern matching and guards
14:32:59 <pyon> haskell927: And recursion.
14:33:18 <haskell927> yes 
14:35:22 <lspitzner> kallisti: `cabal install --dep --enable-t`
14:36:18 <kallisti> lspitzner: nope. doesn't work
14:36:42 <haskell927> pyon do you know if its possible ? searched stackexchange etc couldnt find anything
14:37:28 <pavonia> haskell927: Why do you think it isn't?
14:38:20 <Sindriava> Is there a language similar to Haskell in look & feel, that's OOP-oriented?
14:38:42 <ptd> haskell927: What does your non-binary tree look like? Can you show us the type declaration?
14:39:01 <arw> Sindriava: there is scala. 
14:39:11 <fizruk> Sindriava: F# comes to mind, also
14:39:18 <Sindriava> arw: I know, and I've tried it, but it's just… horrible.
14:39:28 <lspitzner> kallisti: ah sorry, i thought you wanted help.
14:39:28 <arw> Sindriava: but necessarily, there are certain larger differences, since oop and strict fp don't really go together that well.
14:39:46 <Profpatsch> arw: Sindriava Scala does not have the same look and feel.
14:39:49 <arw> Sindriava: at least i know of no language without certain compromises in one domain
14:40:05 <Sindriava> arw: Yeah, that's obvious. I just really like Haskell as a language (syntax & so on), but I miss OOP
14:40:11 <Profpatsch> Sindriava: If you combine FP with Subtyping you get Scala.
14:40:18 <Sindriava> fizruk: I've never dabbled in that. I'll have a look ^^
14:40:35 <Sindriava> I do love scala's mixins, though.
14:40:57 <Sindriava> but the tooling and community around it just put me off
14:41:01 <Profpatsch> heh
14:41:06 <nshepperd> ocaml... has oop... I've heard
14:41:23 <Profpatsch> #scala is one of the more depressing channels arount, yes.
14:41:26 <Profpatsch> *d
14:41:45 <arw> there are object systems for scheme. but it also always depends on your definition of oop.
14:41:51 <Profpatsch> nshepperd: I’ve read most people shun OOP in Ocaml
14:41:52 <Sindriava> Yeah. I wanted to get LWJLG up and running, which I failed to because of some obscure bug or something
14:42:02 <Sindriava> And #scala's response was "Yeah, scala sucks, you're fucked"
14:42:11 <Profpatsch> Sindriava: Exactly. :)
14:42:20 <Profpatsch> It’s funny because it’s true.
14:42:29 <nshepperd> is that because ocaml is bad or because oop is bad :)
14:42:39 <Profpatsch> nshepperd: Hm, I’d suspect the latter.
14:42:45 <Sindriava> nshepperd: Neither has to be true
14:43:02 <Sindriava> Profpatsch: OOP is nice, when it's not abused and overengineered like some people do it
14:43:12 <fizruk> arguable, oop does not exist
14:43:41 <Sindriava> "Orangutan oriented programming"
14:43:42 <fizruk> anyone here have experience with opaleye?
14:43:49 <Profpatsch> It’s one of the least defined buzzwords around.
14:44:11 <Profpatsch> This spoon doesn’t exist either, but people eat with it.
14:44:36 <arw> it's rather one of the most-redefined buzzwords. it always means "like that other OOP-language I like"
14:44:39 <Sindriava> Profpatsch: I like to think that using OOP without having proper education about it tends to end badly
14:44:55 <Profpatsch> Sindriava: I don’t know what education with OOP even means.
14:45:20 <Sindriava> Profpatsch: *about* it. My uni has lots of heavy OOP stuff later on
14:45:25 <Profpatsch> How can you be educated about something that is not properly defined?
14:45:25 <fizruk> I've been taught that OOP = abstraction + incapsulation + polymorphism + inheritance
14:45:37 <Sindriava> Profpatsch: Smalltalk, writing a smalltalk VM, very abstract stuff too
14:45:47 <tippenein_> so, oop is programming?
14:45:58 <arw> all the oop education seems to consist of drawing up complex diagrams where 99% is fluff just to fill the drawing and make things unnecessarily complex
14:45:59 <fizruk> tippenein: exactly
14:46:00 <nshepperd> meh, subtyping polymorphism is fundamentally weak
14:46:04 <Sindriava> Profpatsch: And most people that go through this, I find they use it more sparingly, and more elegantly
14:46:23 <Sindriava> arw + 1
14:46:31 <Profpatsch> Sindriava: Of course, kernel developers probably program very good C, too.
14:46:39 <Profpatsch> But that doesn’t mean C is a good language. :)
14:47:01 <Sindriava> Profpatsch: It means that C is a good language for a subset of problems
14:47:09 <arw> interestingly, the linux-kernel contains some of the best oop usage in C i have seen to date ;)
14:47:12 <Sindriava> Profpatsch: And it means that writing good C requires experience and skill ^^
14:47:42 <arw> Sindriava: thats true for good $anything
14:47:42 <Profpatsch> Writing good *everything* requires experience and skill.
14:47:51 <dolio> This conversation is pretty off topic.
14:47:57 <Sindriava> Yeah, true
14:48:01 <Sindriava> >>= -blah
14:48:24 <nshepperd> you can simulate objects with typeclasses. but you usually end up realising you didn't want a typeclass after all
14:48:51 <haskell927> the tree is a directory which may contain list of directories
14:48:53 <fizruk> I'll repeat in case my question has been lost: anyone here uses opaleye?
14:49:01 <Profpatsch> But is that experience & skill incidental to programming?
14:49:59 <haskell927> ptd http://pastebin.com/2Zk9fHn9 the last function is supposed to be able to search and return regardless of depth
14:50:28 <arw> nshepperd: its rather a bunch of functions with a certain record (aka the object) as the first parameter. no need for a typeclass.
14:50:40 <arw> nshepperd: typeclasses are only needed to simulate crude inheritance
14:51:23 <glguy> haskell927: Were you asking about this previously as Akari2?
14:52:17 <haskell927> yeah im akari i think i was asking another function based on directories
14:52:21 <Profpatsch> nshepperd: If you take a look at go, they actually cleanly separated structs from functions on them.
14:52:53 <glguy> haskell927: I wrote this last time you were looking up paths in a directory tree to share with you but you'd quit a couple minutes before I pasted it: http://lpaste.net/143245#a143246
14:53:10 <Profpatsch> Sindriava: The defining cruft of OOP used today is Inheritance & State combined with behaviour.
14:53:44 <Profpatsch> Sindriava: Which is just dangerous. And that is even made worse by passing everything as reference.
14:54:07 <glguy> haskell927: (first:second:[]) only matches two element lists
14:56:00 <haskell927> that stores the string names to search for, entry whose name is same with the second should be returned, and its leaf of the first one
14:56:14 <haskell927> glguy thanks for the code but i didnt quite get it 
14:57:09 <haskell927> never heard of " do" and "find" before
14:57:24 <glguy> haskell927: OK, we can simplify those away, then
15:02:46 <lpaste> glguy annotated “For Akari2” with “simpler version” at http://lpaste.net/143245#a143656
15:03:08 <glguy> haskell927: That breaks things down into the individual steps
15:05:39 <haskell927> okay Ill try it after eating thank you very much
15:09:47 * dgpratt would like to talk about http://lpaste.net/1153129943664689152
15:10:13 <dgpratt> anything involving an explicit forall always seems to throw my brain for a loop
15:10:48 <dgpratt> I can reason about this stuff on the micro level, but I feel like I still don't "get" it
15:11:08 <dgpratt> I guess I'm asking, how should I think about this code?
15:11:31 <dgpratt> btw, it comes from a paper on extensible effects
15:12:32 <c_wraith> dgpratt: an Eff a holds a polymorphic function. 
15:13:15 <c_wraith> dgpratt: the choice of a is fixed. It is the same as the argument to Eff
15:13:46 <c_wraith> dgpratt: on the other hand, the choice of w is up to the caller of the wrapped function. 
15:14:53 <dgpratt> c_wraith, limited to the example code, is there anything one could apply Eff to besides E?
15:15:30 <c_wraith> dgpratt: from the reverse perspective, the wrapped function "knows" what a is, but not w
15:16:12 <dgpratt> kinda sorta get that...I guess I mostly get the precisely what, but not the why
15:17:04 <dgpratt> I mean, runEff has basically a strictly more general type than E, right?
15:17:27 * dgpratt is not sure his queries make sense
15:21:17 <c_wraith> dgpratt: Eff ($ ()) :: 
15:21:17 <dgpratt> I guess what it comes down to is that I have a hard time (in such cases as this) imagining what is the space of what is possible
15:21:42 <c_wraith> Err, :: Eff () 
15:22:18 <haskell927> glguy http://prntscr.com/8u8gwi  maybe first one is okay but last one shouldnt return Nothing, i think the same thing happens with my code as well
15:22:33 <c_wraith> dgpratt: it's boring, but it has the right type. 
15:22:53 <dgpratt> c_wraith, it's interesting to me :)
15:26:11 <c_wraith> dgpratt: basically, that type means that if there is a value of type w present, it must be from calling the provided function. 
15:27:07 <c_wraith> Plus there is some ability to index the type. I'm not intuitive why offhand, and not running any code to investigate. :) 
15:27:18 <c_wraith> Err, index the value. 
15:27:41 <glguy> haskell927: My code is just demonstrating some structure, not doing the two-part path lookup
15:28:49 <glguy> It's doing a lookup by full path
15:29:20 <dgpratt> I appreciate your insight, c_wraith
15:34:14 <haskell927> glguy okay, right
15:34:56 <lpaste> glguy annotated “For Akari2” with “simpler version (annotation)” at http://lpaste.net/143245#a143658
15:35:36 <glguy> haskell927: You should be able to break down your function like this making use of 'lookupEntryByPath'
15:37:33 <glguy> haskell927: or you could modify lookupEntryInPath so that if it didn't find what it was looking for at the root that it searches all of its children
15:37:49 <glguy> then your code would work for paths of any length, not just 2
15:45:58 <lilred> hey fellas
15:46:05 <dmj> lilred: hi!
15:52:24 <pikajude> does anybody know whether the space usage of LinkedHashMap from the linkedhashmap package matches the space usage of the Java implementation it's based on?
15:52:26 <pikajude> it doesn't look like it is
16:00:12 <lpaste> hardmath123 pasted “A "bug" happened” at http://lpaste.net/143660
16:00:22 <hardmath123> ghc told me to report a bug, but I'm not sure it's a bug. ^^ someone want to take a look?
16:01:17 <hardmath123> This is using GHCi 7.10.1 on OSX
16:01:34 <koala_man> it's clearly a bug. nothing should cause a ghc panic.
16:01:36 <pikajude> if ghc says report a bug, report a bug
16:01:51 <pikajude> no matter how erroneous the input, ICE is always a bug
16:02:21 <Hafydd> Unless you're using unsafeCoerce or the like, perhaps.
16:02:29 <Gurkenglas> > ?f
16:02:30 <lambdabot>  mueval-core: internal error: PAP object entered!
16:02:30 <lambdabot>      (GHC version 7.10.2 for x86_64_unknown_linux)
16:02:30 <lambdabot>      Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
16:02:41 <pikajude> but that wouldn't be an ICE, that would cause a segfault or something
16:02:52 <Hafydd> "PAP object entered!" Ohh my.
16:03:24 <Hafydd> pikajude: it has caused ICE errors.
16:03:36 <pikajude> Hafydd: it shouldn't though, right?
16:03:42 <Hafydd> pikajude: why not?
16:04:01 <Hafydd> If you coerce something to a function, then try to run it, for example.
16:04:02 <pikajude> because internal compiler errors are not user friendly?
16:04:18 <Hafydd> pikajude: that's true, but what does it have to do with the question?
16:04:23 <pikajude> but the compiler doesn't try to run functions, does it
16:04:28 <danza> hey, can anybody help me to find my way in Reflex's code? it is pretty abstract ...
16:04:48 <Hafydd> pikajude: I thought you meant "internal consistency error." Anyway, GHCi can present such errors.
16:04:55 <pikajude> my mistake
16:08:56 <danza> oh well i will be more specific: here, `data Event` is defined with indentation in a `were` section https://github.com/ryantrinkle/reflex/blob/develop/src/Reflex/Class.hs#L34 this is a type class definition, so am i expected to never use that `Event` type directly? i should use an instance of that type class implementing its own Event, right?
16:09:13 <danza> sorry ... `where` section
16:11:09 <hardmath123> the bug reporting site isn't letting me log in as "guest"/"guest"
16:12:53 <kallisti> danza: Event is an indexed data family. you can think of it as a type-level function.
16:13:17 <kallisti> danza: so yes, every instance of Reflex will have an instance for Event
16:14:28 <kallisti> if you have a Reflex instance named Foo, then write "Event Foo" as a type in your code somewhere, it will refer to data family instance that Foo uses
16:15:27 <danza> thanks a lot kallisti! i understand it better now! :)
16:15:51 <danza> also, i can search some doc about "indexed data family" :)
16:17:11 <kallisti> instance Reflex Foo where  Event Foo = CustomEvent1 String | CustomEvent2 | CustomEvent3 String String; ...
16:17:27 <kallisti> instance Reflex Foo where  data Event Foo = CustomEvent1 String | CustomEvent2 | CustomEvent3 String String; ...
16:17:30 <kallisti> rather
16:18:15 <kallisti> so now in the other Reflex methods, you can refer to CustomEvent1, CustomEvent2, etc are the data constructors of the type Event Foo
16:18:57 <danza> cool, i think that this is the trick Ryan Trinkle uses to allow for multiple reactive implementations in Reflex
16:19:22 <kallisti> actually it looks like Event needs to have the kind * -> * -> *
16:20:00 <kallisti> and it has a Functor instance
16:20:20 <kallisti> so it would look like:  data Event Foo a = CustomEvent1 String a | CustomEvent2 a | CustomEvent3 String String a
16:20:21 <kallisti> something like that
16:20:41 <kallisti> basically the first parameter of Event always has to be the instance of the class
16:21:02 <kallisti> the second parameter is always some arbitrary type "a"
16:21:44 <danza> yes, the first argument is used to specify the reactive implementation, as far as i understand
16:23:20 <kallisti> Event Foo is likely to refer to itself as well, since it appears to be a stream data type
16:23:35 <kallisti> so the data constructors will look somewhat like a list
16:24:03 <danza> sorry, what is a stream data type?
16:24:46 <kallisti> list is a simple example of a stream
16:25:01 <kallisti> you either have a value, and the rest of the stream, or the stream has ended
16:25:24 <kallisti> if you remove the [] from list, you have a stream that's forced to be infinite
16:26:19 <danza> so a stream data type is an abstract concept, or it refers to something defined in Haskell, like a type family or something else that i don't know?
16:26:28 <kallisti> just a concept
16:26:33 <danza> oh, cool
16:26:55 <kallisti> if you're not actually writing instances of Reflex, you don't actually need to worry about what an Event's constructors would look like
16:27:09 <danza> right :)
16:27:26 <danza> i wanted to look for the functions allowed on an event, but i got lost reading the types
16:27:34 <danza> thanks for the guidance!
16:28:01 * hackagebot phizzle 0.1.0.0 - Library for checking if a given link is in a phishtank json file  https://hackage.haskell.org/package/phizzle-0.1.0.0 (bmcg)
16:38:41 <shapr> GOOD MORNING
16:43:02 * hackagebot phizzle 0.1.0.1 - Library for checking if a given link is in a phishtank json file  https://hackage.haskell.org/package/phizzle-0.1.0.1 (bmcg)
16:45:45 <Profpatsch> shapr: Good night.
16:53:56 <flippant> begriffs: i just found out about 'postgrest'. how did you create the logo?
16:54:02 <flippant> it looks really cool
16:55:40 <begriffs> A designer friend made it. I never would have been that clever. :) This guy: https://github.com/casalaina
16:56:40 <flippant> yeah, i never would have considered associating REST with a musical rest
16:58:03 * hackagebot secp256k1 0.1.9 - secp256k1 bindings for Haskell  https://hackage.haskell.org/package/secp256k1-0.1.9 (xenog)
17:10:08 <xnil> With Test.QuickCheck.Gen, I would like to do something along the lines of `frequency [(1, choose (Nothing, Nothing)), (9, choose (Just 1, Just 9))]` with the type :: Gen (Maybe Int). Is there any way I can do this?
17:12:26 <joobus> is there an easy way to play with the State monad in the repl?  I'm trying: runState (do {put 5;return 'X'})::Int -> (Char, Int)   ... which I got from the haskell wiki, but show is no defined for the result
17:13:03 * hackagebot secp256k1 0.1.10 - secp256k1 bindings for Haskell  https://hackage.haskell.org/package/secp256k1-0.1.10 (xenog)
17:13:20 <Clint> joobus: what do you want that to do?
17:13:27 <dutchie> joobus: that sounds right; you can't show a function, so you need to give it an initial value
17:13:52 <betaceti> has anyone done exercise 3 of "positive and negative position" here?
17:13:53 <betaceti> https://github.com/commercialhaskell/haskelldocumentation/blob/master/content/covariance-contravariance.md
17:14:06 <joobus> i don't really understand the State monad at the moment, I'm just trying to figure out what the state monad holds, and how to manipulate it
17:14:37 <joobus> I thought the code above would output (5, 'X') but I guess not
17:14:45 <dutchie> :t runState
17:14:47 <lambdabot> State s a -> s -> (a, s)
17:15:16 <betaceti> here's what i came up with. some of the 'tricky' ones i'm not so sure on http://lpaste.net/143662
17:15:21 <dutchie> so it takes some State monad calculation, an initial value, and gives back your (a, s) value
17:15:46 <dutchie> :t runState (do {put 5; return 'X'})
17:15:48 <lambdabot> Num s => s -> (Char, s)
17:16:08 <Clint> :t runState (do {put 5; return 'X'}) 0
17:16:10 <lambdabot> Num s => (Char, s)
17:16:18 <joobus> ok, so then the code above will return a function, and then whatever initial value I get, the func will return ('X', 5), yes?
17:16:22 <dutchie> yes
17:16:25 <joobus> that seems to be what the repl is doing
17:16:27 <joobus> k
17:16:37 <dutchie> do you see why you have to give some argument there?
17:16:41 <dutchie> in fact, i can do:
17:16:51 <dutchie> >runState (do {put 5;return 'X') undefined
17:17:00 <dutchie> > runState (do {put 5;return 'X') undefined
17:17:01 <lambdabot>  <hint>:1:31: parse error on input ‘)’
17:17:07 <dutchie> > runState (do {put 5;return 'X'}) undefined
17:17:08 <lambdabot>  ('X',5)
17:17:10 <joobus> yes, i see from the type signature that it needs an arg
17:17:37 <joobus> does state always return a pair?  I guessing no.
17:17:48 <dutchie> you have runState and execState
17:17:50 <dutchie> :t execState
17:17:52 <lambdabot> State s a -> s -> s
17:18:34 <dutchie> :t evalState
17:18:36 <lambdabot> State s a -> s -> a
17:18:45 <dutchie> so between those three you can get whichever bit you want
17:18:49 <Gurkenglas> betaceti, all of them except for E7 and E8 look like they should instantly be isomorphic to () because they have a () in the return type
17:19:23 <Gurkenglas> (Or are you considering bottom?)
17:20:11 <betaceti> Gurkenglas: >< i knew there was something about unit that would make things come out differently
17:20:56 <Gurkenglas> joobus, here's a sketch that shows how the state monad implements sequence: http://sketchtoy.com/66039843
17:22:23 <betaceti> Gurkenglas: it's a draft document, previously he was discussing functions with an IO () in the signature, so maybe he intended that
17:22:58 <joobus> so is there ever only 1 'key' in the state?  like 'X' from above?
17:23:40 <dutchie> State has two parameters. one is the type of the internal state, and the other is the result of the computation
17:24:06 <dutchie> thanks to tuples and record types, you can fit as much data as you want into each of them
17:24:56 <dutchie> for example, `State (Int, Int) [Double]` is a computation holding two Ints as internal state that computes a list of Doubles
17:25:33 <dutchie> In a real app, you'd define your own types and then you could put them in
17:25:49 <joobus> ok
17:26:31 <joobus> so my example above isn't that great because the computation doesn't depend on the 'internal state' 'X' at all?
17:26:50 <dutchie> you could say that
17:27:25 <dutchie> > runState (do {x <- get; put (x+1); return (2*x)}) 0
17:27:26 <lambdabot>  (0,1)
17:27:30 <joobus> in a normal app that computation would depend on the internal state.  ok.
17:28:15 <dutchie> joobus: exactly, or you wouldn't bother using State at all
17:28:44 <joobus> thanks dutchie
17:28:47 <dutchie> np
17:41:33 <joobus> can you show me an example of modifying the state before doing runState?  I'm trying to figure out how to use 'modify' to update the state before running it.
17:41:49 <Cale> joobus: huh?
17:42:11 <joobus> i've been trying variations of: runState 4 $ modify (+1) $ (do {put 5; return 'X'})
17:42:11 <Clint> joobus: there is something you are misunderstanding
17:42:17 <joobus> probably
17:42:43 <Cale> > runState (do modify (+1); n <- get; put (n+1); return (10*n)) 5
17:42:45 <lambdabot>  (60,7)
17:43:14 <Cale> joobus: is it clear what's going on there?
17:43:29 <Cale> So the initial state is 5
17:43:37 <Cale> modify (+1) will change it to be 6
17:43:49 <Cale> and then n <- get will result in n being 6
17:44:02 <Cale> and then put (n+1) will make the current state 7
17:44:21 <Cale> and we return (10*n), which is 60 as the result of the computation
17:44:25 <Cale> and the final state is 7
17:44:55 <joobus> yes.  but if i have some state in an app, does that state only ever get changed in a certain way while in the state monad?  let's say I have a string in an app that gets updated various places.  how do i go about updating the state?
17:45:37 <Cale> Actually using the State monad is pretty rare
17:45:50 <Cale> If you're talking about mutable state for IO, you probably want an IORef
17:45:55 <Clint> joobus: the state does not exist outside of the "runState block"
17:46:05 <Cale> You can also just pass around values manually.
17:46:16 <Cale> But, well, there are a lot of techniques
17:46:34 <Cale> You can make objects out of data types which have functions or IO actions as their fields
17:46:41 <klo> may be its insaneful but how to hack google  
17:46:49 <joobus> i'm thinking of a scenario where an app loads an initial config, but then certain fields may get updated on the fly.
17:47:00 <Cale> So, for example, you might have:
17:47:54 <Clint> joobus: in that case you might want to do everything in StateT IO
17:48:14 <klo> ??
17:48:17 <klo> no one
17:48:56 <klo> if i try a unexplored exploit can ??
17:49:01 <Cale> I wouldn't usually use StateT IO
17:49:19 <Cale> klo: What does your question have to do with Haskell?
17:49:38 <Cale> klo: How did you end up thinking that this was a reasonable place to ask that question?
17:50:05 <joobus> Clint: you might be right, but I haven't wrapped my head around monad transformers yet.  I trying to figure out the state monad so I could try and build up at least a couple monads, then try to figure out/write a monad transformer.
17:50:10 <Cale> klo: I'd really honestly like to know, because we get someone like you asking about computer security at least a couple times a month
17:50:22 <Hafydd> Everyone knows that the best hackers hang out in #haskell.
17:50:34 <Cale> joobus: I recommend starting out by just passing around the configuration by hand as a function parameter
17:50:53 <Hafydd> "Haskell," after all, is only two letters away from "Hackskill."
17:50:56 <klo> i have already found csrf in yahoo lol
17:51:06 <Hafydd> ...three letters.
17:51:30 <Cale> joobus: That's the simplest most basic solution to the problem, and once you've done that, you can start to envision things which might be useful in cleaning up patterns in how you're dealing with the configuration.
17:52:08 <Cale> joobus: and don't forget that IORefs are indeed a thing which you can make and pass around, and they have operations in IO which will let you edit them
17:52:42 <Clint> but they're ugly
17:52:45 <klo> so anyone can answer ??
17:53:36 <joobus> Cale: well really, I want to write a web service with Snap which does logging, talks to a database, and also does the net IO.  But again I still haven't figured out monad transforms yet.
17:53:53 <e2kp> its easy to hack yahoo you need to use windows it's an awesome hacking tool :^)
17:54:10 <klo> no yo need kali lol
17:54:19 <joobus> I was messing with the state monad because I didn't really understand it, and because I was going to try and build a few monads on top of each other for monad transform learning.
17:55:19 <nshepperd> klo: seriously why the heck are you in #haskell
17:56:06 <Cale> joobus: Monad transformers are kind of a common solution to the problem, but they are overused compared to how effective they are at solving it imo.
17:56:14 <klo> <nshepperd>  why what happen ?
17:56:29 <Hafydd> klo: your life will probably be more satisfying if you, for example, learn Haskell instead of trying to "hack Google."
17:57:03 <Cale> joobus: If all you're doing is passing around some configuration state, replacing IO with StateT s IO is giving up a lot of things in terms of convenience for a very small convenience in return.
17:57:11 <nshepperd> klo: this is the chatroom for Haskell, the programming language
17:57:34 <joobus> Cale: they seem necessary for doing logging/tracing though.  I like to be verbose with logging/tracing, but haven't figured out how to fit logging into a functional app.
17:57:37 <Cale> For example, you'll notice that all the higher order operations on IO, things like catching exceptions and forkIO for creating threads, they want IO actions as arguments
17:57:51 <klo> <Hafydd>  but i use python and perl :(
17:57:55 <Cale> They don't want StateT s IO actions
17:58:14 <Cale> and so you end up doing additional junk to work with any of those, for one
17:58:17 <Clint> but if he's going to be using snap he's going to have a transformer stack anyway
17:58:18 <Hafydd> klo: then you'll find Haskell to be an even greater relief.
17:58:32 <Cale> Secondly, IO already has a ton of ability to create and manipulate mutable variables
17:58:34 <Hafydd> klo: http://book.realworldhaskell.org/read/ and https://www.haskell.org/onlinereport/haskell2010/ are the learning materials I recommend.
17:58:45 <klo> lol
17:58:48 <klo> hahaha
17:58:52 <klo> really
17:58:56 <klo> ok 
17:58:57 <klo> thank 
17:59:00 <klo> i'll
17:59:01 <klo> sure
17:59:04 <Hafydd> ...
17:59:06 <Cale> and you can pass around records which contain those mutable variables (IORefs) directly, or contain operations for acting on them in a restricted way
17:59:18 <nshepperd> I think you missed your spacebar there
17:59:18 <Cale> klo: Please don't press enter until your message is complete.
17:59:30 <anks> @djinn [Word8] -> Put
17:59:30 <lambdabot> Error: Undefined type []
17:59:36 <anks> why doesnt it work :|
17:59:38 <nshepperd> @where learnhaskell
17:59:38 <lambdabot> https://github.com/bitemyapp/learnhaskell
17:59:57 <joobus> can an IORef be used as an argument in a pure function?  I guess if it is passed in a do block...
18:00:05 <klo> bdw can some one suggest me security researchers channel here causes i google and  found this channel
18:00:12 <nshepperd> klo: if you haskell, you can work for google, which is way more profitable than hacking :>
18:00:27 <nshepperd> *learn haskell
18:00:33 <Hafydd> klo: what query did you use?
18:00:38 <KaneTW> i don't think haskell uses google
18:00:38 <Cale> joobus: It can, but readIORef and writeIORef produce IO actions which you have to execute from another IO action
18:00:42 <KaneTW> eh, google uses haskell
18:00:58 <klo> google use haskell ??
18:01:02 <nshepperd> KaneTW: nope, but learning haskell will surely sharpen their brain
18:01:13 <Clint> it uses a little haskell
18:01:16 <danza> KaneTW, big companies use almost any existing technology
18:01:20 <Hafydd> Learning Haskell might make you competent enough to work at Google.
18:01:26 <Cale> joobus: However, you can grab the result of executing readIORef myRef, i.e. the contents of the IORef and pass that to anything you like
18:02:00 <Cale> klo: What gave you the idea that this channel is about security research?
18:02:01 <KaneTW> danza: if i remember correctly google deliberately limits the amount of pl in use
18:02:13 <e2kp> pl?
18:02:15 <Cale> klo: This is an IRC channel about the programming language Haskell.
18:02:17 <klo> ok ok am interested in haskell tell me where i can use this language ? i know js , perl ,python and java 
18:02:18 <KaneTW> programming languages
18:02:18 <danza> seriously? that's very disappointing of them!
18:02:27 <KaneTW> @where learnhaskell
18:02:27 <lambdabot> https://github.com/bitemyapp/learnhaskell
18:02:30 <KaneTW> ^
18:02:47 <Cale> That thing will probably point you to here: http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html
18:03:40 <Cale> joobus: So for example, let's suppose you want to give your program a way to record log messages
18:04:59 <nshepperd> danza: yeah google sticks to almost exclusively c++, python and java (for android)
18:05:09 <klo> What is Haskell actually useful for?
18:05:11 <klo> What is Haskell actually useful for?
18:05:14 <danza> what about Go? :D
18:05:16 <nshepperd> danza: for build consistency and so on, I assume
18:05:17 <Cale> joobus: You could define a record type for all the configuration information regarding various operations like this which will be needed throughout a lot of your program:  data App = App { writeLog :: MessageLevel -> String -> IO (), ... other stuff eventually ... }
18:05:20 <danza> klo if you accept another suggestion, change your nickname http://www.dict.cc/?s=klo
18:05:52 <Cale> joobus: Then you have a bunch of options for how to implement the writeLog operation which you'll be passing around as part of this App record
18:06:08 <klo> i wanna know What is Haskell actually useful for?
18:06:17 <KaneTW> klo: it's a general purpose programming language. anything that's not low-level systems stuff can be done in haskell
18:06:31 <KaneTW> and even if it's low-level you can use it as a host language
18:06:32 <nshepperd> klo: Almost anything! It's a general purpose programming language. Some people write trading platforms in it, other people write web servers
18:06:38 <klo> ok but where we can use ?
18:06:45 <joobus> how common is it to use a Writer monad for doing logging?
18:06:58 <nshepperd> klo: 'where'?
18:07:12 <klo> i mean its specific for something ??
18:07:15 <joobus> and in your writeLog example, is that just returning an IO action, which could be run later?
18:07:21 <nshepperd> klo: it has a compiler, that produces executable programs
18:07:23 <danza> sometimes i think that you are too kind people ... somebody jumps in the channel absolutely out of nothing, and you want to introduce him/her to Haskell?
18:07:32 <Cale> joobus: One would be to store the log in an IORef:  logRef <- newIORef []; let app = App { writeLog = \lvl msg -> modifyIORef logRef ((lvl,msg):), ... }
18:08:10 <Cale> joobus: yes, so in this case, I'm imagining this code as being somewhere in main perhaps
18:08:42 <joobus> what about logging in pure functions?  Or is that not really done?
18:08:55 <Cale> and then you're going to pass this app record around to various parts of your program, and they'll be able to   writeLog app CriticalError "my arms are flailing wildly"
18:09:15 <Hafydd> Good error message.
18:09:29 <Cale> That's not really done, but of course, pure functions might return additional values alongside their results
18:10:06 <Cale> and then you writeLog the log values which are computed by the pure functions as your program proceeds
18:10:16 <Cale> Now you might also implement writeLog differently
18:10:25 <Cale> Maybe you want it to write to disk immediately
18:10:54 <Cale> You might even want to abstract things a bit -- you can be more polymorphic about the choice of monad you use:
18:11:06 <Cale> data App m = App { writeLog :: MessageLevel -> String -> m (), ... other stuff eventually ... }
18:11:56 <Cale> If there's enough stuff in an App m record to do something interesting, maybe some parts of your program would operate entirely using those operations, and no other IO
18:12:19 <Cale> and so would result in computations of type m t for some result type t
18:12:36 <danza> nshepperd, what do you mean by "build consistency"?
18:12:38 <joobus> interesting...
18:12:38 <Cale> and then you could simulate the operation of those parts of your program using a pure monad like State
18:12:42 <Cale> rather than using IO
18:12:53 <Cale> and that can be useful when testing
18:13:03 <Cale> if you don't want to *actually* do IO sometimes
18:13:05 * hackagebot secp256k1 0.1.11 - secp256k1 bindings for Haskell  https://hackage.haskell.org/package/secp256k1-0.1.11 (xenog)
18:13:44 <nshepperd> danza: so that everything builds in the same way
18:13:51 <Cale> joobus: For example, consider
18:14:13 <Cale> data StateOps s m = SO { get :: m s, put :: s -> m () }
18:14:17 <nshepperd> I understand they had a lot of build infrastructure specialized for c++, and they didn't want to make a big migration effort
18:14:25 <danza> nshepperd, nowadays most companies use Docker, and are agnostic of the way you build your services
18:14:27 <Cale> well, maybe I don't want to call those get and put, maybe that's confusing
18:15:59 <Cale> But essentially, something of type  StateOps s m -> m a  is kind of like   MonadState s m => m a  (which is like a generalised version of State s a), but with the important difference being that you get to determine entirely how to implement get and put
18:16:02 <nshepperd> i wonder how much Go they really use
18:16:14 <nshepperd> I got a sort of 'failed experiment' vibe from it
18:16:18 <Cale> So, for instance, you could implement them by using readIORef and writeIORef
18:16:29 <Cale> or you could also make them log changes to the state to a file
18:16:34 <joobus> Cale: i think i see what you are getting at
18:16:55 <danza> nshepperd, i meet a lot of Go enthusiasts around in Berlin ... but well also a lot of PHP and Node enthusiasts ... :(
18:17:05 <Cale> or you could make every get just ask the user what they think the current state is, and every put tell the user what the program wants the state to be :D
18:17:31 <Cale> (those would be with m = IO)
18:17:42 <Cale> Of course there's an obvious m = State s implementation of StateOps
18:18:22 <joobus> so all the pure computational stuff for whatever operation I'm trying to do would be in pure functions, and then in some IO monad I would call the functions and intersperse the log messages to go along with it.
18:18:54 <danza> nshepperd, anyway i was imprecise ... actually Docker is for deployment, not for building ... what i mean is that nowadays the barrier for introducing a different technology is quite low ... a bit because of microservices, a bit because of Ruby, Java, Node, Python, and so on ... the infrastructure can do very few assumptions
18:20:11 <joobus> thanks for the tutorial Cale.  :)
18:20:18 <Cale> joobus: Yeah, or like, depending on which part of the program it is, maybe you'd like to just test it without logging and without any IO at all, in which case you might be able to pass in an App Identity which implemented writeLog and other things as no-ops (obviously not always possible for every sort of operation)
18:20:20 <joobus> i'm going to have to noodle on this a while.
18:21:29 <Cale> The extent to which you can get away with this sort of thing depends on how much else you're doing
18:22:24 <joobus> i'm guessing issues might arise if i'm doing net IO, and db IO, and also trying to do logging IO to the filesystem?
18:23:23 <joobus> i've seen in the logging frameworks that some use liftIO, but if the top of the IO stack isn't the right IO, it wouldn't work?
18:23:51 <Cale> I hate all the logging frameworks I've seen and I wouldn't use them, lol
18:24:10 <joobus> good to know :)
18:24:24 <Cale> But yeah, the idea there is that they give you some monad transformer you could apply to add logging operations to an arbitrary monad
18:24:56 <Cale> liftIO will turn an IO action into an action of almost any sort of monad which is built on top of IO
18:25:43 <Cale> (well, as long as it implements MonadIO, which provides the implementation of liftIO, saying how to do this)
18:26:51 <joobus> Cale: let's not get into liftIO right now.  My brain is full. :)
18:27:14 <joobus> I'm going to experiment with your logging suggestion now.
18:27:35 <Cale> joobus: but yeah, logging is a simple enough thing to do yourself that I dunno, I've rarely seen the need to make a framework for it
18:27:49 <Cale> Maybe it would be good to make one just to be able to tell people "do this thing"
18:28:03 <joobus> every one I've seen doesn't work exactly how I want it either.
18:29:02 <joobus> Cale: again, thanks a bunch.
18:34:03 <halvorg> ((->) t a) can anyone shed some light on what this means?
18:34:29 <dutchie> it just means t -> a
18:34:34 <danza> > :t (->)
18:34:35 <lambdabot>  <hint>:1:1: parse error on input ‘:’
18:34:39 <dutchie> :t (->)
18:34:40 <lambdabot> parse error on input ‘->’
18:34:44 <dutchie> :k (->)
18:34:45 <lambdabot> * -> * -> *
18:35:02 <halvorg> as in function type definitions?
18:35:04 <KaneTW> putting an operator in parens makes it treated like a prefix operator
18:35:10 <KaneTW> instead of infix
18:35:16 <KaneTW> > (+) 1 2
18:35:18 <lambdabot>  3
18:38:09 <Cale> halvorg: yes
18:38:17 <Cale> :t chr
18:38:18 <lambdabot> Int -> Char
18:38:23 <Cale> :t chr :: (->) Int Char
18:38:24 <lambdabot> Int -> Char
18:39:26 <halvorg> I find it hard to reason about an applicative instance of (->), but I got it right through trial and error
18:42:21 <Cale> halvorg: It's not really an Applicative instance for (->), but for (->) e, no matter which type e is
18:42:31 <Cale> That is, you have f a = e -> a
18:42:58 <Cale> Where f is the type constructor which shows up in the types of the Functor/Applicative/Monad operations
18:43:28 <Cale> So, in order to make a Functor instance, you need to supply  fmap :: (a -> b) -> f a -> f b, which is  (a -> b) -> (e -> a) -> (e -> b)
18:43:37 <Cale> that's just function composition
18:43:51 <Cale> To make an Applicative instance, you need to provide
18:43:54 <Cale> pure :: a -> f a
18:43:56 <Cale> that is
18:44:03 <Cale> pure :: a -> (e -> a)  in this case
18:44:05 <Cale> and
18:44:14 <Cale> (<*>) :: f (a -> b) -> f a -> f b
18:44:18 <Cale> so:
18:44:31 <Cale> (<*>) :: (e -> (a -> b)) -> (e -> a) -> (e -> b)
18:45:16 <Cale> both of those are possible types to implement, and even have a unique implementation.
18:45:38 <Cale> (up to doing stupid things like looping forever or using undefined/error)
18:45:53 <halvorg> f <*> x = \t -> f t $ x t 
18:45:59 <Cale> right
18:46:01 <halvorg> this is what I wound up with :)
18:46:04 <Cale> yep
18:46:28 <Cale> You can also do Monad easily enough
18:46:35 <Cale> The monad instance is fun
18:46:45 <halvorg> lemme try on my own first :)
18:46:49 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
18:46:51 <lambdabot>  ("hello","olleh","HELLO")
18:46:58 <Cale> ^^ example of what it does for you
18:47:44 <halvorg> funky example
18:54:46 <danza> :D
20:04:22 <tejon_> Looking for advice on namespacing. I put together a simple utility module to deal with a particularly hideous JSON schema, and while it's simple and currently all the names reflect my opinion of said schema and JSON in general, it *could* be genuinely useful so I'm thinking about uploading it to Hackage.
20:05:15 <ReinH> tejon_: depending on your opinion of JSON that could be good or bad...
20:05:21 <tejon_> As it is, it feels like it should go in Acme. But there's a fair argument to drop it under Data.Aeson. Here's the module in its native environment: https://github.com/tejon/Meeseeks/blob/master/src/lib/Yak.hs
20:06:03 <tejon_> And the only existing usage example: https://github.com/tejon/Meeseeks/blob/master/src/lib/Meeseeks/SchemaOrg/Product.hs
20:06:04 <Lokathor> so foldr evaluates the whole spine of a list before it begins processing the list, right?
20:06:07 <Lokathor> (or other foldable)
20:07:04 <ReinH> Lokathor: no
20:07:05 <tejon_> Lokathor: Only if the spine is strict, I think. (If even then? Might just WHNF the next cell.)
20:07:16 <tejon_> It's foldl that has to consume the whole thing before it can start.
20:07:21 <ReinH> Yes.
20:08:12 <ReinH> @src foldr
20:08:12 <lambdabot> foldr f z []     = z
20:08:12 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:08:23 <ReinH> if f is strict in its second argument, foldr will process the whole list
20:08:26 <Lokathor> @src foldl
20:08:26 <lambdabot> foldl f z []     = z
20:08:26 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
20:08:39 * hackagebot xcb-types 0.7.1 - Parses XML files used by the XCB project  https://hackage.haskell.org/package/xcb-types-0.7.1 (AntoineLatter)
20:08:44 <ReinH> if f is non-strict in its second argument, foldr wiill process as much of the list as is demanded
20:09:02 <Lokathor> but from the right side?
20:09:06 <Lokathor> like starting at the tail?
20:09:08 <ReinH> No, from the left.
20:09:16 <ReinH> > foldr f a [b,c,d]
20:09:18 <lambdabot>  f b (f c (f d a))
20:09:31 <Lokathor> hmmmmmmm
20:09:43 <ReinH> > foldr const 0 [1..]
20:09:44 <lambdabot>  1
20:09:44 <Lokathor> hmmmmmmmmm
20:09:51 <ReinH> const doesn't demand its second argument
20:10:07 <ReinH> so const 1 (foldr const 0 [2..] = 1
20:10:12 <ReinH> missing a )
20:11:15 <Lokathor> so the "accumulator" value comes from the recursive calls?
20:11:17 <ReinH> `l' and `r' refer to the way the statements are grouped
20:11:30 <ReinH> foldr has no accumuator
20:11:39 <ReinH> foldl does though
20:11:57 <ReinH> foldr f z xs is never called with anything other than foldr f z
20:12:00 <Lokathor> the 'z' part, foldr has a 'z' part too
20:12:03 <Lokathor> hmm
20:12:06 <ReinH> yes, but it doesn't accumulate
20:12:10 <ReinH> z is for zero
20:12:13 <ReinH> foldl is strangely named :)
20:12:23 <Lokathor> :t foldr
20:12:24 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
20:12:30 <ReinH> (the z in foldl is strangely named, since it *is* an accumulating parameter)
20:13:03 <Lokathor> so the 'b' part in the signature of foldr
20:13:07 <tejon_> Consider: f z x = if (someCondition z) then z else x
20:13:30 <Lokathor> hmm
20:14:17 <Lokathor> so what i've been wondering is if i can convert this subroutine into a fold https://github.com/Lokathor/roguelike-hs/blob/master/src/Roguelike/Util/PPFOV.hs#L201
20:15:22 <Lokathor> i know the answer is "yeah of course it's a loop it's possible somehow", but i'm wondering if you'd end up being stuck doing extra work compared to this version that can terminate early
20:16:18 <cow_2001> i can't parse this silly csv using cassava :(
20:17:07 <glguy_> Lokathor you can write that function as a foldr if you want it as a fold and with early termination
20:17:19 <glguy_> But still work left to right
20:17:47 <Lokathor> yes, processing the [Location] from left to right as you go is essential for it to work
20:18:25 <glguy_> Yup, you can do that. You end up doing it in a continuation passing style
20:18:36 <Lokathor> that sounds tricky
20:19:17 <tejon_> I've got a half-formed intuition that there's a 'fix' involved there, but I should probably be ignored. :)
20:20:49 <glguy_> http://www.reddit.com/r/haskell/comments/2892a9/someone_asked_me_to_derive_foldl_from_foldr_is/ci8yp1b
20:21:17 <glguy_> It's the same process as writing foldl in terms of foldr
20:22:09 <Lokathor> this goes way over my head
20:23:20 <glguy_> None of that is particularly advanced so you should ask questions about any of the step you don't understand
20:24:32 <tejon_> Were there any thoughts on where to put my yak shaving module?
20:24:44 <Lokathor> Data.Yak
20:25:03 <tabemann> I'd say Control.Yak
20:25:16 <tejon_> Well, I think it'd be Data.Aeson.Yak if I go the non-Acme route.
20:25:20 <tabemann> but Data.Yak works too
20:25:32 <Lokathor> it depends on where the Yak type is coming from really
20:25:52 <Lokathor> do the Yak already exist elsewhere? Control.Yak would be better yeah
20:26:02 <tejon_> https://github.com/tejon/Meeseeks/blob/master/src/lib/Yak.hs
20:26:22 <tejon_> The whole thing is that it addresses a serious use case but man, I don't want to lose that naming scheme. :P
20:27:00 <tejon_> Optimally this would be a TH option for deriveJSON but that's still outside my comfort zone, heh.
20:27:01 <Lokathor> Data.Yak
20:29:30 <Lokathor> so foldl_1 becomes  f (f (f (f z x) x) x) []
20:29:42 <Lokathor> ignoring the different binding shadowings as you go down
20:30:28 <Lokathor> or wait
20:30:58 <Lokathor> no i think that's right
20:31:52 <glguy> > foldl f z [a,b,c,d]
20:31:54 <lambdabot>  f (f (f (f z a) b) c) d
20:32:08 <tejon_> Oh dang. Hayoo down for anyone else?
20:33:14 <Hafydd> > foldr f z [0..]
20:33:15 <lambdabot>  f 0 (f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 (f 11 (f 12 (f 13 (f ...
20:33:49 <Lokathor> so with foldl the accumulator is on the left of the list, and with foldr it's on the right
20:33:55 <Lokathor> withs f's to make it merge up
20:34:00 <Lokathor> *sorta*
20:34:12 <Lokathor> but you you said that foldl has an accumulator and foldr doesn't
20:34:52 <Hafydd> Not in the sense one usually uses "accumulator."
20:36:38 <Lokathor> can you say more on that
20:39:01 <Hafydd> Lokathor: to implement a left fold using manual recursion, you have to (essentially) have an explicit variable representing the accumulated value, which is called an accumulator. To manually implement a right fold, you don't need to use that style.
20:39:22 <Hafydd> An accumulating parameter, more accurately.
20:55:15 <Lokathor> i'm trying to put type signatures on the subroutines
20:55:20 <Lokathor> and ghci is just not having it
20:57:23 <MarcelineVQ> `let foo :: Int -> Int; foo x = x+1`
20:58:30 <Lokathor> right :P
20:58:43 <Lokathor> but i mean i wrote down a signautre and it shouted at me
20:59:20 <lpaste> Lokathor pasted “No title” at http://lpaste.net/143669
21:00:21 <glguy> You'd need scoped type variables to wrote those types
21:01:52 <Lokathor> hmm
21:01:58 <Lokathor> unfortunate
21:02:12 <lpaste> glguy annotated “No title” with “No title (annotation)” at http://lpaste.net/143669#a143670
21:03:15 <shachaf> Is there a program that can only be written with ScopedTypeVariables?
21:06:47 <davean> shachaf: One wouldn't be able to access a config passed as a type?
21:07:03 <davean> an unreified type that is
21:07:08 <shachaf> Do you have an example?
21:09:42 <Lokathor> glguy, where is rec coming from in foldl_5?
21:38:42 * hackagebot bitx-bitcoin 0.6.0.0 - A Haskell library for working with the BitX bitcoin exchange.  https://hackage.haskell.org/package/bitx-bitcoin-0.6.0.0 (tebello_thejane)
21:40:07 <Lokathor> oh
21:40:10 <Lokathor> rec is some keyword?
21:41:31 <ReinH> Lokathor: rec is an argument to the lambda
21:41:38 <ReinH> \x rec a -> ...
21:42:09 <Lokathor> oh, emacs was highlighting it, and there's a thing on the wiki about it being a keyword
21:42:44 <ReinH> Lokathor: rec is a keyword for recursive do
21:43:01 <ReinH> here it's just an identifier
21:43:35 <Lokathor> well i'll call it "re" then in my file here
21:43:45 <Lokathor> for clarity
21:47:02 <MarcelineVQ> Lokathor: huh, that's interesting actually, it compiles but ghc-mod thinks it's a parse error
21:50:07 <Lokathor> it's weird that in foldl_5, foldr is taking in a function but the type doesn't "reduce one stage", so to speak
21:50:30 <Lokathor> because the funciton is taking an extra arg in
21:50:36 <MarcelineVQ> I see, it's because it doesn't like the rec keyword, that wasn't very obvious. `rec` keyword wouldn't even make sense there, there's no indentation or { }
21:51:23 <MarcelineVQ> plus I don't have -XDoRec on, unless that defaults
21:57:17 <kallisti> is GHC's mergesort implementation linear memory?
22:04:30 <nitrix> kallisti: Linear memory? Are you conflating time complexity with memory models?
22:05:18 <kallisti> I am asking if GHC's mergesort has O(n) space complexity
22:06:38 <nitrix> I'm puzzled. Mergesort doesn't store any elements.
22:09:58 <Lokathor> kallisti, since it's not a destructive sort in haskell, if you have the unsorted list and the sorted list, you've got two whole lists
22:10:08 <Lokathor> using the appropriate memory for the number of cons cells
22:10:19 <nitrix> Most datastructures are immutable. By sorting the elements, you're creating additional nodes that favorise the new structure, re-using the common parts like the leafs, then the garbage collector takes care of eliminating the older forms.
22:10:26 <Lokathor> the elements are shared between the two lists
22:13:05 <Lokathor> glguy, i give up
22:14:43 <kallisti> so the answer is "yes"
22:15:19 <Lokathor> "yes mostly"
22:15:22 <MarcelineVQ> I'd put it at, "roughly"
22:16:28 <Lokathor> you're sorting a list of pointers, basically, and getting a new list of pointers, so you eat up *some* memory, but not as much as a deep copy
22:22:37 <kallisti> looking at the GHC implementation, the mutual recursion trick is pretty clever
22:23:36 <bitemyapp> kallisti: what does it do?
22:26:17 <MarcelineVQ> bitemyapp: http://www.jaist.ac.jp/~c-sterna/publications/Sternagel-JAR13.pdf seems to explain it
22:27:33 <kallisti> it switches between an ascending and descending function. at first I thought it was trying to save on comparison operations but it looks like it does something more.
22:29:07 <MarcelineVQ> It's pretty cool yeah
22:29:19 <kallisti> but it flips reversed sorted subsequences with the descending function
22:29:20 <MarcelineVQ> how it keeps passing control between the functions 
22:29:37 <kallisti> and the ascending function avoids splitting up already sorted subsequences
22:32:08 <HexoCyclane> I need to constrain a type argument to be of a certain kind. Is there a way to express such a constraint? Right now, I'm just making a typeclass called IsMyKind and instantiating each and every type in the kind manually, but this is annoying.
22:32:38 <kallisti> type :: kind ?
22:32:53 <HexoCyclane> Can I put that in the constraints section of the type signature?
22:33:14 <HexoCyclane> e.g. "foo :: (a :: MyKind) => Bar a -> Bar a"
22:33:21 <kallisti> no, but I'm not sure what's a requirement really
22:33:33 <kallisti> Bar (a :: MyKind) -> Bar a
22:33:38 <kallisti> would tlel GHC what kind it is
22:33:46 <bitemyapp> MarcelineVQ: thank you
22:34:00 <MarcelineVQ> HexoCyclane: https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/other-type-extensions.html#kinding anywhere close to what you're after?
22:34:30 <HexoCyclane> MarcelineVQ: Oh yeah, that last one is what I want
22:34:32 <HexoCyclane> Thanks
22:34:54 <HexoCyclane> kallisti: I think yours would work too, so thanks
22:34:55 <julianleviston> kallisti: that tell GHC what TYPE it is, not what KIND it is, doesn’t it?
22:35:05 <MarcelineVQ> that's called KindSignatures if it doesn't mention it
22:35:48 <kallisti> no, when you use :: in a type signature it tells GHC the kind of the type
22:35:58 <kallisti> I thought he was working with DataKinds or something thus the "MyKind"
22:36:00 <julianleviston> kallisti: ah ok.
22:36:36 <HexoCyclane> JamesJRH: I am working with DataKinds
22:36:42 <HexoCyclane> Err, kallisti 
22:36:52 <HexoCyclane> Not sure why it autocompleted to James haha
22:36:53 <julianleviston> kallisti: apologies for the noice.
22:37:03 <kallisti> yeah the forall (a :: Kind).
22:37:03 <julianleviston> kallisti: noise*
22:37:05 <kallisti> should work
22:37:10 <kallisti> and probably looks nicer too
22:37:45 <kallisti> but I don't think it will actually do what you want, because if Bar is just a normal data type, and you didn't declare its parameter to have a specific kind, then it's going to assume *
22:38:16 <kallisti> so as soon as you try to tell GHC that "a" has a different kind from *, it'll complain that Bar expects *
22:38:30 <HexoCyclane> Actually, I remember why I needed a typeclass. It wasn't exactly this reason
22:38:52 <HexoCyclane> Bar :: MyKind -> *
22:38:56 <HexoCyclane> and I have this type family
22:39:02 <HexoCyclane> from MyKind to MyKind
22:39:18 <HexoCyclane> Specifically, I have Succ :: MyKind -> MyKind
22:39:22 <kallisti> ah okay
22:39:42 <HexoCyclane> I want GHC to tell me if I Succ something that has no successor
22:39:53 <kallisti> I'm pretty sure it would infer that "a" is MyKind in that case.
22:39:57 <HexoCyclane> but the problem is that GHC just calls it "Succ <whatever>"
22:40:08 <HexoCyclane> It doesn't actually tell me that it doesn't know what "Succ <whatever>" is
22:40:25 <HexoCyclane> So I had to define a typeclass for valid types in MyKind
22:40:41 <kallisti> yeah GHC typechecking doesn't have a built-in logical negation
22:40:44 <HexoCyclane> and then, if I do "Succ <max>", it can't find a typeclass instance for it, and it tells me
22:41:14 <HexoCyclane> So the original purpose (which I forgot at some point in the last 10 minutes) is to auto-generate a type class that contains all members of the Kind
22:41:30 <HexoCyclane> Instead of manually typing them all out
22:41:36 <kallisti> the singletons package kind of does stuff like this for you
22:41:40 <HexoCyclane> and I was just curious if this existed as a convenient feature
22:42:52 <kallisti> not a GHC feature no, but singletons package has TH functions for auto-generating a bunch of type-level stuff. And it has a SingKind typeclass which acts like a kind typeclass
22:43:25 <HexoCyclane> Ok cool, thanks
22:43:31 <HexoCyclane> I appreciate all the help
22:43:46 <HexoCyclane> I think I'll just keep doing what I was doing. It seems simpler for the time being
22:53:44 * hackagebot parser241 0.1.0.0 - A clean interface to create production rules using augmented grammars  https://hackage.haskell.org/package/parser241-0.1.0.0 (YLiLarry)
22:55:22 <hackrilege> :t \ f g a s -> let (x,a') = g a in s (f x) a'
22:55:24 <lambdabot> (t -> r2) -> (r1 -> (t, t1)) -> r1 -> (r2 -> t1 -> r) -> r
22:58:52 * hackagebot parser241 0.1.0.1 - An interface to create production rules using augmented grammars  https://hackage.haskell.org/package/parser241-0.1.0.1 (YLiLarry)
23:02:31 <cwl> How does Haskell runtime manage sockets. Does it use epoll when I have many green threads, each with a socket?
23:02:55 <hackrilege> :t \ f g a s -> let (x,a') = g a in fmap id $ s (f x) (fmap id a')
23:02:57 <lambdabot> (Functor f, Functor f1) => (t -> r1) -> (r -> (t, f1 b1)) -> r -> (r1 -> f1 b1 -> f b) -> f b
23:06:44 <hackrilege> cool huh
23:08:44 <hackrilege> can you help me find it?
23:09:47 <hackrilege> well something with the same type
23:10:06 <hackrilege> im not sure what it is
23:10:16 <MarcelineVQ> You're not alone there
23:11:48 <hackrilege> With a getter and a setter and a function on contents I can modify an element...
23:11:54 <kallisti> cwl: pretty sure it uses something like epoll yes
23:12:59 <kallisti> cwl: actually it looks like the IO manager was rewritten a while back to use asynchronous events.
23:13:35 <cwl> KarolisK: Mio: A High-Performance Multicore IO Manager for GHC. http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
23:14:24 <hackrilege> f=f1 in the above
23:14:30 <cwl> KarolisK: So, Haskell do it for me without any explicit tweak?
23:14:51 <dolio> You're talking at the wrong person. :)
23:15:14 <cwl> dilinger: :-P
23:15:20 <kallisti> I'm not sure what it is you want to do
23:15:36 <kallisti> blocking read on a socket? if so, then yes, you do not have to do anything special.
23:16:46 <cwl> kallisti: forever $ (s, addr) <- accept listenFd; forkIO (workWith s);
23:20:54 <ttt_fff_> so after much thought, I have come to the conclusion that reflex is probably right with the Dynamic/Event/Behaviour approach, because with my "node" approach, when SOMETHING FIRES, I need a notion of "do I store the fired event, or is it transient" -- and once I make this distinction, transient-node = EVENT, store-value-node = Dynamic, and yeah, we're back to square 1
23:21:38 <kallisti> cwl: yeah that should work as expected
23:21:52 <cwl> kallisti: How's the performance
23:22:44 <cwl> kallisti: compared with epoll way
23:23:51 <kallisti> I don't really know exactly.
23:23:53 * hackagebot parser241 0.1.0.2 - An interface to create production rules using augmented grammars  https://hackage.haskell.org/package/parser241-0.1.0.2 (YLiLarry)
23:24:12 <kallisti> but the way you're using the IO system is what GHC devs optimize for
23:25:15 <kallisti> I'm pretty sure warp for example uses that kind of forkIO approach.
23:25:25 <kallisti> which is a very fast Haskell webserver.
23:27:06 <cwl> kallisti: I've read some of the warp code, I does use forkIO way.
23:27:38 <kallisti> the entire runtime system is heavily optimized for concurrency so assuming you have more than one core I would imagine you'll get much better CPU utilization and networking throughput out of using threads vs epoll
23:28:33 <cwl> kallisti: Originally I decided to learn how to use epoll in haskell from warp. But it turns out wrap just forkIO on accept.
23:29:08 <kallisti> if your concern is that you'll spawn too many threads. you won't
23:30:35 <kallisti> there's no OS context switching when transferring execution between threads
23:33:54 * hackagebot aeson-yak 0.1.0.0 - Handle JSON that may or may not be a list, or exist  https://hackage.haskell.org/package/aeson-yak-0.1.0.0 (tejon)
23:34:21 <tejon_> Blah, stupid summary formatting...
23:44:24 * hackagebot aeson-yak 0.1.0.1 - Handle JSON that may or may not be a list, or exist  https://hackage.haskell.org/package/aeson-yak-0.1.0.1 (tejon)
23:49:39 * hackagebot aeson-yak 0.1.0.2 - Handle JSON that may or may not be a list, or exist  https://hackage.haskell.org/package/aeson-yak-0.1.0.2 (tejon)
23:50:29 <tejon_> There. Should have used the candidate system. :P
