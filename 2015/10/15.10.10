00:21:12 <jg> by the way. What's the usual naming convention for helper functions? Think helper function to a recursive function 
00:21:56 <julianleviston> jg: go
00:23:39 <jg> julianleviston: ?. What i mean is - '_f' takes three arguments because two of those are used for passing stuff around in recursive calls,  Then you write 'f' which takes only one argument and calls '_f' with the right initial ones
00:24:13 <jg> 'fgo'
00:24:16 <jg> ?
00:24:19 <julianleviston> jg: got a better example? I’m having trouble following your explanation
00:24:24 <julianleviston> jg: as in… real code?
00:24:57 <jg> julianleviston: i have  _crowdedNodeChildren :: [Node] -> Int -> Node -> [Node] 
00:25:10 <jg> first two of those are currentNodes and currentMax used in the recursion
00:25:29 <julianleviston> jg: you might want to use pastie?
00:27:08 <lpaste> JulianLeviston pasted “This is what I mean... ” at http://lpaste.net/142672
00:27:39 <julianleviston> jg: ^
00:27:46 <jg> julianleviston: that sort of thing http://lpaste.net/142673
00:30:17 <julianleviston> jg: did what I just write make sense?
00:31:23 <julianleviston> jg: http://lpaste.net/142673
00:32:03 <julianleviston> jg: (I annotated it - tho haven’t checked it coz I don’t have “Node” or ”Element” in scope
00:32:50 <julianleviston> jg: that what you were asking?
00:32:54 <jg> yep, exactly. Where's 'go' documented anyway?
00:33:04 <julianleviston> jg: it’s a convention.
00:33:19 <jg> oh, okay
00:33:24 <jg> thanks julianleviston
00:33:24 <julianleviston> jg: it’s not documented anywhere as far as I know. It’s locally scoped so you can name it whatever you like for all Haskell cares.
00:35:00 * hackagebot hsignal 0.2.7.2 - Signal processing and EEG data analysis  https://hackage.haskell.org/package/hsignal-0.2.7.2 (VivianMcPhail)
00:44:03 <jg> i'm getting a highly uninformative 'uncaught exception:' when running my hspec. Is there a way to get a stack trace there?
00:55:55 <julianleviston> jg: you can turn trace on in GHCi. I’m not sure if that’s helpful (because I don’t know how you’re running your tests).
00:56:15 <julianleviston> jg: I think… I haven’t done this myself.
00:57:46 <jg> i'm using stack test to run tests
00:57:48 <julianleviston> jg: how did you get an exception?
00:58:16 <jg> not sure, full error is: 'uncaught exception: ErrorCall (Prelude.foldr1: empty list)'
00:58:32 <julianleviston> jg: oh ok… foldr1 can’t take an empty list.
00:58:37 <julianleviston> :t foldr1
00:58:38 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
00:59:03 <julianleviston> jg: it assumes min of 1 element.
00:59:20 <julianleviston> jg: should be pretty easy to find your bug then…
00:59:27 <jg> i know. But i'm not using it in my code
00:59:37 <jg> perhaps it's used by maximumBy or something?
00:59:42 <julianleviston> hm.
00:59:49 <julianleviston> jg: I’ll check
01:00:24 <julianleviston> jg: yep.
01:00:30 <Yuu-chan> Hello! I'm trying to install `SDL` package on Mac. Tried to get SDL itself both with `port` and manual pkg installation. Still get "SDL not found" error. What can be an issue?
01:00:47 <julianleviston> jg: makes sense… 
01:01:00 <jg> yeah, it does :p
01:01:14 <julianleviston> jg tho maximum has a better exception
01:01:31 <julianleviston> Yuu-chan: what’s SDL?
01:01:41 <athan> julianleviston: I usually use a trick with monoids and semigroups, and a pair tuple
01:02:01 <athan> @let newtype Snd a b = Snd {getSnd :: (a,b)}
01:02:03 <lambdabot>  Defined.
01:02:09 <julianleviston> athan: I think I would just try to make my functions total… :)
01:02:38 <Yuu-chan> julianleviston: a library for graphics and IO stuff, commonly used for games
01:02:47 <athan> instance Eq b => Eq (Snd a b) where; (==) (Snd (_,x)) (Snd (_,y)) = x == y
01:02:55 <athan> > instance Eq b => Eq (Snd a b) where; (==) (Snd (_,x)) (Snd (_,y)) = x == y
01:02:56 <lambdabot>  <hint>:1:1: parse error on input ‘instance’
01:03:07 <pavonia> Yuu-chan: How are you building the Haskell package?
01:03:10 <athan> @let instance Eq b => Eq (Snd a b) where; (==) (Snd (_,x)) (Snd (_,y)) = x == y
01:03:11 <julianleviston> Yuu-chan: cool :)
01:03:12 <lambdabot>  Defined.
01:03:21 <Yuu-chan> pavonia: cabal install SDL
01:03:41 <pavonia> Yuu-chan: Do you pass the lib and include dirs to cabal?
01:03:42 <athan> @let instance Ord b => Ord (Snd a b) where; compare (Snd (_,x)) (Snd (_,y)) = compare x y
01:03:43 <lambdabot>  Defined.
01:04:44 <Yuu-chan> pavonia: well, not explicitly. But this package was the first to get any problem with that.
01:05:23 <athan> > (getSnd . getMin) <$> getOption $ foldMap (\(x,y) -> Option $ Just $ Min $ Snd (x,y)) $ [1..10] `zip` [10,9..1]
01:05:26 <lambdabot>      Not in scope: ‘getMin’
01:05:26 <lambdabot>      Perhaps you meant one of these:
01:05:26 <lambdabot>        ‘getLine’ (imported from Prelude),
01:05:29 <athan> mer
01:06:07 <Yuu-chan> pavonia: I did all with the manual: http://helm-engine.org/guide/installing/ (Helm is dependent on SDL)
01:06:47 <pavonia> Yuu-chan: Could you paste the full build log for SDL?
01:07:05 <athan> > (getSnd . Data.Semigroup.getMin) <$> getOption $ foldMap (Option . Just . Data.Semigroup.Min . Snd) $ [1..10] `zip` [10,9..1]
01:07:07 <lambdabot>  Not in scope: ‘Data.Semigroup.getMin’Not in scope: ‘getOption’Not in scope: ...
01:07:11 <julianleviston> athan: that seems a bit… over-complicated.
01:07:12 <athan> :(
01:07:22 <athan> julianleviston: It's a 1-pass merge
01:07:44 <athan> you just needs some way to order the data
01:07:59 <athan> :t foldMap
01:08:00 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
01:08:12 <athan> reduces via a monoid
01:08:23 <lpaste> Yuu-chan pasted “SDL build log” at http://lpaste.net/142678
01:08:26 <julianleviston> athan: yeah, but if all you want is a maxiumumBy with opional failure, why not use :: Either [a] ?
01:08:54 <julianleviston> sorry :: Either String [a]
01:09:02 <julianleviston> or something
01:09:10 <athan> julianleviston: Well, why would you need an error code?
01:09:15 <athan> This is in Maybe :)
01:09:19 <Yuu-chan> pavonia: please take a look
01:10:05 <pavonia> Yuu-chan: Try adding --extra-lib-dirs=... and --extra-include-dirs=... to cabal install
01:11:11 <athan> julianleviston: Unbounded ordering makes a semigroup - getting the minimum is an associative operation, but doesn't necessarilly have an identity element like a monoid
01:11:16 <Yuu-chan> Huh, that's strange. Helm requires SDL2, but `SDL` package seems to be for SDL 1.x
01:11:18 <athan> That's where Option comes in
01:11:53 <athan> This way, you can have a proper unbounded minimum / maximum over a particular key
01:12:47 <julianleviston> athan: why not just a fold over a lifted comparison function into Either/Maybe? I must be missing something.
01:13:28 <athan> julianleviston: Sure you can do that too, they're isomorphic concepts
01:13:38 <athan> mine just has the accumulator everywhere, so to speak
01:13:49 <athan> rather than explicity passing it to the next element
01:13:52 <julianleviston> ah ok.
01:14:32 <athan> *only if you have a monoidal accumulator, they're isomorphic :)
01:15:06 <julianleviston> athan: I’ll rely on your judgement. I still need to study more before I fully understand… I get the gist now, tho, kinda nice :)
01:15:27 <Yuu-chan> Well, THAT's the problem! According to Hackage, `helm` depends on `sdl2`, but for some reason wants to install `SDL` first. Is there a way to list all dependencies recursively for a package?
01:15:39 <julianleviston> athan: wasn’t that long ago that ALL of that would have gone over my head, but I pretty much undestand what you’re saying now, just haven’t verified / seem it for myself.
01:16:33 <Yuu-chan> Or, cabal tries to install an old version of `helm`
01:17:11 <julianleviston> athan: hehe it’s quite cool how Haskell kind of forces you to understand what you’re doing.
01:17:48 <julianleviston> athan: or at least, won’t let you do things that make absolutely no sense.
01:19:21 <pavonia> Yuu-chan: What helm verision are you trying to install?
01:20:53 <Yuu-chan> Gotcha! helm 0.5+ for some reason requires exactly mtl==2.1.*, and I have 2.2.1
01:21:23 <Yuu-chan> So it tried to install an obsolete, but less restrictive helm 0.4
01:21:47 <julianleviston> What’s the name of the monoid that is *not* the cartesian product one for Lists?
01:21:58 <julianleviston> in fact for that matter, do they even have names?
01:22:25 <julianleviston> is the cartesian product monoid just called that?
01:22:47 <Yuu-chan> cabal hell ftw
01:27:01 <Hafydd> julianleviston: what is the identity element of the cartesian product monoid for lists?
01:27:37 <julianleviston> Hafydd: I don’t know
01:27:42 <julianleviston> Hafydd:  off the top of my head.
01:27:51 <Hafydd> julianleviston: I doubt that such a monoid exists.
01:27:56 <julianleviston> Hafydd: oh
01:28:47 <julianleviston> Hafydd: I don’t get it. Maybe I’m not talking about monoids then...
01:30:50 <Hafydd> julianleviston: the list Monad does something sort of related to the Cartesian product.
01:31:14 <julianleviston> Hafydd: the example is zipWith (+) [3,4] [5,6] versus liftA2 (+) [3,4] [5,6]
01:31:34 <Hafydd> > liftA2 (+) [3,4] [5,6]
01:31:35 <lambdabot>  [8,9,9,10]
01:32:02 <Hafydd> Hmm.
01:32:38 <julianleviston> Hafydd: bitemyapp’s book says “The types are the same, but the behavior differs. The differing behavior has to do with which monoid is being used"
01:33:23 <julianleviston> Hafydd: I obviously need to revise monoids / applicative functors again to really understand what’s going on.
01:33:25 <Hafydd> julianleviston: well, you could defined a Monoid a => Monoid [a] instance like that.
01:33:47 <julianleviston> :t liftA2
01:33:48 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
01:34:10 <Hafydd> Then the identity elements would be respectively (cycle mempty) and [mempty].
01:34:36 <Hafydd> Or rather, Monoid a => WrappedMonoid [a], or whatever.
01:34:57 <Hafydd> (Monoid (WrappedMonoid [a])).
01:35:46 <Hafydd> I don't know what name you'd give to the monoid instance that uses zipWith. Maybe just the zip monoid.
01:36:28 <julianleviston> Hafydd: Applicative ((,) a) ?
01:36:59 <julianleviston> Hafydd: or is it ZipList? 
01:37:06 <julianleviston> Hafydd: I’m a bit all over the place, sorry.
01:37:30 <Hafydd> Oh. Yes.
01:37:34 <julianleviston> Hafydd: I actually would have thought the applicative instance would be the one that defined the combining behavior. Surely the monoid instance should just be about joining the lists together?
01:38:15 <julianleviston> Hafydd: but I should be quiet, because I clearly need to study more. Guh.
01:38:50 <Hafydd> julianleviston: I don't know the full context, so there's not much point on me commenting, but all I can note is that it would be possible to define a monoid based on those operations./
01:38:52 <nitrix> Before I go to bed, I just need to put two words on something.
01:39:40 <nitrix> If I have the expression `1+1`, this is being "evaluated" to a `Num a => a`, but its "execution" might be way later, right?
01:39:50 <nitrix> Just curious if I get the terms evaluation and execution right for Haskell.
01:40:28 <julianleviston> nitrix: when you run your program, main executes.
01:40:33 <Hafydd> julianleviston: so perhaps the book is referring to the monoidal operation underlying the Applicative instance, rather than an explicit Monoid instance.
01:40:38 <cocreature> nitrix: that sounds wrong, you don't evaluate to a type
01:40:46 <julianleviston> Hafydd: that sounds right.
01:41:02 <nitrix> cocreature: Well, evaluated to a value of type `Num a => a`.
01:41:07 <cocreature> also my understanding is that you only execute IO actions in main, the rest is evaluation
01:41:21 <julianleviston> Hafydd: because you could have a Monoid instance that does (<>) all kinds of ways, theoretically… it’s up to the Applicative instance which Monoid it picks.
01:41:29 <nitrix> I see. So only IO is considered execution?
01:41:42 <julianleviston> cocreature: what happens when a pure function is called from main? What do you call that?
01:41:59 <cocreature> julianleviston: I would call that evaluation
01:42:15 <julianleviston> cocreature: that sounds a little dubious to me.
01:42:25 <nitrix> I'm starting to think it's all evaluation actually.
01:42:28 <julianleviston> cocreature: something’s getting executed! :)
01:42:39 <jle`> there's a difference between evaluation and executation
01:42:48 <jle`> `getLine` can be evaluated fully
01:42:49 * cocreature shuts up and lets jle` do the talking
01:42:54 <jle`> and its evaluation gives you an IO String
01:42:56 <julianleviston> jle`: without being executed.
01:43:03 <jle`> `putStrLn "hello"` can also be evaluated to give you an IO ()
01:43:07 <julianleviston> yup.
01:43:11 <jle`> but the evaluation of neither does any IO
01:43:14 <nitrix> jle`: Right, but its execution might be delayed.
01:43:15 <julianleviston> but it’s not until you execute it in main that it does an action.
01:43:17 <jle`> evaluating getLine doesn't get anything from stdin
01:43:31 <jle`> evaluating putStrLn "hello" doesn't print anything
01:43:36 <nitrix> From what I remember, that's what lambdabot does. It just evaluates and doesn't execute anything.
01:43:52 <jle`> i wouldn't say its execution is "delayed"...more like, it doesn't have anything to do with evaluation
01:44:09 <jle`> it's like you can evaluate 1 + 1, but it doesn't cause two apples to appear in front of you
01:44:09 <nitrix> jle`: Gotcha.
01:44:47 <jle`> 1+1 evaluates to 2, which is an actual thing that can *represent* two apples
01:44:47 <cocreature> jle`: so you would agree that calling a non IO function from main is evaluation, right?
01:44:59 <jle`> 2 is a number that can represent two apples, two missiles
01:45:04 <julianleviston> jle`: or say… you can change terms on a maths equation - reduce it down to its constituent elements… but subbing actual real world items in allows you to do some “executing” of the formula.
01:45:14 * hackagebot scientific 0.3.4.2 - Numbers represented using scientific notation  https://hackage.haskell.org/package/scientific-0.3.4.2 (BasVanDijk)
01:45:19 <jle`> getLine is an IO String that can represent getting something from stdin
01:45:33 <jle`> but the number 2 itself doesn't generate two apples int he real world just by the fact that you solved a math equation
01:45:44 <jle`> what you can do is tell someone, "hey, I have a number.  can you give me that many apples?"
01:45:55 <jle`> and the person will take the number 2 and give you 2 apples
01:46:02 <julianleviston> (executing)
01:46:04 <jle`> this happens independently of you figuring out that 1 + 1 is 2
01:46:05 <nitrix> I'm sorry to cut you short, but I don't like analogies for explanations.
01:46:22 <julianleviston> nitrix: lol
01:46:27 <jle`> cocreature: i am not sure what you mean by "calling a non-IO function from main"
01:46:42 <julianleviston> nitrix: use “output on screen” instead of apples.
01:47:23 <julianleviston> jle`: he’s trying to work out where the calculation that happens in the “pure world” gets stitched together to the point where some execution takes place and has effectful actions.
01:47:51 <jle`> the number 2 itself doesn't demand that you print something on the screen by the virtue of you having computed it.  it represents a number.  someone who likes to take numbers and print them on the screen.  that person is what imbues 2 with its put-on-a-screen meaning, not the number 2 itself as a mathematical entity
01:48:25 <nitrix> Well, I understand evaluation and that it happens lazy. I'm wondering where the line is drawn for execution. Obviously the program is executing.
01:48:30 <julianleviston> jle`: no, but say you say to haskell main = print (2 + 2)… where does 2 + 2 happen? :)
01:48:34 <jle`> getLine is just data; an object, a value.  the act of a haskell runtime executing this piece of data is what makes it 'get a line'
01:48:42 <nitrix> Halting problem and whatnot.
01:48:43 <julianleviston> jle`: when you run your program.
01:49:17 <jle`> i'd say it's a part of evaluation
01:49:39 <nitrix> So, the runtime that performs evaluation IS, execution.
01:49:51 <julianleviston> nitrix: I think execution drives evaluation.
01:49:54 <jle`> it has to evaluate enough to know what to execute
01:50:13 <nitrix> So the other way around then, what julianleviston said.
01:50:21 <jle`> you want it to execute `print x :: IO ()`, so it has to evaluate x enough to be able to know what IO () to execute
01:50:33 <nitrix> Execution drives evaluation. So main is executed, then it's evaluation from there.
01:51:00 <jle`> yes.  well, in this case, print (4 + 4) isn't even a fully evaluated IO ()
01:51:02 <nitrix> Well, the program is executed, which evluates main, even.
01:51:15 <jle`> the program *is* main
01:51:27 <jle`> the program is the IO () that is named "main"
01:51:53 <nitrix> But that means this IO () is never evaluated?
01:51:55 <jle`> i can imagine a haskell compiler flag that lets you specify the name of the IO () you want to compile
01:52:10 <jle`> you have to evaluate enough to know what IO action the IO () represents
01:52:32 <ChristianS> jle`: no, it's always 'main'
01:52:37 <nitrix> If we go by the definition that execution drives evaluation, if main is being executed, then also what's comming next is being evaluated. Main isn't itself evaluated with this definition of execution/evaluation.
01:52:38 <jle`> main = if even (sum [1..10000]) then putStrLn "hello" else putStrLn "world"
01:52:42 <jle`> ChristianS: i said, i can imagine it :)
01:52:47 <jle`> it would be a perfectly well defined compiler flag
01:53:21 <jle`> in that case, main is either putStrLn "hello" or putStrLn "world", it's one of two IO actions...so even (sum [1..10000]) has to be evaluated in order for it to even know what IO action main is
01:53:22 <julianleviston> yeah main is just haskell’s standard convention for defining the entry point
01:53:33 <Hafydd> ghc -fnoio
01:54:07 <jle`> the IO action that is named "main" is executed, but haskell first has to know what that IO action even *is*, by evaluating (enough) of it
01:55:01 <nitrix> So, evaluation of main happens before its execution?
01:55:01 <julianleviston> … which forces the enough of the program to evaluate such that it can do that… 
01:55:15 <julianleviston> nitrix: it’s part of it
01:55:40 <jle`> nitrix: i guess that *has* to be correct, because even main = putStrLn "hello" requires putStrLn "hello" to be evaluated
01:56:13 <jle`> otherwise how would the runtime know that you want to put a string...other than evaluating out the IO action that demands it to print a string
01:56:49 <nitrix> So main's evaluated, forcing more expression to be evaluated in a lazy manner; then it's being executed and as it's executing, the IO is decomposed into further IOs, forcing more things to be evaluated to continue the execution of that IO.
01:57:03 <jle`> i guess evaluation and execution work in tandem in this respect.  the IO () named main is executed, and evaluation happens to the extent that it needs to be able to do its job
01:57:22 <jle`> well, the IO isn't necessarily decomposable into further IO's
01:57:22 <nitrix> Might not have phrases that nicely, but I'm getting the idea across.
01:57:39 <nitrix> I see it as a chain reaction.
01:57:42 <jle`> certain actions could arbitrarily be primitives
01:58:25 <nitrix> jle`: Right, but the IO Monad enforces a sequence of those.
01:58:48 <Hafydd> The answer to the original question seems simpler to this: the expression 2+2 is may be evaluated 0 or more times; and is never executed, as it (hopefully) does not have type IO a.
01:58:51 <nitrix> So executing the IO leads to evaluating more of it and executing it further?
01:59:19 <nitrix> Hafydd: What about `return 2+2` :P ?
01:59:26 <Hafydd> nitrix: that would be a different question.
01:59:33 <julianleviston> Hafydd:  nice answer!
01:59:34 <jle`> well, putStrLn "hello" >> putStrLn "world" does *evaluate* to something equivalent to putStrLn "hello\nworld"; the sequencing is a part of the evaluation, not the execution
02:00:28 <jle`> but for (>>=), yeah, the execution of the first thing is required for the evaluation of the second thing
02:00:31 <jle`> maybe that's what you meant
02:00:48 <jle`> getLine >>= putStrLn requires that getLine be executed before the following IO () can even be *evaluated*
02:01:06 <Hafydd> (To answer it, I'd say that the pure action "return 2+2" is technically executed, but does nothing.)
02:01:19 <nitrix> So, main is evaluated, then the first thing is executed to allow the evaluation of further things.
02:01:25 <Hafydd> (return (2+2).)
02:01:31 <nitrix> And I do realise that "first" and "further" are very unclear here.
02:01:46 <julianleviston> Why aren’t there many Monoids ? I mean… there’s not a single answer to “what’s the monoid for this structure” right? Like… the list, for example, has many, possibly infinite ways of joining two lists together. 
02:02:03 <nitrix> Hafydd: Just because it has an IO type?
02:02:09 <julianleviston> Seems a little … restrictive to have a single Monoid instance for list
02:02:13 <Hafydd> nitrix: that's what I'd say.
02:02:13 <jle`> nitrix: might not be the cleanest way of saying it, but i don't think it's too incorrect either
02:02:44 <jle`> julianleviston: well, we have to get around multiple possible/useful instances with newtype wrappers
02:02:55 <julianleviston> jle`: fair enough.
02:03:02 <jle`> there are multiple monoids on Bool, for example
02:03:06 <julianleviston> jle`: seems there should be a lot of standard ones.
02:03:22 <jle`> there are a lot, aren't there?
02:04:08 <julianleviston> jle`: like… Interpose, Append, Combine, etc.
02:04:09 <julianleviston> jle`: I don’t know. Point me? :)
02:04:26 <julianleviston> jle`: I guess this has to do with the fact that Haskell is lazy, actually...
02:04:27 <Hafydd> What are "interpose" and "combine"?
02:04:44 <julianleviston> Hafydd:  interpose is um… an intercalate-like operation
02:04:57 <Hafydd> julianleviston: intersperse?
02:05:00 <julianleviston> Hafydd: knit the two lists together, item by item
02:05:01 <jle`> i'm having trouble loading hackage, but in times when i can, there is a nice list under the documentation for Data.Monoid
02:05:04 <julianleviston> Hafydd: yeah. sorry
02:05:32 <jle`> http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Monoid.html
02:05:49 <julianleviston> jle`: ooh so pretty :) thanks
02:05:53 <jle`> ...what is Lifetime?
02:06:22 <Hafydd> Oh, not intersperse, actually.
02:06:59 <Hafydd> But I know what you mean.
02:07:07 <julianleviston> Why is an Endo useful?
02:07:12 <Hafydd> I wonder, though, what would be a use of that Monoid instance?
02:07:27 <Copperis> hello, can anyone tell me how is this indented wrong? http://lpaste.net/142680
02:07:29 <jle`> (+3) <> (*2) <> negate <> (^2) would be nice
02:07:33 <jle`> if <> was (.)
02:07:36 <jle`> that's what Endo is for
02:07:42 <nitrix> I honestly don't see yet the use of Monoids, but I'll keep that question for tomorrow.
02:07:58 <nitrix> It's 5:11am here.
02:07:59 <julianleviston> Copperis:  you need = on otherwise
02:08:04 <jle`> like any other instance, it's nice for use in things that are generic over all monoids
02:08:12 <jle`> like...Writer
02:08:13 <julianleviston> Copperis: should be | otherwise = isPrime n xs
02:08:28 <Copperis> julianleviston, right, that works, thanks!
02:08:37 <julianleviston> nitrix: it’s just a way to reify joining things in a structure together.
02:08:46 <jle`> some people use (a -> a)'s as the Writer's log value, and so tell is composition
02:09:03 <Hafydd> julianleviston: another use of Endo is in defining foldr in terms of foldMap.
02:09:03 <jle`> also sometimes it's nice to be able to say mconcat instead of foldr (.) id i guess.
02:09:24 <julianleviston> nitrix: like rather than to say 1 + 3 + 3, you can say (Sum 1) <> (Sum 3) <> (Sum 3) and you’ve taken the “verb” and put it into the “noun”...
02:10:04 <julianleviston> nitrix: which can be REALLY handy :)
02:10:53 <julianleviston> > foldr (<>) (Sum 0) $ map Sum [1,2,3,4,5]
02:10:55 <lambdabot>  Sum {getSum = 15}
02:10:55 <Hafydd> julianleviston: e.g. here: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.8.1.0/Data-Foldable.html
02:11:15 <julianleviston> Hafydd: ooh I haven’t looked at foldable yet. Nice.
02:11:42 <julianleviston> Hafydd: there’s something resolutely poetic about this language (and Math)
02:11:46 <Hafydd> julianleviston: and the idea of having functions themselves forming a Monoid is very Functional, if I might say so.
02:11:57 <julianleviston> Hafydd: indeed!
02:12:24 <julianleviston> Hafydd: oh… I might not have properly understood you. You mean ((->) r) forms a Monoid?
02:12:43 <julianleviston> Hafydd: what’s mempty for ((->) r) ?
02:12:45 <Hafydd> julianleviston: by which statement?
02:12:49 <julianleviston> Hafydd: id?
02:12:55 <Hafydd> julianleviston: yes, id is mempty for Endo.
02:13:03 <jle`> julianleviston: you might mean (r -> r)
02:13:09 <julianleviston> jle`: really? 
02:13:10 <jle`> ((->) r) is the wrong kind
02:13:13 <julianleviston> oh
02:13:14 <jle`> Monoids are *'s
02:13:16 <julianleviston> I’m confused now.
02:13:19 <julianleviston> jle`: ahhh ok
02:13:23 <jle`> :t mempty
02:13:24 <lambdabot> Monoid a => a
02:13:25 <arkeet> Endo and r -> r have different Monoid instances.
02:13:43 <julianleviston> :t mempty :: Endo
02:13:44 <lambdabot>     Expecting one more argument to ‘Endo’
02:13:45 <lambdabot>     Expected a type, but ‘Endo’ has kind ‘* -> *’
02:13:45 <lambdabot>     In an expression type signature: Endo
02:13:48 <Hafydd> :t mempty :: Endo ()
02:13:49 <lambdabot> Endo ()
02:13:56 <julianleviston> hm.
02:14:05 <arkeet> :t mempty :: () -> ()
02:14:06 <lambdabot> () -> ()
02:14:09 <arkeet> well, not that there's much there.
02:14:27 <arkeet> well here:
02:14:30 <jle`> you can get a Monoid instance for (a -> a) where (<>) = (.) and mempty = id...there's also a Monoid instance for (a -> m) where m is a Monoid, where (<>) = liftA2 (<>) and mempty = pure mempty
02:14:46 <jle`> the second is basically the free Monoid instance you get for every Applicative
02:14:49 <arkeet> ^
02:14:50 <julianleviston> jle`: oh that makes sense.
02:15:08 <arkeet> > (id <> id :: String -> String) "abc"
02:15:10 <lambdabot>  "abcabc"
02:15:11 <jle`> the second one is pretty useful too
02:15:18 <arkeet> > appEndo (Endo id <> Endo id :: Endo String) "abc"
02:15:19 <lambdabot>  "abc"
02:15:28 <jle`> presto appEndo
02:15:56 <jle`> > presto appEndo (Endo id <> Endo id :: Endo String) "abc"
02:15:56 <arkeet> huh, appEndo sounds like how "append" might be said by a japanese person
02:15:58 <arkeet> :-(
02:15:58 <lambdabot>  "abc"
02:16:01 <arkeet> :t presto
02:16:02 <julianleviston> arkeet: so… Endo id == id ?
02:16:03 <lambdabot> a -> a
02:16:04 <Hafydd> Hahaha.
02:16:11 <arkeet> julianleviston: uh, those have different types.
02:16:15 <julianleviston> :t Endo id
02:16:17 <lambdabot> Endo a
02:16:18 <jle`> julianleviston: Endo is a newtype wrapper
02:16:21 <jle`> so they're identical at runtime
02:16:22 <julianleviston> oh
02:16:28 <jle`> they just have different Monoid instances
02:16:36 <jle`> kind of like... Sum 1 == 1, sorta
02:16:43 <jle`> Sum 1 and 1 are identical at runtime and mean the same thing
02:16:51 <jle`> but one has  Monoid instance and the other doesn't
02:16:59 <julianleviston> > getSum (Sum 1)
02:17:00 <lambdabot>  1
02:17:04 <julianleviston> like that?
02:17:15 <jle`> Endo id is just id, with a newtype wrapper to give it a different Monoid instance
02:17:15 <arkeet> > Sum 1 <> Sum 2
02:17:15 <julianleviston> appEndo Endo 5 == id 5
02:17:17 <lambdabot>  Sum {getSum = 3}
02:17:18 <Hafydd> @remember arkeet huh, appEndo sounds like how "append" might be said by a japanese person
02:17:18 <lambdabot> I will remember.
02:17:31 <julianleviston> ah so <> ends up being (.).
02:17:39 <arkeet> for Endo, yes.
02:17:46 <arkeet> Endo f <> Endo g = Endo (f . g)
02:17:47 <julianleviston> Hafydd: lol dude… I ALWAYS think that.
02:17:52 <julianleviston> Hafydd:  or dudette.
02:18:06 <jle`> i still chuckle sometimes when i use getSum
02:18:07 <arkeet> whereas
02:18:11 <arkeet> (f <> g) x = f x <> g x
02:18:13 <Hafydd> Hahaha.
02:18:13 <julianleviston> arkeet: so Endo is kind of like… the datatype for a function?
02:18:19 <arkeet> it's just a newtype.
02:18:28 <arkeet> (and also the constructor for that newtype)
02:18:33 <jle`> Endo and Sum and Any and All are the same purpose
02:18:48 <jle`> they wrap values to give them alternative/new instances for typeclasses
02:19:01 <julianleviston> jle`: they also convey semantics, tho… right
02:19:25 <jle`> you can think of `Any True` as being more or less equivalent to `True` and equivalent to `All True`, except they all have different Monoid instances (or none)
02:19:44 <jle`> it's a dirty hack
02:19:52 <arkeet> I want an Xor monoid.
02:20:23 <jle`> i guess they are used to convey semantics too
02:20:35 <Hafydd> arkeet: that's interesting. What is the identity element?
02:20:43 <arkeet> False.
02:20:44 <jle`> don't answer :P
02:20:45 <julianleviston> jle`: it does feel a bit strange to be using newtypes for this. It’s almost like there’s something elegant trying to get out, but we haven’t quite got there yet ;-)
02:20:47 <arkeet> oops
02:21:19 <arkeet> Hafydd: sorry, were you asking about Endo or Xor
02:21:23 <arkeet> or something else
02:21:26 <Hafydd> arkeet: Xor.
02:21:28 <arkeet> okay.
02:21:36 <jle`> julianleviston: it's very different than the purpose that newtypes were originally invented for, but it's become the norm i guess
02:21:44 <Hafydd> Oh, yes, that does work.
02:21:45 <julianleviston> Hafydd: wouldn’t it be the not of whatever Any is?
02:21:45 <jle`> it doesn't really make me too happy either
02:21:46 <arkeet> @let xor :: Bool -> Bool -> Bool; xor = (/=)
02:21:48 <lambdabot>  Defined.
02:22:07 <arkeet> > (False `xor` False, False `xor` True, True `xor` False, True `xor` True)
02:22:08 <lambdabot>      Ambiguous occurrence ‘xor’
02:22:08 <lambdabot>      It could refer to either ‘L.xor’,
02:22:08 <lambdabot>                               defined at /tmp/mueval19374770841827336327.hs:1...
02:22:11 <arkeet> oh great.
02:22:15 <arkeet> @undefine
02:22:15 <lambdabot> Undefined.
02:22:15 <arkeet> :t xor
02:22:16 <lambdabot> Bits a => a -> a -> a
02:22:21 <arkeet> okay it already exists.
02:22:22 <arkeet> > (False `xor` False, False `xor` True, True `xor` False, True `xor` True)
02:22:24 <lambdabot>  (False,True,True,False)
02:22:29 <julianleviston> what’s list called?
02:22:33 <arkeet> ?
02:22:38 <julianleviston> “non determinism”?
02:22:39 <jle`> MaybeT is another newtype wrapper that people use often
02:22:45 <julianleviston> I feel like we need that for computation types...
02:22:51 <julianleviston> or something.
02:23:24 <jle`> it gives you a new Alternative instance (an alternative Alternative?), a new Applicative/Monad instance, etc. for your same old boring types
02:23:32 <Hafydd> julianleviston: the identity of Any is (Any False), and the identity of Xor would be (Xor False), as arkeet pointed out, so no, I don't think so.
02:24:04 <arkeet> but the identity of All is All True.
02:24:08 <arkeet> > mempty :: All
02:24:09 <julianleviston> Hafydd: what is xor then?
02:24:10 <lambdabot>  All {getAll = True}
02:24:21 <julianleviston> Hafydd:  I thought it was Not Or.
02:24:33 <julianleviston> Hafydd:  it’s been a while since I’ve looked at it
02:24:37 <jle`> not quite
02:24:38 <arkeet> @google xor wiki
02:24:39 <lambdabot> https://en.wikipedia.org/wiki/Exclusive_or
02:24:48 <julianleviston> yeah
02:25:04 <julianleviston> so… “one but not both” ok.. so it’s False… 
02:25:21 <Hafydd>   xor | True  False
02:25:22 <Hafydd> ------+------------
02:25:22 <Hafydd>  True | False True
02:25:22 <Hafydd> False | True  False
02:25:27 <julianleviston> yep. got it.
02:25:40 <julianleviston> erm.
02:25:40 <julianleviston> no
02:25:50 <julianleviston> one but not both
02:25:58 <julianleviston> the false case is True True
02:26:18 <jle`> And and Or are basically the same Monoid, and Xor is something else altogether.  And/Or and Xor are the only two possible two-element monoids I believe
02:26:19 <Hafydd> It's "exactly one; not both; not neither."
02:26:31 <jle`> s/Monoid/monoid
02:27:11 <julianleviston> jle`: aren’t there like… many combinations? 
02:27:46 <julianleviston> jle`: op x y = always x, or always y, or always not x, or always not y
02:27:56 <jle`> well, there aren't too many binary functions on a two-element set anyway
02:28:01 <julianleviston> jle`: maybe they’re just combos of other things and I don’t really know what I’m talking about.
02:28:10 <jle`> well, not all of those give you monoids
02:28:34 <jle`> op x y = x, what's the identity?
02:28:41 <Hafydd> The ones whose operations are constant functions certainly don't give monoids, as there couldn't be an identity element, for example.
02:28:45 <julianleviston> jle`: I dunno, what’s the identity of const?
02:28:57 <julianleviston> jle`: don’t worry about me. I don’t now what I’m talking about.
02:29:17 <jle`> there isn't an identity for op :: Bool -> Bool -> Bool; op x y = x, so it can't be the operation of a monoid
02:29:32 <julianleviston> 'k
02:29:39 <jle`> it's a perfectly valid semigroup though, it's called the left zero semigroup
02:29:42 <julianleviston> just semigroups
02:29:44 <julianleviston> yeah
02:30:23 <jle`> it actually isn't too difficult to find all of the two-element monoids
02:30:36 <jle`> if you have e and x, e <> x, e <> e, x <> e are already defined
02:30:40 <jle`> you just need to pick what x <> x is
02:30:51 <jle`> if x <> x = e, you have Xor.  if x <> x = x, you have And/Or
02:32:18 <jle`> (which one(s) give you a valid group?)
02:32:49 <jle`> anyways, heading to bed. night :)
02:34:00 <Copperis> I have a prime finding function from haskell's site http://lpaste.net/142685 How could I add a conditional to it to check if the prime is n, then return it? I'm learning haskell and can't figure out how to do it
02:35:46 <julianleviston> Copperis: it’s important to think this through yourself
02:36:18 <Copperis> probably, I don't know the syntax for it
02:36:21 <julianleviston> Copperis: you want a function that you will pass some n to… 
02:36:34 <julianleviston> Copperis: syntax for what?
02:36:44 <julianleviston> Copperis: I’m talking about knowing what you’re trying to do.
02:37:12 <julianleviston> Copperis: what should this function do? you pass it n, then what?
02:37:29 <julianleviston> Copperis: if it’s prime, it returns the number. If not then?
02:37:58 <Copperis> julianleviston, I know i'll need to pass n. But I don't know where do I put the conditional. As a guard in the for comprehension won't do, it will return a list with all values up to the number and then loop forever. What are other options?
02:38:27 <julianleviston> Copperis: no, think about it from the other end.
02:38:30 <Copperis> julianleviston, it should probably return true or false better then
02:38:38 <julianleviston> Copperis: aha :) yes
02:38:42 <julianleviston> Copperis: write the function you wish you had.
02:38:48 <julianleviston> Copperis:  from the outside in.
02:40:25 <julianleviston> Copperis: what you have to work with are the number “n”, and an infinite list of primes, right?
02:40:39 <Copperis> julianleviston, yes
02:40:51 <Hafydd> Woah, woah, how do you know that the list of primes is infinite?
02:41:00 <julianleviston> Copperis: so, can you think of a way, if I handed these things to you on the street, that you could *surely* give me an answer in finite space/time?
02:41:08 <Copperis> Hafydd, i assume it for this case
02:41:14 <Hafydd> Heh, alright.
02:41:18 <julianleviston> Hafydd: because the feeder is [2..]
02:41:35 <Hafydd> julianleviston: how does that prove that the list is infinite?
02:41:57 <Hafydd> (Is filter (const False) [1..] an infinite list?)
02:42:00 <julianleviston> Hafydd: by the fact that [2..] is.
02:42:15 <julianleviston> Hafydd: I think so, yeah.
02:42:39 <julianleviston> Hafydd: depends if you’re talking execution, or evaluation ;-)
02:42:42 <julianleviston> Hafydd: (not really)
02:42:44 <clinton> is there any rhyme or reason behind what goes in "Control" and "Data" categories in package?
02:43:14 <clinton> i.e. Control.Arrow, Data.Functor, Control,Applicative
02:43:15 <Copperis> julianleviston, only in infinite time and space
02:43:21 <julianleviston> Copperis:  huh?
02:43:44 <Hafydd> Well, I suppose it's arguable what "infinite list" means exactly, but I'd require the list of have an infinite number of elements.
02:43:45 <julianleviston> Copperis: anyway.. let’s not get distracted by inifinities too much.
02:44:22 <julianleviston> Hafydd: the point is, filter (<3) [1..] will for all intents and purposes tie your computer up until you cancel the operation.
02:44:31 <Copperis> julianleviston, I understand the problem, I don't know how to express it in haskell
02:44:41 <julianleviston> Copperis: express it in English first.
02:44:52 <julianleviston> Copperis: Step 1: Clearly state your problem.
02:46:16 <clinton> Hafydd: A simple definition of an infinite list l is if "length l" doesn't terminate in finite time. Your example is therefore infinite.
02:46:18 <julianleviston> Copperis: “I want to find out if a number is prime by writing a function that takes an “n”, and uses a list of primes, and tells me a Bool value in return”.
02:46:31 <bakhtiyor> hey everybody
02:46:50 <Hafydd> clinton: is "undefined" an infinite list, then?
02:47:29 <Copperis> julianleviston, that is pretty much it
02:47:32 <Hafydd> Also, it's possible that the RTS will notice that the evaluation is looping, and raise a <<Loop>> exception.
02:47:53 <julianleviston> Copperis: now, one thing you know is that taking from a list of primes that is (maybe?) infinite, you can stop once you get past your number, right?
02:48:00 <julianleviston> Copperis: thinking imperatively.
02:48:14 <julianleviston> Copperis:  thinking declaratively, we can say “My prime will be in the range 0 up to the number n”
02:48:20 <julianleviston> that’s a definite, right?
02:48:32 <Copperis> julianleviston, yes
02:48:57 <julianleviston> Copperis: so, you can “divide and conquer” this problem by taking THAT problem and writing a function for it.
02:49:15 <clinton> Hafydd: I guess so. Name one test that finite lists pass that undefined also passes?
02:49:24 <julianleviston> Copperis:  can you do that? it means… “take the list of primes and return a list of only the primes between 0 and some number”
02:49:29 <julianleviston> Copperis:  is that do-able?
02:49:47 <Copperis> julianleviston, I can do that with another function that takes a number and a list
02:49:54 <Hafydd> clinton: the (const True) test. I don't know what that's supposed to prove, though.
02:49:59 <Copperis> julianleviston, though I want to do it inside one function
02:50:01 <julianleviston> Copperis:  excellent. Do it, and pastie your function.
02:50:13 <julianleviston> Copperis: ok, well if you understand “where” syntax, you can do it inside one function
02:50:45 <julianleviston> Copperis: it’s best to do things simply at first… which would mean writing it in a separate function… just like it’s best when you start doing math to show your entire working out, then “compress” it later, when you’re capable.
02:51:13 <Hafydd> clinton: my definition of an infinite list would be: you take take the tail of the list an infinite number of times without failure to terminate.
02:51:17 <julianleviston> Copperis:  the other advantage is you can test it separately.
02:51:20 <julianleviston> Copperis:  to make sure it works
02:51:21 <Copperis> julianleviston, here's the other function that take the list http://lpaste.net/142687 I don't really understand how to merge those functions, though that's what I'm seeking to do
02:51:52 <julianleviston> Copperis: that’s not what we were talking about tho...
02:51:54 <Hafydd> clinton: otherwise it's either a finite list or a list that cannot be totally evaluated.
02:52:05 <julianleviston> Copperis: that’s the OTHER part of the function :) once you have a ranged list.
02:52:39 <julianleviston> Copperis:  oh actually… that’s kinda half of each.
02:53:07 <julianleviston> Copperis: so would you do the one that takes that list of primes and returns a list of primes LESS than the number passed in?
02:54:09 <julianleviston> Copperis: you need to reason this out yourself… the process I’m using is where you take pieces off that you can manage and do them, then combine them after to get the thing you want.
02:54:22 <Copperis> julianleviston, I didn't understand the question
02:54:27 <julianleviston> Copperis: ok.
02:55:00 <julianleviston> Copperis: so… you want a function that uses an (effectively) infinite list of primes, and a number (n) and answers whether it’s prime or not (True/False)
02:55:07 <julianleviston> Copperis: so you don’t know how to write that
02:55:09 <julianleviston> Copperis: but
02:55:23 <julianleviston> Copperis: one way to write that is to pull it into pieces and write the pieces, then join them later.
02:55:28 <Copperis> julianleviston, yup
02:55:33 <julianleviston> Copperis: so… how can you pull that into pieces?
02:55:45 <julianleviston> Copperis: first… take the “infinite” list, and make it finite.
02:55:49 <Copperis> well I already have, I have those two functions that do that
02:56:00 <julianleviston> Copperis: are you sure? I haven’t seen proof of that yet.
02:56:22 <Copperis> julianleviston, yup, works
02:56:28 <julianleviston> Copperis: huh?
02:56:34 <julianleviston> Copperis: oh so you’ve worked it out?
02:56:39 <julianleviston> Copperis: cool.
02:56:46 <Copperis> not really, the problem is those are two functions and I need one
02:56:50 <Copperis> :D
02:56:53 <julianleviston> Copperis: um...
02:57:09 <julianleviston> Copperis: I haven’t seen these functions. All I’ve seen is “isPrime” which isn’t correct.
02:58:11 <julianleviston> Copperis: isPrime just checks if the head is a number, returns false if it’s less than the number then exits.
02:59:18 <Copperis> julianleviston, it returns false if it is more or eq to the number, otherwise it recurses
02:59:43 <Copperis> that equal shouldn't be there
02:59:52 <julianleviston> Copperis: oh sorry, you’re correct. It does.
03:00:05 <Copperis> no worries
03:00:14 <julianleviston> Copperis: it’s not total, but I suppose that’s ok.
03:00:43 <bakhtiyor> is it worth to learn haskell over other languages for web development?
03:00:58 <julianleviston> bakhtiyor: it’s very good, but very correct.
03:01:15 <julianleviston> bakhtiyor: if you want something quick and dirty, you won’t want haskell.
03:01:28 <julianleviston> Copperis: ok… so you just have to plug that into your function that gets the limited list, and you should be golden.
03:02:30 <bakhtiyor> julianleviston: what do you exactly mean by your last statement? 
03:02:47 <julianleviston> bakhtiyor: huh?
03:02:54 <julianleviston> bakhtiyor: do you know what quick and dirty means?
03:03:09 <julianleviston> bakhtiyor: it means “not incredibly well made”
03:05:49 <bakhtiyor> julianleviston: yes, know, 
03:05:49 <bakhtiyor> your first statement is positive, but last is opposite
03:06:04 <julianleviston> bakhtiyor:  huh?
03:06:11 <julianleviston> bakhtiyor: Haskell is excellent.
03:06:23 <julianleviston> bakhtiyor: I don’t know if you want something excellent. I don’t know your priorities.
03:06:42 <julianleviston> bakhtiyor: most people would say “Of course I do” but they don’t really. They want something quick and easy, which is usually not excellent.
03:07:14 <julianleviston> Copperis: rename isPrime to isInList and make isPrime n [] = False;  isPrime n xs = isInList n (filterLessThanOrEqualTo n primes)
03:07:16 <bakhtiyor> i see
03:08:24 <julianleviston> bakhtiyor: with Haskell, you pay your problems up front. For example, the compiler won’t let you make syntax errors. This is great. You don’t have to write syntax error checking tests at all. However, you have to fix all your syntax errors before your code will compile! :)
03:08:25 <bakhtiyor> and so haskell is difficult to learn, right?
03:08:27 <Copperis> julianleviston, wouldn't that be still two functions? I've made it like this, though it doesn't compile -> http://lpaste.net/142688
03:08:31 <julianleviston> bakhtiyor: not at all!
03:08:38 <julianleviston> bakhtiyor: it takes time and effort.
03:08:50 <julianleviston> bakhtiyor: and it’s different than other programming languages.
03:08:59 <Copperis> and the starting doesn't go anywhere...
03:10:22 <julianleviston> Copperis: that looks a little confused.
03:10:37 <Copperis> yup
03:10:58 * hackagebot wxc 0.92.1.1 - wxHaskell C++ wrapper  https://hackage.haskell.org/package/wxc-0.92.1.1 (HenkJanVanTuyl)
03:11:09 <Copperis> I want a function that takes only a number and returns whether it's a prime or not
03:11:25 <bakhtiyor> julianleviston: also another compilers exactly do this too, or something misunderstood about "the compiler won't let you make syntax errors"
03:11:53 <Copperis> the recursing would have to happen inside it, because it itself wouldn't take a list as an argument
03:12:06 <julianleviston> something like this? Copperis: isPrime n = n `elem` (takeWhile (<n) allPrimes)
03:12:47 <julianleviston> Copperis: I don’t know how much Haskell you know, and if you’re trying to learn Haskell, or not… because this isn’t the best way to begin to learn it (IMO).
03:13:09 <julianleviston> bakhtiyor: Comparing to dynamic languages.
03:13:25 <julianleviston> bakhtiyor: I don’t know what your criteria is for language selection.
03:14:21 <bakhtiyor> julianleviston: for backend development, e.g. ecommerce, payment, ...
03:14:25 <julianleviston> Copperis: if you want, I can rewrite that to be recursive… but like I said, I don’t know what you’re trying to learn… recursion? haskell? or do you just want a primes function?
03:14:27 <Copperis> julianleviston, something like that, though you'd have to get allPrimes from somewhere
03:14:40 <julianleviston> Copperis: well I thought you already had allPrimes
03:14:45 <srhb> Copperis: You can take a look at how arithmoi does it, unless you just want to roll your own :)
03:15:08 <Copperis> I am following a tutorial and I'm doing this as a side exercise 
03:15:14 <julianleviston> Copperis: your sieve of eristothenes method (the first one you showed me) was fine.
03:16:00 <julianleviston> Copperis: tho i’m not sure that actually DOES get primes…
03:16:03 <julianleviston> Copperis:  I didn’t check it.
03:16:37 <Copperis> and I was trying to figure out how to modify that sieve of eratosthenes method to do a conditional and return a true/false
03:16:50 <julianleviston> Copperis: well one gets a list of primes… 
03:17:36 <julianleviston> Copperis:  it gets a list of primes, so you’d do what I did… put that in the where clause of a function that limits the numbers it takes to numbers less than or equal to n, then return elem of that with n. (which checks presence in a list).
03:18:19 <Copperis> julianleviston, that's one solution
03:18:23 <julianleviston> Copperis: if you only know recursion then you wouldn’t want to use filter, though, you’d want to write your own filter function… and you could also write `elem` with recursion, too.
03:18:29 <julianleviston> Copperis: what’s another?
03:18:30 <ocharles__> does anyone know if stack on windows uses minghc and if that means the `unix` library would be available?
03:19:29 <julianleviston> bakhtiyor: so I’m not sure what it is you’re asking, precisely… “is it good” is so vague and general. I’d say “yes”. :)
03:19:32 <cocreature> ocharles__: iirc it does use minghc but I have no idea if the unix library is available
03:19:46 <julianleviston> bakhtiyor: if you tell a little more about your context and requirements, then I can answer more precisely!
03:20:09 <Copperis> julianleviston, check each return value from the primes list: return true if that is the value; or false if the value is bigger than than the number we're looking for
03:21:06 <ocharles__> cocreature: ok, thanks - i think we're just going to go with a vm instead
03:21:33 <cocreature> ocharles__: what are you working on?
03:21:55 <ocharles__> cocreature: it's the haskell infrastructure hackathon today
03:22:04 <cocreature> ah right
03:22:04 <ocharles__> helping someone get hackage-server running, but she's running windows
03:22:07 <ocharles__> it's all so easy with nixos
03:22:08 <ocharles__> ofc
03:22:11 <cocreature> :)
03:22:53 <cocreature> I predict that in an hour she'll be running nixos if you sit next to her :)
03:23:06 <bakhtiyor> julianleviston: for rest api backend solution, e.g. grud operations to dbs(e.g. mongodb, ...), working with third-party services(e.g. data service quandl.com), responding json serialized entities, ...
03:23:28 <julianleviston> Copperis: that’s the same way, isn’t it? filter is implemented with recursion.
03:23:33 <suppi> bakhtiyor, this might help https://github.com/Gabriel439/post-rfc/blob/master/sotu.md
03:23:34 <julianleviston> Copperis: I think.
03:24:34 <Copperis> julianleviston, I don't know. Filter seems it would fit right in, I'll try it
03:26:21 <julianleviston> Copperis: well, all filter does is go over your list, and produce a new list with only items that pass a function of the type (a -> Bool)
03:27:02 <julianleviston> Copperis: all elem does is go through a list and check if an item is in it.
03:29:57 <julianleviston> Copperis: but you could do it by using dropWhile or takeWhile with a combined predicate that checks whether it’s the number and that it’s less than or equal to the number… tho you have the possability that there’s an empty list then… which means you’d have to put a conditional on it, or something like that. (Deal with the empty list case).
03:30:45 <Hafydd> Why not just "isPrime n = elem n (takeWhile (<= n) allPrimes)"?
03:31:16 <julianleviston> Hafydd: yeah, I suggested that a while back.
03:31:17 <Copperis> julianleviston, I'm writing something like that now
03:31:41 <julianleviston> Hafydd: I don’t think s/he knows filter yet… so I wasn’t 100% sure how best to help.
03:32:17 <julianleviston> Hafydd: or drop/takeWhile… but List comprehensions seem already learned :)
03:32:22 <Hafydd> I see.
03:33:33 <zipper> Hello how can I check whether an executable exists in haskell?
03:33:54 <julianleviston> zipper: do you mean filesystem searching?
03:33:57 <solatis> what do you mean with 'executable' ? specifically that it has the executable flag set ?
03:34:43 <Copperis> julianleviston, I know a bit about takeWhile, I'm following this tutorial, which is really great IMO http://learnyouahaskell.com, I'm up to about here: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#type-synonyms
03:34:44 <Maxdamantus> If it's an executable, it exists.
03:35:03 <julianleviston> Copperis: sigh… :( ok.
03:35:07 <julianleviston> Copperis: all good then :)
03:35:15 <Copperis> julianleviston, I wrote a function like this with your suggestions http://lpaste.net/142690 
03:35:19 <Copperis> it doesn't compile
03:35:32 <Copperis> what could be the problem?
03:35:52 <mniip> define "doesn't compile"
03:36:12 <julianleviston> mniip: the prime generator is wrong, I think. Just tried to compile it and it doesn’t typecheck
03:36:16 <codebje>     The function ‘takeWhile’ is applied to three arguments,
03:36:17 <codebje>     but its type ‘(a -> Bool) -> [a] -> [a]’ has only two
03:36:21 <codebje> that's probably a start :-)
03:36:35 <codebje> put "$" before filterPrime?
03:36:56 <codebje> mm, maybe not
03:37:04 <julianleviston> Copperis: I really recommend writing things in SMALL TINY CORRECT PIECES
03:37:10 <mniip> you need to wrap 'filterPrime [2..]' in parentheses
03:37:16 <julianleviston> Copperis: then stitching them together… the pieces… that you know are correct.
03:37:20 <mniip> so it's one argument
03:37:22 <mniip> and not 2
03:37:33 <julianleviston> Copperis: working in large steps is a guaranteed way to burn yourself out with Haskell.
03:37:37 <codebje>   0     n `elem` (takeWhile (<= n) $ filterPrime [2..])
03:37:56 <mniip> Copperis, for future reference, always include the error message when you say something "doesn't work"
03:38:11 <Copperis> mniip, ok, I'll do that
03:38:16 <julianleviston> Copperis:  do this: n `elem` (takeWhile (<= n) $ filterPrime [2..])
03:38:33 <Copperis> julianleviston, I'll keep that in mind, though I thought these are small pieces enough
03:38:34 <mniip> that's a redundant $
03:38:44 <codebje> redundant $s are my specialty
03:38:44 <mniip> n `elem` takeWhile (<= n) (filterPrime [2..])
03:38:47 <codebje> hlint loves me
03:38:51 <julianleviston> Copperis: clearly not if you don’t understand what you’re doing!
03:39:00 <julianleviston> mniip: thanks :)
03:39:22 <codebje> λ> isPrime 31219
03:39:23 <codebje> True
03:39:27 <codebje> looks ok to me now
03:41:33 <Copperis> julianleviston, thanks for the help
03:42:21 <julianleviston> Copperis: no worries. Just be careful with LYAH… once it gets past typeclasses, things can get confusing… in that case, don’t blame Haskell… :)
03:46:05 * hackagebot wx 0.92.1.0 - wxHaskell  https://hackage.haskell.org/package/wx-0.92.1.0 (HenkJanVanTuyl)
03:55:00 <RedNifre> Hi! I heard something about applicative being a superclass of monad now, but I did not quite understand what this means for "pure" vs "return" (vs whatever it's called for functors). Can somebody explain it to this haskell beginner?
03:56:29 <Hafydd> RedNifre: Functor does not have a pure/return!
03:56:37 <RedNifre> why not?
03:57:02 <liste> RedNifre it means that return = pure now
03:57:15 <liste> by default, at least
03:57:16 <RedNifre> yeah, but should I use pure or return?
03:57:26 <RedNifre> and why is it only the same by default?
03:57:28 <julianleviston> RedNifre: return if monad, pure if applicative.
03:57:55 <RedNifre> why? and why is there no return/pure for functors?
03:58:13 <julianleviston> RedNifre: well, what does a Functor do?
03:59:00 <julianleviston> RedNifre: sorry, a Functor instance.
03:59:18 <Hafydd> RedNifre: it isn't part of the definition of a Functor. It would also be impossible to define for some Functors, like (,) a and (->) r.
03:59:22 <RedNifre> okay, I looked up the definition so I guess the idea is to keep functors simple? Just something that can be fmapped?
03:59:35 <liste> that's what functors are
03:59:43 <liste> at least endofunctors on Hask
04:00:13 <RedNifre> Hafydd sorry, what do you mean with "(,) a and (->) r"?
04:00:19 <julianleviston> RedNifre: it applies a function to a structure… what does that have to do with “putting something into a structure” (which is what pure/return does).
04:00:59 <Hafydd> RedNifre: there is a Functor instance that maps the second element of a tuple and the return value of a function. Those are the respective types; also rendered as (a,) and (r ->).
04:01:14 <liste> > fmap (+1) (5,6)
04:01:15 <lambdabot>  (5,7)
04:01:42 <liste> > (fmap (+1) (\x -> x*2)) 10
04:01:43 <lambdabot>  21
04:01:59 <Hafydd> RedNifre: intuitively, and in programming terms, a functor can only modify existing structures, in general; it can't create new ones.
04:02:07 <RedNifre> Oh, so you can't implement a fretpurn for that because you wouldn't know what to put in the first position of the tuple, huh?
04:02:18 <Hafydd> RedNifre: yes, indeed.
04:02:28 <RedNifre> Thanks, I understand it now.
04:02:32 <Hafydd> If you had a type like (Void,a), it would be literally impossible.
04:02:37 <julianleviston> RedNifre: why not just use a function for that? ;-)
04:04:28 <RedNifre> what would happen if I always used "pure" instead of "return"?
04:04:46 <srhb> RedNifre: Sometimes you'd get an Applicative constraint rather than Monad.
04:05:04 <capisce> that's exactly what happens
04:05:09 <srhb> RedNifre: (when your function does not rely on other monadic things.)
04:05:30 <delYsid> If I have a library and an executable in my cabal file, why do I have to repeat the build-depends of the library in the executable section?  Am I doing something wrong?  I've seen cabal files which dont do that, and still work, but I dont seem to be able to replicate that.
04:06:20 <RedNifre> ...so I should always use the function that returns the most powerful thing because if the caller only needs an applicative returning a monad will still do, but if he needs a monad he would be disappointed when I return an applicative?
04:06:52 <Hafydd> Oh, well I suppose you can define pure for (r ->), since it's already Applicative. I was thinking of something else.
04:06:54 <srhb> RedNifre: That doesn't really make sense.
04:07:25 <RedNifre> srhb what exactly would be the harm if I forgot that "return" exists and always use pure?
04:07:35 <srhb> RedNifre: None whatsoever.
04:08:13 <RedNifre> Then I don't understand why I would ever use return.
04:08:14 <Hafydd> RedNifre: there is a proposal to remove "return" from the Monad typeclass and make it defined in terms of pure.
04:08:16 <srhb> RedNifre: Monad implies Applicative, so if the type in question, the monad interface can be used regardless of whether you used pure or not. If it isn't a monad, you wouldn't even be able to use pure instead of return.
04:08:23 <srhb> RedNifre: You don't have to, ever.
04:08:24 <julianleviston> srhb:  what about if he doesn’t include Applicative? pure won’t be there...
04:08:42 <Hafydd> RedNifre: many agree that it's useless to have at all.
04:08:49 <srhb> RedNifre: Once Applicative was "discovered" and implemented, return became superfluous in theory, and in practice after AMP.
04:09:05 <srhb> RedNifre: In other words, return is there for hysterical raisins.
04:09:19 <srhb> This only became true in the last year though. :)
04:09:24 <m0rphism> julianleviston: pure is in Prelude since GHC 7.10
04:09:24 <RedNifre> but if all monads are applicatives now, then I would import monad when I need something like >>= and I would import applicative when I need pure and I would import Functor if I need fmap.
04:09:43 <srhb> RedNifre: They're both in Prelude.
04:09:46 <julianleviston> m0rphism: yep.
04:09:49 <RedNifre> Speaking of fmap, why is their map, fmap and <$> but no fmap for monad?
04:10:03 <srhb> RedNifre: Applicative implies Functor.
04:10:08 <julianleviston> RedNifre: mapM?
04:10:17 <srhb> julianleviston: That's not the same.
04:10:25 <julianleviston> srhb: what’s he mean then?
04:10:27 <Hafydd> RedNifre: <$> is just an infix version of fmap, nothing more. It happens to be defined in Applicative for... aesthetic reasons, I suppose.
04:10:33 <julianleviston> srhb: if he wants a functor map, then that’s fmap.
04:10:42 <julianleviston> srhb:  for a loose definition of “mapping”
04:10:45 <srhb> julianleviston: That's what I'm pointing out. :)
04:10:47 <Hafydd> RedNifre: by which I mean the Applicative module, not the typeclass.
04:11:03 <Copperis> Can someone explain why the dollar sign doesn't work in this contrived example?: 3 `elem` take 10 $ repeat 2
04:11:22 <julianleviston> Copperis: because it’s not REALLY brackets.
04:11:23 <srhb> Copperis: The problem is that take 10 is not a list
04:11:29 <RedNifre> Copperis I would guess that you need more brackets
04:11:32 <srhb> Well, that's ONE problem
04:11:47 <Copperis> 3 `elem` take 10 (repeat 2) works
04:11:58 <julianleviston> Copperis: ($) is function applicatoin
04:11:59 <RedNifre> The $ has a very low priority (maybe lowest?)
04:12:01 <Hafydd> Copperis: that is equivalent to: (3 `elem` take 10) (repeat 2).
04:12:40 <julianleviston> > (+1) $ 1
04:12:42 <lambdabot>  2
04:12:48 <julianleviston> > (+1) $ $ 1
04:12:50 <lambdabot>  <hint>:1:8:
04:12:50 <lambdabot>      parse error on input ‘$’
04:12:50 <lambdabot>      Perhaps you intended to use TemplateHaskell
04:12:57 <julianleviston> > (+1) ((1))
04:12:59 <lambdabot>  2
04:13:05 <Hafydd> "(+1) $ 1" is one of the most disgusting things I've seen recently.
04:13:12 <julianleviston> Hafydd:  lol.
04:13:14 <RedNifre> Hafydd I don't understand, I would find it more intuitive if <$> was part of Functor with a default implementation (<$>) = fmap
04:13:15 <julianleviston> Hafydd: sorry :)
04:13:37 <Hafydd> RedNifre: I agree that it would be.
04:13:39 <RedNifre> I guess I find it weird that syntax is linked to type class instead of functionality.
04:13:41 <srhb> RedNifre: That's what it is. There is no "default" implementation because it needn't be part of the typeclass mechanics.
04:13:46 <Copperis> I think I don't understand how the functions are associated here, I'll have to read up on associativity
04:13:52 <srhb> RedNifre: It simply is fmap
04:13:59 <liste> @src (<$>) -- RedNifre
04:14:00 <lambdabot> Source not found. You speak an infinite deal of nothing.
04:14:02 <Hafydd> RedNifre: but FWIW, it is defined exactly as (<$>) = fmap. It doesn't have a "default implemenetation" because it's not part of a class.
04:14:09 <liste> <$> = fmap, literally
04:14:10 <m0rphism> RedNifre: then it would be possible to give (<$>) and fmap different implementations
04:14:34 <RedNifre> where is <$> = fmap defined exactly?
04:14:50 <srhb> RedNifre: In Data.Functor
04:14:55 <Hafydd> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.8.1.0/src/Data-Functor.html#%3C%24%3E
04:15:03 <Hafydd> RedNifre: ^
04:15:07 <RedNifre> What, in functor? So I don't need applicative to use it?
04:15:12 <srhb> RedNifre: Nope
04:15:14 <srhb> :t (<$>)
04:15:15 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:15:30 <srhb> Though that has nothing to do with the module in which it is defined.
04:15:34 <srhb> That's just its type.
04:15:49 <RedNifre> Ah, guess I had a missunderstanding there. I thought fmap was for functors and <$> came together with <*> for applicatives...
04:16:00 <Hafydd> The way Haskell's modules are structured are also the subject of a bit of discontent.
04:16:00 <srhb> That was the motivation for <$>, I think
04:16:04 <julianleviston> RedNifre: what’s the non-operator version of <*> ?
04:16:07 <srhb> Because foo <$> bar <*> baz is pretty
04:16:16 <srhb> julianleviston: It doesn't exist, but ap, more or less.
04:16:17 <srhb> :t ap
04:16:18 <lambdabot> Monad m => m (a -> b) -> m a -> m b
04:16:26 <julianleviston> srhb: I know it doesn’t exist.
04:16:39 <srhb> Um, okay. :)
04:17:03 <julianleviston> srhb: was a hint as to why <$> is often connected with Applicative, is all.
04:17:08 <srhb> Ah.
04:17:15 <RedNifre> Yeah, I read the monad applicative proposal and I think it said things like "<*> is ap but not really." etc. I guess I'm not the target audience of that proposal :)
04:17:22 <julianleviston> Hafydd:  I hope that the module system gets overhauled sometime… it’d be nice if they were somehow programmatic.
04:17:42 <julianleviston> Hafydd:  and if GHC allowed multiple modules in single files.
04:17:44 <Hafydd> julianleviston: programmatic? How so?
04:18:36 <julianleviston> Hafydd: like data, pretty much.
04:18:40 <RedNifre> and what's the deal with "map"? I always wondered why fmap wasn't just called map, then I discovered this existing "map" function that seems to be fmap but limited to lists. I don't understand why that is needed, but wouldn't it be cleaner to call the generic function "map" and the list specific one "lmap" or something like that?
04:18:58 <srhb> RedNifre: It used to be the constrained version to only work on lists, to make it easier to understand for newcomers
04:19:00 <srhb> :t map
04:19:01 <lambdabot> (a -> b) -> [a] -> [b]
04:19:04 <srhb> Ah, it still is
04:19:18 <srhb> RedNifre: Some people think that's a mistake.
04:19:34 <srhb> But yes, only pedagogical reasons.
04:19:53 <RedNifre> I'm a newcomer and I don't understand how that helps. I get confused when I discover functions that seem to sort of do the same thing but not really.
04:19:57 <Hafydd> julianleviston: oh, like Python? Well, I'd hope it's done carefully.
04:20:00 <julianleviston> srhb: tho sometimes it can be a hint… someone was mentioning the other day that it’s quite useful sometimes
04:20:04 <srhb> RedNifre: Yes, you're not the only one. Sorry. :)
04:20:22 <liste> RedNifre compiler error messages
04:20:23 <julianleviston> srhb: (having map as well as fmap)
04:20:32 <liste> > map (+1) (1,2,3)
04:20:33 <lambdabot>      Couldn't match expected type ‘[b]’
04:20:33 <lambdabot>                  with actual type ‘(Integer, Integer, Integer)’
04:20:33 <lambdabot>      In the second argument of ‘map’, namely ‘(1, 2, 3)’
04:20:36 <srhb> julianleviston: I don't feel strongly either way.
04:20:42 <julianleviston> srhb: same.
04:20:43 <liste> > fmap (+1) [1,2,3]
04:20:44 <lambdabot>  [2,3,4]
04:20:48 <liste> > fmap (+1) (1,2,3)
04:20:49 <lambdabot>      No instance for (Show t0)
04:20:50 <lambdabot>        arising from a use of ‘show_M660872581329277412511435’
04:20:50 <lambdabot>      The type variable ‘t0’ is ambiguous
04:21:43 <julianleviston> fmap (+ 1) (1,2,3) :: (Int, Int, Int)
04:21:46 <julianleviston> will that work?
04:21:52 <RedNifre> what the hell. wouldn't it be a more pedagogic solution to have better compiler errors?
04:21:59 <srhb> RedNifre: Yes, but that's hard.
04:22:18 <srhb> RedNifre: And I mean really hard. telepathically understanding what the user wanted hard.
04:22:20 <julianleviston> RedNifre: there *are* versions of haskell that focus on that… but they got rid of Typeclasses, I think...
04:22:28 <m0rphism> in some cases it can be usefull to specialize type class instances. If my intent is to map over a list, then using `map` over `fmap` prevents me from accidentally mapping over a `Maybe`.
04:22:33 <reygoch> ahoy!
04:22:36 <srhb> julianleviston: That doesn't sound anything like Haskell. :-)
04:22:44 <reygoch> :D
04:22:48 <m0rphism> in some other cases, it may be wanted to be general an allow both Maybe and List
04:22:49 <julianleviston> srhb:  haha check out implementations in haskell.org
04:22:55 <RedNifre> julianleviston originally I would expect that to produce (2,3,4) but since I learned that the functor instance for tuple only maps the second element I'd assume it does something else but since you asked I would guess the answer is "no, it doesn't work".
04:23:16 <srhb> I don't think there's even a Functor instance for a three-tuple to start with.
04:23:16 <Copperis> How can I create a partially applied function like this: 3 `elem` take 10 ; I.e. so I'd have to pass the list only? let partial = 3 `elem` take 10; doesn't work
04:23:17 <julianleviston> RedNifre: no, not 2,3,4, it should be 1,2,4
04:23:23 <reygoch> did anyone use "Users" library perhaps?
04:23:37 <julianleviston> Copperis: it’s automatically partial by default
04:23:38 <m0rphism> and `map` is somewhat shorter than specializing fmap via `fmap :: (a -> b) -> [a] -> [b]`
04:23:42 <reygoch> I need some advice on how to implement it
04:23:52 <Hafydd> In fact, the Functor instance is only for pairs (a,b). I don't know what it's doing with (,,).
04:23:56 <julianleviston> Copperis: (*2) is a function that takes one number, for example.
04:24:21 <julianleviston> Copperis: filter (<3) is a partial function that takes a list and gives you only vals less than 3.
04:24:21 <m0rphism> i would prefer something like the partial type application which comes in ghc 8, just for type classes, such that I can write `fmap @[]` to specialize `fmap` to lists
04:24:31 <RedNifre> but why isn't there a pedagogic prelude that has the simple "map" and a default prelude that has the practical "map"?
04:24:49 <julianleviston> RedNifre: how would you know which was which?
04:24:55 <julianleviston> RedNifre: when talking in here?
04:24:58 <Hafydd> RedNifre: there is one.
04:24:59 <julianleviston> RedNifre:  or other places.
04:25:05 <Copperis> julianleviston, ok, but writing "let partial = 3 `elem` take 10" doesn't work. It returns: Couldn't match expected type ‘[a0]’ with actual type ‘[a1] -> [a1]’ Probable cause: ‘take’ is applied to too few arguments 
04:25:07 <RedNifre> fair point
04:25:28 <srhb> Copperis: Just include the argument. If you mean how to do it pointlessly, then you'll have to compose
04:25:33 <Hafydd> RedNifre: or rather, there is a practicel Prelude called Classy Prelude, but it isn't default.
04:25:33 <julianleviston> Copperis: because of your parens.
04:25:35 <srhb> Copperis: ie elem 3 . take 10
04:25:38 <Hafydd> *pratical
04:25:45 <int-e> RedNifre: a quick search turned up https://hackage.haskell.org/package/simpleprelude
04:25:48 <julianleviston> Copperis:  what srhb said above!
04:26:18 <srhb> Copperis: They are exactly equivalent, so it's usually best to include the argument for clarity.
04:26:28 <reygoch> Does anyone have any experience on implementing user authentication in haskell? I'm having some doubts on how to organise certain things.
04:26:48 <julianleviston> reygoch: you might need to include a bit more context...
04:27:08 <julianleviston> reygoch: web? database? os-level? other?
04:27:08 <reygoch> "users" library in particular
04:27:12 <reygoch> web
04:27:31 <Copperis> uh, I got confused. "take" takes two arguments, a number and a list. srhb, I don't have the list at the moment
04:27:49 <srhb> Copperis: right, so you have foo xs = 3 `elem` take 10 xs
04:27:56 <reygoch> actually, web and database implementation
04:28:12 <julianleviston> Copperis: as in… foo is a function ! :)
04:28:13 <srhb> Copperis: It's a function that given a list gives you whether 3 is a element among the first 10 in the list.
04:29:11 <RedNifre> Copperis take takes one argument (count) and returns a function that takes one argument (list)
04:29:14 <reygoch> cc
04:29:56 <Copperis> srhb, ok, you're using the function definition syntax. Doesn't it work with "let" ?
04:30:15 <srhb> Copperis: let foo = bar is special syntax that only exists in do blocks (and thus ghci)
04:30:29 <reygoch> if I want to retrieve just user id and username for one web view and for some other I'd like to retrieve username and email for example, do I have to create 2 data types for that?
04:30:34 <srhb> Copperis: In a normal .hs file, you would simply write fun arg1 arg2 arg... = value 
04:30:57 <srhb> Copperis: In ghci it would be let foo xs = 3 `elem` take 10 xs
04:31:11 <srhb> Copperis: Or equivalently let foo = elem 3 . take 10
04:31:55 <RedNifre> reygoch you could use different tuples or one big record full of Maybes or different types or a map from String to String or something else.
04:32:04 <Copperis> srhb, ok, got it. Thanks
04:35:04 <reygoch> I'm a bit doubtful, because Users library has data type "User" which doesn't contain id field but it contains several other fields. So I would have to create data types like UserProfilePublic and UserProfilePrivate which would than contain required fields?
04:35:23 <reygoch> This seems a bit repetitive to me.
04:40:05 <RedNifre> speaking of accessing the same data in different ways/subsets, could someone give me an easy summary regarding these "lenses" and "prisms" I'm too afraid to look up?
04:40:23 <srhb> RedNifre: Not really. :P
04:40:27 <srhb> RedNifre: You should look it up,.
04:40:43 <dramforever> reygoch: What about a record containing your original User type? does it make sense?
04:40:46 <RedNifre> I just sort of maybe understand monad transformers, would lenses/prisms be a good next step? I also heard of comonads...
04:40:59 <RedNifre> or, to ask more clearly: which haskell concepts should I work through in which order?
04:41:24 <RedNifre> before I began with haskell I thought monads would be the end, but it looks like they are just the beginning...
04:41:27 <srhb> RedNifre: I don't personally think it works that way. Lenses are nice when you need lenses.
04:41:50 <dramforever> if that User contains fields you don't have in your new type...If I were you I would choose to write another type. that's my two cents on that matter
04:41:51 <srhb> RedNifre: If you want to learn every possible concept in Haskell, I don't think lenses are somehow a better choice than any other subject. :)
04:42:01 <RedNifre> srhb the thing is that I won't notice that I need them if I don't understand them first.
04:42:03 <srhb> RedNifre: In my experience, there is no "end"
04:42:22 <srhb> RedNifre: Right, well, okay. One problem lens solves is digging into nested record fields, providing getters and setters.
04:42:32 <srhb> RedNifre: If you start needing that, it's an excellent time to learn lens.
04:42:53 <RedNifre> no, I meant which concepts are useful. Monads are pretty useful and considering the rumors I heard about lenses they might be useful for reygoch (no guarantees!)
04:43:19 <RedNifre> ah, thanks.
04:43:53 <reygoch> Say I have user defined in DB as (id, username, email, password) and I have User {id::Int, username::String, email::String, password::String} I don't really want to query all columns of database when I need just 2 for example UserPublic {id::Int, username::String}, how can I avoid this duplication?
04:44:46 <RedNifre> Maybe generate all possible combinations with template haskell? :)
04:44:53 <srhb> reygoch: I don't think we have a really nice story for that case.
04:44:54 <reygoch> I can do "select * from user" and than map constructor over result like User <$> field <*> field <*> field ...
04:44:58 <RedNifre> DISCLAIMER: Don't listen to me, I have no idea ;)
04:45:36 <reygoch> but I can't really do the same for "select id, username from user"
04:45:41 <RedNifre> reygoch when I had that problem I wrote a ruby script that generated haskell code for differently sized tuples because I wasn't in the mood for learning template haskell yet ;)
04:45:49 <reygoch> XD
04:45:53 <RedNifre> don't try this at home!
04:45:55 <reygoch> me too
04:46:09 <reygoch> but I thought there was cleaner way
04:46:16 <reygoch> maybe with Maybe values
04:46:21 <reygoch> XD
04:46:51 <reygoch> but again, I can't skip fields when mapping over query results
04:46:52 <srhb> reygoch: That's a bit icky too, since you can't really wrap up every field in a Maybe automatically.
04:48:08 <reygoch> is it possible to apply Nothing to certain fields of user without any order and than use currying to apply sql results that I need?
04:48:25 <RedNifre> well, in the database world you would create a view for that. Maybe there is a nice library that allows you to do something like that?
04:48:26 <srhb> You can't apply Nothing to anything.
04:48:50 <julianleviston> srhb:  why can’t you build up a set of cols?
04:49:01 <reygoch> e.g. User {password = Nothing} <$> username <*> email ...?
04:49:04 <julianleviston> srhb: coz of the shape of the rueturn data?
04:49:07 <srhb> julianleviston: You can.
04:49:08 <reygoch> yes
04:49:17 <julianleviston> srhb: wouldn’t that solve this problem?
04:49:47 <julianleviston> srhb: pretty sure I remember seeing some libs that let you compose db queries etc.
04:49:56 <RedNifre> you mean like retrieving all the data but censoring some parts before handing it to the web view?
04:50:01 <srhb> julianleviston: Assuming you really mean Set, you'd have to basically do some existential stuff to have all the different result types there
04:50:05 <srhb> I don't think it's very neat.
04:50:11 <srhb> I'm also not sure how people usually deal with this. :)
04:50:15 <reygoch> thing Is I don't want to retrieve all data :D
04:50:19 <julianleviston> srhb: list would do fine, wouldn’t it?
04:50:26 <julianleviston> reygoch: that’s what I’m talking about.
04:50:33 <reygoch> ?
04:50:36 <srhb> julianleviston: How do you fit both UserId and UserName in the list?
04:50:41 <julianleviston> reygoch: which db lib are you using?
04:50:48 <reygoch> postgre-simple
04:50:59 <julianleviston> srhb: in an algebraic polymorphic type?
04:51:23 <julianleviston> srhb: “DBResultColVal” ? :)
04:51:23 <RedNifre> maybe you need some lenses, prisms, colenses, coprisms etc. and a SQL database library that lets you apply these optics to queries instead of records where they magically turn into sql views...
04:51:25 <srhb> julianleviston: Right. So now you have some kind of [QueryResult] which includes every possible column.
04:51:40 <RedNifre> (the previous statement may or may not have made sense)
04:51:40 <srhb> It might not be so bad, just feels.. Icky. But that's the tradeoff of no subtyping I guess.
04:51:58 <reygoch> I don't really know lenses yet
04:51:58 <julianleviston> srhb: um, it’s still typed… 
04:52:09 <srhb> julianleviston: Of course.
04:52:12 <reygoch> I have general intuition about them, but not enough to actually use them
04:52:36 <RedNifre> that's better than what I got, I only heard about them in a Haskell podcast recently :)
04:53:22 <reygoch> hm... well, I gtg now
04:53:25 <reygoch> cya
04:53:29 <RedNifre> cya
04:53:37 <xenog> I would like somebody with experience with FFI and FunPtr to help me a bit with this: https://github.com/haskoin/secp256k1/blob/master/test/Crypto/Secp256k1/Foreign.hs#L193
04:54:01 <xenog> I cannot call that foreign function no matter what.
04:55:51 <RedNifre> Just for fun, what is the most complex correct thing you can say about Haskell? Something above "monads are just applicative endo functors"... maybe something like "If your homoiconic type familly is isomorphic to the prism's comonads you can intercalate you transformers to sequence arrows into bindings". You know, like that only correct? :)
04:57:07 <julianleviston> RedNifre: what do you mean by complex?
04:57:21 <julianleviston> RedNifre: do you mean “impressive sounding if you don’t know the terminology?”
04:57:44 <RedNifre> yes, something like that. I.e. the largest number of concepts that are exclusive or nearly exclusive to haskell.
04:58:05 <julianleviston> RedNifre: I dn’t think any of those things are exclusive to haskell
04:58:29 <julianleviston> RedNifre: most of it is just math.
04:58:36 <RedNifre> -eclusive +not common outside of haskell.
04:59:18 <julianleviston> RedNifre: well look at the wikipedia entry for Functor… that’s nothing to do with Haskell particularly… https://en.wikipedia.org/wiki/Functor
05:00:55 <ralu> this is like babling abou C and Touring machines at same time
05:01:23 <julianleviston> ralu: what’s a touring machine? do you mean turing?
05:01:31 <ralu> yes turing
05:13:34 <xplat> 'touring machines' actually is a thing though
05:20:39 <julianleviston> it is :)
05:21:11 <julianleviston> I mean It is? :)
05:21:43 <julianleviston> Here’s the databas stuff I was talking about before… opaleye… (assuming postgres) https://github.com/tomjaguarpaw/haskell-opaleye/blob/master/Doc/Tutorial/TutorialBasic.lhs
05:22:27 <julianleviston> I’m a bit miffed that “not mature” was the rating we gave to ourselves about the state of haskell for databases…
05:26:19 <zomg> julianleviston: interesting, does that include things like acid-state or also clients for postgre and such?
05:26:37 <zomg> at least client-wise it always seemed reasonably mature
05:26:45 <deos> test
05:27:03 <zomg> deos: pass
05:27:22 <julianleviston> zomg: does what include that? the SOTU?
05:27:38 <julianleviston> @where sotu
05:27:38 <lambdabot> I know nothing about sotu.
05:27:42 <julianleviston> @where SOTU
05:27:42 <lambdabot> I know nothing about sotu.
05:27:43 <julianleviston> hm
05:27:44 <zomg> :D
05:27:54 <zomg> state of @where is not mature as well... ;)
05:28:11 <julianleviston> zomg:  https://github.com/Gabriel439/post-rfc/blob/master/sotu.md
05:28:15 <julianleviston> lol
05:28:21 <zomg> thanks
05:28:29 <julianleviston> zomg: there’s a blog post - it’s Gabriel. I just don’t know it off the top of my head.
05:28:57 <julianleviston> zomg: the github is more up to date anyway, I think.
05:30:56 <julianleviston> zomg: also, the ratings seem kind of arbitrarily chosen. Never really sure about what best-in-class vs mature means… seems to be somehow related to other languages and whether someone coming from outside could get up to speed quickly or something.
05:33:38 <zomg> julianleviston: yeah, need to take things with a grain of salt usually but interesting still :)
05:35:02 <zomg> ah yeah, the immature rating seems to be because of exactly what I thought
05:35:17 <julianleviston> zomg: what’s that?
05:35:18 <zomg> The clients are mature, but there's a lack of ORM type stuff
05:35:26 <zomg> I mean it says it right there :) https://github.com/Gabriel439/post-rfc/blob/master/sotu.md#databases-and-data-stores
05:35:39 <julianleviston> zomg: but that’s ridiculous ORM makes no sense in a non-ORM language.
05:36:12 <zomg> I think ORM in this case would refer to something like Persistent
05:36:47 <julianleviston> zomg: hm ok.
05:36:55 <asthasr> I can say that I despise ORMs, but I would like something in Haskell that looks more like this Clojure library: http://sqlkorma.com/
05:37:02 <zomg> or other libraries that could map raw DB results into haskell data types
05:37:21 <julianleviston> asthasr: isn’t that what that postgres thing I linked to is like?
05:37:41 <julianleviston> zomg: how many do we need before we’re “mature”? I mean, Ruby only has like… one… doesn’t it? lol
05:38:15 <julianleviston> and I’m assuming that’s what they’re comparing it to… that and spring/hybernate perhaps.
05:38:16 <julianleviston> Oh well :)
05:38:18 <julianleviston> grain of salt :)
05:38:19 <zomg> No idea :) I'd say there's at least a few with Ruby
05:38:33 <zomg> but for example the last time I checked, Persistent didn't handle relations so well
05:38:36 <hodapp> I don't know if I despise ORM; it's like despising crutches when the crutches are absolutely necessary, but the real question is why you have a broken leg.
05:38:47 <julianleviston> zomg: are there? I’m not aware of many. Active Record and Datamapper and I don’t even know if the latter exists anymore.
05:38:56 <julianleviston> hodapp: lol :)
05:39:21 <zomg> Yeah DataMapper is still around, used it quite recently as it was simpler to use than ActiveRecord (where the latter works nicely with Rails)
05:39:21 <asthasr> julianleviston, I didn't see the link (I may have come in afterwards?) I assume you mean postgresql-simple?
05:39:30 <julianleviston> zomg: true. But I’m pretty sure Opal does a great many more things than most ORMs do … “compositionally”
05:39:38 <julianleviston> asthasr: no. opaleye
05:39:52 <julianleviston> https://github.com/tomjaguarpaw/haskell-opaleye/blob/master/Doc/Tutorial/TutorialBasic.lhs
05:39:57 <julianleviston> fair point tho it’s only postgresql
05:40:24 <hodapp> hum, I've never looked at Opal
05:40:24 <asthasr> ahh
05:40:39 <asthasr> I hadn't looked at it. Its syntax looks less disgusting than most Haskell DB libraries :p
05:40:50 <asthasr> I do hate that it's so Postgres-specific, though
05:41:33 * hackagebot memscript 0.1.0.0 - Command line utility for memorizing scriptures or any other text  https://hackage.haskell.org/package/memscript-0.1.0.0 (KiYungAhn)
05:42:01 <asthasr> hodapp, I don't know that ORM is absolutely necessary as an abstraction; the construction of queries from dynamic snippets (as with Korma) seems, really, more sensible. -- that's a tangent, though, we could take it elsewhere
05:43:09 <hodapp> asthasr: That wasn't meant to say that ORM is absolutely necessary, but that it is a symptom, not a problem.
05:43:59 <zomg> From what I've used Persistent and Acid-State (not a whole lot mind you), some kind of approach between them would be nice
05:44:15 <zomg> Ie. I want to declare my data types and then just say "I want these to go into the database, do it"
05:44:21 <hodapp> That is: Nearly the entire reason for ORM is because of the mismatch between object-oriented, and relational.
05:44:34 <zomg> and then I could query it using some kind of reasonable syntax that gets checked at compiletime
05:46:12 <asthasr> hodapp, agreed.
06:04:36 <lynnard> to implement (=<<) using (<=<) I can do: let f =<< g = (f <=< (const g)) 0
06:04:47 <lynnard> but I find that 0 rather ugly; any thoughts?
06:06:46 <lynnard> no one..?
06:07:35 <phadej> lynnard: if it can be any time, make it ()
06:07:56 <lyxia> @ty \f g -> f <=< const g $ 0
06:07:57 <lambdabot> Monad m => (b -> m c) -> m b -> m c
06:07:58 <lynnard> oh yeah, cool forgot this one
06:08:13 <phadej> *type
06:30:28 <mniip> I wonder, is correctness of an inferred type signature a decidable problem
06:30:53 <mniip> er, rather, unambiguity of the inferred type
06:35:17 <deos1> test
06:35:27 <mniip> I mean, for example,
06:35:33 <mniip> @let func f x = f x x
06:35:34 <lambdabot>  Defined.
06:35:35 <mniip> :t func
06:35:36 <lambdabot> (t1 -> t1 -> t) -> t1 -> t
06:36:05 <mniip> @let func' :: Num a => a -> (forall b c. (Num b, Num c) => b -> c -> r) -> r; func' f x = f x x
06:36:06 <lambdabot>  .L.hs:152:13:
06:36:06 <lambdabot>      Couldn't match expected type ‘(b0 -> c0 -> r)
06:36:06 <lambdabot>                                    -> (b1 -> c1 -> r) -> r’
06:36:18 <mniip> oops
06:36:20 <mniip> @let func' :: Num a => (forall b c. (Num b, Num c) => b -> c -> r) -> a -> r; func' f x = f x x
06:36:21 <lambdabot>  Defined.
06:37:05 <ggole> mniip: what does this have to do with ambiguity?
06:37:23 <mniip> the type of "\f x -> f x x" is ambiguous
06:37:30 <mniip> it could be either that of func, or that of func'
06:37:34 <mniip> and they aren't even compatible
06:37:47 <ggole> Ah, that
06:38:03 <mniip> so inferring either is wrong
06:38:16 <ggole> My understanding is that higher order types make type reconstruction undecidable
06:38:27 <mniip> well, in context of higher order types, yes
06:39:09 <aweinstock> what's stacks equivalent to "cabal list"?
06:39:20 <aweinstock> s/stacks/stack's/
06:39:32 <ggole> mniip: isn't that the problem there? Perhaps I've misunderstood.
06:40:36 <mniip> ggole, hmm
06:40:51 <mniip> I guess the question is
06:41:01 <mniip> is decidability of type reconstruction decidable?
06:43:10 <orion> Is it accurate to say that all monad transformers are monads, but not all monads are monad transformers?
06:44:47 <liste> orion no, monad transformers transform monads
06:44:55 <liste> they're not monads themselves
06:45:10 <liste> but the transformed monads are monads
06:45:19 <orion> Then why do people say, "the State monad"?
06:45:28 <liste> because State /= StateT
06:45:40 <orion> type State s = StateT s Identity
06:45:51 <Hafydd> The State Functor.
06:45:52 <liste> that's transformed Identity
06:46:07 <liste> Identity is a monad, so StateT s Identity is a monad
06:48:21 <orion> Do all transformers have kind * -> (* -> *) -> * -> * ?
06:49:07 <exio4> @kind MaybeT
06:49:08 <lambdabot>     Not in scope: type constructor or class ‘MaybeT’
06:49:09 <lambdabot>     Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
06:49:20 <lyxia> The first * is specific to StateT
06:49:58 <orion> I seer.
06:50:26 <lyxia> The MonadTrans typeclass expects (* -> *) -> * -> *
06:51:08 <m0rphism> orion: so some monads give rise to a monad transformer, which when applied to the Identity monad is isomorphic to the original monad.
06:51:31 <m0rphism> orion: this is in contrast with applicatives which are closed under composition: only some monads can be composed with other monads.
06:52:41 <orion> hmm
06:53:05 <deos1>  /msg NickServ VERIFY REGISTER deos1 olzmowiafmjv
06:53:14 <Jinxit> oopsie
06:53:21 <m0rphism> orion: `MaybeT m` for example basically corresponds to composing the `Maybe` monad with some other monad `m`
06:53:25 <deos1> ops
06:53:30 <orion> m0rphism: Ah ok
06:53:43 <adimit> Is it really the case that I have to define my own TimeLocale for parseTimeM to work, and that the default time library only supplies an American locale?
06:53:48 <adimit> Is there an alternative
06:53:51 <adimit> ?
06:54:17 <m0rphism> orion: for Applicatives `f1` and `f2` this can be done generally via `Compose f1 f2`
06:59:24 <orion> m0rphism: What exactly would you call the MonadState class?
07:01:16 <m0rphism> orion: The mtl-classes like `MonadState`, `MonadReader`, `MonadWriter`, etc have two purposes if I remember correctly.
07:02:39 <m0rphism> orion: The first is abstracting over similar monads, e.g. both the Reader and the State Monad contain a value which can be queried.
07:05:57 <m0rphism> orion: The second is abstracting over the other monads in a monad transformer stack.
07:08:51 <m0rphism> orion: For example if you use the `get :: MonadState m Int => m Int` from the MonadState type class, then it works for both `StateT Int Maybe` and `StateT Int []`
07:10:04 <m0rphism> orion: This can be useful if you write libraries and don't want to restrict the client to a particular monad transformer stack.
07:10:31 <orion> m0rphism: I had a discussion with Cale yesterday. He suggested that I create my own class: "class (Cipher c, Curve d) => MonadHandshake m c d | m -> c d where ..." and the class would have functions like getLocalStaticKey :: m (Maybe (KeyPair d)), modifyLocalStaticKey :: (Maybe (KeyPair d) -> Maybe (KeyPair d)) -> m ()
07:13:44 <m0rphism> orion: Might be reasonable. Then the users of your handshake monad might not need to use `lift` when using your monad in a transformer stack
07:15:04 <orion> m0rphism: I'm currently grappling with an issue.
07:15:49 <orion> https://github.com/trevp/noise/blob/master/noise.md#62-interactive-patterns- <-- These are "patterns" of cryptographic handshakes that two parties can engage in.
07:16:22 <aweinstock> how do I install libraries with stack?
07:16:43 <orion> "e, s, dhee, dhes, dhse, and dhss" are operations to be performed on a particular state
07:17:59 <orion> I'm thinking it might be fruitful to have my MonadHandshake class define the above operations, rather than what Cale suggested. What do you think, m0rphism?
07:21:10 <m0rphism> orion: sorry, I think I don't have enough context to give a reasonable answer :)
07:21:12 <sm> g'day all
07:21:35 <sm> foldl is in Prelude, but the recommended foldl' is not - really ? 
07:22:09 <ARM9> String is [Char] in prelude, aliens.
07:23:34 <orion> m0rphism: hah, ok
07:23:39 <m0rphism> orion: Oh, and I've just looked at the mtl classes again, I was partially mistaken. `MonadState` seems to only account for the second purpose (abstracting about the monad transformer stack)
07:25:04 <m0rphism> orion: I recently found a talk on the haskell reddit introducing and discussing various related concepts to the mtl classes.
07:25:15 <m0rphism> orion: If you're interested:  https://www.youtube.com/watch?v=8t8fjkISjus
07:26:03 <orion> Great, thanks!
07:26:19 <m0rphism> orion: You're welcome! :)
07:27:07 <srhb> sm: Yes, it's a surprising curiosity.
07:28:06 <sm> good that we have lots of interest in a better language & libs cleanup process right now
07:28:08 <srhb> sm: A new language report really ought to change that. :)
07:29:12 <sm> in an ideal world, usability could be so much better
07:29:34 <srhb> I think there are few usability problems in that regard. Most of it is tooling, and that's improving fast too.
07:29:58 <sm> there are many
07:40:34 <sm> hmm.. given a list of chars, how could I generate an infinite deterministic list of unique strings made from them ?
07:41:33 <srhb> sm: There are many options. You could take the first char and make longer and longer strings of just that.
07:41:48 <srhb> sm: Or you could cycle the string of chars and take successively longer strings...
07:41:50 <srhb> etc.
07:42:09 <sm> and, I forgot to say, if possible avoiding just repeating the same char ?
07:42:21 * hackagebot ekg-log 0.1.0.4 - Push metrics to a log file.  https://hackage.haskell.org/package/ekg-log-0.1.0.4 (ParnellSpringmeyer)
07:42:26 <sm> I'm generating some sample data with chinese characters, and would like it to look interesting
07:42:28 <m0rphism> sm: repeating the whole string of chars? :3
07:42:45 <ggole> let useless = "":useless
07:42:50 <ggole> Totally deterministic.
07:42:55 <m0rphism> sm: ah, ok for that purpose that's probably equally unintersting ;)
07:43:42 * sm has been fiddling with zip and fold and not getting anywhere fast
07:43:53 <ggole> So you want something like Chinese lorem ipsum?
07:44:53 <ggole> You could just use an auto-translation of that, if so
07:44:59 <sm> actually I'd like a sequence of unique "words", starting with one character per word and increasing the length as needed to avoid repetition
07:45:17 <sm> this is to generate eg 10000 unique short account names for hledger
07:45:53 <sm> (to test rendering of wide characters)
07:46:38 <sm> previously I was using uniquenamesHex = map hex [1..] where hex = flip showHex ""
07:46:50 <m0rphism> sm: Maybe use a pseudo-random number generator to select characters for which you always use the same seed?
07:47:03 <ggole> Hmm, if this were english I would suggest reading the contents of words
07:47:11 <sm> that's an idea, but a pure function would be nicer
07:47:26 <ggole> I don't think there is a widely available Chinese analogue though
07:47:26 <m0rphism> sm: A pseudo random number generator can be a pure function :)
07:47:32 <sm> ah
07:48:42 <sm> alright why not
07:48:51 <m0rphism> sm: afaik, they are mostly regular functions with complex behaviour and good properties about value distribution.
07:49:26 <m0rphism> sm: but you probably need to scan for duplicates if you want unique strings, or only take 1 string of each length
07:51:45 * sm thinks harder
07:54:29 <lpaste> cjay pasted “vararg inference problem” at http://lpaste.net/142697
07:57:46 * hackagebot pontarius-xmpp 0.4.5 - An XMPP client library  https://hackage.haskell.org/package/pontarius-xmpp-0.4.5 (PhilippBalzarek)
07:59:00 <cjay> any experts on varargs? http://lpaste.net/142697 :)
07:59:19 <cjay> I think the implicit call to (>>) confuses the type inference
07:59:46 <lyxia> cjay: replace a with () in the instance I guess
08:00:15 <geekosaur> varargs is always going to have its pain points, sadly
08:00:42 <cjay> lyxia: the commented out instance already uses ()
08:01:03 <lyxia> cjay: Ah, I didn't see it, my bad.
08:01:40 <Xnuk> exit
08:01:46 <Xnuk> sry
08:01:50 <cjay> the inference is unable to pick the StoryGen instance as long as I don't write (:: StoryGen) behind the tellAny calls
08:02:02 <cjay> because (>>) is too generic I guess
08:02:32 <cjay> if the tellAny call is the last thing in the do block, I don't need to write (::StoryGen)
08:03:40 <cjay> I never would have expected to use undefined to make something work :)
08:12:01 <sm> wow, why does this lock up so hard ? take (length l) $ chunk n $ cycle l
08:12:56 <srhb> sm: length l never terminates
08:13:01 <sm> doesn't respond to ctrl-C, I had to kill it 
08:13:08 <geekosaur> that seems odd
08:13:11 <srhb> sm: It probably would have at some point.
08:13:21 <srhb> Unless you ran out of memory first or something :)
08:15:02 <geekosaur> wouldn't run out of memory
08:15:11 <sm> I forgot to show chunk: https://gist.github.com/simonmichael/5b963f5660d7442df1dd
08:15:17 <geekosaur> which might actually be the problem as memory allocation is one of the points where it checks for that...
08:15:43 <geekosaur> ah, ok... that would allocate
08:16:07 <sm> eg: let l = "abc" in take (length l) $ chunk 2 $ cycle l
08:16:47 <sm> I see 100% cpu but only 500M resident
08:17:23 <srhb> Figuring out exactly where it can be interrupted is something I haven't yet done.
08:17:31 <srhb> I'm usually content killing things that run amok.
08:19:17 <geekosaur> places where thread context switches happen (none in this case) and memory allocation (none, or not enough, in this case)
08:19:20 <geekosaur> iirc
08:21:38 <sm> or better: take 3 $ chunk 2 $ cycle "abc". Did you say you see the cause ? 
08:21:56 <srhb> The cause that it cannot be interrupted? What geekosaur just said.
08:22:13 <lyxia> cjay: using bind "() <- tellAny ..." is another way to restrict the type but I guess that's also out of the question :)
08:22:27 <sm> I don't understand why it's hanging 
08:22:48 <srhb> sm: length of an infinite list is...?
08:23:18 <cjay> lyxia: yeah I found that too :)
08:23:19 <sm> oh there it is. Thank you :)
08:23:29 <srhb> sm: Sure.
08:23:48 <cjay> lyxia: I guess I could write custom operators to chain the stuff instead of using a do-block
08:23:53 <sm> time for some fresh air and breakfast
08:25:44 <Gurkenglas_> Why doesn't http://hackage.haskell.org/package/either have a https://hackage.haskell.org/package/bifunctors instance?
08:31:54 <SiIky> how do i define the function power, recursively, if the exponent is negative? (eg: power 2 -2 = 0.25) Function type should be power :: Num a => a -> Int -> a (im fairly new to Haskell)
08:32:20 <mniip> you can't do "0.25" with Num
08:32:32 <asthasr> you'll have to use Floating.
08:32:42 <mniip> :t 0.25
08:32:43 <lambdabot> Fractional a => a
08:32:46 <mniip> Fractional*
08:33:00 <asthasr> oops, good point.
08:33:03 <asthasr> D:
08:33:50 <mniip> SiIky, you can use fromRational (1 % power base (-exponent))
08:34:17 <asthasr> but, the way I'd do a recursive negative power is to match against a negative power and define it as n < 0 | 1 / power 2 (-n) 
08:35:34 <SiIky> thats what i thought, the problem is the function HAS to have that type. the output must be the same type as the base
08:35:37 <nshepperd> Gurkenglas: instance Bifunctor (Flip EitherT m)?
08:36:21 <asthasr> SiIky, there is no way to represent a decimal type in an integer type, by definition.
08:36:48 <asthasr> you could use a -> Int -> Maybe a, and limit it to positive exponents: n < 0 | Nothing
08:38:04 <SiIky> yeah, i guess ill have to leave it incomplete. My teacher told us to do it just to mess with us, probably. Thanks :)
08:38:27 <asthasr> probably not "just to mess with you," but to make you think about potential challenges :)
08:38:52 <asthasr> this is also actually a good way to learn about the potential uses of monads like Maybe
08:39:03 <asthasr> because it's a really good way to represent "this is a function that may or may not be able to be applied"
08:39:33 <asthasr> your problem here is, quite literally, a textbook application of the approach.
08:42:07 <Gurkenglas> nshepperd, why Flip?
08:42:16 <Gurkenglas> oh wait dangit
08:42:44 <Gurkenglas> inconvenient.
08:45:14 <lyxia> cjay: Are you using varargs because you plan to have arguments of different types?
08:45:38 <cjay> lyxia: nope. I know, I can just use a list argument :)
08:45:46 * cjay was just playing around
08:46:02 <lyxia> cjay: :)
08:51:57 <SiIky> A while (a few years) ago i read GHC and GHCi werent available for ARM devices. Is it possible now? (i want to use it on a RBPi specifically)
08:52:18 <ARM9> ghc is available for raspbian, no ghci unfortunately
08:53:45 <SiIky> ARM9 unfortunate :/ but thanks
08:55:55 <ARM9> I'm not sure if it's because debian repos are more outdated than windows 95 or because ghci doesn't build for arm linux for some reason
08:59:23 <roelof> as a new Haskeller is it wise to learn cabal or can I better learn the new kid on town stack ?? 
09:01:03 <sm> roelof: I would learn stack first
09:02:10 <roelof> sm:  oke, can I also do the exercises from craft then ? 
09:03:28 <adimit> roelof: there really isn't much to learn about cabal, so if the docs you're following are using cabal, you can use that for now.
09:03:42 <monochrom> when learning stack, you will learn the most important part of cabal: what goes in *.cabal files. so it is not like the two are mutually exclusive.
09:04:14 <roelof> adimit:  the docs are not talking about cabal or stack. 
09:05:26 <orion> Would it be accurate to say that "StateT Foo m" is a Monad, but ""StateT Foo m a" is not?
09:06:55 <mniip> orion, "StateT Foo m a" being a Monad would be a kind error
09:07:16 <monochrom> yes, accurate.
09:07:29 <orion> What would be the proper terminology for "StateT Foo m a"?
09:07:39 <mniip> "is of the wrong kind to be a monad"
09:08:00 <orion> I mean, in terms of what it is, not what it isn't.
09:08:02 <monochrom> I don't give a dedicated name to that
09:08:18 <mniip> well, there is a stronger relation than "is not"
09:08:35 <marchelzo> What is the point of let guards?
09:11:34 <lyxia> marchelzo: Clarity by moving a variable closer to its definition, and by restricting the scope of said variable.
09:11:38 <SiIky> marchelzo you mean this? http://learnyouahaskell.com/syntax-in-functions#guards-guards
09:12:20 <marchelzo> I mean like: f k | let a = k + 1 = a
09:12:36 <monochrom> is that legal?
09:12:41 <marchelzo> yes
09:13:02 <mniip> @let f k | let a = k + 1 = a
09:13:03 <lambdabot>  Defined.
09:13:13 <mniip> wat
09:13:20 <marchelzo> It always matches, too.
09:13:32 <marchelzo> So why not just write: f | otherwise = let a = k + 1 in a
09:13:48 <monochrom> interestng
09:13:49 <lyxia> marchelzo: The use case is is a is used in the guard.
09:14:23 <marchelzo> I was thinking it could be used like in Rust, e.g., f k | let Just a = k = a; | otherwise = 42.
09:14:44 <marchelzo> so f Nothing would be 42, but in fact it just fails.
09:15:02 <lyxia> that would be   f k | Just a <- k = a
09:15:10 <marchelzo> That's an extension, right?
09:15:18 <mniip> no
09:15:24 <mniip> actually it's in the 2010 report
09:15:28 <mniip> along with pattern guards
09:15:40 <marchelzo> Oh, neat.
09:16:10 <Hijiri> If I use let guards it's usually in do-block let
09:16:25 <monochrom> ok, how about this: g x | let s = sin x, s > 0.1, s < 0.9 = x+1
09:16:52 <Hijiri> actually nevermind I was thinking of something else
09:17:18 <marchelzo> monochrom: Yeah, I suppose that's useful.
09:18:33 <mniip> whoever came up with this guard syntax :v
09:18:41 <monochrom> and then they allow unaccompanied "let s = sin x" because it is more complicated, not simpler, to add a rule to say "let is allowed except it is disallowed when unaccompanied" 
09:18:44 <mniip> why can't we just use letrecs and case's
09:19:17 <monochrom> every time you have to say "except", it is more complicated, not simpler, even if you are just trying to disallow useless things.
09:20:34 <mniip> > let x | let x = x = x in x
09:20:38 <lambdabot>  mueval-core: Time limit exceeded
09:21:01 <roelof> sorry for my late response. The first chapters are on the basics of haskell and testing with quickcheck and Hunit 
09:21:32 <monochrom> mniip, if you ask that question, you're better off asking "why have guards, why not use if-then-else" straight up
09:21:59 <julianleviston> I don’t understand how join typechecks given the definition join x = x >>= id
09:22:05 <mniip> actually if-then-else is just as bad
09:22:11 <julianleviston> :t join
09:22:12 <lambdabot> Monad m => m (m a) -> m a
09:22:17 <mniip> julianleviston, why wouldn't it
09:22:19 <julianleviston> :t (>>=)
09:22:20 <lambdabot> Monad m => m a -> (a -> m b) -> m b
09:22:36 <julianleviston> mniip: because the second argument to >>= doen’t seem to typecheck with id
09:22:43 <Gurkenglas> You mean we shouldn't have Bool?
09:22:48 <mniip> :t [undefined :: a -> m b, id]
09:22:49 <lambdabot> forall (k :: BOX) (m :: k -> *) (b :: k). [m b -> m b]
09:23:30 <monochrom> julianleviston: have you tried to type-infer x >>= id ?
09:23:43 <julianleviston> mniip: oh is id somehow special? because it’s a -> a, it doesn’t have any typeclass retrictions, so it can fit anywhere?
09:23:48 <mniip> no
09:23:50 <julianleviston> monochrom: I don’t know what that means
09:24:01 <julianleviston> monochrom: oh ok now I do
09:24:02 <mniip> julianleviston, id is not special in any way
09:24:16 <monochrom> "a -> a" can become "m b -> m b", too
09:24:34 <julianleviston> monochrom: yeah, that’s pretty much what I just said.
09:25:05 <monochrom> btw, have you seen "id not False"?  that id becomes (Bool -> Bool) -> (Bool -> Bool)
09:25:07 <julianleviston> mniip: because it doens’t have any retrictions at all, it can fit anywhere
09:25:23 <julianleviston> mniip: oops sorry meant monochrom 
09:26:01 <julianleviston> :t id not False
09:26:02 <lambdabot> Bool
09:26:05 <mniip> suppose x :: x, (>>=) :: m a -> (a -> m b) -> m b, id :: c -> c
09:26:09 <monochrom> ok, (>>=) :: m a -> (a -> m b) -> m b. "x >>= id" forces x :: m a.
09:26:32 <mniip> when we apply (>>=) to x, we establish that x ~ m a
09:26:47 <sm> <adimit> "there really isn't much to learn about cabal" ? I think that's misleading
09:26:50 <julianleviston> monochrom: so id’s types can basically assume anything… forall a. a -> a means that right?
09:27:00 <mniip> (>>=) x :: (a -> m b) -> m b
09:27:11 <monochrom> yes. watch mniip, he/she is doing what I want to do
09:27:11 <julianleviston> monochrom: I didn’t realise that a could be “ a b c s d f wd w d f d w” if we wanted it to be.
09:27:15 <mniip> when we apply that to id, we establish that (a -> m b) ~ (c -> c)
09:27:27 <julianleviston> yeah, I get it.
09:27:32 <mniip> therefore, a ~ c, m b ~ c, therefore a ~ m b
09:27:33 <julianleviston> a -> a means ANYthing.
09:28:17 <mniip> (>>=) x id :: m b
09:28:23 <julianleviston> no wait I don’t get it at all
09:28:27 <mniip> whereas x :: x, x :: m a, x :: m (m a)
09:28:31 <mniip> er
09:28:33 <mniip> whereas x :: x, x :: m a, x :: m (m b)
09:28:46 <julianleviston> because one type has been assumed for id, how can it be different on the other side?
09:28:51 * hackagebot rest-core 0.37 - Rest API library.  https://hackage.haskell.org/package/rest-core-0.37 (ErikHesselink)
09:28:53 * hackagebot rest-happstack 0.3 - Rest driver for Happstack.  https://hackage.haskell.org/package/rest-happstack-0.3 (ErikHesselink)
09:28:55 * hackagebot rest-snap 0.2 - Rest driver for Snap.  https://hackage.haskell.org/package/rest-snap-0.2 (ErikHesselink)
09:28:57 * hackagebot rest-wai 0.2 - Rest driver for WAI applications.  https://hackage.haskell.org/package/rest-wai-0.2 (ErikHesselink)
09:28:59 * hackagebot rest-gen 0.19.0.0 - Documentation and client generation from rest definition.  https://hackage.haskell.org/package/rest-gen-0.19.0.0 (ErikHesselink)
09:29:02 <julianleviston> mniip: this makes no sense
09:29:20 <julianleviston> mniip: how can a -> a ever be fitted to mean (a -> m b) ?
09:29:29 <monochrom> consider a, b, c to be "to be determined"
09:29:40 <julianleviston> monochrom: I don’t know what that means
09:29:44 <mniip> julianleviston, you seem to have a classical case of a type variable scoping issue
09:29:51 <monochrom> it is also why mniip used "id :: c -> c" instead of "id :: a -> a"
09:29:51 <julianleviston> monochrom: to be <- future, or past?
09:30:06 <mniip> julianleviston, the a's in id are different from the a's in >>=
09:30:16 <julianleviston> mniip: yeah, I know.
09:30:17 <lyxia> julianleviston: join (x :: m (m a)) = ((>>=) :: m (m a) -> (m a -> m a) -> m a) x id
09:30:25 <Bruuuuuuno> Hi, since stack can manage the installation of GHC, does I need ghc and cabal in the first place or I can just install stack on a new computer and have a full environment?
09:30:37 <mniip> it could be id :: r -> r, or (>>=) :: Monad waffle :: waffle apple -> (apple -> waffle banana) -> waffle banana
09:30:49 <julianleviston> lyxia: that didn’t help, sorry… 
09:30:52 <julianleviston> lyxia: thanks tho!
09:31:00 <julianleviston> mniip: yeah, I know
09:31:12 <glguy_> julianleviston: you unify  (x -> x) and (a -> m b) by having a assigned as m b
09:31:12 <julianleviston> mniip: let’s say id is c -> c
09:31:19 <mniip> julianleviston, so you are asking how to fit 'c -> c' into 'a -> m b'
09:31:20 <julianleviston> glguy_: what does that mean?
09:31:28 <julianleviston> mniip: yes… it doesn’t work
09:31:30 <mniip> julianleviston, isn't it obvious
09:31:32 <mniip> a = c = m b
09:31:34 <julianleviston> mniip: not at all
09:31:39 <julianleviston> mniip: what the
09:32:04 <julianleviston> :t (>>=)
09:32:05 <lambdabot> Monad m => m a -> (a -> m b) -> m b
09:32:22 <julianleviston> :t x >>= id
09:32:24 <lambdabot>     Couldn't match expected type ‘m (m b)’ with actual type ‘Expr’
09:32:24 <lambdabot>     In the first argument of ‘(>>=)’, namely ‘x’
09:32:24 <lambdabot>     In the expression: x >>= id
09:32:26 <julianleviston> hm
09:32:32 <mniip> inference is bidirectional
09:32:38 <mniip> restrictions propagate both ways
09:32:38 <glguy_> julianleviston: imagine you were using a simpler case: id True. id :: x -> x, and True :: Bool
09:32:41 <monochrom> julianleviston: something more basic, does http://www.vex.net/~trebla/haskell/prerequisite.xhtml#unification make sense?
09:32:45 <julianleviston> argh overload
09:32:45 <lyxia> :t \x -> x >>= id
09:32:46 <lambdabot> Monad m => m (m b) -> m b
09:32:56 <julianleviston> 6 people explaining in different ways all at once lol
09:33:03 <glguy_> julianleviston: since we're applying id to True we know that that first 'x' is the same as 'Bool', so we assign x to be Bool
09:33:04 <julianleviston> ok that’s fine.
09:33:28 <julianleviston> lyxia: thanks for that
09:33:46 <julianleviston> :t (>>=)
09:33:47 <lambdabot> Monad m => m a -> (a -> m b) -> m b
09:34:59 <julianleviston> x >>= y is == y x  right?
09:35:07 <monochrom> no
09:35:10 <julianleviston> guh
09:35:17 <julianleviston> oh… inside the m
09:35:42 <julianleviston> m(v) >>= f == m(f v) ?
09:35:45 <monochrom> leave x >>= y as itself. what >>= does depends on the actual monad, but you're currently working generally
09:35:45 <the_2nd> how can I map to a function with multiple parameters? f :: a -> b -> c      map f [a] b
09:36:16 <mniip> the_2nd, what do you want to map the function over?
09:36:20 <mniip> two lists?
09:36:31 <osa1> it'd be so awesome if we chould define local type synonyms. like in `where` clauses etc.
09:36:48 <osa1> could*
09:36:55 <sm> m0rphism, ggole. srhb: getting some chinese "words" now with http://lpaste.net/142705
09:36:59 <mniip> osa1, but then that where-clause would be local to the type signature
09:37:13 <the_2nd> mniip, many "a"s and one b
09:37:30 <monochrom> m a -> (a -> m b) -> m b. but a has to become m b.  m (m b) -> (m b -> m b) -> m b.
09:37:31 <the_2nd> soo f a1 b ||| f a2 b etc.
09:37:43 <mniip> the_2nd, map (\x -> f x b) as
09:38:04 <mniip> or as pointfree enthusiasts would say, map (flip f b) as
09:38:22 <osa1> mniip: what's problem with that?
09:38:34 <mniip> osa1, it's barely useful
09:38:59 <julianleviston> monochrom: why does a have to become mb?
09:39:01 <mniip> just like where- and let-bound data, class, and instance declarations
09:39:02 <ggole> osa1: where clauses at the term level are recursive, might be a little strange to have that at the type level
09:39:05 <lyxia> applicative style: f <$> as <*> pure b
09:39:05 <julianleviston> monochrom: m b I mean
09:39:10 <monochrom> because id forces it
09:39:11 <mniip> julianleviston, because that's the restriction 'id' places on it
09:39:20 <julianleviston> I don’t see how
09:39:27 <lyxia> (pretty dangerous though)
09:39:39 <mniip> julianleviston, id :: c -> c
09:39:45 <monochrom> id says "source type and target type are the same"
09:39:46 <glguy_> julianleviston: The type   x -> x    says I know this is a function and it's argument and result have the same type, whatever they are
09:39:59 <julianleviston> I don’t get it
09:40:10 <mniip> which part exactly do you not get
09:40:11 <julianleviston> it’d be nice if we could step it through tiny step by step
09:40:16 <julianleviston> mniip: the whole thing
09:40:24 <julianleviston> mniip: maybe start from nothing
09:40:26 <mniip> you have a function of type a -> a
09:40:40 <julianleviston> mniip: hang on I just blanked my brain
09:40:47 <monochrom> ok, have you type-inferred "map id [(), ()]"?
09:40:53 <julianleviston> what hte
09:41:01 <julianleviston> monochrom: me?
09:41:04 <monochrom> yes
09:41:16 <julianleviston> monochrom: no
09:41:25 <mniip> julianleviston, you have a hole of type a -> m b, and a function of type c -> c
09:41:27 <julianleviston> :t map id [(), ()]
09:41:28 <lambdabot> [()]
09:41:30 <monochrom> do that one first. it is more concrete
09:41:37 <mniip> if you try to plug the function into the hole,
09:41:42 <monochrom> more concrete and yet has the same issue
09:41:45 <mniip> you place restrictions on what a, b, and c are
09:41:46 <julianleviston> mniip: wait 
09:41:51 <julianleviston> mniip: you’re going WAY too fast
09:42:04 <julianleviston> monochrom: do what?
09:42:05 <mniip> yyyyyyyyyyyoooooooooooouuuuuuuuuuu hhhhhhhhhaaaaaaaaaavvvvvvvvvvveeeeeeeee
09:42:18 <glguy_> Teaching Haskell from scratch might be better for -overflow
09:42:22 <monochrom> find out why "map id [(), ()]" has no type error
09:42:42 <julianleviston> monochrom: I *think* I know.
09:42:47 <Gurkenglas> :t \n xs -> map (take n) $ take (length xs) $ tails $ cycle xs -- Instead of cycle xs, you can also do "xs ++ xs". Note how the function neatly factorizes into parts using n and parts using xs - maybe the named function should only do the part using xs, and then you map (take n) across the result where you use sequences. ("cycles"?)
09:42:48 <lambdabot> Int -> [a] -> [[a]]
09:42:50 <julianleviston> monochrom: it’s because id returns its input.
09:42:53 <mniip> julianleviston, you might know it intuitively
09:42:53 <monochrom> it is the same reason why x>>=id has no type error
09:42:58 <mniip> but can you explain it formally
09:43:07 <monochrom> no, do not use what id does. use only types.
09:43:15 <mniip> thinking in terms of formal terms is what haskell is about
09:43:19 <julianleviston> mniip: what?
09:43:27 <Gurkenglas> (Only if n is doesn't exceed twice (length xs), of course.)
09:43:30 <julianleviston> mniip: ok give me a sec
09:43:32 <mniip> it's like proving that 2 + 2 = 4
09:43:38 <mniip> (which is a theorem indeed)
09:43:42 <Gurkenglas> *sm, see my last too lines
09:44:01 <julianleviston> mniip: I can’t prove 2 + 2 = 4
09:44:30 <julianleviston> mniip: so I’m not terribly sure what you’re asking me to do, sorry
09:44:43 <the_2nd> Is it possible to sort by not comparing to a with b
09:44:52 <mniip> julianleviston, I (and monochrom) are asking you to deduce something formally
09:45:00 <mniip> as opposed to intuitively
09:45:01 <the_2nd> but by supplying a sort function?
09:45:03 <julianleviston> mniip: I don’t know how to do that
09:45:10 <mniip> the_2nd, sortBy
09:45:20 <mniip> julianleviston, the page monochrom linked
09:45:24 <mniip> http://www.vex.net/~trebla/haskell/prerequisite.xhtml#unification
09:45:26 <julianleviston> which page?
09:45:27 <mniip> explains the process
09:45:40 <julianleviston> mniip: I didn’t see that link
09:45:50 <sm> Gurkenglas: thanks! I've burned quite some time already.. if you want to try it, I'd love to see
09:46:21 <ggole> julianleviston: how about you try it on a simpler example? Take test f x = f x, and try to understand why test id has the type it does.
09:46:36 <lyxia> julianleviston: Why does (x >>=) type-check and what type does it have? Then apply it to id?
09:47:03 <julianleviston> ggole: I don’t know what language to use to “prove something formally"
09:47:06 <Gurkenglas> sm, the chinese characters are "obviously" because that's the range that wideChars maps into.
09:47:17 <ggole> I'm not asking you to prove anything.
09:47:41 <julianleviston> ggole: mnip is
09:48:09 <mniip> julianleviston, have you read the page
09:48:15 <julianleviston> ggole: I know what id does.
09:49:05 <ggole> julianleviston: OK, but there seems to be some other problem
09:49:11 <julianleviston> ok… so “unification” is just substitution
09:49:18 <julianleviston> mniip: yeah, I read that
09:49:22 <julianleviston> ggole: really?
09:49:24 <mniip> no, it is much more
09:49:26 <mniip> than that
09:49:34 <mniip> read the thing again
09:49:37 <julianleviston> mniip: doesn’t seem to be
09:49:51 <mniip> how is (a, Char) ~ (Char, a) substitution?
09:50:26 <julianleviston> mniip: ok… equational reasoning then
09:50:39 <ggole> julianleviston: so, the type of test is (a -> b) -> a -> b, and you apply that to id
09:50:42 <julianleviston> mniip: and matching based on that to see that things are equal.
09:50:47 <mniip> no
09:51:01 <mniip> it's tearing the structure apart to find out how things are related
09:51:03 <ggole> Do you understand how to predict the resulting type?
09:51:13 <julianleviston> mniip: have YOU read that page?
09:51:15 <mniip> yes
09:51:27 <mniip> "The second step is plugging d^2 into x, and we have gone over that."
09:51:32 <mniip> /that/ is substitution
09:51:38 <mniip> unification is discussed further
09:52:25 <julianleviston> mniip: yeah, I’ve been doing this for years.
09:52:39 <julianleviston> mniip: but I’ve just never used the word “unification” for it.
09:52:47 <mniip> well then why can't you unify (c -> c) ~ (a -> m b)
09:52:55 <sm> what's a good way to interleave two lists ? Like zip, but generating a list instead of a list of tuples ?
09:53:18 <julianleviston> mniip: that’s not what I’m having trouble with.
09:53:19 <julianleviston> mniip actually that’s part of it
09:53:33 <julianleviston> mniip: ah I see why now
09:53:35 <mniip> sm, "by hand" is the only thing I can think of
09:53:53 <julianleviston> mniip: because my brain gets , c -> c and says both cs  have to be identical types.
09:53:53 <mniip> unless the lengths are equal
09:54:03 <mniip> julianleviston, and they do
09:54:16 <mniip> those two c's are the same type
09:54:25 <sm> concat . zipWith (\(a,b) -> [a,b]) I guess
09:54:27 <julianleviston> mniip: but if that’s the case, then how can you possibly match one c to a, and then the other c to m b ?
09:54:35 <julianleviston> mniip: I’m obviously missing something.
09:55:03 <julianleviston> mniip: maybe I don’t understand what ~ means
09:55:10 <mniip> "is the same type as"
09:55:12 <julianleviston> mniip: I thought it meant “has equivalency of"
09:55:16 <julianleviston> ah ok
09:55:44 <mniip> julianleviston, uh, it's the same c
09:55:47 <mniip> c ~ a ~ m b
09:55:51 <mniip> it's like a system of equations
09:55:58 <julianleviston> mniip: that makes no sense to me
09:56:07 <julianleviston> mniip: unless a ~ mb 
09:56:12 <julianleviston> mniip: but how can they be?
09:56:14 <mniip> a ~ m b
09:56:17 <julianleviston> how?
09:56:42 <julianleviston> oh coz a can be anything it likes
09:56:43 <julianleviston> ok
09:56:43 <ggole> julianleviston: a is a variable. It can be anything it needs to be.
09:56:44 <julianleviston> god
09:57:03 <julianleviston> ok let me have another look
09:57:13 <mniip> julianleviston, we have a system of equations (relations) describing what can >>= be applied to
09:57:25 <julianleviston> mniip: giimme a sec plz
09:57:36 <mniip> then we append the id's equation to that system, and get a more constrainted system of equations
09:57:42 <ggole> (Obviously, if you have a in more than one place, they all have to be the same thing.)
09:59:11 * hackagebot ghc-pkg-lib 0.3.1 - Provide library support for ghc-pkg information  https://hackage.haskell.org/package/ghc-pkg-lib-0.3.1 (JeanPhilippeMoresmau)
09:59:57 <julianleviston> ok I’m back
10:01:38 <julianleviston> still don’t really get it
10:02:12 <^elyse^> Is it possible to have haskell-mode just indent/dedent 4 spaces always? So that tab will insert 4 spaces, and backspace will remove 4 spaces?
10:02:14 <julianleviston> In this type signature, it says join takes a monadic monadic a and returns a monadic a
10:02:16 <julianleviston> right?
10:02:22 <julianleviston> join :: Monad m => m (m a) -> m a
10:02:46 <mniip> that is correct
10:02:56 <mniip> but it's irrelevant to our discussion
10:03:01 <julianleviston> the thing I don’t get is which bits connect up to which bits in the definition… of x >>= id
10:03:32 <mniip> julianleviston, can you try to calculate what is the type of 'map id'
10:03:36 <ggole> How is this related to join, exactly?
10:03:37 <julianleviston> oh I know why I’m not getting it now
10:03:38 <mniip> as a simpler excercise
10:03:46 <julianleviston> mniip: the type of map id ?
10:03:51 <mniip> yes
10:03:52 <julianleviston> mniip: ok
10:04:02 <julianleviston> mniip: map is (a -> b) -> [a] -> [b]
10:04:13 <julianleviston> mniip: so map id is [a] -> [a]
10:04:22 <mniip> but, paraphrasing you, how can 'a' and 'b' be the same thing?
10:04:25 <julianleviston> mniip: good?
10:04:35 <julianleviston> mniip: huh?
10:05:01 <mniip> that is indeed the correct signature, I'm just providing thought food
10:05:11 <julianleviston> mniip: because “the same thing” is contained within “from one thing of any type to another thing of any type”
10:05:16 <julianleviston> mniip: ah ok.
10:05:19 <mniip> you seem to have no problems unifying (a -> b) with (c -> c)
10:05:28 <julianleviston> mniip: I don’t think the thing I’m confused about is what you’re thinking I am confused about.
10:05:33 <mniip> what's the issue with (a -> m b)
10:05:37 <julianleviston> mniip: no, I’m good with that.
10:05:51 <julianleviston> mniip: that’s fine.
10:05:56 <hackrilege> why does dot not work if the last function composed takes more than one vatiable?
10:06:00 <julianleviston> mniip: it wasn’t, but it is now, thanks to you.
10:06:10 <julianleviston> hackagebot: huh?
10:06:12 <hackrilege> variable*
10:06:17 <julianleviston> hackagebot: bit more context?
10:06:22 <julianleviston> hackrilege:  bit more context?
10:06:34 <hackrilege> map id . replicate
10:07:00 <julianleviston> :t (map id) . replicate
10:07:01 <lambdabot>     Couldn't match type ‘a0 -> [a0]’ with ‘[b]’
10:07:01 <lambdabot>     Expected type: Int -> [b]
10:07:01 <lambdabot>       Actual type: Int -> a0 -> [a0]
10:07:10 <julianleviston> :t replicate
10:07:11 <lambdabot> Int -> a -> [a]
10:07:28 <deech> Anyone know if you have lots of instances of a typeclass (100's) whether splitting it out among multiple modules degrades typechecker performance?
10:07:55 <julianleviston> mniip: the thing I was getting confused about is that I was subbing typeclasses into function definitions. Broken.
10:08:07 <hackrilege> it does not deech im fairly sure
10:08:12 <julianleviston> hackrilege:  what were you trying to do?
10:08:46 <hackrilege> understand that error
10:08:49 <julianleviston> hackrilege: oh… because of currying.
10:08:55 <julianleviston> :t (.)
10:08:56 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:09:11 <julianleviston> hackrilege: see it takes two functions from a to b, and joins them?
10:09:22 <hackrilege> yeh
10:09:25 <julianleviston> hackrilege: sorry, a to b and b to c and joins them
10:09:32 <hackrilege> yeh
10:09:41 <julianleviston> hackrilege: so if you pass it a partial function, it has to be the b -> c one.
10:10:01 <julianleviston> hackrilege: oops.
10:10:04 <hackrilege> oh
10:10:09 <julianleviston> hackrilege: not that.
10:10:16 <julianleviston> hack you have to provide the variables.
10:10:46 <hackrilege> i see
10:11:03 <ggole> hackrilege: at a higher level, you're just missing the int argument to replicate
10:11:11 <ggole> :t map id . replicate 10
10:11:12 <lambdabot> b -> [b]
10:11:18 <julianleviston> ggole: he wants to miss it.
10:11:23 <hackrilege> can i define a new . which works?
10:11:26 <julianleviston> ggole: he wants a partial function.
10:11:34 <julianleviston> hackrilege: hehe I dunno… try! :)
10:11:35 <ggole> Then the argument needs to come from somewhere
10:11:43 <julianleviston> ggole: yes… hence my suggestion :)
10:12:02 <hackrilege> i know its pointless
10:12:07 <exio4> a partial function? 
10:12:33 <ggole> Pretty sure the intention is "partially applied".
10:12:35 <julianleviston> exio4: unapplied function.
10:12:45 <julianleviston> exio4: sorry, yeah not “non-total"
10:12:52 <julianleviston> exio4: gotta watch that language use :)
10:13:47 <julianleviston> mniip: damn why is this so hard for me? ;-) lol
10:13:58 <julianleviston> mniip: I can see exactly where I went wrong now.
10:14:18 <exio4> `unapplied function` sounds like a weird way to say `function` too! :P 
10:14:18 <hackrilege> is there already defined an alternative to . for multivariate function composition?
10:14:29 <exio4> ggole: I know
10:14:41 <julianleviston> exio4:  well what’s pure versus pure x ?
10:14:50 <julianleviston> exio4: what do you call the one without a variable?
10:14:51 <hackrilege> or is such a construction ill posed?
10:15:14 <julianleviston> hackrilege: do you want to write it point free?
10:15:23 <julianleviston> hackrilege: what’s your aim here? :)
10:16:13 <exio4> julianleviston: `pure` is a function, `pure x` is well, a polymorphic value that may be a function or not
10:16:15 <hackrilege> a cryptic but sensible syntax rationalisation
10:16:17 <exio4> > pure 2 3 
10:16:19 <lambdabot>  2
10:16:30 <julianleviston> mniip: ggole:  thanks for your help.
10:16:43 <julianleviston> hackrilege: lol what does *that* mean? :)
10:16:52 <hackrilege> > pure 1 2 3
10:16:54 <lambdabot>      Could not deduce (Num a0)
10:16:54 <lambdabot>      from the context (Num a, Num (a -> t))
10:16:54 <lambdabot>        bound by the inferred type for ‘e_1123’: (Num a, Num (a -> t)) => t
10:16:55 <julianleviston> exio4: I wasn’t talking about pure.
10:17:21 <julianleviston> exio4: I was just meaning some function with un-specified arguments in the definition… 
10:17:49 <hackrilege> like dots help my sugar. as would multivariate . but only in a wierd way
10:18:42 <mniip> julianleviston, wrt typeclasses,
10:18:50 <mniip> typeclass constraints are equations too
10:18:57 <mniip> they're not special in any way
10:18:59 <hackrilege> im just wondering if it seems sane. i have trouble defining such a function
10:19:00 <julianleviston> exio4: such as when you might write, say, divBy3 = div 3
10:19:27 <exio4> that's just a function, too
10:19:30 <exio4> @type div
10:19:31 <lambdabot> Integral a => a -> a -> a
10:19:31 <julianleviston> mniip: sorry, but that doesn’t mean much to me.
10:19:46 <julianleviston> exio4: ah ok so you have no way to talk about them as distinct then?
10:20:08 <julianleviston> exio4: that’s unhelpful… because that’s what hackrilege is trying to get on of :) 
10:20:18 <exio4> julianleviston: partially applied function sounds the term you want, but terminology is a bit weird and nobody can agree on it
10:20:26 <mniip> hackrilege, are you looking for something of the type (c -> d) -> (a -> b -> c) - > a -> b -> d
10:20:38 <ggole> hackrilege: let's see, you want a test such that :t map id `test` replicate has the type Int -> b -> [b]?
10:20:49 <ggole> let test f g x y = (f . g x) y
10:20:51 <ggole> I think
10:21:10 <julianleviston> mniip: I’m not sure what concrete ramifications typeclass constraints being equational has...
10:21:37 <ggole> Rather, let test f g x = f . g x
10:21:54 <mniip> ggole, same thing
10:21:54 <julianleviston> mniip: my biggest stumbling block in Haskell is type signatures. It’s not understanding, it’s interpreting.
10:22:03 <ggole> mniip: right, but less ugly
10:23:17 <hackrilege> > let (.$) fb fa a b = fb $ fa a b in (map id .$ replicate) 2 3
10:23:18 <lambdabot>  [3,3]
10:23:32 <julianleviston> omg
10:23:33 <mniip> :t (.) . (.)
10:23:33 <julianleviston> lol
10:23:34 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:23:48 <julianleviston> mniip: my brain is like “lenses!” :)
10:24:09 <ggole> @pl \f g x -> f . g x
10:24:09 <lambdabot> (.) . (.)
10:24:13 * ggole nods
10:24:26 <ggole> ...it's looking at me
10:24:44 <julianleviston> ggole: I think hackrilege needs to know about @pl. He would love it… :)
10:24:50 <julianleviston> hackrilege: s/he.
10:24:51 <mniip> ggole, and you're looking at them
10:25:16 <hackrilege> ggole thanks that explanation was great
10:26:25 <hackrilege> is that an owl?
10:27:00 <mniip> julianleviston, if you apply a function of type S->T to a value of type P, you get an equation: S=P
10:27:22 <hackrilege> yes i will use @pl thank you i should have had it years ago
10:27:36 <mniip> if you have an equation A -> B = C -> D, you can simplify it to two equations: A = C, B = D
10:27:53 <julianleviston> mniip: oh ok.
10:28:07 <julianleviston> mniip: what is the point of doing that, though?
10:28:19 <mniip> ._.
10:28:27 <mniip> figuring out the type of something?
10:29:15 <julianleviston> mniip: ok.
10:29:16 <hackrilege> can i get some commentary on whats going on with this crazy owl thing?
10:29:33 <mniip> hackrilege, \f g x y -> f (g x y)
10:29:44 <hackrilege> i saw that
10:29:44 <mniip> \f g x y -> (f . g x) y
10:29:48 <mniip> \f g x -> f . g x
10:29:55 <julianleviston> hackrilege: @pl rearranges an equation into point-free.
10:29:55 <hackrilege> and that
10:30:00 <mniip> \f g x -> ((f .) . g) x
10:30:02 <hackrilege> oh! coo
10:30:08 <mniip> \f g -> (f .) . g
10:30:16 <julianleviston> hackrilege: sorry, a function*
10:30:18 <hackrilege> those steps are new
10:30:19 <mniip> \f -> ((f .) .)
10:30:43 <mniip> \f -> ((.) . (.)) f
10:30:46 <mniip> (.) . (.)
10:30:54 <hackrilege> yes!!!
10:31:01 <hackrilege> awesome
10:31:59 <hackrilege> i knew there was magic in it
10:33:08 <mniip> alternatively,
10:33:33 <julianleviston> mniip: lol… ok so you were totally right, I was going a -> b means a /= b.
10:33:40 <mniip> \f g x -> S (K f) (S (K g x) I)
10:33:59 <hackrilege> :t S
10:34:00 <lambdabot> Not in scope: data constructor ‘S’
10:34:20 <mniip> \f g x -> S (K S (K f)) (S (S (K S) (K g)) (K I))
10:34:22 <mniip> errrr
10:34:24 <mniip> \f g -> S (K S (K f)) (S (S (K S) (K g)) (K I))
10:34:28 <julianleviston> mniip: now I’ve reminded myself (which I knew in other contexts) that a -> a fits fine with a -> b, all is a bit easier :)
10:34:45 <monochrom> julianleviston: http://lpaste.net/99842 :)
10:34:58 <mniip> hackrilege, S = ap, K = const, I = id
10:35:22 <julianleviston> monochrom: why?
10:35:34 <monochrom> moar type inference by hand
10:35:43 <julianleviston> monochrom: I wasn’t having trouble with (.) . (.) :)
10:35:57 <julianleviston> monochrom: haha I’m afraid I’ve made everyone think I’m a complete noob :)
10:36:01 <julianleviston> monochrom: which is fine :)
10:36:13 <monochrom> no, I think (.) . (.) is pretty advanced
10:36:28 <monochrom> or at least pretty involved
10:36:55 <julianleviston> monochrom: yeah.
10:36:55 <monochrom> took me a while to do it, too
10:37:10 <julianleviston> monochrom: I think you should show hackrilege … 
10:37:12 <monochrom> if you can ace this one, nothing will stop you :)
10:37:15 <julianleviston> hackrilege: ^
10:37:29 <hackrilege> your S K l thing makes no sense to me
10:37:29 <julianleviston> monochrom: the trouble is only in the number of things named the same thing… :)
10:38:03 <hackrilege> yeh im reading the paste
10:38:04 <geekosaur> hackrilege, look up SKI calculus
10:38:09 <hackrilege> kk
10:38:15 <julianleviston> monochrom: so, ironically, if I was following your explanation of (.) . (.), I’d find your explanation less helpful.
10:38:15 <hackrilege> thanks
10:38:20 <julianleviston> monochrom: bit odd, huh! :)
10:38:40 <hackrilege> it looks hellish
10:39:04 <julianleviston> monochrom: I think more geometrically and less algebraically.
10:39:08 <ggole> You could just stop at the pointful version
10:39:40 <julianleviston> ggole: yeah, pointfree is a silly thing to do as a beginner, I think.
10:40:35 <monochrom> ah, geometrically. yeah, I don't know how to present it geometrically. I only know the algebraic story.
10:40:49 <julianleviston> monochrom: yeah… it’s cool. I don’t need you to.
10:42:17 <julianleviston> monochrom: even just looking at this type-signature boggles my brain… (>>=) :: Monad m => m a -> (a -> m b) -> m b
10:42:49 <julianleviston> monochrom: and it’s not like I just found it yesterday. I’ve been studing Monads on and off for about 6 months.
10:42:51 <mniip> :t undefined :: Lens s t a b
10:42:52 <lambdabot> Functor f => (a -> f b) -> s -> f t
10:42:54 <mniip> :)
10:43:08 <MarcelineVQ> julianleviston: Have you done the monad parts of nicta?
10:43:17 <julianleviston> MarcelineVQ: I haven’t done any of Nicta.
10:44:16 <Copperis> Hi, can anyone tell me why this code http://lpaste.net/142710 doesn't compile? It throws "parse error on input ‘where’"
10:44:20 <MarcelineVQ> It's amazing, but specifically it has you implement a flipped >>= and you learn how it works in the process
10:44:41 <julianleviston> MarcelineVQ: I’ve read RWH’s Monad section, LYAH’s, Richard Bird’s Thinking Functionally with Haskell, Hutton’s Programming in Haskell, and about 10 different Monad tutes on the net (including the gentle introduction and the wikibooks one)
10:44:48 <mniip> julianleviston, there are things much more complex/complicated than >>= :P
10:44:48 <Welkin> Copperis: indentation error
10:45:02 <MarcelineVQ> julianleviston: but this one makes you do it all yourself :>
10:45:06 <julianleviston> mniip: lol yeah I know. I don’t find it hard at all
10:45:19 <monochrom> Copperis: where is your "=" sign?
10:45:24 <mniip> :t undefined :: Prism s t a b
10:45:25 <Welkin> Copperis: oh, after looking at it, you wrote it wrong
10:45:26 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p s (f t)
10:45:27 <julianleviston> MarcelineVQ: it’s just a flipped version of a pumped up fmap/applicative, really.
10:45:35 <mniip> :t undefined :: Iso s t a b
10:45:36 <lambdabot> (Functor f, Profunctor p) => p a (f b) -> p s (f t)
10:45:38 <Welkin> if you are defining a function, you forgot the "="
10:45:50 <julianleviston> mniip: yeah, I’ve seen lens :P :)
10:46:06 <Copperis> oh yeah, it needed an = sign
10:46:26 <Copperis> thanks monochrom 
10:46:31 <monochrom> :)
10:46:59 <julianleviston> mniip: lens and ST Monad used to freak me out.
10:47:07 <julianleviston> mniip: not so much any more.
10:47:19 <julianleviston> mniip: mostly because I just had no clue what any of it meant.
10:48:45 <julianleviston> mniip: watching a couple Edwardk videos made me less scared of Lens
10:49:41 <suppi> julianleviston, really? because it made me more scared of Lens
10:49:44 <julianleviston> mniip: tho the sheer number of operators is a bit daunting. I’m going to have to tackle it sometime soon because I want to build a thing on Snap.
10:49:56 <julianleviston> suppi: oh he just moves quickly… 
10:51:00 <hackrilege> He only have 3... I'd love to know what I so prism and lens were
10:51:06 <hackrilege> Iso
10:51:26 <julianleviston> hackrilege: lens is a way to get and change data in a bigger structure.
10:51:37 <hackrilege> Prism?
10:51:59 <hackrilege> Splits colours?
10:52:31 <johnw> prism is able to reveal colours
10:52:33 <julianleviston> hackrilege: here you are : https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
10:52:34 <mniip> more or less
10:52:38 <johnw> i.e., it can distinguish constructors within a sum type
10:52:50 <hackrilege> !?!?
10:53:11 <julianleviston> hackrilege: read that link… it gives you an overview
10:53:21 <hackrilege> Ok, so lens I'd like fmap fmap fmap and prism... Ok I'll read the link
10:53:22 <johnw> and see http://ftp.newartisans.com/pub/Lenses.mp4 at some point
10:53:35 <johnw> that's SPJ's presentation, very clear
10:54:01 <julianleviston> johnw:  SPJ is so bossmode. :)
10:54:08 <mniip> hackrilege, the fmapfmapfmap dotdotdot traversetraversetraverse analogy is barely useful
10:54:47 <hackrilege> If seen the little lens starter tutorial. It is in an annoying verbose style which I find illegible
10:55:05 <julianleviston> johnw: thanks! I’m going to watch that :)
10:56:12 <hackrilege> I can't view the mp4...
10:56:21 <johnw> can you download it and play it with VLC?
10:56:31 <hackrilege> Good old chrome on android
10:56:53 <mniip> hackrilege, quick intro: "Lens' s a" is a "reference" to something of type a, in something of type s
10:57:13 <mniip> Lens' s a ~ { get :: s -> a, set :: a -> s -> a }
10:57:24 <hackrilege> I know
10:57:30 <hackrilege> What's a prism?
10:57:40 <dibblego> @type prism
10:57:42 <lambdabot> (Applicative f, Choice p) => (b -> t) -> (s -> Either t a) -> p a (f b) -> p s (f t)
10:58:41 <mniip> Prism s t a b ~ {preview :: s -> Maybe a, review :: a -> s}
10:58:51 <mniip> er, that's a Prism'
10:58:57 <mniip> Prism s t a b ~ {preview :: s -> Maybe a, review :: b -> t}
10:59:11 <johnw> a Prisms can select an 'a' from an 's', where 'a' exists within _some_ of the possible values of s
10:59:11 <hackrilege> That's another problem with tutorials like the little lens starter, its spending its introduction and first half telling you things which exhaust you without allowing informative navigation
10:59:34 <johnw> there is a possible Int in Maybe Int
10:59:39 <johnw> there is always an Int in (Int, Float)
10:59:43 <mniip> hackrilege, totally agree with you at that point
10:59:56 <the_2nd> I sort a list with SortBy f list
11:00:08 <the_2nd> how can I get a list of sorted ids aswell?
11:00:18 <the_2nd> so if item 3 becomes item 0
11:00:19 <mniip> johnw, http://i.imgur.com/92OWC66.png
11:00:24 <the_2nd> I want [3, ...]
11:00:26 <mniip> how I internally imagine the structure
11:00:38 <hackrilege> I'm confused by your tilde
11:01:12 <mniip> hackrilege, "isomorphic to" in this context
11:01:12 <johnw> mniip: nice
11:01:29 <hackrilege> Oh it's a datatype definition basically
11:02:04 <CindyLinz> the_2nd: map fst $ sortBy (cmp . snd) (zip [1..] list)
11:02:47 <johnw> CindyLinz: faster in this case is "sortOn snd"
11:02:55 <hackrilege> Why have you written lens with only two type parameters and not 4?
11:03:09 <johnw> unless cmp is doing something I don't expect, that is
11:03:26 <mniip> hackrilege, Lens' is a non-typechanging Lens
11:03:37 <mniip> Lens' s a = Lens s s a a
11:03:46 <mniip> same thing with other optics
11:03:59 <hackrilege> Ok
11:04:04 <^elyse^> Nevermind, defined my own haskell-mode after going crazy for about 15 minutes.
11:04:15 * hackagebot aws 0.9.5 - Amazon Web Services (AWS) for Haskell  https://hackage.haskell.org/package/aws-0.9.5 (AristidBreitkreuz)
11:04:53 <CindyLinz> johnw: I don't know what 'cmp' the_2nd want... ^^|
11:05:11 <CindyLinz> oh f.. XD
11:05:17 <CindyLinz> the_2nd: map fst $ sortBy (f . snd) (zip [1..] list)
11:05:27 <johnw> ah, in that case sortOn is the wrong type
11:05:41 <johnw> unless all that f does is to pick elements of its arguments uniformly
11:05:47 <CindyLinz> mmmm
11:05:55 <johnw> sortOn f == sortBy (comparing f)
11:06:05 <johnw> it results in fewer calls to f
11:06:21 <hackrilege> So Prism' s a ~ {preview :: s -> Maybe a, review :: a -> s}  ??
11:06:26 <^elyse^> really wish Haskell allow an optional "|" before the first variant in an ADT definition
11:06:29 <^elyse^> like OCaml
11:06:57 <johnw> ^elyse^: I read the '=' as being that |
11:07:23 <^elyse^> yeah, but difficult to deal with when editing code, because you can't easily reorder variants, and breaks merge tools
11:07:44 <shachaf> Prism s t a b is certainly not made up of preview
11:07:50 <shachaf> Prism s t a b = (s -> Either t a, b -> t)
11:07:58 <hackrilege> !?
11:08:16 <hackrilege> direct contradiction?
11:09:25 <hackrilege> mniip^
11:10:26 <hackrilege> is your definition consistent with what schachaf is saying?
11:10:40 <dibblego> hackrilege: Prism s t a b is made of a pair of functions (s -> Either t a) and (b -> t) as can be seen in the type of prism above. The preview function, involving Maybe, can be derived from that (but not the other way around).
11:11:03 <hackrilege> aha
11:11:09 <the_2nd> CindyLinz, http://pastebin.com/mc4tGeuR
11:11:14 <hackrilege> thanks
11:11:33 <shachaf> Prism' s a = (s -> Maybe a, a -> s) works, because if the (s -> Either s a) function gives you Left, it'll always give you the value you gave it.
11:11:38 <RedNifre> can I save my ghci command history of the current session?
11:11:41 <shachaf> So you can just represent that as a Maybe.
11:11:57 <shachaf> But it kind of loses part of the point a prism to think only of Prism's.
11:12:17 <hackrilege> ?
11:12:46 <the_2nd> wont work for me
11:12:48 <CindyLinz> the_2nd: You missed a dot (.)
11:12:58 <hackrilege> you mean the preview interpretation is incomplete?
11:13:49 <hackrilege> "to think only of prisms"  I don't understand this
11:14:16 * hackagebot observable-sharing 0.2.3 - Simple observable sharing  https://hackage.haskell.org/package/observable-sharing-0.2.3 (mararon)
11:14:26 <the_2nd> CindyLinz, couldnt match type Double with a -> Double
11:14:40 <the_2nd> with (a, Double) -> a0 
11:15:22 <the_2nd> how can I map the !! operator?
11:15:46 <mniip> shachaf, oh yes
11:15:57 <the_2nd> [Int] -> [a] -> [a]   /// where the output a is sorted by the ids in [Int]
11:16:02 <mniip> the "Left t" is a proof of no "a" being in "s"
11:16:18 <CindyLinz> the_2nd: 'comparing . snd' is not 'comparing  snd'.. @@"
11:16:53 <^elyse^> guess I'll write a preprocessor for this kind of stuff
11:17:03 <the_2nd> CindyLinz, the error is for comparing . snd
11:17:05 <nitrix> the_2nd: Does that code compile? It seems to me it should be (comparing . snd)
11:17:26 <the_2nd> nitrix, CindyLinz I changed it to comparing . snd
11:17:28 <the_2nd> and got
11:17:55 <the_2nd> couldnt match type Double with (a, Double) -> a0
11:18:03 <CindyLinz> oh
11:19:03 <CindyLinz> should be 'comparing snd'
11:19:04 <RedNifre> the_2nd you can map !! by using more brackets, e.g. (!!) <$> listOfLists
11:21:46 <the_2nd> RedNifre, where would I put the id list there?
11:23:50 <^elyse^> johnw: https://gist.github.com/rightfold/ab3e534287ed33fcd9ca :D
11:24:40 <MarcelineVQ> the_2nd: what's your input and what it your expected output?
11:24:55 <the_2nd> MarcelineVQ, two problems
11:25:13 <julianleviston> mniip: so… with this: (>>=) :: Monad m => m a -> (a -> m b) -> m b if we supply a m (m a) as our m a value, and id is the function (being m(m a) -> m(m a), because it’s id), then it will return an m a… so join’s type therefore becomes m (m a) -> m a
11:25:41 <lyxia> the_2nd: \is as -> map (as !!) is
11:25:46 <the_2nd> #A f :: [Int] -> [a] -> [a]    where [Int] contains indices and the result is a subset of the input of these ids
11:26:33 <julianleviston> mniip: thanks again for your help before.
11:30:00 <statusfailed> Anybody running ghc on ARM on Scaleway?
11:30:09 <RedNifre> f ids list = (list !!) <$> ids
11:30:13 <RedNifre> the_2nd
11:30:17 <MarcelineVQ> That's didn't quite clear it up for me, are you trying to sort a list by a supplied index list?
11:31:18 <MarcelineVQ> I think the use of the word id is throwing me off, in haskell that's a specific thing :> Let me know if I'm misunderstanding your entirely
11:31:34 <RedNifre> the_2nd is my solution what you were asking?
11:32:23 <the_2nd> RedNifre, think so, but I went with lyxias solution: pCandidates = map (points !!) candidates
11:33:08 <RedNifre> ah, same thing. didn't notice that one in the chat.
11:33:57 <RedNifre> can I save my ghci session?
11:34:39 <hackrilege> It would be great if there was a good non bare metal arm vm for Haskell. GnurootDebien is down
11:35:50 <johnw> ^elyse^: yeah, I hear you
11:46:12 <EvanR> hackrilege: theres a bare metal arm vm for haskell?
11:46:47 <hackrilege> Well halvm
11:46:56 <hackrilege> Havlm
11:47:22 <EvanR> which one
11:47:42 <EvanR> halvm exists, looks like for cloud servers
11:47:59 <hackrilege> The halvm sorry
11:48:12 <EvanR> is there such a thing as haskell for embedded devices?
11:48:43 <hackrilege> It's built on xen which is Bare metal
11:49:19 <hackrilege> Evanr I have run Haskell on non rooted android but the tool I used is depreciated
11:49:28 <hackrilege> It wad gnuroot wheezy
11:50:12 <hackrilege> It seems the Linux kernel eliminated the fact out being in arm was an issue
11:50:19 <hackrilege> Of
11:50:49 <hackrilege> Cutting edge stuff I gather
11:51:14 <hackrilege> I think hugs is on android
11:51:42 <Copperis> I made a prime number test algorithm http://lpaste.net/142714 using code from https://goo.gl/1JCPQP . I'm learning haskell and FP atm. Are there any obvious places which could have been done more idiomatically or otherwise better?
11:51:43 <EvanR> meh android as "embedded"
11:52:04 <hackrilege> The adk is the only way to produce a functioning program that ribs outside an os emulator
11:52:12 <hackrilege> Runs
11:52:44 <EvanR> is Xen supported by embedded system chips?
11:52:46 <Copperis> is there a way to generate a list of numbers from 5 to n with increments of 6 without using recursion?
11:52:47 <hackrilege> I'll try writing a c shared library and imprinting it to the adk soon
11:53:02 <hackrilege> Yes xen works on arm
11:53:06 <the_2nd> sortBy (comparing snd) how can I invert this?
11:53:08 <EvanR> cool
11:53:52 <hackrilege> But I don't know how to put xen on my phone, anyway it's not a delivery adequate solution, must use aide
11:54:07 <mniip> the_2nd, sort backwards you mean?
11:54:26 <Gurkenglas> > [5,11..100] --Copperis
11:54:28 <lambdabot>  [5,11,17,23,29,35,41,47,53,59,65,71,77,83,89,95]
11:54:51 <hackrilege> You can't ask the users of your app to root their phone and install halvm as their os!
11:55:09 <EvanR> im less interested in phones as custom devices
11:55:18 <EvanR> than *
11:55:24 <Copperis> yup, thanks Gurkenglas 
11:55:34 <hackrilege> The neurocyte project is abandoned I would like to review it but lack the skill
11:55:37 <the_2nd> mniip, yep
11:55:54 <mniip> the_2nd, flip (comparing snd)
11:56:07 <hackrilege> Custom embedded arm devices can use xen and halvm
11:56:39 <hackrilege> As can your phone if you know how to get at the chips safely, which I don't
11:56:54 <hackrilege> Rooting, installing xen
11:57:30 <mniip> the android OS and its runtime are pretty scary
11:57:37 <mniip> because of being so monolithic
11:57:45 <hackrilege> I think xen installation requires minimal Linux exists, so the first part is installing Linux with bootable media storage device lie usb
11:58:44 <hackrilege> Mniip. Once the hurdle is overcome to getting hello world through the ffi and into a java project with all the reagent xml, then all the hard work would be done
11:58:54 <johnw> this is getting somewhat off-topic
11:59:10 <mniip> hackrilege, that's unrelated
11:59:17 <hackrilege> It could be easy intact to wrap a Haskell shared c library into a generic main app
11:59:27 <johnw> yay, on-topic!
11:59:37 <hackrilege> !?
11:59:51 <mniip> it would be hard to wrap haskell into a single program
12:00:02 <hackrilege> Sorry for all those typos
12:00:05 <EvanR> hackrilege: im sort of confused at the simultaneous assertions "xen is bare metal" and "xen must be installed"
12:00:11 <mniip> oh well, maybe not
12:00:29 <mniip> I think they mean xen is ring 0
12:00:40 <EvanR> so its an OS
12:00:58 <mniip> sort of
12:01:02 <mniip> it's a virtualizer
12:02:02 <mniip> EvanR, it's not an OS because it doesn't do anything other than virtualize other OSes
12:02:39 <EvanR> what service does it offer, just multitasking of OSes?
12:02:43 <johnw> this isn't the place to discuss OS virtualization, unless you're talking about Haskell specifically
12:03:27 <hackrilege> Evanr http://www.webhostingtalk.com/showthread.php?t=1198407
12:04:05 <hackrilege> I think it use Linux but eventually ends up underneath it and takes control of grub
12:04:17 <johnw> hackrilege: please take this elsewhere
12:04:59 <hackrilege> Event can you sick up for me here I was responding to your question
12:05:19 <hackrilege> Regarding the installation of halvm
12:05:34 <hackrilege> Evanr^
12:05:42 <johnw> entering into a discussion (now 20+ messages) on a topic not related to Haskell, is not on-topic for this channel
12:05:44 <the_2nd> is sortBy raising or falling?
12:05:55 <johnw> you can move to another channel if you want to hash this out
12:06:01 <mniip> the_2nd, same as 'sort'
12:06:13 <hackrilege> It's directly about running Haskell on embedded devices
12:06:25 <johnw> it sounds like it's about Xen and Android and Linux and GRUB
12:06:46 <johnw> anyway, please take it elsewhere
12:06:58 <hackrilege> The question was is xen bare metal
12:07:08 <the_2nd> mniip, which is?
12:07:19 <hackrilege> I.a. Is the Haskell vm bare metal also
12:07:37 <johnw> then please keep it about HalVM
12:07:42 <mniip> interesting
12:07:45 <mniip> the docs don't mention
12:08:29 <mniip> the_2nd, judging by 'insert', it is ascending
12:09:35 <hackrilege> In future I will respond to inform the questioner that os specific Haskell considerations are of topic, and that no forum exists where discussion with the reagent persons exists
12:09:50 <hackrilege> Relevant
12:10:41 <johnw> I don't mind talking about HalVM, but it was going places that had nothing to do with Haskell, or where I couldn't see the connection.  And likely neither could most of the other 1500+ people here.  This isn't anyone's social channel, which is why we keep things on topic.
12:11:14 <hackrilege> I wonder why the status of this keystones project is unaddressed
12:11:15 <johnw> if you need to go into depth with someone else on a particular subject like this, you can open a PRIVMSG with them
12:12:03 <inad922> Hi
12:12:39 <hackrilege> Installation specific posts were two out the max. If you would like to publicly ridicule me I would invite you to open a private message, your scorn has taken fat more discussion
12:12:40 <inad922> If I define a type synonym via "type NewTypeName = stuff" how can I get this defnition in the interpreter?
12:13:21 <Pompeii> Hey guys; anyone have any experiences with git GUIs?  Wondering if Tower is worth the money
12:13:31 <johnw> hackrilege: there is no scorn, and I apologize if this has come across as ridicule
12:13:47 <johnw> I will resume this in privmsg
12:14:28 <johnw> Pompeii: this channel is for discussions about Haskell
12:14:49 <mniip> inad922, it should be already there
12:14:59 <mniip> or you mean how do you type it in the ghci?
12:16:01 <statusfailed> hackrilege: Just caught your ARM / Haskell conversation- can I ask what you're up to? I'm thinking of spinning up a scaleway (ARM) server with GHC- not sure where to start though
12:16:48 <hackrilege> Please take this discussion to #haskell-embeded
12:17:07 <statusfailed> scaleway's not embedded! :p
12:17:32 <inad922> mniip, I mean let's say I have this type "type Stuff = [String]" and a function with a signature "some_func :: Stuff". If I do "let a = some_func" and ":t a" in ghci it returns "Stuff" and I want "[String]" or "[[Char]]"
12:17:49 <inad922> Is it possible to unwind these type synonyms?
12:17:52 <hackrilege> Johnw^
12:18:00 <johnw> hackrilege: thank you!
12:18:12 <Cale> inad922: :info Stuff will tell you how the synonym is defined
12:18:19 <inad922> Cale, Thanks Cale
12:18:40 <Cale> inad922: I think it's worth pointing out that some_func would not be a function in your example
12:18:50 <statusfailed> hackrilege: seems kinda dead :-)
12:18:51 <hackrilege> Statusfailed, unfortunately that's the only place such discussion is considered on topic
12:19:13 <mniip> inad922, :t! iirc
12:19:14 <statusfailed> hackrilege: well, scaleway is not embedded- I think it's on-topic here.
12:19:18 <statusfailed> ;)
12:19:25 <mniip> no wait
12:19:27 <mniip> nevermind
12:20:06 <inad922> Cale, What is it if it's not a function? It's not a function because it doesn't have any input params?
12:20:13 <inad922> What -> WHy
12:20:18 <Cale> inad922: Right, it's just a list of strings
12:20:28 <inad922> Yeah I know
12:20:31 <Cale> Functions are values whose type is A -> B for some types A and B
12:20:37 <inad922> But isn't this just a constant function?
12:20:40 <Cale> no
12:21:01 <mniip> a constant function is something of type exists b. forall a. a -> b
12:21:08 <Cale> Constant functions still have a domain they act on, they just happen to act on it in a boring way
12:21:08 <inad922> That's just weird. I mean this constant something and functions have the same syntax
12:21:17 <inad922> mniip, ah ok I get that
12:21:24 <mniip> inad922, you can say it's a nullary function
12:21:31 <Cale> For example,  f :: Integer -> Integer; f n = 65  is a constant function
12:21:32 <mniip> but then all functions are actually unary in haskell
12:21:42 <mniip> so yours is just a value
12:22:03 <breadmonster> Guys, are there any cool type system hacks?
12:22:07 <mniip> inad922, in context of pedantry, a function is something of typy X -> Y
12:22:07 <Cale> Yeah, if you're going to call a list of strings a function, then you have no distinction between the word "function" and the word "value"
12:22:09 <inad922> So basically this is the way to define module wide constants?
12:22:10 <breadmonster> Ideally, people would collect all this in one place.
12:22:22 <breadmonster> And call it Imaginary World Haskell or something.
12:22:32 <breadmonster> Phantom types blew my mind.
12:22:33 <mniip> breadmonster, "askhell"
12:22:57 <Cale> breadmonster: I dunno, have you seen Oleg's site?
12:24:11 <breadmonster> Cale: What is Oleg's site?
12:24:14 <breadmonster> Who is Oleg?
12:24:17 <statusfailed> :O
12:24:22 <Cale> Who is Oleg!? :D
12:24:29 <breadmonster> This Haskell thing of referring to everyone by their first names gets confusing.
12:24:31 <statusfailed> breadmonster: http://okmij.org/ftp/
12:24:32 <Cale> http://okmij.org/ftp/README.html -- he has a bunch of other stuff there, but lots of Haskell type hackery
12:24:36 <breadmonster> There are two Simons already.
12:24:50 <mniip> breadmonster, it's not confusing when you only have like 10 people to refer to
12:24:54 <statusfailed> breadmonster: Oleg writes a lot about programming languages, he's got some cool papers
12:24:57 <mniip> because that's how many people have mastered haskell
12:24:59 <statusfailed> mniip: haha :D
12:25:03 <breadmonster> mniip: who are these people?
12:25:09 <breadmonster> statusfailed: Who is he?
12:25:13 <mniip> well, edward...
12:25:17 <mniip> and... uh
12:25:21 <mniip> other people
12:26:01 <breadmonster> Edward, the two Simons, Philip, and now I guess Oleg.
12:26:03 <breadmonster> And Cale too.
12:26:10 <statusfailed> breadmonster: I'm not sure if he's an academic, but he's just a guy who writes a lot of papers, which are often about Haskell
12:26:44 <ralu> about Prelude. Is  library for ghc and other haskell implementaions same?
12:27:03 <EvanR> > sqrt (-1 :: Complex Double)
12:27:05 <lambdabot>  0.0 :+ 1.0
12:27:08 <EvanR> imaginary haskell
12:27:20 <statusfailed> breadmonster: there's a few people who seem to be ridiculously productive, among them ekmett, tekmo, oleg ... etc.
12:27:30 <mniip> breadmonster, maybe also dons
12:27:38 <breadmonster> mniip: Oh yeah, Don.
12:27:38 <EvanR> statusfailed: ill have the drugs theyre having
12:27:49 <mniip> I mean he wrote bytestring
12:27:52 <Cale> ralu: Pretty much? If the other implementation is using the base package, then it'll have the same Prelude exactly. There have been a bunch of recent advances to the Prelude, and perhaps some other implementations of Haskell haven't caught up yet.
12:28:03 <statusfailed> EvanR: :D
12:28:46 <Cale> ralu: But it's pretty rare that anyone actually worries about an implementation of Haskell that is not GHC.
12:29:03 <mniip> Cale, how would a different implementation use the same base package
12:29:08 <mniip> I mean have you seen the module list
12:29:29 <breadmonster> mniip: There's a list module?
12:29:34 <Cale> mniip: The base package has a lot of CPP nonsense in it for just that reason
12:29:43 <mniip> breadmonster, no, there is a module list
12:29:45 <breadmonster> Speaking of which, why aren't things in Haskell as general as possible?
12:29:59 <EvanR> because when you explain haskell like this
12:30:02 <EvanR> :t length
12:30:03 <Cale> breadmonster: What do you mean?
12:30:03 <lambdabot> Foldable t => t a -> Int
12:30:08 <EvanR> people are like what
12:30:24 <EvanR> :t genericLength
12:30:26 <lambdabot> Num i => [a] -> i
12:30:32 * EvanR anime crashes into the floor
12:30:34 <ralu> notso generic
12:30:37 <ralu> lol
12:30:39 <Cale> Note that "using typeclasses" /= "as general as possible"
12:30:44 <breadmonster> eg. we have `length :: [a] -> a` instead of `length :: Sequence f, Num b => f a -> b`
12:31:02 <arkeet> breadmonster: how does that work with ByteString?
12:31:03 <Cale> breadmonster: have you seen the type of length lately?
12:31:06 <Cale> :t length
12:31:07 <lambdabot> Foldable t => t a -> Int
12:31:21 <arkeet> :t genericLength
12:31:22 <lambdabot> Num i => [a] -> i
12:31:25 <arkeet> ha
12:31:26 <Cale> ^^ I'm actually just a little bit sad that this is in the Prelude.
12:31:26 <arkeet> :<
12:31:27 <sinelaw> should have been Integral
12:31:29 <Hafydd> Heh.
12:31:42 <ggole> So genericLength is less generic than length... how strangely satisfying.
12:31:42 <mniip> :t genericLength'
12:31:43 <lambdabot> (Functor t, Num a, Foldable t) => t b -> a
12:31:44 <arkeet> sinelaw: why?
12:31:49 <EvanR> length :: Lengthable a b => a -> b
12:31:57 <ralu> why functor?
12:31:58 <Cale> ggole: It's of incomparable generality :D
12:32:12 <ggole> Cale: that doesn't make it less amusing though
12:32:15 <sinelaw> arkeet: or maybe Integer?
12:32:23 <arkeet> now you're getting less generic :-)
12:32:24 <EvanR> sinelaw: the algorithm only uses +
12:32:27 <EvanR> and 1
12:32:28 <breadmonster> mniip: That makes more sense.
12:32:35 <Cale> It should be Integer
12:32:38 <EvanR> and 0
12:32:39 <Cale> imo
12:32:40 <mniip> :t genericLength'
12:32:41 <lambdabot> (Num a, Foldable t) => t b -> a
12:32:56 <EvanR> Cale: right but it would be inconvenient unless everything else started using Integer too
12:33:00 <mniip> getSum . foldMap (const (Sum 1))
12:33:06 <Cale> Or if we had a well-implemented Natural type, it should be that, but we still don't :P
12:33:21 <breadmonster> Cale: Integer is an annoying type, it doesn't fit into a word, it can't be unboxed...
12:33:25 <EvanR> juggling Int Integer and Natural would be really annoying
12:33:33 <profsimm> Full disclosure, I don't core in Haskell and this is not a Haskell-specific question, but I really need a Haskeller's mindset to resolve it. I have bunch of microservices talking to each other. Every call is made with possibly different authentication/authorization tokens. I don't want to explicitly pass auth to every function's argument list, but I don't want it to be implicit shared state either. Any thoughts how I might factor tha
12:33:50 <EvanR> just pick Integer
12:33:57 <breadmonster> EvanR: that's true.
12:34:22 <Cale> profsimm: "Every call is made with possibly different authentication/authorization tokens. I don't want to explicitly pass auth to every function's argument list." -- these two things seem at odds with each other
12:34:32 <profsimm> Cale: yes
12:34:38 <Cale> profsimm: You have to put the information about which things you want to use *somewhere*
12:34:41 <mniip> profsimm, the State monad
12:34:55 <mniip> your functions would 'get' the token, and then you could 'set' it
12:34:58 <breadmonster> Ideally, we'd have some sort of way of implementing a comparable hierarchy.
12:35:03 <Cale> Yeah, you *could* use a State monad...
12:35:05 <mniip> or maybe the Reader monad's "local" would help
12:35:14 <Cale> Yeah, or local, sure
12:35:21 <profsimm> Cale: on a purely technical level I want to pass auth as argument. I just don't want to write it and read it as an argument, because it's the same boilerplate *in every function* -> wrap it in "auth" object, check it is valid etc.
12:35:21 <EvanR> breadmonster: except numbers arent very hierarchical
12:35:35 <breadmonster> EvanR: There's a total ordering in there.
12:35:41 <EvanR> breadmonster: huh?
12:35:44 <Cale> profsimm: Which boilerplate apart from just passing the parameter?
12:36:01 <breadmonster> EvanR: All numbers can be compared right? Theoretically speaking?
12:36:08 <mniip> well, you could implement a errno-esque API
12:36:11 <profsimm> Cale: wrapping it in an auth object and calling the necessary methods to validate it then pass it along to the next call
12:36:15 <mniip> but if this is to be used in C, programmers will hate you
12:36:27 <EvanR> breadmonster: Int Word Integer Natural Rational Double Complex CReal etc dont really map very well to any sort of nice sequential venn diagram like in the school
12:36:29 <breadmonster> I'd like to implement a general comparison function across types, and leave Ord for comparisons using the same type.
12:36:39 <EvanR> you cant
12:36:40 <Cale> I feel like a lot of people have a completely unnecessary negative reaction to passing around parameters -- especially ones which actually matters.
12:36:42 <Cale> matter*
12:36:52 <EvanR> breadmonster: the computer can only compare numbers of the same type
12:37:12 <mniip> Cale, said everyone who didn't invent the state monad
12:37:12 <ralu> what about locked machinnery approach. You can do computation if you can unlock machinery using token
12:37:26 <breadmonster> `class (Num a, Num b) => Comparable a b where lessThan :: a -> b -> Bool`
12:37:36 <geekosaur> breadmonster, even within numbers there are things you can only compare equality for (complex, quaternions, and higher orders)
12:37:38 <Cale> mniip: There are lots of techniques to pass things around "automatically", like reader or state monads, but it's not like you're not paying a similar syntactic cost to use them.
12:37:43 <EvanR> breadmonster: how would you go about comparing Int and Double?
12:37:51 <breadmonster> geekosaur: Sure, like along the real line.
12:37:53 <profsimm> Cale: I already wrote 10k lines by passing it. And like 20% of my code is just the same boilerplate for reading auth, checking auth, passing on auth...  And then I had to change something in like 200 functions and ...
12:37:57 <breadmonster> EvanR: How does Python do it?
12:38:02 <EvanR> breadmonster: incorrectly
12:38:11 <Cale> profsimm: Well, okay, do you see patterns in the code which reads and checks the auth?
12:38:13 <profsimm> Cale: so it made me think :)
12:38:16 <Cale> Can you factor *that* out?
12:38:24 * dgpratt is about to find out if the oft repeated adage "if it compiles, it works" is actually true
12:38:27 <mniip> breadmonster, metafunctions
12:38:28 <profsimm> Cale: *shrug*
12:38:32 <breadmonster> EvanR: Okay, then convert both to an arbitrary precision real.
12:38:36 <profsimm> Cale: I can't factor it out that's the thing
12:38:40 <breadmonster> mniip: What are metafunctions?
12:38:42 <EvanR> breadmonster: which also cant be compared!
12:38:43 <Cale> profsimm: Can I see a little bit of it?
12:38:49 <breadmonster> EvanR: What really?
12:38:50 <mniip> breadmonster, in haskell terms, it's Eq a => a -> Object -> Bool
12:38:51 <dgpratt> cus I have no idea what I'm doing, but...it compiles!
12:38:54 <EvanR> > (1 :: CReal) == (1 :: CReal)
12:38:55 <profsimm> Cale: yes but... it... is...
12:38:56 <lambdabot>  True
12:38:57 <Cale> profsimm: Is this in a functional programming language?
12:39:05 <profsimm> Cale: nope :(
12:39:07 * EvanR how do you defeat that...
12:39:18 <Cale> profsimm: Oh, well, you might actually be screwed then :D
12:39:18 <EvanR> > (1-1 :: CReal) == (0 :: CReal)
12:39:20 <lambdabot>  True
12:39:25 <mniip> [21:33:02] <profsimm> Cale: yes but... it... is...
12:39:27 <mniip> NDA?
12:39:37 <breadmonster> EvanR: ...?
12:39:38 <ralu> Java ?
12:39:40 <profsimm> Cale: it's Java, JavaScript, PHP and C#
12:39:42 <EvanR> > (2 :: CReal) == (sqrt 4 :: CReal)
12:39:44 <lambdabot>  True
12:39:47 <breadmonster> lol
12:39:50 <profsimm> :(
12:39:51 <mniip> oh
12:39:54 <mniip> not sure which is worse :S
12:40:01 <Cale> profsimm: Well, a few of those have lambda at least
12:40:10 <EvanR> breadmonster: arbitrary reals cant be compared in a total computable way
12:40:15 <breadmonster> @info CReal
12:40:15 <lambdabot> CReal
12:40:29 <breadmonster> EvanR: interesting, I didn't know that.
12:40:33 <Cale> profsimm: So you can write things which e.g. take a function as an argument whose job is to do something with the unpacked authentication.
12:40:40 <ralu> PHP < Java < JavaScrpt < C# 
12:40:42 <EvanR> > (sin pi :: CReal) == (-1 :: CReal)
12:40:44 <lambdabot>  False
12:40:45 <profsimm> Cale: they do yeah. I thinking maybe I make every "endpoint action" in my microservices a separate closure-returning-closure (or separate object) and I pass auth to constructor
12:40:50 <EvanR> > (cos pi :: CReal) == (-1 :: CReal)
12:40:51 <lambdabot>  True
12:41:21 <profsimm> Cale: this means instead of 20 classes with 10 methods each I'll end up with 200 classes, or high-order closures. But maybe it's not that bad.
12:41:29 <Cale> uhhh
12:41:36 <profsimm> ;(
12:41:44 <breadmonster> EvanR: xD
12:41:53 <mniip> wait
12:41:56 <EvanR> breadmonster: anyway, your idea is more along the lines of for types than can be embedded on the real line, first convert them to reals then compare two reals right?
12:41:58 <mniip> CReal's == can return True?
12:42:01 <mniip> how
12:42:08 <EvanR> mniip: i have no idea, will figure that out later ;)
12:42:11 <breadmonster> EvanR: Yeah?
12:42:22 <int-e> > 1 == (1.00000000000000000000000000000000000000000000000000000000000001 :: CReal) -- CReal aren't actually exact reals
12:42:23 <EvanR> breadmonster: so what you really want is a type class which converts the number to a real instead
12:42:23 <lambdabot>  True
12:42:27 <Cale> profsimm: I'm thinking of something which in Haskell would look like   withAuthentication :: AuthToken -> (Stuff -> Things -> IO a) -> IO a
12:42:28 * dgpratt ponders what a Reader Monad would look like in C#
12:42:35 <EvanR> int-e: wth!
12:43:03 <Cale> profsimm: Where "Stuff" and "Things" are the bits which get retrieved from the repetitious code for dealing with the authentication
12:43:07 <EvanR> breadmonster: and were back to my original point, you really only want to compare two numbers of the same type
12:43:19 <mniip> EvanR, oh
12:43:19 <EvanR> if it makes sense, and it doesnt for Complex
12:43:28 <mniip> EvanR, there is a default precision
12:43:34 <mniip> which is what is used for ==
12:43:51 <breadmonster> Okay, cool.
12:43:53 <mniip> 40 digits
12:44:16 <profsimm> Cale: tryin' to wrap my mind around it.
12:44:20 <Cale> profsimm: So withAuthentication can do whatever init is required, pass the resulting bits to the function, and execute the resulting action, and then do some cleanup at the end
12:45:03 <int-e> EvanR: well, they are arbitrary precision reals, but as mniip said there's a default precision and that's used in the Eq instance
12:45:23 <EvanR> breadmonster: this characterization makes way more sense than the much more complex and ambiguous sometimes notion that any two numeric types can somehow be compared as-is, either via weird coercion rules (to/from each other) or n^2 custom algorithms
12:45:30 <Cale> profsimm: i.e. it factors out all the repetitive unpacking of things from the authentication info you're passing around.
12:45:42 <dgpratt> Cale, profsimm I've used such a pattern in C# many times and I'd think it'd be nearly as easy in JS
12:45:45 <breadmonster> Fair enough.
12:45:53 <mniip> int-e, why isn't there a CReal -> CReal -> () that returns a proof of 2 CReals being unequal
12:45:59 <EvanR> breadmonster: its also not really necessary in your daily life! just use Integer or Double ;)
12:46:10 <geekosaur> ...so is 0.23\overbar{9} equal to 0.24?
12:46:26 <Cale> geekosaur: yes
12:46:27 <EvanR> you usually need to know anyway whether youre dealing with integral or fractional numbers
12:46:38 <mniip> geekosaur, you wouldn't run into that issue with CReal
12:46:50 <geekosaur> Cale: yep, that was intended to be rhetorical about comparing reals
12:46:59 <Cale> geekosaur: ah, okay
12:47:28 <profsimm>  dgpratt how would that look in C# can you please post a one-liner, I think I can't think in Haskell well
12:47:45 <EvanR> geekosaur: can you translate that into a False CReal comparison
12:48:44 <geekosaur> EvanR, I was still thinking in terms of the "real number line" bit. I know CReal has no infinitely long values
12:48:49 <dgpratt> profsimm, in C# you'd have a WithAuthentication method that accepts either an Action<> or a Func<>
12:49:09 <mniip> geekosaur, CReal can represent them though
12:49:23 <profsimm> dgpratt: mhm, ok I see. thanks
12:49:31 <EvanR> how can you denote a representation of 0.23333333...
12:49:36 <EvanR> with CReal
12:49:38 <profsimm> Cale, dgpratt, I'll think about what you folks said, thanks for the help!
12:50:05 <mniip> EvanR, 7/30
12:50:06 <EvanR> er 0.2399999999
12:50:21 <mniip> 6/25
12:50:37 <EvanR> in a way that would output those digits if forced
12:50:38 <int-e> 2399999999/10^10
12:50:44 <mniip> you can't
12:50:46 <Cale> EvanR: 24/100
12:50:51 <mniip> that's not how CReal works
12:50:53 <EvanR> meh
12:50:53 <mniip> it's not a list of digits
12:51:09 <mniip> it's a function
12:51:10 <EvanR> just wondering if theres an exploits
12:51:56 <EvanR> wait
12:52:10 <EvanR> > (1/3 :: CReal) + (1/3) + (1/3)
12:52:12 <lambdabot>  1.0
12:52:12 <Cale> EvanR: CReal is essentially Integer -> Rational, where you give a number n, and it gives you an approximating rational within 1/2^n of the value
12:52:30 <Cale> Note that the show instance will sometimes lie
12:52:45 <Cale> It just computes the value to within 200 digits or so
12:53:07 <EvanR> so it avoids digits in the implementation
12:53:13 <mniip> Cale, Int -> Integer
12:53:15 <EvanR> until rendered
12:53:15 <mniip> no rationals
12:53:35 <mniip> > show (pi :: CReal)
12:53:36 <lambdabot>  "3.1415926535897932384626433832795028841972"
12:53:44 <mniip> > showCReal 100 pi
12:53:45 <lambdabot>  "3.1415926535897932384626433832795028841971693993751058209749445923078164062...
12:54:32 <Cale> mniip: Well, yeah, maybe it gives you a dyadic rational with denominator 2^n
12:54:48 <Cale> There are a bunch of possible implementations which are pretty similar
12:58:50 <statusfailed> Do the ghc binaries assume a particular version of glibc?
13:00:15 <johnw> statusfailed: wouldn't that just be a matter of which version they're linked against?
13:00:36 <statusfailed> johnw: actually... I asked the wrong question :|
13:00:40 <EvanR> on linux you can do ldd to see
13:00:46 <statusfailed> what I meant was "do GHC binaries assume glibc"
13:00:50 <statusfailed> i.e., can I use musl
13:00:51 <johnw> let me see
13:01:53 <statusfailed> found a thread on reddit, seems like a massive amount of effort, haha
13:02:20 <johnw> well, not on OS X, but likely because we don't have glibc :)
13:02:22 <EvanR> binaries output by ghc?
13:02:47 <statusfailed> EvanR: GHC itself
13:03:24 <mniip> statusfailed, then your question should've asked "version of libc"
13:03:40 <mniip> glibc is an implementation of libc
13:04:24 <statusfailed> mniip: yeah, sorry, I tried to rectify early with msg "what I meant was 'do GHC binaries assume glibc'"
13:04:33 <statusfailed> earlier*
13:05:11 <statusfailed> You are absolutely right 
13:08:44 <darthdeus> hey guys, it seems that cabal deadlocks when trying to install any package http://i.imgur.com/xWtnHW4.png
13:08:55 <darthdeus> this is strace on cabal install, it gets stuck there for a loong time, not doing anything
13:09:35 <davean> darthdeus: "any"?
13:09:45 <mniip> darthdeus, stracing GHC is a really bad idea
13:10:03 <davean> mniip: Its really useful IME
13:10:14 <mniip> try +RTS -V0
13:10:15 <davean> I mean, this just shows it spinning on a futex
13:10:16 <darthdeus> mniip: I also tried running without strace, and attaching later on
13:10:20 <mniip> that should clean up the strace
13:10:30 <darthdeus> also it doesn't react on ctrl-c, I have to kill -9 it
13:10:37 <darthdeus> davean: well, I tried ghc-mod and some other things afaik
13:11:06 <darthdeus> oh nvm, installing just a small package seems to work, hmm
13:11:19 <davean> darthdeus: do you know what file descripter 9 is?
13:11:32 <mniip> darthdeus, it's not a deadlock
13:11:55 <mniip> it's the heap profile timer thingy
13:11:55 <darthdeus> mniip: how? it's stuck on a futex :O
13:12:04 <mniip> executes every 0.01 seconds by default
13:12:06 <davean> darthdeus: it isn't stuck, its spinning
13:12:12 <davean> darthdeus: thats different
13:12:28 <darthdeus> yeah but spinning on a lock that doesn't get released is the same as being asleep on a kernel mutex, no?
13:12:30 <mniip> GHC is not single-threaded
13:12:42 <davean> darthdeus: no, it isn't
13:12:43 <mniip> like, very far from being single-threaded
13:12:52 <davean> darthdeus: you might want to figure out what fd 9 is
13:13:00 <davean> darthdeus: thats the only interesting thing that happens in the trace you show
13:13:09 <davean> and I'll point out *it does happen in teh trace you show*
13:13:20 <davean> Thus it *can't* be locked up
13:13:25 <darthdeus> davean: anon_inode:[eventfd]
13:14:16 <mniip> darthdeus, the master tick thread is stuck on the futex
13:14:20 <mniip> and that's how it's supposed to be
13:14:23 <mniip> that's just what it does
13:14:29 <mniip> meanwhile there are other threads
13:14:32 <davean> This photo of a trace isn
13:14:36 <davean> t enough to get far with
13:14:44 <darthdeus> mniip: but those aren't doing anything
13:14:47 <mniip> once again
13:14:50 <davean> mniip: you can strace all the threads
13:14:51 <mniip> try passing +RTS -V0
13:15:39 <darthdeus> mniip: can't, cabal: Most RTS options are disabled. Link with -rtsopts to enable them.
13:15:43 <NikolajK> heyyo, how to talk with djinn again, I can't find him
13:15:45 <darthdeus> should I recompile cabal-install?
13:16:02 <darthdeus> btw, I've installed ghc + cabal from arch repos, so that might be why it seems broken
13:16:04 <mniip> :/
13:16:24 <davean> darthdeus: why don't you just turn on cabal's verbosity?
13:16:33 <davean> darthdeus: LEts see what it thinks it is doing
13:16:43 <davean> also, if you could use a pastebin instead of a photo perhaps?
13:17:03 <NikolajK> @djinn: a->a
13:17:03 <lambdabot> f a = a
13:17:09 <darthdeus> I will
13:17:37 <NikolajK> @djinn: (a,b)->b
13:17:37 <lambdabot> f (_, a) = a
13:17:52 <mniip> NikolajK, you can also do that in a PM with lambdabot!
13:18:14 <orion> Is there a generic way to run any monad 'm'?
13:18:18 <darthdeus> http://lpaste.net/8738894769473716224
13:18:25 <NikolajK> ah thx
13:18:42 <orion> For example, if I do something like runStateT, I get a "m (a, s)" not "(a, s)".
13:19:47 <arkeet> orion: no, that's the point.
13:19:53 <mniip> orion, most monads aren't even transformers
13:20:00 <mniip> think []
13:20:12 <arkeet> (or a point.)
13:20:12 <davean> mniip: no monad is a transformer?
13:20:21 <darthdeus> but now it seems to be doing things, with cpu at 100% ... previously it didn't show in htop anywhere near the top
13:20:37 <darthdeus> ha it's moving
13:20:52 <darthdeus> maybe -v3 is the magic that fixes it :P
13:21:19 <mniip> davean, hm?
13:21:19 <hardmath123> Is there a primitive with signature [a] -> (a -> a) -> [[a]] which turns f and [1,2,3] into [[f 1,2,3], [1,f 2,3], [1,2,f 3]]  ?
13:21:37 <hardmath123> I tried Hoogle-ing the type signature, but I didn't see anything relevant.
13:22:15 <orion> So, if I have this: "newtype Descriptor c d m a = Descriptor { unD :: StateT (HandshakeState c d) m a }" what's the proper way to get a "(a, HandshakeState c d)"?
13:22:30 <mniip> you can't
13:22:35 <mniip> not with an arbitrary m
13:23:14 <mniip> you're asking for a magical m a -> a, which is kinda opposite to the point of monads
13:23:19 <orion> hmm
13:23:23 <davean> mniip: mniip a transformer and a monad is a monad
13:23:46 <mniip> davean, I mean Maybe gives rise to a MaybeT transformer
13:24:16 <mniip> ListT is based on [] but it's an unlawful transformer
13:24:24 <mniip> and there is no "lawful" ListT
13:24:36 <Cale> What?
13:24:57 <Cale> There are some nondeterminism transformers which are lawful.
13:25:06 <mniip> hm?
13:25:14 <Cale> See for instance the logict package on hackage.
13:25:25 <Cale> Also, I think there's one in pipes
13:25:28 <mniip> hardmath123, there is not a primitive, but
13:25:54 <mniip> diag [] f = []; diag (x:xs) f = (f x:xs):map (x:) diag xs f
13:25:59 <Cale> http://hackage.haskell.org/package/pipes-4.1.6/docs/Pipes.html#t:ListT -- this ListT is lawful
13:26:35 <Gurkenglas> Don't forget CofreeT Maybe, which is with NonEmpty instead of [] but still
13:26:58 <Cale> http://hackage.haskell.org/package/logict-0.6.0.2/docs/Control-Monad-Logic.html#t:LogicT
13:27:00 <fizruk> mniip: missing parens around (diag xs f)
13:27:03 <Cale> ^^ also lawful
13:27:31 <Cale> It's possible to do ListT right, it's just that mtl screwed it up
13:27:35 <mniip> fizruk, yeah I noticed
13:27:48 <hardmath123> ah, nice. thanks mniip and fizruk.
13:28:04 <mniip> it was left as an excercise to the reader :P
13:28:15 <fizruk> sorry :(
13:28:23 <mniip> just kidding
13:28:56 <mniip> it was more of "oh wait, typo, oh nah, they'll figure it out" ting
13:29:01 <fizruk> i was wondering if there exist a compact implementation for diag
13:29:06 <mniip> thing
13:29:08 <mniip> yeah
13:29:14 <mniip> I wondered the same for like 5 minutes
13:29:24 * hackagebot type-combinators 0.1.0.0 - A collection of data types for type-level programming.  https://hackage.haskell.org/package/type-combinators-0.1.0.0 (KyleCarter)
13:31:11 <hardmath123> compact implementation? as in, occupies fewer sloc, or is that a haskell term? :)
13:31:49 <Cale> hardmath123: He probably means an implementation which doesn't resort to direct recursion.
13:31:54 <mniip> fizruk, my current idea consists of
13:31:56 <mniip> :t iterate (over _tail) (over _head)
13:31:57 <lambdabot> (Cons a1 a1 a1 a1, Cons (a1 -> a1) (a1 -> a1) a a) => [(a1 -> a1) -> a1 -> a1]
13:32:06 <fizruk> wow
13:32:46 <Gurkenglas> *applauds* been looking for that one for a while
13:34:18 <Gurkenglas> :t iterate (over _tail) . (over _head) -- wait shouldn't that be this?
13:34:19 <lambdabot> Cons b b a a => (a -> a) -> [b -> b]
13:34:24 * hackagebot type-combinators 0.1.0.1 - A collection of data types for type-level programming.  https://hackage.haskell.org/package/type-combinators-0.1.0.1 (KyleCarter)
13:34:28 <johnw> Cale: simple-conduit's core type is a ListT also
13:34:45 <johnw> Cale: likewise with 'streaming', if you specialize it
13:34:50 <johnw> so many ListTs, so little time
13:35:56 <Gurkenglas> Huh, is there anything else with this many possible implementations? Has someone tried classifying all possible ListTs?
13:37:55 <cabbibo> hey there! is this an ok place to ask super beginner questions? or is there a better irc channel for that?
13:38:03 <sinelaw> cabbibo: ask away
13:38:10 <sinelaw> and there is also #haskell-beginners IIRC
13:38:16 <cabbibo> oh cool! 
13:38:35 <cabbibo> I'll ask both places :)
13:39:10 <cabbibo> So basically, I am working on a pretty complex repo written by LukeXI doing some graphics things
13:39:17 <cabbibo> and I'm trying to get some of the logic working
13:39:25 <mniip> Gurkenglas, er yes
13:39:39 <cabbibo> I've set up a map: _wldLines  :: !(Map ObjectID Line)
13:39:57 <cabbibo> and I have an id saved : _wldActiveLineID :: !ObjectID
13:40:11 <fizruk> > let g xs f = init $ zipWith (<>) (inits xs) (over _head f <$> tails xs) in g [1..3] (*10)  -- mniip: not so compact though
13:40:13 <lambdabot>  [[10,2,3],[1,20,3],[1,2,30]]
13:40:21 <cabbibo> and I'm basically trying to get a specific line using that map
13:40:28 <Cale> cabbibo: sure
13:40:37 <Cale> cabbibo: Map.lookup will probably help
13:40:40 <cabbibo> using lines <- use wldLines               activeLineID <- use wldActiveLineID
13:40:55 <mniip> :t \xs f -> zipWith (const ($ xs)) xs $ iterate (over _tail) (over _head f)
13:40:56 <lambdabot> [b] -> (b -> b) -> [[b]]
13:41:12 <Cale> http://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Map-Lazy.html#v:lookup
13:41:20 <mniip> > let moo = \xs f -> zipWith (const ($ xs)) xs $ iterate (over _tail) (over _head f) in moo [1,2,3] negate
13:41:22 <lambdabot>  [[-1,2,3],[1,-2,3],[1,2,-3]]
13:41:36 <cabbibo> ah yes, so I used Map.lookup 
13:41:42 <Gurkenglas> why not eta expand f away
13:42:00 <Cale> and that will get you a Maybe Line -- it might be Nothing if the ObjectID you used is not in the Map
13:42:01 <cabbibo> let l = Map.lookup lines activeLineID
13:42:22 <mniip> maybe it's Maybe Line
13:42:26 <Cale> So you'll then probably want to case on whether the result was Nothing, or Just line
13:42:39 <cabbibo> ya ya
13:42:44 <Cale> case Map.lookup activeLineID lines of
13:42:52 <Cale>   Nothing -> ... handle error condition ...
13:43:01 <Cale>   Just l -> ... do stuff with l :: Line ...
13:43:19 <cabbibo> right right!
13:43:26 <cabbibo> lemme try that out real quick!
13:46:26 <Gurkenglas> :t iterate (_tail .) _head
13:46:28 <lambdabot> (Applicative f, Cons s s a a) => [(a -> f a) -> s -> f s]
13:46:54 <cabbibo> @Cale works great!!! Thank you very much!!!
13:46:54 <lambdabot> Unknown command, try @list
13:47:01 <Cale> cabbibo: no problem!
13:52:35 <Gurkenglas> :t sequenceA . (map (%~) (iterate (_tail .) _head) ??) -- mniip, you had the arguments the wrong way round
13:52:36 <lambdabot> Cons a a b b => (b -> b) -> a -> [a]
13:53:59 <mniip> well I didn't use the lensiness
13:54:02 <mniip> just over
13:54:48 <johnw> Gurkenglas: what does this lens construction do?
13:55:45 <Gurkenglas> johnw, iterate (_tail .) _head is a list of all up-to-one-element traversals of a list. (huh why not just map ix [0..])
13:57:00 <mniip> ixing numbers is as bad as map (!!) [0..]
13:57:11 <Gurkenglas> The next bracket up applies over (shoulda called it over not (%~)) and applies that list to a single list. sequenceA takes that list argument back out of the list of functions that results
13:57:41 <Gurkenglas> iterate (_tail .) _head can be optimized? I was hoping for it because lens is so algorithmically simple at the bottom of it
13:58:14 <johnw> can you show me a use of it, Gurkenglas?
13:58:31 <Gurkenglas> Yep and afterwards ill refactor it a little
13:59:41 <Gurkenglas> > take 4 $ (sequenceA . (map (%~) (iterate (_tail .) _head) ??)) (*10) [2..5]
13:59:43 <lambdabot>  [[20,3,4,5],[2,30,4,5],[2,3,40,5],[2,3,4,50]]
14:00:07 <johnw> ok, let me play with this...
14:01:37 <Gurkenglas> :exf "Applicative f => f (a -> b -> c) -> a -> b -> f c" -- gonna need this
14:01:38 <exferenceBot> \ a b c -> fmap (\ f7 -> f7 b c) a
14:02:15 <mniip> @pl \ a b c -> fmap (\ f7 -> f7 b c) a
14:02:15 <lambdabot> flip (flip . (fmap .) . flip . flip id)
14:02:21 * mniip steps back
14:04:32 <Gurkenglas> @let (???) f a b = f ?? a ?? b
14:04:33 <lambdabot>  Defined.
14:05:06 <Gurkenglas> :t (map over (iterate (_tail .) _head) ???)
14:05:07 <lambdabot> Cons b b b1 b1 => (b1 -> b1) -> b -> [b]
14:06:04 <jophish__> :q
14:06:37 <Gurkenglas> > take 4 $ map over (iterate (_tail .) _head) ?? (*10) ?? [2..5] -- Then again one could just write this
14:06:38 <lambdabot>  [[20,3,4,5],[2,30,4,5],[2,3,40,5],[2,3,4,50]]
14:07:29 <mniip> "???"
14:07:39 <mniip> an operator that perfectly depicts your thoughts when reading this code
14:07:58 <johnw> > (\xs -> xs & imap (\i x -> xs & ix i %~ (*10))) [2..5]
14:08:00 <lambdabot>  [[20,3,4,5],[2,30,4,5],[2,3,40,5],[2,3,4,50]]
14:09:33 <johnw> since imap isn't even using the 'x' parameter, there might be a yet simpler way
14:10:32 <mniip> at this point I like the explicit version more
14:11:23 <johnw> yes, lenses don't gain much when it comes to list manipulation
14:11:30 <arkeet> > map (peeks (*10)) (holesOf traverse [2..5])
14:11:32 <lambdabot>  [[20,3,4,5],[2,30,4,5],[2,3,40,5],[2,3,4,50]]
14:12:10 <mniip> :t peeks
14:12:11 <lambdabot> ComonadStore s w => (s -> s) -> w a -> a
14:12:26 <mniip> :t holesOf
14:12:27 <lambdabot> Conjoined p => Over p (Bazaar p a a) s t a a -> s -> [Control.Lens.Internal.Context.Pretext p a a t]
14:12:29 <johnw> very nice
14:12:39 <mniip> okay this is the side of lens I haven't seen
14:12:49 <johnw> i would never have thought of that either
14:12:58 <arkeet> I only thought of it just now.
14:12:59 <edwardk> its based on uniplate
14:13:08 <mniip> no I mean I didn't even know such functions existed
14:13:13 <johnw> what is "holesOf traverse"?
14:13:32 <Gurkenglas> Yep that looks like </thread>. well done
14:13:33 <mniip> :o
14:13:35 <mniip> p a a) s t a a
14:13:44 <arkeet> pasta
14:14:07 <johnw> is it every member of the list, plus it's one-hole context?
14:14:17 <johnw> then you can multiple that member by (*10), and re-integrate
14:14:19 <johnw> clever
14:14:28 <orion> When GHC tells me that the type of something is "((,), a0)" what does the comma mean?
14:14:44 <Maxdaman1us> päästä in Finnish is from the head.
14:14:44 <johnw> it's a pair of a tupling function and a value
14:14:47 <Maxdaman1us> I think.
14:14:48 <mniip> orion, that doesn't seem like a valid type
14:15:01 <johnw> oh, as a type that's weird
14:16:03 <mniip> :t holesOf traverse
14:16:04 <lambdabot> Traversable t => t b -> [Control.Lens.Internal.Context.Pretext (->) b b (t b)]
14:16:15 <mniip> well
14:16:18 <johnw> the type isn't very elucidating in this case :)
14:16:39 <edwardk> holdsOf traverse gives back a list of one-hole contexts of the original list
14:16:43 <orion> "Actual type: Maybe (Descriptor c d ((,) a0) ()) -> HandshakeState c d"
14:17:02 <edwardk> or rather, it gives back a list of versions of the original structure, each with a different element focused
14:17:19 <Gurkenglas> Kinda looks like it should be "Traversable t => t b -> t (Control.Lens.Internal.Context.Pretext (->) b b (t b))"
14:17:32 <edwardk> Gurkenglas: that would be ideal but doesn't work for all traversals
14:17:49 <mniip> edwardk, so wait, it's not a lens
14:17:51 <edwardk> there is a scarier version of this that can be built using Magma
14:17:53 <mniip> it's a lens bound to an object
14:18:11 <Gurkenglas> A more restricted class than Traversable for which that works?
14:18:12 <mniip> edwardk, oh by the way, I have a challenge for you
14:18:18 <edwardk> Pretext is basically lens applied to the second argument
14:18:41 <edwardk> :t Pretext
14:18:45 <lambdabot> Not in scope: data constructor ‘Pretext’
14:18:48 <edwardk> :t Control.Lens.Internal.Context.Pretext
14:18:51 <lambdabot> (forall (f :: * -> *). Functor f => p a (f b) -> f t) -> Control.Lens.Internal.Context.Pretext p a b t
14:19:24 <mniip> edwardk, given kind E = L | R, implement foo :: forall (e :: E). C L -> C R ->  C e
14:19:27 <edwardk> s -> p a (f b) -> f t      is a flipped optic
14:19:35 <Gurkenglas> (Why does it need to say (f :: * -> *) when Functor f already fixes that?)
14:19:35 <jophish_> gdsx: Do you remember a problem you had in march about ld complaining about not being configured for sysroots in nixos?
14:19:36 <edwardk> what is C?
14:19:44 * hackagebot mongoDB 2.0.8 - Driver (client) for MongoDB, a free, scalable, fast, document  DBMS  https://hackage.haskell.org/package/mongoDB-2.0.8 (VictorDenisov)
14:19:57 <mniip> any particular data
14:20:14 <the_2nd> if I list ++ elem
14:20:19 <johnw> > map (peeks (*10)) (holesOf _head [1..10])
14:20:21 <lambdabot>  [[10,2,3,4,5,6,7,8,9,10]]
14:20:22 <mniip> it doesn't seem possible thanks to uniform polymorphism, but maybe there is some hack you could use?
14:20:27 <the_2nd> is elem head list or tail list? tail, right?
14:20:33 <the_2nd> or last
14:20:50 <edwardk> mniip: bit too scattered at the moment to be much use on it, but nothing leaps to mind pro or con
14:21:10 <mniip> edwardk, think GADT witnesses for typelevel nats
14:21:32 <mniip> and the useless KnownE typeclass mess that comes with it
14:21:56 <lyxia> the_2nd: Uh, [1,2,3] ++ [4] == [1,2,3,4]
14:22:12 <lyxia> the_2nd: Does that answer your question?
14:22:29 <jstimpfle> heya parser guys, what do you do if you want to integrate a (i guess Parsec) sub-parser with different or restricted state into a bigger parser?
14:22:29 <the_2nd> last [1,2,3,4] = 4?
14:22:41 <the_2nd> Im hunting a bug for hours, just making sure :D
14:22:46 <lyxia> the_2nd: that's correct
14:26:22 <mniip> edwardk, this seems impossible at the STG level, a closure doesn't know what type it has at runtime, and so a compiled thunk has no way to know which branch to evaluate to
14:26:30 <ackthet> is GHC really offically named "The Glorious Glasgow Haskell Compilation System"?
14:26:31 <mniip> but then again reflection, too, seems impossible
14:26:36 <ackthet> specifically... the glorious
14:27:04 <sinelaw> ackthet: why not
14:27:29 <ackthet> no reason, just seems silly, and additionally I'd never heard that before
14:27:40 <sinelaw> it's an old name
14:28:06 <ackthet> yeah i couldn't find any references to it on haskell.org
14:28:54 <Gurkenglas> Is there a lambdabot command that does Nothing with your input and gives no confirmation?
14:32:35 <ttt_fff> I'm reading https://ocharles.org.uk/blog/posts/2014-02-04-how-i-develop-with-nixos.html and am loooking for a minimal example on "how to setup a brand new nixos environment from scratch"
14:34:57 * hackagebot HaTeX 3.16.2.0 - The Haskell LaTeX library.  https://hackage.haskell.org/package/HaTeX-3.16.2.0 (DanielDiaz)
14:37:32 <orion> It's pretty much a recipe for disaster to create a monad transformer stack without defining the inner monad, right?
14:44:42 <johnw> orion: what do you mean by that?
14:44:49 <johnw> Monad m => ReaderT env m a is fine
14:46:59 <orion> johnw: How do you run such a thing if you don't know what 'm' is?
14:47:34 <johnw> the user will know who uses your stack
14:47:39 <johnw> you don't get to run it
14:50:23 <orion> hmm
14:50:52 <solfu> hello!
14:53:07 <johnw> part of what makes Monads wonderful is that you can thread computations through your program without being _able_ to know what they can do; it means your own code is by definition free of those computations
14:53:42 <johnw> thus, sometimes transformer stacks over any 'Monad m' is exactly what you want
14:57:45 <orion> johnw: I see. The reason I have 'm' in the first place is because some higher order computations I'm defining require IO, and most do not.
14:58:12 <orion> Rather than putting everything in IO, I'd rather be able to separate out only those parts that need it.
14:59:52 <johnw> sure, that makes sense
15:04:54 <ArisFr> Hi! I just can't seem to find how to get over this simple problem. I'm trying to import Control.Lens without the # operator: import Control.Lens hiding ((#))   --error: ghc: parse error on input ')'
15:06:43 <ArisFr> Anyone?
15:07:17 <voidzero> hiding (#) maybe?
15:07:24 <voidzero> i guess you tried that already
15:07:49 <ArisFr> Yes, with (#) I get Error:(10, 28) ghc: parse error on input ‘(#’
15:08:21 <johnw> ArisFr: which GHC are you using?
15:08:26 <ArisFr> Why is this so weird? I know with operators I usually go with parenthesied for and it works OK.
15:08:28 <johnw> your import line works fine for me
15:08:31 <ArisFr> johnw: 7.10.2
15:08:38 <johnw> hmm.. same here
15:08:47 <ArisFr> mmmm
15:10:04 <johnw> are you also using CPP?
15:10:22 <ArisFr> johnw: No
15:10:38 <ArisFr> johnw: Tht's what I just thought about
15:10:51 <ArisFr> johnw: I'll check with no extensions enabled
15:11:25 <voidzero> maybe just type the line again
15:11:51 <johnw> is it a real #, and not some weird Unicode character like OCTOTHORPE_OF_GRACE or something?
15:12:12 <johnw> (totally made up, don't go searching the Unicode spec...)
15:12:19 <ArisFr> johnw: I tried retyping, no dice
15:12:28 <johnw> huh
15:12:30 <ArisFr> johnw: no a simple #
15:12:50 <johnw> trying here in a project I'm building that uses lens.... yeah, it works fine
15:12:54 <johnw> import Control.Lens hiding ((#))
15:13:11 <ArisFr> This is very weird
15:13:13 <voidzero> HASHTAG_FOR_TWITTERS
15:13:14 <johnw> it is!
15:14:17 <voidzero> maybe there is a non displayed character somewhere that messes it up
15:14:48 <voidzero> maybe it's got bad line endings, dunno if that is a problem, but i mean dos versus unix
15:14:57 <ArisFr> voidzero: I don't think so because I just typed all of it. But I'll check and get back to you
15:15:44 <mniip> ArisFr, I suspect it's something to do with UnboxedTuples
15:16:01 <ArisFr> Ah, I did have those enabled.
15:16:09 <mniip> try ( # )
15:16:11 <voidzero> check that first then hehe
15:16:17 <voidzero> before retyping the entire file
15:16:52 <mniip> wait, are you using lens with unboxed tuples?
15:17:15 <ArisFr> yes :)
15:17:18 <ArisFr> why?
15:17:23 <mniip> that's my level of evil, and no one shall surpass me :v
15:17:46 <ArisFr> Oh! sorry. I just have the Extension enabled
15:18:02 <ArisFr> I'm not really mixing them IIRC
15:18:25 <ArisFr> Wait, no, I am :) In a very limited place though
15:18:44 <ArisFr> Is there something I should know about their interaction?
15:18:47 <voidzero> hail mniip, hail discordia
15:19:07 <mniip> voidzero, don't worry, inline assembly in haskell is coming soon
15:20:09 <voidzero> if working on an android port was not sucking up most of my time maybe i'd actually get to play with that :/
15:20:49 <ArisFr> OK, that did it. I had the UnboxedTuples extension enabled, which obviously removes # from the set of valid identifiers?
15:21:41 <mniip> no
15:21:49 <mniip> just have to keep it away from parentheses
15:22:04 <mniip> put a space or something
15:25:37 <ArisFr> dammit! This is the only thing that I didn't think of trying: import Control.Lens hiding (( # ))
15:25:59 <ArisFr> mniip: Thanks a bunch!
15:27:05 <mniip> hmm
15:27:38 <mniip> it seems like I have to construct a BCO# with a single bci_CCALL instruction pointing to a bogus function residing in a mmap-mprotected block
15:28:18 <mniip> that's much less fun than I expected
15:32:28 <P4Titan> Hello all, would the following be possible: type RayEquation = (Int -> Int -> Int -> Int)
15:32:28 <P4Titan>  
15:32:28 <P4Titan> data Ray = Ray (RayEquation Int Int) (RayEquation Int Int) (RayEquation Int Int)
15:32:48 <P4Titan> I want to make Ray take 3 args where each is RayEquation partially completed
15:33:46 <hexagoxel> i have a typeclass Foo (a :: *) with a large number of instances but only two possible semantics. Is there a way to reduce the redundancy?
15:34:09 <mniip> P4Titan, can't do that
15:34:18 <scshunt> hexagoxel: I can think of a terrible way
15:34:21 <P4Titan> How should I do it?
15:34:21 <mniip> just say 'Int -> Int'
15:34:25 <Cluzz> Hi, did anyone else experience a problem with cabal after upgrading to El Capitan and found a solution?
15:34:37 <hexagoxel> scshunt: does it involve UndecidableInstances?
15:34:39 <P4Titan> ok
15:34:54 <hexagoxel> scshunt: ah let me guess, TH?
15:34:55 <Cluzz> Says 'permission denied' with /usr/bin/ar
15:34:56 <P4Titan> Is there a way to prevent someone from passing anon RayEquation
15:35:07 <scshunt> no
15:35:12 <mniip> yeah, not using a type synonym
15:35:16 <hexagoxel> that would be terrible :D
15:35:30 <P4Titan> ok
15:35:37 <glguy_> Cluzz: That happens when you're using things compiled against the older unix library, you need things compiled against unix-2.7.1.0
15:35:40 <scshunt> data MyClassSemantics = Semantics1 | Semantics2
15:35:55 <scshunt> class MyClass t where semantics :: MyClassSemantics
15:36:02 <scshunt> and the rest is default implementations based on semantics
15:36:10 <mitochon> is there an easy way to split string on newline
15:36:10 <Cluzz> glguy_: I see.. i need a full reinstall then?
15:36:31 <glguy_> No, you need a cabal compiled against unix-2.7.1.0. A reinstall won't give you that
15:37:45 <glguy_> Cluzz: Someone posted such a binary in this github issue thread. I don't know off the top of my head if there's a better place to get one: https://github.com/ghcformacosx/ghc-dot-app/issues/41
15:37:55 <hexagoxel> scshunt: that won't work because the methods have constraints that depend on the instance :D
15:38:01 <hexagoxel> scshunt: i should have mentioned that :D
15:38:02 <glguy_> If you have another computer with OS X 10.10 still you can make one for yourself there
15:38:19 <Cluzz> glguy_: I'll try that, thanks
15:39:43 <hexagoxel> scshunt: oh, i may be wrong; it might be possible to embed the constraint in the Semantics data.. one sec
15:40:51 <glguy_> mitochon: The 'lines' function splits a String on newlines
15:41:04 <mitochon> glguy thanks!
15:47:37 <hexagoxel> scshunt: class Foo p where { type Constr p :: Constraint; foo :: Constr p => p -> Int }
15:47:51 <hexagoxel> scshunt: do you see a way too make your solution work for this?
15:48:11 <scshunt> hexagoxel: I'm not sure what you're trying to do.
15:48:12 <scshunt> at all.
15:49:18 <Cluzz> glguy_: I've replaced my cabal with a new binary but it doesn't seem to solve the problem :/
15:49:35 <emmruld> Hi guys, I'm pretty new to Haskell--I've written a function that takes two lists of numbers (think two n-dimensional points) and averages them to produce a third list (the mid-point).  Here's the paste: http://pastebin.com/TtM65AkJ.  My question is, is there a simpler way to write line 13?  I feel like there is that I'm missing.
15:49:56 <emmruld> Some way to write it so I'm not using fst and snd maybe?
15:51:42 <Cluzz> emmruld: Is there a specific reason you want to keep them in a tuple?
15:51:50 <glguy_> Cluzz: You'll have to give more information, then. There are other ways for you to be trying to use the older unix library and cause that problem
15:52:33 <emmruld> Cluzz: The tuple, in `averageList` is used for the `average` function
15:52:37 <emmruld> intended for streaming
15:53:16 <hexagoxel> scshunt: i have the above class, and all instances are either of the form `instance Foo x where { type Constr x = X; foo = foo1 }` or of the form `instance Foo x where { type Constr x = Y; foo = foo2 }`.
15:53:47 <hardmath123> Does Data.Map keep track of insertion-order somehow? I'm using Data.Map for substitutions, but these substitutions might be recursive and so need to be applied in the right order.
15:53:54 <hexagoxel> this is still simplified; there are more members, and i want to avoid the redundancy of writing out all the instances.
15:54:07 <glguy_> hardmath123: No, it doesn't keep track of insertion order
15:54:11 <hardmath123> :-(
15:54:46 <glguy_> ;_;
15:55:13 <MarcelineVQ> :'<
15:55:23 <Cluzz> glguy_: I've disabled rootless, and i've relocated everything from my user root to /usr/local/share/cabal. i've followed https://github.com/haskell/cabal/issues/2653 and http://www.volkerschatz.com/haskell/glocabal.html
15:55:49 <glguy_> Cluzz: What are you actually trying to do when you get the error?
15:56:12 <Cluzz> glguy_: cabal install random
15:56:32 <glguy_> With which ghc?
15:56:41 <Cluzz> glguy_: "cabal: /usr/bin/ar: permission denied"
15:57:13 <ReinH> Cluzz: something is very wrong with your environment
15:57:37 <Cluzz> glguy_: ghc 7.10.2
15:57:49 <Cluzz> ReinH: what could that be?
15:58:01 <hexagoxel> scshunt: maybe this question is too complex for irc (and my simplications might not help), sorry, i will stop bothering you :)
15:59:28 <glguy_> Cluzz: Can you paste the output of 'ghc-pkg list' to lpaste.net ?
15:59:37 <Cluzz> glguy_: sure, sec
15:59:39 <emmruld> Is there a way to ensure that this is computed in a parallel manner? http://lpaste.net/142723
16:00:23 <Cluzz> glguy_: http://lpaste.net/142726
16:00:51 <hardmath123> glguy_: is there an ordered version of Data.Map? I'd use [(KeyT, ValueT)] but I'd rather not re-implement `insert`, `member`, etc. if they're built-in somewhere. :)
16:01:11 <glguy_> Cluzz: and you have no user packages? Just global ones?
16:01:30 <Cluzz> glguy_: AFAIK
16:01:39 <barrucadu> hardmath123: If your key type is hashable, there's unordered-containers
16:01:49 <barrucadu> Wait, misread
16:02:08 <barrucadu> An *ordered* version of Data.Map? Data.Map already has Ord constraints on everything
16:02:18 <glguy_> Cluzz: and the version of cabal people said that works on the github ticket didn't work for you?
16:02:33 <Cluzz> glguy_: it didn't work, no
16:03:25 <Cluzz> glguy_: i've replaced the old one with the new one, ran the command, no result
16:05:52 <hardmath123> barrucadu: as in, it "remembers" the order in which I put things in. Maybe a stack-ish data type?
16:09:46 <glguy_> Cluzz: I don't know. Solving that for me as only involved installing Cabal against the new unix, possibly through manual Setup.hs invocations in the case of GHC-7.8.4
16:10:05 * glguy_ heads out
16:14:41 <pavonia> hardmath123: You could use two maps (Map Time Key and Map Key Value) if you need efficent lookup of time and key
16:16:31 <ttt_fff> wow, nixos per project defaullt.nix for handling haskell is soooooooo clean
16:16:39 <ttt_fff> too bad haskell platform was not based on nix
16:16:43 <ttt_fff> would have saved me so much cabal hell time
16:20:03 * hackagebot plot 0.2.3.5 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  https://hackage.haskell.org/package/plot-0.2.3.5 (VivianMcPhail)
16:24:58 <dgpratt> a basic question, suppose I see a type "Foo" somewhere in a source file in a project, what's the easiest way to figure out where/how that is defined?
16:25:19 <dgpratt> to be clear, I mean a reference of "Foo", not a definition
16:25:32 <heatsink> You could use the info command in ghci
16:25:34 <heatsink> :i Foo
16:26:03 <heatsink> After importing the module, of course
16:26:06 <dgpratt> heatsink, it seems  I'd need to know the  module in many cases, no?
16:26:12 <dgpratt> right
16:26:22 <dgpratt> so what if I don't know the module?
16:27:01 <dgpratt> is there any such thing as a project-local hoogle database?
16:27:17 <heatsink> I don't know of a way to do that
16:32:16 <P4Titan> Hello all, if I have data Object = Sphere ..., Cube ..., Plane ..., how can I create a class on Object that has definitions of a given function per data type
16:32:30 <P4Titan> ie Surface area
16:35:31 <bergey> If sphere & Cube are constructors of Object, every function that takes an Object should handle all the constructors.
16:36:52 <bergey> No reason to involve a type class.
16:39:36 <Hafydd> What is the typical surface area of a plane?
16:40:00 <P4Titan> 2 times the area
16:40:03 <P4Titan> I got it working
16:40:03 <HairyDude> :t Data.Attoparsec.Text.parse Ap.space
16:40:04 <lambdabot> Not in scope: ‘Ap.space’
16:40:09 <HairyDude> ops
16:40:19 <HairyDude> :t Data.Attoparsec.Text.parse Data.Attoparsec.Text.space
16:40:20 <lambdabot> Data.Text.Internal.Text -> attoparsec-0.13.0.1:Data.Attoparsec.Text.Internal.Result Char
16:40:25 <Hafydd> What is the typical area of a plane?
16:40:36 <P4Titan> I took out data Object and made object into a class where each 3d object (sphere, cube, plane) is its own data type
16:40:40 <HairyDude> :t Data.Attoparsec.Text.parse Data.Attoparsec.Text.space "\r"
16:40:41 <lambdabot>     Couldn't match expected type ‘Data.Text.Internal.Text’
16:40:41 <lambdabot>                 with actual type ‘[Char]’
16:40:41 <lambdabot>     In the second argument of ‘attoparsec-0.13.0.1:Data.Attoparsec.Text.Internal.parse’, namely
16:40:47 <P4Titan> I envision a finite plane
16:40:52 <P4Titan> like a sheet of paper
16:40:55 <HairyDude> :t Data.Attoparsec.Text.parse Data.Attoparsec.Text.space (Data.Text.pack "\r")
16:40:56 <lambdabot> attoparsec-0.13.0.1:Data.Attoparsec.Text.Internal.Result Char
16:41:01 <Hafydd> A finite plane? Interesting. Is that a rectangle?
16:41:08 <P4Titan> sure
16:41:23 <P4Titan> sarcasm?
16:41:41 <HairyDude> argh, I forgot I had stderr redirected to another terminal, so I was seeing no error and getting confused :/
16:41:50 <Hafydd> Not as such.
16:43:02 <Hafydd> (But "rectangle" probably is a more appropriate name for that geometric figure. Would you also call a circular disk a "plane"?)
16:44:25 <P4Titan> no
16:44:32 <P4Titan> I'll fix that regardless
16:45:08 <Hafydd> P4Titan: what was the reason for making them into different types?
16:47:05 <P4Titan> to be able to implement Object on each of them where each had diff functions for surface area
16:47:12 <Hafydd> It seems like that will cause you problems when you want to dynamically hold a certain shape (you'd have to use something existentially quantified types, when a much simpler solution is to just have them inhabit the same type).
16:47:28 <Hafydd> P4Titan: why not just pattern match on the constructor of Object?
16:48:00 <P4Titan> i should do that
16:48:03 <P4Titan> thanks
16:48:42 <orion> In a record where all fields have the same type, is it possible to write a function which takes as a parameter a specific field to be updated?
16:53:57 <awpr> orion: the solution to the general form of that problem is the lens library.  but you could also just make a data type with N values and pattern match on it to choose which field to update
16:54:51 <orion> How elegant is the solution with lens, in your opinion?
17:00:41 <tpsinnem> any 'machines' library users? i'm curious if anyone has played with anything like an "unfoldPlan :: s -> (s -> Plan k o s) -> Machine k o"?
17:01:20 <tpsinnem> well, assuming that type makes sense in the first place, which i'm guessing it should
17:07:13 <awpr> orion: I think the lens solution would be the way to go, but it can be a bit hard to learn if you're not already familiar.  lots of big types with lots of type variables and constraints.
17:09:51 <orion> awpr: I see. I mean, it's a really simple use case, and I only need to do it once in my application. I don't already know lens, so it's probably a good idea to learn.
17:11:18 <orion> I have the wiki up now. What operator(s) do you think I should focus on? All I need to do is modify my function so that it can update any record in a field where all the types of the fields are identical.
17:11:35 <xDante> Guys I am thinking of taking up haskell what would you guys say is great about the language, Like compared to others?
17:11:37 <nolraiU> @pl (\ n -> fmap (Par n) (genPartition n))
17:11:37 <lambdabot> liftM2 fmap Par genPartition
17:11:57 <nolraiU> Wow a actually not totally terible pl suggestions.
17:12:34 <arkeet> or use liftA2
17:12:36 <arkeet> or
17:12:42 <arkeet> fmap <$> Par <*> genPartition
17:14:24 <jmcarthur> :t liftA2 fmap
17:14:25 <lambdabot> (Functor f1, Applicative f) => f (a -> b) -> f (f1 a) -> f (f1 b)
17:43:33 <dgpratt> would anyone care to take on the challenge of explaining the purpose of MonadTransControl and MonadBaseControl to me?
17:44:14 <dgpratt> nvm for the moment, sorry -- found a different resource
17:53:37 <kirill`> Where is a good place to ask questions about cabal issues?
18:09:48 <Stratege> Has anyone here managed to install fltkhs and if so would be willing to share what arcane incantations they used for that?
18:18:29 <ttt_fff_> anyone know how to fix this? https://gist.github.com/anonymous/94ac7ab9c82dfb06308b <-- standard nix install; trying to get snap-extras
18:22:32 <liammcdermott> I'm working on: https://wiki.haskell.org/Roll_your_own_IRC_bot and would like to update a timestamp field in the Bot type every time the bot says something in IRC, would that be a job for the State monad?
18:23:32 <liammcdermott> Similar to what's done in section 5 'Extending the bot' except I need to change the state not just read it.
18:23:54 <liammcdermott> Any guidance would be very welcome, please!
18:24:42 <julianleviston> liammcdermott: the State monad is more for local state than “thread persistent” state, from what I know. You may what the ST Monad. It’s probably beyond me, but hope that helps in some way.
18:25:14 <d-snp_> "A Foldable type is also a container. The class does not require Functor superclass in order to allow containers like Set or StorableVector"
18:25:36 <d-snp_> does this mean there's no mathematical reason for foldable to not be functor?
18:26:32 <P4Titan> Hello all, what would be the best way to take the minimum of a list and return Just if there is a min or Nothing if the list was empty?
18:27:17 <d-snp_> P4Titan: I'd make a small helper function, maybeMin [] = Nothing, maybeMin xs = min xs
18:27:29 <d-snp_> eh maybeMin xs = Just $ min xs
18:27:38 <liammcdermott> Huh, ST Monad eh? I'll look into it, thanks for the help (even if it might be beyond you!) julianleviston 
18:27:54 <julianleviston> :t maybe
18:27:55 <lambdabot> b -> (a -> b) -> Maybe a -> b
18:28:26 <P4Titan> Is there a "fancier" way to do it
18:28:38 <julianleviston> P4Titan: isn’t maybe fancy enough for you? :)
18:28:44 <julianleviston> P4Titan: meaning the function?
18:28:49 <P4Titan> How would I use maybe?
18:29:00 <julianleviston> P4Titan: do you understand the type signature above?
18:29:17 <P4Titan> to return Nothing on an empty list and Just minimum on a non-null list
18:29:21 <P4Titan> I do understand the signature
18:29:24 <Gurkenglas> P4Titan, https://hackage.haskell.org/package/safe-0.3.9/docs/Safe.html#v:minimumMay
18:29:38 <julianleviston> P4Titan: ooh listen to Gurkenglas  :)
18:29:49 <P4Titan> is that in prelude or something?
18:29:55 <Gurkenglas> no
18:30:13 <P4Titan> Is it its own module?
18:30:27 <d-snp_> it's in the safe module
18:30:28 <julianleviston> P4Titan: in the safe package, by the look of it.
18:30:28 <Gurkenglas> It's the safe package, not in base, but I feel it ought to be
18:30:52 <P4Titan> So I should sandbox my dir and install it then
18:30:59 <Gurkenglas> (Hmm maybe better https://hackage.haskell.org/package/safe-0.3.9/docs/Safe-Foldable.html#v:minimumMay from the Foldable submodule because it's more general)
18:31:05 <d-snp_> :\
18:31:11 <P4Titan> How would I use the maybe function on an empty list
18:31:17 <P4Titan> as julianleviston mentioned
18:32:24 <julianleviston> P4Titan: I just realised, maybe is probably not that useful here.
18:33:09 <julianleviston> P4Titan: maybe is actually for going the other way (unwrapping to a nice default value from a Maybe)
18:33:11 <d-snp_> P4Titan: I recognize you're trying to learn and you like Haskell's cool features, but if you write that 2 line helper function, any Haskeller would understand it
18:33:26 <julianleviston> P4Titan: ^ what d-snp_ says
18:33:27 <P4Titan> ye
18:33:29 <d-snp_> regardless of their level of proficiency, imo that's more important than some oneliner
18:35:05 <julianleviston> Gurkenglas: strange that Data.Maybe doesn’t have a “toMaybe” function… 
18:35:20 <d-snp_> in my experience the secret to being productive in haskell is leaving all the fancy features to the library writers, and making your own code be just basic FP-101 style
18:35:27 <Gurkenglas> julianleviston, what type do you want?
18:35:31 <julianleviston> d-snp_: yeah, good point.
18:35:49 <julianleviston> d-snp_: fmap is only really useful once you can implement it, for example
18:36:21 <julianleviston> Gurkenglas: (a -> b) -> a -> Maybe b
18:36:26 <julianleviston> Gurkenglas: I guess.
18:36:31 <julianleviston> Gurkenglas: I’ll hoogle it
18:36:33 <Gurkenglas> :t (Just .)
18:36:34 <lambdabot> (a -> a1) -> a -> Maybe a1
18:36:38 <d-snp_> :P
18:36:55 <julianleviston> oops
18:36:57 <julianleviston> that’s not what I want
18:37:07 <julianleviston> (a -> Bool) -> a -> Maybe a
18:37:19 <Gurkenglas> Jackpot. I also want that in base.
18:37:44 <Gurkenglas> :exf "(a -> Bool) -> a -> Maybe a"
18:37:44 <exferenceBot> \ f1 -> mfilter f1 . pure
18:37:45 <d-snp_> P4Titan would need something like a -> (a -> Bool) -> (a -> b) -> Maybe b 
18:38:20 <P4Titan> I already got it working with my own minimumMay function
18:38:28 <julianleviston> P4Titan: beautiful. :)
18:38:58 <Gurkenglas> d-snp_, nah, that can be assembled out of what we want in base and fmap
18:39:01 <julianleviston> d-snp_:  oh yeah, the function on it. lol. tricky.
18:39:34 <julianleviston> d-snp_: “minimum” in this case, I mean.
18:39:40 <d-snp_> makesafe in guard f | guard in -> Just $ f a 
18:39:51 <d-snp_>     | otherwise = Nothing
18:40:12 <d-snp_> eh jeez, Just $ f in
18:41:20 <d-snp_> and then minimumMay in = makesafe in (not.empty) min
18:41:21 <d-snp_> :P
18:41:41 <d-snp_> obviously in should've been the last argument
18:41:42 <julianleviston> :t empty
18:41:43 <lambdabot> Alternative f => f a
18:41:48 <julianleviston> :t not.empty
18:41:49 <lambdabot> Alternative ((->) a) => a -> Bool
18:43:02 <julianleviston> d-snp_: what’s min there? isn’t it a bad idea to call your var in?
18:43:09 <julianleviston> d-snp_: min is the min fn ?
18:43:19 <julianleviston> :t makesafe
18:43:20 <lambdabot> Not in scope: ‘makesafe’
18:43:25 <d-snp_> I'm making all kinds of Ruby assumptions here :P
18:43:33 <julianleviston> d-snp_: lol
18:43:39 <d-snp_> replace empty by null apparently
18:43:42 <julianleviston> d-snp_: minimum might be what yoy want
18:43:49 <julianleviston> d-snp_: what’s null?
18:43:55 <d-snp_> :t null
18:43:56 <lambdabot> Foldable t => t a -> Bool
18:44:05 <d-snp_> it's Haskell's empty ;)
18:44:17 <julianleviston> oh… but there is an empty, isn’t there?
18:44:27 <julianleviston> :t empty
18:44:28 <d-snp_> there doesn't seem to be.. at least not in base
18:44:28 <Gurkenglas> :t ord
18:44:29 <lambdabot> Alternative f => f a
18:44:29 <lambdabot> Char -> Int
18:44:35 <Gurkenglas> Whoops, this isn't a query.
18:45:05 <hardmath123> So, uh, how do people debug haskell? I'm used to littering print statements all over the place...
18:45:13 <Stratege> ghci, mostly
18:45:22 <julianleviston> hardmath123: usually I use the type checker and write tiny functions.
18:45:24 <d-snp_> hardmath123: I litter print statements all over the place :P
18:45:34 <julianleviston> hardmath123: then there’s the Debug.Trace thingie :)
18:45:39 <Stratege> tiny testable functions + ghci help a ton.
18:45:53 <Stratege> and when those don't help ... enjoy Debug.Trace in the presence of laziness xD
18:45:57 <julianleviston> hardmath123: quickcheck !!!! :)
18:46:14 <d-snp_> yes, it really is awful
18:46:22 <julianleviston> d-snp_: what’s awful?
18:46:31 <d-snp_> debug.trace in the presence of laziness
18:46:33 <julianleviston> d-snp_: oh lazy debug trace
18:46:51 <Stratege> and if you know where the issue is ... a bit of equational reasoning can go a long way for figuring out what's wrong.
18:47:46 <d-snp_> I'm writing a C compiler in Haskell and I'm constantly using Debug.Trace, and often it's very hard to figure out where exactly something goes wrong
18:47:57 <d-snp_> I got Haskell to dump stacktraces though, that helped
18:47:59 <Stratege> tbh I'd love to have some ghc plugin or something which could visually show me the code transformation steps that happen by evaluating
18:51:42 <d-snp_> so eh.. anyone know why Foldable isn't Functor?
18:52:30 <julianleviston> d-snp_:  Functor is for mapping
18:52:50 <julianleviston> d-snp_: Foldable is for reducing structure and data into one single item
18:52:58 <d-snp_> apparently this is the reason: https://www.fpcomplete.com/user/chad/snippets/random-code-snippets/set-is-not-a-functor
18:52:59 <julianleviston> d-snp_:  aren’t they different?
18:53:22 <d-snp_> well apparently they are, I just don't fully understand why
18:53:45 <julianleviston> d-snp_: Functor is structure-preserving
18:53:55 <julianleviston> d-snp_: I mean, fmap is.
18:54:07 <julianleviston> d-snp_: but fold “destroys” structure, doesn’t it?
18:54:17 <julianleviston> d-snp_: depending on the shape of the structure, of course.
18:54:21 <julianleviston> d-snp_: “usually”.
18:54:34 <julianleviston> d-snp_: I guess I should say, it can.
18:55:14 <julianleviston> d-snp_: I’m probably deeply wrong on some level :)
18:55:15 <Gurkenglas> It does. Sometimes, you can pass reconstructors to it.
18:55:16 <d-snp_> well yeah, but why aren't fmap and fold in the same typeclass
18:55:27 <julianleviston> d-snp_: because they’re different
18:55:36 <Stratege> julianleviston to my knowledge it's impossible to recover fmap from foldable, so that suggests to me that they are different
18:55:37 <julianleviston> d-snp_: what do you think a typeclass is?
18:55:41 <Gurkenglas> d-snp_, (a ->) is a Functor, but not foldable
18:55:57 <julianleviston> Gurkenglas: I think he might be coming from OOP.
18:56:00 <Stratege> d-snp_ why should they be in the same typeclass? what is the benefit or reason for that?
18:56:11 <julianleviston> Gurkenglas: and so, have a distorted perspective of what “typeclass” means.
18:56:21 <d-snp_> no I don't have a distorted perspective
18:56:28 <julianleviston> d-snp_: oh ok, sorry.
18:56:42 <d-snp_> I just have trouble coming up with a datastructure that's not foldable but is a functor
18:57:11 <Gurkenglas> d-snp_, that's because you're limiting yourself to data structures :D
18:57:24 <julianleviston> d-snp_: what about a function?
18:57:53 <d-snp_> sorry I meant that is foldable but not a functor
18:58:09 <d-snp_> jeez all this set theory stuff gets my head spinning :P
18:58:25 <Gurkenglas> I'll do you one better, try coming up with a Foldable that isn't Traversable
18:58:38 <d-snp_> Gurkenglas: that's exactly the problem I'm thinking about :P
18:58:44 <Stratege> d-snp_ Set is foldable but not a Functor
18:58:56 <d-snp_> Stratege: yes :D
18:59:00 <d-snp_> now we're on the same page
18:59:05 <d-snp_> so... why :P
18:59:12 <Stratege> why Set isn't a Functor?
18:59:16 <d-snp_> yes
18:59:18 <julianleviston> d-snp_: so why is set foldable but not a functor?
18:59:28 <Stratege> because you can not implement fmap in a way that preserves both the functor laws and the way set is supposed to work
18:59:31 <Stratege> functor laws:
18:59:34 <Stratege> fmap id = id
18:59:39 <Stratege> fmap f . fmap g = fmap (f . g)
19:00:31 <julianleviston> Stratege: but you *can* map over a set, can’t you? I mean, a set is unordered, right?
19:00:50 <stiell> Is the HPC overlay language properly documented anywhere?
19:01:39 <julianleviston> Stratege: can’t you actually write map with fold? I guess this is what d-snp_ is wondering about heh :)
19:01:40 <obadz> julianleviston: you can write a function that maps over a set. it just doens't obbey the law Stratege laid out
19:01:56 <obadz> so it isn't a legal instance of Functor
19:01:59 <Stratege> julianleviston you can write map with fold but I don't see how you could write fmap with generalized fold.
19:02:03 <julianleviston> obadz: so Functor isn’t actually about mapping. THAT is why people say that a lot
19:02:27 <Gurkenglas> Should there be an Eq law that anything said to be equal must be indistinguishable?
19:02:45 <obadz> julianleviston: it's about mapping where mapping is defined such that it obeys that law
19:02:56 <Stratege> Gurkenglas that comment is borderline trolling xD
19:02:58 <julianleviston> obadz: I wonder why.
19:03:12 <Stratege> julianleviston Cat Theory :D
19:03:25 <julianleviston> Stratege: that’s not at answer, really is it? :) 
19:03:56 <Gurkenglas> Complexity! Emergence!
19:03:58 <d-snp_> julianleviston: because it's the law ;)
19:04:23 <Gurkenglas> (Now *that* was borderline trolling.)
19:04:29 <obadz> I'm not exactly sure, but it's possible that now, or in the future, a compiler might decide to optimize by rewriting fmap f . fmap g as fmap (f . g) ?
19:04:30 <Stratege> Gurkenglas xD
19:04:43 <Stratege> obadz yeah we already have that, rewrite rules ftw.
19:04:56 <julianleviston> Stratege: but it means you’d have to write your own mapping function over non-Functor objects, right?
19:05:01 <obadz> same goes for monadic laws, you can't write a valid instance, but then I think do notation doesn't do what you'd expect?
19:05:27 <Stratege> julianleviston how would you map over things that aren't functors?
19:05:59 <julianleviston> Stratege: I gunno ! :) haha I probably shouldn’t be a part of this conversation, having never seen a Set before in Haskell
19:06:00 <obadz> julianleviston: I'm sure there's a map-equivalent function in the set library
19:06:24 <julianleviston> obadz: so you can’t do a mapping kinda thing over a set … weird.
19:06:24 <Stratege> someone linked this: https://www.fpcomplete.com/user/chad/snippets/random-code-snippets/set-is-not-a-functor earlier
19:06:25 <Gurkenglas> :t S.map
19:06:25 <lambdabot> Ord b => (a -> b) -> S.Set a -> S.Set b
19:06:35 <Stratege> which shows that yes we have map and yes it is awful.
19:06:43 <julianleviston> obadz: I guess you could just pull it out into a list, then do your evil mapping work :)
19:07:03 <Gurkenglas> At least it is lawful.
19:07:18 <Gurkenglas> Alright alright I'm leaving.
19:07:22 <d-snp_> so why is a Set not traversable? it's demonstrably not a Functor, so it can't be Traversable, but intuitively you can traverse a set right?
19:07:22 <obadz> julianleviston: sure, that's one way..
19:07:48 <julianleviston> d-snp_: where do you start?
19:07:56 <julianleviston> d-snp_: sets have no beginning or ending do they?
19:08:13 <d-snp_> hmm
19:08:24 <julianleviston> d-snp_: assuming I understand what they are correctly
19:09:58 <nshepperd> d-snp_: they're Foldable, so you can do traverse_ etc
19:10:10 <d-snp_> :t traverse
19:10:11 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
19:10:18 <d-snp_> :t traverse_
19:10:19 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
19:10:23 <d-snp_> right :D
19:10:50 <julianleviston> nshepperd: so you pick an item at random until the set’s empty?
19:11:03 <julianleviston> nshepperd: or rather, until you haven’t touched each item?
19:11:09 <nshepperd> julianleviston: Data.Set traverses in ascending order
19:11:36 <julianleviston> nshepperd: which is another way of doing that. Obviously it’s less overhead than random :)
19:11:38 <d-snp_> I actually do get it now, the difference between foldable and traversable, there's simply more meaning behind the names than they intuit
19:11:55 <julianleviston> d-snp_: thanks for asking these questions! :)
19:12:08 <d-snp_> thanks for helping me understand :D
19:12:11 <julianleviston> d-snp_: it’s very helpful to think about this
19:12:18 <julianleviston> d-snp_: haha you know more about it than me! :)
19:12:58 <Stratege> d-snp_ that's the problem with naming things something that isn't "monad" and the like - people have an intuition what it might mean ^^
19:13:34 <julianleviston> Stratege: astute.
19:13:40 <d-snp_> you should thank erik meijer for raising the issue julianleviston :P his tweet made me curious as to why 'and' works on Foldable instead of Traversable
19:14:07 <julianleviston> d-snp_: that seems pretty obvious to me, though I don’t know why.
19:14:08 <Stratege> (and of course the problem with naming things monad and the like is that people don't have an intuition what they might mean ^^)
19:14:20 <d-snp_> now I understand why, I understand less as why he's so mad about it
19:14:25 <julianleviston> d-snp_: and is a folding operation. 
19:14:42 <julianleviston> d-snp_: I don’t really understand what traversable is tho… never looked it.
19:14:56 <Hafydd> d-snp_: you don't need applicative traversal to implement and, so why would it depend on Traversable?
19:14:59 <d-snp_> just a name that's less connected to the fold operation
19:15:23 <julianleviston> Hafydd: is applicative traversal a kind of folding?
19:15:31 <d-snp_> Hafydd: I get it, but Erik Meijer doesn't get it, or doesn't want to get it, which seems strange :P
19:16:15 <julianleviston> Hafydd: and… does traversable necessitate a particular *way* of traversing, necessarily?
19:16:16 <Hafydd> julianleviston: applicative traversal is what Traversable does: modifying a structure by sequencing some applicative actions parameterised by its elements. It's sort of a combination of folding and mapping.
19:16:32 <Hafydd> julianleviston: yes, Traversable does require a certain order.
19:17:01 <Hafydd> d-snp_: which is this Twitter post?
19:17:04 <julianleviston> Hafydd:  but isn’t that what foldable (can) do?
19:17:16 <d-snp_> https://www.reddit.com/r/haskell/comments/3o8rff/fp101x_using_hugs_because_ghc_changes_too_much/
19:17:25 <julianleviston> Hafydd: I’m using intuition instead of knowledge here sorry… I should look up what the difference between traversable and foldable is.
19:17:26 <d-snp_> Hafydd: -^ 
19:17:33 <julianleviston> Hafydd: I’d assumed traversable would be structure preserving for some reason.
19:17:33 <Hafydd> julianleviston: Foldable can't map each element of a binary tree, for example.
19:17:52 <julianleviston> Hafydd: I don’t understand why… hmmm
19:17:54 <Hafydd> julianleviston: yes, it is structure-preserving, idneed.
19:18:09 <d-snp_> he's angry because GHC changes so much, apparently the and being Foldable is a new constraint that's backwards incompatible
19:18:13 <Hafydd> A binary tree has structure beyond any given traversal of its nodes; that would be retained by a Traversal.
19:18:25 <bitemyapp> d-snp_: FSDO backwards incompatible
19:18:28 <bitemyapp> @ty and
19:18:29 <lambdabot> Foldable t => t Bool -> Bool
19:18:37 <bitemyapp> @ty and :: [Bool] -> Bool
19:18:38 <lambdabot> [Bool] -> Bool
19:18:48 <d-snp_> fsdo?
19:18:54 <bitemyapp> for some definition of
19:19:25 <julianleviston> I guess part of the problem of Haskell is that it’s not finished yet…
19:19:52 <bitemyapp> finished is a value judgment
19:19:54 <julianleviston> so we’re subject to the “upgrade problem” that all software is… which might just be time.
19:19:59 <bitemyapp> people that think their language can't be improved shouldn't be trusted.
19:20:02 <d-snp_> right, I don't know exactly how it broke his code, but he probably got angry in general, at the whole unintuitiveness of functor vs foldable
19:20:06 <Stratege> wouldn't finished mean "everyone stopped being interested in making the language better"?
19:20:10 <julianleviston> bitemyapp: no, it’s not. It means “able to change”
19:20:35 <julianleviston> Stratege: no, it’d mean “it’s done, like addition” :)
19:20:48 <julianleviston> Stratege: you can’t get a better or worse addition, it’s just like… addition :)
19:20:53 <Stratege> julianleviston 1. good luck with that for a language, 2. monoids
19:21:16 <bitemyapp> julianleviston: having polymorphic arithmetic without a performance penalty was novel to Haskell when it was introduced.
19:21:26 <julianleviston> Stratege: I wasn’t passing judgement or stipulating anything, I was just commenting that that problem is “very hard” and is going to annoy people inevitably.
19:21:29 <bitemyapp> julianleviston: if you use something like OCaml, there are different addition functions for different kinds of numbers.
19:21:34 <Stratege> d-snp_ he's the guy who used monads in C#, I'm guessing he's more annoyed at it making teaching more annoying.
19:21:46 <julianleviston> bitemyapp: I’m not talking about a computer program. I’m talking about mathematical addition.
19:21:48 <bitemyapp> julianleviston: then you get into PureScript where they've broken out the Num typeclass into a hierarchy of weaker and stronger abstractions.
19:21:52 <davean> Personally I find haskell the easiest to upgrade. Most changes are VERY clear in where they break stuff because of the safety (changing instances not so much) and fixes tend to be local
19:21:57 <julianleviston> bitemyapp: as an example of something “finished”.
19:22:14 <julianleviston> bitemyapp: yeah, they all have the “upgrade problem” too :)
19:23:05 <julianleviston> bitemyapp: to an extent, wherever you draw a distrinction that touches the non-platonic universe you end up with it, perhaps (I’m not entirely sure of that).
19:23:30 <julianleviston> bitemyapp: but it sure does *seem* like Haskell has the “upgrade problem” less.
19:24:05 <julianleviston> bitemyapp: and, if you use versioning, you can pretty much get around it… assuming you have sane package management.
19:24:26 <Stratege> on that note: wtb sane package management for haskell.
19:24:35 <bitemyapp> generally speaking, the people influencing the decisions on GHC and library APIs are thinking a lot harder and working more carefully than I've seen with any other language.
19:24:47 <julianleviston> bitemyapp: totally agree.
19:24:52 <bitemyapp> Stratege: I've been fine since cabal sandboxes came out in 2013, and things have verged on sublime with Stack.
19:25:41 <Stratege> bitemyapp cabal has just spat an completly incomprehensible error message at me "exit error 1" and stack refuses to operate since apparently the version of git that MinGW comes with is sorta broken.
19:25:53 <Stratege> so I now get to switch to a different git version and hope that helps.
19:26:06 <d-snp_> haha
19:26:26 <d-snp_> maybe you should upgrade your MinGW version to just running linux ;)
19:26:44 <Stratege> and I doubt that that fixes the root issues I have with installing fltkhs
19:27:13 <Stratege> d-snp_ honestly? I'm thinking about installing Linux just for that reason. But when I have to install a new OS to get things to work that's the opposite of user friendly. Or sane.
19:27:36 <d-snp_> definitely true
19:28:13 <bitemyapp> well, there are happy Stack+Windows users. Does sound like you need to upgrade your mingw install.
19:28:18 <MarcelineVQ> vm's are reasonably fast these days, certainly it's not a solution but consider it as an option for sanity
19:28:21 <bitemyapp> I'd do that before resorting to anything dramatic.
19:28:25 <d-snp_> unfortunately a side effect of the OSS community being so focused around posix-y OS'es that things like git are often wonky on Windows
19:28:39 <geekosaur> isn't there a fixed mingw for this?
19:28:41 <Stratege> bitemyapp I just installed MinGHC from scratch from the newest downloader, in the hopes that this will help with things.
19:28:48 <geekosaur> yes, moinghc
19:28:51 <geekosaur> er minghc
19:28:55 <gfixler> I've been using git on Windows for years without issue
19:28:59 <Stratege> which is supposed to come with a working set of tools...
19:29:10 <gfixler> anecdotal, of course
19:29:17 <bitemyapp> gfixler: some tools (Stack isn't alone in this) require newer versions of git.
19:29:26 <Stratege> gfixler oh my old version of git worked just fine, it's just that my path got changed to the new version so I have to change it back.
19:29:27 <bitemyapp> gfixler: I've run into this outside of windows or Haskell before.
19:29:35 <gfixler> bitemyapp: I think I have a new git at work on Windows - stack works nicely
19:30:10 * gfixler is not calling himself a happy Anything+Windows user
19:30:30 <d-snp_> perhaps it would've been better if stack depended on libgit instead of a shell git
19:30:42 <d-snp_> Cargo also uses libgit for exactly this reason
19:31:01 <d-snp_> (the package manager of Rust)
19:31:52 <bitemyapp> yeah I honestly think it's better to just embed a library than rely on an outside tool
19:32:02 <bitemyapp> but I'm uh...a bit obsessed with tools that "just work"
19:32:19 <Stratege> I love haskell ... but damn if the whole installing library thing isn't more often than not an annoying shot in the dark followed by a few hours of trying to get it to work.
19:32:48 <julianleviston> Stratege: I have a feeling it’ll get better.
19:32:55 <gfixler> I'm at sea when it requires other dependencies, and the install notes don't mention this
19:33:14 <gfixler> I'm not a C/C++ guy; I don't know about installing libwhateverdev, or figuring out that I need to
19:33:22 <julianleviston> d-snp_: sorry to revive a dead thread, but is set is traversable but not foldable? is that right?
19:34:12 <julianleviston> d-snp_: just reading Foldable. Man that typeclass is giddy funtimes! :)
19:34:23 <Stratege> julianleviston I do hope so, but as long as Haskell libraries regularly depend on libraries not written in Haskell I doubt it can get that much better
19:34:29 <julianleviston> d-snp_: I feel like Harry Potter “I **LOVE** magic” ;-)
19:34:33 <bitemyapp> Stratege: I install and use a lot of libraries, I think getting comfortable with Cabal helps a lot.
19:34:42 <bitemyapp> Stratege: Stack has made a lot of things ncier as well.
19:34:45 <bitemyapp> nicer*
19:36:04 <julianleviston> bitemyapp: I feel like Cabal is like… your super inappropriate annoying friend who knows all the hotties. 
19:36:28 <julianleviston> bitemyapp: they’re your friend, but you wish they’d be a bit nicer sometimes.
19:36:52 <Stratege> bitemyapp as long as it's libraries that don't have bindings to non-haskell libs it's decently fine, I'm comfortable enough with cabal to have all the haskell-only libraries that I desire. (even though I'm still a bit annoyed at sandboxes, probably need a decent tutorial again but eh, another time). But once I have to start mucking around with makefiles and the like and haskell libs that depend on such stuff? No fun is had.
19:37:33 <julianleviston> Stratege: is haskell not self-describing? 
19:37:44 <julianleviston> Stratege: in the sense that our build tools are built in Haskell?
19:38:01 <julianleviston> Stratege: sorry I should have said self-bootstrapped.
19:38:08 <bitemyapp> Stratege: hrm, yeah, non-Haskell stuff can be annoying.
19:38:16 <bitemyapp> some more or less than others.
19:38:30 <bitemyapp> julianleviston: Cabal, cabal-install, and Stack are all written in Haskell.
19:38:33 <Stratege> julianleviston a lot of the libraries on haskell are just bindings to C or C++ libraries. Which are really annoying to get working. Even more so when you have to also get them working with the library that binds to them.
19:38:45 <bitemyapp> julianleviston: Haskellers tend to be linguistically chauvinistic, you'd have a hard time finding anything for Haskell that isn't in Haskell.
19:39:01 <bitemyapp> sometimes, even when writing things like a Python bytecode compiler, they'll still write it in Haskell.
19:39:15 <bitemyapp> the Perl 6 prototypes were in Haskell
19:39:21 <bitemyapp> (pugs)
19:41:02 <julianleviston> bitemyapp: so why haven’t we written a C to Haskell translator yet? (jokes!) ;-)
19:42:06 <davean> Stratege: I'd counter that I'm pretty sure it is only a small-ish percentage of packages that are just C bindings
19:42:19 <julianleviston> bitemyapp: yeah, one of my old Smalltalker friends used to write Java in Smalltalk… it was pretty funny… but it was much faster than writing java, honestly.
19:42:28 <davean> Stratege: I mean, I think I only have to isntall 230 packages in addition to ubuntu base to compile most of hackage
19:43:35 <Stratege> davean fair enough, I suppose it's just that a lot of the packages I stumble across and consider interesting (or just those I remember maybe, because of the pain?) are C bindings.
19:45:38 <davean> Stratege: there definately *significant* packages
19:45:56 <davean> Stratege: and like "unix" wouldn't require a package install
19:46:03 <davean> as thats from base
19:46:12 <davean> but still
19:46:34 <julianleviston> OHHHH Traversible is a subclass of Functor.
19:47:01 <julianleviston> AND of Foldable… what a terrible name!
19:48:01 <Hafydd> The name "traversable"? Why is that terrible?
19:48:34 <julianleviston> Hafydd: I guess I don’t understand it properly, if you’re asking me.
19:48:40 <Hafydd> You have to note that it's more than just something that can be mapped and folded separately. It can do them both at once.
19:49:18 <julianleviston> Hafydd: but my immediate reaction was because “traverse” doesn’t imply that something is Functor-y or Foldable, necessarily.
19:49:22 <Hafydd> (Which is useful for efficiency reasons, and also for avoid duplication of code.)
19:49:26 <julianleviston> Hafydd:  ah ok
19:49:50 <capisce> julianleviston: how would the signature of traverse look in your opinion?
19:49:51 <Hafydd> julianleviston: that's why the name Traversable is there, to tell the user that it's more than just an empty subclass.
19:50:15 <julianleviston> capisce: I don’t understand what you’re asking me. I literally only just opened traversable for the first time a minute ago
19:50:37 * hackagebot workflow-osx 0.0.1 - a "Desktop Workflow" monad with Objective-C bindings  https://hackage.haskell.org/package/workflow-osx-0.0.1 (sboo)
19:51:18 <julianleviston> Hafydd: yeah, but that’s why it’s terribly - because before you’ve looked at it, you have some intuitions about it based on the name. I guess it’s a good lesson in not forming assumptions, but maybe it’s not such a bad name. I should be quiet.
19:51:23 <capisce> julianleviston: you said your immediate reaction was that "traverse" shouldn't imply being Functor-y or Foldable, then what should it imply? :)
19:51:56 <julianleviston> capisce: just foldable, really.
19:52:10 <julianleviston> capisce: which is probably why I didn’t really understand what it was until I opened it up.
19:52:48 <Stratege> julianleviston what is the point of traversing something?
19:52:56 <Stratege> (intuitively, that is)
19:52:58 <julianleviston> Stratege: I get it.
19:53:03 <julianleviston> Stratege: but I’ll answer your question...
19:53:06 <Stratege> kay ^^
19:53:13 <capisce> Data.Traversable: Class of data structures that can be traversed from left to right, performing an action on each element.
19:53:17 <julianleviston> Stratege: it’s to look at it… 
19:53:25 <capisce> "performing an action on each element" is where Functor comes in
19:53:26 <julianleviston> Stratege: and potentially take some information from it
19:54:14 <julianleviston> Stratege: but, really, fold is a non-intuitive name, too… so (shrug)
19:54:33 <Stratege> julianleviston I'm guessing you prefer "reduce"?
19:54:40 <julianleviston> Stratege: not really.
19:54:55 <capisce> well, I guess traverse isn't that intuitive after all
19:54:56 <julianleviston> Stratege: I don’t nave anything better necessarily.
19:56:21 <julianleviston> Stratege: TBH, most functional names for things were completely non-intuitive to me at first, and actually most people I’ve taught have found them quite odd until I explained the reasoning behind them.
19:56:35 <julianleviston> Stratege: like… “inject” from smalltalk. What a bizarre name at the outset.
19:56:54 <julianleviston> Stratege: inject == foldr, pretty much.
19:57:11 <Stratege> julianleviston got to admit, I have never used smalltalk. Ah. Okay. How peculiar, didn't know smalltalk used that kinda stuff.
19:57:46 <julianleviston> Stratege: Alan Kay (creator of smalltalk) was very impressed with MacCarthy’s work.
19:58:11 <julianleviston> Stratege: so you have map, inject, select, reject (select is filter, reject is not filter)
19:58:26 <Stratege> julianleviston oh *right* I remember him praising LISP.
19:58:27 <julianleviston> Stratege: and collect.
19:58:43 <Stratege> and that makes sense and is cool
19:59:01 <julianleviston> Stratege: interestingly, ruby took the name inject… and also added a synonym for reduce
19:59:05 <bitemyapp> julianleviston: time to fuck with you
19:59:11 <julianleviston> bitemyapp: ok :)
19:59:15 <bitemyapp> julianleviston: http://hackage.haskell.org/package/witherable-0.1.3/docs/Data-Witherable.html
19:59:17 <julianleviston> bitemyapp: please do… :) it’s what I live for
19:59:39 <julianleviston> bitemyapp: oh haha I assumed you could remove elements anyway
19:59:45 <julianleviston> bitemyapp: that’s a very cool idea
20:00:13 <Hafydd> I prefer "reduce," personally. "Fold" is too much of a childlike physical metaphor, when "reduce" perfectly describes the operation being performed on the data.
20:00:22 <julianleviston> bitemyapp: what’r she etymology of nub?
20:00:29 <bitemyapp> reduce is what I do to my curries.
20:00:36 <bitemyapp> which is a childlike physical metaphor
20:00:39 <julianleviston> Hafydd: I think the worst part of these names, is that they’re imperative.
20:00:41 <bitemyapp> we should just call it beta.
20:01:03 <Stratege> why beta?
20:01:08 <julianleviston> Stratege: beta reduction?
20:01:13 <Stratege> oh right
20:01:26 <bitemyapp> I'm being a little sarcastic and unfair to Hafydd :)
20:01:35 <Hafydd> julianleviston: I don't think you can avoid using verbs like "map" and "filter" even in functional names. It would be cumbersome to say "mapped" and "filtered," or whatever, even if it's pedantically appealing.
20:01:36 <bitemyapp> Hafydd: has a point, but that line of reasoning doesn't bottom out anywhere you want to be.
20:01:50 <ReinH> bitemyapp: your face is a childlike physical metaphor
20:01:50 <Stratege> Hafydd anything that reminds me of the abomination that is mapReduce is a terrible idea
20:01:58 <Hafydd> Hahah.
20:01:59 <julianleviston> Hafydd: sure you can.
20:02:00 <MarcelineVQ> I think reduce is just as bad, for learning, because a person might think folds always result in a smaller result.
20:02:18 <Hafydd> julianleviston: well, you can, but I don't think one should.
20:02:41 <julianleviston> Hafydd: fair enough :)
20:02:42 <bitemyapp> MarcelineVQ: that's a very good point.
20:02:43 <Hafydd> MarcelineVQ: the same could apply to "fold."
20:02:43 <capisce> julianleviston: imperative? even in pure math they use verbs like add and multiply
20:02:50 <bitemyapp> MarcelineVQ: we can retreat to the high ground of catamorphism!
20:02:57 <julianleviston> capisce: yep.
20:02:57 <Stratege> xD
20:03:02 <MarcelineVQ> Maybe, though if you fold a piece of paper it's just as heavy
20:03:27 <MarcelineVQ> Anyway, there's no perfect words because that needsd a perfect language :>
20:03:38 <julianleviston> MarcelineVQ: esperantists unite! :)
20:03:39 <Hafydd> That's true, but the metaphor involves making it shorter, into one unit.
20:04:21 <MarcelineVQ> I agree
20:04:27 <Hafydd> That reminds me of a lecture on Haskell I attended where the lecturer was explaining the "unzip" function, and he said, "No, I'm not going to demonstrate it."
20:04:34 <Stratege> xD
20:04:44 <julianleviston> sumOf [1,2,3]
20:04:46 <MarcelineVQ> I'm not saying fold is better exactly, just that reduce is probably worse from my own little pov
20:04:48 <capisce> >_<
20:05:06 <MarcelineVQ> Wait that does mean​i'm saying fold is better.
20:05:20 <ReinH> MarcelineVQ: only according to logic
20:05:34 <capisce> I don't think these names are the biggest challenge we face in programming
20:05:38 <MarcelineVQ> I guess that's that then.
20:05:40 * hackagebot pandoc-crossref 0.1.5.4 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.1.5.4 (lierdakil)
20:06:10 <Stratege> bitemyapp got to admit, stack does have much nicer error messages.
20:06:26 <Stratege> capisce but they are great for bikeshedding.
20:06:45 <capisce> :'(
20:08:37 <julianleviston> MarcelineVQ: I guess if you think of a “map of a list” as being a thing, then map (+2) [1,2,3] is actually a noun. So maybe it’s just fine the way it is. :) No one necessarily says that “traverse” is a directive… perhaps it means “traverse of..” :)
20:08:43 <julianleviston> oops.
20:08:50 <julianleviston> bitemyapp: ^ meant for you
20:09:01 <julianleviston> bitemyapp: or both of you.
20:09:19 <Stratege> (+2) `map` [1,2,3] <- still a noun? ^^
20:09:28 <arkeet> all expressions are nouns.
20:09:48 <julianleviston> Stratege: yeah… actually if you think of the difference between execution and evaluation, then “map” *really is* a noun.
20:09:49 <MarcelineVQ> "Traverse this strange land and leave your mark."
20:09:56 <Hafydd> But using a verb for an applicative action such as traverse does make sense, at least when the Applicative instance does consist of "actions."
20:10:02 <julianleviston> Stratege: the whole expression.
20:10:05 <julianleviston> arkeet:  yeah :)
20:10:06 <MarcelineVQ> "Implement Traverse to know how."
20:10:21 <Stratege> julianleviston please do explain how/why functions are nouns.
20:10:46 <julianleviston> Stratege: in the same sense that you just used the word “functions”
20:10:53 <julianleviston> Stratege: the function is (+).
20:11:32 <julianleviston> Stratege: 2 + 2 is just an expression of the values 2 and 2, and the expression (+), which can’t be reduced any more… is that fair?
20:11:39 <Hafydd> I believe that functions are nouns, because they represent a conceptual object: a mapping from inputs to outputs. A function doesn't perform any action; it can just be consulted to associate inputs with outputs.
20:11:53 <julianleviston> Hafydd: thank you. 
20:11:56 <Hafydd> But the noun usually refers to the functions image, rather than the function itself.
20:12:00 <Hafydd> e.g. sum, product, etc.
20:12:01 <julianleviston> Hafydd: I wish I had your way of putting that.
20:12:20 <julianleviston> Hafydd: as bitemyapp’s book start with…. a function is a map between sets.
20:12:20 <Stratege> fair enough, I suppose.
20:17:53 <dibblego> traverse is map with an effect in every return position
20:18:16 <dibblego> map is recoverable by eliminating the effect (Identity)
20:23:00 <Stratege> anyone have a suggestion for a good GUI library in Haskell? Preferably one that doesn't bind to some non-Haskell library? :)
20:24:26 <bitemyapp> @karma+ dibblego
20:24:27 <lambdabot> dibblego's karma raised to 6.
20:28:22 <Cale> Stratege: If using a web page as your GUI is acceptable, perhaps try reflex-dom :)
20:28:48 <Cale> Stratege: Otherwise, well, I don't think there exists a Haskell GUI library which does not in some way involve a binding to a C library.
20:29:02 <julianleviston> Cale: or even if not apparently… didn’t someone say it hooks down into webkit if not using ghcjs?
20:29:06 <Cale> Stratege: Gtk2Hs is pretty mature.
20:29:13 <Cale> yes
20:29:15 <Cale> It does
20:29:35 <Stratege> Cale well... here's to hoping that one's easier to install then
20:29:37 <Cale> You can build the same program with ordinary ghc rather than ghcjs to build it as a webkit app.
20:30:47 <davean> Cale: Hum, what about lighthouse? (I mean, I haven't looked, but maybe?)
20:31:06 <Cale> I haven't heard of lighthouse
20:31:44 <Cale> Oh, do you mean like, House the Haskell OS?
20:31:52 <davean> yes
20:31:58 <davean> lighthouse was a followup I think
20:31:59 <Cale> It had some GUI stuff which presumably was based on nothing else
20:32:08 <Cale> But it's also not really usable :P
20:32:11 <davean> Right, so that would be one?
20:32:22 <davean> Cale: you did *not* say usable
20:32:28 <Cale> heh
20:32:35 <monochrom> sounds like you have to use the House OS to begin with :)
20:32:39 <Cale> yeah
20:32:51 <Cale> If you're using House, then yeah, maybe it's an option :P
20:37:31 <Stratege> Cale any idea how to best install Gtk2Hs?
20:55:29 <montanonic> Hey, so I really want to get a blog going to both record my thoughts and practice with frontend design, and I was thinking of using Hakyll. I'd like to figure out though what haskell DSL's I could use for HTML/CSS.
20:55:46 <montanonic> I looked up BlazeHTML and that seems really cool, but I'd like more feedback.
20:56:24 <montanonic> I was thinking that I could also use Yesod's templates too?
20:56:34 <montanonic> Blaze seems solid for HTML, but I need a CSS option.
21:26:54 <julianleviston> what does the -02 GHC option do?
21:27:11 <julianleviston> sorry -O2
21:28:45 <athan> julianleviston: Excessive optimization
21:28:52 <athan> so excessive i've heard it to slow down :x
21:29:57 <bitemyapp> julianleviston: don't use it, don't worry about it
21:30:51 * hackagebot sbv 5.1 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  https://hackage.haskell.org/package/sbv-5.1 (LeventErkok)
21:31:42 <julianleviston> ah ok… was just looking at Ryan S’s memoize example of snap… and he put it in
21:31:53 <julianleviston> https://github.com/ryantrinkle/memoise/blob/lesson-1/memoise.cabal
21:32:09 <julianleviston> Ryan T, sorry.
21:34:18 <bitemyapp> julianleviston: Ryan knows what he's doing.
21:34:22 <bitemyapp> julianleviston: don't guess, measure.
21:34:30 <julianleviston> bitemyapp: huh?
21:34:41 <julianleviston> bitemyapp: I’m not guessing things, am I?
21:34:58 <bitemyapp> offering general principles for -O2 and the like.
21:35:07 <bitemyapp> it's not something you flip on willy-nilly.
21:35:12 <julianleviston> bitemyapp: ahhh I’m not going to pass judgement on anyone for something.
21:35:31 <julianleviston> bitemyapp: cool :) thanks.
21:35:52 * hackagebot hops 0.1.1 - Handy Operations on Power Series  https://hackage.haskell.org/package/hops-0.1.1 (AndersClaesson)
21:35:55 <bitemyapp> all to say, it's not an automatic win. It's circumstantial.
21:36:09 <ttt_fff> yeah, ryan is smart
21:36:12 <ttt_fff> learn from ryan
21:52:50 <mitochon> what’s the best way to convert Data.ByteString.Lazy.Internal.ByteString to String
21:56:52 <bitemyapp> Cale: https://twitter.com/bitemyapp/status/653071046493343744
21:57:08 <bitemyapp> Cale: is there anything I can do? I'm not sure how to stop it chasing an infinite list.
21:58:52 <athan> With Yoneda, the data constructor is `Yoneda :: (forall b. (a -> b) -> f b) -> Yoneda f a`, right?
21:58:53 <Cale> bitemyapp: What is =-= ?
21:59:15 <Cale> Oh, equality testing with Property-result?
21:59:16 <athan> (for some reason, stack isn't installing category-extras right now >.>)
21:59:31 <Cale> Yeah, I guess you can't check that with QuickCheck
21:59:44 <Cale> Equality isn't really computable there
21:59:52 <Cale> need to actually prove it
22:00:21 <monochrom> perhaps you can settle with "equal up to the first 3000 items"
22:00:23 <bitemyapp> Cale: that's what I suspected. This sucks.
22:01:26 <monochrom> in fact, that's what I do when testing my fibonacci-infinite-list toy code, except just 10 items and I just eyeball :)
22:01:35 <bitemyapp> well, the good news is
22:01:38 <bitemyapp> he splits out EqProp from Eq
22:01:52 <bitemyapp> so having a weird notion of equality is kosher and kept away from making Eq cancer.
22:02:18 <bitemyapp> justifying this to readers of the book is going to suck.
22:02:20 <monochrom> yeah
22:02:42 <bitemyapp> oh god it's midnight
22:05:08 <bitemyapp> Cale: monochrom thank you both :)
22:11:01 * hackagebot hops 0.1.2 - Handy Operations on Power Series  https://hackage.haskell.org/package/hops-0.1.2 (AndersClaesson)
22:15:29 <nitrix> Am I going to be sent to `blah` if I ask for a recommendation about postfix notation?
22:16:22 <nitrix> In my experience, they don't really talk about anything language related.
22:16:57 <julianleviston> nitrix: interesting… what is postfix notation?
22:17:10 <julianleviston> nitrix: you don’t mean infix, right?
22:17:20 <nitrix> RPN, reverse polish notation.
22:17:26 <julianleviston> nitrix: ooh.
22:17:31 <julianleviston> nitrix: interesting!
22:19:56 <nitrix> I'm working on the specifications of a toy language and I'm transposing many Haskell concepts to it. Predominently is the type system and niceties like Monad and so on. The most interesting aspect is that it's concatenative, so `x y` isn't the application of x on y, but the composition of x with y.
22:20:22 <nitrix> Thus, it sort of encourage a point-free style, but I'm figuring out a mechanism for named arguments for functions, still. Anyway.
22:21:04 * hackagebot mathista 0.0.1 - A programming language for numerical computing  https://hackage.haskell.org/package/mathista-0.0.1 (seiya)
22:21:24 <nitrix> The question is how you would maintain this concatenative RPN style while still allowing function definition.
22:22:16 <capisce> have you looked at languages like Joy and Factor?
22:22:52 <nitrix> I'd have to either break the style by introducing an additional syntax (similar to Haskell) `f = x y z`, or someone suggested symbols, as in, `[x y z] @f def`
22:23:33 <nitrix> The latter would follow the RPN spirit, but I'm not knowleageable enough about the implications and it's the kind of thing I'd love to get right on the first time :(
22:23:51 <nitrix> capisce: I did.
22:25:27 <nitrix> Joy might be the closest, but again, they have this additional DEFINE syntax. I'd like to keep identation non-significant, as it already serve the purpose of function composition.
22:25:49 <nitrix> indentation*
22:36:23 <nitrix> Oh well, I'll figure it out.
22:44:42 <PaulFertser> Hi there. Please excuse my silly question but here it goes: imagine for the sake of typesafety I'm doing "newtype Height = Height Double"; now I want to be able to do something like "liftA2 (+) height1 height2" but that's obviously not possible. What am I doing wrong here, and how I should be thinking to get it right? Unfortunately, lack of theoretical background doesn't make it obvious for me :( 
22:47:55 <Cale> PaulFertser: You could use newtype deriving to make an instance of Num for Height
22:48:53 <Cale> PaulFertser: you could also write a higher order function of type  (Double -> Double -> Double) -> Height -> Height -> Height, and apply that to (+)
22:49:00 <PaulFertser> Cale: well, in this specific case, yes. But what if I'm wrapping a Data.Map and want to use the usual map functions without too much boilerplate?
22:49:37 <Cale> The boilerplate is presumably meaningful, because otherwise you wouldn't have newtyped.
22:55:13 <julianleviston> PaulFertser: so you want to lift (+) into your data structure so you can do “all kinds of things” with your values (which are inside your data structure, so to speak) ?
22:55:31 <julianleviston> PaulFertser: or, really, lift anything into that “data structure"?
22:55:37 <julianleviston> PaulFertser: I mean, any function...
22:56:15 <PaulFertser> julianleviston: yes, I think I'm talking about just that
22:57:10 <julianleviston> PaulFertser: well, applicative functor is the typclass that lets you lift operations across data structures, unless you just want to map functions across those data structures, (Hopefully I’m getting this right - Cale will correct me).
22:57:15 <julianleviston> Cale: is that fair?
22:57:20 <julianleviston> typeclass*
22:57:25 <PaulFertser> Cale: I'm afraid I'm not following. The newtype would still save me from passing around wrong data (say, width instead af height) until the very action I'm about to perform.
22:58:20 <julianleviston> Cale: I think he basically wants an “as easy as possible type synonym that also has type safety - ie non-synonymous”
22:58:24 <julianleviston> Cale: if that makes sense.
22:58:25 <PaulFertser> julianleviston: I mentioned liftA2 just because of that. But my type can't be an applicative functor, it's of the wrong kind for it (that's why I say it can't obviously work).
22:58:30 <Cale> PaulFertser: If you were allowed to apply arbitrary Map operations, why wouldn't you be able to merge a Map of widths with a Map of heights by accident?
22:58:50 <Cale> (i.e. with union)
22:59:42 <Cale> PaulFertser: The newtype data constructor / pattern matching is how you explicitly say "okay, I want to give up my type safety here, and just treat this thing as a Map again"
23:00:45 <PaulFertser> Cale: I'd like to have a magical liftX2 that would not typecheck if I pass two different types to it.
23:01:26 <Cale> PaulFertser: Well, liftM2 does fail if you pass two differently typed arguments to it
23:01:28 <Cale> :t liftM2
23:01:29 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:01:38 <Cale> Well, they have to be the same monad
23:01:43 <Cale> :t liftA2
23:01:44 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
23:01:48 <Cale> or same applicative
23:01:52 <Cale> at least
23:02:04 <Cale> But of course, that assumes you actually have a monad or applicative
23:02:07 <PaulFertser> Cale: yes, but my type can't be a monad or applicative, hence I'm asking.
23:02:23 <Cale> Right, so you don't get the benefit of these abstractions and have to write your own higher order functions
23:02:55 <Cale> Thankfully it's not all that hard to do
23:03:27 <PaulFertser> But that should be a common enough need so I'd expect that if it was at all possible there would be a typeclass suitable.
23:03:33 <julianleviston> Cale: so… he wants his type to have, say, a Num instance, and yet not be able to be mixed with other Num instances.
23:03:50 <Cale> well, that's generally the case for Num instances
23:03:52 <Cale> :t (+)
23:03:53 <lambdabot> Num a => a -> a -> a
23:03:53 <PaulFertser> If it's not common enough it means I'm trying to do it wrong and should be thinking in a different way altogether.
23:03:59 <Cale> ^^ you can't just add two of anything
23:04:03 <julianleviston> PaulFertser:  effectively expose the underlying data type of the newtype….
23:04:07 <Cale> They have to be values of the same type
23:04:12 <PaulFertser> julianleviston: exactly
23:04:21 <Cale> PaulFertser: with what operation?
23:04:29 <Cale> PaulFertser: What's the type of the operation you want?
23:04:32 <julianleviston> Cale: whatever operations the newtype’s data has.
23:04:37 <Cale> huh?
23:04:48 <Cale> No, he said an existing type class
23:04:59 <Cale> A type class with which operations?
23:04:59 <julianleviston> Cale: oh, sorry, maybe I don’t actually understand then
23:05:24 <PaulFertser> Cale: I meant like there's Monad and Applicative that do almost what I want there "should be" another typeclass that does exactly what I want. But there isn't one, why?
23:05:34 <Cale> What is exactly what you want?
23:05:42 <Cale> Can you write down its type?
23:06:49 <PaulFertser> I think I want a typeclass that would allow to expose the underlying (wrapped) type and would allow to create a new value of this new type in generic way so that one would be able to write liftX2 function that would work for all the typeclass instances.
23:07:21 <ggole> PaulFertser: you just want to restrict the two type variables in liftM2, right?
23:07:37 <ggole> eg, let liftM2One :: Monad m => (a -> a -> r) -> m a -> m a -> m r; liftM2One = liftM2
23:07:41 <PaulFertser> ggole: no, I can't use liftM2 because my newtype is not a Monad.
23:08:01 <ggole> OK, then never mind - I misread.
23:08:26 <Cale> PaulFertser: but what would the type look like?
23:08:36 <PaulFertser> ggole: and yes, I'd like something similar to a Monad but more restrictive, so that the liftM2One signature looks about the same I'd like.
23:08:45 <julianleviston> Cale: it’s not specific to a particular type.
23:09:05 <Cale> julianleviston: If you're going to define a type class, you need to provide types for the methods
23:09:12 <PaulFertser> I think Cale is trying to make me think so I understand the meaningless of my question myself, right?
23:09:19 <Cale> PaulFertser: Maybe
23:09:22 <julianleviston> Cale: so… say his newtype is newtype Age = Age { getAge = Integer }...
23:09:33 <Cale> PaulFertser: Or else I might be able to tell you that the thing you're looking for exists
23:09:39 <julianleviston> Cale: then he wants to be able to extend the same methods to the Age type that Integer has.
23:09:56 <Cale> PaulFertser: But I need to know what you're looking for first, and in order to understand that, I think I need the type of the operation.
23:10:27 <julianleviston> Cale: what he’s looking would be a function on the newType’s type… so I’m pretty sure we don’t have it… 
23:10:56 <PaulFertser> Cale: but I'm not looking for a specific solution, that all "lifting" I'm thinking about is likely misguided; I just do not know the proper way to think about the problem I'm imagining.
23:11:18 <PaulFertser> I think julianleviston paraphrased my question precisely.
23:11:19 <julianleviston> Cale: in lieu of that, though, he’s looking for some “meta-lifter” that will lift functions across a newtype for the “inner value”… so something he can eval on, say (+) for instance of Num.
23:11:24 <Cale> PaulFertser: Maybe it's better to start from some repetitive code that you'd like to refactor
23:11:57 <julianleviston> PaulFertser: yeah, give him a specific example, and then show the general case from that… this is how we best understand.
23:12:04 <Cale> julianleviston: I'm not sure I understand what you mean. Can you give the type signature for it?
23:12:43 <julianleviston> Cale: I’ll think about if I can
23:13:58 <ggole> Sounds like GeneralizedNewtypeDeriving
23:14:07 <julianleviston> Cale: ok… so say his newtype is called Height. .. it’d be this Num a => (a -> a -> a) -> (Height -> Height -> Height)
23:14:18 <julianleviston> Cale: but that’s only for (+)
23:14:22 <Cale> Really?
23:14:30 <Cale> Can that even be implemented?
23:14:41 <julianleviston> Cale: or for any binary function.
23:14:48 <Cale> It would have to be (Double -> Double -> Double) -> Height -> Height -> Height, wouldn't it?
23:15:06 <Cale> Or do you mean (forall a. Num a => a -> a -> a) -> ...
23:15:07 <Cale> ?
23:15:13 <ggole> newtype W = W Int deriving (Eq,Show,Num) and then (W 1) + (W 2) => W 3
23:15:13 <julianleviston> Cale: sur.
23:15:17 <julianleviston> Cale: sure*
23:15:18 <awpr> how about: class Newtype a where { type Impl a :: *; wrap :: Impl a -> a; unwrap :: a -> Impl a }
23:15:38 <Cale> I already suggested writing a function of type (Double -> Double -> Double) -> Height -> Height -> Height right at the start :)
23:15:47 <nitrix> Whaow, my attempt at a toy language design is clearly headed towards Haskell.
23:15:49 <julianleviston> Cale: yes, but that’s a single specific case.
23:16:16 <nitrix> Whatever I do, it just seems like I getting back to the same point and Haskell does it better :(
23:16:43 <julianleviston> Cale: he wants a single way to liftNewType2, -> N
23:17:04 <Cale> nitrix: Please make a dependently typed functional programming language with a lazy-by-default implementation.
23:17:08 <Cale> and Haskell-like syntax
23:17:18 <julianleviston> Cale: or even better, a way to make an instance for some (unknown) typeclass that would specialise another typeclass to this typeclass (If my lingo is correct there)
23:17:22 <awpr> julianleviston: that's what the typeclass I just wrote is for -- liftNT* would be combinations of (.), wrap, and unwrap
23:17:32 <Cale> :k Iso
23:17:33 <lambdabot> * -> * -> * -> * -> *
23:17:35 <julianleviston> awpr: brillian! :)
23:17:37 <nshepperd> over2 :: Newtype n o => (o -> o -> o) -> (n -> n -> n)?
23:17:39 <Cale> heh
23:18:00 <julianleviston> PaulFertser: so I think you have probably realised this isn’t super trivial Haskell...
23:18:03 <nshepperd> making your thing an instance of Newtype exposes the constructors though
23:18:07 <nitrix> Cale: It is depedently typed, functually, lazy, has pattern matching and rank-n types. Very very similar to haskell, just headed towards a RPN syntax.
23:18:27 <awpr> oh, is there already a Newtype class?
23:18:48 <nshepperd> yeah, in the newtype package
23:19:04 <awpr> I give that only a 75% chance of being maintained by ekmett
23:19:07 <julianleviston> this feels pretty ugly.
23:19:27 <julianleviston> I wonder if there’s a better way to say “Hey, here’s a type synonym that is not actually identical"
23:19:37 <julianleviston> typeclone or something
23:19:47 <awpr> newnewtype
23:20:00 <julianleviston> awpr: don’t you still get the constructors tho?
23:20:20 <julianleviston> awpr: oh duh… of course… you’d end up with overloaded vals
23:20:22 <nshepperd> uh, you need the constructors
23:20:48 <julianleviston> nshepperd:  yeah, feels like someone’s trying to shoehorn OOP into FP ;-)
23:21:14 <Cale> There's ala
23:21:33 <julianleviston> @where ala
23:21:34 <lambdabot> I know nothing about ala.
23:21:39 <julianleviston> alas
23:21:42 <Cale> :t ala
23:21:43 <lambdabot> (Rewrapped s t, Rewrapped t s) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
23:21:58 <julianleviston> Cale: look at that juicy type sig ;-)
23:21:59 <nshepperd> O_O
23:22:13 <Cale> > ala Sum foldMap [1,2,3,4]
23:22:15 <lambdabot>  10
23:22:26 <Cale> ala Product foldMap [1,2,3,4]
23:22:27 <Cale> > ala Product foldMap [1,2,3,4]
23:22:29 <lambdabot>  24
23:22:40 <nshepperd> where is that ala from?
23:22:45 <Cale> lens, where else?
23:24:39 <Cale> > (_Wrapped %~ length) (Const "hello")
23:24:41 <lambdabot>  Const 5
23:25:23 <Mayzie> lol Ben, are you here?
23:25:43 <Cale> But tbh, I would probably never use this :P
23:26:05 <Cale> Well, maybe there will be some point at which it'll come in handy
23:26:25 <nitrix> If Haskell didn't have pattern matching, what would be the alternatives that are common in FP?
23:26:34 <Cale> But as a day-to-day thing, it's doing something trivial using lots of sophisticated machinery
23:27:08 <Cale> It's a nice experiment, but I'd usually prefer to write things more directly.
23:27:34 <Cale> nitrix: Lots of testing conditions and conditionally deconstructing data like they do in Scheme?
23:27:57 <ggole> Endless suffering.
23:27:59 <Cale> nitrix: "no pattern matching" and "FP" don't really fit together so well.
23:28:30 <Cale> Heh, or I guess one glib answer would be "tactics"
23:29:13 <Cale> In Coq, you can write programs which avoid explicit pattern matching by using tactics to write the pattern matches for you.
23:29:18 <ggole> More seriously, perhaps Prolog-style unification + backtracking
23:29:25 <ggole> Although that's not unlike pattern matching in a way
23:29:48 <Cale> Yeah, I'd consider that just an even fancier form of pattern matching
23:30:06 <PaulFertser> julianleviston, Cale, awpr: thank you very much, I now need some time to properly digest that; much appreciated!
23:30:11 <nitrix> I'm trying to figure out how pattern matching would work in a RPN language :/
23:30:21 <julianleviston> PaulFertser: thanks for asking! I learned lots.
23:30:43 <julianleviston> PaulFertser: (no sarcasm, I didn’t know about the newtype package until then)
23:30:45 <Cale> PaulFertser: Yeah, there are ways to do some things which are kind of vaguely like what you seem to be asking for
23:31:06 <Cale> PaulFertser: But some of them are pretty complicated, and I wanted to be sure about what you mean
23:31:15 <julianleviston> PaulFertser: if you want some advice, keep as “simple” as you possibly can, for as long as you possibly can.
23:31:33 <julianleviston> PaulFertser:  (talking about conceptual simplicity)
23:31:48 <PaulFertser> julianleviston: well, you got the essence my question exactly from the start
23:31:50 <Cale> PaulFertser: One thing you could write
23:32:10 <Cale> PaulFertser: is a function of type  (a -> b) -> (b -> a) -> (a -> a -> a) -> (b -> b -> b)
23:32:29 <Cale> PaulFertser: and similar functions for different numbers of arguments
23:32:47 <julianleviston> PaulFertser: that’s because I’ve had precisely that pain. It’s something that I would have loved a simple answer to when I was beginning.
23:33:12 <Cale> i.e. if you can provide the functions which express how the types a and b are "the same", then you can transform a function acting on one type into a function acting on the other type
23:33:59 <julianleviston> PaulFertser: I think more often than not, though, the worries you have, dissolve as you write your program.
23:34:09 <Cale> this is just  iso2 to fro f x y = to (f (fro x) (fro y))
23:34:29 <Cale> which we could make incomprehensible using @pl :)
23:34:35 <Cale> @pl iso2 to fro f x y = to (f (fro x) (fro y))
23:34:35 <lambdabot> iso2 = (. (flip =<< ((flip . ((.) .)) .) . flip (.))) . (.) . (.) . (.)
23:34:39 <Cale> beautiful
23:34:41 <julianleviston> Cale: lol
23:35:10 <julianleviston> Cale: is there a name for (.).(.).(.) ? I see it so often
23:35:29 <Cale> julianleviston: I don't think there's a name for it, but you can think of it as fmap . fmap . fmap
23:35:36 <julianleviston> Cale: nah, I mean a function for it.
23:35:40 <julianleviston> Cale: or an operator
23:35:58 <ggole> Run the type though hoogle
23:36:02 <Cale> If you find yourself wanting that, use a dang lambda.
23:36:03 <ggole> Is there a bot for that?
23:36:06 <julianleviston> ggole: guh. silly me
23:36:07 <julianleviston> sorry
23:36:34 <Cale> :t (.) . (.) . (.)
23:36:35 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
23:36:41 <Cale> @hoogle (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
23:36:44 <lambdabot> No results found
23:36:59 <julianleviston> Cale: yeah I hoogled it on the web. 
23:37:10 <awpr> lots of people define (.:) as (.).(.) , so maybe (.:.)
23:37:12 <ggole> Ah, that's obvious enough
23:37:28 <julianleviston> awpr: triforce.
23:37:37 <ggole> I was wondering about a "hoogle on the type of this term" thing
23:38:01 <Cale> ggole: You could use lambdabot's ability to compose its plugins
23:38:43 <Cale> @@ @hoogle @type fmap
23:38:44 <lambdabot>  Prelude fmap :: Functor f => (a -> b) -> f a -> f b
23:38:45 <lambdabot>  Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
23:38:45 <lambdabot>  Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
23:38:53 <awpr> :t ▲▲▲
23:38:54 <lambdabot> parse error on input ‘▲▲▲’
23:40:33 <ggole> Cale: ooh, didn't know about that
23:41:14 <Cale> @@ @elite @hoogle @type fmap
23:41:15 <lambdabot>  PR31UDe FmaP :: fUN(+Or ph => (A -> 8) -> F A -> f 8 dATA.fUNCTOR phmaP :: FUNctOR f => (A -> b) -> f A -> ph B contR01.monad phM4P :: phuncT0R F => (a -> b) -> f a -> F b
23:41:23 <Cale> useful
23:42:56 <ggole> @@ @pl @src fmap
23:42:57 <lambdabot>  (line 1, column 57):
23:42:57 <lambdabot> unexpected end of input
23:42:57 <lambdabot> expecting white space or simple term
23:43:03 <ggole> Hmm
23:43:16 <joco42> is there a way to turn implicit import into explicit imports automatically?
23:43:16 <ggole> @src fmap
23:43:16 <lambdabot> Source not found. Maybe you made a typo?
23:43:28 <ggole> I see.
23:43:31 <ggole> Well, very nifty.
23:46:58 <cdk> ggole: the implementation of fmap depends on the Functor
23:47:59 <ggole> Yeah, I figured
