00:06:23 <EvanR> what is this notation? let n be a natural transformation from FG -> 1_c, where F and G are functors from C to D. What's the FG? 
00:06:52 <EvanR> oops, F : D -> C, G : C -> D. is it functor composition?
00:07:10 <geppettodivacin> nurupo: mapM_ works great for that.
00:07:29 <geppettodivacin> > mapM_ putStr ["test1", "test2"]
00:07:30 <lambdabot>  <IO ()>
00:07:37 * hackagebot msh 0.1.0.0 - Template Haskell implementation of Programming with Monadic State Hierarchies  https://hackage.haskell.org/package/msh-0.1.0.0 (mbg)
00:07:37 * hackagebot oidc-client 0.1.0.1 - OpenID Connect 1.0 library for RP  https://hackage.haskell.org/package/oidc-client-0.1.0.1 (ShoKuroda)
00:08:38 <nurupo> geppettodivacin: thanks!
00:09:11 <geppettodivacin> In my opinion, mapM_ is about the most useful thing for class projects.
00:09:41 <geppettodivacin> Write all your output to a Writer, one string at a time, then > mapM_ putStrLn
00:10:17 <EvanR> or you could write putStrLn yourString to the Writer, then later sequence_ ;)
00:10:56 <geppettodivacin> That would definitely be one way to do it.
00:11:26 <geppettodivacin> It would kind of bug me leaving that IO function sitting in the list through so much nice pure code, though.
00:11:45 <EvanR> youll like this even more
00:11:56 <geppettodivacin> Although I had never used sequence_ before, so I learned something new already.
00:12:16 <EvanR> make a Flexible instance for Monoid IO (), and make the writer combine them with >>, then in the end just join the result ;)
00:12:51 <geppettodivacin> I'm not familiar with Flexible yet.
00:12:53 <nurupo> geppettodivacin: we use interact for class projects
00:12:57 <EvanR> FlexibleInstances
00:13:03 <nurupo> main :: IO()
00:13:04 <nurupo> main = interact (unlines . map show . f . map read . words)
00:13:06 <EvanR> i was joking on the last advice though
00:13:12 <nurupo> where f is the function you implement
00:13:40 <jle`> EvanR: it looks like functor composition
00:14:18 <geppettodivacin> nurupo: Mm, that makes sense. Maybe I should get used to using interact more, myself.
00:14:40 <EvanR> thx
00:15:01 <EvanR> jle`: and 1_c is a terminal object in C ?
00:16:17 <EvanR> oh, identity functor
00:17:04 <jle`> yes
00:18:11 <EvanR> what about a natural isomorphism from hom_C(F-,-) -> hom_D(-,G-).... i would think these are hom sets, but a natural isomorphism is between two functors so 
00:18:29 <EvanR> uhg
00:19:05 <EvanR> what is hom of two functors
00:21:10 <EvanR> i wish math had a :t
00:24:19 <thimoteus> usually we call that thinking
00:25:09 <EvanR> i cant think what this notation means out of nowhere ;)
00:27:28 <EvanR> doh its not applied to functors after all
00:30:04 <Sinestro> Is there a built in function that would do f :: a -> Bool and g :: a -> Bool to h x = f x && g x
00:30:40 <EvanR> :t (<*>) `asAppliedTo` (\x -> True)
00:30:41 <lambdabot>     Couldn't match type ‘a -> b’ with ‘Bool’
00:30:42 <lambdabot>     Expected type: t -> Bool
00:30:42 <lambdabot>       Actual type: t -> a -> b
00:31:12 <EvanR> :t (&&) <$> f <*> g
00:31:13 <lambdabot> (Applicative f, FromExpr (f Bool)) => f Bool
00:31:40 <EvanR> Sinestro: <*>
00:32:14 <EvanR> hmm something involving this
00:36:08 <EvanR> > ((&&) <$> null <*> null) []
00:36:10 <lambdabot>  True
00:36:12 <EvanR> > ((&&) <$> null <*> null) [1]
00:36:14 <lambdabot>  False
00:37:48 <mniip> :t null
00:37:49 <lambdabot> Foldable t => t a -> Bool
00:37:57 <mniip> oh yes
00:38:46 <EvanR> Sxyz = xz(yz)
00:38:54 <EvanR> <*> is the S combinator
00:39:46 <EvanR> im not sure what <$>/fmap is doing but it worked
00:40:48 <ttt_fff> whoa; so I fainlly feel like I understand whnf
00:40:51 <ttt_fff> here's one thing I don't understand
00:41:00 <ttt_fff> haskell takes about arbitrary execution order / compiler can choose
00:41:06 <ttt_fff> but many libraries seems to _REQUIRE_ laziness
00:41:09 <ttt_fff> that they ASSUME laziness
00:41:18 <ttt_fff> and if there's stritness, then they infinite loop
00:41:23 <EvanR> its constrained to choose in a way that doesnt mess up "non-strict semantics"
00:41:29 <ttt_fff> so it seems that in theory, haskell is 'compiler decides when to execute'
00:41:32 <ttt_fff> but in practice, we're forced to be lazy
00:41:44 <ttt_fff> EvanR: that's like choosing a color that is balck
00:41:44 <EvanR> it can be strict if it knows it wont matter
00:41:52 <EvanR> which is what strictness analysis does
00:41:56 <ttt_fff> how can a compiler possibly infer "this won't infinite loop" ?
00:41:58 <ttt_fff> whoa; this is possible?
00:42:10 <ttt_fff> this sounds very halting-problem esque
00:42:14 <EvanR> it cant, but sometimes it knows
00:45:13 <EvanR> strictness analysis tries to determines if the value will definitely be needed and if evaluating it eagerly wont make the function act differently, so if it was already strict it can be treated strictly
00:45:51 <thimoteus> what's the difference between foldl and foldl'?
00:46:21 <EvanR> foldl' eagerly reduces the accumulating thing at each step
00:46:27 <thimoteus> ahh
00:46:47 <EvanR> which you pretty much always want, or youd be using foldr
01:01:42 <phaazon> hey, how do you pass a Data.Vector.Storable to a C function?
01:01:50 <phaazon> I guess withArray . toList is not the way to go
01:02:12 <phaazon> there’s an unsafe function, unsafeWith, but I’m not sure it’s how we should Storable Vectors 
01:02:25 <EvanR> allocate space for it, store it, pass a pointer to C
01:02:54 <phaazon> EvanR: a Vector is not Storable
01:02:56 <EvanR> unless the API can tell you where to store it
01:03:01 <phaazon> so it can’t be “stored”
01:03:10 <EvanR> what? youre using Storable vector
01:03:25 <phaazon> hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Storable.html#g:36
01:03:30 <phaazon> do you see a Storable instance? ;)
01:03:43 <EvanR> correct you cant poke the whole thing anywhere
01:03:50 <EvanR> but you can do what i said
01:04:08 <phaazon> I didn’t get what you said
01:05:30 <phaazon> 10:02 < EvanR> allocate space for it, store it, pass a pointer to C
01:05:39 <phaazon> that doesn’t really tell me anything
01:05:54 <phaazon> withArray . toList was more accurate on what I do
01:06:04 <phaazon> can you be more accurate? :)
01:07:21 <EvanR> yeah thats defeating the point of the storable vector
01:07:29 <phaazon> yeah
01:07:48 <phaazon> then I don’t get the use of it
01:07:53 <phaazon> unless from using unsafeWith
01:08:01 <phaazon> which exposes its (Ptr a)
01:08:18 <ski> EvanR : from `(A,B) |-> hom_C(F A,B)' to `(A,B) |-> hom_D(A,G B)' ?
01:08:46 <EvanR> yes those unsafeFunctions are useful for low level munging, which is why you need for instance to convert a storable vector of Word8 into a ByteString and back
01:08:49 <EvanR> if necessary
01:09:02 <EvanR> what you need*
01:09:11 <phaazon> so what’s the point of Storable vectors?
01:09:27 <ski> EvanR : "let n be a natural transformation from FG -> 1_c, where F and G are functors from C to D. What's the FG?","oops, F : D -> C, G : C -> D. is it functor composition?" -- yes
01:09:33 <EvanR> they are implemented as arrays of bytes and you get access to them
01:10:06 <EvanR> ski: yeah i get that now, for some reason i thought the arguments were functors
01:11:00 <EvanR> so now i have completed the task of understanding the types of all the ingredients to adjunctions
01:11:30 <phaazon> hm
01:11:34 <phaazon> as I understand them
01:11:47 <phaazon> Storable vectors are not that different from Strict or Lazy standard vectors
01:11:57 <phaazon> the only difference is the use of unsafe operations behind the hood
01:12:02 <phaazon> so that everything is faster
01:12:13 <EvanR> well, it uses Storable somehow
01:12:18 <phaazon> sure
01:12:34 <phaazon> I guess it pokes / peeks things un unsafePerformIO in the implementation
01:12:49 <EvanR> you can get that pointer and memcpy the bytes into your buffer that you pass to C
01:14:08 <EvanR> data Vector a = Vector {-# UNPACK #-} !Int {-# UNPACK #-} !(ForeignPtr a)
01:14:49 <ski> EvanR : so now consider examples, like free functors ?
01:16:00 <EvanR> i saw a couple examples, mainly the free foos which are generated by an adjoint functor to a forgetful functor, but i dont know a good place to get more examples
01:17:04 <ski> EvanR : consider left adjoint of the free graph on a set ?
01:17:54 <EvanR> should i already know what the free graph on a set is before doing that?
01:18:01 <ski> yes
01:18:02 <EvanR> or can it fall out of some machinery
01:18:50 <ski> free graph on a set being the left adjoint to the underlying node set of a graph
01:19:16 <EvanR> oh 
01:19:46 <EvanR> how would i go about computing what that is
01:20:59 <ski> `Free S >---> G' should be equivalent to `S >---> U G', `S' a set, `G' a graph
01:21:51 <ski> so, any set function from `S' to the nodes of `G' should correspond to a graph morphism from `Free S' to `G', and vice versa
01:22:35 * hackagebot dixi 0.2.0.0 - A wiki implemented with a firm theoretical foundation.  https://hackage.haskell.org/package/dixi-0.2.0.0 (LiamOConnorDavis)
01:24:16 <EvanR> those two functors are equivalent? they have different source and targets...
01:24:49 <ski> they go in opposite directions, as any two functors in an adjoint situation would
01:25:02 <EvanR> whats Free?
01:25:18 <EvanR> whats the type of Free
01:25:24 <ski> it's the functor from `Set' to `Graph' that you're trying to determine
01:26:15 <EvanR> ok got it
01:26:42 <EvanR> what are >--->'s ?
01:26:52 <ski> morphism arrows
01:27:02 <ski> `hom's, if you prefer
01:27:03 <EvanR> ah... yeah theres like 4 kinds of arrows on my diagrams
01:27:24 <EvanR> so arrows in Graph and Set
01:27:35 * hackagebot console-program 0.4.0.0 - Interpret the command line and contents of a config file as commands and options  https://hackage.haskell.org/package/console-program-0.4.0.0 (AriePeterson)
01:27:41 <EvanR> what is the nature of Graph anyway?
01:27:45 <ski> `hom_Graph(Free S,G)' should be equivalent to `hom_Set(S,U G)'
01:28:06 <ski> pick any reasonable definition you like
01:28:53 <EvanR> an arrow in Graph means one graph is a subgraph of another?
01:29:16 <ski> e.g. : a graph consists of a set of nodes, and a binary relation on it
01:30:28 <EvanR> alright so U drops the relation and you have a set of nodes
01:30:40 <ski> and then a graph morphism from `(V_0,E_0)' to `(V_1,E_1)' consists of a function `f : V_0 >---> V_1' such that for any `x',`y' in `V_0', if `x E_0 y', then `f(x) E_1 f(y)'
01:31:33 <ski> so that each edge in the domain graph corresponds to an edge between the corresponding source and target vertices in the codomain graph
01:32:02 <ski> if you prefer undirected graphs, you could require that the edge relation is symmetric
01:32:37 <EvanR> alright 
01:32:59 <ski> if you prefer multi-graphs, you could instead have a set of edge( label)s, and a source and a target function from that to the vertex set, and modify the condition for morphisms appropriately
01:33:01 <EvanR> can we name these two functors in the adjuction
01:33:15 <EvanR> F and G
01:34:01 <EvanR> so im still not sure what equivalent means
01:34:01 <ski> if you prefer not thinking about edges from a vertex to itself, you could restrict to binary relations where you've cut away the diagonal
01:35:08 <ski> you can rename `Free' and `U' to `F' and `G', if you prefer
01:35:31 <EvanR> no nevermind
01:35:43 <ski> EvanR : it means at least that to every morphism in one morphism class, there should be a morphism in the other one, and vice versa
01:36:11 <osfameron> quicksilver: wait, what? what is this channel?
01:36:18 <ski> (the "natural" part of "naturalky isomorphic" means something more, but it needs *at least* that)
01:37:08 <ski> EvanR : you can e.g. consider the case `S = U G'
01:37:19 <EvanR> going by this diagram... 
01:37:49 <ski> and from that figure out what `Free S', iow `Free (U G)', must be
01:38:59 <EvanR> man all the letters are different from wikipedia
01:39:29 <EvanR> trying to come up with an equation from the diagram
01:39:41 <ski> ("an arrow in Graph means one graph is a subgraph of another?" -- no)
01:40:23 <EvanR> that wouldnt work?
01:40:33 <ski> (not even if they have the same vertex set, which would be required for "subgraph" to be meaningful)
01:41:37 <ski> there is a graph morphism from the graph with two vertices, and two edges going back and forth between them, to the graph with one vertex, and one self-edge on it
01:41:45 <ski> clearly the former is not a subgraph of the latter
01:42:25 <EvanR> using the standard setup right
01:42:36 * hackagebot console-program 0.4.0.1 - Interpret the command line and settings in a config file as commands and options  https://hackage.haskell.org/package/console-program-0.4.0.1 (AriePeterson)
01:42:45 <ski> using the first version i mentioned, yes
01:42:50 <EvanR> i was trying to invent a Graph category out of nowhere, not knowing the real one
01:44:28 <EvanR> so i named the arrows f and g... and by the definition of adjointness f = Free g . epsilon
01:44:31 <ski> if we'd only be considering a category of graphs with a common vertex set, then having morphisms correspond to the subgraph relation would be the natural thing to do
01:45:25 <EvanR> the fact that epsilon is a natural transformation has to be important somehow
01:45:44 <EvanR> or maybe i should use the other diagram
01:46:16 <EvanR> g = eta . U f
01:46:35 <ski> considering the case `S = U G', we'd want a bijection between `hom_Graph(Free (U G),G)' and `hom_Set(U G,U G)'
01:47:36 <EvanR> how did you get to S = U G
01:47:43 <ski> i assumed it
01:47:49 <ski> considering a special case
01:47:49 <EvanR> alright
01:48:34 <EvanR> so now we figure out what the particular bijection would be
01:49:06 <EvanR> hom_Set(U G, U G), endomorphisms among the graph nodes
01:49:27 <ski> a morphism in `hom_Set(U G,U G)' is *any* function on the vertex set, ignoring the edges completely
01:49:42 <EvanR> yeah
01:49:57 <EvanR> that should put some restrictions on the kind of things in hom_Graph
01:50:12 <ski> so if we're going to construct a graph morphism in `hom_Graph(Free (U G),G)' corresponding to it, that respects the edges in `Free (U G)', what does that tell us about the edges in `Free (U G)'
01:50:21 <ski> ?
01:51:03 <EvanR> the functions in hom_Graph(Free (U G), G) cant depend on the edges
01:51:04 <ski> take e.g. `U G' a set with two elements. there are four functions in `hom_Set(U G,U G)', so there should be four morphisms in `hom_Graph(Free (U G),G)'
01:51:55 <EvanR> yeah so what do those four functions do to the edges
01:52:00 <EvanR> im thinking
01:52:25 <ski> if `G' is the graph with an edge in one direction between the vertices, but not in the other, then any edge in `Free (U G)' would *have* to be translated to that one, by each graph morphism
01:52:36 * hackagebot luminance 0.5 - Type-safe, dependently-typed and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.5 (DimitriSabadie)
01:52:38 * hackagebot luminance-samples 0.5 - Luminance samples  https://hackage.haskell.org/package/luminance-samples-0.5 (DimitriSabadie)
01:53:18 <EvanR> just because theres only one
01:53:19 <ski> if `G' is the graph on two vertices, with no edges at all, then any edge in `Free (U G)' would have to be translated to an edge in `G', which doesn't exists. ergo, there are no edges in `Free (U G)'
01:54:12 <EvanR> right
01:54:28 <ski> note that `Free (U G)' only depends on the vertices in `G', not on any edges. so it would have to determine which graph it will be without knowing whether there *are* any edges in `G'
01:54:47 <ski> so `Free (U G)' will always be a graph with no edges
01:54:52 <EvanR> ok sort of like a polymorphism problem
01:55:12 <ski> now, every set `S' satisfies `S = U G' for *some* graph `G ..
01:55:19 <ski> what does that tell you ?
01:55:56 <EvanR> it tells me Free promots a set to graph with no edges
01:56:02 <EvanR> but i didnt get your reasoning
01:56:13 <ski> which part ?
01:58:50 <EvanR> ok were considering morphisms from Free (U G) to G. how do we get from that to the conclusion that this morphism cant depend on the edges of Free (U G)
01:59:41 <ski> it might be that `G' has no edges. then `Free (U G)' also can't have any edges
01:59:53 <EvanR> thats a special case
02:00:52 <ski> if `G2' is any graph with the same vertex set as `G' (iow `U G = U G2'), but possibly with edges, then `Free (U G2)' is equal to `Free (U G)', which we already know can't have any edges
02:01:08 <ski> so, `Free (U G)', for any graph `G', can't have nay edges
02:01:28 <ski> s/nay/any/
02:01:33 <EvanR> why is Free (U G2) equal to Fre (U G)
02:01:44 <ski> because `U G2' was equal to `U G'
02:01:51 <EvanR> oh
02:01:53 <ski> because `G2' and `G' had the same vertex set
02:01:57 <EvanR> apply Free to both sides
02:02:12 <EvanR> got it
02:02:14 <the_2nd> I want to implement a KdTree which is mutable
02:02:28 <the_2nd> since all implementations I saw keep rebuilding trees
02:02:39 <EvanR> so the Free graph is rather boring
02:02:44 <ski> yes :)
02:03:00 <ski> (free stuff tends to be more or less boring)
02:04:00 <EvanR> so we calculated this problem, but it appears that tons of machinery mentioned on wikipedia did not come up. only the bijections
02:04:11 <EvanR> and im not sure if they even mattered
02:04:34 <ski> there are several different formulations of what an adjoint situation means
02:04:53 <ski> one is the natural isomorphism between those two morphism classes
02:05:06 <ski> another is involving units and counits
02:05:41 <EvanR> we used the fact that for a given FX -> Y, theres a unique X -> GY
02:05:48 <ski> yes
02:06:01 <EvanR> and assumed that FX = GY
02:06:16 <ski> no, that `X = G Y'
02:06:30 <EvanR> er.... right
02:06:37 <EvanR> how was that justified?
02:06:49 <ski> it wasn't in general
02:07:06 <ski> we wanted some bound on how strange `F X' could be
02:07:48 <ski> it remains to be shown that "for a given FX -> Y, theres a unique X -> GY", but now we have an idea of what an `F' that could fit into this could look like
02:08:53 <EvanR> well G was forget the edges, so its clear that X existed
02:09:07 <ski> i suppose it's a bit like solving an equation, and you do some irreversable step, so that the solution set you get might contain false solutions. you know these are the only solutions that might work, but you still have to check that they do work
02:09:26 <EvanR> and it least had an identity morphism to itself
02:09:36 <ski> (in some cases, a left adjoint simply doesn't exist)
02:10:05 <ski> so, we tried to determine some info about `F', from the assumption that it existed
02:10:42 <EvanR> so if we use Free = no edges and U = forget edges, all you have to do is prove the natural isomorphism to prove Free and U are adjoint?
02:10:52 <ski> yes
02:11:56 <EvanR> wikipedia claimed that syntax and semantics are adjoint, so i expect there will be more interesting examples than this ;)
02:12:30 <ski> the left adjoint of the free graph on a set is at least a bit more interesting that this :)
02:13:00 <EvanR> i meant this = free graph
02:13:16 * ski nods
02:13:22 <ski> so did i
02:14:14 <EvanR> to find a natural isomorphism, you have to produce two natural transformations
02:16:26 <EvanR> to produce a natural transformation, you need a set of mappings of objects to arrows which obeys a law regarding the mapping of arrows to arrows
02:17:07 <EvanR> by the two functors, and the natural transformations "components"
02:17:35 <mrkgnao> I'm trying to run this code: https://hackage.haskell.org/package/sized-vector-1.4.2.0/docs/src/Data-Vector-Sized.html
02:17:35 <EvanR> etaY . F(f) = G(f) . etaX
02:17:48 <mrkgnao> (it's more or less a single-file package)
02:18:03 <mrkgnao> and I get this error about ambiguous instances:
02:18:15 <mrkgnao> http://lpaste.net/143192
02:18:52 <EvanR> i dont know why im trying to find a natural isomorphism... nevermind
02:19:48 <EvanR> i got lost on the criteria needed to be proven
02:19:49 <ski> you were trying to show `F X >---> Y' and `X >---> G Y' are isomorphism, naturally in `X',`Y'
02:20:00 <ski> s/isomorphism/isomorphic/
02:20:19 <ski> (i think)
02:20:35 <EvanR> for a given F X -> Y theres a unique X -> G Y. and vice versa
02:20:45 <EvanR> is there a better way to state that?
02:22:01 <mrkgnao> anyone? I'm getting some error about an ambiguous SingI instance.
02:22:31 <ski> EvanR : there is a bijection between the two ?
02:22:46 <EvanR> mrkgnao: n0 is an ambiguous variable... that happens when it cant tell which instance you want. you have to add a type annotation somewhere
02:22:54 <EvanR> ok
02:23:29 <EvanR> let f : Free S -> G
02:24:14 <Saizan> mrkgnao: you need to add some type annotation
02:24:45 <mrkgnao> could you tell me what to add? I've never used singletons before, actually, and I tried to jump in at the deep end by cloning a simple-looking package off Hackage :/
02:25:19 <EvanR> the unique S' -> U G' is
02:26:34 <EvanR> identity?
02:26:56 <Saizan> mrkgnao: you haven't shown your code
02:27:03 <mrkgnao> https://hackage.haskell.org/package/sized-vector-1.4.2.0/docs/src/Data-Vector-Sized.html
02:27:12 <mrkgnao> the entire package is just that one file
02:27:37 <ski> EvanR : basically
02:27:49 <Saizan> mrkgnao: but what code are you running in ghci?
02:27:55 <Saizan> mrkgnao: i.e. what command?
02:28:08 <EvanR> let g : S -> U G. the unique Free S' -> G' is
02:28:12 <ski> (pedantically speaking, you're forgetting the proofs of the preservation of edges under the morphism)
02:28:25 <mrkgnao> fromList' [0..4]
02:28:40 <ski> (not sure why you primed them, though)
02:28:44 <joco42> I've just moved a project to a new directory (which has a cabal sandbox) and now cabal tells me:
02:28:47 <mrkgnao> seems like there's some trouble in inferring the size.
02:28:52 <EvanR> why would they be the same object
02:28:53 <joco42> https://usercontent.irccloud-cdn.com/file/SvXdlKAz/Screen%20Shot%202015-10-17%20at%2012.28.09.png
02:29:07 <Saizan> mrkgnao: it cannot infer the size, you have to tell it
02:29:09 <joco42> how can i reconfigure the sandbox to use the new directory?
02:29:22 <ski> they're supposed to be the same set and the same graph, yes
02:29:23 <EvanR> because thats in the definition ah
02:29:31 <mrkgnao> ah.
02:29:40 <phaazon> http://i.imgur.com/Z6Gi9e6.jpg
02:29:51 <phaazon> hehe, luminance-sample on pluto! :P
02:30:01 <mrkgnao> is there any way I can write a function to convert an int to a type-level natural?
02:30:15 <phaazon> to a type-level?
02:30:18 <Saizan> mrkgnao: fromList' [0..4] :: Maybe (Vector Int 4) -- that might work, or replace 4 with (S (S (S (S Z))))
02:30:25 <EvanR> let g : S -> U G. the unique Free S -> G is the graph identify function
02:30:37 <EvanR> identity. so all edges end up in the same places
02:31:08 <EvanR> i dont think i gave too convincing an argument that this solution is unique
02:31:16 <mrkgnao> i.e. convert 3 to (S(S(S(Z)))), etc.
02:31:32 <mrkgnao> seems like there would be some problems with even writing the type of such a function
02:32:25 <ski> EvanR : "graph identity function" ?
02:32:30 <EvanR> it would be Int -> Nat but we dont have dependent types
02:33:00 <EvanR> ski: yeah?
02:33:53 <ski> `Free S' and `G' aren't known to be the same graph, so i'm not seeing how you could claim it to be an identity morphism
02:34:08 <mrkgnao> Saizan: neither worked.
02:34:18 <EvanR> why did it work before on setes
02:35:09 <EvanR> mrkgnao: theres an extension to type numeric literals instead of S S S S...
02:35:22 <mrkgnao> okay, wait.
02:36:02 <ski> if `f : Free S >---> G', then that means the morphism `f' maps the vertices of `Free S' (namely the elements of `S') to the vertices of `G' (namely `U G'), such that edges between vertices in `Free S' will correspond to edged between corresponding vertices in `G'
02:36:33 <ski> ignoring the "such that ..." part, we have a function from `S' to `U G', which is what you were looking for
02:37:31 <EvanR> S and U G end up being the same set
02:37:38 <EvanR> because they have the same elements
02:37:48 <ski> in some sense, you could say that you're using an identity function to go from `f : Free S >---> G' to `f : S >---> U G'
02:37:49 <EvanR> because Free S is G
02:38:06 <EvanR> er, Free S produces G's vertexes from S
02:38:21 <ski> (more pedantically, it's more like a projection, ignoring the proofs of the extra condition in `f' to only select the set function part)
02:39:07 <ski> "S and U G end up being the same set","because they have the same elements" -- huh ?
02:39:25 <ski> "because Free S is G","er, Free S produces G's vertexes from S" -- huh ?
02:40:07 <ski> `S' is any set and `G' is any graph. no relation between them assumed here, other than that we are assuming as given a graph morphism `f : Free S >---> G'
02:40:12 <EvanR> when i thought about what S -> U G would be, i thought about what S and U G were, and they seemed to be the same set, so i naturally just picked the identity function
02:40:35 <EvanR> yeah f implies S and U G are the same
02:40:47 <ski> we're not assuming `S = U G' here
02:41:01 <EvanR> i thought i conclused that, rather than assuming that
02:41:04 <EvanR> concluded
02:41:11 <ski> that was just for trying to work out how `Free S' could possibly look like
02:41:28 <EvanR> well im taking Free = promote to edgeless graph
02:41:31 <ski> "yeah f implies S and U G are the same" -- no
02:42:30 <EvanR> ok i misunderstood f... this is some arrow from Free S to some graph G
02:42:42 <EvanR> no relation
02:43:32 <ski> (when you talked about identity above, i first thought you were thinking of mapping `f : Free S >---> G' to `f : S >---> U G' as a kind of identity mapping in some sense .. as opposed to selecting `g : S >---> U G' as an identity morphism itself, which can't possibly work, since we don't know the domain and codomain to be equal)
02:43:55 <ski> EvanR : yep
02:44:47 <EvanR> let g : S -> U G (S and G known from before) be ... take S, apply Free... to get a G.. then apply U
02:45:04 <EvanR> no
02:45:27 <EvanR> apply Free then apply f
02:45:32 <EvanR> then apply U
02:45:42 <ski> currently you're trying to build a mapping from `Free S >---> G' to `S >---> U G' (or from `hom_Graph(Free S,G)' to `hom_Set(S,U G)', if you prefer), and also one in the opposite direction, so that they will be inverses of each other
02:46:49 <EvanR> mapping f = U . f . Free
02:46:58 <ski> then, you want to consider such a mapping as the morphism you get as the `(S,G)' "component" of a natural transformation, and similarly for the other one
02:47:19 <ski> (so you'll then need to check that they satisfy the naturality conditions)
02:48:28 <some0ne> hi
02:48:35 <ski> EvanR : "apply Free" sounds like nonsense here, to me
02:48:51 <ski> `Free' is not a morphism, that you can compose with `f' (a morphism)
02:48:57 <EvanR> oh
02:49:05 <EvanR> right
02:49:17 <some0ne> often i need to execute function that do not return value and print stuff. how can i force the evaluation of the function ? deepseq ?
02:49:20 <ski> you have a candidate definition of `Free'
02:50:04 <ski> you know that a graph morphism `f : Free S >---> G' consists of a function from the vertex set of `Free S' to the vertex set of `G', such that "edges correspond to edges"
02:50:57 <EvanR> not injectively though
02:51:16 <ski> what are you claiming isn't injective ?
02:51:23 <ski> `f' ?
02:51:23 <EvanR> a given f
02:51:33 <EvanR> it might merge edges
02:51:47 <ski> the underlying vertex function might or might not be injective
02:51:50 <ski> it doesn't matter
02:52:00 <EvanR> right
02:52:06 <ski> use your knowledge about the candidate definition of `Free S' here to work out what the vertex set of `Free S' is. formulate "the vertex set of `G'" explicitly as a set
02:53:03 <ski> using that, formulate what the domain and codomain set of the vertext mapping part of `f' is
02:53:19 <ski> s/vertext/vertex/
02:54:09 <EvanR> G is some graph with no edges
02:54:13 <ski> no
02:54:26 <EvanR> how?
02:54:28 <ski> `G' is any graph at all, possibly with edges, possibly not
02:54:51 <EvanR> how would f work
02:55:03 <EvanR> given the corresponding edges thing
02:55:16 <ski> every edge in `Free S' (all zero of them) would need to correspond to an edge in `G'
02:55:23 <EvanR> oh
02:55:33 <ski> there can still be edges in `G' that doesn't have an edge in `Free S' corresponding to it
02:55:48 <EvanR> then i know pretty much nothing about f
02:56:53 <EvanR> it sends the vertexes somewhere, thats it
02:57:17 <ski> the condition was : for all vertices `x' and `y' in `Free S', if `x E_{Free S} y', then `f(x) E_G f(y)'
02:57:33 <ski> `f' mapping vertices in `Free S' to vertices in `G'
02:57:55 <ski> `E_{Free S}' being the edge relation on `Free S'. `E_G' being the edge relation on `G'
02:58:04 <ski> EvanR : right
02:58:21 <the_2nd> https://github.com/ijt/kdtree/blob/master/Data/Trees/KdTree.hs recreates the entire tree on pretty much any operation
02:58:35 <the_2nd> how could I do something similar in a mutable fashion?
02:59:12 <ski> the above condition is what i expressed for short as "edges correspond to edges", and, slightly more detailed, as "edges between vertices in `Free S' will correspond to edged between corresponding vertices in `G'"
03:00:00 <EvanR> i get that part now, though it seems not matter right now as that implies nothing given no edges to start with
03:01:12 <EvanR> the vertex set of G is S
03:01:16 <EvanR> uhg
03:01:18 <EvanR> not even
03:02:12 <EvanR> its some set, but includes f v for all v in S
03:02:20 <pavonia> the_2nd: Not sure what these operations do exactly, but if you need to update only certain subtrees zippers might be solution
03:02:57 <the_2nd> pavonia, any example of that?
03:05:01 <pavonia> the_2nd: Have a look at http://learnyouahaskell.com/zippers
03:08:55 <the_2nd> pavonia, looking good, gonna read it
03:09:59 <ski> EvanR : "seems not matter right now as that implies nothing given no edges to start with", ues
03:10:02 <ski> yes
03:10:44 <ski> EvanR : the vertex set of `G' is the underlying set of `G'
03:11:08 <EvanR> sure
03:11:16 <ski> the_2nd : which operation recreating the entire tree are you thinking about ?
03:11:42 <ski> `remove' ?
03:12:33 <EvanR> ok g : S -> U G is f restricted to only caring about vertexes
03:12:47 <the_2nd> ski e.g. yep
03:12:51 <the_2nd> also knearest uses remove
03:12:57 <the_2nd> to remove already found nodes
03:13:08 <the_2nd> which results in a rebuild for each found nearest neighbor
03:14:25 <the_2nd> using that tree is currently slower than calculating each distance for my input
03:14:32 <the_2nd> which is less than great
03:14:53 <ski> the_2nd : possibly you could reformulate it to select some point in the left or right subtree as the point to use is a new root, while preserving the `allSubtreesAreValid' property ?
03:15:24 <ski> the_2nd : so that you can avoid `fromListWithDepth (toList l ++ toList r) axis' rebuilding the whole tree
03:15:36 <ski> EvanR : right
03:16:16 <the_2nd> yeah, maybe
03:16:29 <the_2nd> ski, thats the tree which shows up most when searching for one
03:16:34 <the_2nd> and it seems rather terrible
03:16:43 <ski> the_2nd : that's what one would typically try to do with trees in a situation like this
03:17:01 <EvanR> also thats the only possibility because i have no other info on f or G to customize the morphism
03:17:06 <EvanR> starting with such a g : S -> U G, then f : Free S -> G is ... 
03:17:33 <ski> the_2nd : if you can do that sensibly, only a logarithm of the number of nodes in the tree should need to be rebuilt here, which should probably improve your performance
03:18:20 <ski> the_2nd : there's also a few minor points i could comment on in your code, if you'd care to hear them
03:18:45 <ski> (but if you're prepared to throw the code away, possibly you're not interested in improvements to it)
03:19:03 <the_2nd> ski, not my code, its the KdTree on hackage
03:19:13 <ski> oh, i see
03:20:07 <anks> Hello, i've got an issue with parsing raw bytes from file, I got this custom data formats with numbers encoded as raw bytes, and i want to convert it to a human readable format
03:20:27 <anks> how can i parse ByteString so as it would be possible
03:20:42 <EvanR> f is defined as g for the vertices, and whatever the edges behavior is determined automatically and also doesnt matter
03:21:07 <pavonia> anks: attoparsec is one way
03:21:16 <anks> yes, I already have it parsed
03:21:38 <anks> but then how can I make ByteString to be interpreted as numbers
03:22:22 <the_2nd> ski, I could improve it, tho
03:22:34 <the_2nd> I only need the build method and the knearest
03:22:51 <EvanR> anks: the ByteString operation unpack gives you a list of Word8
03:23:00 <EvanR> which are numbes
03:24:09 <anks> thanks, do you know whether a function with type: [word8] -> Integer exists then?
03:24:30 <EvanR> theres a lot of functions like that
03:24:35 <EvanR> which one are you thinking of
03:24:38 <ski> the_2nd : anyway, i'd consider doing `dimension :: Proxy p -> Int' instead, `(Point p) =>' could be `Point p =>', i'd define `foldMap' instead of `foldr' in the instance for `Foldable', `\a b -> coord axis a `compare` coord axis b' is `comparing (coord axis)', instead of `take'&`drop', use `splitAt', `subtrees' should avoid left-associating `++' (inefficient), `toList' in `isValid' could be removed, `aribtrary = liftA3 Point3d arbitrary arbitrary arbitrary'
03:24:57 <ski> hm, cut off near ".., `toList' in `isValid' could be removed, `aribtrary = liftA3 Point3d arbitrary arbitrary arbitrary'"
03:25:04 <EvanR> @hoogle [Word8] -> Integer
03:25:05 <lambdabot> Data.List genericLength :: Num i => [b] -> i
03:25:06 <lambdabot> Data.Fixed resolution :: HasResolution a => p a -> Integer
03:25:06 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
03:25:17 <anks> EvanR: it'be toInteger
03:25:19 <EvanR> unsafeCoerce, helpful
03:25:31 <EvanR> anks: no, that wouldnt work, wrong type
03:25:32 <the_2nd> ski, could you paste that somewhere first? rather difficult to follow. appreaciate the effort, tho
03:25:36 <ski> the_2nd : i haven't looked at `nearestNeighbor',`nearNeighbors' yet
03:25:36 <anks> Word8 is an instance of Integral
03:25:44 <EvanR> anks: you said [Word8] -> Integer
03:25:45 <anks> right
03:25:45 <anks> ..
03:26:25 <EvanR> fromIntegral on your Word8s will give you whatever integral Num type you want
03:26:38 <EvanR> but thats word by word
03:26:47 <EvanR> :t fromIntegral
03:26:48 <lambdabot> (Integral a, Num b) => a -> b
03:26:49 <anks> Yea, i get it ;]
03:27:49 <anks> that's inconvenient..
03:28:00 <EvanR> anks: depending on how you think this should work, you probably need to go back to your parser and properly parse this number
03:28:05 <ski> EvanR : "f is defined as g for the vertices" -- yes, "and whatever the edges behavior is determined automatically" -- yes, "and also doesnt matter" -- no, it must satisfy the "respects edges" condition, otherwise it won't be a graph morphism
03:28:44 <ski> EvanR : so, (a) show these are inverses; (b) show how to extend these two to natural transformations, by showing naturality
03:28:52 <EvanR> your definition of a graph morphism doesnt seem to leave any room to decide what the edges do, its up to where the vertices go
03:29:15 <anks> EvanR: thanks, ill go this way then, cheers
03:29:49 <ski> `f' would consists of a vertex mapping, selected as `g', and a proof that it respects edges
03:30:40 <ski> since there's no edges in (the candidate) `Free S', it's trivial that it respects edges. but you still need to note this. conceptually that proof is part of the definition of `f'
03:31:40 <EvanR> no... the function isnt defined only for some graphs that happen to have no edges
03:31:51 <ski> the_2nd : paste my message somewhere ?
03:32:02 <EvanR> and the edge respection seems to be based into the definition of graph morphism
03:32:06 <EvanR> baked
03:32:36 <ski> `G' may have edges. `Free S' has no edges. every edge in `Free S' has to correspond to an edge in `G', via `g' mapping their sources and targets
03:33:03 <ski> EvanR : yes
03:33:38 <ski> (to the latest sentence of yours)
03:33:50 <EvanR> so i cant see a possible way any function that describes what to do with vertexes to ever violate the edge respection
03:34:05 <ski> right
03:34:08 <EvanR> so i must be misunderstanding
03:34:59 <EvanR> alright well i was thinking about how to show inversness
03:35:01 <ski> "also doesnt matter" suggests that there's some choice you could take here, that actually doesn't matter
03:35:05 <ski> there is no choice here
03:35:43 <EvanR> no that just meant that the auto edge mapping wouldnt matter since there are none
03:36:04 <ski> (or else it suggests that there's some part of the reasoning that's irrelevant to the construction. which also wasn't the case)
03:36:23 <EvanR> its meta, that part of my message itself didnt matter
03:36:51 <ski> i'd submit that the edge mapping *does* matter, since otherwise you don't have a graph morphism
03:37:22 <ski> it's just that edges mapping appropriately is trivial here, due to `Free S' having no edges. it still matters
03:37:31 <EvanR> so i need a lemma, any mapping that has rules for its vertices is automatically a graph morphism?
03:37:49 <EvanR> if not, thats what im confused about
03:37:59 <ski> possibly i'm just pedanticing on the formulation of what you said
03:38:38 <EvanR> to show that my plans are inverses, im having trouble keeping track of what exactly they do or what to call them
03:39:11 <ski> "so i need a lemma, .. ?" -- no. just note that `g' trivially respects edges, since `Free S' has no edges
03:39:38 <EvanR> >_> that makes no sense
03:39:43 <EvanR> you can prove that like that
03:39:47 <EvanR> cant*
03:40:11 <EvanR> (+) is commutative because 0+0=0 and 0+0=0 ?
03:41:01 <EvanR> im still not really communicating something right i guess: how could any function not obey the edge rules
03:41:03 <ski> if you want to be more detailed, you can spell out what it would mean for `g' to respect edges. note that it's in the form of "for all vertices `x' and `y' in `Free S', ..`x'..`y'..", and claim that that is trivially/vacuously true since the set of vertices on `Free S' is empty
03:41:26 <ski> s/edges. note/edges, note/
03:41:51 <the_2nd> ski, pastebin or something?
03:42:34 <EvanR> well were on totally different wavelengths now about graph morphisms ;)
03:42:54 <ski> every function `g : S >---> U G' must obey the edge rules. you should make it clear that you have understood this (and why it is true). doing so is part of defining the `f : Free S >---> G' graph morphism
03:42:59 <EvanR> youre talking about something that either i think is ridiculous or else an incorrect proof technique
03:43:14 <EvanR> ridiculously obvious*
03:43:32 <ski> sure, it's ridiculously obvious :)
03:43:50 <ski> conceptually it needs to be there, though. it's not a redundant detail
03:44:08 <EvanR> somehow using the non existence of edges seems wrong
03:44:17 <EvanR> but ok
03:45:12 <ski> how much you want to spell it out in your proof is up to you. but i'd at least make it clear that you're aware that it's needed to be argued for, even if only to claim that it's obvious
03:45:18 <EvanR> i still detect your not understanding me. every function g : G1 -> G2 must obey the edge rules
03:45:30 <EvanR> when defined for its vertexes only
03:45:35 <EvanR> not just U G
03:45:55 <ski> the_2nd : i'm not sure what good it would do to repeat my message "the_2nd : anyway, i'd consider doing `dimension :: Proxy p -> Int' instead, .." at a pastebin site ?
03:46:46 <ski> any statement of the shape `forall x : A. ..x..', with `A' the empty set, is trivially/vacuously true
03:46:52 <EvanR> i know that
03:46:54 <ski> any statement of the shape `exists x : A. ..x..', with `A' the empty set, is trivially/vacuously false
03:47:12 <ski> then i don't understand your "somehow using the non existence of edges seems wrong"
03:47:23 <k0ral> Hello
03:47:41 * hackagebot console-program 0.4.0.2 - Interpret the command line and settings in a config file as commands and options  https://hackage.haskell.org/package/console-program-0.4.0.2 (AriePeterson)
03:48:21 <EvanR> i get that now, because the codomain has no edges. i thought you were talking about f
03:48:32 <ski> every graph morphism `g : G1 >---> G2' must have an underlying function from `U G1' to `U G2' that obeys the edge rules, yes
03:48:36 <k0ral> while writing quickcheck property checkers, I'm running into 2 issues
03:48:49 <EvanR> smh
03:48:56 <ski> s/codomain/domain/
03:49:39 <k0ral> how do you check properties on polymorphic functions ? I need to generate somehow arbitrary objects of a polymorphic type 'a'
03:49:45 <ski> i was talking about needing to ensure `g : S >---> U G' respecting edges, in order to be able to turn this `g' into an `f : Free S >---> G'
03:49:47 <EvanR> i guess i misunderstand what a graph morphism consists of still
03:50:35 <ski> a graph morphism `f : G0 >---> G1' consists of a function from the vertex set of `G0' to the vertex set of `G1', respecting edges
03:50:36 <k0ral> for example, say f :: a -> b is the inverse of g :: b -> a, how do you check that f . g = id ?
03:51:32 <EvanR> so it cant move edges, create edges, or delete edges, or really say anything about edges
03:51:37 <ski> (if that function is named `g', then "respecting edges" means "for any vertices `x',`y' in `G0', if `x E_G0 y', then `g(x) E_G1 g(Y)'", `E_G0' being the edge relation on `G0' and `E_G1' the edge relation on `G1')
03:51:47 <EvanR> but it has to place vertexes in a way that they are still connected
03:51:59 <m1dnight_> Does anyone happen to know if there is a major mode for Alex and/or Happy in emacs?
03:52:02 <m1dnight_> I cant seem to find one.
03:52:32 <EvanR> alright so i see how its possible to make a bad function
03:52:54 <EvanR> and why you need an argument for why the vertex function is valid
03:52:56 <ski> k0ral : use `A',`B' from `Test.QuickCheck.Poly' instead of `a',`b'
03:53:27 <EvanR> (again)
03:54:45 <ski> "but it has to place vertexes in a way that they are still connected" -- it has to associate connected vertices to connected vertices, yes
03:55:04 <ski> (i don't really understand "it cant move edges, create edges, or delete edges, or really say anything about edges")
03:55:22 <EvanR> its not a function that moves edges
03:55:37 <ski> i'm not sure what "moves edges" would mean
03:56:15 <EvanR> me neither, unless the source and destination sets were the same
03:56:27 <ski> if you're using a set of edge labels (allowing multi-edges), instead of a relation, then you'd indeed have one function mapping vertices, and one mapping edges (edge labels, if you prefer), and these have to agree
03:56:51 <k0ral> ski: thanks, this is exactly what I need, now my 2nd issue:
03:56:58 <ski> then i suppose you could say this edge-mapping function "moves edges"
03:57:42 * hackagebot mustache 0.3.0.1 - A mustache template parser library.  https://hackage.haskell.org/package/mustache-0.3.0.1 (justus)
03:57:46 <k0ral> how do you generate arbitrary functions ? (meaning `instance Arbitrary (a -> b) where ...`)
03:57:57 <ski> k0ral : just generate them ?
03:58:10 <EvanR> ok given g, let f be g and its valid because the input graph cant have edges so the criteria is satisfied by default
03:58:31 <ski> k0ral : `instance (CoArbitrary a, Arbitrary b) => Arbitrary (a -> b)' is the relevant instance
03:59:07 <ski> EvanR : right
03:59:22 <jophish> I have this table of functions in my code. Obviously there's a structure here, what elegant ways can people think of for generating this table, any neater ones than just pasting it verbatim? http://lpaste.net/143196
03:59:29 <k0ral> ski: okay, obviously I am quite tired, this was right in front of my eyes and I didn't see it; thank you for the pointers, sorry for the noise
03:59:43 <ski> EvanR : or, if you want to be more explicit about proofs, you could say that `f = (g,p)', where `p' is the proof that "the criteria is satisfied"
04:00:26 <ski> (you don't need to think of proofs as objects here. i just find it to be an interesting way to look at it)
04:00:39 <ski> k0ral : no worry
04:01:09 <EvanR> so this defines two families of functions which map arrows to arrows
04:01:17 <EvanR> and im lost
04:01:59 <EvanR> because i have no idea what flavor of object i was dealing with
04:02:37 <breadmonster> Hello EvanR 
04:03:15 <EvanR> hello sailor
04:03:29 <lyxia> jophish: does it have to be in the same order?
04:03:34 <ski> you want to define `eta : hom_Graph(Free -,-) >---> hom_Set(-,U -)' and `epsilon : hom_Set(-,U -) >---> hom_Graph(Free -,-)', so to speak
04:03:55 <jophish> lyxia: yeah, the ordering is important
04:04:24 <EvanR> just to clarify, hom_Graph(X,Y) is the set of arrows?
04:04:30 <EvanR> from X to Y
04:04:43 <EvanR> in which case what category is >---> in, SeT?
04:04:49 <ski> you know that `eta_(S,G) : hom_Graph(Free S,G) >---> hom_Set(S,U G)' is going to correspond to the mapping from `f' to `g' above, and `epsilon_(S,G) : hom_Set(S,U G) >---> hom_Graph(Free S,G)' to the mapping from `g' to `f' above
04:05:32 <EvanR> yes
04:05:32 <ski> `hom_Graph(G0,G1)' is the class of graph morphisms from `G0' to `G1', yes. also written `G0 >---> G1'
04:05:56 <EvanR> so thats sort of meta category notation
04:06:15 <ski> i suppose you could say
04:07:01 <lyxia> jophish: let fs' = [ sign . trig . shift | sign <- [id, negate], (trig, shifts) <- [(sinBounded, [subtract piBy4, id]), (cosBounded, [(piBy4 -), id])], shift <- shifts ] in last fs' ++ init fs'
04:07:26 <EvanR> that would be three overloads of >---> for being so hard to type ;)
04:07:26 <jophish> yeah, that was pretty much what I could come up with
04:07:33 <lyxia> jophish: Doesn't look much clearer than the hard coded list :/
04:07:45 <EvanR> ok eta, epsilon
04:07:58 <ski> `hom_Graph(Free -,-)' is the functor that maps an object `(S,G)' of `Set^op * Graph' to the class of morphisms from `Free S' to `G' in `Graph
04:08:19 <ski> `hom_Set(-,U -)' is the functor that maps an object `(S,G)' of `Set^op * Graph' to the class of morphisms from `S' to `U G' in `Set'
04:08:54 <jophish> thanks anyway lyxia :D
04:08:56 <EvanR> whats the Set^op for
04:09:10 <ski> because it's covariant in `S'
04:09:32 <lpaste> Gurkenglas annotated “No title” with “jophish, meh.” at http://lpaste.net/143196#a143198
04:09:34 <EvanR> oh (S,G) is something.. not a tuple
04:09:46 <ski> `hom_Graph' is a functor from `Graph^op * Graph' to `Set'
04:09:49 <ski> it's a tuple
04:10:10 <Gurkenglas> jophish, maybe if we knew more about sindBounded and cosBounded...
04:10:14 <Gurkenglas> -d
04:10:17 <ski> the objects of `C^op' are the same as the objects of `C', for any category `C'
04:10:20 <EvanR> so what is >---> between hom-set-functors
04:10:53 <ski> part of the notation for a natural transformation
04:11:03 <EvanR> ok
04:11:18 <ski> in general, `eta : F >---> G', with `F,G : C >---> D'
04:12:07 <ski> you can conceive of `F' and `G' as being objects in the functor/exponential category `D^C', and then `eta' is simply a morphism between the objects `F' and `G' in this categoty
04:12:19 <ski> so `>--->' really is a morphism arrow in this case as well :)
04:12:40 <EvanR> i figured there would be a way to say that
04:13:03 * ski smiles
04:13:12 <jophish> Gurkenglas: sure, http://lpaste.net/143199
04:13:23 <jophish> They're just sin and cos as evaluated by a power series
04:15:25 <jophish> hmm, now that I think about it, the ording is important, but it could start anywhere in the sequence, Gurkenglas lyxia 
04:17:06 <EvanR> i have to sleep
04:17:18 <EvanR> thanks for the help
04:17:23 <ski> EvanR : so .. you need to show something like `hom_Set(g,U f) . eta_(S0,G0) = eta_(S1,G1) . hom_Graph(Free g,f)', with `f : G0 >---> G1' and `g : S1 >---> S0'
04:17:43 * hackagebot network-carbon 1.0.6 - A Haskell implementation of the Carbon protocol (part of the Graphite monitoring tools)  https://hackage.haskell.org/package/network-carbon-1.0.6 (OliverCharles)
04:17:54 <ski> EvanR : ok. yw
04:19:14 <ski> the_2nd : any luck ?
04:23:38 <lpaste> evren pasted “parse error on input `='” at http://lpaste.net/143201
04:30:34 <lpaste> ptcek annotated “parse error on input `='” with “parse error on input `=' (annotation)” at http://lpaste.net/143201#a143203
04:34:01 <pavonia> Today's lesson: Making IRC  people help you with code errors without actually connecting to IRC
04:34:46 <suppi> pavonia, heh, the user is actually on a different channel
04:35:00 <pavonia> Ah :)
04:52:18 <the_2nd> ski, switching to c++ xD
04:53:11 <ski> the_2nd :/
04:59:09 <the_2nd> ski, functional, immutable approach seems super nice for many things
04:59:23 <the_2nd> but for really dynamic data it just seems unreasonable to me
05:00:16 <ski> if you really want to, you can do ephemeral data structures in Haskell as well
05:01:56 * ski isn't sure what the_2nd's goal is here, though
05:11:26 <the_2nd> ski, some 2d numeric application
05:11:49 <the_2nd> I already had some quite strong libs in c++ and moved them to haskell to get in touch with it
05:12:00 <ski> and you wanted to learn some more Haskell, while doing it ?
05:12:15 <the_2nd> yes
05:12:29 <ski> i'd first suggest fixing `remove' as i suggested
05:12:57 <ski> if that isn't satisfactory, only then would i consider using a mutable, ephemeral version
05:14:02 <the_2nd> sure
05:14:56 <the_2nd> g2g now, tho
05:15:04 <the_2nd> thank you for your time and help
05:15:10 <the_2nd> highly appreciate it
05:58:32 <phaazon>       with type: M44 Float -> (t0 -> GHC.Ptr.Ptr a0 -> ()) -> IO ()
05:58:35 <phaazon> wtf?!?!
05:58:44 <phaazon> I’m using with, from Foreign.Marshal.Util
05:58:58 <phaazon> the type of the function is weird
05:59:00 <phaazon> it should be IO ()
05:59:03 <phaazon> why is it unit?!
06:04:14 <hexagoxel> icedev: do you compile with -threaded ?
06:05:06 <phaazon> hexagoxel: hm?
06:05:10 <phaazon> nevermind :D
06:06:09 <hexagoxel> phaazon: you have to scroll far back up to see the original question i just noticed :D
06:08:31 <phaazon> :)
06:08:37 <phaazon> I just have a very weird behavior
06:08:46 <phaazon> I have a function that runs in IO
06:08:52 <phaazon> and when partially applying it
06:09:02 <phaazon> GHC tells me it expects it in ()
06:09:05 <phaazon> that doesn’t make any sense
06:09:10 <phaazon> is this a GHC bug?!
06:10:02 <phaazon> http://lpaste.net/2828704347779497984
06:10:06 <phaazon> wtf is that specialization thing
06:12:28 <hexagoxel> phaazon: if `m0` is `(->) GHC.Ptr.Ptr b0`, then `m0 ()` is `GHC.Ptr.Ptr b0 -> ()`
06:14:32 <notdan> hm, stack doesn't want to rebuild my project even though i changed a file
06:14:33 <notdan> weird
06:14:54 <hexagoxel> phaazon: (and that replacement simply is "specializing m0")
06:16:10 <phaazon> hexagoxel: hm
06:16:48 <phaazon> fixed, thanks :D
06:22:35 <aweinstock> does stack/ghc-pkg have an equivalent to "cabal list $SEARCHTERM"?
06:23:59 <hexagoxel> ghc-pkg has list .. (?)
06:26:16 <phaazon> is there a simple way to know which version of a dependency is getting used?
06:26:47 <phaazon> hm, -v3 sounds to give that
06:27:43 <hexagoxel> `cabal freeze --dry-run` might work as well
06:28:01 <phaazon> oh, yeah
06:28:03 <phaazon> thanks :)
06:28:11 <phaazon> very cool command
06:33:17 <notdan> uh stack won't detect any changes to one of my source files
06:33:52 <aweinstock> hexagoxel: "ghc-pkg list" only searches things that are already installed, "cabal list" searches hackage
06:34:29 <aweinstock> hexagoxel: basically, is there an command-line hackage client included in stack/ghc-pkg?
06:35:18 <tsahyt> notdan: Is this a permanent problem or something that just occured once? You can force a recompile using --force-dirty
06:36:07 <notdan> tsahyt: doesn't recognize that flag; probably I have an outdated stack version
06:37:18 <tsahyt> notdan: I'm on 0.1.6.0 here. The flag works on the build command, so it's `stack build --force-dirty`
06:37:57 * hackagebot toolshed 0.16.0.0 - Ill-defined library.  https://hackage.haskell.org/package/toolshed-0.16.0.0 (AlistairWard)
06:37:59 * hackagebot factory 0.2.1.2 - Rational arithmetic in an irrational world.  https://hackage.haskell.org/package/factory-0.2.1.2 (AlistairWard)
06:38:10 <notdan> 0.1.2 here. Probably should upgrade :P
06:43:10 * hackagebot fishfood 0.0.1.5 - Calculates file-size frequency-distribution.  https://hackage.haskell.org/package/fishfood-0.0.1.5 (AlistairWard)
06:43:12 * hackagebot squeeze 1.0.4.8 - A file-packing application.  https://hackage.haskell.org/package/squeeze-1.0.4.8 (AlistairWard)
06:48:11 * hackagebot regexdot 0.11.1.2 - A polymorphic, POSIX, extended regex-engine.  https://hackage.haskell.org/package/regexdot-0.11.1.2 (AlistairWard)
06:48:13 * hackagebot regexchar 0.9.0.13 - A POSIX, extended regex-engine.  https://hackage.haskell.org/package/regexchar-0.9.0.13 (AlistairWard)
07:06:51 <itsmeyo> is there anyway to use binary functions in map? For example instead of doubles xs = map double xs where double x = 2*x, can I do something like doubles xs = map (product 2) xs
07:07:25 <tsahyt> itsmeyo: You can use partial application, like map (*2) xs
07:07:27 <exio4> itsmeyo: map (*2) xs should work there
07:08:08 <itsmeyo> oh ok thanks
07:09:01 <Nuxular> Hi, I'm having an odd issue which is causing what appears to be non-termination. What's the easiest way to inspect the process to see what it's busy doing?
07:09:47 <itsmeyo> seeing as the definition of map f xs = [f x | x <- xs], why does both (2*) and (*2) work? Shouldn't only the former work, because *2 4 wouldn't make sense whereas 2*4 would
07:10:26 <tsahyt> itsmeyo: The place of the argument determines whether it's passed as the first or second argument to (*). Since multiplication is commutative it doesn't matter in this case
07:10:42 <tsahyt> https://wiki.haskell.org/Section_of_an_infix_operator
07:10:48 <Big_G> How can I compose two functions of (a->b->c) and (c->d)?
07:10:55 <hpc> itsmeyo: try it with (2 /) and (/ 2)
07:11:21 <hpc> itsmeyo: (don't do subtraction, '-' has silly parsing rules)
07:11:45 <Nuxular> itsmeyo, don't read (*2) 4 as equivalent to *2 4
07:12:36 <itsmeyo> Nuxular: ok, that's fair
07:12:53 <Nuxular> itsmeyo, think of (*2) as syntactic sugar for (\x -> x*2)
07:13:11 <suppi> Big_G, searching hayoo gave me this: http://hackage.haskell.org/package/pointless-fun-1.1.0.6/docs/Data-Function-Pointless.html#v:.:
07:13:31 <suppi> Big_G, but I would just throw a lambda there
07:13:42 * hackagebot irc-fun-messages 0.2.0.0 - Types and functions for working with the IRC protocol.  https://hackage.haskell.org/package/irc-fun-messages-0.2.0.0 (akrasner)
07:13:44 * hackagebot logic-classes 1.5.3 - Framework for propositional and first order logic, theorem proving  https://hackage.haskell.org/package/logic-classes-1.5.3 (DavidFox)
07:13:46 * hackagebot settings 0.2.1.0 - Runtime-editable program settings.  https://hackage.haskell.org/package/settings-0.2.1.0 (akrasner)
07:15:09 <ggole> @pl \f g a b -> g (f a b)
07:15:10 <lambdabot> flip ((.) . (.))
07:15:17 <ggole> Always with the owl eyes.
07:15:48 <Nuxular> I've no idea why my program fails to terminate and would like an easy way to inspect what it's busy doing. Any suggestions?
07:16:38 <Nuxular> I'm hoping I won't have to pollute my functions with IO nastiness just to get some debug info
07:16:43 <suppi> Nuxular, I don't really know, maybe debugger? https://www.youtube.com/watch?v=1OYljb_3Cdg
07:17:32 <Nuxular> suppi, cheers. I'm watching it now.
07:17:44 <aweinstock> Nuxular: Debug.Trace.trace
07:17:49 <aweinstock> :t Debug.Trace.trace
07:17:50 <lambdabot> String -> a -> a
07:17:57 <aweinstock> :t Debug.Trace.traceShowId
07:17:58 <lambdabot> Show a => a -> a
07:18:02 <ggole> Wait, have I got that backwards?
07:18:09 <ggole> @pl \f g a b -> f (g a b)
07:18:09 <lambdabot> (.) . (.)
07:18:13 <ggole> Hmph.
07:18:57 <suppi> Debug.Trace can also be a great way
07:18:58 * hackagebot irc-fun-client 0.3.0.0 - Another library for writing IRC clients.  https://hackage.haskell.org/package/irc-fun-client-0.3.0.0 (akrasner)
07:19:08 <suppi> but may not always work, depending on laziness stuff
07:24:05 <itsmeyo> is there a pass equivalent in haskell?
07:24:18 <exio4> "pass"? 
07:24:30 <itsmeyo> for example if I have 2 guards but I want otherwise to just continue doing the function
07:24:43 <ChristianS> itsmeyo: you can use 'undefined'
07:25:14 <ChristianS> itsmeyo: though that'll throw an error if its actually executed
07:25:26 <ChristianS> in monadic context: return ()
07:25:27 <itsmeyo> oh
07:25:41 <ChristianS> (uh, maybe)
07:26:38 <itsmeyo> ive got it sorted now anyway, thanks
07:39:29 * hackagebot irc-fun-bot 0.4.0.0 - Library for writing fun IRC bots.  https://hackage.haskell.org/package/irc-fun-bot-0.4.0.0 (akrasner)
07:43:51 <John[Lisbeth]> What advantages does haskell have over programming purely functionally in common lisp?
07:45:29 <aweinstock> John[Lisbeth]: less parenthesis, and you still keep the power of defmacro via Template Haskell
07:45:59 <John[Lisbeth]> Can haskell deal with objects like Lisp can?
07:46:16 <John[Lisbeth]> As in handle c# objects most importantly.
07:49:49 <pavonia> Does Lisp have ASTs?
07:50:25 <chef__> Aren't Lisp s-expressions _the_ AST?
07:50:28 <pavonia> Beacuse that's really one of my favourite features of Haskell
07:51:55 <John[Lisbeth]> My application is running haskell inside of docker in microsoft azure virtual machines.
07:52:40 <icedev> hexagoxel: problem was already solved; yes i did forkOS before (with -threaded) with the same result in my case - but was more a simple issue in my code
07:54:09 <KaneTW> John[Lisbeth]: if you want to deal with .net haskell might not be the best choice
07:54:29 * hackagebot pathtype 0.5.5 - Type-safe replacement for System.FilePath etc  https://hackage.haskell.org/package/pathtype-0.5.5 (HenningThielemann)
07:54:31 <KaneTW> while it's possible i doubt it'll be easy or comfortable
07:54:32 <reactormonk> Looking for String -> IO String - just wrap it in an IO monad, without actual IO
07:54:45 <aweinstock> reactormonk: return
07:54:50 <reactormonk> aweinstock, thanks
07:55:01 <reactormonk> aweinstock, how come the name btw?
07:55:13 <Nuxular> thanks suppi, aweinstock. trace was useful
07:55:31 <chef__> John[Lisbeth], why not F#?
07:55:38 <KaneTW> historical reasons mostly reactormonk 
07:55:54 <KaneTW> also, i'd use pure just because it has a better name and does the same thing (as long you can require ghc >= 7.10)
07:56:13 <MarcelineVQ> What's the historical reason?
07:56:54 <KaneTW> i remember reading something about it in the monad of no return thread on haskell-cafe
07:57:05 <KaneTW> sec
07:57:40 <John[Lisbeth]> KaneTW, must make linux technology superior to .net technology, even if I have to build it in microsoft azure.
07:58:15 <Nuxular> suppi, aweinstock: I had two functions that were two methods of finding the same result. One terminated and the other didn't. I was debugging the function that didn't terminate to see where it was going wrong. As it turns out, I was applying both functions outside of their valid range so, in a way, it was the one that terminated that was more wrong for giving a result at all. :D
07:59:28 <Nuxular> at least the non-terminating one highlighted there was an issue
08:02:23 <KaneTW> MarcelineVQ: i can't find the actual reasons apart from a reference to "historical reasons"
08:03:08 <Tuplanolla> Looks like mod' from Data.Fixed is excruciatingly slow. What can I use to get the fractional part of a Double instead?
08:04:39 <aweinstock> reactormonk: what do you mean?
08:05:34 <aweinstock> Nuxular: is this for something numeric?
08:05:43 <KaneTW> Tuplanolla: decodeFloat with some added math to adjust base
08:06:26 <Gurkenglas> rat
08:06:32 <Tuplanolla> Apparently Data.Fixed converts the Double into a Rational first.
08:06:40 <KaneTW> yes, and that's very slow
08:06:41 <Gurkenglas> Sorry, wrong alt-tab.
08:07:58 <Tuplanolla> Do I really need to make this most basic thing myself?
08:08:15 <KaneTW> there's probably a fractional function somewhere
08:08:28 <KaneTW> i assumed it was an exercise because you did it using mod'
08:08:42 <Tuplanolla> No. I'm doing molecular dynamics.
08:09:03 <Tuplanolla> I want to enforce periodic boundary conditions.
08:11:16 <KaneTW> :t significand 
08:11:17 <lambdabot> RealFloat a => a -> a
08:11:24 <KaneTW> > significand 3.5
08:11:26 <lambdabot>  0.875
08:11:35 <KaneTW> ok that's not it
08:13:22 <KaneTW> i can't find anything but i can't believe there's no such function somewhere 
08:13:51 <Tuplanolla> I postulate no such thing exists. Wrapping C functions doesn't count.
08:17:19 <Tuplanolla> I need one regardless.
08:17:48 <hexagoxel> Tuplanolla: if you find/invent anything, ping me pls.
08:18:41 <John[Lisbeth]> Why doesn't wrapping c functions count if haskell is based in C?
08:20:11 <hpc> well first, you want it to be fast and there's overhead to foreign calls
08:21:23 <hpc> also haskell isn't based on C
08:21:52 <kallisti> anyone here familiar with vinyl?
08:22:45 <Gurkenglas> Tuplanolla, do you just mean the part after the decimal dot, "(`mod'` 1)"? "x - fromIntegral (floor x)".
08:23:14 <kallisti> have a question about this vinyl example https://github.com/VinylRecords/Vinyl/blob/master/tests/Intro.lhs: if I want to use names that aren't SName, SAge, ... and instead wanted to use something like name, age, ... should I remove the genSingletons and write code myself, or should I just bind those singletons to those names?
08:23:38 <Tuplanolla> Does that deal with nan, infinities and negative numbers, Gurkenglas?
08:23:56 <kallisti> also: is it possible to add an additional type parameter to the Elf type family in the same way that a record type could have type parameters?
08:24:14 <Gurkenglas> @let frac x = x - fromIntegral (floor x)
08:24:15 <lambdabot>  Defined.
08:24:17 <hpc> what would valid output for NaN or infinity be?
08:24:30 * hackagebot funbot 0.3 - IRC bot for fun, learning, creativity and collaboration.  https://hackage.haskell.org/package/funbot-0.3 (akrasner)
08:24:31 <Tuplanolla> Naturally nan and infinite instead of an exception.
08:24:50 <KaneTW> arguably frac Infinity = NaN
08:25:01 <KaneTW> but i don't know how it's defined in ieee
08:25:41 <Gurkenglas> > map frac [(-0.6), 1/0, 0/0] -- Tuplanolla
08:25:43 <lambdabot>  [0.4,NaN,NaN]
08:26:16 <Tuplanolla> That was unexpected. Thanks, Gurkenglas.
08:26:23 <Gurkenglas> frac maps into the interval [0,1[, so of course frac Infinity = NaN.
08:26:35 <Tuplanolla> This should be in or near the Prelude though.
08:28:31 <Tuplanolla> As should some floating-point form of quotRem.
08:30:41 <Gurkenglas> > (1/0, floor $ 1/0) -- Huh.
08:30:42 <Big_G> Anyone have good topics for a Haskell meetup today?
08:30:43 <lambdabot>  (Infinity,179769313486231590772930519078902473361797697894230657273430081157...
08:31:08 <hpc> getting loads of warnings when installing some basic packages
08:31:16 <hpc> like for tab characters in System.Random
08:31:32 <Big_G> :t Infinity
08:31:33 <lambdabot>     Not in scope: data constructor ‘Infinity’
08:31:33 <lambdabot>     Perhaps you meant variable ‘infinity’ (imported from Data.Number.Natural)
08:31:51 <Big_G> :t (1/0)
08:31:52 <KaneTW> > log . fromIntegral $ floor 1/0
08:31:53 <lambdabot> Fractional a => a
08:31:53 <lambdabot>      Could not deduce (Integral r0) arising from a use of ‘fromIntegral’
08:31:53 <lambdabot>      from the context (Floating c)
08:31:53 <lambdabot>        bound by the inferred type of it :: Floating c => c
08:31:59 <KaneTW> huh
08:32:01 <KaneTW> :t floor
08:32:02 <lambdabot> (Integral b, RealFrac a) => a -> b
08:32:08 <KaneTW> oh
08:32:12 <Big_G> What type is Infinity?
08:32:26 <KaneTW> :t Infinity
08:32:27 <lambdabot>     Not in scope: data constructor ‘Infinity’
08:32:27 <lambdabot>     Perhaps you meant variable ‘infinity’ (imported from Data.Number.Natural)
08:32:35 <KaneTW> not a tycon
08:32:43 <KaneTW> but there's
08:32:52 <KaneTW> :t Infinity :: Double
08:32:53 <lambdabot>     Not in scope: data constructor ‘Infinity’
08:32:53 <lambdabot>     Perhaps you meant variable ‘infinity’ (imported from Data.Number.Natural)
08:32:56 <KaneTW> or not
08:32:58 <KaneTW> hm
08:33:01 <Gurkenglas> :t 1/0
08:33:02 <lambdabot> Fractional a => a
08:33:22 <KaneTW> > read "Infinity" :: Double
08:33:24 <lambdabot>  Infinity
08:33:39 <KaneTW> looks like it's only in the Show/Read instance
08:34:11 <Big_G> Is infinity like max_int or it's own value? I thought numeric types had a range
08:34:27 <hpc> read on how IEEE floats work
08:34:28 <KaneTW> no, it's a special combination of mantissa and exponent
08:34:34 <hpc> there's a lot to it
08:36:02 <ski> > log ((-1) :+ 0)
08:36:03 <ski> > log ((-1) :+ (-0.00000001))
08:36:03 <lambdabot>  0.0 :+ 3.141592653589793
08:36:04 <lambdabot>  0.0 :+ (-3.141592643589793)
08:36:29 <ski> > log ((-1) :+ (-0))  -- hm
08:36:30 <lambdabot>  0.0 :+ (-3.141592653589793)
08:37:05 <monochrom> > maxBound :: Double
08:37:06 <lambdabot>      No instance for (Bounded Double) arising from a use of ‘maxBound’
08:37:06 <lambdabot>      In the expression: maxBound :: Double
08:37:31 <beepbeepbeep_> Question about type annotations. When I Hoogle sum, I see Num a => [a] -> a. I understand the [a] -> a part perfectly. What does the Num a => part mean?
08:37:53 <beepbeepbeep_> I'm guessing it has to do with different types of numbers?
08:38:21 <mjboa> beepbeepbeep_: it's a constraint meaning the type a must be a member of the Num typeclass
08:38:45 <beepbeepbeep_> great, thx!
08:39:28 <mjboa> so yeah, sum takes a list of values of any type which is a member of the Num typeclass, i.e. Double, Integer, etc.
08:39:49 <ski> @instances Num
08:39:52 <lambdabot> (Data.Fixed.Fixed a), (Shrink2 a), Blind a, CReal, Complex a, Double, Expr, Float, Int, Int16, Int32, Int64, Int8, Integer, Interval a, Large a, Natural, Product a, Ratio a, Small a, Sum a, Sym a, Word, Word16, Word32, Word64, Word8
08:40:57 <monochrom> > sum [Product 1, Product 2, Product 3]
08:40:58 <lambdabot>  Product {getProduct = 6}
08:40:59 <beepbeepbeep_> Thx mjboa, haven't learned about typeclasses or annotations yet but mod-gci complained about missing annotations (is that the right term?) so I started adding naive annotations and here I am :)
08:41:14 <dmj`> in the ghc user guide it says an operator symbol in a type declaration is treated like a type variable like 'a', but the example no longer compiles, is this no longer true? (type T (+) = ((+), (+)))
08:41:16 <aweinstock> > sum [Product 1 .. Product 5]
08:41:17 <lambdabot>      No instance for (Show a0)
08:41:17 <lambdabot>        arising from a use of ‘show_M248486391365601518113821’
08:41:17 <lambdabot>      The type variable ‘a0’ is ambiguous
08:41:26 <aweinstock> > sum [Product (1::Int) .. Product 5]
08:41:27 <lambdabot>      No instance for (Enum (Product Int))
08:41:27 <lambdabot>        arising from the arithmetic sequence ‘Product (1 :: Int) .. Product
08:41:27 <lambdabot>                                                                      5’
08:42:22 <dmj`> example here: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/data-type-extensions.html#type-operators
08:47:32 <ramadoka> hello, is it possible to do "Write yourself a scheme", without using "try" ?
08:49:31 * hackagebot console-program 0.4.0.3 - Interpret the command line and settings in a config file as commands and options  https://hackage.haskell.org/package/console-program-0.4.0.3 (AriePeterson)
08:54:39 <hpc> how does one derive SafeCopy for a type of kind * -> *?
08:54:59 <hpc> it used to just work with $(deriveSafeCopy 0 'base ''KdTree) but now i get The first argument of ‘SafeCopy’ should have kind ‘*’, but ‘KdTree’ has kind ‘* -> *’
08:55:58 <hpc> i just upgraded from ghc 7.4.1 to 7.10.2
08:56:09 <python476> hello people
08:57:03 <python476> I'm trying to build hugs98 (needed for a course), anyone willing to assist me ? it seems a shallow makefile problem
08:57:36 <hpc> eeeesh
08:57:45 <hpc> is ghc not an option? hugs is ancient
08:58:04 <dmj`> hpc: are you using the th function or ghc's deriving mechanism
08:58:11 <hpc> TH
08:59:05 <python476> hpc: so far I can't tell, teacher say using GHC might cause problems down the road
08:59:48 <hexagoxel> and hugs is causing problems immediately.
08:59:54 <python476> the interpreter builds fine actually, but there's an issue when ''compiling'' libraries 
09:00:38 <hpc> dmj`: is there a deriving mechanism for SafeCopy now?
09:00:43 <python476> hexagoxel: it's packaged and is ok on debian, nixos etc, I wanted to build it on archlinux because that's my main distro
09:01:10 <haskell114> someone can teel me what this function does comb m (x : xs) = map ( x: ) ( comb ( m - 1 ) xs ) ++ comb m xs
09:01:28 <KaneTW> python476: why does your teacher say that
09:01:46 <python476> KaneTW: I have no additional info
09:01:48 <monochrom> why are we grilling python476 for a choice they didn't make?
09:01:51 <haskell114> i dont understand the recursion of this fuction
09:02:02 <KaneTW> no i'm just wondering if he gave a reason
09:02:15 <dmj`> hpc: I normally use the TH function
09:02:29 <monochrom> ok, you know what, if you want to know, ask for the email of the teacher and talk to that teacher directly
09:02:30 <hexagoxel> python476: ah, is the aur package from you?
09:02:37 <python476> don't sweat it anyway, I was just asking in case people did adapt the source tarballs for themselves
09:02:38 <monochrom> also applies if you want to argue
09:02:46 <John[Lisbeth]> I am running windows and I am running emacs inside of cygwin.
09:02:50 <python476> hexagoxel: there's not even an aur package yet
09:02:53 <John[Lisbeth]> And I am using ansi-term within emacs
09:03:04 <John[Lisbeth]> and I am trying to figure out the best way to use ghc
09:03:10 <banacorn> https://gist.github.com/banacorn/1f9aac96e4202a2d7183
09:03:11 <hexagoxel> python476: https://aur.archlinux.org/packages/hugs/
09:03:21 <hexagoxel> "Last Updated: 	2015-10-17 03:33"
09:03:38 <python476> hexagoxel: hah, I guess that's a fellow student
09:03:59 <John[Lisbeth]> I could install ghc in windows and then try to access it from within cygwin, or I could compile ghc myself inside of cygwin, or I could try to install it through emacs.
09:04:03 <python476> It wasn't there a few hours ago. he was smarter than me
09:04:52 <banacorn> Hey guys I'm working on a type-level Symbol List, and I'm writing a function trying to query it, but it does not compile, here's the complete code with example and error message: https://gist.github.com/banacorn/1f9aac96e4202a2d7183
09:05:51 <banacorn> Seems like it has something to do with type equality constraints ... could anyone help me thanks :D
09:07:30 <hpc> dmj`: any tips on what i am doing wrong?
09:07:41 <hexagoxel> python476: what is the exact issue?
09:08:18 <python476> hexagoxel: I still don't get it, gcc complains for .so files missing
09:08:25 <hpc> dmj`: http://lpaste.net/6416783746992701440
09:08:45 <Nuxular> aweinstock, they were numerical methods for finding roots
09:08:56 <python476> the aur package author patched a header file to define INLINE, while somebody else just told me a "-p -std=c89" CFLAGS would do
09:09:20 <Tuplanolla> Your implementation of frac is slow, because the intermediate type is Integer, Gurkenglas.
09:09:25 <Nuxular> aweinstock, they I've now got it throwing exceptions when in the invalid ranges to protect myself while not cluttering the types
09:09:49 <Nuxular> aweinstock, I don't prefer using exceptions, but in this case I'm making an...
09:10:03 <Nuxular> damn it
09:10:56 <python476> hexagoxel: linking errors it seems
09:10:59 <hpc> dmj`: oh, and my version constraint is safecopy ==0.8.*
09:11:20 <dmj`> hpc: I don't think it's possible
09:12:21 <hpc> blech
09:12:28 <hpc> it was working before, which is befuddling
09:14:26 <dmj`> hpc: well, there is instances for Maybe... so maybe it should, let me try something
09:14:36 <monochrom> a law of Haskell: all IDEs come to an end. (FPComplete is phasing out its web-based IDE, too)
09:15:35 <monochrom> thus Haskell Centre joins the rank of EclipseFP and Leksah as ex-IDEs.
09:16:15 <osfameron> was fpcomplete open sourced?
09:16:20 <monochrom> no
09:16:43 * osfameron makes a mental note to never use a closed source proprietary ide
09:17:05 <monochrom> well yeah that sounds nice to the ears of FOSS fans.
09:17:07 <jophish> monochrom: is Lekash dead?
09:17:12 <KaneTW> https://peaker.github.io/lamdu/
09:17:24 <monochrom> the fact remains that 2/3 of the ex-IDEs are FOSS.
09:17:28 <jophish> didn't fp complete open source some of the backend
09:18:06 <monochrom> a few months ago I heard people trying to revive Leksah. since then no more news.
09:18:17 <jophish> h ok
09:18:18 <osfameron> http://leksah.org/ doesn't declare that it's dead
09:18:19 <jophish> ah*
09:18:40 <monochrom> it is very possible that you can wait a few more months and then Leksah becomes an ex-IDE the 2nd time.
09:18:52 <osfameron> hah
09:18:53 <KaneTW> i'll have to actually try lambu sometimes
09:19:00 <Gurkenglas> > maxBound :: Int -- Tuplanolla, do you know that the Doubles you work with don't exceed this?
09:19:05 <lambdabot>  9223372036854775807
09:19:10 <Tuplanolla> No.
09:19:14 <Gurkenglas> > maxBound :: Word64 -- Tuplanolla, this? :P
09:19:19 <lambdabot>  18446744073709551615
09:19:30 <Tuplanolla> It's probably still fine.
09:19:30 <KaneTW> > maxBound :: Double
09:19:31 <lambdabot>      No instance for (Bounded Double) arising from a use of ‘maxBound’
09:19:32 <lambdabot>      In the expression: maxBound :: Double
09:19:35 <KaneTW> huh
09:19:54 <Tuplanolla> > snd . properFraction <$> [-4.25 .. 4.25]
09:19:55 <lambdabot>  [-0.25,-0.25,-0.25,-0.25,-0.25,0.75,0.75,0.75,0.75,0.75]
09:20:06 <dmj`> hpc: it's possible, but I don't think it's deriveable, you'd have to make your own instance SafeCopy a => SafeCopy (YourType a)
09:20:15 <Gurkenglas> > (fromIntegral $ subtract 1 $ floor $ 1/0) :: Double -- KaneTW
09:20:17 <lambdabot>  1.7976931348623157e308
09:20:20 <monochrom> anyway even if you set out to use a FOSS Haskell IDE you will still run into the ex-IDE problem just as quickly. and the FOSS aspect is not going to help you, since you are not going to keep it updated and no one is either.
09:20:40 <monochrom> FOSS does not change economics
09:21:00 <monochrom> if no one has incentive to work, then no one has incentive to work.
09:21:05 <osfameron> true
09:21:08 <monochrom> even if said work is legal.
09:21:17 <tsahyt> What's the ex-IDE problem?
09:21:24 <KaneTW> > let (n,m) = floatRange x; x = undefined :: Double in (floatRadix x)^m
09:21:26 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
09:22:41 <hpc> dmj`: oh well
09:26:14 <monochrom> but it is very likely that FPComplete will open-source Haskell Centre when it ends. http://thread.gmane.org/gmane.comp.lang.haskell.cafe/118664
09:26:29 <hexagoxel> python476: well, i can reproduce the error..
09:27:05 <python476> hexagoxel: you run arch ? 
09:27:19 <hexagoxel> yes
09:27:20 <tsahyt> What kind of features do people expect from a Haskell IDE that things like haskell-mode don't provide? I've always found that Haskell is a wonderful language for use without an IDE.
09:27:32 <python476> btw, the aur builds fine on my system, so first thanks a lot, I would never thought to check aur again until a week
09:27:41 <python476> and then don't waste time for me
09:28:54 <python476> but, would have you been able to write the patch bundle in the aur package ? I'm such a C noob :sad
09:32:37 <Tuplanolla> @let x `rem'` y = let (_, z) = properFraction $ x / y in y * if z < 0 then 1 + z else z
09:32:39 <lambdabot>  Defined.
09:32:54 <Tuplanolla> > (`rem'` 1) <$> [-4.25 .. 4.25]
09:32:55 <lambdabot>  [0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.75]
09:32:59 <Tuplanolla> There you go.
09:34:27 <hiptobecubic> Does cabal use a SAT solver for coming up with a build plan?
09:35:59 <hiptobecubic> And is there anything that encodes package conflicts in hackage currently? Suppose two packages provide a Data.Timezone module, for example, is that handled in any particular way or is it just user-beware?
09:36:22 <Hijiri> user-beware
09:36:34 <dolio> Technically, yes, they implemented a SAT solver.
09:37:13 <dolio> I think there's some work on using an external SAT solver. But it hasn't landed yet.
09:44:34 * hackagebot libinfluxdb 0.0.3 - libinfluxdb  https://hackage.haskell.org/package/libinfluxdb-0.0.3 (wereHamster)
09:45:50 <reactormonk> aweinstock, name of "return". According to KaneTW, mostly historical.
09:48:00 <hexagoxel> python476: "INLINE" is defined to "extern inline" when the functions are in fact defined locally. i understand the patch, but likely would not bothered to resolve this myself. Depends on how much help i could have expected from teacher/assistants.
09:53:01 <python476> hexagoxel: aight
10:09:35 * hackagebot ide-backend-common 0.10.1 - Shared library used be ide-backend and ide-backend-server  https://hackage.haskell.org/package/ide-backend-common-0.10.1 (MichaelSnoyman)
10:24:35 <niteria> I have a directory, ghc-mod-test with only A.hs file in there, how do I make `ghc-mod list` list that module as well?
10:25:03 <niteria> I'm not using cabal or stack
10:37:45 <jdnavarro> a function of the type `(a -> IO b) -> IO (a -> b)` is impossible, right?
10:37:58 <jdnavarro> safely, I mean
10:41:40 <konne> I'm reading the following syntax in a GTK project: `set window [ containerBorderWidth := 10 ]`. It seems pretty obvious what this does, but I would like to understand how it works. Where is `set` defined and what does the `[_ := _]` syntax do?
10:42:50 <Ralith> konne: := is probably a data constructor
10:43:06 <hpc> set takes a window and a list of assignments
10:43:16 <hpc> (:=) constructs an assignment from what to set and where to set it
10:44:50 <konne> do you have a link to the hackage definition? I cannot find it.
10:46:17 <Ralith> jfischoff: should be, yeah
10:46:43 <Ralith> jfischoff: the input function could e.g. be print
10:53:52 <Gurkenglas> jdnavarro, (a -> IO ()) -> IO (a -> ()) is morally equivalent to (a -> IO ()) -> IO () (unless you're trying to... make it track all calls of the returned function and execute them retroactively? o.o). What IO () should be returned given, say, putStrLn as the argument?
10:54:39 <up2late> just starting to learn haskell, how would i check intersect of sets im trying this   ["f","a","d","e","m"] `intersect` ["m","a","k","e","l","d"] == ["a"] but it gives false
10:55:20 <sinelaw> > ["f","a","d","e","m"] `intersect` ["m","a","k","e","l","d"]
10:55:22 <lambdabot>  ["a","d","e","m"]
10:55:32 <sinelaw> well, "d", "e" and "m" are also in both sides
10:55:48 <sinelaw> what are you trying to do?
10:56:22 <up2late> dam exactly that not sure why mine didnt work but yours did thank you
10:57:38 <konne> @hpc I figured it out, it's in glib http://hackage.haskell.org/package/glib-0.13.2.1/docs/System-Glib-Attributes.html#t:ReadWriteAttr
10:57:38 <lambdabot> Maybe you meant: src rc pl ghc
10:58:49 <Myrl> up2late: Perhaps you mean
10:59:02 <Myrl> > zipWith (==) ["f","a","d","e","m"] ["m","a","k","e","l","d"]
10:59:04 <lambdabot>  [False,True,False,True,False]
10:59:15 <Myrl> Errr, not that.
11:00:25 <jle`> > filter (uncurry (==)) (zip ["f","a","d","e","m"] ["m","a","k","e","l","d"]) -- perhaps?
11:00:28 <lambdabot>  [("a","a"),("e","e")]
11:00:30 <Myrl> jle`: Yep.
11:00:41 <Myrl> jle`: Then `map fst`
11:00:53 <Myrl> Either way, that's still fallse.
11:01:07 <up2late> ah ok
11:01:33 <jle`> uncurry (==) = (\(x,y) -> x == y)
11:01:59 <Myrl> jle`: Mhm.
11:02:03 <up2late> just learning to set some lists and trying unions and intersect
11:02:35 <Myrl> > pure (==) <*> fst <*> snd $ (1,1)
11:02:37 <lambdabot>  True
11:02:39 <Myrl> > pure (==) <*> fst <*> snd $ (1,2)
11:02:41 <lambdabot>  False
11:03:18 <jle`> pure f <*> x = f <$> x ?
11:03:25 <Myrl> jle`: Yep.
11:03:48 <Myrl> jle`: I forgot about uncurry once and I did `f <$> g <*> h` I kinda felt stupid afterwards. :P
11:14:35 <brtmr> is there a preferred way to provide postgres credentials in postgresql-simple? So far I have hardcoded them into my program, but that seems rather unprofessional, now that i want to set the github repo to public ;).
11:14:38 * hackagebot monad-parallel 0.7.2.0 - Parallel execution of monadic computations  https://hackage.haskell.org/package/monad-parallel-0.7.2.0 (MarioBlazevic)
11:15:46 <glguy> brtmr: Read your connection string out of a configuration file that you don't commit to your repository
11:19:38 * hackagebot bindynamic 1.0.0.0 - A variation of Data.Dynamic.Dynamic with a Binary instance  https://hackage.haskell.org/package/bindynamic-1.0.0.0 (lspitzner)
11:23:40 <rcosta> Hi! Question about the scotty web framework.. how do I get multiple parameters from the request? i.e. I can use username <- param "user_name" to get one parameter, but doing it again results in an error...
11:24:10 <Tuplanolla> Isn't there params too?
11:26:46 <zair> newb-ish warning. Why does (min 2 2/0> return infinity but (min 2 (2/0)) return 2.0?
11:26:55 <zair> I mean (min 2 2.0)
11:27:04 <zair> I mean (min 2 2/0)
11:27:50 <glguy> min 2 2 / 0 --is-- (min 2 2) / 0
11:28:22 <zair> ah, didn't realize that. Thanks
11:28:36 <rcosta> apparently there is, Tuplanolla
11:28:49 <osfameron> why wouldn't you be able to use param twice though?
11:29:02 <rcosta> no idea, but it's not working
11:29:14 <osfameron> may be worth lpaste'ing the code and errors?
11:29:20 <Tuplanolla> You might get an error if you bind param to an unused variable.
11:29:30 <rcosta> "No instance for (Parsable t0) arising from a use of ‘param’"
11:29:41 <rcosta> on the second call to param
11:29:42 <Tuplanolla> You don't get a monomorphic type if you do that.
11:30:11 <bananu7> hey guys. I was wondering if anyone had a tutorial for TemplateHaskell's "reify" that actually does some processing with the Type portion of Info.
11:30:23 <Tuplanolla> Try adding :: ActionM Int or something to the binding.
11:31:32 <rcosta> interesting.. seems to work that way
11:31:59 <rcosta> I wasn't adding :: ActionM something before, even with just one call
11:32:04 <rcosta> and it was ok
11:32:35 <rcosta> well, thanks! mistery solved
11:32:36 <Tuplanolla> That's because you implicitly monomorphized the result by using it elsewhere.
11:32:44 <rcosta> ah right
11:32:50 <rcosta> makes sense
11:33:07 <rcosta> I wasn't using the second parameter yet
11:33:15 <rcosta> cool
11:33:30 <Tuplanolla> This advice applies to all monads.
11:33:43 <rcosta> lesson learned :)
11:39:33 <shyardo> I am 2 hours late, but the teacher is asking for hugs because he thinks the new Foldable, Traversable included in prelude as of 7.10 adds complexity for beginners
11:39:39 * hackagebot git-freq 0.0.3 - A Git subcommand to show total addition, deletion per file  https://hackage.haskell.org/package/git-freq-0.0.3 (DaisukeFujimura)
11:39:52 <bananu7> Nothing? The only tutorials I was able to found used only Names...
11:40:33 <bananu7> I've read the implementation of Ppr (pretty-printing) used for sigs generated from Reify, but it doesn't pattern match on the types either
11:40:42 <voidzero> hugs does not add complexity?
11:40:56 <voidzero> i saw bitemyapp explain more than once why hugs should not be used
11:41:03 <shyardo> i don't know, I never used it
11:41:09 <bananu7> Hugs is years behind IIRC
11:41:19 <voidzero> bananu7, yeah and no longer developed iirc
11:41:45 <glguy> It's kind of a shame the teacher is taking out his dislike of Foldable on his students
11:42:20 <voidzero> teachers ¯\_(ツ)_/¯
11:42:25 <shyardo> it is not that he dislikes it, it just makes it more difficult for novices to understand function types -- his words
11:42:30 <joco42> i just had this idea that haskell is like lego while python/lisp is like play-doh ... any opinions on this analogy?
11:42:35 <shyardo> playing devil's advocate
11:42:56 <voidzero> joco42, i'd buy the t-shirt!
11:43:00 <cow_2001> where do i save defaults for cabal init?
11:43:29 <joco42> voidzero: nice...
11:43:29 <idupree2> There's a Hackage library I'm using that doesn't build on GHC 7.10.  The fix is a simple code change and I submitted it as a github pull request a week ago. No response yet. Do y'all recommend patience, or some other approach?
11:43:46 <glguy> shyardo: That's pretty bogus. something that could have been solved with a local definition for the class is being solved by dragging people through trying to get a working outdated program
11:43:57 <glguy> teaching them something they won't use after the class
11:44:39 * hackagebot tasty-hunit-adapter 1.1 - Use existing HUnit tests with tasty  https://hackage.haskell.org/package/tasty-hunit-adapter-1.1 (JanStolarek)
11:44:53 <cocreature> idupree2: you can't really do much more than having patience so I recommend patience :)
11:45:03 <idupree2> :)
11:45:11 <voidzero> well, after a week you could ping again
11:45:17 <voidzero> attracting attention, why not?
11:45:46 <joco42> is the name of the teach start with E ?
11:45:54 <idupree2> yeah. I think they might be busy in grad school or something based on their last github activity being at the beginning of september
11:45:55 <joco42> glguy: ^
11:46:01 <idupree2> and fairly active before that
11:46:04 <shyardo> Erik, yes :P
11:46:10 <joco42> i see
11:46:24 <joco42> i have seen his tweet
11:46:58 <idupree2> (I have some other fixes for it, and some fixes involve design decisions I'd like to ask the author about.
11:47:11 <joco42> it would kinda annoy me to learn something that i cannot use in practice right away... if i decide to do that...
11:47:18 <voidzero> starting to sound like that teacher has some personal grudge
11:47:24 <shyardo> that fact is that he seems not to care much about teaching haskell, but teaching FP. Haskell used to be the "main" vector for that, but you could use anything in his classes
11:47:27 <voidzero> recommending hugs is a silly solution
11:47:52 <glguy> You can teach FP without caring about Haskell without punishing your students for your opinions
11:48:01 <voidzero> just use ghc and when he complains just say 'you can use both'
11:48:13 <shyardo> yes, he is indeed very opinionated
11:48:36 <shyardo> i like him, but you have to take his positions with some salt
11:49:02 <hexagoxel> (somebody must also have deleted all ghc-7.8.4 distributions)
11:49:06 <ww> if i had a teacher like that i'd use ML for his class
11:49:10 <rcyr> I like him because he's pushing FP to people with classic OOP backgrounds
11:49:38 <ww> i love haskell but i hate being pushed around by opinionated people
11:49:49 <shyardo> but I, as a 6 month newbie at haskell agree with him that [a] -> a is easier than (Foldable t) => t a -> a
11:50:14 <joco42> shyardo:  really?
11:50:15 <MarcelineVQ> But what if you didn't know what [ ] was in the first place?
11:50:15 <shyardo> i fully understand this signature, but for newbies, it is rather difficult
11:50:26 <glguy> shyardo: That's irrelvant to the question of using Hugs
11:50:27 <MarcelineVQ> is it so different?
11:50:27 <joco42> i think the second looks much clearer
11:50:42 <shyardo> glguy: I think it is
11:50:58 <cocreature> ww: you should use java in that case, ml is not enough punishment
11:50:58 <glguy> No, there are versions of GHC that use that type signature that are very easy for students to install
11:51:20 <joco42> shyardo:  its not more difficult than Java's extend ...
11:51:57 <Lokathor> Code Review request thing: https://github.com/Lokathor/roguelike-hs/blob/master/src/Main.hs
11:52:07 <shyardo> yes, that's why we don't learn extend right away as we do with arrays/lists
11:52:31 <Lokathor> I've written a Field of View lib based on a Java version that I had. Right now it's all in one huge module and will be broken up a bit later
11:52:41 <MarcelineVQ> Lokathor: dem hand-made tests...
11:52:43 <bananu7> @Lokathor man, modules exist
11:52:43 <lambdabot> Unknown command, try @list
11:52:49 <voidzero> yeah sounds like a good reason to use hugs from now on :P
11:52:50 <bananu7> :Lokathor man, modules exist
11:52:54 * voidzero = convinced :P
11:52:54 <shyardo> don't misunderstand me, I think Foldable is much better than [a], but for newbies, being myself a teacher, I agree with him, every syntatic sugar helps
11:53:40 <Lokathor> yes bananu7 i'll break it up a bit. Honestly the biggest thing that will go outside the module will be Location. Almost all the rest is internal to the module
11:53:52 <shyardo> If I was doing his course, i would never use hugs as well
11:53:57 <Shockk> Lokathor: around L288, are the cases for (True, False) and (False, True) identical?
11:54:01 <bananu7> Also move your tests to a proper test suite Lokathor, using HSpec perhaps
11:54:23 <Lokathor> MarcelineVQ, yeah :3  I made those by having the Java version spit out correct inputs an outputs and just throwing them in at the bottom.
11:54:24 <shyardo> But I wished ghci had an option to legacy preludes
11:54:32 <joco42> yeah... i dunno, it's just syntax... not a very complex one...
11:54:37 <ww> cocreature: i don't want to punish myself!
11:54:37 <Shockk> Lokathor: if they are, you could move the (False, False) case up and replace those duplicates with: _ ->
11:54:50 <Lokathor> bananu7, I've heard of both HSpec and HUnit, is one perferable or newer than the other?
11:54:51 <glguy> shyardo: You can hide the Prelude already 
11:55:07 <joco42> shyardo:  but yeah, the concept of type classes... is maybe not so easy...
11:55:16 <joco42> for an oo mind
11:55:18 <bananu7> Lokathor, I use Hspec but I think both are ok
11:55:23 <Lokathor> Shockk, each of those cases is distinct. True/False adds shallow bumps, False/True adds steep bumps
11:55:46 <Shockk> Lokathor: oh, my apologies, apparently I can't read
11:55:54 <shyardo> glguy: how is that?
11:56:07 <bananu7> eh okay if anyone likes to dabble with TemplateHaskell I've asked on StackOverflow: http://stackoverflow.com/questions/33189695/how-to-create-a-pattern-match-for-int-in-a-function-taking-a-type
11:56:12 <bananu7> cheers.
11:56:57 <MarcelineVQ> shyardo: {-# LANGUAGE NoImplicitPrelude #-} or import Prelude()
11:57:04 <glguy> ^
11:58:38 <shyardo> but then it takes away everything from prelude, instead of falling back to old, at least trying here the way I did
11:59:05 <shyardo> is there a way to, say, import old prelude with length :: [a] -> a?
11:59:09 <glguy> Yup, and then the teacher provides whatever prelude is appropriate for people who shouldn't see foldable
11:59:34 <glguy> possibly as a hackage package, or just as a file
11:59:37 <Lokathor> joco42, typeclasses are MORE easy to an OO mind than a pure C or other "pre-OO" mind I'd say
12:00:23 <shyardo> nice, I guess it is better than hugs
12:00:26 <MarcelineVQ> more easy to abuse :>
12:00:48 <ggole> > sum (1, 2)
12:00:50 <lambdabot>  2
12:00:53 <ggole> Does seem off.
12:01:05 <shyardo> although I would prefer something like gcc cmd options with old C standards
12:01:09 <Shockk> shyardo: I believe something that was being discussed recently on one of the mailing lists was something about the possibility of separating GHC's base from GHC so that you could depend on a different version of base or something like that
12:01:12 <Lokathor> the usual wording is a little off compared to what OO people are used to, but "The typeclass declares an interface that all types in the class must implement. Each 'instance' of the class provides the methods for you when you go to use them."
12:01:26 <joco42> Lokathor:  yeah...
12:01:47 <eacameron> Not getting much love here, does anyone else have input? http://stackoverflow.com/questions/33177324/is-there-a-way-to-get-ad-hoc-polymorphism-in-python
12:01:48 <Shockk> when I say "discussed", I think I actually only saw it mentioned in passing by SPJ
12:02:13 <shyardo> that would be great, imho
12:02:37 <eacameron> I don't think people know what ad-hoc polymorphism is....
12:03:04 <Lokathor> eacameron, i'm no python guru, but that accepted answer there seems to be the correct-est thing you'll get
12:03:12 <joco42> Lokathor:  with the addition that the function that gets executed can also be selected based on the return type
12:03:12 <shirt> how can i tell ghc to not create .hi and .o files? I just want it to create the final executable
12:03:28 <joco42> Lokathor:  unlike in oo
12:03:36 <eacameron> Lokathor: Thanks. I feared that might be the case. I guess it works...
12:04:39 <joco42> for example the fromInteger function
12:04:54 <Lokathor> joco42, actually, I know it's uncommon, but http://stackoverflow.com/questions/442026/function-overloading-by-return-type
12:05:18 <eacameron> Lokathor: And thanks for the upvote. I'm fast approaching a solid vote of zero. :D
12:05:49 <Lokathor> but sure, I guess selecting by return type is like 5% extra magic people might not be used to
12:06:18 <eacameron> Lokathor: True, I should use a different example. I could even write one in C for crying out loud.
12:07:04 <eacameron> But Haskell is has the best ad-hoc polymorphism I've seen; hence using it for the example.
12:07:16 <Lokathor> that's what got you your downvotes pal :P
12:07:25 <Lokathor> people mistrust wizards
12:07:41 <eacameron> Lokathor: I'm learning that... Be dumb and you'll have more friends...and votes.
12:07:51 <eacameron> Works in many arenas of life.
12:07:56 <joco42> Lokathor:  that is a nice SOF post
12:08:45 <Lokathor> eacameron, my solution is this, if you're going to be writing the generators on your own, stringFromRandom(gen), intFromRandom(gen), myTypeFromRandom(gen), etc
12:09:14 <marchelzo> is there a funciton like f :: (a -> a -> a) -> (a -> a) -> a -> a, where f (-) (*2) 10 would be (-) 10 ((*2) 10) = -10?
12:09:34 <Lokathor> joco42, yeah there's nothing conceptually that allows or prevents overloading based on return type... it's just not normally done is all
12:09:37 <joco42> eacameron:  the python crowd is not as open minded as the haskell crowd... 
12:09:56 <joco42> eacameron:  i expereinced similar negative responses
12:10:07 <Lokathor> keep in mind that python is ultimately more like Lisp than like Haskell
12:10:13 <eacameron> joco42 Joy.
12:10:28 <joco42> yeah, python is play-doh, haskell is lego
12:10:32 <Lokathor> if a question wouldn't make sense to a Lisp person, odds are it can't make sense to a Python person
12:10:42 <eacameron> Lokathor True; I'll bet Lisp does not have ad hoc polymorphism either.
12:11:16 <Lokathor> eacameron, Lisp has a system where you write a generic function, and then you write methods that match on the types passed to the generic function and then do their thing
12:11:35 <Lokathor> and the correct method is selected at runtime, and you can dispatch on more than one type if you want
12:11:36 <joco42> eacameron:  that is a pretty good question
12:11:43 <eacameron> joco42 Nice analogy
12:11:50 <joco42> eacameron: i should wonder about this myself
12:12:32 <joco42> eacameron:  retroactive polymorphism ... 
12:12:39 <eacameron> Lokathor IS that called dynamic dispatch?
12:12:43 <joco42> eacameron:  there is monkey patching
12:12:53 <joco42> in python...
12:12:54 <eacameron> joco42 Let's not go there...
12:13:25 <exio4> marchelzo: (-) <*> (*2) ? 
12:13:27 <joco42> that is pretty... hardcore stuff... 
12:13:30 <exio4> @type (<*>) 
12:13:31 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:13:38 * eacameron rejoices at being back in the non-negatives on SO
12:13:55 <Lokathor> eacameron, well i've heard at least one veteran lisp person call it dynamic dispatch. it's part of their OO system that they bolted on later and specific to Common Lisp (not in Scheme for example, Scheme has different suggested solutions)
12:14:05 <marchelzo> > ((-) <*> (*2)) 10
12:14:07 <lambdabot>  -10
12:14:15 <joco42> Lokathor:  is this the multi something?
12:14:19 <joco42> in lisp?
12:14:22 <joco42> multimethod?
12:14:34 <marchelzo> exio4: I had a feeling it would involve applicative
12:14:42 <marchelzo> exio4: thanks
12:15:04 <Lokathor> joco42, yeah multimethods. I'm no expert I just know the surface level details from having read the book once
12:15:33 <eacameron> Lokathor Neat. Well it actually sounds decently powerful. Seems like Python could take a hint from Lisp then.
12:16:46 <Lokathor> Haskell is Legos, Lisp is Clay or Play Doh, Python is some sort of degeneate version of play doh :P
12:16:53 <joco42> but these multimethods cannot dispatch on return type or can they? are these two concepts related at all?
12:17:02 <eacameron> Lokathor joco42 Jello
12:17:05 <joco42> i dont thing they are but i am not sure...
12:17:58 <Lokathor> I am not sure if dispatching on return type is possible. I don't think it's common at least
12:18:10 <Shockk> Lokathor: is assembly therefore a hay bale with sharp needles hidden in it?
12:18:33 <joco42> ok
12:18:36 <Lokathor> I asked in #lisp one time for basically fmap, "I want to map a function over a thing and just get the same thing back, is there a way to set this up?"
12:19:07 <Lokathor> they said i was silly and that the system wasn't at all set up for it, that map was just always split into like 4 versions and kinda deal with it
12:19:58 <up2late> i got union and intersect how do i get the sets complement?
12:20:29 <joco42> yeah this fmap is a type level concept....
12:20:31 <awpr> Shockk: I think assembly is protons, neutrons, and electrons
12:21:03 <up2late> for example    (A `intersect`B)  `union` C 
12:21:39 <Shockk> awpr: that sounds more accurate
12:21:50 <Lokathor> awpr, I was thinking the same sort of thing.
12:23:02 <awpr> maybe then C is iron ore, C++ is steel, and CPU microcode is just vibrating strings
12:23:58 <Lokathor> well that implies that C++ is almost always better than C, and I think we can agree that's probably not the case because of OO madness
12:24:55 <Shockk> there's always javascript (one of those weird blob things you can't hold in your hand without it going inside-out)
12:24:56 <awpr> it's just iron ore with more structure
12:25:50 <hpc> so what's rust?
12:25:59 <Tomsik> I think metals are bad analogies for programming languages
12:26:10 <dolio> Can you take this somewhere else?
12:26:34 <kallisti> got some questions about vinyl if anyone is familiar with it
12:30:22 <naudiz> is there an UTF8 version of Network?
12:33:55 <jle`> kallisti: best to just ask your question :)
12:34:22 <naudiz> I'm trying to writ an IRC bot that translates Japanese words. It fails because Kanji and Kana won't be read correctly :/
12:35:22 <exio4> naudiz: ? 
12:35:59 <naudiz> e.g. 木 becomes æ
12:36:09 <exio4> naudiz: as far as I know, that UTF8 comes from the library you use for reading from the Handle given
12:36:52 <exio4> maybe you should try reading a ByteString directly, and then using Data.Text.Encoding.encodeUtf8? 
12:37:57 <naudiz> exio4: that's strange, because when I give it a string via terminal, it works
12:39:34 <naudiz> exio4: I followed this guide https://wiki.haskell.org/Roll_your_own_IRC_bot and I can only imagine it to come from s <- init `fmap` io ( hGetLine h )
12:40:42 <naudiz> after that I'm sending it to the terminal output with io $ putStrLn s where a wrong character is printed
12:41:51 <exio4> naudiz: try switching to ByteString plus an explicit encoding call?
12:43:23 <naudiz> I'll try
12:43:52 <elliptic00> anyone know what is difference among fmap and foldr and foldr?
12:43:54 <naudiz> what do you mean by "explicit encoding call"?
12:44:21 <Vektor> elliptic00: Do you mean fmap, foldl and foldr?
12:44:33 <elliptic00> yep
12:44:49 <exio4> naudiz: are you familiar with ByteString/Text? (bytestring / text libraries)
12:45:05 <Vektor> well, fmap maps over a functor. Entirely different from folds
12:45:30 <Vektor> well, not entierly different. You can express a map over a list as a fold, I think.
12:46:44 <naudiz> exio4: a little
12:46:52 <exio4> naudiz: ByteString is an array of bytes, Data.Text is "unicode-aware" text, the way to go either way is with explicit functions that encode/decode with some encoding like UTF8, ASCII, etc..
12:46:56 <jle`> elliptic00: they're all pretty different things
12:47:01 <jle`> what do you think is similar about them?
12:47:09 <Vektor> foldr and foldl differ in the way they fold the list (or any foldable of course). I think it boils down to whether you want your folding to start on the left or right side. Parameters are a bit juggled too.
12:47:27 <naudiz> exio4: so, I could also use Text?
12:49:43 <awpr> naudiz: either way it's coming off the network as raw bytes, and you need to know the encoding to interpret them.  UTF-8 certainly supports Japanese characters, but I seem to recall there's also a Japanese-specific encoding that still sees some use because it's more compact
12:50:05 <kallisti> is it possible to get the name of a vinyl record field?
12:50:06 <Vektor> elliptic00: also, lyah explains foldl and foldr beautifully. -  http://learnyouahaskell.com/higher-order-functions
12:50:21 <Zemyla> Hmm. You know, I just realized something about Vector.
12:50:24 <awpr> the String versions of the IO functions assume some encoding implicitly, probably UTF-8 or Latin-1
12:50:35 <Vektor> Zemyla: You spelled it wrong :P
12:50:42 <Zemyla> Primitive, Storable, and Unboxed Vectors can be theoretically stored unboxed.
12:50:51 <Zemyla> Using an ArrayArray.
12:50:56 <awpr> but if you use the ByteString versions you'll get the raw bytes, which you can decode however you want
12:51:18 <Shockk> there's a note in the Network.Socket module
12:51:22 <Shockk> "Do not use the send and recv functions defined in this module in new code, as they incorrectly represent binary data as a Unicode string. As a result, these functions are inefficient and may lead to bugs in the program. Instead use the send and recv functions defined in the ByteString module."
12:51:31 <naudiz> awpr exio4 thanks
12:51:34 <Shockk> possibly relevant
13:04:43 * hackagebot ide-backend-common 0.10.0.2 - Shared library used be ide-backend and ide-backend-server  https://hackage.haskell.org/package/ide-backend-common-0.10.0.2 (MichaelSnoyman)
13:04:45 * hackagebot ide-backend-common 0.10.1.1 - Shared library used be ide-backend and ide-backend-server  https://hackage.haskell.org/package/ide-backend-common-0.10.1.1 (MichaelSnoyman)
13:06:42 <Zemyla> Oh never mind, I can't do a vector of Storable Vectors. I can't store ForeignPtrs in arrays, only Ptrs.
13:08:36 <Vektor> www.reddit.com/r/haskell/comments/3p59au - do you guys have any ideas?
13:14:19 <Gurkenglas> http://lpaste.net/143226 How do I make line 2 make the do block produce Nothing?
13:14:48 <breadmonster> > let s x y z = x z (y z)
13:14:50 <lambdabot>  <no location info>: not an expression: ‘let s x y z = x z (y z)’
13:14:59 <breadmonster> > let s x y z = x z (y z) in '3'
13:15:00 <lambdabot>  '3'
13:15:15 <breadmonster> :t \x y z -> x z (y z)
13:15:17 <lambdabot> (r2 -> r1 -> r) -> (r2 -> r1) -> r2 -> r
13:15:20 <breadmonster> Cool.
13:16:39 <gexe> Hi all, I'm taking a MOOC in Haskell and this part is confusing me.
13:16:43 <breadmonster> It's interesting how Haskell lets you implement the SKI calculus.
13:16:48 <breadmonster> gexe: what's up?
13:17:00 <gexe> length = { it.size() }
13:17:09 <jle`> breadmonster: your s is actually already in Prelude, btw
13:17:15 <gexe> why does that return what it does?
13:17:16 <breadmonster> jle`: As what?
13:17:20 <jle`> ap
13:17:24 <jle`> and (<*>)
13:17:33 <gexe>  groovysh_evaluate$_run_closure1@125c99f
13:17:33 <breadmonster> :t ap
13:17:34 <lambdabot> Monad m => m (a -> b) -> m a -> m b
13:17:49 <awpr> :t [ap, s]
13:17:50 <lambdabot>     Couldn't match expected type ‘m (a -> b) -> m a -> m b’
13:17:50 <lambdabot>                 with actual type ‘Expr’
13:17:50 <lambdabot>     In the expression: s
13:17:56 <breadmonster> jle`: Specialized to the reader monad?
13:18:02 <jle`> specialized to (->) a
13:18:10 <jle`> or rather, the (->) a instance
13:18:24 <breadmonster> :t [ap, (\x y z -> x z (y z))]
13:18:25 <lambdabot> [(t -> a -> b) -> (t -> a) -> t -> b]
13:18:31 <breadmonster> Hmm, okay.
13:19:03 <jle`> k is of course `const`
13:19:04 <elliptic00> when I use let in GHCI, e.g  let m = 3  it works, but I can't use let m = 3 in my .hs file? any idea?
13:19:18 <jle`> elliptic00: it's kinda silly, because ghci forces you to use weird syntax
13:19:19 <breadmonster> jle`: I'm aware.
13:19:19 * jle` shrugs
13:19:31 <jle`> don't expect ghci and normal haskell files to be the same, in general
13:19:31 <breadmonster> gexe: Try #groovy
13:19:40 <breadmonster> That's definitely not Haskell.
13:19:41 <jle`> there's no real "why" answer, it's just how it is :|
13:20:09 <gexe> Ah! thanks
13:20:20 <breadmonster> jle`: if you're on haskell-cafe, there was a mailing list post about changing the syntax.
13:20:33 <jle`> that would be nice :3
13:20:37 * jle` imagines a world
13:20:51 <breadmonster> Enough people thought it wouldn't b.
13:21:16 <jle`> hm?
13:21:20 <breadmonster> Is SPJ the final and sole authority on what goes into Haskell?
13:23:06 <jle`> elliptic00: ah, in case this was your question, you have to put m = 3 in a haskell source file
13:23:19 <jle`> i wasn't sure if you were asking "why" or asking how you can make it work
13:24:26 <glguy_> Gurkenglas: x:xs <- Just []
13:24:46 <elliptic00> thx, it works,
13:28:00 <elliptic00> i have many small variables in .hs file, e.g.  f1 = max 1 4, f2 = min 3 7,   how can I make f1 and f2 in local scope so that I can use f1 and f2 in other place?
13:28:15 <Gurkenglas> glguy_, can the case match in http://lpaste.net/143224 be made to implicitly act as if there was a line 11 "_ -> Nothing"?
13:28:21 <elliptic00> in the same *.hs 
13:28:29 <Gurkenglas> (I thought fail is made for that stuff :/)
13:34:27 <glguy_> No, you'll have to write that 
13:35:10 <Gurkenglas> Dangit, I want a language extension that does that
13:36:54 <elliptic00> can I use 'deriving' in the function? e.g.  mymax::Int->Int->Int  deriving (show) ? it does't work.
13:37:30 <pavonia> You cannot have a Show instance for a function
13:37:34 <Lokathor> elliptic00, deriving is only for newtypes and data types
13:38:06 <Lokathor> pavonia, you could write it :3  but it'd probably not be much use
13:38:22 <pavonia> What?
13:38:44 <Lokathor> you could write a Show instance for functions, but it'd probably not be very useful
13:39:32 <pavonia> Yeah, but that would be an instance for function types, not a specific function
13:39:55 <pavonia> elliptic00: What would you want the deriving to do in this example?
13:40:33 <elliptic00> just want to print  (mymax 3 4 ) ++ "some string"
13:40:57 <Lokathor> use show on the result, show (mymax 3 4) ++ "some string"
13:41:45 <elliptic00> yep.. this is why I want to ask whether I can skip the show in my print something
13:42:11 <pavonia> You'd have to redefine (++) to do that
13:42:27 <elliptic00> thx.. guys..
13:43:30 <pavonia> > let x ++ y = show x Prelude.++ show y in max 2 3 ++ "foo"
13:43:31 <lambdabot>  "3\"foo\""
13:44:41 <Lokathor> elliptic00, that would probably not be a good idea to try setting up across a whole file though
13:44:46 <Lokathor> it'd mess up list concatination
13:46:30 <elliptic00> thx
13:50:50 <some0ne> why can't i use exception catched with 'try' in an either monad (i think this is because they get evaluated somehow):  https://gist.github.com/RageYL/d0718ca8aca22727a351
13:51:16 <some0ne> if an error is thrown it display *** exception instead being handled in the case
13:52:28 <pavonia> some0ne: The exceptions is probably thrown outside of the let when evaluating "something"
13:52:38 <pavonia> *of the try
13:53:20 <some0ne> if i use 'something' immediately in the case then call somethingelse in the right pattern it works
13:53:57 <glguy_> SomeOne if you want to control where the exception throwing happens don't use undefined, use throwIO
13:54:15 <some0ne> the exception is thrown with throwIO
13:54:46 <EvanR> @src undefined
13:54:46 <lambdabot> undefined = error "Prelude.undefined"
13:54:56 <EvanR> some0ne: in your paste its undefined
13:55:13 <some0ne> ah sorry i misunderstood ^^
13:55:13 <EvanR> :t throwIO (userError "ermagawd")
13:55:14 <lambdabot> IO a
13:55:24 <some0ne> i mean the undefined is not reached
13:55:47 <some0ne> here is more code: https://gist.github.com/anonymous/435500c71d8566cdc355
13:56:02 <EvanR> what is doSomething then
13:56:35 <pavonia> some0ne: readFile is lazy
13:57:03 <EvanR> doh
13:57:12 <some0ne> the error is not thrown by readFile it is throw by the throwIO (i test with a non existing file)
13:57:59 <EvanR> can you paste an actual test case
14:00:16 <k_bx> Can anyone remind me a way to make GHCi explicitly render "forall" statements when describing type please? I think I saw that in one of Richard Eisenberg’s recent videos, but couldn’t find that.
14:00:27 <some0ne> EvanR: https://gist.github.com/anonymous/6f03cfebb19e08d033a3
14:00:46 <some0ne> then in ghci run: :main -f doesnotexist
14:01:00 <EvanR> a minimal test case?
14:01:06 <EvanR> ill look at this anyway
14:01:45 <some0ne> feel free to comment it's my second haskell project ;)
14:01:53 <some0ne> i will give you a smaller :D
14:03:26 <conal> k_bx: :set -fprint-explicit-foralls
14:03:49 <k_bx> conal: thank you very much! I wonder how could I fail googling it
14:03:59 <l3france> is there a shorter function to take two parameters and put them in a list than (\x y -> [x, y])?
14:04:04 <EvanR> some0ne: so its printing out the exception
14:04:14 <EvanR> which is what its supposed to do
14:04:25 <EvanR> your code doesnt really distinguish
14:04:33 <l3france> I'm thinking how (,) is the operator for a tuple, not sure if there is a nice way to do it for lists
14:04:40 <conal> k_bx: you're welcome. someone gave me this tip, so i stashed it away, commented, in my ~/.ghci.
14:04:51 <EvanR> :t (:[])
14:04:52 <lambdabot> a -> [a]
14:05:10 <EvanR> :t flip (:) . (:[])
14:05:11 <lambdabot> a -> a -> [a]
14:05:30 <EvanR> @djinn  a -> a -> [a]
14:05:30 <lambdabot> Error: Undefined type []
14:05:50 <l3france> ohh okay, I was trying to figure something out with [] and :, but couldn't quite get it
14:05:54 <l3france> thanks!
14:06:12 <EvanR> @pl \x y -> [x,y] 
14:06:12 <lambdabot> (. return) . (:)
14:06:57 <some0ne> EvanR: yep i was using print for the moment but event when not using the e it print exit printing the exception
14:07:00 <lspitzner> :exf "a -> a -> [a]"
14:07:00 <exferenceBot> \ a -> (:) a . pure
14:07:01 <exferenceBot> \ a b -> b : pure a
14:07:13 <some0ne> (i'm trying to build a minmal example, but it somehow work, so i'm trying to figure out why :D)
14:07:37 <EvanR> follow a continuous path from the working minimal example toward the non-working complex example
14:07:44 <EvanR> as far as you can ;)
14:08:18 <some0ne> https://gist.github.com/anonymous/f2bde65bab2ecb0dfc1a it doesn't throw error :D
14:08:26 <some0ne> but in my code it do !
14:10:27 <some0ne> i think i will continue with the ugly nested working stuff, and come back to exception later. i'm still not comfortable with exception in haskell
14:11:07 <EvanR> youre probably complicating it too much
14:11:30 <some0ne> the 'core' question would be how to handle custom exception with io excpetion ?
14:11:31 <hexagoxel> how do i operate with records in a way so that a) changing the order of fields does not break code b) when i add a new field, i get a warning in places where i access the record? (so i can implement code for the added element, if necessary?)
14:11:54 <EvanR> by 1. attempting to detect the error condition before IO would, and throwing the IO error yourself which you think is necessary because 2. readFile is annoyingly not going to throw an exception sometimes until later
14:11:57 <hexagoxel> it seems to me i can only have one of the two, which really is a shame.
14:12:00 <kallisti> do singletons from genSingletons derive Show instances?
14:12:17 <EvanR> some0ne: do you need a custom exception?
14:12:22 <EvanR> in this case
14:12:44 <EvanR> and if so do you need to catch it?
14:13:23 <hexagoxel> ah, i could use `myrecord@(MyRecord _ _ _ _ _ _ _ _ _ _) = foo bar` and then use only the record accessors to actually read the fields.
14:13:41 <hexagoxel> anybody got a better idea?
14:13:42 <some0ne> no before i was handling the parsing somewhere else so i don't need a custom exception in the IO (it was by curiosity). i'm just trying to get the content of the first file that exist
14:14:28 <some0ne> and if no file exist print a message and exit
14:14:29 <EvanR> so make a function to return the first file that exists
14:14:37 <EvanR> sell, Maybe first file that exists
14:14:39 <some0ne> that's the filter part in my function
14:14:40 <EvanR> well*
14:14:51 <some0ne> if it returns an empty i throw an IOError
14:15:00 <EvanR> yeah dont mix it all up
14:15:10 <some0ne> otherwise i call readFile but i can get a race condition with what you explained
14:15:19 <EvanR> dont mix up the algorithm to get the file plus either, plus IO exception all in the same thing
14:15:39 <EvanR> youre not really buying yourself any real guarantees here anyway
14:15:41 <some0ne> for me it make sense that if no file exist, it throw a filedoesnotexist
14:15:46 <some0ne> kk
14:15:48 <EvanR> in between getting the file and reading it, it could fail
14:15:56 <EvanR> after beginning to read the file, it could fail
14:16:04 <EvanR> just accept that an exception might happen while doing IO of any sort
14:16:48 <some0ne> ok now i'm confused :D i don't understand at all how to do what i want :D
14:17:07 <some0ne> it will just blow up anytime ^^
14:17:11 <EvanR> start simple, make a function that reads the file system and gives the first of interest or Nothing
14:17:33 <EvanR> dont think about exceptions there, though they could of course happen
14:18:25 <EvanR> or if you want to tie everything to gether with Either, then return Either String Handle
14:18:37 <some0ne> no i think i will do a two part, that's easier
14:18:44 <some0ne> what should i do for the second part ?
14:19:34 <EvanR> read the file contents strictly, which "cant fail" (any more than the first part could)
14:19:50 <EvanR> then connect the Either String String to the parser with >>=
14:20:17 <EvanR> well fmap
14:20:33 <some0ne> ok =)
14:20:46 <some0ne> is it advised to never use lazy IO ?
14:21:02 <EvanR> never in a million years!!?!?!?!!1111
14:21:06 <some0ne> (if it could explode anytime it seems very hard to deal with)
14:21:13 <some0ne> :D
14:21:27 <some0ne> is there a way to read only some part ? to keep low memory usage ?
14:21:28 <EvanR> i dont like lazy IO but its good for funny quick and dirty examples
14:21:50 <EvanR> if your file is very large you can use a library to incrementally parse it
14:21:57 <Tuplanolla> It falls into the "occasionally useful, often destructive" territory.
14:22:31 <some0ne> to summarize, lazy io could throw an exception when 'asking' to read more so it can throw anytime ?
14:22:35 <EvanR> pipes and conduit come to mind for doing incremental processing with IO
14:23:08 <some0ne> i don't know any of those two stuff, will take a look =)
14:23:09 <EvanR> :t readFile
14:23:11 <lambdabot> FilePath -> IO String
14:23:26 <EvanR> @src readFile
14:23:27 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
14:23:32 <EvanR> @src hGetContents
14:23:33 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:23:45 <EvanR> @src unsafeInterleaveIO
14:23:45 <lambdabot> Source not found. Are you typing with your feet?
14:23:51 <EvanR> :t unsafeInterleaveIO
14:23:55 <lambdabot> Not in scope: ‘unsafeInterleaveIO’
14:24:10 <EvanR> its based on unsafeInterleaveIO ;)
14:24:22 <some0ne> :D
14:24:31 <EvanR> the name should help you decide
14:25:17 <some0ne> thanks for your help ;)
14:25:57 <Lokathor> in excel I could write, A1 * ceiling(A1/2.0)
14:26:00 <Tuplanolla> Good exercise: make a pure entropy pool with unsafeInterleaveIO.
14:26:13 <Lokathor> but in haskell it doesn't seem to like, i * ceiling (i / 2.0)
14:26:23 <Lokathor> how can I coerce this into happening?
14:26:59 <Tuplanolla> Place fromIntegral strategically, Lokathor.
14:27:28 <EvanR> :t fromIntegral . ceiling
14:27:29 <lambdabot> (Num c, RealFrac a) => a -> c
14:27:35 <breadmonster> EvanR: When is it okay to use unsafe functions?
14:27:41 <EvanR> nevar!
14:28:30 <EvanR> also you need to make a sacrifice to the GHC gods to ensure that fromIntegral . ceiling will be efficient for Double -> Double
14:28:54 <EvanR> or use FFI to get access to math.h
14:29:29 <Zemyla> Why is there an unsafeFreezeArrayArray but no unsafeThawArrayArray?
14:29:44 <Lokathor> Tuplanolla, thanks. Number stuff in haskell is weird sometimes
14:29:58 <Tuplanolla> Tell me about it. I'm working on numerical physics right now.
14:30:26 <EvanR> numeric haskell
14:30:38 <Tuplanolla> I'm considering writing an article or two about it once I'm done.
14:31:42 <Tuplanolla> It's quite dandy until shit goes south on the performance front.
14:33:56 <Zemyla> Does GHC mark arrays to show whether they're frozen or thawed?
14:34:05 <dolio> Yes.
14:34:28 <Zemyla> So there's no way to thaw an ArrayArray if there's no primitive for it.
14:34:46 <dolio> Probably not.
14:35:00 <dolio> Well, there is a way, but it's pretty evil.
14:35:36 <FusRoDah> hiya all
14:50:38 <Zemyla> Woohoo! Primitive.Vector is now possibly an instance of Unbox! :D
14:52:26 <inad922> Hi
14:53:00 <inad922> If I have a Maybe (Data.Set Int) how can I use the Data.Set.insert function to add an integer to it?
14:53:43 <EvanR> :t Data.Set.insert
14:53:44 <lambdabot> Ord a => a -> S.Set a -> S.Set a
14:53:57 <EvanR> fmap (insert 3)
14:55:31 <dmj`> :t fmap (S.insert 4)
14:55:32 <lambdabot> (Functor f, Num a, Ord a) => f (S.Set a) -> f (S.Set a)
14:56:01 <EvanR> Maybe (Set Int) -> Maybe (Set Int)
14:57:37 <kadoban> > fmap (S.insert 3) (pure S.empty) :: Maybe (S.Set Int)
14:57:38 <lambdabot>  Just (fromList [3])
14:58:05 <inad922> EvanR, Ah fmap
14:58:08 <inad922> Thanks
15:00:44 <inad922> eh doesn't works
15:00:46 <inad922> -s
15:00:56 <inad922> Seems like I need liftM2 form the Control.Monad package
15:01:50 <inad922> so if s is my maybe set and e is the element I want to insert I can do liftM2 insert (Just e) s
15:03:46 <EvanR> thats complicating it a lot
15:04:01 <EvanR> fmap (insert e) s should work
15:06:44 <Lokathor> so in some cases, i don't need to specify that a newtype should be unboxed ints instead of normal ints?
15:06:58 <Lokathor> GHC can just optimize an Int into an Int# some of the time?
15:29:51 * hackagebot plot-gtk 0.2.0.3 - GTK plots and interaction with GHCi  https://hackage.haskell.org/package/plot-gtk-0.2.0.3 (VivianMcPhail)
15:30:19 <Akari2> hi
15:31:35 <lrocksmashtime1> so I'm playing around with modeling a 128 barcode. https://en.wikipedia.org/wiki/Code_128 each barcode character is represented by three bars and three spaces each of which can be of widths 1, 2, 3,  or 4. I'm having a difficult time deciding how much of the type system i should or can use to ensure that the format of a barcode is represented correctly. Does it make sense to have a datatype like data Bar = Bar1 | Bar2 | Bar3 | Bar4 ? 
15:31:37 <Lokathor> Saluton
15:32:28 <Lokathor> lrocksmashtime1, I'd maybe call them BOne BTwo BThree BFour, but that's jsut a preference. Your general idea seems good
15:32:58 <lrocksmashtime1> Lokathor: ok cool I'll stay on this path. thanks for your response
15:33:54 <Akari2> can someone tell me why this doesnt compile http://pastebin.com/4jGNFssV
15:34:35 <Tuplanolla> The last pattern doesn't have a binding.
15:34:38 <Lokathor> Akari2, Dir should hold Entry [Entry]
15:34:40 <Lokathor> not EntryName
15:34:49 <Lokathor> if you want it to have a string you need to use String
15:35:02 <Lokathor> but all the things in the Constructor declaration must be actual types
15:35:18 <Tuplanolla> Besides, (:) is cons instead of (::). This isn't Idris.
15:35:32 <Lokathor> ah, that too
15:37:29 <kallisti> is it possible to get the name of a vinyl field as a value?
15:38:40 <kallisti> as far as I can tell I need to bundle the singleton type with the record value when building the record
15:38:53 <Akari2> i added this line
15:38:53 <Akari2> type EntryName = String
15:39:02 <Akari2> still doesnt compile
15:39:09 <Akari2> and corrected ::
15:41:02 <mutantmell_> Akari2: looks like your last line doesn't have an '='
15:41:22 <Akari2> i changed | to = and got a scary error
15:42:52 <mutantmell_> Akari2: what is the error?
15:43:20 <Akari2> http://prntscr.com/8sf23m
15:43:59 <mutantmell_> Akari2: What the first thing is saying is that it wanted a [Entry], but you gave it an Entry
15:45:13 <mutantmell_> Akari2: The second one says that Just is applied to three arguments -- what's going on there is that function application binds before anythign else, so it's reading it as (Just Dir) j k
15:45:32 <mutantmell_> Akari2: you might wans Just (Dir j k), or perhaps Just $ Dir j k
15:47:00 <Akari2> i fixed that one but i still dont understand the first one
15:48:19 <mutantmell_> Akari2: Here's how you read that first error: It fist says that it expected a [Entry], but found an Entry.  It then points at the value its confused about: Dir j k.  It expands the scope until it shows the full line
15:48:48 <mutantmell_> Akari2: Basically, it expects the thing where (Dir j k) is to be a [Entry], but it isn't
15:49:30 <mutantmell_> Akari2: Looking at the type of Dir, it's correct:  Dir needs its second argument to be a list, there isn't a list there.
15:50:03 <mutantmell_> Akari2: You probably want something like this: ((Dir j k) : dirs)
15:50:46 <Lokathor> Is there way to pass a file to GHC and then have it give back its strictness analysis?
15:51:28 <Cale> Lokathor: You can -ddump-simpl
15:51:43 <Cale> which ought to include annotations from the strictness analyser
15:52:27 <Cale> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/StrictnessAnalysis
15:52:36 <Cale> should help interpret the stuff it prints
15:52:55 <Akari2> yeah finally compiled , thanks!
15:53:13 <om-foxy> I forked fpco/stackage on github and now I want to update my fork with some new commits from fpco.  How do I do this using the github.com web interface?
15:53:43 <Lokathor> hmm
15:53:58 <om-foxy> I accidentally created a pull request on fpco which mistakenly requests a merge from my head.
15:54:02 <Lokathor> yeah it's a lot of stuff here
15:55:18 <bennofs> om-foxy: you could create a PR going from fpco/stackage to yourfork and accept it yourself
15:55:59 <om-foxy> bennofs:  I did that once successfully but now I'm 1 commit ahead and 10 behind and I get no option to switch the order of comparison
15:59:21 <lrocksmashtime1> say you want to ensure that something is a sequence of other things that are related. like in the case of a barcode it is comprised of six sections (quiet, start char, encoded chars, check char, stop char, quiet). So you want to say that a barcode type is Quiet Start Encoded Check Stop Quiet. Do each other these "sections" require their own data type and then you group them in a BarcodeSection type class?
16:00:31 <glguy> lrocksmashtime: Rather than a typeclass you'd make a normal data type with whatever fields a barcode has
16:02:13 <lrocksmashtime1> glguyy: right so data Quiet, data Start, data, Encoded, etc. Then data Barcode = Barcode Quiet Start Encoded ... ?
16:02:32 <bennofs> om-foxy: the following seems to work for me: Pull requests -> create new pull requests -> select your repo for both head and base fork -> click on the link "compare across forks" -> select fpco/stackage for "head fork"
16:03:01 <glguy> lrocksmashtime: You'd only put the data in it. Does "Quiet" have any data?
16:03:35 <lrocksmashtime1> it's represented as some amount of blank at the beginning and the end of a drawn barcode 
16:04:05 <glguy> lrocksmashtime: then that would only go in the "rendered" part of a barcode, but not the abstract one
16:05:22 * hackagebot socket-io 1.3.4 -   https://hackage.haskell.org/package/socket-io-1.3.4 (TimBaumann)
16:05:24 * hackagebot engine-io-yesod 1.0.3 -   https://hackage.haskell.org/package/engine-io-yesod-1.0.3 (TimBaumann)
16:05:26 * hackagebot engine-io 1.2.11 - A Haskell implementation of Engine.IO  https://hackage.haskell.org/package/engine-io-1.2.11 (TimBaumann)
16:05:45 <om-foxy> bennofs: That works for me.  Thank you.
16:10:40 * hackagebot plot-gtk3 0.1.0.2 - GTK3 plots and interaction with GHCi  https://hackage.haskell.org/package/plot-gtk3-0.1.0.2 (VivianMcPhail)
16:11:45 <lrocksmashtime1> glguy Right now I'm playing with a data type called a BarcodeSection that can be any of the five types of sections, however, that means that a Barcode type would be data Barcode = BarcodeSection BarcodeSection BarcodeSection ... which doesn't doesnt' enforce the instances of the types. I'm generally interested to know if there's a good way to create that kind of constraint on data types.
16:12:21 <kallisti> what is meant by "the instances of the types"
16:12:34 <kallisti> what does a BarcodeSection look like
16:12:57 <lrocksmashtime1> data BarcodeSection = Quiet | Start | Encoded | Check | Stop
16:13:17 <lrocksmashtime1> Quiet, Start, Encode etc are the instances.
16:13:47 <kallisti> and then I assume each of those are constructors with different kinds of data stored in them?
16:14:19 <lrocksmashtime1> still working that part out but yes Start, Stop, Check have [BarcodeChar] 
16:14:26 <kallisti> probably the simplest way to do it is to have a data type for each of those constructors. data Quiet = ...; data Start = ...; etc
16:14:35 <lrocksmashtime1> ok that's what i was wondering
16:15:09 <kallisti> and then maybe a typeclass with operations that work on more than one type of barcode section
16:15:46 <lrocksmashtime1> kallisti: will try that. thanks
16:22:02 <kallisti> lrocksmashtime: If you want to enforce a fixed length to the character arrays inside each constructor, but don't want to deal with tuples, you could try using this: https://hackage.haskell.org/package/tagged-list
16:23:09 <kallisti> the length of a TaggedList is encoded as a type parameter so you can strictly enforce a length in the type
16:23:30 <kallisti> there might be a more up-to-date version that uses GHCs type-level naturals, but I don't know where it is.
16:25:37 <lrocksmashtime1> kallisti: cool i'll check that out
16:42:08 <emmanuel_erc> hello 
16:43:33 <jophish> Why isn't e a member of Floating?
16:44:45 <glguy> > exp 1
16:44:46 <lambdabot>  2.718281828459045
16:45:03 <jophish> glguy: for some types having e in there could be quite a bit more efficient
16:45:23 <kallisti> exp 1 = superEfficientE
16:45:27 <kallisti> exp v = ...
16:45:32 <jophish> glguy: we have pi in there too :)
16:45:39 <glguy> ok
16:45:57 <jophish> > 4 * atan 1
16:45:59 <lambdabot>  3.141592653589793
16:46:21 <jophish> kallisti: that doesn't work if the type isn't an instance of Eq
16:46:24 <jle`> > 2 * acos 2
16:46:26 <lambdabot>  NaN
16:46:32 <jle`> > 2 * acos 0
16:46:33 <lambdabot>  3.141592653589793
16:47:15 <jle`> i like having variables named e tho :|
16:47:24 <kallisti> jophish: replace 1 with whatever thing represents 1, that apparently doesn't have an Eq instance for whatever reason
16:47:54 <kallisti> pattern matching still works on your hypothetical type, hopefully.
16:48:02 <jophish> kallisti: nope, it's a function :D
16:48:24 <jophish> in fact, equality is undecidable for my type
16:48:48 <kallisti> so what's the mega-blazing-fast special case e for a function?
16:49:19 <jophish> the special cased taylor series
16:49:34 <jophish> kallisti: I've not benchmarked this yet, so this is just speculation :D
16:50:14 <kallisti> :t exp
16:50:15 <lambdabot> Floating a => a -> a
16:51:21 <Big_G> Do Eq instances have to be deterministic? 
16:51:51 <jophish> Big_G: I think it would be nice if comparing two values didn't diverge
16:52:23 <kallisti> > [1..] == [1..]
16:52:27 <lambdabot>  mueval-core: Time limit exceeded
16:52:47 <jophish> hmm, good example
16:53:03 <Big_G> Not necessarily diverge. For example,is 3.14...=pi? e 
16:53:31 <Big_G> What determines the time limit? 
16:53:39 <glguy> > 3.141592653589793 == pi
16:53:40 <lambdabot>  True
16:53:46 <jophish> :/
16:53:50 <kallisti> some kind of configuration to mueval sets the time limit
16:53:58 <kallisti> there isn't a time limit in actual Haskell code
16:55:29 <jle`> Big_G: traditionally we only have three laws for Eq instances
16:56:06 <jle`> so having some inputs return bottom is fair game as long as it obeys the laws
16:56:50 <ClownPiece> Ehhh.
16:57:12 <glguy> gesundheit
16:57:53 <ClownPiece> Well obaying reflexivity is hard in that case, jle`, isn't it?
16:58:25 <jle`> ah
16:58:26 <jle`> that is truer
16:58:30 <jle`> *true
16:58:41 <jle`> i guess [1..] == [1..] => _|_ kills reflexivity
16:58:51 <jle`> so sad
16:59:25 <ClownPiece> Hmm.
16:59:40 <jle`> that's probably why there aren't any actual Eq laws in the official documentation
17:00:01 <jle`> transistivity and symmetry are probably reasonable to expect though
17:00:06 <ClownPiece> Nah, you could still include that case.
17:02:06 <ClownPiece> A discriminate class might be useful, for things like streams and functions where Eq will _|_ iff the inputs are equal.
17:04:34 <kallisti> if you assume == evaluates an expression to normal form, then you can still use equivalence relation laws
17:06:55 <freemonad> hey does anyone have a nice idea on how to model an "order" for CW ordering quadrants on a 2d plane? the thing is its not really a well defined order but it makes sense to talk about going in CW order
17:07:31 <jle`> CW?
17:07:36 <freemonad> clockwise
17:07:38 <Polarina> Clock-wise
17:07:50 <glguy> Clock--wise
17:07:59 <mson> Clock---wise
17:08:05 <freemonad> so like top right <= top left <= bottom left <=  bottom right <= top right <= top left .........
17:08:12 <hodapp> freemonad: e.g. following some pattern of positive/negative in each quadrant?
17:08:27 <awpr> freemonad: so forall x y. x <= y
17:08:30 <jle`> freemonad: how do you want top right and bottom left to compare?
17:08:34 <glguy> freemonad: You could sort them by the angle between the coordinate, the origin, and the positive x-axis
17:08:58 <freemonad> awpr: yeah its not really an order
17:09:08 <jle`> what are you going to use this for, then?
17:09:10 <freemonad> jle`: well bottom left comes right after top right going in cw order
17:09:11 <ClownPiece> a "succ" function?
17:09:28 <jle`> freemonad: yeah, but top right can also be said to come after bottom left
17:09:31 <freemonad> jle`: yeah i really just want to list the quadrants between the quadrants that two angles lie on
17:09:38 <jle`> start at bottom left and go two quadrants clockwise
17:09:39 <freemonad> using it to try arcs 
17:09:56 <hodapp> freemonad: what's between 0 degrees and 180 degrees?
17:10:26 <freemonad> jle`: yeah.. thats a god point.. maybe "top right < bottom left" is preferable because it takes only one turn
17:10:40 <freemonad> hodapp: that would be quadrant 1 and two
17:10:44 <freemonad> hodapp: topright and topleft
17:10:50 <hodapp> freemonad: why not quadrant III and IV?
17:11:04 <freemonad> because its CW order
17:11:23 <freemonad> i think..
17:11:31 <hodapp> freemonad: 180 to 0 still encompasses III and IV clockwise.
17:11:40 <freemonad> yeah
17:11:50 <freemonad> but 0 to 180 is different from 180 to 0 i guess
17:11:51 <jle`> freemonad: what do you mean by only takes one turn?
17:11:55 <freemonad> we can assume angle1 < angle2
17:12:09 <jle`> angle only makes sense measured from a 0 angle
17:13:01 <jle`> so you're going to have to live with a discontinuity...essentially it's the same as the (improper) ordering for {1,2,3,4}
17:13:09 <jle`> er, {0,1,2,3}
17:13:14 <freemonad> jle`: i mean the angle difference is less basically.. say we define angle of quadrant by the smaller one. so quad1 = 0, quad2 = 90, quad3 = 180, quad4 = 270. now now quad3-quad2 = 90, but quad2-quad3 =-90=270
17:14:25 <freemonad> jle`: hmm ok :(
17:14:34 <jle`> so you want quad0 < quad2 < quad3 < quad4 ?  sounds like just normally "ordering" {0,1,2,3}, right?
17:14:54 <freemonad> ok.. so really i just want to be able to define a function, quadsBetween
17:14:58 <freemonad> quadsBetween(0,3) = 0,1,2,3
17:15:04 <freemonad> quadsBetween(3,1) = 3,1
17:15:14 <freemonad> quadsBetween(3,2) = 3,1,2
17:15:22 <freemonad> i can do that manually
17:15:30 <freemonad> was wondering if there was some nice structure behind this
17:15:31 <jle`> maybe you can dropWhile and takeWhile
17:16:17 <jle`> > takeWhile (/= 3) . dropWhile (/= 0) $ cycle [0..3]
17:16:18 <freemonad> i think i will do this List(TopRight, TopLeft, BottomLeft, BottomRight, TopRight, TopLeft, BottomLeft, BottomRight)
17:16:19 <lambdabot>  [0,1,2]
17:16:33 <freemonad> huh
17:16:36 <jle`> > takeWhile (/= 1) . dropWhile (/= 3) $ cycle [0..3]
17:16:36 <freemonad> i will try to decipher that
17:16:37 <lambdabot>  [3,0]
17:16:37 <freemonad> thanks
17:16:55 <awpr> > let succ x = case x of { 3 -> 0; n -> n+1 } in takeWhile (/= 3) $ iterate succ 0
17:16:56 <lambdabot>  [0,1,2]
17:16:58 <jle`> the takeWhile part means it doesn't include the "end point"
17:17:19 <jle`> awpr: iterate succ 0 for your succ is just cycle [0..3]
17:17:29 <awpr> yep, it's the same thing
17:17:35 <freemonad> :t cycle [0..3]
17:17:36 <lambdabot> (Enum a, Num a) => [a]
17:17:50 <jle`> > cycle [0..3]
17:17:52 <lambdabot>  [0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1...
17:18:02 <freemonad> oh cool
17:18:10 <freemonad> yeah that is what i was going for with this i guess
17:18:10 <freemonad> List(TopRight, TopLeft, BottomLeft, BottomRight, TopRight, TopLeft, BottomLeft, BottomRight)
17:18:17 <freemonad> instead of a cycle i just have two copies
17:18:40 <awpr> > join (++) [0..3]
17:18:41 <lambdabot>  [0,1,2,3,0,1,2,3]
17:18:46 <freemonad> thanks all
17:18:53 <jle`> > fix ([0..3]++)
17:18:54 <lambdabot>  [0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1...
17:19:17 <jle`> > replicate 2 () >> [0..3]
17:19:18 <lambdabot>  [0,1,2,3,0,1,2,3]
17:20:03 <jle`> > map (`mod` 3) [0..]
17:20:04 <lambdabot>  [0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1...
17:20:10 <freemonad> mod 4 :p
17:20:12 <jle`> okay time to stop procrastinating
17:20:15 <jle`> yeah heh ><
17:21:20 <awpr> oh, cool, this is a real concept https://en.wikipedia.org/wiki/Cyclic_order
17:21:35 <awpr> so you can have a well-defined cyclic order on quadrants
17:21:44 <freemonad> woweeee
17:21:54 <freemonad> i love that people here know math <3
17:21:56 <freemonad> i will read that
17:22:07 <freemonad> huhh
17:22:12 <freemonad> cyclic orders are ternary relations
17:22:14 <freemonad> makes sense
17:33:13 <aphocus> Whats the WebGL support like in GHCjs?
17:36:23 <Cale> aphocus: I don't know if there's anything beyond the direct low-level bindings right now..
17:37:52 <Cale> aphocus: It's possible to FFI import arbitrary Javascript expressions using GHCJS, so there's always at least that level of support, and I know there are autogenerated bindings to WebGL.
17:38:48 <jle`> i think there's a low level library, isn't there?
17:38:51 <Cale> oh, I found this: https://github.com/achirkin/ghcjs-modeler
17:39:01 <aphocus> oh cool
17:39:16 <aphocus> there's an old package ghcjs-webgl from 2 years ago
17:39:18 <Cale> http://www.ia.arch.ethz.ch/modeler.html
17:39:27 <Cale> (this is a Haskell program :)
17:39:45 <mutantmell_> It's worth noting that cyclic order is not a total order, which a lot of things assume
17:40:41 <Cale> Yeah, if you define a cyclic (pre-)order on something and make an Ord instance, you'll end up with very broken behaviour out of things like Data.Set and Data.Map
17:41:36 <mutantmell_> https://en.wikipedia.org/wiki/Cyclic_order#The_ternary_relation
17:41:45 <aphocus> I guess I can't take advantage of something like GPipe with webgl :\
17:42:05 <mutantmell_> Cyclic ordering depends on a ternary relationship rather than the (usual) binary relationship
17:42:22 <aphocus> Cale, sadly all I see is a white page with some orange buttons in the corner.
17:42:41 <Cale> aphocus: hm, maybe WebGL isn't working in your browser?
17:42:54 <jophish> Cale: I just get spinning orange things
17:43:02 <Cale> weird
17:43:11 <aphocus> ncaught exception in Haskell main thread: TypeError: Cannot read property 'clearColor' of null
17:43:30 <Cale> Which browser?
17:43:32 <heatsink> An NPE in Haskell?
17:43:35 <aphocus> Chrome
17:43:43 <jophish> ah, Uncaught TypeError: Cannot set property 'status' of null
17:43:51 <mutantmell_> Cale: works for me.  Windows 8.1/chrome
17:43:53 <aphocus> I get that too
17:44:13 <jophish> Firefox seems to work better than Chrome
17:44:31 <aphocus> maybe race condition?
17:44:55 <Cale> I don't get any errors in my Javascript console.
17:45:33 <aphocus> ok refreshed again
17:45:35 <aphocus> working now
17:45:49 <aphocus> yaeh maybe a race condition, now that all the resources are cached it works fine.
17:45:56 <mutantmell_> Cale: No errors in my console either
17:46:00 <Cale> http://cale.yi.org/Modeler.png -- here's a screenshot
17:46:11 <Cale> Yeah, weird
17:47:02 <aphocus> scroll wheel up is zoom out, thats not weird at all :P
17:47:06 <mutantmell_> Just one warning about SMIL animations being deprecated
17:50:45 * hackagebot plot-gtk-ui 0.3.0.1 - A quick way to use Mathematica like Manipulation abilities  https://hackage.haskell.org/package/plot-gtk-ui-0.3.0.1 (sumitsahrawat)
17:51:09 <mutantmell_> Maybe people would know here: are there any Seattle area Haskell meetups?
17:51:56 <jle`> ah, seattle
17:54:36 <mutantmell_> oh?
18:11:38 <naudiz> there was a replacement for ghcmod.... what was it called again?
18:13:43 <MarcelineVQ> uhm
18:13:46 <MarcelineVQ> hdevtools maybe
18:13:54 <naudiz> thanks :)
18:15:12 <MarcelineVQ> dunno if it's a replacement exactly, but it looks like they do similair things
18:15:38 <naudiz> it's the one I was looking for
18:15:43 <MarcelineVQ> cheers
18:16:24 <troydm> quick question when parsec's parser fails it doesn't rewinds the input right?
18:20:04 <glguy> unless you use 'try'
18:20:36 <MarcelineVQ> oh neato "The parser try p behaves like parser p, except that it pretends that it hasn't consumed any input when an error occurs."
18:20:45 <richardiii> newb question incoming
18:21:01 <richardiii> what would be the difference doing
18:21:11 <richardiii> addMul :: Num a => a -> a -> (a, a)
18:21:12 <richardiii> addMul x y = (x + y, x * y)
18:21:19 <richardiii> vs
18:21:23 <richardiii> addMul :: Int -> Int -> (Int, Int)
18:21:23 <richardiii> addMul x y = (x + y, x * y)
18:22:15 <richardiii> Just starting to read about typeclasses
18:22:21 <MarcelineVQ> Exactly what it suggests, you must use Int in the second one, you can't give it Integer or Double, etc
18:22:34 <richardiii> Ohhhhh I see
18:22:47 <richardiii> so typeclasses can take more than one type
18:22:53 <richardiii> that is the benifit
18:23:14 <richardiii> MarcelineVQ: thanks :D
18:24:22 <MarcelineVQ> Typeclasses restrict what types can be used where, so that you only use types that all have the same behavoir for your functions.
18:24:49 <richardiii> Right
18:24:53 <MarcelineVQ> Double, Int, Integer, Float, etc, all have (+) as a behavoir, because they implement Num
18:25:20 <MarcelineVQ> http://hackage.haskell.org/package/base-4.8.1.0/docs/Prelude.html#t:Num
18:25:33 <MarcelineVQ> So you're definetly on the right track, have fun with typeclasses :>
18:25:43 <richardiii> :D
18:25:58 <naudiz> any idea why irc-client can't be found by stack or cabal? :/ https://hackage.haskell.org/package/irc-client-0.2.4.0
18:27:20 <MarcelineVQ> How is it looking for it? is it a dependency in a .cabal file?
18:28:35 <naudiz> MarcelineVQ: yes
18:29:00 <MarcelineVQ> What's the error? paste it to a pastebin of some kind if it's long
18:29:14 <naudiz> it looks like a nice lib for a u8 irc bot, so I'd like to use it
18:30:11 <naudiz> "Could not find package irc-client in known packages"
18:30:19 <naudiz> that was for stack
18:30:40 <MarcelineVQ> Ah that'll do it
18:30:42 <MarcelineVQ> Stack doesn't have it
18:30:43 <naudiz> cabal: At least the following dependencies are missing: irc-client -any
18:31:12 <naudiz> but at least cabal should have it, shouldn't it?
18:31:30 <MarcelineVQ> Sure, `cabal install irc-client` should work
18:32:13 <naudiz> but why doesn't it with a cabal file?
18:32:18 <MarcelineVQ> I'm not sure how to make that all play together nicely when working with something from hackage and using stack though
18:32:42 <MarcelineVQ> It might be in the stack docs since it'd be a common issue
18:32:45 <glguy> naudiz: If you want to install the dependencies for a package you're building you use 'cabal install --dep'
18:32:59 <naudiz> maybe with another resolver?
18:33:24 <naudiz> glguy: ah, thanks. forgot that, since I'm avoiding cabal insall by now :/
18:33:57 <glguy> With stack you'll need to add it to your stack.yaml
18:34:37 <naudiz> to extra-deps?
18:41:09 <MarcelineVQ> hmm, ok
18:41:26 <MarcelineVQ> add irc-client to your package depends in your .cabal
18:41:47 <MarcelineVQ> run, stack solver, add the extact versions solver tells you you need to the extra-deps of stack.yaml
18:41:53 <MarcelineVQ> Worked for me
18:42:29 <MarcelineVQ> e.g. http://lpaste.net/143243
18:42:41 <naudiz> thanks, I'll try
18:43:16 <naudiz> works, thank you :)
18:43:19 <MarcelineVQ> Nice
18:43:53 <naudiz> stack is still a little new to me, while cabal-install is already too old...
18:45:48 * hackagebot bimap 0.3.1 - Bidirectional mapping between two key types  https://hackage.haskell.org/package/bimap-0.3.1 (joel_williamson)
18:56:34 <darkstalker> i'm trying to write a [Word8] to a file as binary data, so i guess i should use hPutBuf right?
18:56:44 <darkstalker> but don't know how to generate the "Ptr"  from it
18:57:28 <glguy> The easiest way is going to be to use ByteStrings
18:58:02 <glguy> pack :: [Word8] -> ByteString; Data.ByteString.hPut :: Handle -> ByteString -> IO ()
18:59:22 <darkstalker> can't write them directly? need to convert them to ByteString first?
19:02:24 <Akari2> how can i correct the second function http://pastebin.com/5EyLuN6p
19:03:17 <pavonia> Akari2: What's wrong with it?
19:03:52 <Akari2> returns Nothing only
19:04:42 <pavonia> For what input?
19:08:47 <Akari2> ah ok it works but i realized i dont do any checks for the name of the root 
19:09:30 <Akari2> so it doesnt work in that scenario
19:09:40 <glguy> Akari2: I don't know what that function is supposed to do, but line 21 is never used, it overlaps with the previous 2 lines
19:13:54 <Akari2> http://prntscr.com/8sgr1p given  ["dir1", "dir1a"] i want to get dir1a1 and dir1a2
19:36:49 <ReinH> darkstalker: why use [Word8] instead of ByteString in the first place?
19:39:41 <darkstalker> ReinH, can i construct a ByteString directly from a list comprehension?
19:40:27 <ReinH> darkstalker: No, but there's probably a better way. What are you doing?
19:40:45 <darkstalker> this https://gist.github.com/darkstalker/bf460462c7f34acf2a25
19:41:34 <ReinH> Could you be more specific?
19:41:56 <lpaste> glguy pasted “For Akari2” at http://lpaste.net/143245
19:42:02 <darkstalker> there: https://gist.github.com/darkstalker/bf460462c7f34acf2a25#file-sphtrace-hs-L124
19:42:05 <darkstalker> line 124
19:42:18 <glguy> Oh, didn't notice that Akari2 had gone :(
19:49:43 <ReinH> darkstalker: I'd probably use data Image = Image Int Int B.ByteString and toLazyByteString . foldMap word8 $ [ pixel x y | ... ], although iirc JuicyPixels uses a Vector instead.
19:49:57 <ReinH> Either way, a list isn't a good choice
19:50:15 <ReinH> (also probably data Image = Image !Int !Int !B.ByteString)
20:40:55 * hackagebot ether 0.3.1.0 - Monad transformers and classes  https://hackage.haskell.org/package/ether-0.3.1.0 (int_index)
20:45:54 <KaneTW> is there a specialized haskell library for graphs with vertices subset R^n and edge being the distance between two nodes
20:48:40 <Hafydd> KaneTW: is every pair of vertices in such a graph connected by a single edge?
20:49:55 <KaneTW> yes
20:50:19 <Hafydd> KaneTW: what kind of computation would you perform with these graphs?
20:51:44 <KaneTW> shortest path between a subset of vertices with a custom distance function (i need to minimize edge count, then weight = distance between vertices), then delta-tsp on that subset with edges being the computed shortest paths
20:52:30 <Hafydd> KaneTW: I thought that (1) the weight of each edge was always the Euclidean distance, and (2) the graphs were always complete!
20:52:50 <KaneTW> they are, it's a different graph
20:53:11 <KaneTW> i have one complete graph with euclidean distance
20:53:43 <KaneTW> i run said modified shortest path algorithm on a subset of nodes from that graph and get a bunch of paths
20:53:47 <KaneTW> and build a new graph out of those
20:53:55 <Hafydd> Oh.
20:54:30 <Hafydd> Do you really want a library specialised particularly for the first type of graph, then?
20:55:02 <KaneTW> not really, but that graph is quite large (around 50k vertices)
20:55:09 <KaneTW> while the second one has around 10
20:55:59 <Hafydd> I see. I'm afraid I don't have anything to recommend, myself.
20:56:28 <KaneTW> i'm thinking of using postgres to get the shortest paths since it's quite a bit of data
20:59:12 <KaneTW> pgrouting might do what i want
21:00:46 <KaneTW> don't know if it can handle R^3 data
21:05:56 * hackagebot ether 0.3.1.1 - Monad transformers and classes  https://hackage.haskell.org/package/ether-0.3.1.1 (int_index)
21:20:57 * hackagebot cubicspline 0.1.2 - Natural cubic spline interpolation.  https://hackage.haskell.org/package/cubicspline-0.1.2 (GershomBazerman)
21:37:30 <Lokathor> the trouble I'm having is
21:37:58 <Lokathor> the split method on RandomGen doesn't in any way specify the relationship between the input generator and the output generators
21:38:09 <Lokathor> it's unclear if either of the output generators can be the input generator
22:11:52 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
22:11:52 --- topic: set by quicksilver!~jules@roobarb.crazydogs.org on [Wed Oct 07 07:39:49 2015]
22:12:02 <Lokathor> here's the thing, the stdlib specifically has a comment saying -- no statistical foundation for this!
22:12:13 <Zekka> I'm not a statistician! Don't trust me!
22:12:13 <Lokathor> which makes me laugh in a worried sort of way
22:12:27 <MarcelineVQ> Lokathor: it's complicated appearantly
22:12:49 <Zekka> I'm just saying that the two rngs produced by split should not be obviously related based on inspecting the output, and that there are already good implementations of RNGs that, to my extremely non-expert eyes, seem to satisfy those conditions
22:12:59 <MarcelineVQ> Prob better off with a crypt-lib of some kind, if you want some random
22:13:31 <Lokathor> well i want to implement this specific random style
22:14:01 <Lokathor> and i only need the "enough" random that one would use for games and such, not for crypto
22:14:43 <kallisti> is it possible to get the name of a vinyl field as a value? as far as I can tell I need to store the singleton inside the record so I can work with it later.
22:14:50 <MarcelineVQ> I just meant for tools and ideas, not strength
22:15:05 <kallisti> but I'd rather avoid this if possible. Seems like all the information should be available in the types
22:21:06 * hackagebot conduit 1.2.5.1 - Streaming data processing library.  https://hackage.haskell.org/package/conduit-1.2.5.1 (MichaelSnoyman)
22:21:08 * hackagebot shakespeare 2.0.7 - A toolkit for making compile-time interpolated templates  https://hackage.haskell.org/package/shakespeare-2.0.7 (MichaelSnoyman)
22:21:37 <kala> Why would that be that hard exactly... if you have a single PRNG buffering values which are fetched by multiple threads, as long as each value is only dispatched once shouldn't the stuff each thread gets necessarily be independent?
22:21:44 <kala> If it isn't, the PRNG is obviously broken.
22:30:57 <Azevedo> /q lambdabot
22:30:58 <Azevedo>  
22:37:37 <darkf> trying to `stack build` sdl2 gives "* Missing (or bad) header file: SDL.h" but the include path given by `pkg-config sdl2 --cflags` and also given by me from --extra-include-dirs has that file. what's going on here?
22:38:14 <darkf> (this is on windows with msys)
22:38:51 <tejon_> There's a bad header in the Windows SDL2 distribution (not the bindings). A drop-in replacement is available, if you haven't done that it's probably the culprit.
22:39:37 <darkf> hm, I installed it via msys2's package, but I can try that. which header?
22:39:56 <tejon_> https://hg.libsdl.org/SDL/raw-file/e217ed463f25/include/SDL_platform.h
22:41:39 <darkf> ah, that actually works, heh. thanks tejon_, weird that it complains about SDL.h then
22:42:42 <tejon_> I think it's an indirect import. Good luck, I'm currently in toolchain hell with regards to getting sdl2 to work at all. Hoping 7.10.3 fixes that. :P
22:42:59 <darkf> what's wrong with yours?
22:43:36 <tejon_> If I knew, it would be fixed. ;) Last I recall, I was running into a linker error.
22:44:04 <darkf> tejon_: heh, want to post the error?
22:44:55 <tejon_> It *was* working once, but I don't want to dig too hard right now because I need a stable environment for other work and, y'know, Windows.
22:45:58 <Lokathor> https://github.com/Lokathor/roguelike-hs/blob/master/src/Roguelike/Util/RNG.hs
22:46:07 * hackagebot pandoc 1.15.1.1 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-1.15.1.1 (JohnMacFarlane)
22:46:12 <Lokathor> this is how I decided to do the 'split', MarcelineVQ 
22:46:29 <Lokathor> I even included the handy comment!
22:47:50 <darkf> argh "Could not find module `SDL'" it's a build-depend so that's weird
22:48:46 <tejon_> darkf, yeah, that's why I don't quite remember which problem I quit on... it's a whack-a-mole situation. :P
22:49:41 <darkf> tejon_: well, I think this is a stack situation (it wants to use 1.3.1 probably because I'm in LTS, when I have 2.0.0 installed)
22:50:04 <darkf> maybe I can force the constraint up somehow
22:56:29 <darkf> tejon_: yep, linker errors -- hitting https://github.com/haskell-game/sdl2/issues/41 :(
22:57:33 <tejon_> Trying to use GHCi, or actually compiling? That one shouldn't happen for the latter.
22:57:51 <darkf> tejon_: trying to compile my program that uses sdl2 and TH
22:58:01 <tejon_> Oh well yeah, TH does it too. :P
22:58:23 <mgsloan> darkf: Yeah, you can upgrade individual packages by specifying in your "extra-deps:" list something like "- PKG-2.0.0"
22:58:38 <mgsloan> and it will override the stackage version
22:59:14 <tejon_> It's a pretty terrible situation right now. I'm not 100% sure that one's actually fixed for next release, either. :(
23:00:01 <darkf> indeed... I wonder how I managed to cajole sdl2 into working a couple months prior. perhaps it's because I was not using stack. :) someone mentions the 64-bit build working, perhaps I could try that.
23:00:37 <tejon_> https://ghc.haskell.org/trac/ghc/ticket/3242 Nope, still open. High priority at least...
23:03:27 <gexe> Hey all, question
23:03:59 <gexe> I'm taking a course and we are using Programming in Haskell as the text
23:04:39 <Cale> gexe: Hutton's book?
23:04:48 <gexe> Here is a sentence which I don't understand "“Note that even though the function sum is defined in terms of itself and is hence recursive, it does not loop forever.”
23:05:07 <gexe> yeah Hutton
23:05:25 <Cale> Okay, so the assumption is that the list is finite, I suppose.
23:05:26 <gexe> what does it mean for something to be defined in terms of itself
23:05:53 <Cale> Ah, are you looking at the definition of sum?
23:06:05 <Cale> I'm assuming there's a definition something like this:
23:06:08 <Cale> sum [] = 0
23:06:12 <Cale> sum (x:xs) = x + sum xs
23:06:18 <gexe> yes
23:06:31 <Cale> Note that the second equation makes use of sum itself on the right hand side.
23:06:34 <gexe> that was the exact example that was just given 
23:06:42 <Cale> so we're defining the sum of the list (x:xs) in terms of the sum of the list xs
23:07:04 <gexe> OH!
23:08:22 <gexe> so it's not an overall definition of sum, just of how that example was written?
23:08:58 <tejon_> Well, that IS an overall definition of sum. :)
23:09:00 <Cale> Uh, that is a definition of a function called sum
23:09:18 <Cale> and it is complete -- it defines sum for every list of numbers
23:09:50 <gexe> Thanks Cale
23:09:55 <gexe> I must read on!
23:10:43 <Cale> Note that if we apply sum to some list like (1 : (2 : (3 : []))), i.e. the list [1,2,3], using the equations, we can get:
23:11:02 <Cale> sum (1 : (2 : (3 : [])))
23:11:04 <Cale> = 1 + sum (2 : (3 : []))
23:11:15 <Cale> = 1 + (2 + sum (3 : []))
23:11:26 <Cale> = 1 + (2 + (3 + sum []))
23:11:32 <Cale> = 1 + (2 + (3 + 0))
23:11:46 <Lokathor> gexe, a term for functions defined in terms of themselves is a "recursive function"
23:12:58 <gexe> I feel like that might be something I spend some time on understanding then. 
23:13:12 <gexe> All I've ever done is simple jquery stuff 
23:13:54 <gexe> *need to spend time on understanding 
23:20:59 <Sinestro> Am I mixing something on Hackage, or am I stuck using blaze-html if I want Markdown parsing in Haskell?
23:22:24 <Sinestro> At least in pure Haskell
23:25:13 <Walther> Sinestro: pandoc?
23:25:27 <Sinestro> Wow
23:25:33 <Sinestro> I was being profoundly retarded.
23:25:38 <Sinestro> -Profoundly-.
23:26:03 <Sinestro> I'm glad that I didn't get much further than just peeking at the markdown spec on my little idea of writing my own
23:26:18 <Lokathor> gexe, the most basic recursive function examples are Factorial and Fibonacci
23:26:42 <Walther> Lokathor: and maybe even length
23:26:58 <Lokathor> ah, yes, and length is similar to sum as well
23:27:00 <Walther> although that is probably more useful as pattern matching example
23:27:06 <Walther> Mm.
23:41:32 <gexe> Thanks everyone for being very helpful :)
