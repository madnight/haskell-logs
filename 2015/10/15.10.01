00:07:40 * hackagebot twiml 0.2.0.0 - TwiML library for Haskell  https://hackage.haskell.org/package/twiml-0.2.0.0 (andrus)
00:07:40 * hackagebot patches-vector 0.1.0.1 - A library for patches (diffs) on vectors, composable and invertible.  https://hackage.haskell.org/package/patches-vector-0.1.0.1 (LiamOConnorDavis)
00:17:35 * hackagebot sha-streams 0.2.1 - SHA hashes for io-streams.  https://hackage.haskell.org/package/sha-streams-0.2.1 (VoMinhThu)
00:19:05 <neuroserpens> :t any
00:19:07 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
00:20:58 <lpaste> JulianLeviston pasted “Anyone know why this doesn't work?” at http://lpaste.net/142058
00:23:12 <julianleviston> Oh.. it’s because parseJSON is returning a parser sin’t it… but toJSON wants a value.
00:23:23 <Cale> It's because the types are under-specified
00:23:26 <wagle> julianleviston:  no instance defined for a list of Somethings toJSON [brianBook, brianBook, brianBook]
00:23:38 <julianleviston> um nah
00:23:42 <julianleviston> lists work fine.
00:23:47 <Cale> toJSON will convert the list of Books to a JSON object, and then parseJSON doesn't know what to parse
00:23:55 <julianleviston> Cale: yeah :)
00:24:03 <julianleviston> Cale: coz it gets handed a Parser a
00:24:04 <Cale> because the result is immediately being consumed by another toJSON which is polymorphic
00:24:19 <julianleviston> Cale: ok… so how do I turn my Parser into a value I wonder...
00:24:24 <wagle> oh nevermind, sorry
00:24:25 <julianleviston> decode!
00:24:34 <Cale> Well, hang on
00:25:04 <julianleviston> hm apparently not
00:25:08 <julianleviston> ok hanging on :)
00:25:12 <Cale> right, okay, parseJSON produces a Parser a value, but that's beside the point really
00:25:18 <Cale> You probably meant to use fromJSON?
00:25:33 <Cale> But still, what you're asking for is underspecified
00:25:56 <Cale> You'll need to put in an explicit type signature so that it knows which parser to use
00:26:11 <julianleviston> Cale: really?
00:26:28 <julianleviston> Cale: doesn’t that kind of defeat the purpose of parsing?
00:26:42 <julianleviston> Cale: it can only be one thing
00:26:52 <Cale> No, it could be almost any type at all
00:26:56 <julianleviston> no
00:27:07 <Cale> The parse might fail for lots of types
00:27:15 <Cale> But you can't know that without running every possible parser
00:27:22 <Cale> which it doesn't do
00:27:23 <julianleviston> crap.
00:27:27 <Cale> That's not how type classes work
00:27:56 <Cale> You fix the type, an instance of the type class gets selected, the instance determines which parser to apply
00:28:00 <julianleviston> that really sucks.
00:28:17 <Cale> What are you trying to make your program do?
00:28:19 <julianleviston> is my type not fixed?
00:28:30 <julianleviston> Cale: it’s a test program which I’m learning Aeson with.
00:28:45 <julianleviston> Cale: currently I’m trying to roundtrip data in a sum type
00:30:08 <Cale> Try something like:
00:30:10 <Cale> case fromJSON (toJSON [brianBook, brianBook]) :: Result [Something] of
00:30:22 <Cale>    Error str -> ...
00:30:49 <Cale>    Success xs -> print $ toJSON xs
00:31:03 <julianleviston> Ok cool got this.
00:31:04 <julianleviston> decode ( encode (toJSON brianBook)) :: Maybe Something
00:31:09 <julianleviston> works.
00:31:22 <julianleviston> I guess I just have to build all of my stuff “inside” that type, so to speak :)
00:31:28 <Cale> uh
00:31:30 <julianleviston> Cale: thanks :)
00:31:40 <Cale> What are decode/encode from?
00:31:42 <dtscode> so I just learned about the $ operator. suddenly, a lot more code makes sense
00:31:44 <julianleviston> Aeson
00:31:52 <julianleviston> dtscode:  hehe nice :)
00:31:54 <Cale> oh, right, it also defines those
00:32:00 <julianleviston> yerp :)
00:32:27 <Cale> Yeah, if you specify what you want to decode, then it will be fine
00:32:37 <Cale> The problem was just that it didn't know what you wanted to decode
00:32:47 <julianleviston> Cale: yeah, got it.
00:32:57 <julianleviston> Cale: I thought I was specifying it in the JSON
00:33:08 <julianleviston> Cale: but then again, that’s the point of types :-)
00:33:17 <Cale> The types only exist at compile time
00:33:29 <julianleviston> Cale: wouldn’t very well be able to typecheck it if it didn’t know what to expect would it…
00:33:32 <Cale> and can't wait until runtime to be determined
00:33:53 <julianleviston> Cale: yep. which just means I’ve got to encode all my ambiguities in the types.
00:38:29 <xpilot> ok, I think I've narrowed the problem down to any quoted promoted data constructor
00:38:39 <xpilot> data a ::: b = a ::: b
00:38:51 <xpilot> :k (Int '::: Int)
00:38:52 <lambdabot> Not in scope: data constructor ‘:::’
00:40:09 <xpilot> can lambdabot remember definitions?
00:40:14 <jle`> yes
00:40:29 <jle`> if you define things with @let it'll remember them until it's undefined
00:41:01 <julianleviston> which can lead to some slightly interesting results ocassionally ;-)
00:41:05 <xpilot> @let data a ::: b = a ::: b
00:41:06 <lambdabot>  Defined.
00:41:10 <xpilot> :k (Int '::: Int)
00:41:11 <lambdabot> * ::: *
00:41:27 <julianleviston> ooh what does ::: do?
00:41:31 <xpilot> there we go, thanks jle'
00:41:38 <cocreature> julianleviston: he just defined it
00:41:44 <cocreature> julianleviston: it's an infix data constructor
00:41:53 <julianleviston> ahhh silly me.
00:41:55 <cocreature> like : is one for lists
00:41:56 <julianleviston> cocreature: thanks :)
00:42:11 <xpilot> :k (':::)
00:42:12 <lambdabot> parse error on input ‘:::’
00:42:23 <xpilot> :(
00:42:26 <julianleviston> awww
00:42:35 <xpilot> that is the problem I'm dealing with
00:42:48 <julianleviston> :k (:::)
00:42:50 <lambdabot> * -> * -> *
00:42:55 <julianleviston> pretty.
00:43:07 <xpilot> any quoted promoted data constructor can't be partially applied :(
00:43:08 <julianleviston> xpilot: what’s the problem?
00:43:12 <julianleviston> ahh
00:43:31 <Cale> hmm
00:43:35 <Cale> :k '(:::)
00:43:36 <lambdabot> k -> k1 -> k ::: k1
00:43:39 <xpilot> as far as I can tell it's just a limitation of the parser
00:43:41 <Cale> yes it can
00:43:44 <xpilot> Cale you genius
00:44:18 <jle`> i remember running into this
00:45:33 <xpilot> :k '(Int :::)
00:45:35 <lambdabot> parse error on input ‘)’
00:45:58 <xpilot> :k '(Int ':::)
00:45:59 <lambdabot> parse error on input ‘)’
00:46:13 <xpilot> surely that is possible?
00:46:32 <wagle> :k (`(:::) Int)
00:46:34 <lambdabot> parse error on input ‘`’
00:46:38 <wagle> awww
00:46:50 <xpilot> :k ('(:::) Int)
00:46:51 <lambdabot> k -> * ::: k
00:46:56 <xpilot> there we go
00:47:02 <wagle> oh
00:47:04 <wagle> duh
00:47:14 <wagle> right idea, wrong implementation
00:47:55 <xpilot> I've definitely seen backticks in place of single quotes somewhere
00:48:10 <wagle> ETOOMUCHBASH
00:49:12 <wagle> egads, "cabal install gitit" installs EVERYTHING
00:49:14 <liste> > 5 `mod` 3 --- xpilot?
00:49:15 <lambdabot>  2
00:49:27 <wagle> oh right
00:49:50 <Hafydd> ETOOMUC*** Exception: out of meSegmentation fault
00:50:43 <wagle> forward tick is usually a suffix?
00:51:03 <liste> or ``latex style quotes'' ?
00:51:05 <Hafydd> If "forward tick" means "apostrophe," then, in Haskell, yes.
00:51:47 <wagle> error "," unexpected 
00:51:54 <wagle> 8)
00:51:55 <Hafydd> But in other functional languages, it can be used as a prefix to denote a type variable, for example.
00:52:12 <wagle> ya
00:52:34 <D3nnisd> Morning
00:52:34 <Hafydd> EDONOTCARE
00:52:53 <MarcelineVQ> :>
00:52:58 <D3nnisd> Anyone here speaking chinese?
00:53:59 <Shockk> I'm doing an entry level module in Mandarin at university if that counts
00:54:20 <D3nnisd> Can i pm you?
00:54:24 <wagle> ls
00:54:57 <Shockk> it probably doesn't count because I've only learned about 6 phrases
00:55:03 <D3nnisd> oh
00:55:04 <D3nnisd> :p
00:55:09 <Shockk> lol
00:55:24 <D3nnisd> Im having trouble with tracking a package from chinepost
00:55:46 <D3nnisd> Google translate wont help
00:56:44 * wagle learned 2...  thats 8 between us
00:57:05 <pacak> D3nnisd: Why not? Usually works for me
00:57:15 <D3nnisd> Because it gives me something strange
00:57:16 <D3nnisd> Look
00:57:23 <D3nnisd> If i translate it, it gets me : [Packet] has Acceptance Center
00:57:31 <D3nnisd> Doesnt make sense, does it
01:16:05 <bollu> merijn: what was the cool library for parsing you mentioned?
01:16:16 <bollu> merijn: the one with the clang lke diagnostics?
01:16:17 <bollu> like*
01:16:49 <merijn> trifecta
01:17:03 <bollu> thank you!
01:17:14 <merijn> bollu: Here's an example of how to use it https://github.com/merijn/lambda-except/blob/master/Lexer.hs
01:17:35 <bollu> merijn: ty :)
01:21:47 <bollu> what's GeneralizedNewtypeDeriving?
01:22:55 <RageYL> how can i tell attoparsec that something goes wrong ? (something like the 'unexpected' from parsec ?)
01:23:28 <Cale> bollu: It lets you derive any type class for a newtype which was supported by the underlying type
01:23:32 <Cale> (basically)
01:23:38 <quchen2> A skew-binary heap is supposed to not have "chains of carries propagating arbitrarily", making insertion linear. But isn't incrementing a skew-binary number O(log(number)) nevertheless, since we have to find the rightmost non-zero digit?
01:24:11 <liste> @let data MyInt = MyInt Int deriving (Num, Integral) -- bollu
01:24:12 <lambdabot>  .L.hs:149:22:
01:24:12 <lambdabot>      Can't make a derived instance of ‘Num MyInt’:
01:24:12 <lambdabot>        ‘Num’ is not a derivable class
01:24:24 <bollu> oh
01:24:29 <liste> seems it's off on lambdabot
01:24:39 <quchen2> edwardk: Probably a question for you ;-) ^^^
01:24:45 <bollu> oh, hm, so it "knows" how to write the wrapping and unwrapping for a newtype?
01:24:47 <liste> bollu oh sorry, used data by accident
01:24:54 <liste> @let newtype MyInt = MyInt Int deriving (Num, Integral) -- bollu
01:24:55 <lambdabot>  .L.hs:149:25:
01:24:55 <lambdabot>      Can't make a derived instance of ‘Num MyInt’:
01:24:55 <lambdabot>        ‘Num’ is not a derivable class
01:25:50 <liste> that'd work with GeneralizedNewtypeDeriving
01:36:48 <quicksilver> bollu: exactly. And even stronger than that, it doesn't actually write them at all.
01:37:00 <quicksilver> bollu: it just uses the fact that the underlying representation is the same and cheats.
01:37:19 <Tokuchi> HI
01:37:30 <bollu> quicksilver: hahaha, nice! so it's a performance boost as well?
01:37:41 <quicksilver> in some cases yes
01:38:00 <quicksilver> the idea is that newtype wrappers should have no performance cost at all - they're just a way of controlling your code with the type system
01:38:18 <quicksilver> see also the class method 'coerce'
01:38:21 <quicksilver> :t coerce
01:38:22 <lambdabot> (Functor f, Contravariant f) => f a -> f b
01:38:26 <arkeet> wrong coerce
01:38:29 * quicksilver nods
01:38:42 <bollu> oh, but that coerce looks interesting
01:38:43 <arkeet> :t Data.Coerce.coerce
01:38:44 <lambdabot> GHC.Types.Coercible a b => a -> b
01:38:45 <bollu> how that it work?
01:38:52 <bollu> huh
01:38:52 <arkeet> which one?
01:38:58 <bollu> (Functor f, Contravariant f) => f a -> f b
01:38:59 <arkeet> the first coerce is from lens and is unrelated.
01:39:12 <quicksilver> bollu: that works because Functor + Contravarian implies Const
01:39:16 <bollu> arkeet: yes, but, I'm trying to understand how it works
01:39:20 <bollu> quicksilver: how so?
01:39:26 <arkeet> :t fmap (const ())
01:39:27 <bollu> :t fmap
01:39:27 <lambdabot> Functor f => f b -> f ()
01:39:28 <arkeet> :t contramap (const ())
01:39:28 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:39:29 <lambdabot> Contravariant f => f () -> f b
01:39:29 <quicksilver> basically if you are both co and contravariant you can't "really have" a value of 'a' in there at all
01:39:38 <arkeet> :t contramap (const ()) . fmap (const ())
01:39:39 <lambdabot> (Functor f, Contravariant f) => f b1 -> f b
01:39:42 <bollu> quicksilver: ah
01:40:05 <bollu> hm
01:40:19 <quicksilver> although "having a value" is a dodgy intuition for what functor means
01:40:21 <quicksilver> I apologise for that :)
01:40:24 <arkeet> :t () $< () <$ ()
01:40:26 <lambdabot>     Not in scope: ‘$<’
01:40:26 <lambdabot>     Perhaps you meant one of these:
01:40:26 <lambdabot>       data constructor ‘Seq.:<’ (imported from Data.Sequence),
01:40:26 <arkeet> er
01:40:36 <quicksilver> but arkeet has shown the proof, which is also the implementation.
01:40:40 <quicksilver> hurrah for constructive logic.
01:40:41 <arkeet> I dunno what I was thinking.
01:40:51 <bollu> because fmap goes (a -> b) -> f a -> f b | cofmap is (a -> b) -> f b -> f a, in some way you're not using the (a -> b) at all?
01:41:10 <bollu> :t \f -> flip (fmap f)
01:41:11 <lambdabot> (a -> c) -> b -> (b -> a) -> c
01:41:15 <jle`> (cofmap is very different from contramap, btw)
01:41:23 <bollu> :t cofmap
01:41:25 <lambdabot>     Not in scope: ‘cofmap’
01:41:25 <lambdabot>     Perhaps you meant one of these:
01:41:25 <lambdabot>       ‘fmap’ (imported from Control.Monad.Writer),
01:41:41 <bollu> jle`: oh, right. I meant contramap :)
01:41:44 <bollu> what's cofmap?
01:41:51 <jle`> http://hackage.haskell.org/package/acme-cofunctor-0.1.0.0/docs/Data-Cofunctor.html
01:42:25 <bollu> jle`: lol :) functor is its own dual is the joke, I hope?
01:43:09 <jle`> :p
01:45:55 <Tokuchi> im in a computing lesson
01:49:18 <bollu> unrelated but still - is the el cap update slooooooow?
01:49:26 <bollu> the download speeds are abysmal
01:52:39 * hackagebot case-insensitive 1.2.0.5 - Case insensitive string comparison  https://hackage.haskell.org/package/case-insensitive-1.2.0.5 (BasVanDijk)
02:02:07 <merijn> ugh, I really can't figure out a nice way to make the parsing of data with source locations nice :\ Token based parsers consume trailing whitespace, so a naive "withPos p = do { start <- position; result <- p; end <- position; return (result, (start, end)) }" approach ends up including the trailing whitespace in my locations, which is not what I want :\ But I can't really figure out how to avoid without di
02:02:13 <merijn> tching token based parsing and manually dealing with whitespace everywhere...
02:05:44 <bollu> merijn: make a type called "Sourced" or something that is a monoid
02:05:51 <bollu> merijn: that stores original source locations
02:06:12 <bollu> merijn: but when building ast's, smash the Sourced together using the <> to "combine" source locations
02:06:39 <bollu> https://github.com/bollu/hask-lisp-interp/blob/master/src/Main.hs#L18
02:06:52 <bollu> I don't know if that's a very naive technique or something, but it worked for me
02:06:55 <merijn> bollu: That doesn't solve the problem of "how do I avoid parsing the whitespace"
02:07:04 <merijn> tracking the source location is easy
02:07:20 <bollu> merijn: what? tokenize it, and trace the source location with the tokens
02:07:21 <merijn> Doing so without also accidentally including the trailing whitespace of tokens is the problem
02:07:40 * hackagebot lentil 0.1.6.0 - frugal issue tracker  https://hackage.haskell.org/package/lentil-0.1.6.0 (fffaaa)
02:07:42 <bollu> merijn: https://github.com/bollu/hask-lisp-interp/blob/master/src/Main.hs#L175
02:08:06 <bollu> merijn: also, yes, I know that every single one of those functions is StateT :) I wanted to understand how StateT worked
02:08:10 <merijn> bollu: The token parser is consuming trailing whitespace, I either have to explicitly do whitespace everywhere which is obnoxious or rewrite the token parser, which means duplicating work and breaking some trifecta features
02:08:52 <merijn> bollu: You basically reimplemented the parser from scratch, which is what I'm trying to avoid doing
02:08:55 <bollu> merijn: ag
02:09:02 <bollu> merijn: ah, yeah
02:15:10 <julianleviston> If I have a data contructor Book {name :: string, age :: Int}, how would I construct a list of Books, such that name and age are applied from two lists? I could use the List Monad instance… or a list comprehension, but I’d like to use Applicative, if I can… is that possible? is that the right choice here? Ideally I'd like to just use the one list ([1..100]) and create names with show, and ages with (16+)
02:15:37 <julianleviston> hopefully my question doesn’t have too much ridiulous insanity in it
02:15:41 <quchen2> merijn: Do you create the token parsers yourself? You could just have "mkTok element = do { (x,loc) <- parse element; ws; pure (x,loc) } that way
02:15:42 <merijn> julianleviston: Are you ok with requiring both lists to be the same length?
02:16:03 <julianleviston> merijn: sure.
02:16:17 <merijn> quchen2: No, I'm using the "TokenParsing" class and overriding the token parser doesn't play nicely with newtypes like Unspaced/Unlined, etc.
02:16:32 <merijn> @define data Book = Book { name :: String, age :: Int }
02:16:33 <quicksilver> zip Book ["Food","Drink"] [5,20]
02:16:33 <lambdabot>  Defined.
02:16:38 <quicksilver> ^^ julianleviston 
02:16:38 <merijn> :t zipWith Book
02:16:40 <lambdabot> [String] -> [Int] -> [Book]
02:16:46 <merijn> quicksilver: type error :p
02:16:54 <quicksilver> (a) I got it wrong and (b) merijn was going to demo it
02:16:58 * quicksilver quiets
02:16:59 <julianleviston> I thought zip created tuples?
02:17:03 <merijn> :t zipWith
02:17:03 <quicksilver> zipWith
02:17:03 <julianleviston> oh haha.
02:17:03 <julianleviston> ok
02:17:04 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
02:17:04 <julianleviston> soz
02:17:05 <quicksilver> like merijn said :)
02:17:07 <julianleviston> ah!
02:17:09 <julianleviston> brilliant :)
02:17:16 <quchen2> merijn: How about including start location and parsed text? That would allow you to get the end location by analyzing the text. As a bonus, you could fully reconstruct the parsed data.
02:17:19 <merijn> "zip = zipWith (,)" :)
02:17:26 <julianleviston> cool
02:17:49 <merijn> quchen2: I am including parsed text and start location, but it's determining the end location efficiently that's bothering me
02:17:49 <quicksilver> > zipWith Book ["Food","Drink"] [5,20]
02:17:51 <lambdabot>      No instance for (Show Book)
02:17:51 <lambdabot>        arising from a use of ‘show_M298416228705871298532691’
02:17:51 <lambdabot>      In the expression:
02:17:54 <quicksilver> :(
02:17:54 <julianleviston> maybe it should be zipTup = zip (,) instead. lol… ie zip is wrongly named.
02:18:00 <merijn> @undefine
02:18:00 <lambdabot> Undefined.
02:18:01 <quicksilver> :t zipWith Book ["Food","Drink"] [5,20]
02:18:02 <lambdabot> Not in scope: data constructor ‘Book’
02:18:07 <merijn> @define data Book = Book { name :: String, age :: Int } deriving (Show)
02:18:08 <julianleviston> lol
02:18:08 <lambdabot>  Defined.
02:18:25 <merijn> > zipWith Book ["foo", "bar"] [1,2]
02:18:26 <quicksilver> merijn: :t can't see @defines?
02:18:27 <lambdabot>  [Book {name = "foo", age = 1},Book {name = "bar", age = 2}]
02:18:39 <julianleviston> ahh I should have been able to work that one out myself.
02:18:40 <merijn> quicksilver: I quickly @undefined to add "deriving Show" :)
02:18:45 <julianleviston> thanks peoples.
02:18:50 <merijn> quicksilver: You had unlucky timing :p
02:19:11 <Darkproger> guys is there some elegant way of having comprehensible errors on pattern match failures? e.g. if i match for `Right _ <- meh` and meh evals to Left, i'd like to at least see what the left was without writing boring wrappers
02:19:30 <julianleviston> Darkproger: you could use Either
02:19:36 <julianleviston> Darkproger: I think...
02:19:48 <erikd> Darkproger: not the Either type, the either function
02:19:51 <erikd> :t either
02:19:52 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
02:19:57 <julianleviston> Erebe: oops :) 
02:20:03 <julianleviston> erikd: oops :) :)
02:20:06 <julianleviston> erikd: thanks.
02:20:15 <quicksilver> foo <- either (throwError "it was a left!!!") (return) meh
02:20:22 <quicksilver> Darkproger: ^^ something like that?
02:20:28 <Darkproger> yeah
02:20:29 <quicksilver> for an appropriate defn of either
02:20:32 <quicksilver> I mean
02:20:37 <quicksilver> an appropriate defn of throwError
02:20:40 <Darkproger> however i don't want to write the `either (throwError "it was a left!!!") (return)` bit
02:20:58 <julianleviston> ok so my question re: book… *could* I use Applicative?
02:21:00 <Darkproger> because ghc already generates some code that triggers an pattern match failure exception
02:22:01 <merijn> julianleviston: ZipWith newtype of list
02:22:14 <merijn> Eh, ZipList
02:22:32 <merijn> > (,) <$> [1..5] <*> [6..10]
02:22:34 <lambdabot>  [(1,6),(1,7),(1,8),(1,9),(1,10),(2,6),(2,7),(2,8),(2,9),(2,10),(3,6),(3,7),(...
02:22:42 <merijn> > (,) <$> ZipList [1..5] <*> ZipList [6..10]
02:22:44 <lambdabot>  ZipList {getZipList = [(1,6),(2,7),(3,8),(4,9),(5,10)]}
02:22:51 <merijn> > getZipList $ (,) <$> ZipList [1..5] <*> ZipList [6..10]
02:22:53 <lambdabot>  [(1,6),(2,7),(3,8),(4,9),(5,10)]
02:23:08 <julianleviston> merijn: I need to revise applicative again, obviously…because I seem to remeber something where I could take a single list, then pipe each item through two functions, then into a constructor… or is that my imagination
02:23:25 <julianleviston> merijn: maybe that was just ((->) r) as a Functor?
02:23:28 <merijn> julianleviston: The problem is that list has two lawful Applicative instances
02:23:57 <merijn> julianleviston: But only one is a valid monad, therefore the default Applicative of list is the one corresponding to the Monad instance (i.e. cartesian product)
02:24:07 <julianleviston> merijn: ah ok
02:24:24 <julianleviston> merijn: but it doesn’t have to feed from two lists. Just one is fine.
02:24:28 <merijn> The ZipList newtype lets you use the alternative applicative for list (which is basically "zip-like" treating everything as pairs)
02:24:46 <bitonic> I'm getting this lovely error: `/usr/bin/ld: error: .stack-work/dist/x86_64-linux/Cabal-1.18.1.5/build/Foundation.dyn_o: requires dynamic R_X86_64_PC32 reloc against '_hpc_tickboxes_simulatezmserverzm0zi1zi0zi0_Settings_hpc' which may overflow at runtime; recompile with -fPIC`.  I'm interpreting it as "I'm trying to link a static library (HPC) into a dynamic
02:24:47 <bitonic> library (what I'm building now), build HPC with -fPIC".  is my interpretation correct, and how can I actually re-build HPC?
02:24:47 <merijn> > getZipList $ (,,) <$> ZipList [1..5] <*> ZipList [6..10] <*> ZipList [11..15]
02:24:50 <lyxia> Darkproger: The monad transformer EitherT wraps "m (Either a b)" in a single monad, and you can just pattern match on the error at the end.
02:24:50 <lambdabot>  [(1,6,11),(2,7,12),(3,8,13),(4,9,14),(5,10,15)]
02:25:02 <merijn> Unlike "zipWith" ZipList generalises to any number of arguments
02:25:26 <bollu2> @let zipListParallel as bs = [(a, b) | a <- as | b <- bs]
02:25:27 <lambdabot>  Defined.
02:25:41 <bollu2> > zipListParallel [1..5] [2..10]
02:25:42 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6)]
02:25:53 <bollu2> merijn: that works too, right?
02:26:04 <bollu2> using the parallel list comprehension?
02:26:13 <Darkproger> lyxia: but what if it's beyond Either? say, i match random constructors throughout my code and as long as their types have Show, ghc-produced code can have nice errors out of the box
02:26:36 <bitonic> oh, it's https://ghc.haskell.org/trac/ghc/ticket/9762 .
02:26:38 <quicksilver> Darkproger: you can define your own implementation of 'fail'
02:26:44 <quicksilver> Darkproger: (in the Monad class)
02:26:50 <quicksilver> to control what happens to the pattern match exceptions.
02:27:00 <quicksilver> I'm not sure if that's what you were asking but maybe it is
02:27:49 <jle`> @let zap = zipWith ($)
02:27:51 <lambdabot>  Defined.
02:27:56 <bollu> :t zap
02:27:58 <lambdabot> [a -> c] -> [a] -> [c]
02:28:03 <bollu> whoa
02:28:18 <bollu> oh, right
02:28:21 <bollu> I see
02:28:52 <jle`> er
02:28:54 <julianleviston> jle`: but I want to use Applicative. I *can*, right?
02:29:03 <julianleviston> jle`: am I talking nonsense here? :)
02:29:04 <bollu> jle`: any way to generalize zap to n arguments?
02:29:10 <Darkproger> quicksilver: let me see what i can do with it..
02:29:11 <jle`> zap is just ap
02:29:25 <bollu> :t ap
02:29:29 <lambdabot> Monad m => m (a -> b) -> m a -> m b
02:29:35 <julianleviston> :t (<$>)
02:29:38 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:29:43 <quicksilver> zap is not ap in the List monad
02:29:45 <bollu> :t (<*>)
02:29:47 <quicksilver> it's ap in the ZipList monad
02:29:49 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
02:30:02 <bollu> oh, right, because the list monad does the cross product
02:30:02 <jle`> > (((,,) <$> [1..5]) `zap` [6..10]) `zap` [11..15]
02:30:03 <julianleviston> mmm
02:30:04 <lambdabot>  [(1,6,11),(2,7,12),(3,8,13),(4,9,14),(5,10,15)]
02:30:05 <bollu> flatMap*
02:30:10 <bollu> nice
02:30:32 <julianleviston> ahhh ok cool
02:30:33 <bollu> @let (<||>) = zap
02:30:34 <Darkproger> :t fail
02:30:34 <jle`> > ((((,,,) <$> [1..5]) `zap` [6..10]) `zap` [11..15]) `zap` [16..20]
02:30:38 <lambdabot>  Defined.
02:30:38 <lambdabot>  mueval-core: Time limit exceeded
02:30:38 <lambdabot> Monad m => String -> m a
02:30:42 <jle`> i forgot to define fixity so i have to deal with parentheses v.v
02:31:23 <jle`> > (,,,) <$> [1..5] `zap'` [6..10] `zap'` [11..15] `zap'` [16..20]
02:31:24 <bollu> > (,,) <$> [1..5] <||> [6..10] <||> [7..15]
02:31:25 <lambdabot>      Could not deduce (Enum a0)
02:31:26 <lambdabot>      from the context (Enum a2,
02:31:26 <lambdabot>                        Enum a3,
02:31:27 <lambdabot>  [(1,6,11,16),(2,7,12,17),(3,8,13,18),(4,9,14,19),(5,10,15,20)]
02:31:36 <jle`> you forgot to define fixity too it seems
02:31:40 <bollu> oh xD
02:31:59 <bollu> hm, I assumed that operators always get some sane 
02:32:08 <jle`> @let infixl 4 (<|*|>); (<|*|>) = zipWith ($)
02:32:08 <lambdabot>  Parse failed: Parse error: (
02:32:18 <jle`> @let infixl 4 <|*|>; (<|*|>) = zipWith ($)
02:32:20 <lambdabot>  Defined.
02:32:26 <jle`> bollu: they're sane, but it doesn't work with <$> necessarily
02:32:36 <bollu> jle`: yeah, gotcha. 
02:32:51 <jle`> it looks like in your example, <||> bound tighter than <$>, so it's like (,,) <$> ([1..5] <||> [6..10])
02:32:54 <Darkproger> quicksilver: the thing is `fail` just accepts some string and fails and i'd like to control what that string contains on a pattern match failure; consider ` data T = A | B deriving Show; action = { A <- return B; return () }` — i want it to bring smth like "error: pattern match failure, expression returned B"
02:33:09 <julianleviston> jle`: so… <$> is Functor version of ap?
02:33:11 <bollu> jle`: that's the inelegant thing about applicative IMO
02:33:26 <bollu> julianleviston: (<$>) is the same as fmap
02:33:28 <bollu> :t fmap
02:33:29 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:33:32 <bollu> :t (<$>)
02:33:33 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:33:37 <julianleviston> :t ap
02:33:38 <lambdabot> Monad m => m (a -> b) -> m a -> m b
02:33:39 <bollu> it's just an operator version of fmal
02:33:42 <bollu> fmap*
02:33:45 <julianleviston> :t zipWith ($)
02:33:46 <lambdabot> [a -> c] -> [a] -> [c]
02:34:01 <julianleviston> jle`: zipWith ($) == ap for lists?
02:34:03 <jle`> > (,,) <$> <|*|> [1..5] <|*|> [6..10] <|*|> [11..15]
02:34:04 <lambdabot>  <hint>:1:10: parse error on input ‘<|*|>’
02:34:16 <bollu> julianleviston: no, even though the types are the same, what they do is different
02:34:20 <quicksilver> Darkproger: I don't think the GHC implementation of pattern match makes that information available I'm afraid.
02:34:20 <bollu> julianleviston: okay, maybe this will help
02:34:32 <jle`> > (,,) <$> [1..5] <|*|> [6..10] <|*|> [11..15]
02:34:34 <lambdabot>  [(1,6,11),(2,7,12),(3,8,13),(4,9,14),(5,10,15)]
02:34:36 <quicksilver> Darkproger: I thought it might be visible in the error string but it isn't.
02:34:37 <bollu> > [(a, b) | a <- [1..2], b <- [1..2]]
02:34:39 <julianleviston> bollu: but isn’t that the same thing where the monad is List?
02:34:39 <lambdabot>  [(1,1),(1,2),(2,1),(2,2)]
02:34:46 <jle`> julianleviston: it's an alternative "ap" for lists, different than the default <*>
02:34:54 <bollu> > [(a, b) | a <- [1..2] | b <- [1..2]]
02:34:56 <lambdabot>  [(1,1),(2,2)]
02:34:57 <julianleviston> jle`: ohhh that’s what someone was just saying to me. right.
02:35:03 <bollu> julianleviston: notice the two different results
02:35:08 <bollu> the former gave you ALL combinations
02:35:09 <julianleviston> jle`: it’s the non-catesian product version.
02:35:15 <bollu> the later gave you combinations "in parallel"
02:35:18 <jle`> but, you can't define a (>>=) such that zipWith ($) = ap
02:35:22 <bollu> the former is the monad version 
02:35:27 <quicksilver> Darkproger: you just get "Pattern match failure in do expression at..."
02:35:29 <bollu> the latter is the "zippy" version
02:35:35 <Darkproger> quicksilver: yeah
02:35:53 <jle`> there is no possible >>= such that zipWith ($) = fs >>= \f -> xs >>= \x -> return (f x)
02:35:54 <quicksilver> Darkproger: I'm afraid you'll have to compose your own error handling stuff.
02:35:54 <julianleviston> bollu: cool :) this tastes like “Julian needs to learn more” pretty familiar with this feeling :) thanks
02:35:56 <julianleviston> jle`: thanks
02:36:10 <jle`> that also follows the monad laws
02:36:16 <quicksilver> jle`: there is a working >>= if you restrict to infinite lists
02:36:31 <jle`> yeah, but that's a different data type
02:36:39 <quicksilver> it's not really different in haskell :)
02:36:43 <jle`> there's a working >>= if you restrict it to lists of size 1 too
02:36:51 <quicksilver> or any fixed size indeeed
02:36:58 <bollu> julianleviston: :) well, if you look at the two examples I gave, one said a <- [1..2], b <- [1..2[ (so that means that ALL combinations). The other said a <- [1..2] | b <- [1..2] (notice the |, it was , before between a and b). This says "take combinations in PARALLEL"
02:36:59 <jle`> yeah, not very meaningful :P
02:37:16 <bollu> quicksilver: for which? zippy ones?
02:37:29 <quicksilver> bollu: yes
02:37:43 <jle`> julianleviston: one thing that might be worth thinking about is...what is `pure` such that pure f <|*|> xs = f <$> xs ?
02:37:52 <bollu> oh, oh, does anyone know how to encode diagonalization for "n" dimensional infinite lists?
02:38:17 <bollu> for stream you can diagonalize
02:38:27 <bollu> but, like, I got intimidated trying to write it for [[[]]]
02:38:28 <jle`> it's the same thing for fixed length vectors too
02:39:04 <jle`> oh you mean that dimension
02:39:14 <bollu> jle`: yeah
02:39:37 <bollu> jle`: in the question you gave, isn't pure = zap?
02:39:49 <jle`> not quite
02:39:57 <bollu> oh, wait, you want me to lift it to ap
02:39:59 <bollu> lemme try
02:40:12 <bollu> :t (<|*|>)
02:40:13 <lambdabot> [a -> c] -> [a] -> [c]
02:40:24 <jle`> bollu: i feel like you can just double diagonalize.  that's just the monoidal aspect of monads
02:40:27 <bollu> pure f = repeat f?
02:40:37 <jle`> it's not called repeat in haskell, but close :)
02:40:41 <jle`> oh wait it is
02:40:54 <jle`> yeah, that's it heh
02:41:14 <bollu> cool :)
02:41:22 <bollu> I never got the appeal of pointfree
02:41:29 <bollu> like, "pure = repeat"
02:41:31 <bollu> why?
02:41:37 <jle`> bollu: it's like a definition
02:41:39 <jle`> pure *is* repeat
02:41:41 <jle`> they're one in the same
02:41:43 <bollu> I get the "you are stating equivalence of functions" and all
02:41:44 <jle`> like synonyms
02:41:45 <bollu> but.. 
02:41:47 <merijn> bollu: Don't have to invent names :p
02:41:51 <bollu> merijn: xD
02:41:53 <merijn> Inventing names is hard
02:42:00 <merijn> That's like 80% of the reason I write pointfree
02:42:09 <bollu> merijn: which is how you end up with Clowns and Jokers? ;)
02:42:13 <jle`> conceptually it's just, "what's pure?  oh, it's just repeat."
02:42:26 <jle`> symbolically, that's pure = repeat
02:42:35 <merijn> bollu: Man, that paper is impossible to read
02:42:53 <jle`> it's a little awkwarder to say "what's pure x?  oh, it's repeat x."  Or, "what's pure?  It's \x -> repeat x"
02:43:01 <bollu> merijn: ik. I wish I could read more hakell papers. 
02:43:16 <bollu> jle`: is there a name for the reduction? f a = g a => f = g?
02:43:16 <merijn> bollu: Most are pretty easy, Conor is just on another plane of existence
02:43:24 <merijn> bollu: eta reduction
02:43:32 <quicksilver> funny you'd say that
02:43:39 <bollu> merijn: isn't eta reduction \x -> f x => f?
02:43:44 <bollu> this isn't quite the same, right?
02:43:46 <merijn> bollu: Same thing
02:43:51 <bollu> really?
02:43:53 <jle`> bollu: have you ever said, "bind for the list monad is (flip) concatMap"
02:43:56 <bollu> I don't see the equivalence
02:43:56 <quicksilver> I think Conor is excellent at writing readable papers, I find his more approachable to the layman than most CS papers
02:43:59 <bollu> oh, wait, I do
02:44:02 <merijn> "f a = g a" is just sugar for "f = \a -> g a" conceptually
02:44:03 <jle`> or have you ever said, "fmap for lists is map"
02:44:15 <quicksilver> compare Conor's applicative paper to Moggi's monad paper...
02:44:20 <bollu> jle`: the latter, yes. Not the former
02:44:21 <jle`> or maybe you have said, "(<>) for lists is concatenation."
02:44:26 <julianleviston> merijn: who’s conor? conal?
02:44:36 <merijn> quicksilver: I've seen his papers "before" editors and "after" and he can write well, but editors trim his papers to unreadability
02:44:41 <merijn> julianleviston: Conor McBride
02:44:41 <bollu> jle`: um, the (<>) specifically when talking about monoid structure
02:44:45 <bollu> jle`: why is that bad?
02:44:47 <julianleviston> merijn: ok
02:44:57 <merijn> julianleviston: Not sure I got the number of n's right :p
02:45:01 <jle`> bollu: if i asked you to tell me what <> was for [a], you'd say that it concatenates the lists, right?
02:45:06 <jle`> symbolically, that's (<>) = (++)
02:45:08 <julianleviston> merijn: haha you did
02:45:10 <bollu> jle`: yes
02:45:14 <jle`> you wouldn't say "x <> y for lists is x ++ y"
02:45:21 <bollu> jle`: I'd argue (++) = (<>) :)
02:45:28 <bollu> jle`: right
02:45:36 <jle`> so, that's the appeal
02:46:04 <bollu> jle`: yes. for like 5% of cases, equivalence like that is nice. But when people do weird stuff like f = ((.) g) . h
02:46:05 <jle`> it maps more naturally to how you think of things/your thought in a lot of situations
02:46:10 <bollu> I just think "why" ?
02:46:15 <jle`> yeah, there's no reason to do that
02:46:56 <jle`> point-free is not an end in and of itself.  the point is cleaner code, which might come from being point free, or might come from not
02:46:57 <bollu> what are the other reduction rules? I know call by name is one
02:47:00 <liste> there's pointfree, and then there's bad code
02:47:19 <jle`> you shouldn't avoid point free just for the sake of avoiding point free, after all
02:47:28 <bollu> jle`: agreed
02:47:40 <bollu> jle`: also, usually you;re doing f . g . h $ x
02:47:45 <jle`> there are situations where it leads to cleaner code closer to the programmer's intent, and situations where it's not
02:47:51 <bollu> which imo is much nicer as x |> h |> g |> f
02:48:04 <bollu> but then again, I'm the crazy (|>) advocate :)
02:48:11 <jle`> maybe, but in f . g . h $ x, you can assign meanings to f . g, and g . h, and f . g . h
02:48:18 <jle`> let fg = f . g in fg . h $ x
02:48:23 <bollu> jle`: yes, I've heard that argument before
02:48:36 <bollu> jle`: but the nice part about haskell *is* that you don't need to split them
02:48:50 <bollu> jle`: and most of the time, splitting it out would be silly
02:49:04 <bollu> jle`: so why not just show control flow "naturally" ?
02:49:09 <bollu> well, data-flow
02:49:24 <jle`> "natural" is a bit of a useless term here, because either way can be argued as more natural :)
02:49:32 <bollu> jle`: hence the quotes :)
02:49:33 <f-a> does adding stack.yaml to extra-source-files: make any sense?
02:49:57 <jle`> but it's not always about pulling things out, it's about how you conceptualize it in your head.  seeing (.) as associative gives you insight into how things work and shapes your thought
02:50:10 <bollu> it feels so weird to show other people Applicative when I didn't understand what Applicative was last year ish
02:50:11 <jle`> you can visualize refactorings
02:50:24 <bollu> jle`: I suppose
02:51:08 <jle`> seeing the associativity and the joining of parts right there in front of your eyes...patterns just seem to pop out easier
02:51:25 <jle`> you might not ever notice simple things like print = putStrLn . show
02:51:33 <jle`> if you're doing x |> show |> print
02:51:50 <bollu> jle`: also, in group theory, a lot of people do this weird things like defining phi as  phi(f)(x) = … . I wish more pure math people used lambda calc to at least simplify notation for higher order functions. (phi(f) = \x -> ….)
02:51:51 <jle`> er, x |> show |> putStrLn
02:52:01 <jle`> but if you did (putStrLn . show) x, then, you can just say
02:52:05 <bollu> jle`: hm, yes, that I "fair" I guess"
02:52:09 <jle`> "oh, i know that putStrLn . show *is literally* just print"
02:52:17 <jle`> so it's literally just print x
02:53:26 <jle`> connections like this...when you start seeing functions as *things* you can manipulate, combine, merge
02:53:34 <jle`> instead of just things whose only purpose is to be applied
02:53:41 <julianleviston> jle`: isn’t that just called understanding?
02:53:57 <bollu> julianleviston: we're arguing about how syntax aids understanding
02:54:09 <bollu> and I gotta agree with jle` on this one
02:54:13 <bollu> yeah, you're right
02:54:16 <jle`> england lagged behind europe in calculus for ages because it couldn't drop the x-dot notation for derivatives
02:54:20 <julianleviston> bollu: it can, I spose.
02:54:27 <jle`> because they loved Newton so much
02:54:44 <bollu> jle`: what's your preferred notation? Euler v/s Leinbniz?
02:54:51 <jle`> it depends on the situation
02:54:57 <bollu> Leibniz*
02:55:26 <jle`> each is good in its own situation, picking one always over the other is where you close doors :o
02:55:32 <bollu> jle`: I've very rarely used dot notation, except in physics
02:55:35 <bollu> jle`: xD
02:55:50 <bollu> jle`: like, I thanked god for dot-notation when doing calculus of variations
02:56:42 <jle`> anyways, have to head to bed. have a good one :)
02:56:55 <bollu> night :)
02:57:42 * hackagebot lentil 0.1.6.1 - frugal issue tracker  https://hackage.haskell.org/package/lentil-0.1.6.1 (fffaaa)
03:27:43 * hackagebot haddocset 0.4.1 - Generate docset of Dash by Haddock haskell documentation tool  https://hackage.haskell.org/package/haddocset-0.4.1 (HirotomoMoriwaki)
03:29:43 <estike> i recently download the ghc and emacs for editing and where i can save the files for the prompt to load the same ?
03:32:59 <estike> anyone can help me ?
03:34:59 <srhb> estike: It's not quite clear what you're asking. You can save your files anywhere and load them with emacs.
03:35:22 <srhb> estike: You can also compile your source files with ghc from anywhere, or load them with ghci from anywhere.
03:36:34 <srhb> estike: It might help if you give us a complete scenario of what you want to do and what kind of system you're on.
03:36:40 <estike> i save a newfile.hs and when i did :l newfile.hs in prompt we didnt find him
03:36:55 <srhb> estike: Then you probably saved newfile.hs in some other location.
03:37:25 <srhb> estike: If you launch ghci from the same location as you saved the file, that will work.
03:37:46 <estike> ok i will try 
03:37:50 <srhb> Otherwise you can use :l /full/path/to/newfile.hs
03:37:52 <srhb> Whatever that path is.
03:41:50 <estike> it work thanks ;)
03:46:45 <akegalj> hey. I am not familiar with Scala, but friend of mine showed me an example of streaming example in Scala which was something like: "(1 to 1000000).iterator map (+1) foldl1 (+)". The type of this was  "SomeStreamingType Int" so they could in fact lift implementation of map into this StreamingType to do a computation in streaming fashion. 
03:47:31 <akegalj> in contradiction, foldl and conduit packages implement their own map, fold, and other functions to achive this
03:47:53 <liste> lists stream also
03:48:04 <quicksilver> they do do that akegalj, but it's not because plain haskell lists can't stream
03:48:08 <quicksilver> plain haskell lists can stream fine
03:48:17 <liste> > map (+1) [1..]
03:48:18 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
03:48:29 <quicksilver> but they can't stream in a generic way interleaved with IO operations and correct error handling
03:48:37 <quicksilver> which is the problem that conduits/pipes solve
03:49:06 <akegalj> aha
03:49:20 <akegalj> so thats why they implement their own map, fold... ?
03:49:31 <bollu> Monoid m => Applicative(Const m) . However, since a monoid is equivalent to a one-object category, is there a similar construction for Endo ?
03:49:40 <bollu> :t Endo
03:49:41 <lambdabot> (a -> a) -> Endo a
03:50:01 <quicksilver> not sure what you mean
03:50:04 <chpatrick> similar in what sense?
03:50:14 <quicksilver> do you mean is there an instance Applicative (Const (Endo a)) ?
03:50:17 <quicksilver> the answer is yes
03:50:24 <quicksilver> it's the instance you jsut gave, since Endo a is a monoid :)
03:51:00 <bollu> yes
03:51:02 <akegalj> quicksilver: could conduit L.map be implemented as lifting Prelude.map into Monad m => Conduit m ?
03:51:03 <bollu> ohh
03:51:05 <bollu> oh!
03:51:29 <bollu> okay, so, identity  is just id? and (<>) = (.) ?
03:51:31 <bollu> nice!
03:51:39 <quicksilver> akegalj: no, because it has support for interleaving other effects
03:51:50 <quicksilver> akegalj: such as explicitly demanding IO and recovering from errors
03:52:02 <quicksilver> I'm not a conduit expert so I can't give a more detailed answer.
03:52:17 <quicksilver> bollu: correct.
03:52:53 <quicksilver> > ((Endo (+1)) <> (Endo (*2))) `appEndo` 5
03:52:55 <lambdabot>  11
03:53:06 <akegalj> quicksilver: ok, I get it. thnx
03:53:06 <quicksilver> it's one of the best Monoid instances
03:53:12 <quicksilver> because it lets you pretend to be Harry Potter
03:53:15 <quicksilver> "appEndo!!"
03:53:18 <bollu> xD
03:53:28 <bollu> appEndo :: Endo a -> a -> a?
03:53:32 <bollu> :t appEnd
03:53:33 <quicksilver> yes
03:53:34 <lambdabot>     Not in scope: ‘appEnd’
03:53:34 <lambdabot>     Perhaps you meant one of these:
03:53:34 <lambdabot>       ‘appEndo’ (imported from Data.Monoid),
03:53:35 <quicksilver> it unwraps it
03:53:36 <bollu> :t appEnd
03:53:38 <lambdabot>     Not in scope: ‘appEnd’
03:53:38 <lambdabot>     Perhaps you meant one of these:
03:53:38 <lambdabot>       ‘appEndo’ (imported from Data.Monoid),
03:53:40 <bollu> :t appEndo
03:53:41 <bollu> lol
03:53:41 <lambdabot> Endo a -> a -> a
03:53:44 <bollu> cool :)
03:53:49 <bollu> ty for the explanation quicksilver
03:53:51 <liste> @src Endo
03:53:51 <lambdabot> Source not found. Do you think like you type?
03:53:56 <quicksilver> newtype Endo a = Endo { appEndo :: a -> a }
03:54:09 <liste> thanks quicksilver (:
03:54:09 <quicksilver> using haskell's quirky record notation to define the unwrapper :)
03:54:49 <quicksilver> bollu: in fact there is an 'Endo' Monoid for any Category
03:54:53 <quicksilver> this is just the one for (->)
03:56:32 <estike> someone can give a example of a function that does Bool -> Intenger
03:57:13 <bollu> @let f x = if x == True then 1 else 0
03:57:14 <frerich> estike: '\x -> if x then 0 else 1 :: Integer'
03:57:15 <lambdabot>  Defined.
03:57:19 <bollu> > f True
03:57:21 <lambdabot>      Ambiguous occurrence ‘f’
03:57:21 <lambdabot>      It could refer to either ‘L.f’,
03:57:21 <lambdabot>                               defined at /tmp/mueval982906996135497281.hs:159:1
03:58:11 <bollu> frerich: I like how we defined complementary functions :P
03:58:23 <srhb> bollu: f is already taken my simple-reflect
03:58:25 <srhb> by*
04:03:35 <bollu> " Lens was criticized a lot for not doing this (this = using newtypes) until people started to realize the mileage Ed was getting out of abusing Haskell's subtyping relation"
04:03:38 <bollu> what does that sentence mean?
04:04:05 <quicksilver> bollu: the fact you can compose lenses and traversals together
04:04:23 <quicksilver> and because of the clever way the type system works that 'automatically' gives you another traversal
04:04:24 <liste> and prisms and getters and setters and...
04:04:29 <quicksilver> ...and it works for all the different kinds of things
04:04:40 <quicksilver> ...and the type system complains if you try to compose non-composable things
04:04:48 <bollu> oh, but.. Haskell doesn't _have_ subtyping
04:04:49 <quicksilver> and it all works using the same standard (.) as prelud.
04:04:53 <bollu> so what are they talking about?
04:05:07 <quicksilver> unification subtyping
04:05:17 <bollu> in the sense of constraints?
04:05:18 <quicksilver> like [Int] is a subtype of [a]
04:05:27 <quicksilver> or Int -> Char is a subtype of a -> b
04:05:29 <bollu> oh, that's.. cool?
04:05:33 <bollu> abusive? 
04:05:34 <bollu> idk
04:05:45 <bollu> a -> b <: a -> a <: Int -> Int ?
04:05:46 <quicksilver> haskell will let you pass a function of type 'Int -> Char' to a function which expects "a -> b"
04:05:55 <quicksilver> this is how polymorphism works
04:05:59 <bollu> hmm
04:06:10 <quicksilver> > map (Data.Char.chr) [65,66,67]
04:06:11 <lambdabot>  "ABC"
04:06:19 <quicksilver> map's first parameter is (a -> b)
04:06:23 <quicksilver> but there I used Int -> Char
04:06:31 <quicksilver> the only thing Lens does is like that - just more of it
04:06:38 <bollu> I see
04:06:51 <bollu> well, I don't "see", but I think I get the principle
04:06:55 <quicksilver> :)
04:07:01 <quicksilver> the way it actually works out is mindblowing
04:07:11 <bollu> most of haskell is :)
04:07:11 <quicksilver> and most cases of it I don't understand.
04:07:13 <quicksilver> lots to learn :)
04:08:55 <bollu> how do I list the kind of templates I have? for stack?
04:09:33 <bollu> got it - "stack templates"
04:11:14 <Tekkkz> Hi. When i have a function "handler String :: [Something]" and i give a string with lines to it and treat it with "handler = map SomeFunc . lines" how can this function parse every  single line to the SomeFunc?
04:14:09 <crocket> Can anyone give us a fair comparison of clojure and haskell.
04:14:11 <crocket> Can anyone give us a fair comparison of clojure and haskell?
04:14:27 <srhb> crocket: There was a thread on reddit with both sides recently. I'd go dig it up if I were you.
04:14:27 <arahael> crocket: Sure.
04:15:24 <arahael> Hmm, very easy to find, too. Just google "clojure haskell".  No need to even mention "vs".
04:15:26 <srhb> Tekkkz: I am not sure what you're asking. You wrote .. function "handler String :: [Something]" -- do you mean handler :: String -> [Something]? 
04:15:27 <bollu> crocket: do you want a (biased) opinion from me?
04:16:08 <arahael> clojure is java, I understand.
04:16:14 <arahael> Haskell is pure - written in haskell, for haskell.
04:16:22 <crocket> srhb, Which reddit?
04:16:25 <srhb> Tekkkz: Because in that case, assuming SomeFunc :: String -> Something, you're done.
04:16:36 <srhb> crocket: clojure and haskell respectively, I think.
04:16:51 <arahael> crocket: https://www.reddit.com/r/haskell/comments/2mr7ks/im_debating_between_haskell_and_clojure_xpost/
04:17:18 <tdammers> IMO the two are quite radically different, fwiw
04:18:09 <julianleviston> crocket: as always, it depends on what you’re using it for.
04:18:15 <tdammers> in fact, I'd be hard pressed to find something they have in common :x
04:18:26 <arahael> tdammers: They're both turing complete!
04:18:30 <julianleviston> tdammers: functional programming? :)
04:18:41 <srhb> Meh, clojure is _barely_ functional. :-)
04:18:51 <tdammers> I wouldn't call clojure a functional programming language
04:19:06 <Rembane> Imperative lisp?
04:19:27 <Tekkkz> srhb yes. But how can it give the called string as parameter without saying "handler str = func str" ?
04:19:28 <julianleviston> tdammers: by that judgement, nothing but ML and Haskell are tho… right?
04:19:34 <tdammers> the thing is, clojure doesn't even *have* functions
04:19:34 <crocket> Clojure has been ok for me.
04:19:37 <srhb> Tekkkz: It's called an eta reduction.
04:19:44 <tdammers> scheme at least has the intellectual honesty of calling them "procedures"
04:19:52 <julianleviston> hehe
04:19:53 <srhb> Tekkkz: Everytime you have foo x = bar x -- you can reduce it to foo = bar
04:19:54 <julianleviston> fair enough.
04:19:57 <obadz> Clojure is absolutely functional, just dynamically typed.
04:20:14 <srhb> Tekkkz: since bar is a function that takes that one argument, foo is a function that takes that one argument.
04:20:14 <crocket> Ok, clojure functions are not mathematical functions
04:20:17 <tdammers> of course functional programming techniques can be used in clojure, and the language goes through great lengths to support them
04:20:28 <Tekkkz> srhb. Okay, i have school now. Ill have a look at it later. Thx
04:20:34 <tdammers> but clojure functions aren't functions, they're procedures.
04:20:35 <srhb> Tekkkz: Have fun.
04:20:46 <tdammers> there is nothing in the language to control side effects, really
04:20:46 <obadz> tdammers: s/functional/imperative/ s/clojure/haskell/ -> still true.
04:21:01 <bollu> tdammers: eh, true. But most people write "pure" functions
04:21:07 <julianleviston> tdammers: you might have to define your terms: what is a function? :)
04:21:08 <srhb> Haskell functions are always functions. Clojure functions are not necessarily functions.
04:21:11 <bollu> tdammers: well, immutable structures helps with that
04:21:11 <hyPiRion> So uh, what about unsafePerformIO?
04:21:15 <srhb> julianleviston: As in math.
04:21:29 <julianleviston> srhb: a mapping between sets?
04:21:36 <arahael> hyPiRion: I think we pretend that doesn't exist. :)
04:21:45 <julianleviston> I think we have to agree then.
04:21:46 <crocket> Is transducer popular in haskell?
04:21:52 <obadz> so is are MLs not classified as functional languages because they have effectful functions?
04:21:54 <tdammers> bollu: yes, but the strange thing is that while there is a lot of attention to mutability, other side effects are completely hand-waived and left to an honor system
04:22:05 <bollu> crocket: no, we have our own streaming libraries (pipes)
04:22:11 <crocket> transducer reduces laziness.
04:22:31 <bollu> tdammers: ah, yes, that's fair
04:22:50 <julianleviston> bollu:  transducers isn’t streaming… it’s more like function composition, I think… isn’t it?
04:22:56 <arahael> Are transducers a clojure thing?
04:22:57 <obadz> tdammers: that's true in just about every other language
04:23:07 <arahael> I'm trying to find a *generic* description of tranducers.
04:23:08 <julianleviston> arahael: well, they’re a thing… and clojure has them
04:23:22 <tdammers> bollu: it's what I call the "100% problem": purity is one of those things where going from 99.9999999% to 100% makes a huge difference in terms of usefulness
04:23:26 <bollu> arahael: type Transducer a b = forall r . (b -> r -> r) -> (a -> r -> r)
04:23:27 <srhb> obadz: Well, there are few functional languages that are as functional as Haskell, so it's not strange that we can say these things about _a lot_ of languages.
04:23:38 <bollu> funny, I was just trying to write fmap, filter etc for transducers right now
04:23:43 <tdammers> having a language that is "mostly pure" isn't anywhere near as powerful as a language that is "pure"
04:24:08 <wedens> what can I use to stream data from CSV file to postgresql table?
04:24:09 <bollu> tdammers: IIRC, the rust people gave up on purity - they tried having partial purity, and said the burden on the type system was too much
04:24:27 <bollu> arahael: that's the most generic description of a Transducer I could find
04:24:35 <tdammers> idk about Rust, but I believe D has much of it covered
04:24:36 <bollu> arahael: you can also supposedly view it as a lens or something
04:24:47 <arahael> bollu: Doesn't mean much to me yet.  (I'm actually a bit of a novice in haskell, too)
04:24:51 <bollu> arahael: kemett has a comment on a reddit thread that I (as usual( didn't understand :)
04:24:54 <arahael> Though trying ot learn and use it more.
04:25:05 <tdammers> the idea there is to have a "pure" annotation that does mostly what "const" does in C, except it covers purity rather than const-ness
04:25:19 <bollu> tdammers: really? that's nice. Cause C'++s is a constexpr clusterfuck 
04:25:31 <bollu> tdammers: every kind of purity?
04:25:51 <arahael> bollu: And is completely different to C's const. :)
04:26:15 <bollu> arahael: xD I'm glad. C's const is even "const" (const_cast<>() anyone?)
04:26:33 <tdammers> IIRC, D uses a concept of "external purity" - the function cannot call any impure functions, and it cannot reference any state other than its own local variable and arguments
04:26:45 <tdammers> it can, however, modify its local variables, which is a concession to practicality
04:26:59 <arahael> bollu: Const in C doesn't mean it won't change.  I'm still digging up on transducers, though.
04:27:07 <liste> wedens cassava + postgresql-simple ? 
04:27:12 <bollu> arahael: yes, but C++ lets you break that using const_cast
04:27:14 <tdammers> the rules are such, however, that the purity guarantees on the outside (i.e., from the caller's perspective) still hold
04:27:19 <arahael> bollu: I keep thinking of monads when I read http://blog.cognitect.com/blog/2014/8/6/transducers-are-coming
04:27:30 <tdammers> oh, and you're allowed to call a selected handful of functions designed for easier debugging
04:27:33 <doomlord> you even need restrict to actually allow register caching assumptions
04:27:39 <arahael> bollu: Of course C++ lets you break it.  const doesn't mean const. :)
04:27:46 * hackagebot rasterific-svg 0.2.3.2 - SVG renderer based on Rasterific.  https://hackage.haskell.org/package/rasterific-svg-0.2.3.2 (VincentBerthoux)
04:27:47 <tdammers> similar to Haskell's `trace`
04:27:54 <bollu> doomlord: yay, my fellow Rustic :) I didn't know you were on #haskell
04:28:08 <doomlord> lurking in many places
04:28:14 <tdammers> arahael: clojure has many abstractions that smell a lot of monads
04:28:40 <arahael> I see.
04:29:42 <wedens> liste: perhaps. but what with the streaming part? I can't find good examples of cassava+postgresql-simple using conduit or pipes
04:30:11 <liste> cassava has Data.Csv.Streaming
04:31:04 <liste> and you can do one INSERT per row
04:32:01 <wedens> liste: can I use COPY TO for batch insert?
04:32:20 <SK0> Is there a guide on when to INLINE functions?
04:33:37 <liste> wedens you could COPY FROM the CSV too without any Haskell, I suppose
04:34:00 <arahael> Only if he's on the DB server.
04:34:04 <liste> yeah
04:34:24 <liste> or, what about COPY FROM STDIN?
04:34:38 <liste> doesn't the data come from the client then?
04:34:39 <arahael> hmm, or that.
04:35:27 <crocket> bollu, What is your biased comparison of clojure and haskell?
04:36:19 <bollu> crocket: haskell is more "learn the ideas" (typeclasses, tons of weird constructs people have found, abstractions). Clojure is more "get stuff done with a *reasonable* amount of purity / FP / what have you"
04:36:30 <bollu> crocket: Clojure didn't really fit any niche for me
04:36:40 <crocket> Which niches?
04:36:58 <wedens> liste: true. but I'm not sure how it works with streaming
04:37:13 <crocket> Is haskell suitable for embedded devices that will power internet of things and for command line applications that need to start fast?
04:37:14 <tdammers> clojure is kind of OK if JVM is a given
04:37:18 <bollu> crocket: okay, the langauges I use: Python (ease of use + libraries), C/C++ (speed), Haskell (learn cool stuff), Rust (again, see how lifetimes and stuff can let someone write good code)
04:37:25 <wedens> liste: especially when data is on remote server
04:37:37 <bollu> crocket: so, well, Clojure doesn't do anything new for me that the languages I already know do
04:37:41 <crocket> Clojure is easy to use as well and has ok libraries.
04:37:50 <bollu> crocket: maybe if I want to write Clojurescript at some point I'll go back to it
04:37:52 <arahael> crocket: "internet of things"? What's that?
04:37:59 <tdammers> crocket: startup time is not usually a problem; running on embedded systems however is problematic
04:38:01 <arahael> crocket: Sounds like something a marketer would say.
04:38:07 <srhb> crocket: For embedded realtime things, usually you would use some kind of Haskell DSL to _generate_ fast and correct programs in eg C (see Atom) rather than embed the Haskell runtime
04:38:08 <crocket> Internet of trash bins and things like that
04:38:12 <arahael> crocket: Or a journalist.
04:38:23 <bollu> arahael: the idea is to connect everything together in a mesh network and exchange info between everyday objects 
04:38:25 <srhb> crocket: For command line things, sure, as long as you compile Haskell first, you can get very, very fast programs.
04:38:31 <tdammers> crocket: there are, however, libraries you can use to write your code in an EDSL in Haskell, and that code produces the actual embedded code for you
04:38:37 <bollu> arahael: idk, people have started defining protocols and stuff
04:38:41 <arahael> bollu: Sounds utterly stupid.
04:39:00 <bollu> arahael: meh, they have a point (as in, everything in our homes is slowly starting to run unix / linux and is connected)
04:39:06 <crocket> tdammers, That sounds suboptimal
04:39:16 <bollu> arahael: eg: smart TV, home automation systems, the 6-10 "regular" devices
04:39:26 <crocket> Is plain old ocaml ok for embedded thingy?
04:39:37 <bollu> arahael: try and count the number of things connected to the internet in your home, you'd be surprised...
04:39:37 <tdammers> crocket: maybe, but if you consider that doing *actual* I/O in Haskell pretty much works the same, then it's not really bad at all
04:39:53 <bollu> arahael: but I do believe they are premature
04:39:57 <tdammers> crocket: after all, the IO type is really also an EDSL for real-world effects
04:40:05 <arahael> bollu: Do many people actually *use* the functionality though? Even if it's a smart tv.
04:40:19 <bollu> arahael: that is completely different. Hence the "premature"
04:40:32 <tdammers> "internet of things" is a stupid name, right up there with "in the cloud" and "web 2.0"
04:40:35 <crocket> Trash bins will be on the internet.
04:40:51 <crocket> or on local network
04:40:51 <arahael> bollu: Fair enough.  Btw, I don't have a TV. Never owned one, even. :)  (Well, except for a brief moment of weakness for some guests)
04:41:01 <tdammers> just like "in the cloud" means "on somebody else's server", "internet of things" means "there's a computer in your appliance"
04:41:21 <bollu> arahael: :) Well, I'm living with my parents right now cause I'm sick, and we have a TV at home. I don't watch it, though
04:41:28 <SK0> The internet of things describes a process in human evolution
04:41:31 <arahael> bollu: I'm also home sick!
04:41:31 <crocket> As we put computers in trash bins, fat JVM won't fit in.
04:41:34 <bollu> arahael: It's mostly grandma who watches soap operas >_>
04:41:38 <srhb> Does it matter? Knowing the terminology is useful when discussing it, whether or not it's a dumb name.
04:41:38 <bollu> arahael: high five? :P
04:41:42 <srhb> Metadiscussing it is just noisy.
04:41:47 * arahael claps.
04:42:08 <bollu> tdammers: there's a computer *with an internet connection* :)
04:42:16 <arahael> srhb: I disagree.  I'd posit that most people who talk about "the cloud" or, now, "the internetn of things", don't neccessarily even kno wwhat they are.
04:42:18 <crocket> It seems haskell is not very good at low memory usage.
04:42:23 <tdammers> the terminology is euphemistic propaganda, is all
04:42:32 <srhb> arahael: OK.
04:42:38 <arahael> crocket: Most languages aren't, though I'd probably use C for really constrained environments.
04:42:50 <srhb> crocket: That's what things like Atom are great for.
04:42:58 <arahael> crocket: But...  Such constrained environments are increasonly rare.  Most embedded systems aren't like, an 8081 anymore.
04:42:59 <bollu> tdammers: "cloud computing", "retina display", "transducer", …
04:43:01 <tdammers> crocket: more like, haskell is average at memory usage, but there are a few gotchas that can blow things up
04:43:17 <srhb> crocket: Check out copilot, written with Atom, which is a NASA funded project for generating correct, fast C with Haskell.
04:43:35 <crocket> Clojure consumes memory extravagantly.
04:43:44 <quchen2> srhb: Disruptive, it has to be disruptive
04:43:46 <bollu> crocket: yes, and it isn't even pleasing to write
04:43:54 <srhb> quchen2: OK, you got me.
04:43:57 <tdammers> arahael: in the modern version of constrained embedded programming, the scarce resource isn't RAM or CPU anymore, but battery life
04:44:02 <quchen2> And gluten free
04:44:07 <crocket> bollu, Clojure was ok to write for me.
04:44:12 <bollu> the really liked the (->>) macro though. The "loop" macro is fugly
04:44:27 <bollu> crocket: you can't use recursion which is just silly. you need to force TCO with a macro
04:44:30 <arahael> tdammers: Arguably, though I do get your point.
04:44:34 <crocket> People use loop rarely.
04:44:38 <bollu> crocket: that takes out a lot of the lisp-y ness
04:44:45 <crocket> bollu, YOu have 'recur'
04:44:53 <arahael> tdammers: You can make very efficient 8-bit microcontrollers, in terms of battery usage.
04:44:54 <julianleviston> crocket: that *is* loop.
04:45:10 <julianleviston> crocket: at least, that’s what he’s talking about when he says TCO.
04:45:33 <tdammers> arahael: yes, but the interesting part is what that means for programming style
04:45:58 <crocket> Can linux be rewritten in haskell and run on a machine with 1GB RAM?
04:46:03 <arahael> tdammers: Point.
04:46:05 <bollu> julianleviston: not really, loop is a macro that lets you setup bindings before you "recur"
04:46:08 <bollu> IIRC
04:46:09 <crocket> like archlinux with XFCE
04:46:10 <bollu> it's been a while
04:46:13 <bollu> recur is a special form
04:46:15 <arahael> crocket: It wouldn't be linux, then.
04:46:16 <bollu> loop is a macro
04:46:25 <crocket> I mean something like linux
04:46:36 <tdammers> crocket: you mean, can kernels be written in haskell?
04:46:45 <bollu> tdammers: I don't think so, right?
04:46:48 <crocket> I know there were attempts like house.
04:46:48 <arahael> crocket: A defining part of unix and linux, are that the system is written in C, and uses files pervasively.
04:46:51 <bollu> tdammers: the runtime is weird
04:47:02 <bollu> tdammers: haskell's runtime, that is
04:47:24 <crocket> Replacing C with haskell would be terrific for operating system maintainers.
04:47:28 <bollu> tdammers: it's call stack is different from C too, I think? or it doesn't have a call stack because its continuations?
04:47:29 <julianleviston> crocket: the thing I really like about Haskell is that I get control over what evaluates… like… “arguments” for example :) to do that in clojure, you need to go into macro-land.
04:47:56 <crocket> I know macro land is quite difficult
04:47:57 <bollu> julianleviston: I'll pick static typing over everything else
04:48:25 <tdammers> macros are an anti-pattern IMO
04:48:27 <julianleviston> bollu: yeah, they go together.
04:48:31 <crocket> I have a feeling that static typing is hyped.
04:48:35 <julianleviston> tdammers: agreed! they always made me feel dirty
04:48:43 <julianleviston> crocket: go tell the author of clojure.typed that ;-)
04:49:02 <arahael> Haha!
04:49:08 <bollu> tdammers: depends. Hygenic macros are cool in my book
04:49:12 <bollu> tdammers: eg: Rust's macros
04:49:24 <crocket> Are clojure macros hygienic?
04:49:30 <tdammers> TH isn't too bad, but I still consider it a weak solution
04:49:48 <arahael> What's TH's cross-compilation story these days?
04:49:51 <julianleviston> crocket: macro land isn’t difficult… it’s just that in lisp you have to reach for it all the time, and it happens at read time… which makes things… complicated.
04:49:51 <crocket> Macros are to be used sparingly
04:50:08 <crocket> Macro begets macro
04:50:09 <julianleviston> crocket: lol half of clojure’s core library uses them.
04:50:19 <srhb> crocket: If it's hyped, then you've found one channel here that has completely drunk the kool-aid. Strong static typing is probably THE reason to use Haskell. So if you don't care about that, you won't like Haskell.
04:50:21 <bollu> 	crocket: IIRC, it has some semi-hygenic macro system?
04:50:32 <tdammers> one of my biggest itches is that you can't tell from a bit of clojure code whether it's invoking a macro or a function
04:50:46 <julianleviston> crocket: clojure is excellent if you’re stuck in java.
04:50:51 <crocket> Static typing in C and java sucked.
04:51:02 <tdammers> [(foo 1) (foo 2)] ; oh, let me refactor that into (mapv foo [1 2])
04:51:04 <aweinstock> julianleviston: I thought only CL's read macros were read-time, and regular macros (via defmacro) are compile-time?
04:51:06 <crocket> Clojure is also ok for exploring new algorithms.
04:51:12 <julianleviston> crocket: they didn’t have inference tho...
04:51:13 <crocket> like new machine learning algorithms
04:51:17 <tdammers> and then foo turns out to be a macro, and everything explodes
04:51:36 <bollu> crocket: meh, use octave / python / (even julia)
04:51:37 <julianleviston> aweinstock: you’re probably correct.
04:51:43 <crocket> tdammers, That's a contrived scenario. REPL prevents those cases.
04:51:46 <aweinstock> (i.e. read macros are lexer plugins, regular macros are AST -> AST functions)
04:52:00 <julianleviston> aweinstock: the thing that bothered me was that they weren’t functions… that you can’t pass them around...
04:52:05 <tdammers> crocket: how does REPL prevent this?
04:52:15 <crocket> REPL tests each expression
04:52:23 <tdammers> only if I tell it to
04:52:23 <crocket> Clojure programmers test almost every new line with REPL
04:52:23 <julianleviston> crocket: what?
04:52:30 <julianleviston> crocket: erm.
04:52:36 <crocket> They are REPL-driven
04:52:38 <srhb> That's not a language feature :-)
04:52:39 <julianleviston> crocket: dude.
04:52:42 <bollu> crocket: it doesn't give you the same guarentees as a type system
04:52:48 <aweinstock> julianleviston: in the sense that Haskell's forM_ and CL's dolist are the same construct, but forM_ can be passed around?
04:53:01 <julianleviston> aweinstock: I don’t know CL.
04:53:07 <arahael> crocket: That's really common.  python has the repl, haskell has a repl, most languages have one.  Not Java (because it's stupid verbose), though.
04:53:19 <arahael> Though, even C# has a repl.
04:53:26 <bollu> C++ too :)
04:53:28 <quchen2> C++ has Geordy
04:53:29 <bollu> cling
04:53:32 <julianleviston> aweinstock: in the sense that you can pass functions into other functions in haskell, or in clojure with other functions…but you just can’t do that with a macro.
04:53:33 <quchen2> Geordie? Something like that.
04:53:46 <crocket> You can even insert a REPL server in production clojure applications.
04:53:50 <crocket> It is so easy
04:53:50 <bollu> oh, cling is for C
04:54:03 <tdammers> crocket: except when it breaks.
04:54:23 <tdammers> crocket: also, having a repl in production code is a terrible terrible idea
04:54:27 <crocket> I know
04:54:41 <tdammers> people still do it, and celebrate it as a huge achievement
04:54:46 <aweinstock> julianleviston: (dolist (x '(1 2 3)) (format t "~a~%" x)) == forM_ [1,2,3] (\x -> print x)
04:54:49 <arahael> tdammers: Though, autocad had a lisp repl in it successfully, it seems.
04:54:59 <crocket> I know static typing guarantees really pay off as a program grows large.
04:55:12 <crocket> as a program passes hands of many programmers.
04:55:13 <tdammers> so anyway, yeah, repls are nice, but if a repl is the only tool I get, that's kind of a shitty situation
04:55:16 <quchen2> Where large = more than 1 byte
04:55:22 <julianleviston> aweinstock: oh … yeah, sure.
04:55:27 <arahael> crocket: No.  Size isn'nt relevant, really.
04:55:40 <tdammers> regarding static type checks, here's what I think.
04:55:41 <crocket> In small programs, dynamic typing is ok.
04:55:41 <arahael> crocket: The static type checking, however, really pays off as the program gets more _complex_.
04:55:56 <julianleviston> arahael: indeed!
04:55:57 <tdammers> types don't go away just because you ignore them; your code is always typed, whether it's explicit or not
04:55:58 <srhb> crocket: I think people overstate the cost of strong types in small programs because they're used to type systems that "get in your way." There's a learning curve, but no real programming overhead once that's done, even for small programs.
04:56:08 <srhb> crocket: Still, the claim persists because most type systems are... Well, bad.
04:56:18 <arahael> Eg, in scripts that barely have if branches, loops, and the like, but simply iterate line by line to the end...  Don't neccessarly gain much from static typing if it's easiy tested.
04:56:23 <tdammers> if it's not explicit, the burden of keeping things consistent is on the programmer
04:56:37 <crocket> I'm just saying dynamic typing and static typing don't make noticeable difference in small programs.
04:56:55 <arahael> crocket: How small?
04:57:00 <julianleviston> crocket: they do for me.
04:57:01 <srhb> I simply don't agree with that.
04:57:08 <tdammers> that's because with small programs, it is usually easy to do the type checking manually
04:57:08 <srhb> I can make type errors in small programs, and I do all the time.
04:57:37 <crocket> It's also easy to test small programs relatively thoroughly with test codes.
04:57:46 <srhb> Yes, but why not just not have to do that.
04:57:52 <julianleviston> crocket: yeah, but dynamic tests = haskell’s type system (automatic)
04:58:04 <julianleviston> crocket: this is something you possibly don’t realise unless you try it out.
04:58:19 <julianleviston> crocket: look at ruby’s obsession with TDD.
04:58:32 <crocket> In small, it doesn't justify learning haskell for clojure programmers.
04:58:36 <julianleviston> crocket: don’t even get me started on the whole “passing nil” problem in clojure!
04:58:36 <quchen2> The type system won't replace your dynamic tests. It reduces the need for them.
04:58:38 <arahael> The trouble, is that haskell doesn't have dependant typing. (is that the right term?), so you still need tests to cover _those_ cases.
04:58:43 <srhb> crocket: I didn't realize that was what we were arguing.
04:58:54 <tdammers> another problem with tests is that it's a blacklist approach
04:59:04 <julianleviston> quchen2: yeah, but quickcheck blows “static tests on dynamic languages” away IMO
04:59:08 <srhb> arahael: Yes, but DT loses you type inference and brings back that overhead.
04:59:18 <srhb> arahael: It's a tradeoff.
04:59:23 <quchen2> arahael: There are also high-level properties that are prohibitively expensive to be tested formally, but very easy via running programs that use them.
04:59:29 <arahael> srhb: Good to know!  I'm still figuring this out myself.
05:00:04 <srhb> arahael: Some features are available in Haskell but not really used widely exactly because the loss of inference is prohibitively costly. And also because DT is still Hasochism a lot of the time :P
05:00:11 <crocket> In small, I barely felt any need to verify type.
05:00:44 <tdammers> crocket: the thing is, the type system isn't your enemy, you can use it to your advantage
05:00:45 <quchen2> Neither do I. But GHC usually complains anyway.
05:01:04 <crocket> tdammers, I didn't say static typing is disadvantageous.
05:01:07 <delYsid> Do we have a library that implements Knuth's "Breaking Paragraphs into Lines" in a generic way?  Something that I could reuse to do line breaking in a text-only (no stretch) environment?
05:01:31 <tdammers> it's like writing code by dealing with all the possible values simultaneously
05:01:32 <julianleviston> crocket: if you want the perspective of someone who has vast experience in both languages, read this: I’ve had type errors in Clojure that multiple professional Clojure devs (in- cluding myself) couldn’t resolve in less than 2 hours because of the source-to- sink distance caused by dynamic typing. We had copious tests. We added println’s everywhere. We tested individual functions from the REPL. It still took ages. 
05:01:33 <julianleviston> was only 250 lines of Clojure. I’ve had similar happen in Python and Common Lisp as well. I did finally fix it and found it was due to vectors in Clojure implementing IFn. The crazy values that propagated from the IFn usage of the vector allowed malformed data to propagate down- ward far away from the origin of the problem. The same issue in Haskell would be trivially resolved in a minute or less because the type-check
05:01:34 <julianleviston> will identify precisely where you were inconsistent.
05:01:49 <julianleviston> crocket: that’s from Chri Allen (bitemyapp)… http://haskellbook.com/authors.html
05:02:16 <crocket> In a large project involving multiple devs, dynamic typing becomes painful
05:02:33 * srhb shrugs
05:02:34 <nshepperd> the way people conceive of static typing before they know haskell is as some sort of crotchety system of rules that stops you from writing any abstractions because it has no features
05:02:43 <crocket> By the way, 250 lines?
05:02:48 <tdammers> crocket: honestly, for me the breaking point is at "one screenful"
05:02:48 <srhb> nshepperd: In fairness, that's... What it usually is like. :-)
05:02:54 <julianleviston> nshepperd:  agreed.
05:02:56 <nshepperd> yep
05:03:25 <crocket> I suspect 250 lines are small enough for clojure.
05:03:39 <crocket> My clojure program is larger, but it is easy to reason about
05:03:56 <nshepperd> from that point of view, dynamic typing is great, because "yay, I can finally write 'map'!"
05:04:36 <srhb> Real Geniuses can probably write thousands of lines of correct-in-one-go PHP, even.
05:04:36 <tdammers> I have a 750-line module here where I've spent the better part of today figuring out why it throws a NullPointerException
05:04:38 <crocket> Is dependent type a useful restriction?
05:04:41 <srhb> I'm sure that's very individual.
05:04:42 <arahael> What really gets me, are language that are neither dynamically nor static typed.
05:04:57 <julianleviston> crocket: what do you mean?
05:05:09 <crocket> Dependent types restrict what you can do with types.
05:05:10 <tdammers> it's not a huge project, and I'm the only author
05:05:11 <arahael> But which impliclityly "coerces" the types depending on how they're used. Ugh.
05:05:12 <nshepperd> but, we have haskell now, and the haskell type system can do pretty much everything that people would resort to dynamicism for
05:05:13 <bollu> arahael: so, C? :)
05:05:19 <tdammers> I have about 200 tests for that module alone
05:05:24 <arahael> bollu: Yes, actually. also perl, javascript... :)
05:05:27 <crocket> tdammers, Was it a clojure project?
05:05:30 <tdammers> yes
05:05:44 <crocket> If I had the same experience, I'd conclude the same.
05:05:45 <arahael> bollu: I prefer C++ for that reason, actually, as it's much more strongly typed.
05:05:58 <tdammers> test:code ratio is > 1
05:06:00 <bollu> arahael: true. C++11 to me is nice
05:06:04 <crocket> I haven't been bitten yet.
05:06:15 <arahael> bollu: Indeed, as that has type inferrence, too. In some cases.
05:06:22 <julianleviston> crocket: clojure is vastly better than javascript.
05:06:25 <julianleviston> crocket: :)
05:06:26 <bollu> yes, "auto" is nice
05:06:31 <crocket> https://github.com/crocket/clj-ddns-client is my code, and it works smoothly.
05:07:06 <tdammers> thing is, this kind of thing has happened to me a lot
05:07:08 <bollu> arahael: It might just be me, but I find myself yearning for simplicity
05:07:09 <ent> isn't weak/strong typing more a question of "what's the type of these bits in memory" and dynamic/static more a question of "this variable is of type x"
05:07:14 <julianleviston> cr it’s like … 10 functions.
05:07:18 <tdammers> usually in Python or Clojure
05:07:19 <bollu> arahael: something like C + typeclasses
05:07:20 <quicksilver> bollu: you and Occam both :)
05:07:25 <arahael> ent: Sort of.
05:07:26 <ent> so strongly typed isn't really the counterpart for dynamic typing
05:07:27 <tdammers> never in Haskell, rarely in C++
05:07:43 <arahael> ent: Weakly typed languages have no way of telling you the type - not at runtime, nor at compile time.
05:07:43 <bollu> quicksilver: :)
05:07:57 <bollu> Haskell is too "out there" to collaborate with people
05:08:08 <bollu> python too slippery, C++ to complex, Java too slow
05:08:09 <srhb> ent: With those terms we might as well do away with the idea of Haskell being typed. :P
05:08:11 <bollu> *sigh*
05:08:13 <quicksilver> there are 1500 people in this room, bollu 
05:08:19 <crocket> tdammers, In javascript, I feared that other programmers would mutate my objects. In clojure, I didn't fear such things.
05:08:20 <quicksilver> it's one of the busiest IRC channels in the world
05:08:30 <quicksilver> there are definitely 'some' haskell people to collaborate with :)
05:08:38 <arahael> quicksilver: He was being sarcastic.
05:08:46 <tdammers> I don't fear other people, I fear my own mistakes
05:08:48 <quicksilver> oh
05:08:54 <julianleviston> tdammers: haha same.
05:08:57 <bollu> quicksilver: I mean, among my friends or something :) I want to write a game in Haskell and I'm not able to convince my friends to switcg
05:08:59 <crocket> tdammers, When you work with other programmers, you will.
05:09:05 <tdammers> other people's mistakes are easy
05:09:06 <bollu> quicksilver: no, I wasn't being sarcastic :)
05:09:17 <julianleviston> tdammers: it’s like… your heart on your sleeve
05:09:18 <quicksilver> bollu: sure. Your friends will learn a lot from trying to learn haskell :)
05:09:31 <quicksilver> but that's not teh quickest way to write a game.
05:09:37 <tdammers> because mistakes I make come from my own brain, and there's a certain blindness there
05:09:40 <bollu> quicksilver: xD yeah, but to them, the time sink versus reward isn't worth it
05:09:42 <tdammers> also, expectation bias
05:09:43 <srhb> And you will learn a lot from convincing your friends to learn Haskell. Hate, suffering, ...
05:09:52 <bollu> most of us freelance for webdev and stuff so we have our own projects or whatever going on
05:09:54 <tdammers> the reason I write what I write is because I expect it to work
05:09:57 <Pro9> When do you use putstr over print? or is print always preferable over putstr since it supports more then just strings?
05:10:01 <tdammers> so when it doesn't, I'm baffled
05:10:09 <srhb> Pro9: print = putStrLn . show
05:10:15 <crocket> hmm
05:10:19 <srhb> Pro9: So print converts any value with a Show instance to String.
05:10:19 <julianleviston> Pro9:  print expects show
05:10:26 <tdammers> whereas when somebody else wrote something that doesn't work, the reason is usually obvious, because it's not the kind of mistake *I* would make
05:10:27 <julianleviston> :t print
05:10:28 <lambdabot> Show a => a -> IO ()
05:10:34 <srhb> Pro9: While putStr and putStrLn simply print Strings.
05:10:40 <hyPiRion> My experience is that it depends on your task. Some of the data structures I need to implement just aren't possible to describe in Haskell elegantly because I need to use very weird tricks that depends on polymorphic recursion and similar things. They are doable if I either sacrifice performance or elegance, but I want to have readable code too.
05:10:46 <bollu> quicksilver: I've set up the rules like this for my hobby game project (http://github.com/bollu/lovecraft)
05:10:49 <crocket> Is dependent typing a win?
05:10:53 <quicksilver> Pro9: often, Show instances are for debugging purposes.
05:10:54 <bollu> I wonder if it'll help or hinder
05:10:55 <tdammers> and, more importantly, because I read their code without the kind of expectations I have when reading my own
05:10:57 <srhb> crocket: Possibly. 
05:10:59 <crocket> Garbage collector was a win
05:11:04 <quicksilver> Pro9: for real well formatted output you wouldn't use them
05:11:04 <julianleviston> bollu: lovecraft? as in…. the horror author?
05:11:16 <bollu> julianleviston: yes, that's the name :P
05:11:18 <quicksilver> except possibly the instance for Int 
05:11:19 <arahael> hyPiRion: Couldn't you define a DSL for that?
05:11:21 <srhb> crocket: As stated, it's a tradeoff. You have to prove more things, but you get more guarantees.
05:11:29 <julianleviston> bollu: lol I’ve heard of references, but to actually use his name… wow
05:11:40 <exio4> tdammers: Haskell's type system helps with both :P
05:11:40 <bollu> julianleviston: :)
05:11:41 <Pro9> quicksilver: What do you use to print well formated output?
05:11:46 <tdammers> exio4: definitely
05:12:10 <crocket> srhb, Some tradeoffs are wins.
05:12:16 <crocket> like garbage collector
05:12:17 <tdammers> example; I'm writing this parser here, and I'd write something like: (tentatively (string "abc"))
05:12:25 <RageYL> how do you create 'sub' parser with attoparsec ? for example i extract a fixed length chunk then parse it. (it's the only way i know to do something like that). but i loose the possibility to throw error. (https://gist.github.com/anonymous/ae147c6220e615d0e205) what would you advice ?
05:12:26 <srhb> crocket: Garbage collector is not always a win in all situations.
05:12:31 <quicksilver> Pro9: I write code. Not sure how ot answer that :)
05:12:32 <bollu> crocket: a GC is never a "win" if you're doing anything realtime
05:12:36 <tdammers> now, that code is wrong, it should be (tentatively string "abc")
05:12:38 <crocket> srhb, But, it is a win in most cases.
05:12:44 <srhb> crocket: And maybe DT is, too.
05:12:47 <arahael> bollu: There are realtime GC's, though.
05:12:49 <crocket> What is DT?
05:12:51 <bollu> crocket: anything audio/visual it is not
05:12:51 <tdammers> and if it were someone else's code, I'd spot it immediately
05:12:53 <srhb> crocket: Dependent typing.
05:12:56 <bollu> arahael: very few of them
05:13:01 <arahael> bollu: True.
05:13:06 <bollu> arahael: the problem is that they are hard to control
05:13:15 <arahael> bollu: Most people seem to be happy with soft-realtime,a s well.
05:13:17 <srhb> crocket: But as a Haskell programmer, I don't feel very tempted to give up super type inference.
05:13:18 <tdammers> but it's my own, so I have this expectation that says "this code tentatively parses the string 'abc'", so that's how I read it
05:13:19 <bollu> arahael: Like, I wouldn't mind stop-the-world if I could give it an upper bound
05:13:22 <arahael> And C++ gives a good alternative.
05:13:33 <tdammers> and my brain corrects the wrong implementation for me to match my expectation
05:13:33 <Pro9> quicksilver: ahh, thought here were some print function that you could use to help you format, my approach to printing at the moment is: stringbuilder -> print -> output
05:13:36 <bollu> arahael: you mean smart poiinters?
05:17:11 <crocket> type inference saves energy
05:17:11 <arahael> bollu: I mean RAII, but yes, smart pointers as well.
05:17:11 <srhb> crocket: Yes, and with DT, you lose that in general.
05:17:11 <crocket> Does idris lose type inference?
05:17:11 <tdammers> the equivalent Haskell code would just slap the actual source of the error in my face:
05:17:11 <srhb> Yup.
05:17:11 <bollu> arahael: I've wound up doing this really ugly thing in my games where I malloc a 1GB chunk of memory and live within that
05:17:11 <crocket> Can it be improved?
05:17:11 <hyPiRion> arahael: Probably? I haven't used DSLs in Haskell.
05:17:11 <bollu> arahael: it gives the best performace I've ever seen
05:17:11 <srhb> crocket: Probably, but there _are_ fundamental limitations to how far type inference CAN go with DT.
05:17:11 <arahael> bollu: Understandably.
05:17:11 <tdammers> I'm passing a value where a function is expected
05:17:11 <ggole> bollu: that's how many games have been written for some decades now
05:17:11 <exio4> type inference becomes code inference quite fast with DTs too
05:17:11 <bollu> ggole: yep, ik
05:17:11 <crocket> I think garbage collectors just need more time to be ready for realtime applications like video.
05:17:11 <bollu> ggole: but then things like the new batman games come out
05:17:11 <arahael> Bed time for me.
05:17:11 <bollu> night :)
05:17:11 <arahael> crocket: A couple of decades isn't enough?
05:17:11 <ent> aren't quite many games made with gc'd languages?
05:17:11 * arahael departs.
05:17:11 <ent> like probably most?
05:17:11 <bollu> ent: the scripting language is GC'd, but the engine is not
05:17:11 <pacak> ent: minecraft
05:17:11 <ent> bollu: ah, that could be
05:17:11 <crocket> Some rhythm games were written in scheme.
05:17:11 <ARM9> what games are written in is rather blurry these days
05:17:11 <bollu> ent: so your core engine doesn't have a GC, but the scripts that run on a separate thread or whatever is GCd
05:17:11 <tdammers> games are soft realtime tho
05:17:11 <arahael> Gah, this discussion is too interesting.
05:17:11 <ARM9> for the last couple decades games were written in a mix of high and low level languages
05:17:11 <arahael> ent: Most games using DirectX can't be GC'ed. At least for the component using DirectX.
05:17:11 <julianleviston> bollu: I live with a MASSIVE lovecraft fan
05:17:11 <c_wraith> just about all mobile games are mostly in GC'd languages
05:17:11 <arahael> ent: Because you can't even touch the pointers that are locked by DirectX.
05:17:11 <crocket> java?
05:17:11 <ARM9> c_wraith except the parts that aren't
05:17:11 <crocket> Are android 3D games written in java?
05:17:11 <bollu> c_wraith: really? most people I know either (a) use unity with drops down to C, or they use the JNI to drop down to C
05:17:14 <tdammers> the situation is that you want to maintain a constant high frame rate if possible, but dropping frames is generally acceptable
05:17:18 <ent> what about mobile games, do they usually use a non gc'd engine too?
05:17:29 <bollu> c_wraith: eg, I was working on PPSSPP for a while
05:17:37 <ARM9> android 3d games are written in c++ and java, and probably some scripting languages here and there
05:17:39 <bollu> c_wraith: and the only part where we interacted with Java was for IO
05:17:59 <bollu> c_wraith: as in "take this audio and dump it out" , "give me the openGL context", "give me input"
05:18:04 <bollu> *everything* else was C++
05:18:15 <tdammers> so there are execution deadlines, but violations are mitigated - a game does not crash and burn if at some point a frame doesn't get rendered in time
05:18:18 <exio4> that is how you get haskell to work on android too
05:18:25 <crocket> JVM wasn't famous for real-time applications.
05:18:39 <crocket> Neither was dalvik VM.
05:18:57 <tdammers> for hard realtime, any general-purpose GC solution is pretty much out of the question
05:19:17 <crocket> We need more research on real-time general-purpose GCs.
05:19:33 <julianleviston> bollu: did you see there’s a clojure interface for unity? on CLR
05:19:37 <ARM9> good thing we have ART now instead of dalvik
05:19:41 <ggole> There's been tons of research on real-time GCs
05:19:42 <bollu> julianleviston: really? that is cool
05:20:00 <bollu> julianleviston: unity binds to C# as wel, right?
05:20:02 <julianleviston> bollu: it was… functional programming possibl with unity. the things people were doing was pretty amazing.
05:20:02 <bollu> well*
05:20:08 <julianleviston> bollu: yep.
05:20:15 <julianleviston> bollu: and… welrdly, js
05:20:22 <bollu> xD
05:20:27 <bollu> everything runs on JS
05:20:29 <julianleviston> bollu: tho it’s really just the mono thing I think.
05:20:40 <exio4> wouldn't F# work too?
05:20:54 <julianleviston> exio4: theoretically anything anyone did would! :)
05:21:01 <julianleviston> exio4: that ran on mono...
05:21:49 <exio4> julianleviston: it does run on mono! 
05:21:57 <julianleviston> exio4: it does :)
05:23:56 <fractalsea> I’ve been trying to reduce the amount of work the GC has to do by reducing the %size of allocations made when serialising data to write to a TCP socket. I’m using the cereal library. I switched to using lazy encoding, but the allocation size is just as much as before (~50 of the program’s allocation size is due to toLazyByteString). I had hoped that using lazy encoding would reduce this, does anyone know why it d
05:23:57 <fractalsea> not? Or have any other suggestions?
05:24:03 <crocket> mono, mono, mono, mono... https://www.youtube.com/watch?v=kClESsrnRhw&t=26s
05:27:51 <Yuras> fractalsea: what is the actual issue? is GC time big? Allocations are virtually free if they are short living
05:32:27 <crocket> Will haskell GC be real-time in the foreseeable future?
05:33:40 <fractalsea> Yuras, Yes there are big spikes in the latency of our system, and I think it is most likely the GC
05:33:57 <srhb> crocket: No.
05:34:11 <fractalsea> For example: http://i.imgur.com/GZ0Ek98.png
05:34:19 <rhz> Anyone got ghc working under OSX 10.11?
05:34:31 <fractalsea> Red colour is > 90th percentile
05:34:44 <iamutkarsh> Hello! I would like to contribute to Huskell. I am familiar with Java, Python, C and have written couple of open source 2D games in Python. Could anyone here please get me started?
05:35:16 <srhb> iamutkarsh: The learnhaskell guide is pretty good. https://github.com/bitemyapp/learnhaskell
05:35:53 <srhb> iamutkarsh: Your familiarity will probably not help you much, aside from having less difficulty with the tooling. Start with the basics, they'll probably be entirely new to you -- not by trying to make some project.
05:36:16 <fractalsea> There is about 20M allocated on the heap at all times, and the majority of that is from encoding of our message data structure to bytestrings
05:38:06 <crocket> srhb, Why no?
05:38:10 <trubar3> According to https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime-control.html , the +RTS -B flag means that the system bell will ring at each major garbage collection.
05:38:23 <srhb> crocket: It's a hard research problem that has not been solved.
05:38:24 <trubar3> Unfortunately, when I use this flag, my system bell doesn't ring.
05:38:25 <Yuras> fractalsea: try +RTS -S to dump online GC stats and try to find correlation
05:38:50 <padre_angolano> чо-то октябрь, и погода соответствующая, а отопление сегодня не включили. 7-го gismeteo уже и снег обещает
05:38:54 <padre_angolano> oops sorry
05:39:10 <fractalsea> Yuras, OK I will try that now. Thank you
05:41:23 <Yuras> fractalsea: the idea is to find out whether gen0 or gen1 collection is problematic. most likely it is gen1, then find out why so much data survives gen0 collection and goes to gen1
05:57:23 <crocket> Can haskell be used to write MySQL?
05:57:43 <crocket> MySQL's requirement for real-time response worries me.
05:57:53 <crocket> Depends
05:57:57 <merijn> MySQL isn't real-time...
05:58:13 <f-a> http://hackage.haskell.org/packages/search?terms=mysql apparently: yes
05:58:15 <slacko1256> database and realtime don't seem to go hand in hand
05:59:21 <crocket> f-a, Those are projects around mysql.
05:59:24 <crocket> Not mysql itself
05:59:29 <f-a> oh I see
06:01:42 <info_is_good> Is there any clever way to optimize this function?  http://lpaste.net/142073
06:01:54 <pavonia> crocket: Are you asking about writing a MySQL database server using Haskell?
06:02:30 <crocket> yes
06:02:33 <crocket> something like mysql
06:04:02 <nshepperd> I don't think there are any real-time sql databases
06:05:17 <nshepperd> most operations running time scale in some manner with the sizes of your tables, which can be arbitrarily large, so it's hard to see how such a thing /could/ be real-time
06:05:41 <slacko1256> also on databases you are more concerned with raw performance that meeting deadlines on operations
06:05:48 <c_wraith> If the operations are allowed to fail it could be real-time.  All operations would fail if the database got too big....
06:07:57 <quicksilver> info_is_good: its symmetric isn't it? You could write it shorter by missing out one half of the asymmetric cases
06:08:05 <quicksilver> info_is_good: but that's not exactly 'optimisation\
06:09:26 <quicksilver> info_is_good: the 'A B AB' part is rather like the type 'These' on hackage
06:10:37 <info_is_good> quicksilver: interesting, is Tree the free monad on These?
06:11:40 <quicksilver> info_is_good: dunno
06:12:20 <lpaste> Pro9 pasted “Not in scope: intToDigit, while trying to convert a "Maybe Int" to char” at http://lpaste.net/7080624114284625920
06:12:24 <c_wraith> Free (These a) is like.. a natural that might be decorated by values of type a
06:12:40 <c_wraith> There's no branching in it, though.
06:13:07 <c_wraith> Each node has 0 or 1 child
06:13:12 <quicksilver> I think info_is_good is actually means newtype BiThese a = BiThese (These a a)
06:13:14 <c_wraith> Err, forking.
06:13:18 <quicksilver> that's what matches his type
06:13:23 <c_wraith> Ah
06:13:49 <quicksilver> BiTheseBeforeTheyreGone
06:13:52 <c_wraith> Hmm.  Freeing that *will* give you a tree
06:14:00 <quicksilver> did you see his paste?
06:14:21 <c_wraith> no, and I have to run now.  I just like practicing envisioning free and cofree on arbitrary functors
06:14:30 <Eat-Marmitte> r Hello Guys
06:14:30 <Eat-Marmitte> Which is the Irc command to know about a user the other nicknames that this user has used ?
06:15:27 <ChristianS> Eat-Marmitte: there is no such command
06:15:29 <shiona> No reliable way of doing that
06:15:38 <shiona> whowas sometimes somehow seems to work
06:16:02 * geekosaur suggests asking in #freenode
06:17:42 <info_is_good> That makes a lot of sense. Will using `these` be faster (i.e., is it hardcoded-optimized like List)?
06:19:32 <quicksilver> no
06:22:50 <info_is_good> quicksilver: I see, thanks.
06:23:21 <quicksilver> @hoogle on
06:23:23 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
06:23:23 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
06:23:23 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
06:25:32 <Sindriava> Is there a reason there's no (>>) ?
06:25:41 <Sindriava> er, * (<<)
06:25:52 <merijn> Sindriava: It's redundant now that we have AMP
06:25:55 <merijn> :t (<*)
06:25:56 <lambdabot> Applicative f => f a -> f b -> f a
06:26:02 <Sindriava> :t (*>)
06:26:04 <lambdabot> Applicative f => f a -> f b -> f b
06:26:06 <Sindriava> :t (>>)
06:26:08 <lambdabot> Monad m => m a -> m b -> m b
06:26:13 <merijn> Sindriava: Well, it depends on what you want it to do, I guess :)
06:26:14 <fractalsea> Yuras, OK I ran the program with -S, and I could not see any significant GC during the period when I can see the spikes (at least looking at the ‘GC user’ column). This is the summary I get at the end:  https://gist.github.com/WillSewell/087779af41cb32e296c5
06:26:24 <merijn> Sindriava: <* is different from "flip (<<)"
06:26:34 <bollu> merijn: what if the applicative sequencing is in parallel while the monad is sequential?
06:26:42 <bollu> merijn: won't the semantics change?
06:26:46 <Sindriava> merijn: Doesn't *> make >> redundant, then?
06:26:49 <merijn> Sindriava: i.e. "x <* y" is "do { x' <- x; y; return x' }"
06:26:53 <merijn> Sindriava: Yes
06:27:04 <merijn> Sindriava: But >> has to be kept for backwards compatibility
06:27:08 <estike> i have to do a exercise that a function f is Bool->Integer, i am doing f::Bool->Integer 
06:27:09 <Sindriava> I see
06:27:11 <Pro9> When looking up a function on hoogle, is there any easy way to see if I need to import the package the function is included in, or if it's part of the default packages?
06:27:14 <Sindriava> Welp.
06:27:18 <Sindriava> merijn: Thanks ^^
06:27:41 <merijn> bollu: No, because the sequencing shouldn't effect the result for lawful Applicatives and Monads
06:27:42 <estike> i have to do a exercise that a function f is Bool->Integer, i am doing f::Bool->Integer f x = if x ==100 then 1 else 0
06:28:05 <Yuras> fractalsea: do you see gen1 collections during the spikes?
06:28:15 <estike> but it gives me a error on the prompt
06:28:36 <fractalsea> Yuras, I see them all over the place
06:29:02 <fractalsea> Yuras, every 100ms or so
06:29:33 <geekosaur> estike, ghci is not the haskell toplevel, you need to use let
06:29:44 <geekosaur> let f :: Bool -> Integer; f = ...
06:29:50 <geekosaur> er. f x = ...
06:30:42 <Yuras> fractalsea: but gen1 collections don't correlate with spikes, right?
06:31:04 <estike> it gives me error the same way geeksaur
06:31:45 <estike> no instance for (num bool) arising from the literal 100
06:31:55 <Yuras> fractalsea: could you please paste a typical piece of the log? including two or five gen1 collections
06:32:03 <Sindriava> estike: What sense does comparing a bool to a 100 make?
06:32:24 <Sindriava> `f x = if x == 100 …` when `f :: Bool -> …` doesn't work
06:33:07 <estike> so i have to do a function that gives me bool->integer 
06:33:13 <tdammers> no
06:33:28 <tdammers> why do you want to compare booleans against integers in the first place?
06:33:44 <estike> it is a exercise i have to do 
06:33:46 <geekosaur> actually that function looks like all sorts of confusion. "if x == 100 then 1 else 0" looks like a misguided attempt at Integer->Bool
06:34:00 <geekosaur> so how about provide the actual exercise text?
06:34:03 <geekosaur> @paste
06:34:03 <lambdabot> Haskell pastebin: http://lpaste.net/
06:34:25 <Sindriava> estike: I somehow doubt that, comparing booleans to integers doesn't make sense. Can you provide the excercise you're doing? :)
06:34:34 <Sindriava> Ah, ninja'd by geekosaur 
06:37:05 <estike> http://lpaste.net/142076
06:37:31 <estike> i put the exercise in this http://lpaste.net/142076
06:37:54 <tdammers> ah
06:38:08 <tdammers> so the task is just "write a function of type Bool -> Integer"
06:38:34 <estike> yes 
06:38:58 <tdammers> then why do you think you need to *compare* booleans with integers?
06:39:15 <tdammers> all you need is something that takes a boolean and returns an integer
06:40:09 <geekosaur> it says you have to explain it too. can you explain what your proposed function actually does? sensibly?
06:40:13 <quchen2> f _ = 1
06:40:15 <quchen2> g _ _ = []
06:40:23 <quchen2> h _ _ = True
06:40:48 <frerich> :t \_ -> 1
06:40:50 <lambdabot> Num a => r -> a
06:41:03 <frerich> but, but - that's not what was asked!
06:41:16 <Shockk> hmm, if I'm forking some haskell project and it's dual-licensed under LGPL and BSD3, does my fork also need to be dual-licensed or can I fork it under only one license?
06:41:52 <tdammers> Shockk: I believe the situation is such that you can pick either license, and you have to comply with its conditions
06:42:03 <Sindriava> Bool -> Integer is such a weird type
06:42:10 <Shockk> tdammers: ahh, thanks
06:42:22 <tdammers> (I'd pick BSD3 ;)
06:42:22 <estike> so if a compare two integers it gives me a boolean and then if is true returns a value 
06:42:42 <geekosaur> but what about the Bool passed in?
06:42:43 <tdammers> you don't have two integers though
06:42:47 <tdammers> you have one boolean
06:42:55 <frerich> estike: You only have a Bool, and you need to produce an Integer.
06:43:16 <frerich> Sindriava: I think it's actually a nice exercise because it forces you to think about how types kind of limit the possible implementations of a function
06:43:23 <tdammers> here's a hint: how many possible values are there for booleans?
06:43:31 <estike> true or false
06:43:35 <tdammers> exactly
06:43:48 <Sindriava> estike: Bool -> Integer is a function that takes a boolean as an input and gives an integer as it's output. So - being pure - it can only ever return two distinct integers
06:44:11 <tdammers> so your function can follow one of two patterns: a) ignore the argument and always return the same integer, or b) return one integer for True and another for False
06:44:29 <estike> so if i put true returns one value if it is false returns other
06:44:35 <tdammers> yes
06:44:48 <tdammers> except for the integers you pick, those are the only possible implementations
06:45:19 <tdammers> (well, you could write a non-total function, but we don't like those at all)
06:45:56 <estike> so a function like f x = if x ==True then 1 else 0
06:46:07 <tdammers> pretty much
06:46:07 <kqr> that's it
06:46:08 <estike> it works then
06:46:17 <tdammers> except that == True is redundant, but yeah
06:46:27 <Sindriava> estike: You can make it even nicer by doing `if x then 1 else 0`
06:46:38 <kqr> `bool 0 1 x`
06:46:42 <kqr> eta-reduce!
06:46:44 <Sindriava> estike: Or even nicer by doing `f True = 1` and `f False = 0`
06:46:46 <tdammers> haha
06:46:54 <Sindriava> kqr + 1
06:47:21 <estike> i am on the beginning of a chair in university so i am doing everything redundant :p
06:47:27 <quchen2> f x | x = 1 | True = 0
06:47:44 <m1dnight_> I know this question will probably have been asked a 100 times but Ill try to explain. Im looking for a good book on haskell. I have done some programming and Im not afraid of some theory. The ultimate goal is to properly understand haskell. So I would like to have some exercises in the book as well as some thorough explanation of concepts. I have read learnyouahaskell but i found it too slow/vague.
06:47:49 <Sindriava> quchen2: Wouldn't that always return 1?
06:47:55 <kqr> Sindriava, no
06:48:00 <kqr> Sindriava, | is not pattern matching, it's guards
06:48:08 <quchen2> > let f x | x = 1 | True = 0 in f False
06:48:10 <lambdabot>  0
06:48:15 <kqr> but it is successfully confusing because it says True = 0 which is a bit funny I gues
06:48:17 <Sindriava> kqr: oh damn, that's confusing
06:48:18 <tdammers> also: f = fromEnum
06:48:21 <tdammers> :x
06:48:29 <quchen2> Sindriava: If it helps,
06:48:31 <quchen2> > otherwise
06:48:32 <lambdabot>  True
06:48:36 <Sindriava> quchen2: Nah, I get it now
06:48:49 <delYsid> Oh, now I know what Cabal hell is.
06:48:50 <quchen2> otherwise looks like a built-in, but it's literally True
06:48:52 <Sindriava> quchen2: I just didn't realise that the x wouldn't include anything
06:49:25 <Sindriava> quchen2: Yeah, I remember when I figured that out, it was pretty neat. Just like a lot of other things in haskell, they seem like they'd be built in, but they're not
06:49:28 <Sindriava> like Bool
06:49:29 <delYsid> neither apply-refact nor hakyll can be installed here due to failures in their dependencies (HUnit and enumerator)
06:50:06 <The^One> hi all will any one tell me what ">>=" is called google results are not being helpful
06:50:12 <kqr> The^One, bind
06:50:21 <tdammers> :t (>>=)
06:50:22 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:50:28 <m1dnight_> I think bind.
06:50:32 <delYsid> The^One: Its called bind.
06:50:44 <c_wraith> Book may be library defined, but several buts of syntax desugar to using it
06:50:48 <The^One> thanks guys
06:50:51 <c_wraith> *Bool
06:51:01 <c_wraith> *bits. Damn autocorrect 
06:51:17 <c_wraith> So.. It's still baked into the language. 
06:51:43 <kqr> how many buts? other than `if`
06:51:58 <c_wraith> Guards. :P
06:52:05 <kqr> can't you pretend guards desugar to if
06:52:17 <kqr> i guess that might not help depending on your point of view...
06:52:25 <exio4> and if desugars to case
06:52:27 <c_wraith> Nah, I pretend they both desugar to case
06:52:58 <c_wraith> Since guards don't require an else, they're much more like case
06:52:58 <exio4> c_wraith++ helps with pattern guards too
06:53:05 <kqr> exio4, but that desugaring requires knowledge of True and False, which a desugaring to if does not
06:53:30 <estike> in the second i have to do a->b->[(a,b)] can i put a= name b=age ?
06:54:08 <delYsid> How do I deal with uninstallable packages?  Whats the typical workflow?  Check it out from git, and manually fix the problem?  Or is there some other way?
06:54:58 <merijn> delYsid: "cabal get" the source from hackage, try to fix and email patch?
06:56:00 <bollu> so I was playing around with the dual of foldable
06:56:03 <bollu> and it is very weird
06:56:05 <nshepperd> you can define your own Bool with RebindableSyntax!
06:56:13 <bollu> @let toList = foldr [] (:)
06:56:14 <lambdabot>  .L.hs:147:16:
06:56:15 <lambdabot>      Couldn't match expected type ‘a
06:56:15 <lambdabot>                                    -> (a1 -> [a1] -> [a1]) -> a1 -> [a1] -> [...
06:56:22 <bollu> :t foldr
06:56:23 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
06:56:38 <bollu> @let toList = foldr (:) []
06:56:40 <lambdabot>  Defined.
06:56:42 <bollu> :t toList
06:56:44 <lambdabot>     Ambiguous occurrence ‘toList’
06:56:44 <lambdabot>     It could refer to either ‘L.toList’,
06:56:44 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:147:1
06:56:53 <bollu> :t flip L.toList
06:56:54 <lambdabot>     Couldn't match type ‘[a]’ with ‘b -> c’
06:56:54 <lambdabot>     Expected type: t a -> b -> c
06:56:54 <lambdabot>       Actual type: t a -> [a]
06:57:00 <bollu> what?
06:57:22 <kqr> :t L.toList
06:57:24 <lambdabot> Foldable t => t a -> [a]
06:57:27 <bollu> okay, basically, flipping toList led me to something.. weird and I want to know what it is
06:57:27 <kqr> just one argument
06:57:31 <bollu> oh
06:58:25 <bollu> :t foldMap
06:58:26 <nshepperd> oh, it doesn't seem to work for guards
06:58:27 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
06:58:30 <nshepperd> that's a shame
06:58:34 <bollu> :t flip foldMap
06:58:36 <lambdabot> (Foldable t, Monoid c) => t a -> (a -> c) -> c
06:58:54 <bollu> oh, wait, the dual of a category is not equal to flip, That's what I was screwing up
06:59:18 <bollu> okay, so, basically, you get something weird like fromList if you flip a Foldable. So, like, is it interesting?
07:00:33 <frerich> I don't understand how you can 'flip' a Foldable.
07:00:36 <nshepperd> you mean [a] -> t a?
07:00:43 <bollu> nshepperd: yep
07:01:00 <bollu> frerich: I guess "dual" is the right word
07:01:16 <nshepperd> sounds like Unfoldable
07:01:30 <quicksilver> if "[a] -> t a " is natural, it defines a Monoid on (t a)
07:01:36 <estike> what kind of function i can do with this a->b->[(a,b)]?
07:01:41 <quicksilver> where [] gives you mempty
07:01:49 <bollu> quicksilver: oh, nice
07:01:53 <bollu> hm
07:02:05 <quicksilver> or does it?
07:02:09 * quicksilver isn't sure what he said made sense.
07:02:13 <bollu> estike: let f = \a b -> (a, b)
07:02:16 <frerich> bollu: On a totally unrelated note, if you're flipping things you might enjoy the fun difference in types between 'id' and 'flip id'. :-)
07:02:30 <hodapp> :t id
07:02:31 <lambdabot> a -> a
07:02:35 <hodapp> :t (flip id)
07:02:36 <lambdabot> b -> (b -> c) -> c
07:02:41 <bollu> quicksilver: I think it will, you're just constructing a monoid isomorphism with [] == (monoid id), (:) == (<>)
07:02:44 <estike> what it means bollu?
07:03:01 <quicksilver> bollu: but you don't know that [a] -> t a is surjective
07:03:16 <bollu> estike: are you looking for a function that will give you a -> b -> [(a, b)] ?
07:03:18 <quicksilver> bollu: there might well be possible (t a)s that are reach by no input list.
07:03:25 <bollu> estike: then it is easy to write
07:03:40 <bollu> @let zip_into_list = \a b -> [(a, b)]
07:03:42 <lambdabot>  Defined.
07:03:46 <bollu> :t zip_into_list
07:03:48 <lambdabot> t -> t1 -> [(t, t1)]
07:03:54 <bollu> > zip_into_list 1 2
07:03:56 <lambdabot>  [(1,2)]
07:04:00 <bollu> quicksilver: hmm
07:04:14 <bollu> quicksilver: okay, homomorphism?
07:04:27 <nshepperd> bollu: I think it is interesting, for instance there's anamorphism https://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html#t:Unfoldable
07:04:27 <bollu> quicksilver: okay, isomorphism onto the restricted range
07:04:32 <estike> it is easy to write but does anything usefull
07:04:44 <tdammers> unlike Bool -> Integer, a -> b -> [(a,b)] has infinitely many possible solutions
07:04:48 <bollu> estike: that I don't know of.
07:04:52 <estike> i have to write what the function does
07:05:03 <bollu> :t zip
07:05:05 <lambdabot> [a] -> [b] -> [(a, b)]
07:05:08 <bollu> :t (,)
07:05:09 <lambdabot> a -> b -> (a, b)
07:05:15 <bollu> :t []
07:05:16 <lambdabot> [t]
07:05:22 <bollu> :t [] . (,)
07:05:23 <lambdabot>     Couldn't match expected type ‘(b0 -> (a, b0)) -> c’
07:05:24 <lambdabot>                 with actual type ‘[t0]’
07:05:24 <lambdabot>     In the first argument of ‘(.)’, namely ‘[]’
07:05:38 <bollu> oh, right, what am I doing
07:05:43 <bollu> [] isn't a function..
07:05:43 <frerich> tdammers: 'Bool -> Integer' doesn't have infinitely many possible solutions? You could set 'f True = 0' or 'f True = 1' or 'f True = 2' or...
07:05:52 <tdammers> frerich: point in case
07:06:01 <aweinstock> :t ((:[]) .) . (,)
07:06:02 <lambdabot> a1 -> a -> [(a1, a)]
07:06:10 <nshepperd> a -> b -> [(a,b)] actually seems more restricted
07:06:21 <frerich> tdammers: Maybe I misunderstood what you meant by 'unlike' then.
07:06:22 <aweinstock> :t ((:[]) .) . (,) :: a -> b -> [(a,b)]
07:06:23 <lambdabot> a -> b -> [(a, b)]
07:06:29 <nshepperd> because it's polymorphic, it's gotta be 'f a b = replicate n (a,b)' for some n
07:06:42 <bollu> nshepperd: yeah
07:06:48 <bollu> nshepperd: I was going to say that
07:06:49 <tdammers> well, what I mean is that Bool -> Integer has only two possible "shapes" for the function
07:07:18 <tdammers> a -> b -> [(a,b)] can return an empty list, a finite list, or an infinite list
07:07:50 <nshepperd> oh yeah. replicate ∞ (a,b) :p
07:07:54 <bollu> :t (pure :: [a]) . (,)
07:07:55 <lambdabot>     Couldn't match expected type ‘[a2]’ with actual type ‘a0 -> f0 a0’
07:07:55 <lambdabot>     Probable cause: ‘pure’ is applied to too few arguments
07:07:55 <lambdabot>     In the first argument of ‘(.)’, namely ‘(pure :: [a])’
07:07:58 <estike> so it works like length?
07:08:18 <tdammers> I just hadn't realized that picking a length for the list amounts to the same kind of decision as picking an integer to return for the Bool -> Integer case
07:08:23 <aweinstock> bollu: (pure .) . (,)
07:08:24 <delYsid> Could not find module ‘GHC.SrcLoc’, hmmm.
07:08:44 <bollu> aweinstock: ah, right, that always confuses me
07:08:52 <bollu> aweinstock: I still don't grok how that construction works
07:08:59 <aweinstock> also, for lists, pure = (:[])
07:09:00 * frerich notes that in the original paste, the task was to define 'g :: a −> b −> [(b,a)]' -- note that the tuple elements are swapped.
07:09:12 <bollu> oh
07:09:36 <aweinstock> (hence my golfed version with no letters above)
07:09:50 <aweinstock> :t (.)
07:09:52 <lambdabot> (b -> c) -> (a -> b) -> a -> c
07:10:05 <aweinstock> :t (pure .)
07:10:06 <lambdabot> Applicative f => (a -> a1) -> a -> f a1
07:10:08 <bollu> estike: no, I don't think it does anything "interesting" (it simply gives you a list of (b, a), and you're only givn *one* b and *one* a 
07:10:16 <aweinstock> :t ((pure .) .)
07:10:17 <lambdabot> Applicative f => (a -> a1 -> a2) -> a -> a1 -> f a2
07:10:19 <bollu> estike: so you have no choice but to simply repeat it
07:10:23 <bollu> :t (f .)
07:10:25 <lambdabot>     Ambiguous occurrence ‘f’
07:10:25 <lambdabot>     It could refer to either ‘L.f’,
07:10:25 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:152:1
07:10:35 <bollu> :t \x -> (x .)
07:10:36 <lambdabot> (b -> c) -> (a -> b) -> a -> c
07:10:39 <aweinstock> (I don't think I know exactly why it works, just that it does follow that pattern)
07:11:18 <exio4> bollu: :t (.) ;)
07:11:35 <bollu> exi04: (a -> b) -> (b -> c) -> (a -> c) :)
07:11:39 <aweinstock> frerich: ((:[]) .) . flip (,)
07:12:05 <bollu> :t (|>)
07:12:06 <lambdabot> Snoc s s a a => s -> a -> s
07:12:20 <bollu> noo, who took my beloved operator? (
07:12:31 <aweinstock> :t (&)
07:12:32 <lambdabot> a -> (a -> b) -> b
07:12:37 <bollu> fmap (+ .)  [(+), (-)]
07:13:14 <aweinstock> > 5 & (+1) & (+2)
07:13:15 <lambdabot>  8
07:13:30 <bollu> aweinstock: yes, I know
07:13:42 <bollu> but, meh
07:13:46 <bollu> :t (.) . (.)
07:13:47 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
07:14:11 <bollu> I would love to understand it in some other sense than "weirdly specialized fmap"
07:14:22 <aweinstock> :t (.) . (.) . (.) . (.)
07:14:23 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> a3 -> b) -> a -> a1 -> a2 -> a3 -> c
07:14:46 <bollu> aweinstock: yeah, I think of it as "editing the inner layer"
07:14:57 <bollu> aweinstock: in this case, the "layers" are "partially applied functions"
07:14:57 <aweinstock> @where semantic editor combinators
07:14:58 <lambdabot> I know nothing about semantic.
07:15:02 <aweinstock> @where sec
07:15:02 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
07:15:10 <bollu> I read that; it's too...
07:15:11 <bollu> idk
07:15:29 <bollu> It reads like a monologue, and not really a "let me explain this"
07:15:53 <estike> sorry the net went down
07:16:04 <delYsid> I loved the sec post, it was an eye-opener for me
07:16:24 <ggVGc> anyone using Yi as their primary editor?
07:16:29 <estike> i was saying that works like reverse list that a->b->[(b,a)]?
07:16:49 <bollu> estike: yes, if I give you two parameters, you're free to "tuple them up" in any order
07:16:58 <frerich> bollu: To me, that 'owl' operator is just how I compose a two-argument function with a one-argument function. :-]
07:17:27 <bollu> frerich: heh, yeah, I suppose that is one way to think about it
07:17:47 <bollu> frerich: but somehow the layering ideas feels more natural (because it works with all functors)
07:17:49 <estike> what do you mean frerich
07:18:10 <frerich> bollu: Maybe, but I'm more of a mundane guy, ahem.
07:18:24 <bollu> frerich: says the person who knows way more haskell than me :)
07:19:34 <aweinstock> :t \n -> curry (replicate n . uncurry flip)
07:19:36 <lambdabot> Int -> (a -> b -> c) -> b -> [a -> c]
07:19:36 <frerich> bollu: I'm just glad that you cannot see how my eyebrows go north and I say 'huh?' 80% of the time I restore my IRC window and look at #haskell
07:20:26 <bollu> xD
07:21:08 <geekosaur> isn't that true for pretty much everyone who isn't named Simon or Edward? >.>
07:21:09 <aweinstock> :t \n -> curry (replicate n . swap)
07:21:10 <lambdabot> Int -> a -> b -> [(b, a)]
07:21:37 <geekosaur> or Oleg
07:21:48 <aweinstock> estike: ^
07:22:03 <bollu> geekosaur: who's Oleg?
07:22:36 <aweinstock> bollu: http://okmij.org/ftp/
07:22:40 <geekosaur> ^
07:23:01 <bollu> where is the "about" page or something
07:23:26 <estike> what do you mean aweinstock by curry (replicate n, swap)?
07:24:04 <geekosaur> bollu, nobody knows... (has anyone ever seen Oleg Kiselyov in person? maybe he's Skynet)
07:24:10 <bollu> estike: he's just playing with functions, I think. Did you manage to solve your question?
07:24:13 <aweinstock> you were asking about functions of type (a -> b -> [(b, a)])
07:24:49 <bollu> @let layerf = \f -> \_ -> f
07:24:50 <lambdabot>  Defined.
07:24:53 <bollu> :t layerF
07:24:54 <lambdabot>     Not in scope: ‘layerF’
07:24:54 <lambdabot>     Perhaps you meant ‘layerf’ (line 149)
07:24:59 <bollu> :t layerf
07:25:00 <lambdabot> t1 -> t -> t1
07:25:15 <aweinstock> for any integer n, (curry (replicate n . swap)) has type (a -> b -> [(b, a)])
07:25:27 <bollu> @let forcef = f ()
07:25:29 <lambdabot>  .L.hs:150:10:
07:25:30 <lambdabot>      Ambiguous occurrence ‘f’
07:25:30 <lambdabot>      It could refer to either ‘L.f’, defined at .L.hs:154:1
07:25:37 <bollu> @let forcef = \f -> f ()
07:25:38 <lambdabot>  Defined.
07:25:50 <bollu> :t layerf (+)
07:25:51 <lambdabot> Num a => t -> a -> a -> a
07:26:12 <bollu> is layerf + forcef enough to create "thunks" ?
07:26:27 <estike> what curry does ?
07:26:34 <bollu> > (forcef layerf (+)) 1 2
07:26:36 <lambdabot>      Couldn't match type ‘()’ with ‘Integer -> Integer -> t’
07:26:36 <lambdabot>      Expected type: ()
07:26:36 <lambdabot>                     -> (Integer -> Integer -> Integer) -> Integer -> Integer ...
07:26:47 <bollu> > (forcef (layerf (+))) 1 2
07:26:49 <lambdabot>  3
07:26:51 <bollu> cool
07:26:51 <quicksilver> bollu: you don't need to do any tricks ot make thunks in haskell
07:27:01 <quicksilver> bollu: (1+2) is already a thunk
07:27:28 <bollu> quicksilver: hm, yes, but, like, if I were to go to a strict language with haskell features, I was wondering how I could encode thunking
07:27:31 <liste> estike converts functions that take a tuple to functions that take two arguments (in curried form)
07:27:34 <quicksilver> or, to be fair, that's implementation dependent. But it probably is.
07:27:52 <quicksilver> in a strict language the tradition way is f () = (1+2) yes
07:28:01 <bollu> quicksilver: cool :)
07:28:17 <quicksilver> but in haskell there is no differnce between "a" and "() -> a"
07:28:31 <quicksilver> as long we agree to ignore some silly facts about `seq` and `undefined`
07:28:36 <estike> but if i do a :t zip 3 5 = it gives me the same way
07:28:45 <bollu> > zip 3 5
07:28:47 <lambdabot>      No instance for (Show a0)
07:28:47 <lambdabot>        arising from a use of ‘show_M8736652855004499445642’
07:28:47 <lambdabot>      The type variable ‘a0’ is ambiguous
07:28:53 <bollu> :t zip 3 5
07:28:54 <lambdabot> (Num [a], Num [b]) => [(a, b)]
07:28:58 <quicksilver> > zip [3] [5]
07:28:59 <lambdabot>  [(3,5)]
07:29:08 <bollu> quicksilver: right, sorry
07:29:24 <bollu> estike: yes, but you want (5, 3) (i.e, the parameters to be reversed)
07:29:26 <estike> so if i do a reverse(zip(3 5))
07:29:30 <bollu> estike: and it should work for any type
07:29:37 <bollu> estike: try it :)
07:30:51 <estike> i cannot do reverse(zip 3 5)?
07:32:43 <tdammers> :t reverse
07:32:44 <lambdabot> [a] -> [a]
07:32:48 <tdammers> :t (2, 3)
07:32:50 <lambdabot> (Num t, Num t1) => (t, t1)
07:33:02 <tdammers> so basically, no, you can't call reverse on a tuple
07:33:10 <Shockk> if I'm forking a cabal package, do I need to specify the original author in both the Author and Copyright fields of the cabal file or only the Copyright field?
07:34:08 <clrnd> Shockk, i'd put my name in Author, and both in Copyright, but I can't even spell "law"
07:34:09 <aweinstock> tdammers: does lens have some kind of generalized reverse that does work on tuples?
07:34:25 <estike> but i can do a snd and fst and zip 
07:34:31 <Shockk> clrnd: that's what I was thinking myself but I needed a second opinion; thanks
07:34:36 <tdammers> :t fst
07:34:37 <lambdabot> (a, b) -> a
07:34:53 <tdammers> so, yes, but only for 2-tuples (i.e., pairs)
07:34:58 <holymac> I have an AST how do I create bindings from my pseudolanguage to JavaScript?
07:35:07 <aweinstock> :t \x y -> [(y, x)]
07:35:07 <tdammers> note that (a, a) and (a, a, a) are completely separate types
07:35:08 <lambdabot> t1 -> t -> [(t, t1)]
07:35:13 <tdammers> as for zip:
07:35:16 <tdammers> :t zip
07:35:17 <lambdabot> [a] -> [b] -> [(a, b)]
07:35:29 <aweinstock> :t \x y -> zip [y] [x]
07:35:30 <lambdabot> b -> a -> [(a, b)]
07:35:55 <tdammers> zip takes two lists and combines them into a list of tuples
07:36:02 <aweinstock> :t curry (replicate 1 . swap)
07:36:03 <tdammers> so you can't call that on a tuple either
07:36:04 <lambdabot> a -> b -> [(b, a)]
07:36:48 <estike> cannot scope swap why?
07:37:13 <frerich> estike: It's in "Data.Tuple"
07:37:37 <estike> how i can acesse that library?
07:37:39 <estike> acess
07:37:54 <aweinstock> estike: put "import Data.Tuple" at the top of the file
07:38:27 <clrnd> holymac, you want to compile your language to JS?
07:38:37 <holymac> Yea
07:39:27 <merijn> Shockk: When forking packages I usually put both my and original author in fields and add time frames
07:39:50 <merijn> Shockk: Also, did you consider asking the old maintainer whether you could become maintainer if they're not updating the original package?
07:40:31 <Shockk> merijn: the reason I'm forking is to basically break most of the API to make it more consistent
07:40:42 <Shockk> but nevertheless it'd break most of the API
07:42:04 <Shockk> forking is probably the better thing for me to do so I can apply my own ideology to the project without it affecting the existing one
07:43:44 <holymac> clrnd  I saw a lecture of Phil Trelford who did it using F#
07:44:13 <quicksilver> oh that's where swap is
07:44:20 <quicksilver> I couldn't find it and wrote it myself again :)
07:44:23 <quicksilver> ah well it's not hard to write.
07:45:04 <zaquest> quicksilver, Data.Tuple seems weird to me, everything from it is in prelude, except swap :D
07:45:56 <clrnd> holymac, cool, do you have a specific quesiton then?
07:46:16 <estike> the only fuction i could do was  : g x y = [(y,x)]
07:46:28 <estike> but dont do nothing :p
07:46:30 <holymac> How do I convert pseudo code to JavaScript?
07:48:01 <estike> the only thing that does it takes two values and make a pair 
07:48:26 <aweinstock> holymac: by converting your pseudocode to lambda calculus, then using an LC -> JS compiler :)
07:48:46 <aweinstock> estike: that's correct
07:48:52 <kqr> estike, that's a solution though
07:49:03 <estike> i think so 
07:49:04 <kqr> estike, it's the one I would give too
07:49:18 <holymac> aweinstock what's an LC?
07:49:25 <clrnd> lambda calculus
07:49:57 <clrnd> honestly though, how do most js-transpilers work? do they build JS-AST or just output strings?
07:50:05 <merijn> s/transpilers/compilers
07:50:10 <aweinstock> holymac: I was attempting to make a joke by suggesting a somewhat overkill solution
07:50:12 <quicksilver> estike: try g x y = [(y,x),(y,x)]
07:50:31 <estike> the other it´s say  Ord t =>[t] −> t −> Bool so i input a list then i choose a element of the list then i compare with something that gives me a boolean
07:50:57 <aweinstock> holymac: what do you mean by pseudocode? the process of converting pseudocode to code is programming, we don't have AI that does that yet
07:51:01 <estike> what is the difference quicksilver?
07:51:45 <aweinstock> holymac: (if you have a specific format in mind for your pseudocode, you can make it "real code" by writing a compiler/interpreter for it)
07:51:52 <estike> it gives me error
07:52:22 <kqr> estike, it should not give you an error
07:52:22 <estike> i forgot the , between the tuples
07:52:41 <aweinstock> > let {f x y = [(y,x)]; g x y = [(y,x),(y,x)]} in (f 1 2, g 3 4)
07:52:43 <lambdabot>  ([(2,1)],[(4,3),(4,3)])
07:53:08 <quicksilver> estike: it was just another example of the kind of thing you could do
07:53:12 <quicksilver> estike: (and have the type you asked for)
07:53:24 <aweinstock> estike: do you see the general pattern? and why both f and g have type (a -> b -> [(b, a)])?
07:53:58 <estike> yes i see that 
07:54:15 <aweinstock> what else has type (a -> b -> [(b,a)])?
07:57:04 <estike> ithat exemple that you gave aweinstock how could i concat to give [(2,1)][(4,3),(4,3)] ?
07:58:33 <aweinstock> > let {f x y = [(y,x)]; g x y = [(y,x),(y,x)]} in f 1 2 ++ g 3 4
07:58:35 <lambdabot>  [(2,1),(4,3),(4,3)]
07:58:44 <aweinstock> :t (++)
07:58:45 <lambdabot> [a] -> [a] -> [a]
07:59:01 <kqr> or
07:59:02 <aweinstock> (++) concatenates a pair of lists
07:59:08 <kqr> concat [f 1 2, g 3 4]
07:59:43 <kqr> concat takes nested lists and flattens them
07:59:45 <kqr> one level
08:00:27 <carrotlord> > ['a','b'] ++ ['c','d']
08:00:29 <lambdabot>  "abcd"
08:04:22 <nobos> anyone here has any experience with Options.Applicative & subparsers with multiple options?
08:05:09 <nobos> (for command line parsing)
08:14:54 <nobos> I figured out a way, but it is not pretty: (\x y -> MkUser $ UserPassOptions x y) <$> a <*> b
08:15:09 <nobos> is there a better way to express this?
08:15:24 <merijn> nobos: I'd define a local function for it
08:15:43 <nobos> good tip
08:15:49 <nobos> merijn: ^^
08:16:34 <quicksilver> nobos: it's a bit ugly
08:16:37 <zaquest> (MkUser . UserPassOptions) <$> a <*> b should be the same
08:16:43 <quicksilver> nope, zaquest 
08:16:49 <quicksilver> because there are two parameters
08:16:50 <quicksilver> it's 
08:16:58 <zaquest> oh, right
08:17:01 <quicksilver> ((MkUser .) . UserPassOptions) <$> a <*> b
08:17:01 <nobos> quicksilver: that's what I experienced as well
08:17:12 <quicksilver> which is.. either ugly, or just something you get used to
08:17:21 <quicksilver> but not easy to generalise to 3 parameters etc
08:17:32 <quicksilver> @pl \x y -> f (g x y)
08:17:32 <lambdabot> (f .) . g
08:17:40 <quicksilver> @pl \x y z -> f (g x y z)
08:17:40 <lambdabot> ((f .) .) . g
08:18:03 <Hafydd> MkUser <$> (UserPassOptions <$> a <*> b)
08:18:35 <quicksilver> oh that's clever hafydd
08:20:06 <nobos> Hafydd: nice, but my Haskell skills are a bit meh, so I think I'll just opt for a "where mkuserpass x y = MkUser $ UserPassOptions x y
08:20:28 <quicksilver> this is a typical issue with applicative-style I find
08:20:35 <quicksilver> you write a lot of
08:20:56 <quicksilver> (\a b c -> ... something involving a b c ...) <$> x <*> y <*> z
08:21:47 <merijn> But ApplicativeDo soon :D
08:23:14 <quicksilver> yeah I'm not sure I think that's 100 times better really
08:23:52 <geekosaur> so when are you adding idiom brackets?
08:23:54 <quicksilver> but it does put the name local to the effect
08:23:56 <geekosaur> :p
08:39:31 <mutantmell> That's where I find liftA* to be useful
08:42:56 * hackagebot patches-vector 0.1.1.0 - Patches (diffs) on vectors: composable, mergeable, and invertible.  https://hackage.haskell.org/package/patches-vector-0.1.1.0 (LiamOConnorDavis)
08:50:37 <emmanuel_erc> hello everyone!
08:51:22 <haskell777> hi guys
08:51:35 <haskell777> whats wrogn with this code
08:51:37 <haskell777> http://pastebin.com/beQEBHQP
08:51:40 <haskell777> :(
08:51:42 <haskell777> idk
08:53:07 <haskell777> can help me pls :(
08:53:58 <pavonia> haskell777: What do you expect the _ on the right-hand side to do?
08:54:34 <haskell777> any list
08:54:38 <Rembane> I find string-formatting awkward in Haskell, have I missed out on some really nice way of doing it?
08:55:03 <ss_> @pl: \li -> (head li, length li)
08:55:04 <lambdabot> liftM2 (,) head length
08:55:05 <pavonia> haskell777: Use "undefined" instead then
08:55:17 <haskell777> how can i do that 
08:55:24 <nolrai66> There's the PrintF template haskell library, but I've never used it.
08:55:53 <pavonia> haskell777: Well, put "undefined" literally into your code
08:55:57 <pavonia> :t undefined
08:55:59 <lambdabot> t
08:56:06 <pavonia> :t undefined :: [a]
08:56:07 <lambdabot> [a]
08:56:43 <Jaume> I would do rotaN 0 x = x
08:56:46 <haskell777> pavonia: undefined instead of ... _ ?
08:57:06 <pavonia> Yes
08:57:08 <glguy> haskell777: The first case would probably be:   rotaN 0 xs = xs
08:57:08 <Jaume> I guess you don't want to rotate if there is a 0. So just be like the identity in this case
08:57:39 <Myrl> Hmm...
08:57:43 <glguy> haskell777: _ isn't a name that you can use like the other names, it means "I don't care"
08:57:46 <Rembane> nolrai66: Thank you.
08:57:51 <haskell777> glguy: thats right
08:58:05 <glguy> so you can't use it as a value on the right-hand side of your definition
08:58:41 <haskell777> glguy: ok...i got it 
08:58:54 <haskell777> glguy: ty
09:00:11 <ss_> @pl:\v c -> if null v then c else min c $ minimum v
09:00:12 <lambdabot> Unknown command, try @list
09:00:21 <chpatrick> @hackage formatting -- rembane
09:00:21 <lambdabot> http://hackage.haskell.org/package/formatting -- rembane
09:00:24 <kras> Hi how do I convert an Integer type to another?
09:00:25 <ss_> @pl: \v c -> if null v then c else min c $ minimum v
09:00:25 <lambdabot> ap (ap . if' . null) (min . minimum)
09:00:36 <byorgey> kras: fromIntegral
09:00:38 <ss_> @pl: :t ap
09:00:39 <lambdabot> (line 1, column 1):
09:00:39 <lambdabot> unexpected ":"
09:00:39 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
09:00:54 <byorgey> ss_: just @pl , not @pl:
09:01:21 <kras> byorgey: awesome, thanks
09:01:28 <byorgey> oh, I guess @pl: works since lambdabot does spell correction on commands =)
09:01:35 <byorgey> @snack
09:01:35 <lambdabot> go slap  yourself
09:01:42 <byorgey> @botsnack
09:01:43 <lambdabot> :)
09:02:37 <breadmonster> @pl 3 
09:02:38 <lambdabot> 3
09:07:07 <Rembane> chpatrick: Thank you! That looks promising!
09:09:05 <kras> Hi, I am taking cis194 course, any good reference to compare my solutions against?
09:17:08 <dtscode> ghci> map (\l@(x:xs) -> (x,length l)) . group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7] -- <- I get what . and $ do, but why is it sort $ [the_list] instead of $ sort [the_list]
09:18:06 <geekosaur> dtscode, then you don;t get what $ does really
09:18:44 <bennofs> dtscode: both do the same
09:18:54 <dtscode> f $ y z is the same as f (y z) right ?
09:18:56 <dave345> discoed, because you are composing the functions and then giving the argument to the new larger function.
09:19:15 <dtscode> hrmmm ok
09:19:19 <geekosaur> dtscode: you've only looked at half of it
09:19:34 <geekosaur> consider f g $ y z
09:19:40 <dave345> you are not composing group with a sorted list but rather with sort. The the composition takes the list
09:20:33 <geekosaur> perhaps more clearly: f g $ y
09:22:57 * hackagebot inline-r 0.7.1.1 - Seamlessly call R from Haskell and vice versa. No FFI required.  https://hackage.haskell.org/package/inline-r-0.7.1.1 (MathieuBoespflug)
09:27:57 * hackagebot inline-r 0.7.1.2 - Seamlessly call R from Haskell and vice versa. No FFI required.  https://hackage.haskell.org/package/inline-r-0.7.1.2 (MathieuBoespflug)
09:52:55 <SK0> Is there a guide on when to INLINE functions?
09:55:27 <dave345> SK0, generally you inline functions that are short but called often so you don't waste time on calling the function all the time
09:56:13 <ggVGc> generally the compiler should figure that out
09:56:17 <dave345> IMO, in haskell just don't bother. If you need speed to the point where inlines make a difference use C.
09:56:37 <ggVGc> I had no idea GHC had an inline hint
09:56:49 <ggVGc> or haskell in general
09:56:55 <dave345> its not standard
09:57:08 <dave345> *I think
09:58:09 <breadmonster> ggVGc: It does, it's how the run fusion.
09:59:04 <michel71> hello all. ive been informed that people in this IRC are the most l33t hackers. hence, im wondering if anyone can help me with a problem im having.
09:59:24 <dave345> *1337 I fixed your problem
09:59:30 <monochrom> do not believe hearsay
09:59:40 <mmachenry> michel71: We're the most 1337 Haskell hackers.
09:59:57 <mmachenry> michel71: If your problem has to do with Haskell we can likely help.
10:00:10 <monochrom> did you know: 31337 is a prime number
10:00:50 <tsahyt> Unfortunately, 1337 isn't.
10:00:55 <tsahyt> 1337 = 7 * 191
10:01:12 <drmoob> but 13 and 37 is, spooky
10:02:53 <tsahyt> I wish zsh had fuzzy matching
10:07:59 * hackagebot psc-ide 0.3.0.0 - Language support for the PureScript programming language  https://hackage.haskell.org/package/psc-ide-0.3.0.0 (kritzcreek)
10:09:55 <drmoob> trying to do some dynamic programming, consider this snippet http://lpaste.net/5868279907481550848 where I have added "comp" as a lookup, but since I need random access between 0 and 8388608 it is slow, but what could I do? In imperative language I would just send along a map as a reference and update/read from that
10:10:13 <drmoob> states are just integers
10:11:13 <chpatrick> drmoob: does constructN do what you want?
10:11:14 <chpatrick> :t constructN
10:11:15 <lambdabot> Not in scope: ‘constructN’
10:11:36 <pikajude> we'll never know
10:11:41 <chpatrick> drmoob: https://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Unboxed.html#v:constructN
10:12:27 <opqdonut> drmoob: your definition of comp should use findOpt to really benefit from the memoization
10:12:34 <drmoob> I forgot to add, I can only use the "standard library"
10:12:39 <chpatrick> why is that?
10:12:55 <drmoob> I am submitting it to an online judge for solving a problem, it only has that
10:13:00 <chpatrick> ah that's a bummer
10:13:04 <chpatrick> standard arrays are pretty janky
10:13:09 <chpatrick> people use vector these days
10:13:14 <drmoob> I already solved it in C++ but I wanted to try Haskell for fun
10:13:19 <pikajude> vector is in the stdlib
10:13:25 * geekosaur would suspect it's not the array so much as the lists / list comprehension, really
10:13:37 <chpatrick> pikajude: it's not in base
10:13:38 <opqdonut> drmoob: now you define the array in terms of findOpt', which is the unmemoized version. do you see what I'm saying?
10:13:46 <pikajude> chpatrick: but it's in any GHC installation
10:13:48 <geekosaur> array isn;t in base either :)
10:14:05 <drmoob> well I am still a beginner so I might use the terminology wrong
10:14:10 <chpatrick> maybe you have vector then drmoob?
10:14:38 <chpatrick> constructN is nice because it doesn't rely on knot tying or anything
10:14:51 <drmoob> I will have a look
10:15:03 <drmoob> I did not have it on my local install so I assumed the judge do not have it either
10:16:07 <drmoob> https://open.kattis.com/documentation/techinfo "Haskell" it is all I know
10:18:58 <Pro9> I need some advice at what i should look at if I want to randomly generate a variable: 90% chance that 0 is generated, 10% chance that a value between 1-9 is generated
10:20:04 <Pro9> I know that I can generate a number between 1-100, and if its <90= 0, 91=1 etc., but maybe there's a better way
10:20:49 <andirc8089-> Я тебя люблю, Вов
10:21:11 <SK0> what qualifies as a short function? And what is meant by called often? Is it "called often" when it's used to map over a list/array?
10:21:54 <SK0> questions regard INLINE
10:22:53 <johnw> Pro9: 0-89=0,91-99=n`mod`100
10:23:14 <mniip> Pro9, do x <- randomR (1, 10); case x of 1 -> randomR (1, 9); _ -> return 0
10:23:21 <mniip> because monads be monads
10:23:23 <bennofs> SK0: if you haven't profiled your code, don't manually add INLINE. GHC should figure this out on its own most of the time
10:23:59 <Pro9> Thank you
10:24:01 <chpatrick> mniip: I don't think that will work
10:24:01 <ReinH> Pro9: also http://hackage.haskell.org/package/MonadRandom-0.1.3/docs/Control-Monad-Random.html#v%3afromList
10:24:09 <chpatrick> you'll need
10:24:14 <chpatrick> :t state (randomR (1, 10))
10:24:15 <lambdabot> (Num a, MonadState s m, RandomGen s, Random a) => m a
10:24:27 <nolrai66> @hoogle Int -> m () -> m ()
10:24:27 <lambdabot> Graphics.UI.GLUT.Callbacks.Global addTimerCallback :: Timeout -> TimerCallback -> IO ()
10:24:27 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
10:24:27 <lambdabot> System.Mem.Weak addFinalizer :: key -> IO () -> IO ()
10:25:34 <mniip> chpatrick, I meant in a generic kind of randomness monad
10:25:40 <mniip> could be IO or State RandomGen
10:30:18 <ReinH> MonadRandom
10:31:04 <mniip> is there a monad capable of remotely stabbing people in the face
10:31:24 * Clint nods.
10:31:44 <exio4> that'd be a lens monad
10:31:53 <hodapp> StabT?
10:32:22 <Hafydd> Yes, there's a Setter s t a b.
10:32:52 <rcrc> so given types:
10:32:57 <rcrc> data D (s :: Symbol) = D
10:33:02 <rcrc> data X = forall s. X (D s)
10:33:10 <rcrc> can I define a Y such that I can write
10:33:14 <SK0> bennofs, clear, thanks
10:33:15 <rcrc> D :: Y "foo"
10:33:16 <rcrc> ?
10:33:34 <SK0> I see library authors do it all the time though
10:33:46 <exio4> type Y = D
10:34:04 <rcrc> oops, sorry
10:34:08 <rcrc> X :: Y "foo"
10:35:49 <bennofs> SK0: well, some authors do add INLINE and know what they are doing. But as long as you don't understand the details, I wouldn't add INLINE manually. One case where INLINE is useful is if you know that inlining will allow further optimization at the call site. For example, if you write a function that chains some vector functions, inlining it may allow stream fusion to happen when the function is called
10:35:51 <bennofs> (stream fusion needs inlining because GHC needs to "see" the whole chain. If there's a blackbox Vector -> Vector function in the chain, GHC can't know how to fuse it )
10:36:02 <bollu> does anyone know why spotlight doesn't show spacemacs?
10:36:35 <ReinH> bollu: how did you install it?
10:36:56 <bollu> ReinH: using homebrew
10:37:09 <bollu> ReinH: I can manually go and run it from Application
10:37:12 <bollu> Applications*
10:37:27 <bollu> mission control shows it as well
10:37:27 <ReinH> Oh, it uses a symlink and apparently spotlight doesn't index those
10:37:32 <bollu> :( bummer
10:37:37 <bennofs> SK0: but I think in most cases, unless you are writing extremely high performance code (then you will need to benchmark and look at Core anyway), not adding INLINE pragmas won't have too much runtime effect
10:37:37 <ReinH> you can replace the symlink with a cp -R
10:38:21 <bollu> ReinH: will it break future updates?
10:40:06 <rcrc> in other words, is there a way that I can write "function application" at the type level? e.g. something like "data Z = Z Int ; foo = Z 5 :: (Int -> Z)(Int)"?
10:41:17 <ReinH> bollu: no, updates happen in ~/.emacs.d
10:42:32 <bollu> ReinH: no, I meant when I "brew update" the next time
10:42:39 <bollu> ReinH: that will be an update of emacs, not spacemacs
10:43:09 <glguy> It seems pretty likely that copying emacs out of the homebrew managed location would stop homebrew from updating it in /applications
10:43:19 <glguy> also this is a little beyond topic
10:44:18 <ReinH> bollu: oh, yes, you'll need to copy it again
10:44:40 <kras> Hi, I need to remember the index of the element in the list so I pass around a variable called "pos" incrementing it on every recursive call 
10:44:53 <kras> is there a better way to do this?
10:44:55 <ReinH> but, on the other hand, spotlight will find it
10:45:07 <srhb> kras: It's ok, or you could just zip the list with its indices.
10:45:55 <ReinH> kras: what are you doing?
10:47:26 <kras> http://codepad.org/aS7P5pJr
10:48:20 <kras> In the showHelper here I use the pos variable to remeber the index, just wondering if this is idiomatic Haskell
10:48:27 <kras> http://codepad.org/aS7P5pJr
10:48:45 <kras> or is there any better way to do this
10:49:10 <rcrc> anyone? ^^
10:50:22 <nolrai66> What was your question rcrc?
10:52:24 <hiptobecubic> kras, your solution for the problem of remembering an index looks ok, but the idea that you need to do that here is probably misguided.
10:53:17 <hiptobecubic> kras, this seems like it should be done with a call to map and intercalate followed by "unwords" or something
10:53:33 <rcrc> nolrai66: my immediate question is, is it possible to write "function application" in the type level?
10:54:02 <rcrc> e.g. given "data D = D Int", can I write something like "D 5 :: (Int -> D)(Int)"?
10:54:28 <opqdonut> rcrc: you can write "(D :: Int -> D) (5 :: Int)"
10:55:21 <opqdonut> with some extensions, you could perhaps define a type family Apply such that Apply (Int -> D) Int = D
10:55:40 <opqdonut> but even with that you couldn't enforce that the expression actually is a function application
10:55:52 <rcrc> the larger question/puzzle is, given "data D a = D" and "data X = forall x. X (D a)", is it possible for me to write "D :: Y Int"
10:56:25 <johnw> type Y = D
10:56:27 <johnw> you asked that one before
10:56:46 <rcrc> derp i'm norry, i meant "X :: Y Int"
10:56:49 <rcrc> *sorry
10:58:06 <monochrom> what is Y?
10:58:20 <rcrc> anything, but I'm imagining a type alias
10:58:49 <monochrom> no
10:58:51 <rcrc> but the thing you'd end up with is a value of "X (D :: D Int)"
10:59:10 <rcrc> oh, that sucks
10:59:43 <monochrom> the type of X (D :: D Int) is X.
11:00:20 <monochrom> I don't know what the hell is Y. and "anything" is a wrong answer.
11:00:55 <monochrom> you simply can't go around wanting "is 'True :: ZZZ' legal? ZZZ could be anything". wrong concept.
11:01:02 <rcrc> what I'd like to be able to express is that it's an "X" that "came from a "D Int"
11:01:40 <rcrc> no, i'm sorry -- what I meant was, is there a "Y" such that I can write that expression?
11:01:48 <rcrc> not "Y may be some arbitrary thing"
11:01:54 <nolrai66> I think the awnser is /no/, to the extent that your question makes sense.
11:02:17 <monochrom> Then use D for Y. D :: D Int.
11:02:17 <nolrai66> Also I posted a comment to your paste.
11:03:21 <rcrc> monochrom: that was a typo. what I was looking for is "X :: Y Int", for some Y
11:03:35 <rcrc> should I back up and explain what I'm looking for more?
11:03:40 <rcrc> (motivation?)
11:03:40 <monochrom> that cannot be done.
11:04:27 <geekosaur> rcrc, I think you'll have to
11:04:27 <monochrom> the type of X is D a -> X.
11:04:37 <geekosaur> I can't make any sense of what you are asking for tbh
11:06:03 <rcrc> ok, lpaste-ing
11:08:17 <dimitri-xyz> Anyone else having problems with the Haskell Platform on the latest "El Captain" OSX version?
11:08:30 <monochrom> yes, there is a haskell-cafe post on this
11:08:44 <dimitri-xyz> I tried to fix issues by running the script here  https://github.com/mzero/haskell-platform/blob/master/hptool/os-extras/osx/bin/activate-hs but apparently, that not's working either
11:08:58 <dimitri-xyz> (this was suggested on haskell-cafe)
11:09:01 <monochrom> in fact, a post from the Haskell Platform people saying they have a candidate installer for El Captain
11:09:18 <dimitri-xyz> there's some permission issues creating the symlinks
11:09:22 <geekosaur> yes, you need to use the new installer candidate
11:09:39 <dimitri-xyz> So, the fix is uninstall and reinstall?
11:10:07 <geekosaur> uninstall that one, install the candidate
11:10:22 <dimitri-xyz> Thanks :-)
11:10:47 <geekosaur> http://downloads.haskell.org/~platform/7.10.2/Haskell%20Platform%207.10.2-a1%2064bit-unsigned.pkg
11:11:16 <obihann> A little while ago I did a functional programming presetation at my office (web shop) and I'm planning a follow up, I'm using haskell as my language of choice and I was wondering if I could reach out to somebody and get some stickers or swag to give at the talk, or if that is too big a request just a sticker or two to put on my macbook and show off my coolness
11:11:29 <obihann> wasn't sure who to reach out to though, you guys seems like a good starting place
11:13:01 * hackagebot combinat 0.2.7.2 - Generate and manipulate various combinatorial objects.  https://hackage.haskell.org/package/combinat-0.2.7.2 (BalazsKomuves)
11:13:17 <srhb> Someone did some lambda stickers a while back. Afraid I can't remember who.
11:13:25 <hiptobecubic> Dan clien? or something
11:13:27 <hiptobecubic> I have one
11:13:29 <hiptobecubic> it's nice
11:13:34 <hiptobecubic> let me find the link
11:13:50 <radix> obihann: I see http://www.unixstickers.com/stickers/coding_stickers/haskell-programming-language-shaped-sticker and http://www.cafepress.com/twhask after a quick google
11:14:15 <monochrom> yes, the  λ= haskell sticker exists. edwardk gave out some when visiting the Toronto haskell meetup. he probably knows where to get more.
11:14:47 <radix> in fact there are lots of different sites selling them
11:14:51 <bitemyapp> I think I have some still.
11:14:54 <obihann> radix: oh but that means spending money! lmao
11:14:57 <hiptobecubic> lien, not clien :)  https://www.stickermule.com/marketplace/3377-haskell-logo
11:15:01 <bitemyapp> not exactly sure where they are.
11:15:03 <srhb> What, were you expecting free? :P
11:15:20 <monochrom> I support spending money
11:15:21 <obihann> haha no
11:15:28 <obihann> yah, of coruse man, of course
11:15:34 <obihann> I do really like the unixsticker ones
11:15:49 <obihann> does the community get any form of a kickback from them? or is it just awareness
11:16:08 <hiptobecubic> I prefer the rounded look on sticker mule personally
11:16:18 <obihann> yah that sticker mule one is pretty sweet
11:16:29 <ReinH> hiptobecubic: ooh I have the uncolored one. That one's nice.
11:16:59 <monochrom> oh, I see, $1.79 is not a good deal
11:17:22 <obihann> no actually its really good
11:17:39 <obihann> and probably little to nothing on shipping cause they probably go in an envelope lol
11:18:53 <monochrom> I see, $1.79 is already the minimum on the whole market.
11:20:20 <tommd> edwardk: WRT Numeric.AD.gradientDescent I find it frustrating to convert f :: [Rational] -> Rational into g :: forall s. Reifies s Tape => [Reverse s a] -> Reverse s a
11:20:48 <tommd> edwardk: Am I not supposed to have to?  It seems I can not directly leverage `f` as is, but perhaps I am doing it wrong.
11:22:29 <rcrc> geekosaur monochrom opqdonut : pasted my question: http://lpaste.net/142087
11:22:30 <bollu> On what do you guys stick your stickers?
11:22:30 <hiptobecubic> ReinH, obihann I like it :)  https://en.gravatar.com/userimage/9064627/7192675b87cb5fa851b49581624b0a3d.jpg?size=480
11:22:59 <bollu> oh, on the laptop? xD I was thinking the fridge
11:23:00 <clrnd> dogs, horses
11:23:07 <clrnd> tv too
11:23:46 <bollu> I miss my desktop compute now. That would have look rad on the  tower 
11:24:32 <johnw> passing airplanes
11:25:59 <monochrom> rcrc: D <> L "hi" is a contradiction. D's type is D ???.  L "hi" 's type is X. there is no way D ??? and X can reconcile.
11:26:32 <geekosaur> rcrc, can't be done. :: is not a cast operator, and D has type D something
11:26:55 <monochrom> it is analogous to "hello" <> EQ
11:28:09 <mniip> monochrom, that's EQ!
11:28:43 <rcrc> oh god I keep doing that, that's a typo -- one second
11:28:45 <rcrc> i apologize
11:29:04 <mniip> (because : is the second constructor and so is EQ, and therefore if the typechecker somehow let that slip thorough, that's what the <> operator would've returned)
11:29:21 <rcrc> ok fixed -- the thing I want to be able to write is "(S :: Y "hi") <> L "hi""
11:29:28 <rcrc> not "(D :: ..."
11:29:37 <rcrc> monochrom geekosaur ^^
11:30:47 <monochrom> S <> L "hi" is still a contradiction. S's type is KnownSymbol s => D s -> X.  This is not reconcilable with X.
11:31:18 <monochrom> it is now analogous to Just <> "hello"
11:31:28 <geekosaur> still the same issue that :: is not a cast operator
11:31:36 <bollu> :t mempty
11:31:37 <lambdabot> Monoid a => a
11:31:44 <bollu> mempty :: Ord
11:31:45 <monochrom> or maybe Just <> Nothing
11:31:47 <geekosaur> :: is an annotation: "this thing may have multiple types, and this is the specific type I wish to use it at"
11:31:54 <bollu> :t Orf
11:31:55 <rcrc> i see, you're right
11:31:55 <lambdabot> Not in scope: data constructor ‘Orf’
11:31:57 <bollu> :t Ord
11:31:59 <lambdabot>     Not in scope: data constructor ‘Ord’
11:31:59 <lambdabot>     Perhaps you meant variable ‘ord’ (imported from Data.Char)
11:31:59 <geekosaur> it does not, ever, mean "convert this thing to some other type"
11:32:04 <bollu> :t LT
11:32:05 <lambdabot> Ordering
11:32:13 <bollu> >mempty :: Ordering
11:32:19 <rcrc> geekosaur: right, that was just a lapse in thinking on my part
11:32:20 <bollu> > mempty :: Ordering
11:32:21 <lambdabot>  EQ
11:32:22 <drmoob> chpatrick: actually vector was supported, however I am not sure constructN is the right choice since it is not really a sequence and I do not know the number of computations I need, see it more like a tree and I want to prune the tree by looking in my "map" for already seen values. Or perhaps I missunderstood?
11:32:35 <bollu> how is that a valid monoid instance?
11:32:37 <bollu> I don't get it
11:32:42 <bollu> there is no "concatenation" happening
11:32:46 <rcrc> can I instead write `(y :: Y "hi") <> L "hi"`?
11:32:53 <mniip> bollu, what do monoids have to do with concatenation
11:32:55 <clrnd> ordered some purple ones, neat
11:33:03 <clrnd> shiping is $6 though here
11:33:16 <mniip> bollu, integers are a monoid under addition, where's the concatenation there?
11:34:08 <geekosaur> bollu, it's "combination" not "concatenation". what counts as "combination" is up to the instance. there is no requirement that it be reversible
11:34:15 <clrnd> > mconcat [Just 5, Just 6, Just 7]
11:34:17 <lambdabot>      No instance for (Show a0)
11:34:17 <lambdabot>        arising from a use of ‘show_M37832685637817533749429’
11:34:17 <lambdabot>      The type variable ‘a0’ is ambiguous
11:34:26 <clrnd> :t mconcat
11:34:27 <lambdabot> Monoid a => [a] -> a
11:34:43 <clrnd> > mconcat [Just 5, Just 6, Just 7] :: Maybe Int
11:34:45 <lambdabot>      No instance for (Monoid Int) arising from a use of ‘mconcat’
11:34:45 <lambdabot>      In the expression: mconcat [Just 5, Just 6, Just 7] :: Maybe Int
11:34:48 <bollu> geekosaur: I somehow don't trust that monoid because I can't intuitively see the associativity of (<>)
11:34:50 <clrnd> whatevs
11:35:05 <bollu> but the I clearly know that (+) on Integers are associativ
11:35:41 <mniip> @check \a b c -> a <> (b <> c) == (a <> b) <> (c :: Ordering)
11:35:42 <lambdabot>  +++ OK, passed 100 tests.
11:35:49 <bollu> hahaha
11:36:05 <rcrc> bollu: it's associative because it's basically just a show before an mappend on strings
11:36:06 <kras> I have a func with type signature, timesHelper :: a1 -> [a1] -> [a1] -> [[a1]]
11:36:09 <rcrc> so it's as associative as string mappend is
11:36:21 <kras> Inside I am using take i (repeat 0)
11:36:40 <mniip> :t replicate
11:36:41 <lambdabot> Int -> a -> [a]
11:36:43 <kras> GHCi complains "Couldn't match expected type ‘Int’ with actual type ‘a1’"
11:37:10 <mniip> kras, what's "i"
11:37:10 <kras> I guess "i" in take i is an int
11:37:42 <monochrom> rcrc: L "hi" has type X. you are confined to (???::X) <> L "hi". you have no other choice. (ok, there is another choice: don't write anything)
11:37:54 <clrnd> > mconcat [Just "b", Just "c", Just "a"]
11:37:56 <lambdabot>  Just "bca"
11:38:17 <clrnd> :t take
11:38:18 <lambdabot> Int -> [a] -> [a]
11:38:28 <kras> http://codepad.org/YQFELaTv
11:39:03 <mniip> bollu, the idea of an Ordering monoid is that
11:39:08 <bollu> mniip: yes?
11:39:22 <mniip> compare (a, b, c) (d, e, f) = compare a d <> compare b e <> compare c f
11:40:09 <monochrom> yeah, lexicographical ordering is the intuition of Ordering's monoid instance
11:40:13 <mniip> also thanks to the implementation detail of that instance, 'compare b e' is only evaluated if 'compare a d' returned EQ
11:40:27 <rcrc> monochrom: I was hoping that, if I could annotate "how we arrive at X", then I can specify the D
11:40:54 <kras> mniip: http://codepad.org/YQFELaTv
11:41:08 <rcrc> e.g. I could say that " it's an X, but specifically it's the result of aplpying S to "D :: D "foo""
11:41:21 <rcrc> which would specify the type of the inner value
11:42:02 <monochrom> ok, how do you say "applying S to D :: D "foo"" in code?
11:42:06 <rcrc> in the way that on the value level I can write e.g. "(show :: Int -> String) 5"
11:42:20 <monochrom> you have to write "S (D :: D "foo")", right?
11:42:30 <rcrc> monochrom: I don't know but it would be awesome if I'm able to
11:42:31 <bollu> mniip: Oh
11:42:33 <bollu> that's
11:42:35 <bollu> hm
11:42:37 <mniip> kras, any particular reason you're ++'ing a single item
11:43:02 * hackagebot haste-compiler 0.5.2 - Haskell To ECMAScript compiler  https://hackage.haskell.org/package/haste-compiler-0.5.2 (AntonEkblad)
11:43:04 * hackagebot polar-configfile 0.1.0.0 - Fork of ConfigFile for Polar Game Engine  https://hackage.haskell.org/package/polar-configfile-0.1.0.0 (Shockk)
11:43:10 <monochrom> so the way I understand it, you say "I don't want to write S (D :: D "hi"), I am looking for an alternative that lets me write S (D :: D "hi")"
11:43:42 <rcrc> monochrom: what I'd like is to be able to have an alias
11:43:54 <rcrc> I can have an alias "x = S D"
11:44:10 <kras> mniip: my bad, I could have used :
11:44:12 <mniip> kras, I'm not entirely sure I grasp the algorithm entirely, but it looks like it can be rewritten without an explicit "i"
11:44:14 <rcrc> and I can have an alias "type y s = D s"
11:44:18 <bollu> mniip: so, compare :: [a] -> [b] -> Ordering? compare l1 l2 = mconcat $ zipWith (compare l1 l2) ?
11:44:27 <rcrc> and I'm hoping I can do something similar here
11:44:36 <mniip> bollu, [a] -> [a] ->
11:44:42 <bollu> ah, sorry
11:44:43 <bollu> yeah
11:44:50 <bollu> but the definition is right?
11:44:53 <mniip> also more complicated than that
11:44:59 <mniip> because different lengths happen too
11:45:00 <bollu> oh, for it to short circuit?
11:45:02 <bollu> ah, man
11:45:11 <ReinH> The Ord monoid is requently used with the Monoid b => Monoid (a -> b) instance:
11:45:16 <ReinH> > sortBy (comparing snd <> comparing fst) [(1,2),(2,1)]
11:45:17 <lambdabot>  [(2,1),(1,2)]
11:45:25 <ReinH> *frequently
11:45:47 <kras> mniip: I need the i to remember the index of the element
11:45:50 <mniip> > (show <> id) "moo"
11:45:51 <lambdabot>  "\"moo\"moo"
11:45:53 <bollu> okay, compare as bs = mconcat $ [a `compare` b | a <- as | b <- bs] ?
11:46:02 <bollu> ^ does that make sense?
11:46:10 <mniip> no
11:46:12 <rcrc> monochrom: and what's tantalizing is that I *can* write type function application with type families
11:46:19 <bollu> oh, what's wrong with it now?
11:46:24 <rcrc> so it seems like I might be able to here
11:46:31 <mniip> you can't have 2 | in a list comprehension
11:46:36 <bollu> yes you can
11:46:40 <mniip> no you can't
11:46:53 <bollu> > [(a, b) | a <- [1..10] | b <- [1..5]]
11:46:54 <lambdabot>  [(1,1),(2,2),(3,3),(4,4),(5,5)]
11:47:03 <mniip> wait what
11:47:03 <bollu> it's an extension or something
11:47:04 <ReinH> mniip: parallel list comprehension
11:47:06 <bollu> I use it a lot
11:47:11 <bollu> it's like the zippy applicative
11:47:13 <bollu> on lists
11:47:18 <mniip> when did that happen
11:47:24 <dmj`> /msg bitemyapp found a big bug in picosecond calculation on the aws lib :(
11:47:25 <dmj`>  
11:47:33 <bollu> I dunno, I was reading through the GHC extensions one day and found it
11:48:14 <ReinH> mniip: since GHC 5 at least
11:48:21 <bollu> mniip: anyway, so, the definition is right?
11:48:24 <mniip> no
11:48:34 <bollu> compare as bs = mconcat $ [a `compare` b | a <- as | b <- bs] 
11:48:38 <mniip> if I interpret the extension correctly, it's identical to zipWith
11:48:42 <bollu> yeah
11:48:50 <mniip> which means it is incorrect
11:48:52 <bollu> oh, I shouldn't chop off the longer string?
11:50:07 <mniip> compare (x:xs) (y:ys) = compare x y <> compare xs ys
11:50:19 <mniip> compare (x:xs) [] = GT
11:50:26 <mniip> compare [] (y:ys) = LT
11:50:30 <mniip> compare [] [] = EQ
11:50:38 <mniip> the only straightforward way to define it
11:51:02 <ReinH> mniip: I think they left
11:51:15 <mniip> ಠ_ಠ
12:09:35 <ReinH> womp womp
12:09:45 <ReinH> mniip: what did you think of that linear algebra site thing?
12:10:28 <clrnd> I'm printing stuff in parallel and it doesn't garble the otuput, is this buffering or something?
12:10:43 <clrnd> literally `forkIO $ print stuff`
12:11:32 <mniip> ReinH, uh how do I explain
12:11:43 <mniip> the 2x2 matrix diagram,right
12:11:56 <mniip> we duplicate, then cross, then pass through numbers, then add
12:12:06 <srhb> clrnd: Sounds like weird luck!
12:12:10 <mniip> what if we duplicated, passed through numbers, /then crossed/ and added
12:12:23 <clrnd> srhb, in ghci it does garble it
12:12:27 <mniip> we would end up storing matrices as columns
12:12:37 <clrnd> this is #haskell, there is no luck here
12:12:45 <mniip> with straightforward multiplication
12:12:51 <mniip> instead of backwards  multiplication
12:13:32 <Welkin> has anyone else encountered this problem with haskell-mode in emacs?
12:13:50 <Welkin> it keeps giving me "parse error: illegal token: =
12:13:55 <Welkin> on this code
12:13:57 <Welkin>   , fieldView = \theId name attrs val isReq ->
12:14:00 <Welkin>       [whamlet|
12:14:03 <Welkin> $newline never
12:14:05 <Welkin> <input id=#{theId} name="#{name}" *{attrs} type="text" maxlength="140" :isReq:required value="#{either id id val}">
12:14:08 <Welkin>       |]
12:14:13 <Welkin> when I remove the QQ content it goes away
12:14:19 <Ankhers> Welkin: Might be easier to put that into a paste.
12:14:20 <mniip> seems obvious
12:14:23 <mniip> no TH support
12:14:23 <Welkin> but this has never happened before... or on any other QQ
12:14:35 <mniip> Welkin, oh did you enable the extension?
12:14:42 <bitemyapp> Welkin: wham.
12:14:44 <mniip> does the syntax checker see it?
12:14:56 <Welkin> mniip: iti s the syntax checker
12:15:03 <Welkin> it break theentire haskell-mode
12:15:06 <Welkin> breaks*
12:15:09 <Welkin> hm
12:15:47 <geekosaur> Welkin, reportedly a recent update to haskell-mode causes it to get confused while parsing
12:15:52 <srhb> clrnd: Testing shows that NoBuffering does indeed break it correctly. :-)
12:16:15 <Welkin> great...
12:16:21 <Welkin> I just updated haskell-mode a couple days ago
12:17:02 <clrnd> srhb, uh but now I need to use a handler, any way to set it up globally?
12:17:07 <Welkin> so any file with this in it is unusable
12:17:11 <clrnd> (tell me if I'm being to nasty)
12:17:11 <Welkin> no keypress has any effect
12:17:20 <srhb> clrnd: I don't think so.
12:18:38 <clrnd> the answer was `hSetBuffering stdout NoBuffering` btw, thanks
12:18:44 <Welkin> https://github.com/haskell/haskell-mode/issues/894
12:19:05 <Welkin> how do major bugs like this happen...
12:19:11 <srhb> clrnd: Yes, that's what I tested with. :)
12:19:25 <clrnd> srhb, well that's global enough for me :P
12:19:28 <srhb> Oh!
12:19:33 <srhb> OK, I misunderstood. Sorry. :)
12:19:38 <clrnd> nono, thank you!
12:19:39 <Welkin> hmm
12:19:50 <Welkin> are there any better alternatives to haskell-mode?
12:19:58 <srhb> Welkin: Not really.
12:20:03 <Welkin> I know chris done has structured-haskell-mode
12:20:09 <srhb> It's not really a replacement.
12:20:17 <Ankhers> That is a complement.
12:20:36 <Welkin> oh, that is a minor mode
12:20:37 <Welkin> bah
12:20:55 <Welkin> well wtf
12:21:18 <Welkin> can I revert to an older version of haskell-mode?
12:21:24 <srhb> Sure.
12:21:25 <Welkin> using the package manager
12:21:29 <srhb> Probably not.
12:21:42 <srhb> Unless you manually replace the package index with an older one.
12:21:55 <srhb> Which ends up being more pain than just removing it from package management and getting it manually.
12:36:42 <quicksilver> I've been dabbling with haskell for nearly 15 years. It only just clicked how simple it is to use 'fix' to do adhoc recursion patterns, including adhoc do-while loops in the IO monad
12:37:05 <Ankhers> :t fix
12:37:06 <lambdabot> (a -> a) -> a
12:38:57 <quicksilver> do putStrLn "hello"; fix (\loop i -> do putStrLn "many : " ++ show i; when (i<100) $ loop (i+3)) 0; putStrLn "done"
12:39:02 <quicksilver> that kind of thing.
12:41:17 <bennofs> I have never thought of using fix that way, that's quite nice
12:41:28 <Ankhers> Interesting.
12:42:45 <kaol> I just eliminated a do ... case a of Just x -> { foo x >> return () } ; Nothing -> return () with runMaybeT, MaybeT and lift. Useless trickery perhaps in that case but I'm happier with how it reads now.
12:43:06 <quicksilver> bennofs: previously I would have given the looping part a name. And made it a named recursive function.
12:43:25 <quicksilver> bennofs: which is fine, of course, and a perfectly sensible way to behave. But it's interesting to have the anonymous choice.
12:43:28 <bennofs> kaol: you can write Data.Foldable.traverse_ foo a  for that
12:43:30 <bennofs> quicksilver: yeah
12:44:01 <quicksilver> arguably I have given it a name. I've called it 'loop'. But at least it was inline.
12:45:14 <quicksilver> kaol: MaybeT is really nice. When it's what you need it is exactly what you need and it's really satisfying how it works out.
12:45:21 <bennofs> quicksilver: It's kind of like making a "label", only nicer :p.
12:45:45 <quicksilver> bennofs: yes. and if you want labels in the middle you reach for ContT.
12:46:36 <kaol> Now, if I could make this EitherT use click together too.
12:48:28 <quicksilver> EitherT is exactly like MaybeT but it additionally lets you 'name' the failure case iwth a type of your choice
12:48:43 <quicksilver> clasically for naming different error conditions so you can see what went wrong
12:48:54 <quicksilver> (but it doesn't have to be 'wrong', it can just be 'early exit')
12:51:53 <Welkin> wow
12:52:03 <Welkin> it's going to take some time to get used to mono-traversable
12:52:12 <Welkin> all the type signatures are different
12:52:25 <Welkin> I tried using notElem and had a surprise
12:56:21 <kaol> bennofs: I'm stuck with GHC 7.6 for the time being, is that a 7.10 thing? Or was this what the Traversable proposal was about?
12:57:14 <bennofs> kaol: no, this should work with GHC 7.6 as well. just import qualified Data.Foldable as F and then do F.traverse_ foo a, it's the same as 'case a of Just x -> { foo x >> return () }; Nothing -> return ()' 
12:58:09 <kaol> I used MaybeT here mostly to get a feel of how the EitherT case would go.
13:06:25 <indiagreen> sorry for a possibly unanswerable question, but I'll try anyway: how much time might it take for a single person to rewrite https://github.com/tgalal/yowsup (an implementation of – undocumented – Whatsapp protocol) to Haskell? assuming that I'm good with Haskell but haven't ever implemented a network protocol before
13:07:15 <nkaretnikov> Enigmagic: okay, i have a question about your promote function.  why does it accept the function parameter?  how is it intended to be used?  also, why did you change the type to Nat?  it doesn't show the size in the type, which is the goal
13:07:31 <nkaretnikov> indiagreen: there's only one way to find out %)
13:09:30 <Enigmagic> nkaretnikov: are you looking at the version from yesterday or today? i have a gadt implementation in there as well
13:09:46 <nkaretnikov> yesterday
13:09:50 <nkaretnikov> didn't know there's a new one :)
13:09:58 <Enigmagic> nkaretnikov: yeah i made some minor changes ...
13:10:45 <nkaretnikov> loosely related: are you aware of a better representation than peano numbers that achieves the same thing?  binary numbers at the type level (as in the software foundations book)?
13:10:55 <Enigmagic> nkaretnikov: the main thing is that you don't know the actual type until runtime, so it needs to use rank-2 types or existentials to do this
13:11:08 <nkaretnikov> if i get it right, the idea is that you just cut the number of constructors
13:11:10 <nkaretnikov> this way
13:11:22 <nkaretnikov> which saves memory(?)
13:11:46 <ReinH> indiagreen: Hmm, it seems pretty extensive. Implementing any particular endpoint might take an afternoon or so. If you want to try it, I'd suggest wreq and... hmm, it's an xml api?
13:11:48 <Enigmagic> nkaretnikov: doesn't really save memory :)
13:11:50 <nkaretnikov> Enigmagic: yeah, i get how existentials help here
13:12:12 <ReinH> indiagreen: Likely there will be far less boilerplate than with the python version
13:12:17 <Enigmagic> nkaretnikov: the built-in type naturals can work but they're very limited compared to this approach
13:12:23 <clrnd> `stack build` seems to build whenever it wants to, meaning some times it doesn't do anything even though there are changes
13:12:23 <nkaretnikov> Enigmagic: anyway, will take a look at the new impl after a short break
13:12:27 <ReinH> indiagreen: I guess someone should write an xml library with a similar design to aeson then... ;)
13:12:34 <nkaretnikov> Enigmagic: so, how are binaries beneficial, then?
13:12:44 <Enigmagic> nkaretnikov: that will change eventually though, maybe ghc 8.0 or 8.2... they've been working on integrating a solver into ghc
13:13:19 <nkaretnikov> like liquid haskell?
13:13:20 <Enigmagic> nkaretnikov: well that's the rub, it's not always clear that they are beneficial
13:13:49 <Enigmagic> nkaretnikov: not like liquid haskell, more like the ability to prove basic stuff about nats, like 1 + 1 ~ 2
13:14:30 <nkaretnikov> Enigmagic: btw, i'm referring to https://github.com/nkaretnikov/software-foundations/blob/8347b96ba043a184b91b264808d6f2c2e1f3a138/Induction.v#L697
13:14:35 <Enigmagic> you can do it (slowly) with data kinds and type families but not the built-in nats
13:15:20 <indiagreen> ReinH: (just in case, at this moment my choice isn't “to do or not to do”, it's “what number do I tell to my employer”, and I really really really don't want to fall victim to Hofstadter's law)
13:15:36 <nkaretnikov> indiagreen: just tell the one that they expect :)
13:15:44 <nkaretnikov> indiagreen: then it'll be too late :)
13:15:53 <Nathan> hi
13:16:32 <nkaretnikov> Enigmagic: the type is itself here: https://github.com/nkaretnikov/software-foundations/blob/8347b96ba043a184b91b264808d6f2c2e1f3a138/Basics.v#L936
13:16:58 <Enigmagic> nkaretnikov: oh... yeah ok
13:17:13 <Nathan> I've got a category-theory related question, is this the right place to ask?
13:17:23 <Enigmagic> nkaretnikov: those use less memory than peano yes. there are decimal implementations as well
13:17:58 <nkaretnikov> Enigmagic: iirc, edwardk has a type somewhere that add T2 to this or something like that
13:18:05 <Enigmagic> nkaretnikov: here's a decimal example: http://hackage.haskell.org/package/type-level-0.2.4/docs/Data-TypeLevel-Num-Aliases.html
13:18:16 <nkaretnikov> Enigmagic: iirc it was in the cache-oblivious talk
13:18:29 <Enigmagic> it's still plenty slow when dealing with large numbers though ;)
13:19:14 <nkaretnikov> Enigmagic: funny little module
13:19:55 <Enigmagic> nkaretnikov: more interesting to look at the implemenations of multiply and stuff and compare that to peano or binary encodings
13:20:21 <JagaJaga> How can I statically link executable if gtk is in dependence?
13:20:25 <Nathan> Does anyone know of a good explanation of ends/coends? Trying to understand day convolution and failing very hard.
13:20:43 <Nathan> tried nlab but its over my head
13:23:06 * hackagebot cryptol 2.2.5 - Cryptol: The Language of Cryptography  https://hackage.haskell.org/package/cryptol-2.2.5 (AdamFoltzer)
13:29:59 <ReinH> indiagreen: unfortunately for you, Hofstadter's Law is impervious to being aware of Hofstadter's Law. There is no hope.
13:30:31 <ReinH> indiagreen: Can your employer afford to have you do a spike for a week to see what kind of progress you make?
13:31:21 <nolrai66> I find that if you break it into tasks that take half an hour each then you can get estimates that are only off by 2, instead of by 10.
13:33:08 <nkaretnikov> Enigmagic: which multiply?
13:33:10 <nkaretnikov> don't recall the name
13:33:30 <wraithm> \q lambdabot :t \f x -> f <<< pure x -- Is this a thing anywhere?
13:33:36 <wraithm> :t \f x -> f <<< pure x -- Is this a thing anywhere?
13:33:37 <lambdabot> (Applicative (cat a), Category cat) => cat b c -> b -> cat a c
13:34:11 <wraithm> meant to pm lambdabot, but whatever, is that a known combinator somewhere? I find I'm writing that a bunch.
13:34:59 <indiagreen> ReinH: I'm pretty sure it'll take me a week just to figure out what's going on. I'm... dumb when it comes to reading code.
13:35:13 <indiagreen> anyway, nevermind, I guess
13:35:53 <mtesseract> Anyone using the stack-ide Emacs package? I'm wondering what's the suggested way to use the interactive-mode in combination with stack-mode.
13:36:11 <mniip> wraithm, why are you using arrows together with applicatives
13:36:33 <wraithm> mniip: Great question. Is there a better what to do it?
13:36:44 <mniip> :t arr (const ?x)
13:36:45 <lambdabot> (?x::c, Arrow a) => a b c
13:37:30 <arkeet> :t pure ?x
13:37:32 <lambdabot> (Applicative f, ?x::a) => f a
13:38:01 <c_wraith> mniip: why not? There should always be an Applicative instance for an instance of Arrow. And it's usually easier to think about. 
13:38:05 <arkeet> anyway, any reasonable instance should satisfy f . pure x = pure (f x)
13:38:11 <mniip> c_wraith, "should always be"
13:38:11 <arkeet> wait.
13:38:15 <Enigmagic> nkaretnikov: type-level represents numbers as lists of digits, so some operations are more efficient... like multiplying by 10 or 100 would be very cheap when compared to peano or binary
13:38:16 <arkeet> type error
13:38:27 <mniip> c_wraith, you should use WrappedArrow then
13:38:57 <mniip> Enigmagic, got a source on that?
13:39:27 <c_wraith> mniip: my point was more that it's a poor library that doesn't provide instances of applicable classes from base. 
13:39:49 <Enigmagic> mniip: they don't actually do the base-10 multiplication optimization but it wouldn't be hard to do
13:39:53 <Enigmagic> mniip: here's the source http://hackage.haskell.org/package/type-level-0.2.4/docs/src/Data-TypeLevel-Num-Ops.html#Mul
13:39:56 <c_wraith> Enigmagic: that's not true of type literals 
13:40:11 <mniip> Enigmagic, ah I thought you were talking about typelits
13:40:14 <mniip> like
13:40:15 <Enigmagic> c_wraith: correct
13:40:16 <mniip> :k 1
13:40:17 <lambdabot> GHC.TypeLits.Nat
13:40:33 <nkaretnikov> Enigmagic: sorry got disconnected
13:40:48 <wraithm> In my case, there is both an arrow and applicative instance. Specifically, I'm using Opaleye. There's this QueryArr which is an arrow. I find that I write my queries as arrows, but then at the end of the day, I need put put a pure value into the query, ie: (someQuery :: QueryArr a b) <<< pure (x :: a) :: Query b
13:41:16 <Enigmagic> mniip: yes, those are a lot faster ;-) but without a solver in ghc they're quite limited
13:41:19 <mniip> I still suggest you use const arrows
13:44:19 * arkeet wonders why QueryArr has to be an arrow. it just looks like Kleisli (State (PrimQuery,Tag)) to me
13:45:49 <arkeet> so it can just be a Monad
13:47:01 <xpilot> hello! does anyone know how edwardk's ad package does sharing?
13:47:29 <xpilot> (in reverse mode that is)
13:47:34 <nolrai66> Is there a fliped version of <$> ?
13:47:45 <arkeet> nolrai66: lens has <&>
13:48:38 * arkeet wonders if it might be worth splitting off such general-purpose operators into a separate package
13:48:44 <hoppfull> Hello. I am not a Haskell programmer. But I've been curious about monads. And I think I am beginning to understand. Is there any point in using monads in a language such as f#?
13:49:04 <mauke> yes
13:49:26 <hoppfull> Do monads provide some useful utility beyond simplifying code?
13:49:35 <Enigmagic> hoppfull: f# calls them 'workflows' iirc. their async support is built using it
13:51:17 <hoppfull> I think I understand the identity monad and the maybe monad. The identity allows you to name temporary variables inside a function and the maybemonad "carries" a value that can be evaluated or return null.
13:51:28 <hiptobecubic> F# doesn't have "monad" in the general sense I don't think. Just some examples of some, like the "workflows" you menioned.
13:51:33 <nolrai66> hoppfull: Not sure what you mean. What could anything do beyond simplifying code?
13:51:38 <wraithm> mniip: I don't think I understand your arr (const x) thing that you wrote above. Could you rewrite "someQuery <<< pure x" in the style that you're talking about?
13:51:46 <arkeet> pure x = arr (const x)
13:51:53 <wraithm> I see
13:52:23 <hoppfull> nolrai66: I used to think monads where something special that provided some kind of safety feature. But now it appears they're only for imitating imperative concepts in a pure functional language.
13:52:31 <nolrai66> hiptobecubic: The haskell idenity monad doesn't do /anything/ that kind of its point.
13:52:57 <Pro9> How do you write a one line "do", if I write (do x <- function return x) I get a parse error
13:53:00 <wraithm> Well then is there a combinator that's an alias for "\f x -> f <<< arr (const x)" somewhere?
13:53:39 <Pro9> If i write the exact same function, but move return x down so that is starts at x <- ...  it works
13:53:51 <Axman6> predator117: need ; after function
13:53:57 <mauke> hoppfull: the maybe monad provides computations that can fail, similar to exceptions
13:53:59 <Enigmagic> hiptobecubic: i guess they're called "computation expressions" https://msdn.microsoft.com/en-us/library/dd233182.aspx
13:54:05 <nolrai66> hoppfull: They can do things like nondeterminism or linear algebra too.
13:54:10 <Axman6> uh, Pro9 
13:54:12 <Enigmagic> hiptobecubic: notice operations like bind/return/etc
13:54:45 <Welkin> Pro9: you write a one-line "do" using the actual functions that it desugars to
13:54:49 <Welkin> namely >>= and >>
13:54:50 <dtscode> is there any haskell convention I'm breaking by doing import qualified for all of my imports?
13:54:54 <hoppfull> nolrai66, I think the problem is that no one has ever pointed a finger at a monad and said "look, that's a monad". I just hear these strange explainations of how they work.
13:55:01 <mauke> Pro9: do x <- ...; return x
13:55:10 <nolrai66> welkin: or simicolons.
13:55:26 <bitemyapp> dtscode: not really
13:55:28 <Axman6> dtscode: "javastyle" :P
13:55:32 <bitemyapp> dtscode: just more careful than most people.
13:55:32 <nolrai66> Well, you know linked lists?
13:55:44 <Welkin> `do { x <- function; return x }` is the same as `function >>= return` is the same as `fmap function`
13:55:45 <bitemyapp> dtscode: as long as it is readable.
13:55:51 <hoppfull> Alright, thanks guys! I will continue with my journey. One day I might understand monads.
13:56:01 <Pro9> mauke: Axman6: Thanks
13:56:05 <Iceland_jack> hoppfull: Do you know what lists are?
13:56:06 <dtscode> bitemyapp: thanks
13:56:11 <nolrai66> hoppfull: Those form a nondetermancy monad.
13:56:52 <hoppfull> Iceland_jack > Is this a question that is so simple I am making it more complicated than it is? I think I know what lists are. Unless you are refering to some profound concept.
13:57:25 <Welkin> er, fmap id function, which is just function
13:57:28 <Iceland_jack> hoppfull: The tricky part is this, do you know the difference between 'Maybe Int' and 'Maybe'?
13:57:42 <Welkin> wow
13:57:43 <Iceland_jack> You said you weren't a Haskell programmer
13:57:46 <Welkin> what a horrible naming scheme
13:58:00 <Welkin> function is not even a function
13:58:03 <Welkin> haha
13:58:07 <hoppfull> Iceland_jack: No. I am not a haskell programmer. I am coming from clojure and f#
13:58:08 <neuroserpens> :t fmap
13:58:10 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:58:34 <Iceland_jack> hoppfull: Lists of integers are written as "[Int]"
13:58:39 <monochrom> Iceland_jack: I'm curious, I want to know how you're going to follow up on "what are lists?" too. I can think of two possibilities.
13:58:57 <hoppfull> Iceland_jack: Okay. Is it a type declaration?
13:59:00 <monochrom> oh, that. I see now.
13:59:10 <ReinH> hoppfull: "Monad" is much more boring than people make it out to be. It's just a type class that defines functions (>>=) and return. What you should focus on is concrete instances of Monad and understanding their definitions of those functions.
13:59:11 <Iceland_jack> hoppfull: It's a type
13:59:44 <hoppfull> Iceland_jack Like List<int> in c#?
13:59:47 <Pro9> Welkin: I have seen the definition for do on hoogle, but I have not fully understood what >>= and >> do
13:59:51 <Iceland_jack> hoppfull: Exactly
13:59:55 <hiptobecubic> Here's an F# person's description of them I guess? http://tomasp.net/blog/2013/computation-zoo-padl/
14:00:04 <Iceland_jack> hoppfull: List<int> is not a Monad, but "List<_>" is
14:00:04 <hoppfull> Iceland_jack: Following so far.
14:00:15 <hoppfull> Iceland_jack: Interesting!
14:00:33 <bitemyapp> dtscode: np
14:01:03 <Iceland_jack> hoppfull: So like ReinH said, what it means to be a monad is fairly uninteresting
14:01:16 <Iceland_jack> what it *takes*, rather
14:01:30 <Welkin> Pro9: >>= and >> are fundamental
14:02:04 <hoppfull> iceland_jack: That has been my impression lately. That they seem more special than they are.
14:02:06 <Welkin> Pro9: read the typeclassopedia https://wiki.haskell.org/Typeclassopedia#Monad
14:02:19 <Welkin> Pro9: and this http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
14:02:22 <dmj`> hoppfull: computation expressions in F# are like monads, .SelectMany in linq is like (>>=)
14:02:25 <Iceland_jack> hoppfull: It just means that you can implement a couple of functions for lists
14:02:57 <Welkin> Pro9: >> sequences computations together
14:03:07 <Iceland_jack> one of those functions creates a list containing a single value
14:03:08 <Iceland_jack>     return :: a -> [a]
14:03:08 <Iceland_jack>     return x = [x]
14:03:08 <Iceland_jack> hoppfull: which is fairly boring
14:03:15 <Welkin> Pro9: >>= sequences them together, and passes along a value from the first to the second
14:03:22 <Iceland_jack> > return 42 :: [Int]
14:03:23 <lambdabot>  [42]
14:04:49 <hoppfull> Thanks for your help guys!
14:05:33 <Iceland_jack> hoppfull: But really there is a hierarchy of things, at the bottom is "Functor" which is simpler than Monad but has some of the same stumbling blocks as Monad 
14:05:47 <Pro9> Welkin: I will bookmark thoose, but I'll probably wait untill I reach the chapter about monads in LYAH, I feel like as soon as I started looking at higher order functions and input and output I kinda slided out into some deep water ^^
14:06:20 <hoppfull> Iceland_jack: A functor is just a function that returns multiple values, right? We use tuples to implement this behaviour?
14:06:26 <Iceland_jack> no
14:06:40 <Iceland_jack> (Similarly [a] isn't a Functor, but [] is
14:06:40 <Iceland_jack> 'Maybe a' isn't a Functor, but 'Maybe' is
14:06:40 <Iceland_jack> 'Identity a' isn't a Functor, but 'Identity' is)
14:07:44 <Iceland_jack> hoppfull: If you're familiar with 'map :: (a -> b) -> [a] -> [b]', that is the Functor action/function for lists
14:08:24 <nolrai66> functor from C++ and functor from haskell are unrelated.
14:08:29 <hoppfull> Iceland_jack: map applies a function to a list and returns a new list with the functions return values?
14:08:35 <Iceland_jack> yes
14:08:36 <Iceland_jack> > map show [1..10]
14:08:37 <lambdabot>  ["1","2","3","4","5","6","7","8","9","10"]
14:09:34 <Iceland_jack> hoppfull: for 'Maybe' it would look like this
14:09:34 <Iceland_jack>     maybeMap :: (a -> b) -> Maybe a -> Maybe b
14:09:34 <Iceland_jack>     maybeMap f Nothing  = Nothing
14:09:34 <Iceland_jack>     maybeMap f (Just x) = Just (f x)
14:09:38 <hoppfull> Iceland_jack: Is a functor always/sometimes the same as a monad?
14:09:50 <Iceland_jack> Every Monad is also a Functor 
14:10:00 <hoppfull> But not every functor is a monad?
14:10:04 <Iceland_jack> that's right
14:11:06 <dmj`> hoppfull: (,) is an example
14:11:18 <hoppfull> Iceland_jack: I'm afraid I don't know what Just is.
14:12:05 <hoppfull> Iceland_jack: I feel a little rude being in here and asking a question about an advanced topic without knowing any of the simple topics in haskell. I should ask these questions in the f#-channel
14:12:33 <mniip> dmj`, but the writer monad
14:12:33 <bitemyapp> hoppfull: you'll learn more here
14:12:44 <bitemyapp> hoppfull: but you'll have an easier time learning Functor if you just learn Haskell
14:12:44 <mpwoz> hoppful: as another newbie, I appreciate the "dumb" questions :)
14:12:47 <Iceland_jack> Not at all, see if you can understand what Just is from the following examples hoppfull 
14:12:50 <bitemyapp> hoppfull: it's easier to understand with HKTs anyway.
14:12:57 <Iceland_jack> > elemIndex 'a' "hello"
14:12:59 <lambdabot>  Nothing
14:13:04 <dmj`> mniip: w/ a constraint, sure
14:13:04 <Iceland_jack> > elemIndex 'e' "hello"
14:13:06 <lambdabot>  Just 1
14:13:07 <hoppfull> I'm considering learning Haskell.
14:13:15 <Iceland_jack> > elemIndex 'l' "hello"
14:13:16 <lambdabot>  Just 2
14:13:28 <Cale> hoppfull: Just is one of the data constructors of a type called Maybe. I believe it might be called Option in F#?
14:13:48 <Fuuzetsu> I think it's Option with None and Some constructors
14:13:51 <Cale> yeah
14:13:53 <Cale> that's right
14:13:59 <mpwoz> same in Scala (Option)
14:14:10 <c_wraith> hoppfull: don't do it. Knowing haskell makes you spend your lunch breaks crying when your job is rails. Or maybe that's just me. 
14:14:11 <hoppfull> Cale: That's what I thought. Maybe looked a lot like Some
14:14:15 <Cale> hoppfull: In Haskell, it's defined by   data Maybe a = Nothing | Just a
14:14:23 <dmj`> hoppfull: if you're coming from F#, https://en.wikibooks.org/wiki/F_Sharp_Programming/Computation_Expressions
14:15:03 <Cale> hoppfull: and yeah, the best way to understand the monad abstraction is just to use a bunch of different monads
14:15:07 <hoppfull> c_wraith: haha, why is that?
14:15:29 <mniip> 'The designers of F# use term "computation expression" and "workflow" because it's less obscure and daunting than the word "monad."'
14:15:31 <Cale> hoppfull: I think it clicked for me once I learned about Parsec.
14:15:33 <mniip> but monads
14:16:14 <dmj`> mniip: "workflow" :(
14:16:23 <Cale> hoppfull: Which is a parser combinator library that happens to define a Monad instance as well, which gives you lots of useful tools for combining parsers
14:16:30 <hoppfull> Cale: It started to click for me when I looked at Clojure examples of monads. Clojure has extremely simple syntax.
14:16:33 <mniip> hoppfull, also it is perfectly okay to ask, uh, simple questions here
14:16:55 <c_wraith> hoppfull: once you see what a language can be with minimal compromised from its ideals, you wonder why ruby has so many bizarre corner cases and such complex semantics. 
14:17:45 <c_wraith> hoppfull: then you come into contact with rails, and wonder when software engineering died. 
14:18:03 <Cale> hoppfull: In that case, we have return :: a -> Parser a constructing the parser which doesn't consume any input, but succeeds with the given result. While, for bind (>>=) :: Parser a -> (a -> Parser b) -> Parser b, we have that x >>= f is the parser which parses the start of the input with x, and then applies f to the result of that parsing in order to get a parser with which to parse the rest of the input.
14:18:15 <athan> c_wraith: It's automagical
14:18:22 <hoppfull> c_wraith: You're talking about rubu on rails, right? I never actually used it.
14:19:06 <mniip> haskell on a horse!
14:19:25 <Cale> hoppfull: The useful thing about abstracting over an arbitrary type which supports these operations, is that there are lots of useful functions which can be written using only the polymorphic return and (>>=), and then we get those libraries of operations for free when we find some new monad.
14:19:40 <c_wraith> hoppfull: yes. The driving design goal seems to be "make simple apps really slick at any cost to maintainability." 
14:19:46 <hoppfull> Cale: Wait, let me try this: (a -> (b -> c)) is b a monad?
14:19:52 <Cale> no
14:20:00 <Cale> A monad is always a type constructor
14:20:08 <Cale> i.e. something which takes a type argument, and produces another type
14:20:11 <Cale> like Maybe
14:20:18 <hoppfull> alright
14:20:37 <Cale> (together with implementations for return and (>>=) specialised for that type constructor)
14:20:48 <Cale> In general,  return :: (Monad m) => a -> m a
14:20:52 <hoppfull> I feel a little exhausted. I'll come back when I've learned some haskell. c_wraith, I think I won't take your advice on avoiding haskell. ; )
14:21:00 <Cale> and  (>>=) :: (Monad m) => m a -> (a -> m b) -> m b
14:21:26 <c_wraith> hoppfull: have fun. That's the important part. :) 
14:21:27 <Cale> and what return and (>>=) (read as "bind") do for each m is a special case
14:21:37 <Iceland_jack> hoppfull doesn't know about type classes so 'Monad m => ...' may not help so much
14:21:48 <Cale> Well, that's a good point :)
14:21:50 <hoppfull> Iceland_jack: yeah
14:22:12 <Cale> The (Monad m) => ... bit is a constraint on which type constructors m we are allowed to pick
14:22:36 <mniip> I don't think you can explain typeclasses in one sentence
14:23:10 <hoppfull> Alright, thanks all! I'm off for adventures!
14:23:13 <Cale> In this case, it means we're only allowed to pick an m for which there's an instance of this class Monad, which means that there are implementations of return and (>>=) available for this m
14:23:20 <Cale> All right! :)
14:23:22 <Iceland_jack> hoppfull: Just like you can have
14:23:22 <Iceland_jack>     (+) :: Int   -> Int   -> Int
14:23:22 <Iceland_jack>     (+) :: Float -> Float -> Float
14:23:22 <Iceland_jack> you can have
14:23:25 <Iceland_jack>     return :: a -> [a]
14:23:28 <Iceland_jack>     return :: a -> Maybe a
14:23:32 <Iceland_jack> Good luck hoppfull
14:26:22 <mniip> that feel when you try to stuff as much haskell into a person as you can
14:26:30 <Iceland_jack> ;)
14:26:49 <Iceland_jack> Explaining things in a big channel can be an exercise in futility though
14:27:06 <mniip> by the way
14:27:16 <mniip> is there a scientific name
14:27:44 <mniip> for when instead of abstracting patterns from examples, you learn patterns directly
14:28:14 <Cale> heh
14:28:22 <Cale> "mathematics"
14:29:34 <mniip> Cale, never once I experienced this kind of thing in mathematic
14:29:34 <mniip> s
14:30:35 <Cale> Yeah, it's kind of possible to avoid it, but in another sense it happens constantly?
14:30:49 <Cale> That was a half-joking remark
14:31:16 <Cale> Yes, you probably knew lots of examples of e.g. metric spaces before you started studying metric spaces
14:32:23 <Cale> But on the other hand, you probably also quickly find that those examples have a lot about them which is more special, and the idea of a metric space gets very unintuitive for a while until you learn enough counterexamples, and prove enough theorems.
14:32:42 <mniip> no like
14:33:18 <mniip> to get intuition about the scalar product you have to think about how different pairs of vectors multiply
14:33:19 <Cale> So sure, maybe the idea of a metric space is abstracted from some examples like subsets of R^n
14:33:34 <mniip> that's abstracting a pattern from examples
14:33:38 <Cale> But as soon as you do it, you find that you're dealing with a very different sort of beast.
14:33:49 <mniip> meanwhile look at the coyoneda functor
14:34:00 <Cale> It's not a very good characterisation of subsets of R^n
14:34:06 <mniip> its definition is so obvious to me that I understand it instantly without even substituting any functor
14:34:14 <Cale> So most of your intuition doesn't apply
14:34:57 <Cale> The natural numbers are another example perhaps
14:35:24 <Cale> We learn about the set of natural numbers without really having an example to work from.
14:35:36 <Pro9> I just want to verify that I have understood data and type correctly: data Player = Human | AI, then I can use type ChessPlayer = Player, basically data creates a data type (int, string, double are data types?) , and type just allowes me to give another name to a datatype (improves readability?)
14:35:46 <mniip> one apple, two apple, three apple
14:36:33 <mniip> Pro9, 'type' is a type synonym, it can also be a more complex construct
14:36:39 <mniip> type String = [Char]
14:36:43 <Cale> mniip: People somehow manage to delude themselves into thinking that apples are enough, but the natural numbers are really big.
14:36:58 <mniip> type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
14:37:13 <Cale> and no matter how many apples you might have at your orchard, I don't think there will be enough to really serve as a model of N :)
14:37:21 <mniip> Cale, that's when your brain kicks in
14:37:34 <mniip> and extrapolates
14:37:48 <mniip> by assuming that natural numbers keep working even when the apples run out
14:38:18 <Cale> Pro9: So yeah, you defined a new data type called Player with just two values, Human and AI
14:38:34 <Pro9> mniip: ahh, good to know. I thought it was just use for readability
14:38:37 <Cale> Pro9: and then you defined the alias ChessPlayer to mean the same thing as Player
14:39:15 <mniip> Pro9, it /is/ only for readability
14:39:18 <Cale> Without language extensions, type is mostly just for readability (though use it sparingly, because it usually harms readability more than it helps)
14:39:50 <mniip> Cale, you end up shaving off stuff irrelevant to the idea of natural numbers
14:39:55 <mniip> i.e apples
14:40:19 <mniip> whereas if we were teaching natural numbers as a pattern
14:40:24 <mniip> we'd use something peano-ish
14:40:37 <mniip> or at least digit arrays
14:40:39 <Cale> We need something Peano-ish
14:40:59 <Cale> The natural numbers are not the same thing as the potential numbers of apples.
14:41:04 <Cale> :)
14:41:12 <mniip> are they not
14:41:18 <Cale> I don't think so anyway
14:41:48 <mniip> do you know a particular number that could not, hypothetically, be an amount of apples?
14:41:57 <Cale> Most natural numbers are so large that even if all the material in the universe were turned into SD cards, we could not store a statement which uniquely characterises them.
14:41:57 <feryll> When I use getCPUTime from System.CPUTime in parallel programs, I seem to be getting exaggerated times proportional to the number of cores in use. Can it accurately measure distributed computer time spent, then?
14:42:18 <mniip> Cale, that's when "hypothetical" kicks in
14:42:45 <mniip> feryll, that's exactly what getCPUTime is
14:43:56 <nkaretnikov> is it possible to have value constructors in type families?
14:44:01 <feryll> mniip All right, thanks, I guess TIL what "cpu time" means
14:44:51 <mniip> nkaretnikov, er?
14:45:03 <Cale> It's a bit questionable to claim that we really have a definite handle on what goes on with such numbers by only looking at tiny examples. We do after all know that the Peano system is either incomplete or inconsistent (we hope the former). So there are many things about how natural numbers operate (we hope) which are not determined by the axioms.
14:45:38 <nkaretnikov> mniip: I want a type level computation with a value level tag
14:46:14 <nkaretnikov> i can work around this by using GADTs
14:46:21 <nkaretnikov> e.g.
14:46:40 <nkaretnikov> data T t where T :: a -> b -> c -> T (Triangle a b c)
14:46:49 <nkaretnikov> where Triangle a b c is my type family
14:47:10 <nkaretnikov> but i want to get Triangle a b c back
14:47:27 <Cale> mniip: Eventually if you pile enough apples together, you probably get a black hole or something.
14:47:36 <Cale> mniip: So apples won't really work.
14:47:47 <mniip> hyyyypoooothetical
14:47:55 <mniip> massless apples
14:48:09 <Cale> There's probably a point at which apples can no longer help you to add numbers, and it's probably well before that even.
14:48:10 <mniip> or incompressible
14:48:24 <mniip> why not
14:48:30 <Cale> We can choose other sorts of physical objects, but they have similar problems.
14:48:44 <Cale> The rules about how natural numbers behave are not determined by physics.
14:48:51 <mniip> take a planet of 2^100000 apples, and a planet of 5^100000 apples, and merge them together
14:49:35 <mr-> mniip: you are running out of apple-matter :)
14:49:43 <thimoteus> are the planets themselves made of apples, or only have the apples on top of a rocky surface?
14:49:56 <Cale> That's a lot of apples
14:50:28 <hiptobecubic> I believe that's more apples than atoms.
14:50:53 <ReinH> I think we've strayed just slightly into off topic territory here...
14:51:01 <hiptobecubic> I don't remember the factors, but i suspect 5^100000 is a pushing it :)
14:51:02 <Cale> I don't think we're going to be able to collect that many, given how many times larger it is than the estimated number of particles in the observable universe. Even if we did, it would likely be disastrous, and we wouldn't be able to count the apples.
14:51:21 <nkaretnikov> Enigmagic: i think i found a way to promote values, it's a hack, though.  i'll write a th function that will look like an ordinary haskell function, but it will construct the type for me.  E.g., [triangle|1 2 3] will return Refl :: Triangle (Succ ...) (Succ ...) (Succ ...)  that's what singletons uses, iiuc
14:52:59 <Cale> That first planet has about 10^30000 times as many apples as there are particles in the observable universe (give or take about 100 orders of magnitude)
14:53:37 <hiptobecubic> well i think it's safe to say that none of this is observable, so it will be fine :)
14:54:53 <Cale> People always like to talk about how *natural* the natural numbers are, and I just totally disagree. :P
14:54:55 <monochrom> did Steve Jobs move to that planet? :)
14:55:15 <ReinH> Cale: I don't think they're any more "natural" than "i" is imaginary. Or, for that matter, than pi is "real".
14:56:06 <Cale> Yeah, but you have quotes like Kronecker's "God made the natural numbers; all else is the work of man."
14:56:12 <monochrom> actually who coined the name "natural numbers"?
14:56:19 <monochrom> and did he/she say why?
14:56:21 <Cale> No, the natural numbers are the work of man too.
14:56:46 <Enigmagic> nkaretnikov: yeah because you're doing evaluation at compile time :) but it will work
14:58:29 <mtesseract> When contemplating about natural numbers, I like the approach of intuinistic mathematics. I tend to agree with the position that natural numbers are indeed some kind of primitive construction, which can be derived from certain basic principles of perception.
15:01:24 <mtesseract> (But on the other hand, intuinistic mathematics says that all mathematics is basically doing mental constructions, this is also true for natural numbers in this sense)
15:04:15 <erikd> Megaparsec anyone? I'm getting "Text.Megaparsec.Prim.many: combinator 'many' is applied to a parser that accepts an empty string." but my parser does not use 'many' directly.
15:04:24 <indiagreen> erikd: does it use “some”?
15:04:27 <Cale> mtesseract: Yeah, the mathematical structures we've built definitely say a lot about how humans percieve things.
15:04:34 <erikd> indiagreen: yes
15:04:44 <indiagreen> ha, I told the author it would confuse someone
15:04:46 <indiagreen> but no-o
15:04:58 <indiagreen> anyway, some uses many under the hood
15:05:44 <erikd> indiagreen: thanks. i'll take it up with the authors :)
15:06:27 <indiagreen> erikd: on the other hand it's not like there's a good solution to that, because lots of things might be using “many” under the hood 
15:11:05 <erikd> indiagreen: raised a github issue. lets see what happens.
15:11:21 <benzrf> is arrow notation part of the haskell standard
15:12:53 <benzrf> and how old is do-notation
15:13:00 <benzrf> when was it introduced
15:23:48 <radix> benzrf: I think in Haskell 1.3? I'm not sure
15:24:24 <damnthosestring> Hello sirs
15:24:35 <radix> https://www.haskell.org/definition/from12to13.html#do
15:24:42 <damnthosestring> anyone might know why I keep getting this ‘parseJson’ is not a (visible) method of class ‘FromJSON’ error?
15:25:06 <damnthosestring> import Data.Aeson (Value(Object)) doesn't seem to solve anything :|
15:25:10 <indiagreen> damnthosestring: because the method is called parseJSON
15:25:23 <indiagreen> Haskell is case-sensitive
15:25:50 <damnthosestring> @indiagreen
15:25:51 <lambdabot> Unknown command, try @list
15:25:58 <damnthosestring> wow thank you so much
15:26:00 <damnthosestring> got it working now
15:26:07 <indiagreen> nice
15:37:03 <m1dnight_> Is it me, or is the real world haskell book really outdated?
15:37:16 <m1dnight_> A lot of examples I have tried give me other errors or dont even work.
15:37:26 <indiagreen> m1dnight_: it's only somewhat outdated
15:37:40 <indiagreen> or rather, some parts are very outdated and some are almost not-outdated
15:37:48 <m1dnight_> Should I bother reading it in its entirety?
15:38:04 <indiagreen> there was some nice Stackoverflow answer detailing what was outdated and in what ways, google for it
15:38:30 <indiagreen> as for the last question, I'm not sure so I'll let somebody else answer this one
15:38:37 <m1dnight_> http://stackoverflow.com/questions/23727768/which-parts-of-real-world-haskell-are-now-obsolete-or-considered-bad-practice
15:38:42 <m1dnight_> This one, if you wanted to know :)
15:43:11 <ReinH> radix: Ah yes, back when pattern matching failure used MonadZero.
16:08:12 * hackagebot Yampa 0.10.3 - Library for programming hybrid systems.  https://hackage.haskell.org/package/Yampa-0.10.3 (IvanPerez)
16:24:59 <pavonia> I've written an IRC bot using the fastirc library. If I run my bot from GHCi everything works fine. But if I compile it to a binary and run that just nothing happens, the program immediately terminates. Any idea what could be a reason for that?
16:25:36 <Cale> pavonia: hmm
16:25:47 <Cale> pavonia: How are you using threads? Does the main thread terminate?
16:25:50 <jabesed> is there some name for functions that can be described by either a fold or an unfold?
16:26:08 <Cale> jabesed: I don't think there is specifically a name for those
16:26:49 <jabesed> Cale: I have this situation where I am building an inductive structure out of another and have no idea what to call it
16:26:52 <pavonia> Cale: I've added debug output and the main thread terminates. The preoblem seems to be in the fastirc library, i.e. in the call of startBot or onEvent
16:27:13 <pavonia> I also use the -threaded option when compiling
16:27:50 <Cale> pavonia: When the main thread ends, the entire program ends.
16:28:18 <jabesed> "the inductive structure of A is induced by the inductive structure of B" seems to be a bit to heavy on the "induction" referencies
16:29:02 <jabesed> but neither unfold nor fold really express what I want
16:29:39 <jabesed> the idea being the both, the input and the output are defined via structural induction
16:29:42 <pavonia> Cale: Oh, I see ... thanks for the hint!
16:31:49 <jabesed> I guess I'll just call it a mapping 
16:32:23 <jabesed> because in essence these are just maps at meta level 
16:32:43 <jabesed> between the trees defining their structure
16:35:52 <hpc> jabesed: traversal?
16:38:08 <ReinH> jabesed: call it a homeomorphism, why not
16:38:13 <ReinH> jabesed: (can you show an example?)
16:42:12 <shachaf> What do homeomorphisms have to do with it?
16:44:07 <pavonia> So I added a takeMVar to prevent the main thread from terminating until the bot receives a quit signal (the onQuit handler is run). That kind of works, but now the program terminates with "thread blocked indefinitely in an MVar operation". Here's what the main looks like: http://lpaste.net/142103
16:45:01 <pacak> pavonia: This means ghc lost all other potential writers  to that MVar
16:45:31 <johnw> pavonia: it's easier to use the 'async' library, and its 'wait' command for things like this
16:45:39 <johnw> it handles exceptions nicely
16:46:06 <pavonia> pacak: That means the bot thread terminates before the putMVar can be executed?
16:46:30 <arahael2> This is a perfect opportunity to show logging.
16:46:58 <ReinH> shachaf: nothing at all.
16:47:00 <pacak> pavonia: Something like that.
16:47:38 <ReinH> pavonia: Have you read Simon Marlow's Parallel and Concurrent Haskell book? It's free.
16:47:49 <ReinH> @google parallel and concurrent programming with haskell
16:47:50 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
16:47:51 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
16:48:08 <pavonia> No, I haven't
16:49:15 <ReinH> You should definitely read it.
16:49:32 <ReinH> Basically anyone doing anything with threads and Haskell should read it.
16:58:01 <pavonia> Hhm, writing the MVar in onDisconnect seems to work. There must be a subtle difference between these two events in that library
17:00:28 <pavonia> Well, yeah, it's bookmarked, but my priority is on getting the program run at the moment :p
17:00:41 <pavonia> ReinH: ^
17:30:25 <ReinH> pavonia: fair enough
17:31:40 <awpr>  my favorite dirty trick to force the main thread to deadlock is to wrap up a reference to an MVar in a FunPtr and then never free it.
17:36:15 <ReinH> Er. Why?
17:36:48 <ReinH> Really the main thread should supervise the child thread, exiting when the child thread exits. Thus `wait'.
17:37:51 <Welkin> unless they want to see a movie
17:37:58 <lilred> hey all, I'm new to Stack. I'm running Alex and Happy on some files at build time, can I make Stack do it for me or should I write a Makefile?
17:38:01 <Welkin> then the grandparent thread or a neighbor thread needs to take over
17:39:04 <monochrom> haha
17:41:18 <damnthosestring> Is anyone familiar with using parseJSON with nested objects>
17:44:42 <ReinH> Welkin: :p
17:44:56 <pavonia> ReinH: Would async/wait also work if the spawned thread starts new threads on its own?
17:45:13 <ReinH> You would probably need to construct a supervision tree
17:45:18 <ReinH> where parents supervise their children
17:45:27 <ReinH> async has various tools for this
17:46:09 <johnw> I suggested async about an hour ago
17:48:05 <pavonia> Oh, indeed, sorry :S
17:48:16 <ReinH> johnw: yep
17:48:38 <ReinH> I was referring to your answer :)
17:50:21 <johnw> \o/
17:50:26 <pavonia> The functions beside async and wait look overly complicated to me
17:50:44 <johnw> link is also very helpful, as well as withAsync
17:50:47 <johnw> other than that, you can ignore the rest
17:51:36 <hunteriam> Ido you think this idea would be good?
17:51:55 <hunteriam> If we could annotate every function with requirements about inputs and guarantees about outputs
17:52:16 <hunteriam> Such as myFunction requires arg1==arg2 and guarantees length out ==1
17:52:39 <lilred> anyone here with Stack experience?
17:53:16 * hackagebot workflow-osx 0.0.0 - a "Desktop Workflow" monad with Objective-C bindings  https://hackage.haskell.org/package/workflow-osx-0.0.0 (sboo)
17:54:28 <damnthosestring> Guys, what on earth does Non-exhaustive patterns in function parseJSON even mean ==
17:55:22 <glguy> It means that none of the patterns matched the value that patterns were being matched against
17:56:29 <glguy> Someone (possibly you) wrote a bad FromJSON instance
17:56:49 <damnthosestring> I'm trying to nest a bunch FromJSON instance
17:57:05 <damnthosestring> they all work individually but when i put them together, its throwing these errors :(
17:57:23 <glguy> The error message tells you which line to look at
17:57:33 <glguy> figure out which cases you omitted and add them
17:58:34 <damnthosestring> thanks for the tip, I will try to take a closer look
17:58:50 <xpilot> does anyone know how the ad package deals with sharing in reverse mode?
17:59:10 <xpilot> it seems hard to do without effects
17:59:53 <pavonia> hunteriam: You can encode much information by using the right types, e.g. if you want your function to return only a single value, don't use a list as return type
18:02:29 <arahael2> hunteriam: If arg1 ==arg2 then why not only provide arg1?
18:03:25 <arahael2> you only need: :: a → b
18:04:37 <arahael2> rather than: :: a → a' → [b]
18:04:51 <hunteriam> That's just an example
18:04:58 <hunteriam> You could make any random claim
18:05:16 <arahael2> I don't understand?
18:05:35 <hunteriam> Could claim f a b == c
18:05:41 <hunteriam> As a requirement for your function
18:05:54 <hunteriam> Anyone who wants to use your function has to make the same claim
18:06:00 <hunteriam> About what they input
18:08:28 <arahael2> Isnt that what Idris and Adga allows?
18:09:39 <hunteriam> Does it really allow those kinds of claims?
18:09:44 <hunteriam> I thought it was kind of limited
18:13:15 <arahael2> I have been lead to think they do, with dependent types.
18:15:06 <arahael2> l haunt used either language though.
18:31:04 <eigensheep> Is there a library for labels out there? like a collection of objects with each object associated with a set of tags
18:31:36 <eigensheep> and efficient lookup that takes a set and finds all objects with a superset of that set
18:32:06 <eigensheep> Searching for labels and tags brings up something different
18:36:55 <hunteriam> Something like a bunch of maps?
18:37:36 <eigensheep> well yeah it probably would be a bunch of maps behind the scenes
18:38:03 <eigensheep> but i was hoping somebody might have already made it so I wouldnt need to bother
18:38:28 <eigensheep> and I couldnt tell because labels and tags are used for a different concept and I don't know what else to search for
18:50:09 <pavonia> eigensheep: "and efficient lookup that takes a set and finds all objects with a superset of that set" -- What superset do you mean here?
18:50:46 <eigensheep> so the lookup would take a set of tags, Q
18:51:14 <eigensheep> and return all objects in the collection associated with a superset of Q
18:53:17 <pavonia> Hhm, I was looking for something similar a while ago but didn't find anything
18:53:55 <eigensheep> well thats very useful information, because it means I can stop looking and start writing one
18:54:08 <eigensheep> so thanks for that
18:56:02 <hunteriam> You should upload it when you're done for future yous eigensheep
18:56:19 <eigensheep> will do
18:56:48 <pavonia> On the other hand, I also don't know if these structures have a special name and I didn't find something because of missing that name :p
18:57:33 <eigensheep> Ruby calls it tags
18:57:43 <eigensheep> And I've heard it called labels before
18:58:09 <pavonia> What I needed was structure for hierarchical categories with keywords associated to these categories an vice versa
19:30:02 <damnthosestring> Trying to learn monads, what do I do with this return type IO (Either String Person)?
19:30:23 <damnthosestring> it just shows Right (....)
19:31:06 <Cale> damnthosestring: The most likely thing you do with an IO action is to execute it
19:31:28 <Hafydd> damnthosestring: you need to pattern-match (e.g. using a case statement) on the two possible cases for Either String Person, namely Left String and Right Person.
19:31:47 <Cale> damnthosestring: You can execute an IO action from inside another IO action by using do-notation.  v <- x  will execute the IO action x, and name whatever its result is v
19:31:54 <Cale> (inside of a do-block)
19:32:10 <Cale> In this case, if x :: IO (Either String Person), then v :: Either String Person
19:32:35 <Cale> and you can then use a case expression to discriminate whether you have  Left str  or  Right person
19:32:36 <damnthosestring> I feel like it is so hard to learn haskell 
19:32:41 <damnthosestring> :(
19:32:56 <Cale> So it would look something like:
19:33:43 <nshepperd> what do you mean 'it just shows Right (....)'? you ran it in ghci?
19:33:58 <Cale> main = do result <- tryGetPerson; case result of { Left err -> putStrLn ("There was an error: " ++ err); Right p -> ... something with p ... }
19:33:59 <damnthosestring> yeah i ran it in terminal just to check what it looks like
19:34:37 <Cale> When you give an IO action to GHCi, it will execute it, and then if the result is something that it knows how to print (i.e. for which there's an instance of Show) it will display that.
19:34:53 <damnthosestring> ohhhh
19:35:05 <awpr> damnthosestring: basically the only thing you can do with IO anything is combine it into a larger IO somethingElse in the way Cale is describing, or make it run as main or in GHCI
19:36:23 <damnthosestring> thanks for the explaination, I'm going to test it out
19:36:51 <awpr> but we commonly talk about the former as "running it within another IO action" or "executing" it because it's convenient.
19:48:35 <crocket> Haskell community seems to focus on quality, but people say cabal is not of quality.
19:48:44 <crocket> It's weird
19:49:15 <crocket> The quality of language seems to be inversely proportionate to the quality of language tooling.
19:50:00 <hunteriam> Haskell is largely fueled by academics
19:50:14 <hunteriam> And academics are largely working on computer science problems
19:50:19 <hunteriam> Not really on their environment
19:51:01 <arkeet> I wouldn't say largely.
19:51:48 <orion> I need to write a library which defines many abstract higher order functions, but leaves the implemention of the low-level/base functions to the application. Are there any libraries which demonstrate this design pattern in a clear and organized way?
19:52:58 <roconnor> I'm not sure people complain about the quality of the cabal tool;  AFAIU it implements it's specification solidly.  The question is about whether the specification is really what we want to have.
19:53:16 <awpr> orion: depending on how well-founded the set of 'base functions' is, you might put them in a typeclass and parameterize your library functions over that class; or, just have each function take a record of functions.
19:53:35 <awpr> orion: Data.Set and Data.Map do this with the Ord typeclass, for example
19:53:43 <roconnor> The premise of a system wide consistent set of packages of all haskell applications is questionable.
19:54:09 <roconnor> But I remember what it was like before Cabal.
19:54:18 <orion> awpr: It's a crypto library. The application provides me with the cryptographic primitives, and I perform higher order tasks like handshakes, etc.
19:54:22 <roconnor> Just a few isolated bits of Haskell software.
19:54:28 <roconnor> Now there is heaps
19:54:56 <roconnor> I also remember what it was like before people had upper bounds on their packages.
19:55:12 <roconnor> As awful as upper bounds are, is was way worse before.
19:55:22 <orion> awpr: Using a typeclass was my first thought, which you seem to agree with.
19:55:34 <kristof> LazyIO is slightly unpredictable, while strict IO often requires a lot of thought to use properly.
19:55:55 <kristof> Is there any middle ground that sort of defers to a buffer and some kind of io strategy?
19:56:07 <kristof> To keep things predictable.
19:56:13 <awpr> actually if the base functions are crypto implementations, I don't think typeclasses offer anything over records of functions
19:56:21 <kristof> But also handles loading and flushing for you.
19:56:26 <bitemyapp> kristof: it's not that hard in practice.
19:56:42 <kristof> bitemyapp: The strategy or just using strict IO as is?
19:56:46 <exio4> kristof: pipes/conduit?
19:56:50 <hunteriam> in general haskell to me is very unpredictable
19:56:57 <awpr> kristof: this is the goal of streaming libraries like pipes, conduit, quiver, and io-streams
19:56:58 <orion> awpr: How so?
19:56:59 <hunteriam> one of the things i imagine a future language will have is less of that
19:57:11 <hunteriam> i really cant reason reliably about whats going on under the surface in haskell
19:57:14 <exio4> hunteriam: which stuff is unpredictavle?
19:57:26 <hunteriam> for example, ive got no clue what will be optimised, and what will be slow
19:57:32 <bitemyapp> kristof: 99% of the code we write at work is written with zero consideration given to lazy/strict/whatever.
19:57:50 <kristof> bitemyapp: I dunno what your dayjob is
19:57:53 <hunteriam> bitemyapp: any chance you guys are looking for interns?
19:57:54 <bitemyapp> kristof: the data processing stuff is written in terms of Pipes and we use NFData in the consumers.
19:57:55 <hunteriam> for this summer
19:58:00 <bitemyapp> kristof: that's really it.
19:58:16 <crocket> People who used clojure and haskell say leiningen is easier to use than cabal.
19:58:25 <roconnor> hunteriam: I took a course once that discussed the Graph-reducing machine.  I think it gave me a fairly reasonable intuation of how Haskell functions will perform, even if the picture isn't really accurate.
19:58:45 <crocket> The difficulty : Leiningen < Gradle < cabal
19:58:49 <hunteriam> roconnor: an undergrad course?
19:59:02 <kristof> bitemyapp: I'll take your word for it then
19:59:07 <kristof> Pipes are great :o
19:59:13 <roconnor> hunteriam: Um, I took it as a grad student, but I forget if it was an upper year undergrad course or not.
19:59:16 <kristof> just link them up and watch them go!
19:59:21 <exio4> hunteriam: well,  wouldn't say that is "unpredictable" but "unknown to you"
19:59:27 <hunteriam> roconnor: what kind of grad schools teach this sort of thing?
19:59:35 <roconnor> hunteriam: This was at UC Berkeley.
19:59:37 <bitemyapp> kristof: if you're write code that will run indefinitely, retain references to things indefinitely, process a dataset larger than the memory allocated to it, then it's worth giving some thought to.
19:59:45 <awpr> orion: well, typically crypto primitives don't vary in types, they're just fixed.  and, there aren't really any laws you could apply to crypto primitives
19:59:57 <bitemyapp> kristof: but that's true in any language and generally the "slap a streaming library on it and nfdata the terminal points" has worked fine for us.
20:00:01 <bitemyapp> kristof: I work in ad-tech.
20:00:25 <kristof> I was actually looking at doing some processing on a 5GB file, yeah
20:00:28 <bitemyapp> I have a more precise understanding of what's going on than that, but you really just have to exercise some sensibility.
20:00:41 <roconnor> hunteriam: but maybe you can find some internet resources teaching how the Graph-reducing machine, or G-Machine, works.
20:00:45 <bitemyapp> "is this a streaming problem?"
20:00:50 <bitemyapp> if yes -> use a streaming library
20:01:05 <exio4> hunteriam: well, I didn't take any undergrad or grad course that did show me that, I have read a few papers and read a little bit else and I found it to be way `simpler` that way
20:01:26 <hunteriam> does anyone have tips on how to get into a grad school like UC berkeley?
20:02:07 <kristof> bitemyapp: I have no need for what I'm about to ask, but surely you should optimize how much you slurp out of IO at a time, right?
20:02:19 <roconnor> My tip is to avoid north american grad schools.  Go to Europe.
20:02:22 <kristof> bitemyapp: Oh, but all you need to do that is deepseq a buffer the size of what you need, huh?
20:02:23 <bitemyapp> kristof: if you want, sure.
20:02:26 <hunteriam> why roconnor 
20:02:33 <hunteriam> and my primary concern is even being accepted
20:02:43 <bitemyapp> kristof: don't deepseq blindly. Benchmark & measure.
20:02:44 <roconnor> In Europe they will pay to be a grad student, rather than you paying them.
20:03:00 <bitemyapp> kristof: use a streaming library.
20:03:01 <hunteriam> roconnor: what are good cs grad schools in europe?
20:03:04 <roconnor> well, some places in europe, like the netherlands, germany, probably belgium and france.
20:03:07 <bitemyapp> kristof: what format is this file?
20:03:25 <hunteriam> roconnor: well, im cursed to only speek english. maybe itd be worth learning a language for one of these places though
20:03:28 <hunteriam> speak
20:03:35 <hunteriam> and thats why i wont get into grad school
20:03:39 <kristof> bitemyapp: 5GB worth of a handrolled metadata-and-numbers record format
20:04:18 <bitemyapp> kristof: write a streaming parser
20:04:21 <bitemyapp> kristof: learn from pipes-csv
20:05:01 <roconnor> I ended up in the Netherlands.  They all speak English there, esp. at the university.
20:05:22 <hunteriam> roconnor: are you in grad school currently? what do you thinks most important for getting in
20:05:23 <roconnor> Germany seemed the same.
20:05:24 <kristof> bitemyapp: Actually, I figure I can just stream chunks and then parse those after the fact.
20:05:39 <roconnor> France, less so. :)
20:05:40 <hunteriam> I love computer science but my grades from my first year are pretty sloppy
20:05:57 <kristof> Oh, that's actually not as good as a streaming parser, you're right.
20:05:59 <kristof> ok.
20:06:21 <roconnor> hunteriam: I finished my Ph.D in 2009
20:06:28 <bitemyapp> kristof: I think I've planted the right seeds. I'll let you figure out the rest.
20:06:36 <kristof> bitemyapp: Sure :)
20:07:06 <roconnor> hunteriam: If you are interested, you can just apply and see what happens.
20:07:37 <hunteriam> roconnor: well im not a senior yet, so ive still got time to make myself look pretty for grad schools
20:07:43 <roconnor> yep
20:08:33 <Hafydd> To tart yourself up, as it were.
20:13:48 <rpfun> is this a good usecase for typeclasses: I would like to work with objects A of different types that contain different information, but I would like to have some common functions "A -> stuff", for example "A -> Int, A -> (Int -> Maybe [Int]), A -> (Int -> a) -> [Int] -> a", etc. the reason i am hesitant to think typeclasses are a good solution is that all my functions ahve A only on the left
20:15:04 <rpfun> the thing is i would like some guarantees that for a,b of type A, a == b => the functions i get above from a and be are equal
20:17:38 <codebje> rpfun, the type system won't guarantee equality of values
20:17:58 <codebje> (and still be useful to your purpose)
20:18:12 <rpfun> if i implement it as a typeclass it will; what i am saying is that i want a function like f :: A -> (Int -> Maybe [Int])
20:18:36 <rpfun> if f is part of a typeclass, and a, b are part of A, then a == b => f a == f b
20:18:42 <codebje> oh, right
20:18:43 <rpfun> in the sense of equality of functions
20:18:58 <rpfun> so that is why i am a little tempted to use typeclasses
20:19:03 <codebje> the typeclass isn't necessary, then
20:19:30 <codebje> f :: a -> (Int -> Maybe [Int]) by referential transparency guarantees that for two identical a you'll get the same output
20:20:01 <rpfun> certainly, but i need different implementations for different as
20:20:15 <codebje> yeah, the typeclass is to let you have different implementations of f for different types
20:20:26 <rpfun> the two alternatives are: 1) have typeclass with f :: A -> (Int -> Maybe [Int]), instance for each A
20:20:56 <rpfun> 2) have some datatype "data B a = B { a :: A, f :: Int -> Maybe [Int] }"
20:21:12 <rpfun> (2) seems a bit better, but loses the equality
20:21:25 <rpfun> unfortunately, in my usecase B would grow quite large
20:21:30 <rpfun> since there are many things like "f"
20:21:34 <awpr> rpfun: 3) have a record type with all the functions in the typeclass without a value of A
20:22:02 <awpr> which is identical to the typeclass approach except that you name the dictionary explicitly
20:22:56 <rpfun> awpr: thanks, that is what i meant along the lines of B a, i included A since practically in my application you always also want to have A, but your way works
20:23:07 <rpfun> i still have the issue of implied equality though
20:23:31 <rpfun> awpr: your solution doesn't have a == b => record from a == record from b
20:23:54 <rpfun> the question becomes whether i should have a typeclass with a function "f :: A -> awpr's record"
20:24:21 <awpr> rpfun: wait -- a ~ b or value of a == value of b?
20:24:31 <rpfun> awpr: value of a == value of b
20:25:33 <rpfun> so is it considered bad form to have a typeclass with just one method, class C A where f :: A -> B?
20:25:56 <hunteriam> awpr: ~ is type equality?
20:26:12 <awpr> rpfun: IsString is a typeclass of that form, so probably not.  but, I think I miscommunicated my suggestion
20:26:28 <awpr> hunteriam: yeah, see the DataKinds extension
20:26:31 <ggole> Functor is such a typeclass too
20:26:42 <hunteriam> awpr: ive glanced at it but it seemed to dense for me to process
20:26:51 <rpfun> ggole: not quite, since functor has "f" in both the argument and result
20:27:08 <awpr> hunteriam: fair enough.  a ~ b is a constraint that's only satisfied if a and b unify
20:27:10 <rpfun> ggole: i guess it seems to me that functor makes more sense to me as a typeclass than what I have
20:27:18 <hunteriam> awpr: unify?
20:27:45 <exio4> awpr: DataKinds? the compiler suggest GADTs or TypeFamilies to me :P
20:28:02 <awpr> hunteriam: Either a Int unifies with Either String b (where a and b are free variables, not universally quantified)
20:28:21 <awpr> exio4: my bad, I always forget which barely-related extension comes with ~
20:28:45 <ggole> rpfun: right, I was thinking of the "just one method" part
20:29:01 <exio4> we need TypeEquality!
20:29:08 <hunteriam> awpr: so unify is "they could be the same type"
20:29:23 <hunteriam> or the intersection of there types is non-zero?
20:29:35 <awpr> hunteriam: yeah, that's a good description.  look up Hindley-Milner type inference if you want a precise description
20:29:39 <rpfun> ggole: of course, i wasn't being clear.
20:29:57 <rpfun> i guess i'll go with the typeclass anyway, doesn't seem to be a good alternative. i've just been scared off typeclasses by the literature on the web that seems to discourage them very strongly
20:30:05 <awpr> rpfun: the record I was talking about is 'data B a = B { f :: a -> Int, g :: a -> (Int -> Maybe [Int]) }'
20:30:23 <awpr> rpfun: which does have the property you were talking about by referential transparency
20:31:58 <awpr> well, each member of the record has that property.  of course you could make any number of records for a type
20:36:16 <rpfun> awpr: does this method carry some advantage?
20:37:16 <awpr> rpfun: it prevents people from accusing you of typeclass abuse :)
20:38:04 <awpr> more seriously, it allows having different sets of implementations for the same type, which typeclasses rule out
20:38:31 <rpfun> awpr: if i'd like to (or at the very least am fine with) ruling that out, are typeclasses "OK" for this?
20:39:25 <awpr> I don't see any problem with it, then.  as long as the types plus some set of laws (maybe empty?) are enough to guarantee the properties you'll assume about them
20:52:56 <wedens> how can I read CSV using cassava with strings like: Abc\, def ? 
20:53:12 <wedens> with escaped separator
20:53:33 <wedens> string is not surrounded in "
20:59:14 <pavonia> wedens: You probably can't
20:59:40 <wedens> is there any other csv library that allows to do it?
21:00:48 <wedens> or do I need to build my own parser?
21:03:35 <pavonia> I don't know if another library supports this, but I presume they all stick to the standard which doesn't allow this
21:04:33 <umib0zu> anyone up?
21:04:54 <umib0zu> assuming the world is round here and someone in China is up
21:05:24 <Hafydd> No, literally everybody in the channel is asleep.
21:05:34 <awpr>  ^ me too
21:07:54 <wedens> pavonia: there is no standard. sadly. especially on escaping
21:08:48 <pavonia> Well, there's RFC4180
21:18:23 * hackagebot papillon 0.1.0.1 - packrat parser  https://hackage.haskell.org/package/papillon-0.1.0.1 (YoshikuniJujo)
21:28:23 * hackagebot papillon 0.1.0.2 - packrat parser  https://hackage.haskell.org/package/papillon-0.1.0.2 (YoshikuniJujo)
21:38:24 * hackagebot peyotls 0.1.6.10 - Pretty Easy YOshikuni-made TLS library  https://hackage.haskell.org/package/peyotls-0.1.6.10 (YoshikuniJujo)
22:18:09 <agent_dtscode> is : a builtin function?
22:18:11 <lpaste> f-a pasted “pipes & files” at http://lpaste.net/142110
22:18:44 <f-a> ^-- trying to get started with pipes-files, I get I type error I kind of understand but don't know how to solve
22:18:52 <johnw> hi f-a
22:19:06 <f-a> hello johnw 
22:19:07 <johnw> use: runSafe $ runEffect
22:19:52 <johnw> I had forgotten that queries are monoids :)
22:20:27 <johnw> it might need to be runSafeT
22:20:35 <f-a> johnw: many thanks, using runSafeT made the error go away. A couple of questions if you have time
22:20:40 <johnw> sure
22:20:57 <f-a> I thought pipes and conduits were two different libraries and apparently pipes-files uses both, is that correct?
22:21:11 <johnw> it shouldn't use Conduit at all
22:21:50 <f-a> sorry I must have mistead the dependencies
22:22:06 <johnw> the predecessor, find-conduit, did use Conduit
22:22:09 <f-a> (worse: I saw CondT and assumed)
22:22:12 <johnw> so it's possible there's a docstring I hadn't updated
22:22:15 <johnw> oh, haha
22:23:07 <f-a> second, this is my use case: I have a little program http://hackage.haskell.org/package/lentil that, first thing, traverses some directories
22:23:35 <f-a> when the tree is big it takes some time, and I planned to use pipes pipe-files to display a "running total of file parsed"
22:23:49 <f-a> (pipes-concurrency too). Am I using the right tools?
22:23:57 <johnw> yes
22:24:06 <johnw> pipes-files will stream the files in so that you can do things as they arrive
22:24:11 <f-a> well, that for sure makes me more confident
22:24:14 <johnw> btw, see pipes-async
22:24:32 <johnw> if you have a place where you now use >->, you can switch to >&> to introduce concurrency at that joining point
22:24:51 <johnw> pipes-concurrency is much lower level
22:24:54 <hunteriam> is calculus relevant in type theory at all
22:25:02 <hunteriam> or category theory and so on
22:25:05 <johnw> hunteriam: you can take derivatives of types...
22:25:23 <hunteriam> johnw: what does the derivative of a type represent
22:25:35 <johnw> a type with its "one hole context"
22:25:47 <f-a> very nice, thanks for your help
22:25:55 <johnw> i.e., you extract a variable, and you're left with a hole and everything else that might go around it to integrate it back into a whole
22:27:22 <johnw> so, x^2, or Bool -> x, becomes 2x, or (Bool,x).  Meaning, the derivate will be either "half" of the values represented by Bool -> x.  If you give me that half back, I can reconstitute the Bool -> x.  There is a neat paper about this, if you're further interested.
22:27:45 <johnw> since I just butchered the description myself
22:28:02 <johnw> http://strictlypositive.org/diff.pdf
22:28:25 <johnw> also see https://youtu.be/K7tQsKxC2I8
22:29:04 <johnw> f-a: please e-mail me if you have more questions and can't find me here; since I haven't really announced pipes-files yet, it doesn't have very many users, so I'd like to hear about any real experiences you have
22:29:32 <rhz> any Homebrew users here that know how to install multiple versions of GHC?
22:30:12 <f-a> johnw: I'll make sure to email you whichever the result of my experimentations is. I feel pipes  (composable/side-effect/stream)  are quite awesome but a tad intimidating to folks like me.
22:30:42 <glguy> rhz: I don't know about Homebrew, but you can have multiple versions of the GHC for OS X app bundle installed at once easily
22:31:09 <glguy> and you can have multiple installs of the binary distribution from haskell.org/ghc by default
22:31:12 <johnw> f-a: their bark is vastly greater than their bite :)
22:31:22 <f-a> \o/
22:33:17 <rhz> glguy, oh. didn't know that
22:34:58 <rhz> glguy, even with the binary distribution from haskell.org/ghc? They don't conflict?
22:35:34 <glguy> They install into different directories by default (in /usr/local) but typically I install them into my home directory specifying --prefix=
22:35:38 <glguy> but either way works
22:42:21 <f-a> johnw: *** Exception: Cannot decode byte '\xad': Data.Text.Internal.Encoding.Fusion.streamUtf8: Invalid UTF-8 stream <-- upon running my pipes thingie. Do  you happen to know how to solve this one too?
22:42:36 <rhz> glguy, what about cabal packages that I install. Are they good for all ghc installations?
22:42:59 <glguy> No, they are per-version of GHC
22:43:11 <liste> f-a is are you sure your input is UTF-8?
22:43:39 <rhz> ok what about the cabal executable itself?
22:44:08 <f-a> liste: I think it should be a file list, so not at all, but have no idea how to change encoding (or let the program guess)
22:44:26 <dfeuer> What happened between GHC 7.4 and 7.6 to make the compiler so much slower?
22:45:08 <liste> f-a guessing encoding is just that, guessing. where does the input come from?
22:45:16 <glguy> rhz: the cabal executable works on multiple versions. You can specify a GHC version  to use with the -w flag
22:45:33 <lpaste> f-a pasted “encoding” at http://lpaste.net/142111
22:45:56 <f-a> ^-- liste this is my snippet.
22:46:37 <f-a> I am just cannibalising other people's example, but it should just output a list of files
22:49:38 <liste> f-a doesn't look like the bug is in your code
22:50:39 <dfeuer> At last! I got poly-kinded Equality, AnEquality, etc., to work for lens in GHC >= 7.6!
22:50:44 <rhz> glguy, I'm getting permission denied errors from cabal using the -w flag
22:51:53 <glguy> rhz: I'd guess you're giving it the wrong argument, then. Maybe you can paste more information on the pastebin and someone could spot the problem
22:53:46 <dfeuer> Hrmm.. I wish I could make this type synonym take a kind argument...
22:54:02 <lpaste> rhz pasted “cabal install with -w flag failure” at http://lpaste.net/142112
22:54:52 <glguy_> You upgraded to osx10.11?
22:54:59 <f-a> liste: thanks, I'll see what the author will say
22:55:41 <rhz> Yup
22:55:48 <dfeuer> glguy, do you know if there's a way to effectively have a type synonym/family take a *kind* argument?
22:55:56 <glguy_> I don't
22:56:07 <dfeuer> Hrmmm...
22:56:18 <rhz> oh
22:56:18 <glguy_> Rhz: your cabal executable is too old for the new osx
22:56:55 <rhz> glguy_, but it worked fine without the -w flag..
22:56:59 <dfeuer> I really want this type synonym parameterized over the kind of one of the arguments to a universally quantified thingumjigger.
22:57:25 <exio4> dfeuer: in GHC 8.x? :P 
22:57:31 <hunteriam> is haskell closely related to symbolic logic, to the point that that would be a class worth taking?
22:57:35 <dfeuer> exio4, I don't have that yet :P
22:57:43 <exio4> dfeuer: (with the `kind` / `type` unification!) 
22:57:59 <dfeuer> exio4, sounds likely.
22:58:28 <dfeuer> exio4, I'm generalizing Equality in lens to     type Equality (s :: k1) (t :: k2) (a :: k1) (b :: k2) = forall (p :: k1 -> * -> *) (f :: k2 -> *) . p a (f b) -> p s (f t)
22:58:45 <rhz> glguy_, anyhow I'm using the latest release of cabal. Do I need to checkout from github or something?
22:59:14 <dfeuer> But really I want    GenEquality k3 . . . = forall (p :: k1 -> k3 -> *) (f :: k2 -> k3) . ...
22:59:16 <glguy_> Rhz: the flag is working fine. Either the error matching the well known 10.11 issue is due to that issue or GHC 7.8 isn't compatible
22:59:54 <Bez_> :t zipWith
22:59:56 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
23:00:18 <glguy_> Rhz: that output said cabal-1.18 where did you get your latest release of cabal?
23:00:39 <dfeuer> because then I could apply an equality to a lot more things directly.
23:01:57 <Bez_> :t map
23:01:58 <lambdabot> (a -> b) -> [a] -> [b]
23:03:24 <dfeuer> @free (a -> b) -> [a] -> [b]
23:03:24 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
23:03:42 <dfeuer> @free (a -> b) -> F a -> F b
23:03:42 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
23:03:46 <dfeuer> hrm
23:05:24 <dfeuer> @free map :: (a -> b) -> [a] -> [b]
23:05:24 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
23:15:35 <orion> It's been said that if implementations of an abstract concept follow certain laws, we should prefer type classes. Could data types and HOFs be used to, say, implement Monad? If so, why would that be a bad thing?
23:18:27 * hackagebot lentil 0.1.6.2 - frugal issue tracker  https://hackage.haskell.org/package/lentil-0.1.6.2 (fffaaa)
23:19:55 <rhz> glguy_, cabal --version on the cmd line gives me: cabal-install version 1.22.6.0
23:20:27 <rhz> i dunno why the in the output it's using a different version
23:20:58 <glguy_> It needs to be built against unix-2.7.1.0 for the 10.11 issue
23:24:12 <rhz> glguy_, you mean cabal?
23:24:19 <rhz> cabal-install, that is..
23:27:29 <glguy> rhz: I wasn't able to use GHC 7.8.4 to build a package on 10.11 either (just tried)
23:28:28 * hackagebot equational-reasoning 0.2.0.6 - Proof assistant for Haskell using DataKinds & PolyKinds  https://hackage.haskell.org/package/equational-reasoning-0.2.0.6 (HiromiIshii)
23:30:38 <glguy> I don't know if that's because I need to rebuild GHC 7.8.4 against the current environment (it's an install left over from preupgrade)
23:30:50 <glguy> or if 7.8.4 is incompatible
23:32:49 <rhz> oh boy
23:33:52 <rhz> well, the whole reason for this rigmarole is because I need to link against OpenGL stuff, and apparently this is broken in GHC 7.10.
23:34:51 <glguy> Good news, but early adopting you're on the front lines with us to figure it out!
23:34:54 <glguy> by*
23:35:39 <arahael> glguy: OpenGL is currently for "early adopters"? Wasn't it supported for a decade or so already?
23:35:51 <glguy> No, os x 10.11 is
23:36:08 <arahael> Ah.
23:36:58 <rhz> i knew i shouldn't have clicked that upgrade button yesterday
23:37:11 <rhz> oh well
23:38:53 <glguy> Good news, ghc 7.8.4 does work I was able to install a package manually using Setup.hs
23:45:50 <glguy> The problem seems to be that when you use cabal install -w ghc-7.8.4 it uses the old Cabal library to do the configuring which is built against the old unix
23:46:09 <glguy> but building the Setup.hs files using the ghc-7.10 with newer cabal/unix I don't get the permission error
23:46:34 <glguy> so I'm trying to install Cabal library in 7.8.4 now against manually updated deps to see if that fixes cabal-install
23:47:43 <glguy> rhz: it worked :)
23:48:15 <rhz> glguy, I just trashed my ghc-7.8.4 installation
23:48:40 <rhz> I'm trying to build the OpenGL package now...
23:48:42 <glguy> manually updated to directory-1.2.4.0, process-1.2.3.0, unix-2.7.1.0, Cabal-1.22.4.0 and things are back in order
23:49:10 <glguy> The OpenGL framework issue can be worked around manually passing flags
23:49:17 <glguy> on 7.10
23:49:33 <glguy> had to do that earlier this week to do something with gloss
23:55:17 <dfeuer> glguy, I realized that I can do, not what I said, but what I actually *wanted* in recent GHC.
23:55:24 <jle`> orion: that's what was suggested by Tekmo in his old "scrap your typeclasses" post, which on hindsight seems like it was advocating for extreme things to make a point
23:56:34 <glguy> dfeuer: What are you doing with Equalities, anyway?
23:56:51 <jle`> orion: you could make a data Monad m = Monad { return :: a -> m a; bind :: m a -> (a -> m b) -> m b }, and then pass them as arguments.
23:56:54 <bollu> mniip: ping? can you walk me through the intutition of the compare monoid?
23:56:56 <bollu> :t compare
23:56:57 <lambdabot> Ord a => a -> a -> Ordering
23:56:58 <dfeuer> glguy, playing with them :-)  https://github.com/ekmett/lens/pull/606
23:57:02 <bollu> Ordering*
23:57:59 <bollu> also, in lens, set x == over (const x) ?
23:58:10 <rhz> as it happens OpenGL-2.13.0.0 just installed without a hitch
23:58:14 <dfeuer> glguy, it sort of disturbed me to see that I could only use Equality s t a b as a proof of (s ~ a, t ~ b) if (s,t,a,b :: *)
23:58:23 <dfeuer> So I decided to see what I could do about that.
23:58:29 * hackagebot xml-conduit 1.3.2 - Pure-Haskell utilities for dealing with XML with the conduit package.  https://hackage.haskell.org/package/xml-conduit-1.3.2 (MichaelSnoyman)
23:58:31 <jle`> bollu: what do you have toruble understanding about Ordering?
23:58:39 <dfeuer> It turns out that I can do everything about that.
23:58:40 <jle`> it's LT, EQ, and GT
23:58:50 <jle`> > compare 5 10
23:58:50 <bollu> jle`: I don't understand how they form a monoid
23:58:52 <lambdabot>  LT
23:59:00 <bollu> jle`: I don't trust the associativity of an Ordering
23:59:20 <bollu> jle`: like, I don't get why ordering monoid should be associative
23:59:32 <jle`> well, if you don't believe in the monoid instance, you can manually verify by looking at the multiplication table
23:59:42 <bollu> jle`: xD yeah, but, maybe some more elegant? :)
23:59:46 <jle`> you can verify that (x <> y) <> z = x <> (y <> z) for all 9 combinations of x, y, and z
