00:05:49 <ReinH> Cale: :p
00:18:59 * hackagebot Hish 0.1.1.0 -   https://hackage.haskell.org/package/Hish-0.1.1.0 (jaiyalas)
00:20:02 <Lokathor> it worked in the end cale
00:20:18 <ewrewr> @djinn (a -> b) -> (a -> b)
00:20:18 <lambdabot> f a = a
00:20:39 <ewrewr> @djinn (a -> b) -> [a] -> [b]
00:20:39 <lambdabot> Error: Undefined type []
00:21:45 <ewrewr> @free fmap
00:21:46 <lambdabot> Extra stuff at end of line in retrieved type "Functor f => (a -> b) -> f a -> f b"
00:22:06 <ewrewr> @free Functor => (a -> b) -> f a -> f b
00:22:06 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
00:23:49 <ewrewr> > :i Functor
00:23:50 <lambdabot>  <hint>:1:1: parse error on input ‘:’
00:23:58 <jle`> ewrewr: did you know that you can use lambdabot on pm? :)
00:24:11 <jle`>  ie, /q lambdabot @djinn a -> b -> a
00:24:17 <jle`> also, there is no :i in lambdabot
00:25:39 <ewrewr>  @free fmap :: (a -> b) -> (F a -> F b)
00:25:57 <Hafydd> jle`: do you know what "i.e." stands for "id est," meaning "that is"?
00:26:53 <Hafydd> In particular, it does not mean "for example," which is more commonly expressed as "e.g."
00:28:13 <jle`> i thought it was somebody pronouncing the word "eye" :|
00:28:20 <jle`> or aye, like "yes," for pirates
00:28:21 <phadej> Found this package: http://hackage.haskell.org/package/async-pool, but revdeps says "only acme-everything", is there better package for this job?
00:28:32 <phadej> or can async do that by itself nowadays?
00:38:20 <newHaskellPerson> can someone around here help me with something?
00:38:57 <liste> newHaskellPerson absolutely
00:38:59 <liste> go ahead
00:39:17 <newHaskellPerson> so yeah, I've got my program, its almost finished
00:39:24 <newHaskellPerson> its supposed to print a matrix row by row
00:39:46 <newHaskellPerson> I've got it to print my rows, but I'm having a problem getting it to print every row
00:39:54 <newHaskellPerson> as it stands it only prints the first one
00:41:48 <magthe> newHaskellPerson: what's the type for your matrix?
00:42:44 <liste> @where lpaste -- newHaskellPerson paste your code here
00:42:44 <lambdabot> http://lpaste.net/
00:43:21 <newHaskellPerson> http://lpaste.net/143423
00:43:50 <newHaskellPerson> thats it, but I'm not sure how to make a loop that prints each column 
00:44:45 <newHaskellPerson> I've been thinking about it as a counter, but that doesn't work here since variables are immutable
00:45:16 <liste> :t intercalate -- newHaskellPerson 
00:45:18 <lambdabot> [a] -> [[a]] -> [a]
00:45:37 <liste> > intercalate "," ["hello", "world"]
00:45:38 <lambdabot>  "hello,world"
00:45:55 <newHaskellPerson> I see, thanks
00:45:58 <newHaskellPerson> I will try that
00:47:34 <newHaskellPerson> Although I'm not sure if I'm allowed to do that, since they expect me to print the matrix row by row
00:48:17 <magthe> newHaskellPerson: what's Matrix?  where does it come from?
00:48:20 <liste> just put line breaks between rows
00:48:52 <liste> > intercalate "\n" ["this", "has", "multiple", "line", "breaks"]
00:48:54 <lambdabot>  "this\nhas\nmultiple\nline\nbreaks"
00:48:56 <magthe> newHaskellPerson: what liste is talking about is a simpler definition of `listToString`
00:49:28 <liste> and you can't print one line at a time any other way with `show'
00:49:42 <liste> because it just produces a string, it doesn't print anything
00:50:03 <newHaskellPerson> Yes, but I'm trying to produce a string for the whole matrix
00:50:20 <newHaskellPerson> then just do putStr on that string 
00:50:29 <magthe> newHaskellPerson: indeed, but you need to map what you have over every row
00:50:29 <newHaskellPerson> and it should print everything properly
00:50:39 <liste> > intercalate "\n" (map (intercalate " ") [[1, 2, 3], [4, 5, 6]])
00:50:41 <lambdabot>      No instance for (Num [Char]) arising from the literal ‘1’
00:50:41 <lambdabot>      In the expression: 1
00:50:41 <lambdabot>      In the expression: [1, 2, 3]
00:50:50 <liste> > intercalate "\n" (map (intercalate " ") [[1, 2, 3], [4, 5, 6]])
00:50:52 <lambdabot>      No instance for (Num [Char]) arising from the literal ‘1’
00:50:52 <lambdabot>      In the expression: 1
00:50:52 <lambdabot>      In the expression: [1, 2, 3]
00:50:53 <liste> > intercalate "\n" (map (intercalate " ") [[1, 2, 3], [4, 5, 6]])
00:50:55 <lambdabot>      No instance for (Num [Char]) arising from the literal ‘1’
00:50:55 <lambdabot>      In the expression: 1
00:50:55 <lambdabot>      In the expression: [1, 2, 3]
00:50:57 <liste> sorry
00:51:10 <liste> > intercalate "\n" (map (intercalate " ") [["1", "2", "3"], ["4", "5", "6"]]
00:51:12 <lambdabot>  <hint>:1:75:
00:51:12 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
00:51:20 <liste> > intercalate "\n" (map (intercalate " ")) [["1", "2", "3"], ["4", "5", "6"]]
00:51:23 <lambdabot>      Couldn't match expected type ‘[[[Char]]] -> t’
00:51:23 <lambdabot>                  with actual type ‘[Char]’
00:51:23 <lambdabot>      The function ‘intercalate’ is applied to three arguments,
00:51:33 <ReinH> liste: please msg lambdabot
00:52:09 <liste> ReinH I will
00:52:13 <magthe> newHaskellPerson: I think it would be helpful to know where `Matrix` (the type) comes from, and what it looks like
00:52:30 <newHaskellPerson> ok I'll pass on the module they gave me
00:53:07 <liste> newHaskellPerson but yeah, do your listToString once for each row (to make them strings), and then to the resulting list of strings to produce one string
00:53:08 <newHaskellPerson> http://lpaste.net/143424
00:53:16 <newHaskellPerson> though its not very nice if you ask me 
00:53:37 <newHaskellPerson> took the whole day figuring out what it was supposed to be doing 
00:53:46 <newHaskellPerson> plus I'm also new at this language
00:54:47 <liste> newHaskellPerson are you familiar with map?
00:55:23 <newHaskellPerson> yes, I've used it, it maps a function on a list and then returns a new list 
00:55:42 <newHaskellPerson> didn't really get it all that well 
00:56:27 <liste> try :t map listToString in your ghci (:
00:56:42 <newHaskellPerson> ok I will try that
00:59:20 <liste> :t concat -- and also this
00:59:22 <lambdabot> Foldable t => t [a] -> [a]
00:59:43 <liste> :t concat `asAppliedTo` ["list", "of", "strings"]
00:59:44 <lambdabot> [[Char]] -> [Char]
00:59:55 <liste> [Char] is String
01:00:32 <newHaskellPerson> its giving me an error 
01:00:55 <liste> what error?
01:01:04 <liste> have you loaded your module?
01:01:10 <merijn> liste: If you're going to recmmend map first and then concat, why not
01:01:10 <newHaskellPerson> just a second
01:01:14 <merijn> :t concatMap
01:01:16 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
01:01:26 <newHaskellPerson>  Expected type: a -> b    Actual type: String  Possible cause: `listToString' is applied to too many arguments
01:02:42 <newHaskellPerson> isn't there just some way to call listToString n times or something, I know its probably not the best solution, but thats all I need it to do 
01:03:24 <liste> map (and concatMap) do just that, call it for every element in a list
01:03:39 <liste> did you put something after the listToString in your ghci?
01:06:16 <liste> > listToString [1, 2, 3]
01:06:19 <lambdabot>  "1 2 3\n"
01:06:27 <liste> :t map listToString
01:06:29 <lambdabot> Show a => [[a]] -> [[Char]]
01:06:45 <liste> :t concatMap listToString
01:06:47 <lambdabot> (Show a, Foldable t) => t [a] -> [Char]
01:07:24 <phadej> :t Data.List.concatMap listToString
01:07:25 <lambdabot> (Show a, Foldable t) => t [a] -> [Char]
01:07:44 <liste> > (concatMap listToString) [[1, 2, 3], [4, 5, 6]]
01:07:46 <lambdabot>  "1 2 3\n4 5 6\n"
01:08:34 <phadej> :t (listToString >>=) 
01:08:36 <lambdabot> Show a => ([Char] -> [a] -> b) -> [a] -> b
01:08:49 <phadej> :t (>>= listToString) 
01:08:50 <lambdabot> Show a => [[a]] -> [Char]
01:09:44 <lfairy> wow, concatMap uses Foldable now?
01:09:53 <phadej> lfairy: yes, FTP
01:09:59 <lfairy> crikey
01:10:05 <phadej> from base >=4.8
01:10:18 <phadej> almost everything uses Foldable/Traversable
01:10:20 <quicksilver> real haskellers use foldMap anyway :P
01:10:50 <quicksilver> :t concat
01:10:51 <lambdabot> Foldable t => t [a] -> [a]
01:11:46 <lfairy> just seems weird to me, how the outside is generalized but the inside is still specialized to []
01:14:02 <KaneTW> @src concat
01:14:02 <lambdabot> concat = foldr (++) []
01:14:04 <KaneTW> that's why
01:21:20 <quicksilver> lfairy: the general case is just 'fold'
01:21:23 <quicksilver> :t fold
01:21:25 <lambdabot> (Foldable t, Monoid m) => t m -> m
01:22:02 <lfairy> quicksilver: I know, which is why I was surprised that concat wasn't just an alias for it
01:22:05 <quicksilver> I think there were a few new-obvious choices in the FTP about generalisation vs leaving specific; 'map' stayed specific, concatMap and concat went half-specific, etc.
01:22:09 <lfairy> KaneTW's explanation made sense though
01:22:29 <quicksilver> I dunno 'we didn't feel like changing the source' isn't a very convincing reason :)
01:27:26 <stef204> hi, newb to Haskell and learning it. Have installed ghc-vis using stack, to visualise data, etc. (figuring any visualization provided by ghc-vis or vacuum-cairo, etc.) would help me better unserstand the language. Firing up ghc-vis from stack ghci, getting the following errors, here's the paste: https://bpaste.net/show/d7130cd3e89d
01:28:15 <stef204> I did try the #haskell-beginners but it was suggested to me there I take it here. If anyone has the patience, let me kow.
01:29:28 <stef204> oh, possibly, one of the cause of the problem is: "This binding for ‘x’ shadows the existing binding" but not sure.... ghci should still recognize command ":vis", I believe bit it doesn't seem to.
01:29:56 <stef204> s/now/know and s/bit/but
01:30:20 <vijaykiran> stef204: did you install the dependencies, Cairo and all .. ?
01:31:05 <stef204> yes, all is installed in its own directory via stack
01:31:14 <stef204> look at the paste
01:31:16 <stef204> please
01:31:34 <quicksilver> I don't think those warnings matter
01:32:08 <ski> nitrix : in that case there is a `->' in the type
01:32:12 <quicksilver> but I'm a bit confused why ghc-vis is apparently being compiled in response to you invoking ghci
01:32:14 <stef204> quicksilver: ok. So I may need to load some modules or something to get it started? It seems to load the modules already but short of experience here
01:32:25 <quicksilver> why wouldn't it have been compiled when you installed it?
01:32:34 <vijaykiran> stef204: I did - and the graphics-vis seems to suggest using cabal, maybe stack behaviour is different (?)
01:32:38 <stef204> quicksilver: I think it's just linking it no?
01:32:49 <quicksilver> no, it was compiling it.
01:33:07 <stef204> vijaykiran: that I really don't know but I want to avoid cabal
01:33:16 <quicksilver> I don't think you wanted to run 'stack ghci' inside that directory
01:33:39 <quicksilver> I think you wanted to *install* ghc-vis
01:33:44 <stef204> quicksilver: no? wo just use the system ghci outside directory?
01:34:03 * hackagebot graphviz 2999.18.0.2 - Bindings to Graphviz for graph visualisation.  https://hackage.haskell.org/package/graphviz-2999.18.0.2 (IvanMiljenovic)
01:34:10 <quicksilver> no, you want to install it.
01:34:20 <quicksilver> running "stack ghci" says "I am developing this project. I want a REPL here"
01:34:21 <magthe> quicksilver: I suspect stef204 is on a system with a GHC version that vis can't cope with
01:34:21 <stef204> quicksilver: yes i have already installed ghc-vis, stack unpack, init build, etc.
01:34:27 <quicksilver> you don't want to *develop* ghc-vis
01:34:30 <quicksilver> you want to run it.
01:34:51 <magthe> hense he's using stack to install it... and then he'll need to let stack set up the environment to get the correct ghci
01:34:51 <stef204> magthe: during stack install it should have downloaded an previous version of ghc, locally
01:35:32 <stef204> magthe: I think you're on the right track so what am I doing wrong here?
01:35:46 <stef204> quicksilver: nope, just use it
01:35:50 <magthe> stef204: no idea ;)
01:36:09 <stef204> magthe: ok
01:36:21 <magthe> how does ghci find the thing implementing `:vis`?
01:36:28 <quicksilver> unfortunately I've never used stack, I don't really understand how it works.
01:36:43 <vijaykiran> stef204: I'd say follow the cabal-sanboxed stuff, and then ask on stack mailing list 
01:36:49 <vijaykiran> stef204: so you can continue exploring :)
01:36:50 <stef204> magthe: that's a good question, don't know I thought just firing up stack ghci from the directory would do it
01:37:19 <stef204> stack mailing list is a good idea, didn't realize there was one
01:37:33 <magthe> vijaykiran: it's just that cabal-sandbox still uses the system GHC, doesn't it?
01:38:21 <vijaykiran> magthe: yup I think so
01:40:00 <stef204> ok, guys, thanks for feedback. will shoot an email to stack mailing list I suppose and I'll stick around...in case bright ideas come to mind, never know. Thanks.
01:41:34 <magthe> vijaykiran: so then the issue is that ghc-vis requires ghc 7.8; if one's system only offers 7.10 one would have to start with compiling ghc manually :(
01:45:35 <kriztw> stef204: I'm trying to build it now with stack
01:45:46 <kriztw> We'll see if I succeed :D
01:47:10 <stef204> kriztw: ok
01:52:26 <Unhammer> is there a equivalent to "runhaskell"  like "cabal repl" is to "ghci"?
01:54:10 <stef204> kriztw: the steps I used to build with stack: https://bpaste.net/show/c3ea2dc5906b
01:55:08 <stef204> I believe I am "using" the system-wide ghtk2hs-buildtools which could be the problem...
01:55:18 <kriztw> stef204: which distro are you on? I'm having to install a few other packages through apt
01:55:20 <stef204> come to think of it....
01:55:27 <stef204> Arch
01:55:55 <keko_> Unhammer: cabal run
01:56:07 <keko_> or no, wait, that's not the same thing
01:56:35 <stef204> I installed ghtk2hs-buildtools via pacman, Arch's package manager but again, this could have been the error, not installing it locally in the stack "sandbox" as well
01:57:09 <Unhammer> keko_,  yeah, that requires a .cabal :) just wondered if there was something as lightweight as runhaskell, but that used my sandbox (so I don't have to clutter my ~./cabal with stuff when just quickly trying out new libs)
01:59:50 <fizruk> Unhammer: cabal exec runhaskell? (I am guessing)
02:00:56 <kriztw> stef204: I can get it to launch, but I only get a white square
02:01:23 <stef204> kriztw: not good...
02:01:29 <kriztw> ah, I need to :view a variable
02:01:31 <kriztw> it works for me
02:01:41 <stef204> ok, do tell
02:01:57 <stef204> can you post to some pastebin the steps you followed, please?
02:02:32 <kriztw> stef204: sure, I'm on Ubuntu, so it might be slightly different
02:02:51 <Unhammer> fizruk,  oh thanks that works ="
02:02:52 <Unhammer> =D
02:03:09 <stef204> kriztw: I understand but still. How do you launch ghc-vis? :vis  ?
02:03:18 <kriztw> yes
02:03:32 <kriztw> after using stack ghci
02:03:36 <Unhammer> oh so I can even cabal exec ghci instead of cabal repl, if I want to exercise my typing muscles
02:03:44 <kriztw> and after putting a magic line in my ~/.ghci file
02:03:47 <kriztw> which stack recommended
02:04:14 <stef204> kriztw: right, that's what I do. I think I will rebuild it and also install ghtk2hs-buildtools locally in the "sandbox"
02:04:38 <kriztw> stef204: I don't have that package, I had to install the following
02:04:38 <stef204> kriztw: which magic line ?
02:04:40 <kriztw> libgtk2.0-dev
02:04:40 <kriztw> libghc-pango-dev
02:04:41 <kriztw> librsvg2-dev
02:04:41 <kriztw> libcairo2-dev
02:05:11 <stef204> kriztw: ok on packages. can you post magic line, please?
02:05:22 <kriztw> :script /home/kris/haskell/ghc-vis/ghc-vis-0.7.2.7/.stack-work/install/x86_64-linux/lts-2.22/7.8.4/share/x86_64-linux-ghc-7.8.4/ghc-vis-0.7.2.7/ghci
02:05:30 <kriztw> need to change the path ofc
02:05:49 <kriztw> and it needs to be non-world-writable, otherwise I got errors
02:05:55 <kriztw> the .gchi file that is
02:06:29 <stef204> but this is not typed inside ghci but manually added inside the ~/.ghci file, correct?
02:06:52 <kriztw> stef204: it's the same thing, .ghci is just run at launch
02:06:56 <kriztw> afaik
02:07:18 <stef204> ok so I can get away with typing magic line after launching ghci? I'm lost here
02:07:27 <Lokathor> mkGenList gen = genHead : mkGenList genTail where (genHead, genTail) = split gen
02:07:41 <kriztw> I think so, this is a first for me as well :D
02:07:44 <Lokathor> and now it's easier to perform simple checks of RNG stuff
02:07:47 <Lokathor> wooo
02:08:37 <kriztw> stef204: http://pastebin.com/vejSfMSA
02:08:48 <Lokathor> it's so obvious it seems like it should be in System.Random
02:09:04 * hackagebot Hish 0.1.2.0 -   https://hackage.haskell.org/package/Hish-0.1.2.0 (jaiyalas)
02:09:07 <stef204> kriztw: tx, looking
02:19:14 <gromak> I'm using pipes-network library. My client sends some data via sendMany (which is Effect), server reads it via fromSocket, which should stop when EOF is received, but it doesn't stop after sendMany. Are there any ways to force EOF apart from closing socket? I hoped that sendMany will do it, but looks like it doesn't :(
02:21:03 <stef204> kriztw: works!!
02:21:22 <stef204> thanks a lot, I was missing the magic line
02:21:43 <kriztw> stef204: great! And now I have it too, so thanks for showing it to me :D
02:21:48 <kriztw> neat tool
02:22:10 <stef204> kriztw: yes, I think it can be helpful to visualize, at least for me
02:22:57 <stef204> ok, off I go back to learning haskell :)
02:23:20 <stef204> thanks to all for feedback, much appreciated.
02:25:25 <gromak> Nvm, I understood that it is impossible to make what I wanted to achieve
02:49:49 <zipper> Hey, I'm trying to build haddock documentation with stack and haddock by running `stack haddock`
02:50:07 <zipper> The issue is that it ends in a failure and I don't see why.
02:51:43 <fizruk> zipper: what does it say?
02:51:56 <zipper> http://lpaste.net/5019011396700995584
02:52:00 <zipper> fizruk: ^
02:52:31 <fizruk> zipper: please, paste the whole output
02:52:45 <fizruk> the actual error is usually a few lines above
02:53:52 <zipper> fizruk: http://lpaste.net/4633764044409405440
02:54:10 <zipper> or do I have to document every exported function?
02:54:25 <zipper> I thought haddock just uses type signatures in those cases.
02:54:41 <fizruk> zipper: there is a parse error (look at line 17 of the paste)
02:55:03 <zipper> fizruk: Oh my thanks.
02:55:24 <fizruk> probably something before that definition is broken
03:23:27 <phale> is it possible to use a data-driven approach in haskell rather than a functional approach?
03:24:07 * hackagebot aws-cloudfront-signer 1.1.0.3 - For signing AWS CloudFront HTTP URL requests  https://hackage.haskell.org/package/aws-cloudfront-signer-1.1.0.3 (ChrisDornan)
03:24:09 * hackagebot keystore 0.8.0.0 - Managing stores of secret things  https://hackage.haskell.org/package/keystore-0.8.0.0 (ChrisDornan)
03:24:15 <liste> phale what do you mean by data-driven
03:24:26 <KaneTW> phale: soemthing like FRP?
03:24:30 <phale> liste: data-driven paradigm
03:24:48 <phale> KaneTW: not really
03:25:02 <phale> I've never used Haskell before and I tend to avoid functional programming
03:25:12 <phale> so I was wondering there was away to do it more imperatively
03:25:16 <phale> or in a more data-driven way
03:26:37 <KaneTW> not that i know of
03:26:42 <phale> oh alright
03:26:45 <KaneTW> why do you avoid functional programming
03:26:47 <liste> the Wikipedia description of data-driven programming looks like functional programming
03:27:01 <phale> liste: Alright well
03:27:05 <liste> "filtering, transforming, aggregating" == "filter, map, fold"
03:27:08 <phale> I still don't know haskell since I never tried it
03:27:16 <phale> anywhere I can start?
03:27:26 <KaneTW> @where learnhaskell
03:27:26 <lambdabot> https://github.com/bitemyapp/learnhaskell
03:27:27 <liste> > filter (>0) . map (+1) [5, 6, 12, 52, 54, 34, 88]
03:27:29 <hodapp> imperative and data-driven don't look like they're really related
03:27:29 <lambdabot>      Couldn't match expected type ‘a -> [a1]’
03:27:29 <lambdabot>                  with actual type ‘[Integer]’
03:27:30 <lambdabot>      Possible cause: ‘map’ is applied to too many arguments
03:27:30 <KaneTW> @where book
03:27:30 <lambdabot> http://haskellbook.com/
03:28:00 <phale> Thanks
03:28:01 <ggole> liste: $, not .
03:28:08 <KaneTW> the haskell book is really good but if you don't want to pay learnhaskell has a bunch of free resources
03:28:52 <liste> ggole ofc (: thanks
03:29:18 <phale> KaneTW: the first one seems rather complicated
03:30:04 <julianleviston> phale: the first what?
03:30:04 <KaneTW> phale: you have to start somewhere and cis194 is well structured to take you from no knowledge about FP to a decent amount, along with exercises to practice what you learned
03:30:21 <phale> julianleviston: <lambdabot> https://github.com/bitemyapp/learnhaskell
03:30:28 <phale> KaneTW: exercises are good
03:30:32 <julianleviston> phale: oh ok.
03:30:45 <phale> I wonder why anyone would upload a book to github though :P
03:31:13 <julianleviston> phale: it’s not a book.
03:31:24 <liste> phale also, people write books in github (:
03:31:28 <julianleviston> phale: it’s a list of resources for learning haskell.
03:31:43 <phale> ok
03:31:52 <arw> github does better versioning than 99% of CMSes, so i can understand hosting stuff there.
03:32:03 <arw> and I can edit with git, which is another plus </blah>
03:32:08 <hodapp> phale: what's an example of data-driven programming that you do?
03:32:43 <phale> hodapp: Let me give you an example C program, sec
03:33:58 <phale> hodapp: http://codepad.org/Csb4QGYZ
03:34:03 <phale> for instance
03:34:30 <julianleviston> phale: what makes that data-driven?
03:34:58 <hodapp> err, yeah, I'm not seeing how that's anything but imperative
03:35:12 <phale> hm, yeah hold on
03:35:17 <phale> I don't have a lot of programs with me right now
03:35:22 <phale> at work
03:35:26 <julianleviston> phale: to me, haskell *IS* data-driven programming
03:35:34 * ski idly wonders where `12' came from
03:35:37 <hodapp> you don't have to dump the code - I'm just looking for high-level examples
03:35:43 <julianleviston> This pretty much describes it…. (from the wiki entry) In computer programming, data-driven programming is a programming paradigm in which the program statements describe the data to be matched and the processing required rather than defining a sequence of steps to be taken.
03:36:12 <julianleviston> phale: let’s see… get a string… now turn it into a list of words.
03:36:20 <hodapp> I suppose Pandas in Python is also this almost exactly
03:36:30 <julianleviston> > words "hey there, how are you?"
03:36:32 <lambdabot>  ["hey","there,","how","are","you?"]
03:36:42 <julianleviston> phale: pretty data-driven, no?
03:37:02 <julianleviston> phale: turn it into a list of the word counts by mapping the length function across each word
03:37:14 <julianleviston> > map length $ words "hey there, how are you?"
03:37:16 <lambdabot>  [3,6,3,3,4]
03:37:59 <julianleviston> phale: sorry, character counts.
03:38:18 <ski> > (sortBy (comparing length <> compare) . words) "The quick brown fox jumps over the lazy brown dog"  -- sorting primarily by length, secondarily by lexicographic ordering
03:38:19 <lambdabot>  ["The","dog","fox","the","lazy","over","brown","brown","jumps","quick"]
03:38:34 <exio4> that definition sounds more like (map (head &&& length) . group . words)
03:40:31 <hodapp> phale: if it actually *is* data-driven programming you're interested in, there's a short PDF that covers a very similar use-case in Haskell: http://www.renci.org/wp-content/pub/tutorials/BeautifulCode.pdf
03:41:31 <quchen> I remember there being a name for the pattern where one annotates a list with something via (\x -> (annotation x, x)), the doing some computation on it, and then mapping out the "snd"s again. For example (map snd . filter fst . map (\x -> (isPrime x, x))). Does anyone rememer that name?
03:43:06 <dutchie> decorate sort undecorate?
03:43:39 <quchen> Ah, Schwartzian transform!
03:43:44 <ggole> schwartzian transform
03:43:48 <ggole> Yeah
03:44:08 <quchen> Looked up dutchie's suggestion and the first result was it. Thanks!
03:44:24 <dutchie> ah, that too
03:46:21 <phale> hodapp: julianleviston: Alright this seems fairly nice
03:46:31 <phale> Looks like i'll be programming in haskell for a while heh
03:46:57 <hodapp> good luck
03:47:01 <phale> thx
03:47:09 <julianleviston> phale: the only thing I’d warn against is moving too quickly as you learn. Go get bitemyapp’s book at haskellbook.com (note this is different than his github on how to learn haskell).
03:47:21 <hodapp> still curious as to why you'd avoid FP for data-driven programming though
03:47:35 <phale> hodapp: It's much better to manipulate data than to change the program control flow
03:47:36 <julianleviston> lately I feel like I’m his personal sales guy or something.
03:48:08 <hodapp> phale: what does FP have to do with any of this?
03:48:20 <zomg> julianleviston: you should ask for commissions ;)
03:48:36 <phale> hodapp: well, I dunno. I've been programming in C and have never done any "functional" programming
03:48:47 <phale> Was just asking if there was a more data-driven approach than functional programming
03:49:08 <danilo2> Hello guys! I'm new to Repa library and I'm wondering if it is possible to process arrays of Boxed values with it. An interesting fact is that Repa allows the creation of Boxed values, using type `Array V sh a` but ANY operation, like sequential fold `foldS` results in array of Unboxed values (see: https://hackage.haskell.org/package/repa-3.0.0.1/d
03:49:08 <danilo2> ocs/Data-Array-Repa.html). This way If I do fold it requires my array to be unboxed ...
03:49:08 <hodapp> phale: yeah, one really *can't* do FP in C
03:49:42 <phale> so I do apt-get install ghc to install haskell on debian?
03:49:46 <danilo2> is there a way to even fold the boxed array ?
03:50:03 <liste> phale that'll install a pretty old version
03:50:13 <phale> : ghc (7.6.3-21) 
03:51:10 <liste> many people here are on 7.10 now
03:51:30 <phale> oh
03:51:34 <phale> does the compiler update a lot?
03:52:01 <liste> phale yep, it's improving very fast
03:52:29 <julianleviston> phale: stack might be the best way to install GHC these days. I prefer it.
03:52:35 <phale> stack?
03:52:38 <liste> phale https://github.com/commercialhaskell/stack/blob/master/doc/install_and_upgrade.md check this out
03:52:49 <julianleviston> phale: that ^
03:53:12 <phale> woah
03:53:13 <liste> stack is a tool for installing Haskell tools and building Haskell projects
03:53:16 <phale> it's over 300 megabytes?
03:54:19 <phale> for amd64 only?
03:54:28 <phale> I thought I could install it for i686 systems too
03:54:54 <liste> phale for 32-bit, use the generic Linux option
03:54:59 <phale> ok
03:56:03 <phale> so stack installs GHC for me?
03:56:28 <dutchie> yes
03:56:28 <liste> yep
03:56:32 <phale> neat!
03:56:34 <julianleviston> phale: yeah, it makes compiling programs and installing packages and running ghci easier.
03:56:42 <hodapp> GHC, and also various dependencies
03:57:13 <hodapp> julianleviston: except for in Ivory :| still trying to track down what they mangled in their Cabal build - or that I did in the stack build - such that I can't start GHCi
03:57:39 <julianleviston> hodapp: I don’t even know what Ivory is.
03:57:51 <hodapp> just a Haskell library
03:58:08 <hodapp> also the main one that I use at work, hence me wanting a REPL :P
03:58:17 <phale> ok.. so how do I install GHC with it?
03:58:25 <phale> it's in my $PATH now
03:59:08 * hackagebot binary-enum 0.1.0.0 - Simple wrappers around enum types  https://hackage.haskell.org/package/binary-enum-0.1.0.0 (tolysz)
04:00:44 <julianleviston> phale: follow the quick start guide here: https://github.com/commercialhaskell/stack#how-to-install
04:00:51 <phale> okay
04:02:03 <phale> 7.10.2
04:02:06 <phale> seems to be the right version!
04:02:38 <julianleviston> phale: you pretty much want to create a sandboxed folder using the stack new command, then cd into it. It’ll create a folder structure, which includes a .cabal file — this is your packages file for that sandboxed project. From there you can start to edit the things in the src folder… and if you like you can then open ghci and load code in...
04:03:02 <phale> julianleviston: why though? why not make it available globally
04:03:40 <KaneTW> reposting https://mail.haskell.org/pipermail/haskell-cafe/2015-October/121835.html
04:03:42 <julianleviston> phale: you can, but it’s not generally advisable because of dependencies, upgrading and keeping things separate.
04:03:58 <phale> oh alright
04:04:28 <julianleviston> phale: sandboxing is less messy, pretty much.
04:04:36 <phale> so I can have two haskells at once?
04:04:40 <phale> two haskell installations
04:04:51 <julianleviston> phale: yeah
04:04:56 <phale> but its like 84mb per file
04:05:00 <phale> that seems to be a little bit too much
04:05:04 <julianleviston> phale: stack will be efficient and make sure you only have one copy of each version, tho.
04:05:13 <julianleviston> phale: what do you mean “per file"?
04:05:23 <phale> well it was downloading
04:05:29 <phale> and said it was around 88mb
04:05:35 <phale> when I did "stack setup"
04:05:48 <julianleviston> phale: um ok.
04:06:37 <phale> Prelude> d = 2
04:06:37 <phale> <interactive>:5:3: parse error on input ‘=’
04:06:39 <phale> is this normal?
04:06:43 <julianleviston> phale: it’s not as small as C, but Haskell is about the highest level programming language I know of, and C is almost the lowest.
04:07:01 <phale> julianleviston: alright i see
04:07:04 <julianleviston> phale: note that doesn’t mean it’s inefficient, but rather that it includes a LOT more by default than C does.
04:07:27 <julianleviston> phale: it includes garbage collection by default, for example. Mind you I’m tstarting to talk aobut things I know not much about so… yeah :)
04:07:47 <liste> phale that's normal. you need let in ghc
04:07:58 <liste> Prelude> let d = 2
04:08:02 <phale> oh ok
04:08:09 <liste> ghci*
04:08:34 <phale> yeah works now
04:08:35 <ski> KaneTW : hm, i thought it was talking about <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/pragmas.html#specialize-pragma>, and got confused when it mentioned it being for newcomers/beginners
04:08:42 <phale> thx for all the help
04:08:58 <julianleviston> phale: lf’s worth noting that this language is VASTLY different than anything else youve been exposed to.
04:09:06 <julianleviston> phale: lt’s*.
04:09:10 <KaneTW> ski: i guess it's i worded it a bit ambigously
04:09:18 <phale> that is true
04:09:33 <julianleviston> phale: so it’s worth not assuming things. Things you think look the same definitely arent.
04:09:39 <liste> phale note that not all the things you input in ghci can be put in top level in .hs files
04:10:16 <aleator> Is there a practical difference between `sum [] = ; sum (x:xs) = x + sum xs` and `sum = foldl' (+) 0` in efficiency nowadays?
04:10:27 <liste> in a .hs file, you'd type "d = 2", but in ghci, it's "let d = 2"
04:10:34 <aleator> Or does ghc make magic happen there?
04:10:36 <phale> dont I need to do d :: Int first
04:10:41 <phale> and then bind it to a number
04:10:43 <ski> phale : to some extent, it may help to think of it as learning programming all over again. obviously some things will carry over, but not at all as many as if you'd be learning Java or Smalltalk or Ada or Perl or Go or ..
04:10:49 <KaneTW> phale: types are inferred as much as possible
04:10:53 <liste> phale it's recommended but not necessary
04:11:40 <julianleviston> phale: I really do recommend reading that book by bitemyapp. It’s the fastest way to get going in this language… haskellbook.com
04:11:53 <KaneTW> which generally means unless you enable extensions, all types but polymorphic recursion are inferrable (polymorphic recursion being recursing with a different type)
04:11:53 <julianleviston> phale: otherwise you’re going to have a massively difficult time of it.
04:12:03 <KaneTW> i mean there are other resources
04:12:17 <ski> KaneTW : also there's ambiguity
04:12:32 <KaneTW> yeah
04:13:18 <phale> the example sumtorial function almost crashed my computer!
04:14:37 <phale> anyways, in haskell is there a "style" i have to follow?
04:14:41 <phale> when I programmed in python there was PEP8
04:14:49 <tdammers> not really, no
04:14:52 <phale> okay
04:14:56 <julianleviston> phale: whitespace matters tho.
04:15:02 <phale> so no tabs?
04:15:06 <tdammers> capitalization also matters
04:15:21 <julianleviston> phale: i’d recommend no tabs… 
04:15:22 <tdammers> tabs are allowed, but they're inconvenient
04:15:35 <tdammers> for pretty much the same reasons as in Python
04:15:49 <tdammers> also, underscores in identifiers are generally avoided
04:15:52 <KaneTW> rip
04:16:09 <ski> (if you use tabs, it's best to break line after any layout-introducing keyword followed by a block of more than one line)
04:16:32 <ski> aligning things is good
04:16:52 <tdammers> there's also the "leading separator" style, which I like quite a bit:
04:16:57 <tdammers> { foo
04:16:59 <tdammers> , bar
04:17:01 <tdammers> , baz
04:17:03 <tdammers> }
04:17:53 * ski notes phale's connection dropped
04:17:59 <julianleviston> tdammers: yeah, I originally hated that, but after about a week of haskell, I realised it’s actually really handy to avoig a whole lot of bugs and problems
04:18:33 <liste> tdammers nowadays I find it hard to avoid that in other languages :(
04:18:40 <liste> where it's unidiomatic
04:18:40 <tdammers> hehe yeah
04:18:48 <tdammers> *cough*clojure*cough*
04:19:03 <ski> you use commas often in Clojure ?
04:19:10 <tdammers> no
04:19:22 <tdammers> in clojure, commas are whitespace
04:19:27 * ski would've thought you only used them for quasiquotations, if anything
04:19:35 <liste> whitespace? wtf
04:19:37 <tdammers> ya
04:19:38 <ski> strange
04:19:41 <julianleviston> tdammers: in closure, no one hears you comma.
04:19:56 <tdammers> e.g., a hashmap is written as {:foo "Hello :bar "world"}
04:20:06 <tdammers> sometimes people add commas for readability:
04:20:14 <tdammers> {:foo "Hello", :bar "world"}
04:21:05 <quicksilver> leading commas (and leading semicolons) have their advocates in all C-like languages
04:21:18 <quicksilver> it's always been a minority view, but they definitely have their adherents
04:21:19 <liste> and then someone types {:foo, "Hello" :bar, "world"} by mistake
04:21:35 <liste> and everyone gets confused
04:21:37 <tdammers> liste: doesn't matter, still means the same, is just confusing
04:21:41 <tdammers> yeah
04:22:08 <tdammers> but then, half of the information one would need to actually understand the code is hidden anyway, so confusion is kind of a given
04:23:21 <veltas> Trubydoor: lol hi dere
04:23:35 <Trubydoor> why hello
04:25:40 <aleator> Hunh? `sum [] = ; sum (x:xs) = x + sum xs` is order of magnitude faster than `Data.List.sum`? 
04:25:46 <aleator> How come?
04:27:04 <pavonia> @src sum
04:27:04 <lambdabot> sum = foldl (+) 0
04:28:06 <aleator> pavonia: Actually it is getSum #. foldMap Sum nowadays
04:28:47 <pavonia> Are lenses in base now?
04:29:09 <pavonia> :t (#.)
04:29:11 <lambdabot> parse error on input ‘)’
04:29:25 <aleator> pavonia: nope. foldMap is from Data.Foldable and the #. is . + coerce 
04:29:38 <jle`> aleator: are you compiling with optimizations?
04:29:42 <pavonia> Ah, okay
04:31:40 <aleator> jle`: Yup. Without them it is almost the same
04:32:27 <aleator> sum [1..10000] runs in 12.49ms and the expl.recursive one at 267.2 μs
04:32:56 <aleator> Without optimizations the recursive one is  12.48 ms
04:33:03 <aleator> Both are specialized for Int's
04:33:21 <KaneTW> aleator: did you look at the core
04:34:30 <jle`> this is concerning
04:34:37 <nomeata> aleator: what version of GHC?
04:34:54 <aleator>  7.10.2. 
04:35:56 <nomeata> aleator: try to make the list dependent on an argument, otherwise GHC will float it to the top-level and share it, which can skew the results.
04:36:02 <nomeata> (althought that should happen in either case)
04:36:28 <aleator> Here is the code: http://pastebin.com/D1M86tAS
04:36:39 <aleator> Ran it a few times and selected the least varying result
04:36:47 <aleator> Oh. dear. 
04:36:55 <aleator> Sorry. That's not right..
04:37:15 <aleator> Though it is interesting!
04:37:34 <nomeata> aleator: can you include http://hackage.haskell.org/package/base-4.8.1.0/docs/GHC-OldList.html#v:sum in the result?
04:39:08 <aleator> nomeata: Lemme see.
04:40:14 <aleator> nomeata: It seems that OldList was hidden some time ago. How can I use it?
04:40:45 <nomeata> hmm, no idea :-)
04:40:46 <aleator> Except cabal unpacking it.
04:40:57 <nomeata> anyways, the Foldable instance for [] overrides sum
04:41:17 <nomeata> so you should not be getting the getSum #. foldMap Sum nowadays implementation
04:41:42 <nomeata> but rather "foldl (+) 0"
04:41:42 <quicksilver> you can explicitly expose hidden packages
04:42:06 <nomeata> you might add that to your comparision, and check if it behaves the same as Data.List.sum
04:42:47 <tekkkz> do you have any experience with plotting in haskell? I wanted to start with chart-cairo (pkg-name) but in the examples there is just shhown how to plot into a file ... is it also possible to plot live?
04:42:48 <aleator> Here is the test again, after I fixed my silly mistake: http://pastebin.com/VMm1KMMm
04:42:59 <aleator> quicksilver: YEah, but it is a module and not a package.
04:43:35 <nomeata> aleator: yes, that looks more sensible
04:43:46 <nomeata> at least the relative performances of sum1, sum2 and sum3
04:43:48 <quicksilver> oh
04:43:56 <nomeata> with sum1 = sum2, and sum3 being much better
04:45:05 <aleator> nomeata: Still, recursive one beats the standard..
04:46:10 <quicksilver> add another 0 to your problem size
04:46:14 <quicksilver> is it still consistent?
04:46:44 <aleator> quicksilver: Sure. Let me do that
04:47:46 <nomeata> aleator: it looks as if the standard (which is foldl (+) 0) does not get optimized to the equivalent foldl' (+) 0, as it should.
04:48:06 <nomeata> aleator: how does an explicit "sum4 = foldl (+) 0" fare?
04:48:47 <aleator> http://pastebin.com/920w3BAW
04:49:01 <aleator> Jeez guys :) I put it on pastebin so you can try also :)
04:49:09 <quicksilver> nomeata: we had another example in here the other day where GHC failed to get the strictness analysis right for a recursive factorial
04:49:10 <nomeata> :-)
04:49:22 <quicksilver> I wonder if there is a strictness analyser regression
04:50:21 <tekkkz> do you have any experience with plotting in haskell? I wanted to start with chart-cairo (pkg-name) but in the examples there is just shhown how to plot into a file ... is it also possible to plot live?
04:50:51 <aleator> pure foldl is same as sum
04:51:28 <quicksilver> aleator: why would you need #. there? foldMap Sum is already the correct type to just apply getSum to
04:51:36 <quicksilver> if you want to avoid getSum you could just say
04:51:40 <quicksilver> coerce (foldMap Sum)
04:51:47 <quicksilver> but I doubt that makes a difference.
04:51:59 <quicksilver> it's only one unwrap at the top level, GHC will compile that away.
04:52:34 <aleator> quicksilver: I wouldn't know, other than that's how I found it in Base.
04:52:40 <quicksilver> weird
04:52:56 <quicksilver> :t getSum . foldMap Sum
04:52:57 <lambdabot> (Num c, Foldable t) => t c -> c
04:53:08 <quicksilver> see? no coercion required
04:53:20 <quicksilver> unless this is somethign to do with an Int/Int# coercion
04:53:37 <aleator> quicksilver: I see, but https://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.Foldable.html#sum
04:53:52 <nomeata> see the comment at the end of http://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.Foldable.html
04:54:12 <nomeata> it explains the point of .#
04:54:18 <nomeata> eh, #.
04:54:49 <nomeata> ok, with GHC-7.8, everything is nice (sum as fast as sum3)
04:55:04 <quicksilver> oh
04:55:14 <quicksilver> right, #. isn't quite what you initially said
04:55:28 <quicksilver> aleator: you should report this to trac as a GHC performance regression
04:55:31 <quicksilver> IMO
04:57:40 <nomeata> even sum3 has regressed from 7.8 to 7.10, it seems :(
04:57:42 <Unhammer> is there a difference between "let go = f a b in go c" and "go c where go = f a b" ?
04:58:04 <Unhammer> other than scope
04:58:14 <nomeata> Unhammer: no, there is none
04:58:45 <mpickering> What's the recommended way to silence redundant import warnings from Data.Foldable and Data.Traversable?
04:58:50 <mpickering> (without CPP)
04:58:51 <maukeauke> different syntactic category
04:58:57 <Unhammer> ok
05:01:29 <nomeata> aleator: looking at the core it seems that foldl is simply not inlined
05:01:35 <ski> Unhammer : bindings in a `where'-clause can scope over patterns and guards, due to being attached to a defining equation
05:01:51 <nomeata> and then of course no specialization and further optimizatoin can happen
05:02:02 <aleator> nomeata: That would explain it. 
05:03:06 <nomeata> if I force the inlining (GHC.Exts.inline), it does give the same performance as foldl'
05:03:41 <nomeata> I mean, the same as sum in GHC-7.8.
05:04:08 <nomeata> foldl' is also not inlined, so it does not perform as well as in 7.8.
05:04:13 <aleator> I did make a track ticket as suggested.
05:04:22 <nomeata> thanks
05:04:27 <nomeata> I’ll add my findings there.
05:06:05 <aleator> nomeata: Feel free to rewrite the ticket. I'm prepareing a lecture which needs to be ready _soon_
05:06:13 <nomeata> :-)
05:07:14 <aleator> nomeata: Since you are there, can we embed the incredible proof machine to our logics e-textbook under some terms? 
05:07:39 <aleator> I'm pretty sure I could teach the whole phil.logic course under 5 hours with that :)
05:10:10 <quicksilver> Unhammer: "go c where go = f a b" is not even valid haskell
05:10:21 <quicksilver> Unhammer: 'where' has to attach to a declaration
05:10:32 <quicksilver> but that aside, what the other people wisely said :)
05:11:36 <vburakovs> Hi guys, could anyone explain this to me? https://gist.github.com/anonymous/06918489f651f6fa1bf0
05:11:46 <nomeata> aleator: heh, of course! It’s all MIT licensed, so legal terms should not pose a problem!
05:11:48 <vburakovs> Seems like some optimization behind the scenes, don't you think
05:11:56 <dm>  dario           ] [ inteq          ] [ moop            ] [ SenpaiSilver    ] [ zenzike_        ] 
05:11:59 <dm> 08:07 [ darkf           ] [ Internet13     ] [ moredhel        ] [ senseibaka      ] [ zerokarmaleft   ] 
05:12:09 <aleator> nomeata: Polite to ask first :) 
05:12:29 <nomeata> aleator: I tracked the problem down to you using sum (and foldl*) unsaturated, see https://ghc.haskell.org/trac/ghc/ticket/10992#comment:1 for an analysis once you come back from your class
05:12:47 <nomeata> aleator: let me know (preferably via github issues) if you need particular features
05:13:04 <aleator> nomeata: Just a thought -- since syntax is surprising hurdle with haskell, how about using the exact same UI as incredible to write haskell programs? (Curry howardingly?)
05:13:06 <nomeata> aleator: or if you need help hosting your customized version with the logics definitions and tasks you need
05:13:44 <nomeata> aleator: this was actually my initial thought: teaching Curry-Howard. In the end I managed to tell the kids something about propositional logic, but hey :-)
05:13:54 <aleator> nomeata: Thanks! I get touch with our system devs. What would be needed is somehow to extract the state out from the javascript..
05:13:59 <jle`> vburakovs: what part are you having difficulty with?
05:14:22 <aleator> nomeata: If you want to turn that towards writing code, ask me after christmas when I have more time. I would very much like to do something like that.
05:14:33 <vburakovs> I don't understand why in the second variant, it halts after outputting "HI", whereas in the first part it waits for user to input actual strings
05:14:36 <maukeauke> vburakovs: that's lazy I/O
05:14:39 <nomeata> aleator: it already saves the state using local storage, so doing something else with that data at that point should not be a problem.
05:14:40 <maukeauke> also known as black magic
05:14:49 <vburakovs> Oh
05:14:58 <vburakovs> Right, I haven't thought about that
05:15:10 <aleator> nomeata: My dream is to take a 5 minute videoclip of 5 year old making a sensible Haskell program and show that to my third year university students who fail to do the same :/ 
05:15:15 <vburakovs> So it's not an optimization per se?
05:15:29 <nomeata> aleator:  :-)
05:15:34 <maukeauke> vburakovs: no
05:15:44 <aleator> nomeata: Ah. Ok. So I would guess that just slapping it in an iframe and eztracting local storage through there would work.
05:15:54 <merijn> This doesn't have todo with lazy IO...
05:16:03 <merijn> vburakovs: What would you expect it todo?
05:16:10 <vburakovs> maukeake: but what if I wanted to output "HI" back every time a user enters anything??
05:16:11 <nomeata> aleator: yes, or simply putting a slightly modified version that does what you want on your webspace :-)
05:16:13 <merijn> vburakovs: interact takes a String containg ALL input every
05:16:22 <merijn> vburakovs: It then returns a String
05:16:33 <merijn> vburakovs: So you program consumes all input and uses it to produce "HI"
05:17:00 <aleator> nomeata: Well, I'll point our e-book people at it and let them figure out what is needed.
05:17:06 <merijn> vburakovs: Sounds like you want "interact $ unlines . map (\s -> "HI") . lines"
05:17:07 <vburakovs> merijn: Yes, a String->String. like unlines . lines
05:17:28 <merijn> vburakovs: Your function gets applied to ALL input, not against every line
05:17:34 <nomeata> aleator: great! Looking forward to what might come out of that.
05:17:52 <merijn> vburakovs: If you want to do something based on lines you need to explicitly split the input into lines and do something with every line...
05:18:06 <merijn> vburakovs: i.e. like my "unlines . map f . lines" suggestion
05:18:17 <vburakovs> merijn: but how does it know where to stop applying "lines" to an input? EOF character?
05:18:38 <merijn> vburakovs: When you hit EOF it terminates the String of input, yes
05:18:48 <vburakovs> merijn: Thanks a lot!
05:18:55 <aleator> nomeata: I'll let yo know.
05:19:00 <maukeauke> EOF isn't a character
05:19:40 <merijn> vburakovs: If you want to do line-by-line/stream processing, you may want to look at the pipes library? (Although it might be a bit too intimidating depending on how new you are to haskel)
05:20:32 <vburakovs> merijn: I'm just working my way through LYAH and experimenting with provided examples :)
05:21:25 <N0viceLive-amd64> Hi guys, how to name this kind of function application: f $ f $ f $ f $ f $ f bar  I found it interesting, but without a name, I can't even Google for it.
05:22:04 <merijn> N0viceLive-amd64: I don't think it has a name, but I can show you a neat trick of writing that without the repetition :p
05:22:31 <ski> N0viceLive-amd64 : `let compose = foldr (.) id in compose (replicate 6 f) bar'
05:22:38 <merijn> ski: awww
05:22:47 <merijn> ski: you ruined it for me :(
05:22:47 <N0viceLive-amd64> eager to hear about
05:22:57 <merijn> I would probably do
05:22:59 <jle`> N0viceLive-amd64: people do iterate f bar !! 6
05:23:20 <ski> merijn : oh, sorry. i didn't notice your response
05:23:22 <jle`> but this can lead to trouble because the definition of iterate/(!!) lead to some unnecessary laziness
05:23:39 <merijn> :t let repeatF :: Int -> (a -> a) -> a -> a; repeatF n f = foldr (.) id (replicate n f) in repeatF
05:23:40 <lambdabot> Int -> (a -> a) -> a -> a
05:24:00 <merijn> Or just Endo, because Endo monoid is best monoid!
05:24:24 <merijn> :t \f -> mconcat (replicate 5 (Endo f))
05:24:26 <lambdabot> (a -> a) -> Endo a
05:24:45 <vburakovs> merijn: One more thing. I'm not sure I've got a part with "function applied to ALL input". I mean, there should be no difference between (\s->s) and (\s->"HI")?
05:24:56 <merijn> :t \f -> appEndo $ mconcat (replicate 5 (Endo f))
05:24:57 <lambdabot> (a -> a) -> a -> a
05:25:10 <merijn> vburakovs: (\s -> s) is just returning the entire input unmodified
05:25:19 <merijn> vburakovs: i.e. regardless of how many lines it is
05:25:24 <merijn> vburakovs: So there is no difference
05:25:53 <jle`> vburakovs: one will take "hello\nworld" and return "hello\nworld", the other will take "hello\nworld" and return "HI"
05:25:54 <merijn> vburakovs: "interact (\s -> s)" turns the entire input into itself "interact (\s -> "HI")" turns the entire input into "HI"
05:26:05 <vburakovs> merijn: Right. But when I compile, it "waits" for an input
05:26:20 <vburakovs> Whereas (\s -> "HI") returns immediately
05:26:20 <merijn> vburakovs: Right, because the input isn't finished until you enter EOF
05:26:23 <maukeauke> \s -> s is strict
05:26:31 <vburakovs> strict?
05:26:38 <merijn> vburakovs: Right, because "(\s -> "HI")" doesn't need the input to finish
05:26:43 <maukeauke> or rather: the result of \s -> s depends on its input
05:26:54 <maukeauke> the result of \s -> "HI" doesn't
05:27:14 <vburakovs> So it's *kind of* optimized?
05:27:17 <maukeauke> > (\s -> s) (error "splode")
05:27:18 <lambdabot>  *Exception: splode
05:27:21 <merijn> No
05:27:21 <maukeauke> > (\s -> "hi") (error "splode")
05:27:23 <lambdabot>  "hi"
05:27:27 <vburakovs> Like a compiler sees thath it doesn't need to wait?
05:27:30 <merijn> vburakovs: But we have laziness
05:27:31 <maukeauke> standard laziness
05:27:37 <merijn> vburakovs: Nothing gets evaluated until it has to be
05:27:37 <maukeauke> or non-strictness :-)
05:27:50 <vburakovs> Oh
05:27:50 <ski> maukeauke : something happened to your nick ?
05:27:53 <vburakovs> Ok, thanks guys
05:27:56 <merijn> vburakovs: It's not an optimisation, it's a fundamental property of everything in haskell
05:28:03 <maukeauke> this is not an optimization because the language itself is defined to work this way
05:28:10 <merijn> vburakovs: Consider the following fibonacci code which uses it's own result to be computed
05:28:12 <maukeauke> is there an echo here
05:28:26 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
05:28:28 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
05:29:16 <jle`> vburakovs: you can think of it as, the result is a String, so interact will print out each line (or character, depending on your buffer) of the string as soon as it's "known"/available.  for the case of (\s -> s), each line is not known until the the corresponding input line is known, so it has to wait for you to put stuff in
05:29:21 <merijn> Actually, since Heinrich wrote a good guide on lazy evaluation, I no longer need to bother explaining it: https://hackhands.com/guide-lazy-evaluation-haskell/
05:29:35 <jle`> vburakovs: for (\s -> "HI"), the String response is already known -- "HI", it doesn't need to wait
05:29:59 <ski> apfelmus ?
05:30:08 <vburakovs> merijn: thanks, I'll look into it
05:30:13 <ski> ok
05:30:18 <merijn> N0viceLive-amd64: anyway, if you need to repeatedly combine/compose functions, look into the Endo monoid :)
05:30:21 <merijn> ski: Yeah
05:30:27 <vburakovs> jle`: But what *if* I wanted to output "HI" every time a user inputs something?
05:30:45 <jle`> vburakovs: you mean, every line?
05:30:46 <merijn> vburakovs: I already told you that you then need to modify it to do something for every newline of input
05:30:49 <ski> (long time since they were on IRC, iirc)
05:32:29 <vburakovs> merijn: you mean at least unlines . lines?
05:32:55 <jle`> vburakovs: you need to convert "hello\nworld\ngoodbye" into "HI\nHI\nHI"
05:33:09 <merijn> vburakovs: Plus map, yes
05:33:22 <jle`> > lines (map (\_ -> "HI") (unlines "hello\nworld\ngoodbye"))
05:33:22 <vburakovs> thanks
05:33:23 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘[Char]’
05:33:23 <lambdabot>      In the expression: "HI"
05:33:23 <lambdabot>      In the first argument of ‘map’, namely ‘(\ _ -> "HI")’
05:33:35 <jle`> > unlines (map (\_ -> "HI") (lines "hello\nworld\ngoodbye"))
05:33:37 <lambdabot>  "HI\nHI\nHI\n"
05:34:16 <jle`> lines "hello\nworld\ngoodbye" gives you ["hello","world","goodbye"]
05:34:26 <jle`> mapping (\_ -> "HI") over that gives you ["HI","HI","HI"]
05:34:40 <ski> > let onLines f = unlines . f . lines in (`onLines` "hello\nworld\ngoodbye") $ \_ -> "LO"
05:34:41 <jle`> and then unlines brings it back to "HI\nHI\nHI\n"
05:34:41 <lambdabot>      Couldn't match type ‘Char’ with ‘[Char]’
05:34:42 <lambdabot>      Expected type: [String]
05:34:42 <lambdabot>        Actual type: [Char]
05:34:53 <ski> oh, forgot a `map'
05:35:19 <ski> > let onLines f = unlines . f . lines; perLine = onLines . map in (`perLine` "hello\nworld\ngoodbye") $ \_ -> "LO"
05:35:21 <lambdabot>  "LO\nLO\nLO\n"
05:47:14 <tekkkz> do you have any experience with plotting in haskell? I wanted to start with chart-cairo (pkg-name) but in the examples there is just shhown how to plot into a file ... is it also possible to plot live?
05:51:16 <DEA7TH> Is there a nicer way to map inner elements of a list? Like so: map (map succ) [[1, 2], [10, 20], [50, 100]]
05:51:57 <magneticduck> @type map . map -- DEA7TH 
05:51:59 <lambdabot> (a -> b) -> [[a]] -> [[b]]
05:52:02 <maukeauke> (map . map) succ
05:52:04 <maukeauke> inb4 lens
05:52:11 <magneticduck> @type map . map . map . map -- DEA7TH 
05:52:12 <lambdabot> (a -> b) -> [[[[a]]]] -> [[[[b]]]]
05:52:20 <DEA7TH> awesome!
05:53:55 <aweinstock> :t (fmap . fmap . fmap . fmap . fmap . fmap . fmap)
05:53:56 <lambdabot> (Functor f, Functor f1, Functor f2, Functor f3, Functor f4, Functor f5, Functor f6) => (a -> b) -> f (f1 (f2 (f3 (f4 (f5 (f6 a)))))) -> f (f1 (f2 (f3 (f4 (f5 (f6 b))))))
05:54:13 * hackagebot megaparsec 4.1.1 - Monadic parser combinators  https://hackage.haskell.org/package/megaparsec-4.1.1 (mrkkrp)
05:54:18 <dutchie> https://www.youtube.com/watch?v=cefnmjtAolY&hd=1&t=1m14s
05:54:32 <aweinstock> :t (fmap `fmap` fmap `fmap` fmap `fmap` fmap `fmap` fmap `fmap` fmap `fmap` fmap)
05:54:33 <lambdabot> (Functor f, Functor f1, Functor f2, Functor f3, Functor f4, Functor f5, Functor f6) => (a -> b) -> f (f1 (f2 (f3 (f4 (f5 (f6 a)))))) -> f (f1 (f2 (f3 (f4 (f5 (f6 b))))))
05:54:36 <magneticduck> @type (.) . (.) . (.) . (.) -- DEA7TH 
05:54:37 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> a3 -> b) -> a -> a1 -> a2 -> a3 -> c
05:55:20 <maukeauke> noooo
05:55:26 <DEA7TH> What does this do (.) . (.)
05:55:41 <aweinstock> composes a 2-argument function with a 1-argument function
05:55:43 <maukeauke> @unpl (.) . (.)
05:55:43 <lambdabot> (\ i b c f -> i (b c f))
05:56:12 <aweinstock> :t ((.).(.)) concat mapM
05:56:14 <lambdabot> (Monad t, Foldable t) => (a1 -> t a) -> [a1] -> [a]
05:56:23 <maukeauke> @unpl ((.) . (.)) f g
05:56:23 <lambdabot> (\ c h -> f (g c h))
06:10:53 <julianleviston> Is there a “brain out easymode” way to grab a piece of code and “send it off to be done then return the results and continue execution afterward"?
06:12:12 <julianleviston> forkIO ?
06:12:40 <merijn> julianleviston: I'll take "You want the async library" for $500
06:13:18 <julianleviston> merijn: sweet :)
06:14:33 <breadmonster> Hey guys.
06:14:38 <breadmonster> What's up?
06:16:34 <julianleviston> merijn: that’s about as awesome as I could have ever hoped for! :)
06:17:09 <aweinstock> julianleviston: yesterday, you were asking about running things in the middle of a context?
06:18:08 <julianleviston> aweinstock: umm…. I was?
06:18:20 <julianleviston> aweinstock:  oh… right I’m with you now… 
06:18:35 <julianleviston> aweinstock: yeah, I was *sort of* asking about that. More just talking about it, really… 
06:18:47 <aweinstock> julianleviston: this might be overkill, but ContT/callCC might be a solution
06:19:03 <julianleviston> aweinstock: a solution to… what.. exactly?
06:19:36 <julianleviston> aweinstock: I’m guessing (by the names) that these are continuation libraries…
06:19:46 <aweinstock> to putting a point in the middle of a do-block that lets you put values in the middle of the context interactively
06:20:03 <julianleviston> aweinstock:  that wasn’t really what I was talking about, actually.
06:20:40 <aweinstock> oh, what were you asking?
06:20:48 <julianleviston> aweinstock: I wasn’t asking.
06:21:10 <aweinstock> what were you expressing?
06:21:44 <julianleviston> aweinstock: I was mostly talking about how I missed the ability to get into a REPL and mash some code that worked together, and then pull it out and jam it into an editor and have it work fine, and then reload that code into the REPL.
06:22:01 <tekkkz> Plotting: after installation with cabal install chart-gtk and following this: https://github.com/timbod7/haskell-chart/wiki/example-0 i ended up with: http://ix.io/lvd
06:22:29 <julianleviston> aweinstock: you can do that pretty easily at top level, but not if you’re writing a piece of code slightly larger than a few lines.
06:23:30 <julianleviston> aweinstock: I don’t want this to come across as an “I hate Haskell” thing, because it’s the opposite.
06:23:37 <aweinstock> julianleviston: I think I see, and that for that purpose, making a half-baked debugger with ContT is more effort than reloading the file?
06:24:02 <julianleviston> aweinstock: I just miss this from other languages… in other languages there is only really *one* context… it’s all kind of top level.
06:24:13 <julianleviston> aweinstock: I have no idea…
06:24:58 <julianleviston> aweinstock: I guess I’d need to know the workflow, or tryi it or something
06:26:20 <julianleviston> aweinstock: how would I try that out?
06:27:24 <aweinstock> julianleviston: actually, I think contT might be way too much overkill
06:27:36 <julianleviston> aweinstock: ah ok.
06:28:14 <aweinstock> julianleviston: if you're debugging (do {x; y}) and want to run something interactive after x, before y, define (\z -> do {x; z; y}), and plug in values to it in ghci?
06:28:37 <aweinstock> (and then inline the argument once you're satisfied with the result in ghci)
06:29:03 <julianleviston> aweinstock: I don’t really follow
06:29:09 <julianleviston> aweinstock: hang on let me give you a context.
06:29:30 <yoyo> anybody good with encryption/decryption ? 
06:30:05 <aweinstock> yoyo: I'm taking a crypto class this semester, does that count?
06:30:36 <Guest93126> I am wondering how to check wether a port on my local machine is free in Haskell, can someone help me please?
06:30:44 <lpaste> JulianLeviston pasted “a context for love and joy -- aweinstock” at http://lpaste.net/143440
06:30:59 <yoyo> any idea what kind of encryption is this $2y$10$/Yt4b0ldzH7rtoDNuB5xu.XU.hywHQ2xgdoJhiuY07lLf8cE9uEVi ?
06:31:26 <maukeauke> yoyo: that looks like a hash, not encryption
06:31:53 <julianleviston> mauke: do hashes have dots? I don’t remember, really.
06:32:09 <SiIky> yoyo theres a ##crypto you know?
06:32:11 <julianleviston> maukeauke: ^
06:32:27 <julianleviston> aweinstock: any ideas?
06:33:01 <maukeauke> it's from crypt_blowfish
06:34:02 <nicow> Hi everybody, I'm using Blaze Builder to create ByteStrings. Thing is, I am creating builders using `fromByteString myStr`, where myStr is created "by hand" from a haskell object. It seems to me that it would be more efficient to create a Builder from my haskell object, and then let Blaze handle the ByteString creation in its buffers. Is that right?
06:34:15 * hackagebot network-msg 0.6 - Recvmsg and sendmsg bindings.  https://hackage.haskell.org/package/network-msg-0.6 (sickmind)
06:35:02 <lpaste> aweinstock revised “a context for love and joy -- aweinstock”: “No title” at http://lpaste.net/143440
06:35:37 <julianleviston> aweinstock:  um....
06:35:44 <julianleviston> aweinstock: I don’t follow
06:36:25 <aweinstock> julianleviston: and then in ghci, do things like (doMigrate2 (someExpressionThatYou'reTesting))
06:36:40 <julianleviston> aweinstock: but that’ll actually run the whole thing.
06:36:54 <Guest93126> Please, I am still wondering how to check whether a give port is bound on localhost or whether its "free". Please help
06:36:57 <julianleviston> aweinstock: I effectively want to “freeze time” at that point… which is silly, because there isn’t any time.
06:37:51 <aweinstock> julianleviston: yes, it'll do the setup/teardown after each time, but you have an interactive way to place expressions into that context
06:38:08 <julianleviston> Guest93126: could you maybe use this to check? https://hackage.haskell.org/package/network-simple-0.4.0.4/docs/Network-Simple-TCP.html
06:38:29 <maukeauke> Guest93126: I'd imagine you'd do it the same way as in any other language
06:38:33 <rootnode> did someone highlight me?
06:38:33 <aweinstock> julianleviston: and if it didn't do the setup each time, what would you expect to happen after running something in the context? or are you imagining an explicit "resume" action?
06:38:39 <julianleviston> aweinstock: it’s not exactly easy, so I’d just skip that, probably.
06:38:59 <julianleviston> aweinstock: yeah, exactly… it’s just a complete hyopthetical question.
06:39:08 <Guest93126> maukeauke: sadly I have no idea how to do it in other languages as well...
06:39:24 <julianleviston> aweinstock: all it was was just an observation that I miss the ability to code like that becuase it was delightful, that’s all. :)
06:40:17 <aweinstock> Guest93126: in C, I'd call bind(2) and check the return code, at least if I couldn't find a syscall for explicitly checking
06:41:16 <Guest93126> maukeauke: I guess I have to first get the socket for that port.. I looking for a function like this "HostName -> PornNumber -> Maybe Socket" or something along those lines
06:42:06 <maukeauke> Guest93126++  # A+ typo
06:42:41 <Guest93126> maukeauke: hahaha, sorry for the typo xD
06:42:43 <aweinstock> Guest93126: you wouldn't be able to get a socket for that port if someone else is already bound to it
06:42:46 <julianleviston> aweinstock: Haskell’s contexts, while being the thing that allows to be Haskell incredibly powerful (IMO), also makes it *very* difficult to use sometimes. The same thing that provides us with the idea of a fallable computational context, for example, say Either, or Maybe, also makes it quite difficult to work out what’s going on in there by programmatic inspection.
06:43:06 <maukeauke> http://hackage.haskell.org/package/network-2.6.2.1/docs/Network.html#v:listenOn ?
06:43:07 <Guest93126> aweinstock: that would be good enough, then I would know that I have to generate an other one
06:43:31 <aweinstock> @let foo x = do { Just 1; x; fmap (+2) x}
06:43:32 <julianleviston> aweinstock: hence, “write small functions” is a good rule of thumb ;-)
06:43:33 <lambdabot>  Defined.
06:43:38 <aweinstock> foo (Just 3)
06:43:42 <Guest93126> I simply want to check, whether I can use a given port for my purpose (integration testing) or wether I have to use an other one
06:43:46 <aweinstock> > foo (Just 3)
06:43:48 <julianleviston> aweinstock: Oh, I get what you were saying :)
06:43:49 <lambdabot>  Just 5
06:43:54 <DEA7TH> Is there a nicer way to write this without do notation? getContents >>= return . solve >>= putStrLn
06:43:56 <aweinstock> > foo (Nothing)
06:43:58 <lambdabot>  Nothing
06:44:20 <Hijiri> getContents >>= putStrLn . solve ?
06:44:52 <julianleviston> aweinstock: doesn’t work if the function is slightly longer than a few lines of code very well, though...
06:45:33 <DEA7TH> Hijiri: yeah that works
06:45:43 <aweinstock> julianleviston: maybe it's possible to make some (MonadIO m => m ()) that works like IPython.embed()?
06:45:57 <julianleviston> aweinstock:  I don’t know what IPython,embed() is.
06:46:12 <quicksilver> Guest93126: the general adage with system programming is "dont' try to check if a resource is free; just try to acquire the resource, and handle the error if it fails"
06:46:20 <julianleviston> aweinstock: I have a feeling that if we had a kind of “named contexts” as functions that could be called (and muster up their own context), this might end up actually being revolutionary (for modules, too).
06:46:22 <aweinstock> (or possibly even (MonadIO m => m a), that keeps the shell open if you try to exit with something other than an a)
06:46:46 <quicksilver> Guest93126: so I wouldn't waste time working out if the port is bound by something else, I would just try to bind it, and handle the error condition appropriately
06:46:47 <julianleviston> aweinstock: maybe. I’m just really a noob… so I have no idea.
06:47:03 <Guest93126> quicksilver: thanks, I will do that :)
06:47:15 <aweinstock> julianleviston: IPython.embed() opens a python repl at the current point in the script
06:47:16 <julianleviston> aweinstock: but maybe precisely *because* I’m a noob, I *may* have a valid perspective on this stuff.
06:47:19 <roelof> anyone who can help me witht this one : https://www.reddit.com/r/haskellquestions/comments/3ph4av/testing_roots_problem_on_a_quadric_function/ 
06:48:08 <aweinstock> (and gives you access to the variables of the surrounding context, which might be the difficult part in a compiled language)
06:48:11 <julianleviston> aweinstock: ah ok… yeah, I guess so…. but have it so that if you call a function, you can “step” through… whatever “current point” means? :) It kind of makes no sense because of the way haskell is executed, if I understand corrrectly.
06:50:21 <ski> DEA7TH :  interact solve >> putChar '\n'
06:50:30 <julianleviston> aweinstock: what would probably be wanted is a way to open a REPL, then “call” a function by “lensing into the function” so to speak (to then call it). But unfortunately, functions aren’t data… so this won’t be possible… right?
06:51:04 <DEA7TH> that's even better
06:51:30 <aweinstock> julianleviston: I'm not sure, and I have to go to class now; it sounds like an interesting idea though
06:51:41 <julianleviston> aweinstock: ah apologies. Ok :) talk about it later sometime, maybe.
06:51:54 <julianleviston> aweinstock: I kind of feel like this would be the next “do” syntax kind of thing. 
06:52:14 <julianleviston> aweinstock: in terms of self-pedagogical ramifications, perhaps.
06:52:52 <nicow> anybody with a good understanding of blaze builder?
06:53:25 <roelof> ski: Can you help me one more time with my "math" problem ? 
06:53:31 <Ankhers> nicow: What is your question?
06:54:16 <nicow> I'm using Blaze Builder to create ByteStrings. Thing is, I am creating builders using `fromByteString myStr`, where myStr is created "by hand" from a haskell object. It seems to me that it would be more efficient to create a Builder from my haskell object, and then let Blaze handle the ByteString creation in its buffers. Is that right?
06:54:45 <nicow> I get a lot of allocation and thus gc time
06:55:40 <ski> roelof : what was the problem ?
06:55:48 <roelof> https://www.reddit.com/r/haskellquestions/comments/3ph4av/testing_roots_problem_on_a_quadric_function/
06:55:48 <ski> roelof : also, i have to leave soon
06:55:59 <ski> oh, right
06:56:25 <roelof> no problem. If you decide to look later and give a respons on reddit it's allright with me 
06:56:37 <nicow> Ankhers: any thoughts?
06:56:58 <ocharles__> any hackage admins around who can edit package metadata? https://hackage.haskell.org/package/dataenc doesn't build on 7.10 because the base upper bound is too restrictive - should that be edited via just metadata?
06:57:03 <ocharles__> (with the bound increased it builds fine)
06:58:19 <sbrg> Anyone here using emacs + org-mode and org-babel for running haskell code? Seems to be broken, but I'm not sure if it's something regarding my setup etc.
06:58:26 <m1dnight_> When using a cabal sandbox, is it possible to make happy produce an info file? (with the --info flag0?
06:58:52 <m1dnight_> I tried `cabal exec happy --info src/Lexer.x` but it thinks the --info flag is for cabal exec.
06:58:59 <ski> roelof : instead of `prop_smaller a b c = (b <= 1 || c <= 1 || a <= 1) || smallerRoots a b c  <= largerRoots a b c', it's better to say `prop_smaller a b c = all (> 1) [b,c,a] ==> smallerRoots a b c <= largerRoots a b c'
06:59:51 <roelof> ski:  oke, i can change that one . That's the only test who is working fine 
07:00:10 <ski> similarly for the other test
07:00:28 <ski> (that's a refactoring, so won't change whether it fails or not, though)
07:00:49 <roelof> ski : oke 
07:01:09 <jophish> Ugh, the numeric hierarchy just seems to get on my nerves all the time
07:01:31 <ski> instead of `mapM_ (\(s,a) -> printf "%-25s: " s >> a) tests', i'd say :
07:01:40 <ski>   forM_ tests $ \(s,a) -> do
07:01:45 <ski>     printf "%-25s: " s
07:01:48 <ski>     a
07:02:08 <jophish> Why on earth does the Real class have Ord as a superclass!!! Ordering the "real" Reals is undecidable 
07:02:09 <ski> (or back on one line, if you prefer)
07:02:52 <ski> @instances Real
07:02:58 <lambdabot> (Data.Fixed.Fixed a), (Shrink2 a), Blind a, CReal, Double, Expr, Float, Int, Int16, Int32, Int64, Int8, Integer, Large a, Natural, Ratio a, Small a, Sym a, Word, Word16, Word32, Word64, Word8
07:03:16 <jophish> It's just forcing me to put instances filled with 'toRational = error "This function can't be defined for this type"'
07:04:24 <roelof> ski: can you paste the last change. I do not see complete what you mean ? 
07:04:29 <merijn> jophish: Wait, what? How are the reals not orderable?
07:05:13 <merijn> Complex numbers aren't orderable (or rather, they have multiple sensible orderings)
07:05:21 <jophish> merijn: sorry, I phrased that poorly. Some reals aren't computable
07:05:31 <jophish> so it's not possible to define (==) for them
07:05:49 <julianleviston> jophish:  (==) is in Eq, not Ord.
07:05:53 <quicksilver> but that's not a big worry in a programming language, since we only have representatives for the computable ones.
07:05:55 <merijn> In what way aren't they compotable?
07:06:00 <jophish> Eq is a superclass of Ord julianleviston 
07:06:06 <maukeauke> maybe they shouldn't be Real then
07:06:14 <julianleviston> jophish: sorry :) lol
07:06:24 <merijn> Either you have an infinite precirsion Real in which case there's no problem
07:06:27 <jophish> merijn: https://en.wikipedia.org/wiki/Chaitin%27s_constant is my favorite 
07:06:29 <ski> merijn : reals form a linear order, but not a total order
07:06:37 <merijn> Or you have a finite representation in which case the problem doesn't exist either
07:06:41 <quicksilver> haskell makes no claim that the Num hierarchy is good for non-computable numbers.
07:06:57 <jophish> quicksilver: I'm writing a type for arbitrary precision reals
07:06:58 <ski> "in which case there's no problem" -- not so
07:07:09 <quicksilver> jophish: arbitrary precision is quite different from uncomputable
07:07:17 <ski> merijn : you can't decide trichotomy
07:07:18 <merijn> ski: Why not? You need to fall to some finite precision and then you can order again
07:07:19 <jophish> and I'd rather not be forced to write in Equality which will diverge if they're equal
07:07:33 <roelof> ski : can you make a paste how you would like to see the main function ? 
07:07:38 <merijn> jophish: How is that a problem?
07:07:38 <SX> hi! tell me please, how to profile stack project? I build it with --library-profiling and --executable-profiling (and run with +RTS -p). It actually generates prof file, but it's said 100% of work happens in main.
07:07:58 <merijn> jophish: Computing equality on uncomputable values is extensionally uncomputable
07:08:16 <SX> All other calls with 0 time
07:08:20 <merijn> jophish: So unless your implementation of Reals supports intensional equality I don't see a problem?
07:08:39 <mpickering> SX: you need something like -fprof-auto to add cost centres
07:08:42 <merijn> And if it does, then use intensional equality insteead of extensional
07:09:01 <merijn> jophish: How is bottom for comparing uncomputable values *worse* than bottom for EVERY comparison?
07:09:01 <quicksilver> even if you have a representation for arbitrary precision arithmetic in which equality is slow or impossible 
07:09:09 <jophish> merijn: the instance for Eq I can kind of understand, with a big comment saying "Don't call (==) if the numbers are equal"
07:09:12 <quicksilver> that doesn't mean those numbers are uncomputable, surely.
07:09:14 <SX> mpickering: for executable or everywhere? I do have that in .cabal
07:09:19 <jophish> but other funcitons such as toRational have no proper answer
07:09:28 <quicksilver> btu I can certainly agree with you that (==) is a pain for a type like that
07:09:33 <quicksilver> see also CReal on hackage
07:09:41 <lpaste> ski pasted “Spec.hs” at http://lpaste.net/143444
07:09:47 <jophish> quicksilver: yeah, I started writing this because that seems unmaintained
07:09:51 <mpickering> SX: https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/prof-compiler-options.html
07:09:53 <maukeauke> :t showCReal
07:09:55 <lambdabot> Int -> CReal -> String
07:10:02 <jophish> and exposes (==) meaning "is equal to 40 decimal places"
07:10:06 <merijn> jophish: I don't see how toRational is a problem for uncomputable values?
07:10:07 <quicksilver> yes
07:10:09 <mpickering> Well, you need it for the executable you are profilng
07:10:28 <merijn> The rational value of an uncomputable real is logically still uncomputable
07:10:32 <jophish> merijn: toRational pi -- what would you return?
07:10:44 <maukeauke> > toRational (pi :: CReal)
07:10:45 <merijn> > pi :: Ratio Int
07:10:48 <lambdabot>      No instance for (Floating (Ratio Int)) arising from a use of ‘pi’
07:10:48 <lambdabot>      In the expression: pi :: Ratio Int
07:10:48 <lambdabot>  *Exception: CReal.toRational
07:10:55 <merijn> oh, pi is Floatin only
07:10:58 <quicksilver> that is not about computability, jophish 
07:11:06 <quicksilver> it's a good point, but it's not a computability point.
07:11:13 <jophish> quicksilver: yeah, that's right
07:11:17 <quicksilver> pi is perfectly computable
07:11:22 <quicksilver> just not rational.
07:11:37 <maukeauke> > showCReal 42 pi
07:11:41 <lambdabot>  "3.141592653589793238462643383279502884197169"
07:11:44 <SX> mpickering: if one function calls inline function, which calls another (heavy) function, will this heavy function present in prof file?
07:12:05 <jophish> It just seems daft to have to define (==) which can only be called on values which aren't equal
07:12:11 <quicksilver> I agree.
07:12:12 <roelof> ski :   Not in scope: ‘sp’ error message on your improvements ? 
07:12:20 <maukeauke> _ == _ = False
07:12:23 <maukeauke> -- optimized
07:12:28 <mpickering> SX: I think so.. couldn't say without trying
07:12:37 <merijn> jophish: Why can it only be called on unequal values?
07:12:37 <jophish> also, all the values in Data.Complex depend on RealFloat, when Fractional or Floating would do
07:12:55 <maukeauke> infinite precision
07:12:57 <jophish> merijn: because if he values are equal, then (==) will loop forever trying to find the first digit where they are not
07:13:02 <jophish> the*
07:13:15 <quicksilver> jophish: if they used Fractional or Floating, then you'd be able to Complex Complex
07:13:24 <quicksilver> jophish: that's why they use RealFloat...
07:14:00 <jophish> quicksilver: is that so terrible?
07:14:11 <quicksilver> I think you can make an argument that (==) and `toRational` shouldn't be where they are - the num hierarchy wasn't planned in terms of sensible representations of arbitrary precision arithmetic
07:14:23 <quicksilver> on the other hand, that's by no means the only flaw in the num hierarchy
07:14:24 <quicksilver> :)
07:14:24 <lpaste> ski annotated “Spec.hs” with “slight reformulation” at http://lpaste.net/143444#a143446
07:15:06 <quicksilver> jophish: I suspect lots of Complex Complex operations don't make sense
07:15:09 <jophish> oh well... I guess I'll just define foo = error "the num hierarchy is broken :("
07:15:13 <ski> roelof : sorry, `sp' was apparently a mispaste of mine of `s '
07:15:15 <quicksilver> yup
07:15:42 <jophish> quicksilver: I think in this case I'd prefer not depending on an inappropriate typeclass to filter these things
07:17:35 <ski> jophish : better to not define `(==)' then, if it can be avoided
07:18:11 <jophish> ski: sadly there are too many things that depend on Eq when they shouldn't
07:18:51 <quicksilver> jophish: yes, that is odd I agree
07:19:13 <roelof> ski  with this code I see the tests fail as I describe under it  : http://lpaste.net/143447
07:20:27 <SX> mpickering: yup, I need to add -fprof-all and -fprof-cafs to library as well
07:20:32 <SX> mpickering: thank you!
07:20:34 <ski> roelof : next time, annotate the original paste with updates
07:20:59 <roelof> sorry : I loose track 
07:21:01 <ski> roelof : yes, obviously you the tests still behave in the same way (though slightly more efficiently, due to using `==>')
07:21:38 <roelof> I can make the first test pass with chancing a <= 1 to a < 1 
07:22:45 <ski> i don't think randomly changing the behaviour of the test around is going to help much
07:22:51 <lpaste> Copperis pasted “RPN calculator” at http://lpaste.net/143448
07:23:30 <roelof> ski:  but the second is not going to work. That is why I asked you for help 
07:23:37 <ski> you should focus on understanding exactly when (for which `a',`b',`c') `smallerRoots a b c' will be greater than `largerRoots a b c'
07:24:32 <ski> (well, preferably think in terms of the problem domain. but since the code for `smallerRoots' and `largerRoots' is so simple, and because you don't understand the problem domain well enough, it amounts to the same thing)
07:24:48 <roelof> ski:  I figured that out when a b c are all greater then 1 
07:25:07 <ski> that's only a sufficient condition
07:25:38 <roelof> ski : ??? 
07:26:59 <Jinxit> how do you do an "and" in parsec? I want to, for example, parse a 'lower' followed by 'many alphaNum', and get the result of both appended
07:27:27 <quicksilver> Jinxit: (,) <$> lower <*> many alphaNum
07:27:36 <quicksilver> Jinxit: depending what you mean by 'appended'
07:27:47 <roelof> ski:  Sorry I do not understand what you mean by only a suffiencent condition ? 
07:27:48 <quicksilver> (:) <$> lower <*> many alphaNum
07:27:49 <quicksilver> perhaps
07:28:05 <Jinxit> let me test that
07:28:12 <Jinxit> but I think that does what I want to
07:28:30 <ski> roelof : also, i think you have bugs in `largerRoots'
07:29:05 <ski> Jinxit : `liftA2 (,) lower (many alphaNum)' is another way to formulate the same thing
07:29:13 <roelof> oke, maybe that is the reason some of the tests fail 
07:29:43 <roelof> maybe I first have to try to make it work with the non degrating version 
07:30:49 <ski> roelof : also, i'm not sure why you're out-of-the-blue returning `0' in the alternate cases
07:31:22 <ski> in `numberRoots' you can use a `where' to give a name to `b * b - 4 * a * c'
07:31:26 <ski> e.g. `discriminant'
07:31:52 <ski> (and your brackets in that one are redundant)
07:31:54 <roelof> ski oke but where is not explained in the book. That in the next part of the chapter 
07:32:07 <ski> ok
07:32:26 <Jinxit> quicksilver: works well, thanks :) I was missing the <*>
07:32:33 <roelof> ski:  that can be . that is something I try to solve when the code works (reductant brackets) 
07:32:51 <ski> roelof : does it require `smallerRoots' and `largerRoots' to return nonsensical answers in some cases ?
07:33:08 <ski> (referring to the `0')
07:34:14 <jophish> One more thing! Why is atan2 in RealFloat?@
07:35:15 <roelof> ski : here is the exact text of the exercise : http://lpaste.net/143450
07:35:15 <julianleviston> damn. I was hoping Control.Concurrent.Async’s async would have stopped Language.Haskell.Interpreter’s runInterpreter from hijacking the signals…. anyone know how I can “get around” this problem with Language.Haskell.Interpreter ? It’s “known” and on the haddocks...
07:36:16 <jophish> ah, the default definition uses isNegativeZero
07:37:02 <julianleviston> This is what it says NB. The underlying ghc will overwrite certain signal handlers (SIGINT, SIGHUP, SIGTERM, SIGQUIT on Posix systems, Ctrl-C handler on Windows). In future versions of hint, this might be controlled by the user. at https://hackage.haskell.org/package/hint-0.3.3.2/docs/Language-Haskell-Interpreter.html
07:37:28 <julianleviston> how might I go about reverting that behaviour so I don’t have to forcekill my app when it runs?
07:38:40 <roelof> ski : maybe I take a fresh look at the Roots calculation tomorrow. I think I have to rewrite the clauses 
07:39:16 <ski> roelof : ok
07:40:05 <ski> roelof : that doesn't say what to do in case there's only a single root
07:40:53 <ski> (unless you interpret "smaller" and "larger" laxly. but in that case `smallerRoot' is also wrong)
07:41:10 <ski> roelof : also, the names of your functions are wrong
07:41:52 <roelof> ski:  no so I suppose that I have to calculate both when there is a single root 
07:42:18 <roelof> ski:  names wrong ? The names are given in the exercises 
07:42:47 <ski> yes, but you didn't use those names
07:42:59 <roelof> ski : is this better code : http://lpaste.net/143454
07:43:25 <ski> roelof : next time, annotate the original paste with updates
07:44:46 <ski> is `numberRoots a b c' supposed to be `3' when there's infinitely many roots ?
07:45:24 <roelof> yes, that was mentioned in the exercise just above this one 
07:46:21 <ski> apart from the name being wrong, that last paste looks ok
07:46:28 <ski> well, you need to use `==' for comparision, not `='
07:46:56 <ski> oh, and you're also missing a pair of needed brackets
07:47:44 <ski> .. and you're forgetting the `±' in the spec
07:48:23 <nomeata> “This is a big anti-climax for someone coming from a "mainstream" language, where type classes are all in the expected logical hierarchy” – what mainstream language has type classes?
07:48:23 <ski> other than that, it looks just fine
07:48:46 <ski> nomeata : Haskell,Mercury,Clean
07:49:07 <nomeata> Interesting definition of mainstream :-)
07:49:14 <merijn> nomeata: Rust?
07:49:37 <merijn> Probably more Mainstream than Mercury and Clean...
07:49:40 <merijn> Anyway, time to run
07:49:41 <roelof> ski:  thanks , test2 is still failing :( so more work to do 
07:49:42 <quicksilver> I would assume that comment means that other languages have a type hierarchy
07:50:06 <nomeata> I guess so as well.
07:50:11 <quicksilver> although most mainstream languages have a very limited 'hierarchy' if at all, where built-in types are concerned
07:50:42 <julianleviston> quicksilver: interesting, because Haskell _doesn’t_ have a type hierarchy, does it…?
07:50:44 <quicksilver> Java tried to have covariant array and look where that took it :)
07:50:59 <quicksilver> julianleviston: indeed :) inheritance is broken and we are the richer for not having it :P
07:51:12 <julianleviston> quicksilver:  completely agree
07:51:23 <ski> coinheritance, otoh ..
07:51:53 <Guest56124> Hi!  I am going crazy trying to compose two functions of type (a -> [Maybe a]) to get another of the same type
07:51:57 <julianleviston> quicksilver:  I think a lot of people miss this when they come from other languages. They translate typeclasses into classes in their heads, but you can’t put your data into a messy bound up hierarchy like that… the data needs to be free, otherwise you can’t compose functionality.
07:52:30 <Guest56124> right now I have weirdCompose g h = (\x -> concat . fmap (fmap g) . h $ x), and I don't understand the error messages
07:52:43 <julianleviston> Guest56124: the type is a -> [Maybe a]   for both?
07:52:45 <roelof> ski : thanks, with a < 0  and b < 0 and c< 0 alll test were successfull :) 
07:52:56 <julianleviston> Guest56124: how can you compose those?
07:53:01 <liste> Guest56124 think your type as Monad m => a -> m (m a)
07:53:02 <ski> Guest56124 : `runMaybeT ((MaybeT . f) <=< (MaybeT . g))' ?
07:53:03 <nomeata> @djinn (a -> [Maybe a])->(a -> [Maybe a])->(a -> [Maybe a])
07:53:03 <lambdabot> Error: Undefined type []
07:53:07 <nomeata> :-(
07:53:27 <roelof> ski : many many thanks from a cold Netherlands 
07:53:37 <Guest56124> julianleviston: yes, same type for both
07:53:48 <ski> roelof : you should paste the whole of your code, to make sure there's no bug lurking
07:53:49 <roelof> tomorrow work on the other tests 
07:53:55 <jophish> What does djinn do?
07:53:57 <ski> roelof : .. or, rather, *annotate* the paste
07:54:03 <ski> @help djinn
07:54:03 <lambdabot> djinn <type>.
07:54:03 <lambdabot> Generates Haskell code from a type.
07:54:03 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
07:54:08 <Guest56124> liste: OK, I think that's helpful
07:54:23 <roelof> I will use the last lpaste from you and annote it 
07:54:24 <ski> preflex: xseen augustss
07:54:25 <Guest56124> ski: that'll take me a bit to digest but thanks
07:54:27 <jophish> ah, thakns ski 
07:54:33 <quicksilver> julianleviston: it's an instance of Kleisli composition
07:54:45 <ski> jophish ^
07:54:49 <julianleviston> quicksilver: ah ok.
07:54:49 <quicksilver> julianleviston: but if we want to use >=> or >>> directly we need wrappers to find the right instances :/
07:54:51 <Guest56124> liste: actually I know that's helpful, but again it will take me a minute
07:55:31 <ski> Guest56124 : actually s/runMaybeT/runMaybeT ./
07:56:07 <julianleviston> :t (>=>)
07:56:09 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
07:56:21 <julianleviston> ahh right
07:56:48 <julianleviston> if your monad is [], do you not end up with a cartesian product like result?
07:57:03 <quicksilver> julianleviston: yes absolutely
07:57:04 <julianleviston> or does this work differently?
07:57:06 <roelof> ski : here you have the code what works for me : http://lpaste.net/143444
07:57:08 <quicksilver> julianleviston: that's (probably) what Guest56124 wants.
07:57:15 <julianleviston> quicksilver: right. in that case I hope that’s what s/he wants! :)
07:57:29 <julianleviston> quicksilver:  because there’s an alternative, isn’t there?
07:57:33 <quicksilver> julianleviston: it's quite natural when doing selection type things
07:57:46 <Guest56124> thanks all!
07:58:01 <quicksilver> julianleviston: 'find me all <div>s with class 'foo'' and then within them 'find me all <spans> with class 'bar''
07:58:18 <quicksilver> julianleviston: is, with a little work, a problem of the general shape Guest56124 presented.
07:58:26 <julianleviston> quicksilver: sure.
07:58:31 <quicksilver> that's why HaXml and HXT use types of that shape
07:58:48 <julianleviston> quicksilver:  things of type a that have things of type a in them. Yup.
07:59:32 <ski> roelof : unfortunately both `smallerRoot' and `largerRoot' are incorrect
07:59:47 <roelof> ski:  :( 
08:00:03 <ski> roelof : you didn't fix the "you're also missing a pair of needed brackets" complaint
08:00:15 <quicksilver> haxml has the composition operator "o :: (Content i -> [Content i]) -> (Content i -> [Content i]) -> (Content i -> [Content i])
08:00:21 <ski> roelof : and you have a `-' in the wrong place
08:00:33 <ski> roelof : well, rather, too few `-'s
08:00:34 <quicksilver> HXT achieves the same result by providing an Arrow instance for its types, so you just use >>>
08:01:18 <ski> roelof : you should test them on some quadratic equations that you know the solutions for
08:02:34 <roelof> ski you mean on the part where I try to make b negative
08:03:17 <julianleviston> :t (<=<)
08:03:19 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
08:03:21 <roelof> Testing by some know values is a problem. Its a very long time ago that I made this sort of things 
08:03:46 <ski> roelof : e.g. `x = 1 \/ x = 2  <=>  x - 1 = 0 \/ x - 2 = 0  <=>  (x - 1)*(x - 2) = 0  <=>  x^2 - 3*x + 2 = 0  <=>  -2*x^2 + 6*x - 4 = 0', so e.g. try `smallerRoot (-2) 6 (-4)' and `largerRoot (-2) 6 (-4)'
08:04:05 <ski> roelof : if you mean `(- b)', then no
08:05:00 <ski> @let smallerRoot a b c = ((- b) + sqrt ( b * b - 4 * a * c)) / 2 * a; largerRoot a b c = ((- b) + sqrt ( b * b + 4 * a * c)) / 2 * a
08:05:01 <quicksilver> I wonder if malcolmw still haskells.
08:05:03 <lambdabot>  Defined.
08:05:37 <ski> > [root (-2) 6 (-4) | root <- [smallerRoot,largerRoot]]
08:05:41 <lambdabot>  [4.0,-2.246211251235321]
08:05:53 <ski> roelof : looks wrong, wouldn't you say ?
08:07:49 <roelof> ski:  I did a quick calculation on paper and if I did it right then smallerRoot = 2 and largerRoot = 1 
08:08:39 <julianleviston> roelof: this might help: https://www.mathsisfun.com/quadratic-equation-solver.html
08:08:56 <ski> roelof : well, that's not quite as wrong as your two functions, then
08:09:25 <ski> roelof : so, you probably are mostly just struggling with expressing it in Haskell
08:09:28 * frerich thinks it's somehow lame when people write Haskell blog entries and then go to reddit/g+/whatnot posting links to it *themselves*. I mean, I'm not surprised if the author finds his own article interesting...
08:10:29 <roelof> ski according to the site the answers are 2 and 1 and my code says 4 and -2 
08:10:43 <roelof> so back to the drawing board :( 
08:10:52 <ski> not, `-2', rather roughly `-2.246211251235321'
08:11:22 <ski> roelof : the main problem seems to be that you're getting the formula down wrong in Haskell
08:11:34 <bartavelle> frerich, I kind of support this statement, but you have to bootstrap in some way: if nobody heard of you, nobody will post a link to your post
08:11:50 <roelof> yes. work to do tommorow. Now time for dinner. 
08:11:58 <ski> roelof : in Haskell, `x / y * z' means `(x / y) * z'. if you meant `x / (y * z)', you have to say so
08:12:01 <roelof> ski:  Thanks, for the help so far 
08:12:30 <ski> roelof : that's one of the problems in your code, but not the only one
08:12:42 <roelof> oke, that is what you mean by missing parenthes 
08:13:05 <frerich> bartavelle: So what's the issue with nobody posting a link to your post again? :-)
08:13:31 <frerich> Maybe the whole blog-business is way above my head but I think this self-advertisement defeats the nice 'qualitative filtering' of e.g. reddit.
08:13:39 <frerich> Err sorry for the offtopic talk.
08:13:40 * frerich shut sup
08:14:00 <julianleviston> frerich: haskell-blah? I’m interested
08:14:10 <Zemyla> Why doesn't GHCi apply rewrite rules?
08:15:13 <bartavelle> frerich, it's important when you feel your post will "make the world a better place" :)
08:15:20 <afraca> Hey guys, I'm looking into the mutable IOArray. And while I'm fine in modifying items, I can't find information on growing it.... Is a manual copy necessary? This one: https://hackage.haskell.org/package/array-0.5.1.0/docs/Data-Array-IO.html#t:IOArray
08:15:30 <quicksilver> frerich: isn't it just a way to get comments on a blog with no comment facility?
08:15:49 <quicksilver> frerich: (or just because you prefer the comment facility / community of hackernews)
08:16:00 * frerich promised to shut up and intends to keep that promise :-)
08:16:05 <quicksilver> sorry
08:16:21 * ski saw no promise
08:16:29 <quicksilver> you should discuss such things in #haskell-blah though frerich 
08:16:31 <jle`> afraca: i think so
08:16:33 <quicksilver> if you wanted to.
08:16:43 <jle`> afraca: the API for the array library is a bit minimal
08:16:53 <jle`> people like to use the vector library instead, for that reason
08:17:17 <quicksilver> afraca: yes, you just need to copy it; Vector is probably the better library. Not using either is, with a high probability, an even better choice :)
08:17:17 <afraca> Ah, yeah, bit minimal. But I'm stuck due code of others
08:17:49 <afraca> Except if there's a performance gain in moving to the Vector package
08:17:59 <afraca> then I could move maybe
08:18:01 <jle`> yeah, i mean, it gives you enough to actually *write* what you want to do, just no convenience fuctions like what you're looking for, heh
08:19:03 <jle`> afraca: i think the vector library is a wrapper over the array library.  but you get some possible performance gains in some areas too maybe...it would be worthwhile to benchmark
08:19:28 <roelof> ski : did some trying and this are my answers now : 4.0  -2.246211 . Are these one well 
08:19:33 <quicksilver> it's not a wrapper over the array library
08:19:42 <quicksilver> it might use some of the same underlying GHC primitives
08:19:46 <quicksilver> but that's not quite the same
08:20:16 <quicksilver> oh, hey, I was wrong :)
08:20:25 <quicksilver> (boxed) Vector *is* a wrapper around Array
08:20:32 * quicksilver apologises
08:20:33 <afraca> In that case I'll stick, thanks
08:20:52 <jle`> well, there's  http://hackage.haskell.org/package/vector-0.11.0.0/docs/src/Data-Vector.html#Vector that suggests it's a wrapper over Array, but
08:20:59 <jle`> that's actually Data.Primitive.Array, not Data.Array
08:21:02 <jle`> .Array
08:21:03 <julianleviston> quicksilver: I thought a vector was quite a different thing than an Array… 
08:21:12 <julianleviston> quicksilver:  isn’t Array mutable, and Vector not?
08:21:31 <jle`> julianleviston: in terms of haskell, there are both mutable and immutable arrays
08:21:32 <ski> roelof : "Are these one well" ?
08:21:38 <jle`> and vectors
08:21:45 <julianleviston> jle`: oh ok :)
08:21:53 <jle`> vectors and arrays aren't different in terms of what they are as data structures, at least the ones from the vector and array package
08:22:15 <jle`> they just offer different API's...but abstract data type interface is essentially the same, semantically
08:22:24 <roelof> ski : did some trying and this are my answers now : 4.0  -2.246211 . Are these one well with -2 6 -4 ? 
08:22:29 <julianleviston> jle`: isn’t an array random access, whereas a vector is usually a tree?
08:22:31 <c_wraith> Well...  Technically, Vector's fusion framework means that it might not ever have that data representation in memory at all.
08:22:39 <ski> roelof : no, you should get `1' and `2'
08:22:48 <c_wraith> julianleviston: Not in any language I know fo
08:22:52 <c_wraith> Or "of"
08:22:53 <jle`> julianleviston: the vectors in the vector library are not trees
08:22:58 <dfeuer> Ha! I just deleted a ton of crap from Prelude.Extras: https://github.com/ekmett/prelude-extras/pull/5/files
08:22:58 <Copperis> I have a function that returns an Either. It's left if it's one type, right if it's another. How can I add a possible error value to that result too? Roll my own data type?
08:23:16 <roelof> then I will look again tommorrow. Now I have to make dinner 
08:23:19 <julianleviston> c_wraith: I think it might be that way in Clojure.
08:23:24 <jle`> julianleviston: vectors from the vector package also gives random access
08:23:24 <roelof> ski:  thanks so far 
08:23:28 <dfeuer> Copperis, you can nest them!   Either e (Either a b)
08:23:28 <ski> np
08:23:31 <julianleviston> c_wraith: but you would probably know better than me I’m guessing!
08:24:00 <jle`> they are essentially the same, from an abstract data type point of view, but yeah, i think vector is famous for fusion
08:24:04 <c_wraith> julianleviston: clojure Vectors are trees, yes.  I forgot them.  :)
08:24:22 <ski> Copperis : maybe you meant `Either A (B,Maybe C)' ?
08:24:24 <jle`> afraca: that might be one situation where it's better; vectors are great at fusion, so your programs might actually be more performant overall
08:24:42 <jle`> besides, premature optimization is the root of all blah blah
08:24:52 <julianleviston> c_wraith: I thought Haskell actually had an implementation of clojure-like “Persistent Data Structures” with Vector / Map / Set implemented as high branching trees, too...
08:25:15 <jle`> there's Seq, a finite data structure which is implemented as a finger tree
08:25:19 <c_wraith> julianleviston: there's one hidden in unordered-containers.  I don't know that it's exposed as a sequence type on its own
08:25:33 <julianleviston> c_wraith:  such as… https://hackage.haskell.org/package/persistent-vector
08:25:57 <Copperis> ski, so either it's an error or a tuple of (B, Maybe C)?
08:25:59 <jle`> interesting
08:26:26 <julianleviston> there’s also some of this: https://github.com/exclipy/pdata
08:26:33 <julianleviston> but I have no ideas about that.
08:27:20 <Copperis> dfeuer, nesting would work. Is it idiomatic to write error handling code like that? With nested Eithers?
08:27:23 <ski> Copperis : if you want it to be ?
08:27:24 <julianleviston> I thought it was weird when I came to Haskell that we use lists as data structures rather than the high branching tries, actually...
08:27:29 <c_wraith> julianleviston: but C++ and Java vectors are both array-backed types.  So it's a pretty common name.
08:27:41 <julianleviston> c_wraith: I see.
08:27:59 <c_wraith> julianleviston: it's because of laziness.  Lists are sequential iteration reified as a data type.
08:28:04 * quicksilver smiles at "log n but it never exceeds 7 so you can treat it as constant"
08:28:06 <dfeuer> Copperis, why is your underlying type based on Either? You might consider a custom sum type unless you want Either's instances.
08:28:21 <jle`> using lists as a data storage thing for random access is actually not too preferred, either
08:28:22 <c_wraith> julianleviston: they're a pretty bad structure for storing data, but they're great for iterating over it sequentially.
08:28:50 <julianleviston> c_wraith: yeah, but if you want nth key access, they kind of suck.
08:28:50 <dfeuer> List = Stack
08:28:53 <dfeuer> Sort o.
08:28:57 <julianleviston> c_wraith:  and efficient appending.
08:29:00 <jle`> Copperis: do you know how to define your own algebraic data types?
08:29:14 <dfeuer> Lists are good for storing things that are accessed according to stack discipline.
08:29:17 <afraca> jle' : thanks, leaving now
08:29:25 <jle`> take care!
08:29:27 <julianleviston> c_wraith: whereas high branching trees are really good at those two things…
08:29:30 <dfeuer> They're also pretty good for streaming things from one piece of code to another.
08:29:32 <c_wraith> julianleviston: you can append just fine, so long as you only ever iterate once. :)
08:29:45 <quicksilver> julianleviston: unordered-containers is also HAMT
08:29:52 <dfeuer> And as long as you don't nest appends the wrong way 'round!
08:29:55 <julianleviston> quicksilver: what’s HAMT?
08:29:59 <Copperis> jle`, yes
08:30:00 <quicksilver> julianleviston: the thing you just posted
08:30:02 <quicksilver> julianleviston: pdata
08:30:13 <julianleviston> quicksilver: ahhh ok
08:30:15 <jle`> Copperis: can you specify exactly what you want?  as an ADT?
08:30:23 <jle`> it's not super obvious/clear, sorry
08:30:25 <quicksilver> I don't know why pdata exists, given unordered-containers. Maybe it' sbetter but the docs don't suggest it's aware of the other package :)
08:30:28 <lpaste> Copperis pasted “RPN calc” at http://lpaste.net/143460
08:31:02 <Copperis> jle`, no worries. I've pasted my code. I'm trying to figure out how to add error handling to "placeToken"
08:31:27 <TheCrafter> Hello guys! Is there any function like this: ([a], [b]) -> [(a,b)]  ???
08:31:41 <jle`> TheCrafter: that looks like `zip`
08:31:46 <jle`> but in haskell we like to curry our functions
08:31:50 <julianleviston> ah so Data.Sequence is effectively, clojure’s vector type?
08:31:53 <jle`> > zip [1,2,3] ['a','b','c']
08:31:55 <lambdabot>  [(1,'a'),(2,'b'),(3,'c')]
08:31:55 <Copperis> or rather "parseToken"
08:32:20 <julianleviston> IIRC, clojure’s vector type has 64-wide branching tries.
08:32:27 <jle`> Copperis: so you want to add another possible "type" of error?
08:32:39 <TheCrafter> thanks jle` maybe I can work with that
08:32:51 <dfeuer> julianleviston, Data.Sequence has lousy constant factors, but there are some things it can do *extremely* well.
08:32:52 <jle`> do you want: Either (Either a b) c ?  either succeed with c, or fail with either a or b?
08:33:05 <julianleviston> oh… HAMT stands for Hash Array-Mapped Trie. aha :)
08:33:06 <jle`> TheCrafter: you can use `uncurry` if you really want the uncurried version
08:33:12 <jle`> :t uncurry zip  -- TheCrafter 
08:33:14 <lambdabot> ([a], [b]) -> [(a, b)]
08:33:29 <quicksilver> julianleviston: A 2-3 fingertree is different from a 64-trie
08:33:32 <quicksilver> quite different
08:33:41 <julianleviston> quicksilver: yep, I just got that. :)
08:33:42 <quicksilver> but Data.Seq has good symptotics and good sharing
08:33:53 <julianleviston> “As it happens, there is a HAMT library in Haskell; however, because of technical limitations in Haskell, it is rather slower than the JVM version” 
08:34:07 <Copperis> jle`, um, I need to think about this actually, what goes where
08:34:23 <jle`> Copperis: that's the fun part :)
08:34:35 <quicksilver> julianleviston: I don't know clojure - but I presume they don't have sharing?
08:34:45 <julianleviston> quicksilver:  yeah, that’s the persistent part.
08:34:53 <jle`> values of type Either (Either a b) c are: Left (Left x), Left (Right y), and Right z
08:35:05 <jle`> so, fail with a Left x, or fail with a Right y, or succeed with a z
08:35:08 <quicksilver> oh
08:35:13 <julianleviston> quicksilver: so Data.IntMap is basically on performance par with clojure vectors. I still don’t really see why they’re not a “built in” type, tho…
08:35:13 <jle`> if this gets unweildy you can just create your own ADT
08:35:51 <julianleviston> quicksilver:  to clarify, they DO have sharing - that’s the persistent part of “Persistent Data Structures”. 
08:35:57 <julianleviston> quicksilver: https://www.quora.com/Why-did-innovation-on-persistent-data-structures-come-from-Clojure-before-Haskell
08:36:08 <tobiasBora> Hello !
08:36:16 <tobiasBora> I have a problem with Cabal
08:36:44 <tobiasBora> I do "cabal update" and I have a "cabal: Codec.Compression.Zlib: premature end of compressed stream" error
08:36:45 <julianleviston> quicksilver:  interestingly, the impression most people (including most clojurists) have is that Clojure “discovered” and popularised these data structures, but I think the truth is they’ve been in libraries in Haskell for a great many years.
08:36:52 <quicksilver> julianleviston: haskell tries to be minimal on built-in types. What would be the advantage of building them in?
08:37:18 <quicksilver> julianleviston: it looks like clojure's vector doesn't support good sharing behavior for joining two vectors together
08:37:42 <julianleviston> quicksilver:  yeah they have some downsides. Like getting a chunk of one out is a bad thing to do too many times, IIRC.
08:37:43 <Gurkenglas> Copperis, doesn't line 24 gurantee that line 26 has (head . tail $ acc) undefined? (This is one reason for why you should use pattern matching.)
08:38:18 <julianleviston> quicksilver: well, I can only tell you how it was useful from a Clojure perspective, and that was that they had a built in syntax, and so you tended to use them more (along with Maps and Sets)… and they were quite efficient at a lot of useful things we’d ordinarily use Lists for in normal Lisp… which means 
08:38:27 <julianleviston> … general code tends to run faster.
08:39:08 <julianleviston> quicksilver: not being pro-clojure here at all. I think you need to always think carefully about your data structures.
08:39:21 * hackagebot claferIG 0.4.2.1 - claferIG is an interactive tool that generates instances of Clafer models.  https://hackage.haskell.org/package/claferIG-0.4.2.1 (mantkiew)
08:39:23 * hackagebot crypto-enigma 0.0.2.1 - An Enigma machine simulator with display.  https://hackage.haskell.org/package/crypto-enigma-0.0.2.1 (Orome)
08:39:31 <quicksilver> julianleviston: yup, the built-in syntax thing is seductive but you get used to it
08:39:48 <quicksilver> julianleviston: haskell's operators look like built-in syntax sometimes :)
08:39:54 <tobiasBora> I'm under a university transparent proxy, I don't know if it can explain my cabal error...
08:39:55 <julianleviston> quicksilver:  yeah :)
08:40:21 <nshepperd> with OverloadedLists I think any haskell container type can by 'built in' now
08:40:22 <jle`> not having the structures be built in means you somewhat have a more open choice between Map, HashMap, Vector, Array, Seq, etc., i guess
08:40:29 <jle`> haskell doesn't have to "pick" one over the other
08:40:32 <jle`> as a language
08:40:37 <Copperis> Gurkenglas, yup, thanks
08:40:39 <quicksilver> > 1 <| 2 <| 3 <| Seq.empty
08:40:42 <lambdabot>  fromList [1,2,3]
08:40:50 <quicksilver> jle`: not having built-in syntax makes things abstractable
08:41:18 <dramforever> tobiasBora: it could be. that message basically means "that does not look like a compressed file"
08:41:19 <quicksilver> jle`: you don't have to ask questions like "how do I turn { <key> :: <value> } into a function?"
08:41:27 <jle`> ah
08:41:27 <sena-kun> Hi, folks. Earlier I was here and asked about complex types and IORef's that don't "save" results of modification. I investigated it a bit and found out that it don't work only if I wrap up my IORef in IO. Here's the minimal example of code - http://pastie.org/10495501 I can't remove IO around IORef, because it would be too hard to create/modify global type with many IORefs, when newIORef returns ref wra
08:41:33 <sena-kun> pped up in IO. And I can't write without mutable state, because I have not enough memory. My question is: why nested IO actions don't work and is there any way to make it work?
08:41:36 <quicksilver> that being some totally made-up idea of what syntax might look like for a built-in assocation map
08:42:05 <dramforever> perhaps the proxy messed up with the file somehow
08:42:40 <jle`> sena-kun: you probably want currentState :: IORef [Int]
08:42:48 <julianleviston> jle`: I just mean built in in the same way that lists are built in… 
08:42:48 <jle`> sena-kun: because you want to pass around the IORef
08:42:59 <quicksilver> julianleviston: lists aren't built-in
08:43:05 <jle`> sena-kun: you don't want to pass around an IO action to create a new IORef
08:43:05 <julianleviston> quicksilver: exactly my point.
08:43:06 <quicksilver> julianleviston: well, not really
08:43:20 <jle`> sena-kun: you want to pass around the same IORef to every single place that uses it
08:43:29 <quicksilver> they just have a tiny bit of magic around [,,] and (:)
08:43:35 <jle`> sena-kun: if you pass an IO (IORef [Int]), you're passing around an IO action that, when executed, returns a new IORef
08:43:43 <quicksilver> people have talked about overlodable [,,] syntax before
08:43:52 <jle`> sena-kun: which isn't what you want...you want to pass around the same IORef 
08:44:02 <tobiasBora> dramforever: hum... The problem is that even if I download it by hand it has problems after... I found a bug here : https://github.com/haskell/cabal/issues/2001
08:44:05 <julianleviston> quicksilver: it’d be nice if Data.Map, Data.Set and Data.IntMap had their own syntax and were in Prelude… it’d probably mean people would use them more… maybe.
08:44:12 <julianleviston> quicksilver: but I’m not convinced, really :)
08:44:24 <julianleviston> quicksilver: record syntax is fine, too ;-)
08:44:29 <quicksilver> julianleviston: did you see my comment to jle about abstraction?
08:44:45 <quicksilver> julianleviston: less syntax means it's easier to see how to partially apply things/ how to turn things into functions
08:44:46 <jle`> sena-kun: createPiece :: IO Piece; createPiece = Piece 10 30 (3,4) <$> newIORef [1,2,3]
08:44:47 <nshepperd> eh, I prefer Set.fromList [a, b, c]
08:44:49 <julianleviston> quicksilver: it’s easier to use record syntax than it is to use map, but sometimes all you need is a map :)
08:44:50 <jle`> sena-kun: that should work
08:44:52 <nshepperd> much more obvious
08:45:06 <julianleviston> quicksilver:  I don’t want more syntx, tho...
08:45:11 <jle`> sena-kun: or do st <- newIORef; return (Piece 10 30 (3,4) st)
08:45:34 <jle`> now the Piece data structure contains an IORef, and when you do stuff with that IORef, you modify that same ref
08:45:35 <dramforever> tobiasBroa: I wonder if the proxy is really transparent in that case...
08:45:58 <lpaste> Gurkenglas annotated “RPN calc” with “Copperis, have some refactoring.” at http://lpaste.net/143460#a143462
08:46:20 <Gurkenglas> (Copperis, are you sure line 19 should append the singleton to the right?
08:46:41 <julianleviston> quicksilver: I’ve noticed that Haskellers tend to choose ADTs where a clojurist would have to get by with just a map… but then again, maps are more flexible in other languages (varying keys, for example), so blah :) it’s a silly discussion at this point.
08:47:01 <quicksilver> julianleviston: I've noticed that. In many cases I think the ADT was a good choice.
08:47:05 <julianleviston> quicksilver:  I think ADTs are a better choice, personally, because they the type system help you :)
08:47:07 <nshepperd> people probably would use those types more, but probably just because they'd be forced to learn about Set and Map while learning the syntax
08:47:09 <julianleviston> quicksilver:  agreed.
08:47:21 <julianleviston> nshepperd:  yeah, true :) 
08:47:21 <roelof> ski:  problem solved. See the reddit question. The answers are now good 
08:47:41 <quicksilver> julianleviston: if you say "OK, first thing, let's work out what the natural data structures are for this problem"
08:47:49 <quicksilver> julianleviston: then quite often you solve it better.
08:47:56 <quicksilver> I guess people have different problem solving techniques.
08:47:58 <julianleviston> quicksilver:  you’re correct.
08:48:23 <quicksilver> but I've seen many cases (some of them by me!) where people knock up a hacky solution which passes around the unstructured dictionaries of python/perl-like languages
08:48:25 <julianleviston> quicksilver: no, I realised after I said that that actually that precise “freedom” is what makes it incredibly difficult to debug other langauges.
08:48:26 <sena-kun> jle`: Oh, I understood it, thanks. Okay, but I have a nested type. It means I should every level(for example, Piece is a part of Segment, Segment of s part of Circle) wrap with IO?
08:48:43 <quicksilver> and its riddled with bugs because the assumptions on data structure are inconsistent and flawed.
08:48:50 <jle`> sena-kun: your type shouldn't really contain any IO actions
08:48:57 <dramforever> sena-kun: no, IORef
08:49:00 <jle`> instead, make an IO action to initialize your type with new IORefs
08:49:06 <nshepperd> heh, saying 'just' a map sounds weird there
08:49:19 <nshepperd> a map is way too much power for a simple record type
08:49:22 * hackagebot mustache 0.3.1.0 - A mustache template parser library.  https://hackage.haskell.org/package/mustache-0.3.1.0 (justus)
08:49:37 <lpaste> Copperis annotated “RPN calc” with “Copperis, have some refactoring. (annotation)” at http://lpaste.net/143460#a143463
08:49:38 <jle`> sena-kun: createPiece :: IO Piece, createPiece would be an IO action that made a new IORef, and returned a Piece with that IORef
08:49:53 <jle`> sena-kun: same deal for nested types, just make a createTheType :: IO TheType
08:49:59 <julianleviston> hehe interesting, over on #haskell-beginners, just now : MarcelineVQ: was looking into afraca's question and holy balls
08:50:15 <julianleviston> … http://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector.html is amazing
08:50:16 <Copperis> Gurkenglas, it should actually append it to the left. It was a bug I think
08:50:22 <Copperis> annotated it 
08:50:24 <dramforever> sena-kun: btw if you are really *that* short of memory you probably shouldn't be using haskell...
08:50:27 <jle`> sena-kun: you can even use createPiece in that createTheType, so you don't have to re-write it
08:50:52 <julianleviston> I guess including some piece of these data structures in prelude *might* be good just so people become more aware of them.
08:51:34 <lpaste> Gurkenglas annotated “RPN calc” with “Copperis, have some more refactoring. (annotation) (annotation)” at http://lpaste.net/143460#a143464
08:52:12 <c_wraith> Let's just add Free and Cofree to the prelude.  The two of them cover a huge number of data types.  :)
08:52:17 <julianleviston> lol
08:52:22 <julianleviston> c_wraith: ok… sorry.
08:52:28 <jle`> julianleviston: it's weird though to imagine Haskell-the-language including and privileging Vector
08:52:41 <roelof> ski:  thanks for the help. I now can get further in solving this annoying exercise 
08:52:46 <dramforever> and Fix, Mu and Nu as well!
08:52:49 <Gurkenglas> c_wraith, don't forget Fix. (Fix f = Fix (f (Fix f)))
08:52:51 <jle`> but...i think it's a pragmatic real-world thing
08:52:56 <julianleviston> ok ok silly suggestion.
08:53:04 <dramforever> Gurken
08:53:09 <jle`> maybe one day haskell will grow up
08:53:22 <dramforever> Gurkenglas: lol
08:53:36 <julianleviston> I think perhaps we need a pathway, though… a beginner’s / explorer’s prelude “with MUCH MORE IN IT” and the normal one. :)
08:53:53 <julianleviston> the normal one being much leaner, as we now have it.
08:53:53 <Copperis> Gurkenglas, yup, the order is right. It's a stack from the left, so 4 3 / = / 3 4 = 3 / 4
08:54:00 <Zemyla> jle`: Why? It currently privileges [], which is a terrible type for just about everything.
08:54:19 <c_wraith> newtype Fix1 f a = Fix1 (f (Fix1 f a) a) ; type WTF a = Fix1 Cofree a
08:54:22 <Copperis> Gurkenglas, thanks, I'll now now how to employ proper list pattern matching
08:54:36 <dramforever> I wonder if we could get a haskell tutorial going with RebindableSyntax
08:54:38 <c_wraith> wait, that's not quite right
08:54:46 <jle`> it works well for a lot of things, actually
08:54:54 <jle`> just not for the purpose of storing data
08:54:59 <jle`> it's a good structure for denoting things
08:55:32 <sena-kun> dramforever: in every piece I store list a with complex type(lets call it "subtype"). "GlobalType"(with all pieces) can contain about 10k-100k(it depends on what situation I simulate) instances of this subtypes and with 4 gb of RAM it can be hard to construct new global on every change. But yes, I have some doubts about haskell in this problem, but I'll try anyway.
08:56:18 <julianleviston> sena-kun: wait… you have a list with 10 to 100k entries???
08:56:35 <dramforever> julianleviston: wait you mean the beginner one should contain more?
08:56:52 <jle`> sena-kun: i would recommend trying the way with persistent structures first
08:57:05 <julianleviston> dramforever: because you want to walk beginners through some “handpicked” pieces of the language - good things.
08:57:31 <c_wraith> Vector really is kind of an optimization for special cases
08:57:34 <jle`> julianleviston: i guess that wouldn't necessarily need to be a part of Prelude...just a sample Prelude.Explorers module/package
08:57:47 <c_wraith> I would hardly consider it a core type
08:57:51 <sena-kun> julianeviston: I have a list of lists to be accurate, and sum is, yeah, about 10k-100k(but I doubt it will be so many).
08:57:58 <nshepperd> lots of other languages have special syntax for loops
08:58:05 <dramforever> julianleviston: I would agree with that, but...I thought we should get a simpler prelude for newcomers
08:58:09 <nshepperd> having [] seems reasonable in that light
08:58:36 <dramforever> nshepperd: good pun lol
08:58:44 <jle`> [] definitely makes more sense as a "fundamental" data type that it would be nice to have priviledged
08:59:00 <ski> @let smallerRoot a b c = ((( -b ) - sqrt ( (b * b)  - (4.0 * a * c) ) ) / (2 * a) ); largerRoot a b c = ((( -b ) + sqrt ( (b * b)  - (4.0 * a * c) ) ) / (2 * a) )
08:59:02 <lambdabot>  .L.hs:164:1: Warning:
08:59:02 <lambdabot>      Pattern match(es) are overlapped
08:59:02 <lambdabot>      In an equation for ‘largerRoot’: largerRoot a b c = ...
08:59:09 <julianleviston> dramforever: no I don’t think “smaller” is better for newcomers. The opposite. You want to walk them through a bunch of things very quickly… 
08:59:11 <jle`> i didn't know lambdabot did warnings
08:59:32 <ski> hrm
08:59:34 <ski> @let smallerRoot a b c = ((( -b ) - sqrt ( (b * b)  - (4.0 * a * c) ) ) / (2 * a) ); largerRoot a b c = ((( -b ) + sqrt ( (b * b)  - (4.0 * a * c) ) ) / (2 * a) )
08:59:37 <lambdabot>  Defined.
08:59:39 <ski> > [root (-2) 6 (-4) | root <- [smallerRoot,largerRoot]]
08:59:41 <julianleviston> dramforever: show them the landscape. Anyway. I’m offtopicking..
08:59:42 <lambdabot>  [2.0,1.0]
08:59:46 <c_wraith> Really, though, the name [] and the special syntax [a] for types are the only particularly extra stuff lists have.
08:59:47 <sena-kun> jle`: thanks, I'll try to write this way too. Also, other question. When ghci shows memory using after evaluation, what exactly it shows? All memory that was used or maximum?
08:59:47 <jle`> @let doesThisWarn x y = x
08:59:49 <lambdabot>  Defined.
08:59:59 <jle`> :(
09:00:04 <julianleviston> c_wraith:  yeah! :)
09:00:05 * nshepperd didn't intend that pun, but laughed out loud when it was pointed out
09:00:07 <dramforever> julianleviston: oh that landscape thing...that sounds okay
09:00:08 <jle`> i'm not special enough
09:00:09 <c_wraith> sena-kun: it shows amount allocated, not amount resident
09:00:22 <ski> @tell roelof sorry, `smallerRoot (-2) 6 (-4) > largerRoot (-2) 6 (-4)', contrary to the specification
09:00:22 <lambdabot> Consider it noted.
09:00:26 <sena-kun> c_wraith: thanks.
09:00:27 <quicksilver> c_wraith: and the special constructor (:) ;P
09:00:33 <HaskellNub> Hello is there anyone around here who can help someone relatively new to haskell
09:00:38 <quicksilver> c_wraith: but that's not important.
09:00:45 <jle`> HaskellNub: yes, there are a lot of people :D
09:00:49 <HaskellNub> I'm almost done with what I neeed to do 
09:00:55 <c_wraith> quicksilver: if that weren't specifically called out as syntax, it could be a normal infix constructor
09:01:05 <quicksilver> c_wraith: could be, but isn't. *nod*
09:01:22 <lpaste> Gurkenglas annotated “RPN calc” with “Copperis, this further modification in parseToken will crash your program instead of silently going on with some anomalous readFloat outputs.” at http://lpaste.net/143460#a143466
09:01:34 <julianleviston> dramforever: the only reason Clojurists tend to be aware of Set, Map and Vector and their implementation is because Rich Hickey “advertised” them by putting them bang in the language without any imports… you could do the same with a beginners/explorer’s prelude… then people on beginning will get to see some of the most excellent libraries Haskell provides “out of the box” so to speak - it’s just a PR job,
09:01:34 <julianleviston> though really.
09:02:06 <dramforever> ski: yeah actually I came here to say that a while ago...except that I thought the tests said otherwise
09:02:22 <ski> dramforever : sorry ?
09:02:33 <jophish> dramforever: a separate beginner's prelude isn't without its issues
09:02:51 <julianleviston> jophish: fair enough.
09:03:08 <sena-kun> Okay, guys, really thanks for your advices. I'll try to write my problem in persistent way first, if I fail, I'll will do as jle` said about nesting.
09:03:09 <jle`> i think we can just start an `explorers` package that offers Prelude.Explorer
09:03:14 <dramforever> ski: so wait what does the two functions do?
09:03:17 <julianleviston> jophish: it’s probably completely unnecessary, anyway. Nothing a few very good books would fix.
09:03:22 <dramforever> as the name said? 
09:03:29 <jle`> sena-kun: best of luck!
09:03:59 <ski> dramforever : they're supposed to give the lesser and the greater solutions of a quadratic equation given by three coefficients
09:04:00 <HaskellNub> So I've got a program that's supposed to print a matrix line by line, so far it does print, but only the first line
09:04:17 <jle`> what are you using as a matrix?
09:04:25 <ski> @paste
09:04:25 <lambdabot> Haskell pastebin: http://lpaste.net/
09:04:34 <ski> HaskellNub : you can use that ^ to show your code, so far
09:04:38 * hackagebot crypto-enigma 0.0.2.2 - An Enigma machine simulator with display.  https://hackage.haskell.org/package/crypto-enigma-0.0.2.2 (Orome)
09:04:48 <HaskellNub> gonna post my matrix module and the stuff I did 
09:04:49 <julianleviston> HaskellNub: is it just a list of lists?
09:05:10 <ski> (be sure to select "#haskell" as the channel to announce in)
09:05:24 <HaskellNub> http://lpaste.net/143468
09:05:34 <HaskellNub> thats the matrix module they gave me 
09:05:48 <dramforever> ...or do that manually
09:06:12 <HaskellNub> http://lpaste.net/143469
09:06:14 <julianleviston> holy wow.
09:06:16 <HaskellNub> thats my code 
09:06:20 <sleblanc> Can GHCI show documentation on a function? Something like Python's help(obj) function
09:06:36 <julianleviston> sleblanc: not that I know of
09:06:51 <julianleviston> sleblanc: just use hoogle.
09:07:00 <ski> HaskellNub : next time, use the "Annotate" button to annotate the original paste with updates
09:07:08 <jophish> sleblanc: it is possible to do :i foo to get some info
09:07:14 <jophish> :i (+)
09:07:24 <sleblanc> jophish, yeah, but it's not nearly enough
09:07:32 <jophish> sure, I understnad
09:07:43 <HaskellNub> I see, I didn't know that existed
09:07:56 <ski> HaskellNub : `getRowCoordinates x y z' isn't using `x'
09:08:15 <Ferdirand> ideally, the type signature is the only help you need
09:08:20 <c_wraith> sleblanc: There's been talk of that working in the future.  Something about considering moving haddock data into the .hi files.  It's not done now, and I don't think it's planned for 8.0, either.
09:08:32 <sleblanc> julianleviston, I am hacking on Xmonad code so I have to search both Hoogle for Haskell stuff and the XMonad site for everything else, kind of a pain.
09:08:49 <dramforever> ski: found it, line 14 of http://lpaste.net/143447
09:08:52 <sleblanc> c_wraith, glad to hear that it's on the table
09:08:55 <julianleviston> sleblanc: I feel your pain. I wish both source and docs were available from it.
09:08:58 <c_wraith> sleblanc: Can't you tell hoogle to include XMonad?
09:09:14 <HaskellNub> you're right, I was wondering if I could change that function to make a 2d array with all the ordered pairs that match 
09:09:22 <dramforever> ski: Yeah I believe you have seen this wtf test a while ago
09:09:22 <ski> dramforever : what about it ?
09:09:24 <sleblanc> c_wraith, that would mean running my own Hoogle instance?
09:09:32 <HaskellNub> it'd be easier to get the whole matrix that way
09:09:33 <Copperis> Gurkenglas, I don't understand the refactoring with the "maybe" function. The default value is the string, then the whole function beginning with Right, then where's the Maybe? I also did not understand the question in the comment, can you clarify?
09:09:38 <HaskellNub> but I'm not sure how to do that 
09:09:41 <ski> dramforever : not sure what "this wtf test" is
09:09:44 <dramforever> ski: smallerRoot >= biggerRoot wtf
09:10:10 <ski> dramforever : oh, roelof was talking about this in ##math, the other day
09:10:49 <c_wraith> sleblanc: no.  Just start your queries on the web site with +xmonad
09:11:10 <sleblanc> woah, what a game changer
09:11:12 <c_wraith> sleblanc: and any other +packagenames you might want to include in your search
09:11:23 <dramforever> ski: yeah and I remember being taught about this smaller/larger root thing in high school 
09:11:37 <sleblanc> c_wraith, thanks a lot
09:11:46 <dramforever> "Always take the sign of a into account"
09:12:06 <ski> HaskellNub : the `Show' instance is wrong. it ought to generate a valid string representation of a Haskell expression that, when evaluated (in an appropriate environment), will yield the original matrix
09:12:32 <HaskellNub> Yeah, I'm new, I don't know much about the language
09:12:44 <ski> HaskellNub : "that function" being ?
09:12:56 <ski> HaskellNub : i don't understand "make a 2d array with all the ordered pairs that match"
09:12:56 <HaskellNub> which function?
09:13:13 <HaskellNub> with GetRowCoordinates
09:13:30 <ski> dramforever : oh, ok. well, if you reflect a moment on the formula, it's the natural thing to do
09:13:32 <HaskellNub> What that does is create a list of the coordinates of one row
09:13:49 <HaskellNub> but it'd be better if it created a 2d array with each row
09:14:01 <ski> what it is supposed to do ?
09:14:27 <HaskellNub> Well it filters ordered pairs if (0,1) and (1,1) match it puts them on a list 
09:14:39 <HaskellNub> it has a parameter to get a specific row
09:14:48 <HaskellNub> but I want to be able to get them all, instead 
09:14:48 <Gurkenglas> :t maybe
09:14:50 <lambdabot> b -> (a -> b) -> Maybe a -> b
09:15:04 <ski> HaskellNub : `coordinates' already gets them all ?
09:15:16 <HaskellNub> yes but it doesnt, separate them
09:15:16 <Gurkenglas> The first argument (Left "asd") of maybe tells it what to use in case of a Nothing
09:15:31 <HaskellNub> it just gets a list with all of them
09:15:42 <Gurkenglas> The second argument (Right) of maybe tells it what to use on the value in a Just in case of justice
09:16:12 <ski> HaskellNub : possibly `getElements' should use `coordinates' instead of `getRowCoordinates' ? at least if it is supposed to get all the elements of a matrix
09:16:31 <ski> HaskellNub : "separate" how ?
09:16:59 <ski> can you give an example, for a matrix with coordinates in the list `[(1,1),(1,2),(2,1),(2,2),(3,1),(3,2)]' ?
09:17:38 <Gurkenglas> The third argument (passed from the composition in the next line) is Nothing if the list passed to listToMaybe is empty, Just something if there is a head. The comment asks whether the list being empty necessarily means the string passed to your program was empty (as your error message says)
09:17:42 <HaskellNub> like this [[(0,1),(0,2)],[1,1],(1,2)]]
09:18:05 <HaskellNub> like this [[(0,1),(0,2)],[(1,1),(1,2)]] sorry an error there
09:18:33 <HaskellNub> basically itd be recreating the matrix in a 2D array 
09:19:20 <ski> oh, ok. you want to "group by"
09:19:38 <HaskellNub> yes, though I don't know if I'm complicating myself
09:20:22 <ski> probably it's simpler here to not use either of `coordinates' or `getRowCoordinates', then, but use list comprehensions directly
09:21:39 <TheCrafter> Any ideas how to convert this list [ [1,2,3], [4,5,6] ] to this list [ [1,4], [2,5], [3,6] ] . I am trying to write my own function but I was wondering if there is already a function for something like that
09:21:45 <HaskellNub> maybe, but I'm almost finished with this 
09:22:14 <quchen> > transpose [ [1,2,3], [4,5,6] ] -- TheCrafter 
09:22:16 <lambdabot>  [[1,4],[2,5],[3,6]]
09:22:25 <TheCrafter> got it! thanks quchen 
09:22:30 <HaskellNub> be better if I just got the coordinates, then converted the list to a list of elements and finally printed all of it with a map using my listToString
09:23:47 <ChristianS> are there somewhere slides i could use to give a short talk motivating programmers why functional programming, and haskell in particular, is great?
09:24:40 <ChristianS> i was invited to give such a talk but i'm too lazy to prepare it from scratch
09:25:04 <ski> > (getZipList . traverse ZipList) [ [1,2,3], [4,5,6] ]
09:25:06 <lambdabot>  [[1,4],[2,5],[3,6]]
09:25:38 <tekkkz> hmmm ... http://stackoverflow.com/questions/33241799/haskell-chart-gtk-rendering-failed
09:26:46 <ski> HaskellNub : do you have more code you haven't shown ?
09:27:13 <HaskellNub> Well I had the matrix module, and my show module but no thats it 
09:27:16 <ski> HaskellNub : otherwise, i think it would be simpler to do what i said
09:27:36 <HaskellNub> I'd use it, but I don't exactly know how to do it 
09:27:43 <ski> retroactively grouping the result from `coordinates' is possible, but it's simpler to not ungroup in the first place
09:28:09 <ski> > [[(i,j) | j <- [1,2,3]] | i <- [1,2]]
09:28:11 <lambdabot>  [[(1,1),(1,2),(1,3)],[(2,1),(2,2),(2,3)]]
09:28:16 <ski> do you understand how that works ?
09:28:33 <HaskellNub> sort of, first it builds a list with pairs
09:28:44 <HaskellNub> then I'm not so sure what j and i do 
09:28:56 <ski> you could call your matrix `f', and also `listToString' in there
09:29:00 <ski> and use `concat'
09:29:41 <ski> HaskellNub : it builds a list of lists of pairs. the outer list having elements lists, one for each `i'
09:30:06 <HaskellNub> yes I see, I guess if where to use two pairs, I could make a range of those pairs 
09:30:22 <ski> HaskellNub : for each element list, we get one pair for each `j' (repeated again for every `i' going over the outer lists)
09:34:12 <HaskellNub> Awesome, I figure that could use ranges as in groupRows (x,y) = [(x,y)| x <- [1..x] , y <- [1..y]]
09:34:30 <HaskellNub> Awesome, I figure that could use ranges as in groupRows (i,j) = [(x,y)| x <- [1..i] , y <- [1..j]]
09:34:38 <HaskellNub> sorry error there
09:34:44 <ski> > range ((1,1),(2,3))
09:34:46 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3)]
09:36:15 <ski> > let groupRows (x,y) = [(x,y)| x <- [1..x] , y <- [1..y]] in groupRows (2,3)
09:36:19 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3)]
09:36:39 <ski> (though of course there's no grouping there)
09:37:19 <HaskellNub> well I tested it, and it seems to do output what I need
09:39:40 * hackagebot Hish 0.1.2.1 -   https://hackage.haskell.org/package/Hish-0.1.2.1 (jaiyalas)
09:39:50 <mniip> aa,haylp
09:40:14 <HaskellNub> Now I'm not so sure about what comes next, but from what I understand I could just do a map through that list to convert all of those pairs into elements
09:40:27 <HaskellNub> I think my old function could work but I'm not sure
09:41:05 <ArkineTP9> ChanServ: You on?
09:41:48 <mniip> oops random keyboard mashing
09:42:06 * ski gets some tuna for mniip's cat
09:42:28 <ski> ArkineTP9 : try `/msg ChanServ help'
09:43:44 <HaskellNub> got another small question, how can I do nested loops with this, because I'm not really sure
09:44:36 <HaskellNub> for instance I have this getElements (Mat ((x,y), f)) = map f $ groupRows (x,y)
09:44:40 <ski> > [[(i,j) | j <- [1,2,3]] | i <- [1,2]]  -- this is a nested loop
09:44:43 <lambdabot>  [[(1,1),(1,2),(1,3)],[(2,1),(2,2),(2,3)]]
09:44:56 <ski> > [(i,j) | i <- [1,2],j <- [1,2,3]]  -- so is this
09:44:58 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3)]
09:45:13 <HaskellNub> but then how do I make sure that it goes into every list, and it doesn't try to just take the first list as a parameter
09:45:36 <ski> i never got what you meant by "it doesn't try to just take the first list as a parameter"
09:45:58 <HaskellNub> well, let me show the error, I think it explains it better than I do
09:46:26 <ski> why not the code ?
09:46:50 <HaskellNub> ok, I'll do that
09:47:27 <ski> (preferably in an annotation on the earlier paste)
09:47:54 <HaskellNub> so here's everything with the new change http://lpaste.net/143469
09:48:38 <ski> (ty)
09:49:08 <ski> HaskellNub : you want `map (map f)'
09:49:09 <HaskellNub> basically I need to refit that getElements to now take those lists properly, since it took lists before not 2D arrays
09:49:16 <ski> also, i'd skip the `$'
09:49:20 <HaskellNub> I see, I'll do that
09:49:20 <mniip> ski: if only I had a cat
09:49:35 <ski> (using proper brackets as $DEITY intended it, instead)
09:49:42 <mniip> it was jist my phone randomly turning on inmy pocket
09:49:59 <mniip> just in my*
09:50:17 <ski> mniip : perhaps this is a clue from your future-cat ?
09:50:33 <Gurkenglas> Copperis, see my last 4 lines (times :14:22-:17:11)
09:51:13 <ski> HaskellNub : `map (map f)' will apply `map f' on each element list of the outer list, and that in turn will apply `f' on each element of each inner list
09:51:25 <HaskellNub> like this map (map (f groupRows (x,y))) ?
09:51:38 <ski> no
09:51:55 <HaskellNub> less parentheses?
09:52:00 <ski>   map (map f) (groupRows (x,y))
09:52:01 <ski>   ^^^^^^^^^^^
09:52:08 <HaskellNub> oh I see
09:52:17 <ski> the first bit being exactly what i said, not something else
09:52:36 <ski> if you prefer, you could also use a list comprehension
09:53:00 <ski>   [[f x | x <- row] | row <- groupRows (x,y)]
09:53:16 <ski> use whichever is clearer to you
09:54:37 <HaskellNub> map looks clearer to me at least it looks more like what I'd do in a normal language
09:54:51 <HaskellNub> I mean object oriented language or whatever
09:54:52 <ski> also, i'd remove the `instance (Show a) => Show (Matrix a) where' line, and instead define `matrixToString :: Show a => Matrix a -> String'
09:55:08 <ski> HaskellNub : then use that
09:55:22 <breadmonster> ski: If a functor of a functor is also a functor, is there an instantiation for that?
09:55:38 <HaskellNub> I can do that, for modules I mean?
09:55:44 <ski> breadmonster : do you mean `instance (Functor f,Functor g) => Functor (Compose f g)' ?
09:55:55 <ski> HaskellNub : sorry ?
09:56:12 <breadmonster> > instance (Functor f, Functor g) => Functor (f (g a)) where fmap f x = fmap (fmap f) x
09:56:14 <lambdabot>  <hint>:1:1: parse error on input ‘instance’
09:56:22 <breadmonster> That's strange...
09:56:30 <ski> that's a kind error
09:56:59 <HaskellNub> I mean like this a module or something and I'm creating a show method for a Matrix so isn't it supposed to go "instance Show where"
09:57:11 <ski> @let newtype Compose f g a = MkC {unC :: f (g a)}
09:57:13 <lambdabot>  Defined.
09:57:45 <ski> @let instance (Functor f,Functor g) => Functor (Compose f g) where fmap h (MkC fga) = MkC (fmap (fmap h) fga)
09:57:47 <lambdabot>  Defined.
09:57:53 <ski> breadmonster : like that ?
09:58:38 <breadmonster> ski: Yeah, I didn't know you needed a construct for that though.
09:59:04 <ski> HaskellNub : imho, `Show' should be reserved for showing a Haskell expression that evaluates to the given value, not to be used for custom pretty-formatting of data
09:59:15 <ski> breadmonster : it's because we have no type-level lambda
09:59:38 <breadmonster> ski: Good idea, how much work would adding it be?
09:59:54 <ski> breadmonster : `type Compose f g a = f (g a)' doesn't work here, since you can't then make `Compose f g' an instance, since it's not "fully saturated"
09:59:57 <mniip> it's impossible
10:00:16 <HaskellNub> I'm sure you're probably right about that, but I don't really understand this language well enough I think
10:00:24 <ski> breadmonster : the problem is that adding them makes type checking undecidable, iirc
10:00:44 <mniip> type level lambdas break the typesystem inconsistent
10:00:56 <mniip> er
10:01:15 <mniip> s/break/make/
10:01:18 <ski> HaskellNub : perhaps the people constructing the exercise for you had the bad taste of suggesting you use `Show' in this way, in which case there's not much to do .. but i consider it bad style
10:01:29 <breadmonster> ski: Yeah but like so do C++ templates and they work just fine.
10:01:46 <ski> mniip : inconsistent in which sense ?
10:02:48 <mniip> breadmonster: just like you don't have Eq on functions, you won't have type equality on any types
10:04:28 <deception1> is it possible to test REST API's using haskell ?
10:04:53 <deception1> i mean test it using quickcheck
10:06:36 <HaskellNub> nearly done, one last question if I may 
10:09:44 <HaskellNub> how do I go about doing a putStr of that huge string
10:09:55 <HaskellNub> it works on my ghci but not through my module
10:10:32 <mniip> define "doesn't work"
10:10:53 <suppi> what are the drawbacks of using GADTs vs using ADTs?
10:11:12 <ski>   displayMatrix :: Show a => Matrix a -> IO ()
10:11:25 <ski>   displayMatrix m = putStr (..m..)
10:11:43 <HaskellNub> was just doing it in my show method 
10:11:44 <ski> suppi : hm, iirc `deriving' doesn't work as well on GADTs ?
10:11:50 <c_wraith> suppi: type inference fails a bunch more, so you need to add more annotations
10:12:00 <ski> HaskellNub : that's a type error
10:12:12 <ski> @type show
10:12:14 <lambdabot> Show a => a -> String
10:12:18 <ski> wants to return a `String'
10:12:24 <suppi> ski, c_wraith, oh, I see.
10:12:28 <suppi> thank you
10:13:07 <ski> suppi : also exhaustiveness and overlapping checking, though they're apparently working on it
10:13:22 <c_wraith> suppi: they also are rather rigid to work with (intentionally).  It takes some practice to feel like you're gaining more than the extra overhead of working with them.
10:13:48 <ski> HaskellNub : hm, need to leave now. good luck
10:13:49 <c_wraith> Yeah, I hear 8.0 should have the improved overlapping/exhaustiveness checker
10:14:01 <HaskellNub> yes, I think I can get the hang of it 
10:14:09 <suppi> I also heard about pattern matching for GADTs
10:14:09 <HaskellNub> thanks for the help
10:14:45 <suppi> c_wraith, can you perhaps provide an example?
10:16:12 <Copperis> Gurkenglas, thanks. I never saw composition used like that and still don't quite understand how it works
10:20:43 <ptcek> Anyone using Oracle DB from haskell?
10:21:16 <clrnd> lol this should prove fun
10:21:53 <c_wraith> suppi: well, for instance, let's say you've got the standard typed expression example, data Expr a where EBool :: Bool -> Expr Bool ; ENum :: Integer -> Expr Integer ; ....  a million more constructors...  And then you want to write a parser.
10:22:21 <sbrg> I would very much like to nuke my whole ghc/cabal install and switch to a 'stack based workflow' so to speak. What is the best way of doing this? I currently have ghc and cabal-install installed via my distro's package manager. Should I remove those, install stack and let it install ghc for me? Or just remove cabal-install, download stack and use stack instead of cabal sandboxes in my projects?
10:22:23 <haskell086> can someone help me figure out this type error 
10:22:27 <c_wraith> suppi: It's easy to write parsers for each particular constructor.  But how do you write a parser that allows you to return any Expr?
10:22:53 <clrnd> sbrg, I'd delete everything and let stack do the work
10:23:04 <clrnd> I myself have a global GHC just in case
10:23:05 <ski> c_wraith : existentials
10:23:09 <haskell086> says "Expected type string, Actual type IO()"
10:23:09 <c_wraith> suppi: It turns out to require types to depend on runtime values...  Which gets painful to work.
10:23:17 <clrnd> haskell086, lpaste.net pls
10:23:33 <sbrg> clrnd: I see.
10:23:36 <c_wraith> suppi: as ski says, you can do it with existentials, but there's a bunch of mental and syntactic overhead
10:24:36 <suppi> c_wraith, I think I understand
10:24:40 <suppi> c_wraith, thanks :)
10:24:43 * hackagebot claferwiki 0.4.2.1 - A wiki-based IDE for literate modeling with Clafer  https://hackage.haskell.org/package/claferwiki-0.4.2.1 (mantkiew)
10:24:45 <haskell086> http://lpaste.net/143469
10:25:01 <haskell086> I think I was asking about this before too, but I forgot to put this question
10:25:40 <haskell086> nearly done with this,but I need it do print strings, not to do show and it works alright in GHCI but not on my module
10:25:55 <haskell086> I assume there's something I need to change on my show action to make that work
10:26:25 <suppi> c_wraith, do you have any tip about knowing when GADTs are appropriate?
10:27:26 <sbrg> srsly.. hakyll's dependency graph is way too huge ;_;
10:28:12 <haskell086> though it was working before, don't know why all of the sudden it doesnt work anymore
10:28:34 <c_wraith> suppi: well, there's a part of me that wants to use them every single time.  :)
10:28:51 <c_wraith> suppi: But then I pull back to "do I actually gain more than I lose here?"
10:29:12 <suppi> c_wraith, they do seem pretty cool :)
10:30:10 <clrnd> haskell086, and what is the full error?
10:30:33 <haskell086> just a second
10:31:17 <haskell086> http://lpaste.net/143469
10:31:25 <haskell086> error's the last annotation in there
10:32:35 <hc> hi all, i'm using the protobuf package and i'd like to continuously decode messages arriving from a tcp connection... what's the best way to do this?
10:32:51 <clrnd> haskell086, that's because `putStr` doesn't go there
10:32:55 <hc> i though about manually reading chunks and feeding them to the Get monad, but that feels kinda too verbose
10:33:01 <clrnd> haskell086, why did you put it there?
10:33:14 <haskell086> I need it there, so that it can print the matrix row by row 
10:33:28 <arkeet> show is supposed to return a String, not an IO action.
10:33:28 <haskell086> otherwise I'm not sure how I'd print it 
10:33:50 <arkeet> :t show
10:33:51 <lambdabot> Show a => a -> String
10:33:57 <arkeet> :t putStr
10:33:59 <lambdabot> String -> IO ()
10:34:02 <haskell086> I know that
10:34:04 <clrnd> haskell086, you are gonna need a main :: IO ()
10:34:35 <clrnd> haskell086, `show` takes a thing makes it a string, `putStr` takes a String and shows it on screen
10:34:55 <haskell086> Is there no way to get it on my module, I mean through some other action or what not?
10:35:59 <haskell086> I'm fine with someone just getting the string and then showing it on the screen, but it'd be easier if the module just took that show and printed it itself
10:36:05 <suppi> haskell086, create a new function, call it printMatrix for example
10:36:31 <suppi> a define it like printMatrix mat = putStr (show mat)
10:36:40 <arkeet> :t print
10:36:42 <lambdabot> Show a => a -> IO ()
10:36:56 <suppi> oh, yeah T_T
10:37:14 <suppi> oh! but print uses putStrLn right? :)
10:37:19 <arkeet> yes
10:37:28 <suppi> so my solution holds. :D
10:37:33 <suppi> I'm sorry, I'm a bit tired.
10:37:56 <clrnd> print = putStrLn . show
10:41:22 <haskell086> small question where exactly would I put this function, outside of my module?
10:42:01 <haskell086> so far it looks like this printMatrix :: Show a => Matrix a -> IO()
10:42:22 <inad922> What does !Int means in comparison to the "normal" Int?
10:43:11 <clrnd> haskell086, why outside?
10:43:31 <haskell086> I don't know, I'm just not sure where to put it
10:43:43 <haskell086> do I just define it like the rest of my functions 
10:44:04 <clrnd> haskell086, in general, if your thing has a Show instance, ppl will realize how to print it
10:44:22 <haskell086> ok, I guess I'm just gonna leave it as it was then
10:44:27 <clrnd> if you really want to, yeah, just add it as a function like the rest
10:44:54 <haskell086> I guess it already does what it needed to do anyway
10:45:04 <clrnd> :)
10:45:43 <haskell086> Anyways thank you for the help, using this language was a difficult endeavor
10:46:24 <clrnd> haskell086, sorry to hear that, what course/book/tutorial are you following?
10:46:43 <haskell086> Well the professor, sucked, not so much the course or the book
10:46:57 <clrnd> oh too bad :/
10:47:02 <haskell086> the books I've seen were pretty helpful
10:47:17 <haskell086> especially the one called learn you a haskell or something
10:47:49 <haskell086> anyway thanks
10:50:43 <aweinstock> inad922: !Int means strictly-evaluated Int, if the BangPatterns extension is enabled
10:51:12 <inad922> aweinstock: And what does strict evaluation mean?
10:52:13 <ski> @let data NotStrict = NS Int
10:52:14 <lambdabot>  Defined.
10:52:21 <ski> @let data Strict = S !Int
10:52:23 <lambdabot> Plugin `eval' failed with: .L.hs: renameFile: does not exist (No such file or directory)
10:52:42 * ski tries one more time
10:52:46 <ski> @let data Strict = S !Int
10:52:47 <lambdabot>  .L.hs:170:1:
10:52:47 <lambdabot>      Multiple declarations of ‘Strict’
10:52:47 <lambdabot>      Declared at: .L.hs:168:1
10:52:55 <f00f00> hi!
10:53:02 <aweinstock> inad922: I'm not an expert in denotational/operational semantics, but basically a list of undefined non-strict ints still has a defined length
10:53:07 <f00f00> I'm getting a parse error I don't quite grasp
10:53:10 <ski> bah!  an
10:53:10 <f00f00> here's the lpaste
10:53:12 <ski> > case NS undefined of NS _ -> "ok"
10:53:15 <lambdabot>  "ok"
10:53:17 <ski> > case S undefined of S _ -> "ok"
10:53:18 <lambdabot>  "*Exception: Prelude.undefined
10:53:19 <f00f00> http://lpaste.net/6134083446177267712
10:53:26 <ski> inad922 ^
10:53:31 <f00f00> why is there an issue with line 17?
10:53:33 <aweinstock> inad922: in non-strict evaluation, only terms that are needed are evaluated
10:54:07 <aweinstock> > (S 5, NS 5)
10:54:08 <inad922> ah I guess I've got the idea
10:54:09 <lambdabot>      No instance for (Show L.Strict)
10:54:09 <lambdabot>        arising from a use of ‘show_M915615104024229497426573’
10:54:09 <lambdabot>      In the expression:
10:54:19 <ski> @let deriving Show Strict
10:54:19 <lambdabot>  Parse failed: Parse error: Show
10:54:27 <f00f00> merge.hs:17:19: parse error on input ‘(’
10:54:28 <ski> @let deriving instance Show Strict
10:54:30 <lambdabot>  .L.hs:150:24:
10:54:30 <lambdabot>      Ambiguous occurrence ‘Strict’
10:54:30 <lambdabot>      It could refer to either ‘L.Strict’, defined at .L.hs:148:1
10:54:38 * ski sighs, gives up
10:54:38 <aweinstock> @let deriving instance Show L.NotStrict
10:54:40 <lambdabot>  Defined.
10:54:48 <aweinstock> @let deriving instance Show L.Strict
10:54:50 <lambdabot>  Defined.
10:54:54 <aweinstock> > (S 5, NS 5)
10:54:55 <lambdabot>  (S 5,NS 5)
10:55:08 <aweinstock> > length [S undefined]
10:55:10 <lambdabot>  1
10:55:17 <aweinstock> > length [NS undefined]
10:55:19 <lambdabot>  1
10:55:24 * ski nods
10:55:54 <aweinstock> > length $ map (\(S x) -> S x+1) [S undefined]
10:55:57 <lambdabot>      No instance for (Num L.Strict) arising from a use of ‘+’
10:55:57 <lambdabot>      In the expression: S x + 1
10:55:57 <lambdabot>      In the first argument of ‘map’, namely ‘(\ (S x) -> S x + 1)’
10:56:05 <aweinstock> > length $ map (\(S x) -> S (x+1)) [S undefined]
10:56:07 <lambdabot>  1
10:56:26 <aweinstock> huh, I'm still missing something...
10:56:46 <ski> > foldl' (flip seq) () [NS undefined]
10:56:47 <ski> > foldl' (flip seq) () [S undefined]
10:56:47 <lambdabot>  ()
10:56:48 <lambdabot>  *Exception: Prelude.undefined
10:59:19 <aweinstock> > NS undefined `seq` ()
10:59:21 <lambdabot>  ()
10:59:28 <aweinstock> > S undefined `seq` ()
10:59:30 <lambdabot>  *Exception: Prelude.undefined
10:59:58 <aweinstock> ski: any reason why foldl' instead of the more direct one involving seq?
11:00:15 <ski> you seemed to want to use a list
11:01:18 <bollu> I'm trying to encode groups into Haskell, and I'm having trouble encoding the cyclic group
11:01:35 <bollu> essentialy, I want a Monoid / Group instance on the cyclic group of order n
11:01:52 <bollu> but the problem is that I can't "list out" all the cyclic groups and set the Group instance separately
11:02:21 <bollu> so, like, how do I write a "generic" group instance for all cyclic groups, so when I ask, for, say, mempty :: Cyclic 10 or something, it gives me the right identity?
11:02:34 <bollu> I don't know how to encode the group order into the type of the group
11:05:38 <bollu> Did the question make sense?
11:05:48 <anks> Hi, did any1 used Put Monad from Data.Binary? Is there away to flatten [Put] into Put ?
11:06:15 <bollu> I basically want to have data Cyclic = Cyclic {order ::n} or something. But I can't write instance Group Cyclic {…}, since the "Group" needs to know the order of Cyclic
11:06:17 <clrnd> :t sequence
11:06:18 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
11:06:19 <glguy> anks: sequence_
11:06:33 <bollu> How I "attach" the integer data the Cyclic group has _at the type level_?
11:08:52 <arkeet> bollu: type level naturals? reflection?
11:09:19 <anks> it worked :P
11:09:19 <bollu> arkeet: is it possible to retrieve the data in the program level once I encode it in the type level?
11:09:26 <arkeet> yes
11:09:26 <bollu> Haskell has reflection? o_O
11:09:33 <bollu> okay, this ought to be cool :D
11:09:34 <bollu> go on
11:09:36 <arkeet> no, reflection as in
11:09:38 <arkeet> @hackage reflection
11:09:38 <lambdabot> http://hackage.haskell.org/package/reflection
11:09:45 <anks> thanks, it wasnt immediately clear to me because i was in Either monad so I needed to lift sequence_
11:09:49 <arkeet> lets you put values into the type level.
11:10:02 <arkeet> but I guess the full power of that isn't necessary.
11:10:48 <bollu> arkeet: where can I read up?
11:12:43 <Cale> bollu: I would recommend against trying to encode the group order at the type level in Haskell. A lot of the recent extensions to Haskell's type system have been in the direction of dependent types, but eventually things get very awkward if you try to actually do dependently typed programming in Haskell.
11:13:07 <bollu> Cale: in that case, what is the "correct" way to construct things like the cyclic group in haskelll?
11:13:48 <bollu> s/construct/encode
11:14:35 <Cale> bollu: Well, what are you going to do with it?
11:15:12 <bollu> Cale: um, hopefully use it for algebraic graph theory, so I'll need "all" group theory stuff
11:15:48 <bollu> at the very least, I want to encode group actions. 
11:16:59 <ski> istr there was some package with cyclic groups, using `reflection' ?
11:17:17 <bollu> Cale: so, like, what's the right approach?
11:17:38 <bollu> Cale: I'll need to know the order of the group if I want to say, enumerate all the elements or construct direct products or whatever, right?
11:17:48 <Cale> You might want to start with representing permutations of positive integers somehow -- perhaps an upper bound integer, and a function Integer -> Integer which implements the bijection, or, well, there are a bunch of other representations.
11:19:13 <bollu> Cale: I can represent _one_ permutation thanks to arkeet I think who helped me come up with a slick implementation, but I don't know how to represent the permutation *group* (since that again needs the order) ?
11:19:14 <Cale> Or if it's really important to represent details about groups, well, computational group theory is complicated, there are lots of representations you might choose from, but you probably want a datatype whose values are themselves groups.
11:20:04 <bollu> Cale: huh, I didn't know that :) I'm doing this in the hopes of learning more computational group theory as well. Any pointers as to what representations would be Haskell-friendly?
11:20:25 <Cale> Oh, no, I was talking about the big permutation group whose elements are all the permutations of the positive integers with finite support (i.e. which send all but finitely many elements of the positive integers to themselves)
11:20:36 <ReinH> Seems like you could pretty easily represent ciclic groups using
11:20:42 <ReinH> @hackage modular-arithmetic
11:20:42 <lambdabot> http://hackage.haskell.org/package/modular-arithmetic
11:20:44 <Cale> Any finite group will embed into that :)
11:20:46 <Cale> (somehow)
11:21:02 <bollu> Cale: Cayley's theorem :)
11:21:33 <ReinH> You can make Integer `Mod` 5 an instance of Group, for instance.
11:21:45 <ReinH> *cyclic
11:21:46 <Cale> Yeah, you can do type level naturals, but as soon as you have to compute anything at the type level using them, things get crazy fast, and you run into frustrating issues where GHC isn't doing enough evaluation during unification or whatever
11:21:59 <ReinH> Cale: no, not for computing at the type level. For computing at the value level.
11:22:08 <bollu> Cale: that seems like a cool idea (use Sn + embedding). I'm unsure as to how to instantiate instance Group (Symmetric n) 
11:22:08 <ReinH> Just for storing the modulus at the type level
11:22:21 <bollu> ReinH: but, well, I need All Integer `Mod` n, right?
11:22:24 <bollu> all*
11:22:26 <Cale> Like, suppose you have two cyclic groups, and you suddenly need the lcm of their orders at the type level
11:22:31 <Cale> Good luck :)
11:22:36 <ReinH> Cale: sure
11:23:06 <bollu> Cale: yes, which is why I was wondering how to solve this problem :P
11:23:20 <bollu> Cale, ReinH: is this "feasible" / "sane" or do I give up on this?
11:23:30 <Cale> bollu: So, another idea is just "don't put that information at the type level"
11:23:41 <bollu> Cale: then how do I abstract out a group?
11:23:44 <romain_> quit
11:23:47 <romain_> exit
11:23:52 <bollu> nahh, I want to see how far I can take this
11:24:13 <Cale> You could have, e.g. a type  Group a  which encodes information about a group whose elements are indexed somehow by values of type a
11:24:32 <ReinH> Cale: not the typeclass?
11:24:36 <bollu> Cale: "indexed by type a" means?
11:24:39 <Cale> So for instance, every cyclic group would be represented as a value of type Group Integer
11:24:53 <ski> /quit
11:24:56 <ski> romain_ ^
11:25:16 <ReinH> Cale: so package up the Group typeclass as a record
11:25:20 <Cale> yeah
11:25:23 <ReinH> Sure
11:25:45 <bollu> Cale: okay, but what about the order of the diferent cyclic groups then?
11:25:46 <bollu> different*
11:25:55 <Cale> So, you'd have  cyclicGroup :: Integer -> Group Integer; cyclicGroup modulus = Group { .. }
11:26:34 <bollu> 	but no Group typeclass?
11:26:35 <serutsubi> I'm trying to implement a function that finds the duccimap according to https://en.wikipedia.org/wiki/Ducci_sequence, however I'm finding it hard to do becuase of the last "edge-case" |a_n - a_1|. Any hints?
11:26:37 <bollu> that's an intruging idea
11:26:44 <bollu> intriguing*
11:27:07 <Cale> and perhaps it might look something like  data Group a = Group { order :: Integer, unit :: a, mult :: a -> a -> a }
11:27:12 <Cale> and maybe some other things
11:27:38 <ski> inverse
11:27:41 <Cale> yes :)
11:27:45 <Cale> certainly at least that :)
11:27:52 <Cale> haha
11:27:57 <bollu> and maybe generate :: [a] ?
11:28:01 <Cale> sure
11:28:21 <bollu> Cale: this will need to be `newtype`d so it remains extensible
11:28:29 <Cale> In fact, you might have lots of Maybe-fields for optional information about groups which might or might not be present
11:28:29 <ski> it's a countable group ?
11:28:44 <Cale> bollu: hm?
11:28:47 <bollu> ski: crap, forgot about the uncountable ones.
11:29:03 <bollu> Cale: like, if I want two groups to be indexed by Integer
11:29:26 <Cale> But yeah, also, my order field implies that we're representing finite groups :P
11:29:30 <bollu> the smarter way would be to, say, newtype Cyclic = Int, instace Group Cyclic {..}
11:29:58 <Cale> bollu: Uhh, no, the group itself is a *value*
11:30:13 <bollu> ohh!
11:30:14 <Cale> bollu: The idea here is that a cyclic group is a group whose elements are indexed by integers
11:30:58 <bollu> okay, so cyclic = Group Int { order=n, unit=0, add g a b = (a + b) `mod` (order g) } ?
11:31:08 <Cale> bollu: So when you go to use the group operations, you provide integers to represent values -- and a given group element might be referred to by more than one Integer
11:31:17 <Cale> yeah
11:31:22 <bollu> I think mult will have to be mult :: Group a -> a -> a -> a
11:31:28 <Cale> actually, let's do the baseline amount of stuff
11:31:30 <bollu> so the mult can use the group information
11:31:30 <bollu> ?
11:31:41 <Cale> data Group a = Group { unit :: a, mult :: a -> a -> a, inv :: a -> a }
11:31:51 <Cale> cyclicGroup :: Integer -> Group Integer
11:32:08 <bollu> ah, right. sorry
11:32:34 <bollu> the cyclicGroup constructor can use the order to create correct mult and inv instances
11:32:43 <bollu> correct?
11:32:46 <Cale> cyclicGroup m = Group { .. } where unit = 0; mult x y = (x + y) `mod` m; inv x = modularInverse x m
11:33:12 <Cale> (that's using RecordWildCards just to make the definitions of functions a little nicer)
11:33:30 <Cale> But yeah, this gives us  mult :: Group a -> a -> a -> a
11:33:36 <Cale> the field extractor
11:33:40 <bollu> oh, I didn't realize you could {..} and then fill the rest in using `let`!
11:33:58 <Cale> yeah, it's handy sometimes
11:34:33 <bollu> Cale: no, it's mult :: a -> a -> a, right? since the "m" that you receive to the cyclicGroup function captures the order, so you don't need the Group instance when calling the "mult" of a particular cyclic group
11:34:47 * hackagebot hyperloglog 0.4.0.3 - An approximate streaming (constant space) unique object counter  https://hackage.haskell.org/package/hyperloglog-0.4.0.3 (EdwardKmett)
11:34:51 <Cale> The *field* has type a -> a -> a
11:35:09 <Cale> but globally, we have a function which is automatically defined by use of the record syntax
11:35:13 <bollu> oh, right, but haskell record functions need the record to work on. Right.
11:35:14 <Cale> which extracts that field
11:35:45 <bollu> hm, anything to be on the lookout when using this approach?
11:36:11 <bollu> pitfalls and stuff?
11:36:14 <Cale> Well, I think it'll get you pretty far. It doesn't enforce as much at the type level, so you can get into trouble.
11:36:55 <bollu> yeah, like if someone decided to ask for inv 5 on a cyclic group of order 3. It should ideally error out
11:36:57 <ReinH> Cale: for groups whose carrier set are a subset of some other group (e.g. Z/6 < Z), do you want some mechanism to, e.g., reduce a term in Z to a term in Z/6?
11:37:02 <Cale> Like, the Integer indices you'll use for your cyclic groups aren't the real group elements, and you can mix and match group structures -- e.g. doing a computation modulo 7 and then modulo 6 or something
11:37:18 <bollu> oh yeah, that's another one
11:37:26 <ReinH> or do you just take elements of the group as the equivalence classes?
11:37:44 <ReinH> so 1 and 7 are the same element of Z/6
11:37:49 <bollu> I think you could define data ModuloInt { val :: Int, order :: Int}, and then define cyclicGroup :: Int -> Group (ModuloInt)
11:37:56 <mldfmlg> Is there a way using stack or cabal to easily add the latest version of a package as a dependency for a project?
11:38:01 <Cale> ReinH: You might at least want an equivalence test
11:38:20 <Cale> So, perhaps we put that into the Group structure
11:38:28 <mldfmlg> for example using npm i can do 'npm install --save someDep' and someDep will be installed and saved in the dependency list
11:38:30 <ReinH> right
11:38:31 <bollu> ReinH: that *is* nicer I guess. I'm not sure which one would be more accident free
11:38:36 <Cale> data Group a = Group { ... , equiv :: a -> a -> Bool }
11:38:55 <Cale> for determining when two indices refer to the same group element
11:39:19 <Cale> normalisation is stronger than that, but it might be *very* tricky to implement for many groups
11:39:20 <ReinH> right
11:39:24 * ski . o O ( "word problem" )
11:39:32 <Cale> In particular the word problem is not computable :)
11:39:39 <ReinH> right
11:39:39 <bollu> does the ModuloInt idea make sense, to make sure that you don't mix cyclic group elements of different order?
11:39:46 <bollu> Cale: what's "normalisation" in this context?
11:39:50 <mldfmlg> which package should I use as AWS SDK? 'amazonka' or 'aws' ?
11:40:01 <ReinH> mldfmlg: both work, you might prefer the former
11:40:18 <ReinH> mldfmlg: we did a bunch of stuff with aws before amazonka existed, but I'd probably use amazonka if I had to do it again
11:40:18 <mldfmlg> ReinH: why the former?
11:40:27 <mldfmlg> ah okay
11:40:31 <mldfmlg> ill use that then, thanks
11:40:32 <ReinH> I think it's easier to use
11:40:35 <ReinH> And it's more complete
11:40:42 <mldfmlg> okay cool
11:40:51 <ReinH> we had to write some parts of the aws API ourselves
11:40:55 <Cale> bollu: Your Group a might come with an operation normalise :: a -> a acting on indices such that x and y :: a refer to the same group element if and only if  normalise x == normalise y
11:40:56 <ReinH> but amazonka is very complete
11:41:18 <mldfmlg> are project dependencies added to the .cabal file by hand most of the time? Is there no easy command way?
11:41:31 <Cale> bollu: This is a tricky sort of thing to work out in general, if you get on to representing finitely presented groups or something
11:41:31 <ReinH> mldfmlg: emacs will do it for you
11:41:50 <mldfmlg> I use vim L(
11:41:59 <ReinH> mldfmlg: then I dunno :/
11:42:01 <bollu> Cale: ah, so reduce equivalent things to the same description? 
11:42:06 <Cale> bollu: right
11:42:08 <ReinH> I didn't find anything for vim last I checked
11:42:17 <ReinH> mldfmlg: as an aside, you should switch to spacemacs :)
11:42:23 <Cale> bollu: for cyclicGroup, this is just mod
11:42:25 <bollu> huh, well, pretty much constructing  equivalence classes and picking a representative element from each
11:42:27 <mldfmlg> ReinH: why spacemacs?
11:42:34 <Cale> bollu: but for something like a finitely presented group, it's hard
11:42:39 <ReinH> mldfmlg: because it's a better vim than vim, and because you can use all the emacs goodies.
11:42:56 <mldfmlg> okay ill try it
11:43:08 <Cale> bollu: in fact, it's hard even just to determine whether some word in the free group is sent to the identity element modulo the relations
11:43:11 <mldfmlg> ReinH: does it support all of the vim stuff and commands?
11:43:17 <ReinH> mldfmlg: I used vim for over a decade and it was very easy to switch to spacemacs
11:43:25 <Cale> (and by hard, I mean it's not computable in general, only in special cases)
11:43:28 <ReinH> Yes, the vim interface is very well supported
11:43:35 <mldfmlg> okay ill try it out, thanks
11:43:46 <ReinH> mldfmlg: and it's pretty easy to get haskell set up as well
11:43:48 <bollu> Cale: I've never done computational group theory, and you seem to know a lot. Is there a book I can pick this stuff up from?
11:44:07 <bollu> Cale: not computable in the NP complete sense of the halting problem sense?
11:44:11 <bollu> or*
11:44:30 <Cale> bollu: Honestly, I don't know a whole lot -- I've just used GAP a bunch and its documentation makes it obvious how complicated this stuff gets
11:44:53 <Cale> But also, my friend took a combinatorial group theory course, and I followed along a bit :P
11:45:16 <Cale> halting problem sense
11:45:29 <bollu> aww :( 
11:45:39 <bollu> Well, this should be a fun / challenging exercise then
11:45:40 <Cale> Yeah, group theory is hard :(
11:45:46 <bollu> but beautiful!
11:46:14 <Cale> https://en.wikipedia.org/wiki/Word_problem_for_groups#Examples
11:46:26 <bollu> thanks for the technique :) I'll go back to the drawing board and come back with more questions
11:46:47 <Cale> They give an explicit example there of a finitely presented group whose word problem is unsolvable
11:47:24 <bollu> I suppose detecting if a word is unsolvable is equivalent to asking for an oracle?
11:48:22 <mldfmlg> ReinH: is spacemacs an emacs plugin?
11:48:43 <ReinH> mldfmlg: it's really more a complete overhaul of emacs including its own configuration system
11:48:53 <bollu> " https://en.wikipedia.org/wiki/Free_monoid_with_involution" = ?
11:48:57 <ReinH> mldfmlg: https://github.com/syl20bnr/spacemacs
11:48:57 <Cale> bollu: Asking whether a word represents the identity element of the group is asking for an oracle.
11:49:02 <mldfmlg> ReinH: trying to figure out how to install.. do I need emacs first?
11:49:14 <Cale> bollu: for these difficult groups
11:49:16 <ReinH> mldfmlg: are you on mac?
11:49:22 <mldfmlg> ReinH: no, linux
11:49:28 <ReinH> mldfmlg: Read the readme https://github.com/syl20bnr/spacemacs
11:49:29 <bollu> Free monoid approximately equivalent to [a], now what's involution?
11:49:38 <bollu> Cale: ah :/
11:51:13 <ReinH> bollu: did you read the wiki page? It is defined.
11:51:45 <bollu> oh, I missed it. thanks!
11:57:05 <mldfhkdjf> ReinH: I can't do :q to exit spacemacs :S
11:57:47 <bollu> mldfhkdjf: you should be able to! I think it'll ask you about running processes sometimes, say "y" 
11:59:01 <alexv19> Why there is no foldl1M and foldr1M?
11:59:16 <mldfhkdjf> well... I can't
11:59:48 * hackagebot wai-thrift 0.0.1.0 - Thrift transport layer for Wai  https://hackage.haskell.org/package/wai-thrift-0.0.1.0 (yogeshsajanikar)
12:00:10 <mldfhkdjf> When I do it I get a new window/frame with : 'Debugger entered--Lisp error: (void-variable q)'
12:00:50 <mldfhkdjf> well
12:00:54 <mldfhkdjf> actually it works sometimes
12:01:03 <mldfhkdjf> like 30% of the time it randomly works
12:01:07 <mldfhkdjf> tried like 20 times
12:01:57 <mldfhkdjf> sometimes it lets me type the q command, other times it gives me an 'Eval:' prompt 
12:02:08 <mldfhkdjf> if i type q there, it gives me the above error
12:03:11 <ski> mldfhkdjf : perhaps `C-g' would get you out of that prompt ?
12:03:23 <mldfhkdjf> it also does some strange initialization stuff or something on start which takes a few seconds
12:03:28 <mldfhkdjf> ski: I know how to get out of it
12:03:45 <mldfhkdjf> the problem is that it doesn work most of the time when I do :q
12:03:50 <ski> and `C-]' to get out of the debugger, i suspect
12:04:41 <mldfhkdjf> ski: I start emacs, move the cursor around a bit with arrow key, then do <ESC> : q and like 70% of the time it tries to eval it as an emacs command
12:05:07 * hackagebot wai-thrift 0.0.1.1 - Thrift transport layer for Wai  https://hackage.haskell.org/package/wai-thrift-0.0.1.1 (yogeshsajanikar)
12:05:07 <arkeet> does it depend on how fast you type : after <ESC>?
12:05:51 <mldfhkdjf> arkeet: no, it doesnt seem too
12:06:09 <ski> `M-:' opens an emacs lisp prompt
12:07:04 <ReinH> mldfhkdjf: yes you can, I just did it
12:07:28 <mldfhkdjf> ReinH: well it doesnt work for me most of the time
12:07:35 <ReinH> mldfhkdjf: It works every time in normal mode.
12:07:46 <ReinH> If you're in the middle of some other operation, it won't work
12:08:13 <ptcek> mldfhkdjf: I've been trying for a year to not do <ESC>:q etc, it won't go away that quick :)
12:09:02 <mldfhkdjf> It also doesnt listen to other vim commands such as i, v, p, d once in this mode
12:09:48 <ReinH> What mode?
12:09:59 <ReinH> What did you do?
12:10:19 <mldfhkdjf> Once this :q fails
12:10:24 <mldfhkdjf> none of the vim commands work
12:11:11 <ReinH> Try ESC and ctrl-g until you get back to normal mode. You must have done something pretty strange.
12:11:21 <blbirrd> Hello all
12:11:47 <mldfhkdjf> Nope, ReinH - I start emacs then do <ESC> : q
12:11:48 <dolio> This isn't a spacemacs help channel.
12:11:59 <mldfhkdjf> ReinH: thats all I do
12:12:21 <ReinH> mldfhkdjf: Well yes, <ESC> : q is not : q
12:12:37 <mldfhkdjf> ReinH: it is in vim
12:12:55 <mldfhkdjf> and it does work in spacemacs a few times
12:13:00 <ReinH> ESC : is meta-:
12:13:24 <ReinH> vim doesn't have anything bound to meta-: by default, but it could.
12:14:15 <mldfhkdjf> What does it do on start? It seems to connect to some remote servers and do some processing stuff... sometimes takes up to 10 seconds
12:14:21 <dolio> This still isn't a spacemacs help channel.
12:14:49 <ReinH> mldfhkdjf: #haskell-blah
12:23:17 <ajb> > [x*2 | x <- [1..5], x*2 > 4]
12:23:19 <lambdabot>  [6,8,10]
12:23:26 <sleblanc> How can I "unbind" a variable in GHCi ?
12:23:50 <shachaf> Can't be done.
12:24:14 <dolio> Does :r unbind variables?
12:24:48 <dolio> It does.
12:24:56 <sleblanc> dolio, as much as "Alt-F4" "unbinds" all the tabs in your browser
12:24:56 <dolio> All your variables.
12:25:50 <dolio> :r is much faster than that, though. :)
12:25:54 <JonReed> Is it possible to use a where clause in a lambda? This small example fails http://lpaste.net/143482
12:26:26 <dolio> JonReed: where clauses are attached to declarations, and lambdas are expressions, not declarations.
12:27:00 <Gurkenglas> JonReed, try let clauses
12:27:53 <dolio> Oh, you could use lambda-case, though.
12:27:57 <dolio> I expect.
12:28:09 <dolio> \case x -> ... where ...
12:29:21 <dolio> Because you can have a `where` that scopes over each branch.
12:32:55 <JonReed> Ok thx, dolio, Gurkenglas.
12:50:49 * hackagebot propellor 2.9.0 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-2.9.0 (JoeyHess)
12:56:46 <mniip> what was the name for the Monoid m => ((->) m) comonad again?
12:57:23 <mniip> oh right, traced
12:58:24 <blbirrd> Hello, I'm beginning. Is that    doubleMe x = x + x   is a good function declaration?
12:58:37 <mniip> what about the (e,) comonad then?
12:58:41 <mniip> blbirrd, it is
12:58:56 <blbirrd> if so, why WinGHCi saying <interactive>:22:12: parse error on input ‘=’
12:59:29 <MarcelineVQ> because in ghci you use let to make statements: let doubleMe x = x+x
12:59:43 <blbirrd> oh
12:59:50 <blbirrd> not with others?
12:59:51 <MarcelineVQ> in your code files the way you've written it is fine
12:59:56 <m_ryan> hi can i ask a question? what is the library use to create html format in haskell?
13:00:00 <blbirrd> I'm not using code files, only console
13:00:17 <mniip> blbirrd, ghci pretends to be a do block
13:00:17 <blbirrd> so there is a difference between code file and console it seems? :)
13:00:25 <c_wraith> m_ryan: there are about 10 of them, depending on how you want to do it
13:00:29 <mniip> so if you want to define a function you need to use 'let' just like you would in a do block
13:00:41 <blbirrd> thank you mniip
13:00:47 <MarcelineVQ> blbirrd: A few little differences
13:01:50 <c_wraith> blbirrd: ghci was mostly designed to interact with code from files.  That's what it is optimized for, so why it's a bit harder to not use source files.
13:01:50 <m_ryan> c_wraith: i want to use it on my project for sending an email.
13:02:46 <c_wraith> m_ryan: oh, I meant there are options like string-substitution templating, semantic templating, tag combinators...  It depends on how you want to approach it in the code.
13:02:55 <mniip> blbirrd, you would write your function to a file, and then load it in ghci like 'ghci file.hs'
13:04:54 <c_wraith> m_ryan: and those categories can be divided up, too.  the semantic templating libraries include things like hamlet, which is similar in design to haml, and things like heist, which is similar in design to (as much as I hate to say it) JSP in that it uses xml-based substitution
13:05:58 * hackagebot fasta 0.10.0.0 - A simple, mindless parser for fasta files.  https://hackage.haskell.org/package/fasta-0.10.0.0 (GregorySchwartz)
13:06:20 <m_ryan> c_wraith: hamlet was use in yesod right? how about in native haskell?
13:06:23 <blbirrd> ok, how to load .hs file with directories with winghci?
13:06:27 <c_wraith> m_ryan: really, there are a million ways to generate html.  How do you imagine writing code to do it?
13:07:03 <c_wraith> m_ryan: hamlet was built for yesod, yes.  What do you mean by "native haskell" in this case?
13:07:35 <m_ryan> c_wraith: i mean in pure haskell.
13:07:47 <c_wraith> are you looking for something like blaze-html?
13:09:03 <thimoteus> so f :: a -> ... b is called a type signature, but what about the line f = ... ? what's that called?
13:09:11 <c_wraith> thimoteus: a definition
13:09:17 <thimoteus> excellent
13:09:26 <thimoteus> that's what i went with but wasn't sure
13:10:18 <c_wraith> thimoteus: sometimes they're also called "bindings", because they bind a name to a value.  But "definition" is probably the most common term.
13:11:15 <m_ryan> c_wraith: what does blaze-html do?
13:11:56 <c_wraith> m_ryan: blaze-html gives you haskell functions for every html tag.  You create a big tree of function calls to represent the dom tree of the page, then render the whole thing.
13:12:56 <c_wraith> m_ryan: alternative, there are things like hastache, which implement well-known templating systems and are commonly used to generate html pages where you just need to substitute in a few values
13:13:03 <c_wraith> *alternatively
13:13:28 <m_ryan> c_wraith: i see thank you for the response.
13:14:49 <blbirrd> Why   let b = [[1,2,3,4,[4,3]]]   is not working?
13:15:20 <aweinstock> blbirrd: lists are homogenous in Haskell
13:15:31 <blbirrd> ok
13:15:34 <aweinstock> blbirrd: all the elements have to be the same type
13:16:00 <aweinstock> and 1, 2, 3, and 4 are all numbers, but [4,3] isn't a number
13:16:30 <aweinstock> blbirrd: what are you trying to represent?
13:16:56 <blbirrd> Nothing sorry, just following a tutorial :p thank for your answer, understood
13:17:19 <sbrg> If I'm not mistaken, `stack exec project_binary` isn't the same as `cabal run` in that `cabal run` will rebuild if necessary. Is there anything in stack that does the same?
13:19:57 <MarcelineVQ> sbrg: `stack build --exec project_binary`
13:20:12 <sbrg> MarcelineVQ: aah, great.
13:23:33 <TheCrafter> I have trouble understanding how FFI works. I have a test.c file with a "void test(int a){ printf("asd%d", a)}" in it. Now I wanna use that in my haskell code. I (hopefully) can do that with ghc alone. I compile the C file first, then the haskell file and the I link with ghc. But how do I do it with cabal?
13:24:06 <TheCrafter> How can I let cabal know that I have my own set of "c" source files and headers that should be compiled and linked with my haskell code?
13:25:19 <arkeet> TheCrafter: there's a c-sources field in cabal
13:25:46 <arkeet> https://www.haskell.org/cabal/users-guide/developing-packages.html#build-information
13:25:48 <c_wraith> arkeet: doesn't that only tell it to make sure those files are included in the sdist?
13:26:01 <arkeet> does it?
13:26:10 <c_wraith> I really don't know for sure.
13:26:22 <arkeet> c-sources: filename list
13:26:23 <arkeet> A list of C source files to be compiled and linked with the Haskell files.
13:26:30 <c_wraith> Maybe it does tell cabal to compile them and make them available during linking
13:26:34 <c_wraith> .... like that quote says
13:27:11 <TheCrafter> hmm okay I'll go try it know! thanks
13:27:24 <arkeet> I haven't used it myself though so I can't say for sure.
13:35:18 <lukky513> is there a good, well-documented application of Cloud Haskell?
13:35:44 <lukky513> so I could see a 'real-life' usage of it?
13:36:00 * hackagebot purescript 0.7.5 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.7.5 (PhilFreeman)
13:37:56 <quchen> lukky513: Alpeh Cloud (disbanded startup) made some cloud service. I think they might be a good lead
13:38:01 <quchen> ReinH: ping? ^
13:41:46 <lukky513> quchen, do you know any particular project name? all I see on their github are repositories that look more like dependencies
13:41:49 <ReinH> quchen: pong?
13:41:55 <ReinH> quchen: We didn't use cloud haskell.
13:42:02 <quchen> Oh.
13:42:30 * Guest39726
13:42:33 <quchen> ReinH: Well, I don't know anything about cloud stuff, so I thought you'd be a good start
13:42:48 <ReinH> quchen: Well, I don't know much about Cloud Haskell, other than it doesn't seem like anyone is using it.
13:43:05 <lukky513> I'll let myself explain, as maybe Cloud Haskell is not what I'm looking for
13:43:44 <ReinH> "Allow me to introduce... myself."
13:44:03 <lukky513> I saw some criticism against Scala actors, saying that Haskell has grown nice abstractions for networking and distributed operations as such
13:44:32 <jophish> https://www.youtube.com/watch?v=67E42LQsU24
13:44:42 <lukky513> and I wanted to know which ones are those, and met Cloud Haskell through some obscure search
13:44:54 <lukky513> ReinH, "allowduce to introllow myself"
13:46:08 <TheCrafter> I have a question about FFI. I defined a function in my C code with this signature: int test(int x). Inside this function I use printf. I noticed that on my haskell code I can import that function as "test :: CInt -> CInt" instaed of "test :: CInt -> IO CInt" . That way I'm able to perform IO operations without the IO monad. What's up with that?
13:47:04 <TheCrafter> I mean, it makes sense, haskell has no way of knowing what's going on inside my C code but is that a feature or a "blind spot". Should I use it to my advantage or pretend I don't know it just to stay safe?
13:47:16 <hpc> treat it as you would unsafePerformIO
13:47:24 <hpc> because that's pretty much what it is
13:47:58 <jophish> TheCrafter: The ffi is unsafe for so many other reasons, it's down the the programmer to make sure it's all valid
13:48:30 <TheCrafter> @ hpc : Yeah I guess you're right.
13:48:51 <TheCrafter> @ jophish : Like what reasons?
13:49:54 <jophish> TheCrafter: It could also be used as a kind of unsafeCoerce for example
13:50:23 <Shersh> Hello, everyone! I have a question about list append. I understand haskell lazyness and all pitfalls in using foldl or foldr. But I don't understand why a ++ (b ++ c) is better than (a ++ b) ++ c. I tried to write all pattern matching on the paper for both cases and still don't understand. Any explanations or link to some blogpost/article?
13:50:43 <arkeet> the difference is in performance
13:50:49 <jophish> Shersh: in order to append c to (a++b) both a and b must be traversed
13:50:54 <arkeet> count how many pattern matches/constructions are required to produce each one
13:51:02 <jophish> but in order to append (b++c) to a, only a has to be traversed
13:51:37 <hpc> or to put it another way
13:51:54 <hpc> in ((((l ++ l) ++ l) ++ l) ...
13:52:08 <hpc> to evalute the head of the list, you need to drill down into every single (++) in the chain
13:52:24 <Shersh> Well, when i have some function f with pattern mathching (x:xs) and I pass to it ([1, 2] ++ [3, 4]) ++ [5, 6], how it determines, that x is 1 and xs is still bad case ([2] ++ [3, 4]) ++ [5, 6] ?
13:52:26 <arkeet> fully evaluating a ++ b requires pattern matching about (length a) times
13:53:17 <arkeet> so to make (a ++ b) ++ c 
13:53:23 <arkeet> you first have to make a ++ b
13:53:51 <TheCrafter> jophish: Okay got it! Thanks!
13:54:00 <jophish> stay safe
13:54:07 <arkeet> so the total cost is like 2*length a + length b
13:54:45 <deech> Anyone know how to configure stack to build a dependency from the local hard drive?
13:54:48 <Shersh> But why after first traversals list append is not reversed, so I can get [2] ++ ([3, 4] ++ [5, 6]) ?
13:55:12 <jophish> deech: I usually make it a subdirectory of the project I'm building
13:55:23 <jophish> stack init will pick it up atomically 
13:55:31 <jophish> automatically*
13:56:36 <deech> jophish: So there's no field where I can just point it to some source directory on my machine?
13:57:07 <jophish> deech: I've never come across one, but you're probably best asking in #haskell-stack
13:57:28 <MarcelineVQ> can't you just add the folder in extra-deps in stack.yaml ?
13:57:32 <jophish> deech: I suspect there isn't one though, as it would run against stack performing reproducable builds
13:57:39 <kaol> Shersh: If you take tail $ ([1,2] ++ [3,4]) ++ [5,6] you get [2,3,4,<thunk>]. With [1,2] ++ ([3,4] ++ [5,6]), you have [2,<thunk>].
13:57:57 <jophish> MarcelineVQ: that works outside the current tree?
13:57:58 <bitemyapp> deech: you want to add another project as a package or dependency via a filepath?
13:58:09 <deech> yep.
13:58:25 <Shersh> I understand how to make it bad :) But I don't understand what the problems with make it good? Maybe some explanations in terms of WHNF, or some other terms. 
13:58:29 <bitemyapp> deech: how often do the deps recompile?
13:58:38 <bitemyapp> deech: (this changes whether you want extra-dep: true or not)
13:58:41 <Shersh> kaol: could you clarify why i get such behaviour?
13:59:25 <bitemyapp> deech: be advisable to put them in a single atomic git repo so the build "just works" WRT filepaths.
13:59:28 <bitemyapp> I'll write up an example.
13:59:52 <bitemyapp> deech: http://lpaste.net/5158847367125925888
14:00:14 <deech> I made some changes to library A locally and built with stack, I have an application B that uses A that I want to build with stack. I don't I want them in the same repo. 
14:00:19 <bitemyapp> "Whether a package should be treated as a dependency: a package marked extra-dep: true will only be built if demanded by a non-dependency, and its test suites and benchmarks will not be run. This is useful for tweaking upstream packages.
14:00:28 <nomeata> joeyh: Is there a bugtracker for git-annex?
14:00:29 <kaol> Shersh: Look at ++'s definition and think of what it needs to do to it's first argument. https://www.haskell.org/tutorial/functions.html
14:00:41 <bitemyapp> deech: and you don't want to reference it as a separate git repo?
14:00:48 <benzrf> why does this fail:
14:00:50 <benzrf> > foldr (liftA2 (:)) (ZipList [[]]) (repeat (ZipList [1]))
14:00:52 <lambdabot>  ZipList {getZipList = *Exception: stack overflow
14:00:54 <jophish> deech: not having them in the same repo means that for someone else to use the code they can't just download the parent repo
14:00:57 <bitemyapp> deech: in that case, do as I showed you. Decide for yourself if extra-dep makes sense or not.
14:01:07 <jophish> deech: you could use a submodule perhaps
14:01:12 <bitemyapp> jophish: if deech doesn't want to, no point troubling them about it.
14:01:26 <jophish> bitemyapp: sure, I just want to make sure :)
14:01:28 <deech> jophish, bitemyapp: Thanks!
14:01:43 <bitemyapp> deech: http://lpaste.net/4418687690136879104 here's an example using a git repo instead of a file-path.
14:01:47 <deech> Trying to migrate from Cabal to Stack. Slow going ...
14:01:54 <bitemyapp> deech: these are taken more or less directly from my company's monorepo.
14:02:01 <bitemyapp> deech: most of this is covered in Stack's documentation btw.
14:02:16 <bitemyapp> deech: you'll save time if you have a cuppa and poke through: https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md#extra-deps
14:02:53 <deech> bitemyapp: And I suppose the `git:` field can be a local git repo too. Cool! I think that's what I need.
14:02:57 <bitemyapp> deech: also since the creator of Yesod has been directing the development of Stack, fpco projects are converted over so examples abound: https://github.com/yesodweb/yesod/blob/master/stack.yaml
14:03:08 <bitemyapp> deech: good good :)
14:03:21 <bitemyapp> deech: good way to get our attention more readily is #haskell-stack.
14:03:29 <bitemyapp> deech: tho the people present in the channel don't know everything.
14:04:09 <ski> > foldr (zipWith (:)) [[]] (repeat [1])
14:04:11 <lambdabot>  *Exception: stack overflow
14:04:43 <nomeata> joeyh: sorry, I mean propellor
14:04:58 <Shersh> kaol: I looked at this definition. If `f` has patter (x:xs) and I pass a ([1, 2] ++ [3, 4]) ++ [5, 6]) to it, so I get next pattern chain: f l = f (l' ++ [5, 6]) = f ((l'' ++ [3, 4]) ++ [5, 6]) = f (([1, 2] ++ [3, 4]) ++ [5, 6])  = ... And what's next? How to get x = [1] and xs = ([2] ++ [3, 4]) ++ [5, 6]. If it is so then such append is bad. But how I achieve such behaviour?
14:05:11 <ski> > fix $ \xs -> zipWith (:) (repeat [1]) xs
14:05:15 <lambdabot>  mueval-core: Time limit exceeded
14:05:23 <arkeet> Shersh: you have to evaluate enough to get it in the form x:xs
14:06:18 <ski> > fix $ \xs -> zipWith (:) [1] xs  -- rather
14:06:22 <lambdabot>  mueval-core: Time limit exceeded
14:06:23 <Shersh> But ([1, 2] ++ [3, 4]) ++ [5, 6] is not the same as 1 : ([2] ++ [3, 4]) ++ [5, 6]. What's the magic transformation happens here?
14:06:25 <arkeet> e.g. [1,2] ++ [3,4] = (1 : 2 : []) ++ [3,4] --> 1 : (2 : [] ++ [3,4])
14:07:01 <ski> benzrf : ok, so `zipWith' is waiting to see whether its last argument is empty or not
14:07:02 <arkeet> ([1,2] ++ [3,4]) ++ [5,6] = ((1 : 2 : []) ++ [3,4]) ++ [5,6] --> (1 : (2 : [] ++ [3,4])) ++ [5,6] --> 1 : ((2 : [] ++ [3,4]) ++ [5,6])
14:07:16 <arkeet> recall (x : xs) ++ ys = x : (xs ++ ys)
14:07:18 <arkeet> by definition
14:07:32 <arkeet> --> is one step of evaluation
14:08:09 <Shersh> arkeet: Thanks a lot! Now I get it!
14:08:45 <benzrf> ski: ah
14:08:53 <benzrf> ...why??
14:09:24 <benzrf> oh, hold on
14:09:40 <benzrf> > liftA2 (+) (ZipList [1, 2, 3]) (ZipList [1, 2])
14:09:41 <lambdabot>  ZipList {getZipList = [2,4]}
14:09:45 <benzrf> alright, that makes sense
14:10:01 <benzrf> ohhhh right, it's forced by parametricity
14:10:05 <benzrf> lame
14:10:59 <ski> benzrf : if it was a `newtype' of infinite streams, then i think it would work
14:14:13 <benzrf> or if it were sized vecs
14:15:25 <ski> yes, obviously (since you couldn't use `repeat' then)
14:24:42 <benzrf> thats not really relevant
14:24:54 <benzrf> the repeat is not generating ziplists, it's generating a regular list that im folding over
14:25:15 <benzrf> all ziplists in question are finite
14:27:04 <hodapp> https://github.com/commercialhaskell/haskelldocumentation/blob/master/content/covariance-contravariance.md - in the 2nd exercise in the "Bivariant and invariant" section, what does the question about ToFrom not being a Profunctior or Bifunctor even mean, when ToFrom has only one type parameter?
14:27:12 <hodapp> or is that the reason why it's impossible
14:30:14 <meretrix> Does java-bridge or a similar JNI interface still exist?
14:36:03 * hackagebot yesod-transloadit 0.4.2.0 - Transloadit support for Yesod  https://hackage.haskell.org/package/yesod-transloadit-0.4.2.0 (boblong)
14:41:03 * hackagebot yesod-transloadit 0.4.3.0 - Transloadit support for Yesod  https://hackage.haskell.org/package/yesod-transloadit-0.4.3.0 (boblong)
14:46:03 * hackagebot shelduck 0.1.4.0 - Test webhooks locally  https://hackage.haskell.org/package/shelduck-0.1.4.0 (boblong)
14:51:56 <tommd> Any opinions on strengthening unidirectional pattern synonyms to include guards?  `pattern Foo x <- Just x | x > 4`
14:54:57 <kaol> Reminds me of monad comprehensions.
14:56:04 * hackagebot Slides 0.1.0.0 - Generate slides from Haskell code  https://hackage.haskell.org/package/Slides-0.1.0.0 (darwin226)
14:58:07 * ski stares transfixed at blinking text
14:58:12 <ski> (ECHAN)
15:05:09 <tippenein_> Is there something I'm missing with setting up stack test runners on travis? I'm using cloudhaskell as an example : https://github.com/haskell-distributed/cloud-haskell/blob/master/.travis.yml
15:07:12 <Darwin226> Hey guys! I need help. I have a custom library in a folder. It's all sandboxed and builds fine and everything. I have another project in another folder that has a dependency on my library added with add-sources.
15:07:18 <Darwin226> it builds, but can't link
15:07:27 <Darwin226> I get "undefined reference" errors, a lot of them.
15:07:58 <mniip> is there a module for unfolding tuples
15:08:08 <mniip> er
15:08:12 <Darwin226> here's the exact output http://lpaste.net/143515
15:08:14 <mniip> a package for unfolding tuples
15:08:46 <mniip> er
15:08:48 <mniip> disregard that
15:09:13 <mniip> is there a package that exports a type family to unflatten tuples into recursive structures
15:09:48 <mniip> (a, b, c) -> f a (f b (f c z))
15:11:32 <tippenein_> https://www.haskell.org/hoogle/?hoogle=%28a%2C+b%2C+c%29+-%3E+f+a+%28f+b+%28f+c+z%29%29
15:11:34 <mniip> wait what
15:11:39 <tippenein_> mniip: looks like no
15:11:48 <mniip> typelevel tuples aren't limited to 62?
15:11:58 <jle`> i didn't think hoogle indexed type families too
15:11:59 <mniip> tippenein_, that's not what I asked for at all
15:12:07 <jle`> isn't it just searching for a function on values there?
15:12:29 <tippenein_> oh, I literally just pasted your type example
15:12:34 <mniip> that's not a type
15:12:42 <tippenein_> yeah, I see now
15:12:46 <tippenein_> sorry
15:12:47 <mniip> and hoogle only indexes base package
15:12:50 <mniip> s
15:13:12 <jle`> what is "base packages"?
15:14:18 <mniip> jle`, I think ones coming with ghc or something
15:15:57 <jle`> i think regular hoogle indexes packages that don't come with ghc, fwiw
15:16:12 <jle`> https://www.haskell.org/hoogle/?hoogle=Free
15:16:19 <jle`> seems to catch the `free` package there
15:17:21 <mniip> jle`, it also searches hackage
15:17:32 <Gurkenglas> Why does Control.Monad.Zip require Monad?
15:17:39 <mniip> however it doesn't search the contents
15:17:40 <mniip> only names
15:17:59 <jle`> omg
15:18:24 <jle`> hm, does text come with ghc?
15:18:41 <jle`> if it does, how come i always have to re-install it when i start a new cabal sandbox v.v
15:19:26 <Gurkenglas> (Wouldn't Functor suffice?)
15:22:00 <tippenein_> has anyone here successfully gotten travis running with stack?
15:26:09 <sm> tippenein_: yes
15:26:23 <sm> the hledger or pandoc projects, eg
15:27:42 <tippenein_> I took hledger's .travis.yml directly and it failed on travis
15:27:54 <tippenein_> Maybe I have to do some other setup than the .travis?
15:27:55 <hexagoxel> jle`: no. you should be able to determine yourself by looking at ghc-pkg output.
15:28:46 <sm> tippenein: you could paste/link the failure
15:29:29 <tippenein_> It doesn't really say anythin in travis - https://travis-ci.org/tippenein/BankHoliday
15:30:04 <sm> "failed to parse field 'resolver': Invalid resolver value: ghc-7.10.1"
15:30:30 <tippenein_> where are you seeing that error?
15:30:31 <sm> your project's stack.yaml should probably specify lts-3.10 or something like that
15:30:42 <mniip> any idea why can't I emerge transformers? https://bpaste.net/show/e23811b5c439
15:30:44 <sm> line 111 on that page
15:31:28 <sm> the ghc-* resolvers are very minimal and not really intended for normal users AFAIK. 
15:31:30 <tippenein_> oh, my browser must be messed up because I only see a loading spinner >___<
15:31:44 <hexagoxel> Gurkenglas: looks like a pre-AMP artefact to me. Might be worth pointing out on mailing list or smth.
15:32:19 <tippenein_> thank you though sm
15:32:46 <sm> tippenein: np. pandoc's config shows how to test multiple ghc versions
15:33:08 <tippenein_> I've been reading through hledger a bit, and I appreciate that too. iirc you are the main contributor?
15:33:34 <sm> tippenein: yes, I'm the project lead. Glad you're liking it
15:34:44 <joehillen> does anyone have a technique for finding "Prelude.!!: index too large"? !! isn't anywhere in my code
15:35:27 <ReinH> > let listToMaybe = foldr (\x _ -> Just x) Nothing in listToMaybe [1..]
15:35:29 <lambdabot>  Just 1
15:35:38 <sm> joehillen: recompile with profiling enabled and then run with +RTS -xc, I think
15:35:47 <ReinH> woops
15:36:05 * hackagebot streaming 0.1.2.0 - an elementary streaming prelude and a general monad transformer for streaming applications.  https://hackage.haskell.org/package/streaming-0.1.2.0 (MichaelThompson)
15:37:19 <sm> joehillen: though, sometimes it's quicker to just stub out code and reload in ghci until it stops, and search the source 
15:38:06 <joehillen> unfortunately, this part can't be stubbed
15:38:22 <joehillen> too much interaction with the outside world
15:39:47 <hexagoxel> joehillen: also -rtsopts when compiling
15:39:59 <sm> you can also insert a bunch of trace statements to narrow it down
15:43:47 <sm> will it be much easier in ghc 8 ? fingers crossed!
15:46:07 * hackagebot Slides 0.1.0.1 - Generate slides from Haskell code  https://hackage.haskell.org/package/Slides-0.1.0.1 (darwin226)
15:46:20 <tippenein_> heh, 12 minute build so far on travis
15:46:43 <sm> I saw.. quicker next time :)
15:46:54 <joehillen> sm: here's hoping our runtime errors will someday be just as good as dynamic languages
15:47:03 <sm> once your stack snapshot is cached
15:47:13 <Gurkenglas> Do mailing list posts take one matter each or do I just put all the things Ive accumulated into one?
15:47:56 <sm> Gurkenglas: use your judgement, but focussed threads are usually more productive
15:48:20 <sm> depends how big are the things :)
15:51:07 * hackagebot streaming-bytestring 0.1.2.0 - effectful byte steams, or: bytestring io done right.  https://hackage.haskell.org/package/streaming-bytestring-0.1.2.0 (MichaelThompson)
15:59:01 <njskdfl> Can a field of a data type be called 'type' ?
15:59:22 <njskdfl> > data Wub = Wub { type :: String }
15:59:23 <lambdabot>  <hint>:1:1: parse error on input ‘data’
15:59:46 <c_wraith> @let data Wub = Wub { type :: String }
15:59:46 <lambdabot>  Parse failed: Parse error: type
15:59:50 <c_wraith> Nope!
15:59:58 <njskdfl> dang
16:00:17 <njskdfl> Is there some workaround maybe?
16:00:34 <c_wraith> Name the field something else.  Type is a reserved lexical token
16:00:45 <c_wraith> err, type is.  without the capitalization
16:00:56 <njskdfl> I need it to be type in the serialized JSON form
16:01:15 <njskdfl> I know I can create a custom serialization for it
16:01:35 <njskdfl> seems like something that would be a common issue though
16:01:52 <c_wraith> aeson?  I think I saw something about it having some tricks to autogenerate things with fields renamed
16:02:23 <njskdfl> Idk about autogenerate, but you can define a custom toJSON instance
16:02:31 <njskdfl> It's just ugly :p
16:03:00 <c_wraith> njskdfl: yeah, deriveJSON takes arguments that let you alter the field -> key mapping
16:03:18 <njskdfl> yeah
16:04:10 <c_wraith> you could set the fieldLabelModifier to rename just a key named something like type' to type in the serialized data
16:04:22 <njskdfl> yeah I know
16:04:31 <c_wraith> So...  You already know the answer to the question you asked?
16:04:46 <njskdfl> Well, this is more of a workaround
16:04:57 <njskdfl> Wanted to see if there is a nicer way
16:05:08 <c_wraith> The only other way is writing the instance from scratch.
16:05:46 <njskdfl> i thought maybe there would be some special character you could use so that 'type' is not interpreted as a keyword
16:05:57 <njskdfl> like %type% or something
16:06:46 <c_wraith> Haskell is not a magic-oriented language. :)
16:07:38 <dmj> c_wraith: some may claim otherwise
16:07:48 <hpc> no, i can confirm
16:07:58 <hpc> i summoned the greatest sorcerers in all the land to explain burritos for me
16:10:01 <MarcelineVQ> It's like a taco but it doesn't fall apart if you eat it with one hand
16:10:36 <mgsloan> Hmm, yes, like a taco but more principled, less leaky
16:11:07 <hpc> and a yummy soft exterior instead of the rigid shell
16:11:13 <c_wraith> dmj: I can explain haskell.  I can't explain ruby.  One of these languages has more magic than the other. :)
16:11:22 <hpc> this metaphor is making me hungry, good thing i had a burrito for lunch today
16:11:57 <dmj> c_wraith: ruby lacks burritos
16:12:46 <njskdfl> is there a way to run the executable that was built with 'stack build' ?
16:13:01 <mgsloan> stack exec my-exe-name
16:13:22 <njskdfl> ah ok thanks
16:13:40 <dmj> c_wraith: whenever I read ruby code all I see is 'end end end end end.. etc'
16:13:46 <mgsloan> Alternatively, "$(stack --local-install-root)/my-exe-name" :)
16:13:57 <mgsloan> err
16:14:05 <c_wraith> dmj: the darker part of me thinks it is the programmer begging for it all to be over.
16:14:07 <mgsloan> $(stack path --local-install-root)/my-exe-name
16:14:10 <mgsloan> I mean
16:14:16 <njskdfl> your first command worked mgsloan 
16:14:27 <njskdfl> btw, is there a way to add a dependency to the project using stack?
16:14:29 <dmj> c_wraith: a foreshadowing of what is to come
16:15:08 <mgsloan> njskdfl: https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md#extra-deps
16:15:32 <njskdfl> mgsloan: I mean add a dependency to the .cabal file
16:15:44 <mgsloan> Oh, no, editing cabal files is not within the scope of stack
16:16:02 <njskdfl> mgsloan: but it does generate the files when you do stack new
16:16:08 * hackagebot fltkhs 0.3.0.1 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.3.0.1 (deech)
16:16:12 <njskdfl> is there a way to do it using cabal?
16:16:40 <njskdfl> I thought stack was aiming to replace cabal anyway?
16:17:09 <mgsloan> It isn't, just cabal-install.  Unfortunately there is naming confusion between cabal-the-library (Cabal package) and cabal-the-binary (cabal-install)
16:17:37 <njskdfl> ohh
16:17:59 <njskdfl> So, is there away to manage project dependencies via command line?
16:18:02 <MarcelineVQ> If the package is in the stackage repo you don't need to user cabal-install, 
16:18:05 <njskdfl> without editing files and looking up versions?
16:18:08 <mgsloan> "stack new" just instantiates cabal files via templates, AFAIK it doesn't do anything special with adding dependencies
16:18:11 <MarcelineVQ> You add them to your build deps sections in your projects .cabal file, and stack build
16:18:35 <njskdfl> MarcelineVQ: the problem is you have to look up the versions and manually edit files
16:18:39 <njskdfl> kinda annoying
16:18:50 <mgsloan> njskdfl: Well, most common dependencies are in stackage.  So you only need to choose specific versions if it's outside of stackage
16:18:52 <njskdfl> 99% of the time you just want the latest stable version
16:18:52 <MarcelineVQ> Only if they're not in stackage
16:19:07 <MarcelineVQ> If they're in stacage you just use the basic name in your cabal file
16:19:08 <mgsloan> If it's not in stackage, then the build errors will tell you the latest stable version
16:19:16 <njskdfl> ohh
16:19:17 <njskdfl> okay
16:19:23 <njskdfl> so I dont need version at all then
16:19:24 <mgsloan> and you can copy the extra-deps lines it gives you straight into your stack.yaml
16:19:36 <njskdfl> ah
16:19:39 <njskdfl> okay makes sense
16:21:10 <njskdfl> Anyone tried this? https://github.com/begriffs/haskell-vim-now
16:21:56 <njskdfl> It seems promising but also kinda heavy
16:22:51 <MarcelineVQ> ghc-mod is pretty great, any editor with language highlighting and ghc-mod for haskell is a good time
16:25:04 <njskdfl> ^ that thing includes ghc-mod, but it also has some 3rd-party dependencies and it installs like 200 cabal packages
16:26:04 <MarcelineVQ> ghc-mod is a big girl, it does a fairly involved job
16:29:01 <njskdfl> How do I get all (or one?) paths from where stack installed executables?
16:29:50 <mgsloan> stack path --local-install-root
16:30:32 <njskdfl> mgsloan: that doesn't seem to be correct
16:31:18 <njskdfl> for example ghc-mod got installed to .stack/snapshots/x86_64-linux/nightly-2015-10-20/7.10.2/bin/ghc-mod
16:31:40 <njskdfl> and that command gives me .stack/global-project/.stack-work/install/x86_64-linux/lts-3.10/7.10.2
16:31:43 <mgsloan> That's where they go after "stack build".  stack install also puts them there, and then copies to "stack path --bin-path"
16:31:57 <mgsloan> Did you run that command from within the ghc-mod repo?
16:32:07 <mgsloan> It can't know where the files went unless it knows which stack.yaml to use
16:32:24 <mpickering> this is a very basic stack question but I want to build lens from the github repo. I tried "stack build" and it seemed to pick out an ancient package set and tried to use ghc-7.8.4 when I have 7.10.3 on my path
16:32:31 <njskdfl> mgsloan: okay I see the path its in when doing 'stack path --bin-path'
16:33:50 <mgsloan> mpickering: It's probably using your global config, stored in ~/.stack/global/stack.yaml
16:34:21 <mgsloan> I'd probably just do "stack init" to initialize a stack.yaml file
16:34:47 <mpickering> ok now it suggest stack init
16:35:06 <mgsloan> Alternatively, manually create a stack.yaml file, with something like "resolver: lts-3.10" in it
16:35:26 <mpickering> there is no snapshot found that matched the package bounds in your .cabal fie
16:36:07 <mgsloan> Odd, I'm surprised the development version of lens would have troublesome version constraints 
16:36:32 <mgsloan> Try "resolver: lts-3.10", and it'll tell you what the problematic constraints are
16:36:45 <mgsloan> I think "stack init"'s output also tells youthis
16:37:19 <njskdfl> oh mgsloan actually 'stack path --bin-path' does not give me the path I'm looking for :(
16:37:58 <mgsloan> Yeah, you want "stack path --localf-install-root", but run stack in the same dir / a subdir of the project with the stack.yaml
16:38:19 <njskdfl> mgsloan: this is not from a project with a stack.yaml
16:38:35 <njskdfl> mgsloan: this ghc-mod was installed by some script to work as an executable
16:38:55 <njskdfl> I think the aim was to be like 'cabal install ghc-mod'
16:39:00 <mpickering> I think the problem is that stack finds cabal files recursively 
16:39:21 <mpickering> but how do I tell it which one to use?
16:39:25 <mgsloan> mpickering: Yeah, you can suppress that behavior with --ignore-subdirs
16:41:49 <mgsloan> njskdfl: Your two paths have different snapshots.  The one it got installed to is using nightly-2015-10-20, whereas stack path is using lts-3.10.  This means your different invocations of stack are getting a different configuration
16:42:17 <njskdfl> mgsloan: hmm, so what do I do?
16:42:28 <mgsloan> Perhaps the script installed ghc-mod with a particular resolver?  Like "--resolver nightly-2015-10-20" ?
16:42:49 <mgsloan> You need to run stack path with the same configuration as stack build got run
16:43:04 <mgsloan> Anyway, you should probably just use stack install and use the binaries out of ~/.local/bin
16:43:13 <mgsloan> --local-install-root is only for development purposes
16:43:29 <mpickering> now it seems that "reflection 2.1" isn't in stackage nightly but reflection 2.0 is
16:43:34 <mpickering> is there a way to find out why?
16:44:41 <njskdfl> mgsloan: yes, using the --resolver parameter worked
16:44:42 <njskdfl> thanks
16:44:48 <mgsloan> mpickering: https://github.com/fpco/stackage/search?q=reflection&type=Issues&utf8=%E2%9C%93
16:44:51 <mgsloan> cool!
16:45:33 <mgsloan> mpickering: Looks like lens is restricting the reflection version
16:48:52 <glguy> len-4.13 supports the new lens, but stackage doesn't have lens-4.13
16:48:58 <glguy> supports the new reflection*
16:50:00 <mgsloan> mpickering: The solution to circumstances like this is to put "extra-deps: [reflection-2.1]" in your stack.yaml
17:11:36 <sm> mgsloan: what does that do ?
17:12:49 <mgsloan> It overrides the version of reflection specified by the stackage snapshot
17:13:18 <sm> doesn't it do that without the brackets ?
17:13:32 <mgsloan> It does, I just didn't want to use the multiline syntax in IRC
17:13:43 <sm> ohh
17:13:51 <sm> all is clearish
17:14:57 <njskdfl> Is it just me or does ghc-mod 5.4.0 (installed with stack) detect a lot less errors than the one installed with cabal
17:15:06 <njskdfl> does it need some sort of configuration?
17:18:01 <ReinH> njskdfl: how does ghc-mod detect errors?
17:18:22 <njskdfl> ReinH: I have no idea... using ghc?
17:19:04 <njskdfl> But, it seems to not detect a lot of stuff in my current project.. like obvious type errors
17:21:28 <mjhoy> why isn't f in `f undefined = 0` strict?
17:22:03 <arkeet> hm? undefined is a variable there.
17:22:10 <arkeet> (unrelated to the existing "undefined :: a")
17:22:19 <mjhoy> arkeet: oh, right
17:23:48 <mjhoy> is seq semantically like `seq (bottom) x = x` ?
17:24:38 <njskdfl> ghc-mod 5.4.0 (vim+syntastic) doesnt detect any issues with this code: http://lpaste.net/143526
17:24:48 <arkeet> "The value of seq a b is bottom if a is bottom, and otherwise equal to b."
17:25:00 <arkeet> from the docs.
17:25:44 <delrik> you have to fully evaluate a before you can get to b.
17:25:53 <delrik> hence, if you fall into bottom, that’s where you’ll stay.
17:25:56 <arkeet> no, seq doesn't imply anything about evaluation order.
17:26:11 <delrik> right.
17:26:12 * hackagebot pathwalk 0.3.0.0 - Path walking utilities for Haskell programs  https://hackage.haskell.org/package/pathwalk-0.3.0.0 (chadaustin)
17:26:30 <delrik> it says “if a is bottom”
17:26:32 <Gurkenglas> And it is evaluated to WHNF, not normal form as one might think when reading "fully evaluated"
17:26:35 <delrik> doesn’t that imply a?
17:26:49 <delrik> yes
17:26:50 <MarcelineVQ> njskdfl: did you check out  https://github.com/begriffs/haskell-vim-now/wiki/Installation-Troubleshooting ?
17:26:50 <delrik> sorry
17:26:53 <delrik> WHNF
17:26:53 <koshmar> if I want apply "f" to "m x" I do: "f <$> (m x)" how do I applay  "f" to "m1 m2 x"?
17:27:01 <Gurkenglas> All it says is that evaluating b to WHNF is not done until evaluating a to WHNF is done
17:27:07 <arkeet> well, evaluating seq a b necessarily evaluates a. (and also b, if a isn't bottom)
17:27:16 <arkeet> but b may be evaluated before a
17:27:21 <mjhoy> arkeet: what can i think of the definition looking like, though?
17:27:33 <njskdfl> MarcelineVQ: I removed that plugin and now trying with just ghc-mod + syntastic
17:27:35 <arkeet> seq _|_ b = _|_
17:27:38 <arkeet> seq a b = b
17:27:47 <mjhoy> arkeet: ok, thanks.
17:30:41 <ski> `a' may even be evaluated after `seq a b' has returned
17:31:29 <Gurkenglas> By returned, you don't mean evaluated, right?
17:31:51 <ski> (assuming the compiler is sure (or makes sure) `a' will be evaluated eventually, so that the whole computation bottoms out when `a' does)
17:33:20 <glguy> Gurkenglas: in seq a b, b can be evaluated to WHNF before a is
17:33:46 <Gurkenglas> glguy, but seq a b can't.
17:38:29 <SGORLA> hi
17:39:09 <njskdfl> hmm syntastic + vim does not seem to be able to find the ghc-mod checker, even though it is installed and in PATH
17:40:07 <delrik> make sure cabal is in your path.  so it finds your stackage bins.
17:40:35 <njskdfl> cabal is in path too (though I installed ghc-mod using stack)
17:40:49 <njskdfl> and I can use ghc-mod fine from command line or even from vim by doing system(ghc-mod)
17:44:21 <njskdfl> very strange :s
17:44:56 <njskdfl> omg
17:45:21 <njskdfl> there is a line in the vimscript for syntastic ghc-mod that specifically excludes version 5.4 -_-
17:45:43 <njskdfl> without so much as an error message
17:46:13 <njskdfl> https://github.com/scrooloose/syntastic/blob/master/syntax_checkers/haskell/ghc-mod.vim line 59 -_-
17:50:54 <aupiff> is there a way to read a file as its being written in Haskell?
17:51:05 <aupiff> or in general? 
17:51:27 <arkeet> do you want a pipe instead?
17:51:33 <arkeet> what are you trying to do
17:53:03 <njskdfl> ok guys, so syntastic doesn support ghc-mod anymore, use ghcmod-vim plugin
17:54:11 <naudiz> there really seem to be people who use C for functional programming.
17:54:47 <e2kp> MarcelineVQ: The installation instructions of this plugin are horrible you should never `bash <(curl http://)`
17:55:51 <njskdfl> e2kp: a lot of packages actually use that method lol, such as docker-compose
17:56:29 <e2kp> eww hopefully they at least use https :P
17:56:42 <njskdfl> the thing about that plugin though.. is that it uses syntastic + ghc-mod 5.4
17:56:54 <njskdfl> and syntastic does not support ghc-mod 5.4
17:57:06 <njskdfl> as I just found out after wasting an hour
17:57:29 <njskdfl> and it installs  A LOT of other packages
17:57:40 <mgsloan> Maybe open an issue / PR / add a proper error message?  This way your hour won't be wasted
17:57:48 <njskdfl> it took me over an hour for that 'bash < curl ...' command to complete
17:58:45 <njskdfl> mgsloan: yeah maybe ill do that.. im a lazy fuck though
18:00:20 <mgsloan> Can be as simple as opening an issue and linking to the line for the ghc-mod-5.4 check you found
18:00:47 <mgsloan> The plugin author might not realize things are broken, and more people's time will be wasted
18:01:51 <njskdfl> yeah
18:02:06 <mgsloan> While I'm certainly not always the best at this myself, I figure if I use opensource software and ask people for help about it, it's my duty to contribute back where I can
18:03:18 <njskdfl> ok mom jeez
18:03:26 <njskdfl> :)
18:11:14 * hackagebot pathwalk 0.3.1.0 - Path walking utilities for Haskell programs  https://hackage.haskell.org/package/pathwalk-0.3.1.0 (chadaustin)
18:13:54 <truber8> The string "http://a.example/\u0073" is in unicode form. It represents "http://a.example/s" . How do I use the text library to get the 2nd from the 1st?
18:15:01 <ski> > "http://a.example/\x0073"
18:15:02 <lambdabot>  "http://a.example/s"
18:15:49 <truber8> ski: but what about for \u rather than \x 
18:15:50 <truber8> ?
18:16:03 <ski> > "http://a.example/\u0073"
18:16:05 <lambdabot>  <hint>:1:20:
18:16:05 <lambdabot>      lexical error in string/character literal at character 'u'
18:16:18 <ski> > "http://a.example/\\u0073"  -- perhaps you meant this
18:16:20 <lambdabot>  "http://a.example/\\u0073"
18:19:57 <ttt_fff> https://gist.github.com/06f0b80693284a4bf6ba <-- is there a way to define  amacro which expands this out?
18:20:01 <ttt_fff> i feel it's rather repetitious
18:34:26 <truber8> ski: how do I go from "http://a.example/\\u0073" to "http://a.example/s" using the text library ?
18:35:07 <ski> i'm not sure
18:36:05 <ski> converting to a `String' inbetween probably works
18:36:14 <ski> perhaps there's a more direct way
18:41:15 * hackagebot propellor 2.10.0 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-2.10.0 (JoeyHess)
18:41:34 <Eduard_Munteanu> truber8, it's rather straightforward to implement \-escaping with attoparsec, though
18:41:56 <eacameron> Does anyone have experience or material describing in what scenarios it is safe/ideal to use randomized testing (a la quickcheck) and when one should instead look for deterministic, explicit test cases?
18:42:21 <truber8> Eduard_Munteanu: interesting, thanks. Pointers to an example for converting instances of "\u" to "\x" ?
18:43:07 <truber8> To avoid this: Data.Text.pack "\u0073"  <interactive>:2:18:     lexical error in string/character literal at character 'u'
18:43:31 <truber8> Is is shown here: http://www.fileformat.info/info/unicode/char/0073/index.htm ... 
18:43:43 <truber8> \u0073 is unicode for lower case s 
18:43:49 <Eduard_Munteanu> > T.pack "\\u0073"
18:43:51 <lambdabot>      Not in scope: ‘T.pack’
18:43:51 <lambdabot>      Perhaps you meant ‘BS.pack’ (imported from Data.ByteString)
18:43:58 <Eduard_Munteanu> > pack "\\u0073"
18:43:59 <lambdabot>      Not in scope: ‘pack’
18:43:59 <lambdabot>      Perhaps you meant one of these:
18:43:59 <lambdabot>        ‘BS.pack’ (imported from Data.ByteString),
18:44:06 <Eduard_Munteanu> > Data.Text.pack "\\u0073"
18:44:08 <lambdabot>  Not in scope: ‘Data.Text.pack’
18:44:25 <Eduard_Munteanu> > fromString "\\u0073" :: Text
18:44:27 <lambdabot>  Not in scope: type constructor or class ‘Text’
18:44:32 <dmj> eacameron: I'd say if it's pure, you should use quickcheck. 
18:44:56 <Eduard_Munteanu> truber8, are you compiling string literals containing \u?
18:45:24 <dmj> eacameron: pure == unit test, I/O == integration test
18:45:24 <Eduard_Munteanu> truber8, because if your input simply contains \u ("\\u"), that won't help
18:45:46 <Eduard_Munteanu> > "\x0073"
18:45:48 <lambdabot>  "s"
18:45:56 <Eduard_Munteanu> > "\\x0073"
18:45:57 <lambdabot>  "\\x0073"
18:46:05 <eacameron> dmj: Interesting. Are there well known weaknesses of quickcheck style testing where it fails to find existing bugs?
18:46:46 <kadoban> eacameron: Why choose? Do both. Any specifically problematic instances, throw a test case in. If you can't think of any (or any more), throw quickcheck at it.
18:47:09 <truber8> Eduard_Munteanu: I'm consuming a unicode file which contains \u0073 . Data.Text.IO.readFile is fine consuming this to \\u0073 , but I just cannot work out how to switch this to the `s` character.
18:47:47 <truber8> \x0073 is fine, as you can see it converts to `s`, but not \u0073 :-/
18:48:01 <eacameron> kadoban: That's a good point. I'm just curious of any pitfalls to fear when using non-deterministic testing. Sure, non-deterministic testing is better than deterministically zero testing, but it seems that some bugs would fall through.
18:48:20 <dmj> eacameron: maybe if your sample size is too smal
18:48:46 <dmj> eacameron: all types that have encode / decode patterns I test for isomorphisms. QuickCheck is a good candidate for this
18:49:00 <dmj> s/smal/small
18:49:31 <eacameron> Any experience with smallcheck?
18:50:44 <dmj> eacameron: not me, but it looks promising
18:52:42 <eacameron> Thanks. This is good food for thought.
18:53:00 <Eduard_Munteanu> truber8, to be clear, does the input contain the 6-character string \u0073?
18:53:41 <truber8> Yes, the input file does contain the 6-character string \u0073.
18:54:21 <truber8> I want to consume the file and translate the 6-character sequence \u0073 to `s`.
18:55:15 <truber8> So that when I write to a file, the 1-character `s` sequence is written to the output file rather than \u0073 6-character sequence.
18:59:08 <truber8> Eduard_Munteanu: got it... `let new_text = Data.Text.replace (Data.Text.pack "\\u0073") (Data.Text.pack "\x0073") input_text`
18:59:19 <truber8> Thanks for the help :-)
18:59:35 <Eduard_Munteanu> truber8, that might fail if other sequences are involved, though
19:02:00 <Eduard_Munteanu> truber8, for instance, "\\u0073" will translate to "\s", when it might be more appropriate to get "\u0073".
19:02:22 <Eduard_Munteanu> (the \ being escaped itself)
19:02:28 <truber8> I see.
19:02:31 <cdk> @pl \ m n f -> m >>= \a -> n >>= \b -> f a b
19:02:31 <lambdabot> (. ((.) . (>>=))) . (.) . (>>=)
19:04:04 <cnr> cdk: that looks like liftA2/liftM2 with a different argument order
19:04:07 <cnr> :t liftA2
19:04:08 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
19:06:01 <cdk> cnr: it is \f m -> join . liftM2 f m
19:08:06 <Eduard_Munteanu> truber8, I'm thinking something like    T.concat <$> many (takeWhile (/= '\') <|> (string "\u" >> ...))
19:42:36 <OutlawStar> is it possible to define a type class as "class Eq a => Foo a where ..." and then define a default implementation for "==" ?
19:43:44 <Cale> OutlawStar: Not without changing Eq
19:44:12 <Cale> OutlawStar: The class declaration of Eq gets to specify a default implementation
19:44:34 <OutlawStar> Cale: ahh, so I can't redefine it with type class "Foo"?
19:45:16 <OutlawStar> I guess I would have to do "instance Eq (Foo a) where ..." ?
19:45:44 <eacameron> OutlawStar: Right, but that won't set the default implementation. That will set *the* implementation.
19:46:17 <OutlawStar> eacameron: I would be fine with that, i wasn't planing on redefining it.
19:46:18 * hackagebot dixi 0.5.0.0 - A wiki implemented with a firm theoretical foundation.  https://hackage.haskell.org/package/dixi-0.5.0.0 (LiamOConnorDavis)
19:46:25 <OutlawStar> or letting others
19:46:39 <Cale> OutlawStar: Wait, what? instance Eq (Foo a) has Foo being a completely different sort of thing
19:46:45 <Cale> A type, rather than a class.
19:47:07 <OutlawStar> Cale:, no. But I was hoping I could get away with it?
19:47:10 <OutlawStar> i gues not..?
19:47:58 <eacameron> OutlawStar: Oh, you want a new typeclass which defines (==)+
19:47:59 <eacameron> ?
19:49:09 <OutlawStar> My goal is that I want to have three types say "A, B, C" with exactly the same data structor, but the content in their structure being different. I mainly want the 3 types to be explicit about contracts for usage
19:49:31 <OutlawStar> So i was currently implementing 3 records and having them be an instance of Foo
19:49:46 <OutlawStar> and only exposing Foo
19:50:07 <OutlawStar> I don't like it, and I would definitly be up for a different way
19:50:52 <eacameron> OutlawStar: Did you try Foo = A | B | C? And then instance Eq Foo where ...?
19:52:04 <OutlawStar> eacameron: my only caveat with that is that if A down the line adds something (by accident) that B and C dont' have. Compiler want detect it, and you will get run time error
19:52:12 <OutlawStar> wont detect it*
19:52:58 <eacameron> Are A, B, and C different views of the same data?
19:54:25 <OutlawStar> I gues the best way to explain this is that, I have A, B, C which are an instance of Foo. A, B and C all have fields Val1 and Val2 and type class Foo also defines these fields
19:54:41 <OutlawStar> I then would like the options of having function definitions that can use Foo in most cases
19:54:53 <OutlawStar> but also use the explicity types A, B, and C when appropriate
19:55:41 <OutlawStar> I can come up with a few lengthy (boiler plate ways of doing it), but I was looking for a clean way
19:58:34 <Axman6> kamatsu: dixi looks quite interesting, do you have a demo up anywhere?
19:59:51 <kamatsu> No, because i have no administrator control
20:00:00 <kamatsu> so i don't want it spammed to all hell
20:00:31 <kamatsu> mostly I'm making this for internal use where such features aren't required as much
20:01:29 <nshepperd> OutlawStar: wait, do A, B and C have the same fields or different fields?
20:01:43 <OutlawStar> nshepperd: same
20:02:20 <OutlawStar> i'd prefer not using data X = A | B | C, as well because that means function def can be doY :: X -> y
20:02:31 <nshepperd> ah, right
20:02:36 <OutlawStar> when really I want doY :: A -> y, doY :: B -> y
20:02:59 <nshepperd> one way you can do that is with a phantom type parameter
20:03:07 <OutlawStar> yeah thats what i was thinking
20:03:33 <nshepperd> so instead of 'data Foo = Foo Val1 Val2', having 'data Foo x = Foo Val1 Val2'
20:03:55 <OutlawStar> and then have x be like, newtype A = A?
20:03:58 <OutlawStar> i thnk that might work
20:04:06 <nshepperd> and then you can having 'doY :: Foo A -> Y'
20:04:22 <nshepperd> yeah
20:04:35 <OutlawStar> yeah, i'll give that a shot, thx
20:05:29 <nshepperd> Or if you're willing to use extensions (DataKinds, KindSignatures), you can do 'data X = A | B | C; data Foo (x :: X) = Foo Val1 Val2'
20:05:32 <OutlawStar> hmm newtype B = B, needs value
20:05:52 <nshepperd> and then the phantom parameter is restricted to being one of those three options
20:06:10 <OutlawStar> oh, i've never used that before, but it sounds interesting
20:06:23 <nshepperd> OutlawStar: oh yeah, newtype won't work, you want 'data B = B' there. or even 'data B' (with no constructor)
20:06:37 <OutlawStar> ah yes
20:07:05 <OutlawStar> thx alot, i'll look up the kind sig stuff
20:07:08 <OutlawStar> that looks cool
20:09:14 <nshepperd> I would take some time to learn about DataKinds stuff, since it's a bit of a nontrivial extension
20:09:41 <nshepperd> X there is being promoted to a kind, and A, B, C are being promoted to types of that kind
20:09:56 <nshepperd> which is how they can be used as a type parameter like that
20:10:25 <OutlawStar> starting here: http://dev.stephendiehl.com/hask/#data-kinds
20:10:26 <dmj> data kinds also gives you type literals
20:12:59 <tabemann> I have an interthread communication question
20:19:00 <pavonia> tabemann: Feel free to ask
20:21:36 <tabemann> how can I do something like dupTChan... except I want to see things that were put in the original TChan *before* the point of duping
20:26:19 * hackagebot sbv 5.3 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  https://hackage.haskell.org/package/sbv-5.3 (LeventErkok)
20:27:58 <glguy_> Tabemann: you dup it ahead of time
20:30:00 <tabemann> glguy_: the thing is that I want to be able to do that an unlimited number of times - but I can't do that, because I cannot construct an infinite list of TChans
20:30:44 <glguy_> Have you tried only giving out dups of the original, never reading from the original?
20:31:09 <tabemann> that's what I've been doing in other places in my code
20:32:07 <tabemann> but from testing it, as expected, even if you never read from the original TChan, with dupTChan you can only see things written after the duping
20:36:46 <Axman6> kamatsu: (sorry for the late reply) right, makes sense. IIRC Servant isn't the best when it comes to things like access control/authentication; at least I haven't seen a nice way to do it
20:41:24 <kamatsu> Yeah, there isn't much support for that yet
20:53:57 <ReinH> tabemann: what are you doing?
20:54:04 <ReinH> This sounds like an xy problem
20:54:23 <ReinH> Axman6: It's definitely possible
20:54:51 <ReinH> Let me find how we're doing it
20:56:21 <ReinH> Axman6: looks like official support is a WIP but you can find some ideas here https://github.com/haskell-servant/servant/issues/70
20:57:09 <tabemann> I am doing a system where I am passing events between threads
20:57:44 <tabemann> the problem is that a thread will be created and receiving events from upstream before anyone can see the thread exists and thus dupChan its output event TChan
20:58:47 <kamatsu> when will travis support ghc 7.10?
20:58:53 <kamatsu> i want sudo:false but 7.10
20:58:57 <tabemann> in all other cases in the code threads that are handling events from elsewhere are being explicitly created, and the creator has a chance to dupTChan the output before it receives anything
20:59:18 <tabemann> but in this case the thread is being created automatically, so no one will see it until it registers itself
20:59:35 <tabemann> but it receives the event for which it was created immediately
21:02:04 <tabemann> I could avoid this problem by not using dupTChan and just providing the TChan directly... but that would completely break the pattern found in the rest of the code, and also have the disadvantage that something can only be received once... unlike when I've been using dupTChan (quite heavily) which allows things to be received multiple times
21:03:11 <Axman6> ReinH: thanks for the link =)
21:05:13 <pavonia> tabemann: Can't you pass the TChan around and dup it before each read?
21:07:02 <tabemann> what I've been doing is, to get the response to something, I dup the TChan, do whatever will cause a response, read the TChan, and handle the response
21:08:03 <tabemann> the issue here is that the event I will be trying to capture will happen before I have a chance to dup the TChan
21:09:46 <pavonia> But if you know the original TChan, you will also know the event at the time your read it in your threads, no?
21:10:42 <tabemann> the thing is I don't want to read from the original TChan
21:11:09 <glguy_> Kamatsu: it has supported it for a while now. I typically use hvr's script to confirm travis
21:11:09 <tabemann> because I want to be able to read the same event more than once
21:11:47 <kamatsu> hvr's script doesn't support sudo:false
21:12:12 <kamatsu> I'm hoping to use travis' built-in infrastructure
21:13:02 <pavonia> tabemann: Do your threads "wake up" only if there's an event in the duplicate chan?
21:14:30 <tabemann> yes
21:14:31 <pavonia> Or do you poll the chan in some intervals?
21:15:01 <tabemann> I'm not polling, just blocking on readTChan
21:15:24 <codebje_> @pl \(p,_) -> p /= 1 && p /= 2
21:15:24 <lambdabot> liftM2 (&&) (1 /=) (2 /=) . fst
21:16:23 * hackagebot hjsonschema 0.7.1.0 - JSON Schema library  https://hackage.haskell.org/package/hjsonschema-0.7.1.0 (seagreen)
21:16:40 <tabemann> okay, I need to get to bed
21:36:59 <kamatsu> well, i hacked around the problem. I have a script in travis now that just detects if it's running ghc 7.4, and if so just downloads some 7.10 binaries and installs them locally into a cached directory
21:37:26 <kamatsu> a bit better than hvr's solution because i don't need to use sudo:required
21:37:43 <kallisti> does bytestring support GHCJS?
21:38:04 <kallisti> I think you could make a nice JS implementation of bytestrings using TypedArray for example
21:38:28 <c_wraith> that's odd phrasing.  It makes me want to respond "bytestring doesn't really compile many projects at all"
21:39:26 <c_wraith> The standard version of bytestring certainly can't work in GHCJS, but it should be possible to put together something api-compatible
21:40:39 <mgsloan> Actually, the patch to the standard version of bytestring is minimal: https://github.com/ghcjs/ghcjs-boot/blob/master/patches/bytestring.patch
21:41:06 <mgsloan> Here are the JS implementations of bytestring's C functions: https://github.com/ghcjs/shims/blob/master/pkg/bytestring.js
21:41:49 <mgsloan> Not sure if it uses typed arrays or standard arrays
21:44:11 <mgsloan> This is why people are so pumped about GHCJS :)
21:44:25 <mgsloan> Tons much of hackage builds with it
21:44:30 <mgsloan> lol
21:46:47 <mgsloan> The new ghcjs-base also has some nice bindings to TypedArrays
21:53:43 <nuttycom> Since there are ghcjs-knowlegeable folks about, how would you compare ghcjs to purescript? 
21:54:23 <bitemyapp> nuttycom: ghcjs is Haskell
21:54:36 <bitemyapp> nuttycom: purescript has some objectionable design decisions. You can't share datatypes with a Haskell backend.
21:54:38 <nuttycom> I have a haskell webapp that I'm starting to toy with putting a purescript front-end on, but I'd consider ghcjs as well.
21:54:43 <bitemyapp> nuttycom: ghcjs has forkIO (this is the real tiebreaker for me)
21:55:03 <nuttycom> bitemyapp: well, purescript has Aff, which gives you forkIO-like behavior.
21:55:33 <nuttycom> what do you consider the objectionable design decisions?
21:57:26 <kallisti> hm, why is this a parse error, even with TypeFamilies extension disabled?  type Test family = family
21:57:30 <kallisti> @let type Test family = family
21:57:30 <lambdabot>  Parse failed: Parse error: family
21:57:38 <kallisti> is this a ghc bug?
21:59:27 <ReinH> family is probably a reserved word
21:59:46 <nuttycom> @let type Test a = a
21:59:48 <lambdabot>  Defined.
22:00:07 <kallisti> I mean I can understand why it wouldn't work with TypeFamilies enabled, but that should parse as valid Haskell 2010 no?
22:00:29 <kallisti> @let family = 2  -- it's not really a reserved word because this is perfectly allowed
22:00:31 <lambdabot>  .L.hs:158:1:
22:00:31 <lambdabot>      Multiple declarations of ‘family’
22:00:31 <lambdabot>      Declared at: .L.hs:155:1
22:00:38 <kallisti> > let family = 2 in family
22:00:41 <lambdabot>  2
22:01:55 <nuttycom> bitemyapp: also, in purescript, I like that the standard library has a very clean semigroupoid-oriented hierarchy of its typeclasses. And, of course, stuff like purescript-halogen, for which I know of no Haskell equivalent.
22:02:23 <YellowOnion> Whats peoples opinions on using acidState+quadtree for storing pixel/voxel data a' la minecraft.
22:03:05 <nuttycom> The lack of sharing datatypes between frontend and backend is a trifle annoying, but the data types in my backend's API are pretty trivial to reproduce.
22:05:02 <Lokathor> any good ghcjs guides? I tried to read the doc on their github once but the auto-build listed the repo as broken and the guide didn't seem to have been updated
22:05:36 <ReinH> Lokathor: How does that prevent you from reading the docs?
22:05:56 <YellowOnion> Lokathor, the guy who wrote it's blog shouldn't be too hard to find
22:07:04 <Lokathor> ReinH, it was the docs on their very own github i was trying to follow along
22:07:19 <mgsloan> Yeah, GHCJS travis is broken, it's being worked on
22:07:33 <Lokathor> but, at the specific time that i tried, they were out of date with what seemed to build, so i got lost fast
22:07:46 <Lokathor> this was a year ago, it might have improved quite a bit since then
22:08:08 <mgsloan> It can still be a bit of a challenge to install GHCJS from development source, and there's still some API flux in ghcjs-base (GHCJS hasn't had a hackage release yet)
22:08:27 <mgsloan> However, it should stabilize soon, and then we can put out some source tarballs that are easier to use
22:08:53 <Lokathor> i'm in no rush i suppose
22:08:59 <Lokathor> stabalize away
22:09:05 <mgsloan> If you are content with using "old-base" and not being on the bleeding edge, then stack can set it up for you
22:09:25 <Lokathor> oh wonderful, i have stack working on that machine
22:09:44 <mgsloan> Just run "stack setup" in a dir with a stack.yaml that has `resolver: ghcjs-0.1.0.20150924_ghc-7.10.2` 
22:10:07 <mgsloan> See this wiki page: https://github.com/commercialhaskell/stack/wiki/Stack-&-GHCJS
22:10:26 <slacko1256> I've started to notice that type classes implmented with more than what the minimal pragma requires are like datatypes with all the constructor exposes
22:10:41 <mgsloan> Note that the GHCJS master sdist is a couple weeks out of date, probably not a good idea to use it
22:10:44 <slacko1256> ie really linked to the implementation to be changed in the future
22:10:57 <slacko1256> *exposed
22:32:32 <quicksilver> I have been confused about ambiguous types. Have I got it straight now: Haskell calls it an 'ambiguous type' when FC would have a type like forall a . {type which does not mention a}
22:33:05 <quicksilver> which is no problem at all in a language with explicit type application but doesn't work out for haskell where type application must be implicit
22:33:30 <bitemyapp> quicksilver: My understanding is that if you force it, there's an obligation to have a concretion at the point you force it.
22:35:48 <quicksilver> bitemyapp: for example, if we had type application then "show.read" would have the perfectly reasonable type "forall a . String -> String" and you could do ((show.read)#Int) "3" === "3", ((show.read)#Int) "foo" === undefined, ((show.read)#Double) "3" == "3.0"
22:36:16 <quicksilver> using # for type application
22:36:40 <bitemyapp> quicksilver: perfectly reasonable doesn't mean, "I have something to execute/evaluate"
22:37:02 <bitemyapp> quicksilver: it's fine to discuss type-level hypotheticals with the compiler, but if you try to eval something, it needs a thing to eval.
22:37:11 <bitemyapp> quicksilver: so in the case of Read, it needs to know which instance to invoke.
22:37:41 <quicksilver> yes
22:37:50 <quicksilver> hence the restriction
22:38:01 <quicksilver> if you require all quantified types to acutally *appear*
22:38:06 <quicksilver> then there is always a way to pick the right instance
22:38:18 <bitemyapp> hrm, yeah, you've lost me :)
22:38:54 <quicksilver> if I did some trick like newtype TaggedString a = TS (String)
22:39:19 <quicksilver> and then made my own special version of show which worked exactly as it did now but kept the phantom tag from its argument
22:39:34 <quicksilver> class ShowTagged a where show :: a -> TaggedString a
22:39:45 <quicksilver> then I would have made 'a' appear in the answer
22:40:00 <quicksilver> and we'd be able to use type annotations to force the examples above
22:40:34 <aidenatt> Yo, anyone know if I can get in trouble for simply enabling piracy? Without actually hosting any data, just code. 
22:41:07 <liste> aidenatt almost any tool can be used for piracy
22:41:29 <liste> though this is off-topic for this channel
22:41:50 <aidenatt> Sorry :) Didn't know where to ask.
22:42:06 <liste> try #haskell-blah (:
22:42:09 <Axman6> well this is almost certainly not the right place... maybe there's a #law?
22:42:17 <liste> yeah #law
22:42:24 <liste> or other place where lawyers hang out
22:42:47 <aidenatt> Might try #law, cheers. 
22:42:48 <liste> ##law actually
22:43:15 <liste> people even talk there!
23:10:10 <isomorphismes> how do I use haddock to see what's in Data.List whilst offline?
23:10:23 <isomorphismes> (assuming haddock is the correct tool)
23:10:49 <cocreature> isomorphismes: set 'documentation: True' in your ~/.cabal/config and reinstall
23:11:48 <nineonine> why do we need to wrap transformer stacks in newtype ?
23:12:07 <isomorphismes> cocreature: I installed with stack; does that change the answer?
23:12:14 <cocreature> isomorphismes: stack haddock in that case
23:12:42 <isomorphismes> cocreature: but still only change that line in ~/.cabal/config ?
23:12:58 <cocreature> nineonine: we don't need to do that. it's just convenient and the newtypes ensure that you don't mix up transformer stacks
23:13:03 <cocreature> isomorphismes: no that change is meaningless
23:13:06 <cocreature> just run stack haddock
23:13:17 <nineonine> thank you
23:13:19 <jle`> nineonine: some people do it to hide implementation details
23:13:40 <jle`> nineonine: they export a MyProgramT, with effects they constructed using monad transformers
23:13:55 <jle`> and they just export MyProgramT to the user, and the user doesn't know "how" it was implemented
23:14:06 <nineonine> got it, thanks
23:14:15 <jle`> they just use it as what it is...a type with many effects
23:37:36 <roelof> Is this a good way for getting feedback on exercises I made : http://lpaste.net/143535 ? or can this also work https://github.com/rwobben/craft/tree/master/chapter_3
23:41:14 <jle`> roelof: it works :)  but we actually like to define and and or slightly differently in practice
23:41:39 <jle`> that's the only thing i can see that i would do differently
23:41:49 <roelof> jle`:  oke, how can I change it then ?
23:41:52 <jle`> also, there's no reason for (>> a) on line 20?
23:42:05 <jle`> was it supposed to be used earlier but you took it out?
23:42:39 <jle`> roelof: the way you wrote it is correct when both arguments are terminating, but in practice a short-circuiting definition becomes pretty useful
23:42:58 <roelof> jle`:  I found this on the wiki page  and like the way the tests are presenting 
23:43:27 <jle`> oh wait, i see what it does, sorry
23:43:31 <jle`> misread it
23:43:34 <roelof> jle`:  oke, I think that short-circuiting is explained later on the book  
23:43:40 <roelof> jle`:  no problem 
23:43:55 <jle`> we like to write myAnd False _ = False; myAnd True _ = True
23:44:16 <roelof> The only thing I do not like my self it the repeating of the map and test part on every solution 
23:44:32 <dolio> I don't like to write that. :)
23:44:34 <jle`> roelof: yeah; if you want,y ou can just define it as a function
23:44:39 <jle`> dolio: haha
23:44:40 <Lokathor> jle`, do you mean myAnd True x = x ?
23:44:41 <jle`> sorry
23:44:44 * frerich . o O (myOr True _ = True)
23:44:48 <jle`> myAnd True x = x, yes
23:45:12 <roelof> jle`:  where x  is all the two arguments ?? 
23:45:26 <jle`> myAnd False _ = False; myAnd True x = x
23:45:31 <Lokathor> i wrote a chip simulating library, but i didn't consider having it do lazy evaluation
23:45:32 <Lokathor> hmm
23:46:03 <roelof> jle`:  thanks 
23:46:27 <roelof> Can you give me a example how to write the test part as a function ?
23:47:01 <jle`> well, you can define a function runTests = mapM_ (\(s, a) -> printf "blah" s >> a)
23:47:08 <jle`> and then main = runTests tests
23:47:13 <jle`> and you can re-use the same thing for both cases
23:47:36 <jle`> the same runTests
23:51:17 <roelof> jle`:  like this : http://lpaste.net/143535
23:52:13 <jle`> roelof: i think you're forgeting `tests`, the argument
23:52:19 <jle`> runTest tests = do ...
23:53:41 <roelof> jle`:  thanks , you are right. I forget that part 
23:53:52 <jle`> np!
23:54:38 <roelof> So one file with all the exercises is better then every exercise a seperate file/project 
23:56:07 <roelof> hmm, I think I need cabal now or ghci to run the tests. stack tests is not working :(
23:57:10 <lightandlight> Is there anyway to contrain parameters in QuickCheck such that at least one paramater has a particular value?
23:57:11 <mgsloan> roelof: Do you have a "test-suite" in your cabal file?
23:57:14 <roelof> fizruk:  good morning ( 
23:57:42 <liste> lightandlight (a == x || b == x || c == x) ==>
23:57:43 <fizruk> roelof: well, hi there)
23:57:45 <roelof> mgsloan:  nope, I have used stack before and did not make a cabal project for this 
23:58:32 <mgsloan> So "stack runghc MyTestFile.hs" isn't working?
23:58:47 <lightandlight> liste: Oh so there's not cute typeclass stuff?
23:59:10 <liste> lightandlight don't know about that
