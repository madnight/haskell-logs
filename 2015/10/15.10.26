00:09:33 <quicksilver> if I have a conduit with no IO dependency, can I 'run' it to get a list which is produced lazily?
00:11:15 <brnhy> quicksilver AFAIK there is only http://hackage.haskell.org/package/conduit-extra-1.1.9.1/docs/Data-Conduit-Lazy.html (which uses IO)
00:17:48 <quicksilver> brnhy: seems weird; because you can build conduits which don't actually use IO
00:18:43 <quicksilver> e.g. parseText' :: MonadThrow m => ParseSettings -> Conduit Text m Event
00:52:15 <gfixler> is there a way to group certain constructors of a type together?
00:52:35 <gfixler> for example, if I had a bunch of villain types, but wanted to write a function that could only accept some of them
00:52:54 <gfixler> sorry, "a bunch of constructors of the same villain type"
00:54:23 <gfixler> is this what GADTs are for?
00:57:25 <liste> you can use GADTs for that
00:58:43 <liste> @let data Badass = Badass
00:58:44 <lambdabot>  Defined.
00:58:50 <liste> @let data Wimp = Wimp
00:58:52 <lambdabot>  Defined.
00:59:18 <liste> @let data Villain a where Joker :: Villain Badass; DrRobotnik :: Villain Wimp
00:59:20 <lambdabot>  Defined.
01:00:49 <gfixler> cool, though seems like a lot of typing
01:01:01 <gfixler> if I had 250 villain types, i.e.
01:02:01 <gfixler> no gadtFromList? :)
01:03:12 <liste> maybe at compile time using TH
01:03:24 <gfixler> yeah
01:04:39 <gfixler> Villain a seems a bit generic
01:04:55 <gfixler> so I could have a Villain Bool?
01:05:45 <liste> if you define one
01:06:14 <gfixler> this is interesting
01:06:20 <gfixler> I'm used to that a being for the user
01:06:33 <gfixler> but here we're smooshing a bunch of our own definitions into the data type
01:30:24 <babygau> Hi anyone, pls help http://lpaste.net/143945
01:31:11 <opqdonut> what is the type of "f" inside that function?
01:33:33 <babygau> opqdonut plse refresh, I just edit the post
01:34:41 <opqdonut> babygau: your code is correct, you just have a type problem
01:34:50 <opqdonut> babygau: what is the type of "f" inside ext?
01:35:22 <babygau> opqdonut it is (* 3)
01:35:28 <opqdonut> that's not a type
01:35:37 <opqdonut> :t not
01:35:38 <lambdabot> Bool -> Bool
01:35:42 <opqdonut> ^ that's a type, for example
01:36:13 <babygau> opqdonut I'm trying to extract (* 3) inside `Just (* 3)`
01:36:15 <babygau> opqdonut How to do it?
01:36:49 <babygau> opqdonut I think using pattern matching will extract `f` inside `Just f` ????
01:37:08 <opqdonut> babygau: your implementation of ext is correct, you've just messed up the type signature for ext
01:37:36 <babygau> opqdonut Oh, what's wrong there?
01:37:45 <liste> ext :: Maybe a -> Maybe b -> Maybe c <-- this means that the function should work for ALL a, b and c
01:38:21 <liste> so ext could be for example specialized to Maybe Int -> Maybe Bool -> Maybe String
01:38:30 <babygau> liste Oh, I see
01:39:09 <babygau> liste I changed to ext :: Maybe a -> Maybe a -> Maybe a but no luck?
01:39:54 <babygau> so what would I do :|
01:40:06 <liste> babygay you take a function as first param and value as second, so they can't be the same type
01:40:32 <liste> maybe start with the types of (*3) and 5 and generalize from them
01:41:11 <liste> so Maybe [the type of (*3)] -> Maybe [the type of 5] -> Maybe [the type of result]
01:41:44 <babygau> Lets say they're all the same type
01:41:49 <liste> they can't be
01:42:00 <liste> (*3) can't be the same type as 5
01:42:17 <liste> of the same type*
01:42:29 <babygau> oh
01:42:40 <babygau> Let's me modify a bit
01:43:01 <babygau> :t fmap (* 3) (Just 5)
01:43:03 <lambdabot> Num b => Maybe b
01:44:08 <babygau> :t Just (*3)
01:44:09 <lambdabot> Num a => Maybe (a -> a)
01:46:56 <babygau> liste I changed to ext :: Maybe (a -> b) -> Maybe a -> Maybe b
01:47:01 <babygau> liste And it worked!
01:47:09 <babygau> liste I could load the file
01:47:40 <liste> makes sense
01:47:45 <babygau> liste but cannot call the function
01:48:27 <liste> what does it say?
01:49:04 <babygau> oh, my mistake
01:49:08 <babygau> all work well!
01:49:23 <babygau> liste Got `Just 15` as expected!
01:50:23 <jle`> hooray!
01:50:35 <babygau> tks opqdonut and liste !!!
01:55:36 <liste> babygau yw (:
02:00:11 <gfixler> liste: yeah, it's still kinda weird
02:00:38 <gfixler> liste: for example, if I have 2 parameters to my GADT constructor, functions need to call them out in order
02:01:03 <gfixler> Wario :: Villain Tall Wimp
02:01:17 <gfixler> foo :: Villain Wimp Tall -> a -- doesn't match Wario
02:01:55 <liste> you could have typeclasses Size and Toughness, and data (Size a, Toughness b) => Villain a b maybe?
02:02:05 <liste> not sure if it works
02:02:24 <gfixler> liste: true, but if these are just properties...
02:02:50 <liste> that may be over-engineering it a bit
02:02:56 <gfixler> actually, not sure that works
02:03:23 <gfixler> maybe row polymorphism? (another thing I need to look into)
02:03:36 <gfixler> we must have a nice answer to this, checkable at runtime
02:03:50 <gfixler> sorry, compile-time
02:03:55 <gfixler> runtime is easy
02:04:27 <gfixler> I'd really like to just be able to list properties for constructors
02:04:52 <liste> gfixler maybe something like Vinyl would help?
02:04:54 <liste> @hackage vinyl
02:04:55 <lambdabot> http://hackage.haskell.org/package/vinyl
02:05:15 <gfixler> hmmm... the only thing I know about vinyl is that Jon Sterling said is very complicated
02:06:30 <gfixler> and he wrote this on a board at LambdaConf: https://twitter.com/gfixler/status/602242205600784384
02:06:41 <gfixler> and erased and rewrote things like that 2 dozen times in that talk
02:24:28 <anohigisavay> hi
02:24:39 <anohigisavay> "Mutable boxed vectors keyed on the monad they live in (IO or ST s)."
02:24:52 <anohigisavay> document for data MVector s a
02:25:02 <anohigisavay> what does this mean? sorry my English is bad
02:25:26 <anohigisavay> what does 'keyed' mean?
02:26:33 <cocreature> anohigisavay: “keyed” is referring to the s type parameter which represents the monad they live in
02:28:36 <anohigisavay> cocreature: so s is either IO or ST s?
02:30:52 <cocreature> anohigisavay: that's the idea, the type is actually more polymorphic, but you can't create something of type MVector s a where s is not IO or ST so pratically it can only be IO or ST s
02:31:38 <concept3d> Hello all, I am using the haskell websockets library, is there a way to identify each connection without having the client send an id. In other words if I have connections in a list I won't be able to compare the connection object because it lacks Eq implementation is there a way to write a valid Eq implementation without the client sending an Id
02:35:30 <cocreature> concept3d: looking at the source there is nothing uniquely identifying a Connection (https://hackage.haskell.org/package/websockets-0.9.6.1/docs/src/Network-WebSockets-Connection.html#Connection). What you could do is wrap the Connection an some other type that pairs it with a unique id and then when you create a connection you automatically create a new unique id using something like monad-gen or
02:35:32 <cocreature> Data.Unique
02:35:44 <cocreature> the eq instance can then simply ignore the actual Connection data and only compare the ids
02:42:58 <EvanR_> ahungry_: aka parameterized or indexed by
02:43:12 <Tehnix> Does anyone know if anybody is using Haskell in eCommerce? 
02:43:13 <EvanR_> Maybe a is parameterized
02:43:18 <EvanR_> anohigisavay: 
02:43:23 <concept3d> cocreature: thanks, I'll take a look at Data.Uniqe and monad-gen
02:44:25 <EvanR_> concept3d: you can also just increment a counter and assign that as the id for each new connection, having the client send an id is bad security
02:56:36 <cocreature> incrementing a counter is what monad-gen does internally
02:56:50 <cocreature> it's just a wrapper around a state monad with the current id
03:24:15 <EvanR_> yes so do unique
03:24:23 <EvanR_> or you could roll your own
03:32:11 <eklavya> withVars :: [(String, Integer)]
03:32:13 <eklavya>          -> (M.Map String Integer -> Maybe Integer)
03:32:14 <eklavya>          -> Maybe Integer
03:32:14 <eklavya>  withVars vs exp = exp $ M.fromList vs
03:32:43 <eklavya> this complaints about illegal type signature
03:33:00 <eklavya> and suggests to add ScopedTypeVariables
03:33:09 <eklavya> but even after adding that it doesn't compile
03:33:46 <eklavya> now it complaints that vs is not in scope!!
03:34:29 <PyroPeter> I'm a TA in an university course teaching FP using the example of haskell. I would like to show my students a good way to run automated tests on their code (they are currently testing manually via ghci). the students had two courses around java before, so they probably would be happy about something like the unit tests. do you know of a very simple to use testing framework for haskell?
03:34:53 <PyroPeter> the main problem is that the students can't actually use haskell at this moment. they don't even know what lists are
03:35:55 <PyroPeter> s/around/involving/
03:36:34 <Jinxit> teach them quickcheck?
03:40:18 <cocreature> PyroPeter:I would go for hcheck https://hspec.github.io/
03:40:22 <cocreature> eh hspec
03:42:01 <EvanR_> quickcheck would be actually introducing them to something new though, relative to java
03:42:57 <zomg> As someone with previous unit testing background before learning about QC, I must say it was a bit hard to think how to use it at first
03:43:27 <PyroPeter> yes, I think quickcheck is too advanced. I just need something gradually more elaborate than loading tests in ghci with :s and comparing the result by hand
03:43:27 <zomg> I've not made extensive use of it, but for a JS app we're developing at work we have a JS version of it in use in a few tests where I was able to figure out a "proof" for the function
03:43:28 <Jinxit> but the point of the entire course is to teach them new concepts IE FP, no?
03:43:52 <zomg> but it took some more thinking than the equivalent unit test would have :) Plus I think the QC proof for one test is still sporadically failing because of some corner case we don't actually care about in production :P
03:44:17 <PyroPeter> the problem is that there is no space reserved in the curriculum for testing at this point
03:45:04 <zomg> It's interesting you're bringing up testing so early
03:45:12 <PyroPeter> they have had one piece of homework each for recursive functions and for nonrecursive data types at this point
03:45:12 <zomg> Most beginner material I find doesn't really talk about it at all
03:45:14 <zomg> I mean automated testing
03:45:25 <zomg> (regardless of whether it's for Haskell or some other topic)
03:45:54 <PyroPeter> well, I'm really just annoyed by all the utter crap they give me for correction
03:46:01 <zomg> heh
03:46:22 <zomg> it's actually funny because I recently launched a JavaScript unit testing course and I'm actually getting fairly good solutions to the exercises I put into it :)
03:47:53 <zomg> But yeah I think in terms of how easy it would be to understand for Java devs, some more traditional unit testing tool like the aforementioned hspec could be easier
03:48:57 <PyroPeter> yes, I will look into hspec
03:52:31 <yashinbasement> what's the differene between Foldable t and simply t
03:54:36 <concept3d> yashinbasement : t is a type variable, Foldable t could be constraint that type t should implement the typeclass Foldable 
03:55:09 <yashinbasement> yeah sorry to be more specific what does Foldable implementaion do on t
03:57:10 <concept3d> yashinbasement : Foldable is any data structures that can be folded.
03:57:43 <yashinbasement> right so in other words we can apply some operation on a list to get single value
03:57:49 <EvanR> yashinbasement: what Foldable does depends of what t is
03:57:54 <EvanR> depends on
03:58:02 <yashinbasement> right
03:58:39 <EvanR> it gives you this operation
03:58:43 <EvanR> :t foldMap
03:58:44 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
03:59:09 <yashinbasement> hmm
03:59:14 <yashinbasement> thanks
03:59:22 <EvanR> now you need to learn Monoid ;)
03:59:39 <cocreature> :t toList
03:59:40 <yashinbasement> one more thing what is Set t
03:59:41 <lambdabot>     Ambiguous occurrence ‘toList’
03:59:41 <lambdabot>     It could refer to either ‘Data.Foldable.toList’,
03:59:41 <lambdabot>                              imported from ‘Data.Foldable’ at /home/lambda/.lambdabot/State/L.hs:86:1-20
03:59:46 <cocreature> :t Data.Foldable.toList
03:59:48 <lambdabot> Foldable t => t a -> [a]
03:59:55 <cocreature> that doesn't require you to learn Monoid :)
04:00:06 <vedosity> I have [a], and I have `a -> Maybe b`. Is there something like asumBy where I can pass that `a -> Maybe b`?
04:00:28 <EvanR> yeah Foldable may or may not be just a fancy class for "toList" support
04:01:18 <EvanR> vedosity: asumBy? what is the type of this
04:02:45 <cocreature> :t asum . traverse (undefined :: a -> Maybe b)
04:02:46 <lambdabot> (Traversable f, Alternative f) => f a1 -> f a
04:02:48 <cocreature> something like that?
04:03:42 <cocreature> hm replace traverse by fmap
04:03:49 <cocreature> then it makes probably more sense
04:04:03 <EvanR> :t asum
04:04:04 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
04:05:45 <vedosity> asumBy would behave somewhat like asum, its type would be `(Foldable t, Alternative f) => (a -> f b) -> t a -> a`
04:05:56 <yashinbasement> is set and list are same concept 
04:05:59 <vedosity> Hmm
04:06:22 <cocreature> :t \f -> asum . fmap f
04:06:23 <lambdabot> (Functor t, Foldable t, Alternative f) => (a1 -> f a) -> t a1 -> f a
04:06:42 <EvanR> :t union
04:06:44 <lambdabot> Eq a => [a] -> [a] -> [a]
04:06:46 <cocreature> wait what do you do with the b in your asumBy?
04:06:57 <EvanR> > [1,2,3] `union` [3,4,5]
04:06:59 <lambdabot>  [1,2,3,4,5]
04:10:19 <vedosity> cocreature, I would do asum on the t a mapped to t (f b) through the first parameter, and the result would be..
04:10:39 <cocreature> YellowaphocusOni: but the result is f b not a if you throw asum on that
04:11:39 <vedosity> not really sure. I think what I was thinking of makes sense for Maybe but not Alternative in general, because concat a b doesn't have to return a or b
04:12:17 <vedosity> Err, (<|>) not concat
04:14:54 <EvanR> :t (<|>)
04:14:55 <lambdabot> Alternative f => f a -> f a -> f a
04:34:10 <ozgura> hi guys. if we have any stack users around, may I ask: how can I find the latest lts for ghc-7.8 series? 
04:34:25 <ozgura> or a list of all LTSs? when I click on "LTS Haskell" on the stackage main page it takes me to lts-3.11 
04:37:00 <cocreature> ozgura: you can look here https://www.stackage.org/snapshots but that's definitely not very convenient
04:38:01 <ozgura> cocreature: that's not too bad actually
04:38:09 <ozgura> I can see it was 2.22, released 3 months ago
04:38:27 <cocreature> yeah it does the job, but it's annoying to have to go back and search manually
04:38:46 <cocreature> something like that but seperated for major versions and nightlies would be nice
04:39:16 <cocreature> maybe I should set up a website for that
04:39:54 <ozgura> heh, that would be nice :)
04:40:27 <ozgura> although if the snapshots page had a way of filtering that could also be better, since it is already there
04:41:07 <ozgura> I don't understand one thing though, did they basically abandon 7.8 series? if the last update was 3 months ago?
04:41:24 <cocreature> I think so
04:41:34 <cocreature> afaik there is always only one lts series being maintained
04:41:43 <ozgura> in my particular case, I need transformers >=0.4, I will have to list it as an extra-dep
04:42:23 <ozgura> (among others)
04:43:02 <cocreature> or move to 7.10 :)
04:43:50 <ozgura> which I did, but I like being able to compile on more than one version of the compiler
04:44:17 <ozgura> I have a muti-config build, which helps me see performance changes between versions and etc
04:44:52 <cocreature> ah ok
04:45:22 <ozgura> cabal install && cabal freeze seems to work fine for me. I thought stack would work even better, but alas, it requires more input from me about versions.
04:45:47 <ozgura> (I only do a cabal refreeze every once in a while)
04:46:18 <ozgura> (where refreeze is basically "rm cabal.config && cabal install && cabal freeze")
04:49:29 <ozgura> anyway, thanks cocreature!
04:49:36 <cocreature> np
05:06:33 <bergmark> ozgura: using the lts-2 resolver will give you the latest point release
05:07:31 <bergmark> but lts-2 is not maintained anymore
05:08:24 <merijn> Anyone have any pointers how to implement something like inferrable/implicit function arguments work? i.e. avoiding the need to write "Cons @Bool True (Nil @Bool)" in my term language instead of "Cons True Nil"?
05:19:39 * hackagebot mustache 0.4.0.1 - A mustache template parser library.  https://hackage.haskell.org/package/mustache-0.4.0.1 (justus)
05:45:23 <cpennington> anyone here know why wreq would be allocating significantly more memory than a python library doing similar work?
05:45:47 <byorgey> merijn: I recommend chapters 22 and 23 of Types and Programming Languages
05:45:50 <frerich> merijn: Maybe one uses some sort of constraint programming for that? I'm really just guessing.
05:46:41 <concept3d> is it equivelant to use type Server = TVar[Client]    or TVar Server, meaning what is the difference between having TVar inside or outside the type
05:47:13 <byorgey> frerich: the easiest way I know of to do it does indeed work by generating constraints during type checking and then later solving the set of constraints.  Though I think "constraint programming" usually means something else
05:47:14 <merijn> byorgey: I'll have to reread those and see, I guess :)
05:47:26 <byorgey> =)
05:47:42 <merijn> I hope that doesn't mean having to redo substantial parts of my typechecker >.>
05:49:18 <merijn> byorgey: Yeah, I know the "take new fresh variable and unify" approach, but I'm not quite sure that actually works with the system I have now >.>
05:49:30 <bergmark> cpennington: how do you know it's wreq itself that's the problem? you should probably profile to make sure, and then you may have your answer
05:49:52 <byorgey> merijn: interesting
05:50:08 <merijn> I have System F_omega, based on the Henk paper by SPJ and Erik Meijer, and afaik inference is not decidable there?
05:50:16 <merijn> That's why I'm currently only checking
05:51:03 <merijn> I'd certainly have to first change the checker to use their predicative approach, I think. Since it's currently still impredicative
05:51:59 <byorgey> merijn: hmm, try http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/putting.pdf perhaps ?
05:53:04 <merijn> byorgey: I'll have a look, thanks :)
06:07:00 <cpennington> bergmark: I've profiled, and according to -pa, the allocations are happening inside the function that calls Wreq.get. I added explicit cost centres around every expression in that function, and verified that it was Wreq.get that was the issue
06:07:13 <cpennington> (or rather, that was doing the allocation)
06:07:30 <cpennington> I haven't yet opened up the Wreq package to profile inside that function
06:09:42 * hackagebot tagsoup 0.13.4 - Parsing and extracting information from (possibly malformed) HTML/XML documents  https://hackage.haskell.org/package/tagsoup-0.13.4 (NeilMitchell)
06:15:21 <cpennington> aha. reinstalling wreq with -auto as well as --enable-profiling has gotten me more detail
06:17:15 <cpennington> yeah, bizarrely, wreq is doing 12 mb of memory to make a request with content-length 188
06:18:09 <tdammers> so?
06:18:39 <tdammers> if the task is to calculate some sort of crypto hash on a 12 MB payload...
06:23:19 <quicksilver> I have a Conduit which is polymorphic in m. If I attach it to an IO sink and run it in IO, it clearly runs incrementally. If I use Conduit.List.consume a sink, run it in Identity in pure code, it runs to the end before producing anything :(
06:23:26 <cpennington> tdammers: in this case, I'm just trying to read the response code
06:24:42 <quicksilver> seems like consume is the bad guy, but isn't there a way of running a pure conduit productively in pure code?
06:27:46 <tdammers> cpennington: that sounds kind of wrong then :D
06:32:45 <cpennington> tdammers: yeah, I'll keep digging when I get some time
06:32:51 <MadNomad> hey guys
06:33:14 <magneticduck> you're only trying to make conversation because you're about to ask something of us MadNomad 
06:33:21 <magneticduck> get on with it, you monster
06:33:59 <MadNomad> magneticduck: im not actually
06:34:05 <magneticduck> oh well
06:34:08 <magneticduck> it was a decent guess
06:35:37 <MadNomad> haha
06:35:41 <MadNomad> how goes it
06:36:18 <Aeroblop> Hey guys, say I have an integer, x, and a list of integers, what is the quickest way of finding the biggest integer in the list of integers that is smaller than x?
06:37:01 <Aeroblop> I currently have   biggestNum x (y:ys) = if x >= y then y else biggestNum x ys   and if I gave biggestNum 997 [1000,900,500,400,100..] it would return 900
06:37:16 <Aeroblop> are there any built in functions that do this?
06:37:41 <Rembane> Aeroblop: What about a combination of maximum and filter?
06:37:52 <Aeroblop> Rembane: example?
06:38:08 <magneticduck> Aeroblop: that algorithm doesn't work, it only returns the first element that's smaller than x
06:38:16 <Rembane> Aeroblop: \n -> maximum $ filter (<= n) [...]
06:38:23 <Aeroblop> Magneticduck, that's fine, that's all I need
06:38:26 <magneticduck> uhh
06:38:44 <mmm> I am looking for job
06:38:48 <magneticduck> Aeroblop: use hayoo
06:38:48 <mmm> anything here
06:39:01 <Aeroblop> What's hayoo?
06:39:07 <magneticduck> it's this thing
06:39:15 <magneticduck> you can search for type signatures and stuff
06:39:21 <Ankhers> @where hayoo
06:39:21 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
06:39:25 <Aeroblop> Oh, I searched on Hoogle
06:39:53 <magneticduck> http://hayoo.fh-wedel.de/?query=%28Ord+a%29+%3D%3E+[a]+-%3E+a
06:40:32 <magneticduck> mmm: do you also want money?
06:40:35 <magneticduck> or just a job
06:41:14 <Myrl> Hey guys.
06:41:33 <Myrl> Using parsec (or attoparsec) how would I do this?
06:41:35 <Azel> Aeroblop: but coming back to your question, if what you need is the first element matching a criteria it's easy: dropWhile should do the trick.
06:42:00 <Myrl> "x <- z ->" => "x " ++ read (f z)
06:42:01 <magneticduck> Aeroblop: or 'find' from Data.List
06:42:15 <Myrl> So, for example, my f increments it, and z is a number
06:42:26 <Myrl> "x <- 1 ->" will return "x 2"
06:42:45 <mauke\lpt1> then what is read doing there?
06:42:54 <Myrl> mauke\lpt1: Should be show, sorry.
06:42:59 <mauke\lpt1> oh
06:43:17 <Myrl> Well, half truth again, it should really just be "x " ++ f z, since f should return a string.
06:43:32 <Myrl> Thought that it'd be clearer to explicitly have a `show` there though.
06:43:47 <Myrl> mauke\lpt1: Got an idea on how to do it?
06:43:59 <mauke\lpt1> I'd use perl
06:44:05 <Myrl> Lol.
06:44:17 <magneticduck> I'd use elisp
06:44:27 <Aeroblop> Thanks magneticduck, Rembane and Azel :) <3
06:44:35 <Myrl> Seriously guys. :P
06:44:44 <MadNomad> super cerious
06:44:52 <Myrl> Very sirius.
06:45:24 <Myrl> I'm thinking of using manyTill or something.
06:45:37 <Myrl> Something like
06:45:41 <mauke\lpt1> s/x <- (\d+) ->/"x " . f($1)/aeg
06:45:57 <magneticduck> perl is overrated
06:46:19 <magneticduck> for reasons
06:46:56 <Myrl> `many ((,) <$> manyTill "<-" <*> manyTill "->")`
06:46:57 <_ari> everything is overrated
06:47:06 <Myrl> (Yes, that won't compile.)
06:47:16 <Myrl> Just trying to give a basic idea of what I'm planning to do.
06:47:34 <Myrl> Something something non-greedy something something.
06:47:45 <mauke\lpt1> what exactly are x and z?
06:48:00 <Myrl> Meh, let's remove all the abstraction.
06:48:13 <Myrl> Okay, you guys know PHP, right? Okay, now imagine Haskell.
06:48:21 <Myrl> Embedding Haskell in HTML.
06:48:32 <Myrl> The opening and closing tags are <` and `>
06:48:43 <mauke\lpt1> no, thanks
06:48:47 <Myrl> <` and `> should also be on their own lines to make parsing easier.
06:48:49 <Ankhers> Can't we already do that with hamlet?
06:49:02 <Ankhers> And probably other templating libraries.
06:49:25 <mauke\lpt1> PHP was a bad idea, as was PLP. I don't think it will be better with Haskell
06:49:37 <Myrl> Ankhers: I'd be glad if I find one that works well.
06:49:57 <Ankhers> Myrl: What is wrong with hamlet?
06:50:12 <Myrl> Ankhers: I still haven't tried it out, that's why I'd be glad.
06:50:21 <Ankhers> Myrl: There is also heist.
06:51:07 <Myrl> Hmmm
06:51:23 <mauke\lpt1> if you're just looking for fixed strings like <` and `>, I'd do it manually
06:51:56 <Myrl> mauke\lpt1: Manually?
06:52:19 <Ankhers> Myrl: blaze-html can build the html from Haskell code.
06:52:37 <Myrl> I'd prefer it the other way around, actually.
06:52:50 <Ankhers> Just stating options.
06:52:54 <Myrl> Yeah.
06:53:01 <Myrl> I've checked out blaze, and it seems good.
06:53:11 <mauke\lpt1> Myrl: yeah, just searching a string for "<`", no parser libraries
06:53:12 <Myrl> Though, HTTP just looks weird without the tags.
06:53:31 <Ankhers> HTTP has nothing to do with tags.
06:53:37 <Myrl> I kinda get lost while reading the blaze.
06:53:42 <Myrl> Ankhers: Err, I mean HTML.
06:53:44 <Myrl> Sorry. :P
06:54:01 <Myrl> I've been mixing up words lately, huh? :P
06:54:11 <danza> Myrl, you might like the implementation of mustaches for Haskell
06:54:36 <danza> of course that way you lose type and syntax checking, it is not a domain specific language anymore
06:54:41 <Rembane> Aeroblop: np, good luck!
06:55:03 * hackagebot singleton-nats 0.4.0.0 - Unary natural numbers relying on the singletons infrastructure.  https://hackage.haskell.org/package/singleton-nats-0.4.0.0 (AndrasKovacs)
06:55:34 <Myrl> Hmm..
06:55:47 <danza> https://github.com/lymar/hastache
06:56:50 <Myrl> This might be a bit of an overkill for what I'm trying to do though.
06:57:18 <Myrl> Since all I just want is to capture the text enclosed in <` and `>, then apply a function to it.
06:57:55 <Ankhers> I thought you were trying to do templating.
06:58:03 <Ankhers> Why not just use an XML parser?
06:58:12 <Myrl> Ankhers: I am.
06:58:30 <Ankhers> Myrl: It sounded like you were writing your own parser.
06:58:46 <Myrl> The text enclosed in <` and `> is actually, *dun dun dun* Haskell code, and then I will use hint.
06:59:12 <Myrl> "I mean, how hard can it be?" --famous last words.
07:00:39 <mauke\lpt1> perl -pe 's/<`(.*?)`>/`ghc -e '$1'`/eg'
07:00:56 <Myrl> mauke\lpt1: Lol.
07:01:28 <Myrl> mauke\lpt1: I can weirdly understand that.
07:01:46 <ww> it would be cool to have arbitrary delimiters in template haskell...
07:01:50 <mauke\lpt1> it's executable pseudocode
07:04:10 <Myrl> Hmmm...
07:04:14 <Myrl> Well, thanks guys.
07:04:23 <Myrl> I think I found a way to do it.
07:04:25 <mmm> magneticduck: money also
07:05:33 <magneticduck> mmm: what do you do?
07:06:23 <mmm> magneticduck: I dont do much now. but I can do good writing/programming for you
07:08:15 <amigojapan> comerijn: ok, here I am
07:08:50 <deception1> shall i use quickcheck to test REST APIs, if possible advice me how should I approach it.
07:09:30 <tetek> hi all, did you notice that haskell wiki doesn't work?
07:11:13 <shachaf> tetek: #haskell-infrastructure would be the place to ask.
07:11:39 <tetek> thx shachaf 
07:21:31 <Myrl> This is making me feel stupid.
07:21:38 <Myrl> I give up.
07:21:40 <Myrl> I'm stupid.
07:21:46 <Myrl> I'll just use Blaze or something.
07:21:56 <Myrl> Actually, no.
07:22:23 <Myrl> I just won't inline it.
07:22:40 <Myrl> Though, using Blaze might be a good idea.
07:30:25 <Myrl> Oh, cool.
07:45:06 * hackagebot mustache 0.5.0.0 - A mustache template parser library.  https://hackage.haskell.org/package/mustache-0.5.0.0 (justus)
07:49:27 <quicksilver> hmm, HaXml's SAX parser distinguishes between <foo/> and <foo></foo>
07:49:35 <quicksilver> that's potentially confusing
07:51:23 <frerich> I'm tempted to claim it's plain wrong given that http://www.w3.org/TR/REC-xml/#NT-content makes it seems that the two versions are synonymous, so any difference in handling would be wrong.
08:04:38 <quicksilver> frerich: any different in handling would be wrong, yes
08:04:58 <quicksilver> frerich: there might be efficiency or expediency reasons for a parser to have two alternate forms, but you'd have to be careful
08:05:03 <quicksilver> it doesn't seem helpful in this case though.
08:05:07 * hackagebot operational-alacarte 0.1 - A version of Operational suitable for extensible EDSLs  https://hackage.haskell.org/package/operational-alacarte-0.1 (EmilAxelsson)
08:05:35 <quicksilver> frerich: on the other hand, you basically have this problem anyway, becuase it is quite correct to distinguish "<foo> </foo>"
08:05:48 <quicksilver> even though in many cases you would expect to ignore that whitespace
08:17:16 <anohigisavay> hi. anyone can give an example usage of untilM?
08:17:39 <anohigisavay> i don't understand how monad operations in the first argument can influence the second
08:18:23 <anohigisavay> untilM :: Monad m => m a -> m Bool -> m [a] 
08:18:56 <comerijn> It basically first runs the first action, then the second and if the the second action returns False it repeats
08:19:26 <comerijn> When the second action generates True it stops. And it returns the list of all a's generated before the True
08:20:19 <anohigisavay> how do i know in the `m Bool` part that it has come to a state where i want it to stop?
08:20:31 <comerijn> You don't
08:20:44 <anohigisavay> with until :: (a -> Bool) -> (a -> a) -> a, i can at least get an a to operate with
08:21:10 <comerijn> You want one of the other monad-loops functions
08:21:17 <quicksilver> anohigisavay: it normally only makes sense if your monad has smoe notion of state
08:21:20 <comerijn> Something like
08:21:23 <comerijn> "iterateUntilM :: Monad m => (a -> Bool) -> (a -> m a) -> a -> m a"
08:21:26 <comerijn> quicksilver: Not really
08:21:37 <comerijn> eh
08:21:38 <comerijn> Wait
08:21:45 <quicksilver> anohigisavay: for example the second argument can read an IORef (if it were in IO)
08:21:59 <quicksilver> anohigisavay: or it can check some property of the state parameter (it it were in State)
08:22:11 <anohigisavay> quicksilver: yea that makes sense
08:22:17 <mauke\lpt1> :t let untilM b p = do { x <- b; c <- p; if c then return [x] else liftM (x :) (untilM b p) } in untilM
08:22:18 <lambdabot> Monad m => m t -> m Bool -> m [t]
08:22:24 <quicksilver> or in a slightly larger sense of the word state, it could check external library state like 'isEof'
08:22:31 <quicksilver> checking whetehr a file handle is at end of file
08:23:30 <comerijn> quicksilver: He just wants "Monad m => m a -> (a -> m Bool) -> m [a]" or something along those lines
08:24:01 <comerijn> Or perhaps with "a -> Bool" instead. And that's perfectly sensible and tbh I'm not sure why monad-loops doesn't have it
08:24:06 <quicksilver> well maybe he does.
08:24:33 <quicksilver> but he said he didn't understand how first argument could influence the second in untilM
08:24:41 <quicksilver> and that question deserved an answer :P
08:25:28 <anohigisavay> yea. i came to know iterateUntil; looks like what i need. but still why untilM is needed at all
08:58:46 <mmm> I am looking for remote job. anyone hiring?
08:58:53 <mmm> please PM me
08:59:30 <kras> HI, I have created an algebraic datatype using record syntax
08:59:47 <kras> how do I construct a value of it
09:00:09 <dfeuer> Anyone know what's up with the Haskell wiki?
09:00:11 * hackagebot operational-alacarte 0.1.1 - A version of Operational suitable for extensible EDSLs  https://hackage.haskell.org/package/operational-alacarte-0.1.1 (EmilAxelsson)
09:00:43 <andromeda-galaxy> kras: How do you construct a record type usually?
09:01:07 <Taneb> kras: with data Foo = Foo {a :: Int, b :: Char} you can either do Foo 1 'a' or Foo {a = 1, b = 'a'}
09:01:09 <dfeuer> With constructors! Or prisms! Or unsafeCoerce!
09:01:23 <Taneb> Those two are equivalent, but with the second one you can reorder the parameters
09:01:53 <andromeda-galaxy> dfeuer, Taneb: I was going to try out the "socratic questioning" method from the wiki... (leaving out lenses for now)
09:02:11 <Geekingfrog> Does anyone knows how to fix the following error with `stack install`: "--  Failure when adding dependencies:
09:02:12 <Geekingfrog>       attoparsec: needed (>=0.13 && <0.14), 0.12.1.6 found (latest is 0.13.0.1)
09:02:12 <Geekingfrog> " ?
09:02:37 <Taneb> andromeda-galaxy: it's not clear at all that kras has enough experience with records for that to be useful
09:02:42 <dfeuer> andromeda-galaxy, I'm really hoping you'll leave out the unsafeCoerce bit too. But andromeda-galaxy, I can't seem to reach the wiki today. 
09:02:49 <Taneb> You have to actually teach people at some point
09:03:01 <kras> dfeuer: Taneb: I get the a from a parse function
09:03:12 <andromeda-galaxy> dfeuer: I don't know what's up with the wiki.  Taneb: true, I wanted to see how much knowledge kras had first...
09:03:28 <kras> and I am trying to get it to assigned to FF {a=}
09:05:11 * hackagebot yaml-config 0.3.0 - Configuration management  https://hackage.haskell.org/package/yaml-config-0.3.0 (FedorGogolev)
09:05:35 <kras> http://lpaste.net/143957
09:05:52 <kras> please see the moduleDef function
09:06:56 <kras> moduleDef's type is Either ParseError String
09:07:17 <kras> How do I construct a Module value with this?
09:07:20 <mauke\lpt1> looks more like Parser String to me
09:07:26 <kras> sorry if the questio is not clear
09:08:19 <andromeda-galaxy> kras: do you know how to parse the modName/portList/modItems?  Then, you can just do Module { modName = modName, portList = portList, modItems = modItems }
09:08:32 <mauke\lpt1> do { n <- moduleDef; return (Module n [] []) }
09:11:18 <mmm> mauke\lpt1: 
09:11:26 <kras> andromeda-galaxy: though I listed the full datatype I just started with parsing only modName
09:12:36 <kras> mauke\lpt1: I keep forgetting praser is an instance of monad, let me give it a try
09:12:53 <andromeda-galaxy> kras: okay, so when you have all of the values, you can do Module modName portList modItems or Module { modnmae = modName, portList = portList, modItems = modItems }
09:14:05 <andromeda-galaxy> kras: to change moduleDef to have type 'Parser Module' you can, if I remember parsec properly, just change 'return b' to 'return Module {...}'
09:15:12 * hackagebot Bang 0.1.1.1 - A Drum Machine DSL for Haskell  https://hackage.haskell.org/package/Bang-0.1.1.1 (5outh)
09:17:06 <kras> andromeda-galaxy: b is a String type, so it complains
09:17:23 <andromeda-galaxy> kras: hmm?
09:18:10 <kras> andromeda-galaxy: sorry got what you are saying
09:18:29 <kras> andromeda-galaxy: thanks a lot
09:19:03 <andromeda-galaxy> kras: glad to be of help
09:19:47 <kras> andromeda-galaxy: awesome it works
09:20:02 <kras> why didn't I think of it :-)
09:35:13 * hackagebot opaleye-trans 0.2.0 - A monad transformer for Opaleye  https://hackage.haskell.org/package/opaleye-trans-0.2.0 (wraithm)
09:44:26 <haskell871> If i have a list of tuples like [(a,b), (a1,b1), (an,bn)]  is there a way i can check if an "a" is in the list regardless of the b value 
09:45:14 * hackagebot htiled 0.1.3.0 - Import from the Tiled map editor.  https://hackage.haskell.org/package/htiled-0.1.3.0 (m09)
09:45:17 <frerich> haskell871: You could use 'map fst' on your list to get all the 'a' elements and then use 'elem'.
09:46:21 <haskell871> yeah that was a lot easier than i was thinking
09:46:24 <haskell871> cheers
09:46:29 <frerich> haskell871: Or you could use the 'lookup' function and see whether you get a 'Nothing' or not.
09:49:11 <hexagoxel> :t any ((==3) . fst)
09:49:12 <lambdabot> (Eq b, Num b, Foldable t) => t (b, b1) -> Bool
09:56:55 <quicksilver> :t anyOf _1 (==3)
09:56:57 <lambdabot> (Eq b, Num b, Field1 s s b b) => s -> Bool
10:13:07 <bennofs> :t anyOf (folded._1) (==3) -- quicksilver you need folded because anyOf doesn't work on lists by default
10:13:09 <lambdabot> (Eq b, Num b, Foldable f, Field1 a a b b) => f a -> Bool
10:13:51 <notabigthreat> is the wiki down for you as well?
10:14:46 <andromeda-galaxy> notabigthreat: yes, I think that someone is planning on restarting it soon
10:14:55 <notabigthreat> hopefully
10:14:59 <andromeda-galaxy> See, #haskell-infrastructure
10:35:20 <hc> hey, quick question: i'm creating a monad that's based on StateT and Process. Now I would like to offer the user of the monad a possibility to store their own state. should i cascade two StateT monads or is there an easier way?
10:35:57 <hc> ...Ah hmm, maybe I could always use a tuple to store the internal state, and use the second field to store the user's state...
10:36:07 <phadej> that's one option
10:36:48 <phadej> users will probably appreciate if you make a MonadState userState (YourMonad userState) instance
10:37:35 <hc> okay
10:42:37 <bitemyapp> if anyone here has used EKG, is there a better way to manage recording latency for a set of handlers than having a product type with a field for each-and-every-handler?
10:43:04 <bitemyapp> the only alternative I've been able to fathom so far has been to make a HashMap of handler names to gauges but that makes me grumpy.
10:45:16 * hackagebot pinboard 0.9.1 - Access to the Pinboard API  https://hackage.haskell.org/package/pinboard-0.9.1 (jonschoning)
10:46:45 <haskell634> Hi, how can i pattern match this data type? I want to make a if statement, so if (Chr x) then do .. else .. here is the type: data Key = Chr Char | Back | FarBack | GoLeft | GoRight
10:47:09 <joco42> how can i factor out  the common pattern from case expression ? the where clause does not seem to work... https://usercontent.irccloud-cdn.com/file/q2lRdvhM/Screen%20Shot%202015-10-26%20at%2019.44.39.png
10:49:41 <joco42> here is an example how my attempt fails https://usercontent.irccloud-cdn.com/file/1KmNQr0V/Screen%20Shot%202015-10-26%20at%2019.48.48.png
10:50:36 <haskell634> anyone?
10:50:54 <bitemyapp> thoughtpolice: you've used ekg right?
10:51:05 <andromeda-galaxy> haskell634: let me take 
10:51:09 <andromeda-galaxy> a look at it...
10:52:34 <haskell634> i want to go through a list with the data type key. [Key] so if i find a type (Chr x) then i want to print out char Char
10:52:48 <haskell634> but i cant find a way to pattern match that in a if statement 
10:53:25 <andromeda-galaxy> haskell634: I believe that you'll need to write a little helper isChr (Chr x) = True;isChr _ = False...
10:53:31 <andromeda-galaxy> or just use a case
10:53:36 <joco42> problem solved :) https://usercontent.irccloud-cdn.com/file/XrjO0Stt/Screen%20Shot%202015-10-26%20at%2019.52.50.png
10:54:17 <haskell634> got it
10:54:20 <haskell634> thanks!
10:55:09 <andromeda-galaxy> haskell634: great! np
11:00:18 * hackagebot wai-transformers 0.0.3 - Simple parameterization of Wai's Application type  https://hackage.haskell.org/package/wai-transformers-0.0.3 (athanclark)
11:05:19 * hackagebot lattices 1.4.1 - Fine-grained library for constructing and manipulating lattices  https://hackage.haskell.org/package/lattices-1.4.1 (phadej)
11:10:42 <ReinH> haskell634: you don't need an if statement, you can just use a case statement.
11:10:57 <haskell634> can u give a example?
11:11:13 <andromeda-galaxy> ReinH: that's why I said ``or just use a case''...
11:11:32 <ReinH> case key of Char c -> ...
11:11:32 <jophish> I have a function foo :: b -> b, but I want to use it as a function from MyNewtype b -> MyNewtype b. So I'm looking for a function like this: (Unwrapped a -> a) -> (Unwrapped -> Unwrapped a) -> a -> a
11:11:45 <andromeda-galaxy> haskell634: case x of Chr x -> abc\n_ -> <if its not a char>
11:11:47 <jophish> what that would do, would unwrap it's argument, call foo and then rewrap the argumet
11:11:59 <jophish> I have a feeling that `ala` can fit the bill somehow
11:12:03 <jophish> but I can't quite see how
11:12:06 <andromeda-galaxy> jophish: fmap?
11:12:07 <ReinH> jophish: make it a functor
11:12:34 <haskell634> what does abc\n means?
11:12:49 <ReinH> haskell634: in what context?
11:12:59 <andromeda-galaxy> haskell634: that was just my notation for putting a newline between the cases
11:13:02 <jophish> oh shit, is my face red :(
11:13:17 <jophish> I shouldn't have spent all day playing aroud with lens and ala
11:13:26 * cocreature gives jophish some green paint
11:13:27 <haskell634> oh ok
11:13:28 <haskell634> thanks
11:19:11 <joco42> here is a pretty interesting problem, i don't know if this happens because of  the  a limitation of Haskel's type system or because of the limitation of my imagination ... any opinions ? https://usercontent.irccloud-cdn.com/file/QUY4yshj/Screen%20Shot%202015-10-26%20at%2020.16.26.png
11:20:24 <andromeda-galaxy> joco42: is that maybe the monomorphism restriction?
11:20:30 <ReinH> joco42: normalizeSvg takes a Float and getQuestion takes an Int
11:20:48 <jpp7> can somebody please tell me why this doesn't work when I pass: d [] [0]
11:20:48 <jpp7> http://paste.ofcode.org/UNBLx36pm9kmEjuy8mg3YY
11:20:49 <ReinH> They have different types, so it is a type error to treat them as having the same type
11:20:49 <andromeda-galaxy> ReinH: oops, git that backward
11:21:00 <andromeda-galaxy> I thought that itw as the other way around..
11:21:03 <joco42> ReinH:  but can i make it polimorphic ?
11:21:10 <jpp7> shouldn't it be caught by the guard that says "otherwise = error "Not same length" ?
11:21:14 <andromeda-galaxy> joco42: a :: Num a => a ->...
11:21:16 <joco42> function that takes an Num ?
11:21:24 <ReinH> joco42: You would need both to take a Num a => a instead of Float or Int
11:21:30 <ReinH> And by the way: don't use Float, use Double
11:21:38 <andromeda-galaxy> well, theres ExistentialQuantification...
11:21:41 <joco42> hmmm....
11:21:45 <ReinH> Float is almost always the wrong choice, unless you specifically need lower precision for some reason
11:21:52 <joco42> ok
11:21:56 <joco42> :)
11:22:01 <joco42> good to know
11:23:23 <joco42> but i really wonder why this is not possible to do in Haskell...
11:23:38 <ReinH> joco42: Because you are claiming that Int and Float are the same type.
11:23:41 <ReinH> They are not.
11:23:42 <joco42> i mean, why can i not generalize over the type of some function?
11:23:49 <ReinH> You can, as long as it is general.
11:23:58 <ReinH> But you are giving concrete types
11:24:06 <joco42> where ?
11:24:11 <ReinH> Int and Float
11:24:18 <andromeda-galaxy> joco42: normalizeSvg/getQuestion: Int -> ... and Float ->...
11:24:18 <ReinH> in the two functions
11:24:42 <joco42> yes, indeed
11:24:48 <ReinH> If those functions were Num a => a -> ... it would work
11:25:04 <ReinH> You can convert inside the functions
11:25:20 * hackagebot wai-middleware-content-type 0.0.3.1 - Route to different middlewares based on the incoming Accept header.  https://hackage.haskell.org/package/wai-middleware-content-type-0.0.3.1 (athanclark)
11:25:33 <ReinH> This is exactly the same problem as trying to write a function: impossible b = if b then 1 else "foo"
11:25:55 <joco42> hmmm
11:26:22 <joco42> i have to thing about this... i dont yet see the light
11:26:30 <joco42> btw this compiles 
11:26:35 <jophish> instance isString Integer
11:26:37 <jophish> IsString*
11:26:39 <joco42> https://usercontent.irccloud-cdn.com/file/nlqddVRA/Screen%20Shot%202015-10-26%20at%2020.25.18.png
11:26:53 <andromeda-galaxy> joco42: you want a :: Num a => a -> <something>, right?
11:27:06 <joco42> andromeda-galaxy:  yeah...
11:27:11 <ReinH> joco42: yes, that compiles.
11:27:23 <andromeda-galaxy> joco42: but normalizeSvg :: Int -> <something>, right?
11:27:29 <joco42> i want read to dispatch on the function type, at runtime
11:27:37 <ReinH> You can't do that.
11:27:42 <joco42> no ?
11:27:46 <joco42> oh no...
11:27:48 <Welkin> there are no types are runtime
11:27:49 <Welkin> lol
11:27:55 <andromeda-galaxy> (at least without unsafeCoerce or Data.Dynamic or something)
11:27:55 <THE_LORD> hello I cannot build certificate-1.3.9
11:28:07 <joco42> hmmm
11:28:20 <andromeda-galaxy> joco42: well, you can't set a = normalizeSvg, because they have different types
11:28:46 <andromeda-galaxy> because, that type for a is
11:28:54 <andromeda-galaxy> forall a. Num a => a -> <something>
11:29:01 <joco42> is there not type magic that would solve this ?
11:29:05 <andromeda-galaxy> so that says that the function stored in a shoud work *for any Num*
11:29:06 <ReinH> joco42: No, there is not.
11:29:07 <andromeda-galaxy> right?
11:29:15 <joco42> some magical pragma ?
11:29:17 <andromeda-galaxy> but normalizeSvg/getQuestion don't work for any Num
11:29:22 <ReinH> joco42: What you want to do is exactly what Haskell's type system is designed to prevent
11:29:25 <ReinH> So no, there is not a way to do it.
11:29:45 <andromeda-galaxy> joco42: can you just generalize normalizeSvg/getQuestion to work for any Num?
11:29:52 <ReinH> If you *could* do it, you would just be writing broken code
11:29:57 <joco42> ReinH:  then maybe I am not thinking in the correct way...
11:29:59 <ReinH> because it would be unsafe
11:30:08 <andromeda-galaxy> ReinH: there is ExistentialQuantification, but I'm pretty sure joco42 doesn't want that...
11:30:13 <andromeda-galaxy> (just for the sake of completeness)
11:30:17 <joco42> i want to do subtype polymorphism...
11:30:27 <ReinH> joco42: First of all, there are no subtypes.
11:30:34 <ReinH> Second of all, if there were, Int and Float would not be subtypes
11:30:36 <jmcarthur> joco42: Haskell's type system is designed not to be magical.
11:30:52 <jmcarthur> joco42: Subtyping is something that sounds great at first, but it really complicates type systems a lot.
11:30:55 <ReinH> Num is not a type. Instances of Num are not subtypes.
11:30:57 <joco42> subtypes of num
11:31:05 <jmcarthur> That's not to say it's always bad, just hard to make not crazy.
11:31:27 <andromeda-galaxy> ReinH: a 'type class' is just a way of saying 'here are some types that all satisfy that contract' --- it's more like an interface from OOP
11:31:39 <andromeda-galaxy> sorry, I meant to say joco42 there
11:31:40 <ReinH> andromeda-galaxy: Ok. But Num is not a type and instances of Num are not subtypes.
11:31:54 <ReinH> Ah.
11:32:21 <joco42> so what is this ExistentialQuantification?
11:32:34 <joco42> andromeda-galaxy:  maybe i want it ...
11:32:37 <joco42> :)
11:32:37 <andromeda-galaxy> joco42: sorry, I shouldn't have mentioned that...
11:32:43 <joco42> :)
11:32:59 <ski>   a :: exists a. (Num a,Read a) *> a -> Img -> [Rect] -> XMLString  -- i think could be what joco42 wants to express
11:33:02 <jmcarthur> ExistentialQuantification gives you a way to hide a type under a value constructor and make it appear as a totally new type upon pattern matching.
11:33:37 <joco42> this is interesting
11:33:58 <jmcarthur> Using ExistentialQuantification with type classes is a common antipattern designed to make Haskell code look more like OOP.
11:34:01 <andromeda-galaxy> joco42: by the way, do you understand why what you have doesn't work?
11:34:10 <ReinH> Existential quantification is a thing that won't help you here.
11:34:28 <ski> it gives you a way to express "there exists some type, and a value having a type mentioning this unknown type"
11:34:28 <joco42> andromeda-galaxy:  i don't really understand...
11:34:28 <andromeda-galaxy> jmcarthur: indeed it is, but ExistentialQuantification is *very occasionally* helpful for Haskelly code as well (e.g. dependent type singletons)
11:34:34 <ReinH> The problem isn't getting heterogeneous types *in*, it's making use of them once they're there.
11:34:41 <andromeda-galaxy> joco42: okay, so:
11:34:49 <jmcarthur> andromeda-galaxy: Yes, I like ExistentialQuantification. I was reacting to bringing it up in this specific context.
11:34:51 <ski> ReinH : are you sure they couldn't help ?
11:34:54 <ReinH> So if you added existential quantification you'd just defer the problem until later.
11:34:56 <ReinH> ski: Pretty sure.
11:34:59 <andromeda-galaxy> joco42: you're current code doesn't work because a has type forall a. Num a => a -> something
11:35:04 <ReinH> Always happy to be proven wrong though.
11:35:27 <andromeda-galaxy> so that says that I should be able to give the function stored in a a value of any type implementing the typeclass Num, and it should work
11:35:36 <ReinH> ski: you'd end up with an extentially quantified type that you couldn't *do* anything with.
11:35:36 <joco42> ReinH:  this defferning the problem later is a good point...
11:35:37 <andromeda-galaxy> but, normalizeSvg :: Int -> <something>
11:35:39 <jmcarthur> ski: Wouldn't your version be impossible to use?
11:36:02 <joco42> andromeda-galaxy:  ok...
11:36:04 <andromeda-galaxy> joco42: so, normalizeSvg *can't* be given *any* Num type --- only Int
11:36:12 <ski> to me it looks like `a' wants to pick one concrete type in one branch, and another one in the other branch. `a' being bound to a value whose type references this unknown type, known only to be in `Num' and `Read'
11:36:16 <andromeda-galaxy> joco42: (since itis :: Int -> <something>)
11:36:23 <ski> jmcarthur : hm ?
11:36:39 <ReinH> ski: Well, perhaps the Num instance could be used to do conversions, but then you could have taken a Num a anyway.
11:36:42 <jmcarthur> ski: What would be a legal first argument?
11:36:49 <joco42> andromeda-galaxy:  i think i understand
11:36:54 <joco42> thanks, for explaining
11:36:59 <ski> jmcarthur : of what ? `action' ?
11:37:30 <ReinH> joco42: what you probably want to do is make both functions start with Num a => a and then use the Num class to do some conversion within the funcitons.
11:37:35 <ReinH> *functions
11:37:37 <andromeda-galaxy> joco42: np
11:37:48 <jmcarthur> ski: Here is how I interpreted your notation, in real Haskell syntax:    data A = forall a. (Num a, Read a) => A (a -> Img -> [Rect] -> XMLString); a :: A
11:38:24 <jophish> What's the name of that proposed extension which allows one to do something like 'fmap @[]' to mean the fmap :: a -> b -> [a] -> [b]
11:38:27 <ski> jmcarthur : yes. or CPS
11:38:34 <jophish> explicit type annotations or something?
11:38:45 <ReinH> ski: I guess what I say is: anything you can do with existentials in this case, you can do without existentials.
11:38:47 <andromeda-galaxy> jophish: explicit type application?  I think it's supposed to be in GHC8
11:38:55 <jmcarthur> ski: Right, so say I want to apply that `a` function to something. What would be a legal type for the first argument?
11:39:08 <ski> ReinH : obviously you can, if you duplicate the application of `action'
11:39:26 <ReinH> ski: because when you introduce existentials, you constrain the consumer to only using the typeclass functions on the values that are existentially quantified. But then you could have just used a Num constraint without existential quantification.
11:39:26 <andromeda-galaxy> jophish: https://ghc.haskell.org/trac/ghc/ticket/5296
11:39:34 <ski> jmcarthur : `a' ?
11:39:38 <jmcarthur> ski: First I'd have to pattern match to access the function under the A constructor, but the first argument has a fresh type because it's an existential.
11:39:41 <joco42> ReinH:  its getting late and my sharpness is declining ... so , i should think about this again in the morning... thanks for the suggestion...
11:39:53 <jmcarthur> ski: So there is nothing I could have in hand that unifies with that type.
11:39:59 <jophish> ah, perfect. thanks andromeda-galaxy 
11:40:07 <andromeda-galaxy> jophish: np
11:40:09 <ski> jmcarthur : you'd try to apply `read' (or `reads' or ...) to the `String' inside `action', and then pass the `a' result of that to the function
11:40:14 <andromeda-galaxy> joco42: okay, hopefully my explanation amde sense...
11:40:26 <jmcarthur> ski: I think you are talking about defining the function, but I'm talking about using it.
11:40:40 <joco42> andromeda-galaxy:  yeah, probably i will try both ways, the existentials and ReinH's ways
11:40:40 <jmcarthur> Oh
11:40:50 <ReinH> joco42: I wouldn't use existentials for this. Absolutely not.
11:40:52 <jmcarthur> Nevermind, I see. The Read constraint gives you a way to construct an 'a'
11:40:53 <ski> jmcarthur : i'm talking about calling `action' with `a' as argument
11:41:10 <ReinH> But I suppose there's no harm in *trying* it.
11:41:47 <joco42> the problem is that read needs to know what to use...
11:41:48 * ski isn't sure it's worth it to use existentials here, either
11:41:55 <joco42> ok...
11:42:04 <andromeda-galaxy> joco42:I wasn't suggesting *using* existentials!
11:42:06 <ski> .. however, it seemed to me that that was what joco42 wanted to do
11:42:19 <andromeda-galaxy> joco42, ReinH: I just thought I'd mention them for completeness...
11:42:53 <joco42> i think there is a type information at runtime
11:42:55 <joco42> btw
11:42:59 <ski> conceptually, they seem to want `a' to be a pair of the selected type, and a function operating on it
11:43:11 <joco42> or , some kind of dictionary...
11:43:12 <ski> joco42 : no, there isn't
11:43:15 <joco42> for type classrs
11:43:21 <ski> yes, that's another thing
11:43:22 <joco42> being passed around 
11:43:24 <joco42> ahh
11:43:27 <joco42> ok
11:43:32 <joco42> implicitly
11:43:55 <andromeda-galaxy> ski: by the way, that's always bothered me---why can't GHC instantiate type classes @ compile time & replace calls with calls to the correct function instead of passing around dictionaries?
11:43:59 <ReinH> joco42: Yes, a dictionary is passed around, but that is *because* there are no types. So you need to already supply the information that could have been determined by the types.
11:44:12 <ski> if you have `foo :: forall a. a -> ..a..', then there's no way you can discover what the type `a' is at run-time
11:44:20 <ReinH> So while there is still type information, it is used to decide which dictionary to pass.
11:44:24 <jophish> andromeda-galaxy: I was under the impression that ghc does that a lot already
11:44:30 <ReinH> That way you don't need that type information any more at runtime.
11:44:42 <ski> andromeda-galaxy : polymorphic recursion. existentials, higher-rank types
11:44:59 <joco42> hmmm
11:45:20 <andromeda-galaxy> ski: that's true, does GHC eliminate them in some cases though?  jophish: I remember reading something once about how such-and-such technique was not advisable since it decreased performance due to dictionary passing
11:45:21 <dolio> Separate compilation.
11:45:21 <ggole> Full instantiation everywhere isn't necessarily a performance win anyway
11:45:29 <andromeda-galaxy> (without any weird type things that I could see)
11:45:35 <ggole> More of a program-sensitive tradeoff
11:45:39 <joco42> so maybe i need some kind of conversion...
11:45:50 <andromeda-galaxy> ggole: hmm, that makes sense... thanks!
11:45:59 <ReinH> @google haskell converting numbers
11:45:59 <lambdabot> https://wiki.haskell.org/Converting_numbers
11:46:02 <ReinH> joco42: ^
11:46:21 <dolio> andromeda-galaxy: It tries to do it when it's able. But it's not always possible.
11:46:27 * ski isn't sure why joco42 would need to convert numbers
11:46:34 <jmcarthur> andromeda-galaxy: GHC is very aggressive about inlining dictionaries.
11:46:59 <ReinH> ski: because they have a Num a and they want a Float or Int, respectively.
11:47:06 <andromeda-galaxy> dolio, jmcarthur: okay, that makes more sense---I just couldn't find any information on it apart from the GHC source (which I haven't tried to delve into yet)
11:47:12 <ski> ReinH : i don't see that
11:47:26 <ReinH> ski: Well, that's what the code is doing...
11:47:29 <ReinH> ski: What do you see?
11:47:32 <ski> afaics, then have a `String', and they want a `Float' alternatively an `Int'
11:47:36 <joco42> passing a float for "question" should be a runtime error
11:47:48 <joco42> or , bad input
11:48:05 <dolio> andromeda-galaxy: A quicker way to see is -ddump-simpl. If you write some Int specific code using overloaded operations, you'll likely see the int-specific stuff in the core.
11:48:13 <ReinH> I would probably use Either Float Int
11:48:25 <ReinH> Or, rather, Either Double Int
11:48:30 <ReinH> but is "5" a double or an int?
11:48:37 <andromeda-galaxy> dolio: I'll do that sometime, thanks for the suggestion...
11:48:42 <ski> ReinH : doesn't matter
11:48:42 <darkroom> hey guys I am trying to install idris using cabal, how do i fix this error its very amgious: http://lpaste.net/143978
11:48:56 <ski> ReinH : the previous word determines the type to try to read it as
11:49:08 <ReinH> ski: Ah. Yeah, I would use Either.
11:49:20 <ReinH> You have "either a double or an int", so just represent that explicitly.
11:49:24 <ReinH> And don't worry about existentials.
11:49:29 <ski> ReinH : and an ADT for more alternatives ?
11:49:38 <ReinH> ski: What alternatives?
11:49:41 <prsteele> Hello everyone, I have a question about the Vector package. What do I need to do to ensure that fusion happens? In particular, I can write an operation as either a map + a fold, or just a clever fold. The former is more readable, but without fusion the second might be faster
11:50:03 <andromeda-galaxy> ReinH: I believe that ski is talking about potentially adding more commands, and, therefore, more data types..
11:50:03 <ReinH> ski: if you have a solution using existentials, I'd love to see it.
11:50:07 <ski> ReinH : `"normalize"',`"question"' .. i imagine there could well be more alternatives to be added after this
11:50:25 <ReinH> I don't believe in "just in case" design.
11:50:45 <ReinH> Right now it's either a double or an int.
11:51:14 <ski> ReinH : the obvious and simply fix is to use the `A' type you wrote above. and to `case' on `a' before calling `action' (or `case' inside `action' instead, if preferred)
11:51:31 <joco42> what is really strange that this compiles fine... https://usercontent.irccloud-cdn.com/file/L1ILPGN9/Screen%20Shot%202015-10-26%20at%2020.50.39.png
11:51:31 <ReinH> ski: I didn't write `A' :)
11:51:34 <ski> it's a bit clunky, but i think it's the most faithful to the original (nonworking) code
11:51:45 <ski> ReinH : oh, sorry. jmcarthur did
11:51:45 <joco42> so why can i just not factor out the common logic ?
11:51:56 <joco42> it is just duplication....
11:52:10 <joco42> this looks really like some kind of limitation of the type system...
11:52:58 <joco42> i am really puzzled here...
11:53:12 <ski> joco42 : you can. with existentials
11:53:22 <joco42> if i have 10 commands then i need repeat that 10 times?
11:53:44 <joco42> ok, so that is the standard way to deal with this problem ?
11:53:44 <jmcarthur> You don't need existentials for this.
11:53:58 <ski> you can use rank-2 CPS as well
11:54:01 <joco42> jmcarthur:  so what is really going on here ? 
11:54:10 <joco42> aham!
11:54:14 <ski> (which i consider as an encoding of existentials, so same thing)
11:54:17 <joco42> rank-2 cps
11:54:24 <joco42> i see
11:55:14 <joco42> is this a common problem ?
11:55:14 <ski> i suppose a more interesting question would be whether/if what joco42 is sketching would scale to more commands
11:55:31 <jmcarthur> You could just define a function, couldn't you?   whatever f = svgIO (f $ read $ as !! 2) $ Fn $ as !! 1
11:55:31 * ski doesn't see a problem
11:55:51 <ski> jmcarthur : and call it once in each branch, yes
11:56:03 <ski> doesn't completely get rid of the duplication :)
11:56:05 <ReinH> ski, jmcarthur: Er, no. f couldn't unify.
11:56:22 <joco42> jmcarthur:  that function does not compile...
11:56:36 <ReinH> Since f would need to unify Float -> ... with Int -> ...
11:56:49 <jmcarthur> it needs to have a higher rank type
11:56:59 <ReinH> The issue is that a partially applied f has type Img -> [Rect] -> XMLString
11:57:21 <jmcarthur> It's just another encoding of the existential thing, just without having to use a constructor and match on it later.
11:57:37 <joco42> jmcarthur : https://usercontent.irccloud-cdn.com/file/oA5i5EKV/Screen%20Shot%202015-10-26%20at%2020.16.26.png
11:57:48 <ReinH> so you can say: let arg2 = as !! 2 in case command of "normalize" -> normalizeSvg arg2; "question" -> getQuestion arg2
11:57:51 <jmcarthur> Right. It needs a higher rank type, like I said.
11:57:53 <ReinH> because those types unify
11:59:09 <jmcarthur> joco42: What you just did isn't what I meant.
11:59:18 <joco42> jmcarthur:  ok...
11:59:35 <jmcarthur> joco42: I wish I had your code so I could type check what I'm about to write.
12:00:02 <joco42> :)
12:00:04 <platz> how do i defeat "Build status unknown" on hackage?
12:00:16 <joco42> jmcarthur:  lemme see
12:00:18 <ski> ReinH : yes. code duplication :)
12:00:40 <jmcarthur> joco42: first: action :: (forall a. (Num a, Read a) => a -> Img -> [Rect] -> XMLString) -> [String] -> IO ()
12:00:55 <joco42> jmcarthur:  if i can make a simple 5 liner demoing the problem
12:00:56 <ReinH> You can do this: http://lpaste.net/5707687816108965888
12:01:04 <jmcarthur> joco42: and your case needs to be:    case command of "normalize" -> action normalizeSvg; "question" -> action getQuestion
12:01:05 * ski doesn't follow jmcarthur
12:01:19 <ReinH> And actually, you can move the read into the functions and skip the duplication.
12:01:22 <jmcarthur> i fail
12:01:27 <jmcarthur> joco42: disregard everything i said
12:01:37 <jmcarthur> joco42: your type i think is fine
12:01:42 <jmcarthur> joco42: it's just the case
12:01:44 <ReinH> since then you have functions of type String -> ...
12:01:56 <joco42> ok...
12:01:56 <ReinH> and you just use read :: String -> Float in one and read :: String -> Int in the other
12:02:10 <ReinH> (or, perhaps, readMaybe to avoid runtime errors)
12:02:23 <ski> joco42 : i think you need `Read a' as well
12:02:27 <jmcarthur> joco42: so  case command of "normalize" -> action normalizeSvg; "question" -> action getQuestion  with your existing definition for action
12:02:37 <jmcarthur> joco42: and yeah, add the Read constraint to action
12:02:51 <joco42> lemme see
12:02:56 <ReinH> jmcarthur: what is action?
12:03:03 <jmcarthur> ReinH: https://usercontent.irccloud-cdn.com/file/oA5i5EKV/Screen%20Shot%202015-10-26%20at%2020.16.26.png
12:04:36 <joco42> nice !
12:04:39 <jophish> Cabal needs a way to set the default value of a flag to be "Is a particular package in the set of dependencies being build"
12:04:44 <quicksilver> if anyone was wndering about my question about running a Conduit without IO to produce a productive ('lazy') list
12:04:54 <quicksilver> I found an answer
12:04:59 <joco42> this is the solution to the puzzle, thanks to ReinH https://usercontent.irccloud-cdn.com/file/wBRdDbkm/Screen%20Shot%202015-10-26%20at%2021.04.03.png
12:05:03 <johnw> quicksilver: what was the answer?
12:05:04 <quicksilver> a sink in the Writer monad
12:05:08 <quicksilver> to collect the things
12:05:15 <quicksilver> and runWriter works fine (that is, lazily)
12:05:17 <jophish> that way, if (for example) QuickCheck isn't being built, then I can forego my dependency on it, and avoid compiling instances
12:05:28 <hexagoxel> jophish: and then make the build-depend depend on the flag!
12:05:38 <jophish> hexagoxel: exactly
12:06:11 <jophish> if it used this, packages like `lens` could avoid pulling in the kitchen sink
12:06:14 <ski> joco42 : but that has code duplication :(
12:06:24 <joco42> ski :)
12:06:55 <joco42> ski:  hmmm... a tiny little bit ....
12:07:10 <ski> if you're ok with the code duplication that's left there, then that's probably the nicest solution (cheers ReinH)
12:07:20 <ReinH> Yeah. I traded that off against the complexity added by the other solutions ;)
12:07:30 <ReinH> ski: :)
12:07:47 <ski> joco42 : if you'd like to, i could sketch the existential quantification solutions
12:07:52 <joco42> yeah... probably this is sort of ... still less letters... than with existentials...
12:08:04 <joco42> ski... that would be interesting :)
12:08:17 <ski> joco42 : perhaps in #haskell-overflow, though ?
12:08:47 <joco42> overflow?
12:08:49 <joco42> sure
12:08:53 <ReinH> ski: For me, the problem with duplication is that it introduces more places to make mistakes / have bugs. I don't think that's the case here, so I don't mind the duplication. YMMV ofc.
12:09:06 <jophish> hexagoxel: just found this: https://mail.haskell.org/pipermail/libraries/2005-July/004133.html
12:09:10 <jophish> not read it yet
12:09:50 <ski> ReinH : i would probably go for your solution in this case. however, since the OP asked about removing code duplication ..
12:10:30 <ReinH> ski: I'm interested to see how existentials solve this. There won't always be a clean solution to this sort of problem with them, I think.
12:10:45 <jophish> hmm, not much there
12:12:49 <hexagoxel> jophish: i meant the cycle in that logic :p
12:13:04 <jmcarthur> my solution should have been something like this (may need -XNoMonoLocalBinds or somesuch):  mainJM = do { (command : arg : _) <- getArgs; let { action f = svgIO (f (read arg)) (Fn command) }; case command of { "normalize" -> action normalizeSvg; "question" -> action getQuestion }
12:13:43 <ski> jmcarthur : yes. which doesn't require a rank-2 `action', though
12:13:57 <ski> (and there's still a bit of code duplication ;/)
12:14:15 <hexagoxel> jophish: depending on the "set of dependencies being build" is strange. asking "what is potentially available" might be better, but equally hard to determine.
12:14:40 <hexagoxel> jophish: but there _are_ conditions that indeed make sense (os/arch/whatever based)
12:14:45 <ReinH> ski: at least you can get the code duplication down to a single character if you want ;)
12:15:28 <jophish> hexagoxel: I'm presuming that to enable finding a fixed point in this dependency resolution, packages default to not being depended upon
12:15:40 <ReinH> Another option is normalizeSvg' = normalizeSvg . read and getQuestion' = getQuestion . read
12:16:54 <ReinH> http://lpaste.net/5707687816108965888#a1539981732529307648
12:17:53 <ski> yes
12:18:21 <ReinH> ski: That goes a bit further towards removing duplication
12:18:54 * ski notes `read' duplication isn't removed, only moved ;)
12:19:03 <andromeda-galaxy> ReinH, ski, jmcarthur, joco42: http://lpaste.net/143981
12:19:06 <ReinH> ski: but arg duplication is removed, so "a bit further" :)
12:19:08 <prsteele> what is the standard approach for dealing with Maybe results when you can guarantee that only Just values come out? It seems silly to propagate Maybe values out when we can do so
12:19:30 <andromeda-galaxy> ReinH, ski, jmcarthur, joco42: my crack at ExistentialQuantification
12:19:46 <joco42> :)
12:19:50 <monochrom> read duplication cannot be removed. it is the same phenomenon as [show 1, show True, show 'x']. it cannot be map show [1, True, 'x']
12:19:54 <joco42> andromeda-galaxy: 
12:19:56 <joco42> :)
12:19:59 <ReinH> monochrom: +1
12:20:12 <ReinH> monochrom: Well it can, via existential quantification, right?
12:20:20 <andromeda-galaxy> joco42: thanks!
12:20:29 <ReinH> it can be map show (Showable 1, Showable True, Showable 'x')
12:20:40 <ReinH> Which isn't exactly "less duplication".
12:20:48 <monochrom> existential quantification translates show duplication to Showable duplication
12:20:48 <ski> monochrom : the point was that it can. at least in this case
12:20:51 <Zemyla> Hmm. I think I've figured out how to fold a free monad with hyperfunctions, which should let you fuse and zip free monads.
12:20:54 <ReinH> monochrom: yep
12:20:55 <andromeda-galaxy> ReinH, monochrom: exactly
12:21:37 <monochrom> ski: how?
12:21:39 <ReinH> zomg: orly
12:21:42 <andromeda-galaxy> joco42, ReinH: in the ExistentialQuantification example that I just posted, it's basically just replacing action frm jmcarthur's solution with Cmd & the later call to action
12:21:43 <ReinH> er
12:21:43 <phadej> the problem is that one cannot really write [1, True, 'x']
12:21:46 <ReinH> Zemyla: orly?
12:21:48 <phadej> or actually can, but not direcly
12:22:00 <andromeda-galaxy> joco42, ReinH: so, it adds a language extension & a bunch of machinery for something about the same length
12:22:13 <ReinH> andromeda-galaxy: Right. This is why I was saying that existential quantification isn't less complex than the duplication in mine ;)
12:22:34 <ReinH> Zemyla: please to be writing your paper now.
12:22:57 <andromeda-galaxy> ReinH: right, that's why I suggested that joco42 not bother with it (I just wanted to mention that there's technically a way to do what he wanted, but doing it differently is probably better)...
12:23:44 <Zemyla> ReinH: Yeah. The type of the fold is FreeH f a = FreeH { runFreeH :: forall b c. (a -> c) -> (f b -> c) -> c }.
12:23:48 <joco42> andromeda-galaxy:  does that lpaste compile ?
12:23:53 <monochrom> there is a more fundamental reason than [1, True, 'x'] being illegal.
12:23:55 <ski> monochrom : this wasn't a case of a homogenous data structure with several elements of differing types but in a common type class. this was a case of alternatively selecting one of several values of different types, but all matching the same abstract existential interface (with typeclass)
12:24:14 <andromeda-galaxy> joco42:it should...
12:24:20 <joco42> http://lpaste.net/143981
12:24:23 <monochrom> at some point you have to say show_Integer, show_Bool, and show_Char.
12:25:08 <andromeda-galaxy> joco42: what about it?  the red bar on the lpaste is just complaining about 'if True'
12:25:09 <Zemyla> Wait, no. It should end with -> Hyper b c.
12:25:14 <andromeda-galaxy> (that's just there for demo purposes)
12:25:18 <joco42> andromeda-galaxy:  yes it does :)
12:25:50 <andromeda-galaxy> joco42: okay, great!  Do you understand why we were saying that it's probably better to just do the action/read way?  About the same amount of duplication + fewer extensions, etc.
12:25:53 <joco42> existential compiles https://usercontent.irccloud-cdn.com/file/ZhYBk0kF/Screen%20Shot%202015-10-26%20at%2021.25.09.png
12:26:55 <monochrom> no, nevermind, "triple_map show (1, True, 'x')" can be done, triple_map just needs a rank-2 type
12:27:07 <joco42> andromeda-galaxy:  not really, i guess i need to go over the existential solution tomorrow, after a good night sleep.... and see how it compares with ReinH's solution
12:27:16 <andromeda-galaxy> joco42: okay
12:27:25 <joco42> many thanks
12:27:27 <andromeda-galaxy> joco42: if you take a quick look at the existential solution, though
12:27:42 <andromeda-galaxy> you'll see that each branch of the if/case/whatever still ends up looking like 'Cmd fnctn'
12:27:48 <utdemir> Hey. Does anyone know why "servant-js" isn't on hackage. Its git repository looks like it's pretty mature: https://github.com/haskell-servant/servant/tree/master/servant-js
12:27:59 <andromeda-galaxy> joco42: which isn't much better than 'fnctn readArg' or 'action fnctn'
12:28:01 <jmcarthur> ski: yeah, my version duplicates in the same place yours would, except yours would be a constructor instead of a functor
12:28:03 <jmcarthur> *function
12:28:31 <andromeda-galaxy> jmcarthur: did you see my sketch of existentials? I think that it's roughly what you were talking about...
12:28:37 <ski> jmcarthur : fair point
12:28:39 <andromeda-galaxy> joco42: you're welcome
12:29:18 <joco42> hmmm.... andromeda-galaxy  so that is the same amount of code duplication...
12:29:20 <joco42> sort of
12:29:24 <andromeda-galaxy> right
12:29:25 <jmcarthur> andromeda-galaxy: Yup, that seems about what I expected.
12:29:32 <andromeda-galaxy> jmcarthur: great!
12:30:04 <andromeda-galaxy> joco42: and the existential way requires the ExistentialQuantification language extension, the extra 'data Cmd' declaration, and the pattern match in runCmd
12:30:10 <jmcarthur> Also, my version doesn't require NoMonoLocalBinds if you give the function an explicit type signature.
12:30:19 <alpounet> utdemir: because it's not released yet
12:30:25 <alpounet> the master branch in the repo is "the upcoming release"
12:30:32 <andromeda-galaxy> joco42: so for this use case, at least, the other ways are probably "better"...
12:31:05 <alpounet> utdemir: a less nice version of it is available as "servant-jquery" on hackage, but as the name suggests, it's the predecessor of servant-js and only generates jQuery-based JS code
12:31:15 <joco42> andromeda-galaxy:  yeah.... but it is nice to know that existentials there if someone needs it... 
12:31:17 <alpounet> whereas servant-js lets you pick between several different libraries and what not
12:31:23 <andromeda-galaxy> joco42: indeed, that's why I mentioned them
12:31:28 <joco42> *are there
12:31:30 <lpaste> Zemyla pasted “Free Monad Hyperfold for ReinH” at http://lpaste.net/143984
12:31:36 <andromeda-galaxy> joco42: hopefully, you'll now be able to use them if/when they really are a good idea...
12:31:38 <utdemir> alpounet: Yes, I'm specifically interested in vanilla js implementation.
12:31:57 <utdemir> alpounet: I'll fetch from git then, thank you!
12:32:09 <joco42> andromeda-galaxy:  yeah... if something similar comes up... and i cannot solve it in the ReinH  way....
12:32:19 <alpounet> utdemir: quite a few things are changing in the upcoming release, it might be harder to use because the tutorial hasn't been updated for it yet
12:32:28 <Zemyla> I've tested on a couple of structures that fromFreeH . toFreeH = id, but I haven't proved it.
12:32:43 <hackal> Hello, please may you help me debug the error message I am getting? http://lpaste.net/1621863261097951232 I do not understand why it is even mentioning Char when I do not use it
12:32:51 <andromeda-galaxy> joco42: anyway, hopefully that was useful...
12:33:17 <andromeda-galaxy> hackal: String = [Char]
12:33:34 <joco42> joco42:  yeah. many thanks, soon off to sleep
12:33:39 <andromeda-galaxy> hackal: [showEntry x | x <- xs] :: [String]
12:34:24 <andromeda-galaxy> hackal: since showEntry produces a string (= [Char]) and it's in a list comprehension
12:34:33 <jmcarthur> alpounet: When do you estimate the next release will be?
12:34:57 <hackal> Oh, list comprehensions returns list. my bad
12:38:07 <Zemyla> But yeah, BRB.
12:38:13 <utdemir> alpounet: Well, I'll just brute-force the combinators until it typechecks then :). I really want to use Servant, it'll solve many problems of us :)
12:38:56 <alpounet> utdemir: oh did you ask another question? i've missed it 
12:39:18 <jmcarthur> alpounet: utdemir didn't, but I did. :)
12:39:33 <alpounet> would you mind repeating it? sorry
12:40:40 <jmcarthur> alpounet: When do you estimate the next release will be?
12:41:49 <ReinH> utdemir: then you should use Servant :)
12:41:52 <alpounet> jmcarthur: in the upcoming weeks I think? we basically have to finalize a PR or two, that are ready, and then update the tutorial/haddocks/etc, and write announcement
12:42:40 <alpounet> i might enter a jobhunt phase somewhat soon so i'd probably be able to prepare a big update to the tutorial
12:42:43 <jmcarthur> Okay. That seems soon enough that it's worth me just getting started and then updating my code.
12:55:25 * hackagebot c2hs 0.26.2 - C->Haskell FFI tool that gives some cross-language type safety  https://hackage.haskell.org/package/c2hs-0.26.2 (IanRoss)
13:00:10 <lpaste> dmwit pasted “Why is vector hidden?” at http://lpaste.net/143987
13:01:35 <dmwit> Why does ghci think vector-0.10.12.3 is hidden even after I run `ghc-pkg expose vector-0.10.12.3`?
13:14:31 <quicksilver> johnw: I can't work out how to work out if uses are left-associated as you'd ideally hope but at least it works :)
13:15:53 <quicksilver> oh yes I can. Just make a special Monoid which shows me.
13:18:58 <c_wraith> A lying monoid? 
13:19:24 <jaj> Hi, I have a program that reads a very long file (some million lines), and sends it over the network. I use lazy bytestrings and I do some line by line modifications. The time until first output is very long so I think the file is first read completely before it begins sending. Is there a way to find out where the laziness got lost?
13:21:06 <meoblast001> hi. with ghc-mod i tried manually running the `type` command and got this: <command line>: cannot satisfy -package-id HDBC-2.4.0.1-5d3721a95fd5485fd16d93358ee84246
13:21:20 <meoblast001> how do i get GHC to recognises packages installed by cabal?
13:21:26 <meoblast001> ghc-mod i mean
13:24:48 <meoblast001> i just used --with-cabal and now i get: cabal-helper-wrapper: Installing a private copy of Cabal because we couldn't find the right version in your global/user package-db
13:24:51 <meoblast001> should i be concerned?
13:26:31 <divVerent> @pl \ f x -> f x x
13:26:32 <lambdabot> join
13:26:34 <divVerent> oh right
13:28:15 <lpaste> Zemyla revised “Free Monad Hyperfold for ReinH”: “No title” at http://lpaste.net/143984
13:28:45 <Zemyla> There we are. Now it has a Monad, MonadTrans, and MonadFree instances.
13:29:53 <divVerent> @pl \ x ->  (join (asTypeOf.read.reverse.show)) x
13:29:53 <lambdabot> asTypeOf =<< read . reverse . show
13:30:25 <divVerent> I don't get why I can't just use join$asTypeOf.read.reverse.show
13:31:19 <ski> @type join (asTypeOf . read . reverse . show)
13:31:22 <lambdabot> (Read a, Show a) => a -> a
13:32:39 <divVerent> ski: right... but this fails:
13:32:41 <divVerent> Prelude Control.Monad> let f = join (asTypeOf . read . reverse . show)
13:32:43 <divVerent> Prelude Control.Monad> :t f
13:32:45 <divVerent> f :: () -> ()
13:33:05 <arkeet> that's because monomorphism restriction + ghci extended defaulting
13:33:22 <divVerent> and the =<< hack from @pl also fails
13:33:28 <arkeet> same reason
13:33:34 <divVerent> sure, but can we fix @pl? :)
13:33:35 <ski> DMR as arkeet said, yes
13:33:39 <arkeet> no, fix your ghci instead.
13:33:45 <ski> fix ?
13:33:51 <arkeet> well,
13:33:57 <arkeet> disable the monomorphism restriction, or provide a type signature
13:33:59 <divVerent> well, clearly the two expressions aren't the same in all context
13:34:10 <arkeet> @where dmr
13:34:10 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
13:34:18 <Zemyla> > fix ghci
13:34:20 <lambdabot>  Not in scope: ‘ghci’
13:34:26 <Zemyla> Damn, can't do it.
13:34:28 <ski> @ghci
13:34:28 <lambdabot> Pattern bindings (except simple variables) not allowed in instance declarations
13:34:43 <ski> divVerent : which context ?
13:34:43 <Zemyla> Anyways, BRB.
13:34:45 <arkeet> hm, wonder what that got corrected to.
13:36:24 <divVerent> but yes... I remember the workaround for DMR is using lambda instead of let
13:36:40 <ski> divVerent : .. or, just write an explicit type signature ?
13:36:51 <divVerent> it's one of the cases where let a = b in c is not the same as (\ a -> c) b
13:37:14 <divVerent> sure, I still just find this "feature" annoying... as in most other senses let expressions are the same as lambda
13:37:44 * ski isn't sure how that would help
13:37:48 <divVerent> but of course, if I were seriously wanting to use my example above, I'd want a type signature anyway
13:44:59 <quicksilver> c_wraith: yes, a lying monoind which exposes its associativity
13:49:29 <jophish> What do people prefer: `foo = join bar` or `foo x = bar x x`?
13:49:38 <jophish> both have their pluses and minuses
13:54:40 <glguy> jophish: I'd advise avoiding reader monad cleverness outside of IRC demo code
13:54:45 <divVerent> jophish: personally: bar x x, as join is normally a monad thing
13:55:49 <divVerent> in fact, my above code only needed this hack so it works without a type declaration... if you REALLY wanted to reverse numbers that way, you'd rather do f :: (Read a, Show a) => a -> a; f = read.reverse.show (but no, you don't want to use something that errors on 1.2e+99)
13:56:11 <jophish> glguy: yeah, I've gone with `bar x x` but if the mantra of "code shouldn't have any repetitions" is taken to the extreme, then using join is perhaps preferable
13:56:59 <glguy> If you blindly follow "mantras" you'll end up with bad code
13:57:44 <jophish> of course :)
13:58:52 <divVerent> haha, here's something someone just posted to me:
13:59:08 <divVerent> foo ... | condition = True
13:59:13 <divVerent>         | otherwise = false
13:59:25 <divVerent> so yes, you can do (a==b?true:false) in Haskell :)
14:00:48 <monochrom> I disbelieve in "code shouldn't have reptitions". not even as a suggestion.
14:01:06 <monochrom> I only believe in "there is a reason why I write this code"
14:01:07 <pavonia> divVerent: Maybe I'm missing context but Haskell has "if ... then .. else ..."
14:01:15 <divVerent> sure
14:01:21 <divVerent> but if ... then true else false looks too obvious :)
14:01:24 <c_wraith> divVerent: I tried to convince someone to reevaluate (== True) once. It didn't go over well. 
14:02:09 <arkeet> case b of { True -> ...; False -> ... }
14:03:02 <divVerent> by following mantras, I recently wrote this mess:
14:03:03 <Darwin226> Hey guys. I'm using HSpec and I'm wondering if anyone knows how to say that a function f should behave exactly as the function g, meaning it also throws an error if g throws an error
14:03:04 <c_wraith> I actually prefer case over a boolean to if/then/else
14:03:04 <divVerent>     let result = F.foldr (min . fieldA) (fieldB input) (fieldC input)            
14:03:23 <Darwin226> those functions are pure, also I'm using quickcheck in conjunction
14:03:25 <divVerent> a month later, I was trying to guess and figure out which one was the Maybe and what it's doing if it's Just
14:04:15 <divVerent>     let result = case (fieldC input) of { Nothing -> fieldB input; Just x -> min (fieldA x) (fieldB input) }
14:04:22 <divVerent> would have been longer, but way more readable
14:04:24 <c_wraith> divVerent: should have used foldMap instead of foldr. :) 
14:04:36 <divVerent> how would that have looked then? :)
14:04:36 <ski> s/\(fieldC input\)/fieldC input/
14:04:45 <monochrom> Darwin226: I don't think that is testable (or even spec-able) unless you drag in IO
14:05:07 <divVerent> ski: right
14:05:13 <divVerent> of course, the real code also would have used newlines
14:05:13 <Darwin226> monochrom: Well, it's tested in IO
14:05:21 <c_wraith> divVerent: foldMap has fewer args. Also, it can be quite a lot faster sometimes. 
14:05:33 <Darwin226> monochrom: There already are combinators like `shouldThrow`
14:05:48 <divVerent> c_wraith: yes, but I am currently trying to figure out what's the Monoid and what's the Traversable
14:05:50 <divVerent> evil one, as Maybe is both
14:06:24 <divVerent> (although I'd guess it must be the Traversable, so what's the Monoid then... probably something that collects the min of N?)
14:06:29 <monochrom> ok, then use shouldThrow. I don't know quickcheck or hspec.
14:06:56 <c_wraith> divVerent: eh. Ones a function, the other is a Foldable. Usually you can tell them apart. 
14:08:55 <divVerent> using Data.Semigroup, probably something like   getMin $ foldMap Min someMaybe (Min originalValue)
14:09:03 <divVerent> doesn't look much better (and I don't have Data.Semigroup installed anyway)
14:09:52 <c_wraith> foldMap only takes two args..
14:10:33 <divVerent> right
14:10:40 <divVerent> and yes, I never managed to use foldMap... you see it
14:12:38 <hexagoxel> why does my program deadlock when i run with -N1, but not with -N2 ?
14:14:04 <Taneb> hexagoxel, it could be that a thread isn't ever yielding
14:14:32 <hexagoxel> any kind of blocking that is not "blocking" in ghc sense, i guess.
14:18:02 <divVerent> appEndo (foldMap (Endo . min) someMaybe) originalValue -- even less readable, but somehow looks like there might be a better way to write this idea
14:20:18 <c_wraith> :t maybe id min
14:20:19 <lambdabot> Ord a => Maybe a -> a -> a
14:20:42 <divVerent> Ah, right.
14:21:43 <NightRa> Is it possible to use Parsec or Attoparsec to parse in a streaming way from stdin?
14:21:56 <tdammers> yes, sort of...
14:21:59 <tdammers> using lazy IO
14:22:18 <tdammers> getContents >>= parseStuff
14:22:31 <pyon> Pattern guards overlap with `where` cluases in their use cases, right?
14:22:42 <pyon> Errr, more precisely, pattern guards subsume `where`, right?
14:23:14 <c_wraith> pyon: not exactly, since where clauses scope over multiple guards. 
14:23:24 <pyon> OH.
14:23:35 <NightRa> tdammers: Thanks.
14:24:04 <luite> for attoparsec you really don't need lazy IO, it returns a continuation if the parser needs more input
14:24:20 <pyon> There's no way to make guards nest, right?
14:24:58 <NightRa> luite: Can you give an example usage?
14:26:14 <ski> pyon : i don't think so
14:27:58 <luite> NightRa: see the parseWith function in attoparsec, you'd probably use that with hGetSome and stdin
14:28:10 <NightRa> luite: 👍
14:28:34 <luite> hm, my font doesn't have that glyph i think
14:28:49 <luite> unless it's a question mark :)
14:29:14 <NightRa> luite: It's a thumbs up :)
14:30:22 <paldepind1> pyon, as far as I understand you can use guards whenever you declare a named function.
14:30:49 <ski> paldepind1 : doesn't have to be a function
14:31:01 <pyon> paldepind1: You can use them when defining non-functions, or in `case ... of ...` blocks.
14:31:27 <paldepind1> What is a non-function?
14:31:36 <luite> NightRa: you may need hSetBuffering
14:31:38 <pyon> paldepind1: Things that... aren't functions.
14:32:12 <paldepind1> How do you use guards when defining things that aren't functions?
14:32:31 <pyon> paldepind1: foo | bar = ... | qux = ...
14:32:32 <ski> paldepind1 : like you always use them
14:32:59 <paldepind1> I've never though of that as a guard.
14:33:05 <ski> > let foo | pi > 3 = "yes" | otherwise = "no" in foo
14:33:07 <lambdabot>  "yes"
14:33:17 <pyon> paldepind1: `bar` and `qux` are guards there.
14:33:25 <ski> what else would it be ?
14:34:42 <paldepind1> ski, I though it was special syntax for defining a type.
14:35:03 <monochrom> oh, heh
14:35:17 <ski> oh. that's another thing
14:35:26 <ski> (also list comprehensions)
14:35:55 <pyon> Anyway, I guess what I really want is something akin to case fall-through in C. If the computation in an arm fails, try the next arm.
14:36:41 <ski> pyon : that much was obvious
14:37:20 <pyon> Or even “fail, and when retrying, pretend the thing being pattern-matched on was <something different than what was originally pattern-matched on>”.
14:37:43 <ski> WLOG ?
14:43:55 <paldepind1> Hm. So something like `foo | pi > 3 = "yes" | otherwise = "no"` is an expression that evaluates to a string.
14:44:18 <paldepind1> I always had the impression that guards was somehow connected to a function definition.
14:44:32 <pyon> paldepind1: It isn't an expression.
14:44:34 <ski> no, it's not an expression. it's a declaration
14:44:34 <pyon> paldepind1: It's a definition.
14:44:36 <monochrom> not an expression. a binding (aka definition). because it contains =
14:46:40 <monochrom> then again, "contains =" is not a precise condition
14:46:44 <paldepind1> Ok. So guards can only be used when introducing a named value?
14:47:08 <ski> guards can be used with definitions, and with branches in `case'-expressions
14:47:08 <monochrom> no, expressions can too, but you haven't written an expression that does
14:47:41 <c_wraith> Guards can be used with pattern matches of any sort. Even vacuous ones. 
14:47:51 <monochrom> if you turn on the extension MultiWayIf, you can write this expression: if | pi > 3 -> "yes" | otherwise = "no"
14:47:54 <ski> > (\() | True -> ()) ()
14:47:55 <lambdabot>  <hint>:1:6: parse error on input ‘|’
14:48:09 <monochrom> err, if | pi > 3 -> "yes" | otherwise -> "no"
14:48:27 <c_wraith> > let 1 == 2 | False in () 
14:48:28 <lambdabot>  <hint>:1:20: parse error on input ‘in’
14:48:46 <c_wraith> Oops, forgot the body
14:48:50 <ski> > case () of () | pi > 3 -> "yes | otherwise -> "no"
14:48:51 <lambdabot>  <hint>:1:51:
14:48:52 <lambdabot>      lexical error in string/character literal at end of input
14:49:04 <ski> oops
14:49:29 <pyon> > case () of { _ | pi > 3 -> "yes" | otherwise -> "no" }
14:49:31 <lambdabot>  "yes"
14:50:02 <c_wraith> > let 1 | False = 7 in () 
14:50:04 <lambdabot>  ()
14:51:57 <c_wraith> Personally, I think the spec should disallow that sillyness
14:52:14 <c_wraith> But it doesn't! 
14:53:08 <ski> > let !1 | False = 7 in ()
14:53:09 <lambdabot>  *Exception: <interactive>:3:5-18: Non-exhaustive guards in
14:53:10 <paldepind1> I've never been told that about guards O.o
14:55:36 <c_wraith> > (\x | True -> False) () 
14:55:38 <lambdabot>  <hint>:1:5: parse error on input ‘|’
14:56:08 <c_wraith> Hah! OK, they aren't allowed *everywhere* patterns are. 
14:57:03 <ski> c_wraith : as already noted :)
14:57:16 <c_wraith> Haskell's grammar has some ugly corners. :) 
14:58:12 <ski> in SML, the function abstraction expressions are multi-way to begin with
14:58:34 <ski> (`case' desugars to a function application of a function abstraction)
15:08:23 <Hamstak> Does GHCI typically only allocate 1MB?
15:09:25 <c_wraith> Maybe at startup. It can certainly use much more. 
15:10:40 <Hamstak> I'm having issues making lists bigger than 1MB
15:10:45 <Hamstak> specifically
15:12:23 <quicksilver> what kind of trouble, Hamstak ? how does the problem present itself? is there an error message?
15:12:43 <quicksilver> > length [1..1000000]
15:12:45 <lambdabot>  1000000
15:12:53 <quicksilver> ^^ that's a fair bit more than 1MB of memory
15:13:29 <c_wraith> To be fair.. That's not all resident concurrently. 
15:14:07 <Zekka> > reverse [1..1000000]
15:14:09 <lambdabot>  [1000000,999999,999998,999997,999996,999995,999994,999993,999992,999991,9999...
15:14:18 <Hamstak> <interactive>: out of memory (requested 1048576 bytes) is what it gives me
15:14:21 <Zekka> that probably can't be gced away
15:14:38 <c_wraith> Zekka: correct, that is all resident at once. 
15:15:43 <quicksilver> that' sjust saying it's asking for 1MB at this moment
15:15:49 <quicksilver> not that 1MB is the total it has asked for
15:16:00 <quicksilver> you might have used a lot more
15:16:02 <Zekka> Yeah, try just one of the examples we did
15:16:20 <Zekka> that is, loading ghci from scratch
15:17:21 <quicksilver> well don't type "reverse [1..1000000]" in ghci, that will take some time to display its answer :)
15:17:33 <quicksilver> take 5 $ reverse [1..1000000]
15:17:41 <quicksilver> would be safer (and still prove the same thing)
15:17:45 <Zekka> You could take the length of the resulting string if you wanted to be sure the whole list would be evaluated
15:17:58 <Zekka> (including the numbers, that is)
15:19:30 <ww> > sum [1..10000000]
15:19:36 <lambdabot>  mueval-core: Time limit exceeded
15:19:42 <ww> > sum [1..1000000]
15:19:46 <lambdabot>  *Exception: stack overflow
15:19:51 <ww> > sum [1..100000]
15:19:52 <lambdabot>  5000050000
15:20:27 <kadoban> quicksilver: It's conceptually not all that clear that 'take 5 $ reverse [1..1000000]' needs the whole list though. Wouldn't it be quite possible for ghci to realize it doesn't?
15:21:11 <quicksilver> many things are possible, kadoban, but according to my knowledge of ghc's evaluation model it won't realize that.
15:25:09 <c_wraith> That knowledge is just a rewrite rule away. :) 
15:25:38 <nobos> @pf remapRows cells = concat $ zipWith (\i cls -> map (remapCell i) cls) [0..] $ filter (not . null) cells
15:25:39 <lambdabot> Maybe you meant: pl bf
15:25:43 * c_wraith imagines a reverse/enumFromTo rule
15:25:48 <nobos> @pl remapRows cells = concat $ zipWith (\i cls -> map (remapCell i) cls) [0..] $ filter (not . null) cells
15:25:48 <lambdabot> remapRows = join . zipWith (map . remapCell) [0..] . filter (not . null)
15:27:03 <quicksilver> c_wraith: ghci doesn't do rewrites ;)
15:27:18 <c_wraith> Hmm. Good point. 
15:32:27 <Hamstak> OK, so yeah my function was using up all 3.5 GiB of memory, thanks prime sieves
15:32:45 <Hamstak> However, I thought I was lazily generating primes, but apparently that isn't the case
15:34:11 <koala_man> laziness is hard to reason about
15:36:00 <jmcarthur> Well, laziness is hard to reason about until you get used to it, at least.
15:38:23 <bsmt> but how do you do that when you're lazy?
15:39:46 <ReinH> nobos: whatcha doin?
15:39:56 <dmwit> jaj: Did you ever get an answer?
15:41:08 <ARM9> I hear ghci works on arm now, but it's not in my repos (debian stable super fun time), any repository that supplies a more up to date haskell-platform?
15:41:41 <dmwit> jaj: One thing you might try is to cook up some custom lazy bytestrings of the form `fromChunks (foo:bar:baz:undefined)`. By putting `undefined` at different places relative to the rest of your lazy ByteString, you can see where your consumer first dies.
15:41:53 <dmwit> :t BS.fromChunks
15:41:55 <lambdabot>     Not in scope: ‘BS.fromChunks’
15:41:55 <lambdabot>     Perhaps you meant one of these:
15:41:55 <lambdabot>       ‘BSL.fromChunks’ (imported from Data.ByteString.Lazy),
15:43:25 <nobos> ReinH: I was checking to see if I could make my tetris game a bit nicer
15:43:34 <dmwit> > BSL.takeWhile (<128) . BSL.fromChunks $ ("abc":"\x129":undefined)
15:43:35 <lambdabot>      Couldn't match expected type ‘BSC.ByteString’
15:43:35 <lambdabot>                  with actual type ‘[Char]’
15:43:35 <lambdabot>      In the first argument of ‘(:)’, namely ‘"abc"’
15:43:42 <nobos> ReinH: FTR: https://github.com/ToJans/learninghaskell/blob/master/0005%20Tetris/src/Game.hs
15:43:51 <dmwit> > BSL.takeWhile (<128) . BSL.fromChunks . map fromString $ ("abc":"\x129":undefined)
15:43:52 <lambdabot>  "abc)*Exception: Prelude.undefined
15:44:19 <dmwit> :t BSC.pack
15:44:20 <lambdabot> String -> BSC.ByteString
15:45:02 <dmwit> Oh, I see my mistake.
15:45:09 <dmwit> > BSL.takeWhile (<128) . BSL.fromChunks . map fromString $ ("abc":"\129":undefined)
15:45:10 <lambdabot>  "abc"
15:45:33 <dmwit> So that's correctly lazy. Whereas it's not lazy enough if you leave out the "\129":
15:45:37 <dmwit> > BSL.takeWhile (<128) . BSL.fromChunks . map fromString $ ("abc":undefined)
15:45:38 <lambdabot>  "abc*Exception: Prelude.undefined
15:46:15 <dmwit> jaj: So that can be a way to cook up some examples by hand and see if your whole producer-consumer chain is "lazy enough" on them.
15:47:47 <dmwit> Oh, and there's another difference between the lazy and strict functions which you can observe in this way: if it's "lazy enough" it will produce some output before it dies. Compare:
15:48:12 <dmwit> > BSC.takeWhile (<128) . BSC.pack $ ('a':'b':'c':undefined) -- dies before producing any output
15:48:13 <lambdabot>      No instance for (Num Char) arising from the literal ‘128’
15:48:13 <lambdabot>      In the second argument of ‘(<)’, namely ‘128’
15:48:13 <lambdabot>      In the first argument of ‘BSC.takeWhile’, namely ‘(< 128)’
15:48:28 <dmwit> > BSC.takeWhile (<128) . fromString $ ('a':'b':'c':undefined) -- dies before producing any output
15:48:30 <lambdabot>      No instance for (Num Char) arising from the literal ‘128’
15:48:30 <lambdabot>      In the second argument of ‘(<)’, namely ‘128’
15:48:30 <lambdabot>      In the first argument of ‘BSC.takeWhile’, namely ‘(< 128)’
15:48:46 <dmwit> ugh
15:49:05 <dmwit> Anyway, take my word for it: the strict version dies before producing output. =P
15:49:14 <Hijiri> > BSC.takeWhile (\c -> ord c < 128) . BSC.pack $ ('a':'b':'c':undefined)
15:49:15 <lambdabot>  "*Exception: Prelude.undefined
15:50:38 <EvanR> that is interesting that a difference between lazy and strict would involve output
15:50:55 <EvanR> when the definition of strict talks about the input
15:51:22 <dmwit> The definition talks about both the input and the output.
15:51:29 <ReinH> EvanR: it involves evaluation.
15:51:46 <dmwit> f is strict when f _|_ = _|_, this equation talks about the input (f _|_) and the output (= _|_).
15:52:19 <EvanR> and lazy is not strict
15:52:34 <EvanR> which doesnt imply much
15:52:58 <dmwit> It implies something quite strong, actually: f starts producing output, *then* inspects its input.
15:53:08 <EvanR> it might right
15:53:12 <dmwit> has to
15:53:14 <dmwit> think about it =)
15:53:21 <ReinH> lazy is not non-strict either
15:54:08 <EvanR> so a non-strict f might be like f x, and its _|_ or not _|_ depending on x
15:54:23 <ReinH> Until something scrutinizes f x, f's strictness is unobserved.
15:54:47 <EvanR> so the first thing it doesnt is check x
15:54:55 <silkyM_> is anyone doing much ghcjs react stuff? what libaries are you using?
15:54:56 <EvanR> > head []
15:54:58 <dmwit> EvanR: I don't think so. If f _|_ /= _|_, then f x /= _|_.
15:54:58 <lambdabot>  *Exception: Prelude.head: empty list
15:55:13 <EvanR> ah
15:55:18 <EvanR> f _|_
15:55:52 <EvanR> non-strict x can't inspect the input first
15:56:06 <EvanR> or it would be strict
15:56:25 <dmwit> That said, people generally use "lazy" and "strict" a bit differently than the formal definition, I think.
15:56:25 <EvanR> and the only other course of action is output something
15:56:57 <dmwit> People talk about things like "lazy enough", for example... =P
15:56:59 <EvanR> s/x/f/
15:57:55 <dmwit> e.g. `map f` is strict. But you might catch somebody by surprise if you suggested it, since it's considered one of the canonical "lazy enough" functions...
15:58:22 <EvanR> as far as strict goes, ive been tacitly assuming informal strict is the same thing as f _|_ = _|_
15:58:33 <EvanR> lets see if thats a counterexample
15:58:55 <ReinH> dmwit: People generally say that about things like (||), there (False ||) is strict and (True ||) is non-strict.
15:59:07 <ReinH> s/there/where
15:59:27 <EvanR> map f is strict for all f ?
15:59:52 <dmwit> EvanR: You betcha. Very first thing it does is check whether its argument is (:) or [].
16:00:05 <hpc> (map f) is spine-lazy
16:00:09 <EvanR> and || may or may not be strict
16:00:19 <hpc> oh, wrt the list
16:00:33 <ReinH> hpc: er, isn't it spine-strict and value-lazy?
16:00:42 <ReinH> Oh, I see what you mean.
16:00:43 <dmwit> hpc: I see you have validated my claim that "you might catch somebody by surprise if you suggested `map f` is strict". ;-)
16:01:13 <hpc> well, you can't just say "it's strict" is perhaps a better claim ;)
16:01:24 <EvanR> i like the blog post thats like "strictness has no bearing whatsoever on memory performance"
16:01:39 <EvanR> because of stuff like this
16:01:43 <hpc> an output is strict or non-strict wrt an input
16:02:16 <EvanR> i thought a function is strict or non-strict
16:02:18 <dmwit> "strict" is a property of functions, defined formally above. `map f` doesn't have that property.
16:02:29 <dmwit> s/n't//
16:03:17 <dmwit> (yikes! it is easy to get tripped up on this stuff)
16:03:19 <EvanR> what about the function map, by itself (a function of 1 argument)
16:03:30 <hpc> dmwit: btw, "If f _|_ /= _|_, then f x /= _|_
16:03:34 <dmwit> map _|_ is not _|_
16:03:43 <EvanR> so map is lazy
16:03:46 <EvanR> er, non-strict
16:03:49 <hpc> dmwit: btw, "If f _|_ /= _|_, then f x /= _|_" is separate from strictness, it's monotonicity that governs that
16:04:07 <dmwit> hpc: Absolutely agree, yes.
16:04:23 <dmwit> hpc: I was doing the "in bed" game where you implicitly add "in Haskell" at the end of every sentence. ;-)
16:04:31 <hpc> in case that wasn't mentioned, so we don't muddle things
16:04:41 <dmwit> Thanks for making it explicit.
16:04:55 <EvanR> what does "in haskell" have to do with it
16:05:16 <dmwit> > case map undefined (undefined:undefined) of _:_ -> "map is not strict"
16:05:18 <lambdabot>  "map is not strict"
16:06:17 <dmwit> EvanR: Well, in the domain theory, there's a perfectly good function which has `f _|_ /= _|_` but `f True = _|_`. It just so happens that function is not the image of the "encoding" that takes a Haskell term and produces a domain-theory function.
16:07:27 <ReinH> hpc: I think to make that rigorous you have to use the definedness ordering on the domain?
16:07:55 <hpc> yeah
16:08:10 <ReinH> e.g. if [[ x ]] > [[ _|_ ]] then [[ f x ]] > [[ f _|_ ]] or something
16:08:22 <dmwit> > map id undefined `seq` "map id is not strict"
16:08:23 <lambdabot>  "*Exception: Prelude.undefined
16:08:24 <hpc> it gets interesting with map because different levels of inspecting the output trigger different levels of strictness about the inputs
16:08:37 <ReinH> hpc: I think something like that is the monotonicity condition we're talking about?
16:08:46 <EvanR> dmwit: ok, where function is math function on domains
16:08:57 <dmwit> EvanR: right
16:09:09 <hpc> ReinH: yeah
16:09:25 <hpc> there's a really good ezyang blog post about it that gets into how it ties into least fixed points
16:09:47 <EvanR> dmwit: so haskell functions are restricted to monotonic in this way
16:09:53 <ReinH> hpc: which is basically saying that f is a functor ;)
16:10:09 <hpc> :P
16:11:32 <ReinH> Hmm. It's some sort of morphism but my brain isn't giving up the specifics.
16:12:07 <hpc> it's beyond the scope of talking about strictness, anyway ;)
16:12:09 <Job314> In an attempt to understand IO better, I built this thing that lists the files (and not directories) in a given directory. Why is the let statement in let z = getline necessary? Why doesn't z<- getline work? http://lpaste.net/144001
16:12:23 <ReinH> hpc: Hmm, I think the condition is actually naturality, but yeah
16:12:42 <hpc> what makes a morphism turn neutral?
16:13:09 <hpc> is it strong normalization? finite domain?
16:13:09 <ReinH> *naturality*
16:13:16 <hpc> or is it just born with a heart full of neutrality?
16:13:21 <ReinH> hahaha
16:14:21 <EvanR> Job314: fileList <-listFilesInDir <$> getLine would work
16:14:39 <EvanR> in that sense a let z = getLine isn't necessary
16:15:02 <ReinH> hpc: something something something adjunctions
16:15:07 <Job314> yeah, that I figure. It's more understanding what the difference between let z=getLine and z<-getline is 
16:15:30 <ReinH> Job314: in let z = getLine, z has type IO String. in z <- getLine, z has type String
16:15:34 <MarcelineVQ> z <- getLine is the computed value, getLine is the wrapped computed value
16:15:39 <ReinH> (in the rest of the do block)
16:15:49 <MarcelineVQ> *let z = getline is the wrapped
16:15:57 <hpc> ReinH: a big diagram of when evaluating parts of output evaluates parts of input would do wonders for this map example, i think
16:16:03 <EvanR> you can think of let z = foo in bar as being exactly the same as bar with z replaced with foo (avoiding re-bound z though)
16:16:08 <hpc> someone with a blog should do that ;)
16:16:43 <EvanR> Job314: let is for giving names to expressions, but <- is to actually execute the IO actions
16:16:52 <EvanR> and get the result
16:17:52 <EvanR> if action :: IO A, then after x <- action, x will have type A 
16:18:27 <Job314> so with z<-getLine, I get a string, not an IO string
16:18:27 <EvanR> let doesnt change the types
16:18:32 <EvanR> yes
16:18:43 <Job314> I think I've rewritten it, one moment
16:20:17 <Job314> so when forcing IO up front, I can write this, which is equivalent (I think): http://lpaste.net/144004
16:20:31 <EvanR> yeah 
16:20:43 <EvanR> you might have been confused by trying to use <$>
16:20:54 <ReinH> Job314: Yep. You can use mapM_ and then you don't need to return () at the end.
16:21:43 <Job314> Yeah, I expected a monad coming back from getLine which requires applicative syntax, but I guess in a do block if you use <- you force that eval and don't get the wrapper
16:21:49 <ReinH> Basically mapM_ f xs = do { mapM f xs; return () }, so it saves that step.
16:22:03 <ReinH> :t (>>=)
16:22:04 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:22:33 <haskell517> case sortOn getName (x:xs) of    this doesnt work on ghc 7.6.3 how can i do the same thing with using sort instead of sortOn ?
16:22:39 <EvanR> Job314: note that were talking about executing IO, not evaluating wrapped values
16:22:43 <ReinH> Job314: The purpose of <- in do notation, which uses (>>=) under the hood, is to take an `m a` and make the `a` that results available for the rest of the block. You can see that in the type of (>>=).
16:23:18 <EvanR> no line exists if you have a getLine :: IO String
16:27:26 <Job314> Thanks everybody, getting it better now
16:29:17 <haskell517> does anyone know how can i do this with sort instead of sortOn   "sortOn getName (x:xs) "
16:29:33 <ReinH> haskell517: why not just use sortOn?
16:29:50 <ReinH> To do it with sort, you have plumb the values around yourself.
16:29:53 <haskell517> function needs to run on old ghc
16:30:02 <ski> @type sortOn
16:30:04 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
16:30:10 <EvanR> :t on
16:30:11 <ski> @type sortBy . comparing
16:30:12 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
16:30:12 <lambdabot> Ord a1 => (a -> a1) -> [a] -> [a]
16:30:29 <ski> so `sortBy (comparing getName)' ?
16:30:38 <ReinH> Sure, if sortBy exists.
16:30:52 <EvanR> :t sortBy (comparing fst)
16:30:54 <lambdabot> Ord a => [(a, b)] -> [(a, b)]
16:30:57 <bb010g> :i sortBy
16:31:08 <ski> there is no `:i' shortcut in lambdabot
16:31:17 <ReinH> ski: sortOn does a Schwartzian transform under the hood though.
16:31:29 <ski> (and no `@info' either)
16:31:54 <ski> ReinH, i see
16:32:05 <ReinH> so it's actually sortOn f = map snd . sortBy (comparing fst) . map (f &&& id)
16:32:13 <ReinH> except strict in f
16:32:38 <ReinH> map (\x -> let y = f x in y `seq` (y, x)), actually
16:33:28 <ReinH> and ofc sortBy exists if sort exists, since sort = sortBy compare
16:34:23 <haskell517> not in scope 'comparing'
16:34:33 <ReinH> ski: I suppose sortOn exists because it's more efficient than sortBy . comparing :)
16:34:48 <ReinH> haskell517: in Data.Ord
16:36:01 <ReinH> comparing p = compare `on` p, using Data.Function.on, as well (which is one of my favorite combinators).
16:36:10 <EvanR> i see your schartzian transform is as efficient as mine
16:36:18 <ReinH> EvanR: there it is
16:36:25 <ReinH> Actually mine was less efficient though
16:36:39 <EvanR> the one with seq?
16:36:43 <haskell517> kk thanks
16:36:45 <ReinH> the first one without
16:38:52 <dpwright> I've received an issue filed against one of my projects asking me to support stack builds, which has given me the kick up the backside I needed to give it a try
16:39:55 <dpwright> I'm struggling to get a handle on what's involved though (I've never used stack).  Is there a simple guide somewhere that will tell me what I need to do to take an existing library package I have and make it stack-compatible?  Do I just up the bounds on the dependencies in the .cabal file? Do I need to add a stack.yml?
16:40:34 * hackagebot ginsu 0.8.2.1 - Ginsu Gale Client  https://hackage.haskell.org/package/ginsu-0.8.2.1 (DylanSimon)
16:43:33 <kadoban> dpwright: Basically, install stack however you like (should be pretty easy, there's binaries for a bunch of stuff and tie-ins with the package managers I've ever heard of). Then go to your project and try: 'stack init', it should create a stack.yaml for you. See what it says at least. Usually for me it just picks a resolver, which corresponds to a stackage snapshot, and … that's it.
16:44:20 <kadoban> dpwright: If your dependency tree isn't compatable with one of the LTS snapshots, I'm not sure, you might need a bit more work. I'm not familiar enough with that to give much general advice, though any problem I'm sure someone here can help with.
16:44:25 <mmm> I am looking for remote job. anyone hiring?
16:44:35 <dpwright> kadoban: Oh right, sounds pretty easy!  I don't suppose there's a consensus on mac about whether it's better to use homebrew or cabal to install stack
16:45:38 <emmanuel_erc> hello there
16:46:05 <deni> how does one go about distributing haskell binaries for internal projects? I mean the easy solution is to copy it to a local fileserver somewhere and have people download an appropriately versioned binary...but was thinking if there are tools like artifactory or something like that
16:46:20 <kadoban> dpwright: Apparently their website suggests using 'brew', which I assume is homebrew.
16:48:03 <dpwright> I guess I'll go with that then!  I think I did spot that in their README but I just wanted to make sure... thanks for your help!
16:48:27 <kadoban> 'welcome. Yeah I'm not a mac guy myself, there may be another consensus that contradicts, but I haven't heard anything.
16:50:00 <deni> while we're at it how can i get cabal (or stack) to append a version name to the binary it produces?
16:51:04 <jophish> What do people do to decide to the order in which to write constraints? Alphabetical, Superclass first?
16:51:32 <kadoban> Random, heh.
16:51:35 <EvanR> let the ide decide
16:52:03 <hexagoxel> i use unordered lists for those
16:52:29 <pdxleif> What's a nice way of working with Eithers? bifunctor? lenses?
16:53:53 <Cale> jophish: Sometimes ordering the constraints by which variable they constrain is worth doing
16:55:10 <ReinH> pdxleif: lenses are a nice general solution that you're probably already using anyway :) (See also: http://www.haskellforall.com/2015/10/explicit-is-better-than-implicit.html)
16:55:24 <jophish> Cale: yeah, that's usually what I end up doing
16:55:50 <ReinH> dpwright: Use homebrew imo.
16:55:53 <jophish> A program to do that automatically would be nice
16:56:04 <ReinH> dpwright: I removed my existing ghc and cabal setup so I am just using stack, actually.
16:56:07 <Cale> Apart from that, it's really not worth thinking about
16:56:18 <ReinH> jophish: whatever order I realize I need them in ;)
16:56:23 <Cale> I wouldn't even worry about it.
16:56:39 <Cale> There isn't really a wrong order.
16:57:14 <Cale> I don't think GHC can take advantage of one ordering vs. another really.
16:57:29 <Cale> But that would be pretty interesting
16:57:36 <dmwit> deni: It would be nice to have a principled way to do that. Perhaps you should mention that idea on this feature request: https://github.com/haskell/cabal/issues/1449
16:57:39 <kadoban> Yeah I nuked my previous GHC and cabal and stuff setup, that seemed to go better with 'stack', though it's not supposed to be necessary.
16:59:02 <dmwit> Cale: GHC can't take advantage of one type variable naming or another, either, but that doesn't mean the choice should be completely arbitrary.
16:59:23 <jophish> On this topic, here's something fun. It's possible to do this: Show a => Num a => a -> a
16:59:33 <dmwit> e.g. Gr node edge > Gr n e > Gr ty12345 ty54321 in terms of human readability.
17:00:34 * hackagebot secp256k1 0.4.2 - secp256k1 bindings for Haskell  https://hackage.haskell.org/package/secp256k1-0.4.2 (xenog)
17:00:36 <ski> jophish : usually i'd try to order them with the most likely to specialize first
17:01:17 <jophish> oh, good idea ski
17:01:30 <ski> jophish : similar to currying
17:03:05 <deni> dmwit: so there isn't a way to do this currently with cabal?
17:04:10 <deni> dmwit: what about stack?
17:04:27 <silkyM_> deni: you can just do it with a post-build script
17:04:31 <hexagoxel> deni: custom Setup.hs should allow it. probably.
17:06:37 <deni> silkyM_: yeah I was leaning towards that direction but I wanted to see what the standard was
17:06:42 <deni> hexagoxel: do you have an example of this?
17:06:44 <dpwright> ReinH: Thanks... I'll give it a go without uninstalling ghc first and see if that works -- if I have problems I'll try the clean slate approach
17:11:34 <ReinH> dpwright: They shouldn't interfere.
17:11:37 <hexagoxel> deni: no, sorry.
17:12:21 <silkyM_> deni: this project - https://github.com/simonmichael/hledger - might be a nice example to learn from
17:15:32 <deni> silkyM_: I'm not sure what you're showing me. Is the solution to use Makefiles for this?
17:15:51 <deni> silkyM_: cause that's what I was thinking of doing but would much rather if there was a built in way
17:16:38 <delYsid> Given a Dec, how do I make a DecsQ?
17:19:14 <delYsid> :t [DataD [] (mkName "A") [] [NormalC (mkName "A") []] []]
17:19:15 <lambdabot> Not in scope: data constructor ‘DataD’
17:19:15 <lambdabot> Not in scope: ‘mkName’
17:19:15 <lambdabot> Not in scope: data constructor ‘NormalC’
17:24:49 <isd> Hey. I'm trying to write An instance of QuickCheck's Arbitrary for a type that can contain FileStatus (http://hackage.haskell.org/package/unix-2.7.1.0/docs/System-Posix-Files.html#t:FileStatus), but I don't see a way to construct those short of making a file and statting it. Am I missing something or am I out of luck?
17:26:42 <jmcarthur> isd: It looks like you are right. If you want to make your function testable, you could write a type class for the functions you need to support on FileStatus, and give it instances for FileStatus and some new type of your own that you can construct values of.
17:26:55 <jmcarthur> isd: and, obviously, write your tests using the latter
17:27:32 <jmcarthur> isd: so your function would just be polymorphic over which implementation to use
17:27:58 <isd> jmcarthur: that makes sense. thanks for the advice.
17:35:24 <jophish> Does anyone here use hoogle in a nix-shell environment?
17:40:36 * hackagebot fn 0.1.1.0 - A functional web framework.  https://hackage.haskell.org/package/fn-0.1.1.0 (DanielPatterson)
17:45:36 * hackagebot fn-extra 0.1.0.0 - Extras for Fn, a functional web framework.  https://hackage.haskell.org/package/fn-extra-0.1.0.0 (DanielPatterson)
17:51:43 <khanage> i'm trying to parse the image file from http://yann.lecun.com/exdb/mnist/
17:52:09 <khanage> i figure that conduit + attoparsec is a good combination
17:56:27 <khanage> i need to parse a header though and use some of the values from it to specify another parser
17:58:05 <jophish> hmm, I have a derivation in a file. What's the command to pass to nix-shell to get an environment in which to build this derivation
17:58:43 <jophish> ah, I think I've got it
18:00:11 <nek0> hello there.
18:00:48 <nek0> I am looking for some advice on how to design software in Haskell.
18:01:40 <nek0> O be more precise, I am looking for something like UML is for object oriented programming.
18:01:54 <nek0> Do you knwo of something?
18:02:07 <jmcarthur> nek0: I have a link for you, but I have to find it first.
18:02:37 <jmcarthur> nek0: got it. https://www.youtube.com/watch?v=zzCrZEil9iI
18:02:58 <jmcarthur> nek0: This may not be exactly what you thought you were asking for, though.
18:03:43 <jmcarthur> nek0: In fact, now I realize this is probably a bad answer, because I now think you are asking more about software engineering than specifications, really.
18:04:42 <nek0> jmcarthur: yes, this is more engineering. I am on the verge of creating new software, which I would like to plan out thoroughly before starting out coding.
18:05:37 * hackagebot checkers 0.4.4 - Check properties on standard classes and data structures.  https://hackage.haskell.org/package/checkers-0.4.4 (ConalElliott)
18:07:02 <monochrom> you need to know about specifying, too
18:07:20 <jmcarthur> nek0: I find that bottom-up design tends to work relatively well in Haskell regardless of experience, but top-down design tends to only work well for experienced Haskellers.
18:08:16 <nek0> jmcarthur: what do you mean by "bottom up"? Start out with the types?
18:08:16 <jmcarthur> nek0: When you try top-down design and only know OOP design principles, you tend to get yourself stuck in designs that don't work so well for Haskell, but if you build from the bottom up then you know everything you've done so far is okay.
18:08:43 <monochrom> http://www.slideshare.net/ScottWlaschin/fp-patterns-buildstufflt
18:11:03 <nek0> monochrom: doesn't show me anything, just a blank page...
18:11:12 <ReinH> Anyway, the idea that you can plan software out thoroughly before you start is based on the flawed premise that you already know everthing you need to know about how the software should be designed.
18:11:39 <EvanR> the zygohistomorphic prepromorphism pattern
18:11:49 <monochrom> I don't know how to help with that. I get more than a blank page.
18:13:20 <jmcarthur> ReinH: All the more reason I tend to promote bottom up design by default. It's not without its flaws (e.g. it's easier to fall into a rabbit hole), but tends to be more... "agile",
18:13:43 <nek0> I agree, that I can't plan everything out, but I want to avoid wasting time coding something, which turns out to be flawed.
18:13:48 <monochrom> http://www.vex.net/~trebla/tmp/Screenshot%20from%202015-10-26%2021:12:08.png
18:14:06 <jmcarthur> Also it means you get something working really fast, althought it doesn't really count as a prototype for the final product, which is a *huge* downside.
18:14:12 <jmcarthur> *although
18:14:43 <jmcarthur> nek0: monochrom's link also works for me
18:15:23 <nek0> jmcarthur: strange. I get stuck somewhere in a redirect.
18:15:52 <jmcarthur> Ugh, I just found the slide that asserts that everything is basically a function. I really hate that claim. It's arbitrary and unhelpful.
18:16:10 <monochrom> I disagree.
18:16:44 <jmcarthur> I think it is helpful to show that many patterns can be captured as functions.
18:16:52 <EvanR> not everything, just that basket of OOP patterns
18:17:28 <jmcarthur> EvanR: Ah. If that's all the slide meant, then my only objection is that it was a pair of bulleted lists instead of a table.
18:18:01 <EvanR> yeah
18:18:23 <EvanR> another objection is it doesnt explain how to do each pattern with functions
18:18:45 <monochrom> I doubt that this objection is legit.
18:18:54 <jmcarthur> Yeah, it seems like it would have been terse enough to just show it. And it would have looked a lot more impressive.
18:18:57 <EvanR> it wouldnt fit
18:19:23 <jmcarthur> monochrom: You mean you doubt that my objection is sincere?
18:20:46 <monochrom> depending on the author's focus, the presentation's length, and other factors, an author has the full right to state a positional statement with or without as much elaboration and justification as you want to see.
18:21:27 <jmcarthur> I completely agree, but I also have the full right to disagree with a perceived (as that's the best I'm going to get) claim.
18:22:14 <jmcarthur> It's not like I'm being personally offended about the use of comic sans. I just think it could have been presented more clearly, *if* the present interpretation of that slide is as the author intended.
18:28:49 <shachaf> jmcarthur: The real problem with your objection is that it's a function.
18:29:50 <jmcarthur> I have no problem with that.
18:29:59 <jmcarthur> Many things are functions.
19:26:36 <lingxiao> hey al
19:26:49 <lingxiao> I'm having a little issue i was hoping someone could help me resolve
19:27:01 <dmj> lingxiao: what issue?
19:27:25 <lingxiao> well it's defining join for this parser thingy ..
19:27:29 <lingxiao> one sec
19:27:57 <lingxiao> http://lpaste.net/144015
19:28:03 <lingxiao> not sure how to define join in this case
19:29:00 <lingxiao> since by def m >>= g = join . fmap g $ m
19:29:22 <lingxiao> it's throwing an infinite loop for me
19:33:36 <ski> lingxiao : and your `Functor' instance is defining `fmap' how ?
19:34:18 <lingxiao> right now it's just liftA
19:34:45 <ski> i think that's your infinite loop
19:35:06 <ski> assuming you haven't defined `(<*>)' directly
19:36:24 <sportanova> can you separate a value of type (Type1 :. Type2) into values (someType1, someType2)?
19:36:44 <sportanova> doesn't necessarily need to be a tuple
19:37:24 <ski> lingxiao : so `(<*>)' is defined as `ap' or what ?
19:37:30 <lingxiao> yeah it's ap
19:37:40 <lingxiao> in this file monad is dfeined first
19:37:43 <lingxiao> defined*
19:37:48 <ski> `(>>=)' is defined in terms of  bindP'  which is defined in terms of `fmap', being `liftA' which is defined in terms of `(<*>)' which is presumably defined as `ap' being defined in terms of `(>>=)'
19:38:01 <lingxiao> ahhh I see ...
19:38:13 <lingxiao> ok I went crazy over this ...
19:38:26 <lingxiao> it's like ther's only one thing join could possibly be!
19:38:59 <ski> sportanova> :k (:.)
19:39:18 <lingxiao> ok great it works! wow thank you
19:39:22 <ski> np
19:40:27 <ski> sportanova : if it's composition, then no
19:41:52 <pavonia> How can (<*>) be defined in terms of ap? You don't necessarily have a Monad instance
19:41:59 <sportanova> ski: how would you access values from it? I used (:.) to do a join in postgres-simple, but now i'm having trouble accessing the values http://hackage.haskell.org/package/postgresql-simple-0.3.7.1/docs/Database-PostgreSQL-Simple-Types.html
19:42:10 <ski> pavonia : .. manually ?
19:42:58 <pavonia> Oh, I thought you were talking about the default implementation
19:43:47 <ski> sportanova : ok, it's just a fancy product type
19:44:30 <dmj> lingxiao: joinP = (>>= id)
19:44:33 <ski> sportanova : so match on `someType1 :. someType2' ?
19:44:53 <ski> dmj : they wanted to define `(>>=)' in terms of `join', not the other way around
19:45:03 <lingxiao> dmj thanks! I was wondering. and yes what ski just said
19:45:11 <lingxiao> it's for instructional purpose only haha
19:46:18 <sportanova> ski: you're a goddamn genius https://www.youtube.com/watch?v=NoptofKbQ04
19:46:25 <sportanova> thanks!
19:46:30 <ski> np
19:52:26 <shanemikel> is there an easy way in ghci to list the typeclasses a data type is member of?
19:54:21 <EvanR> :i MyType
19:56:35 <shanemikel> thanks
19:58:18 <mutantmell_> @pl \o -> \x y -> runReaderT (runReaderT o x) y
19:58:19 <lambdabot> (runReaderT .) . runReaderT
19:58:47 <mutantmell_> That... kinda makes sense
20:01:38 <shachaf> No need to @pl all the way.
20:02:08 <mutantmell_> shachaf: agreed :)
20:02:17 <mutantmell_> Not planning on using that instance, mostly just curoius
20:03:38 <lethjakman-l> cabal install --upgrade-dependencies is what I need to upgrade the dependencies in a project, right?
20:03:46 <lethjakman-l> It seems to keep installing my project .
20:06:01 <shachaf> mutantmell_: Well, you should @pl *some* of those arguments.
20:06:06 <shachaf> Just not all of them.
20:06:37 <mutantmell_> @pl \x y -> runReaderT (runReaderT o x) y
20:06:38 <lambdabot> runReaderT . runReaderT o
20:06:51 <mutantmell_> shachaf: ty
20:11:23 * hackagebot fn-extra 0.1.0.0 - Extras for Fn, a functional web framework.  https://hackage.haskell.org/package/fn-extra-0.1.0.0 (DanielPatterson)
20:11:23 * hackagebot checkers 0.4.4 - Check properties on standard classes and data structures.  https://hackage.haskell.org/package/checkers-0.4.4 (ConalElliott)
20:21:44 <isd> http://pastie.org/private/xq8x5jyqfbnu9orugjfw
20:22:05 <isd> Not in scope: data constructor ‘UnixTime’
20:22:24 <isd> I am so confused. It's probably something silly, but I'm not seeing it. Any ideas?
20:22:49 <pavonia> It's importing the type but not its constructors
20:23:06 <pavonia> try (UnixTime (..))
20:23:34 <isd> pavonia: Aha! thanks.
20:33:41 <dberg> where is IO defined in the ghc source code?
20:33:59 <dberg> it's supposed to be something like data IO :: * -> *, correct?
20:37:40 <anohigisavay> hi. i want to generate random numbers is an ST monad. is it possible?
20:38:20 <EvanR> you can run a random monad insid of ST
20:39:47 <nitrix> dberg: The base library that defines System.IO and the IO type reexport GHC.IO.
20:40:34 <mac10688> To test this function type with quickCheck, whatDoesDollarSignDo :: (Eq b) => (a -> b) -> a -> Bool. Do I need to give it a higher order function or is it possible for quickCheck to generate a  higher order function?
20:40:54 <mac10688> I can do something like this
20:40:55 <mac10688> Q.quickCheck $ whatDoesDollarSignDo (\x -> (x :: Int))
20:41:00 <anohigisavay> EvanR: you mean MonadRandom?
20:41:11 <mac10688> but can I do Q.quickCheck whatDoesDollarSignDo?
20:41:11 <anohigisavay> how can i escape the Monad scope?
20:41:58 <anohigisavay> ST s itself not a MonadRandom instance
20:42:03 <ski> QuickCheck can generate random functions, provided the argument types are in `CoArbitrary'
20:42:28 <EvanR> anohigisavay: you dont need to escape it, thats why i said inside
20:42:53 <Cale> anohigisavay: Uh, I'm not sure I understand what you want... you want to generate random ST computations whose result is a number?
20:42:56 <mac10688> ok thanks ski, I'll see what I can find about CoArbitrary.
20:42:57 <ski> (`whatDoesDollarSignDo' is a higher order function itself. however, it's argument function isn't specified to be a higher-order function. just a function)
20:43:24 <mac10688> ah yeah, I see what you mean
20:43:29 <Cale> Or you just want a random number generator which is itself an ST computation?
20:43:33 <ski> @check \f -> f False == False
20:43:35 <lambdabot>  *** Failed! Falsifiable (after 4 tests):
20:43:35 <lambdabot>  <Bool -> Bool>
20:43:39 <Cale> :t random
20:43:40 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
20:43:51 <anohigisavay> Cale: i'm using Vector.create that accepts an ST monad where i want to write random numbers to that vector
20:43:56 <ski> (that generated a random function. but it didn't show it sensibly ..)
20:44:38 <ski> anohigisavay : s/monad/monad action/
20:44:47 <Cale> anohigisavay: Probably you'll want to get a StdGen from somewhere, which represents a random generator state. The usual way to get one is by executing newStdGen :: IO StdGen
20:45:14 <Cale> and then use random/randomR
20:45:15 <anohigisavay> ski: yea :D thanks
20:46:29 <anohigisavay> Cale: i have this function type: batchPairCrossover :: (MonadRandom m) => V.Vector Word64Genome -> m (V.Vector Word64Genome)
20:46:49 <anohigisavay> can i not use IO?
20:47:03 <Cale> You can use IO, I believe it's an instance of MonadRandom
20:49:46 <anohigisavay> Cale: thanks i'll try to work this out
20:50:01 <Cale> anohigisavay: Of course, you can't use an IO action as an ST action.
20:50:21 <dberg> nitrix: thanks, taking a look at the files.
20:50:22 <Cale> anohigisavay: But you can use batchPairCrossover v as an IO action.
20:50:40 <EvanR> are there any examples of the ST-like strategy but used for some other monad?
20:51:18 * hackagebot acid-state 0.13.1 - Add ACID guarantees to any serializable Haskell data structure.  https://hackage.haskell.org/package/acid-state-0.13.1 (DavidJohnson)
20:51:19 <EvanR> implementation strategy
21:00:13 <jre2> Question: I have a simulation that can receive input at any point in time, currently stored as Map TickTime InputData
21:00:44 <jre2> what would be a better solution if I wanted to store the history of changes (ie. so I can replay my simulation)?
21:01:19 * hackagebot yesod-websockets 0.2.4 - WebSockets support for Yesod  https://hackage.haskell.org/package/yesod-websockets-0.2.4 (MichaelSnoyman)
21:02:07 <dmj> jre2: you might consider using an impure hash table so you can log changes made separately
21:02:35 <EvanR> a temporal database datastructure
21:03:13 <EvanR> a move list
21:03:31 <EvanR> transaction log
21:05:18 <mjrosenb> as long as you only want to replay, a linked list?
21:05:22 <jre2> is a move list effectively a trans log? or is it something else?
21:12:25 <jre2> mjrosenb: well during the simulation I'd prefer a quick way to lookup what input data applies to sim time T
21:13:13 <mjrosenb> jre2: you can also just stick them in N differnet structures,
21:28:47 <EvanR> jre2: yeah, pretty much the same thing
21:31:05 <EvanR> jre2: an index from T to list of input data at time T can be derived from the move list
22:17:58 <Zemyla> Why is currying not called schonfinkeling?
23:02:44 <pi_____> ££££££
23:03:16 <liste> @hackage acme-schoenfinkel -- Zemyla
23:03:16 <lambdabot> http://hackage.haskell.org/package/acme-schoenfinkel -- Zemyla
23:20:25 <platz> found an old irc log that claimed -fexpose-all-unfoldings is equivalent to marking everything INLINABLE
23:21:12 <jaj> dmwit: thanks for your reply! I will read through it later today
