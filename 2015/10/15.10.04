00:00:13 <Hijiri> I don't know, maybe they thought of it after, or the syntax seemed too heavy
00:00:28 <Hijiri> maybe not all monad transformers have an underlying monad?
00:00:44 <Hijiri> often the "vanilla" monad is defined as FooT Identity
00:00:45 <julianleviston> huh… this is interesting
00:00:49 <julianleviston> > length [(minBound::Char)..(maxBound::Char)]
00:00:50 <lambdabot>  1114112
00:01:02 <julianleviston> that’s a lot more than I anticipated!
00:01:08 <RedNifre> how so?
00:01:16 <Hijiri> and you just implement the FooT version before Foo
00:01:29 <julianleviston> for some reason, I thought it’d be just like… ascii lol
00:01:34 <julianleviston> it’s unicode. is it?
00:01:36 <Hijiri> yes
00:01:39 <Adeon> it's all the unicode code points
00:01:39 <RedNifre> no
00:01:45 <RedNifre> it's way more than unicode, unfortunately
00:01:54 <julianleviston> erm.
00:02:05 <RedNifre> char can have any value in that range, even values that aren't valid unicode.
00:02:24 <julianleviston> RedNifre: unicode is a bit comlex, isn’t it?
00:02:24 <arahael> Does running haskell in ghci have the same performance as running it in ghc itself?
00:02:28 <julianleviston> RedNifre: complex*
00:02:38 <HEGX64> > (maxBound::Char):[]
00:02:40 <lambdabot>  "\1114111"
00:02:42 <julianleviston> arahael: what is GHC itself? you mean compiled?
00:02:48 <RedNifre> totally. I think Text solves a lot of the Char problems though.
00:02:50 <arahael> julianleviston: Yes
00:02:57 <HEGX64> > print $ (maxBound::Char):[]
00:02:58 <lambdabot>  <IO ()>
00:03:13 <julianleviston> arahael: well given that Ghci interprets, probably not...
00:03:15 <Adeon> I think by default all you write in the prompt is interpreted and modules often get loaded interpreted as well
00:03:32 <julianleviston> arahael: tho if you code is in a module, probably so…
00:03:37 <Adeon> but I know there are knobs to turn compilation on...don't know if it can be applied to the haskell code on the repl though
00:03:39 <arahael> julianleviston: It doesn't do any sort of JIT compilation or the like?
00:03:44 <RedNifre> > show (mayBound::Char)
00:03:46 <lambdabot>      Not in scope: ‘mayBound’
00:03:46 <lambdabot>      Perhaps you meant one of these:
00:03:46 <lambdabot>        ‘maxBound’ (imported from Prelude),
00:03:49 <julianleviston> arahael: ah sorry I don’t know.
00:03:51 <RedNifre> > show (maxBound::Char)
00:03:53 <lambdabot>  "'\\1114111'"
00:03:56 <Saizan> arahael: no JIT
00:04:15 <arahael> Right, so if my script is taking "hours", I might get faster performance by compiling it first.
00:04:25 <arahael> (Nevermind that the real issue is a crappy algorithm)
00:04:29 <julianleviston> arahael: oh I’d doubt that.
00:04:29 <bollu> is anyone here aware of Urbit? if so, can someone tell me if it is serious? (https://github.com/urbit/urbit)
00:04:47 <bollu> I'm reading the docs and I _really_ can't tell if it is masterful trolling or serious
00:04:49 <arahael> julianleviston: Now you're confusing me!
00:04:52 <julianleviston> arahael: I’d be surprised if it re-compiled things it’d already interpreted.
00:04:55 <Saizan> arahael: it can get much faster, depending on the situation
00:05:08 <arahael> Saizan: Cool, I might give it a play around.
00:05:38 <RedNifre> bollu sounds like something that could work but may still be art...
00:05:40 <julianleviston> bollu: oh yeah, I read that once. I don’t think it’s a troll… it’s quite interesting. :)… and odd.
00:05:43 <arahael> So ghci really interprets the script and only compiles whatever gets imported in as a module?
00:06:06 <julianleviston> arahael: I’m a bit fuzzy, but that’s my general understanding of what takes place… 
00:06:06 <Hijiri> RedNifre: so I guess the answer why Compose isn't used is because you would be forced to define bind/return twice (once for transformer and once for vanilla)
00:06:07 <bollu> heh, yeah, maybe..
00:06:15 <Adeon> if your script is a module there is a knob that can tell it to compile it instead before loading it to ghci
00:06:16 <bollu> I dunno if I should spend time of it
00:06:17 <bollu> on
00:06:39 <Hijiri> well I guess you could do Compose Identity Foo
00:06:42 <Adeon> it should show on ghci
00:06:59 <Hijiri> and just define it for Compose m Foo
00:07:08 <RedNifre> bollu consider learning idris first, might be a better use of your time (maybe)
00:07:39 <Hijiri> but then you couldn't make a MonadTrans instance for Foo transformer
00:07:50 <Saizan> arahael: ghci does not compile by default, but it loads the compiled code for libraries, or for modules that were already compiled
00:08:13 <arahael> Saizan: Thanks - that makes sense.
00:08:20 <julianleviston> Saizan: but it doesn’t do crazy things like re-interpret already interpreted code, right? :)
00:08:37 <Saizan> julianleviston: no, unless you reload the module
00:08:37 <arahael> Saizan: Somehow I thought that interpreting it would result an efficient-in-memory representation of the functions.
00:08:38 <julianleviston> which is… I think… what arahael was asking about (a bit).
00:08:50 <julianleviston> arahael: yeah, I think it does.
00:09:13 <Saizan> julianleviston: i think arahael was just asking about stopping the current run, compiling, then running the compiled exec
00:09:33 <julianleviston> arahael: the point is simply if you use GHC compile it will compile it all at once, rather than piece by piece as it needs it.
00:09:35 <julianleviston> Saizan: yeah
00:09:55 <arahael> Saizan: You're correct, basically I was wondering if ghci is a naive interpreter, or if it actually compiles the scripts (and throws the results away at the end)
00:09:55 <Saizan> arahael: it has bytecode, but that's not optimized like what you get during compilation
00:09:58 <julianleviston> either way it shouldn’t affect performance that much unless there’s a large amount of code
00:10:05 <arahael> Saizan: Ah, that keeps it clear.
00:10:07 <Saizan> julianleviston: you are pretty wrong.
00:10:10 <julianleviston> Saizan: ah! 
00:10:12 <julianleviston> Saizan: thanks :)
00:10:38 <julianleviston> Saizan: I didn’t know it used bytepcode at all
00:11:06 <Saizan> arahael: tbc, ghc compiles down to assembly (either directly or through LLVM)
00:11:26 <Saizan> julianleviston: cheers :)
00:11:41 <arahael> Saizan: Yep - that's clearer. So ghci only compiles (quickly) to an intermediate bytecode and then stops.
00:11:49 <bollu> RedNifre: I'm learning agda and Coq semi-simeltaneously
00:11:49 <julianleviston> Saizan: I think you meant “Your understanding of it is pretty wrong” :)
00:11:50 <bollu> so, like
00:12:00 <julianleviston> Saizan: and, yes! :) thanks for correcting me. 
00:12:01 <arahael> Saizan: Thanks. :)
00:12:33 <RedNifre> > chr 0x41
00:12:35 <lambdabot>  'A'
00:12:43 <RedNifre> > chr 0xFFFE
00:12:44 <lambdabot>  '\65534'
00:12:49 <RedNifre> yeah right
00:13:53 <Saizan> arahael: you can also raise the optimization level by passing -O2 to ghc, it's sometimes worth
00:14:24 <Saizan> julianleviston: i actually just meant that what you were saying was wrong :)
00:14:32 <julianleviston> Saizan: true :)
00:16:25 <julianleviston> Saizan: I should get in the habit of demarcating fact from assumption in my mind. It’s not easy.
00:18:43 <julianleviston> um… what is “newtype”? is it a type constructor constructor?
00:19:04 <julianleviston> and also “data”. What are they called?
00:23:15 <Saizan> i don't think there's a name specific to those two, but they are keywords for declarations, like class
00:23:46 <julianleviston> Saizan: it seems “reserved identifier” is what the report calls them
00:25:01 <julianleviston> Saizan: but yeah, keyword… cool :)
00:27:45 <julianleviston> Saizan: ironically, the report doesn’t seem to mention “keyword” more than once or twice.
00:28:50 <ReinH> "reserved identifier" is the formal name for keyword ;)
00:28:59 <julianleviston> ReinH: aha ;-)
00:29:38 <ReinH> In many language descriptions they are called keywords.
00:34:16 <julianleviston> What’s an example of a type constructor? data Maybe a = Just a | Nothing ? the data marks the definition of the type constructor, but Maybe is the actual type constructor, right? Just and Nothing are data constructors.
00:34:29 <julianleviston> Sorry for the pedestrian questions. Just reinforcing my nomenclature & understanding.
00:34:56 <ggole> julianleviston: pretty much
00:34:59 <julianleviston> great.
00:37:42 <julianleviston> and when I say newtype Box a = Box {boxContents :: a}, newtype is a keyword marking the definition of a type constructor called Box, and a data constructor called Box as well… right?
00:38:28 <ggole> Yep
00:38:37 <julianleviston> and newtype as a keyword can only define a unary type constructor.
00:39:17 <julianleviston> ggole: cool. Thanks. :)
00:39:24 <ggole> No
00:39:31 <julianleviston> ggole: oh?
00:39:32 <ggole> You can, eg, newtype Foo a b = Foo a
00:39:50 <ggole> It's the RHS which has the single argument constraint
00:39:54 <julianleviston> ggole: oh weird.
00:40:07 <ggole> Think of it as a type-level construct
00:40:18 <julianleviston> ggole: so newtype is a keyword that introduces a type constructor that defines only unary data constructors
00:40:32 <MarcelineVQ> if you think that's weird have a look at phantom types
00:40:39 <julianleviston> ggole: think of it <- which is it?
00:40:45 <julianleviston> MarcelineVQ:  ok… :)
00:41:27 <ggole> newtype is constrained the way it is in order for the constructor to be a compile-time only wrapper around the (single) argument
00:41:42 <ggole> Like abstract types in ML
00:41:58 <julianleviston> ggole: ok
00:42:17 <julianleviston> ggole: and when you say “the constructor” you mean the data constructor
00:42:30 <ggole> Well, both
00:42:43 <julianleviston> ggole: except that the type constructor has two arguments in your example
00:43:06 <ggole> Right: you can hang type-only information on those arguments
00:43:22 <julianleviston> MarcelineVQ: isn’t phantom types exactly what ggole is talking about?
00:43:25 <ggole> It exists at the type level, with no physical representation
00:43:42 <julianleviston> ggole: is that actually useful in some cases?
00:43:57 <ggole> Yeah, you can express various things with phantom types
00:44:22 <julianleviston> ah ok cool
00:44:26 <julianleviston> reading about them now.
00:45:10 <ggole> newtypes are useful for other things: you can use them to direct type-based machinery like type classes
00:46:07 <julianleviston> ggole: yeah, I understand how useful newtypes can be :) I’ve read a bit about them, and how they’re different than standard data types after compile time.
00:46:41 <julianleviston> ggole: and of course you see them in State and StateST and whatnot.
01:03:48 * hackagebot mime-mail 0.4.11 - Compose MIME email messages.  https://hackage.haskell.org/package/mime-mail-0.4.11 (MichaelSnoyman)
01:19:37 <julianleviston> How come I can’t do this? newtype (Num a, Eq a) => Fish a = Fish a deriving (Eq, Show)
01:20:09 <julianleviston> … without DatatypeContexts
01:22:22 <julianleviston> Ah actually nevermind - seems to be “you probably don’t need to do that - leave your types open.
01:55:28 <ocramz> good morning all
01:57:43 <ocramz> open source licensing question: what license should I use if I have a mind to use my own code in a commercial setting at a later stage?
01:58:06 <ocramz> e.g. build a commercial service that uses it
01:58:10 <ocramz> BSD?
01:58:30 <ocramz> I understand GPL does not allow this situation
02:00:45 <bennofs> ocramz: wait, why not? isn't Qt exactly doing that? (the OSS version is GPL/LGPL, and there's a commercial license available for non-OSS use)
02:01:40 <ocramz> bennofs: so this means two licenses for the same library
02:02:11 <ocramz> I didn't think about this possibility. But doesn't this defeat the purpose of the more liberal one?
02:04:18 <bennofs> ocramz: well, you could make a special license just for yourself. As I understand it, a license is just a contract, so you could have an OSS license for everyone and then special-license to yourself under different conditions (not sure if that's even neccessary if you own the code. You're just saying: Anyone else using this code has to follow the GPL. That doesn't restrict yourself from also using it for
02:04:19 <bennofs> different purposes). But you should probably ask a laywer about this
02:05:37 <ocramz> bennofs: thanks for the thought food
02:06:07 <ocramz> yeah I'm not a law specialist and honestly don't even know where to look for an OSS-savvy lawyer
02:07:28 <dramforever> ocramz: this? https://tldrlegal.com/ (WARNING: I'm afraid that you shouldn't take serious legal advice from there)
02:08:05 <supki> ocramz: https://www.gnu.org/licenses/gpl-faq.html#ReleaseUnderGPLAndNF
02:09:25 <ocramz> oh, nice! Thanks dramforever and supki
02:09:40 <Ongy> Cale awpr: I played around with the GHC.Event thing, the unsafeCoerce does seem to work, the bigger Problem is that base-4.8.0.0 and base-4.8.1.0 do not export the loop from GHC.Event to actually start the event management (this can be fixed by used threaded RTS for now)
02:14:04 <ReinH> Ongy: have you thought about compiling your own base/ghc?
02:16:10 <Ongy> ReinH: I have done that to test this, but I don't like the "works on my machine" approach this creates, I'm not writing this just for personal use
02:38:44 <medfly> yo. i'm too lazy to start working on bigger projects. wondering if there's a booklet or whatever that'll give me smaller tasks to get familiar with popular libs. i hear real world haskell does it but it's not too up to date. suggestions welcome
02:39:34 <julianleviston> medfly: how big?
02:39:50 <julianleviston> medfly:  I’m assuming you’ve done the 99 problems
02:39:56 <medfly> what 99 problems
02:39:58 <julianleviston> medfly:  and euler
02:40:07 <julianleviston> @where 99 problems
02:40:07 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
02:40:20 <julianleviston> medfly:  they’re very simple tho...
02:41:03 <julianleviston> medfly:  and then, after that, the NICTA course… assuming you’ve done all the problems/homework of the cis194 course?
02:41:07 <medfly> well... I feel like I know enough about the basics of the language already... but I haven't gotten to use any libs and every time I think of things I care about it requires picking like 5 different libs and learning them, and each of them is too hard
02:41:38 <medfly> so just bridging the gap
02:41:38 <julianleviston> medfly: have you done the 194 homeworks? they use some libs…
02:42:00 <medfly> ehh from what I've seen so far it's mostly "how to use haskell as it is"
02:42:03 <ocramz> medfly: what are the things you care about, that you'd use Haskell for ?
02:42:06 <medfly> maybe the later stuff is an improvement
02:42:27 <medfly> ocramz: I don't have anything specific in mind
02:42:37 <julianleviston> medfly: the ones around the monads end are pretty involved
02:42:48 <medfly> I just feel like there's *nothing* I can do, besides maybe write elegant algorithmy things
02:42:48 <julianleviston> @where 194
02:42:48 <lambdabot> I know nothing about 194.
02:42:55 <julianleviston> @where CIS194
02:42:55 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
02:43:17 <ocramz> medfly: ban those nihilistic thoughts
02:43:22 <medfly> like I want to write a thing with databases and graphical stuff and I have to look up which is the modern thing for graphics that is still good, learn how to use it, then I have to do the same for every segment of a program I wanna do
02:43:48 <ocramz> I mean, Haskell has funny notation for doing I/O but that's it, you can do plenty of great things with it
02:43:52 <medfly> no shit
02:44:31 <julianleviston> medfly:  so why don’t you take something you know you can do, and do it using a web framework? :)
02:44:41 <medfly> I don't want to touch the web with a ten foot pole
02:45:00 <medfly> also ven the web frameworks in haskell are fucking huge
02:45:11 <medfly> learning how to use like yesod is a task in of itself
02:45:32 <medfly> and it's hard for me to think of something I care about that just uses just a single web framework and nothing else
02:45:32 <julianleviston> well, why don’t you take something you *can* do, then make it work with a database?
02:45:42 <ocramz> medfly: "too lazy", "nothing specific in mind", "no shit", why don't you learn some manners and come back when you actually have something to say?
02:45:49 <medfly> that's exactly what i'm asking for, like a convenient list of stuff that is isolated enough and not huge
02:46:02 <medfly> dude you're linking me to courses I've already studied
02:46:11 <julianleviston> medfly: um… I’m not ocramz.
02:46:53 <medfly> julianleviston: so i'm wondering if someone came up with a decent list of easy enough problems
02:46:57 <julianleviston> medfly: I wonder if that projects book might be for you.
02:47:16 <bennofs> medfly: have you seen http://dev.stephendiehl.com/hask/#basics ? It at least some recommendations under "Network & Web programming"
02:47:26 <hc> medfly: write a simple web server without having to use yesod... http://hackage.haskell.org/package/warp-3.1.3/docs/Network-Wai-Handler-Warp.html
02:47:28 <julianleviston> medfly:  the trouble with “easy enough” is that it’s relative :)
02:48:13 <arahael> And doesn't neccessarily correspond to the time required to think about it.
02:49:14 <julianleviston> medfly: how about this: go write a sudoku solver
02:49:44 <julianleviston> medfly: then, write an anagram finder
02:49:56 <arahael> julianleviston: The latter's easy.
02:50:07 <arahael> julianleviston: foo = foo[::-1]
02:50:17 * arahael hurredly puts in another '='
02:50:50 <medfly> ehh whatevs
02:50:55 * arahael retracts that - that's palindromes.
02:51:01 <julianleviston> arahael: lol
02:51:13 <julianleviston> arahael: how does that work? what is ::-1 ?
02:51:17 <medfly> sudoku solver seems to be like 99% how to solve sudoku 1% how to write code to do that
02:51:37 <hc> medfly: how about a brainfuck interpreter?
02:51:41 <julianleviston> yeah!
02:51:45 <arahael> julianleviston: I also thought that this was python. :)  [::-1] is python's slice syntax.
02:51:47 <dramforever> @bf ++++++++++++++++++++.
02:51:47 <lambdabot>  Done.
02:51:54 <julianleviston> arahael:   LOLLL
02:51:55 <hc> lol
02:52:04 <arahael> julianleviston: (slice from the start (implied), to the end (implied), but -1 steps at a time, thus, in reverse)
02:52:34 <medfly> none of these tasks seem to fit too well, but whatever
02:52:37 <medfly> I'll just come up with something
02:52:37 <medfly> thanks
02:52:42 <julianleviston> medfly:  what *does*? :)
02:54:17 <medfly> if i was good at coming up with these i wouldn't be asking questions like this 
02:54:37 <hc> i know... write a problem creator
02:54:45 <julianleviston> medfly:  but you’re the one creating the constraint.
02:54:47 <hc> you specify your skillset, your interests and it gives you a problem to solve
02:54:51 <julianleviston> medfly:  you have to express that to us.
02:54:56 <julianleviston> hc:  I love it :)
02:55:17 <medfly> a problem mostly designed to familiarize yourself with a common library, not adding too much additional difficulty 
02:56:12 <julianleviston> medfly:  ok… how about using Gloss or Graphics to create a program that will build a compositional animation language?
02:56:15 <medfly> to write a sudoku solver I don't need additional libraries, but I do need to figure out sudoku, that's not really what interest me
02:56:33 <julianleviston> medfly: depends if the sudoku solver has graphics :)
02:56:38 <julianleviston> medfly:  or a GUI.
02:56:42 <julianleviston> medfly:  or uses the DB.
02:56:44 <medfly> ditto for brainfuck, I don't know the language, or even how to interpret it
02:56:48 <montanonic> medfly: it's really more like 10% soduku, 90% having good data structures and functions
02:57:01 <julianleviston> monochrom: agreed… 
02:57:13 <julianleviston> monochrom: but he’s already decided he doesn’t want to look at that.
02:57:21 <medfly> you're highlighting the wrong person
02:57:27 <julianleviston> medfly: no, I’m not.
02:57:37 <montanonic> medfly: I mean Richard Bird includes it in his Thinking Functionally with Haskell book. A huge chapter just on trying to build the solver.
02:57:39 <julianleviston> medfly: I was talking to montanonic.
02:57:47 <medfly> julianleviston: yes, but you were highlighting mono*
02:58:09 <julianleviston> medfly: true. thanks
02:59:00 <int-e> medfly: all you need is to translate sudoku into a set coverage problem; you don't really have to be able to solve sudokus yourself. (speaking from experience here)
02:59:20 * medfly doesn't know what a set coverage problem is
02:59:47 <hc> what is your motivation to learn and use haskell btw?
02:59:57 <julianleviston> medfly: there’s the set of solutions…do you cover it with your program, I’m guessing.
02:59:58 <hc> (i'm just curious)
03:00:26 <julianleviston> medfly: same as the mastermind solver from the CIS194 class…
03:00:43 <medfly> at the moment my main driving force is that I want to have a language that if I want to pick up a project, I already know most of the libs that are good, instead of having to figure them out in the first place, that is a lot of overhead that prevents me from even stargin to work on things
03:01:11 <arahael> medfly: That what keeps me to python, actually.
03:01:27 <julianleviston> arahael: familiarity?
03:01:27 <arahael> medfly: As that's a language that satisfies that condition - for me. :(  Makes it hard to switch languages.
03:01:32 <arahael> julianleviston: Yes.
03:01:51 <arahael> Well, a bit more than that.
03:01:53 <julianleviston> medfly: that’s a pretty general requirement to learn Haskell.
03:02:03 <arahael> It's awareness of to avoid crap.
03:02:20 <medfly> a lot of people have python as "that language"
03:02:29 <arahael> It's awareness of _how_ to avoid crap.
03:02:47 <julianleviston> medfly: I’ve often felt that having a project is a good way to learn… one that you care about.
03:03:05 <medfly> julianleviston: I don't have anything I care enough about to go through the effort of learning how to use 5 different libraries :P
03:03:06 <julianleviston> medfly: sadly, we can’t tell you what you care about, though.
03:03:07 <arahael> Eg, python has pip, which tends to work well, and established good practices.  This is all part of getting familiar with a language.
03:03:21 <medfly> julianleviston: but if I learned some 10 libraries, maybe in the future I will not have that issue
03:03:26 <arahael> Haskell's the same, I'm sure, but I'm still navigating cabal, cabal sandboxes, and there's this 'stackage' thing, as well.
03:03:37 <medfly> julianleviston: Haskell has an additional overhead that many libraries exist for a given thing and it's hard to figure out which is the good one
03:03:38 <montanonic> Right, so it seems like you just need to learn libraries then... not work on a project...
03:03:48 <int-e> medfly: ok, maybe more fundamentally: humans can only do very limited backtracking, so they need to learn all sorts of complicated patterns that hide backtracking; computer programs can rely on backtracking to a much larger extent and hence get away with far simpler deduction rules.
03:03:49 <hc> mceier: hmm, i always learn new libraries as i need them... it's not too hard to figure out how to use most of them, unless they use arrows *g*
03:03:51 <julianleviston> medfly: you can just ask in here.
03:03:55 * medfly is overwhelmed by text
03:04:06 <hc> s/mceier/medfly/
03:06:00 <medfly> I guess I could try to go forward with a project if I just marginally care about it, but I'm the sort of person to give up if I don't care too much about something and it's getting too hard :D
03:06:17 <julianleviston> medfly: sorry we’re not going to be able to help you with that.
03:06:29 <medfly> I believe all people are like that
03:06:34 <montanonic> medfly: are you confident in your Haskell skills currently?
03:06:37 <julianleviston> medfly: I’m not.
03:06:51 <medfly> montanonic: I'm decently comfortable with ym ability to write code that uses zero libraries
03:06:55 <montanonic> Because it will be painful to start a project and then hit a Haskell wall.
03:06:57 <montanonic> Okay.
03:07:24 <medfly> I've gotten that "manipulate lists and trees" thing down
03:07:26 <montanonic> medfly: have you tried learning lens?
03:07:32 <medfly> I did not
03:07:36 <arahael> medfly: Some people find it much easier to carry a project on if they have a buddy doing it with them - for accountability.
03:07:47 <montanonic> Seems ubiquitous enough to know that it's *worth* learning.
03:07:50 <medfly> arahael: now you're telling me I'll have to make a friend too? ;)
03:07:57 <jimmy_> 恩
03:07:59 <medfly> OK. I will try to learn lens
03:08:15 <julianleviston> um
03:08:19 <arahael> medfly: Yes.  But for programming projects, imaginary friends work well too. ;)
03:08:47 <montanonic> If you can learn Lens you'd probably be good learning 90% of Haskell libs. Anyone want to fact check this statement? 
03:08:49 * montanonic is a noob
03:09:10 <medfly> I guess I could just take my 'basic programming class' which was like 'manipulate this thing into a database' and 'manipulate this thing into a database that is simpler and do some networking' then 'do concurrency too'
03:09:25 <julianleviston> montanonic: to me, lens is only really useful if you have a use for it.
03:09:55 <montanonic> medfly: there's also the free parallel and concurrency book
03:09:57 <julianleviston> medfly: Maybe you should go through the concurrency & parallelism book example of making a chat server...
03:10:02 <julianleviston> montanonic: haha jinx!
03:10:06 <montanonic> :)
03:10:33 <julianleviston> medfly: that book is written SO well, too.. makes it super easy mode.
03:11:04 <julianleviston> medfly: takes you through STM as well, which is pretty handy.
03:12:04 <julianleviston> medfly: http://chimera.labs.oreilly.com/books/1230000000929
03:13:03 <medfly> my book list is possibly too big to start adding things to it
03:13:07 <julianleviston> medfly: Feel your pain, though, I think Haskell education material is missing a large chunk between “extreme advanced”, and “absolute beginner”. 
03:13:11 <julianleviston> medfly: it’s free.
03:13:18 <julianleviston> medfly: well, it can be.
03:13:23 <medfly> thank you
03:14:14 <montanonic> julianleviston: Haskell Programming is hardcore filling that gap in for me though. I've covered 600 pages in several days and totally love it.
03:14:25 <arahael> julianleviston: I'm not sure. I found RWH to be perfectly suited.
03:14:29 <julianleviston> montanonic: yeah I burned through that book. Love it.
03:14:55 <medfly> so you guys reckon RWH isn't too out of date?
03:15:00 <julianleviston> arahael: RWH made me go to sleep… it’s great as a reference… and it’s kind of out of date. Also the examples are extremely confusing sometimes, and the language is often broken
03:15:02 <tomus> http://lpaste.net/142280 - what is wrong with this?
03:15:16 <julianleviston> medfly: I’m probably more beginner than you are… and it doesn’t help that all the really “useful” things or “cool” things are written by advanced people, so use extremely advanced features / complex things…
03:15:24 <medfly> mmhm
03:15:50 <Gurkenglas> tomus, in what monad is your do block?
03:15:57 <arahael> julianleviston: It's a heck a lot better than the crappy english that lyah exhibits.
03:16:03 <tomus> Gurkenglas: ST...
03:16:16 <medfly> montanonic: I hope it's really obvious why I need to ask who the author is, that term is impossible to google :D
03:16:27 <Gurkenglas> So "newArray (0, 1) False" is "ST (UArray Int Bool)"?
03:16:47 <julianleviston> arahael: I disagree - the english is a lot better in LYAH… LYAH is kind of … quirky and camp… is that what you mean?
03:17:03 <arahael> julianleviston: The grammar is consistently wrong.
03:17:06 <julianleviston> arahael: I’m talking about like grammar mistakes, or turns of phrase that aren’t grammatically correct.
03:17:19 <julianleviston> arahael: interesting. Find me some? I didn’t find the grammar incorrect at all.
03:17:19 <Gurkenglas> tomus, by the way, "do x <- y; return x" is equivalent to "x"
03:17:29 <Gurkenglas> I mean equivalent to "y" of course
03:17:35 <arahael> julianleviston: Yes, it kept tripping me up. Ok, lets start with the title. "Learn you a haskell".
03:18:02 <arahael> julianleviston: Correct would be. "Learn Haskell Yourself!"
03:18:02 <julianleviston> arahael: yeeeah, let’s not start with the obviously incorrect on purpose title :)
03:18:03 <tomus> Gurkenglas: newArray (0, 1) False" is "ST (UArray Int Bool)"? - I belive so
03:18:18 <arahael> julianleviston: The phrasing actually persists through the book.
03:18:20 <tomus> newArray :: Ix i => (i, i) -> e -> m (a i e)
03:18:45 <arahael> julianleviston: I suppose it might be suitable for those whose first language is american english.
03:18:58 <arahael> Or those familiar with *spoken* american english.
03:19:10 <arahael> julianleviston: However, I'm deaf, so I am used to formal english.
03:19:12 <julianleviston> arahael: yeah, it’s spoken. Designed to be accessible to English speakers.
03:19:32 <Gurkenglas> tomus, you'll have to use that type signature there then. Also if there's another error try not to paste it without linebreaks
03:19:39 <julianleviston> arahael: then that’s *definitely* not the book for you.
03:19:48 <Gurkenglas> (Or you can leave out the type signature.)
03:20:08 <arahael> julianleviston: One wonders why a haskell programmer needs a book that caters exclusively for *spoken* english to be understood.
03:20:21 <arahael> If it was even slightly mor eformal, it'd be far more accessible.
03:20:24 <medfly> well, good luck being a programmer without knowing English disgustingly well
03:20:37 <julianleviston> medfly: a lot of programmers don’t, amusingly.
03:21:06 <arahael> And there's nothing wrong with that!
03:21:10 <julianleviston> arahael: all I can tell you is that a lot of people find that better than not. Usually extreme beginners. If it wasn’t for that book, I probably wouldn’t have tried haskell, honestly.
03:21:25 <medfly> there's plenty wrong with it. spelling mistakes in function names...
03:21:27 <arahael> julianleviston: I suppose you have a point.
03:21:56 <julianleviston> arahael: different strokes for different folks, though.
03:22:03 <Gurkenglas> tomus, http://lpaste.net/142280#a142281
03:22:07 <Gurkenglas> Even HLint told you :D
03:22:24 <arahael> julianleviston: Ruby had a somewhat similar story, but he did it much better - Why The Lucky Spit's guide to Ruby was accessible to spoken english users, AND it wasn't too unformal for those who prefer more formal english.
03:22:38 <julianleviston> arahael: lol actually it’s _Why the Lucky Stiff.
03:22:39 <arahael> julianleviston: Though sadly, Why has gone and disappeared off the internet.
03:22:40 <tomus> Gurkenglas: arh, ST!
03:22:43 <tomus> thank you
03:22:45 <julianleviston> arahael: he did.
03:22:49 <arahael> Yes, _Why. :(
03:22:54 <julianleviston> arahael: :) 
03:23:07 <julianleviston> arahael: I found that book equally as frustrating as LYAH
03:23:15 <julianleviston> arahael: but they’re really not written for people like me.
03:23:31 <arahael> Curious. :)
03:24:08 <medfly> what kind of people? grammar nazis?
03:24:35 <arahael> medfly: No, it's difficult to parse.
03:24:51 <julianleviston> arahael: I just want the unadorned facts, put in concrete terms, quickly and efficiently, embellished by “quirky things” only where there are natural gaps to be filled.
03:25:08 <arahael> julianleviston: And that's why I liked RWH. :) Even if dated.
03:25:18 <julianleviston> medfly: he explained arrays by using a slippery dip analogy, or something, from memory lol.
03:25:33 <arahael> And something about chunky bacon.
03:25:33 <julianleviston> arahael: to me, the ramp up is too big.
03:25:51 <julianleviston> anyway I’m kind of off-topic so I’ll be quiet.
03:26:06 <arahael> julianleviston: Well, the ramp-up was appropriate for me, imho.
03:26:15 <arahael> Haskell isn't my first language. :)
03:26:22 <julianleviston> arahael: mine neither.
03:26:37 <Stratege> if I were to want to do UI programming in haskell, is there by now any library which does it well / is recommended for it? (the wiki mentions there isn't, but it wasn't updated for more than half a year, so I figured I'd ask)
03:27:04 <arahael> Stratege: For what purpose? (I'm still very new to haskell, but apparently gtk's the conservative choice)
03:28:01 <Stratege> the purpose is actually a game, however the UI needs and the game logic are so extremely simple that a decent UI lib would probably be the better choice.
03:28:41 <arahael> Stratege: What sort of game?
03:28:42 <Stratege> I just need a couple graphics and a bit of text on screen with a few clickable buttons and maybe the ability to drag'n'drop.
03:28:48 <arahael> Stratege: 2D? 3D?  Ah, perhaps SDL2.
03:29:28 <jimmy_> http://tieba.baidu.com/p/4080585981
03:30:35 <Stratege> arahael calling it "2D" would be giving it too much credit. but yeah. And SDL2 has in my experience been annoying to get text on screen with (only used it in C++ though)
03:31:14 <arahael> Stratege: SDL on it's on, yes.  You should use another library to render text - freetype's a common one.  But I'm too new to haskell to suggest more.
03:31:48 <Stratege> 'kay, thanks :)
03:37:29 <Gurkenglas> I deleted the Haskell Platform folder and installed min-ghc, now ghc-mod futilely tries to use Haskell Platform. How do I tell it to use min-ghc?
03:39:04 <magneticduck> ugh, let statements in do-notation always trip me up
03:39:23 <bennofs> Gurkenglas: reinstall ghc-mod (did you install it using cabal-install? if so, do it again). Although I have to say, I don't know much about Haskell on Windows
03:40:12 <magneticduck> https://gist.github.com/8be59aaed3ef936b22b1 is a statement in a do-block
03:40:22 <magneticduck> why does it give me a parse error?
03:40:49 <Gurkenglas> bennofs, I went into the ~/atomghcmod sandbox and did cabal install ghc-mod again, making it do a lengthy process, and did many kinds of restarts of other things to see if that would fix it
03:41:08 <bennofs> Gurkenglas: hmm, what version of ghc-mod are you on?
03:41:49 <Gurkenglas> Oh wait there was an ExitFailure 1 now that I look at the cmdline again where I did cabal install ghc-mod
03:42:40 <Gurkenglas> http://pastebin.com/7nZM7ttj
03:43:47 <julianleviston> magneticduck:  I didn’t think you could have “in” in do blocks
03:44:10 <magneticduck> julianleviston: but 'let <equation> in <expression>' is a valid haskell expression
03:44:16 <julianleviston> magneticduck: as in… the let syntax is different inside do blocks isn’t it?
03:44:26 <magneticduck> and 'let <equation>' is a valid statement in a do block
03:44:32 <magneticduck> hm okay
03:44:35 <magneticduck> I guess that's the issue
03:44:39 <Gurkenglas> Someone apparently had that same problem http://lpaste.net/116684 but http://ircbrowse.net/browse/haskell?q=116684 I don't see any solution https://www.google.de/webhp?sourceid=chrome-instant&ion=1&espv=2&ie=UTF-8#q=%22lpaste.net%2F116684%22
03:44:52 <bennofs> Gurkenglas: hmm https://github.com/haskell/old-time/issues/2
03:45:45 <julianleviston> magneticduck: the reason has something to do with everything after let in a do block is “in”...
03:46:28 <julianleviston> magneticduck: because each line is effectively doing >> or >>= \x -> …sthg to do with x.. 
03:46:29 <Gurkenglas> If I install stack, will the atom/sublime addons that definitely/maybe don't support stack still work with "a cabal provided by stack"?
03:47:01 <bennofs> Gurkenglas: ghc-mod does support stack in  its latests version I believe
03:47:11 <Gurkenglas> Should I delete min-ghc before installing stack?
03:47:23 <magneticduck> julianleviston: uh
03:47:31 <julianleviston> magneticduck: lets are effectively “scoped to the entire do block” right?
03:47:38 <julianleviston> magneticduck: assuming I understand them :)
03:47:40 <Myrl> Should I mke a monad with no "return value"?
03:47:53 <Gurkenglas> I mean, does stack look like cabal to things that don't support stack?
03:48:01 <bennofs> Gurkenglas: no
03:48:03 <julianleviston> Myrl: not entirely sure what that means.
03:48:05 <Myrl> Like, say, making a monad that constructs a header? If that is possible, of course.
03:48:08 <magneticduck> julianleviston: well, a let in a do block can just be syntatic sugar; 'let x = y' => 'x <- return y'
03:48:20 <magneticduck> julianleviston: but it should be possible to say 'x <- return <normal let expression>'
03:48:27 <Myrl> As of current, monads seem to be arcane magic to me.
03:48:30 <magneticduck> and thus 'let x = let y = z in f z'
03:48:35 <magneticduck> as a statement in a do block
03:48:45 <albertus1> rest assured, they're not (except for IO)
03:48:47 <julianleviston> magneticduck: the syntax is different inside a do block.
03:48:47 <magneticduck> but apparently not
03:50:41 <julianleviston> magneticduck: in “normal let syntax” there’s no implicit time sequencing. In a monadic context, there is, so the let is really just about setting a value for the remainder of the do block.
03:51:00 <Gurkenglas> What command corresponds to "cabal install ghc-mod" in stack? ._.
03:51:07 <Gurkenglas> (In a sandbox.)
03:51:12 <julianleviston> magneticduck: depending, obviously on which monadic context you have, I guess.
03:51:23 <magneticduck> ...
03:52:13 <magneticduck> I feel like it should still be possible to write normal haskell expressions in do-block bindings
03:52:17 <julianleviston> magneticduck: well I haven’t seen all the monads, so I can’t comment.
03:52:24 <magneticduck> this isn't about particular monads
03:52:27 <magneticduck> it's about the AST
03:52:31 <magneticduck> anyway gtg
03:52:33 <julianleviston> magneticduck: ok
03:52:43 <julianleviston> magneticduck: one is a let form, the other is a let statement
03:53:36 <julianleviston> magneticduck: this can probably help http://stackoverflow.com/questions/8274650/in-haskell-when-do-we-use-in-with-let
03:53:51 <ReinH> julianlevistalskj
03:54:12 <Gurkenglas> https://github.com/commercialhaskell/stack <- "If you just want to install an executable using stack, then all you have to do is stack install <package-name>."
03:54:29 <Gurkenglas> http://pastebin.com/VGsuvjQd
03:54:34 <ReinH> let in do blocks means the same thing as let elsewhere
03:54:35 <julianleviston> ReinH: huh?
03:54:43 <Gurkenglas> (I installed stack a while back, is my version just too old for install?)
03:54:48 <ReinH> ssh issue :/
03:54:57 <Myrl> Yay.
03:55:05 <Myrl> My web server is working.
03:56:57 <Myrl> Oh.
03:57:02 <Myrl> Wrong channel.
03:57:11 <justatech> like how to get details of a thing you search on google like i want to know about world wide web which gives me result of history but not it's operation which query should i use to get every details of it
03:57:13 <Myrl> Anyways, I just realized what I'm trying to do.
03:58:28 <julianleviston> ReinH: you can have let expressions, or let declarations, right...?
03:58:40 <Myrl> Basically, I'm doing something like a writer monad, except without any computation, just always writing.
03:59:06 <ReinH> let in a do block desugares into a normal let
03:59:10 <Gurkenglas> Ah, I ran "stack install ghc-mod" in the wrong cmd line window, 'twas in some cabal project I think
03:59:11 <ReinH> *desugars
03:59:21 <Myrl> I think I can call this the "append monad"
03:59:37 <julianleviston> ReinH: yeah… do {let decls; stmts} = let decls in do {stmts}
04:00:09 <julianleviston> ReinH: which makes putting them with “in” inside a do block kind of… odd… and sometimes wrong.
04:00:13 <ReinH> There's no "time sequencing" in either form
04:00:38 <julianleviston> ReinH: there’s implicit sequencing in a do expression inside a monadic context.
04:00:40 <Myrl> Oh wait, I don't think this willl work, since lists are homogeneous.
04:00:46 <julianleviston> ReinH: >> and >>= implies a sequencing, no?
04:00:58 <Gurkenglas> Why isn't there an instance of Monoid m => Monad ((,) m) that does that?
04:01:07 <ReinH> No more than $ or . does
04:01:19 <julianleviston> ReinH: I don’t agree with that.
04:01:38 <julianleviston> ReinH: maybe the $, but I don’t see how . implies a sequencing.
04:01:45 <ReinH> ...
04:01:51 <ReinH> Exactly the same way that $ does
04:01:55 <julianleviston> ReinH: mind you, it’s fairly likely it does and I just can’t see it :)
04:02:24 <ReinH> f . g = \x -> f $ g $ x, so if $ does then so does .
04:02:34 <julianleviston> ReinH: yeah, yeah, I just realised :) lol
04:03:04 <julianleviston> ReinH: well… ok… so evaluate this…. 10 * (1 + 2)
04:03:12 <julianleviston> ReinH: that’s got implicit sequencing, doesn’t it?
04:03:36 <julianleviston> ReinH: therefore yes, (.) and ($) have sequencing built into them.
04:03:47 <ReinH> For some value of "sequencing", I suppose.
04:04:01 <julianleviston> ReinH: in the sens that one must be reduced before the other
04:04:06 <julianleviston> ReinH: one of the expressions.
04:04:07 <ReinH> So then everything has a sequencing, so it isn't interesting to talk about it.
04:04:16 <julianleviston> however, do syntax makes the explicit sequencing “implicit” by the line order, no?
04:04:22 <ReinH> And there's no need to make a special point about sequencing in a do block
04:04:28 <julianleviston> ReinH: sure there is.
04:04:39 <MarcelineVQ> \n is pretty explicit
04:05:08 <julianleviston> ReinH: because people don’t usually “get” that there’s no implicit sequencing in a let … in expression, but in a do block it’s sequenced by >>
04:05:57 <julianleviston> MarcelineVQ: except that outside of a do block, evaluation order isn’t specified, whereas inside it, it is...
04:06:16 <julianleviston> ReinH: course, I could be completely wrong about this… 
04:06:16 <albertus1> how's that there's no sequencing in a let expression?
04:06:19 <ReinH> ...
04:06:24 <ReinH> A do block desugars into normal Haskell
04:06:27 <MarcelineVQ> the same thing outside of it is nested lambdas
04:06:39 <julianleviston> ReinH: oh, I thought each line “desugared” into >>
04:06:45 <julianleviston> ReinH: no?
04:06:47 <MarcelineVQ> No
04:06:53 <albertus1> let b = a
04:06:55 <albertus1>   c = b
04:06:56 <julianleviston> MarcelineVQ: I guess I need to go study then
04:06:57 <albertus1> in ...
04:07:05 <ReinH> in any event, >> is normal haskell
04:07:09 <julianleviston> ReinH: course it is
04:07:29 <julianleviston> ReinH: but it changes the meaning of newline, doesn’t it?
04:07:34 <julianleviston> ReinH: a do block?
04:07:40 <MarcelineVQ> @undo do {a <- [1..10]; a}
04:07:41 <lambdabot> [1 .. 10] >>= \ a -> a
04:07:44 <ReinH> So why not just say that?
04:07:50 <julianleviston> ReinH: I did.
04:07:52 <ReinH> Rather than talking about sequencing, which seems poorly defined and unnecessarily confusing
04:08:08 <julianleviston> ReinH: I disagree… sequencing means one thing after another. Can it mean anything else?
04:08:23 <ReinH> What does "after" mean?
04:08:31 <julianleviston> ReinH: really?
04:08:35 <ReinH> Yes, really.
04:09:04 <Shockk> `do { x <- m; let y = 2 * x; print y }'  doesn't result in `m >>= let y = 2 * x >> print y' or something
04:09:04 <julianleviston> ReinH: after is a word which means the thing that follows in a context of single dimensionality. Often, we use time as the dimension.
04:09:26 <Gurkenglas> Welp, stack fails just as min-ghc did http://pastebin.com/y0wvQUes
04:09:49 <Shockk> it results in `m >>= (\x -> let y = 2 * x in print x)'
04:09:50 <julianleviston> Shockk: the desugaring of let in do: do {let decls; stmts}	=	let decls in do {stmts}
04:10:41 <Stratege> julianleviston if that were the case, how could we reference variables from inside the do block? say: do {x <- foo; let y = x}
04:10:53 <julianleviston> Stratege: that’s from the report
04:11:10 <ReinH> julianleviston: I don't think your interpretation of the operational semantics is accurate, especially in light of non-strictness
04:11:16 <julianleviston> ReinH: ok.
04:11:35 <julianleviston> ReinH: I need to go study my bird book again!
04:11:40 <julianleviston> ReinH: thanks
04:11:40 <ReinH> Stratege: that is the literal, correct desugaring of let in a do block
04:12:32 <ReinH> Stratege: And the answer is that x is already bound in the scope of the let block:
04:12:46 <ReinH> @undo do { x <- foo; let y = x; return y }
04:12:46 <lambdabot> <unknown>.hs: 1: 36:Parse error: }
04:12:55 <julianleviston> ReinH: closure.
04:12:57 <ReinH> @undo do x <- foo; let y = x; return y
04:12:57 <lambdabot> <unknown>.hs: 1: 33:Parse error: EOF
04:13:04 <ReinH> :(
04:13:25 <supki> @undo do { x <- foo; let {y = x}; return y }
04:13:25 <lambdabot> foo >>= \ x -> let { y = x} in return y
04:13:36 <ReinH> supki: thanks
04:14:50 <Stratege> ^ that was my point, it doesn't move the let outside of the whole thing, since it can't.
04:14:58 <ReinH> Stratege: yes it does
04:15:19 <ReinH> Stratege: no one said it moves it above statements that are above *it*
04:16:10 <ReinH> The desugaring applies to let as the first statement in a do block.
04:16:15 <Stratege> fair enough.
04:16:37 <ReinH> Previous statements will have already been desugared
04:16:54 <julianleviston> ReinH: thanks for being so rigourous.
04:17:03 <ReinH> julianleviston: :)
04:17:11 <julianleviston> ReinH: I *really* appreciate it.
04:18:55 * hackagebot warp 3.1.3.1 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.1.3.1 (MichaelSnoyman)
04:19:20 <Stratege> ReinH yeah I didn't think of the desugaring as being a recursive thing.
04:37:49 <Gurkenglas> Doing stack new ghcmod and stack install ghc-mod in its folder also led to the same stuff
04:38:07 <Gurkenglas> Can I tell it to start over as if my computer had never heard of Haskell?
04:41:46 <fizruk> Gurkenglas: I guess you should remove ~/.stack, ~/.cabal and other places you have Haskell installed in?
04:50:56 <Gurkenglas> I renamed the stack and cabal folder from my %appdata% and tried again, apparently with the same result. (except that it needed to redownload the package index)
04:52:09 <Gurkenglas> Can someone build a ghc-mod executable and upload it somewhere so I can get my atom/sublime working again? ._.
04:52:42 <xandaros> don't founder. ghc, that's where the actual packages are
04:52:59 <xandaros> wow, phone... wow
04:53:17 <Gurkenglas> ???
04:53:43 <xandaros> "don't forget .ghc"
05:00:27 <Gurkenglas> xandaros, also renamed the ghc and ghc-mod folders, same thing happened
05:00:53 <Gurkenglas> (also deleted the new stack folder. there was no new cabal folder.)
05:02:42 <Gurkenglas> Can I founder already?
05:03:13 <Gurkenglas> The asum has reached the []
05:03:56 * hackagebot exherbo-cabal 0.2.0.0 - Exheres generator for cabal packages  https://hackage.haskell.org/package/exherbo-cabal-0.2.0.0 (NikolayOrlyuk)
05:13:54 <hoppfull_> I don't know if you understand this line of code, but if you do; in http://pastebin.com/3Bn1j5K4, is "read" a monad?
05:15:17 <tomus> http://lpaste.net/142282 - is this the intended behaviour of Array. I create one and try to access (0, 0) element only to get error in index array
05:15:41 <pavonia> hoppfull_: I don't think a function can be a monad
05:16:09 <xandaros> hoppfull_: Looks like a normal impure function to me
05:16:19 <albertus1> impure function?
05:17:04 <hoppfull_> Damnit! This is driving me crazy!
05:17:26 <albertus1> i don't understand this syntactically...
05:17:27 <xandaros> referentially opaque, if you prefer
05:17:44 <albertus1> is read(f) equivalent to read f?
05:18:04 <hoppfull_> read takes a function
05:18:06 <xandaros> it's not haskell
05:18:08 <hoppfull_> yes it equivalent
05:18:15 <hoppfull_> I didn't need the parantheses
05:18:19 <albertus1> ah, F#
05:18:31 <albertus1> didn't see the "Syntax" field at the top
05:18:57 * hackagebot synthesizer-filter 0.4 - Audio signal processing coded in Haskell: Filter networks  https://hackage.haskell.org/package/synthesizer-filter-0.4 (HenningThielemann)
05:20:16 <supki> tomus: line 6 creates a one-element array with (0, 10) as the only valid index
05:20:28 <supki> > listArray ((0, 3), (0, 3)) [1..]
05:20:30 <lambdabot>  array ((0,3),(0,3)) [((0,3),1)]
05:20:33 <supki> > listArray ((0, 0), (3, 3)) [1..]
05:20:35 <lambdabot>  array ((0,0),(3,3)) [((0,0),1),((0,1),2),((0,2),3),((0,3),4),((1,0),5),((1,1...
05:21:49 <Gurkenglas> ewww, they've got the arguments transpose
05:21:50 <Gurkenglas> *d
05:22:48 <tomus> supki: yeah I had to guess it, I couldn't see the relevant info in the doc :/
05:22:53 <bennofs> tomus: newArray takes an argument of the form (lowest valid index, hightest valid index)
05:23:13 <bennofs> tomus: it's a bit hidden, but it's documented here: http://hackage.haskell.org/package/array-0.5.1.0/docs/Data-Array-IArray.html#v:array
05:25:21 <tomus> newArray :: Ix i => (i, i) -> e -> m (a i e) <- Builds a new array, with every element initialised to the supplied value.
05:25:27 <tomus> https://hackage.haskell.org/package/array-0.5.0.0/candidate/docs/Data-Array-MArray.html
05:27:31 <bennofs> tomus: yeah, I just assumed that the convention for the (i, i) argument is the same everywhere in the package, and I knew that it's documented somewhere what that argument means. I agree that it should be documented for newArray as well, or perhaps made a type snyonym with documentation
05:28:47 <tomus> I don't really understand what every element is referring to
05:28:57 * hackagebot synthesizer-filter 0.4.0.1 - Audio signal processing coded in Haskell: Filter networks  https://hackage.haskell.org/package/synthesizer-filter-0.4.0.1 (HenningThielemann)
05:29:24 <tomus> i.e. what is the default value for
05:29:31 <tomus> is it just implementation detail?
05:30:25 <pavonia> Each field of the array gets this value
05:31:35 <tomus> but... aray is empty? so no fields get this value. hence confusing
05:32:01 <pavonia> Why is it empty?
05:32:56 <pavonia> If it has zero elements, of course no element gets the default value
05:33:12 <pavonia> But that's just a special case
05:34:11 <tomus> pavonia: "line 6 creates a one-element array with (0, 10)", one element array
05:34:46 <pavonia> Yes, and that element has the default value
05:35:16 <tomus> ah
05:36:14 <pavonia> In your example, if you'd use "print $ a ! (0, 10)" you should get "False" as a result
05:38:18 <tomus> yeah, I got it now
05:47:34 <tiler> Question! Does anyone know how to unwrap values out of a type? I.e., like in this: https://gist.github.com/anonymous/aada72fa1831040fda4e
05:48:05 <tiler> I could run "runTrace", but assuming I'd like to remove "runTrace" and just have a function handle it, how would I go about writing that function?
05:48:11 <Gurkenglas> Has anyone been able to get the latest ghc-mod to work on Windows?
05:49:13 <Gurkenglas> (Can I tell stack to try installing the latest versions of ghc-mod until it finds one that works?)
05:49:13 <magneticduck> tiler: data Trace a = Trace (a, String) ; unTrace (Trace x) = x
05:49:23 <magneticduck> tiler: but everybody just uses a newtype for that
05:49:43 <magneticduck> uh, I mean, record syntax
05:49:59 <magneticduck> (data and newtype collide on a single-constructor single-parameter datatype)
05:51:23 <MarcelineVQ> Gurkenglas: did you try plain 'cabal install ghc-mod'
05:52:04 <tiler> magneticduck: So something more like this? https://gist.github.com/anonymous/6a239ce719383e21c68c
05:52:17 <Gurkenglas> MarcelineVQ, yes, also tried with renamed ghc/ghc-mod/cabal/stack folders in %appdata%, also tried in a stack project instead of globally
05:52:26 <magneticduck> tiler: I don't know why you'd want to do that though
05:52:32 <magneticduck> runTrace === unwrapTrace
05:52:40 <Gurkenglas> Oh wait I thorugh you wrote stack not cabal
05:53:02 <tiler> magneticduck: Well, yes, I know that. If I were to remove runTrace, how do I write it as a function instead?
05:53:19 <Gurkenglas> But yes I also tried with cabal using min-ghc, which (didnt work) in the same way
05:53:31 <tiler> magneticduck: I also seem to get a compile error. "Constructor `T` should have one argument, but has been given none". 
05:53:34 <Gurkenglas> (tried that first actually)
05:53:48 <Gurkenglas> -thorugh +thought
05:55:22 <MarcelineVQ> tiler: try (T a) to elide that error
05:55:29 <julianleviston> tiler: but it *is* a function.
05:55:54 <tiler> MarcelineVQ: That did it, thanks!
05:56:28 <tiler> julianleviston: Yes, runTrace is a function. I understand the concept, but I couldn't remember how to perform the unwrapping outside of a deconstructor in the data declaration.
05:56:49 <julianleviston> tiler: all good :)
05:56:54 <magneticduck> tiler: https://gist.github.com/c6188eed710184a25bd1
05:56:55 <Phillema1n> I'm using ClassyPrelude and linear. ghc tells me "Couldn't match type `Element (V2 Bool)` with `Bool`" - is there some type class instance missing for V2?
05:56:56 <magneticduck> ta daa
05:57:05 <MarcelineVQ> cosntructors with arguments need paranthesis for places you pattern match them
05:57:33 <magneticduck> and substitute newtype for data
05:57:59 <magneticduck> speaking of which, does anybody have any idea why newtype even exists? can't its usages just be inferred from the datatype constructed?
05:58:15 <magneticduck> are there instances where you'd want to make a *data* with a single constructor taking a single argument?
05:58:31 <magneticduck> is the difference between data and newtype somehow semantically useful?
05:58:53 <arkeet> Phillema1n: there's no instance of Element for that
05:59:22 <tiler> magneticduck: My understanding is that data creates a whole new datatype, whereas newtype performs a synonymous "type" value with static checking. Overall, the difference is just to save memory.
05:59:22 <Phillema1n> arkeet: Ok, but could there be? Or is Element meant for something else?
05:59:26 <arkeet> you could write one.
05:59:30 <Phillema1n> Ah, ok.
05:59:34 <arkeet> there just isn't one because mono-traversabel and linear don't depend on each other
05:59:34 <fizruk> magneticduck: for `newtype A a = A a` both A ⊥ and ⊥ are the same
05:59:42 <Phillema1n> arkeet: Ahhh, ok, I see.
05:59:42 <arkeet> mono-traversable
05:59:50 <MarcelineVQ> There's advantages in avoiding unboxing, but no I don't know why that optomization isn't inferred, aside from making it obvious what you're doing to the reader
05:59:58 <Phillema1n> So ClassyPrelude "overloading" foldMap sucks in this case. ;)
06:00:09 <magneticduck> tiler fizruk I understand that newtype is more efficent for this case
06:00:10 <fizruk> magneticduck: for `data A a = A a` those are different things
06:00:19 <arkeet> Phillema1n: you can just use foldMap from Data.Foldable in that case.
06:00:22 <magneticduck> but, why does the language even expose that difference to the programmer?
06:00:28 <arkeet> but yes it's not good.
06:00:31 <magneticduck> ghc does plenty of other magic behind out backs
06:00:41 <fizruk> magneticduck: this can lead to newtype being "less lazy" in some cases
06:00:44 <Phillema1n> arkeet: Yeah, that's what I'm falling back to for now.
06:00:49 <magneticduck> fizruk: okay that's the answer I needed
06:00:58 <magneticduck> I see
06:07:25 <tyrion-mx> Hello, how do I construct and instance of StateT Int (ErrorT String Identity) Int ?
06:07:54 <tyrion-mx> umh, instance is not the right term
06:07:55 <fizruk> tyrion-mx: what do you mean by "instance"?
06:07:55 <delYsid> Is there a library function that does this? <- http://lpaste.net/142283
06:08:11 <fizruk> :t return 0 :: StateT Int (ErrorT String Identity) Int
06:08:12 <lambdabot>     Not in scope: type constructor or class ‘ErrorT’
06:08:12 <lambdabot>     Perhaps you meant ‘Error’ (line 146)
06:08:41 <fizruk> :t return 0 :: StateT Int (Control.Monad.Error.ErrorT String Identity) Int
06:08:42 <lambdabot> StateT Int (Control.Monad.Trans.Error.ErrorT String Identity) Int
06:08:42 <tyrion-mx> fizruk, I am trying to use the state function but I cannot get the type I want
06:08:52 <tyrion-mx> umh
06:09:18 <fizruk> :t state (\s -> (0, s)) :: StateT Int (Control.Monad.Error.ErrorT String Identity) Int
06:09:19 <lambdabot> StateT Int (Control.Monad.Trans.Error.ErrorT String Identity) Int
06:09:21 <julianleviston> monadic value?
06:09:49 <julianleviston> haha that’s no better
06:10:20 <fizruk> tyrion-mx: what are you trying to pass to `state`?
06:10:41 <fizruk> tyrion-mx: maybe you could share some code?
06:11:33 <lpaste> JulianLeviston annotated “No title” with “No title (annotation)” at http://lpaste.net/142283#a142284
06:12:13 <tyrion-mx> :t state $ \s -> (0,2) :: StateT Int (ErrorT String Identity) Int
06:12:14 <lambdabot>     Not in scope: type constructor or class ‘ErrorT’
06:12:15 <lambdabot>     Perhaps you meant ‘Error’ (line 146)
06:12:18 <tyrion-mx> I did this
06:12:29 <fizruk> :t Data.List.Split.splitOn
06:12:30 <lambdabot> Eq a => [a] -> [a] -> [[a]]
06:12:56 <julianleviston> delYsid: that’s from the PLEAC http://pleac.sourceforge.net
06:13:10 <fizruk> :t (state $ \s -> (0,2)) :: StateT Int (ErrorT String Identity) Int
06:13:12 <lambdabot>     Not in scope: type constructor or class ‘ErrorT’
06:13:12 <lambdabot>     Perhaps you meant ‘Error’ (line 146)
06:13:25 <fizruk> :t (state $ \s -> (0,2)) :: StateT Int (Control.Monad.Error.ErrorT String Identity) Int
06:13:26 <lambdabot> StateT Int (Control.Monad.Trans.Error.ErrorT String Identity) Int
06:13:30 <fizruk> tyrion-mx: ^
06:13:36 <tyrion-mx> ok, cool :)
06:13:46 <tyrion-mx> and what if I want to have a "Left" value inside?
06:13:57 <tyrion-mx> how do I do that
06:14:18 <julianleviston> delYsid: stackage hoogle turns up a couple things… Data.List.Utils breakList
06:14:21 <fizruk> tyrion-mx: then you don't use `state`
06:14:45 <julianleviston> delYsid: then there’s Data.List.break, apparently.
06:15:33 <fizruk> :t Data.List.Split.splitWhen -- delYsid 
06:15:35 <lambdabot> (a -> Bool) -> [a] -> [[a]]
06:16:09 <tyrion-mx> fizruk, I mean I want to have an error of type "StateT Int (ErrorT String Identity) Int"
06:16:11 <fizruk> delYsid: not exactly what you asked for though
06:16:21 <tyrion-mx> I'd like to use the "ErrorT" part
06:17:53 <fizruk> :t throwError "oops" :: StateT Int (Control.Monad.Error.ErrorT String Identity) Int
06:17:54 <lambdabot> StateT Int (Control.Monad.Trans.Error.ErrorT String Identity) Int
06:18:31 <fizruk> tyrion-mx: but you should consider using Control.Monad.Except instead of Control.Monad.Error (as documentation suggests)
06:22:14 <tyrion-mx> fizruk, what is the difference?
06:22:21 <tyrion-mx> I don't understand, they seem the same
06:24:29 <tyrion-mx> umh, I found something on stackoverflow
06:25:36 <fizruk> tyrion-mx: well there are some historical reasons for that, I do not know exactly why they had to rename it
06:25:56 <delYsid> nope, splitWhen isn't it.
06:26:16 <the_2nd> how can I parallelize a guarded list function which uses recursion?
06:26:32 <the_2nd> for normal mapping I can use parMap rpar list
06:26:46 <the_2nd> (a:b:xs) = ???
06:28:35 <bernalex> I'm running ghc-mod from git, and realised that lately it doesn't really report any of the problems it used to. anyone else experienced this?
06:28:56 <bernalex> examples: no TLDs missing type signature warnings, no redundant imports warnings, etc.
06:29:47 <suppi> bernalex, I have ghc-mod 5.3.0.0 and I do get those warnings
06:30:28 <bernalex> suppi: is that the release that works with ghc 7.10? I'm running it straight out of git because that release wasn't packaged here yet. maybe I should see if it's in by now.
06:31:01 <suppi> bernalex, yes, and I also installed from git
06:31:15 <bernalex> suppi: I'm running HEAD.
06:31:40 <suppi> bernalex, I tried compiling ghc-mod after git pull this morning but it did not compile :O
06:36:24 <blackhorse> Re type variables, are there any naming restrictions?
06:36:35 <blackhorse> can I use e.g. a word instead of a single letter
06:37:14 <bernalex> blackhorse: yes but that's usually frowned upon, just like using words for non-TLDs in general.
06:37:50 <bernalex> blackhorse: if you have a really complicated function that's really long, then a word might be useful. then again, you shouldn't have a long complicated function to begin with. ;)
06:37:51 <blackhorse> bernalex: what is TLD
06:37:59 <bernalex> blackhorse: top-level declaration.
06:39:00 <blackhorse> Mhh, I don't quite follow you here - I'm referring to type variables, so typical senario would be a very complicated type
06:39:14 <blackhorse> but again, not sure if that's the best approach
06:39:23 <arkeet> short type variables -> you can see the overall structure of the type more easily
06:39:48 <blackhorse> the thing I was trying to achieve - illustrating the relationship between some paramter types...?
06:40:21 <blackhorse> e.g. class Problem p s a c where -- here p is the problem type, s state, a action, c cost
06:41:00 <blackhorse> the Problem class would then need to have a few functions about the relationships between these things
06:41:06 <bernalex> looks like an overcomplicated class. :] but in answer to your question, there is nothing preventing you from naming your type variables.
06:41:35 <blackhorse> bernalex: can you think of an easier way to achieve this?
06:42:05 <blackhorse> i.e. I want different Problem instances that conform to the same API with their own different data structure
06:42:25 <bernalex> blackhorse: not off the top of my head without knowing specifics. also quite busy atm, sorry. :] but if you describe the problem in some detail (maybe with relevant pastebins), I'm sure someone will help you!
06:43:27 <blackhorse> cool no worries; I'll have a go with my own approach first - always good to learn by trying!
06:43:57 <Gurkenglas> http://pastebin.com/y0wvQUes <- Help! I've also tried installing into a project, renaming the cabal, ghc, ghcmod and stack folders in %appdata%, and using stack
06:43:59 * hackagebot haskore-synthesizer 0.0.3.2 - Music rendering coded in Haskell  https://hackage.haskell.org/package/haskore-synthesizer-0.0.3.2 (HenningThielemann)
06:56:03 <delYsid> :t runIdentity $ runExceptT $ runListT $ runStateT (return "" :: StateT (Int,String) (ListT (ExceptT String Identity)) String) (1,"")
06:56:05 <lambdabot> Not in scope: ‘runListT’
06:56:05 <lambdabot> Not in scope: type constructor or class ‘ListT’
06:58:33 <delYsid> :t runIdentity $ runExceptT $ Control.Monad.Trans.List.runListT $ runStateT (return "" :: StateT (Int,String) (Control.Monad.Trans.List.ListT (ExceptT String Identity)) String) (1,"")
06:58:34 <lambdabot> Either String [(String, (Int, String))]
06:58:46 <delYsid> This looks rather sick, I am not sure if I want to work with that ... :-/
07:01:19 <delYsid> A parser that that can propagate errors, or return a list of results.  I have read somewhere ListT shouldn't be used, is there a better way to approach this?
07:05:41 <delYsid> Ah, I can at least eliminate Identity and replace it with Except
07:08:11 <Cale> Well, the most basic sort of (backtracking) parser you might consider is something like  String -> [(a,String)]
07:08:18 <Cale> which is  StateT String [] a
07:08:31 <Cale> So perhaps start there
07:18:58 <Gurkenglas> CofreeT Maybe m looks like the "done right" version of ListT except that it's with a NonEmpty list.
07:19:13 <Gurkenglas> -m
07:33:21 <Mopezz> can anyone help me get started with haskell using haskforce plugin for intellij? Or basicly help me get started at all so i can learn haskell? i feel stupid failing the set up :/
07:33:33 <Gurkenglas> So maybe ListT done right should actually be NonEmptyT?
07:34:42 <Fuuzetsu> Mopezz: should be much easier to get started just by using GHC yourself
07:35:15 <silver> Mopezz, how do you feel to use vim or sublime text (or any other powerful editor) to get started?
07:36:10 <Mopezz> i could give sublime a try. maybe i can recover from my javascript nightmares a year ago
07:36:12 <Cale> Mopezz: Really all you need is a text editor which can automatically convert tabs to spaces (most good editors have a feature like this), and which preserves the indentation of your previous line (essentially all good editors will do this)
07:36:32 <Cale> and then just keep ghci running alongside the source file you're working on
07:36:51 <Cale> Whenever you save your definitions, you can type :r  in ghci to reload the file
07:38:27 <Mopezz> okay. its just ... although i love programming ... i just cant get the hang of command line stuff
07:38:40 <Mopezz> but ill try it :)
07:39:25 <Vivian10583> do people here use :r for running tests too?  I got SLIMEd a few times, so these days I just close the repl and rerun `cabal repl tests`
07:39:40 <delYsid> Cale: I have that already.  In fact, that was a real eye-opener.  However, I will eventually have the need for unresolveable errors.  This is why I am trying to acquaint myself with monad transformers.
07:39:49 <delYsid> With a lot of trial and error, I arrived at
07:39:59 <Cale> delYsid: Well, you could ExceptT the whole thing
07:40:05 <delYsid> type Disambiguator s e a = StateT s (ListT (ErrorT e Identity)) a
07:41:06 <delYsid> (whats the difference between ExceptT and ErrorT, btw?)
07:41:25 <Cale> There isn't one, other than they come from different libraries
07:41:48 <Cale> Actually, I suppose that's right, you can't just ExceptT later
07:42:39 <Cale> Hmm, I suppose Either e is a commutative monad, so it's safe to apply ListT to it
07:42:41 <delYsid> All the other combinations I tried has Either *inside* of the list, which is not what I wanted (I think).
07:42:48 <Cale> right
07:43:44 <delYsid> And the autolifting seems to work as well, somehow, I like this!
07:43:46 <bennofs> Cale: ehm... ErrorT is different from EitherT and ExceptT
07:43:57 <delYsid> But it takes *a long time* for a novice to arrive at an abstraction like this.
07:44:25 <Cale> bennofs: Oh, you mean just because of the constraint?
07:44:30 <Mopezz> thanks guys. sublime just compiled my first hello world in haskell! :)
07:44:30 <bennofs> yeah
07:44:32 <Cale> That's fair
07:44:38 <Cale> Mopezz: great
07:45:04 <bennofs> Cale: and ExceptT and ErrorT come from the same library :)
07:45:39 <Cale> It seems that transformers defines both now :P
07:45:41 <delYsid> bennofs: What *is* the difference?
07:46:02 <Cale> With Control.Monad.Error being deprecated
07:46:11 <bennofs> delYsid: ErrorT e's monad instance has an Error e constraint, which forces your error type to have a generic way to be constructed from a String
07:46:13 <Cale> Control.Monad.Trans.Error rather
07:46:40 <Cale> The differences aren't very substantial
08:06:26 <the_2nd> Currently I call rseq on many values
08:06:48 <Joeization> hello
08:08:02 <the_2nd> whats the correct syntax to call it on many? rseq (a, b, c) ? rseq <$> a <*> b ... ?
08:09:13 <bennofs> :t rseq
08:09:14 <lambdabot>     Not in scope: ‘rseq’
08:09:14 <lambdabot>     Perhaps you meant ‘seq’ (imported from Prelude)
08:11:09 <seschwar> is there a way to use --allow-newer with `stack solver`?
08:14:02 * hackagebot treeviz 2.0.2 - Visualization of computation decomposition trees.  https://hackage.haskell.org/package/treeviz-2.0.2 (DavidBanas)
08:31:08 <tomus> :t [a] -> Maybe a
08:31:09 <lambdabot> parse error on input ‘->’
08:31:18 <tomus> :hoogle [a] -> Maybe a
08:31:45 <tomus> @hoogle [a] -> Maybe a
08:31:48 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
08:31:48 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
08:31:48 <lambdabot> Prelude head :: [a] -> a
08:31:59 <delYsid> I dont get this.  ghci tells me Control.Monad.Trans.Error is deprecated in favour of Control.Monad.Trans.Except, but when I change to that, it is not found.
08:34:13 <lyxia> delYsid: Do you mean that the module not found when you import it?
08:34:50 <glguy> delYsid: Control.Monad.Trans.Except and .Error are just different types. You should figure out which one of the two you actually wanted
08:34:58 <glguy> and then use it.
08:35:10 <glguy> If the deprecation message annoys you, you can turn it off with a flag
08:39:09 <mreh> my GHC 7.4 is bleating about safe haskell
08:39:12 <sudeep1> hey guys 
08:39:27 <mreh> src/Data/Functor/Contravariant.hs:111:1:
08:39:27 <mreh>     StateVar-1.1.0.1:Data.StateVar can't be safely imported! The module itself isn't safe.
08:39:36 <sudeep1> how i did i do program to print numbers from 1 to 10 in haskell in c way simple example
08:39:57 <mreh> sudeep1, this sounds like homework
08:40:06 <sudeep1> hehe
08:40:11 <sudeep1> sorry for typing mistake
08:40:13 <mreh> we can't help you
08:40:17 <sudeep1> this is no homework
08:40:34 <sudeep1> mreh: others may just i need a quick solution
08:41:05 <sudeep1> mreh: do me a kind favor
08:41:06 <mreh> > mapM print [1..10]
08:41:07 <lambdabot>  <IO [()]>
08:41:29 <mreh> > mapM putStrLn [1..10]
08:41:30 <lambdabot>      No instance for (Enum String)
08:41:30 <lambdabot>        arising from the arithmetic sequence ‘1 .. 10’
08:41:30 <lambdabot>      In the second argument of ‘mapM’, namely ‘[1 .. 10]’
08:41:40 <bennofs> the first one is correct
08:41:48 <mreh> oops
08:42:50 <sudeep1> mreh: no the c way , simpler one this i know 
08:42:58 <sudeep1> mreh: i mean the simple way
08:43:01 <mreh> this is haskell, not C
08:43:47 <mreh> what could be more simple than this?
08:44:37 <sudeep1> mreh: i mean without using map
08:44:38 <mreh> whats the theory or stackage? I never have to fight with cabal again?
08:44:55 <Welkin> mreh: it doesn't work that way
08:45:04 <Welkin> I have had package conflicts using stackage
08:45:13 <mreh> ok
08:45:32 <mreh> Welkin, even using cabal-dev?
08:45:45 <mreh> or cabal sandboxes as they are now know
08:45:50 <Welkin> yes
08:46:01 <Welkin> nothing is a perfect solution
08:46:35 <mreh> Haskell developers seem to be a bit more gung ho about releasing package versions
08:46:37 <delYsid> I think I want Except, and transformers-compat did the trick...
08:47:48 <mreh> haskell saves you a million hours writing the thing, but then you lose it all trying to compile its dependencies
08:47:54 <mreh> I might be generalising
08:48:26 <mreh> sudeep1, there are explicit loops in haskell
08:48:31 <mreh> you have to write a recursive function maybe
08:48:49 <mreh> although C can also do recursion
08:49:11 <mreh> but the obvious C implementation would be a for loop
08:49:40 <mreh> there aren't explicit loops in Haskell*
08:50:20 <mniip> but there are
08:50:26 <mniip> the Cont monad
08:51:02 <mreh> shush, you're confusing him
08:51:02 <mreh> and me
08:52:43 <bennofs> sudeep1: how about this
08:52:58 <acro> @src digitToInt
08:52:58 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
08:53:01 <Welkin> what is with the stack resolver?
08:53:02 <sudeep1> bennofs: which one?
08:53:12 <bennofs> sudeep1: wait
08:53:19 <Welkin> why is it too dumb to try package versions other than the latest?
08:53:22 <sudeep1> bennofs: waiting :)
08:53:27 <glguy> acro: The best way to see the source is to click the [source] links in the documentation
08:53:28 <Welkin> it tries the leatest and then just fails without trying anything else
08:53:38 <Welkin> latest*
08:54:22 <bennofs> λ: fix (\loop i -> when (i < 11) $ print i >> loop (i + 1)) 1 -- ^ sudeep1 
08:54:47 <sudeep1> bennofs: wow :D so comple one i want the simplex of all
08:54:48 <bennofs> needs import Control.Monad and import Data.Function
08:55:00 <bennofs> it's the C way :=)
08:55:01 <sudeep1> bennofs: aanyway thanks i got over it
08:55:23 <bernalex> bennofs: that's almost sufficiently ugly to be C.
08:55:28 <mniip> bennofs, now just do all that in lazy StateT so that you can have parameterless goto
08:55:30 <silver> lol
08:55:59 <bernalex> need to add redundant bracers though.
08:56:05 <monochrom> sudeep1: I think there are conflicts between "simplest" and "the C way". please drop "the C way". then you can simply "print [1..10]"
08:56:17 <bennofs> monochrom: mapM print [1..10] you mean?
08:56:22 <mniip> label \x ->
08:56:22 <mniip> goto x
08:56:28 <mniip> where label = fix; goto = id
08:56:31 <glguy> traverse_, while we're correcting each other
08:56:32 <mreh> why doesn't lambdabot print anymore?
08:56:39 <monochrom> bennofs: is there a strong requirement of "one number per line"?
08:56:45 <mreh> oh, she only evaluates
08:56:53 <bernalex> they just asked for the numbers 1->10, so print [1..10] is indeed sufficient.
08:56:56 <bennofs> monochrom: oh, heh, I noticed a little bit after I wrote that 
08:57:12 <sudeep1> monochrom: you got me thanks bro
08:57:24 <mreh> intercalate ' ' . map show $ [1..10]
08:57:27 <mreh> > intercalate ' ' . map show $ [1..10]
08:57:27 <monochrom> I am fine with adding mapM_ if it is really requied
08:57:28 <lambdabot>      Couldn't match expected type ‘[Char]’ with actual type ‘Char’
08:57:28 <lambdabot>      In the first argument of ‘intercalate’, namely ‘' '’
08:57:28 <lambdabot>      In the first argument of ‘(.)’, namely ‘intercalate ' '’
08:57:36 <mreh> > intercalate " " . map show $ [1..10]
08:57:38 <lambdabot>  "1 2 3 4 5 6 7 8 9 10"
08:57:41 <mreh> woo
08:57:52 <Malachite> hello
08:57:55 <bernalex> print "1 2 3 4 5 6 7 8 9 10"
08:58:01 <bennofs> :)
08:58:13 <mreh> > "1 2 3 4 5 6 7 8 9 10"
08:58:14 <monochrom> but "print [1..10]" also tells you new information: unlike C, in Haskell "print" supports more than basic types.
08:58:15 <lambdabot>  "1 2 3 4 5 6 7 8 9 10"
08:58:24 <Malachite> do I learn Haskell or read Sicp and learn scheme first
08:58:45 <glguy> That depends on which language you want to know
08:58:47 <bernalex> > print "numbers from 1 to 10"
08:58:49 <lambdabot>  <IO ()>
08:58:59 <monochrom> heh
08:59:00 <bernalex> Malachite: that question doesn't make much sense.
08:59:09 <Malachite> oh
08:59:22 <mniip> print "1 10"
08:59:25 <monochrom> I like answering that kind of questions. My answer: learn both concurrently
08:59:45 <Malachite> at the same time ?
08:59:53 <bernalex> Malachite: what is your purpose with doing either?
08:59:57 <monochrom> in fact, sometimes I even answer: use your left eye and right brain to learn one, right eye and left brain to learn the other. at the same time.
09:00:31 <bernalex> monochrom: that's ableist!!!one!
09:00:47 <Malachite> Bernalex, I want to code in scheme for implementing algorithms
09:00:56 <Malachite> And haskell look nice
09:00:56 <monochrom> fortunately, so far I haven't run into "which of the following 3 things should I learn?" yet :)
09:01:05 <bernalex> Malachite: uh then I would learn scheme, because haskell is not scheme.
09:01:42 <Malachite> Hm.
09:01:45 <bernalex> Malachite: why do you want to implement algorithms with scheme instead of another language, e.g. haskell?
09:02:25 <eta> i like scheme for experimenting, i like haskell for putting it into stone
09:02:29 <eta> that's my personal prefernce though
09:02:42 <Malachite> Because it's not mixing code and data and I will programm better
09:02:49 <Malachite> Or that was what was said to me
09:03:21 <bernalex> Malachite: it sounds like nonsense. :]
09:03:33 <Malachite> I feel silly
09:03:38 <bernalex> eta: I prefer haskell for experimenting too. types are yummy.
09:03:46 <monochrom> wait, I think scheme is the one allowing mixing code and data
09:04:01 <eta> monochrom: so doeas assembly
09:04:10 <bernalex> Malachite: don't. programming is confusing. especially when you don't know it. :] just think about what *you* want to do.
09:04:31 <Welkin> how can I get stack to install a new package without figuring out the exact version I need manually?
09:04:34 <Malachite> I want to be an algorithmic wizard
09:04:39 <Welkin> stack seems far less flexible than cabal in this regard
09:05:36 <eta> Malachite: take it from  lisp programmer: macros are powerful, but often too powerful
09:05:40 <bernalex> Malachite: the choice of programming language is not the most important thing here. some algorithms are in fact easier to implement in C than in Haskell.
09:06:27 <bernalex> Malachite: I suggest you read up a bit on what the common cited advantages are for some popular-ish languages, and then just pick one and get going. your algorithms knowledge will transfer to other languages.
09:07:16 <bernalex> Malachite: *I* would choose Haskell. I think Haskell is great. and we in #haskell would enjoy helping you on your way. but you should not choose Haskell being completely uninformed about other languages.
09:07:17 <Welkin> has anyone encountered this?
09:07:30 <Welkin> I am regretting using stack now for this project
09:07:34 <Malachite> Okay !
09:07:46 <bernalex> Welkin: I've yet to actually use Stack. I don't believe the hype, lol.
09:07:55 <Malachite> I did a lot of C and a bit of python
09:07:59 <eta> i used it because Yesod does it
09:08:05 <eta> mmm, C is great. <3 C
09:08:25 <mreh> I'm addicted to PHP
09:08:27 <bernalex> Malachite: then there are huge trade-offs to be considered. C and Python are considerably more low-level than Haskell. Haskell is a denotative language -- which means you try to express what things are, rather than how to compute them.
09:08:33 <mreh> or is that PCP?
09:08:39 <eta> mreh: you should stop. 
09:08:56 <eta> Start with Prolog :^)
09:09:24 <Malachite> Okay, I must admit you lost me
09:09:33 <mniip> prolog hypertext processor
09:09:42 <eta> I'd use the crap out of that, mniip
09:09:52 <Malachite> I got a book, Real World Haskell, is it any good ?
09:10:01 <mreh> Malachite, nah
09:10:05 <eta> I use it for refernce sometimes. It's okay.
09:10:10 <mreh> joking
09:10:11 <eta> haven't touched it in a while.
09:10:13 <mreh> it's pretty good
09:10:24 <mreh> but If you're learning from scratch look at LYAH
09:10:26 <eta> i don't find LYAH better, I would actually say Real World Haskell is better
09:10:33 <ayc> hello. where can i learn about the so-called 'point-free' idiomatic style as a beginner
09:10:37 <mreh> eta: really?
09:10:40 <mreh> as a beginner?
09:10:40 <bernalex> Malachite: see https://secure.plaimi.net/~alexander/tmp/2015-09-11-THUG-01.html#16 from a presentation I did. on top you have imperative code where you explain "how to get X". on the bottom is denotative code, "X is this".
09:10:58 <eta> mreh: I was already a seasonned programmer when I started haskell, so I can't really say the best for a beginner
09:11:01 <nshepperd> real world haskell is good, I think, but it's way out of date now
09:11:07 <nshepperd> regarding libraries and stuff
09:11:20 <eta> Yeah, Parsec has changed quite a bit since it was last published.
09:11:22 <mreh> haskell changes so much
09:11:23 <mniip> Malachite, it is primitive, but unlifted, we never manipulate Real World Haskell directly, it's only used in the type system to parametrize Programming#
09:11:24 <bernalex> mreh: RWH is quite outdated in some aspects, but it does a good job at showing what goes into "real world Haskell", as implied by the title. it has *a lot* of case studies if you enjoy learning from those.
09:11:46 <bernalex> sorry Malachite ^ that was for you.
09:11:47 <glguy> You'll still learn about Haskell, just some of the details of libraries will be wrong
09:12:03 <mreh> so what's all this business about safe importing?
09:12:08 <mreh> I just got back from a year off haskell
09:12:25 <mreh> is it to do with safe haskell?
09:12:29 <bernalex> Malachite: I'd suggest looking at http://learnyouahaskell.com/ and https://github.com/bitemyapp/learnhaskell -- they are two quite different approaches to learning Haskell, but one of them might work very well for you.
09:12:30 <joco42_> what is the # doing in I32# in this line https://github.com/ghcjs/ghcjs-base/blob/master/GHCJS/Marshal/Pure.hs#L80 ?
09:12:39 <glguy> mreh: The extension to read about is SafeHaskell
09:12:46 <mreh> glguy, thanks
09:12:49 <glguy> err, just safe, actually
09:12:51 <joco42_> is that some kind of ghc/ghcjs extension?
09:13:00 <mreh> looks like GHC
09:13:11 <glguy> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/safe-haskell.html
09:13:12 <bernalex> Malachite: reading the first couple of chapters of LYAH, or doing the first two weeks of exercises in cis194 (linked in that github) won't take too long, and will be enough for you to asess "is this useful to me".
09:13:43 <Malachite> Okay
09:13:47 <mreh> so are safe imports redundant in later version of GHC?
09:13:51 <Malachite> Thanks for all the ressources
09:14:02 <mreh> looks like this library was developed without them
09:14:13 <mreh> when my GHC is expecting a safe import
09:14:16 <bernalex> Malachite: if you are in Trondheim, I'm holding a beginners' workshoppe Tuesday, so you're welcome to join. :p
09:14:39 <Malachite> I'm in France...
09:14:48 <eta> Doh i thought I just pasted a massive dump into IRC, it was just ssh lagging....
09:14:58 <bernalex> only a few thousand kilometres. that never stopped anybody. ;)
09:15:19 <glguy> mreh: No, they aren't redundant, they still mean the same thing they used to
09:16:30 <Welkin> god damn
09:16:35 <Welkin> stack has so many problems
09:16:42 <Welkin> I don't see it solving anything
09:16:46 <Welkin> only creating more problems
09:17:18 <Welkin> I still had to manually figure out the package version that would work with my current setup and specify that
09:17:41 <eta> Welkin: welcome to programming
09:17:54 <Welkin> eta: I meant in comparison to cabal
09:18:07 <eta> We're so oversaturated we look for problems with are made up solutions
09:20:24 <Welkin> oh, and for some reason it failed when I tried to use the resolver because it couldn't figure out the version of /usr/bin/strip
09:21:12 <Malachite> what do you build with haskell everyone ?
09:21:16 <Fuco> putStrLn is lazy? WHen I run my haskell program from terminal it prints every second like it should but when I run it from shell script it doesn't print anything until I kill the script
09:21:45 <bernalex> Malachite: pretty much every software I want to develop these days I'll use Haskell if I have the choice.
09:22:46 <glguy> Fuco: It's not lazy, but it can use block buffering if it determines that it's not outputing to a terminal
09:23:03 <Welkin> Malachite: I use it primarily for web applications
09:23:09 <Fuco> glguy: right, so I just call hFlush manually
09:23:21 <glguy> or manually set the buffering mode
09:23:21 <Welkin> Malachite: that is all I build though, so I use haskell for everything
09:24:06 <Welkin> Malachite: soon even to replace the small amount of javascript using ghcjs
09:24:28 <Fuco> glguy: can I do that on stdout?
09:24:38 <glguy> yeah
09:25:06 <mreh> what marks a module as being unsafe?
09:25:09 <mreh> with GHC
09:25:18 <mreh> use of unsafeperformIO?
09:25:59 <glguy> mreh: Did you read the section of the documentation I linked?
09:26:20 <mreh> glguy, not properly
09:26:48 <mniip> mreh, use of modules marked unsafe, and, iirc, some internal-ish extensions
09:26:50 <Fuco> glguy: awesome, got it, thanks :)
09:27:08 <mreh> I'm just trying to compile the turtle library
09:27:15 <mreh> on GHC 7
09:27:18 <mreh> 7.4
09:28:15 <mreh> I'm so confused
09:28:48 <mreh> it won't compile, but the offending module isn't imported with the safe keyword
09:29:02 <mreh> src/Data/Functor/Contravariant.hs:111:1:
09:29:02 <mreh>     StateVar-1.1.0.1:Data.StateVar can't be safely imported! The module itself isn't safe
09:29:28 <Welkin> mreh: that version of ghc is very old
09:29:32 <Gurkenglas> ghc-mod won't build on my machine. Can I make stack or something else try installing other versions of ghc-mod until it finds one that works?
09:29:37 <C_Terrik> hi folks. I'm just beginning to program and i'm looking for some help with C. does anybody know of a place where i can go to get some help?
09:29:42 <Welkin> mreh: update to 7.8.4 at least, or 7.10.2
09:29:43 <Gurkenglas> If not, how do I do that manually?
09:29:46 <mreh> Welkin, even so
09:29:52 <mreh> safehaskell has been in since 7.2
09:30:19 <Gurkenglas> (Oh hey that second was was actually googleable.)
09:30:26 <Welkin> Gurkenglas: lol, I was asking this same question about stack resolving dependencies
09:30:30 <Welkin> Gurkenglas: but it does *not*
09:30:37 <mreh> this library should have been compiled on 7.2+
09:30:37 <Welkin> Gurkenglas: I had to manually resolve the dependencies
09:30:43 <Welkin> so stack is worse than cabal in this regard
09:30:50 <Gurkenglas> cabal didnt work either
09:31:25 <Gurkenglas> Both do pretty much this http://pastebin.com/dRv6k5US
09:31:49 <Gurkenglas> "old-time-1.1.0.3" won't build. Can I have it try other versions of old-time within the bounds?
09:32:10 <Gurkenglas> (How do I even find out the bounds intersection?)
09:32:24 <jstimpfle> C_Terrik: You need help with C, then why do you post to #haskell. But send me a message and I can see if I can help you
09:33:04 <Gurkenglas> Can I somehow obtain a visualization of the dependencies?
09:33:14 <Gurkenglas> *dependency graph
09:33:44 <mreh> Gurkenglas, there's a tool that outputs the graph in dot format
09:33:55 <mreh> and you can run it through dot to get a graph
09:34:01 <glguy_> I think stack has a dependency graph drawing command
09:34:47 <glguy_> Those old-time build errors appear to be related to using Windows
09:35:10 <Gurkenglas> Indeed I am using windows
09:35:31 <mreh> I can't remember the name
09:36:06 <mreh> https://hackage.haskell.org/package/graphmod
09:36:11 <mreh> there's a library
09:36:19 <Gurkenglas> Up to now I had an old version of ghc-mod that worked, I don't know which.
09:38:02 <Gurkenglas> http://pastebin.com/sJ05XUwK <- Can I have it do that automatically? It also said such a thing about ghc-mod until I added that
09:39:21 <Gurkenglas> (stack solver says "No needed changes found" on both counts)
09:45:19 <Alcherk> exit
09:45:28 <Alcherk> @exit
09:45:28 <lambdabot> Maybe you meant: quit elite
09:45:34 <Alcherk> @quit
09:45:34 <lambdabot> Not enough privileges
09:45:47 <Gurkenglas> Try /quit
09:46:07 <ttt_fff>  /quit Gurkenglas
09:46:40 <ttt_fff> http://bash.org/?362137
09:48:03 <orion> What is it called when a parameterized data definition contains a class restriction?
09:49:51 <Gurkenglas> How do I point graphmod at ghc-mod?
09:54:04 <diracdelta> I ran into a couple of packages yesterday that seemed to have problems running their configure script when the script was executed using ubuntu's dash shell; is this a common problem?
09:59:19 <Shockk> quick question,
10:00:17 <Shockk> if I want `x |%| y |%| z' to be parsed as `(x |%| y) |%| z)'
10:00:45 <Shockk> is that left or right associativity?
10:00:50 <jstimpfle> left
10:01:02 <Shockk> ahh, thanks
10:01:48 <jstimpfle> you should just try :-). E.g 8 / 4 / 2
10:02:25 <diracdelta> nm, can't reproduce it anymore, probably a temporary shell environment issue.
10:20:05 <lpaste> athan pasted “OverloadedStrings borked?” at http://lpaste.net/142295
10:20:31 <athan> Hey everyone, can someone explain to me why on line 20, the string literal is assumed to be `String`?
10:21:24 <athan> The actual error -> http://lpaste.net/142296
10:21:31 <Gurkenglas> Hmm. Try uninlining it?
10:22:11 <Gurkenglas> (wee, referential opacity)
10:22:33 <Welkin> holy fucking shit
10:22:46 <Welkin> this api binding I am trying to fix/update is using tabs
10:22:50 <Welkin> O.o
10:23:00 <lemevi> tabs > *
10:23:03 <athan> -.- Gurkenglas even putting it in it's own let statement won't coerce it
10:23:03 <lemevi> heathen
10:23:04 <athan> wtfs
10:23:23 <athan> Welkin: NOOOOOOOOO
10:24:03 <jstimpfle> what is parseUrl? Maybe that returns String?
10:24:17 <Welkin> athan: this is realy a mess though
10:24:23 <Welkin> he didn't even use RecordWildCards!
10:24:29 <Welkin> I'll fix it! 
10:24:32 <athan> jstimpfle: Right, but with -XOverloadedStrings, _all_ string literals are polymorphic to `IsString a => a`
10:24:33 <fizruk> athan: LANGAUGE?
10:24:43 <athan> AH
10:24:57 <athan> thank you fizruk, normally GHC(-mod) yells about that
10:25:26 <Welkin> also, this is making me learn about ExceptT and errors > 2.0
10:25:39 <Gurkenglas> Apropos ghc-mod, it still won't install. Surely someone is on Windows and successfully installed the latest version?
10:25:46 <Welkin> updating packages last updated 2 years ago...
10:26:19 <athan> Welkin: I've never really found a use for RecordWildCards :s
10:26:27 <athan> I really like ExceptT :)
10:26:55 <athan> I've found a use for `note' e mx = fromMaybe (throwError e) $ pure <$> mx` to be useful
10:27:26 <athan> or really I should call it `noteError
10:27:46 <Gurkenglas> ghc-mod has been using old-time (which is the package that errors) since 0.5.2, surely there's a way to get it to install when I had it installed not a day ago?
10:28:57 <Welkin> athan: it is amazing
10:29:06 <dbushenko> can anyone show an example of working with one-to-many relations using persistent?
10:29:07 <Welkin> athan: I use it constantly for large data structure
10:29:15 <Welkin> it is especially useful in web applications
10:29:39 <fizruk> athan: I also use them (in web application)
10:29:45 <Welkin> dbushenko: did you read the chapter on persistent in the yesod book?
10:30:05 <muesli4> Has anyone ever used GDate (from System.Glib), and if so, how do you format it?
10:30:08 <athan> dbushenko: `  userAffiliated :: UserId`
10:30:15 <Welkin> you simple reference the id of the table
10:30:22 <Gurkenglas> How do I point graphmod at a package on hackage?
10:30:27 <athan> Welkin: You might dig my nested-routes update... maybe :|
10:30:41 <dbushenko> Welkin, haven't found one-to-many example there
10:30:42 <athan> it has bau5 authentication / authorization now
10:30:56 <dbushenko> athan, ?
10:30:57 <athan> dbushenko: :|
10:31:13 <athan> dbushenko: Every table you make has an implicit `FooId` field
10:31:26 <dbushenko> ah, sorry, maybe I just missed it
10:31:32 <athan> use that in your field to say "this Bar has one Foo"
10:31:48 <Welkin> dbushenko: http://www.yesodweb.com/book/persistent#persistent_relations
10:31:54 <dbushenko> thanks
10:32:14 <athan> dbushenko: np :)
10:34:31 <Welkin> this file was infested with tabs
10:34:37 <Welkin> how can this happen
10:35:08 <Welkin> I was wondering why when I tried to red-indent the code differently it was deleting random characters...
10:35:16 <Welkin> re-indent*
10:43:54 <kristof> I'm getting warnings for toplevel functions without types
10:44:01 <kristof> How do I turn this off? Flymake is annoying me.
10:45:09 <exio4> giving those top-level functions type signatures? :p 
10:45:48 <athan> kristof: Turn off -Wall?
10:48:39 <kristof> athan: I'm not running GHC, I'm just letting haskell mode highlight warnings.
10:48:53 <kristof> athan: So I take it I can change the settings of flymake somewhere
10:48:56 * athan shrugs
10:48:59 <athan> :\
10:49:00 <kristof> "GHC Command", I think I remember seeing that.
10:49:31 <Welkin> oh god
10:49:32 <Welkin> hahaha
10:49:33 <fizruk> kristof: you should be able to turn those warnings off, but I recommend you to add signatures
10:49:34 <Welkin> this is crazy
10:49:39 <Welkin> these bindings are so outdated 
10:49:55 <Welkin> instead of using OVerloadedStrings, he made his own function to manually convert them
10:50:01 <Welkin> I'll rescue it!
10:50:52 * athan shows Welkin...
10:50:57 <athan> @hackage monoid-subclasses
10:50:57 <lambdabot> http://hackage.haskell.org/package/monoid-subclasses
10:51:05 <athan> :|
10:51:41 <athan> `TextualMonoid` is basically `IsString`, but with `(<>)`, singleton, and all that jazz :)
10:51:49 <Welkin> nice
10:52:01 <Welkin> I think this library could use some love from Arrow as well (for tuples)
10:54:10 <glguy> There's no "love" in "Arrow love"
10:58:28 <kristof> uh, arrows.
10:58:30 <kristof> *ugh
11:04:07 * hackagebot propellor 2.8.1 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-2.8.1 (JoeyHess)
11:05:40 <delYsid> > let f _ _ [] = return []; f p l (x:xs) = p x >>= \x' -> (x' :) <$> f p (l - 1) xs
11:05:42 <lambdabot>  <no location info>:
11:05:42 <lambdabot>      not an expression: ‘let f _ _ [] = return []; f p l (x:xs) = p x >>= \x'...
11:06:05 <delYsid> @let f _ _ [] = return []; f p l (x:xs) = p x >>= \x' -> (x' :) <$> f p (l - 1) xs
11:06:07 <lambdabot>  .L.hs:160:45:
11:06:07 <lambdabot>      Ambiguous occurrence ‘f’
11:06:07 <lambdabot>      It could refer to either ‘L.f’, defined at .L.hs:159:1
11:06:11 <muesli4> what is the Parsec parser called to parse exactly one symbol?
11:07:25 <jstimpfle> muesli4: I think it's simplest to use "string"
11:07:39 <muesli4> jstimpfle: not satisfying :D
11:08:35 <jstimpfle> i mean the "string" function from parsec right? i think it's not possible by contract to parse only a certain amount but it's a long time i've used parsec...
11:08:55 <digitalpeer> I am trying to create a ghc 7.10.2 cross compiler for arm with ./configure --target=arm-none-linux-gnueabi --without-ld.gold
11:09:06 <digitalpeer> results in: ghc-cabal: Cannot find the program 'ld'. User-specified path 'no' does not
11:09:08 <athan> Would it be wise to embed Attoparsec parsing in an Aeson FromJSON instance?
11:09:17 <delYsid> I can't figure out how to add Either e around this function.
11:09:36 <digitalpeer> refer to an executable and the program is not on the system path.
11:10:08 <delYsid> I guess it boils down to needing to work in two monads at once, Except and List.
11:10:16 <fizruk> delYsid: why do you need l there? isn't it just sequence?
11:10:23 <athan> delYsid: traverse ftw
11:10:34 <fizruk> traverse, yes
11:10:37 <fizruk> :t traverse
11:10:39 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
11:10:48 <fizruk> :t mapM
11:10:49 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
11:10:51 <delYsid> fizruk: It would be just sequence if I didn't need l :-)
11:11:10 <fizruk> delYsid: what are you going to use it for?
11:11:28 <fizruk> delYsid: to tell which computation failed?
11:11:42 <delYsid> oh, now I see, wait...
11:11:50 <athan> >:D
11:12:18 <delYsid> let f _ _ [] = return []; f p l (x:xs) = p l x >>= \x' -> (x' :) <$> f p (l - 1) xs
11:12:45 <muesli4> jstimpfle: usually I just wrote my own parser library, but for a bigger project I wanted to try Parsec. Is there a better alternative?
11:12:47 <delYsid> i.e, l is passed to p, and decremented according to x'
11:13:12 <fizruk> :t \p -> sequence . zipWith p [1..]
11:13:13 <lambdabot> (Enum a1, Monad m, Num a1) => (a1 -> b -> m a) -> [b] -> m [a]
11:13:54 <delYsid> nah, sequence wont work.
11:14:21 <fizruk> delYsid: then you're not telling something else)
11:14:29 <jstimpfle> muesli4: there's at least attoparsec. There are speed / ease of use / error messages tradeoffs but I'm the wrong to ask. Btw. Parsec has also "anyChar" and "satisfy", look them up
11:14:53 <delYsid> let f _ _ [] = return []; f p l (x:xs) = p l x >>= \x' -> (x' :) <$> f p (l - g x') xs
11:14:54 <fizruk> delYsid: is it that (l - 1) is not actually pure code (in your actual problem)?
11:15:07 <athan> Also, MegaParsec is a thing I think :|
11:15:08 <fizruk> aha, I knew it
11:15:15 <delYsid> see, the value of l passed to p will be dependant on the path taken
11:15:18 <athan> I really want to try Earley parsers asap
11:15:29 <delYsid> its not just the same for every element.
11:15:53 <Cale> What's the question?
11:16:16 <digitalpeer> freenode forgot password
11:16:20 <Cale> muesli4: Perhaps you're looking for token/tokenPrim?
11:16:33 <lethjakman> So, I'm looking at this function:
11:16:38 <lethjakman> requireAuthId = maybeAuthId >>= maybe handleAuthLack return
11:16:43 <athan> Is there a better way to encode error messages in Aeson other than `mzero`? L:(
11:16:45 <lethjakman> How is that last bit working?
11:16:48 <delYsid> Cale: How to add Either e around the return value of f (given that p also returns Either)
11:16:54 <lethjakman> It takes maybeAuthId and applies it to a maybe?
11:17:01 <athan> J:
11:17:02 <Cale> :t maybe
11:17:03 <lambdabot> b -> (a -> b) -> Maybe a -> b
11:17:28 <delYsid> fizruk: Yes.
11:17:39 <monochrom> lethjakman: what is the type of maybeAuthId?  (I never trust names.)
11:17:47 <muesli4> Cale: exactly, thanks!
11:17:57 <lethjakman> monochrom: maybeAuthId :: HandlerT master IO (Maybe (AuthId master))
11:18:31 <Cale> lethjakman: It first executes maybeAuthId, getting some result of type Maybe AuthId (or something like that), and then if that result was Nothing, it then executes handleAuthLack, otherwise if it's Just aid it executes (return aid)
11:19:01 <lethjakman> Cale: Oh!
11:19:09 <lethjakman> Why is it casing like that?
11:19:20 <lethjakman> That's what I'm confunsed about. 
11:19:27 <Cale> That's what the maybe function does
11:19:39 <Cale> > maybe 0 (*10) Nothing
11:19:40 <lambdabot>  0
11:19:45 <Cale> > maybe 0 (*10) (Just 5)
11:19:47 <lambdabot>  50
11:20:08 <lethjakman> That makes perfect sense then
11:20:12 <lethjakman> And that's really incredibly nifty
11:20:14 <lethjakman> Thank you!
11:20:44 <Cale> lethjakman: You could also just write   do r <- maybeAuthId; case r of Nothing -> handleAuthLack; Just aid -> return aid
11:21:27 <lethjakman> I knew of the case version, somehow I missed the maybe version...
11:21:31 <ReinH> lethjakman: maybe nothing just wraps up the usual pattern of case x of Nothing -> nothing; Just x' -> just x' in a function.
11:21:42 <Cale> In this case, using the maybe function is pretty cute, but in general I often find myself replacing uses of maybe with case expressions eventually.
11:21:47 <lethjakman> That's why I was thinking it was so tedious to do maybe though. 
11:21:50 <lethjakman> That cleans it up quite a bit. 
11:22:07 <lethjakman> Yeah, it would make sense for anything more complicated than that. 
11:22:21 <lethjakman> Thank you people!
11:22:54 <Cale> delYsid: What is f supposed to compute?
11:22:56 <ReinH> (the arguments are so named because they replace the Nothing and Just constructors, respectively, making maybe a fold over Maybe)
11:23:03 <Welkin> lethjakman: just use requireAuthId
11:23:18 <Welkin> it redirects to the login route if there is no user id in the session
11:23:32 <Welkin> otherwise it gives you the user id directly
11:23:43 <lethjakman> Welkin: I just wanted to understand it :)
11:24:00 <Cale> delYsid: It looks like you're doing something like mapM'ing function over zip [n,n-1..] xs
11:25:20 <fizruk> Cale: no, (l - 1) in his example was oversimplification, consider it be (g l x')
11:25:57 <Cale> Can we get a not-simplified-at-all version?
11:26:16 <fizruk> delYsid: can we? :)
11:26:23 <Cale> I hate trying to come up with answers for oversimplified questions like this
11:26:44 <Cale> when people could just post their code and a line number to look at :P
11:27:39 <monochrom> yeah, but sometimes the context consists of a thousand lines so I end up not reading
11:27:42 <fizruk> well, yes. but it comes with time to stop asking something you don't actually want
11:28:19 <johnw> Cale: agreed; if the person doing the simplifying is also doing the asking, it's quite possible the knowledge they lack will ruin the simlpification
11:28:48 <monochrom> askers face this thorny optimization problem of getting enough answerers and getting accurate answers from them
11:29:10 <johnw> monochrom: it's a tough balance
11:29:36 <monochrom> also, http://www.vex.net/~trebla/humour/tautologies.html #4 :)
11:29:58 <johnw> lol, that's perfect
11:30:59 <dmj`> monochrom, johnw: haha #1 and #6
11:31:05 <fizruk> does not load for me :(
11:31:09 <dmj`> johnw, monochrom: still think the best way to get a correct answer on the internet is to confidently state the wrong one.. not intentionally of course
11:31:20 <Gurkenglas> Okay so I somehow and with swapping arguments got rid of the recursion, delYsid
11:31:25 <Gurkenglas> :t evalStateT . mapM (\x -> StateT (\l -> ?p l x <&> \x' -> (x', l - ?g x')))
11:31:26 <lambdabot> (Monad m, Num s, Traversable t, ?g::b -> s, ?p::s -> a -> m b) => t a -> s -> m (t b)
11:31:59 <dmj`> Welkin: ping
11:32:17 <delYsid> let f _ _ [] = return []; f p l (x:xs) = p l x >>= \x' -> (x' :) <$> f p (l - g x') xs
11:32:39 <Gurkenglas> Yep, those should be equal except for swapped arguments
11:33:01 <delYsid> is the "non-simplified" version...
11:33:11 <Cale> delYsid: Well, what are you using it for?
11:33:20 <Cale> :t let f _ _ [] = return []; f p l (x:xs) = p l x >>= \x' -> (x' :) <$> f p (l - g x') xs in f
11:33:21 <lambdabot> (Monad m, Num a, Show t1, FromExpr a) => (a -> t -> m t1) -> a -> [t] -> m [t1]
11:33:29 <Cale> heh
11:33:35 <Welkin> dmj`: gutentag
11:33:37 <Cale> :t \g -> let f _ _ [] = return []; f p l (x:xs) = p l x >>= \x' -> (x' :) <$> f p (l - g x') xs in f
11:33:38 <lambdabot> (Monad m, Num a) => (t1 -> a) -> (a -> t -> m t1) -> a -> [t] -> m [t1]
11:35:33 <dmj`> Welkin: aeson > 0.9 changed lookups to return null instead of nothing w/ (.:?) which breaks a lot of things... just need to swap out (.:?) for something sane.
11:35:48 <dmj`> to build w/ 0.10
11:36:22 <delYsid> :t let g x = x; f _ _ [] = return []; f p l (x:xs) = p l x >>= \x' -> (x' :) <$> f p (l - g x') xs
11:36:23 <lambdabot> <no location info>:
11:36:24 <lambdabot>     not an expression: ‘let g x = x; f _ _ [] = return []; f p l (x:xs) = p l x >>= \x' -> (x' :) <$> f p (l - g x') xs’
11:36:25 <Gurkenglas> :exf "Monad m => (a -> m ()) -> a -> m a" -- Alias for this sure would be nice
11:36:27 <exferenceBot> \ f1 b -> f1 b >> pure b
11:36:32 <Welkin> dmj`: stackage lts requires 0.8.0.2 though
11:36:58 <Welkin> dmj`: I think it is a problem with stack not knowing to check for earlier versions...
11:37:15 <Welkin> I solved it by specifying exactly stripe-haskell-0.1.4.1
11:37:27 <Cale> :t \ f1 b -> f1 b >> pure b
11:37:28 <lambdabot> Monad m => (b -> m a) -> b -> m b
11:37:35 <Cale> ^^ you can even give it a more general type
11:37:44 <delYsid> :t let g x = x; f _ _ [] = return []; f p l (x:xs) = p l x >>= \x' -> (x' :) <$> f p (l - g x') xs in f
11:37:45 <Gurkenglas> But that throws away information D:
11:37:45 <lambdabot> (Monad m, Num a) => (a -> t -> m a) -> a -> [t] -> m [a]
11:38:01 <monochrom> warning: deja vu of a previous debate
11:38:09 <dmj`> Welkin: oh I see, I can just loosen the lower bound
11:38:18 <exio4> @type \f1 b -> fmap (const b) (f1 b)
11:38:18 <Gurkenglas> Also exferenceBot wisely doesn't produce that function from that type because of the throwing away ^^
11:38:19 <lambdabot> Functor f => (b -> f b1) -> b -> f b
11:38:23 <Cale> Computation is all about throwing away information.
11:38:35 <dmj`> Welkin: why does it force aeson == 0.8 ?
11:38:41 <Welkin> 0.8.0.2
11:38:42 <Welkin> no idea
11:38:43 <monochrom> warning: deja vu of a previous debate has materialized
11:38:53 <amf> is there a data structure that combines the tree layout with the uniqueness of sets? (or some other clever way to haskell-ize that concept)
11:38:56 <dmj`> Welkin: I haven't used stack yet so I don't know these things
11:39:04 <Welkin> dmj`: yeah, I just started using it :P
11:39:13 * hackagebot EdisonAPI 1.3 - A library of efficent, purely-functional data structures (API)  https://hackage.haskell.org/package/EdisonAPI-1.3 (RobertDockins)
11:39:16 * hackagebot EdisonCore 1.3 - A library of efficent, purely-functional data structures (Core Implementations)  https://hackage.haskell.org/package/EdisonCore-1.3 (RobertDockins)
11:40:18 <Cale> :exf "Monad m => (b -> m a) -> b -> m b"
11:40:27 <dmj`> amf: Data.Set is implemented as a balanced binary tree
11:40:43 <exferenceBot> could not find expression
11:40:46 <Cale> ?
11:40:49 <athan> module names can't contain unicode, can they? Nor `'`, `-`, or other non-alphanumeric `a-zA-Z0-9` characters?
11:41:08 <athan> s/?/, can they?
11:41:26 <amf> dmj`: perfect! thanks!
11:41:28 <Gurkenglas> :exf -u "Monad m => (b -> m a) -> b -> m b" -- This surprisingly doesn't produce const return, huh.
11:41:28 <exferenceBot> \ f1 b -> fmap (\ f -> b) (f1 b)
11:41:54 <Cale> athan: They can according to the report.
11:41:59 <athan> o_o first time I've seen exferenceBot
11:43:43 <maerwald> just back from hacking on a C project where "get_mute_state()" has random side effects and manipulates gui widgets... but it also gets the mute state... want to be back to haskell :/
11:44:09 <hexagoxel> Gurkenglas: caused by the rating on fmap, which has a negative cost associated to it iirc
11:44:27 <programo> I a using VIM to code in haskell.I want to split my screen into half , one to write code and the other half GHCI REPL, How can I do that? Is there any plugins I have to install?
11:44:49 <maerwald> programo: that's something for your window manager I guess
11:44:51 <glguy> You just open two windows and put them side by side
11:44:56 <maerwald> use tiling wm
11:45:00 <jstimpfle> or tmux
11:45:03 <Cale> Yeah, just open another window :P
11:45:09 <maerwald> xmonad or i3
11:45:13 <Copperis> use tmux
11:46:13 <programo> Yeah I do that usually , but if I want to work on one window and split into half and have REPL on one half and the other haks as my editor, how could I do that?
11:46:15 <Cale> I'll usually have several windows open when working on code, at least one of which will be an editor with the source file I'm working on, and another will be ghci
11:46:56 <Cale> programo: tmux will do that if you *really* want to.
11:47:05 <Cale> I'm not sure why you'd want to.
11:47:09 <programo> okay Cale , I will try that
11:47:25 <Cale> It seems more awkward to me than just using a separate window.
11:47:36 <ReinH> Cale: well, I've had a lot of success in the past with tmux split between vim and a repl
11:47:50 <Cale> Unless you're not using a GUI at all, and only have access to text terminals
11:48:15 <Cale> It would be good if you were SSH'ed into the machine on which you're editing code
11:48:16 <ReinH> There are even vim plugins that wil help you interact with tmux, like Dispatch.
11:48:26 <Cale> and didn't want to do X forwarding for whatever reason
11:48:38 <jstimpfle> also, vim has windows. also, Ctrl+z works nice :-)
11:48:49 <ReinH> s/wil/will
11:49:30 <Cale> Ctrl-z doesn't let you look at your code and ghci at the same time though
11:49:33 <ReinH> Also neovim has a full terminal emilation so you can open a vertical split terminal inside neovim
11:49:36 <ReinH> *emulation
11:50:06 <ReinH> (You can then open neovim inside that terminal inside neovim, ad nauseum)
11:50:19 <Cale> Yeah, I really don't understand why you'd need that
11:50:45 <ReinH> Convenience, ability to interact with it from vim.
11:50:47 <Cale> We're all using, or at least have the option of using, high resolution displays with multiple windows.
11:51:08 <ReinH> These days I frequently use eshell.
11:51:28 <johnw> \o/
11:51:29 <Cale> Building some weird additional windowing system inside the text editor seems like a waste of effort to me :P
11:51:57 <amf> how would you implement Ord on records and use multiple fields?
11:52:08 <ReinH> vim has had a weird windowing system for decades :p
11:52:12 <Cale> amf: Well, you could do it in the way that the derived instance works
11:52:13 <ReinH> As has emacs
11:52:17 <monochrom> you love windowing so much, you run virtualbox in a window, inside which you run terminal windows in X, inside which you run tmux windows, inside which you run vim windows...
11:52:46 <Cale> amf: i.e. compare constructors, and if the constructors match, compare the first field, and if those match the second and so on.
11:52:56 <glguy> compare (x1,x2) (y1,y2) = compare x1 y1 <> compare x2 y2
11:53:10 <ReinH> monochrom: I prefer to incept neovim inside neovim terminals. I think time moves proportionally slower with each new neovim layer as well...
11:53:33 <amf> glguy: where is <> defined?
11:53:49 <glguy> Data.Monoid.(<>) = mappend
11:53:58 <amf> oh right... duh amf!
11:54:14 <jstimpfle> i think :!ghci % in vim for quick checks of the currently edited file was still missing
11:54:14 <amf> bingo! thanks all
11:54:20 <Cale> ReinH: The next thing neovim needs is the ability to do graphics so that someone can write an X server for it, and then you can run xnest inside neovim's embedded X server
11:54:29 <ReinH> Cale: Agree.
11:56:04 <monochrom> x window needs an ascii-art server/driver, much like mplayer has one
11:56:07 <Cale> But given that people want things to be "in the same window" like this, it makes me think that there's room for a window manager that's able to do some additional things with regard to gluing windows together.
11:56:31 <awpr> a hierarchical WM
11:56:51 <jstimpfle> tabbing/paning window managers
11:57:20 <Cale> yeah
11:57:22 <jstimpfle> but in the end whenever one has more than 10 windows open that can't be distributed on four workspaces or so something has to be seriously wrong no?
11:57:31 <delYsid> hmm, this either & list thing is driving me crazy.  I see the problem, but I can't see any way around it.
11:57:41 <Cale> pwm used to have the ability to tab arbitrary windows together
11:59:54 <Cale> (I wonder where tuomov has been, haven't seen him around here in a while)
12:00:23 <jstimpfle> Cale: isn't he the ion3 guy
12:00:32 <Cale> Yeah, and he wrote pwm before that
12:02:44 <Cale> I didn't care much for ion or other tiling WMs, but pwm was pretty cool, especially back when I was using X over a network connection and didn't want anything too graphically fancy.
12:03:07 <orion> I have a bunch of functions (which call other functions) that all need to perform encryption and decryption, but the underlying algorithm doesn't matter. Would it be better to use a type class or a record type? 
12:03:36 <delYsid> Cale: You seem to had an idea whats the issue, care to help a bit?
12:04:21 <Cale> orion: Start with a record type, figure out if it would be better off as a type class by seeing whether there's only ever one record you end up supplying (per type)
12:05:18 <Cale> orion: One cool thing about using a record type which wouldn't work with a type class is that you might be able to bake the keys to use into the record.
12:05:25 <kristof> Woah. What does '->' mean in a do block?
12:05:30 <jstimpfle> delYsid: what's your question?
12:05:32 <Cale> kristof: where?
12:05:46 <johnw> kristof: it could be a view pattern in a binding....
12:05:58 <kristof> Cale: It's showing up as a possible syntax pattern in haskell-mode in emacs.
12:06:15 <orion> Cale: I see. Could you elaborate on what you mean when you say, "there's only ever one record you end up supplying"?
12:06:29 <orion> For example, I have these functions:
12:06:30 <orion> encryptAndIncrement :: CipherState c -> Plaintext  c -> (Ciphertext c, CipherState c)
12:06:34 <orion> decryptAndIncrement :: CipherState c -> Ciphertext c -> (Plaintext c,  CipherState c)
12:06:48 <orion> Where 'c' represents a cipher.
12:07:01 <Cale> are those always the same functions, given c?
12:07:59 <delYsid> jstimpfle: I have a non-deterministic monad (list) algorithm which I'd like to encapsulate in an Either.  However, what used to be a simple modification of sequence, is now seemingly impossible.
12:08:08 <Cale> orion: You can only have one instance of a type class for any given type
12:08:27 <Cale> orion: So you only use type classes in cases where it makes sense that there would be a canonical implementation of something for any given type.
12:08:46 <orion> Cale: Do you mean to ask, "Will the implementations of encryptAndIncrement or decryptAndIncrement change depending on what 'c' is?"
12:08:52 <Cale> No
12:09:18 <Cale> I'm asking: is there any type c for which you'd want more than one implementation of encryptAndIncrement
12:09:18 <orion> Ah, what do you mean when you say, "always the same functions"?
12:09:24 <delYsid> :t let g x = x; f _ _ [] = return []; f p l (x:xs) = p l x >>= \x' -> (x' :) <$> f p (l - g x') xs in f
12:09:25 <lambdabot> (Monad m, Num a) => (a -> t -> m a) -> a -> [t] -> m [a]
12:09:30 <orion> Cale: hmm
12:10:33 <Cale> delYsid: Can you explain why you want this?
12:10:53 <delYsid> Oh, that would require me to explain a lot of things... :-(
12:11:01 <Cale> delYsid: Perhaps with more realistic example code, people would be able to make better suggestions
12:11:20 <orion> Cale: No. The implementation of these two functions are identical regardless of what 'c' is.
12:11:55 <Cale> orion: Always? Then you shouldn't even need a record type, you can just define them at the top level.
12:11:57 <kristof> Oh, this is BNF
12:12:10 <kristof> Problem solved, there's no "->" in do :P
12:12:38 <Cale> kristof: It's not part of the syntax of do, it's (as an extension), part of the syntax of patterns
12:12:44 <alanz> Trying to upload to hackage, getting this: Invalid windows file name in tar archive: "HaRe-0.8.0.0\\test\\testdata\\Con.hs". What does it mean, how do I fix it?
12:12:49 <lpaste> athan pasted “ruh roh - stack trying to `copyFile` a directory?!” at http://lpaste.net/142307
12:13:15 <delYsid> Cale: My main problem is that I dont have the correct haskelly terminology yet I guess.  The basic operation is really just traverse.  However, I need to pass a parameter to the traverse function which depends on the result of the traverseal so far.  Imagine it like a maximum size.  Whenever a step in the traversal returns something, its size is retrieved and that is subtracted from the maximum size...
12:13:28 <delYsid> So I can't use traverse since traverse doesn't allow me to do that.
12:13:41 <kristof> Cale: The line in question I was reading is: do { stmts [;] } stmts -> exp [; stmts] | pat <- exp; stmts | let decllist ; stmts
12:13:42 <Cale> delYsid: Can you just write the whole thing recursively?
12:13:43 <Gurkenglas> If stack fails building a package because one of the dependencies threw an error, I'm supposed to "use another version" of the dependency, right? How?
12:13:45 <awpr> if the travers is in StateT m it does
12:13:45 <delYsid> So I had to reinvent traverse with >>= and <$> + recursion
12:13:53 <athan> Can anyone see an immediately obvious reason why this is happening? http://lpaste.net/142307
12:13:58 <kristof> Cale: I didn't realize that stmts -> means "stmts are of the form ..."
12:14:09 <delYsid> However, I dont see how to make that pattern work if I am inside of the Either monad.
12:14:22 <Cale> kristof: ah, that looks like a newline is missing or something
12:14:25 <Cale> kristof: but yeah
12:14:39 <kristof> Cale: Well all of it has to be shoved in emacs' minibuffer :P
12:14:45 <Cale> heh
12:15:01 <Cale> fair enough
12:15:18 <Cale> delYsid: Maybe it can't work?
12:15:37 <jstimpfle> delYsid: you should describe in abstract input / output terms what you want to achieve
12:15:43 <Cale> delYsid: I recommend not using any of these abstractions to begin with, and just trying to implement your function with recursion.
12:16:01 <Cale> delYsid: If you can do that, then maybe you can think about how it can be simplified with fancy operators.
12:16:13 <jstimpfle> delYsid: Also, the "g" function from your example is just "id" and seems to have no use
12:16:18 <delYsid> Cale: I am learning, so everything is possible... However, I wonder why, i.e., whats my fundamental errorr then.  After all, it has to work somehow, it does in imperative world as well.
12:16:46 <Cale> delYsid: I don't understand well enough what you're trying to achieve in order to determine whether it's possible or not.
12:17:03 <orion> Cale: hmm, the functions I've provided are higher-order functions. They are already defined at the top level.
12:17:24 <Cale> orion: Okay, so what would your record type even consist of?
12:17:26 <orion> Cale: Here's the functions in the record type: cipherEncrypt :: SymmetricKey c -> Nonce c -> AssocData c -> Plaintext  c -> Ciphertext c -- cipherDecrypt :: SymmetricKey c -> Nonce c -> AssocData c -> Ciphertext c -> Plaintext  c
12:17:37 <orion> (among others)
12:17:39 <ReinH> delYsid: Can you describe what you are doing in concrete, imperative terms?
12:17:42 <Cale> okay then
12:17:49 <ReinH> USing real input/output data?
12:18:00 <Cale> orion: So, repeat my question to you, but with those functions instead :P
12:18:01 <orion> Cale: cipherEncrypt and cipherDecrypt are 100% dependent on what 'c' is.
12:18:40 <Cale> orion: So you're saying that if you know which type c is, you know which implementation cipherEncrypt and cipherDecrypt should have?
12:18:51 <orion> Correct.
12:18:51 <Cale> You'll want a type class then.
12:19:32 <orion> Interesting. Under what conditions would that not be true?
12:20:25 <orion> Would using a record type be called for if 'c' did not uniquely determine an implementation of cipherEncrypt or cipherDecrypt?
12:22:35 <Cale> orion: yes
12:23:05 <Cale> orion: One neat thing about using a record type is that you might be able to bake some of the arguments of those functions into the record value
12:23:55 <Cale> (i.e. by pre-applying the functions to some of their arguments)
12:26:30 <Cale> orion: e.g. you might have   data Crypt c = Crypt { encrypt :: Plaintext  c -> Ciphertext c, decrypt :: Ciphertext c -> Plaintext c }, and then  mkCrypt :: SymmetricKey c -> Nonce c -> AssocData c -> Crypt c
12:27:01 <Cale> orion: and then you can pass around the Crypt records instead of all this other stuff
12:27:21 <Cale> orion: I don't know whether that actually makes any sense in your use case, but you should get the idea :)
12:27:24 <orion_> Cale: Last message before I got disconnected was: "One neat thing about..."
12:27:32 <ReinH> note that Crypt is also an Iso, for whatever that's worth.
12:27:32 <Cale> oh
12:27:34 <Cale> <Cale> (i.e. by pre-applying the functions to some of their arguments)
12:27:37 <Cale> <Cale> orion: e.g. you might have   data Crypt c = Crypt { encrypt :: Plaintext  c -> Ciphertext c, decrypt :: Ciphertext c -> Plaintext c }, and then  mkCrypt :: SymmetricKey c -> Nonce c -> AssocData c -> Crypt c
12:27:40 <Cale> <Cale> orion: and then you can pass around the Crypt records instead of all this other stuff
12:27:54 <orion_> Cale: I see, that makes sense.
12:29:24 <ReinH> So you could use lens combinators to work with the data, e.g. over derypted
12:29:38 <deech> Hi all, what's the best way of converting from [ByteString] to [CString] where a copy is made but not freed after use?
12:29:45 <orion> Cale: Is it OK if 'c' is a phantom type? For example, in my implementation module I have "data AES256" and "data ChaChaPoly"
12:29:47 <ReinH> and plaintext # descrypted, etc, which seems rather nice
12:29:59 <orion> That's the complete definition of those types.
12:30:49 <ReinH> er, ciphertext # decrypted
12:31:05 <Cale> orion: Are any of the other types which depend on the type c structurally different based on it?
12:31:12 <Cale> freenode :(
12:31:15 <qmm> thoughts? http://pchiusano.blogspot.com/2010/01/actors-are-not-good-concurrency-model.html
12:31:23 <Ongy> would this be the right place to ask questions about GHC internals, or is there a better channel for something like that?
12:31:26 <hardmath123> Any folks here with Fay experience? I'm trying to use Data.Map, Data.Set, etc. with Fay.
12:31:42 <kristof> The bindings to GTK don't look very... functional.
12:31:48 <kristof> Is there a wrapper over them?
12:31:55 <kristof> a wrapper over the wrapper, heh
12:32:22 <ReinH> qmm: Aside from disagreeing with decades worth of successful experience with actors, how is this relevant to Haskell?
12:32:23 <kristof> Something that treates widgets like monoids and can hook them up together in a dataflow way :o
12:32:28 <Cale> qmm: That seems to mirror a lot of my thoughts from around that time :)
12:32:55 <Cale> freenode pls
12:33:09 <orion> Cale: Are you referring to SymmetricKey, Nonce, etc?
12:33:14 <kristof> qmm: Agree with it. It's very typical in erlang to define pure function a -> b that "hook up" and initialize actors that proceed to do their own thing, but nothing enforces you to do this
12:33:34 <Cale> orion: yeah
12:33:44 <Cale> orion: Are any of them type or data families?
12:33:52 <orion> Cale: Yes, all of them.
12:34:07 <ReinH> My experience with Erlang is that composition is achieved in other ways, and that expecting actors to work like functions is a mistake.
12:34:46 <delYsid> ReinH: My input is a list of ambiguous things.  I have a function f that, given a state, and a ambiguous thing, returns a list of concrete things.  If I didn't have state, I could just do traverse f ambiguousThings, however, state changes with every concrete thing sequenced.  SO I need edto reinvent sequence like this: seq' s (x:xs) = f s x >>= \x' -> (x' :) <$> seq' (s - x') xs.  This works perfectly fine as long as I am "just" doing
12:34:46 <delYsid> non-determinism.  However, I'd like to add Either e around seq' and f.  Now I am really stuck.  I can unpack the Either from f in seq' just fine, but I'd need to iterate over the concrete things returned from f and do the applicative :, however, now I have an Either on the right hand side from my own recursive call.
12:34:47 <Cale> orion: All right then, seems fine that it's a phantom.
12:34:57 <qmm> kristof: pure functions that spin up side effects? yikes
12:35:09 <orion> Cale: Great! Thank you very much for your support.
12:35:26 <Cale> ReinH: The trouble is that if you have a bunch of actors which individually can take input and produce output of some sort, they start to look like shared memory cells.
12:35:40 <ReinH> delYsid: I have no idea what that incantation means. I agree with Cale: you should write a direct, recursive implementation of your problem first.
12:35:45 <Cale> ReinH: and you have all the same problems, just on a slightly larger scale
12:36:16 <ReinH> Well, ideally an implementation of your solution, not your problem
12:37:18 <Cale> ReinH: Like, if the task you're trying to perform involves communicating with two different processes in a way which alters their state, you have no way to prevent the rest of your system from potentially observing the intermediate state -- you don't get to be transactional there.
12:37:32 <ReinH> Well, they are composable in the same way that lisp functions are composable: you just have to prove that the composition typechecks yourself.
12:37:33 <delYsid> ReinH: I dont know what "direct recursive version" means.  I was thinking I have that already.  I am trying to *add* an Either monad to that.
12:37:42 <Cale> (i.e. the state where one of the actors has been updated and the other hasn't)
12:37:58 <ReinH> delYsid: I mean: write it using recursion, not using any traversable or functor machinery
12:38:08 <Cale> delYsid: Either is just a simple data type with two constructors, you can use Left and Right directly, and case to pattern match
12:38:13 <ReinH> Cale: Consistency is a pretty different problem from composability
12:38:13 <Cale> delYsid: What do you want to do?
12:38:24 <Cale> ReinH: Well, it's very interconnected.
12:38:52 <Cale> ReinH: If you could somehow specify transactional communications between actors, there would be greater composability
12:38:54 <ReinH> delYsid: i.e., write your function using recursion and pattern matching only
12:39:17 <kristof> If you can see the functor version of the code immediately, then you should do it :P
12:39:18 <Cale> ReinH: You're familiar with the bank accounts example, yeah?
12:39:25 <ReinH> Cale: Sure.
12:39:45 <delYsid> ReinH: oh.  You want me to reimplement <$>?
12:40:00 <kristof> no need to snark
12:40:12 <ReinH> delYsid: If it prevents you from writing something like seq' s (x:xs) = f s x >>= \x' -> (x' :) <$> seq' (s - x') xs, then yes.
12:40:36 <kristof> delYsid: I'm going to second Cale's question. I get that you're trying to use Either over a List but is it Either over List or List over Either?
12:41:09 <delYsid> I have non-determinism with hard failure.
12:41:28 <delYsid> I.e., the result of the disambiguation might be empty, or there might have been an unresolveable error
12:41:50 <Cale> delYsid: This would be so much clearer if you'd just go here: http://lpaste.net/ and paste your entire source code
12:41:50 <delYsid> So I think I want Either e [a]
12:41:53 <kristof> So you want Either e [a], not [Either e a]
12:42:06 <Cale> delYsid: and then we could work out why you're asking these weird questions :)
12:42:15 <kristof> Nah it's a totally reasonable question
12:42:18 <Cale> I don't even really understand what the question is
12:42:21 <kristof> delYsid: You basically want an EitherT monad transformer
12:42:30 <Cale> What type does the function you want have?
12:42:41 <delYsid> kristof: I think so, yes. [Either e a] would convey the wrong thing.
12:42:42 <Cale> and why do you want it?
12:43:06 <kristof> delYsid: And even if you THINK you don't, it turns out that adding enough methods to monads to get what you want is completely isomorphic to the lift instance of MonadTrans
12:43:19 <ReinH> delYsid: The point is that I want to understand the recursive structure of your program as directly as possible, and I think you would want to as well.
12:43:23 <kristof> I found this out the hard (but interesting?) way
12:43:59 <ReinH> Once we know the structure, we might find an abstraction that captures it.
12:44:17 <kristof> We already do, it's EitherT
12:44:25 <Cale> kristof: I don't know if that's the case
12:44:33 <Cale> kristof: in fact, I think it's not the case?
12:44:35 <kristof> I do! I recognize his situation almost exactly
12:44:37 <ReinH> kristof: That doesn't seem like a justifiable conclustion to me
12:44:55 <kristof> I'm sorry, I meant ListT
12:45:07 <hardmath123> I think this got lost in the netsplit, but...
12:45:10 <hardmath123> > Any folks here with Fay experience? I'm trying to use Data.Map, Data.Set, etc. with Fay.
12:45:11 <lambdabot>  <hint>:1:63: parse error on input ‘,’
12:45:27 <delYsid> ReinH: The problem is, that I am dealing with 4 levels of recursion, and this is all quite hard to explain.  This is my program: https://github.com/mlang/hbmc/blob/master/Haskore/Interface/Braille.hs
12:45:33 <Cale> hardmath123: Fay is not actually Haskell, unfortunately. It might have different Set and Map libraries.
12:45:48 <ReinH> delYsid: The difficulty in explaining it is exactly why I'm asking to look at code.
12:46:02 <kristof> delYsid: You're talking about testms right?
12:46:25 <delYsid> I am talking about ms and all its structure
12:46:41 <rawtrick> hello everyone...  :)
12:46:56 <delYsid> I have managed to change pvs and pms already to use Either e
12:46:57 <Cale> delYsid: finally!
12:47:02 <Cale> delYsid: thank you
12:47:18 <delYsid> But I am stuck converting vs.
12:47:44 <Cale> delYsid: So your goal is to tidy up ms?
12:47:44 <delYsid> And so I havent committed my intermediate state :-(
12:48:02 <kristof> Let's see, blah blah blah, parser stuff...
12:48:10 <kristof> delYsid: Thank god you use applicative style
12:48:22 <kristof> "He's lifting AmbiguousNote over some parsers, cool"
12:48:22 <delYsid> Cale: My goal is to be able to throwError inside of pvs, and have it terminate the whole computation.
12:48:32 <rawtrick> I'd like to ask you a question if I may ask... I'd like to be a pentester and I am not sure which subjects should I study beforehand. Would you recommend me some study-topic ideas to help me out please?
12:48:39 <obadz> What's the purpose of the Real typeclass and why isn't there a Real a => a -> Double function in it ?
12:49:01 <Cale> rawtrick: Does this question have anything to do with Haskell?
12:49:16 * hackagebot HaRe 0.8.0.0 - the Haskell Refactorer.  https://hackage.haskell.org/package/HaRe-0.8.0.0 (AlanZimmerman)
12:49:31 <rawtrick> Cale: I'm so sorry
12:49:34 <rawtrick> :(
12:50:08 <Cale> rawtrick: It's no problem, this just isn't likely the optimal place to be asking that question :)
12:50:27 <rawtrick> Cale: Okay I am terribly sorry
12:50:57 <delYsid> I have defined Disambiguator and runDisambiguator, and I think those are correct.  I am really just stuck converting vs.
12:51:28 <delYsid> pms for instance, was surprisingly easy to convert.  It reads now: pms l pm = traverse (pvs l) pm >>= return . filter allEqDur . sequence
12:52:17 <ReinH> delYsid: m >>= return . f = fmap f m
12:52:54 <ReinH> so filter allEqDur . sequence <$> traverse (pvs l) pm
12:53:00 <Cale> What's wrong with do-notation :(
12:53:42 <Cale> I don't even want to think about what that traverse means
12:53:44 <delYsid> Cale: I dont like to name things :-)
12:53:51 <Cale> My head hurts
12:53:53 <Cale> lol
12:54:05 <lpaste> Gurkenglas pasted “delYsid, here. (I also recommend that you annotate with type signatures.)” at http://lpaste.net/142309
12:54:12 <delYsid> Hehe, tell me, I have (re)started with haskell roughly 3 weeks ago.
12:54:16 * hackagebot connection-pool 0.2 - Connection pool built on top of resource-pool and streaming-commons.  https://hackage.haskell.org/package/connection-pool-0.2 (PeterTrsko)
12:54:21 <delYsid> I am amazed that I came up with this.
12:54:29 <Cale> There's way too much fancy combinator usage in this for *me* and I've been programming in Haskell for 14 years or so.
12:54:32 <squisher> hey folks, I'm having trouble building ghc-7.10 with ghc-7.6 -- I'm getting a type error. Shouldn't I expect that to work? http://pastie.org/10460674
12:55:05 <Cale> I mean, I can figure out what this all means, but...
12:56:18 <darkstalker> hi, i got this code https://gist.github.com/darkstalker/bf460462c7f34acf2a25 and i want to optimize it, but dont know how. it's being slower than a Lua version i have
12:56:20 <Cale> squisher: You'd probably have better luck starting with GHC-7.10 :P
12:56:22 <ReinH> Cale: Do we have fmap f . traverse g = traverse (f . g)?
12:56:41 <Cale> ReinH: I don't know.
12:56:46 <squisher> Cale, haha, yes, but that info is not very helpful :D
12:56:56 <ReinH> Cale: based on fmapDefault, I want to say yes?
12:56:59 <Cale> squisher: Why are you building GHC in the first place?
12:57:05 <EvanR> obadz: a -> Double is already available in the form of realToFrac
12:57:23 <delYsid> Gurkenglas: You mean another state monad?  Interesting.  I need time to digest this, thanks!
12:57:37 <squisher> Cale, I need to use 7.10 on debian stable, which unfortunately only has 7.6 packaged
12:57:43 <obadz> EvanR: feels odd that Double would be viewed as Frac rather than Real
12:57:44 <squisher> should be easy, I can just backport... ;-)
12:57:50 <Cale> squisher: Get the generic linux binary from the GHC website.
12:57:57 <ReinH> :t fmap sequence
12:57:59 <lambdabot> (Monad m, Functor f, Traversable t) => f (t (m a)) -> f (m (t a))
12:58:04 <squisher> Cale, Hm, ok, I may try that. Thx
12:58:17 <Cale> https://www.haskell.org/ghc/download_ghc_7_10_2#x86linux
12:58:24 <lpaste> Gurkenglas revised “delYsid, here. (I also recommend that you annotate with type signatures.)”: “delYsid, oops I forgot to lift pms l x into the StateT.” at http://lpaste.net/142309
12:58:26 <ReinH> squisher: Or use the PPA. One sec.
12:58:48 <EvanR> obadz: well Fractional is how you get from rational to type X
12:59:06 <EvanR> obadz: the names of these classes arent the most illuminating
12:59:11 <ReinH> squisher: you can use these steps https://github.com/freebroccolo/docker-haskell/blob/master/7.10/Dockerfile
12:59:20 <obadz> EvanR: agreed ;-)
12:59:37 <Cale> squisher: Generally I ignore everything that my distribution has related to Haskell, since it's usually out of date and awkwardly packaged (especially debian's packages, which split up the standard GHC distribution into dozens of tiny pieces)
12:59:44 <lpaste> Gurkenglas revised “delYsid, here. (I also recommend that you annotate with type signatures.)”: “Oh hey, vs doesn't even need to have l as an argument.” at http://lpaste.net/142309
12:59:56 <ReinH> squisher: definitely wouldn't recommend using apt to install haskell *packages*.
13:00:38 <Cale> squisher: You might want the generic linux binary package for Haskell Platform though
13:00:50 <Cale> would save you the trouble of installing cabal-install yourself
13:01:01 <delYsid> Gurkenglas: Too fast, I am blind!!! ...  vs *does* need l as an argument.
13:01:11 <Cale> https://www.haskell.org/platform/#linux-generic
13:01:17 <squisher> ReinH, that docker file does nothing but install the debian/ubuntu pkgs... how's that supposed to help me?
13:01:27 <Gurkenglas> delYsid, since vs is defined in a where clause of ms, the argument l from ms is in the scope of vs
13:01:30 <ReinH> squisher: No.
13:01:32 <squisher> and no I don't install pkgs with apt
13:01:46 <ReinH> squisher: It doesn't install the official packages
13:02:04 <Gurkenglas> Is there an easy way to memoize the f in somethingBy (comparing `on` f)?
13:02:13 <squisher> ReinH, ah you're suggesting I use that ppa? Hm, I don't think that's a great idea 
13:02:13 <Gurkenglas> -`on`
13:02:14 <delYsid> Gurkenglas: ah, right.
13:02:21 <ReinH> it installs ghc 7.10.2 nd cabal-install 1.22 from a PPA.
13:02:29 <ReinH> squisher: Why not?
13:02:40 <ReinH> I've used it literally hundreds of times without issue.
13:02:49 <squisher> ReinH, because that's packaged for ubuntu? Then I'd rather try installing the debian sid debs
13:02:59 <ReinH> It's packaged for debian and ubuntu.
13:03:03 <ReinH> The docker image is a debian image.
13:03:11 <squisher> ah
13:03:24 <ReinH> If you want to install haskell 7.10 on debian via apt, this is what you should do.
13:03:36 <ReinH> If you want to put the binary somewhere yourself, you can definitely do that too.
13:03:44 <delYsid> Gurkenglas: So mapM is like traverse, somehow?
13:03:57 <EvanR> whats an example type that is Real but not Fractional
13:04:03 <jstimpfle> mapM is just sequence . map
13:04:06 <Gurkenglas> delYsid, it is exactly traverse, just specialized to monads
13:04:20 <ReinH> EvanR: CReal?
13:04:20 <Gurkenglas> I used mapM there because you used >>= there
13:04:30 <ReinH> Gurkenglas: the >>= is secretly fmap
13:04:36 <ReinH> since it's of the form m >>= return . f
13:05:00 <qmm> is anyone here using session types yet?
13:05:05 <Gurkenglas> ReinH, I meant the one in "vs l (x:xs) = pms l x >>= \pm -> (pm :) <$> vs (l - dur pm) xs where"
13:05:11 <ReinH> Ah.
13:05:22 <ReinH> That one is opaque to me.
13:05:27 <Cale> qmm: Is anyone anywhere using session types? :)
13:05:55 <Cale> qmm: I've seen some Idris libraries which almost made them look usable.
13:05:57 <ReinH> Cale: There was a thing on session types in Rust at ICFP, I believe. So... maybe?
13:06:08 <Gurkenglas> ReinH, it's equivalent to lines 4-9 of http://lpaste.net/142309 :P
13:06:14 <ReinH> Cale: http://munksgaard.me/laumann-munksgaard-larsen.pdf
13:06:56 <Cale> I've only ever seen academic papers about session types, and some half-baked implementations which didn't look so usable in practice.
13:07:13 <EvanR> ReinH: thats kind of broken in that CReal shouldnt really support toRational
13:07:23 <ReinH> Gurkenglas: Ah. I think that's better, although the StateT use seems perhaps unwarranted
13:07:26 <Cale> It's a good idea, but it's tricky to implement in a way that gets you good compiler error messages
13:07:40 <kristof> delYsid: I haven't looked at your ms function but have you considered using ListT (Either e) a?
13:07:41 <delYsid> Gurkenglas: v never reads the state, is that intentional?  You're using the global binding for l then.
13:07:45 <Gurkenglas> ReinH, how would you do it without recursion?
13:07:51 <ReinH> EvanR: Well, the numberic tower is not at all consistent, so...
13:08:17 <Gurkenglas> delYsid, no it's not, let me try again
13:08:28 <EvanR> right, well i was wondering an honest numeric type which is Real but not Fractional, just to try to convince myself theres some sort of sanity going on there ;)
13:08:33 <delYsid> kristof: I actually use StateT s (ListT (ExceptT e Identity)) a ...
13:08:50 <kristof> ah, ok
13:08:59 <lpaste> Gurkenglas revised “delYsid, here. (I also recommend that you annotate with type signatures.)”: “Well, I guess with "l <- get" missing there isn't much to try.” at http://lpaste.net/142309
13:09:09 <qmm> Cale: why are the haskell libs unusable?
13:09:25 <Gurkenglas> Of course, using other variables instead of all the shadowing is probably better
13:09:28 <ReinH> Gurkenglas: I would do it *with* recursion and by explicitly passing the state around.
13:09:31 <Gurkenglas> Also I would inline vs and pms
13:09:47 <ReinH> And then I would suiint at what I wrote and see if there's a nice abstraction that can be used instead.
13:09:48 <Gurkenglas> (and probably rename v?)
13:09:49 <ReinH> *squint
13:10:15 <Cale> qmm: Type level computation in Haskell is just barely possible.
13:10:32 <EvanR> > toRational (3.14 :: CReal)
13:10:34 <lambdabot>  *Exception: CReal.toRational
13:10:37 <EvanR> wtf
13:11:00 <ReinH> Gurkenglas: I think this code is reaching for abstraction to soon.
13:11:21 <ReinH> So I would go the other way and write something very simple and direct.
13:11:30 <ReinH> And then work on cleaning that up.
13:11:46 <Cale> qmm: The language isn't designed around doing the kind of computation at the type level that session types require. You'd really want dependent types, and even with dependent types, type errors in programs using session types tend to be horrible unless you also implement some way to add custom type error messages.
13:12:01 <ReinH> It's likely that some pattern would emerge that can be replaced with an abstraction, but I don't trust that I can just guess which one it will be without doing the work. :)
13:12:10 <Cale> qmm: (because session types specify a lot of the program behaviour and end up having normal forms which are very large and complicated)
13:12:21 <EvanR> whats the point of implementing Real for CReal, other than the name of the class, as an error
13:12:40 <ReinH> What even is the point of Real?
13:12:43 <ReinH> :p
13:12:51 <EvanR> that might be the conclusion
13:12:51 <Cale> :t realToFrac
13:12:53 <lambdabot> (Fractional b, Real a) => a -> b
13:13:09 <EvanR> > realToFrac (3.14 :: CReal)
13:13:11 <lambdabot>  *Exception: CReal.toRational
13:13:13 <kristof> ...how is that mathematically possible
13:13:16 <ReinH> EvanR: class ImpossibleNumber a where
13:13:48 <Cale> The Real typeclass is a bit inappropriately named and doesn't really correspond to the real numbers.
13:13:52 <ReinH> s/realToFram/lieAboutNumbers
13:13:57 <ReinH> *Frac
13:14:08 <EvanR> seems like CReal could have tried to implement a toRational
13:14:18 <kristof> When we used to talk about adding real numbers to Lisp, we were talking about arbitrary precision generators
13:14:20 <Cale> Real consists of those types whose values can be interpreted as rational real numbers.
13:15:00 <Cale> I suspect when the name was chosen, it was by contrast with complex
13:15:04 <EvanR> point 0 was that its pointless to implement Real class for CReal
13:15:43 <Cale> CReal is unfortunately very impractical for most uses.
13:15:44 <EvanR> kristof: thats what CReal is
13:15:57 <Cale> try adding up even 100 numbers with it or something
13:17:10 <EvanR> it doesnt have the be impractical and nonsensical ;)
13:17:48 <erisco> going from  data T = A | B | C  to  data (A :: T); data (B :: T); data (C :: T);  is DataKinds
13:17:52 <erisco> what is the other direction called?
13:18:49 <silver> type demotion? :P
13:19:47 <silver> (in contrast with type promotion)
13:20:11 <erisco> okay thanks, that'll do
13:20:42 <EvanR> class  (Real a, Enum a) => Integral a  where
13:20:54 <EvanR> what on earth, is this still the definition
13:21:26 <EvanR> what does realness have to do with integralness
13:22:38 <ReinH> EvanR: That depends on who you ask.
13:22:58 <qmm> Cale: what are your thoughts on http://www.doc.ic.ac.uk/research/technicalreports/2007/DTR07-5.pdf
13:23:04 <qmm> multiparty async session types
13:23:09 <silver> integers are subset of reals?
13:23:18 <EvanR> => isnt subset
13:23:25 <silver> it is
13:23:36 <qmm> i guess these are still theoretical and would have the same difficult to decipher error messages?
13:23:36 <silver> I mean
13:23:42 <EvanR> wurt
13:24:06 <Cale> qmm: My thoughts on session types in general are that they are a great idea, but one which requires a serious amount of engineering effort to implement well.
13:24:25 <delYsid> Gurkenglas: Thanks a bunch!!! This seems to work.  I just need a few more minutes to close the testing gap...
13:24:31 <EvanR> > 3.14 `div` 2
13:24:32 <ReinH> EvanR: The integers are the subset of the reals obtained by taking x to be the unique number such that r * x = r for all r in |R, and considering the set obtained by repeatedly adding and subtracting it from itself.
13:24:33 <lambdabot>      No instance for (Show a0)
13:24:33 <lambdabot>        arising from a use of ‘show_M832159803493841805612736’
13:24:33 <lambdabot>      The type variable ‘a0’ is ambiguous
13:24:50 <ReinH> s/subtracting it/subtracting x
13:25:36 <EvanR> is that used in generic algorithms for Integral?
13:25:59 <ReinH> EvanR: Alternatively, we could define what it means to be an "inductive set" and then say that N is the least inductive set, and Z is the least set containing N and closed under addition and subtraction.
13:26:10 <ReinH> EvanR: No, I'm just telling you what realness has to do with integralness
13:26:38 <EvanR> ok so what does toRational have to do with divMod and quotRem
13:26:48 <Cale> qmm: If you're working in a dependently typed language like idris, you can implement whatever system like that you want reasonably straightforwardly, but the type errors get hard to manage. I think Idris added some support for transforming error reports to try to improve the situation with their own implementation of session types.
13:26:49 <ReinH> On the other hand, we could ask "Is Z first-oder definable in R?" and the answer is No.
13:27:00 <Cale> qmm: It might be worth looking at what they have there.
13:28:12 <ReinH> *order
13:29:18 * hackagebot hgrib 0.3.0.0 - Unofficial bindings for GRIB API  https://hackage.haskell.org/package/hgrib-0.3.0.0 (mjakob)
13:31:04 <EvanR> :t 3.14 `div` 2
13:31:06 <lambdabot> (Fractional a, Integral a) => a
13:31:59 <EvanR> i wonder how many other weirdo things there are in the numeric classes
13:32:30 <Gurkenglas> delYsid, "do x : xs <- get; put xs; ..." is (in StateT []) the same thing as "do x <- mapStateT maybeToList $ StateT uncons; ..."
13:34:08 <Gurkenglas> (also "do xs <- get; let (as, xs') = span isTail xs; put xs'; ..." is "do as <- state $ span isTail; ...")
13:35:32 <Gurkenglas> Using lens, "zoom _2" can turn a StateT on lists into a StateT on your tuple.
13:36:02 <Gurkenglas> (Although at that point you might be better of using record syntax)
13:36:07 <Gurkenglas> *off
13:39:09 <EvanR> Cale: i happen to be working on a process-calculus-like thing and i happen to be looking at the screen when you mentioned the composability problem. i was thinking the same thing and im not sure how to help composability
13:39:49 <EvanR> what sort of things make things composable and what dont
13:43:08 <crough> There's lots of different kinds of "composable", really.
13:44:29 <crough> It depends on what kind you're looking for.
13:45:27 <crough> Basically, making functionality as mutually exclusive as possible gets you the most, because then composing a and b gets you (a, b)
13:47:42 <EvanR> theres only one way to do it?
13:48:17 <EvanR> im thinking thats not necessary or sufficient, we have many isomorphic types in haskell and its OK
13:48:57 <EvanR> its something about the interface between parts
13:49:03 <Gurkenglas> delYsid, you could also put the mapStateT maybeToList in front of the whole do expression to signify that you aren't actually using the nondetermism power of [] in there
13:49:19 <Gurkenglas> (Then it wouldn't need to go in front of the StateT uncons)
13:50:30 <jstimpfle> EvanR: could post again that mentioning of cale
13:50:46 <jstimpfle> +you, +?
13:51:00 <EvanR> ++ ** !
13:51:50 <Cale> wat
13:52:07 <Cale> EvanR: ah
13:52:25 <qmm> > fmap (+1) (1,2)
13:52:26 <lambdabot>  (1,3)
13:52:36 <qmm> why is the first element not transformed?
13:52:58 <hpc> > fmap (+1) ("seventeen", 5)
13:52:59 <Cale> qmm: Because you're using the instance of Functor for (,) e
13:53:00 <lambdabot>  ("seventeen",6)
13:53:20 <Cale> In general,  fmap :: (Functor f) => (a -> b) -> f a -> f b
13:53:45 <Cale> So, there's an instance where f = (,) e, and we have  fmap :: (a -> b) -> (,) e a -> (,) e b
13:53:52 <Cale> i.e. (a -> b) -> (e,a) -> (e,b)
13:54:00 <EvanR> qmm: if you had two different types in the tuple one function wouldnt be able to fmap
13:54:13 <jstimpfle> in very simple terms, what if you do fmap (+1) on (a,b) and a and b have different types
13:55:09 <Gurkenglas> > join (***) (+1) (1, 2)
13:55:10 <lambdabot>  (2,3)
13:55:22 <Gurkenglas> > (1, 2) & each %~ (+1)
13:55:24 <lambdabot>  (2,3)
13:55:51 <EvanR> what language is that ;)
13:56:13 <dmj`> > over both (+1) (1,2)
13:56:16 <lambdabot>  (2,3)
13:57:04 <suppi> ohhhhh I was always looking for an 'over both' function
14:00:07 <qmm> there are a lot of nice solutions at https://stackoverflow.com/questions/9722689/haskell-how-to-map-a-tuple
14:09:43 <orion> Is it possible for me to put a class constraint on a record constructor?
14:10:05 <orion> Or do I have to add the class constraint to each and every relevant record member?
14:10:13 <orion> (And use RankNTypes)
14:12:04 <jstimpfle> Are GADTs an option?
14:12:58 <Cale> orion: um, what kind of constraint?
14:13:08 <EvanR> dont constrain the data structure constrain the operations
14:13:26 <orion> Basically my situation is that I have this record type: data CipherState c = CipherState { csk :: SymmetricKey c, csn :: Nonce c }
14:13:51 <orion> I want to ensure that 'c' is a type which provides an instance for the "Cipher" class.
14:14:17 <EvanR> do it in the operations
14:14:36 <orion> hmm, ok
14:14:45 <Cale> One thing you can do is:  data CipherState c where CipherState :: Cipher c => SymmetricKey c -> Nonce c -> CipherState c
14:14:59 <jstimpfle> EvanR: wouldn't this be _much_more time than just using GADT (as Cale just posted)
14:15:16 <Cale> Then by pattern matching on a value of type CipherState c, you will "learn" that c is an instance of Cipher
14:15:26 <Cale> However, in practice, you usually just want what EvanR said.
14:15:28 <jstimpfle> sometimes records make only sense with some constraints
14:15:53 <Cale> It's usually simpler just to constrain the operations and not worry about unpacking instances from data structures.
14:16:03 <orion> It literally makes no sense to have a "CipherState Foo" unless Foo is an instance of Cipher.
14:16:19 <EvanR> jstimpfle: thats not a record up there
14:16:23 <EvanR> its a GADT
14:16:33 <jstimpfle> as i said
14:16:44 <jstimpfle> ok, got me
14:16:52 <Cale> You can use the record syntax with GADTs as well
14:17:02 <Cale> I just never remember how it goes :P
14:18:01 <jstimpfle> Cale: by "unpacking instances", do you mean some performance thing?
14:18:09 <Cale> orion: It also makes little sense to have a value of type Set a when a isn't an instance of Ord
14:18:17 <EvanR> jstimpfle: if the c parameter is not in the type then yeah then you want to do this constraint, since theres no other way
14:18:55 <Cale> jstimpfle: I mean if you have a GADT like that, what happens is that there's really an extra invisible field in the data structure which consists of the instance.
14:18:55 <orion> Cale: Right
14:19:20 <Cale> jstimpfle: and when you pattern match on the record, the instance of the type class gets brought into scope magically
14:19:29 <Cale> But you *have* to match
14:20:01 <Cale> You can't just bind the whole structure to a variable
14:20:17 <jstimpfle> basically, just like a vtable?
14:20:19 <Cale> (because that doesn't force the evaluation, and the instance might not actually be available then)
14:20:41 <EvanR> except vtables are associated with classes and dont need to be passed around
14:22:23 <Cale> orion: You'll notice that all the operations on Set just demand Ord instances where they need them
14:24:34 <EvanR> no Set of Complex for you
14:24:44 <orion> Cale: Ah, I see.
14:24:59 <qmm> does anyone have a link to a document describing ghc's runtime linker?
14:25:00 <jstimpfle> EvanR: if it weren't like this, maybe Set could be a Monad :-)
14:25:13 <qmm> i think facebook and other services are using it for hot swapping their code
14:25:24 <EvanR> what would a Set monad do?
14:25:25 <Cale> jstimpfle: nope, you still end up with problems implementing return
14:25:40 <Cale> Set is morally a monad, but only for types having an instance of Ord
14:25:53 <Cale> join takes the union of the set of sets, return forms a singleton
14:26:08 <Cale> fmap applies a function to all the elements, like you'd expect
14:26:08 <jstimpfle> EvanR: like list, only erasing multiplicities
14:26:23 <EvanR> fmap applying to all the elements is weird
14:26:37 <qmm> i guess this is it https://ghc.haskell.org/trac/ghc/wiki/DynamicGhcPrograms
14:26:43 <EvanR> does this obey functor laws
14:26:56 <Cale> EvanR: yes
14:26:59 <qmm> not really sure what the difference is in that and this: https://ghc.haskell.org/trac/ghc/wiki/DynamicByDefault
14:27:12 <Cale> EvanR: I mean, in the category of sets, the powerset functor is a monad.
14:27:33 <Cale> (and a functor)
14:27:40 <qmm> ah, second was an approach that didn't happen
14:28:07 <Cale> You just can't actually make it an instance of Functor or Monad because of the constraint -- it's not an endofunctor on all of the category of Haskell types
14:28:08 <zhkirill>  
14:29:40 <jstimpfle> i thought, maybe it can implement like a -> b -> Set a -> Set b for any a and b because someone works out that a and b must be Ord
14:30:29 <Cale> jstimpfle: if you're given a function (a -> b), and a Set a, and we use the GADT trick, then by unpacking the Set a, you get an instance Ord a
14:30:30 <EvanR> im still not sure what Functor has to do with endofunctors in general
14:30:45 <Cale> jstimpfle: But then to build a value of type Set b, you need an instance Ord b, which you don't have
14:32:29 <jstimpfle> EvanR: Functor (the Haskell one) is just that: an Endofunctor (the mathematical one)
14:32:42 <EvanR> fmap promotes any function to functor status?
14:32:43 <Cale> EvanR: An endofunctor F on a category C consists of two things: a mapping which assigns to each object X of C, some object FX of C, and then a mapping sending arrows a: X -> Y, to arrows Fa: FX -> FY
14:32:47 <qmm> what does a well-typed system like haskell give you that something like clojure or erlang cannot supply?
14:32:59 <qmm> s/system/language
14:33:09 <Cale> EvanR: In Haskell, the type constructor plays the role of the mapping on objects -- it sends types to types
14:33:14 <EvanR> qmm: general sanity
14:33:22 <Cale> and the definition for fmap plays the role of the mapping on arrows
14:33:24 <qmm> compile time guarantees
14:33:31 <Cale> fmap :: (a -> b) -> (f a -> f b)
14:33:41 <qmm> Cale: sanity in which way :)
14:33:58 <Cale> qmm: You mean EvanR
14:34:02 <qmm> sorry
14:34:03 <EvanR> thats what i was missing, the mapping of arrows
14:34:25 <ReinH> qmm: see also: http://stackoverflow.com/questions/3787960/what-makes-haskells-type-system-more-powerful-than-other-languages-type-syst
14:34:38 <qmm> i tried using erlang about two months ago, but i became frustrated not knowing exactly what types  i was dealing with
14:35:09 <EvanR> when i used clojure i constantly wanted to know what the "type" of my values were, but people who could tell me were few and far between
14:35:26 <Cale> qmm: It's hard to express just how painful it is after using Haskell for a while to go back to something like scheme and spend an hour tracking down a bug only to discover that it would have been a type error in Haskell.
14:35:27 <qmm> but that isn't a good reason for leaving, i'd like to know what benefits i'm actually reaping :)
14:36:06 <Cale> Having the compiler point out all the things which you need to change after making some refactoring is *super* useful
14:36:08 <qmm> and i'm sorry to bring up an old debate. i guess maybe links to resources describing the benefts are what i'm looking for unless someone does feel like responding inline :)
14:36:11 <qmm> ReinH: i'll check your link out
14:37:02 <Cale> qmm: There have been times where I wanted to change a fundamental datatype in a library, and I would just change it, and then run the compiler and fix what the compiler said to fix
14:37:03 <qmm> you can't capture all your bugs at compile time
14:37:38 <qmm> and it may be the case that we can't completely eliminite unit tests with dependent types
14:37:46 <jstimpfle> qmm: i think it made me a better C programmer. it might also be great for compilers and parsing. But for lot of stuff, writing in Haskell itself did not pay for me personally
14:37:54 <EvanR> more like, depending on the language catching more bugs at compile time takes more effort on the part of the programmer that at some point its not worth it
14:38:02 <Cale> At one point I did this in a library which was around 8000 lines of code, and it involved changing hundreds of lines, but I did this in a fairly mechanical way, and by the time I was done, my program still worked.
14:38:06 <EvanR> and you "debug" by running the thing in full production over and over
14:38:14 <EvanR> haskell cuts down on that a lot
14:38:17 <qmm> another question i have is: are there resources that describe how to generate tests with quick/small check? i've struggled with this in the past
14:38:18 <jstimpfle> qmm: I think it's great if you need to be certain that you can refactor a bit, but i won't help much for your sorting algorithm or networked application
14:38:20 <kristof> Cale: I love this about static typing.
14:38:36 <kristof> Cale: I had to refactor about 1000 lines of python recently.
14:38:45 <kristof> Not even the unit tests could save me.
14:39:02 <Cale> qmm: Mostly it's pretty simple -- you write the property you want to test as a function, and provide that function to quickCheck, and it will plug in random values
14:39:15 <Cale> qmm: and see if it can find a case where the function produces False
14:39:16 <kristof> Maybe I am just a bad programmer. That is probably true. But even so, that is just more justification for a rigorous type discipline.
14:39:33 <qmm> jstimpfle: i don't understand why haskell wouldn't be helpful in either of those cases
14:39:55 <qmm> jstimpfle: a sorting algorithm in haskell seems like a good use case for the language
14:40:10 <EvanR> concurrent haskell is pretty awesome for "networked applications"
14:40:17 <Cale> Haskell's type system is bad at expressing something like "the list resulting from applying this function is a permutation of the input list"
14:40:24 <qmm> jstimpfle: when i think of networked application, i think of the actor model and cloud haskell
14:40:24 <jstimpfle> qmm: if you write sorting algorithm, you usually juggle invariants that you can't express within a simple type system
14:40:31 <EvanR> think node.js with proper threading
14:40:38 <jstimpfle> qmm: EvanR: true, like Elm
14:40:46 <Cale> qmm: In general, if the type of the result of a function depends on the value of the input to the function, Haskell's type system falls over
14:41:01 <ReinH> Haskell's type system is good for reasoning about types and bad for reasoning about values :)
14:41:02 <Cale> That's called dependent typing
14:41:16 <Cale> and it's what systems like Idris, Coq, and Agda are exploring
14:41:16 <EvanR> jstimpfle: luckily you dont have to rewrite the sorting algorithm all the time, you can use an existing one
14:41:20 <kristof> qmm: If you move boundaries around slightly, you could also think of it in terms of CSP like Go.
14:41:42 <Cale> Recent extensions to Haskell's type system get a little closer to dependent typing, but it's still pretty awkward to use nontrivially.
14:41:50 <kristof> qmm: At which point you're only a step away from dataflow. The difference between dataflow and actors is that there is a rigorous and composability to the types that I just don't see in, say, Erlang.
14:42:32 <Welkin> I am trying to build a library I wrote with cabal
14:42:37 <Welkin> it doesn't seem to do anything
14:42:42 <kristof> Cale: You might find it interesting that Rust will possibly be getting a restricted form of refinement types.
14:42:43 <EvanR> why would you want to think of your system in terms of CSP
14:42:44 <jstimpfle> EvanR: For me, algorithms are the most fun part. I don't like gluing things together, but I think there's actually the biggest strengths of Haskell: making sure that the boring boilerplate code doesn't have stupid and hard-to-find errors
14:42:46 <Welkin> I cannot open it up in a repl using cabal repl
14:43:20 <kristof> Cale: data SomeType = Constructor1 Int | Constructor2 [Char]
14:43:21 <EvanR> jstimpfle: well thats the point of abstraction, to be able to glue things together instead of writing everything directly
14:43:44 <kristof> Cale: You will be able to write f :: Constructor1 -> Constructor1
14:43:51 <EvanR> writing everything directly gets old
14:44:59 <EvanR> kristof: exactly whats the point of that? is it different from Ctor1 and Ctor2 being different types like in haskell
14:45:07 <Cale> What Haskell's type system *will* check for you is the stuff expressed by the type sort :: (Ord a) => [a] -> [a] -- i.e. that the resulting list has the same type as the input list, that any elements which belong to the resulting list came from the input list, and that only the ordering operations were used
14:45:21 <qmm> 17:40 < Cale> qmm: In general, if the type of the result of a function depends on the value of the input to the function, Haskell's type system falls over
14:45:30 <Welkin> cabal repl just gives me this: Preprocessing library plivo-0.1.0.0...
14:45:30 <Cale> But for instance, you could write sort _ = [] and it would satisfy that type
14:45:32 <Welkin> then it exits
14:45:33 <qmm> Cale: seems like you are advocating for dependent types here :)
14:45:42 <Cale> qmm: sure
14:45:51 <qmm> Cale: if not that, then what else?
14:45:56 <Cale> qmm: I'm not going to tell you that dependent types are a bad thing
14:46:11 <Cale> Well, I can tell you some problems that dependent types introduce
14:46:20 <kristof> EvanR: Not having to deconstruct a Maybe into a Just or a Nothing because you've already guaranteed at compile time that it is a Just
14:46:22 <Cale> But generally they're pretty nice
14:46:44 <Cale> It's very hard to have powerful type inference in the presence of dependent types.
14:46:56 <johnw> let's make them dependent on powerful type inference
14:47:28 <qmm> this came to mind just now: http://math.andrej.com/wp-content/uploads/2009/05/msfp2008-slides.pdf
14:47:35 <qmm> Mathematically Structured but not Necessarily Functional Programming
14:48:27 <Cale> Also, dependently typed programs can end up breaking the functional abstraction a bit, because how much evaluation can be done at the type level on expressions that have variables in them will depend on the details of how functions are implemented with matching
14:48:45 <Cale> e.g. you can care about whether your natural number addition matches on the first or second argument
14:48:58 <EvanR> kristof: still not clear. why would you put/leave a Just on something after you guaranteed its there
14:49:34 <Cale> But those are both pretty weak criticisms when compared to the benefits that dependent typing provides in general
14:50:23 <Cale> So eventually I really hope to be able to use a language with non-strict semantics (and mostly lazy evaluation by default), and dependent types
14:50:33 <Cale> But that language doesn't exist yet
14:51:00 <hexagoxel> Welkin: do you have any exposed modules?
14:51:26 <EvanR> Cale: so a non-total language, where strictness has an observable difference
14:51:42 <Cale> EvanR: yeah
14:51:55 <Welkin> hexagoxel: that was it! Thank you
14:52:00 <Cale> EvanR: but the totality isn't even the important part
14:52:17 <Cale> EvanR: even for total programs, strict evaluation isn't always the best evaluation order
14:52:18 <EvanR> so far all the dependent typed languages (except idris) focus on totality
14:52:29 <EvanR> right theres performance differences
14:52:51 <qmm> kristof: thanks for mentioning dataflow, that's the first i've heard of it
14:52:55 <jstimpfle> EvanR: By gluing things together, I meant like using Framework A and library B and shove data forth and back
14:53:04 <Cale> and I really prefer being able to assume that the evaluation order is going to be something close to lazy unless the compiler determines that it's really going to need the results
14:53:16 <Cale> (or I explicitly annotate stuff)
14:53:30 <jstimpfle> EvanR: That's not what I think abstraction is. The point of abstraction is structuring you thought to gain certainty that you program is correct
14:53:49 <qmm> kristof: would you be willing to answer EvanR's question?
14:53:50 <qmm> 17:42 < EvanR> why would you want to think of your system in terms of CSP
14:54:04 <hexagoxel> Welkin: (see https://github.com/haskell/cabal/issues/2656)
14:54:22 <EvanR> jstimpfle: abstraction like lambda abstraction, reusable code
14:54:23 <jstimpfle> qmm: I think it's a good model of interaction, haven't read the whole thing though
14:54:24 <qmm> kristof: nevermind, i see that you did
14:55:08 <EvanR> to make sure your program makes sense you need types
14:58:47 <EvanR> Cale: in your opinion would this language need a type system as extensive as agdas?
14:59:29 <EvanR> like universe polymorphism
15:00:17 <Cale> Well, if it's not total it doesn't need universe polymorphism
15:00:24 <Cale> You can just have Type in Type
15:00:41 <Cale> because you're allowing general recursion anyway
15:01:05 <EvanR> what about "total mode"
15:01:10 <Cale> It might be nice to have a total fragment though, so having universe levels would be useful then
15:01:54 <Cale> and if you're going to have multiple universes, you might as well have universe polymorphism
15:02:28 <EvanR> so basically agda plus haskell mode ;)
15:03:46 <Cale> EvanR: Agda - unicode + lazy by default + lots of practical data structures and I/O stuff
15:04:38 <Cale> EvanR: Or just lazy Idris?
15:05:31 <EvanR> i dont think it has universe polymorphis
15:05:33 <EvanR> m
15:05:57 <EvanR> but it does have other cool features like type class, uniqueness types
15:06:52 <Cale> EvanR: I think Idris has secret universe polymorphism
15:07:00 <Cale> er, I'm not sure actually
15:07:14 <Cale> It had secret universe levels last I checked
15:07:24 <Cale> Not sure about actual polymorphism
15:08:28 <EvanR> it has secret universes
15:08:49 <EvanR> which makes me think it doesnt have universes and its just edwinb trying to get people to shut up about it
15:08:56 <Cale> hehehe
15:09:17 <Cale> Well, if you think it doesn't, you can try to foil the totality checker
15:09:27 <Cale> implement Russell's paradox :)
15:09:38 <EvanR> how would that go
15:09:45 <Cale> http://www.cs.nott.ac.uk/~psztxa/g53cfr/l20.html/l20.html
15:11:11 <delYsid> Gurkenglas: Somehow, mapM doesn't do what the original algorithm did.  I am getting a non-negative value, which should be impossible...
15:11:30 <L8D> How can I split a string into segments by a char? I want the "split" function from text and bytestring, but for normal strings
15:11:34 <delYsid> i.e., l is decremented < 0
15:11:56 <Gurkenglas> A negative value, you mean
15:12:03 <ReinH> @hackage split  -- L8D 
15:12:04 <lambdabot> http://hackage.haskell.org/package/split  -- L8D
15:12:06 <delYsid> yeah
15:12:35 <Cale> > splitOn "x" "xfooxbarxbazxx"
15:12:37 <lambdabot>  ["","foo","bar","baz","",""]
15:12:43 <Gurkenglas> You're "getting a value"? The final l isn't returned to you, how would you know?
15:13:16 <delYsid> Gurkenglas: Haskore has a non-negative duration... and it throws an exception.
15:13:16 <L8D> thanks
15:13:51 <delYsid> So the mapM behaves like a map, the state is not "local" to the path taken.
15:14:18 <Gurkenglas> delYsid, try not having the variables shadow each other?
15:14:47 <delYsid> hmm
15:15:04 <Gurkenglas> Maybe you forgot to put the l <- get line in there or something?
15:15:29 <Gurkenglas> (By the way, is this algorithm a greedy attack of the knapsack problem?)
15:15:44 <delYsid> no, I put vs and v as global function, and have the get.
15:15:48 <delYsid> so no shadowing
15:16:08 <delYsid> Gurkenglas: This is a real world problem being solved.
15:16:18 <delYsid> Gurkenglas: It is not about theoretical experiments
15:16:27 <EvanR> real world (tm)
15:16:39 <Gurkenglas> Yes, well, sometimes the real world contains problems described by theory :P
15:16:56 <Gurkenglas> I know almost nothing of your problem, but the code speaks for itself
15:17:16 <delYsid> Gurkenglas: I have no idea about the theory behind the knapsack problem
15:17:20 <ReinH> Yes, everyone knows the real world does not contain knapsacks which must be packed.
15:17:29 <Gurkenglas> You... try to fit elements of the list into the total l, skipping any that surpass the remainder?
15:17:50 <ReinH> Similarly, I don't understand why people who want to work with graphs care so much about salesmen.
15:18:13 <Gurkenglas> Hopefully that is not your attempt to completely fill up l, unless you have further gurantees :P
15:18:21 <kyfho> why are graph databases popular?
15:18:27 <kyfho> neo4j or something java crazy
15:18:28 <delYsid> Gurkenglas: Basically yes, unfortunately, the pattern repeats itself 4 times!
15:18:40 <ReinH> kyfho: are they?
15:18:46 <Gurkenglas> "the pattern"?
15:21:03 <delYsid> Gurkenglas: In the innermost level (pvs) I have several choices for each element, making sure the overall solution fits l.  One level above (pms), I need to make sure all pvss choosen have the same overall size (l).  One level above again, vs, I need to pass l decremented to each invokation of pms, such that pms knows how much time is left.  And in the outermost level (ms) the pattern of pms repeats itself.
15:21:48 <kyfho> I don't know
15:22:06 <kyfho> some job I got was going on about them but stuff happened and I had to not take it
15:22:10 <kyfho> was great job 2
15:22:14 <kyfho> bugger realy
15:22:22 <kyfho> renaissance faire was awesome today
15:22:29 <kyfho> not as much singles schene but was still fun
15:22:41 <delYsid> Gurkenglas: So pvs and vs are more or less identical.  So it makes quite some sense that you ended up using the state monad to solve it, since this is what is done in pvs as well.
15:22:50 <ReinH> kyfho: Can we keep this a bit more on topic please
15:23:03 <delYsid> However, something about this is wrong, otherwise I wouldnt get negative values.
15:23:15 <johnw> kyfho: especially: something Haskell-related
15:34:22 <ian`> hello?
15:34:43 <dmj`> ian: yo
15:34:44 <Cale> hi
15:35:03 <dmj`> hi Cale
15:35:18 <dmj`> Cale: are you going to hac phi
15:35:27 <delYsid> Gurkenglas: Pushed to branch "throw"
15:35:39 <fread2281> how can I write (a => b) => c? 
15:35:47 <Cale> nope
15:36:03 <delYsid> testvs shows the error, and I verified the same test does not barf with the old code.  So the transformation didn't do what we expect :-(
15:36:05 <thatguy> hey guys just starting off and I think I read somewhere I can do something like "alias" a type? i.e. just use "Green", "Blue" as alias for say 0,1?
15:36:07 <Cale> fread2281: uh, what?
15:36:11 <thatguy> can someone tell me how that was called?
15:36:12 <fread2281> without using :-
15:36:15 <thatguy> can't find it anymore
15:36:31 <crough> thatguy: It's the Enum typeclass, yeah?
15:36:40 <Cale> thatguy: 0 and 1 are not often considered to be types
15:36:48 <crough> thatguy: which is derivable
15:37:28 <Cale> You can derive Enum and use the toEnum and fromEnum functions to convert between your type and Int
15:37:40 <orion> Is running `cabal repl` on a project with cbits supported? ghci is crashing for me. :(
15:37:45 <thatguy> hmm ok either you are missunderstanding me or I confused something I guess
15:37:49 <thatguy> probably the latter
15:38:10 <fread2281> I want to write (given (a :: Constraint), (b :: Constraint)) as a Constraint
15:38:15 <Cale> thatguy: Types are around only at compile time, and they exist on the right side of the :: symbol
15:38:21 <fread2281> like constraints :-
15:38:30 <Cale> thatguy: values are around at runtime, and are on the left side of the :: symbol
15:39:08 <fread2281> https://hackage.haskell.org/package/constraints-0.4.1.3/docs/Data-Constraint.html#g:3
15:39:36 <Cale> thatguy: When you write something like  data Colour = Red | Green | Blue  this defines a new type called Colour, and three new values, Red, Green, and Blue
15:39:53 <Cale> (each of which has type Colour)
15:39:55 <thatguy> Cale, crough, ah ok what I remembered and confused was the type SomeName = String
15:39:59 <thatguy> but that is not what I need
15:40:19 <thatguy> Cale, oh but that is what I need maybe
15:40:20 <EvanR> type String = [Char] ;)
15:40:22 <Cale> yeah, you can give a new name to an existing type like that
15:40:44 <EvanR> [Char] = stack overflow
15:40:45 <Cale> thatguy: Are you sure you don't just want to define some new constants, like
15:40:50 <Cale> green = 0
15:40:52 <Cale> blue = 1
15:40:52 <thatguy> Cale, but I am doing this CIS course everyone recommends and he didn't introduce that kind of data yet, dunno if I should use that for the assignments
15:41:08 <thatguy> Cale, yeah probably that is what I want :D it is late
15:41:13 <thatguy> Cale, thanks
15:44:20 <fread2281> so I have a MPTC quux (c :: * -> Constraint), and I want to write f :: (MPTC quux c, (c a => c (Either () a))) => baz
15:45:24 <EvanR> Either () a aka Maybe a ;)
15:45:38 <EvanR> give or take bottoms
15:45:52 <fread2281> yes
15:46:46 <Cale> fread2281: That's pretty much what the constraint package is for
15:47:07 <fread2281> but then I have to pattern match on it everywhere :|
15:47:31 <dfeuer> The free package makes it clear that FreeT is not a real monad transformer. Does it fail to obey associativity or something?
15:48:40 <johnw> dfeuer: where does it say this?
15:49:32 <dfeuer> johnw, it says it most explicitly at the top of https://hackage.haskell.org/package/free-4.12.1/docs/Control-Monad-Trans-Iter.html but Control.Monad.Trans.Free uses a lot of scare quotes.
15:51:03 <johnw> um, I don't see the scare
15:51:04 <johnw> uotes?
15:51:55 <dfeuer> johnw, look at the docstring for FreeT.
15:52:01 <kristof>  It would be really nice to remember which monad you're in.
15:52:04 <dfeuer> And the one for Free below.
15:52:10 <kristof> do :: []
15:52:13 <kristof> do :: Maybe
15:52:19 <kristof> I'm sure this has come up before.
15:52:20 <johnw> the docstring I see is: "The "free monad transformer" for a functor f"
15:52:23 <johnw> are we looking at the same thing?
15:52:31 <EvanR> kristof: look at the type annotation?
15:53:12 <dfeuer> johnw, yeah, those look like scare quotes, especially in light of the claim in C.M.T.Iter.
15:54:14 <johnw> dfeuer: I still don't get it
15:54:24 <johnw> the only thing I see anywhere even related to what you're saying is: "Unlike Free, this is a true monad transformer."
15:54:33 <johnw> that isn't saying that FreeT isn't a monad transformer
15:54:53 <johnw> it's saying that Free (which can be applied to Monads too) isn't really a monad transformer, although in a way it kind of also is 
15:55:09 <dfeuer> Oh, I wouldn't have read it like that.
15:55:11 <dfeuer> Huh.
15:55:34 <kristof> EvanR: C-c C-t, move eyes all the way to the bottom of the screen. Bleh
15:55:47 <kristof> Oh, you mean in the value it's assigned to.
15:55:55 <kristof> Yeah, that usually has a type signature.
15:56:32 <EvanR> i do sometimes wonder what the types of "inner dos" are when i switch monads
15:56:38 <EvanR> not usually labeled
15:58:01 <fread2281> instantiate the forall in (forall a. c a :- c (Maybe a))
15:58:07 <fread2281> how can I
15:58:42 <Welkin> what is with cabal init?
15:58:50 <Welkin> why does it add constraints on base by default?
15:59:01 <johnw> it's rather conservative by default
15:59:09 <Welkin> base >=4.7 && <4.8
15:59:14 <Welkin> okay
15:59:23 * hackagebot flow 1.0.2 - Write more understandable Haskell.  https://hackage.haskell.org/package/flow-1.0.2 (fozworth)
15:59:27 <Welkin> so it is safe to push it to base <5.0
15:59:47 <EvanR> if it works with base 4.8 and 4.9
16:01:23 <arahael> Somehow, I thought you guys were talking about base 4.8 and 4.9 numbers.
16:02:44 <EvanR> base i
16:03:25 <Welkin> is there a way to have ghci automatically use the language pragmas in the source?
16:03:28 <Welkin> it always seems to ignore them
16:03:29 <Welkin> in particular, I find myself typing :set -XOverloadedStrings every time I open the repl
16:03:35 <kristof> string1 ++ "\n" ++ string2
16:03:40 <kristof> Why is the newline not escaped when I print it?
16:03:57 <Welkin> even though I already have {-# LANGUAGE OverloadedStrings #-} in my source
16:04:52 <EvanR> kristof: try printing the show of the string
16:08:26 <fread2281> edwardk, is it possible to write (forall x. c x :- c (Maybe x)) and use it?
16:12:12 <fread2281> instead of (exists x. c x :- c (Maybe x))
16:17:55 <dfeuer> fread2281, the former is certainly stronger than the latter!
16:18:13 <fread2281> dfeuer, yes, I'm having rouble writing the former
16:18:18 <fread2281> *trouble
16:18:24 <dfeuer> What do you mean by "writing"?
16:19:22 <fread2281> dfeuer, making a function that takes it as argument, writing it's type
16:20:12 <dfeuer> fread2281, I still don't understand. What is the constraint you're trying to prove this about?
16:20:43 <fread2281> so I have a MPTC quux (c :: * -> Constraint), and I want to write f :: (MPTC quux c, (forall a. c a :=> c (Either () a))) => baz
16:20:51 <fread2281> either :=> or :- is fine
16:21:28 <fread2281> no, I need to use :- because you can't write trans for :=> and I need that
16:22:49 <dfeuer> Well, :- doesn't make constraints.
16:23:51 <dfeuer> ^^ fread2281 
16:24:13 <fread2281> sure. f :: (MPTC quux c, c a) => (c x :- c (Either () x)) -> baz is what I have now
16:25:38 <fread2281> and I call f in f with a ~ Either () olda
16:29:55 <fread2281> op, (forall x. c x :- c (Either () x)) works, yay
16:31:48 <Profpatsch> Can someone figure out why this avoids the bottom in head when given an empty list? http://lpaste.net/142320
16:32:04 <Profpatsch> e.g. firstSat id []
16:32:34 <Gurkenglas> filter p [] is [], regardless of the p
16:32:35 <Cale> Profpatsch: If xs is [], then so is filter p xs
16:32:43 <Cale> and so xps will be [] as well
16:32:49 <Cale> So the first guard will match
16:32:56 <Gurkenglas> so null xps is True whenever xs is [], and in those cases xp isnt called
16:32:57 <Cale> and xp never gets used
16:33:32 <Profpatsch> Cale: Ah, I confused the variable names.
16:33:46 <Profpatsch> Thanks!
16:34:00 <Gurkenglas> No fair, I started first and finished first and my lines were longer on average
16:34:19 <Profpatsch> This channel is way to helpful. :)
16:34:43 <Profpatsch> There’s even competition who writes the answer first.
16:35:10 <Profpatsch> That’s why I love #haskell and by extension Haskell.
16:36:32 <Profpatsch> But there is no pattern matching magic that would prevent a bottem from head []?
16:37:25 <Profpatsch> I’m unsure now because I saw the definition of lefts   :: [Either a b] -> [a]
16:37:27 <Profpatsch> lefts x = [a | Left a <- x]
16:38:19 <Profpatsch> Left a <- x should normally result in bottom for Rights (non-exhaustive pattern match)
16:38:31 <Cale> Profpatsch: Well, in a list comprehension, pattern match failure is actually handled -- it just results in no contribution of elements to the list.
16:39:25 <Cale> If you look at the translation in the Report of list comprehension syntax into applications of concatMap, you'll see that the function which gets supplied to concatMap produces an empty list on pattern match failure
16:41:01 <Cale> https://www.haskell.org/onlinereport/exps.html#list-comprehensions
16:41:22 <Cale> (see the stuff in the Translation box)
16:41:48 <Gurkenglas> Profpatsch, of course I would ordinarily use something like this http://lpaste.net/142320#a142322 so one doesn't have to deal with bottoms
16:41:49 <Profpatsch> Cale: I was looking at that yesterday, too, but couldn’t figure it out.
16:42:06 <Cale> So: [a | Left a <- x]
16:42:40 <Profpatsch> Cale: Could ok p = [ e | Q ] be implemented in the language?
16:42:47 <Gurkenglas> (Well, actually I'd use "readMaybe . filter p $ xs", using readMaybe from the safe package because it composes existing building blocks and requires less names and less space etc)
16:43:06 <Gurkenglas> umm headMay I mean lol
16:43:24 <Cale> [a | Left a <- x] --> [a | Left a <- x, True] --> let { ok (Left a) = [a | True]; ok _ = [] } in concatMap ok x
16:43:25 <Profpatsch> I suspect not, because then it would need to be able to catch an non-exh. pattern match, right?
16:43:49 <Cale> --> let { ok (Left a) = [a]; ok _ = [] } in concatMap ok x
16:44:01 <Cale> Profpatsch: hm?
16:44:35 <Profpatsch> Cale: Ah, those are completely syntactic desugaring mechanisms?
16:44:39 <Cale> yes
16:44:47 <Profpatsch> I see.
16:46:29 <Profpatsch> What is the Q in [ a | Left a <- x ] though?
16:46:44 <Cale> Gurkenglas: listToMaybe might be useful
16:47:00 <orion> Are FlexibleInstances safe to use?
16:47:06 <Cale> Profpatsch: That only has one qualifier, so rule 2 applies
16:47:24 <Gurkenglas> Right, I guess that makes more sense than the headMay which might only be included for consistency
16:47:54 <Cale> orion: yes
16:48:20 <Cale> orion: That's probably one of the least controversial extensions.
16:48:23 <Profpatsch> Ah, now I get the transformation.
16:48:36 <Profpatsch> Was reading it wrong.
16:48:50 <glguy> Text.Read.readMaybe is in base
16:48:57 <Cale> Profpatsch: Yeah, it's not written in the clearest possible way there
16:49:32 <Cale> Profpatsch: There's some awkwardness surrounding the fact that things like [e |] are not valid
16:50:24 <orion> Cale: Awesome, thanks. :)
16:50:36 <Profpatsch> I need to use more list comprehensions.
16:50:52 <Cale> btw,  concat [[x1 | cond1], [x2 | cond2], ...] is a rather nice way to have a list with optional elements
16:53:48 <awpr> :t Data.Maybe.catMaybes
16:53:49 <lambdabot> [Maybe a] -> [a]
16:55:07 <Profpatsch> Lists are a bit awkward, because on one hand they are the free Monoid, on the other Haskell constraints the backing implementation to linked lists.
16:55:29 <Cale> Well, lazy linked lists are pretty much the ideal structure to iterate over
16:55:36 <Cale> So they serve as our loops
16:55:54 <Profpatsch> That’s true.
16:56:25 <hpc> it's not like you don't have your choice of other data structures to pick from either
16:56:48 <hpc> and though they have mostly the same api, there's enough differences between them that i have never felt "dang, it'd be nice if i could pass these around generically"
16:57:25 <mreh> any suggestions for outputting Haskell datatypes in a format that's human readable?
16:57:27 <Profpatsch> I’m intruiged by the fact that list comprehensions were generalized to monads prior to Haskell '98.
16:57:41 <Profpatsch> I should continue the history paper.
16:57:43 <mreh> and parsing
16:57:54 <Profpatsch> mreh: read and show
16:58:01 <Profpatsch> :)
16:58:26 <Profpatsch> mreh: From the typeclass Show
16:58:36 <Profpatsch> and Read … meh
16:58:58 <jstimpfle> Cale: you spoke about forced evaluation in presence of GADT type class constraints before
16:59:07 <mreh> show (Just "Hello")
16:59:11 <mreh> > show (Just "Hello")
16:59:12 <lambdabot>  "Just \"Hello\""
16:59:21 <Cale> jstimpfle: Yeah
16:59:25 <mreh> Profpatsch, not quite what I want :)
16:59:37 <jstimpfle> but isn't it actually the caller which decides what instance to use? so i fail to see where this might be a performance problem
16:59:42 <mreh> it's going to output it in one line
16:59:53 <jstimpfle> i mean, it's not like a virtual dispatch penalty, is it?
17:00:34 <Profpatsch> mreh: You probably don’t want to convert them to JSON either?
17:00:41 <jstimpfle> my thinking is, if the call is going on, then evaluation should already be at a point where the instance is known
17:00:45 <mreh> Profpatsch, it's an option
17:00:48 <Cale> jstimpfle: I don't tend to worry about performance issues which are that small. The price you'll be paying is approximately the same -- though you raise a good point that it does force some additional evaluation to occur which you might have wanted to defer (though there are ways around that)
17:01:02 <Profpatsch> mreh: The real question is: why would you want to parse them in again?
17:01:04 <mreh> but JSON doesn't convert to Native haskell
17:01:32 <mreh> Profpatsch, as a kind of primitive database
17:01:35 <Cale> jstimpfle: I was more pointing out that it can be a bit of a syntactic burden -- you're forced to pattern match even in cases where you might otherwise not have to.
17:01:44 <mreh> writing out data to files
17:01:59 <jstimpfle> Cale: got it, thanks
17:02:05 <Cale> (and you have to remember to pattern match, rather than just doing the natural thing)
17:02:30 <Profpatsch> hpc: Could it be that a linked list has even more interesting properties apart from being the free monoid in Hask?
17:03:06 <Profpatsch> mreh: We need something like s-exprs with type annotations. :)
17:03:15 <hpc> Profpatsch: it's also convenient for being able to trivially represent infinite streams
17:03:31 <lambdafan> I have a Data.Map.Strict, that I know a key value pair exists in. When I do a lookup, I will never get a Nothing value. This suggests it is safe to use fromJust, but is there a better way?
17:03:49 <Profpatsch> mreh: In the end it all boils down to wether you innermost fields have Show instances (and Read instances).
17:04:01 <hpc> lambdafan: write a dead Nothing case and know it'll never happen?
17:04:10 <Profpatsch> mreh: In case you want to get Strings
17:04:14 <hpc> and if it does, now you have a message there instead of patten match failure
17:04:25 <Profpatsch> mreh: Take a look at https://hackage.haskell.org/package/cereal-0.4.1.1/docs/Data-Serialize.html
17:04:34 <Gurkenglas> lambdafan, fromJustNote from the safe package lets you specify an error message
17:04:57 <lambdafan> Gurkenglas: Is that not just for associated lists?
17:05:08 <lambdafan> What I have is a Map
17:05:19 <Gurkenglas> :t fromJustNote
17:05:20 <Cale> Profpatsch: It's actually not technically the free monoid -- it has a bunch of additional relations. For any list ys and any infinite list xs, you have xs ++ ys = xs
17:05:20 <lambdabot> String -> Maybe a -> a
17:06:02 <hpc> Profpatsch: oh, and it's native haskell which is nice
17:06:19 <hpc> as opposed to arrays and vectors and such which are blobs of memory?
17:06:26 <Profpatsch> Cale: you are right, that was a point in the talk; it’s actually the non-infinite list.
17:07:07 <xplat> the linked list is a loop
17:07:48 <lambdafan> Gurkenglas: That's what I want!. I want to fail with a mesage if this impossible situation happens.
17:08:05 <Profpatsch> xplat: Probably the most trivial representation of a loop.
17:08:59 <xplat> Profpatsch: but unlike trivial representations of loops as data in other languages it actually works ...
17:09:15 <xplat> because laziness
17:09:38 <Profpatsch> heh, for endless loops it cerainly does.
17:10:00 <mreh> Profpatsch, Text.Show.Pretty
17:10:37 <Profpatsch> That’s why iterate, repeat, replicate and cycle work so well.
17:11:47 <Profpatsch> mreh: Hm, but only in one direction.
17:12:26 <Profpatsch> mreh: For a file store I’d generally recommend a well-defined plain text serialization format, like json, yaml or toml
17:13:08 <xplat> toml?  that's a new one to me
17:13:42 <Profpatsch> xplat: I like it. Not sure how mature Haskell support is, though.
17:14:18 <Profpatsch> yaml is way to complex for my taste. I wouldn’t be surprised if it was turing complete.
17:14:26 <xplat> the great thing about standards is how many there are to choose from
17:14:42 <Profpatsch> For each use-case hopefully a good match.
17:15:04 <taylorhamcheese> Hi everyone. First time on IRC is today. Haskell seems cool :)
17:15:07 <xplat> yaml is not turing complete.  it is a little complex.  it's nice for non-hostile human-generated data.
17:15:18 <Profpatsch> Storage is still a hard problem, though.
17:15:19 <glguy> For debugging pretty-show's Text.Show.Pretty is handy
17:15:40 <Profpatsch> As long as everything lies within the GHC runtime all’s fine and dandy.
17:15:46 <glguy> I put this together as a config language for my IRC client. Similar to Yaml without the ambiguities or surprises: http://hackage.haskell.org/package/config-value
17:15:48 <xplat> storage -> use a relational database.
17:15:57 <Profpatsch> taylorhamcheese: Hi there! Hope you enjoy your stay. :P
17:16:36 <orion> If I write a function that returns type 'a', that's almost useless, because I've basically thrown away type information, right>?
17:16:47 <Profpatsch> glguy: The first rule of markup languages is everyone defines his own markup language. :D
17:16:56 <xplat> orion: it's also really hard to write
17:17:09 <jstimpfle> orion: the only way to write that is "undefined"
17:17:14 <hpc> orion: or extremely useful on the other side, because you have whole swaths of operations you can't perform on it
17:17:36 <hpc> and thus know it'll not be messed with if you use it later
17:17:46 <Profpatsch> hpc: That’s Void, right?
17:17:50 <xplat> orion: well, not that hard.  'undefined', 'error ":("', 'error "i don't know what type this is!"', 'fix id', 'fix unsafeCoerce'
17:17:54 <orion> If I put a type class restriction like Byteable on it, that will allow me to at least use toBytes, right?
17:18:35 <hpc> orion: what does this function do, and what type does it have right now?
17:18:54 <Profpatsch> This conversation should land in the #haskell best-of compilation.
17:19:43 <orion> hpc: The function is called "encryptAndHash", and the spec I'm reading defines it thusly: "EncryptAndHash(plaintext): If has_key == True sets ciphertext = EncryptAndIncrement(h, plaintext), calls MixHash(ciphertext), and returns ciphertext. Otherwise calls MixHash(plaintext) and returns plaintext"
17:20:18 <orion> Right now I have: "encryptAndHash :: SymmetricHandshakeState c -> Plaintext -> Either (Ciphertext c) Plaintext"
17:20:27 <hpc> sounds like at the very worst, you have Something a => a -> a
17:20:27 <xplat> Profpatsch: stick around, you'll see better
17:20:35 <hpc> (for some value of Something)
17:20:45 <hpc> because it takes plaintext and potentially produces it
17:20:51 <orion> What annoys me about crypto is that the people who write these specs just assume everything are bytes.
17:21:17 <orion> s/are/is
17:21:34 <xplat> nah, they assume things are bits, but they're kind enough to say bytes instead for the implementors
17:21:51 <hpc> it's what the algorithms operate on after all
17:22:12 <orion> But then they write stuff like I posted above, and it makes it very difficult for me to write a well-typed library.
17:22:15 <sm> toml, interesting. http://npf.io/2014/08/intro-to-toml
17:23:49 <orion> hpc: What do you think about this signature?: "encryptAndHash :: (Byteable a, Byteable b) => SymmetricHandshakeState c -> a -> b ?
17:24:26 <Profpatsch> sm: It’s like a standardized .ini with sensible features. Best of json and yaml, without the complexity and {{[]}}
17:24:56 <orion> I'm nervous about it because, while it solves my problem, the result can only be used with toBytes.
17:26:49 <fread2281> orion, shouldn't the result just be ByteString? what else would you want to do with it?
17:27:47 <orion> fread2281: It could very well be ByteString.
17:28:40 <orion> What else could I do with it? Nothing... yet.
17:28:50 <orion> fread2281: So, I suppose I'm overengineering it.
17:30:12 <sm> Profpatsch: I just filed an installation bug against htoml
17:30:18 <fread2281> orion, the input could be (Binary a => a) or (Serializable a => a), but you should still provide a version that takes a ByteString as input
17:30:42 <hpc> BS is an instance of Binary, isn't it?
17:31:00 <Profpatsch> sm: Progress. :D
17:32:15 <sm> it looks maybe preferable to the ConfigFile lib
17:33:00 <fread2281> hpc, yes, but it puts a length
17:36:18 <saulzar> toml nested tables seem a bit ugh - they're like the old windows config files. Maybe fine if that's what they're being used for 
17:36:59 <Profpatsch> saulzar: Yes, they are definitely a config file and no serialization for data structures.
17:37:09 <MarcelineVQ> It's for configs, if you need a lot of nesting it might not be the right way to go
17:37:15 <Profpatsch> Although they can of course be used as such.
17:37:46 <Profpatsch> There should be a trivial conversion JSON -> TOML -> JSON
17:37:58 <Profpatsch> TOML -> JSON is not total, though.
17:38:35 <Profpatsch> At least not without further encoding specification.
17:41:28 <fread2281> Profpatsch, huh?
17:42:49 <Profpatsch> fread2281: toml does dates for example.
17:43:00 <jstimpfle> i'm still looking for something usable for little text relational databases (like passwd)
17:43:20 <Profpatsch> jstimpfle: csv?
17:43:24 <hpc> passwd is relational?
17:43:44 <Profpatsch> hpc: If you count csv as ration database, then yes.
17:43:45 <jstimpfle> i'm not sure i like dates in there. it's always the wrong one included
17:44:04 <Profpatsch> A very primitive relational database.
17:44:05 <hpc> csv represents only a single table
17:44:09 <hpc> there's no relations
17:44:10 <fread2281> Profpatsch, it's still total though, with the obvious dates -> strings
17:44:12 <jstimpfle> of course, unix text files are some of the earliest relational databases :-)
17:44:25 <Clint> wat
17:44:37 <arahael> Heh.
17:44:48 <fread2281> of course, you might get some quoted dates as dates in TOML -> JSON -> TOML, but meh
17:45:42 <Profpatsch> fread2281: You are right. We should create an isomorphism and be done with it.
17:45:56 <Profpatsch> Then people can argue over syntax all they want.
17:46:49 <Sebastian> So I gather that Haskell is a lazy language, meaning expressions aren't necessarily evaluated immediately, but only when they're actually needed (e.g. to perform something side-effecty). Can the duration of an expression prior to evaluation be proven? If not, why not? If so, why is garbage collection necessary?
17:46:59 <jstimpfle> i feel for a generally usable database / config file format there should be a mechanism to include custom types
17:47:13 <jstimpfle> but maybe that inevitable leads to a situation like ldap
17:47:23 <jstimpfle> *inevitably
17:48:01 <hpc> Sebastian: values don't vanish from memory after they are evaluated
17:48:05 <Profpatsch> jstimpfle: Hm, normally for formats like JSON you have a metalevel like JSON Schema.
17:48:21 <hpc> GC and laziness are orthogonal to each other
17:48:29 <Profpatsch> Which can be defined with itself again.
17:48:42 <Profpatsch> In practice nobody uses that of course.
17:49:03 <jstimpfle> with json that might be because hierarchies.
17:49:12 <Sebastian> hpc: What does that mean? Sorry, but I don't believe mathematical terms are necessary to establish a conclusive answer.
17:49:38 <Profpatsch> Aren’t DTD, XML Schema and JSON Schema the same as very crude type system??
17:49:40 <Profpatsch> *s?
17:49:42 <Sebastian> hpc: If you intended to explain that the former sentence is irrelevant to the question, sure... I realise this.
17:50:08 <Sebastian> hpc: There is no need to point out the obvious.
17:50:53 <jstimpfle> i honestly don't really know about these. but i guess they must be more concerned about relations, and thus more complex
17:51:07 <hpc> my suspicion is that computing lifetime of haskell values is going to be equal to the halting problem
17:51:21 <Profpatsch> jstimpfle: You could take a look at RDF.
17:51:26 <jstimpfle> if you have flat things, then it's more about just specifying what the individual types are. which of course is more feasable
17:51:35 <jstimpfle> Profpatsch: I'll do that, thank you
17:51:38 <Sebastian> hpc: So you say that values don't vanish from memory after they are evaluated, which is a good point... and that point applies to other programming languages, which commonly perform optimisations based on the visibility of a value, such as optimising away unnecessary variables... Is such an optimisation available to Haskell?
17:51:54 <Profpatsch> jstimpfle: But it’s going to be a hard and stony path and might not what you expect.
17:53:02 <Sebastian> If not, why not? Does Haskell have anything like eval() in Javascript that prevents such an optimisation from being correct?
17:53:11 <fread2281> Sebastian, haskell like every other programming language can avoid gc by doing DFA
17:53:14 <Profpatsch> jstimpfle: The Wikipedia article might or might not be a good introduction: https://en.wikipedia.org/wiki/Resource_Description_Framework
17:53:24 <orion> Grr!! The spec now wants me to set the value of a SymmetricKey to be the output of a hash (type = Digest). And all these types I took so long to cafeully craft go out the window.
17:53:27 <Sebastian> If so, why can't the same form of optimisation be used instead of GC?
17:53:47 <fread2281> Sebastian, haskell can also optimize away unnecissary variables like every other language
17:54:07 <fread2281> Sebastian, it can, it's just untolerably slow and expensive
17:54:26 * hackagebot streaming 0.1.1.0 - an elementary streaming prelude and a general monad transformer for streaming applications.  https://hackage.haskell.org/package/streaming-0.1.1.0 (MichaelThompson)
17:55:45 <Profpatsch> Holy crap, I just discovered that it should be trivial to encode ADTs in RDF.
17:57:05 <Sebastian> fread: Why is it untolerably slow and expensive? I would think such a task would be more difficult in Javascript, right?
17:57:36 <fread2281> Sebastian, not really
17:57:44 <Profpatsch> Sebastian: Imagine the most optimizing of the world. Then look at GHC.
17:58:02 <Profpatsch> *optimizing compiler in
17:58:37 <Sebastian> Sure. I'm just trying to understand why a GC (particularly a poor one) was chosen.
17:58:56 <fread2281> Sebastian, haskell's GC is really good because no mutation
17:59:33 <arahael> So, I have a bunch of infinite lists.  An infinite list of primes, etcetera.
18:00:09 <fread2281> Sebastian, old generations can't point into new generations, which simplifies things
18:00:11 <arahael> My program is dirt slow, though.  And the reason is obvious - the algorithms are very slow. (Primes, for instance, is just a naive sieve, in the most naive form)
18:00:11 <Sebastian> fread2281: Only if you consider parrallelism to be non-existent, which Haskell is supposed to be good at... and then there's cache friendliness...
18:00:25 <arahael> What's the easiest, most trivial way to help me profile and see performance issues?
18:00:34 <neuroserpens> :t sqrt
18:00:35 <arahael> (As I think it's a good excuse for profiling)
18:00:36 <lambdabot> Floating a => a -> a
18:01:17 <heatsink> You can compile with -prof, then run with +RTS -p to get an execution time profile
18:01:30 <fread2281> Sebastian, no GC will 99.9% of the time beat a GC, a GC is used for haskell do that we don't have to do manual memory management
18:01:31 <heatsink> Compile with -prof -rtsopts
18:01:44 <fread2281> Sebastian, where to you get the idea that haskell's GC is poor?
18:01:50 <arahael> heatsink: Thanks.
18:02:47 <Sebastian> fread: "no GC will 99.9% of the time beat a GC" is orthogonal to my query. I'm asking why a GC is necessary, not whether Haskells GC is of decent quality (I know it isn't).
18:02:51 <arahael> heatsink: Hmm, I'm confused: How does +RTS play with the program's opt parsing?
18:03:14 <jstimpfle> i remember even john carmack say that the haskell gc is just a very deterministic constant small overhead, around 2013 when he evaluated haskell for gaming. It's certainly not the reason why he went into scheme later instead
18:03:15 <heatsink> arahael: Options after +RTS are intercepted by the runtime system before your program sees them
18:03:57 <crough> I swear to god, things that are typed `HashMap Text Value` are the most frustrating things...
18:04:00 <heatsink> arahael: The runtime system parses those arguments if you compile with -rtsopts
18:04:04 <crough> API developers, get your shit together
18:04:08 <arahael> heatsink: And only if you have -rtsopt, I see.  That's cool.
18:04:27 * hackagebot streaming-bytestring 0.1.1.0 - effectful byte steams, or: bytestring io done right.  https://hackage.haskell.org/package/streaming-bytestring-0.1.1.0 (MichaelThompson)
18:04:30 <Sebastian> fread2281: Most GCs are poor, and you only need to look at how they're used to determine why. In Java, for example, you have no way to tell the GC that an object is no longer used; it has to discover that fact all by itself. There is no mechanism for providing hints, and thus little by which tuning/optimisation can be performed. Isn't this the same in
18:04:30 <Sebastian> Haskell?
18:05:07 <fread2281> Sebastian, Data Flow Analysis is the idea of figuring out where data goes, a.k.a when memory is used, and wole program DFA is expensive because it increases in complexity very fast 
18:05:28 <arahael> Sebastian: You seem to think that a GC cares at all about objects that aren't being used.
18:05:33 <arahael> Sebastian: That would be a very poor GC.
18:05:35 <fread2281> Sebastian, it is, that's the point of a GC, that you don't need to free memory manually
18:05:57 <Sebastian> fread2281: Compilers for other languages typically use this technique during compilation to eliminate dead code and variables, right?
18:06:19 <fread2281> Sebastian, sure, but they don't do whole-program DFA
18:06:20 <Sebastian> arahael: They have to, in order to reclaim them.
18:06:46 <arahael> Sebastian: No, they don't. The fact that a (dead) object occupies free space is a nice side effect.
18:06:53 <Sebastian> fread2281: No. Originally, GC was used to determine when memory wasn't freed manually, and to free it... at a cost, of course.
18:06:54 <fread2281> Sebastian, once you start dealing with the interactions between functions it increases in complexity fast
18:07:36 <arahael> Sebastian: It is usually better to keep track of live objects.  And regard all the rest of the memory as free space.
18:07:44 <Sebastian> fread2281: Nonetheless, other compilers use this technique, some even at the linking phase of compilation.
18:08:05 <arahael> Sebastian: Essentially, dead objects become *forgotten*.
18:08:16 <fread2281> Sebastian, ghc does the same amount of DFA as most compilers
18:08:17 <Sebastian> arahael: So they leak, then?
18:08:47 <arahael> Sebastian: No, imagine it this way.
18:08:53 <fread2281> Sebastian, doing more, as is required to determine how memory is used, isn't done in any real compilers that I know of
18:09:12 <Sebastian> arahael: Is this going to answer my questions?
18:09:22 <arahael> Sebastian: GC calls out: "Hey program, do you have any objects using this memory?" Program: "Uhh... Nope, can't see anything using it". GC: "That memory must be available, then!"
18:09:41 <fread2281> Sebastian, ghc allocates zones of memory that it every often copies lives objects out of and frees/re-uses
18:09:53 <arahael> Sebastian: A dead object, no-longer reachable by the program is thus completely ignored.
18:10:08 <arahael> Sebastian: And since it's not reachable, it might as well not exist.
18:10:10 <Sebastian> fread2281: If gcc can determine when a variable is unused, why can't Haskell use the same technique to determine when an expression can be freed, rather than using an expensive GC system?
18:10:18 <EvanR> arahael: unlike threads
18:10:29 <EvanR> unreachable threads might as well exist
18:10:37 <arahael> EvanR: Lets not complicate it.
18:10:42 <fread2281> Sebastian, because gcc can't use it to determine when a variable can be freed
18:10:51 <Sebastian> arahael: Right, so the garbage collection is essentially a graph traversal. You're not telling me anything new.
18:11:13 <arahael> Sebastian: The difference is, you seem to think it's a graph traversal of *dead objects*. It's not. It's a graph traversal of *live objects*.
18:11:27 <Sebastian> fread2281: But it can. Otherwise it can't use it to determine that the variable is unused.
18:11:36 <EvanR> unused variables?
18:11:54 <Sebastian> arahael: : Sure. It's graph traversa to determine if an object is dead or live.
18:12:00 <arahael> Sebastian: Nope.
18:12:03 <fread2281> Sebastian, then why do you need to free in C?
18:12:14 <EvanR> its not determining if objects are alive or dead, its finding which objects are alive
18:12:22 <heatsink> Sebastian, do you know what a copying collector is?
18:12:23 <arahael> Sebastian: If the object is in the graph, it's live.  Dead objects never enter the equation.
18:12:58 <fread2281> Sebastian, why can't gcc insert frees automatically?
18:13:02 <jstimpfle> Sebastian: Are you talking about knowing statically knowing at what points objects will be unused? That would of course be the equivalent to the halting problem again...
18:13:23 <Sebastian> fread2281: You don't need to free variables. You need to free objects that are allocated by malloc. Technically, what a leak surmounts to is undefined; there might be a garbage collector behind malloc deciding when memory has leaked from the live graph.
18:13:43 <arahael> jstimpfle: Which is exactly what happens when people, for some reason, try to add "finalizers" to their GC systems, which of course, are a bad idea.
18:13:44 <EvanR> indeed "free" is a noop if you use a gc for C
18:13:47 <Sebastian> fread2281: Can you prove that gcc can't insert frees automatically?
18:14:09 <arahael> Sebastian: Typically if you're using a GC, you're not using malloc anymore.
18:14:15 <Sebastian> Not necessarily, EvanR. It could be a "hint" rather than a "noop".
18:14:28 <EvanR> Sebastian: it can insert frees, by using reference counting in the implementation. which is slow and stupid
18:14:31 <arahael> Sebastian: Instead, the GC might malloc a single 100MB bucket, but that's it.
18:14:33 <Sebastian> arahael: I don't think malloc is what you think it is.
18:14:42 <fread2281> Sebastian, go ask a C developer that you trust
18:14:47 <arahael> Sebastian: Eh?
18:14:50 <fread2281> Sebastian, think of variables in haskell as pointers to objects or thunks
18:14:55 <Sebastian> EvanR: reference counting is no more necessary than GC.
18:15:03 * arahael is a far, far better C programmer than he is at Haskell.
18:15:05 <Sebastian> fread2281: I am a C developer that I trust.
18:15:09 <fread2281> Sebastian, gcc can't
18:15:26 <Sebastian> fread2281: Show me where in the C standard it says that malloc/free aren't implemented using garbage collection algorithms.
18:15:26 <EvanR> is the discussion whether GC is necessary?
18:15:28 <fread2281> Sebastian, why do C programs call free if gcc can?
18:15:39 <Sebastian> fread2281: It's not up to gcc.
18:16:19 <Sebastian> fread2281: gcc is not representative of all C implementations.
18:16:24 <fread2281> Sebastian, sure, malloc can use a gc, but gcc can't instert frees where they are needed, which is what you're asking for
18:16:40 <heatsink> C developers make extra copies of data for the sole purpose of having predictable lifetimes so that they can free data correctly.
18:16:49 <arahael> Sebastian: GC's in C have some severe constraints and limitations.  Primarily, they often can't move objects around.
18:17:17 <fread2281> theoretically, a C implementation that does full-program DFA can, but show me that does
18:17:33 <EvanR> its possible in some languages to compile it such that memory is automatically managed without a GC
18:17:51 <arahael> EvanR: To a point - C++ does demonstrate this.  I think rust might as well.
18:17:55 <tabemann> as mentioned, there are implementations of malloc that *do* have GC in C... but they have severe limitations in practice
18:18:03 <Sebastian> Sure it can, providing it can deduce that free and malloc do what they're specified to do in the standard.
18:18:06 <squall> Am I correct in thinking that as Haskell uses lazy evaluation that gc is not necessary?
18:18:08 <arahael> boehm, in particular.
18:18:15 <EvanR> arahael: i was thinking of more specialized languages designed specifically for this
18:18:35 <Sebastian> No, squall. Lazy evaluation is irrelevant here.
18:18:37 <EvanR> squall: no thats not correct
18:18:37 <tabemann> e.g. a GC in C requires what is known as *conservative* GC - where all address word-sized groupings of data have to be treated as a potential reference
18:18:40 <arahael> EvanR: I'm not aware of more specific languages, in this case.
18:18:47 <Sebastian> What is relevant is storage duration.
18:18:58 <fread2281> Sebastian, point is, there's no magic sauce in laziness that makes memory management easier
18:19:12 <EvanR> you cant do it in C or haskell because the usage patterns are unpredictable at compile time
18:19:29 <squall> True
18:19:31 <EvanR> gcc cant know if you want it to be free or not
18:19:35 <tabemann> what makes GC easier in Haskell is not laziness but rather that the compiler knows what is a reference and what is not
18:19:47 <EvanR> tabemann: also immutable data
18:19:55 <squall> So gc is a bad idea?
18:19:59 <tabemann> whereas due to wonders like people stuffing void*s into longs in C code, you can't trust *any* data to not be a reference
18:20:04 <arahael> tabemann: In addition to being allowed knowing how the references work.  Haskell devs don't tend to use raw pointers much.
18:20:09 <EvanR> squall: no, gc is an awesome idea
18:20:20 <Sebastian> fread2281: I understand that. My first sentence wasn't relevant to my question; it was just to show that I understand laziness so we wouldn't have to have a discussion about the lifetime of expressions.
18:20:25 <heatsink> Determining the lifetime of dynamically allocated data is undecidable and intractable in practice.
18:20:43 <squall> But you should let it know if the data is likely to be reused
18:20:45 <Sebastian> fread2281: That was obviously futile, since you started a discussion about why it was irrelevant... We essentially had that discussion anyway.
18:20:46 <heatsink> It can be solved in enough special cases to be useful as a supplement to GC
18:21:01 <tabemann> to determine the lifetime of dynamically allocated data requires solving the halting problem
18:21:04 <fread2281> Sebastian, memory management is hard pretty much no matter what the language
18:21:18 <Sebastian> Indeed, heatsink, which is what makes Haskell's GC decidedly poor.
18:21:34 <EvanR> fread2281: well, a basic copying collector is pretty simple
18:21:35 <heatsink> What?
18:21:52 <heatsink> That does not follow, Sebastian.
18:22:03 <EvanR> Sebastian: GHCs garbage collector is actually really awesome
18:22:10 <Sebastian> heatsink: There is no supplement to GC in Haskell, is there?
18:22:14 <tabemann> Haskell's GC is not "decidedly poor" - it is just optimized for a maximum rate of garbage collection rather than for responsiveness
18:22:35 <EvanR> its also optimized for responsiveness, since it can run incrementally
18:22:46 <EvanR> and concurrently
18:22:50 <fread2281> Sebastian, compared to e.g. Java, ghc's GC is great
18:22:55 <tabemann> you can't trust humans to do memory management, Sebastian - so we cannot allow humans to have free() at their disposal, as they'll introduce bugs with it if they can use it
18:23:03 <Sebastian> EvanR: You keep saying that, but you don't seem to be saying "Actually, Haskell *DOES* accept hints by a mechanism such as free()"
18:23:06 <squall> How does it decide what to store?
18:23:06 <arahael> Python's GC, by contrast, is embarrasingly bad.
18:23:14 <tabemann> EvanR: oh, GHC's GC switched from stop the world to incremental?
18:23:14 <heatsink> Sebastian: There is.  The compiler removes a lot of unnecessary memory allocation from the program.
18:23:22 <Sebastian> fread2281: What is so great about GHCs GC compared to Java?
18:23:39 <EvanR> tabemann: it stops the world, but it doesnt have to do a whole gc before starting the world again
18:23:56 <tabemann> EvanR: well yes, there's the split between minor GC and major GC
18:24:04 <arahael> Sebastian: Java's GC has to deal with finalizers, which are stupid.
18:24:13 <EvanR> GHC also supports finalizers
18:24:27 <arahael> EvanR: Blegh.
18:24:28 * hackagebot streaming-utils 0.1.1.0 - http, attoparsec and pipes utilities for streaming and streaming-bytestring  https://hackage.haskell.org/package/streaming-utils-0.1.1.0 (MichaelThompson)
18:24:34 <jstimpfle> i don't even think that C has something like "unreferenced" allocated storage. technically, write away references to a file, restore them later, and use the referenced memory. Or am i wrong?
18:24:48 <arahael> jstimpfle: You can do that in C.
18:24:55 <tabemann> yes, you can do that
18:24:55 <arahael> jstimpfle: But it is greately discouraged in modern coding.
18:24:58 <jstimpfle> arahael: by the spec?
18:25:04 <squall> Omg how do we do this stuff!? Finalisers and free?
18:25:13 <arahael> jstimpfle: Spec doesn't discuss this, iirc.
18:25:14 <fread2281> Sebastian, ghc can do nursery collections without touching older generations because of immutability
18:25:20 <jstimpfle> and how are C GCs implemented? further restricting the spec?
18:25:24 <silver> we need to steal Go's GC
18:25:38 <arahael> jstimpfle: C GC's deal with this by explicitly saying: "Don't do it".
18:25:42 <Sebastian> jstimpfle: Technically, C doesn't require files. FILE fopen(char const *filename, char const *mode) { return NULL; }
18:25:53 <Sebastian> s/FILE/FILE */
18:26:03 <EvanR> Sebastian: since youre programming in haskell with expressions more often than explicit objects like IORefs, it wouldnt really make sense to "free an expression"
18:26:13 <tabemann> jstimplfe: C GCs are implemented by assuming that every address-word sized octet sequence is a reference - every last one of them
18:26:19 <EvanR> youre on a different level from the operational semantics of objects and pointers
18:26:23 <jstimpfle> Sebastian: yes i know. I just made up some kind of "inversible function"
18:27:18 <tabemann> mind you that compared with something like GHC's GC, this is horribly inefficient, and results in things never getting GCed because some value happens to look like a pointer pointing to them
18:27:21 <Sebastian> jstimpfle: It makes no more sense to write a pointer to a file, and then read it back, as it does to read from /dev/random into a pointer and try to access that.
18:27:35 <jstimpfle> completely clear on that
18:27:41 <arahael> Sebastian: I disagree.
18:27:51 <tabemann> mind you that the whole write-a-pointer-to-a-file thing breaks C GCs
18:27:52 <EvanR> you cant write a pointer to a file
18:27:54 <Sebastian> jstimpfle: Hence, no garbage collection would bother considering that. What happens if the user modifies the file and the reference disappears?
18:27:55 <squall> If gc deletes pointer references, how is there an analogy to pointers in Haskell for this to make sense?
18:28:08 <arahael> Sebastian: A C programmer can dump a block of memory to disk.  And then later restore it when it needs to.
18:28:21 <arahael> Sebastian: Such manual paging is especially common in constrained environments and embedded systems.
18:28:22 <EvanR> you can only write bytes to a file, or the encoded integer that a pointer getes coerced to
18:28:27 <jstimpfle> arahael: he means races with other threads / processes
18:28:41 <arahael> jstimpfle: Why doesn't he specify that, then(!)
18:29:07 <tabemann> EvanR: it's simple enough to cast a pointer to a pointer to a char*
18:29:13 <Sebastian> arahael: That sounds like something a sensible OS would do, an operation commonly called "paging"... Why would a sensible C programmer reinvent the wheel? C was designed precisely to avoid reinvention of the wheel.
18:29:23 <EvanR> tabemann: well, thats not a pointer anymore
18:29:32 <arahael> Sebastian: I dunno. The last 8081 chip I saw didn't have such an OS on it.
18:29:54 <Sebastian> Is it really common in embedded systems, where my example "FILE *fopen(char const *, char const *) { return NULL; }" came from?
18:29:55 <tabemann> Sebastian: when's the last time you developed on something with less than 64K of RAM?
18:30:02 <EvanR> Sebastian: pretty sure you have to reinvent several wheels an hour when writing C code
18:30:24 <arahael> Sebastian: Actually we didn't have fopen, since we didn't have a filesystem.
18:30:34 <arahael> Sebastian: Incidentially, filesystems are not part of the C spec.
18:30:51 <Sebastian> tabemann: When was the last time you made a distinction between freestanding and hosted implementations of C?
18:30:53 <squall> How does Windows gc compared to c or haskells?
18:31:08 <arahael> squall: Windows doesn't have a GC.
18:31:13 <xplat> hpc: the tables are the relations in relational databases, so even with one table there's one relation
18:31:33 <Sebastian> arahael: Indeed, they are particularly not a part of the freestanding part of the spec, which is what you're discussing now...
18:31:47 <squall> So how does it free memory?
18:31:52 <EvanR> can we stop talking about the C spec please
18:32:09 <arahael> Sebastian: I didn't bring up the spec.
18:32:40 <Sebastian> The OS keeps track of memory allocated by the program, and any leaking memory is reclaimed when the program exits.
18:33:12 <arahael> Sebastian: Only partially true.
18:33:23 <Sebastian> arahael: Someone asked me to consult a reliable C programmer... I mustn't be one.
18:33:26 <arahael> Sebastian: The OS, in most modern system, keeps track of *pages* allocated by the program.
18:33:31 <squall> The is never had to free memory after a bad exit or something?
18:33:35 <tabemann> OSes typically operate in terms of pages, not the frequently much smaller blocks of memory actual language implementations deal with - and GC is typically at the language level, not the OS level
18:33:37 <Sebastian> arahael: On Windows, it does. That's what squall asked about.
18:33:37 <squall> Os
18:33:49 <jstimpfle> xplat: if you mean passwd etc., these are actually multiple tables, in multiple files
18:34:37 <squall> So how do I ensure efficient gc in Haskell?
18:34:47 <EvanR> so you both know how OSs and GCs work you can stop arguing
18:35:05 <tabemann> squall: well obviously the OS frees all pages allocated to a process once it exits provided they are not shared with any other processes - but that GC is not
18:35:39 <Sebastian> Fair enough. I got my answer ages back, not long after I asked the question... and it's the answer I suspected, which is that Haskell technically does not need GC.
18:35:40 <arahael> Sebastian: On windows, malloc is most likely implemented on top of HeapAlloc.
18:35:49 <EvanR> nothing needs a GC
18:36:01 <fread2281> Sebastian, ignore what I said about ghc's GC, I can't find any benchmarks
18:36:17 <EvanR> you can just keep allocating memory for ever and ever
18:36:22 <heatsink> A Haskell implementation will leak memory if it does not have GC.
18:36:55 <tabemann> Haskell does not need GC in an environment where it will use less memory than the amount that can be allocated by the language implementation before it exits - the problem is that Haskell uses so much memory so fast that it will exhaust this amount within probably seconds in many cases
18:37:03 <EvanR> as memory gets bigger and cheaper we will eventually be unable to use it all fast enough
18:37:56 <squall> Oh so if I'm folding I can dump a bunch of values from memory as i go...
18:38:02 <Sebastian> EvanR: Grep the discussion for DFA to discover why Haskell does not need GC to determine whether an object (or expression, rather) is alive or dead, in order to reclaim it
18:38:03 <heatsink> EvanR: When the singularity comes, the amount memory of memory will grow faster than it can be used
18:38:03 <tabemann> the thing is that most systems are not devoted to a single process, so even if this *is* possible with a single process on the system implemented in Haskell, this is not practical in practice
18:38:30 <arahael> Infact, if I recall, the earlier versions of PHP didn't have a GC. They just leaked memory until they exited.
18:38:39 <tabemann> Sebastian: that is claiming that you can solve the halting problem
18:38:49 <EvanR> Sebastian: i still dont get your account of reclaiming expressions, this seems like a mix up of operational semantics with something on the language level
18:38:50 <jstimpfle> Sebastian: I just can't imagine any way to code a haskell program where the programmer could know when thunks could be freed.
18:39:07 <Sebastian> I don't believe it is, tabemann.
18:39:56 <EvanR> but if you have an alternate design for a gc i would love to see it
18:39:58 <Sebastian> EvanR: Consider that garbage collection isn't necessarily just used for objects in Haskell, as it is in other languages, but also expressions... due to laziness.
18:40:05 <tabemann> there is no way to statically determine the lifetime of an object *in all cases*
18:40:30 <arahael> Which is exactly why finalizers are so complicated.
18:40:30 <squall> That's come up before
18:40:41 <glguy> nt memory of memory will grow faster than it can be used 
18:40:53 <glguy> (kid got to the trackpad)
18:41:53 <heatsink> Sebastian: Expressions do not exist in dynamically allocated memory.  Operationally, unevaluated thunks and continuations exist (I forget whether continuations are unevaluated thunks).  These have a loose relationship to expressions, but they are not expressions.
18:42:55 <EvanR> so youre still really talking about reclaiming memory used by objects (thunks, data)
18:43:38 <Sebastian> heatsink: Right. I had forgotten the term for them, but you are right. I meant to say "thunks" :)
18:44:02 <heatsink> Sebastian: Those exist in strict languages too, by the way.  In strict languages, they're collectively called the stack.
18:44:33 <Cale> I dunno, I tend to say the word "expression" when referring to the runtime things which thunks represent.
18:44:34 <Sebastian> heatsink: Can you show me where in the C standard this "stack" is described?
18:44:57 <EvanR> but a given expression on the page may not equate to a runtime object, or only one
18:45:00 <Cale> function : closure :: (runtime) expression : thunk
18:45:09 <arahael> Sebastian: You seem to be bringing up the C standard /again/.
18:45:37 <Cale> Yes, thunks are used to implement unevaluated expressions at runtime, but they're not the only mechanism for that
18:45:43 <EvanR> Sebastian: check out #c
18:45:58 <squall> Thunks?
18:46:01 <Sebastian> arahael: Well, an assertion was made that C requires this thing called a "stack".
18:46:15 <Sebastian> EvanR: Check out my /whois.
18:46:19 <EvanR> Sebastian: no there was not
18:46:23 <arahael> Sebastian: In practice most implementations do.  C without a stack is... Quite bizarre.
18:46:57 <Sebastian> EvanR: "<heatsink> Sebastian: Those exist in strict languages too, by the way.  In strict languages, they're collectively called the stack."
18:46:57 <Cale> When I'm thinking about the evaluation of Haskell code, I tend to think in terms of graph reduction rewriting expressions to other expressions.
18:47:08 <EvanR> Sebastian: no assertion was made about C requiring something
18:47:16 <xplat> you could allocate activation records in the heap, but C permits recursion so it does need to keep them somewhere
18:47:35 <squall> Zoink leaves no thunk unevaluated, I'd that right?
18:47:52 <EvanR> squall are you a bot
18:48:31 <Sebastian> arahael: Sure. I don't think heatsink correctly understands what "the stack" is, though. There's no need for it to be used in any way related to passing arguments or evaluating expressions; registers can be used, instead.
18:48:56 <Sebastian> EvanR: C is a "strict language", right?
18:48:57 <arahael> Sebastian: Sure, if you have enough registers, and don't permit re-entrancy.
18:49:19 <Cale> squall: A thunk is the generic term for a sort of datastructure mechanism which represents unevaluated expressions at runtime. In GHC, a thunk is basically a pointer to code. The first time the code is entered, it first rewrites the pointer to point at a black hole, then evaluates the expression, and then rewrites the pointer to point at a shorter piece of code which simply returns the already computed value, before re
18:49:20 <Cale> turning that value itself.
18:49:43 <Cale> The "black hole" is simply a piece of code which throws an exception, having detected an infinite loop.
18:49:43 <tabemann> you have to save registers somewhere when calling another function, because you can't know which registers will necessarily be used by that function
18:50:14 <tabemann> you can store them in fixed locations in memory... as some early language implementations did... but that's not possible in C, as C allows reentrancy
18:50:24 <EvanR> so much C
18:50:29 <Cale> squall: An alternate representation might be a pointer to either code or data together with a boolean flag that tells you which
18:50:39 <Sebastian> tabemann: Technically, you can, because the compiler keeps track of that as things are being compiled. It knows it's own contract.
18:50:50 <tabemann> even if you store them on the heap, you will have to construct a stack of some fashion, even if it is as a linked list of objects on the heap
18:51:13 <tabemann> Sebastian: that assumes whole-program compilation, and again requires solving the halting problem
18:51:36 <arahael> Or you could require CPS programming style.  Which is... Painful... In C.
18:51:40 <Sebastian> Does ghc not compile whole programs, as gcc does?
18:52:02 <tabemann> there is no way for the compiler to necessarily know the entire possible control flow from a function in all cases
18:52:18 <tabemann> Sebastian: neither ghc nor gcc do whole-program compilation
18:52:19 <squall> And so evaluating all thinks (zoinking?) Leads to lazy evaluation?
18:52:24 <heatsink> Sebastian: 
18:52:27 <arahael> Sebastian: The problem are boundary conditions - the boundaries between the program, and any libraries it uses, the hardware, and the OS.
18:52:35 <heatsink> Sebastian: gcc can be used with ld for linking.
18:52:44 <tabemann> and mind you that if something does not work in *all* cases, it does not work
18:53:26 <Sebastian> tabemann: heatsink: arahael: There are link-time optimisations, too...
18:53:33 <tabemann> Sebastian: in gcc, no
18:53:56 <tabemann> and how can you think that all the local variables used by a program will all fit into, say, 16 GPRs (on x86-64)?
18:54:00 <arahael> And even if gcc could do that, the libraries and OS would have to have LTO on.
18:54:07 <Sebastian> Why has gcc become the representatitve of all C implementations, anyway?
18:54:16 <tabemann> Sebastian: this is true of all C compilers
18:54:18 <EvanR> Sebastian: so Haskell, I'm curious for your idea of how to compile haskell code with these "frees" ?
18:54:31 <glguy> This conversation has strayed away from the topic of Haskell discussion. You're welcome to take it somewhere like #haskell-blah
18:54:36 <Sebastian> tabemann: Can you prove that all C code is compiled?
18:55:01 <fread2281> tabemann, "there is no way for the compiler to necessarily know the entire possible control flow from a function in all cases" explanation/source?
18:55:19 <Sebastian> EvanR: Actually, I would consider using realloc. It has a more appropriate interface for this kind of functionality.
18:55:32 <tabemann> fread2281: recursion breaks the whole idea, as does separately-compiled libraries
18:55:37 <EvanR> ok so a realloc-like thing, go on
18:55:42 <jstimpfle> fread2281, higher order functions / function pointers
18:55:57 <tabemann> and yes, function pointers too break the idea
18:56:11 <Cale> squall: zoinking? Where'd you get that term? The use of thunks in the first place is part of the mechanism for lazy evaluation (as well as polymorphism)
18:56:22 <heatsink> fread2281: You can look up the paper "Undecidability of Static Analysis"
18:56:34 <fread2281> tabemann, I don't understand, can you explain more or provide an example?
18:56:44 <xplat> first you thunk it, then you zoink it, then you froob it, then you mweep it.
18:56:56 <neuroserpens> ^ what?
18:57:03 <EvanR> bop-it
18:57:11 <neuroserpens> I just come in and see that.
18:57:11 <Cale> squall: There's an operation which GHC refers to as "zonking" but it has to do with freezing the mutable references used while doing type unification at compile time.
18:57:12 <fread2281> nvm, i'll go read that
18:57:15 <tabemann> take a function that calls itself an arbitrary number of times - the compiler will need to know how many times it will call itself just to allocate registers - except it can't know this until runtime
18:58:41 <Big_G> How can I see the source code of prelude functions?
18:58:43 <heatsink> fread2281: That paper goes into detail about the problem of deciding whether two pointers point to the same address.  From that, you can easily derive that other analyses, such as precisely knowing control flow, are also undecidable.
18:59:15 <arahael> heatsink: That would be lots of fun with HIMEM apps.
18:59:23 <squall> I thought zoinking was evaluating all nested thunks or some thing like that. So I'd guess it's in that operation that gc would want to act...
18:59:34 <kyfho> why haskell over ada or go or smalltalk?
18:59:49 <Cale> squall: I've never heard anyone use that term
18:59:51 <pacak> kyfho: Haskell is nice and fluffy.
18:59:56 <xplat> Sebastian: look, i get that you don't like garbage collection.  i recommend you implement a simple haskell98 compiler that doesn't use GC, as a proof of concept, then resume the discussion when you either finish it or give up
18:59:58 <EvanR> haskell isnt dysfunctional
19:00:08 <arahael> kyfho: And it allows a sexy implementation of fib.
19:00:10 <xplat> Sebastian: either way, the discussion will be a lot more productive.
19:00:16 <Cale> kyfho: Haskell has a more usable type system than any of those
19:00:33 <kyfho> can that make better software faster?
19:00:37 <Cale> yes
19:00:41 <EvanR> yes
19:00:45 <Sebastian> xplat: For one person, that seems like a lot of work.
19:00:49 <kyfho> can entrereneurs use haskell to advantage?
19:00:55 <kyfho> to make money
19:00:58 <tabemann> faster is not the best measure of a programming language, but haskell is faster than smalltalk, e.g.
19:00:58 <Cale> It is so so convenient when you make a refactoring change to have the compiler tell you everything you need to do
19:01:02 <kyfho> can I get rich with haskell?
19:01:09 <kyfho> hm
19:01:13 <EvanR> Sebastian: a simple implementation is within the capability of a person with a weekend to kill
19:01:20 <Cale> kyfho: I think so. I'm being paid to write Haskell.
19:01:24 <tabemann> haskell solves a lot of programming problems that are basically hard for unaided humans to solve
19:01:26 <kyfho> really?
19:01:40 <tabemann> such as (obviously) memory management and aliasing
19:01:50 <Big_G> Cale, Care to say where that is?
19:01:54 <kyfho> if I get latet ghc not haskell platform will cabal have trouble adding modules?
19:02:00 <Cale> Yeah, I'm working for Obsidian systems, working on a web application for a client. We're using Haskell for both the frontend and backend of the app.
19:02:17 <Cale> We're using the Snap framework and groundhog on the backend
19:02:28 <kyfho> do you use sql database? or something like acid state?
19:02:31 <Cale> and reflex/reflex-dom for the frontend, compiled to Javascript with GHCJS
19:02:38 <xplat> Sebastian: it's just haskell98.  you could even skip parts of the h98 spec that aren't relevant to the central issues, like indent syntax, typeclasses, constructor polymorphism, parts of the prelude, and syntactic redundancies like 'where'
19:02:42 <Cale> SQL database for now
19:02:45 <tabemann> kyfho: if you get ghc without the haskell platform you will basically have to install everything separately because none of it besides the very bare core of things will be installed
19:02:58 <Big_G> Cale, Looks like you're a consultant, right? Is it just the one project using Haskell or more than that?
19:03:16 <kyfho> haskell platform seems to have older ghc, and I am on freebsd now, so not sure I can get platform
19:03:37 <xplat> kyfho: one of the important advantages of haskell over ada is lowercase letters.
19:03:39 <Cale> Big_G: All of the applications Obsidian has done have been using Haskell.
19:04:00 <Hijiri> how do I get a job doing freedomware haskell
19:04:07 <Big_G> Cale, That sounds amazing. Sadly looks like you aren't hiring 
19:04:40 <EvanR> xplat: now hold on, ada uses lowercase letters
19:04:41 <kyfho> cale how is it better than say php? with a good php framework?
19:04:54 <kyfho> gnoga is an intereesting ada thingy
19:05:09 <Cale> kyfho: I don't even know where to begin answering that. :D
19:05:39 <lambdafan> Cale, the answer is "Five Pounds of Flax"
19:05:52 <Cale> kyfho: Well, an easy place to start is that we get to share data structures and code between our frontend and backend.
19:05:56 <lambdafan> it's an old zen trick
19:06:10 <kyfho> can someone who knows only bash, a linux guy, learn to make websites with haskell?
19:06:14 <xplat> kyfho: some people use stack and stackage instead of the platform lately, it's fairly viable.
19:06:30 <lambdafan> kyfho, yes! you described me two years ago
19:06:38 <kyfho> no way really?
19:06:42 <arahael> kyfho: You can make websites with just bash, incidentially.
19:07:04 <kyfho> werc and rc are interesting www.cat-v.org
19:07:09 <xplat> arahael: heh, i used to do that when i wanted to transfer files to windows machines
19:07:12 <EvanR> Cale: how fast to redeploy or test changes to the app?
19:07:41 <kyfho> cgi becomes more viaable as the lang used becomes lighter?
19:07:47 <xplat> you just need echo, cat, and bash
19:07:48 <Cale> EvanR: Pretty quick. GHCJS isn't the fastest compiler in the world, but you only have to rebuild the frontend a lot of the time.
19:07:51 <jstimpfle> parsing HTTP requests in bash (even sh) is almost straightforward :-)
19:07:55 <kyfho> so many thing I don't know
19:08:05 <lambdafan> kyfho, do you know the domain of web programming really well? If so, I suggest Yesod as a way to dive into Haskell, after looking at LYAH. I learned using Yesod, but I didn't know web programming very well so it that much more difficult. But for someone familiar with the domain it might be the way to go
19:08:11 <kyfho> no
19:08:37 <Cale> EvanR: tbh, I wish we could cut compile times further a bit -- there's a fair amount of TH code and if something needs to compile one of those modules, it can take a while to build.
19:08:43 <kyfho> I know linux, some virtualization, web support as admin, lamp tomcat jboss weblogic, bash, unix stuff, some san, os stuff bsd
19:08:48 <xplat> jstimpfle: heh, i never bothered actually parsing the request
19:09:06 <kyfho> I can code basic html but don't know a lot of css or js 
19:09:06 <Cale> (Mostly the Aeson and Groundhog stuff)
19:09:11 <kyfho> kow some mysql
19:09:29 <kyfho> so groundhog is not a database, but a mapper or?
19:09:34 <arahael> kyfho: It's worth learning CSS.
19:09:50 <xplat> kyfho: if we get you to use haskell (any of the frameworks) instead of php today you will thank us profusely later
19:09:56 <Cale> kyfho: Yeah, it's basically a mapper -- we're using its postgresql backend
19:10:27 <xplat> css selectors are pretty easy to learn.  however, learning the attributes never ends...
19:10:30 <lambdafan> kyfho : wear the hairshort now, and you'll be happy you did later.
19:10:34 <lambdafan> hairshirt
19:11:06 <kyfho> :)
19:11:06 <Cale> kyfho: here, there's a pretty cool talk about reflex-dom... let me get you a link :)
19:11:10 * arahael used to wear his hair long.  Got rather hot during the summers.
19:11:21 <kyfho> why all this about js and dom?
19:11:31 <kyfho> makes browser in to gui clint or something?
19:11:48 <Cale> https://www.youtube.com/watch?v=dOy7zIk3IUI
19:11:52 <xplat> sadly html5 is not really made to be used without js
19:12:08 <lambdafan> there's a project called threepenny that makes the browser into a reactive gui
19:12:23 <Cale> kyfho: You get to write Haskell instead of Javascript and HTML, and yeah, there are a lot of people wanting web applications these days.
19:12:47 <kyfho> by the gods i am in boston
19:12:58 <xplat> there's lots of html5 elements that don't even do anything useful without js code ... even beyond the really obvious ones like <canvas>
19:13:13 <kyfho> I added boston haskell to my meetup a while back
19:13:20 <arahael> heatsink: The profiler output isn't terribly enlightening. :(  I've run it, and all the profiler seems to say is that Main has a 100% cost centre.
19:13:21 <xplat> boston is a good place to be if you're interested in haskell
19:13:27 <kyfho> ya?
19:13:37 <arahael> heatsink: with 100% of the time, and 100% of the allocs, in Main.
19:13:55 <kyfho> I am interested in 1 making money 2 learning to make websites on free software, and not java
19:13:55 <xplat> one of the best places in the US.  SF and NYC are probably the other 2 best.
19:14:01 <Cale> kyfho: The guy giving that talk is my current boss :)
19:14:07 <kyfho> !
19:14:23 <kyfho> I start new linux cloud job 8am tomorrow
19:15:04 <matsuura> I've been eating therapeutic mushrooms and medicinal cannabis enhanced beverage products. I'm liking Yi.
19:15:08 <kyfho> must learn my haskell
19:15:13 <lambdafan> kyfho: knowing haskell will set you apart, even if you never user it in your job. It's an indicator that you have certain traits most people don't. So go for it!
19:15:23 <kyfho> aye! I shall!!!
19:15:37 <kyfho> good night everyone, thx for links and other nice words
19:15:41 <jstimpfle> for that matter, there's also brainfuck...
19:15:53 <arahael> Which also sets you apart.
19:16:01 <lambdafan> kyfho, also thee's a mailing list, reddit and stackoverflow.
19:16:15 <kyfho> I joined a mailing list once long time ago
19:16:18 <kyfho> my inbox exploded
19:16:23 <lambdafan> you'll have support for the problems you'll get stuck on
19:16:25 <kyfho> never did again
19:16:38 <kyfho> thee's?
19:16:39 <lambdafan> haskell cafe won't blow up your mail box
19:16:44 <lambdafan> there's
19:16:47 <kyfho> theres ok
19:17:03 <Pamelloes> How do mailing lists work? They've always scared me.
19:18:42 <Cale> Pamelloes: You sign up, you get lots of emails in your inbox, you configure gmail or whatever mail client you're using to categorise it all for you, and then you proceed to ignore it forever
19:18:42 <arahael> Pamelloes: A mailing list is like a gnome.  You give your email address to the gnome, and whenever someone emails the gnome, he forwards it to every single email address he knows about.
19:19:08 <kyfho> can you just read it on google groups or somthing?
19:19:14 <Cale> kyfho: yes :)
19:19:26 <kyfho> I have a problem of shutting off job recruiters
19:19:29 <EvanR> arahael: i think you have to compile the program a certain way to get informative profiler reports
19:19:30 <kyfho> bombing me
19:19:42 <Pamelloes> Hmmmmm that sounds scary.
19:19:43 <Pamelloes> :D
19:19:48 <kyfho> ok must go bed to be chipper new employee tomorrow
19:19:59 <kyfho> thx again good people
19:20:05 <arahael> EvanR: I did. -prof -rtsopts
19:20:15 <arahael> Pamelloes: Some gnomes are scary.
19:20:20 <EvanR> theres probably a lot of flags
19:20:24 <arahael> ParahSailin: But the haskell gnome is pretty cool.
19:20:43 <Pamelloes> Alright, I'll give it a try :)
19:20:46 <Pamelloes> Where's the sign up?
19:21:08 * arahael wonders how he tab-completed to two _different_ users, accidentally.
19:21:17 <Cale> https://wiki.haskell.org/Mailing_lists#Subscription_information
19:21:27 <Pamelloes> arahael: There was a gnome messing with your autocomplete.
19:21:53 <arahael> Pamelloes: Possibly.
19:22:42 <Pamelloes> Should I sign up to Haskell or Haskell Cafe? Or both?
19:23:33 <Big_G> Cale, Do you know of any workplaces like yours?
19:24:29 <Cale> I'm not sure what many other places are like
19:25:02 <Big_G> Fair enough. Just seems like it is pretty awesome from what I can find
19:25:42 <Cale> http://www.haskellers.com/jobs has a few listings you might want to check out :)
19:26:05 <Cale> https://wiki.haskell.org/Haskell_in_industry has a list of some people using Haskell in industry
19:27:09 <Big_G> I've been to those sites but they usually are out of date or are in places I can't go. I remember seeing one in south america for a while
19:27:24 * dfeuer is still hoping to apprentice himself to Cale.
19:28:30 <fread2281> heatsink, fair enough. but manual memeory management or annotation can't do better, right?
19:32:38 <kyfho> happstack.com gets me excited
19:32:44 <kyfho> dang it time for bed!!
19:32:51 <kyfho> all exited about haskell
19:45:03 <JX7P> the red flag of functional programming: https://github.com/jarcane/red-flag-of-fp
19:49:19 <ttt_fff> should nix and cabal snadbox be used together?
19:49:26 <ttt_fff> or if i'm using nix, I should just ahve a global sandbox ?
19:51:51 <squall> Couldn't see many good jobs the listing is all full of c jobs and loss of strange other requisites
20:13:21 <dmj`> I wish maybe was defined as maybe :: Maybe a -> b -> (a -> b) -> b, so we could hang the lamdba 'maybe (Just 4) (return 0) $ \x -> do .. thing ... return (x + 1)'
20:16:05 <heatsink> arahael: GHC has some flags to control which regions of code get their own profiling counters.  I think the flag to instrument all top-level functions is -fauto.
20:17:32 <arahael> heatsink: Ah, indeed! Thanks.  (-fprof-auto)
20:18:08 <heatsink> fread2281: Manual memory management can do better than GC.  It takes a lot more programmer effort, though, which makes them hard to compare.
20:22:08 <slack1256> > id "this is a test"
20:22:10 <lambdabot>  "this is a test"
20:23:15 <fread2281> heatsink, sure, but whole-program analysis based memory management (which breaks seperate compilation and is slow) is different than GC
20:30:40 <heatsink> fread2281: Memory usage patterns can often be statically described in practice, even though it's unsolvable in general
20:31:41 <heatsink> fread2281: Think of Rust's region system, for example.  Rust uses a combination of user annotations and analysis to manage memory without GC.
20:32:43 <fread2281> heatsink, can user annotations beat inference on unsolvable examples?
20:32:44 <mietek> I’m surprised to see that with DataKinds, KindSignatures, etc, the following type synonym is accepted byGHC: "type IsTrue (a :: Ty) (tc :: Ty -> *) = tc a" — but unfortunately, the following isn’t: "type Cx (a :: Ty) = a -> *". Is there some extension which will make the latter be accepted?
20:33:41 <dmj`> mietek: {-# PolyKinds #-} might work
20:33:49 <heatsink> Clearly not, fread2281
20:34:04 <mietek> dmj`: nope
20:34:30 <dmj`> mietek: what is the error?
20:34:43 <mietek> Just a regular "parse error on input ‘*’"
20:35:43 <dmj`> mietek: what is Ty defined as ?
20:36:23 <mietek> dmj`: https://gist.github.com/mietek/00af0ffe78e041136de8
20:36:47 <mietek> So it’s not a big deal
20:36:52 <mietek> Just would be nice to have
20:37:50 <nshepperd> mietek: what is 'a -> *' supposed to mean? isn't that a kind?
20:38:24 <mietek> nshepperd: compare
20:38:26 <mietek> type IsTrue (a :: Ty) (tc :: Ty -> *) = tc a
20:38:34 <nshepperd> I didn't think we had kind synonyms
20:38:41 <blz37> This might not be exactly language question. I am interested about the commenting code that is used in Realworld Haskell online book page. I saw it a while back on github but couldn't locate it anymore. Any help is appreciated. 
20:38:55 <mietek> nshepperd: it’s the kind of tc
20:39:43 <mietek> So clearly we can state kinds at least in this fashion
20:39:57 <mietek> Just not on the RHS?
20:40:10 <nshepperd> right, but tc itself is a type, not a kind...
20:40:49 * mietek wishes we’d already have dependent Haskell
20:41:05 <nshepperd> it looks like you're doing the equivalent of 'f (a :: Foo) (b :: x -> Bar x) = b a' ==> 'f (a :: Foo) = Bar x'
20:41:37 <julianleviston> mietek: what will dependent haskell bring? (or can you point me to a resource that answers that)
20:41:39 <nshepperd> which is clearly a sort error, you can't put a type where a value should be
20:41:44 <mietek> nshepperd: o_O
20:42:13 <mietek> nshepperd: perhaps you’ll find the equivalent Idris easier to read; https://gist.github.com/mietek/1c229948ed56fa93dd7c
20:42:40 <mietek> nshepperd: or Agda; https://gist.github.com/mietek/460b65064d26bf3fb0e5
20:42:50 <wrengr> mietek: the kind of IsTrue is Ty -> (Ty -> *) -> *. whereas the kind of CX is Ty -> ** (if we assume ** is the name for the sort of kinds; which it's not)
20:43:35 <mietek> wrengr: I intended the kind of CX to be Ty -> *, but I don’t know how to express that in Haskell
20:44:13 <wrengr> mietek: try "type Cx (a :: Ty) = whatevs a" where whatevs :: Ty -> *
20:45:08 <mietek> wrengr:  parse error on input ‘where’
20:45:34 <mietek> hmm
20:45:38 <wrengr> the "where" was english, not haskell. My point is you need to pass the a::Ty to something which will return a *
20:46:03 <wrengr> but "a -> *" does not live in *
20:46:19 <mietek> wrengr: I’m... really not sure how would I go about getting a *
20:47:12 <wrengr> look again at the IsTrue version; the second argument is something that maps Ty into *, so in the body of IsTrue we use it on some particular Ty to get a particular *
20:47:45 <wrengr> in order to have Cx :: Ty -> * we need whatever's on the rhs to be some *
20:47:45 <mietek> Yes, that’s what I wrote.
20:48:34 <nshepperd> mietek: are you really trying to write a kind synonym?
20:49:05 <wrengr> For example, we could have "data Boring :: Ty -> * where Dull :: Boring a" and then we could define "type Cx (a :: Ty) = Boring a"
20:49:24 <nshepperd> I think we don't have those
20:50:36 <wrengr> or "data LessBoring :: Ty -> Ty -> * where StillDull :: LessBoring a b" and "type Cx (a :: Ty) = LessBoring a a"
20:51:00 <waressearcher2> is anyone here ?
20:51:18 <wrengr> or even just "type Cx (a :: Ty) = Int" or whatever; no need to actually use the "a"
20:51:21 <mietek> wrengr: well, that’s interesting, but attempting the use so-defined Cx results in
20:51:30 <mietek> ‘Cx’ of kind ‘Ty -> *’ is not promotable
20:51:39 <mietek> But at least it has the right kind!
20:52:02 <wrengr> oh right, GADTs aren't promotable. Try writing the same thing but without the GADT syntax
20:52:14 <waressearcher2> this is weird, I can curtainly say that some time ago when I joined "haskel" it was a separate channel but now it redirects here ? when did it changed ? less than year ago ? more ?
20:52:36 <wrengr> e.g., "data LessBoring (a :: Ty) (b :: Ty) = StillDull a b"
20:52:42 <nshepperd> mietek: 'type Cx = Ty -> * ; type IsTrue (a :: Ty) (tc :: Cx) = tc a' seems like it would do what you want? but the 'type Cx = Ty -> *' is not legal syntax since * is not a type
20:53:00 <mietek> nshepperd: it would
20:53:53 <mietek> wrengr: "data Boring (a :: Ty) = Dull a" — Expected a type, but ‘a’ has kind ‘Ty’
20:54:40 <wrengr> oh, duh; because Ty /= * and we can only have * for the arguments to data constructors
20:54:45 <wrengr> silly me. 
20:55:51 <waressearcher2> is tha channel bout nime ?
20:56:05 <julianleviston> waressearcher2: this is a channel about the haskell programming language
20:56:06 <wrengr> could always try "data VeryBoring (a :: Ty) = VeryDull"
20:56:23 <wrengr> mietek: though I'm afraid this is getting ever further from your goal
20:56:48 <mietek> wrengr: unfortunately that is still not promotable
20:58:27 <wrengr> You can't say "type Cx (a :: Ty) = VeryBoring a" ? it works for me (on ghc 7.10.1)
20:58:57 <mietek> I can say that, but I can’t *use* the defined type where I’m currently using Tm -> *
20:58:58 <wrengr> n.b., we're not promotong "VeryBoring"; it's already a type
20:59:29 <wrengr> mietek: the problem is that kinds are not types in Haskell
20:59:34 <mietek> (The promotable error message is shown at the use site)
20:59:37 <mietek> Yes, I know.
21:00:03 <mietek> It seems like kind synonyms wouldn’t require an extension of what’s already implemented, though
21:00:09 <wrengr> there's no way to abstract over kinds and give them names, because there's nothing above the kind level in order to make it sound
21:00:49 <mietek> Somebody cares about Haskell’s type system being sound?
21:01:00 <mietek> With bottom all over the place?
21:01:27 <mietek> Anyway, thanks for trying. :)
21:01:27 <wrengr> Bottom doesn't violate type safety...
21:02:16 <nitrix> What do you mean? You could implement bottom yourself anyway.
21:02:28 <lpaste> nshepperd pasted “data Cx” at http://lpaste.net/142329
21:03:40 <mietek> nshepperd: well, that says something a little bit different, no?
21:03:41 <nshepperd> mietek: so it is sort of possible to make Cx an ADT and manually add and remove the type-level constructors
21:04:12 <wrengr> mietek: I'm talking about the soundness of the type system itself (as a mechanism of excluding ill-behaving terms), not the logical-soundness of the interpretation of that type system as a logic
21:04:26 <mietek> wrengr: fair enough.
21:04:37 <nshepperd> mietek: does it? I think it's the same thing
21:05:27 <nshepperd> we define an isomorphism between (Ty -> *) and (Cx *), which sort of lets us use Cx * as a synonym for that
21:05:42 <nshepperd> except that all the manual constructor moving makes it a bit pointless ^_^
21:06:32 <mietek> nshepperd: MCx seems... value-y
21:09:44 <nshepperd> when promoted, it's a type constructor
21:10:26 <mietek> Oh huh.
21:10:44 <mietek> Well, thanks for trying as well, but this is horrible. ;)
21:11:00 <nshepperd> yup
21:11:29 <nshepperd> it's actually more verbose than just pasting Ty -> *
21:11:30 <mietek> Also I happened to dig up https://www.reddit.com/r/haskell/comments/qadwm/improbable_uses_of_unsafecoerce/
21:11:37 <mietek> Fun.
21:15:39 <wrengr> that's... gloriously horrifying
21:29:18 <wrengr> g'night all
21:31:24 <tommd> g'night
21:31:48 <waressearcher2> in what task haskell is irreplaceable language ?
21:32:21 <tommd> That question implies there exists a language that is irreplaceable for some task.  I don't think that is true.
21:32:44 <waressearcher2> tommd: but haskell was created for a reason right ?
21:33:15 <tommd> To do some particular thing that we could never have ever done without haskell?  No.
21:33:17 <julianleviston> waressearcher2: rephase your question, perhaps.
21:33:29 <julianleviston> waressearcher2: rephrase*
21:34:28 <julianleviston> waressearcher2: Haskell is quite good at letting you do equational reasoning, like you can in math.
21:37:22 <julianleviston> waressearcher2: along with a bunch of other qualities of the language, it makes it a very nice language to build programs in. You can reuse code, and also it helps you to write programs that are less junky than many “common” languages in use these days by forcing you to match the types of your expressions and values together before it will allow your program to run at all.
21:37:33 <dmj`> waressearcher2: 'use the right tool for the job' doesn't apply as well to haskell since it's a general purpose programming language, so it can do a lot. Industry uses it for all kinds of things. It's really good at writing parsers for languages, web programming, the list goes on
21:43:08 <julianleviston> waressearcher2: have you done any programming before?
21:45:10 <waressearcher2> julianleviston: some stuff in C
21:45:13 <waressearcher2> a little
21:45:28 <julianleviston> waressearcher2:  ah ok. :)
21:48:27 <julianleviston> waressearcher2: maybe one of the nicest things, coming from C, is that you spend less time worrying about what types of things the computer works in (like whether you’re using a string pointer pointer, or if you’ve malloc’d the right amount of space for your array of arrays), or how to loop over a data structure, and spend more time thinking about what your program is trying to mean… or more time thinking about t
21:48:27 <julianleviston> types of things you’re thinking about, rather than how to fit that into the computer. I mean, it’s a little of both, but Haskell gets out of the way of what you’re trying to do more than C>
21:49:22 <julianleviston> waressearcher2: for example, earlier today, a friend was wondering if “mutalisk” was an anagram of “multitask”… and it took me a few seconds to work out with Haskell. Contrast that to how long it would take to write that program in C… 
21:49:51 <julianleviston> waressearcher2:  in haskell it was this simple : sort “mutalisk” == sort “multitask”
21:50:26 <waressearcher2> julianleviston: I can see it without writing programm, they have different amount of characters
21:50:32 <julianleviston> waressearcher2: yep :)
21:50:51 <thimoteus> mietek: that definition of undefined had me laughing
21:51:00 <julianleviston> waressearcher2: but he then also wanted to know which characters were different
21:53:37 <waressearcher2> I was thinking why haskell is in that list https://www.linkedin.com/pulse/20140910083024-22490386-programming-languages-to-know, its like Bjarne Stroustup, Larry Wall and Erik Raymond were suggesting all of these languages "C++, Java, Python, Ruby, JavaScript, Haskell, C, Perl", I mean if someone knows say "Python, Ruby, Perl" does he really need 
21:53:42 <waressearcher2>  to leard also a haskell ?
21:55:03 <tommd> waressearcher2: I think of it the other way around.  If someone knows C++, Java, Python then Haskell gives them a vastly different view, vs C or Perl which is (to a significant degree) more of the same.
21:55:06 <julianleviston> waressearcher2: well… once you’ve written some programs, you start to realise you’re doing the same things over and over. Haskell lets you minimize that. It also lets you write bigger programs.
21:56:15 <waressearcher2> allright
21:56:51 <julianleviston> waressearcher2: haskell’s type system is the equivalent of having someone automatically write unit tests for you around simple errors all the time. It’s also quite performant… it’s also kind of like having Java’s type system (which checks your types) without all the absolute pain of writing typesafe code (like massive numbers of casts, etc.)… because of type inference.
21:57:27 <athan> bitemyapp: ping - BBP?
21:57:56 <tommd> waressearcher2: Even at a fairly high level we can enumerate significant differences between, say, C++ and Haskell.  Manual memory management / garbage collected, eager/lazy, impure/pure, OO/FP, "typed"/typed...
21:58:09 <zomg> the unit test comments is true - I work with javascript in my job and you need to write tests in order to feel any kind of confidence when you change the code, with haskell the type system gives you a lot of that
22:00:25 <athan> Why unit test when you have...
22:00:27 <julianleviston> waressearcher2: type inference lets me write code, and have haskell create all the type signatures for me automatically, and check that my code has no obvious syntax errors in it
22:00:30 * athan dives into rabbit hole
22:00:47 <julianleviston> athan: lol no no no :) not “don’t unit test” just “you don’t have to write as many unit tests” lol
22:01:17 <athan> or we could just... coq :|
22:01:25 <tommd> I think he was going to say... damn, he beat me to it.
22:01:25 * athan coughs something bad
22:02:05 <julianleviston> athan: like… proofs instead? :)
22:02:08 <athan> I still need to try JonPRL >.>
22:02:16 <athan> julianleviston: :) you bet
22:02:37 <athan> theorems, automated theorem proving and proof derivation tools, all the goodies
22:02:38 <julianleviston> athan: for some definition of “proof” :)
22:03:01 <athan> ah jeez
22:03:09 <julianleviston> waressearcher2:  here’s a simple example:
22:03:17 <julianleviston> > let x = 5 in ex + 5
22:03:19 <lambdabot>      Not in scope: ‘ex’
22:03:20 <lambdabot>      Perhaps you meant one of these:
22:03:20 <lambdabot>        ‘x’ (line 1), ‘hex’ (imported from Numeric.Lens),
22:03:42 <julianleviston> waressearcher2:  see what happened there? I wrote ex instead of x, and haskell told me what I did wrong.
22:03:43 <athan> @check \x -> x + 1 - 1 == x
22:03:44 <lambdabot>  +++ OK, passed 100 tests.
22:03:52 <julianleviston> hehe :)
22:04:02 <athan> let the games begin
22:04:44 <julianleviston> waressearcher2: that’s the other thing. There’s this thing called “quickcheck” - you describe your code to the test suite and it’ll go off and test the shape of your code (called the invariants) to see if it’s good. Basically write tests for you.
22:04:53 <julianleviston> waressearcher2:  that war waht athan you showed.
22:05:25 <athan> WAY better than unit tests. You can see it generated 100 of them
22:05:47 <athan> @check
22:05:47 <lambdabot>  <unknown>.hs: 1: 1:Parse error: EOF
22:05:48 <athan> erm
22:05:50 <athan> :D
22:05:59 <athan> @check \x -> reverse (reverse x) == x
22:06:01 <lambdabot>  +++ OK, passed 100 tests.
22:06:03 <julianleviston> waressearcher2:  and these are only the simplest things. When it comes to building complex programs, Haskell is amazing.
22:06:11 <arkeet> @check \x -> reverse x == x
22:06:12 <lambdabot>  +++ OK, passed 100 tests.
22:06:41 <athan> :D see it works!
22:06:53 <athan> arkeet: wtf is going on here :| I think they're on to us
22:06:59 <arkeet> @check \x -> reverse x == (x :: [Int])
22:07:01 <lambdabot>  *** Failed! Falsifiable (after 3 tests and 1 shrink):
22:07:01 <lambdabot>  [2,1]
22:07:08 <arkeet> it defaults to [()]
22:07:08 <athan> did it assume unit?
22:07:10 <athan> ahhh
22:07:26 <waressearcher2> julianleviston: one can say haskell is mainly for those how good at math right ?
22:07:32 <arkeet> no.
22:07:49 <athan> waressearcher2: Haskell is based off abstract algebra and category theory as a means to design and organize your code
22:08:04 <athan> but honestly it's as simple as "put the triangle block in the triangle hole"
22:08:07 <arkeet> you can say that, but you don't need to know it to use it.
22:08:14 <arkeet> to use haskell, I mean.
22:08:55 <athan> waressearcher2: For instance, I have no college background, but after 2 years of _using_ haskell for my own purposes, I can now keep-up with smart people math stuff
22:09:35 <nitrix> Hi guys, I have a IO function that process its argument into many Maybe values. All these values need to be `Just` values for processing to continue, so I figured I'd use the Maybe monad into this IO context...
22:09:40 <dmj`> waressearcher2: you'll have more fun w/ haskell, once you get OOP it all looks the same, and can't be reasoned about, refactored sanely.
22:09:45 <nitrix> The problem is that now I have this whole to fill: Maybe (IO ()) -> IO ()
22:09:47 <nitrix> hole*
22:10:08 <nitrix> How would I fill that hole and is this a use case for MaybeT ?
22:10:13 <athan> niteria: Have you heard of traverse?
22:10:25 <julianleviston> nitrix: he meant you
22:10:26 <athan> Maybe itself is a monad
22:10:37 <nitrix> I'm using it as a monad.
22:10:44 <athan> ah crud sorry
22:10:55 <nitrix> Maybe a snippet of code?
22:10:59 <athan> Oh! So you have a maybe of IO?
22:11:21 <athan> Or do you have `IO [Maybe a]`, where they all need to be Just?
22:11:23 <julianleviston> nit why can’t you just conditionally unwrap and “action” each?
22:12:14 <athan> check it -
22:12:27 <athan> > sequence [Just 1, Just 2, Just 3]
22:12:29 <lambdabot>  Just [1,2,3]
22:12:30 <julianleviston> :t sequence_
22:12:31 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
22:12:46 <davidar> :t maybe (return ()) id
22:12:47 <lambdabot> Monad m => Maybe (m ()) -> m ()
22:12:57 <julianleviston> beautiful.
22:13:13 <athan> davidar: That's what `fromMaybe` is for :)
22:13:33 <julianleviston> :t fromMaybe
22:13:34 <lambdabot> a -> Maybe a -> a
22:13:35 <athan> :t fromMaybe (maybe Nothing id)
22:13:36 <lambdabot> Maybe (Maybe (Maybe a) -> Maybe a) -> Maybe (Maybe a) -> Maybe a
22:13:38 <athan> lol
22:13:51 <julianleviston> that’s a lotta maybe! lol
22:13:59 <athan> ...maybe :|
22:14:08 <nitrix> http://lpaste.net/142331
22:14:41 <julianleviston> nitrix: ooh the concurrency book?
22:14:47 <julianleviston> uh no.
22:14:52 <dmj`> :t \action xs -> mapM_ action =<< catMaybes <$> (return xs :: IO [Maybe Int])
22:14:53 <lambdabot> (Int -> IO b) -> [Maybe Int] -> IO ()
22:14:57 <athan> @tell edwardk Is there a name for the `a -> (b -> r) -> r` profunctor?
22:14:57 <lambdabot> Consider it noted.
22:15:23 <nitrix> onMessage is the former function, onMessage' is where I'm headed towards, trying to get rid of the Maybe/fromJust by a cleaner approach, ideally Maybe monad.
22:15:46 <arkeet> dmj`: you're making too much work for yourself.
22:15:47 <dmj`> nitrix: catMaybes
22:15:48 <arkeet> :t traverse_ . traverse_
22:15:50 <lambdabot> (Applicative f, Foldable t, Foldable t1) => (a -> f b) -> t (t1 a) -> f ()
22:16:18 <dmj`> arkeet: ooo :) nice
22:16:50 <nitrix> dmj`: I'm not interested in filtering them. I want to shortcircuit like the Maybe monad does upon a Nothing value.
22:17:03 <athan> anyone here know that profunctor? `a -> (b -> r) -> r`?
22:17:05 <nitrix> dmj`: I feel like you didn't read any of what I wrote. I don't mind re-explaining.
22:17:49 <athan> nitrix: Well, MaybeT is nice for accessing the underlying monad stack while working in a Maybe-like monad
22:18:00 <athan> errors also give you `hoistMaybe`, which is also useful
22:19:42 <nitrix> Right now with the onMessage' version, I have a hole of type `Maybe (IO ()) -> IO ()` to fill. Is this a use case for MaybeT ?
22:20:36 <athan> nope :\
22:20:45 <athan> you've got to handle the Nothing case somehow
22:21:00 <athan> (is IO an Alternative?)
22:21:16 <nitrix> The Nothing case would be as simple as `return ()`
22:21:17 <dmj`> athan: nah
22:21:49 <dibblego> the hint for MaybeT is: case Nothing -> return Nothing
22:21:53 <nitrix> Giving an `IO ()`. The problem I see is runMaybeT returns a `m (Maybe a)` :/
22:22:28 <athan> nitrix: That may be the only way then
22:22:55 <dmj`> athan: not w/o catching / throwing exceptions :/
22:23:06 <nitrix> Maybe (m a) -> m a
22:23:33 <athan> good point dmj`, verbose errors ftw
22:23:34 <nitrix> There has to be a clean way to do this without using the `maybe` function -.-
22:23:50 <EvanR> whats wrong with MaybeT?
22:23:58 <athan> ayooo fromMaybe
22:24:56 <athan> @src fromMaybe
22:24:56 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
22:24:59 <nitrix> http://lpaste.net/142331
22:25:00 <athan> @src maybe
22:25:01 <lambdabot> maybe n _ Nothing  = n
22:25:01 <lambdabot> maybe _ f (Just x) = f x
22:25:04 <athan> darn
22:25:32 <dmj`> nitrix: you have a [ IO ( Maybe a ) ] and you want to short circuit on the first maybe?
22:25:44 <athan> I thought it would be something like `maybe nil f mx = f (fromMaybe nil mx)`
22:25:44 <dmj`> or IO [Maybe a]
22:25:45 <nitrix> dmj`: I don't have a [].
22:26:07 <EvanR> theres also ExceptT
22:26:14 <nitrix> dmj`: There is no list. You're confused.
22:26:27 <nitrix> dmj`: http://lpaste.net/142331
22:26:50 <athan> nitrix: naw you got it
22:26:52 <dmj`> :t Data.Foldable.forM_ (Just 4) print
22:26:54 <lambdabot> IO ()
22:27:03 <athan> the feature of Maybe is that Nothing exists
22:27:09 <dmj`> nitrix: returns unit in case of Nothing
22:27:11 <athan> and needs to be accounted for :)
22:27:20 <nitrix> maybe (return ()) id $ do ...
22:27:26 <nitrix> Seems completely silly to me.
22:28:00 <dmj`> :t for (Just 4) print
22:28:01 <lambdabot> IO (Maybe ())
22:28:18 <dmj`> nitrix: forM_ from Foldable seems like what you want
22:28:51 <EvanR> you can also do shortcircuiting with ContT ;)
22:28:54 <nitrix> :t forM_
22:28:55 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
22:29:01 <EvanR> if you feel lucky
22:31:11 <EvanR> for max readability maybe you just want to pattern match
22:32:20 <athan> EvanR: ContinueT...?  *insert token*
22:32:46 <athan> I wonder if ContT might have use in parsing actually
22:32:53 <julianleviston> Guh… 30 minutes to realise I’d type “data” instead of “type”.
22:33:11 <julianleviston> typed*
22:33:32 <athan> julianleviston: That's not so bad. I was crying over LANGAUGE earlier T_T
22:33:40 <julianleviston> athan: OMFG
22:33:52 <EvanR> Cont is the functional version of "goto" so you can easily make code incomprehensible
22:34:24 <athan> EvanR: Hmm, which makes sense why it's not a MonadFix?
22:35:50 <nitrix> Well, now it looks like this:
22:35:54 <nitrix> flip forM_ id $ do ...
22:36:30 <athan> :t forM_
22:36:31 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
22:36:33 <bitemyapp> athan: burning bridges proposal
22:36:37 <bitemyapp> athan: toList isn't in prelude.
22:36:38 <athan> :t mapM_
22:36:39 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
22:36:46 <bitemyapp> athan: I want to know why and the answer is probably somewhere in those threads.
22:36:58 <athan> bitemyapp: wtf why is it not? It's in Data.Foldable
22:37:08 <nitrix> I see. Well, I guess I have a `mapM_ id $ do ...` then.
22:37:08 <athan> hopefully we can sneak in Semigroup => Monoid too
22:37:42 <athan> oh okay
22:37:57 <athan> s/we/they ._.
22:38:01 <EvanR> mapM_ id reminds me of clojure
22:38:12 <Kaede_> what r u guy ds;ioigibg'
22:38:13 <EvanR> evaluate this list because i want the side effects dammit
22:38:35 <EvanR> or i want the errors to happen now instead of later
22:39:11 <nitrix> mapM_ id seems clunky to me. Surely I can combine this Maybe monad with my IO monad.
22:39:12 <nshepperd> it's probably because toList wasn't in the prelude before the BBP
22:39:26 <nshepperd> and adding it would have broken things
22:39:57 <dibblego> sequence_ = mapM_ id 
22:40:07 <EvanR> ah right
22:40:21 <athan> night yall :)
22:40:34 <nitrix> There we go. That seems much much better :D
22:40:48 <nitrix> sequence_ :: (Monad m, Foldable t) => t (m a) -> m ()
22:43:43 <nitrix> http://lpaste.net/142333
22:45:50 <nitrix> This just seems so much nicer. Get a bunch of things, nick, chan, origin from parsing the message we received, then I can use some fancy calls on those without having nested `maybe` or `case of` :)
22:46:34 <nitrix> Plus, it gets rid of the partial `fromJust`s earlier that were bogus.
22:46:36 <julianleviston> nitrix: pretty.
22:47:37 <nitrix> julianleviston: I don't really show here and the names are confusing, but for other parts of the code, it'd make things a lot more readable.
22:47:46 <nitrix> It doesn't really show*
22:48:43 <julianleviston> nitrix: it looks much nicer to me. The ramification of putting things in nice places is often that the “onflowing effects” are nicer, too, aren’t they :)
22:49:04 <Phyx-> Hi, anyonw know why I'm getting "unexpected stanza" on this cabal file? http://lpaste.net/4139617963831459840
22:49:07 <julianleviston> whatever nice means
22:49:45 <julianleviston> Phyx-: wow you can write if else in cabal files??
22:50:31 <Phyx-> julianleviston: yeah, I've seen it before and the documentation mentions it https://www.haskell.org/cabal/users-guide/developing-packages.html
22:50:32 <julianleviston> Phyx-: cool! :) (just looked it up)
22:51:03 <Phyx-> it seems to work but the warning is screwing up a test
22:51:21 <nitrix> julianleviston: Well, it lets me transform this disgusting thing:   when (isJust maybeNick && isJust maybeChan) $ ctxRemChannelNames ctx (fromJust maybeChan) [(fromJust maybeNick)]
22:51:21 <dibblego> any = Maybe False
22:51:47 <nitrix> julianleviston: Some of them have 5 to 8 Maybe values.
22:52:35 <julianleviston> Phyx-: can you isolate? as n… remove if then test consequent, then test alternative?
22:54:45 <EvanR> @src any
22:54:45 <lambdabot> any p = or . map p
22:54:55 <Phyx-> julianleviston: without the if it works, but then only on one platform.
22:55:05 <julianleviston> Phyx-: not the windows one?
22:55:20 <Phyx-> with the if it also seems to work.. just an annoying warning shown
22:56:42 <julianleviston> Phyx-: where does the “-6” part come from? isn’t that actually in the name of the DLL?
22:57:15 <Phyx-> julianleviston: yes it is
22:58:03 <Phyx-> i want cabal to pass on -lstdc++-6 to ghc on windows
23:02:37 <julianleviston> Phyx-: I wonder if this issue might help you: http://stackoverflow.com/questions/6404636/libstdc-6-dll-not-found
23:03:23 <julianleviston> Phyx-: tho if it works with stdc++-6, then probably not.
23:03:43 <julianleviston> Phyx-: sorry I couldn’t be more help.
23:04:07 <Phyx-> julianleviston: that's ok, appreciate the help :)
23:04:36 <Phyx-> I don't have a problem with actually finding the library. cabal is just giving an annoying warning that i don't get..
23:04:42 <Phyx-> what's a "stanza" anyway
23:05:39 <julianleviston> Phyx-: haha it’s a poetry / prose term, I think… means like a section of text.
23:06:08 <Phyx-> julianleviston: ah ok, hehhe
23:07:07 <julianleviston> Phyx-: bit of an arcarnely bizarre usage there! :) but maybe they’re just waxing lyrical :) I guess because the cabal has Stanzas (in real life)
23:07:36 <julianleviston> (kabalah sorry
23:08:12 <julianleviston> guh assuming I could get *any* of my jewish text references correct.
23:09:16 <Phyx-> lol, never good when the warning is obscure :P
23:19:57 <julianleviston> Hm… interesting. (:) is actually a reservedop… and so is .. obviously. and yet, we can ask for the type of (:) whereas we can’t ask for the type of (..). Is that because (:) is actually defined in the prelude to overwrite the reservedop, or something?
23:20:12 <julianleviston> (… and so is (..), obviously.)
23:20:58 <julianleviston> or mabye it’s because of this: An operator symbol starting with a colon is a constructor.
23:22:40 <liste> @src []
23:22:40 <lambdabot> data [] a = [] | a : [a]
23:22:56 <julianleviston> @src (:)
23:22:56 <lambdabot> Source not found. Maybe you made a typo?
23:23:07 <julianleviston> maybe I did, lambdabot, maybi I did.
23:23:24 <liste> : is defined in the @src [] line
23:25:44 <Phyx-> arg. that explains it.. this isn't cabal but ghc-pkg
23:25:56 <Phyx-> i'll just solve this in the makefile then
23:27:23 <liste> (..) isn't an operator, it's just syntactic sugar in [a..] [a..b], [a,b..], [a,b..c]
23:28:38 <julianleviston> liste: it’s listed under 2.4 Identifiers and Operators of the haskell report - so I guess it must just be an identifier? its marker is “reservedop”
23:29:03 <julianleviston> liste: reservedop →	.. | : | :: | = | \ | | | <- | -> | @ | ~ | =>
23:29:21 <julianleviston> I guess that’s just their name in the grammar, tho.
23:29:58 <Walther> Huh, how does it parse the pipe as a reserved character from that list o.O
23:30:02 <julianleviston> liste:  and this explains it a bit more, too: Notice that a colon by itself, “:”, is reserved solely for use as the Haskell list constructor; this makes its treatment uniform with other parts of list syntax, such as “[]” and “[a,b]”.
23:30:18 <arkeet> Walther: it's not a machine-read specification
23:30:21 <arkeet> just documentation
23:30:28 <Walther> right
23:31:10 <julianleviston> but I imagine you could easily do it by saying “pipe whitespace* token whitespace* pipe” in the grammar, assuming whitespace+ is optional whitespace, and token can be pipe, no?
23:31:48 <nitrix> Can someone explain why is (forall a. a -> a) -> (forall b. b -> b) a rank-2 type? 
23:31:50 <nitrix> I can see the two levels of universal quantification, but no matter what I read on the subject, I don't understand how can this be identified or verified.
23:34:29 <tommd> nitrix: I don't understand the question.  If you can see the levels of quantification can you not understand how it is identified?
23:35:26 <EvanR> because theres a forall on the left hand side of a ->
23:36:00 <nitrix> Why can't it be written sort of like How is that any different from (forall a b. (a -> a) -> (b -> b))
23:36:32 <nitrix> Whoops, don't mind the accidental stray paste.
23:38:09 <nitrix> I read this page on the wiki [1] but their example basically boils down to "can or cannot be moved to the left". Not exactly clear if you know nothing about Rank-N types (or forall for that matter).
23:38:13 <EvanR> in the second one, the called chooses the a and b
23:38:13 <Hijiri> nitrix: with forall a b. (a -> a) -> (b -> b) you could pass in (Int -> Int) for example
23:38:55 <nitrix> Hijiri: That seems wrong to me. The kinds wouldn't match.
23:39:05 <tommd> The second example is more of an existential than universal quantification (from the right point of view).
23:39:15 <nitrix> Hijiri: Int cannot match (a -> a), can't it?
23:39:24 <lamefun> Is there a ListSet type that is both a list and a set (a list that can not contain duplicate elements)?
23:39:25 <EvanR> a = Int
23:39:27 <Hijiri> I said you could pass in (Int -> Int)
23:39:29 <Hijiri> not Int
23:39:36 <EvanR> lamefun: known as a Bag
23:39:39 <tommd> Pass in, as in (b -> b) is the return value.
23:40:14 <tommd> lamefun: How about `Map k Integer`?
23:40:32 <EvanR> nitrix: when the forall is embedded inside the -> on the left, the callee is picking the type and you cant know what it is
23:40:34 <lamefun> tommd, ?
23:40:39 <nitrix> Hijiri: Sorry, I read that wrong. So you pass (Int -> Int), and what is wrong with that?
23:40:58 <Hijiri> with  (forall a. a -> a) -> (forall b. b -> b), your function has to work with any type
23:41:00 <lamefun> tommd, what if two keys have the same Integer value?
23:41:05 <Hijiri> not just Int
23:41:15 <Hijiri> cause your function has to work for all a
23:41:21 <Hijiri> I mean the function you pass in
23:41:50 <nitrix> forall a b. (a -> a) -> (b -> b), aren't a and b entirely independant from each others?
23:42:05 <tommd> lamefun: I think I missed your meaning.  If you have a order and a uniqueness requirement you can keep a map (thus, uniqueness) and an integer (index).
23:42:15 <Hijiri> nitrix: what do you mean
23:42:28 <tommd> lamefun: But you can enumerate your desired operations and come up with a more fitting structure.
23:42:36 <lamefun> I want a list with no duplicate elements.
23:42:51 <tommd> lamefun: Either way, chances are high that uniqueness will be guarenteed by construction and not as a property of the data type.
23:43:21 <lamefun> eg. ["a", "b", "c"], but not ["a", "a", "b", "c"]
23:43:23 <tommd> lamefun: So what is wrong with a list is the natural question.  Do you want a correct by construction certainty that there are no duplicates?
23:43:29 <nitrix> Hijiri: It's not (a -> a) -> (a -> a), so what matter is it if the foralls are individual to each or on a larger scope? a and b are different either ways...
23:43:40 <nitrix> Hijiri: Maybe I just don't graps the notation but that just seems weird to me.
23:43:47 <Hijiri> because with the second signature the caller gets to choose what a is
23:43:58 <Hijiri> with the first signature the callee gets to choose
23:43:59 <ReinH> nitrix: no one is suggesting that a and b aren't different type variables
23:43:59 <tommd> lamefun: Smart constructors are so commonly used for a reason.  They help here to a great extent.
23:44:33 <Hijiri> @let bob _ = id :: (a -> a) -> (b -> b)
23:44:34 <lambdabot>  .L.hs:159:9:
23:44:34 <lambdabot>      Couldn't match type ‘a1’ with ‘b1’
23:44:34 <lambdabot>        ‘a1’ is a rigid type variable bound by
23:44:45 <ReinH> A rank-1 polymorphic type can be instantiated by the caller at any type
23:44:47 <tommd> 2 year old fit.  Good night!
23:44:51 <Hijiri> uh
23:44:56 <ReinH> e.g., id 1 :: Int
23:45:09 <Hijiri> @let bob :: (a -> a) -> (b -> b); bob _ = id
23:45:10 <lambdabot>  Defined.
23:45:37 <Hijiri> @let john :: (forall a. a -> a) -> (forall b. b -> b); john _ = id
23:45:38 <lambdabot>  Defined.
23:45:46 <Hijiri> > bob (+5) "abc"
23:45:47 <lambdabot>  "abc"
23:45:54 <Hijiri> > john (+5) "abc"
23:45:55 <lambdabot>      No instance for (Num a) arising from a use of ‘+’
23:45:56 <lambdabot>      Possible fix:
23:45:56 <lambdabot>        add (Num a) to the context of
23:46:03 <ReinH> A rank-2 polymorphic type must be used polymorphically by the caller
23:47:22 <nitrix> ReinH: That's very informative. But what about the notation? 
23:48:10 <nitrix> I'm not the kind that remember things by heart, I have to understand it and so far, there's no material that explains forall or rank-n properly.
23:48:49 <ReinH> nitrix: https://en.wikibooks.org/wiki/Haskell/Polymorphism#Higher_rank_types https://wiki.haskell.org/Rank-N_types http://stackoverflow.com/questions/12031878/what-is-the-purpose-of-rank2types https://ocharles.org.uk/blog/guest-posts/2014-12-18-rank-n-types.html
23:49:27 <nitrix> I visited the first 3. Maybe that blog, reading.
23:52:12 <EvanR> so in john, the callee isnt getting to choose either
23:52:17 <ReinH> I mean, I just picked some things from the first page of the google results for "haskell rank-n types", so there's hardly "no material".
23:52:53 <julianleviston> ReinH: to me, he seemed to mean that so far no material had worked for him.
23:53:20 <julianleviston> the subjective word “properly” indicates that.
23:53:47 <ReinH> I think the explanation from ocharles__'s blog is pretty good
23:54:17 <ReinH> Specific questions about things that they don't understand would be better than a claim that there isn't any information.
23:54:19 <neuroserpens> poweroff
23:54:28 <julianleviston> nitrix: do you know about isomorphic types?
23:54:40 <neuroserpens> lol wtf
23:54:52 <ReinH> If those resources aren't "proper", what is improper about them?
23:55:39 <julianleviston> ReinH: he means he hasn’t managed to understand higher rank types yet, and he’s using language to voice his emotional reaction, it seems. It’s not a semantic message, it’s an emotional one.
23:56:18 <ReinH> Right, and I'm asking for specific questions that can be answered.
23:56:30 <julianleviston> ReinH: you could rephrase it as “does anyone know of any documents that make it easier to understand higher ranked types that may be of help to someone who is struggling to understand the concepts?”
23:56:48 <julianleviston> ReinH: yeah.
23:57:00 <ReinH> Sure, but I just gave 4 of them.
23:57:22 <julianleviston> ReinH: you did :)
23:57:25 <ReinH> So at this point, to get beyond "well try reading this one", we need specifgics.
23:58:23 <ReinH> It's totally reasonable to not understand rank-n types. I just need more information so I can help.
23:59:33 <ReinH> If the resources they've tried didn't work, where specifically did they lose the thread? And such.
