00:00:23 <jle`> just a toy concept :)
00:01:49 * hackagebot pathwalk 0.1.1.0 - Path walking utilities for Haskell programs  https://hackage.haskell.org/package/pathwalk-0.1.1.0 (Xena)
00:01:55 <lpaste> kallisti pasted “cabal configure problem” at http://lpaste.net/143108
00:02:22 <kallisti> So, if the build-depend for the test suite isn't a build-depend on the library, cabal just decides that it doesn't exist and doesn't try to install it?
00:03:25 <MarcelineVQ> Hmm, the nicta course cabal project has a test suite with its own unqiue depends and seems to install them fine, not sure what's up
00:04:14 <MarcelineVQ> Though maybe it's possible that depends for project packages manage to fulfill them too
00:04:42 <MarcelineVQ> idk, I tried making one with `primes` as a dependancy and had the same issue you're having kallisti 
00:05:23 <kallisti> yeah, I'm not making warp a dependency of my library just so I can have a test-suite in cabal. :P
00:05:34 <kallisti> could use build flags but that's pretty ugly.
00:06:27 <elliptic00> try to use fromInt(int) to convert Int to Float, and get error: Not in scope 'fromInt'
00:07:03 <kallisti> :t fromIntegral
00:07:04 <lambdabot> (Integral a, Num b) => a -> b
00:07:08 <jle`> elliptic00: where are you getting "fromInt" from?  i don't think that it's in any library i know
00:07:10 <kallisti> is what you want I believe
00:08:13 <kallisti> > fromIntegral ( 5 :: Int ) :: Float
00:08:15 <lambdabot>  5.0
00:08:15 <elliptic00> this is my question, what package I should import in order to use 'fromInt'
00:08:24 <kallisti> there is no fromInt function in any standard library.
00:08:29 <jle`> i don't think fromInt is in any package
00:08:33 <kallisti> you just want to use fromIntegral which is in Prelude
00:08:36 <jle`> written anywhere
00:08:49 <jle`> oh, it's in criteron
00:08:56 <jle`> but yeah, you probably want `fromIntegral` :)
00:09:06 <elliptic00> thx. change to fromIntegeral
00:09:15 <jle`> fromIntegral is in Prelude and already imported by default
00:09:19 <MarcelineVQ> kallisti: dunno what's up with the dependancies either, I get `fail (unknown package: primes)` but stack did it just fine
00:09:50 <kallisti> yeah I should really be using stack. I'm on a windows box and I haven't really felt like setting it up properly for windows
00:09:56 <kallisti> but it would save a lot of headache I think
00:10:16 <MarcelineVQ> Sometimes, not every hackage lib is on stack though iirc
00:10:47 <MarcelineVQ> https://www.stackage.org/lts-3.9
00:12:05 <kallisti> hspec, warp, and quickcheck are the only new dependencies which I'm pretty sure are all on stackage. my library itself is on stackage as well so that part isn't an issue.
00:20:28 <echo-area> So the fact that `f x . g x = liftA2 (.) f g x` hides in (f <*> g) x = f x (g x)
00:21:01 <jle`> i guess
00:21:09 <jle`> i mean, it does, but that's not the best way to look at it, i think
00:21:36 <jle`> liftA2 f g h applies f to the result of g and the result of h.  it "merges" g and h, with f
00:21:53 <jle`> > liftA2 (++) (take 3) reverse $ "hello world"
00:21:55 <lambdabot>  "heldlrow olleh"
00:21:55 <Mamaril> Hello
00:22:05 <jle`> it merges the results of take 3 and reverse with (++)
00:22:08 <jle`> hi Mamaril :D
00:23:09 <Mamaril> I want to know if haskell have generators and decorators like in python?
00:23:42 <julianleviston> Mamaril: What does a generator or decorator do?
00:23:52 <gfixler1> Mamaril: Haskell is lazy, so generators aren't necessary
00:23:58 <julianleviston> Mamaril: if it’s a decorator like in standard OOP, it’s just a function.
00:24:07 <Stratege> echo-area funfact: (f <*> g) x = f x (g x) means that (<*>) is basically S for functions :D
00:25:20 <gfixler1> Mamaril: Haskell doesn't have decorators, but it has powerful higher-order function capabilities, which is much better
00:25:34 <cwl> Any easy to manipulate xml structure in Haskell? I am doing a lot `var x = elem.querySelector('#haha'); x.setAttribute('data-id', 123); x.appendChild(document.createElement('img'));`
00:26:13 <julianleviston> cwl:  that looks like JS to me.
00:26:29 <cwl> julianleviston: Yes, that's javascript
00:26:41 <julianleviston> Stratege: I don’t understand that if f <*> g, doesn’t that mean Functor f, Functor g => ?
00:27:01 <julianleviston> sorry, Applicative f, Applicative g
00:27:03 <Mamaril> Thanks
00:27:04 <jle`> julianleviston: that's the definition of <*> for functions
00:27:09 <Stratege> ^
00:27:11 <gfixler1> Mamaril: Haskell is also immutable, so generators don't "run out" of values
00:27:18 <julianleviston> jle`: ahhh of course
00:27:22 <gfixler1> Mamaril: we also have list comprehensions :)
00:27:38 <cwl> I inspected several xml libs, HXT, HaXML, xml-conduit. They are more likely to process XML but not modify XML.
00:27:40 <jle`> instance Applicative ((->) r) where pure x _ = x; (f <*> g) x = f x (g x)
00:27:53 <jle`> honestly defining things in terms of (<*>) always feels a little awkward to me
00:28:06 <jle`> i wouldn't mind it if the Applicative class of the future let us define liftA2 instead
00:28:09 <Stratege> pure = I; <*> = S;
00:28:12 <Stratege> and ofc: const = K
00:28:24 <Stratege> minus a little bit of issues because of the type system ^^
00:28:38 <jle`> or, let us define either (<*>) or liftA2, with default implementations for both
00:28:41 <pavonia> cwl: HXT is very powerful, not necessarily easy
00:28:56 <jle`> (<*>) = liftA2 ($), or liftA2 f x y = f <$> x <*> y
00:28:57 <gfixler1> jle`: I'm just finally feeling less awkward around <*>
00:29:00 <julianleviston> Stratege: is this SKI arithmatic or whatever? I don’t really get that.
00:29:14 <jle`> <*> is the awkward one, I think
00:29:25 <jle`> liftA2 makes much more sense to me when thinking about what Applicative does for the types
00:29:33 <cwl> If there is some monadic lib so that I can write: do n <- querySelector('#xx'); appendChild n (Element xxxx)
00:29:35 <jle`> s/the types/types
00:29:48 <gfixler1> but ($), <$>, <*>, and (=<<) are so similar
00:30:01 <julianleviston> cwl: what does a selector have to do with XML? Just out of cursiosity.
00:30:05 <gfixler1> they're all just (a -> b) -> a -> b, but with embellishments
00:30:10 <julianleviston> cwl:  isn’t a selector CSS terminology?
00:30:15 <jle`> yeah, but that doesn't mean it has to be *the typeclass* method
00:30:22 <Stratege> julianleviston mhm, it's SKI with haskell functions, note that it isn't proper SKI since the infinite recursion cases are blocked by the type system.
00:30:30 <gfixler1> jle`: I suppose not
00:31:03 <quicksilver> cwl: tehre are a bunch of haskell XML libraries. I don't know if any of them support CSS selector syntax
00:31:12 <jle`> when i look at a new type/instance of Applicative, liftA2 yields more insight for me.  and when writing an Applicative instance for my own type, I think of it in terms of liftA2
00:31:33 <quicksilver> julianleviston: CSS can be used for XML as well as HTML.
00:31:36 <cwl> julianleviston: I am doing such job in nodejs, I use the selector to get the right element.
00:31:43 <cwl> I want to try it with haskell
00:31:49 <jle`> and i have to "translate" my liftA2 idea in my head to (<*>), or liftA2 ($)
00:31:58 <freemon__> i have been reading about the free monad + interpreter pattern. so the free monad is supposed to represent an AST - is there a way to actually build an AST out of free monads?
00:32:01 <gfixler1> jle`: you can't drop LA2 in the middle of FTP - we're not even over the scars of AMP yet!
00:32:22 <jle`> adding liftA2 to Applicative would be relatively painless I think...
00:32:37 <Stratege> well I'd also think similiar for AMP and FTP ...
00:32:37 <gfixler1> jle`: mutual defs? define what you like?
00:32:38 <jle`> freemon__: yes, more or less the same way you'd build the AST if you had implemented it from scratch
00:32:42 <jle`> gfixler1: yeah
00:32:47 <cwl> quicksilver: It's not about selector, the main difficulty is modification.
00:32:49 <gfixler1> jle`: sounds good
00:32:52 <quicksilver> jle`: is there actually a benefit, though?
00:32:56 <jle`> free monads aren't actually AST's; the ideas aren't equivalent
00:33:01 <quicksilver> cwl: there are several haskell libraries for XML modification.
00:33:06 <jle`> but you can write your AST using free monads, and you get a lot of neat things
00:33:12 <jle`> like free instances and combinators
00:33:15 <freemon__> jle`: ah ok.
00:33:20 <cwl> quicksilver: I cannot change a sub-element easily
00:33:23 <freemon__> jle`: so a tree build with free monads as nodes?
00:33:24 <echo-area> jle`: Ah that view of liftA2 is indeed better!  Thank you :)
00:33:39 <echo-area> Stratege: What's the S you were talking about?
00:34:05 <jle`> freemon__: if you write your AST 'like normal', then building the same thing with your AST-implemented-using-Free should look more or less the same
00:34:37 <quicksilver> cwl: why do you say that? you certainly can.
00:34:37 <jle`> in fact there's even template haskell in the 'free' library to even make it easier/pretty much identical
00:34:38 <Stratege> echo-area from SKI Calculus: Sxyz = xz(yz) ... and semantics there are close enough to haskell functions that one can say that <*> for functions is sorta S
00:35:30 <echo-area> Oh I see the context now, but I haven't yet learned SKI.  Noted, thank you
00:35:37 <freemon__> oh cool
00:35:38 <mniip> and pure for functions is sort of K
00:35:46 <freemon__> ill go look at the source
00:35:51 <mniip> and applicative for functions is sort of turing complete
00:36:00 <mniip> oh wait, only in untyped LC
00:36:22 <jle`> freemon__: if you don't have an idea of how you would build your AST if you were doing it *without* free, then it might be useful to check out tutorials/examples of people doing it
00:36:47 <jle`> my answer was based on the premise that you already know how to make normal AST's and build them up, and are wondering how you could spice up your life with Free
00:37:09 <mniip> jle`, does that bring a performance improvement/
00:37:13 <freemon__> jle`: well really im just kind of trying to learn about this stuff.. the application i had in mind though was a tree of moves for a chess game
00:37:16 <quicksilver> jle`: what would be the benefit of making liftA2 a method? I mean, I sometimes think it's a better primitive than `ap`, and there would be some symettry with liftA1 being the fundamental method of Functor, but would it actually make anything better?
00:37:41 <freemon__> jle`: it would just be a tree really, not sure what makes it an "AS"T there. 
00:37:43 <jle`> mniip: the basic Free actually has huge performance *costs*, i think
00:37:55 <cwl> quicksilver: Can I modify the node this way: do x <- getTheElement; setAttribute x "width" "10"; ...
00:37:56 <mniip> so what's the point then
00:38:03 <jle`> you can recover performance using church-encoded Free or something
00:38:12 <mniip> Coyoneda Free?
00:38:21 <jle`> i mean...you get a Monad instance for free
00:38:24 <quicksilver> cwl: absolutely you can, but you need to choose an XML library
00:38:33 <jle`> one that follows the Monad laws
00:38:38 <quicksilver> cwl: there are like 10 or more, and I can't particularly recommend any one, I haven't used them recently.
00:38:43 <cwl> quicksilver: Do you know which library can do that?
00:38:46 <jle`> and you get a MonadTrans instance for free too if you use FreeT, and some other nice instances i guess
00:39:01 <quicksilver> cwl: https://wiki.haskell.org/Web/Libraries/XML_and_HTML https://hackage.haskell.org/packages/search?terms=xml
00:39:03 <cwl> quicksilver: I can't find one have monadic
00:39:09 <quicksilver> some of them are not well documented :(
00:39:14 <jle`> the Monad instance follows the laws for free so you don't have to worry about it, I guess
00:39:26 <quicksilver> I've used HaXml and HXT in the past, but years ago, I don't remember htem well.
00:39:29 <jle`> idk, for me, i've always implemented it from scratch and not using Free whenever I have the opportunity.  I don't get the hype around Free
00:39:38 <cwl> quicksilver: none of HXT, HaXML, xml-conduit
00:39:40 <freemon__> so Coyoneda goes from any T => Functor[T], and FreeMonad goes from any Functor[T] => Monad[T] ?
00:39:49 <jle`> quicksilver: liftA2 is easier to understand for most types
00:40:07 <jle`> quicksilver: when I write Applicative instances or try to understand them, it's easiest to start from the point of view, "what would liftA2 do?"
00:40:50 <fizruk> jle`: Free is useful when you need many interpreters
00:41:08 <jle`> it actually doesn't add anything in that regard
00:41:21 <jle`> writing your own AST/Tree without using Free also lets you have multiple interpreters
00:41:31 <jle`> with the same amount of work...there's no practical difference
00:41:34 <quicksilver> cwl: you're saying that HXT, HaXML, xml-conduit are "not monadic"?
00:41:39 <quicksilver> cwl: what do you mean, and why does that matter?
00:42:09 <quicksilver> jle`: I normally start with thinking "what does *> do on f ()", actually
00:42:35 <quicksilver> jle`: I know what you mean, but I'm not sure adding it to the class actually helps anyone. We could just better document the relationships.
00:42:48 <fizruk> jle`: I guess its a matter of taste, DSL GADTs look considerably more complicated compared to Free + functor, to me at least
00:43:06 <jle`> quicksilver: for me, i'd writer be able to actually write liftA2, and let (<*>) be defined automatically
00:43:11 <jle`> writring <*> is awkward
00:43:14 <jle`> fizruk: i'm not talking about GADT's
00:43:26 <quicksilver> jle`: you can do that though, if you want to.
00:43:45 <quicksilver> you can write myliftA2 and then just define <*> = myliftA2 ($)
00:43:48 <cwl> quicksilver: To easily modify element this way, do x <- getSomeElement; setAttribute x "key" "value" ..
00:44:08 <jle`> the prototypical Free example is something like data StateF s f a = Get (s -> a) | Put s a; type State = Free (StateF s)
00:44:15 <quicksilver> cwl: why would you not just do "let x = getSomeElement in setAttribute x "key" "value"" ?
00:44:26 <jle`> er, type State s = Free (StateF s)
00:44:27 <quicksilver> cwl: a monadic interface is not of a benefit in itself, it has to exist for a reason.
00:44:35 <Stratege> jle` the benefit of Free is that it's called "Free", everyone likes free things! ^^
00:44:47 <jle`> but you could do the same thing with data State s a = Get (s -> State s a) | Put s (State s a) | Pure a
00:44:59 <quicksilver> jle`: I do however have one argument for you - liftA2 is closer to being the natural dual to "divide" ( https://hackage.haskell.org/package/contravariant-1.3.3/docs/Data-Functor-Contravariant-Divisible.html )
00:45:03 <jle`> that's just the manual expansion of Free (StateF s)
00:45:50 <jle`> whatever interpreters you'd write on Free (StateF s) are identical to the interpreters you'd write on State s
00:45:53 <cwl> quicksilver: say, x is child element of y, I want to modify x's attribute, and get the new y with new x
00:46:00 <jle`> it's the same amount of work either way
00:46:29 <jle`> i guess there's a benefit in that you don't have to use explicit recursion...so like using Fix over recursive data types.  and you have to think less about your Monad instance because Free gives you a lawful one automatically
00:46:34 <quicksilver> cwl: this is possible in all the libraries mentioned, and pretty simple and "being monadic" is not relevant.
00:46:54 <jle`> but those don't really seem like they justify all the hype
00:47:02 <freemon__> jle`: hey would you mind explaining what the free monad on a list would be?
00:47:41 <jle`> and also i definitely don't see how that justifies the common trope of, "do you want multiple interpreters?  use free!" or, "do you want an AST? use free!"
00:47:51 <jle`> the reason why those types are good interpreters and good AST's have nothing to do with Free
00:48:10 <jle`> they admit multiple interpreters and are good AST's because of the underlying type...not because of Free
00:48:48 <cwl> quicksilver: When I have a lot of child elements in y, in children of y, it's not easy. The stateful way is easy, that's why I need monadic.
00:49:03 <fizruk> jle`: it is much simpler to write interpreters for Free (StateF s) than for State s, especially when going with a more complicated domains
00:49:06 <quicksilver> cwl: no, you don't. You are misunderstanding what 'monadic' means.
00:49:19 <quicksilver> cwl: I can imagine many different library designs which make it easy to do that
00:49:30 <quicksilver> cwl: monadic has nothing to do with stateful.
00:49:37 <fizruk> jle`: admittedly, I might not have enough experience with the subject though
00:49:38 <jle`> fizruk: i don't buy it
00:50:11 <jle`> but i could just be being stubborn and picking a criteria for "simpler" that matches my pre-established conclusion :p
00:51:01 <cwl> quicksilver: I may misunderstood the monadic term. I need to simulate state similar to the State monad.
00:51:12 <fizruk> jle`: something like iterM allows you to only focus on the underlying functor (a single instruction/node), that helps
00:51:28 <thatguy> I want to apply mod partly to the second argument, i.e. have it return a function f, s.t. f(a) = mod a b. What is best practice for this?
00:51:29 <jle`> cwl: i think quicksilver's point is that you can do what you want to do much simplier/easier/more elegantly *without* treating it like State
00:51:29 <cwl> quicksilver: I still don't know how to do it using xml-conduit.
00:51:44 <jle`> thatguy: (`mod` a)
00:51:57 <thatguy> jle`, thanks
00:52:11 <cwl> quicksilver: xml-conduit is close, but when I have a lot nodes to modify, it's still hard
00:52:20 <quicksilver> cwl: unfortunately neither do I :-( but that's only because I've never used xml-conduit
00:52:37 <tomjaguarpaw> ttt_fff_: Testing and fixing, but I don't really have much time for that.  If you would like to help out that would be great and we might get somewhere!
00:52:46 <quicksilver> it's designed for streaming, maybe t's not good for mass modifications?
00:52:57 <ttt_fff_> tomjaguarpaw: I needt opaleye-sqlite for production
00:52:59 <jle`> freemon__: it's something like a rose tree
00:53:04 <ttt_fff_> tomjaguarpaw: so I'm already testing
00:53:10 <ttt_fff_> tomjaguarpaw: what needs fixing?
00:54:14 <ttt_fff_> tomjaguarpaw: should we discuss this in pm ?
00:54:35 <jle`> fizruk: yeah, having all of the pre-built generic combinators and instances is nice...sort of like using Fix instead of explicit type recursion
00:56:23 <cwl> quicksilver: For example, <svg><very><deep><nest><g id="target1"></g></nest></deep></svg>, I want to change #target1 's attribute. In js, I do var target1 = svg.querySelector('#target1'); target1.setAttributeNS(null, 'x', 10); return svg; How to do it with haskell? Especially when I have many such elements to modify.
00:57:42 <cwl> quicksilver: I haskell when I get the element #target1, and modify it, I get new #target1. But what I want is the new svg with the new #target1.
00:58:21 <thatguy> could anyone check if I am writing good code here or doing not so nice things? http://pastebin.com/eTBbZmpR it is just a toBase function
00:58:27 <thatguy> returns a number to a specific base
00:58:28 <cwl> quicksilver: Very similar to what lens do
01:01:40 <jle`> thatguy: it looks nice :)
01:01:50 <jle`> thatguy: if i were you, i'd move the mod/div logic to someFunc instead
01:02:02 <jle`> also, isZero = (== 0)
01:02:40 <jle`> also, your someFunc looks suspiciously like a foldl
01:02:43 <jle`> @src foldl
01:02:44 <lambdabot> foldl f z []     = z
01:02:44 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
01:02:54 <tomjaguarpaw> ttt_fff_: Feel free to discuss wherever you like.  The things that need fixing are the broken things you find in testing :)
01:03:11 <tomjaguarpaw> ttt_fff_: I'll definitely be happy to give you a hand getting it production-ready.
01:03:33 <jle`> er, i mean a foldr.
01:03:35 <jle`> @src foldr
01:03:35 <lambdabot> foldr f z []     = z
01:03:35 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
01:04:16 <jle`> but before you get that far, i would use guards instead of if-then-else
01:04:30 <jle`> but good job :)  these are just stliyistic things
01:05:04 <jle`> you only ever call someFunc once, so feel free to inline things like isZero straight into someFunc and get rid of h, the parameter
01:05:16 <jle`> premature abstraction doesn't always pay off :)
01:05:44 <sinelaw> what do you call a function that's defined exactly on one value?
01:06:10 <jle`> that is, instead of parameterizing `someFunc` on a function h, just drop the h parameter and use e == 0; instead of parameterizing on a function `g`, parameterize on a number b and use (e `mod` b) instead of f
01:06:17 <quicksilver> cwl: it would be simple enough in haxml, certainly, but I am rusty and don't recall how to use it
01:06:21 <jle`> s/`g`/`f`
01:06:37 <sinelaw> e.g. kind * -> * is like a function that can only be a applied on *
01:06:52 <sinelaw> (* -> *) -> * is only defined for * -> *
01:06:53 <sinelaw> etc.
01:06:55 <julianleviston> thatguy: isn’t someFunc just a helper on toBase?
01:07:00 <sinelaw> is that a "thing"?
01:07:30 <cwl> quicksilver: Thanks, I'll try it.
01:08:32 <jle`> sinelaw: well, * -> * is a function that can be applied to any type of kind *
01:08:44 <jle`> are you talking about a function a -> b that is only defined for one value of type a?
01:08:48 <jle`> and undefined for all other values?
01:08:58 <quicksilver> cwl: although did you see xml-lens (I have never used it)
01:09:07 <thatguy> jle`, thanks! Yes I already thought that someFunc probably already exists or something similar but didn't know what to search to find it. Thanks for all the tips! The abstraction was mainly for practice now
01:09:09 <jle`> a * -> * in particular can be applied to a *lot* of things, so it might not have been the best example :)
01:09:13 <sinelaw> yes, but jle` if you look at the kind-level, it can only be applied on * 
01:09:32 <sinelaw> what kinds can  * -> * be applied to? *
01:09:41 <cwl> quicksilver: I did, but not simple enough
01:09:43 <jle`> how is that different from an f :: Int -> Bool that can only be applied to things that are of type Int?
01:09:46 <thatguy> julianleviston, yes in this case it is
01:09:53 <sinelaw> jle`: it isn't
01:10:07 <sinelaw> if you look at the type level
01:10:15 <jle`> i wouldn't say that a total f :: Int -> Bool is "defined on one value", though
01:10:18 <julianleviston> thatguy: if it’s not general, you could just put it into a where clause then.
01:10:20 <sinelaw> I know
01:10:29 <sinelaw> jle`: neither would I
01:10:32 <jle`> this is just a part of the typical definition of functions --- a function has an associated domain and codomain
01:10:47 <sinelaw> jle`: right, ok
01:10:56 <jle`> so a function that works only on its single domain and not on things outside of its domain is...well, a function
01:11:49 <jle`> sort of like, asking for a term for "a monoid that has an identity"
01:11:56 <jle`> that's...just a monoid, already
01:12:16 <thatguy> julianleviston, ah yeah I could do that, thanks
01:12:33 <sinelaw> jle`: it sounds kind of silly. What I'm doing is: data Func a b = Func a b
01:12:48 <sinelaw> jle`: data Kind = Star | KFun (Func Kind Kind)
01:13:08 <quicksilver> cwl: your example, in xml-lens, should be simply doc & attributeIs "id" "target1" . attr .~ "10"
01:13:26 <quicksilver> doc & attributeIs "id" "target1" . attr "x" .~ "10"
01:13:30 <quicksilver> (sorry there was a typo)
01:13:33 <quicksilver> seems pretty simple to me
01:14:00 <sinelaw> Func is polymorphic on the type of the domain and range
01:14:45 <sinelaw> but for a given domain *type*, Func is only defined on a single domain *value* 
01:16:07 <jle`> so Func 1 True :: Func Int Bool is supposed to represent a function from Int to Bool that's only defined for 1 as the input?
01:16:46 <sinelaw> jle`: ya but that's not the sort of example that's interesting, because 1 is not 'a domain' 
01:16:56 <julianleviston> how odd is *this* funciton? removeUppercase strings = [[c | c <- string, c `notElem` ['A'..'Z']] | string <- strings]
01:17:06 <jle`> sinelaw: what examples are you thinking of?
01:17:06 <sinelaw> jle`: Func Star Star
01:17:12 <sinelaw> can only be applied to Star
01:17:33 <jle`> Func Star Star :: Func Kind Kind, it's the same situation, right?
01:17:44 <sinelaw> yes
01:17:45 <jle`> a function from Kind -> Kind that's only defined for one input, Star
01:18:05 <sinelaw> yes, because Kind is a "domain type" and values of type Kind are domains
01:18:18 <jle`> i mean...it's a *partial* function, the same as f 1 = True; f _ = undefined
01:18:32 <jle`> f Star = True; f (KFun _ _) = undefined
01:18:37 <sinelaw> yes
01:18:54 <sinelaw> just like you can't 'apply' (* -> *) on a  (* -> *)
01:18:58 <sinelaw> you need a  *
01:19:12 <jle`> yeah, because (* -> *) is not in the domain of * -> *
01:19:18 <sinelaw> right
01:19:32 <jle`> but in this case, KFun _ _ *is* in the domain of Func Kind Kind
01:19:36 <jle`> it's just undefined
01:20:11 <sinelaw> that's an interpretation
01:20:30 <sinelaw> i'm just looking for some terminology, when representing functions and domains as haskell values
01:20:48 <sinelaw> I guess it doesn't matter 
01:20:55 <jle`> well, it's still a "normal function", but you're decoupling the idea of a domain from the type parameters in Func
01:21:04 <jle`> that is, Func a b no longer represents a function whose domain is a and whose codomain is b
01:21:18 <sinelaw> the Func a b type doesn't
01:21:23 <sinelaw> but a value Func x y, does
01:21:48 <jle`> the value Func x y represents a function whose domain is the singleton set containing x, and whose codomain is the singleton set containing y?
01:21:51 <sinelaw> it represents exactly 'the type of functions with domain x and codomain y'
01:22:06 <sinelaw> no, x is the domain itself
01:22:07 <cwl> quicksilver: When I have a lot to change. I always result in let doc1 = .. let doc2 = .. doc 1... let doc3 ..
01:22:30 <jle`> ah yeah, so x is a value that represents a domain, and so is y
01:22:35 <sinelaw> yip
01:22:48 <jle`> so yeah, you're decoupling these things from the Haskell type system, but they're still just domains and codomains, from a mathematical perspective
01:23:05 <sinelaw> right, was wondering if there's a haskellism for this
01:23:37 <quicksilver> cwl: just combine the functions with (.)
01:23:42 <jle`> maybe you can say "monomorphic"?  a better answer might be one that considers the context though
01:24:14 <cwl> quicksilver: Hmm.. I think I need to learn more about lens.
01:24:38 <quicksilver> cwl: that's not really about lens (although it's a handy technique) - composing functions with (.) is just natural for haskell
01:25:35 <cwl> But I'm composing Lens, Traversal thing.
01:25:46 <quicksilver> > ["apple","pear","plum"] & (ix 0 %~ map toUpper) . (ix 2 %~ ("sugar"++))
01:25:47 <lambdabot>  ["APPLE","pear","sugarplum"]
01:26:10 <quicksilver> two different 'modifications' to that list, combined into one using .
01:38:58 <quicksilver> cwl: still there?
01:39:23 <cwl> quicksilver: yes, I'm going through the Lens tutorial
01:39:57 <cwl> quicksilver: It's not intuitive
01:40:22 <lpaste> quicksilver pasted “changing a couple of attributes with xml-lens for cwl” at http://lpaste.net/143110
01:40:29 <quicksilver> cwl: see that paste.
01:40:34 <quicksilver> I think that's the kind of thing you're tryign to do.
01:40:43 <quicksilver> I agree that lens is not intuitive until you get into it.
01:40:55 <cwl> quicksilver: Thanks so much
01:43:10 <quicksilver> well I was glad for the excuse to try out xml-lens
02:31:55 * hackagebot Hish 0.0.1 -   https://hackage.haskell.org/package/Hish-0.0.1 (jaiyalas)
02:32:31 <fractalsea> tf
02:34:17 <fractalsea> I’m writing a client for an API. The API has a endpoint where you give it a list of field you want it to return, and you get back map of those fields to their values. I want ot write a Haskell function that wraps this. Is there a way of modelling this behaviour in the Haskell type system? Or do I need dependent types?
02:37:10 * hackagebot repa 3.4.0.2 - High performance, regular, shape polymorphic parallel arrays.  https://hackage.haskell.org/package/repa-3.4.0.2 (BenLippmeier)
02:37:12 * hackagebot repa-io 3.4.0.2 - Read and write Repa arrays in various formats.  https://hackage.haskell.org/package/repa-io-3.4.0.2 (BenLippmeier)
02:37:14 * hackagebot monoid-absorbing 0.1.0.4 - A library for (left, right) zero monoids and backtracking with cut  https://hackage.haskell.org/package/monoid-absorbing-0.1.0.4 (maciejpirog)
02:37:16 * hackagebot repa-algorithms 3.4.0.2 - Algorithms using the Repa array library.  https://hackage.haskell.org/package/repa-algorithms-3.4.0.2 (BenLippmeier)
02:37:40 <quicksilver> fractalsea: well if fields and values are all strings, you can do Map String String :)
02:37:54 <quicksilver> fractalsea: otherwise perhaps I need a little more context to see what you're hoping the type system will do for you
02:39:52 <fractalsea> That’s true, but I was hoping for a way of making the return type depend on the values of the input type. So if you give it a hashet of field as the input type, the return a record who’s fields are the ones requested
02:40:06 <fractalsea> As I write that I’m almost certain it would require dependent types
02:40:13 <quicksilver> the way you've phrased that, that is certainly dependent types
02:40:21 <quicksilver> and it wouldn't be all that useful in a program anyway (I think)
02:40:35 <fractalsea> hmm
02:40:36 <quicksilver> however that doesn't mean you can't get strong type constraints here
02:40:49 <quicksilver> it's easy enough to make sure each field has the right type of value
02:40:55 <quicksilver> you can model that as a data type
02:41:05 <fractalsea> Yeah
02:41:10 <quicksilver> it is more fiddly - but possible - to encode the type of a request
02:41:14 <fractalsea> It’s going to be a record with Maybe fields
02:41:23 <quicksilver> as in "request for Foo,Bar,Baz"
02:41:40 <quicksilver> and have the type system guarantee that the answer returns (exactly) Foo Bar and Baz
02:41:46 <fractalsea> hmm
02:41:50 <fractalsea> that would be great
02:42:13 <fractalsea> At the moment the request/response are separate types (with duplication of information)
02:42:20 <quicksilver> you need a type-level list for that
02:42:26 <fractalsea> ah ha
02:42:35 <quicksilver> that's not as scary as it sounds
02:42:50 <fractalsea> Yeah I’ve come across the conept before, but have never worked with it
02:42:51 <quicksilver> the haskell98 type (Bool,(Char,(Bool,(String,()))))
02:43:00 <quicksilver> is a possible implementation of a type-level list
02:43:10 <fractalsea> I see
02:43:14 <quicksilver> that's a standard type but it's "the list [Bool,Char,Bool,String]"
02:43:17 <quicksilver> if you squint at it
02:43:20 <quicksilver> see what I mean?
02:43:25 <fractalsea> yes
02:43:55 <quicksilver> there have been a bunch of implemenations of this over the years
02:43:56 <fractalsea> I had not seen it explained like that before; that’s really helpful
02:44:01 <quicksilver> the earliest famous one was HList
02:44:31 <quicksilver> but I have always found them cumbersome to use and not having the right cost/benefit balance for actual problems I actually wanted to solve
02:44:34 <quicksilver> so I didn't :(
02:44:41 <fractalsea> OK
02:44:46 <quicksilver> recent GHCs have added some features which make this stuff a bit easier, in principle
02:44:52 <fractalsea> hmm
02:44:53 <quicksilver> but I haven't used any of that stuff
02:45:23 <quicksilver> here is a different trick for you to think about:
02:45:32 <fractalsea> Well to be honest I may try it for personal interest, but this is for a library so I would rather favour simplicity over nicely constrained types
02:45:42 <quicksilver> supposing data Record = Record { foo :: Int, bar :: Char, baz :: Bool }
02:45:50 <quicksilver> that's the kind of thing you are imagining, yes?
02:45:54 <fractalsea> yeah
02:45:58 <fractalsea> as the return type
02:46:02 <quicksilver> step 1 trick is this:
02:46:23 <quicksilver> data Record f = Record { foo :: f Int, bar :: f Char, baz :: f Bool }
02:46:39 <quicksilver> now "Record Maybe" is the maybe-thing you were talking about 5 minutes ago
02:46:58 <quicksilver> but "Record Identity" is something which is the same as my first non-parameterised Record
02:47:16 <quicksilver> so you can distinguish in the type system between "all parameters definitely there" and "all parameters optional"
02:47:38 <fractalsea> ah interesting
02:47:51 <quicksilver> step 2 trick takes this just slightly further
02:48:17 <quicksilver> data Record f g h = Record { foo :: f Int, bar :: g Char, baz :: h Bool}
02:48:21 <julianleviston> quicksilver: why f?
02:48:48 <julianleviston> quicksilver: is this a functor or you just prefer it to a b etc. ?
02:49:01 <fractalsea> understood
02:49:02 <quicksilver> fractalsea: now you can specify a type whicih 'definitely has foo, maybe has bar, and definitely doesn't have baz'
02:49:08 <julianleviston> quicksilver: there’s no type constraint, so I guess it’s just random?
02:49:13 <fractalsea> That’s useful
02:49:17 <fractalsea> Thanks!
02:49:18 <quicksilver> fractalsea: Record Identity Maybe Void1
02:49:34 <quicksilver> julianleviston: I tend to use f for (* -> *)
02:49:37 <julianleviston> quicksilver:  oh I get it
02:49:40 <quicksilver> julianleviston: and a,b,c for *
02:49:42 <julianleviston> quicksilver: is this normal haskell?
02:49:48 <quicksilver> yes, all normal haskell
02:49:50 <julianleviston> quicksilver:  I didn’t know you could do that! :) 
02:49:54 <quicksilver> that's all haskell98 I believe
02:50:02 <julianleviston> quicksilver: oh maybe I did…
02:50:07 <quicksilver> except haskell98 doesn't let you actually define Void1
02:50:19 <julianleviston> quicksilver:  I guess I’ve just never seen it written with record types before… very clever!
02:50:41 <julianleviston> quicksilver: I’ve always seen it done the other way around, I think.
02:50:46 <quicksilver> fractalsea: not a concrete suggestion to go with either of those, just point some corners in the design space for you to think about.
02:50:56 <julianleviston> quicksilver: like the concrete types parameterized.
02:51:02 * quicksilver nods
02:51:13 <quicksilver> fractalsea: it's a suprisingly expressive type system.
02:51:27 <quicksilver> fractalsea: in the end you have to be guided by the api you want your library to have.
02:52:53 <fractalsea> quicksilver: Yeah that really helps. I’m not sure I will go that way, but like you say it’s nice to have another option to consider because I wouldn’t have come up with that myself
02:52:57 <fractalsea> Thanks again
02:53:45 <quicksilver> fractalsea: I suspect Vinyl can express exactly what you want
02:53:51 <quicksilver> btu I have never used Vinyl myself
02:53:57 <quicksilver> https://github.com/VinylRecords/Vinyl/blob/master/tests/Intro.lhs
02:55:21 <fractalsea> That’s interesting. I have been tempted to give vinyl a try before to solve over issues I’ve had with records. In this case it’s not really appropriate since this is the external interface of a library, so I should stick to vanhilla types here
02:56:17 <quicksilver> I think I'm allowed to say haskell can do dependent types when the type of the result depends parametrically on the type of the inputs.
02:56:43 <quicksilver> well that's silly
02:56:45 <quicksilver> try again
02:56:58 <quicksilver> haskell can have functions whose result type depends on the *type* of the inputs
02:57:05 <quicksilver> but not if it depends on the *value* of the inputs
02:57:11 <quicksilver> that's much better.
02:57:23 <quicksilver> so the "trick" is to encode enough information in the types of the inputs
02:57:30 <quicksilver> to enable to the types of the output to be rich enough?
02:58:42 <fractalsea> Yeah that makes sense. I guess you essentially get dependent types when you lift values to the type level
02:59:15 <quicksilver> yes, so to encode any kind of value-dependency you need to choose a way to reflect some part of the values into the type system
02:59:21 <quicksilver> and we have a bunch of tools to do exactly that
02:59:30 <quicksilver> I outlined a bunch of haskell98 ones above ^^
02:59:36 <fractalsea> yeah
02:59:39 <quicksilver> GADTs also deserve an honourable mention.
02:59:56 <quicksilver> and many recent GHC features inch in this direction - hence vinyl
02:59:57 <fractalsea> It’s ones of thos things where I get the principal, but have never tried it out in practice
03:00:18 <quicksilver> unfortunately(?) there are lots and lots of possible approaches
03:00:20 <fractalsea> It can get a little crazy when you start pushing the type system to its limit like that
03:00:26 <fractalsea> hmm
03:00:27 <fractalsea> yeha
03:00:37 <quicksilver> it can be hard to understand the tradeoffs without trying them a bit
03:00:42 <ttt_fff_> https://gist.github.com/1229b7e115d2ca011581 <-- is there a way to simplify this using liftM, <$>, or <*> ?
03:00:57 <quicksilver> the problem with hashkell programming is actually getting stuff done rather than spending all your time thinking about what would be nicer.
03:01:10 <fractalsea> Definitely, hopefully the various approaches get unified as time goes on, and people have had the chance to experiment with what works well in practice
03:01:15 <ttt_fff_> lol
03:01:18 <ttt_fff_> I am totally guilty of that
03:01:23 <quicksilver> ttt_fff_: well =<< return is an immediate red flag
03:01:24 <ttt_fff_> https://gist.github.com/1229b7e115d2ca011581 <-- is there a way to simplify this using liftM, <$>, or <*> ?
03:01:32 <quicksilver> ttt_fff_: no need to bind something which is only returned.
03:01:50 <ttt_fff_> yeah, but I'm trying ot make it easier for me to see <$> and <*>
03:02:06 <quicksilver> =<< return *is* <$>
03:02:22 <julianleviston> ttt_fff_: ooh are you doing react-dom stuff?
03:02:34 <ttt_fff_> julianleviston: lol, yes, and I don't want to touch mkDyn
03:02:53 * ttt_fff_ has philosophical problems with Template Haskell
03:02:55 <julianleviston> ttt_fff_: I don’t know much about it. I’ve just watched a couple of trinkle thingies on it…
03:02:58 <julianleviston> ttt_fff_: also.
03:03:06 <ttt_fff_> ryan trinkle is a badass
03:03:09 <julianleviston> ttt_fff_: maybe necessariy evil sometimes tho
03:03:09 <ttt_fff_> we need more people like him
03:03:38 <quicksilver> > [1,2,3,4] =<< return (+1)
03:03:39 <julianleviston> ttt_fff_: I was watching a hudak video on FRP the other day and I recognised him in the audience. I was like hehe :)
03:03:40 <lambdabot>      Couldn't match expected type ‘(Integer -> Integer) -> m b’
03:03:40 <lambdabot>                  with actual type ‘[Integer]’
03:03:40 <lambdabot>      In the first argument of ‘(=<<)’, namely ‘[1, 2, 3, 4]’
03:03:49 <quicksilver> bleh, stupid
03:04:02 <ggVGc> what do you guys think about this? http://journal.stuffwithstuff.com/2010/10/29/bootstrapping-a-type-system/
03:04:06 <ttt_fff_> julianleviston: ryan trinkle in audience of ra FRP talk? was this in sovient russia?
03:04:07 <ggVGc> looks pretty amazing to me
03:04:36 <julianleviston> ttt_fff_: paul hudak pretty much co-invented FRP in haskell…
03:04:45 <ttt_fff_> there's also conal elliot
03:04:54 <julianleviston> ttt_fff_: he put the co in co-invented ;-)
03:06:08 <quicksilver> ttt_fff_: "((mapDyn2 (uncurry f)) d) =<< (return d3)" is just "((mapDyn2 (uncurry f)) d) d3"
03:06:13 <ttt_fff_> :t (<$>)
03:06:14 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:06:21 <ttt_fff_> :t (<*>)
03:06:22 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:06:23 <quicksilver> which you'd normally rite
03:06:30 <quicksilver> mapDyn2 (uncurry f) d d3
03:06:44 <ttt_fff_> the hard part is getting rdi of the "d <-"
03:07:19 <quicksilver> mapDyn2 (,) d1 d2 >>= \d -> mapDyn2 (uncurry f) d d3
03:07:36 <quicksilver> but that's just expanding the definition of monad notation
03:07:38 <ttt_fff_> yeah, I'd like to get rid of the >>= too
03:07:41 <ttt_fff_> by using <$> and <*>
03:07:48 <quicksilver> you can't
03:07:55 <ttt_fff_> why not?
03:07:57 <quicksilver> this is a genuine monadic expression
03:08:06 <quicksilver> it can't be expressed by applicative combinators alone
03:08:15 <quicksilver> it will need bind or join
03:08:33 <quicksilver> the second action is dependent on the first (via `d`)
03:09:21 <ttt_fff_> i see
03:09:23 <ttt_fff_> this amkes sense
03:09:26 <ttt_fff_> thanks for explaining :-)
03:09:27 <ttt_fff_> quicksilver++
03:09:54 <quicksilver> what is mapDyn2?
03:10:03 <ttt_fff_> it's reflex-dom combineDyn2
03:10:10 <ttt_fff_> you want the type sig?
03:10:21 <quicksilver> combineDyn2 has no google hits
03:10:48 <ttt_fff_> https://gist.github.com/anonymous/035bada43963af80b86b
03:11:47 <quicksilver> aha
03:12:11 * hackagebot wai-middleware-etag 0.1.1.1 - WAI ETag middleware for static files  https://hackage.haskell.org/package/wai-middleware-etag-0.1.1.1 (ameingast)
03:12:28 <ggVGc> what would haskell's equivalent of F#'s type providers be? Just generating haskell from data schemas?
03:13:42 <quicksilver> interesting
03:13:50 <quicksilver> I wonder why that type isn't Functor or Applicative
03:13:55 <quicksilver> presumably it doesn't work out right
03:14:04 <ttt_fff_> actually it would work fine
03:14:09 <ttt_fff_> but using monad makes it more efficient
03:14:13 <ttt_fff_> and avoids some re-evaluation
03:14:14 <ttt_fff_> or something
03:14:20 <ttt_fff_> I don't understand how frp implemnetaitons works
03:14:21 <quicksilver> Dynamic I mean
03:14:25 <quicksilver> not the monad you're using
03:14:28 <quicksilver> the type dynamic itself
03:14:29 <ttt_fff_> basically sticking it in a monad enforces it only gets evaluated once
03:14:41 <quicksilver> oh because the combination are only defined inside a monad
03:14:51 <liste> ggVGc template haskell and maybe type families
03:14:58 <quicksilver> too long since I have thought about FRP
03:16:12 <lpaste> Ferdirand pasted “Include directive for IO-stacked ParsecT” at http://lpaste.net/143114
03:16:36 <Ferdirand> so i'm trying to implement an #include-like directive for my toy language
03:17:08 <Ferdirand> the version above compiles, but i'm not very happy about it, it looks overcomplicated
03:17:11 * hackagebot reflex-animation 0.1.4 - Continuous animations support for reflex  https://hackage.haskell.org/package/reflex-animation-0.1.4 (saulzar)
03:17:37 <Ferdirand> is there a cleaner way that I missed ? I wasn't sure how to use setInput
03:18:35 <Gurkenglas> (Replacing lines 7 to 9 by "either (fail.show) return result" will remove two names, but that's probably not what you're asking for)
03:18:50 <Ferdirand> oh, that's something actually
03:19:51 <Ferdirand> but what I found awkward was to need to match over the result of runPT, then send the parse error back up through fail.show
03:20:16 <Ferdirand> i'm trying to avoid looking at ParsecT internals, to maintain abstraction
03:21:58 <quicksilver> I think it's more elegant to directly mess with parsec's "coming next" stream
03:22:01 <quicksilver> Ferdirand
03:22:15 <quicksilver> rather than taking the parser as a parameter and running
03:22:36 <quicksilver> ..unless the #included files have a totally unrelated internal syntax, in which case I think you're doing it the right way.
03:22:58 <kallisti> ggVGc: yes, template haskell is commonly used for that. Something like this for example: https://hackage.haskell.org/package/persistent-template-2.1.3.7/docs/Database-Persist-TH.html
03:23:28 <Ferdirand> quicksilver: they do have the same syntax
03:23:37 <Ferdirand> what puzzles me is the type of setInput
03:23:45 <Ferdirand> setInput :: Monad m => s -> ParsecT s u m ()
03:24:10 <quicksilver> but I don't know how to do this in parsec, not sure how setinput works
03:24:10 <Ferdirand> does it know to go back to the original source once its hits eof ?
03:24:51 <Ferdirand> the definition in hackage looks fishy to me
03:24:56 <Ferdirand> = do updateParserState (\(State _ pos user) -> State input pos user)
03:25:11 <Ferdirand> looks like something is lost there
03:25:15 <quicksilver> it just drops the old input on the floor
03:25:16 <quicksilver> I'd say.
03:25:27 <quicksilver> another approach is to structure your parser as two levels
03:25:29 <kallisti> all it's doing is setting a new parser state.
03:25:38 <kallisti> which is what you can roughly gather from the type
03:25:51 <quicksilver> first process the #include directives to generate a preprocessed stream
03:25:53 <quicksilver> then parse that
03:27:23 <Ferdirand> i hope that would be what happens with the current version
03:28:01 <Ferdirand> i have a non-IO-constrained parser for non-include statements
03:28:21 <kallisti> do { oldInput <- getInput; setInput includeFileContents; parseInclude; setInput oldInput }
03:28:34 <kallisti> just make sure parseInclude parses all the way to EoF
03:28:48 <Ferdirand> kallisti: in hindsight, that looks completely obvious, thanks
03:29:30 <Ferdirand> man, i'd slap myself for not figuring this one out by myself
03:34:35 <quicksilver> you could also do setInput (includeFileContents ++ oldInput)
03:34:37 <quicksilver> couldn't you?
03:35:17 <Ferdirand> I thought of that
03:35:37 <Ferdirand> actually, one of the reaons i went with the subparser call, was to make sure error reporting would still make sense
03:36:02 <quicksilver> suprised not to be able to google up an answer
03:36:14 <quicksilver> "How do you #include in parsec" seems like such an obvious quesiton :)
03:36:46 <Ferdirand> to think of it, with kallisti's version, the position information would be lost, no ?
03:36:52 <kallisti> if your line number information is stored directly in the parsec state, then you should still get sane errors using the approach I mentioned
03:36:55 <kallisti> however
03:37:05 <kallisti> you'd want to copy the whole parsing state, not just the input
03:37:22 <quicksilver> and reset 'pos' by hand to something referencing the new file name
03:37:45 <kallisti> right, presumably that happens in the parseInclude step, which is probably the same parser that you used to parse the original file
03:37:54 <kallisti> which would setup  the position/file state
03:38:34 <quicksilver> there is getState/setState to save the whole thing
03:38:52 <quicksilver> although if you're using user state you may not wish to restore it, you may want it to continue
03:39:00 <kallisti> getParserState/setParserState is what they're called I believe.
03:39:09 <quicksilver> yes, sorry, so they are :)
03:40:09 <kallisti> honestly the subparser approach looks like a good choice. It mostly depends on what kind of custom state you have and whether or not you want it to transfer down to includes.
03:40:53 <Ferdirand> that is a good question
03:41:30 <quicksilver> another thing is what syntactic position #include can appear in, Ferdirand 
03:41:51 <quicksilver> if #include is a pseudo-declaration, which can only appear at the top level, then you know which sub-parser to run
03:42:06 <quicksilver> but note that C's #include can appear in the middle of a declaration or expression.
03:42:13 <Ferdirand> for the record, i'm targeting Yara (small language for writing malware signatures)
03:42:46 <Ferdirand> there doesn't seem to be any formal spec beyond the bison grammar in the source repo, unfortunately
03:42:52 <Ferdirand> and I guess this is subject to change
03:43:10 <quicksilver> valid in C with preprocessor: "void main() { int f =\n #include "value_of_f.h" \n ; }"
03:43:25 <quicksilver> where value_of_f.h is the one-character file containing the char '3'
03:43:28 <quicksilver> you get the idea.
03:43:35 <Ferdirand> so for now I got away with no user state, but that is because i'm conveniently ignoring their import directive
03:43:56 <quicksilver> so do implement CPP-like includes you really want it to run "before" or "underneath" the main parser
03:44:03 <quicksilver> and produce the stream of tokens which the main parser consumes.
03:45:50 <Ferdirand> actually, in this specific case i don't think it makes sense to pass user state down the subparser
03:46:18 <Ferdirand> because by convention included files should also be valid standalone
03:46:31 <Gurkenglas> Why isn't there modifyInput?
03:47:37 <deni> johnw: you around?
03:48:00 <deni> johnw: you mentioned system "uname -a" as in running that as a shell command and then I just have to parse the output?
03:48:11 <deni> uname is present on all the distros right?
04:02:00 <ggVGc> kallisti: thanks. Can you see anything type providers would give better than what template haskell offers?
04:02:10 <ggVGc> I'm trying to understand the fuss about them
04:04:36 <kallisti> ggVGc: I'd have to read the MS docs more to give you a good answer, and there's only so much MS docs I can read in a single sitting. :)
04:05:15 <ggVGc> fair
04:05:34 <ggVGc> anyway, type providers seem to just be "compile time static types for arbitrary data"
04:05:41 <ggVGc> which is nice, but doesn't seem so revolutiounary
04:05:58 <kallisti> ggVGc: it looks like type providers resolve at compile-time yes? If so, then they basically have the same limitations of TH, and TH is more versatile because it can be used to generate arbitrary expressions, patterns, or top-level declarations.
04:06:09 <ggVGc> yep
04:06:16 <ggVGc> that's my impression too
04:06:17 <cocreature> deni: uname is in coreutils so it should be present on all distros
04:06:33 <ggVGc> I mean, I've used type providers, but while using them I keep thinking "Isn't this just code generation from metadata"
04:06:44 <kallisti> but it seems like type providers are easier to use for the specific thing that they do allow. TH code can get pretty hairy.
04:06:50 <ggVGc> yep
04:06:52 <ggVGc> so, convenience
04:07:13 <quicksilver> ggVGc: in the old days we did it with CPP macros
04:07:13 * hackagebot feed 0.3.10.3 - Interfacing with RSS (v 0.9x, 2.x, 1.0) + Atom feeds.  https://hackage.haskell.org/package/feed-0.3.10.3 (AdamBergmark)
04:07:19 <ggVGc> quicksilver: I've done that...
04:07:20 <ggVGc> :((((
04:07:23 <quicksilver> or occasionally something more powerful like m4 or a perl script
04:07:27 <kallisti> so you COULD, say, fetch some kind of information from a remote server and use that info to generate types using template haskell, but I don't know of any open source code that does it.
04:07:32 <quicksilver> type providers are just convenient
04:07:32 <ggVGc> yeah, I've used m4 for this several times
04:07:34 <quicksilver> as you said.
04:07:35 <ggVGc> in several languages
04:07:51 <ggVGc> yep, I'm not bashing them. Just trying to think if there's anything extra, but I don't think so
04:07:53 <quicksilver> I really love that trick where you #include the same file multiple times
04:07:55 <ggVGc> I think they're a nice feature though
04:07:59 <quicksilver> with different #defines
04:08:06 <quicksilver> and it builds up a bunch of related boilerplate
04:08:10 <quicksilver> blew my mind first time I saw it :P
04:08:11 <ggVGc> C metaprogramming is pretty fun, tbh
04:08:13 <ggVGc> but it's not good...
04:08:17 <cocreature> kallisti: while not being a remote server, Frames is similar in spirit, it generates types by looking at a csv https://github.com/acowley/Frames
04:08:28 <quicksilver> it's the kind of fun that comes from solving something you initially thought was impossible
04:08:35 <quicksilver> which is quite different from 'good'
04:08:37 <quicksilver> as you say :)
04:08:49 <ggVGc> quicksilver: using #include directives as  function evaluations blew my mind the first time I encountered it
04:08:54 <ggVGc> but it also rubbed me the wrong way
04:09:09 <hodapp> ggVGc: it's only "fun" if you're not under the burden of making it work, or maintaining it.
04:09:25 <ggVGc> making it work is fune, maintaining it not so much
04:09:34 <quicksilver> well it's definitely a possible way to produce horrendous unmaintainable code, and remarkably hard to understand errors
04:09:39 <quicksilver> but that *precise* criticism
04:09:41 <hodapp> making it work is only fun if you don't *have* to make it work.
04:09:43 <quicksilver> also applies to TH. Or to C++.
04:09:47 <ggVGc> hodapp: macro and #include abuse was my first encounter with metaprogramming though
04:09:50 <ggVGc> so it was a new world for me
04:09:58 <hodapp> mine was probably stuff in Lisp
04:10:13 <deni> cocreature: yeah that's what i though
04:10:16 <deni> *thought
04:10:21 <ggVGc> I've crashed the visual studio compiler twice through erronous template programming.. that wasn't super fun to figure out
04:10:28 <hodapp> also with people using the term "metaprogramming" to substitute for "I don't know what the hell I'm doing, but I bet it's more advanced than what you're doing"
04:10:42 <kallisti> are there any TH libraries that generate patterns? I haven't really seen that feature of TH used.
04:10:55 <hodapp> I haven't seen one but that's not saying much
04:11:10 <hodapp> the only TH I examined in detail was in Ivory
04:11:16 <ggVGc> lisp is maybe the only language with fairly sane metaprogramming, since the line is fairly blurred there
04:11:25 <ggVGc> but also.. I'd say it's a problem of lisp
04:11:37 <hodapp> ggVGc: TH doesn't count as sane metaprogramming?
04:11:43 <quicksilver> kallisti: it would be entirely logicaly to have TH which generated code from a WSDL file, which is traditionally served by a remote server
04:11:48 <ggVGc> hodapp: I haven't actually used TH myself. But maybe yea
04:11:57 <quicksilver> kallisti: but it would make no engineering sense to couple the network access that tightly
04:12:02 <ggVGc> hodapp: I wouldn't say it's at the level of integration as lisp though
04:12:09 <quicksilver> kallisti: you would, pragmatically, make download and code generate separate steps.
04:12:10 <ggVGc> since all of lisp is practically meta
04:12:14 * hackagebot cblrepo 0.18.2 - Tool to maintain a database of CABAL packages and their dependencies  https://hackage.haskell.org/package/cblrepo-0.18.2 (MagnusTherning)
04:12:20 <hodapp> ggVGc: you certainly can't do it at runtime as in Lisp
04:12:55 <hodapp> whatever 'runtime' means for Lisp o_O
04:12:56 <kallisti> quicksilver: yeah you'd probably have a monitor that runs in the background and updates a local mirror from the server's changes, rather than using TH directly.
04:13:04 <ggVGc> but I don't know. At the same time I think separating the "meta" from the "normal" has benefits too, so lisp isn't all roses
04:13:09 <quicksilver> kallisti: "soap" does it at runtime, not at compile time
04:13:17 <ggVGc> hodapp: right, that's the issue
04:13:18 <quicksilver> kallisti: as a result its soap interface is untyped
04:13:19 * hodapp hears SOAP, shudders
04:13:31 <quicksilver> kallisti: but then it's not particularly hard to layer a typed interface for the webservices you care about
04:14:20 <kallisti> lisp has easy metaprogramming because lisp barely has syntax. TH is in the same spirit as lisp macros, but the AST is a smidge more complex.
04:14:21 <julianleviston> hey if I have … say…. a web thingie… running on Snap… on Heorku…. which doesn’t allow interprocess comms… and I have say I dunno… 2 or 3 “dynos” (as they’re called) and I want to have a “single” timer-based trigger, kind of like a cron job, but at the haskell level…. how do you think would be a good way to go about doing that?
04:14:37 <Aruro> guys, how to achieve +RTS -s from withing code? any module dedicated to it?
04:15:16 <ggVGc> honestly I barely know Haskell yet, but learning slowly, so TH is a fair bit above what I'd be doing for a while
04:15:39 <bennofs> Aruro: compile with --with-rtsopts=-S and take a look at GHC.Stats
04:15:58 <Aruro> bennofs: ty!
04:16:09 <kallisti> aside from having more complex syntax than Lisp, the other big reason why TH isn't as important to normal Haskell code is that lazy evaluation covers a large segment of use cases that lisp macros are frequently used for.
04:16:41 <ggVGc> kallisti: well, having a strong and expressive type system doesn't mesh super well with very integrated metaprogramming(in the lisp sense), I think
04:17:03 <ggVGc> I'd say haskells type system allows us to express a lot of things in "normal code" that most languages would need metaprogramming for
04:17:17 <breadmonster> Like what?
04:17:19 <ggVGc> i.e the way I see it Haskells type system is already one level "meta" above mostothers
04:17:48 <gciubota_> Hi guys, I think this was asked a lot on this channel and I apologise about that. Can you give me some good Monads tutorial / problems ?
04:17:48 <gciubota_> I know the Monad "theory" but I cannot "feel" them yet. The abstraction level of monads is too advanced for me right now and I want to get used with it.
04:17:51 <kallisti> ah that's a good point actually. I forgot lisp macros can be recursive at runtime. You can't really do that with TH. But, again, many of the cases where you'd use a recursive macro are covered by non-strict evaluation semantics.
04:17:55 <ggVGc> breadmonster: well, I might just not understand Haskell well enough yet. But type classes feels to me like meta types
04:18:27 <breadmonster> ggVGc: To be a fair, inheritance and typeclasses have fairly similar use cases.
04:18:43 <ggVGc> Having Kinds is what first made me feel like this in Haskell
04:18:53 <breadmonster> They're not entirely isomorphic, but it's sorta close.
04:19:06 <Aruro> gciubota_: relax , there are no monads, just function application. Look at here for starter https://wiki.haskell.org/Typeclassopedia
04:19:11 <quicksilver> breadmonster: no no no no no
04:19:33 <quicksilver> typeclasses and inheritance are very, very different. They coincidence in almost no use cases.
04:19:52 <Copperis> is it possible to change guards to be pointfree? For example in this function: http://lpaste.net/143115
04:19:56 <quicksilver> Any translation from a C++ or Java design which maps a class or interface to a haskell typeclass needs a second thought :)
04:19:58 <ggVGc> the way I see Haskell currently(as a newbie) is that the whole type system is functional, meaning I can combine and work on the types the same way I could work on instances. So in that way it feels one level more meta to me than other languages
04:20:45 <quicksilver> Copperis: no, not in any elementary way.
04:20:54 <julianleviston> breadmonster: the problem with classes is they bind the “procedures” to the “data”… whereas with typeclasses you can have what amounts to like… multiple inheritance without the mess.
04:20:57 <Copperis> quicksilver, ok
04:21:17 <SX> Hi! Should I use typeclasses to make module level abstractions? Like "here's an interface you should implement for your data type to make it work with lib"?
04:21:33 <quicksilver> Copperis: as a rule of thumb, btw, never use (== []) or (length foo)
04:21:34 <frerich> Copperis: Not really, no - for what it's worth, in your particular example there are probably better means to make the code concise than making the guards point-free :-}
04:21:39 <ggVGc> breadmonster: what would you say a Kind is in non-haskell?
04:21:49 <quicksilver> SX: short answer is no.
04:21:51 <breadmonster> julianleviston: I'd agree, but that's a programmer side problem, C++ just have those kinds of things, they're just uglier.
04:21:57 <breadmonster> ggVGc: Still searching for that :P
04:22:00 <kallisti> SX: that's a thing typeclasses can be used for, yes. Though whether or not it's necessary or beneficial depends largely on the library's interface.
04:22:03 <SX> And is it a good idea? Another way is to make adt with functions.
04:22:14 * hackagebot reflex-gloss-scene 0.1 - A simple scene-graph using reflex and gloss  https://hackage.haskell.org/package/reflex-gloss-scene-0.1 (saulzar)
04:22:15 <ggVGc> breadmonster: yeah, so that makes me feel haskells type system is already kind of meta
04:22:17 <julianleviston> breadmonster: LOL.
04:22:20 <Copperis> frerich, yup, a palindrome can be checked with "line == reverse line"
04:22:22 <ggVGc> so we don't need as much metaprogramming
04:22:38 <quicksilver> Copperis: I would pattern match for the empty case and the 1 case
04:22:46 <Copperis> quicksilver, what to use instead of length or (== []) ?
04:22:59 <quicksilver> Copperis: isPalindrome [] = True; isPalindrome [x] = True;
04:23:20 <quicksilver> and then drop back to your existing code for the catch-all case
04:23:32 <kallisti> SX:  it mostly comes down to a judgement call. There's no hard rules. If you gave us more information about what you're wanting a typeclass to accomplish, that would help.
04:23:34 <frerich> Copperis: Instead of '== []' you can also use 'null' (in case you want to continue using guards).
04:23:49 <ggVGc> on another note, I think the wiki page of Kinds is a fairly good example of why Haskell isn't doing too well for attracting users. When the help starts out with ""In type theory, a kind is the type of a type constructor..."
04:23:58 <SX> I want to make an interface for my network client and make different implementations. Without making adt with different constructors.
04:23:59 <ggVGc> anything starting with "In type theory" probably is a bit offputting
04:24:19 <quicksilver> ggVGc: do you, in fact, think haskell isn't doing well at attracting users?
04:24:21 <Aruro> ggVGc haskell does not need any more new users anymore :D
04:24:38 <quicksilver> I agree that's an off-putting wiki page but I'm not convinced it is causing a problem.
04:25:06 <quicksilver> SX: why "Without making an ADT"?
04:25:13 <ggVGc> quicksilver: yeah, absolutely. Evan Czaplicki(author of Elm) has a lot of good things to say about it
04:25:19 <quicksilver> SX: what motivates you to impose that constraint on yourself?
04:25:31 <SX> To provide an API to work with clients to user, but leave an implementations in different modules
04:25:38 <quicksilver> SX: I would say than an ADT is almost certainly better than a typeclass
04:25:38 <ggVGc> I pretty much agree with all his ideas about language adoption and how FP can be brought more into the everyday programmer world
04:25:49 <quicksilver> the purpose of a typeclass is overloading
04:26:01 <quicksilver> if you think you win something by overloading, then sure
04:26:14 <quicksilver> but you need type-based dispatch for that overloading so it's often clumsy
04:26:19 <ggVGc> quicksilver: the bottom line is that we want the average-joe web developer to use haskell features in his everyday work
04:26:19 <quicksilver> there are lots of other tools.
04:26:22 <ggVGc> and enjoy it
04:26:26 <SX> So single adt with Client = Client1 {} | Client2 etc is not an option
04:26:56 <quicksilver> SX: no, the adt you would define is "data MyClient"
04:27:01 <julianleviston> ggVGc: sorry, but the “average web developer” does NOT want to learn as much as Haskell provides. They just want to get their work done.
04:27:04 <quicksilver> SX: each implementation would just be a value of this type
04:27:20 <quicksilver> SX: parallelImpl :: MyClient
04:27:25 <quicksilver> serialImpl :: MyClient
04:27:46 <julianleviston> ggVGc: in fact, I think reactjs is kinda pushing the enveope for change of “the average web programmer"
04:27:47 <quicksilver> julianleviston: I think ggVGc is saying that he would like haskell to be a language they would enjoy adopting
04:27:50 <SX> What should I store in client then? Interface?
04:27:54 <ggVGc> julianleviston: exactly, and that's the issue. What we, programmers as a group, should want, is that all software is developed with better techniques, and that the average-joe's of our work feel it's useful and easy to get into
04:28:06 <quicksilver> julianleviston: I'm not opposed to that notion although I'm not convinced it's achievable myself
04:28:07 <ggVGc> julianleviston: i.e they should take part of the great features, without feeling it's difficult
04:28:07 <julianleviston> quicksilver: there’s an issue there though that has nothing to do with language adoption.
04:28:15 <quicksilver> many many issues all conflated :)
04:28:18 <Aruro> Copperis: your polindrom is beautiful enough to my taste, only thing you could use safe head
04:28:26 <Aruro> Copperis: from module Safe
04:28:28 <quicksilver> SX: essentially yes
04:28:34 <kallisti> SX: data. probably lots of functions. things relevant to specifying the implementation of your interface.
04:28:34 <julianleviston> ggVGc: yeah, but we, programmers , generally, as a group, don’t want that. We want to get our work done… on whole.
04:28:44 <quicksilver> Aruro: Copperis's paste is a good example of when *not* to use safeHead
04:28:52 <Copperis> Aruro, thanks, what's safe?
04:28:53 <julianleviston> ggVGc: you can want it all you like, but the facts are pretty clear.
04:29:03 <SX> And make smart constructors with additional realisation specific functions and data, currying them to match this api, yes?
04:29:05 <Aruro> quicksilver: elaborate?
04:29:10 <ggVGc> julianleviston: right, but the technology can change so we get our job done using better techniques without feeling it's a big hassle getting into it
04:29:36 <ggVGc> julianleviston: today every random person is using a GPS. They could never have done that with the early GPSes
04:29:37 <julianleviston> ggVGc: I disagree… learning new better ways of doing things takes time and effort. It has nothing to do with syntax or tooling.
04:29:41 <ggVGc> we can do this for programming too, and we have
04:30:04 <quicksilver> Aruro: Copperis's code makes it impossible to reach the line which says 'head' unless the list has at least 2 elements in
04:30:06 <ggVGc> anyway, Julian says it better than me. I think Elm is a very good step on the road
04:30:06 <SX> Or closure, which returns fully functional MyClient.
04:30:19 <ggVGc> ehh, Evan
04:30:19 <ggVGc> I meant
04:30:26 <quicksilver> Aruro: so 'safeHead' would just give you a 'Nothing' case which can't be reached
04:30:37 <Aruro> Copperis: http://dev.stephendiehl.com/hask/#safe
04:30:40 <quicksilver> Aruro: so you'd have to write extra code with an error condition for something impossible
04:30:47 <quicksilver> Aruro: that's extra work to no benefit.
04:30:53 <julianleviston> ggVGc: no… that’s not quite the same thing… that’s providing “easy tooling”. This is what I’m telling you. No amount of easy tooling is going to get you to the point where you understand what a Functor is more easily. Tooling can’t make you magically learn without pain.
04:31:06 <Aruro> quicksilver: what about headDef?
04:31:19 <quicksilver> SX: I'm not sure what you mean by closure but yes, probably that is what I meant
04:31:23 <ggVGc> I just think it's a matter of momentum and human psychology
04:31:29 <quicksilver> Aruro: that makes you provide a default value which you know will never occur?
04:31:36 <quicksilver> Aruro: how does that benefit you? :)
04:32:04 <SX> quicksilver: https://en.wikipedia.org/wiki/Closure_%28computer_programming%29
04:32:13 <ggVGc> quicksilver: I think haskell could never be the language, but haskell will build the base upon which some other language/tool will come out with the good parts of haskell packaged in a way that suits the mainstream programming world. Sort of like lisp was for javascript
04:32:18 <Aruro> quicksilver: seems reasonable :)
04:32:26 <Aruro> quicksilver: your argumentation
04:32:37 <quicksilver> SX: I know what a Closure is. But we're talking about haskell, the language, as we use it. Haskell doesn't "have" closures. Closures are an implementation technique. Y
04:32:56 <quicksilver> ggVGc: yeah but lisp is hardly feeling good about javascript :P
04:33:04 <quicksilver> ggVGc: still I expect you're right.
04:33:08 <quicksilver> on the other hand julianleviston is right too.
04:33:13 <Aruro> quicksilver: his version is basically already safe :D
04:33:19 <quicksilver> Aruro: exactly.
04:33:27 <ggVGc> quicksilver: still, it brought lambdas to the mainstream develoer
04:33:30 <ggVGc> which is a good thing
04:33:32 <ggVGc> I thikn
04:33:44 <julianleviston> ggVGc: I kind of agree with Evan, but he’s missing a bit of understanding there… and that’s the fact that things become popular because of a sweet spot of “just a little bit better” than what people are used to. He’s trying to understand how to get Elm to be mainstream popular… and kind of sell Haskell to the masses… but I really truly feel he’s missing something.
04:33:58 <quicksilver> things like Functor and Traversal and Lens and so on are genuinely interesting, enlightening and *useful* concepts
04:34:07 <quicksilver> they are hard to understand (for most people, in my experience)
04:34:09 <ggVGc> julianleviston: yep, sure, but he's on a good path
04:34:11 <quicksilver> and when you understand them
04:34:11 <ggVGc> I think
04:34:14 <quicksilver> they actually help you program!
04:34:21 <quicksilver> it's not just for fun or because we enjoy theory
04:34:22 <SX> quicksilver: erm, make a function with implementation specific fields (sockets, threads etc) and functions to work on them, then combine them in MyClient API and data.
04:34:32 <quicksilver> SX: yes
04:34:33 <SX> And return this MyClient
04:34:34 <ggVGc> quicksilver: right, but there will be a way to bring that understanding to people in a much easier way than what we can imagine right now
04:34:38 <ggVGc> we just need to figure it out
04:34:48 <SX> The right term for this?
04:34:57 <quicksilver> SX: It may have to be (MyClient s) where s is some varying type which holds some of those internal details
04:35:00 <quicksilver> or it may not
04:35:04 <quicksilver> depends on... details
04:35:11 <ggVGc> ^ story of life
04:35:19 <julianleviston> ggVGc: there’s a lot of things we can do to bring programming to the masses. Have you seen Brett Victor’s stuff?
04:35:28 <ggVGc> julianleviston: yeah, he's amazing really
04:35:30 <SX> Then I can't make a list containing clients with different s, no?
04:35:37 <ggVGc> I think he's truly one of the geniouses of our time
04:35:50 <julianleviston> ggVGc: I’d hesitate to put people on pedestals. You’re only putting yourself down.
04:35:57 <kallisti> I'm honestly not sure "the masses" want programming brought to them. :P
04:36:01 <quicksilver> ggVGc: yes I agree to that. 500 years of mathematical developments has shown conclusively there are always other ways to explain things you just haven't seen yet.
04:36:04 <julianleviston> ggVGc: he’s just a guy who’s good at communicating some ideas.
04:36:24 <quicksilver> SX: well you can, with a wrapper. Or maybe you hide that wrapper inside MyClient and the 's' doesn't leak out.
04:36:31 <quicksilver> different approaches exist.
04:36:44 <ggVGc> julianleviston: well, I'm not saying I can't also do great things, or you or anyone. But he's done a lot of amazing stuff
04:36:57 <SX> quicksilver: what do you mean?
04:37:44 <quicksilver> the point is that typeclasses are very nearly a specification of a record (often of higher order functions but not exclusively), plus a finite number of 'instances', plus a 'hook' to enable the type-checker to choose a particular instance based on the result of type inference
04:37:59 <quicksilver> that's particularly convenient when you want to overload something to work at multiple types
04:38:09 <quicksilver> but it's not a particularly general purpose abstraction
04:38:20 <quicksilver> better to roll it back and look at the basic power of the language underneath
04:38:32 <quicksilver> SX: existential types, is what I meant, about hiding in a wrapper
04:38:55 <julianleviston> ggVGc:  curiosity - since when has JS had lambdas?
04:38:58 <SX> quicksilver: ok, will look at that, thanks!
04:38:58 <ggVGc> quicksilver: I've just converted my team(JS work) from using prototypes and 'this' to relying on closures mainly. And they had a hard time grasping it at first, since they never fully understood what closures and lambdas in JS were actually doing theoretically. But the fact is they've been using it in their work for years(every time you register an event listener with an anonymous function). The same way we
04:39:04 <ggVGc>  can get people using good functional techniques without really understanding them fundamentally initially, and still give them the benefits of it
04:39:08 <julianleviston> ggVGc: or are you not meaning pure function when you say lambda?
04:39:17 <kallisti> you can also avoid existential types and lots of type parameters when using typeclasses, which is something "interface" records will tend to accumulate.
04:39:18 <ggVGc> julianleviston: maybe I'm using the wrong terms. But anonymous functions with closures are what I meant
04:39:21 <quicksilver> JS has always had lambdas
04:39:24 <ggVGc> o, not pure
04:39:28 <ggVGc> no*
04:39:31 <julianleviston> ok
04:39:31 <quicksilver> function(x) { return x+1; }
04:39:38 <quicksilver> mind you, so has perl
04:39:41 <julianleviston> quicksilver:  yes, but it’s not a pure function is it...
04:39:45 <quicksilver> no it isn't 
04:39:48 <julianleviston> quicksilver:  it’s a procedure still
04:39:48 <quicksilver> but it's still a lambda
04:39:50 <ptd> I reckon if you have an object being manipulated by some functions, you want a typeclass. If there is not a natural object, you don't want a typeclass.
04:39:59 <quicksilver> impure lambda calculus is a thing
04:40:07 <julianleviston> quicksilver:  ok.
04:40:09 <quicksilver> just look at ML
04:40:18 <quicksilver> which is a much more popular function language than haskell :)
04:40:21 <quicksilver> all its lambdas are impure
04:40:23 <julianleviston> quicksilver: just needed my nomnclature tightened up
04:40:25 <quicksilver> or lisp, of course
04:40:32 <ggVGc> maybe we are all impure lambdas in a web of function applications
04:40:34 <kallisti> ha, using the phrase "pure function" in the context of javascript programming.
04:40:39 <quicksilver> hey, I'm pure
04:40:42 <kallisti> only in #haskell
04:41:12 <quicksilver> kallisti: not only in #haskell - http://eliperelman.com/fn.js/
04:41:29 <ggVGc> quicksilver: the bottom line of what Evan is arguing with Elm, which I agree with a lot, is that we don't necessarily need to know the details and thory under what we're doing to benefit from it. But we'll obviously benefit more when we start learning it.
04:41:39 <ggVGc> so we need to bring the functional usefulness without the baggage, initially
04:41:45 <ggVGc> with the option of learning more
04:41:50 <ggVGc> Haskell is not doing this well
04:41:56 <quicksilver> yes.
04:42:17 <ggVGc> anyway, it'll probably be all good, just about time for us to die
04:42:20 <quicksilver> people quite happily use monads, functors, and lenses without knowing category theory though.
04:42:42 <ggVGc> quicksilver: yeah, but wouldn't it be great if they could use pure FP with monads without knowing the term monad?
04:42:46 <julianleviston> ggVGc: whoever said you needed to know the theory?
04:43:12 <julianleviston> ggVGc: do you want to call a monad something else?
04:43:18 <ggVGc> anyone who's tried learning haskell
04:43:18 <ggVGc> I think
04:43:26 <kallisti> the only thing separating monads, functors, and lenses from other programming concepts is that they have funny names (but they're really not that funny sounding if you consider all the funny sounding things the average programming works with)
04:43:44 <ptd> lens is a good example of an abstraction that you don't need to fully understand to use (If you want to interpret the error messages however).
04:44:01 <ggVGc> julianleviston: sure, why not initially. Humans enjoy working with relatable similarities before they learn the exact definitions
04:44:12 <ggVGc> I might call an oval a ball, before I learn what an oval is
04:44:22 <kallisti> I really don't know very much at all about what a "monad" is in the context of category theory, but I know exactly how it works when I need to write Haskell code that does something useful.
04:44:41 <julianleviston> ggVGc: I’ve heard this argument before… but I really don’t think “callback” is a good description of a monadic context.
04:44:42 <kallisti> it's not the language bringing this baggage you speak of, it's the people trying to explain the concepts.
04:44:49 <ggVGc> yeha, I don't know
04:44:57 <ggVGc> it's a fairly hard psychological problem  think
04:45:01 <julianleviston> ggVGc: no it’s not.
04:45:08 <ggVGc> alright
04:45:12 <julianleviston> ggVGc: it’s that haksell has different things than other languages in it.
04:45:33 <ggVGc> sure, and those things can be presented in many different ways
04:45:40 <julianleviston> ggVGc: you can dress it up how you like… and you can not explain it, but that just ends people up in a context where they can’t ask questions because they don’t have names for things
04:45:57 <quicksilver> ptd: I find that, although I have a reasonable grasp of the theory underlying it, I still don't understand lens error messages :)
04:46:14 <quicksilver> ptd: ...or at least, that a detailed examination of the error message is not the quickest way to solve the error, anyway
04:46:32 <julianleviston> ggVGc: I think you should NOT shy away from understaing what things are… calling a monad a “boxed computation” or calling the pipes library “a functional conveyer belt” are kinda what you’re talking about… but I think it actually hinders understanding a lot of the time.
04:46:56 <quicksilver> the problem comes when you find something which unifies a lot of different ideas
04:47:09 <quicksilver> and it turns out that any simple choice of name ends up being misleading
04:47:10 <ggVGc> julianleviston: sure, it hinders understanding, making it slower. But it also makes you produce maybe 30% better stuff without any personal additional effort
04:47:21 <julianleviston> quicksilver:  yes. abstraction is difficult. Full stop!
04:47:22 <ggVGc> and to reach the other 50% benefit you have to learn for real
04:47:28 <julianleviston> ggVGc: intense disagree.
04:47:33 <quicksilver> I'm pretty sure you could call 'Monoid' 'Appendable' or 'Connectable' or something
04:47:36 <julianleviston> ggVGc: you end up in a mess, and frustrated.
04:47:38 <quicksilver> and that would be absolutely fine
04:47:46 <quicksilver> you could consider calling Functor 'Container'
04:47:53 <quicksilver> and that seems nice, but loads of functors aren't containers.
04:47:56 <julianleviston> quicksilver: yeah, then people would not recognise a monoid where soemthing was a monoid in all cases.
04:47:59 <ggVGc> well, JS programmers everywhere are using callbacks with closures, without actually understanding closures
04:48:04 <ggVGc> and it's helping them anyway
04:48:08 <Aruro> gosh just 100h small course in algebra will solve every ggVGc problems.
04:48:11 <quicksilver> and as for names for Monad .. well people have spent 20 years trying to think of them
04:48:21 <quicksilver> and I have not yet seen a convincing one
04:48:31 <quicksilver> although FWIW I think the name 'effect' is quite reasonable
04:48:37 <ggVGc> Aune: try to convince the average programmer to take 100h algebra in the middle of their work and family lifes
04:48:42 <quicksilver> for the things that applicatives and monads both do.
04:49:02 <kallisti> "Mappable" is probably better for "Functor", since "Container" would associate it with a general-purpose collection interface
04:49:02 <julianleviston> ggVGc: the thing that I don’t get is… why is this important?
04:49:17 <quicksilver> kallisti: Mappable is fine but it is almost as abstract as Functor
04:49:28 <ggVGc> because having everyone use better techniques overall makes our technology better
04:49:40 <Aruro> ggVGc: 100h course in algebra is 1 day of clear head thinking. Problem is head clarity if you have kids, that is true.
04:49:41 <julianleviston> ggVGc: intense disagree
04:49:41 <ggVGc> and brings people closer to learning more eventually
04:49:41 <quicksilver> kallisti: I suppose maybe the word map is in slightly more common parlance
04:49:56 <quicksilver> EffectfulComputation
04:49:57 <kallisti> quicksilver: true. it's just the fact that "map" is a function that is pretty commonly encountered now in many languages.
04:50:05 <quicksilver> kallisti: yeah, that helps.
04:50:09 <kallisti> whereas a thing called a Functor isn't really all that common.
04:50:23 <quicksilver> kallisti: and also 'map' is pretty easy to understand by example to most programmers from another background
04:50:27 <ggVGc> well, we could also argue that we want an elitist work force, which is also a fair argument I think
04:50:36 <ggVGc> like, for example in nuclear power
04:50:44 <ggVGc> we could have that in programming too
04:50:50 <kallisti> Honestly I feel really bad for anyone who gets paid to write modern javascript code and doesn't know what a closure is or how it works.
04:50:51 <ggVGc> but I don't think that's reasonable currently
04:50:52 <Aruro> ggVGc: yep, we want mathematicians work force
04:51:15 <frerich> I think you're venturing into #haskell-blah terrain here.
04:51:16 <julianleviston> ggVGc you’re assuming making things available to people will make them smarter.
04:51:21 <julianleviston> yeah
04:51:22 <ggVGc> Aruro: problem is that economy drives it, and you can't just decide "we want this"
04:51:24 <julianleviston> fractalcat: sorry
04:51:30 <julianleviston> frerich: sorry.
04:51:42 <julianleviston> ggVGc: this is offtopic. Let’s move to haskell-blah
04:51:43 <quicksilver> kallisti: I don't think you need to know what a closure is, precisely.
04:51:49 <ggVGc> heh, I need to work anyway
04:51:50 <ggVGc> sorry
04:51:51 <yogeshsajanikar> take 5 [1..]
04:52:03 <quicksilver> kallisti: you just need to know that "functions you write in an inner scope can still 'see' variables from outside that scope"
04:52:03 <kallisti> > take 5 [1..]
04:52:05 <lambdabot>  [1,2,3,4,5]
04:52:18 <quicksilver> kallisti: and you need to know an extremely regretabble rule about for loops not introducing a fresh scope :P
04:52:21 <yogeshsajanikar> @hoogle [a] -> [a]
04:52:24 <lambdabot> Prelude cycle :: [a] -> [a]
04:52:24 <lambdabot> Data.List cycle :: [a] -> [a]
04:52:24 <lambdabot> Prelude init :: [a] -> [a]
04:52:47 <Aune> ggVGc, what?
04:52:49 <ggVGc> quicksilver: JS scoping :(((((((((((((
04:52:52 <kallisti> quicksilver: IIRC no curly bracket block introduces a real lexical scope, only functions
04:52:53 <ggVGc> Aune: sorry, that was for Aruro 
04:52:56 <ggVGc> too many similar nicks
04:52:58 <Aruro> yep
04:53:15 <quicksilver> kallisti: correct. You have to nest everything in fresh function(){}() if you want nice scoping
04:53:17 <yogeshsajanikar> @hoogle (a -> b) -> f b -> f a
04:53:17 <lambdabot> Data.ByteString.Builder.Prim (>$<) :: Contravariant f => (b -> a) -> f a -> f b
04:53:17 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
04:53:17 <lambdabot> Data.IntMap.Strict adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
04:53:48 <Aruro> he (ggVGc) just wanted to talk with comrades about philosophy, very noble desire.
04:53:51 <yogeshsajanikar> :i Contravariant
04:54:09 <kallisti> as the list of nicks in a channel approachs infinity, and thus becomes closer to an enumeration of all possible strings in an alphabet, tab completion becomes more and more useless. :)
04:54:10 <Aruro> :it does not work here
04:54:17 <Aruro> :i , its for GHCI
04:54:33 <indiagreen> are there any good examples of using lookAhead while parsing? (need them for a tutorial)
04:54:50 <yogeshsajanikar> @hoogle Contravariant
04:54:50 <lambdabot> package contravariant
04:54:52 <kallisti> > [0..] >>= (`replicateM` "abc")
04:54:54 <lambdabot>  ["","a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aa...
04:54:55 <indiagreen> not lookahead-as-a-principle, Parsec's lookAhead specifically
04:55:32 <quicksilver> indiagreen: no, lookahead is evil and, therefore, no good examples exist? :)
04:55:58 <indiagreen> hm, why is it evil?
04:56:06 <quicksilver> I don't know.
04:56:06 <ggVGc> has anyone here used Haskell in an "Erlang way", i.e as a supervisor for other processes that might error/die/whatever and need to be logged and seamlessly restarted
04:56:21 <quicksilver> but I always write my parsers not too need it
04:56:22 <yogeshsajanikar> How about cloud haskell
04:56:31 <quicksilver> get the tokenisation right and the grammar right
04:56:35 <quicksilver> and you don't need lookahead
04:56:42 <quicksilver> I am trying to think of an example for you tho...
04:56:49 <ggVGc> yogeshsajanikar: ah, that looks intersting. thanks
04:57:35 <ggVGc> yogeshsajanikar: my idea is to use haskell for a lot of things I currently use bash for, and the main thing of bash is easy process management in my opinion
04:58:03 <ggVGc> and extending it to be a supervisor would be nice
04:58:07 <quicksilver> indiagreen: it is sometimes useful for manyTill
04:58:07 <yogeshsajanikar> @faq is Perdicate a functor
04:58:07 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
04:58:22 <quicksilver> indiagreen: when you want to stop when you see 'Foo', but you still want to parse Foo separately
04:58:39 <yogeshsajanikar> @faq Is Predicate a functor
04:58:39 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
04:58:53 <yogeshsajanikar> @faq Is Predicate a functor?
04:58:53 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
04:58:55 <quicksilver> indiagreen: although that's partly just because manyTill is silly and doesn't return anything about the ending type
04:59:11 <quicksilver> yogeshsajanikar: by predicate do you mean "a -> Bool" ?
05:00:21 <yogeshsajanikar> quicksilver: yes
05:00:34 <quicksilver> yogeshsajanikar: data Pred a = Pred (a -> Bool) 
05:00:35 <yogeshsajanikar> Was looking at example of "Contravariant" functor
05:00:44 <quicksilver> yogeshsajanikar: then Pred is, as you suggest, not a Functor
05:00:50 <kallisti> ggVGc: Haskell has excellent concurrency features. Cloud Haskell is mostly trying to fill in the distributed computing parts that Haskell lacks when compared to Erlang
05:00:51 <quicksilver> but it is a Contravariant
05:01:09 <ggVGc> kallisti: yeah, I realised that. So not what I'm looking for(yet)
05:01:17 <quicksilver> kallisti: haskell does not have much in the way of process management or resource limit functionality though
05:01:26 <kallisti> if you're looking for really convenient process handling stuff that emulates bash, there's shelly
05:01:29 <kallisti> @hoogle shelly
05:01:29 <lambdabot> package shelly
05:01:29 <lambdabot> package shelly-extra
05:01:40 <quicksilver> lambdabot does it by running the code in a separate process
05:01:45 <ggVGc> kallisti: what is the best library currently for dealing with the actual external processes currently? process-streaming?
05:01:48 <quicksilver> and using ordinary unix rlimits on the subprocess
05:02:04 <kallisti> uh... process? :P
05:02:15 <kallisti> I mean, that's what I would use.
05:02:22 <kallisti> call me old-fashioned
05:02:24 <ggVGc> I don't really want to emulate bash. I just want a better tool for hooking togetger processes, and feel haskell could be that tool
05:02:30 <ggVGc> alright
05:03:03 <kallisti> I'm not hip to the newfandled libraries the kids are using these days.
05:03:17 <ggVGc> probably a good stance
05:03:25 <quicksilver> there are traps lurking in IO with subprocesses
05:03:30 <ggVGc> right
05:03:32 <quicksilver> traps to do with buffering and accidentally deadlocking
05:03:36 <Aruro> ggVGc: did you look at turtle? or im missing something?
05:03:38 <quicksilver> not haskell specific, that :)
05:03:42 <quicksilver> but something to remember.
05:04:10 <ggVGc> Aruro: I've looked at it in the past but for some reason didn't feel it suited me. I'll take another look
05:04:41 <Aruro> ggVGc: there are alternatives, author mentions them on hackage page, i think
05:06:11 <ggVGc> I have this theoretical idea about a shell language where processes and procedures are synonymous, and procedures don't take values and return, but rather take a set of streams to work with
05:06:34 <yogeshsajanikar> trying to use ByteString, similar to handle over IO. Is STM is the only way. Like a memory file. 
05:06:35 <ggVGc> I think it's mostly a syntax idea, but I think it's what I would want for this kind of modular work
05:07:03 <ggVGc> procedures being "functions" in the language, and processes being external programs
05:08:14 <yogeshsajanikar> @hoogle STM ByteString
05:08:14 <lambdabot> Did you mean: :: STM ByteString
05:08:15 <lambdabot> No results found
05:08:36 <yogeshsajanikar> @hoogle :: STM ByteString
05:08:36 <lambdabot> GHC.Conc.Sync retry :: STM a
05:08:36 <lambdabot> GHC.Conc retry :: STM a
05:08:36 <lambdabot> Control.Monad.STM retry :: STM a
05:09:17 <quicksilver> yogeshsajanikar: I don't see any connection at all between STM and using a ByteString like a file?
05:10:12 <yogeshsajanikar> quicksilver: Trying to implement thrift Transport for Wai Request
05:10:23 <quicksilver> to use a ByteString like a file you really just need to store and update a counter about how far you are down it
05:10:58 * frerich wrote this web app which serves statistics extracted frmo some SQL server. Since the queries are somewhat slow (and plentiful), he just implemented a lame 'cache' in which the web page actually renders the contents of some 'STM Statistics' value which is populated every hour by a separate thread which runs the queries periodically.
05:11:07 <frerich> Somehow it feels like cheating.
05:11:58 <quicksilver> caching is a fairly standard approach frerich 
05:12:16 <quicksilver> if the SQL server doesn't give you any hooks into a quick way of fetching incremental stats updates
05:12:20 <quicksilver> I don't see what else you could have done
05:12:34 <julianleviston> quicksilver:  memchached?
05:12:40 <frerich> quicksilver: Oh, sure - I mean, it was so easy to just have a separate thread which periodically fetches data and then (safely!) use that for the UI, it felt like cheating. :-)
05:12:45 <yogeshsajanikar> quicksilver: This has to be with side-effects. So ByteString with a counter would not help, if it has to be used just like a Handle.
05:13:26 <quicksilver> frerich: oh right :)
05:13:52 <quicksilver> yogeshsajanikar: well you can just embed the counter into IO to copy the Handle interface exactly.
05:14:03 <quicksilver> yogeshsajanikar: I'm not familiar with 'thrift' or Wai
05:14:24 <julianleviston> quicksilver: WAI is what yesod and Scotty are built on, right?
05:15:10 <quicksilver> so google tells me, yes
05:15:16 <yogeshsajanikar> quicksilver: yes. Trying to write a Wai to work with Thrift Transport protocol
05:15:22 <quicksilver> but I don't know the apis well enough to answer yogeshsajanikar's question.
05:15:42 <obadz> Can I call Debug.trace.traceStack from ghci and expect to see a stack trace?
05:15:57 <obadz> (I've build libraries with profiling)
05:16:19 <obadz> (and run cabal configure --enable-executable-profiling --enable-library-profiling --ghc-options="-fprof-auto")
05:16:40 <yogeshsajanikar> @hoogle Thrift.Transport
05:16:40 <lambdabot> package network-transport
05:16:41 <lambdabot> package network-transport-amqp
05:16:41 <lambdabot> package network-transport-inmemory
05:20:32 <obadz> I'm trying :set -fbreak-on-exception / :trace someValue / <hits exception> / :back and getting "no more logged breakpoints"
05:21:27 <quicksilver> I don't know, obadz, but possibly it only works in compiled code?
05:22:09 <obadz> actually https://mail.haskell.org/pipermail/beginners/2013-September/012687.html seems to say that I must do ":l blah.hs"
05:22:25 <obadz> I was using C-c-l in emacs and apparently those are not equivalent
05:24:18 <quicksilver> obadz: :trace and Debug.trace.traceStack are different
05:24:23 <quicksilver> at least I thought they were
05:24:33 <obadz> am not saying otherwise
05:24:37 <quicksilver> the former is a functionality which only exists in interpreted code, as it depends on ghci's internal representation
05:24:38 <obadz> just trying to get to the source of my exception
05:24:46 <quicksilver> the latter is something which only exists if you compile with profiling
05:24:51 <quicksilver> and (I thnk but I'm not sure) only in compiled code
05:24:58 <quicksilver> I have never used either one...
05:29:09 <frerich> The annoying thing with web apps serving stats extracted from some SQL database is that as I go on, I optimize the SQL more and more and at some point the Haskell code actually doesn't *do* anything anymore. It's all SQL doing the heavy lifting and JavaScript.
05:29:51 <quicksilver> the haskell code which does the most does nothing at alll, frerich 
05:30:04 <frerich> Oh you and your Zen again! :-)
05:30:20 <quicksilver> we are both always students.
05:30:56 <frerich> but maybe this Haskell program does have buddha nature.
05:32:40 <paldepind> I have a program. It works fine. Then I refactor some lines into a function. Now GHC tells me that a type variable is ambiguous and I have to add a type annotation. I don't quite understand why moving something to a function makes types harder to infer?
05:35:59 <quicksilver> paldepind: well no one else can tell you unless you show us at least some part of the code
05:36:12 <quicksilver> it maye be the monomorphism restriction though
05:36:35 <kallisti> paldepind:  http://lpaste.net/143120
05:37:05 <paldepind> quicksilver, it's related to type classes. I can certainly post code. I just thought there might be some general things to say about it.
05:38:56 <lpaste> paldepind pasted “Ambiguous type variable” at http://lpaste.net/143121
05:38:59 <kallisti> paldepind: generally speaking, the way you call a function does not influence its inferred type
05:39:35 <kallisti> only its result expression and the way that expression uses the function's arguments affect inference
05:39:53 <paldepind> I'm sorry the code example is a bit long. I created the "createCounterAction" function and then was forced to give it a type annotation.
05:40:17 <paldepind> Previously it appeared directly where it was used and no annotations was necessary.
05:41:08 <quicksilver> paldepind: looks like it's because of RankNTypes
05:41:08 <kallisti> when you move the expression into its own function, the type inference will make it as general as possible. when it was part of the original expression its type was less polymorphic
05:41:22 <paldepind> I've run into similar things before where I did a refactor in afterwards received an error about ambiguous types. So clearly there's something I'm no getting.
05:42:05 <paldepind> kallisti, that makes sense. Before the refactor it only had to infer a function that would work in one particular case.
05:42:35 <paldepind> I still don't really understand why it just can't infer a less polymorphic type and go with that?
05:43:05 <paldepind> In general I find it hard to predict when type annotations are necessary.
05:43:51 <quicksilver> "normal haskell" has quite strong guarantees
05:44:02 <quicksilver> that when you place code in a more general context
05:44:08 <quicksilver> the more general type it infers will be fine
05:44:12 <kallisti> in ordinary haskell code (no advanced type extensions being used), you mostly want to add annotations to your top-level functions, and to functions that return polymorphic types that aren't being directly used by anything else
05:44:12 <quicksilver> it will still work with the specific
05:44:36 <quicksilver> paldepind: try removing the type annotation
05:44:43 <kallisti> :t fromString
05:44:45 <lambdabot> IsString a => String -> a
05:44:52 <quicksilver> paldepind: and putting {-# LANGUAGE NoMonoMorphismRestriction #-}
05:44:55 <quicksilver> paldepind: at the top
05:45:20 <quicksilver> I thought your problem was RankNTypes but now I don't think that. I don't think AppAction is Rank-N.
05:45:29 <quicksilver> took me a while to chase down all the type synonyms tho
05:46:00 <deception1> http://groups.inf.ed.ac.uk/links/formlets/ this link has been given in this page https://hackage.haskell.org/package/digestive-functors and was dead. is there any live links to replace that
05:47:39 <quicksilver> actually it doesn't seem to have a type class context either, so I don't see why monomorphism would apply
05:47:47 <quicksilver> I think I need to see the error message you get
05:49:44 <kallisti> it likely has something to do with a type extension being used
05:49:50 <paldepind> quicksilver, enabling that extension removes the error about ambiguity. I still get another error though.
05:50:19 <kallisti> I've seen a few people asking about ambiguous type inference when working with yesod/persistent stuff
05:54:01 <kallisti> I think it needs SqlBackend explicitly mentioned in the type somewhere for the runDb call perhaps?
05:54:53 <paldepind> kallisti, that sounds right. It does mention SqlBackend in the error.
05:54:54 <quicksilver> paldepind: can you annotate that paste with the exact error?
05:55:53 <lpaste> paldepind annotated “Ambiguous type variable” with “Ambiguous type variable (annotation)” at http://lpaste.net/143121#a143122
05:56:10 <paldepind> Yes, indeed.
05:56:15 <Copperis> > map (\l -> map (\e -> toUpper e) l) ["one", "two"]
05:56:17 <lambdabot>  ["ONE","TWO"]
05:56:59 <paldepind> My main problem is that I feel like I don't understand what's going on fully. To me there's a lot of quite complicated types.
05:57:09 <Copperis> is there a better one-liner to do that?
05:57:12 <kallisti> > map (map toUpper) ["one", "two"]
05:57:13 <lambdabot>  ["ONE","TWO"]
05:58:34 <kallisti> let f = map . map toUpper in f ["one", "two"]
05:58:42 <kallisti> > let f = map . map toUpper in f ["one", "two"]
05:58:43 <lambdabot>      Couldn't match type ‘[Char]’ with ‘a1 -> b1’
05:58:44 <lambdabot>      Expected type: [Char] -> a1 -> b1
05:58:44 <lambdabot>        Actual type: [Char] -> [Char]
05:58:56 <quicksilver> paldepind: and that's literally the same code as you pasted just with that one-line annotatation commented out?
05:59:12 <paldepind> Copperis, \e -> toUpper e is the same as just toUpper. See: https://wiki.haskell.org/Eta_conversion
05:59:13 <kallisti> oh right :P
05:59:37 <kallisti> > let f = map (map toUpper) in f ["one", "two"]
05:59:38 <lambdabot>  ["ONE","TWO"]
05:59:40 <Copperis> paldepind, ok, I'm trying to grasp kallisti's first example. 
06:00:18 <Copperis> right :D
06:00:28 <Copperis> thank you both
06:00:31 <kallisti> Copperis: yeah don't pay attention to my first example it was just a basic illustration of how a function definition's inferred type isn't affected by any other function's calling it.
06:00:33 <paldepind> quicksilver, yes. There's more in the file but I think the relevant code is included. I make the error appear just by commenting out the type declaration.
06:00:53 <quicksilver> paldepind: nod
06:01:02 <kallisti> Copperis: bleh sorry I thought you were paldepind. nevermind :P
06:01:49 <kallisti> Copperis: in the same way that (\e -> toUpper e) is just toUpper:   (\l -> map toUpper l) is just map toUpper
06:02:00 <quicksilver> paldepind: well I am sad to admit it btu I cannot put my finger on the problem. There must be a use of an 'advanced' type feature somewhere in the maze of type synonyms within SpockActionCtx
06:02:10 <quicksilver> paldepind: and that feature makes tyep inference do the wrong thing
06:02:12 <Copperis> kallisti, yup, now I see that
06:02:21 <quicksilver> but it is such a maze I cannot put my finger on it.
06:02:45 <paldepind> Well, at least I'm not the only one who think it's a maze.
06:04:11 <hodapp> boo, hackage seems to be down
06:04:16 <hodapp> nevermind
06:04:24 <hodapp> clearly I just had to bitch about it on IRC to get it back up
06:05:21 <kallisti> yesod persist does a lot of type magic, so it probably does need some explicit types to help it resolve types
06:06:06 <kallisti> unless I'm working a small quick script, my general rule of thumb is to always include explicit type annotations for top-level bindings.
06:06:19 <Ferdirand> is there a way to raise a warning from pure code ? something akin to error, but that would not kill execution ?
06:06:59 <kallisti> GHC has a WARNING pragma
06:07:19 * hackagebot pdf-toolbox-content 0.0.5.0 - A collection of tools for processing PDF files  https://hackage.haskell.org/package/pdf-toolbox-content-0.0.5.0 (YurasShumovich)
06:07:21 * hackagebot pdf-toolbox-document 0.0.7.0 - A collection of tools for processing PDF files.  https://hackage.haskell.org/package/pdf-toolbox-document-0.0.7.0 (YurasShumovich)
06:07:23 * hackagebot pdf-toolbox-viewer 0.0.5.0 - Simple pdf viewer  https://hackage.haskell.org/package/pdf-toolbox-viewer-0.0.5.0 (YurasShumovich)
06:07:23 <paldepind> kallisti, I usually do so as well. But with Spock I don't actually understand the types. So having the inferred is easier :(
06:07:40 <Ferdirand> kallisti: but that is compile-time, right ?
06:08:04 <quicksilver> Ferdirand: Debug.trace perhaps
06:08:08 <kallisti> Ferdirand: oh, right.
06:08:46 <kallisti> trace will print to stdout I believe. not sure what you would use for stderr
06:09:09 <kallisti> well, looking at the source of trace, it just uses unsafePerformIO so... guess that answers my question. :P
06:09:25 <quicksilver> paldepind: Expected type: hvect-0.3.0.0:Data.HVect.HVectElim '[] (ActionCtxT ctx (WebStateM SqlBackend ses AppState) ())
06:09:31 <Ferdirand> yeah the source of trace looks suitable, nice
06:09:35 <quicksilver> I think that's a clue as to where the problem is
06:09:59 <Ferdirand> i've been playing with Haskell for a couple of years but this will be my first legitimate unsafePerformIO use. Champagne!
06:10:06 <quicksilver> it's using HVect to peel off layers
06:10:12 <quicksilver> of a type
06:10:15 <quicksilver> and that's not inferrable
06:10:59 <quicksilver> I don't understand hvect so I can't give more details :/
06:11:19 <kallisti> paldepind: basically all of the type parameters are filling in details of the implementation. so SqlBackend is telling it to use SQL as the backend for the persistent store, for example. If you look at the docs for SqlBackend you'll see it's just a big record of various functions that get called during specific points in time.
06:11:23 <hanDerPeder> hey! is there a way to inspect the fields of a data type from the interpreter?
06:11:54 <kallisti> I believe :i does this? I haven't used it in a while though.
06:11:55 <hanDerPeder> coming from clojure and having to look everything up all the time really breaks my flow
06:12:30 <paldepind> quicksilver, kallisti, Hm. It makes sense but is quite tricky imo.
06:13:02 <kallisti> yeah :i will show you the definition of that type/typeclass/etc
06:13:16 <Copperis> "IO a" is already the result, only boxed in IO or is it some sort of "magic thingy" has yet to get the result and will get it only when I'll bind it with <- ?
06:13:22 <Big_G>  /list 
06:13:46 <hanDerPeder> kallisti: tried that, gives me this: http://lpaste.net/143123 what I want is the name of the record fields
06:14:17 <hanDerPeder> s/name/names
06:14:39 <kallisti> Copperis: technically speaking the only IO action that ever gets "executed" is the one bound to main. But do syntax composes multiple IO actions into larger ones.
06:15:12 <kallisti> hanDerPeder: hm. honestly surprised it doesn't show record fields. that's something that should be added to ghci I think
06:15:22 <quicksilver> hanDerPeder: :i XConfig
06:15:37 <quicksilver> :i on a variable tells you the type
06:15:44 <quicksilver> :i on a type shows ou the type's definition
06:15:44 <kallisti> hanDerPeder: hm what happens if you do :i XConfig{..}
06:15:57 <hanDerPeder> quicksilver: I see, thanks, exactly what I was looking for
06:16:01 <quicksilver> Copperis: it's more of a magic thingy.
06:16:11 <quicksilver> Copperis: in particular you can execute it more than once, or not at all.
06:16:26 <Copperis> this is the concrete example: http://lpaste.net/143124 on line 4 the "IO a" is bound to result, then the handle is closed, then it is repackaged to IO again
06:16:53 <quicksilver> Copperis: yes you have the option to run "f handle" multiple times
06:16:56 <quicksilver> Copperis: (or no times)
06:17:08 <quicksilver> Copperis: and it presumably returns different answers each time you run it
06:17:17 <quicksilver> as well as 'having an effect' (e.g. moving file pointers around)
06:17:52 <lpaste> kallisti revised “No title”: “No title” at http://lpaste.net/143124
06:17:58 <kallisti> Copperis: ^
06:18:04 <Copperis> quicksilver, ok, so running it and getting the "IO a" will contain the answer, right? At this point it IO is a package and will not do anymore logic when I bind it with <- ?
06:18:25 <kallisti> Copperis: each of those are unique handles to the same file.
06:18:29 <Copperis> coul've worded it better
06:18:34 <Copperis> typos :/
06:18:45 <SX> anyone using System.Socket instead of Network.Socket?
06:18:48 <Stratege> one way to think of IO is as a description of things to be executed in the execution stage.
06:18:49 <kallisti> Copperis: it will do the logic again if you bind it again.
06:19:24 <quicksilver> Copperis: running and getting an "a" gives you an answer
06:19:29 <SX> Is it worth switching? Interface there is way better than Network.Socket at first glance
06:19:30 <quicksilver> Copperis: not an IO a
06:19:47 <quicksilver> Copperis: consider "getChar"
06:19:56 <quicksilver> Copperis: getChar has the type 'IO Char'
06:20:10 <Copperis> yup
06:20:11 <quicksilver> Copperis: each time you run it you get a different char (well that depends what the user types, but you see the point)
06:20:36 <Copperis> yes
06:21:11 <kallisti> Copperis: The "IO a" is a description of how to get an "a"; when you use bind, you're actually performing the action that "IO a" described, to receive a value of type "a".  In that example the variable "handle" has type "Handle" whereas "openFile path mode" has type "IO Handle"
06:22:15 <quicksilver> and you can combine descriptions into longer descriptions.
06:22:43 <quicksilver> "do a <- getChar; b <- getChar; return (a,b)" is a description of how to get a (Char,Char) i.e. two chars
06:22:55 <quicksilver> simply putting that description in a program doesn't inherently run it
06:23:04 <quicksilver> you then choose how often to use it - or not to use it at all.
06:23:05 <Copperis> kallisti, in that case, do you see the point in repackaging the result in IO on line 6 in the example?
06:23:45 <kallisti> the "return result" part?
06:23:47 <Copperis> IMO that's misleading, because the handle is closed and that's not the same action
06:23:51 <Copperis> kallisti, yes
06:24:38 <kallisti> yeah there's no real reason to do that
06:24:42 <kallisti> it would be bad practice in reality
06:24:43 <Copperis> returning just "a" would be better IMO
06:25:06 <kallisti> if you don't have a sensible return value, the convention is to return ()
06:25:10 <kallisti> which is what hClose would return for example.
06:25:14 <kallisti> :t hClose
06:25:15 <lambdabot> Not in scope: ‘hClose’
06:25:31 <kallisti> hClose :: Handle -> IO ()
06:25:52 <kallisti> oh sorry
06:25:56 <kallisti> I misread the code
06:25:59 <kallisti> you're not returning the handle
06:26:16 <kallisti> you're returning the result of calling f on the handle, this happens BEFORE the handle is closed
06:26:30 <Copperis> no, it's an "IO a", but it is recreated from the binded value
06:26:41 <Copperis> and doesn't represent the original action
06:27:11 <kallisti> every line of do notation in this example has to have the type "IO something"
06:27:27 <kallisti> it's a constraint of how monads work, IO being one example of a monad.
06:27:47 <Copperis> oh, so return type "a", wouldn't even work? I'll try
06:28:01 <kallisti> no it would work
06:28:16 <kallisti> I mean, the example code has valid types
06:29:50 <Copperis> kallisti, returning a doesn't work for me http://lpaste.net/143127
06:30:13 <kallisti> right you can't just have "result" by itself on a line in do notation, because it doesn't have the right type
06:30:17 <kallisti> it has to be "IO a"
06:30:20 <kallisti> whereas result is just "a"
06:30:25 <kallisti> :t return
06:30:27 <lambdabot> Monad m => a -> m a
06:30:40 <kallisti> :t return :: a -> IO a
06:30:42 <lambdabot> a -> IO a
06:31:08 <kallisti> "return" wraps the "a" value back into IO
06:31:56 <kallisti> which is required for the do notation to typecheck properly  (the do notation is translated by the compiler into a series of function calls)
06:32:46 <Copperis> kallisti, but the need to wrap it is mostly to be able to return it from the do block? I don't see any other goal. Is there?
06:33:27 <Copperis> I don't understand Monads well yet, neither how the do block looks compiled
06:33:35 <kallisti> well, in the case of IO, the goal is to prevent computations that result from side-effects from escaping into pure code.
06:33:43 <kallisti> for other monads the goal can be different
06:34:06 <quicksilver> there is more than one way to think of this
06:34:19 <Copperis> kallisti, talking about that concrete example in line 6, calling "return result"
06:34:22 <quicksilver> from one perpsective there is no "goal" in requiring the wrapping
06:34:29 <quicksilver> it's just - that's what the types say.
06:34:37 <quicksilver> a do block in the IO monad has type IO a
06:34:46 <quicksilver> 'result' does not have type IO a
06:34:52 <quicksilver> so you can't use it (bare) there.
06:35:37 <JagaJaga> How can I send warnings myself from code?
06:35:44 <quicksilver> it desugars - just looking at that last part - into "hClose handle >> return result"
06:35:52 <quicksilver> "hClose handle >> result" would be a type error
06:35:58 <quicksilver> the type of >> does not permit that.
06:37:40 <Copperis> quicksilver, is it possible to make this function http://lpaste.net/143124 return only "a" with some syntax?
06:38:11 <kallisti> absolutely. we call it unsafePerformIO, and it will cause all sorts of weird inconsistent problems with your code. :)
06:38:16 <quicksilver> no, it is not, Copperis 
06:38:30 <quicksilver> do blocks are desugared into things built out of >> and >>=
06:38:41 <quicksilver> and >> and >>= are operators whose types always include the monad.
06:38:43 <quicksilver> :t (>>)
06:38:44 <lambdabot> Monad m => m a -> m b -> m b
06:38:46 <quicksilver> :t (>>=)
06:38:48 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:38:56 <quicksilver> in both cases it's 'm b' at the end
06:39:11 <quicksilver> so a do block will always desugar to something of type 'm b' (for some m and some b(
06:39:11 <kallisti> ah, right, in the do block, yes you still have to do the return
06:39:31 <Gurkenglas> You're supposed to take the things that want you to plug an a into them and make them accept an IO a
06:39:53 <kallisti> well, no
06:40:01 <quicksilver> there is a lot to think about here and I'm just waiting for Copperis to ask the questions he wants to ask
06:40:09 <quicksilver> in my experience it's hard to guess hte best way to explain this
06:40:15 <Gurkenglas> (Of course, that'll also make them produce an IO a, so IO contaminates everything that uses IO stuff indirectly. Such is IO.)
06:40:16 <quicksilver> easier to see what questions people wish to ask :)
06:40:33 <Copperis> quicksilver, you already answered, that it's not possible to make that function return just an "a". Thanks!
06:40:37 <quicksilver> :)
06:40:54 <Copperis> so the "do" block is also a function?
06:41:03 <quicksilver> well it's a value
06:41:13 <quicksilver> I wouldn't call it a function but you can if you like
06:41:23 <quicksilver> people use the word 'function' to mean different things
06:41:23 <kallisti> Gurkenglas: you only want to use IO as the return type of operations. Basically your code should mimic the signature of (>>=) in most cases. arguments to your functions should be non-monadic unless you want to manipulate the side-effects of that monad by using >>= multiple times (or conditional ignoring it) etc
06:41:42 <kallisti> Gurkenglas: so it doesn't REALLY contaminate all of your code. It would be silly to write all of your code like  f :: IO a -> IO b -> IO c
06:42:34 * hackagebot wavefront 0.4.0.1 - Wavefront OBJ loader  https://hackage.haskell.org/package/wavefront-0.4.0.1 (DimitriSabadie)
06:42:36 * hackagebot codex 0.3.0.10 - A ctags file generator for cabal project dependencies.  https://hackage.haskell.org/package/codex-0.3.0.10 (aloiscochard)
06:42:37 <Gurkenglas> Most top level definitions that dont directly do IO stuff dont get contaminated, but the code that plugs all the pieces of your code together will have to lift your top-level definitions somehow to be able to accept IO code
06:42:45 <Gurkenglas> *IO data
06:42:57 <Copperis> quicksilver, how is the do block a value? Does the "do" keyword desugar to anything?
06:43:11 <frerich> I think 'contaminated' has a terribly negative connotation. IO is what makes the world go round.
06:43:20 <camm1> Hey, how are you. Do you know what is the difference between Set and Seq? Which one give us a better performance?
06:43:29 <quicksilver> Copperis: 'do' itself is just the trigger to parse a certain kind of syntax
06:43:45 <jophish> camm1: they do quite different things
06:43:45 <quicksilver> Copperis: "do a;b" is exactly the same as "a >> b"
06:43:58 <alexv19> I'm reading Servant tutorial http://haskell-servant.github.io/tutorial/client.html . They have this line: `position :<|> hello :<|> marketing = client api (BaseUrl Http "localhost" 8081)`. What is going on here? Did they just defined 3 functions in one pattern?
06:44:13 <quicksilver> Copperis: so "do" tells the compiler to treat semicolons (or newlines) as meaning >>
06:44:19 <Copperis> quicksilver, oh, ok, makes sense
06:44:24 <kallisti> Copperis: additionally: do {x <- a; b}  desugars to a >>= (\x -> b)
06:44:27 <quicksilver> Copperis: but then it also has a rule for <-
06:44:31 <quicksilver> what kallisti just said
06:44:56 <Gurkenglas> > let (x : (y : (z : zs))) = [1..] in x + y + z -- alexv19
06:44:58 <lambdabot>  6
06:45:01 <jophish> Copperis: lambdabot has a @undo command for exploring this kind of thing
06:45:13 <jophish> @undo do {x <- a; b a}
06:45:13 <lambdabot> a >>= \ x -> b a
06:45:22 <Copperis> noice
06:45:23 <lyxia> alexv19: yes you can do pattern matching in definitions
06:45:30 <Hjulle> Does anyone recognize this function? ($(,)) . ((.).(.))
06:45:42 <kallisti> @undo do {a; x <- b; c}
06:45:42 <lambdabot> a >> b >>= \ x -> c
06:46:02 <kallisti> @undo do {a; x <- b; c; d; y <- e}
06:46:02 <lambdabot> <unknown>.hs: 1: 29:Parse error: Last statement in a do-block must be an expression
06:46:12 <kallisti> @undo do {a; x <- b; c; d; y <- e; return y}
06:46:13 <lambdabot> a >> b >>= \ x -> c >> d >> e >>= \ y -> return y
06:46:26 <kallisti> return y is completely redundant there btw
06:46:27 <frerich> Hjulle: curry!
06:46:31 <Ferdirand> @type ($(,)) . ((.).(.))
06:46:32 <lambdabot> ((a, b) -> c) -> a -> b -> c
06:46:40 <frerich> Hjulle: but I cheated and checked the type.
06:47:01 <kallisti> Copperis: in a lot of ways the do notation kind of obscures what's actually going on. That's why it can seem so confusing at first.
06:47:01 <Copperis> kallisti, it does return a value, so how it is redundant?
06:47:14 <kallisti> Copperis: because you could just write   e on a line by itself to mean the same thing
06:47:24 <kallisti> do {y <- e; return y}  is the same as "e"
06:47:31 <Copperis> oh, ok
06:48:00 <Copperis> @undo do {a; x <- b; c; d; y <- e; e}
06:48:00 <lambdabot> a >> b >>= \ x -> c >> d >> e >>= \ y -> e
06:48:07 <alexv19> Gurkenglas: oh wow, I didn't know you can do this at top level.
06:48:23 <quicksilver> alexv19: it's not very common in general.
06:48:34 <quicksilver> alexv19: you can write (a,b) = (4,5) at the top level if you wish
06:48:37 <kallisti> Copper: but as you can see the >>= and >> syntax gets hairy pretty fast, which is why do notation is nice for larger computations.
06:48:39 <quicksilver> but people do not often to do that :)
06:48:39 <Hjulle> frerich: Yes, It's quite obvious then. :) You can probably guess this one even without looking at the type: ($ snd) . ($ fst) . liftA2
06:48:46 <hanDerPeder> is there something similar to lambdabots @undo in ghci?
06:48:47 <kallisti> Copperis: ^
06:49:11 <frerich> Hjulle: This might be an amusing game for some Haskell meetup.
06:49:23 <Hjulle> Haha :)
06:49:49 <Copperis> kallisti, yup, got it. Will have to look into it some time
06:50:04 <SX> So nobody tried socket package here?
06:50:17 <SX> hackage.haskell.org/package/socket
06:50:22 <tobiasBora> Hello !
06:50:29 <SX> https://hackage.haskell.org/package/socket
06:51:07 <kallisti> @undo do {handle <- openFile path mode; result <- f handle; hClose handle; return result}
06:51:07 <lambdabot> openFile path mode >>= \ handle -> f handle >>= \ result -> hClose handle >> return result
06:51:53 <quicksilver> hanDerPeder: no
06:52:04 <tobiasBora> I would like to know what is the best way to install a haskell env without having root privileges on a computer. I saw halcyon but I don't know how to use it in a local dir
06:52:32 <Hjulle> tobiasBora: Windows or Linux?
06:52:33 <Gurkenglas> kallisti, note "\ handle -> f handle" = "f"
06:53:03 <kallisti> that doesn't work in this example though because you need the handle reference when calling hClose
06:53:23 <Gurkenglas> Welp, soz.
06:53:26 <kallisti> I imagine undo would actually handle that case
06:53:41 <exio4> Gurkenglas: is it? \handle -> (>>=) (f handle) (\result -> (>>) (hClose handle) (return result))
06:53:46 <kallisti> @undo do {handle <- openFile path mode; result <- f handle; return result}
06:53:47 <lambdabot> openFile path mode >>= \ handle -> f handle >>= \ result -> return result
06:53:49 <kallisti> guess it doesn't
06:54:42 <kallisti> yeah would be kind of nice for teaching if undo showed explicit parens, but I can see why it doesn't as well
06:55:32 <tobiasBora> Hjulle: Linux
06:56:05 <kallisti> it has two competing purposes 1) explaining to beginners wtf is going on with do notation  2) showing that monadic code can be pretty without do notation
06:56:22 <kallisti> explicit parens helps with case 1, but hurts case 2
06:56:24 <Hafydd> It's not doing a very good job at the second purpose.
06:57:18 <kallisti> yeah. it would need to do a bit more pointfree stuff, but not FULL pointfree. more like... pointlesser. :)
06:57:44 <Hafydd> I think it could also afford to omit the space between \ and the first parameter.
06:58:09 <kallisti> why not the space before -> as well?
06:58:21 <quicksilver> OMITALLTHESPACES
06:58:26 <Hafydd> That would look worse.
06:58:39 <quicksilver> it's jsut convenient, habit and what you're used to
06:58:40 <Hjulle> tobiasBora: On Windows, using the stack installer works without admin. I haven't tested it on linux. https://github.com/commercialhaskell/stack/releases
06:58:43 <kallisti> well, you know, that's just your opinion, man.
06:58:55 <roelof> anyone who have done the exercises of the Craft of functional programming book ? 
06:59:07 <Gurkenglas> Why must do notation, the paragon of plumbing, also introduce so many names?
06:59:17 <Hafydd> \ arg1 arg2 -> ... reminds me of people who write: int Fun( Arg1, Arg2 ) { ... }
06:59:43 <ChristianS> Gurkenglas: do notation doesn't introduce any names afaik
06:59:56 <Gurkenglas> Using it for plumbing does
07:00:21 <kallisti> learning when to use >>= (and =<<, <$>, <*>, >=>, <=<, etc) and when to use do notation is a fine art.
07:00:24 <Gurkenglas> Is there something like a hierarchy of combinators that replaces "mathematically sound" uses of verbose do notation?
07:00:28 * frerich is one of those people writing 'int f( arg1, arg2 ) { ... }' :-]
07:00:30 <Hjulle> tobiasBora: The stack tool also supports having multiple ghc versions installed simultaniously as an extra bonus.
07:00:37 <kallisti> Gurkenglas: basically all of those things I just listed
07:00:47 <Gurkenglas> An infinite hierarchy, I mean
07:00:59 <roelof> Hafydd:  I think people come from some languages have learned to do Fun(arg1, arg2) I still have to learn that it can be fun arg1arg2 
07:01:12 <alpounet> alexv19: did you get an answer on the servant question?
07:01:42 <Hafydd> roelof: arg1arg2?! I don't think there's any question of that, since it is a different syntax tree.
07:01:48 <alexv19> alpounet: yes, thanks
07:01:50 <Hypoon> Hi guys, I'm looking for suggestions for an algorithm. I have 50000 points, and I need to find which polygon contains each point, of a space-filling tesselation of 200 convex polygons. I then need to repeat this process 10000 times, where the locations of the points and the polygons vary each time. I have some ideas, but I'm very much open to suggestions.
07:02:13 <nshepperd> int Fun ( Arg1 , Arg2 ) { ... }
07:02:13 <roelof> kallisti:  and a lot of practice and reading . Im learning haskell and have not learned the <$> and <*> part 
07:02:27 * Hafydd shudders.
07:02:27 <kallisti> roelof: well, <$> is easy. it's just fmap
07:02:29 <Gurkenglas> "Obviously", there's always going to be another set of do notation that comes up once you try to do the next level of abstract math. I want a combinator hierarchy that removes the need to use do notation for exactly those cases
07:02:46 <roelof> Hafydd:  sorry I mean Fun arg1 arg2 
07:02:56 <kallisti> > negate <$> Just 2
07:02:57 <lambdabot>  Just (-2)
07:03:01 <kallisti> > negate <$> Nothing
07:03:03 <lambdabot>  Nothing
07:03:14 <voidzero> roelof,  fmap (+1) [1,2,3]
07:03:16 <quicksilver> Gurkenglas: do you just mean avoiding the name "x" in foo >>= \x -> bar?
07:03:18 <Gurkenglas> It would have the benefit of you knowing that if you can do a simple specialization of one of those combinators to fit your use case, your use case is mathematically sound
07:03:18 <voidzero> you can also write that as
07:03:20 <Hafydd> int Fun
07:03:21 <Hafydd> (   Arg1
07:03:21 <Hafydd> ,   Arg2
07:03:21 <Hafydd> )
07:03:21 <Hafydd> {
07:03:22 <Gurkenglas> quicksilver, yes
07:03:23 <Hafydd>     ...
07:03:25 <Hafydd> }
07:03:29 <voidzero> roelof, (+1) `fmap` [1,2,3]
07:03:41 <Gurkenglas> (All the names to the left of <- in do blocks)
07:03:43 <voidzero> roelof, that you can also write as  (+1) <$> [1,2,3]
07:03:45 <quicksilver> Gurkenglas: that's pretty ugly to do if x is used multiple times
07:03:55 <Hafydd> Or indeed with "int" and "Fun" on different lines, as is sometimes necessary.
07:04:03 <voidzero> roelof, it's called infix fmap
07:04:06 <voidzero> iirc
07:04:08 <roelof> and also as map (+)  [ 1,2,3] 
07:04:11 <roelof> ?
07:04:22 <quicksilver> @pl foo >>= \x -> bar x >> baz x >> bam >> barr x
07:04:23 <lambdabot> ap ((>>) . (>> bam) . liftM2 (>>) bar baz) barr =<< foo
07:04:24 <Gurkenglas> For any one specific use case, one could introduce a special combinator to do it without much ugliness
07:04:29 <quicksilver> Gurkenglas: ^^
07:04:29 <kallisti> fmap = map when the type is [], yes
07:04:44 <kallisti> fmap is a generalized version of fmap that works with any type that has an instance of the typeclass Functor
07:04:53 <kallisti> *generalized version of map
07:04:54 <roelof> oke, that was my next question. Difference between map and fmap 
07:05:01 <quicksilver> roelof: 'f' :P
07:05:05 <kallisti> :t fmap
07:05:07 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:05:12 <kallisti> :t map
07:05:13 <lambdabot> (a -> b) -> [a] -> [b]
07:05:57 <kallisti> replace f with [] and you'll see that map is just fmap specialized to list
07:06:03 <Gurkenglas> do {x <- foo; y <- bar x, z <- baz x; return (y, z)} for example fits the reader pattern, and is probably easily abstractable
07:07:10 <roelof> Can someone help me what I ment here . The two exercises look the same to me : http://lpaste.net/143130
07:07:26 <roelof> kallisti:  thanks for the explanation 
07:08:03 <fizruk> roelof: first one is partial (only considering non-degenerate cases)?
07:08:09 <quicksilver> roelof: well do you know what degenerate means?
07:09:00 <kallisti> yeah first one is asking for roots of a non-degenerate equation (hence ND in the name) and the second one can be degenerate
07:09:03 <neuroserpens> Why am I banned from haskell beginners and not from here? o,0
07:09:07 <roelof> yes, that is explained in the text above it. Degenarate means that a , b,  c and be zero 
07:09:12 <neuroserpens> I mean... Not that I want to be banned here lol...
07:09:45 <kallisti> roelof: btw did you see the example using fmap with Maybe?
07:11:07 <kallisti> > fmap negate (Just 2)
07:11:08 <lambdabot>  Just (-2)
07:11:12 <kallisti> > negate <$> Just 2
07:11:14 <lambdabot>  Just (-2)
07:11:24 <roelof> oke, those exampes I saw 
07:12:46 <roelof> kallisti:  but thanks for the explanation about the exercises. The second will have many case statements then 
07:13:11 <kallisti> > Just 2 >>= return . negate
07:13:12 <lambdabot>  Just (-2)
07:13:30 <roelof> and thanks for the lessons about <*> 
07:14:12 <roelof> kallisti:  >>= means that just 2 is a parameter for the return negate function 
07:14:47 <kallisti> that's what the type would imply yes
07:14:58 <kallisti> but what if I told you that fmap f m = m >>= return . f
07:15:06 <c_wraith> neuroserpens: different channels with different mods
07:15:07 * kallisti does his best Morpheus impression
07:15:21 <voidzero> POTATO
07:15:48 <roelof> the outcome of fmap fm is stored in m and that one is a parameter for the return f 
07:16:16 <kallisti> > fmap negate Nothing
07:16:17 <lambdabot>  Nothing
07:16:38 <kallisti> so basically Maybe is like a list that can only have zero or one elements.
07:16:57 <roelof> and nothing has only zero elements 
07:17:01 <kallisti> > fmap negate []
07:17:02 <lambdabot>  []
07:17:04 <kallisti> > fmap negate [2]
07:17:06 <lambdabot>  [-2]
07:17:18 <joneshf-laptop> So, `join . duplicate = id` yeah? I believe so, but I can't google this early in the morning, and it's way too early to try and prove it.
07:17:50 * roelof hopes to get a 6 out of 10 
07:18:01 <kallisti> it's uh....
07:18:05 <kallisti> extract . duplicate = id
07:18:41 <kallisti> oh nevermind
07:18:46 <Hjulle> joneshf-laptop: Is't that one of the monad laws?
07:19:37 <kallisti> yeah not sure if join . duplicate = id, but the types would seem to indicate it
07:19:41 <joneshf-laptop> Hjulle, there's a comonad in there
07:19:50 <Hjulle> aha
07:20:53 <roelof> everyone thanks. I will try to make those exercises and continue with the Craft book 
07:21:33 <kallisti> joneshf-laptop: I mean type-wise that checks out, but I don't know if they're semantically equivalent given monad/comonad laws. Not sure how you would prove that.
07:21:39 <quicksilver> the monad law you're maybe thinking of is join . return == id
07:22:06 <quicksilver> join . duplicate would only make sense if 'm' was both a Monad and a Comonad
07:22:09 <bennofs> joneshf-laptop: I think there are types which are both Monad/Comonad and join . duplicate /= id
07:22:39 <kallisti> What happens when you join . duplicate a Tree? not familiar with the comonad instance for rose trees
07:23:08 <kallisti> that would be a sufficiently complex case to look for a potential counterexample
07:23:54 <bennofs> :t duplicate
07:23:56 <lambdabot>     Not in scope: ‘duplicate’
07:23:56 <lambdabot>     Perhaps you meant one of these:
07:23:56 <lambdabot>       ‘replicate’ (imported from Data.List),
07:24:05 <bennofs> @let import Control.Comonad
07:24:07 <lambdabot>  Defined.
07:24:23 <kallisti> duplicate :: Comonad w => w a -> w (w a)
07:24:32 <bennofs> > duplicate (x, 3)
07:24:33 <kallisti> it's the inverse of join
07:24:34 <lambdabot>  (x,(x,3))
07:24:37 <clrnd> omg it can import
07:24:38 <bennofs> > join $ duplicate (x, 3)
07:24:42 <lambdabot>      Could not deduce (Monad ((,) Expr)) arising from a use of ‘join’
07:24:42 <lambdabot>      from the context (Num a)
07:24:42 <lambdabot>        bound by the inferred type of it :: Num a => (Expr, a)
07:25:03 <quicksilver> the comonad instance for Trees gives you, at each point, the tree at that point
07:25:04 <bennofs> > runWriter $ join $ writer $ duplicate (x, 3)
07:25:06 <lambdabot>      Couldn't match type ‘Expr’ with ‘WriterT (Expr, a1) Identity a’
07:25:06 <lambdabot>      Expected type: WriterT
07:25:06 <lambdabot>                       (Expr, a1) Identity (WriterT (Expr, a1) Identity a)
07:25:08 <exio4> > join (duplicate ("a", 3))
07:25:09 <lambdabot>      Could not deduce (Monad ((,) [Char])) arising from a use of ‘join’
07:25:09 <lambdabot>      from the context (Num a)
07:25:09 <lambdabot>        bound by the inferred type of it :: Num a => ([Char], a)
07:25:18 <kallisti> tuple is not a monad
07:25:23 <exio4> wow rude :P 
07:25:42 <kallisti> @let import Data.Tree
07:25:45 <lambdabot>  Defined.
07:26:09 <kallisti> > join . duplicate . levels $ [[1,2,3],[4,5]]
07:26:11 <lambdabot>      Couldn't match expected type ‘Tree a’
07:26:11 <lambdabot>                  with actual type ‘[[Integer]]’
07:26:11 <lambdabot>      In the second argument of ‘($)’, namely ‘[[1, 2, 3], [4, 5]]’
07:26:47 <quicksilver> > duplicate (Node 1 [Node 2 [], Node 3 []])
07:26:49 <lambdabot>  Node {rootLabel = Node {rootLabel = 1, subForest = [Node {rootLabel = 2, sub...
07:26:56 <quicksilver> ah silly print instance
07:27:02 <quicksilver> you get that entire tree in the root node
07:27:17 <kallisti> >  levels . join . duplicate $ (Node 1 [Node 2 [], Node 3 []])
07:27:17 <quicksilver> and each of the child nodes you get just the subtree there (2 or 3)
07:27:19 <lambdabot>  [[1],[2,3,2,3]]
07:27:24 <quicksilver> so, it's quite different
07:27:26 <bennofs> > join $ duplicate (x, 3)
07:27:29 <lambdabot>  (x <> x,3)
07:27:31 <quicksilver> join.duplicate definitely not id
07:27:33 <bennofs> ^^^ that is not id
07:27:36 <quicksilver> :)
07:28:04 <bennofs> also, since extract.duplicate = id and fmap extract.duplicate = id, it would be weird if join.duplicate = id
07:28:14 <kallisti> > levels . duplicate $ (Node 1 [Node 2 [], Node 3 []])
07:28:16 <lambdabot>  [[Node {rootLabel = 1, subForest = [Node {rootLabel = 2, subForest = []},Nod...
07:28:38 <kallisti> so duplicate for free just replaces each node with a copy of the root?
07:28:40 <kallisti> *tree
07:29:03 <quicksilver> no, a copy of the tree at that point
07:29:08 <kallisti> ah
07:29:11 <quicksilver> so at the root you get the whole thing
07:29:14 <kallisti> what the hell does join do? :P
07:29:19 <quicksilver> and then at each branch you get a copy of that subtree
07:29:24 <quicksilver> squashes it all back together
07:29:32 <quicksilver> that's why the 2s and 3s ended up back on the same level
07:29:39 <kallisti> right but what if there's outliers in different subtrees etc
07:29:41 <quicksilver> in your example
07:29:45 <kallisti> does it just merge everything together ignoring duplicates?
07:29:56 <quicksilver> it doesn't care about duplicates, it can't even detect them
07:29:59 <quicksilver> no Eq instance here
07:30:37 <kallisti> okay I think I understand
07:30:52 <quicksilver> it merges levels, so level 2 is all the level 1s of all the level 2 trees
07:31:11 <kallisti> right
07:31:11 <quicksilver> level 3 is all the level 1s of the level 3 trees *and* the level2s of the level level 2 trees
07:31:17 <quicksilver> and, indeed, the level3s of the root tree
07:31:34 <kallisti> okay that makes sense. somewhat analogous to join for lists but in more dimensions. :P
07:31:45 <bennofs> ah, so it's kind of "overlaying" the trees :)
07:31:51 <quicksilver> well it's exactly that kallisti 
07:31:55 <quicksilver> if you squint right
07:32:04 <quicksilver> a list is just a rose tree with precisely one child at each level
07:32:10 <quicksilver> (until some level where it has zero)
07:32:32 <joneshf-laptop> bennofs, quicksilver thanks!
07:34:29 <kallisti> instance Comonad IO where extract = unsafePerformIO  -- >:D
07:35:32 <quicksilver> kallisti: a little trick to find a 'duplicate' which makes that extract obey the comonad laws.
07:35:35 <quicksilver> or I think so.
07:36:08 <fizruk> there is a sensible comonadic IO I think, though it won't be a monad anymore then
07:40:25 <kallisti> oh I just realized now that we have type-level naturals you can make a comonad image processing type where the type parameters specify the dimensions of the window
07:40:26 <fizbin> Anyone here with experience looking at ghc profiles?
07:43:11 <fizbin> I've got a program that is supposedly spending a huge amount of time inside "myFunc.mySubCalculation.(...)" (by which I mean 22% of the time and 34% of the alloc). No other line in the profile comes close to being that hot. How do I break down the "(...)" there into something telling me what's wrong?
07:44:40 <frerich> fizbin: What I sometimes do is to add 'cost centers' by hand. They look like {-# SCC "someName" } <expression>
07:45:07 <emmanuel_erc> Hello there, I have been digging around for Data.Packed.ST, and I can't seem to find it anywhere on Hackage. Does anyone know what could be the problem?
07:45:21 <frerich> fizbin: Like 'let x = {-# SCC "Splitting Words" #-} words xs' will get you a dedicated 'cost center' (i.e. profile entry) for the 'words xs' expression.
07:47:10 <fizbin> Hrm. Okay. I just wish I knew how this function isn't getting split already.
07:49:46 <kallisti> @hoogle Data.Packed.ST
07:49:49 <lambdabot> package STL
07:49:49 <lambdabot> package STMonadTrans
07:49:49 <lambdabot> package stable-heap
07:51:17 <emmanuel_erc> thanks kallisti
07:51:24 <emmanuel_erc> I feel silly now
08:02:55 * hackagebot clash-prelude 0.10.1 - CAES Language for Synchronous Hardware - Prelude library  https://hackage.haskell.org/package/clash-prelude-0.10.1 (ChristiaanBaaij)
08:13:26 * hackagebot clash-lib 0.6.1 - CAES Language for Synchronous Hardware - As a Library  https://hackage.haskell.org/package/clash-lib-0.6.1 (ChristiaanBaaij)
08:13:28 * hackagebot clash-systemverilog 0.6.1 - CAES Language for Synchronous Hardware - SystemVerilog backend  https://hackage.haskell.org/package/clash-systemverilog-0.6.1 (ChristiaanBaaij)
08:13:30 * hackagebot clash-verilog 0.6.1 - CAES Language for Synchronous Hardware - Verilog backend  https://hackage.haskell.org/package/clash-verilog-0.6.1 (ChristiaanBaaij)
08:13:32 * hackagebot clash-vhdl 0.6.1 - CAES Language for Synchronous Hardware - VHDL backend  https://hackage.haskell.org/package/clash-vhdl-0.6.1 (ChristiaanBaaij)
08:18:34 * hackagebot clash-ghc 0.6.1 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.6.1 (ChristiaanBaaij)
08:24:35 <Xandaros> http://hastebin.com/akocoremub.txt - halp plz :(
08:25:00 <Xandaros> (All the lambdabot-* packages are included via cabal sandbox add-source)
08:25:41 <Xandaros> If I just reinstall the lambdabot-misc-plugins package, it works fine, but building the main lambdabot package fails, as seen above
08:30:41 <bergmark> Xandaros: when things like that happen i usually wipe the sandbox
08:31:13 <Xandaros> Yay... I'm currently in a location with the worst internet I have had since 56k modems :/
08:33:27 * hackagebot pathwalk 0.1.1.1 - Path walking utilities for Haskell programs  https://hackage.haskell.org/package/pathwalk-0.1.1.1 (Xena)
08:36:05 <Xandaros> Alright. Time to go compiling for 2 hours
08:57:36 <Peaker> Is there an IRC channel for the libgit family of packages?
08:57:58 <Peaker> Seems like the "isBare" flag in RepositoryOptions doesn't belong there (it's a repo-init option, but RepoOpts is used for open too)
09:05:07 <the_2nd> I defined a data KdTree val = 
09:05:16 <the_2nd> and want to instanciate Show for it
09:05:31 <the_2nd> but get an "type * -> * instead of *" error
09:09:17 * hackagebot diversity 0.7.1.0 - Return the diversity at each position by default for all sequences in a fasta file  https://hackage.haskell.org/package/diversity-0.7.1.0 (GregorySchwartz)
09:10:31 <ramadoka> hey guys, can I get some help, I've just started learning haskell using "Write yourself a scheme".
09:11:20 <ramadoka> I'm not yet even comfortable on reading the docs ._.
09:14:55 * ski awaits ramadoka's question
09:19:32 <julianleviston> ramadoka: write yourself a scheme is a *bit* of a tricky intro to start with IMO.
09:20:11 <josephle> but it's a fun way to start
09:20:20 <josephle> I do wonder how up-to-date it is though...
09:20:41 <dredozubov> josephle: not so fun if you have no clue how it all works
09:21:13 <ramadoka> yeah, I've read some learn you haskell for greater good, but "write yourself a scheme" seems pretty practical to learn.
09:21:16 <josephle> dredozubov: yeah, it definitely depends on your prior knowledge
09:21:17 <dredozubov> it's complexity multiplied by complexity, if you don't know 1) haskell 2) how to write an interpreter
09:21:43 <dredozubov> ramadoka: go with the domain you know
09:21:58 <dredozubov> if you know how to write an interpreter - it's okay
09:22:06 <ramadoka> I have less idea about how to write an interpreter, than about how to haskell.
09:22:10 <dredozubov> if you don't - do something else
09:22:23 <josephle> I found "write yourself a scheme" pretty good about avoiding knowledge about interpreter architecture
09:22:44 <dredozubov> ramadoka: it makes more sense to tackle the problem from the domains you know about
09:23:35 <ramadoka> <dredozubov> what do you suggest
09:23:38 <dredozubov> josephle: i haven't tried it, above is my opinion on the matter from the general perspective :)
09:23:53 <ramadoka> ?
09:23:59 <ski> ramadoka : have you learned any other functional programming language before ?
09:24:02 <josephle> dredozubov, perhaps you should read it to see if it really is as hard as you make it out to be
09:24:07 <dredozubov> ramadoka: surely you can take some problems you've tackled with different programming languages
09:24:15 <julianleviston> josephle: I’ve read it.
09:24:17 * hackagebot singletons 2.0.1 - A framework for generating singleton types  https://hackage.haskell.org/package/singletons-2.0.1 (RichardEisenberg)
09:24:41 <ski> ramadoka : if not, it would probably help more with learning the basics first (including unlearning stuff from other programming languages you might know)
09:24:49 <ramadoka> i'm pretty comfortable with concept about higher order function, currying, and what not.
09:24:53 <julianleviston> josephle: I found the CIS194 course way more approachable and easier
09:24:59 <julianleviston> @where cis194
09:24:59 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
09:25:02 <phaazon> hm
09:25:12 <ramadoka> though, not monad.
09:25:14 <josephle> julianleviston, CIS194 and bitemyapp's book are definitely more beginner friendly
09:25:17 <phaazon> is there a way to query the bytes of a strict type without using a value for it?
09:25:22 <dredozubov> i like the NICTA course
09:25:25 <phaazon> I thought something with Proxy might work
09:25:29 <phaazon> but Proxy is not Storable
09:25:36 <julianleviston> dredozubov: I have to go and do that I think...
09:25:45 <dredozubov> ramadoka: https://github.com/NICTA/course i liked this course
09:25:46 <quicksilver> phaazon: no; values of a strict type don't "have bytes"
09:25:52 <phaazon> sizeOf (undefined :: a)
09:25:54 <phaazon> if a is strict
09:26:00 <phaazon> that won’t make it through
09:31:49 <fizbin> frerich: Thank you - it took a while, but lots of manual cost center annotations found the major nastiness in my code.
09:32:27 <fizbin> And they aren't here any more. Oh well.
09:32:29 <julianleviston> really? fmap = M.liftM
09:32:33 <julianleviston> :t liftM
09:32:35 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
09:33:00 <julianleviston> that’s not completely confusing or anything.
09:34:30 <julianleviston> what does ≅ mean?
09:34:38 <julianleviston> is it “equivalent to”?
09:35:20 <fizbin> FWIW, people may wish to hide away this in their heads when profiling: I got an auto-generated cost center because I had in my where clause a few destructuring assignments; e.g., "(_, _, label, _) = G.context startGraph".
09:35:35 <fizbin> Using manual cost center annotations helped me distinguish between them.
09:35:57 <fizbin> That is, "I got an auto generated cost center named (...) because I had..."
09:37:43 <Hypoon> julianleviston: the precise definition depends on where you see it and what convention they use. LiftM basically just takes a function and applies it inside a monad. For example, you can't take the sqrt of IO(Float), but you can take the (liftM sqrt) of an IO(Float).
09:38:03 <julianleviston> Hypoon: yeah I know what liftM does
09:38:23 <Cale> I'd rather say that it applies the function to the result of an action
09:38:26 <julianleviston> I just found defining fmap as it in the beginnig of the NICTA course seems…. unhelpful
09:39:14 <Hypoon> Cale: that's only true for the IO monad, but there are many other monads.
09:39:19 <Peaker> johnw: Hey, looking into gitlib, cool stuff. Why do you use: -fno-warn-unused-binds <-- lots of dead code detected by that/
09:39:29 <Peaker> For example, the remoteFetch there isn't exposed
09:39:29 <Cale> The values of type m t for all monads m can be referred to as actions
09:39:32 <Cale> m-actions
09:39:52 <Hypoon> Cale: ok, from that perspective, yeah, I agree.
09:40:23 <julianleviston> I thouhgt it wasn’t perspective.
09:40:33 <julianleviston> I thought “action” was generally what monadic effects were called.
09:41:05 <Cale> Well, it is a bit of an analogy, but it's such a small jump (especially in Haskell) that it's almost not there :)
09:41:32 <Cale> Effects are not part of the definition of a monad.
09:42:22 <julianleviston> Cale: usually, the definition sits “around” the effects :-)
09:42:26 <Cale> But you can kind of go the other way, and define effects to be the stuff that monads achieve?
09:42:52 <Cale> Though once you get outside of a programming context, that starts making a whole lot less sense
09:43:57 <reactormonk> Best way to replace character "~" at the start of a string with the output of a function? What function should I look at?
09:45:23 <Hypoon> If a list of floats is an "action", how would one describe "liftM (+1) [3,4,5]"? (I would be using a map here, but this suffices for the thought experiment)
09:45:47 <phaazon> ok, debugging in Haskell is pretty cool!
09:45:55 <phaazon> https://twitter.com/phaazon_/status/655061818281467904?lang=en
09:46:50 <Cale> Hypoon: So from this view, the elements of the list are the result(s) of the action (it's nondeterministic), and liftM is giving you an action whose result is the result of the original action with (+1) applied to it.
09:47:19 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
09:47:21 <lambdabot>  [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2,...
09:47:34 <Cale> "running" a list means picking an element from it (in all possible ways)
09:47:53 <Cale> > do x <- liftM (*10) [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
09:47:54 <lambdabot>  [(10,4,6),(10,4,7),(10,4,8),(10,5,6),(10,5,7),(10,5,8),(20,4,6),(20,4,7),(20...
09:48:21 <Cale> Here, x gets bound to 10 times what it was bound to in the original computation
09:48:32 <julianleviston> Cale: hence the commonly touted comment about the fact that if do notation was invented before list comprehensions we might not even have had to come up with the latter.
09:48:43 <Cale> Maybe
09:48:52 <Cale> List comprehensions are still very nice
09:48:57 <julianleviston> Cale: sure… :)
09:49:03 <Cale> But yeah, they are basically the same thing as do-notation
09:49:07 <hodapp> I've hardly used them
09:49:11 <Cale> with extra sugar for guards
09:49:12 <hodapp> and I hardly see them used
09:49:13 <Peaker> They have a weird top-most-then-bottom-up ordering
09:49:23 <SrPx> Why non recursive "let" is usually included in formulations of the base calculi if it is expressible as an application?
09:49:26 <Peaker> Nicer to have a consistent top-down or bottom-up ordering (I prefer the latter)
09:49:40 <Peaker> SrPx: Usually because of let generalization, I think
09:49:49 <SrPx> what is that?
09:50:13 <Peaker> SrPx: The (inferred) type of function parameters is monomorphic. The (inferred) type of "let" bindings can be polymorphic
09:50:26 <julianleviston> I don’t really understand NICTA.
09:50:35 <julianleviston> I guess that’s to be expected as per the readme.
09:51:00 <Peaker> SrPx: "let generalization" means that any type variables that appear in the inferred type of a "let"-bound variable that are "free" (not equal to any outer type from the environment) get their "forall" in the let-binding's type rather than being in the outer-most "forall"
09:52:03 <ggole> let is indeed redundant in, say, explicitly system f
09:52:18 <ggole> Er, "explicitly typed"
09:52:40 <Peaker> SrPx: for example, I'll use :: to denote inferred types:   foo (x :: a) = let f y = (x, y) in ...         f :: b -> (a, b)     "a" appears outside but "b" appears only in "f", so it can be "forall"d in f, so: f :: forall b. b -> (a, b)
09:53:26 <Peaker> SrPx: "let generalization" automatically converts the type of f   from "b -> (a, b)"  to "forall b. b -> (a, b)"  because the "b" is completely free
09:53:52 <Copperis> > let one = "1"
09:53:55 <lambdabot>  <no location info>: not an expression: ‘let one = "1"’
09:54:35 <Copperis> > one = "1"
09:54:37 <lambdabot>  <hint>:1:5: parse error on input ‘=’
09:54:41 <julianleviston> Copperis: > let one = “1” in one 
09:55:07 <Copperis> > let one = "1" in one
09:55:08 <lambdabot>  "1"
09:55:13 <Copperis> > one
09:55:14 <lambdabot>      Not in scope: ‘one’
09:55:15 <lambdabot>      Perhaps you meant one of these:
09:55:15 <lambdabot>        ‘none’ (imported from Control.Lens),
09:55:24 <julianleviston> Copperis: oh you have to use the @ form I think… 
09:55:26 <Welkin> Copperis: use @let
09:55:37 <Peaker> lambdabot has TypeFamilies enabled I think -- because it has let generalization disabled
09:55:38 <Welkin> special lambdabot commands
09:55:45 <Copperis> @let one = "1"
09:55:47 <lambdabot>  Defined.
09:55:47 <julianleviston> Copperis: lambdabot is a bit different than GHCI
09:55:51 <Copperis> one
09:55:54 <julianleviston> > one
09:55:54 <Copperis> > one
09:55:56 <lambdabot>  "1"
09:55:56 <lambdabot>  "1"
09:56:01 <Peaker> GHC disables let generalization if certain extensions (TypeFamilies at least) are enabled
09:56:08 <Copperis> cool, thanks julianleviston 
09:56:24 <SrPx> Peaker: uhm I think I get it, without the "let" you'd have the forall to float to the type of "foo"?
09:56:38 <Copperis> @let thing = do x <- liftM (*10) [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
09:56:41 <lambdabot>  Defined.
09:56:47 <Copperis> @type thing
09:56:48 <lambdabot> (Num t, Num t1, Num t2) => [(t, t1, t2)]
09:56:54 <Copperis> @type return
09:56:55 <lambdabot> Monad m => a -> m a
09:57:19 <julianleviston> Copperis:  you can do this stuff in private to lambdabot if you’d like… so’s you don’t spam the channel
09:57:28 <Peaker> SrPx: to that level, yes. It will only actually appear in the type of "foo" if the type var appears in the type of "foo" but morally that's where all inferred foralls are (until let generalization)
09:58:00 <SrPx> I see
09:58:04 <Copperis> so, why does that "thing" definition is a list of nums, while do notation works on monads and "return"'s type is monad?
09:58:28 <SrPx> I googled "let generalization" and the first paper is "Let Should Not Be Generalised" lol
09:58:34 <julianleviston> Copperis: return’s type is a function from a to monadic-a.
09:58:46 <Copperis> julianleviston, yup
09:58:50 <Peaker> in ghci: let f x = x in (f 'x', f "x")  <-- works   but:    (\f -> (f 'x', f "x")) (\x -> x)  <-- doesn't work
09:58:55 <Peaker> SrPx: :)
09:59:08 <julianleviston> Copperis: List forms a monad.
09:59:19 * hackagebot timeless 0.8.1.0 - An Arrow based Functional Reactive Programming library  https://hackage.haskell.org/package/timeless-0.8.1.0 (carldong)
09:59:20 <julianleviston> Copperis:  or “has an instance of Monad”
09:59:24 <SrPx> That makes sense to me Peaker, thanks
09:59:30 <Peaker> SrPx: the tradition set forth by ML made let generalized :)
09:59:39 <Copperis> julianleviston, lists are somehow related to a Monad?
09:59:47 <SrPx> Now that I learned why let generalization is good I'll have to learn why it is bad
09:59:49 <Peaker> SPJ wants to change that tradition
10:00:16 <julianleviston> Copperis: they have an instance of Monad, just like Maybe has an instance…
10:00:39 <Copperis> Monad is a typeclass?
10:00:45 <julianleviston> Copperis: yeah.
10:00:47 <Copperis> ok
10:01:32 <julianleviston> Copperis: it’s a typeclass that requires >>= to be defined… and usually has return defined, and join… (and some other stuff sometimes)
10:01:57 <shersh> Hello everyone! I wonder if there is a particular reason for not having `evalWriter` function in Haskell? It is really annoying to write `fst . runWriter` each time :( Besides, there IS `evalState` function.
10:02:16 <Copperis> julianleviston, don't typeclasses require everything to be defined?
10:02:21 <julianleviston> shersh:  what would it do?
10:02:29 <shersh> `fst . runWriter`
10:02:34 <julianleviston> Copperis:  they require only whatever their minimal implementation requires…
10:02:58 <Shockk> join isn't part of the typeclass
10:03:15 <Shockk> >>=, >>, return, and fail right now
10:03:38 <Copperis> julianleviston, so by their minimal implementation, everything gets defined as I understand
10:03:48 <julianleviston> Copperis: no.
10:04:03 <julianleviston> Copperis: oh I’m not sure what you mean
10:04:07 <julianleviston> https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Monad.html
10:04:15 <julianleviston> check the section on “minimal complete definition"
10:04:19 * hackagebot pandoc 1.15.1 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-1.15.1 (JohnMacFarlane)
10:05:00 <Ferdirand> :t evalState
10:05:02 <lambdabot> State s a -> s -> a
10:05:07 <Copperis> julianleviston, Eq requires == and \= (or \==?) to be defined, so by defining only ==, you automatically define the other
10:05:26 <julianleviston> Copperis: oh you’re talking about default definitions. yeah.
10:05:28 <Copperis> so in the end, the minimal implementation defines everything
10:05:34 <julianleviston> Copperis: return is applicative’s “pure”
10:05:56 <Shockk> the whole typeclass instance is defined, but not every function needs to be explicitly defined
10:06:01 <julianleviston> Copperis: maybe.
10:06:18 <julianleviston> Copperis: sometimes you might have a more efficient definition that your type requires, too.
10:06:28 <Ferdirand> shersh: so you want to discard the writer output ? 
10:06:48 <Copperis> julianleviston, do you have an example where defining a minimal implementation doesn't define automatically everything?
10:07:15 <ReinH> shersh: what's the point of using writer if you discard the writer output?
10:07:20 <julianleviston> Copperis: nope.
10:07:23 <Copperis> ok
10:07:33 <julianleviston> Copperis:  someone else might be able to help.
10:07:41 <julianleviston> Copperis:  it’s 4am and I’m about to fall asleep.
10:08:11 <ReinH> Copperis: if the minimal implementation didn't define anything then it would not be the minimal implementation
10:08:19 <ReinH> s/anything/everything
10:08:23 <shersh> Ferdinand: I just want to get the result of writer. It seems strange to me that there is a function `execWriter` which definition is `snd . runWriter` and there is no function `evalWriter` with definition `fst . runWriter`
10:08:50 <ReinH> shersh: the result of writer is the second element
10:09:04 <ReinH> shersh: which is what execWriter gives you
10:09:19 * hackagebot luminance 0.4.1 - Type-safe, dependently-typed and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.4.1 (DimitriSabadie)
10:09:21 * hackagebot timeless 0.8.1.1 - An Arrow based Functional Reactive Programming library  https://hackage.haskell.org/package/timeless-0.8.1.1 (carldong)
10:09:30 <ReinH> there is no evalWriter because throwing away the writer component means the Writer monad context is completely wasted
10:09:38 <shersh> ReinH: In some places of program I need to do some evaluations only on first element of Writer.
10:09:49 <ReinH> shersh: then just don't use Writer
10:10:03 <ReinH> since the use of writer is completely superfluous in that case
10:10:14 <Ferdirand> first element ?
10:10:30 <ReinH> @unmtl Writer w a
10:10:30 <lambdabot> (a, w)
10:10:34 <shersh> filter for example. But ignore writer. And I use writer in some different place in the same function
10:10:39 <jophish> errr... When I run ghc it crashes with: Illegal instruction (core dumped)
10:11:24 <ReinH> shersh: then just use fst . runWriter, I guess. It doesn't exist because it's basically useless.
10:12:13 <ReinH> since there's no way for the w component to change the result (the a component), fst . runWriter just discards all the writer effects and runs the "pure" computation.
10:12:20 <ReinH> (pure in the sense of not having monadic effects)
10:12:52 <Ferdirand> well maybe if there is stuff outside his control and written in terms of Writer instead of the relevant transformer ?
10:13:17 <ReinH> Yeah, I assume there's some Writer w a action that needs to be run to produce an a and they don't care about the w
10:13:26 <Shockk> jophish: what architecture are you running on, what architecture is your GHC compiled for, and are you doing anything involving attempting to link or run binary code that isn't for your architecture?
10:13:28 <ReinH> Which is reasonable, but not common enough to warrant inclusion in the library
10:13:45 <shersh> ReinH: I don't want to "write" filter actions, only some meaningful parts of function. Or could you suggest example of rewriting filter in that way, that `filter` add only `memply` to log? That is another way to achieve my goal.
10:13:55 <jophish> Shockk: x86_64 all round, nothing exotic at all
10:13:58 <ReinH> shersh: filter?
10:14:02 <ReinH> You don't mean
10:14:05 <ReinH> :t filter
10:14:06 <lambdabot> (a -> Bool) -> [a] -> [a]
10:14:07 <jophish> just run stack setup
10:14:09 <jophish> ran*
10:14:11 <ReinH> which does not involve Writer?
10:14:22 <shersh> :t filterM
10:14:23 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
10:14:37 <ReinH> What are you doing with filterM and Writer?
10:15:08 <ReinH> Do you have code we can see?
10:15:10 <ReinH> @where lpaste
10:15:10 <lambdabot> http://lpaste.net/
10:15:12 <Shockk> jophish: try running through gdb or something, I don't know
10:16:12 <jophish> Shockk: good thinking. I'll try that, thanks!
10:16:37 <Shockk> jophish: actually if the core was dumped, you can load that into gdb
10:17:34 <shersh> ReinH: I'm using filter. I filter my Writers by `myPredicate . fst . runWriter` and add actions only on "valid" writers (which i assume to be true of my predicate).
10:17:42 <shersh> ReinH: here is my code: http://lpaste.net/7683827145449144320
10:18:55 <ReinH> shersh: If you're filtering with fst . runWriter, you may as well map runWriter and then filter on fst
10:19:05 <ReinH> since you're already performing the computation, you may as well just perform the computation
10:20:44 <kallisti> where do I find functions for working with type-level lists?
10:21:07 <jophish> Shockk: I reinstalled ghc and things are working well
10:21:11 <jophish> no idea what happened there
10:21:11 <jophish> !
10:21:21 <Shockk> oh, great
10:21:27 <Ferdirand> ReinH++
10:21:53 <ReinH> performing the computation in the filter and then discarding it to perform it again later is wasteful
10:22:09 <Shockk> if you do still have the core dump, I'd probably recommend looking into it a bit and/or posting a bug report something somewhere or something like that
10:22:21 <ReinH> there's no point in throwing away the w component and then performing the computation again to get it back
10:23:32 <shersh> ReinH: could you suggest ways to rewrite this code in more haskell way?
10:23:54 <ReinH> shersh: I think I just did?
10:24:17 <shersh> ReinH: i don't actually get your idea...
10:24:58 <jophish> Shockk: I could't find it... not in the current directory or /var/crash
10:25:18 <jophish> searching for ghc core dump is (predictably) unuseful
10:27:36 <jophish> I think it's evaporated :/
10:27:53 <Shockk> jophish: ahh
10:28:01 <Shockk> most likely you don't have a core dump limit set
10:28:27 <Shockk> for the future: $ ulimit -c x
10:28:38 <Shockk> where x is a number or "unlimited" without quotes
10:28:58 <jophish> I'll remember, thanks Shockk!
10:29:40 <Shockk> jophish: that number is the core file size, not how many core files there can be
10:29:46 <Shockk> so unlimited isn't a bad thing to use there
10:30:04 <ReinH> shersh: ok, one sec
10:30:29 <obadz> do I need to do something before I can use cpp macros in a file?
10:31:12 <Shockk> obadz: {-# LANGUAGE CPP #-}
10:31:20 <Shockk> at the top of the file, or built with -XCPP I think
10:31:20 <obadz> Shockk: ok thanks
10:31:31 <Shockk> or build*
10:32:31 <kallisti> is there a typeclass somewhere that can be used to test if a type is an element of a type list?
10:33:05 <Shockk> I don't know if there's a package that defines that, but I wrote one
10:33:13 <bob_twinkles> if you just want a "thing that can be iterated over" there's Traversable and Foldable, depending on exactly how you want to use i t
10:33:14 <Shockk> not a typeclass though, a type family
10:33:15 <Shockk> one sec
10:33:32 <bob_twinkles> nvm I misread what you said, sorry
10:33:46 <athan> kallisti: Yes, watch:
10:33:48 <lpaste> Shockk pasted “No title” at http://lpaste.net/7153448261200642048
10:33:50 <Shockk> there you go
10:33:55 <athan> dangit :(
10:34:05 <Shockk> :D
10:34:07 <athan> kallisti: Check out singletons
10:34:12 <kallisti> ah, well, I was hoping for something that was standard, but I guess that's fine.
10:34:13 <jophish> kallisti: vinyl has this operator, you could check out this: https://hackage.haskell.org/package/vinyl-0.5.1/docs/Data-Vinyl-Notation.html#t:-8712-
10:34:34 <kallisti> oh I think singletons is what I'm looking for actually
10:36:24 <Shockk> it'd be interesting to have an extension that promotes functions operating on types to type families operating on kinds
10:37:11 <Shockk> could then use all the standard list functions in their promoted form, on type lists
10:37:56 <tobiasBora> Hjulle: Ok thank you. I'm more looking for Linux solution, but I think I know how to edit the script no to ask to password. It's only a bit dirty...
10:39:15 <Hjulle> tobiasBora: My solution might work with linux, it's just that I haven't tested it.
10:41:17 <kallisti> basically my idea is to create something that's like a generalized sum type
10:41:25 <kallisti> based on a list of types
10:41:39 <kallisti> but I've never tried this kind of type-level stuff before
10:42:33 <Shockk> like '[Integer, Int, Float] being integer + int + float?
10:43:10 <kallisti> not sure what you mean by +, but if you mean sum types in the ADT sense, then yes.
10:43:50 <Shockk> oh, I don't know what you mean by sum type then
10:44:27 <kallisti> so like Choice `[Integer, Float] would be analogous to Either Integer Float
10:46:12 <acowley> kallisti: Something like this? http://hackage.haskell.org/package/Frames-0.1.2.1/docs/Frames-CoRec.html
10:46:59 <dmj`> kallisti: you could probably have a type function that enforces that association
10:47:30 <dmj`> type Conversion Choice '[Integer, Float] = Eiter Integer Float
10:47:36 <dmj`> s/Eiter/Either
10:47:50 <geppettodivacin> I'm having weird problems with Binary.encode not being lazy enough. I made a newtype for list to be encoded lazily, but in some cases it doesn't appear to be.
10:47:56 <geppettodivacin> I've got my code here: http://lpaste.net/143097
10:48:01 <kallisti> acowley: yep exactly. Would have taken me forever to figure out the representation since I've never tried type-level programming before
10:48:28 <geppettodivacin> testBin and testBin2 both work lazily, but testBin3 doesn't seem to.
10:48:29 <acowley> kallisti: I walk through parts of the development of it in the first half of the talk I gave at Boston Haskell earlier this year.
10:48:37 <kallisti> seems obvious now that you'd want a GADT though, because you need some way to pattern match to extract the value. that was the issue I was running into when thinking of type family/typeclass approaches
10:48:46 <acowley> kallisti: It's a really neat technique
10:49:21 * hackagebot grouped-list 0.1.3.0 - Grouped lists. Equal consecutive elements are grouped.  https://hackage.haskell.org/package/grouped-list-0.1.3.0 (DanielDiaz)
10:50:41 <kallisti> acowley: so what I'm looking into is the concept of catching exceptions for a specific list of exception types, and I figured something like CoRec might make sense to allow pattern matching over possibilities
10:50:59 <kallisti> but that might not be the best method
10:51:12 <acowley> kallisti: I think it's a great idea to explore!
10:51:29 <acowley> kallisti: Check out 'match' in that module
10:55:16 <kallisti> acowley: that hardest part of reading docs like this is figure out what's "type-level source code" and what's "type-level interface";  I need a PromotedHaddock :P
10:56:24 <acowley> kallisti: Yes, you need to think about both the types and the values at the same time
10:57:00 <acowley> kallisti: It does look like we're missing some sort of narrowing function
10:57:33 <ReinH> shersh: it looks like you actually want WriterT w [] a
10:57:34 <acowley> kallisti: A problem is that removing things from lists gets pretty hideous
10:58:09 <lrocksmashtime> is there a cabal command that you can run to actually add a depency into your projects cabal file?
10:58:14 <shersh> ReinH: I'm not good in trasformers yet :(
10:58:24 <kallisti> I'm thinking that it should be set-based instead of list-based, for exception handling. So that the order doesn't matter.
10:58:30 <shersh> ReinH: But thanks for advice!
10:58:48 <acowley> kallisti: As a general pattern, you run into choppy waters when you want to say "A list/set ts such that neither t1 nor t2 are members"
10:59:01 <acowley> kallisti: Yes, it should be a set
10:59:19 <acowley> kallisti: But I think the notation starts getting rather cramped even when you do that.
10:59:30 <tobiasBora> Hjulle: The Stack tool contains cabal or not ?
10:59:42 <acowley> kallisti: The order can be relaxed, btw
10:59:55 <Hjulle> tobiasBora: It does.
10:59:56 <kallisti> what happens when you promote an existential exactly?
11:00:25 <Shockk> hmm speaking of promotion, I have a question
11:00:28 <acowley> kallisti: You can see we use ∈ sometimes, there are also equivalence operators that factor out ordering.
11:00:30 <tobiasBora> Hjulle: Ok thank you, I will try !
11:00:42 <acowley> kallisti: I'm not sure if the relevant ones are in Frames or Vinyl
11:01:29 <Shockk> how come there are no promoted char literals but there are promoted string literals?
11:01:30 <ReinH> :(
11:01:37 <Shockk> :k "test"
11:01:38 <lambdabot> GHC.TypeLits.Symbol
11:01:39 <acowley> kallisti: The point is, you can build up a set of handlers, then tell GHC something like "handle :: (ts ≡ hs) => Expression ts -> Handlers hs -> Whatever"
11:01:42 <Shockk> :k 'a'
11:01:43 <lambdabot> parse error on input ‘'’
11:02:44 <acowley> kallisti: And you deal with the reordering by calling "rcast" (from Vinyl)
11:02:57 <kallisti> ≡  is type equality right?
11:03:14 <ReinH> @tell shersh WriterT example: http://lpaste.net/1181790135876845568
11:03:14 <lambdabot> Consider it noted.
11:03:15 <Shockk> [] is promoted so having char literals would allow strings to be '[Char] 
11:03:19 <acowley> kallisti: No, it's from Vinyl: http://hackage.haskell.org/package/vinyl-0.5.1/docs/Data-Vinyl-Lens.html
11:03:22 <Shockk> or something like that
11:03:28 <acowley> kallisti: It's a short form for REquivalent
11:03:49 <acowley> kallisti: It's specifically for dealing with this list/set tension
11:03:49 <kallisti> oh I see structurally equivalent
11:03:51 <acowley> yes
11:04:50 <acowley> Set membership plumbing is annoying in every language I've worked with
11:05:49 <kallisti> it would be pretty interesting to promite typeclasses to kind constraints I think
11:05:53 <kallisti> *promote
11:05:55 <acowley> It's frustrating because it seems like an accident of the way the types are formulated in whatever DT language you're using, but it's probably above my pay grade
11:06:05 <ReinH> acowley: o/
11:06:13 <acowley> ReinH: \o
11:06:15 <joco42> is anyone using emacs+ghc-mod to include explicit import statements for a function?
11:06:26 <acowley> joco42: yes
11:06:44 <joco42> acowley: i try to get it work and it tells me : 
11:06:59 <joco42> https://usercontent.irccloud-cdn.com/file/PR3VeWFS/Screen%20Shot%202015-10-16%20at%2020.59.57.png
11:07:10 <kallisti> acowley: I'm trying to wrap my head around what happens when you promote an existential. is it even possible?
11:07:20 <joco42> No module guessed
11:07:56 <KaneTW> kallisti: wait for dependenthaskell
11:08:16 <acowley> joco42: Where is printTest defined?
11:08:23 <KaneTW> should be much easier to promote typeclasses to the kind level there, as there is no kind level anymore
11:08:25 <acowley> joco42: I'm not sure what the limits of ghc-mod are 
11:08:53 <acowley> joco42: But you can try typing in a name like foldl', then see what ghc-mod says about that error. If it suggests Data.List, then things are working
11:08:54 <joco42> acowley: it is defined in Svg.IO.IO
11:09:00 <acowley> joco42: Oh
11:09:08 <acowley> joco42: So it's already in scope?
11:09:13 <joco42> yeah that kind of stuff work...
11:09:23 <joco42> yeah it compiles
11:09:28 <acowley> joco42: I don't think it does what you want it to
11:09:33 <joco42> i just wanna make the import explicit
11:09:51 <joco42> oh no....
11:09:54 <acowley> joco42: That would be hard for it to do as there may be other imported identifiers
11:10:13 <acowley> joco42: What you can do is comment out the import, and let ghc-mod manage the explicit imports
11:10:21 <quchen> edwardk: Thanks for the update.
11:10:21 <joco42> hmmm
11:10:23 <joco42> i see
11:10:34 <joco42> let me see
11:10:44 <acowley> joco42: Which ideally will just involve a bunch of M-t, C-x C-s, M-n, M-t, ....
11:11:04 <joco42> ok
11:11:07 <acowley> kallisti: I think everything's possible
11:11:33 <kallisti> that's a nice mentality to have for life, I think.
11:11:40 <roelof> any people here which are good in math ?
11:12:12 <joco42> No module guessed
11:12:17 <joco42> acowley: well
11:12:41 <acowley> joco42: What if you put empty parentheses after the import?
11:12:44 <joco42> so i cannot just turn every import into an explicit import in some magical way?
11:12:46 <acowley> joco42: Can it find them then?
11:12:50 <joco42> lemme se
11:12:52 <joco42> e
11:13:10 <acowley> joco42: I don't know of a way to make all imports explicit after the fact.
11:13:19 <roelof> I have to write a function which calculates the outcome of smallerRoot (( -b - sqrt( b * b - 4 * a * c)/ (2 * a) and largerRoot the same but then - becomes a +  
11:13:34 <acowley> joco42: It's more than reasonable to want to do it, though
11:13:51 <acowley> joco42: Make a PR to ghc-mod! :)
11:14:03 <joco42> acowley: yeah :)
11:14:05 <joco42> indeed
11:14:07 <roelof> According to the exercises this is true :  one thing you would expect is that the result of the first function is less than 
11:14:28 <acowley> quchen: You need to come to the US meetups for the other mob!
11:14:55 <quchen> acowley: See my followup mail. Really, "mob" was the wrong word.
11:15:04 <newbLeon> Damn there are meetups. Shame im in the uk
11:15:10 <roelof> but when I do it with these numbers -1.0e-45 2.649814e-23 0.0 then smallerRoot is 6.6784346e21 and largerRoot is -6.6784346e21
11:15:15 <acowley> quchen: I hope everyone took it the right way
11:15:16 <quchen> newbLeon: Haskell Exchange just happened
11:15:27 <roelof> Is the text in the exercise wrong or something in my code ? 
11:15:46 <newbLeon> Roelof did you try it on ghc?
11:15:50 <joco42> acowley:  m0rphism told that emacs can do magic like this...
11:15:56 <joco42> with ghc-mod
11:16:07 <roelof> newbLeon:  yes, that why I had the outcomes of both functions
11:16:09 <joco42> is that right, m0rphism ?
11:16:46 <quchen> acowley: The problem with US meetings is that the Atlantic is in the way. :-)
11:16:51 <kallisti> acowley: now that I've added an overloadable config typeclass in webdriver I might add a Config.Vinyl submodule. I think that's a nice compromise between supporting new lens/record libraries and vanilla records
11:16:59 <acowley> quchen: We're working on that. Anything is possible!
11:17:05 <newbLeon> You cant just write -b - sqrt try ((-b) - sqrt etc.....
11:17:12 <kallisti> will help me learn vinyl as well
11:17:22 <Shockk> quchen: I do have that problem myself occasionally
11:17:23 <joco42> http://ircbrowse.net/browse/haskell?id=21601014&timestamp=1444547185#t1444547185 < here, acowley  and m0rphism 
11:17:26 <acowley> kallisti: You should write your own vinyl at some point
11:17:42 <acowley> kallisti: Just to get yourself going, then swap over to vinyl for some agreement on names
11:17:56 <roelof> a try is a formala . I never seen it in haskell functions 
11:18:11 <acowley> kallisti: It's a very simple pattern, and I'm sure playing with it will increase your comfort level
11:18:15 <newbLeon> Roleof give me a min, let me try out your functikn
11:18:29 <joco42> http://ircbrowse.net/browse/haskell?id=21601029&timestamp=1444547538#t1444547538 < acowley , m0rphism 
11:19:42 <acowley> joco42: I think that's the simpler form of adding an explicit import for an unknown identifier
11:19:45 <joco42> this is what i get with () https://usercontent.irccloud-cdn.com/file/0wsa1AW0/Screen%20Shot%202015-10-16%20at%2021.18.47.png
11:19:51 <acowley> joco42: But the feature you want could totally be done
11:20:13 <acowley> Now that's a bit frustrating
11:20:37 <acowley> joco42: I feel like ghc-mod has a chance at figuring that one out
11:20:45 <joco42> acowley: does that work for you ?
11:20:47 <joco42> anyone ?
11:20:58 <joco42> for anyone ?
11:21:17 <joco42> i asked this at #ghc-mod, the channel is super quiet....
11:21:48 <acowley> joco42: It doesn't work for me either
11:21:49 <acowley>  
11:21:49 <acowley>  
11:22:04 <joco42> acowley: ok, then that is reassuring....
11:22:12 <joco42> then it is not just my setup...
11:22:15 <sena-kun> Hi folks. I have a rather complex record type with nested types. One of this nesting fields is IORef(I know I need it) that points to list of other record type variable. But my code that should modify this IORef don't work - not in do-form, not after desugaring. Is there any known problems about dealing with IORef in nested types? I can show code, of course.
11:22:38 <acowley> joco42: It'd be good to figure out which variant of this functionality would be most useful
11:22:40 <joco42> acowley: then is just do this explicit import stuff by hand...
11:22:56 <kallisti> https://hackage.haskell.org/package/webdriver-0.8.0.3/docs/Test-WebDriver-Capabilities.html#t:Capabilities so I need to change this record a specific way so that it supports two different purposes
11:22:58 <shapr> now that es6 has tail call optimization, I think GHC needs an es6 backend
11:23:05 <joco42> but yeah... this is a good coding style , acowley 
11:23:13 <joco42> explicit imports
11:23:30 <acowley> joco42: That is, make all implicit imports explicit at once. Or incrementally expand an import starting from ().
11:23:35 <acowley> joco42: I kind of like the latter idea
11:23:47 <kallisti> when the client is sending this record to server (as serialized JSON) each of the Maybe Bool fields need to be something like: Required Bool | Desired Bool | Unspecified
11:23:50 <acowley> joco42: And it seems like ghc-mod might be able to do it
11:24:17 <kallisti> when parsing from the server and construct the record, it needs to be something like:  Actual Bool | Unspecified   (essentially Maybe)
11:24:31 <roelof> newbLeon:  any news on my matter ? 
11:24:38 <kallisti> I want a GADT here right?
11:24:41 <joco42> acowley: i dunno how ghc-mod works on the inside but i think it has all the knowledge what ghci has... so yeah
11:25:08 <joco42> acowley: maybe hare does this?
11:26:38 <fizbin> Hey, does anyone know what URL cabal-install uses to download the latest list of packages from hackage when you do "cabal update"? Specifically, does anyone know if cabal-install downloads that file over https?
11:26:50 <sena-kun> Fix: under "don't work" I mean "don't change state of list", but syntactically code is correct.
11:27:55 <kallisti> fizbin: believe you can find that in the config file under your cabal installation directory
11:28:24 <acowley> joco42: It's in ghc-mod. You can see lookupSymbol
11:28:24 <acowley>  
11:28:43 <acowley> joco42: I think the problem is that it's not updating the symbol database
11:29:03 <acowley> joco42: perhaps that can be tweaked without making everything terrible
11:29:03 <joco42> acowley: where is lookupSymbol?
11:29:12 <kallisti> fizbin: my config says remote-repo: hackage.haskell.org:http://hackage.haskell.org/packages/archive
11:29:17 <newbLeon> Dude code is correct, the algorithm isnt
11:29:25 <acowley> joco42: https://github.com/kazu-yamamoto/ghc-mod/blob/master/Language/Haskell/GhcMod/Find.hs
11:29:30 <newbLeon> I mean it compiles
11:29:30 <fizbin> kallisti: Thanks
11:29:46 <roelof> newbLeon:  do you mean my code ? 
11:30:43 <newbLeon> Yes
11:30:50 <joco42> acowley: i am kinda lost, what does this mean in practice? this lookupSymbol thing ?
11:31:32 <roelof> so the book is incorrect newbLeon 
11:31:38 <jophish> hmm, I wonder if it would be possible to do a mathjax quasiquoter
11:31:46 <jophish> typeset math -> expression
11:32:09 <acowley> joco42: So, here it creats a new symbol database and passes that to the command loop: https://github.com/kazu-yamamoto/ghc-mod/blob/master/src/GHCMod.hs#L418
11:32:33 <acowley> joco42: (I'm just tracing through this myself, I don't actually know how to do what we're talking about)
11:33:05 <joco42> acowley: ok, hmmm
11:33:16 <bitemyapp> roelof: although I did recommend Craft of FP at the time we talked, my book has caught up to what it covers and then some.
11:33:28 <joco42> maybe then it's only just me... 
11:33:39 <joco42> who wants to do this kind refactoring
11:33:57 <joco42> maybe this is more of a hare thing
11:34:12 <acowley> joco42: hare will need ghc-mod to do this
11:34:12 <roelof> oke, so I can better use your book and forget about Craft bitemyapp 
11:34:52 <joco42> acowley:  hmmm, i wonder maybe hasktags would help
11:34:58 <kuznero> Hi All!
11:35:24 <joco42> acowley: it finds the location of a given identifier...
11:35:50 <bitemyapp> roelof: so at this point, it's between free and not-free resources.
11:36:36 <roelof> bitemyapp:  Craft is also non free 
11:39:28 <bitemyapp> roelof: yep.
11:41:22 <tnks> does the desire to have laws for our type classes speak more to the limitations of our type systems than lawfulness as an ideal?
11:41:22 <roelof> bitemyapp:  so the choice between craft and your book is not about free or non free 
11:46:12 <bitemyapp> roelof: that wasn't the contrast I was drawing in this case, but you're right about that.
11:46:26 <bitemyapp> roelof: generally if someone needs free resources only, the recommendation for cis194 -> NICTA course holds.
11:46:47 <bitemyapp> roelof: if they're willing to buy a book, my own has a ton of content now so I think it's ready for most people.
11:46:58 <bitemyapp> when the book was less complete, I did not recommend it.
11:48:22 <roelof> oke, I tried CIS194 but was missing some background so on the second week exercise I could not continue 
11:48:35 <roelof> that why I took the advice to read a book 
11:49:04 <bitemyapp> roelof: yeah, which makes sense.
11:49:50 <LudicTortoise> <bitemyapp> How would you compare the learn.hfm.io tutorials with the book you are writing?
11:50:06 <roelof> but thanks for the help, Going to bed  . Very tired 
11:51:23 <bitemyapp> LudicTortoise: http://learn.hfm.io/books.html they actually recommend our book
11:51:32 <bitemyapp> LudicTortoise: but you're asking me to compare two totally different sorts of things.
11:51:48 <LudicTortoise> Ah, not the same peeps.... of course not, I apologize.
11:51:53 <bitemyapp> LudicTortoise: our book is currently 800 pages, probably 1200+ when it's finished. It's extremely thorough and aggressively tested with reviewers and learners.
11:52:40 <bitemyapp> LudicTortoise: the hfm tutorials are decent, but they're not a complete course.
11:53:04 <LudicTortoise> Okay. I think I will support it then. I am currently taking the fp101x Erik Meijer class, so I think I will dive into the book after that
11:53:40 <bitemyapp> LudicTortoise: I would _strongly_ recommend you skip FP101x.
11:54:05 <bitemyapp> LudicTortoise: http://bitemyapp.com/posts/2014-12-31-functional-education.html I provide some explanation here, but it's one of the most consistently unsuccessful courses for learning FP or Haskell.
11:55:38 <LudicTortoise> Alright. I'll take that recommendations seriously. I read through the sample and found it very approachable. I prefer reading through books anyways, since I find Meijer's style a bit draining. Thank you.
11:56:12 <bitemyapp> LudicTortoise: cheers. Don't forget to send us questions or ping us about problems at the support line. http://haskellbook.com/support.html
12:06:51 <Tuplanolla> I just got "Oops!  Entered absent arg arr2 Array D DIM2 Double" from Repa and I have no idea why. I don't even use parallel strategies.
12:08:58 <Tuplanolla> It doesn't happen if I don't compile with "-fno-liberate-case -funfolding-keeness-factor1000 -funfolding-use-threshold1000".
12:12:00 <Tuplanolla> Feels like a compiler bug, but I wouldn't know.
12:14:25 * hackagebot mida 0.4.5 - Language for algorithmic generation of MIDI files  https://hackage.haskell.org/package/mida-0.4.5 (mrkkrp)
12:15:25 <quicksilver> xml-conduit - any users?
12:15:50 <quicksilver> am I right in guessing that it only does "conduit stuff" if you use the Stream.Parse interface
12:17:02 <dblarons> How do I run a function of type `State Database (Maybe String)` from within a function of type `StateT Database IO ()`?
12:17:17 <dblarons> I can do it by using get & put, but there has to be a better way.
12:17:31 <dblarons> get, runState, and then put, that is...
12:17:59 <nitrix> Is there such thing as first-class types? I have a mental model of how it'd work but nothing that I know to compare it to.
12:18:15 <Tuplanolla> This seems to be a strictness analyzer bug. I guess I'll have to file a report later.
12:18:42 <quicksilver> dblarons: you can use "state" with "runState"
12:19:16 <quicksilver> dblarons: did you write the State action yourself, out of interest?
12:19:36 <quicksilver> :t state . runState
12:19:37 <lambdabot> MonadState s m => State s a -> m a
12:20:02 <quicksilver> ^^ that type embeds a concrete 'State' action in any Monad which supports MonadState, including your example.
12:20:16 <quicksilver> nitrix: you mean types as a first-class value?
12:20:33 <lpaste> yyyyy pasted “renaming “type” on JSON for Aeson” at http://lpaste.net/143143
12:20:33 <dblarons> quicksilver: Not sure what you mean by "write the State action yourself"... I'm using the State monad and StateT transformer from the Control package.
12:20:38 <quicksilver> nitrix: that is a typical (although not guaranteed) feature of dependently typed languages
12:20:46 <quicksilver> dblarons: I mean it's your code.
12:21:23 <nitrix> quicksilver: I see.
12:21:33 <quicksilver> dblarons: if it is the you could consider writing it to have the type 'MonadState Database m => m (Maybe String)'; it is no extra work to give it the more general type and then you will be able to use it transparently in either context
12:21:49 <nitrix> Like, it'd be great if type declarations would let you do `product` or `sum` of other types, build arbitrary complex things and those functions would have type :: [Type] -> Type or similar.
12:22:15 <nitrix> That would require the compiler to execute code though, right? I'm not found of "super compilers".
12:22:22 <quicksilver> you can do some of that with recent GHC extensions, nitrix 
12:22:30 <nitrix> Template Haskell?
12:22:34 <quicksilver> no
12:22:53 <quicksilver> nitrix: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/promotion.html
12:23:10 <quicksilver> I have not used this feature though so I can't advise you on it.
12:23:30 <nitrix> quicksilver: Anyway, so the field for this is dependently type systems, right? I just needed a direction.
12:23:43 <quicksilver> but for examples of how other people have used it, see the 'hvect' and 'vinyl' packages on hackage
12:23:47 <dblarons> quicksilver: Brb have to wrap my head around this.
12:25:31 <nitrix> Second question, does the kind # can substitute a kind * ? Given the type constructor `* -> *`, can `#` be used here, or do I need a transformation from `# -> *` ?
12:27:00 <quicksilver> it cheats, nitrix 
12:27:10 <quicksilver> although # and * are not substitutable in general
12:27:17 <quicksilver> there is a special case for function application
12:27:19 <quicksilver> to make it work
12:27:20 <DanielDiaz> when instantiating a type to Pointed and/or Copointed, are there any laws associated?
12:27:38 <quicksilver> DanielDiaz: no, which some people claim makes them doubtful as classes.
12:27:55 <nitrix> quicksilver: Thanks. Appreciated.
12:29:23 <DanielDiaz> quicksilver: oh, ok, thanks
12:29:34 <volothamp> Can anyone help me installing hsc2hs using stack? `stack install hsc2hs` fails
12:30:16 <jophish> volothamp: This is an appropriate channel, but there's also #haskell-stack
12:30:30 <volothamp> jophish thanks for the suggestion, I'll ask there
12:30:58 <jophish> volothamp: It's quite a bit less busty then here, so it might take a little longer for a response
12:31:04 <jophish> than*
12:31:06 <jophish> busy*
12:31:26 <volothamp> :)
12:45:05 <clrnd> #haskell-stack exists? woah
12:46:12 <volothamp> clrnd yeah but it seems quite dead though
12:46:32 <clrnd> volothamp, well stack is getting old
12:46:45 <volothamp> is it? :D
12:46:47 <clrnd> :P
12:47:22 <volothamp> anyway, if anyone is interested, seems like it's difficult to build hsc2hs with stackage/stack..
12:47:37 <clrnd> volothamp, let me help, what's the error?
12:47:49 <volothamp> https://gist.github.com/lucamolteni/cdcc89523fe16f0bda89
12:48:17 <volothamp> it seems like every stack is too young for hsc2hs
12:48:38 <clrnd> heh
12:49:18 <volothamp> anyway, fortunately hsc2hs is only a binary. I may obtain it by compiling using cabal-install
12:49:40 <clrnd> volothamp, try downloading the project and building it there with stack
12:49:48 <clrnd> (I'd do that)
12:50:08 <volothamp> clrnd nice idea thanks
12:50:11 <clrnd> stack unpack hsc2hs maybe
12:50:29 <clrnd> there you can try using an older lts version in the project's stack.yaml
12:50:44 <clrnd> or just pinning the older versions in extra-deps
12:51:10 <volothamp> I never converted a project to Stack, let me try that :)
12:52:17 <clrnd> stack init! 
12:54:12 <bollu> guys, If I have a typeclass called "Group", how do I encode the symmetric group Sn?
12:54:19 <bollu> like, it'll be what, Group (Endo a) ?
12:54:33 <bollu> as in, how do I encode the "letters" for the symmetric group
12:54:39 <bollu> I'm sort of confused about how to represent it
12:54:50 <bollu> Group ([a] -> [a]) seems decent, maybe?
12:55:39 <quicksilver> well two points, bollu 
12:55:51 <quicksilver> one is you probably want to restrict to lists of a fixed length
12:56:02 <quicksilver> and the other is that you really only want the invertible functions
12:56:06 <Hafydd> bollu: Endo a needn't be bijective, so I wouldn't do that.
12:56:19 <bollu> Hafydd: oh, right. I need inverses as well
12:56:25 <bollu> quicksilver: so how do I encode it?
12:56:30 <quicksilver> presumably to make your group instance you're going to need an explicit way to calculate the inverse
12:56:39 <bollu> newtype Bijection a = (Endo a, Endo a) ?
12:56:43 <bollu> yes, I'll have that
12:56:54 <quicksilver> actually either choice is possible
12:57:01 <quicksilver> you can store both halves explicitly
12:57:16 <quicksilver> or you can just calculate the inverse by applying the permutation to [1,2,3,4,5,6,7]
12:57:34 <quicksilver> and complaining loudly (with 'error') if it turns out not to be a permutation.
12:57:47 <bollu> ooh, I like that approach
12:58:05 <bollu> but I was hoping to type-level enforce it
12:58:18 <bollu> I'm writing my first haskell package - something for algebraic graph theory :)
12:58:22 <monochrom> the type will not enforce "this function is invertible" either
12:58:28 <quicksilver> haskell is not well suited for enforcing arbitrary mathematical constraints at the type level
12:58:34 <quicksilver> since Sn is a finite construct
12:58:37 <quicksilver> it's clearly possible
12:58:37 <bollu> So, graph rendering using diagrams + group actions and graph automorphisms
12:58:41 <quicksilver> but it might be a *lot* of work.
12:58:52 <bollu> huh, very well then
12:59:03 <bollu> I want to use QuickCheck to enforce constraints as well
12:59:05 <quicksilver> you could, for example, come up with an enumeration of Sn
12:59:06 <bollu> any tips on that?
12:59:08 <monochrom> haskell is just a programming language, not a theorem statement language, despite how [ x+1 | x<-[1..10] ] look like set notation
12:59:24 <quicksilver> and just store the index into that enumeration as your representation
12:59:54 <quicksilver> but even then, you'd still have type system permitting numbers bigger than n!
13:00:08 <Zekka> QuickCheck also won't enforce anything because doing so would require solving the halting problem afaik
13:00:18 <bollu> quicksilver: so you're saying, have something like createSym :: ([a] -> [a]) -> Symmetry a, where Group(Symmetry a) exists?
13:00:27 <Zekka> ultimately this stuff is going to come down to using your own intelligence
13:00:28 <quicksilver> yes
13:00:36 <monochrom> if you just settle with using QuickCheck to test bijections, \x -> f (g x) == x && g (f x) == x
13:00:39 <quicksilver> a "smart constructor" bollu
13:00:48 <quicksilver> which complains if the function you give it is not a permutation.
13:01:01 <Zekka> I usually only go to the trouble to try to enforce stuff I know that I'm not personally going to be able to keep myself honest about with that much accuracy (e.g. the advantage of Maybe)
13:01:16 <quicksilver> there is a small higher rank trick you can do here bollu 
13:01:17 <bollu> quicksilver: nice. monochrom: I'd probably like to test for closure against the set of symmetries as well. 
13:01:19 <Zekka> more verification is not always better
13:01:21 <bollu> quicksilver: go on
13:01:34 <quicksilver> createSym :: (forall a. [a] -> [a]) -> Symmettry
13:01:43 <quicksilver> that restricts things a tiny bit
13:01:48 <bollu> quicksilver: what is "Symmetry" here?
13:01:59 <quicksilver> because after all permutations must act without needing to know the types of the elements
13:02:11 <bollu> oh, crap, the "a" doesn't leak out
13:02:13 <quicksilver> you might need to specify the size tho
13:02:14 <bollu> hmm
13:02:18 <quicksilver> that's deliberate, yes
13:02:29 <bollu> and Symmetry is what, exactly in this construction?
13:02:36 <quicksilver> Symmetry (yay I spelt it right this time) is a type you'd have to define
13:02:56 <quicksilver> there are lots of possible representations
13:03:17 <quicksilver> data Symmetry = forall a . Symmetry ([a] -> [a])
13:03:28 <quicksilver> data Symmetry = Symmetry ([Int])
13:03:41 <quicksilver> data Symmetry = forall a . Symmetry ([a] -> [a],[a] -> [a])
13:03:45 <quicksilver> are three which spring to mind.
13:03:53 <monochrom> wait a second, "data Symmetry = forall a . Symmetry ([a] -> [a])" is not going to be usable.
13:04:06 <quicksilver> I have a feelin you'll want to store the Int in there too, to be honest
13:04:08 <bollu> monochrom: why not? because I can never "invoke" it?
13:04:10 <quicksilver> (the 'n' from your Sn)
13:04:30 <quicksilver> monochrom: why not? you can invoke it on [1,2,3,4,5] and observe what it does
13:04:34 <bollu> quicksilver: or I can generate it (order of the permutation should work)
13:04:47 <monochrom> I have done it in my head. it is a type error.
13:04:49 <quicksilver> ...which is why my second idea is just to store an [Int]
13:05:10 <dblarons> quicksilver: So I'm using this MonadState signature for the function (a) that is called by my StateT function (b)... does that mean that any subsequent functions called by (a) will have to have a MonadState signature as well?
13:05:28 <bollu> monochrom: where will it fail?
13:05:29 <quicksilver> not necessarily dblarons 
13:05:30 <monochrom> how about this: your position of "forall a" is wrong. you wrote an existential type
13:05:48 <shachaf> monochrom: It's usable.
13:05:56 <quicksilver> erm
13:06:09 <shachaf> You give it an empty list, and it gives you a list of values, possibly nonempty.
13:06:15 <quicksilver> did I mean data Symmetry = Symmetry (forall a . [a] -> [a]) ?
13:06:20 <monochrom> yes
13:06:20 <shachaf> Then you can construct lists out of those values.
13:06:36 <shachaf> I guess that wasn't the intent. But you could make an interesting type that way.
13:06:43 <bollu> okay, I'm confused. The difference between the two constructions of quicksilver being..?
13:07:10 <quicksilver> one is an existential type (haskell's syntax for existential types is a bit odd); the second is a normal forall nested inside the type.
13:07:24 <dblarons> quicksilver: It seems like I'll just be writing signatures with MonadState instead of StateT but that StateT will be the `m` parameter in the MonadState
13:07:33 <quicksilver> dblarons: often yes
13:07:35 <shachaf> quicksilver: It doesn't seem too odd.
13:07:36 <bollu> quicksilver: how is data Symmetry = forall a . Symmetry ([a] -> [a]) an assertion of "there exists an 'a' such that..."
13:07:52 <quicksilver> bollu: it's easier to look at the types of the constructors
13:07:56 <quicksilver> in one case it would be
13:08:11 <shachaf> If you say "data T = T Int", it means that if x :: Int, T x :: T
13:08:15 <quicksilver> Symmetry :: forall a . ([a] -> [a]) -> Symmetry
13:08:18 <quicksilver> in the other
13:08:19 <reactormonk> Best way to replace character "~" at the start of a string with the output of a function? What function should I look at?
13:08:27 <quicksilver> Symmetry :: (forall a . [a] -> [a]) -> Symmetry
13:08:28 <shachaf> If you say "data T = forall a. T a", it means that, for all types a, if x :: a, T x :: T
13:08:41 <dblarons> quicksilver: Okay, I'll move forward with that approach then.
13:08:45 <dblarons> Thanks!
13:09:20 <bollu> quicksilver: I wish I could tell the difference. From what I can see, in the latter, the "forall" is scoped to the [a] -> [a], so it cannot leak out to the Symmetry
13:09:37 <bollu> whereas in the former, the forall a. … binds to the Symmetry as well?
13:09:44 <bollu> I don't know if that analysis is completely wrong
13:10:01 <quicksilver> bollu: one says, to construct this value, you may choose any 'a' of your choice and give me a function [a] -> [a]
13:10:24 <quicksilver> bollu: the other says, to construct this value, you must give me a polymorphic function ([a] -> [a]) which will work for any 'a' at all that I might choose.
13:11:21 <bollu> hmm.. So, because the (forall a . [a] -> [a]) is airgapped, the function [a] -> [a] is forced to have "zero knowledge" about "a" and is hence polymorphic?
13:13:20 <quicksilver> I'm not sure about airgapped but you've come to the right conclusion so perhaps your intuition has it right :)
13:13:22 <bollu> whereas in the former, Symmetry :: forall a . ([a] -> [a]) -> Symmetry, because the "forall a" is not applied purely to [a] -> [a], it acts as a "there exists" ?
13:13:23 <lpaste> quicksilver pasted “Symmetry” at http://lpaste.net/143151
13:13:34 <quicksilver> bollu: ^^ just to prove this idea works.
13:13:44 <lrocksmashtime> what's it called when you have a data type that has no body? like "data Something" and nothing else. This requires some haskell extension and i can't remember what it's called. 
13:13:55 <quicksilver> lrocksmashtime: EmptyDataDecls
13:13:59 <lrocksmashtime> sick
13:14:01 <bollu> coool
13:14:05 <lrocksmashtime> thanks quicksilver
13:14:20 <bollu> quicksilver: could you explain existentials again?
13:14:27 <quicksilver> bollu: however I think you really want to have the size enforced somewhere
13:14:41 <quicksilver> because you can apply my 'rot3' to a 7 element list
13:15:07 <quicksilver> and whilst there is a logical notation of S3 acting on the first 3 elements of a 7 element set I still think this is not quite the abstraction you wanted.
13:15:12 <bollu> yep, I think I'll compute the order of the permutation
13:15:16 <bollu> and verify that at runtime
13:15:29 <quicksilver> to be a real Group you'd want the size of the permutation to be in the type
13:15:40 <quicksilver> which is possible but mildly painful in haskell
13:15:43 <bollu> I don't think haskell lets you have "type leve" integers?
13:15:46 <bollu> oh, really? how?
13:15:53 <quicksilver> well there is an old haskell 98 trick
13:16:00 <bollu> trick or hack? :)
13:16:05 <quicksilver> trick
13:16:14 <quicksilver> data Z
13:16:15 <bollu> I'm all ears
13:16:21 <quicksilver> data S n = S n
13:16:30 <tsahyt> There's also GHC.TypeLits now
13:16:33 <quicksilver> then you use the type S (S (S (Z)))
13:16:38 <quicksilver> to represent the number 3
13:16:45 <quicksilver> but it's fairly hard to work with
13:16:53 <bollu> aren't you constucting the successor function in type level?
13:16:56 <bollu> that's pretty cool
13:16:58 <quicksilver> and, more recently, GHC has slightly more 'direct' support for this kind of trick.
13:17:13 <quicksilver> which is what tsahyt just said.
13:17:21 <quicksilver> I've never used typelits in anger myself
13:17:33 <quicksilver> but if you just want to encode a small integer in the type
13:17:38 <quicksilver> so you can make a well-defined Group instance
13:17:41 <quicksilver> I think this is a simple enough case
13:17:54 <bollu> hm, yes.
13:18:09 <bollu> My god, I'm intimidated to publish my package now :( There's so much I don't know
13:18:15 <bollu> what if it turns out to be pointless?
13:18:18 <quicksilver> haha
13:18:36 <tsahyt> I've been playing around with them for a while now and I actually rather like them. In many ways I prefer them over the Peano encoding trick, but occassionally some things are a bit harder to do with them
13:18:40 <quicksilver> if you learn something yourself in the process it isn't pointless is it?
13:18:49 <bollu> true :)
13:18:52 <Black0range> Hello! Pretty trivial question but... If i make a Module directory Say MyModule are there some way i can make it such that it import a specific file from that directory? say "import Modules.MyModule" imports "Modules.MyModule.MyModule" or something ?
13:18:54 <FireFly> well, whether it's pointful or pointless is a matter of code style, isn't it?
13:19:11 <bollu> haskell doesn't have anything related in the ecosystem, right? I looked around for stuff to contribute to
13:19:19 <tsahyt> I've actually been thinking about collecting some type level functions like gcd and so on and put them in a package for use with GHC.TypeLits. I've searched hackage but haven't found anything like it yet
13:20:43 <bollu> can I leave data Z empty?
13:20:48 <clrnd> Black0range, relative imports? afaik no
13:21:00 <bollu> also, matter of taste, shouldn't it be data Zero or something? :)
13:21:16 <tsahyt> bollu: Yes, it can be empty. Whether you call it Z or Zero is up to you
13:21:34 <tsahyt> Unless of course you want to have values of that type for whatever reason, then you need a constructor
13:21:47 <Black0range> clrnd: Would the best solution be to make a MyModule.hs file in the same levels as i put the MyModule directory? 
13:22:16 <clrnd> Black0range, I;m not sure what you are trying to accomplish, that will work yeah
13:22:34 <bollu> quicksilver: if I use the type level number encoding
13:22:38 <bollu> won't the error messages suck?
13:22:44 <Black0range> clrnd: project getting messy need to tidy up a bit :)
13:22:59 <bollu> like, I'll get "type error" rather than "length of permutations do not match"
13:23:30 <the_2nd> When to use **2 and when ^2 ?
13:23:41 <quicksilver> bollu: yes but on the plus side you're getting the errors at compile time
13:24:03 <bollu> quicksilver: does TypeLists have better error messages?
13:24:10 <bollu> quicksilver: yes, but, ergonomics as well :/
13:24:12 <clrnd> the_2nd, https://wiki.haskell.org/Power_function
13:24:14 <quicksilver> bollu: it's a fairly general problem haskell has with clever type-level tricks. It's cool that it's checked statically (i.e. by the compiler) but the error message is at a different abstraction level to the one you were programming at.
13:24:26 <quicksilver> bollu: I duno. Ask tsahyt ? :)
13:24:48 <bollu> tsahyt: does TypeLists give good errors for mismatched lengths?
13:24:48 <quicksilver> bollu: by the way I think [Int] is a simpler rep than (forall a.[a] -> [a])
13:25:01 <quicksilver> bollu: but they are isomorphic so storing either is fine.
13:25:02 <bollu> quicksilver: yes, but (forall a. [a] -> [a]) is cooler
13:25:18 <bollu> though I suppose you can always write a apply :: ([Int] -> [Int]) -> [a] -> [a]
13:25:26 <quicksilver> absolutely
13:25:34 <quicksilver> and the reverse is - already there :)
13:25:44 <tsahyt> bollu: In some way yes, but mostly just because of the syntactic sugar that it provides. Instead of S (S Z) it knows the literal 2, and there are type operators for +, -, *, and some other stuff, so the error messages use these
13:25:49 <quicksilver> not what you said, bollu 
13:25:52 <shachaf> Why is [Int] isomorphic to (forall a. [a] -> [a]) here?
13:25:59 <quicksilver> apply :: [Int] -> [a] -> [a]
13:26:08 <quicksilver> shachaf: because you simply record its effect on [1..n]
13:26:14 <bollu> oh, right because you're using the indeces
13:26:15 <bollu> right
13:26:17 <quicksilver> shachaf: I should point out I'm working under various quotients
13:26:19 <tsahyt> bollu: So the same message becomes more readable, but it's still the same message as far as I know
13:26:24 <quicksilver> shachaf: it's not the full type in either case.
13:26:31 <shachaf> Ah.
13:26:52 <quicksilver> shachaf: it's "[Int] which is a permutation of [1..n]" vs "[a] -> [a] which is a permutation"
13:27:07 <quicksilver> shachaf: which constraints we would enforce by a smart constructor (either way)
13:27:58 <bollu> tsahyt: hm
13:28:30 <bollu> this is fun. I love haskell for stuff like this
13:28:56 <bollu> Also, I need nice symbols for group operations :( (*) is already taken, as is (-)
13:29:02 <bollu> I was eyeing (@@) maybe
13:29:24 <quicksilver> |*| perhaps
13:29:38 <quicksilver> you can't have a unary negation, '-' is super special magic
13:29:41 <tsahyt> <+>?
13:29:53 <bollu> tsahyt: it's difficult to type, right?
13:29:58 <quicksilver> but you can of course have subtraction
13:30:00 <tsahyt> Depends on your keymap I suppose
13:30:24 <tsahyt> All those <$>, <*>, <>, etc have taught me to type it quickly, and I think <+> isn't that widely used yet
13:31:10 <bollu> hm
13:31:12 <bollu> I'll pick it up then
13:31:26 <tsahyt> Oh wait, <+> is actually used in Control.Arrow
13:31:30 <quicksilver> yeah
13:31:31 <bollu> and how do I create a unary negation?
13:31:33 <monochrom> :)
13:31:33 <quicksilver> all the <> stuff is
13:31:33 <bollu> bummer :/
13:31:40 <bollu> <> is monoid
13:31:44 <quicksilver> bollu: it will have to be made of words
13:31:45 <bollu> which may work, actualy
13:31:56 <quicksilver> if you decide to make group a subclass of monoid
13:31:57 <bollu> oh, like "neg" or something
13:31:58 <tsahyt> Every group is a monoid anyway, so there's that
13:32:00 <quicksilver> which is reasonable enough
13:32:03 <bollu> yeah, exactly
13:32:05 <quicksilver> then you can just use <> and mempty
13:32:07 <bollu> that was what I was thinking
13:32:08 <quicksilver> don't need new names
13:32:11 <bollu> exactly
13:32:15 <quicksilver> you just need to define inverse (or neg)
13:32:18 <bollu> I was thinking of maybe e = mempty
13:32:24 <bollu> as a shorthand
13:32:25 <monochrom> I propose "inv"
13:32:37 <bollu> I'll take it :)
13:32:53 <monochrom> "inv" is short, and is desirably ambiguous between "inverse" and "involution". :)
13:32:54 <tsahyt> Single letter function names are probably not a good idea, considering how much single letter variable naming is going on in Haskell, especially with mathy stuff
13:33:15 <bollu> tsahyt: good point.
13:33:27 <bollu> I also wanted to use TH for group represntations, with the grnrators
13:33:40 <bollu> like, be able to say G = <x, y | x^2, y^2, xy>
13:34:01 <bollu> dunno if I can even use TH for that >_<
13:34:05 <bollu> but I think I can
13:34:10 <bollu> rewrite that form, correct?
13:34:28 <hodapp> Just aim to find a happy medium between variables with less than 4 letters, and the way Java classes are named.
13:34:28 * hackagebot bloodhound 0.9.0.0 - ElasticSearch client library for Haskell  https://hackage.haskell.org/package/bloodhound-0.9.0.0 (bitemyapp)
13:35:18 <tsahyt> GroupInverseFactory
13:35:30 <tsahyt> Should probably be abstract though
13:36:20 <quicksilver> bollu: you can use quasiquoters for anything
13:36:47 <quicksilver> bollu: (in the sense that a quasiquoter can parse arbitrary text and transform it into arbitrary code and declarations)
13:37:14 <bollu> quicksilver: cool, that's awesome
13:37:17 <monochrom> more precisely, you can use quasiquoters for anything computable.
13:37:22 <bollu> quicksilver: what's their parsing power?
13:37:25 <tsahyt> Would a library of type level arithmetic functions for GHC.TypeLits be useful for anyone?
13:37:34 <bollu> tsahyt: maybe for me?
13:37:41 <monochrom> you write your own parser from scratch
13:37:42 <bollu> group embeddings and whatnot?
13:37:45 <bollu> monochrom: :O
13:37:53 <bollu> monochrom: that sounds tedious as hell, tbh
13:38:00 <tsahyt> Writing parsers is easy in Haskell
13:38:03 <quicksilver> bollu: you can just write an arbitrary chunk of haskell code as the parser
13:38:11 <bollu> quicksilver: oh, that makes it way simpler
13:38:14 <quicksilver> as tsahyt says, parsers are easy
13:38:18 <bollu> I thought you had to use TH voodoo to create the parser
13:38:23 <monochrom> the ups and downs of "anything computable"
13:38:28 <bollu> I loved the "convert failure to list of successes" :)
13:38:43 <dmj`> is [*] the kind for type level lists
13:38:46 <monochrom> ups: you can do anything computable! downs: you have to implement everything yourself!
13:38:47 <tsahyt> In fact it's so easy that regex is almost completely superflous in Haskell
13:38:57 <quicksilver> definitely superfluous
13:38:59 <quicksilver> (IMO)
13:39:21 <tsahyt> quicksilver: Unless you're providing regex functionality to the user, e.g. for search and replace or something
13:39:25 <quicksilver> regex is a tool for interacting with a user - it's a concise way for a user to specify text pattern matching (e.g. you are writing a file renaming application, or a text editor)
13:39:33 <jophish> quicksilver: regex might have better speed when the language is regular
13:39:33 <quicksilver> it is not a parsing tool for programmers
13:39:41 <quicksilver> except perl programmers
13:39:45 * quicksilver weeps bitter tears
13:39:46 <tsahyt> Aren't you a perl programmer?
13:39:51 <jophish> *almost certainly will
13:39:53 <quicksilver> yes.
13:39:58 <bollu> quicksilver: debatable. Sometimes regexes are really nice
13:40:09 <Tomsik> They're great for hacking things fast
13:40:18 <quicksilver> bollu: it is debatable. I was giving my opinion, but I stated it as fact.
13:40:26 <quicksilver> more concise that way :)
13:40:38 <monochrom> regex is not faster or slower. a regex library is faster or slower. and there are real-world examples of both.
13:40:44 <tsahyt> I find finite state machines really nice, but regexes not so much.
13:41:03 <bollu> how do I throw an error to the user if their permutation is wrong?
13:41:04 <quicksilver> Tomsik: when you get good at writing parsers, parsers are excellent for hacking things fast.
13:41:07 <bollu> runtime error*
13:41:31 <bollu> quicksilver: while parsec is slick, I still think that regexes have less "thinking" to do
13:41:38 <quicksilver> bollu: the dirty option is just to do: error "invalid permutation because ..."
13:41:40 <jophish> tsahyt: They're so nice for building DFAs though
13:41:48 <bollu> quicksilver: ins't that GHC limited?
13:41:56 <quicksilver> the cleaner option is to change the type of createSym
13:41:57 <bollu> quicksilver: and the nice way is?
13:42:02 <quicksilver> make it return Either String Symmetry
13:42:03 <bollu> Either monad?
13:42:05 <bollu> hm
13:42:10 <quicksilver> and then the user can properly handle the error
13:42:13 <bollu> right
13:42:15 <jophish> There's always regex-applicative, parser combinators, but restrcted to regular languages
13:42:22 <quicksilver> you can of course provide the unsafe alternative too
13:42:25 <quicksilver> it would be
13:42:28 <monochrom> for example, I read that several widely used regex libraries use a naïve backtracking way for | , and so they are the slow.
13:42:43 <quicksilver> unsafeCreateSym = either error id . createSym
13:42:48 <Tomsik> But you can control how backtracking works
13:42:52 <quicksilver> :t either error id
13:42:53 <lambdabot> Either [Char] c -> c
13:42:57 <Tomsik> like ?+ and stuff
13:43:08 <jophish> monochrom: a shoddy implementation will be slow if the language is regular or more complicated
13:43:33 <quicksilver> bollu: and, honestly, I have plenty of practice at both, and I would now say that parsers are less thinking. 15 years ago I would have defended regexp to the hilt.
13:43:49 <quicksilver> it's just practice and familiarity
13:44:04 <bollu> quicksilver: you've.. been programming for 15 years?
13:44:09 <jophish> but regular languages take fewer operations to parse than constext sensitive languages for example
13:44:30 <quicksilver> bollu: around twice that, actually
13:44:37 <jophish> well, I guess that's not an easy comparison to make
13:45:01 <bollu> quicksilver: so you're *at least*, like, 37 or something. Wow. I feel like a kid
13:45:22 <exio4> quicksilver: I envy you, I wasn't even a thing and you already were writing code! :P
13:45:29 <bollu> I know right!
13:45:58 <bollu> 	hm, I realize I'll need to check for uniqueness of array elements as well
13:46:02 <bollu> what's the nicest way to do that?
13:46:32 <Tomsik> regex != regular languages
13:46:42 <quicksilver> apply your permutation to [1,2,3..n]
13:46:43 <Tomsik> I mean, it should be the thing
13:46:45 <quicksilver> then 'nub' it
13:46:48 <quicksilver> and check the length
13:46:51 <quicksilver> should still have length n
13:47:03 <Tomsik> but perl disagreed and now implementations are turing complete and stuff
13:47:08 <bollu> oh, neat
13:47:13 <quicksilver> that's not desperataly efficient for extremely long lists but I don't know how often you expect people to work with S100000
13:47:15 <jophish> Tomsik: prime number regex!
13:47:20 <fizbin> Hey, anyone know concisely what the rules are around haskell's multi-line strings? I thought it was just "end the previous line with backslash-newline, then start the next line with whitespace followed by backslash".
13:47:30 <fizbin> But apparently it isn't that simple.
13:47:46 <jophish> fizbin: I know in the past I've used a quasiquoter for that
13:47:49 <quicksilver> that sounds like what I thought it was, fizbin
13:47:57 <quicksilver> I never use them because they look ugly to my eyes
13:48:04 <jophish> (had to embed a large amount of json, it might not be appropriate for your usecase)
13:48:05 <bollu> quicksilver: I'll go hunting for algorithms when I need them. I also don't think many (most?) algorithms are functional in nature. They're all highly imperative IIRC
13:48:06 <tsahyt> Assuming the fast Ord a => [a] -> [a] version, is there even an (asymptotically) faster way to do it?
13:48:21 <fizbin> Well, this gives me an error (it's in the middle of a long list)
13:48:31 <fizbin>     , "asdf\
13:48:32 <fizbin>       \:asdf"
13:48:39 <bollu> tsahyt: would still be nlogn at best, right?
13:48:53 <quicksilver> tsahyt: since we think we know the length, we could just bucket them
13:48:56 <monochrom> "shoddy implementations are slow" is a tautology with no information. but I am not even saying that. I am saying the shocking information: shoddy regex implementations are actually widely used in the real world. therefore, when you choose to use regex, you can be victimized, it is more likely than you think.
13:49:16 <quicksilver> tsahyt: that would be "O(n)" if you believe this complexity stuff
13:49:20 <fizbin> jophish: Actually, my use case is embedding a huge amount of json for a stress test. I had a python script generating the haskell code.
13:49:31 <jophish> monochrom: ah yes, I agree completely, sorry I misunderstood you
13:49:55 <fizbin> Anyway, apparently it's not allowed to have the second line begin with a colon. WTF?
13:50:02 <tsahyt> Ah right, I wasn't thinking of non-comparison based methods
13:50:09 <Tuplanolla> Are you stress testing yourself, fizbin?
13:50:23 <Cale> fizbin: that works for me
13:50:55 <fizbin> Cale: Huh. I get "lexical error in string/character literal at character ':'"
13:51:07 <Tuplanolla> Are you sure it's not the JSON parser failing?
13:51:32 <Cale> fizbin: did you intend for there to be a newline in your string? If so, then put one in explicitly using \n
13:52:00 <Cale> fizbin: String gaps let you break strings onto multiple lines, but they don't insert newlines or anything for you.
13:52:07 <fizbin> No, I intend to have the string "asdf:asdf"
13:52:19 <Cale> In that case, it ought to work...
13:52:26 <quicksilver> did you accidentally a whitespace, fizbin 
13:52:28 <quicksilver> after the first \
13:52:42 <lpaste> Cale pasted “fizbin test” at http://lpaste.net/143156
13:52:45 <quicksilver> turn on trailing-whitespace highlighting in your editor
13:53:13 <Cale> adding whitespace in between the \'s shouldn't hurt anything
13:53:29 <Cale> in fact, you should be able to put as much whitespace as you like
13:53:41 <Cale> > "foo\                        \bar"
13:53:42 <lambdabot>  "foobar"
13:54:15 <quicksilver> oh
13:54:25 * quicksilver didn't know that
13:54:43 <quicksilver> so fizbin was right. I didn't knwo the rules :)
13:54:50 <Cale> It also doesn't matter if the second \ would otherwise have formed an escape code
13:54:52 <fizbin> Hrm. Extracting this to a separate file and it works. WTF...
13:54:57 <Cale> > "foo\         \nar"
13:54:59 <lambdabot>  "foonar"
13:54:59 <fizbin> AH! Found it.
13:55:13 <fizbin> {-# LANGUAGE CPP #-} screws it up.
13:55:24 <monochrom> this is another data point for http://www.vex.net/~trebla/humour/tautologies.html #4
13:55:32 <Cale> Ah, I had a nagging feeling about CPP
13:55:40 <Tuplanolla> I was about to suggest that too.
13:55:42 <fizbin> And the error I'm getting is actually from the C preprocessor. Damn.
13:56:06 <quicksilver> monochrom: :)
13:56:23 <Tuplanolla> I have an idea. Add trailing spaces.
13:57:16 <tsahyt> Does anyone have experience with xmonad here? How much of a pain is it to set it up for someone who's experienced with Haskell?
13:57:19 <Cale> heh, or put the string definition in another module which doesn't have {-# LANGUAGE CPP #-} at the top :P
13:57:29 <the_2nd> If I need higher order functions which belong to type A and take a B
13:57:36 <the_2nd> while B has functions taking As
13:57:49 <quicksilver> fizbin: personally I use concat ["foo","bar"] or unlines ["foo","bar"]
13:57:59 <the_2nd> is there another solution but to create a new file with higher order functions to prevent ring imports?
13:58:00 <Cale> the_2nd: hm?
13:58:09 <exio4> the_2nd: care you write the complete types for that? 
13:58:11 <Tuplanolla> I had tremendous difficulties with it and gave up, tsahyt.
13:58:25 <quicksilver> fizbin: because they look nicer (editor syntax highlighting and indentation)
13:58:30 <fizbin> quicksilver: hrm. That might work.
13:58:35 <Tuplanolla> It doesn't work well with two monitors of different sizes and a lazy user who doesn't want to configure everything.
13:58:56 <quicksilver> the_2nd: put the types in one module called Types
13:59:09 <quicksilver> the_2nd: and then put your functions whereever you like, just importing the types module
13:59:21 <quicksilver> is the 'classic' way to break up that dependency.
13:59:25 <tsahyt> Oh okay. Well, I only have to use it for one monitor. I'm looking for a tiling window manager for my old laptop, and I thought xmonad would be a good fit, since I can use Haskell to extend it
13:59:54 <Tuplanolla> Go ahead then, but keep in mind it's more like a window manager maker than a tailor-made product for you.
14:00:10 <the_2nd> quicksilver, I think I'll go with:
14:00:22 <quicksilver> that's OK because haskell is more of a programming language construction kit than a programming language :)
14:00:27 <the_2nd> Types.hs Class1.hs Class2.hs Functions.hs Main.hs 
14:00:29 <tsahyt> Well, look slike I'll have a fun weekend then
14:00:47 <Tomsik> At least it's not lisp
14:01:00 <dolio> quicksilver: Seems more like a description of twelf.
14:01:16 <Tuplanolla> Is there a simple explanation to huge dips in heap allocation graphs? Sometimes the memory usage goes from nearly constant 1 MB to 0.1 MB for one bin's width in the graph and then back again.
14:02:17 <quicksilver> dolio: well it's a description of a lots of recent interesting languages (and some less recent ones) insofar as good abstraction tools let you create really useful EDSLs.
14:03:51 <Cale> Tuplanolla: Probably not... are large things becoming garbage all at once?
14:03:59 <the_2nd> quicksilver, put instances in that file aswell? Types file
14:04:05 <Cale> Well if 1MB can be considered "large"
14:04:06 <quicksilver> the_2nd: probably
14:04:34 <Tuplanolla> They should not. I was wondering if the measurement method causes some artifacts.
14:04:44 <Cale> I don't know
14:05:09 <Cale> You're looking at hp2ps output?
14:05:14 <Tuplanolla> Yes.
14:05:54 <quicksilver> is it just the collection of the old generation
14:06:04 <quicksilver> that runs less often than the nursery
14:06:19 <Cale> Yeah, maybe it's that
14:06:44 <Tuplanolla> That sounds reasonable as well.
14:08:05 <and123> hello. I am writing a boolean formula parser (with just -> for implication for now). It compiles but refuses to parse. Can you please give me a hint how to fix that? http://pastebin.com/GLVQ7ikJ
14:08:31 <the_2nd> quicksilver, I'll leave the functions in the files and only move the problematic ones to "HighOrderFunctions" or similar
14:08:38 <kallisti> tsahyt: the Haskell part of setting up xmonad is the easy part. it's the linux part that's annoying. :P but you'll encounter that in any kind of customized linux config
14:09:09 <Tuplanolla> Use parseTest to run a parser on some string, and123.
14:09:30 * hackagebot wai-extra 3.0.12 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.12 (GregWeber)
14:09:40 <Tuplanolla> Once you have that, you can look at runParser and friends.
14:10:04 <tsahyt> kallisti: Okay, but I was already expecting that.
14:10:04 <and123> Tuplanolla: great, thank you.
14:11:06 <nomeata> Hi. Out of curiosity: Is anyone here using travis-ci’s deploy-to-hackage feature?
14:11:30 <kallisti> tsahyt: here's my old xmonad config. not clue if it's still valid with newer versions http://lpaste.net/8297846330194132992
14:11:50 <kallisti> tsahyt: but for a basic setup you don't need anywhere near as much. just kind of giving you an idea of what you can do with it.
14:13:41 <ski> and123 : shouldn't the first `*>' be `<*' ?
14:16:38 <tsahyt> kallisti: Thanks! That'll come in handy to get an overview I think
14:22:38 <Hypoon> Hi all, what's the fastest way to check to see if a value is close to another value?
14:23:48 <Hypoon> I'm using "(x > y-d) && (x <= y+d)", but that's the slowest part of my code, according to the profiler.
14:24:18 <Tuplanolla> Is abs (y - x) < d any different?
14:24:31 * hackagebot tasty-expected-failure 0.11.0.2 - Mark tasty tests as failure expected  https://hackage.haskell.org/package/tasty-expected-failure-0.11.0.2 (JoachimBreitner)
14:24:50 <Tuplanolla> That's how mathematicians would write it anyway.
14:25:15 <Hypoon> Tupanolla: I lose the "<=" on the one side, but that's it.
14:25:30 <hexagoxel> Hypoon: maybe the comparisons force the thunks, creating a false picture.
14:25:48 <hexagoxel> rest of channel: that is possible, given how the profiler works, right?
14:26:46 <Hypoon> hexagoxel: I don't know enough about the profiler.
14:26:58 <Hypoon> Tupanolla
14:27:27 <Hypoon> Tuplanolla: I don't know how abs is implemented in Prelude.
14:27:51 <quicksilver> Hypoon: what is the 'type' of number in use?
14:27:52 <Tuplanolla> I don't either, but I don't see any other way than these two.
14:28:01 <Hypoon> but it's worth a shot, what have I to lose?
14:28:02 <hexagoxel> Hypoon: if i am right, lazyness might result in the _computation_ of x,y,d to be attributed to the comparison.
14:28:18 <Tuplanolla> It's possible that abs has a faster specialized implementation for, say, Double.
14:28:25 <quicksilver> that can happen I think, hexagoxel 
14:28:26 <Hypoon> quicksilver: they're floats,
14:28:28 <hexagoxel> Hypoon: to be sure, you could force the variables in an extra step before, and see what the profiler reports then.
14:28:34 <quicksilver> Hypoon: "Float" ?
14:28:42 <Hypoon> quicksilver: yes
14:28:57 <quicksilver> Hypoon: is it painful to rewrite the critical loop to use Double?
14:29:05 <quicksilver> Double is faster than Float, generally.
14:29:19 <quicksilver> Hypoon: are you compiling with -O2 ?
14:29:30 <tsahyt> And here I was thinking that Float was faster. Why is Double faster?
14:29:31 * hackagebot tasty-expected-failure 0.11.0.3 - Mark tasty tests as failure expected  https://hackage.haskell.org/package/tasty-expected-failure-0.11.0.3 (JoachimBreitner)
14:29:33 * hackagebot fltkhs 0.3.0.0 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.3.0.0 (deech)
14:29:34 <Hypoon> quicksilver: I am using -O2, yes.
14:30:25 <Hypoon> I know floating point arithmetic is sometimes implemented using double floating point hardware, but I didn't expect it to be *slower*
14:30:37 <Tuplanolla> The usual: try library functions, add more !, consider INLINE, resort to GHC.Prim in desperation.
14:30:53 <quicksilver> Hypoon: you end up wasting cycles converting to and from single precision
14:31:00 <quicksilver> at least, you can do
14:31:19 <quicksilver> this advice was correct some years ago; recent changes in CPU architecture, GHC, and LLVM may make it obsolete advice
14:31:26 <quicksilver> but if it's easy to try it, then try it :)
14:31:58 <quicksilver> definitely worth trying 'abs' as well
14:33:02 <deech> Sometime in the last week Hackage has disabled the ability to upload docs seperately. I now get "Hackage no longer accepts packages with version tags: docs"
14:33:09 <Hypoon> "abs" worries me due to the possibility of the edge-case. The edge case is highly unlikely, but possible.
14:33:34 <Tuplanolla> Are you doing Monte Carlo things?
14:33:55 <Hypoon> No, this part of the code does a histogram though.
14:34:04 <quicksilver> Hypoon: if are using floating point then you have rounding errors all over
14:34:22 <quicksilver> the difference between '<' and '<=' should be lost in the noise of general rounding
14:34:26 <quicksilver> I'd have thought
14:34:37 <quicksilver> anyhow try abs out of interest to see if it is indeed faster; maybe it won't be.
14:35:45 <quicksilver> if none of these tricks makes any difference and you need this code to be faster, could be time to consider parallelising it or running the maths part on a GPU :)
14:35:56 <Tuplanolla> If you're gathering a histogram and your data source is stochastic, you can discard a "finite" amount of points as if it had zero measure.
14:36:02 <Hypoon> it's a histogram issue, that's all. Putting data in bins. If a datum hits the edge of the bin, it'll get lost. I'll try it anyway though.
14:36:05 <hexagoxel> deech: really? they might have just changed the format (there was some development in the direction of supporting doc uploads with cabal directly iirc).
14:36:51 <Hypoon> Tuplanolla: right, that might be OK here.
14:37:02 <and123> Can you please help me write http://pastebin.com/vyDVLgx4 in applicative style? Thank you.
14:37:09 <deech> hexagoxel: I think you're right. They didn't I just did the Curl command wrong. Sorry.
14:37:15 <Hypoon> Tuplanolla: GPU math is on the radar, but for another day.
14:37:46 <Tuplanolla> I'm doing something similar next week.
14:37:50 <hexagoxel> deech: there are scripts around to automate this stuff, you know :)
14:38:00 <quicksilver> and123: pure TImpl <$> (parseFormula <* string "->") <*> parseFormula
14:38:50 <Tuplanolla> quicksilver: pure?
14:38:55 <and123> quicksilver: oh, that's the last one I haven't tried probably :-) Thank you.
14:39:31 * hackagebot fltkhs-fluid-examples 0.0.0.2 - Fltkhs Fluid Examples  https://hackage.haskell.org/package/fltkhs-fluid-examples-0.0.0.2 (deech)
14:40:21 <quicksilver> Tuplanolla: pure is return but since he said 'applicative-style' it seems appropriate to use it.
14:40:37 <exio4> "pure F <$>" ? 
14:40:40 <exio4> that looks weird
14:40:46 <Tuplanolla> quicksilver: TImpl <*> ...
14:40:50 <quicksilver> oh it was just wrong
14:40:53 <quicksilver> sorry all :)
14:41:00 <quicksilver> and123: drop the pure :)
14:41:19 <and123> quicksilver: I didn't know that was a keyword and didn't copy that :-)
14:41:26 <quicksilver> hehe
14:41:30 <quicksilver> alls well that ends well
14:41:40 <nomeata> Nice, just pushed my first package to hackage via travis.
14:41:55 <quicksilver> and123: the trick there is just that TImpl wants two parametrs and we want to ignore the return type of string "->"
14:42:06 <nomeata> No more uploads with stupid mistakes that CI would have found.
14:42:18 <quicksilver> and123: a <* b does a and then b, but it ignores b's return type and just returns whatever a returned
14:42:26 <quicksilver> nomeata++
14:42:50 <Tuplanolla> Compare f <$> x <*> y and liftA2 f x y too, and123.
14:45:56 <and123> quicksilver, Tuplanolla: Oh, great, now it makes sense to me. Thank you
14:47:53 <quicksilver> and123: here is an alternative way to ignore the result of string "<-"
14:48:25 <quicksilver> (\a b c -> TImpl a c) <$> parseFormula <*> string "->" <*> parseFormula
14:48:44 <quicksilver> and123: in this case that trick is harder to read (notice it simply 'doesn't use' b at all)
14:49:03 <quicksilver> but if you were unlucky and TImpl took itse parameters in the wrong order, this approach would help.
14:50:56 <slacko1256> not really a haskell question. If I want to script an interaction with a website (say library account to renew checkouts), is libcurl what I want to use?
14:51:04 <slacko1256> it seems to have bindings for haskell
14:51:19 <quicksilver> probably not, slacko1256 
14:51:24 <acowley> wreq
14:51:25 <quicksilver> you probably want selenium or webdriver
14:51:54 <acowley> Yeah, it depends what kind of interaction you intend to have
14:51:55 <quicksilver> unless their setup is rather simple
14:53:32 <slacko1256> it will probably will have a lot of cruft
14:53:44 <slacko1256> quicksilver: got it, thanks for the info
14:56:25 <slacko1256> OMG it has a haskell binding!!
15:02:16 <geppettodivacin> Is it possible to break off a lazy ByteString from an encode before the default break point?
15:04:40 <geppettodivacin> It seems like it waits until a certain number of bytes before it becomes lazy.
15:05:00 <geppettodivacin> Example here: http://lpaste.net/143097
15:15:27 <c_wraith> It's a chucked representation, and there's a default chunk size, yes. But I could swear that any time getting you the full default size would block, it just produces what it has so far and creates a n…
15:15:28 <c_wraith> …ew chunk for the next read. 
15:16:59 <c_wraith> Oh, that's more of a binary question than a bytestring question. 
15:17:19 <c_wraith> I do know that binary produces chunks for efficiency, too. 
15:18:32 <geppettodivacin> Does Binary not use ByteStrings?
15:18:43 <geppettodivacin> Or do you mean the internal Builder?
15:18:45 <quicksilver> it does, but it is in control of hte chunk size
15:18:45 <nocturne777> does any of you use cql-io to communicate with Apache Cassandra ?
15:18:56 <quicksilver> so it chooses to produce chunks of a certain size
15:19:04 <quicksilver> I believe, anyway
15:19:54 <c_wraith> geppettodivacin: I'm actually most suspicious of you accidentally leaning on the Binary instance for lists. 
15:20:22 <c_wraith> geppettodivacin: because that instance isn't lazy, iirc
15:20:23 <geppettodivacin> I wrote a new instance, because the default binding requires the entire list.
15:20:46 <geppettodivacin> The new instance is lazy, but it takes several thousand iterations before I can get the first few bytes with a take.
15:22:05 <c_wraith> That just sounds like the default chunking, which I believe defaults to 4k
15:22:32 <geppettodivacin> Is it possible to change that chunking?
15:23:53 <c_wraith> No idea. Never used the library except as a dependency for other things. 
15:24:33 * hackagebot pretty-show 1.6.9 - Tools for working with derived `Show` instances and generic  inspection of values.  https://hackage.haskell.org/package/pretty-show-1.6.9 (IavorDiatchki)
15:30:38 <quicksilver> I think not, geppettodivacin - binary doesn't have many twiddleable settings
15:30:44 <quicksilver> then again what binary does it pretty simple
15:30:55 <quicksilver> you wouldn't make your code much more complex if you just generated your own lazy bytestrings
15:32:18 <geppettodivacin> That would be a possibility. I might try looking into that, as convenient as the Binary package would have been.
15:32:27 <dm_comp> hi, getting an error when using greater than symbol ex'' n = if n > 0
15:32:39 <arkeet> is that the entire code?
15:32:40 <dm_comp> but this works ex'' n = if n > 0
15:32:46 <arkeet> that's the same thing.
15:33:05 <dm_comp> ex' n = if n /= 0
15:33:19 <arkeet> @paste your complete code and error message
15:33:19 <lambdabot> Haskell pastebin: http://lpaste.net/
15:33:59 <dm_comp> http://lpaste.net/143167
15:34:11 <dm_comp> sorry missing error
15:34:25 <arkeet> is that a space at the start of line 9?
15:34:36 <dm_comp> http://lpaste.net/143168
15:34:48 <arkeet> that is the problem.
15:34:49 <dm_comp> yes
15:34:52 <dm_comp> oh
15:34:54 <dm_comp> thx
15:35:11 <arkeet> the space makes it think it's continuing from the previous definition
15:35:13 <arkeet> because layout rules
15:37:08 <Tuplanolla> "Because layout rules" is accurate.
15:37:44 <arkeet> I was using "rules" as a noun. but I suppose it was ambiguous. :-)
15:38:42 <Tuplanolla> Works both ways.
15:40:15 <Demon_Fox> How employable is Haskell?
15:40:35 <Xe> as employable as any other lanugage provided you find the right place to work
15:40:38 <quicksilver> not very employable directly Demon_Fox 
15:40:55 <quicksilver> however smart employers will recognise that learning haskell shows you're taking an interest in stuff
15:40:55 <hpc> the best way to get a job in any language is to also learn a different language
15:41:21 <jophish> Demon_Fox: if I were interviewing a candidate and they were proficient in Haskell that would be a plus for sure
15:41:40 <Demon_Fox> I currently know C and Python, but I'm wanting to expand the languages I know.
15:41:51 <jophish> Demon_Fox: learning Haskell will expand your mind
15:41:56 <jophish> :)
15:42:21 <Demon_Fox> I recommended it to a mathematician because of it's syntax
15:42:41 <jophish> This has been said time and again, but I think learning Haskell will make you a better programmer in other languages too
15:42:42 <Demon_Fox> I was just wondering how employable it is in combination w/ the language I know.
15:43:02 <jophish> Demon_Fox: I'm primarily c++ and Haskell, and I'm employed :D
15:43:16 <hpc> my day job is perl
15:43:22 <Demon_Fox> That's rare
15:43:26 <Demon_Fox> Perl in the modern era
15:43:38 <hpc> it's the email language
15:43:39 <Demon_Fox> Outside of drivers and etc
15:43:49 <jophish> perl in drivers?
15:43:49 <Demon_Fox> I see
15:43:57 <Demon_Fox> I mean to say
15:44:05 <Demon_Fox> C and Perl are used in the Linux kernel
15:44:30 <quicksilver> perl is not used in the linux kernel.
15:44:33 <rcyr> Nobody cares about Perl :P It got replaced by Python a decade ago
15:44:46 <quicksilver> perl programmers care about perl
15:45:11 <Demon_Fox> It's used for the menu config stuff, isn't it?
15:45:48 <hpc> isn't perl everywhere in the build system though?
15:46:03 <quicksilver> well yes perl is used *everywhere* in small quantities
15:46:04 <hpc> also ghc had perl parts for a while
15:46:08 <quicksilver> it used to be a critical part of GHC :)
15:46:18 <quicksilver> https://xkcd.com/224/
15:46:34 <hpc> oh right, my point
15:46:44 <hpc> i use techniques from haskell in my perl code, to neat effect
15:46:48 * quicksilver highfives hpc
15:46:54 <quicksilver> perl brogrammers !
15:47:08 <ski> @quote when.Perl
15:47:08 <lambdabot> mux says: "Haskell: For when Perl doesn't give you enough ways to write something"
15:47:10 * hpc ^5
15:47:22 <Demon_Fox> jophish, How often do you get to use Haskell in your job?
15:47:23 <arw> uh, perl. yes. ^5.
15:47:53 <arw> and btw. is there an official collection of haskellish perl modules ala List::MoreUtil and stuff?
15:48:11 <hpc> arw: start with acme-dont
15:48:42 <ski> @quote probably.the.worst
15:48:42 <lambdabot> Fatalnix says: Perl is probably the worst thing to happen to the world. Larry Wall should be shot.
15:48:44 <ski> @quote is.turning.into
15:48:45 <lambdabot> LarryWall says: Perl is turning into Haskell. Someone shoot me.
15:48:49 <quicksilver> osfameron did a talk on perl monad once
15:48:56 <quicksilver> but he doesn't even remember he's in this channel
15:49:07 <hpc> hah
15:49:40 <mauke> I have an unpublished port of Data.List
15:49:57 <quicksilver> see. This channel is actually *full* of perl programmers
15:50:05 <quicksilver> you just don't recognise us with our sigils
15:50:08 <jophish> Demon_Fox: not as much as I'd like
15:50:08 <quicksilver> without.
15:50:22 <jophish> not everything is written in Haskell
15:50:38 --- mode: ChanServ set +v quicksilver
15:50:55 <shachaf> Everyone in here came across Haskell via Pugs.
15:51:12 <quicksilver> not me, shachaf 
15:51:37 <hpc> quicksilver: everyone in here
15:51:40 <hpc> even the old people
15:51:45 <hpc> /especially/ the old people
15:51:45 <quicksilver> I came across haskell via university, I guess
15:51:48 <quicksilver> I don't actually remember
15:51:54 <quicksilver> I am especially old, certainly
15:52:10 <shachaf> Old enough to have a sigil.
15:52:13 * ski came across Pugs via this channel
15:52:34 <hpc> legend has it that SPJ stumbled across the first haskell compiler while porting perl to powerpc
15:52:55 <ski> the evil mangler was written in Perl
15:53:17 <ski> @quote mangler
15:53:17 <lambdabot> Pseudonym says: All hail the Evil Mangler!
15:53:50 <ski> (it mangled around the assembler output from GCC a bit)
15:54:01 <hpc> it made names into other names, mostly
15:54:13 <hpc> there were fairly specific reasons for it
15:54:16 <quicksilver> bit worse than that
15:54:24 <quicksilver> it also moved the data sections relative to the code section
15:54:33 <quicksilver> to do some trick about memory layout I don't understand
15:54:44 <quicksilver> didn't it?
15:54:44 <hpc> oh my
15:54:57 <hpc> and they used perl for that
15:55:13 <quicksilver> http://code.haskell.org/ghc-scp/ghc/docs/comm/the-beast/mangler.html
15:55:18 <mauke> absolutely awful perl
15:55:27 <jophish> What on earth were they thinking?
15:55:27 <quicksilver> "The code executed when a closure is entered is moved adjacent to that closure's infotable. Moreover, the order of the info table entries is reversed"
15:55:36 <quicksilver> that is the thing I was talking about.
15:55:40 <hpc> christ
15:56:37 <quicksilver> it was a work of evil beauty 
15:56:41 <quicksilver> compile haskell into invalid C
15:56:43 <quicksilver> C which doesn't even work
15:56:48 <quicksilver> btu which GCC accepts
15:56:52 <quicksilver> to produce asm code which won't work
15:57:01 <quicksilver> which you then use a perl script to rearrange into something which does work.
15:57:29 <hpc> and then write to object files that take hours to link
15:59:21 <hpc> let's get back to cool haskell things and not weird crappy ones
15:59:29 <hpc> like being the first implementation of STM
16:09:26 <AndroUser> Quick question... ++ is called concatenation, but what about ::  ?
16:09:41 <AndroUser> What is the operator's name?
16:11:42 <jophish> regarding that^ isn't there an extension to allow using :: as a partially applied infix operator?
16:12:10 <jophish> something like: length = (:: Int) . genericLength 
16:12:19 <jophish> I think it was a gsoc project
16:12:32 <shachaf> No such extension.
16:12:36 <shachaf> But you can write \x->x
16:12:42 <shachaf> Only three characters longer.
16:12:58 <shachaf> Five characters longer.
16:14:04 <jophish> hmm, I was certain I'd seen it though
16:14:09 <jophish> perhaps it didn't get merged
16:15:05 <shachaf> I've heard of it but I don't think it's in GHC.
16:15:15 <shachaf> Tell me when you can do (x ::).
16:19:29 <acowley> jophish: It's an extension augustss was supposed to deliver last year, but it has perhaps fallen off the radar.
16:20:26 <jophish> ah, thanks acowley 
16:20:28 <pavonia> shachaf: What is that supposed to mean?
16:20:50 <shachaf> What it looks like.
16:21:12 <pavonia> I have no idea what it looks like
16:21:22 <jophish> pavonia: a section, which when supplied with a type, binds x to be that type
16:21:42 <pavonia> Oh
16:21:42 <jophish> (x ::) Int would be the same as x :: Int
16:21:45 <jophish> I assume
16:23:00 <arkeet> @let type I a = a -> a
16:23:01 <lambdabot>  Defined.
16:23:03 <arkeet> :t (id::I Int)
16:23:04 <lambdabot> I Int
16:23:11 <arkeet> > (id::I Double) 1
16:23:13 <lambdabot>  1.0
16:23:17 <arkeet> I dunno.
16:23:41 <arkeet> I suppose that's 4 extra characters (if you count the required space)
16:23:52 <arkeet> could rename id
16:25:23 <montanonic> I'm studying HTML5 and CSS right now, and after I got decent at making good-looking pages I wanted to try my hand at web apps. I know a solid amount of beginner-to-intermediate Haskell, but Yesod has been really tough for me.
16:25:25 <hexagoxel> are there hooks into the rts for querying stuff like memory/heap usage, gc counts, etc.?
16:25:42 <montanonic> I can't find any guides that are for noob web devel stuff that are relevant to Haskell/Yesod
16:26:11 <montanonic> I'm not interested in leaving the Haskell web devel world, but it seems like all the materials here are for people who already know web devel.
16:27:23 <hpc> there's no way out of it
16:27:28 <hpc> you need to know all the languages involved
16:27:33 <danza> montanonic, you can't expect to learn web dev out of Yesod anyway
16:27:46 <danza> because web dev nowadays is more than that
16:27:54 <montanonic> danza: would you have some recommendations for places to start?
16:28:02 <montanonic> hpc: what languages do you refer to?
16:28:17 <hpc> html/css/js
16:28:29 <montanonic> hpc: right, I'm learning all of those
16:28:56 <hpc> from there, yesod is going to just be outputting those
16:29:14 <hpc> and you need to learn the translation
16:29:19 <hpc> and doing it "right" comes from experience
16:29:36 <hpc> the fact that you care immediately puts you in the top tier of webdevs
16:30:10 <montanonic> hpc: any ideas for a good place to start with Yesod after I get comfortable with HTML/CSS/JS?
16:30:28 <montanonic> The Yesod guide covers a ton of ground, and it's super hard to digest
16:30:35 <hpc> make a procedurally generated menu for a static site
16:30:38 <hpc> perhaps
16:30:49 <danza> yeah, make your own app
16:31:22 <hpc> then look up the latest fashions of site organization, html structuring, design styles, etc
16:31:23 <montanonic> I just wasn't sure where I'd start, but adding a menu seems like a solid idea. Goal-driven learning is probably the best way to tackle something like Yesod.
16:31:26 <hpc> then ignore them
16:31:34 <hpc> take what you like and just have them in the back of your mind
16:31:57 <montanonic> hpc: I'm reading through two dense books on HTML and CSS, so I think that covers a decent amount of that territory
16:32:14 <hpc> you can learn a lot from viewing the source of existing sites
16:32:27 <montanonic> I've been doing that too. It's the app-related stuff that is hard for me.
16:32:33 <hpc> and that'll get you comfortable with your browser's f12 for a bonus
16:32:44 <montanonic> yeah, been using that a ton
16:33:03 <hpc> adding logic to a web app is silly and backwards
16:33:12 <montanonic> What do you mean?
16:33:17 <montanonic> Not sure what that entails
16:33:30 <hpc> because you can end up with logic split over many independent and concurrent executions of the same code
16:33:40 <hpc> (via multi-page actions and such)
16:33:49 <montanonic> So what's the solution
16:34:10 <MarcelineVQ> Go insane :3
16:34:15 <MarcelineVQ> And then it all makes sense.
16:35:01 <montanonic> in any case, thanks for the advice hpc
16:35:06 <hpc> it's very similar to database design
16:35:20 <hpc> every request should end with your application in a good state
16:35:41 <montanonic> hpc: Oh, I should ask, even though I know it is task-dependent, which DB languages do you prefer?
16:35:43 <hpc> and you should know what responsibilities you want to give to each page ahead of time
16:35:51 <hpc> definitely sql
16:35:57 <montanonic> just plain SQL?
16:36:15 <SoCool> so if there's a way to go from `a -> (b -> r) -> r` and `b -> (c -> r) -> r` to `a -> (c -> r) -> r` which can be seen as `(b -> r) -> (a -> r)` and `(c -> r) -> (b -> r)` becoming `(c -> r) -> (a -> r)`, would the proper function for that be `f a b = /c -> a(b(c))`
16:36:27 <montanonic> hpc: okay, that makes sense, returning to a neutral state
16:36:35 <hpc> yeah
16:36:43 <hpc> learn the basics, then learn joins the ugly way
16:36:49 <hpc> then learn nested queries, then come back to joins
16:37:08 <hpc> it's a great class of languages for what it's meant for
16:37:11 <montanonic> hpc: I kind of wish there was a comprehensive resource on stuff like that which was language agnostic
16:37:28 <montanonic> The contemporary version of language agnostic means OOP, so, nope.
16:37:29 <hpc> man, that'll be the day
16:37:33 <frerich> montanonic: SQL is actually a fairly powerful language, if you find that you do multiple simple queries and then massage the returned data into some particular format, chances are that maybe SQL can do it for you.
16:38:13 <montanonic> frerich: yeah, I've spent a little time with it, I was just curious as to opinions on which version of SQL to use as a baseline.
16:38:19 <frerich> montanonic: I'm still lamenting that all my Haskell 'web apps' are actually very little Haskell. It's mostly SQL and JavaScript :-/
16:38:21 <hpc> my crowning achievement in sql is writing an 80-line query that pulls only the useful data out of a crappy php cms a client was using
16:38:29 <SoCool> SQL makes set logic umpteen times easier, clearer, and more performant than doing set logic in app code (for most values of app code languages)
16:38:33 <hpc> so they can use it in something reasonable instead
16:39:03 <hpc> oh yeah, and more performant can't be emphasized enough
16:39:21 <hpc> the indexing and optimization a good dbms can do is insane
16:39:51 <hpc> there's reasons to buy oracle (though not everyone who buys it needs it)
16:39:55 <montanonic> hpc: which frameworks do you use?
16:39:58 <frerich> Even without that, SQL servers have a few decades of optimizations for processing queries, chances are they are better at it than any hand-crafted code you'd write :-}
16:40:00 <SoCool> but then I'm an enterprise dev so I've been crunching about in huge SQL systems for years... it seems proper RDBMS modeling and such is not so common these days as people trust ORMs and more hardware to solve such
16:40:35 <tommd> Is there a way to match variables in a pattern synonym?
16:40:58 <SoCool> tommd: There are no variables, only definitions, or bindings if you prefer.
16:41:02 <hpc> montanonic: in-house perl cms, does a bunch of stuff in simple ways and doesn't reify data in <?php ?> crap
16:41:02 <tommd> x = 478 ; pattern Foo a = (x,a) 
16:41:16 <frerich> montanonic: I cannot chose the database to talk to, in my case it's MySQL. I use Bryan O'Sullivans "mysql-simple" for talking to that. For the frontend, I use Scotty as the web server/REST framework and Shakespeare for templating.
16:41:18 <montanonic> hpc: you use Haskell for anything at work?
16:41:22 <hpc> no
16:41:53 <hpc> nobody else knows it, and i like perl anyway
16:42:01 <frerich> montanonic: Shakespeare is part of the Yesod family of things, but it's really standalone - you can use it without any of the rest.
16:42:06 <montanonic> frerich: gotcha, thank you for the info
16:42:19 <tommd> I feel like I want something between viewpatterns and pattern synonyms here.
16:42:20 <SoCool> tommd: what do you "pattern" ? what do you want, a function?
16:42:23 <montanonic> frerich: is there a guide on how to integrate it, or is it pretty self-explanatory?
16:42:25 <hpc> i have ghc installed on our devel servers though, so we'll see what happens
16:42:47 <tommd> SoCool.  No, I have identifiers (language keywords) that are kept as top-level bindings in my own Ident type.
16:42:55 <hpc> been messing with acid-state / ixset, so maybe big data things with it could be snuck in
16:42:56 <montanonic> frerich: also, what's your opinion on Scotty, and do you have on opinion on Yesod?
16:43:13 <tommd> SoCool: And the idea was on parsing, my one constructor `C Ident [Arg]` could have patterns 
16:43:25 <frerich> montanonic: I always only used Scotty, it's the first framework I tried because it was very easy to get something working and I never looked back really. Do you know 'sinatra' from Ruby maybe?
16:43:25 <SoCool> hpc: big data.. mmm buzzwords, tastes like burning.
16:43:44 <tommd> SoCool: Such as `pattern IfBlock p t = C ifIdent [p,t]
16:43:58 <montanonic> frerich: I do not, I've only been programming for 6 months. Focused on Haskell for the past 2.5 of them.
16:44:08 <SoCool> tommd: oh you want pattern matching in a type constructor? err I can't imagine how that would make sense, considering type constructors don't have a function body
16:44:12 <hpc> SoCool: https://www.youtube.com/watch?v=E8b4xYbEugo
16:44:28 <frerich> montanonic: https://github.com/scotty-web/scotty/blob/master/README.md has a complete web server which, when you access it via 'localhost:3000/montanonic' will reply with 'montanonic, beam me up'
16:44:35 <tommd> SoCool: I want a stronger PatternSynonym extension.
16:44:53 <montanonic> frerich: thanks!
16:45:46 <hpc> (as buzzwords go, "big data" doesn't even register - the word 'cyber' causes me physical pain though)
16:47:24 <hpc> montanonic: oh, write a blog system, it's like the fibonacci of webdev
16:47:27 <frerich> montanonic: The best thing about Scotty is that when you run the program, it prints "Setting phasers to stun... (port 3000) (ctrl-c to quit)" :-)
16:47:59 <montanonic> hpc: yeah, that was my original idea; I think that seems like a great start
16:47:59 <jophish> frerich: You've sold me on scotty!
16:48:41 <montanonic> hpc: I ask this out of ignorance; websites like Squarespace which have customizable templates and such, Yesod/Scotty could build something like that right?
16:49:03 <hpc> yeah
16:49:04 <montanonic> hpc: I think it'd be fun to make some basic templating stuff that wasn't boring square images, that other people could use
16:49:18 <hpc> factor out the right bits of html and keep the basic structure the same
16:49:24 <hpc> then functionalize switching between them
16:49:29 <SoCool> hpc: what...in...fucks? that's sure something haha
16:49:38 <montanonic> hpc: right, okay. Thanks for your feedback on all of this.
16:50:19 <hpc> anyway, you're by far in the easiest field to break into - results are extremely visible and really just need a text editor to accomplish
16:51:21 <SoCool> hpc: eh, in enterprise circles "big data" is code word for "I'm an important person!" among business types these days..
16:51:50 <jophish> I said "synergize" at work the other day :)
16:52:00 <SoCool> meanwhile I once had somebody tell me they really needed to use some advanced big data techniques because they had a whopping 3gb database...
16:52:07 <montanonic> hpc: that's a good point; one more question that you might not have an answer to: if I was probably going to spend more time in web devel later on, would it matter if I started with Scotty vs Yesod? It seems like that latter is the big one for Haskell, but I don't know much about this stuff.
16:53:10 <SoCool> If your database could fit in my laptops ram, or even on it's damned hard drive for that matter... no. You aren't a big data synergy cloud.
16:54:22 <hpc> doesn't really matter
16:55:09 <hpc> SoCool: well, bigger data, at least
16:55:12 <hpc> than what we have now
16:55:32 <hpc> and no, it wouldn't be for everything, but parts
16:55:49 <hpc> ("high throughput" maybe?)
16:56:07 <SoCool> hpc: I presume you're using the term correctly, I wasn't trying to say you don't know what you're talking about. Just that it's an abused buzzword where most people don't know what they're talking about
16:56:15 <hpc> yeah
16:56:21 <SoCool> My default position is people in #haskell other than I, know what they're talking about.
16:56:50 <hpc> usually a safe bet
16:57:01 <jophish> SoCool: uh oh, I assumed the same
16:57:25 <SoCool> jophish: ah yeah, add me to the "other than I" list, sorry about that.
16:57:26 <hpc> i wonder how hard it would be to beat redis benchmarks with something written in haskell
16:59:46 <SoCool> hpc: why would you bother though? redis is perfectly fine for what it does, no real reason to make another. If you want to create something in Haskell, go create a contextual logging service that makes splunk look like an idiot, stuff that enterprise folk use so it can get a little penetration into my job space...
16:59:56 <hpc> heh
17:02:48 <MarcelineVQ> What is a contexual logging service? (I hope the answer isn't, it depends.)
17:17:40 <qvhDOPh> hi
17:24:38 * hackagebot clafer 0.4.2 - Compiles Clafer models to other formats: Alloy, JavaScript, JSON, HTML, Dot.  https://hackage.haskell.org/package/clafer-0.4.2 (mantkiew)
17:27:35 <SoCool> MarcelineVQ: Adds context to logging, so you can do things like see all log messages generated from the top of the stack to the bottom - even on different servers - for a single incoming webrequest. Similar to how google analytics gives you instrumentation per visitor, but google analytics is only for front-end websites, contextual logging can give you the detailed instrumentation across tiers and in general across 
17:27:35 <SoCool> systems.
17:28:48 <SoCool> If you have for instance a service that runs for the purpose of processing batch jobs, contextual logging would give you the ability to get all the instrumentation from each individual step for all jobs, or all steps for a given job etc.
17:29:01 <tpsinnem> is there a recommended program for generating haskell tags files to be used by vim?
17:29:16 <SoCool> I presume hasktags, but I use emacs not vim
17:29:27 <jophish> tpsinnem: hothasktags, lushtags, gasbagtags?
17:29:28 <SoCool> better yet, ditch vim and stop worrying about it :)
17:29:38 <jophish> in various states of maintenance 
17:29:46 <jophish> tpsinnem: stay with vim!
17:29:55 <jophish> ghcmod-vim is super for generating names in scope
17:29:56 <tpsinnem> i remember a while back they all seemed to be a little spotty in what features they supported
17:30:09 <jophish> tpsinnem: I don't use any tags files for haskell
17:30:26 <jophish> deoplete + neco-ghc works well enough for me
17:30:47 <jophish> if you want tags, take a look at neco-ghc-lushtags
17:30:51 <jophish> it's a fork
17:31:50 <tpsinnem> jophish: hm i wonder if hdevtools should help me jump to code. i remember having trouble with performance with ghcmod-vim
17:32:16 <jophish> tpsinnem: yeah, you could try that, it was written with performance in mind
17:32:20 <tpsinnem> i have a pretty slow computer
17:32:32 <jophish> ghc-mod has that kind of stuff on the roadmap, but afaik it's not quite there yet
17:32:50 <jophish> hopefully there's a more maintained fork of hdevtools
17:33:00 <jophish> bitc seems to have gone
17:33:28 <tpsinnem> the hackage page now lists schell/hdevtools rather than bitc/hdevtools on github
17:34:00 <schell> tpsinnem, jophish: yes - i’m the “interim” maintainer 
17:34:14 <schell> my fork is pretty up to date
17:34:21 <jophish> ah, I'd not seen that bedore
17:34:22 <jophish> before*
17:35:02 <schell> i haven’t used jump to code with hdevtools though - and i’m a bit of a lame maintainer - i can’t tell you if hdevtools supports it
17:35:38 <schell> it’s really bitc’s baby but he left it locked in the car so i called social services 
17:39:39 * hackagebot claferIG 0.4.2 - claferIG is an interactive tool that generates instances of Clafer models.  https://hackage.haskell.org/package/claferIG-0.4.2 (mantkiew)
17:42:06 <rpfun> what is the "current" solution for indenting code? I've been using structured-haskell-mode in emacs, but it does not play well with search-replace refactoring at all; i end up having to review my code line by line
17:42:53 <jophish> rpfun: I use https://github.com/neovimhaskell/haskell-vim
17:44:24 <rpfun> thanks! i guess i should have specified i'm looking more for something emacs-specific
17:44:39 * hackagebot claferwiki 0.4.2 - A wiki-based IDE for literate modeling with Clafer  https://hackage.haskell.org/package/claferwiki-0.4.2 (mantkiew)
17:51:16 <jophish> Goodnight everyone
17:51:20 <Joseph_uttech> rpfun: I tried out a lot of the haskell indentation packages, and I settled on just using haskell-mode and manually indenting sometimes.  It works well enough for me
17:54:35 <rpfun> do you manually re-indent after a search+replace?
18:15:53 <newsham> does ghci evaluate pure functions with constant args at compile time?
18:15:57 <newsham> s/ghci/ghc/
18:16:10 <newsham> like: length "hello world"
18:16:30 <shachaf> No.
18:16:40 <newsham> is there a reason that would be a bad idea?
18:16:44 <shachaf> It doesn't even optimize "reverse []" to "[]".
18:16:58 <shachaf> (Though it can do some inlining of non-recursive functions.)
18:17:12 <newsham> i guess you never know if a pure function will terminate or not
18:17:17 <shachaf> I think it's just not particularly easy to do.
18:17:24 <newsham> but you'd think you could try it out for a little bit at least
18:39:41 * hackagebot msh 0.1.0.0 - Template Haskell implementation of Programming with Monadic State Hierarchies  https://hackage.haskell.org/package/msh-0.1.0.0 (mbg)
18:44:15 <Joseph_uttech> rpfun: yeah I do, but I've never worked on a huge haskell code base, so it's never been that painful.  Maybe somebody with more experience can chime in, I'm still pretty new to haskell
18:45:55 <EvanR> rpfun: theres some haskell IDE/plugins which auto format stuff
18:46:28 <EvanR> like, HaskForce
18:54:42 * hackagebot oidc-client 0.1.0.1 - OpenID Connect 1.0 library for RP  https://hackage.haskell.org/package/oidc-client-0.1.0.1 (ShoKuroda)
19:25:44 <submain> Anyone knows if ghcjs is on hackage? I couldn't find it...
19:28:46 <frase> anyone know if there's a freebsd pkg repository offering Haskell packages with profiling enabled?
19:29:04 <hodapp> submain: I don't think it is.
19:29:44 <submain> yeah, i thought that was weird, considering it is a rather popular packaged.
19:29:48 <submain> *package.
19:30:18 <hodapp> submain: it's not clear to me it can be implemented as a hackage package.
19:30:27 <hodapp> perhaps that's changed
20:21:50 <icedev> Hi, my threads are not running simultaneously in my code. first the gui thread runs, finished, then the net thread starts | https://defuse.ca/b/LSbQmP7tnd33a7OsmhVNzn | can someone help me understand the issue?
20:23:59 <icedev> i also have a dockerfile for testing here https://github.com/icetruckde/HackChat-Haskell-Client/
20:27:26 <KaneTW> icedev: where's control.concurrent.thread from
20:27:35 <icedev> called 'threads'
20:27:54 <icedev> http://hackage.haskell.org/package/threads-0.5.1.3/docs/Control-Concurrent-Thread.html
20:28:54 <KaneTW> " but returns a computation that when executed blocks until the thread terminates"
20:29:02 <KaneTW> you're then doing guiWait >> netWait
20:29:13 <KaneTW> so it's running exactly as intended
20:29:31 <KaneTW> do you want the net thread to exchange data with the gui thread?
20:30:21 <icedev> yes right - guess i got lost in the monad topic .. what would i use instead?
20:34:26 <selveskii> Hello! I am writing a abstract syntax tree with info attached to every node, like data AST a = Var String a | App (AST a) (AST a) a. I now use DeriveFunctor to generate functions that can operate over those info, but I don't know how to access those info: getInfo :: AST a -> a Is there a convenient way to generate the info accessor function?
20:36:20 <KaneTW> make it into a record
20:36:40 <KaneTW> with a having name getInfo or whatever in both cases
20:36:47 <KaneTW> *might require ghc 8
20:38:14 <selveskii> KaneTW: I am more interested in a template Haskell approach, but don't know the keyword to google, thank you
20:39:43 <glguy> selveskii: There's no keyword to Google for a Template Haskell approach. You'd jsut use Template Haskell to generate the syntax
20:39:58 <KaneTW> selveskii: lenses i think
20:39:59 <glguy> selveskii: An easier way would be to use GHC.Generics to do it
20:40:01 <KaneTW> can do that
20:40:32 <selveskii> glguy: well I don't prepare well to learn th though so I am looking for library recommendation. maybe I should look into it now
20:41:02 <glguy> There isn't likely to be a library to do that with Template Haskell
20:41:38 <selveskii> but we already have derive functor…I think they are similar
20:42:13 <KaneTW> not really
20:42:13 <selveskii> learning GHC.Generics now, thank you!
20:43:10 <KaneTW> every monad is a functor, having something like extract :: Functor f => f a -> a would be extremely unsound for the f = IO case
20:43:15 <icedev> @KaneTW the problem is: after the first keypress the gui thread exits and the network thread starts - so in your opinion the wait part was correct? when i do netWait >> guiWait the same happens
20:43:15 <lambdabot> Unknown command, try @list
20:43:32 <glguy> icedev: @ is for bot commands, not addressing users
20:43:48 <KaneTW> i blame slack or twitter
20:43:58 <KaneTW> icedev: hm
20:44:09 <icedev> no i integrated another chat into irc and have to mention people there with the at sign
20:44:37 <KaneTW> i'm currently working on something else so i can't read too deeply into your code
20:44:49 <KaneTW> but maybe look into something like conduits (not sure if you already use that)
20:45:00 <icedev> ok ill have a look, thanks
20:45:47 <KaneTW> selveskii: http://hackage.haskell.org/package/lens-4.13/docs/Control-Lens-TH.html
20:46:03 <KaneTW> lenses seem to be exactly what you want
20:46:15 <selveskii> KaneTW: yep…defining Tree a -> a seems not to be a good idea neither…not sure if attaching info to every AST node is a right design
20:46:22 <selveskii> thank you, I am checking it out
20:46:38 <KaneTW> and with GHC 8 you can do the same with {-# LANGUAGE OverloadedRecordFields #-}
20:48:00 <selveskii> but with extra lines brought by record syntax I could hand write my function with type class… :)
20:48:27 <icedev> oh .. didn't know OverloadedRecordFields exists.. ah too late - would have needed that for the other json library i guess
20:48:29 <lpaste> glguy pasted “generic annotation function” at http://lpaste.net/143179
20:48:38 <glguy> selveskii: You can do it like this ^
20:49:16 <glguy> for any type where the annotation is the right-most field of all of its constructors you can use genericAnnotation as the implementation
20:49:43 <KaneTW> icedev: it won't be in a released GHC version until approx. february, it's only in HEAD right now
20:49:57 <icedev> oh ok, but nice feature
20:50:32 <selveskii> glguy: thanks! working on understanding it
20:53:17 <elliptic00> data Myfoo = Myfoo{int::Integer, str::String}
20:53:17 <elliptic00> instance Eq Myfoo where
20:53:17 <elliptic00> (Myfoo int1 str1) == (Myfoo int2 str2) = (int1 == int2)
20:53:50 <elliptic00> I try to overload ==  for my type Myfoo, but I get compile error
20:54:49 <elliptic00>  Ambiguous occurrence ‘==’
20:54:49 <elliptic00>     It could refer to either ‘Main.==’, defined at first.hs:292:19
20:54:49 <elliptic00>                           or ‘Prelude.==’,
20:54:58 <elliptic00> here is error I got, any idea?
20:55:38 <glguy> elliptic00: didn't indent your 3rd pasted line?
20:55:40 <shachaf> Paste code and errors on hpaste.org, not in here.
20:55:46 <awpr> elliptic00: I'm gonna guess that's missing inde... ^ what glguy said
20:55:51 <shachaf> But in this case, you need to indent your definition of (==).
20:57:26 <elliptic00> your guy are awesome :) thx
20:58:00 <elliptic00> BTW, why do I need to indent my code? is it only in Python?
20:58:11 <shachaf> It is not only in Python.
20:58:25 <awpr> in more detail, if you don't indent that line, you've declared an instance with no methods, and *separately* a function called (==)
20:59:07 <awpr> and when you say "int1 == int2", GHC doesn't know whether you're using the (==) from the Eq class or the one you've just defined.
20:59:22 <KaneTW> honestly GHC should throw an error when something like that happens
20:59:35 <glguy> Thank you for your honesty
20:59:47 <awpr> well, it has a warning, but of course that doesn't show up if there are also errors, which there often are
21:00:37 <KaneTW> the warning doesn't seem to be enabled by default at least
21:00:44 * awpr has -Wall
21:00:45 <KaneTW> well a lot of useful warnings aren't
21:01:08 <KaneTW> yeah, but newbie programmers rarely specify -Wall
21:01:27 <elliptic00> thx..guys
21:01:28 <awpr> wait why would that not be enabled by default?  is there *any* situation where it makes sense to have an instance that's missing defaultless methods?
21:01:57 <awpr> (not including when the methods are just sentinels like a few in optparse-applicative)
21:07:45 <nshepperd> don't (==) and (/=) in Eq have defaults?
21:08:02 <nshepperd> 'a == b = not (a /= b)' and vice versa?
21:08:14 <elliptic00> data Myfoo = Myfoo{int:Integer, str::String} and  data Myfood = Myfoo Integer String
21:08:47 <ReinH> nshepperd: yep
21:08:50 <elliptic00> can anyone explain to me what is difference between two declartion?
21:09:20 <KaneTW> nshepperd: yeah, which is exactly why that instance is accepted
21:09:35 <awpr> elliptic00: the only difference really is that the record form comes with accessor functions, and it can be used with record syntax.  they should be identical in memory
21:09:53 <nshepperd> it would be nice if the instance checker had some kind of dependency analyser that could ensure you defined at least one method of a mutually recursive set like that
21:11:13 <KaneTW> oh it does in 7.10.2
21:11:15 <KaneTW> well
21:11:30 <KaneTW> it might require an annotation, not sure
21:12:07 <KaneTW> i accidentally checked for a warning in a 7.6.3 ghc where it doesn't exist
21:12:10 <KaneTW> it exists in 7.10.2
21:12:26 <KaneTW> without -Wall, even
21:13:06 <awpr> I love how every question in this channel turns into "hmm, now how can we make the language better so that problem could never happen?"
21:14:19 <elliptic00> are the class and instance in Haskell are same as the class and instance in Java?
21:14:31 <KaneTW> not at all
21:14:33 <icedev> oh KaneTW this is bad.. i had: "(x:xs) <- takeMVar q" - it did not complete, because the content was [] ..
21:14:47 <awpr> class and instance are more like interface and implementation, but don't dig too deep into that analogy
21:15:02 <awpr> because it falls apart in a lot of ways
21:15:02 <elliptic00> can you explain a little bit? i'm new to Haskell.. 
21:15:22 <KaneTW> what are you using to learn haskell
21:15:47 <elliptic00> Google
21:16:03 <KaneTW> @where learnhaskell
21:16:03 <lambdabot> https://github.com/bitemyapp/learnhaskell
21:17:20 <elliptic00> thx for the link, it should be very usefull for me
21:17:50 <nshepperd> {-# MINIMAL foldMap | foldr #-}
21:17:58 <nshepperd> ah, it defines an explicit minimal set
21:18:34 <shachaf> foldr is a scow way to define a Foldable instance, though.
21:18:39 <shachaf> You should always define foldMap.
21:19:27 <icedev> KaneTW: everything is working now, thanks for helping
21:19:46 <KaneTW> i didn't really help much :v
21:20:03 <icedev> you told me the threads part was right ;)
21:20:07 <icedev> helped a lot
21:20:34 <KaneTW> hah ok
21:20:36 <KaneTW> np
21:35:01 <ski> icedev : fwiw, `x:xs <- ...' would do the same
21:35:21 <icedev> ah jup
21:35:42 <icedev> has been some time since i last touched haskell :D
22:07:44 <nurupo> i have a function taking two arguments `fun x y`. i want to do something like `map (fun x) ys` but with the arguments switched, i.e. `map (fun _ y) xs`
22:08:36 <Cale> nurupo: map (\x -> fun x y) xs
22:08:54 <nurupo> yay!
22:09:05 <nurupo> how i haven't though of that
22:09:32 <ReinH> or map (`fun` y) xs, or map (flip fun) xs, but Cale's is perfectly cromulent.
22:09:39 <ReinH> er, (flip fun y)
22:10:08 <ReinH> The `fun` version might be preferable if the function reads better that way, eg.g. (`elem` xs)
22:17:02 <jle`> hlint gives a warning to change (\x -> fun x y) to (`fun` y) for some reason...which seems like an odd choice for a do-this-every-time style guide
22:20:27 <Cale> jle`: I agree
22:20:38 <Cale> It's maybe worth considering though
22:20:48 <Cale> There are definitely cases where it's better
22:21:05 <jle`> yeah, i guess it's a good, "maybe consider..." kind of hint
22:24:38 <NeverDie> Why is the lookup of a length of a list in Haskell in linear time as opposed to constant time?
22:25:44 <dramforever> NeverDie: because it traverses through the list to get the length
22:26:01 <NeverDie> Yes, but other languages look it up in constant time, why does Haskell not go that route as well?
22:26:31 <dramforever> NeverDie: because other languages store lists as arrays, haskell stores it with singly linked lists
22:26:45 <dramforever> in that way it supports cons (:) efficiently
22:26:52 <dramforever> oh and also unconsing
22:27:25 <NeverDie> Hmm, I see. 
22:28:35 <dramforever> NeverDie: interestingly, length is hardly necessary in many cases
22:29:01 <NeverDie> Yeah, coming from an imperative background, I find that hard to wrap my head around currently.
22:29:44 <dramforever> NeverDie: don't worry, that happens to everyone
22:29:58 <KaneTW> NeverDie: other languages don't have lists, they have arrays or vectors
22:30:36 <valdyn> NeverDie: lists are just the same in other languages, but they may not be a language feature and/or they may not be as commonly used
22:30:48 <valdyn> NeverDie: (just the same performance-wise)
22:30:53 <glguy_> Linked lists exist in other languages, too. If you want an array use an array
22:30:53 <KaneTW> *as their standard multiple element datatype
22:31:08 <dramforever> python called and wants its lists back
22:32:46 <Denommus> dramforever: heh, Haskell's list comprehension is actually older than Python's, IIRC
22:33:05 <lispy> Haskell is older than Java, so yes :)
22:33:05 <jle`> you do recall correctly
22:33:43 <lispy> (I realize we're not talking about Java, but that should give you a sense of how old Haskell is)
22:34:13 <jle`> NeverDie: i don't think it's an imperative vs functional thing; there could definitely be an imperative langauge that uses linked lists as its main multiple-value storage structure
22:34:38 <jle`> and haskell could have definitely used arrays as its main value containing thing
22:34:40 <NeverDie> Is there any downside to looking up the length in constant time as opposed to linear time?
22:34:42 <jle`> but it didn't
22:34:47 <NeverDie> That's what I mostly don't get with Haskell.
22:34:57 <dramforever> NeverDie: I said it, consing and unconsing
22:34:58 <jle`> different data structures have different operations on them
22:35:07 <NeverDie> dramforever: Mostly just for that?
22:35:20 <valdyn> NeverDie: the downside is that you have to compute and store the length after each change
22:35:22 <dramforever> well, yes, because isn't that exactly what lists are?
22:35:59 <NeverDie> valdyn: Even for other imperative languages?
22:36:08 <valdyn> NeverDie: of course
22:36:10 <KaneTW> yes
22:36:18 <jle`> yes; do you know how arrays are typically implemented?
22:36:21 <NeverDie> Hmm, I see.
22:36:35 <NeverDie> I'm still learning. I've been programming only for about almost 7 months.
22:36:49 <NeverDie> Same with teaching myself stuff about computer science, so I'm still a huge noob.
22:36:49 <KaneTW> NeverDie: lists are essentially used as a control structure in haskell and for that efficient cons/uncons is important
22:37:13 <NeverDie> I see.
22:37:22 <jle`> ah, ok.  traditional arrays store their length as a "flag" with the actual array data
22:37:51 <Denommus> lispy: well, not every Haskell feature is as old as Haskell itself, though
22:38:03 <jle`> so if you want to combine two arrays, you have to return a new array and recompute the length flag
22:38:34 <lispy> Denommus: For sure
22:38:36 <jle`> lists and arrays in haskell are kind of nice actually because (to a certain extent) they aren't actually compiler magic
22:38:47 <jle`> haskell's lists can be implemented in haskell using normal haskell things
22:39:13 <pikajude> kind of. you don't get [] for free
22:39:17 <jle`> a common beginner's exercise actually is to ditch the built-in list data type and roll your own...which actually is fairly simple
22:39:45 <dolio> The only thing you can't implement yourself is the syntax.
22:39:45 <jle`> pikajude: that's just syntactic sugar, though
22:39:48 <lispy> pikajude: oh, you mean the syntax?
22:39:49 <jle`> i'm talking about the data type itself
22:40:01 <NeverDie> jle`: That explains it far more beautifully. Thank you!
22:40:09 <lispy> What about with pattern synonyms? You could get pretty far, yeah? and view-patterns on top?
22:40:39 <jle`> the only compiler magic that i can think about is that the compiler is aware of its Prelude lists so it can optimize functions using them better
22:40:52 <dolio> I don't think [] and : are going to be legal pattern synonyms.
22:41:13 <dolio> Nor [x,y,z], of which you need infinitely many.
22:41:15 <lispy> dolio: no, but maybe there is something similar. I'm not sure because I haven't played with the synonyms yet
22:42:29 <jle`> NeverDie: there's also the fact that lists in haskell are often infinitely long, so it wouldn't make sense to pre-compute the length and store it as a part of the data type
22:42:50 <jle`> in fact, the `length` function sometimes actually never terminates -- it's a partial function
22:42:52 <NeverDie> jle`: That's a very good point. I didn't think of that.
22:44:05 <jle`> i'm not sure if my classification of it as a partial function is a useful one
22:44:16 <nitrix> NeverDie: Learning Haskell as your first language?
22:44:32 <jle`> any function is potentially partial if you consider nonterminating inputs...
22:44:44 <jle`> s/any function is/many functions are
22:45:08 <jle`> but this is a digression, heh
22:48:53 <scc_> +i
22:49:35 <dolio> Being undefined on a well defined input is a fine specification for partial.
22:51:11 <NeverDie> nitrix: It's my second language.
22:51:33 <KaneTW> dolio: define well defined
22:51:41 <thimoteus> haha
22:51:47 <NeverDie> Would've made it my first were it not for my priority of getting a job as a dev.
22:52:02 <nurupo> > putStr "test"
22:52:03 <lambdabot>  <IO ()>
22:52:11 <nurupo> hm
22:52:40 <nurupo> so, i have [String] and i want to print out each of them on a new line in ghci
22:53:14 <nurupo> `map (putStr) ["test1", "test2"]` doesn't really work
22:53:25 <Adeon> you probably want for_ or traverse_ from Data.Foldable
22:53:32 <Adeon> for_ lines putStrLn
22:53:39 <Adeon> traverse_ putStrLn lines
22:54:12 <Adeon> those two functions do the same thing, just different order of arguments
22:54:47 <nurupo> Adeon: why can't i simply map it?
22:54:56 <Adeon> I'm actually thinking how to explain it
22:55:00 <nurupo> No instance for (Show (IO ())) arising from a use of `print'
22:55:23 <Adeon> when you use map putStr ["test1", "test2"] you get a list of IO actions [putStr "test1", putStr "test2"]
22:55:38 <nurupo> oh, i didn't fold the list of IO monads
22:55:52 <nurupo> so to speak :)
22:55:52 <KaneTW> @hoogle (Monad m, Foldable t) => t (f a) -> f ()
22:55:54 <lambdabot> Did you mean: Foldable t => t (f a) -> f ()
22:55:55 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
22:55:55 <lambdabot> Data.Foldable sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
22:55:55 <Adeon> when you use for_ ["test1", "test2"] putStr you get putStr "test1" *> putStr "test2"
22:57:15 <Adeon> and yeah as you say, you can fold the list so
22:57:25 <Adeon> sequence_ $ map putStr ["test1", "test2"] should work too
22:57:48 <Adeon> sequence_ can turn lists of IO actions into just one IO action that you can execute
22:58:15 <Adeon> it works on more that just lists (it works on any Foldable), which is what lambdabot is telling there
23:03:37 <KaneTW> i like that lambdabot corrected my tyvar typo
23:08:06 <jle`> thank hoogle and neil :3
23:57:51 <kamatsu> hm, emacs haskell mode seems to barf if i use a MIN_VERSION CPP pragma
