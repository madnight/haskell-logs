00:03:51 <pavonia> With the fastirc package you can add a handler for each received message via onMessage to log incomming messages. Does anyone see a way to also log all outgoing messages?
00:06:47 <m0rphism> joco42: I think ghc-mod can do this. Look at keybinding C-cC-m on http://www.mew.org/~kazu/proj/ghc-mod/en/emacs.html .
00:07:40 * hackagebot hops 0.1.2 - Handy Operations on Power Series  https://hackage.haskell.org/package/hops-0.1.2 (AndersClaesson)
00:07:40 * hackagebot mathista 0.0.1 - A small programming language for numerical computing  https://hackage.haskell.org/package/mathista-0.0.1 (seiya)
00:08:03 <joco42> m0rphism: this is handy ! now i have some real reasons to start using ghc-mod
00:12:40 <m0rphism> joco42: It's not completely automatic, as it only inserts the import for the identifier under the cursor, but I'm not aware of any alternatives, which process the whole module.
00:13:08 <joco42> m0rphism: still, it is quite ok
00:13:38 <joco42> but yeah, some fully automatic solution might be simpler
00:14:23 <joco42> especially if i want to read existing code
00:14:43 <liangzan> hello, i got a beginner question on haskell(can‚Äôt find answers on #haskell-beginners)
00:15:04 <m0rphism> joco42: maybe it's possible to script something using the ghc-mod binaries
00:15:09 <liangzan> if i defined a data type ‚Äúdata FooList = [Foo]‚Äù
00:15:16 <joco42> m0rphism: yeah, indeed
00:15:37 <m0rphism> joco42: but at first look I can't find the refactoring commands in their manual...
00:15:38 <liangzan> how do i access FooList like a list?
00:15:40 <joco42> m0rphism: what is that key binding under vim ?
00:16:30 <joco42> or maybe it is time to swtich emacs?
00:16:34 <m0rphism> joco42: I don't know. This is the corresponding vim plugin: https://github.com/eagletmt/ghcmod-vim
00:17:03 <pavonia> liangzan: This isn't a legal definition, data requires a new constructor on the right-hand side
00:17:07 <m0rphism> joco42: I'm currently using spacemacs, which is relatively simple to setup for haskell and comes with vim keybindings by default
00:17:50 <liangzan> got an ans over at haskell-beginners. thanks for the help!
00:17:59 <joco42> m0rphism: i have alook
00:25:42 <joco42> m0rphism: just installing spacemacs... what do you reccomend for haskell ? what emacs/spacemacs packages/tools ?
00:26:53 <m0rphism> joco42: spacemacs is organized in layers, which consist of a set of emacs plugins and configuration according to spacemacs standards.
00:27:02 <m0rphism> joco42: I simply use the default haskell layer: https://github.com/syl20bnr/spacemacs/tree/develop/layers/%2Blang/haskell
00:27:12 <joco42> ok, nice, and simple
00:27:50 <m0rphism> joco42: You basically just add "haskell" into the layers section of your configuration file and make sure that the required binaries are on your path (see haskell-layer documentation)
00:29:01 <joco42> ok, simple :)
00:29:43 <m0rphism> I also recommend using the syntax-checking, git, version-control and auto-completion layers
00:30:03 <m0rphism> joco42: but you can find out yourself what suits your needs best :)
00:31:21 <joco42> yeah, this looks quite nice, m0rphism , https://github.com/syl20bnr/spacemacs/tree/develop/layers/%2Blang/haskell indeed
00:37:40 * hackagebot varying 0.1.5.0 - FRP through varying values and monadic splines.  https://hackage.haskell.org/package/varying-0.1.5.0 (SchellScivally)
00:37:47 <elliptic00> is Type Constructor in Haskell like Class in Java/C++?
00:39:44 <m0rphism> elliptic00: a type constructor is something which takes types as input and returns a type, e.g. the type constructor `vector` in C++ may take type `int` and return the type `vector<int>`
00:40:57 <elliptic00> nice analogy:)
00:40:57 <m0rphism> elliptic00: note that there are also value constructors, which are only in some aspects similar to constructors in C++/Java
00:42:19 <m0rphism> elliptic00: e.g. in `data List a = Nil | Cons a (List a)` we have a type constructor `List` and two value constructors `Nil` and `Cons`
00:43:28 <m0rphism> value constructors are things you can pattern match on
00:44:50 <elliptic00> What is the difference between Type Constructor and Algebraic Type? are they are same or diff?
00:45:18 <julianleviston> elliptic00: they‚Äôre not the same kind of thing to compare on‚Ä¶ 
00:45:31 <elliptic00> i'm new to Haskell, very confusing.. 
00:45:36 <julianleviston> elliptic00: data Animal = Cat | Dog | Mouse
00:45:43 <m0rphism> most important a type constructor is not a type
00:45:52 <m0rphism> it yields a type when applied to other types
00:46:09 <julianleviston> ellinokon: Animal is the type. Cat, Dog, Mouse are all type constructors.
00:46:18 <m0rphism> e.g. you can't have a value of type `vector`, but you can have a value of type `vector<int>`
00:46:25 <julianleviston> ellinokon: Animal is an algebraic type.
00:46:34 <ggole> No, Cat Dog and Mouse are data constructors
00:46:50 <julianleviston> ggole: oops‚Ä¶ I said type constructors (sigh)
00:47:09 <julianleviston> elliptic00: sorry‚Ä¶ listen to ggole..
00:47:19 <elliptic00> thx
00:47:36 <julianleviston> elliptic00: Cat is a data constructor, is a value constructor.
00:47:56 <julianleviston> elliptic00: if you have a type that can take a parameter to construct another type, then THAT is a type constructor.
00:48:16 <julianleviston> elliptic00: or rather, a consturctor that takes a parameter.
00:48:45 <m0rphism> elliptic00: an algebraic datatype is a type defined by algebraic operations: i.e. products and sums
00:48:54 <elliptic00> In Java    MyClass c = new MyClass("dog"), then MyClass is Type Constructors, c is value type?
00:49:17 <m0rphism> elliptic00: taking the product of two types is a tuple type, taking the sum of two types is an `Either a or b` type
00:49:18 <julianleviston> elliptic00: Animal is an algebraic type because it says the data can be Cat or Mouse or Dog. That‚Äôs a sum type‚Ä¶
00:49:36 <julianleviston> elliptic00: don‚Äôt compare this to Java, I don‚Äôt recommend.
00:49:58 <ggole> There's a bit of an irregularity in the terminology because a data constructor can be nullary and a type constructor cannot
00:50:00 <julianleviston> m0rphism:  really?
00:50:12 <julianleviston> m0rphism:  how is either a Sum type?
00:50:22 <julianleviston> m0rphism:  oh‚Ä¶ because Left a | Right b. Ok.
00:50:54 <m0rphism> elliptic00: for example in `data List a = Nil | Cons a (List a)` you take the product of `a` and `List a` and name it `Cons`, and then you take the sum of `Cons` and `Nil`
00:50:57 <julianleviston> elliptic00: nullary meaning ‚Äútakes no arguments‚Äù.
00:51:24 <m0rphism> hence everything defined using haskells `data` keyword is an algebraic data type
00:51:40 <julianleviston> elliptic00: Sum is equivalent to Logical OR.
00:52:00 <ggole> (Although you can regard a nullary data constructor Foo as shorthand for Foo () if you want to restore some symmetry.)
00:52:16 <m0rphism> julianleviston: it's ok to compare these things to java etc, it's just important to highlight that they have similarities but are not identical
00:52:37 <julianleviston> m0rphism:  IMHO it can be super super confusing. But sure.
00:52:39 <m0rphism> julianleviston: if your coming from oop then your brain does that no matter what, at least that was my experience back then ;)
00:55:31 <elliptic00> data Maybe a = Nothing | Just a,   is Nothing like a identity map in abstract algebra?
00:56:18 <shachaf> Not in any way I can think of.
00:57:08 <elliptic00> fmap (+2) Nothing, return Nothing
00:57:22 <julianleviston> elliptic00: it does.
00:57:25 <shachaf> Well, Maybe gives you the free monoid on a semigroup, which is kind of like adding an identity.
00:57:33 <awpr> Nothing is the identity element of several monoids formed by Maybe
00:57:40 <awpr> but it's not the identity function
00:58:17 <m0rphism> elliptic00: I think the basic idea is, that you have an algebra, where the objects of interest are types, and the operations are "take the cartesian product of two types" and "take the disjoint sum of two types" (intuition would be thinking of types as sets of their value).
00:58:33 <m0rphism> *values
01:00:38 <elliptic00> Maybe is functor in Haskell definition
01:01:07 <m0rphism> elliptic00: yes
01:01:20 <julianleviston> elliptic00: or at least, it has a Functor instance (it has other instances, too).
01:02:30 <elliptic00> two laws:  1. F(fg) = F(f)F(g) and 2. F(id_x) = idF(x)
01:02:38 <Ferdirand> what's the free monoid on a semigroup ?
01:02:58 <elliptic00> where is F(id_x) = idF(x) in Maybe?
01:03:08 <Ferdirand> semigroup i get, but the wikipedia definition of the free monoid doesn't make sense to me in that context
01:03:26 <julianleviston> elliptic00: the laws are not explicitly defined‚Ä¶ 
01:03:31 <julianleviston> elliptic00: often
01:04:48 <m0rphism> elliptic00: Here are the laws in haskell syntax: https://wiki.haskell.org/Typeclassopedia#Laws
01:05:28 <m0rphism> julianleviston: of course the laws are explicitly defined. Haskell just doesn't verify that there true.
01:05:36 <m0rphism> *they are
01:05:53 <julianleviston> m0rphism: they‚Äôre not defined in code, which is what I would expect to be ‚Äúexplicit‚Äù.
01:06:15 <elliptic00> Why we can't see Maybe define the two laws?
01:06:27 <julianleviston> m0rphism: apologies for any imprecision in my semantics.
01:06:42 <m0rphism> julianleviston: ambiguity happens ;)
01:06:54 <m0rphism> elliptic00: They hold for Maybe, but there is no need to specify them
01:07:50 <julianleviston> m0rphism:  why DOESN‚ÄôT Haskell‚Äôs typechecker verify that instances are law-abiding? I‚Äôve often been curious about that
01:07:51 <m0rphism> elliptic00: e.g. `Maybe` is a functor, and hence we know that `fmap id (Just x) = Just x`.
01:08:17 <m0rphism> julianleviston: because it's non-trivial to proof that.
01:08:27 <julianleviston> m0rphism:  proove*. Ok.
01:08:43 <julianleviston> m0rphism: you could do some quickchecking tho, no?
01:09:31 <m0rphism> julianleviston: You can proove that by hand in languages with stronger type systems, like Agda, Idris, and Coq, but there it requires human help to write the proofs.
01:09:42 <m0rphism> julianleviston: You can, but that's no proof.
01:10:27 <julianleviston> m0rphism: it just surprised me that there‚Äôs no automated checking of the rules, is all, I guess‚Ä¶ all good :)
01:12:34 <m0rphism> elliptic00: It's like when you know that the natural numbers are a monoid with + and 0, then + is associative and 0 the neutral element.
01:13:29 <m0rphism> elliptic00: The associativity and the neutrality are the laws of a monoid, in the same way that the above laws are the laws of a functor.
01:13:41 <elliptic00> can anyone explain what is monoid(I know the algebraic definition)   an monad?
01:14:00 <ggole> Automated checking of arbitrary properties sounds pretty undecidable
01:14:14 <elliptic00> what is example in Haskell for monoid and monad?
01:15:09 <m0rphism> elliptic00: I was also talking about the algebraic definition.
01:16:12 <julianleviston> elliptic00: in what sense are you asking what a monoid is?
01:16:12 <m0rphism> elliptic00: it's basically the same in Haskell, for example `[Int]` is a monoid with list concatenation as associative operation and the empty list [] as neutral element.
01:16:55 <julianleviston> elliptic00: Monoid is a typeclass that lets types ‚Äúbe a monoid‚Äù.
01:16:56 <elliptic00> ok, can you expplain what is Monad? in Haskell?  
01:18:27 <m0rphism> elliptic00: that's a tough one, it remember it taking me quite some time of meditiation to fully finall grasp the concept :)
01:19:00 <julianleviston> elliptic00: it‚Äôs a way of connecting a bunch of function applications together that can do something within a ‚Äúcontextual frame‚Äù as well as producing/consuming values.
01:19:21 <ggole> If only there were a tutorial on the subject...
01:19:25 <julianleviston> ggole: lol
01:19:29 <m0rphism> ;)
01:19:56 <elliptic00> I read a few of them, but I d't get it.
01:19:59 <julianleviston> elliptic00: take the Maybe monad. 
01:20:27 <julianleviston> elliptic00: Maybe has a Monad instance which forms a way to chain a whole bunch of function calls together and ‚Äúearly expire‚Äù on the Nothing value.
01:21:33 <julianleviston> elliptic00: I reckon the best way to understand them is to go through the process of learning Monoid -> Functor -> Applicative -> Monad.
01:22:51 <julianleviston> elliptic00: the reason is that if you follow that path, it becomes apparent that they‚Äôre just a sort of extension of Applicative. The primary point of confusion is the ‚Äúgluing of two things together that both would return a wrapped result‚Äù in other words, if you have a function of a to [a], and another of a to [a], how do you glue them together? Monad answers that question
01:22:53 <elliptic00> Ok, I'm in functor now, my next step will be Applicative.. :
01:23:35 <julianleviston> elliptic00: Monad allows you to unwrap the first function‚Äôs ‚Äúwrapper‚Äù to feed it into the second function.
02:17:57 * hackagebot pandoc-placetable 0.2 - Pandoc filter to include CSV files  https://hackage.haskell.org/package/pandoc-placetable-0.2 (mb21)
02:42:44 <jpcooper> I am trying to gain an intuition for what applicative functors are. I understand that functors define a homomorphism between categories. Is it safe to say that an applicative functor is a normal functor that also maps "applications" inside the domain?
02:50:19 <matsuura> https://www.youtube.com/watch?v=E814iS5w42M
02:57:07 <Copperis> I have a question regarding how ghc works. In this fibonacci example -> http://lpaste.net/142759 on the last line, the both `fibo` calls would be done using the same parameters for the most part. Is there any automatic caching of return values being done or does ghc compute those values each time for both calls?
02:58:02 * hackagebot cryptonite 0.8 - Cryptography Primitives sink  https://hackage.haskell.org/package/cryptonite-0.8 (VincentHanquez)
02:58:44 <orion> How can I tell QuickCheck to only generate bytestrings of a fixed length?
02:59:05 <lyxia> Copperis: No you must rewrite the function if you want caching
02:59:29 <Copperis> lyxia, how could it be rewritten?
03:00:41 <lpaste> akegalj pasted ‚Äústrange ghc rts behaviour‚Äù at http://lpaste.net/142760
03:00:55 <lyxia> Copperis: by storing all results in a lazy list for example
03:02:27 <Copperis> lyxia, ok, thanks
03:03:17 <akegalj> can someone explain me why this is a case http://lpaste.net/142760 ? Running some serial task inside parallel has worse performanse if run with more cores, so if -N is bigger, running time is worse and intuatively it should be the same
03:03:54 <akegalj> so running with -N10 has 10x worse performanse
03:05:34 <joco42> i am trying to install haskell-mode but this is the result:
03:05:40 <phadej> akegalj: how much worse? you might trigger https://ghc.haskell.org/trac/ghc/ticket/9221 bug in rts
03:05:42 <joco42> https://usercontent.irccloud-cdn.com/file/7LA4fHTy/Screen%20Shot%202015-10-11%20at%2012.58.40.png
03:05:43 <joco42> error
03:05:51 <joco42> any idea what am i doing wrong?
03:05:56 <akegalj> phadej: -N10 is 40x slower then -N1
03:06:29 <joco42> i am following this  guide : https://github.com/haskell/haskell-mode
03:06:59 <joco42> this is my emacs version: 
03:07:07 <joco42> https://usercontent.irccloud-cdn.com/file/oPKzz5ym/Screen%20Shot%202015-10-11%20at%2013.00.26.png
03:07:08 <akegalj> phadej: thnx for the link, I am looking into it
03:08:18 <phadej> akegalj: not to mention that -N with bigger number than cores you have, is very bad idea.
03:08:30 <phadej> counthing hyperthreads as one
03:10:17 <akegalj> phadej: yes, that might be a case on my machine (as it has only 2 cores). But we had similar issue on job using all (48 cores). So I am trying to replicate the issue. Ill try on that machine now
03:12:15 <phadej> akegalj: than it's definitely the bug I linked, try the flags mentioned in the comments for tweaking GC
03:12:25 <phadej> and run with +RTS -s
03:14:21 <phadej> there's a new cool feature on the stackage btw: https://www.stackage.org/diff/lts-3.7/lts-3.8
03:18:07 <akegalj> phadej: thanks, Ill take a look at those GC flags
03:18:23 <Copperis> I have a fibonacci functions that caches the intermediate values -> http://lpaste.net/142761 can anyone explain to me what the 2nd line does? Maps a number to a list and gets the value at the index passed to the function?
03:18:29 <Copperis> *function
03:19:09 <Copperis> as in I don't completely understand what it does
03:19:51 <phadej> Copperis: it does exactly what you told
03:20:37 <Copperis> phadej, how can it map a number to a list? Does that mean it replaces all values of that list with that number?
03:20:42 <phadej> except that that one is not cached
03:21:24 <phadej> Copperis: map fib [0...] == [0,1,1,2,...] 
03:21:32 <m0rphism> joco42: are you using spacemacs or regular emacs?
03:22:03 <joco42> m0rphism: this is regular, spacemacs unfortunately does not play well with solarized colors
03:22:39 <joco42> m0rphism:  there is an issue about it https://github.com/syl20bnr/spacemacs/issues/1269
03:22:58 <joco42> they are trying to fix it...
03:23:44 <m0rphism> joco42: oh, haven't noticed, I've been using monokai which seems to work nice for a dark color scheme
03:24:17 <joco42> m0rphism:  yeah, should be fixed soon, so perhaps i just wait for the solarized to work... then try agian :)
03:24:28 <joco42> in the meanwhile i am just trying out regular emacs
03:25:21 <Copperis> phadej, I still don't understand what happens on the second line. I recently started learning haskell. So "fib" is a function, that takes an argument itself and it get's that argument when from "mfibo x" x?
03:25:33 <m0rphism> joco42: I'm not sure why the melpa repository can't be found, maybe add it as recommended on the melpa project page? https://stable.melpa.org/#/getting-started
03:26:18 <phadej> Copperis: yes, recursively
03:26:35 <joco42> m0rphism: thanks, i look into that
03:27:38 <Copperis> doesn't make sense to me
03:27:42 <mniip> edwardk, wait, isn't ComonadStore basically the "context" detached from the value?
03:30:12 <joco42> https://usercontent.irccloud-cdn.com/file/JO1lzWQQ/Screen%20Shot%202015-10-11%20at%2013.29.29.png
03:30:21 <joco42> m0rphism: I've tried that... no luck...
03:31:39 <m0rphism> joco42: then maybe ask in #emacs
03:31:50 <joco42> did that :)
03:32:51 <akegalj> phadej: on a machine where we have 48 cores, running with -N48 is ~5 times slower then running the same program with -N1. And similar slowdown is for our main task (with a much complicated code base)
03:33:09 <akegalj> phadej: anyway, Ill look into a ghc ticket link. Thanks for that
03:38:15 * hackagebot ruby-marshal 0.1.1 - Parse a subset of Ruby objects serialised with Marshal.dump.  https://hackage.haskell.org/package/ruby-marshal-0.1.1 (filib)
03:47:30 <Copperis> I don't understand how do the saved values get passed on. http://lpaste.net/142761 Does calling "mfibo" on line 6 reuse the list made on line 2 somehow?
03:48:10 <lpaste> nshepperd annotated ‚ÄúNo title‚Äù with ‚ÄúNo title (annotation)‚Äù at http://lpaste.net/142761#a5621237975640702976
03:49:00 <nshepperd> Copperis: does my version make more sense?
03:49:28 <Copperis> nshepperd, I'm reading/figuring it out now, thanks
03:50:07 <zipper> How to get the architechture of a processort from haskell e.g x86_64
03:50:15 <zipper> *?
03:50:26 <zipper> I've seen it somewhere but I can't remember it.
03:51:02 <hvr> zipper: http://hackage.haskell.org/package/base-4.8.1.0/docs/System-Info.html
03:52:03 <hvr> works only for lucky host systems though
03:52:27 <albertus1> hvr: are those values set by the compiler? i'm wondering whether these (at least os and arch) should be monadic (IO)
03:52:50 <nshepperd> Copperis: I think that your original definition of mfibo relies on a rather undocumented implementation detail: the operator section (map fib [0..] !!) allocates a value for 'map fib [0..]' (just one list) and then returns (!!) partially applied to that list. and that is the value of mfibo
03:53:16 <hvr> albertus1: those values are statically determined at compiletime
03:53:28 <hvr> albertus1: so it's perfectly reasonable they're not in IO
03:53:40 <nshepperd> Copperis: so that way the fact that the same mfibo gets reused means that the same list gets reused
03:54:58 <hvr> albertus1: also, you wouldn't expect a program to change its os or arch during execution, would you? :)
03:57:01 <albertus1> hmm, thinking of heterogeneous parallel computing... not sure ;)
03:59:08 <albertus1> as long as there are no "binarily compatible" different possible values for "os", i think it's fine to have it set by the compiler
04:02:49 <clinton> sorry, I'm totally confused by this one. "import Data.Functor (Identity)" throws the error "Module ëData.Functorí does not export ëIdentityí" but I'm running GHC 7.10.2 which clearly has "Data.Functor.Identity" as documented on Hackage. Does anyone have any ideas regarding what's screwy?
04:05:36 <montanonic> clinton: ah, that's because Identity is an *instance* of Functor
04:06:08 <montanonic> clinton: I'm not sure what module *exports* Identity, but importing Data.Functor only brings that instance into scope, but not Identity itself, if that makes sense.
04:06:26 <zipper> Hey how can I get the output of the version of GHC from a library or something?
04:06:34 <zipper> As in something like 7.10.2
04:06:53 <zipper> There's http://hackage.haskell.org/package/base-4.8.1.0/docs/System-Info.html#v:compilerVersion
04:07:00 <zipper> but it's not complete
04:07:03 <montanonic> clinton: this is, by the way, why there is a functionality in writing `import Data.Functor ()`, which imports the instances from a module, but nothing else. 
04:07:05 <clinton> But here it says "Identity" is a newtype: https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Functor-Identity.html#t:Identity
04:07:38 <m0rphism> clinton: import Data.Functor.Identity
04:07:40 <clinton> (I've actually implemented my own more general version of Functor, but I'd like the existing instances to work)
04:07:50 <m0rphism> clinton: it has its own module
04:08:00 <m0rphism> clinton: btw, you can ask hoogle for such things: https://www.haskell.org/hoogle/?hoogle=Identity
04:08:17 <montanonic> clinton: if you check the module Data.Functor section, it doesn't export Identity, as indicated: http://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.Functor.html
04:08:17 <clinton> oh, I see, I misread, silly me
04:08:22 * hackagebot cli 0.0.5 - Simple Command Line Interface Library  https://hackage.haskell.org/package/cli-0.0.5 (nicolasdp)
04:09:50 <Copperis> nshepperd, in you example http://lpaste.net/142761 fibs on line 4 gets the argument from mfibo and in "map fib [0..]" passes it to fib?
04:11:49 <orion> What is the point of CoArbitrary in QuickCheck?
04:18:50 <Copperis> nshepperd, I think I found a stackoverflow answer for this thing: http://stackoverflow.com/questions/11466284/how-is-this-fibonacci-function-memoized
04:21:34 <lyxia> orion: To generate random functions
04:23:31 <julianleviston> Copperis: oh that‚Äôs a cool stack overflow. Thanks for mentioning it! I didn‚Äôt know the fib n = 1:1:zipWith (+) etc. worked that way...
04:25:06 <Copperis> julianleviston, np, now to take in and understand what is said there
04:25:06 <julianleviston> Copperis: more importantly, I hadn‚Äôt seen how that zipWith one was actually memoized until I read that. Makes sense now, though.
04:25:21 <julianleviston> Copperis: ah‚Ä¶ let me know if you need help, I might be able to!
04:25:33 <Copperis> julianleviston, ok
04:34:04 <nicow> Hi there, where can I find documentation about eventlog? The package page has only very sparse doc...
04:47:33 <julianleviston> Wow‚Ä¶ Monad Transformers are baking my brain.
04:48:00 <selckin> jummy
04:55:00 <fizruk>  
05:18:46 <hexagoxel> does not type-check, Baking is a food transformer.
05:27:12 <blueonyx> does this mean brain is no food?
05:27:29 <_wordsarewind_> calm down there, hannibal
05:28:37 <blueonyx> i just had liver with some fava beans and a nice chianti
05:29:12 <_wordsarewind_> that film is excellent
05:32:27 <phaazon> Silence of the Lambs?
05:32:47 <_wordsarewind_> yes
05:32:56 <phaazon> great movie, indeed
05:33:19 <_wordsarewind_> I mean the film itself is a bit silly, yet the interactions between the detective and hannibal are lovely
05:33:20 <youngthugga> too violent
05:33:35 * hackagebot wavefront 0.1 - Wavefront OBJ loader  https://hackage.haskell.org/package/wavefront-0.1 (DimitriSabadie)
05:33:44 <magneticduck> today I'm playing a game I call 'guess the channel'
05:33:54 <magneticduck> I have to figure out what channel I'm on without looking at the channel name in my client
05:34:03 <magneticduck> #filmreviews?
05:34:03 <_wordsarewind_> and?
05:34:05 <_wordsarewind_> xD
05:34:17 <magneticduck> darn, still have 2 tries left
05:35:08 <magneticduck> hey that could be a thing though
05:35:21 <magneticduck> a game where people get a live feed of an active channel and they have to guess its name as fast as they can
05:35:37 <dramforever> magneticduck: it could be a bit hard here now, because it's rather quiet
05:36:22 <dramforever> I wonder if you're allowed to look at the people list =P and stop this off topic meta-discussion
05:37:59 <magneticduck> what could I see in the people-list
05:39:01 <dramforever> magneticduck: bots (more or less) specific to this channel...still hard though because of long list
05:39:36 <zomg> magneticduck: that's a fun idea, too bad the channel name is so clearly visible in my client =)
05:40:32 <dramforever> zomg: hmm...we could bring it back on topic if someone is going to ... wait are you still trying to guess it, magneticduck ?
05:41:20 <magneticduck> zomg: imagine, say, a website where you join a little party and you all see a live feed of a channel with some information severely reduced, leaving only the conversation
05:42:00 <magneticduck> well from hackagebot's notification I already know it's #haskell
05:42:07 <dramforever> fine
05:42:09 <magneticduck> so you can go back to topic lol
05:42:37 <dramforever> perhaps code up this game? but that "information severely reduced" part is kinda hard...
05:42:57 <zomg> no topic and no names
05:43:07 <magneticduck> I would if I wasn't already invested in two projects
05:43:08 <zomg> that would probably be a start
05:43:12 <albertus1> no names is hard, too, when people refer to each other
05:43:35 <zomg> you can try to make an educated guess, it would work for most cases. Ie. list of users on the channel and use that as a blacklist
05:43:50 <magneticduck> yeah but in some cases, the viewer would end up gaining information
05:43:55 <zomg> or even something like filtering out messages that start with `word, ` or `word: `
05:43:58 <magneticduck> imagine somebody is named 'haskell'
05:44:12 <magneticduck> and somebody says 'haskell is an interesting functional language with a compiler named ghc'
05:44:28 <magneticduck> and your code blacks out the first word of that sentence because it assumes it's referring to the nick
05:44:42 <magneticduck> but anyway x)
05:44:52 <dramforever> yes somebody is named Haskell, but he shouldn't be here at all =P
05:45:14 <magneticduck> GHCI: but you, for instance, would pose a problem
05:45:47 * dramforever remembers that some time ago there's someone named "so"
05:48:38 * hackagebot wavefront 0.1.0.1 - Wavefront OBJ loader  https://hackage.haskell.org/package/wavefront-0.1.0.1 (DimitriSabadie)
05:49:14 <dramforever> and I remember saying in #fedora "mock is running" (where mock is some automated building program) and got mock saying "/me is running"
05:49:35 <mniip> there was this guy named Obviously
05:49:49 <mniip> also some jerk called eyes
05:50:55 * dramforever wonders if there's someone called "to"...could seriously mess up the game
05:51:16 <mniip> [14:45:05] -NickServ- Information on to (account DLange):
05:51:46 <dramforever> lol
06:21:13 <julianleviston> :t guar
06:21:14 <lambdabot>     Not in scope: ‚Äòguar‚Äô
06:21:15 <lambdabot>     Perhaps you meant ‚Äòguard‚Äô (imported from Control.Monad.Writer)
06:21:16 <julianleviston> :t guard
06:21:17 <lambdabot> Alternative f => Bool -> f ()
06:22:25 <julianleviston> :t empty
06:22:26 <lambdabot> Alternative f => f a
06:38:44 * hackagebot publicsuffix 0.20151011 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20151011 (wereHamster)
06:39:38 <julianleviston> :t set
06:39:39 <lambdabot> ASetter s t a b -> b -> s -> t
06:40:43 <dramforever> hint: /query lambdabot to have more fun without spamming in the channel
06:41:17 <julianleviston> dramforever: yep. thx
07:00:15 <SlimCow> Hey! I can't use the ghc command under Windows to compile. It doesn't recognize it "`ghc` is not recognized as an internal or external command, operable program or batch file."
07:01:47 <liste> SlimCow how did you install ghc?
07:02:18 <SlimCow> from here https://www.haskell.org/platform/
07:02:56 <albertus1> make sure the location (directory) of ghc.exe is in the %PATH% environment variable, or write it out with the path explicitly
07:06:25 <dramforever> hmm...I thought the platform should add the path of ghc.exe to %PATH%
07:08:03 <SlimCow> thanks albertus1, I manually introduced the path so now it works
07:11:36 <albertus1> i would have thought so, too, but that was the first thing I would have double-checked. it's like debugging, don't trust your own assumptions :)
07:25:02 <orion> Hi. Is there an easy way to use QuickCheck to generate Arbitrary fixed-length ByteStrings? I tried "resize 32 arbitrary" but that didn'
07:25:06 <orion> didn't seem to help*
07:25:49 <Myrl> What's the equivalent of `(on f id)`? `=<< f` ?
07:26:04 <dramforever> :t replicateM arbitary
07:26:05 <lambdabot>     Not in scope: ‚Äòarbitary‚Äô
07:26:05 <lambdabot>     Perhaps you meant ‚Äòarbitrary‚Äô (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
07:26:12 <dramforever> :t replicateM arbitrary
07:26:14 <lambdabot>     Couldn't match expected type ‚ÄòInt‚Äô with actual type ‚ÄòGen a0‚Äô
07:26:14 <lambdabot>     In the first argument of ‚ÄòreplicateM‚Äô, namely ‚Äòarbitrary‚Äô
07:26:14 <lambdabot>     In the expression: replicateM arbitrary
07:28:32 <dramforever> :t BS.pack <$> replicateM 32 arbitrary -- my first try, could be very inefficient
07:28:33 <lambdabot> Gen BSC.ByteString
07:28:52 * hackagebot ListLike 4.2.1 - Generic support for list-like structures  https://hackage.haskell.org/package/ListLike-4.2.1 (DavidFox)
07:33:52 * hackagebot Fractaler 3 -   https://hackage.haskell.org/package/Fractaler-3 (serprex)
07:40:06 <phaazon> swin 1
07:40:09 <phaazon> oops
07:49:08 <inaff> take 10 [10..]
07:49:26 <fizruk> > take 10 [10..]
07:49:28 <lambdabot>  [10,11,12,13,14,15,16,17,18,19]
07:49:54 <inaff> > :t 2
07:49:55 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
07:50:58 <inaff> > if 3 > 2 then Just 3 else Nothing
07:50:59 <lambdabot>  Just 3
07:51:51 <inaff> @ty 2
07:51:52 <lambdabot> Num a => a
07:52:09 <inaff> @ty Just 2
07:52:10 <lambdabot> Num a => Maybe a
07:53:01 <inaff> @ty Just 2 :: Maybe Int
07:53:02 <lambdabot> Maybe Int
07:54:14 <inaff> @hoogle String -> Bool
07:54:16 <lambdabot> Test.QuickCheck.Text isOneLine :: String -> Bool
07:54:16 <lambdabot> System.FilePath.Windows hasDrive :: FilePath -> Bool
07:54:16 <lambdabot> System.FilePath.Posix hasDrive :: FilePath -> Bool
07:55:01 <bollu> can I get a lens for a sum type
07:55:02 <bollu> ?
07:55:16 <bollu> something like A -> Some(A) when you try to focus?
07:55:20 <bollu> not sure if that makes sense
07:55:51 <bollu> I guess what I want is a refinement type like structure.
07:56:40 <inaff> @pl \f a b -> f (f b a) (f b a)
07:56:41 <lambdabot> ap (ap . (ap .) . liftM2 (.) (.) flip) flip
07:58:34 <inaff> @pl \l -> sum l / (fromIntegral . length) l
07:58:34 <lambdabot> liftM2 (/) sum (fromIntegral . length)
07:59:27 <fizruk> bollu: you can get a prism
07:59:55 <bollu> fizruk: what does that do?
08:00:09 <fizruk> > (Just "hello", 3) & _1._Just %~ length
08:00:11 <lambdabot>  (Just 5,3)
08:00:31 <BooneJS> Hey all, I'm working through the early release of haskellbook.com. Chapter 3, print5broken.hs has a function that looks like this, and my solution. Is my solution what the author intended? http://pastebin.com/Y6ePu4au
08:00:58 <bollu> huhh
08:00:59 <fizruk> bollu: https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
08:01:08 <bollu> thanks!
08:01:17 <bollu> fizruk: how do you know which operator does what?
08:01:27 <fizruk> :t _Just
08:01:28 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Maybe a) (f (Maybe b))
08:02:14 <bollu> :t Choice
08:02:15 <lambdabot> Not in scope: data constructor ‚ÄòChoice‚Äô
08:02:17 <bollu> :info Choice
08:02:23 <fizruk> bollu: well, you could tell from the type... if you are kmett-like enough
08:02:46 <fizruk> bollu: but this one is pretty obvious from its name
08:04:01 <bollu> I wish it was obvious :(
08:04:14 <fizruk> bollu: I think generally prisms start with underscore and a capital letter (like constructors) and lenses ‚Äî with underscore and a small letter (like functions)
08:05:01 <lpaste> BooneJS pasted ‚Äúprint5broken.hs‚Äù at http://lpaste.net/142767
08:05:11 <bollu> http://haddock.stackage.org/lts-3.8/lens-4.12.3/Control-Lens-Prism.html#t:Choice <- found it, I think?
08:05:51 <fizruk> bollu: yes
08:06:50 <fizruk> bollu: I suggest you go through that tutorial, I am no expert on lens :)
08:07:06 <Gurkenglas> BooneJS, probably not, since printSecond and putStrLn would be identical...
08:07:13 <fizruk> bollu: when you have questions ‚Äî feel free to ask here or on #haskell-lens
08:07:29 <bollu> oh, thanks! I didn't know that existed
08:08:26 <Gurkenglas> I'd just do 'main = replicateM 2 $ putStrLn "Yarrrrr"' :P
08:09:09 <orion> If I have a function foo x y :: ByteString -> State -> (ByteString, State), given a [ByteString], how can I chain together many calls to foo? I am looking at foldl', but I am having difficulty deciding what my accumulator should be.
08:10:25 <mniip> I should figure out the arcane lens stuff someday
08:12:26 <mniip> > extend (1:|2:3:[])
08:12:28 <lambdabot>  Not in scope: ‚Äòextend‚Äô    Not in scope: data constructor ‚Äò:|‚Äô
08:12:28 <lambdabot>      Perhaps you meant one of these:
08:12:28 <lambdabot>        ‚Äò:+‚Äô (imported from Data.Complex),
08:12:31 <mniip> :/
08:12:57 <cofo> stop hack
08:13:51 <Gurkenglas> :t runState . sequence . map state . map ?foo -- orion
08:13:52 <lambdabot> (?foo::a1 -> s -> (a, s)) => [a1] -> s -> ([a], s)
08:14:08 <mniip> huh
08:14:09 <cofo> what is this
08:14:22 <mniip> duplicate for NonEmpty is 'tails' ?
08:14:23 <cofo> :t a
08:14:25 <lambdabot> Expr
08:14:31 <cofo> :t sudo apt-get upgrade
08:14:32 <lambdabot> Not in scope: ‚Äòsudo‚Äô
08:14:33 <lambdabot>     Not in scope: ‚Äòapt‚Äô
08:14:33 <lambdabot>     Perhaps you meant one of these:
08:14:52 <cofo> don't you forget to upgrade
08:15:08 <Gurkenglas> @@ cofo's spamming? @where ops
08:15:08 <lambdabot> Plugin `compose' failed with: Unknown command: ""
08:15:17 <Gurkenglas> Dangit.
08:15:32 <liste> @where ops
08:15:32 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
08:15:38 <cofo> i don't spam
08:15:53 <cofo> i want to learn haskell
08:16:32 <cofo> but it's cost money
08:17:38 <liste> what do you mean?
08:18:55 * hackagebot luminance-samples 0.3 - Luminance samples  https://hackage.haskell.org/package/luminance-samples-0.3 (DimitriSabadie)
08:19:45 <mniip> why is the Show instance for Tree so ugly :(
08:19:50 <pifon> Hackernews. Suggested this place
08:19:54 <mniip> would've been better without records
08:20:46 <Rembane> Are we being invaded by slightly confused IRC-bots?
08:21:31 <pifon> I'm not a bot
08:21:37 <bernalex> Rembane: haha
08:21:52 <cofo> ,docs
08:21:55 <cofo> !help
08:21:57 <cofo> !books
08:22:02 <cofo> nothing ? :(
08:22:20 <liste> @where learnhaskell
08:22:21 <lambdabot> https://github.com/bitemyapp/learnhaskell
08:22:24 <mniip> @where lyah
08:22:24 <lambdabot> http://www.learnyouahaskell.com/
08:22:35 <mniip> @where rwh
08:22:35 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
08:22:58 <int-e> https://www.haskell.org/documentation
08:23:09 <int-e> (starts with a list of books)
08:24:09 <cofo> that's big resources
08:24:22 <cofo> i will gonna lost :<
08:26:05 <orion> Gurkenglas: Hmm, in your example, what's the type of 'state'?
08:26:30 <cofo> liste, mniip, int-e help?
08:26:35 <cofo> i mean advise
08:26:49 <exio4> @type state
08:26:50 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
08:27:18 <mniip> cofo, would you prefer to read about haskell and absorb information, or to actively learn it by doing excercises?
08:27:24 <orion> Oh, look at that.
08:27:40 <exio4> MonadState is basically what you had there
08:27:44 <cofo> I want to know why should I learn it and I want to learn it,
08:27:48 <orion> exio4: Interesting.
08:28:05 <exio4> er, State, not MonadState :)
08:28:17 <cofo> exercises is good but anything prefer from people who did that
08:33:56 * hackagebot luminance 0.3.1.1 - Type-safe, dependently-typed and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.3.1.1 (DimitriSabadie)
08:38:56 * hackagebot mtl-unleashed 0.6 - MTL classes without the functional dependency  https://hackage.haskell.org/package/mtl-unleashed-0.6 (DavidFox)
08:48:57 * hackagebot yesod-core 1.4.15.1 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.4.15.1 (GregWeber)
08:50:15 <Gurkenglas> :t ala StateT traverse -- orion
08:50:16 <lambdabot> (Monad m', Traversable t) => t (s' -> m' (a', s')) -> s' -> m' (t a', s')
08:50:38 <Gurkenglas> :t (au (mapping $ _Wrapping Identity) . alaf StateT) traverse -- To get rid of Identity :/ is there a better way?
08:50:39 <lambdabot> Traversable t => t (s' -> (a', s')) -> s' -> (t a', s')
08:51:01 <mniip> *red cross appears* there's got to be a better way
08:51:39 <Gurkenglas> :t alaf StateT traverse -- Oh and orion, this one immediately gives you a spot for your foo
08:51:40 <lambdabot> (Monad m', Traversable t) => (a -> s' -> m' (a', s')) -> t a -> s' -> m' (t a', s')
09:03:57 * hackagebot hops 0.1.3 - Handy Operations on Power Series  https://hackage.haskell.org/package/hops-0.1.3 (AndersClaesson)
09:04:43 <tomus> my function, entropy accepts a list, so [a] -> a. How do I feed it a tuple?
09:05:05 <tomus> or make tuple foldable
09:05:45 <Gurkenglas> tomus, your question would be more elegant in the form of: "I request ([a] -> a) -> ([a],[a]) -> (a, a)"
09:06:05 <Gurkenglas> (If I didn't represent your question correctly, that's why that form is more elegant :P)
09:07:20 <Gurkenglas> (And of course, if that was your question, the type you should actually asking us to inhabit is "(a -> b) -> (a, a) -> (b, b)")
09:07:21 <tomus> perhaps I want foldr (+) 0.0 (0.1, 0.2, 0.4) to work
09:07:37 <mniip> that's impossible
09:07:57 <monochrom> you have to do your own (\(x,y,z) -> [x,y,z])
09:07:59 <Gurkenglas> That's not a type, and why don't you want a list? If you want "A list but with fixed size", look at vector
09:08:08 <monochrom> tuples and lists are unrelated
09:08:18 <tomus> yeah I think I am missing something
09:08:26 <tomus> why are they not foldable
09:08:32 <ggole> foldr (+) 0.0 (f triple), where f converts to list?
09:09:29 <mniip> tomus, tuples are conceptually unrelated to lists
09:09:30 <Gurkenglas> tomus, the kind of Foldable is ((* -> *) -> Constraint), and the kind of (,,) is (* -> * -> * -> *). You cannot make an instance of Foldable for that, you'd need to make your own ADT like data Triple a = Triple a a a
09:09:42 <monochrom> because lists already exist.
09:09:44 <mniip> tuples are, for example, heterogeneous
09:09:52 <tomus> mniip: ah ok
09:09:56 <tomus> that makes more sense now
09:10:02 <mniip> :t ((), True, 1)
09:10:03 <lambdabot> Num t => ((), Bool, t)
09:10:06 <Gurkenglas> (writing "deriving Foldable" after that is also nice.)
09:10:08 <mniip> :t [(), True, 1]
09:10:09 <lambdabot>     Couldn't match expected type ‚Äò()‚Äô with actual type ‚ÄòBool‚Äô
09:10:09 <lambdabot>     In the expression: True
09:10:09 <lambdabot>     In the expression: [(), True, 1]
09:10:26 <tomus> but (a, a, a) could be foldable?
09:10:33 <mniip> no
09:11:00 <mniip> only things that take a type argument can be foldable
09:11:16 <mniip> such as [] and Maybe 
09:11:36 <mniip> and (Either e)
09:11:39 <tomus> ok
09:11:41 <tomus> got it
09:11:58 <mniip> theoretically, Œõa -> (a, a, a) could be an instance of Foldable
09:12:05 <mniip> but the haskell type system has no way to express that
09:12:10 <ggole> data Triple a = Triple (a, a, a)
09:12:12 <ggole> Meh
09:12:19 <mniip> other than an explicit newtype like one ggole pasted
09:12:25 <phaazon> hm
09:12:35 <phaazon> Ignoring unusable UNPACK pragma on the second argument of ‚ÄòSieve‚Äô
09:12:42 <phaazon> why can GHC not do that?
09:12:51 <phaazon> the argument is a [Maybe Int]
09:13:02 <mniip> how do you UNPACK a [Maybe Int]
09:13:23 <ggole> Actually, that should probably be either newtype or Triple a a a.
09:13:33 <monochrom> which is why I jumped straight to "because lists exist". lists exist, so people don't even bother with Triple.
09:14:11 <mniip> phaazon, UNPACK only applies to unboxable types
09:15:01 <phaazon> mniip: what make a type unboxable?
09:15:05 <phaazon> the bang pattern?
09:15:09 <phaazon> lists can‚Äôt be?
09:15:47 <mniip> phaazon, no, unboxed types are separate from laziness
09:16:09 <phaazon> mniip: I see DList can‚Äôt be as well
09:16:13 <phaazon> what make them so special then?
09:17:03 <mniip> phaazon, only a limited set of types, that has unboxed equivalents
09:17:27 <mniip> no wait
09:17:45 <monochrom> the GHC user's guide tells you what types can enjoy UNPACK
09:18:36 <mniip> UNPACK unpacks a constructor
09:19:15 <mniip> "Any single-constructor data is eligible for unpacking"
09:19:31 <mniip> yeah it is just that in case of Int the unpacked field is an Int#
09:19:35 <exio4> data Int = I# Int# 
09:19:39 <exio4> makes sense :) 
09:19:48 * mniip scribbles
09:30:22 <orion> hmm
09:30:44 <orion> How come I can do "property foo" where foo has any number of arguments, but I can't do the same with ioProperty?
09:31:19 <orion> (In QuickCheck)
09:31:19 <exio4> what's `property` here?
09:33:04 <orion> https://hackage.haskell.org/package/QuickCheck-2.8.1/docs/Test-QuickCheck-Property.html#v:property
09:33:46 <orion> For example, foo :: AssocData -> [Plaintext] -> CipherState ChaChaPoly1305 -> Property works properly, but bar :: Plaintext -> IO Property does not.
09:33:55 <exio4> orion: ioProperty expects all the "parameters" inside IO
09:34:02 <lupin> hi, anyone knows if the HAIFA library is still maintained?
09:34:12 <exio4> the type is IO prop -> Property, not prop -> Property with some base case for IO 
09:34:32 <lupin> or if there are equivalents for SOAP services
09:35:54 <orion> exio4: Oh, hmm. I'm not sure how to proceed. 
09:37:23 <exio4> orion: property (\x y -> ioProperty (f x y)) ? 
09:37:27 <exio4> or something like that?
09:39:57 <orion> Ah! That did it. I needed to use ioProperty within the function, not outside of it.
09:39:58 <orion> Thank you.
09:42:55 <darkf> how do I tell cabal to copy certain files alongside the binary? (I have a .dll I'd like copied to bin/ to run with it)
09:48:57 <dasdasdasd> hi
09:59:12 * hackagebot flat-tex 0.3.1 - flatten a latex multi-file latex document  https://hackage.haskell.org/package/flat-tex-0.3.1 (JohannesWaldmann)
10:00:07 <lpaste> tomus pasted ‚Äúsimple maximization brute force is a bit slow? ‚Äù at http://lpaste.net/142768
10:00:17 <ichimaru> has anyone here used Yesod?
10:00:49 <roelof> hello, any stack experts here. Is there a template which produces a main.hs with a test directory 
10:01:57 <ichimaru> roelof, you can list available templates like this: "stack templates"
10:02:44 <hexagoxel> darkf: i am not sure that is possible without resorting to a custom "build-type".
10:02:54 <roelof> I know that I tried the simple template but then no test directory and I tried new-template but then the file has a name of lib.hs 
10:03:25 <ichimaru> roelof, what do you want the template to give you?
10:03:38 <ichimaru> if its just one main.hs file, the template would be rather pointless
10:04:15 <roelof> one main,hs and a directory where I can place my tests  ichimaru 
10:05:06 <ichimaru> roelof, just do this: "touch main.hs && mkdir test"
10:05:25 <darkf> hexagoxel: ah, that's a shame
10:06:19 <athan> ichimaru: What kind of application are you using?
10:06:30 <orion> Here's a curious error: When I specify {-# ANN module "HLint: ignore Reduce duplication" #-} at the top of my module, I get a compiler error: "File name does not match module name: Saw: ‚ÄòMain‚Äô Expected: ‚ÄòMyModule.Foo.Bar‚Äô"
10:06:30 <athan> Also, do you understand monads and monad transformer stacks?
10:07:01 <ichimaru> i somewhat understan monads, transformers not so much.
10:07:09 <ichimaru> I'm not sure what application you ment
10:07:12 <ichimaru> *mean
10:07:59 <athan> ahh okay. I was just wondering how good you are with it. Would you be open to other options, rather than just Yesod? You might find others easier
10:08:19 <athan> it all depends on what you're working with though
10:08:38 <tomus> heh, haskell maximising a function over 10^6 parameters takes about 1 min. can't decide whether it's acceptable
10:09:00 <tomus> over 10^6 values rather
10:09:13 * hackagebot bindings-DSL 1.0.23 - FFI domain specific language, on top of hsc2hs.  https://hackage.haskell.org/package/bindings-DSL-1.0.23 (JohnWiegley)
10:09:15 <ichimaru> athan, I think I can cope with yesod(i hope), I'm currently trying to create middleware but get strange type errors
10:09:36 <ichimaru> Couldn't match expected type ‚ÄòImport.Request‚Äô with actual type ‚ÄòNetwork.Wai.Request‚Äô
10:10:07 <athan> ichimaru: Yesod uses some advanced techniques that are hard for beginners :\ That actually doesn't look too bad
10:10:18 <athan> the `wai` package exports `Network.Wai.Request`
10:10:52 <athan> that's the bread-and-butter for any application, you can actually make servers just using wai and warp (I actually prefer to)
10:11:07 <athan> any web application*
10:12:41 <athan> ichimaru: You can inspect packages pretty quickly with stack: `stack unpack wai && cd wai-* && stack init --resolver=nightly-2015-10-10 && stack build && stack ghci` will put you into a repl with the latest package contents
10:13:03 <athan> then you can `:browse`, `:info` and `:type` everything to your heart's content :)
10:13:09 <athan> (also <TAB> completion!)
10:13:31 <ichimaru> athan, I'm currently tring to get the domain and add it to the query parameters: http://lpaste.net/142769
10:13:53 <ichimaru> athan, thanks I'll try that, sounds a lot better than running around hackage which is what I'm currently doing
10:16:56 <Gurkenglas> > foldl1' min $ map (\x -> 2^x - x^2) [1..1200000] -- tomus, doesnt look like a minute to me
10:17:00 <lambdabot>  mueval-core: Time limit exceeded
10:17:05 <Gurkenglas> welp
10:17:29 <Gurkenglas> > foldl1' min $ map (*2) [1..1200000] -- There, that shouldnt take quadratic time
10:17:31 <lambdabot>  2
10:17:52 <JagaJaga> :t pure (+2) <*> pure (1)
10:17:53 <lambdabot> (Num b, Applicative f) => f b
10:18:16 <JagaJaga> I get that there is Applicative f. But after execution it's gone. Why?
10:18:46 <athan> JagaJaga: How is it gone?
10:18:52 <JagaJaga> :t 3
10:18:54 <lambdabot> Num a => a
10:19:02 <athan> :t pure 3
10:19:03 <lambdabot> (Num a, Applicative f) => f a
10:19:43 <athan> JagaJaga: An applicative law is that `pure f <*> pure x ~ pure (f x)`
10:20:04 <athan> or really, that `pure f <*> ~ f <$>`
10:20:21 <JagaJaga> Oh! I got everything now, stupid am I :D
10:20:54 <athan> :T
10:22:57 <nitrix> Some people are willing to insult themselves for not knowing everything.
10:23:20 <sm> in the (great!) video of ghc-vis on its home page, it looks like the :su command is used in ghci to start debugging. Does anyone know what this is ?
10:24:41 <JagaJaga> How do we call (<*>)?
10:25:19 <geekosaur> sm: -- Evaluate one step and update values in ghc-vis:def su \x -> return $ ":step " ++ x ++ "\n:update"
10:25:22 <geekosaur> nerp
10:25:32 <geekosaur> http://hackage.haskell.org/package/ghc-vis-0.7.2.7/src/ghci
10:25:43 <sm> geekosaur: ah, thanks!
10:31:27 <nitrix> JagaJaga: (<*>) somewhat means function juxtaposition. It shouldn't be pronounced different than you do with whitespaces.
10:33:09 <nitrix> "ap" or "apply" is the closest I can think of, just because of the similarities it shares with Monad.
10:35:05 <mniip> wooooah
10:35:16 <ReinH> JagaJaga: "ap"
10:35:27 <mniip> just like Monoid m => ((,) m) is a monad
10:35:35 <mniip> Monoid m => ((->) m) is a comonad
10:36:44 <tomus> Gurkenglas: why \x -> 2^x - x^2 didn't work
10:36:57 <ReinH> mniip: and Comonoid m =>> ((,) m) is a comonad, except that everything is a Comonoid
10:37:52 <mniip> ReinH, similarly Comonoid m => ((->) m) makes a monad
10:38:17 <mniip> is it related to ((->) e) being adjunct to ((,) e) on Hask?
10:38:17 <JagaJaga> nitrix: ReinH: thank you.
10:38:38 <ReinH> mniip: yep
10:39:10 <Gurkenglas> tomus, 2^1000000 has a lot of zeroes; And once that would work, but not a million times :D
10:39:37 <tomus> ah ok
10:39:47 <mniip> wait
10:39:57 <mniip> Monad is a superclass of Applicative
10:40:09 <mniip> Comonad is a cosuperclass of ComonadApply!
10:40:26 <tomus> > foldl1' min $ map (\x -> 2^x - x^2) ([1..1200000] :: [Double])
10:40:27 <orion> Is it possible to define the working directory cabal uses when it runs tests?
10:40:28 <lambdabot>      No instance for (Integral Double) arising from a use of ‚Äò^‚Äô
10:40:28 <lambdabot>      In the first argument of ‚Äò(-)‚Äô, namely ‚Äò2 ^ x‚Äô
10:40:28 <lambdabot>      In the expression: 2 ^ x - x ^ 2
10:41:02 <phadej> orion: no, but you can do http://hackage.haskell.org/package/directory-1.2.4.0/docs/System-Directory.html#v:setCurrentDirectory
10:41:15 <ReinH> mniip: Think about what adjunction gives the Reader monad.
10:41:17 <phadej> in the test
10:41:32 <mniip> ReinH, hm?
10:41:35 <tomus> > foldl1' min $ map (\x -> 2**x - x**2) ([1..1200000] :: [Double])
10:41:37 <lambdabot>  -1.0
10:42:06 <orion> phadej: Ah. Do you know what the working directory usually is? I'm trying to execute "hlint -h tests/.hlint ..." but it can't seem to find the file, even though that path is relative to the project directory.
10:42:22 <ReinH> mniip: All monads are formed by adjuncitons, and vice versa
10:42:29 <mniip> what
10:42:51 <phadej> orion: the root of the package
10:43:00 <orion> Interesting. I wonder why it can't find that file then.
10:43:20 <phadej> orion: or should be, not 100%, there is getCurrentDirectory, so you can check
10:43:32 <mniip> ReinH, I don't think I have the categorical understanding of monads yet, only a Hask one
10:43:54 <ReinH> mniip: http://www.stephendiehl.com/posts/adjunctions.html
10:44:34 <ReinH> mniip: https://www.youtube.com/playlist?list=PL54B49729E5102248
10:45:06 <orion> phadej: Ah, good idea. Thanks.
10:45:50 <phadej> you're welcome
10:47:25 <ReinH> mniip: The curry/uncurry induces state and costate.
10:47:35 <ReinH> reader and traced are induced by a different adjunction
10:47:40 <ReinH> mniip: http://www.cs.ox.ac.uk/ralf.hinze/WG2.8/28/slides/ralf.pdf
10:48:17 <ReinH> That last one is very good, but a bit dense
10:48:30 <ReinH> *The curry/uncurry adjunction
10:50:09 <ReinH> mniip: You can also see the adjunction for reader and traced literally presented (without comment) in the old category-extras package.
10:50:47 <ReinH> mniip: Here's another other presentation https://wiki.haskell.org/wikiupload/8/85/TMR-Issue13.pdf (page 73)
10:51:58 <ReinH> mniip: Ah, the new version of the adjunctions is the... adjunctions package http://hackage.haskell.org/package/adjunctions-4.2.2/docs/Data-Functor-Adjunction.html
10:53:06 <ReinH> Oh, it's reader and env, writer and traced. I always forget the names.
10:55:34 <ReinH> mniip: if it's any help, the adjunction uses the unit/counit definition of an adjunction and leftAdjunt/rightAdjunct recover the homset definition
10:55:39 <ReinH> *the adjunction package
10:56:02 <mniip> ReinH, do you have a more... gradual introduction?
10:56:15 <johnw> mniip: I'd recommend reading books that address this subject
10:56:23 <SiIky> hey how can i represent the imaginary number (j in python)?
10:56:24 <johnw> I don't think any IRC conversation will ever be able to communicate what adjunctions are
10:56:26 <mniip> not asking for a tutorial, but maybe a specific sequence of typeclasses?
10:56:51 <mniip> johnw, depends on the recipient
10:57:17 <mniip> SiIky, there is a Complex datatype, in Data.Complex
10:57:30 <johnw> I actually think it doesn't; has anyone ever grokked Monads from being in here?  You have to study them, use them, think about them
10:57:33 <ReinH> mniip: Try the Catsters videos I linked.
10:57:38 <ReinH> johnw: probably not.
10:57:41 <SiIky> mniip Aye thanks!
10:57:48 <mniip> johnw, I just brainstormed the Comonad definition for 20 minutes
10:57:53 <ReinH> mniip: Or try a good category theory book (I have recommendations if you need them)
10:57:58 <mniip> and I already have a containerific understanding of comonads
10:58:32 <ReinH> mniip: the data dump was mainly to give you some references for future use :)
10:58:51 <haskell347> wazzap
10:58:53 <mniip> ReinH, let's recursive descent
10:59:04 <mniip> what are the prerequisites for learning about adjunctions
10:59:20 <ReinH> category theory, functors, natural transformations
11:00:16 <ReinH> Depending on the presentation, universal properties
11:00:24 <mniip> what specific level (version :) ) of category theory?
11:00:54 <ReinH> well, you need to know what a category is so you can understand functors, and etc
11:01:05 <ReinH> adjunctions are defined in terms of natural transformations
11:01:29 <SiIky> found Number.Complex too, whats the difference between the two? i see some functions present in both modules
11:01:49 <mniip> ReinH, okay, let's leave that on the stack
11:01:53 <ReinH> mniip: try the catsters videos and see if they start at the right place and move at the right pace for you
11:02:01 <mniip> what are the prerequisites for natural transformations?
11:02:05 <haskell347> recomend good haskell tutorial for pythonist, pls
11:02:25 <ReinH> functors, ability to read commutative diagrams
11:02:27 <monochrom> functor is the prereq for natural transformations
11:03:16 <ReinH> it goes categories > functors > natural transformations > adjunction
11:05:02 <ReinH> mniip: if you understand the based of CT, you should try the catsters videos. Maybe if I keep saying this you will do it. :D
11:07:00 <ReinH> s/based/basics
11:07:49 <mniip> based CT
11:08:08 <exio4> category theory is crazy
11:09:13 <ReinH> mniip: :D
11:09:50 <tsahyt> ReinH: You mentioned that you have recommendations for a good category book. I'm looking for one, so I'd love to hear some recommendations
11:10:41 <ReinH> tsahyt: From easy to hard: Conceptual Mathematics by Lawvere, Basic Category Theory by Leinster, Category Theory by Awodey, Category Theory for the Working Mathematician by Mac Lane
11:10:50 <ReinH> tsahyt: The Leinster book is new and quite good
11:11:06 <ReinH> He does a great job of motivating things
11:11:24 <tsahyt> I didn't know that one, I'll check it out, thanks!
11:12:14 <ReinH> CTftWM is a bit dated by now, but still provides the best introduction to Kan extensions that I know of.
11:12:25 <ReinH> er, it's Categories for the Working Mathematician.
11:12:36 <ReinH> I thought that looked wrong
11:12:57 <johnw> how is it dated?
11:13:08 <ReinH> johnw: I think the presentation has been improved since
11:13:28 <ReinH> but conceptually, not much has changed
11:13:46 <johnw> ah, usually when people say "dated", it means the information is not as relevant anymore
11:13:56 <ReinH> yeah, poor choice of word
11:15:43 <tsahyt> Huh, 192 pages. That seems like something that I could actually work through in a reasonable amount of times
11:15:47 <tsahyt> time*
11:16:14 <hopla> hello all. I am getting a weird error while compiling c code using cabal. I got this error: "cabal: Bad header file: imgui.h". imgui.h is in the section "Includes". If I rerun Cabal, it compiles everything. If I remove the file in the list, it also compiles. Is Cabal trying to parse the header file in some way?
11:17:16 <ReinH> tsahyt: Yeah, it gets through the the basic stuff including adjoints, yoneda, representables, and limits. Thus the name, I guess.
11:17:37 <ReinH> You should be able to pick up Awodey pretty easily once you're done
11:18:32 <tsahyt> I started reading Awodey two summers ago but I didn't get very far for lack of motivation
11:19:19 <hopla> Basically, code is c++ (I am just using -x C++ to compile everything from cabal). But the header is full of c++ code. I am just going to expose everything as C function (for simpler ABI) but code is C++
11:19:30 <Copperis> what sort of math proficiency does the book by Leinster require?
11:19:38 <tsahyt> I'd really like to find the time to work through the HoTT book. I got through the first chapter rather successfully but then I was suddenly overwhelmed and decided that I should get a math major first
11:19:46 <johnw> lol
11:20:14 <hodapp> o_O
11:20:55 <tsahyt> I have yet to convince the people at the math department to let me start a math masters without the corresponding bachelor degree first. After all, my CS degree involved a fair bit of math. Somehow they're not convinced, and the more advanced math I see, the more I agree with them.
11:23:07 <hopla> arf. It seems that Cabal is processing the headers. Would you know what the purpose of the "Includes" section in cabal config files? Is it supposed to be only the functions visible to the rest of Haskell code?
11:23:21 <ReinH> Copperis: He says "an undergraduate degree", but really a basic familiarity with mathematical notation and set theory should suffice.
11:23:49 <ReinH> s/set theory/the existence and properties of naive sets
11:24:33 <tsahyt> The main problem I had when I was trying to read Awodey's book wasn't the category theory itself, but rather that I wasn't familiar with a lot of the stuff he used as examples
11:24:46 <johnw> yeah, he assumes a lot of math knowledge
11:24:50 <Copperis> ReinH, I've found a preview: https://goo.gl/LAIgnW
11:24:54 <johnw> i don't understand the majority of his examples either
11:25:44 <ReinH> johnw: Yeah, but I don't think that's necessary. I don't think he assumes that you understand them, he just presents a wide variety to try to engage with various segments of his readership
11:26:03 <ReinH> Some might stick, many might not
11:26:06 <johnw> true
11:26:18 <cocreature> I think he even states that explicitely somewhere at the beginning
11:26:33 <ReinH> cocreature: In fact he says, "
11:26:36 <ReinH> "Each new concept is illustrated with a generous supply of examples, but it is not necessary to understand them all"
11:26:41 <ReinH> Sorry, copy-paste weirdness
11:27:08 <tsahyt> I've read (most of) Categories and Computer Science by Walters this summer, and found it a very gentle introduction to CT for people with a CS background
11:27:20 <ReinH> "In courses I have taught based on earlier versions of this text, probably no student has had the background to understand every example. All that matters is to understand enough examples that you can connect the new concepts with mathematics that you already know."
11:27:41 <tsahyt> Although it doesn't even touch a lot of concepts, it's nice for building some intuition about categories
11:28:05 <shachaf> What intuition about categories?
11:28:51 <shachaf> I feel like most introductions, especially many for CS people, give misleading intuition.
11:29:04 <EvanR> an arbitrary graph isnt necessarily a category
11:29:19 <ReinH> EvanR: but it generate a free category
11:29:22 <ReinH> *generates
11:29:33 <shachaf> Or maybe it's that people get misleading intuition from reasonable introductions.
11:29:40 <EvanR> orly
11:30:06 <ReinH> EvanR: Yes, equip every node with an identity morphism. The generated category is the category of nodes and paths of edges.
11:30:07 <tsahyt> Intuition is misleading more often than not in the more abstract branches of math in my experience
11:30:10 <EvanR> by completing the graph 
11:30:27 <EvanR> ReinH: wait, i dont think thats right
11:30:52 <EvanR> just adding loops isnt enough
11:31:18 <ReinH> EvanR: specifically for directed graphs, a.k.a. quivers
11:31:25 <cocreature> EvanR: the path in ‚Äúpaths of edges‚Äù gives you the transitivity here
11:31:27 <EvanR> you also have to add more edges
11:31:31 <ReinH> EvanR: no you don't
11:31:41 <ReinH> Arrows aren't edges. They are paths.
11:31:45 <EvanR> oh
11:31:52 <ReinH> http://ncatlab.org/nlab/show/path+category
11:32:27 <ReinH> Likewise, if you forget the category structure then you get a directed graph.
11:32:47 <EvanR> for any category right
11:33:24 <ReinH> For small categories, since there are size restrictions on graphs
11:33:48 <EvanR> uh size restrictions?
11:34:15 <EvanR> i can see that if you begin withing saying "a graph is a set blah blah"
11:34:35 <ReinH> yep
11:34:38 <EvanR> but...
11:34:47 <EvanR> i hate it when stuff is a set!
11:34:53 <ReinH> So do category theorists ;)
11:35:59 <cocreature> so EvanR is on the right track to become a category theorist :)
11:36:22 * EvanR gets in his large graph car and drives off laughing maniacally
11:37:23 <t0by> Um, hi. Does Haskell have a prefix comparison operator? Like (equals 1 2) [aka False] (equals 42 42) [meaning True]?
11:37:27 <t0by> If not... why?
11:37:37 <ReinH> > (==) 1 1
11:37:39 <lambdabot>  True
11:37:44 <t0by> ouch
11:37:48 <t0by> thanks ReinH 
11:37:52 <ReinH> Any infix operator can be turned into an expression and used prefix by enclosing in ()
11:38:20 <ReinH> Well, except infix operators created using ``
11:38:24 <t0by> thanks a bunch
11:38:35 <ReinH> yw
11:38:43 <t0by> um
11:38:44 <t0by> wait
11:38:47 <d-snp_> > 1 `(==)` 1
11:38:50 <lambdabot>  <hint>:1:4: parse error on input ‚Äò(‚Äô
11:38:53 <d-snp_> ah
11:38:56 <d-snp_> aw :P
11:39:00 <ReinH> d-snp_: That's not what I said, but it also doesn't work.
11:39:05 <ReinH> > (`max`) 1 1
11:39:06 <t0by> wouldn't (('op') a b) be for all intents and purpouses equal to (op a b) anyway?
11:39:07 <lambdabot>  <hint>:1:7: parse error on input ‚Äò)‚Äô
11:39:22 <ReinH> Yes. It would be pointless.
11:39:27 <ReinH> (and it's ``, not '')
11:39:37 <d-snp_> thought I'd make a bit of fun :P
11:39:43 <t0by> Thanks again ReinH 
11:39:50 <d-snp_> but haskells parser is no fun at all >.<
11:39:52 <t0by> thanks d-snp_ for the comic relief :P
11:39:53 <ReinH> t0by: We strive for correctness at the expense of conciseness ;)
11:40:15 <ReinH> Although with Haskell we often achieve both!
11:40:31 <t0by> "Not to mention, kittens!"
11:40:57 <t0by> well, I *thought* it would sound good in context :P
11:41:05 <cocreature> are kittens concise or correct?
11:41:46 <ReinH> Yes.
11:42:07 <hexagoxel> > (`mappend` [3,4]) [1,2] -- but you can avoid flip by using a section :p
11:42:09 <lambdabot>  [1,2,3,4]
11:42:18 <Gurkenglas> It should be ` to the left of the to be infix'd term, ¥ to the right, and any terms including spaces allowed on the inside
11:42:38 <ReinH> I can't type ¬¥ easily though
11:42:50 <Gurkenglas> On my keyboard ` is shift-¥
11:46:05 <t0by> On my keyboard it i... oh, who am I kidding. I use US-international.
11:46:11 <t0by> I am confused.
11:46:35 <t0by> Prelude> let first::(a,b,c)->a; first (a,_,_) = a;
11:46:36 <t0by> Prelude> (first 1 2 3)
11:46:48 <t0by> ^^^^ why this doesn't this work for me?
11:47:30 <t0by> i such.
11:47:31 <haskell259> hello
11:47:33 <t0by> *suck.
11:47:38 <t0by> it's a tuple.
11:47:41 <t0by> nevermind.
11:48:14 <haskell259> anybodu?
11:48:29 <cocreature> haskell259: just ask your question :)
11:48:29 <t0by> somebodu, most definitely
11:48:50 <haskell259> hello?
11:49:01 <t0by> hi haskell259 
11:49:12 <haskell259> hi )
11:49:18 * hackagebot ampersand 3.1.0 - Toolsuite for automated design of business processes.  https://hackage.haskell.org/package/ampersand-3.1.0 (hanjoosten)
11:50:22 <tsahyt> t0by: How's US international for daily use and coding?
11:50:33 <haskell259> recomend me good haskell tutor, pls
11:50:49 <t0by> haskell259, http://learnyouahaskell.com/
11:51:24 <haskell259> i just finish this tutor
11:51:26 <t0by> tsahyt, suboptimal compared to US-en. But I speak a funny language with funny diacritics, so it's a compromise.
11:52:15 <t0by> congratulations, haskell259 
11:52:45 <tsahyt> I was thinking about switching from the German layout, because a lot of code-related symbols seem to be in much better positions in the US layout. But I still need umlauts and all that stuff
11:53:03 <cocreature> tsahyt: neo to the rescue :)
11:53:08 <tsahyt> neo?
11:53:24 <cocreature> http://neo-layout.org/ (I'll stop now, this is offtopic after all, sorry)
11:53:29 <geekosaur> us-international or us with compose key?
11:54:34 <tsahyt> cocreature: Switching away from the overall QWERT{Y,Z} layout is a sure way to kill all my productivity for several months I think. I like that there's a letter for greek letters though.
11:55:35 <dickewolle> just change the keyboard definition file so that the first register is querty
11:55:46 <dickewolle> qwerty*
11:55:55 <magneticduck> uh, is there a library that lets me recieve a simple http request as a Text?
11:56:04 <magneticduck> s/request/response
11:56:18 <magneticduck> HTTP seems to only use strings, does this has an impact on performance?
11:56:48 <cocreature> http-conduit and wreq use bytestrings iirc
11:57:34 <EvanR> `(==)` and (`mappend`) would be pointless, but these pointless things would be awesome f :: a -> b -> c -> d, y `f x` z (partially applied and infix)
11:59:16 <EvanR> magneticduck: just utf8decode wont work?
11:59:24 <dickewolle> ignoring space-leak problems, is it ever possible to make a completely lazy program more efficient by making some parts strict?
12:00:02 <EvanR> dickewolle: theoretically no, i think
12:00:26 <EvanR> lazy evaluation will take at most the same number of steps as eager
12:00:36 <dickewolle> that's what i was thinking too
12:01:20 <dickewolle> i'm reading okasaki's purely functional data structures, which assumes a strict language
12:02:00 <dickewolle> and it's not clear to me if i need any strictness annotations when implementing in haskell
12:02:20 <EvanR> you probably do to do exactly what hes doing
12:02:47 <EvanR> or you could use ocaml
12:02:49 <dickewolle> EvanR: make my data structures as stricct as possible?
12:03:10 <EvanR> strictness annotations, like bang patterns
12:03:24 <breadmonster> Bang patterns are awesome.
12:03:33 <EvanR> awesome for making you use tons of memory! ;)
12:03:40 <breadmonster> Really now?
12:04:19 <EvanR> sometimes
12:05:27 <breadmonster> EvanR: Example?
12:07:00 <EvanR> if you pattern match to see which constructor you have in order to make a decision, but you dont care about the payloads yet, and they havent been generated yet, then youll use more memory by using a bang pattern on them.
12:07:12 <EvanR> if the things that are being generated are large, you use more memory
12:07:31 <breadmonster> EvanR: Went over my head.
12:07:31 <EvanR> well, if the thunk that would generate them is relatively small
12:07:35 <breadmonster> A little more detail?
12:07:35 <EvanR> ;)
12:07:56 <Lokathor> is there a convientent way to declare a newtype that derives all of the base types instances *except* for a particular one?
12:07:59 <breadmonster> Maybe that statement is lying unevaluated in my head.
12:08:04 <EvanR> breadmonster: look at the length function
12:08:09 <MarcelineVQ> breadmonster: If you won't need something you don't want it to be strict
12:08:09 <EvanR> @src length
12:08:09 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
12:08:28 <EvanR> breadmonster: imagine implementing the length function using bang patterns
12:08:47 <breadmonster> `length = foldl' (\z -> const (z + 1)) 0`
12:09:05 <EvanR> and the list you check the length of contains large bytestrings
12:09:22 <EvanR> but they havent been evaluated yet, and the generator thunks are small
12:09:22 <breadmonster> EvanR: Okay, I don't see how it matters though, if it's a list of bytestrings, it should just return the bytestring.
12:09:35 <EvanR> what? were trying to compute the length of the list
12:09:36 <ReinH> breadmonster: probably the most obvious example would be cases where strictness causes evaluation to diverge on infinite input
12:09:38 <breadmonster> It's O(1)
12:10:05 <breadmonster> EvanR: The cost of evaluating a constant is O(1) right?
12:10:19 <Lokathor> breadmonster, imagine i have a finite list that contains infinite lists. If i compute the length, i need to not compute all the values in the list as well
12:10:20 <Lokathor> or bad things
12:10:27 <EvanR> talking about this function length :: [a] -> Int
12:10:41 <breadmonster> Lokathor: Sure, but like seq only evaluates to WHNF, so that case is ruled out.
12:10:52 <breadmonster> EvanR: Okay, go on?
12:11:00 <EvanR> breadmonster: a [ByteString] doesn't necessarily imply there are any actual bytestrings anywhere (yet)
12:11:21 <breadmonster> EvanR: Sure but like won't it just evaluate to WHNF?
12:11:33 <Lokathor> @let foo = [undefined,undefined] :: [ByteString]
12:11:34 <lambdabot>  .L.hs:149:34:
12:11:34 <lambdabot>      Not in scope: type constructor or class ‚ÄòByteString‚Äô
12:11:34 <lambdabot>      Perhaps you meant one of these:
12:11:39 <ReinH> breadmonster: for another obvious pessimal case, take 1 ([1..1000] ++ [1..1000]) if (++) were strict.
12:11:40 <EvanR> if you evaluated it you just get a list head and still no bytestrings
12:11:57 <breadmonster> ReinH EvanR: point taken.
12:12:17 <EvanR> breadmonster: so to compute the length, you dont want to touch the contents of each list node
12:12:18 <breadmonster> So how do you correctly pepper your code with seq?
12:12:28 <Lokathor> carefully :3
12:12:35 <ReinH> breadmonster: like this http://apfelmus.nfshost.com/blog/2013/08/21-space-invariants.html
12:14:21 <dickewolle> okasaki's haskell examples don't use bangs
12:14:52 <EvanR> well, dont add bangs to those ;)
12:15:06 <EvanR> you might get _|_
12:16:22 <breadmonster> I wish Okasaki updated his book, there's been so much progress :(
12:16:59 <dickewolle> he talks a lot about introducing laziness into an otherwise strict language - i feel confused about the theory when everything is lazy already
12:17:41 <hopla> Is there a way to specify binary literal in Haskell (like 0b000100)?
12:17:48 <EvanR> i get confused about everything when everything is strict
12:19:41 <tsahyt> hopla: I think there might be a quasiquoter somewhere
12:20:00 <tsahyt> https://hackage.haskell.org/package/binary-literal-qq
12:23:49 <roelof> any people here who are using stack ? 
12:24:10 <johnw> roelof: there is also #haskell-stack
12:24:31 <roelof> oke, thanks, I did not know that 
12:24:44 <roelof> I will ask there my questions
12:24:51 <breadmonster> EvanR: That's what too much Haskell does to you.
12:25:30 <EvanR> breadmonster: manually inserting accumulating parameters is annoying
12:25:47 <breadmonster> EvanR: as opposed to?
12:25:58 <EvanR> as opposed to not?
12:26:15 <EvanR> when you do recursion in haskell it usually just works
12:26:38 <EvanR> @src mapM
12:26:38 <lambdabot> mapM f as = sequence (map f as)
12:26:43 <EvanR> @src sequence
12:26:43 <lambdabot> sequence []     = return []
12:26:43 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:26:43 <lambdabot> --OR
12:26:43 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
12:26:51 <breadmonster> :t foldm
12:26:52 <lambdabot>     Not in scope: ‚Äòfoldm‚Äô
12:26:52 <lambdabot>     Perhaps you meant one of these:
12:26:52 <lambdabot>       ‚Äòfoldl‚Äô (imported from Data.List),
12:26:56 <breadmonster> :t foldM
12:26:57 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
12:27:01 <sm> is there a way to force the GHCI debugger to use ansi highlighting instead of vv markers in an emacs shell buffer (which has ansi-color-for-comint-mode-on) ?
12:27:03 <breadmonster> :t sequence
12:27:04 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
12:27:11 <breadmonster> What's the difference?
12:27:24 <EvanR> sequence :: Monad m => [m a] -> m [a]
12:27:36 <EvanR> breadmonster: well theres no accumulating parameter
12:28:00 <mniip> ReinH, I'm going to call functions cotuples and tuples cofunctions from now on
12:28:48 <xplat> mniip: i'm going to call you confusing and nfusing comniip from now on
12:29:12 <jophish__> This channel needs a quote function
12:29:20 <mniip> but it does
12:29:22 <EvanR> @quote
12:29:22 <lambdabot> carpi says: all said ... the brain of someone of who writes compilers for haskell scares me nuts. I wouldn't want them concentrating on me, lest I catch fire.
12:29:50 <jophish__> I presume I can't quote that exchange now you've both said new things :/
12:30:30 <mniip> xplat, how co-me
12:30:38 <cocreature> jophish__: there is also a list of quotes at the end here http://haskellnews.org/grouped
12:30:51 <EvanR> dont hold on to past, move on to the future!
12:35:18 <breadmonster> @quote
12:35:18 <lambdabot> emacs says: [comment just above a bug in haskell-mode's elsip file] ;; Not sure if it's useful/needed and if it actually works"
12:35:42 <mniip> so how does one get immortalized in lambdabot's @quote :o
12:35:52 <EvanR> @quote mniip 
12:35:52 <lambdabot> < says: mniip> who hasn't implemented a haskell compiler in lisp, and a lisp compiler in haskell is not a real programmer
12:36:12 <EvanR> you tell me!
12:36:34 <xplat> @quote EvanR
12:36:34 <lambdabot> EvanR says: oop is never about what people say its about
12:36:35 <EvanR> why are all these quotes about compilers?!
12:36:58 <mniip> @quote mniip
12:36:58 <lambdabot> < says: mniip> who hasn't implemented a haskell compiler in lisp, and a lisp compiler in haskell is not a real programmer
12:37:05 <mniip> :( that's the only one it seems
12:37:36 <mniip> also that quote seems broken
12:37:47 <breadmonster> @quote breadmonster
12:37:47 <lambdabot> No quotes match. The more you drive -- the dumber you get.
12:38:07 <breadmonster> :(
12:38:21 <breadmonster> @quote edwardk
12:38:21 <lambdabot> edwardk says: i learned to program becaise i'd lied and told a kid that i'd written a disassembler, then had to make good on the claim.
12:38:34 <breadmonster> @quote EvanR 
12:38:34 <lambdabot> EvanR says: oop is never about what people say its about
12:38:46 <breadmonster> How do you add quotes to lambdabot?
12:38:49 <EvanR> oh the wisdom
12:39:21 <mniip> @quote
12:39:21 <lambdabot> Porges says: State is stored in spacesuits. [via: reddit]
12:39:33 <EvanR> @quote breadmonster How do you add quotes to lambdabot?
12:39:33 <lambdabot> No quotes for this person. That's something I cannot allow to happen.
12:40:47 <mniip> hahahahha
12:40:58 <mniip> @list quote
12:40:58 <lambdabot> quote provides: quote remember forget ghc fortune yow arr yarr keal b52s pinky brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo nixon farber
12:41:18 <mniip> @yhjulwwiefzojcbxybbruweejw probably this one
12:41:19 <lambdabot> Just 'J'
12:42:30 <t0by> arr
12:42:55 <t0by> @quote arr
12:42:55 <lambdabot> atp says: it's a marriage made in heaven | a haskell network server talking to an excel visual basic macro
12:43:05 <t0by> @quote arr
12:43:05 <lambdabot> xplat says: because, you know, you have to write a quicksort so differently in java than any other language. first you create an AbstractSequenceSubrangeFactory interface, and then you create the implementation for ArrayList ...
12:43:20 <t0by> this is gold
12:45:26 <Cale> @zippy
12:45:26 <lambdabot> Unknown command, try @list
12:45:32 <bollu> how do I "build a record" using lenses?
12:45:37 <Cale> NO ZIPPY!
12:46:17 <Cale> bollu: Generally you don't. However, if you have a bunch of lenses, and a default record to start with, you can just set the fields of the default record one by one
12:46:39 <bollu> Cale: for a type to have a "default record", what's the right typechass?
12:46:42 <bollu> typeclass*
12:47:00 <bollu> as in, is there a typeclass that abstracts the idea of having an identity?
12:47:12 <Cale> There's Data.Default you could use, but another option is just to... actually define a constant value of your record type.
12:47:12 <mniip> monoid?
12:47:32 <Cale> and yeah, if there's a Monoid instance, then maybe you could use mempty
12:48:05 <breadmonster> @quote Cale
12:48:05 <lambdabot> Cale says: I plan on forming a symbiotic relationship with sandtrout, which, as they merge with my body, will sustain me as I slowly turn into a sandworm, and make use of my billions of other memories and prescience to rule over everyone and everything for millenia.
12:48:22 <xplat> in a lot of cases where you have a record it's probably even best to use a default value and set only what you want to change.
12:48:30 <bollu> heh, that's neat
12:48:40 <breadmonster> @quote protontorpedo
12:48:40 <lambdabot> protontorpedo says: or is haskell doomed to be a mysql driver
12:48:52 <supki> > undefined & set _1 4 & set _2 7 :: (Int, Int)
12:48:54 <lambdabot>  (4,7)
12:49:04 <xplat> e.g. an 'options'/'settings' type, or an automaton-state type.  makes it more futureproof.
12:49:34 <lpaste> cmwilhelm pasted ‚ÄúProject Euler Problem #9‚Äù at http://lpaste.net/142779
12:50:08 <xplat> @yow
12:50:08 <lambdabot> I'm a nuclear submarine under the polar ice cap and I need a Kleenex!
12:50:15 <cmwilhelm> would anyone mind taking a look at my solution for project euler #9 and comment on haskell style?
12:50:29 <bollu> how does @quote work?
12:50:42 <mniip> @remember mniip I wonder what does this button do
12:50:42 <lambdabot> Good to know.
12:51:00 <Cale> cmwilhelm: Well, this isn't a Haskell style thing, but... you don't need to use Float for this problem.
12:51:11 <mietek> Does Haskell do something weird to rank-N universal quantification in type synonyms?
12:51:17 <Cale> cmwilhelm: Really all you want to check is that c^2 = a^2 + b^2
12:51:26 <Cale> cmwilhelm: That computation can be done exactly using Integer
12:51:41 <xplat> cmwilhelm: yeah, i think you have problems here that are kind of more basic than style
12:51:43 <Cale> Though this might work out up to 1000 in Float, I would never trust it.
12:52:16 <Cale> Any time you're testing equality of Float values, you're probably doing something a bit dangerously.
12:53:44 <tsahyt> @where ieee754
12:53:45 <lambdabot> I know nothing about ieee754.
12:53:47 <mietek> I‚Äôve found a mention of "hoisting" the forall in type synonyms in an old version of the GHC manual: https://downloads.haskell.org/~ghc/5.02/docs/set/universal-quantification.html
12:53:52 <cizra> Hello! Why is that when I "cabal install azurify", cabal-install finds all deps (although it then fails to build it). However, when I "cabal get azurify" and "runhaskell Setup.hs configure", it complains about missing deps, including at least one that's not available on Hackage?
12:53:52 <bollu> @quote mniip
12:53:52 <lambdabot> mniip says: I wonder what does this button do
12:54:07 <tsahyt> http://hackage.haskell.org/package/ieee754
12:54:12 <bollu> ah, that's how it works
12:54:15 <tsahyt> For your floating point equality needs
12:54:16 <bollu> @quote ekemmet
12:54:17 <lambdabot> No quotes match. You speak an infinite deal of nothing.
12:54:27 <mietek> It doesn‚Äôt seem to be mentioned in the latest version, though: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/other-type-extensions.html#explicit-foralls
12:57:08 <cmwilhelm> sure re: Floats; the nuance of the problem that i found hard to get around is figuring out whether c^2 is a perfect square without requiring floats
12:57:42 <bollu> is there a nice way to get the operator related to a lens function
12:57:42 <bollu> ?
12:57:51 <bollu> I want the operator for "view", but I can't remember it :(
12:59:03 <xplat> bollu: (^.)
12:59:16 <xplat> er
12:59:20 <xplat> (.^)
12:59:24 <bollu> thanks!
12:59:45 <xplat> :t (^.)
12:59:47 <lambdabot> s -> Getting a s a -> a
12:59:54 <xplat> oh, i was right the first time
13:00:16 <xplat> it always looks wrong because it only has one eye
13:01:12 <bollu> is there a "lensier" way to write this? source1 ^. val <> source2 ^. val
13:01:50 <Gurkenglas> bollu, here is an iirc outdated table: https://github.com/ekmett/lens/wiki/Operators
13:02:16 <bollu> Gurkenglas: thanks :)
13:03:49 <bollu> like, this is the line: Sourced { _val=source1 ^. val <> source2 ^. val, _region=source1 ^. region <> source2 ^. region}
13:03:59 <bollu> where "source1" and "source2" are of type Sourced
13:04:10 <bollu> I was hoping lens would make that nicer to write
13:04:29 <Gurkenglas> That looks like something that there should be deriving Monoid for
13:04:53 <bollu> I didn't know you could derive Monoid :O
13:05:17 <xplat> you can't!  but looking at that makes a person think you should be able to
13:05:28 <Gurkenglas> I meant it would be nice if you could <.<
13:05:53 <bollu> so, well, is there a nicer way to write that using "over" or something?
13:06:05 <Gurkenglas> "a -> b -> c -> Lens' d a -> Lens' d b -> Lens' d c", hmmm
13:06:34 <Gurkenglas> No wait that'd be a getter or fold or something wouldn't it
13:06:40 <Clechay> Hi, can someone tell me what exactly is Haskell? I didn't get description from haskell.org. Where can I use it and for what?
13:07:22 <Eduard_Munteanu> Clechay, it's a programming language. Are you familiar with programming in other contexts?
13:07:43 <Eduard_Munteanu> Also, hi.
13:08:02 <tommd> Clechay: Haskell is a general purpose programming langauge.  The typical way one uses a programming language is through a compiler or an interpreter.
13:08:35 <tommd> Clechay: In the Haskell community this usually means people download and run "GHC" or the "GHC Interpreter" known as ghci.
13:08:38 <bollu> can I improve line number 26? https://github.com/bollu/hask-lisp-interp/blob/master/src/Main.hs#L26
13:08:40 <Gurkenglas> bollu, if your container of Sourced values is indexed, you could do one container for val and one for region
13:08:42 <Clechay> Yes, I used to program in C++ and now I'm programming in JS
13:09:56 <bollu> Gurkenglas: what exactly do you mean by "indexed" ?
13:10:40 <Gurkenglas> uhh how about "something that can be zipped"
13:11:01 <jackhill> How do I get an account on the wiki.haskell.org?
13:11:13 <Clechay> tommd Is there something special about this language?
13:11:29 <bollu> Gurkenglas: nope, the container can't be indexed. The containers are Tokens and "Sourced" is the source file region they came from
13:11:36 <jackhill> oh, never mind, I see
13:11:38 <bollu> Clechay: the language is much "stricter" than most
13:11:47 <tsahyt> bollu: But it's lazy
13:11:49 <xplat> bollu: no, it's lazier than most
13:11:59 <bollu> xplat: but.. type system?
13:12:17 <xplat> stern, but not strict?  ;)
13:13:08 <hexagoxel> cizra: `cabal install` might choose a version of azurify that is not the latest. also, you still need to install dependencies after `cabal get`. why don't you use `cabal configure` instead of runhaskell.. ? also, all packages seem to be on hackage.
13:13:23 <bollu> Clechay: so that gives us a lot of guarentees eg: "if it compiles, it runs"
13:13:43 <xplat> bollu: pls don't exaggerate
13:14:13 <bollu> heh, I missed a "most of the time"
13:14:20 <bollu> but.. that is the essence / hope, right?
13:14:24 <Lokathor> I need a data structure that has ordering, indexing, variable length, and can be updated. Given that the number of elements will always remain small (less than 50 say) should I just bit emy teeth and use a normal List and not worry that updates are costing me silghtly more?
13:14:26 <awpr> I don't think that's an exaggeration, that's true of any language, if you consider "raise an exception" to be "running"
13:14:40 <jophish__> .exit
13:15:27 <xplat> haskell is safer than most languages that are fast and terse, faster than most languages that are safe and terse, and terser than most languages that are safe *or* fast.
13:15:41 <Gurkenglas> :t [?source1, ?source2] ^. each . ?val . folded -- Oh hey there we go
13:15:42 <lambdabot> (Foldable f, ?source1::t, ?source2::t, ?val::(f a -> Const a (f a)) -> t -> Const a t, Monoid a) => a
13:16:37 <Lokathor> bollu, you can always write "inc = id" and it'll type check but not do what you thought :P
13:16:48 <Gurkenglas> :t foldOf ?val [?source1, ?source2] -- bollu, ooh i can do one better
13:16:49 <lambdabot> (?source1::t, ?source2::t, ?val::Getting a [t] a) => a
13:17:18 <xplat> compared to many languages it's a little harder to get something from the point of zero to 'barely working' especially if you're inexperienced, but once you hit 'barely working' there's less debugging left to do and it's easier to refactor
13:18:57 <EvanR> bollu: re: strict language, i think people like to throw around "strong" to mean what you mean by strict
13:19:01 <EvanR> i.e. strongly typed
13:19:18 <Gurkenglas> ...of course, neither of those work now that i test them on tuples in query.
13:19:23 <aweinstock> Lokathor: going one further, it's valid to write (increment x = unsafePerformIO (modifyIORef someGlobalRef (+1) >> return (x+1)))
13:19:38 <bollu> Gurkenglas: what do the "?" do?
13:19:41 <aweinstock> (it's just not commonly done)
13:19:48 <EvanR> aweinstock: wth is that ;)
13:20:08 <aweinstock> bollu: ImplicitParams, he's using them to infer the types of "blank spots", basically
13:20:09 <EvanR> that wont even work!
13:20:20 <bollu> EvanR: ahh, TIL. Thanks for the terminology :)
13:20:33 <aweinstock> EvanR: why not?
13:20:35 <EvanR> bollu: of course strong and weak typing dont mean anything
13:21:25 <bollu> :t foldOf
13:21:26 <lambdabot> Getting a s a -> s -> a
13:21:27 <Lokathor> EvanR, usually by "strong" and "weak" typing people mean "will the language do automatic conversaions for you, and how much of them will it do?"
13:21:30 <EvanR> aweinstock: it seems like that wont cause the right number of side effects
13:21:47 <EvanR> because of the "semantics" of upio
13:21:50 <bollu> what's foldOf? :( I really need to understand lens types
13:22:01 <EvanR> Lokathor: usually, sometimes, maybe, sometimes not, who knows
13:22:04 <bollu> oh, given an s product an a?
13:22:16 <bollu> produce*
13:22:28 <Gurkenglas> bollu, they make Lambdabot do something similar to if I declared the identifier after the ? as a variable at the front of the line.
13:22:43 <Gurkenglas> > [(1, "a"), (2, "b")] ^. each . _2 -- bollu, this. dunno if theres something shorter.
13:22:43 <aweinstock> EvanR: that's part of why I gave it as an example of something bad
13:22:45 <lambdabot>  "ab"
13:22:55 <EvanR> aweinstock: something "valid" ? ;)
13:22:56 <bollu> huhh
13:23:18 <aweinstock> EvanR: it compiles, but it's (probably) not correct
13:23:55 <bollu> wait, but, how it did know how to combine them?
13:23:57 <bollu> Semigroup?
13:24:14 <bollu> to form "ab" 
13:24:35 <Gurkenglas> > "a" <> "b"
13:24:37 <lambdabot>  "ab"
13:24:52 <bollu> right, monoid them
13:24:54 <bollu> then*
13:24:59 <Gurkenglas> Lists are almost the free monoid
13:25:17 <xplat> there's always a catch
13:25:19 <bollu> oh, I know this one :) mempty = [], (<>) = (++)
13:25:51 <EvanR> in what was are lists not exactly the free monoid
13:26:09 <EvanR> way
13:26:15 <xplat> http://comonad.com/reader/2015/free-monoids-in-haskell/ -- the catch
13:26:35 <xplat> EvanR: ^
13:27:59 <bollu> xplat: ELI(know haskell, no category theory)?
13:28:28 <Gurkenglas> The lens docs should list, next to each name, what terms can be simplified using this one.
13:28:35 <cizra> hexagoxel: Indeed "cabal configure" works! I wonder where it takes its deps info then...
13:29:48 <lpaste> cmwilhelm annotated ‚ÄúProject Euler Problem #9‚Äù with ‚ÄúProject Euler Problem #9 (annotation)‚Äù at http://lpaste.net/142779#a142783
13:29:52 <xplat> bollu: a free monoid in haskell should be able to have both left-infinite and right-infinite lists, but [] only allows right-infinite
13:29:58 <cmwilhelm> another take; now 100% float-free
13:30:24 <bollu> xplat: ah, interesting.
13:30:28 <lupin> hi, any good libraries out there for using SOAP APIs?
13:30:50 <Clechay> Thanks guys, I think I understand. I will try this language :)
13:30:56 <hexagoxel> cizra: ah, you have a sandbox?
13:31:07 <bollu> xplat: aren't "left infinite" and "right infinite" isomorphic? (they are both countable infinite since you can "index" them with natural numbers, right?)
13:31:41 <jg_> hi all. I'm trying to find the error in my tree traversal function http://lpaste.net/142782 
13:31:42 <lpaste> cmwilhelm revised ‚ÄúProject Euler Problem #9 (annotation)‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/142783
13:32:13 * EvanR derives the punchline as "the free monoid is finite lists and haskell is infinite or worse bottom"
13:32:31 <xplat> bollu: they're isomorphic, but not equivalent.  if [] was free monoid, you would be able to have 'reverse' such that 'reverse . reverse = id', but for right-infinite lists 'l' you instead have 'reverse (reverse l) = _|_'
13:32:53 <bollu> bottom in the sense of non-termination?
13:33:23 <EvanR> you can never get the first element of reverse (reverse l)
13:33:35 <xplat> EvanR: nope, *in haskell* you should have all the infinite lists as part of the free monoid too
13:34:12 <bollu> EvanR: oh, right.
13:34:13 <cizra> hexagoxel: No clue, probably not. But as long as 'cabal configure' does the right thing, I'm semi-happy. Today, I want to get the code to work, can deal with packaging later. Thanks for the help.
13:34:14 <EvanR> you mean, we want to consider all the normal stuff differently in Hask?
13:34:57 <EvanR> i didnt know that free monoids made sense for infinite sequences
13:35:07 <monochrom> it should be interesting to work out whether Hask's free monoid is finite list only or includes infinite lists
13:35:12 <Hijiri> something something codata?
13:35:14 <xplat> EvanR: for some purposes, yes.  and sometimes this is one of them
13:35:24 <bollu> EvanR: some of the most common monoids in math are infinite, right?
13:35:49 <xplat> 'free monoid' is defined by a universal property
13:35:50 <Hijiri> I thought that just means the elements are infinite amount
13:35:52 <EvanR> bollu: infinite alphabet, were talking about an infinite expression
13:36:06 <monochrom> as in, work out how the "adjoint of the forgetful functor" comes out
13:36:17 <bollu> EvanR: ah, sorry
13:36:31 <EvanR> left infinite, right infninte, both infinite
13:36:36 <bollu> EvanR: I think it makes sense for any absorbing monoid
13:36:46 <bollu> eg: LT <> a <> b <> ‚Ä¶. == LT
13:36:54 <hexagoxel> cizra: ok. i would not have expected different behaviour of that type either then.. hum. well, if it works :)
13:36:56 <EvanR> bollu: well associativity doesnt necessarily make sense once the expression is infinite anymore
13:37:17 <EvanR> bollu: consider infinite series as a infinite list of terms concatteed by +
13:37:29 <EvanR> some series depend on which way you add up the terms
13:37:54 <xplat> you can't do some reassociations of an infinite expression using a finite number of finite reassociations
13:37:55 <bollu> EvanR: yes, agreed. (Also, I think any non absolutely convergent sequence cannot be rearranged IIRC?) that was why I gave a specific example where it works out
13:38:23 <EvanR> any absorbing monoid... 
13:38:54 <EvanR> wrong ;)
13:38:55 <xplat> so a monoid, which is defined with only a finite associative law, doesn't necessarily follow an 'infinite associative law' even if it allows infinite expressions
13:39:32 <EvanR> bollu: what if it was a doubly infinite expression, and you have a alternating absorbers going to the left
13:39:36 <monochrom> interesting
13:39:59 <EvanR> or both ways
13:40:04 <bollu> EvanR: ah, right. your sequence can grow in the "opposite side" of the absorption
13:40:19 <mniip> it's not an infinite associative law that is the problem
13:40:23 <EvanR> so this doesnt seem like a monoid at all
13:40:28 <mniip> it's the continuum induction
13:40:40 <mniip> because countable induction is fine
13:40:56 <EvanR> who let continuums in here o_O
13:41:13 <bollu> mniip: cotinuum induction?
13:41:16 <bollu> what's that about?
13:41:25 <mniip> well the set of combinations of elements of an infinite set
13:41:31 <mniip> is a continuum
13:41:54 <EvanR> ah, if you tried to list all the combinations
13:41:58 <bollu> huh, because n! > 2^n ?
13:42:06 <EvanR> or induct your way through them
13:42:07 <bollu> for n >= 4, ofc
13:42:32 <mniip> if you have a finite amount of addition signs
13:42:45 <mniip> you could prove a finite amount of associativity theorems
13:42:49 <xplat> actually you could see 'domain' types like haskell's as a topological completion of 'set-like' types in very much the way the continuum is a topological completion of rationals or of binary fractions
13:42:58 <mniip> if the amount of addition signs is infinite though
13:43:04 <mniip> you get a continuum of theorems
13:43:17 <mniip> some of which aren't actually true
13:43:52 <EvanR> well youre saying you cant prove them all that way
13:44:04 <xplat> well, in most formal mathematical proof systems we only allow any single proof to be finite anyway
13:44:14 <mniip> yeah, I'm saying that it's impossible to prove them
13:44:18 <xplat> because otherwise you have to worry about circular proofs
13:44:39 <EvanR> finitistic methods
13:44:43 <mniip> but it's no coincidence, you cannot prove them because they're false!
13:44:53 <bollu> xplat: what do you mean by "single proof to be finite" ?
13:44:56 <bollu> finite in what sense?
13:45:11 <mniip> hmm, analogy
13:45:45 <mniip> saying that commutativity applies to an infinite sum is like saying that there is an isomorphism between naturals and sets of naturals
13:45:53 <monochrom> actually I haven't seen any system allowing infinite-length proofs
13:45:58 <EvanR> sometimes theyre false, but i have no idea what an alternating true false infinite concatted with AND in both directions is
13:45:58 <xplat> bollu: a finite number of axioms/assumptions invoked, a finite number of inference steps
13:46:10 <mniip> if I ask you what natural corresponds to the set of even numbers, you're going to name an infinite number
13:46:19 <bollu> xplat: isn't induction against that?
13:46:21 <EvanR> i guess thats supposed to be false
13:46:22 <xplat> monochrom: me neither that i can recall.  infinite-*width* proofs, however ...
13:46:28 <monochrom> (how much time would I need to do homework in such a system? XD )
13:47:04 <bollu> mniip: I'm so confused right now. How does stuff like induction and diagonalization work?
13:47:16 <xplat> bollu: that's why you need induction.  to prove an infinite number of cases with a finite-length proof.
13:47:18 <mniip> how's diagonalization related
13:47:49 <bollu> mniip: you create an inifinite length list and then use it?
13:47:51 <bollu> xplat: ahh
13:47:52 <mniip> xplat, infinite countable number of casses
13:48:04 <xplat> bollu: otherwise you would have to prove each of the cases individually, and you couldn't prove a general theorem with forall
13:48:08 <EvanR> mniip: unless you use transfinite induction
13:48:20 <mniip> EvanR, is that logically consistent?
13:48:25 <seesaw8> I've a question the the example of tail recursion using an accumulation parameter here: https://wiki.haskell.org/Performance/Accumulating_parameter 
13:48:27 <monochrom> induction proofs are finite-length. even transfinite induction proofs.
13:48:31 <EvanR> you can have an ordinally indexed set of cases
13:48:39 <mniip> EvanR, is logical consistency of that even decidable?
13:48:41 <seesaw8> Here's an execution of both the non-tail and tail recursive examples: https://gist.github.com/anonymous/e1be82f5e29f304bf865
13:48:52 <EvanR> decidability of logical consistency? got me
13:49:12 <monochrom> you could unfold an induction proof to inflict upon yourself an infinite-length thing. but that's your choice.
13:49:16 <seesaw8> As far as I can see, we're still accumulating on the stack, though accumulating on the accumulator in the 2nd case.
13:49:36 <xplat> mniip: it's decidable in a sufficiently stronger system.  but then, how do you know *that* system is consistent?  etc.
13:49:39 <monochrom> me, last time I read an induction proof, it only took me 3 minutes. definitely finite-length.
13:49:45 <bollu> mniip: how does cantor diagonalization work? isn't constructing the new number using an "inifinite proof" ?
13:49:45 <seesaw8> I don't see how this would give any difference in space or time performance?
13:50:21 <EvanR> xplat: its sufficienctly strong systems all the way up
13:50:24 <EvanR> stronger
13:50:27 <monochrom> not to mention that even after you unfold induction proofs, you still haven't covered all possible infinite-length proofs
13:50:38 <xplat> EvanR: yep, all the way up to falso
13:50:51 <EvanR> huh
13:51:30 <EvanR> bollu: its a recipe for getting the next digit, you can go as far as you want
13:51:59 <monochrom> seesaw8: to avoid spending memory, you will have to combine both "use an accumulator" and "add strictness, so the accumulator is evaluated earlier". the former alone is not enough.
13:52:06 <mniip> bollu, we're talking about different kinds of infinities here
13:52:06 <bollu> EvanR: oh, slick
13:52:20 <bollu> mniip: which one are you talking about? and which one am I?
13:52:51 <mniip> induction lets you prove a countably infinite amount of theorems
13:53:10 <mniip> but there is a "bigger" infinity than a countable infinity - a continuum
13:53:16 <seesaw8> monochrom: the haskell wiki page suggests great performance benefits *before* applying the strictness on the accumulator.
13:53:17 <EvanR> or is there o_O
13:53:44 <xplat> actually induction lets you prove a single theorem, which has a countably infinite number of obvious corollaries ;)
13:53:44 <monochrom> ok, then I will have to read that page and see whether it's right or wrong
13:53:49 <mniip> EvanR, let's disregard edwardk's nonsense about hyperfunction machines for now :)
13:54:03 <bollu> mniip: |R| = c, right?
13:54:06 <seesaw8> monochrom: Towards the end: "We need to fix a small problem with regards to the stack overflow.".. which might be misleading me into thinking that even a lazy accumulator still gives benefits.
13:54:11 <mniip> yes that
13:54:13 <EvanR> once things get constructive it might not be so clear how continuumy continuums are
13:54:46 <monochrom> FWIW it's an open wiki of unknown contributor quality so nothing guarantees correctness or relevance
13:54:58 <seesaw8> ok.
13:55:00 <mniip> EvanR, but then you've got bottom sets
13:55:13 <EvanR> bah! sets!
13:55:36 * EvanR goes into a room and slams the door which says SEAR on it
13:55:38 <mniip> for example the set of all sets that don't contain themselves
13:55:47 <mniip> membership check for that set will sometimes diverge
13:55:53 <xplat> mniip: no sets contain themselves
13:56:08 <xplat> mniip: it's a consequence of the axiom of foundation
13:56:09 <mniip> xplat, we are talking about constructive predicative set theory
13:56:25 <EvanR> mniip is using anti-foundation
13:56:37 <bollu> xplat: isn't that done using type theory?
13:56:44 <mniip> cofoundation
13:56:50 <bollu> I have 0 knowledge of axiomatic set theory :/
13:57:05 <xplat> there are various approaches to constructive mathematics.  type theory is one of them.
13:57:14 <EvanR> bollu: check out SEAR on ncatlab
13:57:15 <xplat> or, it is a family of them
13:57:24 <xplat> but there are various other ones
13:57:34 <xplat> not familiar with one that allows 'bottom sets' though
13:57:48 <mniip> xplat, consider a Mu (Op Bool)
13:58:01 <mniip> which is a predicate over things like itself
13:58:11 <bollu> Thanks :)
13:58:22 <xplat> mniip: that's not an approach to constructive mathematics.  at least, not one that people use.
13:58:32 <mniip> oh I'm just haskelling
13:59:06 <EvanR> last [0..] -- don't mind me just haskelling
13:59:23 * hackagebot hoogle 4.2.42 - Haskell API Search  https://hackage.haskell.org/package/hoogle-4.2.42 (NeilMitchell)
13:59:26 <xplat> well, stop it!  this is #haskell, take your haskelling to #haskell-haskell
13:59:34 <bollu> SEAR has no set equality?
13:59:35 <bollu> why not?
13:59:43 <EvanR> two different sets are obviously different
13:59:49 <mniip> EvanR, 9223372036854775807
14:00:09 <bollu> EvanR: {} == {} ?
14:00:21 <EvanR> bollu: all the sets with no elements are isomorphic
14:00:22 <mniip> bollu, but how do you know if something is empty
14:00:31 <xplat> SEAR has no set equality because how do you compare two sets for equality if you can't compare their elements for equality?
14:00:32 <EvanR> mniip: through sear axioms
14:00:46 <mniip> well then that's just an equivalence class
14:01:08 <xplat> you can't compare elements of two sets for equality unless you already know they are the same set
14:01:15 <bollu> oh, right. Hm
14:01:15 <EvanR> you can choose to deal with isomorphism classes, but you dont have to
14:01:35 <mniip> > [9223372036854775805..] :: [Int]
14:01:37 <lambdabot>  [9223372036854775805,9223372036854775806,9223372036854775807]
14:02:06 <xplat> i always wondered how high you could count.  now i know.
14:02:54 <EvanR> infinite, infinite+1, ....
14:02:58 <mniip> well, integer-gmp on x86_64 goes up to 2^(2^70)
14:03:02 <EvanR> infinite^infinite
14:03:40 <EvanR> gpm natural has no upper limit, i thought
14:03:48 <EvanR> gmp
14:03:53 <mniip> the limb count is a word
14:04:13 <EvanR> unless its documented, better not rely on it ;)
14:04:28 <EvanR> "natural" implies infinite!
14:04:40 <monochrom> seesaw8: for the "len' (x:xs) acc = len' xs (1 + acc)" version, it happens that "ghc -O" is smart enough to increase strictness for you (I read the intermediate code to verify), so you don't have to do it yourself. but this is not guaranteed to happen to all other cases.
14:04:46 <mniip> EvanR, you're never going to fit that number in your RAM though
14:05:00 <EvanR> ok bill gates
14:05:04 <mniip> no
14:05:06 <EvanR> lol
14:05:13 <mniip> thing is, you need multi-word addresses
14:05:41 <EvanR> 2^(2^70) ram should be enough for anybody
14:05:50 * EvanR laugh track
14:06:46 <hpc> speaking of memory, could anyone suggest a memory-efficient way of parsing some json?
14:06:46 <mniip> if 1 address = 1 word, then you have 2^(2^n-n) addressable words
14:07:05 <seesaw8> monochrom: Wow thanks for checking that out!
14:07:07 <mniip> and then gmp would fit 2^(2^n) limbs
14:07:11 <hpc> it's 200M and has some nested structure to it
14:07:11 <EvanR> hpc: in terms of techniques, theres a c library i found that does this
14:07:31 <mniip> 2^(2^n) > 2^(2^n-n)
14:07:55 <EvanR> hpc: it keeps a pool of "tokens", and you walk through the json text and tokens are used to view the ... tokens of the json. if you need more tokens at some point for some reason (depth) you can create more
14:07:56 <mniip> unless n < 0, but then you have other problems
14:08:21 <hpc> EvanR: sounds like a streaming parser?
14:08:37 <EvanR> yes
14:08:45 <hpc> could work
14:08:51 <mniip> hmm
14:08:53 <EvanR> it doesnt use any memory except for whats in the tokens
14:09:10 <mniip> with 0-bit words and 1 word of memory you could actually store the number in your ram!
14:09:12 <hpc> my data is a list of dicts and each is pretty big but managable individually
14:09:38 <EvanR> so youd walk through using two tokens at a time for each dict entry
14:09:56 <EvanR> i mean if the value was a single token 
14:10:47 <mniip> if you have 2-word addresses however
14:11:01 <mniip> n needs to be > 0.3502
14:11:18 <mniip> so even half-bit words would suffice
14:12:07 <mniip> interestingly, 8086 can do it
14:12:24 <mniip> because addresses are 1.25 words
14:12:46 <EvanR> this sounds less like a chosen limit by gmp and more like they are required to use some real type to store a number (without using its own self to host)
14:12:58 <EvanR> and its wildly more than necessary so 
14:13:32 <mniip> in 8086 the largest number would be 2^(2^16), it would take 2^16 words, which is 2^17 bytes, which is well under 2^20
14:14:11 <EvanR> when talking about huge numbers 2^17 being "well under" 2^20 is laughable
14:14:47 <mniip> come on, 2^17 is not even close to 640KB
14:15:08 <EvanR> whats the significance of 2^20
14:15:34 <monochrom> 8086 and 8088 had 20 bits on the address bus
14:15:54 <EvanR> ah addresses
14:15:58 <mniip> 8086 could effectively address 2^20 bytes
14:16:28 <EvanR> where does 640K come from?
14:17:16 <BooneJS> Hey all, I'm working through the early release of haskellbook.com. Chapter 3, print5broken.hs has a function that looks like this, and my solution. Is my solution what the author intended? http://pastebin.com/Y6ePu4au
14:17:28 <monochrom> start with 1MB (20 bits), but give only 640KB for RAM, the other reserved space for various firmware (even though at the end not nearly half-used in practice)
14:17:48 <lispy> BooneJS: This page has been removed!
14:17:53 <EvanR> ok 640K was an arbitrary limitation
14:18:02 <BooneJS> argh. thanks lispy.
14:18:15 <lispy> BooneJS: maybe http://lpaste.net/ ?
14:18:16 <monochrom> yeah, it's specific to IBM PC
14:20:56 <lpaste> BooneJS pasted ‚ÄúChapter 3 of HaskellBook.com, print5broken.hs exercise‚Äù at http://lpaste.net/142789
14:22:39 <lispy> BooneJS: that seems pretty resonable, but I'm not sure what the author expected
14:22:59 <lispy> anohre thing you can do is to put the let inside the do-block
14:23:07 <lispy> if you do it that way, you don't need to use `in`
14:23:32 <BooneJS> Thanks. I mean, if the printSecond function isn't expecting an argument like 'greeting', then there's no way to inject it. Right?
14:23:33 <lispy> as an example all on one line, do { let greeting = "hello"; putStrLn greeting }
14:23:54 <lispy> You could define greeting at the toplevel, meaning outside of any function
14:25:52 <BooneJS> Thanks lispy. I wasn't sure if I was missing one character somewhere that would magically make it work, but printSecond can't use a variable that it isn't expecting.
14:26:23 <BooneJS> Back to the book, where I'm spending most of my time unrolling my imperative-first thinking. :)
14:26:38 <Gurkenglas> BooneJS, you also don't need the do in line 18 because it's only one line after that
14:26:57 <Gurkenglas> (Indeed, you can even say printSecond = putStrLn)
14:28:07 <lispy> BooneJS: Yeah, a lot of imperative and functional code is "inside out" relative to each other
14:29:24 * hackagebot http-api-data 0.2 - Converting to/from HTTP API data like URL pieces, headers and query parameters.  https://hackage.haskell.org/package/http-api-data-0.2 (NickolayKudasov)
14:31:21 <BooneJS> ty Gurkenglas
14:36:15 <orion> hmm... so I've written a test suite that invokes hlint. I print out the CWD, and it's the project root, as I expect. However, when I pass the "-h ./tests/.hlint" argument, I get an error: "hlint: Couldn't find file:  ./tests/.hlint"
14:36:24 <orion> Yet, I'm able to locate the file just fine.
14:36:40 <orion> Anyone know why hlint might be behaving like this?
14:39:18 <geekosaur> how are you passing that?
14:39:34 <geekosaur> because if you quoted the error exactly, it looks like it might have an extra space in it?
14:44:04 <orion> geekosaur: I actually just determined what happened. Apparently the [String] which holds the arguments is messed up by spaces. My solution is to use the alternative form of "-h", "--hint=": hints <- hlint $ [ "src", "benchmarks", "tests", "--hint=tests/.hlint", "--cpp-define=HLINT"] `mappend` args
14:44:42 <mauke> it's not "messed up", it just tries to load a file called " ./tests/.hlint"
14:45:03 <mauke> fix: either use "-htests/.hlint", or "-h", "tests/.hlint"
14:45:11 <geekosaur> it's using raw parameters. ["-h", "./tests/.hlint"] (possibly as part of a larger list), or ["-h./tests/.hlint"] (again possibly as part of a longer list)
14:45:40 * geekosaur slow
14:45:54 <orion> mauke: Yes, you are indeed right.
14:46:06 <mniip> [23:11:29] <monochrom> start with 1MB (20 bits), but give only 640KB for RAM, the other reserved space for various firmware (even though at the end not nearly half-used in practice)
14:46:12 <mniip> it was most definitely half-used
14:46:52 <mniip> you have the 0th page for the vector and a lot of other state, the Bth page for the video memory, and the Fth page for the firmware
14:47:38 <mniip> and that is before a command line interpreter loads
14:50:24 * geekosaur is reminded of programming old 6502s >.>
14:53:15 <f-a> is there a simple way to capture keyboard events in haskell? (keypress/release as an example)
14:53:31 <f-a> everything I see is SDL, but that's a tad big
14:54:24 <geekosaur> no simple one on unix. on windows, might be something in the win32 package
14:55:05 <f-a> geekosaur: I was gonna add "possibly cross-platform" :√æ. Thanks for the information
14:55:19 <geekosaur> cross-platform, you're looking at sdl or opengl.
15:19:54 <Lokathor> so i'm writing, remove :: (Integral a) => a -> [b] -> [b]
15:20:18 <Lokathor> if the index exceeds the length, it can't do it obviously
15:20:55 <Lokathor> would the "normal" style be to check the length first and error then, or to just lazily recurse and error when you can't recurse any more?
15:21:01 <mniip> you could return the original list and make a total function
15:21:23 <Lokathor> well
15:21:29 <ReinH> Lokathor: checking the length first couldn't possibly be better.
15:21:48 <ReinH> Since you're just doing the work twice.
15:21:51 <mniip> ReinH, remove 1 [x] = x:bottom
15:21:54 <mniip> versus bottom
15:21:58 <ReinH> And, in fact, doing more work that is strictly necessary.
15:22:02 <ReinH> mniip: ?
15:22:13 <mniip> he's asking what kind of bottom to return
15:22:21 <Lokathor> if you check the length first, you'll get the error right away, otherwise you'll get a partial list back before the error
15:22:23 <ReinH> I thought he's asking what he asked.
15:22:51 <ReinH> Lokathor: what exactly does remove do?
15:22:53 <Lokathor> [0,1,2,3*** Exception: Index requested exceeds list length.    vs   *** Exception: Index requested exceeds list length.
15:23:07 <Lokathor> it remove the element at the index given from the list
15:23:53 <ReinH> Checking the length evaluates the entire spine of the list even though it isn't necessary.
15:24:22 <Lokathor> right
15:24:31 <ReinH> And removing a non-existent element seems like it should just be a noop, as mentioned
15:24:44 <Lokathor> alright, i'll go with that
15:26:01 <Lokathor> java has it as an ArrayIndexOutOfBounds, so I started off thinking in those terms
15:26:52 <ReinH> I would expect remove n to xs be denotationally equivalent to take n xs ++ drop (n + 1) xs
15:26:57 <ReinH> *remove n xs to be
15:27:31 <geekosaur> lists aren't arrays
15:27:35 <ReinH> Lokathor: it's generally a bad idea to... yes.
15:27:40 <ReinH> don't think of lists as arrays.
15:28:05 <geekosaur> this isn't just terminology; it's a linked list
15:28:10 <ReinH> (Or whichever version using take and drop isn't an off-by-one error)
15:28:25 <Lokathor> This I fully understand, however for the particular case here, my first pass at translating a Java program to a Haskell program involves using a haskell list similar to a java list
15:28:26 <geekosaur> removing an element is expensive. *traversal* is expensive, compared to Array or Vector
15:28:29 <Lokathor> just for a bit
15:29:05 <Lokathor> and the length of the list in question will generally be less than 10-20 anyway, so it's safe enough
15:29:36 <ReinH> Lokathor: what algorithm are you implementing?
15:29:47 <ReinH> Direct transliterations from Java to Haskell usually don't fare well.
15:29:56 <Lokathor> Precise Permissive Field of View, https://github.com/Lokathor/JRoguelikeToolkit/blob/master/src/main/java/rl/toolkit/fov/PPFOV.java
15:30:08 <ReinH> Lokathor: writing a roguelike?
15:30:22 <Lokathor> Intending that it be possible some day
15:30:58 <Lokathor> this is step 1
15:32:28 <papap2> I'd like to get GHC to print out what rewrite rules fire, using `stack install --ghc-options="-fglasgow-exts -ddump-simpl-iterations -fforce-recomp"`. I don't get any rule reports from GHC, but I'm certain they're being fired.
15:33:06 <papap2> I've also tried -ddump-simpl-stats , still no luck. What am I doing wrong?
15:34:27 * hackagebot mezzolens 0.0.0 - Pure Profunctor Functional Lenses  https://hackage.haskell.org/package/mezzolens-0.0.0 (RussellOConnor)
15:37:31 <ReinH> Lokathor: Are you aware of LambdaHack?
15:37:40 <ReinH> It has a PFOV implementation.
15:37:50 <Lokathor> It has a shadowcasting based one, as I understand it
15:38:08 <ReinH> PPFOV is based on shadowcasting.
15:38:33 <ReinH> walls cast shadows whose extremities are represented by views
15:38:36 <Lokathor> huh. Well either way I understand about 0% of LambdaHack's FOV code when I looked at the git
15:39:02 <ReinH> that's what the bumps do: they adjust the views to account for a new shadow
15:39:15 <Lokathor> yes I know :3
15:39:22 <Lokathor> I've used the java and python versions for a while now
15:39:51 <ReinH> https://github.com/AllureOfTheStars/Allure/blob/last_standalone/src/FOV/Permissive.hs is a PPOV implementation
15:40:05 <ReinH> *PPFOV
15:40:56 <Lokathor> it's a little excessively terse for my brain
15:45:19 <joneshf-laptop> is there a library somewhere that has `(:+:)` and `(:*:)` implemented in the data types ala carte sense?
15:45:31 <joneshf-laptop> functor instances and injection and all that good stuff?
15:46:43 <Gurkenglas> Is there something that speaks against the proposal to swap all the pairs in Control.Concurrent.MVar and make the MVars the last argument in two-argument functions, not the first one? It would make wiring StateT into it simpler
15:47:28 <Gurkenglas> ("\var -> modifyMVar var . fmap fmap fmap swap . runStateT . modify . (+)" becomes "modifyMVar . runStateT . modify . (+)")
15:47:48 <ReinH> joneshf-laptop: apparently https://hackage.haskell.org/package/compdata does
15:49:12 <ReinH> joneshf-laptop: transformers also has Compose and Product
15:49:28 * hackagebot yesod-auth-ldap-native 0.1.0.0 - Yesod LDAP authentication plugin  https://hackage.haskell.org/package/yesod-auth-ldap-native-0.1.0.0 (mkazulak)
15:53:05 <ReinH> Gurkenglas: fmap fmap fmap swap?
15:53:22 <joneshf-laptop> ReinH, I see the sum, but not the product in compdata.
15:53:35 <ReinH> joneshf-laptop: check the index, it's there
15:53:44 <Zemyla> Can a pattern synonym be a symbol instead of a name?
15:53:47 <BalinKingOfMoria> https://ghc.haskell.org/trac/ghc/ticket/10956
15:53:48 <Gurkenglas> ((.) . liftM) swap. I've once seen (fmap . fmap) substituted with fmap fmap fmap, and thought it funny.
15:53:57 <BalinKingOfMoria> Would anyone have any idea what to do with that?
15:54:55 <Gurkenglas> :t fmap fmap fmap swap :: (a -> IO (b, a)) -> (a -> IO (a, b))
15:54:55 <ReinH> Gurkenglas: use flip?
15:54:56 <lambdabot> (a -> IO (b, a)) -> a -> IO (a, b)
15:55:27 <Gurkenglas> ReinH, where? 
15:55:34 <joneshf-laptop> ReinH, holy! there's an index!
15:55:35 <ReinH> Gurkenglas: where you want it to be flipped?
15:55:37 <joneshf-laptop> ReinH, thanks.
15:55:40 <ReinH> joneshf-laptop: np
15:55:57 <mgsloan> papap2: Maybe the output is going to the log file?  Take a look at .stack-work/logs/your-package.log
15:56:25 <Gurkenglas> ReinH, I'm saying that the version in base is the flipped one. Or asking for a situation where you'd want the argument order that way.
15:56:41 <asdf_> Hi! This may be a simple question, but are there any workarounds for https://ghc.haskell.org/trac/ghc/ticket/10956?
15:57:23 <ReinH> Gurkenglas: ok, but until that happens, why not use flip?
15:57:34 <mgsloan> papap2: You might also like "-ddump-to-file", which will dump to a file
15:59:42 <asdf_> > "Testing out lambdabot"
15:59:43 <lambdabot>  "Testing out lambdabot"
15:59:51 <asdf_> Whoa.
16:00:14 <asdf_> :pl foo x y = length x ++ length (show y)
16:00:25 <asdf_> @pl foo x y = length x ++ length (show y)
16:00:25 <lambdabot> foo = (. (length . show)) . (++) . length
16:00:31 <ReinH> asdf_: I can't reproduce that behavior with the testcase. Up key works for me as expected.
16:00:45 <ReinH> I guess it's a windows issue?
16:00:45 <asdf_> Windows is working fine?
16:00:47 <asdf_> Weird....
16:00:54 <ReinH> No, not windows.
16:01:04 <ReinH> I don't understand how this could even be a GHC issue.
16:01:13 <ReinH> GHC doesn't bake readline into your programs for you.
16:01:19 <ReinH> I suspect it's a windows console issue.
16:01:19 <asdf_> If I recall, the bug was a Windows bug due to GHC's backend being written for POSIX compatibility instead of the WinAPI
16:01:27 <asdf_> Which causes issues where you can't use raw input
16:01:35 <asdf_> And they pushed it back to 8.0.1 or something like that to fix it
16:01:58 <ReinH> This ticket is 29 hours old.
16:02:27 <asdf_> There's a long discussion here: https://ghc.haskell.org/trac/ghc/ticket/2189
16:02:50 <ReinH> That's a different issue.
16:03:37 <ReinH> It's not obvious that the two are related.
16:03:42 <asdf_> Someone suggested putting the terminal in raw mode, but the bug prevents that
16:03:48 <asdf_> So that workaround doesn't work, unfortunately
16:03:55 <asdf_> (well, it's not a bug, but whatever)
16:04:37 <Gurkenglas> ReinH, because using flip only gets it to "flip modifyMVar . fmap fmap fmap swap . runStateT . modify . (+)", and then my function is inconsistent with the order in MVar.
16:05:12 <Gurkenglas> (Except if we wrap the whole composition in flip again)
16:07:23 <ReinH> is that just lift swap?
16:08:09 <Gurkenglas> :t [fmap fmap fmap swap, ((.) . liftM) swap] :: [(a -> IO (b, a)) -> (a -> IO (a, b))]
16:08:10 <lambdabot> [(a -> IO (b, a)) -> a -> IO (a, b)]
16:08:29 <cammv222> Hello. Do you know what could be an example of Redundant Clauses in pattern matching?
16:09:10 <Gurkenglas> Damn university courses inventing their own terminology and making students memorize it
16:09:44 <Cale> cammv222: consider something like:
16:09:53 <kadoban> Gurkenglas: ? what's that in reference to?
16:09:54 <Cale> f x = length x
16:09:59 <Cale> f [] = 0
16:10:28 <Cale> cammv222: Since the first pattern matches absolutely anything, the second will never have an opportunity to match
16:10:29 <Gurkenglas> kadoban, "Redundant Clauses" sounded capitalized enough to be an Invented Term, and his question sounded like homework, so i doubled 2
16:11:01 <kadoban> Gurkenglas: Ah. I just assumed it was some error/warning message with which I wasn't familiar.
16:12:42 <Cale> A less trivial example would be something like:
16:12:46 <Cale> f [] = 0
16:12:51 <Cale> f (x:xs) = 1
16:12:55 <Cale> f (x:y:xs) = 2
16:13:09 <cammv222> And why is redundant? 
16:13:27 <Cale> Here, the third pattern will never have an opportunity to match, because anything which matches (x:y:xs) would already have matched the (x:xs) on the previous line.
16:15:04 <Lokathor> cammv222, it's like in other languages when the compiler warns that you can never reach a particular line of code, for example, if(false){ System.out.println("will never happen"); }
16:15:58 <Cale> I suppose it's important to understand here that the patterns are tried in the order in which they're listed
16:16:09 <Cale> and the first one which succeeds in matching "wins"
16:16:23 <Cale> So, if a more specific pattern occurs later, it is redundant.
16:17:09 <Lokathor> they are also tried with the individual matches going left to right, if it ever matters
16:17:20 <cammv222> Ok, thank you. You're great.
16:19:31 <Lokathor> ReinH, I've managed to turn a complex double for loop into a nice and clean List monad function that spits out a list of Locations
16:19:33 <Lokathor> it's pretty cool
16:20:05 <elliptic00> I'm new to Haskell, anyone know how to pass arguments to Haskell program?   e.g myhaskell_script file1 file2
16:20:36 <Lokathor> elliptic00, that's how you do it, if you want to not compile it first try "runhaskell myscript arg1 arg2"
16:20:48 <Lokathor> otherwise you'll need to use ghc to compile the program
16:21:14 <Lokathor> either way you need to have a main action defined
16:21:28 <elliptic00> I mean how to capture the arguments: file1 and file2 in my Haskell code?
16:21:37 <Lokathor> oh, you use getArgs
16:21:44 <Cale> getArgs :: IO [String]
16:21:50 <Lokathor> https://hackage.haskell.org/package/base-4.8.1.0/docs/System-Environment.html
16:22:11 <Cale> So you write something like  main = do args <- getArgs; ...
16:22:19 <Cale> and then use args :: [String] in what follows
16:23:36 <Cale> If you don't care about handling errors very nicely, you might also just write  [arg1, arg2] <- getArgs
16:23:53 <Cale> (supposing that you always want to pass two commandline arguments)
16:24:38 <Lokathor> or use something like, args <- getArgs; case args of [argA, argB] -> ... ; _ -> printUsageAndExit
16:31:04 <elliptic00> main = do
16:31:04 <elliptic00>     [arg1, arg2] <- getArgs
16:31:05 <elliptic00>     print "dog"
16:31:36 <elliptic00> get error: Not in scope: 'getArgs'
16:31:51 <elliptic00> any idea?
16:31:56 <Lokathor> you have to import it
16:32:02 <Lokathor> import System.Environment
16:32:19 <Lokathor> put that at the top right after the "module Main where" line
16:33:02 <Lokathor> unlike much of haskell, which lets you put definitions in any order, your imports have to go at the top
16:34:02 <elliptic00> thx, it works :)
16:34:29 * hackagebot ed25519 0.0.5.0 - Ed25519 cryptographic signatures  https://hackage.haskell.org/package/ed25519-0.0.5.0 (AustinSeipp)
16:44:49 <Lokathor> concatMapForSets :: (a -> Set b) -> [a] -> Set b
16:45:21 <Lokathor> I'm not quite seeing such a thing on hoogle
16:46:41 <mjhoy> are there any papers i should consider reading before diving into pipes or conduit?
16:52:26 <lynnard> I'm looking at this statement: let (c, d) = f (b, d) where d is NOT defined in the previous scope...
16:52:58 <lynnard> why does ghc let this compile? the only possible explanation I can think of is that f (b, d) is referencing that d from (c, d)
16:53:11 <lynnard> which just doesn't make sense to me
16:53:14 <Hijiri> it is
16:53:17 <Hijiri> have you seen fix?
16:53:29 <lynnard> what do you mean by 'fix'
16:53:32 <Hijiri> :t fix
16:53:33 <lambdabot> (a -> a) -> a
16:53:39 <Hijiri> > fix (1:)
16:53:41 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
16:53:47 <Hijiri> @src fix
16:53:48 <lambdabot> fix f = let x = f x in x
16:54:15 <Hijiri> you are allowed to refer to something recursively
16:54:22 <Hijiri> just as you're allowed to with a function
16:54:25 <lynnard> err...
16:54:42 <lynnard> then where is the starting point..?
16:55:07 <Hijiri> starting part of which thing
16:55:16 <lynnard> would expect an empty list in that definition
16:55:34 <lynnard> where the recursive definition then builds upon
16:55:53 <Hijiri> if you unpack fix (1:)
16:56:06 <Hijiri> you get let x = 1 : x in x
16:56:24 <lynnard> ah, okay I see
16:56:34 <Hijiri> so then when you evaluate x one element, you get 1:x
16:56:45 <Hijiri> and x becomes 1:x again, so you have 1:1:x, and so on
16:57:02 <lynnard> I should get in the habit of thinking 'lazily' :)
16:57:20 <Hijiri> In "let (c, d) = f (b, d)", basically the "d" is the thing that's getting looped around
16:57:57 <Hijiri> you might want to take a look at https://wiki.haskell.org/Tying_the_Knot
16:58:12 <lynnard> cool thanks
17:06:24 <Hijiri> lynnard: this one might have been more related: https://wiki.haskell.org/Circular_programming
17:07:14 <Hijiri> actually I don't know, this one covers arrows
17:07:28 <Hijiri> including function
17:07:57 <lynnard> hmm, okay; actually I saw that definition from an ArrayLoop
17:08:23 <sm> I think I have a space leak of some kind here, can you tell ? http://lpaste.net/142800
17:08:45 <lynnard> /ArrayLoost/ArrowLoop
17:08:51 <sm> heap profile at https://github.com/simonmichael/hledger/issues/275#issuecomment-147257314
17:12:07 <Gurkenglas> sm, would you try "ala Endo foldMap" instead of "foldl' (\acc new x -> new (acc x)) id" and see if that's better?
17:13:20 <sm> Gurkenglas: how's that ?
17:14:11 <Gurkenglas> "ala Endo foldMap" means "runEndo . foldMap Endo"
17:14:19 <sm> hmm I'll look at that, thanks
17:14:31 * hackagebot dbus 0.10.11 - A client library for the D-Bus IPC system.  https://hackage.haskell.org/package/dbus-0.10.11 (JohnMillikin)
17:14:35 <lispy> sm: foldl' can only be strict if the function you give it is strict
17:14:53 <lispy> sm: And I suspect that's not the case here
17:16:14 <sm> lispy: probably not
17:16:31 <lispy> looking at the github issue now
17:16:41 <Gurkenglas> (What I want to say is 'also consider "combineJournalUpdates = execStateT . traverse modifyT" with strict StateT', but modifyT isn't in the libraries.)
17:19:45 <Gurkenglas> I hereby submit a pull request request to get modifyT and getsT added to them, which I haven't done myself yet because there are two libraries that we might want to add it to in some order and I'm not sure about the procedure.
17:21:41 <Gurkenglas> (Afterwards, isos for modifyT and getsT and modify and gets so we can have "combineJournalUpdates = au _ModifiedT traverse")
17:23:56 <Gurkenglas> Although I guess the one for modify is already provided by Endo
17:24:54 <NeverDie> Would anyone be interested in being my Haskell mentor?
17:25:14 <lispy> sm: have you tried making combineJournalUpdates lazier?
17:26:54 <mjhoy> is there a way to have ghc(i) load a module before eval'ing? I want to get the output of a command like `ghc -m Foo -e ":t foo"`
17:27:08 <mjhoy> (i.e. run "import Foo" before evaling)
17:27:42 <ttt_fff_> is there an efficient (Map k v) -> k1 -> k2 -> [(k, v)] where it returns all items in between k1 & l2 ?
17:27:46 <ttt_fff_> between k1 and k2
17:27:55 <ttt_fff_> it should take log (n) + number of items time
17:28:24 <Cale> http://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Map-Lazy.html#v:split
17:28:55 <Cale> If you only wanted a Map result, then it would only take O(log n) time
17:28:57 <Gurkenglas> You can't possibly have less than 2 * number of items time because that's how many nodes are between root and the leaves you want
17:29:04 <hardmath123> Is there a way to make a .prof file tell you line numbers of where the functions were called from?
17:29:40 <hardmath123> My .prof file shows that "==" is using up 80% of the time or something... but I don't know which usage of == is the culprit.
17:29:56 <Cale> hardmath123: That's not even necessarily well-defined, since the inliner does lots of stuff
17:30:01 <Cale> hmm
17:30:05 <ttt_fff_> Gurkenglas: sure, I meant: O(log n + number of items) time
17:30:10 <Cale> That's pretty unusual
17:30:20 <ttt_fff_> Cale: this is cute, so two splits and I get a map back, and I read out the entire map
17:30:26 <Cale> ttt_fff_: yes
17:30:51 <Cale> ttt_fff_: See also splitLookup if you want to keep the items at the endpoints of your interval
17:31:03 <Gurkenglas> Would be nice to be able to run the inliner in isomorphic mode, where you get annotations that say the original line.
17:31:18 <lispy> sm: I don't know if sequence returns results lazily or not in this case, but it might be building the whole list ( [Journal -> Journal] ) and feeding that to foldl' at once.
17:31:28 <Cale> hardmath123: can we look at the code?
17:34:17 <lpaste> hardmath123 pasted ‚Äúeddie.prof (@ Cale)‚Äù at http://lpaste.net/7861767082176675840
17:34:34 <hardmath123> Cale: ^^
17:35:04 <Cale> okay, so what does the code for prove' look like?
17:35:45 <Cale> It's an (==) in the definition of prove' which is costing all the time
17:35:56 <lpaste> hardmath123 pasted ‚Äúprove' @ Cale‚Äù at http://lpaste.net/5697514657787412480
17:36:26 <Cale> hmm, weird
17:36:33 <hardmath123> That's the thing, there aren't any (==)'s in prove'.
17:36:47 <Cale> Well, okay, there are some obvious things we can do to improve this
17:36:53 <hardmath123> I tried removing the `nub` and `sort` calls, but that didn't change much.
17:37:01 <Cale> oh really?
17:37:05 <Cale> nub is O(n^2)
17:37:10 <Cale> if you evaluate the whole list
17:37:13 <lispy> sm: also, can you upload your profiling data here: http://heap.ezyang.com/
17:37:31 <felixn> evalState (Control.Data.List.runListT (do { x <- get; ListT $ return x })) [[1,2,3],[4,5]] <-- hey, how come it doesn't matter if I lift `get` here?
17:37:32 <Cale> are the lists resulting from resolve and paramodulate supposed to be long?
17:37:48 <sm> lispy: I haven't, yet. All of these comments will be quite helpful when I next work on it. I'll do that and report back
17:37:48 <ttt_fff_> does anyone in vim has a nice module
17:37:57 <ttt_fff_> where you type in "a :: b" and it fills in "a = undefined" for you
17:38:03 <sm> lispy, Gurkenglas: thanks!
17:40:29 <hardmath123> Cale: No, not long at all. Maybe 2 or 3 at most.
17:40:48 <hardmath123> Cale: but I would expect cmp and cls to grow to pretty big over time?
17:42:08 <echo-area> What is the bot behind @pl?
17:42:12 <echo-area> djinn?
17:42:29 <lispy> No, it's just mechanical refactoring
17:43:01 <echo-area> Is it available in ghci?
17:43:03 <lispy> https://github.com/lambdabot/lambdabot/blob/master/lambdabot-haskell-plugins/src/Lambdabot/Plugin/Haskell/Pl.hs
17:43:21 <echo-area> Oh, thanks
17:44:08 <lispy> That module doesn't have much of the smarts though
17:44:17 <lispy> I'm not actually sure which module does, but poke around
17:44:34 * hackagebot cpython 3.3.1 - Bindings for libpython  https://hackage.haskell.org/package/cpython-3.3.1 (JohnMillikin)
17:44:36 * hackagebot cpython 3.4.0 - Bindings for libpython  https://hackage.haskell.org/package/cpython-3.4.0 (JohnMillikin)
17:44:40 <echo-area> Okay, I'm cloning the repo to learn :)
17:45:06 <lispy> echo-area: There used to be a way to run lambdabot inside ghci, called 'ghci-on-acid'. Dunno if it still works: https://github.com/chrisdone/goa
17:45:23 <lispy> echo-area: other options include a local lambdabot and sending a private message to lambdabot
17:46:42 <hardmath123> Cale: okay, so it was the (\\) that was breaking things. Not sure why that call didn't get traced by the profiler...
17:47:33 <lispy> hardmath123: figuring out where to attribute cost in the profile is hard. If that function was inlined then it would disappear but the cost would still be there
17:48:08 <ttt_fff_> what I want is NOT groupWith. I want a :: (a -> Bool) -> [a] -> [[a]]; where "elements that are true serve as separators for the other elements"
17:48:11 <echo-area> lispy: Cool, thanks
17:54:36 * hackagebot quiver 1.1.2 - Quiver finite stream processing library  https://hackage.haskell.org/package/quiver-1.1.2 (patrykz)
18:09:38 * hackagebot hashabler 1.1 - Principled, portable & extensible hashing of data and types, including an implementation of the FNV-1a and SipHash algorithms.  https://hackage.haskell.org/package/hashabler-1.1 (BrandonSimmons)
18:18:13 <ttt_fff_> http://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Exts.html#groupWith
18:18:17 <ttt_fff_> why is this not part of base ?
18:19:17 <exio4> well, it is part of base
18:19:45 <ttt_fff_> but not part of prelude
18:19:49 <ttt_fff_> how I have to import GHC.EXTS ?
18:35:54 <ttt_fff_> is there a nicer way to write f $ g $ h $ j value ; where f, g, h j are all expressions that are long
18:36:04 <ttt_fff_> something like a multine notation, similar to monads, to not a monad
18:37:01 <bitemyapp> f .\n g .\n h .\n j $ value
18:44:43 * hackagebot zim-parser 0.1.0.0 - Read and parse ZIM files  https://hackage.haskell.org/package/zim-parser-0.1.0.0 (robbinch)
19:49:11 <profsimm> Folks I'm not a Haskell users, but I need a piece of mind on types only a Haskeller can understand... When I read input over the network, say an HTTP form with fields, and I'm reading a record with fields "a", "b", "c", if the input contains also field "d" I can react in two ways: ignore "d" and consider the input valid, or error out and say "d" is unexpected field. Which approach is more "correct"?
19:51:14 <Ralith> profsimm: be liberal in what you accept, be strict in what you produce
19:51:29 <dmj`> profsimm: it depends on your application, do you absolutely *need* 'd' ? You can do both w/ types, purely return Left, or just ignore it
19:52:01 <profsimm> Ralith: I'm glad to hear this one, because that's what I do. But it also means when I have optional field "d" and sometimes typoes it as "dd" I'll just silently ignore it
19:52:42 <profsimm> dmj`: I currently ignore it, but can you please check the scenario in the previous line, thoughts?
19:54:40 <dmj`> profsimm: under what circumstances would "dd" be received? Are you generating these forms ?
19:54:49 * hackagebot cabal-graphdeps 0.1.3 - Generate graphs of install-time Cabal dependencies  https://hackage.haskell.org/package/cabal-graphdeps-0.1.3 (JohnMillikin)
19:55:42 <profsimm> dmj`: API input, I don't control the sending party
19:57:19 <dmj`> profsimm: I don't know enough about the third party sending the form to make an intelligent comment
19:57:50 <profsimm> dmj`: I'm writing a general purpose validation library. Which one would you have as a default: extra fields are ignored, or cause an error?
20:00:06 <MarcelineVQ> I'd error as default in a general purpose library, if the person needs to exchange safety for flexiblibily they should make that choice conciously
20:00:53 <MarcelineVQ> That's a really generla statement though so only apply it if it makes sense for you
20:02:21 <dmj`> profsimm: it's still not enough information for me, how does "dd" get produced ?
20:02:31 <profsimm> MarcelineVQ: it's hard. I see arguments both ways.
20:02:40 <dmj`> is that a part of your general purpose library?
20:02:51 <profsimm> dmj`: the library only reads input, it doesn't produce it
20:03:20 <profsimm> dmj`: errors would come down to human errors, someone reading specs and seeing the name wrong
20:03:25 <profsimm> dmj`: or spelling it wrong
20:04:38 <dmj`> profsimm: in aeson for example, in a FromJSON instance, you can select only the fields you want to parse, it ignores others if they're present
20:04:54 <dmj`> but not specified
20:05:28 <Ralith> profsimm: if it says 'validation' on it, it should be as strict as possible
20:05:45 <dmj`> profsimm: if someone says that it should be present, and it's not, that's an error, if it exists, but the user doesn't specify it should, maybe not
20:11:31 <profsimm> Ralith: well it says "filtering and validation" so again both ways :)
20:12:06 <profsimm> dmj`: yup.
20:12:27 <profsimm> dmj`: the problem is essentially typoing an *optional* field. If one prefers required fields, the problem doesn't exist.
20:13:06 <profsimm> dmj`: I suppose I may make erroring on extra fields opt-in and people can select it when they have many optional fields, or whatever
20:20:38 <dmj`> profsimm: programming the end user to not make mistakes would be nice yes, keeping a user from typos is probably impossible. It it's optional, and they typo, i'd return Nothing
20:22:10 <lpaste> echo-area pasted ‚ÄúSolving fmap (fmap fmap) fmap‚Äù at http://lpaste.net/142810
20:22:17 <echo-area> Is this correct?
20:22:53 <profsimm> dmj`: yup. Thanks for your feedback :)
20:22:59 <profsimm> Ralith: thanks :)
20:25:52 <athan> What would be a good way to make a newtype for QuickCheck-generating `[(k,a)]` list pairs, where you can /exclude/ some `Set.Set k` from being generated?
20:26:49 <athan> I was thinking something like `WithoutKeys k a = WithoutKeys {getWithoutKeys :: Set.Set k -> [(k,a)]}`, but that doesn't really make sense for automatically knowing that the function will /exclude/ that list from being generated
21:01:11 <nshepperd> athan: you want that set to be user-configurable?
21:02:47 <nshepperd> athan: would it work to just generate an arbitrary [(k,a)] and then filter out the keys you don't want?
21:03:52 <nshepperd> you could write a custom Arbitrary instance for your WithoutKeys newtype that would do that
21:19:24 <athan> nshepperd: derp, you're right, sorry
21:27:33 <ttt_fff_> is there a way to combine 'parsec' and auto completion?
21:27:39 <ttt_fff_> I feel that auto completion and parsec are very related
21:27:44 <ttt_fff_> parsec describes valid parse strings
21:27:59 <ttt_fff_> auto completion is about finding potrential completions (into valid parse strings) from current string
21:29:07 <kadoban> ttt_fff_: It'd have to be based on different principles. Parsec is too general; you can encode it to accept things that would be impossible to autocomplete.
21:29:19 <ttt_fff_> yeah
21:29:46 <ttt_fff_> any idea how to 'limit' arbitrary gramms to make them 'easy to auto complete' ?
21:30:09 <lpaste> nshepperd pasted ‚ÄúSuper Silly Reflection Stuff‚Äù at http://lpaste.net/142812
21:30:43 <kadoban> ttt_fff_: Look at what optparse-applicative does, maybe.
21:31:04 <ttt_fff_> if I evaluate that maybe to I get a Nothing or Just answer ?
21:31:20 <nshepperd> athan: I went way overboard and made a type-level version of a similar idea
21:31:35 <nshepperd> it's probably not a good idea :q
21:32:38 <codebje> a parser usually describes inifinitely many possible input sequences, it probably wouldn't be ideal to autocomplete based on possible input sequences starting with a fixed sequence
21:32:54 <ttt_fff_> well, I just want completion of "the next token"
21:32:59 <ttt_fff_> not "the entire stream"
21:33:05 <ttt_fff_> (my fault for failing to clarify that)
21:33:33 <codebje> if "the next token"  might be "a string", there's still infinitely many possibilities
21:34:05 <codebje> (iow, you really would need something much more constrained than a general purpose parser)
21:39:40 <ReinH> ttt_fff_: parsing is about consuming, auto-completion is about generating
21:41:55 <lpaste> nshepperd revised ‚ÄúSuper Silly Reflection Stuff‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/142812
21:44:14 <shourya> Hello
21:44:42 <nshepperd> this is probably still silly, but it surprises me how possible it is to use runtime data in a Arbitrary instance like that
21:45:03 <shourya> XD true that
21:52:13 <athan> nshepperd: Ah wow that is crazy :|
21:52:22 <nitrix> ttt_fff_: Sort of like type holes but parser holes?
21:52:39 <ttt_fff_> nitrix: I think we can be less vague
21:52:53 <ttt_fff_> we need a way to express grammas in the form [Token] -> [Token]
21:53:03 <ttt_fff_> nextPossibleToken :: [Token] -> [Token]
21:53:10 <ttt_fff_> it takes a list (current tokens parsed so far)
21:53:16 <ttt_fff_> and outputs another list, possible values ofr Next token
21:53:22 <nitrix> Aren't token determined by a Parser?
21:53:22 <ttt_fff_> with such a function, we can do both parsing and completion
21:53:47 <ttt_fff_> we can consider the special case [Char] -> [Char]
21:53:55 <ttt_fff_> or [Char] -> [String]
21:54:03 <ttt_fff_> actually, we want String -> [String]
21:54:15 <ttt_fff_> after seeing current possible input string; what is the list of all possible strings that can compelte the current keyword/varname/funcname/...
21:54:32 <ttt_fff_> we just need a function that looks at "so far" and says "here's everything that can possibly work next"
21:54:54 <nitrix> Fine, ignore me. I'm going back to my code.
21:58:17 <ttt_fff_> nitrix: what code are you writing?
21:59:31 <nitrix> A distributed file system.
22:44:11 <ttt_fff_> is there a way to run my own 'private hackage' ?
22:44:24 <ttt_fff_> i.e. I want to be able to specify dependencies, but I want these libraries ot be readable by me only, and not shared on ahckage
22:44:58 <liste> ttt_fff_ simplest way would be add-source
22:45:55 <liste> but you can also host your own hackage if you want to
22:46:00 <liste> that's what stackage does
22:47:25 <liste> https://www.haskell.org/cabal/users-guide/installing-packages.html#sandboxes-basic-usage <-- example of add-source
22:59:47 <ReinH> ttt_fff_: yes, https://github.com/haskell/hackage-server
23:00:05 <ReinH> ttt_fff_: btw I was talkng to someone about setting up a hackage-as-a-service but I'm not convinced the market is big enough to support it
23:00:34 <ttt_fff_> ReinH: if you could get each haskell dev to pony up $0.99 / year, you'd be able to make .. tens of thousands / year
23:00:40 <ReinH> but if say 1000 people wanted to pay $10/mo I might consider it
23:01:06 <ReinH> usually the big money is in large enterprise clients though
23:01:16 <ReinH> (saying this as someone who build a PaaS company before)
23:01:26 <ttt_fff_> I dunno; I thought github was retarded, and github is worth billions, so I'm the idiot
23:01:31 <ReinH> yep
23:02:00 <ttt_fff_> but I think many of the 'hackage on their own' are more clueful than the heroku/github crowd, and probably also have spare digital ocean machines lying around
23:02:00 <ReinH> *built
23:02:31 <ReinH> well, it's easy enough to start a hackage server. There's a docker image even. The annoying thing is maintaining it.
23:02:41 <ttt_fff_> ReinH: can I PM you about your experience with PAAS? I have questions, but it's probably -blah material
23:02:46 <ReinH> sure
23:07:57 <nurupo> i have a hex number in string, e.g. "0bcbca21", and i want to add to it a number (the representation doesn't matter, i.e. a regular Integer or hex string) and get a hex string of the result
23:08:33 <nurupo> so, something like "0bcbca21" + "c" = "0bcbca2d", or "0bcbca21" + 12 = "0bcbca2d"
23:08:47 <kadoban> nurupo: The easiest way is just going to be to convert the hexidecimal string to an integer and then convert the result back
23:10:37 <EvanR> do arithmetic on numbers no strings
23:11:13 <jle`> nurupo: there's a lens that does this if you're willing to get a lens dependency
23:11:48 <jle`> > over hex (+2) "bcbca21"
23:11:50 <lambdabot>  "bcbca23"
23:12:12 <shachaf> But watch for the leading 0.
23:12:57 <shachaf> Fixed-size integers are different from arbitrary-size integers.
23:13:21 <ReinH> 0b is also the prefix for a binary number in some places, so
23:15:13 <ReinH> jle`: btw that's a nice example of a lens that isn't just a fancy record accessor
23:16:18 <shachaf> Except it's a prism.
23:19:25 <nurupo> jle`: are "over" and "hex" in "lense" package?
23:19:30 <nurupo> *lens
23:20:19 * hackagebot sbv 5.2 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  https://hackage.haskell.org/package/sbv-5.2 (LeventErkok)
23:20:23 <nurupo> oh, hex is a separate package
23:20:25 <jle`> shachaf: thanks, missed that
23:20:43 <jle`> nurupo: it's hex from the lens package, yes, and over too
23:20:51 <EvanR> whats a prism
23:20:55 <nurupo> hm
23:20:57 <jle`> you can think of (over hex) as an "fmap" for hex strings
23:21:14 <jle`> like how you can fmap (+2) (Just 10), you can (over hex) (+2) "deadbeef"
23:21:19 <EvanR> i mean, is `over' a prism
23:21:27 <EvanR> or over hex
23:21:28 <EvanR> or
23:21:31 <jle`> over isn't a prism, hex is the prism
23:21:52 <jle`> (over hex) gives you like an "fmap" over the underlying integral that the hex string represents
23:22:42 <EvanR> is that the case for over x for any prism x
23:23:26 <jle`> yes; more generally, for any Setter, so it works for lenses, traversals, iso's, etc.
23:24:04 <jle`> > over _1 (+2) (1,2)    -- _1 is the lens here
23:24:04 <EvanR> whats over?
23:24:05 <lambdabot>  (3,2)
23:24:38 <EvanR> :t over
23:24:40 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
23:24:47 <EvanR> i see
23:25:08 <jle`> i think of it like taking a setter/lens/prism/iso etc. and giving you an fmap-like thing/mapper using it
23:25:33 <EvanR> it does look like that, but the profunctor
23:25:37 <EvanR> can you get a contramap?
23:25:54 <EvanR> i mean rmap
23:26:04 <EvanR> yeah contramap
23:26:05 <nurupo> wow, lens pulls in a lot of things as dependencies, so it seems
23:26:24 <jle`> yes that's a, uh, common sentiment
23:26:34 <EvanR> yes welcome to kmett-skell
23:26:48 <EvanR> jle`: is there like an under which produces the opposite of an fmap ;)
23:27:20 <EvanR> :t under
23:27:21 <lambdabot> AnIso s t a b -> (t -> s) -> b -> a
23:28:02 <EvanR> it... consumes the opposite of an fmap
23:28:28 <EvanR> this is awfully asymmetric
23:28:31 <jle`> i'm not totally sure what something you're thinking of would look like
23:29:24 <EvanR> i should learn what s t a b is
23:29:29 <jle`> i can be a bit more specific with my vocabulary.  For a Lens s t a b, it lets you turn an (a -> b) into an (s -> t), like how map lets you turn a (a -> b) into an ([a] -> [b])
23:29:52 <nurupo> :t over
23:29:53 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
23:30:18 <jle`> for a Prism s t a b, it lets you turn an (a -> b) into an (s -> t), too; so hex is (specializing, here) a Prism String String Int Int.  Use an (Int -> Int) as a String -> String
23:30:29 <nurupo> how do i ask the interpretor to print out scope?
23:30:52 <nurupo> not sure what should i import for "over" and "hex" to work
23:31:05 <liste> import Control.Lens should be enough
23:31:28 <EvanR> @where over
23:31:28 <lambdabot> I know nothing about over.
23:31:35 <EvanR> @hoogle over
23:31:38 <lambdabot> Graphics.UI.GLUT.Callbacks.Window overlayDisplayCallback :: SettableStateVar (Maybe DisplayCallback)
23:31:38 <lambdabot> Graphics.UI.GLUT.Overlay overlayPossible :: GettableStateVar Bool
23:31:38 <lambdabot> Graphics.UI.GLUT.Overlay overlayVisible :: SettableStateVar Bool
23:31:40 <nurupo> ok, found "hex" in Numeric.Lens
23:32:36 <EvanR> jle`: right ok, over does that for anything parameterized by s t a b
23:32:52 <jle`> not *anything*
23:33:00 <jle`> there's a little table here http://hackage.haskell.org/package/lens
23:33:05 <jle`> s/table/diagram
23:33:13 <nurupo> there is
23:33:22 <nurupo> now try finding it in there, lol
23:33:27 <jle`> it works for anything that is usable as a Setter; the arrows pointing upwards means "is usable as a"
23:33:43 <jle`> so you can use Equality's Iso's, Prism's, Lens's, Traversal's, Setter's.
23:33:51 <jle`> i'm not sure why i put apostrophes there
23:35:51 <bitemyapp> jle`: apostrophe's
23:36:02 <jle`> thank's
23:37:27 <bitemyapp> jle`: the welcome is your's
23:37:39 <bitemyapp> jle`: I really liked the 'over hex' example btw
23:38:50 <ReinH> bitemyapp: o/
23:39:07 <liste> > over hex (+1) "nothex"
23:39:09 <lambdabot>  "nothex"
23:39:29 <jle`> it is one of the cuter examples i know.  shame it's not a proper/lawful prism, though
23:41:28 <Hafydd> Stop right there, criminal scum!
23:42:41 <ggole> > fmap (+1)
23:42:42 <lambdabot>      No instance for (Typeable f0)
23:42:43 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
23:42:43 <lambdabot>        arising from a use of ‚Äòshow_M673510553033652709119297‚Äô
23:42:47 <ggole> :t fmap (+1)
23:42:48 <lambdabot> (Functor f, Num b) => f b -> f b
23:42:53 <ggole> Why does that happen?
23:43:03 <jle`> what part surprises you?
23:43:19 <ggole> That :t doesn't report the type error (if that's what it is)
23:43:28 <liste> no it isn't a type error
23:43:35 <liste> why would it be?
23:43:51 <liste> it's a functiohn
23:43:55 <jle`> ggole: oh, for the attempt at evaluation, lambdabot tries to *show* the things that it's given to evaluate
23:43:58 <liste> and functions can't be `show'n
23:44:04 <jle`> so it's trying to Show a (Fcuntor f, Num b) => f b -> f b
23:44:08 <liste> yep
23:44:12 <ggole> Wait, I think I see the problem: my (old) ghci is reporting a different error
23:44:29 <ggole> That does appear to be a type error "Ambiguous type variable `f0' in the constraint: ..."
23:44:31 <jle`> it does have a Show instance on functions I believe, but it's constrained to only Typeable's inputs and outputs
23:44:53 <ggole> So presumably there was a change at some point
23:45:21 <jle`> the error here is for a different reason than that, heh
23:45:38 <jle`> on old-ghc, that error comes because old ghci wants every binding to have a monomorphic type unless you explicitly tell it otherwise
23:46:19 <ggole> Erm
23:46:53 <jle`> in this case it doesn't know what to pick for f, even though it is happy enough to pick Integer for b
23:47:37 <jle`> on lambdabot's environment, there *is* a Show instance for functions
23:47:39 <ggole> Hmm, that's a bit confusing
23:47:41 <jle`> > not
23:47:42 <lambdabot>  <Bool -> Bool>
23:48:04 <jle`> but it only works on a -> b where a and b are instances of Typeable, so that's why it was freaking out about Typeable
23:48:50 <ggole> Why the restriction? Does it cause a problem for inference?
23:49:34 <jle`> the restriction is because it wants to print out something like Bool -> Int, but remember that you can't get the name of a type in general for an (a -> b)
23:49:51 <jle`> because everything you do with an (a -> b) has to be polymorphic over all a's and b's...you can't inspect their types in haskell
23:49:55 <ggole> Sorry, I'm asking about the polymorphism thing, not Show
23:50:03 <jle`> oh
23:50:23 <jle`> the restriction is known as the MonomorphismRestriction, and it's a practical restriction for performance reasons
23:50:38 <ggole> Ah, so I eta expand?
23:50:58 <jle`> well, in new ghci, it's turned off, because it's not very useful and causes a lot of trouble anyways
23:51:13 <akegalj> does anyone have problems (like me) playing videos from skillsmatter in firefox ?
23:51:16 <ggole> I see
23:51:23 <jle`> you can store polymorphic values by giving explicit polymorphic type signatures
23:51:40 <jle`> let mySum :: Num a => [a] -> a; mySum = sum
23:51:49 <ggole> Right
23:51:55 <ggole> Thanks, that clears it up nicely.
23:52:05 <jle`> with MonomorphismRestriction on, it'd normally store mySum :: [Integer] -> Integer
23:52:42 <ggole> Because Integer is the default
23:52:43 <jle`> well, in normal haskell code, it can usually *infer* what type you're using it because you eventually use it later in the source.   but in GHCI, it can't see into the future, so it defaults to Integer
23:53:24 <jle`> seeing into the future has been pushed back to ghc 8.0
23:53:25 <ggole> I see: this happens where you would get a weak type variable in ocaml
23:53:42 <ggole> (Very) roughly speaking
23:54:40 <EvanR> Integer is the default Num
23:54:50 <EvanR> Double is the default Fractional
23:55:02 <EvanR> > read "()"
23:55:03 <lambdabot>  ()
23:55:10 <EvanR> ... () is the default Read ?
23:55:31 <EvanR> handy ?
23:55:35 <jle`> mhm.  usually in normal haskell code you don't have problems because inference will fix most problem cases (the only issue is when you want to use mySum on [Int] and also on [Integer] in the same program).  so the decision was that it would be *on* for normal source code and *off* for ghci
23:56:11 <jle`> the only annoying thing is that it's rarely taught properly so the first time people see it there are always lots of questions
23:56:19 <jle`> i think every other haskell question on stack overflow involves this
23:56:37 <EvanR> i distinctly remember the defaulting-to-Integer being explained very early in a tutorial i was using
23:56:44 <EvanR> i was like "Okay."
23:56:57 <EvanR> its never really mattered
23:57:02 <echo-area> jle`: Excuse me, do you have time to take a look at http://lpaste.net/142810 to see if it's correct?
23:58:03 <jle`> it doesn't look like a very fun thing to verify :P  doesn't ghci/ghc do it for you?
23:59:02 <EvanR> the reactive-banana space invariant blog post here is very good http://apfelmus.nfshost.com/blog/2013/08/21-space-invariants.html
23:59:52 <EvanR> even if it doesnt directly help too much, it does give a lot of negative advice for things that WONT work when trying to figure out space usage
