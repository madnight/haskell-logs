00:07:38 * hackagebot aeson-yak 0.1.0.1 - Handle JSON that may or may not be a list, or exist  https://hackage.haskell.org/package/aeson-yak-0.1.0.1 (tejon)
00:07:38 * hackagebot aeson-yak 0.1.0.2 - Handle JSON that may or may not be a list, or exist  https://hackage.haskell.org/package/aeson-yak-0.1.0.2 (tejon)
00:08:37 <tejon_> hackagebot repeating itself? Or was that for the haddocks?
00:08:56 <quicksilver> cwl: GHC's IO manager uses epoll to implement thread
00:14:56 <lf94_> What's a good name for '->' in Haskell?
00:15:08 <lf94_> Where you'd normally find it in type definitions.
00:15:17 <lf94_> type/function
00:15:31 <tejon_> I usually say "to"
00:15:31 <lf94_> type declarations
00:15:49 <lf94_> What is the proper name for f :: a -> a ? :(
00:15:56 <lf94_> It is type declaration rigth
00:16:43 <tejon_> Type signature.
00:16:50 <tejon_> Though I don't think "declaration" will confuse anyone.
00:17:27 <lf94_> Gah type signature. Right.
00:17:51 <lf94_> Isn't data myType = Int|Int a type declaration?
00:18:51 <MarcelineVQ> Almost, those Ints need constructors since it's a data type
00:19:04 <MarcelineVQ> data MyType = A Int | B Int
00:19:14 <tejon_> I think he meant that yes, calling a signature a declaration may cause confusion. :)
00:20:04 <joehillen> type declaration would be: newtype Foo = ...
00:20:17 <joehillen> data declaration is: data Foo =
00:20:43 <joehillen> a type synonym is: type Foo = Bool
00:32:41 * hackagebot generics-sop 0.2.0.0 - Generic Programming using True Sums of Products  https://hackage.haskell.org/package/generics-sop-0.2.0.0 (AndresLoeh)
00:38:36 <frerich> True Sums sounds like a designer fragrance.
00:42:07 <quicksilver> or a great chinese restaurant.
00:42:24 <frerich> :-)
00:43:17 <quicksilver> suprisingly hard to find documentation on the status of GHC's IO manager
00:43:27 <quicksilver> based on personal memory plus a little googling
00:43:43 <quicksilver> I think the "new IO manager" went live in 7.0, that is the one which switched to epoll/kqueue
00:43:50 <quicksilver> and then "Mio" went live in 7.8
00:43:56 <quicksilver> which massively improves multicore IO
00:47:42 * hackagebot basic-sop 0.2.0.0 - Basic examples and functions for generics-sop  https://hackage.haskell.org/package/basic-sop-0.2.0.0 (AndresLoeh)
01:09:26 <jacereda> hi... how can I specify a run-dependency in a .cabal file? That is, some tests rely on a program and I want that installed when "cabal test" is run.
01:14:55 <phadej> jacereda: there are build-tools:
01:15:13 <phadej> field, you can specify per buildable component
01:18:07 <jacereda> phadej: great, thanks
01:44:30 <sbrg> Anyone here using ghc-mod with stack? 
01:44:44 <muhuk> Hi! Can you help me resolve this dependency conflict? https://groups.google.com/forum/#!topic/light-table-discussion/zMMm_5srE2o
01:45:22 <muhuk> I tried adding light-haskell to my cabal deps, but it can't find the package. I can't find it either in hackage etc.
01:47:05 <spill> I'm also interested in getting ghc-mod to find stuff installed by stack
01:48:37 <muhuk> sbrg: spill: I made ghc-mod work with stack, to use atom editor from within.
01:49:01 <sbrg> spill: https://github.com/kazu-yamamoto/ghc-mod/issues/498 this issue suggests stack support is already landed in master
01:49:30 <sbrg> which should be in the newest release, 5.4.0.0, which I am running
01:50:31 <spill> hmm, that makes three of you telling me this. tried to get it to work last week with a friend who simply said ghc-mod 5.4.0.0 ought to be enough
01:50:54 <sbrg> yeah, but it doesn't work for me either, heh.
01:51:01 <spill> but half way through that I managed to mangle my ubuntu update (after missing my release went EOL)
01:51:26 <spill> so I'm postponing getting all the libraries up to date till after exams, but I\ll make sure to follow that issue, thanks
01:51:41 <sbrg> I also did some silly update/reinstall stuff wrt cabal/ghc.. I nuked my package manager's ghc, but cabal-install is still installed and I think it might be broken. 
01:52:35 <spill> yeah I have cabal lying around still from before I learnt of stack
01:55:24 <sbrg> yeah. I'm not sure what to do in this case. My emacs' haskell-mode doesn't work either. 
01:57:46 <spill> update: with stack-exec ghc-mod check <file> I get a lot of shadowing errors, but seeminlgy no complaint of 'quickcheck not found'
01:57:54 <spill> is there a flag to ignore shadowing errors?
01:58:02 <spill> warnings"
02:01:22 <Ongy> davean: the package manager i mentioned yesterday told me he doesn't remember his hackage logins and that the package should just be transfered (I got a mail, it's unsigned so I could be making this up)
02:06:27 <Unhammer> http://sprunge.us/bHXA so this change made my code about 25x faster, but I stumbled on it completely by chance; readData creates a trie and "run" just looks up a bunch of bytestrings in that. Is this because the trie is created lazily if I don't close the handle before running?
02:07:17 <Unhammer> (bytestring-trie, that is)
02:12:41 <quicksilver> you mean basically moving the 'run d' outside the withFile bracket, Unhammer ?
02:13:36 <quicksilver> if I had to guess, it's 25x faster because it's only working on the first 1/25th of the file
02:13:46 <quicksilver> because you closed it before it finished readin.
02:13:50 <quicksilver> I can't think of another explanation
02:15:09 <Unhammer> hm, was getting the same output though
02:16:57 <Unhammer> yeah, running all keys of the trie through I get the same output
02:20:33 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
02:20:33 --- topic: set by quicksilver!~jules@roobarb.crazydogs.org on [Wed Oct 07 07:39:49 2015]
02:26:02 <Unhammer> bangpatterns on run seems to help as well. hm. But is it generally considered "unsafe" to do the withfile in a separate function like I did?
02:26:13 <Unhammer> (unsafe as in the file might be closed before reading is done)
02:35:27 <quicksilver> no
02:35:32 <quicksilver> changing function makes no difference
02:35:42 <quicksilver> what changed is that you moeved 'run d' out of the withFile
02:38:02 <quicksilver> and all that does is change which happens first, 'run d' or the handle close
02:38:19 <quicksilver> that shuoldn't make any different at all, unless readHandle uses the so-called 'lazy IO'
02:38:32 <quicksilver> but, if it did, then it would only make a difference because you weren't getting all the content
03:11:33 <Jinxit> a question about laziness: if I use parsec to build for example a list, and then map a function over that list, am I right in thinking that it will execute the function -while- parsing?
03:11:59 <Jinxit> as I then print out the list or whatever
03:13:12 * hackagebot pretty-sop 0.2.0.0 - A generic pretty-printer using generics-sop  https://hackage.haskell.org/package/pretty-sop-0.2.0.0 (AndresLoeh)
03:15:22 <quicksilver> Jinxit: yes
03:15:23 <obadz> Jinxit: I think so
03:15:38 <quicksilver> I mean, it does depend how you parser is built
03:15:41 <obadz> Jinxit: you can test by running your program and typing in the list by hand, you should start seeing output...
03:15:55 <obadz> before you're done typing the list
03:16:14 <quicksilver> for most formats it wouldn't be productive until it sees the closing delimeter
03:16:34 <quicksilver> in fact, now I think about it, you have to be pretty careful in your parser design if you want to design a lazily productive one
03:16:39 <obadz> Aeson uses vectors for Json arrays so that's settled..
03:17:13 <quicksilver> I retract my original answer.
03:17:24 <quicksilver> parsec can't produce any information until it knows the file contains no errors.
03:17:34 <quicksilver> in practice, for many files and many formats that means it is essentially 'done' parsing
03:17:51 <obadz> if quicksilver retracts, I retract too ;-)
03:17:54 <quicksilver> although if your parse had some particularly expensive post-processing that part might be deferred until demanded.
03:18:24 <quicksilver> the compromise with a streaming parser is always the possibility that you might discover an error after you've already done some processing
03:22:12 <quicksilver> polyparse has a lazy parser in it
03:23:13 * hackagebot lens-sop 0.2.0.0 - Computing lenses generically using generics-sop  https://hackage.haskell.org/package/lens-sop-0.2.0.0 (AndresLoeh)
03:23:15 <xnil> With Test.QuickCheck.Gen, I would like to do something along the lines of `frequency [(1, choose (Nothing, Nothing)), (9, choose (Just 1, Just 9))]` with the type :: Gen (Maybe Int). Is there any way I can do this?
03:24:28 <shlomo> Is there a built in function for finding all possibilities to choose N elements from a list?
03:27:54 <Jinxit> quicksilver: I'm mostly thinking whether I should carry some replacement information (think #define in C) while parsing or if I should just map after parsing
03:28:09 <Jinxit> it's not really performance critical in my case but I'm looking for best practices
03:28:10 <quicksilver> well the map will be applied lazily :)
03:28:15 <quicksilver> even if the parse wasn't
03:28:19 <Jinxit> ah true
03:28:26 <quicksilver> so it probably doesn't matter much
03:28:37 <quicksilver> but there is a semantic difference of course
03:29:04 <quicksilver> if you apply them in place then "FOO ; #define FOO 3 ; FOO" parses as "FOO; 3"
03:29:11 <quicksilver> if you do the map afterwards, you get "3 ; 3"
03:29:27 <Jinxit> ah yes
03:29:36 <Jinxit> but I'm only allowing defines at the start anyways to keep it simple
03:29:47 <quicksilver> (or you do if you don't go to some effort to record, along with each macro, "This macro only applies from line M"
03:30:41 <xnil> Does anyone here have any experience with Test.QuickCheck at all?
03:33:13 * hackagebot language-c-inline 0.7.9.2 - Inline C & Objective-C code in Haskell for language interoperability  https://hackage.haskell.org/package/language-c-inline-0.7.9.2 (ManuelChakravarty)
03:38:27 * hackagebot json-sop 0.2.0.0 - Generics JSON (de)serialization using generics-sop  https://hackage.haskell.org/package/json-sop-0.2.0.0 (AndresLoeh)
03:46:38 <fractalsea> Hi, does anyone know how I can get profiling (+RTS -p) to work when I background the haskell process with & ?
03:46:53 <fractalsea> At the moment it writes a myprog.prof file, but it’s 0 bytes
03:47:33 <quicksilver> I doubt backgrounding has anythng to do with it
03:47:47 <quicksilver> output is only flushed to that file occasionally, or when the process finishes cleanly
03:47:53 <quicksilver> are you killing the processs perhaps?
03:48:04 <fractalsea> If I run it without & and kill it with Ctrl-C it writes the .prof file
03:48:20 <fractalsea> Ah well I’m using the kill command on it
03:48:29 <fractalsea> which I thought was the same as Ctrl-C
03:48:36 <quicksilver> it is
03:48:39 <quicksilver> hmm
03:48:43 <dutchie> "kill" sends SIGTERM, ctrl-c sends SIGINT
03:48:50 <fractalsea> hmm
03:48:50 <quicksilver> is your program blocked on input?
03:48:58 <quicksilver> that's the only difference I can think of about &
03:49:07 <quicksilver> if you run in the background you will get suspended if you try to read from the terminal
03:49:34 <fractalsea> It’s reading from a socket
03:49:38 <fractalsea> or waiting to
03:49:41 <quicksilver> that shouldn't matter
03:49:52 <quicksilver> maybe you're accidentally reading from stdin as well?
03:49:59 <quicksilver> otherwise I can't see how & would affect it.
03:51:16 <fractalsea> I think dutchie is right. I will try sending a SIGINT with kill
03:51:43 <dutchie> i would be slightly surprised if they are handled differently, but it's worth a try
03:51:57 <quicksilver> oh I didn't understand you as saying that you were doing Ctrl-C in one case and kill -TERM in the other
03:52:04 <quicksilver> if that's a difference then, sure, check it :)
03:52:10 <quicksilver> kill -INT is easy enough to try
03:52:52 <fractalsea> Yes that’s it!
03:53:06 <fractalsea> So it writes on INT, not TERM
03:53:15 <quicksilver> it's an improvement that Ctrl-C works. In my day we had to install our own signal handler for INT to exit cleanly
03:53:18 <quicksilver> if we wanted a profile :)
03:53:27 <fractalsea> ouch
03:53:40 <fractalsea> Thanks for the help
03:57:38 <SrPx> Is there any alternative to gloss that allows me to merely render a REPA array to screen and get keyboard inputs? I'm having problems related to GHCI with gloss.
03:59:34 <quicksilver> in my experience, GUI librarys are not reliable with GHCi, SrPx 
03:59:38 <lf94_> One moment I'm loving Haskell, doing everything in Haskell for 2 weeks. Then it's back to the bullshit with PHP and friends for a month. Ugh.
04:00:01 <quicksilver> maybe other people have specific recommendations but I've always reconciled myself to compileing when I wanted to run the GUI parts.
04:02:35 <SrPx> quicksilver: no, I don't want to use the lib on ghci... the problem is that the mere existence of the lib on the project makes ghci stop working
04:02:42 <SrPx> even if I only to use ghci for other purposes
04:06:25 <quicksilver> oh
04:06:33 <quicksilver> well that's odd.
04:06:36 <quicksilver> what happens?
04:07:16 <quicksilver> as for other libraries, glfw, glut, sdl, wxwidgets
04:15:51 <mreh> > let x = x in x
04:15:55 <lambdabot>  mueval-core: Time limit exceeded
04:16:18 <mreh> :t \_ -> let x = x in x
04:16:19 <lambdabot> r -> t
04:16:25 <mreh> um
04:17:42 <mauke> mu?
04:18:28 * hackagebot chalmers-lava2000 1.5.1 - Hardware description EDSL  https://hackage.haskell.org/package/chalmers-lava2000-1.5.1 (EmilAxelsson)
04:18:57 <quicksilver> :t \_ -> fix id
04:18:58 <lambdabot> r -> a
04:19:12 <quicksilver> that implementation is faster because a < t
04:20:42 <mauke> :t fmap pure fix ask
04:20:43 <lambdabot> Applicative f => f r
04:21:28 <mauke> that implementation is more readable because it contains no symbols
04:23:09 <aweinstock> :t fix ask
04:23:11 <lambdabot> a
04:23:18 <aweinstock> :t ask
04:23:20 <lambdabot> MonadReader r m => m r
04:23:35 <aweinstock> :t ask :: a -> a
04:23:36 <lambdabot> a -> a
04:24:10 <mauke> :t [id, ask, ($), asks]
04:24:12 <lambdabot> [(a -> a1) -> a -> a1]
04:26:16 <quicksilver> > fix (error "out of cheese")
04:26:17 <lambdabot>  *Exception: out of cheese
04:26:27 <quicksilver> fix doesn't work :( it didn't fix the error.
04:26:40 <mauke> > fix fail
04:26:42 <lambdabot>  ""
04:35:33 <Ongy> :t fix
04:35:35 <lambdabot> (a -> a) -> a
05:40:05 <Myrl> @pl (\x -> f x . g)
05:40:05 <lambdabot> (. g) . f
05:40:12 <Myrl> Welp.
05:42:08 <Gurkenglas> It takes your x, sends it through f, and then sends the resulting (f x) through the process of plugging it into _ . g
05:43:21 <Gurkenglas> (\fx -> fx . g) . (\x -> f x)
05:48:12 <Myrl> @pl (\x -> mutate (f xs) (\x -> swapAdj (g x) x) xs
05:48:12 <lambdabot> (line 1, column 48):
05:48:12 <lambdabot> unexpected end of input
05:48:12 <lambdabot> expecting variable, "(", operator or ")"
05:48:14 <Myrl> @pl (\x -> mutate (f xs) (\x -> swapAdj (g x) x) xs)
05:48:15 <lambdabot> const (mutate (f xs) (swapAdj =<< g) xs)
05:48:23 <Myrl> Oh cool.
05:48:36 <Myrl> @pl (\xs -> mutate (f xs) (\x -> swapAdj (g x) x) xs)
05:48:36 <lambdabot> flip mutate (swapAdj =<< g) =<< f
05:48:42 <Myrl> Yeah, this looks nice.
05:49:25 <Myrl> IIRC, f =<< g == f (g x) x
05:49:35 <quicksilver> bind in the reader monad lets you use the same argument twice
05:49:36 <Myrl> For functions.
05:49:42 <quicksilver> I mean, the reader monad in general permits that
05:49:55 <quicksilver> but unless you are fluent in it, the resulting code is not so easy to read
05:50:11 <Myrl> quicksilver: Yeah.
05:50:19 <Myrl> I got used to it though, specially <*>
05:50:26 <Myrl> especially*
05:50:33 <Myrl> Hmmm
05:50:33 <quicksilver> f (g x) x is rather like S
05:50:45 <Myrl> quicksilver: in SKI?
05:50:47 * quicksilver nods
05:50:56 <Myrl> quicksilver: I learned from someone that <*> *is* S.
05:51:12 <Myrl> quicksilver: f <*> g $ x == f x (g x)
05:51:44 <quicksilver> @pl \x -> f x (g x)
05:51:45 <lambdabot> ap f g
05:51:53 <Myrl> :t ap
05:51:54 <lambdabot> Monad m => m (a -> b) -> m a -> m b
05:51:55 <quicksilver> ap is <*>
05:51:58 <Myrl> Ah.
05:52:53 <quicksilver> @pl \x -> f x x
05:52:53 <lambdabot> join f
05:53:16 <quicksilver> obviously, 'join', 'bind' and '<*>' are all things which combine two combinations
05:53:29 <quicksilver> so, in (r ->) they get to use the `r` twice
05:53:51 <quicksilver> they do so in slightly different ways and if you're golfing code which uses a variable ore than once, it varies which one looks nicest
05:58:25 <Myrl> @pl \y z -> f y z x
05:58:25 <lambdabot> flip flip x . f
05:58:35 <Myrl> Hmmm...
05:58:42 <Myrl> @pl \y z -> f y z . g
05:58:42 <lambdabot> flip flip g . ((.) .) . f
05:58:50 <Myrl> Wow, just a very small change.
06:02:33 <quicksilver> @pl \a b -> foo a (bar a b) b (baz b a)
06:02:33 <lambdabot> ap (ap . join . liftM2 (.) foo bar) (flip baz)
06:02:46 <quicksilver> Myrl: I think these things just show how great lambda notation is
06:03:14 <quicksilver> got two values? got a bunch of places to use each of them? I know, let's give them both a temporary name and use that name to show where each value is used.
06:03:25 <quicksilver> \ is your friend.
06:05:39 <Gurkenglas> But naming is hard!
06:07:17 <Gurkenglas> Also perhaps the pl'd version being long means that you ought to pass the arguments in another order, or the functions you use ought to take them in another order, or you're trying to solve the wrong problem
06:08:16 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
06:08:16 --- topic: set by quicksilver!~jules@roobarb.crazydogs.org on [Wed Oct 07 07:39:49 2015]
06:09:33 <jophish> hmm, what are people's opinions on functions that start with 'get'
06:10:04 <Clint> like getPaid?
06:10:05 <Gurkenglas> When you're building one of those, perhaps you ought to use lens stuff or State monad stuff
06:12:20 <c_wraith> :t getConst
06:12:21 <lambdabot> Const a b -> a
06:12:42 <c_wraith> My recent favorite get* function 
06:13:04 <Gurkenglas> I usually try to use ala and the like to not have to use the name of the unwrapper
06:13:43 <jophish> What's ala all about
06:13:44 <c_wraith> I've never found ala to work for any use case I actually have. 
06:13:57 <jophish> I'm no lend guru and the type isn't helping :/
06:14:08 <Gurkenglas> c_wraith, give me a use case where you hoped to be able to use ala
06:15:03 * hodapp pokes around for Haskell/other FP jobs near Cincinnati...
06:17:08 <Gurkenglas> :t ala Sum foldMap -- jophish, ala borrows a newtype's features for a function like foldMap or traverse that can use them
06:17:10 <lambdabot> (Num b, Foldable t) => t b -> b
06:17:10 <quicksilver> c_wraith: that means that are you insufficiently skilled in refactoring your use cases as a call to foldMap
06:17:32 <quicksilver> c_wraith: because ala works in precisely all the cases that you can re-express your problem as a call to foldMap inside a newtype
06:17:47 <quicksilver> which is, quite a large set of cases if you're prepared to work really hard at it :)
06:19:59 <frerich> Does anybody know if there are 'stack' packages for Debian 6 ?
06:20:47 <hodapp> hm, I'm using it on my Debian 7.8 VPS from packages but that's about it
06:20:58 <jophish> :t foldMap Sum
06:20:59 <c_wraith> > flip appEndo [] . getConst . traverse (Const . Endo . (:)) $ [1..]
06:20:59 <lambdabot> (Num a, Foldable t) => t a -> Sum a
06:21:00 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
06:21:33 <c_wraith> Antigolf for id
06:22:01 <quicksilver> haskell is pretty great at antigolf actually
06:22:38 <muhuk> stack test --file-watch doesn't seem to recompile test executable (actually a lib test exec imports)
06:22:43 <muhuk> am I missing something?
06:22:56 <Gurkenglas> jophish, your version steals the features, ala only borrows :D
06:23:41 <c_wraith> Pretend my use case was better than id. How does something structured like that use ala? 
06:24:22 <Myrl> quicksilver: Antigolf == Obfuscation?
06:24:59 <c_wraith> Not always! 
06:25:30 <Ankhers> I think obfuscation is just a side effect of antigolf.
06:25:35 <c_wraith> Sometimes golf == obfuscation, and antigolf makes it readable. 
06:25:49 <Ankhers> That is a better description.
06:26:12 <Ankhers> golf = make it as short as possible. antigolf is make it as long as possible?
06:26:24 <Gurkenglas> :t (alaf Endo . alaf Const) traverse (:)
06:26:25 <lambdabot> Traversable t => t a -> [a] -> [a]
06:27:36 <quicksilver> shame that Endo . Const doesn't typecheck
06:27:42 <quicksilver> sometimes our type system is surprising :)
06:27:51 <c_wraith> That's not an improvement if you have to put the [] some place far from where it makes sense.. 
06:30:10 <quicksilver> > flip ((alaf Endo . alaf Const) traverse (:)) [] $ [1..]
06:30:11 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
06:30:40 <Gurkenglas> > ($ []) . (alaf Endo . alaf Const) traverse (:) $ [1..] -- I'd say manipulations using Endo should return a function. Applying [] to it ought to look tacked on
06:30:42 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
06:30:59 <julianleviston> does anyone know how to get around the fact that the hint package’s runInperpreter takes over the system signals?
06:31:03 <c_wraith> The [] still migrated pretty far from the Endo use. 
06:31:15 <Gurkenglas> As my comment says it should
06:31:20 <quicksilver> also ($ []) is quite a nice combinator, known as the 'money-obsessed monkey'
06:31:44 <julianleviston> quicksilver: I thought all combinators had bird names! ;-)
06:32:30 <Myrl> @pl (\x -> flip swapAdj x <$> randomlyR (0, length x - 1)
06:32:30 <lambdabot> (line 1, column 54):
06:32:30 <lambdabot> unexpected end of input
06:32:30 <lambdabot> expecting variable, "(", operator, "<*", "*>", "<$>", "<$", "<**>", "==", "/=", "<", "<=", ">=", ">", "`elem`", "`notElem`" or ")"
06:32:32 <Myrl> @pl (\x -> flip swapAdj x <$> randomlyR (0, length x - 1))
06:32:32 <lambdabot> ap ((<$>) . flip swapAdj) (randomlyR . (,) 0 . subtract 1 . length)
06:33:38 <julianleviston> flip == thrush?
06:36:27 <Myrl> :t trush
06:36:28 <lambdabot> Not in scope: ‘trush’
06:36:49 <Gurkenglas> :t flip
06:36:50 <lambdabot> (a -> b -> c) -> b -> a -> c
06:37:05 <Gurkenglas> Exactly one function implements this (inb4 _|_)
06:37:15 <Gurkenglas> @djinn (a -> b -> c) -> b -> a -> c
06:37:15 <lambdabot> f a b c = a c b
06:37:57 <Myrl> What the hell.
06:38:20 <julianleviston> Myrl: the @ djinn thing makes a function that implements a type sig
06:38:30 <quicksilver> BY MAGIC
06:38:34 <julianleviston> lol
06:38:34 <quicksilver> or, actually, BY LOGIC
06:38:45 <quicksilver> but, you know, I'd rather call myself a magician than a logician.
06:39:15 <jophish> "mathemagician"
06:39:33 <julianleviston> as to thrush, it’s a bird name for (.), I think… from a somewhat interesting book on math puzzles… http://www.amazon.com/Mock-Mockingbird-Other-Logic-Puzzles/dp/0192801422
06:39:35 <Myrl> julianleviston: I know.
06:39:39 <Ankhers> jophish: I'm stealing that.
06:39:45 <julianleviston> Myrl: oh ok. why the “what the hell” then?
06:40:24 <breadmonster> Hey guys.
06:40:35 <Myrl> https://gist.github.com/19347a8bd527c899198b
06:40:39 <Myrl>  It won't typecheck!?
06:41:14 <julianleviston> Myrl: flip has too many arguments doesn’t it?
06:41:25 <julianleviston> :t flip
06:41:26 <lambdabot> (a -> b -> c) -> b -> a -> c
06:41:29 <Myrl> julianleviston: The first 2 typechecks.
06:41:31 <Myrl> The last one doesn't.
06:41:35 <julianleviston> Myrl: oh ok.
06:42:00 <Myrl> :t (>=>
06:42:01 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
06:42:01 <Myrl> :t (>=>)
06:42:02 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
06:42:15 <Myrl> It *should* typecheck..
06:42:32 <julianleviston> Myrl: should it?
06:42:40 <quicksilver> Myrl: no it shouldn't
06:42:45 <Myrl> ([a] -> m a) -> (a -> m a) -> a -> m a
06:42:48 <Myrl> quicksilver: Why not?
06:42:51 <quicksilver> swapAdjR is 'backwards'
06:43:04 <Myrl> quicksilver: How is it backwards?
06:43:08 <quicksilver> erm wait
06:43:10 <julianleviston> Myrl: it takes a string
06:43:18 <Myrl> Basically, what I'm doing is
06:43:21 <quicksilver> no it's fine
06:43:23 <julianleviston> ooh oops
06:43:27 <quicksilver> but the answer is Randomly String
06:43:33 <quicksilver> not Randomly (Pop String)
06:43:47 <julianleviston> :t (>=>)
06:43:48 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
06:43:54 <Myrl> (Pop String -> Randomly String) -> (String -> Randomly String) -> Pop String -> Randomly String
06:44:10 <quicksilver> yes
06:44:17 <quicksilver> but that's not what you wrote in the gist
06:44:17 <Myrl> quicksilver: Then why doesn't it typecheck?
06:44:26 <quicksilver> Randomly (Pop String)
06:44:28 <quicksilver> you wrote
06:44:34 <quicksilver> but it's actually Randomly String
06:44:38 <quicksilver> as you said in this channel  just now
06:44:48 <Myrl> quicksilver: Oh shit...
06:44:54 <quicksilver> :)
06:45:07 <Myrl> Err...
06:45:08 <Myrl> :(
06:46:40 <Myrl> Also, is there a type
06:46:56 <Myrl> Rather
06:47:52 <Myrl> Is there a function in stdlib, `foo :: Int -> (a -> a) -> [a] -> [a]`
06:48:06 <Myrl> Hmmm..
06:48:09 <Myrl> List update operation.
06:48:28 <julianleviston> Combinator birds! http://www.angelfire.com/tx4/cus/combinator/birds.html
06:48:47 <Myrl> The question is, is there...
06:49:04 <hc> i'm using distributed-process... what's the easiest way to see an error for a crashing process?
06:49:23 <hc> (right now, the crashing process just vanishes without any output on the console)
06:49:35 <quicksilver> Myrl: no, there isn't.
06:49:50 <Myrl> quicksilver: Yeah. :s
06:49:58 <quicksilver> Myrl: you can write take (n-1) xs ++ f (xs !! n) ++ drop n xs
06:50:07 <quicksilver> but that's a clue you're using the wrong data structure.
06:50:27 <quicksilver> > "hello" & ix 2 .~ 'X'
06:50:29 <lambdabot>  "heXlo"
06:50:42 <quicksilver> or you can use lens, which is polite enough not to remind you it's the wrong data structure :P
06:51:40 * dutchie idly wonders if there is a question in haskell that doesn't have "use lens" as a possible answer
06:52:20 <Myrl> dutchie: Pathfinding.
06:52:37 <Myrl> I guess you can define a lens for maps though...
06:52:44 <Myrl> And maps are useful for pathfinding.
06:52:46 <quicksilver> the lens library certainly makes writing dijkstra a bit more concise
06:52:54 <Myrl> quicksilver: Really?
06:53:13 <quicksilver> well, sure, the parts where you update the maps storing visited nodes etc
06:53:22 <Myrl> Also, for Dijkstra, I used `Nothing` instead of infinity, it feels more Haskell-ish. :D
06:55:14 <dutchie> i suppose really you should define `type SuccOmega = Finite Integer | Infinity` and define an appropriate Ord instance...
06:55:43 <dutchie> er, `data SuccOmega = ...`
06:55:51 <quicksilver> already exists, dutchie
06:55:59 <dutchie> i suspected as much
06:57:40 <quicksilver> somewhere. Can't find it actually.
06:57:44 <quicksilver> I thought it was in semigroups.
06:58:16 <quicksilver> "Min Integer" is a Semigroup but you need to adjoin +Inf to make it a Monoid
06:58:46 <dutchie> oh, my integers weren't non-negative
06:59:06 <dutchie> church numerals it is then!
07:04:28 <Myrl> :t mod
07:04:29 <lambdabot> Integral a => a -> a -> a
07:21:11 <meditans> hi, I'd like a little help to enumerate a datatype using Control.Monad.WeightedSearch
07:21:29 <meditans> (which is a bit like Control.Monad.Omega, but with weights added)
07:21:50 <meditans> here it's a stub of the problem I'm trying to solve https://gist.github.com/meditans/979a0e486f7839e3b2be
07:22:46 <meditans> basically, I'd like to generate the trees in depth order
07:30:15 <anelson> johnw: ping
07:32:52 <byorgey> quicksilver, dutchie: http://hackage.haskell.org/package/monoid-extras-0.4.0.2/docs/Data-Monoid-Inf.html
07:34:02 <quicksilver> thanks byorgey :)
07:34:09 <byorgey> sure =)
07:35:10 <quicksilver> byorgey: diagrams is such a great example of why monoids are actually relevant to practical programming
07:35:34 <byorgey> quicksilver: agreed =)
07:39:36 <lesmon> Hi.
07:43:18 <lyxia> meditans: interesting exercise.
07:45:42 <byorgey> hi lesmon 
07:46:07 <lesmon> :}
07:48:11 <meditans> lyxia: yeah, it is.. I'm interested in all smart solutions that don't explicitely construct the trees of a given depth, but I've not been able to find one; if you do, please ping me ;)
07:56:09 <orion> I am writing a small unit test to see if the output generated by a function matches a certain regular expression. What's the best regex library to use in this case?
07:59:56 <quicksilver> not sure? regex-tdfa perhaps? but are you sure that regexp is the best way to solve that problem orion?
08:02:20 <orion> Unfortunately, I am not sure that a regex is the best way to solve the problem.
08:02:33 <Azel> orion: regex-pcre should be safe if you want Perl regexp rather than Posix.
08:04:59 <orion> I have a function that takes a Foo and formats it as a bytestring. The result should look like, "1445312105.176365" (for example), it should *not* look like "1.445319044668561e9"
08:05:00 <SrPx> Is there any way to run stack build/install with optimizations off so it ends faster?
08:05:32 <orion> And I need to test to make sure that property holds, and I see no other way to do so without checking the resultant bytestring via regexs.
08:05:46 <quicksilver> orion: you could try checking it doesn't contain the char 'e' :)
08:05:54 <orion> heh
08:06:09 <orion> ehhhhh I guess. :p
08:07:00 <quicksilver> seriously though
08:07:06 <quicksilver> check
08:07:15 <quicksilver> all (`elem`"01234567890.")
08:07:19 <quicksilver> and check
08:07:40 <quicksilver> (==1) . length . filter(=='.')
08:08:01 <quicksilver> then you know it's composed entirely of digits and dots, and it has exactly one dot
08:08:11 <quicksilver> (maybe you want 'at most one dot', I don't know)
08:08:37 <quicksilver> you may have other constraints I don't know about (maximum? min? max length?)
08:08:40 <orion> heh, that's much easier than bringing in regex. :p
08:08:52 <rcat> is anyone aware of a HTTP/2 client library available?
08:08:58 <quicksilver> in my opinion, it's simpler, yes :)
08:09:05 <kia> My site is getting hacked by file upload code .can some one advice me something on how to prevent it??
08:09:18 <quicksilver> rcat: https://hackage.haskell.org/package/http2 ?
08:10:54 <lyxia> meditans: https://gist.github.com/Lysxia/ff7592f3cde561934cde
08:11:31 <rcat> quicksilver: yeah I saw that, it only implements the new wire protocol used in HTTP/2
08:11:45 <rcat> I need to investigate if it is easy to use somehow over another library or something
08:13:06 * quicksilver nods
08:13:18 <kia> hi rcat
08:13:32 <rcat> kia: hi!
08:14:31 <kia> are you a hacker?? I need some advice..
08:14:41 <meditans> lyxia: wow, that's great, give me a minute to read the code
08:15:09 <rcat> kia: a hacker in what sense? haha
08:15:14 <rcat> kia: but no...
08:15:35 <cow_2001> how do i decode this csv :|
08:15:40 <cow_2001> using cassava
08:15:48 <kia> i Mean My site is getting hacked by a UAE hacker by a file upload code I am unable to understand what to do
08:17:46 <davean> Ongy: Ok, I'll email the maintainer and transfer it if I get the same response. What is your hackage login?
08:18:17 <rcat> kia: definitely not me
08:18:26 <davean> Ongy: I'm a hackage trustee and can take care of that for you two.
08:18:36 <Ongy> davean: https://hackage.haskell.org/user/ongyerth
08:18:41 <Ongy> thank you
08:18:47 <kia> ?? you mean you don't know??
08:18:47 <lambdabot>  you mean you don't know
08:19:06 <kia> haha
08:20:09 <kia> ok place where I can get some advice that you know rcat:
08:20:31 <meditans> lyxia: that's a correct version of what I was trying to write. Why the weight for a tree l has to be 2^dl - 1?
08:21:04 <davean> Ongy: you confirmed with Max Treskin?
08:21:23 <kia> ok thanks racat... bye..
08:21:52 <Ongy> davean: yes
08:23:40 <davean> Ongy: Ok, I've emailed him. I'll handle it as soon as I get a response
08:24:10 <lyxia> meditans: The weights encountered in a path to one result add up together.
08:25:23 <lyxia> meditans: and you want the weight function to be such that w (Branch l r) >= 1 + max (w l) (w r) to get the trees in the right order
08:26:53 <lyxia> meditans: w(t) = 2^depth t - 1 makes that an equality, which is sufficient
08:27:19 <lyxia> uh 
08:27:36 <lyxia> what am I saying
08:28:06 <lyxia> w (Branch l r) >= w l + w r
08:28:24 <meditans> lyxia: yeah, that's crystal clear, thank you
08:29:19 <lyxia> in the do block, binding l and r accumulates the weight w l + w r, so the final weight is going to be at least as much.
08:29:28 <meditans> lyxia: I was stuck trying tricks to set the weight equal to the depth, tricking the library, instead of regarding this as a funcional equation, as you rightly did
08:29:51 <lyxia> yeah I also tried that :)
08:29:57 <breadmonster> Hey guys.
08:30:17 <meditans> lyxia: yeah, that's clear now; So basically, I have to take a variation of that function if I have a 3-branching tree?
08:30:42 <meditans> lyxia: I mean, I have to do various manual tweakings to my weight function, as I vary the datatype
08:32:33 <lyxia> If the nodes have bounded arity it should be possible to automate it with a lot of work
08:33:28 <meditans> lyxia: what would be a suitable weight function if I have different arities coexisting?
08:33:44 <lyxia> Actually if the arities are bounded, there are going to be already infinitely many trees at depth 1 already...
08:33:50 <meditans> lyxia: like Tree = Leaf | BBranch Tree Tree | TBranch Tree Tree Tree
08:34:13 <lyxia> meditans: treat every branching node as if it had maximum arity
08:35:11 <lyxia> So the weight would be maxArity^depth, give or take a constant for cleaner code.
08:35:41 <SrPx> What is the easiest way to load a BMP from disk as an unboxed RGBA array of Word8s? left to right, top to bottom as usual?
08:36:08 <quicksilver> depends what you want to do with it when it's loaded
08:36:17 <quicksilver> there must be half a dozen graphics libs on hackage which can load BMPs
08:36:27 <quicksilver> (but mostly they load it into their own data types so they can use it, which makes sense)
08:36:41 <meditans> lyxia: yeah, that works
08:36:55 <meditans> lyxia: thanks so much for the insight :)
08:47:51 <SrPx> quicksilver: that's why I'm asking, what I want to do = get an unboxed array which is the format my image lib is using...
08:48:13 <SrPx> I'm currently trying to go through repa since it has a load BMP function
08:48:40 <SrPx> so, REPA → Unboxed array of Word8 → unboxed array of Word32 (the format I am using)
08:48:56 <SrPx> how do I convert an unboxed array of Word8 to an unboxed array of Word32 in O(1)?
08:49:24 <quicksilver> sounds like a terrible idea to me
08:49:32 <Welkin> unboxed?
08:49:38 <quicksilver> how do you know the word8s are in the order which corresponds to your machine's endianness?
08:49:39 <Welkin> you just change the pointer boundaries
08:49:40 <Welkin> lol
08:50:30 <quicksilver> having said it's a terrible idea, it may be possible with some of the unboxed array types
08:50:46 <SrPx> So again, how do I load an image from disk as the format I am using (U.Vector Word32)? 
08:50:54 <quicksilver> sounds like an un-needed optimisation though, how big are your arrays?
08:51:05 <emmanuel`> hello there everyone.... I have an optimization question.
08:51:08 <quicksilver> the word8-word32 conversion would be a different order of magnitude speed ot the disk load.
08:51:33 <SrPx> quicksilver: okay
08:51:40 <SrPx> but still can I cut the middle man (repa)?
08:51:46 <lpaste> emmanuel_erc pasted “List element frequencies -- One pass” at http://lpaste.net/143696
08:51:56 <SrPx> for the sake of not needing the dependency just for it
08:53:22 <Welkin> emmanuel`: to record the frequency of elemetns in a list, just use a Map to store the number, using the element as the key
08:53:35 <quicksilver> SrPx: well you can write your own code of course, it's pretty trivial
08:53:47 <quicksilver> SrPx: or JuicyPixels probably has more or less the API you want
08:53:51 <emmanuel`> Welkin, that would be faster than what I've written?
08:54:17 <SrPx> quicksilver: it may be trivial but I'm not sure how the BMP format works... hmm let me see
08:54:27 <quicksilver> hmm maybe not
08:54:35 <quicksilver> maybe JuicyPixels stores it as Word8s
08:54:40 <Gurkenglas> emmanuel`, fst &&& f . snd is second f
08:54:41 <Welkin> building a Map is (n log n)
08:55:00 <emmanuel`> thanks Gurkenglas
08:55:01 <Welkin> emmanuel`: you could also try using HashMap instead
08:55:17 <glguy> and second f is actually fmap f
08:55:23 <Welkin> Map should be fast enough
08:55:26 <Welkin> lol glguy 
08:55:33 <glguy> No need to drag Control.Arrow out of the grave
08:55:43 <Welkin> but Arrow doesn't get enough love!
08:55:51 <SrPx> quicksilver: actually that's the least of my problems since I'm using the even worst route of MyImage→REPA→GlossRaster to render it on screen... so I still depend on both REPA and Gloss just to render the image
08:55:54 <emmanuel`> Arrow is a cool customer..
08:56:11 <SrPx> quicksilver: I think I'll try to solve that first, what do you recommend ? OpenGL and Glut, or is there something more lightweight that will just render an unboxed vector to the screen?
08:56:27 <emmanuel`> So, basically, what I have done is overkill?
08:56:45 <Welkin> emmanuel`: your code is hard to read, actually
08:56:53 <Jinxit> I have a sum type as a tree, trying to define it as a Traversable (instance Traversable Expr where ...), but it says the first argument should have the kind "* -> *"
08:56:56 <Jinxit> what am I missing?
08:56:58 <Welkin> I would have no idea what it is doing within reading very closely
08:57:07 <Welkin> luckily you provided a title
08:57:11 <Zekka> Jinxit: Your type needs to take a parameter
08:57:19 <Welkin> without*
08:57:19 <Zekka> does it?
08:57:31 <Welkin> emmanuel`: but if all you want to do is get the frequency of elements in a list, use a Map
08:57:32 <Zekka> (If it takes more than one parameter, that's OK, but it will only be a Traversable over the last one)
08:57:35 <Welkin> it is the simplest solution
08:57:41 <Jinxit> no, it does not
08:57:41 <Welkin> lists are not what you should be using
08:57:47 <emmanuel`> Essentially, all I am doing, is creating a lists of empty lists as a another way of counting.
08:57:50 <Welkin> they have linear access
08:57:51 <Jinxit> is Traversable the wrong thing to use?
08:57:54 <Welkin> Map has log n access
08:58:03 <quicksilver> SrPx: well, Gloss is probably easier to use than OpenGL
08:58:11 <quicksilver> SrPx: unless you are already a confident GL progrmmer
08:58:13 <emmanuel`> Right... I will keep that in mind Welkin.
08:58:15 <Zekka> Yeah, it's pretty likely -- the traversable operations assume your type will let you swap a different thing in
08:58:22 <Jinxit> ahh I see
08:58:33 <SrPx> but isn't it overkill just for putting pixels on the screen? I'm doing all the rendering on the cpu
08:58:37 <Zekka> For instance, Traversable requires your type to be a Functor
08:58:50 <Zekka> which means it must support fmap :: (a -> b) -> f a -> f b
08:58:59 <Jinxit> so if I want to manipulate what is inside my sum type tree?
08:59:03 <Jinxit> without changing types
08:59:03 <lpaste> glguy annotated “List element frequencies -- One pass” with “List element frequencies -- One pass (annotation)” at http://lpaste.net/143696#a143698
08:59:24 <Zekka> I don't know if there's a typeclass for that, but don't quote me
08:59:34 <emmanuel`> lol glguy.... Thanks...
08:59:43 <exio4> MonoTraversable?
09:00:18 <Zekka> https://hackage.haskell.org/package/mono-traversable-0.10.0/docs/Data-MonoTraversable.html <- didn't know this existed but it might do what you want
09:00:34 <Welkin> mono-traversable is awesome :D
09:00:41 <quicksilver> or you cna just use Traversal from lens
09:00:49 <quicksilver> which can also be mono-typed
09:01:09 <quicksilver> however 'Expr' sounds like more than any old traversal, it sounds Plated to me.
09:01:20 <Jinxit> it's an AST
09:01:31 <Gurkenglas> > fmap (+1) ("a", 3) -- Of course, second is just fmap because of ((,) a)'s Functor instance.
09:01:32 <lambdabot>      Ambiguous occurrence ‘+’
09:01:33 <lambdabot>      It could refer to either ‘L.+’,
09:01:33 <lambdabot>                               defined at /tmp/mueval1374344043760313750.hs:178:3
09:01:55 <Gurkenglas> > fmap (*2) ("a", 3)
09:01:57 <lambdabot>  ("a",6)
09:02:31 <quicksilver> Jinxit: yeah I'd go with lens, Traversal, and Plated myself.
09:02:31 <Jinxit> should I use Functor?
09:02:33 <Jinxit> oh
09:02:52 <glguy> Jinxit: First you should just write the traversal function you need
09:02:56 <lpaste> Gurkenglas annotated “List element frequencies -- One pass” with “emmanuel`, he refactored all but main, here's a refactored main.” at http://lpaste.net/143696#a143699
09:03:00 <glguy> second you should think about if you need to drag in a class
09:03:13 <Jinxit> I mostly thought it would be a good exercise
09:03:28 <Jinxit> the function is already done (but untested because I got sidetracked)
09:04:35 <emmanuel`> Gurkenglas: wow.... I have a lot to learn about writing good Haskell code.
09:04:37 <Gurkenglas> (Oops, nevermind the removal of samples, you use it in two places.
09:05:07 <emmanuel`> Thanks, for looking at my code.
09:05:15 <emmanuel`> I thought I was being clever ... lol.
09:05:26 <Welkin> emmanuel`: it never pays to be clever in programming
09:05:35 <Zekka> Which one is his?
09:05:39 <Welkin> emmanuel`: you are your own worst enemy :P
09:06:40 <Gurkenglas> emmanuel`, his refactoring can also be replaced by "frequencies = M.fromListWith (+) . map (,1)"
09:07:26 <glguy> but probably shouldn't be
09:07:37 <Gurkenglas> Why not?
09:08:03 <c_wraith> That will leak space like crazy
09:08:34 <Gurkenglas> Ah, right.
09:08:53 <emmanuel`> Did you mean forM instead of for Gurkenglas?
09:09:02 <Welkin> c_wraith: why is that?
09:09:03 <emmanuel`> (I'm not saying you're wrong, I am just confused)
09:09:06 <lpaste> glguy annotated “List element frequencies -- One pass” with “emmanuel`, he refactored all but main, here's a refactored main. (annotation)” at http://lpaste.net/143696#a143701
09:09:07 * hackagebot TaxonomyTools 1.0.0 - Tool for parsing, processing, comparing and visualizing taxonomy data  https://hackage.haskell.org/package/TaxonomyTools-1.0.0 (FlorianEggenhofer)
09:09:14 <Gurkenglas> emmanuel`, forM is for restricted to monads instead of Applicatives
09:09:24 <glguy> emmanuel`: There's one with a refactored main which doesn't try to be as clever
09:09:38 <quicksilver> really? does that mean all these beautiful foldBy (M.unionWith (+)) tricks are a bad idea ? :(
09:09:44 <quicksilver> but they look so pretty
09:10:27 <Gurkenglas> fromListWith (+) works if we use Data.Map.Strict, right?
09:11:08 <Welkin> I always import Data.Map.Strict
09:11:32 <glguy> Gurkenglas: How would this work: [(0,25), ('a','z')] ?
09:11:33 <Gurkenglas> That's because you never need codata maps.
09:12:04 <c_wraith> In theory. I don't really trust it to get the level of strictness I want. It always goes too far in one direction or the other. 
09:12:17 <quicksilver> Gurkenglas: Data.Map.Strict is only WHNF of values, isn't it?
09:12:30 <quicksilver> doesn't really affect codata values, just might force their head
09:13:03 <Gurkenglas> I thought Data.Map.Strict evaluates the whole map, including values, to WHNF once anything of it is read
09:13:21 <quicksilver> yes, but WHNF values doesn't stop you storing co-data
09:13:30 <quicksilver> it simply forces the head of the co-data
09:13:43 <emmanuel`> I tried your version glguy, it is 3x faster than my original code lol.
09:14:16 <quicksilver> as for keys - well, Maps are almost strict in keys anyway
09:14:33 <quicksilver> because compare for equality has a tendency to force things fully
09:14:34 <Welkin> emmanuel`: usre, lists are O(n), Map is O(log n)
09:14:49 <emmanuel`> Yeah
09:14:51 <Gurkenglas> > [1, 3] `for` lookup $ [(1, 2), (2, 3), (3, 1)] -- glguy, here's an example using the Reader applicative
09:14:53 <lambdabot>  [Just 2,Just 1]
09:15:00 <glguy> Gurkenglas: The point was that it's a type error
09:15:07 <Gurkenglas> oops :D
09:15:11 <orion> When you have flags defined in your cabal file and you run "cabal install", which flags will be turned on automatically, and if a flag isn't turned on automatically, how do you turn it on?
09:15:32 <Welkin> orion: none of them
09:15:36 <Welkin> oh
09:15:39 <Welkin> cabal install?
09:15:43 <Welkin> what flags do you mean?
09:15:47 <Welkin> compiler flags?
09:15:57 <glguy> orion: You turn on cabal flags with the -f flag
09:16:00 <Welkin> I thought you meant language pragmas
09:16:09 <Gurkenglas> Damn, I think that's the first time I want heterogenous lists.
09:16:32 <glguy> orion: try "cabal configure --help" and looking for --flags
09:16:48 <tommd> orion: There are lots of flags defined in a .cabal.   Cabal flags, GHC flags, CC flags, language paragmas were there at one point...
09:17:32 <orion> No, I mean project flags.
09:18:12 <orion> I.e., "flag foo" in the cabal file.
09:18:17 <tommd> So the top level 'flag foo'?   That is wha glguy is talking about.
09:18:27 <tommd> orion: There can be a 'default: {True,False}'.
09:18:38 <tommd> orion: And you can use 'cabal install -ffoo'
09:18:41 <orion> I see.
09:19:22 <quicksilver> glguy: so are you saying that, even with a 'fixed' Monoid instance, foldMap (\x -> M.singleton x (Sum 1)) is not wise?
09:20:08 <glguy> quicksilver: You were talking to c_wraith about strictness
09:20:53 <quicksilver> 17:06 < Gurkenglas> emmanuel`, his refactoring can also be replaced by  "frequencies = M.fromListWith (+) . map (,1)"
09:20:56 <quicksilver> 17:07 < glguy> but probably shouldn't be
09:21:03 <quicksilver> were you not responding to that point?
09:22:12 <glguy> I was objecting to the jump to -XTupleSections and using operators for the sake of using operators
09:23:07 <quicksilver> oh :)
09:23:14 <glguy> I'd expect foldMap to be lazy in the values and for  the foldMap version to build up big thunks, though
09:25:43 <glguy> quicksilver: Also, using foldMap to consume the list is going to be worse than using foldl'
09:45:06 <orion> I am building a binary in a sandbox, and my expectation is that when I run "ldd .cabal-sandbox/bin/foo" I'll see a bunch of haskell libraries linked in, but I do not.
09:45:51 <orion> Does that mean the executable can be moved to another machine on the same OS and it'll work? Or do I need to link with "-static" for that?
09:53:41 <tommd> orion: That is an implication.  You can try running the binary and looking at the pmap (vmmap on OS X)
09:55:55 <c_wraith> As long as the architecture is the same and all required libs can be found.. Yes. 
09:56:37 <tommd> And the ABI is the same...
09:56:41 <c_wraith> When I used haskell in production, we always built on a build box and just shipped binaries to production machines. 
09:57:09 <zomg> ^ same
09:57:19 <brendanwhite84> @help
09:57:20 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:57:25 <zomg> helps in a case where your production box isn't so beefy and would take forever to build it =)
09:58:19 <brendanwhite84> @undo do a <- putStr "\n" ; let b = show a ; return b
09:58:19 <lambdabot> <unknown>.hs: 1: 48:Parse error: EOF
09:58:38 <brendanwhite84> @undo do print "foo"
09:58:38 <lambdabot> print "foo"
09:58:54 <brendanwhite84> @undo do a <- putStr foo ; let b = show a ; return b
09:58:55 <lambdabot> <unknown>.hs: 1: 47:Parse error: EOF
09:59:25 <brendanwhite84> @undo do a <- putStr foo
09:59:25 <lambdabot> <unknown>.hs: 1: 19:Parse error: Last statement in a do-block must be an expression
09:59:33 <brendanwhite84> @undo do a <- putStr foo ; print a
09:59:33 <lambdabot> putStr foo >>= \ a -> print a
09:59:44 <brendanwhite84> @undo do a <- putStr foo ; return a
09:59:44 <lambdabot> putStr foo >>= \ a -> return a
10:00:13 <c_wraith> brendanwhite84: it's ambiguity of the semicolon with both let and do. 
10:00:21 <brendanwhite84> Thanks c_wraith!
10:01:46 <c_wraith> brendanwhite84: to clear it up, change the let to have braces.. let { foo = bar } ;... 
10:02:09 <brendanwhite84> @undo do a <- putStr foo ; let { b = show a } ; return b
10:02:10 <lambdabot> putStr foo >>= \ a -> let { b = show a} in return b
10:02:23 <brendanwhite84> Awesome, thanks again! Saved me a scrubby post to Stack Overflow
10:02:44 <Zekka> brendanwhite84: You can do it more simply than that
10:02:57 <Zekka> But maybe you already have the idea well enough
10:03:02 <brendanwhite84> Thanks Zekka; this is more for pedagogical purposes. I'm just getting started.
10:03:05 <brendanwhite84> Cheers all!
10:03:19 <f-a> I guess this has already been answered: why no instance of Functor for Set? Doesn't seem to break any functor law https://wiki.haskell.org/Functor
10:03:42 <f-a> (and I don't see why Set.map has to be ordereable Sets)
10:04:47 <Zekka> https://www.fpcomplete.com/user/chad/snippets/random-code-snippets/set-is-not-a-functor <- f-a: here's a good example of why the straightforward way of making set a functor would not be lawful
10:06:00 <Zekka> f-a: It's possible you will be able to do what you want with Foldable though
10:06:02 <Zekka> and sets are Foldable
10:06:21 <f-a> thanks Zekka 
10:06:26 <Zekka> https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Foldable.html#t:Foldable
10:07:19 <Zekka> foldMap can simulate concatMap afaict, and concatMap can simulate map
10:08:03 <f-a> silly me, now it is obvious. Thanks Zekka 
10:08:03 <Zekka> (concatMap is actually just a specialization of foldMap)
10:08:10 <Zekka> Yeah, don't worry about it, I had the same question a while bakc
10:12:37 <orion> c_wraith / tommd: In production, would you recommend using staticly linked binaries?
10:13:02 <mksldf> Is there a convention/best practice when defining conversions between types?
10:13:19 <mksldf> My use case is actually closer to serialization
10:13:28 <quicksilver> Zekka: you can simulate map in the sense of outputting to a list, not a Set, yes :)
10:13:52 <mksldf> I'm guessing type classses are the way to go - similar to ToJSON/FromJSON ?
10:14:36 <mksldf> Do types in Haskell have 'default values'?
10:15:00 <Zekka> quicksilver: Sets are monoids too
10:15:25 <Zekka> (well, they're monads when their element type is Ord, but afaict that's necessary for most useful set ops)
10:15:28 <Zekka> er, monoids*
10:16:02 <Zekka> Foldable's concatMap will only output to a list, but foldMap will output to any monoid, including sets themselves
10:16:28 <tommd> orion: I would suggest building a package (deb, rpm, or msi/installer).  Some tooling exists to pull in or otherwise indicate the dependencies.
10:16:41 <tommd> orion: Long ago I used the bamse package to make an msi.
10:16:45 <Zekka> (will be on for very briefly more, but I have to go to school in a sec)
10:17:04 <tommd> I think there are easy ways to make a .deb from a cabalized package.
10:17:46 <Zekka> OK, have to go -- quicksilver: if I overlooked something I will probably be on in about 30-45 minutes
10:17:54 <Zekka> sorry to drop out on you
10:19:10 * hackagebot origami 0.0.5 - An un-SYB framework for transforming heterogenous  data through folds  https://hackage.haskell.org/package/origami-0.0.5 (nedervold)
10:19:40 <orion> tommd: I'm more referring to linking rather than packaging. Would you build a static binary or a dynamically linked one?
10:20:34 <mksldf> Are constructor fields no visible outside of the module they are declared in?
10:21:02 <tommd> orion: I see no issues with the dynamic binary if the packaging system is mature.
10:22:52 <orion> tommd: Alright. Are there any downsides with a static executable?
10:25:55 <Sonolin> if you link dynamically deployments could be faster due to smaller size
10:26:03 <Sonolin> if size difference doesn't matter maybe just go static?
10:28:03 <tommd> orion: Just the typical ones - no opportunity for reduced memory use by sharing library .text sections between separate processes.
10:28:08 <tommd> orion: Nothing special to Haskell.
10:29:21 <orion> Ok.
10:29:49 <orion> I do wonder though... with dynamic linking, how come I don't see entries for every single haskell library my project depends on?
10:30:22 <orion> All I see are links to C libraries.
10:32:13 <sfilipov> How do I create a Map using ClassyPrelude? The compiler tells me that Map constructor or functions like empty, insert, singleton are undefined. I thought that if I import ClassyPrelude then I don't need to import the most common data structures.
10:32:28 <tommd> orion: Do you have "shared: True" in .cabal/config?
10:32:46 <orion> tommd: It's commented out.
10:35:51 <tommd> orion: You need to add that an executable-dynamic: True, or use the --enable-... flags in cabal.
10:36:02 <tommd> Or just be happy with the static binary.
10:37:03 <orion> Ok, thank you.
10:41:37 <lpaste> vedosity pasted “Parsing permutations from a list” at http://lpaste.net/143705
10:41:46 <vedosity> So
10:42:51 <vedosity> I'm trying to get this permutation parser working, but as soon as I try to make it optional, it loops forever and I'm having trouble figuring out why
10:44:52 <lpaste> vedosity revised “Parsing permutations from a list”: “No title” at http://lpaste.net/143705
10:45:03 <vedosity> Any ideas?
10:48:35 <GLM> What is the type for int that doesn't have a max_int?
10:48:43 <sfilipov> Integer
10:53:50 <nomeata> vedosity: can you explain in what sense the parsing should be optional?
10:54:10 <nomeata> vedosity: i.e, do you want to parse any sublist of the given parsers?
10:55:02 <nomeata> hmm. looks like I scared him away.
10:56:18 <sfilipov> nomeata, do you have any experience with classy-prelude
10:56:35 <nomeata> sfilipov: no, sorry
10:56:44 <sfilipov> Thank you :)
10:58:26 * nomeata looks at the docs
10:59:41 <nomeata> sfilipov: the docs don’t say anything about maps
11:00:51 <nomeata> sfilipov: ah, it also exports CorePrelude
11:01:15 <nomeata> which exports the Map type
11:01:22 <sfilipov> Based on blogs - I should be able to access the functions without refering to the data type. It is strange because when I import it in ghci, I get suggestions for Map, but when I do ":t Map" I get "not in scope: Map"
11:01:29 <nomeata> I guess I’d need to see a paste of the code and error in question to help you
11:01:41 <sfilipov> yep, give me a minute
11:02:26 <shachaf> sfilipov: The full error should say something about "data constructor Map", not just "Map".
11:02:41 <sfilipov> yes it does
11:02:51 <shachaf> There's no data constructor in scope because Map is a type.
11:04:17 <nomeata> sfilipov: oh, of course shachaf is right, :t Map makes no sense. Does ":i Map" work?
11:04:40 <Cale> nomeata: yeah, or :k Map
11:04:47 <Cale> :k Map
11:04:47 <lambdabot>     Not in scope: type constructor or class ‘Map’
11:04:47 <lambdabot>     Perhaps you meant ‘M.Map’ (imported from Data.Map)
11:04:49 <Cale> :k M.Map
11:04:49 <lpaste> sfilipov pasted “Not in scope: data constructor 'Map'” at http://lpaste.net/143708
11:04:50 <lambdabot> * -> * -> *
11:05:15 <Cale> Oh, well, it looks like you've only imported Prelude and ClassyPrelude
11:05:18 <Cale> not Data.Map
11:05:45 <brendanwhite84> @undo do ; let { a = ( concat ( replicate 5 x ) ) ++ [ioLF] } ; b <- a ; return b
11:05:45 <lambdabot> let { a = (concat (replicate 5 x)) ++ [ioLF]} in a >>= \ b -> return b
11:05:49 * hackagebot network-anonymous-tor 0.11.0 - Haskell API for Tor anonymous networking  https://hackage.haskell.org/package/network-anonymous-tor-0.11.0 (solatis)
11:05:50 <Cale> oh ClassyPrelude exports it?
11:06:10 <Cale> sfilipov: But yeah, :t Map is obviously going to give you a not in scope regardless
11:06:16 <Cale> because Map is not a value
11:06:24 <Cale> It's a type constructor
11:06:40 <Cale> You can only ask for the types of values with :t
11:06:52 <nomeata> sfilipov: did you try :i?
11:07:01 <sfilipov> yes, ClassyPrelude is supposed to export it (CorePrelude more specifically)
11:08:40 <sfilipov> nomeata: :i Map works - it gives me a long list of packages which define Map. I can always import Map from "containers". But my understanding of ClassyPrelude is that I should be able to do things like 'singleton "key" "value"' and get back a singleton Map
11:09:08 <sfilipov> without importing Data.Map
11:09:13 <sfilipov> maybe I am wrong :)
11:10:04 <breadmonster> Oh hi Cale 
11:11:36 <shachaf> Using ClassyPrelude is probably making your life harder than it needs to be.
11:11:36 <nomeata> sfilipov: ok, lets’ start this different. what are you trying to do?
11:11:56 <sfilipov> shachaf: You are probably right, I'll give it a try for another 10 minutes and then just create a Map the old school way.
11:12:37 <sfilipov> nomeata: I want to create a Map. I have a NoImplicitPrelude and I import ClassyPrelude (which exports CorePrelude).
11:12:55 <nomeata> sfilipov: what map do you want to create? an empty one? a singleton? from a list?
11:13:26 <sfilipov> Let's say a singleton, I don't mind an empty one as well
11:13:35 <nomeata> empty one should probably simply be mempty
11:14:58 <nomeata> and you could combine them with <>..., and it provides "asMap" to force a type to that of a map
11:15:27 <nomeata> but indeed, I also cannot find a way to create a singleton
11:16:47 <sfilipov> "asMap $ mempty" does work indeed
11:17:39 <sfilipov> According to this article: http://www.yesodweb.com/blog/2013/01/so-many-preludes the thing I am trying to do should be as simple as "people = asMap $ singleton "Michael" 28"
11:18:13 <sfilipov> Thanks everyone, that was helpful.
11:20:56 * hackagebot typelevel 1.0.2 - Useful type level operations (type families and related operators).  https://hackage.haskell.org/package/typelevel-1.0.2 (danilo2)
11:22:59 <nomeata> sfilipov: but where is singleton defined?
11:23:17 <nomeata> sfilipov: or did you have to import it after all?
11:26:29 <lpaste> sfilipov pasted “Create a singleton map using ClassyPrelude” at http://lpaste.net/143710
11:26:39 <sfilipov> OK, I have a solution. Package "mono-traversable" exports the function singletonMap. It can be used as follows: http://lpaste.net/143710
11:27:55 <shachaf> Data.Map also exports the function singleton.
11:28:02 <sfilipov> I get it now. The point is - you only import ClassyPrelude, no imports of Data.Map or anything from containers. Then you should use the functions from Data.Containers (from mono-traversable).
11:28:08 <shachaf> M.singleton "myKey" "myValue"
11:28:23 <shachaf> Much simpler than a bunch of ad-hoc type classes.
11:28:46 <glguy> shachaf: You might be optimizing for a different metric
11:28:55 <shachaf> Probably.
11:29:08 <sfilipov> shachaf: You are right. But you need to do "import Data.Map as M" in all files. The point of ClassyPrelude is that you only import that. Whether that is better solution is debatable but at least I understood how to create data structures using classy-prelude.
11:30:50 <WarzoneCommand> Does anyone know an altnernative to Data.Map that implements join in O(log n) time? (i.e. given two maps L and R, with max_{(x,_) \in L} < min_{(y,_) in R}, create a new map with the keys/values from both L and R? 
11:31:23 <monochrom> for reasons of intentional name clash, you are meant to use "import qualified Data.Map as M" (replace M by your favourite name) and "import Data.Map(Map)"
11:31:30 <Zemyla> WarzoneCommand: You could try making one using Data.FingerTree.
11:33:02 <WarzoneCommand> hmm yes, true. But I was hoping for an existing implementation 
11:33:19 <mjhoy> :r
11:34:04 <WarzoneCommand> (tbh: such a function should just go in Data.Map as well)
11:35:26 <glguy> WarzoneCommand: Do you have any reason to believe that Data.Map.union performs this operation slowly?
11:39:44 <WarzoneCommand> glguy: considering that it does hedge-union it is O(n+m), and I want O(log n) 
11:40:00 <glguy> O(n+m) is the worst case runtime for an arbitrary input
11:40:41 <glguy> Do you also know that hedge union works in O(n+m) time on your particular input?
11:41:10 * hackagebot deepcontrol 0.4.1.0 - Provide more deeper level style of programming than the usual Control.xxx modules express  https://hackage.haskell.org/package/deepcontrol-0.4.1.0 (KONISHI_Yohsuke)
11:42:11 <WarzoneCommand> I don't have a particular input in mind. But let me check the implementation and see if it would give O(log n) for separated sets 
11:48:34 <ReinH> WarzoneCommand: you had a particular constraint on the input in mind
11:48:38 <lpaste> glguy pasted “benchmarking union with overlapping and separated inputs” at http://lpaste.net/143716
11:49:24 <ReinH> glguy: you need three points to make a curved line :p
11:49:56 <ReinH> Although logarithmic performance might not be different from linear in a statistically significant way for those sample sizes, etc
11:50:20 <wiskirz> hello
11:50:28 <ReinH> It certainly looks like disjoint union is much, much faster though
11:50:44 <glguy> I'm not trying to prove any particular bound, the numbers are still interesting
11:51:01 <glguy> and we can see that disjoint maps union very quickly
11:51:08 <ReinH> yep
11:51:11 * hackagebot deepcontrol 0.4.1.1 - Provide more deeper level style of programming than the usual Control.xxx modules express  https://hackage.haskell.org/package/deepcontrol-0.4.1.1 (KONISHI_Yohsuke)
11:53:12 <dolio> It also happens to be a factor of 3.5 different, and the log of the size difference is 3.
11:54:10 <dolio> Whereas the overlapping case is a factor of 2000 different, which is on the order of the size difference.
11:54:16 <qmm> will people chim in their tips on writing maintainable, modular code in Haskell?
11:54:19 <qmm> s/chim/chime
11:55:02 <dolio> Size ratio, even.
11:55:58 <Ankhers> qmm: https://www.reddit.com/r/haskell/comments/2t4lba/haskell_design_patterns_extended_modules/ might be a decent start.
11:56:04 <qmm> at a Ruby shop, I once was told to keep your methods down to 2-3 lines, but sometimes about 5 lines was okay. i don't think this is terrible advice, but i don't think it's realistic advice especially in Haskell with where statements
11:56:18 <qmm> thanks Ankhers, I'll take a look
11:56:30 <WarzoneCommand> hmm seems HU is indeed sensitive tgo the input distribution 
11:56:53 <Ankhers> qmm: 5 lines is decent for Ruby. Though, I just found a 330+ line function here recently (also a Ruby shop)
11:57:20 <monochrom> with where statements, you count "f x = blahblah where {y = stuff; g z = foobar}" as 3 functions, not 1 function. therefore, it can have 3*3 lines, not just 3 lines.
11:57:44 <monochrom> perhaps s/function/binding/
11:58:19 <ReinH> dolio: good point
11:58:40 <monochrom> but I don't use "how long" to measure modularity
11:59:04 <ReinH> qmm: "method length" is used as a poor approximation of "method complexity"
11:59:24 <monochrom> every "how long" rule of thumb is a double-edged sword on modularity, if you include coherence in your definition of modularity
11:59:46 <monochrom> guess what, I don't use "how complex" either.
12:00:03 <Ankhers> :o 
12:00:21 <dolio> Just figure out the Kolmogorov complexity of each of your functions.
12:00:41 <ReinH> dolio: or the Shannon entropy :p
12:01:18 <qmm> it seems that modularity and maintainability are fuzzy terms
12:01:24 <ReinH> It sure does.
12:02:00 <ReinH> I think a lot of people take the Potter Stewart stance: I'll know it when I see it.
12:02:50 <qmm> Kolmogorov complexity seems like a decent way to tackle this problem
12:03:01 <monochrom> the reason "how long" can hurt modularity is this. you are going to artificially cut up a piece into 10 slides just because the piece is longer than your "how long" rule, even though they are so tightly coupled that they are conceptually one atomic piece.
12:05:02 <graycoder> i've chuckling about how people on freenode that have been the most helpful have names like "cornfeedhobo"
12:05:05 <qmm> oh, i was thinking of cyclomatic complexity. thanks for mentioning kolmogrov's work dolio 
12:05:13 <graycoder> shit
12:05:16 <graycoder> sorry guys
12:05:19 <graycoder> wrong chat
12:05:49 <ReinH> I'm reasonably certain that dolio was joking. Kolmogorov complexity doesn't resemble a human's notion of complexity.
12:06:21 <dolio> Also it's not computable.
12:06:24 <monochrom> it does to me.
12:07:09 <monochrom> and it agrees with the general phenomenon that most human notions are incomputable, too.
12:07:23 <ReinH> I meant for describing the complexity of software.
12:07:54 <ReinH> Because the complexity lies in some part at a meta level above the text itself or even the AST generated from the text.
12:09:42 <ReinH> It's pretty easy for shorter code to be more complex.
12:10:45 <ReinH> For an obvious example, compare (f .) . g with \x y -> f (g x y)
12:14:49 <johnw> anelson: hi!
12:16:26 <nolrai66> hi?
12:16:57 <ReinH> yes, hi
12:17:12 * johnw responds to pings when ZNC shows them to him :)
12:18:39 <SrPx> should I use  all uppercase for acronyms or mixed case?
12:19:06 <johnw> all uppercase typically
12:19:39 <SrPx> okay ty
12:19:50 <SrPx> asking because google's guideline says otherwise - I found it weird
12:20:55 <ReinH> It's almost like google doesn't have a lot of experience writing idiomatic Haskell
12:21:26 <ReinH> I wouldn't take google's guidelines as written in stone.
12:22:48 <obihann> I have a function that takes an integer and finds the divisors of it that fit within a range of numbers, I'm trying to write an additional function that accepts an integer, and take an integer, pass it to the first function, and then test the result if it is also within a specific range
12:22:53 <monochrom> no, both "always uppercase" and "always mixed case" are wrong.
12:22:58 <obihann> first function divisors n = [(x::Integer) | x <- [1..(n-1)], n `rem` x == 0, x <= 999, x >= 100]
12:23:07 <obihann> secondn match x = if x `div` (divisors(x)!!0) >= 100 then True else False
12:23:26 <obihann> my lack of knowdlege is throwing me of, because I know the second function should check for each divisor
12:23:33 <obihann> however I'm not sure how I would write that
12:23:55 <exio4> "if B then True else False" is the same as "B" 
12:24:21 <monochrom> example: BASIC --- Beginners All-purpose Symbolic Instruction Code --- began as an all-uppercase acronym. But after all these decades, it has become the mixed-case atomic word Basic, e.g., Visual Basic rather than Visual BASIC
12:24:53 <obihann> I'm wondering if I should create a new list, based on filtering the list that comes from divisors
12:25:05 <Ankhers> obihann: For the future, it is generally better to not paste code directly into IRC. You can use something like lpaste.net.
12:25:32 <obihann> Ankhers: thanks I'll keep that in mind :)
12:25:40 <obihann> Should I paste a link to my code?
12:25:40 <monochrom> the correct thing to do is neither "butcher to all caps" nor "butcher to mixed case". the correct thing to do is "preserve what we actually use"
12:26:01 <Ankhers> obihann: Also, using `!!` is unsafe.
12:26:22 <Ankhers> Which may not always be a problem if you are being safe with it.
12:26:27 <obihann> thats just a placeholder for now, because I know at that point I should be doing something recursive
12:26:56 <obihann> I'm thinking though of taking the list that I get from recursive and creating a new set that will filter each of the values
12:30:04 <monochrom> obihann: consider "all" from Prelude. or if you want to do it yourself, write a recursion function that takes a list and answers "whether all number in the list are in range"
12:32:32 <obihann> monochrom: I've not used all before, I'll look into it
12:32:57 <obihann> I was trying to write it myself but am not very skilled at lists and recursion yet
12:33:20 <Ankhers> :t all
12:33:21 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
12:33:58 <Ankhers> > all even [2,4,6,8]
12:33:59 <lambdabot>  True
12:34:01 <Ankhers> > all even [2,4,6,8,9]
12:34:02 <obihann> so that will return true if all or true, false if 1 or more is false?
12:34:03 <lambdabot>  False
12:34:06 <obihann> k
12:34:07 <obihann> thanks
12:34:14 <obihann> lambdabot: I love you
12:34:20 <Ankhers> Similarily, there is any
12:34:46 <Ankhers> which returns True if 1 or more of the elements return True for the function.
12:35:52 <t0by> Stupid question: how can I enter a multiline statement at the GHCI prompt?
12:36:03 <t0by> ( stuff...
12:36:06 <t0by>  ... other stuff)
12:36:11 <t0by> does't seem to work
12:36:44 <monochrom> begin with :{  end with :}
12:37:59 <t0by> monochrom, it doesn't seem to be working for me. any gotchas?
12:39:26 <t0by> monochrom, e.g. :{ [1, \n 2] :}         ==>     unknown command ':{'
12:39:56 <Ankhers> t0by: :{\n [1, \n 2] \n :}
12:40:12 <Ankhers> :{ and }: need to be on their own lines.
12:40:37 <t0by> in the immortal words of hugh grant, "oopsiedaisy".
12:40:43 <t0by> Thanks Ankhers, monochrom.
12:41:12 * hackagebot cabal-macosx 0.2.3.1 - Cabal support for creating Mac OSX application bundles.  https://hackage.haskell.org/package/cabal-macosx-0.2.3.1 (dfrancesconi)
13:02:45 <amf> whats the best tool / method to auto fix all the indentation? my files have a mix of indentation amounts and id like to normalize them all out
13:03:39 <mgsloan> amf: https://github.com/chrisdone/hindent
13:05:04 <amf> mgsloan: perfect!
13:05:40 <breadmonster> Does SPJ ever show up here?
13:05:47 <monochrom> no, I think not
13:06:01 <bitemyapp> breadmonster: no
13:06:08 <dolio> He's been in #ghc a couple times, I think.
13:06:26 <monochrom> Simon Marlow yes, as JaffeCake, but not often since joining Facebook.
13:06:50 <dolio> A couple times in like a decade, that is.
13:06:53 <monochrom> Facebook is a time sink for both users and implementers :)
13:07:06 <c_wraith> He's definitely in #ghc more frequently 
13:07:53 <monochrom> the climax of capitalism. the unbounded mutual positive feedback of demand and supply.
13:08:34 <bitemyapp> dolio: what was his nick?
13:08:43 <dolio> simonpj, I think.
13:09:34 <horrid> does anyone know of a library that makes haskell mutable and imperative?
13:10:20 * monochrom grins
13:10:29 <dolio> base
13:10:35 <c_wraith> horrid: there's a type in the base package called IO. It might be what you want. 
13:10:38 <breadmonster> horrid: Check out the IO monad.
13:10:49 <monochrom> https://hackage.haskell.org/package/BASIC makes Haskell mutable and imperative
13:11:09 <horrid> yeah but monads are so confusing
13:11:45 <c_wraith> Fortunately, you can ignore monads and just use IO
13:11:54 <monochrom> read my http://www.vex.net/~trebla/haskell/IO.xhtml to decrease confusion
13:11:58 <horrid> what if I want to execute some asm I've been working on
13:12:02 <horrid> can I make that a monad
13:12:24 <monochrom> then you need way more than IO. you need FFI.
13:12:46 <c_wraith> Depends on the representation. Being a monad isn't very important, though. 
13:12:47 <monochrom> Haskell doesn't have an "inline these asm code" construct.
13:13:25 <monochrom> it only has "call an externally written procedure" construct
13:14:20 <horrid> I can deal with that. I'll just write all my asm to a string and have haskell convert it into machine code and call that
13:14:37 <ReinH> ...
13:14:51 <ReinH> How do you plan on doing that?
13:14:51 <monochrom> ok, mauke may have an example, but I forgot the url
13:15:14 <monochrom> also, don't use string, use bytestring
13:15:20 <c_wraith> I hate to mention it, but there is that llvm package that converts llvm ir to IO actions. 
13:15:38 <monochrom> string is not going to be good for binary code like this
13:15:50 <horrid> well the asm code is a string
13:15:50 <Ankhers> Where can I find current information on any changes that are proposed or planned for Haskell's record changes?
13:15:57 <horrid> the machine code will of course be binary
13:16:06 <monochrom> oh, I see
13:18:05 <obihann> I
13:18:31 <obihann> I'm trying to memozie a function that checks if a string is a palindrome, however the map is throwing me off https://bpaste.net/show/48c77a6e19eb
13:18:58 <obihann> I've memoized funcions before that deal strictly with integer -> integer howver string -> bool seems different to memoize for some reason
13:23:10 <sm_> obihann: it should be same in principle. This code doesn't make sense though
13:23:29 <Ankhers> obihann: `if reverse(x) == x then True else False` is the same as just using `reverse(x) == x`
13:24:02 <Ankhers> You also appear to be trying to reverse an Integer, which shouldn't work.
13:24:16 <Ankhers> Unless you wrote your own reverse function.
13:25:01 <obihann> deffinitly not an int, that is a mistake on my part, should be "9009" not 9009
13:25:11 <obihann> "9009" is just a simple example I thought of
13:25:23 <obihann> and good to know that I can optomize that line a lot, makes sense now
13:25:41 <Ankhers> but using [0..] will create a list of Integers.
13:25:46 <Ankhers> Or some Num type anywas.
13:26:13 <obihann> since I am usint string should it be [""..]
13:26:20 <obihann> that doesn't seem right
13:26:51 <Ankhers> :t (!!)
13:26:54 <lambdabot> [a] -> Int -> a
13:27:07 <obihann> cleanup -> https://bpaste.net/show/7a9596731e3f
13:27:10 <Ankhers> Your function is also expecting an Int.
13:27:26 <Ankhers> > [""..]
13:27:29 <lambdabot>      No instance for (Enum [Char])
13:27:30 <lambdabot>        arising from the arithmetic sequence ‘"" .. ’
13:27:30 <lambdabot>      In the expression: ["" .. ]
13:27:41 <sm> obihann: you should use ghci to see if your examples typecheck, that will guide you
13:27:53 <obihann> I will look into that thnanks!
13:28:12 <obihann> so drop !! and use [""..
13:28:13 <obihann> ]
13:28:23 <Ankhers> [""..] does not work.
13:28:49 <obihann> so what I need is to create a map of strings, correct?
13:29:23 <Ankhers> I'm not entirely sure what it is you need to do. What are you trying to accomplish with this function?
13:29:40 <Ankhers> test if something is a palindrome? create a list of palindromes?
13:29:45 <kazagistar> You can always try out https://hackage.haskell.org/package/tuple-gen-2.0/docs/Data-Tuple-Enum.html
13:30:14 <obihann> the function tests if something is a palindrome
13:30:18 <obihann> I am trying to serialize it
13:30:28 <obihann> because I will be testing numeric palindromes
13:30:32 <sm> memoize it, you mean
13:30:35 <obihann> I could test the same number multiple times
13:30:36 <obihann> yes
13:31:06 <obihann> I guess I could change ti to accept a integer then use show to convert it
13:31:28 <sm> try to do it by hand in ghci, in small steps
13:31:38 <Ankhers> (!!) is used for list indexing.
13:31:56 <Ankhers> [1..10] !! 5
13:32:00 <obihann> thanks
13:32:01 <Ankhers> > [1..10] !! 5
13:32:01 <kazagistar> obihann: is this an Euler problem, and if so, which one?
13:32:02 <lambdabot>  6
13:32:40 <obihann> 4 actually
13:32:45 <obihann> and yes its euler
13:33:10 <obihann> you must get a lot of people trying to use haskell to solve euler
13:33:30 <kazagistar> some, but also I am just fairly familiar with them
13:34:21 <kazagistar> not sure which one this is exactly is all
13:34:38 <martinvlk> Hi, setting up a project to work with Euterpea, using stack as my project management tool. All installed fine, but my executable fails to link on pthread package with this error: undefined reference to symbol 'pthread_create@@GLIBC_2.2.5' .. libpthread.so.0: error adding symbols: DSO missing from command line. Would anyone has a pointer on what to do?
13:36:19 * hackagebot copilot-core 2.2.0 - An intermediate representation for Copilot.  https://hackage.haskell.org/package/copilot-core-2.2.0 (LeePike)
13:39:21 <NHRR> Hi ! I want to share with you with I've discovered recently - an app better than skype or whatsapp + you can earn free money by using it - https://www.wowapp.com/w/naheer/join
13:39:32 --- mode: ChanServ set +o glguy
13:39:33 --- mode: glguy set +b *!*@188.26.240.168
13:39:33 --- kick: NHRR was kicked by glguy (NHRR)
13:40:29 <voidzero> free moneyyyyyyyyyyyy \ooo/
13:40:33 <voidzero> tnx glguy 
13:41:34 * hackagebot copilot-sbv 2.2.0 - A compiler for CoPilot targeting SBV.  https://hackage.haskell.org/package/copilot-sbv-2.2.0 (LeePike)
13:45:15 <Guest80049> How would you go about converting a list eg [1,1,2,3,4,5,5,6] unto a tuple which has the elements then the occurences eg [(1,2),(2,1),(3,1)(4,1)(5,2),(6,1)]?
13:45:17 --- mode: glguy set -o glguy
13:46:35 * hackagebot copilot-language 2.2.0 - A Haskell-embedded DSL for monitoring hard real-time  distributed systems.  https://hackage.haskell.org/package/copilot-language-2.2.0 (LeePike)
13:47:56 <kazagistar> Guest80049: sort, group, and count
13:51:24 <kazagistar> :t (head &&& length) . group . sort
13:51:25 <lambdabot> Ord a => [a] -> ([a], Int)
13:51:38 <kazagistar> er, thats not quite right
13:51:42 * hackagebot copilot-c99 2.2.0 - A compiler for Copilot targeting C99.  https://hackage.haskell.org/package/copilot-c99-2.2.0 (LeePike)
13:52:25 <kazagistar> > let counted = map (head &&& length) . group . sort in counted [1,1,2,3,4,5,5,6]
13:52:28 <lambdabot>  [(1,2),(2,1),(3,1),(4,1),(5,2),(6,1)]
13:52:46 <glguy> This must be today's homework
13:52:55 <ggole> It's from that 99 problems thing
13:53:27 <kazagistar> well, either way, if you hand in homework using Arrow syntax, teach will be suspicious :P
13:54:02 <Guest80049> well it is for university but I'm having a really hard time understanding haskell
13:54:10 <Guest80049> it just seems so foreign
13:54:20 <ggole> That's half the fun.
13:54:29 <kazagistar> I am sure my example didn't help with that <_<
13:54:37 <monochrom> no, that's a half-empty half-full cup
13:54:49 <Guest80049> i'm using learnyouahaskell but its not really helping a lot
13:54:54 <Guest80049> are there any other good resources?
13:55:04 <horrid> The best description I've heard is that a haskell program is just a pipe you put data through
13:55:08 <glguy> Is the class teaching Haskell?
13:55:10 <monochrom> does your class say which books to read?
13:55:39 <Guest80049> Real world haskell
13:55:48 <Guest80049> and haskell the craft of functional programming
13:56:21 <monochrom> ok, spend most of your time on haskell the craft of functional programming
13:56:51 <Guest80049> does haskell just click at one point?
13:56:55 <tommd> Yes
13:57:00 * hackagebot copilot-cbmc 2.2.0 - Copilot interface to a C model-checker.  https://hackage.haskell.org/package/copilot-cbmc-2.2.0 (LeePike)
13:57:02 <horrid> ehh
13:57:16 <horrid> it didn't for me, it's been sort of slow
13:57:23 <monochrom> real world haskell is a short whirlwind tour of the language itself followed by many chapters on advanced libraries that assume you are fluent in Haskell
13:57:30 <tommd> It's not a sudden click - it is a gradual understanding.  But at some point Haskell does just make sense to you.
13:57:44 <JagaJaga> How are exceptions are connected to types if there is no mention in the type of a function about it? I mean how does catch "catches" error that is thrown? Or it's not a pure action?
13:58:24 <Zekka> JagaJaga: The dirty secret: for usability reasons a Haskell function is allowed to nonterminate without signaling that in its type
13:58:28 <tommd> JagaJaga: All types include bottom.
13:58:31 <monochrom> catch is not a pure function
13:58:50 <monochrom> look at the type of catch. it ends in IO a. that tells you a lot.
13:59:05 <Zekka> (that's because taking a turing-complete language like Haskell and adding termination-checking would require the halting problem)
13:59:23 <Zekka> As far as pure code is concerned, exceptions are just another way to nonterminate
13:59:30 <monochrom> also, exceptions are not connected to types
13:59:44 <Zekka> But for cheaty IO code, they additionally let you do something about the nontermination instead of jut freezing your program
14:00:04 <martinvlk> Guest80049: go for this book: http://haskellbook.com/, it's the most accessible to non-Haskellers and non-academics of them all.
14:00:33 <JagaJaga> I can't understand :( If exception is returned, it doesn't have the type a, it is IOError (for example). How does catch handles that?
14:00:52 <Zekka> No, it's not returning an exception
14:01:09 <JagaJaga> Zekka: so what is the transfer mechanism?
14:01:15 <Zekka> JagaJaga: Exceptions are a transfer mechanism
14:01:44 <Zekka> After the exception happens, Haskell skips all your non-IO code and rises into IO to see if they catch it
14:02:00 * hackagebot copilot-libraries 2.2.0 - Libraries for the Copilot language.  https://hackage.haskell.org/package/copilot-libraries-2.2.0 (LeePike)
14:02:06 <Zekka> It's not a language feature used for things other than exceptions
14:03:03 <JagaJaga> Zekka: so it's a some kind of backdoor?
14:03:33 <Zekka> It's pretty much what I said it was, which I guess you could call that
14:04:17 <JagaJaga> Zekka: thank you
14:04:40 <Zekka> No problem, besst of luck
14:04:56 <monochrom> the control flow of exception throwing and catching is built-in. and yes it is control flow because it is in IO.
14:06:07 <monochrom> i.e. if you are still stuck in the pure picture, there is no such thing as control flow. therefore don't stick yourself in the pure picture. the exception mechansim of Haskell is emphatically in IO.
14:06:42 <monochrom> and it is the same control flow alteration as in Java and C++
14:07:36 <JagaJaga> monochrom: thank you for your explanation
14:08:26 <kazagistar> If you want to handle exceptional cases in pure code, Either is a good solution
14:10:22 <JagaJaga> kazagistar: no, I'm exploring IO Exceptions
14:11:34 <SrPx> What is the shortest way to convert an unboxed Vector of Word8s to Base64? If no direct algorithm available, how do I convert a Vector to ByteString?
14:12:36 <bitemyapp> SrPx: how'd you end up with a Vector of Word8?
14:13:43 <Lokathor> so a computation for a Conway's Game of Life sort of situation
14:13:49 <Lokathor> cellular automata
14:13:53 <SrPx> bitemyapp: pardon?
14:14:05 <Lokathor> not quite a normal use of functor
14:14:28 <bitemyapp> Lokathor: comonad
14:14:31 <bitemyapp> SrPx: http://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString.html#v:pack
14:14:44 <SrPx> Oh, just noticed a "unpack" function. I was looking for fromList/toList. My bad. 
14:15:15 <SrPx> Yep. I hoogled the wrong thing, too. My faul.
14:15:21 <oldmanmike> Would anyone recommend a specific library for generating RSA keypairs?
14:15:54 <Lokathor> bitemyapp, not familiar. I was thinking that you could fmap a partially applied function like, nextGen :: Set Location -> Location -> CellType
14:16:19 <Lokathor> applying the previous generation gets you Location -> CellType
14:16:55 <Lokathor> fmap (nextGen oldGen) locations --> newGen
14:17:14 <bitemyapp> Lokathor: http://blog.emillon.org/posts/2012-10-18-comonadic-life.html http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html https://github.com/gelisam/conway http://www.slideshare.net/davidoverton/comonad
14:17:19 <bitemyapp> Lokathor: Comonad.
14:17:37 <Lokathor> that's quite the number of links
14:18:02 <cocreature> also https://www.fpcomplete.com/user/edwardk/cellular-automata
14:18:21 <Lokathor> an embarassment of resources
14:18:48 <bitemyapp> Lokathor: http://chrisdone.com/posts/twitter-problem-loeb#update-with-comonads-pointed-lists further fuckery
14:19:55 <Lokathor> i saw that twitter problem before
14:20:49 <Lokathor> (=<<) :: (a -> m b) -> m a -> m b
14:20:55 <Lokathor> aren't the arrows backward on this one?
14:21:32 <Lokathor> oh it's the reverse argument one
14:22:01 * hackagebot copilot 2.2.0 - A stream DSL for writing embedded C programs.  https://hackage.haskell.org/package/copilot-2.2.0 (LeePike)
14:22:28 <monochrom> yes, putStrLn =<< getLine
14:23:06 <bitemyapp> Lokathor: http://hackage.haskell.org/package/slave-thread
14:23:49 <Lokathor> bitemyapp, was that... for someone else maybe?
14:24:12 <bitemyapp> sigh.
14:24:14 <bitemyapp> yes.
14:24:15 <bitemyapp> h/o
14:24:23 <bitemyapp> Lokathor: https://github.com/kwf/ComonadSheet/blob/master/Presentation/presentation.md
14:25:16 <Lokathor> okay that's litearlly 7 pages. is there a best ordering to these pages?
14:25:31 <bitemyapp> no pedagogy here bro
14:25:42 <bitemyapp> I'm just tossing you stuff like I do others.
14:25:59 <bitemyapp> choose the articles most local to what you were originally thinking about.
14:26:49 <Lokathor> every time someone says "pedagogy" i wonder if there's some secret reason they didn't use the word "teaching" (or variant) instead
14:27:14 <bitemyapp> Lokathor: 'tis a sekrit.
14:30:21 <Lokathor> if i'm making a 2d space, and i need to perform many many updates to it before it becomes relatively finalized
14:30:41 <monochrom> mutable vector :)
14:30:44 <Lokathor> is there some data structure that'd be particularly better suited than just using a set?
14:30:49 <Lokathor> ah, see i thought so
14:31:32 <monochrom> you can use an immutable map, but I don't know how fast you want it.
14:31:46 <monochrom> or rather, how slow you will accept
14:32:11 <Lokathor> it'd be for random level generation, so doesn't need to run toooo fast, since levels are generated relatively infrequently
14:32:28 <Lokathor> and the 2d space would probably be less than 256x256
14:32:31 <monochrom> but I wouldn't shy away from mutable array. it is ok because you can still get a lot of protection from ST.
14:32:53 <Lokathor> ah, I take it ST is somehow not a StateT?
14:33:43 <bitemyapp> Lokathor: yeah if you can stage updates into one big block and then freeze it you have a lot of nice options.
14:33:50 <Lokathor> my random number rolling is a lot of things like, rollxdy :: (RandomGen g) => Int -> Int -> State g [Int]
14:34:07 <Lokathor> so i was thinking i'd end up with a funciton that produces a State g Dungeon at the end
14:35:27 <kazagistar> Lokathor: ST is IO's little brother… you can use mutable data structures inside, and then "close" it into an immutable one at the end
14:35:37 <Lokathor> eg: makeCaves :: (RandomGen g) => Int -> Int -> State g Dungeon  with width and height as inputs
14:36:00 <Lokathor> interesting
14:36:44 <Lokathor> yes, after the initial generation i expect that it would be "possible, but rare" for terrain changes as a result of game effects
14:36:58 <lethjakman> Hey, does anyone have any experience with the haskell-interactive-mode in emacs? 
14:37:12 <lethjakman> Whenever I enable it I just can't press enter anymore
14:37:36 <lethjakman> I want the type definition tool so I can see the type of whatever I'm sitting on. 
14:41:55 <monochrom> I have more than one year of uneventful experience of haskell-interactive-mode working fine out of the box.
14:42:02 * hackagebot copilot-theorem 2.2.0 - k-induction for Copilot.  https://hackage.haskell.org/package/copilot-theorem-2.2.0 (LeePike)
14:42:29 <monochrom> in other words I have 0 seconds of experience trouble-shooting problems because I never ran into one and I did nothing special.
14:42:31 <Lokathor> monochrom, do you use stack-ghci as your repl mode? I've had some trouble trying to set that up
14:42:35 <monochrom> no
14:43:43 <kallisti> so when I was looking at the GHC mergesort implementation yesterday, I noticed that the comments mention it being stable. I got a bit of a chuckle out of that, because semantically it makes no difference whether it's stable or unstable.
14:43:55 <monochrom> the moral of the story is that when someone cites "I have 10 years of experience" it is pretty informationless. 10 years of having seen it all? 10 years of run of the mill?
14:43:57 <kallisti> but now I'm curious if it actually has a real operational consequence
14:44:09 <kallisti> maybe GC behavior?
14:45:32 <monochrom> it has a semantic significance when your Eq is not equality
14:47:02 * hackagebot propellor 2.12.0 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-2.12.0 (JoeyHess)
14:47:12 <kallisti> true
14:48:25 <Lokathor> bitemyapp, before i read too far, can this comonad version of cellular automata be made parallel do you know?
14:48:31 <kallisti> if it's not... structural equality? representational equality? what's the word here.
14:48:58 <monochrom> I use neither. I use observable equality.
14:49:03 <bitemyapp> Lokathor: *ponders*
14:49:22 <Lokathor> because i imagine a version that's a crazy suped up form of map could be turned into a parMap
14:49:51 <kallisti> well, Eq could be an equivalence relation, but not over the entire structure of the data
14:49:57 <kallisti> and then the stability of the sort matters
14:50:08 <kallisti> so in some sense Eq is still "equality" in that case, right?
14:50:11 <bitemyapp> Lokathor: I mean, maybe? But if want parallelization, just write the obvious thing initially.
14:50:23 <bitemyapp> kallisti: you're not really supposed to use Eq for equivalence relations.
14:51:07 <bitemyapp> Lokathor: http://www.cl.cam.ac.uk/~dao29/publ/ypnos-damp10.pdf this touches on it, but is getting far afield of what you wanted to do.
14:51:13 <Lokathor> bitemyapp, yeah, I was going to pick cellular automata first over a BSP tree or other dungeon gen because i thought it'd be interesting to compute the cell of each next gen in parallel
14:51:48 <monochrom> that is a special case of x==y but you can still observe differences between x and y. this means you can write a function f such that f x /= f y
14:52:48 <Lokathor> maybe what you want is closeTo :: (Kinda k) => k -> k -> Bool
14:52:51 <monochrom> but then, "you can" depends on how much access you have on the data type
14:52:57 <Lokathor> but you'd have to make that up
14:54:07 <monochrom> here is a daily example that really scares you (because it's a daily example that you have always used but never thought over, like your neighbour you greet every morning turns out to be a vampire stalking you)
14:54:49 <monochrom> GHC's implementation of Integer goes like "data Integer = A Int# | B <byte array>".
14:55:49 <monochrom> the idea is that for small numbers let's go machine's basic and fast Int#, for large numbers use a huge byte array and give it to libgmp
14:56:44 <monochrom> an implementer can observe the difference between A 3# and B <an array that holds 3>. a user cannot.
14:57:04 <monochrom> now sort [Integer] by an unstable sort algorithm
14:57:42 <monochrom> a user will find it stable because the user does not have enough access to write a function to tell the difference.
14:58:06 <monochrom> a GHC dev will find it unstable because the GHC dev has access to A and B.
14:58:44 <monochrom> this cannot possibly be explained by false dichotomies such as "structural equality", "representational equality", etc.
15:00:27 <monochrom> anyway, wish you a happy Halloween!
15:01:23 <bitemyapp> monochrom: spooOOOoooOoky
15:03:07 <kallisti> so we have () as a single-valued type, Bool as a two-valued type, Order and Maybe Bool as three-valued types. All of these types have generally useful properties. What's a four-valued type and what would an application for it be?
15:04:28 <monochrom> (Bool, Bool) is a four-valued type
15:05:28 <monochrom> it is important for representing, in the Prisoner's Dilemma, the decision made by the pair of friends
15:05:32 <kallisti> I suppose Maybe Ordering would be useful as well, for a partially ordered set?
15:06:13 <kallisti> yeah I use (Bool, Bool) pretty frequently to collapse case expressions when doing nested boolean logic and such.
15:06:35 <kazagistar> data Direction = North | East | South | West
15:07:42 <kazagistar> just thought I would provide the "flat" option
15:09:34 <kallisti> ah yes the unit vectors of fungespace. :)
15:10:03 <kazagistar> challenge question: rationalize a use case for Maybe (Maybe (Maybe ()))
15:10:32 <kazagistar> the "linked list" version of the 4 value type
15:10:34 <hpc> dealing with monad transformers
15:11:00 <monochrom> teaching and exams
15:11:04 <kazagistar> hpc: … I dont get it?
15:11:53 <hpc> it's easy to find yourself in a situation with monad transformers (especially when writing generic code) where you need to make some weirdly nested values to make things work
15:12:26 <hpc> and instantiated for Maybe, that kind of thing could come up
15:13:01 <joehillen> I lost some faith in Haskell today https://www.reddit.com/r/haskell/comments/3pylic/records_with_different_fields_for_its/
15:13:41 <hpc> it is known
15:13:50 <hpc> record fields are projections
15:13:58 <joehillen> not even a warning though?
15:13:59 <monochrom> I recommend having no faith, for all languages, to begin with. programming languages are not meant to be religions.
15:14:19 <joehillen> monochrom: I thought someone would say something like that
15:14:22 <hpc> it's not that big a deal
15:14:33 <hpc> writing a record with multiple constructors is enough of a red flag imo
15:14:50 <hpc> maybe a future ghc will warn for it
15:15:03 <joehillen> hpc: the compiler accepted the code, I ran it. it cause a run-time failure. It is a big deal
15:15:04 <monochrom> I recommend the cold-blooded calculating utilitarian view.
15:15:21 <hpc> joehillen: it's not hard to make runtime errors in haskell ;)
15:15:36 <joehillen> hpc: true, but it should be harder than this
15:16:48 <joehillen> the number of tribally known "donts" is growing to dynamic language proportions
15:17:03 * hackagebot tidal 0.6 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-0.6 (AlexMcLean)
15:17:05 * hackagebot secp256k1 0.2.0 - secp256k1 bindings for Haskell  https://hackage.haskell.org/package/secp256k1-0.2.0 (xenog)
15:18:52 <monochrom> join the Haskell Prime committee, or talk to a person who joins, so that you can voice your concern, and also hear the opposing concern.
15:20:18 <joehillen> I'm actually thinking about writing a patch for GHC to add a warning about this. On the other had, there must be a reason that warning doesn't already exist
15:20:25 <joehillen> but I can't think of a good one
15:21:10 <bitemyapp> joehillen: it's been known for awhile that you're not supposed to expose record accessors in a sum type.
15:21:22 <bitemyapp> joehillen: my coworker does sometimes, but he uses classy lenses to elide the danger involved.
15:21:34 <joehillen> if I'm not supposed to then, the compiler should tell me
15:22:02 <bitemyapp> joehillen: given how tightly people cling to head and read...good luck. I'd make it a compile error if I had my way. But nobody cares what I want :P
15:22:28 <bitemyapp> besides, it'd break a bunch of code.
15:22:35 <joehillen> as it should
15:22:39 <bitemyapp> and people are getting _very_ upset about even getting warned that their code is bad.
15:22:43 <joehillen> it's unsound
15:22:46 <Lokathor> so a functor in a functor is always still a functor?
15:22:47 <bitemyapp> it is. but here we are.
15:23:04 <bitemyapp> Lokathor: Functors and Applicatives, when composed, always give rise to something that is also a Functor or applicative, respectively.
15:23:04 <joehillen> this is hopeless. I should just go back to Python
15:23:05 <monochrom> I think I know why the warning doesn't exist. because most users don't even know that they can write this code. so they just don't write code like this. so no one actually does this risky thing, so no warning is demanded. the world is in good balance.
15:23:18 <bitemyapp> Lokathor: a Monad and a Monad can be composed, but you don't get another Monad for free.
15:23:31 <bitemyapp> Lokathor: thus...transformers and the many competitors nipping at its heels.
15:23:39 <joehillen> monochrom: hard to imagine for a language that's 20+ years old
15:23:44 <Lokathor> bitemyapp, do you have to use that Compose datatype you had in your talk ?
15:24:29 <lynnard> I know _Just lets me 'lens' into a Maybe value, is there a lens that allows me to focus on that inner value, but if there isn't one, use another one?
15:24:48 <lynnard> a bit like what 'maybe' does
15:25:30 <bitemyapp> Lokathor: it's wise to use some sort of datatype to signal intent here. There are probably other ways.
15:25:57 <johnw> lynnard: "non"
15:26:28 <johnw> let me find the right incantation...
15:27:07 <bitemyapp> johnw: nice library for feeling wizardly, yeah?
15:29:01 <Zekka> lynnard: Just remember, whatever research you have to do to figure out this trick is research anyone who has to maintain your code will have to do when they're reading it
15:29:35 <ReinH> Lokathor: Conor's answer is good http://stackoverflow.com/questions/7040844/applicatives-compose-monads-dont
15:30:57 <ReinH> bitemyapp, Lokathor: Of course, [[a]] is still a composition of [] and [], we just don't have a way in Haskell to represent that directly. It might be nice if you could say, e.g., ([] . []) a, although using (.) at the type level might be confusing.
15:31:32 <lynnard> johnw: is it the same as (to (maybe x id))
15:31:44 <Lokathor> ReinH, can't you use this https://hackage.haskell.org/package/transformers-0.4.3.0/docs/Data-Functor-Compose.html
15:31:50 <Lokathor> and make a Compose [] [] a
15:32:00 <ReinH> Lokathor: Yes, I mean without introducing a new contruction.
15:32:04 <Lokathor> ah
15:32:38 <ReinH> so that ([] . []) a was actually equivalent to [[a]]
15:32:55 <ReinH> (or rather, exactly the same as, modulo desugaring)
15:33:01 <Lokathor> well i kinda want to try the parallelism version, so i think i'll go the double list and double fmap route
15:33:04 <johnw> > (Just 2 :: Maybe Int) ^? _Just ^. non 10
15:33:07 <Lokathor> instead of the comonad and zipper route
15:33:08 <lambdabot>  2
15:33:09 <johnw> > (Nothing :: Maybe Int) ^? _Just ^. non 10
15:33:14 <lambdabot>  10
15:33:14 <ReinH> Lokathor: of what?
15:33:34 <Lokathor> ReinH, ah, sorry, Cellular Automata cave generation
15:33:57 <lynnard> > (Just 2 :: Maybe Int) ^? _Just ^. to (maybe 10 id)
15:34:00 <lambdabot>  2
15:34:11 <ReinH> Lokathor: oh cool
15:34:22 <lynnard> > (Nothing :: Maybe Int) ^? _Just ^. to (maybe 10 id)
15:34:24 <lambdabot>  10
15:34:26 <ReinH> I want to try L-system cave generation now that I have a nice way to represent L-systems.
15:34:50 <johnw> yes, non just generalizes it, and so it also works nicely with other things like "at"
15:35:37 <Lokathor> this comonad stuff seems well suited to infinite 2d spaces
15:35:44 <Lokathor> but i just want a finite 2d space
15:35:53 <lynnard> hehe yes and also 'non' works as a Lens not just a Getter, I see
15:36:34 <ReinH> johnw: I really like being able to do:
15:36:35 <ReinH> > M.fromList [('a', 1)] & at 'a' . non 0 %~ subtract 1
15:36:37 <lambdabot>  fromList []
15:37:05 <monochrom> is that APL?  <duck>
15:37:06 <nocturne777> is this package reliable: https://hackage.haskell.org/package/uuid
15:37:14 <nocturne777> has anyone been using this in production?
15:37:47 <kazagistar> hmm
15:37:47 <Zekka> ReinH: Realizing that if most people saw that in code they would have no idea what it meant?
15:38:23 <lynnard> I had the great idea the other day about making a game about 'Lens' - players kill monsters to get basic lens and then compose and upgrade them to make more powerful ones - the point is that people get to learn it better
15:38:50 <Lokathor> learning games are one of the hardest to make
15:38:57 <Lokathor> unfortunately
15:39:04 <kazagistar> hmm, like, are the monsters hidden in progressively more complex data structures?
15:39:08 <kazagistar> that would be pretty cool
15:39:24 <lynnard> there is an online game about vim which is really quite cool - although I didn't learn it that way
15:39:33 <lynnard> kazagistar: that's a nice idea - feature request accepted
15:39:53 <kazagistar> "set the health of all the monsters living in this ST array to zero to move on to the next level"
15:40:14 <lynnard> with limited set of 'Lens' weapon
15:41:05 <kazagistar> well, I mean, you don't have to go too crazy with the theming if you really want to target programmers learning haskell
15:41:40 <Zekka> I don't think there would be a good reason to teach lenses to people who don't already know Haskell
15:41:58 <kazagistar> I mean, who have recently learned haskell, or something like that
15:42:07 <Zekka> they're kind of useless outside of haskell afaict and a lot of other language dudes have (imho pretty reasonably) eschewed them as too abstract when I showed them
15:42:16 <ReinH> lynnard: I have a unique set of skills, etc
15:42:45 <johnw> lynnard: as long as edwardk is the end boss, I'm in
15:43:14 <kazagistar> lynnard: well, sign me up for the beta, I am quite shaky at lenses
15:43:23 <Zekka> they're an extremely elaborate way to spend less time typing
15:43:39 <Zekka> (that is, hitting keys on the keyboard, not fighting with the type system. You will spend much more time fighting with the type system)
15:43:43 <lynnard> I also had the thought about visualizing the type system as slots which can connect into each other -- I feel the difficultest part for a newbie to swallow is the type
15:44:03 <lynnard> vs object-oriented languages which can give nice examples like People and objects
15:45:15 <lynnard> Zekka: well, I feel this is more like moving up some ladder - once you are familiar with a tool, you build on that tool and the old tool becomes second nature
15:45:40 <Zekka> When I was really into Haskell I had the same experience
15:45:57 <monochrom> "it is too abstract" changes over time, i.e., becomes more and more false.
15:46:02 <Zekka> Then I realized that a majority o the code I'd written recently was doing pretty commonplace things in a way that was totally unreadable for other people
15:46:15 <monochrom> just 200 years ago, most humans weren't even taught multiplication
15:46:44 <lynnard> hehe right, language specification always has that compromise - readability for other people vs feeling-goodness for the author
15:46:52 <kazagistar> Zekka: so you propose that Lens is to Haskell as Spring is to Java? :P
15:46:59 <Zekka> monochrom: It's still sensible to make claims like this: it is far more abstract to do an update in a deeply nested structure using a lens than just by following some pointers and making the change yourself
15:47:20 <Zekka> kazagistar: I still like Lens and think it's well-designed for its goals, but otherwise, sure
15:47:47 <Zekka> I don't see why for most problems a person should choose the purely FP language and the lensy update over the imperative language and the nonlensy update
15:47:49 <lynnard> compare Haskell vs Objective-C; the former lets the author do things in any way he desires - the later encumbers the author so as to make him sociable
15:47:58 <Zekka> because a big feature of good design is being as concrete as you can get away with imho
15:48:04 <monochrom> "far more abstract" is much weaker than "too abstract"
15:48:44 <monochrom> haskell is far more abstract than Turing machines (which I will be inflicting on poor students when I will be a TA next year).
15:48:51 <Zekka> There are people Lens isn't too abstract for, but most of the programmers I showed them to, including the ones who understood it, said that they didn't see a point in using something as abstract as Lens for what was trivial in the languages they were using
15:49:14 <monochrom> but I don't want to write a Turing machine. I prefer Haskell.
15:49:39 <Zekka> These are guys who are perfectly happy writing large imperative programs with densely nested data structures in C#
15:49:51 <Zekka> (C# is an example, anotehr guy uses C++, another Python, another Java)
15:49:51 <lynnard> Zekka: it depends on 'what' mental model you want to fit in - do you want to think in the way of a computer, or think as a functional programmer that builds up abstract stuff from immutable structures
15:50:03 <c_wraith> Zekka: I have never seen an equivalent of lens in any other language. It's way more than just record accessors. 
15:50:29 <lynnard> the pointer thing only becomes obvious because most people tend to think like a computer
15:50:32 <Zekka> c_wraith: Nor have I (to be clear, I used lens prettty extensively in the past and I'd say I know it fairly well) -- but the most common use case is nested record access imho
15:50:51 <lynnard> if you don't know anything about memory or hardware it isn't really that obvious
15:51:07 <Zekka> I don't think my friend are writing programs that justify using persistent data structures for anyhting and it makes a lot of what they're trying to do much more abstract
15:51:25 <Zekka> If they were trying to write something that used backtracking super intensely or something I might try harder to get them into Haskell, but I'm not convinced they have a good reason to care
15:51:50 <monochrom> I agree. so don't even tell them about Haskell.
15:51:58 <c_wraith> Zekka: I've never used lens for nested field access. 
15:52:22 <Zekka> I've actually got to go fwiw -- I feel bad because I think I said something ontentious and there are probably a lot of guys who would like to change my mind
15:52:31 <c_wraith> I use Traversals all the time, though. 
15:52:36 <Zekka> it's not "I have to go because I don't want to bew rong" but "I have to go because otherwise my kid cousin will fry in a minivan"
15:52:50 <Zekka> c_wraith: Yeah, for me traversals and prisms were the most common usecase that wasn't nested field access
15:53:07 <Zekka> And a lot of languages are still trying to reclaim that ground with null coalescing operators and things
15:53:20 <Zekka> it's less principled but it has the advantage that you don't need a slideshow to introduce people to it
15:54:10 <Zekka> c_wraith: I'll probably be on in less than an hour again, might be too early to chat
15:54:34 <rodlogic> a quick thought... would it be possible to create a servant like lib but for parsing? So that the same parser api could be used to generate emacs/vim/etc interfaces?
15:56:30 <monochrom> I have only found one use of lens, and it only uses the very basic "forall f. Functor f => (a -> f b) -> s -> f t". but it already exceeds the trivial "read or write a deep but statically known field".
15:56:32 <alpounet> rodlogic: hmm... there would be some problems with a type-level approach, I think. servant gets away because it only has to sum up information about an API up to some level. I'm not sure how much details you'd have to put there for generating whatever you need from that.
15:56:47 <monochrom> this is because I want to read and write a not-statically-known field.
15:57:45 <monochrom> namely, recall balanced binary search trees and the balancing algorithm, which is two algorithms in mirror images of each other.
15:58:11 <monochrom> how do you write just one copy to subsume the two mirror images?
15:58:41 <monochrom> my answer: parameterize over the notion of "left subtree" and "right subtree".
15:58:51 <monochrom> lens does that.
16:00:43 <rodlogic> alpounet: what if the syntax being parsed was constrained to some extent?
16:00:48 <monochrom> in other words, the unified algorithm does not statically know, at line 5 say, whether it is reading the left subtree or the right subtree. it only knows it reads the subtree determined by a lens parameter.
16:01:41 <monochrom> so, to be sure, yes, lens is overkill for trivially reaching a statically known field.
16:02:02 <monochrom> but try to reach a field determined by a parameter. you can't even do that in Java.
16:02:14 <monochrom> "first-class reference"
16:09:04 <monochrom> and this is another data point for how language limitations become mental limitations.
16:10:24 <monochrom> just two years ago, I thought it couldn't be parameterized, I thought there was no avoiding of writing two mirror images by hand. because two years ago, I had not heard of the idea of lens and I did not think that first-class reference could be a thing.
16:11:22 <monochrom> and even one year ago, after I had heard of lens, I still didn't think of applying it this way. it takes time to see the connection.
16:11:51 <lynnard> re lens: Is there a function for 'preview', as 'use' for 'view'?
16:11:54 <ReinH> monochrom: you can even, e.g., make a traversal out of targets that match a predicate.
16:12:04 <monochrom> by extrapolation, most of our Java friends will never think it can be done, in their whole lifetimes.
16:12:10 <lynnard> e.g., gets . preview
16:13:16 <mabgriff> I've got strange newbie question. Does the (\\) operator from Data.Set just not work in ghci for some reason? I'm getting type errors with the simplest of uses, like [1..10] \\ [2,4,9]
16:14:44 <mabgriff> Actually I'm getting type errors with everything from Data.Set, using example expressions from LYAH
16:14:58 <ReinH> mabgriff: well, [1..10] and [2,4,9] are not sets
16:15:08 <kazagistar> mabgriff: you are trying to use set operations on lists?
16:15:13 <ReinH> What example expressions are you using?
16:15:57 <mabgriff> [1..10] \\ [2,5,9]
16:16:18 <ReinH> mabgriff: Where in LYAH does that appear?
16:16:30 <RageD> mabgriff: See fromList (http://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Set.html#v:fromList)
16:17:13 <RageD> mabgriff: That said, I think you meant to import Data.List
16:17:15 <RageD> not Data.Set
16:17:27 <mabgriff> Oh jesus, hold on. I'm in the Data.List section of the book. I looked up the operator and saw that it was from Data.Set, not realizing there are conflicting name spaces.
16:17:29 <RageD> http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-List.html#v:-92--92-
16:17:39 <mabgriff> RageD: bingo. Well I feel sheepish.
16:17:44 <kazagistar> mabgriff: https://www.haskell.org/hoogle/?hoogle=%28\\%29
16:17:57 <ReinH> mabgriff: The (\\) that LYAH is using is from Data.List and operates on lists.
16:18:30 <RageD> mabgriff: It happens :)
16:18:34 <RageD> good luck
16:19:00 <ReinH> mabgriff: LYAH doesn't do a good job at all of making that clear
16:19:18 <mabgriff> Alright, well, thanks everybody :) that's a dumb error I won't make again (with the help of Hoogle, I now see the utility of that)
16:19:31 <RageD> ReinH: Well, it just doesn't provide any good intro/bg to hoogl'ing :)
16:19:54 <mabgriff> ReinH: It really doesn't. It was so far into the section I had totally lost track
16:35:44 <dolio> monochrom: But have you yet realized that there are dozens of random functions sprinkled through the standard libraries (and that people periodically propose adding) that can undergo the same treatment?
16:36:33 <dolio> And become a composable grammar instead of dozens of functions with a naming scheme.
16:37:35 <tpsinnem> hey, the discussion on this GHC ticket suggests that these days there's a way to tag 'where' blocks so that functions defined there get included for profiling. can anyone point me to documentation on this feature?
16:37:39 <tpsinnem> https://ghc.haskell.org/trac/ghc/ticket/5207
16:38:33 <tpsinnem> well it's stack traces that i'm interested in but anyway
16:39:34 <ReinH> tpsinnem: Well, you won't get a stack trace.
16:40:41 <tpsinnem> ReinH: i do get an imprecise stack trace if i've compiled with profiling enabled and run with +RTS -xc
16:41:02 <ReinH> The closest thing you can get is a list of cost centers
16:41:30 <ReinH> Or cost centres, as it were.
16:41:30 <monochrom> dolio: no, I think I haven't
16:41:37 <dolio> Oh.
16:42:05 <tpsinnem> but afaiu those skip where and let block definitions by default
16:43:03 <tpsinnem> ReinH: i mean, if i've compiled with profiling, and use errorWithStackTrace in the code
16:43:17 <monochrom> and this is all the more reason I like you guys inventing highly abstract things. I couldn't learn and think better otherwise. I am just as much a prisoner of language-limits-thought as the next Cobol programmer.
16:43:19 <tpsinnem> and run with xc
16:43:55 <ReinH> It's confusing to me that GHC describes this as a call stack, but I guess I should use the term if the GHC manual does.
16:44:50 <tpsinnem> ReinH: http://hackage.haskell.org/package/base-4.8.1.0/docs/GHC-Stack.html#v:errorWithStackTrace
16:44:55 <ReinH> Maybe "call stack" is better than an explanation of why it isn't a call stack.
16:45:24 <iffraff> I have a/some nube questions.  Is there anyone around can help me?
16:45:37 <tpsinnem> i'm fine with whatever it's called, i just want to get the info :)
16:45:59 <monochrom> it can be reasonably called a call stack, but you have to know what procedures are being called, which are different from the eager evaluation story
16:46:24 <dolio> monochrom: Well, we have isNothing, isJust, isLeft, isRight, fromJust, fromMaybe, maybeToList. And I've seen proposals for adding mapLeft, mapRight, traverseLeft, traverseRight. You could imagine leftToList, rightToList, ....
16:46:37 <kazagistar> just saying "go read about Spineless Tagless GMachines" could sound an awful lot like "go fuck yourself" haha
16:46:44 <monochrom> the procedures being called are usually "now is the time to evaluate that thunk, so call the procedure that does that evaluation"
16:47:35 <monochrom> kazagistar: I finally gave in and read that paper. I feel much better now. :)
16:47:49 <mabgriff> iffraff: I asked a really newbish question just a few minutes ago, everyone was very nice and helpful :)
16:47:54 * hackagebot MagicHaskeller 0.9.6.4.5 - Automatic inductive functional programmer by systematic search  https://hackage.haskell.org/package/MagicHaskeller-0.9.6.4.5 (SusumuKatayama)
16:48:03 <dolio> But, instead, you can have `is`, `from`, `toListOf`, `over` (map), and `traverseOf`. And have `_Just`, `_Nothing`, `_Left`, `_Right`.
16:48:09 <ReinH> monochrom: which paper?
16:48:16 <tpsinnem> so, does anyone know how to use this 'where' block SCC pragma thing?
16:48:23 <tpsinnem> https://ghc.haskell.org/trac/ghc/ticket/5207
16:48:24 <kazagistar> monochrom: I found it very interesting and useful, but my point stands :P
16:48:25 <monochrom> anyway, since the procedures called are usually "to evaluate that thunk", you can better say "evaluation stack". but "call stack" is still true.
16:48:30 <monochrom> the STG paper
16:49:01 <monochrom> yes, it can be very information-overload. it's why I procrastinated for years.
16:49:07 <dolio> And just get all of the individual functions (and many more) by combination.
16:49:10 <kazagistar> ReinH: http://research.microsoft.com/apps/pubs/default.aspx?id=67083
16:49:27 <monochrom> it can also be overkill if your purpose is much less ambitious
16:49:59 <impure_code> is it safe to use cabal with force-reinstalls?
16:50:07 <impure_code> keeps nagging me about it every time I try to install new package
16:50:11 <dolio> I think it's quite helpful for understanding lazy evaluation.
16:50:16 <ReinH> tpsinnem: According to https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html, it should add cost centers to the where clause
16:50:36 <ReinH> tpsinnem: Which you can view using +RTS -p -RTS
16:50:43 <glguy> impure_code: It's better to unregister the packages that would have been broken by the install and reinstall them afterward if you still need them
16:51:11 <ReinH> tpsinnem: I don't see anything that suggests that this affects the stack trace output
16:51:19 <impure_code> glguy: pff. seems like a lot of work
16:51:36 <monochrom> dolio: I agree. by the time we reach mapLeft, traverseLeft, and leftToList, it begins to look like particle physics before postulating just 6 quarks.
16:51:54 <glguy> impure_code: Yeah, that's why I made a tool to recursively unregister packages in these cases
16:52:01 <impure_code> :)
16:52:20 <glguy> https://github.com/glguy/GhcPkgUtils
16:52:27 <monochrom> Feynman says "there were like 450 particles found!" and I don't know whether he was exaggerating or understating. :)
16:52:31 <dolio> I think I've even seen mapJust proposed.
16:52:54 <impure_code> glguy: thanks!
16:53:19 <dolio> 450 seems like a lot. But I guess it's possible.
16:53:37 <monochrom> yeah, but even 100 is too many
16:54:12 <dolio> Yeah. Dozens maybe.
16:54:40 <tpsinnem> ReinH: the errorWithStackTrace documentation doesn't mention it but http://hackage.haskell.org/package/base-4.8.1.0/docs/GHC-Stack.html#v:currentCallStack does, and i remember reading elsewhere that profiling options during compilation were relevant
16:55:13 <tpsinnem> ReinH: anyhow, thanks for the link -- it seems i had been looking at same docs but for an older ghc version
16:56:25 <ReinH> tpsinnem: Ah, right. Are you using -fprof-auto?
16:56:36 <iffraff> mabgriff, you underestimate me :)
16:56:52 <tpsinnem> ReinH: i'm using the profiling config options in a .cabal file
16:57:21 <ReinH> tpsinnem: You should make sure that you are using -fprof-auto, I think
16:57:29 <iffraff> I am trying to learn/use fp, and I know you'll hate this but I'm using js.  but I'm having trouble understanding how to compose functors.  and I think that may be lang agnostic
16:57:33 <ReinH> To make sure cost centers are created automatically
16:57:43 <arkeet> iffraff: what are functors?
16:58:49 <iffraff> crap.  well, I though they were the buiding blocks that you use to build up functional programs, upon which monads act ect
16:58:55 <tpsinnem> ReinH: thanks, i'll look into it
16:59:04 <ReinH> iffraff: How do you define functors in JS?
16:59:33 <iffraff> I believe the definition of a functor is that it has a map function, it's transitive and crap something else. 
16:59:39 <iffraff> like I said I'm pretty new.
16:59:49 <iffraff> give me a sec and I'll look it up
17:00:23 <arkeet> maybe you should understand what functors are before thinking about what it means to compose them.
17:01:41 <arkeet> but also I don't know why you're trying to do it in js. (how does one define them and abstract over them in js?)
17:01:50 <ReinH> I don't think that one does.
17:01:57 <iffraff> ok so if I read the definition, and understand it, what then?  just keep thinking about them till it's ripe?
17:02:25 <iffraff> arkeet, I don't know haskell, I don't use haskell, I do use js. I want to learn it.
17:03:04 <ReinH> I don't think you can express this in JS, or at least not in a useful way.
17:03:59 <iffraff> arkeet, I think i did define functor properly.
17:04:37 <iffraff> ReinH, a functon in js let's say identity for arguments sake is id=x=> return x;
17:04:59 <ReinH> iffraff: You think "a map function, it's transitive and crap something else" is a proper definition of functor?
17:05:30 <mabgriff> ReinH: Am mathematician, can confirm :P
17:05:31 <iffraff> well, I know in college that would have earned me an A+
17:05:47 <ReinH> mabgriff: I think we've been working too hard.
17:05:47 <iffraff> of course I didn't realize I was in college
17:06:09 <glguy> In any case, JavaScript programming is a bit outside the topic for #haskell
17:06:47 <iffraff> yes, I know I don't really want to prove that js can be functional.  I didn't think I"d have to, I was just hoping someone could help me understand things from a higher level
17:07:11 <ReinH> We can help you understand things at a Haskell level.
17:07:34 <iffraff> ok, thanks
17:07:55 <mabgriff> iffraff: Are you looking for a conceptual grounding in category theory, which is where functors come from, or advice on JS implementation specifically? I could potentially provide the former, the latter is out of my reach.
17:11:25 <iffraff> mabgriff, neither. I just want to know how to take some imperative code that I use to filter an eventstream and practice using functors to create a small functional program
17:12:28 <iffraff> I get that no one in here is trying to turn imperitve code into functional code because you already have functional code
17:12:43 <iffraff> so I'll dig elsewhere
17:15:24 <slacko1256> what languages offer HM-type inference and run on android?
17:15:37 <slacko1256> haskell has influenced my aesthetic sense
17:15:50 <exio4> may I suggest "painful haskell"? 
17:15:59 <MP2E> haha
17:17:05 <darkstalker> slacko1256, Rust? duno if it runs on android
17:17:19 <danza> slacko1256, maybe have a look at Frege https://github.com/Frege/frege
17:18:13 <slacko1256> frege seems interesting for this
17:19:08 <danza> you can also run Haskell on Android, Keera Studios seems to be trying it https://github.com/keera-studios
17:19:31 <danza> or should i say Ivan Perez ...
17:22:25 <mabgriff> Once again, I feel like LYAH is lying to (or at least being coy with) me. I have two .hs files in the same folder, one is a module, the other can't find that module. Module (Geometry) is copy/pasted from the "Making Our Own Modules" section of LYAH.
17:23:22 <slacko1256> just launch a ghci, load the module and then the file
17:24:14 <ReinH> mabgriff: have you tried anything other than LYAH?
17:25:07 <mabgriff> ReinH: I started in on Real World Haskell, but I found it a bit slow for my taste. I liked the pacing of LYAH, though now I'm questioning it.
17:25:33 <ReinH> RWH is out of date, LYAH is easy-ish but shallow
17:25:59 <danza> well but modules should work as in there
17:26:18 <ReinH> mabgriff: people have had success with some other approaches, e.g. https://github.com/bitemyapp/learnhaskell
17:26:53 <ReinH> mabgriff: I think you might enjoy Richard Bird's new book, Thinking Functionally with Haskell. Especially if you already have some intuition for category theory.
17:28:16 <Lokathor> mabgriff, http://www.seas.upenn.edu/~cis194/spring13/lectures.html this is a really good set of lessons and practice
17:28:49 <Lokathor> it uses LYAH as the basis for the reading sections as well, so you'll be part of the way already if you've read that
17:29:39 <mabgriff> ReinH, Lokathor: Thank you for the suggestions. I will look into all of them. Also, I see from the first link that there is a #haskell-beginners, so I can stop bothering you all with silly questions :)
17:30:04 <Lokathor> questions are not silly :3c
17:32:31 <pavonia> Are there any books besides "Parallel and Concurrent Programming in Haskell" that address more advanced topics in detail?
17:32:47 <pavonia> e.g. something similar to design patterns in Java
17:33:03 <pavonia> or optimization or such things
17:33:31 <Lokathor> Haskell's design patterns are typeclasses
17:34:18 <Lokathor> each typeclass, along with the supporting library around it, can do weird enough things that learning a new one gives you as much new power as learning visitor or such
17:35:28 <pavonia> But there are cases where you shouldn't use typeclasses. I vaguely recall a blog article about functions on GUI widgets
17:36:18 <Lokathor> oh indeed, indeed, they're not always a fit. But in terms of the lion's share of the "advanced subjects" of haskell
17:36:30 <Lokathor> "Parallel and Concurrent Programming in Haskell" is quite good, if you haven't started it yet
17:36:38 <Lokathor> i'm abot halfway through
17:41:52 <mabgriff> Speaking of GUI widgets, what would you recommend for learning to create GUIs in Haskell using good functional practices? I gather that sometimes it's a bit of a hack job, and I'd like to learn the right way if possible.
17:44:05 <danza> i am afraid that in the case of user interfaces, "good functional practices" are still subject of research
17:44:29 <mabgriff> I suspected that might be the case.
17:44:55 <Lokathor> I like Haskell a lot more than Java, but if i were doing a stronly GUI oriented program (width widgets and all, not just SDL), I still might do it in java
17:46:36 <mabgriff> Lokathor: I'm basically a hobbyist who's currently set on learning Haskell. GUI programs are just satisfying learning projects, since you can really see the outcome. But they're not essential for me.
17:47:49 <Lokathor> same. However, the typical GUI ends up with lots of things nested inside other things, each with a bunch of tiny properties being adjusted. That's a little bit hairy with Haskell
17:48:32 <Lokathor> can be done, but sometimes feels awkward
17:49:59 <mabgriff> That's reasonable. Coming from a Python background, I wonder how crazy it would be to write the domain logic in Haskell and offload the GUI to Python. Probably super inefficient, but could be fun.
17:51:17 <danza> mabgriff, anyway, have a look yourself, maybe you will find it not so terrible. this is probably a good starting point https://wiki.haskell.org/Reactive-banana/Examples
17:51:18 <bsmt> might as well just use that DSL with qt itself
17:53:16 <mabgriff> "Reactive-banana" well, alright then
17:53:25 <mabgriff> bsmt: which DSL?
17:53:38 <bsmt> your theoretical domain logic thing
17:53:42 <bsmt> i was just assuming you meant a DSL
17:54:35 <hackrilege> http://lpaste.net/143737 could anyone take a look at my paste and talk to me about how to work round this type error, it really has me baffled...
17:55:09 <mabgriff> oh I see, what I meant was put the real content of the program, any relevant data structures, algorithms, etc, in a Haskell program. Domain logic in this sense: https://en.wikipedia.org/wiki/Business_logic
17:55:41 <bsmt> ah
17:56:03 <bsmt> i guess haskell is perfectly fine for webapps, so you can do a GUI that way
17:56:27 <pleiosaur> slacko1256 darkstalker: rust runs on android, yes, but its type inference isn't technically HM
17:56:37 <bsmt> i'm currently trying to figure out a good way to do a fancy CLI, might just end up using emacs for the front end and having it talk to the haskell code
17:57:04 <hackrilege> Sorry, the imports can be omitted by commenting out the last line, you will have to compile it to see the error
17:57:06 <pleiosaur> rust's type inference is also function-local intead of whole-program, and some folks get antsy about that
17:59:58 <hackrilege> It complains I have no instance Focus Polymer b0, but I'm explicitly working with b0 set to Int in the instance declaration
18:03:51 <hackrilege> Is flexible contexts behaving correctly?
18:06:22 <hackrilege> It's some kind of superclass instantiation thing, I'm not sure if I have a syntax error or I'm doing something wrong
18:06:38 <hackrilege> http://lpaste.net/143737
18:07:27 <hackrilege> No instance Focus Polymer b0 from use of insert
18:08:33 <hackrilege> I'm sure I'm telling it that b0 odd an not at line 47
18:09:01 <hackrilege> b0 is an Int, rather
18:11:16 <Cale> hackrilege: join :: a -> f a -> f a
18:11:39 <Cale> hackrilege: For the instance you're writing, f = Polymer
18:11:50 <Cale> So you need to implement a function of type   a -> Polymer a -> Polymer a
18:12:03 <Cale> but you've only written a function of type  Int -> Polymer Int -> Polymer Int
18:12:08 <Cale> which is not polymorphic enough
18:12:51 <Cale> also, I think you'll have trouble ever using join with this class declaration
18:13:20 <Cale> because nothing determines the type b to use in a usage side for join: b doesn't occur in the type of join at all
18:13:24 <Cale> site*
18:13:35 <hackrilege> Buy a in the definition of join is set at line 35
18:13:36 <Cale> and there's no functional dependency
18:13:56 <Cale> That's just an instance of Focus
18:14:19 <Cale> Maybe the error message will make more sense to you if you write join a f = fst $ insert (a :: Int,f)
18:14:45 <Cale> Because then it will be able to select the Focus Polymer Int instance
18:15:06 <Cale> and will fail for another reason: you're not allowed to select a = Int here -- it has to work for any type a whatsoever
18:15:23 <Cale> given what you wrote
18:15:42 <Cale> Did you mean to have  join :: b -> f b -> f b  in the class declaration for Zebedde?
18:15:52 <hackrilege> No
18:16:06 <hackrilege> B Is an index
18:16:16 <hackrilege> To collections of a
18:16:40 <Cale> anyway, do you understand why this doesn't work now?
18:17:54 <hackrilege> Join :: (a,b) -> f a -> f a is probably better
18:18:16 <hackrilege> No I'm still struggling :-)
18:20:04 <Cale> The type variable a which occurs in the declaration of join is also not bound by the class
18:20:12 <Cale> So it's totally polymorphic in a
18:20:18 <Cale> a is allowed to be any type at all
18:20:32 <hackrilege> The idea is I can have focus add an implemented assessor. Indexed implements it using ints but I might want to use tuples elsewhere
18:20:56 <hackrilege> As an
18:21:24 <hackrilege> Unimplemented
18:22:42 <lf94_> https://wiki.haskell.org/Keywords#rec
18:22:48 <lf94_> Why! Why!
18:23:01 <Cale> why what?
18:23:12 <lf94_> Why would people want to suddenly use mutable variables in a language that promotes otherwise.
18:23:21 <Cale> There's no mutable variable there
18:23:24 <lf94_> xs
18:23:31 <Cale> xs is not mutating
18:23:41 <lf94_> No it isn't but it's giving the illusion of mutation
18:23:43 <Cale> It never changes
18:23:46 <Cale> no it doesn't
18:23:53 <Cale> xs is equal to 1:xs
18:23:56 <exio4> I don't see anything like that there 
18:23:58 <Cale> It's an infinite list
18:24:31 <lf94_> it's re-assigning a value to xs
18:24:35 <Cale> nope
18:24:40 <exio4> do you consider `` xs = 1 : map (+1) xs `` as an expression that gives you the illusion of mutation?
18:24:41 <Cale> You're not understanding what's going on
18:24:42 <lf94_> 1:1:1:etc
18:24:51 <Cale> There's no reassignment
18:24:59 <hackrilege> Sorry I dropped the line
18:25:01 <Cale> just a cyclic data structure taking up constant space in memory
18:25:41 <Cale> > let xs = 1 : xs in xs
18:25:43 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:25:47 <Cale> ^^ is this mutation? No.
18:26:09 <Gurkenglas> http://puu.sh/isDAc/a70bc263c5.jpg
18:26:27 <Gurkenglas> (Credit to arkeet for that one.)
18:27:13 <Cale> That probably makes more sense if you get that it's evaluating  let xs = 1 : map (*2) xs in xs
18:27:50 <Gurkenglas> Right. Why did I think it said that? Gotta remember that for the next time this comes up.
18:27:58 <lf94_> > let xs = 1 : map (+1) xs
18:27:59 <lambdabot>  <no location info>: not an expression: ‘let xs = 1 : map (+1) xs’
18:28:12 <Cale> > let xs = 1 : map (+1) xs in xs
18:28:14 <lambdabot>      Ambiguous occurrence ‘+’
18:28:14 <lambdabot>      It could refer to either ‘L.+’,
18:28:14 <lambdabot>                               defined at /tmp/mueval1477171087356426808.hs:180:3
18:28:16 <hackrilege> Instead of saying focus takes arbitrary type can I not say somehow that it's ok as long as it can be some type? So that the int instance is allowed?
18:28:18 <Gurkenglas> @undefine
18:28:19 <lambdabot> Undefined.
18:28:19 <Cale> @undefine
18:28:20 <lambdabot> Undefined.
18:28:22 <Cale> > let xs = 1 : map (+1) xs in xs
18:28:23 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:28:37 <lf94_> hm
18:28:40 <Cale> > let xs = 1 : map (*2) xs in xs
18:28:41 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
18:29:13 <lf94_> How is it taking up constant space too - it's just lazy evaluation, isn't it?
18:29:33 <Cale> That one uses constant space given that you're printing the elements and doing nothing else
18:29:39 <hackrilege> As if such a deceleration permits unknown type for subclasses without requiring them to be totally general?
18:29:48 <Cale> Because the elements become garbage as you use them
18:29:54 <Cale> but that does linear allocation
18:29:58 <lf94_> Ah
18:30:07 <lf94_> Ok so what the hell...
18:30:13 <Cale> However, let ones = 1 : ones is constant space no matter how you slice it
18:30:25 <lf94_> let xs = (1 : map (+1) xs in xs) ?
18:30:31 <Cale> It will allocate a single cons cell
18:30:44 <lf94_> I'm having a hard time interpreting how to read the line
18:30:47 <Cale> whose tail pointer refers to ones
18:30:49 <lf94_> I've never used "in" before
18:30:59 <Cale> let <declarations> in <expression>
18:31:24 <Cale> is an expression form where the declarations in the first "let" part are available for use in the second "in" part
18:31:59 <hackrilege> > let a = 1 in a
18:32:00 <lambdabot>  1
18:32:01 <Cale> > let f x = x^2 in (f 3, f 5)
18:32:02 <lambdabot>  (9,25)
18:32:35 <Cale> > let fac 0 = 0; fac n = n * fac (n-1) in fac 10
18:32:37 <lambdabot>  0
18:32:40 <Cale> > let fac 0 = 1; fac n = n * fac (n-1) in fac 10
18:32:42 <lambdabot>  3628800
18:32:42 <Cale> derp
18:32:42 <Cale> heh
18:32:48 <lf94_> OK, I see
18:32:56 <Cale> > let ones = 1 : ones in ones
18:32:57 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:33:20 <Gurkenglas> (But I'll probably forget mentioning it next time too, and realize it afterwards, and link to the ircbrowse of the above line to shame myself, and then to this one. Hi, future readers! Unless I mention the words "arkeet draw" in this line, so I might see it when I look for the link to his drawing next time. Sorry for the highlight, arkeet.)
18:33:20 <Cale> Definitions of data structures are allowed to use recursion
18:33:33 <lf94_> let xs = (1 : map (+1) xs) in xs
18:33:42 <lf94_> 1:[]
18:33:54 <hackrilege> use a >
18:33:54 <Cale> at no point in time is xs ever equal to 1:[]
18:33:56 <lf94_> [1], then we run xs, which is the same thing...
18:34:06 <lf94_> OK, I get it :)
18:34:14 <lf94_> The very beginning?
18:34:18 <Cale> nope
18:34:20 <lf94_> xs is nothing
18:34:23 <Cale> let xs = 1 : map (+1) xs in xs
18:34:31 <Cale> -> let xs = 1 : map (+1) xs in 1 : map (+1) xs
18:34:41 <lf94_> Yeah I was just thinking that
18:34:43 <Cale> -> let xs = 1 : map (+1) xs in 1 : map (+1) (1 : map (+1) xs)
18:34:44 <lf94_> Heh
18:34:48 <lf94_> Yep...
18:34:59 <lf94_> So does Haskell like, autodetect this stuff?
18:35:05 <Cale> -> let xs = 1 : map (+1) xs in 1 : (1+1) : map (+1) (map (+1) xs)
18:35:06 <lf94_> That must be computationally expensive
18:35:15 <lf94_> er
18:35:18 <lf94_> no I guess not
18:35:21 <lf94_> since tail calls
18:35:23 <Cale> There is an efficient runtime representation of expressions
18:35:26 <lf94_> I was thinking the call stack would run out
18:35:29 <hackrilege> No it just checks the type which is cheap
18:35:30 <Cale> Tail calls are not really important
18:35:43 <Cale> Types aren't really important for this either, they're all gone at runtime
18:35:49 <Cale> There's no call stack
18:35:55 <Cale> (there is a pattern matching stack)
18:36:01 <lf94_> heh
18:36:06 <lf94_> *mind is breaking*
18:36:14 <Cale> All your assumptions are wrong :D
18:36:14 <hackrilege> I didn't know what was meant by auto detect
18:36:39 <lf94_> My thoughts were: Wow it must *not* generate recursive code like that?
18:36:46 <tolt> Does anyone have ideas on why adding LANGUAGE TemplateHaskell and makeLenses ''SomeRecord would result in a segfault?
18:36:55 <lf94_> Then: right, recursion is just calling the same function over and over
18:36:55 <exio4> that sounds quite nasty
18:37:07 <lf94_> Then: Shit what about the call stack? Won't that run out?
18:37:13 <lf94_> Then: Oh right tail calls!
18:37:16 <Cale> lf94_: Mind you, what I wrote if you think of it like a *tree* rather than a *graph* is less efficient than what really happens
18:37:41 <lf94_> Then: Oh wtf no call stack! Shit!
18:37:41 <Cale> lf94_: Okay, evaluation 101 right now :D
18:37:43 <exio4> tolt: do you have a minimal example to reproduce that?
18:37:47 <Cale> So, suppose we have the program double x = x + x, and we want to evaluate the expression double (double 5)
18:37:48 <hackrilege> Haskell is telling me my focus superclass to indexed is wrong. It says you can't define a thing that will later be indexed by ints without knowing in advance this is the only implementation possible.
18:37:51 <tolt> exio4: I'm working on it
18:38:12 <Cale> First, there's strict evaluation, or innermost-first evaluation, which you're probably used to from practically every other programming language
18:38:13 <lf94_> Cale: Right
18:38:16 <Cale> double (double 5)
18:38:19 <hackrilege> I'm trying to build something that will work with any implementation of focus
18:38:20 <Cale> -> double (5 + 5)
18:38:22 <Cale> -> double 10
18:38:25 <Cale> -> 10 + 10
18:38:26 <Cale> -> 20
18:38:29 <lf94_> Cale: Yeah, that's the logic I use when using Haskell too.
18:38:51 <Cale> We could also do what's called normal-order or outermost-first evaluation:
18:38:54 <Cale> double (double 5)
18:38:59 <Cale> -> (double 5) + (double 5)
18:39:05 <Cale> -> (5 + 5) + (double 5)
18:39:09 <Cale> -> 10 + (double 5)
18:39:13 <Cale> -> 10 + (5 + 5)
18:39:16 <Cale> -> 10 + 10
18:39:16 <Cale> -> 20
18:39:26 <Kristler> Cale: Is eager synonymous to strict?
18:39:31 <Cale> Kristler: yeah
18:39:34 <Kristler> neat
18:39:41 <Cale> Kristler: well, when speaking of evaluation anyway
18:40:01 <Cale> Kristler: Some people like to use eager evaluation as a term to keep it separate from strict semantics
18:40:31 <Cale> but that's a little later ;)
18:40:36 <lf94_> Cale: How...How does double (double 5) become (double 5)+(double 5) ?
18:40:43 <hackrilege> How can I build a framework that is partially implemented as i desire?
18:40:43 <Kristler> Looking forward to it :P
18:40:47 <Cale> Because we evaluate the outermost double first
18:40:53 <Cale> plugging in double 5 for x
18:41:05 <lf94_> But the outermost can't be evaluated until the inner one is
18:41:09 <Cale> why not?
18:41:14 <Cale> We can do it on paper, right?
18:41:18 <lf94_> We can?
18:41:19 <lf94_> lmao
18:41:22 <Cale> I just did!
18:41:31 <lf94_> Right
18:41:33 <Cale> Here: evaluate the following expression for me
18:41:36 <lf94_> Let me just stare at this some more
18:41:42 <Cale> (4328973 * 47389291) - (4328973 * 47389291)
18:41:48 <Cale> what do you get?
18:41:50 <hackrilege> 0
18:42:03 <Cale> hackrilege: You're really good at multiplication! :)
18:42:16 <lf94_> This is like factoring
18:42:22 <hackrilege> No I didn't bother to evaluate then I'm lazy
18:42:52 <lf94_> So...
18:42:53 <Cale> See, hackrilege didn't evaluate the multiplication, he evaluated outermost first, and applied the additional optimisation that x - x = 0
18:43:01 <Cale> (which the Haskell compiler won't do)
18:43:12 <Cale> But of course, we as humans can certainly do that
18:43:21 <lf94_> double (double (double 5)) === (double 5) + (double 5) + (double 5) ?
18:43:28 <Cale> hm?
18:43:30 <hackrilege> I could identify the similar objects
18:43:31 <Cale> double x = x + x
18:43:34 <Cale> is the definition
18:43:41 <Cale> So if we evaluate outermost first
18:43:45 <Cale> double (double (double 5))
18:43:53 <Cale> -> double (double 5) + double (double 5)
18:44:00 <lf94_> Ah
18:44:03 <lf94_> Oh shit
18:44:04 <lf94_> no way
18:44:08 <hackrilege> Lol
18:44:09 <lf94_> i think I see where this is going
18:44:19 <lf94_> The whole right side can be optimized
18:44:23 <hackrilege> Great stuff
18:44:30 <hackrilege> Evaluated
18:44:37 <Cale> Under strict evaluation, every argument to every function is evaluated exactly once
18:44:52 <Cale> Under outermost first evaluation, arguments to functions are evaluated zero or more times
18:45:04 <tolt> exio4: well, that's really weird. It's working somehow now in a new project.
18:45:06 <lf94_> Seems super efficient
18:45:07 <Cale> If we don't end up needing an argument in the result, it might not be evaluated
18:45:28 <lf94_> So Cale...how is the "+" determined to be put between?
18:45:32 <exio4> tolt: .. that sounds really nice! (actually, it doesn't :/)
18:45:32 <Cale> Well, as the double example shows, this duplication is a source of inefficiency
18:45:47 <tolt> exio4: exactly what I was thinking...
18:45:51 <Cale> We evaluated double 5 twice, because x occurred twice in the body of double
18:45:57 <lf94_> What determines that we have to "+" these two expressions?
18:46:02 <tolt> "Awesome it compiles! uh oh. It compiles..."
18:46:03 <Cale> and we ended up needing both occurrences to be evaluated
18:46:06 <exio4> the definition of double
18:46:08 <Kristler> lf94_: By the definition of double
18:46:11 <Cale> lf94_: the definition of double
18:46:26 <Cale> If for any x, we have double x = x + x
18:46:29 <Cale> then when x = double 5
18:46:38 <Cale> we have double (double 5) = (double 5) + (double 5)
18:46:40 <Cale> right?
18:46:48 <Cale> highschool algebra
18:47:18 <Cale> We're just plugging things in for variables and substituting equals for equals
18:47:33 <lf94_> Yeah
18:47:46 <hackrilege> (345*5 - (3440+8)/2)-1
18:47:52 <Cale> okay
18:47:59 <Cale> So, maybe we want to avoid that problem
18:48:00 <lf94_> I don't know why but this is just not...clicking. I know it's basic, I just can't see it. Give me a moment to work it out.
18:48:05 <Cale> okay
18:48:21 <Cale> Maybe another example or two?
18:48:39 <lf94_> No no, I see now
18:48:57 <Cale> all right
18:49:01 <lf94_> double x = x + x -> double (double 5) -> double 5 + double 5
18:49:02 <Cale> So, let's look at that again
18:49:16 <lf94_> double x = x + x -> double (double 5) = double 5 + double 5
18:49:19 <Cale> the second -> could be an = sign if you like
18:49:20 <Cale> yeah
18:49:21 <lf94_> maybe better way to put it :)
18:49:42 <lf94_> Sorry about that, shit like that happens to me all the time.
18:49:47 <Cale> I was using -> before for the way that evaluation proceeds, but here it's implication :)
18:49:48 <hackrilege> Could you talk to me about why this abstract class thing didn't work out?
18:50:35 <Cale> hackrilege: The "a" in the type of join is a totally unconstrained type variable, and you're not allowed to make any assumptions about which type it is when you define join
18:50:37 <lf94_> \Rightarrow B)
18:50:54 <hackrilege> Why is what I'm trying to do not sane?
18:51:03 <lf94_> OK so Haskell always does outermost evalution?
18:51:17 <Cale> lf94_: It does an optimisation which I'm about to discuss :)
18:51:28 * lf94_ buckles his seatbelt
18:51:30 <lf94_> Lets fly
18:51:33 <Cale> hackrilege: I don't really understand what you're trying to do, I'm just explaining why it's a problem
18:51:38 <Cale> okay
18:51:43 <Cale> So, let's look at this again:
18:51:45 <hackrilege> I should be able to allow the user to implement the abstract class later, i can't tell what a should be and there are several viable alternative
18:51:46 <Cale> double (double 5)
18:51:51 <Cale> = double 5 + double 5
18:51:58 <Cale> = (5 + 5) + (double 5)
18:52:01 <Cale> = 10 + (double 5)
18:52:06 <Cale> = 10 + (5 + 5)
18:52:09 <Cale> = 10 + 10
18:52:10 <Cale> = 20
18:52:28 <Cale> So we evaluated double 5 twice
18:52:35 <hackrilege> I could index my lookup with a tuple out an int, I can define a mapping to any countable set
18:52:45 <lf94_> When we clearly don't have to
18:52:48 <Cale> right
18:53:10 <hackrilege> Why it's Haskell syntax not allowing me to embody that concept?
18:53:17 <Cale> So, lazy evaluation fixes this: it does outermost evaluation, but any expression which is bound to a variable is evaluated at most once
18:53:31 <Cale> and the results of that evaluation are shared between all occurrences of the variable
18:53:50 <Cale> So, under lazy evaluation, if I may use let/in syntax to represent the sharing, we get
18:53:55 <Cale> double (double 5)
18:54:19 <Cale> = let x = double 5 in x + x   -- still outermost-first, but we're giving a name to the repeated bit :)
18:54:33 <hackrilege> I know i have a type error, I don't know how not yo have a type error and I don't know if it's my use of syntax or my concept which is to blame
18:54:34 <Cale> = let x = 5 + 5 in x + x
18:54:39 <Cale> = let x = 10 in x + x
18:54:42 <Cale> = 10 + 10
18:54:43 <Cale> = 20
18:54:52 <Cale> So we remove the duplication of work like that
18:55:18 <Cale> Under lazy evaluation we kind of get the best of both worlds: every argument to a function is evaluated zero or one times.
18:56:18 <Cale> So we can avoid evaluating things we don't need, but if the function parameter occurs multiple times in the body of the function, we don't end up redoing the same work.
18:56:46 <Cale> Instead, those occurrences end up being pointers to the same location in memory, and when the evaluation is done, it gets done for all of them at once.
18:56:57 <Cale> So, there are really graphs of expressions in memory
18:57:07 <lf94_> That is so cool.
18:57:09 <Cale> and those graphs may actually have cycles in them
18:57:29 <lf94_> Is there...is there a way to visually see how haskell evaluates code?
18:57:31 <Cale> (as a result of recursion)
18:57:39 <lf94_> That would be so amazing.
18:57:40 <Cale> Unfortunately not for Haskell...
18:57:45 <Cale> well, there are some tools
18:57:52 <lf94_> Someone's got to get on it. I would pay for it.
18:58:02 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
18:58:22 <Cale> I really wish this programming language HOPS were publically available
18:58:33 <Cale> It's a graphical functional programming language where you get to see the graph reduction happen
18:58:44 <Cale> This is going on for Haskell too, but it's hard to visualise
18:59:51 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/ -- more info here
18:59:56 <hackrilege> Would making focus require a contained type which was instantiated by int solve the problem Cale?
19:00:07 <Cale> hackrilege: maybe
19:00:17 <hackrilege> Aha ok
19:00:18 <Cale> hackrilege: I don't really know what your program is trying to do...
19:00:45 <Cale> hackrilege: But I think possibly you intend for that 'a' to be Int in this case
19:00:46 <lf94_> Cale: Could you pleaaaase do an example for 2 function parameters? :>
19:00:50 <Cale> based on the program you wrote
19:00:59 <Cale> lf94_: Here's a really really simple one :)
19:01:05 <Cale> const a b = a
19:01:15 <Cale> const (double (double 5)) 7
19:01:26 <Cale> actually, more fun going the other way around
19:01:32 <Cale> const 7 (double (double 5))
19:01:40 <Cale> -> 7
19:01:43 <Cale> done
19:02:06 <Cale> because we evaluate const first, and it discards the second argument
19:02:11 <hackrilege> Cale, the framework is constructed do that an alternative implementation of indexed with tuples could be defined
19:02:31 <Cale> lf94_: Now, the next thing I suppose I have to tell you about is data constructors and pattern matching
19:02:52 <Cale> hackrilege: I'm not sure what "indexed" you're referring to
19:03:03 <Cale> I mean, there's one in your code
19:03:11 <fryguybob> Cale: Yuras and you were discussing RWLocks yesterday and the topic of interuptable and STM came up.  A transaction is only interuptable if it commits a `retry`.  If it fails to commit and restarts the transaction, it remains uninteruptable.
19:03:14 <hackrilege> It's a class I defined in the paste
19:03:27 <Cale> fryguybob: yes, I became aware of that
19:03:44 <hackrilege> It implements focus using Int
19:03:55 <Cale> fryguybob: There were some interruptible cases, I was too busy at the time to really continue spending time thinking about whether my code was correct or not
19:04:44 <lf94_> Cale: nice example
19:04:46 <hackrilege> In the Focus Polymer definition in terms of the methods of Indexed
19:05:01 <lf94_> Cale: maybe a little too simple
19:05:02 <lf94_> lol
19:05:05 <lf94_> It's ok
19:05:13 <lf94_> Uhm
19:05:20 <Cale> lf94_: Yeah, to give better examples, I need to introduce data constructors
19:05:24 <Cale> and pattern matching
19:05:31 <lf94_> I'm all eyes
19:05:42 <Kristler> If I may add a little tidbit, lf94_: Have a think about why lazy evaluation wouldn't work for a more traditional (non-functional) programming language
19:05:44 <Cale> Well, let's look at this, before we get to any level of formality
19:05:54 <Cale> @src foldr
19:05:54 <lambdabot> foldr f z []     = z
19:05:54 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
19:05:57 <lf94_> Kristler, because of mutation
19:06:02 <Cale> Have you seen foldr before?
19:06:06 <lf94_> yes
19:06:09 <Cale> okay
19:06:17 <Cale> So, let's look at why this works:
19:06:20 <lf94_> Starts from the very...left and folds to right?
19:06:37 <lf94_> Or reverse, I always mess it up
19:06:43 <Cale> You can only ever start traversing a list at its beginning
19:07:00 <Bashmetim> Can anyone give me some guidance on effectively using mutable vectors?
19:07:04 <Cale> So "starts from the left" is a bit weird
19:07:04 <lf94_> I thought foldr or foldl, whichever, starts from the innermost?
19:07:24 <Cale> Both foldr and foldl start what they do at the beginning of the list.
19:07:26 <lf94_> And then foldl or foldr, again whichever, starts from the beginning
19:07:31 <Cale> But they produce different results
19:07:38 <Cale> Which are *associated* to the left and right
19:07:46 <lf94_> Yes association
19:07:51 <Bashmetim> I'm trying to write something like zipWith, but takes a vector and a mutable vector, and updates the mutable vector in-place
19:08:10 <Cale> http://cale.yi.org/share/Folds.png
19:08:16 * lf94_ click
19:08:19 <Cale> some pictures of the structural transformation :)
19:09:29 <Kristler> Cale: Did you make these?
19:09:32 <Cale> yes
19:09:36 <Kristler> They're very pretty
19:09:52 <Cale> So you can see that foldr takes what is effectively a replacement for (:) and a replacement for [], and it does the substitution
19:10:10 <Cale> > foldr (\x xs -> 10*x : xs) [] [1..]
19:10:12 <lambdabot>  [10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,...
19:10:16 <Cale> ^^ why does this work?
19:10:22 <Cale> @src foldr
19:10:22 <lambdabot> foldr f z []     = z
19:10:22 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
19:10:25 <lf94_> Cale: I hope you see why I say "innermost"
19:10:35 <lf94_> I think these diagrams make it clear why I say that X)
19:10:42 <Cale> lf94_: I do, it's because you're used to innermost-first evaluation
19:10:56 <lf94_> Very nice diagrams too by the way :D
19:11:14 <Cale> So, let's try evaluating this foldr by hand
19:11:22 <Cale> foldr (\x xs -> 10*x : xs) [] [1..]
19:11:46 <Cale> = (\x xs -> 10*x : xs) 1 (foldr (\x xs -> 10*x : xs) [] [2..])
19:12:06 <Cale> (I'm not going to worry about how [1..] gets evaluated to 1 : [2..])
19:12:15 <lf94_> (OK)
19:12:20 <Cale> (but perhaps I should have put in that step)
19:12:35 <Cale> So now we evaluate the outermost thing again
19:12:54 <Cale> putting in 1 for x and (foldr (\x xs -> 10*x : xs) [] [2..]) for xs
19:12:58 <Cale> we get
19:13:09 <Cale> =  10*1 : (foldr (\x xs -> 10*x : xs) [] [2..])
19:13:40 <Cale> now, if we were trying to match the pattern (z:zs) against this expression
19:13:47 <Cale> we would have already done enough evaluation
19:13:57 <Cale> we have z = 10*1
19:14:03 <Cale> and zs = (foldr (\x xs -> 10*x : xs) [] [2..])
19:14:29 <Cale> and we're done with evaluating the foldr for now, until something needs to evaluate zs for some reason
19:14:49 <Cale> and "for some reason" is essentially always "for the purposes of determining if it matches a pattern"
19:15:02 <lf94_> That is pretty amazing.
19:15:14 <lf94_> No flipping wonder Haskell took long to be developed.
19:15:15 <Cale> At some level, all evaluation occurs in order to determine whether or not some pattern matches
19:15:30 <lf94_> So many really good ideas that work together.
19:15:36 <Cale> All the stuff I'm telling you already existed in the mid-80's :)
19:15:52 <Cale> and some of it dates back before the advent of the electronic computer
19:16:04 <lf94_> Not like this.
19:16:09 <Cale> But yeah
19:16:22 <Cale> To make this stuff *run efficiently* is a challenge :)
19:16:36 <Cale> Especially when you have no control over what the hardware looks like
19:16:43 <lf94_> Pattern matching as we know it today...you're telling me it existed in the 80s?
19:16:46 <Cale> yeah
19:16:56 <lf94_> Are there papers or something I could read?
19:16:58 <Cale> You can read Simon Peyton Jones' book about it
19:17:11 <lf94_> Like was this developed in secrecy?
19:17:11 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
19:17:25 <Cale> No, it was developed in academia :D
19:17:34 <Cale> Everyone always ignores academics
19:17:55 <Cale> Any good idea takes 2 or 3 decades to make it to industry
19:18:07 <lf94_> Holy shit. This book looks like gold.
19:18:24 <Cale> Look at OOP -- by the time anyone paid any attention to that, academia had already decided it was probably a bad idea :D
19:18:27 <lf94_> Where in academia? Again, are there papers?
19:18:32 <Cale> yeah
19:18:37 <Cale> lots of them...
19:18:43 <lf94_> Shit man I wish I could find this stuff
19:18:47 <lf94_> It's probably so, so informative.
19:19:10 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/Papers/papers.html
19:19:56 <hackrilege> I really can't get this to work
19:20:06 <Cale> http://homepages.inf.ed.ac.uk/wadler/ also has lots of great papers
19:20:34 <Cale> look under "Publications and Talks"
19:20:41 <Cale> he has links to pages of his older papers
19:21:02 <Cale> His stuff back in the 90's is great reading for beginners
19:21:20 <hackrilege> Even with a constraining superclass to the indexing type argument to focus, Int is still a subset and not general enough
19:22:10 <hackrilege> Subclasses cannot constrain superclass abstract methods in Haskell, this is bad
19:22:15 <Cale> http://homepages.inf.ed.ac.uk/wadler/papers/class/class.ps -- 1989 type classes -- horribly titled paper (even if it is a pun, it misleads a lot of people into thinking type classes are ad-hoc polymorphism somehow)
19:22:23 <Cale> but yeah, type classes :)
19:22:51 <Cale> hackrilege: I mean, you said it should be polymorphic
19:22:53 <hackrilege> Do you have that in pdf?
19:22:55 <Cale> hackrilege: So it's polymorphic
19:23:01 <Cale> I could make it into one if you want
19:23:13 <hackrilege> But I can't make any specific instance
19:23:49 <Cale> http://cale.yi.org/share/class.pdf
19:23:55 <tolt> exio4: well, I found the issue. It's really weird. https://github.com/KevinCotrone/llvm-th/ . If you compile that it segfaults. If you remove 'makeLenses ''Name' it compiles or you can remove the dependency on llvm-general and it will compile
19:23:58 <hackrilege> Thanks!
19:24:23 <Cale> hackrilege: That wasn't really intended to help you solve your problem, but maybe good reading anyway :)
19:24:31 <hackrilege> Totally
19:24:54 <Cale> Let's see, who else has really good papers...
19:25:11 <Cale> https://wiki.haskell.org/Research_papers/Authors ... this is probably too many people :D
19:26:04 <Cale> Bird is great, but most of his stuff is paywalled :(
19:26:32 <Cale> a lot of these links are dead too :(
19:26:35 <exio4> tolt: wow, you should make a small demo package and report it tomorrow (if nobody knows how to deal with that)
19:27:11 <Cale> http://www.disi.unige.it/person/MoggiE/publications.html -- Some good historical things here
19:27:13 <hackrilege> It's reasonable I define an index class, but a class who's methods type is constrained to be instances of the index class cannot be instantiated
19:27:17 <Cale> Computational lambda-calculus and monads. Tech. Report ECS-LFCS-88-66, Edinburgh Univ., 1988. [pdf]
19:27:20 <Cale> 1988!
19:27:22 <glguy> hackrilege: The goal is to get your code to compile in your last paste?
19:27:28 <hackrilege> Yes
19:27:38 <glguy> It's just a type ambiguity error
19:27:46 <hackrilege> You can remove the last line and the imports
19:27:54 <lpaste> glguy annotated “Nasty type error” with “Nasty type error (annotation)” at http://lpaste.net/143737#a143738
19:28:46 <hackrilege> No way will that work!?!?
19:28:55 <Cale> http://www.disi.unige.it/person/MoggiE/ftp/abs-view.pdf looks rather good
19:29:02 <glguy> hackrilege: Next time you have a type error include the type error in your paste. Someone would have helped you much sooner
19:29:13 <Cale> 1989, category theoretical account of programming languages :)
19:29:25 <tolt> exio4: What else should I add to that?
19:30:41 <Cale> But yeah, that stuff is written in a pretty ivory-towerish way
19:30:59 <Cale> which required a bunch of translation for people to realise practical benefits from the understanding
19:31:24 <hackrilege> Glguy, I don't think that works
19:31:40 <Cale> Wadler read Moggi's stuff, and realised that we could actually use monads directly in our programs rather than just thinking about what our programs were doing using them :)
19:32:14 <lf94_> Cale: Got it all. Thank you so much. You make me want to just study forever.
19:32:28 <glguy> hackrilege: It certainly allows the file to load and selects the instance that you were hoping to use, so if you needed something else you'll have to be more specific
19:32:34 <lf94_> There is not enough time in this life.
19:33:07 <Cale> lf94_: The really fun stuff right now is going on in dependent type theories and homotopy type theory
19:33:25 <Cale> lf94_: Eventually people will work out how to make that 100% practical :)
19:33:34 <hackrilege> Sorry dropped connection
19:34:10 <hackrilege> Glguy, Yeh your suggestion does not change the error
19:34:44 <lf94_> Cale send me the paper when it's ready to come out the oven :>
19:34:50 <Cale> (dependent types are closer to being practically usable for "real world programming" now than they were a few years ago now that Idris is a thing)
19:35:00 <lf94_> I don't even know where to find this stuff
19:35:08 <Cale> Hang around here
19:35:11 <Cale> :D
19:35:15 <lf94_> Heh
19:35:32 <lf94_> What are dependent types? Just a brief summary is enough
19:35:39 <glguy> hackrilege: Then you'll have to paste the error or save the file
19:35:43 <Cale> In Haskell, we have data types which depend on types
19:36:01 <Cale> Like, e.g.  data Tree a = Tip | Branch a (Tree a) (Tree a)
19:36:19 <Cale> defines a type of trees with a type parameter a
19:36:42 <Cale> "Dependent types" refers to the case of types which depend not on other types, but on values
19:37:05 <hackrilege> It requires a Bluetooth transfer, the error is that a in type focus cannot be constrained to be int, it requires a general function but only a specific instance is provided
19:37:18 <Cale> For example, you might have a type of "lists of length n having elements of type a"
19:37:28 <Cale> Vec n a
19:37:30 <Cale> say
19:37:37 <glguy> hackrilege: Then the code you're loading isn't the code that was on the top of lpaste
19:37:41 <Cale> and then the operation to concatenate two of those lists would have type
19:37:49 <Cale> Vec n a -> Vec m a -> Vec (n + m) a
19:37:51 <glguy> maybe you've changed it since that last paste
19:38:05 <Cale> So now in order to do type checking, you have to do evaluation at the type level
19:38:37 <Cale> and it's a bit weird, because you often end up wanting to evaluate things which still have uninstantiated variables in them when checking that types match
19:39:00 <lf94_> Cale: Whoa.
19:39:01 <Cale> For example, you might end up wanting to know that Vec (0 + n) a is the same type as Vec n a
19:39:06 <lf94_> I never thought about that.
19:39:09 <Cale> which involves looking at the definition of +
19:39:56 <Cale> (and you might not be able to plug anything in for n yet)
19:40:08 <isBEKaml> Cale: I thought Haskell does not have dependent types? We'd have to look to Coq or Idris for that
19:40:13 <Cale> Right
19:40:19 <Cale> I was just explaining what dependent types were
19:40:28 <isBEKaml> Ah, okay
19:40:29 <Cale> Or Agda is another one
19:40:59 <Cale> Haskell's new features are sort of leaning in the direction of letting you do things which programmers in dependently typed languages do
19:41:31 <hackrilege> No really, you can get it to compile?
19:41:42 <Cale> Like, there's the DataKinds extension which turns data types into kinds and values into type-level things automatically
19:41:52 <Cale> hackrilege: hm?
19:42:01 <lf94_> Wait we don't have dependent types? I thought you just showed an example
19:42:12 <hackrilege> I really don't think so, Cale did you see glguys paste?
19:42:20 <Cale> My example with the vectors of length n thing wasn't really Haskell
19:42:30 <Cale> hackrilege: nope
19:42:32 <Cale> sorry
19:43:28 <hackrilege> Could you check, he claims it should compile but i don't think it does...
19:44:16 <Cale> oh, heh, it does, look at that
19:44:45 <Cale> So I guess you can have a totally polymorphic join, whatever the heck join is supposed to be
19:45:01 <hackrilege> It's really hard for me to get that paste to a compiler
19:45:13 <isBEKaml> Cale: yeah,  I'm on and off Haskell. I've yet to check out new features in 7.10 :-)
19:45:21 <hackrilege> And the fix does not work for me
19:45:23 <shachaf> Cale: It's a pullback, right?
19:45:23 <lf94_> Cale: I can see how that *would* be useful though.
19:45:38 <hackrilege> I can't see how it should even
19:45:49 <lf94_> Cale: So Idris and Coq support that?
19:45:50 <hackrilege> It's the same type error
19:45:51 <lf94_> Agda
19:46:05 <Cale> lf94_: Yeah, all three can do that kind of thing
19:46:16 <Cale> lf94_: and what's more, once you have types depending on values
19:46:24 <Cale> lf94_: You can define a type for equality of values
19:46:57 <Cale> Something like:  data Equals x y where Refl :: Equals x x
19:46:59 <lf94_> Yeah see I can't even comprehend that
19:47:20 <Cale> and that's the start of being able to express any mathematical property you like in the type system
19:47:35 <Cale> and have programs be proofs of those properties
19:48:32 <hackrilege> Aha I found a stray ::int
19:48:43 <Cale> ^^ that declaration is valid in Haskell using the GADT syntax, but since x and y are type variables, it doesn't mean the same thing as if they can be arbitrary values
19:48:56 <hackrilege> Wow i can't believe that was the fix that is brilliant thanks glguy
19:49:12 <hackrilege> It makes very little sense why that works
19:49:21 <hackrilege> And it's a total hack
19:49:56 <glguy> hackrilege: It's pretty straightforward why it works. The typesystem needs help knowing what instance to select
19:50:55 <Cale> I didn't actually realise that there was an instance to select which would have worked, perhaps I should have looked more carefully
19:51:01 <hackrilege> But putting insert (a:: Int,f) does not work
19:51:03 <glguy> insert :: a -> (a, f a) -> (f a, b), and then you immediately took the 'fst' of that result tuple, so there was nothing to constraint 'b'
19:51:17 <glguy> so there was no way to determine which typeclass instance to use
19:51:24 <hackrilege> Cale, yes that was kind of the whole point of my confusion
19:51:49 <hackrilege> Why do I always find the worst bugs!?
19:52:03 <Cale> Of course, it would help if I could somehow understand how any of this is useful.
19:52:30 <glguy> I don't know if that would have helped in this case :)
19:52:47 <hackrilege> Lol, I told you I'm going to provide several indexing options, its for benchmarking them
19:53:03 <Cale> Well, I'd be able to reason about whether an instance Zebedde Polymer Int  actually made sense
19:53:06 <Cale> in the first place
19:53:10 <hackrilege> I have a competition against Data.Map I'm going to win
19:53:46 <Cale> Oh, don't introduce type classes if you're going to be doing microbenchmarking
19:54:02 <hackrilege> The Int there is required to tell the ZEBEDDE how it's being indexed
19:54:50 <hackrilege> Oh no it's got to be a good benchmarking set up, it shouldn't make things slow
19:54:50 <Cale> Maybe you just want a functional dependency  class Focus f b => Zebedde f b | f -> b where ...
19:55:12 <Cale> I mean, type classes don't slow things down that much
19:55:31 <Cale> But they do count as additional function parameters, and you end up unpacking records and stuff at runtime, which is more indirections
19:55:31 <hackrilege> I was looking at funders, I couldn't see how they were to be used here
19:55:47 <hackrilege> I get that
19:56:16 <hackrilege> I hope it goes smoothly despite this
19:57:26 <hackrilege> It's an educational framework, more rigorous benchmarking can be done at performance critical development stages later, the difference between Map and lists should hopefully be clear
19:58:02 <Cale> hackrilege: You're going to try to beat Data.Map in performance benchmarks?
19:58:41 <hackrilege> Yes i have no need for lead balanced trees add I require all memory accessed one systematically not random access
19:58:45 <hackrilege> Load
19:59:28 <hackrilege> I plan to use a minimal spanning tree on Fibonacci stacks
19:59:42 <hackrilege> To make efficient traversal
20:00:39 <hackrilege> I discussed the proposal earlier in a few pastes about cyclic trees
20:01:12 <Cale> oh, you're that guy
20:01:14 <Cale> haha
20:01:28 <hackrilege> Hmm, yes
20:01:57 <hackrilege> It's a funny proposal?
20:02:55 <hackrilege> Have I missed some subtle rational which indicates it is not likely to work?
20:03:23 <hackrilege> Please if it's obvious to you do let me know
20:06:49 <hackrilege> My suspicion is that the requirement of random access makes only astronomically better performance in test cases suited to random access requirements, and that a systematic traversal would be better represented as a different sort of tree
20:07:13 <hackrilege> Asymptotically
20:07:40 <SrPx> `putStrLn "\033]1337;........"` doesn't work in Haskell. The first character is replaced by a "!". Why? 
20:07:48 <hackrilege> Anyway I'll report back with crude benchmarks in time
20:08:51 <hackrilege> Srpx backslash I'd an escape character in Haskell strings, use double backslash instead
20:08:55 <glguy`> \033 is not octal
20:09:03 <glguy`> In Haskell
20:09:06 <mjrosenb> oh man, I've been writing functions of the form a -> b -> c -> ... -> a, where it is absolutely necessary for you to pass the result of the function back into itself
20:09:10 <hackrilege> Oh sorry my bad
20:09:14 <SrPx> Ah! Woops. My bad. It should be 27.
20:09:26 <mjrosenb> and I just realized that I can put the first argument last, and use fix.
20:09:34 <SrPx> Thanks
20:10:00 <glguy`> > '\o33' -- ?
20:10:02 <lambdabot>  '\ESC'
20:10:17 * glguy` doesn't do many octal literals
20:12:23 <Cale> mjrosenb: heh
20:12:31 <SrPx> glguy`: that's better
20:12:36 <Cale> mjrosenb: and then you can build fix into the definition of the function
20:12:45 <SrPx> I'm getting a "Couldn't match type ‘m0’ with ‘ST s’       because type variable ‘s’ would escape its scope" error on GHCI, but not when I compile it with GHC. Why could that be?
20:13:00 <Cale> mjrosenb: and then you can convert that into an ordinary recursive definition :D
20:15:16 <mjrosenb> Cale: not really.
20:15:26 <mjrosenb> Cale: because there are like 3 levels of this
20:15:38 <mjrosenb> and only the top level can actually have fix applied to it
20:16:20 <mjrosenb> the rest need to have access to their subpart of the whole
20:25:18 <FireFly> > '\x1B'
20:25:20 <lambdabot>  '\ESC'
20:25:25 <FireFly> oh, good
20:28:04 * hackagebot resource-pool-monad 0.1.0.0 - A monadic interface for resource-pool  https://hackage.haskell.org/package/resource-pool-monad-0.1.0.0 (srijs)
20:43:04 * hackagebot aur 4.0.1 - Access metadata from the Arch Linux User Repository.  https://hackage.haskell.org/package/aur-4.0.1 (fosskers)
21:03:05 * hackagebot ghcjs-dom 0.2.3.0 - DOM library that supports both GHCJS and WebKitGTK  https://hackage.haskell.org/package/ghcjs-dom-0.2.3.0 (HamishMackenzie)
21:18:30 <Ox11de_> Hey! Is there an extra cabal channel?
21:19:05 <lispy> Ox11de_: if you have questions about using cabal, then people here can probably answer it
21:19:35 <lispy> there is a #cabal channel, but not many people are in it
21:20:32 <Ox11de_> It's about contributing... I would like to get involved and have some questions.
21:22:09 <homovitr`> I'm playing with parsec and a base monad that allow limited IO and has different implementation for normal runs and testing. I have problems w/ the MonadIO instance. Somebody has a few minutes to take a look at http://dpaste.com/1XVJEZ0?
21:22:17 <lispy> Ox11de_: A lot of the conversations for cabal happen in the issue tracker on github: https://github.com/haskell/cabal/issues
21:22:54 <lispy> Ox11de_: there is also a cabal mailing list: http://mail.haskell.org/cgi-bin/mailman/listinfo/cabal-devel
21:23:46 <Ox11de_> Yeah, saw that. I will dig further on github then. And thanks for the mailing list.
21:24:01 <lispy> Ox11de_: looks like they use the #hackage channel
21:24:05 <lispy> Ox11de_: see this: https://github.com/haskell/cabal/wiki
21:24:42 <Ox11de_> Thank you!
21:24:44 <lispy> Ox11de_: thanks for your interesting in working on cabal. We need more people :)
21:24:48 <lispy> interest*
21:29:40 <SrPx> I managed to isolate the bizarre code that works on GHC but not on GHCI. http://lpaste.net/143744 any idea what is going on?
21:30:44 <lispy> homovitr`: is it just liftIO = O ?
21:31:32 <glguy> SrPx: that code loads for me in both GHCi and GHC (7.10.2)
21:32:06 <glguy> Do you have a .ghci defined?
21:32:15 <SrPx> glguy: it loads in GHCI, but not if you use "stack ghci Imbug"
21:32:29 <SrPx> you need the exact path structure there... really weird
21:32:49 <glguy> SrPx: When you load it with stack ghci it's turning on more extensions
21:32:50 <SrPx> glguy: no, what is that?
21:33:10 <glguy> one of those extensions is MonoLocalBinds or something, usually turned on by -XTypeFamilies
21:33:50 <glguy> Yup, MonoLocalBinds is the one that produces the error you got
21:33:59 <SrPx> you managed to replicate it!?
21:34:12 <glguy> Yeah, add the MonoLocalBinds extension to the file
21:34:16 <glguy> and then normal GHCi won't load it
21:34:29 <homovitr`> lispy: tried that. But then the putStr lifted in the number parser produces output even when evaluated in the O monad (e.g. in the 'test' portion
21:34:34 <glguy> and then if you add a type signature to 'foo' it will start loading again
21:34:55 <SrPx> glguy: you are a genius. So, what does this mean at all? 
21:35:18 <glguy> Type Families extension turns on monolocalbinds for a  reason that I don't know
21:35:37 <glguy> and it means that when stack loads your .cabal file probably mentions that your project uses that extension
21:35:41 <glguy> so it's turning it on in GHCi
21:35:54 <SrPx> I mean, why it didn't work? What went wrong? Is this kind of code bad, should I find another solution instead of the forall thing?
21:36:13 <glguy> The code is fine, you just need to add an explicit type signature to foo
21:36:18 <glguy> inside the where
21:36:52 <SrPx> okay, I'll always add it from now
21:37:18 <glguy> SrPx: The particular issue is that your foo definition works for all Monad
21:37:28 <glguy> but monolocalbinds wants to pick a type, but it's ambiguous, could be any
21:37:55 <SrPx> I'll read about that, thanks :)
21:38:00 <SrPx> it took me half an hour to isolate this but that was worth it
21:39:12 <lispy> SrPx: in my experience, isolating problems is almost always worth it because I learn something.
21:41:09 <SrPx> Exactly. In that case, I just learned that is related to that paper I read other day, "Let should not be generalised". Interesting, I remember that paper mentioning 99% of hackage being compilable without let generalizing 
21:41:25 <SrPx> And then there is that 1% that just requires a type signature. I guess I know what that 1% does, now.
21:45:57 <lispy> homovitr`: I'm not sure you can do this sensible for types IO a -> O a, but you could do it for IO () -> O () with liftIO = const (return ())
21:46:30 <lispy> homovitr`: the conceptual problem I'm having with a more general version is that if you're not running the IO computation, then what value does it return in the O monad?
21:47:25 <lispy> homovitr`: (I think you also notice this judging by your HasPutStr class)
21:47:27 <SrPx> Fixed the actual issue now. :) Thanks again!
21:51:21 <glguy> yw ^_^
21:59:10 <homovitr`> lispy: in this case I might have a type problem, here I just wanted not to do the putStr. In the real code the IO operation I'll support is readFile :: String-> IO String / O String
22:00:14 <homovitr`> lispy: thanks for your help, I'll continue to play with this until I understand what I'm missing
22:01:37 <lispy> homovitr`: in that case, I think free monads are a nice way to do what you're doing: http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html
22:32:11 <Tehnix> Does anyone know if the haskell web-devel mailing list has a google groups or something like that? I find it very tedious to read the digest mails
22:35:20 <KaneTW> Tehnix: which one
22:35:35 <KaneTW> https://mail.haskell.org/mailman/listinfo/web-devel ?
22:36:06 <KaneTW> there's https://mail.haskell.org/pipermail/web-devel/ and http://dir.gmane.org/gmane.comp.lang.haskell.web
22:58:41 <Tehnix> KaneTW: ah, thanks, the gmane one is probably what I would prefer if there aren't any google groups for it :)
23:11:39 <hvr> imho gmane is superior to google groups, unless there's a way to access gougle groups via nntp
23:43:13 <sw2wolf> list
23:43:26 * hackagebot binary-tagged 0.1.3.0 - Tagged binary serialisation.  https://hackage.haskell.org/package/binary-tagged-0.1.3.0 (phadej)
23:54:06 <mauke> monochrom: http://lpaste.net/77137
