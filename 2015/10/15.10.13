00:00:06 <Stratege> tdammers I suppose, ultimately, it's more of a style thing. The reason Hoogle's useful is not just because of haskell's type system in my opinion but also because of the sort of types people created with it and uploaded.
00:00:20 <Maxdamantus> Nobody uses the objects, or the (sub)types?
00:00:43 <tdammers> Haskell's type system is what makes it possible - both the search mechanics and the sophisticated abstractions people build
00:00:55 <ggole> The objects
00:01:22 <ggole> Subtyping in OCaml isn't limited to objects, but it isn't anywhere near as pervasive as it is in typical OO langs, either
00:02:25 <Stratege> tdammers well, yes. Of course?
00:06:54 <tdammers> my point being, the reason other languages don't have hoogle is because their type systems are too limited to make it possible / useful
00:07:42 <Stratege> fair enough
00:07:51 * hackagebot ncurses 0.2.12 - Modernised bindings to GNU ncurses  https://hackage.haskell.org/package/ncurses-0.2.12 (JohnMillikin)
00:07:53 * hackagebot timeless 0.8.0.0 - Timeless is a Arrow based Functional Reactive Programming library  https://hackage.haskell.org/package/timeless-0.8.0.0 (carldong)
00:11:15 <EvanR> for times when someone wonders what the point of a "does nothing" identity function or Identity monad is
00:11:22 <EvanR> theres https://en.wikipedia.org/wiki/Zero-ohm_link
00:11:28 <gfixler> I think there's something to be said for not "thinking in types" in other languages == no hoogle for them
00:11:50 <gfixler> EvanR: nice :)
00:12:27 <gfixler> EvanR: http://www.urbandictionary.com/define.php?term=GNDN
00:12:54 <EvanR> haha i remember GNDN from the tech manual
00:13:04 <gfixler> yeah, good times
00:13:09 <tdammers> gfixler: yes, that too. I believe in order to actually use types the way we do in Haskell requires a certain minimum expressivity that most languages don't have
00:13:29 <gfixler> tdammers: I'm in C# at work these days (game dev in Unity), and it has me thinking about this a lot
00:13:40 <tdammers> gfixler: I bet
00:14:01 <tdammers> gfixler: using clojure at work, and it turns out to be very difficult to use
00:14:04 <Stratege> tdammers mhm.
00:14:15 <neuroserpens> Does anyone know how I can contact bitemyapp? I want to talk to him about his upcoming book.
00:14:16 <gfixler> tdammers: just playing in it for 6 months, I felt that, too - was odd
00:14:28 <gfixler> neuroserpens: he might be sleeping
00:14:40 <capisce> tdammers: why difficult?
00:14:45 <neuroserpens> gfixler: I know. Maybe I could leave him an e-mail or something.
00:14:45 <Stratege> gfixler do you have some tricks for dealing with Unity's pecularities that you learned from haskell or such?
00:14:54 <gfixler> neuroserpens: could message him on twitter
00:15:13 <gfixler> Stratege: not yet - hoping to soon; it resist my every effort
00:15:15 <neuroserpens> gfixler: True. I'm feeling so dumb right now.
00:15:27 <tdammers> capisce: I think it's because the language is expressive enough to build complex abstractions, but there's no type system, so you have to do all the type juggling in your head
00:15:32 <gfixler> neuroserpens: about haskell stuff, or tracking him down?
00:15:49 <tdammers> there are other factors though, such as uncontrolled effects
00:15:51 <capisce> tdammers: right
00:16:05 <gfixler> tdammers: yeah, I looked back at some early Haskell code of mine (tutorial stuff) - no types, no idea what I was looking at
00:16:16 <capisce> it requires more discipline I guess
00:16:24 <gfixler> it was amazing how much harder it was to figure out what things were without the types on each function
00:16:27 <Stratege> gfixler preeeetty much what I have found as well. Atleast there's LINQ and using collections in unity is reasonably common, I'd argue. (Or atleast in the game code I wrote / read it was)
00:16:44 <tdammers> capisce: yet library authors are nowhere near the amount of discipline that would make for an acceptable situation
00:16:57 <gfixler> Stratege: I'm spawning a message box, which was a several day ordeal of research and crying
00:17:06 <neuroserpens> gfixler: some questions about his book
00:17:09 <tdammers> it gets worse when you're going into macro land
00:17:10 <gfixler> Stratege: and I wanted to make it a function, so I could spawn many, and it really doesn't want me to do that
00:17:34 <Stratege> gfixler I'm currently having the same experience in Haskell :D @trying to do basic GUI stuff and it being a several day ordeal of research and crying
00:17:42 <tdammers> because really nothing about a function tells you whether it's supposed to run in a macro expansion context or at runtime
00:17:58 <capisce> tdammers: hmm, in what way are library authors undisciplined?
00:18:06 <gfixler> Stratege: iTween wants strings for everything, e.g. iTween.valueTo(gameObject, iTween.hash("from", 0f, "to", 10f, "time", 0.5f, "oncomplete", "HandleComplete", etc))
00:18:15 <tdammers> capisce: lack of automated tests, sloppy documentation, mainly
00:18:18 * hackagebot timeless 0.8.0.1 - An Arrow based Functional Reactive Programming library  https://hackage.haskell.org/package/timeless-0.8.0.1 (carldong)
00:18:20 * hackagebot true-name 0.0.0.2 - Template Haskell hack to violate another module's abstractions  https://hackage.haskell.org/package/true-name-0.0.0.2 (LiyangHu)
00:18:38 <gfixler> Stratege: so I can't just make callbacks to clean up things, because I need to give string names to the iTween hash callbacks
00:18:54 <gfixler> I found lambdas, but you have to rewrite the code in Unity itself to get that to work
00:18:55 <tdammers> suppose I write, say: foo :: Monoid a => Int -> a -> a
00:18:57 <gfixler> it goes on like this forever
00:19:10 <tdammers> this little bit contains so much information
00:19:17 <Stratege> gfixler oO is iTween some Unity 5.0 or external lib? (also we maybe should move this to pm if it stays unity centric since it's sorta off-topic for #haskell, I guess)
00:19:33 <gfixler> Stratege: that's pretty much my rant :)
00:19:49 <tdammers> to get anything comparably useful in clojure, you would have to write at least a dozen unit tests, and a few paragraphs of documentation
00:19:56 <gfixler> tdammers: I'm guessing foo merges a into itself Int times
00:20:00 <capisce> tdammers: right
00:20:23 <tdammers> gfixler: yeah, that's what I'd guess too - this type is rigid enough to not leave a lot of room for valid implementations
00:20:24 <gfixler> where merges = the monoidal operation on a
00:20:35 <tdammers> yes
00:20:43 <Stratege> gfixler curious though ... what sort of awfulness is iTween xD not a native Unity thing, I guess? Since I haven't seen that in the docs.
00:20:43 <gfixler> types are so great
00:21:05 <tdammers> it's probably going to be something like `mconcat $ replicate n x`
00:21:27 <gfixler> Stratege: interesting, I guess it is a n addition from the store https://www.assetstore.unity3d.com/en/#!/content/84
00:21:34 <gfixler> tdammers: yeah, nie
00:21:36 <gfixler> nice*
00:21:48 <capisce> tdammers: are there any areas where you think clojure (the language, not libraries etc) makes you more productive than Haskell would?
00:21:56 <gfixler> tdammers: it was in the codebase (and used everywhere) when I joined the team
00:21:59 <tdammers> capisce: I had hoped so, but I haven't found any
00:22:03 <gfixler> sorry, that was for Stratege ^^
00:22:18 <tdammers> capisce: I had high hopes for clojurescript in particular
00:22:20 <profsimm> Folks, if I model properties of an action to a "layman programmer" and I try to classify how a function behaves in time in terms of its *effects* and *output*, do think it's more intuitive to talk about function *effects* and function *output*, or more like function *writes* and function *reads*
00:22:45 <capisce> tdammers: maybe you should start a skunkworks project to convince the organization about the superiority of Haskell ;)
00:23:00 <tdammers> already on that crusade
00:23:18 <julianleviston> neuroserpens: if it’s about his book, you can use the http://haskellbook.com website - it has a support link which emails him and julie
00:23:20 <tdammers> frankly, I'd even settle for Python at this point
00:23:26 <tdammers> or node.js, or whatever
00:23:26 <Stratege> gfixler ah wow. That explains my blissful unfamilarity with it ^^
00:24:03 <gfixler> Stratege: less annoyed at Unity now, seeing that it's a 3rd party lib (but still, Unity is a mess)
00:24:27 <tdammers> they're roughly on par with clojure, except they lack the macro antifeature, they have more reasonable tools, and compile and startup times aren't prohibitive
00:24:30 <gfixler> capisce: I did a tiny port of a name generator thing from Clojure to Haskell
00:24:38 <gfixler> capisce: clojure https://gist.github.com/nasser/1db446782cf7f3587283
00:24:45 <gfixler> capisce: haskell https://gist.github.com/gfixler/84a81e9fd8ee64d42635
00:24:58 <gfixler> capisce: I felt like the Haskell was easier to read, and it's smaller, too
00:25:14 <gfixler> capisce: and that included having to roll my own random function!
00:25:44 <Stratege> gfixler LINQ is the only salvation you are going to find there. pure, lazy, functional interface providing map, filter and a few other things parametrized over most kinds of collections.
00:26:08 <julianleviston> gfixler: can’t you just map pick across a list of those things then pass that to sequence?
00:26:12 <gfixler> Stratege: yeah, it's on my radar, hoping to use it soon
00:26:40 <gfixler> julianleviston: maybe, though I'm playing a bit in the who' and plc' with some of the outputs
00:26:52 <tdammers> lol... the clojure impl uses metaprogramming to say `(?) = randNth`
00:26:58 <julianleviston> gfixler: I meant before that. I see “pick pick pick..” and I’m like ugh.
00:26:59 <gfixler> tdammers: :)
00:27:18 <tdammers> seriously, if you need metaprogramming to alias a function, then something is really really wrong
00:27:19 <gfixler> julianleviston: well, it's not golf :)
00:27:34 <gfixler> tdammers: that didn't bug me too much - I thought it was "cute"
00:27:35 <julianleviston> gfixler:  huh? :)
00:28:03 <capisce> tdammers: is it needed in this case though?
00:28:19 <gfixler> I suppose I could do [org,adj,who,big,pre,plc] = map pick [orgs,adjs,whos,bigs,pres,plcs]
00:28:21 <julianleviston> tdammers: what does “alias a function” mean? you mean like blah = yay ? 
00:29:15 <gfixler> julianleviston: alias meaning wherever ? is used in the code, rand-nth is called instead
00:29:46 <capisce> gfixler: yeah, but couldn't ? be defined as a function instead?
00:29:56 <julianleviston> capisce: I don’t think so
00:30:12 <gfixler> I'm not sure - Lisps are pretty lax with names, but ? might be too much
00:30:37 <gfixler> capisce: just tried it - it works
00:30:44 <gfixler> capisce: (defn ? [] 42)
00:30:47 <gfixler> capisce: (?) => 42
00:31:48 <julianleviston> gfixler:  nah (def ? rand-nth) actually works fine. Corrected!
00:32:04 <gfixler> yeah
00:32:34 <gfixler> anyone doing/done the 99 Haskell Problems thing?
00:32:35 <darkf> gfixler: a lot of lisps allow ? for naming predicates (e.g. zero?)
00:32:44 <julianleviston> gfixler: quite a few of them.
00:32:47 <gfixler> darkf: true - wasn't sure if it was alright on its own
00:32:53 <gfixler> julianleviston: just started last night - I'm on 23
00:33:13 <julianleviston> gfixler: a lot of the “problems” in lisp/scheme just aren’t really problems in haskell.
00:33:33 <gfixler> julianleviston: like what?
00:34:41 <julianleviston> gfixler: anything that requires non-evaluation of its arguments to write macros for, for example.
00:34:52 <gfixler> ah, special forms
00:34:55 <julianleviston> yep.
00:35:02 <gfixler> but Haskell has the flip problem
00:35:12 <gfixler> sometimes you want strictness, so you have to force it in Haskell
00:35:31 <capisce> but forcing it is very easy
00:35:37 <julianleviston> and yet some things are “much trickier” in haskell… like the random stuff.
00:35:44 <tdammers> uncontrolled laziness is kind of the biggest hole in Haskell, IMO
00:35:51 <gfixler> julianleviston: that's why I stopped on problem 23 - that's where random shows up, and it was late :)
00:36:22 <tdammers> oh, and random stuff is trickier in Haskell mainly because we don't cheat
00:36:29 <julianleviston> yep.
00:36:30 <aleator> Morning! Can I somehow point stack to a git repo containing stack yaml and build that?
00:36:51 <tdammers> we don't allow uncontrolled effects, so having a global RNG state and having it accessible from anywhere just won't fly
00:37:03 <julianleviston> gfixler: plus we have all sorts of things in Data.List that make the combinations questions kind of trivial...
00:37:20 <julianleviston> gfixler:  tho implementing from scratch is a really useful exercise.
00:37:30 <darkf> well, you can really hope someone doesn't use unsafePerformIO :p
00:37:45 <gfixler> darkf: I've made a point not to learn how to use it - it's still a mystery to me
00:37:57 <darkf> gfixler: admirable :)
00:39:12 <gfixler> julianleviston: that's what all the problems up to 23 are - implementing list stuff
00:39:13 <julianleviston> gfixler: and what do you do when the response required involves a multi-type linked list? build your own multi-morphic List type? enable one of the extensions?
00:39:30 <gfixler> julianleviston: that was also in the first 22 questions :)
00:39:37 <tdammers> unsafePerformIO isn't mysterious at all
00:39:42 <deam> the flip function is just weird are there even some use cases for it?
00:39:50 <gfixler> tdammers: but it's forbidden knowledge
00:40:00 <gfixler> deam: yeah, I just used it today
00:40:10 <julianleviston> deam: You use it all the time later on. 
00:40:13 <tdammers> more like, if you understand what it does and what the consequences are, you won't want to use it
00:40:30 <Stratege> gfixler the downside of not learning unsafeCoerce is that you won't be able to read much of ekmett's more experimental code ^^
00:40:35 <gfixler> tdammers: I don't understand what it does, but I don't want to use it
00:40:41 <deam> gfixler, julianleviston: ah okay xD
00:40:44 <tdammers> gfixler: that works too
00:41:02 <gfixler> Stratege: awww, I guess I'll have to cross that bridge when I come to it
00:41:06 <tdammers> deam: most Haskell functions are written such that the arguments that are most likely to be "curried off" come last
00:41:59 <deam> tdammers: I don't get the "curried off" part.. I should go learn some more
00:42:01 <tdammers> e.g., map has the function argument first and the collection argument second, because it is more common to create specialized functions that amount to "map this function here over X" than to create ones that amount to "map F over this collection here"
00:42:32 <gfixler> I feel like the last argument is the 'direct object'
00:42:34 <tdammers> by "curried off", I mean that you call the function in a partial-application way, leaving out the last argument
00:42:39 <gfixler> the target, the actual thing I'm trying to work on
00:42:50 <tdammers> gfixler: the target is sometimes relative
00:42:51 <gfixler> the other args are the parameters that flavor the operation I'm doing to that target
00:42:56 <gfixler> tdammers: ?
00:43:10 <tdammers> gfixler: take Data.Map.lookup
00:43:17 <tdammers> :t Data.Map.lookup
00:43:18 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
00:43:42 <tdammers> you could say that the key to look up is the parameter, and the map is the target
00:43:46 <deam> tdammers: hmm okay
00:43:55 <tdammers> but sometimes, the map is your parameter to look up the meaning of your target
00:44:08 <tdammers> "take a value, and look it up in this dictionary"
00:44:51 <tdammers> "I have a symbol, go look up the meaning"
00:45:11 <tdammers> other example, database queries
00:45:39 <tdammers> a typical database API should have a function along the lines of: query :: Connection -> Query -> Params -> IO Result
00:45:52 <gfixler1> it's hard to decide the ordering sometimes
00:45:57 <tdammers> yes
00:45:58 <Stratege> mhm
00:46:13 <Stratege> but on the other hand it is often easy to predict the ordering of function parameters.
00:46:14 <tdammers> having the connection first is useful, because the parameters are the most likely thing to come from "the outside"
00:46:49 <gfixler1> movePiece :: Piece -> Move -> GameBoard -> GameBoard
00:46:54 <tdammers> so you can create a function Params -> IO Result just by pulling a connection and a query from somewhere and partially applying the query function
00:46:56 <tdammers> point-free
00:47:06 <gfixler1> some like that, because if you apply the first two, you get a GameBoard transforming function
00:47:20 <gfixler1> but I like it first, because then I can partially apply the board, and get something I can throw pieces and moves at
00:47:40 <gfixler1> if Move is last, I can partially apply, then map a bunch of moves in a row on a piece
00:47:48 <tdammers> but then, it's also very common to have a function like this: withConnection :: ConnectionOptions -> (Connection -> IO a) -> IO a
00:47:58 <gfixler1> but if piece is last, then I can partially apply and map a move over a bunch of pieces easily, advancing all together, e.g.
00:48:09 <tdammers> that function opens a connection, runs its worker, closes the connection, and returns the result from the worker
00:48:39 <ggole> Named arguments solve that better imo
00:48:57 <tdammers> given my above query function, I'd use it like this: withConnection myOptions (\conn -> query conn "SELECT * FROM users" [])
00:48:58 <Stratege> gfixler1 I'm guessing multiple pieces are thrown at it because of testing multiple new states?
00:48:59 <ggole> Whatever arguments you like, without effort.
00:49:00 <gfixler1> ggole: in other languages?
00:49:08 <ggole> Yeah
00:49:15 <tdammers> but if the query function were, instead, query :: Query -> Params -> Connection -> IO Result:
00:49:29 <tdammers> withConnection myOptions $ query "SELECT * FROM users" []
00:49:31 <tdammers> much nicer
00:49:49 <gfixler1> Stratege: I suppose I meant fold there
00:50:05 <gfixler1> Stratege: yes, mapping would create possibilities, folding would create a sequence of moves
00:53:20 * hackagebot getopt-generics 0.11.0.2 - Create command line interfaces with ease  https://hackage.haskell.org/package/getopt-generics-0.11.0.2 (SoenkeHahn)
00:53:20 <gfixler1> > mapMaybe (flip lookup $ zip "abcdefghijklmnopqrstuvwxyz" [1..]) "word"
00:53:22 <lambdabot>  [23,15,18,4]
00:53:27 <gfixler1> deam^^
00:53:35 <gfixler1> that was where I used it today
00:53:49 <gfixler1> to get the letter positions of characters in a word
00:54:01 <gfixler1> there's probably a function for that somewhere (Data.String?)
00:54:23 <gfixler1> sorry, to get the letter positions in the alphabet for letters in a given word
00:55:48 * frerich . o O ( ['a'..'z'] )
00:55:49 <tdammers> gfixler1: you could use ord from Data.Char
00:55:55 <deam> gfixler1: I see, I think I get the gist of it now
00:56:08 <deam> frerich: haha xD
00:56:16 <gfixler1> frerich: oh, right :)
00:56:34 <gfixler1> I can't remember every cool thing at the same time
00:56:44 <tdammers> > map ((- ord 'a') . ord) "word"
00:56:46 <lambdabot>      Couldn't match expected type ‘Int -> b’ with actual type ‘Int’
00:56:46 <lambdabot>      Possible cause: ‘ord’ is applied to too many arguments
00:56:46 <lambdabot>      In the expression: ord 'a'
00:56:49 <julianleviston> gfixler1: findIndices
00:57:08 <gfixler1> ((-) ord 'a')?
00:57:19 <tdammers> brrr
00:57:35 <tdammers> looks like I ran into 50% of the things that are broken in Haskell there
00:57:46 <mtae321> Hello, does anyone know of a ghc extension that implements the Num typeclass differently? (Came up after reading Dan Piponi's remarks at the end of "Eleven reasons to use Haskell as a mathematician")
00:57:57 <gfixler1> tdammers: are the other 50% fromIntegral?
00:58:06 <tdammers> gfixler1: I was thinking record syntax
00:58:15 <MarcelineVQ> > map ((subtract 96) . ord) "word"
00:58:16 <lambdabot>  [23,15,18,4]
00:58:25 <gfixler1> MarcelineVQ++
00:58:34 <tdammers> fromIntegral isn't so bad... Float and Double sharing Num with Integer, Int, etc., kind of is though
00:58:47 * hackagebot hspec-checkers 0.1.0.1 - Allows to use checkers properties from hspec  https://hackage.haskell.org/package/hspec-checkers-0.1.0.1 (SoenkeHahn)
00:59:14 <frerich> MarcelineVQ: That doesn't do the same thing though (think of characters which are not letters)
00:59:49 <gfixler1> frerich: yeah, mine threw out non-lowercase letters
01:06:23 <frerich> deam: To be honest, most of the examples of 'flip' I can think of are either somewhat of a stretch (i.e. there are much nicer alternatives) or involve point-free code which requires some degree of careful consideration. A common alternative though is to use functions infix.
01:06:27 <frerich> deam: Like
01:06:34 <frerich> > map (`elem` "aeiou") "daem"
01:06:36 <lambdabot>  [False,True,True,False]
01:07:24 <frerich> deam: At least to me, "flip" is a bit of a (small) mental speed bump when reading code. I stop for a moment, remember what the function does and then mentally flip the arguments around.
01:07:29 <delYsid> Hmm, I have a nested structure that I need to map over in a certain order.  If I had assignment, I'd just flatten to (Int, a) and sortBy.  However, I need to map over the original structure, so flattening is not helpful.  Any hints?
01:07:32 <tdammers> frerich: flip is sometimes convenient when passing such functions around
01:07:56 <tdammers> i.e., you need to pass a two-arg function, but the function at hand has the arguments reversed
01:08:55 <julianleviston> delYsid: why can’t you flatten it to (Int, a) and sortBy??
01:09:03 <Stratege> delYsid why is the particular order important if you are just mapping and not folding?
01:09:04 <julianleviston> delYsid: like… why can’t you “just do that”?
01:09:40 <delYsid> julianleviston: Because I need to original structure preserved, hence the word map.
01:10:18 <julianleviston> delYsid: sorry. guh! :)
01:10:36 <julianleviston> delYsid: and you can’t just fmap over it?
01:10:38 <jgx> Hi
01:10:45 <julianleviston> delYsid: obviously, I’m assuming?
01:10:48 <deam> frerich: I see :)
01:10:54 <jgx> Is it possible to expose a module if the module's name doesn't match the file path ?
01:11:08 <jgx> I have a module named "Domain", in "src/Domain/Domain.hs"
01:11:10 <delYsid> Stratege: Because I need to "visit" each element of the structure "in order" to enhance it with additional data gathered by the traversal...
01:11:14 <jgx> I want to expose it in my cabal file
01:11:16 <jgx> How can I do ?
01:11:33 <jgx> I don't want to name it "Domain.Domain"...
01:11:40 <Stratege> delYsid so you are looking for ... traversable or possibly monad. Not 100% sure.
01:11:56 <delYsid> julianleviston: It is a nested list structure, it doesnt matter if I use map or fmap, the problem stays the same.
01:12:16 <julianleviston> delYsid: I mustn’t understand the problem then. Seems like a simple case of Functor to me
01:13:08 <Stratege> delYsid actually, foldable or traversable should suffice, really.
01:13:09 <delYsid> julianleviston: I need to sort before the traversal, *and* preserve the structure after the operation...
01:13:42 <Stratege> oh!
01:13:49 <julianleviston> delYsid: (confused look)
01:13:57 <gfixler1> delYsid: are you breaking the functor laws by carrying info with you?
01:14:00 <Stratege> so you have a nested structure and you want to reorder the elements in the structure without changing the shape of the structure?
01:14:30 <julianleviston> Stratege: by “shape”, I think he means “no more or less elements, and in exactly the same place as before, but changed positions, and changed data contents (ie a map)
01:14:36 <julianleviston> delYsid: is that right?
01:14:51 <gfixler1> changed positions isn't a map
01:15:05 <julianleviston> gfixler1: no, that’d be the “sorting” part.
01:15:15 <jgx> Anyone ?
01:15:17 <julianleviston> gfixler1: but s/he’s mapping *as well* as sorting.
01:15:48 <julianleviston> deam: I got a question for you
01:15:48 <gfixler1> julianleviston: I'm not entirely sure what s/he's doing yet
01:15:56 <julianleviston> gfixler1: gotcha.
01:15:57 <Stratege> honestly, I'd probably just concat + sortby and then traverse and replace with the elements from my sorted list.
01:16:00 <delYsid> The actual operation behaves like a map, i.e. structure preserving.  However, the order in which the elements are mapped over needs to be different from what the container actually contains.
01:16:18 <julianleviston> delYsid: ok monad.
01:16:21 <Stratege> that is, if I understood the problem correctly. Does that sound like a possible solution delYsid?
01:16:23 <delYsid> Stratege: But with the concat, I loose the structure.
01:16:29 <deam> julianleviston: bring it on
01:16:32 <Stratege> delYsid not if you keep a reference to the original structure.
01:16:40 <Stratege> immutability ftw
01:16:41 <julianleviston> delYsid:  you’re carrying some info which you use to inform the mapping “behaviour"
01:16:56 <julianleviston> deam: ok… so you know what filter does, right?
01:17:10 <julianleviston> deam: like… say… [1..10] filtered by even 
01:17:27 <deam> julianleviston: yes?
01:18:02 <julianleviston> deam: cool… so well you know how you make a function that filters *ANY* list of numbers to evens?
01:18:18 <gfixler1> delYsid: do you have a way to modify values in the nested structure?
01:18:26 <julianleviston> deam: like…. filterEvens nums = filter even nums
01:18:29 <julianleviston> deam: right?
01:18:31 <gfixler1> purely, of course, but something like lens or whatever
01:18:34 <delYsid> Stratege: In C++, I solved it simply be sorting a container of pointers.  References sounds a bit like that, but I was under the impression that Haskell doesn't have that?
01:18:57 <julianleviston> deam: and once you have that, you know that you can just drop the last argument… so you can write filterEvens = filter even 
01:19:06 <gfixler1> delYsid: I'm feeling like you want to zip the sorted items with the non-sorted items
01:19:19 <delYsid> gfixler1: I dont understand the question.
01:19:36 <deam> julianleviston: okay I'm not that far yet then :( confused now
01:19:45 <julianleviston> deam: ah ok. sorry…
01:19:50 <Stratege> delYsid you are aware that the normal data structures in Haskell are immutable, correct? So if you do  "y = sort . concat $ x" your x will still be the same it was at the start. So you don't lose the structure at all.
01:20:09 <julianleviston> deam: you can make a new function called filterEvens like this: filterEvens numbers = filter even numbers
01:20:19 <tdammers> delYsid: so what you're looking at is really two completely unrelated operations: one, sort things in a tree structure by key, and two, fmap over a tree structure
01:20:20 <tdammers> yes?
01:20:26 <quicksilver> delYsid: there is a sense in which haskell doesn't have pointers; but there is another sense in which everything in haskell is a pointer. 
01:21:02 <julianleviston> deam: you with me? :)
01:21:26 <gfixler1> delYsid: why do you need to sort them? Is it because each next operation carries state from the previous, or because of something like IO?
01:21:32 <frerich> So Haskell negates the dualism of pointers vs. values, much like it does away with statements vs. expressions. That's very Zen-style.
01:21:46 <deam> julianleviston: yes
01:21:49 <julianleviston> deam: sweeeet
01:22:14 <julianleviston> deam: ok… so that filterEvens function is really handy if you’re going across a LOT of lists and getting only even numbers from them.
01:22:47 <deam> julianleviston: yes..
01:23:08 <julianleviston> deam: but… let’s say you actually just wanted to run a bunch of “filterings” over the SAME list of numbers…
01:23:14 <gfixler1> delYsid: ultimately the trouble is that you need to rebuild the data structure with the new values
01:23:32 <tdammers> frerich: it doesn't negate the reference/value dualism, it just doesn't implement mutable values, so everything can be expressed as a value, but transparently optimized into a reference behind the scenes
01:23:40 <gfixler1> so you need to know paths, a la lens, or have breadcrumbs, a la zippers, etc
01:23:59 <frerich> tdammers: but if everything is a value, then nothing is a value!
01:24:11 <julianleviston> deam: that’s to say… what if you had a massive list… say [1..1000] and you wanted to find evens, then odds, then primes, then squares, then cubes, then square roots, then cube roots, etc?
01:24:29 <deam> julianleviston: yup..
01:24:38 <julianleviston> deam: but you’re repeating yourself, and that sucks.
01:24:39 <tdammers> if everything is immutable, value semantics and reference semantics are transparently interchangeable
01:24:53 <deam> julianleviston: haha xD what to do then
01:24:56 <julianleviston> deam: so, rather than that, let’s make a function that takes that “filtering function” as an argument...
01:25:08 <gfixler1> I think we lost delYsid in a puff of philosophy
01:25:19 <julianleviston> deam: filterBy f = filter f [1..10000]
01:25:31 <julianleviston> deam: so in that case, we can say filterBy even then filterBy odd , etc.
01:25:34 <julianleviston> deam: with me?
01:25:56 <deam> julianleviston: yes
01:26:00 <julianleviston> deam: excellent.
01:26:38 <julianleviston> deam: so… there’s this thing in haskell… if we go back to our first function, you can drop the right hand arguments… so filterEvens xs  = filter even xs is exactly the same as filterEvens = filter even
01:27:28 <deam> julianleviston: yes
01:27:31 <julianleviston> deam: you’re defining filterEvens to be filter partially applied with the even function, and “missing” the list of numbers… which will be “filled in” when you call filterEvens [1..100]
01:27:34 <julianleviston> deam: excellent
01:27:43 <julianleviston> deam: now let’s go back to the second function we wrote.
01:27:55 <gfixler1> tdammers: but how do you rebuild a tree from parts - delYsid's questions is striking me as rather complex now
01:27:57 <julianleviston> deam: what if we want to do THAT (that argument dropping thing) on the filterBy function?
01:28:16 <julianleviston> deam: remember it looks like this filterBy f = filter f [1..10000]
01:28:22 <julianleviston> deam: you can’t do it, right?
01:28:51 <julianleviston> deam: because if you dropped the right argument on filterBy, you’d have to drop the list, which would break everything… 
01:29:11 <julianleviston> deam: GHC would say “what is f??”
01:29:14 <gfixler1> tdammers: feeling like you'd need to turn the tree into [(path,value)], sort that somehow, then rebuild from the paths
01:29:16 <gfixler1> after mapping
01:29:17 <deam> julianleviston: wait
01:29:19 <julianleviston> deam: THIS is where flip comes in.
01:29:23 <julianleviston> deam: ok. waiting.
01:29:27 <deam> julianleviston: where's the argument dropping thing
01:29:33 <julianleviston> deam: ok I’ll go back
01:29:49 <julianleviston> deam: so… filterEvens xs = filter even xs 
01:29:51 <julianleviston> deam: right?
01:30:12 <julianleviston> deam: filterEvens xs = filter even xs  is identical to filterEvens = filter even
01:30:28 <deam> julianleviston: yes..
01:30:39 <julianleviston> deam: that is, you can actually assign filterEvens to a “partially applied” filter function.
01:30:39 <tdammers> gfixler1: why would you need to reduce the tree though?
01:30:50 <tdammers> wouldn't sorting at every level amount to the same order?
01:31:00 <julianleviston> deam: ok… so let’s go back to filterBy f = filter f [1…10000]
01:31:05 <tdammers> (or rather, sort per level, then traverse depth-first)
01:31:17 <gfixler1> tdammers: I'm not sure
01:31:26 <tdammers> something like:
01:31:29 <julianleviston> deam: so this is our function that lets us filter the numbers 1 up to 10000 by any filtering predicate function we pass in...
01:31:32 <gfixler1> tdammers: but wasn't the sorting for all things in the whole tree?
01:31:41 <deam> julianleviston: yes..
01:31:44 <julianleviston> deam: sweet.
01:32:10 <julianleviston> deam: now… we want to do what we didi with our other function… to turn it into “arguments are missing” form (otherwise known as “point free”)
01:32:34 <deam> julianleviston: ah yes..
01:32:50 <tdammers> gfixler1: yes, but sorting recursively would do the same, wouldn't it?
01:32:53 <julianleviston> deam: so we have filterBy f = filter f [1..10000] but we can’t drop the list, because that’s part of the function! we want to drop the “f” off both.
01:33:00 <tdammers> gfixler1: assuming that we're sorting by key, not by value
01:33:04 <julianleviston> deam: so what we have to do is “flip” the arguments that filter takes...
01:33:22 <gfixler1> tdammers: it doesn't feel like it would, but maybe you're right - I'm no algorithms guy
01:33:48 <julianleviston> deam: so… filter takes a predicate (filtering function), and a list, in that order. We want a function that does the same thing, but takes the list first...
01:33:49 <tdammers> gfixler1: it would, that's how tries work in the first place
01:34:13 <julianleviston> deam: so we can do two steps. First, flip the filter function, and second, drop the “f”.
01:34:40 <julianleviston> deam: step 1: filterBy f = (flip filter) [1..10000] f
01:35:07 <julianleviston> deam: now, handily, the arguments are in the right order to turn it into point-free style (ie… we can drop our last argument)
01:35:26 <julianleviston> deam: so… step 2: filterBy = (flip filter) [1..10000]
01:36:13 <deam> julianleviston: I see.. that's it?
01:36:16 <julianleviston> deam: now, this is a SUPER trivial example… and it’s not *really* that necessary here, but there are cases later on where you’ll be *very* thankful that flip exists.
01:36:38 <deam> julianleviston: it's not very readable is it? or
01:36:52 <julianleviston> deam: like say if you want to map a list of functions across a standard set of data, and some of them are in the wrong form.
01:37:11 <MarcelineVQ> deam: it's more useful when you're stringint functionsd together in chains
01:37:14 <julianleviston> deam: that’s a matter of opinion. :)
01:37:15 <MarcelineVQ> stringing
01:37:53 <deam> julianleviston: okay thank you! :)
01:38:12 <delYsid> Hmm, I could keep indices, instead of pointers, in the list that I sort, something like [(Int, Ix)], but this feels rather hackish.
01:38:31 <gfixler1> delYsid: I thought it was nested
01:38:56 <delYsid> gfixler1: Yes, thats an additional problem :-(
01:39:24 <delYsid> So I'd need a tuple of indices, which is just horrible.
01:40:10 <gfixler1> delYsid: almost feeling like I'd want a zipper for this
01:40:23 <julianleviston> deam: you’re welcome! sorry I couldn’t think of a better example.
01:40:31 <gfixler1> and let the sorting actually be a production of cursor movements to target nodes
01:40:49 <gfixler1> but that's a very engineered way, and probably not very theoretically sound
01:40:57 <julianleviston> deam: but until you get to function composition, flip isn’t terribly useful.
01:41:09 <gfixler1> delYsid: what are you sorting by?
01:41:34 <deam> julianleviston: I see
01:41:39 <gfixler1> delYsid: also, how are you achieving nesting? custom data type? You can't just nest lists in Haskell
01:41:59 <gfixler1> well, you can, but not arbitrarily
01:42:24 <gfixler1> [[this]] is fine, but not something where some elements are lists, some aren't, some are lists of lists, etc
01:42:37 <m1dnight_> Hello guys. I am trying to get parsec to work in cabal. I have done `cabal init`, `cabal init sandbox` and then `cabal install parsec` but it cant find the library when i do `cabal install`. I have installed parsec globally (`cabal install parsec` outside of a sandbox) and then the file compiles fine.
01:42:56 <m1dnight_> When I did install parsec in the sandbox it showed me "installing in sandbox" so I guess that would be okay.
01:44:53 <tdammers> gfixler1: rose trees?
01:44:59 <gfixler> tdammers: that would work
01:45:35 <delYsid> gfixler1: It is basically just an [[[[a]]]]
01:45:36 <gfixler> tdammers: maybe something like zippers, but for sorting
01:45:54 <gfixler> tdammers: i.e. as you sort, it records how to unsort
01:46:02 <m1dnight_> (I also just checked `ghc-pkg list` and it shows the packages in my sandbox)
01:46:35 <gfixler> sortedMap mySort f structure
01:46:49 <Stratege> delYsid still working on your problem? I believe I have found a simple (and fun!) solution
01:46:58 <gfixler> delYsid: and are you proclaiming the sort, or figuring out the sort from the values?
01:47:14 <tdammers> again, if you want to sort by keys in such a way that the result is the same as what you'd get if you were to extract "paths" through your trees as lists and sort those, then just sorting per-level is going to be valid, and probably even more efficient, too
01:47:15 <gfixler> Stratege: share!
01:47:28 <gfixler> tdammers: what keys?
01:47:59 <Stratege> basically: \x -> let y = sort . concat $ x in replaceFunc x y
01:48:43 <gfixler> Stratege: is that supposed to be 2 line?
01:48:45 <tdammers> gfixler: I was assuming something like data Tree k v = Leaf v | Branch [(k, Tree k v)]
01:48:49 <Stratege> and replaceFunc [] _ = [] ; replaceFunc _ [] = [] ; replaceFunc (x:xs) ls = let len = length x in take len ls : replaceFunc xs (drop len ls)
01:48:58 <gfixler> tdammers: apparently it's [[[[a]]]]
01:49:04 <Stratege> gfixler was still typing up the second line
01:49:23 <Stratege> ... that's a lot of nesting oO
01:49:24 <tdammers> gfixler: then maybe, uhm, idk, map that onto a Tree Int a
01:49:30 <tdammers> do the sorting and fmapping
01:49:36 <Stratege> suggestion: implement a Scheme first
01:49:39 <tdammers> then map back to [[[[a]]]]
01:49:42 <Stratege> then do it in there.
01:50:03 <gfixler> I'm still waiting to hear how delYsid wants to sort things
01:50:12 <gfixler> we're presuming that currently
01:50:24 <gfixler> the sort could be based on a manager's written ordering
01:50:36 <Stratege> gfixler well to be fair with my solution the actualy sorting is just a replacement of the sort with a sortBy if you want it different ^^
01:50:43 <gfixler> Stratege: nice
01:51:35 <Stratege> with 5 nesting deep lists, the replaceFunc there would need to be adapted, since it's just for 2 deep atm. But that should be doable.
01:52:36 <gfixler> Stratege: still trying to grok that $ in the function
01:52:59 <gfixler> oh, got it
01:53:03 <gfixler> wasn't parsing for me
01:53:04 <Stratege> $ is just infix apply
01:53:10 <Stratege> *nods*
01:53:12 <gfixler> I know, but it looked odd
01:53:12 <Stratege> kay
01:53:25 * frerich thinks it's a law that if you are not sure how many levels of nesting you need, it's a power of two.
01:53:31 <Stratege> yeah the issues of writing stuff in one line and using let ... in together with $
01:54:14 <delYsid> gfixler: Imagine every element a has a 'length' field.  I am sorting by position.  So I need to add up all lengths to get the position of an element in the structure...
01:55:29 <gfixler> delYsid: you mean the length preceeding it in the tree?
01:55:36 <Stratege> delYsid if you have n elements, and all lengths are >= 1, and you accumulate the lenghts of all the ones you've seen so far, would that not mean that you might have to place some element at a position > n?
01:55:37 <gfixler> lengths*
01:56:11 <Unhammer> I'm doing a lot of "upd w = let x'=x w + 1 y'=y w + 1 in w{x=x',y=y'}" – is there something in haskell like ocaml's punning where you can just do "w{x,y}" if x and y have been bound to something in that scope?
01:56:39 <Stratege> delYsid also ... adapting the solution I've shown via replacing the appropriate sortBy and a fold for the accumulating should do the trick :)
01:57:28 <quicksilver> Unhammer: why would you not just write w { x = x w + 1, y = y w + 1 } ?
01:57:37 <quicksilver> Unhammer: what have the names x' and y' gained you?
01:57:38 <delYsid> Look, its really just mapAccumL (\pos x -> (pos + dur x, (pos, x))
01:57:44 <lpaste> echo-area pasted “Deducing types” at http://lpaste.net/142928
01:57:52 <quicksilver> Unhammer: (if you do a lot of work like this, then lens makes things nicer)
01:57:56 <echo-area> I just found a very convenient way of deducing types
01:58:44 <Unhammer> quicksilver,  I first bind x, then if something=1, I bind y
01:59:29 <Unhammer> so I gain reuse :)
01:59:31 <Unhammer> (and the expressions do get a bit larger than that at times)
01:59:35 <Stratege> delYsid hm? So you have the solution? ^^
01:59:52 <quicksilver> Unhammer: so, the answer to your question is yes, there is an extension Record puns
02:00:09 <quicksilver> Unhammer: which makes w{x,y} a short hand for w{x=x,y=y}
02:00:09 <Unhammer> I tried understanding NamedFieldPuns, but it seems to be about something else
02:00:19 <quicksilver> that's the one
02:00:23 <quicksilver> NamedFieldPuns
02:00:32 <quicksilver> I must admit I don't recommend it.
02:00:44 <Darwin226> Hey guys. Is there anything wrong you can spot with this "implementation" of a priority queue? It's very short https://gist.github.com/LukaHorvat/12c51dd3ecd6b5a02ac7
02:00:45 <quicksilver> but, it's there if you want
02:00:53 <quicksilver> I find it gets confusing to have all the 'x' s around
02:01:05 <Unhammer> hm
02:01:25 <quicksilver> Darwin226: what makes you think something is wrong with it? does it give a compile error? wrong answers in some case?
02:02:25 <quicksilver> I wouldn't be surprised if your Ord instance for U breaks Data.Map
02:02:31 <nkaretnikov`> is there a simple to use udp server?  something like scotty would be ideal
02:02:38 <quicksilver> it violates the laws.
02:02:48 <Darwin226> quicksilver: It does break the map in the sense that you can't do lookups, but for minimum values it works
02:03:04 <delYsid> Stratege: No.
02:03:05 <Stratege> Darwin226 well, for one, what is the point of "Unique"? It appears to be just unit?
02:03:08 <Darwin226> quicksilver: and questions like these is why I ask :D I have no idea if what I did is somehow bad
02:03:16 <delYsid> OK guys, thanks, I'll have to figure this out on my own, too many cooks and all.
02:03:25 <Darwin226> Stratege: It allows you to have duplicate values with the same priority
02:03:36 <gfixler> delYsid: good luck!
02:03:45 <quicksilver> Stratege: the point of it is to create things which look the same but are actually different
02:03:49 <quicksilver> in the Map
02:04:07 <quicksilver> Darwin226: the problem is you'd have to audit every Map function you use, to see how it behaves in the presence of a broken Ord instance
02:04:08 <Stratege> Darwin226 oh I see. Yeah saw the U == U = False thing. Reminds me of JS.
02:04:43 <Darwin226> quicksilver: Another solution would be to have a counter in the queue and pair that up with keys
02:05:03 <lpaste> quicksilver pasted “pqueue from Map” at http://lpaste.net/142929
02:05:03 <Darwin226> quicksilver: This would even let me have an order invariant when objects have the same priority
02:05:24 <quicksilver> Darwin226: I just pasted my own pqueue-in-Map implementation
02:05:25 <fizruk> Darwin226: did you now there is Data.Unique in base?
02:05:31 <Darwin226> quicksilver: But if this already doesn't break, then keeping track of that int seems like a pain
02:05:43 <Darwin226> fizruk: It's not what I need
02:06:54 <quicksilver> Darwin226: well my version wasn't much of a pain, I thought
02:06:56 <Darwin226> quicksilver: I see. That's one way of avoiding problems. It's a bit messier though
02:07:08 <quicksilver> Darwin226: ah well that's subjective :)
02:07:24 <quicksilver> I think law-violating Ord instances are 'messier' than encoding priority queues as multimaps
02:07:43 <quicksilver> but the elegant solution is just to download a real one, there are like 3 implementations on hacakge
02:08:13 <Darwin226> quicksilver: Sometimes it's not an option
02:08:35 * quicksilver nods
02:09:28 <Darwin226> quicksilver: Can you think of any problems with an implementation that keeps track of a count?
02:11:07 <quicksilver> don't see how it's better than a list?
02:11:14 <quicksilver> why do the hard work of keeping the count correct
02:11:25 <quicksilver> rather than just have the actual list of all the things with the same key?
02:12:28 <Darwin226> quicksilver: Well for one, it makes sure that the one I push in first gets poped first if it has the same priority
02:12:50 <quicksilver> wouldn't you need (say) an auxiliary (Map key count) to track the count so far?
02:13:10 <quicksilver> Darwin226: pretty simple to change my code to use opposite ends of the list for push+pop
02:13:15 <Darwin226> quicksilver: I don't think so. The individual counts may be spread out, but the order would still be fine
02:13:41 <Darwin226> quicksilver: That doesn't perform as good
02:14:01 <quicksilver> if you care about performance, throw all this away and do it properly with a heap :P
02:14:37 <Darwin226> quicksilver: I'm not sure how much slower this actually is compared to a "real" implementation
02:14:42 <quicksilver> I mean the answer to your question is "no, nothing wrong with the idea of storing counts"
02:15:04 <quicksilver> Darwin226: right. Neither of us knows that without a benchmark. But you were the one who raised performance.
02:15:04 <Darwin226> quicksilver: It's asymptotically sound at least
02:15:23 <quicksilver> mine is asymptotically sound as long as hte number of items with the same key is bounded.
02:15:43 <quicksilver> well it's asymptotically sound anyway, if you don't mind the LIFO behaviour
02:15:48 <Darwin226> quicksilver: Anyways. Thanks for the discussion. I might just do a few benchmarks. Maybe even report back :D
02:15:51 <quicksilver> :)
02:18:50 * hackagebot type-list 0.3.0.0 - Operations on type-level lists and tuples.  https://hackage.haskell.org/package/type-list-0.3.0.0 (mjmrotek)
02:22:04 <nazrhom> hey guys, im a haskell newbie and I am currently having a bit of trouble with the snap framework, would this room be a good place to ask for tips or should I look for something specific to that?
02:22:24 <quicksilver> I'm pretty sure there is a snap channel but you are absolutely welcome to ask here as well, nazrhom 
02:23:56 <Gurkenglas> I want to build a program that (keeps a large amount of data in RAM and then) responds to another program's requests. How should I go about that?
02:24:26 <Gurkenglas> (The other program is not going to be written in Haskell.)
02:24:57 <fizruk> like a web server?
02:25:18 <Gurkenglas> Sounds close?
02:25:41 <Gurkenglas> A part of a university project, where I am the only Haskeller.
02:26:46 <fizruk> sounds like web server should fit perfectly
02:26:47 <gfixler> Gurkenglas: "I am the only Haskeller" is a common refrain in my life
02:27:03 <nazrhom> thanks quicksilver, I am currently learning about heist and splices, I made a userData splice with some data about the current user but I am now manually "injecting" the splice in every route (since it is needed almost everywhere) is there a better way to do this?  
02:27:36 <Gurkenglas> There should be only one request/answer per UI operation (like moving the mouse one pixel), so it doesn't have to be *too* performant.
02:28:40 <fizruk> Gurkenglas: what kind of requests/answers are you going to handle?
02:29:52 <Gurkenglas> "Give me all the data with these specifications from your data, and quickly."
02:29:57 <fizruk> Gurkenglas: will it have concurrent requests or do you expect a single client?
02:30:08 <Gurkenglas> Single client. Read only.
02:30:55 <Gurkenglas> (Although multiple *could* be possible, I guess? And I might remember things about each client, but they aren't going to interfere with one another.)
02:31:51 <Gurkenglas> By could, I mean it might be neat if I could tell the other parts of my project "Oh and by the way you can have multiple windows open without doubling RAM usage."
02:32:36 <waressearcher2> if you randomly pick a person off the street, what is the probability that their birthday occurs in June ?
02:32:52 <Gurkenglas> Depends on the street.
02:33:51 * hackagebot type-list 0.3.0.1 - Operations on type-level lists and tuples.  https://hackage.haskell.org/package/type-list-0.3.0.1 (mjmrotek)
02:34:07 <fizruk> Gurkenglas: I'd just go with a web server, e.g. using servant library, but I can't tell you for sure that will work great because I don't fully understand what you are doing
02:34:40 <Gurkenglas> How much latency do local web packets introduce?
02:35:06 <fizruk> waressearcher2: 30/365 ?
02:36:23 <fizruk> Gurkenglas: should not be noticable as you've said there are not many requests and mostly one client
02:36:37 <tdammers> fizruk: that's assuming birth rates are constant over the course of any given year
02:37:10 <fizruk> tdammers: yes, and also no leap years :)
02:37:11 <tdammers> fizruk: in reality, though, they're not - people have more sex during holiday season, climate influences both libido and fertility, etc.
02:40:15 <waressearcher2> fizruk: 1/12
02:40:30 <quicksilver> Gurkenglas: local HTTP overhead should be on the order of 100 us to 1ms
02:40:34 <fizruk> tdammers: well, "define reality". factors you mentioned can indeed influence that, but waressearcher2 did not mention what kind of probability he was interested in
02:40:50 <quicksilver> Gurkenglas: naturally varies depending on lots of details about your software
02:41:30 <quicksilver> nazrhom: I don't know I'm afraid :( snap experts?
02:42:21 <tdammers> nazrhom: not a snap expert myself, but IIRC, heist uses quasiquotes for its templates, yes?
02:42:42 <tdammers> nazrhom: which means that whatever is in scope where you write your quasiquote expressions is accessible from within the template
02:43:04 <tdammers> nazrhom: so there's probably a monad stack somewhere, where you can add some state of your own
02:43:29 <Gurkenglas> Is there a way to rent an ssh account in a place where I can write haskell and use stack in a sandbox and things like that? (so I can do things while at university without having a laptop and maybe don't even need to overcome the installation challenges at home)
02:44:10 <Gurkenglas> Because https://www.fpcomplete.com/ doesn't have servant installed.
02:44:23 <tdammers> rent a cheap VPS?
02:44:51 <waressearcher2> if you imagine grade 1 to 10 where: 1) I don't know haskell and 10) haskell guru,   what amount of time do you time do you think it will take to proceed every step, from 1 to 2, from 2 to 3 and so forth till 10 ? I don't think they will be same amount, like it will take longer to get from 9 to 10 then from 1 to 2
02:45:17 <tdammers> I don't think there's an upper end on that scale
02:45:18 <nazrhom> thanks for the pointer, I must admit im not really familiar with quasiquotes but I will look into that
02:46:48 <merijn> waressearcher2: I think the last steps might actually be easier than the first one :)
02:47:52 <ent> the first step is easy, it's the second or third that's hard
02:48:13 <ent> (that's where I am :P)
02:48:29 <mostalive> Gurkenglas: Digital Ocean can be fairly cheap (write a bash script to install stack, destroy VPS when not using it)
02:48:49 <merijn> mostalive: hell, Digital Ocean is even cheap if you keep it running 24/7 :p
02:48:51 * hackagebot observable-sharing 0.2.4 - Simple observable sharing  https://hackage.haskell.org/package/observable-sharing-0.2.4 (mararon)
02:48:53 * hackagebot type-list 0.3.0.2 - Operations on type-level lists and tuples.  https://hackage.haskell.org/package/type-list-0.3.0.2 (mjmrotek)
02:49:18 <mostalive> merijn: sure, but Gurkenglas: mentions he's a student. I don't want to deny them their drinks ;)
02:50:09 <tdammers> alternatively, buy a suitable server, configure it for a sleep-when-inactive / wake-on-lan setup, run it from your home, use a dynamic DNS service to find it from outside
02:50:26 <tdammers> VPS might have a cheaper bottom line though
02:50:28 <Gurkenglas> If I could set up stack to work at home I wouldn't need any of this
02:51:19 <mostalive> Gurkenglas: what are your installation challenges?
02:51:20 <Gurkenglas> Waaait. Why doesn't fpcomplete have servant installed when they're the ones behind stack?
02:54:40 <Gurkenglas> mostalive: Packages won't build (I'm on Windows). On a vm, it worked except that Atom started lagging everything. Maybe I'll get that to work, but I was trying to see if someone saw so many having problems getting an IDE setup and made a web service for it
02:55:03 <ChristianS> Gurkenglas: what does servant have to do with stack?
02:55:33 <Gurkenglas> ...servant isn't on stackage? Damn.
02:56:05 <Gurkenglas> Up to now, every library I needed had been on stackage.
02:56:17 <Gurkenglas> Is there an equal competitor to servant that I can use on fpcomplete?
02:56:23 <ChristianS> Gurkenglas: sure it is
02:56:34 <fizruk> Gurkenglas: servant is on stackage
02:56:44 <Gurkenglas> I Ctrl-F'd http://daniel-diaz.github.io/stackagelist/ for servant
02:57:25 <jgx> Is there a stack command to install a dependency *and* appending it to the .cabal file ?
02:57:31 <fizruk> Gurkenglas: you might use scotty for a simple web server as well
02:58:07 <fizruk> jgx: I believe stack does not modify .cabal, I might be wrong
02:58:46 <jgx> fizruk:What is the common way to include a new lib ?
02:58:50 <alpounet> servant is on stackage: http://haddock.stackage.org/lts-3.9/servant-0.4.4.4/index.html
02:59:00 <jgx> I added the lib name to .cabal then I did "stack build"
02:59:05 <mostalive> Gurkenglas: I spent quite a bit of time getting an IDE set up (emacs, because it seemed best supported). and then I noticed some people who have been doing haskell for longer just gave up on that. Random editor + ghci (and in my case stack)
02:59:07 <jgx> Is it the right way ?
02:59:38 <mostalive> I put my emacs config in Docker - https://github.com/capital-match/haskell-emacs so other people could use it, but its big (and doesn't have stack)
02:59:44 <alpounet> you just have to pick the right "package selection", which would be a recent LTS 3 here
03:00:20 <alpounet> OTOH i don't know how you can do that from the online IDE, unfortunately.
03:00:27 <alpounet> (never used it)
03:00:50 <fizruk> jgx: yes, this is fine.
03:01:08 <jgx> fizruk: I can't clearly see what's the main purpose of stack.yaml
03:01:39 <jgx> I used it to depends on ghc-mod 5.4 to make atom editor compatible with stack, but that's all
03:02:21 <mostalive> jgx: choosing a ghc version + package set, and it allows me, for a project, to remove version bounds from the .cabal file
03:02:56 <jgx> mostalive: what do you put exactly in the packages key ?
03:03:16 <mostalive> jgx: '.'
03:03:17 <fizruk> jgx: stack.yaml ensures your project(s) will build on other machines if you can build with it on yours
03:03:36 <jgx> mostalive: Yes I have that too, but what does it mean ?
03:03:45 <fizruk> jgx: . is current directory
03:04:10 <jgx> fizruk: Ok, so it searches for .stack-work in the current dir
03:04:16 <jgx> makes more sense now ^^
03:04:16 <mostalive> jgx: so the packages key has the current directory. I never edited that. I occasionally edit 'extra-deps' if I try to compile someone elses' blog post from last year and a package is not in stackage.
03:04:20 <fizruk> jgx: no
03:04:51 <jgx> fizruk: Ok I don't follow :p
03:04:54 <fizruk> jgx: . is where to look for a package, .stack-work/ is always in the current dir (I think)
03:05:05 <fizruk> jgx: some projects have multiple packages
03:05:16 <fizruk> jgx: take a look at servant repo for instance: https://github.com/haskell-servant/servant
03:05:22 <jgx> so maybe I don't get what a package is
03:05:27 <jgx> I'm beginning today with Haskell ^^'
03:05:31 <ketil_> I should know the answer to this,but: how do I parse numbers with explicit error reporting?  'read' calls 'error', but I want Maybe Double, or similar.
03:05:40 <fizruk> jgx: this is servant's stack.yaml: https://github.com/haskell-servant/servant/blob/master/stack.yaml
03:05:51 <ketil_> ...in order to deal gracefully with illegal input.
03:06:04 <fizruk> jgx: you can see that there is a single stack.yaml for multiple packages
03:06:12 <jgx> fizruk: ok I see
03:06:25 <jgx> fizruk:So the default package name is "app" ?
03:06:43 <jgx> No ok app is part of the package :p
03:06:53 <jgx> the package is the project itself
03:07:02 <jgx> and servant has multi project in one folder
03:07:06 <jgx> I think I got it
03:07:07 <fizruk> jgx: yes
03:07:13 <jgx> fizruk:Thanks :D
03:07:43 <fizruk> jgx: app/, src/, test/ are just subdirectories that help structure project
03:08:29 <ketil_> Ah, I can hack something from readsPrec, I guess.
03:08:57 <jgx> fizruk: If for example I want to create an app with two entry points, one from the web, the other from the CLI, I would create a Web/ and Cli/ folder instead of app/ right ?
03:09:15 <mostalive> ketil_: https://hackage.haskell.org/package/safe-0.3.9/docs/Safe.html  readMay
03:09:33 <jgx> fizruk:and in the .cabal file, I'd have to reference two "executable" ?
03:09:46 <mostalive> ketil_: for some reason hoogle doesn't find the function if you type the type signature (it does find something from Network)
03:10:27 <fizruk> jgx: most likely you'd have src/ for common library, server/ for server and client-cli/ for CLI client (if I got you right)
03:10:57 <fizruk> jgx: this separation into directories is optional (though you should do that)
03:11:13 <fizruk> jgx: yes, you'd have a library and two executable sections
03:11:58 <jgx> fizruk:ok perfect
03:12:35 <fizruk> jgx: stack new can create basic project structure for you (it has a few templates to choose from)
03:12:39 <jgx> fizruk: In JS I tend to create everything under src/ but it seems that Haskell does it differently
03:12:54 <jgx> fizruk:Yes I used that to begin with stack
03:13:28 <jgx> for example I would do : src/UserInterface/Http/Main.hs and src/UserInterface/Console/Main.hs
03:14:42 <ketil_> mostalive, thanks.  This should be in the prelude, if you ask me.
03:15:15 <fizruk> :t Text.Read.readMaybe
03:15:17 <lambdabot> Read a => String -> Maybe a
03:15:38 <fizruk> ketil_: were you looking for that? ^
03:15:45 <fizruk> :t Text.Read.readEither
03:15:46 <lambdabot> Read a => String -> Either String a
03:16:10 <fizruk> ketil_: that is in base
03:17:07 <Gurkenglas> How much space overhead does Map Int Char have versus [(Int, Char)] when both are fully evaluated?
03:17:33 <Gurkenglas> Or even an efficent array representation of the latter, or something. The kind of stuff you'd do in C, say.
03:17:58 <athan> Gurkenglas: With Map Int Char (or IntMap), you're guaranteed uniquely-keyed elements, while in [(k,a)], you're not
03:18:07 <mostalive> fizruk: thanks, I hadn't seen the readMaybe and either in Text.Read
03:18:12 <athan> so theyre different concepts really
03:19:05 <fizruk> Gurkenglas: there is also Data.IntMap
03:20:18 <shourya> I might be going a little off topic here, but do you people know a easier language to learn?
03:20:21 <athan> Gurkenglas: I know that the underlying data representation is a finger-tree, though (something like a ternary-tree?), see also TernaryTrees
03:20:30 <Gurkenglas> athan, what impact does that have on space? But huh, you might be able to save a little space by putting the leftmost digit of the int into a Node if the children all have the same one.
03:20:43 <athan> There's a paper floating in my folder on different underlying data representations
03:21:13 <athan> Gurkenglas: You mean like a trie?
03:21:29 <Gurkenglas> So that's what a trie is? Huh.
03:21:42 <athan> Gurkenglas: As far as space is concerned, you could have duplicate elements in your cons-list of pairs
03:22:07 <athan> while with a tree-based version, you order by the key's value
03:22:26 <athan> so instead of cons-listing over the pairs, you're cons-tree'ing over the keys
03:22:45 <athan> Gurkenglas: Well... tries are fun
03:23:56 <mostalive> ketil_: I think it should (or at least the unsafe read shouldn't). I'm migrating to https://hackage.haskell.org/package/classy-prelude-0.12.4/docs/ClassyPrelude.html that has readMay (now that I checked). at the very least it doesn't have the unsafe functions from Prelude so forces me to stop and not use them.
03:24:04 <fizruk> shourya: depends on what you want to learn. one option is simply typed lambda calculus (seriously)
03:24:52 <Gurkenglas> athan, I won't have duplicates. I want to know how much "Too much RAM!" backlash from my project partners I can expect if I try storing the file of numbers and char entries in a map.
03:25:02 <waressearcher2> what are "servant" and "stack" in short ?
03:25:52 <athan> Gurkenglas: If you lazilly fold over the file's contents, building / insterting on top of the accumulated map, you should be good :)
03:26:34 <mostalive> Gurkenglas: is your dataset larger than can easily fit in RAM, or are your partners suffering from premature optimization?
03:26:41 <Gurkenglas> The map is supposed to stay in memory and answer requests of the form "What's in this range?"
03:26:46 <fizruk> waressearcher2: servant is a collection of libraries around type-level DSL for HTTP API (see http://haskell-servant.github.io)
03:26:49 <bennofs> waressearcher2: stack is a package manager replacing cabal-install with better support for multi-package projects and stackage integration and in general more of a "do what I mean" approach (ex.: I believe stack build will install deps into a sandbox and build automatically)
03:27:33 <bennofs> waressearcher2: it can also automatically download required GHC versions on a per-project basis for you
03:28:26 <Gurkenglas> mostalive: It fits into RAM, it might fit twice, and it probably doesnt fit ten times.
03:28:57 <athan> Is Data.Map.mapKeys hylomorphic?
03:29:15 <bennofs> athan: what does hylomorphic mean? :o
03:29:57 <athan> bennofs: liek, it has to build another structure entirely while collapsing the existing one
03:30:16 <mostalive> Gurkenglas: I see.
03:30:19 <Gurkenglas> I guess "There is a hylomorphism that does it", like with isomorphic?
03:30:21 <bennofs> athan: yes, since it needs to reorder
03:30:44 <bennofs> athan: if you don't want reordering, you need mapKeysMonotonic
03:31:00 <athan> the way I see it, it's something like O(n^2) in terms of space (if the sizes of the lists are the same)
03:31:07 <athan> bennofs: Oh woah, okay
03:31:39 <bennofs> athan: well, it can change the ordering of the elements in the map, so the tree structure needs to be rebuilt. there's no way to avoid that
03:31:43 <Gurkenglas> athan, quadratic space for a Map? What? Surely you're mistaken.
03:32:14 <athan> Gurkenglas: Well, I'm still new to using hylo obviously, but you don't really tend to use it for homomorphic-style reasoning purposes, like isomorphism
03:32:33 <athan> but more as a description of the action? Idk, I bet catamorphisms distribute or something
03:32:57 <athan> bennofs: mapKeysMonotonic can reorder?
03:33:05 <Gurkenglas> Even if you mean the space you'd need to implement mapKeys, just doing inserts is already n*log n time and n space
03:33:35 <vlatkoB_> Is it safe to assume that if I have List or Map (A) with some values (Text,Record,...), that other Maps and Lists getting the values directly from A, will have only pointers to A value, not the full copied A value?
03:33:37 <bennofs> athan: no, it doesn't reorder. It just expects that your key-mapping is monotonic: forall a,b,  a < b implies f a < f b
03:33:50 <athan> that makes sense
03:34:09 <athan> so mapKeysMonotonic is O(1) in space?
03:34:30 <athan> I think I was wrong about Map.mapKeys being quadratic Gurkenglas - it might just be a normal catamorphism
03:35:26 <athan> mapKeys f xs = foldMapWithKeys (\k v -> Map.singleton (f k) v) xs
03:35:50 <athan> making it O(n) (?)
03:36:10 <bennofs> athan: I don't get what O(1) in space means here. You have the old map, and you get the new map, which is of the same or smaller size. But this applies to both mapKeys and mapKeysMonotonic
03:36:39 <athan> ahh you're right, it's not clear what I'm measuring
03:36:47 <athan> I'm not very familiar with space notations
03:37:10 <athan> maybe with `t` as a time variable would be useful
03:37:34 <athan> and `n` being the size of the Foldable you're using as input
03:38:17 <bennofs> athan: the thing is, mapKeysMonotonic already knows the "shape" of the resulting tree. It can therefore build it bottom-up, and never needs to rebalance, so every node only needs to be built once
03:38:18 <athan> then `mapKeys` would actually be `n` in size for all `t`, if you manage to build the same size of structure as you're breaking it down
03:38:25 <harry_hill2> The definition of reverse is `rev []  a = a  ; rev (x:xs) a = rev xs (x:a)` . Why doesn't this stack overflow on the increasing accumulated data structure? My confusion comes from being unsure when something like (x:a) goes on the evaluation stack, or the heap?
03:39:10 <athan> bennofs: Exactly, that's my point - you don't really need to break anything down, it's just a hard mapping preserving the data's structure
03:39:12 <bennofs> athan: mapKeys doesn't have that advantage. Therefore, it might be that it needs to do some tree rebalances, which means throwing away already built nodes and rebuilding them (since their child "pointers" change, you need to built a new node)
03:39:28 <athan> so you don't need to allocate any space for the time of execution
03:39:52 <athan> hmm
03:40:05 <bennofs> athan: you need to allocate exactly as much space as the old map had, since you need to go through each node and build a new one, with a replaced key + children pointer
03:40:34 <athan> hmm
03:40:43 <bennofs> athan: mapKeys might allocate a little bit more space though, since it also builds things that can be GCed afterwards
03:40:51 <athan> sorry, I just don't know what to say :)
03:42:07 <fizruk> harry_hill2: this does not stack overflow because there is no call stack in haskell, iiuc
03:42:14 <bennofs> oh, I just realized why my plan to stream a lazily-built map didn't work (basically, build a huge map that is never fully in memory while processing): maps are *always* spine-strict! :/
03:42:33 <harry_hill2> fizruk: I was meaning the evaluation stack.
03:43:23 <harry_hill2> https://wiki.haskell.org/Stack_overflow
03:44:27 <athan> bennofs: Those are just the lookup names though, right? If there's no way to delete while you're accumulating, like a commutative operation, you might be screwed :
03:44:29 <athan> :\
03:46:21 <bennofs> Gurkenglas: I think we can estimate IntMap's space requirement: if you look at http://hackage.haskell.org/package/containers-0.5.6.3/docs/src/Data-IntMap-Base.html#IntMap, we've got: per 'Bin' constructor, you've got 1 (header) + 4 (payload) words, per Tip constructor you have 1 (header) + 2 (payload) words and a Nil constructor takes 1 word
03:46:39 <bennofs> Gurkenglas: a word is 8 bytes (64bit) on 64bit systems
03:48:52 <bennofs> Gurkenglas: so we've got 3 * n  (for all the tip constructors) + the Bin constructors overhead   words of overhead
03:50:34 <julianleviston> can anyone recommend a good place to start with FRP in haskell?
03:50:51 <bennofs> Gurkenglas: If we assume a completely balanced tree with 2^n nodes, then the number of bins is: n/2 + n/4 + n/8 ... + n/n     (n/2 for the "first" layer, then n/4 for the second layer and so on till the root where we've got 1 bin)
03:50:53 <julianleviston> I’m not really new to FRP, just FRP on haskell
03:52:01 <bennofs> Gurkenglas: oops sorry, I meant to say: if n = 2^m nodes 
03:55:24 <bennofs> Gurkenglas: so, according to the formula for geometric series, we end up with: number of bins = n * (1 - 0.5^n) / 0.5 = 2n * (1 - 0.5^n)
03:56:25 <bennofs> Gurkenglas: so we've got at most about 5 words of overhead per map entry (this is not exact, since not all trees are balanced and there are also nil nodes in those unbalanced etc)
03:57:27 <srhb> Remind me, what's the point of MR affecting point-free names but not pointed ones?
03:58:00 <waressearcher2> for C language there is kernigan&richi book written by creators  themselves, for C++ language there is also a C++ book written by creator, is there similar book for haskel ?
03:58:16 <srhb> waressearcher2: Nope.
03:58:28 <srhb> waressearcher2: Feel free to read the language report though :)
03:58:34 <bennofs> srhb: with pointed ones, it's clear that something is a function. With pointfree ones, one might assume that something is a value while actually it is not (due to the additional directory being passed), which changes memoization behavior
03:58:55 <srhb> bennofs: Hmm. I'll let that simmer for a while and see if it clicks. Thanks.
04:00:00 <julianleviston> I decided to look at Reactive Banana
04:00:43 <bennofs> Gurkenglas: seems I've made a mistake in my calculation, or Data.Map.IntMap changed recently: http://blog.johantibell.com/2011/06/memory-footprints-of-some-common-data.html :/
04:10:57 <breadmonster> Hey geveryone.
04:11:38 <breadmonster> How do I implement type level natural numbers?
04:12:23 <breadmonster> In particular, how do I implement the usual numeric functions?
04:12:27 <fizruk> breadmonster: data Nat = Z | S Nat ? with DataKinds
04:12:42 <breadmonster> `data Z; data S a = S a` is fairly simple.
04:12:43 <fizruk> breadmonster: type families, I think
04:13:49 <fizruk> breadmonster: type family (n :+ m); type instance (Z :+ m) = m; and so on
04:13:55 * hackagebot reflex-transformers 0.2 - Collections and switchable Monad transformers for Reflex  https://hackage.haskell.org/package/reflex-transformers-0.2 (saulzar)
04:14:39 <breadmonster> fizruk: So can you do divisibility too?
04:14:41 <orion> For the people who use Haskell professionally, what ticketing system do you use?
04:15:03 <absence> with a squint, can mconcat be seen as a generalisation of filter?
04:15:20 <breadmonster> :t mconcat
04:15:21 <lambdabot> Monoid a => [a] -> a
04:15:25 <breadmonster> :t filter
04:15:27 <lambdabot> (a -> Bool) -> [a] -> [a]
04:15:31 <breadmonster> absence: No?
04:15:55 <silver> orion, https://www.targetprocess.com/
04:16:05 <absence> breadmonster: i may have been thinking of a somewhat more specific case of foldMap :s
04:16:13 <fizruk> breadmonster: well, I am not sure
04:17:18 <absence> breadmonster: foldMap combined with a predicate that chooses mempty or the monoid value
04:17:29 <fizruk> breadmonster: you can make type checker to infer the division from multiplication, but it only will work for even divisions
04:17:34 <merijn> absence: foldMap where instead of returning False you return mempty would be like filter, yes
04:17:59 <merijn> absence: Since mappend mempty is the identity operation
04:18:04 <fizruk> breadmonster: you also could go through value-level division and get an existential Nat
04:19:09 <fizruk> breadmonster: there might be some way to perform division at type level, but I am not sure. GHC.TypeLits does not have division
04:22:09 <absence> is there a "(dis)advantage" to foldMap with predicate vs filter followed by mconcat?
04:23:15 <Like> can u help me define function last
04:23:16 <Like> last :: [a] -> a
04:23:55 <kriztw> Like: what have you tried?
04:24:24 <merijn> absence: I shouldn't think so
04:24:29 <Like> i said last [x] = x
04:24:46 <quicksilver> that;s a good start Like
04:25:06 <absence> merijn: just subjective huh? ok, thanks :)
04:25:13 <Like> now i need to do a recursive function
04:25:32 <Like> last (x : y) =....
04:25:48 <merijn> absence: Well, I'm not confident it can't ever possibly be less efficient, but I don't see why it ever would be...
04:25:55 <kriztw> Like: the [x] part is a pattern match, it matches the pattern of a list containing a single element, and names the element x
04:26:03 <Like> yeah
04:26:19 <kriztw> but you would like to match a list containing one _or more_ elements
04:26:33 <kriztw> which is more general
04:26:36 <absence> merijn: that's fine, just wondered if there was some obvious advantage to one or the other
04:26:46 <Like> yeah
04:27:39 <kriztw> That pattern looks like: last (x : xs) = ...  -- (:) is the list constructor, so it matches a list with at least one element x, and names the rest of the list xs
04:27:52 <Like> yes
04:27:56 <Like> its done this part
04:28:00 <julianleviston> Like: the trick is working out how to reduce the list into a smaller list.
04:28:27 <Like> true julian
04:28:39 <julianleviston> Like: and you’ve kind of already done that with the (x:xs) pattern match
04:28:53 <julianleviston> Like: xs is a smaller list than the whole argument, after all.
04:29:02 <Like> yes
04:29:53 <julianleviston> Like: so… if I pass you [1,2,3], then that’ll match to (x = 1, xs = [2,3])… so you know x isn’t the answer… the answer is IN xs, but it’s NOT xs…
04:30:09 <Like> y
04:30:10 <julianleviston> Like: this is a hint to your recursion…
04:31:44 <quchen2> Can I use certain environment variables in my cabal config, such as $HOME?
04:31:58 <quchen2> (And others, should they be in env)
04:32:08 <nbrader> lispy, you there?
04:32:13 <fizruk> quchen2: why would you want that?
04:32:37 <quchen2> fizruk: To make my dotfiles compatible with multiple compuers
04:32:48 <quchen2> e.g. world-file: $HOME/.cabal/world
04:33:22 <julianleviston> Like: you pretty much just have to pass that smaller list back into the function… yeah?
04:33:38 <Like> y
04:33:50 <julianleviston> Like: do you mean “why” or “yes”? :)
04:33:59 <nbrader> has anyone managed to get SDL-gfx working on windows?
04:34:45 <Like> why
04:34:52 <julianleviston> Like: ok...
04:35:42 <fizruk> quchen2: I know nothing about world-file, but using environment variables in .cabal sort of defeats the idea of portability, no?
04:36:03 <julianleviston> Like: so… if I give you the list [1,2,3]… and all you have is a case that can give you the “last” for a 1-element list… what do you need to do to the list to make it fit into the one element list shape?
04:36:17 <quchen2> I think not having environment variables also defeats the idea of portability.
04:36:36 <quchen2> Such as in my case, because on this laptop my username is different from the one on my home laptop, so I cannot share .cabal among them.
04:36:49 <quchen2> cabal upda >>> permission denied
04:37:07 <Like> remove 1 and 2
04:37:12 <julianleviston> Like: yep.
04:37:14 <Like> and stay with the 3
04:37:17 <julianleviston> Like: but that’s two steps
04:37:32 <julianleviston> Like: no no you’ve already got a case that will give you the 3… when it’s reduced to [3]
04:37:45 <fizruk> quchen2: sorry, I don't understand the issue, cabal does not depend on username
04:37:47 <Like> i said last [x] = x so the 3 part is done i think
04:37:55 <julianleviston> Like: recursion is when you call the function itself again, usually with less data.
04:38:01 <julianleviston> Like: yep. exactly.
04:38:12 <julianleviston> Like: so the FIRST step… when I hand you [1,2,3] is?
04:38:16 <Like> no i need to reduce the list
04:38:19 <quchen2> fizruk: There are paths hardcoded into .cabal/config, and those depend on the username.
04:38:34 <quchen2> e.g. world-file, extra-prog-path.
04:38:34 <Like> i need to remove 1 first
04:38:38 <julianleviston> Like: bingo
04:38:39 <Like> then recursion
04:38:43 <julianleviston> Like: and yep
04:39:01 <julianleviston> Like: so if you pattern match (x:xs) on the list, x is “the first item”, right?
04:39:08 <julianleviston> Like: and xs is “the rest"
04:39:09 <Like> y
04:39:31 <julianleviston> Like: so you don’t need to remove it, that pattern match already does it for you… you then just need to pass “the rest” into a call to the function again… yeah?
04:39:46 <Like> yes
04:39:51 <julianleviston> Like: and what will that do?
04:39:58 <samvher> Hi. I'm looking to connect to a SQL database, with the ability to pass literal queries. Is HDBC still the go-to library for this as described in real world haskell or are there better libraries these days?
04:40:05 <julianleviston> Like: it’ll pass [2,3] back into the function… right? then what will happen?
04:40:15 <Like> then
04:40:23 <Like> i it will passe 3 to the function
04:40:28 <julianleviston> Like: nope
04:40:38 <Like> like i have [2,3]
04:40:41 <Like> recursive again
04:40:47 <Like> i'lll stay with 3
04:40:51 <Like> and its my answer
04:40:51 <julianleviston> Like: when you pass the function [2,3] iti’ll match on (x = 2, xs = [3])
04:40:52 <julianleviston> Like: yep.
04:41:00 <julianleviston> Like: perfect
04:41:05 <fizruk> quchen2: okay, .cabal/config is cabal-install configuration, while package.cabal is package configuration using Cabal format
04:41:23 <Like> the problem here is i dont know how i remove them
04:41:25 * samvher slaps a4j around a bit with a large fishbot
04:41:34 <julianleviston> samvher: how about this? https://github.com/Gabriel439/post-rfc/blob/master/sotu.md
04:41:46 <julianleviston> samvher: I’m interested to know whether Groundhog is any good, too...
04:42:00 <julianleviston> samvher: that post includes a section on DBs.
04:42:14 <samvher> ah great I'll have a look at that, thanks. I saw it before but didn't think of it
04:42:20 <julianleviston> Like: you already are removing them… (x:xs) splits and matches...
04:42:20 <fizruk> quchen2: they serve different purposes, so if you have troubles using package.cabal on a different machine — probably cabal-install is broken on then machine
04:42:31 <delYsid> Does the prelude have a list element update function like \n x xs -> take n xs ++ [x] ++ drop (n+1) xs ?
04:42:57 <fizruk> delYsid: no, you should not use lists for that
04:43:21 <julianleviston> Like: (x:xs) will match “any element of more than 1 item” because you have your [x] already set up, and it will pull the head of the list off and put it in x, and put the tail into xs.
04:43:36 <fizruk> delYsid: if you need update things by index, use Data.Map, Data.Vector or something else
04:43:41 <samvher> Hmm I will need to connect to a MSSQL server so I'll have to look for that specifically
04:43:44 <delYsid> fizruk: Any other reason then performance?
04:43:45 <Like> yes
04:43:46 <julianleviston> delYsid: there’s something in Data.List for it, I think.
04:44:08 <julianleviston> fizruk: let’s assume he’s capable of making his own choices.
04:44:37 <quchen> fizruk: Hm. Maybe. I just broke my local config by pulling from Github. :-\
04:44:46 <quchen> And all it did was overwrite the cabal config.
04:45:03 <julianleviston> samvher: ah… that’s… unfortunate, possibly.
04:45:12 <julianleviston> Like: so do you understand it?
04:46:25 <samvher> julianleviston: it is, I wish it was different :) but HDBC has ODBC bindings which I've used with python so I'm still hopeful. It's the only hit I can find on haskell mssql though
04:46:51 <Like> i'm like this https://gyazo.com/4cd09f520320a443ff5358ae7acb6de2
04:47:02 <quchen> fizruk: Hmm, it seems like I can use $prefix to mean $HOME/.cabal
04:47:17 <quchen> Which is even more what I want, since $prefix is set by Cabal itself, and not in the config
04:47:22 <quchen> … I think
04:47:31 <julianleviston> Like: so you don’t want to write the second definition yourself?
04:48:43 <fizruk> delYsid: julianleviston: well, if you want random-access update on lists, most likely you either don't want lists or don't want random-access update. it more interface than performance-related
04:48:44 <Like> can i say remove x : ( last y)
04:48:59 <julianleviston> fizruk: agreed.
04:49:19 <julianleviston> Like: think infinitely.
04:49:38 <julianleviston> Like: if I pass that function [1,2,3,4] what happens?
04:49:48 <julianleviston> Like: I’ll message you privately.
04:55:13 <absence> is there something in the library that converts "Monoid a => Maybe a" to "Monoid a => a", substituting mempty for Nothing?
04:55:39 <quicksilver> the point at which I start writing (take n xs ++ [x] ++ drop (n+1) xs) is the point at which I switch from lists to something else
04:55:44 <quicksilver> but, since you asked
04:55:57 <quicksilver> > "hello" & ix 2 .~ 'X'
04:55:59 <lambdabot>  "heXlo"
04:56:11 <quicksilver> :t fromMaybe mempty
04:56:13 <lambdabot> Monoid a => Maybe a -> a
04:56:16 <quicksilver> absence: ^^
04:57:48 <absence> :t foldMap (fromMaybe empty)
04:57:49 <lambdabot> (Foldable t, Monoid (f a), Alternative f) => t (Maybe (f a)) -> f a
04:58:00 <absence> :t mconcat . catMaybes
04:58:01 <lambdabot> Monoid c => [Maybe c] -> c
04:58:20 <quicksilver> absence: empty not mempty, was that a typo ? 
04:58:27 <absence> yes
04:58:28 <quicksilver> you'll get a simpler type with mempty
04:58:31 <absence> :t foldMap (fromMaybe mempty)
04:58:32 <lambdabot> (Foldable t, Monoid m) => t (Maybe m) -> m
04:58:51 <absence> nice, thanks
04:59:02 <muzzle> hi
04:59:16 <muzzle> can anyone help me with achieving this (Fractional a) => a -> Double ?
04:59:33 <quicksilver> muzzle: try using "realToFrac"
04:59:35 <julianleviston> muzzle: have you looked in hoogle?
04:59:41 <obadz> Is there a Rational -> Maybe Int function that will give me an Int if the rational has remainder 0 ?
05:00:10 <muzzle> quicksilver: doesn't work already tried it
05:00:23 <muzzle> julianleviston: already have
05:00:31 <quicksilver> muzzle: right, because it only works on Real 'a's
05:00:37 <quicksilver> but still it's the closest you can get
05:00:49 <quicksilver> Fractional includes Complex
05:01:03 <quicksilver> obadz: just check if the denominator is 1?
05:01:23 <obadz> quicksilver: is it always "reduced" ?
05:01:26 <quicksilver> yes
05:01:30 <quicksilver> https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Ratio.html
05:02:57 <fizruk> :t realToFrac
05:02:58 <lambdabot> (Fractional b, Real a) => a -> b
05:03:57 * hackagebot yesod-auth 1.4.8 - Authentication for Yesod.  https://hackage.haskell.org/package/yesod-auth-1.4.8 (MichaelSnoyman)
05:04:00 <delYsid> fizruk: You're probably right.  I am thinking about the list update thing because I fail to see the probably obvious correct solution.
05:04:20 <fizruk> delYsid: what are you trying to do?
05:04:57 <obadz> I don't see a Ratio a -> (a, a) function that gives you both parts though
05:05:26 <quicksilver> obadz: just call numerator and denominator separately :)
05:05:36 <quicksilver> obadz: but to answer your question you only need the denominator
05:05:39 <obadz> makes pattern matching more annoyting ;-)
05:05:47 <quicksilver> not really
05:05:48 <obadz> k thx
05:05:55 <quicksilver> case (numerator a,denominator a) of ....
05:05:56 <quicksilver> if you like :)
05:06:08 <bennofs> :t (%)
05:06:10 <lambdabot> Integral a => a -> a -> Ratio a
05:06:24 <obadz> bennofs: it's not a constructor
05:06:32 <obadz> (in case that's where you were going)
05:06:42 <bennofs> obadz: Yeah, just wondering, you're right, it's not
05:06:54 <quicksilver> the constructor is hidden to stop you breaking hte invariant
05:07:11 <delYsid> fizruk: flat mapping over a nested list, preserving the structure/order of elements, but "visiting" them in a order which is different from how they are arranged in the lists...  In C, I'd just sort a container of pointers to the elements, and iterate over that pointer container, updating the actual elements as desired.  However, In FP, I dont have destructive modification, and I dont have pointers either.
05:08:59 <delYsid> So I was thinking: Reinvent pointers by a list of indices.  So an element in my nested list ([[[[a]]]]) could be addressed like (Int, Int, Int, Int).  If I now had a list update function, I could just do what I want, but it feels *very* cumersome.
05:09:54 <quicksilver> better than [[[[a]]]] indexed by (Int,Int,Int,Int)
05:09:57 <quicksilver> is just to use
05:10:02 <quicksilver> Map (Int,Int,Int,Int) a
05:10:12 <quicksilver> which has more efficient update anyway
05:11:07 <delYsid> quicksilver: I dont need a in there, I want to preserve original structure, only update elements.
05:11:13 <jgx> Hi
05:11:24 <jgx> How do you manipulate lists with lenses ?
05:11:31 <fizruk> delYsid: then Vector?
05:11:43 <jgx> For example I have a record containing a list, I want to add/remove element from this list
05:12:38 <fizruk> > ("hello", 23) & _1._head .~ 'H'
05:12:39 <lambdabot>  ("Hello",23)
05:13:23 <jgx> MyRecord { myList : [Foo] } 
05:13:23 <jgx> I made a lens to access myList, but now I don't know what to do to append an element in the list 
05:13:23 <jgx> or to search a particular item in the list and then replace it with a new one
05:13:31 <delYsid> Gah, this is so ugly that I dont *want* to write it :-)
05:14:26 <julianleviston> jgx: pretty sure there’s a list append operation in lens
05:14:36 <delYsid> fizruk: For what, exactly?  For the address quadruple?
05:14:42 <jgx> julianleviston:oh ? :o
05:14:44 <fizruk> delYsid: four nested lists look suspicious to me anyway, probably the problem is a few levels higher
05:14:58 <bennofs> julianleviston, jgx: no, just write  over myListLens (++ someOtherListToAppend) 
05:15:25 <delYsid> fizruk: I'm afraid that is the input I am dealing with.
05:15:26 <bennofs> Or if you prefer the operator version:  myListLens <>~ someOtherListToAppend
05:15:29 <jgx> bennofs:Is there a function name for "++" ?
05:15:41 <fizruk> jgx: append?
05:16:13 <delYsid> I am parsing a format that has been invented roughly 120 years ago, I am afraid people didn't care to design stuff such that it is easy to program back then :-)
05:16:14 <julianleviston> fizruk: where is “append” defined??
05:16:31 <quicksilver> delYsid: just because you're parsing it doesn't mean you have to model it as nested lists
05:16:43 <fizruk> julianleviston: that is the "name" for ++, I might have misunderstood the quesion though
05:16:44 <julianleviston> delYsid: can you “translate it” into your own format to work with and then write it back?
05:16:46 <quicksilver> delYsid: your parser, you can define how you hold the data?
05:16:58 <julianleviston> fizruk: I think s/he was asking for a non-operator version of it.
05:17:10 <jgx> julianleviston:exactly
05:17:18 <julianleviston> jgx: I don’t think so.
05:17:21 <jgx> As I'm new to haskell I like to be very explicit with the functions
05:17:26 <quicksilver> jgx: you can call it mappend, but mostly people call it ++
05:17:28 <fizruk> jgx: there is no direct alias, mappend is close enough though
05:17:45 <jgx> fizruk:There isn't an alias at all ? :o
05:17:59 <jgx> weird that we haven't the choice
05:18:00 <bennofs> jgx: no. there's also no alias for (+), (
05:18:03 <fizruk> jgx: no, just like there is no alias for + * /
05:18:15 <quicksilver> > ([0,1,2,3],88) & _1 %~ ([4,5]++)
05:18:17 <lambdabot>  ([4,5,0,1,2,3],88)
05:18:18 <julianleviston> Isn’t mappend from monoid? is it in prelude?
05:18:28 <quicksilver> ^^ jgx modifying a list in a field
05:18:30 <jgx> fizruk:Ok, I'll assume that (++) is a common operator so :D
05:18:33 <bennofs> with GHC 7.10 (not sure about 7.8), it's in Prelude
05:18:36 <julianleviston> jgx: it is.
05:18:58 * hackagebot threads-supervisor 1.0.4.0 - Simple, IO-based library for Erlang-style thread supervision  https://hackage.haskell.org/package/threads-supervisor-1.0.4.0 (AlfredoDiNapoli)
05:18:59 <delYsid> Hmm, this channel keeps telling me I shouldn't be doing what I do.  Thats interesting, since I have roughly 5 years of domain knowledge about the format I am dealing with.  I totally understand that I could be off here and there, but talking to you guys feels like I am a completely misguided little child :-)
05:20:06 <fizruk> delYsid: we don't know the problem you're dealing with
05:20:21 <quicksilver> delYsid: please don't take it that way. You obviously understand the format, but just because the format is what it is doens't mean [[[[a]]]] is the right haskell data structure to use
05:20:24 <bennofs> :t fold `asAppliedTo` Nothing
05:20:25 <julianleviston> delYsid: it’s quite possible you haven’t explained what you’re trying to do well enough :)
05:20:26 <lambdabot> Monoid b => Maybe b -> b
05:20:29 <bennofs> absence: ^^^
05:21:14 <fizruk> delYsid: and so we only can give you advice from what you've told us + our own experience
05:21:18 <julianleviston> delYsid: linked lists are not very efficient for much. You obviously know this.
05:21:22 <absence> bennofs: cute
05:21:28 <absence> :t asAppliedTo
05:21:29 <lambdabot> (a -> b) -> a -> a -> b
05:21:49 <bennofs> absence: I only used asAppliedTo to get the correct type signature. You can just use fold in your coe
05:21:52 <bennofs> :t fold
05:21:53 <lambdabot> (Foldable t, Monoid m) => t m -> m
05:22:09 <bennofs> absence: it's a trick for "specializing" a type :)
05:22:19 <absence> i see
05:22:36 <bennofs> delYsid: you might want to look at Vectors or Arrays for this kind of stuff
05:23:20 <bennofs> delYsid: with vectors, you can "thaw" an existing vector, do mutable operations, and then freeze it again to get an immutable vector back. So you can have localized mutable vectors, which is quite nice
05:23:21 <delYsid> quicksilver: I am actually quite interesting in knowing about alternative representations.  A substantial part of my algorithm is based on that nested list structure, so if I use something different, I will have to go back and rewrite all that.  But still, mind to let me know what could be an alterative?
05:23:55 <absence> :t foldMap fold
05:23:56 <lambdabot> (Foldable t, Foldable t1, Monoid m) => t (t1 m) -> m
05:24:38 <frerich> delYsid: Just to recap (I hope you don't get frustrated by repeating yourself by now...): you're dealing with a tree of things and you'd like to update each tree node -- however, the order in which the tree nodes are updated depends on the values of the nodes. Does that sounds accurate?
05:24:42 <absence> > foldMap fold [Just "hello ", Nothing, Just "world"]
05:24:44 <lambdabot>  "hello world"
05:24:52 <absence> bennofs: thanks :D
05:25:02 <julianleviston> delYsid: what kind of tree is it?
05:25:09 <frerich> delYsid: E.g. if you have a tree of, say, names then you'd like to augment each name with some number (1, 2, 3) depending on the lexicographical ordering of all tree items?
05:25:41 <quicksilver> delYsid: well probably some kind of map giving quick access to the tiems for effeicient update
05:25:48 <quicksilver> so, possibly Data.Map
05:26:01 <julianleviston> quicksilver:  for a tree?
05:26:36 <fizruk> quicksilver: I think delYsid mentioned he wants to be able to go back to inital ordering of elements
05:26:39 <jgx> bennofs:it worked \o/
05:26:44 <delYsid> frerich: Yes, thats basically it, I think.
05:26:53 <julianleviston> delYsid: so what kind of tree is it?
05:27:24 <jgx> bennofs:But I'm not sure of what happen here : over todoListTodos (++ [todo]) todoList
05:27:41 <jgx> ++ takes a list and append it to another one ?
05:27:48 <julianleviston> jgx: yep
05:27:51 <fizruk> quicksilver: Data.Map won't allow to do that easily, right?
05:27:56 <julianleviston> > [1,2,3] ++ [4,5,6]
05:27:57 <lambdabot>  [1,2,3,4,5,6]
05:28:01 <fizruk> > "hello, " ++ "world!"
05:28:02 <lambdabot>  "hello, world!"
05:28:06 <jgx> ok
05:28:07 <julianleviston> jgx: it’s not efficient tho, because of singly linked lists.
05:28:15 <jgx> and over take a lamda as second parameter ?
05:28:25 <jgx> julianleviston:what's the alternative ?
05:28:37 <quicksilver> fizruk: well if might be that the Ord instance on (Int,Int,Int,Int) is the order he wanted. or not. Or it might be possible to choose it.
05:29:02 <fizruk> julianleviston: you have a more efficient ++? sorry, I might have missed something
05:29:19 <julianleviston> fizruk: depends how big your lists are
05:29:33 <tdammers> fizruk: I believe julianleviston is referring to alternatives for String
05:29:33 <julianleviston> fizruk: / I don’t know.
05:29:45 <julianleviston> tdammers: guh sorry :0
05:30:15 <julianleviston> jgx: just ignore me :)
05:30:18 <tdammers> if linked lists are a given, I don't think a more efficient drop-in replacement for ++ could be written
05:30:20 <fizruk> tdammers: oh, okay then
05:30:26 <delYsid> frerich: I have [[[[a]]]], and every a has some sort of a "length".  The innermost list is serial, one level above is parallel, then serial, and parallel again.  So I want to visit all of these items in the order that is defined by their respective lengths.  It is really just musical notes.  Every note has a duration, and I am trying to visit all these elements in the order that is being defined by their durations.
05:30:40 <jgx> julianleviston: If I want to decompose (++ [todos]), what would it be ? (\t -> t ++ [todo]) ?
05:30:43 <tdammers> but for Vector or Text or sth like that, there are more efficient concatenation functions
05:30:43 <freeman4> I've written down the reduction of `reverse` for [1..10]. Could someone tell me why the construction of the reverse list is put on the heap rather than on the evaluation stack. See: https://gist.github.com/anonymous/6ef9be9d8df3c8e06ac5
05:31:08 <julianleviston> jgx: sorry I’m not sure what you mean…. I’m pretty sure fizruk is better to ask tho! :)
05:31:09 <tdammers> also, if you can express your code in terms of cons-ing instead of concatenation, it'll also perform better
05:31:19 <freeman4> E.g. half way through, where the fold is at [1,2,3,4,5] , where is that held.. on the evaluation stack or on the heap?
05:31:54 <jgx> As I'm beginning with Haskell, I prefer to use explicit notation even if it's represent more characters :p
05:31:59 <jgx> To fully understand what I do
05:32:02 <fizruk> jgx: that "decompose" is called eta-expansion, but yes, those expressions are the same
05:32:15 <fizruk> :t (++ [1])
05:32:16 <lambdabot> Num a => [a] -> [a]
05:32:19 <jgx> fizruk:Ok, I'll eta-expand it :D
05:32:20 <julianleviston> delYsid: what do you mean by serial and parallel?
05:32:21 <jgx> thanks
05:32:24 <fizruk> :t (\t -> t ++ [1])
05:32:25 <lambdabot> Num a => [a] -> [a]
05:32:56 <tdammers> delYsid: oh, so this is music notation
05:33:00 <jgx> julianleviston:thanks for your help too ^^
05:33:10 <julianleviston> jgx: ohhhh THAT’s what you meant by “decompose” haha sorry :0
05:33:15 <fizruk> jgx: lists are usually given names with `s`: elements, values, xs, ys, as, bs
05:33:17 <quicksilver> freeman4: that question isn't about haskell - it's about one specific implementation of haskell.
05:33:29 <quicksilver> freeman4: GHC - which is what we mostly use - doesn't have an evaluation stack as far as I know.
05:34:13 <quicksilver> freeman4: I don't think that your reduction is right, either...
05:34:29 <freeman4> quicksilver: really? "When GHC is evaluating a thunked expression it uses an internal stack. This inner stack for thunk evaluation is the one that can overflow in practice." https://wiki.haskell.org/Stack_overflow
05:34:30 <tdammers> delYsid: I think I solved this particular problem by tagging every "event" with a reference (identifier) to the staff system and/or voice that it belongs to, then flattening them all into one huge list, iterating over it while dragging along and updating a list of "next absolute position per voice", tagging the events with positions as I went, and finally splitting them back up into voices
05:34:51 <jgx> fizruk:in the eta-expansion expression you meant ?
05:34:59 <quicksilver> freeman4: it uses the stack for thunk evaluation; it doesn't store values on it.
05:35:11 <fizruk> jgx: anywhere in the code
05:35:15 <freeman4> quicksilver: oops no it isn't, the int list should be in the carried state in \xs , (but I hope you get the idea)
05:35:29 <julianleviston> jgx: FYI there is more “expansion” possible… all lists expand to : … [] forms… (eg [1,2,3] = 1 : 2 : 3 : []) etc.
05:35:50 <julianleviston> jgx: it keeps going quite a lot. Haskell has a fair amount of “syntactic sugar"
05:36:30 <jgx> julianleviston:ok, I'll use more sugar when I'll be more familiar with the language for sure
05:36:56 <julianleviston> jgx: there’s no real point, though… because it’ll become very tedious… given for example that every single function is curried “under the hood”… 
05:37:32 <julianleviston> jgx: so (+) is (\x -> (\y -> x + y)) for example… (etc.)
05:37:51 <jgx> julianleviston:Yes, I try to stay pragmatic too :p
05:37:54 <delYsid> tdammers: Yes, its all about music notation.  In particular, I am trying to calcualte the real alteration from the key signature + accidentals present on individual notes.
05:38:27 <tdammers> yeah
05:38:33 <julianleviston> delYsid: oh… so you’ll listen to tdammers when s/he says “translate to an intermediate format, then back again”, but not me? lol ;-) ;-)
05:38:39 <tdammers> haha
05:38:39 <delYsid> To do that, I sort of need to visit all my voices sorted by time.
05:38:41 <julianleviston> delYsid: just poking fun.
05:39:12 <fizruk> delYsid: only per bar, right?
05:39:14 <frerich> delYsid: I concur with the sentiment that a deeply nested list of lists is not a good data structure for dealing with trees. A more common structure (e.g. the one in DAta.Tree) could be used to do something like: http://lpaste.net/142937
05:39:26 <freeman4> quicksilver: here's the correct reduction I think https://gist.github.com/anonymous/23011178f6fcfd1aa27d
05:39:42 <delYsid> julianleviston: I am struggling to keep up with the replies.  I am usually not whining, but man, I am blind!  It is not as easy as you might think, to digest all the various suggestions here :-)
05:39:42 <freeman4> dam, no it isn't!
05:39:42 <tdammers> well, again, one of the first steps after combining parts and voices into a composition, in my case, was to flatten the entire list of events in order to calculate absolute positions
05:39:53 <frerich> delYsid: t is a small tree (one item with two children) and t' is the same tree, but the nodes have been 'updated': the structure is preserved, but the nodes have their values changed depending on the lexicographical ordering of the abels.
05:40:00 <tdammers> also, fwiw, music notation is an incredibly complex subject
05:40:04 <fizruk> freeman4: you can't just get the last element of the list like that
05:40:14 <julianleviston> delYsid: It’s fine, I understand (having been subjected to “the flurry of craziness, and whirlwind of suggestions” before) :)
05:40:56 <julianleviston> I’m gonna go try and work out how I can build this software :) 
05:41:03 <fizruk> delYsid: so actually every one of those nested lists has its own purpose
05:41:18 <bennofs> delYsid: oh, so you have data Music a = Parallel [Music] | Sequential [Music] | Note Time a, and you want to "fold" over all the a's in their absolute time ordering?
05:41:26 <delYsid> frerich: Hmm, I'll have to think about this.  What turns me off about trees is, that my structure is not arbitrarily deep.  It is really just four nested lists, and thats it.  A tree would give me more, and I am not sure if I like that.
05:41:30 <fizruk> delYsid: like staff, bar, voice, etc.?
05:41:57 <delYsid> bennofs: Gosh, I couldn't have explained it better :-)
05:42:30 <frerich> delYsid: That's ok, you could have your own domain-specific tree (e.g. your 'Music' tree or so). I just used this for illustration purposes. The main point is that you have something to 'map' over, and the approach is to flatten your data structure, compute a new value for each element, and then build a new tree.
05:42:38 <delYsid> fizruk: Its actually specific to braille music.  We call it measure, voice, partial measure, and partial voice.
05:42:55 <freeman4> fizruk: quicksilver: OK here's the correct reduction https://gist.github.com/anonymous/6be244c54af376579484
05:43:01 <bennofs> delYsid: oh, and probably in each Sequential, the times are relative to the start of that Sequential chunk, right?
05:43:27 <freeman4> My question is: where do the intermediate lists go? E.g. [5,4,3,2,1] .. The heap?
05:43:35 <delYsid> bennofs: You so nailed the problem :-)  Yes, exactly.
05:43:54 <fizruk> freeman4: yes
05:44:32 <quicksilver> freeman4: everything on the heap, as I said before.
05:44:34 <freeman4> So the only thing the stack is used for is to compute (x:xs) ? I.e. the function passed to foldl?
05:44:54 <bennofs> delYsid: do you load the whole thing into memory anyway or do you need some kind of single-pass algorithm to stream it directly from disk and not even store everything? (no idea if that's even possible heh)
05:45:01 <quicksilver> the stack is just used to remember where it is in the calculation
05:45:07 <quicksilver> and store parameters to the arguments being used currently
05:45:08 <quicksilver> I believe
05:45:20 <quicksilver> *pointers!
05:45:33 <freeman4> quicksilver: I need to go and re-learn why stack overflows are a thing in GHC, then :-/
05:45:33 <quicksilver> store *pointers* to the arguments being used
05:45:38 <fizruk> freeman4: no, the only thing on stack is foldl application itself (which is exactly one every time you partially reduce)
05:45:41 <quicksilver> (the actual pointers being on the heap)
05:45:49 <quicksilver> the actual data being on the heap.
05:45:53 <quicksilver> I cannot type it seems.
05:46:05 <quicksilver> freeman4: just because you get too many stack frames
05:46:07 <delYsid> bennofs: Nah, its all in memory already.
05:46:13 <quicksilver> freeman4: none of it is data
05:46:20 <quicksilver> it's just the recursion
05:46:39 <quicksilver> although some people say that haskellc ompilers shouldn't limit recursion, they should just go with it and store the stack on the heap...
05:46:44 <freeman4> so GHC does not have a call stack, but it does have stack frames?
05:47:00 <quicksilver> I probably shouldn't call them stack frames
05:47:19 <quicksilver> there is a thing, when you enter a thunk, which records the pointers to the arguments being used for this evaluation
05:47:28 <quicksilver> and when you enter another thunk, you put another one on the stack
05:47:34 <quicksilver> it's not exactly like a stack frame for C++ or Java
05:48:01 <freeman4> quicksilver: OK, I think I understand.
05:48:22 <bennofs> delYsid: yeah, then I think the best idea is really to just collapse it down into a [Event] (tagged by absolute time, + [Index] where each Index tracks which entry in the corresponding Parallel/Sequential we went down to) (for sequentials, you just append, for parallels, you "merge"), then do your processing on that list, and then regroup
05:48:38 <delYsid> bennofs: Although I really just have [[[[a]]]], since the depth of the structure is fixed, so I didnt go for a sum type...
05:49:03 <tdammers> delYsid: one tip; write actual types now, instead of using just plain lists
05:49:13 <tdammers> delYsid: even if it's just newtype wrappers around lists
05:49:55 <bennofs> Parallel (Sequential (Parallel (Sequential a))) just looks nicer than [[[[a]]]] :)
05:50:42 <delYsid> bennofs: Hmm, OK, thats the "solution" I was thinking about.  It still looks/feels rather ugly, but I will try that.  Thanks for confirming my intuition!
05:51:16 <tdammers> it's more verbose, but in this case I would argue that's a good thing
05:51:20 <delYsid> bennofs: Yes, I get that.  However, it opens the road for a category of type errors I want to avoid...
05:51:35 <delYsid> Or, in other words, I dont want to pattern match for things which can never occur.
05:51:52 <tdammers> ?
05:52:00 <bennofs> delYsid: ah, my last example was refering to newtype Sequential a = Sequential [a], ...
05:52:06 <bennofs> delYsid: not the ADT representation
05:52:06 <tdammers> I'd think it'd do the opposite
05:52:23 <tdammers> produce type errors when you're trying to treat a Sequential as a Parallel
05:52:29 <tdammers> this is something you want
05:52:38 <fizruk> delYsid: data Measure a = Measure [Voice a]; data Voice a = Voice [PartialMeasure a]; data PartialMeasure a = [PartialVoice a]; data PartialVoice a = [a]
05:52:41 <tdammers> because it moves potential runtime bugs to compile time
05:52:48 <fizruk> delYsid: Measure a ~ [[[[a]]]]
05:52:57 <delYsid> tdammers: I use type synonyms already.
05:53:21 <tdammers> type synonyms don't give you that type safety though
05:53:29 <tdammers> you can still confuse them without being punished
05:53:33 <delYsid> fizruk: I have that, but just with type synonyms.
05:53:36 <Myrl> Is there a function with type `:: m a -> (a -> m b) -> m a` ?
05:54:16 * hackagebot witherable 0.1.3.1 - Generalization of filter and catMaybes  https://hackage.haskell.org/package/witherable-0.1.3.1 (FumiakiKinoshita)
05:54:20 <quicksilver> Myrl: just to ignore the b and return the a you got from the first action?
05:54:20 <bennofs> Myrl: I don't know of any. I agree that would sometimes be useful
05:54:34 <tdammers> type Distance = Double; type Duration = Double; type Speed = Double; mySpeed = (s :: Duration) / (t :: Distance) -- typechecks just fine
05:54:47 <delYsid> tdammers: Point taken.  However, a [[a]] is always a PartialMeasure, so cunfusion is hard to achieve.
05:54:50 <Myrl> bennofs: Yeah, I need to use it right now, it's very useful for debugging!
05:54:59 <bennofs> :t \m f -> m >>= \x -> x <$ f x
05:55:01 <lambdabot> Monad m => m b -> (b -> m b1) -> m b
05:55:12 <Myrl> bennofs: Say, you want to print out what you've read.
05:55:20 <quicksilver> @pl  \m f -> m >>= \x -> x <$ f x
05:55:20 <lambdabot> (. ap (<$)) . (>>=)
05:55:21 <delYsid> tdammers: i.e., the nesting level is what differentiates the types...
05:55:29 <fizruk> delYsid: [[a]] also matches [[[[b]]]]
05:55:44 <quicksilver> fizruk: his a is concrete tho
05:55:47 <quicksilver> fizruk: so it doesn't
05:55:50 <tdammers> still
05:55:54 <quicksilver> his a is 'Note' or whatever
05:56:00 <quicksilver> it can't unify with [[b]]
05:56:11 <delYsid> fizruk: Oh, you're totally right of course, thanks!
05:56:11 <tdammers> I'd still at least newtype those lists
05:56:21 <bennofs> delYsid: ah, I was rather thinking newtype Parallel a = Parallel [a];  newtype Sequential a = Sequential [a];   Parallel (Sequential (Parallel (Sequential a)))
05:56:33 <tdammers> among other things, this would also allow you to define different Monoid instances for them
05:56:34 <fizruk> quicksilver: does not mean he does not have helper functions with [[a]]
05:56:45 <fizruk> quicksilver: where a is variable I mean
05:56:49 <tdammers> such that a Parallel implements <> as "merge", while a Sequential implements it as "concat"
05:57:23 <delYsid> bennofs: Thats a neat idea, I will look intot that.
05:57:34 <delYsid> Thanks guys, you've been a fountain of ideas.
05:57:41 <fizruk> tdammers: I guess all Monoid there would be "concat" though
05:58:16 <quicksilver> fizruk: nod
05:58:51 <Unhammer> I get such weird user times from haskell. 52s 51s 36s 52s
05:59:45 <tdammers> fizruk: hah, you're right
06:03:58 * dgpratt has been thinking about the penchant of Haskellers to use short variable names
06:04:21 <dgpratt> it's something I think I've almost come full-circle on
06:04:46 <dgpratt> like many others, when I first started learning Haskell, I found it hard to get used to
06:05:01 <tdammers> dgpratt: I'm thinking it's often a matter of operating at an abstraction level where there simply isn't a reasonably descriptive variable name; if you have to use meaningless names, might as well make them single-character ones
06:05:03 <dgpratt> but eventually I did and even went so far as defending the practice
06:05:20 <quicksilver> dgpratt: I still use long ones for values with large scope
06:05:21 <phadej> i agree with tdammers 
06:05:28 <dgpratt> tdammers, that much I can agree with *when it's true*
06:05:32 <quicksilver> dgpratt: top-level function names being the most obvious example
06:05:46 <quicksilver> but I defend the use of x in (\x -> (x,2))
06:05:47 <comerijn> The best argument for short variable names is that it's easier to see the "shape" of types/expressions
06:05:55 <quicksilver> (pls don't tell me about tuplesections, thx)
06:05:59 <tdammers> it's a balance
06:06:07 <dgpratt> but I often find when browsing Haskell code that abbreviated names are used when it would be better not to
06:06:09 <exio4> the smaller the scope the shorter the variable name
06:06:14 <quicksilver> agree exio4 
06:06:16 <frerich> dgpratt: For me, the scope of names also matters a lot, i.e. the larger the scope, the more important the name.
06:06:21 <tdammers> yeah, scope is an important factor
06:06:27 <exio4> @type x
06:06:28 <lambdabot> Expr
06:06:40 <tdammers> also, even a super short variable name can still be descriptive
06:06:53 <exio4> (x:xs) ? :P 
06:06:59 <quicksilver> also, in haskell I will avoid naming something I only use once - unless by giving it a name I am contributing useful information to the reader
06:07:02 <tdammers> in a map-like data structure context, 'k' for a key, 'v' for a value, and 'm' for a collection, are very common
06:07:15 <tdammers> x:xs is a super common convention, and it's fine
06:07:25 <tdammers> x, in general, as the main argument to operate on
06:07:33 <tdammers> n or i for iteration count
06:07:41 <dgpratt> m for monad
06:07:42 <frerich> Also, something like 'tmp' is equally expressive as 'dummyVariable' (a lesson I learned many many years ago when moving frm Pascal to C...)
06:07:47 <dgpratt> I think these are fine
06:07:48 <tdammers> f for a function
06:07:57 <exio4> f g h 
06:08:14 <Myrl> Hmmm...
06:08:16 <dgpratt> although someone should put up a wiki page documenting these :D
06:08:25 <Myrl> Attoparsec's impossible to debug. ._.
06:08:35 <tdammers> dgpratt: you think?
06:08:39 <frerich> dgpratt: I think the 'bigger' problem with Haskell is that it's so good at generalizing and abstracting things, that you end up factoring out a lot of crazy little functions -- and they all need names.
06:08:40 <tdammers> dgpratt: some of them are contextual though
06:08:55 <frerich> dgpratt: So you basically get forced to think about naming, but many people don't like that, and yeah - that's what you get. :-)
06:08:58 <tdammers> yes; one problem is that you operate on high abstraction levels a lot
06:09:09 <tdammers> higher abstraction levels -> harder to come up with meaningful names
06:09:13 <Myrl> Hmmm...
06:09:30 <tdammers> like, in an arbitrary fmap call, what do you call the second argument?
06:09:45 <phadej> tdammers: and then you look up math/greek/latin end end up with "kataAlgAnaColimit" or something like that
06:10:29 <dgpratt> for very abstract functions, you'll get no argument from me -- but sometimes I think Haskellers take too much license from that
06:10:40 <tdammers> in some cases, yes
06:10:50 <tdammers> Lens, I think, is a popular offender
06:10:57 <tdammers> especially when it comes to type vars
06:11:09 <dgpratt> Lens is pretty general, though
06:11:13 <tdammers> Lens s t a b -- come on, you can do better :D
06:11:29 <frerich> dgpratt: My secret suspicion is also that a lot of Haskell code comes from an academic environment, where you are writing papers about things and so on. So it's a very mathy-scientific approach, and the notation kind of fits I think.
06:11:51 <tdammers> Math is certainly an influence here
06:12:03 <frerich> dgpratt: but I would neve rcliam that in public without my asbestos underwear on to protect my private parts from the inevitable flame war.
06:12:10 <quicksilver> tdammers: you'd prefer Lens outer0 outer1 inner0 inner1 or ?
06:12:37 <tdammers> quicksilver: maybe. or something like outer outer' inner inner'
06:12:51 <quicksilver> I think the problem is that makes type signatures more forbidding to read
06:12:56 <quicksilver> I don't know why it would, but it does (to me)
06:12:56 <exio4> o o' i i' 
06:13:49 <tdammers> well, s t a b kind of works too, once you understand how the naming works - at least it's done consistently, which helps a lot
06:14:02 <fizruk> tdammers: I'm ok with s t a b: a and b are common for element type in a structure (like in f a, f b), s and t stand for "structure" for me.
06:14:13 <tdammers> yes
06:14:23 <fizruk> tdammers: and I don't like o o' because primes get lost...
06:14:25 <tdammers> also, the 's' is related to the s in State/StateT
06:14:45 <tdammers> and s -> t and a -> b are satisfyingly analogous
06:14:58 <fizruk> to be honest, I don't use lens in my everyday life, so my opion might not count :p
06:15:08 <exio4> tdammers: some people disagree! 
06:15:14 <quicksilver> (.~) :: ASetter outer0 outer1 inner0 inner1 -> inner1 -> outer0 -> outer1 
06:15:16 <quicksilver> vs
06:15:22 <quicksilver> (.~) :: ASetter s t a b -> b -> s -> t 
06:15:22 <tdammers> exio4: of course. Some people always disagree
06:15:42 <quicksilver> to me the shorter typevars are worth it, improves readability
06:15:45 <exio4> I remember people that had problems solving equations when the teacher changed the variable x to s <.<
06:15:45 <quicksilver> I think that is subjective
06:16:11 <tdammers> (.~) :: ASetter theOriginalContainer theNewContainer theOriginalElement theNewElement -> theNewElement -> theOriginalContainer -> theNewContainer
06:16:22 <exio4> alpha equivalence
06:16:38 <quicksilver> maybe tdammers; I think it's just what I'm used to
06:16:39 <blueonyx> tdammers: looks like java now :>
06:16:46 <tdammers> blueonyx: mission accomplished :D
06:16:54 <quicksilver> there is the fact that 'element' and 'container' are at best analogies there
06:17:28 <tdammers> yes and no
06:17:50 <tdammers> there's no reason why a Lens can't produce values out of thin air and throw them into a black hole
06:18:10 <quchen> blueonyx: Doesn't exceed 160 characters, can't be Java
06:18:28 <exio4> tdammers: well, there are a few laws..
06:18:43 <quicksilver> (.~) :: ASetter theOriginalElementFactory theNewElementFactory theOriginalElementObject theNewElementObject -> theNewElementObject -> theOriginalElementFactory -> theNewElementFactory
06:18:46 <frerich> For some reason, I also have the habit of using p and q when calculating the indices of some range in a list (e.g. 'p' is the index of the first colon and 'q' is the index of the next colon after that or so).
06:19:10 <blueonyx> > length "(.~) :: ASetter theOriginalContainer theNewContainer theOriginalElement theNewElement -> theNewElement -> theOriginalContainer -> theNewContainer"
06:19:11 <lambdabot>  145
06:19:12 <frerich> It only now occurs to me that 'q' comes after 'p', heh. I always though I do it because the letters are mirrored.
06:19:15 <aweinstock> frerich: I'd use i and j for that (p and q are primes, or logic formulae)
06:19:18 <tdammers> exio4: true...
06:19:24 <dgpratt> from a project I've been perusing http://lpaste.net/7434108525564919808
06:19:35 <dgpratt> I might guess that m = Monad, s = State?, a = value?, and d = ???
06:19:41 <frerich> aweinstock: 'i' and 'j' are -- in imperative languages -- things I use for nested loop counter variables.
06:20:06 <frerich> aweinstock: but yeah, I think I also use 'i' sometimes. I guess all hope is lost with any kind of naming if you're not consistent with it. :-)
06:20:28 <blueonyx> quchen: yea (.~) needs to be more descriptive
06:21:03 <aweinstock> frerich: probably both uses (indices and counters) are derived from FORTRAN inferring/defaulting i,j,k,l,m,n to integers, and everything else to floats?
06:21:57 <frerich> aweinstock: Ah yes, I heard about that. Actually, it's maybe kind of nice to "enforce" a naming to that degree (much like Haskell differs between identifiers with a capital letter vs. those witha  lowercase letter)
06:22:02 <fizruk> aweinstock: and that it turn comes from math, right?
06:22:21 <frerich> aweinstock: It kind of encodes a convention into the language. Maybe there should be a Haskell extnesion which enforces that e.g. x' has the same type as x :-)
06:22:21 <fizruk> aweinstock: except for l maybe
06:22:31 <frerich> aweinstock: And 'f' must be a function :-)
06:23:37 <fizruk> frerich: sometimes 'f' is a value of type `f a`
06:23:50 <aweinstock> :t map . curry
06:23:51 <lambdabot> ((a, b) -> c) -> [a] -> [b -> c]
06:24:05 <aweinstock> :t (map .) . curry
06:24:07 <lambdabot> ((a, a1) -> b) -> a -> [a1] -> [b]
06:25:34 <Sindriava> When will haskell wiki support ' in identifiers?
06:25:45 <Pro9> If you have an expression: match ('h':'a':'s':'k':'e':'l':'l':rest), can you do: match(hask:rest) .... where hask = 'h':'a':'s':'k':'e':'l':'l'  (dosent seem to work), or do it in some other betetr way?
06:26:31 <Sindriava> Pro9: Yeah, that doesn't really make sense. You might be able to use pattern synonyms :)
06:26:38 <fizruk> Pro9: use isPrefixOf or splitPrefix
06:26:51 <Sindriava> Derp, yeah, use what fizruk said
06:27:18 <Pro9> fizruk: Sindriava: Thanks, will look into isPrefixOf and splitPrefix
06:27:30 <fizruk> Pro9: it's stripPrefix, sorry
06:27:38 <fizruk> :t stripPrefix
06:27:39 <lambdabot> Eq a => [a] -> [a] -> Maybe [a]
06:27:55 <quicksilver> frerich: https://en.wikipedia.org/wiki/Hungarian_notation
06:28:48 <fizruk> > let match s = case stripPrefix "haskell" s of Just rest -> rest; Nothing -> "default" in match "haskell2010" -- Pro9 
06:28:50 <lambdabot>  "2010"
06:29:22 <frerich> quicksilver: Hm? :-) As somebody who gets paid to use the Win32 C API every day, I'm well aware of hungarian notation, ahem - but I'm not sure how that relates to what I wrote... :o)
06:29:29 <Pro9> fizruk: ahh, thanks!
06:29:52 <exio4> pattern guards might be kinda cool for this too
06:30:52 <quicksilver> frerich: well it's another naming convention, admittedly not enforced
06:31:25 <frerich> quicksilver: Oh well, yeah - and the x vs. x' convention is a form of hungarian notation, that's true
06:31:43 <quicksilver> > "haskell programmer" ^? prefixed "haskell"
06:31:45 <lambdabot>  Just " programmer"
06:32:14 <fizruk> > let match s | Just rest <- stripPrefix "haskell" s = rest; match _ = "default" in match "haskell2010"  -- Pro9  (with pattern guard)
06:32:14 <aweinstock> :t prefixed
06:32:16 <lambdabot>  "2010"
06:32:16 <lambdabot> (Eq a, Applicative f, Choice p) => [a] -> p [a] (f [a]) -> p [a] (f [a])
06:32:25 <frerich> quicksilver: but I thought that in the case of Fortran, the use of e.g. 'i' for integers was not a convention, it was actually required (to simplify the compiler or so)?
06:32:38 <frerich> quicksilver: I.e. it was basically syntax, more like the uppercase/lowercase difference in Haskell?
06:32:50 <frerich> quicksilver: This is just hearsay though...
06:32:54 <quicksilver> frerich: x vs x' notation is the way god tells you you are about to make a mistake, and you should be using a state monad or better abstraction.
06:33:20 <quicksilver> I don't know much FORTRAN so, dunno :)
06:33:41 <sgronblo_> Good evening, I would just like to express my feelings that stack was an incredibly poor naming choice for a tool...
06:34:09 <frerich> quicksilver: I suppose that makes me a heretic then!
06:34:18 * hackagebot OpenGLRaw 2.6.0.0 - A raw binding for the OpenGL graphics system  https://hackage.haskell.org/package/OpenGLRaw-2.6.0.0 (SvenPanne)
06:35:17 <aweinstock> frerich: I don't think it was required, just that if you didn't specify types, it defaulted to those specific ones
06:35:57 <aweinstock> frerich: (I guess that might be "to simplify the compiler", but Hindley-Milner wasn't invented for another decade)
06:38:01 <aweinstock> frerich: there's also an "implicit none" declaration that prevents type-defaulting, probably because it can cause obscure/subtle bugs when doing valid alpha-equivalence refactorings
06:40:10 <jgertm> is it possible to upgrade a diagram in V2 to V3? so that all points lie in the xy plane?
06:58:53 <fryguybob> jgertm: I don't think so, but there should be.  Try asking in #diagrams
07:01:37 <jstimpfle> is there a way in haskell to enforce non-recursive or at least non-mutually-recursive datatypes?
07:03:23 <srhb> jstimpfle: As in, have the compiler prevent you from making them?
07:04:05 <jstimpfle> yes
07:04:20 * hackagebot wavefront 0.3 - Wavefront OBJ loader  https://hackage.haskell.org/package/wavefront-0.3 (DimitriSabadie)
07:04:21 <srhb> jstimpfle: Nope.
07:04:29 <srhb> jstimpfle: Not in GHC at least.
07:05:01 <nbrader> I'm attempting to compile some haskell code and all it produces are .o and .hi files (not .exe)
07:05:12 <nbrader> what's going wrong?
07:05:18 <sgronblo_> in a project that has a cabal sandbox how can i make cabal copy the built executable to some "reasonable" /something/something/bin path? I tried both --user and --global but it seems to be installing to the sandbox in both cases.
07:05:28 <srhb> nbrader: How are you compiling and with which compiler?
07:05:28 <nbrader> I'm getting no error messages
07:05:32 <bartavelle> nbrader, are you compiling with cabal or stack ?
07:05:33 <nbrader> ghc
07:05:54 <nbrader> I'm using ghc --make [filename]
07:06:09 <quicksilver> that will make an executable only if it finds a module called 'Main'
07:06:17 <quicksilver> containing a function called 'main'
07:07:49 <hexagoxel> sgronblo_: `cabal install --bindir=whatever/bin --datadir=whatever/share`
07:07:58 <nbrader> thanks, though it seems it also works if you don't specify the file as being a module (unless this defaults to main)
07:08:15 <srhb> nbrader: Main is the default module, given no other name.
07:08:24 <nbrader> fair enough
07:08:27 <nbrader> thanks
07:08:53 <srhb> Important optimization for short Hello Worlds! :-)
07:08:57 <hexagoxel> sgronblo_: datadir is not always necessary, but safer (if any dependent package uses datadir and you ever (re)move sandbox)
07:09:04 <quicksilver> see also the flag -main-is
07:09:07 <quicksilver> nbrader: ^^
07:09:42 <joof> connect mozilla
07:09:51 <joof> derp
07:10:14 <sgronblo_> hexagoxel: it seemed to work, thanks
07:10:15 <exio4> srhb: well, it's handy for throw-away scripts 
07:10:50 <srhb> exio4: I'm not complaining :P
07:11:19 <exio4> srhb: heh
07:23:21 <bennofs> delYsid: hmm, I just had another solution to your problem: you could store the sequential chunks as Zippers, and store the "current time" for each sequential. Then, when you fold, you always start at the root, look which of the sequentials has the the earliest "next" time, and advance the zipper in that sequential by one. Then repeat. I don't know if that fully works out, but perhaps it's an interesting idea
07:23:23 <bennofs> to think about in case your unsatisifed with the event stream approach :)
07:25:27 <nbrader>     Couldn't match expected type `Linear.Affine.Point V2 CInt'
07:25:28 <nbrader>                 with actual type `V2 CInt'
07:25:34 <nbrader> any ideas what my problem is?
07:30:36 <nbrader> This is an question to anyone who recognizes the problem
07:32:36 <Ferdirand> nbrader: you are missing the P constructor ? (random guess)
07:33:10 <nbrader> Ferdira, suggested fix?
07:33:30 <nbrader> Ferdirand: suggested fix?
07:34:21 * hackagebot websockets 0.9.6.1 - A sensible and clean way to write WebSocket-capable servers in Haskell.  https://hackage.haskell.org/package/websockets-0.9.6.1 (JasperVanDerJeugt)
07:37:12 <nbrader> Ferdirand: I imported Point using "import Linear.Affine( Point( P ) )"
07:37:30 <Ferdirand> nbrader: the correct way is probably to use "relative origin" or somethig
07:38:01 <Ferdirand> or just stick P in front of the expression if you don't mind bypassing the neat typechecking of points vs vectors
07:38:06 <Ferdirand> i have no idea, i never used these
07:39:13 <nbrader> I'm trying to use the sdl2 pckage
07:40:07 <nbrader> the vector-space-points package seems to export relative and origin but I don't know if that's a dependency of sdl2 or not
07:40:19 <Ankhers> What is the difference between "eta reduction" and "pointfree"?
07:41:06 <merijn> Ankhers: eta reduction is the step of removing an extraneous parameter. Pointfree is a description of code that binds no variables
07:41:20 <merijn> Therefore eta reduction can make some expressions pointfree
07:41:43 <Ankhers> merijn: Thanks!
07:42:09 <merijn> But not all eta-reductions (in fact, most don't) result in pointfree code
07:42:19 <merijn> And not all pointfree code can be achieved through eta reduction
07:42:33 <Myrl> Is there a way to interactively find out where the hell I am in the IO monad?
07:42:49 <quicksilver> Myrl: what kind of answer are you expecting?
07:42:52 <merijn> Myrl: What do you mean by "where I am?"?
07:42:53 <quicksilver> what does 'where' mean for you?
07:43:01 <Myrl> Imagine gdb.
07:43:38 <Myrl> This code's taking precious time of my life.
07:43:43 <quicksilver> ghci has an interactive step debugger but, it's not easy to use because of haskell's evaluation model
07:43:52 <quicksilver> it is often not the easiest way to explore code
07:44:03 <quicksilver> although perhaps some people are better at it than me :)
07:44:03 <merijn> Oh...you wanna trace/debug code?
07:44:12 <Myrl> merijn: Yep.
07:44:17 <merijn> Myrl: Does the Debug.Trace module help?
07:44:30 <Myrl> merijn: Let me check that out.
07:44:41 <merijn> Full of unsafe goodness like "print in the middle of pure code" for debugging
07:45:41 <Myrl> merijn: Is there a step-by-step debugger? Since this won't be really helpful if I want to figure out what's causing the hangup.
07:45:54 <Myrl> I suspect that it's blocking I/O.
07:46:06 <merijn> ghci has an interactive debugger
07:46:12 <merijn> But I've never really used it
07:47:06 <glguy> jkbl/exit
07:48:22 <nbrader> I can't speak with confidence here, because I'm by no means very far into haskell and am still more used to programming languages like Python... but isn't the point of haskell to avoid using the 'live debugging' techniques common to stateful programming and instead split the problem up in a way that makes everything easily testable in isolation as a pure function?
07:48:52 <merijn> nbrader: Sure, hence why I've never used the ghci debugger :p
07:49:10 <merijn> nbrader: But some problems are hard, if not impossible to solve without interactive debugging
07:49:21 <bartavelle> yeah well, Debug.Trace is still useful :)
07:49:21 * hackagebot packer 0.1.9 - Fast byte serializer and unserializer  https://hackage.haskell.org/package/packer-0.1.9 (VincentHanquez)
07:51:04 <nbrader> I'm interested in moving to using haskell for my more interactive programs (hence why I'm currently fiddling with SDL2)
07:51:31 <Myrl> Ugh.
07:52:26 <nbrader> I'm anticipating that wherever my code gets close to the SDL2 bindings, things are going to be more well knotted with IO and require a little more interactive debugging
07:52:33 <nbrader> but I'm hoping to avoid that if possible
07:52:45 <quicksilver> nbrader: I don't know if that's the "point" of haskell, or at least not the only point, but certainly I normally find other ways to debug haskell.
07:54:32 <exio4> Myrl: nothing ASTs can't fix... 
07:54:37 <nbrader> Perhaps it's unfair to try and sum up a language as having a single point. Perhaps it's more fair to say the language is geared against mindless use of IO
07:54:40 <exio4> er, merijn * 
07:56:15 <nbrader> by which I mean, it makes you aware of impurity where it can and gives you access to the advantages of doing without it where you can
07:57:15 <nbrader> correct me if I'm not making sense :)
07:57:30 <steve_k_9> Could someone explain to me the difference between INLINEing `g` and not doing so in this gist: https://gist.github.com/anonymous/b3a65d399c443ddbb00e
07:58:04 <steve_k_9> That is, if k is strict on both its arguments.
07:58:04 <humanoyd> Is there a way with lens to remove parts of a structure, i.e. "remove _1 (1,2,3) === (2, 3)"?
08:03:41 <Myrl> Hmmm..
08:09:16 <steve_k_9> I don't follow this statement in the GHC docs: " if GHC decides a function is “too expensive” to inline, it will not do so" from https://downloads.haskell.org/~ghc/7.0.3/docs/html/users_guide/pragmas.html under "INLINE pragma".
08:09:23 <steve_k_9> When is a function "too expensive" to inline?
08:09:28 <Myrl> wtf...
08:09:30 <jophish> steve_k_9: if it's huge?
08:09:42 <jophish> (and used more than once)
08:10:08 <jophish> or perhaps even if it's just huge
08:10:15 <steve_k_9> jophish: how do you measure the "size"  of a function? And what's bad about inlining a huge function?
08:10:22 <exio4> code bloat 
08:10:35 <steve_k_9> exio4: And what's wrong with code bloat?
08:10:41 <jophish> steve_k_9: the size (in bytes) of the generated code
08:10:56 <jophish> steve_k_9: it could prevent good cache use
08:11:04 <Myrl> WOw.
08:11:14 <Myrl> I'm so shocked right now. I have no idea what the heck is happening.
08:11:25 <jophish> what's happening?
08:11:27 <steve_k_9> Myrl: ?
08:11:27 <merijn> Myrl: Do you have a small example to paste?
08:12:06 <quicksilver> humanoyd: well, you coul dhave a Lens which selects out the (2,3) portion, which amounts to the same.
08:12:21 <quicksilver> humanoyd: (there isn't a default lens for that particular permutation tho)
08:12:59 <steve_k_9> jophish: so the bad effects of code bloat is good cache use? I'd really like to understand what the negative impacts of bad cache use are. And indeed how GHC makes use of cache, and why inlining a huge function puts pressure on cache.
08:13:02 <Myrl> merijn: It uses Network.Socket.
08:13:13 <Myrl> It's so hard to debug it. =_=
08:13:51 <merijn> Myrl: Small example?
08:14:15 <merijn> steve_k_9: No, the bed effect of code bloat is your hot code loop being to big for the cache, causing slowdown
08:14:28 <Myrl> merijn: I don't know how to give a small example since it "works for the most part"
08:14:34 <Myrl> And the code's really intertwined.
08:14:45 <merijn> Myrl: Is the code on github or whatever? (and how many lines?)
08:14:57 <Myrl> merijn: I'll put it on github.
08:16:18 <Myrl> merijn: https://github.com/Myrl/Website
08:16:22 <merijn> steve_k_9: This isn't GHC or haskell specific. The bigger the produced binary, the smaller the chance that your hot code fits in the CPUs cache, thus causing CPU stalls while code is fetched from memory
08:16:37 <Myrl> merijn: Been trying to fix that since yesterday.
08:16:47 <steve_k_9> merijn: terrific thanks, that makes sense to me now.
08:16:47 <merijn> Myrl: What's the problem/error you're getting?
08:17:14 <Myrl> merijn: No error at all, it just *stops responding*.
08:17:28 <merijn> steve_k_9: Incidentally, this is why -Os (optimise for space) sometimes produces faster code than -O3 in gcc
08:17:32 <merijn> Myrl: After which part?
08:17:36 <Myrl> merijn: I tried running it through the debugger, but it wasn't really that helpful.
08:17:46 <Myrl> merijn: That's really the problem, there's no specific part.
08:17:54 <Myrl> merijn: As I said, "it works for the most part"
08:18:24 <Myrl> merijn: Once you load index.html, it will work for like 5 more requests then it just dies.
08:18:46 <Myrl> merijn: I'm experimenting with keep-alive.
08:19:39 <quicksilver> more log messages, myrl?
08:19:44 <quicksilver> that's how I'd expect to debug that
08:19:45 * hackagebot timeless 0.8.0.2 - An Arrow based Functional Reactive Programming library  https://hackage.haskell.org/package/timeless-0.8.0.2 (carldong)
08:19:47 <Myrl> quicksilver: Log messages won't help.
08:19:55 <quicksilver> log when you accept a connection, log when you start to serve a response
08:20:02 <quicksilver> when it "dies" is it accepting new connections?
08:20:03 <Myrl> quicksilver: Ah, right.
08:20:06 <quicksilver> is it consuming CPU?
08:20:09 <quicksilver> ...etc...
08:20:15 <Myrl> quicksilver: It's not accepting new connections since it's keep-alive.
08:20:45 <humanoyd> quicksilver: How would I do that?
08:22:35 <quicksilver> humanoyd: well it's easy enough to write a lens by hand. lens (\(a,b,c) -> (b,c)) (\(a,b,c) (b',c') -> (a,b',c'))
08:22:51 <quicksilver> :t lens (\(a,b,c) -> (b,c)) (\(a,b,c) (b',c') -> (a,b',c'))
08:22:53 <lambdabot> Functor f => ((t, t1) -> f (t3, t4)) -> (t2, t, t1) -> f (t2, t3, t4)
08:23:01 <Myrl> quicksilver: I'm pretty convinced that it's hanging up at `recv` now.
08:23:03 <quicksilver> type looks right to me.
08:23:27 <merijn> Oh!
08:23:31 <merijn> I think I know
08:23:34 <merijn> Lemme check the docs :)
08:24:10 <merijn> ok, here's a wild ass guess that you should check
08:24:19 <merijn> You're using recv
08:24:20 <humanoyd> quicksilver: Thanks
08:24:36 <merijn> recv returns empty string when the remote connection is closed!
08:24:44 <Myrl> merijn: Yep.
08:24:46 <Myrl> merijn: I handled that.
08:24:55 <Myrl> go' f str | B.length str ≡ 0 = print ("Connection closed." :: B.ByteSt
08:25:04 <merijn> oh, right
08:25:16 <merijn> Myrl: FYI, use B.null instead of "B.length s == 0"
08:25:18 <Gurkenglas_> humanoyd, https://hackage.haskell.org/package/lens-3.7.0.2/docs/Control-Lens-Traversal.html#v:holesOf looks close to the general case of what you want
08:25:25 <Myrl> merijn: Ah, thanks!
08:25:34 <quicksilver> merijn: doesn't really matter for bytestring
08:25:40 <quicksilver> but it's good habit.
08:25:57 <merijn> quicksilver: It does for lazy bytestring
08:26:04 <quicksilver> barely
08:26:04 <merijn> length is O(n) for lazy
08:26:10 <quicksilver> O(spine)
08:26:13 <quicksilver> not really O(n)
08:26:17 <bennofs> quicksilver. humanoyd: you might also like tuple-lenses
08:26:23 <merijn> Still O(n), but with a constant factor
08:26:24 <bennofs> @hackage tuple-lenses
08:26:24 <lambdabot> http://hackage.haskell.org/package/tuple-lenses
08:26:25 <Myrl> merijn: I'm really making this ugly just so that I can easily debug it.
08:26:48 <quicksilver> does recv ever return more than a 1-chunk bytestring anyway? :)
08:26:59 <tpuu> I've got a rewrite rule that refuses to fire
08:27:04 <merijn> Myrl: How are you testing it?
08:27:06 <quicksilver> but either way, not using Eq to compare for emptiness is a sound rule of thumb.
08:27:16 <tpuu> There's a very similar rule that fires so I'm not sure what the problem is
08:27:29 <Myrl> Anyways, this is what my logs say.
08:27:34 <tpuu> it doesn't seem to be the source expression being inlined early
08:27:37 <Myrl> "/home/myrl/Website/files/images/banner.jpg" "Loading file." "Loaded file." "Sending" "Sent" "Receiving"
08:27:48 <Myrl> It ends at "receiving"
08:27:55 <Myrl> It should say "received" again
08:28:15 <Myrl> For some weird reason, it blocks.
08:28:15 <Myrl> :s
08:28:57 <quicksilver> this might be a dumb question, but is the socket set to non-blocking?
08:29:00 <dfeuer> I have no need for such a thing myself, but a number of SO questions by students learning Haskell in school make me think an alternate prelude with almost no *functions* at all would be really useful. Does such a thing exist?
08:29:07 <Myrl> quicksilver: It's not.
08:29:15 <quicksilver> then recv can choose to block
08:29:19 <tpuu> dfeuer: theres an extension that can do that
08:29:20 <quicksilver> if there aren't enough bytes available
08:29:26 <tpuu> noimplicitprelude or something
08:29:31 <dfeuer> Students seem to reach for things like head and tail and == way before they should.
08:29:34 <Myrl> quicksilver: It does have enough bytes available though.
08:29:53 <dfeuer> tpuu, that's overkill, I believe. NoImplicitPrelude has a bunch of knock-on effects (I think).
08:30:35 <merijn> quicksilver: This is not true
08:30:44 <dfeuer> Morning, merijn.
08:30:48 <quicksilver> merijn: is it not?
08:30:53 <tpuu> dfeuer: yes, I think it removes monads and the numeric typeclasses
08:30:55 <merijn> quicksilver: It's Socket, not Handle
08:30:56 <humanoyd> Gurkenglas_: Can you give me an example of how that might look? Bazaar, Context...that's still a bit too advanced for me
08:31:07 <quicksilver> merijn: I remember being confused (and other people being confused) about this before; I could have misremembered the conclusion tho
08:31:08 <merijn> quicksilver: recv returns any available bytes UP TO the request amount
08:31:11 <humanoyd> bennofs: Thanks, I will look into that
08:31:15 <merijn> dfeuer: Ola
08:31:52 <dfeuer> tpuu, I wouldn't think it particularly pleasant to teach Haskell without numbers :P
08:32:10 <dfeuer> OTOH, there might be advantages...
08:32:23 <exio4> peano numerals from start 
08:32:48 <tpuu> dfeuer: lol. I don't think the prelude like the one you need exists, you'll just have to write it yourself or try hiding all the functions you don't like
08:32:51 <dfeuer> exio4, yeah, you *could*, but that seems a lot more Agdaish.
08:33:37 <Myrl> Haha....
08:33:42 <Myrl> I'm so sad rite now. ;~;
08:34:12 <dfeuer> I'm just vaguely wondering if educators have tools readily available to avoid the horrors of code students write when they understand functions but don't understand pattern matching, and end up doing really crazy things.
08:34:19 * dfeuer hugs Myrl.
08:34:21 <quicksilver> Myrl: is it possible one of your earlier calls over-recved?
08:34:42 <quicksilver> Myrl: could the previous call to recv have grabbed the final request as well and not handled it?
08:34:47 <merijn> Myrl: I would start with something that just reads and echoes locally
08:34:49 <Myrl> quicksilver: Nope.
08:34:56 <merijn> Check if that works, THEN hook up the parser
08:35:01 <pnutus> Is there a way to tell stack to install haddocks for all installed packages, other than reinstalling everything?
08:35:11 <quicksilver> pnutus: I think you have to reinstall everything :(
08:35:14 <Myrl> quicksilver: That's actually what i immediately looked at first.
08:35:15 * hackagebot ot 0.2.1.0 - Real-time collaborative editing with Operational Transformation  https://hackage.haskell.org/package/ot-0.2.1.0 (TimBaumann)
08:35:30 <Myrl> Anyways, this is my log.
08:35:30 <Myrl> "/home/myrl/Website/files/images/banner.jpg" "Loading file." "Loaded file." "Sending" "Sent" "Receiving" "Received." "Connection closed." "Receiving" "Received." "/home/myrl/Website/files/assets/js/jquery.min.js" "Loading file." "Loaded file." "Sending" "Sent" "Receiving"
08:35:48 <Myrl> "Receiving" "Received." "Connection closed.
08:35:51 <Myrl> means a timeout.
08:36:01 <phaazon> I’m wondering, is there a tool to test a package for the whole range of supported version per-dependency?
08:36:02 <Myrl> It's waiting for something, then it gets a zero length, so it closes connection.
08:36:10 <phaazon> that might sound a bit heavy though
08:36:58 <tpuu> dfeuer: when I had a haskell class the lecturer just told us not to use certain functions
08:37:17 <pnutus> quicksilver: and there seems to be no way of saying "always install docs"?
08:37:28 <merijn> phaazon: hvr had something like that
08:37:33 <merijn> phaazon: Ask him
08:37:44 <quicksilver> pnutus: yes there is
08:37:48 <pnutus> quicksilver: aka I have to remember to say --haddock --haddock-deps all the time?
08:37:55 <quicksilver> pnutus: put enable-documentation into your cabal config
08:38:06 <pnutus> and stack respects that?
08:38:19 <phaazon> merijn: thanks, I will
08:38:22 <quicksilver> stack just calls cabal and as long as it is looking at the right config file, yes
08:38:34 <Myrl> Anyways.
08:38:42 <pnutus> ok, thanks :) (although I thought I'd set that in the days before stack...)
08:38:50 <Myrl> Is firefox deliberately cutting off the connection?
08:38:56 <Myrl> That may be it.
08:39:03 <Myrl> And that's funny stupid.
08:39:12 <Myrl> I may be trying to fix something that is not my problem.
08:39:17 <quicksilver> Myrl: all browsers will only keep-alive up to a point
08:39:25 <quicksilver> then they will start a new request
08:39:32 <quicksilver> I didn't realise you were testing with a real browser (tm) :)
08:40:01 <Myrl> quicksilver: :P
08:40:21 <dfeuer> tpuu, sounds sensible. I never took a Haskell class, but I'd mostly want to prohibit beginners from using head, tail, null, length, last, init, inits, isJust, fromJust, (==), (/=), and (to start with) floating point.
08:40:43 <Myrl> Do haskell classes even exist in an ordinary school?
08:40:52 <tpuu> dfeuer: why would you want to prohibit == ?
08:42:07 <quicksilver> some Myrl 
08:42:13 <quicksilver> tpuu: so they learn about using pattern matching first
08:42:28 <quicksilver> tpuu: common newbie mistake - checking if a list is empty using == []
08:42:34 <quicksilver> or checking for Nothing with == Nothing
08:43:11 <pavonia> quicksilver: Why do you consider this a mistake?
08:43:29 <merijn> pavonia: Only works for types implementing Eq
08:43:33 <tpuu> quicksilver: I see.
08:43:34 <dfeuer> tpuu, what quicksilver said. ==[] and ==Nothing are common errors.
08:43:46 <merijn> :t (==[])
08:43:47 <lambdabot> Eq t => [t] -> Bool
08:43:57 <merijn> :t null `asAppliedTo` []
08:43:59 <lambdabot> [a] -> Bool
08:44:12 <merijn> null works for more lists than ==[] does
08:44:14 <dfeuer> :t asAppliedTo
08:44:17 <lambdabot> (a -> b) -> a -> a -> b
08:44:22 <merijn> (i.e. all lists, instead of lists of types with Eq)
08:44:29 <Myrl> quicksilver: Actually, no.
08:44:31 <merijn> dfeuer: It's just const with a funny signature :)
08:44:51 <dfeuer> merijn, I'd never heard of it before. Nice.
08:45:02 <merijn> dfeuer: It's only in lambdabot, afaik
08:45:06 <dfeuer> Ah....
08:45:16 * hackagebot mono-traversable 0.10.0 - Type classes for mapping, folding, and traversing monomorphic containers  https://hackage.haskell.org/package/mono-traversable-0.10.0 (MichaelSnoyman)
08:45:17 <pavonia> merijn: Is it still a mistake if the type has an Eq instance?
08:46:10 <merijn> I would say so
08:46:17 <merijn> Better stop bad habits before they appear
08:46:24 <Myrl> Wow.
08:46:29 <Myrl> It's even more apparent with elinks.
08:47:44 <Myrl> Err...
08:48:02 <Myrl> This is so weird in so many levels.
08:49:32 <quicksilver> Myrl: sorry, actually,no to which part?
08:49:52 <fr33domlover> Is it generally possible to redirect stdout to a file using the shell? I tried `dist/build/myprog/myprog > log.txt` but I still get output on the command line
08:49:55 <tpuu> Can someone help me figure out why this rewrite rule http://lpaste.net/1791524038477086720 isn't firing please?
08:50:39 <Myrl> "Receiving" "Received." "/home/myrl/Website/files/index.html" "Loading file." "Loaded file." "Sending" "Sent" "Receiving" "Connection closed." "Receiving" "Received." "/home/myrl/Website/files/assets/css/main.css" "Loading file." "Loaded file." "Sending" 
08:50:45 <Myrl> This one barely makes no sense at all.
08:51:02 <Myrl> So, I receive the header for index.html.
08:51:12 <Ankhers> fr33domlover: You may be getting output from stderr.
08:51:20 <Myrl> Then it just keeps waiting, then I close elinks.
08:51:25 <Ankhers> Which would still appear on your command line.
08:52:00 <fr33domlover> Ankhers, I tried redirecting both, same result. I see text my own code prints with putStrLn
08:52:02 <Myrl> Then it closes the connection, then receives the header for main.css.
08:54:13 <Myrl> "GET /index.html HTTP/1.1\r\nHost: meido.is-into.science\r\nUser-Agent: ELinks (0.12pre6; Linux 4.0.5-gentoo x86_64; 159x18)\r\nReferer: http://meido.is-into.science/index.html\r\nAccept: */*\r\nConnection: Keep-Alive\r\n\r\n" -- The accepted header.
08:54:17 <Myrl> "" -- The parser remainder.
08:54:19 <Myrl> "/home/myrl/Website/files/index.html" -- the parsed path.
08:54:45 <Myrl> As you can see on the accepted header, I only accepted one header.
08:54:54 <Myrl> Since there's only one occurence of \r\n\r\n.
08:55:33 <Myrl> Then "" says that my parser has no strings that it didn't consume, (and thus the next recv should be a whole header.)
08:55:40 <Ankhers> fr33domlover: Try using `tee'. It is a shell program.
08:56:39 <fr33domlover> Ankhers, thanks, will try. Looks like it does work with a trivial program though. Probably my mistake...
08:57:00 <Ankhers> fr33domlover: I was going to say, I quickly wrote a hello world and I was able to redirect.
08:57:15 <fr33domlover> Yeah, me too :P
08:57:42 <pavonia> fr33domlover: Do you call external processes from your pogram? I think I had issues with this once
08:58:17 <Myrl> There's nothing wrong with it at all. =_=
08:58:26 <quicksilver> Myrl: \o/ ?
08:58:37 <tpuu> oh god
08:58:48 <tpuu> I used the advice at http://stackoverflow.com/questions/32130011 and the rules just fired forever
08:59:05 <fr33domlover> pavonia, no, just a single process but with several threads. Now I get this: When I redirect, the output file is empty for some reason. Maybe buffering causes stdout not to be flushed before I kill the process?
09:00:18 <tpuu> I fixed it!
09:00:27 <Pro9> Anyone using winghci that know how to import a non-standard module, e.g. haste?
09:01:08 <pavonia> fr33domlover: Possibly
09:01:24 <ReinH> fr33domlover: Is your program exiting before the thread has a chance to print?
09:02:04 <ReinH> fr33domlover: You need to make sure that the main thread doesn't exit until all the other threads are done because GHC will cause the program to terminate when the main thread terminates, regardless of the status of children.
09:02:14 <fr33domlover> ReinH, no. Without redirection it does prints. With redirection nothing gets written to the file. I'll try running for more time and see what happes in the end.
09:02:18 <ReinH> You can use, e.g., await from async.
09:02:22 <Myrl> quicksilver: No, not \o/
09:02:25 <medfly> hey guys i am reading this guide for persistent (http://www.yesodweb.com/book/persistent) and they make like a data type age Int Maybe in the first example. isn't that reversed? shouldn't it be Maybe Int? 
09:02:29 <fr33domlover> ReinH, thanks
09:02:30 <Myrl> quicksilver: There's nothing wrong, but it's not working.
09:02:33 <Myrl> quicksilver: This is hell.
09:02:52 <ReinH> fr33domlover: well, that doesn't make any sense.
09:03:08 <Myrl> quicksilver: I found a bug.
09:04:18 <exio4> "there's nothing wrong, but it's not working" sounds like a false statement to me :p
09:04:24 <exio4> unless you meant it to not work 
09:04:38 <quicksilver> medfly: I think that's a quirk of the QuasiQuoter
09:04:40 <quicksilver> (I'm not sure)
09:06:03 <Myrl> Nope, there's no bugh.
09:06:06 <fr33domlover> medfly, it has its own syntax, it's not plain regular Haskell
09:06:10 <Myrl> I sent wrong input.
09:06:21 <fr33domlover> I think the Maybe there tries to imitate SQL's "not null"
09:06:28 <fr33domlover> that's why it comes after the type
09:06:32 <fr33domlover> makes the mapping easier
09:06:38 <medfly> ah, I see. thanks
09:06:39 <fr33domlover> to the developer's eyes
09:06:39 <quicksilver> I think it tries to imitate the opposite of "not null" :)
09:06:50 <fr33domlover> quicksilver, yeah sorry
09:06:57 <fr33domlover> my mistake :P
09:07:39 <Myrl> There's...
09:07:43 <Myrl> Is there a bug in the buffer?
09:09:19 <Myrl> Perhaps it's because it's sending something other than..
09:09:22 <Myrl> Nah.
09:10:40 <Myrl> Also doesn't work in my other server.
09:11:57 <Myrl> I'm guessing I'm not sending enough.
09:12:03 <Myrl> That's why firefox won't respond.
09:13:20 <mr_rm> i'm having a problem trying to install stack on windows 7. while installing msys2, i keep getting timeout errors on various sourceforge repos and the entire installation of msys fails. is this a known issue?
09:13:51 <mr_rm> tried it like 20 times and different repos keep timing out
09:16:02 <Myrl> I'ma go.
09:26:57 <taruti> Which library is preferred for fast email parsing without C library dependencies? hsemail or something nicer?
09:40:14 <fr33domlover> mr_rm, the solution is to install a GNU/Linux distribution... :)
09:40:20 <fr33domlover> (otherwise I have no idea)
09:45:04 <jophish> mr_rm: that sounds a bit like a network error
09:45:10 <jophish> are you able to try on another network?
09:46:56 <jakub_> Hello, can (->) be a MonadTrans?
09:50:04 <sleepomeno> I use parsec to parse a simple (programming) language. I want to better understand/debug what my parser parses/why it fails. After parsing, as a part of the result, I would like to have a log of all the applied parsers, including their nesting (that's why simple putStrLn logging is out of question anyway). That log should also be available in case the parsing fails. How can that be done? 
09:50:32 <srhb> :k MonadTrans
09:50:33 <lambdabot> ((* -> *) -> * -> *) -> Constraint
09:50:35 <srhb> :k (->)
09:50:36 <lambdabot> * -> * -> *
09:50:39 <srhb> Nope.
09:55:11 <jakub_> thanks, next time i will know better than bother you with stupid questions
09:55:20 <merijn> sleepomeno: Use parsec's state to maintain a list of tried parsers and add a part to your parsers that inserts their name into it?
09:56:02 <johnw> jakub_: please feel free to bother us with any questions
09:56:12 <johnw> we don't rate the intelligence of questions here
09:58:49 <sleepomeno> merijn: i sort of did that so far but you don't get the nesting aspect. I would need to add another "depth" state field such that I increase the depth at the start of a parser and decrease it at the end of the parser. Well now as I think about it, it's not that bad anyway..
10:00:18 <merijn> sleepomeno: Should be too hard to make your state a tree instead of a list, no? Or add a depth parameter...
10:03:38 <schell> hi all - i’m having trouble writing a MonadTrans instance for ghc7.8
10:03:57 <schell> in 7.10 it was simple thanks to the monadapplicative update
10:04:51 <schell> but now i’m having trouble specifying that the monad is an applicative, since the monad type var itself does’nt appear in the instance head
10:05:05 <ReinH> schell: the Monad doesn't need to be Applicative.
10:05:21 <Myrl> Found the problem.
10:05:22 <sm> sleepomeno: I've had pretty good success adding logging (trace) to all my parsers
10:05:33 <Myrl> Wow, this is so stupid.
10:05:39 <Myrl> I don't even know what the fuck's happening anymore.
10:05:58 <schell> ReinH: maybe it’s because some of my other instances have other constraints that could be relaxed
10:06:20 <merijn> Myrl: What was it?
10:06:22 <sm> sleepomeno: with some leading whitespace to help show nesting
10:06:24 <Entropy2> haskell scaresm e
10:06:26 <Entropy2> scares me
10:07:01 <Myrl> merijn: I have no idea how to say it.
10:07:16 <Myrl> merijn: Basically, it jams a shittonne of GET requests.
10:07:35 <Myrl> And `recv` skips it?
10:07:37 <Myrl> I don't know.
10:07:53 <srhb> Entropy2: Don't worry, GHC Haskell comes with a type system that holds your hand all the way through everything! :-)
10:08:21 <merijn> Entropy2: I can show you things scarier than Haskell if you want me to recalibrate your scariness meter...
10:08:52 <Entropy2> merijn, lisp?
10:09:00 <kaol> I'm trying to adapt some code from Snap and I keep running into trouble trying to fit the types together. I ended up using a few extensions, just to keep things interesting. Anyone see what I'm doing wrong? http://lpaste.net/142947
10:09:06 <merijn> Entropy2: C++
10:09:16 <Myrl> merijn: http://imgur.com/33Ax9y7
10:09:27 <Myrl> merijn: The best question now is, WHY THE HELL IS IT GETTING SKIPPED!?
10:09:29 <Entropy2> merijn, you said scary not digusting
10:09:33 <dazed_and_amused> whats wrong with  (Data.Set.fold sum 0 (s :: Data.Set Int))
10:10:01 <merijn> Entropy2: Both, then :)
10:10:16 <Entropy2> xD
10:10:50 <kaol> Why does my logoutUser care about what "u" is in it?
10:11:19 <merijn> dazed_and_amused: sum has the wrong type
10:11:21 <merijn> :t sum
10:11:22 <lambdabot> (Num a, Foldable t) => t a -> a
10:11:44 <merijn> dazed_and_amused: Presumably you mean "Data.Set.fold (+) 0 s"?
10:11:53 <merijn> dazed_and_amused: Which, incidentally is just "sum" in 7.10
10:11:56 <schell> ReinH: turns out i just had to write lift without using anything from applicative
10:12:10 <merijn> :t sum `asAppliedTo` Data.Set.empty
10:12:11 <lambdabot> Num b => S.Set b -> b
10:12:31 <merijn> > sum $ Data.Set.fromList [1,2,3,5]
10:12:33 <lambdabot>  Not in scope: ‘Data.Set.fromList’
10:12:37 <merijn> awww
10:12:37 <dazed_and_amused> merijn: yup, I'm an idiot. In my head I was seeing +, just wrote it as sum
10:12:39 <dazed_and_amused> thanks
10:13:01 <ggole> :t asAppliedTo
10:13:02 <lambdabot> (a -> b) -> a -> a -> b
10:13:11 <ggole> Of course.
10:13:13 <tpuu> I just spent over 30 mins debugging some missing '
10:13:19 <merijn> ggole: It's just const :)
10:13:44 <tpuu> Why on earth did this become convention
10:13:56 <merijn> tpuu: Similarity to math
10:14:06 <merijn> tpuu: But it should be sparingly used, imo
10:14:33 <ReinH> See, this is why we need linear types ;)
10:14:57 <schell> merijn: what’s a better notation?
10:15:08 <tpuu> well there was a missing ' but the code still doesn't work
10:15:26 <merijn> schell: Depends on what you're doing, ' should only be used in really small scopes with infrequent use so you don't confuse/miss them
10:15:43 <schell> yeah, that makes sense
10:16:08 <schell> i usually use them to show values of the same type that have been updated
10:16:23 <schell> like steps of a thing
10:17:03 <Myrl> merijn: This is stupid. :/
10:18:25 <schell> ReinH: i’ve never read about linear types - what’s the general idea?
10:18:36 <merijn> schell: Values that can only be used once
10:18:47 <merijn> schell: i.e. repeated references to the same value are a type error
10:19:00 <schell> ah - interesting
10:19:24 <schell> ‘used’ as in evaluated?
10:19:46 <merijn> schell: Whatever definition of used you decide on in your language design
10:19:51 <schell> or just referenced?
10:19:53 <schell> ah i see
10:25:54 <merijn> Things like this can be used, for example, to create a purely functional language where you don't separate IO out ala haskell, but instead statically guarantee any IO is only performed once
10:26:12 <kaol> Ooh. I made the error go away with functional dependencies. Fair enough.
10:27:23 <merijn> schell: For example, Clean (Haskell's purely functional sister) uses uniqueness types to deal with purity
10:27:56 <merijn> Where uniqueness types are a subset of linear types if I've got my story straight
10:28:22 <schell> sounds neat
10:30:22 <m1dnight_> Im having an odd effect with parsec. Whenever I feed it a string it has to end on '\n'. Is that normal?
10:31:16 <kadoban> m1dnight_: Sounds like line buffering on input or something, more than something parsec would be doing.
10:31:47 <m1dnight_> No, I mean literally append \n to it.
10:31:49 <schell> merijn: it doesn’t look like it affects the way you write your code much (that’s a naive statement though - i’m just looking at the lang’s wikipedia page)
10:31:51 <m1dnight_> Hold on, I will demonstrate.
10:33:25 <merijn> schell: Not a lot, but there's some things that linear types can express that e.g. haskell can't
10:33:46 <merijn> schell: For example, imagine a file type that enforces that the "close" code is run
10:34:09 <srhb> Seems like uniqueness types would obsolete the "unsafePerformIO to bootstrap C library" trick
10:34:55 <m1dnight_> https://www.refheap.com/110584
10:35:27 <m1dnight_> In the discussion above: somebody at the lab built a language that uses linear types to statically verify futures are resolved.
10:37:01 <ReinH> merijn: And Rust uses affine types, which are a slightly weakened version of linear types.
10:38:48 <xpilot> hi, I'm using ghci and it looks like :load is picking up existing .o files produced by ghc
10:39:06 <ReinH> schell: well, the impetus was the idiom using x x' x'' etc. Linear types could ensure that the wrong one wasn't used.
10:39:07 <xpilot> thus wasting a lot of time interpreting modules that should have already been compiled
10:39:46 <ReinH> schell: In Haskell, if you can structure your code to avoid introducing those bindings then you can also avoid the bug.
10:39:54 <ReinH> e.g. pointfree style can help with this
10:39:58 <schell> ReinH: right - because if x’ references x then it’s already “been used”, correct?
10:40:13 <ReinH> schell: if x' is constructed from x then that "uses" x
10:40:26 <ReinH> So a further use of x instead of x' would be a type error
10:40:56 <xpilot> whoops I meant that ghci is NOT picking up .o files
10:41:01 <ReinH> schell: If you've used Rust then you've seen this in action
10:41:18 <schell> i haven’t yet - i’ve been meaning to
10:41:54 <ReinH> (Affine types let you say a value must be used "at most once" rather than "exactly once")
10:42:03 <schell> the idea is interesting but it leaves me thinking that it would then be hard to do things like x’ = x + 2, y = x + 3
10:42:30 <schell> i’m sure there’s a whole set of strategies for that stuff though
10:42:36 <ReinH> schell: Yes, but you aren't required to use a linear type.
10:42:53 <schell> ah - so it’s not system wide - it’s only very specific marked types
10:43:22 <ReinH> Yes, it's an additional statement that can be made in the type system.
10:43:28 <mr_rm> jophish: sorry i was away at lunch. yes it does sound like a network error but i also tried (unsuccessfully) on 3 separate networks :)
10:43:41 <schell> like “Unique Float” - i think i just read that but it hadn’t sunk in
10:44:22 <schell> well if people keep talking about it i’m sure someone will write a language extension :)
10:44:24 <mr_rm> jophish: the part i thought might be a known issue is how you can't just try again once it fails to commit. it starts all over from the very beginning, and, for me, subsequently fails on another package download
10:44:29 <ReinH> schell: it's not quite that simple
10:45:19 <elkorn> hello everyone. I have a pretty basic problem with grokking how to fit State in a simple case (or whether it is possible/makes sense). The case is: http://sprunge.us/bLdX?haskell. I'd like to get numbers from stdin and use State to store them in a list, printing it out after each 
10:45:25 <schell> of course not ;)
10:45:58 <ReinH> @google wadler linear types can change the world
10:46:00 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.31.5002
10:46:00 <lambdabot> Title: CiteSeerX — Linear Types Can Change the World!
10:46:09 <ReinH> schell: I think this is what merijn was referring to regarding linear types and IO
10:46:11 <merijn> elkorn: You probably want the State transformer and then use "StateT [Int] IO Int"
10:46:29 <schell> but i’m constantly impressed with all the tough problems people around here are solving so...
10:46:36 <schell> oh cool, thanks ReinH 
10:46:57 <merijn> ReinH: I dunno what I was referring too :p
10:47:15 <ReinH> merijn: it's ok, I might :)
10:47:21 <ReinH> @google emulating linear types in Haskell
10:47:24 <lambdabot> http://www.ioc.ee/~tarmo/tsem11/jeltsch1602-slides.pdf
10:47:24 <lambdabot> Title: Emulating Linear Types in Haskell
10:47:26 <merijn> ReinH: I know both Clean and a language some colleagues are working on use uniqueness type to be purely functional, but I don't know too much about linear types :p
10:47:26 <ReinH> schell: You might also find this interesti
10:47:29 <ReinH> ng
10:48:39 <schell> thanks :) i think the latter of two will be more digestible for my layman gut
10:49:06 <ReinH> schell: well, it does involve some abstract nonsense
10:49:36 <schell> yeah, it’s still a bite too large to chew 
10:50:01 <schell> but i can put it in the pantry
10:50:05 <schell> lol
10:50:08 <schell> i’ll stop now
10:50:21 * hackagebot grouped-list 0.1.2.0 - Grouped lists. Equal consecutive elements are grouped.  https://hackage.haskell.org/package/grouped-list-0.1.2.0 (DanielDiaz)
10:50:50 <merijn> schell: Gotta start somewhere :p
10:51:03 <broma0> Has anyone been messing around with GHCJS recently?
10:51:04 <merijn> My approach so far has been to hit my head against stuff I don't understand until I do :p
10:51:11 <merijn> Although that often takes a while... :p
10:51:19 <clrnd> I built ghcjs and then forgot about it
10:51:24 <elkorn> merijn: thanks for the answer, I'll try to level up on this
10:51:26 <clrnd> built it using stack
10:51:48 <merijn> elkorn: I've got a good exercise for you
10:51:58 <broma0> clrnd: ghcjs-dom?
10:52:01 <merijn> elkorn: https://gist.github.com/merijn/098106abd45c940dab09
10:52:03 <broma0> clrnd: used that?
10:52:09 <clrnd> broma0, no :P
10:52:28 <merijn> elkorn: The best way to understand StateT is to just implement it. I'd recommend doing State first (if you haven't yet) and then trying to generalise to StateT
10:54:13 <elkorn> merijn: much appreciated! I've implemented State a few times, but it somehow keeps eluding me in 'real' cases, hopefully your exercise will help
10:57:20 <merijn> elkorn: The thing with state is that the datatype exists "just" to conveniently be able to write a monad instance for "s -> (a, s)" (which otherwise you can't)
10:58:13 <merijn> StateT just generalises that notion to "well...what if I had a function that used some monad m for producing it's result?", i.e. "s -> m (a, s)". If you've already done State, StateT shouldn't be a lot more difficult :)
10:58:27 <merijn> Anyhoo, time to go now
10:59:17 <merijn> elkorn: (also, it probably kept eluding you in "real" case because in 80-90% of my real uses of State I use some form of StateT, almost never plain State :))
10:59:48 <elkorn> merijn: it might very well be the case, I had the feeling of something "lacking"
11:00:01 <elkorn> merijn: again, thank you very much for the insight
11:00:08 <broma0> Has anyone recently gotten ghcjs-dom to build? It keeps failing on me with this error: src/GHCJS/DOM/Types.hs:861:23: Module ‘GHCJS.Marshal’ does not export ‘ToJSRef(..)’
11:03:10 <Ankhers> broma0: Sounds like ghcjs-dom is trying to use a function that does not exist. At least it does not exist where it is trying to look.
11:04:49 <Ankhers> broma0: Do you have GHCJS on your machine? I don't believe it is on hackage.
11:05:36 * hackagebot pandoc-citeproc 0.8 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.8 (JohnMacFarlane)
11:05:38 * hackagebot first-and-last 0.1.0.0 - First and Last generalized to return up to n values  https://hackage.haskell.org/package/first-and-last-0.1.0.0 (andrus)
11:07:12 <broma0> Ankhers: I do, i installed it from the respository
11:07:23 <broma0> Ankhers: well actually, from ghcjs.luite.com
11:07:58 <broma0> Ankhers: I noticed a commit on ghcjs that renamed JSRef to JSVal.. ghcjs-dom probably hasn't been updated 
11:08:19 <Ankhers> broma0: That might do it. You should send them a pull request.
11:11:03 <broma0> Ankhers: I hope it's that easy. Thanks
11:15:36 * hackagebot haskore-vintage 0.3 - The February 2000 version of Haskore.  https://hackage.haskell.org/package/haskore-vintage-0.3 (IavorDiatchki)
11:35:58 <cow_2001> is this everything there is to producing statically linked standalone executable in GHC? https://stackoverflow.com/questions/16149948/is-it-possible-to-produce-stand-alone-haskell-executable
11:38:09 <bennofs> cow_2001: you will need a statically compiled GMP library for that to work, but otherwise, yes, it should be enough I think
11:38:38 <cow_2001> statically compiled GMP library... what's that?
11:39:31 <davean> cow_2001: GMP is waht gives us Integer, that or integer-simple
11:39:41 <davean> cow_2001: Its a GPL library for unbounded integer math
11:40:09 <cow_2001> ah
11:40:11 <davean> cow_2001: Strictly speaking though, static linking doesn't exist on linux, you'll *always* dynamically link linux-vdso.so.1 no matter the language or compiler, even if you write machine code with a hex editor
11:40:21 <cow_2001> hmmm
11:40:22 <davean> cow_2001: Its usually dynamically linked due to licensing
11:40:35 <davean> with is also why integer-simple exists
11:41:02 <davean> You probably don't care about linux-vdso.so.1
11:41:17 <davean> But you simply can't have "static" linking on linux, only "nearly static"
11:42:35 <davean> (vDSO is how you make system calls)
11:42:49 <davean> (system calls are dynamically linked in)
11:42:59 <nitrix> @pl \x -> x - 1000
11:43:00 <lambdabot> subtract 1000
11:46:15 <clrnd> > (`substract` 1000) 10001
11:46:16 <lambdabot>      Not in scope: ‘substract’
11:46:16 <lambdabot>      Perhaps you meant ‘subtract’ (imported from Prelude)
11:46:22 <clrnd> > (`subtract` 1000) 10001
11:46:24 <lambdabot>  -9001
11:46:28 <clrnd> well lol
11:50:38 * hackagebot waddle 0.1.0.6 - DOOM WAD file utilities.  https://hackage.haskell.org/package/waddle-0.1.0.6 (MartinGrabmueller)
11:50:40 * hackagebot uhc-util 0.1.6.2 - UHC utilities  https://hackage.haskell.org/package/uhc-util-0.1.6.2 (AtzeDijkstra)
11:52:45 <BernhardPosselt1> does a map function have an order
11:53:01 <BernhardPosselt1> like map over a list will always start at the first element
11:53:55 <tdammers> evaluation order is undefined
11:54:08 <tdammers> but the order of list elements stays intact
11:54:18 <BernhardPosselt1> is that also true for fmap?
11:55:18 <MarcelineVQ> For a well behaved fmap yes
11:55:21 <MarcelineVQ> https://wiki.haskell.org/Typeclassopedia#Laws
11:55:34 <tdammers> depends what you fmap over, but generally, the contract is that fmap maintains structure (including ordering)
11:55:37 <BernhardPosselt1> example: map over a list of files and edit them
11:55:39 * hackagebot happstack-authenticate 2.3.0 - Happstack Authentication Library  https://hackage.haskell.org/package/happstack-authenticate-2.3.0 (JeremyShaw)
11:55:56 <tdammers> that's not map though
11:56:11 <hseg> Just heard of linear implicit parameters. Any reason they didn't really take off?
11:56:12 <BernhardPosselt1> map is always side effect free?
11:56:18 <tdammers> map is pure, so yes
11:56:35 <tdammers> if you want effects, you're looking at mapM, for example
11:56:37 <tdammers> :t map
11:56:38 <lambdabot> (a -> b) -> [a] -> [b]
11:56:39 <tdammers> :t mapM
11:56:40 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
11:56:51 <tdammers> and if you want *only* the effects:
11:56:53 <tdammers> :t mapM_
11:56:55 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
11:57:44 <BernhardPosselt1> well behaved map means that map does not change the structure right?
11:58:43 <BernhardPosselt1> whats an example of a not well behaving map :)
11:59:08 <exio4> map _ _ []
11:59:22 <exio4> map _ _ = [] -- I mean
11:59:34 <BernhardPosselt1> ah
11:59:38 <hseg> AFAICT, well-behaved = lawful
11:59:55 <BernhardPosselt1> so basically bijective ?
12:00:08 <hseg> so e.g. map f (x:xs) = f x : f x : map f xs is also not well behaved.
12:00:10 <exio4> map f (x : xs) = f x : f x : xs ; map _ [] = [] 
12:00:34 <hseg> BernhardPosselt1: No, just satisfying functorial laws
12:00:37 <fizruk> BernhardPosselt1: map f (x:y:xs) = f y : f x : map f xs; map f [x] = [f x]; map _ _ = []
12:00:51 <hseg> BernhardPosselt1: i.e. map (f . g) = map f . map g and map id = id
12:02:32 <hseg> You also get the free theorem map f . map g = map p . map q for f.g=p.q
12:02:37 <wildweasel> Is it possible to recursively define a function?
12:02:55 <kadoban> wildweasel: Of course.
12:03:07 <hseg> wildweasel: Sure. e.g. factorial 0 = 1; factorial n = n * factorial (n-1)
12:03:07 <BernhardPosselt1> ty
12:03:25 <wildweasel> hseg: I understand that
12:03:40 <hseg> BernhardPosselt1: I think one of the functorial laws is free.
12:04:00 <wildweasel> I want to create a higher order function that takes a function and a list, adding elements from that list as patterns to the function.
12:04:18 <wildweasel> But I cannot figure out how or if it is even possible.
12:04:20 <hseg> wildweasel: ?
12:04:23 <mniip> as patterns?
12:04:29 <hseg> wildweasel: Could you give an example?
12:04:32 <mniip> oh
12:04:36 <mniip> constructing functions
12:04:42 <fizruk> hseg: map f . map g = map (f . g) follows from map id = id and parametricity
12:05:02 <fizruk> hseg: but the proof is not obvious afaik
12:05:13 <shachaf> fizruk: ...Assuming the type F that you're talking about is a functor.
12:05:22 <mniip> fizruk, assuming bottomless world
12:05:39 <mniip> actually hm, that map id = id covers the case
12:05:52 <fizruk> shachaf: isn't [] a functor?
12:05:58 <shachaf> It is.
12:06:10 <fizruk> so then it does follow, right?
12:06:36 * hackagebot happstack-server 7.4.5 - Web related tools and services.  https://hackage.haskell.org/package/happstack-server-7.4.5 (JeremyShaw)
12:06:38 * hackagebot clckwrks 0.23.11 - A secure, reliable content management system (CMS) and blogging platform  https://hackage.haskell.org/package/clckwrks-0.23.11 (JeremyShaw)
12:06:40 * hackagebot clckwrks-cli 0.2.15 - a command-line interface for adminstrating some aspects of clckwrks  https://hackage.haskell.org/package/clckwrks-cli-0.2.15 (JeremyShaw)
12:06:42 * hackagebot clckwrks-theme-clckwrks 0.5.2 - simple bootstrap based template for clckwrks  https://hackage.haskell.org/package/clckwrks-theme-clckwrks-0.5.2 (JeremyShaw)
12:06:52 <fizruk> did I miss anything? map is still (a -> b) -> [a] -> [b], right?
12:06:58 <hseg> Yeah.
12:07:12 <BernhardPosselt1> just scrolling further down on the typeclass page: regarding applicative functors: f (a -> b) -> f a -> f b
12:07:29 <BernhardPosselt1> lets say f is a list
12:07:50 <BernhardPosselt1> so ive got a list of functions from a to b, a list of a and i get a list of b
12:08:24 <fizruk> > [show, reverse . show] <*> [12, 34]
12:08:26 <lambdabot>  ["12","34","21","43"]
12:08:44 <BernhardPosselt1> ok :)
12:08:45 <kadoban> BernhardPosselt1: Yep
12:08:49 <BernhardPosselt1> that makes it clear
12:09:25 <MarcelineVQ> you can also use pure to promote a -> b to f (a -> b)
12:09:31 <MarcelineVQ> > pure (*) <*> [1,2,3] <*> [4,5,6]
12:09:32 <lambdabot>  [4,5,6,8,10,12,12,15,18]
12:09:33 <BernhardPosselt1> so a flatten happens in between?
12:09:39 <fizruk> > ZipList [show, reverse . show] <*> ZipList [12, 34]
12:09:41 <lambdabot>  ZipList {getZipList = ["12","43"]}
12:09:44 <BernhardPosselt1> or concat
12:09:56 <kaol> I wish (+1) . (Just 5) would work. Because (+1) `fmap` (Just 5) does. And ((+1) `fmap` (+5)) 0 does.
12:10:35 <MarcelineVQ> kaol: fmap is what lets +1 know how to talk to the 5 inside Just
12:11:08 <mniip> I think he's trying to say Prelude.. = fmap
12:11:36 * hackagebot clckwrks-theme-bootstrap 0.4.1 - simple bootstrap based template for clckwrks  https://hackage.haskell.org/package/clckwrks-theme-bootstrap-0.4.1 (JeremyShaw)
12:12:00 <kaol> Like map should be fmap, too.
12:12:08 <fizruk> kaol: (.) is generalized to Control.Category..
12:12:16 <fizruk> :t (Control.Category..)
12:12:17 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
12:13:14 <ttt_fff> can someone familiar with both explain to me how react and FRP compares? and the strengths / weaknesses of each?
12:13:34 <clrnd> react js?
12:13:50 <MarcelineVQ> kaol: That's a common conversation here, whether map really needs to be around since fmap exists. The common thread seems to be that having map is useful because we do so much list operations and it's quite clear to the reader that its operating on lists
12:13:57 <ttt_fff> yeah, facebook/react/js vs functional-relationalprogramming
12:14:08 <rcyr> relational?
12:14:11 <fizruk> ttt_fff: frp is functional reactive programming
12:14:22 <ttt_fff> sorry, funcational reactive programming
12:14:23 <ttt_fff> typo on my part
12:14:29 <kaol> But I can't write (+1) Control.Category.. (Just).
12:14:33 <kaol> But I can't write (+1) Control.Category.. (Just 5).
12:14:34 <ttt_fff> basically React vs things like Sodium/Reactive-Banana/Reflex
12:14:47 <davean> ttt_fff: Doesn't react just deal with updating the view?
12:14:53 <fizruk> kaol: that's because you (.) does not generalize to fmap
12:14:59 <fizruk> s/you//
12:15:26 <rcyr> React only deals with the view but probably does it in a more performant way than all the haskell alternatives I know.. (Because virtual dom)
12:16:36 <rcyr> That said, nothing prevents you from using React with RxJS which is RP, not FRP
12:17:51 <hseg> Just heard of linear implicit parameters. Any reason they didn't really take off?
12:21:36 * hackagebot uhc-light 1.1.9.1 - Part of UHC packaged as cabal/hackage installable library  https://hackage.haskell.org/package/uhc-light-1.1.9.1 (AtzeDijkstra)
12:23:29 <ttt_fff> suppose I have m1 :: (Map k v), m2 :: (Map k v), and I have the guarantees that all the keys in m1 < all the keys in m2. Is there a faster than O(n) way to "merge" m1 and m2 ?
12:24:08 <hseg> No takers? mboes claimed on reddit that linear implicit parameters were a failure. Why is this?
12:26:28 <kadoban> ttt_fff: Data.Map ? I don't think so. Other implementations could though.
12:26:39 <ttt_fff> yeah; I couldn't find it in Data.Map
12:26:47 <ttt_fff> which was sorta weird wince ther eis a O(log n) Data.Map.split
12:26:54 <ttt_fff> and I'm basically asking for "inverse split"
12:29:22 <dolio> hseg: Almost no one used them, in large part because people thought they were too tricky, I think.
12:30:06 <Ferdirand> ttt_fff: but when you split, the pivot is present in neither sides
12:30:32 <ttt_fff> Ferdirand: valid point. it's "sorta-inverse-split"
12:31:27 <hseg> dolio: Thanks
12:31:56 <Ferdirand> with a naive implementation of a tree map, it sounds a lot easier to do the inverse-split-with-additional-pivot than your sorta-inverse-split
12:33:45 <hubner> hello, i have a question about groupBy in Data.List
12:34:21 <hubner> i have a list of lists, and if i compare on the first element i should get 64 groups
12:34:21 <frerich> hubner: shoot
12:34:30 <hubner> length $ nub $ map head choicesetTSL
12:34:33 <hubner> gives me 64
12:34:45 <hubner> however: length $ groupBy ((==) `on` head) choicesetTSL
12:34:57 <hubner> gives me 16384
12:35:00 <Ferdirand> groupBy only collates contiguous elements
12:35:07 <Ferdirand> if i remember correctly
12:35:25 <MarcelineVQ> yes, that's why you usually see group and sort together
12:35:59 <hubner> so i would have to sort on that first element before using groupBy?
12:37:34 <Ferdirand> probably it's not much more expensive to sort with the default order for lists ?
12:38:39 <hubner> couple of seconds.. but that's ok.. it works, thanks so much!!
12:44:26 <m1dnight_> My osx laptop has the exact same version of cabal as my ubuntu desktop (1.22.6.0) but the GHC differs. On my desktop I have 7.8.4 and on osx I have 7.10.2. When I want to cabal build my project on my osx laptop it complains about the `base` that is not correct.
12:44:40 <m1dnight_> What is this base it it speaking of. The verion numbers dont seem to match anything I now of.
12:44:43 <m1dnight_> know*
12:45:37 <MarcelineVQ> base are the libs that come with vanilla ghc https://hackage.haskell.org/package/base
12:46:00 <m1dnight_> ah, so nothing a cabal sandbox can fix, right?
12:46:15 <m1dnight_> i.e., I have to use the same ghc version on both machines?
12:46:20 <MarcelineVQ> probably
12:46:23 <MarcelineVQ> I had a similair issue before and don't remember solving it
12:46:29 <hexagoxel> base version correlates with ghc version
12:47:09 <hexagoxel> e.g. base-4.8.0.0 ~ ghc-7.10.1
12:48:45 <sinelaw> I just noticed something, probably obvious.
12:49:03 <hexagoxel> m1dnight_: and yes, this connection is static and sandboxes wont change that
12:49:06 <sinelaw> Kinds (the usual ones) are just indexes, They are Nats.
12:49:31 <sinelaw> Z = *, S = (* ->)
12:49:59 <sinelaw> am I missing something?
12:50:55 <hexagoxel> :k StateT
12:50:56 <lambdabot> * -> (* -> *) -> * -> *
12:51:14 <sinelaw> hm.
12:52:17 <sinelaw> -> isn't associative
12:52:37 * hackagebot servant 0.4.4.5 - A family of combinators for defining webservices APIs  https://hackage.haskell.org/package/servant-0.4.4.5 (jkarni)
12:57:45 <mniip> sinelaw, finite binary trees
12:57:48 * hackagebot servant-client 0.4.4.5 - automatical derivation of querying functions for servant webservices  https://hackage.haskell.org/package/servant-client-0.4.4.5 (jkarni)
12:57:50 * hackagebot servant-docs 0.4.4.5 - generate API docs for your servant webservice  https://hackage.haskell.org/package/servant-docs-0.4.4.5 (jkarni)
12:57:50 <mniip> isomorphic to nats, yes
12:57:52 * hackagebot servant-jquery 0.4.4.5 - Automatically derive (jquery) javascript functions to query servant webservices  https://hackage.haskell.org/package/servant-jquery-0.4.4.5 (jkarni)
12:57:54 * hackagebot servant-server 0.4.4.5 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-server-0.4.4.5 (jkarni)
12:57:56 * hackagebot servant-examples 0.4.4.5 - Example programs for servant  https://hackage.haskell.org/package/servant-examples-0.4.4.5 (jkarni)
13:00:14 <Vq> edwardk: foldFree :: (Functor m, Monad m) => (forall x. f x -> m x) -> Free f a -> m a
13:00:26 <Vq> edwardk: Isn't the Functor restriction redundant here?
13:02:33 <kadoban> Vq: In older GHC, a Monad instance did not require a Functor instance. So … only in recent GHC.
13:02:58 * hackagebot servant-blaze 0.4.4.5 - Blaze-html support for servant  https://hackage.haskell.org/package/servant-blaze-0.4.4.5 (jkarni)
13:03:00 * hackagebot servant-lucid 0.4.4.5 - Servant support for lucid  https://hackage.haskell.org/package/servant-lucid-0.4.4.5 (jkarni)
13:03:02 * hackagebot servant-mock 0.4.4.5 - Derive a mock server for free from your servant API types  https://hackage.haskell.org/package/servant-mock-0.4.4.5 (jkarni)
13:03:48 <joobus> kadoban: was that actually fixed in recent GHCs?  Is there a way I can check?  I just finished reading learnyouahaskell and that is one of the things they noted about monads.
13:03:52 <Vq> kadoban: "only in recent"? When was this changed?
13:05:08 <dolio> 7.10
13:05:30 <Vq> Really?
13:06:54 <byorgey> Vq: Really.
13:07:47 <kadoban> joobus: Yes. It was a warning for a while, now it's an error.
13:08:47 <Vq> ok, my mind is playing tricks on me. :)
13:10:38 <kadoban> joobus: You can check … I guess by writing code that assumes a Functor instance based on a Monad one and seeing what happens, I guess, if you're in an empiricle mood. There's changelogs somewhere that say for sure though.
13:12:15 <cow_2001> Enigmagic: where do i start reading about regex-applicative?
13:14:21 <KaneTW> :t fmap :: Monad m => (a -> b) -> m a -> m b
13:14:22 <lambdabot> Monad m => (a -> b) -> m a -> m b
13:14:24 <KaneTW> ^
13:14:54 <Enigmagic> cow_2001: maybe here? https://github.com/feuerbach/regex-applicative
13:18:51 <Vq> KaneTW: Everything I thought I knew is wrong.
13:19:18 <davean> Vq: welcome to monday mornings
13:20:27 <Vq> An unusually long one I'd say.
13:25:25 <c_wraith> And you thought you knew what day it is. 
13:26:05 <MarcelineVQ> :>
13:33:33 <miniBill> I've written a piece of code that does what I want but I've got a feeling that it's far from being idiomatic. I'm looking for suggestions on how to improve it: https://gist.github.com/miniBill/7fce1193e5f2c19a2a65
13:41:24 <Ararat> Clint.
13:41:52 <clrnd> 2hlint
13:42:59 <Vq> miniBill: Tried running it? Line 13 looks a bit suspicious.
13:45:39 <miniBill> Vq: it's missing a let
13:47:01 <miniBill> Ararat: link?
13:47:10 <miniBill> clrnd: link?
13:47:20 <Ararat> Yes?
13:47:39 <clrnd> http://community.haskell.org/~ndm/hlint/
13:49:16 <miniBill> clrnd: oh, hlint. sadly it has no suggestions for me =(
13:49:31 <clrnd> nevermind, I was being lazy sorry
13:49:39 <miniBill> Ararat: do you have a link to "clint", I can't seem to find it
13:50:03 <miniBill> clrnd: thank you for the answer anyway, it would have helped if I didn't knew about it already =)
13:50:38 <Ararat> miniBill, Clint is here.
13:51:25 <kallisti> if I use AutoDeriveTypeable, will I get errors on types that cannot derive Typeable? Is it even possible for a type to be unable to derive Typeable? What's the minimum version of GHC that supports the extension?
13:52:06 <miniBill> Ararat: ?
13:52:31 <Ararat> He is here with us.
13:52:31 <miniBill> oh, ok
13:57:13 <Vq> miniBill: I'd probably rewrite stratify' to pass the (Map b b) as an argument instead of via the State monad.
13:57:47 <Vq> miniBill: It doesn't seem to buy you much.
13:57:51 * hackagebot accelerate-io 0.15.1.0 - Read and write Accelerate arrays in various formats  https://hackage.haskell.org/package/accelerate-io-0.15.1.0 (TrevorMcDonell)
13:59:45 <kallisti> so it looks like GHC 7.8.1 is the first release to support AutoDeriveTypeable?
14:00:24 <kallisti> I'd like to enable it by default in my entire package (via cabal extensions line) if using the appropriate GHC version, but I'm afraid it will cause compile errors on some version of GHC / some configuration of dependencies I haven't tested.
14:00:51 <Vq> miniBill: Your res' can be inlined. Just write  return (Map.insertWith ...)
14:04:08 <miniBill> Vq: I've tried not using state, and the result was not that different from where I started... otoh it's not really state, I should probably just pass it around and back
14:04:34 <miniBill> Vq: uh, yeah, inlining res' makes sense
14:05:48 <Vq> miniBill: stratify' looks like it contains an implementation of mapM, that could probably be factored out.
14:06:04 <Vq> miniBill: (or map if you rewrite it without State)
14:07:51 * hackagebot Lambdaya 0.1.0.0 - Library for RedPitaya  https://hackage.haskell.org/package/Lambdaya-0.1.0.0 (ralu)
14:08:00 <miniBill> where?
14:08:51 <miniBill> the idea is: get the values from the state map, get the max, increment by one, save the new max (in the same keys), put (newmax, currentvalue) in the result map
14:10:16 <Vq> miniBill: If you keep State as is, you can rewrite stratify' to take  a  instead of  [a]
14:10:39 <Vq> miniBill: Use it like: mapM (stratify' f) xs
14:11:10 <Vq> miniBill: and define it like:  stratify' f x = do ...
14:13:48 <miniBill> uh, yes!
14:14:06 <miniBill> that will make it much better
14:15:36 <Vq> I'm lying a bit since that will give you a list from evalState where you want the last value, but you get the idea.
14:15:49 <miniBill> wait, it's a bit more complicated
14:15:52 <miniBill> yeah
14:15:59 <miniBill> but I can have two different states
14:16:13 <miniBill> let me think
14:17:38 <Vq> Think away :)
14:18:03 <Vq> I'm going to do the opposite, it's early night over here.
14:18:18 <Vq> Happy coding.
14:29:44 <impure_hate> ohai. what parser to use for dsl or configuration file parsing?
14:29:53 <EvanR> parsec
14:30:03 <Welkin> O-HAAAAA!!
14:30:08 <impure_hate> ^^
14:30:09 <Welkin> shingo mama!
14:30:16 <Clint> alex/happy
14:30:24 <miniBill> updated the gist: https://gist.github.com/miniBill/7fce1193e5f2c19a2a65
14:30:31 <Welkin> config file parsing?
14:30:33 <impure_hate> is there anything tak can take like BNF grammar and parse accordingly?
14:30:33 <jamesfordummies> I am trying to haskell for a project and the code has to compile on an unmodified machine in terms of libraries. GHC 7.8.4 is installed on the machine, but I need Network (https://github.com/haskell/network). how can I include this source in my project and have it compile with my project?
14:30:33 <Welkin> configurator
14:30:43 <Welkin> for general parsing, use parsec
14:30:50 <impure_hate> ok!
14:31:03 <Welkin> https://hackage.haskell.org/package/configurator
14:31:21 <impure_hate> nice
14:31:24 <impure_hate> thank yo
14:31:24 <impure_hate> u
14:32:01 <impure_hate> for parsing binary files I guess it's better to use attoparsec, right?
14:32:18 <Welkin> parsec or attoparsec
14:32:24 <Welkin> it depends on your needs
14:32:36 <Welkin> attoparsec is faster, but it has horrible error messages
14:32:38 <Welkin> parsec is much nicer
14:32:51 <impure_hate> I'm trying to design a DSL that would generate ansible :)
14:33:07 <impure_hate> ansible's too much typing
14:33:11 <Welkin> then use parsec
14:33:21 <impure_hate> will do :)
14:33:46 <impure_hate> realworldhaskell is down :(
14:34:30 <marxs> can somebody help with some code
14:35:03 <impure_hate> Welkin: which form is preferred in parsec? standard or applicative?
14:35:12 <Welkin> impure_hate: applicative
14:35:20 <EvanR> standard
14:35:20 <impure_hate> thanks!
14:35:24 <marxs> the prop_lookUp fails for some reason: http://paste.ofcode.org/PZGqiEF6YKdjD5V2ZNF2Aw
14:35:24 <impure_hate> :)
14:35:30 <Welkin> what is "standard" anyway?
14:35:32 <EvanR> lol
14:35:42 <Welkin> monadic?
14:35:44 <marxs> when I run quickCheck on it
14:35:45 <EvanR> class Standard a where
14:41:15 <marxs> the prop_lookUp fails for some reason: http://paste.ofcode.org/PZGqiEF6YKdjD5V2ZNF2Aw when I run quickCheck on it
14:41:21 <pavonia> marxs: Does quickCheck handle errors? You first function crashes if the list isn't empty but no element matches the letter
14:41:50 <marxs> oh
14:42:42 <marxs> I'm not sure how to go about adding a guard in this example of list comprehension
14:44:34 <emmanuel_erc> marxs: Why don't you use the Maybe type?
14:44:42 <miniBill> look ma, no state: https://gist.github.com/miniBill/7fce1193e5f2c19a2a65
14:45:19 <miniBill> now I'm quite more happy
14:46:02 <marxs> emmanuel_erc: I've addressed that but I get the error saying " Failed! Exception: 'Prelude.head: empty list' (after 2 tests and 3 shrinks)"
14:48:22 <pavonia> marxs: Yeah, that's exactly the problem. You have to handle the case when the list is empty
14:49:27 <Welkin> marxs: don't use `head`
14:49:34 <Welkin> pattern match on it instead
14:49:41 <Welkin> or use headMay from Safe
14:49:51 <marxs> Welkin: Isn't that what I've done by using lookUp letter [] = letter
14:49:55 <marxs> in the case of an empty list?
14:51:51 <Gurkenglas_> miniBill, that computes f e twice to for expensive f you probably want to uninline that
14:52:50 <pavonia> marxs: You are handling the case of an empty input list, not an empty list comprehension. You input list can have many elements and still the list comprehension is empty
14:52:53 * hackagebot picologic 0.1.2 - Utilities for symbolic predicate logic expressions  https://hackage.haskell.org/package/picologic-0.1.2 (sdiehl)
14:53:04 <marxs> oh I see
14:54:18 <sm> impure_hate: or megaparsec
14:54:57 <sm> also, polyparse is less popular but claims to be easier 
14:57:39 <bennofs> Is it possible to splice some TH decs into a where clause?
14:57:42 <Ararat> Clint, ask what I did to deserve it.
14:59:26 <glguy> bennofs: I don't know how to do it, but the error message "Declaration splices are allowed only at the top level:" makes it seem unlikely
14:59:41 <Gurkenglas_> miniBill, stratum x s = maximumBy stratum' x (you might want to flip the arguments for an eta reduce)
15:00:26 <bennofs> glguy: ah, solved the problem differently. I only wanted to splice something into a where clause of a [d| |] clause, but I can just use letE instead and build a let instead of splicing the required things into the where
15:01:06 <glguy> bennofs: Seems like a good solution
15:04:03 <bennofs> is there a shortcut for fmap concat . sequence?
15:07:13 <ReinH> :t fmap concat . sequence
15:07:14 <lambdabot> (Monad f, Traversable t) => t (f [a]) -> f [a]
15:14:22 <EvanR> :t foldMap
15:14:24 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
15:18:51 <gfixler1> I need to ramp up on data modeling
15:19:18 <gfixler1> a coworker in another division wants me to give a talk on data modeling in Haskell
15:19:31 <gfixler1> that's an aspect of Haskell I've not explored much
15:19:35 <EvanR> ByteString
15:20:07 <gfixler1> what should I look into?
15:20:13 <EvanR> JBOB
15:20:26 <gfixler1> :)
15:20:29 <MarcelineVQ> "A talk? Well allright. Types, uh, sum, exponent, product, types, uh, monoids, type-safety, types, uh"
15:20:43 <gfixler1> MarcelineVQ: all good
15:20:57 <gfixler1> I think they're going to be interested in records - people, addresses, bought things
15:21:11 <gfixler1> are records awesome in Haskell yet?
15:21:18 <gfixler1> have we folded in all of those proposals?
15:21:20 <MarcelineVQ> Bring along slides of images that relate to the words you're saying but not the concepts you're expressing, that works every time
15:21:21 <Welkin> gfixler1: they will be in ghc 8
15:21:31 <Welkin> OverloadedRecordAccessors
15:21:37 <gfixler1> Welkin: should I push off the talk until then?
15:21:48 <Welkin> what talk?
15:21:56 <Welkin> I would say no
15:22:04 <gfixler1> the one my coworker wants me to give on modeling data in Haskell
15:22:18 <Welkin> there is also lens
15:22:36 <gfixler1> ah, lens
15:23:06 <gfixler1> What do people do when they need a record with 50 elements in it?
15:23:07 <EvanR> my structural set database isnt done yet, you cant talk about that
15:23:14 <gfixler1> do they just roll out a 50-element record?
15:23:29 <EvanR> what is the point of a 50 element record
15:23:47 <EvanR> when do you "need" that?
15:23:48 <gfixler1> to record 50 elements?
15:23:49 <Welkin> lol
15:23:56 <EvanR> right X Y
15:23:59 <gfixler1> I'm trying to play to my audience
15:24:05 <EvanR> ;_;
15:24:13 <gfixler1> we're not rocket lawyers here
15:24:32 <Welkin> un-normalized data?
15:24:36 <EvanR> just walk in, put up one slide "everything you know is wrong", drop the mic and walk out
15:24:54 <kadoban> Haha
15:25:04 <gfixler1> EvanR: http://globalnerdy.com/wordpress/wp-content/uploads/2007/10/john_mccarthy_successories_poster.jpg
15:25:17 <EvanR> lol
15:26:08 <EvanR> pracitcally you probably want to keep your records split up
15:26:25 <gfixler1> EvanR: I'm imagining they have tons of data points on customers and such
15:26:29 <gfixler1> metrics and whatnot
15:26:34 <EvanR> yeah, in tables
15:26:43 <EvanR> or represented in esoteric ways
15:26:46 <gfixler1> and text files, and post-its
15:26:52 <EvanR> data cubes
15:26:59 <gfixler1> isolinear chips
15:27:38 <gfixler1> I'm trying to think of at least one, hopefully more "cool" things
15:27:52 <gfixler1> I'm not sure "things working" and "safety" will be enough to turn heads
15:28:34 <marxs> why use if,else statements over using guards w/ an otherwise clause?
15:28:38 <impure_hate> is it possible to autogenerate bindings for e.g. python?
15:28:43 <EvanR> email this to everyone http://highscalability.com/blog/2013/11/25/how-to-make-an-infinitely-scalable-relational-database-manag.html
15:28:51 <Welkin> can I compose sql queries in esqueleto?
15:29:28 <gfixler1> EvanR: is that even haskell anymore?
15:29:43 <EvanR> im not sure if its anything
15:29:51 <gfixler1> I'm pronouncing it "infiniscule"
15:31:01 <EvanR> gfixler1: so ive been trying to work on modeling data as sets :: * and relations :: * -> *
15:31:16 <EvanR> this is modeling not necessarily big data analysis algorithms
15:31:25 <gfixler1> any luck?
15:31:26 <Hijiri> 2/disconnect
15:31:43 <EvanR> yeah, just no implementations
15:32:30 <EvanR> gfixler1: for data-oriented games, i have heard advice to stop the types more or less and just use a bunch of IntMaps to dynamically typed values
15:32:38 <EvanR> to drop* the types
15:33:07 <gfixler1> wow, seems so unprincipled
15:33:18 <EvanR> well, game programming almost 100% is unprincipled
15:33:33 <gfixler1> I'm in games, and working in Unity/C# all day has me thinking about how to do this in Haskell a lot
15:33:42 <gfixler1> EvanR: I know, I'm trying :)
15:33:57 <gfixler1> Unity uses the entity-component system
15:34:03 <gfixler1> entities are just buckets with a name/id#
15:34:10 <gfixler1> components imbue them with powers
15:34:20 <EvanR> weird
15:34:34 <EvanR> just sounds like oop
15:34:40 <gfixler1> Transform component lets it be in the 3D scene, Image lets it display an image, etc
15:34:43 <gfixler1> yeah, very similar
15:35:00 <gfixler1> it's very dynamic - you can throw components onto things throughout play
15:35:35 <gfixler1> to me it's a complete mess, but it looks cool when people get something going in a short while
15:35:48 <EvanR> in haskell i would expect the components-existing-causes-stuff-by-virtue-of-itself to be replaced with, entities have certain attributes or dont, and what that means depends on the game code
15:35:49 <gfixler1> it all just becomes more and more tangled as you continue to build out the game
15:36:09 <gfixler1> we have new bugs daily
15:36:10 <EvanR> the attributes are just values though, or maybe functions
15:36:19 <gfixler1> can't reason about order of things, race conditions, etc
15:36:23 <EvanR> keeping your schema straight sounds tough
15:36:46 <Welkin> FRP
15:36:50 <EvanR> gfixler1: thats why i would keep the interpretation of the data in a regular imperative program somewhere, one thing after the other
15:37:05 <gfixler1> it's just tons of classes and explicit access control everywhere, and lots of globally shared mutability
15:37:28 <gfixler1> EvanR: I want to do it monadically
15:37:40 <EvanR> yeah, IO monad
15:38:07 <gfixler1> the Haskell world is full of toy examples
15:38:08 <EvanR> observers and sooky effects caused by who knows at a distance sounds insane
15:38:15 <gfixler1> yeah
15:38:44 <gfixler1> not toy example: two characters fight, with powers based on their inventories, affecting the environment, and being affected by it, etc
15:39:04 <EvanR> the classic way would work
15:39:07 <Welkin> gfixler1: what about lambdacube3d?
15:39:14 <Welkin> quake was remade in it
15:39:19 <Welkin> also, monadius
15:39:25 <gfixler1> Welkin: that's on the very edge of my memory
15:39:35 <EvanR> loop through the physics steps, running each phase of the simulation one after the other in regular way, predictable effects of each one
15:39:43 <gfixler1> Welkin: ah, wasn't that the one that broke from haskell to make its own language?
15:39:50 <Welkin> yeah
15:39:57 <Welkin> lambdacube3s is pretty amazing now
15:40:04 <Welkin> http://lambdacube3d.com/
15:40:06 <gfixler1> EvanR: yeah, that's my guess, but I haven't done it yet, so it's still full of mysteries
15:40:15 <Welkin> they have their own hot-loading code editor in the browser too
15:40:39 <gfixler1> Welkin: wow, I'll have to look into it again
15:41:21 <Welkin> the went on a tour around europe this summer
15:41:25 <Welkin> they*
15:41:36 <Welkin> showing it off
15:42:15 <EvanR> gfixler1: for a saner data schema... then a collection of sets, relations, and functional rules would stop updates from messing up the data. you can change the content of relations at will, but adding and removing sets in isolation might be impossible due to rules and relations.
15:42:20 <gfixler1> the link on the page about font rendering looked extremely familiar
15:42:31 <nurupo> > (+4) 3221223972
15:42:31 <nurupo> > (+(length "test")) 3221223972
15:42:32 <EvanR> gfixler1: you might want to research this project too https://hackage.haskell.org/package/haskelldb
15:42:32 <gfixler1> checked my bookmarks file - had a link to lambdacube3d
15:42:33 <lambdabot>  3221223976
15:42:33 <lambdabot>  3221223976
15:42:44 <gfixler1> git blame - it was from the day before they posted that article
15:42:54 <gfixler1> I must have left the tab open for a few days and caught it just as it went up
15:43:01 <gfixler1> I love data
15:43:11 <nurupo> why do i get:
15:43:11 <nurupo> Prelude> (+(length "test")) 3221223972
15:43:11 <nurupo> -1073743320
15:43:12 <nurupo> ?
15:43:19 <nurupo> should be positive
15:43:24 <hpc> > maxBound :: Int
15:43:25 <lambdabot>  9223372036854775807
15:43:31 <bennofs> > maxBound :: Word32
15:43:32 <lambdabot>  4294967295
15:43:36 <hpc> oh right
15:43:45 <Welkin> > maxBound :: Int32
15:43:46 <lambdabot>  2147483647
15:43:53 <nurupo> see what lambdabot printed above
15:43:55 <Welkin> you must be using a 32 bit system
15:43:55 <hpc> > 3221223972 :: Int32
15:43:56 <lambdabot>  -1073743324
15:43:56 <EvanR> > 3221223972 :: Int32
15:43:58 <lambdabot>  -1073743324
15:44:00 <nurupo> oh
15:44:01 <gfixler1> lol, cannot copy text from scrolling screen
15:44:01 <bennofs> nurupo: you're on 32bit, so the maximum value an Int can take is maxBound :: Int32
15:44:03 <EvanR> your starting number is out of range
15:44:09 <gfixler1> weakness of terminal/weechat
15:44:13 <bennofs> > 3221223972
15:44:14 <lambdabot>  3221223972
15:44:18 <nurupo> > (+(length "test")) 3221223972
15:44:19 <bennofs> > 3221223972 + 4 :: Int32
15:44:19 <lambdabot>  3221223976
15:44:20 <lambdabot>  -1073743320
15:44:28 <nurupo> yeah, i'm on 32-bit
15:44:34 <nurupo> lambdabot should be on 64-bit then
15:44:45 <nurupo> since it works fine for him :)
15:44:59 <EvanR> gfixler1: ctrl+S used to freeze the scrolling ;)
15:45:05 <bennofs> nurupo: you can also use genericLength, but then you need to give a type signature
15:45:16 <EvanR> just make sure you know how to unfreeze
15:45:22 <gfixler1> haskell only guarantees Int up to 2^30
15:45:29 <bennofs> > genericLength "test" + 3221223972  :: Integer
15:45:31 <lambdabot>  3221223976
15:45:42 <sm> EvanR: "game programming almost 100% is unprincipled", that can't be right surely
15:45:49 <bennofs> ^^^ nurupo that will work on 32 bit as well, and with numbers larger than maxBound :: Int64 :)
15:45:49 <gfixler1> EvanR: not working on this macbook
15:45:59 <EvanR> chucknorris guarantees haskell Int go up to anything he wants
15:46:08 <Welkin> Integer*
15:46:24 <gfixler1> I tried to get ghci to tell me the type of a gigantic number was Integer, but it still said Num a => a
15:46:25 <johnw> Chuck Norris a bound that Integer is afraid to approach
15:46:30 <EvanR> sm: OOP isnt exactly a principle
15:46:31 <gfixler1> it just doesn't want to commit
15:46:53 <sm> I didn't mention it.. 
15:47:03 <gfixler1> could Chuck Norris defeat Max Bound?
15:47:12 <sm> there must be principles at work even if you're writing a game, is all
15:47:15 <EvanR> the principle is "get it working by release date... or not"
15:47:16 <Welkin> he can't defeat Max Headroom
15:47:26 <sm> we just need to understand them better
15:47:29 <gfixler1> sm: I think you'd be surprised
15:47:35 <gfixler1> sm: it's a complete free-for-all
15:47:42 <johnw> sm: most of those principles are in the $$ category though
15:47:43 <nurupo> bennofs: (+toInteger(length "test")) 3221223972
15:47:45 <nurupo> works too
15:47:50 <bennofs> yeah :)
15:47:53 <sm> a free-for-all is a project not using principles
15:47:57 <gfixler1> johnw: just had that chat at my yearly review yesterday
15:48:11 <johnw> gfixler1: which was that exactly?
15:48:18 <EvanR> principle, change code, recompile, see if the bug was fixed, repeat
15:48:20 <johnw> gfixler1: tell me in -blah
15:48:25 <gfixler1> johnw: basically "You're good, but stop being so principled and just get sh*t out the door faster"
15:48:51 <Welkin> gfixler1: so it can break 2 days later and then you have to go back and redo it :D
15:50:02 <EvanR> "all things in class X have the interface with word foo that takes anything, returns anything or nothing, and has any effect whatsoever"
15:50:11 <EvanR> "except some things in class X dont even have that"
15:51:29 <EvanR> not saying it doesnt produce games
15:52:00 <sm> can we say one of the "principles" or architectural requirements in video games is managing a lot of data with complex schemas, with both data and schema changing a lot at runtime
15:52:10 <sm> ..fast
15:52:49 <EvanR> thats a principle or is that a problem to be solved for the context
15:53:08 <EvanR> constraints to work with
15:53:14 <EvanR> or around
15:53:49 <EvanR> there are many more difficulties than that
15:55:55 <sm> EvanR: well, I read your comment as "there are no principles which apply to game programming".. maybe you were saying "game programming is almost 100% undisciplined ?"
15:56:03 <EvanR> maybe principle expands to generally applicable conceptual technique to help deal with such complexity
15:56:32 <johnw> sm: join us in -blah!
15:56:43 <EvanR> sm: no i wasnt saying theres no way to come up with such things
15:59:10 <sm> how to build video games in haskell is such a FAQ and still seemingly not well-solved, it's quite interesting
15:59:51 <EvanR> yeah, im working on a way to do it with not much memory
16:00:02 <EvanR> for low rez games
16:00:18 <EvanR> i dont think im smart enough to figure it out
16:00:59 <sm> EvanR: not much memory in what sense ?
16:01:13 <EvanR> on a microcontroller
16:01:23 <Welkin> EvanR: embedded c
16:01:29 <Welkin> oh, use ivory
16:01:39 <EvanR> no i want something like frp
16:02:07 <EvanR> the low mem might give an excuse to make it less complete
16:02:19 <EvanR> but hopefully still semantically sound
16:04:50 <sm> lispy: around ? I uploaded that heap profile http://heap.ezyang.com/view/3937dfd7cce7149e1042e2424a96ead28e34f0ff
16:04:55 <sm> nice viewer, thanks
16:06:58 <johnw> that's cool
16:07:13 <johnw> sm: can you also do an -hr profile?
16:07:16 <sm> (if only it didn't truncate the names...)
16:07:24 <sm> will do!
16:08:34 <EvanR> i had the same issue
16:09:50 <sm> EvanR: yes I remember.. any luck ?
16:11:59 <EvanR> with the truncating or memory usage
16:12:53 <nurupo> how can i give something a name to later reuse it in the same line?
16:13:01 <Lokathor> EvanR, there's lots of FRP videos and articles. Are any particularly good that you know of?
16:13:02 <Welkin> use a let binding
16:13:40 <Welkin> Lokathor: ocharles started a video series using reactive-banana
16:14:51 <Welkin> Lokathor: https://www.youtube.com/watch?v=qi2f8xhbzhs
16:15:18 <EvanR> Lokathor: not really... its a mess. I'd say read the Fran paper and then the Reactive paper. I have heard good things about reflex though
16:15:30 <Lokathor> I don't really need FRP for anything i'll work on any time soon I think
16:15:50 <sm> johnw: -hc http://heap.ezyang.com/view/0f9cf3dfccc7e7ff25c72d1a910730e8ad793bea, -hr http://heap.ezyang.com/view/cd6a58ba81e641fadfcb47fd59451634e8a870ec
16:16:09 <EvanR> after the two papers, conals historical blog posts on the subject seem kind of like an epilogue
16:19:07 <EvanR> one thing i havent done is to browse #haskell for all informal discussion of FRP
16:19:13 <EvanR> in the past
16:19:30 <EvanR> but that might be pretty awesome
16:20:22 <gfixler1> EvanR: I'd like something that can find interesting convos in the logs, and roughly figure out where they begin and end
16:20:56 <EvanR> you and every researcher ever
16:21:01 <gfixler1> ha
16:21:09 <sm> and with longer names.. but I'm not sure it helps: http://heap.ezyang.com/view/1334fb2f662b5b89c4461c04e14e2bdd02479295, http://heap.ezyang.com/view/e461b46b4705448255da1d9df59529af960f2b77
16:21:37 <kallisti> is multi-parameter typeclasses part of Haskell 2010?
16:21:40 <gfixler1> EvanR: I've read conal's two papers, but am not yet smart enough to really grok everything
16:21:54 <johnw> sm: how much memory do you think this should be using?
16:22:08 <EvanR> gfixler1: its a lot to digest
16:22:17 <sm> it's a good question, I don't actually have much idea
16:22:28 <sm> with 300k transactions, it reaches 2G, which seems too much
16:22:35 <EvanR> sm: pesky OTHER
16:23:05 <gfixler1> EvanR: I know I need to learn about integration - my math skills are crap
16:23:45 <EvanR> aol keywords i lately been using for FRP is "dynamic collections" which is a sticky point for a lot of bloggers
16:24:12 <sm> perhaps I should use that lib that measures values's heap size to get some insight
16:25:40 <EvanR> sm: luck with memory usage, for my program i did manage to change the memory usage to much less, but by using an algorithm so much slower (though seems more correct to me), that it doesnt seem as bad space wise
16:26:01 <EvanR> sm: whats your code?
16:26:30 <johnw> sm: readersForPathAndData is holding onto a lot of thunks
16:26:52 <sm> EvanR: the hledger parser. I was looking at https://github.com/simonmichael/hledger/blob/master/hledger-lib/Hledger/Read/JournalReader.hs#L104 but it could be many places
16:26:59 <johnw> and OTHER means that there are many values being held by >8 different thunks/values
16:28:02 <sm> I may have a bunch of knot-tied recursive values inflating things
16:28:11 <johnw> sm: can you link me to readersForPathAndData?
16:28:19 <sm> transactions contain postings which reference their parent transactions again
16:28:39 <sm> (but that's done at the end)
16:29:23 <sm> johnw: https://github.com/simonmichael/hledger/blob/master/hledger-lib/Hledger/Read.hs#L157
16:29:55 <johnw> ah, you've just got to love tuples
16:30:11 <johnw> I can't think of a single space leak that's been mentioned in this channel that didn't involve them
16:30:20 <sm> ouch
16:30:21 <johnw> sm: can you force f and s please?
16:30:26 <EvanR> do you think thats the issue?
16:30:27 <johnw> your lambda is holding those values
16:30:35 <EvanR> when i tried a strict pair, it did change things a lot
16:30:49 <EvanR> but curried is better?
16:30:57 <sm> johnw: as in.. readersForPathAndData (!f,!s) = ... ?
16:31:10 <johnw> well, if f and/or s are thunks, referencing those thunks in a lambda will not only keep the thunks around, but also whatever values are necessary to evaluate those thunks
16:31:12 <johnw> sm: yes
16:31:47 <johnw> the cost of a thunk isn't just its pointer, but the fact that the data it needs before evaluation may be MUCH larger than the data it represents after evaluation
16:32:11 <johnw> like "length xs" where xs is a 1G string
16:32:11 <johnw> that thunk takes 1G of memory
16:32:24 <johnw> (or is responsible for retaining 1G)
16:32:49 <EvanR> solution, make xs be a lazy generated string from something much less than 1G
16:33:08 <EvanR> but with IO, it seems like you often have to end up with 1G before continuing
16:33:15 <EvanR> for input
16:34:01 <johnw> EvanR: yes, that is often the better answer
16:34:01 <johnw> I'm not of the opinion that strict is automatically always better
16:34:26 <johnw> sm: what is that 's'?
16:35:03 <sm> johnw: the full journal content
16:35:21 <johnw> of that transaction, right?
16:36:08 <sm> no the full content of the journal, all txns. For this 10k journal, it's about a 1M string
16:36:29 <johnw> ah, well that at least explains a lot of why it's retaining data then :)
16:36:41 <Lokathor> So, it seems like the advantage of a record based data type over a tuple based newtype is that (1) the accessors are written for you automatically, (2) making a new value by updating one or more old values and keeping the rest the same is easy with records
16:36:46 <johnw> in that case, forcing s will likely don othing at all
16:36:51 <sm> yeah it didn't
16:36:57 <sm> tsk, who was this hack.. what an amateur..
16:37:03 <Lokathor> is that kinda the whole deal?
16:37:09 <johnw> Lokathor: and it doesn't unify with a tuple type :)
16:37:32 <bennofs> Shouldn't there be an instance Distributive (,) ?
16:37:39 <sm> johnw: soo.. I wouldn't have guess this function mattered, since it's only called once for each reader, of which there's 2-3
16:37:40 <johnw> sm: ok, next step then is to see the -p output
16:37:42 <Lokathor> i'm not clear on what that sentence means johnw 
16:38:04 <johnw> Lokathor: a 3 field record Foo is not the same type as a 3 element tuple
16:38:18 <johnw> whereas all 3 element tuples of the same element types have the same type
16:38:38 <bennofs> oh no, (,) would be like a "Bidistributive" :)
16:38:39 <johnw> sm: ok, we've established that it might be valid in retaining the memory
16:38:55 <Lokathor> but i said newtype not type, so wouldn't the fact that it's a newtype prevent people passing "normal" tuples without using the constructor?
16:39:07 <johnw> correct
16:39:12 <johnw> and this, I would argue, is what you want
16:40:13 <GLM> Can you ensure a function is pure if has a type like a -> b?
16:40:20 <Lokathor> It's a bit extra work to write the utility functions for accessors and such. The question becomes, how much overhead is there in having the record?
16:40:23 <sm> johnw: here's the -p profile: https://gist.github.com/simonmichael/6fbf858797ab50bf4c72
16:40:25 <johnw> GLM: turn on -XSafe
16:40:32 <Lokathor> I know that a newtype is compiled away entirely, right?
16:40:33 <johnw> sm: thanks, reading
16:40:36 <GLM> johnw:What does that do?
16:40:46 <johnw> GLM: it makes sure that a function of type a -> b is pure
16:40:55 <johnw> among a few other things
16:41:09 <GLM> johnw:But if I didn't have that arg, it could be as unpure as I wanted?
16:41:30 <johnw> yes
16:41:35 <johnw> with unsafePerformIO, the world is your oyster
16:41:45 <johnw> Lokathor: yes
16:41:54 <GLM> johnw:Why isn't that the default? It seems like Haskell touts pure functions but this doesn't guarantee it
16:42:53 <Gurkenglas_> GLM, so the Haskell source files written back when Safe didn't exist still work.
16:43:10 <sm> johnw: the parser is probably doing a lot of backtracking ?
16:43:19 <johnw> sm: oh yes indeed
16:43:26 <johnw> fixedlotprices is terribly inefficient
16:43:31 <GLM> Gurkenglas_: Shouldn't they be forced to change to be consistent with current standards?
16:43:33 <johnw> i'm reading it now
16:43:51 <johnw> it potentially does a LOT of work, and always backtracks on failure
16:43:55 <sm> I don't really trust myself to read profiles when parsec is involved, yet
16:44:08 <sm> monadically-sequenced things seem to nest forever
16:44:18 <Gurkenglas_> GLM, maybe in some future major version. Backwards compatibility is a good thing, and what's so bad about enabling Safe?
16:44:19 <johnw> it's allocating memory to preserve the input so it can backtrack
16:44:25 <sm> yes that makes sense
16:44:58 <johnw> you could make it fail sooner
16:44:59 <GLM> Gurkenglas_:I don't mind enabling safe. I mind because before I knew about it, I could write really bad code that I shouldn't have been able to
16:45:03 <Lokathor> GLM, -XSafe isn't on by default for the same reasons that -Wall isn't on by default
16:45:16 <GLM> Lokathor:What does -Wall do
16:45:32 <johnw> but better would be to do this parsing later
16:45:35 <Lokathor> turns on all possible Warnings
16:45:39 <hexagoxel> sometimes i _do_ want to launch rockets!
16:45:42 <johnw> I mean, you need to parse '{' ... '}' for other things too
16:45:55 <johnw> "fixedlotprices" prices should only kick in if an '=' is found between them
16:46:08 <sm> well.. by splitting the hledger and ledger parsers, {} will be gone so there's a win :)
16:46:13 <johnw> it shouldn't be tried on the entire annotation first, every time
16:46:17 <johnw> because it's so damn rare
16:47:04 <johnw> but this allocation doesn't necessarily explain high residency
16:47:27 <sm> I see.. so parse in stages ? I tried to avoid that so error locations are preserved, but I guess that can be handled
16:47:45 <johnw> with LL parsers like this, you want to branch on immediate tokens as much as possible
16:47:53 <johnw> so, parse as normal, and if '{' is encountered, go down that road
16:48:02 <johnw> but branch on that single character, not on a whole speculative parse
16:48:15 <sm> that makes sense
16:48:33 <johnw> I still don't get the high residency from OTHER though
16:48:46 <sm> polyparse has a "commit" which I think locks in a branch like that
16:49:01 <johnw> fixedlotprices is only keeps a few megabytes in memory
16:49:43 <EvanR> sm: is the journal string an actual String ?
16:50:01 <sm> yup
16:50:13 <EvanR> seems like thats a big memory hog too
16:50:25 <marchelzo> What is ~/.hoogle used for? Mine is 800 MB o.o
16:50:35 <EvanR> dealing with Megs of text you really need Text or ByteString
16:50:44 <sm> yeah, I want to try Text for sure
16:51:38 <johnw> i think ledger-parse is using Text
16:51:49 <johnw> or BS
16:51:59 <sm> (but presumably it wouldn't change this leak, just reduce the numbers)
16:52:20 <EvanR> from experience it would reduce it, but also avoid stack overflows
16:52:30 <EvanR> depending on what you do with the [Char]
16:53:07 <EvanR> 1M linked lists are pretty absurd
16:58:53 <sm> johnw: what makes you say fixedlotprices only keeps a few Mb in memory, when its individual allocation is reported as 21% ?
17:05:19 <c_wraith> sm: total allocation and maximum residency are very different. 
17:06:21 <kallisti> hm, isn't there an extension to allow an instance to be the default for a class when there's ambiguity?
17:06:26 <sm> oh right. And he knows fixedlotprice is responsible for only a few Mb maximum residency from teh heap profile I guess
17:12:53 <sm> got to go - thanks for looking at it johnw, EvanR. More to be revealed.
17:12:55 <lpaste> JulianLeviston pasted “I can't work out how to fix this” at http://lpaste.net/6813502905392300032
17:14:06 <lpaste> JulianLeviston pasted “Here's my source (that's causing the error)” at http://lpaste.net/142978
17:15:16 <julianleviston> Having a bit of a problem trying to get the “groundhog example” compiling after pulling it into a test project of my own… seems to just be an ambiguous type variable, but I can’t see how the error is arising...
17:16:24 <fizruk> julianleviston: did you try adding an explicit type signature for dbTest?
17:17:11 <julianleviston> fizruk: thanks! that worked fine.
17:17:29 <julianleviston> fizruk: I don’t understand why, really, though. :~/
17:18:08 <julianleviston> fizruk: is it because it knew it was a Monad, but couldn’t infer which one?
17:18:20 <julianleviston> fizruk:  sorry, I mean monadic expression.
17:19:32 <fizruk> julianleviston: try run that without explicit type signature and with {-# LANGUAGE NoMonomorphismRestriction #-}
17:20:01 <julianleviston> fizruk: how will that help me to understand what’s going on?
17:20:14 <kallisti> hm, so I return a lot of list results in webdriver, and it would be nice to use a typeclass to overload for any collection, but there are also situations where you don't actually use the result of a webdriver command, and do you'll get ambiguous instance errors.
17:21:24 <fizruk> julianleviston: afaik MonadIO is defaulted to IO
17:21:38 <fizruk> julianleviston: but in your case you also have MonadLogger constraint
17:21:57 <fizruk> julianleviston: which IO does not have instance for afaict
17:22:24 <julianleviston> fizruk: I don’t undertand how there’s a MonadLogger constraint. 
17:22:29 <fizruk> julianleviston: I first thought there is only a MonadIO constraint, so thought it should work as is
17:22:38 <fizruk> julianleviston: withSqliteConn :: (MonadBaseControl IO m, MonadIO m, MonadLogger m) => Text -> (SqlBackend -> m a) -> m a
17:22:39 <julianleviston> fizruk: i just changed to dbTest :: IO () and it worked fine, but I don’t know why.
17:22:54 <julianleviston> fizruk: hm. ok.
17:23:20 <kallisti> MonadIO does not default to IO
17:23:23 <julianleviston> fizruk: oh you looked that up in hackage did you
17:23:36 <fizruk> julianleviston: yes
17:24:27 <julianleviston> kallisti: seems a bit weird that it didn’t infer it given that I had main = dbTest, but oh well.
17:24:55 <fizruk> kallisti: ok, I got confused then
17:25:19 <kallisti> I don't actually think there's a way to specify a default instance for a typeclass, but this is actually something I would really like to have.
17:25:26 <kallisti> beyond Num/IsString
17:25:50 <fizruk> julianleviston: anyway, put type signatures for every top-level definition and you won't have troubles like this :p
17:26:16 <julianleviston> fizruk: doesn’t really help me in the future, but thanks for helping me now. I’m sure I’ll learn this stuff as I go.
17:26:42 <Lokathor> Welkin, i watched the first video about reactive-banana, but they're unlisted so i'm not sure where the next video is
17:26:51 <Lokathor> is there some blog post that links them all?
17:27:25 <Welkin> Lokathor: ask ocharles__ 
17:27:41 <kallisti> julianleviston: using dbTest in main will not make the actual type of dbTest less polymorphic
17:27:42 <Lokathor> ah
17:27:59 <Lokathor> ocharles__, got any more videos about reactive-banana? I saw the first one here https://www.youtube.com/watch?v=qi2f8xhbzhs
17:28:02 <julianleviston> kallisti: I don’t understand what that means.
17:28:05 <fizruk> kallisti: you're right, there isn't
17:28:55 <fizruk> julianleviston: there is a simple defaulting mechanism in Haskell, that allows you e.g. to default (Num a => a) to Integer
17:29:24 <fizruk> julianleviston: you might've seen warnings (with -Wall) about that defaulting taking place
17:29:27 <marchelzo> Does anybody know what the ~/.hoogle directory is for?
17:29:48 <julianleviston> fizruk: You’re telling me stuff, but I’m not sure what to do with it. 
17:29:53 <julianleviston> fizruk: thanks, though!
17:30:09 <kallisti> julianleviston: okay, for demonstration purposes I'm going to make an implementation of the function "when", do you know what "when" does?
17:30:20 <fizruk> julianleviston: sorry, I thought you were referring to a previous message from kallisti :)
17:30:27 <julianleviston> kallisti: not really - it’s like a conditional if inside a monad isn’t it? 
17:30:35 <kallisti> yes
17:30:37 <julianleviston> fizruk: I don’t know any more.
17:30:39 <c_wraith> marchelzo: I'd assume metadata and settings for the command line program. 
17:30:46 <julianleviston> kallisti: I don’t understand why you’re telling me this.
17:30:47 <kallisti> that's fine it's pretty easy to understand once you see the code for it
17:30:52 <fizruk> julianleviston: just ignore me :p
17:31:00 <julianleviston> fizruk: THAT, I can do :)
17:31:07 <julianleviston> fizruk: thanks for helping me.
17:31:33 <kallisti> :t when
17:31:34 <lambdabot> Applicative f => Bool -> f () -> f ()
17:31:48 <fizruk> cool, it's Applicative!
17:32:03 <julianleviston> kallisti: I think maybe you’ve misunderstood me. It’s not that I don’t understand what you MEANT. It’s that I didn’t understand how you said it.
17:32:33 <julianleviston> kallisti: I didn’t understand what this means: using dbTest in main will not make the actual type of dbTest less polymorphic
17:33:21 <julianleviston> kallisti: if I flip the pos/neg of it, I get: using dbTest in main will not change its polmorphic / monomorphic nature. (its typing)
17:33:25 <fizruk> julianleviston: dbTest is top-level, so it gets its type as general as typechecker can infer (I guess I am right here)
17:33:41 <julianleviston> fizruk: that’s understandable. :) thanks.
17:34:16 <julianleviston> kallisti: yeah, I understand it now, I think. You were just trying to say that specifying its type won’t change how polymorphic it is?
17:34:25 <fizruk> monomorphism restriction only takes place for let/when bindings I think
17:34:38 <julianleviston> fizruk: see, there’s nothing in that statement for me.
17:35:10 <julianleviston> fizruk: I’m not sure what a monomorphism restriction is, or why one would be interested in that, or even if it’s useful for me to know right now.
17:35:40 <sgronblo_> does anyone know how i would pass through snap's -f development flag when building with stack?
17:35:49 <fizruk> julianleviston: monomorphism restriction is what it sounds like — you get monomorphic functions (not polymorphic)
17:36:22 <julianleviston> fizruk: ok. So the problem was I didn’t know what monomorphism was. Now I get it (You mean it has a concrete type - ie not polymorphic).
17:36:27 <fizruk> julianleviston: this is a restriction by default because there are inference problems if everything has maximum polymorphism by default
17:36:49 <julianleviston> fizruk: GOD that’s a complicated way to explain that.
17:37:01 <julianleviston> fizruk: but thank you :)
17:37:19 <fizruk> julianleviston: well, I try :)
17:38:35 <c_wraith> fizruk: it's actually about efficiency, not inference. 
17:38:36 <kallisti> julianleviston: hold on I'm testing some stuff to make sure I have this right
17:39:07 <fizruk> c_wraith: I thought there was something about ambiguity too, was I wrong?
17:39:56 <fizruk> I probably was, I haven't faced monomorphism restriction for a long time
17:40:08 <c_wraith> fizruk: there's potential ambiguity with or without it. It's really just about the implementation details of classes as dictionary passing. 
17:41:39 <fizruk> "Basically, it solves one practical problem (without the restriction, there would be some ambiguous types) and one semantic problem (without the restriction, there would be some repeated evaluation where a programmer might expect the evaluation to be shared)."
17:41:46 <fizruk> from https://wiki.haskell.org/Monomorphism_restriction
17:42:46 <c_wraith> OK, but it doesn't solve the ambiguity problem. It just eliminates it by force in one uncommon case,and ignores all the more common cases 
17:43:01 * hackagebot warp 3.1.6 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.1.6 (KazuYamamoto)
17:43:59 <julianleviston> woo! I had the same problem and recognised it an fixed it. Yay.
17:44:55 <sgronblo_> no stack users here?
17:45:03 <kallisti> julianleviston: yeah I was actually going to mention monomorphism restriction but I actually don't think that's what was causing the ambiguity now.
17:45:58 <julianleviston> kallisti: when you say “the ambiguity” do you mean in me, or in the compiler’s attempt at type inference?
17:46:03 <fizruk> c_wraith: yes, I see what you mean, here's motivation for monomorphism restriction in the Report https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-930004.5.5
17:46:06 <kallisti> julianleviston: type inference
17:46:19 <julianleviston> kallisti: ahhh. ok :) 
17:46:41 <julianleviston> kallisti: I don’t need to know what was causing it. 
17:46:51 <fizruk> sgronblo_: just ask away
17:46:57 <julianleviston> fizruk:  he did ask.
17:47:03 <sgronblo_> fizruk: already did
17:47:20 <sgronblo_> im trying to run snap in development mode
17:47:25 <EvanR> monomorphism restriction? the original language feature designed to confuse newbies ? ;)
17:47:39 <julianleviston> EvanR:  EVERYTHING confuses me :)
17:47:49 <fizruk> sgronblo_: I am sorry, I missed your message
17:47:56 <sgronblo_> but their instructions are cabal specific "cabal install -f development" and i cant figure out what stack build command to translate it to
17:48:07 <fizruk> sgronblo_: you can add the flag to stack.yaml
17:48:23 <sgronblo_> fizruk: yeah i was trying to do that, but didnt succeed
17:48:38 <fizruk> sgronblo_: https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md#flags
17:48:46 <sgronblo_> i tried flags: {snap: { development: true}}
17:49:23 <sgronblo_> should match with this right? http://snapframework.com/faq#how-do-i-run-my-app-in-development-mode
17:49:43 <sgronblo_> maybe i a already running in dev mode?
17:49:58 <sgronblo_> but stack exec my-web-app doesnt tell me explicitly
17:49:58 <fizruk> sgronblo_: the flag is not for snap package
17:50:12 <fizruk> sgronblo_: that flag is for your project
17:50:18 <sgronblo_> fizruk: oh!
17:51:03 <fizruk> sgronblo_: so it should be flags: {my-project: {development: true}}
17:51:31 <sgronblo_> fizruk: thanks, i should check a bit more about exactly what development means as well i think :)
17:53:14 <kallisti> julianleviston: yeah I'm not sure what caused the inference problem. my best guess is it has something to do with one of the type extensions you're using, but I can't pinpoint which one.
17:54:20 <julianleviston> kallisti: thanks.
17:55:07 <Cale> http://reply.obsidian.systems/ -- Hey everyone check this thing out. It's a lisp repl written in Haskell using reflex-dom :)
17:56:40 <Welkin> Cale: the page took too long to load, so I left
17:57:03 <Cale> Welkin: hmm, it only takes about a second to load here
18:07:37 <nshepperd>  /url 1
18:07:47 <nshepperd> bah
18:09:34 <CEGL> @pl z a b=uncurry(++)$span(==b)a
18:09:34 <lambdabot> z = (uncurry (++) .) . flip (span . (==))
18:10:18 <CEGL> I hope there's function shortener
18:11:28 <CEGL> Somebody know how to golf code on Haskell?
18:13:04 <johnw> yes, just ask here
18:16:05 <Cale> CEGL: Isn't that just id?
18:16:13 <fizruk> ?check \a b -> (uncurry(++)$span(==b)a) == a
18:16:15 <lambdabot>  +++ OK, passed 100 tests.
18:16:33 <Cale> Or rather, const
18:16:35 <fizruk> that's not a real check though, is it, lambdabot?
18:16:54 <Cale> ?check \a b -> (uncurry(++)$span(==b)a) == (a :: [Integer])
18:16:56 <lambdabot>  +++ OK, passed 100 tests.
18:17:40 <fizruk> that's better)
18:19:34 <julianleviston> is “Beginning Haskell” a good book to learn quickly how to build software with? Anyone read it?
18:19:37 <sam-d> fizruk: wouldn't it be different from a in that everything (==b) would be moved to the front of a?
18:20:32 <fizruk> > span (== 3) [1, 2, 4, 3, 5, 7, 3, 3, 3, 9, 10]
18:20:34 <lambdabot>  ([],[1,2,4,3,5,7,3,3,3,9,10])
18:20:52 <sam-d> ah, I misunderstood span I guess
18:20:53 <fizruk> > span (== 3) [3, 3, 3, 3, 1, 2, 4, 3, 5, 7, 3, 3, 3, 9, 10]
18:20:55 <lambdabot>  ([3,3,3,3],[1,2,4,3,5,7,3,3,3,9,10])
18:21:25 <sam-d> that's what I get for only looking at the type
18:21:27 <awpr> sam-d: partition is probably what you thought span was
18:21:31 <sam-d> yeah
18:21:53 <fizruk> :t span
18:21:54 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
18:22:00 <fizruk> :t partition
18:22:01 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
18:22:03 <Cale> julianleviston: I haven't really looked at it... https://www.reddit.com/r/haskell/comments/1wtdlf/new_haskell_book_beginning_haskell_a_projectbased/ -- there are some good reviews here
18:22:11 <fizruk> :t break
18:22:12 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
18:22:17 <julianleviston> Cale: yeah, I’m reading that now… thanks :)
18:22:37 <julianleviston> Cale: the google was my first port of call. Just wondered if any people in here had read it. 
18:26:29 <julianleviston> Cale: there’s a scathing review here, based around technical errors. https://llaisdy.wordpress.com/2014/04/26/review-beginning-haskell/
18:27:20 <Cale> julianleviston: interesting
18:29:52 <garrett> What is the difference between traversable and foldable?
18:32:18 <Cale> Traversable and Foldable are really quite different...
18:33:31 <Guest25128> Cale, It might be my mental model but it seems like everything that is traversable should be able to fold on it
18:33:31 <Cale> Traversable is for data structures which have the property that if you fill them with actions in some Applicative or Monad, you can transform such a container of actions into a single action which produces a container of the results with the same structure
18:34:06 <Cale> If you could show that this is the case, I would be quite happy.
18:34:13 <Cale> Foldable is kind of ugly
18:34:31 <Cale> and so if you could implement foldMap in terms of traverse, that would be very interesting.
18:35:04 <nshepperd> you can, that's why traversable is a subclass of foldable
18:35:31 <Cale> nshepperd: uh, you mean the other way?
18:35:33 <nshepperd> getConst . traverse (Const . f)
18:35:37 <Guest25128> nshepperd, So all traversables are foldable but not all foldables are traversable?
18:35:44 <nshepperd> Guest25128: yup
18:36:24 <Cale> nshepperd: hmm
18:36:37 <Cale> nshepperd: Well, that isn't always what the Foldable instance does
18:36:51 <Cale> Unless I'm misunderstanding what that code does :)
18:38:37 <Cale> Oh, the Applicative instance for Const uses Monoid
18:38:39 <Cale> huh!
18:38:46 <Cale> So that's amusing
18:39:00 <Cale> and enlightening
18:39:10 <Cale> Now: why does Foldable exist?
18:39:44 <Cale> Maybe there really are Foldables which aren't Traversable, I suppose.
18:40:13 <CEGL> It's very difficult to log in back because of my ultra-slow modem.
18:41:05 <CEGL> I somehow misread the span function. I think it will exclude the item selected. It's not.
18:41:41 <nshepperd> yeah
18:42:00 <nshepperd> well, if you have a GADT, that can be foldable without being traversable
18:42:03 <CEGL> uncurry(++)$span(==b) was thought to remove b from list a.
18:42:59 <CEGL> my closest way to delete first item in array is []!_=[];(x:y)!z|x==z=y|2>1=x:(y!z);
18:43:03 * hackagebot monad-parallel 0.7.2 - Parallel execution of monadic computations  https://hackage.haskell.org/package/monad-parallel-0.7.2 (MarioBlazevic)
18:43:16 <CEGL> @pl []!_=[];(x:y)!z|x==z=y|2>1=x:(y!z);
18:43:16 <lambdabot> (line 1, column 4):
18:43:16 <lambdabot> unexpected "_"
18:43:16 <lambdabot> expecting white space or simple term
18:44:41 <Guest25128> Is a tree traversable or foldable?
18:45:47 <CEGL> Curious. []!_=[];(x:y)!z|x==z=y|2>1=x:(y!z); is feedable into REPL with prefix let. But it's not feedable with lambdabot.
18:46:21 <CEGL> Replace closest with shortest.
18:47:28 <tobiasBora> Hello !
18:47:54 <CEGL> Hello. I am confused how to shorted
18:48:14 <CEGL> Misenter. How to shorten a function to delete item.
18:48:19 <nshepperd> I think unordered trees are generally traversable
18:48:22 <tobiasBora> I've a little question : is it possible to display the documentation of a function in an Haskell interpreter (like ghci) ?
18:48:50 <nshepperd> but something like a Data.Set is only foldable, since there is the Ord constraint on modifying the contents
18:49:35 <CEGL> My shortest function is []!_=[];(x:y)!z|x==z=y|2>1=x:(y!z);
18:50:15 <arkeet> what is it supposed to do?
18:50:19 <arkeet> also the final ; is not necessary.
18:50:56 <johnw> tobiasBora: it takes a fair bit of work to make that possible
18:51:02 <arkeet> removes an element from a list?
18:51:03 <pavonia> tobiasBora: Not yet ;)  https://ghc.haskell.org/trac/ghc/ticket/2168
18:51:03 <johnw> but with hoogle it can be done to some degree
18:51:24 <CEGL> It's just copy paste. It is meant to be embedded in let expression. It deletes first item that is equal to z
18:51:47 <CEGL> Loading Data.List just make my program longer.
18:52:02 <tobiasBora> johnw: The problem of hoogle is that it needs internet connection. Do you know if it's simple to use it without any need of internet connection ?
18:52:10 <johnw> I'm pretty sure "delete z" is as short as it gets
18:52:13 <arkeet> tobiasBora: offline hoogle.
18:52:21 <arkeet> you can have a local hoogle db
18:52:22 <dolio> Cale: Set.
18:52:27 <kallisti> Is it possible to test for the existing of cabal build flags in CPP?
18:52:34 <Cale> dolio: right
18:52:54 <CEGL> Golfing.
18:53:12 <CEGL> Every byte counts
18:53:20 <lispy> sm: thanks
18:53:26 <lispy> nbrader: I'm there now
18:53:27 <Cale> dolio: I'm not sure I've ever even used the Foldable instance for Set, but yeah, heh, now I recall this coming up as an example before.
18:54:33 <kallisti> ah I see how to do CPP flags from build flags now
18:57:30 <CEGL> And after trying, it is dramatically make my program shorter. I don't think of retrying before.
19:13:48 <tobiasBora> arkeet: Thank you !
19:25:52 <kallisti> does the parallel package mysteriously not exist anymore?
19:30:02 <jenny38> i need a concat function that works on monads, something :: IO [[a0]] -> IO [a0]. How do I do that?
19:30:36 <joehillen> any lens experts around? https://stackoverflow.com/questions/33115595/how-can-i-use-ix-0-in-an-independent-getter
19:32:05 <kadoban> :t fmap concat :: IO [[a]] -> IO [a] -- jenny38
19:32:06 <lambdabot> IO [[a]] -> IO [a]
19:32:54 <bitemyapp> joehillen: which AWS library is that?
19:33:08 <joehillen> bitemyapp: amazonka
19:33:17 * bitemyapp fires off stack
19:34:40 <joehillen> bitemyapp: nevermind, I figured it out
19:35:12 <bitemyapp> joehillen: tell me pls
19:35:13 <nshepperd> jenny38: if you need to apply a function to the value 'inside' a monad, you use fmap
19:35:29 <joehillen> bitemyapp: writing the answer now
19:35:48 <jenny38> thanks. that helped kadoban and nshepperd.
19:38:01 <joehillen> bitemyapp: http://stackoverflow.com/a/33115686/334632
19:38:15 <jenny38> question though. if i have  a function  f :: IO [[Int]] and i try :t fmap concat f I get an error. but it works if i do f :: IO [Int]; f = fmap concat $ <orignal f body> it works
19:38:18 <jenny38> why is that?
19:38:29 <bitemyapp> joehillen: danke
19:38:46 <bitemyapp> joehillen: yeah, no longer just a lens. Makes sense.
19:39:26 <bitemyapp> joehillen: this is why one my go-to sanity-checks is "drop the type assertion, see what floats". Also why I'm grateful for Ed keeping the inference working.
19:40:29 <kadoban> jenny38: What error? Paste code and error to http://lpaste.net/new/haskell
19:41:25 <lispy> jenny38: it seems like something else might be wrong, see for example this:
19:41:27 <lispy> :t let { f :: IO [[Int]]; f = return [] } in fmap concat f
19:41:28 <lambdabot> IO [Int]
19:43:30 <EvanR> jenny38: f isn't a function
19:43:43 <EvanR> thats the problem
19:44:21 <EvanR> oh nvm
19:49:37 <kadoban> (though they're right, it's not a function ^)
20:18:46 <jenny38> okay next question. I have vs :: IO [String]. How do i do list operations like head, take, drop, takeWhile, etc. on vs.  If i try take 1 vs i get 'Couldn't match expected type `[a1]' with actual type `IO [String]''
20:19:42 <sgronblo_> jenny38: you can fmap on IO since it's a Functor
20:20:21 <jenny38> i tried fmap..no dice. should it be fmap (take 1) vs
20:20:47 <sgronblo_> or you can just do myList <- yourIoStringListHere and then operate on myList if you are already in an IO function
20:21:53 <awpr> :t fmap (take 1) (return [2,4] :: IO [Int]) 
20:21:54 <lambdabot> IO [Int]
20:36:59 <Guest25128> > take 1 []
20:37:01 <lambdabot>  []
20:39:01 <Welkin> > take 1000 []
20:39:03 <lambdabot>  []
20:58:55 <fabianhjr> Hello, searching something akin of: (a -> b) -> [a] -> [(a, b)], tried touse hoggle; think I might be going with a zip a a and then map the last value of every tuple.
20:59:17 <fabianhjr> Is there a better way to archive this?
20:59:28 <glguy> thing xs = [ (x, f x) | x <- xs ]
20:59:40 <awpr> :t \f -> map (id &&& f)
20:59:41 <lambdabot> (a -> c') -> [a] -> [(a, c')]
21:00:34 <awpr> that's one of the less obfuscated uses of &&&, but depending on the audience the other one is probably better
21:01:19 <glguy> The &&& one is good if your audience is lambdabot
21:01:37 <awpr> also particularly good for code golf :)
21:01:44 <fabianhjr> awpr: thhanks
21:04:39 <awpr> :t \f -> map ((,) <*> f)
21:04:40 <lambdabot> (a -> a1) -> [a] -> [(a, a1)]
21:13:13 <ReinH> jenf :: IO [[Int]] is not a function.
21:13:25 <ReinH> er
21:13:32 <ReinH> Never mind, I guess.
21:14:04 <ReinH> awpr: (&&&) is a pretty useful combinator for working with funcional algorithms. Bird uses it a lot.
21:14:23 <ReinH> *functional
21:16:51 <awpr> indeed, I rather like it.  it's nice for atomicModifyIORef too
21:17:22 <ReinH> (id &&& f) is an especially useful idiom for, e.g., Schwartzian transforms.
21:17:51 <ReinH> e.g., map fst . sortBy (comparing snd) . map (id &&& f)
21:21:43 <sgronblo_> are stack clean and cabal clean comparable to each other, i dont know either tool very well yet
21:22:23 <arkeet> :t sortOn
21:22:24 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
21:23:39 * hackagebot dns 2.0.1 - DNS library in Haskell  https://hackage.haskell.org/package/dns-2.0.1 (KazuYamamoto)
21:32:07 <jle`> (&&&) is nice but i sometimes wish there was a nicer thing than (id &&& f) and stuff like that
21:33:13 <jle`> ( `ap (,)` is not an answer )
21:33:32 <Guest25128> How can I compose two functions that take two and one arguments respectively?
21:33:40 * hackagebot webdriver 0.8 - a Haskell client for the Selenium WebDriver protocol  https://hackage.haskell.org/package/webdriver-0.8 (AdamCurtis)
21:33:47 <awpr> :t (.).(.) -- is this what you're looking for?
21:33:48 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
21:34:24 <jle`> Guest25128: some people like writing (\x -> g . f x)
21:34:43 <jle`> or foo x = g . f x to define their composition
21:35:04 <jle`> there's also the classic foo x y = g (f x y)
21:35:50 <Guest25128> awpr, Yeah, that's what I want. Can't say it looks visually appealing though
21:36:09 <awpr> @let (.:) = (.).(.) -- is what I do
21:36:10 <lambdabot>  Defined.
21:36:30 <awpr> > ((+) .: (*2)) 1 8
21:36:32 <lambdabot>      Could not deduce (Num a10)
21:36:32 <lambdabot>      from the context (Num a1, Num a, Num (a1 -> a))
21:36:32 <lambdabot>        bound by the inferred type for ‘e_1218’:
21:36:35 <Guest25128> Is there a clean way in freepoint to do it or is that the main way?
21:36:39 <awpr> > ((+) .: (*2)) 1 8 :: Int
21:36:40 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘a0 -> a0’
21:36:40 <lambdabot>      Probable cause: ‘(+) .: (* 2)’ is applied to too few arguments
21:36:40 <lambdabot>      In the expression: ((+) .: (* 2)) 1 8 :: Int
21:37:05 <kallisti> "clean"
21:37:05 <Guest25128> Shouldn't there be three numbers?
21:37:26 <kallisti> in my experience "clean" and "pointless" are often competing concerns. :)
21:37:32 <Guest25128> > ((+) .: (*2)) 1 8 4
21:37:34 <lambdabot>      Could not deduce (Num a10)
21:37:34 <lambdabot>      from the context (Num a1, Num a, Num (a1 -> a))
21:37:34 <lambdabot>        bound by the inferred type for ‘e_12184’:
21:37:47 <Guest25128> > ((+) .: (*2)) 1 8 4 :: Int
21:37:49 <lambdabot>      No instance for (Num (a10 -> Int))
21:37:49 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
21:37:49 <lambdabot>        arising from a use of ‘*’
21:38:08 <awpr> > ((+) .: (*2)) 1 8 -- this is what I meant to do
21:38:10 <lambdabot>      Could not deduce (Num a10)
21:38:10 <lambdabot>      from the context (Num a1, Num a, Num (a1 -> a))
21:38:10 <lambdabot>        bound by the inferred type for ‘e_1218’:
21:38:36 <awpr> I entered it wrong again... but flip the arguments and it works.
21:40:08 <mniip> > ((*2) .: (+)) 1 8
21:40:09 <lambdabot>  18
21:41:04 <Guest25128> mniip, Thanks
21:53:55 <EvanR> .:: = (.).(.).(.) and so on
21:54:48 <EvanR> but theses are like folklore, are they in any library?
22:06:56 <liste> @hackage composition
22:06:56 <lambdabot> http://hackage.haskell.org/package/composition
22:11:20 <liste> what's the easiest way to cross-compile x86->arm with Cabal+GHC? _TARGET_ARCH etc?
22:11:47 <liste> or do I need to install a parallel toolchain? how?
22:11:59 <liste> reading the GHC wiki page atm
22:13:41 * hackagebot unix-time 0.3.6 - Unix time parser/formatter and utilities  https://hackage.haskell.org/package/unix-time-0.3.6 (KazuYamamoto)
22:25:49 <waressearcher2> haskel has good support for parallel programming ?
22:26:23 <liste> waressearcher2 absolutely
22:26:29 <liste> both concurrency and parallelism
22:26:47 <jle`> that's actually widely considered one of the "killer apps" of haskell
22:26:54 <waressearcher2> I saw a little example where haskel programm can reuse many cores, but can it reuse many PCs same way ? 
22:27:11 <liste> waressearcher2 there's Cloud Haskell
22:27:16 <jle`> immutable-by-default data structures kills a lot of the typical pitfalls/headches encountered in concurrent programming in other languages
22:27:31 <jle`> waressearcher2: there's a library for that, yeah
22:27:34 <liste> waressearcher2 https://haskell-distributed.github.io/
22:27:50 <EvanR> parallel processing on multiple cores though
22:28:33 <EvanR> easy to do, hard to get any benefit from?
22:30:29 <Hijiri> sometimes easy
22:31:01 <Hijiri> like if you have to map an expensive operation over a large traversable
22:34:12 * hackagebot language-lua2 0.1.0.4 - Lua parser and pretty printer  https://hackage.haskell.org/package/language-lua2-0.1.0.4 (mitchellwrosen)
22:46:15 <nitrix> :T (.::)
22:46:18 <nitrix> :t (.::)
22:46:19 <lambdabot>     Not in scope: ‘.::’
22:46:19 <lambdabot>     Perhaps you meant ‘.:’ (line 159)
22:46:52 <EvanR> @let (.::) = (.).(.).(.)
22:46:54 <lambdabot>  Defined.
22:46:56 <EvanR> :t (.::)
22:46:58 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
22:47:41 <nitrix> So that's the composition of a trinary and binary function?
22:49:22 <EvanR> partially apply while preserving all the arguments
22:50:23 <awpr> "precompose a function onto the Nth argument"
22:50:41 <awpr>  er, disregard that
22:50:46 <EvanR> no one knows
22:50:52 <EvanR> just use it
23:24:14 * hackagebot hastily 0.1.0.5 - A program to download subtitle files.  https://hackage.haskell.org/package/hastily-0.1.0.5 (sras)
23:28:11 <MarcelineVQ> http://lpaste.net/142996 is ((f <$>) <$> as) pretty common in functors or should I be writing this differently?
23:29:20 <johnw> i'd personally write that as fmap f <$> as
23:29:48 <MarcelineVQ> I can see how that'd be beneficial
23:39:15 * hackagebot hastily 0.1.0.6 - A program to download subtitle files.  https://hackage.haskell.org/package/hastily-0.1.0.6 (sras)
23:39:56 <Lokathor> is it just me or does the over lens read better prefix than infix?
23:40:05 <Lokathor> i'm looking at an example and they keep using it infix
23:40:28 <johnw> I've never seen the non-operator form of it used infix actually
23:40:59 <Lokathor> both `over` (+10) $ (1, 2)
23:41:06 <Lokathor> is one of the examples
23:41:21 <johnw> huh, first time I've ever seen that type of usage
23:42:28 <klugez> Yeah, I think almost everyone uses %~ when they want an infix over.
23:43:05 <Lokathor> i like over as prefix, looks good and reads good
23:43:14 <arkeet> > (1,2) & both %~ (+10)
23:43:16 <lambdabot>  (11,12)
23:43:18 <arkeet> > (1,2) & both +~ 10
23:43:21 <lambdabot>  (11,12)
23:43:24 <Lokathor> > over both (+10) (1,2)
23:43:25 <lambdabot>  (11,12)
23:43:40 <arkeet> "over both" reads nicer than "both over" imo.
23:43:42 <funk> hi, cabal install grapefruit-ui-gtk yields src/Internal/UIItem.hs-boot:12:2: lexical error at character 'i' any clues? googled something about boot files but i am a noob..
23:44:50 <Lokathor> arkeet, maybe that's just because we speak subject verb object languages i guess
23:45:09 <arkeet> the verb there is (+10)
23:45:57 <arkeet> besides, these are english names :-)
23:46:25 <Lokathor> they are
23:46:47 <Lokathor> and though the +10 is strictly speaking the verb, the preposition there is the most important part I'd say
23:48:36 <EvanR> or is the whitespace the most important part
23:48:54 <Lokathor> icouldfigurewhat'sgoingonwithoutthewhitespaceifihadto
23:49:14 <EvanR> overboth(+1)$(1,2)
23:50:52 <Lokathor> > both `over` (+10) (1, 2)
23:50:54 <lambdabot>      Couldn't match type ‘(a0, Identity b0)’ with ‘a -> Identity b’
23:50:54 <lambdabot>      Expected type: Setting (,) (r a a) (r b b) a0 b0
23:50:54 <lambdabot>        Actual type: (a -> Identity b) -> r a a -> Identity (r b b)
23:51:02 <Lokathor> > over both (+10) (1, 2)
23:51:04 <lambdabot>  (11,12)
23:51:09 <Lokathor> huh
23:51:30 <EvanR> precedence
23:51:31 <arkeet> careful of precedence
23:52:00 <arkeet> both `over` (+10) (1, 2) = over both ((+10) (1, 2))
23:52:43 <Lokathor> i mostly use `` for predicates when there's just one thing on each side
23:52:55 <Lokathor> line `isBelow` point
23:54:07 <EvanR> Bools
23:54:13 <EvanR> Bools for fools
23:55:29 <EvanR> Boolproof
23:56:16 <Lokathor> sometimes people have gotten on my case about boolean blindness
23:56:25 <Lokathor> when it was specifically a predicate i was writing
23:56:43 <johnw> boolean blindness becomes very real in dependently typed programming
23:57:15 <johnw> when you're asked to provide a witness to some proof, and all you have is a True, it's pretty much worthless unless you know where it came from and why it's not False
23:57:16 <jle`> the best* measure of code quality is a low ratio of bools per line
23:57:30 <Lokathor> i'm vaguely aware of the idea that it reduces the information available or something
23:57:44 <Lokathor> but i specifically wanted to do one or the other thing depending on what a situation was
23:57:56 <Lokathor> so complaining about boolean blindness in that case seemed rather off base
23:57:58 <EvanR> the situation being True or False
23:58:12 <awpr> > take 10 $ let x = True:x in x
23:58:14 <lambdabot>  [True,True,True,True,True,True,True,True,True,True]
23:58:23 <awpr> ^ infinite bools per line, worst code possible
23:58:29 <Lokathor> ha
23:58:38 <Hafydd> That looks rather finite to me.
23:58:41 <Hafydd> Perhaps you ment:
23:58:45 <Hafydd> > let x = True:x in x
23:58:46 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
23:58:59 <awpr> eh I didn't want to DOS lambdabot, wasn't sure what it would do
23:59:22 <EvanR> whatever you do dont make it divide by zero
23:59:34 <liste> > 0 / 0
23:59:34 <jle`> that's an ip ban offence
23:59:36 <lambdabot>  NaN
23:59:42 <Hafydd> Yes. You might just be disgusted by the result.
23:59:42 <jle`>  @where ops
23:59:54 <Hafydd> > 0 `div` 0
23:59:56 <lambdabot>  *Exception: divide by zero
23:59:58 <Hafydd> That's better.
