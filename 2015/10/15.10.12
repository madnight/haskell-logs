00:00:28 <EvanR> the very last couple sentences do shed some light on how to plan for this
00:00:28 <echo-area> jle`: One thing that I'm not so sure is to solve `a -> b ~ f0 b0` I assume `f0 ~ (->) c0`.  Is this a valid step?
00:01:04 <echo-area> Or a valid method in general
00:02:49 <jle`> echo-area: rephrase the left hand side into ((->) a) b
00:03:11 <jle`> and so (->) a ~ f0, b ~ b0
00:04:38 <echo-area> jle`: Ah, it is clearer this way, now I see why it is a right step.  Thank you!
00:05:40 <EvanR> except the blog post says that seq a b evaluates a to WHNF whenever b is evaluated
00:05:47 <EvanR> is that true?
00:06:03 <EvanR> stack overflow references something that says HNF ... which is weird
00:07:00 <EvanR> the reference is to RWH
00:10:24 <EvanR> yes just think WHNF
00:12:48 <davidar> Is anyone working on https://ghc.haskell.org/trac/ghc/wiki/GeneralizedMonadComprehensions ?
00:15:27 * hackagebot json-stream 0.3.2.3 - Incremental applicative JSON parser  https://hackage.haskell.org/package/json-stream-0.3.2.3 (ondrap)
00:15:48 <cocreature> davidar: I don't think so. the applicative stuff will however be enabled by ApplicativeDo which should be in ghc 8.0
00:16:53 <davidar> cocreature (IRC): will applicative do also apply to comprehensions?
00:17:07 <cocreature> davidar: not that I know of
00:18:44 <davidar> cocreature (IRC): would it be particularly difficult to support applicative comprehensions  after applicative do is supported?
00:18:59 <cocreature> davidar: to be honest I have no idea :D
00:19:08 <cocreature> although it would seem like it shouldn't be that hard
00:19:24 <cocreature> I suppose comprehensions are just not used very often so there is not that much interest in them
00:20:31 <davidar> cocreature (IRC): for idiomatic Haskell, yeah, but they're useful for DSLs
00:20:51 <cocreature> fair enough
00:22:13 <EvanR> tired of DSLs 
00:22:23 <EvanR> when are we getting support for CABELs
00:22:40 <cocreature> what is a CABEL? :)
00:23:04 <EvanR> a mispelled version of cable
00:23:29 <EvanR> waiting for a joke expansion
00:23:59 <davidar> cocreature (IRC): do you know who I'd be able to talk to about getting it supported?
00:24:25 <cocreature> davidar: the ghc-dev mailing list but I suppose you'll probably have to implement it yourself :)
00:24:37 <cocreature> still the mailing list should be a good start
00:25:39 <davidar> Alright, I'll try that, thanks :)
00:33:39 <joco42> cabal sandbox question: if i say cabal install -only-dependencies, using a sandbox then how can i tell cabal that it should download the sources for the dependencies ?i was looking for the sources in .cabal-sandbox but could not find them, what happens to the sources when cabal installs the dependencies into the sandbox ? huh, long question :)
00:41:15 <nitrix> joco42: You might be interested into cabal fetch.
00:43:29 <nitrix> Wait, I think it's cabal get.
00:48:25 <davidar> EvanR (IRC): Condensed Applicative Bananas Embedded in Lenses?
00:51:01 <ggole> Condensed bananas sounds disgusting.
00:52:51 <frerich> I'm fairly disappointed that a self-proclaimed "Industrial-strength" programming language like Haskell doesn't have anything like https://github.com/auchenberg/volkswagen
00:53:40 <jle`> i thought about implementing it too, but it seems like haskell is too limited for features like that
00:53:55 <jle`> it might be our main barrier to being taken seriously in industry
00:55:50 * hackagebot distributed-process-tests 0.4.3.2 - Tests and test support tools for distributed-process.  https://hackage.haskell.org/package/distributed-process-tests-0.4.3.2 (AlexanderVershilov)
00:57:45 <joco42> nitrix: many thanks for the tip, i have a look
01:00:01 <nitrix> frerich: jle`: Ahahah, this is wrong in so many ways. I love it guys.
01:45:56 * hackagebot rest-happstack 0.3.1 - Rest driver for Happstack.  https://hackage.haskell.org/package/rest-happstack-0.3.1 (ErikHesselink)
02:31:00 * hackagebot MagicHaskeller 0.9.6.4.2 - Automatic inductive functional programmer by systematic search  https://hackage.haskell.org/package/MagicHaskeller-0.9.6.4.2 (SusumuKatayama)
02:32:08 <vincenz> Is there any way to choose implementation of some function depending on the type-class that type implements?
02:33:32 <merijn> vincenz: Depends, are you asking for a *reasonable* way to do this or "any horrifically hacky solutions that requires goat blood will do"?
02:33:36 <vincenz> e.g: I have a typeclass SPord (for strictly partially ordered).  I have some function that uses a priority-queue. I can make a way more effificient priority-queue if I know the type is Ord but I can also solve it for SPord. It seems the only way I can do this is if I create a type-class specific for my input
02:34:38 <vincenz> And then hope for Undecideable/Overlapping with 'instance SPord a => MyFunctionRequires a where getPQ a = ..."
02:35:12 <vincenz> But then I need a typeclass just for my function, I don't see another way to do it because afaict, you can't have require a type be either typeclass A *OR* typeclass B
02:35:34 <vincenz> (as in, I can't say :  myfun :: (Ord a | SPord a) => a -> ...
02:35:45 <merijn> vincenz: This can do what you want, but the internals contains a substantial amount of voodoo: https://github.com/mikeizbicki/ifcxt#ifcxt
02:36:16 <vincenz> merijn: thanks, I'll take a look
02:36:32 <jle`> vincenz: what if something is an instance of both?
02:37:00 <vincenz> jle`: Ideally I'd use the more efficient one, namely Ord
02:37:04 <vincenz> but you're right, that is tricky
02:37:18 <merijn> vincenz: FYI, there's another alternative
02:37:39 <merijn> hmm, on second thought not a great one
02:39:10 <vincenz> I have a prioq implementation for any preorder but it devolves to a list-implementation for anything that's ordered
02:39:16 <vincenz> so not super efficient :D
02:40:22 <lpaste> merijn pasted “Typeclass mess example” at http://lpaste.net/142819
02:40:32 <merijn> vincenz: That's another option
02:45:20 <phaazon> hm
02:45:24 <vincenz> merijn: unfortunately it's not that simple :)
02:45:31 <phaazon> attoparsec is so lovely to use
02:45:38 <vincenz> I'm not just choosing a single function but basically a whole data-type
02:45:57 <phaazon> though, I had to create my own parser to do the same thing as many1, but by failing if the parser fails
02:46:08 <phaazon> something like untilEnd
02:46:28 <vincenz> merijn: actually, nm, I think that was what I originally proposed. Have a typeclass for my function
02:46:39 <vincenz> (the whole function, where some of its internals needs that specialization
02:46:43 <phaazon> I guess I could try with manyTill
02:54:02 <danza> maybe i found a way to track the growth of the Haskell community https://www.google.com/trends/explore#q=hoogle
02:55:50 <LokiSnake> hoogle (maps|translate|etc.) are high on related searches
02:56:04 <danza> :(
02:56:46 <LokiSnake> also, it's crazy how frequently search engines see the search term "google"
02:57:14 <LokiSnake> and it seems hoogle is frequently a typo for google
02:57:16 <danza> because in Chrome the address bar goes through Google itself
02:58:35 <LokiSnake> yeah, and in general, many many search for facebook/twitter/etc, then click the result to go to the site (instead of directly doing the .com)
03:01:02 * hackagebot wavefront 0.1.0.2 - Wavefront OBJ loader  https://hackage.haskell.org/package/wavefront-0.1.0.2 (DimitriSabadie)
03:03:14 <hexagoxel> joco42: the tarballs are cached in ~/.cabal somewhere; the sources are extracted in /tmp (iirc)
03:13:38 <bernalex> I regularly see people asking for how to "efficiently" convert from BigInteger to BigDecimal in Java, and similar questions for similar languages. which got me thinking: is our fromInteger really bad or something? it seems that this is like zomg super difficult in those languages, surely it can't be a simple builtin function in Haskell does it "efficiently"? 
03:20:47 <bakhtiyor> hi everybody!
03:23:45 <quicksilver> bernalex: I have no useful answer to that but it might be interesting to remember that 'fromInteger' is a class method so, actually, its implementation varies from type to type.
03:25:34 <bakhtiyor> what do you thing about elixir over haskell? is it worth to learn
03:33:33 <bakhtiyor> hey haskellers!
03:35:29 <joco42> hexagoxel: thanks - i have a look there
03:35:49 <bernalex> bakhtiyor: wouldn't it be more natural to compare elixir to erlang than haskell?
03:36:53 <bakhtiyor> bernalex: learning haskell or elixir for web development
03:37:23 <bernalex> bakhtiyor: why not both?
03:37:45 <bakhtiyor> lack of time
03:37:57 <ARM9> I'd go with elixir
03:38:14 <bernalex> bakhtiyor: elixir is not pure, nor does it have static verification. it probably doesn't have higher-kinded polymorphism either, but I do not know. I would go with haskell, which is the language I use for web development.
03:38:21 <nesqi> What is (,)? I know that I can use it to make a pair and I guess that it's equivalent to (a,b) but I cant find it on Hoogle and it's not a normal infix operator since I cannot do 1 , 2 , 3
03:38:37 <liste> @src (,)
03:38:37 <lambdabot> Source not found. Take a stress pill and think things over.
03:39:07 <liste> nesqi it's both a type constructor and a data constructor
03:39:23 <quicksilver> nesqi: but you're right, it has funky syntax
03:39:23 <bakhtiyor> bernalex: do you use haskell for web development?
03:39:43 <quicksilver> nesqi: partly because the , has more than one use. It's also used to separate list items.
03:40:29 <nesqi> But is it a built in thing or is there haskell code for it?
03:40:57 <bernalex> nesqi: it's a bit silly hack when used infix, since it depends on the context. but prefix it's just a regular haskell function.
03:41:05 <bernalex> > (,,,) 1 2 3 4
03:41:06 <lambdabot>  (1,2,3,4)
03:41:17 <bernalex> bakhtiyor: that's what I just said.
03:41:47 <nesqi> ah! I was woundering how to make a tripplet
03:41:47 <bernalex> nesqi: here's the unholy source code: https://hackage.haskell.org/package/ghc-prim-0.4.0.0/docs/src/GHC-Tuple.html#%28%2C%29
03:41:49 <Hafydd> > 1 `(,)` 2
03:41:50 <lambdabot>  <hint>:1:4: parse error on input ‘(’
03:41:53 <Hafydd> 2 bad.
03:42:18 <nesqi> WOW! That was unexpected =)
03:42:19 <bernalex> Hafydd: ()s means prefix of infix operator. it would be
03:42:22 <bernalex> > 1 , 2
03:42:24 <lambdabot>  <hint>:1:3: parse error on input ‘,’
03:42:31 <bernalex> Hafydd: but that's not possible because ',' is reused other places like
03:42:33 <bernalex> > [1,2]
03:42:35 <lambdabot>  [1,2]
03:42:37 <quicksilver> nesqi: it's built in syntax
03:42:45 <liste> nesqi also check out TupleSections language extension
03:43:18 <bernalex> quicksilver: (1,2) is, not (,) 1 2, that's just a regular ADT.
03:43:24 <liste> > (,5) 5
03:43:26 <lambdabot>  (5,5)
03:43:34 <quicksilver> bernalex: the comma specifically, is syntax
03:43:57 <quicksilver> even (,) is syntax in the sense that that is not a valid constructor lexeme
03:44:00 <bernalex> quicksilver: oh, yes, that's true.
03:44:08 <bernalex> > data (,) = Foo
03:44:09 <lambdabot>  <hint>:1:1: parse error on input ‘data’
03:44:16 <bernalex> right, lambdabot doesn't handle that
03:44:21 <Hafydd> @let data (,) = Foo
03:44:21 <lambdabot>  Parse failed: Illegal data/newtype declaration
03:44:22 <bernalex> but it should spit out "Illegal binding of built-in syntax".
03:44:24 <quicksilver> but, the syntax aside, it's a perfectly standard data, yes
03:44:56 <bernalex> tuples and TupleSelections are a major headache for the language extension I was working on (that I need to revisit soon)
03:45:24 <Hafydd> TupleSelections, eh?
03:45:38 <nesqi> ok.. thanks. It's a bit special I have concluded =)
03:45:50 <quicksilver> nesqi: it's special, but only syntactically so, is the point
03:46:02 <quicksilver> nesqi: the way it actually works - beyond the syntax - is like any other type
03:46:26 <Hafydd> I prefer to think of (1,2,3) being the "special" syntactic sugar introduced to avoid having to write (,,) 1 2 3.
03:46:48 <Hafydd> But it's true also that (,,) does not obey the same grammar as most other data constructors.
03:47:30 <bernalex> Hafydd: sorry, I meant Tuple*Sections*.
03:50:23 <EvanR> johnw: i realized that the lzw thing is traversing the tree in the wrong order, not putting the finding the stamps first at each layer. so i wrote a more straight forward version. now things are a lot more interesting, but i still dont really get it
03:50:35 <EvanR> http://lpaste.net/142820 http://i.imgur.com/lHzsWIk.png
03:50:57 <EvanR> memory usage seems to decrease more and leak more
03:52:34 <bakhtiyor> bernalex: why did you choose over another languages?
03:53:08 <EvanR> drag starts to go down after 5 seconds, and void seems to continue up
03:53:19 <EvanR> also, doing -hr causes a segfault :)
03:55:18 <bernalex> bakhtiyor: it was the most practical choice.
03:57:00 <bakhtiyor> bernalex: which companies using the lang for web?
03:57:34 <bernalex> bakhtiyor: my company. Facebook. Silk. other companies. lots of companies.
03:57:49 <bakhtiyor> bernalex: didn't find any entry-level haskell developer jobs :(
03:58:04 <EvanR> can anyone else confirm that running that code with -prof -fprof-auto -rtsopts and then RTS -hr causes a segfault?
03:58:10 <EvanR> seems pretty bad
03:58:34 <EvanR> entry level i.e. they want you to be an expert but pay you shit
03:59:05 <bernalex> EvanR: I doubt that's true for Facebook's entry level Haskell jobs.
03:59:36 <EvanR> they want you to be an expert but pay you awesome?
03:59:46 <EvanR> hows that entry level ;)
03:59:51 <bernalex> my company also hired someone that wasn't a Haskell expert, expecting him to be able to learn as he went.
04:00:47 <bernalex> EvanR: the project doesn't require any Haskell expertise AFAIK. you will of course need to be capable at *something* if they're going to hire you, expecting you to be able to learn Haskell as part of the gig.
04:01:04 <EvanR> which project?
04:01:31 <bernalex> EvanR: I don't know if there are any well-known specifics of it. I think it was for some R&D-ish group using Haskell.
04:01:41 <EvanR> ah i remember that
04:01:45 <bernalex> they are also looking for experienced Haskellers to work on the team that is working on Haxl.
04:02:32 <EvanR> this space behavior is making me feel like a noob
04:06:00 <merijn> EvanR: Did you run with -hc?
04:06:22 <Sindriava> Is there such a type A that `empty :: A` would make sense, yet A wouldn't be a Monoid?
04:06:44 <merijn> EvanR: The graph you showed has not info to tie memory to code?
04:06:54 <merijn> Sindriava: Maybe you're thinking of "Default"?
04:07:01 <merijn> Sindriava: Which is a pretty useless class, imo
04:07:04 <Sindriava> merijn: No, why?
04:07:13 <bernalex> Sindriava: sure, why wouldn't there be?
04:07:18 <merijn> Sindriava: "class Default a where def :: a"
04:07:28 <Sindriava> bernalex: Can you give an example?
04:07:49 <Sindriava> merijn: I know what Default is. How is it relevant to my question?
04:08:02 <liste> > (def :: [a])
04:08:04 <lambdabot>  []
04:08:14 <liste> > (def :: M.Map String a)
04:08:16 <lambdabot>  fromList []
04:08:26 <bernalex> Integers with binary operator f = (-) and x = 0?
04:08:37 <merijn> Sindriava: You asked for a type "A" where "empty :: A" makes sense, but it's not a Monoid, isn't that basically "all isntances of Default"
04:08:54 <bernalex> I don't think I understand the question
04:09:00 <Sindriava> merijn: [a] is a monoid though.
04:09:17 <EvanR> merijn: ill try that
04:09:23 <merijn> Sindriava: It's nearly impossible to invent a type that can't be a Monoid *some* way
04:09:44 <Sindriava> merijn: Which was a crucial part of my question.
04:09:47 <bernalex> a monoid is something that has an associative binary operator f and a value x such that f x = id.
04:09:50 <EvanR> i just modified something that makes it run smoother, but slower, which is fine im just trying to get memory to not suck
04:09:59 <bakhtiyor> bernalex: what your company?
04:10:15 <Sindriava> bernalex: I'm asking because I'm trying to figure out whether it makes sense for `empty` to not be a part of Monoid
04:10:17 <merijn> Sindriava: In fact, any type which has an "empty" can trivially be a Monoid if you can compare to check whether a value is equal to empty
04:10:20 <anteater> Is there a function like a -> [Either a b] -> Either a b that gives me the first Right (and some Left otherwise)?
04:10:21 <Sindriava> bernalex: (right now it's mempty)
04:10:56 <merijn> Sindriava: mempty without mappend is basically Default, so yes it makes sense for some value of sense
04:11:04 <merijn> Because I consider default to be dumb
04:11:04 <Sindriava> anteater: What would the first a b?
04:11:08 <bernalex> Sindriava: Monoid should only have empty
04:11:10 <merijn> Also, the name "empty" is already taken
04:11:14 <Sindriava> anteater: *first a be
04:11:14 <merijn> :t empty
04:11:15 <lambdabot> Alternative f => f a
04:11:19 <bernalex> Sindriava: and <> should be in a SemiGroup typeclass.
04:11:39 <bernalex> bakhtiyor: plaimi.
04:11:42 <quicksilver> Sindriava: the best Monoid for Maybe a requires a SemiGroup (or Monoid) for a; but you can *always* have empty without that.
04:11:53 <merijn> EvanR: You seem to append a lot, that's kinda bad usually'
04:11:54 <quicksilver> Sindriava: so in a sense, that's an example of empty without monoid
04:12:04 <Sindriava> merijn: I'm not asking for Haskell specifically, so "name is taken" is irrelevant, and so is default in this case
04:12:05 <merijn> EvanR: Have you tried rewriting to DList?
04:12:07 <EvanR> merijn: its supposed to be lazy
04:12:08 <anteater> Or something like: Left "foo" <?> Right "bar" <?> Right "blob" == Right "Bar
04:12:10 <Sindriava> bernalex: Oh yeah, that's what I had in mind!
04:12:11 <EvanR> merijn: its infinite
04:12:24 <Sindriava> quicksilver: Good point.
04:12:34 <bernalex> Sindriava: a semigroup is a generalisation of Monoid where the x such that f x = id is not mandatory.
04:12:37 <merijn> EvanR: If you append to infinite lists you can just leave the append out >.>
04:12:42 <Sindriava> bernalex: So SemiGroup a => Monoid a?
04:12:45 <EvanR> merijn: http://i.imgur.com/j5R1NxT.png http://i.imgur.com/S6Radhq.png
04:12:51 <bernalex> Sindriava: yes.
04:12:53 <Sindriava> bernalex: Yah
04:12:55 <merijn> EvanR: Or you mean the eventual tail is infinite?
04:13:03 <Sindriava> bernalex: That's what I was thinking about, great ^^ Thanks!
04:13:04 <EvanR> merijn: its not appending to an infinite list, its building an infinite list
04:13:29 <quicksilver> anteater: have you see partitionEithers?
04:13:29 <EvanR> im trying to generate it without huge amount of memory
04:13:33 <merijn> EvanR: I don't see why that wouldn't work with DList?
04:13:51 <merijn> EvanR: Also, might wanna turn on colour for the graphs you generate
04:13:59 <quicksilver> anteater: that gives you the pieces you need - take the first from the left list and if it's empty the first from the right list?
04:14:00 <Sindriava> Left "foo" <|> Right "bar"
04:14:06 <anteater> quicksilver: let me have a leek.
04:14:06 <Sindriava> > 	Left "foo" <|> Right "bar"
04:14:07 <EvanR> merijn: with DList you eventually have to provide something to begin the ++ process
04:14:08 <lambdabot>  Right "bar"
04:14:21 <anteater> Sindriava: which <|> is that?
04:14:24 <Sindriava> > Left "foo" <|> Left "bar"
04:14:25 <lambdabot>  Left "bar"
04:14:31 <Sindriava> :t (<|>)
04:14:32 <lambdabot> Alternative f => f a -> f a -> f a
04:14:34 <EvanR> and theres no such thing
04:14:39 <merijn> EvanR: And that's a problem because?
04:14:47 <merijn> EvanR: That thing can easily be an infinite list...
04:15:06 <Sindriava> > foldr (<|>) [Left 0, Left 1, Right 2, Left 3]
04:15:08 <lambdabot>      No instance for (Typeable t0)
04:15:08 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
04:15:08 <lambdabot>        arising from a use of ‘show_M778904764751611491423691’
04:15:10 <EvanR> if i had that infinite list, i wouldnt need to do anything else
04:15:13 <Sindriava> wha
04:15:23 <Sindriava> > foldr1 (<|>) [Left 0, Left 1, Right 2, Left 3]
04:15:24 <lambdabot>      No instance for (Show a0)
04:15:25 <lambdabot>        arising from a use of ‘show_M209718943511540848323701’
04:15:25 <lambdabot>      The type variable ‘a0’ is ambiguous
04:15:28 <EvanR> merijn: this is a breadth first traversal of an infinite tree
04:15:37 <anteater> Sindriava: hmm, I don't have that instance in Control.Applicative.  Where does it come from?
04:15:41 <EvanR> trying to print out every node
04:15:49 <anteater> No instance for (Alternative (Either [Char]))
04:16:29 <EvanR> merijn: i think before i figure out color i need to figure out how to read the RHS of this chart... the constructors are cut off
04:16:58 <anteater> > [empty, Left "foo" <|> Right "bar"]
04:17:00 <lambdabot>  [Left "",Right "bar"]
04:17:11 <anteater> > [empty, Left "foo" <|> Right "bar" <|> Right "fnord"]
04:17:13 <lambdabot>  [Left "",Right "bar"]
04:17:25 <Sindriava> anteater: https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Applicative.html
04:17:30 <Sindriava> anteater: Should be there
04:17:32 <anteater> > [empty, Left "foo" <|> Left "abc" <|> Right "bar" <|> Right "fnord"]
04:17:33 <lambdabot>  [Left "",Right "bar"]
04:18:53 <Sindriava> Wait, that's applicative
04:19:14 <Sindriava> anteater: Also, you can PM lambdabot to play with him ^^
04:19:47 <anteater> Oh, I think the instance lives in Control.Monad.Except
04:19:51 <anteater> Sindriava: oh, true.
04:21:46 <Sindriava> anteater: https://ghc.haskell.org/trac/ghc/ticket/4095
04:22:28 <anteater> Sindriava: Oh, I want an Alternative, not Appplicative.
04:22:44 <Sindriava> God dammit I'm dyslexic or something >D
04:23:00 <Sindriava> Anyways, not sure why it's not defined O.o
04:23:08 <Sindriava> it should be somewhere, h,,
04:23:24 <Sindriava> empty :: Either String a
04:23:30 <Sindriava> > empty :: Either String a
04:23:31 <lambdabot>  Left ""
04:24:35 <EvanR> should i take this segfault to the ghc channel or file a bug report?
04:25:42 <EvanR> uhg its already today
04:27:05 <merijn> EvanR: I'm trying to see if I can DListify it, but I'm too lazy to figure out how to profile it locally, so you'll have to check if it improves anything yourself when I'm done
04:27:34 <EvanR> i seriously dont understand how DList is relevant
04:28:14 <merijn> EvanR: Infinitely appending using ++ is going to result in using more and more memory as you consume more of your list
04:28:27 <EvanR> eh?
04:28:36 <merijn> EvanR: Every time you recurse into integrate or levels you're going introduce an extra layer of ++ thunks
04:29:11 <merijn> EvanR: An infinitely recursion of ++ is always going to consume more and more memory as you traverse deeper
04:29:15 <EvanR> im consuming the layers, and hopefully not introducing more too fast (of course, i am)
04:29:42 <EvanR> > concat (repeat [1])
04:29:43 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:30:04 <merijn> concat on repeat is fine
04:30:05 <EvanR> so if i forM print that, its going to expand memory?
04:30:23 <merijn> Because repeat produces a circularly linked list
04:30:36 <merijn> So you never introduce any actual ++ when using concat
04:30:58 <EvanR> @src (++)
04:30:58 <lambdabot> []     ++ ys = ys
04:30:58 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
04:30:58 <lambdabot> -- OR
04:30:58 <lambdabot> xs ++ ys = foldr (:) ys xs
04:31:07 <EvanR> ++ is foldr (:)
04:31:10 <EvanR> whats the problem
04:31:45 <merijn> EvanR: That's not what ++ looks like in GHC
04:31:57 <EvanR> ++ is broken in ghc?
04:31:58 <merijn> EvanR: ++ uses either the first OR builder fusion IF it can fuse
04:32:06 <merijn> https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Base.html#%2B%2B
04:32:20 <merijn> And foldr doesn't help you
04:32:29 <merijn> Because repeated ++ will still introduce repeated foldr
04:32:30 <EvanR> fine the first one is fine
04:32:45 <EvanR> thats not a problem as long as its lazy
04:32:52 <merijn> Sure it is
04:32:54 <EvanR> and `x' is not ridiculous
04:32:57 <merijn> It introduces non-zero overhead
04:33:00 <EvanR> which im my case it probably is
04:33:17 <merijn> Well, you just said it's infinite so you keep linearly increasing the amount of foldrs
04:33:21 <EvanR> consuming [0..] does not continuouslly increase over head forever
04:33:31 <EvanR> you are consuming foldrs
04:33:43 <EvanR> you generate 1 foldr per foldr
04:33:45 <merijn> Maybe I'm wrong, but I'm gonna try anyway :p
04:33:47 <ravi__> hi all
04:33:54 <anteater> fmap msum . sequence :: [a -> Either String b] -> a -> Either String
04:33:57 <anteater> Does what I actually wanted.
04:34:31 <liste> hi ravi__
04:34:49 <ravi__> http://askubuntu.com/questions/684503/haskell-7-8-4-error-while-building-for-ppc64le
04:34:58 <ravi__> can any please look into it
04:35:04 <EvanR> > foldr (+1) 0
04:35:06 <lambdabot>      No instance for (Typeable t0)
04:35:06 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
04:35:06 <lambdabot>        arising from a use of ‘show_M318856617777383796924034’
04:35:43 <EvanR> > scanl (+1) 0 [0..]
04:35:45 <lambdabot>      Occurs check: cannot construct the infinite type: b ~ Integer -> b
04:35:45 <lambdabot>      Expected type: b -> Integer -> b
04:35:45 <lambdabot>        Actual type: b -> b
04:35:54 <EvanR> low on sleep
04:36:00 <ravi__> can any please tell how to build ghc 7.8.4 having issue http://askubuntu.com/questions/684503/haskell-7-8-4-error-while-building-for-ppc64le
04:36:12 <ravi__> can any please tell how to build ghc 7.8.4 having issue http://askubuntu.com/questions/684503/haskell-7-8-4-error-while-building-for-ppc64le
04:36:17 <ravi__> is anyone online
04:38:10 <quicksilver> lots of people online, ravi
04:38:19 <quicksilver> sometimes takes moer than a minute to answer, no need to post it 3 times
04:38:46 <EvanR> who builds ghc!
04:39:04 <EvanR> ghc binaries grow on trees i thought
04:39:07 <anteater> Ravi, have you tried specifying a build type?
04:39:15 <shourya> Any advice on where I can get some Haskell tutorials?
04:39:36 <anteater> shourya: Have you tried Bing?
04:39:37 <quicksilver> I have no recent memory of anyone discussing ghc on ppc :(
04:40:16 <shourya> anteater: Nope.
04:40:34 <anteater> shourya: Google also works.
04:40:54 <anteater> shourya: if you the tutorials you find don't work for you, tell us.
04:41:13 <shourya> Could you give me a link to the basics of Haskell?
04:41:25 <shourya> I'm new to the language.
04:41:57 <shourya> anteater: Do you think any search engine would? XD
04:42:24 <anteater> shourya: really, just going to Google.com or bing.com and looking for "Haskell basics" or "haskell tutorial" will get you tons of material.  Learning how to use a search engine will be key in learning any programming language.
04:42:38 <magneticduck> ugh I'm confused about how the mtl and transformer packages relate
04:42:43 <magneticduck> they seem to export many of the same symbols
04:42:50 <anteater> (Because there's so much additional stuff that you will want to be looking for on your own.  Next step up is going directly to stackoverflow.com.)
04:43:01 <shourya> Great. Thanks a lot :thumbsup:
04:43:09 <merijn> magneticduck: mtl provides convenience typeclasses around transformers
04:43:28 <merijn> magneticduck: And reexports everything from transformers for us lazy people
04:43:38 <anteater> shourya: https://www.google.com.au/search?q=haskell+basics
04:43:47 <magneticduck> merijn: mtl re-exports transformers?
04:43:50 <ChristianS> uh, normally irc channels have a list of tutorials to recommend to newcomers, is that not the case here?
04:43:52 <magneticduck> uh, other way around
04:43:54 <merijn> magneticduck: So all mtl does is provide MonadState, MonadReader, etc. classes from us
04:43:54 <magneticduck> lol
04:43:57 <anteater> shourya: and https://www.google.com.au/search?q=haskell+tutorial
04:44:06 <magneticduck> okay good
04:44:16 <merijn> magneticduck: mtl re-exports transformers, yes
04:44:18 <magneticduck> so, I can use just mtl in my code?
04:44:18 <anteater> ChristianS: The Haskell wiki has a good list of tutorials.
04:44:20 <magneticduck> good
04:44:24 <merijn> magneticduck: Yes
04:44:34 <anteater> ChristianS: the Haskell wiki's list ranks high in a google search for "Haskell tutorial".
04:44:41 <merijn> magneticduck: mtl is it's own library since it uses a bunch of GHC specific extensions making it unportable
04:44:48 <anteater> (Just trying to teach how to fish, instead of giving a meal.)
04:44:58 <EvanR> merijn: i think the difference between your thinking of dlist use-case and this is that im appending stamps one at a time as i traverse the tree very carefully. where as in a html builder you ++ a lot of ++ trees from the left and right
04:45:15 <anteater> ChristianS, shourya: Some people really like "Learn you a Haskell".
04:45:16 <EvanR> also i dont see how dlist can build an infinite result
04:45:35 <merijn> EvanR: Why wouldn't it be able to?
04:45:47 <ChristianS> anteater: yeah, i feel that's more like it
04:45:56 <merijn> EvanR: My biggest problem is grokking what integrate is actually doing >.>
04:46:00 <EvanR> you have an infinite chain of ([x] ++) . ([y] ++) . right
04:46:14 <EvanR> no place to put an argument
04:46:27 <anteater> ChristianS: but that's also one of the first few results that pops up in a web search.
04:46:48 <EvanR> for an ultimately finite result, its more efficient for inserting stuff in the middle
04:46:53 <merijn> EvanR: You'd have an infinite chain of "(x:) . (y:)" which is perfectly fine as soon as you provide an argument, even if that argument is an infinite recursion
04:46:55 <EvanR> but you have to eventually decide to build it
04:47:06 <EvanR> merijn: ... the chain is infinite
04:47:11 <merijn> EvanR: So?
04:47:14 <merijn> > fix (1:)
04:47:16 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:47:18 <Copperis> ravi__, https://www.gnu.org/software/autoconf/manual/autoconf-2.65/html_node/System-Type.html#System-Type
04:47:22 <EvanR> so you cant provide an argument
04:47:31 <merijn> EvanR: Sure you can, see fix
04:47:50 * EvanR facepalm
04:48:21 <EvanR> im using fix to build the tree itself, now im trying to walk it. i cant use fix to walk it because walking it doesnt involve "itself" at any point but the beginning
04:48:46 <EvanR> the final result isnt the fixed point of anything
04:49:04 <hackrilege> im trying to write a datatype like; data A = B.C, is this allowed?
04:50:10 <liste> @let data A = B.C
04:50:11 <lambdabot>  Parse failed: Illegal data/newtype declaration
04:50:14 <liste> nope
04:50:16 <EvanR> merijn: integrate is taking a list of "all layers"s, and merging the layers at each layer into one "all layers"
04:50:19 <ravi__> @Copperis build=ppc64le ?
04:50:19 <lambdabot> Unknown command, try @list
04:50:19 <Copperis> hackrilege, what is the "." supposed to stand for?
04:50:39 <EvanR> an interleaving concat
04:53:13 <Copperis> ravi__, something like "./configure --build=ppc64le" though I'm not sure that is the correct build value, check config.sub file. I don't know myself
04:53:44 <Gurkenglas> If I have a function that I want in mtl/transformers, how should I go about it? Pull requests? In what order?
04:54:15 <merijn> Gurkenglas: Suugestion/proposal to libraries@
04:54:46 <pavonia> Gurkenglas: What function do you want to be added?
04:55:05 <Gurkenglas> merijn, how? Is there a tutorial? Do you mean making one of those wiki articles with proposal in the title?
04:55:32 <quicksilver> Gurkenglas: I would start with just an email and see if peopl eagree/ have comments etc.
04:55:34 <srhb> Gurkenglas: A mail to the list with your arguments and the function will probably suffice. :)
04:55:36 <Gurkenglas> pavonia, modifyT and getsT as inverses of execStateT and evalStateT, like modify and gets to execState and evalState
04:55:37 <merijn> Gurkenglas: That helps, but the starting point would be to just email a quick proposal and see if there's any obvious objections/whatever
04:56:01 <Gurkenglas> What list?
04:56:02 <merijn> Gurkenglas: What does "inverse of execStateT" mean?
04:56:08 <merijn> Gurkenglas: libraries@haskell.org
04:56:22 <quicksilver> "modify" already works perfectly well with a StateT type
04:56:23 <Gurkenglas> merijn, it means that composing it with execStateT (on either side) produces id
04:56:27 <quicksilver> as well as a State type
04:56:56 <Gurkenglas> :t execStateT . modify -- quicksilver
04:56:57 <lambdabot> Monad m => (s -> s) -> s -> m s
04:57:21 <quicksilver> :t execState . modify
04:57:22 <lambdabot> (s -> s) -> s -> s
04:57:41 <merijn> Gurkenglas: I'm confused? What does this accomplish?
04:57:42 <quicksilver> I'm not sure how it can do any more
04:57:58 <quicksilver> in general, with other transformers in the 'm'
04:58:05 <quicksilver> how can modifyT possibly unroll them?
04:58:31 <merijn> Sounds like it's either 1) below the Fairbairn threshold or 2) not sensible
04:59:11 <merijn> EvanR: I'm not making it substantially faster, I think. At least not with the time I put in now and I should probably do some work instead >.>
05:01:05 <Gurkenglas> :t \f -> StateT $ \s -> liftM ((),) (f s) -- modifyT. quicksilver, merijn
05:01:07 <lambdabot> Monad m => (s -> m s) -> StateT s m ()
05:01:20 * hackagebot yesod-auth-ldap-native 0.1.0.1 - Yesod LDAP authentication plugin  https://hackage.haskell.org/package/yesod-auth-ldap-native-0.1.0.1 (mkazulak)
05:01:46 <Gurkenglas> :t \f -> StateT $ \s -> liftM (,s) (f s) -- execStateT
05:01:47 <lambdabot> Monad m => (s -> m a) -> StateT s m a
05:01:56 <Gurkenglas> *getsT, of course
05:06:15 <Gurkenglas> (Hmm, modifyT and getsT are only right identities to execStateT and evalStateT, since the latter two discard information.)
05:07:00 <Gurkenglas> (same thing without the Ts too)
05:09:05 <Gurkenglas> (Although execStateT ceases to discard if its argument is set to "StateT s m ()", as the composition dictates... then we also have modifyT as a left identity)
05:09:26 <quicksilver> :t execStateT . (\f -> StateT $ \s -> liftM (,s) (f s))
05:09:27 <lambdabot> Monad m => (s -> m a) -> s -> m s
05:10:23 <Gurkenglas> That's the wrong one. You want to compose that lambda expression to the right of evalStateT.
05:10:37 <quicksilver> :t evalStateT . (\f -> StateT $ \s -> liftM (,s) (f s))
05:10:38 <lambdabot> Monad m => (s -> m a) -> s -> m a
05:10:44 <quicksilver> gotcha.
05:10:49 <quicksilver> why is this useful?
05:12:13 <Gurkenglas> Even if the two did not have a use, they ought to be in there simply to complete the rectangle of modify, execState and execStateT/gets, evalState and evalStateT. I do have sometimes wished that I could write modifyT. Example:
05:12:34 <merijn> Eh, what's stopping you from writing modifyT? You just did...
05:12:56 <Gurkenglas> merijn, why do we have evalState in the library if it already has runState?
05:13:11 <merijn> because eval and exec are actually used a lot
05:13:21 <merijn> You just admitted you didn't even know what these are useful for
05:13:28 <quicksilver> Gurkenglas: (\f -> StateT $ \s -> liftM (,s) (f s)) is lift . gets
05:13:35 <quicksilver> specialised to StateT
05:13:45 <quicksilver> sorry
05:13:48 <quicksilver> not quite
05:13:52 <quicksilver> \f -> lift . gets f
05:13:56 <quicksilver> (lift.).gets
05:14:00 <Gurkenglas> No, I said that they should be in there even if they did not have to use, and that I am about to post an example
05:14:44 <quicksilver> actually I don't think what I said is quite right.
05:15:17 <merijn> Gurkenglas: Right, I'm disagreeing on the "they should be there even if they don't have a use"
05:15:50 <quicksilver> try again
05:16:00 <quicksilver> it is \f -> join (gets f)
05:16:04 <quicksilver> specialised to StateT
05:16:12 <quicksilver> :t join.gets
05:16:13 <lambdabot> MonadState s m => (s -> m a) -> m a
05:16:29 <Gurkenglas> I would still want edward to write his libraries even if he didn't write them to use them in something else he needs, because they generally are mathematically elegant enough that they ought to be around in case someone derives their use at some point
05:16:34 * hackagebot MagicHaskeller 0.9.6.4.3 - Automatic inductive functional programmer by systematic search  https://hackage.haskell.org/package/MagicHaskeller-0.9.6.4.3 (SusumuKatayama)
05:16:49 <Gurkenglas> @let modifyT = (\f -> StateT $ \s -> liftM (,s) (f s))
05:16:50 <lambdabot>  Defined.
05:17:19 <quicksilver> still wrong :) sorry
05:17:20 <Gurkenglas> :t (.) (either id absurd) . evalStateT . forever . modifyT
05:17:21 <lambdabot> (a -> Either c a1) -> a -> c
05:17:22 <quicksilver> me, that is.
05:17:51 <quicksilver> I would say it's definitely worth a mailing list post, Gurkenglas 
05:18:00 <Gurkenglas> (Wait what why is that a1)
05:21:11 <Gurkenglas> Argh I copypasted the wrong lambda expression for the @modifyT let ._. *fixes in query*
05:21:56 <Gurkenglas> :t (.) (either id absurd) . evalStateT . forever . modifyT
05:21:57 <lambdabot> (a -> Either c a) -> a -> c
05:22:02 <quicksilver> ok, the modifyT you pasted here is \f -> lift =<< gets f
05:22:08 <Gurkenglas> > ((.) (either id absurd) . evalStateT . forever . modifyT $ \(i, j) -> if j == 0 then Left i else Right (i+1, j-1)) (5, 7)
05:22:10 <lambdabot>  12
05:22:47 <quicksilver> i.e. (lift =<<) . gets
05:22:56 <quicksilver> :t (lift =<<) . gets
05:22:57 <lambdabot> (Monad m, MonadTrans t, MonadState s (t m)) => (s -> m b) -> t m b
05:23:36 <Gurkenglas> > ((.) (either id absurd) . evalStateT . forever . (\f -> lift =<< gets f) $ \(i, j) -> if j == 0 then Left i else Right (i+1, j-1)) (5, 7) -- Empirically not. Let me try to find the difference...
05:23:40 <lambdabot>  mueval-core: Time limit exceeded
05:23:55 <quicksilver> interesting
05:25:30 <quicksilver> :t modifyT
05:25:31 <lambdabot> Monad m => (s -> m s) -> StateT s m ()
05:26:08 <quicksilver> that's not the modifyT I had
05:26:13 <quicksilver> or at least it isn't the same type
05:26:25 <Gurkenglas> :t [(lift =<<) . gets, modifyT]
05:26:26 <lambdabot> Monad m => [(() -> m ()) -> StateT () m ()]
05:26:38 <quicksilver> mine was Monad m => (s -> m a) -> StateT s m a
05:26:53 <quicksilver> which one did you intend? did I copy/paste the wrong one?
05:26:54 <Gurkenglas> Right, modify is supposed to take a function that makes a state
05:27:08 <Gurkenglas> gets is supposed to take a function that makes a return value
05:27:52 <Gurkenglas> As said above, my first @let binding of modifyT had me copypaste the wrong lambda expression. Try to simplify "modifyT = \f -> StateT $ \s -> liftM ((),) (f s)"
05:28:15 <dxtr_> hi
05:28:18 <quicksilver> yeah I got mixed up, apologies
05:28:56 <dxtr_> so Num does not imply Ord .. is there any example of an actual type that fits Num but not Ord in Haskell? (or in General?)
05:29:03 <quicksilver> and now I do see what you're doing with modifyT, yes
05:29:10 <Sindriava> holy crap, LaTeX can be used to render Diagrams? :O
05:29:11 <ravi__>  @anteater @copper i am trying for ./configure --build=powerpc64le. build takes more than hour to compile i will let you know
05:29:12 <maukeauke> dxtr_: Complex Double
05:29:34 <dxtr_> ah, i see .. thx
05:29:42 <anteater> ravi__: I'll be sleeping. ;)
05:30:47 <Gurkenglas> ( http://ircbrowse.net/browse/haskell?q=modifyT huh, I thought I brought that up a few times more)
05:31:14 <quicksilver> Gurkenglas: your modifyT is (join (gets f) >>= put)
05:32:17 <Gurkenglas> :t \f -> join (gets f) >>= put -- nope
05:32:18 <lambdabot> MonadState s m => (s -> m s) -> m ()
05:32:42 <quicksilver> :t modifyT
05:32:43 <lambdabot> Monad m => (s -> m s) -> StateT s m ()
05:32:50 <quicksilver> why nope? looks right to em
05:32:59 <quicksilver> oh same m
05:33:01 <quicksilver> bleh
05:33:03 <quicksilver> missing lift
05:33:40 <quicksilver> :t :t \f -> do act <- gets f; lift act >>= put
05:33:41 <lambdabot> parse error on input ‘:’
05:33:45 <quicksilver> :t \f -> do act <- gets f; lift act >>= put
05:33:47 <lambdabot> (Monad m, MonadTrans t, MonadState s (t m)) => (s -> m s) -> t m ()
05:34:25 <quicksilver> Gurkenglas: anyway the point is, yes I now understand what you want with this, which I did not understand at all from your first desription of them as inverses to exec/eval, and yes I think you should send an email to libraries@
05:35:16 <exio4> Gurkenglas: isn't that a `concrete` catamorphism 
05:35:44 <Gurkenglas> Individually, I know each of those words.
05:36:35 <quicksilver> and there is a reall non-enlightening point free version too
05:36:42 <quicksilver> :t (((>>= put) . lift) =<<) .  gets
05:36:44 <lambdabot> (Monad m, MonadTrans t, MonadState s (t m)) => (s -> m s) -> t m ()
05:38:12 <quicksilver> Gurkenglas: what I normally do is simply not write things of type (s -> m s)
05:38:39 <quicksilver> Gurkenglas: (preferring to write either StateT s m () or MonadState s m => m ())
05:39:22 <hackrilege> Copperis: composition of kind (*->*) datatypes
05:39:36 <quicksilver> Gurkenglas: but it is kind of a bad situation for me that there are so many possible ways to write functions with the same semantics, and a mess of run/eval/exec/lift required to cast things to the right type to be plugged together
05:39:45 <Gurkenglas> Thing is, stuff like (s -> m s) is what arises naturally. "s -> Either a s" is already of that form. Look at how many libraries do it that way. And I don't blame them
05:39:52 <quicksilver> Gurkenglas: agree.
05:40:27 <Gurkenglas> I think we should generally use (s -> m s) for our type signatures and stuff like modifyT to use nice abstractions
05:40:58 <hackrilege> if you dont require the full monadic instance is it necessarily good practice. basically, should the most general superclass be instantiated if only its subclass is required?
05:40:59 <Nuxular> I'm following https://wiki.haskell.org/SDL/Windows and failing to get it to work
05:41:07 <Gurkenglas> :t auf (iso modifyT execStateT) traverse -- This would have come in handy yesterday iirc when someone asked us to inhabit this type.
05:41:08 <lambdabot> (Monad m, Traversable t) => (a -> s -> m s) -> t a -> s -> m s
05:41:32 <quicksilver> Gurkenglas: I would certainly like to have some kind of certainty about what I should generally use for types :)
05:41:38 * hackagebot yesod-auth-ldap-native 0.1.0.2 - Yesod LDAP authentication plugin  https://hackage.haskell.org/package/yesod-auth-ldap-native-0.1.0.2 (mkazulak)
05:41:41 <quicksilver> Gurkenglas: I am not consistent and I spend too long doing plumbing
05:41:44 <quicksilver> just call me haskell-mario
05:42:03 <hackrilege> does anyone know if i can write, type A = B.C where . is composition of kind * -> * datatypes?
05:42:06 <Nuxular> Am I supposed to be copying the includes / libs into the same folder such that the result is only one include / lib folder each of which contains everything?
05:42:14 <Gurkenglas> quicksilver, show me some code with a lot of plumbing, I like refactoring that away.
05:42:21 <quicksilver> hackrilege: well...
05:42:27 <fizruk> hackrilege: someday we might get superclass instances for free, but currently you should implement them, yes (although it should be quite simple)
05:42:33 <quicksilver> hackrilege: you have to eta expand it
05:42:42 <quicksilver> hackrilege: type A x = B (C x)
05:42:43 <fizruk> hackrilege: like (<*>) = ap
05:42:46 <merijn> hackrilege: Are you perhaps looking for Data.Functor.Compose?
05:42:55 <hackrilege> perhaps, i hadnt seen that
05:43:00 <quicksilver> hackrilege: is fine, although normally we want a newtype - which takes you to Data.Functor.Compose
05:43:13 <merijn> "newtype Compose f g a = Compose { runCompose :: f (g a) }"
05:43:23 <hackrilege> i dont want newtype as im trying to eliminate syntax in huge nested types
05:43:41 <quicksilver> then the eta-expanded type decl shoulud work for you
05:43:57 <hackrilege> no, thats the syntax i am specifically trying to eliminate
05:43:59 <merijn> hackrilege: Then quicksilver's type synonym is the way to go, but you can't do partial applications then nor provide instances
05:44:27 <merijn> hackrilege: Anything else is ruled out, because that'd be equivalent to type-level lambda's, which Haskell doesn't/can't have
05:44:35 <Nuxular> has anybody here managed to get an SDL package to work on windows?
05:44:36 <hackrilege> and also then i would want to know if i can parametrise "type". i guess im trying to write point free
05:44:37 <fizruk> hackrilege: you might also try something like this: type (f :.: g) a = f (g a)
05:44:42 <quicksilver> Gurkenglas: don't have a concrete enough example to hand. In the general case there is a mix of State s1, State s2, Reader s1, Reader s2, where there is some relationship between s1 and s2 (maybe one contains the other)
05:44:56 <Gurkenglas> quicksilver: Have you looked at zoom from lens?
05:45:01 <quicksilver> Gurkenglas: yes.
05:45:08 <hackrilege> oh, type level lambdas are a nono? does that rule out what im tring to do?
05:45:29 <quicksilver> Gurkenglas: that particular kool-aid still tastes slight off. Perhaps I need to drink more.
05:45:36 <merijn> hackrilege: You can either 1) use fully applied synonyms or 2) newtypes
05:45:47 <hackrilege> thanks
05:45:56 <merijn> hackrilege: Type level lambda's result in Turing complete type checking, i.e. no guarantee that type checking terminates due to halting problem
05:46:06 <merijn> hackrilege: Which is...undesirable ;)
05:46:07 <fizruk> >>> type (f :.: g) a = f (g a)
05:46:07 <fizruk> >>> :k Maybe :.: Maybe
05:46:07 <quicksilver> Gurkenglas: but it's also the mixture of s -> m s and StateT s and State S and MonadState (etc), as I was saying before.
05:46:08 <fizruk> Maybe :.: Maybe :: * -> *
05:46:45 <hackrilege> :t (:.:)
05:46:46 <lambdabot> Not in scope: data constructor ‘:.:’
05:47:01 <merijn> hackrilege: It's not a bad idea in itself, dependently typed languages can give you type level lambdas, but then you switch to a total language (i.e. throwing out Turing completeness for the sake of guaranteed termination)
05:47:23 <hackrilege> hmm, interesting
05:47:32 <hackrilege> so haskell is not turing compleet?
05:47:33 <fizruk> hackrilege: I have just defined it. it won't work for multiple Maybes though
05:47:43 <exio4> well, Haskell's type system is currently turing complete
05:47:50 <exio4> GHC Haskell's*
05:48:27 <hackrilege> :t undefined :: Maybe :.: Maybe
05:48:27 <exio4> and there's UndecidableInstances...
05:48:28 <lambdabot>     Not in scope: type constructor or class ‘:.:’
05:48:28 <lambdabot>     Perhaps you meant ‘:~:’ (imported from Data.Typeable)
05:48:43 <Gurkenglas> "By default, use unwrapped newtypes. If you can use a neat newtype feature, use it internally and unwrap at the outer end of the definition, leaving the type signature unwrapped. If this ends you up wrapping every call to the function and unwrapping at the outer end of its definition, remove the wrapping and change the type signature."
05:48:51 <merijn> hackrilege: Haskell *is* Turing complete
05:49:01 <merijn> hackrilege: Hence why we don't want to allow type level lambdas
05:49:06 <Gurkenglas> In particular, this means "Leave globally exported library functions unwrapped"
05:49:22 <quicksilver> Gurkenglas: where is that advice from?
05:49:33 <hackrilege> oh sorry i got it backwards.
05:49:42 <merijn> hackrilege: I was saying that there are *other* language which sacrifice Turing completeness to guarantee termination (i.e. no halting problem), this allows these languages to allow type-level lambdas while still knowing typechecking terminates :)
05:49:58 <Gurkenglas> quicksilver, my fingers, just now :P.
05:50:01 <merijn> hackrilege: Examples would be Coq, Agda, Idris, and Epigram (if that's still alive)
05:50:14 <quicksilver> Gurkenglas: oh, sorry, quotation marks made it look like a quotation :P
05:50:28 <hackrilege> wow, dead languages galore
05:50:33 <fizruk> well, Idris is turing complete, totality is optional
05:50:33 <Sindriava> What's the stack equivalent of cabal-install's -f ?
05:50:46 <Sindriava> e.g. how do I do `cabal install -fps diagrams-builder` with stack?
05:50:50 <quicksilver> Gurkenglas: so your advice is always avoid the cool newtype until you've proved you need it.
05:50:58 <Gurkenglas> Indeed. I wanted to make it look like it could be written into an advice article. I guess it means you may quote me on that until I say otherwise :D
05:51:01 <exio4> and it achieves `totality` at the type-level by only allow total functions there :P 
05:51:12 <fizruk> Sindriava: flags field in stack.yaml
05:51:16 <merijn> exio4: Close enough
05:51:19 <quicksilver> Gurkenglas: I'll try working that way and let you know where it takes me 
05:51:45 <hackrilege> is it very hard to write ghc?
05:51:46 <Sindriava> fizruk: Nothing else? I'm not doing it inside a project, so I just use the global stack.yaml?
05:51:54 <Gurkenglas> quicksilver: Always use the cool newtype, internally. It's almost like orphan instances, you're allowed to put the cool newtype in global exports if you export the newtype.
05:51:55 <Sindriava> fizruk: Won't that apply it to all packages?
05:52:08 <fizruk> Sindriava: https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md#flags
05:52:09 <hexagoxel> Gurkenglas: you could upcast yourself to "anonymous haskeller" :)
05:52:27 <Sindriava> fizruk: I see, thanks ^^
05:52:42 <Gurkenglas> http://www.dict.cc/englisch-deutsch/upcast.html ???
05:52:47 <hackrilege> what would be the biggest task, the garbage collection perhaps?
05:52:51 <merijn> hackrilege: Depends what you mean by "writing GHC" :)
05:53:09 <quicksilver> Gurkenglas: so write foo :: s -> m s; foo s = evalStateT s $ do .... ?
05:53:09 <hackrilege> a haskell compiler at least as good as ghc i mean
05:53:14 <merijn> hackrilege: Writing a simple compiler for a functional language is pretty simple. Making it a fast optimising compiler is hard :)
05:53:33 <fizruk> hackrilege: typechecker perhaps (just guessing)
05:53:45 <Gurkenglas> quicksilver: remove both s tokens! That's the cool part about StateT >:(
05:53:46 <srhb> HM type checking isn't that hard to implement actually. :)
05:53:49 <merijn> hackrilege: That would be a challenging task. GHC has nearly two decades of optimisation/hacking/etc. into it :)
05:53:52 <hackrilege> thats the point, how hard is it to write that stuff? i mean its all in the ghc source, so it should be easy to write a checklist
05:53:55 <Gurkenglas> (Doesn't even typecheck like you wrote it.)
05:54:06 <hexagoxel> Gurkenglas: i meant the oop "upcast"ing of A* to B* if A is subclass of B
05:54:11 <merijn> fizruk: With all GHC extensions, maybe. Just plain Haskell2010 would be easy to typecheck
05:54:15 <quicksilver> merijn: writing a type-checker for haskell is non-trivial (constraint propagation). Writing a typechecker for haskell+GHC extensions is genuinely hard.
05:54:36 <fizruk> merijn: I was talking all extensions, yes
05:54:42 <merijn> quicksilver: Constraint propagation is just fairly straightforward unification, no?
05:54:42 <hackrilege> as things like template haskell are written in haskell, dont we get a lot of the functionality for free as soon as we can compile these libraries?
05:54:49 <quicksilver> "trivial" is subjective relative to how many type-checkers you've written before I guess
05:54:57 <quicksilver> merijn: not entirely because you have to delete satisfied constraints
05:55:00 <merijn> quicksilver: Seems like that should be easy enough once you get the trick :)
05:55:08 <merijn> quicksilver: Sure
05:55:43 <merijn> quicksilver: Trivial might be an exaggeration, but once you've implemented unification once it should be fairly easy to implement Haskell2010 typechecking
05:55:48 <quicksilver> hackrilege: template haskell is written in haskell but only as part of GHC. So, to get it for free you have to write a compiler good enough to compile GHC :)
05:56:16 <hackrilege> re: "Making it a fast optimising compiler is hard", is that one which makes code run faster even when it is written with the same syntax?
05:56:25 <quicksilver> unfortunately GHC isn't written in pure haskell, it bootstraps off its own implementation techniques, I think.
05:56:38 <hackrilege> i think i heard something like that
05:56:45 <hackrilege> thats why you just grab binaries of it
05:56:46 <quicksilver> Gurkenglas: yes, sloppy, you're right
05:57:18 <merijn> hackrilege: An optimising compiler is a compiler that doesn't naively translate the source to binary the "stupid" way, but implements all sorts of tricks to generate faster code
05:57:29 <JagaJaga> How to print type for instance of datatype? For example <*> for Maybe?
05:57:38 <hackrilege> merijn; are these documented, or all voodoo?
05:57:46 <merijn> hackrilege: Basically the -O, -O2, -O3 etc. flags on compilers
05:57:46 <quicksilver> Gurkenglas: and you prefer (s -> (a,s)) to (MonadState s m => m a)
05:58:17 <merijn> hackrilege: There are hundreds if not thousands of optimisations that are known. Compiler optimisations are a huge field of research with lots of books, papers, etc. written about them
05:58:31 <Gurkenglas> quicksilver: Depends on whether you always use it by first wrapping in state
05:58:34 <Nuxular> has anybody here managed to get an SDL package to work on windows?
05:59:09 <exio4> Nuxular: you might have better luck asking the question directly :)
05:59:11 <hackrilege> "all sorts of tricks" should exist in a defined sense, i guess its a whole disciplin, but if there is a standard set of such optimisations to include then again, a checklist can be constructed and then its just a matter of work. im assuming work is less hard than understanding undocumented things 
05:59:19 <quicksilver> Gurkenglas: what about code which uses 'gets/modify' and 'throwError'; such code most naturally lives in MonadState s m,MonadError e m, no?
05:59:48 <merijn> hackrilege: The problem is that the work is dependent on your input language, output format and the internal representation used in the compiler :)
06:00:01 <Hafydd> JagaJaga: I don't know that that's possible without writing out the type yourself, but if you entered in GHCi ":t (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b", it would at least let you know if you're correct.
06:00:02 <Nuxular> exio4, I'm not sure what you mean. Do you mean I'm asking the wrong people or the wrong thing?
06:00:12 <merijn> hackrilege: So there's not really a single checklist of optimisations :)
06:00:18 <hackrilege> drat
06:00:33 <Nuxular> exio4, I don't know who specifically could help
06:00:33 <Hafydd> JagaJaga: luckily, obtaining the type for an instance usually just involves simple substitution of variables.
06:00:36 <hackrilege> a competative field then at least
06:00:51 <merijn> hackrilege: Why? If you're interested in writing your own compilers you should just start simple and work your way up to more complex :)
06:00:56 <Nuxular> exio4, I also don't know exactly which thing is the problem with what I've tried
06:01:30 <exio4> Nuxular: no, "don't ask to ask, just ask", you basically ask the question now, if somebody knows, they'll answer
06:01:36 <hackrilege> merijn; i would be more happy to engage in a task with clear success criteria
06:01:45 <merijn> hackrilege: I mean, CoffeeScript and similar things are very popular, despite barely doing any optimisation at all, hell they don't even do type checking :)
06:02:00 <merijn> hackrilege: The success criteria is "produces a binary/result with the correct behaviour" :)
06:02:03 <hackrilege> i wouldnt want a new language, just a new haskell compiler
06:02:28 <merijn> hackrilege: Before tackling the "new haskell compiler" goal you might wanna start simpler :)
06:02:37 <hackrilege> no, to be industrially useful it should at least not make simple tasks slow through poor compilation optimisations
06:03:02 <merijn> hackrilege: I think a non-optimising haskell would be a realistic, albeit very work-intensive goal for a single person
06:03:30 <hackrilege> merijn; i know, that was my point, what i have just learned kills this challange completely, it is not achievable for me to implement a haskell compiler as sophisticated as ghc, i will not begin to try
06:03:33 <merijn> Implementing an optimising haskell-compiler competitive with GHC...that's probably a several man-decade job :)
06:03:47 <quicksilver> merijn: augustss is rumoured to be a single person.
06:04:00 <quicksilver> and I don't think hbc was even entirely non-optimising
06:04:04 <merijn> quicksilver: Yeah, but I'm assuming he didn't write Mu completely on his own :)
06:04:05 <BernhardPosselt> hi, since monads are monoids, whats the neutral element for a maybe monad?
06:04:07 <Nuxular> exio4, I'm not exactly asking to ask: as it stands I don't know if many people have actually managed to do it
06:04:20 <quicksilver> merijn: he wrote hbc essentially on his own; or that's the way the story is normally told
06:04:20 <Gurkenglas> quicksilver: I would guess that you never unwrap it directly after its invocation. If that is true, the wrapped type signature is fine
06:04:33 <merijn> quicksilver: Also, I don't think it's fair to compare first time compiler writers with people that implement haskell compilers as a hobby :p
06:04:36 <BernhardPosselt> Just( Just 4) == Just 4?
06:04:48 <Nuxular> exio4, if I had a good idea of what I was doing wrong, I'd be more able to ask a more specific question
06:04:50 <exio4> Nuxular: I assumed you had an issue compiling it
06:04:55 <quicksilver> Gurkenglas: this question wasn't so much about wrappings as about what you think of the transformers 'MonadFoo' type classes
06:05:03 <merijn> quicksilver: Sure, but I didn't say anything about "single person writing an optimising, but not GHC competitive compiler" :p
06:05:09 <quicksilver> :)
06:05:22 <merijn> quicksilver: I think writing a completely non-optimising compiler is harder than implementing some simple optimisations :p
06:05:34 <quicksilver> I think JohnMeacham wrote jhc essentially solo as well
06:05:49 <Nuxular> exio4, my issue is simply that I have followed it's steps in many interpretations and options and have gotten the same 'SDL not found' message each time
06:06:05 <quicksilver> BernhardPosselt: no. they are different types
06:06:08 <exio4> Nuxular: then, if you have a log, you could paste it in http://lpaste.net/, which things you have tried, and then well, that
06:06:13 <hackrilege> merijn, its certainly a shame that despite advances in this field it is still such a mammoth task, industry standards for optimisation and methodological implementation guidelines should exist... basically, at some point it should be more automatic 
06:06:16 <merijn> hackrilege: tbh, if you've never written a compiler, I would highly recommend it. (One of the) most useful/educational things I ever did 
06:06:19 <Gurkenglas> quicksilver: I didn't think of those when manufactoring the quoted advice, but upon pondering, it seems sane to submit them to the same rules
06:06:35 <quicksilver> BernhardPosselt: the 'neutral element' of a Monad - when viewing it as a monoid - is "return"
06:06:46 <quicksilver> BernhardPosselt: but they are monoids in a different category so it's not quite as you expect it.
06:06:57 <hackrilege> i will write a compiler sure, but it will be part of a more realistic task now, its a shame because i would have loved to get one running on android
06:07:14 <hackrilege> but hugs already exists, its ghci thats really missing
06:07:17 <merijn> hackrilege: You could just start hacking on GHC and help get the ARM/android stuff working :>
06:07:22 <hackrilege> and of course the arm cross compiler 
06:07:55 <hackrilege> merijn, i think this was done by neurocyte already, but repairing the project looks too daunting 
06:07:59 <quicksilver> Gurkenglas: the cute thing about the double constraint (MonadState,MonadError) is you can instantiate it with the stack either way around.
06:08:18 <quicksilver> Gurkenglas: and you get different semantics - changes whether the state so far is still recorded on error.
06:08:28 <BernhardPosselt> quicksilver: ty
06:08:31 <quicksilver> Gurkenglas: whether that is actually useful - rather than merely cute - I do not say.
06:08:49 <Nuxular> exio4, the variations I've tried have been: using mingw / Visual Studio, overwriting folder with other folders / keeping them separate as downloaded, noticing there's no bin folder and leaving it out / creating an empty bin folder
06:08:51 <hackrilege> "hacking on ghc" involves rewriting it or importing it into android java
06:09:03 <hackrilege> does that sound doable?
06:09:37 <Nuxular> exio4, to be fair I haven't tried every combination of each of those variables, but there's only so much of that I'm going to do before coming here and asking for direction
06:10:13 <Nuxular> the result is no different between my attempts
06:10:31 <merijn> hackrilege: Why would you rewrite it/import it into android java? What's wrong with just adding features for ARM/android?
06:10:51 <hackrilege> because it will not run then. it would require a linux emulator
06:11:05 <Gurkenglas> quicksilver: I'm not as sure about classes as I am about newtypes. For the latter, ala/alaf/au/auf provide easy manipulation of unwrapped values using features of wrapped values. The former may provide features like yours or that you can insert layers into your stack without changing any code...
06:11:13 <merijn> Oh, you want to run GHC itself on android?
06:11:16 <hackrilege> yes
06:11:32 <merijn> That should still be possible, albeit with more engineering work
06:11:48 <merijn> Once GHC can compile haskell code to ARM, it can also compile itself to ARM
06:11:49 <exio4> that should be easier than crosscompiling
06:11:50 <hackrilege> i would hope most of the work was done already in the ghc source
06:11:57 <exio4> sounds*
06:12:26 <hackrilege> if your last statement is correct then this would simply require reconstructing neurocytes arm cross compiler
06:12:44 <hackrilege> and infact there is a stable build
06:12:54 <hackrilege> so perhaps this is doable with existing tools
06:12:58 <hackrilege> im excited!
06:13:20 <quicksilver> Gurkenglas: nod
06:13:40 <lpaste> tomus pasted “Out of ram. How do I fix this?” at http://lpaste.net/142826
06:14:26 <exio4> Nuxular: I don't know myself, that's why I suggested you to ask to the whole channel :) 
06:15:09 <hackrilege> [13:58] <Nuxular> has anybody here managed to get an SDL package to work on windows?
06:15:10 <tomus> ^^ just a simple script that finds a maximum of a function by bruteforce. it gets killed quickly though. any ideas what is so inefficient in my code?
06:16:44 <quicksilver> tomus: I might be misreading your code but findExp appears to be an infinite sum?
06:16:54 <hackrilege> Nuxular; i have
06:17:10 <quicksilver> no, I am misreading it :)
06:17:46 <hackrilege> Nuxular: are you working from; https://wiki.haskell.org/SDL/Windows   ?
06:17:53 <fizruk> tomus: sequence (take 5 (repeat l)) is huge, right?
06:18:01 <tomus> fizruk: yes..
06:18:03 <Nuxular> hackrilege, yes
06:18:11 <hackrilege> whats the issue?
06:18:26 <Nuxular> error: *** SDL not found!
06:18:33 <hackrilege> have you installed SDL?
06:18:39 <fizruk> tomus: btw, take 5 (repeat l) == replicate 5 l
06:18:54 <Nuxular> I'm not sure, but I've followed the steps of that tutorial to the best of my ability
06:19:36 <hackrilege> it looks like you must have messed up the step; Copy the bin, lib, include and share directories from the packages to a common directory, like C:\Libraries
06:19:42 <hackrilege> and put this in your path
06:20:12 <tomus> fizruk: but entire list isn't needed in ram?
06:20:35 <Nuxular> hackrilege, I noticed there was no bin folder in what I downloaded
06:20:52 <hackrilege> ill have a look
06:21:14 <hackrilege> lets take this to a private message ill try to walk through the installation with you
06:21:20 <fizruk> tomus: I am not sure about this. sequence might not fuse (never thought of this)
06:21:24 <Nuxular> hackrilege, what operating system, architecture and compiler are you using?
06:22:17 <tomus> fizruk: anyways to make it work by replacing sequence by something else?
06:22:39 <fizruk> tomus: nvm, sequence fuses
06:24:02 <tomus> fizruk: are you russian btw? :)
06:24:18 <fizruk> I am
06:24:27 <tomus> me too, funny name :)
06:24:46 <quicksilver> tomus, fizruk: if you replace the call to arg max with something which takes the first 5 (or 10 or 100 or 1000) entries of restrictedDomain
06:25:01 <quicksilver> you can verify that restrictedDomain is correctly being generated lazily
06:25:22 <fizruk> I suspect that domain' size is the issue
06:25:35 <fizruk> it has ~10^10 elements, if I am right
06:25:41 <quicksilver> yes, it certainly is the issue, fizruk 
06:25:46 <quicksilver> but on the other hand, it should be GCed
06:25:52 <quicksilver> as long as nothing else holds references to the head of it
06:26:04 <fizruk> oh, I forget that memory is the issue
06:26:51 <hexagoxel> hsSDL2 is deprecated in favor of sdl2.
06:27:15 * hackagebot milena 0.4.0.1 - A Kafka client for Haskell.  https://hackage.haskell.org/package/milena-0.4.0.1 (tylerholien)
06:28:17 <JagaJaga> Hafydd: thank you.
06:28:36 <tomus> quicksilver: head (reverse (take 100 (restrictedDomain)) works
06:28:37 <hexagoxel> Nuxular: admittedly, sdl2 does not seem to provide any windows-specific installation instructions. however i did set it up on a windows system recently.
06:29:12 <Nuxular> hexagoxel, I'd be happy with _any_ sdl package atm
06:29:13 <tomus> killed on take 10000
06:29:31 <Nuxular> hexagoxel, sdl2 would be nice but I'd be fine with SDL
06:32:16 * hackagebot haxl 0.3.0.0 - A Haskell library for efficient, concurrent,  and concise data access.  https://hackage.haskell.org/package/haxl-0.3.0.0 (SimonMarlow)
06:35:09 <fizruk> tomus: did it use a lot of memoru with take 10000?
06:35:21 <fizruk> tomus: perhaps the issue is with argmax
06:35:35 <fizruk> tomus: (if answer to my question is no)
06:37:02 <bartavelle> i think it's a problem with replicateM
06:37:59 <bartavelle> or perhaps not
06:39:15 <bartavelle> yes it is
06:39:58 <bartavelle> fizruk, tomus : http://lpaste.net/1322357345958756352
06:41:25 <fizruk> bartavelle: there is no replicateM in the original paste, do you refer to (sequence (take 5 (repeat l))) ?
06:41:33 <L8D> :t fmap (fmap fmap) fmap
06:41:35 <lambdabot> Functor f => (a1 -> b) -> (a -> a1) -> f a -> f b
06:41:43 <bartavelle> yeah
06:41:47 <bartavelle> that's the same thing
06:41:54 <L8D> same thing as what?
06:42:04 <bartavelle> L8D, sorry, was answering to fizruk
06:42:05 <tomus> fizruk: with 50000, memusg: peak=785348
06:42:07 <L8D> :t fmap . fmap
06:42:08 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
06:42:16 <L8D> hm...
06:42:35 <fizruk> bartavelle: can you explain why there is a problem?
06:42:40 <bartavelle> no idea :)
06:42:42 <tomus> bartavelle: your code doesn't use as much memory?
06:42:51 <tomus> I thought it is identicaly to sequence...
06:42:51 <fizruk> :t fmap fmap fmap fmap fmap fmap fmap fmap -- L8D 
06:42:53 <lambdabot> (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
06:42:53 <bartavelle> tomus, no it uses 80M according to -t
06:43:01 <jophish__> morning :)
06:43:32 <bartavelle> tomus, and yes, I would also expect it to be identical to replicateM :/
06:43:43 <fizruk> bartavelle: would sequenceA perform better?
06:43:44 <hexagoxel> Nuxular: i think i basically did the following 1) use msys2 2) use that to install sdl2 system packages and base-devel 3) add pkgconfig path to my .bashrc 4) fix sdl2's pkgconfig to use windows paths instead of linux (this is kind of a hack, there must be a better solution..)
06:44:30 <bartavelle> fizruk, it hits my 1G limit too
06:44:34 <Nuxular> it's possible I didn't do all of that
06:45:20 <hexagoxel> Nuxular: i don't promise that that is complete :)
06:45:45 <Nuxular> hexagoxel, ok but thanks for your input nonetheless
06:46:58 <tomus> bartavelle: yay, it computed my probability distribution which maximises entropy given that mean roll of a die is 4! :)
06:47:47 <bartavelle> fizruk, tomus : I *suppose* sequence keeps a reference to all 4, 3, 2 and 1 element lists ? I don't really know why it doesn't GC
06:48:42 <fizruk> @src sequence
06:48:42 <lambdabot> sequence []     = return []
06:48:42 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
06:48:42 <lambdabot> --OR
06:48:42 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
06:48:57 <fizruk> @src sequenceA
06:48:57 <lambdabot> Source not found. Maybe you made a typo?
06:49:55 <dredozubov> it's "traverse id"
06:50:46 <fizruk> dredozubov: yep, and sequence = sequenceA with GHC 7.10
06:50:59 <hexagoxel> lambdabot is polite for once? that is rare.
06:51:28 <fizruk> maybe I am special
06:51:34 <hexagoxel> try again :p
06:51:46 <BernhardPosselt> is a monad limitted to bind and return? i mean if i look at Promise (in ES6) theres the .then method (which seems to be bind) and also the catch method (which feels similar to bind)
06:52:02 <fizruk> @src sequenceA
06:52:03 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
06:52:21 <dredozubov> BernhardPosselt: 'then' seems semantically close to >>=
06:52:32 <BernhardPosselt> yep
06:52:37 <BernhardPosselt> what about 'catch'
06:52:46 <dredozubov> sources?
06:53:10 <fizruk> BernhardPosselt: what does catch do?
06:53:13 <dredozubov> i actually don't have a clue about ES6 promises
06:53:14 <tomus> uence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
06:53:22 <tomus> ^^ would that one not work?
06:53:56 <BernhardPosselt> fizruk: it handles error cases. basically if one promise in the chain gets rejected, catch is executed
06:53:56 <fizruk> tomus: try it)
06:54:39 <fizruk> BernhardPosselt: that does not make sense for a bunch of Monad instances (e.g. Identity, Writer m)
06:54:57 <dredozubov> BernhardPosselt: what does it mean for promise to be "rejected"?
06:55:00 <fizruk> BernhardPosselt: so you need a subclass for that (e.g. MonadCatch)
06:55:43 <BernhardPosselt> dredozubov: all following then methods are skipped and the catch at the end is executed
06:55:43 <dredozubov> fizruk: it looks like an instance of some particular monad, rather than monad class
06:55:51 <tomus> fizruk: killed
06:55:55 <sleblanc> Why not use a chain of Maybes instead?
06:55:57 <BernhardPosselt> much like Nothing 
06:55:59 <BernhardPosselt> yep
06:56:05 <sleblanc> Just = Then, Nothing = Catch (without value)
06:56:19 <BernhardPosselt> but the catch has usually a value
06:56:21 <BernhardPosselt> the error
06:56:32 <BernhardPosselt> and the callback is executed
06:57:00 <BernhardPosselt> http://www.2ality.com/2014/10/es6-promises-api.html
06:57:48 <dredozubov> @src either
06:57:48 <lambdabot> either f _ (Left x)  = f x
06:57:48 <lambdabot> either _ g (Right y) = g y
06:57:58 <BernhardPosselt> classic usecase for the error monoid?
06:57:58 <dredozubov> it looks like something like this
06:58:25 <dredozubov> 'then' takes two handlers, just like 'either'
06:58:30 <BernhardPosselt> exactly
06:58:54 <dredozubov> i guess there is a failure context somewhere in "Left" branch of this `then`
06:59:17 <sleblanc> Found that for inspiration: https://gist.github.com/chrisdotcode/d16c89864f4278e52605
06:59:53 <dredozubov> (i think it's called a promise burrito pattern)
07:00:01 <roelof__> Hello, I have this in my main.hs : http://lpaste.net/142830 and this is my test : http://lpaste.net/142832
07:00:33 <BernhardPosselt> btw, funny how you are actually using monads in other languages (like Optional in Java) without knowing or grasping the concept :D
07:00:36 <roelof__> as soon as I do stack test I see this error message : Progress: 1/2exercise1-test: user error (Pattern match failure in do expression at app/Main.hs:12:8-14)
07:00:42 <roelof__> how to solve this one ? 
07:01:08 <fizruk> roelof__: [a1,a2] <- getArgs
07:01:29 <BernhardPosselt> and most explanations just suck
07:01:30 <fizruk> roelof__: this suggests 2 command line arguments
07:01:52 <srhb> roelof__: As stated earlier in the other channel, that pattern match will fail for anything but two command line args. if you want to handle the other cases, use as <- getArgs and case match on as with sensible handling.
07:01:56 <merijn> BernhardPosselt: And all the nice guarantees of the laws
07:02:14 <roelof__> fizruk:  that's right my_xor true false 
07:02:15 <sleblanc> BernhardPosselt, funny, right? I saw a "Maybe for C++" blog article with code example, the other day, and I was amazed at how much code is required to make it work
07:02:36 <sleblanc> Then I wondered whether your average C++ coder would use it, let alone understand the semantics
07:02:47 <fizruk> roelof__: stack test will run your test module
07:02:47 <merijn> C++ is nice in that you CAN make it do what you want. It just takes a million lines of code + compile overhead
07:02:59 <merijn> sleblanc: I think you're underestimating the "average C++ coder"
07:03:07 <fizruk> roelof__: which has main imported from your Main module
07:03:23 <L8D> BernhardPosselt: Optional is not a monad
07:03:24 <sleblanc> merijn, if they would stop tacking on more and more stuff on the same base structure, maybe they could simplify the syntax, but legacy is legacy
07:03:24 <fizruk> roelof__: perhaps you intended to make a different Main for test
07:03:30 <L8D> in the same way Maybe isn't "a monad"
07:03:39 <merijn> sleblanc: The biggest problem is not the legacy
07:03:47 <merijn> sleblanc: The biggest problem is the core tenet of C++
07:03:58 <merijn> sleblanc: "Unused abstractions should not cost anything"
07:04:06 <dredozubov> merijn: i believe that C++ is the hardest PL to master to date
07:04:12 <roelof__> chips I wanted to test my_xor and not main 
07:04:35 <dredozubov> so "the average C++ programmer" must be pretty knowledgeable
07:04:36 <merijn> dredozubov: Naah, it's not *that* hard, it just requires memorising a billion facts
07:04:51 <BernhardPosselt> dredozubov: one of the languages where a lot of stuff can go wrong in ways youve never imagined :D
07:05:05 <dredozubov> merijn: it's still error-prone, so you have to be pretty smart not to shoot yourself in the foot
07:05:19 <merijn> dredozubov: Actually, it's not that bad in C++11 and C++14
07:05:25 <ruslan_talpa> while on this channel with a question about parsers, someone said something like "you could write your parsers in a lib agnostic way". Can someone please direct me to some documentations on that? Thank you
07:05:37 <merijn> @hackage parsers -- ruslan_talpa 
07:05:38 <lambdabot> http://hackage.haskell.org/package/parsers -- ruslan_talpa
07:05:40 <dredozubov> merijn: maybe, i haven't tried it since 2009-2010 or something
07:05:50 <dredozubov> man, i was terrified 
07:05:53 <fizruk> dredozubov: or you just have to be smart enough to not *obviously* shoot yourself in the foot
07:06:05 <roelof__> fizruk:  so I have to change my import , I think 
07:06:06 <merijn> dredozubov: C++11 has a properly function std::shared_ptr and std::uniq_ptr
07:06:27 <roelof__> Haskell is easy till you try to make a project :(
07:06:29 <dredozubov> fizruk: i consider haskell to be a good match for me, i can be pretty stupid and compiler will help to fix plenty of errors
07:06:35 <fizruk> roelof__: you probably want to separate logic from Main into a separate module and not import Main ever
07:06:46 <BernhardPosselt> merijn: however they are tricky in their own ways
07:06:55 <dredozubov> merijn: i'd like to see rust replace c++ in the future
07:07:00 <merijn> I think Haskell is a good default language, but it's not suitable for everything, sadly :\
07:07:05 <dredozubov> it looks much cleaner
07:07:08 <roelof__> fizruk:  so I can import my_xor from the main.hs to test 
07:07:11 <dredozubov> also design seems more modern
07:07:19 <BernhardPosselt> dredozubov: couldnt agree more :)
07:07:24 <sleblanc> dredozubov, re: Rust, I agree
07:07:34 <dredozubov> roelof__: i use haskell at work, still happy
07:07:38 <sleblanc> Rust could almost be called "C done right, mostly"
07:07:47 <tdammers> almost mostly
07:07:48 <fizruk> roelof__: try moving my_xor to Lib.hs, then import Lib from both main.hs and test.hs
07:07:49 <merijn> Yeah, I have high hopes for Rust in the future
07:08:07 <fizruk> roelof__: in test.hs you still need `main :: IO ()
07:08:09 <merijn> BernhardPosselt: What's so tricky about shared_ptr/uniq_ptr?
07:08:21 <BernhardPosselt> merijn: 
07:08:45 <BernhardPosselt> cyclic refs
07:08:46 <BernhardPosselt> etc
07:08:59 <merijn> That's not harder than with pointers in general
07:09:25 <BernhardPosselt> its just you need to aware of the internals
07:09:34 <merijn> You always need that with C++
07:09:59 <fizruk> dredozubov: I'd like to see Haskell replace C++ :)
07:10:01 <dredozubov> you need to be alert, constant sense of danger and this sweet adrenaline sensation
07:10:04 <sleblanc> When your data structure introduces cyclic references, you will need a finalizer in any case (excluding sophisticated garbage collection)
07:10:05 <dredozubov> this is how you market C++
07:10:06 <BernhardPosselt> as for rust the compiler will make sure everything is sane
07:10:20 <BernhardPosselt> although i dont know how Rc is implemented thb
07:10:22 <BernhardPosselt> tbh*
07:10:24 <roelof__> fizruk:  then I see the same error : Progress: 1/2exercise1-test: user error (Pattern match failure in do expression at app/Main.hs:12:8-14)
07:10:26 <dredozubov> fizruk: it's GC'd, so i don't see it happening
07:10:26 <BernhardPosselt> as for cyclic refs
07:11:01 <fizruk> dredozubov: i never said it might happen
07:11:27 <dredozubov> i'm just pointing out the obvious, just in case :)
07:13:03 <dredozubov> do you think it's possible for Rust to replace C++ in gamedev?
07:13:05 * roelof__ thinks maybe change stack for cabal for his projects 
07:13:17 <fizruk> roelof__: the problem is not stack vs cabal
07:13:23 <dredozubov> C++ is a holy grail in game industry to this day
07:13:28 <dredozubov> it seems wrong
07:13:42 <fizruk> roelof__: did you remove `import Main` from test.hs? are you still running `stack test`?
07:13:44 <roelof__> fizruk:  oke, I do not see it anymore. 
07:14:19 <roelof__> fizruk:  yes, I have changed import Main to import Lib 
07:14:59 <fizruk> roelof__: so now you just have to implement main for test.hs, right?
07:15:42 <roelof__> oke, I see there is no main anymore. Can I just copy main from main.hs ? 
07:15:46 <fizruk> dredozubov: I thought C# is also somewhat popular?
07:16:07 <sleblanc> fizruk, only in corporate Microsoft-backed environments
07:16:11 <dredozubov> fizruk: can you do multiplatform stuff with C#?
07:16:18 <sleblanc> dredozubov, kind of
07:16:23 <dredozubov> is it supported by sony, i mean?
07:16:34 <sleblanc> dredozubov, Microsoft will tell you "Yes! .NET is on Windows, Linux and Mac"
07:16:41 <Testeree> is there a creative coding library for haskell à la https://libcinder.org/ or http://openframeworks.cc/ ?
07:16:42 <fizruk> roelof__: no, main in test.hs should run tests, that's different from main in main.hs
07:16:52 <fizruk> roelof__: you should take a look at hspec
07:16:58 <sleblanc> I don't think Sony officially supports C#, it's mostly the licensed game engines that do
07:17:02 <fizruk> roelof__: http://hspec.github.io
07:17:59 <roelof__> pity , I cannot use quickCheck :( 
07:18:09 <sleblanc> Unity requires you to code in C#, but when you target PlayStation or Wii, I believe it does some fancy translation
07:18:11 <merijn> dredozubov: Meh, gaming will move away too
07:18:36 <merijn> dredozubov: There was a PoPL talk by Tim Sweeney (of Epic fame) about "The Next Big PL" (for games)
07:19:18 <sleblanc> merijn, I predict the gaming industry will soon die, same as in the 80s
07:19:18 <dredozubov> merijn: i think i saw that, it was in the lines of "we don't have anything tolerable, let's make something new?"
07:19:21 <dredozubov> ?
07:19:23 <fizruk> roelof__: why?
07:19:34 <merijn> dredozubov: No, just describing what it would look like
07:19:36 <fizruk> roelof__: is this homework?
07:19:43 <dredozubov> sleblanc: it's super big right now, it cannot die
07:19:44 <sleblanc> die → crash
07:19:45 <merijn> dredozubov: Which "a lot more like haskell than we have now"
07:20:07 <merijn> dredozubov: https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf
07:20:07 <roelof__> no, im self study haskell and I tried to make my first project 
07:20:15 <sleblanc> dredozubov, meh, I disagree. It's full of re-hashed content, DLC, subscription-based content and whatnot.
07:20:34 <dredozubov> sleblanc: the main point is: it makes money
07:20:52 <merijn> sleblanc: Who says subscription-based content is inherently bad? Anyway, this is off-topic, so to #haskell-blah
07:20:53 <dredozubov> i hate to see all that dlc stuff, but it's marketing for you
07:21:21 <sleblanc> GM does too, and look what happened in 2009
07:21:40 <sleblanc> Yeah, I agree it's off topic
07:21:44 <dredozubov> merijn: oh, we actually have #haskell-blah...
07:21:50 <merijn> dredozubov: Yes
07:21:50 <dredozubov> i thought you were joking :)
07:22:04 <merijn> Although it's usually off-topic too and talking about haskell :p
07:22:11 <dredozubov> hehe
07:22:19 * hackagebot mandrill 0.5.0.0 - Library for interfacing with the Mandrill JSON API  https://hackage.haskell.org/package/mandrill-0.5.0.0 (AlfredoDiNapoli)
07:22:47 <fizruk> roelof__: if you want to write tests completely by yourself, you can run prop_my_xor for some inputs and exit with failure if any of the tests fail
07:22:57 <fizruk> roelof__: use System.Exit
07:23:05 <roelof__> maybe back to the books and learn more about haskell before I can try to make projects with cabal or stack 
07:23:48 <jophish__> :Q
07:23:52 <roelof__> fizruk:  I know that way and use ghci as this quickTest prop_ xxxxxxx
07:26:01 <fizruk> roelof__: project structure has little to do with language, you probably should read more about cabal project structure, stack and see some project examples
07:26:12 <roelof__> Does anyone know if the book programming haskell from Hutton will talk about cabal ? 
07:26:30 <dcoutts> roelof__: it doesn't, but it's a great intro book
07:27:14 <roelof__> oke, and is there a book where I can learn more about cabal , project structure and so on ?
07:32:19 <roelof__> fizruk:  dcoutts  what is a good tutorial where I can learn more about Cabal, project structure 
07:32:38 <dcoutts> roelof__: the cabal use guide
07:32:54 <dcoutts> roelof__: and https://wiki.haskell.org/How_to_write_a_Haskell_program
07:33:14 <dcoutts> roelof__: https://www.haskell.org/cabal/users-guide/
07:34:40 <testeree> is there a creative coding library for haskell à la https://libcinder.org/ or http://openframeworks.cc/ ?
07:35:18 <roelof__> the wiki page is very interresting 
07:36:09 <roelof__> Thanks all, enough to study tonight when my daugther is sleeping 
07:36:36 <fizruk> roelof__: stack can create some template project structures for new projects, this page might also be useful: https://github.com/commercialhaskell/stack#the-haskell-tool-stack
07:37:17 <roelof__> fizruk:  I have read it but get more and more confused 
07:37:20 * hackagebot rest-example 0.2.0.3 - Example project for rest  https://hackage.haskell.org/package/rest-example-0.2.0.3 (ErikHesselink)
07:37:47 <fizruk> roelof__: did you also take a look at https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md
07:38:44 <roelof__> but I see something wierd on the wiki page : First they do cat > QuickTests.hs and later runhaskell Tests.hs. Must that not be runhaskell Quicjktests.hs ? 
07:39:20 <roelof__> fizruk:  yes, but nothing about tests 
07:41:12 <fizruk> roelof__: well for tests read cabal user guide and also hspec
07:42:04 <roelof__> oke, so Hunit and QuickCheck are not the good tests frameworks. They are explained in the programming Haskell book 
07:42:26 <fizruk> roelof__: hspec uses HUnit and QuickCheck
07:43:02 <roelof__> oke, like I said enought to study tonight and the next few days
07:43:05 <roelof__> Thanks all 
07:43:16 <fizruk> you're welcome!
07:57:08 <bitemyapp> ReinH: o/
08:05:52 <quicksilver> Gurkenglas: https://hackage.haskell.org/package/mmorph-1.0.4/docs/Control-Monad-Morph.html
08:11:29 <BernhardPosselt> if dependency injection and partial function application are basically the same, are there dependency injection frameworks out there for haskell?
08:12:30 <ChristianS> BernhardPosselt: why says that? also, you don't generally need "frameworks" in haskell.
08:12:43 * hackagebot secp256k1 0.1.0 - secp256k1 bindings for Haskell  https://hackage.haskell.org/package/secp256k1-0.1.0 (XenoGenesis)
08:12:45 * hackagebot secp256k1 0.1.1 - secp256k1 bindings for Haskell  https://hackage.haskell.org/package/secp256k1-0.1.1 (XenoGenesis)
08:12:48 <tdammers> BernhardPosselt: they're not the same
08:12:51 <BernhardPosselt> what about swapping out implementations?
08:13:02 <BernhardPosselt> based on a config file for instance
08:13:16 <BernhardPosselt> simple example: db connections (postgres,sqlite etc)
08:13:34 <tdammers> the most straightforward way to do that in Haskell is to provide different values of the same type based on configuration
08:13:54 <tdammers> for modularity, this often involves wrapper types
08:14:29 <quicksilver> I don't want to be guilty of over-generalising
08:14:32 <tdammers> another popular option is to do it at compile time, using typeclasses and polymorphic types
08:14:51 <quicksilver> but very often a "dependency injection framework" is a shim around the fact that a language doesn't support first-class values of some type
08:15:07 <quicksilver> in haskell you simply define the right kind of data type and pass the right value
08:15:33 <quicksilver> using typeclasses for this kind of example (DB connections, say) is probably unneeded, and slightly cumbersome.
08:15:39 <BernhardPosselt> what about storage for instance?
08:15:44 <tdammers> OTOH, swapping out implementations isn't needed anywhere near as often as it is in a typical OOP language, because Haskell provides more fine-grained ways of separating and wrapping abstraction layers, allowing them to be tested in isolation without having to explicitly mock anything
08:15:58 <BernhardPosselt> i mean with DI you can swap out a db for a file based storage 
08:16:08 <BernhardPosselt> if both implement the same interface
08:16:12 <tdammers> BernhardPosselt: the typical approach for this would be to define a type that represents the common interface
08:16:21 <quicksilver> just pass a value which represents the storage interface
08:16:41 <tdammers> data Storage a = Storage { put :: a -> IO Int, get :: Int -> IO (Maybe a) }
08:16:42 <quicksilver> I've seen that done occasionally using a MonadFoo typeclass
08:16:57 <quicksilver> mostly because people want to use an overloaded 'do' notation for uses of it
08:17:25 <c_wraith> As the joke goes, 99% of common OO patterns become "higher-order functions" in haskell 
08:17:42 <BernhardPosselt> yes ;D
08:18:01 <BernhardPosselt> was just wondering if you'd wire up stuff in the same way as in java
08:18:04 <BernhardPosselt> for instance
08:18:45 <quicksilver> c_wraith: really first-class values of various types, not just functions but yes.
08:18:56 <quicksilver> c_wraith: it's surprisingly often true for somethign so trite.
08:19:33 <c_wraith> Yeah.. The joke is just exaggerating the frequency, not the substance. 
08:22:14 <BernhardPosselt> can you dynamically create data "things" in haskell? e.g. by providing the full path as a string
08:22:51 <quicksilver> BernhardPosselt: you mean dynamically load a haskell source file which defines a type?
08:23:15 <BernhardPosselt> like this: http://stackoverflow.com/questions/7495785/java-how-to-instantiate-a-class-from-string
08:23:38 <quicksilver> well haskell is quite unlike java
08:23:49 <quicksilver> you define all the types and functions and modules in your program at compile time
08:23:54 <quicksilver> so loading them later doesn't make sense
08:24:05 <tdammers> types only really exist at compile time
08:24:08 <tdammers> just like in C
08:24:15 <quicksilver> however, if you really do need runtime loading you can do it - it's not a built-in haskell notion - you have to embed a haskell interpreter in your code.
08:24:26 <quicksilver> hsplugins was the original proof of concept for this
08:24:33 <quicksilver> not sure what the current state of the art is
08:24:43 <quicksilver> but generally it is not needed in those cases that java uses the trick above.
08:25:04 <BernhardPosselt> usecase is putting the types in a configuration file that you swap them out
08:25:05 <srhb> plugins is the more recent attempt.
08:25:24 <quicksilver> https://hackage.haskell.org/package/plugins-1.5.5.0
08:25:27 <tdammers> you don't really want actual code in your configuration file anyway
08:25:39 <tdammers> not worth the risk
08:26:01 <BernhardPosselt> so code over configuration is the preferred option?
08:26:06 <tdammers> no
08:26:08 <quicksilver> not at all
08:26:11 <tdammers> dumb data for configuration
08:26:19 <quicksilver> a sensibel configuration language is the preferred option
08:26:49 <BernhardPosselt> i see :)
08:26:56 <tdammers> e.g., you can have a YAML config file, and implement your FromJSON instances such that they pick the right functions when reading the config file
08:27:12 <tdammers> but the config file itself knows nothing about the program's internal types
08:27:23 <BernhardPosselt> as in: you have to create the mapping
08:27:26 <tdammers> yes
08:27:42 <tdammers> however, much of it can be automated / templated away
08:43:07 <orion> Does lens support anything like RecordWildCards?
08:44:42 <quicksilver> orion: erm... not sure how that would work
08:45:12 <quicksilver> I guess the answer is no. The point of lens is to make field names first class; not to confuse them with their values
08:46:07 <orion> ok
08:47:20 <hpc> finally found a reason to upgrade ghc - https://hackage.haskell.org/package/json-stream-0.3.2.3
08:52:36 <quicksilver> orion: lens gives us the tools to make most functions pretty easy to write and concise, tho
08:52:45 * hackagebot wavefront 0.2 - Wavefront OBJ loader  https://hackage.haskell.org/package/wavefront-0.2 (DimitriSabadie)
08:55:48 <c_wraith> The lens package in particular isn't even really about record fields anymore. It's much more general. 
08:57:25 <orion> Is there a way to make this more concise?: http://lpaste.net/5963756180068106240
08:58:13 <glguy> cs & csn .~ cipherIncNonce (cs ^. csn) --to-- cs & csn %~ cipherIncNonce
08:58:24 <glguy> or: over csn cipherIncNonce cs
08:58:40 <orion> Oh wow, that's cool. :|
08:59:37 <capisce> yeah
09:01:34 <orion> Is there a way to automatically export autogenerated lenses, similar to how you can export fields with (..)?
09:01:52 <roelof> hello, I make a cabal sandbox with cabal sandbox init and after that I installed Hlint with cabal install Hlint. 
09:02:24 <glguy> orion: Not the ones like makeLenses makes, no. If you put them all in a class like makeClassy does you can export the class with .., but then you have to have the class.
09:02:24 <roelof> but as soon as I do Hlint at a normal prompt I see a message that Hlint cannot be found. How to solve that ? 
09:02:39 <orion> glguy: I see.
09:07:22 <Nuxular> hexagoxel, you there? I;m still working on this SDL issue
09:07:46 * hackagebot http-api-data 0.2.1 - Converting to/from HTTP API data like URL pieces, headers and query parameters.  https://hackage.haskell.org/package/http-api-data-0.2.1 (NickolayKudasov)
09:09:34 <orion> Are there lenses for creating new records, as opposed to modifying existing ones?
09:10:06 <Testeree> is there a creative coding library for haskell like https://libcinder.org/ or http://openframeworks.cc/ ?
09:11:47 <tommd> orion: How goes the noise?
09:13:03 <Nuxular> why is this such a pain? All I want to do is use haskell for graphical purposes
09:13:34 <tommd> Nuxular: "This"?
09:13:58 <Nuxular> tommd, I'm trying and failing to install sdl packages for haskell
09:14:01 <orion> tommd: Great! I am redoing sections of the code to make use of lens, which I'm super happy about because I've never used lens before. I also have two handshakes (Noise_NN and Noise_SN) implemented, and I've designed unit tests for them.
09:14:43 <tommd> Nuxular: sdl or sdl2?  Do you have the C libs installed?  What OS?
09:15:30 <tommd> orion: Good work.  So is this library going to be purely crypto, leaving any sort of use (network, UI, what have you) to another package?
09:15:31 <Nuxular> tommd, I don't mind which. I've been trying to follow the steps provided by tutorials of which I believe that is one. Windows 8.1 64bit
09:16:10 <orion> tommd: Indeed. There's going to be the noise package, and then there's going to be a separate package which contains the bindings to libraries like cryptonite.
09:16:48 <tommd> Nuxular: Feel free to paste the output and ask for more specific help, but if you're _unsure_ about things like having the requried C library then you'll want to double check that first.
09:17:39 <orion> So far, the library only depends on base, bytestring, lens, memory, and mtl.
09:19:08 <Nuxular> tommd, I believe 'having the required C library' means 'have the correct version of all files (such as SDL.dll / SDL2.dll and the various includes, libs, bins and shares) in all the correct places
09:20:17 <Nuxular> I've put what I thought were the correct versions of the correct files in all of the possible correct places and have not successfully compiled anything any tutorial has suggested I should be able to
09:20:49 <Nuxular> so I'm a little unsure what's going wrong here
09:21:34 <Nuxular> It's possible that none of these tutorials have been well maintained and the links / steps I'm following no longer apply
09:21:42 <Nuxular> so I'm a little frustrated
09:22:14 <Nuxular> I'm left wondering why cabal can't just sort this out for me
09:23:30 <Nuxular> tutorial 1: http://stackoverflow.com/questions/8307091/setting-up-sdl-in-mingw
09:23:33 <nshepperd> orion: creating records? you can add or remove values from a mapping type using 'at'
09:24:05 <Nuxular> tutorial 2: https://wiki.haskell.org/SDL/Windows
09:25:11 <nshepperd> orion: 'at "key"' defines a lens that extracts a (Maybe v) from a (Map String v), for instance
09:25:53 <orion> I see.
09:26:27 <Nuxular> my frustrations aren't limited to trying to use SDL with haskell on windows
09:26:47 <Nuxular> I've had a similar experience trying to get an xml parser package installed
09:26:54 <nshepperd> > Data.Map.empty
09:26:56 <lambdabot>  Not in scope: ‘Data.Map.empty’
09:26:59 <nshepperd> whoops
09:28:42 <nshepperd> > set (at "hi") (Just 4) M.empty -- adding a value
09:28:44 <lambdabot>  fromList [("hi",4)]
09:29:40 <ttt_fff> ghc is outputting *.o *.hi *.dyn_o *.dyn_hi files , but no binary. What flag to I need?
09:29:41 <hexagoxel> Nuxular: huh? an xml parser should not have external dependencies..
09:30:20 <hexagoxel> Nuxular: how do you determining that your sdl setup is not working? what command? what is the output?
09:31:31 <lyxia> ttt_fff: Is your main in the module Main?
09:31:33 <ttt_fff>         ghc -outputdir out-ghc -I. -Wall -fno-warn-orphans -j8 -XCPP -XNoImplicitPrelude -XOverloadedStrings -XMultiParamTypeClasses -XFunctionalDependencies -XTypeSynonymInstances -XFlexibleInstances -XInstanceSigs -XOverloadedStrings -XNoImplicitPrelude -XLambdaCase -XTupleSections -XScopedTypeVariables -XGADTs -XTemplateHaskell --make Main.hs -o test
09:31:42 <ttt_fff> yes, it is
09:31:45 <ttt_fff> also, above = my flags
09:32:53 <ttt_fff> err, n/m, joking, this works :-)
09:33:23 <lyxia> heh
09:34:32 <Nuxular> hexagoxel, the xml parser issue was with cabal failing to install it
09:34:56 <Nuxular> I don't think it's dependencies were external but they were failing to be maintained it seems
09:35:42 <Nuxular> hexagoxel, my test method would be with each given tutorial there would be a test that would fail for me
09:36:15 <Nuxular> hexagoxel, usually the error message would be of SDL or some other file not being present
09:36:56 <Nuxular> hexagoxel, when I have time, I'll do it all in a well recorded fashion
09:37:10 <Nuxular> but the tutorial is the best record of what I did in each case..
09:37:16 <Nuxular> gotta go thanks anyway
09:41:28 <hexagoxel> Nuxular: my setup is exactly the same, so it is definitely possible. unfortunately i did not follow a specific tutorial
09:44:10 <Nux> I'm Nux on my phone now
09:46:07 <hexagoxel> Nux: anyway, without more detailed information what you tried it will be near impossible to help.
09:47:57 <Nux> Am I right in saying that all I should need to run an executable is SDL.dll and it will be found so long as it is in the same directory as that executable or if my path environment varirable mentions it's location?
09:48:17 <orion> Does GHC's profiler have a mechanism which allows me to get a listing of every time a function was called, and what arguments were passed?
09:48:21 <Nux> an executable using SDL I mean
09:49:04 <Nux> or if the executable explicitly states where to find it?
09:49:21 <Nux> or is it only that last one?
10:00:08 <hexagoxel> Nux: i am pretty sure you need the header files (and probably the static libraries (.lib i think for win)). also, the .dll is/would be runtime; i guess your first goal should be to compile the sdl2 successfully.
10:01:42 <Nux> alright I'll try next time I'm are my computer
10:01:48 <hexagoxel> (oh, they are called "libSDL2.a" in the msys2 installation)
10:06:32 <cabbibo> hey there! does anyone know the name of the beginner haskell channel?
10:06:35 <tommd> Nuxular: That's a shame.  If you get concrete steps and errors then people here will usually help.
10:09:32 <shachaf> cabbibo: This is the beginner Haskell channel.
10:10:29 <humanoyd> When I define myLens = key "foo" . key "bar" . values . _String in order to read an array of strings from JSON with lens-aeson, ghc complains about p not being an instance of Data.Profunctor.Choice. What to I need to do to make this work?
10:11:01 <cabbibo> oh coool! Thanks @shachas
10:11:05 <shachaf> I don't know. Post full code and full error.
10:11:14 <cabbibo> I've got a lens question!
10:11:34 <cabbibo> So I've made a lens that looks like : 
10:11:35 <cabbibo> data Line = Line   { _linPose        :: !(Pose GLfloat)   , _linStartPoint  :: !(V3 GLfloat)   , _linEndPoint    :: !(V3 GLfloat)   , _linColor       :: !(V4 GLfloat)   , _linActive      :: !Int   } makeLenses ''Line
10:11:37 <shachaf> It could be the monomorphism restriction or it could be how you're using it (review?) or something else.
10:11:45 <cabbibo> oh man. is there a better way to format code here?
10:11:53 <shachaf> You can paste it on hpaste.org
10:14:06 <cabbibo> Ok. So Made a lens that looks like this: http://lpaste.net/142844 , and look it up from a map, like this : http://lpaste.net/142847
10:14:36 <cabbibo> in lines 7 & 8 of http://lpaste.net/142847 though, I'm trying to set those values from the lens, but obviously thats no the right way to do it...
10:14:46 <shachaf> THis is inside StateT s IO or something?
10:14:57 <cabbibo> Is there some way to basically extrac those values form a lens and then set thim
10:14:59 <cabbibo> umm
10:15:14 <cabbibo> yes ? I think so.
10:15:28 <shachaf> You think so?
10:16:12 <shachaf> (^.) is a viewing function. It's also called view. (l ^. someLens) is just a value.
10:16:20 <humanoyd> shachaf: Thanks, it was the monomorphism restriction
10:16:37 <cabbibo> ahh
10:16:39 <cabbibo> ok. 
10:16:41 <shachaf> I'm not really sure what you're trying to do.
10:16:46 <cabbibo> I thought of it as 'extract'
10:16:51 <cabbibo> I am trying to set
10:17:07 <cabbibo> linActive  equal to 0
10:18:08 <shachaf> Set what?
10:18:30 <shachaf> Haskell doesn't have mutation.
10:18:31 <cabbibo> sorry. im bad at explaining this....
10:18:41 <cabbibo> in the lens
10:18:43 <cabbibo> from http://lpaste.net/142844
10:18:44 <shachaf> It looks like you're using some sort of MonadState monad.
10:18:57 <cabbibo> there is the value _linActive
10:19:05 <shachaf> You should paste full code rather than a snippet.
10:19:32 <cabbibo> oh man... the full code is heinous :) But I can !!!
10:20:15 <cabbibo> http://lpaste.net/142848
10:20:57 <cabbibo> so lines 244 and 245 are the ones in question, where I'm trying to set the values of the Line lens
10:21:14 <cabbibo> Obviously not all the code is mine :) ...
10:42:49 * hackagebot vcache-trie 0.2.4 - patricia tries modeled above VCache  https://hackage.haskell.org/package/vcache-trie-0.2.4 (dmbarbour)
10:50:19 <chaosmasttter> cabbibo: try just "." instead of "^."
10:55:40 <cabbibo> @chaosmasttter ya I had tried that and it gives me a type error of :         Couldn't match expected type ‘(Line -> Identity Line) -> World -> Identity World’   with actual type ‘Line’
10:55:40 <lambdabot> Unknown command, try @list
10:56:37 <Zemyla> Wow. "If you think you know what you are doing, use 'unsafePerformIO'. If you are sure you know what you are doing, use 'unsafeDupablePerformIO'. If you enjoy sharing an address space with a malevolent agent of chaos, try 'accursedUnutterablePerformIO'."
11:04:16 <EvanR> AUPIO is pretty handy
11:04:26 <EvanR> NOT
11:09:26 <mmakowski> I've asked a question on SO yesterday: http://stackoverflow.com/questions/33063853/haskell-function-returning-existential-type, and from responses such as "evidently you thought that types somehow work differently" and "someone who is obviously a beginner" I infer that I got something fundamentally wrong about Haskell type system, but I struggle to understand what it was
11:09:34 <mmakowski> would anyone here be willing to help?
11:09:46 <mmakowski> (in understanding why it was a silly question to ask)
11:10:25 <glguy> Wrap -> D a -- This type says that the caller gets to pick the return type
11:11:07 <glguy> so it's not going to be possible to use the value wrapped inside "Wrap" as the result, it might not be the type the caller picked
11:11:49 <EvanR> unwrap should work for any a at all
11:11:57 <EvanR> Wrap -> D Int should always work 
11:11:59 <EvanR> but it cant
11:12:08 <EvanR> Wrap might not be wrapping an Int
11:12:30 <mmakowski> ok, so the obviously wrong "example" was misleading
11:13:01 <mmakowski> What I was really after was expressing the pseudo-signature `f :: T -> (exists a. U a)` in real Haskell
11:13:06 * hackagebot pandoc-crossref 0.1.5.5 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.1.5.5 (lierdakil)
11:13:26 <shachaf> GHC doesn't have first-class existential types. So you have to use a wrapper like Wrap to express the existential directly.
11:14:04 <EvanR> so you dont need the D
11:14:09 <mmakowski> ok, I suppose that's what I was asking for -- clearly my question-asking skills need working on :-)
11:14:13 <mmakowski> thanks!
11:14:18 <shachaf> The unsafeCoerce answer is pretty unhelpful.
11:15:00 <shachaf> mmakowski: n.m.'s answer does give you an alternative encoding for existentials.
11:15:12 <shachaf> But you still have to encode them, one way or another.
11:15:21 <mmakowski> shachaf: yes, I concluded this is the best I can get
11:16:07 <EvanR> you can think of Wrap as an abstract data type providing the same smoke screen as an existential type
11:18:27 <ggole> The answer suggests that such wrapping is bad, but how about something like data Wrap f = forall a . Wrap (f a)
11:18:35 <ggole> eg, hiding the parameter of a GADT
11:23:06 * hackagebot sbp 0.51.1 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-0.51.1 (mookerji)
11:25:05 <Zemyla> ggole: You can't hide the parameter, then somehow get it out again.
11:25:17 <ezyang> Wrapping unwrapping for State monad is a chore and I wish I could define an instance without it 
11:25:21 <Zemyla> Not without something like a Typeable constraint.
11:25:45 <c_wraith> ggole: that's not so bad if the GADT always allows you to get the type by matching it. (ie, all constructors give you enough info) 
11:26:08 <EvanR> why is Wrap bad?
11:26:17 <ggole> GADT matching (on f) should be able to yield the parameter again
11:26:31 <c_wraith> Zemyla: matching on a GADT actually does give you type info back. 
11:26:33 <ggole> Where that's useful, anyway
11:26:38 <obadz> If I have a type of kind * -> *, can I instanciate a typeclass with a constraint on the argument of a type?
11:27:12 <obadz> i.e. something like instance Storable a => Functor Vector where ...
11:27:13 <c_wraith> obadz: no. 
11:27:21 <obadz> c_wraith: what's the fundamental reason?
11:27:38 <EvanR> a doesn't appear anywhere in the body...
11:28:19 <obadz> EvanR: does that have deep consequences?
11:28:21 <EvanR> Vector isn't already a functor?
11:28:26 <c_wraith> obadz: it would reduce your ability to reason over the types. 
11:28:31 <EvanR> obadz: well how would it even know what youre talking about
11:28:40 <obadz> EvanR: not the one in hmatrix
11:28:49 <c_wraith> EvanR: well, not the storable versions. 
11:29:06 <EvanR> makes sense for the same reason Set isnt a functor
11:29:27 <EvanR> obadz: hmmm... i like linear when i tried it
11:29:29 <obadz> I thouht Set wasn't a functor because fmap f . fmap g != fmap (f. g)
11:29:42 <obadz> that's not the case for Vector
11:29:43 <EvanR> well, i think that would work
11:29:57 <EvanR> but its because Sets require Ord constraint on the values
11:30:15 <EvanR> storable vectors require storable on the values
11:30:21 <ggole> It wouldn't work because transforming the elements of a set might produce the same value, which would be uniqued away
11:30:49 <EvanR> i was told functor could work for set if it wasnt for the constraint, so lets check
11:31:01 <davean> ggole: which step they're uniqued away at doesn't matter though
11:31:11 <ggole> At least, that's what I think the problem is - although maybe Functor doesn't have to preserve "shape" in that way?
11:31:30 <EvanR> fmap even {1, 2, 3, 4} = {True, False}
11:31:35 <c_wraith> obadz: you get guarantees about behavior based on types. The fact that a and b aren't part of the Functor definition means that fmap can't have its behavior change based on them. That's what you'd los…
11:31:36 <c_wraith> …e. 
11:31:41 <EvanR> fmap (+1) {1, 2, 3, 4} = {2, 3, 4, 5}
11:32:14 <EvanR> fmap (even . (+1)) {2,4} = {False}
11:32:16 <ggole> Hmm, if that's allowed it seems I have been assuming more about Functor that I should be.
11:32:18 <EvanR> i messed that up
11:32:47 <EvanR> ggole: the cosmic gotcha is that Set's implementation requires comparing the values
11:32:48 <ggole> *than
11:32:57 <EvanR> so you couldnt implement this behavior for any type
11:33:43 <ggole> Right, you'd need another constraint
11:33:50 <EvanR> another?
11:34:12 <EvanR> oh, on the definition of Functor
11:34:32 <EvanR> youd need two, because Set wants Ord and storable vector wants Storable ;)
11:34:37 <EvanR> and you just broke the abstraction
11:34:47 <ggole> Mmm.
11:35:43 <EvanR> in the end, you basically want to use a custom map for Set
11:35:52 <EvanR> its wont be polymorphic, because its cant be
11:36:27 <nitrix> :t {1,2}
11:36:29 <lambdabot> parse error on input ‘{’
11:36:54 <nitrix> EvanR is doing sorcery!
11:37:42 <EvanR> syntax {} = S.empty
11:38:06 <EvanR> and uh...
11:38:27 <nitrix> Does Haskell let you introduce additional syntax?
11:38:32 <EvanR> no ;)
11:39:35 <Zemyla> EvanR: Or use a GADT.
11:39:45 <EvanR> syntax {xs@(sepBy ',')} = S.fromList xs
11:40:00 <Zemyla> And explicitly use a function like order :: (Ord a) => Set a -> Set a.
11:40:02 <ggole> Hmm, there's a (a -> b) -> Set a -> Set b in Data.Set: I guess it just copies the nodes and assumes that ordering is retained
11:40:37 <EvanR> it cant do that, you cant have duplicate keys
11:40:55 <EvanR> and ordering is definitely not guaranteed to be the same
11:41:13 <ggole> "mapMonotonic f s == map f s, but works only when f is monotonic. The precondition is not checked."
11:41:14 <EvanR> Zemyla: use a GADT to represent the set?
11:41:39 <EvanR> ggole: for speed!!!
11:41:46 <Zemyla> Yeah. data MSet a where { SOrd :: (Ord a) => Set a -> MSet a; SAny :: Seq a -> MSet a }
11:41:57 <ggole> And of course you're right about uniqueness.
11:41:58 <EvanR> ramp it up into high gear like dale earnhardt
11:42:51 <Zemyla> I kind of wish there was an implementation of Set where minView and maxView were O(1) so I didn't have to figure out how to do everything as a fold or toList.
11:42:53 <EvanR> Zemyla: ok so that cant be made a functor either
11:43:19 <EvanR> if took out the SAny then
11:43:43 <shachaf> O(log n) is O(1)
11:44:45 <statusfailed> Are there any nice examples of code using the amazonka library? Specifically the DynamoDB stuff
11:45:22 <statusfailed> oh just found the github examples heh
11:45:44 <johnw> shachaf: is that true?
11:45:49 <johnw> shachaf: http://stackoverflow.com/questions/1491795/olog-n-o1-why-not
11:45:52 <shachaf> It's not technically true.
11:46:47 <EvanR> its practically true
11:47:01 <EvanR> like the voltage on a diode never gets much over 0.7V ;)
11:47:41 <statusfailed> MagicSmokeException
11:47:45 <magneticduck> uh, what's the most haskell-y way to construct a function (a -> m Bool) -> [a] -> m a ?
11:47:51 <magneticduck> essentially a monadic find
11:47:56 <magneticduck> I can't find anything on hayoo
11:48:03 <statusfailed> sounds like filterM
11:48:04 <statusfailed> a bit.
11:48:16 <magneticduck> yeahh
11:48:28 <statusfailed> fmap head . filterM f ?
11:48:32 <EvanR> @hoogle Monad m => (a -> m Bool) -> [a] -> m a
11:48:34 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
11:48:34 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
11:48:34 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
11:49:03 <magneticduck> anyway, I can apply this to a huge list and expect there to be little memory issues?
11:49:08 <magneticduck> like 5000 elements
11:49:14 <statusfailed> magneticduck: depends, probably no
11:49:17 <EvanR> firstM :: Monad m => (a -> m Bool) -> [a] -> m (Maybe a)
11:49:17 <statusfailed> is m ~ () ?
11:49:18 <statusfailed> IO *
11:49:27 <statusfailed> how did I type "()" :|
11:49:27 <magneticduck> yes
11:49:30 <statusfailed> then no
11:49:31 <EvanR> magneticduck: i always look in monad-loops to see what people decided to call these things
11:49:46 <EvanR> firstM matches what you wanted
11:49:48 <magneticduck> yeah
11:50:09 <magneticduck> can I apply it to a 5000 element list?
11:50:10 <magneticduck> x)
11:50:12 <magneticduck> with m ~ IO
11:50:16 <EvanR> why not
11:50:20 <jophish> What does a green version mean on hackage now?
11:50:23 <magneticduck> hm okay
11:50:29 <shachaf> O(inverse ackemann(n)) is also not O(1)
11:50:42 <magneticduck> btw I like this new syntax highlighting on hackage 
11:50:44 <magneticduck> http://hackage.haskell.org/package/base-4.8.1.0/docs/src/Control.Monad.html#filterM
11:51:16 <kadoban> jophish: "green version" ?
11:51:24 <magneticduck> it means it's good for the environment
11:51:43 <jophish> kadoban: here for example: 
11:51:44 <jophish> https://hackage.haskell.org/package/ghc-mod
11:52:09 <jophish> ah: https://hackage.haskell.org/package/ghc-mod/preferred
11:52:51 <kadoban> jophish: Huh, never seen that before.
11:52:54 <kadoban> Interesting
11:53:21 <begriffs> What is the best alternative Prelude? Any consensus?
11:53:22 <behzad> @hoogle (a -> b -> b) -> b -> [a] -> b
11:53:22 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
11:53:23 <lambdabot> Data.List foldr :: (a -> b -> b) -> b -> [a] -> b
11:53:23 <lambdabot> Prelude scanr :: (a -> b -> b) -> b -> [a] -> [b]
11:53:50 <behzad> @hoogle getLine
11:53:50 <lambdabot> Prelude getLine :: IO String
11:53:50 <lambdabot> System.IO getLine :: IO String
11:53:50 <lambdabot> Data.ByteString getLine :: IO ByteString
11:54:43 <EvanR> magneticduck: firstM consumes the list as it goes, but the visitor can do whatever it wants with the values. see the source on hackage. 5000 isnt really that much, but to avoid space issues specifically for the list spine you want to generate it lazily
11:55:17 <EvanR> or not, 5000 isnt that much
11:55:27 <EvanR> infinite is a lot ;)
11:56:20 <EvanR> as long as nothing else holds on to that 5000 list, itll be collected
11:56:34 <magneticduck> EvanR: a million dollars isn't cool. you know what's cool? a lazily evaluated non-terminating tree of chunks, each containing one dollar
11:56:55 <EvanR> i thought about that yesterday, if i had a penny a second
11:57:07 <EvanR> thatd be 24/7 36 dollars an hour ;)
11:58:04 <EvanR> as for my infinite tree of foo, i can only get to about 57000 with my new traversal before it craps out :(
11:58:08 * hackagebot RSA 2.2.0 - Implementation of RSA, using the padding schemes of PKCS#1 v2.1.  https://hackage.haskell.org/package/RSA-2.2.0 (AdamWick)
11:58:39 <jophish> begriffs: I think subhask is pretty fancy
12:00:36 <begriffs> jophish: that is pretty cool.
12:01:28 <begriffs> More specifics about what I'm looking for: a prelude that exposes common things like Data.Maybe and Control.Applicative, plus overrides things like `fail` to accept Text rather than String
12:03:39 <jophish> begriffs: you might want to wait a couple of years until everyone uses backpacks :)
12:05:41 <ChristianS> begriffs: Applicative is already defined in the Prelude as per ghc 7.10, and Maybe always was
12:06:31 <begriffs> ChristianS: including stuff like catMaybes?
12:06:47 <kadoban> Well, some stuff from Data.Maybe isn't, only part.
12:07:34 <nitrix> begriffs: What prevents you from creating your own module and re-export all the things you want to work?
12:08:47 <begriffs> nitrix: nothing really. Thought there might be something convenient and opinionated on Hackage that I could just use.
12:09:32 <nitrix> I doubt you'll find something that matches 100% your personal choices; it'll always have compromises to make few people happy.
12:09:42 <nitrix> That's just common sense.
12:10:48 <EvanR> how would you change fail to take a Text 
12:12:46 <quicksilver> I don't think there *are* much in the way of opinionated-preludes on hackage
12:12:51 <quicksilver> there is a classy-prelude
12:12:58 <quicksilver> but that's a different kind of experiment.
12:13:08 <hpc> acme-php is an alternate prelude
12:13:32 <quicksilver> we lack the re-export+rename qualifed you'd like to make opinionated module re-exports convenient.
12:13:44 <tdammers> I guess you could say that acme-php is opinionated
12:14:04 <begriffs> EvanR: fail' = fail . unpack   but looking into it more it seems fail just calls error, which raises an ErrorCall, which takes String. Some hypothetical prelude might change this stuff to use Text everywhere.
12:14:18 <davean> Why are we making "fail" take Text instead of just ditching that monster completely?
12:14:28 <exio4> davean: fail doesn't call error
12:14:31 <EvanR> what fail does depends on the Monad
12:14:32 <exio4> er
12:14:34 <hvr> begriffs: fyi, https://hackage.haskell.org/package/base-noprelude makes it easy to bould your own prelude
12:14:35 <exio4> begriffs: *
12:14:38 <begriffs> davean: because I don't know any better. :) What's the better way?
12:14:42 <kadoban> If you're going to fix 'fail', it seems like making it able to take Text is like, the last possible thing I'd think of.
12:14:50 <davean> exio4: Yes?
12:14:52 <kadoban> "Don't use it" comes to mind first.
12:15:01 <davean> Yah, "fail" is a disaster
12:15:09 <Cale> begriffs: uhh, why? If you're going to make a change to fail, you'd probably just remove it. Its inclusion was a mistake in the first place.
12:15:16 <davean> It has no business there and its a problem
12:15:17 <exio4> davean: like a tab-fail :P 
12:15:30 <davean> exio4: oh, that makes more sense
12:15:37 <begriffs> The context is that my program begins by attempting to connect to a database. It checks an Either for problems and then I'd like the program to die with a message.
12:15:49 <EvanR> begriffs: in IO you can just throw an exception
12:15:49 <davean> begriffs: throw an exception?
12:15:51 <EvanR> or use error
12:15:57 <EvanR> actually throw an exception
12:16:01 <Cale> begriffs: throwIO
12:17:18 <Hafydd> Is there a proposed solution to handling pattern match failure in do-expressions that doesn't use fail?
12:17:21 <EvanR> fail = throwIO . userError in IO?
12:17:54 <Cale> Hafydd: Well, the real proposal at this point is that fail gets moved to its own class.
12:18:42 <begriffs> OK, I'll throw an exception that sounds straightforward. In fact my errors are being prefixed with "user error" which is annoying and consistent with your description of how fail works in IO.
12:19:08 <Hafydd> And if the type inferred for the do expression is an instance of that class, then its fail is used?
12:19:53 <Hafydd> That seems like it might interact a but uncertainly with polymorphism, but maybe it would work.
12:20:04 <Hafydd> *a bit
12:20:21 <Cale> Hafydd: But in the past, pattern match failure in do-expressions which contained failable patterns would use mzero, which would generate a MonadZero constraint since mzero was in its own class.
12:20:39 <Hafydd> Oh. That's reasonable.
12:20:51 <Hafydd> One shouldn't use failable patterns that expect to fail, anyway.
12:21:10 <Hafydd> Er... that expect to fail and not be handled.
12:21:16 <Cale> Well, in stuff like the list monad it's quite useful
12:21:25 <Cale> Where you have an appropriate mzero
12:21:25 <EvanR> wait, so do isnt exactly syntax sugar?
12:21:32 <Cale> EvanR: hm?
12:21:34 <EvanR> it has this failable feature?
12:21:39 <Hafydd> Yes, I agree. It's also useful in Maybe, I've found.
12:21:53 <Cale> EvanR: This is part of the desugaring process.
12:22:04 <Hafydd> EvanR: it is sugar. The handling of pattern match failure is defined in the Report.
12:22:11 <EvanR> or can you trigger the pattern fail thing using >>=
12:22:24 <EvanR> and lambdas
12:22:47 <Hafydd> You can trigger it by invoking 'fail' or having a do-notation binding that doesn't match.
12:22:52 <srhb> EvanR: \x -> case x of _ -> ... fail ... ?
12:23:02 <EvanR> oh fail is inserted everywhere
12:23:46 <EvanR> thats so annoying because patterns can fail in other places and have no catch all case
12:24:02 <EvanR> and something else has to happen
12:25:11 <EvanR> does anything use fail productively? parsers?
12:25:43 <srhb> EvanR: Cale mentioned the list monad.
12:25:45 <Hafydd> > return (fail "") :: Maybe Maybe ()
12:25:47 <lambdabot>      ‘Maybe’ is applied to too many type arguments
12:25:47 <lambdabot>      In an expression type signature: Maybe Maybe ()
12:25:47 <lambdabot>      In the expression: return (fail "") :: Maybe Maybe ()
12:25:53 <Hafydd> > return (fail "") :: Maybe (Maybe ())
12:25:55 <lambdabot>  Just Nothing
12:26:05 <Hafydd> That uses it unproductively.
12:26:31 <EvanR> ok
12:26:36 <Cale> EvanR: I'm not sure what you mean by productively
12:26:54 <EvanR> to do anything, in a way people use
12:27:01 <EvanR> that matters ;)
12:27:08 <srhb> Everything with a sensible mzero, I guess. :)
12:27:21 <EvanR> so its common for people to use this instead of mzero?
12:28:14 <Cale> > do (x:xs) <- tails [1..4]; y <- xs; return (x,y)
12:28:16 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
12:31:05 <Cale> ^^ it's nice to be able to match patterns like that to do things like that, or filtering out Nothings
12:31:22 <Cale> do Just x <- ...; ...
12:32:11 <exio4> catMaybes xs = [ x | Just x <- xs ] -- a nice definition there!
12:32:12 <nitrix> What, you can pattern match "bind" ?
12:33:06 <nitrix> Oh makes sense. I guess I'm still confused about the List monad.
12:34:40 <Cale> do p <- x; <stmts>  will be translated to  let { ok p = do <stmts>; ok _ = fail "some message" } in x >>= ok   where ok is a fresh variable.
12:34:48 <Cale> when p is a pattern that may fail
12:34:55 <Cale> nitrix: ^^
12:37:26 <EvanR> Cale: i know youve show this before and i never think to use it ;)
12:37:47 <EvanR> but that particular case of filtering out Nothings is really handy
12:37:55 <Cale> In the days of Haskell 1.4, that just used mzero instead of fail
12:37:59 <Cale> yeah
12:38:22 <Cale> Also, to be honest, sometimes it's really nice that fail produces a custom error message with the line number in it
12:39:00 <Cale> You can use pattern match failure in IO for instance as a handy way to get good errors in "this shouldn't happen" sort of cases
12:39:42 <EvanR> but using a case doesnt do that
12:39:43 <Cale> So, there is some upside to these proposals which keep fail around but put it in its own type class.
12:40:16 <exio4> class MonadZero m => MonadFail m ? 
12:40:23 <exio4> :P
12:40:35 <Cale> Well, using case and not handling the failure also would produce a message with a line number
12:40:46 <Cale> But using e.g. fromJust, would be worse
12:41:10 <Cale> If that fails, you get a bad error which doesn't tell you from where the failure happened.
12:41:16 <Cale> > fromJust Nothing
12:41:18 <lambdabot>  *Exception: Maybe.fromJust: Nothing
12:42:35 <EvanR> i just tried it, a case with no case for the failure gives a line number but an awful message
12:43:11 <EvanR> lol and using error explicitly in the failure case gives no information
12:43:59 <EvanR> moral of the story dont use complete cases
12:46:25 <Cale> EvanR: Well, sometimes it's okay for the error message to be awful if it's something you think shouldn't be able to happen, as long as that message provides you enough information to get you started working out what went wrong.
12:46:32 <nitrix> Could someone take a bit of their time to explain why: do x <- [1..4]; y <- [5..8]; return (x,y)   is distributive?
12:46:46 <Cale> nitrix: Distributive in which sense?
12:46:55 <nitrix> > do x <- [1..4]; y <- [5..8]; return (x,y)
12:46:57 <lambdabot>  [(1,5),(1,6),(1,7),(1,8),(2,5),(2,6),(2,7),(2,8),(3,5),(3,6),(3,7),(3,8),(4,...
12:47:20 <nitrix> Cale: Each elements of the first list being paired with elements of the second list.
12:47:45 <Cale> Well, x <- [1..4] pretty much means "select x from the list [1..4] in all possible ways"
12:47:51 <nitrix> I just don't grasp the [] Monad, I even looked at the base implementation but it's not enough.
12:48:09 <Cale> The way it works is that xs >>= f is concat (map f xs)
12:48:11 <nitrix> It's the "in all possible ways" that I don't understand.
12:48:23 <nitrix> What in the List monad implementation makes this possible?
12:48:32 <Cale> The definition of (>>=)
12:48:58 <Cale> So, here, the rest of the do block is  \x -> do { y <- [5..8]; return (x,y) }
12:49:06 <Cale> we map this function over the list  [1..4]
12:49:16 <Cale> and then concatenate the results
12:49:17 <nitrix> xs >>= f             = [y | x <- xs, y <- f x]
12:49:18 <tdammers> :t (>>=)
12:49:19 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:49:48 <tdammers> so for the list monad: [a] -> (a -> [b]) -> [b]
12:49:58 <EvanR> the x <- [1..4] corresponds to the [1..4] >>= (\x -> ...
12:50:00 <tdammers> meditate on that, and consider what such a function could possibly do
12:50:46 <Kristler> I've always wondered, how do you read ">>=" out loud?
12:50:53 <EvanR> dont try!
12:50:58 <nitrix> EvanR: Oh I think it just clicked.
12:51:23 <obadz> Kristler: bind ?
12:51:33 <nitrix> obadz: <- is bind.
12:51:50 <EvanR> >>= is called bind, by some people
12:52:02 <EvanR> theres so many operators just give up trying to name them
12:52:03 <Cale> (>>=) is pronounced bind, and written (>>=) :)
12:52:05 <obadz> well that's what I say when I read it "out loud"
12:52:08 <johnw> <- desugars to >>=
12:52:36 <EvanR> unless we have a intercal-style name generator
12:52:42 <EvanR> <> is rhombus
12:53:04 <tdammers> <- desugars to half of an application of >>=
12:53:06 <EvanR> >>> is chevrons
12:53:39 <obadz> :t concatMap
12:53:40 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
12:53:48 <tdammers> that said, Haskell should have done as INTERCAL: explicitly assigning new, better names to all non-alphanumeric ASCII characters (or EBCDIC, as the case may be)
12:54:11 <obadz> (>>=) = flip concatMap..
12:54:14 <tdammers> oh wait, intercal has been mentioned already
12:55:39 <EvanR> :: is square-pair
12:56:26 <tdammers> I like ' (sparks) and " (rabbit-ears)
12:57:30 <EvanR> no one has mentioned .: in a while maybe this fell out of favor
12:57:49 <nitrix> ^^ cat ears.
13:01:11 <EvanR> ** grue
13:09:24 <mutantmell> I thought <> was diamond
13:12:59 <EvanR> thats totally different from a rhombus
13:13:02 <EvanR> i swear
13:47:10 <medfly> hellllo
13:50:39 <darkroom> Hey this is kinda a stuipd question and i wish i could add it in the java freenode but the java freenode is invite only so maybe someone could help mebut if i have a collection like this list<E> but i have a function that only works when E = Double how do I tell the function the element needs to be a double
13:50:55 <darkroom> I am trying to impliment a haskell verison of lists
13:51:24 <darkroom> And i made a folding function that has alot of type variables but I dont know how to get rid of the type variables
13:53:15 <nolrai66> How hard would it be to make a boxes with lines editor in Haskel or related languages, and what would the easiest way to do so be?
13:53:21 <Cale> darkroom: list<Double> ?
13:53:29 <bb010g> How would you do something like 1.5 from http://mercurylang.org/documentation/papers/book.pdf in Haskell?
13:53:44 <Cale> nolrai66: Boxes with lines editor?
13:53:46 <darkroom> Cale: yes but what happens when the function is using this for the list 
13:54:09 <darkroom> Cale: i could set the function up like this public Double sum(List<Double> list)
13:54:21 <darkroom> Cale: but i want to use this and have it be public Double sum()
13:54:29 <Cale> bb010g: Probably use the list monad (or another nondeterminism monad) a bunch
13:54:52 <medfly> darkroom: join ##java not #java
13:55:15 <darkroom> medfly: thanks :) felt bad about not posting haskell stuff in here 
13:55:17 <exio4> ##java is +r 
13:55:29 <exio4> he needs to register to freenode first
13:55:55 <nolrai66> Cale: Like a flowchart editor, or the javascript front end of the "incredible proving machine".
13:56:50 <Cale> nolrai66: I see. Well, the answer is probably "nearly as hard as in any other language". You might get good use out of the fact that the diagrams library exists.
13:57:37 <bb010g> Cale: And you'd use Alternative with whatever the Alternative guard is for the conditions?
13:58:56 <bb010g> Oh. Control.Monad.guard is Alternative now, not MonadPlus. Shouldn't that be a re-export from Control.Applicative?
13:59:32 <Cale> bb010g: It wouldn't really matter which class it belongs to, because you'd be using it at a specific type, but yeah, guard.
14:00:17 <darkroom>  /msg NickServ VERIFY REGISTER darkroom otzmnhojwnnf
14:00:22 <Cale> oh, also
14:00:51 <nolrai66> Cale: Yeah, Diagrams looks useful.
14:00:54 <Cale> @let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
14:00:55 <lambdabot>  Defined.
14:00:56 <Sonolin> might want to choose another password ;)
14:01:02 <Cale> > select [1..4]
14:01:04 <lambdabot>  [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3])]
14:01:10 <Cale> ^^ this function will be useful
14:01:14 <glguy> That was just the verification code, shouldn't matter so much
14:01:30 <Sonolin> oh true
14:01:47 <Cale> @let digits = [0..9]
14:01:49 <lambdabot>  Defined.
14:02:23 <tdammers> and that is why you script your IRC login
14:04:48 <Like> enumFromTo :: Int -> Int -> [Int]
14:04:48 <Like>  
14:04:49 <Like> -- enumFromTo 1 5 = [1,2,3,4,5]
14:04:59 <Like> how i do it
14:06:24 <Cale> Like: Perhaps start with the case:   enumFromTo x y | x > y = ...
14:06:46 <Cale> Like: the list will be empty in that case
14:06:51 <Cale> right?
14:07:14 <Like> yeah
14:08:03 <Cale> Like: and otherwise, we know that x <= y, so we know what the first element of our resulting list should be: it should be x
14:08:25 <Cale> So we have:
14:08:26 <Like> yeah cale
14:08:34 <Cale> enumFromTo x y | x > y = []
14:08:42 <Cale>                | otherwise = x : ...
14:08:49 <Cale> What will the rest of the list be?
14:09:47 <Like> the numbers between x to y
14:09:51 <Like> last y
14:10:15 <Cale> Well, certainly it won't have x
14:10:25 <Like> ofc 
14:10:42 <Cale> So it'll be the numbers from x+1 to y
14:10:46 <Cale> inclusive
14:11:00 <Cale> Thankfully, we have a function which does this already, it's the one we happen to be writing
14:11:33 <Cale> So the rest of the list is  enumFromTo (x+1) y
14:12:10 <Like> thx man
14:19:53 <Like> enumFromThenTo :: Int -> Int
14:19:53 <Like> -> Int -> [Int]
14:20:15 <Like> enumFromTo 1 3 10 = [1,3,5,7,9]
14:20:30 <mniip> missing a Then
14:21:24 <Like> yeah 
14:26:26 <NemesisD> i've got a typeclass class SomeClass, and types Foo and Bar that implement it. I've got a type data FooBar = F Foo | B Bar, is there anything with possibly generics that could save me the work of implementing SomeClass for FooBar?
14:26:57 <NemesisD> would i have to go to SomeClass and provide a default implementation that worked on generics?
14:27:45 <samgd> Would someone be able to point me in the right direction for string escaping? Text.Regex provides `subRegex' that claims: "In the replacement string, "\1" refers to the first substring;" etc... but \1 escapes to \SOH. :-(
14:28:02 <lpaste> Cale pasted “dog + ant = cat” at http://lpaste.net/142858
14:28:14 * hackagebot reflex-transformers 0.1 - Collections and switchable Monad transformers for Reflex  https://hackage.haskell.org/package/reflex-transformers-0.1 (saulzar)
14:28:31 <Cale> ... where is bb010g
14:28:41 <tdammers> samgd: what kind of escaping do you need? why do you think you need regular expressions for it?
14:29:53 <samgd> Grabbing n tabs, turning into n + 1 tabs where n >= 1
14:30:05 <Cale> @tell bb010g Here's analogous Haskell code for the DOG + ANT = CAT thing for you: http://lpaste.net/142858
14:30:05 <lambdabot> Consider it noted.
14:31:09 <tdammers> samgd: you don't need regular expressions for that
14:31:52 <samgd> Yes, but it seemed the most logical way
14:37:20 <lpaste> tdammers pasted “n + 1 tabs” at http://lpaste.net/142859
14:37:25 <shlevy> Is there a well-known name for a function that takes an x:xs and a y and returns x:y:xs?
14:37:45 <tdammers> samgd: ^ something like this maybe?
14:38:19 <tdammers> note that it handles runs of tabs anywhere within the string; if you want to capture only at the beginning, it becomes simpler
14:38:32 <kadoban> shlevy: If it has a name, it probably comes from 'forth' or some stack language.
14:38:34 <MarcelineVQ> shlevy: http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-List.html#v:intersperse ?
14:38:59 <shlevy> MarcelineVQ: Sort of, except only once :D
14:39:27 <samgd> Nice, tdammers, cheers.  Shame about the regex documentation but solution found :-)
14:40:06 <tdammers> fwiw, regex has a bit of a smell to it in haskell land
14:40:25 <tdammers> the general notion is that regular expressions are not an elegant approach, and unnecessarily specific
14:41:06 <Cale> shlevy: there's no well-known name for that
14:41:16 <shlevy> OK, just wanted to check
14:59:10 <sm> IMHO, regular expressions are a proven pragmatic tool and haskell's ongoing poor support for them and attempts to wave them away is pretty embarassing by now
14:59:34 <bitemyapp> sm: I take it you don't like regex-applicative?
14:59:40 <bitemyapp> sm: or the PCRE ones?
15:00:38 <sm> bitemyapp: that's a jump.. hopefully we would agree that doing regex stuff in haskell is far harder/more confusing/less documented than in other languages
15:00:56 <sm> pcre requires c libs, so causes portability issues
15:01:41 <sm> regex-tdfa is my go-to at the moment
15:03:03 <bitemyapp> sm: good to know.
15:03:09 <sm> does regex-applicative support ERE-ish regex strings as in other langs ? I can't tell
15:03:10 <haskell355> Is there a way to access the cabal version of my executable at runtime 
15:03:11 <Axman6> regular expressions are a poor tool in almost all circumstances - parser combinators are a strict superset of what is capable with them, and infinitely more maintainable. There is basically no rason to use them in haskell - regexes should only ever be used for quick one off hacks/tasks such as find and replace in text editors
15:03:14 <bitemyapp> sm: I avoid using regex when I can, so I didn't really know what was good.
15:03:34 <bitemyapp> Axman6: attoparsec can be really fast if you avoid the slow stuff, so I haven't had cause to use regex.
15:03:38 <Axman6> I don't think it's at all embarrassing the difficulty involved in using them in haskell
15:03:56 <bitemyapp> I don't know why somebody would want to bring all the ways they already did things to Haskell.
15:04:07 <bitemyapp> stuff like having nice, efficient parser combinators is part of the deal.
15:04:27 <sm> bitemyapp: many of the haskel regex libs don't support crazy far-out stuff like.. regex substitution
15:04:45 <Axman6> sm: because no one wants to use regexes
15:05:03 <sm> that is obviously wrong :)
15:05:03 <Axman6> they are simply not a tool people should be using in software
15:05:24 <saulzar> Regex syntax and it's many variations always annoyed the heck out of me anyway, so I was fairly happy that Haskell went with another solution :)
15:05:25 <sm> and an example of what I'm talking about
15:06:31 <haskell355> Is it in the Distribution module ?
15:06:49 <hexagoxel> haskell355: be guided by the guide! praise https://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-the-package-version
15:06:57 <Axman6> "regular expressions are a proven pragmatic tool" is a statement I definitely cannot agree with, they have been proven to be completely unpragmatic because they cannot be maintained
15:07:31 <glguy> Maybe you're writing an IRC client and you wanted users to be able to search the chat log with a regexp?
15:07:41 <glguy> parser combinators don't seem terribly superior
15:08:05 <Axman6> sure, that's when a regex library is useful, but regular expressions themselves aren't something you should have in your software imo
15:08:12 <haskell355> Hexagonal: you're awesome, thanks
15:08:17 <phaazon> hey
15:08:26 * hackagebot grouped-list 0.1.1.0 - Grouped lists. Equal consecutive elements are grouped.  https://hackage.haskell.org/package/grouped-list-0.1.1.0 (DanielDiaz)
15:08:27 <phaazon> one nanosecond = 1e-9 seconds, right?
15:08:49 <Axman6> like I said, they should be for one off search and replace type tasks
15:09:20 <bennofs> With 'stack', can I use stack just for the multi-project feature, without using it's sandbox functionality? I already have ways to setup an environment with just the right packages installed, but I find multi-package projects annoying to work with with plain cabal
15:09:28 <exio4> phaazon: yes
15:09:29 <sm> regexes are a highly popular and useful DSL. Non-haskell-coding Users like them.
15:09:46 <Axman6> sm: because they don't know better/don't have better tools
15:09:48 <bennofs> So, in my case, I would already have all dependencies installed globally. Will stack use them?
15:10:08 <exio4> wait, I don't know 
15:10:12 <phaazon> my gosh
15:10:16 <bitemyapp> bennofs: I don't think Stack will use a pre-existing package-db without some serious finagling and I don't think it would be worth it.
15:10:19 <phaazon> my obj loader is fast as HELL
15:10:23 <Axman6> phaazon: wolfram alpha knows
15:10:25 <bitemyapp> bennofs: but it's probably hypothetically possible.
15:10:29 <phaazon> I load a 2MB obj file in 8ms
15:10:32 <phaazon> with attoparsec
15:10:32 <bitemyapp> phaazon: obj loader?
15:10:37 <phaazon> bitemyapp: yep, wavefront obj
15:10:46 <phaazon> wavefront, on hackage
15:10:49 <bitemyapp> phaazon: hrm, wow.
15:10:57 <bitemyapp> all hail attoparsec? :P
15:11:02 <phaazon> /home/phaazon/Desktop/quhydra.obj loaded in 0.0082s
15:11:02 <phaazon> vertices: 7818
15:11:02 <phaazon> tex coords: 0
15:11:02 <phaazon> normals: 15363
15:11:04 <phaazon> yeah!
15:11:07 <phaazon> definitely
15:11:12 <exio4> attoparsec is insane 
15:11:17 <phaazon> it is
15:11:28 <phaazon> I thought it’d be slow, but damn that’s awesome
15:11:36 <phaazon> I use DLists for my lexer
15:11:42 <phaazon> which is pretty fast then as well!
15:11:43 <mniip> considering it operates on raw arrays of words
15:11:45 <phaazon> I should profile 
15:12:08 <mniip> it's not too surprising
15:12:15 <phaazon> I should print the number of faces as well
15:12:46 <phaazon> /home/phaazon/Desktop/quhydra.obj loaded in 0.0074s
15:12:46 <phaazon> vertices: 7818
15:12:46 <phaazon> tex coords: 0
15:12:46 <phaazon> normals: 15363
15:12:46 <phaazon> faces: 46794
15:12:48 <phaazon> that’s just insane.
15:22:54 <sm> Gurkenglas_: I don't know how to use runEndo and foldMap in http://lpaste.net/142800 , feel free to show me
15:24:23 * hackagebot network-api-support 0.2.1 - Toolkit for building http client libraries over Network.Http.Conduit  https://hackage.haskell.org/package/network-api-support-0.2.1 (MarkHibberd)
15:34:11 <Clint> sm: combineJournalUpdates = liftM (appEndo . foldMap Endo) . sequence?
15:36:56 <sm> Clint: wow, thanks
15:39:59 <Nux__> Trying to get sdl installed still http://lpaste.net/142872
15:40:45 <lispy> Nux__: hi
15:40:52 <Nux__> hi lispy
15:40:54 <lispy> Nux__: Are you using msys2
15:40:59 <sm> Gurkenglas_ (Clint, lispy): that doesn't affect performance, but it's good to know about
15:41:12 <Nux__> I'm using cygwin so... maybe?
15:41:18 <lispy> Nux__: or, I should ask, how did you get the SDL2 C libraries installed?
15:41:38 <Nux__> lispy, I didn't get sdl2 installed
15:41:39 <Clint> sm: was it supposed to?
15:41:42 <lispy> Nux__: I think the memory leak you're seeing is caused by sequence, but I'm not certain.
15:41:57 <Nux__> lispy, memory leak?
15:42:01 <lispy> Gah, sorry
15:42:05 <lispy> Meant that for sm
15:42:08 <lispy> sm: ^^
15:42:25 <lispy> Nux__: okay, so which SDL version do you plan to use?
15:42:34 <lispy> Nux__: And you said you use cygwin to install it?
15:43:18 <lispy> Nux__: I ask because this is the hardest step on windows with anything that depneds on external libraries
15:43:23 <Nux__> lispy, I don't mind what version of SDL I use to begin with. I currently have http://www.libsdl.org/download-1.2.php
15:43:59 <Nux__> lispy, I'm using cygwin when executing the command 'cabal install sdl'
15:44:02 <lispy> Okay cool. I have more recent experience with SDL2. I used https://msys2.github.io/ to install it instead of cygwin, but cygwin should be able to do it too.
15:44:25 <sm> Clint: not necessarily, Gurkenglas_ suggested it was worth trying
15:44:37 <Clint> ah
15:44:46 <sm> I can't quite hold in my brain what it's doing but DOESN"T MATTER
15:44:59 <lispy> Nux__: Did you download SDL-devel-1.2.15-mingw32.tar.gz?
15:45:07 <Nux__> lispy, I have successfully written and compiled a c++ program that uses this SDL
15:45:24 <lispy> Okay, that's helpful to know
15:45:32 <Nux__> lispy, yes
15:45:58 <lispy> Nux__: So then, the next step is getting cabal to add the right path when building sdl. It needs to be pointed at the development version of sdl
15:46:30 <Nux__> lispy, and how do I do this?
15:46:57 <lispy> Nux__: two main ways: a) on the command line; b) in your global config
15:47:09 <lispy> Nux__: You need to set extra-lib-dirs
15:47:22 <lispy> And likely you need to also set extra-include-dirs
15:47:36 <lispy> Have you modified your cabal config before?
15:47:37 <Nux__> lispy, I'm guessing these aren't environment vars but cygwin specific. Is that right?
15:47:46 <lispy> Nux__: they are part of cabal
15:47:46 <Nux__> lispy, no
15:47:58 <Nux__> lispy, I didn't know that
15:48:21 <lispy> So you might just try, as a test, cabal install sdl --extra-lib-dirs="whatever the path should be" --extra-include-dirs="similar, but for the .h files"
15:49:24 <lispy> Once you find the right paths, then add them to to your cabal config. I think the path is usually something like, C:\Users\<username>\.cabal\config
15:49:46 <lispy> The line where the setting goes should be in the file, but commented out
15:51:52 <cloj_dev> is there a way to define an integer type in haskell such that an integer is either 0 or 1 + an int?
15:51:53 <Nux__> lispy, I tried the command you suggested and got: http://lpaste.net/142873
15:52:06 <cloj_dev> something like : data Int = 0 | Int + 1
15:52:35 <Nux__> lispy, please pay special attention to my paths which may be invalid
15:52:48 <Nux__> lispy, I forget which type of slash cygwin prefers
15:53:07 <Cale> cloj_dev: data Nat = Z | S Nat is a valid declaration
15:53:45 <Eduard_Munteanu> cloj_dev, data ZeroOrInt = Zero | SomeInt Int
15:53:56 <Cale> (it doesn't quite get you the integers, because you'd want some representation for negative values)
15:54:06 <cloj_dev> interesting
15:54:14 <cloj_dev> yes, I meant without negatives
15:54:57 <Nux__> lispy, well flipping all of the slashes in the paths didn't help
15:55:36 <Nux__> lispy, I notice the output there seems to be referring to an even older version of SDL
15:55:40 <lispy> Nux__: It's trying to run a configure script. I'm not sure if cabal passes extra-lib-dirs. It might help to use --verbose
15:56:16 <Nux__> lispy, I have tried to tackle this before and I do remember that people get caught out by some sort of configure file
15:56:43 <Nux__> lispy, I seem to remember the problem is particular to windows users
15:57:13 <greymalkin> Hackage seems to be crawling today?
15:57:46 <Nux__> lispy, with verbose: http://lpaste.net/142874
15:57:46 <lispy> Nux__: yes, that's fairly accurate
15:58:07 <bennofs> Can I have a closed data family in GHC?
15:58:44 <exio4> wouldn't that be a GADT?
15:58:47 <exio4> bennofs: ^ 
15:59:01 <Nux__> lispy, the world is learning of my directory structure :)
15:59:01 <lispy> Nux__: okay, it looks like that directory didn't make it to configure
15:59:16 <exio4> bennofs: most of the time I wanted a closed data family, I actually needed a GADT 
15:59:37 <Nux__> lispy, so now should I try the cabal config route?
16:02:11 <bennofs> exio4: well, I can't use GADTs since GHC can't {-# UNPACK #-} sum types
16:02:30 <exio4> can it unpack data families? o.O
16:02:45 <exio4> bennofs: also, is using a new kind for that a nice hack? :P 
16:02:51 <bennofs> exio4: well, at least it doesn't give a warning ....
16:02:57 <bennofs> exio4: just got that idea, yeah
16:03:06 <lispy> Nux__: Asking a friend, and he said you probably need to add sdl-config to your path
16:03:19 <lispy> Nux__: that's how the configure script for sdl finds the binaries
16:03:46 <Nux__> lispy, to my 'PATH' environment var?
16:04:40 <exio4> bennofs: you mean data A = A2 {-# UNPACK #-} !X | A2 {-# UNPACK -} !Y  ?
16:04:43 <Nux__> lispy, to the path I'm executing from?
16:04:47 <bennofs> exio4: any idea how I can check if it unpacked it?
16:05:02 <Nux__> lispy, I'm not sure what you mean
16:05:33 <exio4> bennofs: I don't, really :/
16:05:51 <lispy> Nux__: what happens now if you type sdl-config at the terminal?
16:06:09 <lpaste> bennofs pasted “Unpack data family” at http://lpaste.net/142875
16:06:10 <Nux__> -bash: sdl-config: command not found
16:06:10 <exio4> bennofs: anyway, what I posted should work
16:06:18 <Nux__> lispy, "-bash: sdl-config: command not found"
16:06:19 <exio4> given that X and Y have only one constructor
16:06:24 <bennofs> exio4: I meant unpacking like what I pasted :)
16:06:44 <lispy> Nux__: Was that tool part of the stuff you instlled under C:\SDL-1.2.15?
16:06:49 <exio4> oh, didn't see lpaste's link, hehe
16:07:13 <Nux__> lispy, what tool? is sdl-config a tool?
16:07:22 <bennofs> basically, I'm trying to build an unboxed version of largeword, possibly avoiding TH
16:07:25 <lispy> Nux__: if so, you'll want to edit PATH so that the directory with sdl-config.exe is in your path. Like, export PATH=$PATH:C:\SDL-1.2.15\bin
16:07:44 <lispy> Nux__: yeah, it's a tool that sdl should provide
16:07:44 <exio4> bennofs: makes perfect sense, I don't think a GADT makes sense at all there
16:08:47 <Nux__> lispy there's a 2 KB file called 'sdl-config' in the bin folder
16:08:52 <lispy> Nux__: err, that example doesn't exactly work because C:...hmm...I'm not sure what to use with cygwin
16:08:58 <bennofs> exio4: well, it would make sense, but GHC would have to clever enough to realize that unpacking a GADT is ok if only a single constructor can ever match. would require lots of magic
16:09:24 <lispy> Nux__: right, so you need to set things up so that when you type 'sdl-config' at the terminal that program gets run
16:09:28 <bennofs> exio4: ah, "Ignoring unusable UNPACK pragma ..." :/
16:09:59 <exio4> we need inductive type families! ... 
16:10:45 <lispy> Nux__: maybe the path should be /cygdrive/c or so?
16:10:58 <bennofs> So I guess I'll need to write TH...
16:11:37 <lispy> Nux__: afk for a bit. Sorry this is complicated to setup :(
16:11:56 <Nux__> lispy, no worries thanks for your help
16:12:37 <dersquisher> hey, so if I'm in ghci and I've imported a bunch of packages, is there a way to trace where some function was actually defined?
16:13:08 <sm> Clint, lispy, Gurkenglas_: well I am at least clearing out some ancient cruft. import Data.Monoid.Endo (Endo(Endo), appEndo)
16:13:15 <MarcelineVQ> dersquisher: :info might tell you
16:13:41 <dersquisher> MarcelineVQ, ah, that is helpful, thanks!
16:14:31 <sm> sorry, I mean: what I had before was in fact just foldl' (.) id <$> sequence us
16:15:36 <Nux__> lispy, I'm tentatively going to say that worked
16:15:58 <sm> lispy: you think sequence is to blame eh ?
16:16:32 <GLM> What is the best way to represent a programs states and the valid transitions from them to other states?
16:25:16 <Nux__> lispy, well thanks to you I've managed to write a working program in haskell that uses SDL! Thanks :)
16:25:33 <Welkin> does anyone know about SockAddr from Network.Socket?
16:25:36 <Nux__> lispy, that's a good note to go to bed on
16:25:45 <Nux__> lispy, goodnight
16:25:48 <Welkin> I want to store the IP address using inet (in postgres)
16:26:18 <Welkin> this only sems to work with SockAddrInet and SockAddrInet6
16:26:37 <Welkin> what is the format of SockAddrUnix and SockAddrCan?
16:34:59 <lispy> Nux__: cheers!
16:35:34 <lispy> sm: It could be an issue. If sequence is forced to generate the entire list before giving any elements, then I would expect a blow up there.
16:35:54 <lispy> sm: I'm not very familiar with ExceptT
16:37:49 <Welkin> ExceptT is like EitherT
16:56:45 <lispy> sm: I just showed your code/problem to a co-worker and he said that foldM should be more efficient here
16:56:54 <lispy> sm: and he confirmed what I was afraid of
16:57:26 <lispy> sm: actually, maybe this version of fold: https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Foldable.html#v:foldlM
16:57:52 <lispy> He said it's worth a try because you won't need the sequence anymore
17:10:27 * hackagebot wolf 0.2.0 - Amazon Simple Workflow Service Wrapper.  https://hackage.haskell.org/package/wolf-0.2.0 (markfine)
17:52:12 <behzad-nouri> @hoogle mapM_
17:52:12 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
17:52:13 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
17:52:13 <lambdabot> Data.Foldable mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
18:11:40 <td123> does haskell have a vim / editor plugin that does expression searches like idris for vim?
18:17:33 <solfu> hello everyone!
18:21:20 <ulyssesdwolfe> hello
18:23:54 <EvanR> Welkin: i recommend postgres type string for that
18:30:04 <Welkin> EvanR: ('::'::inet)
18:30:31 <Welkin> yeah, I am doing all kinds of string processing to convert from SockAddrInet/6 to inet
18:30:57 <EvanR> fuckit
18:31:16 <Welkin> it works
18:31:23 <Welkin> at least for those two constructors
18:31:26 <EvanR> not worth it
18:31:44 <Welkin> once I get the ip in the database, I'm not pulling it out
18:31:51 <Welkin> except for viewing if necessary
18:31:54 <EvanR> GLM: dependent types
18:31:59 <julianleviston> I still feel like I’m fighting Haskell. I spend too much of my time pulling data structures apart, which feels wrong to my Haskell-sensibilities.
18:32:07 <EvanR> Welkin: right
18:32:33 <Welkin> julianleviston: you mean record accessors?
18:32:39 <julianleviston> Welkin: yeah
18:32:40 <Welkin> perhaps you should normalize your data
18:32:42 <EvanR> julianleviston: you might be missing Functors and Applicatives where possible... or you might feel like getting into lenses
18:32:45 <Welkin> you can also use lens
18:32:59 <julianleviston> well… it’s not a depth problem.
18:33:12 <EvanR> for a large number of predictable record types, theres template haskell
18:33:32 <lpaste> JulianLeviston pasted “Fighting Haskell?” at http://lpaste.net/142880
18:33:38 <julianleviston> This is what I mean
18:34:01 <julianleviston> That code feels incredibly ugly to me.
18:34:05 <EvanR> julianleviston: validation in particular is a good use case for applicative style
18:34:31 <EvanR> julianleviston: the wrapping of String several times might be overkill for you simple program
18:34:35 <EvanR> your*
18:34:47 <julianleviston> EvanR: yeah, it’s just an experiment before I get into more complex things.
18:35:03 <EvanR> Price = Maybe Integer seems weird
18:35:06 <julianleviston> EvanR: I like to do little experiments to prove my thought processes before I do more complex stuff
18:35:24 <julianleviston> EvanR: the semantics are “sometimes there’s a price on the page, sometimes there’s none”
18:35:33 <EvanR> some record might have a Maybe Price field though
18:35:37 <julianleviston> EvanR:  and in fact, sometimes there’s a “POA”
18:35:44 <EvanR> Page { price :: Maybe Price }
18:35:46 <julianleviston> EvanR: how do you mean?
18:35:55 <julianleviston> EvanR:  ahhh
18:36:04 <julianleviston> EvanR:  fair enough. I put the maybe in the wrong spot.
18:36:08 <EvanR> if there really is a price, now everything has to deal with the possibility of Maybe when it shouldnt have to
18:36:28 <julianleviston> EvanR:  that’s definitely a good catch - that will clear up some of my ugliness
18:36:33 <julianleviston> EvanR:  thanks
18:37:04 <KaneTW> i feel like you can separate all that validation
18:37:10 <julianleviston> EvanR:  alghough… come to think of it, the actual data store has to keep a Maybe in there… because that field might not have a value in it.
18:37:20 <julianleviston> EvanR: it actually *is* a facet of the flute. It might not have a price.
18:37:20 <EvanR> well all that validation goes away when you dont have Maybe Integer
18:37:45 <EvanR> julianleviston: fine, Flute { price :: Maybe Price } ?
18:38:11 <julianleviston> EvanR: yeah, sorry.. much better. I’ll refactor that now
18:38:41 <EvanR> but when you do need to validate a bunch of things theres applicative
18:38:56 <EvanR> and deal specially with the case where things are invalid
18:39:24 <julianleviston> EvanR: yeah, what’s the typeclass? Validation or something. I remember that… so you can have multiple validation errors at once?
18:39:41 <EvanR> for requirements like the name, brand cant be blank, the user input might be a better place to put that validation than in the data model?
18:39:42 <julianleviston> EvanR:  sorry, not typeclass… polymorphic type.
18:40:09 <EvanR> like you could say names could be blank and nothing bad would probably happen when you use the data, but restrict the input from being blank
18:40:37 <julianleviston> EvanR: I’d like the data model to encapsulate the validation. It should communicate (all of) the user input sections. the model feels like the right place for it.
18:40:48 <EvanR> well thats not a good pattern imo
18:41:02 <EvanR> the "fat model" paradigm from rails
18:41:04 <julianleviston> EvanR: I’m not convinced? “that’s not a good pattern” isn’t enough explanation for me
18:41:50 <julianleviston> EvanR: ah ok. So you’d advocate a “protective writer” or somesuch? a piece of code which wraps the dumb model and handles things like validation?
18:41:58 <EvanR> for a database-based application you have the raw data and the validation rules, the validation rules are best to enforce at the very edge of the system where the user is typing
18:42:27 <EvanR> if you put the validation rules at the end of the process, where you put stuff in the database (i mean, you have it ONLY there) then its way more complex leading up to that
18:42:37 <julianleviston> EvanR: That makes little sense to me… what if there are multiple edges (which there will be in my case) - then you have duplication of validation code.
18:42:47 <EvanR> julianleviston: why do you have duplication?
18:43:29 <EvanR> imagine a command line program and the user types a long string to execute a command
18:43:40 <julianleviston> EvanR: well, say I have a JSON input as one mode of input, and also a web form as another… where does the validation logic reside? both in the part of the app that handles the JSON processing, AND the part of the app that handles the form
18:43:40 <EvanR> now imagine you leave that as a string until the very end of the process of figuring out what to do
18:43:51 <EvanR> from beginning to end, you dont know if any properties of that string are valid
18:44:10 <EvanR> so eaech step has to deal with a mix of things that are supposedly known via ad hoc means until you do proper validation
18:44:14 <julianleviston> EvanR: Sorry, I’m not following that analogy at all for some reason.
18:44:36 <EvanR> so you have a json api, and a web form api
18:44:55 <julianleviston> EvanR: I will.
18:44:59 <julianleviston> EvanR: and potentially others.
18:44:59 <EvanR> alright try this
18:45:19 <julianleviston> EvanR: the validation rules need to be specified in one single place, right? Coz they need to be changeable as the model changes.
18:45:50 <liyang> When did this Hackage Trustees thing become a thing? I like the idea.
18:45:59 <EvanR> julianleviston: pushing your question onto my stack ;)
18:46:08 <julianleviston> EvanR: lol huh? :)
18:46:21 <EvanR> im in the process of explaining something else
18:46:28 <julianleviston> EvanR: oh ok. sorry!
18:46:52 <nshepperd> no, they only need to be changed when the input method changes
18:46:55 <EvanR> to avoid duplicating work for a pretty similar two interfaces that just use json vs a form...
18:47:20 <julianleviston> nshepperd: it’s data validation, not input field validation I’m talking about here.
18:47:49 <EvanR> just use json or the web forms result (unvalidated) as the input to the other consumer that is taking json or form data
18:47:52 <EvanR> dont do both
18:48:04 <julianleviston> nshepperd: input field validation should be driven from both the data validation and the requirements of the input fields (types).
18:48:05 <EvanR> alternatively define a super structure of both, and parse both into that
18:48:21 <julianleviston> EvanR: not following, really. Sorry!
18:48:33 <julianleviston> EvanR: have no idea what a super structure is.
18:48:54 <EvanR> a web form and json data are just two ways to get a big nested format for transferring raw data
18:49:16 <julianleviston> EvanR: I mean, I’m happy to put the validation into code *around* the model - like a guard - the thing that does the data updating, for example.
18:49:17 <EvanR> you chose to have both, so to deal with that, convert both to a common format before continuing
18:49:49 <EvanR> only having data validation at the database level is pretty bad for usability and flexibility
18:49:54 <nshepperd> why do you need to do validation at all?
18:50:07 <EvanR> do you understand what i was saying about json vs html forms before i answer your other question
18:50:28 <Welkin> validate as much as possible on the client
18:50:31 <julianleviston> EvanR: “the other consumer” <- what is that?
18:50:38 <julianleviston> Welkin: yes, obviously.
18:50:49 <Welkin> you can do this using html "type" and "required"
18:50:56 <EvanR> julianleviston: your "duplicated" code that handled the json or the html form data
18:50:57 <julianleviston> Welkin: sorry, obviously for me :)
18:51:24 <julianleviston> nshepperd: to ensure the data conforms to the right shape (ie not just the type, but the ranges etc. of the data).
18:51:46 <julianleviston> EvanR: I don’t really follow what you’re trying to say about the json and form.
18:52:01 <EvanR> julianleviston: is every possible update to this application of the form "here is a full description of a record"
18:52:09 <julianleviston> EvanR: no.
18:52:14 <EvanR> i didnt think so ;)
18:52:19 <julianleviston> EvanR: it’s a different model than you might have seen before. :)
18:52:25 <julianleviston> EvanR: (no assumptions here)
18:52:55 <nshepperd> julianleviston: he's saying you can translate the web forms input into json and then supply it into the first validator
18:53:01 <julianleviston> EvanR: I’m building a system using data streams & diffs.
18:53:18 <julianleviston> nshepperd: oh yeah, absolutely - that’s what I meant by the guard on the “data store” (/ model)
18:53:19 <EvanR> so each action needs to validate the information in its own way (this does not include the SAME action that happens to have json and html form variants)
18:53:31 <julianleviston> EvanR: what’s an action?
18:53:43 <EvanR> you tell me
18:53:46 <julianleviston> EvanR: (trying to understand your nomenclature)
18:53:54 <EvanR> a POST for example
18:54:11 <julianleviston> EvanR: oh… action = input of some kind of data to the system
18:54:17 <EvanR> a command
18:54:39 <EvanR> the form of that command needs to be validated before you can even start processing it
18:54:55 <julianleviston> EvanR: ok… um… well… *some* things are different, but the data validation should be identical, I think.
18:54:59 <EvanR> this is exactly opposite to original rails wisdom
18:55:21 <EvanR> you just said that not all commands are of the form "here is a big piece of data. do something"
18:55:36 <EvanR> where "do something" is literally that vague, and the same for all commands
18:55:39 <julianleviston> EvanR:  obviously if it’s in a JS-enabled browser, the JS will enforce as much of the validation as it can before doing a post / xhr.
18:55:40 <julianleviston> EvanR  that’s right - it’s streaming / diff data.
18:55:44 <EvanR> i.e. just the big data record
18:55:45 <julianleviston> EvanR:  yup
18:55:53 <julianleviston> EvanR: wait what?
18:56:01 <julianleviston> EvanR:  “just the big data record” threw me
18:56:03 <EvanR> yeah so not all commands are just some record
18:56:33 <julianleviston> EvanR:  maybe a concrete example is good… “update the name of this flute to “hey””
18:56:33 <EvanR> implicitly meant to update the database
18:56:39 <julianleviston> EvanR:  versus “here is all the data for this flute"
18:57:09 <EvanR> how about "make flute X be associated with customer Y"
18:57:31 <julianleviston> EvanR: obviously *some*times I can’t get around that and because forms, for example, can’t really be partial in this way of looking at things… but xhr totally can.
18:57:33 <Welkin> flutes?
18:57:40 <Welkin> what about bassoons?
18:57:42 <Welkin> and oboes?
18:57:42 <julianleviston> Welkin: instruments you play. It’s just an example.
18:57:51 <julianleviston> Welkin: heh :)
18:57:52 <Welkin> damn the flute
18:58:00 <julianleviston> aw :(
18:58:07 <EvanR> julianleviston: the idea is that not every commands payload consists of exactly some literal database field
18:58:25 <julianleviston> EvanR: my “database” is actually just JSON
18:58:29 <EvanR> i mean if it is, nevermind i tried to determine that earlier
18:58:31 <julianleviston> EvanR: so… “that’s right” :)
18:59:06 <EvanR> what physical shape your database is is not the concern
18:59:11 <Welkin> I often find myself using intermediate data structures to gather the form data, from which I generate/compile the data structure that models the database record
18:59:25 <julianleviston> Welkin: yeah, that’s a nice pattern.
18:59:30 <EvanR> :(
18:59:43 <julianleviston> EvanR: true. the store shape isn’t important.
19:00:13 <EvanR> if this is literally some inventory management app, then if youre lucky everything is literally just updating fields and youre done
19:00:16 <EvanR> active record will save you
19:00:27 <julianleviston> EvanR: active record?
19:00:30 <julianleviston> EvanR:  lol
19:00:51 <EvanR> yeah active record popularized "application programmed by the one operation of building a 'model' record"
19:01:01 <EvanR> you build it, it does stuff
19:02:34 <EvanR> for example, validate user input
19:02:35 <solfu> i'm working through a haskell tutorial and found the "take x(cycle[1,2..n]" construct and thought that it would serve as a good platform to experiment with 'clock arithmetic', but quickly found that's not true. I foundt it wasn't true when i entered 'take 10(cycle[1,10..20])' and expected [1,10,19,8,17...] and instead got [1,10,19,1,10,19...]
19:02:36 <nshepperd> the problem is, if you only validate things at the last step before putting stuff into the database, all the intermediate code there has to think about "what if what I'm handling right now is nonsense"
19:02:37 <Welkin> why the rails references?
19:02:41 <julianleviston> EvanR: active record is a shitty solution.
19:02:51 <solfu> what is a better haskell model for 'clock arithmetic'?
19:03:11 <EvanR> Z mod 12
19:03:20 <Welkin> > [1..3]
19:03:21 <lambdabot>  [1,2,3]
19:03:29 <ReinH> > cycle [1, 10 .. 20]
19:03:31 <lambdabot>  [1,10,19,1,10,19,1,10,19,1,10,19,1,10,19,1,10,19,1,10,19,1,10,19,1,10,19,1,1...
19:03:48 <julianleviston> nshepperd: don’t worry, I won’t only be validating at that level, but I need a place to reify my validations…
19:03:49 <Welkin> ah, yes
19:03:52 <orion> What's worse in terms of performance?: Converting a strict bytestring to a lazy one, or a lazy one to a strict one?
19:03:54 <ReinH> > cycle [1, 10 .. 20] :: [Int]
19:03:56 <lambdabot>  [1,10,19,1,10,19,1,10,19,1,10,19,1,10,19,1,10,19,1,10,19,1,10,19,1,10,19,1,1...
19:03:58 <Welkin> because it skips by 9
19:04:00 <nshepperd> > [1, 10 .. 20]
19:04:02 <lambdabot>  [1,10,19]
19:04:06 <Welkin> thus, 1,10,19
19:04:06 <ReinH> orion: the latter
19:04:12 <orion> ReinH: thanks
19:04:17 <julianleviston> Welkin: I’m not sure why the rails references. 
19:04:19 <nshepperd> cycle doesn't know about the enumeration inside that
19:04:22 <ReinH> orion: the former is O(1), the latter is O() where n is the number of chunks
19:04:26 <ReinH> er, O(n)
19:04:32 <orion> Ah, ok
19:04:39 <Welkin> > cycle (1:[10..20])
19:04:41 <lambdabot>  [1,10,11,12,13,14,15,16,17,18,19,20,1,10,11,12,13,14,15,16,17,18,19,20,1,10,...
19:04:49 <ReinH> orion: a lazy bytestring is a list of chunks.
19:05:05 <Welkin> > cycle (1: reverse [10..20])
19:05:06 <lambdabot>  [1,20,19,18,17,16,15,14,13,12,11,10,1,20,19,18,17,16,15,14,13,12,11,10,1,20,...
19:05:08 <ReinH> solfu: what do you want to do?
19:05:39 <solfu> ReinH: I want to represent numbers cyclically, as they would appear on the face of a clock, and then perform arithmetic with them.
19:05:48 <solfu> ReinH: thus if we were in base 12 (as on a clock)
19:05:53 <EvanR> julianleviston: well youre the one who was fighting haskell ;)
19:05:55 <julianleviston> solfu: [1..12] then?
19:06:02 <solfu> 1+15=3
19:06:10 <nshepperd> solfu: https://hackage.haskell.org/package/modular-arithmetic has an actual modular numbers type
19:06:13 <EvanR> i was trying to explain what you were really fighting
19:06:15 <julianleviston> solfu: oh that’s modulo division
19:06:17 <Welkin> solfu: define a new type and make it an instance of num and performe mod 12 on it
19:06:25 <ReinH> solfu: there's a package for modular arithmetic
19:06:31 <ReinH> @hackage modular-arithmetic
19:06:32 <lambdabot> http://hackage.haskell.org/package/modular-arithmetic
19:06:36 <echo-area> solfu: Shouldn't 1+15 be 4?
19:06:42 <solfu> ...yes
19:06:48 <ReinH> > 1 + 15 `mod` 12
19:06:50 <lambdabot>  4
19:06:54 <julianleviston> EvanR: am I fighting something?
19:07:04 <EvanR> maybe not
19:07:07 <julianleviston> EvanR: I really don’t think the active record pattern is good.
19:07:14 <solfu> why is take not a good representation of this?
19:07:15 <julianleviston> EvanR: (either for OOP, or FP)
19:07:37 <solfu> i was assuming that cycle would build a long list, and take would select from that list, and it seems that this is nto true
19:07:57 <julianleviston> > take 1 $ drop 10 $ cycle [1..12]
19:07:58 <lambdabot>  [11]
19:08:07 <EvanR> > [250..] :: [Word8]
19:08:08 <lambdabot>  [250,251,252,253,254,255]
19:08:10 <ReinH> solfu: Why would take be a good representation of this?
19:08:17 <EvanR> you just need to use the right type
19:08:26 <julianleviston> take 22 $ drop 10 $ cycle [1..12]
19:08:33 <julianleviston> > take 1 $ drop 10 $ cycle [1..12]
19:08:34 <lambdabot>  [11]
19:08:38 <julianleviston> god
19:08:46 <julianleviston> > take 22 $ drop 10 $ cycle [1..12]
19:08:48 <lambdabot>  [11,12,1,2,3,4,5,6,7,8,9,10,11,12,1,2,3,4,5,6,7,8]
19:08:49 <julianleviston> I’m going to stop
19:08:52 <solfu> are you guys evaluating haskell in the chat client??
19:08:54 <ReinH> I'd think an integer with a modulus would be a good representation.
19:09:12 <julianleviston> ReinH: I think the take / drop pattern I just put up is what he’s thinking of
19:09:34 <ReinH> > cycle [1..12] !! 20
19:09:36 <lambdabot>  9
19:09:45 <julianleviston> ReinH: yeah
19:09:50 <ReinH> The obvious thing is an off-by-one error
19:09:59 <ReinH> and pretty inefficient, ofc
19:10:06 <KaneTW> honestly a type Clock = Integer `Mod` 7 
19:10:08 <KaneTW> seems best
19:10:10 <KaneTW> eh
19:10:11 <julianleviston> ReinH: geometric vs algebraic thinking.
19:10:12 <KaneTW> 12
19:10:19 <EvanR> 24
19:10:28 <KaneTW> he wants a mod12 clock
19:10:30 <ReinH> KaneTW: data Mod i = Mod i i; 12 `Mod` 5
19:10:40 <ReinH> As I said, a version of this is available already
19:10:44 <ReinH> @hackage modular-arithmetic
19:10:44 <lambdabot> http://hackage.haskell.org/package/modular-arithmetic
19:10:55 <solfu> the mod solution works quite well unless you want to perform it on other types, such as ['a','e'..'z']
19:11:12 <KaneTW> ReinH: yeah that's what i'm talking about
19:11:19 <solfu> awesome, checking it now
19:11:20 <julianleviston> EvanR: so no other comments about my code besides the “you shouldn’t be doing validation there” comments?
19:11:22 <ReinH> Actually, modular-arithmetic does this at type level
19:11:24 <ReinH> which is quite nice
19:11:32 <KaneTW> that's why i wrote Integer `Mod` 7
19:11:34 <KaneTW> :v
19:11:39 <ReinH> koala_man: :)
19:11:41 <ReinH> er
19:11:43 <ReinH> KaneTW: :)
19:11:47 <EvanR> julianleviston: ive got a million of em ;)
19:12:02 <julianleviston> EvanR: that’s a lot :)
19:12:23 <julianleviston> EvanR: well, I want to improve, so if you feel like telling me the worst of them, go ahead.
19:12:29 <EvanR> julianleviston: so i recommend that you take the Flute type and provide several ways to construct one or update one. All of them validate whatever they need to validate, and internally you can reuse the validation rules
19:12:42 <EvanR> instead of one constructor
19:13:43 <julianleviston> EvanR: sure. I wasn’t actually talking about stuff I hadn’t done yet. Mostly about the crappiness of dhe code that exists - the pattern match deconstrutions that I have feel very ugly.
19:13:51 <EvanR> also you can expose the validation rules so you can use them separately if necessary
19:14:08 <julianleviston> EvanR: yep.
19:14:29 <EvanR> which pattern match deconstructions?
19:14:45 <julianleviston> EvanR: well, say “showFlute” for example. Guh… so ugly.
19:15:03 <EvanR> deriving (Show) isnt good enough?
19:15:24 <julianleviston> EvanR: it’s my “give me a non-programmer string” function. 
19:16:03 <shlomocomputer> Why can I not instantiate an IOArray holding generic elements with signature IOArray Int a
19:16:09 <EvanR> if youre expecting to make a lot of these pretty print functions for a bunch of records, and you have custom wrapped wrapped string types, you need a pretty printing library
19:16:17 <shlomocomputer> but if I narrow 'a' to, say, Char, it type checks OK?
19:16:30 <KaneTW> shlomocomputer: post an example
19:16:46 <julianleviston> EvanR: so there’s no language-level nicer deconstruction stuff?
19:16:49 <EvanR> julianleviston: also this is related to html templates? other "views" of the data? reports?
19:16:59 <shlomocomputer> xsA <- newListArray (0, 10) xs :: IO (IOArray Int Char)
19:17:26 <shlomocomputer> xsA <- newListArray (0, 10) xs :: IO (IOArray Int a) fails complaining that a is a rigid type variable
19:17:27 <EvanR> julianleviston: for what youre doing, slightly nicer syntax to deconstruct for the purposes of pretty printing wouldnt even help, youll have too much and its boring
19:17:32 <julianleviston> EvanR: this data will be fed into something that constructs HTML out of it. It could also feed into something that constructs simple text without HTML, sr an email sender.
19:18:16 <EvanR> and yall tried to act like i wasnt justified comparing this to a rails app
19:18:31 <julianleviston> EvanR: it’s less about pretty printing and more about transmuting the data in various ways. The “human readable” showFlute function was just my first port of call down that road (of data transmuting)
19:18:34 <KaneTW> shlomocomputer: works fine for me
19:18:57 <KaneTW> oh nevermind there
19:19:24 <julianleviston> EvanR: Rails lets you make web apps. This will be on the web. Is that your point here? lol
19:19:28 <EvanR> julianleviston: yeah thats gonna be slow, youll want to normalize the way in which you view all this data and abstract over it. first step, convert it all to json?
19:19:40 <KaneTW> shlomocomputer: you're providing the type signature too deep
19:19:50 <julianleviston> EvanR: slow for who?
19:19:55 <EvanR> for you
19:19:59 <shlomocomputer> KaneTW:  What do you mean?
19:20:08 <julianleviston> EvanR: … and this *is* my normalization of the data… this *is* my abstraction… 
19:20:15 * EvanR looks at it again
19:20:31 <EvanR> b ++ " " ++ m ++ " " ++ desc ++ " $" ++ p ?
19:20:33 <julianleviston> EvanR:  the Flute datatype is an abstraction over the data.
19:20:40 <EvanR> i dont think thats a good normalization
19:20:56 <julianleviston> EvanR: I don’t think I undrstand what you mean by normalization, sorry.
19:21:04 <EvanR> you wont be able to do anything with that but show it
19:21:47 <EvanR> is all your data going to be records with fields where each field type has some nice formatting to show a small value?
19:22:04 <EvanR> you can abstract over that
19:22:18 <julianleviston> EvanR: I’m not understanding your use of the words “abstract over” here.
19:22:48 <EvanR> i mean do something so you dont repeat the same exact boring task over and over for each type
19:23:00 <shlomocomputer> KaneTW: What would be an example of a less deep type annotation?
19:23:09 <KaneTW> shlomocomputer: uhh
19:23:11 <julianleviston> EvanR: uh ok.
19:23:30 <julianleviston> EvanR: so pretty much abstract out more functions.
19:23:38 <KaneTW> let's say you do (\xs -> newListArray (0, 10) xs) :: [a] -> IO (IOArray Int a)
19:23:47 <KaneTW> ignore the let's say you do
19:23:49 <KaneTW> inline editing
19:23:53 <EvanR> pretty printing of record-like stuff can totally be automatd
19:24:07 <EvanR> html display, totally automated
19:24:12 <shlomocomputer> KaneTW: k
19:24:19 <KaneTW> shlomocomputer: essentially you have a type variable inside the expression
19:24:35 <KaneTW> that then needs to be unified with a type variable outside of it, like the \xs in this case
19:24:38 <KaneTW> and it can't do that
19:24:43 <shlomocomputer> ahhhhh.
19:25:30 <KaneTW> the type of xs in \xs* but you got what i mean
19:25:31 <julianleviston> EvanR: alright, so that means you pretty much don’t have any comment on the way the current code is written. All good. :)
19:26:12 <shlomocomputer> KaneTW:  That explains it.  The 'a' in the function sig does not get "scoped" down to expressions within the definition
19:27:29 <julianleviston> EvanR: BTW, the thing I’m building isn’t actually this one instance, it’s something that can hold anything like it ;-) fun begins. :)
19:27:37 <EvanR> julianleviston: alright, even though i was talking about this code ill throw out something more specific, you decided to double wrap String, and then got annoyed having to double unwrap to display it. but you could have just used `show' on the doubly wrapped value
19:27:44 <KaneTW> shlomocomputer: yeah
19:27:57 <shlomocomputer> however, if I provide no annotation at all, it complains thus:
19:28:00 <EvanR> or `prettyShow'
19:28:16 <julianleviston> EvanR:  where’s the double wrapped string?
19:28:16 <shlomocomputer> No instance for (MArray a0 a IO)   arising from a use of ‘newListArray’  The type variable ‘a0’ is ambiguous
19:28:29 <EvanR> Brand
19:28:33 <KaneTW> yup, you'll need to add a constraint on a
19:28:53 <julianleviston> show Just “Hello”
19:29:00 <KaneTW> eh, a0
19:29:05 <julianleviston> > show Just $ Just 57
19:29:06 <lambdabot>      Couldn't match expected type ‘Maybe Integer -> t’
19:29:07 <lambdabot>                  with actual type ‘[Char]’
19:29:07 <lambdabot>      The first argument of ($) takes one argument,
19:29:15 <KaneTW> oh i see enow
19:29:28 <EvanR> julianleviston: well you already said this is pretty, so no we cant use show, youd use the version of prettyShow for that type
19:29:42 <julianleviston> > show $ Just $ Just 5
19:29:43 <lambdabot>  "Just (Just 5)"
19:29:43 <EvanR> you define a new prettyShow for every wrapped type
19:29:45 <julianleviston> EvanR: yep.
19:29:53 <julianleviston> EvanR: right.
19:30:04 <julianleviston> EvanR: which is “abstract functions”. It’s cool :)
19:30:08 <EvanR> and for Brand i wonder if its worth it ;)
19:30:27 <EvanR> type Brand?
19:30:33 <EvanR> instead of newtype?
19:30:56 <julianleviston> EvanR: ok unless I wanted type differentiation (which I did)
19:30:57 <KaneTW> shlomocomputer: you can either define a function like the lambda i posted above
19:31:01 <julianleviston> EvanR: really, though, all we’re doing is moving the complexity vertically rather than horizontally in this case, which is fine… 
19:31:15 <julianleviston> EvanR: I should probably wait until I have a non-toy example.
19:31:30 <EvanR> well better than doing the deconstruction in every place
19:31:41 <EvanR> but yeah for newtypes you have to do all this
19:31:44 <julianleviston> EvanR:  very true.
19:31:50 <KaneTW> or something like let newListIOArray = newListArray :: Ix i => (i, i) -> [e] -> IO (IOArray i e)
19:31:55 <julianleviston> EvanR: oh? Why not for newtypes?
19:32:07 <EvanR> why yes for newtypes
19:32:07 <julianleviston> EvanR: oh sorry I misread.
19:32:44 <julianleviston> EvanR: or data types. We don’t have a way to say “I want a distinct copy of this type, named Blah”
19:33:00 <julianleviston> EvanR: maybe if we did, we’d have less newtype (ab)use…
19:33:01 <EvanR> what would the point be of that?
19:33:14 <julianleviston> EvanR: type distinction by the compiler.
19:33:28 <shlomocomputer> KaneTW:  http://hastebin.com/uzibewayoj.coffee
19:33:49 <EvanR> i guess that would help in case you have a binary function like a -> a -> a
19:34:03 <EvanR> as a class
19:34:32 <EvanR> but if you duplicated A and B, then they would act exactly the same and you couldnt have A.foo and B.foo in scope together unqualified anyway
19:34:35 <EvanR> A as B
19:35:10 <EvanR> the compiler would know the diff, but the programmer almost cant tell the diff now
19:35:57 <julianleviston> EvanR: the way the autogenerated “data accessor” functions work is a mistake IMO. They should have been “namespaced” from the start, with the option to alias them to the top level if you want.
19:36:14 <lpaste> shlomocomputer pasted “Ambiguous type of array?” at http://lpaste.net/142884
19:36:16 <EvanR> you want to qualify them?
19:36:43 <EvanR> TripleDoubleSundae.price
19:36:46 <julianleviston> EvanR: defining a record type shouldn’t automagically create functions for field access IMO
19:37:07 <EvanR> how would you get the fields?
19:37:24 <julianleviston> EvanR: TripleDoubleSundae.price.
19:37:42 <julianleviston> EvanR: at least then you could *choose* if you wanted to top-level function namespace pollute.
19:37:51 <EvanR> you mean it should create an unqualified version
19:37:54 <EvanR> should not
19:37:58 <julianleviston> EvanR: yes.
19:38:01 <EvanR> not that it should be a function
19:38:09 <julianleviston> EvanR: then using lenses would be a bit less strange.
19:38:36 <EvanR> well its not top level pollution, its module pollution
19:38:44 <julianleviston> EvanR: yes.
19:38:55 <EvanR> global global pollution = php
19:39:00 <KaneTW> shlomocomputer: http://hastebin.com/ketetayili.coffee
19:39:45 <EvanR> julianleviston: of course, that would probably lead to a lot more unqualified declarations at the top... and theres already so many freakin imports
19:40:17 <nineonine> hello
19:40:21 <KaneTW> hi
19:40:29 <nineonine> need some help
19:40:36 <nineonine> 2**64 gives me strange number
19:40:37 <nineonine> :)
19:40:42 <nineonine> its complex i guess
19:40:47 <shlomocomputer> KaneTW:  Thanks, you got it working
19:40:50 <EvanR> > 2**64
19:40:51 <lambdabot>  1.8446744073709552e19
19:40:51 <nitrix> I seem to be to a point in my Haskell learning experience where I can easily write code and use some of the features adequatly, still, reading someone else code isn't easy.
19:40:58 <shlomocomputer> but holy *mackerel* is that noisy
19:41:13 <nineonine> how can i get Integer from it
19:41:13 <nineonine> ?
19:41:19 <nineonine> thanks in advance
19:41:21 <KaneTW> :t (**)
19:41:22 <lambdabot> Floating a => a -> a -> a
19:41:24 <KaneTW> :t (^)
19:41:25 <lambdabot> (Integral b, Num a) => a -> b -> a
19:41:25 <nitrix> For the most part, the structure makes sense, but they just tend to name everything poorly with x, y, j, k, letters and I have to mentally keep notes of which is what.
19:41:28 <KaneTW> :t (^^)
19:41:29 <lambdabot> (Fractional a, Integral b) => a -> b -> a
19:41:30 <Welkin> "thanks in advance"?
19:41:32 <Welkin> wtf is this
19:42:03 <Welkin> such a passive aggressive way of saying "thank you" without saying "thank you"
19:42:04 <shlomocomputer> Welkin:  In a chat room, lol
19:42:16 <EvanR> nitrix: internal pure code can be like that... i got pretty good at reading somebody elses FFI code though
19:42:25 <shlomocomputer> He prolly has to run right after he gets his answer
19:42:30 <EvanR> that helped with a lot of idioms
19:43:20 <nitrix> EvanR: As long as you say that it's just a quick phase, that'll cheer me up.
19:44:07 <nineonine> thanks @KaneTW !
19:44:24 <EvanR> variable naming is a skill whether its one letter or 35 letter names
19:44:47 <umib0zu> anyone know the difference between Data.Hashtables and Data.Maps ?
19:44:53 <shlomocomputer> KaneTW:  You'd think GHC could infer the necessary types from the shuffle sig
19:45:04 <nitrix> EvanR: I suppose I can't blame the language for that. Maybe my inexperience is just making it more difficult since the context is less obvious.
19:45:49 <KaneTW> shlomocomputer: how would you decide if you want IOArray or IOUArray
19:46:02 <shlomocomputer> right, that's the one thing
19:46:46 <KaneTW> ghc can't infer an instance even if it knows there only exists one because that doesn't mean there can't be another one in the future
19:47:06 <KaneTW> so you add another instance sometimes later and unrelated code breaks
19:47:15 <nitrix> umib0zu: From looking at the library, it seems it's a mutable data structure in the IO monad.
19:47:28 <umib0zu> nitrix which one?
19:47:35 <nitrix> umib0zu: Data.Hashtables.
19:47:39 <umib0zu> ohhh
19:47:47 <umib0zu> no 
19:47:48 <nitrix> umib0zu: In contrast, Data.Map seems immutable. All functions takes a Map and returns a Map.
19:48:01 <shlomocomputer> KaneTW:  That makes sense
19:48:11 <umib0zu> it’s not mutable. Mutators on both always seem to return a new instance
19:48:17 <shlomocomputer> KaneTW:  Still though, I don't even need to unify the inner 'a' with the outer 'a'
19:48:20 <umib0zu> nitrix where do you see that?
19:48:54 <nitrix> umib0zu: Oh, I was looking at Data.HashTable.IO
19:49:04 <KaneTW> oh
19:49:06 <KaneTW> i totally forgot
19:49:09 <shlomocomputer> I did :: IO (IOArray Int a), and that *should* be all the information needed
19:49:11 <KaneTW> -XScopedTypeVariables
19:49:24 <EvanR> umib0zu: Map is more commonly used for functional code
19:49:25 <shlomocomputer> duuuuuuuuuuuude
19:49:38 <umib0zu> nitrix I think Map uses balanced trees but I’m not sure
19:49:46 <EvanR> Map uses balanced trees
19:50:02 <EvanR> its more efficient to update a Map immutably than a hash table
19:50:42 <nitrix> umib0zu: That maps Data.Hastables is dealing with collisions and probably has a resize operation and all the shabang hashmaps have.
19:50:47 <nitrix> s/maps/means/
19:50:57 <shlomocomputer> KaneTW:  Nope, still doesn't work
19:51:48 <shlomocomputer> I guess I'm really not understanding the meaning of the error message.  Especially baffling is "Expected type: [a1] Actual type: [a]"
19:51:49 <umib0zu> ahh ok. I dug into it and it does look like Data.Map is balanced as in operations like filter are supported
19:51:54 <umib0zu> nitrix ^^
19:52:04 <KaneTW> shlomocomputer: that's just the scoping error
19:52:10 <umib0zu> hash tables don’t support filter-likes
19:52:10 <KaneTW> iirc you need an explicit forall now, hold on
19:52:31 <KaneTW> yeah
19:52:42 <KaneTW> do shuffle :: forall a. [a] -> IO [a]
19:52:45 <KaneTW> and it works
19:53:18 <EvanR> umib0zu: Map supports a lot of cool operations, for example you can split a Map into a Map of all key less, a Map of all greater greater, and Maybe the element whose key is equal to some key
19:53:28 <shlomocomputer> KaneTW:  I am shoving a cookie through my laptop's webcam
19:53:34 <KaneTW> haha
19:53:37 <shlomocomputer> but it's not working out the way I wanted
19:53:38 <EvanR> ... Map of all elements whose keys are less, greater and maybe equal
19:54:11 <EvanR> umib0zu: for even higher performance there is IntMap
19:54:45 <umib0zu> lol were the folks who were chatting about the type constraint Fractional a working on a factorial function? I’m literally trying to do that but memoizing it with Data.Map
19:54:51 <shlomocomputer> KaneTW:  That actually makes me want to use mutable arrays now
19:54:57 <KaneTW> hah
19:55:08 <umib0zu> numeric types are the oddest types to work with in Haskell
19:55:21 <EvanR> > 3.14159 :: Centi
19:55:23 <lambdabot>  3.14
19:55:41 <shlomocomputer> or rather, the hassle has been so great to use them that I was like, bleh
19:55:46 <EvanR> > sqrt 2 :: CReal
19:55:47 <lambdabot>  1.4142135623730950488016887242096980785697
19:55:51 <shlomocomputer> KaneTW:  Goodnight sir/madam, thank you for the time spent
19:56:06 <KaneTW> good night
19:56:50 <EvanR> numeric types are really odd to work with in python/ruby/clojure/javascript/php
19:56:56 <EvanR> 2 + "2"
19:57:06 <EvanR> "2" + 2
19:57:07 <Guest54638> "22"
19:57:10 <julianleviston> EvanR: numeric types are really odd.
19:57:29 <EvanR> FALSE == "NULL"
19:58:13 <EvanR> julianleviston: Nats, Integer, Rationals are ok ;)
19:58:13 <Guest54638> Is it possible to have a value be in multiple types? Like if I have int but also have nat which is all ints > 0. Would I be able to pass in 2 :: int to a function that takes a nat?
19:58:28 <EvanR> no
19:58:56 <julianleviston> Guest2510: 5 is “in multiple types” inasmuch as it’s polymorphic
19:59:04 <julianleviston> :t 5
19:59:05 <lambdabot> Num a => a
19:59:10 <Welkin> if Nat is a type class for which Int is an instance, then yes
19:59:48 <Guest54638> Welkin, What if Nat was a regular type?
20:00:05 <julianleviston> Guest54638: what’s a regular type?
20:00:07 <EvanR> Guest54638: haskell doesn't have subtyping or coercion
20:00:12 <shlomocomputer> there does happen to be a class that maps a type to and from Ints
20:00:25 <Guest54638> julianleviston, Something like int or list
20:01:08 * hackagebot yesod-media-simple 0.2.0.0 - Simple display of media types, served by yesod  https://hackage.haskell.org/package/yesod-media-simple-0.2.0.0 (MichaelSloan)
20:01:10 * hackagebot webdriver 0.7 - a Haskell client for the Selenium WebDriver protocol  https://hackage.haskell.org/package/webdriver-0.7 (AdamCurtis)
20:01:24 <julianleviston> Guest54638: it’s a very theoretical question isn’t it? :) Haskell will defer what type something is until it absolutely needs to know to get you the answer you want (when you want it), generally.
20:01:40 <EvanR> yall are being confusing
20:02:09 <Guest54638> julianleviston, Yes it is. I'm basically trying to put constraints on input values without messing with dependent types
20:02:21 <julianleviston> Guest54638: ah… right. :/
20:02:25 <EvanR> is ((+1) :: Int -> Int) (2 :: Nat) well typed
20:02:28 <EvanR> no
20:02:53 <Guest54638> nope
20:02:58 <EvanR> Guest54638: theres several techniques to do what you want
20:03:27 <EvanR> for example https://wiki.haskell.org/Smart_constructors
20:06:58 <shlomocomputer> The Peano numbers section on the smart constructors wiki page has me smiling
20:07:56 <shlomocomputer> However, an Agda tutorial I was looking at today had my eyes bleeding
20:08:02 <shlomocomputer> mainly 'cause of the unicode
20:08:03 <Guest54638> EvanR, Browsed through the link. I want the constraint in the type system but that seems to only work for small finite values rather than all ints > 0
20:09:10 <EvanR> Guest54638: there are more or less practical techniques, one that gets some use is type level naturals with type level arithmetic
20:09:23 <EvanR> smart constructors are easier
20:09:45 <Guest54638> EvanR, How would I be able to best convert from ints to nats in that case?
20:10:05 <EvanR> and even easier is to use a common numberic type like Int or Integer and crash/burn immediately when something isnt right
20:10:21 <EvanR> Guest54638: in any case, you need to convert explicitly
20:10:25 <Guest54638> I use Haskell to not crash and burn
20:10:39 <Guest54638> How would I go about doing that? 
20:11:09 <EvanR> write a function intToNat :: Int -> Nat, or Int -> Maybe Nat
20:11:46 <Guest54638> EvanR, I understand that but I feel like that'd get pretty low level
20:12:04 <EvanR> you can use a library already written too
20:13:04 <shlomocomputer> I feel like Haskell is comfortable at this place: "Here are all the great things we can do at compile time.  If you want more, there are great, young languages which look awfully like Haskell but give you dependent types etc."
20:13:14 <EvanR> value level naturals are pretty unpopular in haskell i feel like
20:13:30 <Guest54638> EvanR, Is that just for Int -> Nat or for a -> b?
20:13:41 <EvanR> a -> b ?
20:14:26 <EvanR> to convert between two integral types use this
20:14:31 <EvanR> :t fromIntegral
20:14:32 <lambdabot> (Integral a, Num b) => a -> b
20:15:03 <Guest54638> What if I want to convert from a to b where they may not be Intgeral/ Num?
20:15:22 <EvanR> then that method wont work, since it relies on toInteger
20:15:31 <EvanR> and fromInteger
20:16:03 <EvanR> what do you know?
20:17:49 <yungfool> selenium is rolling out a new protocol spec pretty soon, and one of the new features is support for parallel "action chains" (parallel touch/keyboard/mouse execution). So in anticipation of that I've been working considering how I want to add the new feature to the Haskell bindings. I'd be interested in feedback on this mock-up example showing what
20:17:49 <yungfool>  the API could look like: http://lpaste.net/1589295060963295232
20:20:13 <EvanR> Guest54638: if you meant "not necessarily numbers at all" you can check out Convertible
20:20:56 <EvanR> but a -> b where a and b are any type is not a very interesting type by itself
20:21:01 <yungfool> has the benefit of making your code resemble stylish automobiles.
20:23:18 <umib0zu> anyone know what this “foldable-traversable-apocalypse” is mentioned in the ghc-devs mailing list?
20:27:25 <EvanR> link? cant find it in the archivs
20:29:38 <EvanR> https://mail.haskell.org/pipermail/ghc-devs/2015-October/010068.html
20:30:24 <EvanR> umib0zu: the foldable traversable proposal aka burning bridges proposal moves a lot of functionality from the prelude into foldable and traversable by generalizing
20:30:27 <EvanR> :t length
20:30:29 <lambdabot> Foldable t => t a -> Int
20:30:30 <EvanR> ^
20:31:09 <umib0zu> that’s strange
20:31:11 <Clint> i thought burning bridges was both FTP and AMP
20:31:26 <EvanR> right, AMP and probably something else
20:31:27 <umib0zu> EvanR that was the link by the way
20:32:02 <umib0zu> lol if haskell devs are leaving the language for breaking changes, they should checkout R
20:32:02 <EvanR> "mzero" is only referring to foldable traversable though
20:32:43 <EvanR> umib0zu: actually the changes didnt break very much i think, and many of the changes were compromises to not break stuff. theres a lot written on this
20:32:44 <Stratege> I thought AMP broke way more code than FTP?
20:33:00 <EvanR> umib0zu: but the type signatures of stuff dont look so noob friendly anymore
20:33:09 <EvanR> i guess thats what hes pissed about
20:33:18 <EvanR> :t sequenceA
20:33:19 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
20:33:21 <KaneTW> AMP is fine
20:33:25 <lolisa> I dont get why it is called burning bridges... 
20:33:41 <EvanR> "no going back" ;0
20:33:43 <KaneTW> i like FTP myself but
20:33:52 <KaneTW> when teaching it's just added complexity
20:34:11 <KaneTW> "if you want to see the type of an expression, type :t in ghci"
20:34:21 <KaneTW> :t length
20:34:22 <lambdabot> Foldable t => t a -> Int
20:34:41 <KaneTW> "what's Foldable? what's that =>? ?????"
20:34:41 <EvanR> there should be an easy way to show a specialized version
20:34:46 <KaneTW> yes
20:34:59 <KaneTW> i just don't know how to do the easy part
20:34:59 <lolisa> Maybe we should lie a simple haskell for beginner, just as SPJ lie about lens, simplifying two of the argument on his talk on skillmatter...
20:35:01 <EvanR> we already needed that for Monad combinators
20:35:08 <EvanR> :t sequence
20:35:09 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
20:35:24 <EvanR> we dealing with just IO or just whatever monad
20:35:55 <Stratege> there's always the option of having a version of Prelude for teaching which has all the type signatures specialized to the point of being non-scary
20:36:19 <EvanR> instead of a separate version, a mode of asking for type sigs
20:36:30 <EvanR> more general, less general
20:37:01 <Stratege> how is it supposed to figure out which type to use for the "less general" though?
20:37:15 <EvanR> well, we have defaulting rules, but thats probably not right
20:37:20 <KaneTW> hm
20:37:38 <EvanR> a configurable-with-defaults specialization for Foldable, Monad, Traversable, etc
20:37:39 <KaneTW> maybe an interactive command in ghci
20:37:50 <awpr> actually that might make sense, just as a special learning feature of GHCI and Haddock.  Monad -> IO; Foldable, Traversable -> []
20:37:54 <EvanR> the default Foldable and Traversable is [ ]
20:37:58 <EvanR> Monad... IO ?
20:38:08 <EvanR> might be a bad idea
20:38:17 <KaneTW> Monad -> IO is a terrible idea
20:38:19 <awpr> eh, or Maybe, I'm not sure it really matters which
20:38:21 <Stratege> ^ I'd agree with that being a biad idea.
20:38:29 <EvanR> the default Monad can be Identity
20:38:34 <KaneTW> :s length and then it walks you through the context ala
20:38:38 <Clint> :t length `asAppliedTo` []
20:38:39 <lambdabot> [a] -> Int
20:38:49 <EvanR> that also works
20:39:13 <awpr> I'm not sure I've correctly represented my idea then.  Not that 'return' would default to IO, but that :st return ("simplified-type") would show "a -> IO a"
20:39:22 <EvanR> still
20:39:31 <EvanR> thats going to confuse IO and monads even more
20:39:46 <KaneTW> :s length \ Enter instance for Foldable t (? for potential instances in scope): 
20:39:57 <EvanR> theres no equivalent problem with Foldables and lists
20:39:58 <KaneTW> something like that
20:40:13 <awpr> fair enough.  but it also probably shouldn't be Identity, since it's not very illustrative as a monad
20:40:15 <Stratege> I'm already rather annoyed with LYAH for explaining IO before Monads despite relying on monads for the IO explanation.
20:40:51 <EvanR> awpr: true, and [ ] was confusing to me as a monad at first
20:41:08 <EvanR> we dont want everything to seem list based
20:41:24 <Stratege> why would monad in particular have to be specialized to something anyway?
20:41:39 <EvanR> just leave monad alone then
20:41:41 <awpr> it doesn't; this is just about presenting beginner-friendly type signatures
20:41:55 <EvanR> but specializing monad would help sometimes when demonstrating
20:41:56 <yungfool> I think you just want to keep the Monad m constraint
20:42:14 <EvanR> or Functor
20:42:55 <Stratege> awpr when teaching - when will you use a function that relies on monadic behaviour without explaining monads first?
20:43:44 <yungfool> the issue with things like length being generalized is that they're very very commonly used to illustrate basic language concepts using easy to understand types, before typeclasses are introduced. At the point where people begin to learn monads it should probably already be clear what a typeclass is
20:43:45 <EvanR> if you guys can solve this right here, then Mark will be forced to return ;)
20:44:17 <awpr> I'm not personally writing Haskell books or teaching courses; but apparently LYAH teaches IO before typeclasses and Monad
20:45:29 <kadoban> awpr: What LYAH does pedagogically should probably be taken with a huge grain of salt.
20:46:11 <awpr> someone asked for an example of teaching IO before Monad, and I gave one.  no judgment on whether it's good or bad involved.
20:46:18 <EvanR> after trying to learn scala via a book i have no idea how youre supposed to teach a programming language as such
20:46:22 <Welkin> EvanR: who is Mark?
20:46:27 <kadoban> Ah sorry, shouldn't have spoken without the context.
20:46:35 <EvanR> Welkin: the topic is the latest post on ghc-dev mailing list
20:46:44 <Welkin> link?
20:46:55 <KaneTW> https://mail.haskell.org/pipermail/ghc-devs/2015-October/010068.html
20:46:58 <ReinH> yungfool: this is the exact reason for map btw
20:47:06 <EvanR> :t map
20:47:07 <lambdabot> (a -> b) -> [a] -> [b]
20:47:12 <EvanR> ok thats still the same
20:47:33 <EvanR> fwiw ;)
20:47:39 <awpr> actually this could even be a setting in GHCI and Haddock: a URL parameter that says "specialize all Traversable to []".  then books can keep teaching 'length' as [a] -> Int, and power users can use it at any Traversable.
20:47:55 <KaneTW> URL?
20:47:57 <yungfool> It makes sense to a degree. If all you're using is do notation, you can sort of gloss over the whole monad point and just treat and treat do as built-in semantics rather than syntax sugar. It also gives a clear example of how a monad can be useful once you actually teach monads. (though it doesn't really solve the issue where beginners conflate the
20:47:57 <yungfool>  special side-effect semantics of IO with being a magical behavior of all monads)
20:48:00 <ReinH> Just use GHC 7.8 :p
20:48:08 <Welkin> EvanR: oh god
20:48:11 <Welkin> wtf???
20:48:18 <Welkin> that reads like an onion article
20:48:20 <ReinH> EvanR: map exists to make the type signature easier to understand compared to fmap :p
20:48:37 <Welkin> who cares about "wider adoption"
20:48:38 <EvanR> and it escaped AMPs and FTPs
20:48:42 <Stratege> awpr it's true LYAH explains monads before IO, and anyone who I tell about reading LYAH I tell to skip the IO chapter until later for exactly that reason. It goes "suddenly magic, just accept it" and I'd say that's bad ^^
20:48:48 <Welkin> prelude causes major problems for the people who *actually* use haskell
20:48:49 <yungfool> flength for Foldable length. ez language design.
20:48:55 <Welkin> so we use things like ClassyPrelude instead
20:49:01 <ReinH> Stratege: which is among the problems with LYAH
20:49:12 <ReinH> Welkin: we do?
20:49:16 <Welkin> ReinH: I do
20:49:26 <EvanR> fsounds fgood
20:49:30 <ReinH> I haven't worked anywhere that has used an alternative prelude, but YMMV
20:49:41 <ReinH> I can see why someone might prefer one
20:50:41 <ReinH> I actually think there's an interesting monad tutorial to be had explaining how do notation was invented and why, e.g., it can be refatored easily
20:50:47 <KaneTW> maybe a language extension -XBeginner
20:50:47 <ReinH> *refactored
20:50:56 <Stratege> ReinH I'm curious, which other ones exist? I personally found it to be a decent primer and the people I've recommended it to or who read it independently appear to have learned decent haskell basics by now.
20:51:15 <EvanR> KaneTW: cool
20:51:18 <KaneTW> that specializes foldable/traversable to [] by default and defaults to [] when an instance of those is ambiguous
20:51:22 <ReinH> Stratege: Given the paucity of beginner Haskell tutorials, it still has some value. But it is objectively not very good.
20:51:33 <Stratege> Welkin what problems arise from the generalized prelude? I haven't gotten around to a larger project in haskell since then.
20:51:46 <ReinH> Stratege: I think http://dev.stephendiehl.com/hask is much better, but it could use a bit more of a narrative
20:51:47 <Welkin> Stratege: it isn't general enough
20:52:16 <Welkin> so you find yourself importing Data.Text to perform operations like `elem` on Text
20:52:36 <EvanR> :t elem
20:52:37 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
20:52:48 <Welkin> EvanR: sure, that was after the FTP
20:53:06 <Welkin> also, show
20:53:08 <Welkin> :t show
20:53:09 <ReinH> Welkin: doesn't matter
20:53:09 <lambdabot> Show a => a -> String
20:53:19 <ReinH> Welkin: text is not a Foldable
20:53:29 <ReinH> It's MonoFoldable or w/e
20:53:38 <Welkin> MonoTraversable
20:53:43 <nitrix> I feel like Text could be a foldable, no?
20:53:47 <EvanR> wrong kind
20:53:58 <KaneTW> @hoogle Text
20:53:59 <lambdabot> Data.Generics.Text module Data.Generics.Text
20:53:59 <lambdabot> Data.Text module Data.Text
20:53:59 <lambdabot> Generics.SYB.Text module Generics.SYB.Text
20:54:24 <ReinH> Welkin: mono-traversable provides a MonoFoldable typeclass
20:54:26 <Welkin> https://hackage.haskell.org/package/mono-traversable-0.9.3/docs/Data-MonoTraversable.html#v:oelem
20:54:29 <Welkin> yeah
20:54:45 <KaneTW> nitrix: Text :: *, but Foldable (m :: * -> *)
20:54:56 <ReinH> Welkin: Which has an elem function. So. :p
20:54:58 <nitrix> Interesting.
20:55:26 <nitrix> So, wait, so something of kind * -> *, Maybe is one.
20:55:26 <ReinH> nitrix: Text has the wrong kind
20:55:32 <nitrix> Foldable Maybe would work?
20:55:47 <ReinH> nitrix: Maybe is Foldable
20:55:51 <EvanR> > fold (Just (Product 1))
20:55:52 <lambdabot>  Product {getProduct = 1}
20:55:58 <KaneTW> i wish :i worked with lambdabot 
20:56:30 <nitrix> Great. I'm just refreshing what I know whenever I can to confirm my own learnings.
20:56:47 <nitrix> I don't spend enough time in here. I really should.
20:56:49 <EvanR> > fold (Nothing :: Maybe (Product Int))
20:56:50 <lambdabot>  Product {getProduct = 1}
20:58:11 <pavonia> :t fold
20:58:12 <lambdabot> (Foldable t, Monoid m) => t m -> m
20:59:07 <KaneTW> :t folr
20:59:08 <lambdabot>     Not in scope: ‘folr’
20:59:09 <lambdabot>     Perhaps you meant one of these:
20:59:09 <lambdabot>       ‘foldr’ (imported from Data.List),
20:59:10 <KaneTW> :t foldr
20:59:11 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
20:59:15 <MarcelineVQ> https://wiki.haskell.org/Typeclassopedia has a good section on monoids if you need one pavonia
20:59:35 <pavonia> I don't, thanks
21:01:43 <KaneTW> https://ghc.haskell.org/trac/ghc/ticket/10963
21:07:22 <roconnor> KaneTW: you should do Num while you are at it.
21:07:45 <roconnor> :type (+)
21:07:50 <roconnor> @type (+)
21:07:51 <lambdabot> Num a => a -> a -> a
21:07:54 <roconnor> is confusing for beginners
21:09:01 <profsimm> Is nullipotent a correct term to describe a function without side effects (pure)?
21:09:55 <roconnor> profsimm: arguably.
21:10:04 <profsimm> roconnor: well..
21:10:11 <profsimm> roconnor: ok argue it :P
21:10:27 <EvanR> Num a => a -> a -> a is the only thing that made sense when i started
21:10:47 <EvanR> it introduces a lot of the features of haskell
21:10:49 <roconnor> If, for example, I had a function a -> State s b, but it only read from the state and didn't modify it, I'd call it nullipotent.
21:11:19 <EvanR> binary function (curried) which must have both arguments the same, and be a Num in some sense
21:12:31 <ReinH> roconnor: o/
21:12:33 <profsimm> roconnor: so what would be the difference between "pure" and "nulipotent"
21:12:35 <roconnor> But when talking about function of the form a -> m b, I am wearing my Kleisli googles.
21:12:49 <profsimm> Aside from one has a typo in it :P
21:12:52 <roconnor> profsimm: pure wouldn't even read the state.
21:13:02 <profsimm> Hmm
21:13:04 <roconnor> again, I'm wearing Kleisli googles here.
21:13:10 <ReinH> profsimm: I suppose the difference is that nullipotent has a definition
21:13:12 <profsimm> roconnor: I don't get it
21:13:31 <ReinH> I wouln't call anything involving StateT impure
21:13:34 <yungfool> what's the point of EmptyCase? placeholder code?
21:13:37 <ReinH> Or anything else, really
21:13:45 <ReinH> yungfool: EmptyCase?
21:13:47 <awpr> yungfool: pattern matching on Void, basically
21:13:50 <ReinH> Oh the extension
21:14:14 <yungfool> so... placeholder code. got it. :P
21:14:21 <EvanR> to go with EmptyDataDecl
21:14:21 <roconnor> profsimm: we use often use a pure function of type a -> m b to represent a (possibly) impure function from a to b with regards to some effects represented by m.
21:14:35 <roconnor> maybe "captured by m" would be a better way of saying it.
21:14:49 <EvanR> yungfool: some libs use an empty type to some effect
21:15:01 <roconnor> So when I think of a -> m b as a sideffectfull opration from a to b I say I'm wearing my Kleisli googles.
21:15:05 <EvanR> like pipes
21:15:06 <yungfool> yes I understand that, but isn't case ... of { } just undefined?
21:15:11 <ReinH> roconnor: :)
21:15:16 <roconnor> My Kleisli googles make functions of type a -> m b look like functions from a to b.
21:15:50 <MarcelineVQ> That's too much power for one man!
21:16:31 <EvanR> yungfool: hmmm, undefined can be evaluated in valid haskell code, but hopefully you never end up in a position to check those cases thanks to the type system?
21:16:37 <roconnor> Then we can talk about whether these functions from a to b are pure or nullipotent or idempotent.
21:17:11 <roconnor> as long as we are considering effects that could have functions that give rise to those properties.
21:17:12 <yungfool> is there any semantic difference at all between writing "undefined" and writing "case ... of {}
21:17:13 <aarvar> aren't functions with no side effects just called functions?
21:17:18 <yungfool> that's all I want to know really.
21:17:29 <ReinH> If a function a -> m b is impure because it builds some sort of m-structure then pure is a boring word that I dn't want to use any more. :p
21:17:31 <yungfool> I know how undefined can be used with empty data declarations and phantom types and all that.
21:17:31 <EvanR> yungfool: whats the type of the empty case?
21:17:48 <profsimm> robogoat: I thank you very much for explaining this to me, but I honestly... I have... not the faintest of ideas what your Kleisli glasses work like :P
21:17:51 <julianleviston> ReinH: haha “subjective purity” lol
21:17:52 <yungfool> forall a. a?
21:18:01 <julianleviston> ReinH: special relativity of purity?
21:18:01 <EvanR> then its the same ;)
21:18:11 <roconnor> so these a to b functions can be pure, if they don't access the state, or nullipotnent if they only read from the state, or idempotent if when they are chained together they are the same as using it once.
21:18:12 <yungfool> so I guess my next question then is "why"
21:18:13 <ReinH> I just prefer to say that functions in Haskell are pure.
21:18:27 <yungfool> I mean I understand people don't like writing "undefined", but an empty case isn't much better.
21:18:29 <ReinH> I guess roconnor and I disagree about terminology.
21:18:30 <EvanR> only bottom inhabits all types
21:19:01 <roconnor> ReinH: well clearly a Haskell function a -> m b is a pure function because all functions in haskell are pure.
21:19:07 <EvanR> with an empty case you dont have to write a non empty case and then undefined
21:19:32 <profsimm> roconnor: I thank you very much for explaining this to me, but I honestly... I have... not the faintest of ideas what your Kleisli glasses work like :P
21:19:34 <roconnor> They only look impure if you are using Kleisli googles, but the the Kleisli googles on then the result type is b not m b.
21:19:45 <EvanR> or ... `seq` undefined
21:19:46 <profsimm> roconnor: why is State special
21:20:21 <ReinH> roconnor: ah
21:20:36 <roconnor> profsimm: State is one of the monads such that we can consider function of type Kleisli m a b as being pure, nullipotent or idempotent.
21:20:52 <roconnor> @hoogle Kleisli
21:20:52 <lambdabot> Control.Arrow Kleisli :: (a -> m b) -> Kleisli m a b
21:20:53 <lambdabot> Control.Arrow newtype Kleisli m a b
21:20:53 <lambdabot> package Kleislify
21:21:08 <yungfool> EvanR: so basically your use case for EmptyCase is: I've written a case expression but I haven't written any patterns yet, and I want this to compile correctly while I solve other compiler issues, and I'm too lazy to add undefined. Time to add a LANGUAGE pragma for this because this is somehow a better choice.
21:21:25 <EvanR> yungfool: and im sure the case wont be evaluated
21:21:47 <EvanR> undefined to me seems like the wrong word?
21:21:57 <EvanR> more like "impossible"
21:22:08 <profsimm> roconnor: thans
21:22:10 <profsimm> thanks
21:22:36 <EvanR> yungfool: no i was not thinking this was placeholder code
21:22:58 <roconnor> functions of type Kleisli Identity a b, for example, are always pure.  It doesn't make much sense to talk about if they are nullipotent or idempotent.
21:23:28 <roconnor> Functions of type Kleisli (Cont r) a b, I have no idea if nullipotent would mean anything.
21:23:43 <ReinH> roconnor: which m other than State or StateT does it mean something for?
21:23:54 <EvanR> IO!
21:24:11 <ReinH> which is a state monad :p
21:24:22 <EvanR> i beg your pardon
21:24:37 <ReinH> IO is a fancy state monad
21:24:43 <EvanR> better
21:24:43 <ReinH> Just look at the definition
21:24:46 <roconnor> ReinH: well I think I'd distinguish between Kleisli (Reader r) a b as pure if it doesn't access the enviroment, and impure otherwise.  I suppose they are all trivially nullipotent, so I guess then it doesn't make much sense to talk about it.
21:24:56 <EvanR> IO is abstract, i cant
21:25:02 <ReinH> EvanR: sure you can
21:25:05 <EvanR> rather i would prefer not to
21:25:07 <ReinH> roconnor: Right
21:25:27 <roconnor> ReinH: I don't know, nullipotent and idepotent feel like they are meant in a stateful effect context.
21:25:28 <yungfool> okay so I've now read the actual feature request for EmptyCase and it makes a little bit more sense. It's about as niche of a thing as I thought it would be.
21:25:33 <ReinH> roconnor: yeah
21:25:48 <roconnor> ReinH: But I'd entertain other contexts.
21:27:00 <EvanR> deconstructing an empty data type? ;)
21:28:54 <roconnor> I'm surprised people are so worked up about foldable-traversable.  We are finally free of the shakles of the list type.  That coupled with traversals and lenses mean we will all finally be able to manipulate actual data structures and we don't have to squeeze everything through the toothpaste tube that are lists.
21:29:38 <awpr> Haskell Prime: Please Stop Saying We're Like Lisp
21:31:27 <shachaf> We're still squeezing things through the toothpaste tube that is "a sequence of elements".
21:32:05 <julianleviston> shachaf: lookup into a balanced tree isn’t really sequencing is it? Just wondering
21:32:11 <roconnor> shachaf: Most traversables (which are foldable) are not just sequences of elements.  They usually have non-trivial shapes.
21:32:25 <arkeet> julianleviston: that's not even a Functor.
21:32:42 <shachaf> Yes, but the view that Traversable/Foldable gives you is a sequence of elements.
21:32:44 <arkeet> if you're talking about search trees.
21:32:54 <arkeet> shachaf: well you can cheat a little.
21:33:01 <arkeet> you get a binary tre.
21:33:01 <arkeet> e
21:33:07 <EvanR> hold on a perfectly balanced tree of a is not a functor?
21:33:09 <shachaf> If you break laws, sure.
21:33:12 <roconnor> shachaf: traversable does more than give you a sequence of elements.
21:33:17 <shachaf> But roconnor doesn't even believe in infinite traversals.
21:33:41 <shachaf> roconnor: That's true. But Foldable is pretty much (disallowing infinite traversals etc.) just a class that has a toList function.
21:33:50 <julianleviston> shachaf: I was thinking of, say, something with a wide branching level… but yeah, I have no idea about T/F, really. . . was just curious.
21:34:17 <EvanR> theres a blog post floating around about how Foldable isn't just `toList'
21:34:23 <roconnor> shachaf: sure, but foldables don't have a fromList function.
21:34:51 <julianleviston> shachaf: I guess if the thing you need *is* in sequence, then a sequenced thing is probably what you need? (lol).
21:35:15 <arkeet> Foldable gives you a view as a list.
21:35:22 <roconnor> traversables are really much more important.
21:36:17 <julianleviston> I’m assuming the “shackles” of a list are the time required to do common things like look things up by index, or get to the end of it?
21:36:54 <Clint> no, they're those ugly brackets
21:37:03 <roconnor> julianleviston: the shackles of the list are that you have to use list and you cannot use seq, or a finger-tree, or anything else that might be more useful in your particular case.
21:37:18 <julianleviston> roconnor: what does seq (the function) have to do with lists? 
21:37:30 <roconnor> Sorry, I mean Seq
21:37:32 <julianleviston> roconnor: wait… why do you have to use these things?
21:37:50 <julianleviston> roconnor: I mean… why are you (ordinarily) not able to use these things?
21:37:58 <roconnor> That said I lists are great and they are useful most of the time.
21:38:20 <roconnor> julianleviston: because someone wrote an function in some library that takes a list instead of taking a foldable.
21:38:30 <roconnor> julianleviston: so now I have to call toList.
21:38:38 <roconnor> and pray it fuses away.
21:38:48 <yungfool> I've personally has no issues importing Text and using it instead of [Char]  >:D
21:38:56 <shachaf> It's not going to fuse away.
21:39:10 <julianleviston> roconnor: ah… that’s probably one of the nice things about Clojure’s seq abstraction being there from the beginning, I guess… but he basically just stole it from Haskell, right...?
21:39:13 <shachaf> But the situation with Foldable is unlikely to be better.
21:39:19 <EvanR> julianleviston: did you see this conal talk? its awesome for showing a case where lists suck and something else doesn't :) http://begriffs.com/posts/2015-06-28-haskell-to-hardware.html
21:39:30 <julianleviston> EvanR:  thanks I’ll have a look
21:39:38 <roconnor> julianleviston: I'm not familiar with Clojure.
21:39:53 <EvanR> julianleviston: clojures seq abstraction is pretty awful
21:40:11 <julianleviston> roconnor: uses vectors instead of lists, mostly… has some different syntax than lisp, runs on JVM, and has a seq abstraction over the first class vectors, maps and sets.
21:40:15 <EvanR> actually all the stdlib abstractions are bad
21:40:18 <julianleviston> EvanR: yeah? fair enough.
21:40:26 <EvanR> julianleviston: vectors or "seqs"
21:40:35 <julianleviston> EvanR:  in what way is it awful?
21:40:50 <julianleviston> EvanR: huh? vectors aren’t seq. Seq is an abstraction. Vector is a type of collection.
21:40:58 <julianleviston> EvanR:  in clojure.
21:40:59 <EvanR> julianleviston: see? ;)
21:41:05 <julianleviston> EvanR:  that’s a good thing, tho
21:41:19 <EvanR> seq, seqs, Seq arent well defined
21:41:24 <julianleviston> EvanR: it means all the code just cares that it takes a collection… (the abstraction)
21:41:37 <julianleviston> EvanR: I don’t think that’s true.
21:41:39 <EvanR> we can talk about clojure somewhere else
21:41:47 <julianleviston> EvanR: sorry. yep. mouth zipped.
21:42:53 <EvanR> the problems they are talking about with Foldable are even worse in clojure, just no one knows ;)
21:43:48 <EvanR> and the idea of a "noob mode" for traversable probably wont go anywhere
21:43:50 <yungfool> and here I was, happily and obliviously writing Haskell code, not realizing all of these problems with the language. :P
21:43:51 <julianleviston> EvanR: no doubt. I was only commenting on the API, really.
21:44:37 <EvanR> check #haskell-blah and ill ask about the API
21:44:59 <roconnor> yungfool: well the problem with Haskell Prelude are not very severe.
21:45:46 <roconnor> yungfool: I was just slowly hiding more and more of the Prelude as time went on and we developed more abstract, better libraries, like Traversable.
21:46:23 <roconnor> Well I guess I just stopped using mapM and used traverse instead.
21:47:28 <roconnor> I suppose we didn't *need* to update the Prelude.  We could have let it fall into disuse ;)
22:11:25 * hackagebot elo 0.1.0 - Elo Rating Library  https://hackage.haskell.org/package/elo-0.1.0 (markfine)
22:11:54 <julianleviston> As we have “Sum” and “Product” in our data type algebra… is an “Exponential” actually a function?
22:12:19 <EvanR> yeah
22:12:38 <julianleviston> That’s really nice.
22:14:14 <srhb> julianleviston: http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/ -- might interest you
22:14:45 <julianleviston> srhb: <3 thanks
22:15:06 <julianleviston> sometimes this language makes me want to cry, it’s so beautifully elegant… mostly.
22:19:41 <Stratege> julianleviston then don't look at gui or web dev in haskell or you might cry for a different reason.
22:20:28 <julianleviston> Stratege: :) sadly I am :) But it’s fine.
22:21:41 <julianleviston> Stratege: using Snap as my basic servy thing, and write my own stuff on top of that.
22:22:38 <Stratege> julianleviston does that have in some way some of the beauty found in the more theory orientated parts of haskell? (please say it is so xD)
22:23:10 <julianleviston> Stratege: I’m not that good at Haskell yet! haha :)
22:23:52 <profsimm> Damn, I can't figure out how to describe a program which, if you feed the output into the input, produces the same output.
22:24:00 <yungfool> when was Word added to Prelude?
22:24:00 <profsimm> That's idempotent sort of.
22:24:18 <julianleviston> profsimm: that’s the definition of idempotency, isn’t it?
22:24:19 <abh> profsimm: referentially transparent
22:24:50 <abh> oh wait. feed output into input. yes, idempotent.
22:24:56 <profsimm> julianleviston: the problem is idempotency is also used in one another sense: you feed input, and it produces effect first time; next time it just returns same output
22:25:12 <julianleviston> profsimm: how does what you mean differ?
22:25:26 <julianleviston> profsimm: do you just mean “id”?
22:26:08 <Stratege_> julianleviston shame xD here I was hoping for a ray of hope
22:26:16 <profsimm> julianleviston: former is f(x) = y, f(y) = y,   and latter is  f(x) = y;   f(y) != y, and effect occurs only first time you call f(x)
22:26:26 <srhb> profsimm: That second sense seems like a rather ad-hoc redefinition of idempotency.
22:26:32 <julianleviston> Stratege: I pretty much just want to chain a set of flows of data through a bunch of data-caching functions…. and have them reconfigurable… kind of like apache samza, but using code as well as data, and not “limited” to running on Kafka.
22:26:43 <profsimm> srhb: well there you go.
22:27:12 <profsimm> srhb: http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html
22:27:12 <julianleviston> profsimm const?
22:27:22 <profsimm> srhb: this is how PUT and DELETE are defined
22:27:44 <srhb> profsimm: Sure, but still. The first sense is the original one.
22:27:54 <profsimm> srhb: definitely.
22:28:05 <julianleviston> profsimm: I really don’t understand. Can you explain with a couple of ints?
22:28:08 <profsimm> srhb: but how do I differentiate both as properties of my programs.
22:28:12 <Stratege_> julianleviston never used apache samza so that part of the description is lost on me. same for kafka. The only Kafka I know is the writer ^^
22:28:30 <srhb> profsimm: I would explicitly state things about actions being performed only once, if that was a property of my program.
22:28:38 <srhb> profsimm: And use idempotency in the original sense.
22:28:55 <profsimm> srhb: ok so what would be a neat word to use for "actions performed once"
22:29:04 <srhb> "actions performed once"
22:29:07 <srhb> That seems clear and nice.
22:29:14 <profsimm> srhb: I need a term :P
22:29:19 <srhb> OK, no idea then.
22:29:24 <profsimm> srhb: ok thanks :D
22:29:29 <julianleviston> Stratege_: normally, the DB is one single source of truth… this works differently… there are many “caches” and they all flow through, keeping data where they need for “instant reads”, and writes happen by updating a streaming log… (think of a river flowing, and people living on the river taking the water that is needed as it flows past”
22:29:36 <profsimm> julianleviston: well did you check out the HTTP spec
22:29:38 <srhb> profsimm: GHC has a concept of dupable IO.
22:30:20 <srhb> profsimm: ie. it calls the function which may actually run IO actions twice, omitting the safety check, unsafePerformDupableIO
22:30:29 <profsimm> srhb:  what is that
22:30:36 <profsimm> oh
22:30:37 <srhb> profsimm: You know unsafePerformIO?
22:30:42 <julianleviston> profsimm: isn’t that just idempotency?
22:30:42 <Stratege_> julianleviston this is a bad time to say that I'm of the Dijkstra school of "metaphors are evil"? ^^ But I suppose I kinda sorta get it.
22:31:21 <profsimm> julianleviston: it's not the meaning of idempotency which is purely functional
22:31:29 <profsimm> julianleviston: there are two definitions used apparently
22:31:31 <julianleviston> Stratege_: it’s literally a log of changes. Each chunk of code takes the data it needs from a subscription and does its own processing, and avails its downstream code of the opportunity to read ITS “log” of changes.
22:31:41 <profsimm> julianleviston: one is about pure functions, one is about side-effecty functions
22:32:30 <julianleviston> profsimm: I view them as identical, with respect to, say, a tuple of values (1,2) <- update 1 to 5 (5,2), ok so the value is 5… (basically State Monad)
22:32:37 <Stratege_> julianleviston oh! basically a reactive system of sorts? (although discrete instead of continous, in your case)
22:33:00 <julianleviston> Stratege_: completely… but “reactive” is so convoluted, I still would have had to explain it.
22:33:27 <julianleviston> Stratege_: … because… if you do anything remotely complicated with the web, you need to treat everything in this way, really…
22:33:30 <profsimm> julianleviston:   (1, 2) -> (5, 1)  and (5, 1) -> (5, 1), but in the HTTP definition  (1, 2) -> something   and something -> nothing
22:33:35 <profsimm> julianleviston:  :P
22:33:58 <profsimm> julianleviston: in the HTTP definition the output isn't necessarily the idempotent result
22:34:06 <profsimm> julianleviston: it's some other result, you can feed it back
22:34:15 <profsimm> julianleviston:  I mean you CAN'T feed it back
22:34:17 <julianleviston> profsimm: yeah, that’s just side effects you’re describing. For the web, DELETE /files/1 -> DELETED, and DELETE /files/1 again -> ERROR, right?
22:34:28 <profsimm> julianleviston: yea
22:34:40 <profsimm> julianleviston: which is a really stupid way to define idempotency :P
22:34:45 <profsimm> julianleviston:  but there we go...
22:35:17 <julianleviston> profsimm: they mean “you can perform an action multiple times, but it will only have an effect, if it does, once”. I think… 
22:35:36 <srhb> Idempotency of effects... There really isn't one unique word to describe this.
22:35:41 <srhb> However much you want it. :-)
22:36:09 <julianleviston> profsimm: it’s also wrong… 
22:36:26 <julianleviston> profsimm: “the side-effects of N > 0 identical requests is the same as for a single request."
22:36:58 <julianleviston> profsimm: that’s simply not true for DELETE, and also, if the resource that a GET is after is removed between two GETs, it won’t be there, so it will have a different response.
22:38:23 <julianleviston> profsimm: but they’re only talking about the “side effect idempotency” whatever THAT means… they really should not use that word.
22:42:07 <srhb> julianleviston: I think that ship has long sailed. It's in use in the Wiki article, and I've seen things like Ansible docs use the term as well.
22:42:27 <julianleviston> srhb: sorry?
22:42:38 <julianleviston> srhb:  not sure what you’re talking about.
22:44:09 <tdammers> HTTP relaxes the requirements for idempotency for pragmatic reasons, and somehow the commonly used definition got watered down to match with the existing reality
22:45:00 <srhb> julianleviston: I mean: I think it's too late to avoid this sense of the word. It's in the wild, and has been for a long time.
22:45:09 <julianleviston> srhb: ah right.
22:45:27 <julianleviston> srhb: people en-masse do something bizarre to deep ideas.
22:45:48 <tdammers> see also, the JS community's usage of the word "isomorphic"
22:46:05 <julianleviston> tdammers: yeah, I’ve seen that. A little piece of me died inside.
22:46:22 <julianleviston> tdammers: it’s like… isomorphic with respect to client/server or something.
22:46:27 <tdammers> also: "type", "function", "homoiconic", ...
22:46:31 <srhb> I relegate it to "all terms are context specific" and move on with only a minor involuntary stress twitch.
22:46:49 <julianleviston> srhb: exactly! :) hehe context creates semantics.
22:47:26 <tdammers> julianleviston: not even that. I think the reasoning is something like "'iso-' means 'same', right? and '-morphic' is something about what it looks like, so 'isomorphic' somehow means 'same on both'... let's use that!"
22:47:50 <julianleviston> tdammers: that’s exactly what isomorphic means… “similar form and operations to”
22:47:56 <tdammers> it's not, though
22:48:03 <julianleviston> tdammers: isn’t it?
22:48:06 <Stratege_> julianleviston btw if you want to do some reactive-ish stuff in haskell, you might want to look into FRP if you haven't yet. Uses a continous values instead of a discrete values based system, but might still be what you want + has some decent popularity in haskell.
22:48:09 <julianleviston> tdammers: ;-) what does it mean then?
22:48:12 <tdammers> it means "similarly shaped", for a relatively narrow meaning of "similar" and "shape"
22:48:47 <julianleviston> Stratege_: I *do* mean continuous values… but as a set of events. I’m pretty familiar with FRP, but not in Haskell (the sheer number of libraries scared me to death)
22:49:02 <julianleviston> tdammers: I think originally it comes from geology, doesn’t it? ;-)
22:49:15 <tdammers> it is usually taken to mean "analogous structures expressed in different domains"
22:49:40 * julianleviston looks with disdain at isomorphic.net
22:49:40 <Stratege> isn't "continous values but as a set of discrete things" a contradiction? ^^
22:50:00 <julianleviston> Stratege: who said there was a set of discrete things?
22:50:17 <Stratege> julianleviston are events not discrete things?
22:50:22 <julianleviston> Stratege: I mean, other than the fact that *somewhere* you have to say what something’s identity is :-)
22:50:34 <julianleviston> Stratege: not if you view them as a stream.
22:50:41 <tdammers> in FRP, an Event is a "stream" of discrete occurrences in a continuous domain (usually time)
22:50:42 <julianleviston> Stratege: [Int] for example?
22:50:55 <julianleviston> tdammers: thanks.
22:51:25 <Stratege> ah *nods* I've heard that referred to as a signal and the discrete thing as an event. Thus my question.
22:51:40 <julianleviston> Stratege: exactly the case :)
22:52:24 <julianleviston> Stratege: sorry if my langauges isn’t precise enough. 
22:53:30 <julianleviston> Stratege: language use* LOL!
22:53:32 <Stratege> *shrugs* my PoV on that is: As long as one is open to clarification questions it's not that big a deal how precise ones language is. As long as it doesn't go into full on buzzword bingo territory ofc xD
22:53:35 <tdammers> I think the conventional names are Event (for the stream) and Behavior (for a continuous signal)
22:54:03 <julianleviston> tdammers: they seem the same thing.
22:54:19 <julianleviston> tdammers: Event sounds like “at this time, this was the value"
22:54:26 <tdammers> yes
22:54:30 <julianleviston> tdammers: as in “Clicked on button at 5.00pm"
22:54:42 <tdammers> Behavior is "given a time, I can tell you the value"
22:54:51 <julianleviston> tdammers: whereas Stream sounds like “a series of events over time” as one “thing”…
22:54:59 <tdammers> behaviors are, conceptually, t -> v; events are [(t, v)]
22:55:14 <julianleviston> tdammers: yes, but why [] wrapping the (t,v) ?
22:55:28 <tdammers> because the event can contain more than one occurrence
22:55:31 <julianleviston> tdammers: or was that Event :: (t,v), Events :: [(t,v)]
22:55:46 <tdammers> "event" is the stream
22:55:57 <julianleviston> tdammers: ah, so you have Event :: [Occurrence] , Occurrence :: (t,v) ?
22:56:02 <tdammers> something like that, yes
22:56:16 <tdammers> you can, of course, express an Event as a Behavior
22:56:33 <julianleviston> tdammers: ah. ok. To me an event doesn’t have more than one occurrence. But that’s just the way my brain works. If someone clicks once, that’s one single event (time / value combo)
22:56:46 <tdammers> yeah, I think that was the original FRP approach too
22:56:49 <julianleviston> tdammers: so what’s a behaviour?
22:56:53 <julianleviston> tdammers: ok.
22:57:08 <tdammers> conceptually, a function of a value over (continuous) time
22:57:09 <Stratege> afaik the original FRP approach was that everything is t -> v
22:57:15 <julianleviston> I think I like… Signal :: [Event], Event :: (t,v)
22:57:30 <julianleviston> tdammers: ah ok
22:57:37 <julianleviston> tdammers: I guess I’m viewing it as data rather than functions.
22:57:51 <tdammers> Stratege: yeah, that works, but sometimes it is convenient to look at Events as streams of occurrences
22:58:04 <tdammers> also, yes, viewing it as data is kind of the point
22:58:12 <tdammers> anyway, time to haul kids to school
22:58:23 <julianleviston> tdammers: that does sound interesting. I’ll have to look it up.
22:58:25 <julianleviston> tdammers: thanks.
23:06:27 * hackagebot vector-th-unbox 0.2.1.3 - Deriver for Data.Vector.Unboxed using Template Haskell  https://hackage.haskell.org/package/vector-th-unbox-0.2.1.3 (LiyangHu)
23:15:17 <profsimm> Ok so I think people say "side effects" when they should say "effects" sometimes. What is the official definition of "side" in "side effects"?
23:18:37 <pavonia> profsimm: To me "side effects" expresses more unexpected behaviour than just "effects"
23:18:40 <julianleviston> profsimm: I thought side effects were adverse effects…
23:18:44 <johnw> profsimm: consider the type "f a".  I think "side" is used to refer to the 'f' instead of the 'a'; but it's not a good term.  There is no side effect, just a value. Only the runtime can have the sorts of effects people are usually thinking of.
23:19:27 <profsimm> All right this aligns with how I see it mostly. Thanks folks!
23:19:58 <profsimm> Effects = non-functional IO/mutation; Side Effects - unexpected/unintentional/non-obvious effects
23:20:14 <julianleviston> erm
23:20:55 <Stratege> I'd have honestly just taken "side effects" a singular term to mean "things that are not what the function returns but still occur because of it"
23:21:12 <Stratege> or something along those lines.
23:21:36 <julianleviston> Stratege: yeah, which is why most monadic actions are actually pure.
23:22:10 <johnw> if a Haskell function returns, and does not use IO in some unsafe way, then it's output always depends on its inputs
23:23:03 <johnw> IO effects can only occur when the runtime is executing an action resulting from a function in IO; but the action itself is always a reproducible value
23:23:20 <johnw> @quote ls
23:23:21 <lambdabot> matthew_- says: so if you differentiate a running program, I believe you should get the source code and maybe also the input to the program
23:23:36 <johnw> anyway, it's like the difference between the "ls" program, and running it
23:24:25 <gfixler> I have a gumball machine metaphor in my head
23:24:58 <gfixler> all the IO work in Haskell is like designing a gumball machine to spec, with holes the right size for gumballs and coins, etc
23:25:13 <gfixler> and running that program is sticking it in a grocery store and letting people use it
23:25:30 <gfixler> gumballs can jam, people can smash the wrong coins in, etc
23:25:34 <gfixler> but the machine was perfect
23:25:47 <gfixler> the haskell code just builds the machine, the same way every time
23:26:36 <rola> hello
23:27:02 <julianleviston> rola: ello.
23:27:36 <jle`> RIP Haskell Platform :(
23:27:47 <gfixler> jle`: wha?
23:28:02 <rola> rip in platform
23:28:11 <jle`> maintainer is stepping down, nobody can decide if continuing it is a good idea or not
23:28:16 <gfixler> wow
23:28:21 <gfixler> where's the news?
23:28:38 <gfixler> ah, found it
23:29:23 <jle`> well, i guess it's not certain that it will be gone, this is just my unsolicited prophecy
23:29:43 <mutantmell> It looks like it's transforming to a wrapper around MinGW and Stack
23:29:50 <mutantmell> which seems like it'll be easier to maintain
23:30:45 <gfixler> what's the FTP thing?
23:30:50 <neuroserpens> Who has last seen bytemyapp?
23:30:52 <jle`> FTP always seemed to me like a step to make things *more* serious for real development int he real world
23:30:56 <mutantmell> Foldable Traversable Proposal
23:31:04 <neuroserpens> sorry i was typing his name wrong
23:31:40 <mutantmell> Basically, it moved a lot of the Foldable class into the Prelude, changing a lot of the [a] methods into Foldable t => t a methods
23:31:52 <gfixler> jle`: is this just adding typeclass constraints to things that fit, but didn't have them?
23:32:03 <gfixler> mutantmell: an, right
23:32:14 <gfixler> I've run into some of those, once during a little demo
23:32:24 <jle`> i'm going to defer to other people because i have a deadline in a few minutes, but also this probably wasn't the best place for me to start a debate.
23:32:36 <gfixler> "Let's look at the type of this" (expecting a simple type, seeing Foldable), "umm..."
23:32:36 <kadoban> I don't really have strong feelings on FTP either way. It's … not exactly pretty, but it's quite useful. *shrug*
23:32:46 <jle`> i guess what i was trying to say is that i had no idea it was so controversial and polarizing
23:32:55 <jle`> i thought people were mostly on board or neutral like kadoban 
23:33:01 <Cale> Foldable kind of makes me sad
23:33:20 <gfixler> I'm neutral so far, but curious if Cale can get me riled up about it
23:33:26 <mutantmell> Cale: Because it has no laws associated?
23:33:32 <Cale> mutantmell: Yeah
23:33:40 <Cale> Well, there are some laws, but not really enough
23:33:57 <profsimm> classifying function behavior in time in imperative languages is quite tough. No wonder people prefer pure functions.
23:34:05 * gfixler is less enthused now
23:34:14 <shachaf> Cale: There are?
23:34:22 <jle`> it's sad but i always figured that it was an ugly but meaningful step towards a more real-world usable language
23:34:23 <gfixler> profsimm: that's my hell at work every day these days (Unity/C#)
23:34:32 <Cale> shachaf: There are laws which relate what foldMap does to what the other things do.
23:34:49 <jle`> i didn't realize that some people thought it was both sad and a step *away* from a serious language
23:34:51 <profsimm> gfixler: I'm trying to come up with a system of tags to describe declaratively the effect of a method call...
23:35:08 <gfixler> jle`: my only stumbling block would be in simple, didactic scenarios, but I could just bring/write my own functions as needed during those times to illustrate points
23:35:18 <mutantmell> Cale: As far as I understood, Foldable was basically the free monoid?
23:35:29 <gfixler> profsimm: in a class? is there shared state?
23:35:41 <Cale> Foldable isn't a type (constructor), so it can't be the free monoid.
23:36:01 <mutantmell> Cale: Sorry, *related to the free monoid
23:36:11 <Cale> Also, how do you form a singleton?
23:36:24 <profsimm> gfixler: check preliminary list... IdempotentEffect (write first time only), IdempotentOutput (feedback loop stability), NoEffect (read only, pure query), NoOutput (write only, pure command), DeterministicEffect (repeatable, stable effect), DeterministicOutput (repeatable, stable output)
23:36:26 * mutantmell is tired, and scrambling concepts
23:36:34 <Cale> There's no (Foldable t) => a -> t a
23:36:41 <gfixler> profsimm: ah, now I see
23:36:44 * hackagebot warp 3.1.5 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.1.5 (KazuYamamoto)
23:36:56 <mutantmell> Cale: ok, fair point on that.
23:37:18 <profsimm> gfixler: I stand almost no chance of mere mortals understanding this list... not sure how to make it more understandable
23:37:47 <gfixler> profsimm: lots of examples
23:38:29 <profsimm> gfixler: good point, examples can explain
23:44:35 <rola> what are some resources haskeller to get to know the python ecosystem? what are the approximate equivalents of ghci, hackage, hoogle, etc
23:44:57 <rola> /haskeller/for a haskeller/
23:46:04 <liste> rola: pypi=hackage, python/ipython=ghci, setuptools=Cabal
23:46:26 <liste> pip+virtualenv=cabal-install
23:46:35 <liste> though setuptools may be outdated now
23:46:46 <tdammers> virtualenv ~= cabal sandbox
23:47:37 <ttt_fff> let m = a map, let m' = a map created by taking m, and applying d insert/delete/updat eoperations to m
23:47:42 <ttt_fff> can we compute diffeernece of m, m' in O(d) time?
23:50:32 <liste> I'm not aware of any tools that come close to Hoogle for other languages
23:50:53 <liste> maybe Java/C# could use one?
23:51:06 <tdammers> I'm not even aware of any languages that would be suitable
23:51:14 <tdammers> not mainstream or almost-mainstream ones anyway
23:51:16 <rola> im stugglin without hoogle 
23:51:36 <rola> and auto generated haddock docs
23:51:46 <gfixler> people make up their own types and abstractions in Java/C# constantly
23:52:05 <tdammers> people do that in Haskell too
23:52:21 <liste> most languages have autogenerated docs (:
23:52:21 <gfixler> yeah, but there's a ton of composable, reusable stuff
23:52:25 <tdammers> yes
23:52:36 <gfixler> making hoogle type searches worthwhile
23:52:50 <tdammers> I think the thing that sets Haskell's type system apart in this regard is how far you can go in abstracting type patterns
23:53:02 <tdammers> so that you can search for the "shape" of a type
23:53:19 <gfixler> I think it's also that functions are expressions, not piles of IO-riddled statements
23:53:21 <Stratege> also not being OOP means the types are generally more general.
23:53:35 <tdammers> does it? I'm not sure about that
23:53:36 <rola> i can't find the docs in pypi, am i looking in the wrong place? https://pypi.python.org/pypi/nltk/3.0.5
23:54:14 <gfixler> I could look up a function that takes two types and returns a third in Java, but I wouldn't know about all the side effects it has
23:54:40 <liste> rola pypi doesn't host docs, you need to find them elsewhere (http://www.nltk.org/py-modindex.html for nltk)
23:54:52 <liste> readthedocs has quite a lot of python docs
23:55:02 <rola> oic
23:55:48 <Stratege> tdammers well as long as the constructors are exposed there is no hard bundling of methods and data. Nevermind that in OOP you are generally supposed to hide the implementation entirely and only expose the intention of your thing and eh ... I -guess- nothing is stopping you (apart from maybe the type systems in the OOP languages I know of) of making more general types in a OOP language, but it doesn't appear to be that common.
23:56:46 <frerich> Stratege: I think trying to compare a paradigm like OOP with a language feature (Haskell's type system) is kind of comparing apples with oranges.
23:56:53 <tdammers> indeed
23:57:03 * hackagebot cef 0.1.3 - CEF log format  https://hackage.haskell.org/package/cef-0.1.3 (utdemir)
23:57:05 * hackagebot ncurses 0.2.12 - Modernised bindings to GNU ncurses  https://hackage.haskell.org/package/ncurses-0.2.12 (JohnMillikin)
23:57:21 <Stratege> eh, the shape of the type system and the programming paradigm are linked.
23:57:22 <tdammers> also, implementation hiding is just as common in Haskell as it is in, say, Java
23:58:24 <tdammers> and in fact, I can even imagine an OOP language with a type system that is as expressive as Haskell's
23:58:53 <Stratege> to my knowledge subtyping is found in the type system of languages intended for OOP, but not outside of it. I might be wrong though.
23:58:57 <ggole> OCaml has objects with pretty expressive types - roughly nobody uses them.
