00:00:11 <liste> > 1 / 0
00:00:12 <lambdabot>  Infinity
00:00:36 <Lokathor> i don't get if divide by zero is a joke or not, but lambda bot seems to be surviving
00:00:41 <EvanR> im about to define division by zero as 42, since theres nothing else i can do (no facility for exceptions or anything)
00:00:48 <Hafydd> It's a jape.
00:01:02 <EvanR> Lokathor: well the idris bot would crash, last time i tried
00:01:25 <liste> JS devs do isNaN(stringVarThatMayBeNumeric) all the time...
00:01:28 * liste cringes
00:01:49 <arkeet> > 0 / 0 :: Rational
00:01:49 <jle`> is it the season for horror stories already?
00:01:50 <lambdabot>  *Exception: Ratio has zero denominator
00:01:58 <jle`> that's the ... rational answer
00:02:02 <Hafydd> > 0 / 0 :: CReal
00:02:06 <lambdabot>  mueval-core: Time limit exceeded
00:02:13 <arkeet> :-)
00:02:16 <jle`> too real for me
00:02:24 * EvanR shines a flashlight at face
00:02:26 <nshepperd> if (isNaN(email_address)) { return "Email address passed validation." }
00:02:54 <EvanR> > [3.14 .. 19] :: [Double]
00:02:56 <lambdabot>  [3.14,4.140000000000001,5.140000000000001,6.140000000000001,7.14000000000000...
00:03:19 <liste> isNaN("") == false :-)
00:03:33 <EvanR> "NaN" == NaN
00:03:55 <EvanR> NaNaNaNaNaNaNaNa float man
00:03:56 <Hafydd> NaNNaNNaNNaNNaNNaNNaNNaNNaNNa
00:04:04 <Hafydd> Wat man.
00:04:09 <nshepperd> you wouldn't want your email address to be a number, would you?
00:04:28 <Lokathor> i saw a vid where a guy showed off JS sillyness by adding up arrays and objects and stuff
00:04:40 <Lokathor> and then the crowd could never guess what would happen
00:05:05 <liste> > concat [show 0/0 :: Double...]
00:05:07 <lambdabot>  <hint>:1:21: parse error on input ‘Double...’
00:05:14 <liste> > concat [(show 0/0 :: Double)...]
00:05:16 <lambdabot>      A section must be enclosed in parentheses
00:05:16 <lambdabot>        thus: ((show 0 / 0 :: Double) ...)
00:05:57 <liste> > concat [show (0/0 :: Double)...] -- sorry for spamming
00:05:58 <lambdabot>      A section must be enclosed in parentheses
00:05:59 <lambdabot>        thus: (show (0 / 0 :: Double) ...)
00:06:06 <liste> I give up
00:06:07 <nshepperd> @where wat
00:06:07 <lambdabot> https://www.destroyallsoftware.com/talks/wat
00:06:17 <nshepperd> ^^ yup
00:07:03 <nshepperd> liste: it's complaining about the ... there
00:07:05 <shachaf> Apologizing for spamming while you continue spamming doesn't really work.
00:07:08 <petercommand> liste: only two dots
00:07:14 <ttt_fff> I have a copy of parallel + concurrent programming in haskell. However, what I want, is erlang-like (1) light weight threads and (2) messaging system . Is there something like that for Haskell?
00:07:17 <nshepperd> presumably interpreting it as an operator
00:07:21 <petercommand> > concat [(show 0/0 :: Double)..]
00:07:22 <lambdabot>      Couldn't match type ‘[Char]’ with ‘Double’
00:07:22 <lambdabot>      Expected type: Double
00:07:22 <lambdabot>        Actual type: String
00:07:36 <petercommand> > concat [(show 0 :: Double)..]
00:07:36 <ttt_fff> I have a copy of parallel + concurrent programming in haskell. However, what I want, is erlang-like (1) light weight threads and (2) messaging system . Is there something like that for Haskell? (Note, I'm not after cloud haskell / distibuted computing; I'm interested in concurrency within a single machine / single haskell run time).
00:07:37 <lambdabot>      Couldn't match type ‘[Char]’ with ‘Double’
00:07:37 <lambdabot>      Expected type: Double
00:07:37 <lambdabot>        Actual type: String
00:07:54 <petercommand> > concat [(show (0 :: Double))..]
00:07:55 <lambdabot>      No instance for (Enum [Char])
00:07:55 <lambdabot>        arising from the arithmetic sequence ‘(show (0 :: Double)) .. ’
00:07:55 <lambdabot>      In the first argument of ‘concat’, namely
00:07:55 <nshepperd> -_-
00:08:02 <liste> ttt_fff forkIO and Chan
00:08:04 <EvanR> ttt_fff: theres the async packge
00:08:21 <EvanR> but Chan is like messaging
00:08:34 <ttt_fff> forkIO = haskell threads, not OS threads right?
00:08:38 <liste> yep
00:08:47 <EvanR> theres also TChan which has cool STM properties
00:08:57 <ttt_fff> forkIO = light weight thread, forkOS = OS thread
00:08:59 <ttt_fff> cool :-)
00:09:28 <liste> petercommand /q lambdabot
00:10:11 <petercommand> liste: ?
00:10:30 <ttt_fff> you're being told to stop spamming the channel
00:10:33 <ttt_fff> and talk to lambdabot one on one
00:10:49 <petercommand> sorry about that
00:11:26 <Hafydd> @let spoonIO x = x >> return () -- a lightweight replacement for forkIO.
00:11:27 <lambdabot>  Defined.
00:11:49 <ttt_fff> liste, EvanR: great; this is what I wanted; thanks!
00:11:55 <liste> yw (:
00:12:44 <ttt_fff> actually, I want one more thing. Suppose I am (1) using ghc + snap, (2) using ghcjs, (3) using aseson, (4) using websockets, and (5) have a shared Data.hs file which stores data-decls common to both server and client. Is there a nice way to get a chan-like interface over the websockets?
00:13:56 <EvanR> Chan might not be the best thing for websockets
00:14:00 <EvanR> its unbounded
00:14:26 <funk> hi, cabal install grapefruit-ui-gtk yields src/Internal/UIItem.hs-boot:12:2: lexical error at character 'i' any clues? 
00:14:34 <ttt_fff> okay, a bounded-chan
00:26:16 <SX> Hi, guys. Tell me please, is it possible to assign a type name to function to use it in type diclaration?
00:26:38 <SX> myFunc
00:27:13 <SX> myNextFunc :: myFunc -> Int -> Int
00:27:25 <SX> Like this. 
00:28:05 <SX> MyFunc should be just a type, without implementation
00:28:08 <peddie> SX: are you talking about a type synonym?  'type MyFunction a b = a -> b -> b' ?
00:28:19 <liste> SX you can have "type MyFunc = Double -> Double; myFunc :: MyFunc; myNextFunc :: myFunc -> Int -> Int"
00:28:21 <SX> Yes
00:28:35 <peddie> SX: try it ;)
00:28:36 <SX> So it's done this way? So easy?
00:28:37 <liste> SX you can have "type MyFunc = Double -> Double; myFunc :: MyFunc; myNextFunc :: MyFunc -> Int -> Int"
00:28:43 <SX> Wow!
00:28:48 <SX> Thanks!
00:44:56 * hackagebot GLURaw 1.5.0.2 - A raw binding for the OpenGL graphics system  https://hackage.haskell.org/package/GLURaw-1.5.0.2 (SvenPanne)
00:51:40 <SX> how can I setup stack project to install some packages from local directory instead of stackage or hackage?
00:52:16 <liste> SX https://github.com/commercialhaskell/stack/blob/master/doc/faq.md#i-need-to-use-a-package-or-version-of-a-package-that-is-not-available-on-hackage-what-should-i-do
00:52:32 <liste> that comes up often
00:52:43 <liste> maybe it should be added to lambdabot?
00:54:19 <SX> so if I change dot to path to some other directory (outside of project) it would work too?
00:54:57 <SX> like my local repo for multiple projects
00:55:18 <Walther> :t sequence
00:55:19 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
00:57:51 <mniip> :t sequenceM
00:57:52 <lambdabot>     Not in scope: ‘sequenceM’
00:57:52 <lambdabot>     Perhaps you meant one of these:
00:57:52 <lambdabot>       ‘sequence_’ (imported from Data.Foldable),
00:58:06 <mniip> oh wait, nevermind
00:58:10 <EvanR> sequenceA
00:58:12 <mniip> yes
00:58:19 <mniip> I was looking at the wrong part
00:58:30 <mniip> thinking t would magically turn into a monad
00:59:00 <EvanR> hahhaaha what
00:59:28 <Walther> :t print
00:59:29 <lambdabot> Show a => a -> IO ()
00:59:47 <Walther> :t mapM_
00:59:48 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
00:59:55 <Walther> :t mapM
00:59:56 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
01:00:13 <mniip> hmm
01:00:29 <mniip> if folds are for tearing structures down
01:00:38 <mniip> and traversals are for morphing structures
01:00:46 <mniip> then what corresponds to structure generation?
01:00:53 <EvanR> haskell code
01:00:58 <johnw> mniip: unfoldr
01:00:59 <keko_> a scan?
01:01:17 <keko_> no wait, no
01:01:22 <keko_> unfold is the thing
01:01:47 <keko_> scan is just fold that returns all the immediate values
01:01:56 <keko_> *intermediate
01:02:00 <Walther> i was explained elsewhere that mapM_ is "just an optimization of mapM, when you only care about the side effects and not the return values"
01:02:26 <Walther> however i'm not sure why the other version is Traversable and the other is Foldable
01:02:29 <mniip> johnw, unfoldr is just an example function
01:02:44 <mniip> is there a generic name for this kind of stuff
01:03:10 <frerich> mniip: Maybe you mean 'anamorphism'; a fold is a 'catamorphism'.
01:03:11 <Walther> in the example of `mapM_ print values` (which in my humblest opinion looks a bit awful and terribly difficult to reason for beginners as to why)
01:03:17 <EvanR> anamorphism?
01:03:31 <mniip> frerich, is there a typeclass for anamorphic functions anywhere in haskell?
01:03:44 <mniip> like there is for folds
01:04:00 <EvanR> Walther: theres a function forM_ which is mapM_ with args reversed
01:04:15 <EvanR> Walther: the type signatures are admittedly a little more dense now
01:04:30 <frerich> mniip: I'm not aware of anything like that, no.
01:04:47 <EvanR> forM_ :: Monad m => [a] -> (a -> m b) -> m ()
01:05:09 <Walther> EvanR: regardless of the new "controversial change", it seems to me there's something more fundamentally different about mapM and mapM_ than just skipping the return values
01:05:24 <EvanR> is there?
01:05:34 <EvanR> from the outside observer
01:05:45 <keko_> mapM produces a new structure, mapM_ does not
01:06:31 <merijn> Walther: Oh, I can explain
01:06:44 <Walther> excellent :)
01:06:56 <merijn> Walther: Traversable is for operations that can use/rebuild the underlying structure you are traversing (hence, traverse)
01:07:17 <merijn> Foldable is for operations that can fold values in some structure together, but not necessarily retaining the original structure
01:07:46 <merijn> In other words, Traversable is "more powerful" than Foldable
01:07:50 <mniip> :t traverse
01:07:50 <EvanR> oh wow, they have different constraints
01:07:51 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
01:08:02 <merijn> As a result, not everything that is Foldable is Traversable
01:08:04 <mniip> mhm
01:08:24 <johnw> Buildable has been suggested a few times by different people
01:08:28 <merijn> Walther: Since mapM_ throws away the initial structure as it consumes elements, it merely needs to be Foldable
01:08:35 <Walther> right, so foldable is more "forgiving" / wider category, and traversable is a subset of foldable
01:08:36 <EvanR> that is going to be a lot more to explain 
01:08:45 <merijn> Walther: mapM on the other hand needs to *rebuild* the Traversable as it iterates over elements
01:08:52 <merijn> :t mapM
01:08:53 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
01:08:55 <merijn> :t mapM_
01:08:56 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
01:09:07 <EvanR> Foldable is very generic, almost anything with the right kind is foldable
01:09:20 <merijn> Walther: This means that it needs to somehow preserve/rebuild the initial structure. Hence why mapM requires Traversable
01:09:24 <mniip> ((->) e)
01:09:25 <Walther> EvanR: "right kind"?
01:09:37 <merijn> :k Foldable
01:09:38 <EvanR> it has to be a type constructor with one argument
01:09:38 <lambdabot> (* -> *) -> Constraint
01:09:46 <frerich> Ever since mzero gave that (IMHO compelling) example of how the FTP causes issues, I couldn't resist looking for other funny things. E.g. 'maximum Nothing' typechecks...
01:09:47 <EvanR> like Maybe, or List
01:09:48 <mniip> EvanR, ((->) e)
01:10:20 <quicksilver> frerich: which example?
01:10:22 <merijn> frerich: I don't see how that's a problem?
01:10:29 <EvanR> mniip: huh
01:10:31 <merijn> :t maximum [] -- also typechecks
01:10:33 <lambdabot> Ord a => a
01:10:45 <liste> > maximum []
01:10:47 <lambdabot>  *Exception: Prelude.maximum: empty list
01:10:51 <frerich> merijn: It also makes sense, too. :-}
01:10:53 <frerich> quicksilver: Let me look it up...
01:11:06 <merijn> I fail to see why maximum Nothing is any worse/better than maximum []
01:11:10 <mniip> :t undefined :: Foldable ((->) e) => e
01:11:11 <EvanR> maximum Nothing should be the new slogan
01:11:11 <lambdabot> Foldable ((->) e) => e
01:11:28 <mniip> er
01:11:30 <merijn> Walther: Anyhoo, does that explain the different constraints for mapM/mapM_ for you? :)
01:11:34 <frerich> merijn: It's easy to introduce bugs in your code which used to be caught by the compiler, but not anymore. Same for e.g. 'length'.
01:11:43 <quicksilver> merijn: I do see why it could be confusing to people learning the language.
01:11:55 <quicksilver> that is the price we pay for generalisation certainly.
01:11:58 <merijn> frerich: What does break for length?
01:12:00 <mniip> > fold id
01:12:02 <lambdabot>      No instance for (Show a0)
01:12:02 <lambdabot>        arising from a use of ‘show_M6297609872976000027607’
01:12:02 <lambdabot>      The type variable ‘a0’ is ambiguous
01:12:04 <quicksilver> generalised types == more things typecheck
01:12:07 <mniip> EvanR, ^
01:12:11 <frerich> merijn, quicksilver: This is the example I was referring to: https://www.reddit.com/r/haskell/comments/3ojekh/excuse_me_i_think_this_is_my_stop_haskell_platform/cvy40mi
01:12:16 <EvanR> huh
01:12:23 <Walther> merijn: Yeah, the "traversable is a stricter subset of foldable" bit pretty much did it
01:12:33 <EvanR> :t id
01:12:34 <lambdabot> a -> a
01:12:42 <Walther> it was too easy to think of them as ~opposing structure types instead of similar
01:12:47 <merijn> So far my annoyance with FTP has been "some of my examples in #haskell are more complicated than I intended" vs "Whooo! A lot of my new code magically just works without qualified imports and annoyances"
01:12:57 <merijn> Walther: Note that Foldable is a superclass of Traversable
01:13:07 <merijn> Walther: "class Foldable f => Traversable f where ..."
01:13:24 <mniip> EvanR, Foldable is actually more restricted than Functor
01:13:27 <frerich> merijn: I understand why it typechecks, but I think the fact that it does is actually a step backwards. I'd rather explicitely import a more generic function of, say, length or maximum or so if I really want to work on things other than lists.
01:13:35 <quicksilver> frerich: nod. I agree with him but I don't agree with him :)
01:13:35 <mniip> because not only you can't have contravariance, but you can't have any arrows at all
01:13:37 <mniip> only data
01:13:51 <frerich> quicksilver: What is it with your Zen lately? :-)
01:14:04 <frerich> quicksilver: Or rather, I'd like to un-ask that question.
01:14:11 <EvanR> mniip: yeah i figured it wasnt like Functor, but whats an example of a data type which cant be foldable
01:14:21 <mniip> ((->) e)
01:14:27 <EvanR> data type
01:14:27 <EvanR> data
01:14:31 <quicksilver> frerich: to elaborate: I agree that this is a real problem which we should accept, and face. I happen to think the price is worth paying because the generalised types overall are so beneficial. 
01:14:33 <mniip> data Hom e a = Hom (e -> a)
01:14:44 <EvanR> ok so no functions
01:14:51 <mniip> exactly
01:15:06 <Walther> merijn: exactly, that was what i needed to notice :)
01:15:28 <quicksilver> mniip: there is one axis where foldable is more general than functor though
01:15:33 <merijn> frerich: tbh, I'd have preferred no length in Foldable, but then I'm not even sure I'd have noticed, since I don't think I ever use length
01:15:50 <mniip> quicksilver, yes, it doesn't involve typechanging parametricity
01:15:59 <EvanR> it doesnt have any laws
01:17:16 <mniip> data VeryLawful f a = VeryLawful (f a); instance Foldable VeryLawful where fold _ = mempty
01:17:25 <mniip> err, (VeryLawful f)
01:17:49 <EvanR> which law is that following
01:17:59 <merijn> frerich: I just checked, in all my haskell code the only occurence of length are (lazy) bytestring/text
01:18:16 <mniip> EvanR, it follows all laws which there are, as you say, none
01:20:35 <EvanR> data LawfulEvil
01:21:06 <quicksilver> there is a law for Foldables-which-are-Functors, tho, isn't there?
01:21:40 <mniip> data ChaoticNeutral a = Random a => Chaos (IO a)
01:21:44 <bennofs> quicksilver: it's a free theorem I believe
01:22:46 <quicksilver> bennofs: nod
01:23:59 <quicksilver> bennofs: no, I don't think it is
01:24:07 <quicksilver> bennofs: it's easy to write bad foldable instances
01:24:25 <EvanR> bad in what sense
01:24:25 <quicksilver> bennofs: given a tree I can write a foldable instance which only descends down the right leg
01:24:43 <EvanR> what foldable functor law is this?
01:24:46 <quicksilver> in fact, in Lens terms, you can write a Foldable instance for any 'Fold'
01:24:52 <quicksilver> but there is only one 'right one'
01:24:56 <bennofs> quicksilver: yes, but it still holds that fmap f . toList = toList . fmap f
01:25:12 <bennofs> (if that's the law you're talking about)
01:25:13 <quicksilver> hmph
01:25:19 <quicksilver> you're right
01:25:45 <quicksilver> you need Traversable to get the law I'm after
01:25:53 <bennofs> quicksilver: you might be interested in https://www.fpcomplete.com/user/gbaz/building-up-to-a-point-via-adjunctions
01:26:00 <quicksilver> the law that forbids incomplete folds
01:26:22 <bennofs> quicksilver: yes, Traversable is quite strong, as you can actually "observe" which elements you traverse with a particular choice of f
01:26:55 <quicksilver> but there is no law forbidding incomplete traversals either
01:27:12 <quicksilver> all I can do is make sure the Foldable visits the same elements as the Traversable
01:27:36 <bennofs> quicksilver: there is. I think you cannot satisfy property: over traverse (f . g) = over traverse f . over traverse g  if you visit the same element twice 
01:27:54 <bennofs> or no, sorry, that's wrong I think
01:28:04 <quicksilver> bennofs: doubling up elements breaks laws, yes
01:28:12 <quicksilver> bennofs: but is there a law which forbids missing out elements?
01:28:23 <bennofs> quicksilver: and you must visit all due to paramtricity. You must change the type of the values inside
01:28:38 <quicksilver> ah
01:29:06 <quicksilver> ok so the Traversable/foldMap law is enough to make my Foldable maximal
01:29:13 <quicksilver> but without Traversal I can't get that?
01:29:18 <quicksilver> +be
01:29:26 <bennofs> quicksilver: for Foldable, I think the problem comes from the fact that you want a Foldable instance for data Repeat a = Repeat Int a
01:29:39 <bennofs> quicksilver: that folds the 'a' the given number of times, repeating it
01:29:45 <EvanR> is that true, Traversables cant leave out or double up elements? that means it can only change the shape, right
01:29:54 <quicksilver> EvanR: it means it can't chaneg the shape
01:29:56 <bennofs> quicksilver: it's hard to say what "maximal" means in case you allow such an instance
01:30:11 <EvanR> then it sounds sort of like Functor
01:30:15 <bennofs> EvanR: it can only change the values itself, not the shape or the ordering of the values
01:30:16 <quicksilver> EvanR: it can visit the elements in order and perform an effect
01:30:25 <bennofs> EvanR: in fact, it's like "functor with effectss" :)
01:30:29 <quicksilver> EvanR: yes, it is very much sort of like functor
01:30:39 <quicksilver> :t traverse
01:30:41 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
01:30:41 <quicksilver> :t fmap
01:30:43 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:30:44 <EvanR> its weird to say it cant change the ordering of elements since its changing the type
01:31:00 <quicksilver> the types of travers and fmap are very similar
01:31:09 <EvanR> ok
01:31:12 <quicksilver> rewrite fmap as
01:31:21 <quicksilver> Functor t => (a -> b) -> t a -> t b
01:31:26 <bennofs> EvanR: or wait, I'm not so sure about the ordering :)
01:31:46 <EvanR> alright then
01:31:56 <EvanR> that explains that, its like functor
01:32:41 <merijn> It's the functor for kleisli arrows! 
01:32:46 <bennofs> merijn: no, it's not
01:33:03 <bennofs> merijn: I thought it first as well, but traverse (f >=> g) /= traverse f >=> traverse g
01:33:13 <merijn> oh, you're right
01:33:14 <merijn> blah
01:33:19 <bennofs> merijn: also, you can see that's not true in that it only requires Applicative
01:33:53 <bennofs> merijn: I think it's more a Functor in some category where you have a parallel composition of applicative instead of the sequential composition of the Kleisli category
01:36:50 <bennofs> Btw, what's this "naturality" law that is stated here: http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Traversable.html#v:traverse but not in lens docs: http://hackage.haskell.org/package/lens-4.13/docs/Control-Lens-Traversal.html#t:Traversal ?
01:36:57 <bennofs> is it actually a free one?
01:37:15 <bennofs> oh, I should read the docs till the end!
01:37:26 <bennofs> "(The naturality law is implied by parametricity.)"
01:37:50 <EvanR> dude Buildable
01:38:12 <merijn> Laws are like booze
01:38:15 <merijn> I prefer them free :p
01:38:23 <EvanR> its like sex
01:38:26 <EvanR> better when its free
01:38:39 <merijn> I'm not so sure about that...
01:38:50 <EvanR> -- torvalds
01:39:19 <merijn> Anyway, that quickly goes off-topic :p
01:39:58 * hackagebot hermes 1.3.4.3 -   https://hackage.haskell.org/package/hermes-1.3.4.3 (AlfredoDiNapoli)
01:41:04 <bennofs> I think data Repeat is not Foldable & Buildable
01:41:19 <quicksilver> what's Buildable bennofs ?
01:41:21 <funk> anyone successfully installed grapefruit?
01:41:30 <bennofs> In fact, I think Buildable rules out everything that has a fixed size
01:41:47 <bennofs> quicksilver: https://www.fpcomplete.com/user/gbaz/building-up-to-a-point-via-adjunctions
01:42:03 <quicksilver> oh sorry bennofs :) you did already link that
01:42:25 <EvanR> Buildable is basically fromList
01:43:39 <BernhardPosselt> wha are common usecases for applicative functors? something like having a Maybe with a function and a Maybe of a value and if both are present, the function is applied, otherwise Nothing?
01:43:57 <comerijn> BernhardPosselt: Amongst others, yes
01:44:23 <comerijn> Really just any time you have multiple values in a certain functor and want to combine them
01:44:47 <comerijn> BernhardPosselt: I like the explanation of Applicative extending "fmap" to multi-parameter functions
01:45:21 <comerijn> :t (,) `fmap` [1..5]
01:45:22 <lambdabot> (Enum a, Num a) => [b -> (a, b)]
01:45:34 <bennofs> BernhardPosselt: I once used Applicative to manage resources. I would provide primitive "actions" that allocate a specific resource, but also know how to deallocate it. Then, I can use Applicative to allocate bigger structures, like: bigger = f <$> allocateBasic1 <*> allocateBasic2 ...
01:45:36 <comerijn> Now I'm stuck with a list of functions, instead of a list of tuples
01:45:56 <bennofs> BernhardPosselt: And I get a deallocation function for the big structure as well
01:45:57 <comerijn> How can you turn that list of function in a list of resulting tuples like you want?
01:45:59 <comerijn> :t (<*>)
01:46:01 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
01:46:15 <comerijn> :t (,) `fmap` [1..5] <*> [6..10] -- whoo! cartesian product!
01:46:16 <lambdabot> (Enum a, Enum a1, Num a, Num a1) => [(a1, a)]
01:46:21 <quicksilver> comerijn: that's quite cute, because it "suggests" both the list applicative and the ziplist applicative
01:46:25 <comerijn> > (,) `fmap` [1..5] <*> [6..10]
01:46:27 <lambdabot>  [(1,6),(1,7),(1,8),(1,9),(1,10),(2,6),(2,7),(2,8),(2,9),(2,10),(3,6),(3,7),(...
01:46:46 <comerijn> For convenience sake we then add "(<$>) = fmap" to get
01:46:59 <comerijn> > (,) <$> [1..5] <*> [6..10]
01:47:01 <lambdabot>  [(1,6),(1,7),(1,8),(1,9),(1,10),(2,6),(2,7),(2,8),(2,9),(2,10),(3,6),(3,7),(...
01:47:28 <comerijn> i.e. applying (,) to two functors "simultaneously"
01:47:28 <quicksilver> > let (<*!*>) = zipWith ($) in (,) <$> [1..5] <*!*> [6..10]
01:47:30 <lambdabot>      Could not deduce (Enum a0)
01:47:30 <lambdabot>      from the context (Enum a1, Enum (a1 -> a), Num a1, Num (a1 -> a))
01:47:30 <lambdabot>        bound by the inferred type for ‘e_115610’:
01:47:38 <quicksilver> :(
01:47:48 <quicksilver> > let (<*!*>) = zipWith ($) in ((,) <$> [1..5]) <*!*> [6..10]
01:47:50 <lambdabot>  [(1,6),(2,7),(3,8),(4,9),(5,10)]
01:48:02 <comerijn> BernhardPosselt: Now, you might wonder "but this is applying every function from the first fmap to ALL values in the second list, couldn't it be more like "zipWith"?"
01:48:36 <comerijn> BernhardPosselt: And the answer is "YES!" lists, in fact, have TWO valid applicative instances (however, only one of those is a Monad, therefore that's the default instance for list)
01:49:06 <EvanR> BernhardPosselt: many functor container situations obviously extend to applicative. theres also some applicatives which do extra stuff like validation, or parsing
01:49:10 <BernhardPosselt> i see thanks :)
01:49:13 <comerijn> > (,) <$> ZipList [1..5] <*> ZipList [6..10] -- newtype ZipList a = ZipList { getZipList :: [a] }
01:49:15 <lambdabot>  ZipList {getZipList = [(1,6),(2,7),(3,8),(4,9),(5,10)]}
01:49:33 <comerijn> ZipList is a newtype that produces the "zip-like" applicative of lists
01:49:45 <comerijn> Except it works for ANY number of lists, unlike ZipWith
01:49:53 <mniip> [11:48:16] <comerijn> BernhardPosselt: And the answer is "YES!" lists, in fact, have TWO valid applicative instances (however, only one of those is a Monad, therefore that's the default instance for list)
01:49:54 <mniip> but wait
01:49:55 <mniip> there's more
01:50:00 <EvanR> BernhardPosselt: do x <- (+) <$> readNumber <*> readNumber ;)
01:50:12 <mniip> there is actually an infinite (presumably countable) family of Applicative instances for []
01:50:13 <comerijn> > getZipList $ (,,) <$> ZipList [1..5] <*> ZipList [6..10] <*> ZipList [11..15]
01:50:15 <lambdabot>  [(1,6,11),(2,7,12),(3,8,13),(4,9,14),(5,10,15)]
01:50:21 <comerijn> mniip: Is there?
01:50:32 <mniip> comerijn, it's definitely infinite
01:50:41 <mniip> but I haven't found any signs of it making a continuum
01:50:43 <comerijn> mniip: Explain?
01:51:15 <mniip> an instance that zips the first N elements and foreachs the rest
01:51:41 <merijn> I don't think that's lawful
01:52:02 <bennofs> also, wasn't there some kind of "diagonal" instance that can produce results even when both lists are infinite?
01:52:10 <merijn> "pure id <*> [1..]" would produce a finite list of N elements, which violates the law that "pure f <*> x = fmap f x"
01:52:18 <mniip> bennofs, diagonal would be for monads
01:52:33 <mniip> merijn, why would it
01:52:41 <mniip> pure id = replicate (N + 1) id
01:52:54 <merijn> mniip: "fmap id x = x" according to functor laws
01:53:01 <mniip> let me formulate more strictly,
01:53:06 <merijn> Therefore "pure id <*> x == x"
01:53:11 <mniip> pure x = replicate (N + 1) x
01:53:12 <merijn> Via functor and applicative laws
01:53:30 <merijn> Therefore "pure id <*> [1..]" would violate the Applicative laws for your applicative
01:53:33 <mniip> f <*> x = zipWith (take N f) (take N x) ++ (drop N f <*> drop N x)
01:53:44 <merijn> mniip: Right, that's illegal
01:53:53 <mniip> no it isn't
01:54:20 <mniip> @let data Fancy a = Fancy [a] deriving Show
01:54:22 <lambdabot>  Defined.
01:54:27 <merijn> mniip: No? Then explain how "pure id <*> [1..(n+1)] == [1..(n+1)]"?
01:54:53 <merijn> mniip: Unless you have a smart constructor for [] that enforces they are never longer than N elements
01:55:07 <merijn> In which case you can't say we're talking about an Applicative instance for lists anymore
01:55:08 <quicksilver> merijn: well it zips the first 'n' with id, which make [1..n]
01:55:21 <mniip> @let instance Applicative Fancy where pure x = Fancy $ replicate 4 x; Fancy f <*> Fancy x = Fancy $ zipWith id (take 3 f) (take 3 x) ++ (drop 3 f <*> drop 3 x)
01:55:23 <lambdabot>  .L.hs:165:10:
01:55:23 <lambdabot>      No instance for (Functor Fancy)
01:55:23 <lambdabot>        arising from the superclasses of an instance declaration
01:55:26 <merijn> quicksilver: Right, which violates the applicative law that "pure f <*> x = fmap f x"
01:55:32 <quicksilver> merijn: and then it does [id] <*> [n+1] on the n+1th
01:55:40 <bennofs> @let instance Functor Fancy where fmap f (Fancy as) = Fancy $ fmap f as
01:55:41 <mniip> @let instance Functor Fancy where fmap f (Fancy x) = Fancy $ fmap f x
01:55:42 <lambdabot>  Defined.
01:55:43 <quicksilver> merijn: which gives [1..(n+1)] in total
01:55:43 <lambdabot>  .L.hs:165:10:
01:55:43 <lambdabot>      Duplicate instance declarations:
01:55:43 <lambdabot>        instance [safe] Functor Fancy -- Defined at .L.hs:165:10
01:55:44 <merijn> quicksilver: Because the functor laws says that fmap cannot cut the length off
01:55:45 <bennofs> haha
01:55:53 <mniip> @let instance Applicative Fancy where pure x = Fancy $ replicate 4 x; Fancy f <*> Fancy x = Fancy $ zipWith id (take 3 f) (take 3 x) ++ (drop 3 f <*> drop 3 x)
01:55:55 <lambdabot>  Defined.
01:56:06 <mniip> > pure id <*> (Fancy [1..])
01:56:08 <lambdabot>  Fancy [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,...
01:57:22 <merijn> mniip: Now it's just identical to ZipList
01:57:53 <merijn> > (,,) <$> Fancy [1..5] <*> Fancy [6..10] <*> Fancy [11..15]
01:57:55 <lambdabot>  Fancy [(1,6,11),(2,7,12),(3,8,13),(4,9,14),(4,9,15),(4,10,14),(4,10,15),(5,9...
01:58:53 <kadoban> That doesn't look identical.
01:59:07 <merijn> hmm, wait
01:59:14 <merijn> I misread the code
01:59:37 <merijn> I'm pretty sure this violates some other Applicative law, but I don't know them by heart
02:00:51 <merijn> > pure 'c' :: Fancy Char
02:00:53 <lambdabot>  Fancy "cccc"
02:01:16 <merijn> > pure succ <*> pure 'c' :: Fancy Char
02:01:18 <lambdabot>  Fancy "dddd"
02:02:12 <kadoban> I don't see a law that that obviously breaks, but it's possible I'm missing something.
02:02:34 <bennofs> merijn: no it doesn't. It's isomorphic to Produce (ZipList, []), where the first ZipList has the invariant that it's constant length
02:02:46 <bennofs> s/constant length/has a maximum length
02:02:52 <bennofs> s/Produce/Product
02:03:16 <bennofs> hmm well, and with a little different pure...
02:03:20 <merijn> > (pure (.) <*> pure succ <*> pure succ <*> (pure 'c' :: Fancy Char)) == (pure succ <*> pure succ <*> pure 'c')
02:03:21 <lambdabot>      No instance for (Eq (Fancy Char)) arising from a use of ‘==’
02:03:22 <lambdabot>      In the expression:
02:03:22 <lambdabot>        (pure (.) <*> pure succ <*> pure succ <*> (pure 'c' :: Fancy Char))
02:03:24 <bennofs> hmm, no, same pure :)
02:03:56 <merijn> @let instance Eq a => Eq (Fancy a) where Fancy x == Fancy y = x == y
02:03:58 <lambdabot>  Defined.
02:03:59 <merijn> > (pure (.) <*> pure succ <*> pure succ <*> (pure 'c' :: Fancy Char)) == (pure succ <*> pure succ <*> pure 'c')
02:04:01 <lambdabot>      No instance for (Enum (Char -> Char))
02:04:01 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
02:04:01 <lambdabot>        arising from a use of ‘succ’
02:04:20 <merijn> oh, duh
02:04:25 <merijn> > (pure (.) <*> pure succ <*> pure succ <*> (pure 'c' :: Fancy Char)) == (pure succ <*> (pure succ <*> pure 'c'))
02:04:27 <lambdabot>  True
02:04:29 <merijn> bah
02:04:47 <merijn> ok, I should get back to work instead of trying to prove this in Coq...
02:05:06 <bennofs> merijn: It's isomorphic to Product (ZipList, []), where the first ZipList has the invariant that it has a maximum length, and Products of Applicatives are Applicatives
02:06:17 <quicksilver> bennofs: or Product ((a,a,a,a),[]) if you like
02:06:28 <quicksilver> since we fix the length of the first part in advance anyway
02:06:34 <quicksilver> excuse abuse of notation
02:06:35 <bennofs> quicksilver: no, the first list can be shorter
02:06:45 <quicksilver> oh
02:07:03 <quicksilver> right
02:29:47 <m1stermag1c> :q
02:31:08 <Myrl> merijn: After further analysis(by that, I mean trying to solve the problem while lying down), I'm pretty sure it's because they're sending requests with *another* socket.
02:32:22 <Myrl> merijn: That means... time to use the cont monad.
03:15:02 * hackagebot witherable 0.1.3.2 - Generalization of filter and catMaybes  https://hackage.haskell.org/package/witherable-0.1.3.2 (FumiakiKinoshita)
03:17:01 <asdfaoeu> is it possible to create a cabal project with two levels of preprocessors? I have a preprocessor that generates happy and alex files
03:19:29 <asdfaoeu> (on top of that, the first preprocessor generates *several* files)
03:44:46 <merijn> asdfaoeu: Write some custom build hooks?
03:44:58 <merijn> asdfaoeu: You can insert arbitrary hooks into cabal's buildprocess, so...
03:45:34 <merijn> asdfaoeu: Here's an example of me hooking c2hsc into cabal's build: https://github.com/merijn/SNet2.0/blob/master/Setup.hs
03:45:43 <asdfaoeu> merijn: would preBuild be a good time?
03:45:55 <asdfaoeu> ah, I see :)
03:46:11 <merijn> asdfaoeu: Depends, I recommend consulting the documentation and seeing which hook sounds most appropriate
03:46:32 <asdfaoeu> merijn: can I also output to the build dir, and have alex/happy read from there?
03:46:52 <merijn> asdfaoeu: You can run arbitrary IO, so sure
03:47:05 <asdfaoeu> yeah but will alex/happy read from the build dir?
03:47:15 <merijn> No idea
03:47:25 <quicksilver> you can, for example, make a build hook which refuses to actually build the app but instead plays Rick Astley.
03:47:57 <frerich> Argghh, get of my head...
03:48:03 <asdfaoeu> quicksilver: i understand that. but the point here is that i'd like things to integrate with existing tools nicely.
03:48:17 <asdfaoeu> and i'm just wondering how i can minimize the damage i have to do
03:48:30 <quicksilver> asdfaoeu: sorry, my facetious remark was unhelpful :(
03:48:45 <quicksilver> I don't know the right way to manage input/output dirs
03:48:51 <quicksilver> but the build dir does seem the natural place.
03:56:25 <elliptic00> hi, I define a function:  rev::[Int]->[Int]   rev [] = []   rev list = last(list):rev(init(list))
03:57:40 <elliptic00> reverse a list, and I want to have generic type, can be use char, Int, ... how can I define a generic type?
03:57:56 <tdammers> use a type variable
03:58:00 <tdammers> rev :: [a] -> [a]
03:58:28 <tdammers> also, you don't need all those parentheses
03:58:43 <quchen> Is there a way I can throw a user error in Shake? I'd like Shake to fill out the target and the stack, but be able to choose the inner exception myself.
03:58:44 <tdammers> rev list = last list:rev (init list) -- is fine
03:58:59 <roelof> hello, I have this file : /home/nitrous/code/craft/chapter_3/exercise14/.stack-work/install/x86_64-linux/lts-3.9/7.10.2/doc/exercise14-0.1.0.0
03:59:01 <quchen> Or do I simply throw the exception and Shake will wrap it when it occurs
03:59:33 <roelof> but as soon as I do stack exec exercise14-exec 0 1 0
03:59:59 <roelof> I see this error message  : Executable named exercise14-exec not found on path: ["/home/nitrous/code/craft/chapter_3/exercise14/.stack-work/install/x86_64-linux/lts-3.9/7.10.2/bin","/home/nitrous/.stack/snapshots/x86_64-linux/lts-3.9/7.10.2/bin","/home/nitrous/.stack/progr ams/x86_64-linux/ghc-7.10.2/bin","/home/nitrous/bin","/usr/local/bin","/usr/local/sbin","/usr/local/bin","/usr/sbin","/usr/bin","/sbin","/bin","/usr/games","/usr/l
04:00:14 <roelof> but its there according to find 
04:00:18 <roelof> how to solve this ? 
04:00:39 <elliptic00> thx
04:02:36 <srhb> roelof: Is your PATH variable supposed to look like this? Usually it's a colon separated string.
04:02:51 <srhb> roelof: does echo $PATH look sane?
04:03:02 <srhb> oh, that's stacks output. Nevermind
04:03:34 <roelof> srhb:  do you need the path ? 
04:03:52 <srhb> roelof: No. But according to you, your executable lives in doc, not in bin.
04:04:02 <srhb> roelof: That seems wrong.
04:04:12 <roelof> moment 
04:05:06 <roelof> srhb:  Sorry , I copied the wrong one. Here is the right one : /home/nitrous/code/craft/chapter_3/exercise14/.stack-work/install/x86_64-linux/lts-3.9/7.10.2/bin/exercise14-exe
04:05:38 <elliptic00> f1::Int->Int  f1 a = a + 1     f2:Int->Int   f2 a = a + 2   and I try composite two functions  f1 and f2 
04:05:48 <elliptic00> I use f1.f2(1) 
04:06:04 <elliptic00> I get error when I composite two functions.  any idea?
04:06:05 <merijn> elliptic00: Your bracketing is wrong
04:06:09 <srhb> roelof: Now you're calling it exercise14-exe, but your error message implied you tried to run exercise14-exec
04:06:11 <merijn> elliptic00: "(f1.f2) 1"
04:06:29 <merijn> elliptic00: Right now it parses as "f1 . (f2 1)"
04:06:44 <merijn> elliptic00: And "f2 1 :: Int" and you can't compose a function with an Int
04:07:00 <roelof> srhb:  sorry I do not see the difference between the two 
04:07:05 <srhb> roelof: exe vs exec
04:07:12 <roelof> I see it 
04:07:33 <roelof> problem solved 
04:08:29 <roelof> Now i can investigate why 0 1 0 is doing wrong on this test : prop_max2 x y z = (x == maxThree x y z && y == maxThree x y z && z == maxThree x y z) 
04:09:40 * ski idly wonders what roelof is doing
04:10:09 <asdfaoeu> merijn, quicksilver: i ended up going for the preBuild hook. happy and alex don't read from build dirs unfortunately. so i added some stuff to .gitignore to make up for it. thanks for your suggestions.
04:10:24 <roelof> ski:  im trying to test a function which has to find the highest value of 3 numbers 
04:10:35 * hackagebot Chart 1.5.4 - A library for generating 2D Charts and Plots  https://hackage.haskell.org/package/Chart-1.5.4 (TimDocker)
04:10:37 * hackagebot Chart-diagrams 1.5.4 - Diagrams backend for Charts.  https://hackage.haskell.org/package/Chart-diagrams-1.5.4 (TimDocker)
04:10:37 <merijn> asdfaoeu: You could probably patch the happy/alex hooks to look in a different dir
04:10:59 <roelof> the function does right. Stack exec exercise14-exe 0 1 0 is given 1 
04:11:57 <ski> roelof : how can all of `x',`y',`z' be the result of `maxThree x y z' ? assuming there are more than one inhabitant in the type ..
04:11:59 <quchen> roelof: Your test looks wrong.
04:12:29 <quchen> roelof: all (== maxThre x y z) [x,y,z] -- this is equivalent to what you wrote.
04:12:31 <ski> roelof : i'm not sure what you intended to test in this property
04:12:35 <roelof> oops, I did copy it from the programming haskell book 
04:12:58 <roelof> but then with 2 numbers 
04:13:31 <roelof> prop_max2 x y =  x == max x y && y == max x y  
04:13:42 <roelof> but apperently this is not holding 
04:13:51 <ski> that also seems probably wrong
04:14:28 <ski> what is the *intent* that you wanted to capture in the test ?
04:14:29 <haskell805> hello i need some help in a fuction if a have a fuction that receives a string and i want to permutate however abc == cba for example ghci> combinations 3 "abcde" [ "abc" , "abd" , "abe" , "acd" , "ace" , "ade" , "bcd" , "bce" , "bde" , "cde" ]
04:14:32 <roelof> then Im deleting this test as wrong. There is a text stated to look which one is holding
04:15:25 <quchen> You should never delete tests as wrong.
04:15:35 <quchen> You should delete tests because you know the reason for having them is wrong.
04:15:53 <ski> haskell805 : are you saying you want help in defining `combinations' ?
04:16:36 <roelof> I see it I did && which is a and so every condition must be true. But it must be || because only 1 of them can be true 
04:16:43 <quchen> In your case, the binary operator is the problem. And the thing you actually want to test -- that either x or y is (max x y) -- is a good test.
04:17:32 <haskell805> yes i dont know where to start i know it receives a integer and a string so ::Combinations (Integer a)->"String"->["Strings"]
04:17:39 <ski> roelof : in case `x' is equal to `y', then both are true. so you want "at least one of them true"
04:17:39 <roelof> quchen:  I found it. See my answer right above yours 
04:18:29 <ski> haskell805 : a correct type signature could be
04:18:40 <ski>   combinations :: Integer -> String -> [String]
04:18:43 <quchen> Another test for "max" would be checking that its result is at least as large as any of its arguments.
04:18:53 <quchen> And that it's symmetric. And what not.
04:19:08 <haskell805> i dont know how to use strings in a fuction 
04:19:30 <ski> haskell805 : a string is a list of characters. do you know how to write functions that operate on lists ?
04:19:34 <roelof> quchen:  correct max can never be bigger then the biggest number given 
04:20:49 <haskell805> so my fuction has to have 2 parameters one that is integer the other that is a string
04:20:53 <ski> yes
04:21:39 <haskell805> i see know i will try then if i need help i call tks
04:21:51 <ski> you do that
04:22:14 <haskell805> i can have a base case
04:22:36 <haskell805> if combinations 0 then equals the strings that is the parameter
04:24:20 <haskell805> for example if the person gives me combination 0 "abcde" then ghci>"abcde"
04:24:52 <haskell805> i can program that by doing combination x y ; combination 0 = y ??
04:24:59 <ski> `combinations n s' should be a list of strings, all of which have length `n'
04:25:16 <ski> so if `n = 0', then every string in the output list should have length `0'
04:26:03 <ski> more specifically, you should return a list of all possible ways to select zero elements out of your string
04:26:17 <ski> haskell805 : in how many ways can you select zero elements out of a string ?
04:26:34 <m1dnight_> Hey guys, Im trying to use alex and happy in a project and cabal build keeps saying "missing dependencies: alex -ant, happy -any" but they are clearly preent in my sandbox.
04:26:43 <m1dnight_> I have even done "cabal install alex happy" and they all work fine.
04:26:48 <srhb> m1dnight_: Are they in your PATH though?
04:27:08 <m1dnight_> Doesnt cabal take care of that..?
04:27:18 <haskell805> so it returns a empty list then
04:27:20 <m1dnight_> I have to add the sandbox dir to my path for every project, that is?
04:27:34 <asdfaoeu> m1dnight_: yeah cabal should take care of that
04:27:34 <m1dnight_> (Or just install alex and happy globally?)
04:27:38 <dcoutts> m1dnight_: with a recent enough version of cabal, it will indeed look in the target bindir to find tools
04:27:41 <asdfaoeu> m1dnight_: what what project is this?
04:27:54 <m1dnight_> A project of mine, a typed lambda calculus.
04:28:02 <asdfaoeu> m1dnight_: okay, so a "simple" build type?
04:28:02 <dcoutts> m1dnight_: but yes the workaround is just install those tools globally
04:28:07 <m1dnight_> asdfaoeu: yes.
04:28:26 <elliptic00> is Hask same as type class in Haskell?
04:28:29 <m1dnight_> cabal is version 1.22.4.0 though, guessing that is one of the most recent versions.
04:28:37 <hpc> does the package registration need to be present, or just the tool on path?
04:28:46 <asdfaoeu> m1dnight_: how exactly does it report "missing dependencies"? they should be in build-tools, not as "library" dependencies
04:28:47 <m1dnight_> ah, yes it is.
04:28:47 <dcoutts> hpc: only the latter
04:28:54 <hpc> cool, i had forgotten
04:28:56 <ski> elliptic00 : there is no standard type class called `Hask' that i know of
04:29:13 <hpc> i remember cabal-dev and then manually copy was something i liked to do for crazy stuff like mueval
04:29:20 <hpc> where it's hard to reconcile with the rest of your tools
04:29:22 <dcoutts> m1dnight_: hmm, ok, I'm surprised then. Did you run cabal configure since installing alex/happy ?
04:29:38 <m1dnight_> hmm. No I have not, will do it first.
04:30:16 <ski> haskell805 : can you explicitly answer my question ?
04:30:18 <dcoutts> m1dnight_: but even so, best solution is to install them user-wide, since currently sandboxes involve rebuilding each time you make a new one.
04:30:48 <haskell805> ski i said that return a empty list i think
04:31:05 <asdfaoeu> dcoutts: whenever i install something globally i later run into problems. there's something to say for installing everything locally.
04:31:17 <ski> haskell805 : "in how many ways can you select zero elements out of a string ?" -- the answer should be a counting number
04:31:18 <dcoutts> asdfaoeu: but I mean specifically for alex & happy
04:31:25 <dcoutts> asdfaoeu: they don't change much
04:31:34 <elliptic00> from the WiKi.  Haskell uses Hask as category?
04:31:40 <haskell805> 0 then
04:32:09 <ski> haskell805 : ok. that's unfortunately the wrong answer. so using `combinations 0 y = []' will not work for you
04:32:25 <asdfaoeu> m1dnight_: any progress?
04:32:32 <m1dnight_> it seems to work fine now.
04:32:37 <m1dnight_> Damn thing! :p
04:32:43 <m1dnight_> Im guessing cabal configure solved it?
04:32:44 <haskell805> i didnt put y i put _
04:32:54 <ski> doesn't matter
04:33:18 <jameseb> elliptic00: that's referring to a branch of mathematics called category theory which can be used to describe Haskell's type system, don't worry about it
04:33:27 <ski> haskell805 : if you want to, you can fix this problem later .. or now
04:33:37 <asdfaoeu> m1dnight_: would make sense yes :)
04:33:42 <ski> (maybe you don't believe that it is a problem, yet :)
04:33:45 <haskell805> that´s a case base 
04:33:48 <ski> yes
04:33:55 <dcoutts> m1dnight_: because configure time is when it looks for programs, and it doesn't look again later. This is all going to be a bit smoother in future, (re)doing these things automagically
04:34:07 <haskell805> if x = y.length then returns y
04:34:17 <haskell805> but if x = 0 then 
04:34:32 <haskell805> if x = y.length then returns [y]
04:34:49 <ski>   if x == length y then [y] else ...
04:34:57 <ski> could possibly work
04:35:26 <ski> however, i think there's a simpler way to handle all cases
04:36:05 <ski> if `x' is zero, then there's no elements to select. otherwise (if `x' is greater than zero), there's at least one element to select
04:36:30 <ski> so, possibly, you should make sure there's at least one element in the list, to select
04:36:46 <ski> do you know pattern-matching on lists ?
04:37:04 <quicksilver> elliptic00: in that context 'Hask' is a mathematical construct; it is the category whose objects are Haskell types and morphisms are Haskell functions.
04:37:18 <haskell805> i am seeing the book in that matter 
04:37:30 <haskell805> about pattern matching in lists
04:38:51 <haskell805> i dont know how to use (x:xs) in the list
04:40:10 <ski> you could use something like
04:40:18 <ski>   combinations x (y:ys) = ...
04:40:37 <ski> then `y' is the first character of the string, and `ys' is the remaining list of characters
04:41:50 <haskell805> yes but i add to concat the first 3 caracteres
04:41:56 <haskell805> caracters*
04:42:04 <ski> i don't understand
04:42:15 <haskell805> y is the first character
04:42:25 <haskell805> and ys is the rest of the list
04:42:54 <ski> yes
04:42:59 <haskell805> x gives me length of the sub strings i want to use 
04:43:28 <ski> `x' gives the count of the number of characters to select out of `y:ys', your string
04:44:02 <ski> either you can decide to pick `y', and then pick the remaining characters to pick from `ys'
04:44:13 <ski> or you can refrain from picking `y', and pick all the characters you need from `ys'
04:44:35 <ski> and you want to return a list of all possibilities, all possible ways to pick `x' characters from `y:ys'
04:44:37 <haskell805> yes i get it that works fine until the end of the string but how can i change the y after the end
04:45:08 <ski> i'm not sure what you mean by "change the y"
04:45:28 <haskell805> ghci> combinacoes 3 "abcde" ["abc","abd","abe","acd","ace","ade","bcd","bce","bde","cde"]
04:46:07 <haskell805> until y = a all complete and then how i start it b then
04:46:08 <ski> the first few of these combination possibilities starts with an `a' (the first character in your input string). the remaining ones don't include an `a'
04:46:37 <haskell805> so when all is complete i dont use more that recursion
04:46:50 <ski> if you could compute the list `["abc","abd","abe","acd","ace","ade"]', and also the list `["bcd","bce","bde","cde"]', then you could `++' them together, and then you'd be done
04:46:53 <ski> agree ?
04:46:59 <haskell805> yes
04:47:21 <ski> so, how would you compute the list `["bcd","bce","bde","cde"]', in your example, using recursion ?
04:47:51 <haskell805> i dont know if i can use y+1?
04:48:57 <ski> in your case, if  "abcde"  is the input string, which matches the pattern  y:ys  , then  y  will be the character  'a'  and  ys  will be the string  "bcde"
04:49:17 <haskell805> yes i get that 
04:49:24 <ski> so since `y' is a character, `y+1' would be nonsense. it's not a number
04:49:45 <haskell805> so i have to use the string ys 
04:49:52 <ski> yes
04:49:58 <ski> have you seen Jeopardy ?
04:50:02 <haskell805> and then use ys (x:xs)
04:50:22 <haskell805> no in my country it doesnt goes on tv 
04:50:23 <haskell805> :p
04:50:30 <ski> but you know how it works ?
04:50:59 <ski> what is the (relevant) question to which `["bcd","bce","bde","cde"]' would be the answer ?
04:51:05 <haskell805> a little
04:51:24 <ski> what inputs should you pass to `combinations' to get that result ?
04:51:49 <haskell805> b and then c 
04:52:07 <haskell805> inputs 
04:52:10 <haskell805> ys 
04:52:14 <ski>   combinations 'b' 'c'  -- this ?
04:52:43 <haskell805> no combinations 3 ys 
04:52:48 <haskell805> to give me all the b
04:52:58 <ski> where `ys' comes from where ?
04:53:08 <haskell805> comes from the initial string
04:53:13 <haskell805> without the first char
04:53:30 <ski> ok, sounds good
04:54:06 <ski> so, in this case, since the initial string was `"abcde"', then matching that with `y:ys' gets `ys' to be `"bcde"', which is what you want for this recursive call
04:54:16 <ski> so, so far, you have
04:54:30 <ski>   combinations 0 _      = []
04:54:46 <ski>   combinations x (y:ys) = ... ++ combinations x ys
04:54:48 <ski> agree ?
04:54:52 <haskell805> yes
04:55:21 <ski> so, now to figure out the `["abc","abd","abe","acd","ace","ade"]' part above, and put it in the `...' "hole" in the code
04:56:07 <yaxu> I'm trying to install optparse-applicative on a clean install of ghc 7.8.4, but get "libHStransformers-0.4.3.0.so: cannot open shared object file: No such file or directory". 
04:56:07 <yaxu> I've found "~/.cabal/lib/transformers-0.4.3.0/ghc-7.8.4/libHStransformers-0.4.3.0.a".
04:56:07 <yaxu> Any ideas how I can fix this?
04:56:25 <ski> how would you compute `["abc","abd","abe","acd","ace","ade"]', by using `x',`y',`ys', and possibly calling `combinations' recursively, knowing that in this case :
04:56:28 <ski>   x = 3
04:56:30 <ski>   y = 'a'
04:56:36 <ski>   ys = "bcde"
04:56:40 <ski> haskell805 ?
04:57:15 <elliptic00> If I want to define a functor, do I have to use following syntax:  instance Functor myFunctor where?
04:57:25 <yaxu> Also, here's a video of me making  music with haskell and a dot matrix printer: https://www.youtube.com/watch?v=TMrv_wEFdqE
04:57:58 <jameseb> elliptic00: yes, that's the syntax for instance declarations
04:58:03 <ski> elliptic00 : yes, but `myFunctor' should start with a capital letter (or be an application of such a thing, to type variables)
04:58:35 <Myrl> Welp.
04:58:44 <haskell805> i will have to adding the first char and then the second
04:58:59 <Myrl> Continuations will be hard...
04:59:04 <ski> haskell805 : why the second ?
04:59:17 <haskell805> take x-1 (y:ys)
04:59:30 <haskell805> since i already have the first
05:00:03 <haskell805> i am trying to understand recursion sorry
05:00:22 <nomeata> I’m trying to run criterion in a way to get the data in my benchmarking program, so that I can present it in the way I want to, but I cannot make sense of the criterion API. Is that usecase not supported? Do I have to take the detour via a CSV file?
05:00:27 <elliptic00> can I use something else instead of fmap when I define my functor?
05:00:57 <quicksilver> elliptic00: well the point of defining something as a Functor is to give an instance to fmap
05:01:04 <quicksilver> elliptic00: that is the very essence of Functor
05:01:07 <quicksilver> elliptic00: what are you hoping to do?
05:02:22 <ski> haskell805 : the point of recursion is being able to spot, in the solution of a problem, smaller instances of the same kind of problem
05:03:21 <haskell805> i am just adding the characters until i get x lenght 
05:03:36 <elliptic00> it seems to me fmap only for list and tree structure.. if I want to define "different" data structure.. then what should I do?
05:03:44 <ski> haskell805 : in this case, you have a string of five characters, and you take that apart into the first character and the remaining four characters. if you decide to use the first character, then that means that you have `3-1', iow two, characters left to select from the remaining characters
05:03:54 <liste> elliptic00 use the `data' keyword
05:04:10 <quicksilver> elliptic00: fmap works for many data structures
05:04:10 <liste> @let data Pair a b = Pair a b
05:04:10 <tdammers> haskell805: the mindset for recursive solutions is roughly this: "if I knew the answer for n-1, here's how I'd calculate the answer for n"
05:04:11 <lambdabot>  Defined.
05:04:24 <Ongy> is i possible to create a statically linked executable with current ghc?
05:04:28 <quicksilver> elliptic00: however, if your data structure does not support fmap then it's not a Functor. Which is fine too, many fine things are not Functors.
05:04:29 <tdammers> haskell805: that, plus a trivial base case
05:04:45 <liste> @let instance Functor (Pair a) where fmap f (Pair a b) = Pair a (f b)
05:04:47 <lambdabot>  Defined.
05:05:06 <liste> > fmap (+1) (Pair 3 4) :: Pair Int Int
05:05:08 <lambdabot>      No instance for (Show (Pair Int Int))
05:05:08 <lambdabot>        arising from a use of ‘show_M84375459649345698394353’
05:05:08 <lambdabot>      In the expression:
05:06:29 <ski> haskell805 : it rarely helps in recursion to think of "second element","third element",&c. either the list is empty, or there's a first element and a list of the remaining ones. in the most common cases, that's "how deep" you need to look to be able to make a recursion
05:06:47 <Myrl> Hmmm..
05:06:48 <ski> haskell805 : "looking deeper" usually just complicates things, for no gain
05:06:59 * ski stares at Myrl
05:07:13 <Myrl> Guys, what should I use if I want to halt execution and return to it later?
05:07:42 <peddie> SIGSTOP
05:07:49 <ski> maybe coroutines. or continuations ?
05:07:52 <Ongy> or rather: when I try to compile a statically linked binary with ghc (-static -optl -static) I get an error that ld cannot find -lgmp, but /usr/lib/libgmp.so exists on my system
05:08:09 <Myrl> ski: Ah. Good thing to know that continuations is a viable option.
05:08:13 <merijn> Ongy: libgmp.so is dynamic, do you have libgmp.a?
05:08:14 <Myrl> How do I use it to do that?
05:08:25 <Myrl> merijn: Hey, I think I found my problem.
05:08:35 <merijn> Myrl: Do tell :)
05:08:36 <ski> continuations are a sledgehammer
05:08:55 <Myrl> merijn: Firefox probably opened multiple sockets.
05:09:02 <quicksilver> when all you have is a sledgehammer, everything looks like a nut?
05:09:11 <quicksilver> Myrl: it normally opens 2 per host
05:09:14 <quicksilver> IIRC.
05:09:20 <quicksilver> (if it has more than one thiing to fetch)
05:09:25 <Myrl> merijn: And since my server is single-threaded, it had to wait until itmeout.
05:09:43 <Myrl> merijn: So now I'm planning to use Cont.
05:09:56 <quicksilver> it's probably easier just to use threads?
05:10:03 <merijn> Myrl: Why not just one thread per socket?
05:10:11 <quicksilver> getting coroutines right is hard. threads are easy.
05:10:12 <merijn> Myrl: Probably 10,000% easier
05:10:17 <Myrl> merijn: quicksilver: That's too sane. ;(
05:10:17 <Ongy> merijn: oh right, not in /lib or /usr/lib
05:10:30 <merijn> quicksilver: I'll take "Things only haskell programmers says" for $10,000 ;)
05:10:36 <Myrl> merijn: quicksilver: That makes too much sense, I don't want to do that.
05:10:37 * hackagebot luminance 0.3.1.2 - Type-safe, dependently-typed and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.3.1.2 (DimitriSabadie)
05:10:38 <quicksilver> merijn: :)
05:10:50 <tdammers> threads are easy. synchronizing state between threads is not
05:11:08 <merijn> Myrl: Why make things needlessly hard on yourself?
05:11:13 <Myrl> merijn: Dunno.
05:11:23 <ski> merijn : more fun, perhaps
05:11:31 <Myrl> ski: Probably.
05:11:44 <merijn> Myrl: GHC has an insanely high performance threading/IO subsystem that makes this stuff simple :)
05:12:36 <exio4> fun? threads are fun!
05:13:01 <Myrl> I'm amazed.
05:13:05 <Myrl> using coroutines made things even worse.
05:13:11 <Myrl> 
05:13:19 <Myrl> Oh wait, I didn't use it yet.
05:14:07 <Hafydd> "<quicksilver> when all you have is a sledgehammer, everything looks like a nut?" I spent a few minutes thinking you meant this kind of nut - <http://3.imimg.com/data3/BJ/SB/MY-10450013/metal-nut-250x250.jpg> - but then I realised you probably meant this kind: <http://www.phrases.org.uk/images/in-a-nutshell.jpg>.
05:14:43 <frerich> I thought the saying is 'When all you have is Haskell, everything looks like a thread' :->
05:14:44 <merijn> Hafydd: Oh, I thought "crazy person" :p
05:14:44 <tdammers> https://s-media-cache-ak0.pinimg.com/736x/fd/23/d5/fd23d5d0b9d6c61c278b83ab77da8e60.jpg
05:14:49 <Hafydd> Hahah.
05:15:29 <Hafydd> When all you have is Haskell, everything looks like a category.
05:15:36 <merijn> It does!
05:15:43 <merijn> Even the categories look like categories!
05:16:01 <tdammers> it's categories all the way down
05:16:09 <frerich> Until you get to the turtles.
05:16:23 * merijn mumbles "it's isomorphisms all the way down", while swinging a homotopy type theory book around
05:16:35 <Hafydd> Why are there crumbs under the nail and the metal nut?
05:17:21 <exio4> merijn: nice one!
05:17:45 * ski idly ponders permutation exponentiation
05:17:46 <tdammers> Hafydd: long story.
05:18:07 <phaazon> hm
05:18:23 <phaazon> is there a way to partially pattern-match arguments of functions?
05:18:24 <phaazon> like
05:18:44 <phaazon> foo obj{ a = objA, b = objB } = {- use a and b -}
05:18:50 <phaazon> I think I already saw something similar
05:19:08 <Hafydd> phaazon: that's valid syntax, if you replace "obj" with a constructor name.
05:19:12 <merijn> phaazon: Eh...exactly like that? if you provide a constructor
05:19:15 <Myrl> Wow, this is even worse now. :(
05:19:19 <phaazon> oh nice!
05:19:22 <phaazon> thanks!
05:19:26 <merijn> phaazon: Fun fact!
05:19:40 <Myrl> Oh wow, I'm stupid.
05:19:40 <phaazon> I thought it was a bit like view pattern, but it’s not
05:19:43 <merijn> phaazon: This syntax generalises to zero fields and non-record constructors too!
05:19:43 <phaazon> it’s just record syntax
05:19:46 <Hafydd> (You can also use an as-pattern to get the object, too, like this: foo obj@(Con{ a=objA, b=objB }.
05:19:53 <phaazon> merijn: huh?
05:19:57 <Hafydd> )
05:19:58 <merijn> @let data Foo a = Foo a a
05:19:59 <lambdabot>  Defined.
05:20:06 <ski> @type let foo Node {rootLabel = a,subForest = ts} = Node a (reverse (map foo ts)) in foo
05:20:07 <phaazon> Hafydd: yep I know that! :)
05:20:07 <lambdabot> Tree a -> Tree a
05:20:19 <merijn> > case Foo 'a' 'b' of Foo{} -> True; _ -> False
05:20:21 <lambdabot>  True
05:20:27 <Myrl> Boom.
05:20:28 <Myrl> It works.
05:20:49 <phaazon> merijn: wtf
05:20:53 <merijn> phaazon: :D
05:20:54 <Hafydd> In perhaps the most contrived example of the year.
05:21:16 <merijn> Hafydd: It's useful if you want to be forward compatible/lazy and not depend on the number of fields of a constructor
05:21:17 <Myrl> Err... wtf.
05:21:36 <Myrl> "Transferred: 18.56 KB, Size: 24.75 KB"
05:22:18 <Hafydd> merijn: I'm not talking about the empty record syntax, but rather the name "Foo" and the pattern that guarantees to mach.
05:22:20 <Myrl> My file system agrees with me that it's only 6.4 KB.
05:22:23 <phaazon> thanks guys :)
05:22:31 <merijn> Hafydd: Yeah, I misread your comment :)
05:22:32 <Myrl> Errr... I'm talking about another file now. Lol.
05:23:35 <Myrl> Wow, I derped pretty hard.
05:24:38 <Myrl> go' f str | B.null str | otherwise
05:24:55 <Myrl> That should really have been `go' f ""` and `go' f x`
05:25:06 <Myrl> And now that I did that, I just inlined it with case lambda.
05:26:57 <magamig> hey
05:27:39 <Myrl> This makes me feel better now.
05:27:51 <magamig> any idea how to make this work: function :: [String] -> Int -> String
05:27:51 <magamig> function l p = "Line "++ p ++" is invalid" 
05:27:59 <Myrl> BRB.
05:28:08 <merijn> magamig: "show :: Show a => a -> String"
05:29:53 <kakashiAL> could anyone tell me what let means?
05:30:04 <kakashiAL> does it mean let such as "let it be" ?
05:30:35 <magneticduck> let it = it in it, let it = it in it, let it = fix it in it it
05:30:40 <MarcelineVQ> `let` these things mean this `in` the following expression
05:30:42 <srhb> kakashiAL: Yes. Let "name" be equal to... 
05:30:52 <magneticduck> Speaking (words "widsom")
05:30:54 <magneticduck> let it = it in it
05:31:03 <magamig> "Line "++ show (p - length l) ++" is invalid" @merijn
05:31:26 <kakashiAL> ahh okay, like in math: let x = 4 ...
05:31:38 <srhb> kakashiAL: Yes.
05:31:46 <magamig> kakashiAL yes correct
05:31:51 <magneticduck> kakashiAL: correct
05:31:54 <kakashiAL> thanks guys :)
05:32:00 <magneticduck> teamwork
05:32:21 <magamig> and how to make this work: funcion l p = "Line "++ show (p - length l) ++" is invalid" 
05:32:43 <magamig> ?
05:32:48 <srhb> magamig: That looks valid to me, if you haven't got a type error elsewhere.
05:32:58 <magneticduck> @type \l p -> "Line 
05:33:00 <lambdabot>     lexical error in string/character literal at end of input
05:33:08 <magneticduck> @type \l p -> "Line " ++ show (p - length l) ++ "is invalid"
05:33:10 <lambdabot> Foldable t => t a -> Int -> [Char]
05:33:20 <magneticduck> magamig: hooray for type signatures
05:37:19 <magamig> i have a function to check if all the strings in a list are the same size, but I think it is too complicated (http://pasted.co/43f2a8e4)
05:37:33 <magamig> any suggestions to make this simpler
05:37:35 <magamig> ?
05:37:51 <phaazon> hm, let’s say we have a typeclass, class Foo a where…
05:38:06 <phaazon> when looking at the hackage documentation for instance, I see a kind annotation between Foo and the instance type
05:38:09 <phaazon> and does that mean?
05:38:30 <merijn> phaazon: That the Foo is polykinded
05:38:40 <merijn> phaazon: You mean like Category?
05:38:52 <phaazon> it’s not polykinded since the kind is *
05:38:55 <phaazon> hm
05:39:00 <phaazon> let me check the Category 
05:39:28 <magneticduck> @type all -- magamig
05:39:30 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
05:39:41 <magneticduck> use library functions, essentially
05:39:58 <magneticduck> it's usually a mistake to manually employ recursion in your code
05:40:04 <impure_hate> how do you discover library functions when you need to do something?
05:40:12 <phaazon> merijn: yeha
05:40:13 <phaazon> yeah
05:40:14 <magneticduck> http://hayoo.fh-wedel.de/
05:40:15 <phaazon> like in Category
05:40:19 <phaazon> Category * (->)
05:40:21 <magneticduck> impure_hate: hayoo for example
05:40:23 <magamig> @magneticduck what? I did not understand, i am new to haskell so..
05:40:23 <lambdabot> Unknown command, try @list
05:40:35 <merijn> phaazon: That's because of polykindedness
05:40:38 <impure_hate> magneticduck: thanks!
05:40:43 <phaazon> merijn: so that means…
05:40:53 <phaazon> class Category a
05:40:56 <phaazon> is polykinded?
05:40:58 <merijn> phaazon: "Category :: k -> (k -> k) -> Constraint"
05:41:07 <merijn> phaazon: I think that's not entirely correct
05:41:16 <merijn> Lemme rewrite in fictional syntax
05:41:18 <phaazon> merijn: but there’s no kind in the signature
05:41:24 <phaazon> is it an implicit parameter?
05:41:32 <quicksilver> phaazon: I think what you are describing is a haddock bug
05:41:41 <magneticduck> magamig: I'd use \xs -> case xs of [] -> True; (x:xss) -> all (== x) xss
05:41:52 <merijn> "Categroy :: {k :: BOX} -> (k -> k) -> Category"
05:42:02 <merijn> quicksilver: I don't think it's a bug, because it looks sensible to me
05:42:21 <phaazon> ok
05:42:22 <quicksilver> Category * (->) is sensible?
05:42:25 <quicksilver> what does it mean?
05:42:26 <magneticduck> magamig: well in reality I'd use pointfree style and fromMaybe / maybeToList, but that's because I'm insane
05:42:28 <phaazon> I see that in ghci
05:42:32 <phaazon> class Category (cat :: k -> k -> *) where
05:42:40 <ski> magneticduck : s/(x:xss)/x:xss/
05:42:43 <merijn> phaazon: "Category * (->)" means "(->)" is a category with kind "* -> *"
05:42:50 <quicksilver> why
05:42:56 <frerich> ski: That must be your favorite pet peeve, isn't it? :-)
05:43:00 <quicksilver> why does 
05:43:01 <phaazon> merijn: yep
05:43:06 <magneticduck> ski: sorry, recovering from a bout of heavy Lisp
05:43:06 <ski> frerich : one of them :)
05:43:07 <quicksilver> why does '*' mean '* -> *'
05:43:10 <merijn> "Category k (Coercion k)" means "Coercion k" is a Category for any kind 'k'
05:43:14 <phaazon> k -> k -> *
05:43:19 <phaazon> quicksilver: substitution, I guess
05:43:23 <phaazon> replace my k with *
05:43:27 <phaazon> you end up with * -> * -> *
05:43:37 <merijn> Yeah, I think the haddock rendering is...perhaps suboptimal
05:43:40 <frerich> ski: It's like a perfect test for whether you're around. Writing something like [x | (x:xs) <- f a]
05:43:40 <merijn> But it makes sense
05:43:53 <phaazon> merijn: now let’s state this:
05:43:54 <frerich> ski: I mentally go "21... 22... 23..." ;-)
05:44:03 <phaazon> class Category (cat :: k -> q -> *)
05:44:08 * ski is resisting this one
05:44:09 <phaazon> we would need that instance:
05:44:12 <exio4> it will be valid code in GHC 8!
05:44:13 <quicksilver> so in the haddock rendering the first 'parameter' is the kind, for kind application?
05:44:14 <phaazon> instance Category * * (->)
05:44:16 <phaazon> right?
05:44:27 <merijn> phaazon: Can't work
05:44:35 <merijn> phaazon: What's the type of "id" in that category?
05:44:35 <phaazon> quicksilver: yeah, sounds to
05:44:38 <merijn> eh
05:44:41 <phaazon> merijn: it’s just an example
05:44:45 <merijn> Well, kind of the type of id, I guess
05:44:48 <quicksilver> the syntax is just 'instance Category (->)", kinds are inferred
05:44:50 <quicksilver> (no?)
05:44:56 <phaazon> replace Category with Foo
05:45:01 <dgpratt> I found this Haskell eXchange talk pretty interesting, but a lot of it went over my head https://skillsmatter.com/skillscasts/6733-transformers-handlers-in-disguise
05:45:04 <phaazon> class Foo (f :: q -> k -> *)
05:45:09 <merijn> phaazon: Oh, you mean "class Foo (f :: k -> q -> *)"?, yeah, sure
05:45:12 <phaazon> the instance would have the form, in hackage:
05:45:17 <phaazon> instance * * (->) where…
05:45:30 <dgpratt> does anyone know of a resource that outlines those ideas in written format?
05:45:42 <phaazon> merijn: can the instance have different kinds but the same types?
05:45:42 <phaazon> like
05:45:47 <phaazon> instance Nat * (->)
05:45:52 <phaazon> instance Bar Nat (->)
05:45:53 <phaazon> and so on?
05:45:54 <dgpratt> even the slide deck would be nice
05:46:03 <phaazon> not sure what that’d mean tzhough
05:46:04 <phaazon> though*
05:46:14 <merijn> phaazon: Assuming the other kinds/type accept that, sure
05:46:28 <merijn> phaazon: The (->) example won't work, because (->) is not polykinded :)
05:46:31 <quicksilver> dgpratt: http://lambda-the-ultimate.org/node/4786 perhaps
05:46:38 <jophish> I have a function fun :: (Floating a, Real a) => a -> a -> a; I'd like to keep some behavior for every type that's in Floating and Real, except for a particular type Foo. This would be easy, except that Foo is an instance of Floating and Real, so I can't solve this with classes without an overlapping instance between (Floating a, Real a) => MyClass a and MyClass Foo. What's the idiomatic way of solving th
05:46:44 <jophish> is, two functions `fun` and `fun_Foo`? (I think it's worth noting that the implementation for fun is broken for Foo because of an (arguably) incorrect instance definition) 
05:46:45 <quicksilver> dgpratt: if you google "haskell transformers vs effects" you should fund that, and a few other referencies.
05:46:52 <phaazon> merijn: yeah, that’s true
05:46:55 <phaazon> it’s * -> * -> *
05:47:02 <phaazon> even though the * is weird for ->
05:47:04 <ski> magneticduck : do you mean "is not polymorphic" ?
05:47:06 <ski> er
05:47:08 <ski> merijn ^
05:47:13 <phaazon> it accepts #, too
05:47:20 <jophish> Foo in question is the CReal data type, which has an instance of Eq https://hackage.haskell.org/package/numbers-3000.2.0.1/docs/Data-Number-CReal.html
05:47:22 <phaazon> and something else, don’t remember
05:47:34 <phaazon> too much Foo around there guys!
05:47:44 <merijn> ski: I don't think so?
05:48:05 <merijn> ski: (->) is not polykinded, in that it only accepts types with one kind, i.e. *
05:48:37 <dgpratt> quicksilver, thanks -- effect handlers are certainly one thing I want to know more about, but the talk was actually about unifying transformers and effect handlers in a particular way that seemed to make the implementation of the latter simpler and more general
05:48:42 <Crazycolorz5> @pl myf f g h a = f (g a) (h a)
05:48:42 <ski> merijn : i would say "is not polymorphic"
05:48:42 <lambdabot> myf = liftM2
05:48:48 <lyxia> jophish: What makes CReal not adequate for that function? (I don't know the answer to your question anyway though)
05:49:10 <ski> `words' is not polymorphic, in that it only accepts values with one type, i.e. `String'
05:49:13 <jophish> lyxia: the Eq instance only checks the first 40 digits, but I may need more than that
05:49:26 <quicksilver> dgpratt: nod. I dunno. Ping zenzike_ ? :)
05:49:28 <jophish> the function involves root finding
05:49:30 <quicksilver> dgpratt: or email him
05:49:34 <phaazon> 14:47 < merijn> ski: (->) is not polykinded, in that it only accepts types with  one kind, i.e. *
05:49:37 <phaazon> that’s not totally true
05:49:40 <phaazon> and I still don’t get why
05:49:49 <phaazon> (someone tried to explain me but I really didn’t get it)
05:49:50 <merijn> phaazon: Why is that not true?
05:50:00 <phaazon> because you can pass Proxy#, or Int#, or that kind of things
05:50:01 <merijn> It's not entirely true right now, but will be soon
05:50:02 <dgpratt> quicksilver, ah, I should have noticed that -- we'll see if he shows up :)
05:50:04 <phaazon> which are not *
05:50:08 <phaazon> they’re #
05:50:20 <merijn> phaazon: GHC 8 will have subkinding where * and # are subkinds of a single kind
05:50:26 <merijn> phaazon: So the distinction will disappear
05:50:28 <phaazon> that’s why I thought we’d need subkinding
05:50:30 <phaazon> well
05:50:36 <phaazon> merijn: it already has it, right?
05:50:41 <phaazon> that’s called sorts
05:50:59 <ski> sorts ?
05:51:01 <phaazon> yeah
05:51:16 <quicksilver> there is already a common superkind of # and *, has been for many years
05:51:19 <quicksilver> but it isn't used for (->)
05:51:24 <quicksilver> for reasons which I do not understand.
05:51:52 <merijn> phaazon: No
05:51:59 <merijn> Sorts are "the types of kinds"
05:51:59 <phaazon> (k :: ?) -> (k :: ?) -> *
05:52:07 <phaazon> with ? being a kind with two « values » (kinds)
05:52:10 <phaazon> * and #
05:52:11 <merijn> phaazon: Sort is to kind as kind is to type is as type is to term
05:52:19 <phaazon> yeah, that’s what I wrote just above
05:52:20 <merijn> GHC only has one sort: BOX
05:52:35 <phaazon> merijn: I’m saying that it could be used to implement subkinds
05:52:39 <phaazon> instead of
05:52:40 <phaazon> * -> * -> *
05:52:42 <phaazon> we’d have
05:52:42 <merijn> phaazon: If GHC prints a sort you explicitly see "BOX" printed
05:52:50 <merijn> phaazon: No
05:52:52 <phaazon> (k :: ?) -> (k :: ?) -> *
05:52:54 <quicksilver> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Kinds
05:52:55 <jophish> I think my question could be rephrased: How can I overload a function for one type only because that type has broken instances
05:53:00 <quicksilver> https://ghc.haskell.org/trac/ghc/wiki/NoSubKinds
05:53:06 <quicksilver> jophish: no neat way :(
05:53:09 <merijn> jophish: IfCxt?
05:53:25 <merijn> jophish: Beware devil voodoo ahead: https://github.com/mikeizbicki/ifcxt#ifcxt
05:53:26 <quicksilver> jophish: use a different name, maybe find another typeclass which better restricts the cases where it works right
05:54:04 <jophish> I suppose the best solution would be to get the instance removed in the next definition of the library
05:54:24 <phaazon> merijn: I don’t get why we don’t use sorts as generalization of kinds over types
05:54:33 <phaazon> as kinds are generalization of types over values
05:54:45 <jophish> quicksilver: sadly I don't think there is a more restrictive typeclass then what I've got
05:54:47 <phaazon> we could group kinds and make them instance of sorts
05:54:49 <merijn> phaazon: You're getting levels confused, I think
05:54:51 <phaazon> and we’d have subkind
05:54:56 <jophish> merijn: I'll take a look, thanks!
05:54:57 <merijn> phaazon: That question doesn't make a lot of sense to me
05:56:13 <quicksilver> some people consider subtyping relationships a thing to avoid rather than seek.
05:56:34 <phaazon> merijn: don’t you agree that types are a way to groups values?
05:56:39 <quicksilver> although the lens library makes extraordinary use of the subtyping relationship which haskell+rankNTypes doesn't have.
05:56:48 <phaazon> group*
05:57:21 <phaazon> well, it’s not really “subtyping”, it’s more like instancing in the direct term
05:57:25 <phaazon> 3 is in the set of Int
05:57:36 <phaazon> just as Int is in the set of *
05:57:38 <benzrf> in quickcheck, how can i test a property that takes 2 lists that are permutations of each other and a random element?
05:57:47 <phaazon> and * should be in the set of ?
05:58:00 <phaazon> that’s why I think sorts could make it through if we could manipulate them
05:58:30 <merijn> phaazon: No, because there are a large number of types with 0 values
05:58:34 * quicksilver puts phaazon in a BOX
05:58:40 <phaazon> merijn: yeah
05:58:44 <phaazon> so what?
05:58:45 <Crazycolorz5> @pl formIntegral . length >>= (\d->(sum>>=(\s->return(s/d))))
05:58:46 <lambdabot> (`fmap` sum) . flip (/) =<< formIntegral . length
05:58:56 <phaazon> 3 is in the set of Int, in the set Float
05:59:03 <phaazon> that’s not a problem
05:59:05 <merijn> phaazon: So I don't agree that "types are a way to group values" :)
05:59:16 <phaazon> merijn: well
05:59:20 <phaazon> in the set of Int
05:59:22 <phaazon> you’ll find 3
05:59:29 <phaazon> in the set of *
05:59:31 <phaazon> you’ll find Int
05:59:36 <phaazon> in the set of OpenKind
05:59:43 <phaazon> you’ll find *
05:59:47 <phaazon> and so on and so forth
05:59:57 <merijn> You find * in BOX
06:00:20 <phaazon> yeah, but every kind are in BOX
06:00:35 <phaazon> while we could, for instance
06:00:38 <phaazon> put * and # in BOX
06:00:39 <phaazon> and have
06:00:57 <phaazon> (s :: BOX), (k :: s) -> (k :: s) -> *
06:01:52 <merijn> But * and # is already in BOX and that signature would have to be in a different sort than BOX
06:01:54 <benzrf> nvm i figured it out >w>
06:01:56 <quazimodo> should I know from looking at this  Monad m => (a -> m b) -> t a -> m (t b)  that t is a list?
06:02:08 <Myrl> There should be a `tee` function.
06:02:16 <quicksilver> quazimodo: hopefully there is also Traversable t
06:02:28 <phaazon> quicksilver: it could be
06:02:29 <quazimodo> hrmmmm
06:02:32 <quazimodo> i see
06:02:36 <phaazon> it could be Maybe as well
06:02:55 <phaazon> actually, I often use that with Maybe
06:03:00 <quazimodo> t could be anything, but it's probably gonna be Traversable because *generally* speaking we'd use a lowercase for whatever the type constructor is, yes?
06:03:08 <phaazon> (traverse_, which drops the Monad for Applicative instead)
06:03:09 <phaazon> travers*
06:03:11 <phaazon> dammit
06:03:13 <phaazon> traverse*
06:04:06 <quazimodo> i found it here http://hackage.haskell.org/package/base-4.8.1.0/docs/Prelude.html#v:mapM
06:04:16 <phaazon> merijn: I just don’t get why we have BOX
06:04:22 <phaazon> since everything is in BOX
06:04:22 <quazimodo> ahhh i see
06:04:27 <phaazon> it’s like we don’t give a heck about it
06:04:39 <phaazon> why we could have several sorts
06:04:50 <phaazon> to correctly kind (->)
06:05:04 <phaazon> couldn’t*
06:05:08 <quazimodo> so why does :t mapM give me mapM :: Monad m => (a -> m b) -> [a] -> m [b]
06:05:22 <quazimodo> if the type is actually mapM :: Monad m => (a -> m b) -> t a -> m (t b)
06:05:41 <phaazon> quazimodo: because mapM is a specialized version of traverse
06:05:44 <phaazon> :t traverse
06:05:45 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
06:06:05 <phaazon> and works for Monads while traverse works for Applicative
06:06:28 <phaazon> but if you have a Monad, you also have an Applicative, so you should use the traverse function instead
06:06:29 <tdammers> actually, it depends who you ask
06:06:31 <quazimodo> I don't even know what :pplicative
06:06:36 <bennofs> :t mapM
06:06:37 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
06:06:50 <tdammers> GHCI 7.10 says exactly what lambdabot says
06:06:51 <phaazon> quazimodo: it’s the superclass of Monads
06:07:01 <phaazon> just as Functor is the superclass of Applicative
06:07:16 <phaazon> how conformtable do you feel with those abstractions, quazimodo?
06:07:24 <quazimodo> i'm on 7.6.3
06:07:26 <phaazon> comfortable*
06:07:34 <quazimodo> phaazon: which ones
06:07:47 <mniip> hey merijn
06:07:50 <mniip> did you prove it yet
06:07:53 <phaazon> quazimodo: Functor and Monad
06:07:55 <mniip> sorry for leaving so abruptly
06:07:56 <merijn> phaazon: BOX is internal to GHC, and the reason for that is that you "can't do anything" with it
06:08:14 <phaazon> merijn: well, I’m pretty sure we could make OpenKind a sort
06:08:16 <merijn> phaazon: But there's plenty of sorts outside of BOX in type theory more rich than GHC's
06:08:17 <phaazon> instead of a « subkind »
06:08:30 <merijn> In fact, there's an infinite hierarchy of sorts in CoC
06:09:38 <mniip> (->) :: (BOX -> BOX)
06:09:48 <quazimodo> phaazon: enough to be dangerous :)
06:09:58 <quazimodo> i know what they both are in category theory
06:10:00 <mniip> no wai
06:10:03 <mniip> (->) :: (BOX -> BOX -> BOX)
06:10:18 <quazimodo> and i know what they are in haskell too but i don't know how to use them properly
06:10:25 <quazimodo> not enough practice
06:10:35 <phaazon> quazimodo: Applicative is not very hard to understand
06:12:11 <clrnd> :k (->)
06:12:13 <lambdabot> * -> * -> *
06:12:40 <quazimodo> phaazon: given a morphism (a -> b) we can partially apply fmap to get a morphism f a -> f b, and to map a -> f a we just apply the functor riht
06:13:49 <phaazon> quazimodo: basically, yeah, fmap is used to map functions over types
06:14:07 <quazimodo> hrm
06:14:37 <quazimodo> i guess to get something that goes a -> f a we'd apply fmap to id ?
06:14:59 <mniip> no
06:15:04 <mniip> that'd be f a -> f a
06:15:07 <ski> @type fmap id
06:15:08 <lambdabot> Functor f => f b -> f b
06:15:16 <mniip> id (of a different type), according to the functor laws
06:15:43 * hackagebot trurl 0.4.0.0 - Haskell template code generator  https://hackage.haskell.org/package/trurl-0.4.0.0 (dbushenko)
06:16:03 <quazimodo> mniip: that's right
06:16:12 <quazimodo> it's just the class's type constructor taking a -> f a
06:16:28 <quazimodo> right
06:16:47 <mniip> no
06:16:49 <mniip> :t pure
06:16:50 <lambdabot> Applicative f => a -> f a
06:17:00 <quazimodo> wat
06:17:12 <latro`a> that usually being a data constructor
06:17:21 <latro`a> e.g. Just
06:17:28 <mniip> "usually"
06:17:37 <mniip> assuming one in ten is usually enough
06:17:41 <quazimodo> my brain hurts, hold up
06:17:45 <quazimodo> i need to look at Maybe
06:17:59 <mniip> @src Applicative Maybe
06:18:00 <lambdabot> Source not found. :(
06:18:01 <jophish> What are the laws (in haskell) for the Eq class?
06:18:06 <fr33domlover> Is there a quick way to convery Either to Maybe? (i.e. Left _ becomes Nothing)
06:18:11 <fr33domlover> *convert
06:18:13 <ski> @type pure :: a -> ((->) rho) a
06:18:14 <lambdabot> a -> rho -> a
06:18:24 <magneticduck> don't rush quazimodo guys, we don't need another victim of currying on this channel
06:18:25 <ski> fr33domlover : `either (const Nothing) Just'
06:18:26 <latro`a> jophish, I don't think there are any completely strict laws, seeing as floating point equality can't satisfy any good laws
06:18:27 * magneticduck shudders
06:18:29 <mniip> jophish, haskell typeclasses have no laws
06:18:41 <fr33domlover> ski, sure, I mean some fancy ready function :P
06:18:55 <mniip> but if you want to be nice, an instance should respect all equality laws
06:19:04 <quazimodo> magneticduck: i'm cool
06:19:06 <mniip> commutativity and transitivity, I guess
06:19:16 <quazimodo> i think with a monad you define return to take  a -> m a
06:19:17 <jophish> mniip: ah, I meant like the ones usually attached as documentation
06:19:20 <latro`a> fr33domlover, I think there is something in a utility package, something like "hush"
06:19:24 <quazimodo> though not sure how with functor
06:19:27 <mniip> I don't think Eq has any
06:19:35 <latro`a> quazimodo, monads have return, applicatives have the analogous pure
06:19:37 <jophish> yeah, I couldn't see any
06:19:41 <mniip> jophish, but generally it is expected (a == b) == (b == a)
06:19:43 <latro`a> in general a functor has no analogous function
06:19:45 <magneticduck> quazimodo: yeah that's what you think, until you're looking the other way and point-free sneaks up on you and WHAM
06:19:53 <magneticduck> be careful
06:19:54 <mniip> and that if a == b and b == c then a == c
06:20:01 <mniip> and if a == b and b /= c then a /= c
06:20:02 <quazimodo> magneticduck: what's point-free?
06:20:03 <jophish> mniip: how about (f a == f b) == (a == b)?
06:20:23 <latro`a> jophish, do you mean if f is injective somehow?
06:20:25 <mniip> jophish, that automatically holds due to referential transparency
06:20:38 <latro`a> no
06:20:40 <latro`a> f x = 0
06:20:43 * hackagebot trurl 0.4.0.1 - Haskell template code generator  https://hackage.haskell.org/package/trurl-0.4.0.1 (dbushenko)
06:20:44 <mniip> oh, it holds one way
06:20:47 <jophish> mniip: :)
06:20:47 <quazimodo> latro`a: and since a functor is an applicative, it'll have a 'pure' defined somewhere
06:20:50 <mniip> but not in any way the other way
06:20:57 <quazimodo> so if i define a new functor do i have to define pure for it?
06:20:59 <latro`a> quazimodo, you have that backwards
06:21:02 <magneticduck> @type (.) . (.) -- quazimodo 
06:21:03 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
06:21:07 <latro`a> all applicatives are functors, not all functors are applicatives
06:21:34 <jophish> mniip: I don't think it hold due to RT if the Eq instance is "faulty"
06:21:45 <latro`a> so you may not always have a function of type "forall a. a -> f a"
06:21:50 <jophish> for example if it equates all values below zero, and f is (+ 10)
06:22:12 <jophish> it doesn't hold for all a,b in (0..10)
06:22:12 <latro`a> you should have a == b being true implies f a == f b being true
06:22:14 <jophish> 10]*
06:22:16 <ski> `CoYoneda IORef' is a functor, but is not idiomatic
06:22:21 <jophish> ah, yes
06:22:23 <mniip> jophish, okay then
06:22:29 <latro`a> but common practice floating point issues break that already
06:22:45 <mniip> latro`a, if a structurally equals b, then f a structurally equals f b
06:22:49 <mniip> but not within the Eq typeclass
06:25:16 <ski> > (negate 0 == 0,isNegativeZero (negate 0) == isNegativeZero 0)
06:25:18 <lambdabot>  (True,False)
06:25:47 * hackagebot OpenGL 2.13.1.0 - A binding for the OpenGL graphics system  https://hackage.haskell.org/package/OpenGL-2.13.1.0 (SvenPanne)
06:26:09 <jophish> > negate (0::Float)
06:26:11 <lambdabot>  -0.0
06:26:20 <Ankhers> :t isNegativeZero
06:26:21 <lambdabot> RealFloat a => a -> Bool
06:26:35 <Ankhers> :t isNegativeZero 0
06:26:36 <lambdabot> Bool
06:26:49 <Ankhers> > isNegativeZero 0
06:26:50 <lambdabot>  False
06:26:54 <Ankhers> > isNegativeZero (-0)
06:26:56 <lambdabot>  True
06:27:45 <MarcelineVQ> > isNegativeZero "NegativeZero"
06:27:46 <lambdabot>      No instance for (RealFloat [Char])
06:27:46 <lambdabot>        arising from a use of ‘isNegativeZero’
06:27:46 <lambdabot>      In the expression: isNegativeZero "NegativeZero"
06:28:37 <clrnd> what examples of formal verification of "real world" programs can you guys think of?
06:28:50 <clrnd> e.g. Amazon and TLA+ 
06:29:01 <mniip> let instance RealFloat String where isNegativeZero "NegativeZero " = True
06:29:09 <ski> > isNegativeZero (read "-0" :: Float)
06:29:11 <lambdabot>  True
06:29:33 <MarcelineVQ> mniip: problem solved
06:30:02 <jophish> clrnd: Aerospace applications spring to mind
06:30:04 <merijn> clrnd: SeLinux and compcert?
06:30:40 <clrnd> merijn, good ones
06:31:03 <clrnd> didn't know about selinux
06:31:03 <jophish> :(
06:31:15 <clrnd> seL4?
06:31:30 <merijn> clrnd: afaik
06:31:49 <quicksilver> clrnd: there is a train system somewhere which was formally verified IIRC
06:31:59 <clrnd> compcert uses coq, interesting
06:32:24 <merijn> clrnd: They're working on formally verifying x86 ISA and verified optimisations now
06:32:29 <quicksilver> the "european train control system"
06:32:55 <clrnd> I meant computer verified, aerospace is usually pencil-based afaik :P
06:33:04 <clrnd> quicksilver, let me check it out
06:34:49 <clrnd> this is amazing: http://repository.cmu.edu/cgi/viewcontent.cgi?article=2242&context=compsci
06:35:17 <quicksilver> clrnd: I know, who was still using Computer Modern in 2009?
06:35:48 <clrnd> jajaja
06:35:51 * hackagebot haskell-src-exts-qq 0.7 - A quasiquoter for haskell-src-exts.  https://hackage.haskell.org/package/haskell-src-exts-qq-0.7 (MathieuBoespflug)
06:36:18 <quicksilver> clrnd: I haven't read the details; I've just heard it used as an example of formal verification in quite a few cases
06:36:24 <clrnd> gonna make a github list out of this
06:37:23 <clrnd> haven't found an agda one yet. coq, keymaera and tla+ so far
06:39:16 <bennofs> clrnd: there's also http://research.microsoft.com/en-us/projects/slam/
06:39:41 <bennofs> although it's more static analysis than formal verfication I think
06:40:05 <clrnd> microsoft also has Lean, a theorem prover
06:40:15 <clrnd> microsoft is all in for this stuff :P
06:40:22 <clrnd> and z3
06:40:50 <rk> tla of course also is supported by ms
06:42:28 <rk> I've used maude to model check certain components at my company (distributed data storage), not to far off from what amazon does with tla+
06:42:46 <rk> http://maude.cs.illinois.edu/w/index.php?title=The_Maude_System
06:43:21 <clrnd> thanks rk
06:46:00 <magneticduck> hm what exactly would be involved in moving a fairly large project from a cabal build system to stack?
06:46:21 <magneticduck> anybody here to speak from experience?
06:46:58 <m1089> exit
06:48:00 <jophish> magneticduck: hopefully just `stack init`
06:48:42 <clrnd> magneticduck, yep, stack only needs a stack.yaml, which `stack init` auto gens
06:48:43 <Ankhers> magneticduck: as jophish said, `stack init' should be enough. If you get a build error, you may need to add a package or two to your stack.yml file.
06:48:53 <clrnd> also `stack solver` maybe
06:49:39 <magneticduck> cool
06:50:42 <fprev> how was that ghc-mod feature to tell from which module is a given identifier imported ?
06:51:21 * hackagebot GLUT 2.7.0.3 - A binding for the OpenGL Utility Toolkit  https://hackage.haskell.org/package/GLUT-2.7.0.3 (SvenPanne)
06:58:06 <magneticduck> it's correct to say that stack 'wraps' cabal, right?
07:01:12 <Ankhers> magneticduck: Not entirely. There are two things to talk about when you say cabal. There is `caball-install', which is the actual `cabal' binary. Then there is `Cabal' which is the library that both `cabal-install' and `stack' use internally.
07:02:47 <Myrl> Any reason why `:: (Text -> Text) -> ByteString -> ByteString` doesn't exist?
07:03:21 <quicksilver> Myrl: well it would need at least an encoding parameter?
07:03:30 <Myrl> quicksilver: Of cource.
07:03:42 <Myrl> `withUtf8`
07:04:55 <indiagreen> how much does Parsec's no-backtracking-by-default affect performance? i.e. how much slower would everything be if I defined <|> to be “try a <|> b”?
07:05:28 <mniip> many slower
07:05:42 <Myrl> mniip: Ohai.
07:06:01 <mniip> there's a level of algorithmic complexity between StateT [] and StateT Maybe
07:06:21 <mniip> I mean
07:06:27 <clrnd> I'd like to see a benchmark anyway
07:06:32 <mniip> StateT [token] [] and StateT [token] Maybe
07:06:46 <mniip> clrnd, it's not a benchmark
07:06:47 <mniip> it
07:06:59 <mniip> it's just a difference in algorithmic complexity
07:07:29 <phaazon> hm
07:07:33 <phaazon> given a collection of values
07:07:56 <quicksilver> :t let utf8 = iso Data.Text.Encoding.decodeUtf8 Data.Text.Encoding.encodeUtf8 in over utf8
07:07:57 <lambdabot> (Data.Text.Internal.Text -> Data.Text.Internal.Text) -> BSC.ByteString -> BSC.ByteString
07:08:03 <quicksilver> Myrl: ^^
07:08:05 <phaazon> is there a better algorithm / data structure to remove duplicates than something in O(n²)?
07:08:25 <mniip> O(n log n) but with an Ord constraint
07:08:33 <merijn> mniip++
07:08:43 <phaazon> mniip: is nub O(n log n)?
07:08:43 <quicksilver> or O(n) which is really O(n log n) with a Hashable constraint
07:08:50 <mniip> phaazon, Data.List.nub? no
07:08:54 <phaazon> yeah
07:08:57 <quicksilver> hurrah for fictional asymptotics.
07:08:58 <mniip> it's quadratic because no Ord constraint
07:09:00 <phaazon> hm, so you’d put them in a hash
07:09:11 <mniip> or sort
07:09:17 <phaazon> I can’t change the order
07:09:19 <mniip> map head $ group $ sort
07:09:21 <phaazon> I can’t sort it
07:09:31 <phaazon> the order is semantically important
07:09:42 <bennofs> phaazon: you could use ST and use a mutable hashmap
07:09:46 <MarcelineVQ> sort a temp?
07:09:57 <sm> indiagreen: you could measure it.. I think it will depend on your parser and the data
07:09:58 <quicksilver> fold over the list
07:09:59 <bennofs> s/hashmap/hashset
07:09:59 <indiagreen> phaazon: it usually preserves order
07:10:01 <indiagreen> phaazon: https://github.com/nh2/haskell-ordnub
07:10:02 <quicksilver> keeping a Set of seen values
07:10:05 <quicksilver> in an accumulator
07:10:11 <mniip> map snd . sortBy (comaring fst) . map head . groupBy ((==) `on` snd) . sort . zip [1..]
07:10:18 <mniip> gtg
07:10:50 <phaazon> mniip: yeah, I thought of that as well
07:10:51 <quicksilver> having to resort at the end is probably slower than accumulating a 'seen' Set
07:10:59 <phaazon> you capture the order and destroy it afterwile
07:11:03 <quicksilver> and the accumulation approach is more productive
07:11:03 <phaazon> afterwhile*
07:11:09 <quicksilver> (lets you get the first item in O(1))
07:11:45 <frerich> phaazon: I'd fold the data structure and maintain a Data.Set of seen elements and use that to filter those elements which you saw al... goddammit Mr. Zen beat me to it
07:12:10 <phaazon> ok
07:12:15 <phaazon> so O(n log n)
07:12:24 <phaazon> because you fold the list, which is O(n)
07:12:28 <quicksilver> all the above methods are O(n log n)
07:12:32 <phaazon> and you lookup into the Set, which is O(log n)
07:12:38 <quicksilver> except some people will pretend the Hash-bashed ones are O(n)
07:12:42 <quicksilver> but don't listen to them.
07:12:47 <phaazon> quicksilver: that depends on the hash function
07:12:52 <quicksilver> no, it doesn't.
07:13:00 <phaazon> quicksilver: sure it does
07:13:06 <phaazon> if you hash in O(1), that’s cool
07:13:08 <quicksilver> no hash function can possibly do less than O(log n) work
07:13:13 <quicksilver> pigeon hole principle
07:13:14 <phaazon> in you don’t, you can’t state it’s O(n)
07:13:27 <phaazon> quicksilver: that depends
07:13:31 <quicksilver> no, it doesn't.
07:13:36 <phaazon> the nucleobase algorithm is a good example of that
07:13:36 <quicksilver> it's an absolute limit.
07:13:48 <phaazon> the hash function is O(1) because you know the data
07:13:52 <frerich> I might misunderstand what you mean by 'hash function', but to me basically all hash functions hash in constant time irrespective of the number of elements in the hash...
07:14:04 <quicksilver> hash functions must do O(log n) work if they are going to assign different values to n different inputs
07:14:10 <phaazon> frerich: that’s not true
07:14:14 <quicksilver> because it requires that much work to 'tell them apart'
07:14:16 <phaazon> hashing a string is not O(1)
07:14:24 <phaazon> it’s O(n) with n = length str
07:14:36 <frerich> phaazon: Right that's why I wrote 'irrespective of the number of elememts in the hash'
07:14:50 <phaazon> frerich: my point was that in the nucleobase example
07:14:59 <phaazon> whatever the size of the window you use
07:15:05 <phaazon> the hash function still performs in O(1)
07:15:34 <merijn> O(k) in the size of the key
07:15:35 <quicksilver> is that because there are only finitely many possibilities?
07:15:40 <phaazon> no
07:15:44 <merijn> Also worst case O(n) for hash map in case of collision
07:15:50 <quicksilver> I am unfamiliary with the nucleobase example
07:15:53 <phaazon> it’s because of the structure of the nucleobase sequence
07:16:01 <phaazon> quicksilver: you have a sequence of bases
07:16:02 <phaazon> like
07:16:06 <phaazon> ACTCAATACTGAGTACT
07:16:12 <merijn> I think he might be referring to radix sort
07:16:19 <phaazon> and a window = 4, for instance
07:16:22 <merijn> Since nucleobases have a small fixed number of keys
07:16:34 <phaazon> you get the first hash
07:16:35 <phaazon> ACTC
07:16:38 <phaazon> then the second one
07:16:41 <phaazon> CTCA
07:16:43 <Ankhers> I'm looking at https://github.com/bos/aeson/blob/f012d0936808224d82150292c2b866fc5d1c182c/examples/Simplest.hs#L17-L19 and it is just using the variables `x' and `y' without mentioning the coord. Is that possible because of the `Coord{..}'?
07:16:47 <phaazon> uses 3/4 of the previous hash
07:16:53 <phaazon> so you just need to hash a single base each time
07:16:55 <quicksilver> Ankhers: yes, it's an extension
07:16:57 <phaazon> by shifting right
07:17:02 <indiagreen> Ankhers: yes, and that's possible because of RecordWildCards
07:17:06 <phaazon> so building a hash is O(1)
07:17:09 <phaazon> whatever the size of the window
07:17:15 <quicksilver> indiagreen: isn't it NamedFieldPuns?
07:17:20 <quicksilver> indiagreen: I get these confused.
07:17:27 <Ankhers> quicksilver, indiagreen: Cool, thanks!
07:17:42 <quicksilver> phaazon: I don't understand that example but it doesn't seem to apply to the case of hashing input to use in a hashtable
07:17:55 <quicksilver> it seems to be a remark about a very specific example where you're working on subsequences
07:17:59 <indiagreen> quicksilver: nope, NFP is for replacing “C {a=a}” with “C {a}”
07:18:09 <quicksilver> indiagreen: thanks :)
07:18:24 <phaazon> quicksilver: it does
07:18:34 <phaazon> all hashes will be different
07:18:50 <phaazon> so you can use it in a hashmap if you want to
07:18:58 <indiagreen> quicksilver: re hashing: would it be more accurate to say that hashNub works in O(n log maxBound) or something?
07:19:03 <phaazon> each base is either A, C, G or T
07:19:08 <phaazon> you only need two bits to encode that
07:19:13 <quicksilver> the basic argument about hashing not being O(1) is that to assign `n` different values to `n` different inputs, you must necessary examine at least 'log n' bits.
07:19:20 <phaazon> A = 00, C = 01, G = 10, T = 11
07:19:35 <phaazon> quicksilver: not in that case
07:19:38 <quicksilver> if you fail to assign `n` different hashes then you naturally can do it faster, but you collide all the time, so you won't get n log n anyway.
07:19:46 <phaazon> because you’ve already examined them on the previous hash function!
07:19:56 <quicksilver> phaazon: but how is that relevant to the general case?
07:19:58 <Myrl> @pl (\x -> flip fileHandler (defaultMimelookup . decodeUtf8 $ x) path')
07:19:58 <lambdabot> fileHandler path' . defaultMimelookup . decodeUtf8
07:20:04 <phaazon> it’s not relevant to the general case
07:20:07 <quicksilver> the general case is I have `n` entirely independent values of a type.
07:20:07 <phaazon> it’s relevant to that case
07:20:15 <phaazon> and that’s why I don’t like to reason in « general cases »
07:20:21 <quicksilver> ok but we're talking about uniq'ifying a list here
07:20:21 <phaazon> if I can have a smarter specific function
07:20:27 <phaazon> are we?
07:20:28 <phaazon> sorry
07:20:30 <quicksilver> not uniqifying subsequences.
07:20:44 <Myrl> @pl (\x -> fileHandler (defaultMimelookup . decodeUtf8 $ x) path')
07:20:44 <lambdabot> flip fileHandler path' . defaultMimelookup . decodeUtf8
07:20:45 <indiagreen> phaazon: if you can reuse previous hashes because all your values are overlapping, that's cool, but yeah, that's not what the argument is about
07:21:07 <phaazon> indiagreen: yeah, that’s the nucleobase’s trick to O(n)
07:21:26 <Ankhers> Are there any tools that can look at my source code and see if I have any language extensions enabled that I'm not using?
07:21:31 <quicksilver> it's extraordinary how many people still believe general hashing is O(1) though
07:21:34 <indiagreen> Ankhers: hlint, in some cases
07:21:52 <quicksilver> I tried to find a concise stackoverflow explanation and instead I find lots of people promulgating wrong analysis :/
07:21:53 <Myrl> @pl fileHandler (defaultMimeLookup . decodeUtf8 $ path)
07:21:54 <lambdabot> fileHandler (defaultMimeLookup (decodeUtf8 path))
07:21:59 <Myrl> ew
07:22:01 <Ankhers> indiagreen: Cool. Thanks.
07:22:01 <phaazon> quicksilver: for sure it’s not, but it can :)
07:22:02 <indiagreen> quicksilver: do they? I mean, does anybody believe that e.g. hashing is O(1) for Integer?
07:22:25 <frerich> quicksilver: O(1) in what respect? Size of the key? Size of the hash map?
07:22:28 <Myrl> @pl B.unpack >>= \path' -> flip fileHandler path' ∘ defaultMimeLookup ∘ decodeUtf8
07:22:28 <lambdabot> (line 1, column 48):
07:22:28 <lambdabot> unexpected '\136'
07:22:28 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
07:22:36 <quicksilver> frerich: size of the hash map, but they are related.
07:22:40 <Myrl> @pl B.unpack >>= \path' -> flip fileHandler path' . defaultMimeLookup . decodeUtf8
07:22:41 <lambdabot> (. (defaultMimeLookup . decodeUtf8)) . flip fileHandler =<< B.unpack
07:22:48 <Myrl> Lol...
07:22:56 <quicksilver> frerich: if your hash map contains `n` different elements, it must necessarily have keys at least `log n` long
07:22:56 <phaazon> hm, the Set of seen elements won’t work :(
07:23:00 <frerich> quicksilver: With 'hashing' do you mean just comparing the hash sum, or adding something to a hash (i.e. also traversing the bucket)?
07:23:09 <phaazon> or it can.
07:23:13 <Myrl> Holy shit, it compiles.
07:23:26 <phaazon> if I can fold with the index
07:23:31 <quicksilver> frerich: because you need `log n` length keys to manage to have `n` distinct keys...
07:23:34 <Myrl> `fileHandler (defaultMimeLookup . decodeUtf8 $ path) $ B.unpack path` became `((. (defaultMimeLookup ∘ decodeUtf8)) ∘ flip fileHandler ↩ B.unpack) path`
07:23:35 <frerich> quicksilver: Err s/comparing/computing/
07:23:47 <Myrl> There should be something called monad abuse or something.
07:23:54 <quicksilver> frerich: I'm just talking about actually calculating a (useful) hash function.
07:24:14 <quicksilver> frerich: you can calculate *bad* hash functions faster - ones with high probabilities of collision
07:24:18 <quicksilver> frerich: but that's not what you want, of course.
07:24:20 <Myrl> ∘ is ., and ↩ is =<<
07:24:36 <quicksilver> for example you can just look at the first bit :)
07:26:21 <Myrl> @pl fileHandler (defaultMimeLookup . decodeUtf8 $ path) $ B.unpack path
07:26:21 <lambdabot> fileHandler (defaultMimeLookup (decodeUtf8 path)) (B.unpack path)
07:27:09 <Myrl> I'll give you a cookie if you can figure out what this means. `((. (defaultMimeLookup . decodeUtf8)) . flip fileHandler =<< B.unpack) path `
07:27:47 <obadz> When hitting an error, is there a way to get a stack trace?
07:28:40 <frerich> quicksilver: What I don't quite understand is how the size of the hash map comes into play. E.g. any of the functions in http://www.cse.yorku.ca/~oz/hash.html clearly only depends in the size of the key being hashed, no?
07:29:26 <frerich> quicksilver: When I see (or say...) that hashing takes O(1), I always meant that it takes equally long unrelated to how many elements there are already in the hash map. And I'd imagine that's what other people claiming different things meant, too.
07:29:27 <magamig> can someone help me, I am having troubles install hdevtools in cabal (http://ctrlv.it/txt/2579/2697363532)
07:29:48 <quicksilver> frerich: but it isn't unrelated.
07:30:26 <clrnd> Odd_Bloke, https://wiki.haskell.org/Debugging#Stack_trace
07:30:33 <quicksilver> frerich: do you agree that if you have more (or intend to have more) than 65536 items in your map, a 16 bit hash is useless?
07:30:55 <frerich> quicksilver: No, I wasn't thinking of *perfect* hashing -- but if that's your premise, then I can see where you're coming from.
07:31:05 <Odd_Bloke> obadz: < clrnd> Odd_Bloke, https://wiki.haskell.org/Debugging#Stack_trace
07:31:07 <Odd_Bloke> clrnd: ;)
07:31:09 <quicksilver> frerich: it has to be perfect to achieve O(n log n)
07:31:10 <MarcelineVQ> Is there a good primer for making your own hash functions? I haven't googled it yet
07:31:15 <clrnd> sorry
07:31:21 <clrnd> obadz, https://wiki.haskell.org/Debugging#Stack_trace
07:31:24 <quicksilver> frerich: continue the example assume we accept we will not get unique hashes, then?
07:31:36 <clrnd> oh you already did it, sorry again :P
07:31:37 <obadz> clrnd: is there no way that doesn't require the profiling mode?
07:31:41 <quicksilver> frerich: as I store more than 65536 items in my hash, i necessarily get many, many collisions
07:31:52 <clrnd> obadz, no, you need to  compile that information into the executable
07:32:01 <clrnd> maybe from ghci ... but I;m not sure
07:32:03 <quicksilver> frerich: once I reach 256K items, on average I'll follow a collision chain of depth 4 to actually look up at item
07:32:04 <obadz> clrnd: I have an error "" and I don't know where it's coming from.. seems like that would not be a very rare usecase?
07:32:06 <frerich> quicksilver: Right, pigeon principle.
07:32:16 <frerich> (or pigeonhole principle? I think that's it...)
07:32:18 <quicksilver> frerich: at 512K items I'll follow a collision chain of depth 8
07:32:30 <quicksilver> frerich: do you see that this hash is no longer doing O(log n) lookup?
07:32:35 <quicksilver> sorry
07:32:42 <quicksilver> no longer O(1) I meant.
07:32:54 <quicksilver> in fact it has degraded to O(n)
07:33:06 <frerich> quicksilver: Yes, I think that's why many (most?) hashes only claim 'ammortized constant time' or so, right?
07:33:08 <clrnd> obadz, an `error ""` is very rare I'd say
07:33:23 <quicksilver> frerich: amortized doesn't work. I'm getting 8 collisions *on average*
07:33:23 <obadz> clrnd: well, the string isn't empty but doesn't tell me how I got there
07:33:40 <quicksilver> frerich: amortized says I should get, on average, at most a constant number of collisions
07:33:46 <quicksilver> frerich: but here I'm getting O(n) collisions.
07:33:48 <frerich> quicksilver: Oh yes, I was thinking of something else I think (appending to some array and every now and then you get reallocations which need O(n))
07:33:54 <clrnd> obadz, can't you recompile it for some reason?
07:34:09 <obadz> clrnd: doesn't it require recompiling all deps as well?
07:34:14 <quicksilver> frerich: so if I want to avoid O(n) collisions, I need to have a hash with a low probality of colliding.
07:34:30 <clrnd> obadz, oh damn yes, and if you are using cabal it can be painful
07:34:35 <quicksilver> frerich: and to have a low probability of colliding I need to produce O(log n) different hash results
07:34:45 <clrnd> :/
07:34:46 <quicksilver> frerich: which must require O(log n) work.
07:35:15 <quicksilver> frerich: (and I haven't even discussed the fact that equality checking is also O(log n), which is not required for this argument, but also worth remarking :P)
07:36:13 <clrnd> obadz, sorry, I can't offer a better solution, in any case if it's indeed an `error`, you can look it up with grep
07:36:24 * hackagebot compose-ltr 0.1.2 - More intuitive, left-to-right function composition.  https://hackage.haskell.org/package/compose-ltr-0.1.2 (Wizek)
07:37:35 <obadz> clrnd: I know the source, but not the path I took to get there "vector index doesn't exist"... hmm which vector, etc. ?
07:37:48 <quicksilver> frerich: error, sorry. "to have a low probability of colliding I need to produce O(n) different has results, which means that in binary they are O(log n) bits long, which necessarily requires O(log n) work"
07:40:41 <bennofs> is there a standard function for applying a function n times to a given value?
07:41:09 <bennofs> An implementation would be something like iterate f v !! n
07:41:22 <indiagreen> bennofs: I haven't ever seen it
07:41:24 <tsahyt> bennofs: I think that's the canonical way to do it
07:42:25 <magamig> can someone help me, I am having troubles install hdevtools in cabal (http://ctrlv.it/txt/2579/2697363532)
07:42:36 <frerich> quicksilver: I agree, but I think what still confuses me that I was thinking of imperfect (is that a word?) hashes all the time, e.g. hashing 32bit to 16bit values. Whether or not a lookup into that hash is O(n) or O(log n) would depend on how many elements I actually inserted, no? So it would be O(n) in the worst case.
07:42:38 <obadz> bennofs/peti: is there a new way of turning on profiling in nix ?
07:42:55 <quicksilver> frerich: yes, but observe that you can only possibly have 2^32 different keys
07:43:02 <quicksilver> frerich: so that's not really an 'asymptotic' structure
07:43:05 <bennofs> obadz: in what way new? also, isn't this more #nixos topic? :)
07:43:10 <frerich> quicksilver: but maybe my thinking is just going downhil from here (I never actually learned anything about complexity of algorithms in school...) and I shouldn't try to think about this while waiting for compiles to finish :}
07:43:11 <quicksilver> frerich: it just goes up to 2^32 elements.
07:43:17 <obadz> bennofs: ok moving to #nixos
07:43:31 <quicksilver> frerich: I can call anything O(1) if I fix a hard upper bound :)
07:44:22 <hexagoxel> magamig: i'll pm
07:44:51 <quicksilver> frerich: if you really want to annoy people, even pointer dereference isn't O(1)
07:45:11 <quicksilver> frerich: your computer has to decode the pointer and fetch the memory, that requires examining every bit in the pointer, so it's O(log n)
07:45:23 <bennofs> quicksilver: I can call anything with a log n factor if I'm pedantic enough :p
07:45:27 <quicksilver> if you have the patience you can argue about this for days on ##c++
07:45:42 <indiagreen> quicksilver: but if upper bound and lower bound coincide here (because operations on machine ints are going to take the same time anyway), isn't treating them as O(1) more useful because it yields more accurate estimates?
07:46:01 <quicksilver> indiagreen: if you are restricted to machine ints then O(log n) is constant
07:46:04 <bennofs> quicksilver: the question is, does it matter in practice. I estiminate that it doesn't matter in 99% of cases
07:46:11 <quicksilver> indiagreen: after all, log n is 64, right?
07:46:22 <quicksilver> indiagreen: hence the absurd bounds in the Data.Sequence docs
07:46:56 <quicksilver> oh they removed them, or I'm thinking of a different module
07:47:14 <frerich> quicksilver: True, I think I agree that it makes sense that you can only claim that some particular hash map implementation can do O(1) lookups if the hashing function bothered to do O(log n) work where 'n' would be the number of distinct values which can be stored in the Hash. Does that sound plausible?
07:47:51 <quicksilver> frerich: how can the lookup be O(1) if the hash function is diong O(log n) work? Calling the hash function is part of doing a lookup.
07:48:17 <quicksilver> indiagreen: some module used to have 'log W' bounds where W was machine word size, I thought it was Sequence, but it isn't.
07:48:19 <frerich> quicksilver: Oh I meant lookup as in, accessing the bucket (which has only one element), i.e. after doing the hash computation
07:48:30 <quicksilver> frerich: oh right. Yes that part can be constant.
07:48:33 <frerich> quicksilver: I.e. it can only be O(1) if you have no collisions and no list to walk
07:48:42 <quicksilver> unless you want to go into the pointer-dereference rabbithole.
07:48:51 <frerich> I'd rather not.
07:49:03 <indiagreen> quicksilver: what I mean is that if frerich and you measure performance of hashNub of 1000 elements and then try to guess how much would hashNub of 1000000 elements take, frerich's estimate based on O(1) hashing would be closer to truth
07:49:18 <nshepperd> pointer dereference is O(1)
07:49:39 <nshepperd> unless you are actually switching between machines based on problem size
07:49:58 <tsahyt> quicksilver: You're thinking of Data.IntMap with that W bound I think
07:50:13 <nshepperd> (since all pointers are the same size)
07:50:27 <quicksilver> indiagreen: have you ever tried to emperically measure performance and plot it to theoretical bounds?
07:50:35 <quicksilver> indiagreen: I have supervised a class on that twice.
07:50:44 <quicksilver> indiagreen: it turns out that "log n" is a straight line
07:50:47 <quicksilver> seriously
07:50:52 <tsahyt> There's a bunch of functions in there with O(min(n,W)) complexity where n is the number of elements in the IntMap and W is the machine word size
07:51:04 <quicksilver> it's almost impossible to distinguish "log n" from constant, on real data
07:51:20 <quicksilver> indiagreen: you also have cache locality effects which make everything O(log n)
07:51:35 <quicksilver> tsahyt: that's the one, thank you
07:51:49 <quicksilver> you can see what they're trying to say
07:51:55 <quicksilver> but it is, strictly, nonsense.
07:52:01 <quicksilver> if it's bounded above by a constant, it's constant.
07:52:37 <frerich> As somebody who only got to do three semsters at a University (and that was about 13 years ago...), I always feel that talking about asymptotic complexity of things is a very slippery slope.
07:52:43 <nshepperd> it's redundant with O(1) anyway, since big-O is asymptotic
07:52:55 <quicksilver> nshepperd: that's what I was attempting to say by 'strictly nonsense'
07:53:22 <quicksilver> what actually matters to real programmers is O(n^2)
07:53:28 <quicksilver> and of course O(2^n) and worse.
07:53:45 <quicksilver> log factors are negligible in practice. And they're everywhere.
07:53:45 <tsahyt> O(2^n), also known as "the complexity of everything that's actually interesting"
07:54:00 <nshepperd> eh, interesting things are n log n
07:54:10 <darkroom> hey guys lets say I have this type ReaderT (Map Text a) (Either Text) a what is the best way of throwing an error only one i can think of is ReaderT (\_ -> Left "error") but this is ugly 
07:54:23 <tsahyt> Yeah maybe that's just me and my fascination with automated theorem proving
07:54:24 <quicksilver> darkroom: this is why we have type classes
07:54:25 <nshepperd> I've been able to empirically observe the difference between n and nlogn before
07:54:35 <arw> tsahyt: tons of interesting stuff is just "search for some complex criteria" which is strictly O(n).
07:54:38 <quicksilver> darkroom: throwError "error"
07:55:11 <darkroom> quicksilver: is reader an instance of monadError or something?
07:55:16 <tsahyt> arw: O(n) \subset O(2^n) :p
07:55:30 <quicksilver> darkroom: there is an instance of MonadError which 'ripples up' through ReaderT, yes.
07:55:39 <darkroom> quicksilver: :)
07:55:53 <quicksilver> darkroom: it says "if (MonadError m) holds, then (MonadError (ReaderT r m)) holds"
07:56:13 <tsahyt> arw: But I agree, there are of course a lot of interesting things with manageable complexity. It's just that so many things I end up working with turn out to be intractable
07:56:14 <darkroom> quicksilver: i forgot about the whole monadError thing thanks
07:56:28 <quicksilver> darkroom: this is the raison-d'etre for the MonadFoo classes; to let you work with monad transformer stacks like your one without having to manually wrap/unwrap the FooT things to get it in the right place.
07:56:41 <quicksilver> darkroom: it means that if you later add another layer to the stack it will still work, also.
07:56:58 <darkroom> quicksilver: also monadError is depreacted apparently use monadExcept
07:57:04 <quicksilver> yup
07:57:10 <quicksilver> but it's still called throwError I think?
07:57:12 <quicksilver> the method
07:57:47 <darkroom> quicksilver: yep!
07:58:16 <tsahyt> I have a question. I'm taking a class on formal specification this semester, and I was wondering how Haskell users use formal methods. Has anyone here used formal methods in conjunction with Haskell?
07:59:21 <quicksilver> tsahyt: personally no. I am under the impression that Galois have done some formal stuff in haskell.
08:01:25 * hackagebot atomic-primops 0.8.0.2 - A safe approach to CAS and other atomic ops in Haskell.  https://hackage.haskell.org/package/atomic-primops-0.8.0.2 (RyanNewton)
08:01:37 <lennartl> anyone knows whether and how dependent functions fit in category theory (as used in haskell)?
08:02:28 <tsahyt> I was thinking that Coq would probably be a good match to use for specification, since you can directly generate Haskell code from it. I've been learning Z notation the last couple of days and I find it rather cumbersome compared to type theoretical approaches. And then there's a whole bunch of invariants that you specify that are automatically caught by a good type system too.
08:02:32 <SX> Hi! I need some fast shared mapping structure with atomic operations
08:02:43 <quicksilver> what are dependent functions, lennartl ?
08:02:49 <Welkin> SX: Map?
08:03:03 <quicksilver> SX: shared between threads? processes? machines?
08:03:08 <clrnd> SX, STM and Data.Tree?
08:03:09 <SX> threads
08:03:29 <quicksilver> SX: Data.Map stored in an MVar would be first attempt
08:04:38 <SX> I need to lookup and delete in one operation (blocking other threads from access), but do not block simultaneous reads
08:05:09 <lennartl> quicksilver: i mean something like (lenght :: vector { length = n } -> n)
08:05:57 <clrnd> SX, I think STM's TVar is exactly for that?
08:06:20 <clrnd> an MVar is too low level I guess
08:06:28 <Welkin> SX: there is also acid-state, which is an in-memory haskell database
08:06:49 <Welkin> https://hackage.haskell.org/package/acid-state
08:06:53 <quicksilver> lennartl: ah, dependent types
08:07:04 <clrnd> you can't read simultaneous MVars really, it always needs to block while another thread puts it back 
08:07:05 <quicksilver> how is MVar too low-level clrnd ?
08:07:08 <lennartl> quicksilver: yes
08:07:24 <quicksilver> clrnd: well readMVar is about to change that
08:07:33 <quicksilver> but even so the amount of time it blocks for is pretty low
08:07:41 <quicksilver> we have no idea what SX's requirements are
08:07:46 <quicksilver> I've never thought of MVars are low-level
08:08:31 <quicksilver> lennartl: OK I understand your question, but I don't have a short answer to give you.
08:08:54 <clrnd> quicksilver, you are right, it depends on the use case
08:08:57 <quicksilver> lennartl: you can google 'category theory dependent types'
08:09:08 <quicksilver> lennartl: and see loads of stuff which might or might not help you
08:09:13 <lennartl> quicksilver: thanks
08:09:38 <lennartl> quicksilver: tried that some times now, but i haven't really found something yet :(
08:10:06 <clrnd> quicksilver, didn't know about readMVar, though it was takeMVar and putMVar (seems like it was at some time)
08:11:26 * hackagebot wavefront 0.4 - Wavefront OBJ loader  https://hackage.haskell.org/package/wavefront-0.4 (DimitriSabadie)
08:11:57 <quicksilver> clrnd: it was, yes. the commit was in 2013 which changed it.
08:12:05 <quicksilver> clrnd: trying to work out if that version got released/when
08:12:39 <clrnd> quicksilver I'm not saying I ever used it, it's just what I thought it was :P
08:12:49 <clrnd> (didn't read the docs carefully i guess)
08:13:17 <quicksilver> clrnd: no you were right, it really was that.
08:13:21 <quicksilver> clrnd: change was in base-4.7
08:13:28 <quicksilver> GHC 7.8 I guess?
08:13:30 <SX> Well, I have one thread that reads packets from socket, looking in table to find out if someone is waiting for the data
08:13:33 <clrnd> oh that's recent
08:13:56 <quicksilver> SX: if you're doing sockets then I'm going to bet that an MVar with a Data.Map in will be fine for you
08:14:11 <quicksilver> TCP is like 3 orders of magnitude slower than MVars
08:14:19 <quicksilver> I can't see the MVar ending up as your bottleneck.
08:14:20 <SX> UDP =)
08:14:25 <quicksilver> ok
08:14:29 <clrnd> oh the bet is on
08:14:31 <quicksilver> just 1 order of magnitude then :)
08:15:04 <SX> So there could be a lot of threads writing to this table
08:16:37 <SX> What about TVar?
08:16:45 <clrnd> thread's will lock each other automatically while reading from the MVar
08:17:39 <quicksilver> well a Map in a TVar is really no better - it will "allow" concurrent writes and then one of them will get aborted + restarted.
08:17:46 <quicksilver> that's not really any better than waiting is it?
08:18:10 <quicksilver> you could design a Map "with TVars all the way down" but I wouldn't like to be person who wrote the balance algorithm for that.
08:18:38 <clrnd> https://hackage.haskell.org/package/stm-containers-0.2.9/docs/STMContainers-Map.html
08:19:09 <clrnd> there you go, I have no idea what it means though
08:19:34 <quicksilver> clrnd: cute
08:22:48 <SX> quicksilver: is it an option? or just stick to MVar?
08:24:54 <tsahyt> Why not just try the MVar approach and profile it? I can see how that would be an issue if you're working with a rather large system of course
08:25:35 <tsahyt> On the other hand, you may want to abstract access to whatever concurrent map you're using anyway, so you could change the underlying type without breaking your interface
08:31:09 <quicksilver> SX: I would just say that the MVar (Data.Map.Map k v) is the simplest thing
08:31:14 <quicksilver> try it first, see if it works for you
08:31:19 <quicksilver> if not, discuss how it falls short
08:32:14 <EvanR> quicksilver: accessing via STM might have performance benefit sometimes, but otherwise its just a style preference
08:32:36 <EvanR> if theres not much contention no locks are taken out
08:32:48 <EvanR> because no locks are taken out, low contention = faster
08:33:47 <EvanR> an additional layer on top of Mvar/Stm for basically a clojure atom might be overkill
08:38:09 <nshepperd> I like TVar because `atomically` is really easy to understand
08:38:24 <nshepperd> it just magically works
08:38:59 <nshepperd> but for something like this I imagine MVar takeAndReplace would be just as simple?
08:44:15 <quicksilver> I find atomically harder to understand because there is magic involved
08:44:19 <Peaker> nshepperd: what's takeAndReplace? withMVar?
08:44:50 <Peaker> quicksilver: operationally sure, denotationally it's simple
08:45:01 <quicksilver> wheres put/take/modifyMVar are "simple"
08:45:09 <quicksilver> just goes to show that these things are subjective :)
08:46:42 <int-e> quicksilver: well, gears are simple, but computers are easier to program ;)
08:47:38 <quicksilver> int-e: most people find riding a bike simpler than programming a computer
08:47:44 <quicksilver> admittedly, not everyone
08:47:53 <nshepperd> Peaker: er, might be that. I don't remember the name
08:48:03 <int-e> of course, if riding bikes makes you happy...
08:48:10 * quicksilver agrees
08:48:32 <quicksilver> easier to think about how to program computers when you are away from a screen and no one can talk to you.
08:49:20 <concept> AESON encode function returns a lazy ByteString is there a way to return a strict ByteString
08:49:42 <Guest15796> Hello all
08:49:43 <Guest15796> AESON encode function returns a lazy ByteString is there a way to return a strict ByteString
08:50:01 <quicksilver> Guest15796: just convert the result AFAIK
08:50:34 <Guest15796> Ok, I was wondering if there is an alternatve to the toStrict function
08:52:29 <tsahyt> What's wrong with toStrict?
08:53:15 <glguy> The encoding functions all tend to make lazy bytestrings because they don't know ahead of time how long the encoded message will be, so they allocate chunks on demand to fill
08:53:28 <glguy> and the lazy bytestrings and texts are just linked lists of chunks
08:53:59 <EvanR> ideally your consumer accepts a lazy bytestring ;)
08:57:01 <quicksilver> but if the consumer only accepts strict that probably means its expecting them to be small, and a call to toStrict is not going to be an issue
08:57:04 <quicksilver> FSOV of small
08:59:50 <bitemyapp> quicksilver: For Some OLIGOPOLIC VENTURE
09:00:19 <quicksilver> not OLIGOCRATIC?
09:00:27 <quicksilver> we're all oligarchs here.
09:02:33 <shachaf> quicksilver: Olegarchs, perhaps.
09:05:53 <mrkgnao> I have a list like so: [(Int, SomeThingy)] which I can find the maximum of.
09:06:10 <phaazon> maximumBy (comparing fst)
09:06:15 <mrkgnao> suppose there are multiple maxima. how do I generate a list of them?
09:06:32 <phaazon> multiple maxima?
09:06:39 <mrkgnao> [2,3,5,4,5
09:06:52 <mrkgnao> wait, sorry.
09:07:00 <phaazon> ok, I got it
09:07:02 <phaazon> well then
09:07:15 <mrkgnao> the snds are different, I meant
09:07:28 <phaazon> head . group . sortBy ((>) `on` fst)
09:07:30 <phaazon> something like that
09:07:53 <phaazon> you’ll get [5,5] in your example
09:08:07 <mrkgnao> no, no, what I meant is something like this:
09:08:15 <phaazon> hm, not sure sortBy expects a Bool though, it might expect a Comparing
09:08:39 <mrkgnao> [(2,"adf"),(3,""),(5,"adfa"),(4,"faer"),(5,"aa")]
09:08:48 <phaazon> yeah, then
09:08:49 <phaazon> sorry
09:08:53 <phaazon> with my stuff
09:08:54 <mrkgnao> I want [(5,"adfa"),(5,"aa")] back.
09:08:57 <phaazon> you’ll get that, yeah.
09:09:07 <mrkgnao> oh, nice.
09:09:09 <phaazon> but the (>) `on` fst might be wrong
09:09:15 <phaazon> you just have to change that
09:09:32 <phaazon> it expects a Ordering
09:09:58 <phaazon> so, I guess…
09:10:07 <tsahyt> Wow, sbv is an amazing package
09:10:08 <phaazon> head . group . sortBy ((flip compare) `on` fst)
09:10:11 <phaazon> that should work
09:10:51 <phaazon> hm, nope
09:10:56 <phaazon> lacks a single thingm
09:10:57 <phaazon> thing
09:11:09 <c_wraith> Don't forget comparing 
09:11:44 <phaazon> > head . groupBy ((==) `on` fst) . sortBy ((flip compare) `on` fst) $ [(2,"adf"),(3,""),(5,"adfa"),(4,"faer"),(5,"aa")]
09:11:46 <lambdabot>  [(5,"adfa"),(5,"aa")]
09:11:47 <phaazon> mrkgnao: ^
09:12:16 <mrkgnao> oops, sorry, I was away for a sec
09:12:35 <mrkgnao> that's very helpful of you. thanks!
09:12:36 <phaazon> and, yeah
09:12:37 <fryguybob> SX: how may concurrent threads (hardware) are you expecting to be accessing your shared data structure?
09:12:45 <phaazon> > head . groupBy ((==) `on` fst) . sortBy (flip $ comparing fst) $ [(2,"adf"),(3,""),(5,"adfa"),(4,"faer"),(5,"aa")]
09:12:46 <lambdabot>  [(5,"adfa"),(5,"aa")]
09:12:48 <phaazon> [(5,"adfa"),(5,"aa")]
09:12:50 <phaazon> with comparing
09:13:05 <mrkgnao> got it, thanks
09:13:07 <phaazon> :)
09:13:26 <phaazon> beware the empty list though ;)
09:13:32 <phaazon> (head is unsafe)
09:18:21 <magamig> guards in my sublime are not behaving correctly (could not fix anything from google)
09:18:56 <c_wraith> > group [] 
09:18:58 <lambdabot>  []
09:19:15 <phaazon> @src group
09:19:15 <lambdabot> group = groupBy (==)
09:19:20 <phaazon> @src groupBy
09:19:20 <lambdabot> groupBy _  []     =  []
09:19:20 <lambdabot> groupBy eq (x:xs) =  (x:ys) : groupBy eq zs
09:19:20 <lambdabot>     where (ys,zs) = span (eq x) xs
09:19:23 <phaazon> :)
09:19:36 <c_wraith> Huh. For some reason, I thought it would return [[]] 
09:19:40 <nshepperd> hmm, that solution does traverse the whole list a few times sorting them
09:19:48 <phaazon> c_wraith: that’s the same thing
09:19:52 <nshepperd> which is probably only a problem if it's huge and streamy though
09:20:14 <c_wraith> > head [[]] 
09:20:16 <lambdabot>  []
09:20:23 <phaazon> nshepperd: it sorts it once
09:20:47 <phaazon> group is lazy in the list
09:20:53 <tsahyt> Why has the sbv library gotten so little exposure compared to QuickCheck? I see that it's easier to test large things with QC, but assuming that the type signatures are sufficiently polymorphic, sbv can prove fundamental properties about important core functions
09:21:02 <phaazon> so the head will preclude any more grouping, I guess
09:21:29 <fryguybob> SX: Depending on your application you may find any of the following to be faster: IORef (M.Map k v) under atomicModifyIORef', IORef (M.Map k v) under atomicModifyIORefCAS (atomic-primops), TVar (M.Map k v), MVar (M.Map k v), or STMContainers Map.
09:21:42 <c_wraith> sbv is way harder to use. Quickcheck takes haskell functions. 
09:21:45 <nshepperd> that's what I mean, sorting traverses a few times
09:21:59 <nshepperd> or it's not streamy anyway
09:22:41 <fryguybob> Also, the pure Map with the best performance that I know is from unordered-containers, but you can find others that do better on the right workload.
09:22:43 <phaazon> nshepperd: well, sure, that’s a naive implementation
09:22:46 <phaazon> one could use a O(n) one
09:22:51 <phaazon> with a fold
09:22:57 <tsahyt> c_wraith: That's why I said your functions need to be sufficiently polymorphic. Numeric functions constrained over Num and similar stuff can be used with sbv
09:23:14 <tsahyt> The numeric types in sbv support the corresponding type classes
09:23:20 <magamig> any suggestions to make this: [12 3] -> (12,3)
09:23:45 <phaazon> yep
09:23:50 <phaazon> I have that online! :D
09:24:07 <tsahyt> For example, SFloat is an instance of Floating. So if I have a function foo :: Floating a => a -> a -> a, I can use that to write a property for sbv
09:24:40 <c_wraith> I've never once used Quickcheck for a numeric property. I use it for testing structural properties 
09:24:50 <phaazon> magamig: can’t find it, but it’s easy:
09:24:58 <phaazon> oh right, I can
09:24:58 <phaazon> :
09:25:15 <phaazon> https://github.com/phaazon/luminance/blob/master/src/Graphics/Luminance/Core/Shader/Uniform.hs#L213
09:25:16 <tsahyt> Maybe I'm just influenced by having spent too much time with numerical bugs this summer.
09:25:25 <phaazon> so toPair would be:
09:25:31 <davean> tsahyt: I thought it couldn't do conditionals?
09:25:33 <phaazon> toPair [x,y] = (x,y)
09:25:40 <phaazon> and I’d make it type-safe with:
09:25:49 <magamig> but i have this: 
09:25:50 <phaazon> toPair :: [a] -> Maybe (a,a)
09:25:54 <phaazon> toPair [] = Nothing
09:26:01 <phaazon> well no
09:26:04 <magamig> "12 3" -> (12,3)
09:26:18 <davean> tsahyt: I mean, I know one problem with it was the availability of solvers
09:26:19 <magamig> i have a string with two numbers separated by a space
09:26:22 <phaazon> toPair [x,y] = (x,y)
09:26:26 <phaazon> toPair [x,y] = Just (x,y)
09:26:29 <phaazon> toPair _ = Nothing
09:26:31 <phaazon> then your function is
09:26:56 <phaazon> toPair . words
09:27:21 <tsahyt> Huh, okay I redact my statement. It's lacking some vital instances apparently
09:27:23 <phaazon> @let toPair :: [a] -> Maybe (a,a); toPair [x,y] = Just (x,y); toPair _ = Nothing
09:27:24 <lambdabot>  Defined.
09:27:28 <phaazon> :t toPair . words
09:27:29 <lambdabot> String -> Maybe (String, String)
09:27:34 <tsahyt> davean: Z3 is MIT licensed
09:27:41 <phaazon> > toPair $ wordds "12 3"
09:27:42 <lambdabot>      Not in scope: ‘wordds’
09:27:42 <lambdabot>      Perhaps you meant one of these:
09:27:42 <lambdabot>        ‘words’ (imported from Data.List),
09:27:45 <phaazon> > toPair $ words "12 3"
09:27:46 <lambdabot>  Just ("12","3")
09:27:53 <phaazon> magamig: ^
09:27:57 <magamig> YES :)
09:28:01 <magamig> TY!
09:28:16 <phaazon> if you need them as Int, just use a parser ;)
09:28:18 <bennofs> What is the difference between unsafeShift* and shift* from Data.Bits?
09:28:20 <phaazon> like parsec / attoparsec
09:28:33 <davean> tsahyt: It is *now*
09:29:26 <magamig> phaazon
09:29:27 <tsahyt> davean: Well that's good enough. I actually just found out about it too
09:29:35 <magamig> can you please explain ? :)
09:29:46 <davean> tsahyt: No, I've known it was made MIT
09:29:51 <davean> tsahyt: But that doesn't change history
09:29:58 <davean> tsahyt: you asked why people didn't use it more
09:30:03 <davean> Z3 being MIT is brand new
09:30:14 <tsahyt> I wasn't implying you didn't know before, I was referring to me discovering that fact
09:31:10 <davean> tsahyt: Z3 hasn't been MIT for even a year, I'm not sure why people would be using sbv given that
09:32:51 <phaazon> magamig: explain? sure, what haven’t you gotten? :)
09:33:03 <nomeata> Hi. Is there a portable equivalent to "setFileMode filename (ownerReadMode `unionFileModes` ownerWriteMode)"?
09:33:15 <magamig> this: "if you need them as Int, just use a parser"
09:33:25 <magamig> phaazon
09:34:39 <tsahyt> davean: Huh well okay that explains that. I didn't know it was that recent. I thought it's been like that for a bit longer than that.
09:35:28 <davean> tsahyt: End of March
09:36:05 <tsahyt> That also explains why I found it in the Fedora repos now, but didn't find it the last time I looked
09:39:32 <phaazon> magamig: well
09:39:44 <phaazon> how do you turn (String,String) into (Int,Int)?
09:39:51 <phaazon> you can bimap read, but that’s nasty
09:39:53 <tobiasBora> Hello !
09:39:56 <phaazon> :t bimap read
09:39:58 <lambdabot> (Read b, Bifunctor p) => (c -> d) -> p String c -> p b d
09:40:09 <phaazon> > bimap read ("a","b")
09:40:10 <lambdabot>      Couldn't match expected type ‘c -> d’
09:40:10 <lambdabot>                  with actual type ‘([Char], [Char])’
09:40:10 <lambdabot>      In the second argument of ‘bimap’, namely ‘("a", "b")’
09:40:16 <phaazon> hm
09:40:16 <phaazon> oh
09:40:20 <phaazon> > bimap read read ("a","b")
09:40:22 <lambdabot>  (*Exception: Prelude.read: no parse
09:40:25 <tobiasBora> I don't understand the difference between ":m + <my module>" and "import <my module>", can you help me getting it ?
09:40:28 <phaazon> > bimap read read ("a","b") :: (Int,Int)
09:40:30 <lambdabot>  (*Exception: Prelude.read: no parse
09:40:34 <phaazon> ahah I’m stupid.
09:40:38 <phaazon> > bimap read read ("11","3") :: (Int,Int)
09:40:39 <lambdabot>  (11,3)
09:41:43 <phaazon> :t both
09:41:44 <lambdabot> (Applicative f, Data.Bitraversable.Bitraversable r) => (a -> f b) -> r a a -> f (r b b)
09:41:56 <phaazon> I thought we’d have a both for Bifunctor
09:44:16 <merijn> You can do
09:44:21 <merijn> :t join (&&&)
09:44:22 <lambdabot> Arrow a => a b c -> a b (c, c)
09:44:24 <merijn> or
09:44:32 <merijn> :t join bimap
09:44:33 <lambdabot> Bifunctor p => (a -> b) -> p a a -> p b b
09:45:06 <phaazon> oh, yeah
09:45:12 <phaazon> I always forget (->) as a monad
09:45:14 <phaazon> :)
09:45:20 <phaazon> nice tip ;)
09:45:26 <ski> @type join (***)
09:45:27 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
09:46:01 <merijn> ski: oh, right, my bad
09:47:36 <Sonolin> what's wrong with
09:47:37 <Sonolin> f :: (String, String) -> (Int, Int); f = read *** read
09:47:46 <phaazon> Sonolin: read is unsafe
09:48:13 <merijn> > read "a" :: Int
09:48:14 <lambdabot>  *Exception: Prelude.read: no parse
09:48:44 <phaazon> magamig: at least
09:48:45 <phaazon> use reads
09:48:47 <phaazon> :t reads
09:48:48 <lambdabot> Read a => ReadS a
09:48:51 <phaazon> dammit :D
09:49:03 <phaazon> > reads "3" :: [(Int,String)]
09:49:05 <lambdabot>  [(3,"")]
09:49:09 <phaazon> > reads "a" :: [(Int,String)]
09:49:10 <lambdabot>  []
09:49:12 <phaazon> ;)
09:49:23 <Sonolin> hm ok
09:49:40 <Sonolin> so what was the solution to the cast tuple of strings -> int problem?
09:49:44 <Sonolin> without read
09:49:54 <ski> > (reads :: ReadS Int) "3"
09:49:55 <lambdabot>  [(3,"")]
09:50:14 <byorgey> Sonolin: nothing
09:50:57 <phaazon> ski: do you know what the S stands for?
09:51:28 <merijn> Why does everyone still recommend reads? :(
09:51:34 <merijn> We have readMaybe in base now...
09:51:59 * hackagebot twitter-types 0.7.1.1 - Twitter JSON parser and types  https://hackage.haskell.org/package/twitter-types-0.7.1.1 (TakahiroHimura)
09:52:40 <yyyyy> in aeson, if i receive JSON fields out of order, does it impact the parser? i.e. if consuming out-of-order fields is a necessity, do i have to forego automatically generated instances for FromJson?
09:53:07 <ski> phaazon : i don't know
09:53:37 <joobus> merijn: where is readMaybe?  I didn't find it on hoogle, and it isn't there in ghci 7.10.2.
09:54:10 <kadoban> joobus: http://haddock.stackage.org/lts-3.9/base-4.8.1.0/Text-Read.html#v:readMaybe
09:54:33 <merijn> joobus: Text.Read
09:54:41 <merijn> joobus: It's not in Prelude
09:54:45 <joobus> thanks
10:00:35 <ReinH> yyyyy: JSON objects aren't ordered
10:08:51 <yyyyy> ReinH: so parsing { "a" : "0" , "b" : "0" } and { "b" : "0" , "a" : "0" } works identically?
10:10:12 <davean> yyyyy: yes
10:10:38 <davean> yyyyy: it wouldn't really by json if that wasn't true
10:11:43 <yyyyy> davean: that's quite good. i'm going to consume some data and the provider specifically says that fields might be missing, new ones might be added and they might come out of order. the first two points didn't concern me, but the third i was unsure.
10:11:59 * hackagebot Lambdaya 0.1.1.0 - Library for RedPitaya  https://hackage.haskell.org/package/Lambdaya-0.1.1.0 (ralu)
10:12:33 <phaazon> @let test a = case (reads a :: [(Int,String)]) of { [(i,[])] -> Just i; _ -> Nothing }
10:12:35 <lambdabot>  Defined.
10:12:38 <phaazon> magamig: ^
10:12:39 <davean> yyyyy: what data provider?
10:12:40 <phaazon> > test "foo"
10:12:42 <lambdabot>  Nothing
10:12:43 <phaazon> > test "23"
10:12:43 <Sonolin> ooh readMaybe is kind of cool :)
10:12:45 <lambdabot>  Just 23
10:12:55 <bennofs> What is the difference between unsafeShift* and shift* from Data.Bits?
10:13:05 <phaazon> bennofs: no idea!
10:13:09 <merijn> bennofs: Wild ass guess: how overflow is handled
10:13:10 <phaazon> and I’m curious about that as well!
10:13:10 <davean> Sonolin: http://hackage.haskell.org/package/safe
10:13:20 <yyyyy> davean: GNIP
10:13:39 <merijn> phaazon: Normally the behaviour for shift greater than bit size is undefined in C (i.e. architecture/CPU dependent)
10:13:39 <Sonolin> davean nice!
10:13:50 <phaazon> merijn: ah?
10:13:51 <merijn> bennofs: Eh, see above :)
10:13:56 <phaazon> I thought we’d have a flag for that
10:14:03 <phaazon> like an overflow flag
10:14:09 <merijn> phaazon: On the CPU in asm, sure
10:14:10 <phaazon> like a carriage flag
10:14:14 <davean> Sonolin: I actually prefer its "readMay" naming, but if you like "May" functions ...
10:14:19 <davean> and really? Who doesn't
10:14:22 <davean> They're insane
10:14:33 <ski> > test " 23 "
10:14:35 <lambdabot>  Nothing
10:14:35 <ski> > (\s0 -> case [n | (n,s1) <- (reads :: ReadS Int) s0,("","") <- lex s1] of [n] -> Just n; _ -> Nothing ) " 23 "
10:14:37 <lambdabot>  Just 23
10:14:39 <ski> phaazon ^
10:14:41 <merijn> But that's not defined in C, and it means that the result in haskell is dependent on the CPU you're running since you can't test said flag
10:14:59 <merijn> Unless you write wrappers that check the flag, which I'm betting is the difference between safe and unsafe shift
10:15:22 <merijn> Mind you, all this is a complete guess from my side, but it seems the only logical thing to me
10:16:10 <tsahyt> Is there something to undo an import in ghci?
10:16:21 <phaazon> ski: yeah, sure
10:16:28 <phaazon> it was just an example for magamig 
10:16:33 <phaazon> I’d use parsec / attoparsec for that
10:29:02 <breadmonster> Hey guys.
10:30:27 <clrnd> hi
10:32:33 <slacko1256> Is totality a necessary condition for a language with dependent types?
10:32:56 <slacko1256> I understand the logic implications but they are no neccesary for a prog lang
10:33:13 <slacko1256> Is there some lang with dependent types and partiality?
10:33:26 <clrnd> idris
10:33:59 <slacko1256> it insist on totalityt
10:34:11 <slacko1256> *totality
10:35:02 <tsahyt> slacko1256: It's necessary as long as you insist on your type system being a consistent logic, yes
10:35:04 <clrnd> not by default
10:37:02 <tsahyt> But we're getting closer to dependent Haskell, so if you can live with an inconsistent logic, you can do that soon
10:38:13 <slacko1256> clrnd: are you sure about that? the tutorial always showed how we where doing structural recursion on the examples
10:38:40 <slacko1256> tsahyt: so you're saying what I am searching is "future" haskell :-D
10:39:14 <tsahyt> Not that far in the future actually. -XTypeInType will probably arrive with GHC 8
10:39:29 <tsahyt> That's not all there is to it of course
10:39:38 <clrnd> slacko1256, http://docs.idris-lang.org/en/latest/tutorial/theorems.html#totality-checking
10:40:24 <tsahyt> clrnd: The unofficial Idris FAQ (here https://github.com/idris-lang/Idris-dev/wiki/Unofficial-FAQ ) says "Idris is a total language".
10:42:20 <pdxleif> You can have your Idris code be just as partial as any Haskell code.
10:42:23 <clrnd> my link says "By default, Idris allows all well-typed definitions, whether total or not"
10:43:18 <tsahyt> Well, since yours links to an official document, I suppose that's right then. The FAQ page was just the first thing that Google gave me
10:43:20 <pdxleif> Enforcing totality is an opt-in feature in Idris.
10:43:33 <clrnd> I have no idea :P
10:44:08 <tsahyt> On a side note, can the totality checker in Idris prove totality for any total function?
10:44:12 <pdxleif> The --total and --warnpartial command-line flags are relevant.
10:45:05 <clrnd> tsahyt, no, because Eitchdensdung :P
10:45:29 <clrnd> (halting problem)
10:45:44 <tsahyt> Thought so
10:45:47 <pdxleif> tsahyt: Nope. There's plenty of total functions that it's uncertain about. It responds with either "total" when it can tell that it's certainly total, or "possibly not total".
10:46:06 <pdxleif> Mentions that a bit in the third paragraph of that totality-checking link.
10:46:48 <tuv> what is the closest thing in the Haskell world to Python's Sqlalchemy? (ORM / mapping of database relations to native language constructs)
10:46:59 <slacko1256> Mmm if this is true then idris is starting to look really nice
10:47:01 * hackagebot language-lua2 0.1.0.5 - Lua parser and pretty printer  https://hackage.haskell.org/package/language-lua2-0.1.0.5 (mitchellwrosen)
10:47:04 <tsahyt> tuv: persistent and esqueleto
10:47:31 <tsahyt> Although the latter is only needed when you specifically want SQL features
10:47:45 <tsahyt> persistent works with a variety of backends
10:48:02 <pdxleif> The mcarthy 91 function is an example of a function that's total that Idris doesn't know is total. https://github.com/puffnfresh/idris-partiality/blob/master/Example.idr#L6
10:48:56 <tsahyt> pdxleif: Does the totality checker work on all primitive recursive functions?
10:50:17 <tuv> tsahyt: if i understand correctly, persistent is used to model the relations/tables, and esqueleto is used for "complex" queries, right?
10:50:48 <tsahyt> tuv: Yes. Persistent only allows queries that work over all its backends, like "get an object by ID from a table"
10:51:02 <pdxleif> tsahyt: I don't know the exact boundaries... it gets into that a bit at the bullet points at the bottom of this section: http://docs.idris-lang.org/en/latest/tutorial/theorems.html#totality-checking
10:51:06 <tuv> tsahyt: although esqueleto syntax appears to be non-obvious
10:51:15 <pdxleif> It has to know the input is "getting smaller" if its recursing on it.
10:51:30 <pdxleif> There's some assertions you can add to your code to tell it "trust me"
10:51:55 <tuv> tsahyt: and too SQL-ish
10:53:08 <tsahyt> tuv: Well if you want SQL power, SQL is your best bet. I wouldn't consider that a downside. But I agree that esqueleto is a bit strange to use. I only use it when I absolutely need joins in my queries.
10:53:26 <tsahyt> tuv: Alternatively, you can also write raw SQL with persistent, but that's error prone of course
10:53:37 <tuv> tsahyt: i take it the other database access libraries, e.g. HDBC, Hasql, HaskellDB are lower-level and require the use of plain SQL statements?
10:53:44 <tsahyt> pdxleif: As far as I can tell, primitive recursive functions would satisfy all of those points
10:53:59 <tsahyt> tuv: Any that I've tried do, yes.
10:55:29 <tsahyt> tuv: esqueleto has the huge advantage that all your queries are statically checked at compile time.
10:57:10 <pdxleif> If you implement factorial with Int, it'll say possibly not total because its recursing and it cant tell the ints are getting smaller (it's just a machine thing external to the language), whereas if you implement it with peano nats (defined in the language as data Nat = Z | S Nat), it can tell its getting smaller from the structural recursion.
10:57:22 <pdxleif> They'd be able to explain things better in the #idris channel
10:58:42 <slacko1256> it seems that idris know that 4 = S S S S Z and will change them appropiatly
11:01:50 <zalatovo> What is the reason for including the header name in FFI declarations? Like "math.h sin"
11:03:55 <pdxleif> There's a bot in the #idris channel if you want to play with it, too.
11:04:16 <pdxleif> Responds like lambdabot would in this channel.
11:04:19 <pdxleif> > 5 + 5
11:04:21 <lambdabot>  10
11:05:58 <thoughtpolice> zalatovo: It's not strictly needed anymore, but if you read the FFI spec it's so that if your code compiles to C, it needs to insert the header file in an #include, because e.g. sin might be a macro wrapper (around __builtin_uberfast_sin, perhaps)
11:06:29 <thoughtpolice> In practice, GHC does not compile to C anymore, and instead properly calls out to the external symbol itself, when it generates machine code.
11:06:38 <zalatovo> thoughtpolice: ah that makes sense, thanks
11:06:52 <thoughtpolice> Also, I'm hoping the next standard will include the 'capi' extension, which I think is more suited for that particular scenario described by the standard.
11:07:20 * hackagebot jose-jwt 0.7 - JSON Object Signing and Encryption Library  https://hackage.haskell.org/package/jose-jwt-0.7 (LukeTaylor)
11:07:51 <thoughtpolice> The 'capi' extension instead specifies the compiler generates its own little bit of C code, which calls the specified function in a wrapper. This allows it to properly handle the case where some identifier you THINK is external is actually a macro.
11:08:13 <thoughtpolice> Of course, life is even worse than that, because whether or not some identifier is a macro or identifier may even depend on things like "how was that library built", because yes, software is awful.
11:08:30 <thoughtpolice> So I think 'capi' is better for this, and 'ccall' should be reserved for when you *know* something resolves to an external symbol.
11:09:10 * ski . o O ( grovelling )
11:09:45 <tsahyt> Is there even a C backend for GHC anymore?
11:10:39 <thoughtpolice> I think so, but it's only used in theory for bootstrapping compiler ports. And bootstrapping that way is both difficult and very rare in practice.
11:11:10 <thoughtpolice> I think having GHC robustly cross compile itself, given some existing toolchain, is a much better path forward than the 'bootstrap port' method.
11:12:16 <bitemyapp> thoughtpolice: what's the state of cross-compilation as an end-user?
11:12:27 <bitemyapp> thoughtpolice: such as from x86_64, targeting ARM (mobile phones?)
11:12:35 <tsahyt> Couldn't you use the LLVM backend for cross compiling?
11:13:14 <bitemyapp> I think that's how it's done currently, but I don't know what sharp edges exist.
11:13:15 <thoughtpolice> "If you're brave, you can make it work". Actually GHC itself supports it pretty well these days I think, it's all the surrounding stuff that still needs work, e.g. I think some Cabal stuff breaks
11:13:46 <thoughtpolice> tsahyt: Using LLVM doesn't change anything about the cross-compiled porting method, whether or not GHC has for example a MIPS backend or we used LLVM's MIPS backend.
11:13:59 <thoughtpolice> In practice the cross compiler ports all use LLVM anyway since it *does* support that stuff, so there you go.
11:14:10 <thoughtpolice> e.g. ARM only can use the LLVM port. A native code generator would be great though.
11:14:39 <thoughtpolice> er, ARM only can use the LLVM backend I mean. But a native ARM codegen would still be good.
11:17:27 <ralu> i was able to crosscompile both ways with and without LLVM
11:19:59 <ralu> is there way to cross compile templates? I am looking for at lest one  web frameworks that can be crosscompiled. 
11:27:21 * hackagebot twitter-conduit 0.1.1.1 - Twitter API package with conduit interface and Streaming API support.  https://hackage.haskell.org/package/twitter-conduit-0.1.1.1 (TakahiroHimura)
11:34:25 <zalatovo> In this guide https://wiki.haskell.org/Foreign_Function_Interface#Data_structures shouldn't the Haskell version of that struct hold a CDouble instead of Double?
11:35:12 <zalatovo> wait I see now Double is an instance of Storable
11:37:21 * hackagebot BlogLiterately 0.8.1.3 - A tool for posting Haskelly articles to blogs  https://hackage.haskell.org/package/BlogLiterately-0.8.1.3 (BrentYorgey)
11:42:35 <dgpratt> suddenly I have a much higher opinion of the intelligence of Australian children (not that it was low before) http://encyclopedia.kids.net.au/page/yo/Yoneda_lemma
11:43:38 <ralu> lol
11:45:32 <tsahyt> Does anyone have experience with LiquidHaskell? Why can it prove that \x -> x + x is of type v:Int -> Even, but can't prove this for \x -> 2 * x? Even is defined as { v : Int | v mod 2 = 0 }
11:46:13 <tsahyt> The underlying solver has no problems with proving 2*x mod 2 == 0
11:52:22 * hackagebot language-c-quote 0.11.3 - C/CUDA/OpenCL/Objective-C quasiquoting library.  https://hackage.haskell.org/package/language-c-quote-0.11.3 (GeoffreyMainland)
12:13:51 <itsmeyo> how can I get around using head? I need to use it but it returns errors when its an empty list
12:15:04 <muzzle> :t sequence
12:15:05 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
12:15:33 <clrnd> > headMay []
12:15:34 <lambdabot>  Not in scope: ‘headMay’
12:15:43 <clrnd> anyway, itsmeyo https://hackage.haskell.org/package/safe-0.3.9/docs/Safe.html
12:16:59 <itsmeyo> clrnd: how can I do it without importing new modules?
12:17:06 <itsmeyo> like what is that module doing that makes it okay?
12:17:17 <clrnd> itsmeyo, oh, it's simple patter matching
12:17:23 * hackagebot varying 0.2.0.0 - FRP through value streams and monadic splines.  https://hackage.haskell.org/package/varying-0.2.0.0 (SchellScivally)
12:17:34 <clrnd> @define headMay [] = Nothing; headMay (x:xs) = Just x
12:17:36 <lambdabot>  Defined.
12:17:40 <clrnd> > headMay []
12:17:41 <lambdabot>  Nothing
12:17:43 <clrnd> > headMay [1,2,3]
12:17:44 <lambdabot>  Just 1
12:18:02 <ski> @type listToMaybe
12:18:04 <lambdabot> [a] -> Maybe a
12:19:01 <Nux__> Hi, I've been following https://www.reddit.com/r/haskellgamedev/comments/3kvm7z/building_and_installing_sdl2_200_sdl2image/
12:19:07 <Nux__> 	Which has given me more success than anything else in getting SDL2 to work in Haskell
12:19:15 <Nux__> unfortunately there are a few things that aren't working as promised
12:19:23 <Nux__> all but the first bindings failed to install
12:20:14 <Nux__> "cabal: Error reading local package.
12:20:29 <Nux__> Couldn't find .cabal file in: .
12:20:31 <Nux__> "
12:20:36 <itsmeyo> ok I got around it by making an exception when the item is not in my list, thanks
12:22:33 <Sindriava> Are there any good beginner resources on automata and grammars?
12:24:06 <itsmeyo> clrnd: could you explain why this fails please? http://paste.ofcode.org/9WyX4LijkfcKWXEpjFRxGA
12:24:20 <clrnd> let me try
12:24:28 <itsmeyo> I've accounted for case where you pass an empty list and also where the letter isn't in any of the 2-tuples
12:24:47 <itsmeyo> but I get this error when I do quickCheck "*** Failed! Exception: 'Prelude.head: empty list' (after 4 tests and 4 shrinks): 
12:24:47 <itsmeyo> 'a'
12:24:47 <itsmeyo> [('a','a')]"
12:25:53 <clrnd> itsmeyo, [toUpper y | (x,y) <- xs, toUpper x == letter] returns empty for that case
12:26:05 <itsmeyo> for what case?
12:26:14 <clrnd> > let xs = [('a','a')] in [toUpper y | (x,y) <- xs, toUpper x == letter]
12:26:15 <lambdabot>      Not in scope: ‘letter’
12:26:15 <lambdabot>      Perhaps you meant one of these:
12:26:15 <lambdabot>        data constructor ‘Setter’ (imported from Control.Lens),
12:26:21 <clrnd> > let xs = [('a','a')] in [toUpper y | (x,y) <- xs, toUpper x == 'x']
12:26:22 <lambdabot>  ""
12:26:35 <clrnd> > let xs = [('a','a')] in [toUpper y | (x,y) <- xs, toUpper x == 'a']
12:26:37 <lambdabot>  ""
12:26:43 <itsmeyo> oh ok I see
12:27:00 <itsmeyo> tricky to get around
12:27:26 <itsmeyo> I can't even do elem letter xs because elem doesn't seem to work on individual items in tuples
12:27:46 <clrnd> :t elem
12:27:47 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
12:28:46 <ski> itsmeyo : tuples aren't homogenous collections
12:28:53 <itsmeyo> yea
12:29:06 <clrnd> itsmeyo, what does lookUp do?
12:30:44 <itsmeyo> so I'm making a caesar cipher, the helper function generated a list of tuples for all letters in the alphabet shifted by n spaces. So xs would be a list like [('A','F')...] for the whole alphabet. Lookup then returns the other letter in the tuple (i.e  the first letter in the tuple shifted n-spaces)
12:31:05 <Gurkenglas_> :t lookup -- itsmeyo
12:31:07 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
12:31:47 <itsmeyo> lookUp :: Char -> [(Char, Char)] -> Char
12:32:15 <clrnd> ok, and your dismissing lower case letters?
12:33:12 <itsmeyo> well no, it works fine for what I need it for (because my list of tuples contain every letter in alphabet so the isLetter guard is enough) it's just it's failing a quickCheck against another function
12:34:56 <itsmeyo> I will probably just leave it because the guards in place are sufficient for its purpose, I just wanted to know if there's something where head [] would just return " "
12:35:30 <Cale> itsmeyo: You could use a case expression for that
12:35:48 <clrnd> coq has headWithDefault iirc
12:36:00 <clrnd> headWithDefault :: [a] -> a -> a
12:36:04 <Cale> case str of [] -> ' '; (x:xs) -> x
12:36:07 <clrnd> but yeah, it's trivial
12:36:27 <tsahyt> clrnd: the safe package also has something like this I think
12:37:01 <lpaste> Cluzz pasted “Monad exercise” at http://lpaste.net/143031
12:37:23 <Cluzz> Hi, can anyone help me solve something? I just pasted it
12:37:35 <Gurkenglas_> :t modify id
12:37:36 <lambdabot> MonadState s m => m ()
12:37:43 <Gurkenglas_> :t get
12:37:44 <lambdabot> MonadState s m => m s
12:37:48 <Cluzz> i got get and modify down, but i really struggle with put :/
12:37:51 <Gurkenglas_> One of these things is not like the other
12:38:45 <Cluzz> Yes, but the type signatures are given with the assignment
12:39:11 <Cluzz> and they have to be made to fit somehow
12:39:16 <Gurkenglas_> modify id does not fulfill the requested type signature
12:39:27 <Cluzz> o.o
12:39:37 <Gurkenglas_> Oh wait nvm your modify is also modified <.<
12:40:10 <Gurkenglas_> Cluzz, want what I would write there on the order of stubbing a toe, or a link to MonadState's original sourcecode?
12:40:50 <Gurkenglas_> Also let us talk to whoever wrote that assignment, just modifying modify's type signature like that
12:41:04 <Cluzz> Gurkenglas_: I have the source, i tried to comprehend that but my teacher messed up the functions on purpose so we wouldn't be a able to blindly copy
12:41:31 <Cluzz> Gurkenglas_: Fine, his name is Ruud Koot from Utrecht Univeristy :P
12:41:33 <Gurkenglas_> Cluzz, the solution lies in that you also have the functions Monad provides to work with
12:42:24 * hackagebot postgresql-schema 0.1.8 - PostgreSQL Schema Management  https://hackage.haskell.org/package/postgresql-schema-0.1.8 (markfine)
12:42:27 <Cluzz> Gurkenglas_: Really? I only have "import Control.Monad       (ap, liftM, replicateM, filterM)" these to work with. The rest has to be defined by us
12:42:30 <Gurkenglas_> Clearly, put cannot be implemented using _just_ the monad functions, or it wouldn't need to be specified in the class, so you have to use modify or get, but you're no limited to them
12:42:42 <Gurkenglas_> They suffice.
12:43:48 <Gurkenglas_> Do you have an ansatz you tried, but that didn't work for a stupid reason?
12:44:41 <Bez_> Gurkenglas_: 'ansatz' xD
12:44:50 <Cluzz> Gurkenglas_: I found a stackoverflow post that said        put s = modify $ const s
12:44:58 <Cluzz> Gurkenglas_: But that didn't work
12:45:02 <Gurkenglas_> Why not?
12:45:18 <Gurkenglas_> Bez_, https://en.wikipedia.org/wiki/Ansatz it's a real word!
12:45:21 <Cluzz> Just a sec, i'll get the error message
12:45:46 <Gurkenglas_> I don't need the error message, I know why.
12:45:49 <Gurkenglas_> Explain in your own words.
12:46:40 <Bez_> Gurkenglas_: I guessed as much, but I thought it was funny, because well, Ich kann auch Deutsch :p
12:46:41 <Cluzz> because it doesn't return ()
12:46:42 <Cluzz> but s
12:46:49 <arkeet> :t modify
12:46:51 <lambdabot> MonadState s m => (s -> s) -> m ()
12:47:24 <Gurkenglas_> (Were you given any instructions about the semantics your three implementations must fulfill?)
12:47:50 <arkeet> oh ther'es a paste
12:48:18 <Cluzz> Gurkenglas_: yes.. i think so. http://foswiki.cs.uu.nl/foswiki/pub/FP/CourseAssignments/Assignment4.pdf
12:48:37 <Cluzz> Gurkenglas_: it's under exercise 8
12:48:58 <Cluzz> Gurkenglas_: actually.. just above 8
12:50:19 <Gurkenglas_> Cluzz, that still leaves two semantically different implentations for modify :S
12:51:03 * arkeet can think of infinitely many
12:51:06 <Gurkenglas_> (Actually infinitely many but two of them "make sense")
12:51:50 <Cluzz> Gurkenglas_: Really...? I'm not even sure that i know what that means :s
12:52:23 <arkeet> should the result of modify be the old value, or the new value, or something else? how many times should it apply the given function? 
12:52:51 <arkeet> there are no laws relating modify to the other functions
12:52:53 <arkeet> methods
12:53:45 <Cluzz> I guess that you give a function that alters the state once
12:53:52 <Cluzz> just once
12:54:00 <Cluzz> put forces a state
12:54:04 <Cluzz> and get retrieves the state
12:54:14 <Cluzz> those are what i aimed for anyway
12:54:18 <arkeet> for all we know, modify is allowed to completely ignore its (s -> s) argument.
12:54:26 <arkeet> (of course, it would be pretty useless that way.)
12:54:50 <tsahyt> Why does http://lpaste.net/8828035110600179712 not compile? I've been doing something like this before, but somehow GHC cannot deduce (KnownNat n0) arising from a use of 'natVal' here, even though ScopedTypeVariables is enabled
12:54:52 <Gurkenglas_> If it was earlier in the day in Germany I'd just call him on his phone now, heh.
12:55:07 * ski imagines an implementation of `modify' that applies the function the *next* time `modify' is executed
12:55:10 <arkeet> (an indexed state monad would leave no room for choices though.)
12:55:58 <Gurkenglas_> ski, but that couldn't be implemented in terms of get, put, and Monad.
12:56:37 <ski> admittedly
12:56:38 <Cluzz> By the way, it's supposed to be a beginners course. 6 weeks ago most of the students didn't even know what haskell was
12:57:07 <Cluzz> O.O
12:57:22 <cloj_dev> hello, how would would you write a function that flips the order of 2 other functions? I tried  flip_functions f f2 = \x y -> f2 f y x 
12:57:36 <Gurkenglas_> Cluzz, the line your pasted doesn't work here because the modify returns an s you don't need. Discard it.
12:57:39 <cloj_dev> it didn't work
12:58:05 <Gurkenglas_> cloj_dev, give us the type signature of the function you want
12:58:32 <Gurkenglas_> Oh, and say only it, and put @djinn in front of it.
12:58:53 <cloj_dev> (a -> b) -> (x -> y) -> (x -> y) -> (a -> b)
12:58:56 <cloj_dev> something like that
12:59:10 <tsahyt> @djinn (a -> b) -> (x -> y) -> (x -> y) -> (a -> b)
12:59:10 <lambdabot> f a _ _ b = a b
12:59:57 <lpaste> Cluzz revised “Monad exercise”: “No title” at http://lpaste.net/143031
13:00:06 <Gurkenglas_> (Now that the novelty factor has passed, try again in /query lambdabot until you're stumped on your next try.)
13:00:12 <dc_> xpost from #xmonad. This is not directly a Haskell question. Apologize in advance if this is the wrong channel. I've successfully changed the resolution of my monitor using xrandr, however I have yet to succeed in obtaining the right resolution for GUI programs like Firefox, Chromium (they appear to be in 800x600, even when in full screen). How should I go about solving this problem?
13:01:15 <Gurkenglas_> Cluzz, your modify must return an s, you must discard it only when trying to use it to implement put.
13:01:16 <aweinstock> :t flip ($)
13:01:17 <lambdabot> a -> (a -> c) -> c
13:01:26 <aweinstock> :t flip . ($)
13:01:30 <lambdabot> (a -> b -> c) -> b -> a -> c
13:01:49 <ski>   flip . ($)  =  flip . id  =  flip
13:01:53 <Gurkenglas_> aweinstock, ($) is id, ". ($)" doesnt make much sense
13:01:55 <Cluzz> Gurkenglas_: you know what, i'll just paste the entire source.. 
13:02:00 <lpaste> Cluzz revised “Monad exercise”: “No title” at http://lpaste.net/143031
13:02:20 <aweinstock> @pl \ a _ _ b -> a b
13:02:21 <lambdabot> const . const
13:02:31 <aweinstock> :t const.const
13:02:33 <lambdabot> a -> b -> b1 -> a
13:02:34 <Gurkenglas_> Cluzz, "return s  -- return the altered state monad" that's the old one.
13:03:17 <Cluzz> Gurkenglas_: Ok... I'll change that thanks
13:03:24 <aweinstock> cloj_dev: are you sure that type signature is what you meant? (the (x->y) never gets used)
13:03:54 <cloj_dev> yeah, might be the wrong sig
13:04:08 <aweinstock> :t (\f g x y -> g f x y)
13:04:09 <lambdabot> r1 -> (r1 -> r2 -> r3 -> r) -> r2 -> r3 -> r
13:04:10 <tsahyt> Is there some shortcut to enable all GHC extensions at once?
13:04:29 <cloj_dev> ah interesting
13:04:45 <aweinstock> :t (\f g x y -> g f y x)
13:04:46 <Gurkenglas_> tsahyt, some of them change the meaning of existing syntax rather than introducing its own
13:04:47 <lambdabot> r1 -> (r1 -> r2 -> r3 -> r) -> r3 -> r2 -> r
13:04:56 <cloj_dev> every function in haskell takes one param and gives one return, right?
13:05:02 <tremon> tsahyt: don't think so. Some cause the universe to implode if you cross them
13:05:12 <cloj_dev> so a function that takes 2 args is actually 2 functions curried together, right?
13:05:17 <aweinstock> cloj_dev: yes
13:05:35 <cloj_dev> interesting
13:05:44 <tsahyt> Well okay then. I've found the problem without trying all extensions anyway.
13:06:33 <hexagoxel> :exf -p "r1 -> (r1 -> r2 -> r3 -> r) -> r2 -> r3 -> r"
13:06:33 <exferenceBot> flip id
13:06:35 <aweinstock> cloj_dev: (f x y z = w), (f x y = \z -> w), (f x = \y z -> w), (f x = \y -> \z -> w), and so on, all express the same function
13:06:56 <aweinstock> (it sounds like you might already know this since you know about currying, but just to make it explicit)
13:07:27 <hexagoxel> :t flip id
13:07:29 <lambdabot> b -> (b -> c) -> c
13:07:37 <aweinstock> :t (flip . flip) id
13:07:39 <lambdabot> (a -> c) -> a -> c
13:07:54 <aweinstock> :t [(flip . flip) id, ($), id]
13:07:56 <lambdabot> [(a -> c) -> a -> c]
13:07:56 <ski> cloj_dev : "a function that takes 2 args is actually 2 functions curried together" sounds strange
13:08:21 <aweinstock> :t (flip.flip)
13:08:22 <lambdabot> (b -> a -> c) -> b -> a -> c
13:08:48 <adimit> @pl \a b c -> b<>a<>c
13:08:48 <lambdabot> ((<>) .) . flip (<>)
13:10:19 <ideuler> If map applies the same function to an entire list, is there a way to recursively do different things on certain elements? Such as, changing the first odd number to -2, the second to -1 till it reaches 2 for example?
13:10:27 <tsahyt> @src lcm
13:10:27 <lambdabot> lcm _ 0 = 0
13:10:27 <lambdabot> lcm 0 _ = 0
13:10:27 <lambdabot> lcm x y = abs ((x `quot` (gcd x y)) * y)
13:10:37 <ski> cloj_dev : we can express "takes several args" in two main ways in Haskell : (a) tupled style, the function taking a tuple (or record or other datastructure) holding the two conceptually separate arguments; (b) curried style, the function taking one argument at a time, returning a new function that (curriedly) takes the rest, before finally yielding the (conceptual) result
13:11:11 <Cluzz> Gurkenglas_: I know about the >> operator to discard results... also do _ <- {- something -}; return () might work
13:11:20 <ski> ideuler : `mapM' with the state monad might do what you want .. or `mapAccumL'
13:11:37 <aweinstock> :t mapAccumL
13:11:38 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
13:12:05 <ideuler> @ski Thanks! I'll look into it.
13:12:05 <lambdabot> Maybe you meant: wiki src ask
13:12:42 <ski> ideuler : IRC custom is to not prefix nicknames with `@', but to (usually) start the message directly with the nick, and then continue with `:' or `,' before the message
13:13:20 <aweinstock> :t mapAccumL (\oddsCount elem -> if odd elem then (oddsCount+1, oddsCount-2) else (oddsCount, elem)) 0
13:13:22 <lambdabot> (Integral c, Traversable t) => t c -> (c, t c)
13:13:24 <benzrf> ideuler: your client probably does it by default, even (if you tab complete a nick at the beginning of the line)
13:13:29 <tsahyt> Is there a type level if-then-else in base?
13:13:35 <aweinstock> > mapAccumL (\oddsCount elem -> if odd elem then (oddsCount+1, oddsCount-2) else (oddsCount, elem)) 0 [1..10]
13:13:37 <lambdabot>  (5,[-2,2,-1,4,0,6,1,8,2,10])
13:13:42 <benzrf> ideuler: in irssi and weechat, for example, typing 'ide<tab>' will put "ideuler: "
13:13:51 <ski> ideuler : in case you're not familiar with `Traversable', ignore the `Traversable t => ' part, and pretend `t b' and `t c' said `[b]' and `[c]', in the type reported for `mapAccumL' above
13:14:35 <ski> ah, nice, aweinstock provided an example of how to use it
13:16:11 <ideuler> Oh boy. You all make me love haskell even more. 
13:16:14 <aweinstock> ski: I figured out the meaningful names to use from the type
13:16:36 <benzrf> why doesnt minimumOn exist btw
13:16:43 <benzrf> ideuler: good to hear :]
13:16:55 <aweinstock> :t (minimum `on`)
13:16:57 <lambdabot>     Occurs check: cannot construct the infinite type: b ~ t0 (b -> c)
13:16:57 <lambdabot>     Expected type: b -> b -> c
13:16:57 <lambdabot>       Actual type: t0 (b -> c) -> b -> c
13:17:11 <aweinstock> :t (minimum, minimumBy, on)
13:17:12 <lambdabot> (Ord a, Foldable t, Foldable t1) => (t a -> a, (a1 -> a1 -> Ordering) -> t1 a1 -> a1, (b -> b -> c) -> (a2 -> b) -> a2 -> a2 -> c)
13:17:33 <aweinstock> > minimum []
13:17:35 <lambdabot>  *Exception: Prelude.minimum: empty list
13:17:57 <aweinstock> benzrf: what are you imagining minimumOn doing?
13:18:10 <aweinstock> :t minimum . map
13:18:12 <lambdabot> (Ord b, Foldable ((->) [a])) => (a -> b) -> [b]
13:18:25 <aweinstock> :t (minimum .) . map
13:18:27 <lambdabot> Ord c => (a -> c) -> [a] -> c
13:18:38 <ski> @type minimumBy . comparing  -- benzrf ?
13:18:39 <lambdabot> (Ord a1, Foldable t) => (a -> a1) -> t a -> a
13:19:24 <benzrf> ski: 'swhat i'm using
13:19:28 <benzrf> jw why the lack
13:19:48 <ski> dunno
13:20:13 <Gurkenglas_> :t alaf StateT traverse -- Aww, the pair and argument orders of mapAccumL are all wrong.
13:20:14 <lambdabot> (Monad m', Traversable t) => (a -> s' -> m' (a', s')) -> t a -> s' -> m' (t a', s')
13:21:06 <ski> yes :(
13:22:18 <aweinstock> :t ((>=>) `on`) -- I'm not entirely sure what this should do, but it typechecks
13:22:19 <lambdabot> Monad m => (a -> a1 -> m a1) -> a -> a -> a1 -> m a1
13:23:25 <aweinstock> :t \f x x' y -> f x y >>= f x' -- is this right?
13:23:27 <lambdabot> Monad m => (r -> b -> m b) -> r -> r -> b -> m b
13:23:29 <ReinH> aweinstock: Probably the only obvious thing that uses both a and a1?
13:23:40 <ReinH> @src on
13:23:40 <lambdabot> (*) `on` f = \x y -> f x * f y
13:23:50 <Gurkenglas_> :exf "Monad m => (a -> a1 -> m a1) -> a -> a -> a1 -> m a1"
13:23:51 <exferenceBot> \ f1 b c d -> f1 b d >>= f1 c
13:23:51 <exferenceBot> \ f1 b c d -> f1 c d >>= f1 b
13:24:24 <ReinH> *uses both a's and the a1
13:24:41 <ReinH> (>=>) `on` f = \x y -> f x >=> f y
13:26:47 <ReinH> Same difference
13:27:19 <ReinH> f a b >>= g c = f a >=> g c
13:27:29 <Gurkenglas_> One of the things I envision exference to do in the future is go through all the type signatures in libraries and find the isomorphic type signature of each one that has the shortest implementation in terms of high-level libraries, to hint at elegant API changes.
13:28:03 <aweinstock> Gurkenglas_: what is exference? djinn-on-steroids?
13:29:03 <Gurkenglas_> Yea, pretty much, except it uses brute force instead of theorem deduction, as is (i think) the only possible way once you add recursive data structures
13:29:39 <aweinstock> is there not a (viable/tractible) way to interleave theory and brute force?
13:29:58 <Gurkenglas_> That way lay Singularity :P
13:30:24 <aweinstock> the concept of Singularity in general, or a specific project named Singularity?
13:30:33 <Gurkenglas_> the former
13:31:51 <Gurkenglas_> And not a bad one either, I'd guess the kind of thing that can be produced on that path is way easier to prove unsusceptible to blowing up in our faces
13:32:26 * hackagebot webdriver 0.8.0.1 - a Haskell client for the Selenium WebDriver protocol  https://hackage.haskell.org/package/webdriver-0.8.0.1 (AdamCurtis)
13:34:14 <aweinstock> Gurkenglas_: how so?
13:40:08 <hexagoxel> aweinstock: the problem exference solves is undecidable (which presumes a "brute-force" approach, right?). And i don't know a way to turn the properties that cause the undecidability into special-cases, without entirely removing support for central features (like for proper type classes).
13:40:19 <hexagoxel> @djinn Monad m => a -> m a
13:40:20 <lambdabot> f = return
13:40:24 <hexagoxel> @djinn Monad m => b -> m b
13:40:24 <lambdabot> -- f cannot be realized.
13:41:08 <aweinstock> does djinn special-case some typeclass-including signatures?
13:41:23 <ReinH> heh
13:41:27 <dolio> No.
13:41:30 <hexagoxel> i don't know for sure, but my assumption is that even the above limitation to djinn's functionality is necessary to get to decidability
13:42:03 <dolio> Type classes are done by adding premises.
13:42:27 <ski> djinn doesn't really handle type classes with polymorphic methods
13:42:35 <aweinstock> dolio: how is it able to get (return :: a -> m a), but not the eta-equivalent (return :: b -> m b)?
13:42:35 <dolio> So 'Monad m => t' is the same as '(a -> m a) -> (m a -> (a -> m b) -> m b) -> t'
13:42:51 <dolio> Or however it was typed in.
13:43:10 <ski> aweinstock : alpha-convertible
13:43:29 <dolio> It isn't alpha convertable, because there is no quantifier.
13:43:45 <dolio> There are no quantifiers in djinn.
13:43:50 <ski> yes
13:52:51 <Suq_Madiq> serious issue here, my daughter smeared feces all over her face and ate some of it too, can she get sick? should i call doctor?
13:53:21 --- mode: ChanServ set +o shachaf
13:53:39 --- mode: shachaf set +b *!*@*51.174.19.26
13:53:44 --- kick: Suq_Madiq was kicked by shachaf (Suq_Madiq)
13:53:46 <adimit> thanks.
13:53:46 --- mode: shachaf set -o shachaf
13:55:33 <fkbm> Wow.. It's the first time I see a spam bot on freenode.
13:56:08 <jophish_> What was the desired outcome there?
13:57:50 <zomg> fkbm: either you're lucky or haven't been here very long :D
13:57:51 <fkbm> Maybe just to annoy people..  or disgust for that matter.
13:58:01 <zomg> but if you've been here long... I'd suggest investing in lottery
13:58:02 <zomg> lol
13:58:15 <fkbm> zomg: I intend on coming more often :)
14:02:21 <Sindriava> Are there any good beginner resources on automata and grammars?
14:03:07 <tsahyt> Sindriava: Elements of the Theory of Computation is a pretty good beginner book on the topic
14:03:23 <Sindriava> tsahyt: Thanks! I'll have a look :)
14:05:42 <JagaJaga> Is there a point free if?
14:06:18 <ski> @type bool
14:06:19 <lambdabot> a -> a -> Bool -> a
14:06:39 <tsahyt> :t if'
14:06:41 <lambdabot>     Not in scope: ‘if'’
14:06:41 <lambdabot>     Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
14:07:11 <JagaJaga> Where is "bool"? Seems that it is no in prelude.
14:07:11 <tsahyt> http://hackage.haskell.org/package/utility-ht-0.0.11/docs/Data-Bool-HT.html#v:if-39-
14:07:25 <tsahyt> Here's if' :: Bool -> a -> a -> a
14:07:33 <aweinstock> :t let if' c t f = if c then t else f
14:07:35 <lambdabot> <no location info>:
14:07:35 <lambdabot>     not an expression: ‘let if' c t f = if c then t else f’
14:07:39 <aweinstock> :t let if' c t f = if c then t else f in if'
14:07:40 <lambdabot> Bool -> t -> t -> t
14:08:10 <tsahyt> @pl if a then b else c
14:08:11 <lambdabot> if' a b c
14:08:14 <JagaJaga> :t let if' t f c = if c then t else f in if'
14:08:15 <lambdabot> t -> t -> Bool -> t
14:08:17 <JagaJaga> better
14:08:37 <ski> @pl bool t f b = if b then t else f
14:08:38 <lambdabot> bool = flip . flip if'
14:08:44 <Sindriava> tsahyt: Who's the author, btw? I found 2 books with that name
14:08:54 <aweinstock> why does @pl have if' in scope, but :t doesn't?
14:09:11 <tsahyt> Sindriava: Lewis & Papadimitriou
14:09:16 <Sindriava> tsahyt: Thanks!
14:09:58 <Hijiri> to get free group can I take the finite list version of the free monoid and add a negation operation that reverses the list and negates its contents?
14:10:55 <dolio> pl just compiles things into an arbitrary set of functions of its own definition, one of which is if'.
14:11:05 <dolio> And :t is actually running a Haskell type checker.
14:11:10 <Gurkenglas> Well, at best you'd get the finite version of the free monoid.
14:11:24 <Gurkenglas> *group
14:14:41 <aweinstock> Hijiri: why is reversing the list necessary? group-inverting every element already satisfies the group axioms (I think?)
14:15:45 <ski> aweinstock : only for abelian groups
14:16:14 <monochrom> inverse a * inverse b = inverse (a*b)
14:16:16 <monochrom> err
14:16:20 <monochrom> inverse a * inverse b = inverse (b*a)
14:16:20 <ski> Hijiri : you also need to collapse adjacent elements that are inverses of each other
14:17:28 <monochrom> example: to undo "put on socks, then put on shoes", you do not go "take off socks, then take off shoes". quite the contrary.
14:18:19 <shachaf> To undo "put on socks, then put on shoes", you go "put on anti-shoes, then put on anti-socks".
14:18:56 <aweinstock> putting on anti-shoes is defined to be taking off shoes though?
14:19:39 <monochrom> I just hope that anti-shoes are not made of antimatter. would get a lot of harmful radiation when annihilating with shoes
14:20:44 <hexagoxel> has anyone ever considered/tested using a custom prelude involving a CPP `#include` to get qualified modules as part of the Prelude?
14:20:51 <Gurkenglas> When a*A = A*a = 1, b*B = B*b = 1, and 1 being the multiplicative identity is given, you can turn a*b*B*A into 1, but not a*b*A*B.
14:20:54 <Ferdirand> if a*a' = 1 and b*b' = 1, it's very clear that (a*b)*(b'*a') = 1, because associativity
14:21:01 <Ferdirand> ah well, beaten to it
14:27:49 * hackagebot fltkhs 0.2.0.2 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.2.0.2 (deech)
14:36:29 <Gurkenglas> https://www.reddit.com/r/haskell/comments/3oq0kd/proposal_eliminate_the_monad_implementation_on/
14:36:32 <Gurkenglas> What?
14:36:35 <Gurkenglas> > ("x","ab") >>= \xs -> ("y", length xs)
14:36:37 <lambdabot>      No instance for (Monad ((,) [Char])) arising from a use of ‘>>=’
14:36:37 <lambdabot>      In the expression: ("x", "ab") >>= \ xs -> ("y", length xs)
14:36:56 <Gurkenglas> No such monad instance.
14:37:21 <Gurkenglas> (Which is bad!)
14:40:35 <arkeet> don't remove any tuple instances
14:40:56 <bitemyapp> arkeet: we'll just wait until you go to bed
14:41:01 <bitemyapp> arkeet: then poof. They'll be gone!
14:41:09 <arkeet> :(
14:41:35 <Gurkenglas> Yes, I'm declaring confusion on them wanting to replace the ((,) a) monad instance
14:41:41 <Gurkenglas> *remove
14:42:07 <Gurkenglas> Because... what ((,) a) monad instance? We'll have to add it to remove it, and I agree with the adding part
14:42:49 * hackagebot snaplet-ghcjs 0.1.0.0 - Serve javascript files compiled with GHCJS  https://hackage.haskell.org/package/snaplet-ghcjs-0.1.0.0 (johncant)
14:43:14 <arkeet> we should add it.
14:43:15 <arkeet> by default.
14:43:36 <arkeet> until then, there is Control.Monad.Instances or whatever
14:44:00 <arkeet> wait.
14:44:04 <arkeet> never mind.
14:51:59 <ideuler> @pl curve l = l ++ (reverse l)
14:51:59 <lambdabot> curve = ap (++) reverse
14:52:02 <glguy> osa1: You around?
14:54:02 <ideuler> @pl curve x l = l ++ [x] ++ (reverse l)
14:54:02 <lambdabot> curve = ap (++) . (. reverse) . (:)
14:55:18 <CasW> Hey guys, quick question; what does <$> do?
14:55:50 <kadoban> :t (<$>)
14:55:51 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:55:54 <ski> applies a function to every "element of a collection", roughly
14:55:56 <kadoban> It's fmap
14:56:08 <ski> except it doesn't have to be a "collection" in the usual sense
14:57:38 <CasW> Aah, okay, thanks!
14:57:50 <ski> all clear ?
14:58:59 <CasW> Clear enough ;) Clear enough to understand what this code I'm looking through, does
14:59:17 <ReinH> CasW: <$> is fmap, if you're already familiar.
14:59:42 <ReinH> Well. (<$>) is fmap.
15:00:26 <CasW> I need to dig a bit through my memories, but I remember using it some time. I'm far from experienced using Haskell
15:01:51 <osa1> glguy: yep
15:02:25 <glguy> I learned about a neat feature in alex that I wanted to share https://github.com/glguy/language-lua/commit/b7f2c1b0ad1cc3ac350909a2d4703f8a602b5bee
15:02:52 <glguy> osa1: The alex feature shows up on line 90 of the .x file
15:04:57 <nitrix> CasW: It transform a value of type `f a` to a value of type `f b` by applying a transformation function (a -> b) while preserving the context `f`.
15:05:08 <nitrix> > (+2) <$> Just 3
15:05:10 <lambdabot>  Just 5
15:05:45 <osa1> glguy: interesting. is Mode defined by Alex?
15:05:55 <CasW> Ah, yes, exactly! That made it entirely clear, thanks :P
15:06:28 <glguy> osa1: https://github.com/glguy/language-lua/blob/happy/src/Language/Lua/LexerUtils.hs#L171
15:09:19 <Nux__> what does '@pl' do?
15:09:47 <josephle> Nux__: makes the given expression "pointless"
15:10:13 <Nux__> @pl test x = x + 1
15:10:13 <lambdabot> test = (1 +)
15:10:16 <Nux__> I see
15:10:24 <Nux__> cheers
15:10:27 <nitrix> Works the opposite way too:
15:10:41 <Nux__> @pl test = (1 +)
15:10:41 <lambdabot> test = (1 +)
15:10:45 <nitrix> @pl foo = \x -> x - 100
15:10:45 <lambdabot> foo = subtract 100
15:10:50 <arkeet> @unpl test = (1 +)
15:10:50 <lambdabot> test a = 1 + a;
15:11:05 <Nux__> ah I see
15:11:22 <Nux__> cool
15:11:44 <ReinH> This can lead to some rather amusing constructions.
15:11:57 <ReinH> @pl \a b c d e f g h i j -> f (g a b c d e f g h i j)
15:11:58 <lambdabot> ((((ap ((.) . (.) . (.) . (.)) .) .) .) .) . flip flip id . ((flip . ((flip . ((flip . ((flip . (ap .) . flip) .) . flip) .) . flip) .) . flip) .) . flip . flip id
15:12:02 * Clint shudders.
15:12:28 <ReinH> @pl \a b c d e f g h i j -> f (g c d f g a b h j i)
15:12:29 <lambdabot> ((((const . ap ((.) . (.) . (.) . (.)) . (((flip .) .) .)) .) .) .) . flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip flip id . ((flip . (ap .) . flip) .) . flip . flip id)
15:12:29 <Nux__> that certainly is pointless
15:12:33 <ReinH> And so on.
15:12:34 <Nux__> ;)
15:12:39 <Sonolin> lol
15:12:43 <ReinH> Nux__: Yes. That is the joke. :)
15:13:20 <lamefun> Should I use !(Vector a) instead of [a] and !Text instead of String everywhere?
15:14:03 <ReinH> lamefun: No.
15:14:36 <lamefun> Almost everywhere?
15:14:40 <kadoban> You should probably use Text pretty often.
15:14:46 <ReinH> Text is often better than String
15:15:02 <ReinH> Vector and [] not so much, it depends.
15:15:14 <arkeet> [] has its uses.
15:15:39 <ReinH> If your thing needs to behave like an array, Vector is probably better. If it needs to behave like a linked list, [] is probably better.
15:16:16 <ReinH> There are lots of places where lists can be used that you might reach for an array in another language though, so it isn't clear cut
15:22:51 * hackagebot rei 0.3.2.0 - Process lists easily  https://hackage.haskell.org/package/rei-0.3.2.0 (kerkomen)
16:11:56 <GLM> Why does the following line not work?
16:12:01 <GLM> Identity "TEST" > id
16:12:07 <GLM> Identity "TEST" >>= id
16:12:28 <arkeet> why should it work?
16:12:48 <GLM> arkeet:My understanding that you just pipe it through a function
16:12:54 <arkeet> :t (>>=)
16:12:55 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:13:29 <arkeet> now picture what happens when you put id for the second argument.
16:14:05 <GLM> I see now. Is there a way to use fmap for a monad or is fmap the canonical way for monads
16:14:31 <arkeet> you can just use fmap. (Functor is a superclass of Monad sinc ghc 7.10)
16:14:38 <arkeet> since
16:15:09 <GLM> Why would I want to use >>= then? It seems like all of those use cases would be better solved with fmap?
16:15:16 <arkeet> (and before 7.10, you could use liftM instead of fmap if you really only want a Monad constraint, or you can just use fmap anyway since every instance of Monad also has a Functor instance)
16:15:20 <arkeet> because
16:15:29 <arkeet> it lets you do things fmap can't.
16:16:51 <GLM> arkeet:What things would those be>
16:17:15 <fizbin_mobile> >>= is for when you really do have an a->m b, and can't easily rewrite it as an a->b
16:18:45 <fizbin_mobile> GLM: I think the simplest example would be a list comprehension.
16:18:53 <dmj`> GLM: putStrLn =<< getLine
16:19:59 <GLM> fizbin:When would that happen beyond comprehensions? It might be that I write most of my code but it seems like that is a bit rare
16:20:53 <fizbin_mobile> > let f x = [x*10, x*20, x*30] in [3, 4, 5] >>= f
16:20:54 <lambdabot>  [30,60,90,40,80,120,50,100,150]
16:20:58 <GLM> dmj`:How does that work? putStrLn and getLine have different types
16:21:45 <dmj`> GLM: (getLine :: IO String) (>>= :: IO String -> (String -> IO ()) -> IO ()) -> (putStrLine :: String -> IO ())
16:22:05 <dmj`> s/putStrLine/putStrLn
16:22:22 <fizbin_mobile> :t join
16:22:23 <lambdabot> Monad m => m (m a) -> m a
16:22:35 <dmj`> GLM: do you see how the types align there?
16:22:35 <fizbin_mobile> :t join . fmap
16:22:37 <lambdabot>     Occurs check: cannot construct the infinite type: f ~ (->) (f a1)
16:22:37 <lambdabot>     Expected type: (a1 -> a) -> f a1 -> f a1 -> a
16:22:37 <lambdabot>       Actual type: (a1 -> a) -> f a1 -> f a
16:22:46 <dmj`> :t join $ fmap getLine putStrLn
16:22:47 <lambdabot>     Couldn't match expected type ‘IO () -> String -> a’
16:22:47 <lambdabot>                 with actual type ‘IO String’
16:22:47 <lambdabot>     In the first argument of ‘fmap’, namely ‘getLine’
16:23:13 <dmj`> :t join $ fmap putStrLn getLine
16:23:14 <lambdabot> IO ()
16:23:26 <GLM> Are IO String and IO () considered the same type?
16:24:25 <glguy> no
16:24:41 <dmj`> GLM: IO is considered a type constructor, it can become a concrete type when its applied to another type of kind *
16:24:49 <dmj`> :k IO
16:24:50 <lambdabot> * -> *
16:24:51 <EvanR> if i have type E a = forall x . Event x a, and i have an E a, is there anything that i can do with it? what sort of function will accept it
16:24:54 <dmj`> :k IO String
16:24:55 <lambdabot> *
16:25:24 <EvanR> trying to simplify a phantom type param with a type synonym
16:25:26 <arkeet> EvanR: anything that will accept any Evenet x a
16:25:35 <arkeet> Event x a
16:25:41 <EvanR> well, its not unifying
16:25:46 <arkeet> share code?
16:27:12 <EvanR> http://lpaste.net/143038
16:27:52 <EvanR> well, if i take out the forall in the gadt, its the same error
16:28:51 <EvanR> bad paste check now
16:29:09 <GLM> Would it be possible to have a list of potential return types of a function? Not saying it'd be a good idea, just curious
16:29:15 <GLM> without using Either too
16:29:18 <glguy> EvanR: your paste loads for me in GHCi
16:29:28 <EvanR> yeahi just noticed
16:29:33 <EvanR> the updated one doesnt
16:31:06 <glguy> 143038 does
16:31:51 <EvanR> ... ill copy 143038 and try it
16:31:58 <glguy> GHC 7.10.2?
16:32:16 <EvanR> i have ghc 7.6
16:32:42 <glguy> Might be time to update if you're running into a fixed bug
16:32:56 <EvanR> so its not a bug?
16:33:05 <EvanR> on my part
16:33:16 <EvanR> Couldn't match type `Event x (Maybe a)' with `forall x1. Event x1 (Maybe a)'
16:33:43 <EvanR> requires being explicit about type variables or something?
16:33:54 <EvanR> i know i should upgrade
16:33:55 <glguy> try: filterE x = Filer x
16:34:27 <arkeet> monomorphism restriction?
16:34:30 <glguy> The behavior of rank-n types has changed over time
16:34:32 <arkeet> no wait there s a type signature
16:34:40 <EvanR> holyyyy
16:35:16 <EvanR> http://lpaste.net/143042
16:35:30 <EvanR> this might also explain why i was segfaulting while doing a breadth first traversal a few days ago
16:35:55 <EvanR> oh i mis typed the flag :(
16:36:00 <EvanR> though it was kernal panic
16:36:20 <EvanR> that fixed it
16:36:50 <Lokathor> quite the old GHC you got there EvanR 
16:37:22 <EvanR> ikr
16:37:31 <EvanR> upgraded about a year ago
16:39:08 <ski> glguy : hm, it can auto-convert from `forall a. F a -> G a' to `(forall a. F a) -> (forall a. G a)', now ?
16:42:02 <glguy> Yeah
16:42:03 <EvanR> can abstract over UnionU and UnionG with one utility function on E a
16:42:14 <glguy> test :: (forall a. f a -> g a) -> (forall a. f a) -> (forall a. g a); test x = x
16:43:04 <EvanR> i guess that would require a runtime type check
16:51:10 <EvanR> it messes up the monoidness
16:53:02 <ski>   Union :: Event g0 a -> Event g1 a -> Event (Merge g0 g1) a  -- maybe ?
16:53:28 <EvanR> whats Merge
16:54:09 <ski>   type family (g0 :: Guardedness) (g1 :: Guardedness) :: Guardedness
16:54:20 <ski> er, with `Merge' in there
16:54:30 <ski>   type instance Merge G G = G
16:54:41 <ski>   type instance Merge G U = U
16:54:45 <ski>   type instance Merge U G = U
16:54:47 <ski>   type instance Merge U U = U
16:54:51 <ski> or something like that
17:02:04 <EvanR> i got the syntax straight
17:02:37 <EvanR> but mappend = Union gives the error http://lpaste.net/143043
17:03:12 <EvanR> hmm
17:03:43 <EvanR> Guardedness is a DataKind?
17:04:03 <EvanR> or a type
17:07:52 <EvanR> heh i switched it all around but came back the same error, Couldn't match type `x' with `Merge x x'
17:09:21 <EvanR> Monoid (Event Guardedness a) where, says Guardedness has kind * but should have Guardedness ...
17:13:31 <EvanR> fixed that but seems like x cant unify with Merge x x
17:16:58 <EvanR> can this be done with type classes instead?
17:27:10 <EvanR> a closed family syntax does not work, maybe i need to upgrade ghc........ for real
17:59:18 <EvanR> ski: thanks for helping. i gave up and went with two separate monoids for now. i cant imagine mappending two different types ever checking anyway
18:01:30 <johnw> EvanR: could you have a GADT with two type indices, so that you are mappend'ing the same type?
18:02:45 <hpc> as in like
18:02:55 <EvanR> the gadt is already *->*->* you mean *->*->*->* ?
18:02:58 <hpc> data Refl a b where Whatever :: Refl a a?
18:03:33 <johnw> I haven't read the problem description closely enough to know what I mean yet
18:03:58 <johnw> just that Merge up above could perhaps be lowered
18:04:25 <EvanR> the Merge x x .. is x given the (closed now that i updated ghc) instances
18:04:40 <EvanR> just ghc doesnt know it
18:05:05 <EvanR> but irl you might have a mixture of types cant use <> anyway
18:05:58 <EvanR> mixture of guardedness rather
18:17:01 <NeverDie> Anyone up for joining me on a project? I'm trying to start a virtual stock market trading platform. 
18:28:00 <Lokathor> go on
18:36:53 <freemonad> helloo
18:39:13 <ski> hello freemonad
18:39:22 <freemonad> hi
18:39:27 <freemonad> would you like to flatMap with me
18:39:42 * ski prefers `concatMap'
18:39:45 <freemonad> i promise to be right associative
18:39:50 <freemonad> or something
18:40:13 <freemonad> aw
18:40:48 <freemonad> im not a Foldable :(
18:41:59 <ski> what would the type of your `flatMap' be ?
18:42:00 <Lokathor> use /nick <name> to change yourself
18:44:01 <freemonad> it be a B i believe?
18:44:09 <freemonad> i dunno, i barely get monads lol
18:44:51 <ski> "a B" ?
18:46:13 <freemonad> like flatMap[B](f: A => F[B]): F[B]
18:46:28 <freemonad> any B you like
18:46:32 <freemonad> im generic like that
18:46:42 <ski> oh
18:46:49 <ski> @type (>>=)
18:46:50 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:46:52 <ski> then
18:47:03 * ski supposes the above is Scala
18:47:33 * freemonad praises beautiful haskell syntax with typeclass
18:47:39 <freemonad> but yeah
18:47:47 <freemonad> it goes to any b right
18:48:07 <ski> rather `F[B]' for any `B'
18:48:55 <freemonad> so its the monad wrapping B
18:49:10 <freemonad> ill eat any A you like
18:49:16 <ski> `F' would presumably be a monad here, yes
18:49:17 <freemonad> poop out a B
19:07:41 <mgsloan> Does anyone know if there's a way to get the package key (thing that looks like condui_BASE64HASH) for a package that cabal has built but not installed?
19:08:08 <mgsloan> I can get this info via ghc-pkg, but that only works for installed packages
19:11:27 <mgsloan> Ahah!  I can parse it out of "dist/pacakge.conf.inplace/PKG-inpace.conf"
19:22:59 <Zemyla> I love that there is a Haskell interpreter as a module.
19:23:02 <Guest70378> Are trees (binary, trinary, etc.) considered to be traversable? Would I be able to make functions like insert and delete with only traverse?
19:23:24 <dolio> Yes, and no.
19:23:46 <Zemyla> I also love that I can import that module into the Haskell code I am interpreting and run an interpreter inside it.
19:24:14 <Guest70378> dolio, Please explain
19:24:52 <dolio> You can't write insert or delete with traverse because the idea of traverse is that it doesn't change the shape of the structure.
19:26:17 <Guest70378> dolio, Is there a traverse that does change the structure? Is changing the size of a list considered changing the structure? 
19:26:39 <julianleviston> dolio: is “b-tree” a structure shape, or a structure type?
19:26:57 <julianleviston> dolio: (in that nomenclature you’re using there)
19:27:15 <Guest43807> Hey guys, I'm a CS student. If I learn Haskell for the 2 and 1/2 years I have left in college will I get a Haskell job after I graduate?
19:27:28 <dolio> Type, probably.
19:27:40 <Guest70378> Guest43807, Realistically? Not really
19:27:43 <julianleviston> dolio: good stuff.
19:27:57 <Guest70378> but please try and prove me wrong
19:28:11 <lispy> Guest70378: there are lots of haskell jobs, but typically more haskellers looking for haskell jobs than haskell jobs
19:28:23 <julianleviston> Guest43807: given that no one can predict the future, that question might be a bit difficult to answer. There’s nothing to say that Java won’t go out the window in the next 2 years… but it doesn’t seem so...
19:28:39 <shachaf> lispy: whoa whoa whoa
19:28:50 <shachaf> You haven't been around in a bit.
19:29:25 <Guest70378> lispy, Where are there lots of Haskell jobs? I think part of the issue is that the bar is so high because haskellers can program pretty well
19:29:32 <nshepperd> I only know one haskell shop that is hiring right now, and that is fpcomplete
19:29:36 <dolio> You could write traversals of a list that traversed parts that would allow you to change the overall shape of the list. But they wouldn't be candidates for implementing the `traverse` method of the `Traversable` class.
19:30:17 <dolio> And they wouldn't let you change the shape of the part of the list you're traversing, in some sense.
19:30:52 <Guest70378> dolio, Just so we're on the same page, what is the goal of traverse/traversable
19:30:54 <dolio> So you could write: traverseTail :: ([a] -> f [a]) -> [a] -> f [a]
19:31:39 <dolio> But that would only allow you to change the tail of the list, not whether the top constructor were a nil or a cons.
19:32:27 <lispy> Guest70378: https://wiki.haskell.org/Haskell_in_industry
19:32:47 <lispy> Guest70378: if you keep your eyes open on the mailing lists and twitter, and that sort of thing you will see Haskell jobs come and go
19:33:59 <Guest70378> lispy, I've seen a few here and there but they've primarially been for senior engineers. I've applied to a few and been shot down for being too junior
19:34:11 <dolio> The goal of Traversable is to give a way of mapping over the elements of structures with an 'effectful' function, where the effects are characterized by an Applicative.
19:34:22 <EvanR> so many guests
19:34:33 <dmj`> Guest43807: I'd say it's worth the risk, you're young first of all, even if you don't get that Haskell bitcoin startup job other programmers would want to work with you. Plus haskell is fun
19:34:35 <tabemann> this sounds like a stupid question, but where is there a type class containing a function with a signature String -> Maybe a for parsing something that *might* fit?
19:34:52 <EvanR> the safe package
19:35:16 <EvanR> readMay :: Read a => String -> Maybe a
19:35:19 <julianleviston> hm looks like OS/X 10.11 makes it so cabal doesn’t install. Funtimes. Time to reboot with rootless off, I guess.
19:35:38 <Guest70378> dolio, Would an 'effectful' function be something that changes the structure or just effects like IO?
19:36:31 <Guest70378> dmj`, Are there Haskell bitcoin startups? I was thinking about that the other day
19:37:00 <hodapp> bah?
19:37:34 <dolio> It does not include changing the structure.
19:37:37 <ski> Guest70378 : not changing the structure
19:38:01 <dmj`> Guest70378: I wouldn't be surprised, haskoin seems like a serious project
19:38:15 <ski> Guest70378 : effects like `IO', `[]', `Maybe', yes
19:38:58 <tobiasBora> Hello !
19:39:20 <Guest70378> ski, So what would I do if I wanted to delete/insert which changes the structure?
19:39:37 <tabemann> damn there's a lot of functions out there with the signature Read a => String -> Maybe a
19:39:38 <ski> Guest70378 : pattern-match ?
19:39:53 <tobiasBora> Does anyone knows is something like the |> of Ocaml exists in haskell ? (it could be defined has "|> a f = f a"
19:39:55 <tobiasBora> )
19:40:05 <ski> Guest70378 : or maybe you could make it with Compos or something like that, not sure
19:40:08 <awpr> :t (Control.Lens.&)
19:40:09 <lambdabot> a -> (a -> b) -> b
19:40:09 <Guest70378> ski, I know how but I'm trying to abstract it to something like fmap where I give it the delete function
19:41:00 <ski> Guest70378 : not following
19:41:06 <julianleviston> damn. I keep getting “/usr/bin/ar: permission denied” for setup simple cabal"
19:41:11 <tobiasBora> awpr: "Could not find Control.Lens"
19:41:21 <dolio> It is because it is like fmap that you cannot write delete with it.
19:41:28 <awpr> http://hackage.haskell.org/package/lens
19:41:47 <EvanR> Guest70378: you cant delete from a structure with fmap
19:42:03 <freemonad> @type (>>=)
19:42:04 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:42:05 <freemonad> @type (>>)
19:42:06 <EvanR> though you could do this
19:42:07 <lambdabot> Monad m => m a -> m b -> m b
19:42:07 <tobiasBora> awpr: Why this function isn't available in Prelude ?
19:42:08 <dolio> Unless you do it by gluing together a new structure using monoids as the effects.
19:42:10 <EvanR> :t fmap delete
19:42:11 <lambdabot> (Eq a, Functor f) => f a -> f ([a] -> [a])
19:42:23 <Guest70378> EvanR, How? I've had some difficulty getting it to work in the same way for delete and insert. Especially for the leaf nodes
19:42:35 <dolio> However, trees aren't legal monoids.
19:42:37 <EvanR> how you cant?
19:42:55 <Guest70378> EvanR, I didn't know there was a builtin delete. I mean my custom delete
19:43:23 <ttt_fff> tomjaguarpaw: I am running into a limitation with runInsertMany
19:43:24 <dolio> At least for the purpose I described.
19:43:31 <ttt_fff> and I'm not sure if it's my stupidity or a opaleye-sqlite3 limitation
19:43:36 <ttt_fff> it appears that I can not insert 1000 items at a time
19:43:45 <ttt_fff> am I instead support to insert 1 item at a time? (it seems slightly inefficient)
19:43:47 <ski> freemonad : it is possible to privately message lambdabot
19:43:55 <ttt_fff> I get the error "too many terms in compound SELECT"
19:43:57 <awpr> tobiasBora: I'm not sure, I find it quite useful for certain uses.  but, the prevailing usage is to use ($) instead, since it reads in the same direction as function composition
19:44:01 <freemonad> ski: ty
19:44:28 <EvanR> ttt_fff: doh
19:44:35 <ttt_fff> EvanR: ?
19:44:50 <EvanR> sql queries definitely can be too big
19:45:08 <ttt_fff> EvanR: is there a better haskell-sqlite3 library to use for inserting massive amounts of data?
19:45:31 <EvanR> sqlite-simple ?
19:46:10 <tabemann> why can't a tree be a monoid; e.g. a rope is a tree, yet it forms a monoid?
19:46:52 <tobiasBora> awpr: Ok thank you. It's too bad cause I think it's usually clearer to read than ($)... Well I'll put let (|>) a f = f at the beginning of every single program :P
19:47:25 <ski> tobiasBora : imho using brackets is often clearer
19:47:46 <gfixler> can I stack exec ghci.specific.version?
19:47:54 <tobiasBora> ski: What do you mean by brackets ?
19:48:03 <dolio> tabemann: Because for the purpose I was describing, the idea was to rebuild an existing tree with an element removed. But trees like that allow you to observe the way things are associated.
19:48:07 <ski> tobiasBora : `foo (...)' instead of `foo $ ...'
19:48:18 <awpr> a tree isn't associative -- Node (Leaf a) (Node (Leaf b) (Leaf c)) isn't the same as Node (Node (Leaf a) (Leaf b)) (Leaf c)
19:48:35 <awpr> some things that are implemented as trees are legal Monoids -- i.e. Data.Sequence
19:49:01 <awpr> but only because they hide any function that would let you distinguish the above cases
19:49:07 * ski . o O ( quotient types )
19:49:08 <dolio> A rope is a quotient that doesn't allow you to observe the association.
19:49:30 <dolio> Or if it does, then it also isn't a monoid.
19:49:30 <mgsloan> gfixler: That will use the ghci that comes with the compiler specified by your stack.yaml
19:49:58 <gfixler> mgsloan: so I need a yaml? No way to just run ghci from a short command?
19:50:12 <mgsloan> gfixler: If you don't have a stack.yaml (not using ghci on a project), you can do "stack --resolver ghc-7.10 exec ghci"
19:50:32 <gfixler> mgsloan: ah, that's what I was hoping for - thanks!
19:50:44 <shachaf> Free structures in universal algebra are generally expressions quotiented by the laws, right?
19:50:55 <shachaf> Is there a similar way to describe other sorts of free structures?
19:51:05 <mgsloan> gfixler: Welcome! Or specify some stackage release, as you will probably want a set of packages availablef
19:51:31 <tobiasBora> ski: Hum maybe. But what I would like to do is more something like "[1..10] |> map (^2) |> filter (\x -> x `mod` 2 == 0)" instead of "filter (\x -> x `mod` 2 == 0) (map (^2) ([1..10]))"
19:51:31 <gfixler> mgsloan: actually, I just want to be able to choose a prelude for didactic reasons - I do a lot of quick demos for newbs
19:51:45 <awpr> shachaf: you mean arbitrary terms of the available operations?  that's clever if I understand it correctly
19:51:53 <mgsloan> gfixler: Gotcha, cool!
19:52:06 <gfixler> and - though I'm okay with the FTP, it is cumbersome when guiding someone brand new through a volley of compositions :)
19:52:10 <ski> tobiasBora : `(filter (\x -> x `mod` 2 == 0) . map (^ 2)) [1 .. 10]'
19:52:32 <awpr> i.e. a free Monoid would be a binary tree of the identity element and the binop, quotiented by associativity and identity laws, which ends up equivalent to a list?
19:52:45 <ski> tobiasBora : or  (filter (2 `divides`) . map (^ 2)) [1 .. 10]  defining `divides'
19:53:15 <Lokathor> cabal install sadly doesn't tell how many projects it has to build like it lists how many moduels it has to build
19:53:37 <ski> awpr : basically
19:54:51 <tobiasBora> ski: I see... But I think that the |> is more natural since you write it as you would say it. "First I map, then I filter" And if after you want to do another action (sum for example) just write "|> sum" at the end instead of come back to the beginning and write "sum . ..."
19:55:12 <ski> (awpr : see "Free Monoids in Haskell" by dolio in 2015-02-21 at <http://comonad.com/reader/2015/free-monoids-in-haskell/> for some more info)
19:55:19 <Guest43807> thanks dmj`
19:55:33 <awpr> yeah, I'm familiar with the infinite list issue in Hask
19:55:36 <Guest43807> What kind of beginner projects is haskell good for?
19:55:44 <gfixler> mgsloan: ah, unfortunately it conflicts with my global stack.yaml
19:56:02 <lispy> Guest43807: toy languages, like lambda calculus interpreters :)
19:56:15 <ski> tobiasBora : "first i compose together two functions, then i apply the result to some input"
19:56:18 <Guest43807> I know haskell you can make lots of functions...but for programs as a whole I don't understand
19:56:22 <EvanR> tobiasBora: well, consider the way youd normally write it f(g(h(x))) 
19:56:29 <EvanR> first you do h
19:56:45 <EvanR> i.e. f . g . h, thats why its backwards
19:57:04 <ski> actually, with non-strict semantics, first you'd "do" `f'
19:57:06 <dmj`> Guest43807: keep it fun, go with what interests you, people rarely succeed unless they enjoy what they do. The joy of learning will guide you. Find other friends who like haskell, read haskell reddit, go to meetups 
19:57:22 <EvanR> ignoring bottom
19:57:33 <mgsloan> gfixler: That's weird, it works for me.  Also, "exec" isn't necessary, "stack ghci" is a command
19:57:42 <tobiasBora> EvanR: Actually I'm pretty sure math would be more natural if you would write x -> f -> g. For example to get the type of the function just pick the type of the first element and the ending type of the last one.
19:57:53 * ski seconds dmj`
19:57:56 <gfixler> mgsloan: it wasn't always!
19:58:06 <EvanR> tobiasBora: ok but you mixed up the various interpretations of ->. what does -> mean now?
19:58:10 <mgsloan> gfixler: True, I think that got fixed recently-ish
19:58:19 <gfixler> mgsloan: yeah, I've just noticed it works for me at last
19:58:21 <luyifan> hello, I have a question , why (+) :: a -> a -> a is left associative , but take :: Int -> [a] -> [a] is right-associative 
19:58:22 <gfixler> good reminder
19:58:30 <mgsloan> (that "stack ghci" required a stack.yaml project)
19:58:31 <tobiasBora> EvanR: I wrote -> instead of |>, but I mean |> instead
19:58:36 <gfixler> luyifan: they're defined that way
19:58:58 <EvanR> tobiasBora: so youd prefer |> to be left assoc, post fix function application.
19:59:05 <gfixler> luyifan: the arrows (function constructors) are all right-associative
19:59:08 <Cale> luyifan: take shouldn't have any associativity
19:59:30 <shachaf> luyifan: + and `take` are both left-associative.
19:59:48 <EvanR> tobiasBora: and its more natural because we read left to right. we being the western world
20:00:17 <EvanR> and north is up
20:00:25 <luyifan> @Cale but I see real world haskell, take is right-associative
20:00:25 <lambdabot> Unknown command, try @list
20:00:26 <EvanR> its all natural
20:00:26 <tobiasBora> EvanR: left assoc yes, but I would say infix function.
20:00:39 <ski> tobiasBora : one problem then is that we'd write `x -> f = ..x..', and we prefer having the thing defined first, if possible
20:00:45 <luyifan> take :: Int -> [a] -> [a]
20:00:54 <luyifan> t’s pretty clear that there’s something going on with an Int and some lists, but why are there two -> symbols in the signature? Haskell groups this chain of arrows from right to left; that is, -> is right-associative. I
20:01:04 <gfixler> function construction: right-associative; function application: left-associative; infix operators: explicitly defined associativity
20:01:05 <Cale> I guess it defaults to being infixl
20:01:09 <EvanR> tobiasBora: so the minus sign... it should be like 39-
20:01:14 <ski> tobiasBora : this is more important if `x' is in fact a big pattern
20:01:15 <Cale> Because its fixity isn't declared anywhere
20:01:17 <shachaf> -> is right-associative
20:01:35 <shachaf> That's true for both the ->s in (+)'s type signature and the ->s in take's type signature.
20:01:40 <Cale> But if you were to care about using take in an infix way, being right associative would be the only thing which would make sense
20:02:00 <tobiasBora> EvanR: Not sure to follow you... But actually natural is maybe subjective...
20:02:07 <EvanR> maybe!
20:02:09 <Cale> After all, you wouldn't want 4 `take` 5 `take` [1..10] to mean (4 `take` 5) `take` [1..10]
20:02:19 <Cale> (at least not typically!)
20:02:26 <Cale> Well, no, regardless
20:02:31 <EvanR> tobiasBora: most significant digits first in numbers, whats up with that!
20:02:47 <Cale> (4 `take` 5) would have to be a list, even if you were to find some way to interpret 5 as a list
20:03:03 <Cale> and then that list would be the first argument to take, which would be bad
20:03:25 <Cale> So, yeah, I guess if you actually cared to define the associativity of take, you'd want to define it to be infixr
20:03:35 <gfixler> Couldn't match expected type ‘Int’ with actual type ‘[a0]’
20:03:37 <Cale> However nobody has bothered to do this, because nobody uses take infix
20:03:47 <Cale> So, it defaults to being left associative, which is useless.
20:04:12 <shachaf> Cale: The associativity of take isn't actually what the question is about, though.
20:04:24 <Cale> "<luyifan> hello, I have a question , why (+) :: a -> a -> a is left associative , but take :: Int -> [a] -> [a] is right-associative "
20:04:34 <shachaf> See below.
20:04:37 <Cale> ...
20:04:45 <Cale> hmm
20:04:52 <luyifan> @Cale: to see :info (+)
20:04:53 <lambdabot> Unknown command, try @list
20:05:02 <luyifan> infixl 6 +
20:05:04 <Cale> luyifan: Did you really mean to ask about the associativity of (->) which occurs in types?
20:05:09 <tobiasBora> EvanR: And it's a good thing, but it's different from function. In function you have an element and you perform several operations on it. So you have a first element x, and then you apply f, then g, that's why I really like the notation x |> f |> g. By the way when you do chemistry, you never write the last reaction at the very beginning...
20:05:11 <Cale> luyifan: sure
20:05:19 <julianleviston> I have a test Snap app I’m building, and I have put a file called Postgresql.hs into the path /src/Snap/Snaplet/Groundhog. How do I import this from my /Main.hs file? Are all .hs files “automatically seen” by cabal/snap when building?
20:05:22 <luyifan> but I don't know why take is right-associate 
20:05:29 <Cale> luyifan: It's not.
20:05:49 <luyifan> the book said take is right-associative , I don't know why 
20:05:51 <Guest43807> What other functional languages are there besides haskell? I know of f#, erlang, clojure
20:05:54 <Cale> luyifan: Where?
20:06:02 <Guest43807> they don't have to be 100% functional or anything
20:06:03 <luyifan> It’s pretty clear that there’s something going on with an Int and some lists, but why are there two -> symbols in the signature? Haskell groups this chain of arrows from right to left; that is, -> is right-associative. If we introduce parentheses, we can make it clearer how this type signature is interpreted:
20:06:13 <tobiasBora> Guest43807: Ocaml
20:06:15 <ski> Guest43807 : Scheme,SML,OCaml,Clean,Mercury
20:06:18 <luyifan> Read world haskell , Chapter 2 
20:06:22 <kadoban> Guest43807: Scheme. JavaScript XD
20:06:23 <Cale> luyifan: It doesn't say take is right associative
20:06:27 <gfixler> > let infixr 5 `t`; t = take in 2 `t` 3 `t` [1,2,3,4,5] -- Cale
20:06:29 <lambdabot>  [1,2]
20:06:30 <luyifan> The Type of a Function of More Than One Argument
20:06:32 <Cale> luyifan: It says -> is right associative.
20:06:56 <Axman6> rule #1, functions only ever take one argument
20:07:12 <luyifan> oh 
20:07:19 <Cale> gfixler: I'm aware that you can give a declaration of the fixity :P
20:07:19 <gfixler> maybe we should just call them morphisms
20:07:23 <ski> rule #0, functions are values too
20:07:25 <gfixler> Cale: figured
20:07:29 <EvanR> tobiasBora: well f(x) is ingrained in our heads
20:07:49 <awpr> rule #undefined, bottom inhabits all types
20:08:10 <EvanR> dx, integral(x), !9, -9, &x
20:08:11 <Axman6> Guest43807: Scala is the obvious one missing from your list these days. also the other lisps
20:08:34 <EvanR> ops go on the front
20:08:40 <EvanR> f x y z w
20:08:56 <shachaf> Cale: Maybe take should be : ℕ∪{∞} -> [a] -> [a] or something like that.
20:09:05 <shachaf> To make it a monoid action, where the monoid is min.
20:09:16 <Cale> shachaf: indeed
20:09:24 <luyifan> @Cale, Thanks
20:09:24 <lambdabot> Unknown command, try @list
20:09:26 <Cale> shachaf: In Haskell that could just be Nat
20:09:29 <ski> shachaf : hmm .. using the generic convergent sequence, i suppose
20:09:56 <tobiasBora> EvanR: With one function, yes it's in our head cause it's pretty simple to revert it. After I tried to program in a functionnal way with the |> operator and the $ operator, really |> is sooo nice to use... You can write ten lines of |> which would be unreadible with .
20:10:18 <EvanR> tobiasBora: maybe you just need practice
20:10:21 <shachaf> ski: Generic convergent sequence?
20:10:34 <ski> shachaf : one-point compactification of the naturals
20:10:44 <shachaf> Right.
20:10:59 <shachaf> Is there any other ℕ∪{∞} people talk about?
20:11:10 <shachaf> I see what you mean by generic convergent sequence.
20:11:19 <shachaf> Since a convergent sequence is continuous function from this space to some other space.
20:11:26 <Guest43807> What do you all think of scala?
20:11:53 <shachaf> Like a circle is a "generic loop".
20:11:59 <Guest43807> is it like clojure but not lispy
20:12:10 <shachaf> And a closed interval is a "generic path" and so on, I suppose.
20:12:16 <tobiasBora> EvanR: Maybe... But after 3 years of using "$", I discovered the |> and now I am so disapointed when I cannot use |>... But hopefully I can define |> in Haskell, so everything is fine ! I just need to define it by hand at the beginning of every program.
20:13:19 <EvanR> tobiasBora: $ ? 
20:13:19 <dibblego> @type (&)
20:13:21 <lambdabot> a -> (a -> b) -> b
20:13:38 <EvanR> (a . b . c . d . e) x
20:13:49 <ski> shachaf : see e.g. "The intrinsic topology of a Martin-Löf universe" by Martín H. Escardó in 2012-05-15 at <http://www.cs.bham.ac.uk/~mhe/papers/universe-indiscrete-and-rice.pdf>
20:13:51 <EvanR> or f = a . b . c . d . e, or on many lines
20:14:50 <EvanR> tobiasBora: yeah, & is current what youre thinking of for that, but in haskell its idiomatic to use composition style
20:14:59 <ski> shachaf : it is equal to `ℕ∪{∞}' iff WLPO
20:15:04 <tobiasBora> EvanR: $ or ., it's pretty similar in the idea. But I must admit that having a way to avoid putting the variable is quite practical (you need to give the variable with |>)
20:15:09 <EvanR> in concatenatice languages, you never apply anything ;)
20:15:21 <shachaf> ski: Ah.
20:15:33 <tobiasBora> dibblego: I cannot find the &, it's in the strange non standard library defined above ?
20:15:39 <EvanR> tobiasBora: maybe you should look at some style guides if youre uhappy with your code
20:15:40 <ski> (er, s/WLPO/LPO/)
20:15:55 <Cale> Guest43807: https://www.reddit.com/r/haskell/comments/1pjjy5/odersky_the_trouble_with_types_strange_loop_2013/cd3bgcu
20:16:13 <Cale> Guest43807: some comments from edwardk there :)
20:16:32 <Cale> https://www.reddit.com/r/haskell/comments/3h7fqr/what_are_haskellers_critiques_of_scala/ -- more discussion here
20:17:14 <julianleviston> guh. why is package management so tricky.
20:17:43 <Guest43807> thank you Cale I will read this
20:19:00 <tobiasBora> EvanR: I think that both |> and . are practical, it only depends on the context. When you write small composition, . is nice cause you don't need to provide the variable. But in huge composition giving the variable takes only a few chars and the readibility is increased with |>. Well at least it's what I think...
20:19:52 <td123> julianleviston: because we're still a young industry :)
20:20:24 <Cale> julianleviston: Because it's about how complicated systems interact
20:20:29 <td123> julianleviston: wait till you have code fragments with proven correct properties and you'll see the end of dll hell
20:20:45 <td123> julianleviston: in the mean time enjoy the show :)
20:20:48 <Cale> julianleviston: and we're trying to summarise any instance of such a complicated system using a small number of bits (a version number)
20:20:52 <julianleviston> td123: I’m not using DLLs am I?
20:21:04 <Cale> Even though that doesn't entirely capture which piece of software you're talking about even.
20:21:30 <Cale> Because the same version of the same package can be compiled against many different combinations of versions of its dependencies.
20:21:31 <td123> julianleviston: it's a sorta related problem
20:21:49 <EvanR> tobiasBora: & is the default thing for that, its in the lens lib but you can easily define it yourself. also its kind of unidiomatic.
20:22:15 <EvanR> haskel just doesnt like f (g (h (foo (bar (baz x)))))) style
20:22:15 <Cale> So packagename-version.number isn't enough information to decide what it is that you're dealing with once you've built the code.
20:22:26 <EvanR> oops too many parens
20:22:51 <EvanR> tobiasBora: ... what variable? are you using lambdas?
20:22:56 <tobiasBora> EvanR: Why would I use brackets with |> ?
20:23:14 <EvanR> now it sounds like youre making it too complicated
20:23:39 <EvanR> tobiasBora: i mean lots of application vs lots of composition
20:23:44 <EvanR> in a row
20:23:54 <EvanR> isnt |> the Data.Sequence operator?
20:24:25 <EvanR> & and <&> are reverse application and reverse fmap respectively
20:24:44 <julianleviston> td123: yeah, sure. package management is a dependency issue… and there’s work being done on it to fix as much of the problem space is fixable. I get that.
20:25:30 <julianleviston> td123: in clojure, though, there’s a thing called “leiningen” which is one of the nicest package managers I’ve ever used. We should take the nice pieces from that.
20:25:45 <ski> EvanR : this `|>' is from OCaml. basically it's the lens `&'
20:25:46 <EvanR> leiningen is a build tool
20:25:56 <julianleviston> EvanR: yep. 
20:26:19 <julianleviston> EvanR: but *something* resolves the packages… maybe it’s the java package system, I don’t know.
20:26:31 <julianleviston> EvanR: whatever it is, it works. We should take advice from that.
20:26:37 <EvanR> lein has its own cabal-like system tacked onto maven
20:26:48 <EvanR> it all seems a lot like cabal
20:26:54 <julianleviston> EvanR: it is. But it works.
20:27:23 <EvanR> whatever isnt working about cabal, im not sure but i dont think its the build system
20:27:31 <julianleviston> EvanR: it’s probably the dependency system that’s better, really. There *are* multiple simultaneous issues at play here.
20:27:46 <dolio> It also isn't solving as difficult a problem.
20:27:55 <julianleviston> dolio: how come?
20:28:06 <tobiasBora> EvanR: ski is right, when I write '|>', you may read '$'. It's just because I do not understand the '$' symbol : the arrow like style of |> is much clearer in my mind.
20:28:07 <EvanR> do you typically have many versions of many things at the same time in clojure?
20:28:25 <dolio> Because GHC doesn't maintain binary compatibility in the face of basically any change.
20:28:53 <dolio> Whereas Java's ecosystem is largely based around distributing compatible binaries.
20:28:58 <EvanR> neither does clojure, its all reloaded and relinked on boot, which takes forever
20:29:07 <EvanR> not counting java libs
20:29:52 <EvanR> tobiasBora: oh i see i thought you were trying to reverse the ordering
20:30:17 <EvanR> well enough dwelling on lexical syntax ;)
20:30:46 <dolio> EvanR: Does it just rebuild from source every time?
20:31:14 <julianleviston> dolio: Pretty sure it doesn't.
20:31:48 <EvanR> yes it des
20:31:52 <EvanR> it has to because of macros
20:31:55 <EvanR> even the stdlib
20:33:00 <dolio> Well, then. That's easy, too. :)
20:33:00 <julianleviston> EvanR: gosh! it’s amazingly fast then! :)
20:33:09 <EvanR> after it boots up yeah
20:33:17 <dolio> Just write a script that deletes and rebuilds your sandbox every time you compile, and cabal will work the same way.
20:33:24 <julianleviston> EvanR: you might need to define “compile” ;-)
20:33:46 <EvanR> once you really compile it you get a .jar
20:33:55 <EvanR> during development though that doesnt help
20:34:25 <EvanR> durign development "recompile" means reload changed source files and reload the program
20:34:30 <julianleviston> EvanR: yeah, this conversion isn’t useful.
20:34:37 <julianleviston> EvanR:  and it’s also not really about Haskell.
20:35:17 <EvanR> theres some degree of x-files-ness to what exactly is wrong with cabal
20:35:26 <EvanR> it seems to work great for some people
20:35:43 <EvanR> not others, and whats the actual problem, who know
20:35:49 <thoughtpolice> Some of the things it kind of does is stuff we want, though. We just can't quite do it the same way. Normally for something like a .jar deployment, you take the transitive dependencies and stuff them together and put them on the CLASSPATH. You can selectively pick what is in the classpath; essentially running 'java -jar' is linking all the dependencies
20:35:49 <thoughtpolice> together at runtime when the JVM starts. A .jar file doesn't "link" against a specific dependency in a hard way.
20:35:50 <julianleviston> EvanR: i have no doubt it works well if you know how it works.
20:36:16 <thoughtpolice> If your .jar file depends on foo-0.1.jar, you can replace it with foo-0.2.jar as you want, and providing the API hasn't broken it will just work. Doing that in Haskell is what causes a recompilation.
20:36:17 <julianleviston> i’m getting this problem when I try to stack build: --  Failure when adding dependencies: mtl: needed (>=2.2 && <2.3), 2.1.3.1 found (latest is 2.2.1) needed for package: MonadRandom-0.3.0.2
20:36:38 <julianleviston> do I need to specify which version?
20:36:57 <julianleviston> I wasn’t even aware I was *using* MonadRandom, but I guess something I’m importing does.
20:37:09 <lispy> I haven't used stack, but the last time I glanced at the docs it seemed like that depends on which resolver you use.
20:37:25 <EvanR> i havent used stack
20:37:27 <lispy> Are you using the cabal resolver?
20:37:39 <julianleviston> lts 2.19
20:37:54 <julianleviston> lispy: I don’t know if I am. How would I find out?
20:38:03 <mgsloan> There is no cabal resolver :)
20:38:05 <lispy> Good question, again I haven't used stack
20:38:33 <mgsloan> julianleviston: That error means that MonadRandom wants a different version of mtl than is in lts 2.19
20:38:46 <julianleviston> mgsloan: ok.
20:39:17 <julianleviston> mgsloan: I don’t really have much of an idea about what I’m doing.
20:40:33 <lispy> mgsloan, julianleviston: this is what I was thnking of: https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md#alternative-solution-dependency-solving
20:40:41 <JX7P> how do we feel about the Red Flag of FP
20:41:19 <julianleviston> lispy: ummm what’s your question? Did I try stack resolver? Yeah I did… it “exhausts”
20:41:22 <lispy> JX7P: frankly, the first time I saw it I thought it was purely a joke.
20:41:37 <lispy> julianleviston: okay
20:41:50 <EvanR> soyuz nerishimij respublik svobonik
20:42:07 <Big_G> Is it not a joke? 
20:42:30 <mgsloan> Ahh, I know what is going on.  It's because the cabal metadata for MonadRandom got revised today, which broke that stackage snapshot
20:42:42 <julianleviston> mgsloan: ahh…
20:42:55 <EvanR> JX7P: #haskell-politics
20:42:58 <JX7P> Big_G, see the manifesto included in the repository
20:43:19 <julianleviston> JX7P: off-topic.
20:43:21 <JX7P> EvanR, I think you forgot the purpose of the Red Flag of FP
20:43:43 <lispy> "I also believe in the ideals of equality of opportunity, regardless of race, gender, sexual orientation, or economic class, and that the needs of all members of society should be met, rather than only those of a wealthy and privileged elite and those who can claw their way into its good graces."
20:43:44 <EvanR> is it the flag against on-topicness?
20:43:49 <JX7P> in the author's words, "A lot of talk has grown in the programming scene about 'keeping politics out of code' so I decided instead to create a banner for those who feel rather more otherwise."
20:43:49 <lispy> That part of it seems very reasonable to me
20:43:57 <lispy> EvanR: probably?
20:44:54 <julianleviston> JX7P: I think you’re forgetting the purpose of this CHANNEL
20:46:30 <julianleviston> mgsloan: so, what should I do under these circumstances?
20:50:21 <tobiasBora> In Haskell, is there a notion of tail recursion ? For example is foldr equivalent to foldl or not ?
20:50:38 <lispy> tobiasBora: pretty much everything in haskell is a tail call
20:51:23 <lispy> tobiasBora: but what do you mean by "is foldr equivalent to foldl"? they have different types and different associativity, and even sometimes different strictness
20:51:24 <mgsloan> julianleviston: I'm discussing the issue with folks.  Out of curiousity, what's your stack version?
20:51:48 <julianleviston> mgsloan: Version 0.1.5.0 X86_64
20:52:15 <EvanR> > foldr (++) [] [[1],[2],[3],[4]]
20:52:17 <lambdabot>  [1,2,3,4]
20:52:24 <EvanR> > foldr (++) [] [[1],[2],[3],[4]]
20:52:26 <lambdabot>  [1,2,3,4]
20:52:35 <EvanR> > foldl (++) [] [[1],[2],[3],[4]]
20:52:37 <lambdabot>  [1,2,3,4]
20:52:42 <EvanR> yep equivalent
20:52:46 <julianleviston> EvanR: erm.
20:52:48 <tobiasBora> lispy: Well I come from an Ocaml world, and for commutative/associative rules it's better to use foldr rather than foldl because foldl keep the intermediate result in memory, while foldr remove them. But since haskell is lazy I'm not sure it has sens anymore...
20:53:05 <julianleviston> tobiasBora: compare foldr with foldl'
20:53:22 <lispy> tobiasBora: So there are definitely times when foldr and foldl have different efficiency.
20:53:23 <julianleviston> tobiasBora: Haskell doesn’t *have* to be lazy… it just is by default.
20:53:38 <EvanR> foldr and foldl will both keep intermediate results in memory sometimes
20:53:59 <EvanR> you have to understand how they are defined and practice evaluating each kind of fold
20:54:15 <lispy> tobiasBora: If you have an infinite list, then usually foldr is better. If you are turning a finite list of big things into something small, then foldl' is usually the best
20:54:55 <EvanR> https://wiki.haskell.org/Fold
20:56:52 <mgsloan> julianleviston: You can do "stack upgrade --git", and then use the "--allow-newer" flag that was added 12 hours ago :D
20:56:58 <lispy> tobiasBora: if you'd like to learn more about how laziness really works and the implications, then I highly recommend reading this book and doing the implementation: http://research.microsoft.com/en-us/um/people/simonpj/Papers/pj-lester-book/
20:57:08 <julianleviston> mgsloan: what will that do for me? :)
20:57:23 <mgsloan> Ignore all the version bounds, lower and upper
20:57:25 <EvanR> > foldr (:) 0 [1,2,3,4]
20:57:27 <julianleviston> mgsloan: more than knowing *what* to do, I’d like to know the why & how.
20:57:27 <lambdabot>      No instance for (Show a0)
20:57:27 <lambdabot>        arising from a use of ‘show_M244118709611324019521236’
20:57:27 <lambdabot>      The type variable ‘a0’ is ambiguous
20:57:47 <EvanR> > foldr (:) [] [1,2,3,4]
20:57:48 <lambdabot>  [1,2,3,4]
20:57:56 <EvanR> > foldl (flip (:)) [] [1,2,3,4]
20:57:57 <lambdabot>  [4,3,2,1]
20:58:06 <lispy> tobiasBora: More details on your specific question can be found here: http://stackoverflow.com/questions/13042353/does-haskell-have-tail-recursive-optimization
20:58:22 <EvanR> foldr folds right and foldl folds left ;)
20:58:45 <EvanR> so foldl does not work on infinite lists
20:58:57 <julianleviston> EvanR: I never found “foldr folds right” helpful.
20:58:58 <mgsloan> julianleviston: Right!  In this case, the issue was caused by a bad revision to cabal metadata on hackage.  This is not a problem people should have to think about.  I think we're going to consider some approach for making hackage cabal file revisions not break deterministic builds
20:59:06 <EvanR> i have
20:59:13 <julianleviston> EvanR: because “to the right” doesn’t mean anything.
20:59:15 <lispy> EvanR: Well, that's a bit strong because you can implement foldr with foldl :)
20:59:16 <EvanR> it seems like the natural direction to fold a list
20:59:35 <julianleviston> EvanR: “what is folding?” “what is right?”
20:59:39 <julianleviston> EvanR: it has right-associativity.
20:59:40 <EvanR> ??
20:59:48 <tobiasBora> julianleviston lispy EvanR : Ok, I'l read it thank you !
20:59:51 <EvanR> right is that way ->
21:00:10 <EvanR> lispy: i need to check that out
21:00:48 <EvanR> julianleviston: the diagrams on this page also help https://wiki.haskell.org/Fold
21:01:06 <julianleviston> EvanR: I don’t need help. I’m just explaining to you how people could get confused.
21:01:09 <EvanR> from top-to-bottom you can see the folding action happens to the right or to the left
21:01:19 <EvanR> i agree its hell confusing
21:01:21 <EvanR> hella
21:01:25 <julianleviston> EvanR: it doesn’t have to be.
21:01:33 <lispy> tobiasBora: cheers. Don't hesistate to ask more questions!
21:01:35 <julianleviston> EvanR:  but when you don’t specify the context, it is.
21:01:37 <EvanR> the way i explained it is pretty clear
21:01:40 <julianleviston> EvanR: no.
21:01:46 <julianleviston> EvanR: it’s clear to you.
21:01:50 <julianleviston> EvanR:  but not all people.
21:02:04 <EvanR> NO U
21:02:15 <julianleviston> EvanR: associate right could mean the action starts on the right, or it could mean the action moves to the right.
21:02:30 <julianleviston> EvanR: it depends on how the person is thinking at the time and their centre of gravity.
21:02:30 <EvanR> i didnt say anything about associating right, thats confusing to me
21:02:39 <EvanR> what is associating
21:02:39 <julianleviston> EvanR: you said “foldr folds right"
21:02:44 <julianleviston> EvanR: exactly.
21:02:45 <EvanR> yeah it folds right
21:02:52 <mgsloan> julianleviston: Discussion of this exact issue here: https://github.com/commercialhaskell/stack/issues/770#issuecomment-148049610
21:02:54 <julianleviston> EvanR: yes, but that implies a few things you’re missing out.
21:03:32 <julianleviston> EvanR: like… what “right” means.
21:03:35 <EvanR> foldr (+) 0 [1,2,3,4] for example
21:03:43 <julianleviston> EvanR: to someone reading arabic, right means where you start.
21:03:43 <EvanR> 0 [1,2,3,4]
21:03:47 <EvanR> 1 [2,3,4]
21:03:50 <EvanR> 3 [3,4]
21:03:53 <EvanR> 6 [4]
21:03:53 <julianleviston> EvanR:  to someone reading english, right means where you’re moving towards.
21:03:57 <EvanR> 10
21:04:27 <EvanR> up is down in is out
21:04:32 <julianleviston> EvanR: ok. so you’re meaning “the operation applies from the left of the data to the right of the data as the operation evaluates.
21:04:41 <julianleviston> EvanR: that’s a much clearer explanation.
21:04:48 <EvanR> sometimes the more words the more confusing it is
21:04:58 <julianleviston> EvanR: I disagree.
21:05:25 <julianleviston> EvanR: you can form small sentences. It’s the word-choice that is mostly confusing.
21:05:51 <EvanR> imo a good way to remember the difference is that foldr folds right, and foldl folds left
21:05:54 <EvanR> when you need to use one
21:06:05 <julianleviston> EvanR: whatever “fold” means to you.
21:06:12 <julianleviston> EvanR: and whatever “to the right” means.
21:06:13 <EvanR> its like reading to the right, or to the left
21:06:28 <julianleviston> EvanR: no it’s not. :)
21:06:29 <EvanR> were not reading to the left
21:07:12 <EvanR> well, you can also make it more confusing by destructing existing understanding as much as possible ;)
21:07:18 <MarcelineVQ> left and right association just mean where the brackets pile up :>
21:07:22 <julianleviston> EvanR: you haven’t defined what “fold” is when you say that “it folds to the right”. Is folding the expansion of implicit parens, or is it the application of the operation once the expansion has taken place?
21:07:23 <Big_G> So which definition is right? 
21:07:32 <julianleviston> MarcelineVQ: whatever “pile up” means.
21:07:42 <EvanR> nothing means anything!
21:07:42 <julianleviston> MarcelineVQ: (((((( <- that could be considered a pile.
21:07:46 <MarcelineVQ> that is a pile
21:08:01 <MarcelineVQ> That's a left associative pile
21:08:33 <julianleviston> MarcelineVQ: or the part that isn’t ((((( could be considered a pile.
21:08:49 <EvanR> for all x . whatever x is could be considered not x
21:08:54 <julianleviston> MarcelineVQ: but you’re right… (((( is a pile of brackets. It’s a clearer way to explain it.
21:08:57 <MarcelineVQ> (((((x +y) + z) + y) + d) + b)
21:09:27 <MarcelineVQ> leans left :>
21:09:35 <julianleviston> MarcelineVQ: whereas “fold to the left” is not clear because we haven’t defined what fold means.
21:09:53 <EvanR> well, at least its not called inject
21:10:03 <MarcelineVQ> you can look at the definiton of the function to know what fold means
21:10:05 <julianleviston> MarcelineVQ: “begin evaluating at the left” would possibly be clear, too.
21:10:18 <MarcelineVQ> It's not like you'll get it without looking at that anyway, when you get right down to it
21:10:19 <EvanR> it doesnt begin evaluating at the left though, that would be misleading
21:10:41 <EvanR> foldl first zips to the far right (the end) and starts there
21:10:41 <julianleviston> EvanR: oh?
21:10:48 <EvanR> so that it can fold left
21:11:01 <julianleviston> EvanR: ok now I’m confused.
21:11:06 <EvanR> i know!
21:11:10 <julianleviston> EvanR: you do?
21:11:24 <EvanR> look at the picture https://wiki.haskell.org/Fold
21:11:29 <EvanR> after that well look at the code
21:11:51 <julianleviston> EvanR: no, my understanding is correct.
21:12:07 <julianleviston> EvanR: I have no idea what “zips to the far right” means in your sentence above.
21:12:42 <EvanR> see how the 5 is "first" in the foldl picture, in foldl f z [1,2,3,4,5]
21:12:44 <julianleviston> EvanR:  “starts evaluating” to me, above, means “starts to apply the function once the expansion has finished”
21:12:54 <EvanR> well, the expansion doesnt have to finish
21:12:57 <EvanR> its lazy
21:13:15 <EvanR> so more words also means you are more likely to get things wrong ;)
21:13:24 <julianleviston> EvanR: intense disagree.
21:13:33 <EvanR> lets look at fold's code
21:13:38 <EvanR> @src foldl
21:13:38 <lambdabot> foldl f z []     = z
21:13:38 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:13:52 <EvanR> so when you start evaluating, as you say, the first thing you do is foldl
21:14:03 <EvanR> i mean, in the body, it calls itself
21:14:13 <EvanR> then again, until it gets to the end of the list
21:15:12 <EvanR> then it starts really doing computations using f, starting from the end of the list, moving back to the beginning
21:15:25 <EvanR> at least in the case of a strict f
21:15:37 <julianleviston> lol
21:15:45 <EvanR> it could just stop there for lazy f
21:17:26 <julianleviston> EvanR: I don’t think your idea of how foldl works is quite correct.
21:17:35 <EvanR> yeah the last sentence is not right
21:17:37 <julianleviston> EvanR: take their example.
21:17:39 <julianleviston> > foldl (\x y -> concat ["(",x,"+",y,")"]) "0" (map show [1..13])
21:17:41 <lambdabot>  "(((((((((((((0+1)+2)+3)+4)+5)+6)+7)+8)+9)+10)+11)+12)+13)"
21:17:57 <EvanR> now you need to be careful when trying to understand it using expansions like that
21:18:16 <lispy> The important bit is where the supplied function appears relative to the fold(l|r) recurrsion
21:18:21 <EvanR> > foldl (+) 0 [a, b, c, d, e, f]
21:18:23 <MarcelineVQ> EvanR: Because it shows a result instead of a working?
21:18:23 <lambdabot>  0 + a + b + c + d + e + f
21:18:38 <EvanR> hmm its not showing parens
21:18:47 <EvanR> > foldl (+) z [a, b, c, d, e, f]
21:18:48 <lambdabot>  z + a + b + c + d + e + f
21:18:53 <lispy> Does the function application appear on the inside or outside? What affect does that have on the control you get with respect to returning a value before/after the recursion?
21:20:21 <EvanR> to get any part of the result of foldl, you have to go to the very end of the list, combine f to all the elements back to the beginning
21:21:08 <EvanR> then it will start producing 
21:21:09 <julianleviston> EvanR: yep. You’ve described the initial “problem” I was explaining quite well...
21:21:27 <EvanR> the order of the f's though, is right to left ;)
21:21:35 <julianleviston> EvanR: there are two “parts” - expansion, and “evaluation” (using that term loosely).
21:21:58 <julianleviston> EvanR: but that’s just a natural consequence of the shape of the LIST isn’t it?
21:22:10 <julianleviston> EvanR:  depending on what you mean by “order” ;-)
21:22:16 <EvanR> yes
21:22:31 <EvanR> you can also think of the "expansion" as leaning left
21:23:19 <julianleviston> EvanR: doesn’t the right fold also have that property? … ie the order of the f’s… is right to left…(it has to walk the entire list to “expand”)
21:23:32 <EvanR> no it doesnt, thats the beauty of it
21:23:52 <EvanR> @src foldr
21:23:52 <lambdabot> foldr f z []     = z
21:23:52 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:24:17 <EvanR> the first thing foldr does is apply the f, awesome now we can even return immediately and drop the rest of the expansion
21:24:31 <EvanR> namely it applies the f to the beginning of the list
21:24:39 <EvanR> and so on, going right
21:24:46 <julianleviston> EvanR: erm… this is a fold, not a map or filter
21:25:00 <EvanR> right but you could implement head with foldr
21:25:11 <EvanR> (or foldl but thats a brain teaser!)
21:25:48 <julianleviston> EvanR: sure, but again, that’s just a property of the shape of the list… isn’t it?
21:25:53 <EvanR> > foldr (\x _ -> x) [] [1,2,3,4]
21:25:58 <lambdabot>  mueval-core: Time limit exceeded
21:26:12 <EvanR> why did that not work
21:26:47 <EvanR> > foldr (\x _ -> x) undefined [1,2,3,4]
21:26:52 <lambdabot>  mueval-core: Time limit exceeded
21:27:24 <julianleviston> foldr (\x _ -> x) 0 [1,2,3,4]
21:27:52 <lispy> EvanR: I think you're just getting unlucky with a busy lambdabot 
21:28:01 <EvanR> convenient!
21:28:03 <lispy> it worked for me in privmsg
21:28:07 <julianleviston> > foldr (\x _ -> x) 0 [1,2,3,4]
21:28:09 <lambdabot>  1
21:28:17 <julianleviston> you had [] instead of an int
21:28:36 <EvanR> yeah wouldve been a type error
21:28:38 <MarcelineVQ> Yeah but that would have had an error not a time-limit
21:28:39 <julianleviston> EvanR: you had foldr (\x _ -> x) [] [1,2,3,4]
21:28:47 <EvanR> undefined was more righter
21:28:58 <lispy> yes, and that's the one I tried
21:29:25 <julianleviston> k
21:29:30 <EvanR> julianleviston: yeah all this intuition relies on the list structure, and the usual printing of it from left to right
21:29:43 <MarcelineVQ> > foldr (const) undefined ['a'..'z']
21:29:44 <lambdabot>  'a'
21:30:56 <EvanR> at least they didnt call it fold up and fold down, then proceeded to use two versions of diagrams, one right side up and upside down (like computer memory diagrams)
21:31:02 <MarcelineVQ> > let f = (+2) in (foldr ((:) . f) []) [1..5]
21:31:04 <lambdabot>  [3,4,5,6,7]
21:31:32 <julianleviston> mgsloan: how do I use the allow-newer flag? is it something I put in my .cabal or stack.yaml files?
21:33:59 <julianleviston> mgsloan: thanks very much for finding this stuff out for me, by the way.
21:36:24 <EvanR> > foldr const undefined [1..]
21:36:26 <lambdabot>  1
21:36:43 <lispy> julianleviston: allow newer is a cabal flag, but I don't know what mgsloan intended
21:37:43 <glguy> lispy: presumably talking about the brand-new stack.yaml option allow-newer, actually https://twitter.com/animald
21:37:43 <glguy> rumss/status/592169335667486720
21:37:56 <glguy> hmm, looks like my copy/paste didn't work
21:38:02 <glguy> https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md
21:38:27 <glguy> I don't endorse using twitter or reading that link
21:38:58 <julianleviston> glguy: yeah, I am.
21:39:06 <julianleviston> glguy: this one : https://github.com/commercialhaskell/stack/issues/770#issuecomment-148049610
21:40:16 <julianleviston> guh I hate yaml.
21:41:54 <mgsloan> julianleviston: "stack build --allow-newer"
21:42:09 <julianleviston> mgsloan: or add it into stack.yaml under “flags: {}” I’m guessing?
21:42:13 <mgsloan> lispy: You'd be right 12 hours ago, but now "--allow-newer" is also a stack flag, heh
21:42:47 <mgsloan> Oh, glguy already mentioned that
21:43:32 <mgsloan> julianleviston: Add "allow-newer: true" to stack.yaml
21:45:22 <julianleviston> mgsloan: thanks. sorry I’m so ehh...
21:45:39 <mgsloan> No worries!  Takes a while to learn things :)
21:46:00 <julianleviston> mgsloan: I’ve been using yaml for about 8 years. You’d like I’d have learned it by now.
21:47:20 <mgsloan> Snoyberg just pushed a change to trust snapshots over hackage revisions, yielding warnings about it: https://github.com/commercialhaskell/stack/commit/df543398f231b6cff5918d7b964835ef44dac5f8
21:47:34 <lispy> julianleviston: You're no schedule? http://norvig.com/21-days.html
21:47:36 <mgsloan> So actually, if you upgrade to the git version, now you no longer need allow-newer
21:47:40 <lispy> julianleviston: er, on
21:49:04 <julianleviston> lispy: haha… not sure how to answer that. How about this: 22 years ago I wrote my first program professionally… ;-)
21:49:19 <julianleviston> mgsloan: ace :)
21:50:02 <Guest43807> is lua a good language?
21:50:21 <glguy> Oops, you joined the wrong channel
21:50:23 <glguy> This is #haskell
21:50:31 <julianleviston> Guest43807:  I dunno man, but haskell is awesome! :)
21:52:14 <julianleviston> mgsloan: hm… I’m getting the same errors. 
21:52:18 <EvanR> lua+C is pretty interesting, ##c is pretty interesting, never been to #lua
21:52:26 <julianleviston> mgsloan: it could be because I have no clue what I’m doing package-wise :)
21:52:30 <EvanR> checkemout
21:52:51 <mgsloan> julianleviston: After another "stack upgrade --git"? hmm
21:53:01 <julianleviston> mgsloan: yeah, I just did that.
21:53:03 <Hafydd> In #lua, every message you type is sent as a global message on the IRC network unless you explicitly declare it as local.
21:53:05 <julianleviston> oh wait… did I
21:53:09 <julianleviston> yes.
21:53:14 <EvanR> lol
21:54:10 <Guest43807> i asked here b/c haskellers are smart
21:54:21 <Guest43807> i don't know where else to find smart people who also program
21:54:36 <Sinestro> lol
21:55:00 <julianleviston> Guest43807: maybe #haskell-blah is a good place to ask non-haskell questions of the haskell people?
21:55:04 <Sinestro> never confuse us for smart. smart people go outside and talk to people
21:55:18 <Sinestro> instead of bossing around pieces of silicon all day
21:55:37 <Sinestro> programmers are, at best, skilled
21:55:40 <davean> Sinestro: Thats social people
21:55:52 <davean> Sinestro: you've confused smart and social
21:55:58 <Guest43807> a good programmer would also be social 
21:56:04 <Guest43807> so he can work with others
21:56:04 <mgsloan> julianleviston: Try "stack update" to fetch your package index?
21:56:39 <julianleviston> mgsloan: no change, sadly.
21:56:50 <julianleviston> mgsloan: I have a feeling that it’s my cabal file.
21:57:47 <julianleviston> hm 
21:57:57 <julianleviston> there’s an lts 3 now?
21:58:52 <mgsloan> Yup.  Maybe that's the easy fix, just upgrade to lts 3 / GHC 7.10
21:59:06 <julianleviston> mgsloan: I’ve already got 7.10.2
21:59:26 <mgsloan> LTS-2.19 uses GHC 7.8
21:59:29 <julianleviston> mgsloan: I just noticed, because I switched into a different project to build it to test (a test for groundhog) and it started getting lts 3
21:59:32 <julianleviston> mgsloan: ahhhh
22:00:16 <julianleviston> mgsloan: I just updated to 10.11 and I had to replace my cabal with one that worked for ghc 7.8 that evan (of elm fame) built… 
22:00:53 <julianleviston> mgsloan: the “main” project I’m trying to build is a test Snap app that I’m trying to get a groundhog snaplet I found in someone’s github repo to work with.
22:01:09 <julianleviston> mgsloan: sorry - os/x10.11 by the way lol :) missed that out.
22:01:54 <julianleviston> mgsloan: ok I might start from scratch and slowly introduce known good pieces.
22:17:47 <DigitalKiwi> Guest43807 Lua is one of my favorites
22:22:07 <julianleviston> has anyone used Fruit?
22:58:41 <lispy> julianleviston: Unless something changed, my understanding is that Fruit was a cool research prototype that stagnated after folks published/moved on
22:58:56 <julianleviston> lispy: ah… hence reactive-banana etc?
22:59:27 <lispy> I don't know if they are related, but yeah basically
22:59:36 <lispy> FRP Now seems pretty nice, bTW
22:59:46 <lispy> IF you're looking specificalyl into FRP
23:00:07 <lispy> http://www.cse.chalmers.se/~atze/papers/prprfrp.pdf
23:00:15 <lispy> and there is a talk from the latest ICFP about it as well
23:01:40 <lispy> yampa is the main FRP library I've played with, but I found arrows to be ... unpleasant
23:03:22 * hackagebot pandoc-citeproc 0.8.0.1 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.8.0.1 (JohnMacFarlane)
23:04:59 <pyrtsa> julianleviston, lispy: With the changes in its latest major version (1.0.0.0), I'd consider using reactive-banana.
23:05:42 <lispy> pyrtsa: cool. I did checkout reactive banana last month and for the first time the pathologically bad space leaks I was having before were gone :)
23:06:30 <pyrtsa> FRPNow seems cool too, but I'm a bit concerned that it's more of a research toy until the list of future research topics in the Conclusion of the above paper have been fixed.
23:07:14 <pyrtsa> (Or I mean, the ideas behind FRPNow are cool. But reactive-banana isn't that different.)
23:08:25 <lispy> sodium and elerea are supposed to be nice as well, but I have 0 experience with them
23:08:58 <liste> how many FRP frameworks are out ther :D
23:09:13 <pyrtsa> Sodium (its Haskell variant) has been deprecated in favour of reactive-banana. What the latter does is equivalent but it does it better than Sodium.
23:09:50 <lispy> liste: there is really a lot
23:10:05 <lispy> liste: and it can be quite challenging to figure out how they differ in practice
23:10:55 <lispy> I keep hopiing someone will make a bench of programs and translate them to all of the frameworks to show off the differences
23:11:08 <liste> TodoFRP :D
23:11:11 <pyrtsa> I'm not sure if Gergy has been all that active maintaining Elerea lately. But Elerea, Reflex, Sodium, reactive-banana and FRPNow seem to have been converging towards the same goal, with slightly different approaches. Yampa is much different of course.
23:12:17 <lispy> Yampa seemed really nice until I wanted to switch varying behaviors together using switches or do any substantail refactoring. I kept accidentally bumping up against the arrow restrictions.
23:12:18 <pyrtsa> While FRPNow is brand new, Reflex and reactive-banana seem most active to me.
23:13:08 <lispy> Maybe if I had use more of the combinators and less of the proc notation, I would have had a better time. Dunno.
23:13:50 <pyrtsa> Yampa also reevaluates the whole graph every iteration, so it might not scale. But it could be nice in a game-like scenario where you'd do that anyway (and constantly work against a ticking clock).
23:15:22 <pyrtsa> lispy: With all the FRP libraries listed above, you should take a good look at Reflex too. It's much more mature than e.g. Sodium, although it gets complicated with type signatures.
23:17:32 <lispy> pyrtsa: thanks. I'll keep that in mind the next time I need to scratch that itch.
23:39:50 <nitrix> Cale: Are you still responsible of lambdabot?
23:40:18 <nitrix> I was wondering if it could be possible to update lambdabot's offline docs to make it more up-to-date.
23:41:32 <nitrix> Currently, the type signature of `length` shows `[a] -> Int` instead of `Foldable t => t a -> Int`.
23:42:03 <nitrix> (When doing hoogle searches).
23:45:01 <Fylwind> is there a way to write let x' = x, y' = y, z' = z in [x', y', z'] more idiomatically?
23:45:15 <Fylwind> correction: is there a way to write let !x' = x, !y' = y, !z' = z in [x', y', z'] more idiomatically?
23:45:27 <Fylwind> I want the elements of a list to be completely strict
23:45:36 <Fylwind> but there's a lot of elements
23:46:32 <julianleviston> Fylwind: can’t you use … ummm I can’t remember something to do with seq… 
23:47:21 <pavonia> :t map (join seq)  -- ?
23:47:23 <lambdabot> [a] -> [a]
23:47:55 <glguy_> Join seq is a no op
23:48:14 <pavonia> Hhm
23:49:19 <julianleviston> Fylwind:  oh… deepseq ?
23:49:40 <julianleviston> Fylwind: is that what you want?
23:50:08 <Fylwind> I could … but I'm not sure if deepseq is enough of a hint to GHC though
23:50:14 <Fylwind> (this is mainly for optimization reasons)
