00:08:36 * hackagebot carettah 0.4.0 - A presentation tool written with Haskell.  https://hackage.haskell.org/package/carettah-0.4.0 (KiwamuOkabe)
00:12:47 <lpaste> tabemann pasted ‚Äúwhy isn't this working?‚Äù at http://lpaste.net/143756
00:15:19 <cocreature> tabemann: what do you mean by not working?
00:15:25 <lamefun> Are there statically dynamic type-level monoids?
00:15:50 <Tehnix> statically dynamic ._.
00:15:59 <Tehnix> How does that work?
00:16:03 <lamefun> tabemann, why IsString?
00:16:48 <tabemann> lamefun: because I want it to work with String, Text, etc.
00:16:55 <lispy> tabemann: you might want to read Section 7.6.3.1: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-class-extensions.html
00:17:34 <cocreature> tabemann: you only use show so the IsString isn't allowing you to do anything
00:17:43 <tabemann> yes
00:17:49 <lamefun> Tehnix, I have no idea what they mean, I just want them statically dynamic
00:18:11 <tabemann> this is because in the actual code I'm working on, I want types without IsString instances to behave differently
00:20:13 <lamefun> Is there a standard class for Formattable?
00:22:13 <tabemann> what I'm really trying to do is create a better Text.Printf, one that takes an map of names to values, any arbitrary formatting string that can be provided at runtime (i.e. no fixed number of arguments or fixed types), and for my own purposes, supports styled and colored text
00:22:37 <tabemann> the purpose of the map is so that the order of values is not hard-coded but is determined by the formatting string
00:22:48 <lamefun> Why don't you simply define instances for String, Text, etc.?
00:22:53 <lispy> tabemann: http://okmij.org/ftp/typed-formatting/
00:22:58 <tabemann> and so that values can even be omittted or repeated as needed
00:23:00 <bitemyapp> tabemann: http://hackage.haskell.org/package/formatting
00:23:50 <bitemyapp> lispy: Holey Monoids are simpler.
00:24:32 <lispy> There's a simpler way to do something than what Oleg came up with?
00:24:33 <lamefun> I want a static-dynamic query function.
00:24:51 <lispy> (yes, that was sarcasm)
00:26:12 <bitemyapp> lispy: seems appropriate that you'd use the parenthetical.
00:26:42 <bitemyapp> lispy: sadly there isn't a syntactic equivalent to biting or I'd dance with you.
00:26:52 <EvanR> tabemann: im not sure why this would be a polymorphic feature
00:30:13 <EvanR> why not a formatMyTypeA, formatMyTypeB which take different kinds of formatting options
00:30:24 <EvanR> instead of a Map of strings
00:31:47 <tabemann> by goal here is to be able to have locale-configurable and user-configurable messages which are arbitrary in nature, i.e. no enforced ordering or even presence of formatted values; these examples I see all assume fixed ordering
00:32:20 <EvanR> the user is writing instances?
00:32:27 <EvanR> or do you mean library user
00:32:57 <tabemann> no, they're writing strings like, e.g. "%nick:s left %channel:s"
00:33:24 <tabemann> where "nick" and "channel" are keys into the map of values
00:33:46 <EvanR> so you have an algorithm like String -> Map String String -> String ?
00:34:02 <tabemann> that's what I'm trying to implement
00:34:30 <tabemann> more like FormattableValue a => String -> Map String a -> String
00:34:44 <EvanR> ok, String -> Map String String -> String is better
00:35:20 <EvanR> for any Map String X you can convert it to a Map String String using the pretty printer defined for X
00:35:53 <tabemann> the thing is that I'd like the user to be able to use C-style formatting *after* the keys are specified
00:36:25 <tabemann> that's why I didn't write Show a => String -> Map String a -> String
00:37:09 <EvanR> is a like a dynamic type?
00:37:31 <EvanR> youre going to have Map String (Number+String+Null+Bool)
00:37:32 <tabemann> dammit I've been working in Java too long...
00:38:25 <tabemann> now I don't even remember the name of what in Haskell is roughly equivalent to dynamic types
00:38:33 <tabemann> because that's what I want to use here
00:38:58 <EvanR> well good, because if your dynamic type type is called MyDynamicType you can write all your functions against that
00:39:09 <EvanR> which will be explicit on how nonsense format strings work
00:39:32 <EvanR> like %.2f used on a Bool
00:40:58 <tabemann> nonsense format strings will result in things like "<BAD FORMAT STRING> left #haskell"
00:41:20 <EvanR> im not sure how youd accomplish that with type classes
00:41:35 <EvanR> by implementing "<BAD FORMAT STRING>" instance for every type you can think of?
00:42:05 <EvanR> or as a fall through case in every instance
00:42:28 <EvanR> but if in your final application youll only have Map String MyDynamicType, then none of this matters.
00:43:13 <tabemann> the thing is that MyDynamicType is defined as data MyDynamicType = Formattable a => MyDynamicType a
00:43:26 <EvanR> i doubt it
00:44:19 <EvanR> why do you want to use type classes so much for this? most times you would think to make something polymorphic over Show, you could just pass in a String instead and it would be more flexible
00:44:48 <EvanR> and allow mixing things that dont have the same type
00:45:11 <tabemann> because I want the formatting string to specify formatting, to use different formatting functions with each type which has a Formattable instance
00:45:24 <EvanR> sounds like XY
00:45:25 <tabemann> and unlike Show, Formattable takes a formatting string to parse
00:46:06 <tabemann> I can't use Map String String because then the formatting string wouldn't be able to specify the formatting of each field
00:46:08 <EvanR> im trying to figure out what youre really trying to do and suggest a bette rway
00:46:36 <EvanR> youre right, i suggested something that coul
00:48:20 <tabemann> the other solution is to not bother with type classes and use a sum type instead of MyDynamicType, and hardcode in all the possible constructors in one place, and have one formatting function that handles all of those in one place
00:48:48 <EvanR> i was assuming you knew i meant sum type = MyDynamicType
00:49:07 <tabemann> I was thinking of something different there
00:49:10 <EvanR> MyBool Bool | MyString String | MyNumber Double
00:49:40 <EvanR> i.e. how youd implement dynamic types in a dynamically typed language
00:49:46 <tabemann> as I mentioned, I assumed MyDynamicType was: data MyDynamicType = Formattable a => MyDynamicType a
00:49:54 <EvanR> thats not actual haskell code
00:50:03 <tabemann> not Haskel98, no
00:50:04 <EvanR> and makes no sense
00:50:23 <EvanR> its not any haskell anymore
00:51:02 <EvanR> i mean MyDynamicType a = Formattable a => MyDynamicType a doesnt work anymore
00:51:37 <tabemann> when'd they get rid of that?
00:51:41 <EvanR> you should read about the existential-for-oop anti-pattern
00:52:30 <ChristianS> tabemann: if Formattable is a typeclass, you can just add  Formattable a  as a constraint to all functions that need a Formattable. you don't need MyDynamicType.
00:53:31 <tabemann> ChristianS: the problem is making Map String a contain a variety of types
00:53:40 <tabemann> that doesn't accomplish that
00:53:52 <EvanR> tabemann: ah i didnt know you were trying to do that, you cant do it that way
00:54:09 <EvanR> youre trying to make a heteromap, now we can talk about how to not do that ;)
00:54:33 <tabemann> well I didn't realize that they got rid of existential types
00:54:56 <EvanR> they didnt, they got rid of constraints in ADT definitions
00:55:17 <EvanR> this is an existential data Foo = forall a . Foo a
00:55:28 <EvanR> which is a different thing entirely
00:55:49 <tabemann> but that's useless, because you don't know anything about a
00:56:02 <EvanR> correct
00:56:13 <EvanR> so thats not what you want ;)
00:56:54 <EvanR> i think you want to use "OOP" instead
00:57:38 <EvanR> what you seem to want is a map of objects which are different in nature, but have a uniform interface, namely that you can get a String using a format String
00:59:12 <EvanR> in haskell you can express the interface as the type String -> String, and you can create arbitrary values that support this interface using partial application of functions of the form X -> String -> String
00:59:23 <EvanR> your maps would have the type Map String (String -> String)
00:59:52 <EvanR> the source of data for the map elements could be any type, not all the same
01:00:00 <tabemann> that would work
01:00:45 <elliptic00> hi guys, this might be not a Haskell question, but it is indirected relative to monoid questions. we know Min forms a monoid. e.g. MAX = identity 
01:01:29 <elliptic00> I'm wondering what is the proerties:  Min(a, b) + 1 = Min(a+1, a+1)
01:01:58 <lamefun> Are there integer overflow safe conversion functions?
01:02:18 <EvanR> elliptic00: not all Bounded things you can use with Min can do + 1
01:02:31 <elliptic00> no, there is not a Haskell syntax
01:02:48 <EvanR> and Min(a+1,a+1) = a+1
01:03:11 <elliptic00> I'm talking about Monoid algebraic definition
01:03:44 <EvanR> typo?
01:04:19 <elliptic00> Min(a+1, a+1) = Min(a, a) + 1
01:04:33 <EvanR> did you mean to write Min(a+1,b+1)
01:04:37 <elliptic00> so Min(a, b) + 1 = Min(a+1, b+1)
01:05:16 <EvanR> thats not a monoid law, thats the distributive law
01:05:27 <EvanR> and does not hold for all monoids that have +1
01:06:14 <EvanR> f(min(a,b)) /= min(f(a), f(b))
01:06:57 <elliptic00> I'm only talking Monoid laws.
01:07:18 <EvanR> well theres no such monoid law Min(a, b) + 1 = Min(a+1, b+1)
01:07:44 <elliptic00> u might be right, it is distritutive law, but Monoid does't need that to hold
01:07:55 <EvanR> correct, it doesnt
01:08:20 <elliptic00> thx.
01:08:24 <EvanR> > min maxBound (maxBound-1)
01:08:26 <lambdabot>      No instance for (Show a0)
01:08:26 <lambdabot>        arising from a use of ‚Äòshow_M74359158768102530628927‚Äô
01:08:26 <lambdabot>      The type variable ‚Äòa0‚Äô is ambiguous
01:08:33 <EvanR> > min maxBound (maxBound-1) :: Int
01:08:34 <lambdabot>  9223372036854775806
01:08:49 <EvanR> > (min maxBound (maxBound-1))+1 :: Int
01:08:51 <lambdabot>  9223372036854775807
01:09:00 <EvanR> > (min maxBound (maxBound+1)) :: Int
01:09:01 <lambdabot>  -9223372036854775808
01:13:56 * hackagebot exhaustive 1.1.2 - Compile time checks that a computation considers producing data through all possible constructors  https://hackage.haskell.org/package/exhaustive-1.1.2 (OliverCharles)
01:48:07 <lf94_> reactive programming makes so much sense in an environment where values are changing all the time.
01:48:27 <lf94_> I can see why people talk about it for GUIs.
01:48:59 <EvanR> frp?
01:50:34 <lf94_> Yeah
01:50:43 <capisce> frp is a bit more specific
01:50:49 <lf94_> Yeah, I was about to say
01:50:59 <lf94_> Doesn't need to be *functional* reactive programming.
01:51:04 <EvanR> i was wonder if "reactive programming" is referring to like bacon.js
01:51:06 <lf94_> I just mean reactive programming.
01:51:23 <lf94_> (Pure) FRP is even better though.
01:51:23 <EvanR> if thats the case im annoyed because the next step after that is "programming"
01:51:43 <EvanR> but i guess there is "processing" already ;)
01:51:57 <capisce> why annoyed?
01:52:20 <lf94_> Haha, yeah! I didn't realize that. I guess Processing is reactive.
01:52:35 <lf94_> (GF uses it in one of her courses.)
01:52:39 <EvanR> bacon-like "reactive programming" was invented because there was backlash against calling it FRP
01:52:52 <EvanR> like julia attempting to add "dependent types"
01:52:57 <capisce> yep
01:53:00 <EvanR> terminology wars
01:53:14 <capisce> indeed
01:53:22 <lf94_> I was just taught about dependent types today. I highly doubt Julia has dependent types...
01:53:25 <EvanR> take something cool, do it wrong, and call it the same thing ;)
01:53:28 <capisce> the FRP term should have been more specific
01:53:32 <EvanR> lf94_: right
01:53:50 <lf94_> What is it really, in Julia?
01:53:53 <lf94_> Just types?
01:54:00 <lf94_> I thought it was dependency injection
01:54:02 <EvanR> runtime checked parameterized classes
01:54:08 <lf94_> Like in PHP
01:54:19 <EvanR> like Matrix<4,4>
01:54:32 <EvanR> the dimensions will be checked at runtime
01:54:33 <lf94_> Ah
01:54:47 <lf94_> Well I can see why they thought it *was* dependent types
01:55:12 <EvanR> its about marketing
01:55:23 <EvanR> and FUD
01:55:28 <EvanR> well confusion
01:55:58 <lf94_> Yeah definitely marketing.
01:56:18 <lf94_> That's why I love the Haskell community - so down to Earth and *really* persistent on correctness.
01:56:25 <lf94_> Correctness runs straight to the core.
01:56:28 <EvanR> i can predict the next thing like this, if a language added the ability to type a variable as some subset of the 7 or do dynamic types, like Bool|Number, that would be called Sum Types ;)
01:56:41 <EvanR> 7 or so
01:56:57 <lf94_> lmao
01:57:01 <lf94_> Yeah
01:57:02 <pyon> EvanR: In dynamic languages, it looks more like union types. (Which are similar, but not quite the same thing as sums.)
01:57:06 <lf94_> Multitypal
01:57:25 <lf94_> (A term someone might also come up with - probably some JavaScript guy)
01:57:31 <EvanR> untagged union, which doesnt really make sense
01:57:38 <pyon> EvanR: The difference being that `(Bool | Number) | Number` is just `Bool | Number`.
01:58:09 <lf94_> I think that's a bad example
01:58:19 <EvanR> i dont think its that similar
01:58:21 <lf94_> Isn't that same as...Bool | Number | Number?
01:59:02 <lf94_> Which is, yeah, the same as Bool | Number...
01:59:10 <paldepind> capisce, the FRP term _is_ very specific. People just ignored the specification.
01:59:15 <EvanR> a sum lets you have A x | B y where x might be y, and the union types is about classifying subsets of an already existing type (the dynamic type)
01:59:24 <pyon> You can think of sum types this way: primitive types are disjoint sets of values, but union types may overlap. When taking the union of two overlapping types, the overlapping part is only included once in the union.
01:59:33 <pyon> Errr, s/sum/union/
01:59:44 <EvanR> yeah i think thats a bad way to look at it, using sets
01:59:48 <EvanR> (untyped sets)
02:00:02 <lf94_> I think unions are too different from sum types to even compare them
02:00:04 <pyon> EvanR: Yeah, but that's the only way I can make sense of dynamic types. :-|
02:02:19 <EvanR> im really trying to ignore terminology and think of dynamic typing schemes as runtime classification of runtime objects
02:02:36 <lf94_> Good way to look at it
02:02:37 <EvanR> and calling it a type system just confuses the whole thing
02:02:40 <lf94_> Never thought about that
02:03:07 <lf94_> You're referring to Haskell, right?
02:03:16 <EvanR> uh no
02:03:24 <lf94_> >dynamic typing scheme
02:03:41 <EvanR> like php python js
02:03:46 <lf94_> is data Type a = Nothing | Just a not dynamic?
02:03:52 <lf94_> eh
02:03:53 <lf94_> guess not!
02:04:01 <lf94_> Considering types are all settled at compile time
02:04:03 <lf94_> :)
02:04:16 <lf94_> Right right right...that's what I thought at first. Just needed to clarify.
02:04:22 <EvanR> the Nothing and Just serve to classify Type a's at runtime
02:04:32 <EvanR> so yeah
02:04:54 <nitrix> lf94_: I used to make that mistake all the time. Approach types from the perspective they are set of possible values. Then sum types and product types will instinctively make sense.
02:05:33 <EvanR> typed sets though
02:06:16 <EvanR> that is, sum and products of sets A and B are new sets A+B and AxB. but union A with B makes no sense
02:06:40 <paldepind> Because A and B are disjoint?
02:06:57 <EvanR> because they have different types
02:07:10 <EvanR> you can think of union as making sense between any two subsets of a given 1 set
02:07:16 <lf94_> nitrix: The mistake of thinking it's dynamic?
02:07:43 <EvanR> union :: P(A) -> P(A) -> P(A)
02:07:44 <lf94_> Also nitrix, freaking 5am.
02:07:45 <nitrix> lf94_: I'm an intruder that hasn't read much of the discussion.
02:07:47 <EvanR> powerset of set A
02:08:05 <nitrix> lf94_: Isn't it 5am for you too? :)
02:08:06 <paldepind> EvanR, yes. That makes sense. And them being subset of a given 1 set means that the values they contain are of the type being described by that 1 set?
02:08:10 <lf94_> nitrix: I'm in Australia.
02:08:50 <EvanR> paldepind: yeah. which again suggests dynamically typed languages have 1 universal type, so union types make sense
02:09:03 <lf94_> nitrix: I'll keep that advice in mind though. types are a set of possible values.
02:09:10 <lf94_> Seems like good advice at a glance
02:09:11 <EvanR> well, it might! or might now, once you look at it like this
02:09:18 <EvanR> not*
02:09:26 <nitrix> lf94_: I messed up my sleep schedule. I love writing haskell code at night, from my condo unit, next to the window, with a view on the city down below.
02:09:49 <paldepind> EvanR, that I don't understand. Union types also makes sense in statically typed languages.
02:09:52 <EvanR> so still not too convinced unions make sense in real DT languages
02:09:55 <lf94_> ntrix: Ah.
02:10:02 <nitrix> I have a friend mathematician that comes ones in a while and he spends the night with a marker solving equations :P
02:10:05 <lf94_> nitrix: Lets just start a Haskell company.
02:10:11 <nitrix> I wish.
02:10:16 <lf94_> nitrix: And become famous in Montreal
02:10:17 <lf94_> B)
02:10:20 <EvanR> paldepind: you think so?
02:10:43 <paldepind> EvanR, Elm has them and it is a statically typed language?
02:10:57 <nitrix> lf94_: Anyway, #haskell-blah for this. #haskell's topic is pretty strict.
02:11:09 <EvanR> is Elm a static language intended to model javascripts dynamic type system?
02:12:06 <EvanR> paldepind: hmm i dont see union types
02:13:03 <paldepind> EvanR, it seems like they don't mention it any more. But they used to describe their types as being union types and it looked very much like sum types. I never understood the distinction.
02:13:22 <EvanR> the docs have "tagged union" which is another name for sum types
02:13:53 <EvanR> earlier we were talking about untagged unions, which dont make much sense (unless maybe were talking about a dynamic language where you can do this subset thing of the 1 universal type)
02:14:32 <paldepind> EvanR, They might have been using imprecise terminology in the documentation then.
02:14:52 <lf94_> data MyType = Int | Bool | etc
02:14:57 <lf94_> Isn't that like a union?
02:15:10 <lf94_> Note: like
02:15:16 <EvanR> looks like an enum to me
02:15:28 <EvanR> which is a degenerate sum type
02:15:58 <lf94_> data MyType = Int Int Int | Int | Bool
02:16:14 <EvanR> you repeated two of the constructors
02:16:26 <lf94_> rip
02:16:30 <lf94_> I'm just being senseless
02:16:32 <lf94_> heh
02:16:47 <EvanR> data MyType = MyInt Int | MyBool Bool | ...
02:16:50 <lf94_> data MyType = Ho Int Int Int | He Int | Ha Bool
02:17:09 <EvanR> now were on the way to implementing PHP
02:17:13 <paldepind> EvanR, you seem to know a lot about types :) Any recommendation on how to gather such knowledge?
02:17:14 <lf94_> hahaha
02:17:40 <EvanR> i can tell you a book or two 
02:18:21 <paldepind> That's exactly what I'm after.
02:18:31 <EvanR> theres types and programming languages (tapl)
02:18:39 <zomg> EvanR: *cough* https://github.com/jhartikainen/hs-language-php/blob/master/Tokenizer.hs#L11
02:19:01 <paldepind> I've got that one laying around. I'm currently reading up on math so that I can understand it.
02:19:21 <lf94_> zomg: That's like a real union :>
02:19:27 <EvanR> i found this one recently practical foundations for programming languages
02:19:31 <paldepind> I've read the first 2 chapters but I need to understand induction better to grasp the proofs.
02:20:05 <paldepind> EvanR, I've looked at that as well. Do you like it? Apparently there's a second version under way.
02:20:28 <EvanR> i like the subject matter presented
02:20:39 <nitrix> lf94_: MyType is the set of values composed of the sum of the other set of types listed.
02:20:47 <EvanR> but the author seems to be flaming against dynamic languages hardcore the whole time
02:20:56 <EvanR> which is fine but in a text book?
02:20:57 <elpetrero> EvanR: any recomendation for somebody approaching it from graduate level math?
02:21:19 <elpetrero> somebody who already manager first order logics but doesn't think much about it
02:21:23 <elpetrero> *manages
02:21:26 <paldepind> It's more general than just types? Do you think it's best to read it before or after tapl?
02:22:02 <EvanR> elpetrero: not really, but i see people recommend Software Foundations which has a lot of proofs
02:22:11 <EvanR> or its about doing proofs with coq
02:22:31 <EvanR> do tapl
02:22:43 <elpetrero> I think I got to the chapter about lists, played a bit with induction on coq
02:23:18 <elpetrero> but It seemed really oriented to programming instead of math proofs of lineal algebra
02:23:44 <elpetrero> I should approach it with a more open mind
02:24:19 <EvanR> type theory seems to involve a lot of logic, but if you want more math maybe you want category theory instead
02:24:59 <elpetrero> already working my way through Cat theory for the wrking mathematician 
02:25:02 <elpetrero> :-D
02:25:15 <elpetrero> This community has all the right influences
02:25:38 <paldepind> How do you do? I've heard that book is really tough.
02:25:57 <nitrix> elpetrero: For someone that had no experience nor background with neither, I find type theory easier.
02:26:01 <elpetrero> if you know algebraic structures you can relate to a lot of examples
02:27:52 <elpetrero> CT serves the same function a naval map server on the sea. It's a guide and can tell you a where are the good spots of different areas
02:28:03 <elpetrero> *serves
02:28:32 <lf94_> nitrix: I have no idea what you said earlier x_x
02:28:51 <nitrix> elpetrero: You're supposed to use car analogies like everyone.
02:28:51 <lf94_> MyType is just 3 Ints, 1 Int or 1 Bool
02:28:53 <nitrix> :P
02:29:24 <paldepind> What is the car analogy?
02:29:43 <nitrix> lf94_: The 3 Ints is a product type, but your final MyType is a sum type, which is the sum of the values possible from all those types combined.
02:30:02 <nitrix> lf94_: That's because your value of type MyType can be a value of any of those sets.
02:30:09 <EvanR> if very general fields of math were cars
02:30:25 <elpetrero> I will try with car analogies
02:30:39 <EvanR> actually theres if set theories were operating systems
02:30:41 <elpetrero> car, uh, bro, rev up and speed
02:30:46 <elpetrero> ag i suck a this
02:31:13 <EvanR> ZF is windows, ETCS is unix, and SEAR is OSX ;)
02:31:16 <no-n> dude where's my category?
02:32:04 <lf94_> nitrix, ah, you were just defining what it was.
02:32:05 <EvanR> nitrix: a tagged value
02:32:23 <nitrix> lf94_: Think of it this way if you substitute them: e.g. data DemoType = (1 | 2 | 3)  |  (4 | 5 | 6) | (7 | 8 | 9)
02:33:08 <lf94_> nitrix: that makes no sense to me.
02:33:16 <EvanR> data Either a b = Left a | Right b, so the union thing breaks down for Either Int Int
02:33:20 <lf94_> Aren't you also missing data constructors?
02:33:41 <nitrix> lf94_: I'm explaining figuratively sum and product types.
02:33:50 <lf94_> I know what they are
02:33:58 <nitrix> What?!
02:33:59 <lf94_> t = a a a <- product type
02:34:17 <lf94_> t = a a a | b b <- 2 product types, with t being a sum type
02:34:28 <nitrix> Strange. What made me think that you were confused...
02:34:28 * hackagebot getopt-generics 0.11.0.3 - Create command line interfaces with ease  https://hackage.haskell.org/package/getopt-generics-0.11.0.3 (SoenkeHahn)
02:34:30 * hackagebot clash-prelude 0.10.3 - CAES Language for Synchronous Hardware - Prelude library  https://hackage.haskell.org/package/clash-prelude-0.10.3 (ChristiaanBaaij)
02:34:32 * hackagebot clash-lib 0.6.3 - CAES Language for Synchronous Hardware - As a Library  https://hackage.haskell.org/package/clash-lib-0.6.3 (ChristiaanBaaij)
02:34:34 * hackagebot clash-ghc 0.6.3 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.6.3 (ChristiaanBaaij)
02:34:41 <lf94_> nitrix, you are just being strangely confusing to me. lol.
02:34:59 <EvanR> probably because lf94_ was like data Foo = Int Int Int | Int
02:35:01 <lf94_> It could be because it is *5 am*
02:35:07 <nineonine> hi there
02:35:17 <nineonine> how can i make Char instanceOf IsString
02:35:40 <EvanR> toString c = [c]
02:35:43 <elpetrero> lf94_: new york?
02:35:58 <lf94_> nitrix: also I guess you missed out on the context. We were talking about representing unions in Haskell :>
02:36:12 <lf94_> elpetrero, Montreal
02:36:23 <nineonine> so i need to implement this one method for Char right ?
02:36:26 <elpetrero> noice
02:36:28 <elpetrero> eh
02:36:29 <lf94_> (Except I'm actually in Australia)
02:36:32 <EvanR> yes
02:36:36 <elpetrero> omelette au fromage?
02:36:40 <lf94_> lmao
02:36:43 <nineonine> ok will try it out
02:36:44 <nineonine> thanks
02:37:32 <nitrix> EvanR: Isn't it `fromString :: String -> a` ?
02:37:44 <EvanR> er yeah
02:37:54 <EvanR> fromString [c] = c ;)
02:37:58 <nineonine> :D
02:38:21 <elpetrero> fromString a:_ = a ?
02:38:32 <EvanR> you could do that
02:38:50 <EvanR> but specifying more than 1 letter for a char makes no sense
02:39:09 <nitrix> Does that matches a single character string?
02:39:14 <elpetrero> You clearly haven't pair programmed with me then
02:39:40 <EvanR> > case "a" of [c] -> c
02:39:42 <lambdabot>  'a'
02:39:45 <EvanR> > case "ab" of [c] -> c
02:39:47 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
02:40:10 <elpetrero> > case ab of c:_ -> c
02:40:11 <lambdabot>      Not in scope: ‚Äòab‚Äô
02:40:11 <lambdabot>      Perhaps you meant one of these:
02:40:11 <lambdabot>        ‚Äòa‚Äô (imported from Debug.SimpleReflect),
02:40:16 <elpetrero> > case "ab" of c:_ -> c
02:40:18 <nitrix> I guess his suggestion is safer but less correct.
02:40:18 <lambdabot>  'a'
02:40:35 <EvanR> you can always avoid crashing by silling in the missing cases with nonsense ;)
02:40:35 <capisce> paldepind: I mean they should have chosen a more specific term for what is now called FRP, instead of hogging the generic "Functional Reactive Programming"
02:40:39 <EvanR> by filling
02:40:49 <EvanR> but in PHP thats called "white screen effect"
02:41:02 <EvanR> an error causes a white screen instead of an error message
02:41:18 <lf94_> I hate that so much
02:41:58 <nitrix> Nothing like an error that doesn't print on a Monday morning :)
02:42:11 <nineonine> fromString [c] = c
02:42:13 <nineonine> gave me
02:42:16 <nineonine> Non-exhaustive patterns in function fromString
02:42:30 <EvanR> a compile error?
02:42:41 <elpetrero> [c] desugars into c:[]
02:42:41 <EvanR> add another clause
02:42:47 <nitrix> nineonine: Is the string matched more than a single character?
02:42:59 <EvanR> fromString _ = error "wtf"
02:43:02 <elpetrero> which is a particular case of the two you need to define
02:43:10 <paldepind> capisce, Oh. Then we agree. The more specific term is invented btw. It's "denotational continuous-time programming".
02:43:38 <capisce> ah yes, I remember reading about that somewhere
02:43:40 <EvanR> i think conal has said that functional doesnt mean anything anyway
02:44:12 <capisce> right: https://medium.com/@andrestaltz/why-i-cannot-say-frp-but-i-just-did-d5ffaa23973b#.3yzeu6k7z
02:44:15 <paldepind> I don't think he said that. I think however that it means something more specific to him than to other people.
02:44:32 <EvanR> its in this talk right here! ;)
02:44:39 * hackagebot hakyll 4.7.4.0 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.7.4.0 (JasperVanDerJeugt)
02:44:46 <paldepind> He's said that he prefer the term denotational programming to functional programming.
02:45:00 <EvanR> and the blog goes over all the issues with what is and isnt functional
02:45:06 <paldepind> Which talk?
02:45:26 <EvanR> https://www.youtube.com/watch?v=bmKYiUOEo2A
02:45:40 <paldepind> I've heard him define functional programming as "programming with mathematical functions". That quite different from saying it doesn't mean anything.
02:45:59 <EvanR> yes you can define whatever in a current context, for the sake of argument
02:46:25 <EvanR> but stuff like "functional reactive programming" as a thing without context, is different. no one is usually there to tell you what it means, or disagree with you about your interpretation
02:46:32 <EvanR> theres no actual discussion, or context
02:46:42 <EvanR> so the question is what stuff means by default
02:46:52 <EvanR> and in the worst case, nothing ;)
02:47:47 <paldepind> Well. There's a difference between what something initially meant by the coiner of a term and what it has turned out to mean.
02:48:02 <paldepind> Basically both functional programming and FRP has turned into just buzzwords.
02:48:15 <EvanR> yeah originally i think he wanted it to be well defined (my by-default meaning)
02:48:22 <EvanR> and it has turned out to mean nothing ;)
02:48:24 <capisce> I feel I still have a lot to learn about the benefits of various reactive programming approaches vs DCTP
02:48:27 <EvanR> (by default)
02:48:56 <EvanR> paldepind: though i was talking about "functional" without context
02:49:05 <paldepind> He certainly did. He gave it a very specific definition.
02:49:30 <EvanR> common lisp was said to be a functional language
02:49:31 <lf94_> http://i.imgur.com/3NuyFKm.png
02:49:37 <capisce> I'm still on the fence about how wise it is to propagate signals / events through the entire signal graph on each new change
02:49:40 <lf94_> Whoops
02:49:51 <lf94_> Not what I meant to paste...this is what I meant: http://conal.net/fran/tutorial.htm
02:49:54 <capisce> like Elm does
02:49:57 <lf94_> Fran is freaking awesome.
02:50:03 <EvanR> capisce: thats a particular implementation strategy, and yeah might not be the right thing in all circumstances
02:50:06 <lf94_> Great way of representing FRP.
02:50:13 <vadgeayna> common lisp is a more important language than haskell
02:50:17 <vadgeayna> haskell sucks
02:50:36 * EvanR checks average salary of common lisp vs haskell ;)
02:50:37 <paldepind> EvanR, By many people Common Lisp is still said to be a functional language.
02:50:47 <vadgeayna> common lisp is better than haskell
02:50:50 <EvanR> paldepind: and has not much in common with haskell at all
02:50:54 <EvanR> so
02:51:00 <EvanR> its almost getting to the OOP stage of definition
02:51:02 <vadgeayna> haskell was cerated by a fat lazy nigger retard who couldn't learn lisp properly
02:51:06 <capisce> common lisp is also said to be a multi-paradigm programming language
02:51:10 <capisce> like Oz
02:51:18 <vadgeayna> nigger retard
02:51:29 <paldepind> I agree. If Common Lisp is a functional programming language then JS is as well.
02:51:33 <kloeri> vadgeayna: drop the trolling
02:51:37 <EvanR> !ops
02:51:37 <vadgeayna> no you nigger
02:51:41 <vadgeayna> go back to africa
02:51:44 <bitemyapp> @ops
02:51:44 <lambdabot> Maybe you meant: pl oeis docs
02:51:46 <vadgeayna> i will kill every nigger that i see
02:51:48 <bitemyapp> @op
02:51:49 <lambdabot> Maybe you meant: yow wn v rc pl id do bf @ ? .
02:51:55 <bitemyapp> well nevermind then.
02:52:49 <EvanR> paldepind: moral of the story i think is, who cares about the meaning of terms "by default", its kind of disengenuous to try to engineer very vague terms for ones own purpose anyway ;)
02:52:57 <capisce> although Haskell is kind of multi-paradigm too
02:53:03 <capisce> lets you program imperatively if you want
02:53:08 <EvanR> s/very vague/very generic
02:53:34 <paldepind> Yes. That's a good take away.
02:54:17 <paldepind> But it would be nice if the terms had a precise by default meaning.
02:55:06 <EvanR> i hate it when you try to get into a discussion and someone yells out "no! thats not what that means at all!"
02:55:31 <EvanR> like theres only one meaning
02:58:03 <capisce> https://blogs.janestreet.com/breaking-down-frp/
02:58:08 <capisce> "In all of this I'm basically going to talk only about discrete FRP. A lot of the people involved in FRP think of continuous-time semantics as really important, but that's not the focus here."
02:58:13 <capisce> "(I am curious, however, if anyone can explain why people think continuous time semantics are important when writing programs for a largely discrete computer.)"
02:58:16 <capisce> lol
02:58:31 <EvanR> yeah
02:58:38 <lf94_> To feel important
02:59:16 <EvanR> for better composability
02:59:54 <lf94_> How do continuous time semantics give better composability over discrete semantics?
03:00:05 <capisce> I'm also curious about that
03:00:20 <paldepind> Continuous time does make sense. It doesn't matter whether or not computers are discrete. It's a horrible argument. What matters is whether or not the thing you're trying to model is discrete.
03:01:02 <EvanR> to me 3d graphics is a great situation where of course its all discrete but of course youd rather it wasnt
03:01:17 <paldepind> SVG graphics is a perfect example. Shapes are not a grid of pixels. Modeling them as continuous shapes is a better representation that bitmap graphics.
03:01:58 <capisce> yeah
03:02:15 <paldepind> Time is not discrete. Motion is not discrete. So using discrete semantics is mixing up machine artifacts into your semantic model.
03:02:45 <capisce> true, for animations you probably want a continuous model
03:02:55 <lf94_> http://conal.net/fran/tutorial.htm
03:02:56 <capisce> although... animations are still typically frame based
03:03:05 <lf94_> This is a really good example of this conversation
03:03:09 <capisce> but they can be sped up and slowed down
03:03:17 <lf94_> the author has continuous animations
03:03:23 <capisce> so at some level a continuous representation makes sense
03:03:26 <EvanR> a texture on a triangle is running a shader at various sampled points in the triangular region, you dont want to have to modify that shader if you decided you want to show the triangle 5 pixels to the left, rotated, or transformed somehow
03:03:28 <lf94_> then moves onto discrete/continuous animations
03:03:41 <EvanR> you want to just use it
03:03:46 <EvanR> composed with the transformation
03:04:01 <EvanR> and you can compose many transformations before getting to the end of the rendering process
03:04:31 <EvanR> capisce: well youre talking about implementation now, which is usually not what FRP is talking about
03:04:40 <paldepind> capisce, only in the very end are they frame based. Just like a functional program ends up as something imperative in the end. But we shouldn't have to think about animations as frames just as we shouldn't have to think of programs as a sequence of machine instructions.
03:04:41 <EvanR> its talking about the denotational semantics
03:04:58 <exio4> what's the point of haskell if it is all registers in the end?
03:05:20 <exio4> what's the point of functions if it is all jumps in the end?
03:05:39 <capisce> ...
03:05:40 <EvanR> animations as frames is really bad
03:05:50 <EvanR> because some devices have different refresh rates
03:05:56 <lf94_> capisce, seriously look at the link I pasted.
03:06:05 <lf94_> It is an excellent look into this.
03:06:07 <capisce> yes, I intend to
03:06:08 <EvanR> you dont want an animation to have to resample, interpolate, or run at the wrong speed
03:06:09 <lf94_> And easy to understand
03:06:32 <exio4> "programming is more about the middle than the end"
03:06:34 <lpaste> bad_alloc pasted ‚ÄúHelp?: Data Constructor not found‚Äù at http://lpaste.net/143759
03:06:38 <capisce> I'm not aware of any game or animation system that really does "animations as frames" though
03:06:39 <exio4> (if I remember his words correctly :P)
03:06:43 <bad_alloc> Hi I'm trying to reimplement a paper describing so called finger trees. The authors define an operator (:¥), however I always get the error "Not in scope: data constructor `:¥'". How do I fix this? Code here: http://lpaste.net/143759
03:06:50 <EvanR> capisce: well video players
03:06:59 <lf94_> Uh, a lot of 3D games?
03:07:01 <capisce> well, games _do_ have keyframed animations
03:07:07 <lf94_> any game actually
03:07:19 <EvanR> capisce: right game programming often does all this, but in very complex language
03:07:20 <capisce> and the animations themselves are often defined as interpolations between those keyframes
03:07:28 <EvanR> its very implementation oriented
03:07:33 <lf94_> does logic, moves things around, paints to buffer, puts buffer to screen
03:07:34 <capisce> yeah
03:07:49 <capisce> lf94_: sure, but the animation logic is often frame rate independent
03:07:59 <capisce> unless you're talking about old Amiga and C64 games
03:07:59 <lf94_> Not always true.
03:08:03 <capisce> where the frame rate was known
03:08:12 <lf94_> Yeah, even the Nintendo 64 had games that were frame rate dependent.
03:08:15 <capisce> yep
03:08:18 <EvanR> capisce: you can also use that point to go into the question of correctness, is the game going to show the right thing if run at a different speed?
03:08:33 <EvanR> what is the right thing anyway?
03:08:34 <capisce> I'm thinking about modern games for iOS, Android, PS4, PC, etc
03:08:40 <EvanR> you need semantics to answer the question
03:08:53 <capisce> yeah, the semantics are implicit usually
03:08:56 <capisce> not explicit
03:09:06 <EvanR> in game programming, theres usually no attention paid to any of this
03:09:16 <capisce> well, they pay attention to it
03:09:24 <capisce> I remember in Quake 3 you could jump higher at certain frame rates
03:09:36 <EvanR> you can say its not done in a very principled way
03:09:37 <capisce> so all the players would lower the graphics settings to run at that frame rate
03:09:49 <capisce> that's right
03:10:11 <capisce> actually, these days it's more common to run physics (i.e. animations) at a fixed frame rate
03:10:17 <capisce> and then interpolate when rendering
03:10:20 <capisce> between physics frames
03:10:34 <capisce> so in a way they are doing it in a principled way
03:10:38 <capisce> it matters a lot for gameplay quality
03:10:54 <EvanR> the holy grail would be to define your game in a way that makes sense in some model, and then deal with issues like interpolation or whatever clever strategy in the implementation only
03:11:00 <capisce> running physics at different speeds depending on the screen refresh rate is not a good idea
03:11:14 <EvanR> but often game programming boils down to mix all of this up at all levels
03:11:32 <capisce> often because of performance considerations
03:11:44 <EvanR> its some performance, and some culture
03:12:32 <delYsid> How do I make a simple "newtype Parallel a = Parallel [a]" traversable?
03:12:54 <EvanR> another potential benefit of using the right language to talk about the game (not the interpolation strategies) is that now the implementation could have more information to optimize with
03:13:11 <EvanR> instead of requiring the game programmer to come up with ad hoc optimizations
03:14:44 <EvanR> if you dont write all your code as literal assembly language, then a compiler is free to rearrange code in a way that produces the same results, since the source language elements have a meaning the compiler can deal with
03:14:45 <capisce> do you know of any paper or text that explores these kind of optimizations for FRP?
03:14:54 <capisce> indeed
03:15:17 <capisce> but it depends on the concept of a sufficiently smart compiler
03:15:18 <EvanR> well, the reactive paper mentions some ideas
03:15:35 <EvanR> it depends crucially on a sufficiently expressive set of primitives
03:15:59 <capisce> and not having abstractions that are too leaky
03:16:14 <EvanR> i.e. having proper abstractions
03:16:22 <capisce> that's a very hard problem
03:16:32 <EvanR> apparently its hard for game programming
03:16:50 <EvanR> but these ideas already have many successes elsewhere
03:17:33 <bad_alloc> Resend: Hi I'm trying to reimplement finger trees. In the original paper the authors define an operator (:¥), however I always get the error "Not in scope: data constructor `:¥'". How do I fix this? Code here: http://lpaste.net/143759
03:17:50 <capisce> yeah, declarative vs imperative, describe the what instead of the how
03:18:01 <capisce> gives a lot more flexibility for optimization
03:18:05 <EvanR> capisce: example involving optimizing circuit generation http://begriffs.com/posts/2015-06-28-haskell-to-hardware.html
03:18:40 <capisce> I'm very interested in that topic
03:19:01 <Gurkenglas> bad_alloc, have you tried using another character than ¥? That seems like a straightforward thing that could cause your problem.
03:19:46 <capisce> EvanR: is there a paper related to that talk? instead of just slides
03:19:59 <EvanR> https://github.com/conal/lambda-ccc
03:20:16 <capisce> they should have linked to that :p
03:20:20 <capisce> though maybe the slides do
03:20:25 <Gurkenglas> Although it could be that operators starting with : are data constructors, to be used like data Pair a = a :, a
03:20:29 <EvanR> dunno if the talk predates the repo
03:20:51 <Gurkenglas> Just try other character configurations. Or look up some manual about infix operator syntax.
03:20:59 <capisce> I don't like the tendency to have things presented only as talks and not as articles
03:21:36 <capisce> https://github.com/conal/lambda-ccc/blob/master/doc/notes.md has a lot of links though
03:22:41 <bad_alloc> Gurkenglas: Indeed, using *** instead works. Any combination with : doesn't.
03:22:51 <EvanR> capisce: funding ran out for that project, so i guess they didnt make it to a paper
03:22:56 <bad_alloc> Gurkenglas: Thanks for that hint I'll look it up :)
03:23:21 <capisce> EvanR: funding :(
03:34:47 <gaetannn> !ciao
03:37:23 <julianleviston> I have a function which uses Snap, and in particular, uses the renderWithSplices function, whose type is renderWithSplices :: HasHeist b => ByteString -> Splices (SnapletISplice b) -> Handler b v () as specified here: http://haddock.stackage.org/lts-3.6/snap-0.14.0.6/Snap-Snaplet-Heist.html#v:renderWithSplices 
03:37:57 <julianleviston> However, as far as I can tell, the type Splices is an internal type‚Ä¶ and I want to pull the third argument out into its own function‚Ä¶ what type signature should I give it?
03:38:33 <julianleviston> my b type is GetContented
03:39:05 <julianleviston> So I thought I could do this, but GHC complains that it doesn‚Äôt know what Splices is‚Ä¶ x :: Splices (SnapletISplice GetContented)
03:40:24 * hackagebot gogol-core 0.0.1 - Core data types and functionality for Gogol libraries.  https://hackage.haskell.org/package/gogol-core-0.0.1 (BrendanHay)
03:40:26 * hackagebot gogol 0.0.1 - Comprehensive Google Services SDK.  https://hackage.haskell.org/package/gogol-0.0.1 (BrendanHay)
03:40:28 * hackagebot gogol-siteverification 0.0.1 - Google Site Verification SDK.  https://hackage.haskell.org/package/gogol-siteverification-0.0.1 (BrendanHay)
03:40:30 * hackagebot gogol-storage 0.0.1 - Google Cloud Storage JSON SDK.  https://hackage.haskell.org/package/gogol-storage-0.0.1 (BrendanHay)
03:40:32 * hackagebot gogol-adexchange-buyer 0.0.1 - Google Ad Exchange Buyer SDK.  https://hackage.haskell.org/package/gogol-adexchange-buyer-0.0.1 (BrendanHay)
03:41:42 <julianleviston> I could just import Heist.Internal.Types and use it directly from there, but there‚Äôs a warning that says ‚Äú If you use them, no complaining when your code breaks.‚Äù
03:42:41 <julianleviston> I guess I‚Äôll just use the type the Splices type alias refers to. Seems a bit‚Ä¶ ugly.
03:43:03 <capisce> EvanR: just found this thread, interesting conversation: http://lambda-the-ultimate.org/node/4900#comment-88717
03:44:19 <capisce> "The performance cost of this kind of approach is that (a) everything is clocked to the rate of the most quickly-changing datasource, and (b) there can be a lot of "no-change" events (Waits in my example)."
03:44:29 <capisce> "However, the performance advantage of this approach is that (a) there is generally a lot less buffering you have to do than in more asynchronous strategies, and (b) if the UI is changing very quickly you don't need to waste effort maintaining a DOM/scene-graph/etc."
03:44:51 <capisce> hmm
03:45:06 <capisce> "I and my collaborators do have a new draft (which I haven't blogged about yet, but will soon) about how to understand asynchronous callback-y APIs type-theoretically, but the big open question is how to integrate the two styles into a single programming model."
03:45:13 <capisce> seems like some pieces are still missing
03:45:34 <capisce> "(Eg, a webpage might have a subwindow playing a videogame in it, where you want most of the page to be retained mode but the game to be immediate mode.) This is needed because each style is expensive when the other one is cheap."
03:45:34 * hackagebot gogol-adexchange-seller 0.0.1 - Google Ad Exchange Seller SDK.  https://hackage.haskell.org/package/gogol-adexchange-seller-0.0.1 (BrendanHay)
03:45:36 * hackagebot gogol-admin-datatransfer 0.0.1 - Google Admin Data Transfer SDK.  https://hackage.haskell.org/package/gogol-admin-datatransfer-0.0.1 (BrendanHay)
03:45:38 * hackagebot gogol-admin-directory 0.0.1 - Google Admin Directory SDK.  https://hackage.haskell.org/package/gogol-admin-directory-0.0.1 (BrendanHay)
03:45:42 * hackagebot gogol-adsense-host 0.0.1 - Google AdSense Host SDK.  https://hackage.haskell.org/package/gogol-adsense-host-0.0.1 (BrendanHay)
03:45:44 * hackagebot gogol-apps-tasks 0.0.1 - Google Tasks SDK.  https://hackage.haskell.org/package/gogol-apps-tasks-0.0.1 (BrendanHay)
03:45:46 * hackagebot gogol-tagmanager 0.0.1 - Google Tag Manager SDK.  https://hackage.haskell.org/package/gogol-tagmanager-0.0.1 (BrendanHay)
03:45:48 * hackagebot gogol-deploymentmanager 0.0.1 - Google Cloud Deployment Manager SDK.  https://hackage.haskell.org/package/gogol-deploymentmanager-0.0.1 (BrendanHay)
03:45:50 * hackagebot gogol-appengine 0.0.1 - Google App Engine Admin SDK.  https://hackage.haskell.org/package/gogol-appengine-0.0.1 (BrendanHay)
03:46:10 <capisce> Elm etc suffer from these performance issues I think
03:46:51 <EvanR> interesting if they have performance issues even while dismissing proper semantics ;)
03:47:21 <capisce> how so? :)
03:48:06 <EvanR> most of the web-oriented "rp"s began with an implementation in mind, explain it in terms of that implementation, then slapped frp on it
03:48:15 <EvanR> presumably for efficiency
03:48:35 <capisce> right
03:49:21 <EvanR> so after all that, if you have performance issues, why is it right to blame frp
03:49:29 <capisce> "everything is clocked to the rate of the most quickly-changing datasource"
03:49:36 <capisce> this doesn't sound very good
03:50:52 * hackagebot gogol-bigquery 0.0.1 - Google BigQuery SDK.  https://hackage.haskell.org/package/gogol-bigquery-0.0.1 (BrendanHay)
03:51:16 <capisce> if you have a clock that's expensive to draw that updates every second, and you also have some other component that updates based on the mouse position, then moving the mouse will cause the clock to be recomputed as well
03:51:44 <EvanR> i dont really understand their implementation
03:51:52 <julianleviston> capisce: why isn‚Äôt it clocked to requestAnimationFrame ?
03:52:07 <capisce> EvanR: "When one event fires you have to add a Wait to all events that did not fire simultaneously, and all consumers of those events have to process that Wait."
03:52:19 <capisce> julianleviston: why should a clock that updates every second be clocked to requestAnimationFrame? :)
03:52:31 <EvanR> capisce: well.. that sounds like events are done wrong too
03:52:56 <capisce> EvanR: yeah, but that's the model Elm etc use
03:53:06 <julianleviston> capisce: I only know from clojurescript‚Äôs Om & other clojurescript frameworks that I‚Äôve used that if you don‚Äôt, you end up with performance issues.
03:53:13 <capisce> EvanR: and which this guy is talking about: http://lambda-the-ultimate.org/node/4900#comment-78969
03:53:22 <capisce> julianleviston: indeed
03:53:45 <julianleviston> capisce: same reason why iOS uses a separate high frequency external synchronising event rather than a ‚Äúwild west‚Äù approach to updates.
03:53:50 <capisce> you shouldn't recompute things that are only needed once per frame more than one time per frame ;)
03:54:07 <capisce> julianleviston: oh, how so?
03:54:21 <julianleviston> capisce: I‚Äôm talking about refreshes, not updates. Updates should happen in a separate space.
03:54:24 <capisce> you mean an event similar to requestAnimationFrame?
03:54:27 <EvanR> capisce: well, dont get too far too fast... theres some cases where a lazy strategy will be bad
03:54:29 <julianleviston> capisce: yes.
03:54:36 <capisce> yes, that makes a lot of sense
03:55:19 <EvanR> capisce: for example, the result of an integral might be needed so seldom that when its finally needed it has to do a bunch of work to compute, and a better idea is to compute it incrementally through time
03:55:27 <julianleviston> I‚Äôve seen the practical effects of this‚Ä¶ you wouldn‚Äôt think it‚Äôd matter, but it‚Äôs the difference between smooth updates and jerky ones. I think game engines tend to use this strategy, too‚Ä¶ and of course, the graphics cards we use use that strategy, too‚Ä¶ shadow ram, etc.
03:55:37 <capisce> EvanR: sure
03:55:52 <EvanR> capisce: how often you do that really shouldnt matter though
03:56:04 <capisce> it's an implementation detail
03:56:25 <EvanR> and youd hope that the programmer doesnt have to implement this 
03:56:42 <capisce> ideally, though that requires the sufficiently smart compiler again :/
03:56:56 <EvanR> not necessarily
03:56:57 <julianleviston> This is, I think, one of the ‚Äúcool‚Äù things about ReactJS.
03:57:20 <capisce> well, or the sufficiently smart library
03:57:29 <EvanR> a sufficiently working frp ;)
03:57:52 <capisce> at least something seems to be lacking in the model of frp that I just linked to
03:58:01 <capisce> in the semantics themselves
03:58:06 <EvanR> do they even have a model?
03:58:18 <EvanR> besides "how the implemntation works"
03:58:34 <EvanR> (operational semantics)
03:59:22 <capisce> I guess I need to read the papers linked to in http://lambda-the-ultimate.org/node/4900#comment-78969
04:00:00 <capisce> they say they have a model, and it's synchronous
04:00:23 <capisce> so it's probably not an ideal model for all use cases then
04:00:47 <EvanR> capisce: comments on lambda the ultimate are hit or miss. the people that are very vocal often are long winded and may or may not be making any sense
04:01:00 <capisce> sure
04:01:07 <capisce> but this is the paper author
04:01:15 <EvanR> theres one guy with a pet competitor to frp
04:01:23 <EvanR> called rdp
04:01:27 <capisce> I think there are many such guys
04:01:33 <EvanR> i so far failed to understand it
04:01:44 <capisce> I need to study the topic more deeply to be able to see if my fears are justified
04:02:06 <EvanR> have you read the fran paper and the reactive paper
04:02:06 <capisce> EvanR: reactive demand programming?
04:02:12 <julianleviston> capisce: what are your fears?
04:02:31 * hackagebot gogol-android-publisher 0.0.1 - Google Play Developer SDK.  https://hackage.haskell.org/package/gogol-android-publisher-0.0.1 (BrendanHay)
04:02:33 * hackagebot gogol-doubleclick-bids 0.0.1 - Google DoubleClick Bid Manager SDK.  https://hackage.haskell.org/package/gogol-doubleclick-bids-0.0.1 (BrendanHay)
04:02:35 * hackagebot gogol-play-moviespartner 0.0.1 - Google Play Movies Partner SDK.  https://hackage.haskell.org/package/gogol-play-moviespartner-0.0.1 (BrendanHay)
04:02:37 * hackagebot gogol-identity-toolkit 0.0.1 - Google Identity Toolkit SDK.  https://hackage.haskell.org/package/gogol-identity-toolkit-0.0.1 (BrendanHay)
04:02:39 * hackagebot gogol-plus 0.0.1 - Google + SDK.  https://hackage.haskell.org/package/gogol-plus-0.0.1 (BrendanHay)
04:03:13 <capisce> julianleviston: that it'll be hard to achieve the performance of more ad hoc solutions
04:04:03 <julianleviston> capisce: in what context? browser or other?
04:04:22 <capisce> browser, desktop, ios, android, whatever
04:04:30 <julianleviston> capisce: I think the context matters.
04:04:33 <capisce> it's all the same
04:04:35 <EvanR> toolkit GUIs arent usually trying to get really high performance for their GUI, just the code they control
04:04:35 <capisce> :)
04:04:48 <capisce> EvanR: how do you mean?
04:05:04 <capisce> toolkit GUIs usually try to reduce the cost of abstraction
04:05:06 <julianleviston> capisce: in the browser, I think it‚Äôs pretty well proven that it‚Äôs better performance to use FRP‚Ä¶ 
04:05:18 <capisce> by providing the right abstractions
04:05:33 <srhb> julianleviston: [citation needed]
04:05:49 <julianleviston> srhb: practice - facebook. no citations available.
04:05:50 <EvanR> toolkit GUIs are just the best that could be done with what they had when they were invented, which was imperative C code or an attempt at OO GUIs
04:05:56 <julianleviston> srhb: sorry for misusing the word ‚Äúproven"
04:06:06 <capisce> and there's a tradeoff between giving the user more control or limiting what the user can do in order to be able to make more aggressive optimizations
04:06:08 <EvanR> capisce: theres very little abstraction in toolkits
04:06:21 <srhb> julianleviston: I wasn't trying to be a pedant, I've just never heard that argument before anywhere, and I've looked into FRP quite a lot.
04:06:26 <paldepind> If you do FRP in the browser you run into the problem that JS does not have weak pointers.
04:06:28 <capisce> EvanR: how so? have you looked at QtQuick 2 and QML for example?
04:06:44 <capisce> QML is one variant of reactive programming
04:06:47 <EvanR> no
04:06:48 <julianleviston> srhb: I guess it depends which FRP we‚Äôre talking about.
04:06:57 <EvanR> i was thinking of Qt, windows, cocoa
04:07:08 <paldepind> QML is part of Qt.
04:07:10 <capisce> sure, those are all very old and imperative
04:07:21 <julianleviston> srhb: I thought facebook pretty much showed that for large scale apps, FRP through reactjs kills ad hoc development
04:07:30 <capisce> yeah, QML and QtQuick 2 are supposed to solve many of the old performance issues with imperative UIs
04:07:35 <paldepind> julianleviston, React is not FRP.
04:07:41 * hackagebot gogol-dataflow 0.0.1 - Google Dataflow SDK.  https://hackage.haskell.org/package/gogol-dataflow-0.0.1 (BrendanHay)
04:07:43 * hackagebot gogol-freebasesearch 0.0.1 - Google Freebase Search SDK.  https://hackage.haskell.org/package/gogol-freebasesearch-0.0.1 (BrendanHay)
04:07:45 * hackagebot gogol-drive 0.0.1 - Google Drive SDK.  https://hackage.haskell.org/package/gogol-drive-0.0.1 (BrendanHay)
04:07:45 <paldepind> And React is pretty slow.
04:07:47 * hackagebot gogol-fitness 0.0.1 - Google Fitness SDK.  https://hackage.haskell.org/package/gogol-fitness-0.0.1 (BrendanHay)
04:07:49 * hackagebot gogol-datastore 0.0.1 - Google Cloud Datastore SDK.  https://hackage.haskell.org/package/gogol-datastore-0.0.1 (BrendanHay)
04:07:52 <capisce> where each widget was passed a QPainter and told to draw itself
04:07:55 <srhb> julianleviston: I don't think React has anything to do with FRP.
04:08:05 <julianleviston> ok
04:08:07 <julianleviston> i‚Äôll be quiet then.
04:08:18 <capisce> now instead, the idea is to build the UI declaratively out of components
04:08:22 <EvanR> capisce: i wasnt even thinking of graphics, which is pretty fast
04:08:34 <EvanR> just the programming of the GUI
04:08:48 <srhb> julianleviston: Just curious. :-) I would have loved if it were true.
04:08:48 <capisce> the graphics performance of traditional UIs on mobile has been a bit lacking
04:09:03 <capisce> especially when wanting to do animations etc
04:09:05 <EvanR> are you thinking about graphics performance problems on frp?
04:09:09 <capisce> no
04:09:13 <capisce> well
04:09:15 <EvanR> ok ;)
04:09:18 <capisce> uhm
04:09:31 <capisce> that too
04:09:37 <paldepind> capisce, have you seen Reflex? It aims to be high performance FRP.
04:09:46 <julianleviston> srhb: with react you hook a bunch of components up, and the data propigates through them in a flow‚Ä¶ seems similar to a signal graph to me.
04:09:48 <EvanR> thats not really a problem, for 2d toolkit like guis anyaw
04:09:53 <capisce> paldepind: seen it, haven't looked too closely into it yet
04:10:02 <capisce> paldepind: but yeah, curious to see how their implementation differs from Elm
04:10:11 <julianleviston> srhb: granted it‚Äôs only event driven, not signal driven, but‚Ä¶ yep.
04:10:17 <capisce> EvanR: you'd be surprised :)
04:10:57 <EvanR> ive mired in toolkit programming, and i implemented a UI with frp that wasnt slow
04:10:58 <capisce> 2D UIs still struggle to get a stutter free experience on mobile
04:11:09 <paldepind> julianleviston, there is nothing similar to a behavior/signal. It's a form of immediate mode GUI where your view is a function of you state.
04:11:16 <capisce> define "wasn't slow"
04:11:23 <paldepind> capisce, it's much more powerful than Elm.
04:11:24 <capisce> running at screen refresh rate without any stutters?
04:11:28 <EvanR> yeah
04:11:33 <paldepind> FRP in Elm is a bit lame.
04:11:44 <paldepind> And the Elm architecture does not really use FRP.
04:11:45 <EvanR> but also, you want stuttering when the processor isnt fast enough
04:11:46 <capisce> EvanR: on which platform?
04:11:48 <EvanR> not slowdowns
04:11:53 <EvanR> Mac
04:12:08 <capisce> sure, on desktop it's pretty achievable
04:12:17 <capisce> the challenge tends to be mobile and embedded
04:12:21 <julianleviston> paldepind: I don‚Äôt see how it‚Äôs that different, really.
04:12:44 <EvanR> capisce: well i didnt do anything special in the graphics, just used the OS graphics api, fast
04:12:51 <EvanR> why would that not work on mobile?
04:12:51 <capisce> yes, if you can't keep up then stuttering is certainly better than the alternative of falling behind
04:12:51 * hackagebot gogol-translate 0.0.1 - Google Translate SDK.  https://hackage.haskell.org/package/gogol-translate-0.0.1 (BrendanHay)
04:12:53 * hackagebot gogol-webmaster-tools 0.0.1 - Google Webmaster Tools SDK.  https://hackage.haskell.org/package/gogol-webmaster-tools-0.0.1 (BrendanHay)
04:12:54 <julianleviston> paldepind: mind you, I never used the stateful reactjs. I only used a clojurescript version that used non-mutating stateless components.
04:12:55 * hackagebot gogol-apps-licensing 0.0.1 - Google Enterprise License Manager SDK.  https://hackage.haskell.org/package/gogol-apps-licensing-0.0.1 (BrendanHay)
04:12:57 * hackagebot gogol-replicapool-updater 0.0.1 - Google Compute Engine Instance Group Updater SDK.  https://hackage.haskell.org/package/gogol-replicapool-updater-0.0.1 (BrendanHay)
04:12:59 * hackagebot gogol-appstate 0.0.1 - Google App State SDK.  https://hackage.haskell.org/package/gogol-appstate-0.0.1 (BrendanHay)
04:13:16 <paldepind> julianleviston, you don't have a first class representation for a value that can change over time. That is a pretty fundamental difference IMO. React is just a virtual DOM library.
04:13:24 <secwang> hi all ,I have a question. map a function to a list, how to force all function evalutation.  I try with L.last $ map function [Text] , haskell will only eval the last one element. 
04:13:58 <capisce> EvanR: depends _how_ you use the OS graphics api I guess
04:14:03 <exio4> secwang: you could use deepseq for that
04:14:09 <julianleviston> paldepind:  except that every time you change a piece of data it propigates through the component tree‚Ä¶ and if you only accrete state, then it seems pretty similar to a first class representation of a vlaue that changes over time...
04:14:13 <secwang> the previous function only receive a not [a] 
04:14:42 <secwang> deeqseq , I'll see that. Thank you.
04:14:45 <EvanR> capisce: the strategy was, idle until an event occurs, then re-render anything whose visualization would have changed
04:15:13 <paldepind> julianleviston, it's a big state machine and you're doing all the propagation yourself.
04:15:13 <EvanR> though i can see that youd need to be slightly more complex with a scrolling app
04:15:21 <capisce> EvanR: sounds sensible, though the devil is in the details
04:15:25 <julianleviston> paldepind:  sure. ok then.
04:15:25 <capisce> :)
04:15:55 <EvanR> capisce: right, my implementation handled it. and thats the rub, you cant really blame frp for a particular implementations lack of imagination
04:16:13 <capisce> what's your implementation of frp btw?
04:16:21 <julianleviston> paldepind: http://swannodette.github.io/todomvc/labs/architecture-examples/om-undo/index.html
04:16:30 <EvanR> for whatever situation, an implementation from somewhere else might be inappropriate
04:16:34 <julianleviston> paldepind: I‚Äôm not entirely sure how you‚Äôre doing all the propigation yourself.
04:16:44 <EvanR> capisce: not really ready for public consumption ;)
04:17:05 <capisce> EvanR: alright, are you planning for that? :)
04:17:25 <julianleviston> paldepind: but you‚Äôre right it‚Äôs not what we call FRP.
04:17:28 <EvanR> theres a process running in my brain about it
04:17:33 <paldepind> julianleviston, try taking a look at Reflex and Reflex DOM. It's quite different from what you do in React. Since FRP provides a form of observable you don't need virtual DOM. In some ways the approach has more to do with Knockout than with React.
04:17:45 <julianleviston> paldepind: yes. I know Reflex.
04:17:46 <capisce> EvanR: btw, frp is such a loaded term now that it's hard to know what you're talking about
04:17:56 <julianleviston> paldepind: well‚Ä¶ I know about it. I‚Äôm familiar with it.
04:18:01 <EvanR> capisce: yeah im talking about original frp
04:18:01 * hackagebot gogol-monitoring 0.0.1 - Google Cloud Monitoring SDK.  https://hackage.haskell.org/package/gogol-monitoring-0.0.1 (BrendanHay)
04:18:03 * hackagebot gogol-games-management 0.0.1 - Google Play Game Services Management SDK.  https://hackage.haskell.org/package/gogol-games-management-0.0.1 (BrendanHay)
04:18:05 * hackagebot gogol-fonts 0.0.1 - Google Fonts Developer SDK.  https://hackage.haskell.org/package/gogol-fonts-0.0.1 (BrendanHay)
04:18:07 * hackagebot gogol-admin-reports 0.0.1 - Google Admin Reports SDK.  https://hackage.haskell.org/package/gogol-admin-reports-0.0.1 (BrendanHay)
04:18:09 * hackagebot gogol-qpxexpress 0.0.1 - Google QPX Express SDK.  https://hackage.haskell.org/package/gogol-qpxexpress-0.0.1 (BrendanHay)
04:18:11 <capisce> EvanR: alright, good
04:18:32 <capisce> EvanR: indeed, you can't blame original frp for poor implementations, you have to judge it based on the best implementations :)
04:18:45 <EvanR> i dont see how that makes sense
04:18:51 <capisce> hmm?
04:18:55 <paldepind> julianleviston, I don't know Om. I though you where talking about React + flux.
04:19:03 <julianleviston> paldepind: no.
04:19:20 <EvanR> capisce: proof by lack of imagination?
04:19:31 <julianleviston> paldepind: I kinda mentioned it was clojurescript over React. I actually used a different one than Om. Still uses the virtual DOM tho‚Ä¶ 
04:19:42 <EvanR> capisce: thing point of abstractions is to be independent of the implementation
04:19:45 <capisce> EvanR: so you should imagine the best implementation?
04:20:10 <EvanR> yes
04:20:11 <capisce> EvanR: yes, but an abstraction can be very elegant but hard or impossible to implement to match the performance of other abstractions
04:20:19 <julianleviston> paldepind: the virtual DOM is only useful to stop too much DOM mutation (as the DOM mutation is by far the slowest part of front end web apps)
04:20:38 <EvanR> the best is identified as the abstraction itself
04:20:49 <capisce> then how do you judge performance?
04:20:53 <capisce> relative to a different abstraction
04:21:14 <capisce> or relative to an ad hoc implementation
04:21:44 <EvanR> im not sure it makes sense to compare two different abstractions with two different implementations?
04:21:54 <EvanR> like C vs haskell
04:22:10 <EvanR> sounds complex
04:22:11 <capisce> if you're writing a game and concerned with performance I guess it does?
04:22:35 <EvanR> if youre writing a game, youre not concerned with abstraction, youre concerned with the deadline (and high enough performance) 
04:22:43 <EvanR> unfortunately
04:22:57 <paldepind> julianleviston, indeed. But with FRP you have observable values. You can do precise modifications to the DOM when the observables push changes.
04:22:58 <julianleviston> depends on the game.
04:23:11 * hackagebot gogol-spectrum 0.0.1 - Google Spectrum Database SDK.  https://hackage.haskell.org/package/gogol-spectrum-0.0.1 (BrendanHay)
04:23:12 <EvanR> proper abstraction ;)
04:23:13 * hackagebot gogol-urlshortener 0.0.1 - Google URL Shortener SDK.  https://hackage.haskell.org/package/gogol-urlshortener-0.0.1 (BrendanHay)
04:23:15 * hackagebot gogol-apps-reseller 0.0.1 - Google Enterprise Apps Reseller SDK.  https://hackage.haskell.org/package/gogol-apps-reseller-0.0.1 (BrendanHay)
04:23:17 * hackagebot gogol-shopping-content 0.0.1 - Google Content API for Shopping SDK.  https://hackage.haskell.org/package/gogol-shopping-content-0.0.1 (BrendanHay)
04:23:19 * hackagebot gogol-youtube 0.0.1 - Google YouTube Data SDK.  https://hackage.haskell.org/package/gogol-youtube-0.0.1 (BrendanHay)
04:23:20 <julianleviston> paldepind: yeah, I completely agree that it‚Äôs not what you mean by ‚ÄúFRP".
04:23:21 <capisce> EvanR: I'm unconvinced :)
04:23:56 <julianleviston> paldepind: and I guess my definition of FRP is slowly changing more toward yours, too.
04:24:03 <EvanR> scene graphs, event subscribers, and oop dont really amount to abstraction
04:24:25 <paldepind> My point is that FRP can make virtual DOM unnecessary.
04:25:04 <julianleviston> paldepind: I‚Äôm not entirely sure how, but I‚Äôll take your word on that.
04:25:13 <capisce> EvanR: have you looked at Elm?
04:25:20 <EvanR> a little
04:25:31 <capisce> and I'd suggest looking at QML too
04:25:32 <EvanR> i didnt see an explanation of the semantics
04:25:49 <capisce> you can read the thesis about Elm I guess
04:25:49 <julianleviston> EvanR: did you read the ‚ÄúElm Architecture"?
04:25:54 <EvanR> no
04:26:05 <julianleviston> EvanR:  oh, you should read that. It‚Äôs only a page or two.
04:26:07 <EvanR> is that an explanation of the implementation?
04:26:09 <paldepind> capisce, I don't think there's precise semantics in the thesis.
04:26:20 <julianleviston> https://github.com/evancz/elm-architecture-tutorial/
04:27:39 <julianleviston> EvanR: no, it‚Äôs an explanation of how to implement Elm programs, pretty much.
04:27:46 <capisce> if the semantics aren't explicit then they're implicit :)
04:28:05 <zomg> Didn't elm start using virtual-dom recently or do I remember wrong?
04:28:06 <EvanR> capisce: or non existent
04:28:13 <zomg> I recall someone mentioned that they did and it brought big perf improvements
04:28:15 <paldepind> zomg, yes indeed.
04:28:20 <capisce> EvanR: that's a stretch
04:28:21 * hackagebot gogol-pubsub 0.0.1 - Google Cloud Pub/Sub SDK.  https://hackage.haskell.org/package/gogol-pubsub-0.0.1 (BrendanHay)
04:28:23 * hackagebot gogol-autoscaler 0.0.1 - Google Compute Engine Autoscaler SDK.  https://hackage.haskell.org/package/gogol-autoscaler-0.0.1 (BrendanHay)
04:28:25 * hackagebot gogol-latencytest 0.0.1 - Google Cloud Network Performance Monitoring SDK.  https://hackage.haskell.org/package/gogol-latencytest-0.0.1 (BrendanHay)
04:28:27 * hackagebot gogol-sqladmin 0.0.1 - Google Cloud SQL Administration SDK.  https://hackage.haskell.org/package/gogol-sqladmin-0.0.1 (BrendanHay)
04:28:29 * hackagebot gogol-games 0.0.1 - Google Play Game Services SDK.  https://hackage.haskell.org/package/gogol-games-0.0.1 (BrendanHay)
04:28:44 <EvanR> capisce: you can always explain what the implementation does, but there doesnt have to be any meaning to it
04:29:26 <EvanR> it might turn out that you cant come up with any other precise meaning
04:29:43 <capisce> yes, then the implementation defines the semantics
04:29:57 <EvanR> youll end up with operational semantics
04:30:01 <capisce> right
04:30:07 <EvanR> but programs wont have any semantics of their own
04:30:11 <Yuras> Hackage is very slow today. Is it only for me?
04:30:27 <EvanR> except maybe literally the program text itself
04:31:10 <capisce> why does it seem like most reactive programming libraries for Haskell etc _don't_ use the original FRP semantics?
04:31:30 <julianleviston> capisce: reactive banana does, doesn‚Äôt it?
04:31:48 <EvanR> same reason js etc doesnt
04:32:08 <julianleviston> EvanR: lack of understanding? 
04:32:52 <EvanR> understand in terms of final implementation
04:33:31 * hackagebot gogol-replicapool 0.0.1 - Google Compute Engine Instance Group Manager SDK.  https://hackage.haskell.org/package/gogol-replicapool-0.0.1 (BrendanHay)
04:33:33 * hackagebot gogol-oauth2 0.0.1 - Google OAuth2 SDK.  https://hackage.haskell.org/package/gogol-oauth2-0.0.1 (BrendanHay)
04:33:36 * hackagebot gogol-dns 0.0.1 - Google Cloud DNS SDK.  https://hackage.haskell.org/package/gogol-dns-0.0.1 (BrendanHay)
04:33:37 * hackagebot gogol-billing 0.0.1 - Google Cloud Billing SDK.  https://hackage.haskell.org/package/gogol-billing-0.0.1 (BrendanHay)
04:33:39 * hackagebot gogol-mirror 0.0.1 - Google Mirror SDK.  https://hackage.haskell.org/package/gogol-mirror-0.0.1 (BrendanHay)
04:33:45 <phaazon> hey, I just unregistered all the version of a dependency; explicitely installed the one I wanted to, and then cabal freeze --dry-run gives me the highest version, not the one installed ; is there a way to know which version of a dependency is being used on a cabal configure?
04:35:22 <EvanR> julianleviston: in particular the update rule at the bottom here, for handling an update tick...
04:35:56 <EvanR> its basically all a well-typed version of the classic technique for doing an MVC GUI program
04:36:20 <EvanR> update, render
04:36:26 <EvanR> and input handlers
04:36:34 <capisce> again, the devil is in the details :)
04:36:51 <EvanR> who cares about the details when in the end youre programming it the same way?
04:37:13 <capisce> the wrong abstraction leads to worse performance
04:37:19 <haskell003> can someone please show me an example for the usage of "type"? for instance type Month = String
04:37:42 <dibblego> type Month = String
04:37:43 <julianleviston> haskell003: that‚Äôs a good one.
04:37:45 <julianleviston> lol
04:37:48 <EvanR> capisce: now youre just trolling
04:38:12 <capisce> I think we're not understanding each other
04:38:14 <julianleviston> haskell003: type creates a type synonym.
04:38:23 <julianleviston> haskell003: do you understand it?
04:38:37 <EvanR> capisce: we really should not be interested in a syntax-skin of some existing understood language and blaming it for higher performance, i.e. coffeescript vs normal js
04:38:41 * hackagebot gogol-maps-coordinate 0.0.1 - Google Maps Coordinate SDK.  https://hackage.haskell.org/package/gogol-maps-coordinate-0.0.1 (BrendanHay)
04:38:43 * hackagebot gogol-gmail 0.0.1 - Google Gmail SDK.  https://hackage.haskell.org/package/gogol-gmail-0.0.1 (BrendanHay)
04:38:45 * hackagebot gogol-affiliates 0.0.1 - Google Affiliate Network SDK.  https://hackage.haskell.org/package/gogol-affiliates-0.0.1 (BrendanHay)
04:38:47 * hackagebot gogol-discovery 0.0.1 - Google APIs Discovery Service SDK.  https://hackage.haskell.org/package/gogol-discovery-0.0.1 (BrendanHay)
04:38:49 * hackagebot gogol-games-configuration 0.0.1 - Google Play Game Services Publishing SDK.  https://hackage.haskell.org/package/gogol-games-configuration-0.0.1 (BrendanHay)
04:39:00 <capisce> EvanR: of course
04:39:40 <EvanR> capisce: and its easy to end up with something like that when you just add "heres the expression which causes a side effect when evaluated"
04:40:16 <EvanR> it might even be harder to use as a result, if you have to use observers to trigger the effects instead of it being straight imperative
04:40:48 <EvanR> in the end what youre trying to do is the same, schedule the low level commands directly
04:40:53 <capisce> yes, event listeners and the old "inversion of control"-symptom
04:41:29 <capisce> the low level commands to manipulate the graphical scene graph?
04:41:42 <EvanR> graphics, whatever
04:41:50 <EvanR> i havent really been thinking of graphics
04:41:58 <capisce> oh?
04:42:14 <capisce> graphics is where performance issues often arise
04:42:30 <EvanR> im not sure graphics is to blame for that
04:42:46 <capisce> the wrong abstaction was to blame for it in Qt at least
04:42:52 <capisce> immediate painting
04:42:54 <hexagoxel> phaazon: i would assume `freeze` gives the same result as `configure`, although i am not sure you can completely trust this.
04:43:04 <EvanR> well im sure Qt has more problems than that
04:43:17 <phaazon> hexagoxel: maybe it‚Äôs hidden somewhere in cabal configure -v3
04:43:35 <capisce> "Using a scene graph for graphics rather than the traditional imperative painting systems (QPainter and similar), means the scene to be rendered can be retained between frames and the complete set of primitives to render is known before rendering starts. This opens up for a number of optimizations, such as batch rendering to minimize state changes and discarding obscured primitives."
04:43:41 <hexagoxel> phaazon: so configure _does_ give different results?
04:43:51 * hackagebot gogol-useraccounts 0.0.1 - Google Cloud User Accounts SDK.  https://hackage.haskell.org/package/gogol-useraccounts-0.0.1 (BrendanHay)
04:43:53 * hackagebot gogol-storage-transfer 0.0.1 - Google Storage Transfer SDK.  https://hackage.haskell.org/package/gogol-storage-transfer-0.0.1 (BrendanHay)
04:43:55 * hackagebot gogol-resourcemanager 0.0.1 - Google Cloud Resource Manager SDK.  https://hackage.haskell.org/package/gogol-resourcemanager-0.0.1 (BrendanHay)
04:43:57 * hackagebot gogol-customsearch 0.0.1 - Google CustomSearch SDK.  https://hackage.haskell.org/package/gogol-customsearch-0.0.1 (BrendanHay)
04:43:59 * hackagebot gogol-android-enterprise 0.0.1 - Google Play EMM SDK.  https://hackage.haskell.org/package/gogol-android-enterprise-0.0.1 (BrendanHay)
04:44:03 <EvanR> capisce: youre calling the implementation details the abstraction?
04:44:10 <julianleviston> wow BrendanHay is having a field trip with google SDKs today.
04:44:12 <phaazon> hexagoxel: well, I just don‚Äôt know
04:44:15 <capisce> no, but those are not implementation details
04:44:32 <EvanR> well it features prominently in the interface
04:44:35 <capisce> I mean, Qt's original rendering API was imperative
04:44:49 <capisce> as in the abstraction / interface mandated imperative rendering
04:45:06 <capisce> then they introduced another abstraction, enabling higher perfornamce
04:45:46 <exio4> that doesn't tell much
04:45:49 <EvanR> start with a fast implementation, and add some interface ;)
04:46:02 <hexagoxel> phaazon: if you just want a specific version, can't you add the constraint in your .cabal or when you configure?
04:46:09 <EvanR> thats the classic ordering
04:46:10 <exio4> if anything, you are saying he is right
04:46:13 <capisce> I thought your idea was to start with Original FRP and add a fast implementation
04:46:35 <phaazon> hexagoxel: hm, in the .cabal, that sounds nasty
04:46:49 <phaazon> however I‚Äôm interested in the way you do that on the CLI of cabal configure
04:46:54 <phaazon> I need to dig in the man
04:46:55 <phaazon> thanks!
04:47:17 <hexagoxel> phaazon: and `configure --constraint "foo==3.1"` or something like that iirc
04:47:19 <EvanR> capisce: not exactly, but if it were then... thats still not what youre talking about
04:47:34 <capisce> EvanR: unfortunately abstractions are leaky, you can't ignore implementation concerns
04:47:43 <capisce> which is why Qt's original abstraction proved inferior
04:47:45 <EvanR> all abstractions are leaky?
04:47:53 <phaazon> hexagoxel: thanks, I‚Äôll try that!
04:47:59 <hexagoxel> (`freeze` should accept that flag as well)
04:48:06 <capisce> EvanR: then that includes Original FRP, right?
04:48:24 <EvanR> i was asking you to clarify
04:48:41 <capisce> higher level abstractions are more leaky than lower level abstractions
04:48:55 <EvanR> eh?
04:49:01 * hackagebot gogol-youtube-analytics 0.0.1 - Google YouTube Analytics SDK.  https://hackage.haskell.org/package/gogol-youtube-analytics-0.0.1 (BrendanHay)
04:49:03 <capisce> because they constrain you more
04:49:03 * hackagebot gogol-compute 0.0.1 - Google Compute Engine SDK.  https://hackage.haskell.org/package/gogol-compute-0.0.1 (BrendanHay)
04:49:05 * hackagebot gogol-dfareporting 0.0.1 - Google DCM/DFA Reporting And Trafficking SDK.  https://hackage.haskell.org/package/gogol-dfareporting-0.0.1 (BrendanHay)
04:49:07 * hackagebot gogol-apps-activity 0.0.1 - Google Apps Activity SDK.  https://hackage.haskell.org/package/gogol-apps-activity-0.0.1 (BrendanHay)
04:49:09 * hackagebot gogol-debugger 0.0.1 - Google Cloud Debugger SDK.  https://hackage.haskell.org/package/gogol-debugger-0.0.1 (BrendanHay)
04:49:24 <capisce> well, depends how you look at it
04:49:28 <EvanR> as in memory leaky?
04:49:34 <capisce> no
04:49:40 <EvanR> no idea what youre saying
04:49:49 <capisce> http://www.joelonsoftware.com/articles/LeakyAbstractions.html
04:49:55 <capisce> are you familiar with the concept?
04:50:08 <EvanR> leaky abstractions expose implementation details you didnt want to be exposed
04:50:17 <capisce> yeah
04:50:32 <EvanR> so higher level interfaces expose details more why?
04:50:54 <capisce> because they hide more implementation details
04:51:07 <paldepind> I don't understand that either. C is a lower level abstraction. Haskel a higher one. How does Haskell leak more than C?
04:51:29 <paldepind> capisce, isn't that the purpose of abstractions?
04:52:22 <capisce> Haskell might make it harder to predict the performance of your program
04:52:39 <Jinxit> how is that leaky?
04:53:10 <julianleviston> it‚Äôs leaky because bits of the lower level aren‚Äôt used.
04:53:15 <capisce> The Law of Leaky Abstractions: "All non-trivial abstractions, to some degree, are leaky."
04:53:20 <julianleviston> potentially
04:53:26 <capisce> https://en.wikipedia.org/wiki/Leaky_abstraction
04:53:32 <capisce> "Spolsky's article gives examples of an abstraction that works most of the time, but where a detail of the underlying complexity cannot be ignored, thus leaking complexity out of the abstraction back into the software that uses the abstraction."
04:53:43 <capisce> "As systems become more complex, software developers must rely upon more abstractions. Each abstraction tries to hide complexity, letting a developer write software that "handles" the many variations of modern computing."
04:53:47 <capisce> "However, this law claims that developers of reliable software must learn the abstraction's underlying details anyway."
04:54:02 <capisce> if you want to write the fastest programs with Haskell, you need to learn a lot about how GHC works internally
04:54:05 <mungojelly> there's a perfected vision of the algorithm but because it's complicated enough to be difficult to construct it doesn't match the ideal, it thus "leaks" parts of its implementation accidentally into its interface
04:54:05 <capisce> for example
04:54:11 * hackagebot gogol-doubleclick-search 0.0.1 - Google DoubleClick Search SDK.  https://hackage.haskell.org/package/gogol-doubleclick-search-0.0.1 (BrendanHay)
04:54:13 * hackagebot gogol-partners 0.0.1 - Google Partners SDK.  https://hackage.haskell.org/package/gogol-partners-0.0.1 (BrendanHay)
04:54:15 * hackagebot gogol-maps-engine 0.0.1 - Google Maps Engine SDK.  https://hackage.haskell.org/package/gogol-maps-engine-0.0.1 (BrendanHay)
04:54:17 * hackagebot gogol-books 0.0.1 - Google Books SDK.  https://hackage.haskell.org/package/gogol-books-0.0.1 (BrendanHay)
04:54:19 * hackagebot gogol-classroom 0.0.1 - Google Classroom SDK.  https://hackage.haskell.org/package/gogol-classroom-0.0.1 (BrendanHay)
04:54:38 <exio4> capisce: that's exactly why the whole thing waves around denonational semantics
04:55:05 <julianleviston> capisce: I kinda disagree with that, because the fact that it‚Äôs abstract actually lets you get to market faster (or even, sometimes, faster than infinity) without the abstraction.
04:55:30 <capisce> julianleviston: yes, but that's orthogonal :)
04:55:47 <julianleviston> capisce: is it tho
04:55:59 <julianleviston> capisce: still seems fairly RELEVANT ;-)
04:56:07 <mungojelly> for instance conceptually something lets you increase a number infinitely, but actually the number is implemented on a machine with fixed memory, when the memory runs out the fact that it was implemented that way "leaks" into the algorithm by having it emit a memory error instead of an increment
04:56:57 <exio4> capisce: do you realize that's basically claiming "if you want to work at an operational-level, you'll need to deal with operational details"?
04:57:01 <capisce> mungojelly: right
04:57:21 <exio4> capisce: if all you want is your program's correctness, you don't need to deal with those `leaky abstractions`, which isn't leaky abstractions
04:57:28 <exio4> but working with different abstractions
04:57:32 <julianleviston> all perfected virtual machines need some imperfect actual machines to run on in order for anything to be done.
04:57:58 <mungojelly> "higher level abstractions are leakier" might even be a tautology, what is a "low level" abstraction except one that's possible to construct quite solidly
04:58:12 <capisce> exio4: yeah, but if you care about performance those leaky abstractions are really pesky
04:58:18 <exio4> capisce: no, it's not
04:58:19 <EvanR> capisce: the fact that real computers are finite in memory and speed, in of itself, has nothing to do with abstractions
04:58:53 <exio4> capisce: if you care about performance, you are thus working with operational details, which weren't part of the original abstraction you were working with 
04:59:03 <EvanR> when the program runs fast enough, and completes 100% of the time on the computer without a memory error, who in their right mind would dwell on the detail
04:59:18 <capisce> mungojelly: well, TCP is a higher level than UDP for example, and leaks its implementation details on top of UDP, in _addition_ to UDPs implementaion details
04:59:21 * hackagebot gogol-taskqueue 0.0.1 - Google TaskQueue SDK.  https://hackage.haskell.org/package/gogol-taskqueue-0.0.1 (BrendanHay)
04:59:23 * hackagebot gogol-apps-calendar 0.0.1 - Google Calendar SDK.  https://hackage.haskell.org/package/gogol-apps-calendar-0.0.1 (BrendanHay)
04:59:26 * hackagebot gogol-container 0.0.1 - Google Container Engine SDK.  https://hackage.haskell.org/package/gogol-container-0.0.1 (BrendanHay)
04:59:28 * hackagebot gogol-plus-domains 0.0.1 - Google + Domains SDK.  https://hackage.haskell.org/package/gogol-plus-domains-0.0.1 (BrendanHay)
04:59:30 * hackagebot gogol-groups-settings 0.0.1 - Google Groups Settings SDK.  https://hackage.haskell.org/package/gogol-groups-settings-0.0.1 (BrendanHay)
04:59:31 <Jinxit> TCP isn't built on top of UDP
04:59:36 <EvanR> you might as well dwell on the lifeforms living on the computer hardware
05:00:01 <EvanR> they also have nothing to do with your abstraction
05:00:18 <mungojelly> every piece of human written code runs on multiple machines, starting with wetware, so they have to be very general abstractions that can run both on a human and a von neumann style silicon box
05:00:19 <capisce> exio4: what?
05:01:36 <julianleviston> capisce: TCP is the same level as UDP, I think. The Transport Layer
05:01:37 <EvanR> capisce: just to clear you up, i was talking about starting with a semantically sound interface, and then moving to the awesomely efficient implementation (if we have resources to spend on such a thing)
05:01:49 <julianleviston> capisce: https://en.wikipedia.org/wiki/Transport_layer
05:01:55 <EvanR> not specifically using original frps interface
05:02:01 <capisce> julianleviston: right, though I guess it's still correct to say that TCP is a higher level abstraction than UDP
05:02:12 <EvanR> TCP and UDP are different
05:02:17 <julianleviston> capisce: not sure why, but ok.
05:02:18 <EvanR> ones not higher than the other
05:02:36 <mungojelly> the human compiles the abstraction into an approximate model to simulate its behavior (usually by discarding lots of details), while the computer attempts to compile it into a set of more direct instructions that counts to it as equivalent (usually by disregarding time)
05:02:40 <julianleviston> I think TCP is ‚Äúhigher‚Äù than IP.
05:02:42 <EvanR> its easy to do a stream in TCP, and easy to do a datagram in UDP, and both are annoying in the other
05:04:06 <exio4> capisce: if your abstraction is only talking about how something should behave `mathematically` (like, without constraints on time, just like you say the statement x+x = 2*x is true)
05:04:32 * hackagebot gogol-resourceviews 0.0.1 - Google Compute Engine Instance Groups SDK.  https://hackage.haskell.org/package/gogol-resourceviews-0.0.1 (BrendanHay)
05:04:34 * hackagebot gogol-blogger 0.0.1 - Google Blogger SDK.  https://hackage.haskell.org/package/gogol-blogger-0.0.1 (BrendanHay)
05:04:36 * hackagebot gogol-groups-migration 0.0.1 - Google Groups Migration SDK.  https://hackage.haskell.org/package/gogol-groups-migration-0.0.1 (BrendanHay)
05:04:38 * hackagebot gogol-adsense 0.0.1 - Google AdSense Management SDK.  https://hackage.haskell.org/package/gogol-adsense-0.0.1 (BrendanHay)
05:04:40 * hackagebot gogol-genomics 0.0.1 - Google Genomics SDK.  https://hackage.haskell.org/package/gogol-genomics-0.0.1 (BrendanHay)
05:04:47 <EvanR> how many 0.0.1's can you upload!
05:04:52 <capisce> EvanR: and I'm talking about finding out if that semantically sound interface is the _best_ interface from a performance point of view
05:05:00 <exio4> capisce: if you start caring if `x+x` is 'faster' than `2*x`, then your implementation becomes your new abstraction, pretty much
05:05:11 <capisce> EvanR: or if it's impractical to implement it efficiently, relative to a different interface
05:05:17 <EvanR> capisce: how would an interface have a performance?
05:05:39 <EvanR> alright
05:05:46 <capisce> so TCP and UDP are equivalent?
05:05:58 <EvanR> its two different interfaces
05:06:03 <capisce> performance wise, UDP tends to be a lot better for games than TCP
05:06:10 <exio4> is it?
05:06:17 <capisce> for realtime games at least
05:06:23 <exio4> ok, that's different
05:06:26 <exio4> you had said games
05:06:32 <EvanR> UDP gives you datagrams, if thats what you want, good
05:06:44 <EvanR> if you want a stream, UDP might be faster, but probably not
05:06:46 <capisce> and what if all realtime games need datagrams?
05:07:11 <EvanR> good point, what if?
05:07:23 <capisce> then they would use UDP, and ditch TCP
05:07:29 <EvanR> of course
05:07:49 <capisce> and maybe realtime animated UIs on embedded and mobile would need to ditch FRP
05:07:57 <capisce> and use a different interface
05:08:19 <Jinxit> but then again, many games implement a semi-TCP on top of UDP
05:08:24 <EvanR> probably not, and your argument doesnt work since thats coinsiding with the point of frp
05:08:28 <Jinxit> because reliability is cool
05:08:41 <capisce> EvanR: how so?
05:08:43 <EvanR> coinciding, god my E key
05:09:16 <capisce> in any case, that's what I want to find out
05:09:30 <EvanR> capisce: ... if all games in the universe needed datagrams, you would use the datagram api for all of them. this doesnt translate to, if apps on a phone need interactive animations, you would not use frp
05:09:42 * hackagebot gogol-logging 0.0.1 - Google Cloud Logging SDK.  https://hackage.haskell.org/package/gogol-logging-0.0.1 (BrendanHay)
05:09:44 * hackagebot gogol-analytics 0.0.1 - Google Analytics SDK.  https://hackage.haskell.org/package/gogol-analytics-0.0.1 (BrendanHay)
05:09:45 <capisce> no, it certainly doesn't
05:09:46 * hackagebot gogol-prediction 0.0.1 - Google Prediction SDK.  https://hackage.haskell.org/package/gogol-prediction-0.0.1 (BrendanHay)
05:09:48 * hackagebot gogol-admin-emailmigration 0.0.1 - Google Email Migration API v2 SDK.  https://hackage.haskell.org/package/gogol-admin-emailmigration-0.0.1 (BrendanHay)
05:09:49 <EvanR> its kind of the opposite result
05:09:50 * hackagebot gogol-proximitybeacon 0.0.1 - Google Proximity Beacon SDK.  https://hackage.haskell.org/package/gogol-proximitybeacon-0.0.1 (BrendanHay)
05:10:15 <capisce> but you understand the analogy?
05:10:18 <Xnuk> @pl \a b -> b a
05:10:18 <lambdabot> flip id
05:10:28 <EvanR> not really
05:10:53 <capisce> "if game A needs the best network performance it needs to use UDP instead of TCP"
05:10:59 <EvanR> i think you didnt get past the part where TCP and UDP arent in a high levelness relationship
05:11:20 <capisce> no, I get that
05:11:39 <EvanR> if game A needs a stream
05:11:47 <capisce> so performance is related to interfaces in some way
05:11:57 <EvanR> i would hope they dont use UDP
05:12:02 <EvanR> but some do anyway
05:12:18 <capisce> or to implementations of interfaces
05:12:24 <EvanR> they must be making some compromises with correctness that TCP doesnt
05:12:44 <capisce> right
05:12:48 <ggole> Why pay for ordering if you don't need it?
05:12:52 <capisce> exactly
05:13:06 <capisce> that's the point of using UDP instead of TCP
05:13:09 <EvanR> were talking about games that either need a stream or need a datagram
05:13:10 <mungojelly> doesn't non-frp just mean having the state be a function of only recent events and aggressively compressing the past? more an implementation detail than an interface i'd think
05:13:18 <EvanR> capisce: no, they are very different
05:13:25 <ggole> If you have a dropped packet, ordered streams result in packets sitting uselessly in a buffer rather than being used to update your state in a timely way
05:13:31 <EvanR> streams and datagrams are totally different things
05:13:35 <capisce> yes
05:13:45 <EvanR> its not "one is faster and you dont get ordering"
05:14:00 <ggole> Sensible game protocols handle that themselves, allowing timely updates without buffering in the presence of dropped packets
05:14:03 <capisce> but if you don't care about performance, you could use both to achieve the same effect
05:14:04 <EvanR> both use IP
05:14:20 <EvanR> capisce: but you use the one which is simpler
05:14:21 <ggole> And if you want that, then TCP is simply the wrong thing.
05:14:38 <EvanR> you dont deal with packets in UDP
05:14:39 <capisce> TCP might be simpler
05:14:43 <EvanR> you deal with datagrams
05:14:48 <capisce> that's right
05:14:52 * hackagebot gogol-youtube-reporting 0.0.1 - Google YouTube Reporting SDK.  https://hackage.haskell.org/package/gogol-youtube-reporting-0.0.1 (BrendanHay)
05:14:54 * hackagebot gogol-civicinfo 0.0.1 - Google Civic Information SDK.  https://hackage.haskell.org/package/gogol-civicinfo-0.0.1 (BrendanHay)
05:14:56 * hackagebot gogol-fusiontables 0.0.1 - Google Fusion Tables SDK.  https://hackage.haskell.org/package/gogol-fusiontables-0.0.1 (BrendanHay)
05:14:58 * hackagebot gogol-pagespeed 0.0.1 - Google PageSpeed Insights SDK.  https://hackage.haskell.org/package/gogol-pagespeed-0.0.1 (BrendanHay)
05:15:00 * hackagebot gogol-cloudtrace 0.0.1 - Google Cloud Trace SDK.  https://hackage.haskell.org/package/gogol-cloudtrace-0.0.1 (BrendanHay)
05:15:11 <capisce> you might need to write more network code to use UDP
05:15:14 <capisce> in your game
05:15:15 <EvanR> and doing messages over TCP is bollocks
05:15:17 <capisce> but the result will be faster
05:15:23 <EvanR> so youre analogy is completely off
05:16:11 <mungojelly> i've never actually sent any messages over UDP, i'm gonna do that right now
05:16:29 <EvanR> messages/datagrams
05:17:21 <mungojelly> what's a datagram, that doesn't mean anything different to me yet than message, it's less structured somehow?
05:17:33 <EvanR> its not different
05:17:50 <capisce> EvanR: if you steelman my argument, you still don't see at all how FRP might constrain performance in some ways relative to a different interface?
05:17:53 <capisce> for a given application
05:18:12 <capisce> but you do see how UDP might constrain performance relative to TCP?
05:18:19 <EvanR> not really since FRP has so many implementation options
05:18:30 <capisce> and TCP doesn't?
05:18:44 <EvanR> UDP and TCP both have strictly defined implementations
05:18:51 <EvanR> in terms of IP
05:19:04 <EvanR> its very operational
05:20:02 * hackagebot luminance 0.5.2.1 - Type-safe, dependently-typed and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.5.2.1 (DimitriSabadie)
05:20:44 <capisce> yes, FRP is quite a bit higher level
05:21:03 <capisce> that doesn't mean it doesn't constrain implementations at all
05:21:15 <capisce> performance wise
05:21:34 <EvanR> its interesting that implementations are also based on some lower level abstraction, which we dont question
05:21:47 <capisce> what do you mean?
05:21:51 <EvanR> C for example
05:22:21 <capisce> why wouldn't we question C?
05:22:49 <EvanR> my 3d application will be written in opengl, in C. the interface i invent for this thing will be something, the implementation is in C. but we wont question whether C itself is a good abstraction (for performance)
05:22:52 <capisce> although when it comes to graphics performance the limiting factor tends to be the GPU and the low level graphics API
05:23:00 <capisce> OpenGL or other
05:23:13 <EvanR> opengl is another, opengl will not be questioned
05:23:15 <capisce> we often have no choice there
05:23:19 <EvanR> but its not the best either
05:23:23 <capisce> certainly not
05:23:28 <capisce> that's why they're now working on Vulkan
05:23:29 <capisce> :p
05:23:45 <capisce> as OpenGL was a very leaky abstraction
05:23:57 <capisce> and inefficient
05:24:16 <EvanR> well, vulkan is doing your plan, see how fast it can go (current graphics tech), and put some sort of interface on it
05:24:26 <EvanR> and call it good
05:24:34 <capisce> what's the alternative?
05:24:54 <EvanR> start with a nice language for describing 3d graphics, then implement it somehow
05:25:04 * hackagebot secp256k1 0.3.0 - secp256k1 bindings for Haskell  https://hackage.haskell.org/package/secp256k1-0.3.0 (xenog)
05:25:16 <EvanR> this is not even close to impossible now that gpus are programmable
05:26:00 <EvanR> graphics has a lot of opportunity for nice composable language
05:26:05 <mungojelly> yay i just sent a hello world over udp
05:26:11 <Clint> now do it over sctp
05:26:13 <EvanR> did it arrive? ;)
05:26:34 <mungojelly> unfortunately yes :( i can't think how to actually get it to drop any packets on me, hmm
05:26:42 <julianleviston> EvanR: yes, but it came out as ‚Äúelloh olwr‚Äù
05:26:43 <EvanR> it probably wont
05:26:45 <julianleviston> jokes.
05:26:48 <int-e> are there any publicly available vulkan specs... I don't see them
05:27:05 <capisce> EvanR: unfortunately, in graphics there are so many variables, a high level API would have a hard time exposing all of those in a nice way
05:27:13 <capisce> in a way that makes everyone happy
05:27:16 <EvanR> why would it want to?
05:27:31 <capisce> because otherwise it constrains the design space a lot
05:27:42 <capisce> it makes certain kind of applications harder to implement
05:27:45 <EvanR> if you want all the "variables" you can use api X (which actually doesnt exist, opengl doesnt expose everything either)
05:27:47 <int-e> capisce: there'll be room for many high-level frameworks
05:27:57 <EvanR> which is what i was saying earlier
05:28:01 <capisce> EvanR: exactly, you have to use a different API then if you want the best performance
05:28:07 <capisce> a lower level API
05:28:24 <EvanR> sometimes, not because of some law of the universe though
05:28:37 <EvanR> because of the state of the tools
05:29:55 <capisce> anyway, I gotta head out, see you later
05:29:58 <mungojelly> getting better performance by writing to a lower level api means you're creating a new higher level abstraction over it that fits your needs, just usually not documenting it well
05:30:40 <mungojelly> nobody actually writes low lever like they write for thousands and thousands of lines about what the computer should do for a nanosecond, they write low level as in they write in low level languages new abstractions specific to their problems
05:30:46 <mungojelly> *level
05:31:22 <mungojelly> i've tried to learn haskell a few times and i gave up because ugh so much syntax, what should i try next, something i should read maybe?
05:32:03 <julianleviston> @where haskelbook
05:32:03 <lambdabot> I know nothing about haskelbook.
05:32:07 <julianleviston> @where haskell book
05:32:08 <lambdabot> http://haskell.org
05:32:11 <EvanR> maybe lisp, they dont have syntax ;)
05:32:12 <julianleviston> sigh
05:32:16 <EvanR> or types
05:32:21 <EvanR> maybe its up your alley
05:32:21 <julianleviston> mungojelly: wait‚Ä¶ do you want to learn haskell still?
05:32:30 <benzrf> mungojelly: haskell has considerably less syntax than most languages ive learned tbqh
05:32:38 <benzrf> :v
05:32:46 <julianleviston> mungojelly: http://haskellbook.com
05:33:03 <mungojelly> EvanR: well yes i already speak a couple of lisps ok (elisp and clojure), easypeasy
05:33:03 <benzrf> bbl
05:33:12 <julianleviston> mungojelly: if you want to learn haskell, that stacks things on top of each other.
05:33:28 <benzrf> mungojelly: i believe you mean "i already thpeak"
05:33:30 <mungojelly> benzrf: um ok well what do you call all this *!&#$*(&!#$ you talk in here all day long then? :/
05:33:38 <benzrf> function names
05:33:41 <benzrf> later!
05:34:10 <EvanR> mungojelly: symbols for operators, you have that in lisp, they just go in the front
05:34:15 <mungojelly> the functions you talk in seem to take straightforward reality and bend it somehow into complicated shapes, and those shapes are what i'm calling syntax
05:34:15 <julianleviston> mungojelly: I dunno‚Ä¶ do you consider  == to be syntax? because it‚Äôs not. It‚Äôs just an operator.
05:34:29 <EvanR> mungojelly: its called infix ;)
05:34:42 <julianleviston> mungojelly: once you understand typeclasses and abstract data types, you realise there‚Äôs hardly any syntax 
05:34:50 <EvanR> f <$> x <*> y <*> z
05:35:17 <julianleviston> mungojelly: sorry, algebraic data types‚Ä¶ 
05:35:24 <EvanR> = liftA3 f x y z
05:35:33 <mungojelly> that sounds to me like how what i'd say what you're saying is that you create syntaxes using typeclasses
05:35:45 <julianleviston> mungojelly: no.
05:35:47 <EvanR> haskell doesn't let you create new syntax, no
05:35:54 <EvanR> unlike some languages
05:36:07 <mungojelly> it lets you create patterns in which there have to be particular types at particular places in sequences
05:36:34 <julianleviston> mungojelly: that types.
05:36:53 <julianleviston> mungojelly: other languages let you do the same thing, they just don‚Äôt throw an error until after the program is running.
05:36:58 <julianleviston> mungojelly:  that‚Äôs just types*
05:37:01 <mungojelly> so the syntax is in what sequence of types you have to have in what order
05:37:03 <int-e> > let foo x | x == 1 = "one" | otherwise = "not one" in foo 2 -- Haskell programmers are sometimes quite good at making stuff look like new syntax. ("otherwise" is a constant that evaluates to true, not syntax)
05:37:04 <lambdabot>  "not one"
05:37:30 <julianleviston> mungojelly:  well, that‚Äôs just silly - based on that, all programming languages have infinite syntax.
05:38:00 <EvanR> i can see that syntax is a confusing concept coming from lisp ;)
05:38:02 <mungojelly> i'm just trying to figure out what we're talking about. you speak a language that's very complicated, but you're saying it has no syntax at all. what do you call the complication.
05:38:12 <julianleviston> mungojelly: we‚Äôre more likely to think ‚Äúsyntax‚Äù is just ‚Äúthe number of forms you have to learn‚Äù.
05:38:33 <julianleviston> mungojelly: no one said Haskell has no syntax at all. All programming languages have syntax. 
05:39:05 <babygau> Could someone pls explain to me type pameterized synonyms?
05:39:24 <julianleviston> babygau: you mean like type Hello a = Maybe a ?
05:39:27 <mungojelly> what is the syntax? putting `` around things makes them infix, or something. does putting <> around things mean something or are those just words? is there precedence orders?
05:39:46 <EvanR> you cant put < > around things
05:39:51 <babygau> julianleviston yes, sth like that
05:39:58 <mungojelly> is = a function
05:40:01 <babygau> http://learnyouahaskell.com/making-our-own-types-and-typeclasses#type-synonyms
05:40:08 <int-e> <> are just parts of infix operator names
05:40:09 <babygau> I'm reading this but cannot my head round
05:40:16 <mungojelly> so <$> is just the word <$>? 
05:40:27 <julianleviston> babygau: but you asked for PARAMETERISED type synonyms.
05:40:30 <EvanR> mungojelly: <$> and <*> and <> are operators, you can name operators with any symbols you want
05:40:41 <julianleviston> babygau: a type synonym by itself is just another name for a type.
05:40:52 <EvanR> mungojelly: = is not a function
05:41:03 <mungojelly> EvanR: maybe it's as simple here as you're saying but i'm just being confused by the flood of ascii art
05:41:05 <EvanR> (==) is a function
05:41:06 <julianleviston> babygau: so if you‚Äôre writing a program about people and you decide you want a type for name, and it‚Äôs just the same as String, you can say type Name = String
05:41:08 <babygau> julianleviston but why we need to parameterize it
05:41:24 <julianleviston> babygau: well until you need to do that, you don‚Äôt need to do that! :)
05:41:41 <babygau> julianleviston could u give me an example :(
05:42:00 <julianleviston> babygau: you‚Äôre going about it backwards. You should have the need before you try to learn the thing! :)
05:42:04 <julianleviston> babygau: but I‚Äôll try.
05:42:13 <julianleviston> babygau: do you know of any types that take parameters already?
05:42:43 <int-e> mungojelly: there are fixity declarions which give an associativity (left, right, none) and precedence (from 0 to 9) to infix operators. So on that level the programmer has some influence on the syntax.
05:42:44 <julianleviston> babygau: oh‚Ä¶ there‚Äôs a good example in LYAH. let‚Äôs use that‚Ä¶ type AssocList k v = [(k,v)]
05:42:48 <julianleviston> babygau: do you understand that type?
05:42:58 <babygau> nope
05:43:03 <julianleviston> babygau: it says ‚Äúwherever I say AssocList, I mean [(,)]
05:43:08 <babygau> julianleviston I'm looking into it and don't understand
05:43:11 <julianleviston> babygau: do you understand (,) ?
05:43:20 <julianleviston> babygau: I‚Äôm assuming you know what a pair is?
05:43:25 <julianleviston> > (1,2)
05:43:26 <babygau> yes
05:43:27 <lambdabot>  (1,2)
05:43:29 <julianleviston> cool :)
05:43:40 <julianleviston> so you know what this is then? [(,)] ?
05:43:51 <julianleviston> babygau: it‚Äôs a list of pairs, yeah?
05:43:52 <babygau> and why they parameterize AssocList?
05:43:58 <julianleviston> babygau: one step at a time.
05:43:58 <babygau> with `k` and `v`?
05:44:05 <julianleviston> babygau: one step‚Ä¶ at a time.
05:44:15 <ggole> That's not a list of pairs...
05:44:15 <babygau> julianleviston I'm listening :)
05:44:19 <julianleviston> isn‚Äôt it?
05:44:31 <julianleviston> ggole: i thought it was the type of a list of pairs?!?
05:44:33 <mungojelly> int-e: do you have to know which precedence 0 to 9 things are to understand them? :/
05:44:42 <julianleviston> [(k,v)]
05:44:48 <ggole> It's a list of functions from two arguments to pairs
05:44:55 <julianleviston> ggole: oh god. Ok. 
05:44:58 <julianleviston> ggole: yes.
05:45:06 * hackagebot secp256k1 0.3.1 - secp256k1 bindings for Haskell  https://hackage.haskell.org/package/secp256k1-0.3.1 (xenog)
05:45:20 <ggole> (Of which (,) is the only reasonable inhabitant, I think?)
05:45:28 <julianleviston> ggole: yes yes. ok.
05:45:44 <EvanR> mungojelly: so learn the special symbols first, then anything you see that isnt a special symbol is defined with code somewhere. special symbols include =, ::, .., \, |, ->, <-, =>
05:45:52 <babygau> it is imported from Data.Map
05:45:55 <julianleviston> babygau: ok‚Ä¶ so let‚Äôs say you have a function that takes a pair and spits out the first item‚Ä¶
05:46:06 <EvanR> im not sure whats up with @
05:46:07 <babygau> julianleviston yes
05:46:20 <EvanR> > let x @ x = x + x in 2 @ 2
05:46:21 <julianleviston> babygau: called fst, obviously.
05:46:22 <lambdabot>  <hint>:1:24: parse error on input ‚Äò@‚Äô
05:46:33 <EvanR> though you could use @
05:46:44 <EvanR> mungojelly: and @
05:46:56 <julianleviston> babygau: so map fst [(1,2),(3,4)] will give you [1,3] yeah?
05:47:04 <julianleviston> > map fst [(1,2),(3,4)]
05:47:06 <lambdabot>  [1,3]
05:47:08 <int-e> mungojelly: at least for a few operators, yes. there's the standard operators like + - * /... and there's the infamous case of $ (which is a right-associative operator with very low precedence...). If in doubt you can query such things in ghci using :i ($) (:i is short for :info)
05:47:21 <babygau> julianleviston yues
05:47:59 <EvanR> @src ($)
05:47:59 <lambdabot> f $ x = f x
05:48:12 <julianleviston> babygau: ok‚Ä¶ so let‚Äôs call the function firsts‚Ä¶ firsts xs = map fst xs
05:48:41 <julianleviston> babygau: the type of it will be this: firsts :: [(a,b)] -> [a]
05:48:42 <mungojelly> int-e: but why? i thought we all gave that up as confusing after c :(
05:48:57 <int-e> ?
05:49:22 <babygau> julianleviston yes
05:49:25 <int-e> I thought that was only lisp programmers... (I know that's not quite true either)
05:49:34 <julianleviston> babygau: now, say you actually want the type to be a bit clearer‚Ä¶ you want it to actually say firsts :: AssocList a b -> [a]
05:49:44 <julianleviston> babygau: then you can write a type synonym for that.
05:49:57 <int-e> mungojelly: to me, having deeply nested parentheses is confusing.
05:50:10 <mungojelly> so :i + gives "infixl 6" so it's left associative at precedence 6. i literally can't even believe this. what. is. the. point.
05:50:22 <julianleviston> babygau: k and v are traditionally used for an association list because they have ‚Äúkey‚Äù, and the ‚Äúvalue‚Äù.
05:50:38 <julianleviston> babygau: so you can write type AssocList k v = [(k,v)]
05:50:43 <EvanR> mungojelly: to have less parentheses
05:50:44 <julianleviston> babygau: now, what don‚Äôt you understand?
05:50:45 <capisce> mungojelly: you haven't used any language that isn't a lisp for the last 10 years?
05:50:47 <int-e> we all spent a good deal of time at school learning that multiplication binds stronger than addition; why let that training go to waste?
05:51:11 <mungojelly> because you have to work hard to learn it, and then you still get it wrong!?
05:51:19 <babygau> julianleviston I don't understand `k and v`
05:51:27 <julianleviston> babygau: they‚Äôre just variable names.
05:51:29 <mungojelly> are y'all fixing precedence bugs all the time around here? fess up
05:51:37 <julianleviston> babygau: they could be x and y or a and b
05:51:39 <int-e> not really, no
05:51:42 <babygau> julianleviston is it a `concrete type` of `AssocList`
05:51:55 <EvanR> putting something with the wrong precedence together usually causes a type error
05:52:04 <julianleviston> babygau: they‚Äôre named k and v because of maps having a key and value
05:52:08 <mungojelly> so maybe there's some coherence or meaning or predictability to it that i'm not seeing yet!? :(
05:52:08 <julianleviston> babygau: huh?
05:52:19 <EvanR> mungojelly: yes
05:52:40 <capisce> mungojelly: you know you can use parentheses in Haskell too right?
05:52:40 <babygau> julianleviston I meant, If I name `type AssocList k v = [(k, v)]`
05:52:42 <EvanR> equational reasoning
05:52:52 <julianleviston> babygau: what‚Äôs your question?
05:52:59 <babygau> julianleviston the return value must be `either k or v`, right?
05:53:09 <mungojelly> capisce: but i have to understand how people speak here in order to understand this conversation
05:53:23 <julianleviston> babygau: AssocList is a name for a list of pairs‚Ä¶ with non-fixed first and second elements (the k and the v)
05:53:25 <capisce> mungojelly: precendence bugs don't happen a lot because of type safety
05:53:28 <mungojelly> or speak appropriately
05:53:30 <julianleviston> babygau: let‚Äôs make one...
05:53:38 <EvanR> mungojelly: people will clarify where the parens go if you ask
05:53:54 <julianleviston> babygau: [(‚Äúhi‚Äù,1), (‚Äúwoo‚Äù,2)] :: AssocList String Int
05:53:55 <EvanR> in a -> b -> c, it means a -> (b -> c), for example
05:54:01 <mungojelly> capisce: by don't "happen" a lot you mean, you get them quickly from the type checker
05:54:07 <julianleviston> babygau: do you understand that?
05:54:23 <capisce> mungojelly: exactly, instead of at runtime
05:54:26 <julianleviston> babygau: see how I made an association list with String as the k and Int as the v?
05:54:32 <mungojelly> well i don't want any bugs at any time. i want to just say things and have them happen.
05:54:38 <capisce> ?
05:54:46 <babygau> julianleviston I see
05:54:49 <capisce> that language hasn't been invented yet
05:54:52 <julianleviston> babygau: sweet.
05:54:54 <EvanR> i wouldnt trust my voice to be interpreted right
05:54:56 <int-e> mungojelly: perhaps programming isn't for you then.
05:55:20 <babygau> thank julianleviston, I have other
05:55:28 <julianleviston> babygau: you have other?
05:55:38 <babygau> data Vector a = Vector a a a deriving (Show)  
05:55:39 <babygau>   
05:55:39 <babygau> vplus :: (Num t) => Vector t -> Vector t -> Vector t  
05:55:40 <babygau> (Vector i j k) `vplus` (Vector l m n) = Vector (i+l) (j+m) (k+n) 
05:55:45 <EvanR> siri: please solve collatz conjecture
05:55:49 <babygau> what is this julianleviston 
05:56:03 <capisce> mungojelly: precedence bugs don't happen a lot in the first place, and if they do happen the type checker will typically catch it
05:56:07 <babygau> We have `vplus` a function, right?
05:56:12 <julianleviston> babygau: uh‚Ä¶ dude it looks like you‚Äôre skipping around a LOT.
05:56:24 <EvanR> capisce: sometimes its hard though, if you have a lot of monoids going on
05:56:26 <babygau> but why `vplus` is in the middle of the next sentence?
05:56:28 <capisce> though a beginner might have more precedence bugs related to ($) and (.) than an experienced programmer I guess
05:56:45 <julianleviston> babygau: can i recommend you don‚Äôt learn Haskell this way but rather buy bitemeapp‚Äôs book?
05:56:56 <mungojelly> capisce: ok well what people say about haskell is "you have to wrestle with the type checker" and now i see why, that's too complex to write anything without a wrestling match
05:57:00 <capisce> I wouldn't call them "bugs" actually
05:57:11 <babygau> julianleviston you might be right, but I don't see that definition on LearnYouAHaskell
05:57:12 <julianleviston> babygau: you‚Äôre going to have a lot of pain if you learn this way.
05:57:19 <julianleviston> babygau: what definition?
05:57:31 <julianleviston> babygau: http://haskellbook.com
05:57:41 <int-e> mungojelly: every type checking error is a bug that you don't have to fix later on.
05:57:41 <EvanR> mungojelly: and i tend to wrestle even harder tracing the problem back from a runtime error
05:57:46 <capisce> mungojelly: and in dynamic languages you have no support from types at all, so your program is a lot more likely to fail at runtime
05:58:16 <julianleviston> mungojelly:  what they mean is there‚Äôs no typechecker.
05:58:22 <mungojelly> types don't require ten adjustable precedence levels.
05:58:24 <capisce> mungojelly: wrestle is a loaded way of describing it
05:58:25 <julianleviston> mungojelly: usually
05:58:37 <babygau> julianleviston Could you explain this `(Vector i j k) `vplus` (Vector l m n) = Vector (i+l) (j+m) (k+n) `
05:58:38 <julianleviston> mungojelly: you‚Äôve never learned C, have you...
05:58:41 <int-e> mungojelly: that's right, you're conflating different aspects of the language.
05:58:53 <EvanR> mungojelly: thats for reducing parentheses, not type safety
05:58:53 <julianleviston> babygau: it‚Äôs adding two vectors together.
05:58:58 <capisce> mungojelly: you can program in lisp style in Haskell too
05:59:01 <babygau> I see the link, look interesting, but it cost me too much :(
05:59:04 <capisce> mungojelly: that way you don't need precedence levels
05:59:12 <julianleviston> babygau: there‚Äôs a lot of stuff I‚Äôd have to explain in order to explain that. 
05:59:16 <mungojelly> julianleviston: C is one of the first languages i learned from my dad when i was little, it's beautiful but also it's so time to move on
05:59:21 <EvanR> > ((+) 1 2 3 4 5 6)
05:59:22 <lambdabot>      Could not deduce (Num a0)
05:59:22 <lambdabot>      from the context (Num a,
05:59:22 <lambdabot>                        Num a4,
05:59:23 <capisce> mungojelly: but most people prefer precedence levels to having more parentheses
05:59:28 <julianleviston> mungojelly: it has precedence rules.
05:59:43 <EvanR> need a Num instance for functions!
05:59:45 <julianleviston> babygau: first, you need to understand making your own datatypes.
05:59:50 <julianleviston> babygau: do you understand how to do that yet?
05:59:57 <babygau> julianleviston I do
06:00:08 <julianleviston> babygau: ok‚Ä¶ so you know what Vector i j k is then?
06:00:08 <babygau> julianleviston Let me explain first
06:00:26 <julianleviston> babygau: and I‚Äôm assuming you understand pattern matching?
06:00:28 <babygau> julianleviston data Vector a = Vector a a a deriving (Show) 
06:00:39 <julianleviston> babygau: yes, but what does that mean?
06:00:49 <babygau> julianleviston this define a `Vector` type which has 3 values
06:00:49 <julianleviston> babygau: in english‚Ä¶ what is that data type?
06:00:58 <julianleviston> babygau: more information please?
06:00:59 <MacPooter> hello
06:01:08 <julianleviston> babygau: that‚Äôs correct, but what about those values?
06:01:23 <babygau> julianleviston these values has the same type
06:01:30 <julianleviston> babygau: yes, and what type is that?
06:01:42 <MacPooter> has anyone had issues installing the haskell package on el capitan?
06:01:46 <mungojelly> babygau: did you know your name means "make soap" in lojban?
06:01:53 <babygau> julianleviston whatever type it it such as Int, Char, String ...
06:02:06 <julianleviston> MacPooter: el capitain does some stuffed up things with the /usr/bin folder and the like...
06:02:19 <babygau> julianleviston ex: Vector 1 2 3
06:02:22 <julianleviston> MacPooter: check the issues on stack relating to it‚Ä¶ I think
06:02:27 <MacPooter> i did
06:02:40 <MacPooter> even with the unsigned binary i still get the command not found error
06:02:47 <babygau> and this Vector is an instance to type class `Show`
06:02:54 <MacPooter> and the usr folder seems void of anything haskell related
06:02:55 <babygau> julianleviston Am I correct
06:03:00 <julianleviston> babygau: ok‚Ä¶ so the answer is ‚Äúany type at all‚Äù
06:03:04 <julianleviston> babygau: anyway.
06:03:18 <julianleviston> MacPooter: oh I had different errors‚Ä¶ complaining about no access to ld.
06:03:30 <babygau> julianleviston the next statement is follow: vplus :: (Num t) => Vector t -> Vector t -> Vector t  
06:03:36 <julianleviston> babygau: ok.. so in that function `vplus` ‚Ä¶ 
06:03:51 <julianleviston> babygau: yep‚Ä¶ explain that?
06:04:01 <babygau> This is a function `vplus` which take 2 `Vector` and return a `Vector`, right?
06:04:10 <julianleviston> babygau: good enough.
06:04:19 <julianleviston> babygau: we‚Äôll gloss over currying for now.
06:04:24 <babygau> and `t` must be type of `Num`
06:04:27 <julianleviston> babygau: but‚Ä¶ it has a constraint
06:04:30 <julianleviston> yeah ok cool
06:04:41 <babygau> julianleviston the next I don't understand
06:04:49 <julianleviston> babygau: technically t must be of a type that has a Num instance.
06:04:56 <julianleviston> babygau:  (pretty sure that‚Äôs right)
06:05:10 <julianleviston> babygau: ok‚Ä¶ next is the definition of the function.
06:05:11 <babygau> julianleviston (Vector i j k) `vplus` (Vector l m n) = Vector (i+l) (j+m) (k+n) 
06:05:22 <julianleviston> babygau: let me rewrite it for you
06:05:39 <babygau> julianleviston tks
06:05:45 <julianleviston> babygau:  this means exactly the same thing: vplus (Vector i j k) (Vector l m n) = Vector (i+l) (j+m) (k+n)
06:05:52 <julianleviston> babygau: do you understand that?
06:06:05 <babygau> Yes
06:06:20 <MacPooter> what should show up in my usr/local/bin?
06:06:20 <julianleviston> babygau: in the same way as you can use the ` ` characters to infix a function when applying functions, you do it while defining functions.
06:06:23 <babygau> julianleviston On website, they don't mention `vplus` notation
06:06:30 <babygau> julianleviston I'm puzzled by that notation
06:06:34 <julianleviston> babygau: pretty sure they do.
06:06:46 <babygau> julianleviston could you please point out?
06:07:00 <julianleviston> babygau: say you have a function: plus a b = a + b
06:07:15 <julianleviston> babygau: then you can call it like this: plus 1 2
06:07:22 <julianleviston> babygau: or you can call it like this: 1 `plus` 2
06:07:54 <julianleviston> babygau: it turns a normal (prefix) function into an infix function
06:08:02 <babygau> Now I just learn that!
06:08:22 <babygau> julianleviston thank you so much
06:08:34 <julianleviston> babygau: glad I could help.
06:09:19 <babygau> julianleviston f**k me, it's right here http://learnyouahaskell.com/starting-out
06:09:41 <babygau> julianleviston If a function takes two parameters, we can also call it as an infix function by surrounding it with backticks. For instance, the div function takes two integers and does integral division between them. Doing div 92 10 results in a 9. But when we call it like that, there may be some confusion as to which number is doing the division and which one is being divided. So we can call it as an infix function by doing 92 `div` 10
06:09:41 <babygau>  and suddenly it's much clearer.
06:09:50 <hpc> woohoo, i just found my first bug in a hackage package that's not my own!
06:10:14 <julianleviston> babygau: yeah. I really don‚Äôt recommend that book. A lot of people love it, but I think it‚Äôs very confusing.
06:10:34 <MacPooter> i attempted to create the usr/local/bin folder but i dont have permission, how do i force it to let me mkdir
06:10:35 <julianleviston> babygau: hey, it‚Äôs free tho‚Ä¶ just remember, if you‚Äôre frustrated, it‚Äôs not haskell‚Äôs fault!
06:10:46 <julianleviston> MacPooter: um‚Ä¶ why are you doing that?
06:11:00 <julianleviston> MacPooter: have you installed 7.10.2-a ?
06:11:03 <MacPooter> i figured if the folder doesnt exist ill mkdir it there
06:11:11 <MacPooter> yes i believe i did
06:11:19 <julianleviston> MacPooter: hm. what is the issue?
06:11:30 <MacPooter> well ghci returns a command not found error
06:11:42 <MacPooter> so im looking to see if it installed correctly
06:11:47 <julianleviston> MacPooter: I‚Äôm assuming you‚Äôve closed the window since installing it?
06:11:53 <MacPooter> yes i have
06:12:07 <julianleviston> MacPooter: and did you run the app?
06:12:46 <MacPooter> app?
06:12:53 <julianleviston> MacPooter: are you using the platform, or this? https://ghcformacosx.github.io
06:12:59 <MacPooter> platform
06:13:07 <babygau> tks julianleviston :)
06:13:17 <julianleviston> MacPooter: oh sorry, I have no idea about platform really.
06:13:24 <MacPooter> should i use this instead?
06:13:38 <julianleviston> MacPooter: did you follow the 3 steps? 
06:13:45 <julianleviston> MacPooter: run the installer and follow the instructions?
06:14:11 <babygau> julianleviston the book you recommentd looks great, but it is very expensive :(
06:14:22 <MacPooter> i was pretty sure i did
06:14:34 <babygau> I can't afford that much
06:14:40 <julianleviston> babygau: no problem.
06:15:23 <julianleviston> babygau: let me link you to some exercises that I wrote when I was learning that might be helpful‚Ä¶ http://www.genericoverlords.com/haskell_exercises
06:15:31 <julianleviston> babygau: they‚Äôre for basics.
06:16:36 <julianleviston> babygau: some of them are taken from the CIS194 tutorial(s)‚Ä¶ which are very good. 
06:16:42 <julianleviston> @where cis194
06:16:42 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
06:16:47 <julianleviston> babygau:  ^
06:17:30 <julianleviston> MacPooter: ah ok‚Ä¶ it sounds like ghci isn‚Äôt in your path is all‚Ä¶ which should have been in your instructions‚Ä¶ which is why I asked if you‚Äôd closed your terminal window since you‚Äôve installed it - 
06:17:56 <julianleviston> MacPooter: terminal doesn‚Äôt see changes to your bashrc file until you‚Äôve opened a new terminal session usually.
06:18:08 <MacPooter> i did open a new one
06:18:31 <babygau> julianleviston thanks so much
06:18:40 <babygau> julianleviston really appreciated!
06:18:43 <MacPooter> the issue is more elusive than that
06:18:55 <julianleviston> MacPooter: ok.
06:19:07 <julianleviston> MacPooter: I‚Äôm still not sure what the issue is.
06:19:16 <MacPooter> me neither
06:19:16 <julianleviston> MacPooter: sounds like it‚Äôs not on your path, no?
06:19:51 <MacPooter> oh shit
06:19:52 <MacPooter> im in
06:19:54 <MacPooter> yes
06:19:56 <julianleviston> MacPooter: El Capitaine has some problems installing certain things because of the new sandboxing rules (programs can‚Äôt write into /usr/bin)
06:20:04 <julianleviston> MacPooter: ?
06:20:12 <MacPooter> your link worked better than the other binaries
06:20:21 <julianleviston> MacPooter: um. ok.
06:20:57 <MacPooter> s
06:21:05 <julianleviston> babygau: no problems
06:21:21 <MacPooter> it looks like the platform is busted for capitain, there are a few versions people edited floating around but for some people none of them work
06:21:51 <julianleviston> MacPooter: mmm I had some troubles with GHC 7.8.
06:22:04 <MacPooter> well im in ghci
06:22:07 <julianleviston> MacPooter: and a version of stack that used it wasn‚Äôt installing because it couldn‚Äôt run ld.
06:22:11 <MacPooter> lets see how far it gets without error
06:22:12 <julianleviston> MacPooter: ok then.
06:22:29 <julianleviston> MacPooter: if you can install packages, you‚Äôll be fine.
06:22:50 <MacPooter> what do you mean version of stack
06:23:03 <julianleviston> MacPooter: do you know what ‚Äústack‚Äù is?
06:23:09 <MacPooter> nope guess not
06:23:23 <julianleviston> MacPooter: https://github.com/commercialhaskell/stack/
06:23:34 <julianleviston> MacPooter: it‚Äôs an installation helper tool
06:23:41 <julianleviston> MacPooter: kind of replaces cabal install
06:23:58 <julianleviston> MacPooter: some people like to use it because it makes installing things much less painful.
06:24:04 <sternenseemann> What do I do if I need Ord in a Functor or Bifunctor instance?
06:24:11 <sternenseemann> where my type is data Foo a b = ‚Ä¶
06:24:22 <sternenseemann> and I need Ord for both a and b?
06:25:00 <julianleviston> sternenseemann: constrain your usage to Ord ?
06:25:01 <sternenseemann> instance Bifunctor Foo and instance Functor (Foo a) don't allow me to declare that for a and b?
06:25:08 * hackagebot easy-bitcoin 0.0.0.2 - types and functions for bitcoin applications  https://hackage.haskell.org/package/easy-bitcoin-0.0.0.2 (AlejandroDuranPallares)
06:25:13 <sternenseemann> julianleviston: what do you mean by that?
06:25:36 <julianleviston> sternenseemann: isn‚Äôt it more advisable to constrain your uses of it (ie the functions that use it) rather than at the instancing level?
06:25:56 <julianleviston> sternenseemann: could be talking incorrectly here.
06:28:06 <nshepperd> sternenseemann: you can't constrain the types in fmap with a typeclass
06:28:17 <sternenseemann> julianleviston: but I need the Ord for the implementation of bimap and fmap
06:28:23 <julianleviston> sternenseemann: I don‚Äôt get it.
06:28:25 <sternenseemann> nshepperd: I know
06:28:31 <sternenseemann> okay:
06:28:37 <julianleviston> sternenseemann: you can constrain the data type, but that‚Äôs really inadvisable.
06:28:57 <sternenseemann> yes, therefore I am looking for a different solution
06:29:00 <julianleviston> data (Ord a, Ord b) => Foo a b = 
06:29:05 <benzrf> omg
06:29:07 <benzrf> no no no
06:29:09 <sternenseemann> I have a BiMap: data BiMap a b
06:29:13 <benzrf> oh wait nvm -.-
06:29:19 <julianleviston> benzrf: I just finished saying not to do that ;)
06:29:26 <sternenseemann> it allows to lookup an a or b
06:29:39 <benzrf> sternenseemann: your functor instance is probably invalid if it relies on ord
06:30:02 <sternenseemann> benzrf: that could be true
06:30:04 <julianleviston> sternenseemann: maybe you just want a plain old function?
06:30:07 <benzrf> oh ait i think i see
06:30:33 <benzrf> bbl
06:30:50 <sternenseemann> if I was fmaping or bimaping I would have to resort the quadtree
06:30:57 <nshepperd> Yeah, I think the thing to do is to just define your own mapping functions
06:30:58 <sternenseemann> since otherwise lookups would be incorrect
06:31:22 <sternenseemann> nshepperd: yeah, probably because I have the feeling that I would break the functor laws‚Ä¶
06:34:11 <k0ral> Hello
06:34:50 <k0ral> is there a way to leverage haskell laziness so that the following computation doesn't crash: "min (-1) $ max 0 undefined" ?
06:36:03 <qubitcoder> Question for any Emacs/Spacemacs users... Has anyone been able to show the type of a function in the auto-complete popup? I've played around with the company-mode show info options to no avail. :)
06:39:09 <nshepperd> hmm yeah, fmap (f . g) = fmap f . fmap g could depend on the correctness of the Ord instance there, at that
06:41:35 <xinming> When I /jo#git
06:41:37 <xinming> oops
06:41:38 <xinming> sorry
06:42:01 <sternenseemann> k0ral: well if you don't evaluate it, it won't crash your program
06:42:22 <k0ral> sternenseemann: not my point, let me rephrase it
06:42:26 <hexagoxel> k0ral: no. lazyness either computes a chunk or it does not; it won't give intermediate results such as "x | x >= 0"
06:43:04 <k0ral> sternenseemann: "min 0 $ max 1 anything" is 0 whatever "anything" is
06:44:09 <k0ral> hexagoxel: so I have to implement an alpha-beta like algorithm to get that behavior ?
06:44:24 <hpc> k0ral: depends on the Ord instance
06:44:44 <hexagoxel> and i don't think any form of dependent typing would change matters if (-1) and 0 are bound at runtime
06:45:19 <hpc> also, not all numbers are ordered
06:45:26 <k0ral> hpc: could you please clarify ?
06:45:34 <hpc> for instance, complex numbers
06:45:50 <k0ral> my question is about Int
06:46:16 <k0ral> (or Double if you like)
06:47:54 <hpc> in both cases, you need to evaluate that undefined, no matter what
06:48:14 <sternenseemann> k0ral: -1 is smaller than 0
06:49:12 <k0ral> it looks like I need to manipulate intervals rather than Int-s
06:49:59 <Gurkenglas> Does :t use mueval?
06:50:08 <Gurkenglas> (Lambdabot's.)
06:50:32 <hpc> no, it's an interaction with ghci
06:50:49 <hpc> (last i checked, which was a while ago)
06:51:14 <sternenseemann> k0ral: bla x y = if x == 0 then "bla" else show y
06:51:22 <sternenseemann> k0ral: bla x undefined works
06:51:32 <sternenseemann> k0ral: err, bla 0 undefined
06:51:39 <sternenseemann> k0ral: bla 2 undefined crashes
06:51:48 <sternenseemann> k0ral: if that was what you were looking for
07:00:10 * hackagebot origami 0.0.6 - An un-SYB framework for transforming heterogenous  data through folds  https://hackage.haskell.org/package/origami-0.0.6 (nedervold)
07:00:12 * hackagebot secp256k1 0.3.2 - secp256k1 bindings for Haskell  https://hackage.haskell.org/package/secp256k1-0.3.2 (xenog)
07:00:21 <Gurkenglas> I downloaded http://hackage.haskell.org/package/hint . I did stack init and stack install in its folder. How do I run examples/example.hs?
07:01:09 <Gurkenglas> (downloaded its tar.gz and unpacked it into a folder. Did the stack commands inside the unpacked folder, not the one I unpacked into.)
07:01:30 <Gurkenglas> (So tired of being bad at this basic interface stuff.)
07:03:21 <Gurkenglas> Ah, turning "stack ghc -O2 example.hs" into "stack ghc example.hs" made it work
07:05:08 <k0ral> sternenseemann: not exactly what I'm looking for
07:05:39 <sternenseemann> k0ral: then I don't get what you are looking for :D
07:05:47 <k0ral> sternenseemann: I have 2 functions involved, min and max, and when I compose them, I'd like the callee to be aware of the caller
07:06:44 <k0ral> sternenseemann: in "min a $ max b c", if max was somehow aware that it is called by 'min', it can avoid evaluating c if b is already greater than 'a'
07:07:46 <sternenseemann> k0ral: you could probably try to model something like that on the type level
07:08:08 <sternenseemann> k0ral: but that is not possible since max b c is not max b c for min but a value
07:08:19 <ggole> Surely since max does not do what you want, the straightforward path is to write something that does?
07:10:08 <ggole> Although I don't see how you can avoid the comparison. If you don't evaluate c, how do you know it isn't smaller than a?
07:13:22 <k0ral> ggole: do you agree that "min 0 $ max 1 c" is 0 whatever c is ?
07:14:33 <ggole> Oh, I see
07:15:12 <ggole> That's actually really obvious in hindsight -_-
07:26:13 <Gurkenglas> Where does Lambdabot get Natural?
07:26:21 <julianleviston> it can only be 0 whatever c is when viewed from a context above both of those functions, though‚Ä¶
07:26:35 <julianleviston> I realise s/he‚Äôs gone.
07:28:02 <int-e> Gurkenglas: the numbers package
07:30:07 <Gurkenglas> https://hackage.haskell.org/package/numbers-3000.2.0.1/docs/src/Data-Number-Natural.html should implement max lazily in the second argument.
07:32:25 <Gurkenglas> > min 2 $ max 3 (undefined :: Natural) -- Because then this would work
07:32:26 <lambdabot>  *Exception: Prelude.undefined
07:47:04 <KaneTW> @src max
07:47:04 <lambdabot> max x y = if x <= y then y else x
07:47:17 <KaneTW> how would you implement it lazily
07:48:20 <ARM9> I don't think you can unless you check if one is max/min bound
07:50:36 <KaneTW> even then
07:50:56 <KaneTW> max 3 undefined wouldn't work
07:51:19 <KaneTW> wouldn't make sense either
07:51:31 <ARM9> max 3 undefined?
07:52:22 <KaneTW> Gurkenglas' example above
07:53:11 <Gurkenglas> KaneTW, "max (S $ S $ S Z) undefined" ought to be "S $ S $ S $ undefined", because we know it is at least 3.
07:54:09 <KaneTW> eh
07:54:25 <KaneTW> not really
07:54:34 <Gurkenglas> Ya rly.
07:56:18 <KaneTW> let's say undefined is an io action that's blocking but later on evaluates to S Z
07:56:25 <KaneTW> you get an incorrect result
07:57:47 <KaneTW> otherwise you need to remove 3 S constructors from undefined and that requires pattern matching on it
07:57:50 <Gurkenglas> "max (S $ S $ S Z) <io action>" ought to be "S $ S $ S $ fmap (subtractwithminimumzero 3) <io action>"
07:58:16 <Gurkenglas> I simplified it to undefined above, because, yes, pattern matching on undefined gives undefined :D
07:59:26 <KaneTW> not really, case expressions force evaluation to whnf or they can't inspect the constructor
07:59:39 <KaneTW> it gives you a crash
07:59:47 <Gurkenglas> Right, and S $ S $ S $ undefined is in whnf
08:00:02 <KaneTW> except you inspect the undefined for the subtract thing
08:00:33 <Gurkenglas> And the subtract thing is inspected once someone asks whether it is larger than 3
08:00:47 <KaneTW> hm
08:00:51 <Gurkenglas> As opposed to the current implementation of max, which crashes once someone asks whether the result is larger than 0
08:01:40 <KaneTW> i guess that's ok
08:01:52 <KaneTW> i wouldn't put it in base though since that's kind of an edge case
08:02:17 <KaneTW> and usually strictness with stuff like that is nice for memory usage
08:02:18 <Gurkenglas> Natural isn't in base. Natural's whole point is lazy numbers
08:02:45 <KaneTW> i see
08:05:22 <Gurkenglas> Requesting "Monad m => ([a] -> m a) -> a -> m [a]" that works like the "([a] -> a) -> a -> [a]": "\f x -> fix $ set _head x . map f . inits", but doesn't do the monadic effects multiple times. Do I need MonadFix for this?
08:07:47 <hpc> Gurkenglas: it's hard to understand how that would work, perhaps an example with IO?
08:08:31 <Gurkenglas> Sure, here's one that discards most of the usefulness of the combinator I think:
08:10:24 <hpc> it does look like MonadFix is going to be needed though, just at a glance
08:11:41 <Gurkenglas> f = \xs -> print (length xs) >> return (length xs); x = 0 leads to a printout of unlines . map show [0..] and a return of [0..]
08:12:39 <Gurkenglas> (...would be nice if only the head is printed if you inspect the head...)
08:13:01 <Gurkenglas> Hmm, probably has to be [m a] in the return type of the requested function then i guess
08:15:36 * hackagebot tersmu 0.2.1 - A semantic parser for lojban  https://hackage.haskell.org/package/tersmu-0.2.1 (mbays)
08:22:34 <SrPx> I'm doing some ascii art animation using the terminal, a loop and thread delay. Is there any way to keep my animation on the middle of the terminal, instead of flooding it with the frames?
08:22:58 <SrPx> I.e., can I count the number of rows on the terminal from haskell, as to correctly calculate the number of empty lines I must print to "clear" it?
08:23:04 <ARM9> SrPx https://en.wikipedia.org/wiki/ANSI_escape_code#CSI_codes
08:23:58 <ARM9> or try out some haskell ncurses bindings, should be more portable because windows cmd/powershell don't work with ansi escape codes by default for example.
08:24:44 <SrPx> Don't care a lot for portability, it is just for me
08:25:03 <ARM9> then the csi codes should suffice, they're very simple and requires little setup
08:25:11 <ARM9> if your terminal supports them that is
08:29:37 <eriksensei> where do stack or cabal sandbox store the source files of dependencies? I just did 'mdfind Monad.hs' on my mac and it came up pretty much empty
08:30:10 <mungojelly> that is just the same question i was about to ask!
08:30:44 <eriksensei> mungojelly: a miracle indeed! :)
08:30:58 <mungojelly> we're in a "where does cabal put dependencies" cycle in the unknown secret rhythms underlying society, or coincidence, w/e
08:31:15 <glguy> Cabal doesn't keep the .hs files around for installed packages
08:31:49 <eriksensei> mungojelly: whichever it is, our inquiry proves fruitful :) 
08:32:19 <eriksensei> glguy: so if we wanted to navigate to source files in our respective editors, is there a feature for that in stack/cabal or something?
08:32:48 <eriksensei> in SBT i can say 'get sources as well', which is quite convenient
08:32:58 <SrPx> ARM9: I'm not sure what you mean, what code exactly helps me there?
08:33:03 <eriksensei> (sbt is a scala tool btw)
08:33:36 <glguy> You can download and unpack a copy of a package with "cabal get packagename"
08:33:48 <ARM9> SrPx CSI n ; m H	CUP ‚Äì Cursor Position
08:33:53 <eriksensei> and that would stick it in a default location?
08:34:00 <glguy> the current directory
08:34:02 <eriksensei> somewhere in the project dir?
08:34:03 <eriksensei> ahh
08:34:16 <SrPx> ARM9: but the issue is exactly calculating those constants, right?
08:34:19 <SrPx> The default name when I type cabal comes out wrong. What can I do?
08:34:27 <glguy> You can install documentation for a package with hyperlinked source (that won't help to open it in your editor)
08:34:33 <eriksensei> interesting‚Ä¶ thanks! seems a bit of a shame that there's nothing a little structured than that though
08:35:45 <glguy> The hyperlinked source is pretty convenient; clicking on an identifier jumps to its definition
08:37:20 <eriksensei> glguy: yeah, i usually do that on the hackage website, but I'd like to reify all of the links and do something useful with them, IDE-wise, so it won't be of much help in my case
08:38:46 <Gurkenglas> Is there a list of all tokens pl will introduce in its output?
08:38:55 <SrPx> Also, is there any analogue of deepseq, except monadic? 
08:39:27 <SrPx> evaluated <- evaluate term
08:40:04 <hpc> that's not deep
08:40:05 <glguy> (evaluate . force)
08:44:14 <Romefeller> Hello all
08:46:10 <Gurkenglas> Is there an arbitrarily long combination of (.), id and flip that doesn't typecheck?
08:46:34 <Gurkenglas> (How large can we make the set of functions with this property?)
08:48:20 <Gurkenglas> Or even a term made from the three?
08:50:39 <Romefeller> :t liftIO
08:50:40 <lambdabot> MonadIO m => IO a -> m a
08:50:49 * hackagebot microlens-mtl 0.1.6.0 - microlens support for Reader/Writer/State from mtl  https://hackage.haskell.org/package/microlens-mtl-0.1.6.0 (Artyom)
08:55:49 * hackagebot microlens-platform 0.1.5.0 - Feature-complete microlens  https://hackage.haskell.org/package/microlens-platform-0.1.5.0 (Artyom)
09:15:50 <phaazon> is there a way to know the version of the library / app we‚Äôre building through CPP?
09:15:51 * hackagebot ncurses 0.2.14 - Modernised bindings to GNU ncurses  https://hackage.haskell.org/package/ncurses-0.2.14 (JohnMillikin)
09:15:53 <phaazon> or that kind of thing?
09:16:05 <phaazon> like MIN_package(x,y,z)
09:16:11 <phaazon> but for the current version of the package being built?
09:31:42 <Aeroblop> Hey guys, can anyone help me with some Haskell?
09:32:17 <ChristianS> Aeroblop: probably, but only if you ask your question
09:32:48 <Aeroblop> Ok, so I'm trying to implement a function that flattens a cyclic digraph depth first
09:33:12 <Aeroblop> so the first thing I'm trying to suss out is to flatten a simple digraph (no cycles)
09:33:51 <Aeroblop> But, I'm having trouble with it. Should I send a pastebin link or something with my code in it??
09:34:01 <glguy> ?lpaste
09:34:01 <lambdabot> Haskell pastebin: http://lpaste.net/
09:34:29 <magneticduck> this is what happens when you suck at handing data
09:34:31 <magneticduck> http://www.snopes.com/autos/law/noplate.asp
09:35:10 <Aeroblop> http://lpaste.net/8196375558867648512
09:36:17 <Aeroblop> I started out with simply implementing functions with Chars, but eventually I want to have them all polymorphic
09:37:14 <glguy> Aeroblop: As a quick aside, what's this if-then-else doing for you? if c `elem` ns then True else False
09:38:09 <MarcelineVQ> magneticduck: "we don't want to fix it. please just change what you write, law enforcers of the entire country, that'll solve it" :X
09:38:14 <Aeroblop> glguy, the way I was doing it was by storing all previously visited nodes (so that it wouldn't carry on with a cycle), so the c `elem` ns was to check if a value was in my previously visited nodes
09:38:37 <SrPx> What is the url of that new hackage version? The interactive one?
09:38:50 <SrPx> hoogle*
09:39:27 <glguy> Aeroblop: Sure, but look and what the if-then-else part is doing with the result of c`elem`ns
09:41:07 <Aeroblop> glguy: it's simply returning False? It's just a boolean check. (I've only been doing functional programming for about 3 weeks and get quite confused.)
09:41:19 <Aeroblop> Is there something it's doing that I'm overseeing?
09:41:21 <glguy> if b then True else False is the same as just: b
09:41:41 <Aeroblop> oh silly me
09:42:05 <Aeroblop> I can simply change it from   if c `elem` ns then True else False   to  c `elem` ns
09:42:07 <glguy> when people are learning haskell they don't always think of if-then-else as an expression but more like a control structure
09:42:37 <Aeroblop> Thanks for pointing that out.
09:43:28 <glguy> So what's your question about your code?
09:43:57 <Aeroblop> I don't know how to implement this function whatsoever, the more and more I do, the more and more I get confused about it
09:44:07 <padre_angolano> Œæ
09:44:13 <padre_angolano> sorry
09:44:17 <Aeroblop> I so badly just want to have local variables, but obviously the language doesn't allow that
09:44:33 <Aeroblop> So I've read into accumulating parameters a bit, but I'm having trouble implementing them
09:45:22 <Aeroblop> so yeah, I basically have no idea how to really implement a solution for this problem.
09:47:22 <Aeroblop> And any help would be greatly appreciated.
09:48:42 <glguy> Your 'trav' definition has the appropriate type. You have the names you've seen so far and the nodes remaining to check
09:49:09 <glguy> When you get to a node you have two possibilities, you've seen it before or you haven't
09:50:07 <glguy> so you should branch at that point and think about what to do in each case separately
09:50:22 <glguy> Your first case of no more nodes is fine
09:50:27 <Aeroblop> so if I've seen the node before, I don't carry on look at it's child nodes
09:50:34 <Aeroblop> and if I have seen it before I do explore it
09:50:52 <glguy> right, you explore after recording that you've now seen that node
09:50:53 <Aeroblop> I understand that - it's just the actual implementation of it
09:51:15 <glguy> well, update your code to have the branch and then let's focus on the case where you've already seen the node
09:51:39 <Aeroblop> would that be using guards?
09:51:48 <Aeroblop> or simply two pattern matches?
09:51:49 <glguy> Sure, guards would be good here
09:52:23 <Aeroblop> Ok, let me have a play and I'll get back to you. Thanks man!
09:52:25 <glguy> You don't really need any of the helper functions defined above trav to implement this, so lets ignore them for now
09:52:45 <glguy> One thing before you go
09:53:03 <Aeroblop> Ok
09:53:09 <glguy> You can write:   trav cs (Node n cs : ns) = in that second case if you want
09:53:13 <glguy> (you probably knew that)
09:53:23 <Aeroblop> I didn't
09:53:25 <Aeroblop> lol
09:53:29 <Aeroblop> that's gonna help...
09:53:44 <Aeroblop> I was trying to get something like that
09:54:09 <Aeroblop> so (Node n cs : ns) is a list of nodes
09:54:20 <Aeroblop> like (n:ns)
09:54:23 <glguy> Yup, with the first one deconstructed
09:54:32 <Aeroblop> but with "n" you're splitting up even more
09:54:50 <glguy> another trick you might not have thought of that is a handy general optimization:
09:55:01 <glguy> instead of repeatedly appending to the end of a list (slow)
09:55:12 <glguy> You can cons onto the front of the list and reverse it at the end
09:55:31 <Aeroblop> what's the difference? and how does the implementation differ?
09:55:59 <glguy> To append to the end of a list you have to match all the way to the end of the list, each time you do that it gets slower
09:56:12 <Hijiri> adding it to the end takes O(n) time, so doing it with n elements is O(n^2) time
09:56:20 <Hijiri> reversing is O(n) so that is cheaper
09:56:43 <Aeroblop> ah ok
09:56:51 <Aeroblop> so how would that differ in implementation?
09:57:40 <kadoban> Aeroblop: You'd simply construct the result list in the "wrong" order using (:) to add an element, and then reverse it at the end.
09:58:09 <Aeroblop> instead of using ++ ?
09:58:19 <kadoban> Usually either you can do it in the [] case, or sometimes you need a wrapper.  Yes.
09:58:38 <kjcwncsdr> www.buzzfeed.co.il   -   free sex   www.buzzfeed.co.il   -   free sex  www.buzzfeed.co.il   -   free sex   www.buzzfeed.co.il   -   free sex  www.buzzfeed.co.il   -   free sex   www.buzzfeed.co.il   -   free sex  www.buzzfeed.co.il   -   free sex   www.buzzfeed.co.il   -   free sex  
09:59:09 <kjcwncsdr> www.buzzfeed.co.il   -   free sex   www.buzzfeed.co.il   -   free sex  www.buzzfeed.co.il   -   free sex   www.buzzfeed.co.il   -   free sex  www.buzzfeed.co.il   -   free sex   www.buzzfeed.co.il   -   free sex  www.buzzfeed.co.il   -   free sex   www.buzzfeed.co.il   -   free sex  www.buzzfeed.co.il   -   free sex   www.buzzfeed.co.il   -   free sex  www.buzzfeed.co.il   -   free sex   
09:59:09 <kjcwncsdr> www.buzzfeed.co.il   -   free sex  www.buzzfeed.co.il   -   free sex   www.buzzfeed.co.il   -   free sex  
09:59:19 <dmj> @where ops
09:59:20 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
10:01:39 <jamesfordummies> I am confused: I am returning an array ([a]) into the IO monad specified by the signature, no? http://lpaste.net/143784
10:03:05 <dutchie> :t when
10:03:06 <lambdabot> Applicative f => Bool -> f () -> f ()
10:03:08 <int-e> jamesfordummies: "return" isn't what you're used to.
10:03:17 <int-e> :t return
10:03:18 <dutchie> also, that
10:03:19 <lambdabot> Monad m => a -> m a
10:03:30 <mpickering> Which stages of the GHC optimiser are tuned to  deal with the State monad?
10:03:50 <jamesfordummies> yes, I thought return would take an [a] and wrap it in the IO monad in this case
10:03:54 <monochrom> I need to see the ".. more .." part. it completely determines the final type
10:03:54 <jamesfordummies> int-e
10:04:54 <jamesfordummies> monochrom: http://lpaste.net/143785
10:04:59 <andromeda-galaxy> jamesfordummies: 'return result' has type IO [a], but when (in this case) comes out to be Bool -> IO () -> IO ()
10:05:12 <int-e> jamesfordummies: That's what it does, but you're passing that IO [a] to 'when' which wants an IO (). "return" does not skip to the end of the do block or anything like that.
10:05:24 <jamesfordummies> oh
10:05:28 <jamesfordummies> i see
10:06:09 <jamesfordummies> so I need to use an if-else
10:06:27 <int-e> yes.
10:06:40 <jamesfordummies> thanks all!
10:07:21 <int-e> jamesfordummies: or perhaps give a definition for  tryGetNum 0 chan result  and another one for the other values
10:07:45 <jamesfordummies> ah
10:07:59 <jamesfordummies> int-e: of course, why didn‚Äôt I see that
10:08:35 <int-e> I think it's called learning :)
10:08:57 <jamesfordummies> :P
10:11:57 <Aeroblop> glguy: It works!
10:12:18 <Aeroblop> trav :: [Char] -> [Node Char] -> [Char]
10:12:25 <Aeroblop> trav cs [] = cs
10:12:26 <Aeroblop> trav cs (Node n rs : ns) = n : trav cs rs ++ trav cs ns
10:12:50 <glguy> Aeroblop: That's pretty close
10:13:07 <Aeroblop> It doesn't deal with cycles
10:13:32 <Aeroblop> and I'm pretty sure I haven't done the cons onto front of list
10:13:42 <Aeroblop> so it's not optimised
10:13:52 <glguy> Yo never actually added anything to the cs list
10:15:12 <Aeroblop> trav cs (Node n rs : ns) = n : trav (cs++n) rs ++ trav (cs++n) ns ??
10:18:53 <Aeroblop> glguy?
10:19:02 <Aeroblop> would the above change do it?
10:19:53 <monochrom> cs++n would be a type error. cs++[n] may be better.
10:20:39 <Aeroblop> ah of course
10:20:44 <Aeroblop> would cs:n be better?
10:20:53 <monochrom> no, cs:n is also a type error
10:21:27 <Aeroblop> what's the difference between : and ++ ?
10:21:31 <benzrf> :t (:)
10:21:32 <lambdabot> a -> [a] -> [a]
10:21:35 <benzrf> :t (++)
10:21:36 <lambdabot> [a] -> [a] -> [a]
10:21:42 <monochrom> they have different types
10:21:53 <benzrf> more to the point, they do different things
10:22:36 <Aeroblop> so you could do n:cs?
10:22:42 <monochrom> yes
10:23:12 <Aeroblop> and you can do [n]++cs, cs++[n] and n:cs
10:23:17 <monochrom> yes
10:23:21 <Aeroblop> what about a:b:cs?
10:23:34 <monochrom> yes. it means a:(b:cs)
10:23:42 <Aeroblop> curried function, right?
10:24:13 <monochrom> no. just good old infix syntax and right-associative
10:24:20 <Aeroblop> ah ok
10:24:22 <Aeroblop> thanks
10:52:33 <padre_angolano> what's the simplest way to convert from UTF-8 hex code to Char? like '\xAABB', but for UTF-8 rather than haskell's internal unicode
10:53:02 <hpc> UTF8 is a byte encoding for unicode
10:53:07 <hpc> unicode defines the codepoints
10:53:43 <hpc> so it's the same
10:53:50 <EvanR> yeah thats not haskells internal unicode
10:53:55 <hpc> specifically, it's not different
10:53:57 <hpc> ;)
10:54:15 <sternenseemann> padre_angolano: if you want to have to control over the encoding you probably want to use text
10:54:27 <EvanR> dont specify characters with utf8 bytes
10:54:28 <Lokathor> you can put the bytes into a bytestring
10:54:41 <Lokathor> and then use the Text package to decode that bytestring into something useful
10:54:46 <padre_angolano> sternenseemann: no, I'm just trying to visualize a char that is shown in hex by 'hexdump'
10:54:47 <Lokathor> ...(i think)
10:55:24 <EvanR> padre_angolano: http://software.hixie.ch/utilities/cgi/unicode-decoder/utf8-decoder
10:55:30 <marchelzo> convert it to to an Int and then use Data.Char.chr? maybe I'm misunderstanding
10:55:35 <marchelzo> s/to to/to/
10:55:40 <sternenseemann> padre_angolano: then you'll probably just have to parse the hex number and use chr
10:55:43 <EvanR> marchelzo: no way
10:55:54 <padre_angolano> OK, trying now...
10:56:20 <sternenseemann> padre_angolano: oh, nope that is wrong I think
10:56:31 <glguy> If you have UTF-8 encoded bytes and you want to see the corresponding Char you'll need a UTF-8 decoder like the one that Text uses or the function in the utf8-string package
10:56:41 <sternenseemann> padre_angolano: still easiest way would be to parse the bytes into a ByteString and use Data.Text.decodeUtf8
10:57:11 <marchelzo> ah, right. I was thinking it was a single-byte character
10:57:51 <Lokathor> marchelzo, sadly that's often not the case my friend
10:58:16 <marchelzo> it's very sad indeed
11:00:10 <padre_angolano> sternenseemann, hdc: OK, I'm trying the greek letter Œ¶. To get it's UTF-8 hex code, I do 'echo -n Œ¶|hexdump -C' and get 'ce a6'. But if I do 'putChar (Data.Char.chr 0xcea6)' in ghci, I get a different char (actually, an empty box)
11:00:51 <sternenseemann> padre_angolano: tried decodeUtf8?
11:00:58 <Lokathor> ghci might not know how to show it
11:01:11 <Lokathor> based on the font and/or codepage your terminal is using
11:01:22 <glguy> To print that you'd use:   putChar 'Œ¶'    or   putChar (chr 934)
11:01:24 <padre_angolano> sternenseemann: moreover, Text.Printf.printf "%x\n" (Data.Char.ord 'Œ¶') gives me another code -- 0x03a6
11:01:37 <glguy> or putChar '\x3a6'
11:02:05 <padre_angolano> yeah, putChar '\x3a6' does this, but 03a6 is not the utf code of this char
11:03:06 <padre_angolano> So, Data.Char.ord and Data.Char.chr don't work with UTF-8 and require different codes
11:03:09 <glguy> Right, UTF-8 is just an encoding of the codepoint's actually value of 0x3a6
11:03:45 <glguy> http://www.fileformat.info/info/unicode/char/03a6/index.htm
11:04:13 <hpc> padre_angolano: "don't work" is a misnomer
11:04:24 <hpc> they operate in the domain of codepoints, not bytes
11:04:25 <sternenseemann> padre_angolano: that's the issue with different encodings
11:05:09 <padre_angolano> so, I'm trying to figure out with decoding function I can use so that Char.chr(decode(0xcea6)) == 'Œ¶'
11:05:26 <padre_angolano> * which decoding function
11:06:12 <padre_angolano> obviously, I can feed a character to Data.Text.decodeUtf8, but I want to do this with a hex code 
11:06:57 <kadoban> padre_angolano: This is probably a dumb question, but ‚Ä¶ why?
11:07:08 <Azel> I'd say transform your two bytes into a bytestring, use decodeUtf8 and take the first character of the resulting Text
11:07:18 <glguy> padre_angolano: You'll have to build such a thing, it doesn't exist anywhere common as you've specified
11:07:28 <padre_angolano> kadoban: just to visualize a char I find in hexdump's output
11:07:43 <glguy> UTF-8 is a byte encoding so it's never implemented to take a single number as a UTF-8 encoding like that
11:07:51 <Azel> But you're better off working from codepoints if you want to transform numbers in chars. For one thing, they're actually numeric values
11:11:44 <Azel> padre_angolano: Why not read hexdump's output into a ByteString and decode the whole thing in one go then? But you perhaps have to make sure that you really have UTF-8 first...
11:15:58 * hackagebot secp256k1 0.4.0 - secp256k1 bindings for Haskell  https://hackage.haskell.org/package/secp256k1-0.4.0 (xenog)
11:17:08 <padre_angolano> > putStrLn (Data.Text.unpack (Data.Text.Encoding.decodeUtf8 (Data.ByteString.pack [0xce, 0xa6])))
11:17:09 <lambdabot>  Not in scope: ‚ÄòData.Text.unpack‚ÄôNot in scope: ‚ÄòData.Text.Encoding.decodeUtf8...
11:17:53 <padre_angolano> OK, I figured it out. 'putStrLn (Data.Text.unpack (Data.Text.Encoding.decodeUtf8 (Data.ByteString.pack [0xce, 0xa6])))' does what I wanted (outputs UTF-8 char with hex code 0xCEA6
11:18:42 <glguy> That's what sternenseemann said about 25 minutes ago :)
11:18:55 <padre_angolano> I was hoping that it can be done easier with something like 'Data.Char.UTF.chr 0xcea6'
11:19:03 <sternenseemann> glguy: lol :D
11:19:44 <padre_angolano> yes, thanks to sternenseemann and others :-)
11:19:53 <sternenseemann> padre_angolano: happy to help
11:20:16 <EvanR> padre_angolano: its not outputting a "utf8 char"
11:20:52 <padre_angolano> EvanR: ok, it decodes a utf-8 sequence :-)
11:21:25 <EvanR> yes ByteString -> Char
11:31:33 <SiIky> whats the function (im assuming its in Data.Char) that converts a string into an Int?
11:33:17 <tzh> SiIky: you probably want `read` or maybe `reads`
11:34:22 <padre_angolano> aha, the easy function I was looking to is Codec.Binary.UTF8.String.decode [0xce, 0xa6] from the package utf8-string
11:35:46 <EvanR> really the text function is better
11:35:53 <EvanR> more conventional now i think
11:36:03 <padre_angolano> EvanR: but longer :-)
11:36:15 <SiIky> tzh thx
11:36:25 <EvanR> well ... i wouldnt exactly want to spell out of the full path each time
11:36:37 <EvanR> even if i didnt put whatever this operation is into its own function
11:37:14 <EvanR> (show . decodeUtf8 . BS.pack) bytes
11:38:39 <padre_angolano> show escapes the non-ascii char, so 'putStr . unpack . decodeUtf8 . BS.pack'  :-)
11:39:01 <EvanR> i wouldnt bake in the putrStrLn either
11:39:35 <EvanR> show doesnt escape anything
11:39:47 <EvanR> or does it
11:40:02 <EvanR> > "\0" !! 0
11:40:04 <lambdabot>  '\NUL'
11:40:13 <padre_angolano> > "–ø—Ä–∏–≤–µ—Ç"
11:40:14 <EvanR> > (show "\0") !! 0
11:40:15 <lambdabot>  "\1087\1088\1080\1074\1077\1090"
11:40:16 <lambdabot>  '"'
11:40:39 <EvanR> > (show "\0") !! 1
11:40:43 <lambdabot>  '\\'
11:40:49 <EvanR> right
11:42:01 <EvanR> padre_angolano: if the goal is to basically take some utf8 data, decod it, convert it back to utf8 for output and display on the terminal theres an even easier way
11:42:31 <EvanR> BS.putStrLn 
11:43:00 <EvanR> BS.putStrLn [0xce, 0xa6]
11:43:12 <EvanR> ah, gotta pack
11:43:56 <padre_angolano> EvanR: for me it outputs garbage to the screen if I don't do decodeUtf8
11:44:02 <cnd_> Hi
11:44:08 <cnd_> What do people usually use Haskell for?
11:44:18 <EvanR> padre_angolano: windows?
11:44:25 <Cale> cnd_: Writing programs
11:44:33 <Cale> cnd_: It's pretty general purpose
11:44:35 <padre_angolano> EvanR: ah, not it worked
11:44:36 <cnd_> Why use it instead of Python?
11:44:40 <padre_angolano> EvanR: ah, no, it worked
11:44:46 <padre_angolano> Data.ByteString.Char8.putStrLn (Data.ByteString.pack [0xce, 0xa6])
11:44:48 <cnd_> I‚Äôm trying to pick my first language
11:44:57 <EvanR> padre_angolano: you dont need Char8
11:45:01 <cnd_> I mainly need to interact with Raspberry Pi
11:45:08 <padre_angolano> ah, ok :-)
11:45:15 <suppi> cnd_, It won't matter much what you learn. you just need quality material
11:45:29 <suppi> cnd_, It won't matter much what you learn. you just need quality material
11:45:31 <EvanR> padre_angolano: alternative paste your hex into that website i linked
11:45:45 <cnd_> ok
11:45:46 <Cale> cnd_: Right now I'm working for a company and we're building a web service for a client, and using Haskell for both the backend (using Snap to build the webserver), and frontend (using reflex-dom and GHCJS, compiling Haskell to Javascript to run in the browser)
11:45:46 <cnd_> thanks
11:45:57 <EvanR> suppi: welcome to haskell where your questions are answered in magnificent stereo !
11:46:02 <suppi> cnd_, Haskell, Python, Racket, pick your poison :)
11:46:03 <cnd_> Haha
11:46:03 <padre_angolano> EvanR: right, thanks for the link
11:46:08 <cnd_> this is also my first 10 minutes on IRC ever
11:46:50 <Cale> EvanR: That quote is more appropriate when different people are answering in the same way, rather than the same person accidentally posting a message twice though ;)
11:46:52 <suppi> EvanR, it was an echo, not stereo
11:48:09 <EvanR> Cale: ah i thought that was iambic pentameter or something ;)
11:48:12 <Cale> cnd_: There are a lot of financial companies which are using Haskell for building analysis tools. There are a bunch of people interested in writing games in Haskell, and some interesting approaches there.
11:48:13 <suppi> cnd_, and I'm working on an emulator in Haskell (video: https://www.youtube.com/watch?v=WzFXH5XzN7A)
11:48:38 <cnd_> I see
11:48:49 <cnd_> I‚Äôm building something on Raspberry Pi hardware
11:48:55 <cnd_> to parse SMS strings
11:49:10 <cnd_> In reality, I need to find a developer to join my team
11:49:19 <cnd_> but I‚Äôm trying to learn enough to know which kind of developer I need
11:50:41 <Cale> There are people using Haskell as a metalanguage to write programs for microcontrollers -- e.g. Tom Hawkins at Eaton built a domain specific language called atom (https://hackage.haskell.org/package/atom) in Haskell for writing realtime embedded software, and used that to build control software for hybrid hydraulic vehicles.
11:51:10 <Cale> That's not Haskell code directly running on the microcontrollers, but programs which were the result of running Haskell programs :)
11:51:40 <cnd_> But Python is more ubiquitous, no?
11:51:43 <EvanR> rpi is kind of high end for that approach
11:52:02 <cnd_> I‚Äôm worried about recruiting a developer in an esoteric language, then having problems finding people who can also build in that language
11:52:07 <cnd_> to help later on
11:52:28 <Cale> cnd_: Well, there are certainly more people who know Python than Haskell
11:52:33 <EvanR> PHP is even more ubuiqitous
11:52:39 <cnd_> got it
11:52:51 <cnd_> I know absolutely nothing about any of this, if that‚Äôs not obvious
11:52:53 <cnd_> thank you!
11:53:43 <EvanR> and more esoteric ;)
11:58:25 <TheLab_> Hey Guys
11:58:28 <codehero> hey
11:58:45 <codehero> huh
11:58:47 <codehero> how can i start a process in the background from within haskell?
11:58:58 <codehero> spawnProcess "htop" [] doesn't work
11:59:27 <superturrican> guys how do I go about going from "solving cute haskell exercises" to "full fledged programs"
11:59:57 <marchelzo> step 1. decide what you want to make
12:00:56 <Taneb> step 2. try really hard to make it without giving up
12:01:08 <scshunt> step 3. throw out the prototype and do it again using what you learned to avoid mistakes
12:01:20 <scshunt> codehero: are you sure?
12:01:31 <scshunt> codehero: htop might be quitting if it's not attached to a terminal, since it's a graphical program
12:01:33 <codehero> scshunt: yeah. it just takes over the terminal
12:01:43 <scshunt> codehero: or that
12:02:01 <EvanR> how did you guys do that sequence?
12:02:03 <scshunt> codehero: you don't have a haskell problem, you have a terminal problrm ;)
12:02:06 <EvanR> is it from somewhere?
12:02:16 <codehero> well. i actually want to start a detached tmux session, but i thought that htop would be a simpler example
12:02:38 <EvanR> you want to spawn another terminal window
12:02:46 <EvanR> not as simple as another process
12:03:00 <scshunt> codehero: your first challenge is
12:03:07 <scshunt> "how do you spawn a detached tmux session"
12:03:20 <codehero> tmux new -d -s session
12:03:20 <scshunt> if you don't know how to do that period, you don't know how to do it in haskell
12:03:45 <scshunt> then why not spawnProcess "tmux" ["new", "-d", "-s", "session"]?
12:03:46 <codehero> and that works on the terminal
12:03:51 <codehero> but not when i do it from haskell
12:03:55 <codehero> well. i tried that
12:05:31 <EvanR> running commands from a shell on a terminal is a different thing than spawning a process from a normal (non-shell) program
12:05:37 <codehero> hm
12:05:38 <EvanR> you basically need to act like a shell
12:05:51 <scshunt> yeah, you need to figure out what tmux is expecting and what's different
12:05:54 <scshunt> terminals are complex
12:06:01 * hackagebot phizzle 0.1.0.2 - Library for checking if a given link is in a phishtank json file  https://hackage.haskell.org/package/phizzle-0.1.0.2 (bmcg)
12:06:11 <codehero> scshunt: okay
12:06:40 <EvanR> try to run a shell command instead of spawning a process
12:07:25 <EvanR> callCommand :: String -> IO ()
12:07:27 <codehero> okay
12:10:00 <jay6981> hi folks. i'm working thru learn you a haskell. can someone patiently explain how this list comprehension stuff works?
12:10:26 <jay6981> specifically the difference between [¬†(a,b,c)¬†|¬†c¬†<-¬†[1..10],¬†b¬†<-¬†[1..10],¬†a¬†<-¬†[1..10]¬†] and [¬†(a,b,c)¬†|¬†c¬†<-¬†[1..10],¬†b¬†<-¬†[1..c],¬†a¬†<-¬†[1..b] ]
12:10:44 <codehero> > [¬†(a,b,c)¬†|¬†c¬†<-¬†[1..10],¬†b¬†<-¬†[1..10],¬†a¬†<-¬†[1..10]¬†]
12:10:46 <lambdabot>  [(1,1,1),(2,1,1),(3,1,1),(4,1,1),(5,1,1),(6,1,1),(7,1,1),(8,1,1),(9,1,1),(10...
12:10:46 <codehero> hm
12:10:54 <codehero> > [¬†(a,b,c)¬†|¬†c¬†<-¬†[1..10],¬†b¬†<-¬†[1..c],¬†a¬†<-¬†[1..b] ]
12:10:56 <lambdabot>  [(1,1,1),(1,1,2),(1,2,2),(2,2,2),(1,1,3),(1,2,3),(2,2,3),(1,3,3),(2,3,3),(3,...
12:11:49 <codehero> EvanR: callCommand worked. thank you :)
12:11:59 <Aeroblop> the first one has 1000 items, second one 220
12:13:02 <jay6981> i'm not really understanding the syntax. c is list from 1 to 10, b is a list from 1 to c?
12:13:17 <kadoban> jay6981: Make it smaller, and look at the pattern.
12:13:23 <kadoban> > [(a, b) | a <- [1..3], b <- [1..a]]
12:13:25 <lambdabot>  [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3)]
12:13:28 <kadoban> > [(a, b) | a <- [1..3], b <- [1..3]]
12:13:30 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
12:13:54 <kadoban> Note in the first one that there's no (1,2) or (1,3)
12:13:57 <jay6981> i see that empirically too
12:15:03 <jay6981> having trouble comprehending what [1..a] means
12:15:05 <Hijiri> jay6981: c, b, and a represent one element from the list
12:15:15 <Hijiri> their respective lists
12:15:20 <suppi> what is the simplest way to write web apps in Haskell or a Haskell-like language? is it haste? purescript? elm?
12:15:28 <Hijiri> so you go through each element in [1..10] and call it c
12:15:34 <EvanR> a will be substituted with values from the list its defined as
12:15:37 <Hijiri> and then each time you get a c, you go through each element in [1..c]
12:15:39 <Hijiri> and call it b
12:15:51 <Hijiri> and then the same for a from [1..b]
12:16:26 <jay6981> ahhhh‚Ä¶. ok i think the light bulb above my head just got dim (not bright yet, but i'm starting to see it) :)
12:16:54 <andromeda-galaxy> jay6981, if you're coming from an imperative background, I believe that this is approximately correct: [(a,b) | a <- [1..3], b <- [1..a]] ==> (imperatively) for a in range(1,3) { for b in range (1, a) { list.append((a,b)) } }
12:17:08 <andromeda-galaxy> (conceptually speaking, anyway)
12:17:40 <jay6981> perfect! thanks Hijiri and andromeda-galaxy
12:17:58 <andromeda-galaxy> jay6981: happy to help
12:18:04 <kadoban> > do {a <- [1..3]; b <- [1..a]; return (a, b)}
12:18:05 <lambdabot>  [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3)]
12:18:20 <kadoban> Not sure if that's actually helpful or just confusing, but that's another way to write it ^
12:18:35 <jay6981> ++andromeda-galaxy
12:18:49 <jay6981> andromeda-galaxy++
12:20:45 <EvanR> its a possible imperative implementation of the list comprehension syntax
12:20:53 * Paradox__ starting to learn haskell, having trouble with types X(
12:20:58 <EvanR> now im trying to figure out how to explain it without such a thing
12:21:26 <andromeda-galaxy> EvanR: isn't kadoban's example just using the [] monad?
12:21:31 <lispy> Paradox__: that's a normal feeling. Hang in there and I'm sure you'll get it sorted
12:21:47 <EvanR> andromeda-galaxy: which is another implementation
12:22:35 <jay6981> another question: when you use :t in ghci‚Ä¶ is there a difference between t and a?
12:22:38 <andromeda-galaxy> EvanR: of course, I was just a little bit confused by your "imperative" mention
12:22:49 <jay6981> like sometimes you'll see foo :: (t -> t) -> t -> t
12:22:56 <EvanR> andromeda-galaxy: as far as explanations go, you probably really dont want to explain it as a list monad ;)
12:22:57 <jay6981> or foo :: (a -> a) -> a -> a
12:23:06 <Sagi> is anything the matter with the doc builder for hackage? I'm missing documentation for a recently update package (recent being yesterday)
12:23:08 <andromeda-galaxy> EvanR: true
12:23:24 <Sagi> the status page looks fine
12:23:25 <EvanR> andromeda-galaxy: i was talking about your explanation
12:23:45 <Sagi> or well, at least the one mentioned in the topic :) Not sure if there's more
12:23:46 <andromeda-galaxy> EvanR: ah, that makes sense
12:24:27 <andromeda-galaxy> jay6981: I believe that the name of the type variable doesn't matter for the type signature, but I don't know how GHC chooses names for inferred signatures
12:24:29 <EvanR> its possible to assign a meaning to list comprehensions without an example implementation, one that all implementations must satisfy if done right
12:24:38 <EvanR> i just cant think of it right now
12:25:04 <jay6981> andromeda-galaxy: yeah, when I let ghci infer the prototype, i got t
12:25:49 <EvanR> jay6981: another way to display it is forall t . (t -> t) -> t -> t, this way you can see that t is bound
12:26:02 <EvanR> and its equivalent to forall a . (a -> a) -> a -> a by alpha conversion
12:26:33 <EvanR> the forall is dropped most of the time 
12:26:43 <EvanR> but you need it to do Rank N types 
12:27:11 <Paradox__> No instance for (Integral Double)... what does that mean?
12:27:16 <andromeda-galaxy> ({-# LANGUAGE ExplicitForAll #-} lets you write it at any time, but its most useful for RankNTypes or ExistentialQuantification)
12:27:34 <EvanR> Paradox__: you probably tried to do div or mod on doubles
12:27:43 <Zekka> Paradox__: Haskell thought that for your  code to work, it would need doubles to be a kind of integer
12:27:45 <jay6981> is there a good reference i can use in concert with learn you a haskell?
12:27:51 <Zekka> but since they're not it can't make your code work
12:28:07 <jay6981> like how k&r has the tutorial and the language spec in the same book
12:28:39 <EvanR> jay6981: in that case, theres the haskell report
12:28:43 <andromeda-galaxy> jay6981: Hmm, I don't know---there's always the GHC Manual & the Haskell 97 Report, but those can be a bit dense sometimes...
12:28:46 <nitrix> jay6981: adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
12:29:07 <tpsinnem> if i do "cabal install --enable-profiling --enable-library-profiling --ghc-options="-auto-all -caf-all -fprof-auto -fprof-auto-calls" foo", will those ghc options also be used for building all dependencies of 'foo'?
12:29:07 <nitrix> jay6981: https://wiki.haskell.org/Typeclassopedia
12:29:18 <jay6981> cool!
12:29:30 <nitrix> jay6981: These two were the incredibly useful for me to speed up my learning.
12:29:40 <Paradox__> it says its arising from the use of ^
12:29:56 <jay6981> nitrix, thanks got these bookmarked
12:30:10 <EvanR> Paradox__: yeah, ^ is for integral types. use **
12:30:13 <EvanR> :t (^)
12:30:14 <lambdabot> (Integral b, Num a) => a -> b -> a
12:30:16 <EvanR> :t (**)
12:30:17 <jay6981> andromeda-galaxy: got those bookmarked too thanks
12:30:18 <lambdabot> Floating a => a -> a -> a
12:30:33 <andromeda-galaxy> jay6981: you're welcome, glady that they were helpful
12:30:53 <EvanR> Paradox__: these are different kinds of power algorithms, using different assumptions of numeric types supported ops
12:31:02 <tpsinnem> or will they be just used for 'foo'?
12:31:30 <Gurkenglas> Why does the time "stack ghc Something.hs" takes seem to vary between minor changes?
12:31:38 <Paradox__> it works.. i salut you all
12:31:58 <Gurkenglas> (or even without it)
12:33:43 <nitrix> Gurkenglas: If you were building or reloading the project, it'd only compile the files modified.
12:33:53 <nitrix> Gurkenglas: Here you're explicitly asking to recompile that file so it's doing that.
12:34:12 <suppi> what is the simplest way to write web apps in Haskell or a Haskell-like language? is it haste? purescript? elm?
12:34:47 <marchelzo> suppi: You mean front-end apps?
12:34:55 <nitrix> Gurkenglas: As for the time it takes, well, small changes can cascade into a lot of analysis. GHC is one of the most advanced compiler afterall.
12:35:02 <Gurkenglas> I'm not too sure about this "project" business. I downloaded the library tar.gz from hackage which had an example in it that I'm using as a template
12:35:23 <Gurkenglas> Unpacked it somewhere, did stack init and stack install in there (the first because the second requested the first)
12:35:33 <suppi> marchelzo, yes.
12:35:39 <Gurkenglas> Went in the examples folder and have been working there.
12:36:01 <Gurkenglas> (By editing and using stack ghc and running the resulting executable)
12:36:17 <nitrix> Gurkenglas: I pointed it out to you already. That's just how GHC is :)
12:36:46 <nitrix> Gurkenglas: You could always use the repl instead.
12:36:50 <nitrix> It's meant for that.
12:36:52 <Gurkenglas> Just to make sure, a range of 3-30 seconds for a 43 line .hs is normal, yes?
12:38:30 <nitrix> Constant 3s and 30s are both normal. Varying between 3 and 30 is suspicious.
12:46:02 * hackagebot deepcontrol 0.4.2.0 - Provide more deeper level style of programming than the usual Control.xxx modules express  https://hackage.haskell.org/package/deepcontrol-0.4.2.0 (KONISHI_Yohsuke)
12:49:10 <Aeroblop> Can anyone tell me why this outputs "ABBACEECBAFFECBAFECBACBAA"...? It should just be giving "ABCDEF" as a breadth first flattening of nodes. http://lpaste.net/4418518107648163840
12:53:14 <monochrom> in nodeD = Node 'B' [], you have a typo, B vs D
12:53:38 <EvanR> Gurkenglas: 43 lines? with no imports?
12:54:08 <EvanR> this is stack taking a long time?
12:54:38 <monochrom> yeah, I think that will do, since your algorithm relies entirely on getting reliable labels :)
12:55:59 <monochrom> no, I wonder if your algorithm also ends up doing depth-first, when given correct labels
12:56:03 * hackagebot pinboard 0.9.0 - Access to the Pinboard API  https://hackage.haskell.org/package/pinboard-0.9.0 (jonschoning)
12:56:50 <uncle-j_j> hi there, i have an issue when i try to run `cabal install -j`: "Not in scope: ‚Äò$=‚Äô" what am i doing wrong?
12:56:54 <uncle-j_j> haskell2010*
12:58:38 <Aeroblop> monochrom - it still outputs "ABBACEECBAFFECBAFECBADDCBADCBAA" with the typo fixed
12:59:49 <monochrom> you know, I don't understand why "| n `elem` cs = cs" is not "| n `elem` cs = []"
12:59:49 <Aeroblop> depth first should be "ABCEFD"
13:00:22 <Aeroblop> That changes it to : "ABBACEFFECBADDCBADCBAA"
13:01:07 <test2462> Aeroblop: state is lost in the individual sub-branches of your traversal
13:01:21 <Aeroblop> what does that mean test2462?
13:01:31 <Aeroblop> and how do I correct it?
13:01:52 <test2462> try this:  Node 'A' [Node 'B' [], Node 'B' []]
13:01:56 <test2462> it should give you ABB
13:02:28 <Aeroblop> Yeah, that gives ABBAA
13:03:08 <test2462> the trouble is that 'trav' branches twice in the second clause, but does not carry over information gained from one branch to the other
13:03:12 <test2462> does that make sense?
13:03:49 <Aeroblop> ah yeah
13:03:52 <Aeroblop> that does make sense
13:04:10 <Aeroblop> what would suggest I change to fix it?
13:04:18 <test2462> i would use a state monad here
13:04:25 <Aeroblop> what's that?
13:04:29 <int-e> also, the visited nodes are accumulated both in the cs argument and also in the result...
13:04:41 <uncle-j_j> what should i import to enable to use `$=` operator?
13:05:10 <test2462> Aeroblop: your current function does this: MyState -> [Node Char] -> String
13:05:27 <test2462> but it should really do this:  MyState -> [Node Char] -> (MyState, String)
13:05:48 <test2462> that returns not only the result, but also the already seen elements
13:06:14 <test2462> (where MyState = [Char])
13:06:31 <Aeroblop> Ok, I understand that, but what should I change to implement that?
13:06:56 <test2462> a state monad is just a more automatic way to encode this, but don't worry about that for now, if you haven't seen state monads before
13:09:29 <test2462> Aeroblop: start by changing the type signature of 'trav':  [Node Char] -> [Char] -> ([Char], [Char])
13:10:02 <test2462> wait‚Ä¶  the way your function works you don't even need that
13:10:28 <Aeroblop> haha, okay
13:10:45 <test2462> really all you need to do is to *use* the result in the second clause
13:11:47 <Aeroblop> the otherwise clause?
13:11:52 <test2462> yes
13:12:00 <Gurkenglas> EvanR, including imports
13:12:12 <Aeroblop> what do you mean by *use* it
13:12:26 <harwiltz> Hello. I'm trying to write a script for dzen2 using Haskell, which requires that I pipe information to dzen2. I figured out how to create the process that receives the data for dzen, can someone explain how to pipe that to another process?
13:12:30 <Aeroblop> could you ask me questions that would lead me to finding the correct solution?
13:12:31 <Gurkenglas> But it already built all the imports beforehand, right?
13:12:37 <test2462> Aeroblop: you apply trav two times, and you need to give the result of one as additional "cs" to the other
13:12:52 <Aeroblop> yeah
13:13:03 <test2462> try a 'let' clause
13:13:11 <Aeroblop> I've never used let before
13:13:54 <test2462> or 'where'
13:14:18 <Aeroblop> what am I defining in where?
13:14:22 <Aeroblop> the cs?
13:14:32 <harwiltz> Does anyone know how to use createProcess to pipe data to another process?
13:15:23 <hpc> what problem are you having?
13:15:45 <test2462> Aeroblop: first take the first application of 'trav' and give its result a name
13:16:03 * hackagebot s-cargot 0.1.0.0 - A flexible, extensible s-expression library.  https://hackage.haskell.org/package/s-cargot-0.1.0.0 (gdritter)
13:16:05 <test2462> Aeroblop: in other words:  write "y ‚Ä¶ where y = f x" instead of "f x"
13:16:10 <Aeroblop> yup, got that
13:16:14 <andromeda-galaxy> harwiltz: I think that you can set std_in = CreatePipe in the createProcess configuration
13:16:36 <test2462> Aeroblop: now that name stands for the characters one of the traversals has already seen
13:16:47 <Aeroblop> yup
13:16:58 <test2462> pass that as additional 'cs' to the other one
13:17:00 <harwiltz> andromeda-galaxy: I tried that, but I don't think it worked. How does it know what the parent process is?
13:17:01 <Aeroblop> so I've got where q = trav (n:cs) rs
13:17:19 <Aeroblop> how do I pass it as an additional cs?
13:17:22 <andromeda-galaxy> harwiltz: I'm not sure... I pulled that from my own dzen driver
13:17:36 <Aeroblop> concatenating q to cs in the second?
13:17:52 <harwiltz> andromeda-galaxy: Can I show you the two createProcesses that I have to see if they make sense?
13:17:58 <test2462> Aeroblop: would that make sense?  the first argument of 'trav' is a list of the characters already seen
13:18:08 <ahihi> when you set std_in to CreatePipe, you receive a Handle as the first element of the 4-tuple that createProcess returns
13:18:09 <andromeda-galaxy> harwiltz: sure, I'll see if I can elp
13:18:11 <andromeda-galaxy> *help
13:18:14 <ahihi> then you just write to that
13:18:18 <Aeroblop> No, it wouldn't
13:18:23 <test2462> Aeroblop: it would =)
13:18:33 <harwiltz> andromeda-galaxy: Thanks a lot
13:18:39 <andromeda-galaxy> harwiltz: my code does this:
13:18:42 <Aeroblop>     | otherwise     = n : q ++ trav q:cs ns
13:18:42 <Aeroblop>                             where q = trav (n:cs) rs
13:18:53 <andromeda-galaxy> (Just inp, _, _, _) <- createProcess (proc  ...) { std_in = CreatePipe }
13:18:55 <test2462> Aeroblop: that's not concatenation
13:18:57 <andromeda-galaxy> and then writes to inp
13:19:21 <test2462> Aeroblop: don't confuse consing with concatenation
13:19:27 <Aeroblop> okay, changing it to q++cs doesn't work either
13:19:32 <harwiltz> andromeda-galaxy: Mine looks just like that, but I'm not storing it in a tuple. 
13:19:41 <harwiltz> Here's my first process:
13:19:48 <test2462> Aeroblop: that's because now you're ignoring stuff the upper-level traversal has already seen
13:19:48 <Aeroblop> Oh, I'm a fool, didn't put it in brackets
13:19:59 <test2462> that, too =)
13:20:09 <harwiltz> (_,Just hout,_,_) <- createProcess (proc...){ std_out = CreatePipe)
13:20:19 <harwiltz> Then, my next line is
13:20:24 <Aeroblop> can I just PM you? test2462?
13:20:36 <harwiltz> createProcess(proc...) {std_in = CreatePipe}
13:21:00 <test2462> Aeroblop: sure, but if it's for haskell support i'd be more comfortable talking here
13:21:16 <Aeroblop> Ok, no problem. So I've got the following:
13:21:16 <Aeroblop>     | n `elem` cs   = []
13:21:16 <Aeroblop>     | otherwise     = n : q ++ trav (q++cs) ns
13:21:17 <Aeroblop>                             where q = trav (n:cs) rs
13:21:35 <Aeroblop> What do you mean by I'm "ignoring the upper-level traversal"
13:22:20 <test2462> now you're ignoring the current node in the second traversal:  previously you had (n:cs), to which you should add q
13:22:24 <andromeda-galaxy> harwiltz: so, if you're using CreatePipe, you need to capture the std_in handle from the 2nd proc & write some code that reads from the 1st std_out & writes to the 2nd std_in
13:22:48 <harwiltz> andromeda-galaxy: That's what I thought. But how do I do that?
13:23:07 <andromeda-galaxy> harwiltz: the code that I posted should let you get an inp handle, then you'd have to do some kind of chunked read/write
13:23:23 <Aeroblop> so q++n:cs?
13:23:26 <andromeda-galaxy> but it might be better to use { std_in = UseHandle hout) }
13:23:34 <andromeda-galaxy> (I haven't tested that, but I think that it should work)
13:23:37 <darkstalker> how do you prevent data struct definitions from polluting the global namespace? like when you do: data Stuff a = Stuff { asdf :: a } -- that creates an "asdf" function
13:23:59 <harwiltz> Ok. So I changed my second createProcess to capture the std_in, but how do I write to it? And what exactly does writing to it mean?
13:24:23 <test2462> Aeroblop: try it out
13:24:23 <harwiltz> andromeda-galaxy, thanks a lot for the help btw. Hope I'm not causing too uch trouble
13:24:34 <Aeroblop> I did and got "ABBAABBA"
13:24:50 <monochrom> darkstalker: I try to use a fairly unique name for asdf. there are also times non-export helps
13:25:01 <andromeda-galaxy> harwiltz: System.IO has functions for reading/writing to handle
13:25:14 <test2462> your program seems to love classic rock =)
13:25:28 <andromeda-galaxy> harwiltz: but did you have a chance to try the UseHandle?
13:25:29 <Aeroblop> hahaha
13:25:39 <darkstalker> monochrom, there is not an alternative way? like calling it Stuff.asdf
13:25:51 <harwiltz> andromeda-galaxy: I saw something about the UseHandle but I don't know what it is or how to use it
13:25:55 <Aeroblop> with the input I gave it, it should return ABB
13:25:55 <monochrom> no
13:26:03 <andromeda-galaxy> harwiltz: not tested right now, but try:
13:26:04 <test2462> Aeroblop: did you implement monochrom's suggestion about the first guard?
13:26:16 <andromeda-galaxy>     createProcess (proc...) { std_in = UseHandle hout }
13:26:22 <Aeroblop> which suggestion was that?
13:26:31 <monochrom> suggestion #39031
13:26:36 <test2462> `= []` instead of `= cs`
13:26:39 <Aeroblop> first guard is | n `elem` cs   = []
13:26:56 <harwiltz> andromeda-galaxy: So that will take the data from my first process and pipe it to the second right away? Awesome, I'll give it a try
13:27:11 <test2462> what about the first clause?  it doesn't look right to me in the paste
13:27:25 <Aeroblop> trav :: [Char] -> [Node Char] -> [Char]
13:27:26 <Aeroblop> trav cs [] = cs
13:27:26 <Aeroblop> trav cs (Node n rs : ns)
13:27:26 <Aeroblop>     | n `elem` cs   = []
13:27:26 <Aeroblop>     | otherwise     = n : q ++ trav ((n:cs)++q) ns
13:27:26 <Aeroblop>                             where q = trav (n:cs) rs
13:27:34 <andromeda-galaxy> harwiltz: I think that it should make the input of the new process = the output of the old process, yes...
13:27:52 <test2462> Aeroblop: please use lpaste for longer pastes‚Ä¶  and yes, i mean the second line of that
13:28:11 <test2462> Aeroblop: note, you can edit/annotate on lpaste
13:28:17 <harwiltz> andromeda-galaxy: That's what I meant :). But when I try running it now I get a Pattern match failure
13:28:19 <Aeroblop> sorry, I didn't know that sorry
13:28:34 <Aeroblop> I've changed the first pattern match to trav cs [] = []
13:28:43 <Aeroblop> and it returns "AB" 
13:28:51 <test2462> no worries‚Ä¶  is "AB" what you would expect?
13:29:04 <andromeda-galaxy> harwiltz: if you use UseHandle, don't match for the inp handle
13:29:11 <Aeroblop> yeah, it works now. Thank you very much!
13:29:18 <andromeda-galaxy> harwiltz: that's only created if you use CreatePipe
13:30:06 <test2462> you're welcome‚Ä¶  i hope it made sense‚Ä¶  you have now a more stateful 'trav'
13:30:18 <harwiltz> andromeda-galaxy: So I should remove the (Just inp,_,_,_)? I'll try that now
13:30:25 <andromeda-galaxy> harwiltz: see the doc for createProcess/CreateProcess/StdStream
13:30:29 <andromeda-galaxy> harwiltz: yes
13:31:15 <harwiltz> andromeda-galaxy: Thanks. I'll look into it. Now when I run my program, nothing happens...
13:31:37 <andromeda-galaxy> harwiltz: hmm...
13:31:38 <harwiltz> andromeda-galaxy: Thanks for the help though, you lead me in the right direction. 
13:32:17 <andromeda-galaxy> harwiltz: you're welcome, I'm not sure why nothing's happening...
13:32:36 <harwiltz>                     (_,Just hout,_,_) <- createProcess (proc "echo" ["TESTING 1 2 3"]) { std_out = CreatePipe }
13:32:56 <harwiltz>  createProcess(proc "dzen2" []) { std_in = UseHandle hout }
13:33:26 <harwiltz> Does that look right?
13:33:46 <andromeda-galaxy> harwiltz: seems right, is it opssible that the problem is that echo exits immediately
13:33:48 <andromeda-galaxy> ?
13:34:03 <test2462> Aeroblop: challenge: write 'trav' without the 'cs' argument:  trav :: [Node Char] -> [Char]
13:34:16 <andromeda-galaxy> harwiltz: for me, this also produces no output: echo "abc" | dzen2
13:34:19 <harwiltz> andromeda-galaxy: hmmm... I hadn't thought of that. 
13:34:35 <harwiltz> andromeda-galaxy: Really? I'll give it a try right now
13:34:43 <andromeda-galaxy> harwiltz: indeed,
13:34:57 <Aeroblop> test2462, will do. But before that I want to make them polymorphic. I've got trav :: (Eq a) => [a] -> [Node a] -> [a]
13:34:57 <Aeroblop> and it all works nicely
13:34:59 <Aeroblop> However
13:35:04 <andromeda-galaxy> try (proc "dzen2" ["-p" "5"])
13:35:11 <andromeda-galaxy> then dzen2 will continue running for 5 seconds
13:35:19 <harwiltz> andromeda-galaxy: You're right. I'll try that right now
13:36:18 <Aeroblop> I want to simply call trav nodeA, instead of trav [] [nodeA]. Is there any way of changing it so that it works like that, or do I have to create a separate initialising function that takes Node a and calls trav [] [nodeA] ?
13:36:21 <andromeda-galaxy> harwiltz: I think that that should work, glad to be of help
13:36:25 <harwiltz> andromeda-galaxy:YES! It worked
13:36:38 <test2462> Aeroblop: that's exactly the challenge i'm posing =)
13:36:42 <harwiltz> andromeda-galaxy: Can I ask you one more quick question? 
13:37:10 <Aeroblop> You said [Node Char] -> [Char] not Node Char -> [Char] :P
13:37:12 <andromeda-galaxy> harwiltz: sure
13:37:47 <test2462> Aeroblop: oh‚Ä¶  you can do both in once step
13:37:56 <harwiltz> I have my code inside a "loop", basically a function that just calls itself at the end. However, now I'm spawning infinite dzen's on top of each other, which makes sense now that I think of it.
13:38:00 <Aeroblop> I've got no idea where to start
13:38:10 <Aeroblop> I've only been doing Haskell for 2 weeks
13:38:18 <test2462> Aeroblop: the easy way out would be to rename 'trav' and write it as a wrapper function, but really the first argument is not necessary *algorithmically*
13:38:25 <harwiltz> andromeda-galaxy, how should I get haskell to update dzen?
13:38:42 <andromeda-galaxy> harwiltz: in that case, it might be better to go back to the other approach
13:38:59 <andromeda-galaxy> create the dzen outside the loop, with CreatePipe & store the handle
13:39:07 <test2462> Aeroblop: the wrapping idea would be pretty straightforward: trav node = travWith [] [node]
13:39:17 <andromeda-galaxy> then inside the loop, run the outside process, read the input, and write it to the dzen handle
13:39:34 <Aeroblop> and then travWith is the algo function?
13:39:34 <harwiltz> andromeda-galaxy: Oh I see, makes a lot of sense. Thank you very much
13:39:42 <test2462> Aeroblop: yeah
13:39:47 <andromeda-galaxy> harwiltz: you're welcome
13:39:56 <Aeroblop> thought as much, that's what I was planning on keeping it as
13:40:13 <Aeroblop> But, you're saying there's a way of doing it without a second function>
13:40:45 <test2462> Aeroblop: i'm saying that you can write 'trav' as a '(Eq a) => Node a -> [a]' directly
13:41:21 <Aeroblop> yeah, I would have no idea where to start when trying to adapt it to that
13:42:01 <test2462> Aeroblop: are you familiar with 'if'?
13:42:32 <Aeroblop> well, I know how it works, but I don't have a working intimacy with using it in Haskell
13:46:05 <test2462> Aeroblop: can you write a function 'nodeElems :: Node a -> [a]' that returns *all* elements?
13:46:06 * hackagebot tellbot 0.6.0.2 - IRC tellbot  https://hackage.haskell.org/package/tellbot-0.6.0.2 (DimitriSabadie)
13:46:45 <Aeroblop> Yeah
13:46:55 <Aeroblop> maybe using fold
13:47:36 <test2462> a very simple implementation would be using 'concatMap'
13:47:54 <test2462> :t concatMap
13:47:55 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
13:48:06 <test2462> read "t a" as "[a]" there
13:50:58 <Aeroblop> when you mean *all* elements, do you mean all of it's child Node's char?
13:54:50 <test2462> Aeroblop: yes, and of course the top-level element as well
13:55:06 <test2462> i'm saying "element", because i'm thinking in terms of "Node a" rather than "Node Char"
14:01:49 <Gurkenglas> When I have downloaded a project, and there is a single .hs file in a subproject that I would like to have ghci or stack ghci interpret, how do I do that?
14:02:49 <Gurkenglas> http://pastebin.com/URQ75fPe
14:08:18 <bergmark> i think stack isn't that granular, you load one or more packages. you might be able to fiddle with --ghc-options to do it though
14:13:23 <Lokathor> Gurkenglas, stack exec ghci Rainbow.hs
14:13:24 <Lokathor> try that
14:16:57 <Akari2> can someone help me to achieve this structure http://prntscr.com/8uxanz    http://pastebin.com/LbiNvNpp
14:18:26 <phaazon> ahah
14:18:37 <phaazon> building stack is a bit like building all packages from hackage haha
14:19:42 <phaazon> Akari2: hm
14:20:12 <cocreature> Akari2: you need a parameter to dirTree that represents the indent level, then on each recursive call you can increase that to achieve the nesting you want
14:20:36 <phaazon> I‚Äôm not even sure he needs that
14:20:42 <phaazon> they need that*
14:20:42 <phaazon> sorry
14:20:55 <phaazon> they can just use a String representing the current ¬´ prefix ¬ª
14:21:21 <phaazon> and add more prefix as they find a Dir ctor
14:21:25 <cocreature> oh yeah if you want thse lines the indent level doesn't even work
14:23:22 <cocreature> so go for a prefix and append "|  " or something like that on each recursive call to the prefix
14:23:35 <phaazon> I‚Äôd actually prepend it
14:23:39 <phaazon> so that it‚Äôs faster
14:23:50 <cocreature> fair enough
14:24:07 <phaazon> but, yeah
14:24:21 <phaazon> Akari2: you basically traverse a tree (Entry)
14:24:40 <phaazon> at first, your prefix is an empty string
14:24:59 <phaazon> so you hit a Dir with an entry name and subdirs
14:25:25 <phaazon> just print out the entry name and recursively call your pretty-printing function again by prepending the prefix you want
14:25:30 <phaazon> and that‚Äôs enough I guess
14:26:06 <mm_freak> minor nitpick: prepending can actually be slower‚Ä¶  it depends on association =)
14:26:18 <phaazon> hm?
14:26:26 <phaazon> a ++ b is O(n) with n = length a, right?
14:26:35 <exio4> O
14:26:41 <exio4> O(length a), yeah
14:26:47 <phaazon> then
14:26:51 <phaazon> if a == the prefix
14:27:08 <phaazon> it‚Äôll be faster to prepend a constant prefix
14:27:17 <phaazon> than prepending a dynamically increasing prefix
14:27:21 <mm_freak> phaazon: it depends on what you're asking for
14:27:37 <phaazon> I‚Äôd go with "|  " ++ prefix
14:27:46 <phaazon> instead of prefix ++ "|  "
14:28:16 <Akari2> i dont care much about the speed , i tried to append "     |" to string s whenever i call pList however it gets messed up 
14:28:19 <phaazon> mm_freak: do you have a concrete example?
14:28:34 <phaazon> what is pList responsible of?
14:28:35 <mm_freak> 'head (foldr (++) [] lists)' is faster than the equivalent left-associated version
14:29:38 <Akari2> it calls the dirTree function for every child
14:30:22 <phaazon> well, you have a lot of redundancy in your code
14:30:38 <phaazon> line 18 is a specific case you also have at line 20 + line 14
14:30:58 <phaazon> you can remove line 18
14:31:03 <phaazon> and replace line 20 with
14:31:20 <phaazon> dirTree (Dir root x) s = root ++ "\n" ++ pList x s
14:31:41 <phaazon> then, let‚Äôs see
14:31:51 <phaazon> your line 19 is correct
14:32:21 <phaazon> even though I don‚Äôt get the use of s in your code
14:32:24 <phaazon> you never use it
14:32:41 <phaazon> is it the prefix?
14:33:36 <Akari2> yeah its supposed the store the "    |" 's for each level but i mess up when i try using it
14:33:57 <phaazon> right, then, for the File case, it‚Äôs very simple
14:34:08 <phaazon> dirTree (File n p) s = s ++ n ++ "\n"
14:34:30 <phaazon> for the Dir case, it‚Äôs a bit trickier, but not that much
14:34:58 <phaazon> dirTree (Dir root c) s = s ++ root ++ \n ++ pList c ("|  " ++ s)
14:35:35 <phaazon> and I guess you don‚Äôt have to use pList, you can do all the work in dirTree
14:35:53 <phaazon> and concatMap
14:35:56 <phaazon> :)
14:37:36 <phaazon> I‚Äôm writing an example for you, wait
14:37:51 <SrPx> Is there any friendly library that allows me to render JuicyPixels-like images to the screen, and get keyboard/mouse events? Something like Gloss's playArray (which renders a REPA array), but Gloss is not on stack LTS :(
14:38:58 <phaazon> I‚Äôd say my luminance package, but it‚Äôs for 3D, and still very experimental ;)
14:41:05 <SrPx> Not on LTS :(
14:42:27 <lpaste> phaazon pasted ‚ÄúAkari2, this‚Äù at http://lpaste.net/143800
14:45:11 <sinelaw> conal, ping
14:46:25 <Akari2> phaazon last line didnt compile
14:48:01 <Gurkenglas> How do I give "stack exec ghci Rainbow.hs" getArgs contents?
14:48:27 <phaazon> Akari2: hm?
14:48:40 <phaazon> Gurkenglas: :set args
14:49:01 <phaazon>  :set args arg0 arg1 arg2‚Ä¶
14:49:37 <phaazon> Akari2: which line doesn‚Äôt compile?
14:49:44 <phaazon> compiles perfectly here
14:49:48 <Akari2> phaazon my bad, it compiles, but do you know how can i implement the empty lines with appropriate pref
14:50:00 <Gurkenglas> Thanks, worked.
14:50:30 <phaazon> Akari2: empty lines?
14:51:09 <Akari2> yes like 318 320 322 lines in the ss
14:51:34 <phaazon> I didn‚Äôt get what you said :D
14:53:04 <Akari2> http://prntscr.com/8uxw4w here entries have empty lines between them that makes the tree look better
14:53:53 <phaazon> oh, then, just add those after hitting a ctor! :)
14:58:31 <Akari2> phaazon okay thanks for the help, i added it , the tree doesnt look as good as i imagined but whatever
15:00:20 <platz> > fmap sequence . traverse waitCatch
15:00:22 <lambdabot>  Not in scope: ‚ÄòwaitCatch‚Äô
15:23:29 <platz> :t \xs g f e -> either e (f . foldr g mempty) . sequence <$> traverse waitCatch xs
15:23:31 <lambdabot> (Traversable t, Monoid b1) => t (Async a) -> (a -> b1 -> b1) -> (b1 -> b) -> (SomeException -> b) -> IO b
15:27:06 <tippenein> What kind of code hilighting is github using that it's always messing up on haskell source?
15:27:48 <lynnard> is Control.Monad.Trans.State included in default installation of ghc?
15:29:37 <lynnard> no one..?
15:29:37 <phaazon> hey, how do you insert explicit unicode in a String?
15:29:56 <phaazon> lynnard: I‚Ä¶ guess so, it comes with transformers, which should be
15:33:42 <monochrom> lynnard: old GHC did not include it. newer GHC does.
15:33:57 <lynnard> cool, I was certainly hoping so
15:42:11 <haskell274> hi, I'm trying to to write a "sort-function" that sorts: 1. occurrences of the letters and 2. smaller to higher value (e. g. "t7g7a7g" = "atgg777"). My code so far: http://lpaste.net/4206144584884944896 
15:45:19 <Darwin226> Hey guys. My package has pending docs and unknown build status for a couple of days now. Who do I ping about that?
15:48:25 <tzh> haskell274: would `concat . sortBy (compare `on` length) . groupBy (==) . sort` do what you're trying to do?
15:51:14 * hackagebot tellbot 0.6.0.3 - IRC tellbot  https://hackage.haskell.org/package/tellbot-0.6.0.3 (DimitriSabadie)
15:51:24 <tzh> > let uniqueLetter = concat . sortBy (compare `on` length) . groupBy (==) . sort in uniqueLetter "t7g7a7g"
15:51:26 <lambdabot>  "atgg777"
15:51:41 <hpc> yeesh
15:51:47 <hpc> that's almost as bad as acme-php's sort
15:52:23 <Darwin226> isn't groupBy (==) just group?
15:52:33 <hpc> and (compare `on`) is comparing
15:53:20 <hpc> can't think of any other brevities that keep it readable
16:08:08 <SrPx> Is there any way to write a function that works like `delay` combined with `getChar`? That is, `waitForChar :: Int -> IO (Maybe Char)` delays the thread for some milliseconds, but if the user press a char on the meanwhile, it stops the delay and gives you that char.
16:09:12 <Hijiri> use MVars and have one thread do the delay, and another thread do the getChar?
16:09:57 <Hijiri> and then wait on an mvar and the first one to finish fills it
16:10:02 <hpc> i was going to suggest polling stdin for having characters ready to read, but that's a better idea
16:10:21 <mniip> my first thought was select voodoo
16:10:42 <hpc> i used select once
16:10:47 <hpc> and i am never using it again ;)
16:11:00 <mniip> I too hate SQL
16:11:08 <hpc> heh
16:12:27 <SrPx> Wait, no. Actually, I think the pooling idea might be simpler because I only actually need the character after the delay. I know how to do Hijiri but not sure how I could do what hpc said.
16:12:39 <SrPx> Hijiri's suggestion*
16:13:55 <hpc> lol, we're all stupid
16:13:58 <SrPx> Specifically, I'd need a "getChar" that returns immediately if there is nothing on the buffer
16:14:01 <hpc> http://hackage.haskell.org/package/base-4.8.1.0/docs/System-IO.html#g:18
16:14:04 <hpc> hWaitForInput
16:15:03 <hpc> foo = do {p <- hWaitForInput stdin 1000; if p then Just <$> getChar else return Nothing}
16:15:20 <hpc> s/1000/appropriate number of milliseconds/
16:16:16 <SrPx> Oh ok. I was trying to understand wtf was Handle. Thanks hpc :)
16:16:35 <hpc> yeah
16:16:56 <SrPx> No that's not right at all. I'm getting an error complaining "appropriate" isn't a function...
16:16:57 <hpc> stdin, stdout, and stderr are magic space miracles, defined at the top level
16:17:05 <hpc> SrPx: :P
16:17:16 <SrPx> ah okay
16:17:39 <hpc> it's easy to forget they exist because you'd have to unsafePerformIO to define them yourself
16:18:56 <SrPx> we need `perhaps :: Bool -> a -> Maybe a`. 
16:19:30 <SrPx> ah there is, `toMaybe`
16:19:45 <SrPx> No there isn't. meh
16:20:02 <hpc> some things are better left explicit ;)
16:20:17 <hacker> perhaps b c = pure c <* guard b 
16:20:37 <MarcelineVQ> :t maybe --might do something like what you're after as well
16:20:38 <lambdabot> b -> (a -> b) -> Maybe a -> b
16:37:50 <KaneTW> @hoogle Bool -> a -> Maybe a
16:37:52 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
16:37:53 <lambdabot> Control.Exception assert :: Bool -> a -> a
16:37:53 <lambdabot> Control.OldException assert :: Bool -> a -> a
16:37:59 <KaneTW> rip
16:43:14 <platz> :t \x e -> either e id <$> waitCatch x
16:43:15 <lambdabot> Async b -> (SomeException -> b) -> IO b
16:49:51 <SrPx> Turns out `hWaitForInput` has some kind of issue, because using it causes the FPS of the animation to drop to mediocre levels :( 
16:50:28 <SrPx> Using `delay` from `Control.Concurrent.Thread.Delay` has no issue. I'll study the other suggestinos
16:51:00 <platz> :t \x f -> async $ f <$> waitCatch =<< x
16:51:01 <lambdabot> Not in scope: ‚Äòasync‚Äô
16:56:41 <SrPx> got it! :) 
17:00:56 <SrPx> There you go, inline terminal game runner: http://imgur.com/ukDn06y yea! Goodbye Gloss for dev time :) 
17:07:52 <EvanR> SrPx: reading stdin, seems easy to use a thread
17:08:04 <EvanR> block until you get a char, dump it to an MVar
17:08:50 <EvanR> the consumer can block on that, or tryTakeMVar to poll
17:14:47 <SrPx> EvanR: turns out just hReady after the delay was enough : http://lpaste.net/143804 ty :)
17:15:20 <SrPx> Kinda magical to see the app running on the terminal 
17:15:25 <EvanR> yeah i like threads more for this stuff than sequential loops
17:16:00 <SrPx> why?
17:16:10 <EvanR> or event handlers
17:16:22 <SrPx> I still didn't read the concurrent haskell book :( but seems quite simple it won't hurt on this case, no?
17:16:39 <EvanR> no, but concurrent haskell is awsum
17:17:14 <SrPx> I know!
17:18:39 <EvanR> its like what i replace OOP with in my head
17:18:53 <mac10688> bitemyapp, I was reading a web article about cabal and noticed a typo. I opened up the email to send you a ticket but realized my mistake when I couldn't find the chapter name and section.
17:24:05 <SrPx> "parse error in let binding: missing required 'in'" on a `let` inside a `do` ?
17:24:47 <EvanR> lpaste
17:26:22 <SrPx> EvanR: I had an `else` inside a case in an unrelated line. Could improve that error message, though. http://lpaste.net/143805 I wonder if I can make this code cleaner anyway.
17:26:57 <EvanR> yes thats where i would use fix
17:27:16 <EvanR> or a move that inner code into its own recursive action
17:27:30 <EvanR> or look for a monad-loop combinator in monad-loops
17:27:53 <SrPx> Hmm I meant about all the ifs and cases. But fix makes sense here
17:28:07 <EvanR> i dont see ifs
17:29:10 <EvanR> SrPx: case pressedKey, this would be a whenJust or some sort
17:29:12 <EvanR> of*
17:29:40 <EvanR> ah the if
17:29:51 <EvanR> SrPx: yeah this would be simpler with threads ;)
17:30:12 <EvanR> its worse than C as is
17:31:26 <SrPx> EvanR: I won't complain if you write it :P I have no idea how threading in Haskell works
17:31:50 <SrPx> indeed I just copypasted how it is done in C, I guess
17:32:24 <EvanR> ok
17:34:50 <EvanR> SrPx: the main thing that helps is not using a Maybe everywhere once you know its not Nothing
17:34:59 <EvanR> well one thing that helps
17:37:00 <SrPx> the code was quite brief before the `\ESC` req, I'll refactor that later on 
17:37:25 <SrPx> I also don't understand what you meant with OOP and concurrent haskell earlier
17:37:53 <EvanR> you can think of threads as objects that pass messages
17:38:27 <SrPx> So actors?
17:38:52 <mniip> EvanR, ans messages are morphisms!
17:39:03 <SrPx> Haskell threads work like that? From Concurrent.Thread? I thought they followed pthread's model.
17:39:24 <EvanR> its not like pthreads at all
17:40:13 <EvanR> forkIO threads are very cheap to create and switch between, and support async exceptions
17:40:50 <SrPx> Interesting, I really assumed it was very low level.
17:41:18 <lf94_> EvanR: Thank you again for linking me to those papers. I got through the Functional Reactive Animations and the FRP (FrTime) in PL Scheme papers. Really great material.
17:41:48 <lf94_> I don't understand why people who try and teach FRP make it seem so complex.
17:43:46 <SrPx> Pardon, what papers?
17:44:31 <EvanR> SrPx: something like this? http://lpaste.net/143805
17:45:08 <EvanR> lf94_: simple semantics right, not necessarily simple to not try to think about implementations
17:46:00 <lf94_> EvanR: Even the implementations...when presented in these papers, seem well thought out and easy to understand.
17:46:12 <lf94_> EvanR, but yes, simple semantics :)
17:46:29 <EvanR> i think both implementations eventually had problems
17:47:19 <lf94_> I find it funny how the first type of implementation I had in mind, nearing the end of the FrTime paper, was using streams.
17:47:31 <lf94_> Then I read that, that's what Fran did.
17:48:05 <lf94_> Evaluating a lazy list of behaviours/signals
17:48:12 <SrPx> EvanR: you did that without typechecking??
17:48:19 <EvanR> i doubt it type checks
17:48:54 <hacker> there are a few syntax errors, too
17:49:22 <EvanR> lf94_: well its a slightly more complex, at each step the behavior returns an updated copy of itself
17:49:24 <hacker> like `else` in case expressions ..
17:49:49 <EvanR> ah thats SrPx's code i left there ;)
17:49:53 <lf94_> EvanR, Yes I know, I'm just detailing the really high-level idea I had, that turns out was the first thing that was used - sort of proving it's a naive idea :)
17:51:33 <EvanR> i think its interesting to try and implement the fran-like idea restricted to literally only operating on [(T,a)] and T -> a values
17:51:38 <SrPx> EvanR: that looks really cool, had to do a lot of googling on the terms you used but now I think very good of haskell threads :) Might just read the book already
17:51:40 <EvanR> without worrying about IO
17:52:10 <EvanR> that should/might have a more elegant implementation based on the semantics
17:52:38 <EvanR> and be more or less useless in practice but still a cool experiment
17:53:16 <EvanR> SrPx: i mean /= in there near '\ESC' probably other errors
17:53:22 <lf94_> EvanR, T being time, a being a behaviour?
17:53:31 <EvanR> T is time a is any type
17:53:46 <lf94_> Alright
17:55:48 <EvanR> lf94_: like, first, the semantic functions at :: B a -> T -> a and occs :: E a -> [(T,a)] are clearly trivial to implement...
17:55:59 <EvanR> then if you can implement the combinators, youre done ;)
17:56:23 <EvanR> and make it work with infinite Es
17:56:31 <EvanR> more or less efficiently ;)
17:56:32 <lf94_> occs means...occurs?
17:56:39 <EvanR> occurrences
17:57:59 <lf94_> I understand at, not understanding occs, but I understand your overall idea X)
17:58:20 <EvanR> if E a is implemented as [(T,a)], then occs = id
17:58:29 <EvanR> or unE or you know
17:58:52 <lf94_> OK so you're saying, an E a is value occuring at a certain time
17:58:59 <lf94_> well, many
17:59:05 <EvanR> its many occurrences
17:59:10 <EvanR> which are values at times
17:59:21 <lf94_> yes
17:59:22 <EvanR> (or none, in the case of [])
17:59:34 <lf94_> I'm *sure* someone has done something like this
17:59:36 <lf94_> As an exercise
17:59:40 <EvanR> i know i have ;)
17:59:44 <lf94_> lmao
18:00:20 <lf94_> So you need combinators to: combine behaviours, combine events
18:00:40 <lf94_> And also..to combine one of both?
18:00:46 <EvanR> yeah, so relatively easy is mempty and mappend for E a's
18:00:54 <voidzero> happy CET everyone
18:01:25 <EvanR> and fmap for E a and B a
18:01:27 <lf94_> I don't know what mempty and mappend are~
18:01:39 <EvanR> its the Monoid class
18:02:50 <lf94_> Haven't looked into Monoids yet
18:03:09 <EvanR> do that !
18:03:17 <EvanR> do you know Functors?
18:03:23 <lf94_> Yes I know Functors :)
18:03:25 <lf94_> lol
18:03:30 <lf94_> Functors and Monads
18:03:34 <EvanR> then do fmap for E a's and B a's
18:03:36 <lf94_> Applicative too
18:03:43 <EvanR> and applicative for B a's
18:04:14 <lf94_> No applicative for E a's?
18:04:27 <EvanR> i dont think so
18:04:35 <EvanR> though the likes of bacon have dont it anyway
18:04:39 <lf94_> What if you want multiple events to happen before a behaviour
18:04:41 <EvanR> done*
18:05:00 <EvanR> what do you mean
18:05:29 <lf94_> Like, an event is just something happening and returning a value that corresponds to when it happened in time
18:05:57 <EvanR> an event is a list of occurrences ;)
18:06:19 <EvanR> theres no before a behavior, which is defined for all time
18:06:58 <lf94_> "events are sets of arbitrarily complex conditions, carrying possible rich information"
18:07:08 <lf94_> - quote from functional reactive animations
18:07:12 <EvanR> that sentence is referring to predicates
18:07:21 <EvanR> events defined using a Bool test
18:07:53 <lf94_> well that's what I'm referring to too, because even the FrTime paper refers to them in the same way...
18:07:56 <EvanR> its also a quite old characterization
18:08:10 <lf94_> But like, the way you're describing it
18:08:15 <lf94_> E a -> [(T,a)]
18:08:17 <lf94_> also seems correct
18:08:18 <EvanR> =
18:08:38 <EvanR> this is probably first established in the reactive paper
18:09:59 <lf94_> EvanR, what do you mean?
18:10:01 <EvanR> lf94_: in the fran paper, for example the mouse clicking isnt a predicate
18:10:08 <lf94_> Right
18:10:10 <EvanR> its just some event
18:10:19 <lf94_> What if you wanted 3 mouse clicks to happen
18:10:23 <lf94_> then evaluate
18:10:40 <EvanR> 3 mouse clicks happen then what?
18:11:04 <lf94_> EvanR, then you change a behaviour
18:11:27 <EvanR> so you have some behavior, and you want it to switch on the 3rd mouse click
18:11:37 <lf94_> yes
18:11:44 <EvanR> you need to define a "the 3rd mouse click event"
18:12:12 <lf94_> Ok so we define that
18:12:40 <lf94_> Now I want to combine that with a "pressing enter 9 times event"
18:13:00 <EvanR> well, you cant do both at the same time
18:13:24 <lf94_> right, the order matters
18:13:44 <lf94_> newEvent = "3rd mouse click event" <and> "enter 9 times event"
18:13:57 <lf94_> Could specify <or> too
18:14:00 <EvanR> the <and> combinator isnt in these frps
18:14:21 <EvanR> and doesnt fit into the denotation [(T,a)]
18:14:35 <lf94_> why not
18:14:46 <lf94_> mmm
18:14:46 <EvanR> but you could say, the event which happens at the soonest time that e1 happened and e2 happened
18:15:00 <lf94_> yes
18:15:19 <lf94_> that's what it would mean
18:15:30 <lf94_> anyways you're right, it doesn't talk about those in the frp papers
18:15:41 <lf94_> but I'm saying in this pretend system we *were* talking about
18:15:48 <EvanR> would you add that as a primitive combinator, expose the [(T,a)] directly for that, or allow it to be implemented in terms of simpler combinators
18:15:59 <lf94_> shouldn't we also create an applicative for events? I guess the real answer is: it's up to us!
18:16:12 <EvanR> that goes along with this feature you want events to have ;)
18:16:22 <EvanR> im not sure using applicative for that follows the laws
18:16:41 <lf94_> Yeah actually, wouldn't be applicative
18:16:46 <lf94_> I think~
18:16:47 <EvanR> it makes sense for Stream and for T -> a because you can do a pointwise zip
18:17:16 <EvanR> but [(T,a)] arent necessarily both infinite
18:17:43 <EvanR> no matter what way you decide to combine them
18:18:18 <EvanR> lf94_: so i was listing obviously doable combinators, E Monoid, E B Functor...
18:19:15 <EvanR> switcher :: E (B a) -> B a -> B a, this might seem nice but, its not obviously doable
18:19:45 <EvanR> nor the join-like thing for events :: E (E a) -> E a -> E a
18:19:52 <EvanR> er, E (E a) -> E a
18:20:26 <EvanR> referenced for the infamous space time leaks
18:20:37 <lpaste> JulianLeviston pasted ‚ÄúAttempting a refactor‚Äù at http://lpaste.net/143810
18:20:46 <lf94_> I guess joining events is also really complex or yeah, undoable
18:21:00 <EvanR> the idea being to switch the behavior of an event
18:21:06 <EvanR> because of another eent
18:21:50 <lf94_> EvanR, E (B a) -> E (B a) -> B a   -- shouldn't it be like that?
18:22:04 <EvanR> no you need an initial B to start with before any E happen
18:22:05 <julianleviston> I‚Äôve been writing the code in customersEditHandler (in a Snap App) recently‚Ä¶ I‚Äôm looking at it and thinking that it could be cleaned up somehow, but I‚Äôm not quite sure how the theoretical knowledge I have of Haskell can help me to refactor it into some cleaner, more abstract code. Any help would be very much appreciated :)
18:22:10 <lf94_> EvanR, ah
18:22:22 <lf94_> EvanR, nevermind what am I saying X)
18:22:49 <lf94_> EvanR why is the switcher not doable?
18:23:18 <lf94_> An event happens, and instead of using the B a in the E, you use the passed-in B a
18:23:19 <EvanR> you might be able to pull it off with the pure lists and time functions, but maybe not without a risk of leaks
18:23:34 <Big_G> Is there a general consesus as to using single character symbols like lambda being good/bad?
18:23:41 <lf94_> EvanR, oh ok
18:23:45 <lf94_> EvanR, what do you mean by leaks?
18:23:48 <EvanR> lambda isn't a symbol, its a letter
18:24:21 <EvanR> lf94_: so the point of this exercise
18:24:21 <Big_G> EvanR, Since when isn't lambda considered a character?
18:24:23 <julianleviston> in particular, I‚Äôm about to add a case clause in the ‚ÄúformSubmit‚Äù section for checking if mCustomerId has a Just value or Nothing in it, which will mean I have two case clauses in it‚Ä¶ screams maybe monad or something like that to me‚Ä¶ but I‚Äôve haven‚Äôt really done this before, so I don‚Äôt recognise the patterns.
18:24:34 <EvanR> Big_G: ... it is a character
18:24:43 <jmcarthur> lf94_: switch makes it easy to accidentally express values that hold on to history forever. it's perfectly reasonable to implement, and can even be used safely, but is very easy to misuse
18:24:49 <Big_G> EvanR, I must have misread something than
18:24:53 <julianleviston> EvanR: it *can* be a character‚Ä¶ if you use unicode.
18:24:54 <EvanR> yeah
18:25:01 <julianleviston> EvanR:  I think that‚Äôs what s/he is talking about.
18:25:07 <Big_G> Yeah
18:25:15 <EvanR> let me try and say my message again ;)
18:25:18 <EvanR> lambda isn't a symbol, its a letter
18:25:30 <julianleviston> EvanR: um
18:25:30 <lf94_> greek letter l right?
18:25:34 <EvanR> yeah
18:25:45 <julianleviston> EvanR: it depends‚Ä¶ viewed from unicode and english, it‚Äôs a symbol...
18:25:52 <EvanR> implication, you cant use lambda in operators
18:25:58 <julianleviston> EvanR: especially when used in a mathematical or functional programming context.
18:25:59 <EvanR> you can use it for variable names
18:26:10 <Hijiri> unicode tells lambda is a letter doesn't it?
18:26:13 <EvanR> julianleviston: assuming Big_G is asking about haskell code
18:26:18 <Big_G> So I can't do something like `Œªx -> x * 2 ?
18:26:22 <EvanR> nope
18:26:32 <Eduard_Munteanu> You can, with UnicodeSyntax, I think.
18:26:38 <EvanR> nor Œªx . x * 2
18:26:39 <Big_G> That is dissapointing
18:26:49 <EvanR> agda is that way ;)
18:26:50 <julianleviston> EvanR: yes‚Ä¶ but using Leksah you can enable a mode that replaces \x -> x with {{lambda-char}}x {{arrow}}x
18:27:04 <lf94_> jmcarthur, so you're saying in our example: E(B a) -> B a -> B a, we might accidentally always return the same behaviour that never changes?
18:27:07 <y> Œªx. x*2 looks nicer! right?
18:27:13 <julianleviston> EvanR: it‚Äôs called candymode, I believe.
18:27:21 <Hijiri> you can do Œªx . x * 2
18:27:28 <lf94_> jmcarthur, I'm very new to this so being explicit would be fantastic :)
18:27:32 <Hijiri> but it would mean somthing else
18:27:34 <y> my nick is just an inverted lambda
18:27:39 <Big_G> Hijiri, Wouldn't that mean composition somehow?
18:27:45 <EvanR> yx . x + 1
18:27:49 <julianleviston> Big_G: no, it‚Äôs lambda calculus syntax
18:27:52 <Hijiri> yes, Œªx composed with x * 2
18:28:00 <Hijiri> so there would need to be num instance for functions
18:28:09 <Big_G> julianleviston, I know that but how would we be able to easily tell if . is used for both
18:28:22 <EvanR> lf94_: so the cool part of implementing this like i said, is you can use it to simulate a given interactive session, and check its performance ;)
18:28:39 <EvanR> and if you do it wrong, itll be low performance
18:28:44 <EvanR> or freeze up
18:28:56 <voltz> Hey, is there anyone that would be so kind as to show me in baby steps how to install ghc-mod in vim (or emacs)?
18:28:58 <lf94_> Yeah I might do it in the near future just for fun
18:29:02 <julianleviston> Big_G: because in candy mode, it‚Äôs a simple substitution‚Ä¶ 
18:29:10 <lf94_> First I would like to use a real Haskell FRP package though
18:29:12 <EvanR> lf94_: but at least it serves as a reference implementation
18:29:13 <julianleviston> Big_G: it‚Äôs not lambda calculus
18:29:25 <EvanR> and is close to the semantics so you know its probably right
18:29:31 <lf94_> Yeah
18:29:40 <lf94_> EvanR, could you explain what jmcarthur was talking about?
18:29:41 <jmcarthur> lf94_: imagine you have an event whose millionth occurrence happens after several hours, and it's a very active behavior that was defined when the program started. the frp library didn't necessarily know to keep advancing the behavior while it wasn't being used. the first thing you do upon getting the behavior hours later might be to access something that happened within the first few second.
18:29:48 <lf94_> (oop nevermind)
18:29:58 <jmcarthur> s/it's/the millionth occurrence/
18:30:17 <jmcarthur> lf94_: so basically you have a behavior that's just been accumulating crap since the program started
18:31:10 <jmcarthur> lf94_: switcher is only safe if every behavior the event yields is created "fresh"
18:31:23 <jmcarthur> by "safe" i mean "memory efficient"
18:32:19 <EvanR> lf94_: if you implement switcher you might see
18:32:39 <lf94_> jmcarthur, how is it not used, if it's very active?
18:33:19 <julianleviston> lf94_: talking about consumption
18:34:21 <lf94_> why wouldn't it know to keep updating the behaviour?
18:34:29 <EvanR> Fran didnt
18:35:15 <lf94_> In Fran if an event happens, yes, it does update a behaviour...IIRC. It did it with changing colors.
18:35:23 <EvanR> and also, would that be a good thing in all cases
18:35:27 <lf94_> Let me recheck though
18:36:06 <EvanR> lf94_: were talking about a behavior that isnt visible anywhere yet, but relies on current stuff through time until finally the switcher event happens
18:36:31 <EvanR> once it happens, switchers implementation would get that new behavior and start computing the whole thing
18:36:42 <EvanR> from the beginning of time
18:37:04 <lf94_> and jmcarthur saying the new behaviour is no good, since it never updated since the beginning
18:37:17 <EvanR> its good but using too much time and memory
18:37:23 <EvanR> its still "right"
18:37:41 <lf94_> sounds like an implementation detail or something because I'm just not getting this heh...
18:37:49 <EvanR> definitely
18:38:31 <lf94_> It'll re-compute everything that happened from the beginning of time, to the present?
18:38:39 <EvanR> but the recourse since then has been to drop switcher-like support
18:38:50 <EvanR> or go with a whole new model like arrows
18:39:11 <EvanR> lf94_: no everything used by that behavior up to this point
18:39:33 <EvanR> which could be lots of stuff otherwise that could be collected since its ancient history
18:40:39 <lf94_> Yeah OK. I think I sort of get what's being said.
18:41:07 <lf94_> Again sounds like an implementation detail, or something that I would *really* realize if I used switcher.
18:41:21 <EvanR> if you eagerly attempt to compute all alternative futures, thats another problem
18:41:24 <lf94_> Know any FRPS that use switcher? :D
18:42:05 <lf94_> I think Fran does that
18:42:14 <EvanR> i dont think it does
18:42:18 <EvanR> its lazy
18:42:19 <julianleviston> lf94_: you might want to look into this video‚Ä¶. maybe‚Ä¶ https://www.youtube.com/watch?v=Agu6jipKfYw
18:43:22 <julianleviston> lf94_: the creator of Elm talking about FRP.
18:43:34 <EvanR> lf94_: there is a switcher-like thing in Reactiv
18:43:38 <lf94_> julianleviston, thanks!
18:43:40 <julianleviston> lf94_: and the design choices and ramification.
18:43:42 <EvanR> Reactive
18:43:50 <julianleviston> ramifications*
18:44:07 <jmcarthur> lf94_: how do you suppose the following function might work when applied to its arguments?   switcher . map integral
18:44:25 <lf94_> EvanR, I'm saying that because I know Fram has later :: Int -> Behaviour a -> Behaviour a or something like that
18:44:42 <EvanR> i dont get what that would do
18:45:00 <lf94_> It sets the time of the behaviour to occur later
18:45:14 <lf94_> maybe it takes an event
18:45:19 <EvanR> so a time shift
18:45:29 <EvanR> Time -> B a -> B a
18:45:55 <EvanR> thats useful for a T -> a comonad
18:45:57 <lf94_> just checked, it's a behaviour
18:46:10 <jmcarthur> meh, sorry, i meant    switcher . fmap integral
18:46:12 <jmcarthur> ugh
18:46:25 <lf94_> jmcarthur, I'm thinking about it X)
18:46:47 <jmcarthur> i think i meant integrate. whatever that function is typically called
18:46:48 <lf94_> What does fmap take? E(B a) ?
18:47:05 <lf94_> [(E(B a))]
18:47:17 <lf94_> or just 1 E (B a)
18:47:21 <jmcarthur> in this case i'm using fmap as something like this      (B Double -> B Double) -> E (B Double) -> E (B Double)
18:47:40 <EvanR> fmap takes B a -> B a, and a E(B a) and gives E(B a) (where a can be integrated)
18:48:25 <jmcarthur> my point free style may be unnecessarily confusing. here is a pointful version:    \eb b -> switcher (fmap integrate eb) b
18:48:38 <lf94_> Yeah I'm totally lost at this point
18:48:42 <EvanR> integral :: VectorSpace a => a -> B a -> B a
18:48:59 <lf94_> switcher takes 2 arguments too
18:49:12 <lf94_> So now we have like partial application going on
18:49:13 <jmcarthur> yeah, see my pointful version
18:50:25 <lf94_> So the outside b is not evaluated until it's accessed
18:50:45 <lf94_> I'm seriously just guessing at this point, sorry I can't understand
18:50:49 <julianleviston> If I have a Maybe String, and I want to turn it into an Int, escaping in the case that it‚Äôs Nothing, or in the case that a read fails, how should I do that?
18:50:50 <jmcarthur> i think the more interesting part of this is the first argument to switcher
18:51:12 <julianleviston> All the ways I can think of doing it are syntactically ugly (double case expressions, pretty much
18:51:20 <EvanR> julianleviston: well you can fmap read on the Maybe String to get a Maybe Int
18:51:35 <jmcarthur> lf94_: so the result needs to be segments of the various behaviors that occur in eb. each of these is integrated. how must this work?
18:51:41 <julianleviston> EvanR: but if it fails‚Ä¶? do I use Safe‚Äôs maybeRead ?
18:51:43 <EvanR> er, well use readMay from safe package
18:51:51 <julianleviston> EvanR: that‚Äôs the one.
18:52:04 <EvanR> in which case you get Maybe (Maybe Int)
18:52:13 <julianleviston> yeah
18:52:16 <EvanR> then use join :: Maybe (Maybe a) -> Maybe a
18:52:22 <lf94_> jmcarthur, I have no clue.
18:52:24 <jmcarthur> lf94_: in order to know what value each behavior has "now", you have to start from the beginning of that behavior's history and trace it all the way to the present
18:52:31 <julianleviston> EvanR:  sounds monadic to me.
18:52:33 <andromeda-galaxy> EvanR: or bind...
18:52:38 <julianleviston> EvanR:  except the values are different.
18:52:50 <julianleviston> EvanR:  but that doesn‚Äôt matter, does it?
18:52:54 <julianleviston> :t (>>=)
18:52:55 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:52:57 <lf94_> jmcarthur, I thought the result was a new behaviour from fmap
18:53:00 <julianleviston> cool
18:53:04 <EvanR> yes readMay =<< myMaybeString
18:53:16 <lf94_> jmcarthur, but you're saying all those events actually occur
18:53:18 <julianleviston> I‚Äôll use bind. great‚Ä¶
18:53:20 <julianleviston> EvanR:  thanks.
18:53:23 <jmcarthur> lf94_: the fmap integral stuff is applied to the event *before* switcher is being applied...
18:53:33 <lf94_> jmcarthur, or rather many occurences of an event occur
18:53:56 <jmcarthur> lf94_: each occurrence of the event is a behavior whose value at any given time depends on all of its values up to then
18:54:29 <lf94_> If an occurence is [(T,a)] isn't that not *really* true?
18:54:45 <lf94_> So you could have
18:54:45 <jmcarthur> but that's not what the types say...
18:54:54 <jmcarthur> switcher :: E (B a) -> B a -> B a
18:54:56 <lf94_> hm
18:55:27 <jmcarthur> if we subst E and B for their denotations, we have    switcher :: [(T, T -> a)] -> (T -> a) -> T -> a
18:55:48 <EvanR> lf94_: right, so [(T, integral 0 0 T f0), (T2, integral 0 0 T2 f1)]
18:57:07 <julianleviston> is this wrong ? mCustomerId >>= mayRead :: Int >>= getContent
18:57:15 <julianleviston> I‚Äôm not sure how to specify the mayRead
18:57:20 <julianleviston> constrain*
18:57:21 <lf94_> So using the term I heard before...alternative future...is the switcher causing an alternative future?
18:57:24 <EvanR> Maybe Int
18:57:34 <lf94_> Causing the past to be re-evaluated up to our new future?
18:57:36 <julianleviston> oh ok
18:57:38 <EvanR> julianleviston: it will probably be inferred
18:57:39 <julianleviston> i‚Äôll try that
18:57:44 <julianleviston> ah yeah
18:57:47 <julianleviston> good point. thanks
18:57:47 <jmcarthur> lf94_: I don't know what "alternative future" should mean in the context of FRP.
18:57:57 <lf94_> I just heard EvanR say it
18:58:00 <lf94_> what I mean is
18:58:00 <EvanR> lf94_: i was going along with your idea to eagerly evaluate all these ahead of time
18:58:00 <y> lf94_: you should stop mixing weird things :P
18:58:17 <lf94_> y: I can't help it I'm new to this :(
18:58:26 <jmcarthur> lf94_: Let's consider a couple evaluation strategies for this scenario.
18:58:46 <y> I meant it as you know, smoking and drinking at the same time? that's bad, mmkay? :P just a silly joke
18:59:01 <lf94_> Oh lmao, I thought you meant terminology.
18:59:07 <lf94_> Yeah I don't do either of those.
18:59:15 * EvanR pours 1/3 haskell 1/3 scala 1/3 clojure
18:59:15 <jmcarthur> lf94_: If we use some sort of pull-based, lazy strategy, we don't try to compute any integrals until the event has already occurred. In that case, we have an unbounded of history to hold on to.
18:59:33 <julianleviston> EvanR: what‚Äôs the mayRead / readMay called? I can‚Äôt find it in hoogle
18:59:40 <lf94_> jmcarthur, OK.
18:59:42 <EvanR> julianleviston: package safe
18:59:46 <y> @type Text.Read.readMaybe
18:59:47 <lambdabot> Read a => String -> Maybe a
18:59:48 <y> in base 
18:59:53 <EvanR> or that
19:00:02 <jmcarthur> lf94_: If we use some sort of push-based, eager strategy, we need to try to compute all these behaviors as time moves forward, but we don't even know the full set of behaviors in advance, so we are kind of stuck.
19:00:03 <julianleviston> ah ok
19:00:22 <julianleviston> was looking on the haskell.org hoogle rather than the stackage one.
19:00:23 <julianleviston> thanks
19:00:28 <lf94_> jmcarthur, well just compute them as they come?
19:00:39 <jmcarthur> lf94_: That's the lazy version.
19:00:56 <lf94_> lazy is waiting until the event occurs
19:00:56 <jmcarthur> lf94_: That requires storing history from the beginning of time, due to the integral.
19:01:03 <lf94_> sounds a little different to me
19:01:16 <julianleviston> oh cool it‚Äôs in base.
19:01:19 <jmcarthur> lf94_: the event is producing the behaviors. i don't see the distinction you are making.
19:01:19 <EvanR> lf94_: you dont neceesarily know the precise time of a future event
19:02:26 <lf94_> So in one we wait until an event occurs; in the other we accumulate results of events or something, and then do another thing
19:02:53 <EvanR> the eager thing can be done incrementally specifically for a E(B a) which is just involving integrals at the "top level"
19:02:59 <EvanR> this requires a more complex example
19:03:03 <EvanR> or a different example
19:03:56 <jmcarthur> EvanR: It can't really, unless you know how to lift the behaviors out of the event as a static transformation.
19:03:59 <EvanR> like something that cant be done eagerly / optimistically
19:04:29 <EvanR> jmcarthur: right, and a counterexample would be a program which cant do that
19:04:32 <lf94_> Implementation hell :>
19:04:43 <EvanR> integral of a constant function for example can be
19:04:51 <init> nothing infinite memory/time can't fix
19:05:00 <EvanR> or time travel
19:05:06 <jmcarthur> EvanR: Ah. I was just assuming we were abstracting over what the input event of behaviors was. Okay.
19:05:55 <EvanR> the blog post about this regarding reactive banana used a mouse click or something
19:06:33 <lf94_> OK after re-thinking, yes, how the hell could you ever eagerly evaluate it
19:06:42 <lf94_> You need to be a time traveler
19:07:05 <EvanR> lf94_: for integrals of constant functions, youd just do it.
19:07:24 <lpaste> JulianLeviston pasted ‚ÄúHelp with a do block‚Äù at http://lpaste.net/143811
19:07:25 <EvanR> keep pushing the "integral read head" forward in time
19:07:30 <lf94_> You can eagerly evaluate a mouse click that you know will happen in 6.134 seconds from now?
19:07:58 <EvanR> the swtich involves E (B a), click is a B a so not a good example
19:08:02 <EvanR> click isnt
19:08:09 <julianleviston> EvanR: what have I done wrong in my do (Maybe) do block?
19:08:18 <lf94_> click is the E
19:08:27 <julianleviston> it‚Äôs asking for a required ‚Äòin‚Äô‚Ä¶ which confuses me slightly.
19:08:40 <EvanR> lf94_: yes, so if its fmap (integral constantF) click, you can do it
19:08:40 <lf94_> click is E (B a) since it returns values
19:09:09 <EvanR> well fmap (const (integral constantF)) click
19:09:26 <lf94_> still sounds lazy to me
19:09:37 <EvanR> its not anything, just the program
19:09:48 <lf94_> Well that's what I thought at first
19:10:04 <lf94_> then jmcarthur had be re-evaluate my own thinking about what "eager" and "lazy" really are
19:10:06 <EvanR> at runtime, the integral can be eagerly computed in the background
19:10:14 <lf94_> I know lazy is about evaluating when accessed
19:10:16 <EvanR> before the click
19:10:28 <lf94_> and eager is evaluating everything right away
19:11:03 <jmcarthur> Well, I think lf94_ basically got what I was trying to demonstrate. I don't know where EvanR is going now, but I will leave lf94_ in EvanR's good hands. :) Good night.
19:11:11 <EvanR> lol
19:12:13 <EvanR> lf94_: so Fran is basically lazy. You can check out reactive which made some improvements
19:12:14 <lf94_> jmcarthur, thank you :)
19:12:49 <lf94_> EvanR, I'll be checking out a bunch! FRP so far has been really neat.
19:12:50 <EvanR> but we didnt get to the real counterexample, so im not sure if reactive has the same issue
19:13:18 <lf94_> The first FRP package I'm trying out is Reflex
19:15:21 <EvanR> still havent found any docs on it
19:15:55 <julianleviston> :t toIntegral
19:15:57 <lambdabot>     Not in scope: ‚ÄòtoIntegral‚Äô
19:15:57 <lambdabot>     Perhaps you meant one of these:
19:15:57 <lambdabot>       ‚ÄòfromIntegral‚Äô (imported from Prelude),
19:16:18 <EvanR> :t toInteger
19:16:19 <lambdabot> Integral a => a -> Integer
19:20:43 <jimbow> who taught blacks programming?
19:20:45 <jimbow> do you find it fascinating that subhumans can mimic human behavior so well?
19:20:53 <jimbow> blacks are to humans as donkeys are to horses
19:21:02 <jimbow> so it's not racist
19:21:41 <julianleviston> jimbow: when you say ‚Äúblacks‚Äù, I assumeg you‚Äôre meaning all the objects in the world that have the colour ‚Äúblack‚Äù, yes? Not people‚Ä¶ In which case, how can they program?
19:22:15 <julianleviston> jimbow: like‚Ä¶ my black hat that is here‚Ä¶ it cannot program
19:22:17 <jimbow> no i'm talking about the black "people" that others like to refer the subhumans as since they mimic human behavior really well
19:22:18 <julianleviston> jimbow: it‚Äôs a hat!
19:22:36 <jimbow> blacks are to humans as donkeys are to horses
19:22:36 <julianleviston> jimbow: what do people have to do with programming?
19:22:40 <EvanR> julianleviston: and your monacle?
19:22:44 <julianleviston> jimbow: that‚Äôs a bit off topic here
19:22:52 <julianleviston> EvanR:  haha lol‚Ä¶ no it‚Äôs a cap in this case :P
19:23:01 <jimbow> both horses and donkeys can reproduce
19:23:13 <julianleviston> jimbow: you‚Äôre offtopic, sorry.
19:23:14 <jimbow> same as humans and blacks
19:23:23 <julianleviston> jimbow: this is about haskell programming.
19:23:26 <EvanR> :ops
19:23:39 <julianleviston> jimbow: if you‚Äôd like to talk about haskell, feel free.
19:23:52 <MarcelineVQ> you could just not engage him instead of bothering ops ^^;
19:24:38 <Maxdamantus> @where ops
19:24:38 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
19:24:40 <julianleviston> MarcelineVQ: I was going for ‚Äúmove the action into a slightly different position‚Äù, but if you think allowing the action will be useful, let‚Äôs try that :-)
19:25:24 --- mode: ChanServ set +o Cale
19:25:30 --- mode: Cale set +b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.162.244.81.177
19:25:30 --- kick: jimbow was kicked by Cale (jimbow)
19:25:39 --- mode: Cale set -o Cale
19:25:40 <EvanR> i like how "allowing" is considered such an active thing these days
19:25:58 <EvanR> blame him he allowed it
19:25:59 <julianleviston> EvanR: well, you have to ‚Äúdo‚Äù something :) you have to actively not reply ;-)
19:26:05 <EvanR> .... uh huh
19:26:07 <julianleviston> EvanR:  I wasn‚Äôt meaning it like that tho.
19:26:24 <julianleviston> EvanR: all good.
19:31:00 <julianleviston> :t lift
19:31:02 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
19:31:56 <julianleviston> If I have a value in one monad and I want to put it into a different monad, how can I do that?
19:32:09 <EvanR> Control.Monad.Morph.hoist
19:32:11 <julianleviston> Handler GetContented GetContented -> Maybe T.Text in this case
19:32:16 <EvanR> :t Control.Monad.Morph.hoist
19:32:17 <lambdabot> (Monad m, Control.Monad.Morph.MFunctor t) => (forall a. m a -> n a) -> t m b -> t n b
19:32:20 <julianleviston> hm‚Ä¶ I wonder if I‚Äôm doing something wrong
19:32:52 <EvanR> you can put anything you want in any monad with this
19:32:54 <EvanR> :t return
19:32:56 <lambdabot> Monad m => a -> m a
19:33:16 <julianleviston> yeah I think I should probably actually take the other thing *out* of the first Monad. I‚Äôll do that.
19:33:42 <EvanR> in most monads you arent guaranteed to be able to do that ;)
19:34:31 <julianleviston> god it‚Äôs so easy to get in a complete mess
19:37:45 <julianleviston> <sigh> now my code‚Äôs broken and I don‚Äôt know how to fix it. Oh well‚Ä¶ undo-city for me.
19:38:57 <EvanR> the monad stack got too high and fell over, JENGA
19:39:44 <pharaun> nice
19:39:49 <pharaun> sounds like someone needs a jenga pistol
19:39:55 <julianleviston> no, I just didn‚Äôt understand the 12 error messages that appeared when I was trying to remove some of the monads
19:40:01 <julianleviston> have to do it in smaller steps.
19:40:24 <EvanR> never remove the bottom monad!
19:42:11 <julianleviston> Ah I see the problem‚Ä¶ I was trying to pull something out of a piece that has IO at the bottom
19:49:24 <julianleviston> how do I turn a ByteString into a Text?
19:49:26 <julianleviston> lol
19:49:38 <EvanR> with decodeUtf8
19:50:15 <julianleviston> ah that‚Äôs right. thanks
20:00:46 <qolen> I'm having some trouble running interactive processes from a Haskell script (using createProcess) is there anyone here who can help me with that?
20:01:07 <julianleviston> god this is so hard and it‚Äôs such a simple thing.
20:01:44 <johnw> julianleviston: what is so hard?
20:02:06 <julianleviston> johnw: I‚Äôm trying to refactor my code...
20:02:23 <glguy> qolen: Just show what you tried to do say what it did and what you'd expected. You can put the code on http://lpaste.net
20:02:25 <lpaste> JulianLeviston pasted ‚Äútrying to refactor the mContent piece ‚Äù at http://lpaste.net/143812
20:03:04 <ReinH> or not
20:03:41 <qolen> okay, I'm on it.
20:03:57 <julianleviston> johnw: and I don‚Äôt know how to proceed step by step‚Ä¶ 
20:07:11 <julianleviston> johnw: it‚Äôs a case of I know lots of theory, but applying it is doing my head in.
20:08:12 <EvanR> big monad stack over IO can be confusing
20:08:38 <EvanR> and unnecessary, given what IO can do
20:09:43 <qolen> My code is here: (lpaste.net/143813). I'm expecting it to show a prompt, and when i type in a command it evaluates it in python and prints out the answer. This exactly what it does in ghci (albeit much slower than it should) but if I compile in GHC and then run it, it doesn't get past the prompt
20:10:02 <EvanR> apparently -XBinaryLiterals is a thing, someone asked about this the other day
20:10:57 <julianleviston> EvanR: um‚Ä¶ I don‚Äôt follow
20:11:14 <julianleviston> qolen: it‚Äôs probably buffering, no?
20:11:14 <EvanR> are you doing Snap stuff
20:11:19 <julianleviston> EvanR: yep
20:11:24 <EvanR> k nevermind ;)
20:11:28 <julianleviston> EvanR:  :P
20:11:30 <julianleviston> ok
20:11:40 <julianleviston> EvanR: do you have to be all stackish in snap?
20:11:49 <qolen> julianleviston: what do you mean? I have flush statements in there
20:11:51 <EvanR> dont they drop you into a monad stack
20:11:58 <julianleviston> qolen: oh ok nevermind.
20:12:07 <julianleviston> EvanR: yep. 
20:12:16 <EvanR> youre stuck then
20:12:20 <EvanR> you can only go deeper!
20:12:35 <julianleviston> EvanR: everything‚Äôs in a handler, which has lens‚Ä¶ and MonadIO and‚Ä¶ lol
20:12:53 <julianleviston> a StateT, I mean.
20:13:32 <julianleviston> EvanR: and I‚Äôm also using a postgres lib, which has its own monad things going on.
20:15:59 <julianleviston> EvanR: lol this is the type of getParam, which grabs a param from the HTTP params (the GET in this case): getParam :: MonadSnap m => Data.ByteString.Internal.ByteString -> m (Maybe Data.ByteString.Internal.ByteString)
20:16:55 <EvanR> getParam :: MonadSnap m => ByteString -> m (Maybe ByteString)
20:16:57 <EvanR> whats m in your case
20:17:09 <julianleviston> EvanR: now‚Ä¶ that can obviously return a Nothing, or a Just ByteString‚Ä¶. but the trouble is, that Just ByteString could be empty, in which case I‚Äôd like it to ‚Äúerror‚Äù (which just means render the index in this case)‚Ä¶ and same if it can‚Äôt read an Int from it, and same if that Int can‚Äôt be found in the DB.
20:17:11 <zachmay> Why does Persistent's Entity type's Ord instance require the entity value to have an Ord instance? Isn't the key enough?
20:17:20 <julianleviston> EvanR:  my m is called GetContented
20:17:53 <glguy> qolen: Use the threaded run-time. You can turn it on with -threaded
20:18:28 <julianleviston> EvanR: I mean‚Ä¶ Handler GetContented
20:18:30 <EvanR> julianleviston: you could make "" be treated as Nothing
20:18:48 <julianleviston> EvanR:  well it all looks like a big Maybe chain to me‚Ä¶
20:18:58 <EvanR> except for the ""
20:19:02 <julianleviston> EvanR: a monadic one‚Ä¶ but I can‚Äôt seem to wrangle my types.
20:20:13 <julianleviston> EvanR: mmm  I could write a different function‚Ä¶ yeah‚Ä¶ ok I‚Äôll look at that‚Ä¶ trouble is, as I try to go step by step, I get errors I don‚Äôt understand too well ‚Ä¶ sadtimes.
20:20:22 <julianleviston> EvanR:  I‚Äôll try again :) thanks for the comments/ help
20:24:30 <Big_G> What is the term for two functions where f . g == g . f?
20:25:19 <EvanR> == id ?
20:25:26 <shachaf> You could say "f and g commute", maybe.
20:26:30 <Big_G> shachaf, Is that the technical definition?
20:26:39 <Zekka> EvanR: An example where you don't get id: f = Set.insert 'a'; g = Set.insert 'b'
20:27:17 <Big_G> The example I was thinking of was let f = (filter (\x -> x `mod` 2 == 0) . (takeWhile (\x -> x < 100))) 
20:27:50 <EvanR> nice
20:28:25 <bitemyapp> mac10688: lol
20:28:57 <julianleviston> wow I can‚Äôt believe how much of a nightmare this is
20:29:13 <Zekka> Big_G: Are you sure about htose? Try [100, 1, 200, 300]
20:29:32 <julianleviston> I guess I shouldn‚Äôt be doing this inside my Snap monad. lol.
20:29:32 <Zekka> Er, wait, that's not a correct exmaple
20:29:34 <julianleviston> i‚Äôll continue.
20:29:46 <Zekka> Perhaps: [2, 101, 4, 6]
20:29:57 <Zekka> If you filter first, you get [2, 4, 6], but if you takeWhile first you get [2]
20:30:13 <shachaf> That is f. Presumably g is yet to come.
20:30:29 <Big_G> Looks like they don't commute
20:30:39 <Zekka> I thought he'd coincidentally named his example of both f.
20:31:07 <Big_G> No, the I had takewhile as one function and filter as the other
20:31:15 <Big_G> two many f's to keep track of
20:31:26 <Big_G> I see the point though
20:32:17 <Big_G> So are all functions that meet that requirement considered inverses and make the id function?
20:33:50 <EvanR> f = f . g = g . f = id = g
20:34:08 <EvanR> got it
20:35:01 <Big_G> No, I'm asking if we find the following statement to be true (f . g == g . f), do we say f and g commute, are inverses of eacherother, and g.f == id?
20:35:31 <shachaf> They're certainly not inverses.
20:36:15 <julianleviston> How do I specialise a Maybe T.Text to actually be a MaybeT and MonadIO ?
20:36:37 <julianleviston> can I do it in the type signature ad-hoc style, or must I create a separate newtype for it?
20:38:02 <julianleviston> I guess the type I want is actually MonadIO Maybe (T.Text) is it?
20:38:46 <julianleviston> I think I‚Äôll go read more about MonadTs.
20:38:53 <kadoban> julianleviston: Isn't MonadIO a typeclass?
20:38:54 <nshepperd> commuting and being inverses isn't really related
20:38:55 <johnw> julianleviston: MaybeT . return :: MonadIO m => Maybe T.Text -> MaybeT m T.Text
20:39:59 <julianleviston> johnw: hm
20:40:09 <kadoban> julianleviston: So yeah you want MaybeT IO T.Text, I believe. But yeah looking up and messing with monad transformers is probably a good idea.
20:40:38 <julianleviston> kadoban: I‚Äôve had a read through a bunch of monad transformer things‚Ä¶ but putting theory into practice is different, obviously
20:41:57 <kadoban> julianleviston: Indeed I found it pretty hard at first (and still kinda suck at it), but a project that uses it really helped.
20:42:15 <glguy> I know that qolen left, but the issue with his python code was that python wasn't running in interactive mode when GHC executed it, it could tell it wasn't connected to a terminal
20:42:25 <glguy> in non-interactive mode it parses the whole input before executing
20:42:30 <julianleviston> glguy: maybe leave him a message
20:42:56 <julianleviston> :t MonadT
20:42:57 <lambdabot> Not in scope: data constructor ‚ÄòMonadT‚Äô
20:43:21 <julianleviston> is this in mtl?
20:43:45 <kadoban> julianleviston: I don't think MonadT is a thing.
20:44:25 <julianleviston> MonadTrans ...
20:44:49 <julianleviston> Control.Monad.Trans.Class
20:45:10 <julianleviston> but it‚Äôs not a data constructor
20:45:42 <julianleviston> I‚Äôm so confused.
20:45:45 <noah_> the type you are looking for does seem to be either MaybeT IO a or (MonadIO m) => MaybeT m a
20:46:11 <julianleviston> noah_: so I have to manually make it, don‚Äôt I?
20:46:13 <kadoban> Why do you expect MonadTrans to be a data constructor? AFAIK it's a typeclass that you usually don't directly mess with.
20:46:25 <julianleviston> kadoban: it *is* a typeclass
20:46:47 <julianleviston> kadoban: I wasn‚Äôt expecting it, I was going off something johnw said which I obviously didin‚Äôt understand‚Ä¶ he was expressing a type to me‚Ä¶
20:46:53 <kadoban> Ahh
20:47:23 <julianleviston> noah_: Yeah, I think the latter because I‚Äôm using an instance of MonadIO, not IO directly.
20:47:27 <julianleviston> noah_: AFAIK
20:47:42 <noah_> you have to type it in each time, or wrap it with a type or a newtype.
20:48:10 <julianleviston> noah_: yeah I‚Äôm happy to ad-hoc Type it‚Ä¶ but I just don‚Äôt know how
20:48:30 <johnw> julianleviston: I gave you an expression which had the type of the function you're looking for
20:49:29 <julianleviston> where is MaybeT tho?
20:49:31 <julianleviston> johnw: you did.
20:49:33 <noah_> julianlevision: you can declare something like "type MyMonad m a = (MonadIO m) => MaybeT m a" if you want it wrapped up
20:49:43 <johnw> MaybeT is a data constructor in Control.Monad.Trans.Maybe
20:49:45 <julianleviston> noah_: yeah I‚Äôm happy ad-hocking it.
20:49:59 <julianleviston> johnw: sweet thanks.
20:50:14 <johnw> actually, it's a type wrapper, not a data constructor, technically
20:50:17 <johnw> (since it's a newtype)
20:50:32 <julianleviston> oh god I have no idea what I‚Äôm doing
20:50:39 <julianleviston> the worst part is, I don‚Äôt know how to get a clue.
20:50:49 <johnw> do you know how MaybeT works?
20:50:51 <julianleviston> Quite fine with not knowing what I‚Äôm doing if I have a path to finding out.
20:50:59 <julianleviston> johnw: let‚Äôs assume I don't.
20:51:01 <johnw> it's a type wrapper around "m (Maybe a)"
20:51:14 <johnw> so, MaybeT takes an "m (Maybe a)", and wraps it into a MaybeT m a
20:51:27 <julianleviston> johnw: I don‚Äôt know what you mean by ‚Äúwraps it into
20:51:43 <johnw> it applies a newtype construction around it
20:51:47 <johnw> it changes the type
20:51:55 <julianleviston> johnw: um 
20:51:57 <julianleviston> johnw: ok.
20:52:02 <noah_> :r
20:52:04 <noah_> oops
20:52:06 <johnw> newtype MaybeT m a = MaybeT (m (Maybe a))
20:52:21 <johnw> if that makes no sense, I'd recommend not using MaybeT if you can avoid it
20:52:58 <julianleviston> johnw: I thought a newtype had to have some extra data
20:53:15 <johnw> no, a newtype just allows you to turn something of one type into a new type
20:53:17 <julianleviston> like newtype Yay = Yay a
20:53:25 <johnw> that wouldn't work
20:53:31 <johnw> you can't have a type variable on the right-hand side only
20:53:35 <julianleviston> johnw: hm‚Ä¶ what‚Äôs with runState then?
20:54:03 <julianleviston> johnw: apparently none of the newtype stuff has stuck in my head.
20:54:06 <johnw> newtype State s a = State { runState :: s -> (a, s) }
20:54:21 <johnw> so, runState is an accessor that effectively unwraps the State s a into its underlying function
20:54:33 <johnw> it doesn't "run" anything, contrary to the name
20:54:34 <julianleviston> johnw: ok that makes sense. but in that case aren‚Äôt you having a value ‚Äúinside‚Äù the newtype ?
20:54:43 <julianleviston> johnw: yes, I know - it‚Äôs just an accessor
20:54:51 <johnw> there's no value inside anything
20:54:54 <johnw> newtypes don't exist at runtime
20:54:57 <julianleviston> johnw: what?
20:55:00 <johnw> it's just a way to change the type of something
20:55:13 <johnw> so that you can have separate instances, and so that the newtype type, and the underlying type, don't unify in the type checker
20:55:22 <julianleviston> johnw: there‚Äôs a value if you make a value of that type
20:55:31 <johnw> what I meant is, the newtype isn't there at runtime
20:55:36 <julianleviston> johnw: yes, I know that.
20:55:37 <nshepperd> that's a bit misleading
20:55:44 <nshepperd> conceptually the newtype contains a value
20:55:46 <julianleviston> johnw: it‚Äôs just a type synonym that also checks as a different type.
20:55:57 <johnw> nshepperd: how does it "contain" a value?
20:56:12 <nshepperd> the constructor not being there at runtime is an implementation detail
20:56:22 <julianleviston> johnw: please don‚Äôt start a big niggly-debate.
20:56:24 <S11001001> julianleviston: it's no more inside than outside, because there's nothing else in it
20:56:32 <julianleviston> johnw: sorry, no offense, I just don‚Äôt want to get distracted 
20:56:34 <johnw> julianleviston: I was just trying to help you; go about your way then
20:56:38 <julianleviston> johnw: sigh
20:56:45 <julianleviston> johnw: seriously?
20:56:52 <julianleviston> johnw: I‚Äôm really valuing your help right now.
20:57:04 <johnw> ah, you meant don't debate with nshepperd?
20:57:06 <julianleviston> johnw: I was just asking if you‚Äôd mind, please, not starting a big debate with others while you‚Äôre helping me..
20:57:09 <julianleviston> johnw: yeah
20:57:13 <johnw> ok, sorry
20:57:18 <julianleviston> johnw: no problems at all
20:57:31 <johnw> let's pretend that a newtype is just a convenience wrapper, letting you treat something of type A, as if it were a thing of type B
20:57:33 <julianleviston> johnw: I understand the need to be technically accurate and that‚Äôs one of the reasons I love the haskell community.
20:57:39 <johnw> in this case, an m (Maybe a) as if it were a MaybeT m a
20:57:45 <julianleviston> johnw: yep, sure.
20:57:47 <johnw> why this matters is because their Monad instances are not the same thing
20:57:56 <julianleviston> johnw: same thing as?
20:58:47 <nshepperd> julianleviston: 'm (Maybe a)' has a different Monad instance to 'MaybeT m a'
20:58:55 <julianleviston> nshepperd:  oh??!
20:59:13 <johnw> yes!
20:59:15 <nshepperd> the monad instance for 'm (Maybe a)' is just the monad instance for 'm'
20:59:16 <julianleviston> I don‚Äôt follow
20:59:21 <nshepperd> it doesn't know about the Maybe
20:59:30 <julianleviston> wait what
20:59:34 <nshepperd> it just treats it as a normal value
20:59:35 <julianleviston> could we start that thing again?
20:59:37 <julianleviston> hand on
20:59:45 <johnw> the whole value of MaybeT is that you can chain together functions that return MaybeT things in a convenient way
21:00:09 <julianleviston> I‚Äôm lost right now
21:00:11 <julianleviston> what are we doing?
21:00:26 <johnw> is there still a confusion about newtypes, btw?
21:00:33 <johnw> we should nail that down
21:00:36 <julianleviston> johnw: I don‚Äôt think there ever was, but I don‚Äôt know.
21:00:43 <nshepperd> > [[Just 4], [Nothing]] >>= id
21:00:45 <lambdabot>  [Just 4,Nothing]
21:00:54 <johnw> so, MaybeT is a newtype wrapper that is letting us treat your m (Maybe a) as a different kind of Monad than 'm'
21:01:13 <julianleviston> johnw: I don‚Äôt understand that.
21:01:21 <julianleviston> johnw: the ‚Äútreat‚Äù bit.
21:01:28 <johnw> it doesn't change your value
21:01:38 <julianleviston> I should look up the definition of MaybeT somewhere so I know what on earth you‚Äôre talking about
21:01:40 <johnw> it just changes what ">>=" and "return" mean when applied to that value
21:01:45 <EvanR> its like Product vs Sum Monoids
21:01:59 <johnw> newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }
21:02:09 <julianleviston> ok newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }
21:02:12 <nshepperd> > [Just 4] :: [Maybe Int]
21:02:13 <lambdabot>  [Just 4]
21:02:14 <johnw> yeah, the Sum Monoid is a good example btw
21:02:21 <johnw> right
21:02:24 <nshepperd> > MaybeT [Just 4] :: MaybeT [] Int
21:02:26 <lambdabot>      Not in scope: data constructor ‚ÄòMaybeT‚Äô
21:02:27 <lambdabot>      Perhaps you meant variable ‚Äòmaybe‚Äô (imported from Data.Maybe)    Not in ...
21:02:27 <lambdabot>      Perhaps you meant ‚ÄòMaybe‚Äô (imported from Data.Maybe)
21:02:37 <nshepperd> :(
21:02:43 <johnw> now, we can define instance Monad m => Monad (MaybeT m) where ...
21:02:59 <johnw> I have to go to dinner at this point, I hope nshepperd and EvanR can pick up where I left off; good luck, julianleviston!
21:03:07 <julianleviston> lol
21:03:08 <julianleviston> ok thanks
21:03:17 <julianleviston> I‚Äôm really not sure what is going on
21:03:32 <nshepperd> > MaybeT [Just 4] :: MaybeT [] Int
21:03:34 <lambdabot>  MaybeT [Just 4]
21:04:06 <julianleviston> so this doesn‚Äôt seem to work let x :: (I.MonadIO m) => MaybeT m T.Text
21:06:05 <nshepperd> julianleviston: do you understand the Sum or Product monoids?
21:06:23 <julianleviston> nshepperd: I‚Äôm not sure I can say I understand anything to do with Haskell, but let‚Äôs say I do.
21:06:36 <nshepperd> heh
21:06:40 <nshepperd> as in
21:06:41 <julianleviston> newtype Sum a = Sum {getSum :: a}
21:06:46 <julianleviston> something like that?
21:06:52 <julianleviston> but with a constraint on a ?
21:06:57 <julianleviston> I can‚Äôt remember the definition.
21:07:08 <nshepperd> newtype Sum a = Sum {getSum :: a} is correct, yes
21:07:14 <julianleviston> yep.
21:07:19 <nshepperd> that has instance Num a => Monoid (Sum a)
21:07:21 <julianleviston> Sum 5 <> (Sum 8)
21:07:29 <julianleviston> > Sum 5 <> (Sum 8)
21:07:30 <lambdabot>  Sum {getSum = 13}
21:07:38 <EvanR> > Product 5 <> Product 8
21:07:40 <lambdabot>  Product {getProduct = 40}
21:07:40 <julianleviston> sure.
21:07:57 <nshepperd> right so, there are two different ways you can combine numbers as a monoid
21:08:02 <nshepperd> > 3 <> 4
21:08:04 <lambdabot>      No instance for (Show a0)
21:08:04 <lambdabot>        arising from a use of ‚Äòshow_M316512394695311055127563‚Äô
21:08:04 <lambdabot>      The type variable ‚Äòa0‚Äô is ambiguous
21:08:10 <julianleviston> yeah I don‚Äôt think I was ever unclear on how newtypes work. I haven‚Äôt used them much for myself, so they‚Äôre reasonably theory / (read only, not write) for me, but I get them.
21:08:28 <nshepperd> ^^ that won't work since ints don't have a monoid instance
21:08:36 <nshepperd> because there are two different ways
21:08:44 <julianleviston> nshepperd: yes. I don‚Äôt know what this has to do with the MaybeT monadT‚Ä¶ but yeah, I know that already.
21:09:27 <nshepperd> now, there are also two different ways you can treat IO (Maybe a) as a value in a Monad
21:10:05 <julianleviston> nshepperd: do you mean as MaybeT IO a or MonadIO Maybe a
21:10:23 <julianleviston> nshepperd:  as in‚Ä¶ depending on the order you stack your monadTs?
21:10:25 <nshepperd> MonadIO Maybe a doesn't exist
21:10:38 <julianleviston> nshepperd: oh so what I just said was rubbish?
21:10:40 <nshepperd> you can treat it as an IO b (where b = Maybe a)
21:11:04 <nshepperd> ie. just treat the Nothing or Just x as an ordinary value, don't do anything special with the maybe
21:11:11 <nshepperd> this is the default behaviour
21:11:23 <julianleviston> nshepperd: I don‚Äôt follow.
21:11:46 <nshepperd> eg. 'return (Just 4) >>= print' prints out "Just 4"
21:11:53 <julianleviston> I don‚Äôt understand.
21:12:31 <nshepperd> > return (Just 4) :: IO (Maybe Int)
21:12:33 <lambdabot>  <IO (Maybe Int)>
21:12:36 <julianleviston> oh ok so the first return puts the Just 4 into IO ?
21:12:44 <nshepperd> yes
21:12:44 <julianleviston> ok
21:12:50 <julianleviston> is that called lifting?
21:13:22 <nshepperd> if you like
21:13:31 <nshepperd> I'd call it just putting a value into a monad
21:13:32 <julianleviston> I don‚Äôt. I just want to use the word properly.
21:13:39 <julianleviston> ok
21:13:47 <nshepperd> I'm not sure if there's any technical definition of lifting
21:13:50 <nshepperd> anyway
21:13:53 <julianleviston> ok
21:14:14 <nshepperd> so you understand why 'return (Just 4) >>= print' prints "Just 4"?
21:14:26 <julianleviston> nshepperd: yep.
21:14:45 <nshepperd> that's one way to treat it as a monad
21:15:18 <julianleviston> :t return (Just 4) >>= print
21:15:19 <lambdabot> IO ()
21:15:22 <julianleviston> thought so.
21:15:36 <julianleviston> nshepperd:  yeah, tha‚Äôts the one I‚Äôm *not* interested in doing.
21:15:58 <nshepperd> @let print' = liftIO . print :: (MonadIO m, Show a) => a -> m ()
21:16:00 <lambdabot>  Defined.
21:16:14 <julianleviston> nshepperd:  because all of this existis within an instance of MonadIO
21:16:22 <julianleviston> nshepperd:  (for my app)
21:16:36 <nshepperd> right, so the other way is
21:16:54 <nshepperd> :t MaybeT (return (Just 4)) >>= print'
21:16:55 <lambdabot> MonadIO m => MaybeT m ()
21:17:14 <nshepperd> :t MaybeT (return (Just 4)) >>= print' :: MaybeT IO ()
21:17:16 <lambdabot> MaybeT IO ()
21:17:29 <nshepperd> that one just prints '4'
21:17:36 <julianleviston> my god this is complicated.
21:17:47 <julianleviston> nshepperd:  sorry I‚Äôll try to leave out my commentary.
21:18:01 <nshepperd> it's the same thing as before, but we've wrapped the value in a MaybeT constructor
21:18:17 <nshepperd> MaybeT (return (Just 4)) instead of return (Just 4)
21:18:54 <nshepperd> (and upgraded the print function, but that's only for demonstration purposes)
21:19:19 <julianleviston> nshepperd: at this point, my brain falls out.
21:19:51 <nshepperd> julianleviston: this is equivalent:
21:20:01 <nshepperd> :t return 4 >> print' :: MaybeT IO ()
21:20:02 <lambdabot>     Couldn't match expected type ‚ÄòMaybeT IO ()‚Äô
21:20:02 <lambdabot>                 with actual type ‚Äò() -> m0 ()‚Äô
21:20:02 <lambdabot>     Probable cause: ‚Äòprint'‚Äô is applied to too few arguments
21:20:05 <julianleviston> :t MaybeT
21:20:07 <lambdabot> m (Maybe a) -> MaybeT m a
21:20:09 <nshepperd> :t return 4 >>= print' :: MaybeT IO ()
21:20:10 <lambdabot> MaybeT IO ()
21:20:22 <julianleviston> ok I‚Äôve got it now.
21:20:45 <julianleviston> nshepperd:  hey thanks for helping me by the way. (Just an aside)
21:21:15 <nshepperd> hehe
21:21:20 <julianleviston> :t (return 4 :: Maybe Int) >>= print‚Äô
21:21:21 <lambdabot> lexical error at character '\8217'
21:21:40 <julianleviston> :t (return 4 :: Maybe Int) >>= print'
21:21:41 <lambdabot>     No instance for (MonadIO Maybe) arising from a use of ‚Äòprint'‚Äô
21:21:41 <lambdabot>     In the second argument of ‚Äò(>>=)‚Äô, namely ‚Äòprint'‚Äô
21:21:41 <lambdabot>     In the expression: (return 4 :: Maybe Int) >>= print'
21:22:10 <nshepperd> right, that's actually a MaybeT
21:22:18 <nshepperd> :t (return 4 :: MaybeT IO Int) >>= print'
21:22:19 <lambdabot> MaybeT IO ()
21:22:24 <julianleviston> :t (return 4 :: MaybeT Int) >>= print'
21:22:25 <lambdabot>     The first argument of ‚ÄòMaybeT‚Äô should have kind ‚Äò* -> *‚Äô,
21:22:25 <lambdabot>       but ‚ÄòInt‚Äô has kind ‚Äò*‚Äô
21:22:25 <lambdabot>     In an expression type signature: MaybeT Int
21:22:42 <julianleviston> guh. silly me
21:22:54 <julianleviston> :t (return 4 :: MaybeT IO Int) >>= print'
21:22:55 <lambdabot> MaybeT IO ()
21:23:05 <julianleviston> ok I think I kinda understand it now.
21:23:26 <julianleviston> at least, I get it. I‚Äôll understand it after a few days of using it, probably.
21:23:48 <EvanR> julianleviston: it might help to implement some monad transformers
21:24:01 <julianleviston> EvanR: or it might confuse me lots! :)
21:24:12 <EvanR> well, you wont be more confused surely
21:24:14 <julianleviston> EvanR:  I think implementing them would help later, tho.
21:24:20 <EvanR> if you succeed, you probably wont be!
21:24:24 <julianleviston> EvanR:  lol
21:24:57 <julianleviston> EvanR:  one of those ironic things. I find ‚Äúgetting into a context where you need something, then implementing it‚Äù is very helpful‚Ä¶ 
21:25:11 <julianleviston> EvanR:  so you‚Äôre probably right. because I need it .
21:25:13 <EvanR> theres not much code to them
21:25:24 <EvanR> but you have to get you brain wrapped in a twisted knot
21:25:30 <EvanR> +r
21:25:39 <julianleviston> EvanR: not too sure about that.
21:25:59 <julianleviston> EvanR:  I usually find it‚Äôs pretty easy to do in a theoretical context, and then when I practically need them I don‚Äôt see where the parts fit together.
21:26:07 <EvanR> something like a MaybeT or a FooT that allows you to exit early (same thing!) is not very much code
21:26:25 <EvanR> neither is WriterT, ReaderT etc
21:27:21 <julianleviston> EvanR: I think perhaps you missed what I‚Äôm saying.
21:27:34 <julianleviston> EvanR:  I‚Äôve looked at WriterT, ReaderT, StateT quite a few times.
21:27:43 <EvanR> im definitely not talking about the real deals
21:28:01 <EvanR> i was going to say, two star problem followup, understand the real ReaderT, WriterT etc ;)
21:28:44 <julianleviston> anyway back to trying to implement this and I‚Äôm completely stuck again.
21:28:54 <julianleviston> There are just far too many moving pieces.
21:29:06 <EvanR> i said the same thing
21:29:41 <EvanR> though what do you expect from transformers ;)
21:30:52 <julianleviston> I don‚Äôt follow
21:31:01 <julianleviston> EvanR: is that a joke about the mattel toys?
21:31:07 <EvanR> monads in disguise
21:31:53 <julianleviston> Is this the right type ? x :: (I.MonadIO m) => MaybeT m T.Text
21:31:55 <julianleviston> I have no idea
21:32:00 <julianleviston> :t MaybeT
21:32:01 <lambdabot> m (Maybe a) -> MaybeT m a
21:32:27 <kadoban> julianleviston: It looks like a possible type for sure.
21:32:28 <julianleviston> it seems to be.
21:32:32 <EvanR> definitely a type
21:33:09 <julianleviston> Ok so I‚Äôm getting errors about mismatching MaybeT m Int with Maybe a0 and stuff
21:33:10 <julianleviston> guh
21:33:25 <julianleviston> if I do somethign like this in a do block‚Ä¶ customerIdAsString <- mCustomerId
21:33:31 <julianleviston> what type should the left bit be?
21:33:39 <EvanR> well did you use runMaybeT somewhere
21:33:42 <EvanR> :t runMaybeT
21:33:43 <lambdabot> MaybeT m a -> m (Maybe a)
21:33:48 <julianleviston> no
21:33:55 <julianleviston> where should I do runMaybeT?
21:34:17 <julianleviston> EvanR:  I‚Äôm not even up to the unpacking bit yet
21:34:25 <EvanR> at the point you run the MaybeT IO Text
21:34:40 <EvanR> or whatever the final action is
21:34:43 <lpaste> JulianLeviston pasted ‚Äúthe pain! :) (monadT)‚Äù at http://lpaste.net/143814
21:35:08 <jle`> hm, does that compile?
21:35:16 <lpaste> JulianLeviston revised ‚Äúthe pain! :) (monadT)‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/143814
21:35:23 <julianleviston> jle`: no
21:35:28 <julianleviston> jle`: i added the errors
21:35:33 <jle`> ah ok
21:35:50 <jle`> your problem is line 5
21:35:57 <jle`> well, it depends on what mCustomerId is
21:36:19 <julianleviston> jle`: mCustomerId is a Handler GetContented GetContented () which has an instance of MonadIO
21:36:24 <jle`> but line 5 is Maybe String, but you want MaybeT m String
21:36:26 <julianleviston> oh actually
21:36:55 <julianleviston> jle`: ahhh ok really? with the m?
21:36:58 <jle`> my favorite way of Maybe a -> MaybeT m a is `maybe mzero return`
21:36:59 <EvanR> everything in a do block has to have the same monad
21:37:09 <jle`> julianleviston: well, the important thing is the T, Maybe vs MaybeT
21:37:18 <julianleviston> jle`: ok i‚Äôll loook
21:37:47 <julianleviston> but where am I saying Maybe?
21:37:52 <jle`> on line 5
21:37:56 <julianleviston> no I‚Äôm not.
21:38:02 <jle`> readMaybe returns a Maybe Int, don't it?
21:38:16 <julianleviston> this is line 5 : (customerId :: Int) <- readMaybe $ T.unpack decodedCustomerIdAsString
21:38:23 <EvanR> ghc has a point there
21:38:36 <jle`> yeah, readMaybe (T.unpack decodedCustomerIdAsString) is Maybe Int, here
21:38:53 <jle`> but every line in the block needs to be a MaybeT m a
21:38:56 <julianleviston> ah ok‚Ä¶ so how do I transmute it? with maybe mzero return?
21:39:03 <julianleviston> jle`: really?
21:39:12 <jle`> yeah, every line in a do block has to be the same monad
21:39:14 <jle`> :t (>>=)
21:39:15 <lambdabot> Monad m => m a -> (a -> m b) -> m b
21:39:17 <EvanR> every <- line in a do block has to have the same monad on the right
21:39:18 <julianleviston> jle`: it‚Äôd help if I really understood what was going on I guess‚Ä¶ 
21:39:38 <EvanR> namely MaybeT m
21:39:40 <julianleviston> EvanR:  ok that makes sense.
21:39:50 <julianleviston> EvanR:  but the ‚Äúa‚Äù value can be different right?
21:39:53 <EvanR> yes
21:39:56 <jle`> yeah heh, that's what i meant
21:39:59 <julianleviston> phew
21:40:10 <julianleviston> I was getting worried that my understanding of monads was wrong...
21:40:14 <julianleviston> lol
21:40:26 <jle`> don't worry, i have that feeling every day
21:40:31 <julianleviston> my brain is so annoying‚Ä¶ it just coredumps if it thinks I don‚Äôt know what‚Äôs going on. lol
21:41:11 <jle`> MaybeT is a MonadPlus, so `maybe mzero return` is, "if the result is Nothing, then fail here.  if the result is not, then `return` it as a success"
21:41:39 <jle`> i sort of wish sometimes that there was a cleaner way, because Maybe a -> MaybeT m a is a pretty common pattern
21:41:50 <jle`> it might just be not common enough to warrant its own name i guess, idk
21:41:54 <julianleviston> I guess I just wish there was a simple path to follow, like in clojure‚Ä¶ where you can kind of work out what everything is along the way by inspecting the code.
21:42:02 <EvanR> you can?
21:42:10 <julianleviston> like‚Ä¶ pulling pieces out as separate functions maybe?
21:42:16 <pavonia> :t MaybeT . return
21:42:17 <lambdabot> Monad m => Maybe a -> MaybeT m a
21:42:24 <jle`> MaybeT . return is lame
21:42:29 <jle`> >_____>
21:42:43 <pavonia> But it's cleaner, IMHO
21:42:43 <EvanR> thread first macro, thread last macro, deferred side effects
21:42:59 <julianleviston> EvanR: yeah, I know you hate clojure. Let‚Äôs not bash clojure.
21:43:19 <EvanR> at least if these transformers are as complicated, the compiler will tell you its wrong
21:43:23 <julianleviston> EvanR: I obviously love haskell and am preferring it‚Ä¶ I just want a way to work this stuff out myself without asking you guys every 3 seconds
21:43:48 <jle`> julianleviston: this seemed like magic to me sorta at first, but after a while it all makes sense and you can do it pretty smoothly
21:44:11 <EvanR> transformers are like the part of the kung fu movies where you have to carry the scaling hot kettle across the room
21:44:14 <jle`> one thing you can think of is, "okay, everything in my line has to be MaybeT m a", and think of ways of bringing everything you want into MaybeT m a
21:44:24 <julianleviston> jle`: well, to be fair, I‚Äôm doing VERY complicated things and I‚Äôm only just beginning to be an intermediate haskeller, so yep.
21:44:29 <EvanR> you get the experience, and never want to deal with again ;)
21:44:36 <jle`> this is what Tekmo calls the "functor design pattern"
21:44:45 <julianleviston> jle`: but I don‚Äôt understand what ‚Äúin my line‚Äù means?
21:44:54 <jle`> 1) establish the domain/lowest common denominator of what you want to do
21:45:02 <jle`> 2) figure out a way to pull everything else into that world
21:45:15 <jle`> julianleviston: every line in the do block has to be MaybeT m a
21:45:24 <julianleviston> jle`: oh yes, I know that.
21:45:25 <Guest13805> I installed haskell-stack using brew, and I seem to have a few issues getting things to work.  I am trying to set up emacs to work with haskell, and so I wanted to install packages like stylish-haskell. For whatever reason it says "Warning: cannot determine version of /usr/local/Library/ENV/4.3/gcc: "" The build-tool has reset ENV. --env=std required."
21:45:29 <julianleviston> jle`: that‚Äôs standard monad stuff.
21:45:31 <jle`> so, let's say i wanted to sequence an `m a` in that do block.  then i can use MaybeT :: m a -> MaybeT IO a
21:45:39 <Guest13805> Any ideas about where to find other info?
21:45:58 <jle`> let's say i wanted to sequence a Maybe a in that do block.  then i can use MaybeT . return :: Maybe a -> MaybeT IO a, or maybe mzero return :: Maybe a -> MaybeT IO a
21:46:05 <julianleviston> Guest13805: what platform?
21:46:17 <Guest13805> osx el capitan
21:46:27 <jle`> or let's say I wanted to sequence an m (Maybe a) in my block.  then i can just do MaybeT :: m (Maybe a) -> MaybeT m a
21:46:30 <julianleviston> Guest13805: I didn‚Äôt use brew (that‚Äôs my platform)
21:46:45 <julianleviston> Guest13805: use this: https://ghcformacosx.github.io
21:47:09 <jle`> this is what i sort of did at first...i had a cheat sheet of sorts, which was like: "how to get into MaybeT.  if you have m a, use `lift`.  if you have Maybe a, use MaybeT . return.  if you have m (Maybe a), use MaybeT"
21:47:28 <jle`> establish a "world" you want to work in, and then think about ways you can change everything you have/need into that workd
21:47:55 <julianleviston> jle`: yeah, I get the conceptual parts pretty well
21:48:11 <Guest13805> oh wow, thanks for the link. It seems like it includes everything I would need right?
21:48:23 <jle`> and if course if you have an `a`, then you can use return :: a -> MaybeT m a
21:48:54 <julianleviston> Guest13805: I‚Äôd say so.
21:50:22 <julianleviston> Guest13805: at least, it was the case for me. Installing stack is then pretty easy - you just follow the instructions from the stack github.
21:50:22 <julianleviston> I‚Äôm pretty sure that even includes it
21:50:38 <julianleviston> so how do I turn a Maybe String into a MaybeT String ? return val ?
21:50:50 <julianleviston> oh cool it worked.
21:50:52 <jle`> MaybeT . return, or maybe mzero return
21:50:52 <julianleviston> oh‚Ä¶ odd
21:51:04 <julianleviston> jle`: what is MaybeT.return ?
21:51:12 <julianleviston> :t mzero
21:51:13 <jle`> it is also a Maybe String -> MaybeT m String
21:51:13 <lambdabot> MonadPlus m => m a
21:51:15 <EvanR> :t MaybeT . return
21:51:16 <lambdabot> Monad m => Maybe a -> MaybeT m a
21:51:19 <julianleviston> euughhh
21:51:35 <julianleviston> I‚Äôll stick with return.
21:51:36 <jle`> so there are two paths to go through...but it helps to just pick one and stick with it
21:51:39 <julianleviston> I think I can understand that.
21:51:46 <jle`> return :: String -> MaybeT m String
21:51:49 <julianleviston> customerIdAsString <- return mCustomerId
21:51:51 <jle`> so it won't work if you have a Maybe String
21:51:54 <julianleviston> it works.
21:51:59 <julianleviston> I do have a Maybe String
21:52:02 <julianleviston> (or equiv)
21:52:03 <jle`> x <- return y is the same as let x = f y, btw
21:52:07 <julianleviston> god I hate the haskell string dance by the way.
21:52:13 <jle`> i mean, let x = y
21:52:13 <julianleviston> oh ok
21:52:16 <julianleviston> monad laws
21:52:19 <Guest13805> julianleviston: I Installed GHC 7.10.2 and I followed the checklist, put GHC in my path and everything, but it seems like nothing changed
21:52:31 <jle`> julianleviston: if you use return on a Maybe String, you'll get a MaybeT m (Maybe String)
21:52:31 <EvanR> julianleviston: for production probably better to avoid String and just use Text
21:52:33 <Guest13805> If I write ghc in my zsh shell nothing changes
21:52:35 <julianleviston> Guest13805: what are you using to measure ‚Äúhnothing changed‚Äù?
21:52:42 <julianleviston> jle`: oh‚Ä¶ :(
21:52:52 <julianleviston> jle`: how do I get a MaybeT a from a Maybe a ?
21:52:53 <Guest13805> it just says command not found: ghc
21:52:59 <Guest13805> command not found: stack
21:53:00 <jle`> maybe mzero return, or MaybeT . return
21:53:04 <julianleviston> Guest13805: what does ‚Äúnothing changes‚Äù mean?
21:53:11 <EvanR> :t MaybeT . return -- ;)
21:53:12 <lambdabot> Monad m => Maybe a -> MaybeT m a
21:53:19 <julianleviston> Guest13805: well you need to open a new terminal window
21:53:22 <jle`> `maybe mzero return` makes the most sense to me, because it's like "okay...if you have Nothing, then fail here (mzero).  if you have Just, then return a success that value (return)"
21:53:35 <jle`> `MaybeT . return` is a bunch of newtype nonsense
21:53:35 <julianleviston> jle`: I don‚Äôt understand that at all
21:53:51 <EvanR> it relies on intuition of MonadZero
21:53:52 <julianleviston> jle`: but why is that any different than customerIdAsString <- return mCustomerId ?
21:53:54 <jle`> julianleviston: so, you have Maybe String.  and if it's Nothing, then you want to "fail", right?
21:54:12 <julianleviston> jle`: what does fail mean?
21:54:14 <jle`> and if it's Just x, you want to `return x`, succeed
21:54:20 <EvanR> fail means Nothing
21:54:21 <Guest13805> Ok well when I write cabal --version it says cabal-install version 1.22.6.0
21:54:22 <jle`> julianleviston: in the context of MaybeT, it means stop there
21:54:25 <jle`> and stop executing
21:54:28 <jle`> short-circuit
21:54:28 <julianleviston> jle`: um...
21:54:36 <Guest13805> but it still cant find ghc or stack
21:54:43 <julianleviston> jle`: I just want to pull the value out of a maybe.
21:54:46 <Guest13805> or cabal-install
21:54:50 <EvanR> > fail "omg" :: Maybe Int
21:54:52 <lambdabot>  Nothing
21:54:52 <julianleviston> Guest13805: then I don‚Äôt know sorry
21:54:53 <jle`> what do you want to happen if it's Nothing?
21:54:59 <jle`> do you want the entire block to short-circuit?
21:55:05 <julianleviston> jle`: if WHAT is nothing?
21:55:05 <jle`> and stop executing at that point?
21:55:09 <julianleviston> jle`: which?
21:55:09 <jle`> the Maybe String
21:55:22 <julianleviston> jle`: if it‚Äôs nothing, then it should return nothing. yes.
21:55:31 <julianleviston> jle`: I just assumed it‚Äôd work with Maybe
21:55:36 <julianleviston> god it‚Äôs so complex.
21:55:43 <EvanR> you have two levels of Maybe going on
21:55:51 <julianleviston> EvanR:  but that‚Äôs not what I want
21:55:56 <EvanR> too bad ;)
21:55:59 <jle`> ah, the reason people use MaybeT is so you can choose to short-circuit/fail early
21:56:07 <julianleviston> I have something called a mCustomerId...
21:56:13 <Guest13805> julianleviston: what did you do to install stack on their github. did you install from source, the installer, or brew
21:56:33 <jle`> x <- return y is just let x = y, though
21:56:43 <julianleviston> Guest13805: I installed that thing I sent you, then I went to stack‚Äôs github and followed their instructions.
21:56:51 <julianleviston> Guest13805: but I did this before el capitaine.
21:57:00 <julianleviston> Guest13805: and then I upgraded things.
21:57:55 <hnfmr> A question for stack, I have created a stack project using the "simple" template, and I modified cabal file to include one more dependency, now how can I make stack install the dependency?
21:58:05 <hnfmr> with cabal I could do " cabal install --only-dependencies"
21:58:08 <julianleviston> So how can I get my Maybe String and turn it into a MaybeT String ?
21:58:15 <julianleviston> :t maybe
21:58:16 <EvanR> :t MaybeT . return
21:58:16 <lambdabot> b -> (a -> b) -> Maybe a -> b
21:58:17 <lambdabot> Monad m => Maybe a -> MaybeT m a
21:58:26 <julianleviston> EvanR:  ok. I‚Äôll try that.
21:58:28 <EvanR> julianleviston: you mean MaybeT m String
21:58:42 <julianleviston> EvanR:  oh yeah‚Ä¶ 
21:58:44 <julianleviston> god
21:58:47 <jle`> julianleviston: i was assuming before that you wanted to "bind" on the String and use it on the rest of the block, and if your Maybe String was Nothing, your entire block would short-circuit
21:58:59 <jle`> that's what it means to make it a `MaybeT m String`
21:59:01 <julianleviston> jle`: I think that *is* what I want to do.
21:59:10 <jle`> ah okay
21:59:50 <julianleviston> jle`: so I don‚Äôt know where to put it tho
21:59:54 <julianleviston> jle`: in the do syntax
22:00:01 <jle`> it's a function
22:00:05 <EvanR> using mzero is probably a good way to distinguish the "transformer im using to exit early" from the regular Maybe values you encounter in that transformer
22:00:05 <julianleviston> jle`: yes I know
22:00:06 <jle`> so, find your Maybe String
22:00:09 <jle`> and apply it to that
22:00:16 <EvanR> thinking of them both as Maybe is just confusing
22:00:27 <jle`> your Maybe String here is (readMaybe (T.unpack decodedCustomerIdAsString))
22:00:29 <julianleviston> so like this ? customerIdAsString <- MaybeT . return mCustomerId
22:00:34 <jle`> so apply `MaybeT . return` to that
22:00:41 <julianleviston> jle`: um‚Ä¶ no‚Ä¶ it‚Äôs this: customerIdAsString <- MaybeT . return mCustomerId
22:00:53 <julianleviston> that blows up
22:00:55 <jle`> MaybeT (return (readMaybe (tT.unpack decodedCustomerAsString)))
22:01:02 <jle`> what is the type of mCustomerId?
22:01:11 <julianleviston> it‚Äôs a Maybe ByteString
22:01:26 <julianleviston> what I was calling a Maybe String for you guys
22:01:31 <jle`> btw, if you want to apply `MaybeT . return` to x, it's MaybeT . return $ x, or (MaybeT . return) x
22:01:36 <jle`> MaybeT . return x is MaybeT . (return x)
22:01:49 <julianleviston> oh
22:01:59 <jle`> or you can do MaybeT (return x), too
22:02:05 <julianleviston> jle`: stupid me. Ok that compiles now
22:02:06 <julianleviston> god
22:02:40 <EvanR> :t maybe mzero Just
22:02:42 <lambdabot> Maybe a -> Maybe a
22:02:42 <julianleviston> now I have to do this one. wish me luck: (customerId :: Int) <- readMaybe $ T.unpack decodedCustomerIdAsString
22:02:59 <jle`> same deal here.  your Maybe Int is (readMaybe $ T.unpack decodedCustomerIdAsString)
22:03:04 <jle`> so apply MaybeT . return to that
22:04:05 <jle`> the alternative way that i mentioned earlier would be equivalent to something like this:
22:04:08 <EvanR> :t lift
22:04:09 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
22:04:19 <jle`> case readMaybe (T.unpack decodedCustomerIdAsString) of Just x -> return x; Nothing -> mzero
22:04:27 <jle`> where mzero is, "short-circuit and fail the block here"
22:04:32 <julianleviston> ok. that worked.
22:05:00 <jle`> from the block you gave us, it looks like you never actually do any IO?
22:05:21 <jle`> if you don't ever do any IO you can just use Maybe the entire time, actually
22:05:22 <julianleviston> ok now I‚Äôm up to this bit (the IO part)
22:05:24 <julianleviston> let content = T.pack $ getContent customerId
22:05:25 <jle`> ah ok
22:05:32 <julianleviston> I think this is where I have to use lift, yeah?
22:05:42 <jle`> getContent customerId is IO String ?
22:05:45 <Guest13805> julianleviston ok I got it to work! Instead of using the .zshenv file I added the path to my zshrc and it worked. thank you very much
22:05:55 <julianleviston> Guest13805: cool :)
22:06:06 <julianleviston> jle`: actually it‚Äôs something else‚Ä¶ 
22:06:23 <julianleviston> jle`: getContent :: Int -> Handler GetContented GetContented T.Text
22:06:44 <jle`> ah
22:06:52 <julianleviston> jle`: MonadIO x, MonadIO y=> Handler x y a (I think)
22:07:08 <jle`> well, once you eventually get an IO String out of it, or IO Text somehow, you can use lift :: IO a -> MaybeT IO a
22:07:12 <julianleviston> that‚Äôs not obviously technically correct monad, just saying that Handler is an instance of MonadIO, I think
22:07:19 <jle`> ah
22:07:23 <EvanR> liftIO?
22:07:28 <julianleviston> aha :)
22:07:45 <jle`> liftIO works too
22:07:50 <jle`> for IO a -> MaybeT IO a
22:07:55 <EvanR> how can you be a MonadIO without being a Monad
22:08:57 <jle`> julianleviston: you have to find a way to get an IO action out of a Handler GetContented GetContected T.Text
22:09:02 <jle`> so an IO Text, somehow
22:09:06 <jle`> and then you can use lift or liftIO
22:09:37 <julianleviston> hm...
22:09:55 <julianleviston> jle`: I think liftIO gets an IO action out of a handler, doesn‚Äôt it?
22:10:15 <jle`> liftIO absorbs an IO a into a MonadIO instance
22:10:17 <EvanR> :t liftIO
22:10:18 <lambdabot> MonadIO m => IO a -> m a
22:10:23 <julianleviston> oh
22:10:24 <jle`> so it's kind of the opposite of that
22:10:26 <jle`> heh
22:10:26 <julianleviston> I want the opposite
22:10:29 <julianleviston> crap
22:10:44 <jle`> the library that gives you getContent/Handler probably documents a way
22:10:53 <julianleviston> at the end, I wonder if I have to use return or not.
22:11:03 <julianleviston> lol.. still learning do syntax. (FAIL)
22:11:17 <julianleviston> jle`: I wrote getContent.
22:11:18 <EvanR> :t fail
22:11:19 <lambdabot> Monad m => String -> m a
22:11:27 <julianleviston> jle`: but I‚Äôll look at Handler‚Äôs dox
22:11:36 <jle`> yeah, probably look at Handler then :)
22:12:40 <julianleviston> oh hang on I don‚Äôt want to return an IO anything
22:13:30 <EvanR> you want to execute IO in there
22:13:41 <julianleviston> um‚Ä¶ do I?
22:13:48 <EvanR> if you didnt, you dont need the transformer over IO
22:14:01 <julianleviston> oh coz of getContent :: Int -> Handler GetContented GetContented T.Text
22:14:05 <julianleviston> yeah
22:14:10 <julianleviston> it talks to a DB.
22:14:49 <EvanR> i have a feeling Handler is about to throw a wrench into this whole thing ;)
22:15:12 <julianleviston> well it‚Äôs the m.
22:15:19 <julianleviston> x :: (I.MonadIO m) => MaybeT m T.Text
22:15:21 <andromeda-galaxy> julianleviston: it looks like handler values can only really be evaluated by snap
22:15:33 <julianleviston> andromeda-galaxy: oh?
22:15:57 <EvanR> what is the type of anything that can do anything with a Handler
22:16:02 <andromeda-galaxy> Instead of MaybeT IO a can you use MaybeT (Handler GetContented GetContented) a everywhere?
22:16:19 <jle`> if Handler GetContented GetContented is a Monad, then that def works
22:16:20 <julianleviston> andromeda-galaxy: I don‚Äôt see why not
22:16:34 <julianleviston> andromeda-galaxy: except that might not be what you mean
22:17:07 <andromeda-galaxy> julianleviston: hmm.. Where are you calling the function that you are writing?
22:17:24 <julianleviston> andromeda-galaxy: within customersEditHandler :: Handler GetContented GetContented ()
22:18:09 <andromeda-galaxy> So, you can type this function with a MaybeT around a handler and use runMaybeT to call it
22:18:24 <julianleviston> andromeda-galaxy: should be able to, assuming I know what you‚Äôre talking about
22:18:24 <jle`> if (Handler GetContented GetContented) is a Monad that represents some action, then you can use MaybeT (Handler GetContented GetContented) to sequence failable Handler actions with short-circuiting
22:18:57 <julianleviston> jle`: well Handler GetContented GetContented () is a monad.
22:19:14 <julianleviston> jle`: that‚Äôs what I thought I was doing.
22:19:31 <EvanR> jle`: hmm. what happens if the action fails half way through executing its effects
22:19:39 <jle`> by Monad, i mean the `m` part in the `m a`
22:19:43 <lpaste> JulianLeviston pasted ‚Äúmonads monads, everywhere‚Äù at http://lpaste.net/143817
22:19:52 <julianleviston> this is the function and its enclosing function ^
22:20:02 <julianleviston> jle`: yeah.
22:20:22 <julianleviston> that code doesn‚Äôt run at the moment.
22:20:52 <jle`> okay, so your monad you're working in is Handler GetContented GetContented
22:21:06 <julianleviston> jle`: um‚Ä¶ yeah?
22:21:08 <jle`> so if you used MaybeT, it'd be MaybeT (Handler GetContented GetContented) T.Text
22:21:15 <andromeda-galaxy> x :: (I.MonadIO m) => MaybeT (Handler GetContented GetContented) T.Text
22:21:51 <julianleviston> jle`: ohhh coz MaybeT takes a monad an a value‚Ä¶ ok
22:21:56 <andromeda-galaxy> Sorry, x :: MaybeT (Handler GetContented GetContented) T.Text
22:22:02 <jle`> i like to think of it as, it takes a Monad and returns a Monad
22:22:08 <jle`> but that works too, heh
22:22:23 <julianleviston> that falls apart
22:22:52 <jle`> it looks like you don't ever actually sequence any "failable Handler actions"/"failable IO actions"/"failiable m actions"
22:22:56 <julianleviston> andromeda-galaxy: you don‚Äôt need the constraint, if you‚Äôve got a concrete type do you?
22:23:07 <jle`> hm
22:23:08 <julianleviston> jle`: failable in the context of Maybe...
22:23:15 <jle`> oh i guess it's still useful because you have a lot of Maybe's you want to short-circuit on
22:23:16 <julianleviston> jle`: sure it does.
22:23:27 <julianleviston> jle`: that‚Äôs exactly what I‚Äôve been trying to do :)
22:23:30 <jle`> okay, what's the error here?
22:23:35 <jle`> btw, let x = y; x is the same as y
22:23:35 <julianleviston> jle`: otherwise I‚Äôd just write out a lot of cases.
22:23:36 <andromeda-galaxy> julianleviston: right, that's why I just sent a correction
22:23:41 <julianleviston> jle`: gimme a sec I‚Äôll find it
22:23:55 <julianleviston> jle`: oh it‚Äôs an easy to fix error
22:23:59 <jle`> well, if you just want to sequence a lot of Maybe's, you can just use Maybe and not MaybeT
22:24:16 <jle`> MaybeT is if you want to sequence m (Maybe a)'s together in short-circuiting ways
22:24:22 <julianleviston> I just needed to lift it into the MaybeT.
22:24:23 <jle`> if you just want to sequence a bunch of Maybe's, then you can just use maybe
22:24:26 <julianleviston> now it‚Äôs not erroring
22:24:35 <julianleviston> jle`: oh how do I do that?
22:24:54 <jle`> x = do customerIdAsString <- mCustomerId
22:25:12 <jle`>        customerId <- readMaybe decodedCustomerIdAsString
22:25:31 <jle`> or well it's the last line, so the last line can be readMaybe decodedCustomerIdAsString
22:25:33 <jle`> without naming it
22:25:40 <jle`> x is a Maybe Int
22:25:47 <julianleviston> jle`: sorry I‚Äôm not following what you‚Äôre saying here very well
22:25:49 <jle`> you can do more short-circuiting Maybe stuff
22:25:59 <julianleviston> oh ok
22:26:08 <EvanR> hes just talking about Maybe monad
22:26:17 <julianleviston> so how can I take that MaybeT and turn it into a Maybe now? using runMaybe ?
22:26:19 <julianleviston> :t runMaybe
22:26:26 <julianleviston> hm
22:26:26 <EvanR> runMaybeT
22:26:26 <jle`> hm okay, so you can have x = do customerIdAsString <- mCustomerId; blah blah; readMaybe blah blah
22:26:27 <lambdabot>     Not in scope: ‚ÄòrunMaybe‚Äô
22:26:27 <lambdabot>     Perhaps you meant ‚ÄòrunMaybeT‚Äô (imported from Control.Monad.Trans.Maybe)
22:26:30 <jle`> i'm talking about never even using MaybeT
22:26:33 <julianleviston> oh
22:26:35 <julianleviston> :t runMaybeT
22:26:37 <lambdabot> MaybeT m a -> m (Maybe a)
22:26:41 <julianleviston> boss.
22:26:43 <julianleviston> mode.
22:27:30 <julianleviston> jle`: um hang on a sec.
22:28:20 <julianleviston> cool got it compiling‚Ä¶ 
22:28:24 <julianleviston> jle`: ok so now what were you saying?
22:29:10 <lpaste> jle` annotated ‚Äúmonads monads, everywhere‚Äù with ‚Äúmonads monads, everywhere (annotation)‚Äù at http://lpaste.net/143817#a143818
22:29:13 <andromeda-galaxy> julianleviston: I believe that jle` is considering using Maybe (not MaybeT) for the first bit of x, and moving the getContent call to use the resultant value
22:29:21 <jle`> i annotated things to use only Maybe and never MaybeT
22:29:28 <julianleviston> haha I just tested it, and it worked. woo :)
22:29:52 <jle`> if you never sequence any m (Maybe a)'s in your MaybeT, then it's actually redundent/doesn't add anything, heh
22:30:03 <julianleviston> jle`: that‚Äôs exactly what I‚Äôve been trying to do all day. Thanks :)
22:30:13 <jle`> if all you ever sequence are Maybe a's (and a's) then you only need Maybe...MaybeT doesn't add anything
22:30:31 <jle`> mCustomerId :: Maybe ByteString, readMaybe decoded :: Maybe Int
22:30:32 <julianleviston> jle`: I‚Äôm glad coz I just looked at that code and was like I‚Äôm not sure I want to write Haskell if this is the stuff I have to do to do this simple thing.
22:30:45 <jle`> you only ever use Maybe, so you don't need MaybeT ever
22:30:54 <jle`> julianleviston: did you see my annotation? :)
22:31:03 <julianleviston> jle`: yeah, I just replied about it.
22:31:08 <anohigisavay> hi, http://lpaste.net/143819
22:31:10 <jle`> ah okay
22:31:11 <julianleviston> jle`: I was like ‚ÄúI‚Äôm glad because ..."
22:31:15 <jle`> yeah heh
22:31:18 <julianleviston> jle`: thank you so much for annotating that
22:31:30 <jle`> the only reason you would need MaybeT would be if you also want to sequence a bunch of/multiple m (Maybe a)'s
22:31:41 <jle`> and also maybe some Maybe a's interspersed here and there
22:31:47 <julianleviston> jle`: I‚Äôm a bit confused tho...
22:31:50 <jle`> but here, you don't have a single one in your block
22:31:54 <jle`> so there's no point
22:31:57 <glguy> anohigisavay: You need getBitSize :: FiniteBits dtype => Gene dtype -> Int
22:32:03 <julianleviston> jle`: what happens when the getContent fails?
22:32:35 <jle`> julianleviston: getContent operates in the Handle GetContented GetContented monad, so whatever failure happens is handled by that type
22:32:40 <julianleviston> jle`: and where‚Äôs the read?
22:32:42 <jle`> however that type decides to work with failure
22:32:43 <julianleviston> oh it‚Äôs at the end
22:32:46 <anohigisavay> glguy: yea that will work. but i wonder why gtype is not inferred as FiniteBits from runGene type
22:33:06 <julianleviston> jle`: yeah, but I‚Äôll probably be shifting getContent to return a Maybe ByteString in the not distant future, soo....
22:33:09 <jle`> it is up to the Handle type to decide what "failure" means, how to handle it, etc.
22:33:17 <jle`> ah
22:33:27 <julianleviston> jle`: then wouldn‚Äôt I actually need the things?
22:33:58 <julianleviston> jle`: it‚Äôs actually not too bad, I was just being melodramatic, really.
22:34:02 <jle`> well, you only have one m (Maybe ByteString) in this case, the usage might not be super much
22:34:13 <jle`> *the helpfulness
22:34:15 <jle`> *but*
22:34:20 <jle`> you actually have another m (Maybe something) hidden in your code
22:34:21 <andromeda-galaxy> jle`: just to double check, getContent does not have type Handler GetContented GetContented (Maybe a), right?
22:34:44 <jle`> if you pulled that into your do block, it might make it worth the MaybeT
22:34:48 <andromeda-galaxy> *does have
22:34:49 <jle`> andromeda-galaxy: i was not aware of that :O
22:34:53 <julianleviston> jle`: getContent :: Int -> Handler GetContented GetContented T.Text
22:35:16 <jle`> let me annotate it to absorb getParam and getContent into the do block as a working example of MaybeT
22:35:18 <julianleviston> andromeda-galaxy: internally, it unwraps a Maybe which I‚Äôll expose later‚Ä¶ for now I‚Äôm just returning ‚Äú"
22:35:27 <julianleviston> jle`: I think I love you.
22:35:59 <andromeda-galaxy> Ah, then jle`'s code works, but it gets less elegant if you change the type of getContent
22:36:12 <lpaste> glguy annotated ‚ÄúWhy FiniteBits cannot be inferred from runGene signature‚Äù with ‚ÄúWhy FiniteBits cannot be inferred from runGene signature (annotation)‚Äù at http://lpaste.net/143819#a143820
22:36:31 <julianleviston> andromeda-galaxy: yeah :) well, having gone through this process, it‚Äôs probably going to be much easier for me wrangle MonadT‚Äôs now. :)
22:36:36 <glguy> anohigisavay: You can do it like this
22:36:37 <andromeda-galaxy> Then, the MaybeT approach starts to make sense
22:37:26 <glguy> anohigisavay: You need to use pattern matching instead of a selector to get access to the 'FiniteBits gtype'
22:37:28 <lpaste> jle` annotated ‚Äúmonads monads, everywhere‚Äù with ‚Äúmonads monads, everywhere (annotation) (annotation)‚Äù at http://lpaste.net/143817#a143821
22:37:41 <glguy> anohigisavay: and I believe that you need GADTs for GHC to use that constraint
22:37:48 <shachaf> glguy: You can also do it like data Gene gtype = FiniteBits gtype => Gene { runGene :: gtype }
22:37:52 <jle`> julianleviston: i absorbed mCustomerId into the block, so that you get more milage out of using MaybeT
22:37:58 <jle`> now you have *two* m (Maybe a)'s, so it's slightly more worth it
22:38:26 <shachaf> Though I suspect that putting the constraint on getBitSize instead of in the data type would work better.
22:38:29 <julianleviston> jle`: yeah nice‚Ä¶ good to do - was probably going to end up doing that in a refactor phase, so‚Ä¶ nice :)
22:38:31 <lpaste> jle` revised ‚Äúmonads monads, everywhere (annotation) (annotation)‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/143821
22:38:32 <anohigisavay> glguy: is there any chance to use record syntax with GADTs?
22:38:34 <glguy> shachaf: Yeah, but then it wanted me ot turn on ExistentialQuantification and this felt better overall
22:38:44 <julianleviston> jle`: starting to look pretty :)
22:38:48 <glguy> anohigisavay: Yeah, you can , but you won't get access to the FiniteBits that way
22:38:49 <shachaf> But this way it wanted you to turn on GADTs.
22:38:50 <jle`> (fixed line 11)
22:38:53 <andromeda-galaxy> julianleviston: jle`'s annotation is ezactly what I was suggesting.
22:39:01 <julianleviston> andromeda-galaxy: ah‚Ä¶ cool! :)
22:39:20 <anohigisavay> glguy: alright. thanks man. saved my day :)
22:39:41 <andromeda-galaxy> It uses MaybeT & assumes that getContent returns a Maybe
22:39:54 <glguy> shachaf: yeah, I like that one better :)
22:40:03 <shachaf> OK.
22:41:58 <julianleviston> hm‚Ä¶ this doesn‚Äôt compile now‚Ä¶ (line 3/4 has some issue)
22:42:26 <andromeda-galaxy> Hmm... What is the type of getParam?
22:42:49 <julianleviston> it‚Äôs a Handler GetContented GetContented (ByteString) I think.
22:43:18 <julianleviston> getParam
22:43:18 <julianleviston>   :: MonadSnap m =>
22:43:19 <julianleviston>      Data.ByteString.Internal.ByteString
22:43:20 <julianleviston>      -> m (Maybe Data.ByteString.Internal.ByteString)
22:43:22 <julianleviston> oops
22:43:23 <julianleviston> sorry
22:43:28 <lf94_> EvanR, you know how I was talking about <or> and <and> to combine events? In the FRA paper, it mentions exactly that X)
22:43:32 <andromeda-galaxy> Yeah, that makes more sense
22:44:00 <andromeda-galaxy> Then, remove line 4
22:44:27 <julianleviston> andromeda-galaxy: oh‚Ä¶ duh!
22:44:29 <andromeda-galaxy> And use mCustomerId everywhere
22:44:56 <julianleviston> andromeda-galaxy: yeah, silly me. 
22:45:11 <julianleviston> that‚Äôs a lot simpler
22:45:19 <andromeda-galaxy> Also, I think that line 11 should be MaybeT $ getContent customerId, though I can't check that right now...
22:46:04 <julianleviston> andromeda-galaxy: i have let content = getContent customerId and then lift content on the next line
22:46:15 <julianleviston> :t lift
22:46:17 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
22:46:23 <jle`> yeah i fixed that in my edit, heh
22:46:59 <julianleviston> that‚Äôs the same as lift, right?
22:47:01 <jle`> oh yeah i forgot about that too, sorry
22:47:02 <julianleviston> just not generic
22:47:49 <lpaste> jle` revised ‚Äúmonads monads, everywhere (annotation) (annotation)‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/143821
22:48:01 <jle`> julianleviston: let x = y is just saying, "everywhere in this block where you see x...put y instead"
22:48:17 <julianleviston> jle`: yeah, I know.
22:48:29 <jle`> so let x = y; lift x is the same as lift y
22:48:37 <andromeda-galaxy> jle`: that's exactly what I was thinking of
22:48:40 <julianleviston> yeah
22:48:57 <julianleviston> jle`: i was asking about lift versus MaybeT really
22:49:03 <julianleviston> this is what it currently looks like: I.lift $ getContent customerId
22:49:18 <andromeda-galaxy> Also, you probably don't really need decodedCustomerIdAsText
22:49:22 <chancy> Does Yesod have a console for working with persistent models?
22:49:40 <julianleviston> andromeda-galaxy: then the line will get big
22:50:14 <andromeda-galaxy> True... I was thinking that after these edits you could shorten some of the names
22:50:23 <jle`> julianleviston: MaybeT and lift are actually different
22:50:31 <jle`> MaybeT :: m (Maybe a) -> MaybeT m a
22:50:35 <jle`> lift :: m a -> MaybeT m a
22:50:38 <julianleviston> jle`: oh‚Ä¶ mine‚Äôs working with lift. hm
22:51:02 <julianleviston> jle`: why is it working then, if it‚Äôs wrong?
22:51:04 <jle`> if it's working with lift, then that means that you are giving it an `m a`, and not an `m (Maybe a)`
22:51:35 <jle`> i wrote it with MaybeT expecting getContent to be m (Maybe ByteString), heh
22:51:40 <andromeda-galaxy> or, that it is creating a MaybeT m (Maybe a)
22:51:58 <andromeda-galaxy> Did you change getContent yet?
22:51:59 <julianleviston> jle`: yeah it doesn‚Äôt work with MaybeT
22:52:07 <julianleviston> andromeda-galaxy: to return a Maybe?
22:52:10 <jle`> which line?
22:52:13 <andromeda-galaxy> Yes
22:52:18 <julianleviston> andromeda-galaxy: not just yet.
22:52:22 <julianleviston> andromeda-galaxy: still refactoring slightly
22:52:28 <andromeda-galaxy> That explains it
22:52:34 <julianleviston> andromeda-galaxy: ah haha ok
22:52:38 <jle`> if `getContent customerId` returns `m a`, then you'd use lift
22:52:43 <jle`> if it returns `m (Maybe a)`, then use MaybeT
22:53:00 <julianleviston> I‚Äôll change it now
22:53:31 <julianleviston> jle`: god. I actually know what you‚Äôre talking about ! :)
22:53:33 <julianleviston> haha cool
22:53:59 <andromeda-galaxy> julianleviston: great, I hope that I managed to be somewhat helpful...
22:54:45 <julianleviston> Yeah that didn‚Äôt work.
22:54:49 <julianleviston> nevermind I‚Äôll work it out later
22:55:04 <julianleviston> yeah you‚Äôve all been very helpful...
22:55:35 <julianleviston> thankyou
22:55:56 <andromeda-galaxy> You're welcome
22:56:25 <jle`> np. congrats!
22:56:37 * hackagebot hwsl2 0.4.0.0 - Hashing with SL2  https://hackage.haskell.org/package/hwsl2-0.4.0.0 (srijs)
22:59:23 <EvanR> lf94_: <or> is <> is mappend for events
22:59:43 <EvanR> earlier you were trying to have an <and>.
23:00:06 <EvanR> what would the type of <and> be?
23:03:28 <eklavya> insert :: LogMessage -> MessageTree -> MessageTree
23:03:29 <eklavya> insert (Unknown _) t = t
23:03:29 <eklavya> insert lm@(LogMessage _ ts _) Leaf = Node Leaf lm Leaf
23:03:29 <eklavya> insert lm@(LogMessage _ ts _) (Node l @x(LogMessage _ v _) r) =
23:03:47 <eklavya> here x is inferred to be a MessageTree and not a LogMessage
23:03:50 <eklavya> why?
23:06:04 <jle`> do you mean x@(LogMessage _ v _) ?
23:06:42 <jle`> what are the fields of the Node constructor?
23:06:46 <eklavya> eeeeeeee !
23:06:47 <eklavya> sorry
23:06:55 <eklavya> jle` it works
23:07:01 <eklavya> I had the @ reversed
23:07:14 <eklavya> but how come it's not a syntax error or something else
23:07:33 <jle`> what are the fields of the Node constructor?
23:07:56 <eklavya> Node MessageTree LogMessage MessageTree
23:08:16 <jre2> any general recommendation on tasty vs hspec?
23:08:55 <jle`> from that it looks like it should be a LogMessage.
23:09:41 <eklavya> yes but when I do @x instead of x@ it's not a syntax error but x just gets type MessageTree
23:09:52 <eklavya> how does that work?
23:11:31 <jle`> eklavya: it looks like it's parsing as l@x (LogMessage _ v _) r
23:12:45 <eklavya> but what about the preceding (Node ?
23:13:05 <jle`> sorry, i meant (Node l@x (LogMessage _ v _) r)
23:13:34 <eklavya> is that a valid match?
23:13:50 <eklavya> ok
23:13:51 <eklavya> yeah
23:13:52 <eklavya> got it
23:13:56 <jle`> yes, it's the same as Node x (LogMessage _ v_) r
23:14:01 <eklavya> it just so happened that it matched :P
23:14:15 <eklavya> thanks jle` :)
23:14:23 <jle`> blah is the same as x@blah, except the entire blah thing is also bound to 'x'
23:14:32 <jle`> > let x@y = 5 in (x, y)
23:14:34 <lambdabot>  (5,5)
23:14:46 <eklavya> got it
23:16:26 <MarcelineVQ> as-patterns (@) are awesome
23:19:02 <Supdiop> What is this about?
23:19:44 <Supdiop> Programing ok
23:19:50 <Supdiop> Bye
23:20:12 <MarcelineVQ> I miss Supdiop
23:20:20 <joco42> can I make every RectangleLike also automatically an instance of Translateable ? is that possible in Haskell ?  https://usercontent.irccloud-cdn.com/file/LLYDQmrN/Screen%20Shot%202015-10-25%20at%2008.18.04.png
23:21:02 <jle`> joco42: you can do class Translateable a => RectangleLike a, where any instance of RectangleLike is required to also be an instance of Translateable
23:21:44 <joco42> jle`:  ok, thanks, i try that
23:22:16 <joco42> why i did not think about that ?
23:22:17 <joco42> :)
23:22:43 <jle`> there's another unadvisable way of doing something similar
23:22:52 <jle`> that can ruin everything
23:23:08 <jle`> or at least has a high potential of ruining and breaking everything
23:23:17 <joco42> hmmm...
23:23:29 <jle`> you can write an instance RectangleLike a => Translateable a where ..., and define translate in terms of RectangleLike methods
23:23:32 <joco42> something runtime casting?
23:23:55 <jle`> that way any time you write an instance of RectangleLike, you also get an instance of Translatable for free
23:24:05 <jle`> but this is a Bad Idea(tm)
23:24:12 <joco42> well i want to define translate in rectangle like methods...
23:24:39 <joco42> will the Translateable a => RectangleLike a work like that?
23:24:55 <joco42> coz every Rectangle should be Translatable...
23:25:33 <jle`> you can't do it for all Transatable's in general, becuase not all Translatables are RectangleLike
23:25:48 <jle`> but when you actually write your instances, you can define `translate` for your type/instance using methods from RectangleLike
23:26:04 <jle`> instance RectangleLike MyType where; instance Translatable MyType were; ...
23:26:16 <jle`> you can use methods from RectangleLike in your instance for Translatable
23:26:37 <joco42> jle`:  hmmm,  I was thinking doing that in the class declaration...
23:26:48 <joco42> like it is done with scaleCenter
23:27:07 <jle`> it doesn't make sense to do it in the class declaration for Translatable, because not every Translatable is RectangleLike
23:27:46 <jle`> unless i misunderstood you, and you want every Translatable to also necessarily be RectangleLike
23:27:52 <joco42> no
23:28:12 <joco42> but if somthing already a RectangleLike
23:28:28 <joco42> let me write this down , its easier to communicate
23:28:40 <jle`> you can do what the base libraries do, and offer a translateUsingRectangleLikeMethods
23:29:00 <jle`> that is `translate`, but using only RectangleLike methods so generic over all RectangleLike's
23:29:17 <jle`> and then, instance Translatable Foo where translate = translateUsingRectangleLikeMethods
23:29:25 <jle`> this is why liftM, liftA, etc. exist
23:29:31 <jle`> (and ap)
23:30:20 <lf94_> EvanR, ooops, yeah I guess not and.
23:30:32 <jle`> hm, you also might be able to do something with the DefaultSignatures extension
23:30:53 <jle`> translate :: V2 Float -> a -> a
23:30:53 <EvanR> lf94_: me neither, but many libraries out there have decided it makes sense in at least two ways
23:31:04 <jle`> default translate :: RectangleLike a => V2 Float -> a -> a
23:31:13 <jle`> translate = define-it-here-assuming-a-RectangleLike-instance
23:32:19 <joco42> jle`:  i tried it out
23:32:23 <joco42> here is the result
23:32:35 <EvanR> lf94_: way one, imagine an event as a buffer or channel which piles up with occurrences. now e1 and e2 does nothing as long as e1 or e2 is empty. as soon as e1 and e2 are both not empty, say with values v1 and v2, then emit occurrence (v1,v2) and dequeue from the channels
23:32:35 <joco42> https://usercontent.irccloud-cdn.com/file/IQIoQGZO/Screen%20Shot%202015-10-25%20at%2008.31.44.png
23:33:16 <jle`> joco42: ah yeah, no, you can't do that.  translate has to be defined in the Translatable instance
23:33:27 <EvanR> lf94_: actually the other way is so complex i cant even explain it
23:33:28 <joco42> jle`:  why?
23:33:34 <joco42> this is strange...
23:33:35 <jle`> because it's a method of Translatable
23:33:42 <jle`> not of RectangleLike
23:34:04 <lf94_> EvanR, gotchya
23:34:11 <joco42> yeah, but what is preventing haskell for allowing this?
23:34:16 <EvanR> lf94_: apparently stuff like this is useful when you dont have Bs
23:34:23 <joco42> is there any fundamental reason?
23:34:31 <jle`> well, if something is an instance of RectangleLike, then it means that it already has a valid instance of Translatable
23:34:41 <lf94_> EvanR, if you don't have Bs sounds useless to me :)
23:35:00 <jle`> so it already has a valid `translate`
23:35:14 <lf94_> EvanR: I'll just stick with the idea that having just <or> is the only thing that makes sense.
23:35:17 <EvanR> you can simulate Bs as e1 <and> e2 where when e2 happens, you get the last value of e1 as a pair 
23:35:29 <joco42> jle`:  but in this case every information is there to do this...
23:35:30 <lf94_> EvanR: The first <and> example seems OK...just complex implementation
23:35:41 <joco42> is there some language pragma to do something like this ?
23:35:45 <EvanR> lf94_: well... and inefficient
23:35:46 <lf94_> Compared to <or>
23:36:06 <jle`> joco42: but any instance of Rectangle already has a valid `translate` defined on it
23:36:08 <EvanR> its not really ok in general, since one event may be finite
23:36:15 <lf94_> Yeah. Scale that to millions of events.
23:36:16 <EvanR> and the other piles up forever
23:36:25 <jle`> that would be like class Eq a => Ord a where (>=) = ..; (==) = ...
23:36:50 <jle`> typeclass declarations are supposed to describe methods of that typeclass
23:37:08 <joco42> jle`:  but if i want to reuse RectangleLike's methods for RectangleLike stuff....
23:37:10 <EvanR> lf94_: and i cant think of a good reason to want to do it
23:37:11 <jle`> and like i said, any instance of Ord will already have (==) defined on it
23:37:24 <joco42> i mean, i can do this in Java
23:37:34 <joco42> why can i not do this in Haskell ? (
23:37:35 <jle`> typeclasses in haskell aren't related to classes in java
23:37:50 <joco42> jle`:  they are related to interfaces...
23:38:08 <joco42> in can do this even in Scala with traits...
23:38:15 <joco42> so why is this limitation?
23:38:33 <joco42> i am sure there is a good reason for it...
23:38:36 <jle`> every RectangleLike instance already has a valid defined translate
23:38:39 <joco42> and probably SPJ knows...
23:38:46 <jle`> so it doesn't make sense to define translate inside RectangleLike
23:38:53 <jle`> one is already defined
23:38:58 <joco42> no...
23:39:11 <jle`> yes; if something is an instance of RectangleLike, that means that it already has `translate` defined on it
23:39:17 <jle`> that's what Translatable a => RectangleLike a means
23:39:19 <joco42> hmmm
23:39:26 <joco42> ok
23:39:32 <joco42> i see
23:39:48 <jle`> so it's like if i wrote an Ord typeclass that also gave an implementation for (==)
23:39:59 <jle`> but that's kind of silly because everything that is Ord already has (==) defined on it...
23:40:28 <jle`> what you can do is flip what you have and put a default definition for `translate`, that is used when your type is also a RectangleLike
23:41:03 <jle`> in your Translateable typeclass, you can put default translate :: RectangleLike a => V2 Float -> a -> a; translate v r = ...
23:41:03 <gfixler> the shrink example for quickcheck this bit: [Branch x' l' r' | (x', l', r') <- shrink (x, l, r)]
23:41:16 <gfixler> at the end, is that shrinking a 3-tuple?
23:41:18 <joco42> hmmm
23:41:24 <joco42> let me try that
23:42:09 <joco42> does not work... https://usercontent.irccloud-cdn.com/file/vcOCvczb/Screen%20Shot%202015-10-25%20at%2008.41.27.png
23:42:41 <jle`> i meant, put in in the Translatable typeclass
23:42:56 <joco42> oh , yeah ...
23:42:58 <nitrix> I have a somewhat controversial question. The more I learn about Haskell, the more I realise the amount of idioms and habits I have developed around my time as a procedural developer that are completely made obsolete (e.g. writing algorithm that are lazy instead of an overall lazy strategy, or being defensive because of side effects and so on)
23:43:11 <jle`> `class Translateable a where translate :: V2 Float -> a -> a; default translate :: RectangleLike a => V2 Float -> a -> a; translate v r = ...
23:43:52 <nitrix> My question is, how do you react to someone that doesn't have any of that knowledge. For me it screams "please have a look at Haskell", but they have valid arguments why they wouldn't and it actually saddens me.
23:43:52 <jle`> you'll need to turn on DefaultSignatures
23:43:54 <joco42> but then I face the problem that not every Rranslatable  is RectangleLike ... 
23:43:56 <joco42> again
23:43:59 <joco42> or not ?
23:44:15 <jle`> the way DefaultSignatures works is that that default definition is offered in the case that your type is also RectangleLike
23:44:21 <jle`> and if it isn't, the perosn has to manually define translate themselves
23:44:43 <joco42> holy shit, :) this is what i was looking for :)
23:44:51 <joco42> i think
23:45:22 <joco42> jle`:  thanks!
23:45:30 <jle`> if you have that set up, then instance Translatable Foo; instance RectangelLike Foo where ...; should work
23:45:37 <jle`> and the Translatable instance should automatically be filled out
23:46:02 <joco42> yeah ;)
23:46:05 <joco42> exactly 
23:46:07 <joco42> nice
23:46:37 <joco42> lemme try
23:47:09 <gfixler> ah, the source is revealing: shrink (x, y, z) = [ (x', y', z') | (x', (y', z')) <- shrink (x, (y, z)) ]
23:47:24 <joco42> can i have multiple defaults ?
23:47:33 <joco42> say CircleLike...
23:47:55 <gfixler> and I just learned an interesting way of recursing over n-tuples
23:48:07 <jle`> joco42: i haven't tried, and i'm not sure
23:48:27 <joco42> ok, well, this is a good start though, thanks
23:48:41 <jle`> joco42: the more sane way of doing this would be to write translateRectangle = ..., translateCircle = ..., etc. using polymorphic methods from the appropriate typeclasses
23:48:53 <jle`> and then letting the person write instance Transtable a where translate = translateRectangle
23:49:07 <joco42> hmmm...
23:49:09 <joco42> maybe
23:49:18 <jle`> that way the person can choose which default one they want
23:49:54 <jle`> translateRectangle not being a part of the RectangleLike typeclass, but just as a normally defined function
23:50:13 <joco42> yeah...
23:50:21 <joco42> actually that sounds kinda clean
23:50:49 <jle`> this is the path that the base library chooses, with liftM, liftA, ap, fmapDefault, etc.
23:51:03 <joco42> jle`:  i see
23:51:11 <joco42> yeah, clean and explicit
23:51:25 <jle`> multiple defaults would be interesting, but it might get complicated if you have types that satisfy more than one default implementation
23:51:34 <joco42> yeah
23:51:36 <joco42> indeed
23:51:36 <jle`> what if a type is both RectangleLike and CircleLike, for example?
23:51:47 <joco42> yeah, indeed
23:51:56 <joco42> though then one should get a compiler error
23:52:03 <joco42> maybe that should be disallowed
23:52:30 <joco42> that would be the diamond problem
23:52:42 <joco42> in oo
23:53:09 <joco42> scala solves that by linearization...
23:53:17 <joco42> but that is too compilcated... imho
23:53:23 <EvanR> joco42: its not a problem in haskell since prereq classes arent doing inheritance
23:53:41 <joco42> prereq?
23:53:53 <EvanR> like class Functor a => Monad a where
23:53:59 <hnfmr> If I have 3 types already: TypeA, TypeB, TypeC, how can I achieve something like this? data Type = TypeA | TypeB | TypeC?
23:54:24 <EvanR> data MyType = MyTypeA TypeA | MyTypeB TypeB | MyTypeC TypeC
23:54:25 <hnfmr> I want to make Type a super type of TypeA, TypeB and TypeC
23:54:35 <EvanR> no subtyping in haskell
23:54:49 <joco42> yeah, no subtyping...
23:54:57 <hnfmr> EvanR: then I do pattern matching on MyType?
23:55:03 <EvanR> see my example
23:55:10 <joco42> ok, jle`  , gotta go, many thanks for the tip
23:55:21 <hnfmr> ok thanks
23:55:22 <jle`> np!
23:55:23 <joco42> i am gonna try it later today
23:55:26 <jle`> happy haskelling
23:55:39 <joco42> my car is heating up.....
23:55:42 <EvanR> in fact diamonds in the instance network are useful for doing reasoning!
23:56:11 <EvanR> A implies B implies D = A implies C implies D
23:56:56 <EvanR> if A B C and D meant anything important, i guess that would be nice ;)
23:58:05 <EvanR> hnfmr: feel free to ask more specific questions about your problem, since there might be a more haskelly way to accomplish it
23:58:26 <EvanR> subtype patterns for example usually dont get implemented that way
