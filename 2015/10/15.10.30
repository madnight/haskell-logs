00:47:16 <oftl> using record syntax functions yielding single values are created. that's cool. but i can't repeat names (keys ?) in another record-syntax-friend, can i ?
00:49:10 <oftl> where the record-syntax-friend would be a type :)
01:00:37 <brnhy> Hi oftl, it's a fairly common annoyance for most of us. There are a number of workarounds such as https://nikita-volkov.github.io/record/ and http://statusfailed.com/blog/2013/02/19/overloading-record-fields-with-lens.html 
01:01:15 <brnhy> Hopefully in GHC 8.0? there will be a codified approach within the compiler/base: https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields
01:01:48 <brnhy> To answer your actual question, no, you can't, without some workarounds :)
01:02:05 <oftl> i see, thanks :)
01:03:08 <oftl> (i always liked discovering known annyances ;-)
01:10:55 <oftl> is there maybe a way to make ghci print records indented ?
01:12:02 <lesshaste> There is a cute competition at http://codegolf.stackexchange.com/questions/62095/a-single-pixel-moving-round-a-circle/62189 and it would be great to have a Haskell answer too
01:12:11 <lesshaste> if anyone is feeling keen :)
01:13:50 <brnhy> oftl: If you don't want to write Pretty instances by hand (http://hackage.haskell.org/package/pretty) you can use http://hackage.haskell.org/package/pretty-show to somewhat automatically indent any type with a 'Show' instance
01:14:48 <brnhy> Specifically using: http://hackage.haskell.org/package/pretty-show-1.6.9/docs/Text-Show-Pretty.html#v:ppShow
01:20:25 <oftl> brnhy: thanks
01:20:41 <oftl> think i have enough to read now for tonight :-)
01:21:30 <brnhy> Good luck!
01:21:35 <oftl> thanks
01:22:19 <oftl> is it just me (and my english), or does ppShow sound misleading when read out loud ? ;-)
01:22:54 * hackagebot template-yj 0.0.0.2 - Process template file  https://hackage.haskell.org/package/template-yj-0.0.0.2 (YoshikuniJujo)
02:10:03 <ely-se> Is id considered a higher-order function? It accepts functions as argument.
02:11:23 <Cale> ely-se: heh
02:11:48 <Freundlich> No, I don't think so. It's the other way around: If a function has to take a function as argument, it's higher order.
02:11:57 <Freundlich> Otherwise polymorphism would make almost every function higher order.
02:13:18 <ely-se> Well, most functions in Haskell are higher-order anyway, because they return functions.
02:13:48 <ely-se> Whatever, this is pointless bikeshedding. :P
02:15:15 <shanemikel> despite the curry behavior, the most useful definition of higher-order, is a function that's meant to wrap a wide variety of functions in some way that has little to do with their computations, and much to do with signature, or abstract behavior
02:15:29 <ely-se> yes
02:16:02 <shanemikel> so sortBy I wouldn't consider a higher-order function
02:16:12 <shanemikel> but flip I would
02:21:28 <shanemikel> but sortBy would be higher-order than sort, because it could potentially be curried to produce more specific functions before a call... so the less abstract definition would be a function you can further-specialize in a useful way before calling
02:22:53 <shanemikel> I think it should be green
02:30:13 <quicksilver> I don't see why that's a useful definition of higher-order
02:30:26 <quicksilver> I would say sortBy is definitely higher-order.
02:33:23 <joeyh> nomeata: http://tmp.kitenet.net/demo2.gif .. about ready to replace concurrentoutput I think
02:35:05 <quicksilver> that's cute joeyh 
02:35:10 <shanemikel> there has to be a distinction between functions that utilize other functions to perform meaningful computation (like sortBy), and functions that I conceive as alter a function, or group of functions, like flip, (.), fmap, etc.. quicksilver is there a definition that makes that distinction?
02:35:12 <quicksilver> I don't entirely know what it is, but it's cute
02:36:11 <quicksilver> shanemikel: well the ones that 'alter a function' probably return a function?
02:36:21 <quicksilver> whereas some just return a value
02:37:22 <shanemikel> but in that definition, every multi-parameter fn is higher-order
02:38:15 <quicksilver> true enough
02:38:19 <quicksilver> but we can pretend to ignore that
02:38:26 <quicksilver> we can pretend they're all uncurried or something.
02:38:48 <quicksilver> :t uncurry sortBy
02:38:49 <lambdabot> (a -> a -> Ordering, [a]) -> [a]
02:38:53 <shanemikel> sure, but since we're using a curried language, we can just forget the 'higher-order' concept and say that its a fn, because they all behave that way
02:38:59 <quicksilver> yes, we can :)
02:39:19 <shanemikel> OR, we can find a more abstract way to give higher-order meaning
02:39:21 <quicksilver> it's a more meaningful distinction in some other languages than haskell
02:45:42 <shanemikel> maybe meta-programming is the right word
02:47:51 <quicksilver> meta-programming has a distinct meaning though
02:48:13 <quicksilver> meta-programming is when you have to write a program to generate (part of) a program, presumably because you couldn't express it directly.
02:50:47 <shanemikel> function wrapping (or decoration in languages like python) isn't so far off from code generation, it just happens at run-time
02:51:17 <shanemikel> in some languages, even types happen at run-time
02:57:04 <quicksilver> I agree, not far off; and things which are require metaprogramming in one system do not require it in another
02:57:24 <quicksilver> in GHC sometimes type system extensions let us write something directly where previously it required metaprogramming
02:57:32 <quicksilver> but I still think it's clear what metaprogramming means.
03:01:37 <shanemikel> I feel like I've heard it (perhaps mis-) used in some circles to encompass both approaches to that end, but that's what jargon is for.
03:03:15 <shanemikel> on another note, is hoogle open source?
03:03:25 <quicksilver> I thought it was
03:03:43 <quicksilver> https://github.com/ndmitchell/hoogle
03:08:21 <shanemikel> thanks
03:15:15 <farnoy> Hi, can I get some help with this? https://redd.it/3qm1u4
03:21:36 <nomeata> joeyh: Great :-)
03:22:37 <nomeata> Is Antti-Juhani Kaijanaho here?
03:22:48 <nomeata> whois ibid
03:23:00 <nomeata> ah, that lacks a /
03:23:09 <nomeata> but looks like that is Antti-Juhani :-)
03:23:12 * hackagebot combinat-diagrams 0.2 - Graphical representations for various combinatorial objects  https://hackage.haskell.org/package/combinat-diagrams-0.2 (BalazsKomuves)
03:23:34 <nomeata> ibid: Can we get Joey Hess on planet.debian.org in time before he blogs about http://tmp.kitenet.net/demo2.gif (presuming he does :-))
03:25:27 <quicksilver> is joeyh not on planet.debian? he's been involved in debian for 20 years...
03:26:12 <nomeata> sorry, planet.haskell.org of course
03:26:30 <nomeata> He is doing cool stuff with Haskell and definitely on topic there.
03:26:47 <quicksilver> ah :)
03:35:08 <frerich> 'Arc Float Float Float -- A circular arc drawn counter-clockwise between two angles (in degrees) at the given radius.'  *grumble*
03:35:21 <frerich> I take bets which of those floats is the radius :-}
03:36:23 <statusfailed> frerich: middle one!
03:39:13 <Jinxit> frerich: third
03:39:18 <Jinxit> going by the order of the description
03:39:48 <quicksilver> Yes and then (Arc 60 75) works like Circle, having type Float -> Shape
03:39:54 <quicksilver> which seems right
03:40:11 <frerich> Ok ok y'all are smart enough to deduce it, but I had to try!
04:00:20 <frerich> Hm, I suppose it's out of scope, but maybe it's possible anyway: does anybody know how to draw a single pixel with gloss? I saw that there's some support for bitmaps (even generated programmatically) but that's it. :-}
04:07:31 <quicksilver> frerich: well bitmapOfByteString 1 1 will presumably work?
04:08:14 <frerich> Yeah, maybe, or a line of length 1.
04:08:22 <quicksilver> btu I agree it's not "really" what gloss is for
04:08:29 <quicksilver> or a circle of radius 0.5?
04:13:41 <quicksilver> using small circles seems more natural in the context of that particular library
04:13:44 <quicksilver> they're scalable etc
04:18:44 * hackagebot luminance 0.6.0.2 - Type-safe, type-level and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.6.0.2 (DimitriSabadie)
04:22:00 <phaazon> hm, is there a way to install a new version of a dependency with stack?
04:22:14 <phaazon> do I have to use another resolver?
04:22:54 <phaazon> ah dammit, semigroups 0.17 is not in stackage yet
04:25:54 <muesli4> I just learned some FRP with reactive-banana. But I need to use some custom monad with reactimate (which provides MonadIO), which is not possible. Is there another FRP implementation that allows that? Can somebody recommend one?
04:26:05 <kqr> this is not an entirely related question but I'll shoot anyway: is there really no standard (like IEEE floats) for representation of unbounded ints (other than as an ascii string)
04:30:00 <quicksilver> simply using bytes as a base-256 representation is natural
04:30:14 <quicksilver> but there are details about how to encode length and sign and I'm not aware of a standard
04:31:12 <phaazon> reinstalling gl -> bad idea :D
04:36:13 <vulk4n0> Hi everyone
04:40:11 <frerich> lesshaste: I just contributed a Haskell version to the codegolf competition you posted, at http://codegolf.stackexchange.com/a/62205/13333 -- the first time I ever did something with gloss.
04:40:23 <lesshaste> frerich, fantastic!
04:40:29 <lesshaste> how do you install gloss?
04:40:44 <phaazon> stack install gloss?
04:40:51 <phaazon> cabal install gloss?
04:41:21 * frerich reviews his own code on stackexchange and things he uploaded a version where he mixed up translation and rotation, ahem
04:43:45 * hackagebot luminance 0.6.0.3 - Type-safe, type-level and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.6.0.3 (DimitriSabadie)
04:43:47 * hackagebot cgrep 6.5.9 - Command line tool  https://hackage.haskell.org/package/cgrep-6.5.9 (NicolaBonelli)
04:43:51 * lesshaste is installing gloss
04:43:59 <mrkgnao> is this combinator well-known or anything?
04:44:11 <mrkgnao> xi f g e x = e (f x) (g x)
04:44:12 <lesshaste> ExitFailure 1
04:44:13 <lesshaste> gloss-1.8.1.2 depends on GLUT-2.4.0.0 which failed to install.
04:44:56 <mrkgnao> it's for things like \x -> x == reverse x.
04:45:26 <phaazon> mrkgnao: hm
04:45:30 <phaazon> looks like on
04:45:32 <phaazon> :t on
04:45:34 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
04:45:56 <phaazon> but on applies the same function on both argument
04:46:05 <phaazon> while you apply two functions to the same argument
04:46:06 <frerich> mrkgnao: http://hackage.haskell.org/package/concatenative-1.0.1/docs/Control-Concatenative.html#v:bi has the exact type you describe
04:46:19 <frerich> mrkgnao: It's not a 'common function' though
04:46:54 <mrkgnao> I agree. I've used this pattern sometimes, though. 
04:47:02 <mrkgnao> Thanks!
04:47:04 <lesshaste> I can't seem to install gloss  
04:47:12 <lesshaste> http://paste.ubuntu.com/13008241/
04:47:18 <lesshaste> anyone know how to deal with this?
04:47:56 <phaazon> lesshaste: do you have stack installed?
04:48:06 <lesshaste> no.. I can try to get that
04:48:11 <lesshaste> phaazon, does that work better?
04:48:19 <phaazon> it’ll help a lot with that kind of nasty issues
04:48:20 <phaazon> even though
04:48:24 <phaazon> you should try to unregister OpenGL
04:48:32 <lesshaste> how do I do that??
04:48:35 <phaazon> ghc-pkg unregister OpenGL-2.8.0.0
04:48:41 <phaazon> the hash is not the same
04:49:44 <lesshaste> trying that
04:49:53 <lesshaste> looks like it worked!
04:50:01 <mrkgnao> oh, apparently, if I change the order of the arguments a bit, it becomes liftM2.
04:50:05 <mrkgnao> heh.
04:50:27 <phaazon> lesshaste: try installing again
04:50:34 <lesshaste> phaazon, thanks! It worked
04:50:37 <phaazon> ah?
04:50:40 <phaazon> great :)
04:50:46 <lesshaste> frerich, I get
04:50:47 <MarcelineVQ> https://github.com/NICTA/course/blob/master/src/Course/State.hs why does `distinct` suggest I use a Set with filtering and State? I can just convert to a Set and back to a List if I wanted to involve Set in the problem, am​ I missing something?
04:51:07 <phaazon> I still don’t get why stack / cabal don’t provide a way to unregister packages
04:51:21 <phaazon> if they have an “install” command
04:51:23 <lesshaste> frerich, hmm.. how should I run your code from ghci? I tried 
04:51:24 <lesshaste> animate(InWindow "" (100,100) (0,0))white$ \t->color(makeColor 0.5 0.0 0.5 1.0).rotate(t*6).translate 38 0$circle 1
04:51:28 <phaazon> they should have the oppposite command
04:51:30 <phaazon> like, uninstall
04:51:41 <frerich> lesshaste: I don't know much about installation issues, sorry. I'm on OS X and I just did 'cabal sandbox init; cabal install gloss; vim main.hs' and then I repeatedly ran 'cabal exec -- ghc main.hs && ./main' for testing
04:52:38 <MarcelineVQ> phaazon: it's easier to break things with an uninstall than an install, you can remove packages with ghc-pkg if you need to, that seperation is probably to save users from themselves more often than not.
04:53:18 <MarcelineVQ> It's hard to make an uninstall 
04:53:21 <MarcelineVQ> 'just work'
04:53:27 <phaazon> MarcelineVQ: well
04:53:31 <phaazon> pacman does that pretty well
04:53:35 <phaazon> apt-get as well
04:53:37 <phaazon> yum as well
04:53:42 <phaazon> why not cabal / stack?
04:56:01 <MarcelineVQ> A little different use cases I would guess, cabal is for managing projects for making software, pacman is a little broader but it's for things already put together which reduces deep-down breakage issues already. Maybe.
04:57:41 <saulzar_> phaazon, They kind of do .. you can do cabal sandbox hc-pkg unregister foo 
04:57:43 <MarcelineVQ> There might be a good comparison for makepkg and cabal since they can perform a more similair task, but they work quite differently so I'm not sure how to make that comparison
04:58:21 <lesshaste> frerich, it works! How do you set the 60 seconds?
04:58:41 <ibid> nomeata: sorry, i've been on medical leave almost the whole month and haven't been following planet mail at all. i'm sure there's quite a queue of requests by now. will take some time to work through them all
04:58:50 <frerich> lesshaste: I don't set "60 seconds". The 'rotate' function rotates in degrees - so I just multiply the elapsed time by 6 such that it does one circle in 60 seconds.
04:58:50 <saulzar_> phaazon, It's just not great to use, since mostly you have to get rid of the dependencies first..
04:59:31 <lesshaste> frerich, thanks.. I am very pleased there is a haskell solution now :)
04:59:47 <lesshaste> if only could persuade someone to post a C one :)
04:59:59 <ibid> nomeata: for background, see http://antti-juhani.kaijanaho.fi/newblog/archives/1946 and http://antti-juhani.kaijanaho.fi/newblog/archives/1965
05:00:09 <frerich> lesshaste: It's really more of a show-down between different libraries simplifying such animations
05:00:52 <lesshaste> frerich, and BASIC beating them all :)
05:01:20 <lesshaste> frerich,  Java is clearly the worst, BASIC is clearly the best. In between it is as you describe I think
05:03:35 <lesshaste> frerich,  the next one will be http://meta.codegolf.stackexchange.com/questions/2140/sandbox-for-proposed-challenges/7337#7337 :)
05:09:59 <quicksilver> frerich: you can save at least 3 " " and two ".0"
05:12:51 <Geekingfrog> Are there any thread safe sqlite library? SQLite.Simple is apparently not, same for persistent.
05:13:59 <quicksilver> it would surprise me if persistent wasn't thread safe?
05:15:30 <MasseR> Hmm..? Isn't sqlite by itself not threadsafe
05:15:42 <MasseR> At least when it comes to multiple simultaneous writes
05:16:02 <quicksilver> sqlite is, indeed, not threadsafe
05:16:11 <quicksilver> however a library using it can be threadsafe
05:16:17 <quicksilver> it must simply do its own synchronisation
05:16:42 <MasseR> And the last I tried, persistent-sqlite failed with simultaneous writes
05:20:21 <Geekingfrog> So how would you build something using sqlite? One thread holding the connection and waiting for actions to execute on TChan, others part of the app send stuff to this TChan? The connection is kind of global (reader monad?) and each part of the app do its own business?
05:20:32 <quicksilver> yeah something like that.
05:21:00 <MasseR> Geekingfrog: is sqlite a hard dependency=
05:21:07 <Geekingfrog> MasseR, no
05:21:24 <MasseR> Ditch sqlite and use a database that was meant for multiple accesses :)
05:21:24 <Geekingfrog> I just need something simple and preferably self contained for a toy project
05:22:03 <MasseR> You might also take a look at acid-state
05:22:06 <MasseR> Not sql, but is self-contained
05:22:19 <frerich> quicksilver: True!
05:27:41 <Geekingfrog> MasseR, cool, I'll look into acid state.
05:38:59 * hackagebot combinat 0.2.8.0 - Generate and manipulate various combinatorial objects.  https://hackage.haskell.org/package/combinat-0.2.8.0 (BalazsKomuves)
05:45:56 <dibblego> mrkgnao: liftA2
05:55:20 <deni> I'm unable to figure out a good approach for parsing json but requiring fieldA to be defined only if fieldB is not defined. can anyone point me to an example?
05:55:52 <deni> if i define fieldA and fieldB as Maybe in my data type then both of them don't need to be defined and the thing will parse but be invalid
05:57:50 <blueonyx> deni: does Either (Maybe A) A work?
05:58:35 <blueonyx> in case B is defined you use the Right wich must be A, if B is undefined you use The Left which Maybe A
05:58:53 <quicksilver> don't you want Either A B?
05:59:00 <quicksilver> I mean you haven't quite been precise about what you need
05:59:31 <blueonyx> or Either (B,A) A
06:00:03 <blueonyx> err Maybe (Either (B,A) A)
06:00:08 <quicksilver> maybe your question is about the automatically dervived insteance?
06:00:26 <quicksilver> rememer you can write your own to/fromJSON parsers if the automated deriving isn't right
06:00:28 <quicksilver> it's not hard.
06:04:44 <deni> no i know i can write my own instances...i have to for this case
06:04:52 <deni> i'm just trying to figure out how to model this in that instance
06:06:11 <deni> quicksilver: i have a json that's like {'A': 'something', 'optional1': 'asdsad'} or {'B': 'something', 'optional2': 'asdads'} 
06:06:28 <deni> basically i have a lot of optional fields but either A or B need to be defined but not both
06:06:43 <quicksilver> ok good so the first question is definitely how to model in haskell
06:06:44 <deni> it's clearly an Either A B then 
06:06:47 <quicksilver> how about 
06:07:17 <quicksilver> data YourData = A Something (Maybe Asdsad) | B SomethingElse (Maybe Asdads)
06:07:18 <quicksilver> ?
06:09:57 <deni> quicksilver: that should work yes
06:10:38 <quicksilver> I mean yo uneed to be precise about exactly which fields are expected in each case
06:10:49 <quicksilver> and if there are loads of fields / a substantial overlap between the two
06:10:59 <quicksilver> then it makes sense to 'factor out' the shared ones
06:11:21 <quicksilver> (CommonBits, DifferentBits) where data DifferentBits = A .. | B ...
06:31:17 <dreams> If a Haskell implementation is non-strict (i.e. uses normal-order reduction) and not lazy (does not share expressions), would it still be considered a Haskell implementation?
06:31:59 <bernalex> dreams: yes. Haskell defines a non-strict semantics, not a lazy semantics. GHC uses lazy semantics however.
06:32:16 <hodapp> laziness is an implementation of non-strict.
06:32:17 <bernalex> *evaluation however.
06:32:26 <bernalex> yes.
06:32:54 <dreams> hodapp: an optimized implementation.
06:33:21 <bernalex> lazy evaluation = call-by-need evaluation. you could imagine an evaluation that evaluates potentially unneeded expressions, a "just-in-case evaluation", if you will. this would be very neat for e.g. a GPU with nothing better to do with its downtime.
06:33:40 <hodapp> dreams: as opposed to what?
06:34:26 <dreams> bernalex: I know how it works. Just trying to stick to conventions.
06:34:49 <dreams> hodapp: lack of sharing.
06:35:14 <dreams> Its just a bit puzzling now when its said that if you have pattern matching, then its not pure lazy.
06:35:28 <bernalex> call-by-need is a memoized call-by-name.
06:36:06 <quicksilver> bernalex: pretty sure the report hints or suggests lazy in a few places
06:36:22 <dreams> hodapp: so non-strict by itself is rather inefficient.
06:36:50 <hodapp> dreams: that really depends on the implementation.
06:37:07 <bernalex> quicksilver: I think it does *ance*, in the marshalling chapter. this might have been a mistake.
06:37:16 <ski> dreams : "its said" -- by whom ?
06:37:22 <dreams> hodapp: in theory.
06:37:58 <dreams> ski: I read somewhere in the Haskell wiki. It even says GHC is no pure lazy (as far as I remember).
06:38:01 <bernalex> quicksilver: in the introduction it clearly says "non-strict". in fact, if you grep the 2010 report, I'm willing to bet you'll get *a lot* of results for "non-strict", but only one for "lazy". I choose to believe the latter was a mistake on Simon's part, as he was thinking about GHC rather than Haskell.
06:38:15 <quicksilver> bernalex: the justification for the monomorphism restriction references sharing
06:38:17 <obadz> I'm trying to avoid restarting emacs after adding a new package to build-depends
06:38:21 <hodapp> bernalex: I feel like shapr knew of an implementation that did something very close to what you just said (the 'just in case' eval), but I can't recall the name
06:38:31 <obadz> I get the error "It is a member of the hidden package blah...
06:38:37 <hodapp> dreams: no, in practice; otherwise I wouldn't be talking about implementations.
06:38:39 <obadz> How do I tell it to reload the cabal file?
06:38:45 <quicksilver> bernalex: the '98 report uses the word 'lazy' or 'lazily' a fewo times but in each case it is using to mean non-strict, it's not talking about sharing.
06:39:03 <dreams> hodapp: I was saying it is inefficient in theory. 
06:39:15 <hodapp> dreams: which theory would that be?
06:39:15 <dreams> hodapp: compared to a lazy one.
06:39:17 <bernalex> quicksilver: I was talking about 2010. don't remember '98. and the monomorphism restriction is a mistake anyway. :p 
06:39:25 <dreams> hodapp: normal-order reduction.
06:39:29 <ski> dreams : i'm not sure what "pure lazy" is supposed to mean. however, i would think `case' on algebraic data types to be similar to application on functions. in both cases you need to reduce to WHNF
06:39:30 <bernalex> dreams: quicksilver: but anyway, Haskell doesn't actually have a formal semantics, so I guess anything goes.
06:39:36 <hodapp> dreams: non-strict vs. lazy isn't a meaningful comparison.
06:39:51 <ski> (well, at least if you have an essential `case' that's actually using nontrivial patterns)
06:40:43 <dreams> hodapp: how so? they are different.
06:41:04 <hodapp> bernalex: http://ennals.org/rob/archive/intel/pubs/thesis.pdf well, here's a 244-page thesis that he sent me on 'adaptive evaluation' >_> that's not as helpful as I hoped.
06:41:05 <bernalex> dreams: lazy is an implementation of non-strict
06:41:17 <bernalex> dreams: it's like comparing clothes to trousers.
06:41:26 <dreams> ski: I think there is a difference between strict and lazy pattern matching, which relates to pure laziness.
06:41:58 <ski> dreams : if you're thinking about `~<pat>' patterns, then you can't do case distinctions with those
06:42:21 <obadz> All, do you know how to get rid of error message "Could not find module XYZ, it is a member of hidden package ABC" in emacs?
06:42:29 <dreams> bernalex: yes, but its not simply that. Its an optimized implementation: you cannot model a lazy semantics using non-strict semantics by itslef: you'll have to model sharing too.
06:42:39 <dreams> ski: yes its that.
06:43:18 <quicksilver> obadz: you might need to kill your *haskell* buffer 
06:43:37 <quicksilver> personally I don't think we're very consistent in how we use the word 'lazy'
06:43:40 <obadz> quicksilver: haskell-process-restart not enough?
06:43:59 <quicksilver> dunno
06:44:01 * hackagebot tagsoup 0.13.5 - Parsing and extracting information from (possibly malformed) HTML/XML documents  https://hackage.haskell.org/package/tagsoup-0.13.5 (NeilMitchell)
06:44:35 <obadz> quicksilver: I've killed every buffer, error is still there
06:45:10 <obadz> quicksilver: seems like I have to kill all buffers, then rm -rf dist, then re-open
06:45:15 <obadz> surely there is a better way?
06:51:04 <quicksilver> I would hope so :(
06:51:28 * quicksilver has never actually used a .cabal file
06:52:00 <quicksilver> bernalex: haskell doesn't have a *written* formal semantics, but I there is some kind of fairly well agreed unwritten semantics
06:54:32 * hackagebot aws-sdk-text-converter 0.4.1 - The text converter for aws-sdk.  https://hackage.haskell.org/package/aws-sdk-text-converter-0.4.1 (YusukeNomura)
07:09:53 <fizbin> Those of you in Philadelphia or close enough to get there next weekend, a reminder that today is the last day to register for Hac Phi! https://wiki.haskell.org/Hac_%CF%86#Registration
07:10:38 <deni> quicksilver: this seem like it would work but I'm struggling to write the instance FromJSON for the Either part
07:14:32 * hackagebot persistent-ratelimit 0.2.0.0 - A library for rate limiting activities with a persistent backend.  https://hackage.haskell.org/package/persistent-ratelimit-0.2.0.0 (jp_rider)
07:28:12 <myname_> :q
07:30:33 <nomeata> ibid: ok, thanks for the information and get well soon
07:39:34 * hackagebot typed-wire 0.1.0.0 - WIP: Language idependent type-safe communication  https://hackage.haskell.org/package/typed-wire-0.1.0.0 (AlexanderThiemann)
07:44:47 * hackagebot fn 0.1.3.0 - A functional web framework.  https://hackage.haskell.org/package/fn-0.1.3.0 (DanielPatterson)
07:50:23 <clrnd> this Web.Fn looks nice ...
07:56:15 <unit73e> hello
07:57:31 <unit73e> I have a question. Does haskell have a non accelerated 2D graphics library? Or it is OpenGL and that's it?
07:58:04 <unit73e> I'm not very familiar with 2D graphics libraries
07:58:07 <dmj> @package diagrams
07:58:07 <lambdabot> http://hackage.haskell.org/package/diagrams
07:58:30 <hodapp> must Cairo be GPU accelerated?
07:59:16 <quicksilver> deni: maybea <- o .:? "A"; maybeb <- o .:? "B"; case (maybea,maybeb) of (Just a,Nothin) -> A <$> {- do A bits here -}; (Nothing,Just b) -> B <$> {- do B bits here -}
07:59:52 <quicksilver> deni: (and also ... (Just _,Just _) -> error "Not allowed A and B!"; (Nothing,Nothing) -> error "Must have A or B")
08:02:27 <clrnd> sdl?
08:02:53 <quicksilver> many 2D libraries have multiple backends, including opengl but not only opengl
08:03:02 <quicksilver> I think that is true of cairo and sdl
08:03:50 <ackthet> why are there no good haskell tshirts :(
08:04:47 * hackagebot fn-extra 0.1.1.0 - Extras for Fn, a functional web framework.  https://hackage.haskell.org/package/fn-extra-0.1.1.0 (DanielPatterson)
08:05:02 <unit73e> Is opengl crossplatform? What's the point of SDL?
08:05:17 <quicksilver> opengl itself is crossplatform; but SDL covers the parts that opengl doesn't cover
08:05:18 <unit73e> Is SDL like the directx of open-source?
08:05:20 <hnfmr> can I use "stack" to do some custom build step? e.g. hsc2hs preprocessing?
08:05:21 <unit73e> ok
08:05:25 <unit73e> thanks
08:05:26 <quicksilver> opening windows, keyboard events, etc
08:05:48 <unit73e> quicksilver: and SDL is cross platform right?
08:05:53 <tzaeru> SDL is cross-platform, yes.
08:06:14 <unit73e> nice, then that's what I'll learn
08:06:16 <unit73e> thanks
08:06:34 <tzaeru> OpenGL in itself is just a specification, not an implementation. So there are different OpenGL implementations per-platform. SDL has support for accessing the OpenGL implementations on various different platforms.
08:06:55 <tzaeru> thou wouldn't strictly need SDL, but SDL also has all that other jazz.
08:07:32 <unit73e> hopefully SDL works great in haskell
08:07:50 <tzaeru> it really just depends on the bindings. SDL2 itself is pretty OK in my experience.
08:11:32 <dzhus> What are the advantages of this: http://hackage.haskell.org/package/stm-chans-3.0.0.4/docs/Control-Concurrent-STM-TBChan.html over plain old TBQueue?
08:14:48 * hackagebot haskell-exp-parser 0.1 - Simple parser parser from Haskell to TemplateHaskell expressions  https://hackage.haskell.org/package/haskell-exp-parser-0.1 (EmilAxelsson)
08:21:37 <quicksilver> dzhus: TBChan was written before TBQueue was added to the main stm package?
08:23:29 * quicksilver can't find a release announce for stm-2.4
08:26:06 <fryguybob> dzhus: The implementations are rather different as well.  It isn't easy to say which is better.
08:29:22 <isovector> morning. i've got a giant state monad I'm trying to restrict write-access to via a lens
08:29:27 <isovector> but still have the entire state be readable
08:29:48 * hackagebot deepcontrol 0.5.3.0 - Provide more deeper level style of programming than the usual Control.xxx modules express  https://hackage.haskell.org/package/deepcontrol-0.5.3.0 (KONISHI_Yohsuke)
08:29:50 * hackagebot fixplate 0.1.6 - Uniplate-style generic traversals for optionally annotated fixed-point types.  https://hackage.haskell.org/package/fixplate-0.1.6 (BalazsKomuves)
08:34:07 <quicksilver> isovector: I suspect you'll end up with a custom monad and writing your own MonadReader and MonadState instances
08:34:37 <quicksilver> so under the covers it will be "StateT bigstate"
08:34:57 <quicksilver> but you'll only supply instances for MonadReader bigstate and MonadState smallstate
08:35:08 <quicksilver> at elast, that is one approach which springs to mind.
08:35:53 <isovector> quicksilver: that's what I was afraid of. thanks! :D
08:36:20 <isovector> quicksilver: i feel like I can't be the first person to need this; maybe I'm doing something roundabout?
08:37:34 <quicksilver> I have been wondering about related things and done some searching and I haven't found anything packaged
08:37:41 <quicksilver> or even a particularly clear blog post :(
08:37:47 <quicksilver> maybe I didn't find the right search keywords yet.
08:38:17 <isovector> i'll think about it today. see if i can come up with something
08:38:50 <quicksilver> my related question is "supposing you have some functions which are read only and some which are read-write and some which only access part of the state...
08:39:00 <quicksilver> it's natural to give each function the most precise type you can
08:39:14 <quicksilver> but there are a lot of choices abou how you do that and for each choice the plumbing is different.
08:39:22 <quicksilver> What is the best practice for arranging such functions and their types?
08:39:22 <quicksilver> "
08:40:47 <m1dnight_> Im having a bit of a problem. I have an evaluator for the lambda calculus. I can call `eval environment expression` and it fully reduces any expression to its final value. Now I want to emulate threads, so I would need `evaluate environment [threads]`. I dont want to use actual threads, just small step semantics.
08:41:19 <m1dnight_> So Im wondering how I can do this. Do I have to rewrite my evaluator so that I have a function `evaluateSingleStep` and then keep applying that to each thread once, until all threads are reduced to a value?
08:41:49 <m1dnight_> I know that semantically speaking evaluating each thread in sequence to a value is okay, but I have 1 synchronisation value that requires a single thread to stop and wait for another thread.
08:41:54 <m1dnight_> Does this make sense? :p
08:42:21 <isovector> the eternal question
08:42:56 <isovector> gotta run off to work. thanks for the help, quicksilver
08:44:01 <ttt_fff> in a directory with more than one *.cabal files, which ones does "cabal repl" pick ?
08:45:46 <fryguybob> m1dnight_: I would think that you are free to choose your implementation, run until blocked then switch thread seems reasonable.
08:47:01 <flexfit> I'm a little bit confused about what "infixr" actually does.
08:47:19 <fryguybob> m1dnight_: If you can express non-blocking access to your shared mutable data then you will need some pre-emption such as run each thread one step.
08:48:14 <flexfit> Is that essentially adding the precedence of a new operator to the order of operations?
08:48:15 <m1dnight_> idd, thats what I was afraid of, which would mean that I would have to return some sort of continuation to the main evaluation loop
08:48:18 <fryguybob> flexfit: It expresses that an operator or infix use of a function is right associative at a given prescidence level
08:48:38 <fryguybob> flexfit: Yes
08:49:19 <quicksilver> it does two things, in fact
08:49:34 <quicksilver> the 'r' part just affects the bracketing when the operator is used twice adjacent
08:49:40 <quicksilver> a %% b %% c
08:49:42 <fryguybob> m1dnight_: Or just use real threads :D
08:49:58 <quicksilver> he might want his evaluator to be deterministic though fryguybob 
08:50:03 <quicksilver> at least for testing purposes
08:51:05 <fryguybob> quicksilver: Don't we all.
08:51:36 * fryguybob wishes GHC's output was deterministic...
08:52:52 <m1dnight_> fryguybob: yeah that is what I have now, but I want my implementation to map as well as possible on the operational semantics, and I think it is cooler to have smal step semantics in my evaluator instead of real threads :p
08:52:53 <fryguybob> flexfit: It might be helpful to realize that you can parse expressions without knowing precidence and associativity and then apply that knowledge later to get the actual expression tree you want.
08:53:34 <ocramz> aaaaaahahahahahahahahahahahaha I have slain the mutable vector + FFI dragon
08:53:48 <quicksilver> I hate to break this to you ocramz 
08:53:51 <clrnd> just program in C
08:53:53 <quicksilver> but it's more of a hydra than a dragon :P
08:54:15 <flexfit> fryguybob: I see.
08:54:15 <ocramz> yeah I noticed
08:54:16 <m1dnight_> I think it would be feasible to evaluate each thread as much as possible, just up to the point of synchronisation primitives and then yield control back to the scheduler
08:54:35 <ocramz> but one concern at a time quicksilver ;)
08:55:06 <ocramz> clrnd: I'm trying to hide C, I was trying to represent a callback
08:55:28 <fryguybob> m1dnight_: Yeah maybe unblocking real threads by priority of number of steps taken...
08:55:41 <quicksilver> you can just to small-step left to right
08:55:51 <quicksilver> reducing the first reducible expressed
08:56:00 <quicksilver> ("blocked" caounts as not reproducible)
08:56:06 <quicksilver> when you get to the right you go back to the left
08:56:14 <quicksilver> maybe some other things have become reducible now
08:58:21 <m1dnight_> Idd, that might be the best approach, this way I only have to change the functions that can block
08:58:52 <ocramz> now, since the boring engineering is done, how may I signal in the types that the underlying datastructure has changed? (after a FFI roundtrip)
08:58:53 <phaazon> fucking modules cycle!
09:01:25 <fryguybob> ocramz: Are you wanting to perform the GC write barrier after the foreign call?
09:02:13 <ocramz> fryguybob: that's a very interesting question; how may I trigger it?
09:02:37 <ocramz> I was actually thinking something simpler like MVars
09:02:39 <fryguybob> ocramz: Cmm wrapper perhaps?
09:03:19 <ocramz> Cmm is one of the intermediate representations right? I have no experience with that ..
09:06:53 <quicksilver> I think you might be doing this a harder way than necessary
09:07:10 <quicksilver> changing something that is supposed to be immutable via the FFI and then convincing GHC you've been a good boy is possible
09:07:20 <quicksilver> but it's easier to use one of the mutable reps
09:08:46 <ocramz> quicksilver: MVector, for example? 
09:09:31 <quicksilver> MVector is  a class not a representation isn't it?
09:09:33 * quicksilver gets muddled
09:09:52 <quicksilver> oh it's both
09:10:08 <ocramz> uhm yes sorry I thought you were meaning in a metaphorical sense; what's a "representation" exactly?
09:10:36 * hackagebot typed-wire 0.2.0.0 - WIP: Language idependent type-safe communication  https://hackage.haskell.org/package/typed-wire-0.2.0.0 (AlexanderThiemann)
09:10:40 <quicksilver> https://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Storable-Mutable.html
09:10:49 <quicksilver> ^^ that one is represented by a foreignptr
09:10:53 <quicksilver> which is exactly a C ptr
09:10:58 <quicksilver> so you can modify it safely from C
09:12:25 <ocramz> actually, I'd rather map haskell functions on c arrays
09:13:05 <ocramz> but, rather than "lifting to Storable", I'd rather copy on the Hs side, do all the crazy stream fusion with Vector or repa and then dump back to C once I'm done
09:13:45 <ocramz> this is within an iterative algorithm inner loop (numerical optimization)
09:15:17 <dolio> I'm not sure I would say ForeignPtr is exactly a C pointer.
09:15:45 <dolio> Well, actually, I am sure I wouldn't say that. :)
09:15:54 * glguy is sure dolio wouldn't say that
09:21:52 <ocramz> sick as it may sound, are there mutable lists ?
09:22:18 <byorgey> ocramz: there are mutable arrays.
09:23:43 <lyxia> ocramz: you can define mutable structures with (IO|ST)Ref
09:23:47 <quicksilver> haskell has, in fact, an *embarassment* of mutable types in the various libraries.
09:23:55 <quicksilver> the quesiton is, which one is right for you.
09:25:37 * hackagebot parsec-trace 0.0.0.1 - Add a hierarchical trace to Parsec parsers.  https://hackage.haskell.org/package/parsec-trace-0.0.0.1 (sleepomeno)
09:30:29 <mmachenry> I can't figure out the import line for Servant. http://hackage.haskell.org/package/servant It's not included in any of the tutorials. In Hackage, the top-level package is Servant.API but that import is not found. What am I doing wrong?
09:30:56 <Taneb> Have you installed the library?
09:34:17 <schell> mmachenry: also - if you need specific servant help you can hang out in #servant - the authors are there and super helpful
09:34:35 <mmachenry> Taneb, yes.
09:34:48 <mmachenry> schell: Thanks
09:39:11 <cocreature> mmachenry: how have you installed it and how are you building?
09:39:53 <mmachenry> I didn't use a sandbox
09:40:22 <cocreature> so just a normal cabal install?
09:40:28 <cocreature> have you added servant to your cabal file?
09:40:53 <mmachenry> What cabal file?
09:46:08 <glguy> mmachenry: Maybe you could paste the output of ghc-pkg list servant, and ghc-pkg describe servant
09:47:25 <mmachenry> glguy: Here's my install… I'll do that next
09:47:26 <mmachenry> http://lpaste.net/144275
09:47:45 <glguy> mmachenry: You installed an old version of servant
09:47:53 <glguy> mmachenry: and you're probably looking at the documentation for the new one
09:47:59 <glguy> (and the modules have changed since then)
09:48:02 <mmachenry> glguy: Oh
09:48:46 <glguy> GHC 7.6.3 is too old for anything but the oldest servant version
09:49:02 <mmachenry> Makes sense.
09:49:39 <mmachenry> I need to get my production systems team to get off their ass and make an RPM for GHC 7.10 :(
09:50:04 <mmachenry> The only one that exists made by the community for Oracle Linux (our distro) is as old as 7.6.3
09:50:42 * hackagebot verdict 0.0.0.0 - Validation framework  https://hackage.haskell.org/package/verdict-0.0.0.0 (jkarni)
09:50:44 * hackagebot classy-prelude 0.12.5 - A typeclass-based Prelude.  https://hackage.haskell.org/package/classy-prelude-0.12.5 (MichaelSnoyman)
09:50:46 * hackagebot classy-prelude-conduit 0.12.5 - conduit instances for classy-prelude  https://hackage.haskell.org/package/classy-prelude-conduit-0.12.5 (MichaelSnoyman)
09:51:16 <cocreature> mmachenry: stack might be able to install a newer ghc
09:51:45 <mmachenry> cocreature: I should try it.
09:52:34 <jujitsu> Hey, I'm writing a parser using Text.Parsec for a custom language supporting user-defined operators. How can I make my parser support custom priority and associativity ? So far I came with this: I could first parse operator declarations and then parse the remaining code giving the operator table as an argument to each sub-parser. However I would like to see how you'd do it because I'm not entirely sure that's the good way to do it
09:53:45 <quicksilver> a normal approach is to parse operators as if they were n-ary
09:53:56 <quicksilver> making no assumptions about precedence or associativity
09:54:20 <quicksilver> so you parse (a + b * c / d) as an alternating-list of ops and terms
09:54:45 <jujitsu> Ok so I tokenize my expression without parsing it ?
09:55:15 <jujitsu> That's nice thanks
09:55:22 <jujitsu> I'll try that
09:55:42 * hackagebot verdict-json 0.0.0.0 - JSON instances and JSON Schema for verdict  https://hackage.haskell.org/package/verdict-json-0.0.0.0 (jkarni)
09:55:44 * hackagebot classy-prelude-yesod 0.12.5 - Provide a classy prelude including common Yesod functionality.  https://hackage.haskell.org/package/classy-prelude-yesod-0.12.5 (MichaelSnoyman)
10:00:42 * hackagebot typed-wire 0.2.1.0 - WIP: Language idependent type-safe communication  https://hackage.haskell.org/package/typed-wire-0.2.1.0 (AlexanderThiemann)
10:00:47 <obadz> is f1 $ f2 $ f3 ... $ fn $ x always equivalent to f1 . f2 . f3 ... . fn $ x from an operator precedence standpoint ?
10:02:22 <cptnsandwich> hi, i have a problem compiling stack. after a lot of successful compilation cabal refuses to build vector and i dont know how to properly diagnose the error. how can i find out what went wrong?
10:02:37 <obadz> cptnsandwich: what's the error?
10:02:47 <glguy> ?paste
10:02:47 <lambdabot> Haskell pastebin: http://lpaste.net/
10:02:56 <kadoban> cptnsandwich: You know there's pre-built binaries for a bunch of platforms, right?
10:04:24 <cptnsandwich> I get some warnings "Data.Monoid is redundant". then cabal tells me "Error some packages failed to install" and lists a lot of packages that rely on vector (and text-1.2.1.3 which has a similar problem)
10:05:15 <glguy> cptnsandwich: You should paste the command you ran and the output you got if you don't know how to interpret it
10:05:24 <glguy> (to the pastebin)
10:07:47 <cptnsandwich> sure
10:07:56 <utdemir> Hey. I want to have a command line interface like "./app mode param --flag1 --flag2". I found "cmdargs" package for this, does anyone know any alternatives?
10:08:29 <quicksilver> utdemir: https://wiki.haskell.org/Command_line_option_parsers
10:09:11 <ReinH> utdemir: optparse-applicative
10:09:24 <utdemir> Thanks, I'm checking both now
10:10:19 <utdemir> ReinH: It looks like "optparse-applicative" does not support multi mode
10:10:25 <glguy> And there's always System.Console.GetOpt in base
10:10:34 <Clint> what is multi mode
10:11:24 <utdemir> Clint: "cabal install | cabal update" instead of something like "cabal --install", I think.
10:11:40 <Clint> utdemir: it most definitely does that
10:14:15 <utdemir> Clint: I continue looking to it then
10:15:32 <cptnsandwich> my error output http://lpaste.net/144280
10:15:43 * hackagebot json-stream 0.4.0.0 - Incremental applicative JSON parser  https://hackage.haskell.org/package/json-stream-0.4.0.0 (ondrap)
10:16:58 <cptnsandwich> there are a lot of warnings, but some of them are only cabal warnings and for the rest i would expect maybe runtime errors, but no problems during compilation
10:19:19 <broma0> Hello, can someone help out with a quick lens question?
10:19:42 <quicksilver> sure, broma0 
10:21:57 <broma0> Given a deeply nested type like http://lpaste.net/144282, how can i drill down through both the product and sum types to update, say, '_loginUsername', and get back a (Maybe App)? I think i need some way to compose lenses and prisms.. Something like app & appView._AppGuest.guestView._GuestLogin.loginUsername .~ "Username"
10:22:57 <broma0> quicksilver: I'm really just looking for a safe way to modify a value deep down a nesting of both sum and product types. I'd assume this would return a (Maybe a) if i tried to go down the wrong piece of a sum type along the way
10:23:29 <quicksilver> yes
10:23:39 <quicksilver> that's pretty much exactly how it works, the way you wrote it
10:24:25 <quicksilver> .~ simply does nothing if you 'went the wrong way'
10:24:29 <glguy> broma0: If you want to know if the update actually updated anything you can use 'failover' 
10:24:32 <quicksilver> ^? gives you a Nothing if you "went the wrong way"
10:24:52 <glguy> ^? gives Nothing if you went the wrong way on a lookup rather than modification
10:25:04 <quicksilver> > Right (Right 2) & _Right . _Right .~ 3
10:25:06 <lambdabot>  Right (Right 3)
10:25:12 <quicksilver> > Right (Left 2) & _Right . _Right .~ 3
10:25:14 <lambdabot>  Right (Left 2)
10:25:28 <cptnsandwich> kadoban: i am aware of that, but it's on arm. no binary there
10:25:30 <quicksilver> did nothing because _Right . _Right was the wrong way.
10:25:44 * hackagebot typed-wire 0.2.1.1 - WIP: Language idependent type-safe communication  https://hackage.haskell.org/package/typed-wire-0.2.1.1 (AlexanderThiemann)
10:25:47 <cptnsandwich> obadz, glguy: did you have a look? any idea?
10:26:26 <glguy> cptnsandwich: I'm not sure, but I'd start by getting your cabal-install built against a modern version of Cabal to avoid all the cabal warnings
10:26:33 <broma0> how can i get back a Nothing instead of an unmodified 'app' if I go down the wrong path?
10:26:50 <broma0> glguy: failover?
10:27:03 <broma0> googling..
10:27:16 <cptnsandwich> ill try that for sure. i just ran into cabal hell before and hoped stack would help me prevent that this time -.-
10:30:24 <RageYL> what would you recommend for an easy drawing library (window, images and events, possibly animation of some movement)
10:31:27 <quicksilver> broma0: you can check first with "has"
10:32:03 <quicksilver> if has (_Foo._Bar) s then Just (over (_Foo._bar) s f) else Nothing
10:32:22 <broma0> quicksilver: that'll do!
10:32:29 <broma0> quicksilver: thank you for the help
10:32:33 <quicksilver> you're welcome
10:33:25 <sleblanc> In an FFI, is there a way to ensure users will not call the init function more than once?
10:34:15 <ARM9> it's difficult, depends on how strict you want to be
10:35:00 <sleblanc> So I am probably putting too much thought into it
10:35:03 <ARM9> static analysis could tell you if it's called more than once in the code but it can't always tell if it's going to be executed or not
10:35:45 * hackagebot open-haddock 0.1.0.0 - Open haddock HTML documentation  https://hackage.haskell.org/package/open-haddock-0.1.0.0 (jml)
10:40:27 <dolio> if has l x then Just (over l f x) else Nothing = traverseOf l (Just . f) x?
10:42:15 <dolio> Oh, I guess not.
10:46:41 <glguy> broma0: failover is the way to do that without two passes
10:48:07 <glguy> > failover (ix 3) (*10) [0..5] :: Maybe [Int]
10:48:09 <lambdabot>  Just [0,1,2,30,4,5]
10:48:13 <glguy> > failover (ix 10) (*10) [0..5] :: Maybe [Int]
10:48:15 <lambdabot>  Nothing
10:51:23 <quicksilver> nice
10:54:16 <Bor0> @src ix
10:54:16 <lambdabot> Source not found. I feel much better now.
10:57:54 <quicksilver> Bor0: https://hackage.haskell.org/package/lens-4.13/docs/Control-Lens-At.html
10:58:21 <Bor0> thanks
11:05:46 * hackagebot casadi-bindings 2.4.1.1 - mid-level bindings to CasADi  https://hackage.haskell.org/package/casadi-bindings-2.4.1.1 (GregHorn)
11:09:58 <owwo> Why/how is Warp faster than FastCGI?
11:10:29 <clrnd> haskell is webscale
11:11:24 <clrnd> also http://aosabook.org/en/posa/warp.html
11:13:56 <owwo> Is it basically that other aspects of the architecture are enough to outweigh the HTTP overhead?
11:15:49 * hackagebot dbmigrations 0.9.1 - An implementation of relational database "migrations"  https://hackage.haskell.org/package/dbmigrations-0.9.1 (JonathanDaugherty)
11:16:23 <monochrom> I wonder if there can be any meaningful comparison. sounds as apple vs orange
11:18:38 <owwo> monochrom: I think there is a comparison to made. We're currently using nginx to reverse proxy to warp on localhost. We're thinking about performance and my intuition is that FastCGI should be better because this is basically the use case it's designed for. But https://www.safaribooksonline.com/library/view/developing-web-applications/9781449336868/ch11s02.html claims that Warp is significantly faster
11:20:50 <ReinH> owwo: Well, for one, FastCGI has to start and tear down a process for each request.
11:21:06 <ReinH> The web has largely moved towards persistent processes behind reverse proxies.
11:21:28 <owwo> ReinH: I thought that was regular CGI. FastCGI keeps persistent processes?
11:21:47 <ReinH> owwo: Yeah, you're right.
11:22:02 <ReinH> It's been over a decade since I've used either.
11:23:07 <clrnd> fastCGI is really old, I don't see why warp would be slower
11:23:15 <clrnd> also haskell rocks
11:24:21 <ReinH> FastCGI is fast compared to CGI.
11:24:27 <johnw> lol
11:24:33 <owwo> I guess I'm mostly thinking about the protocol level. HTTP is a textual protocol which isn't really designed for performance or reverse proxying on localhost. FastCGI is a binary protocol designed for performance. But I guess the other factors outweigh that?
11:24:48 <ReinH> owwo: reverse proxying on localhost is how everyone does it. It works quite well.
11:25:02 <ReinH> (or not on localhost)
11:25:29 <clrnd> well, someone has to parse that HTTP, be it nginx or haskell
11:25:50 <clrnd> right?
11:25:53 <ReinH> HTTP envelopes are probably pretty small compared to today's average payload size.
11:26:29 <ReinH> So I don't think there's much HTTP protocol overhead.
11:26:40 <clrnd> does nginx parse http in order to rev proxy?
11:26:51 <owwo> clrnd: I believe so
11:27:06 <ReinH> clrnd: Yes, it must.
11:27:16 <ReinH> We've gotten pretty good at parsing HTTP.
11:27:21 <clrnd> why is that?
11:27:33 <clrnd> also, does it need to do it BEFORE passing the request?
11:27:37 <ReinH> clrnd: It needs to match the requeast to its configuration.
11:27:43 <ReinH> *request
11:28:19 <martinvlk>  > 1 :: Sum Int
11:28:31 <ReinH> martinvlk: You can query lambdabot.
11:28:39 <martinvlk> > 1 :: Sum Int
11:28:40 <lambdabot>  Sum {getSum = 1}
11:29:28 <martinvlk> Hi, can somebody explain to me why simply adding monoid type annotation to a number acts like if I used the monoid type constructor? 
11:29:28 <ReinH> clrnd: e.g., it might dispatch to the reverse proxy or serve a static file depending on the uri's path and its configuration.
11:29:37 <ReinH> :t 1
11:29:38 <lambdabot> Num a => a
11:29:46 <ReinH> martinvlk: number literals are polymorphic.
11:29:55 <ReinH> it's as if there is an implied fromIntegral
11:30:16 <ReinH> which Sum implements as an instance of the Num typeclass
11:30:26 * ski . o O ( `fromInteger' )
11:30:31 <ReinH> ski: yes sorry
11:30:56 <clrnd> yeah but the path is only the first line of HTTP
11:30:58 * ReinH . o O ( I should start that #haskell FAQ )
11:31:03 <clrnd> (I'm being super cynical I know)
11:31:08 <ReinH> clrnd: Also accept headers.
11:31:10 <ReinH> etc
11:31:29 <ReinH> and parsing the first line is still parsing
11:31:30 <kadoban> martinvlk: It's the same mechanism that lets you do:  1 :: Double, essentially.
11:31:49 <ReinH> clrnd: It probably has to parse more, given how flexible the configuration language use.
11:32:04 <clrnd> yeah probably that overhead is super small compared to what the app needs to do
11:32:05 <martinvlk> @i Sum
11:32:05 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect irc-password irc-persist-connect v @ ? .
11:32:18 <martinvlk> > :i Sum
11:32:20 <lambdabot>  <hint>:1:1: parse error on input ‘:’
11:32:26 <clrnd> martinvlk, lambdabot has no :info
11:32:39 <martinvlk> h:- ah ok :-)
11:33:00 <clrnd> then back to what I was saying, haskell > C => warp > fastCGI
11:33:02 <ReinH> clrnd: We've gotten *really really good* at parsing HTTP.
11:33:41 <ReinH> clrnd: Transforming an HTTP request into a binary payload for fastCGI isn't free either.
11:33:56 <clrnd> nono, ofc
11:34:01 <martinvlk> ReinH, clrnd, ski: thanks, I get it now
11:34:16 <ReinH> Probably *more* expensive than parsing, given that parsing is probably zero-allocation.
11:45:34 <jle`> 1/b 15
11:48:53 <owwo> okay, thanks all
11:51:53 <statusfailed> Why would you use a Free monad to define a DSL instead of using a GADT and writing "eval" ?
11:52:00 <statusfailed> or vice versa
11:52:25 <monochrom> I'm pretty sure it depends on the DSL
11:52:46 <statusfailed> monochrom: are there things you can do with one and not the other?
11:52:49 <statusfailed> how does it depend on the DSL?
11:54:11 <monochrom> is your DSL monadic? if yes, you can make it a Free monad
11:54:59 <statusfailed> What does it mean for a DSL to be monadic?
11:55:05 <monochrom> is your DSL type-discriminating? e.g., Op1 :: E Int -> E Int but Op2 :: E Bool -> E Char. if yes, then you can make it a GADT
11:55:33 <monochrom> a DSL is monadic iff it forms a monad
11:56:02 <monochrom> so far I haven't seen a DSL that satisfies both monadic and type-discriminating
11:56:16 <monochrom> in fact pretty sure they're mutually exclusive
11:57:38 <statusfailed> Could you elaborate on what "type discriminating" is, too? 
11:58:01 <statusfailed> What is your "E" in Op1 and Op2 ?
11:58:10 <monochrom> your GADT type
11:58:12 <statusfailed> is that the Expression type, of which Op1 and Op2 are tags?
11:58:13 <statusfailed> ok
12:06:38 <doismellburning> anyone know if/how I can enforce minimum test coverage with hpc?
12:06:46 <doismellburning> I'd like to fail my tests if I have <100%
12:07:14 <obadz> how come read is a partial function? seems old school..
12:07:41 <jle`> yeah, not many people are happy with that
12:07:47 <bitemyapp> obadz: it's not great, but after the hissy fit that followed FTP, it seems unlikely Prelude is going to get fixed.
12:07:52 <dolio> Because read is a function for toy, one-line examples.
12:08:02 <obadz> is there a readMaybe that's popular out there?
12:08:06 <bitemyapp> 'ish?
12:08:22 <ggVGc> I'd like to write an open source project in haskell, but feel people won't try it out if it's too hard to get started(and haskell currently requires quite a lot of baggage to get up and running). What's the best deployment stragegy? Granted I can build binaries for the common platforms, but I'd like to be able to support a source build also. Is it possible/viable to generate ansi C that would build on most machines?
12:08:31 <obadz> dolio: I got a date in a String, is there a quicker way to turn it into a 
12:08:33 <obadz> Day?
12:08:45 <bsmt> something something stackage
12:09:01 <dolio> Not quicker. But you should probably use a real parser.
12:09:31 <liste> ggVGc just tell people to use stack (:
12:09:37 <dolio> Which Read is not.
12:09:39 <obadz> I hope not
12:09:58 <statusfailed> Can you make (->) an instance of a class in the first argument?
12:10:01 <dolio> I can't even think of a Read instance that should be able to parse dates, because dates are not valid Haskell syntax.
12:10:12 <liste> ggVGc or do you mean things like source-based distros?
12:10:17 <obadz> ggVGc: use stack to produce windows exes. use linux distros builtin mechanisms to package your project...
12:10:28 <ggVGc> liste: they'll still need the several hunderd meg compiler, which most won't accept
12:10:37 <ggVGc> yeah, I mean a source distribution that's not the haskell source
12:10:43 <ggVGc> I'm looking at jhc now
12:10:49 <ggVGc> not sure it's maintained still
12:11:13 <doismellburning> actually, hm, does anyone recommend a coverage tool that isn't hpc? https://wiki.haskell.org/Haskell_program_coverage links to http://projects.unsafeperformio.com/hpc which now doesn't resolve
12:11:27 <ggVGc> obadz: I'd like to not have all of ghc and dependencies as part of the deps.
12:11:36 <ggVGc> it'll be too much for many people to want to try it out
12:11:44 <ggVGc> I guess binary distribution is the most sane choice
12:11:47 <bsmt> yeah
12:11:59 <ggVGc> but if possible I'd like a source distribution too
12:12:06 <bsmt> if they're too lazy to build it from source then they need to use binaries
12:12:21 <obadz> is there a scanf equivalent I can use?
12:12:40 <obadz> ggVGc: I don't think apt-get install some-haskell-proj installs ghc
12:12:49 <obadz> ggVGc: but I could be wrong.
12:12:56 <bsmt> not if it's a binary
12:12:58 <joeyjojo> hey, how do you map a function to a list if the function takes in two variables? For example if I wanted to map a function that multiplied everything by x to a list?
12:13:03 <ggVGc> obadz: if it's a source distribution it will
12:13:06 <ggVGc> but maybe that's okay..
12:13:10 <obadz> On nixos you end up depending on ghc
12:13:21 <obadz> ggVGc: well if you have a source distro, it's going to need a compiler..
12:13:52 <obadz> ggVGc: there's no way around that unless you want to ship binaries to a source distro but then it's no longer a source distro?
12:14:10 <liste> generated C code isn't really source
12:14:21 <liste> if you can't modify it
12:14:32 <bsmt> plus the C backend is pretty much deprecated by now, yeah?
12:15:03 <johnw> joeyjojo: map (* x) [1..]
12:15:23 <johnw> is that what you mean?
12:15:25 <dolio> The only remaining C backend (I believe) is for portability purposes only.
12:15:34 <obadz> so what's the best way to parse "2015/3/2" without resorting to Parsec or split/read :: Int ?
12:15:52 <bsmt> regex?
12:16:17 <liste> @hackage regex-applicative --- don't know about others, but I like this
12:16:18 <lambdabot> http://hackage.haskell.org/package/regex-applicative --- don't know about others, but I like this
12:16:41 <joeyjojo> johnw: thanks
12:16:47 <johnw> in some ways, a regex is just specialized syntax for a subset of what Parsec can express
12:18:12 <dolio> Well, yeah. :)
12:18:55 <bsmt> regular grammars of all grammars, sure
12:18:59 <bsmt> are a subset*
12:19:01 <bsmt> typing is hard
12:21:07 <dolio> I'm still waiting (with Cale, I think) for a regex library that supports language complement.
12:22:23 <Phyx-> @info peekCWString
12:22:23 <lambdabot> peekCWString
12:22:27 <Phyx-> uhh
12:22:41 <Phyx-> @hoogle peekCWString
12:22:43 <lambdabot> Foreign.C.String peekCWString :: CWString -> IO String
12:22:43 <lambdabot> Foreign.C.String peekCWStringLen :: CWStringLen -> IO String
12:23:09 <ggVGc> Swizec: should be fixed now
12:23:16 <bsmt> can you explain like I'm a golden retriever what language complement is?
12:23:21 <ggVGc> Swizec: thanks for the repot
12:23:28 <ggVGc> eh, sorry, wrong channel
12:23:36 <Swizec> I'm so confused :D
12:23:47 <ggVGc> Swizec: hah, sorry
12:24:19 <Swizec> ggVGc no worries, is someone else calling themselves swizec somewehre on the internet?
12:24:23 <Swizec> cause that's not allowed :P
12:25:52 <dolio> If R is a regular language for an alphabet A, and U is the language of all strings over A, then U - R is also regular.
12:26:13 <ggVGc> Swizec: no I just tab completed wrong in the wrong channel
12:29:08 <obadz> λ> readf (Int % "-" % Int % "-" % Int) "2013-3-2"
12:29:09 <obadz> Just (2013 :%: ("-" :%: (3 :%: ("-" :%: 2))))
12:29:11 <obadz> kewl
12:30:42 <Cale> dolio: Yeah, it seems silly to even restrict yourself to regular languages and use regular expression syntax if you're not also going to implement all the nice operations on languages that gives you.
12:31:01 <Cale> dolio: Don't forget you can also do intersection.
12:31:05 <breadmonster> Cale: Do you have any idea how to set the ghci prompt to a lambda?
12:31:40 <bsmt> :set prompt "λ"
12:31:59 <breadmonster> cool.
12:32:05 <dolio> Cale: I've actually seen intersection before, though. Perhaps not in a Haskell library.
12:32:05 <bsmt> put in .ghci
12:32:24 <dolio> Vim has something that is effectively intersection in its regexes.
12:32:54 <Cale> That's interesting
12:33:09 <dolio>  Of course, it's dangerous to use, because they're not really regular expressions.
12:33:24 <dolio> So you might end up with something really slow.
12:33:28 <johnw> irregular expressions?
12:43:41 <obadz> Is this horrendous?
12:43:52 <obadz> parseDate s = case readf (Int % "-" % Int % "-" % Int) s of Just (y :%: _ :%: m :%: _ :%: d) -> Right $ Time.fromGregorian (fromIntegral y) m d
12:44:55 <frerich> I think one of the main reasons why I'd never dare to try interviewing for a Haskell job is that I'm afraid the interviewer would ask something related to handling times and dates in Haskell. :-}
12:45:14 <Phyx-> @hoogle CString
12:45:14 <lambdabot> Foreign.C.String type CString = Ptr CChar
12:45:15 <lambdabot> Foreign.C.String type CStringLen = (Ptr CChar, Int)
12:45:15 <lambdabot> Foreign.C.String newCString :: String -> IO CString
12:45:19 <Phyx-> wtf
12:45:31 <breadmonster> Phyx-: ?
12:45:39 <Phyx-> ghc tells me my import of Foreign.C.String is redundant, but without it tells me that CString is not found
12:46:21 <Shockk> what are you importing from Foreign.C.String?
12:47:11 <ReinH> bitemyapp: do you have/know of a guide for setting up a reflex-dom project?
12:47:26 <bitemyapp> ReinH: other than "use stack" and "check examples", no.
12:47:50 <bitemyapp> ReinH: I could try making an example later
12:48:01 <ReinH> bitemyapp: womp womp. But at least that means I was doing the right thing wrong rather than the wrong thing.
12:48:13 <bitemyapp> ReinH: what went awry?
12:48:24 <ReinH> bitemyapp: I don't recall off hand sorry.
12:48:30 <bitemyapp> np
12:49:19 <dmj> ReinH: https://github.com/ryantrinkle/reflex-todomvc , not really a guide, but a start maybe
12:49:48 <obadz> frerich: knowledge of date libraries in any language shouldn't be interviewing topic unless you make grandiose claims about having written one or having knowledge of one..
12:50:15 <obadz> frerich: but maybe you were just trying to say that the state of affairs of haskell date libraries was poor ;-)
12:50:41 <ReinH> dmj: thanks
12:52:04 <Phyx-> Shockk: Foreign.C.String ( peekCWString, CString() )
12:52:30 <Phyx-> and I need CWString too i just noticed
12:53:17 <ReinH> frerich: The answer to such questions is "I would use google and hackage, just like you would." ;)
12:53:40 <Shockk> if you're being warned about it being redundant, I'd guess it's peekCWString that you're not using
12:56:19 <clrnd> Lens.Simple is fantastic
12:57:53 <shachaf> People are still writing things like (b -> f b') -> a -> f a' in 2015?
12:58:05 <shachaf> How can you not be confused seeing a type like that?
12:58:15 <breadmonster> shachaf: Why is that problematic...?
12:58:25 <breadmonster> it's `flip map`
12:58:46 <breadmonster> eeks wait no it's not.
12:59:18 <bennofs> shachaf: what would you prefer? (a -> b) -> s -> f t ?
12:59:25 <clrnd> why is the custom to use {-# LANGUAGE ... #-} instead of saying so in the .cabal file?
12:59:37 <shachaf> I would prefer (a -> f b) -> s -> f t, yes.
12:59:42 <shachaf> But I'm pnot particular about s and t.
12:59:53 <clrnd> sometimes it bothers me that different files in my project have different extensions, like OverloadedStrings or LambdaCase
13:00:14 <obadz> what's a good package to do https gets ?
13:00:16 <breadmonster> bennofs shachaf: What function is this...?
13:00:21 <clrnd> obadz, wreq
13:00:29 <clrnd> http-simple is simpler
13:01:11 <hodapp> Is the construct like '[a,b,c] in a type signature DataKinds, TypeOperators, both, or something different still?
13:01:39 <obadz> clrnd: HTTP-Simple says deprecated in favor of HTTP
13:01:47 <obadz> clrnd: and HTTP doesn't handle https
13:02:32 <bennofs> hodapp: DataKinds i'd say
13:02:49 <clrnd> obadz, sorry! O meant http-client
13:02:53 <clrnd> s/O/I/
13:03:03 <clrnd> @hackage http-client
13:03:03 <lambdabot> http://hackage.haskell.org/package/http-client
13:03:13 <ggVGc> can someone point me to a fairly mature open source haskell project with a userbase of non-hasell users?
13:03:15 <clrnd> no idea about https, I assumed that was implemented
13:03:19 <ReinH> ggVGc: pandoc
13:03:23 <ggVGc> thanks
13:03:43 * clrnd recalls telling his sceptic co-worker pandoc was haskell "nah don't fuck with me"
13:04:02 <ReinH> clrnd: heh
13:04:21 <clrnd> so ReinH what do you think of my question ^ ?
13:04:42 <ReinH> clrnd: about language pragmas?
13:04:49 <JonReed> ggVGc: pandoc, git-annex
13:04:57 <clrnd> yeah
13:05:01 <ReinH> Possibly so that the file is self-contained and you can see what is used.
13:05:29 <ReinH> I also think it's reasonable to include extensions on a case-by-case basis.
13:05:44 <breadmonster> ggVGc: also xmonad.
13:05:48 <clrnd> yeah that's good, but it means different files have different semantics
13:05:48 <ReinH> I prefer my files to have the minimum necessary extensions for possibly irrational reasons related to hygene.
13:06:17 <clrnd> a literal string would mean something very different just a file away!
13:06:26 <clrnd> me too
13:06:32 <clrnd> don't get me wrong, I currently do it like that
13:06:51 <clrnd> but just like I carry the same style cross file
13:06:57 <clrnd> indentantion, spacing, etc
13:07:03 <clrnd> extensions would make sense, probably
13:07:04 <ReinH> Yes, but you know what it means by reading the pragmas.
13:07:04 <Phyx-> Shockk: it's saying the import is redundant, but i am using peekCWString
13:07:08 <Phyx-> so that's why I don't get the warning
13:07:10 <ReinH> Versus having to go to the cabal file.
13:07:16 <JonReed> ggVGc: If web frameworks satisfy you then you can search for them as well. E.g. , yesod
13:07:35 <clrnd> ReinH, you could go to the cabla once, like you usually do anyway to see ghc-options and dependencies
13:07:42 <Shockk> Phyx-: are you using any of CString's constructors?
13:08:00 <ReinH> On the other hand, if you want to standardize your project on a particular set of extensions (make your own "Haskell Prime"), I can see a rationale for that as well.
13:08:00 <ggVGc> JonReed: I'm just seeing how people deploy haskell to the public usually
13:08:11 <ggVGc> is it correct that haskell-platform is not used much anymore?
13:08:15 <clrnd> anyone here does it like that? ^
13:08:19 <Phyx-> Shockk: just the type and peekCString as well
13:08:23 <ReinH> ggVGc: Some people use it. It has been updated recently.
13:08:32 <Shockk> Phyx-: try replacing CString() with just CString
13:08:34 <clrnd> (I've honestly never seen -XExt in cabal files)
13:08:58 <doismellburning> So I have `hpc` in my test dependencies (https://github.com/doismellburning/hoofreader/pull/2/files#diff-be92886a0c526ba03b5f5234e068ca8fR83) but I still get "cabal: unrecognized option `--enable-coverage'" in https://travis-ci.org/doismellburning/hoofreader/builds/88419904 - what am I missing?
13:09:00 <dolio> -X is not how you enable things in cabal files.
13:09:12 <dolio> You could, but it's not the expected way.
13:09:55 <ReinH> ggVGc: Personally, I use stack now and I've been very happy with it.
13:10:24 <hodapp> though, if I do '[Foo, Bar, Baz] with DataKinds I'd assume that I cannot actually create a value of that type...
13:10:39 <platz> i wonder if the dependent haskell stuff Weirich is looking to add is going to make efforts like Servant have to reconsider their design
13:10:55 <platz> probably a long way off, but still
13:11:11 <Phyx-> Shockk: ah found it, there was an import to Foreign.C that I didn't see before
13:11:37 <Shockk> ahh
13:12:09 <hodapp> platz: what stuff is this?
13:12:35 <alpounet> platz: i'm afraid most things would have to stay pretty much as they are. only full blown dependent types would let us bring descriptions to the value level, if that's what you were talking about?
13:12:58 <alpounet> (i'm one of the servant devs)
13:13:38 <platz> ahh, cool.  well i'm not sure what the roadmap for adding dependent types for haskell looks like, but i thought they were trying to figure out how to add full DP
13:14:28 <platz> maybe i misunderstood the vision there
13:15:24 <hodapp> platz: http://typetheorypodcast.com/2015/04/episode-4-stephanie-weirich-on-zombie-and-dependent-haskell/ ?
13:15:58 <clrnd> typetheorypodcast omg
13:16:00 <platz> hodapp: yep, that and just random stuff i've read, of course no one is saying full DP is going in anytime soon
13:18:16 <hodapp> platz: yeah, I had read Eisenberg's view in the singletons paper
13:19:02 <platz> yeah singletons seem to be a nice first step
13:19:38 <platz> there's the merging of kinds and types stuff too - though that still doesn't get us all the way there
13:20:53 <platz> i don't even know how much it could really be added while preserving the existing syntax & semantics.. maybe it's too much to bite off
13:22:26 <hodapp> platz: people seemed to have varying opinions on the extent to which existing functionality covers it
13:24:16 <platz> ah, that's a good point
13:24:44 <ttt_fff> would a language like Haskell or Erlang be better suited for writing an IRC server ?
13:25:59 * hackagebot reflex 0.3.1 - Higher-order Functional Reactive Programming  https://hackage.haskell.org/package/reflex-0.3.1 (RyanTrinkle)
13:40:59 * hackagebot crypto-enigma 0.0.2.5 - An Enigma machine simulator with display.  https://hackage.haskell.org/package/crypto-enigma-0.0.2.5 (Orome)
13:45:59 * hackagebot reflex 0.3.2 - Higher-order Functional Reactive Programming  https://hackage.haskell.org/package/reflex-0.3.2 (RyanTrinkle)
13:51:00 * hackagebot hledger-lib 0.27 - Core data types, parsers and functionality for the hledger accounting tools  https://hackage.haskell.org/package/hledger-lib-0.27 (SimonMichael)
13:51:02 * hackagebot hledger 0.27 - Command-line interface for the hledger accounting tool  https://hackage.haskell.org/package/hledger-0.27 (SimonMichael)
13:51:04 * hackagebot hledger-ui 0.27 - Curses-style user interface for the hledger accounting tool  https://hackage.haskell.org/package/hledger-ui-0.27 (SimonMichael)
13:51:06 * hackagebot hledger-web 0.27 - Web interface for the hledger accounting tool  https://hackage.haskell.org/package/hledger-web-0.27 (SimonMichael)
13:51:08 * hackagebot deepcontrol 0.5.4.0 - Provide deep level programming style for Applicative and Monad  https://hackage.haskell.org/package/deepcontrol-0.5.4.0 (KONISHI_Yohsuke)
14:45:45 <emmanuel_erc> hello everyone!
14:47:45 <imalsogreg_> emmanuel_erc, Hello!
14:48:47 <emmanuel_erc> hey there imalsogreg!
14:48:55 <emmanuel_erc> How long have you been using haskell?
14:49:13 <imalsogreg_> 4 years I think
14:49:49 <imalsogreg_> Still not tired of it :)
14:50:01 <emmanuel_erc> wow, that's a long time... Have you gotten flak for using from your colleagues?
14:51:01 <imalsogreg_> Sure. It's a lot of fun to make fun of a Haskeller. I get it from coworkers, wife, etc. More flak for Haskell than for being vegetarian. No big deal.
14:51:03 <lispy> Do people catch flak for using Haskell?
14:51:07 <deech> Are there guidelines in place for when a package needs to be fixed but the maintainer doesn't respond?
14:51:27 <lispy> deech: yeah, but I don't know where it's documentd
14:51:50 <emmanuel_erc> I think some of the people in my department (I am a graduate student) think I am crazy for using it.
14:51:53 <lispy> deech: How long have you waited since contacting them?
14:52:05 <deech> lispy: Approx 1 wk.
14:52:20 <bsmt> hah. How do you know someone writes haskell? Don't worry, they'll tell you.
14:52:24 <lispy> deech: IIRC, you're ready to move to the next stage
14:52:34 <deech> lispy: My body is ready.
14:52:43 <imalsogreg_> emmanuel_erc, in some non-CS department? I'm from neuroscience myself.
14:52:52 <lispy> deech: there is this document: https://wiki.haskell.org/Taking_over_a_package
14:53:12 <deech> Ah, great. Thanks!
14:53:15 <emmanuel_erc> Yea I am in electrical engineering (my work is in image processing/computer vision, though).
14:53:25 <lispy> deech: BTW, which library is this?
14:53:33 <emmanuel_erc> If I had told people I was python, no one would have batted an eyelid.
14:55:29 <imalsogreg_> emmanuel_erc, Oh cool. Yeah. In my department I would still get flax for Python. matlab is the standard. Python is edgy :P
14:55:52 <imalsogreg_> How long have you been at it? Get to do your vision stuff w/ haskell?
14:56:22 <emmanuel_erc> I've been using for about 8 months now.
14:56:47 <imalsogreg_> Got a mentor or learning by internet?
14:56:54 <emmanuel_erc> I was convinced to use because of the abstractions baked into the language.
14:56:58 <deech> lispy: Greencard. https://hackage.haskell.org/package/greencard. Doesn't compile with 7.10.2. There's been a PR hanging out there since April: https://github.com/sof/greencard/pull/3.
14:57:07 <emmanuel_erc> I've been learning on my own and through IRC and random sources.
14:57:27 <emmanuel_erc> It isn't the most disciplined approach.
14:57:40 <lispy> deech: ah, sigbjorn can be heard to reach a times
14:57:45 <lispy> hard*
14:57:58 <deech> lispy: Ok, then I'll give it more time.
14:58:01 <emmanuel_erc> But I do have a package on github to show for it (still needs major work on it.).
14:58:35 <deech> lispy: Libclang which is what I really need has a dependency on it. 
14:58:47 <lispy> deech: Well, if your goal is just to upload a small change to keep it working then I think you should go down that path
14:58:57 <imalsogreg_> Heh, no. I think it's fine though - I did it that way. LYAH, RWH, erik meijer videos. I'm in Boston though so we have a great meetup, which after a couple years I was brave enough to attend
14:59:02 <lispy> deech: there are some hackage janitors or something like that who should be able to help you
14:59:12 <imalsogreg_> emmanuel_erc, What's it called?
14:59:15 * ski . o O ( SIGBOVIK )
14:59:24 <deech> lispy: I don't want to step on the toes of the person who made the PR.
14:59:24 <emmanuel_erc> I just the post the link.
14:59:50 <lispy> deech: I mention that sigbjorn can be heard to reach more in the sense that you may never get a reply :(
15:00:00 <deech> lispy: Hmmm .
15:00:31 <emmanuel_erc> imalsogreg_: https://github.com/emmanueldenloye/manifoldRNC
15:01:05 <deech> lispy: Ok. I don't think I want to take over maintainership of Greencard but I'll give it another week. Thanks for the advice!
15:02:05 <deech> lispy: Although long-term it seems like Greencard is on it's way out. Probably good to convert Libclang to c2hs but that's more than I have time for now.
15:02:37 <lispy> Could be, but isn't greencard automated?
15:02:56 <deech> What do you mean?
15:03:16 <deech> TMK, it's a file format, just like *.chs files.
15:03:57 <imalsogreg_> Ooh nice. Cool to see a pca example.
15:05:20 <imalsogreg_> emmanuel_erc, I don't know about your field specifically, but there's the ReScience github journal that's trying to encourage this kind of  thing where you reimplement the algorithm/model in a paper and try to reproduce their results.
15:05:35 <mightybyte> We now have Haskell's counterpart to the Wat talk. :)  https://news.ycombinator.com/item?id=10480762
15:05:37 <lispy> "Green Card will then generate gobs of low-level boilerplate code that takes care of all the details."
15:05:51 <lispy> deech: I've never used it, but that made me think it does boring things for you
15:07:35 <deech> lispy: I think it's a pre-processor like c2hs. It pre-processes *.gc files and generates all the boring C FFI junk.
15:08:47 <imalsogreg_> wat-sensitivity.  Thanks for the post.
15:15:50 <phaazon> is there a way to break compilation with a message in the middle of some code?
15:15:58 <phaazon> like, {-# ERROR "fuck it" #-}
15:16:26 <hpc> with template haskell?
15:16:40 <phaazon> with the simplest thing
15:17:01 <hpc> just do ()()
15:17:11 <phaazon> I’m using CPP to select a backend in my code
15:17:23 <phaazon> #if … #elsif … #else fail here #endif
15:17:57 <hpc> i think fail in the Q monad will say why something failed
15:18:07 <mgsloan> An error pragma like that would be kinda cool.  Like the upcoming type level errors stuff, but for CPP 
15:18:40 <mgsloan> Yeah, $(fail "yadda yadda") is probably the most straightforward, but requires TH
15:18:58 <phaazon> I guess my issue is more linked to how I should do conditional compilation
15:19:32 <hpc> i think this is an okay use of TH
15:19:40 <phaazon> yeah but I mean
15:19:53 <phaazon> I can have all my functions in a single place
15:20:02 <hpc> i bet TH can reimplement CPP conditions
15:20:04 <phaazon> and interleave #if / #endif CPP directives
15:20:06 <hpc> it's just env, right?
15:20:11 <phaazon> or I can have several modules
15:20:15 <phaazon> and use cabal flags
15:27:21 <emmanuel_erc> imalsogreg_: Thanks for the heads up about that github journal.
15:27:33 <emmanuel_erc> I had to step out front a moment.
15:27:37 <emmanuel_erc> for a*
15:34:05 <imalsogreg_> emmanuel_erc, no prob.
15:47:29 <^elyse^> Is there a limit on the number of data constructors an algebraic type can have in GHC?
15:53:08 <Welkin> hm
15:53:12 <Welkin> that is a good quesiton
15:53:41 <Welkin> tuples are limited to 67 (?) for some reason related to ghc
15:53:54 <Welkin> not sure about data constructors
15:57:22 <pyon> Is there any automatic way to make prettier Show instances for records that follow the convention that allow for using makeLenses?
15:57:35 <pyon> makeLenses and makeFields
16:01:32 <pyon> Never mind, found about declareFields :-)
16:05:53 <o`connor> What triggers a "MUT_ARR_PTRS_FROZEN object entered"?
16:18:14 <lispy> o`connor: a gc bug?
16:18:36 <lispy> https://github.com/ghc/ghc/blob/master/rts/StgMiscClosures.cmm
16:23:55 <o`connor> lispy: thanks
16:24:49 <o`connor> I think I'll make a bug report and maybe compile without -threaded temporarily
16:41:09 * hackagebot hsignal 0.2.7.4 - Signal processing and EEG data analysis  https://hackage.haskell.org/package/hsignal-0.2.7.4 (VivianMcPhail)
16:49:55 <sbrg> Anyone here have experience with using hslogger, or can someone recommend any other nice logging frameworks in haskell?
16:53:23 <Welkin> fastlogger
17:06:40 * hackagebot aws-route53 0.1.2.1 - Amazon Route53 DNS service plugin for the aws package.  https://hackage.haskell.org/package/aws-route53-0.1.2.1 (DavidTerei)
17:11:40 * hackagebot hledger-irr 0.1.1.8 - computes the internal rate of return of an investment  https://hackage.haskell.org/package/hledger-irr-0.1.1.8 (JoachimBreitner)
17:26:09 <harwiltz> can someone help me get a list of directories in haskell? I'm having a bit of an issue
17:26:39 <harwiltz> by list of directories I mean a function that returns a list of all the files in the current directory
17:26:51 <dibblego> @type getDirectoryContents
17:26:52 <lambdabot> Not in scope: ‘getDirectoryContents’
17:27:10 <harwiltz> but that returns a list of IO Filetype
17:27:12 <dibblego> @type System.Directory.getDirectoryContents
17:27:13 <lambdabot> FilePath -> IO [FilePath]
17:27:22 <dibblego> no, it returns IO [FilePath]
17:27:38 <harwiltz> Basically what I want to do is make a function that gathers the files in a directory and adds a '/' to the end of the ones that are folders
17:28:12 <harwiltz> But I keep getting type mismatches because of IO
17:28:38 <Romefeller> Hello all
17:29:00 <Romefeller> harwiltz: fmap
17:29:27 <harwiltz> Romefeller: Ok, I've never heard of that. I'll look it up. I'm quite the noob lol
17:30:22 <Romefeller> harwiltz: String and IO String are different. If you have a function f::String -> String, you'll need fmap f to get IO String -> IO String.
17:31:32 <dibblego> isDirectory will require (=<<)
17:31:51 <harwiltz> dibblego: What exactly does that operator do?
17:32:47 <harwiltz> dibblego: Also I've never heard of that function (isDirectory), I am using doesDirectoryExist
17:49:53 <slacko1256> for test the cabal docs recommend detailed-0.9 interface, yet I haven't seen it in use on any popular package
17:50:07 <slacko1256> is it still recommended?
18:11:43 * hackagebot WaveFront 0.1.0.1 - Parsers and utilities for the OBJ WaveFront 3D model format  https://hackage.haskell.org/package/WaveFront-0.1.0.1 (SwiftsNamesake)
18:11:45 * hackagebot WaveFront 0.1.0.2 - Parsers and utilities for the OBJ WaveFront 3D model format  https://hackage.haskell.org/package/WaveFront-0.1.0.2 (SwiftsNamesake)
18:40:32 <pimlu> does c `elem` ['a'..'z'] get optimized to 'a' <= c && c <= 'z' by ghc?
18:42:14 * hackagebot concurrent-output 1.1.0 - Ungarble output from several threads  https://hackage.haskell.org/package/concurrent-output-1.1.0 (JoeyHess)
18:48:07 <harwiltz> I'm having trouble dealing with the IO Monad while trying to make a function that lists files in the current directory and marks which ones are folders. Can anyone help?
18:53:32 <Lantern_O_jack> harwiltz: If you do something like
18:53:32 <Lantern_O_jack>     do files <- getDirectoryContents "/tmp"
18:53:32 <Lantern_O_jack>        filterM doesDirectoryExist files
18:53:32 <Lantern_O_jack> you get the directories of /tmp
18:53:41 <Lantern_O_jack> getDirectoryContents and doesDirectoryExist are from System.Directory
18:54:25 <harwiltz> Hmm, I imported System.Directory just couldn't figure out how to get the booleans out of the IO Boolean format. I'll try it
18:54:33 <harwiltz> Lantern_O_jack, thanks
18:56:30 <harwiltz> Lantern_o_jack, but if I wanted to return a list of FilePaths where there was a '/' added after the directories, how can I do that?
18:58:39 <pavonia> harwiltz: Do you know how the do-blocks work?
18:59:32 <harwiltz> pavonia, I believe so. I just don't know how to return the list because whenever I try mapping a function to a list I get type mismatches because of the IO Monad
19:00:09 <pavonia> Maybe you want mapM
19:00:11 <pavonia> :t mapM
19:00:12 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
19:00:36 <harwiltz> I was just about to try that! Thanks, hopefully all goes well haha
19:00:47 <Lantern_O_jack> No, they want "fmap . map" I would think
19:01:07 <harwiltz> why fmap . map and not map?
19:01:34 <Lantern_O_jack> harwiltz: because you're mapping over two things
19:01:45 <Lantern_O_jack> The 'fmap' maps over the IO, the 'map' maps over the list
19:01:56 <harwiltz> Oh, I see. I'll try that out.
19:02:22 <Lantern_O_jack> harwiltz: If you have "intsIO :: IO [Int]" and you want to map show over the list
19:02:22 <Lantern_O_jack>     do ints <- intsIO
19:02:22 <Lantern_O_jack>        let ints' = map show ints
19:02:22 <Lantern_O_jack>        return ints'
19:02:47 <harwiltz> But you didn't use fmap there?
19:02:57 <Lantern_O_jack> That's right, using fmap/map:
19:02:57 <Lantern_O_jack> :t fmap (map show) (undefined :: IO [Int])
19:02:58 <lambdabot> IO [String]
19:03:12 <Lantern_O_jack> harwiltz: I wanted to show a more explicit version first
19:03:32 <harwiltz> ok, so why can't I just use map?
19:03:54 <Lantern_O_jack> You can use 'map show' on something of type [Int]
19:04:00 <Lantern_O_jack> You cannot use 'map show' on something of type IO [Int]
19:04:10 <harwiltz> right sorry, makes ssense
19:04:34 <Lantern_O_jack> It's an extra onion layer you have to 'peel' off
19:05:06 <Lantern_O_jack> See the type of 'map' versus the type of 'fmap.map'
19:05:10 <Lantern_O_jack> :t map
19:05:12 <lambdabot> (a -> b) -> [a] -> [b]
19:05:13 <Lantern_O_jack> :t fmap.map :: (a -> b) -> IO [a] -> IO [b]
19:05:14 <lambdabot> (a -> b) -> IO [a] -> IO [b]
19:06:36 <harwiltz> I see. So I'm trying to do fmap . map, and should I pass that a lambda function that tests if the directory exists and adds a slash at the end if it does?
19:07:31 <harwiltz> Like this:
19:07:42 <harwiltz>  contents <- getDirectoryContents path
19:07:44 <harwiltz>  29     let list = (fmap . map) (\s -> if doesDirectoryExist s then (s ++ "/") else s) contents yY
19:07:55 <harwiltz> Sorry bad formatting
19:08:09 <Lantern_O_jack> If you want to add a slash at the end, use 'fmap' and 'map', but you will need 'mapM' or similar functions if you want 'doesDirectoryExist'
19:09:00 <Lantern_O_jack> harwiltz: An important distinction that may seem frustrating, looking at the types of map and fmap we see
19:09:01 <Lantern_O_jack>     (a -> b) -> ...
19:09:01 <Lantern_O_jack> meaning that the function cannot have side-effects
19:09:04 <harwiltz> Ok, but shouldn't I be doing that all in one step? 
19:09:30 <Lantern_O_jack> You can, but I would separate the two
19:09:55 <Lantern_O_jack> Checking 'doesDirectoryExist': side-effects. ==> mapM
19:09:55 <Lantern_O_jack> Adding 
19:10:10 <Lantern_O_jack> Adding '/' to paths: pure. ==> map/fmap
19:10:10 <Lantern_O_jack>  
19:10:18 <harwiltz> Ok, but I don't understand the separation. Can you please explain how to split it up? I was thinking making a list of Trues/Falses by doing fmap . mapM doesDirectoryExist and then somehow mapping it to the list
19:10:42 <Lantern_O_jack> Quick question, do you want to remove non-directories?
19:10:54 <harwiltz> So what do you do with the result of checking if the directory exists? That's what I can't wrap my head around. Sorry about this
19:11:06 <harwiltz> No, I want to keep all of them, just show which ones are directories
19:11:23 <Lantern_O_jack> Okay, then it's okay to fold them into one: I'll post an example in a bit if you want
19:11:30 <harwiltz> Thank you very much
19:12:15 * hackagebot dimensional 1.0.0.0 - Statically checked physical dimensions,  using Type Families and Data Kinds.  https://hackage.haskell.org/package/dimensional-1.0.0.0 (dmcclean)
19:12:24 <harwiltz> If I had a list of booleans generated from mapM doesDirectoryExist and another list generated by the getDirectoryContents, is there a way to "combine" them so that Haskell knows when to add the "/"?
19:12:36 <Lantern_O_jack>     mapM (\path -> do isDir <- doesDirectoryExist path; pure (if isDir then path ++ "/" else path))
19:12:59 <Lantern_O_jack> harwiltz: Sure, if they are in the same order it's easy
19:13:08 <harwiltz> So how do I do that? Thanks so much.
19:13:26 <Lantern_O_jack>     zipWith (\isDir path -> if isDir then path ++ "/" else path)
19:13:30 <Lantern_O_jack> :t zipWith (\isDir path -> if isDir then path ++ "/" else path)
19:13:31 <lambdabot> [Bool] -> [[Char]] -> [[Char]]
19:13:43 <Lantern_O_jack> :t zipWith (\isDir path -> if isDir then path ++ "/" else path) :: [Bool] -> [FilePath] -> [FilePath]
19:13:44 <lambdabot> [Bool] -> [FilePath] -> [FilePath]
19:13:54 <harwiltz> But what is isDir>
19:13:57 <harwiltz> *?
19:14:01 <Lantern_O_jack> the boolean
19:14:16 <Lantern_O_jack> from the list of booleans generated from mapM doesDirectoryExist
19:14:18 <harwiltz> Oh so isDir is the list of booleans and path is the list of directory contents?
19:14:27 <harwiltz> Ahhh I see. Will try that right now. Thanks so much
19:14:30 <ackthet> discuss happstack vs yesod?
19:14:31 <Lantern_O_jack> Well, 'isDir' is a *single* boolean
19:14:43 <Lantern_O_jack> and 'path' is the corresponding *single* path
19:14:49 <Lantern_O_jack> You have the right idea though
19:15:01 <harwiltz> Right but you're calling zipWith on both the lists so it iterates through them
19:15:14 <Lantern_O_jack> Correct
19:15:27 <harwiltz> Thank you very much.
19:15:58 <Lantern_O_jack> yw
19:16:26 <harwiltz> and just to be clear, I get the booleans by mapM (doesDirectoryExist) paths right?
19:17:04 <Lantern_O_jack> Yes
19:17:05 <Lantern_O_jack>     mapM doesDirectoryExist :: [FilePath] -> IO [Bool]
19:17:13 <harwiltz> Great. Thanks a lot.
19:17:23 <Lantern_O_jack> harwiltz: The first example I gave was wrong, since getDirectoryContents only returns filenames and not absolute paths
19:17:50 <harwiltz> Lantern_O_jack, no problem, believe me I came up with a bunch of wrong examples trying to figure this out too haha
19:19:00 <harwiltz> Lantern_O_jack, one more thing, the function should return a IO [FilePath] right?
19:19:05 <Lantern_O_jack> Yes
19:19:15 <harwiltz> Ok, nice
19:19:16 <Lantern_O_jack> It cannot simply return a [FilePath]
19:19:34 <harwiltz> Right. This Monad stuff confuses the hell out of me
19:20:00 <Lantern_O_jack> Start a little smaller until you get used to it, in a way it's a better way of thinking even though it doesn't seem so at first
19:20:45 <harwiltz> I see. I'm starting to get a small understanding of the concept, I think I just need to see it in use a little more.
19:21:08 <lifter> How can I write a literal Double? "10.0" (as opposed to "10")?
19:21:34 <Lantern_O_jack> > 10.0
19:21:36 <lambdabot>  10.0
19:22:34 <Lantern_O_jack> harwiltz: In C (simplified) the following function call returns 6, for the number of characters it prints
19:22:34 <Lantern_O_jack>     printf("Hello\n")
19:22:34 <Lantern_O_jack>     
19:22:37 <lifter> Well 10.0 is a Fractional while 10 is a Num
19:23:08 <Lantern_O_jack> harwiltz: Yet you would never say replace printf("Hello\n") by 6, right?
19:23:17 <Lantern_O_jack> lifter: Then I'm not sure I understand your question
19:23:19 <harwiltz> Lantern_O_jack, right
19:23:41 <Lantern_O_jack> harwiltz: In this sense,
19:23:41 <Lantern_O_jack>     printf("Hello\n") :: IO Int
19:23:41 <Lantern_O_jack> while
19:23:41 <Lantern_O_jack>     6                 ::    Int
19:24:05 <harwiltz> Ok, I kind of see where you're going with this
19:24:13 <Lantern_O_jack> There is a *huge* difference between the two, Haskell makes that difference explicit
19:24:33 <Lantern_O_jack> Whether you care to make that distinction or not, up to you
19:24:48 <Lantern_O_jack> harwiltz: Similar to this pithy quote
19:24:48 <Lantern_O_jack> @quote /bin/ls
19:24:48 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
19:25:05 <harwiltz> I see. Seems interesting, probably just takes a lot of getting used to 
19:25:40 <Lantern_O_jack> At first it's only a PITA
19:25:48 <harwiltz> PITA?
19:25:52 <Lantern_O_jack> Pain in the ass :)
19:25:57 <harwiltz> Hahaha
19:25:59 <harwiltz> Indeed
19:26:20 <Lantern_O_jack> But when you realise that you can use it to your advantage, things change quickly in my experience
19:26:22 <harwiltz> I love Haskell though for the most part. Just this stuff is definitely a PITA :)
19:26:42 <Lantern_O_jack> harwiltz: Do you know any C?
19:27:04 <harwiltz> Lantern_O_jack, I'm excited for that to happen because Haskell seems really interesting. Off to watch a bunch of YouTube videos about this stuff later! And yes, I know some C
19:27:29 <Lantern_O_jack> If we have
19:27:29 <Lantern_O_jack>     int a = i++;
19:27:29 <Lantern_O_jack>     int b = i++;
19:27:29 <Lantern_O_jack> can we refactor it to
19:27:32 <Lantern_O_jack>     int z = i++;
19:27:36 <Lantern_O_jack>     int a = z;
19:27:39 <Lantern_O_jack>     int b = z;
19:27:46 <Lantern_O_jack> And if not, why not?
19:28:44 <harwiltz> Hmm, I would say not because in the second one, a and b store the same value, but in the first one b should be greater than a by 1
19:29:05 <Lantern_O_jack> But we can refactor
19:29:05 <Lantern_O_jack>     int a = 42; int b = 42;
19:29:05 <Lantern_O_jack> to
19:29:08 <Lantern_O_jack>     int z = 42; int a = z; int b = z;
19:29:13 <harwiltz> Yes
19:29:17 <Lantern_O_jack> How is i++ different from 42?
19:29:36 <harwiltz> Because the ++ is only evaluated after, right?
19:29:48 <rcyr> Lantern_O_jack: "i" won't have the same value at the end.
19:29:49 <harwiltz> I don't understand ++ entirely, I just know it isn't evaluated right away
19:30:53 <rcyr> harwiltz: i++ will increment i by one but "return" the old value
19:31:08 <harwiltz> rcyr, right, that's what I meant
19:31:48 <harwiltz> So in his first scenario, a stores 'i', b stores 'i + 1' and then i = 'i + 2' 
19:32:26 <MrSkeltal> I think the idea was that "i++" is a different value in different contexts
19:32:37 <MrSkeltal> so you have absolutely no right to do common-subexpression-elimination
19:33:15 <Lantern_O_jack> harwiltz: In Haskell if you have a similar function "inc i" 
19:33:15 <Lantern_O_jack>     let a = inc i
19:33:15 <Lantern_O_jack>         b = inc i
19:33:15 <Lantern_O_jack> you *can* safely rewrite it as
19:33:18 <Lantern_O_jack>     let z = int i
19:33:21 <Lantern_O_jack>         a = z
19:33:25 <Lantern_O_jack>         b = z
19:33:44 <Lantern_O_jack> *z = inc i
19:33:48 <John[Lisbeth]> I asked about this a year ago and now my research is coming along the same veins
19:34:02 <harwiltz> Lantern_O_jack, is that because of Haskell's laziness?
19:34:05 <John[Lisbeth]> Basically I am curious about the C primitives which make up haskell code today
19:34:07 <John[Lisbeth]> such as <-
19:34:23 <Lantern_O_jack> No, it's beacuse Haskell maintains a distinction between /evaluationf/ on the one and and /execution/ on the other
19:35:03 <harwiltz> Ok, I think I understand
19:35:12 <Lantern_O_jack> harwiltz: When you do
19:35:12 <Lantern_O_jack>     main = do
19:35:12 <Lantern_O_jack>       let foo = putStrLn "ARRGGGH I'M A PIRRATEE"
19:35:12 <Lantern_O_jack>       putStrLn "main"
19:35:15 <Lantern_O_jack> it never prints anything about being a pirate
19:35:28 <harwiltz> what would that print?
19:35:31 <Lantern_O_jack> Just "main"
19:35:36 <Lantern_O_jack> "main\n" to be precise
19:35:43 <Lantern_O_jack> Actions (like 'putStrLn "...") are first class
19:36:02 <John[Lisbeth]> In actuality I am curious about the point at which the code stopped being written and compiled in C and started being written and compiled in haskell
19:36:06 <harwiltz> So why wouldn't the pirate thing be printed?
19:36:23 <John[Lisbeth]> So that I can see the actual logical primitives in haskell
19:37:20 <nolrai66> Harwiltz: because its never ran.
19:37:38 <harwiltz> why doesn't it run?
19:38:08 <John[Lisbeth]> The reason is that I am trying to make my own toy language for running in asp.net
19:38:12 <nolrai66> "let foo = ..." is a definition.
19:38:21 <John[Lisbeth]> which compiles to a language called CIL which is like assembly
19:38:25 <harwiltz> Oh I see.
19:38:38 <John[Lisbeth]> Everything in .net compiles to CIL
19:39:13 <John[Lisbeth]> So if I can trace some of the logical primitives back to C and then back to assembly, then I can ascertain the logical constructs which make up haskell and reproduce "a haskell" for .net
19:43:18 <John[Lisbeth]> It would basically be the "c haskell compiler" and would not longer be in development
19:46:39 <harwiltz> Lantern_O_jack, Everything works almost perfectly for the directory listing, so thanks a lot! Just one more quick thing, all the directories print in quotation marks. 
19:47:10 <harwiltz> I am getting a list returned by the function that called zipWith, then doing mapM_ print list
19:47:26 <harwiltz> Do you know why it displays them in quotes?
19:48:39 <shachaf> Because that is what print does.
19:48:49 <shachaf> (With Strings.)
19:50:11 <harwiltz> shachaf, I'm printing FilePaths. Do you know how to remove the quotes?
19:50:24 <shachaf> FilePath = String
19:51:04 <harwiltz> shachaf, Ok, switched to putStrLn and it works :)
19:53:49 <Lantern_O_jack> harwiltz: Went away to read the Little Prince :) glad it's working
19:54:15 <harwiltz> Lantern_O_jack, no problem. Thanks for all the assistance tonight, you were very helpful.
19:54:37 <Lantern_O_jack> harwiltz: Note of interest, since actions (IO a) are first class, we can make a function that repeats an action twice
19:54:37 <Lantern_O_jack>     twice x = do
19:54:37 <Lantern_O_jack>       x
19:54:37 <Lantern_O_jack>       x
19:54:57 <Lantern_O_jack> or a function that repeats action forever
19:54:57 <Lantern_O_jack>     forever x = do
19:54:57 <Lantern_O_jack>       x
19:54:57 <Lantern_O_jack>       forever x
19:55:13 <harwiltz> I was actually just reading about that this morning!
19:55:39 <harwiltz> Is that the preferred way to do an infinite loop? (Like for a game or a command shell)
19:56:17 <Lantern_O_jack> Generally yes, it's very useful in simple threads to spin a thread that executes some action forever
19:56:56 <Lantern_O_jack> harwiltz: Since they are first class we can also store actions in lists, or trees, or ...
19:56:57 <harwiltz> That sounds pretty complicated. I'm not very well-versed in threads either
19:57:12 <Lantern_O_jack> Not really complicated!
19:57:37 <Lantern_O_jack>     forkIO (forever (print 1))
19:57:37 <Lantern_O_jack> will print 1 forever in a separate thread
19:57:54 <harwiltz> Really? That's actually pretty simple
19:57:59 <Lantern_O_jack> :-)
19:58:01 <harwiltz> Is that done in the IO Monad?
19:58:05 <Lantern_O_jack> Yes
19:58:09 <Lantern_O_jack>     forkIO :: IO () -> IO ThreadId
19:58:13 <harwiltz> Interesting. Will keep that in mind
19:58:17 <nitrix> I'd argue that no.
19:58:22 <nitrix> I hate when people say IO Monad.
19:58:37 <harwiltz> Sorry but whats the correct way to say it?
19:58:58 <Lantern_O_jack> harwiltz: It's not wrong, but it's fine to just say "IO"
19:58:58 <nolrai66> Thats how people say it.
19:59:00 <nitrix> It's an IO action.
19:59:06 <harwiltz> Oh ok
19:59:13 <nitrix> Monad IO is just one way to use the action. It's just a type.
19:59:17 <Lantern_O_jack> Since IO is many things, and there is really no reason to mention "Monad"
19:59:38 <harwiltz> Honestly I still don't really know what a Monad is. I have lots of research to do haha
19:59:54 <Lantern_O_jack> Don't worry about it 
20:00:28 <Lantern_O_jack>     forkIO (forever (putChar 'a'))
20:00:28 <Lantern_O_jack>     forkIO (forever (putChar 'b'))
20:00:28 <Lantern_O_jack> forks two threads that print 'a' and 'b' forever
20:01:03 <harwiltz> So the a's and b's would likely intertwine when printed right? (because they're being printed simultaneously)
20:01:29 <nitrix> harwiltz: There are many tutorials online and they are almost all terrible. My recommendation if you were on #haskell-beginners would be to understand the type system first, then everything else will magically fall into place.
20:01:40 <nitrix> harwiltz: Most importantly, monads aren't burritos.
20:02:15 <MrSkeltal> yep, can't bind burritos
20:02:28 <harwiltz> nitrix, I didn't think they were, hahaha. I'm reading Learn you a Haskell right now and so far I'm finding it helpful
20:03:01 <lpaste> emmanuel_erc pasted “I want to boost the speed of this piece of code: Finding  all  necessary pairs of distances from point set (Here are two attempts)” at http://lpaste.net/144303
20:03:06 <nitrix> harwiltz: LYAH is a great book to introduce you to the language; unfortunatly, from the middle and onwards, the content isn't very adequate or approached properly for a beginner.
20:03:22 <emmanuel_erc> some more crappy code from me
20:03:23 <harwiltz> nitrix, ok. So you suggest I learn on irc?
20:04:00 <nitrix> harwiltz: Read the book, develop your curiosity, maybe do toy projects or exercises and see what problems comes up. We'll be glad to help and point you in the right directions after that.
20:04:37 <harwiltz> nitrix, that's actually exactly what I'm doing! Right now I'm trying to build a simple file manager. Hopefully not too big of a leap
20:06:49 <lispy> emmanuel_erc: if you change the type signature of dists to use Double instead of (Fractional b, Storable b) do you get any improvement?
20:07:01 <lispy> emmanuel_erc: I'm guessing no, because GHC likely inlines it already
20:08:41 <glguy> > let pairs xs = [ (y,z) | y:ys <- tails xs, z <- ys ] in pairs [1..4]
20:08:42 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
20:08:45 <lispy> emmanuel_erc: Personally, I would replace the lambda inside the unfoldr with a locally defined function. Then you can use pattern matching instead of head/tail
20:08:58 <glguy> emmanuel_erc: If you want to speed your code up, you should profile it and see where it's slow
20:09:32 <emmanuel_erc> sorry, you are right I should do that.
20:10:33 <nitrix> harwiltz: Join me on #haskell-beginners, I'm curious to see where you're at with your learning :)
20:10:57 <glguy_> Beginner questions are fine in #haskell
20:11:13 <emmanuel_erc> lispy, are lambdas generally slow when they are used like I have?
20:11:16 <Lantern_O_jack> Yearh harwiltz, also check your PM
20:11:17 <harwiltz> nitrix, this is going to sound very stupid but this is one of my first times on irc. What do you mean by "join me"?
20:11:28 <lispy> emmanuel_erc: I'm suggesting it for readability
20:11:31 <harwiltz> And how do I check my pm? 
20:11:51 <harwiltz> I'm using WeeChat btw
20:11:54 <emmanuel_erc> Ah I see. Yeah, I have a bad habit of using lambdas to get down my thoughts as quickly as possible.
20:12:11 <emmanuel_erc> Or I might lose them...
20:12:17 * hackagebot lol 0.0.1.0 - A general-purpose library for lattice cryptography.  https://hackage.haskell.org/package/lol-0.0.1.0 (crockeea)
20:12:20 <nitrix> harwiltz: You're not joining me specifically; it's a separate channels where we try to help beginners which often spawns long discussions where we break down subjects. /j #haskell-begineers
20:12:26 <lispy> emmanuel_erc: actually, in this case it's the if/then/else with head/tail that I don't like. using lambdas can be fine
20:13:23 <nitrix> hackagebot: /j #haskell-beginners 
20:13:24 <harwiltz> nitrix, oh ok I see. I'm actually just about to go to sleep, it's almost midnight where I am. Are you on often? Because that sounds pretty cool
20:13:25 <Lantern_O_jack> harwiltz: You should be able to use "Alt + Left key" and "Alt + Right key" to change between tabs
20:13:27 <nitrix> Gah.
20:13:39 <nitrix> harwiltz: Oh okay. No problem.
20:13:58 <harwiltz> Lantern_O_jack, I just saw your pm. Thanks so much! Now how do I send a PM?
20:14:45 <harwiltz> Lantern_O_jack I think I got it
20:14:46 <shachaf> Note that that channel is unaffiliated with #haskell. There's no problem with beginners in #haskell.
20:15:09 <Lantern_O_jack> You can write
20:15:09 <Lantern_O_jack>     /query Lantern_O_jack hello
20:15:09 <Lantern_O_jack> to send a message to me, my nick is normally Iceland_jack outside of Halloween :)
20:15:21 <harwiltz> Hahaha sounds good!
20:15:31 <harwiltz> I used /msg though
20:15:36 <Romefeller> Lantern_O_jack: are you from Iceland?
20:15:45 <Lantern_O_jack> Yes
20:16:21 <Lantern_O_jack> I am currently in the US though, when in Rome carve pumpkins and change your nick to something scary
20:16:35 <Romefeller> Lantern_O_jack: You know a lot about winter lol. Im from Brazil
20:17:14 <lispy> emmanuel_erc: As an example, I find this version slightly easier to read (even with a silly name for the lambda): http://lpaste.net/144303
20:17:48 <harwiltz> Alright, goodnight all, I shall be off to bed. Thanks so much for all the help!
20:18:29 <glguy_> In this case unfoldr isn't necessary
20:19:22 <emmanuel_erc> lispy: in response to your earlier hint about replacing the type signature of dists. IT only boosted the speed of each version by a non impressive amount.
20:20:35 <lispy> emmanuel_erc: I'm not too surprised because it's in the same module and a good candidate for inlining. The reason I mentoined it is because number crunching is fastest when GHC knows the numeric type "end-to-end" in a computation.
20:21:09 <lispy> emmanuel_erc: also, not sure if you noticed glguy_'s suggestion
20:21:14 <emmanuel_erc> I should get rid of it... When I use simpleBuild function, if I later want to get the distaces between points 1 and 2 and then later get the distance between 2 and 1, I have to do this complex lookup.
20:21:26 <emmanuel_erc> I will get rid of the unfoldr
20:21:33 <emmanuel_erc> I saw his suggestion.
20:21:43 <emmanuel_erc> (or her, I don't know)
20:21:51 <lispy> his
20:23:42 <emmanuel_erc> So about the inlining, then I should also put a "detailed" type signature for that function as well?
20:24:31 <lispy> Let's see. I always get these mixed up, but there are a few pragmas that might help.
20:24:46 <lispy> I think You want SPECIALIZED
20:25:17 <lispy> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/pragmas.html#specialize-pragma
20:26:59 <lispy> You won't see a speed up here, but if you later refactor your code it will give you a tiny bit of future proofing
20:27:59 <emmanuel_erc> Yea, the simpleBuild is still faster than simpleMapBuild
20:28:06 <emmanuel_erc> I wasn't expecting that.
20:28:37 <emmanuel_erc> I think I definitely doing something wrong.
20:29:06 <lispy> Do you mind posting the current version again?
20:29:51 <emmanuel_erc> Sure, I think I am going to try glguy's suggestion about pairs, to see if there is any difference.
20:30:16 <emmanuel_erc> But, the memory usage of simpleBuild went down from 100K bytes to 80 bytes.
20:30:56 <enoon> hello all
20:31:01 <tommd> hello enoon
20:31:15 <enoon> haskell is fun :D
20:31:20 <enoon> sorry, stating the obvious
20:31:27 <tommd> Yep.  It's allowed.
20:31:55 <lispy> Haskell is fun...ctional.
20:32:13 <emmanuel_erc> That last comment about memory usage is vague. I am testing it with dumb lists of size 1000.
20:32:17 <enoon> get outta here lisp
20:32:37 <lispy> (I see (what you) did (there))
20:33:57 <lispy> emmanuel_erc: What do you use for benchmarking this? You use the profiler and some example inputs?
20:34:19 <lispy> emmanuel_erc: and what optimization level do you request?
20:34:38 <enoon> if anyone wants to have a read of the xkcd, here's a link
20:34:42 <enoon> https://drive.google.com/file/d/0B2E_iIvrv8jkQ0g1RXNoUHBvc3c/view?usp=sharing
20:34:52 <emmanuel_erc> I am just using the :set +s flag in ghci
20:35:03 <emmanuel_erc> which is probably very lightweight.
20:36:09 <isovector> is local a necessary part of MonadReader?
20:36:27 <isovector> I have an implementation for get, but i don't think local is do-able for my monad
20:36:30 <isovector> ask*
20:36:37 <lispy> emmanuel_erc: You might read this over: http://book.realworldhaskell.org/read/profiling-and-optimization.html
20:37:04 <lispy> emmanuel_erc: if you're not compiling your program, it's hard to say how the performance will be when it is compiled (and if you want performance you should compile it)
20:37:35 <enoon> @lispy: would you mind reading this, you have to save it as html first, and then open (in browser, ofcourse) :D                        https://drive.google.com/file/d/0B2E_iIvrv8jkQ0g1RXNoUHBvc3c/view?usp=sharing
20:37:35 <lambdabot> Unknown command, try @list
20:40:14 <shachaf> enoon: What are you doing?
20:42:41 <lispy> emmanuel_erc: beyond the advice in RWH, the criterion library is nice once you've found a hotspot and you want to compare alternative implementations
20:42:41 <lpaste> emmanuel_erc annotated “I want to boost the speed of this piece of code: Finding  all  necessary pairs of distances from point set (Here are two attempts)” with “I want to boost the speed of this piece of code: Finding  all  necessary pairs of distances from point set (Here are two attempts) (annotation)” at http://lpaste.net/144303#a144305
20:42:59 <pause_> Hello
20:43:04 <lispy> Hello
20:43:05 <enoon> hello play
20:43:07 <emmanuel_erc> hello there pause_
20:43:15 <Cale> isovector: I would say it is... why is local hard?
20:43:20 <pause_> I have a quick beginner question :-)
20:43:22 <enoon> with reference to what shachaf?
20:43:30 <enoon> play
20:43:34 <enoon> sorry, go pause
20:43:39 <pause_> Track 1:
20:43:47 <emmanuel_erc> So I just ran that compiled that piece of code with the options -O2 and --make
20:43:58 <Cale> isovector: Though I really don't like the mtl MonadFoo classes much at all, and think that people should usually make more domain specific classes.
20:44:11 <pause_> In GHCI, ':t (flip (:)) gives me the expected answer, while ':t (flip :) does not
20:44:21 <pause_> What is the difference that i did not get ?
20:44:22 <emmanuel_erc> My stats are real	0m0.403s user	0m0.373s sys	0m0.027s
20:44:32 <lispy> emmanuel_erc: ah, so you're still removing unfoldr and making those other changes.
20:44:39 <shachaf> pause_: (flip :) is ((:) flip), like (5 +) is ((+) 5).
20:44:45 <emmanuel_erc> Yea I should do that.
20:44:47 <Cale> pause_: (flip :) is the function which adds flip to the beginning of a list of functions
20:44:58 <Cale> It's an operator section
20:44:58 <emmanuel_erc> glguy's piece of code wasn't working though...
20:45:09 <lispy> emmanuel_erc: Also, I'm not sure I made that 'unfoldIt' edit correctly. I was just sort of hacking that in as a demonstration. So double check it before you use it :)
20:45:21 <emmanuel_erc> It works fine.
20:45:32 <emmanuel_erc> as far as I can tell.
20:45:40 <pause_> shachaf: Cale: Thanks, i'll try to wrap my head around that :D
20:46:00 <shachaf> pause_: ((flip :) xs) = (flip : xs)
20:46:09 <Cale> pause_: In general (x :) is the function which adds x to the beginning of a list, and this is no different when x = flip
20:46:18 <Cale> > (1:) [2,3,4,5]
20:46:19 <lambdabot>  [1,2,3,4,5]
20:46:41 <Cale> > map (1:) [[2,3],[4,5],[6,7]]
20:46:43 <Lokathor> There seem to be several libraries to abstract over SQL access. If i'm using postgresql but don't want to be locked out of a possible later switch, what's the current best lib to look at?
20:46:44 <lambdabot>  [[1,2,3],[1,4,5],[1,6,7]]
20:47:06 <pause_> Ah thanks, i get it now.
20:47:38 <Romefeller> :t flip
20:47:39 <lambdabot> (a -> b -> c) -> b -> a -> c
20:47:53 <pause_> Nice bot !
20:48:22 <pause_> I'll try that in ghci, thank you all for your help
20:48:38 <emmanuel_erc> Here are the stats with simpleBuild real	0m0.016s user	0m0.013s sys	0m0.000s
20:48:44 <emmanuel_erc> If anyone is interested...
20:49:26 <ReinH> Lokathor: persistent is popular due to yesod
20:49:56 <Lokathor> ReinH, ah, i found this tutorial for persist, https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/persistent-db
20:50:05 <Lokathor> but it's from 2013, should it still be accurate enough?
20:50:34 <Lokathor> or is there perhaps a better/newer tutorial?
20:50:43 <ReinH> dunno
20:50:52 <ReinH> iirc it's covered in the yesod book
20:51:41 <Lokathor> i'll give that a look
20:57:41 <isovector> Cale: writing a State monad that uses lenses to restrict which parts you can change to, but provides a Reader of the entire managed state
20:58:21 <lispy> emmanuel_erc: are you generating the indices in order?
20:58:34 <isovector> unless maybe local just discards any changes you make inside of it?
20:58:44 <Cale> isovector: Usually what I would do is rather than providing MonadReader/MonadState instances, just design operations for manipulating the various pieces of state in whatever ways seem reasonable for the application.
20:59:07 <Cale> isovector: and then *consider* abstracting over those operations using a type class, if it seemed like it would have any benefit
20:59:52 <emmanuel_erc> lispy: I found another way to do it ( it is kind of gros though).
20:59:59 <emmanuel_erc> I'll post an annotation in a moment.
21:00:02 <Cale> isovector: another option for abstracting over the operations is to make a record datatype with a monad type parameter, with the operations as fields, which you can then pass around as an argument -- that gives even more freedom in terms of how the operations are implemented
21:00:25 <isovector> Cale: that's a good idea about a new typeclass. 
21:00:41 <isovector> Cale: afraid to make any changes to it though, spent all day trying to get it to typecheck
21:01:19 <Cale> The case where you want a new type class rather than just monomorphic operations that only work in the one newtype-monad you defined is when you think there are other monads which would implement the same operations.
21:01:28 <Cale> and so you'd gain some benefit from abstracting over them
21:02:06 <Cale> There are a *lot* of libraries which go overboard in this respect imo
21:02:57 <isovector> Cale: makes sense. seems reasonable to make this a State, and it's conceptually a Reader too, except for local being wrong
21:03:02 <Cale> Yeah, monad transformers are a thing, but honestly, not everything has to be a monad transformer
21:03:14 <lpaste> emmanuel_erc annotated “I want to boost the speed of this piece of code: Finding  all  necessary pairs of distances from point set (Here are two attempts)” with “I want to boost the speed of this piece of code: Finding  all  necessary pairs of distances from point set (Here are two attempts) (annotation) (annotation)” at http://lpaste.net/144303#a144306
21:03:39 <emmanuel_erc> simpleBuild is still better (4x times faster).
21:03:42 <Cale> isovector: There's not a whole lot that writing an instance of MonadReader actually gets you
21:04:17 <glguy> emmanuel_erc: You don't need to use 'concat' when you're generating the list of pairs directly
21:04:39 <isovector> Cale: I suppose that's true. good enough for me haha
21:04:46 <Cale> isovector: there are very few operations as it is which don't apply to all monads, but require a MonadReader or MonadState constraint, and you're not losing much by not having instances of those classes
21:04:55 <emmanuel_erc> I made a mistake
21:05:12 <emmanuel_erc> while posting it.
21:05:28 <emmanuel_erc> replace everyting after concat with --> pairs . preCombs $ [0..(V.length input -1)]
21:05:42 <Cale> As long as you can do the things you want to do *somehow* those type classes are pretty unimportant
21:06:32 <lpaste> emmanuel_erc annotated “I want to boost the speed of this piece of code: Finding  all  necessary pairs of distances from point set (Here are two attempts)” with “I want to boost the speed of this piece of code: Finding  all  necessary pairs of distances from point set (Here are two attempts) (annotation) (annotation) (annotation)” at http://lpaste.net/144303#a144307
21:10:02 <isovector> so. now that i have an implementation, the hard part is what should i name this thing
21:13:25 <emmanuel_erc> I've generated rts profiles of both functions (simpleBuild and simpleMapBuild) and their productivity percentage are much lower than I would have thought.
21:14:20 <emmanuel_erc> Fro the former I get 28.6% and the latter I get 46.4%
21:14:25 <emmanuel_erc> For*
21:15:38 <emmanuel_erc> So, this is confusing, building to store the distances is slower but ghc does garbage collection more effectively for that function more effectively.
21:15:46 <emmanuel_erc> How does that make sense?
21:16:12 <lispy> Well, there is another possibility
21:16:29 <lispy> all that "productive" work is doing the insertion
21:16:40 <lispy> and that takes log(n) time in the map
21:16:42 <emmanuel_erc> I see.
21:17:42 <lispy> well, and also those reverses are not free
21:18:31 <lispy> Have you tried using the vector version to build it and then converting that to a map using fromAscList?
21:18:48 <emmanuel_erc> That's a good suggestion.
21:19:36 <emmanuel_erc> I wanted to add the -prof flag, and now I have to reinstall vector and hmatrix with  the right flags .... uggghhh 
21:20:17 <emmanuel_erc> I will try that.
21:21:21 <emmanuel_erc> I reallly  should get a mentor.
21:21:50 <lispy> Get a Haskell Coach
21:22:00 <emmanuel_erc> I have tried talking to some CS people at my university. I want to send this CS professor my code, but he is probably too busy.
21:22:19 <lispy> Yeah, professors tend to be busy
21:22:27 <emmanuel_erc> Where could I go to ask for one?
21:22:46 <lispy> If you don't mind them being remote you could ask here, reddit, or the mailing lists
21:23:42 <emmanuel_erc> Ok... Huge request to everyone in the IRC chat: Who wants to be my mentor. I already have a package on github to critique.
21:23:42 <lispy> People on this channel tend to be happy to help.
21:23:48 <emmanuel_erc> Any takers?
21:24:01 <emmanuel_erc> You have been really helpful lispy.
21:24:06 <lispy> yw!
21:24:07 <emmanuel_erc> Thanks a lot for your help.
21:24:43 <pimlu> I'm going through project euler with haskell, and every time I solve one successfully I check the haskell wiki for their solution
21:25:06 <pimlu> and usually when I look at the wiki's solution compared to mine I feel so inadequate lol
21:25:38 <emmanuel_erc> Yeah, there a lot of tricks in Haskell.
21:25:41 <lispy> emmanuel_erc: I'm hoping we can get the mentoring situation for Haskell to be a bit more transparent and streamlined. I see it as pretty important for retaining beginners into expert-hood.
21:26:06 <pause_> pimlu: Same here, feeling like a monkey banging on a keyboard
21:26:34 <martinvlk> lispy: I second that 
21:26:42 <emmanuel_erc> I really want to get good at Haskell. It seems so much more powerful and expressive tthan any other programming language I've encountered. So much so, that I am willing to put up with the learning curve.
21:26:56 <pimlu> yeah, exactly
21:27:23 <martinvlk> Been learning for over half a year myself and still not productive  ... 
21:29:18 <emmanuel_erc> lispy: There is something strange that I noticed when I tried to run the executable cabal generated for my first project. It ran substantially slower than my runs before the cabal build. I even passed the exact same compiler flags to the cabal file during the build.
21:29:32 <emmanuel_erc> If you are willing to answer, why might that happen?
21:29:44 <lispy> Was that with profiling?
21:30:21 <emmanuel_erc> I was timing my code. But I was not doing the intensive prolifing that I just did right now.
21:30:23 <emmanuel_erc> Me culpa
21:30:38 <emmanuel_erc> I was really just racing to get code that even worked.
21:31:12 <lispy> Turning on the profiler changes the way code gets generated and sometimes interferes with optimizations, but it also requires extra book keeping. So it's expected that turning on profiling slows down a program.
21:32:06 <lispy> I can never remember if cabal uses optimizations by default. You want at least -O, -O2 helps for some things but it also dramatically increases compile times.
21:32:29 <lispy> Other than that, it's hard to say why it would get slower
21:34:32 <lispy> My usual workflow is to write things in the way that seems natural and defer optimization until something in too slow.
21:34:39 <emmanuel_erc>  BRB
21:34:40 <lispy> Then I use that as a test case for making things faster
21:35:02 <lispy> (haskell has taught me to be lazy!)
21:52:45 * hackagebot stripe-core 2.0.1 - Stripe API for Haskell - Pure Core  https://hackage.haskell.org/package/stripe-core-2.0.1 (DavidJohnson)
21:52:47 * hackagebot stripe-haskell 2.0.1 - Stripe API for Haskell  https://hackage.haskell.org/package/stripe-haskell-2.0.1 (DavidJohnson)
21:52:49 * hackagebot stripe-http-streams 2.0.1 - Stripe API for Haskell - http-streams backend  https://hackage.haskell.org/package/stripe-http-streams-2.0.1 (DavidJohnson)
21:53:30 <Adeon> what happens if C calls back to haskell, an exception is thrown and no one catches it
21:54:29 <Adeon> okay I'm testing
21:54:34 <Adeon> it can't be good
21:58:13 <Adeon> okay it doesn't crash if I exception in the callback but the remaining C code is not executed
21:58:25 <Adeon> so it's like longjmp()
22:00:39 <Adeon> I bet lots of C libraries would get in inconsistent state if you unexpectedly jump over their call stack
22:05:42 <emmanuel_erc> "<lispy> (haskell has taught me to be lazy!)" <-- HA!
22:13:49 <lispy> Adeon: This seems fitting: http://i.imgur.com/BFEM8r8.jpg
22:13:58 <lispy> scary pumpkin
22:56:26 <Kristler> Out of curiosity
22:56:39 <Kristler> Is is possible to use the guard syntax in a lambda function?
22:59:12 <nitrix> Whao. I'm impressed.
22:59:29 <nitrix> I compiled a binary on my machine, copied it to a server and it worked out of the box.
22:59:39 <nitrix> Does GHC compiles statically?
23:00:47 <MarcelineVQ> Kristler: if you don't find what you're after there's https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#multi-way-if 
23:01:27 <Kristler> neat, thank you MarcelineVQ! I realized shortly after, that pulling the function out into a where clause was the right way to go
23:01:45 <MarcelineVQ> That's probably best, for clarity
23:03:33 <Kristler> Small extension on that question: If I want to pattern match on a list, but don't intend on deconstructing the list, is xss@(x:xs) the best choice?
23:03:58 <MarcelineVQ> why not just call it xs if you don't plan to take it apart?
23:04:48 <Kristler> You're absolutely right
23:07:57 <davidthomas> nitrix: Mostly, yes
23:14:34 <jg> hi all. I want to use ConduitM with my custom monad stack. "type WST a = WriterT [Paragraph] (StateT ParserState Identity) a" how do i combine the two?
23:15:15 <jg> i'd want to use my WST monad in the following sink:  sink ::MonadIO m => ConduitM XT.Event o m ()
23:19:13 <johnw> use it with your custom stack how?
23:21:29 <jg> well, in a way that enabled me to use WST inside of the sink
23:21:33 <jg> *enables
23:21:50 <johnw> but use it how?
23:22:00 <johnw> as in, runStateT . runWriterT?
23:22:31 <johnw> are you asking if you can lift your WST into something that's MonadIO?
23:23:53 <jg> i don't care about that MonadIO restriction, i just want to use my stack there
23:24:04 <jg> lift get, lift put, runWriterT
23:27:51 <johnw> I still don't know what you mean by "use my stack"
23:27:58 <emmanuel_erc> glguy: I just finished getting through the Real World Haskell chapter on optimization. Though it is a bit dated, there is a lot that I am currently not doing to optimize my code.
23:28:04 <johnw> if you have a WST action, you can run it anywhere
23:28:12 <johnw> composing it through a conduit, that's something very different
23:30:07 <jg> johnw: maybe this snippet will show what i'm trying to do http://lpaste.net/2038598195457556480
23:30:30 <jg> it's an html parser where i want to make a list of Paragraph from a html page
23:30:59 <johnw> ah, I see
23:31:18 <johnw> "WST m =>" is not correct
23:31:36 <johnw> so, you can do this
23:31:41 <johnw> ConduitM XT.Event o WST ()
23:31:43 <johnw> then, later
23:32:05 <johnw> =$= hoist _ eventConduit
23:32:14 <johnw> what "_" should be I don't exactly remember, but the hole should tell you the type
23:32:30 <johnw> it's either liftIO, or return, or return . runIdentity
23:33:05 <jg> johnw: yeah, i tried that but compiler says 'WST should have 1 argument'
23:33:09 <jg> in ConduitM XT.Event o WST ()
23:33:14 <johnw> it needs to be a newtype, not a type synonym
23:33:18 <johnw> or
23:33:24 <johnw> drop "a" from both sides of the synonym
23:34:37 <jg> what's the difference between newtype and this type thing i used?
23:34:50 <johnw> you mean, type WST a and newtype WST a?
23:34:57 <jg> yes
23:36:07 <johnw> there are actually quite a few differences, I'd recommend reading up on that subject.  Did dropping the "a" from both sides work?
23:36:40 <jg> yes
23:38:04 <jg> thanks johnw. I might be able to take it from here. There's some docs on using transformers with conduit https://github.com/snoyberg/conduit/wiki/Dealing-with-monad-transformers
23:39:02 <emmanuel_erc> hello everyone!
23:39:36 <jle`> hi emmanuel_erc !
23:41:04 <emmanuel_erc> So what type of applications do you mainly write in Haskell for?
23:42:04 <kras> Hi, how can I convert the following do notation to use >>= instead?
23:42:12 <kras> http://lpaste.net/144317
23:43:24 <johnw> kras: Port <$> identifier <*> pure Nothing <*> pure "input"
23:43:55 <johnw> (\b -> Port b Nothing "input") <$> identifier
23:44:04 <johnw> identifier >>= \b -> return $ Port b Nothing "input"
23:44:06 <Cale> kras: identifier >>= \b -> return (Port b Nothing "input")
23:44:21 <johnw> Monad is not needed for this, only Functor
23:44:28 <Cale> @undo do b <- identifier; return (Port b Nothing "input")
23:44:28 <lambdabot> identifier >>= \ b -> return (Port b Nothing "input")
23:44:47 <kras> johnw: any advantages of using Appl functor instead of a monad?
23:44:54 <Cale> yeah, you could just write  fmap (\b -> Port b Nothing "input") identifier
23:44:57 <johnw> just that monad isn't necessary
23:45:12 <Cale> Applicative is also not necessary
23:45:16 <johnw> right
23:46:22 <kras> thanks for the comments
23:46:41 <John[Lisbeth]> Back, again.
23:46:58 <John[Lisbeth]> I'm curious about the underlying math that makes up functional programming in haskell.
23:47:19 <johnw> emmanuel_erc: every kind of application that I have need of, actually
23:47:22 <John[Lisbeth]> Because I am trying to run .net class libraries in haskell
23:48:21 <johnw> how does that relate to your question about math in Haskell?
23:49:31 <emmanuel_erc> johnw: Cool... have you run in to any situations where Haskell has been underwhelming and consequently used another programming language?
23:49:42 <johnw> emmanuel_erc: no, not at all
23:50:08 <johnw> I've used it for system scripting, web scraping, web applications, database queries, parsing, numerical computations, etc.
23:50:42 <johnw> I might not write a commercial game in it just yet, due to relatively poor graphics bindings, but that scene is getting better
23:50:54 <emmanuel_erc> I am just starting out with Haskell; I have about 8 months on my beard..ha! How long have you been using it?
23:51:52 <johnw> 3 years and a month now :)
23:52:04 <johnw> and professionally for all that time
23:52:11 <johnw> (as well as personally)
23:52:25 <johnw> I used to use Python and Ruby as my go-to languages, but I replaced them with Haskell a while back
23:52:36 <johnw> and I used C++ as my high performance language, but Haskell replaced that too
23:52:41 <emmanuel_erc> That's impressive given the seeming dearth of Haskell jobs.
23:54:14 <emmanuel_erc> I am actually in grad school right now, and I've made the somewhat controversial decision (at least in my circles) of using Haskell for my research, which is in the area of machine learning (specifically topological data analysis).
23:54:42 <emmanuel_erc> It seems that Haskell is an extremely good candidate for this type of work. Would you agree johnw?
23:54:47 <johnw> I certainly would
23:54:50 <johnw> but I hang out in #haskell :)
23:55:41 <johnw> I have a friend who chose Haskell for analytical tasks relating to neuroscience research, and he was very happy with the result
23:56:17 <nitrix> Hi, how would I make a Wai application drop root permission after binding on port 80? I found setBeforeMainLoop but I'm missing the action that'd perform this.
23:56:31 <emmanuel_erc> What was your friend using before Haskell?
23:56:39 <jle`> emmanuel_erc: i am another grad student who is using haskell exclusively for my research :)
23:56:49 <jle`> er, exclusively using haskell for my reasearch
23:56:52 <jle`> i don't know how to grammar
23:57:02 <johnw> nitrix: the 'unix' package makes setEffectiveUserId available
23:57:18 <johnw> emmanuel_erc: I'm not sure, actually, I'm going to see him on Sunday so I'll have to ask
23:57:46 <johnw> jle`: I would have read both sentences equally
23:58:02 <johnw> unless you meant that also used Haskell elsewhere
23:58:08 <jle`> "using haskell exclusively for my research" might be interpreted as the only situation where i use haskell is for research, and nowhere else
23:58:15 <johnw> right
23:58:20 <emmanuel_erc> That's awesome jle`. What's your major?
23:58:24 <jle`> but i meant to say that all of my research is in haskell
23:58:37 <johnw> good night, all
23:58:41 <jle`> er, not research in haskell, but i use haskell to write programs and...stuff
23:58:43 <jle`> night johnw :)
23:58:51 <jle`> um i like to call it an applied math/computational science
23:59:18 <Adeon> haskell is not the predominant language I use at my work but I've used for job orchestrating
23:59:27 <Adeon> I work in ad industry
23:59:45 <emmanuel_erc> ah
