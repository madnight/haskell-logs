00:00:00 <liste> or x `elem` [a, b, c] ==>
00:00:56 <roelof> it seems to do it only I see this error message : http://lpaste.net/143537
00:01:11 <liste> @check \x y -> (x == 0 || y == 0) ==> x * y === 0
00:01:14 <lambdabot>  No instance for (Show prop0) arising from a use of ‘myquickcheck’
00:01:14 <lambdabot>  The type variable ‘prop0’ is ambiguous Note: there are several potential ins...
00:01:36 <MarcelineVQ> it's telling you pretty clearly what the problem is there, you have more than one `main` function
00:01:57 <lightandlight> Oh right (==>) is what I was looking for
00:02:00 <lightandlight> Thanks
00:02:16 <liste> yw (:
00:02:58 <liste> hope it's cute enough
00:03:14 <roelof> MarcelineVQ:  I know, I try to figure out how to solve it. I have on every test a main 
00:04:21 <MarcelineVQ> In one file you have two `main`, that's an error
00:05:27 <fizruk> roelof: you're probably importing your app's Main.hs from a test.hs
00:05:30 <roelof> MarcelineVQ:  yes, like I said Im thinking how to solve that one : http://lpaste.net/143535
00:06:40 <MarcelineVQ> well, if they do the same thing and they look like they basically do, you can just remove one
00:07:39 * hackagebot sbv 5.3 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  https://hackage.haskell.org/package/sbv-5.3 (LeventErkok)
00:07:39 * hackagebot hjsonschema 0.7.1.0 - JSON Schema library  https://hackage.haskell.org/package/hjsonschema-0.7.1.0 (seagreen)
00:08:30 <roelof> oke, so one big test file for all the exercises and not a possibility to run only 1 test , pity :( 
00:09:15 <fizruk> roelof: or multiple files, one for each exercise, if you want to run tests per exercise
00:09:30 <MarcelineVQ> there's two things going on, you can't have two functions at the top level with the same name, and since main is the entry point for a haskell program you should only have one in a single program.
00:09:56 <roelof> fizruk:  oke, I can do that also. One file a exercise  instead of 1 project per exercise  
00:14:25 <cwl> Consider a representation of matrices as nested lists, with the inner lists being the rows. Use Traversable to implement transpose :: [[a]] -> [[a]] which transposes a matrix. https://en.wikibooks.org/wiki/Haskell/Traversable#Interpretations_of_Traversable
00:15:00 <Darwin226> Hey guys. I'm using file-embed to embed a css file in my library. The library doesn't build on hackage because it can't find the file. How do I make sure the file is visible? If I include it in data-files or extra-source-files, will it work?
00:15:34 <cwl> How to implement it?
00:15:43 <fizruk> :t sequenceA
00:15:45 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
00:15:58 <cwl> :t traverse
00:16:00 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
00:16:07 <fizruk> cwl: ^ that switches t and f
00:16:38 <cwl> > traverse id [[1,2,3],[4,5,6],[7,8,9]]
00:16:40 <lambdabot>  [[1,4,7],[1,4,8],[1,4,9],[1,5,7],[1,5,8],[1,5,9],[1,6,7],[1,6,8],[1,6,9],[2,...
00:16:45 <fizruk> cwl: in your case [[a]] is presumably a list of rows
00:17:01 <cwl> > traverse (\row -> [ row !! 0 ]) [[1,2,3],[4,5,6],[7,8,9]]
00:17:03 <lambdabot>  [[1,4,7]]
00:17:16 <cwl> > traverse (\row -> [ row !! 1 ]) [[1,2,3],[4,5,6],[7,8,9]]
00:17:17 <lambdabot>  [[2,5,8]]
00:17:19 <cwl> > traverse (\row -> [ row !! 2 ]) [[1,2,3],[4,5,6],[7,8,9]]
00:17:21 <lambdabot>  [[3,6,9]]
00:19:29 <cwl> > let transpose ([]:_) = []; transpose xs = map head xs : transpose (map tail xs); in transpose [[1,2,3],[4,5,6],[7,8,9]]
00:19:31 <lambdabot>  [[1,4,7],[2,5,8],[3,6,9]]
00:19:45 <roelof> fizruk:  MarcelineVQ  thanks for the help 
00:20:17 <fizruk> cwl: so you can write it like [Row a] (just to separate the meaning of two lists), where data Row a = Row [a]
00:21:12 <fizruk> cwl: now, you want to get from [Row a] to Row [a]
00:21:38 <fizruk> :t sequenceA
00:21:39 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
00:22:34 <fizruk> cwl: you might use sequenceA for that if Row is an Applicative
00:22:56 <fizruk> cwl: [] is already an Applicative, but as you've noticed, it does not do what you want
00:24:04 <fizruk> cwl: note that it's Applicative instance that does not work here for us, not Traversable — sequenceA/traverse preserve the structure of t
00:27:32 <fizruk> cwl: sequenceA "sequences" applicative values, so that [row1, row2] becomes (\x y -> [x, y]) <$> row1 <*> row2
00:27:34 * hackagebot Slides 0.1.0.2 - Generate slides from Haskell code  https://hackage.haskell.org/package/Slides-0.1.0.2 (darwin226)
00:28:38 <fizruk> cwl: let's expand row1 and row2: [Row [a, b], Row [c, d]] ==> (\x y -> [x, y]) <$> Row [a, b] <*> Row [c, d]
00:29:52 <cwl_> and we want [Row [a, c], Row [b, d] ]
00:29:54 <fizruk> cwl_: on the other hand we want sequenceA [Row [a, b], Row [c, d]] to be Row [[a, c], [b, d]]
00:30:41 <fizruk> cwl_: right, so (\x y -> [x, y]) <$> Row [a, b] <*> Row [c, d]  ==  Row [[a, c], [b, d]]
00:30:54 <fizruk> cwl_: note that Row and [] have to switch places
00:31:41 <fizruk> cwl_: so how do we fix Applicative for Row in such a way that 'a' gets paired with 'b', and 'c' gets paired with 'd'?
00:32:23 <cwl_> let me try
00:32:53 <fizruk> cwl_: consider <*> first, then go to pure
00:34:44 <thimoteus> hmmm, reading some vimscript and i see the line "return b . c . a" and what i think is closer to "put the composition of the functions c and b and a into some monadic context"
00:35:09 <thimoteus> although technically i guess that's not what would happen because it's missing some parens
00:40:55 <Myrl> In writing pathfinding in Haskell, what do you suggest I should use?
00:41:02 <Myrl> s/use/do/
00:41:27 <Myrl> Rather, what are your suggestions?
00:42:18 <TheCrafter> Hello #haskell !! Can anyone tell me how can I convert a CInt to an Int ?? I'm trying to use haskell's ffi
00:42:44 <bob_twinkles> Myrl: depends on what sort of thing you want to find a path through, and why you want to do it
00:43:08 <bob_twinkles> :t fromInteger -- TheCrafter 
00:43:09 <lambdabot> Num a => Integer -> a
00:43:23 <bob_twinkles> err, brain fail
00:43:38 <bob_twinkles> :t toInteger -- TheCrafter 
00:43:39 <lambdabot> Integral a => a -> Integer
00:44:38 <TheCrafter> oh yeah that's right! CInt is still an instance of Integral
00:44:40 <TheCrafter> thanks!
00:49:57 <Myrl> bob_twinkles: A graph.
00:51:57 <bob_twinkles> Myrl: http://www.ukuug.org/events/agm2010/ShortestPath.pdf
00:52:01 <bob_twinkles> I can't find the talk that goes with those slides ATM, but its a place to start
00:53:42 <fizruk> cwl_: how's it going?
00:54:11 <Myrl> bob_twinkles: I'
00:54:15 <Myrl> bob_twinkles: I was just reading that.
00:54:25 <Myrl> bob_twinkles: It doesn't seem like for Haskell though.
00:54:29 <cwl_> fizruk: failed
00:54:58 <cwl_> Row fs <*> Row xs = Row (zipF fs xs) where zipF (f:fs) (x:xs) = f x : zipF fs xs
00:55:13 <cwl_> Got Row [[1,4,7]]
00:55:22 <fizruk> cwl_: that's fine, except missing base case for zipF
00:55:37 <fizruk> cwl_: (what if any of the input lists is empty)
00:55:39 <cwl_> zip [] _ = [] zip _ [] =[]
00:55:55 <cwl_> I have both empty list
00:57:06 <fizruk> cwl_: ok, what expression gives you Row [[1,4,7]] ?
00:57:41 <cwl_> let rs = [Row [1,2,3], Row [4,5,6], Row [7,8,9]] in sequenceA rs
00:58:04 <fizruk> cwl_: okay, let's consider a simpler case we've been using before
00:58:33 <fizruk> cwl_: sequenceA [Row [a, b], Row [c, d]]  ==>  (\x y -> [x, y]) <$> Row [a, b] <*> Row [c, d]
00:59:26 <fizruk> cwl_: here we have <$> and <*>
00:59:52 <fizruk> cwl_: we probably should test them separately to figure out where the problem is
01:00:18 <fizruk> cwl_: e.g. try Row [(+1), (+2)] <*> Row [3, 4]
01:00:47 <fizruk> cwl_: that should pair (+1) with 3 and (+2) with 4, resulting in Row [4, 6]
01:00:49 <cwl_> fizruk: Row [4, 6]
01:01:02 <fizruk> cwl_: great! now let's check <$>
01:01:44 <fizruk> cwl_: (\x -> [x]) <$> Row [1, 2]  should map (\x -> [x]) over every element in the row, resulting in Row [[1], [2]]
01:03:05 <fizruk> @src sequenceA
01:03:05 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
01:03:47 <cwl_> traverse f = List.foldr cons_f (pure [])       where cons_f x ys = (:) <$> f x <*> ys
01:04:13 <cwl_> sequenceA = traverse id
01:04:15 <fizruk> cwl_: right, there is pure used for the case of empty list
01:04:36 <fizruk> cwl_: as we know f <$> x = fmap f x = pure f <*> x
01:05:08 <fizruk> cwl_: so if <$> and <*> are working fine, there seems to be a problem with pure
01:05:18 <cwl_> pure x = Row [x]
01:05:30 <cwl_> I have this
01:05:55 <fizruk> cwl_: let's check if this is a correct implementation
01:06:59 <fizruk> cwl_: pure (+1) <*> Row [1, 2]  should apply (+1) to every element in the Row, because pure f <*> x = fmap f x, right?
01:07:21 <cwl_> fizruk: right
01:07:26 <fizruk> cwl_: with your definition pure (+1) <*> Row [1, 2] = Row [(+1)] <*> Row [1, 2]
01:07:44 <cwl_> my version is Row [2]
01:08:11 <fizruk> cwl_: right, so how do we fix pure?
01:08:46 <cwl_> pure (+1) should be Row [(+1), (+1) ...] ?
01:09:18 <radens> Who here is good at parsec? How would I introduce an else clause to parsing an if statement in this code? 
01:09:20 <radens> https://pastebin.osuosl.org/34421/
01:10:13 <cwl_> aha, I get it
01:10:31 <cwl_> it is Row [[1,4,7], [2,5,8], [3,6,9]]
01:10:31 <fizruk> cwl_: since zipF chooses the minimum length of its inputs and pure does not know the size of the future inputs...
01:11:04 <fizruk> cwl_: congratulations!
01:11:18 <cwl_> fizruk: Thanks for you step by step help
01:11:22 <fizruk> cwl_: now, this Row type is known as ZipList in Control.Applicative
01:11:57 <cwl_> fizruk: wow, I'm not aware of it
01:12:26 <fizruk> cwl_: to transpose [[a]] you can map inner lists to become ZipList, sequenceA the result and then getZipList
01:13:11 <fizruk> :t getZipList . sequenceA . map ZipList
01:13:12 <lambdabot> [[a]] -> [[a]]
01:13:23 <fizruk> sequenceA . map f == traverse f
01:13:32 <fizruk> :t getZipList . traverse ZipList
01:13:33 <lambdabot> Traversable t => t [b] -> [t b]
01:14:33 <cwl_> > getZipList . sequenceA . map ZipList $ [[1,2,3],[4,5,6],[7,8,9]]
01:14:35 <lambdabot>  [[1,4,7],[2,5,8],[3,6,9]]
01:14:51 <fizruk> > let transpose = getZipList . traverse ZipList in transpose [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
01:14:52 <lambdabot>  [[1,4,7],[2,5,8],[3,6,9]]
01:15:04 <vedosity> How does one choose what gets put on the bottom of a monad transformer stack?
01:15:23 <cwl_> > getZipList . traverse ZipList $ [[1,2,3],[4,5,6],[7,8,9]]
01:15:26 <lambdabot>  [[1,4,7],[2,5,8],[3,6,9]]
01:15:47 <tdammers> vedosity: dependencies, in a way
01:16:09 <tdammers> vedosity: also, you often have one monad in your stack that can't be a transformer (typically IO)
01:16:43 <tdammers> vedosity: in my experience, it's usually rather obvious which goes inside which
01:17:05 <vedosity> tdammers: I want to have a megaparsec parser that uses state. I have two transformers, both ParsecT and StateT
01:17:37 * hackagebot argon 0.1.0.0 - Measure your code's complexity  https://hackage.haskell.org/package/argon-0.1.0.0 (rubik)
01:20:55 <vedosity> I think either would work but I might be missing something
01:23:40 <quicksilver> vedosity: one way around you lose your state when the parse fails
01:23:53 <quicksilver> the other way arond you get state in the failure message
01:23:55 <quicksilver> but on the other hand
01:24:08 <quicksilver> it also affects whether or not the state backtracks when the parser backtracks
01:24:42 <quicksilver> vedosity: but you don't need any of this, ParsecT has state built in :)
01:25:06 <quicksilver> oh, megaparsec's version doesn't?
01:25:53 <vedosity> In Megaparsec's CHANGELOG: Introduced type class MonadParsec in the style of MTL monad transformers. Eliminated built-in user state since it was not flexible enough and can be emulated via stack of monads. Now all tools in Megaparsec work with any instance of MonadParsec, not only with ParsecT.
01:26:11 * quicksilver nods
01:26:22 <quicksilver> OK well yes it matters which way around you stack, see my comments above
01:26:39 <vedosity> So now I'm trying to figure out what it means by "stack of monads"
01:26:47 <isomorphismes> when I try to stack init I get a core dump / segfault / something
01:26:47 <isomorphismes> stack: out of memory (requested 1048576 bytes)
01:26:49 <isomorphismes> stack: out of memory (requested 1048576 bytes)
01:26:54 <quicksilver> ParsecT StateT, vedosity 
01:26:54 <isomorphismes> stack: out of memory (requested 1048576 bytes)
01:26:59 <quicksilver> is callde a stack of monads
01:27:00 <isomorphismes> oops
01:27:11 <isomorphismes> that seems like a lot, doesn't it?
01:27:13 <quicksilver> shoulds be a stack of monad *transformers* really but people just say monads
01:27:51 <vedosity> quicksilver, I figured that out after not too long but I'm wondering what the best way around is
01:28:18 <vedosity> ParsecT StateT makes more sense personally. I'm assuming that would be the way around that would backtrack state?
01:28:47 <vedosity> I don't actually think my implementation backtracks past state changes but I'd like to not rely on that implementation detail
01:29:31 <tdammers> isomorphismes: space leak somewhere would be my guess
01:32:21 <Joan152> YEE
01:33:03 <jle`> huh, got a warning for non-exhaustive pattern matches...apparently i'm not matching the case: foo _ _ = ...
01:33:10 <jle`> first time seeing that...
01:33:13 <jle`> thanks GHC, very helpful
01:33:54 <hexagoxel> it can't invert arbitrary expressions in guards, probably?
01:34:15 <Joan152> I want a function to add two numbers.
01:34:30 <hexagoxel> :t (+)
01:34:32 <lambdabot> Num a => a -> a -> a
01:34:46 <Joan152> thanks
01:34:46 <jle`> hexagoxel: not using any guards, but that's a nice catch
01:34:48 <Joan152> i'm noob
01:34:57 <jle`> > 3 + 4
01:34:59 <lambdabot>  7
01:35:02 <yalda_> Hi
01:35:09 <jle`> hi yalda_ :D
01:35:42 <yalda_> hi jle
01:37:01 <yalda_> what's going on here?
01:37:55 <hexagoxel> Joan152: parentheses around infix operators gives you functions. the inverse is ``, e.g.   xs `append` ys
01:39:49 <saparvia> Can someone tell me why the function add5 = (+) (fromIntegral 5) has the type Integer -> Integer? I would have expected it to be something more general.
01:40:04 <jle`> saparvia: what version of ghc are you using?
01:40:08 <jle`> and are you asking in ghci?
01:40:32 <jle`> you're running into the monomorphism restriction
01:40:34 <jle`> @where dmr
01:40:34 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
01:40:36 <saparvia> Yes, ghci and 7.6.3
01:40:44 <jle`> ah yeah, it's on by default on 7.6.3
01:40:53 <jle`> 7.6.3 is kinda ancient, though, for what it's worth
01:40:55 <saparvia> Aha, I see
01:41:29 <saparvia> Thanks for the hint!
01:41:39 <jle`> with the DMR on, it specializes certain polymorphic things to be monomorphic for performance reasons
01:42:03 <jle`> in ghci, it doesn't have a clue about what you want to eventually use add5 on, so it defaults to specializing to Integer
01:42:25 <jle`> ghc 7.8+ has the DMR off in ghci, so you won't run into it...you can disable it to with :set -XNoMonomorphismRestriction
01:49:47 <lpaste> vedosity pasted “Megaparsec State Stack” at http://lpaste.net/5638804709708922880
01:50:53 <vedosity> So this fails with "Could not deduce (MonadPlus m) arising from a use of ‘expr'’"
01:51:17 <vedosity> Does StateT require m to be a MonadPlus or something?
01:51:27 <vedosity> I don't understand where MonadPlus comes into play
01:54:21 <quicksilver> no, MonadParsec does
01:54:31 <quicksilver> well it requires Alternative
01:57:31 <vedosity> So MonadParsec requires StateT to be a MonadPlus/Alternative?
02:00:36 <quicksilver> no
02:00:41 <quicksilver> it requires the underlying 'm' to be MonadPlus
02:00:43 <quicksilver> (MonadPlus m, MonadParsec s m t) => MonadParsec s (StateT e m) t
02:00:59 <quicksilver> (that's the MonadParsec instance for State T from https://hackage.haskell.org/package/megaparsec-4.1.1/docs/Text-Megaparsec-Prim.html )
02:01:21 <isomorphismes> tdammers: I think so too
02:01:59 <quicksilver> as far as I can see
02:02:01 <isomorphismes> not sure what to do about it though
02:02:06 <vedosity> Ah, MonadParsec requires m be Alternative, StateT's Alternative requires m be MonadPlus
02:02:07 <isomorphismes> I'm trying to use hackage
02:02:09 <quicksilver> that essentially forces you to put StateT on top
02:02:30 <quicksilver> because the ParsecT 'inside' will give you the MonadPlus you need
02:02:55 * hackagebot typelevel 1.0 - Useful type level operations (type families and related operators).  https://hackage.haskell.org/package/typelevel-1.0 (danilo2)
02:03:25 <quicksilver> no that's not true :)
02:03:32 <quicksilver> with ParsecT on top you're always fine
02:03:41 <quicksilver> the MonadParsec instance for ParsecT requires nothing
02:03:54 <quicksilver> Stream s t => MonadParsec s (ParsecT s m) t
02:04:29 <vedosity> Ah, so I explicitly need to say ParsecT instead of using the more generic MonadParsec?
02:06:16 <quicksilver> I'm not entirely sure what you *are* trying to say in that toy example
02:06:39 <tdammers> vedosity: you need to say whichever you mean. MonadParsec is a typeclass, ParsecT is a type
02:07:55 * hackagebot typelevel 1.0.1 - Useful type level operations (type families and related operators).  https://hackage.haskell.org/package/typelevel-1.0.1 (danilo2)
02:10:07 <vedosity> quicksilver: expr runs some stateful parser expr' with an initial state. expr' will call other parsers that rely on and modify that initial state
02:12:55 * hackagebot data-rtuple 1.0 - Recursive tuple data structure. It is very usefull when implementing some lo-level operations, allowing to traverse different elements using Haskell's type classes.  https://hackage.haskell.org/package/data-rtuple-1.0 (danilo2)
02:18:24 * hackagebot convert 1.0 - Safe and unsafe data conversion utilities with strong type-level operation. checking.  https://hackage.haskell.org/package/convert-1.0 (danilo2)
02:23:25 * hackagebot prologue 1.0 - Replacement for the Haskell's Prelude, exposing more commonly used functions and patching old GHC ones to behave in the newest GHC's way.  https://hackage.haskell.org/package/prologue-1.0 (danilo2)
02:25:37 <Heather> hello, how to show " but not \"
02:27:16 <hexagoxel> Heather: use putStr or putStrLn instead of print
02:28:38 <Heather> hexagoxel I've got Data.Text.Internal.Lazy.Text
02:28:58 <Heather> hexagoxel I used to use print because I need to show it :/ but maybe show is not correct here
02:29:37 <hexagoxel> Heather: http://hackage.haskell.org/package/text-1.2.1.3/docs/Data-Text-IO.html#v:putStr
02:29:56 <hexagoxel> or unpack + the usual putStr
02:29:56 <ReinH> if you show it then you'll see escaped \"
02:30:31 <hexagoxel> http://hackage.haskell.org/package/text-1.2.1.3/docs/Data-Text-Lazy.html#v:unpack
02:32:37 <Heather> hexagoxel thanks!
02:33:22 <hexagoxel> Heather: btw you can find this stuff yourself, e.g. http://hayoo.fh-wedel.de/?query=Text%20-%3E%20IO%20%28%29 :)
02:34:40 <Heather> hexagoxel new hoogle?
02:35:46 <hexagoxel> Heather: coexisting alternative. indexes more packages than the default hoogle, but other hoogle instances are just as good i think.
02:36:01 <hexagoxel> e.g. the one on stackage.
02:38:26 * hackagebot Slides 0.1.0.3 - Generate slides from Haskell code  https://hackage.haskell.org/package/Slides-0.1.0.3 (darwin226)
02:39:56 <ttt_fff> is there a haskell library for finding minimal cost perfect matching?
02:42:32 <SK0> Is there a good way to approximately compare Doubles (in QuickCheck tests)?
02:42:49 <liste> SK0 define `approximately'
02:43:03 <SK0> accounting for floating point error
02:43:13 <CoconutCrab> (a - b) < threshhold?
02:43:16 <liste> absolute or relative?
02:43:26 * hackagebot argon 0.2.0.0 - Measure your code's complexity  https://hackage.haskell.org/package/argon-0.2.0.0 (rubik)
02:44:00 <SK0> I guess that's my question. Is there a recommended method of comparison for this?
02:45:13 <merijn> SK0: "(a - b) < epsilon" is the usual approach in any language
02:45:22 <SK0> I see
02:45:38 <merijn> SK0: But depending on what you're doing you might wanna switch to a perfect precision type?
02:45:49 <merijn> Since Haskell has some convenient ones
02:46:23 <liste> SK0 check this out https://randomascii.wordpress.com/2013/07/16/floating-point-determinism/
02:46:52 <SK0> I'm dealing with signals
02:46:55 <liste> and everything else in https://randomascii.wordpress.com/category/floating-point/ too
02:47:29 <merijn> For example, we have Ratio if your okay with only being able to handle rationals instead of reals
02:47:39 <SK0> In the end they are written to 16bit integers, so precision isn't terribly important
02:47:51 <merijn> > (2 % 5) + (3 % 5)
02:47:52 <SK0> accuracy*
02:47:53 <lambdabot>  1 % 1
02:48:07 <SK0> I cannot use rationals in most places
02:48:19 <merijn> > (1/3 :: Ratio Int) == 1/3
02:48:21 <lambdabot>  True
02:48:22 <SK0> I actually use Complex Double for most stuff
02:48:25 <merijn> Ah
02:48:41 <merijn> Then "a - b < epsilon", imo
02:48:54 <SK0> I will also look into Herbie, looks promising
02:49:26 <SK0> but for my tests I'll go with your suggestion of (a - b) < epsilon
02:49:54 <quicksilver> you may want an 'abs' in there SK0 merijn :)
02:50:12 <SK0> ye
02:50:27 <SK0> liste, nice links, reading
02:57:18 <ReinH> SK0: Maybe make your functions polymorphic and test with an instance like Rational? Unless you're testing *for* floating point error, ofc.
02:58:00 <quicksilver> Rational is a bit of a horrible type though
02:58:13 <quicksilver> it gets slower the more you use it
02:58:27 <quicksilver> that's quite a strange behaviour for a numeric type (although the reason is of course reasnoable)
02:59:43 <SK0> ReinH: perhaps
03:00:25 <ReinH> It doesn't need to be production fast, just fast to run the tests in a reasonable amount of time.
03:00:32 <ReinH> *fast enough
03:00:34 <quicksilver> that's true
03:00:48 <quicksilver> and your suggestion is reasonable.
03:21:12 <quchen> ReinH: Thanks for the new Haskell Cast! :-)
03:28:33 <Heather> I've got problem \" transforming into &quot; :/
03:32:20 <Heather> hm... maybe I should use show
03:35:16 <ArkineTP9> Hello?
03:35:50 <Heather> ArkineTP9 hi
03:36:11 <Heather> when I'm unpacking Data.Text.Lazy \" I want to get " but getting &quot; :S
03:36:37 <ArkineTP9> Hi
03:36:40 <Heather> so I need packed quote to unpack it as "
03:37:00 <ArkineTP9> Do u like utube
03:37:29 <Heather> ArkineTP9 youtube?
03:37:45 <ArkineTP9> Yea
03:37:55 <ArkineTP9> Do u 
03:37:57 <ttt_fff> WTF does this have to do with Haskell ?
03:38:05 <ttt_fff> Please go to #haskell-blah
03:38:27 <Heather> ArkineTP9 I never used to think whether I like it or not, let's say I don't
03:38:34 <ArkineTP9> K
03:40:36 <quicksilver> Heather: there is nothing in data.text which will give you &quot;
03:40:43 <quicksilver> Heather: there must be something important you aren't telling us
03:41:08 <quicksilver> like you're viewing it through an XML or HTML generation layer which is automatically escaping "s into XML entities?
03:41:10 <Heather> quicksilver hm... I'm trying to use Lucid https://github.com/chrisdone/lucid/blob/master/test/Example1.hs
03:41:41 <Heather> quicksilver and by default Html with renderText there returns Data.Text.Lazy
03:41:58 <quicksilver> right
03:42:01 <Heather> quicksilver in the end I'm doing L.unpack and putStr
03:42:05 <quicksilver> but your problem is nothign to dow ith Text
03:42:08 <quicksilver> it's to do with lucid
03:42:13 <quicksilver> lucid is a library for generating html
03:42:25 <quicksilver> in HTML you can escape " to &quot;
03:42:31 <quicksilver> and, sometimes you must.
03:42:46 <quicksilver> it's even in the example
03:42:46 <quicksilver> https://github.com/chrisdone/lucid
03:42:52 <quicksilver> "Plain text is written using the OverloadedStrings and ExtendedDefaultRules extensions, and is automatically escaped"
03:43:00 <quicksilver> example is - 123 &lt; 456
03:43:57 <ArkineTP9> ArkineTP9: [swift]: adimit: adnausea1: ahihi: aloiscochard: amontez: AndChat|79476: arahael: arianvp: aristid_: arkeet: augur: Axman6: bananagram: bcoppens: Beetny: benzrf: bernalex: bgyss: biscarch: bitemyapp: boegel: boyscared: bsmt: byorgey: ByronJohnson: bz: c_wraith: caasih: Cale: capisce: carter: carter_cloud: Chousuke: cin: cnr: cocreature: codehero: companion_cube: CosmicRa`: cschneid: cscorley: defanor: diginet: dju
03:44:00 <ArkineTP9> ArkineTP9: [swift]: adimit: adnausea1: ahihi: aloiscochard: amontez: AndChat|79476: arahael: arianvp: aristid_: arkeet: augur: Axman6: bananagram: bcoppens: Beetny: benzrf: bernalex: bgyss: biscarch: bitemyapp: boegel: boyscared: bsmt: byorgey: ByronJohnson: bz: c_wraith: caasih: Cale: capisce: carter: carter_cloud: Chousuke: cin: cnr: cocreature: codehero: companion_cube: CosmicRa`: cschneid: cscorley: defanor: diginet: dju
03:44:00 <Heather> quicksilver right, is it because ofOverloadedStrigns?
03:44:03 <ArkineTP9> ArkineTP9: [swift]: adimit: adnausea1: ahihi: aloiscochard: amontez: AndChat|79476: arahael: arianvp: aristid_: arkeet: augur: Axman6: bananagram: bcoppens: Beetny: benzrf: bernalex: bgyss: biscarch: bitemyapp: boegel: boyscared: bsmt: byorgey: ByronJohnson: bz: c_wraith: caasih: Cale: capisce: carter: carter_cloud: Chousuke: cin: cnr: cocreature: codehero: companion_cube: CosmicRa`: cschneid: cscorley: defanor: diginet: dju
03:44:08 --- mode: ChanServ set +o quicksilver
03:44:12 --- mode: quicksilver set +b *!*holoirc@*.1-3.cable.virginm.net
03:44:12 --- kick: ArkineTP9 was kicked by quicksilver (ArkineTP9)
03:44:17 <quicksilver> Heather: no.
03:44:26 <quicksilver> Heather: it is not. It is because that is what the library is designed to do.
03:44:32 <quicksilver> lucid is an HTML generation library
03:44:46 <quicksilver> part of what it does is escape characters which would be HTML special if not escaped.
03:45:10 <Heather> quicksilver I can't see in library where it's replacing quotes with &quot;
03:45:21 <quicksilver> lucid is quite a big library
03:45:34 <quicksilver> why do you care? why is replacing " with &quot; not what you want?
03:45:38 <quicksilver> it's the right thing for it to do.
03:46:13 <Heather> quicksilver there are few cases
03:46:18 <quicksilver> go on?
03:46:47 <Heather> quicksilver first case is that I'm generating templates for hakyll
03:46:57 <Heather> quicksilver and I need template specific syntax
03:47:45 <Heather> quicksilver second case is that I feel that currently it's a bit incomplete and I need to paste some stuff as plain text until I will be able to do it using lucid
03:48:05 <frerich> SK0: One extension to what merijn and CoconutCrab wrote -- comparing the absolute difference with some epsilon is a good idea, but there is no single fixed epsilon; the epsilon depends on the magnitude of the values being compared. The 'gap' between floating point numbers is not even, it gets larger as the values get larger.
03:48:19 <frerich> SK0: So for a general purpose function, that should be taken into account I think.
03:49:25 <Heather> quicksilver as far as I unerstand it could be part of blase
03:49:27 <Heather> *blaze
03:49:33 <quicksilver> Heather: yes, it is
03:49:46 <quicksilver> Heather: underneath, Lucid delegates rendering to blaze
03:50:02 <quicksilver> using things like toHtml    = build . Blaze.fromHtmlEscapedString
03:50:17 <quicksilver> as far as I can see in a 5 minute glance you can write
03:50:30 <quicksilver> termRaw "foo" "long string goes here"
03:50:41 <quicksilver> and the string will be placed - unescaped - into a <foo></foo>
03:51:00 <quicksilver> I don't currently see how to do it without introducing a wrapping tag though
03:51:59 <Heather> quicksilver wrapping tag?
03:53:20 <Heather> quicksilver easiest way will be replasing &quot back to " after render but it's just weird :/ I need specific term where I really need it
03:53:56 <quicksilver> lucid is realy not designed for producing templates
03:54:01 <quicksilver> still, I bet there is a way
03:54:09 <quicksilver> did you check the lucid issues database on github?
03:54:12 <quicksilver> or you could email the author
03:54:39 <Copperis> a bit offtopic: would a algebraic structures course be beneficial in understanding all this monad, endofunctor stuff?
03:55:19 <Heather> quicksilver I've added issue
03:55:36 <Heather> quicksilver is there bot which can eval "last seen"
03:55:56 <Heather> quicksilver on irc channel I mean
03:56:26 <cocreature> Copperis: from a theoretical perspective, it would at least make it easier to go into category theory. from a practical haskell perspective I highly doubt it
03:56:35 <quicksilver> seen chrisdone
03:56:42 <quicksilver> mauke: seen chrisdone
03:56:47 <quicksilver> apparently not :)
03:56:51 <Heather> I see
03:56:52 <mceier> !seen chrisdone
03:56:53 <quicksilver> there used to be, once upon a time.
03:57:01 <Heather> :/
03:58:22 --- mode: quicksilver set -o quicksilver
03:59:01 <ttt_fff> for writing webserver code in Haskell (SnapFramework in particular)
03:59:07 <ttt_fff> is ther ea nice way to check "I don't have space leaks" ?
04:00:13 <quicksilver> run a nice long run of your code with heap profiling on?
04:00:16 <quicksilver> and check the graph is flat?
04:01:17 <ttt_fff> I can't encode 'no space leak" as a type that GHC can check for me?
04:01:31 <ttt_fff> i guess not, as that might involve solve halting problem 
04:01:57 <merijn> ttt_fff: Pretty much :p
04:03:41 <Copperis> cocreature, so algebraic structures could be a requirement for cat. theory?
04:04:03 <Copperis> (not that cat. theory is offered at the place I'm looking at :| )
04:04:39 <merijn> Copperis: A little bit, since a lot of examples involve algebraic structures
04:04:47 <cocreature> Copperis: not really, but some sort of abstract algebra helps undestanding category theory and provide a lot of examples
04:04:47 <merijn> Copperis: Mostly stuff like monoids, lattices, etc.
04:05:11 <bernalex> ttt_fff: I've seen nice things like encoding "this computation should take less than n microseconds to run for arbitrary x" in the typesystem. that's neat.
04:05:20 <bernalex> (that wasn't the haskell typesystem though)
04:05:24 <merijn> Copperis: Incidentally, assuming you're decently familiar with haskell this is a good intro: http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
04:05:28 <Heather> quicksilver when I do termRaw I'm getting \" as \" :S
04:05:39 <quicksilver> Heather: yes, good.
04:05:45 <quicksilver> Heather: that's how it has to work.
04:05:54 <Heather> quicksilver well but I still need just "
04:05:58 <quicksilver> Heather: because it needs to do <script>foo("bar");</script>
04:06:08 <quicksilver> Heather: nah, you're being fooled by ghci now I expect
04:06:18 <quicksilver> \" is just how it looks when displayed
04:06:21 <quicksilver> try putStrLn on it
04:06:43 <Heather> quicksilver oh, yes, sorry I was using print again to test :)
04:06:59 <Heather> quicksilver yes it's okay with unpack
04:07:07 <Copperis> merijn, ok, thanks! I'll check that out
04:07:27 <Heather> quicksilver so now I only need termRaw w/o first argument :/
04:07:38 <quicksilver> yeah I didn't immediately see how to do that
04:08:03 <merijn> Copperis: The other usual recommendations are Awodey's "Category Theory", which (to me) can feel a lot like smashing your head against a brick wall, but after attempt number 8  I managed to get about 50 pages in ;)
04:08:25 <merijn> Copperis: There's also Mac Lane, which is if you prefer your brick wall covered in diamond spikes...
04:09:16 <merijn> Incidentally, most of this isn't particularly helpful for writing "real Haskell", but it's very interesting :)
04:09:42 <Heather> quicksilver for script I even can do termRawWith "script" [src_ "js/youtube.js"] ""
04:10:09 <Copperis> merijn, oh I remember a discussion about books sometime earlier. I've saved a list -> http://lpaste.net/143544 from easiest to hardest if I recall. The second book lost me with the second example
04:10:12 <Heather> quicksilver but still for template syntax I need some overhead
04:11:16 <merijn> Awodey is good, but very dense (like most math)
04:11:21 <gothos> I also like CT for the Sciences as an intro, it doesn't convey to my brain that I'm way too stupid for CT.-
04:19:48 <timrich> newbie question. I have installed haskell platform on os x. updated cabal. Trying cabal install StateVar. Fails unhelpfully, final output is cabal: ~/.cabal/logs/StateVar-1.1.0.1.log: does not exist
04:27:16 <meretrix> Anyone know how to pass a [Double] to a Java method that takes a double array as an argument using java-bridge?
04:27:31 <meretrix> It must be possible, but I keep getting missing instances..
04:28:32 <Kaligule> hi there. I am searching for a library for splitting words into syllables. Is there anything like that in haskell?
04:30:03 <sm> timrich: stack may be easier than cabal and/or HP
04:30:15 <pavonia> @hackage hyphenation  -- Kaligule
04:30:15 <lambdabot> http://hackage.haskell.org/package/hyphenation  -- Kaligule
04:30:40 <sm> timrich: but feel free to pastebin your log. The real issue is probably further up
04:31:43 <timrich> hi sm. In fact there is no other output.
04:33:41 <Kaligule> pavonia: I am amazed.
04:33:49 <Kaligule> pavonia: Thank you so much.
04:34:02 <pavonia> No problem
04:47:38 <hexagoxel> timrich: there is a trick to get more logging: use the -j1 flag
04:48:31 * hackagebot Slides 0.1.0.4 - Generate slides from Haskell code  https://hackage.haskell.org/package/Slides-0.1.0.4 (darwin226)
04:48:42 <timrich> thanks hexagoxel. I have a permission problem in ~     :) 
05:00:24 <hc> hi, i am looking for a concat function that takes a list of strings and turns them into a text
05:00:29 <hc> like this: [String] -> Text
05:00:44 <aweinstock> :t T.pack
05:00:45 <lambdabot>     Not in scope: ‘T.pack’
05:00:45 <lambdabot>     Perhaps you meant ‘BS.pack’ (imported from Data.ByteString)
05:01:11 <hc> T.pack takes a string, though, not a list of strings
05:01:29 <aweinstock> :t Data.Text.pack . concat
05:01:30 <lambdabot> Foldable t => t [Char] -> Data.Text.Internal.Text
05:01:43 <aweinstock> :t Data.Text.pack . unlines
05:01:44 <lambdabot> [String] -> Data.Text.Internal.Text
05:01:55 <hc> that concatenates the strings as strings, though... isn't that less efficient than doing the concatenation as Text?
05:02:55 <aweinstock> :t mconcat . map Data.Text.pack
05:02:57 <lambdabot> [String] -> Data.Text.Internal.Text
05:02:58 <quicksilver> it's hard to say for sure, benchmark it if you care
05:03:14 <fizruk> :t Data.Text.unlines . map Data.Text.pack
05:03:15 <quicksilver> but both will be quite fast and how much does speed matter for this part ;)
05:03:15 <lambdabot> [String] -> Data.Text.Internal.Text
05:03:32 <fizruk> aweinstock: mconcat will not insert newlines
05:05:44 <hc> well it doesn't matter too much i guess, unless the strings are hugh
05:05:46 <hc> huge even
05:06:00 <hc> in erlang there is the concept of an "iolist", a list of strings, binary strings and possibly sublists
05:06:13 <hc> i wonder if there is something similar available in haskell... or if it would even make sens
05:06:52 <hc> said iolist get concatenated to a single binary string only when needed
05:07:00 <quicksilver> probably not particularly; lazy evaluation is on your side anyway
05:07:04 <quicksilver> take a look at https://hackage.haskell.org/package/text-1.2.1.3/docs/Data-Text-Lazy-Builder.html
05:07:22 <quicksilver> but that's a much simpler interface not explicitly supporting IO, because it doesn't really need to .
05:07:33 <hc> interesting, thanks!
05:07:44 <hc> "iolist" has nothing to do with io btw ;)
05:07:49 <quicksilver> oh, sorry
05:08:04 <hc> it's explained here: http://prog21.dadgum.com/70.html
05:08:07 <Unhammer> is there a way to tell haskell to turn off -Wall for a portion of a file?
05:08:11 <quicksilver> a builder is basically a function to build a Text
05:08:17 <Unhammer> (my scratch pad at the bottom of the file =P)
05:08:31 <quicksilver> because of lazy evaluation it won't do the work until demanded
05:08:35 <quicksilver> just like your iolist
05:08:51 <hc> thanks
05:08:57 <fizruk> Unhammer: I guess no, but you should be able to turn it off for a single file
05:09:12 <quicksilver> so you can just slap <>s around to concat builders
05:09:14 <quicksilver> and not worry too much
05:09:29 <fizruk> Unhammer: then you might be able to move your "scratch pad" to another file and import the original module
05:10:23 <Unhammer> fizruk,  ok, that works …
05:19:48 <Heather> quicksilver https://gist.github.com/Heather/204a6e12f2914451bb55
05:28:12 <akegalj> I would like to create small program which will have to query some request to get an json from a server endpoint. So I am looking into something like curl in haskell. Is http package ok for this case https://hackage.haskell.org/package/HTTP ?
05:28:41 <clrnd> akegalj, I'd recommend one of: http-client, curl or wreq
05:28:57 <akegalj> clrnd: thnx, Ill take a look into those
05:29:28 <clrnd> akegalj, http-client is simple, wreq is powerful, and curl is curly
05:30:08 <akegalj> clrnd: thank you. I will try all of them to see which one suits my needs
05:36:23 <breadmonster> Hey guys.
05:37:18 * padre_angolano is looking at the NICTA course. It seems that it does not contain any learning material but the excercises. How do you teach yourself to do those exercises? Try and fail only? :-)
05:37:39 <akegalj> clrnd: do you happen to know would any of these packages be compatible on Windows? (as I don't have any experiance) Curl depends on libcurl.
05:38:57 <clrnd> akegalj, well not curl. wreq and htt-client should work, but wreq has many times more dependencies than http-client
05:39:28 <clrnd> (I've built wreq on windows fwiw)
05:39:35 <clrnd> remember to use withSocketsDo
05:39:55 <clrnd> https://hackage.haskell.org/package/network-2.6.2.1/docs/Network.html#v:withSocketsDo
05:40:48 <anohigisavay> hi. how can i know the members i imported from a module?
05:41:07 <anohigisavay> *how can i know what members i have imported from a module?
05:41:10 <akegalj> clrnd: oh, thats a great tip. Thank you. Ok, I am going to try these two now.
05:41:47 <anohigisavay> (or what members a module exports)
05:41:57 <breadmonster> Hey guys.
05:42:41 <liste> hey breadmonster
05:43:00 <breadmonster> What's up?
05:43:38 <Jinxit> what's the proper way to read a file line by line in parsec and get out the errors at the correct lines?
05:44:13 <Jinxit> the docs example with runParser only applies the parser once
05:44:18 <breadmonster> Jinxit: What I usually do is parse it line by line.
05:44:40 <Jinxit> but then the error is always "error at line 1, column x"
05:44:49 <breadmonster> something like `fileParser = many1 lineParser; lineParser = option1 <|> ...`
05:45:17 <Jinxit> ahh
05:49:59 <breadmonster> I just had an interesting idea.
05:50:14 <breadmonster> A knapsack problem based to do list.
05:54:16 <Myrl> @pl \k a -> [SBTree (k, a) []]
05:54:16 <lambdabot> flip flip [] . ((:) .) . flip flip [] . (SBTree .) . (,)
05:54:21 <Myrl> lolno...
05:54:38 <Myrl> :t []
05:54:39 <lambdabot> [t]
06:00:09 <Copperis> breadmonster, how does that work?
06:00:30 <breadmonster> Copperis: assign a deadline, a priority, and an effort level.
06:00:53 <breadmonster> Okay, actually it might be exact cover rather than knapsack.
06:01:03 <breadmonster> Either way, it's a combinatorial optimization problem.
06:01:12 <Copperis> yup, seems like it
06:01:34 <breadmonster> Except I know very little about combinatorial optimization :(
06:02:53 <Copperis> write a solver! You'll learn a lot no doubt. Check optaplanner (it's in java though) for inspiration
06:03:10 <breadmonster> Copperis: I was more looking for a textbook...
06:03:14 <breadmonster> But yeah okay.
06:10:01 <Jinxit> does it make more sense to use parsec to build a list of statements and going through them to create an AST, or to try to create the AST while parsing?
06:10:31 <breadmonster> Jinxit: Can you paraphrase? I'm not sure I got what you meant?
06:10:32 <concept3d> hi all, what is the difference between those two types 
06:10:35 <concept3d> updateCTIState :: MonadState CTIState m => Event -> m CTIMsg
06:10:43 <concept3d> updateCTIState :: Event -> State CTIState CTIMsg
06:10:48 <breadmonster> @info CTIState
06:10:48 <lambdabot> CTIState
06:11:05 <concept3d> CTIState is my own type
06:11:15 <quicksilver> the second type is concrete
06:11:20 <fizruk> concept3d: the first one is more general
06:11:22 <quicksilver> it says "precisly this monad"
06:11:23 <Jinxit> breadmonster: either parse returns a [Statements] and then I go through that to make an AST, or the parser could (I guess?) create the AST while reading the file
06:11:30 <concept3d> but I was curios of the difference of the signature
06:11:33 <obadz> With Data.Map, is there a way to ask for a submap where all keys are > k0 ?
06:11:41 <obadz> or to traverse such a portion of the map
06:11:42 <concept3d> the second one I hardcoded
06:11:46 <breadmonster> Jinxit: Oh right. What compiler are you building?
06:11:49 <concept3d> the first was deduced
06:12:00 <fizruk> :t put
06:12:02 <lambdabot> MonadState s m => s -> m ()
06:12:03 <breadmonster> concept3d: Well, the first works for any monad, it's meant for use with a monad transformer.
06:12:16 <breadmonster> concept3d: And the second is specialized to the State monad.
06:12:23 <quicksilver> any monad which supports get and put with type CTIState
06:12:24 <breadmonster> concept3d: When in doubt, use the first one.
06:12:29 <obadz> hmm looks like split
06:12:31 <Ferdirand> :t Data.Map.split
06:12:32 <lambdabot> Ord k => k -> M.Map k a -> (M.Map k a, M.Map k a)
06:12:34 <Ferdirand> yes, that
06:12:44 <Jinxit> breadmonster: it's a pretty simple compiler, significant whitespace where each line starts with a keyword
06:13:11 <Jinxit> sequence Foo:\n\tcall bar()
06:13:13 <Jinxit> like so
06:13:28 <breadmonster> Jinxit: Usually, compiler designers will use two passes, first lex and then parse, but if it's a throw away thing, I don't see what you gain from using two passes.
06:13:58 <breadmonster> Jinxit: though like parsing the token stream isn't as straightforward as I'd like...
06:14:03 <breadmonster> so I just parse in one pass :P
06:14:19 <Jinxit> well I'm not entirely sure how to do the creation of the AST while I'm parsing, type-wise
06:14:43 <concept3d> breadmonster: Ok, I see, the one I hardcoded seemed more intuitive (because of my limited knowledge). my confusion comes from the "m", I don't see where it is useful
06:15:13 <breadmonster> Jinxit: `data AST = Number Integer | Function { name :: String, Args :: [AST
06:15:17 <concept3d> breadmonster: for example I can see the CTIState is the state and CTIMsg is the result. but what about the deduced "m"
06:15:52 <breadmonster> Jinxit: `data AST = Number Integer | Function { name :: String, Args :: [AST] } | ...` and then `fileParser :: File -> AST`
06:16:19 <breadmonster> Jinxit: Basically, create an AST type and then create a parser for every different constructor.
06:16:26 <concept3d> breadmonster: if I understand correctly 'm' could be IO for instance, in my case it's identity ?
06:16:42 <breadmonster> And glue them together with (<|>)
06:16:56 <fizruk> concept3d: note the MonadState CTIState m constraint 
06:17:26 <concept3d> fizruk: I see, so the m is identity in my case ?
06:17:37 <breadmonster> Jinxit: If you're a little more principled and you have something in EBNF then the translation into parsec is almost pure substitution
06:17:49 <fizruk> concept3d: it tells you that m can't be arbitrary, but has to provide MonadState interface with CTIState (i.e. provide get/put for state of type CTIState)
06:18:12 <Jinxit> breadmonster: yeah I'm pretty much doing that except I don't keep track of the children right now
06:18:17 <Jinxit> so that should be all I'm missing
06:18:17 <fizruk> concept3d: the simplest case would be the one you've written explicitly: State CTIState
06:18:19 <Jinxit> thanks
06:18:21 <breadmonster> Jinxit: replace `|` with `<|>` and `:=` with `=` and then do the appropriate conversions.
06:18:42 <phaazon> that’s funny how I need to open hackage and look at GHC.Generics each time I want to write instances for Generic stuff haha
06:18:49 <fizruk> concept3d: when you run that computation with runState/evalState/execState, you force m to be State CTIState
06:18:56 <fizruk> :t runState
06:18:57 <lambdabot> State s a -> s -> (a, s)
06:19:09 <breadmonster> phaazon: There's some command line hoogle tool, but I've never been able to get it to work :(
06:19:14 <fizruk> :t put "hello"
06:19:16 <lambdabot> MonadState [Char] m => m ()
06:19:40 <phaazon> breadmonster: I mean, I can’t get my mind around the types in Generics
06:19:55 <phaazon> U1, D1, K1, C1, S1, :*:, :+:, there’re so many :D
06:20:10 <concept3d> fizruk: Ok, I see
06:21:59 <ph88^> what is this guy talking about https://mail.haskell.org/pipermail/ghc-devs/2015-October/010068.html ¨Foldable-Traversable-aPocalypse¨ ???
06:23:16 <Yuras> ph88^: the Great Polymorphism Catastrophe :)
06:23:24 <fizruk> ph88^: https://wiki.haskell.org/Foldable_Traversable_In_Prelude ?
06:24:12 * clrnd *sighs*
06:24:23 <merijn> ph88^: The fact that the "list only" versions of, e.g. foldr, mapM, etc. were replaced with the functions from Foldable/Traversable
06:24:26 <merijn> :t foldl
06:24:28 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
06:24:42 <clrnd> ehem, in the Prelude, they are still available somewhere else
06:24:51 <Heather> wow
06:24:54 <ph88^> and why should we care about that ?
06:25:00 <clrnd> we shouldn't
06:25:12 <raichoo> keep calm and curry on.
06:25:33 <merijn> ph88^: Well, if you think that's "no big deal" you are in the majority of people who wanted that
06:25:50 <ph88^> i dont have an opinion on it
06:25:54 <merijn> ph88^: But some people were very focal opponents because "it makes the languages more confusing"
06:26:00 <merijn> s/focal/vocal
06:27:52 <et09> have a quick question - what are the performances advantages of doing FP in haskell over perl?
06:28:06 <et09> i know there are some to many, just not sure exactly what
06:29:23 <voidzero> 1) not having to learn perl
06:29:26 <voidzero> 2) learning haskell
06:29:48 <clrnd> et09, doing FP in Perl? it should prove slower because it's not focused on FP
06:29:49 <liste> Haskell is (usually) compiled to native code
06:30:00 <voidzero> perl 6 can do FP
06:30:04 <clrnd> it has no fusion or sharing optimizations
06:30:18 <Heather> perl regex is faster XD
06:30:22 <clrnd> huh? like python or really really?
06:30:27 <voidzero> reaally
06:30:39 <clrnd> voidzero, like what?
06:30:51 <voidzero> http://examples.perl6.org/categories/euler.html
06:30:53 <ChristianS> regexes in haskell are rarely a good idea, and rarely needed
06:31:11 <Heather> ChristianS why?
06:31:18 <voidzero> http://examples.perl6.org/categories/euler/prob016-grondilu.html
06:31:48 <ChristianS> Heather: because haskell is so expressive that you usually don't need them
06:31:51 <liste> Heather parser combinators are more powerful and easier to use
06:31:59 <merijn> Heather: Because parser combinators are more expressive, easier to read and easier to understand
06:32:08 <clrnd> yet has a while and a for http://examples.perl6.org/categories/euler/prob004-unobe.html
06:32:09 <Heather> liste easier? :D doubt
06:32:13 <tdammers> Heather: because writing full-fledged parsers in Haskell isn't much harder, if at all, and the downsides of regular expressions aren't worth it
06:32:23 <clrnd> that's just HOF, ruby has those
06:32:35 <tdammers> also, parser combinators are type safe, regular expressions aren't
06:32:49 <voidzero> clrnd, well, i'm just repeating what i read on hacker news a few weeks ago
06:32:53 <merijn> tdammers: You can easily have typesafe regexes
06:32:55 <voidzero> but at least i'm honest about it!
06:33:01 <clrnd> ajjajaja
06:33:03 <merijn> tdammers: Regexes are just a subset of parser combinators
06:33:18 <tdammers> merijn: well, on some level, sure
06:33:32 <clrnd> "read it on HN" is the new "read it on Slashdot"
06:33:52 <tdammers> merijn: but your typical regex works only on character streams (or byte streams, as the case may be), and only returns match objects
06:33:53 <liste> Heather is "\\d+\\s*" really more intuitive than "some decimal *> many space" to you?
06:34:28 <tdammers> such decimal *> many space <?> "wow"
06:34:35 * voidzero claps
06:34:56 <merijn> Anyone know if there's library like ansi-wl-pprint but that supports 256 colour terminals?
06:34:57 <Heather> liste dpends, but perl will work faster I think there :P that was my point
06:35:18 <tdammers> Heather: citation needed
06:35:52 <clrnd> perl will work faster for imperative stuff ofc
06:35:56 <clrnd> (and maybe not)
06:36:34 <ChristianS> clrnd: in almost all cases perl will be slower, thought there are a few exceptions
06:36:48 <tdammers> being fast isn't perl's niche anyway
06:36:59 <ChristianS> indeed
06:37:10 <breadmonster> clrnd: What's wrong with slashdot?
06:37:13 <Heather> well... it's very fast
06:42:19 <clrnd> breadmonster, meh I just can't enjoy it, personally
06:43:02 <breadmonster> clrnd: It's really not that bad...
06:50:30 <jophish> What's people's opinions on having tests which are implied by other tests, for example testing that for some Num type T: Sum T follows the Monoid laws, and also that for any T t: t + 0 = t
06:50:44 <jophish> the second test follows from the first, so it is necessary?
06:51:23 <jophish> A better example might be a test file filled with trigonometric identities, it only takes a handful to prove all the rest
06:51:50 <Myrl> Why does Num not imply Enum?
06:52:12 <jophish> Myrl: there are types for which one can write a Num instance but not an Enum instance
06:52:20 <quicksilver> Myrl: Doubles aren't enumerable. Or no more more enumerable than every single type, anyway
06:52:34 <quicksilver> bad example since Double does actually have a Num instance.
06:52:39 <quicksilver> Enum
06:52:42 <jophish> Myrl: a nice example of this is Complex
06:53:02 <quicksilver> I think the honest answer is that Enum is at least 50% about ranges, and ranges don't work for Complex
06:53:03 <Myrl> quicksilver: Ah, true.
06:54:10 <Myrl> Hmmm
06:54:13 <Myrl> How about integral types?
06:56:33 <phadej> enum instance for Double is a bit controversial
06:57:04 <phadej> useful so you can write [1.0..10.0]
06:57:07 <Myrl> phadej: Since they're not exactly infinite?
06:57:09 <Myrl> Oh.
06:57:30 <jophish> > [0,0.1..1]
06:57:31 <lambdabot>  [0.0,0.1,0.2,0.30000000000000004,0.4000000000000001,0.5000000000000001,0.600...
06:57:32 <Myrl> How about Integral?
06:57:32 <phadej> otherwise I don't know why you'd want to use it
06:57:36 <fizruk> > [1..10] :: [Double]
06:57:37 <lambdabot>  [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
06:58:08 <jophish> Sometimes it would be nice if [1.0,2.0] was a list of every double in that range
06:59:02 <Myrl> This is a somewhat stupid question, why don't integrals have show type? :P
06:59:07 <Myrl> Errr..
06:59:13 <Myrl> you know what I mean.
06:59:20 <phadej> Show a => Integral a ?
06:59:28 <Myrl> Yes.
06:59:51 <Myrl> Wait, am I misunderstanding something here?
07:00:05 <jophish> Myrl: most Interals you'll use do have an instance of Show, but again, there are Integrals which can't be shown
07:00:10 <Taneb> Is it a rule that cycle . cycle === cycle?
07:00:16 <Myrl> jophish: Such as?
07:00:39 <quicksilver> actually all integrals had show until rather recently
07:00:42 <merijn> Taneb: cycling an infinite list should be the same as the original list, so modulo potential space/performance loss, yes
07:00:44 <jophish> Myrl: (a -> Int) for example
07:00:51 <Myrl> Ah.
07:00:58 <quicksilver> haskell2010 specifies that they should
07:01:06 <quicksilver> haskell2010 says all Num instances should have Show and Eq
07:01:11 <merijn> Taneb: The semantics of cycle are equivalent to "infinitely appending a list to itself", clearly appending to an infinite list is a no-op, semantically
07:01:18 <quicksilver> but GHC has moved away from that since 7.4 (?) 
07:01:19 <Myrl> quicksilver: Oh cool.
07:01:20 <phadej> jophish: Integral does have `toInteger` though
07:01:25 <jophish> I've got to walk to the dog now. laters
07:01:30 <phadej> so you can do show . toInteger
07:01:45 <jophish> phadej: In my opinion it shouldn't :)
07:02:27 <phadej> well, there are n+1 opinions on how numeric typeclasses should be in Haskell.
07:06:23 <et09> well i was reading that perl has high overhead for fn calls 
07:06:35 <et09> oh sry convo was far in scrollback
07:08:49 <phadej> et09: yes, that is the problem with almost any interpreted language.
07:09:14 <merijn> phadej: That's not true
07:09:23 <merijn> phadej: It's perfectly possible to make interpreted languages fast
07:09:36 <quicksilver> he said 'almost' any not 'every' :P
07:09:54 <quicksilver> there are certainly some general reasons why interpreted languages often have slow fn calls
07:09:57 <merijn> quicksilver: You can even make every interpreted language fast
07:10:36 <merijn> quicksilver: I've got some pointers for you to cool stuff, but that's more for -blah :)
07:12:43 <quicksilver> sure. I think you should read phadej's comment as "that is the problem for almost every interpreted language implementation"
07:13:09 <quicksilver> it's certainly true that python, perl and ruby have pretty hefty fn call overhead
07:13:35 <phadej> merijn: do you have in mind something like tracing jit or so?
07:13:41 <phadej> ... or something similar?
07:13:59 <merijn> phadej: JIT with on the fly specialisation
07:14:16 <phadej> merijn: yes, that is cool. But quite hard to get right.
07:14:16 <merijn> phadej: If you're in #haskell-blah I just linked some neat things
07:14:23 <merijn> phadej: Not anymore!
07:14:31 <phadej> merijn: i'm not there
07:14:41 <merijn> phadej: I'll repeat in PM
07:14:47 <phadej> thanks
07:21:54 <breadmonster> merijn: link it to me too?
07:23:41 <pmade> Is it possible to write a FromJSON instance for this type: data T a = { one :: Int, two :: a Int}
07:24:20 <phadej> constrained by 'FromJSON (a Int) =>' yes.
07:25:03 <pmade> phadej: If I write that constraint GHC gives me an error.  Do I need to enable flexible instances for that to work then?
07:25:42 <phadej> pmade: probably yes. Don't remember by heart. If you really want to avoid extensions, you can use a approach like in http://hackage.haskell.org/package/prelude-extras
07:26:02 <pmade> phadej: Thanks!
07:26:44 <phadej> i.e. define class FromJSON1 f where fromJSON1 :: FromJSON a => Value -> Parser (f a)
07:28:31 <cheater> hello
07:29:25 <cheater> is there a particularly efficient way to present autocompletion options from a database of maybe 1M strings of up to 20 characters? how would I structure the database so that it presents as little load as possible at scale?
07:30:21 <merijn> cheater: Depends, is the question about scaling large queries or is it just "I don't know an efficient data structure for approximate lookup"?
07:31:06 <merijn> cheater: Do you plan to update/mutate the database?
07:31:27 <cheater> i don't know what you mean by "large" - in the end you are searching for one of the entries, but until you choose you should be given about 10 autocompletion / fuzzy search results at a time.
07:31:32 <cheater> yes
07:31:49 <cheater> but the writes will be at a rate much lower than reads.
07:32:09 <merijn> cheater: For fuzzy lookup in general you want a class of datastructures called "metric trees" for strings specifically you'll want a trie (also known as radix tree, prefix tree, etc.)
07:32:22 <cheater> is a trie a metric tree?
07:32:44 <merijn> Not quite
07:32:56 <merijn> It's less general than a true metric tree
07:33:06 <cheater> i would like "merin" to also find "merijn" though
07:33:09 <merijn> A metric tree would let you also autocorrect/complete past typos
07:33:17 <merijn> Ok, then tries aren't general enough
07:33:44 <merijn> cheater: https://cs.stackexchange.com/questions/2093/efficient-map-data-structure-supporting-approximate-lookup
07:33:57 <cheater> so tries just let you search everything that strictly has a specific prefix as the one given?
07:34:19 <cheater> what metric would i use - just typical edit distance?
07:34:34 <merijn> cheater: Levensthein distance usually
07:34:48 <cheater> hmm, isn't that the same as edit distance?
07:35:09 <merijn> cheater: Levenshtein is a specific definition of edit distance
07:35:21 <merijn> cheater: There are many equally valid specifications of "edit distance"
07:35:28 <cheater> what if I would like to apply some transformations - say, use vocalization to find things that sound similar. Say marrying and merijn. Would I just store a second metric tree with the strings transformed into that space?
07:35:30 <merijn> but usually people intend Levenshtein, yes
07:35:51 <merijn> cheater: Well, you'd be way off since those two don't sound remotely the same ;)
07:36:28 <cheater> they can with the right (wrong) vocalizations - i'm sure there's an accent where marrying sounds the same as merijn according to someone who doesn't know how to pronounce it
07:36:40 <merijn> cheater: Yeah, I'd keep a seperate tree for that. Or define a combined metric that includes both transformation and edit distance and then average them with some weight
07:36:57 <cheater> OK
07:37:14 <merijn> And yes, tries are strictly for looking up using a strictly matching prefix (but they're VERY efficient for that :))
07:37:34 <cheater> would you say what is described in that link is the optimal solution?
07:38:17 <merijn> I would say there's a bunch of decent solutions in that link, but for optimal it depends a lot more on details like 1) how often do you update 2) how big is the dataset 3) any restrictions on compute time, etc.?
07:39:09 <merijn> From then on it's probably time to hit the papers :p
07:40:49 <nshepperd> you can search in a trie by edit distance with a kind of best-first search, I programmed something like that once
07:40:50 <Hudawuy> how do i pattern match on a list of strings and than concatenate the first string of the list with another string
07:41:16 <merijn> Hudawuy: So you want to match a list inside a list?
07:41:32 <Hudawuy> yeah
07:41:33 <cheater> at n=1M d=20 I am looking at 1M^(c*sqrt(20)) which is maybe 1M * 1M, so 1 TB of space. That is a lot. I can see there would be a good reason to compact the data.
07:41:42 <nshepperd> but the running time (and maybe the space?) goes as O(e^(edit distance)) or something like that
07:41:47 <merijn> > case [[1,2],[3,4]] of ((x:xs):ys) -> (x, xs, ys)
07:41:48 <lambdabot>  (1,[2],[[3,4]])
07:41:50 <tsahyt> When explaining type classes to someone, is it didactically wrong to say "they're kind of like interfaces in OOP"?
07:42:07 <LangeOortjes> Is there a way to curry the minus operator by applying its left operand, e.g. I can do (/10) 100 to obtain 10.0 but I cannot obtain 90 by (-10) 100
07:42:10 <merijn> tsahyt: There's a few important differences to interfaces
07:42:18 <cheater> the compute time would be dictated by UX, you would want at least a similar latency to say the google search box.
07:42:21 <merijn> LangeOortjes: You want subtract
07:42:26 <merijn> :t subtract
07:42:27 <lambdabot> Num a => a -> a -> a
07:42:33 <cheater> the size is 1M 20 char records, as a guesstimate.
07:42:54 <merijn> LangeOortjes: It's a bit annoying that minus operator vs slicing is ambiguous, so subtract was created to solve the ambiguity
07:42:59 <merijn> > subtract 3 5
07:43:00 <tsahyt> merijn: Of course, but I found that to get an OOP programmer to understand the basic type classes, interfaces are a decent analogy. I was wondering where it breaks down.
07:43:01 <lambdabot>  2
07:43:21 <quicksilver> tsahyt: I would say it is not a *completely* false analogy but you are setting them one hell of a trap.
07:44:05 <quicksilver> tsahyt: I would talk about them as a way of doing function overloading in a way the type-checker can understand (and check)
07:44:06 <merijn> tsahyt: Be sure to point out the difference: i.e. multiparam typeclasses, polymorphic values, polymorphic result, and the fact that "Eq a => a -> a -> Bool" is very different from "bool foo(Eq a, Eq b)" (since 'a' and 'b' can be different instance of Eq)
07:44:09 <tdammers> tsahyt: one thing where they fall apart is when you notice that interfaces produce runtime polymorphism, whereas typeclasses guard compile-time polymorphism
07:44:40 <merijn> cheater: You're quickly running into "tricky HPC territory" here ;)
07:45:02 <tsahyt> Those are all good points, thank you. I'll be sure to point that out.
07:45:29 <cheater> well, a 1TB size dataset fits in ram, so it's not even big data.
07:45:36 <merijn> tsahyt: Bounded with minBound/maxBound is a good example of polymorphic values
07:45:38 <merijn> cheater: :)
07:45:46 <merijn> cheater: HPC doesn't need big data :p
07:45:52 <LangeOortjes> merijn: Roger, no way to use the terseness of the minus operator then, I was hoping that separating the operator and its operand by a space would do the trick but alas.
07:46:31 <merijn> LangeOortjes: It's that or using the ocaml approach of having a different operator for negation and subtraction, which is sucky too :)
07:46:33 <cheater> a 1TB ssd costs $500. 1TB of ram sticks costs $10k.
07:46:54 <merijn> cheater: You could buy a nice big SPARC box from Oracle ;)
07:47:02 <merijn> 1024 hardware threads, 5TB RAM
07:47:16 <cheater> there will obviously be load spikes according to favorism, so you could probably make do with ram on the order of a few GBs.
07:47:25 <tdammers> merijn: should be just enough for minecraft
07:47:39 <cheater> but does Haskell compile properly to sparc?
07:47:45 <cheater> and HalVM?
07:47:56 <merijn> cheater: This is the kinda territory where you want to optimise for disk access and use mmap to access your data structure and let the OS handle your paging
07:47:57 <tsahyt> Finally I can create a multiple TB spaceleak
07:48:22 <merijn> tsahyt: I've had (ex)colleagues get 4TB core dumps...takes a while to get gdb to start, then ;)
07:48:40 <cheater> I can see the point in using a Linux or BSD for a server that is very slow to start up anyways.
07:48:51 <tsahyt> Ouch. Can gdb even stream those things from disk or do you actually need that much RAM for it?
07:49:02 <merijn> tsahyt: dunno, tbh?
07:49:30 <tsahyt> A really big swap partition and lots of time would also work
07:49:44 <cheater> no, it would not work
07:50:04 <tdammers> finding a job in web dev would also work
07:50:05 <cheater> that's like saying having a larger fridge is the same as having a fridge in a shop in another city while you live in the mountains
07:50:24 <tdammers> drupal comes to a grinding halt long before you get anywhere near 4 TB worth of data
07:51:24 <Lokathor> cheater, i'm sorry are you saying that 1TB isn't big because it fits into some people's RAM?
07:51:26 <tsahyt> cheater: For certain values of work.
07:52:29 <cheater> Lokathor: what will $10k of dev time buy you?
07:53:25 <Lokathor> i've no idea at all
07:53:26 <nshepperd> about a month to figure out how to use mmap?
07:53:36 <cheater> there you go
07:53:53 <cheater> so even with such a positive estimate, you still get an inferior technology
07:54:17 <nshepperd> I don't think it actually takes a month to figure out how mmap works
07:54:36 <Lokathor> what does the 10k dollars have to do with it?
07:54:52 <cheater> me either. But additional complexity related to you using a wheelbarrow instead of a race car will easily eat up that 1 month of dev time over the 5 years your code base will live.
07:55:02 <cheater> Lokathor: that's how much 1TB ram cost a year ago.
07:55:02 <nshepperd> Lokathor: because you can buy 1TB of ram for $10k, apparently
07:55:37 <Lokathor> I guess i'm too "end user" oriented in my approach
07:57:57 <cheater> once you start thinking in terms of budget, expensive toys become really cheap
07:58:46 <nshepperd> or once you start thinking in terms of companies that have more money than time, anyway
07:59:05 <nshepperd> I won't be personally buying a $10k compute node any time soon
07:59:18 <cheater> related: http://yourdatafitsinram.com/
07:59:39 <Lokathor> I'd guess that the average end user has a laptop with 100 - 500 gb of hdd or sdd space, and then maybe an external 1TB drive, and no budget to spend on new computer stuff :3c
08:00:15 <tsahyt> Interesting site. It links me to a 10k Dell server after specifying that I have 7 bytes of data
08:00:42 <cheater> yeah :)
08:00:48 <Lokathor> tsahyt, you couldn't possibly spend less than 10k on a computer, waste of time to buy less
08:00:57 <tsahyt> Lokathor: HDDs have been getting a lot larger in recent years. I wouldn't be surprised if the average user had about 3TB of space overall these days
08:01:20 <tdammers> sheer size is the only thing on which hdd's can still compete these days
08:01:33 <davean> tsahyt: Do people still have HDDs normally?
08:01:41 <tdammers> if you need no more than 128 GB, you're better off buying an SSD
08:01:51 <cheater> SDDs have replaced HDDs in all cases I know of.
08:01:52 <davean> Everything i see these days uses SSDs except sometimes an extra bulk drive
08:01:57 <cheater> SSDs.
08:01:59 <tsahyt> davean: I actually don't have anything but HDDs. About 18TB or so in total
08:02:04 <tdammers> budget laptops still have hdds
08:02:16 <cheater> right, but they're not servers
08:02:16 <Lokathor> tsahyt, i dunno, how rich are the people you know? with all these new laptops? Most folks I know are in the "poor college student or soon to be one" age bracket
08:02:20 <tdammers> 500 GB HDD is still cheaper than 500 GB SDD
08:02:40 <cheater> what if you additionally count the electric power it uses?
08:02:44 <tsahyt> Lokathor: Not particularly rich, just data hungry. A 3TB HDD is about 110€ these days
08:02:49 <cheater> things might be different then.
08:03:10 <Lokathor> tsahyt, but that's a desktop price, i'm sure
08:03:12 <cheater> 3TB of SSD is only about 10x as much.
08:03:22 <cheater> probably not worth the effort.
08:03:41 * hackagebot configifier 0.0.6 - parser for config files, shell variables, command line args.  https://hackage.haskell.org/package/configifier-0.0.6 (MatthiasFischmann)
08:03:44 <tsahyt> Lokathor: Yes of course, it's not enterprise grade
08:03:51 <tsahyt> I was speaking of end users
08:04:13 <Lokathor> that much space in a laptop will be much more than a desktop though, i imagine
08:04:24 <Lokathor> haven't looked closely in a while i admit
08:05:02 <tsahyt> As far as I can see there are no 2.5" HDDs over 2TB
08:05:18 <cheater> no, and it's unlikely there will be any
08:05:37 <tsahyt> But a WD Green Mobile with 2TB is about €120 it seems, so there's that for your laptop storage needs
08:06:07 <tsahyt> cheater: Why not?
08:06:10 <cheater> not sure why you would inflict an hdd on a user
08:06:23 <tsahyt> Better TB/price ratio
08:06:56 <cheater> tsahyt: because the expensive SSDs are the high performance ones, whereas cheap stuff uses single-cheap deals not different from an SD card
08:07:09 <cheater> so there isn't really much of a space for laptops with HDDs any more.
08:07:24 <c_wraith> If you want 3TB of local storage, there are no cheap SSD options. 
08:07:43 <cheater> it is assumed that any time you need terabytes of personal data you'll be accessing it somewhere you might have an USB drive anyways.
08:08:01 <cheater> your desk at work, your couch at home, etc.
08:08:20 <Lokathor> you'll probably not need it all at once though
08:08:25 <cheater> you're not going to be accessing all episodes of star trek at once while on the bus.
08:08:31 <Lokathor> probably a movie or other thing  you stream to your dosplay
08:08:32 <Lokathor> display*
08:08:41 <tsahyt> cheater: I might want to do just that, now that I've configured xmonad on my laptop
08:08:43 <cheater> at which point you just copy a few over for the duration of the trip to work.
08:10:02 <tsahyt> On a full HD display I'd get about 10x6 pixels of screen space per episode. Might be an interesting experience.
08:10:33 <cheater> another reason to purchase a retina macbook then
08:10:51 <tsahyt> But yeah, I see your point. I hardly use my laptop anymore, and when I did, it was my only machine, so having a lot of storage space was the right thing to do back then.
08:11:57 <tsahyt> Now I keep most of my data in cold storage on a RAID full of HDDs, until I find the time (and money) to set up a decent homeserver. Either way, I'm fully satisfied with HDDs. It's not like I ever really thought that I *need* to buy an SSD now for performance reasons
08:12:36 <tsahyt> On a sidenote, the drive on the machine I'm sitting on has a hybrid HDD, so that might have something to do with it being fast enough for me
08:13:15 <haskell200> hello?
08:13:18 <tsahyt> Hello
08:13:47 <haskell200> hi,uh im just looking around online looking for some help with haskell.dunno if im in the right place
08:14:03 <tsahyt> You are. Just go ahead and ask your questions
08:14:56 <haskell200> ok thanks!well im a beginner and  im just trying to wrap my head around the syntax with writing functions
08:15:13 <merijn> oh, bollocks...
08:15:55 <Copperis> haskell200, oh yeah, you have quite some choices
08:16:11 <merijn> Code not working because I was naively deriving Eq on a type that didn't have the Eq behaviour I wanted and then spent an hour to figure this out >.>
08:17:41 <haskell200> and i just dont understand it,especially since im coming from c++.I have some functions i have to write for hw and i just need some help with that
08:17:44 <tsahyt> Talking about Eq instances, are they supposed to satisfy transitivity, symmetry, and reflexivity?
08:18:08 <merijn> tsahyt: Yes
08:18:22 <merijn> But sometimes you don't want that, like me now >.>
08:18:59 <tsahyt> merijn: As far as I can see, the docs don't actually specify that. Why would you want an Eq instance that doesn't define an equivalence relation by the way?
08:19:18 <merijn> i.e. I don't want equality of my AST branches to depend on the source annotation in the nodes
08:19:54 <tsahyt> Yes that makes sense, but I think that such an instance would still be an equivalence relation, or not?
08:20:21 <Copperis> haskell200, have something more specific in mind? http://learnyouahaskell.com/syntax-in-functions this seems a good place to read upon function syntax
08:21:02 <phadej> can someone shortly explain what is difference between Data.Promotion.Prelude and Data.Singletons.Prelude in singletons library?
08:22:14 <phadej> rubber duck effect: Modules in Data.Promotion namespace provide functionality required for function promotion. They mostly re-export a subset of definitions from respective Data.Singletons modules.
08:25:34 <cheater> merijn: thank you for your help
08:26:13 <merijn> cheater: np
08:29:15 <quicksilver> tsahyt: you're right, it would still be an equivalence relation.
08:29:55 <quicksilver> since not many functions depend on the existence of Eq instances, the consequences of lawlessness are not so severe
08:30:15 <quicksilver> but you can get confusing 'nub' and 'group' if your Eq is not an equivalence relation
08:30:55 <quicksilver> > groupBy (<) [1,2,3,4,1,2,3,1,2,3]
08:30:57 <lambdabot>  [[1,2,3,4],[1,2,3],[1,2,3]]
08:31:15 <quicksilver> this behaviour is out-of-spec. Does it even work consistently? exercise for the reader.
08:34:16 <hodapp> hrpmh. Trying to use stack-mode and stack-ide in Emacs, and whenever I attempt anything, Emacs just stalls
08:34:35 <trumpler> so what kind of chatroom is this ?
08:35:12 <hodapp> trumpler: It's an IRC channel on Freenode for the Haskell programming language.
08:36:43 <trumpler> oops . so I better leave before someone throws my ass out
08:37:22 <MarcelineVQ> I miss trumpler
08:39:01 <hodapp> o_O
08:39:07 * hackagebot MagicHaskeller 0.9.6.4.4 - Automatic inductive functional programmer by systematic search  https://hackage.haskell.org/package/MagicHaskeller-0.9.6.4.4 (SusumuKatayama)
08:39:09 * hackagebot ghc-typelits-extra 0.1 - Additional type-level operations on GHC.TypeLits.Nat  https://hackage.haskell.org/package/ghc-typelits-extra-0.1 (ChristiaanBaaij)
08:44:07 * hackagebot lens-prelude 0.1.0 - Alternate prelude that exports lens combinators  https://hackage.haskell.org/package/lens-prelude-0.1.0 (andrewthad)
08:47:38 <humanoyd> Would it be possible to define a Monoid instance for https://hackage.haskell.org/package/hspec-core-2.2.0/docs/src/Test-Hspec-Core-Spec-Monad.html#SpecM?
08:49:35 <Cale> humanoyd: Probably many different ones.
08:52:09 <Cale> humanoyd: For any monad M, you can either define an instance Monoid (M ()) where mempty = return (); mappend = (>>), or you can define a lifting instance:  instance Monoid w => Monoid (M w) where mempty = return mempty; mappend = liftM2 mappend
08:53:31 <Cale> (the latter is probably a better option in general, as () is a monoid in a trivial way anyhow)
08:54:09 <hodapp> grrrr. Even chrisdone's stock Emacs config for stack-ide & stack-mode is stalling when I try to do anything
08:55:23 <humanoyd> Cale: Thanks, I'm not really familiar with Hspec, but wouldn't it make sense to have (<>) == (>>) for Spec?
08:56:29 <ggVGc> to use quasi quotation I essentially have to implement my own parser right?
08:58:09 <happyfeet> hi, i need a function that transforms a input file like this: http://pasted.co/fbd673b8/fullscreen.php?hash=8aeccd9426d8941f57b7b7681a6e1516&toolbar=true&linenum=false
08:58:11 <quicksilver> the reason that instance isn't given generically is, presumably, that some specific Monad also have other natural Monoid instances
08:58:20 <happyfeet> any suggestions?
08:58:20 <quicksilver> List in particular
08:58:38 <quicksilver> looks easy to me happyfeet 
08:58:43 <quicksilver> anything you've tried so far?
08:59:07 <happyfeet> i have the file converted to a list os lists
08:59:13 <happyfeet> (each line is a list)
08:59:47 <vektor> https://hackage.haskell.org/package/rosezipper-0.1/docs/Data-Tree-Zipper.html - now, I might be blind here, but... I can't see a function to add a child to the node I'm currently focused on.
08:59:52 <quicksilver> do you have an idea for the algorithm you're going to use, happyfeet ?
08:59:59 <Cale> humanoyd: I don't know.
08:59:59 <quicksilver> even explained in english, say?
09:00:25 <happyfeet> i was thinking ok remove a "#" when all the top, bottom and side are all "#"
09:01:02 <quicksilver> happyfeet: sounds good.
09:01:07 <quicksilver> I don't think it's quite right but it's a good start.
09:01:23 <quicksilver> so the problem with list of lists is it's a bit of pain accessing your neighbours
09:01:33 <quicksilver> I'd do something which lets you use (x,y) coordinates
09:01:52 <quicksilver> vektor: insertDown{First,Last,At} ?
09:02:09 <Cale> Map (Integer,Integer) Bool  or  Map (Integer,Integer) Char  might be better
09:02:16 <happyfeet> how can i use the coordinates so?
09:02:20 <Cale> An array could also work
09:02:57 <tsahyt> @hackage grid
09:02:57 <lambdabot> http://hackage.haskell.org/package/grid
09:03:05 <vektor_> client just crashed.
09:03:25 <tsahyt> happyfeet: It might be overkill, but you could take a look at the grid package
09:03:42 <happyfeet> i am looking at it right now
09:03:48 <vektor_> I think setTree should work...
09:04:24 <vektor_> Though I need to bodge a bit.
09:04:32 <happyfeet> setTree or  grid package?
09:04:43 <Cale> quicksilver: Well, not only are there other instances, but trying to write something like  instance (Monad m, Monoid w) => Monoid (m w)  will immediately put you into overlapping instances hell, because this instance head matches any type application whatsoever
09:07:12 <cocreature> we don't have nested guards, right?
09:07:34 <joobus> hola peeps.  I'm having trouble wrapping my head around monad transformers.  I understand what they are for, but I'm having trouble getting started.  First, I'd like to write a Snap server, but have no idea how to go about logging.  In imperative languages, I like to be verbose with my traces, but I'm having trouble getting started in haskell.  Is there some recommended example code you can point me to?
09:09:22 * hackagebot clash-prelude 0.10.2 - CAES Language for Synchronous Hardware - Prelude library  https://hackage.haskell.org/package/clash-prelude-0.10.2 (ChristiaanBaaij)
09:09:24 * hackagebot clash-lib 0.6.2 - CAES Language for Synchronous Hardware - As a Library  https://hackage.haskell.org/package/clash-lib-0.6.2 (ChristiaanBaaij)
09:09:26 * hackagebot clash-systemverilog 0.6.2 - CAES Language for Synchronous Hardware - SystemVerilog backend  https://hackage.haskell.org/package/clash-systemverilog-0.6.2 (ChristiaanBaaij)
09:09:28 * hackagebot clash-verilog 0.6.2 - CAES Language for Synchronous Hardware - Verilog backend  https://hackage.haskell.org/package/clash-verilog-0.6.2 (ChristiaanBaaij)
09:09:30 * hackagebot clash-vhdl 0.6.2 - CAES Language for Synchronous Hardware - VHDL backend  https://hackage.haskell.org/package/clash-vhdl-0.6.2 (ChristiaanBaaij)
09:11:49 <vektor> happyfeet: I wasn't referring to your problem
09:12:13 <happyfeet> oh ok vektor , but BTW what do u recommend for my problem?
09:12:29 <vektor> I wasn't quite following.
09:13:48 <happyfeet> this:
09:13:49 <happyfeet> http://pasted.co/fbd673b8/fullscreen.php?hash=8aeccd9426d8941f57b7b7681a6e1516&toolbar=true&linenum=false
09:14:09 <happyfeet> vektor
09:14:32 * hackagebot clash-ghc 0.6.2 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.6.2 (ChristiaanBaaij)
09:16:01 <vektor> replace the "#" with " " whenever all surrounding tiles are either a # or outside the border..?
09:16:38 <SiIky> anyone knows Jośe Bernardo Barros (aka JBB)?
09:16:55 <vektor> or - keep the # when there was one to begin with and there's a ' ' nearby.
09:16:58 <vektor> same thing
09:17:31 <merijn> Whoo!
09:17:39 <merijn> "> Cons Bool True (Nil Bool)"
09:17:42 <merijn> " :: List Bool"
09:17:54 <merijn> My type checker can succesfully do recursive parameterized ADTs :>
09:18:04 <merijn> Well...presumably, anyway
09:18:07 <monochrom> congrats
09:18:21 <merijn> I really need to refactor and check it to make sure it isn't broken someway :p
09:19:09 <merijn> Also, despite the paper saying it's "easy" to ban type level recursion, I'm not entirely sure it isn't currently allowing type level recursion anyway
09:24:52 * hackagebot wai-thrift 0.0.1.2 - Thrift transport layer for Wai  https://hackage.haskell.org/package/wai-thrift-0.0.1.2 (yogeshsajanikar)
09:24:54 * hackagebot wai-thrift 0.0.1.3 - Thrift transport layer for Wai  https://hackage.haskell.org/package/wai-thrift-0.0.1.3 (yogeshsajanikar)
09:26:18 <orion> Will stack work on FreeBSD?
09:29:24 <sm> orion: good question, it's not mentioned
09:29:25 <tojans> how can I convert from `IO (m a)` to `m (IO a)` ?
09:30:13 <sm> orion: but almost certainly yes, it's a haskell program you can install with cabal
09:30:23 <tojans> (or is that impossible?)
09:30:39 <sm> tojans: sequence
09:30:57 <sm> eh.. sorry, ignore me
09:31:27 <tojans> sm: found that one on hoogle too
09:33:34 <tojans> i'd assume it would be something with mapM ?
09:35:26 <tojans> sorry, I meant like mapM
09:37:05 <obadz> I don't know what it's possible
09:37:17 <obadz> tojans: how would you write IO [a] -> [IO a] ?
09:38:25 <obadz> or even IO (Maybe a) -> Maybe (IO a)
09:38:29 <tojans> obadz: here's what I'm trying to achieve: http://pastie.org/10498012
09:38:29 <obadz> that implies exiting IO
09:38:34 <obadz> which is impossible..
09:38:46 <obadz> s/exiting/escaping/
09:39:27 <tojans> obadz: context why I need it: https://haskell-servant.github.io/tutorial/server.html#natural-transformations
09:39:36 <obadz> tojans: why not return an IO (m a) ?
09:40:03 <tojans> obadz: I need to return an `Either ServantErr IO a`
09:40:20 <obadz> EitherT
09:40:36 <tojans> obadz: I'm assuming it has something to do with natural transformations, but I'm not sure
09:41:20 <tojans> obadz: this is the original type: type Server api = ServerT api (EitherT ServantErr IO)
09:42:14 <tojans> obadz: and I would like to convert it including the runResourceT that I mentioned in the pastie
09:42:30 <tojans> obadz: i.e. http://pastie.org/10498012
09:43:32 <tojans> obadz: yes EitherT
09:43:42 <obadz> that should be doable
09:43:48 <obadz> and does not require escaping IO
09:43:56 <obadz> let me think for a sec
09:44:07 <tojans> obadz: ok, ty!
09:44:25 <obadz> tojans: does the function in your pastie compile?
09:44:37 <tojans> obadz: not atm
09:44:55 <tojans> obadz: if I get rid of the monad, it does ;)
09:45:03 <tojans> obadz: I'll post what does compile
09:46:12 <tojans> obadz: so this works: http://pastie.org/10498034
09:48:31 <tojans> obadz: and this is an example in the REPL: http://pastie.org/10498040
09:48:49 <tojans> obadz: FTR no hashing etc ;)
09:49:47 <obadz> tojans: left $ runResourceT
09:49:51 <obadz> tojans: (the one that works)(
09:49:53 <tojans> obadz: I've created a wrapper around Database.SQLite.Simple so I can avoid using connection everywhere; this is the full code: http://pastie.org/10498043
09:51:00 <obadz> :t Control.Monad.Trans.Either.left
09:51:01 <tojans> obadz: but that would be only applicable to an EitherT ? Wouldn't it make a diff if I added some other transformers on top?
09:51:01 <lambdabot>     Not in scope: ‘Control.Monad.Trans.Either.left’
09:51:01 <lambdabot>     Perhaps you meant ‘Control.Monad.Writer.lift’ (imported from Control.Monad.Writer)
09:51:23 <obadz> tojans: well you need an EitherT no?
09:51:37 <tojans> obadz: in the end I do
09:51:39 <obadz> tojans: it'll give you an EitherT e IO a
09:52:28 <tojans> aha
09:52:50 <tojans> obadz: so you're suggesting to just hardcode the EitherT in there
09:53:00 <tojans> obadz: good idea, I'll give it a go!
09:53:33 <obadz> tojans: I don't see how to do it any other way but I'm only a month or so ahead of you so..
09:53:45 <tojans> obadz: ok, ty
09:58:24 <ReinH> tojans: you should use ExceptT rather than EitherT
09:58:54 <tojans> ReinH: I will
09:59:10 <tojans> ReinH: Servant used EitherT in pre 0.5
09:59:35 <tojans> ReinH: they switched to ExceptT in 0.5
09:59:54 <ReinH> tojans: also ResourceT is already the name of a monad transformer, so that may confuse people.
10:00:08 <nshepperd> what's wrong with EitherT
10:00:10 <ReinH> Ah, makes sense.
10:00:18 <nshepperd> apart from not being in transformers
10:00:19 <ReinH> nshepperd: nothing, but ExceptT is in transformers now
10:00:23 <tojans> ReinH: good tip, I didn't know that
10:00:26 <nshepperd> oh
10:00:46 <ReinH> personally I wish they had called it EitherT
10:02:58 <ReinH> tojans: EitherT e m a is m (Either e a), not Either e (m a)
10:03:07 <ReinH> There's no need to "exit" m.
10:03:41 <ReinH> Which is convenient given that the latter is impossible
10:04:04 * tojans is reading & trying to grasp what he sees
10:04:37 <sm> tojans: just another day in #haskell..
10:05:24 <tojans> ReinH: aha, so I can just use `runResourceT :: String -> ResourceT  a -> IO a`
10:06:02 <tojans> ReinH: where `a` represents `EitherT ServantErr IO a`
10:06:10 <tojans> ReinH: ?
10:06:52 <tojans> ReinH: I'll try
10:07:47 <ReinH> @unmtl ReaderT r m a
10:07:47 <lambdabot> r -> m a
10:08:26 <obadz> tojans: you can do IO a -> IO (Either e a) simply with fmap Right
10:08:50 <obadz> tojans: and IO (Either e a) -> EitherT e IO a is the basic EitherT constructor
10:09:07 <obadz> tojans: composing the two is done by the "right" function
10:09:22 <obadz> tojans: (sorry I had said left, it was right)
10:09:39 <tojans> obadz: indeed
10:09:48 <tojans> obadz: thank you for going the extra mile
10:10:38 <obadz> tojans: np
10:11:24 <tojans> obadz: & ReinH: have to go now, but thanks!
10:11:30 <obadz> tojans: https://hackage.haskell.org/package/either-4.4.1/docs/Control-Monad-Trans-Either.html#v:right
10:12:04 <obadz> wait no
10:12:34 <obadz> I messed up. You need m a -> EitherT, not a -> EitherT
10:13:11 <tojans> obadz: ok
10:13:53 <tojans> obadz: only have a few mins left, as I have to get the kids from soccer training
10:14:45 <obadz> tojans: "right" is wrong, but fmap Right + EitherT constructor should get you there
10:14:51 <obadz> :t EitherT . fmap Right
10:14:52 <lambdabot>     Not in scope: data constructor ‘EitherT’
10:14:52 <lambdabot>     Perhaps you meant variable ‘either’ (imported from Data.Either)
10:15:02 <obadz> grrr
10:15:23 <poottlee> 'Not in scope: runResourceT', I have 'import Data.Conduit' - do I need other imports?
10:16:31 <obadz> tojans: ExceptT . fmap Right :: Functor m => m a -> ExceptT e m a
10:16:48 <obadz> tojans: works. Go take care of your kids ;-)
10:18:10 <tojans> obadz: ok, ty
10:18:31 <tojans> bb!
10:23:33 <codygman> Is there a better way to write this oneliner: fmap (filter (T.isInfixOf "haskell" . T.toLower . title) . contents) <$> runRedditAnon findHaskellPosts >>= \postListings -> mapM_ (mapM_ (print . title)) postListings
10:24:39 <obadz> lol it would probably be clearer if it wasn't a one liner
10:25:15 <haskell200> any1 mind helping me with some homework?im a beginner with haskell
10:25:20 <ReinH> Who was asking about hexagonal grids?
10:25:26 <ReinH> haskell200: sure, what's the question?
10:25:57 <ReinH> codygman: well, you can eta reduce to get rid of postListings
10:25:57 <tsahyt> haskell200: What's your question?
10:26:35 <tsahyt> ReinH: https://www.reddit.com/r/haskell/comments/3pm6yc/how_do_you_do_a_hex_board_in_haskell/ ?
10:26:45 <ReinH> codygman: but I'd think that would be better off not as a one-liner
10:26:53 <ReinH> tsahyt: ah thanks
10:29:30 <haskell200> ok so i have to write a function
10:29:34 <haskell200> im gonna take it here
10:29:48 <codygman> ReinH: I agree, was just seeing what it would look like if I were playing with that library in GHCI to find out some info quickly
10:29:49 <haskell200> Write a function breakString of type (Char,[Char])->[Char] that takes a character c and a string x as arguments, and returns the substring of x after the first occurence of c.For example,the expression breakstring('d',"1hitd4pm")evaluates to "4pm".
10:30:43 <dolio> codygman: What's with the double fmap? Is it returning Maybe [String] or something?
10:30:55 <dolio> IO (Maybe [String]), I guess.
10:31:16 <tsahyt> haskell200: breakstring('d',"1hitd4pm") does not look like Haskell...
10:31:58 <tsahyt> Although that may just be the lack of a space inbetween the function name and its argument. Looking at your type signature that might be okay (although that's a bit weird too)
10:32:10 <codygman> dolio: it's returning IO (Either (APIError RedditError) [Post])
10:32:38 <haskell200> i have an example function he gave us
10:32:41 <tsahyt> haskell200: Anyway, what have you got so far?
10:33:05 <dolio> codygman: Well, since you're just ignoring errors, it might be simpler to fold out the Either instead of keeping it around.
10:33:36 <haskell200> before(c,x)=if null x then [] else if head x==c then [] else head x(before(c,tail x))
10:35:04 <amalloy> i'm curious why there's not a built-in instance like: instance Bounded a => Bounded (Maybe a) where minBound = Nothing; maxBound = Just maxBound. it seems like the obvious way to implement Bounded, with no weird gotchas
10:35:34 <amalloy> and of course you could do something similar for Enum
10:35:45 <dolio> codygman: `either (const []) id` gets rid of the second fmap, the parentheses for it, and one of the mapM_ calls.
10:36:42 <tsahyt> haskell200: First of all, please use some spaces. before (c,x) instead of before(c,x) and so on. Okay, so the general algorithm should be quite clear. You walk the list until you find the first occurrence of the character that you're given. And then you want to return the rest of the string, right?
10:37:00 <tsahyt> Are you familiar with how lists are defined in Haskell?
10:38:10 <haskell200> yes
10:38:35 <haskell200> iwell
10:38:38 <haskell200> well*
10:38:56 <haskell200> yeah im pretty confident in it
10:38:58 <tsahyt> For simplicity, let's also change the signature for a moment. Instead of (Char, [Char]) -> [Char], let's use Char -> [Char] -> [Char]
10:40:12 <tsahyt> The way to go at this would be pattern match on the list. There are two cases here, because lists have two constructors, [], and :.
10:40:46 <tsahyt> So, breakChar c [] = ? and breakChar c (x:xs) = ?
10:40:51 <tsahyt> I think you can figure out the first case already
10:41:31 <haskell200> im really a beginner so i dont know what x:xs means
10:41:37 <tsahyt> It's a pattern-match
10:41:51 <tsahyt> Look at the list [1,2,3,4] for example. We can write that using the : constructor
10:41:56 <tsahyt> > 1 : 2 : 3 : 4 : []
10:41:58 <lambdabot>  [1,2,3,4]
10:42:21 <tsahyt> Matching x:xs on that list results in x = 1 and xs = [2,3,4]
10:42:29 <haskell200> oh ok
10:42:50 <haskell200> so  breakChar c []=[]
10:42:58 <tsahyt> Yep, that's the base case for the empty list
10:43:54 <tsahyt> The second case is where it gets interesting. The algorithm would dictate that we need to compare the head of the list (which is now bound to x) with c and then do one of two things based on that
10:44:24 <tsahyt> If c == x, we can return the entire rest of the list (and the leading character of course)
10:44:44 <tsahyt> Otherwise you'll need to look at the rest of the list
10:45:06 <tsahyt> So the right hand side should look something like if c == x then ... else ...
10:45:58 <haskell200> so so when c==x it should stop and then print the rest
10:46:09 <tsahyt> Not print but return
10:46:17 <haskell200> yeah
10:46:43 <tsahyt> But yeah, that's what should happen. So you need to put an expression in that place that evaluates to the list from there on
10:47:11 <tsahyt> You've got three things to work with. c, x, and xs. And c == x, so you've really only got two
10:48:46 <haskell200> is this for the example or for the question?
10:49:08 <tsahyt> It's for the right hand side of breakChar c (x:xs)
10:49:16 <jophish> hmm, I must be doing something strange, I'm profiling a library with a wrapper which just calls a single function in the library from main. In wrapper.prof 100% of the time is in main, with no details about what's going on in the library
10:49:29 <jophish> I'm compiling it with --enable-library-profiling
10:50:07 <jophish> I must just be  overlooking something dafty
10:50:10 <jophish> daft*
10:50:47 <tsahyt> jophish: Just a guess, but -fprof-auto?
10:51:38 <haskell200> breakChar c (x:xs)= if c==x then [] else
10:51:41 <jophish> tsahyt: yeah, that's enabled on the executable wrapper
10:51:45 <nitrix> @let breakString c s = tail $ dropWhile (!= c)
10:51:46 <lambdabot>  .L.hs:150:37:
10:51:46 <lambdabot>      Not in scope: ‘!=’
10:51:46 <lambdabot>      Perhaps you meant one of these:
10:51:51 <nitrix> @let breakString c s = tail $ dropWhile (/= c)
10:51:52 <lambdabot>  .L.hs:150:26:
10:51:52 <lambdabot>      Couldn't match expected type ‘[a]’ with actual type ‘[a1] -> [a1]’
10:51:52 <lambdabot>      Relevant bindings include
10:52:10 <nitrix> @let breakString c s = tail $ dropWhile (/= c) s
10:52:11 <lambdabot>  Defined.
10:52:19 <tsahyt> haskell200: Well, not quite. Once you've found that c == x in that position, you'll want to return the rest of the list from there, not just the empty list
10:52:42 <nitrix> > breakString 'd' "1hitd4pm"
10:52:44 <lambdabot>  "4pm"
10:52:48 <nitrix> Yay! :D
10:53:25 <tsahyt> You've got two relevant bindings here, x :: Char, and xs :: [Char]. x is the character of the list that you're looking at right now, and xs is everything *after* that.
10:53:36 <akegalj>  I would like to decode Data.ByteString.Lazy.Internal.ByteString to Data.Text.Text . How can I do this? I see Data.Text.Encoding has decode* but they all work with Data.ByteString.Internal.ByteString  (not the Lazy one).
10:53:44 <jophish> tsahyt: whoops, had to put that on the library too
10:53:50 <jophish> thanks
10:53:58 <tsahyt> nitrix: Yep, but from the level of the question I'm thinking that the exercise is supposed to be more basic than that
10:54:20 <dfeuer> This is funny. If you start with  fix (liftM2 (.) (>>=) . ((flip when .) .))  and hand it to @pointy and @pl repeatedly, it just keeps getting longer.
10:54:31 <haskell200> breakChar c (x:xs)= if c==x then [] else xs?
10:54:32 <nitrix> tsahyt: How would you interpret it differently?
10:54:47 <tsahyt> nitrix: I mean implementing it with explicit recursion
10:54:57 <nitrix> It doesn't say anything about explicit recursion.
10:55:18 <nitrix> If anything, dropWhile is easier than recursion for a beginner.
10:55:27 <tsahyt> nitrix: Not as instructive though
10:55:45 <tsahyt> haskell200: Nope. When c == x, you want to return *the rest of the list*, which is comprised of x and xs.
10:56:00 <tsahyt> well, the rest of the list including the current head to be precise
10:56:04 <nitrix> tsahyt: Well, let's try not to speculate on the goal since the author cannot be clear on the requirements.
10:56:32 <jophish> Now, that's odd, when I use -fprof-auto things are _much_ faster
10:56:41 <jophish> as in, hundreds of times faster
10:56:57 <tsahyt> nitrix: In my experience, recursion is probably the hardest part for beginners, so that's what a lot of those basic exercises focus on
10:58:06 <tsahyt> jophish: Better compile with that all the time now
10:58:55 <jophish> tsahyt: a problem ignored is a problem solved :D
11:00:42 <nitrix> To some degree. If it can be ignored for a long time, it's not worth solving.
11:01:16 <Copperis> ooh, yeah, that could end bad
11:01:49 <haskell200> im kind of lost,
11:04:39 <happyfeet> i have a list of strings that I wana convert to a grid in which is possible to work with (x,y)
11:04:50 <happyfeet> the list is something loke this : ["####",""## #","# ##","####"]
11:05:14 <tsahyt> haskell200: Okay, so far you've figured out that breakChar c (x:xs) = if c == x then <the list from there onwards> else <walk further down the list>, right?
11:05:40 <obadz> happyfeet: are you trying write a screenscraper?
11:05:42 <tsahyt> The list from there onwards is comprised of x and xs, in that order. We just need to put them back together. That's what : is for
11:05:44 <tsahyt> :t (:)
11:05:45 <lambdabot> a -> [a] -> [a]
11:06:18 <happyfeet> obadz it is for a game
11:06:20 <obadz> happyfeet: https://hackage.haskell.org/package/matrix-0.3.4.4/docs/Data-Matrix.html
11:06:24 <obadz> happyfeet: ha ok
11:06:28 <haskell200> ok
11:06:34 <tsahyt> There are only two possible ways to apply : here, since all you have is c, x, and xs
11:06:48 <tsahyt> In your case both are actually correct too
11:07:21 <haskell200> so if c==x then xs should be returned
11:07:25 <tsahyt> Almost
11:07:49 <tsahyt> You're almost there now. xs does not include the first character!
11:08:03 <happyfeet> obadz i found this https://github.com/mhwombat/grid/wiki but i am not sure on how to make it "work"
11:08:10 <tsahyt> You need to prepend that to xs and then you're done with this case
11:08:27 <codygman> dolio: Thanks! :D
11:08:53 <tsahyt> And that's what : is for. So you're looking for _:xs, where _ is the first occurrence of the character you're searching for.
11:09:04 <tsahyt> That can either be c or x, because they're the same thing here
11:09:20 <haskell200> so c:xs
11:09:36 <tsahyt> Yeah that's one way
11:09:53 <obadz> happyfeet: didn't know about this package. it seems like it's also on hackage: http://hackage.haskell.org/package/grid-7.8.4/docs/Math-Geometry-Grid.html
11:09:54 <tsahyt> I'd use x:xs, because we've taken that x out of the list and now put it back in
11:10:14 <obadz> happyfeet: I'm not sure what you mean re making it work?
11:10:27 <tsahyt> (actually we haven't really taken it out, x is just a binding to that list element)
11:10:41 <tsahyt> (but xs is also a binding to the stuff *after* that x)
11:10:49 <happyfeet> i mean, how do I covert my list of strings in a grid ( obadz )
11:11:18 <tsahyt> Okay so there's one last case to consider.
11:11:40 <tsahyt> Thinking back to the overall algorithm, you now need to walk one step further down the list, because you haven't found the first occurence of c yet
11:11:59 <tsahyt> (because the else part is for when c is not equal to x)
11:12:47 <obadz> happyfeet: to be honnest, if you're working on a rectangular grid with square tiles, it's probably easiest to lose the generality and just use matrix 
11:13:07 <tsahyt> And the way you do that is by recursion. So you've got the tail of the list bound to xs, and you want to do the same thing to that.
11:13:08 <haskell200> so what does c:xs return?
11:13:23 <tsahyt> The character c prepended to the list xs
11:13:26 <happyfeet> obadz okok i will look into it thanks
11:13:36 <MarcelineVQ> tsahyt: as an aside `breakstring('d',"1hitd4pm")evaluates to "4pm".` suggests you don't keep the x on a match anyway, so xs is fine on a match
11:14:03 <tsahyt> MarcelineVQ: Oh, I missed that
11:14:13 <nitrix> > breakString('d',"1hitd4pm")
11:14:15 <lambdabot>  <[(Char,[Char])] -> [(Char,[Char])]>
11:14:31 <nitrix> > breakString 'd' "1hitd4pm"
11:14:34 <lambdabot>  "4pm"
11:14:47 <tsahyt> haskell200: Disregard the c:. I thought that you needed the string to include the first occurence.
11:14:49 <nitrix> Had a brain fart for a moment.
11:15:17 <MarcelineVQ> `<haskell200> so if c==x then xs should be returned` correct
11:16:03 <obadz> happyfeet: I don't get the sense that Math.Geometry.Grid will give you a data structure where you can store your data. It instead gives you means to query certain properties about the grid (give me the neighors of this tile, etc.)
11:16:11 <haskell200> ok so the else part is for recursion when it doesnt find the match
11:16:25 <MarcelineVQ> That's right
11:16:39 <happyfeet> obadz that was I was not able to "work" with it... ty :)_
11:17:33 <tsahyt> haskell200: Exactly. You've got a bunch of relevant things here. First of all, there's xs :: [Char], and then there's breakChar :: Char -> [Char] -> [Char], and there's also c :: Char.
11:18:03 <tsahyt> Now you just need to put those things together such that the types line up
11:19:57 <haskell200> hmm
11:20:48 <haskell200> this is off topic but is there a way i can hide when people connect and disconnect?
11:20:56 <tsahyt> Depends on your client
11:21:01 <MarcelineVQ> depends on your client, so google is best
11:21:18 <koala_man> haskell200: http://wiki.xkcd.com/irc/Hide_join_part_messages
11:21:51 <amalloy> i'm curious why there's not a built-in instance like: instance Bounded a => Bounded (Maybe a) where minBound = Nothing; maxBound = Just maxBound. it seems like the obvious way to implement Bounded, with no weird gotchas. and of course you could do something similar for Enum a => Enum (Maybe a)
11:23:06 <haskell200> im just on my browser i dont have a client
11:23:51 <monochrom> then the website you're using is the client
11:24:02 <kadoban> amalloy: Just guessing, but it could easily go the other way too, with Nothing being the maximum value.
11:24:07 <monochrom> so you can't escape, you have a client.
11:24:59 <kadoban> amalloy: It seems like when there's two (or more) instances that both make equal sense, there's some attempt to not pick one directly. Maybe there's newtype wrappers somewhere like there are for Sum and Product for Monoid ?
11:25:17 <clrnd> how can I show a Double with no 'e7' format?
11:25:21 <amalloy> that makes sense, i suppose. making it the min bound seems a lot more sensible, but the opposite isn't crazy
11:25:41 <clrnd> > read "2.2e7" :: Double
11:25:43 <lambdabot>  2.2e7
11:26:03 <clrnd> > show (2.45**-5)
11:26:05 <lambdabot>      Not in scope: ‘**-’
11:26:05 <lambdabot>      Perhaps you meant one of these:
11:26:05 <lambdabot>        ‘**’ (imported from Prelude), ‘***’ (imported from Control.Arrow),
11:26:20 <kadoban> Yeah I think it'd probably depend on what 'a' is representing. Sometimes neither would make sense too, like if it's an Integer should -5 really be greater than Nothing ? Hmmmm.
11:26:47 <clrnd> > show (2.45 ** (-12))
11:26:48 <lambdabot>  "2.1379964887392858e-5"
11:26:50 <monochrom> > Just (-5) > Nothing
11:26:50 <kadoban> Of course that's not bounded so a bad example, pretend I said Int instead.
11:26:51 <lambdabot>  True
11:26:54 <monochrom> :)
11:27:05 <kadoban> Err
11:27:28 <monochrom> this is because of "instance Ord a => Ord (Maybe a)"
11:27:52 <monochrom> in fact, probably simply "data Maybe a = ... deriving (..., Ord, ...)"
11:28:09 <kadoban> Right :-/
11:28:19 <saml> if i want to make http requests  and connect to websocket servers... etc.  where can i find examples and which libraries to use?
11:28:21 <amalloy> oh, there is an Ord instance then? so it makes sense for Bounded to use the same ordering, i would think
11:28:33 <kadoban> Haha, probably. Hmm.
11:28:37 <saml> maybe curated cookbooks on various tasks
11:28:47 <tsahyt> > printf "%f" 2.22e7
11:28:48 <lambdabot>      No instance for (Show a0)
11:28:48 <lambdabot>        arising from a use of ‘show_M805697729833963098217157’
11:28:48 <lambdabot>      The type variable ‘a0’ is ambiguous
11:28:54 <tsahyt> > printf "%f" 2.22e7 :: String
11:28:56 <lambdabot>  "22200000.0"
11:29:04 <tsahyt> clrnd: That should work
11:30:06 <tsahyt> printf isn't exactly the nicest function out there, but you can wrap that in a showDouble function or something
11:30:30 <clrnd> tsahyt, he I should have said "without printf" :P
11:30:31 <clrnd> but thanks
11:30:54 <clrnd> (I know I can use printf, I was looking for an alternative)
11:31:28 <tsahyt> :t showFFloat
11:31:30 <lambdabot> RealFloat a => Maybe Int -> a -> ShowS
11:31:45 <tsahyt> > showFFloat Nothing 2.1351e-10
11:31:47 <lambdabot>  <[Char] -> [Char]>
11:32:24 <tsahyt> > showFFloat Nothing 2.1351e-10 ""
11:32:25 <lambdabot>  "0.00000000021351"
11:32:30 <clrnd> tsahyt, yeah! nice
11:33:02 <clrnd> thanks
11:33:28 <tsahyt> You're welcome. It's in Numeric in base, along with a few other nice showing and reading functions for numbers
11:33:40 <clrnd> good to know
11:34:33 <jmct> Scoping rules with type classes are strange
11:34:55 <jmct> why does the Foldable instance for Seq work (scroll down a bit): http://hackage.haskell.org/package/containers-0.5.6.3/docs/src/Data-Sequence.html#Seq
11:35:07 <jmct> but not this: https://gist.github.com/jmct/0705a0fb0cc84dce646c
11:35:12 * hackagebot codex 0.4.0.0 - A ctags file generator for cabal project dependencies.  https://hackage.haskell.org/package/codex-0.4.0.0 (aloiscochard)
11:36:26 <aloiscochard> ^^ which now support stack projects
11:36:42 <shachaf> I don't follow the question.
11:36:51 <shachaf> What does it mean that it doesn't work?
11:37:03 <jmct> try to compile that gist and it fails
11:37:39 <jmct> but I can rephrase, the Foldable instance for Seq defines teh member function 'length' despite hiding the import of 'length'
11:38:03 <jmct> unless I am missing something (which clearly I am)
11:39:32 <shachaf> "fails" isn't very descriptive.
11:39:50 <shachaf> But when defining a method of a class, the method doesn't need to be unqualified.
11:39:51 <aweinstock> jmct: can you put the error message into a comment on the gist?
11:40:26 <shachaf> E.g. import qualified Foo; instance Foo.K T where { k = ... }
11:40:27 <MarcelineVQ> Are you asking where it gets length?
11:40:33 <MarcelineVQ> `length (Seq xs) =  size xs`
11:41:50 <jmct> aweinstock: done
11:42:09 <jmct> shachaf: but the Foldable instance for Seq does not use the qualified name
11:42:33 <shachaf> Yes, you never use the qualified name in an instance declaration.
11:42:47 <jmct> MarcelineVQ: right, but I'm taling about the right hand side of the definition
11:42:49 <shachaf> The code I wrote above is valid.
11:44:03 <jmct> MarcelineVQ: shachaf: see this line https://github.com/haskell/containers/blob/master/Data/Sequence.hs#L257
11:44:05 <MarcelineVQ> size? There's instances for Sized in the doc
11:44:37 <shachaf> jmct: Yes, that line is fine.
11:44:41 <jmct> and notice that Prelude.length is hidden
11:44:59 <jmct> when I try to do the same in my gist I get a compiler error
11:45:12 * hackagebot deepcontrol 0.3.2.0 - Provide more deeper level style of programming than the usual Control.xxx modules express  https://hackage.haskell.org/package/deepcontrol-0.3.2.0 (KONISHI_Yohsuke)
11:45:13 <aweinstock> jmct: I think that the "length" Data.Sequence hides from Prelude isn't a Foldable method, and it does explicitly import Data.Foldable
11:45:38 <MarcelineVQ> there is a length function defined in that doc though, are you sure you're doing the same?
11:45:44 <aweinstock> (but I'm not sure either)
11:46:00 <jmct> aweinstock: You might be on to something
11:46:10 <shachaf> jmct: It does import length qualified, though.
11:46:17 <aweinstock> MarcelineVQ: it defines length in several "instance Foldable..." blocks, and also defines a top-level length
11:46:31 <shachaf> jmct: As long as it's in scope, even qualified, that's good enough.
11:46:46 <jmct> where is that import?
11:47:00 <shachaf> import qualified Data.List
11:48:36 <jmct> shachaf: I see now. I think what aweinstock said is the issue though
11:50:00 <aweinstock> jmct: I think shachaf is right, the Data.Foldable import has a whitelist that doesn't include Foldable's length
11:50:19 <dolio> shachaf is right.
11:51:01 <jmct> fair enough, I'm convinced :)
11:51:17 <dolio> In the relevant versions, Data.List.length and Prelude.length are the Foldable method.
11:51:47 <dolio> In older versions, they are not, but Foldable doesn't have that method anyway.
11:52:07 <jmct> remember when the prelude was one file? Those were the days ;)
11:52:14 <aweinstock> and it hides all the unqualified "length"s so it can define Data.Sequence.length (as a non-Foldable thing)?
11:52:53 <dolio> Yes.
11:53:24 <jmct> yeah, shachaf's original point is the issue directly, I just didn't see how it related
11:53:58 <monochrom> no. you don't need to hide anything to define a name clash.
11:54:12 <monochrom> the only trouble is when you try to use that name you define.
11:54:44 <dolio> Right, that's technically more accurate. They hide the unqualified lengths so that they can export Data.Sequence.length.
11:55:04 <dolio> And use it in the Foldable definition.
11:56:55 <monochrom> there are about 40 places in Data.Sequence that use its own "length"
11:58:29 <dolio> Oh, okay.
12:01:11 <cdk> why can't I use Data.Coerce.coerce to safely coerce between data T a b = T and newtype A a = A (forall b. T a b)?
12:01:34 <jmct> shachaf: thanks btw, sorry for being dense :)
12:02:25 <monochrom> are they the same kind?
12:03:04 <monochrom> I guess that is unimportant
12:03:14 <cdk> monochrom: no, T :: * -> * -> * and A :: * -> *, but they have the same runtime representation don't they?
12:03:25 <monochrom> I don't know why
12:03:39 <arkeet> cdk: what would the type of coerce be?
12:05:42 <cdk> arkeet: something like (T a b -> A a) and (A a -> (forall b. T a b)) I would think
12:08:30 <lpaste> arkeet pasted “cdk” at http://lpaste.net/794935649772765184
12:08:34 <arkeet> hmmm
12:09:11 <arkeet> I did guess that it had something to do with the forall.
12:10:22 <cdk> I'm confused why the forall'ed types matter at all, since they're all phantom
12:11:36 <gpampara> you just need to .flatMap(_ => other) to chain them  in order
12:11:42 <KaneTW> i guess it can't handle the case A a -> forall b. T a b
12:11:50 <arkeet> it doesn't work in either direction.
12:11:54 <gpampara> stupid alt+tab
12:12:23 <dolio> Type classes don't really work with foralled types, and that they do with coerce at all is a one-off hack, I believe.
12:12:25 <KaneTW> why it's failing that is, since coercibility is symmetrical
12:13:22 <dolio> So it wouldn't be super unsurprising if some use cases weren't covered properly by that.
12:13:30 <dolio> Super surprising, even.
12:13:47 <arkeet> but
12:13:50 <arkeet> they don't?
12:14:21 <dolio> What don't?
12:17:09 <arkeet> what works with coerce at all?
12:18:04 <dolio> I think some stuff got put in for handling types with quantifiers. Or I thought I heard that. Maybe I'm wrong.
12:20:28 <dolio> \(v :: V) -> coerce v :: Coercible b (forall a. a) => V -> b
12:20:45 <dolio> For `newtype V = V (forall a. a)`. 
12:20:54 <dolio> That is ghci output.
12:23:33 <Zemyla> What is the purpose of hyperfunctions?
12:24:12 <dolio> Zipping folds in linear time.
12:40:41 <Zemyla> dolio: Also, if Hyper is an Arrow, and a Monad, why isn't it an ArrowLoop if ArrowLoop is equivalent to Monad?
12:42:22 <dolio> I don't know the exact answer to that.
12:42:29 <dolio> Wait, no.
12:42:33 <dolio> ArrowApply is Monad.
12:42:48 <dolio> ArrowLoop is fixed points of some sort.
12:43:26 <Denommus> ArrowLoop isn't Monad
12:43:54 <Denommus> ArrowLoop is for Arrows what MonadFix is for Monads
12:44:02 <Denommus> but an Arrow isn't necessarily a Monad
12:45:09 <aweinstock> ArrowApply + ArrowLoop = MonadFix?
12:45:16 * hackagebot Slides 0.1.0.5 - Generate slides from Haskell code  https://hackage.haskell.org/package/Slides-0.1.0.5 (darwin226)
12:47:02 <lpaste> Maro pasted “dimensions test” at http://lpaste.net/143574
12:47:41 <Maro> hello #haskell
12:48:05 <Zemyla> dolio: Yeah, ArrowApply is what I meant.
12:48:17 <Zemyla> Hyper is a Monad, so it should be an ArrowApply.
12:48:26 <arkeet> why use ArrowApply when you can use Monad?
12:48:53 <Zemyla> arkeet: Because some things want an ArrowApply, and also with ArrowApply we get ArrowChoice.
12:49:09 <arkeet> why would something want an ArrowApply when it could just use Monad?
12:49:09 <Maro> i'm trying to construct a dimensions type (like kg*m*s^-1), i'm trying to use TypeLits to keep track of the dimensions as Nats; but when I try to implement (+), ghc says it can't add Nats
12:49:19 <arkeet> Maro: which ghc version?
12:49:42 <Zemyla> ArrowApply and Monad have different kinds.
12:49:45 <Maro> 7.8.3
12:50:15 <Maro> i pasted the code above
12:50:24 <Maro> http://lpaste.net/143574
12:50:50 <obadz> When I import Module.Blah (MyType(..)) I should be able to call the MyType constructor if data MyType = MyType Int no?
12:50:52 <obadz> I get error "Not in scope: data constructor MyType"
12:50:59 <arkeet> Maro: I can't remember if the solver is included in ghc 7.10
12:52:09 <arkeet> or maybe 7.8 had that.
12:52:10 <arkeet> I forget.
12:52:10 <Maro> arkeet: is that related to ghc-typelits-extra?
12:52:40 <Maro> https://hackage.haskell.org/package/ghc-typelits-extra
12:54:06 <obadz> (figured it out, I needed to export)
12:55:02 <shachaf> Why am I suddenly getting a bunch of emails from Michael Snoyman? I never signed up for this mailing list.
12:57:16 <anoe> Hello, do you have a link explaining the difference between pre-FTP and after-FTP ? I would like to understand Mark Lentczner point of view, and I am rather new to haskell. Thanks in advance for the explanations and links if available.
12:58:21 <aweinstock> :t map
12:58:22 <lambdabot> (a -> b) -> [a] -> [b]
12:58:30 <aweinstock> :t length
12:58:31 <lambdabot> Foldable t => t a -> Int
12:59:03 <aweinstock> anoe: Prelude.length is now (Foldable t => t a -> Int) instead of ([a] -> Int)
12:59:12 <aweinstock> (and likewise for a bunch of prelude functions)
12:59:19 <shachaf> I don't care too much about Foldable and Traversable being exported from Prelude.
12:59:31 <kadoban> shachaf: I think they might be being sent to either people with FP accounts or to people on hackage maybe? I can't figure out why I'm getting them either, though I don't particularly mind them I guess.
12:59:34 <shachaf> But I hate the acronym "FTP" and can't stand discussion of it.
13:00:08 <aweinstock> shachaf: because it conflicts with File Transfer Protocol?
13:00:12 <anoe> aweinstock: many thanks, that is clear
13:00:16 <tommd> anoe: FTP was, to a large extent, a generalization of many pre-existing function.  This means some functions are redundent and many will give more verbose error messages that might be harder to understand.
13:01:13 <shachaf> Acronyms are a bad idea in the first place, but acronyms like these "proposal" ones are especially bad.
13:01:22 <MarcelineVQ> Wasn't there an acrinym with A in it that meant the same thing? would have been better than ftp
13:01:23 <anoe> ok tommd 
13:01:37 <Cale> Traversable I'm totally okay with, Foldable I'm not so okay with.
13:01:38 <MarcelineVQ> amp?
13:01:47 <shachaf> That acronym is terrible too.
13:02:01 <shachaf> If people don't stop making these stupid acronyms I'll probably have to unsubscribe from all mailing lists.
13:02:07 <MarcelineVQ> I guess amp is for the monoid thing now that I tink about it for 2 seconds, so nvm :X
13:02:15 <MarcelineVQ> *monad
13:02:22 <KaneTW> all of them are, but typing out foldable-traversable proposal all the time is a pain
13:02:57 <aweinstock> MarcelineVQ: ADT can mean both {Algebraic, Abstract} Data Type
13:03:10 <KaneTW> amp is the one with class Applicative m => Monad m
13:03:21 <shachaf> Yes, that name is terrible too.
13:04:05 <shachaf> Not everything needs a name.
13:04:30 <jmct> shachaf: I agree with you, the acronyms add nothing to the discussion and have the potential to confuse those entering the conversation
13:04:39 <kadoban> Well, it needs a name when you're discussing it a lot, which I assume the people who came up with those acronyms are/were. FTP is a really bad acronym though.
13:04:55 <shachaf> No, it was completely gratuitous.
13:05:09 <shachaf> I read the original proposal before there was any discussion of it.
13:06:37 <kadoban> And I'm sure there had no reason to expect any discussion about a feature modifying Monad? :-/
13:27:34 <aetbx> Hello.
13:28:04 <aetbx> anyone active?
13:28:06 <Cale> yes
13:28:18 <aetbx> What's up? Just here to chat.
13:28:19 <Cale> There are 1500+ people here, someone is always active :)
13:28:28 <voidzero> AM NOT
13:28:30 <voidzero> oooops
13:28:39 <voidzero> darnit, fell for it again
13:29:02 <aetbx> I'm just surprised that this place isn't just swarming with chat and people spamming it
13:31:09 <voidzero> europe is drunk, the US is fed up and ready to call it a day
13:31:40 <bsmt> pretty much
13:32:01 <voidzero> :)
13:32:10 <voidzero> and i'm behind my pc as always
13:32:19 <voidzero> what a life
13:44:44 <ReinH> voidzero: that's my secret, I'm always fed up and ready to call it a day.
13:46:38 <voidzero> it's trendy
13:47:14 <bsmt> nihilism: it's new! it's hip! it's fun!
13:47:29 <voidzero> MEH
13:47:45 <voidzero> ^ picking up fast
13:56:57 <varaindemian> .
13:58:41 <voidzero> hello varaindemian 
14:01:43 <varaindemian> tried haskell on prelude emacs and after inserting some "erros" I used C-c C-l and it froze 
14:01:49 <varaindemian> http://imgur.com/QUjhvR2
14:01:57 <varaindemian> I had to use killall emacs to kill the process
14:06:05 <ReinH> varaindemian: well, there's a prompt.
14:08:38 <jmct> aweinstock: maybe it's more subtle still? Check this out: https://gist.github.com/anonymous/4344d3d3d3615024babb
14:09:36 <varaindemian> ReinH: could't access it... everything was frozen
14:10:06 <aweinstock> jmct: I'm not familiar with the MINIMAL pragma, nor am I a typeclass guru
14:10:54 <jmct> aweinstock: the minimal pragma just means that when defining and instance you only have to define the ones marks as minimal
14:11:20 <jmct> I'm trying to emulate teh Foldable class which does not require an instance to define length
14:11:58 <jmct> aweinstock: being a non-guru aside, would you agree that this _seems_ to do what we decided was the solution earlier?
14:12:30 <jmct> the qualified import of Test2 should bring the typeclass members into scope (I thought)
14:13:07 <jophish> I have a library which is super slow (25 seconds) without -fprof-auto, but with that flag it is about a hundred times faster
14:13:26 <aweinstock> jmct: it looks very similar
14:13:44 <jophish> What could the cause of this be?
14:14:30 <jophish> total alloc is about 1000 times higher without -fprof-auto
14:14:57 <sm> win! :)
14:15:19 * hackagebot smtlib2 0.3 - A type-safe interface to communicate with an SMT solver.  https://hackage.haskell.org/package/smtlib2-0.3 (HenningGuenther)
14:15:31 <jophish> It's an odd kind of heisenbug I suppose
14:15:52 <jophish> sm: I supppose so, but I'd really like to get to the bottom of this
14:17:04 <jophish> but I can't profile it to find out why it's slow!
14:19:32 <MarcelineVQ> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#prof-rules maybe something to do with the stacking involved is making things evaluate stricter in the profiled version
14:20:14 <jophish> MarcelineVQ: I tried compiling the library with -fno-state-hack, but no dice, that's still as slow
14:20:20 * hackagebot post-mess-age 0.2.0.0 - Send messages to a handle concurrently without getting them mixed.  https://hackage.haskell.org/package/post-mess-age-0.2.0.0 (DanielDiaz)
14:24:00 <jophish> Is it worth mentioning that the code which is so slow doesn't touch ST or IO
14:25:38 <sm> you could probably find out by staring at the generated core long enough
14:26:18 <jophish> What would I do when I found a difference? Just pepper that bit of code with strictness annotations?
14:27:37 <sm> that's always worth a try IMHO :)
14:28:01 <sm> since it's quick, but usually it has no effect and you have to actually understand why its slow
14:28:55 <sm> you can probably at least narrow down where to look in the code by using trace statements or ghci or timeit
14:29:03 <sm> to find what's slow
14:29:37 <jophish> sm: I ran the stages in ghci fairly informally and it seemed to be slow all over. I'll try a little more carefully now
14:30:47 <sm> but wait.. why can't you profile it to find out why it's slow ?
14:30:56 <MarcelineVQ> because profile is making it fast
14:31:03 <jophish> :D
14:31:18 <sm> not even a little bit slow, somewhere ?
14:31:31 <jophish> sm: not as far as I can tell
14:31:39 <jophish> it uses 33MB of memory instead of 35GB
14:31:47 <sm> I am totally using that flag from now on
14:32:08 <jophish> I really can't recommend it enough :)
14:32:27 <jophish> 25s to about 50ms
14:33:03 <sm> trace statements will probably tell you a lot.. compare the log from both versions
14:33:34 <jophish> sm: It would be nice if there were a version of timeIt which works like Debug.Trace
14:34:17 <sm> I'm sorry to give such low-tech advice, but they do tell a lot. There's also some new-fangled event logger in GHC
14:34:30 <jophish> yeah, I just saw that
14:34:42 <jophish> I wonder if it's possible to enable without profiling
14:34:52 <sm> a trace that prints times ? good idea, and it shouldn't be hard to make
14:39:23 <sm> a trace that printed the time elapsed and change in heap/stack size since the last trace would be interesting too
14:48:15 <jophish> sm: tracing has shown a completely different call stack! Perhaps something is being shared in the profiled version
14:49:12 <jophish> some function is being evaluated 184708 times in the non-profiled version, and 267 times in the profiled version
14:50:22 <sm> maybe it's where the traces diverge ?
14:52:26 <jophish> must be, I should print a call stack there
14:52:41 <ReinH> "a call stack"?
14:53:01 <jophish> ReinH: the output of traceStack :)
14:53:16 <jophish> a forced thunk stack?
14:53:53 <ReinH> A list of SCC annotated locations
14:54:00 <jophish> gotcha
14:54:02 <ReinH> not an actual call stack, which Haskell/GHC doesn't have.
14:54:28 <jophish> sure, the documentation for traceStack does use the term "call stack"
14:54:36 <ReinH> It does, which is annoying
14:54:44 <jophish> so I though that was acceptable nomenclature 
14:55:09 <ReinH> Yeah, of course you would, no worries
14:58:04 <jophish> hmm, printing the list of SCC annotated locations wasn't very helpful
15:00:12 <ReinH> Yeah, not a very good call stack, as far as call stacks go ;)
15:00:59 <ReinH> GHC is inherently somewhat hard to debug using traditional methods
15:01:13 <ReinH> that, e.g., rely on the existence of a call stack ;)
15:01:32 <jophish> Haskell makes up for it in that I hardly ever get into this kind of mess in the first place
15:02:07 <sm> I think if you simply trace function names when you enter them, it'll be enough to pinpoint where the behaviour differs 
15:02:12 <sm> no need for a stack
15:02:21 <montanonic> Hmmm, is it just me, or are the amount of programming resources out there rather small? A lot of the must-read programming books are just about how to use an outdated language in a way that is productive. 
15:03:09 <sm> or is that naive
15:03:10 <johnw> montanonic: didn't you just describe like 90% of real-world engineering?
15:03:25 <montanonic> And after looking up books for functional programming, there are very few "essentials"
15:03:30 <jophish> sm: It's quite tricky to follow
15:03:35 <montanonic> johnw: I wouldn't know. I'm new to this stuff.
15:03:44 <jophish> the flow is fairle convoluted in this program :/
15:03:47 <jophish> fairly*
15:04:12 <montanonic> I'm just experiencing surprise. I was just expecting there to be a clearer path upwards for more advanced stuff. 
15:04:18 <sm> can you simplify it until it stops doing the thing
15:04:48 <jophish> sm: I'll put a few more traces in, if that doesn't work I'll try to generate a testcase
15:04:51 <jophish> :/
15:04:52 <montanonic> (not saying I'm at the point where I'm ready for more advanced stuff; I have a good chunk of books to work through right now; I've just been curious to see what the next step was)
15:04:56 <johnw> montanonic:  it depends on where you look.  The bookshelf of any decent academic involved in functional programming will have a good deal of excellent material.
15:06:51 <johnw> Barnes and Noble, not so much
15:07:39 <jophish> sm: the issue is that all of the functions here return a closure which is evaluated much later on
15:07:49 <jophish> so it's very tricky to tell where they're all being generated
15:08:20 <jophish> all I can really see is that this one lambda is being called with the same arguments about 200000 times
15:11:00 <sm> can you.. add traces to all the place that generate closures..
15:11:04 <sm> sorry, I'll stop now
15:11:48 <sm> I have a parser that's bear to debug for similar reasons, I'm planning to rewrite it for easier troubleshooting
15:12:11 <jophish> sm: sadly this design is not really able to be changed :/
15:12:58 <sm> it's quiet here now, but #ghc might have ideas
15:13:08 <jophish> good thinking
15:13:54 <paf31> bitemyapp: re earlier chat, im also interested to hear what design points you find objectionable
15:15:07 <bitemyapp> paf31: my opinion doesn't matter much there, you have different constraints & priorities.
15:16:21 <paf31> alright then. i'm still interested to hear your thoughts at some point.
15:20:23 * hackagebot codex 0.4.0.2 - A ctags file generator for cabal project dependencies.  https://hackage.haskell.org/package/codex-0.4.0.2 (aloiscochard)
15:25:23 * hackagebot atlassian-connect-descriptor 0.4.1.0 - Code that helps you create a valid Atlassian Connect Descriptor.  https://hackage.haskell.org/package/atlassian-connect-descriptor-0.4.1.0 (RobertMassaioli)
15:29:44 <montanonic> Could anyone here whose read Purely Functional Data Structures clarify to me two exercises?
15:31:01 <montanonic> I'm confused about 2.2 and what it means to "keep trach of a candidate element that might be equal to the query element", and "checking for equality only when you reach the bottom of the tree". I just don't see how that would improve the performance of `member` for a Binary Tree.
15:31:25 <montanonic> Or what it means to keep track of a candidate element
15:33:06 <montanonic> then 2.3 asks me to insert an existing element into a binary tree while avoiding copying nodes that are indistinguishable from the originals. It says to "Rewrite insert using exceptions to avoid this copying. Establish only one handler per insertion rather than one handler per iteration". I'm not clear on what this means though.
15:33:13 <montanonic> Thank you for any interprative assistance.
15:34:22 <montanonic> I didn't realize that the way you wrote a function would effect how Haskell copies it? Like, that you could have a more efficient persistance structure just by altering your high-level code.
15:41:16 <lpaste> ghorn pasted “MINIMAL pragma with -XDefaultSignatures” at http://lpaste.net/143581
15:41:41 <ghorn> i found that the minimal pragma will trigger a warning even when DefaultSignatures are used
15:41:44 <ghorn> is this a known issue?
15:42:28 <acowley> Can somebody buy dolio a beer or coffee or whatever he enjoys? His email was fantastic.
15:42:29 <acowley>  
15:47:14 <ghorn> my answer seems to be this https://ghc.haskell.org/trac/ghc/ticket/10959
15:47:55 <montanonic> From Purely Functional Data Structures, I'm working on this exercise: http://lpaste.net/7790021319944306688#a7790021319944306688
15:48:40 <Gurkenglas> acowley, what do you mean, his email? Is this about those mailing lists? Neither of the three at the top of https://wiki.haskell.org/Mailing_lists have "dolio" in an authors name in the most recent month's archive.
15:48:42 <montanonic> The current version of `insert` copies every node that its search goes through when finding where to insert the new element.
15:49:07 <acowley> Gurkenglas: I mean Dan Doel
15:49:29 <montanonic> The exercise suggests that by writing it differently I can make it so that it only connects a pointer from the inserted element to the point of the tree where it ought to be. Or something like that.
15:49:43 <acowley> Gurkenglas: Specifically, his measured response on the libraries list
15:50:06 <montanonic> I (1) didn't know what something like this was possible, and (2) am not sure what the specifics of the exercises I pasted are asking me to do.
15:50:25 * hackagebot msh 0.1.0.1 - Object-Oriented Programming in Haskell  https://hackage.haskell.org/package/msh-0.1.0.1 (mbg)
15:50:28 <Gurkenglas> Damn, do the mailing lists have more discussions than the Haskell channel?
15:50:34 <Gurkenglas> *s
15:51:09 <acowley> The mailing lists are mostly people yelling for everyone to get off their lawn, but they're the most official discussion forums we have
15:51:32 <Gurkenglas> You mean this one? https://mail.haskell.org/pipermail/libraries/2015-October/026390.html (Because that's the only occurence of his name on https://mail.haskell.org/pipermail/libraries/2015-October/thread.html )
15:51:53 <acowley> Yes
16:00:22 <ReinH> acowley: o/
16:00:43 <Gurkenglas> Should there be "newtype EndoT m a = EndoT (a -> m a)"?
16:01:19 <acowley> Hey ReinH!
16:09:36 <johnw> Gurkenglas: that was mentioned here in Apr 2008 :)
16:10:05 <johnw> Gurkenglas: http://ircbrowse.net/browse/haskell?events_page=152747
16:10:07 <Gurkenglas> Right, shoulda checked ircbrowse
16:10:26 * hackagebot msh 0.1.0.2 - Object-Oriented Programming in Haskell  https://hackage.haskell.org/package/msh-0.1.0.2 (mbg)
16:14:09 <Zemyla> edwardk: I think I found an instance for ArrowChoice for Hyper.
16:14:53 <Zemyla> I don't know how to prove it, but it seems to work on all the tests I throw at it.
16:15:21 <acowley> Can anyone put the libraries committee thing in terms I can understand? The current situation is exactly a public mandate following years of discussion.
16:15:57 <acowley> So why ask for exactly that to happen again?
16:15:58 <johnw> acowley: What aspect of the libraries committee thing do you mean?
16:16:34 <acowley> johnw: Geoffrey and Henrik's contributions today wherein they suggest that a committee other than CLC that better represents the two of them should have more sway.
16:17:14 <johnw> ah, you mean their point about having publicly elected members, rather than individuals selected by past members?
16:17:39 <acowley> I guess. I don't think they actually have a particular plan they want enacted. 
16:18:04 <acowley> It's just so striking that they're asking for just what happened because they don't like the outcome.
16:18:51 <johnw> It would be strange if that were the motive for them asking.  That wasn't the take away I had from reading their messages.  Can you point me to something that you think was saying that more explicitly?
16:19:27 <acowley> Sure, here's Henrik just now, "I and others who
16:19:27 <acowley> are suggesting that far-reaching changes should go past a
16:19:27 <acowley> committee with a clear mandate and a sufficiently robust and long
16:19:27 <acowley> process"
16:20:04 <johnw> ah, I see
16:20:11 <acowley> What happened was years of grumbling about AMP, followed by a poll and the formation of a CLC with public support. They did their thing. Some people were unhappy, so there was a second, larger poll to *confirm their mandate*.
16:20:18 <acowley> All of that took years
16:21:08 <johnw> sounds like Henrik wants something along the lines of a "oversight committee" to prevent excessively disruptive changes, if I'm reading that correctly
16:21:24 <johnw> but yeah, we've had a few examples in the community already of people thinking the process should be replaced because it wasn't doing what they wanted in particular
16:21:31 <acowley> Yes, but what he clearly does not want is a "clear mandate"
16:21:32 <davean> Right, enforce the status quo
16:21:37 <acowley> Because that is what we have
16:22:19 <johnw> so it is simply that Henrik wants progress in Haskell to happen at a slower pace?
16:22:26 <davean> Welcome to politics. The haskell community has developed its own, we're pretty doomed.
16:22:27 <acowley> And Geoffrey earlier suggested that the CLC's work should have fallen to the Haskell Prime committee who had already disbanded
16:23:12 <johnw> I don't think I completely understand yet what the interests of all the parties involved are, even though it's quite clear with the particular points they're arguing about are
16:23:14 <acowley> johnw: I don't recall Henrik every arguing for any change, so yours is a charitable interpretation
16:23:29 <acowley> I think change makes their lives harder in some ways
16:23:44 <acowley> And they don't think those hardships are worth the benefits of those changes
16:23:46 <johnw>  sometimes I think they mean "never change", that I have a feeling that's being too naïve about their concerns
16:23:51 <johnw> s/that/though
16:24:30 <johnw> have we even resolved yet whether it's time for Haskell to cease being a research language, and to start being an industrial language that needs to cater to things like commercial stability?
16:24:36 <davean> People don't like change, and smart people are very good at coming up with arguments to defend their possitions.
16:24:43 <acowley> The best you can do is look at what they do and say. If they are arguing for some change and not others, then clearly they are not against all change.
16:24:49 <johnw> Because our slogan of avoiding success at all costs would clearly favor changed for the better, even if it breaks existing state-of-the-art
16:24:49 <davean> I'm not entirely convinced people's arguments are entirely based on their actual interests
16:25:06 <davean> I think we might be past that point
16:25:19 <acowley> I still buy in to the slogan, fwiw
16:25:21 <johnw> davean: yes, it could be that FTP just pissed people off
16:25:27 <johnw> and that's what all of this is really about
16:25:39 <acowley> Henrik and Geoffrey didn't participate in the FPT debate to my recollection
16:25:55 <johnw> which may go further to explain why they don't like that it happened
16:25:57 <acowley> So at least in their case it's not lingering sour feelings after a contentious argument
16:26:01 <johnw> because they never got the heads up in time to participate?
16:26:13 <acowley> Yes, but at some point they have to take responsibility for that
16:26:33 <davean> No they don't - people are very good at not taking responsability
16:26:41 <davean> Not saying it is in their case
16:26:53 <davean> But I'm saying I think we're more into politics then technical
16:27:05 <acowley> davean: Yes, I think so, too
16:27:08 <davean> A lot of people are still having a technical debate
16:27:15 <davean> But I think the debate overall ahs left the technical range
16:27:35 <davean> Which means a lot of bets are off
16:27:40 <acowley> Yes, I agree
16:27:50 <johnw> so what is the debate really about?
16:28:03 <acowley> That's why I'm picking on the suggestion that we ought to have a long process with a committee that has a mandate
16:28:20 <acowley> Because that is not advancing the political conversation given it is what we already have
16:28:29 <johnw> acowley: makes sense
16:28:56 <acowley> I also just feel like people on the CLC must be really offended by it, which is why I was so impressed by dolio's email
16:29:00 <davean> johnw: I think it varries a lot, but I think thats what needs to be figured out
16:29:41 <davean> I tihnk we have a problem untill someone figures that out
16:30:01 <ReinH> Rule 1 is "Never mistake a people problem for a technical problem."
16:30:08 <ReinH> Rule 2, of course, is "all problems are people problems."
16:30:44 <johnw> "Separate the people from the problem", and then "Negotiate interests, not positions."
16:31:10 <ReinH> johnw: I think that's easier said than done :)
16:31:31 <davean> Yah, see, we're technical people - maybe we need a politician
16:31:34 <johnw> it only took a setence to say it, so I agree :)
16:31:39 <davean> We're bad at this problem and it is biting us
16:31:52 <johnw> ReinH: I'm actually quoting a book that I'm currently reading
16:31:58 <ReinH> johnw: ha :)
16:32:01 <ReinH> johnw: which book though?
16:32:18 <johnw> "Getting to Yes: Negotiating Agreement Without Giving In"
16:32:29 <ReinH> johnw: I like another book by the same author
16:32:30 <johnw> reading it with the haskell committee in mind has been a trip
16:32:45 <ReinH> "The Power of a Positive No"
16:32:53 <ReinH> William Ury, right?
16:32:54 <johnw> it's actually a very good book, I just started a few days ago
16:33:03 <johnw> but already it's changing the way I read these e-mail discussions
16:33:10 <johnw> Roger Fischer, William Ury, Bruce Patton
16:33:14 <jophish> sm: you'll never guess what. I finished putting in all the traces, and now the non-profiled version has sped up again :/
16:33:18 <johnw> apparently it's research from a project at Harvard
16:33:34 <ReinH> jophish: Yeah, great book. Try mine when you're done with that one too.
16:33:37 <johnw> anyway, I think I'll send an e-mail to Henrik, to find out his interests
16:33:42 <johnw> ReinH: will do!
16:33:45 <jophish> ReinH: will do!
16:33:45 <davean> johnw: Yah, see, this is part of why I kinda tapped out of the discussion
16:33:53 <ReinH> jophish: hah, you too I guess :D
16:34:00 <davean> When I started reading it that way, I kinda declared bankrupcy
16:34:07 <davean> I've got enoguh politics in my life
16:34:18 <ReinH> jophish: TOCTOU error in tab completion, which is in most-recently-seen order :)
16:34:32 <ReinH> god they show up everywhere
16:34:44 <hackal> Hello I am doing an assignment for my haskell class and wanted to ask if this is correct way to do the exercise. Also lpaste is throwing some kind of error http://lpaste.net/7065586196830748672
16:35:15 <jophish> ReinH: such a pleasant acronym though
16:35:17 <ReinH> hackal: lpaste is being a bit forceful with its *suggestion* that you replace uppers x = map toUpper x with uppers = map toUpper
16:35:23 <ReinH> jophish: just rolls off the tongue
16:35:39 <ReinH> hackal: really that is a hlint suggestion, not an error
16:35:40 <davean> What ReinH said, nothing is wrong, theres just a shorter, equivilent way
16:36:01 <jophish> hackal: looks good to me
16:36:03 <davean> hackal: you might find the equivilent less clear though, some people do
16:36:07 <ReinH> > let uppers = map toUpper in uppers "Hello World"
16:36:09 <lambdabot>  "HELLO WORLD"
16:36:13 <ReinH> stop shouting at me
16:36:20 <ReinH> hackal: also seems good to me
16:36:44 <hackal> Why does the function work without arguments?
16:37:10 <davean> hackal: because then it returns a function
16:37:14 <davean> hackal: which takes an arguement
16:37:31 <hackal> oh yeah, now I see. We had that in our class
16:38:18 <davean> hackal: its realyl simple *once* you notice
16:38:22 <montanonic> Yeah, so writing it without x means that you are coding on the level of the function. I tend to prefer doing it that way. What's it mean to convert a string to uppercase? map toUpper
16:38:30 <davean> hackal: untill you notice whats actually happening its magic :)
16:38:52 <ReinH> :t map
16:38:53 <lambdabot> (a -> b) -> [a] -> [b]
16:39:03 <ReinH> hackal: One way of looking at map is that it takes a function and a list and applies the function to the list elements
16:39:05 <hackal> I did a lot of javascript. lot of things in haskell are magic for me
16:39:31 <montanonic> hackal: have your read functional programming in JavaScript or used underscore.js?
16:39:32 <ReinH> another way is map :: (a -> b) -> ([a] -> [b]), which says that it takes a function and gives a *new* function which now works on lists instead of single elements.
16:40:11 <montanonic> hackal: if not, you might want to take a look at them. It will help you learn parts of Haskell, and Haskell will help you learns parts of Functional Javascript and Underscore
16:40:16 <ReinH> hackal: and Haskell is cleverly designed such that those two type signatures are equivalent, which makes the rule f x = g x ==> f = g something that actually works as a way to transform programs.
16:40:40 <hackal> montanonic: thanks for suggestion
16:40:51 <ReinH> hackal: hopefully I am making some sense :)
16:41:11 <montanonic> hackal: no prob. What's the name of the class you're in now?
16:41:29 <hackal> https://www.inf.ed.ac.uk/teaching/courses/inf1/fp/
16:42:02 <acowley> johnw: You're so zen! I was going to reply with a taco emoji, drop my laptop on the floor, and walk out of the room.
16:42:19 <johnw> acowley: lol!
16:42:32 <johnw> acowley: I'm just trying to put my book into practice, to test it out
16:43:20 <acowley> johnw: And I'm trying to put these new emojis into practice. It's like you got the grownup version of whatever playbook I'm using.
16:43:21 <montanonic> hackal: cool, thank you for that link. FP is really cool, so seems like a great class.
16:44:28 <johnw> acowley: the name of U+1F32E is "TACO", but I have no font that contains it
16:44:41 <hackal> montanonic: no problem, there are also lectures online under the "video" section. Also our professor is great.
16:44:48 <ReinH> acowley: dropping the laptop seems especially egregious given that he won't know you did it
16:45:01 <ReinH> but I suppose *saying* you're going to do it has a similar effect with less hardware damage
16:45:22 <acowley> ReinH: Wish I'd thought it through that far
16:45:23 <johnw> ReinH: destruction perceived is destruction achieved?
16:45:29 <ReinH> johnw: I mean, isn't it?
16:45:42 <johnw> I cannot argue
16:45:57 <montanonic> Is there away to have two otherwise equal functions that use persistance in different ways?
16:46:18 <ReinH> montanonic: What do you mean by "persistance"?
16:46:21 <ReinH> And, for that matter, "use"?
16:46:25 <ReinH> And, for that matter, "equal"
16:46:32 <montanonic> For example: one which inserts an element into a tree, copying everything in its search path; and another which only draws a pointer from the element to that place in the tree
16:46:56 <montanonic> It's a problem I'm still trying to figure out from Okasaki's PFDS. I probably should just have said "immutable structure"
16:47:07 <ReinH> montanonic: you could observe a difference if the trees were mutable, yes
16:47:12 <montanonic> And by equal, I mean, with the exact same input -> output
16:47:23 <montanonic> but perhaps a different *underlying* representation
16:48:23 <montanonic> I've just started learning about how an insert function acutally works on a Binary Tree, in terms of the new data structure it generates
16:49:03 <montanonic> But what I've yet to grasp is how/if you can generate a new structure that doesn't copy the search-path elements that insert has to go through to get to the point where it adds a new element
16:49:23 <ReinH> montanonic: if structure are immutable, you can use sharing in some fancy ways
16:49:27 <ReinH> *structures
16:49:44 <montanonic> Right, so I'm trying to understand how to alter how a function is using sharing
16:49:54 <montanonic> And yes, that's the word I was looking for, sharing, ty.
16:50:42 <lpaste> montanonic pasted “PFDS Binary Tree” at http://lpaste.net/1759537033316925440
16:51:46 <montanonic> Right now, Okasaki is telling me that the tree that `insert` generates will share all the elements it traverses until the point of insertion with its input tree
16:52:11 <ReinH> montanonic: a common example of not-so-fancy sharing is copy-on-write :)
16:52:12 <hackal> http://lpaste.net/7531415527961395200 how come in this case I get error in compiler that (/100) returns Int?
16:52:16 <montanonic> But that "using exceptions", I can make it so that it doesn't copy identical data.
16:52:31 <ReinH> hackal: This one should really be in the faq
16:52:34 <ReinH> :t (/)
16:52:35 <lambdabot> Fractional a => a -> a -> a
16:52:53 <ReinH> (/) expects both arguments to be of the same type, and that type must be an instance of Fractional
16:53:14 <ReinH> Int is not an instance of Fractional, so it can't be the numerator of (/)
16:53:39 <ReinH> > (1 :: Int) / (100 :: Double)
16:53:40 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘Double’
16:53:40 <lambdabot>      In the second argument of ‘(/)’, namely ‘(100 :: Double)’
16:53:40 <lambdabot>      In the expression: (1 :: Int) / (100 :: Double)
16:53:48 <ReinH> > fromIntegral (1 :: Int) / (100 :: Double)
16:53:50 <lambdabot>  1.0e-2
16:54:00 <ReinH> However, you can explicitly convert the Int using fromIntegral
16:54:23 <ReinH> hackal: also as a side note, you should use Double instead of Float unless you have a specific reason for wanting the lower precision Float
16:55:28 * hackagebot propellor 2.11.0 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-2.11.0 (JoeyHess)
16:56:05 <ReinH> (Also we should actually have a faq)
16:56:12 <montanonic> Can anyone help me understand how to alter how a function uses structural/data sharing?
16:56:25 <ReinH> (It could probably just point to a bunch of stackoverflow entries)
16:56:31 <ReinH> montanonic: alter in what way?
16:57:15 <montanonic> ReinH: well, the way I talked about earlier, with a Binary Tree and an insert function. My lpaste has code for an insert function that copies elements along its search path and shares with the rest
16:57:34 <montanonic> Okasaki wants me to make it share everything except for the element it inserts.
16:57:38 <hackal> ReinH: I see. (\x -> fromIntegral x / 100) this is working. However I am wondering if there is different way to do it.
16:57:39 <montanonic> I have 0 ideas on how to do this.
16:58:52 <davean> montanonic: and the nodes on the path to the root
16:59:40 <ReinH> hackal: not really, no
16:59:55 <ReinH> montanonic: *everything* else?
17:00:06 <ReinH> I don't think that's possible, but I am not an expert
17:00:20 <jmcarthur> montanonic: That doesn't sound right. How can you point to a new element without the pointer to the element also being new?
17:00:23 <montanonic> hackal: I added an annotation to your lpaste with how to write it without fromIntegral
17:00:45 <ReinH> montanonic: I would expect you to be able to share everything but the forest you grafted on for the new element
17:00:58 <ReinH> er, tree you grafted on
17:01:05 <montanonic> ReinH, jmcarthur, davean, let me paste the exercise text
17:01:10 <montanonic> That way I can make sure I'm being clear
17:01:18 <jmcarthur> Maybe the real trick is that it needs to be a constant time insertion? But that sounds like a fancy data structures problem more than a sharing problem.
17:01:31 <jmcarthur> And of course just defers the work for later.
17:01:32 <ReinH> jmcarthur: that would be a real trick indeed...
17:01:57 <lpaste> montanonic pasted “Binary Tree data sharing” at http://lpaste.net/143587
17:01:58 <ReinH> Well, I can make a constant time insertion easily: add Insert e (Tree e) to the adt ;)
17:02:04 <davean> jmcarthur: ah, its both - Okasaki uses laziness
17:02:16 <davean> jmcarthur: He does a lot of work in using laziness for amortization
17:02:24 <jmcarthur> ah!
17:02:29 <ReinH> The problem is good amortized access
17:02:31 <joeyh> is there any way to link to the latest version of a module on hackage?
17:02:31 <jmcarthur> I understand what it's asking for now.
17:02:33 <ReinH> Yeah
17:02:34 <montanonic> I've tried to understand that exercise I pasted but I just have no clue.
17:02:47 <jmcarthur> montanonic: The key phrase is "an existing element".
17:02:56 <Clint> joeyh: just leave off the version number?
17:03:09 <ReinH> jmcarthur: indeed
17:03:10 <jmcarthur> montanonic: If the element already exists in the tree, you should just return the whole original tree.
17:03:16 <ReinH> joeyh: you wrote git-annex right?
17:03:17 <montanonic> jmcarthur: ooooooooooh, dang. That changes things. I understand now! Wow.
17:03:31 <joeyh> aha, thanks.. although it fails if the latest version docs have not built
17:03:33 <ReinH> joeyh: if you link without a version, it will choose the latest
17:03:36 <joeyh> ReinH: yes
17:03:51 <ReinH> joeyh: well, thanks for that.
17:03:54 <davean> joeyh: you need something built faster?
17:04:02 <ReinH> it's good software
17:04:19 <joeyh> davean: no, just trying to make a documentation link that will work reliably longterm..
17:04:24 <ReinH> joeyh: Impatient people can publish their own documentation if they want :)
17:04:27 <montanonic> jmcarthur: thank you for your help
17:04:52 <ReinH> montanonic: see this is why we become pedantic, crotchety old people. ;)
17:04:55 <davean> joeyh: well, then using the unversioned and providing your own docs is the safest - docs are being improved though
17:05:39 <montanonic> ReinH: in what sense? The necessity to be absolutely precise with descriptions?
17:05:57 <montanonic> If so, fair enough hah :)
17:06:06 <ReinH> montanonic: yes
17:06:49 <ReinH> montanonic: tbh one of the reasons for the unreasonable success of mathematics in the sciences is just that it provides an incredibly precise way to describe a problem. ;)
17:07:47 <montanonic> ReinH: yeah, that's a great point; but, on that note.... I'm confused again about a problem he's giving... I'll paste it.
17:08:27 <jophish> sm: I've annotated a couple of functions as INLINE and things are back to (nearly) normal
17:08:43 <lpaste> montanonic pasted “Rewriting `member`; Okasaki” at http://lpaste.net/143588
17:09:26 <montanonic> I have no idea why I'd do "by keeping track of a candidate ele-ment that might be equal to the query element"
17:09:44 <montanonic> And "checking for equality only when youhit the bottom of the tree"
17:09:58 <montanonic> How is that more efficient than short-circuiting once a match is found?
17:10:30 <kadoban> montanonic: It's fewer comparisons, which may or may not be more efficient.
17:10:59 <montanonic> kadoban: hmm, maybe I need to diagram the problem out; it's hard for me to see what he means
17:13:16 <kadoban> montanonic: You know how when you get to the root of a new subtree, you say: okay, is this, <, if not, you say "is this =="? There's a more efficient (in terms of avoiding comparisons) way to do that. You defer some == checks until later, because many will become impossible anyway due to later results.
17:13:44 <montanonic> kadoban: ah, sorry, it finally dawned on me what he was saying
17:13:45 <ReinH> kadoban: but in Haskell, Ord gives you both for one :)
17:14:18 <montanonic> I totally get it now. If I only test for >, and then assume <= otherwise, and then test for equality at the end, I cut down the amount of comparisons by half, and then add 1.
17:14:27 <kadoban> ReinH: Yes, but the book isn't haskell specific. And I'm not sure that's always free, though it probably is, isn't it?
17:14:29 <ReinH> montanonic: yep!
17:15:05 <montanonic> kadoban: yeah, gotcha; that helps me to understand it even further; thank you
17:15:10 <kadoban> 'welcome
17:18:06 <ReinH> kadoban: of course it's good to know that you can do this with just (<) and (==), but isn't it nice to have compare? :)
17:20:00 <montanonic> ReinH: wait, wouldn't using `compare` be around as efficient?
17:20:09 <montanonic> I'm thinking about the cost of the compare function
17:20:18 <montanonic> Hmm, maybe not.
17:20:25 <kadoban> ReinH: :) yes.
17:20:46 <kadoban> I'm trying to think of some reason that not checking for == in compare would be more efficient … but I can't think of one, haha.
17:21:11 <jmcarthur> @src compare
17:21:11 <lambdabot> compare x y | x == y    = EQ
17:21:11 <lambdabot>             | x <= y    = LT
17:21:12 <lambdabot>             | otherwise = GT
17:21:15 <jmcarthur> that's why
17:21:27 <jmcarthur> for some types maybe it's more efficient, but that's the default at least
17:21:55 <montanonic> Right, yeah I just realized it's like no different than what what exists. Just obscured the calculations.
17:22:43 <ReinH> Yeah, but at least it *can* be more efficient.
17:23:32 <ReinH> Although it's hard to know if a particular instance is, and I imagine most aren't.
17:23:41 <montanonic> Gotcha. Good points.
17:42:25 <davean> joeyh: propellor is built if you were waiting :)
18:01:35 <xecycle> say I have a Reader a b, and a function c -> a, how to produce a Reader c b? (here I know not much about haskell, learning some monad stuff for use in javascript)
18:02:49 <jakeehrlich> So in haskell accelerate what is a good way to do vector addition and matrix multipication?
18:03:03 <jakeehrlich> like small vector addition and small matrix multipication
18:04:38 <Cale> xecycle: Reader a b is really just a -> b
18:05:15 <Cale> xecycle: It's really hard to get anything very worthwhile out of the monad abstraction in Javascript
18:05:39 <Cale> xecycle: You can do it, but it ends up being awkward, because you need to pass around the record of monad operations to everything explicitly.
18:05:57 <Cale> (because you don't have the benefit of type classes)
18:06:53 <Cale> A lot of attempts try to weasel out of this, and end up doing stuff that, well, might technically implement the monad operations for various things, but not in a way that there's any point in recognising that you have a monad.
18:07:03 <xecycle> Cale: okay somehow getting the point.  As for awkwardness in js, I think it will still be better than passing dependencies down the call chain manually.
18:07:21 <Cale> The point of Monad is to be able to write code that will work with *any* monad, and only write it once.
18:07:26 <johnw> xecycle: withReader foo, where foo :: c -> a
18:07:31 <Cale> Things like sequence :: (Monad m) => [m a] -> m [a]
18:07:38 <johnw> is how it would be done in Haskell
18:07:58 <ReinH> Usually in JS and such you don't use "monads", you use specific, ad hoc implementations of bind and return. You don't get any of the generality.
18:08:26 <Cale> If you can't write sequence once and reuse it for every monad you come across, then you haven't really gained anything by recognising that things happened to be monads.
18:09:39 <xecycle> johnw: thanks, got it
18:12:07 <jophish> I have a function foo :: (Int -> Bool) which is True above some value and False below it. Would it be ok to call it monotonic?
18:15:21 <johnw> jophish: I think so
18:15:50 <johnw> you're mapping Integers to Bools, preserving that order, so that no False int is above a True int
18:16:21 <ReinH> Sure, using the usual ordering of the bools
18:16:28 <johnw> right
18:16:32 <ReinH> (and the usual ordering of the ints)
18:16:41 <ReinH> where False is bottom and True is top
18:17:01 <jophish> ReinH: well, thinking about it, it would still be monotonic (ly decreasing) with the other order
18:17:04 <johnw> "an order preserving mapping between sets" is what you need to satisfy
18:17:11 <ReinH> jophish: yep
18:17:18 <jophish> cool stuff
18:17:52 <eriksensei> Hello folks, i'm looking for a 2-element windowing function like this: https://github.com/epost/psc-query/blob/master/src/Lib.hs#L120. I've looked in various places on hackage, but I couldn't find what I need. Any tips on where to look?
18:18:36 <ReinH> eriksensei: is there a reason you don't want to use that function?
18:18:38 <jophish> Here's another question. What does everyone do with all the little helper functions that get written. I've just come up with one which will do a binary search for the first True element of a monotonic boolean function. It seems silly to make a package with just one function like this in, but it doens't really live anywhere else
18:19:29 <eriksensei> ReinH: well, I'd prefer to know what/where it was, if it exists :)
18:19:40 <ReinH> eriksensei: Ah. I don't know of any.
18:19:48 <jophish> hmm, I suppose that could actually go in binary-searches
18:19:54 <eriksensei> i'm guessing it should fit into something predictable
18:20:16 <eriksensei> ReinH: too bad :)
18:20:39 <jophish> in fact, it already exists :/
18:21:12 <ReinH> jophish: oh?
18:21:46 <jophish> :t search
18:21:48 <lambdabot>     Not in scope: ‘search’
18:21:48 <lambdabot>     Perhaps you meant ‘each’ (imported from Control.Lens)
18:21:54 <jophish> https://hackage.haskell.org/package/binary-search-0.1/docs/Numeric-Search-Integer.html
18:21:57 <jophish> ReinH: ^
18:23:10 <ReinH> Ah, nice.
18:23:21 <ReinH> eriksensei: That appears to be similar to
18:23:23 <ReinH> :t \f -> concatMap (uncurry f) . (zip <*> tail)
18:23:23 <jophish> well, that's over Integers, but I only need Int
18:23:24 <lambdabot> (a -> a -> [b]) -> [a] -> [b]
18:23:51 <ReinH> In fact, equivalent
18:24:43 <arkeet> :t \f -> zipWith f <*> tail
18:24:44 <lambdabot> (a -> a -> c) -> [a] -> [c]
18:24:49 <arkeet> oh.
18:25:03 <arkeet> :t \f -> concat . (zipWith f <*> tail)
18:25:04 <lambdabot> (a1 -> a1 -> [a]) -> [a1] -> [a]
18:25:39 <eriksensei> ReinH, arkeet: wow, that's pretty cool! thanks!
18:25:47 <ReinH> arkeet: Yeah, or that
18:26:08 <ReinH> I just went for zip`ap`tail and then stopped ;)
18:26:28 <ReinH> @quote zip`ap`tail
18:26:28 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
19:01:18 <hunteriam> Does anyone have a link to an example of the Data Expr haskell example which is a small DSL in haskell?
19:01:23 <hunteriam> im trying to show my friend how neat it is
20:01:01 <tommd> There's bound to be a dozen such examples.
20:56:40 <Romefeller> Hello
21:01:34 <sportanova> no
21:15:24 <dlight> In the Emacs haskell-mode, is there something like C-c C-l that detects I'm in a Cabal project and calls it in my Main.hs? (or whatever "main-is" in Cabal)
21:24:02 <dlight> Or even, a function to find the Main.hs of the Cabal project the current buffer belongs to, however deep in the directory hierarchy it is
21:35:47 <sportanova> @dlight sorry don't know
21:35:47 <lambdabot> Unknown command, try @list
21:35:57 <sportanova> dlight: 
22:01:12 <dlight> sportanova, thanks for the answer nonetheless :P
22:02:17 <sportanova> dlight: yeah haven't been doing emacs for that long. Do you know how to have multiple <sessions / frames> open? to keep buffers separate between projects
22:06:31 <lpaste> tzh pasted “No title” at http://lpaste.net/143597
22:07:12 <tzh> whoops i was gonna ask the question _before_ pasting that.
22:08:30 <tzh> so i have a question that is a little hard for me to put into words but is displayed in that code: is there a way for me to combine all those extractX and renderX functions into a single function? i think typefamilies might be the thing? or maybe not; this is way beyond what i've done in terms of type-level programming so far, so i'm pretty lost
22:16:44 <dlight> sportanova, M-x new-frame to open a new frame (that's a new "window" in the terminology outside Emacs)
22:17:38 <sportanova> dlight: i do that, but the new frame has all of the new buffers
22:17:48 <sportanova> * all of the same buffers
22:17:49 <Cale> tzh: At the very least, they look Template Haskell-able
22:17:54 <KaneTW> tzh: i can't think of a type family that'd work due to monotype restriction (https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-families.html#type-instance-declarations)
22:18:02 <dlight> sportanova, C-x 2 and C-x 3 to divide the current "window" horizontally and vertically (this creates what emacs call a "window"), C-x 1 closes all windows except this one, C-x 0 closes the last window you opened
22:18:06 <dlight> ohh, uhmm
22:18:10 <Cale> tzh: But I don't understand what's going on with your code well enough to try to suggest anything concrete
22:18:47 <dlight> sportanova, yes that sucks. I kind of solved that making my own function to switch buffers, instead of using C-x <- and C-x ->, that take in account other stuff
22:19:26 <dlight> actually, not exactly *this* problem, but a similar approach can solve your problem
22:20:44 <sportanova> yeah it's not a big deal, but kind of a pain. keeping buffers separated between projects would be nice
22:20:55 <tzh> KaneTW: yeah, from what i had read it seemed like the answer to "is this possible" was "no", but there's always hoping i missed something really obvious
22:21:54 <KaneTW> switch to agda :v
22:22:13 <tzh> the solution to all my problems :V
22:23:07 <tzh> Cale: yeah maybe at the worst i can use template haskell to generate more without having to actually type it all out; that's something for sure
22:24:12 <sinelaw> conal: there?
22:24:43 <dlight> sportanova, but I'm sure there is a mode out there to tie buffers to windows
22:24:53 <dlight> or frames
22:25:57 <sportanova> hmm looks like there's a page for this - i'll look into it more http://www.emacswiki.org/emacs/SessionManagement. Thanks!
22:38:12 <dlight> sportanova, it appears that session management is just for saving buffer and window configurations. But I asked on #emacs and it appears that there is a way to set a buffer as being "dedicated" to a window, with set-window-dedicated-p
22:39:09 <dlight> but it actually doesn't achieve this either, it makes the buffer dedicated so no other buffer will be shown there. :(
22:39:18 <sportanova> haha oh dear
22:43:37 <dlight> sportanova, it appears that perspective  http://github.com/nex3/perspective-el and projectile https://github.com/bbatsov/projectile do that
22:44:08 <dlight> (or perhaps they work together, I'm not sure)
22:45:35 <sportanova> dlight: just saw projectile in there - looks like it could be it. Thanks!
22:45:54 <sportanova> oh you already posted. nice!
22:46:28 <dlight> oh actually is at #emacs too
22:46:42 <sportanova> perspective looks great
22:55:46 <dlight> sportanova, my emacs buffer switching looks like this: when in a buffer that isn't *special*, s-left (win key + left) and s-right cycle only between non-*special* buffers (that are likely files), likewise if it's *special*
22:56:14 <dlight> also when cycling between *buffers* it skips *Messages* and some others
22:56:21 <dlight> this solved most of my complaints
22:58:09 <sportanova> hmm i'll have to try that out
23:00:45 * hackagebot language-python 0.5.2 - Parsing and pretty printing of Python code.  https://hackage.haskell.org/package/language-python-0.5.2 (BerniePope)
23:00:47 * hackagebot language-python-test 0.5.2 - testing code for the language-python library  https://hackage.haskell.org/package/language-python-test-0.5.2 (BerniePope)
23:03:39 <dlight> sportanova, i didn't publish in a package, but it's something like this https://gist.github.com/anonymous/d0d1f3bac535c0d9562f (put on init.el), also contains s-up to go to regular buffers and s-down to go to buffers beginning with *
23:03:54 <dlight> not sure if it's compatible with perspective
23:05:23 <lolmac> j go-nuts
23:47:02 <lpaste> montanonic pasted “Can I clean up `member`?” at http://lpaste.net/143602
23:47:42 <montanonic> I'm new to the State Monad and still haven't been able to use it in any significant manner thus far, but I was wondering if I could use it to clean up the member function I just pasted.
23:49:18 <montanonic> Or if there's any other way to clean up the code. Again, I'm not used to using Haskell to pass states around, so...
23:49:35 <montanonic> It feels inelegant.
23:53:39 <nshepperd> I don't think I'd use the State monad there
23:53:56 <montanonic> Yeah, it's a pretty simple use case now that I'm looking at it more.
23:54:19 <montanonic> I was mainly curious to see what using the State monad would look like because I'm so damn bad at figuring out how to make it work the way I want it to.
23:54:33 <nshepperd> I'd probably call that variable 'candidate' rather than 'state' though
23:54:38 <montanonic> Good point.
