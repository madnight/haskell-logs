00:01:33 <Ongy> Cale: I use registerFd with my (unsafeCoerce MultiShot), it does compile and the runtime does not complain either, but from what I can see, the event never triggers (neither once, nor multiple times as desired)
00:01:47 <Cale> Interesting
00:05:22 <awpr> have it dump the C-- and look at what numeric tag it actually ends up using?
00:05:34 <Ongy> awpr: how can I dump the C--?
00:05:44 <awpr> there's some flag, I'll try to find it
00:05:50 <Cale> -ddump-cmm ?
00:05:57 <awpr> yep
00:07:40 * hackagebot pqueue 1.3.1 - Reliable, persistent, fast priority queues.  https://hackage.haskell.org/package/pqueue-1.3.1 (lspitzner)
00:07:40 * hackagebot polar-shader 0.1.0.3 - High-level shader compiler for Polar Game Engine  https://hackage.haskell.org/package/polar-shader-0.1.0.3 (Shockk)
00:08:21 <Ongy> might take a few minutes (I have to build a minimal example, doing this in the current project [cabal build] produces way to much code)
00:14:46 <Aleka> Hello all
00:15:04 <Aleka> anybody working on anything fun?
00:17:04 <pharaun> define fun
00:18:59 <nitrix> @let fun = undefined
00:19:01 <lambdabot>  Defined.
00:19:14 <pharaun> :)
00:19:29 <rhovland> aleka: working on nicta, woot
00:19:38 <awpr> > sizeOf (fun :: Word32)
00:19:40 <lambdabot>      Not in scope: ‚ÄòsizeOf‚Äô
00:19:40 <lambdabot>      Perhaps you meant one of these:
00:19:40 <lambdabot>        ‚ÄòIM.size‚Äô (imported from Data.IntMap),
00:20:29 <Ongy> awpr: my minmal example only produced 7k lines of Cmm, this will be fun
00:21:39 <rhovland> 7k of Cmm sounds like average
00:23:48 <awpr> Ongy: http://community.haskell.org/~simonmar/papers/ptr-tagging.pdf might be useful for figuring out what's going on in the cmm, if you haven't read it.  there's an example of generated code for static constructors
00:25:49 <Aleka> so I recently saw a video of a guy walking up street in his boxers because he was caught with someones girlfriend
00:26:20 <Aleka> makes me  think of all the crazy things we missed before the internet
00:26:49 <shachaf> This is not the channel for that.
00:32:09 <Adeon> how do I check at compile-time that Int is Int64
00:32:51 <Adeon> aside from using TH
00:34:23 <Cale> Adeon: maxBound
00:34:29 <Cale> > maxBound :: Int
00:34:30 <lambdabot>  9223372036854775807
00:34:41 <Cale> oh, at compile time
00:34:49 <Adeon> yeah, that's trickier
00:34:49 <Cale> Just use TH :)
00:35:01 <Cale> (and maxBound)
00:35:09 <Adeon> okay, bonus round, what if I'm cross-compiling from 32-bit platform to 64-bit platform
00:35:13 <Cale> heh
00:35:30 <Adeon> I'm not actually doing that but I feel terrible that my TH solution wouldn't work for that
00:36:00 <Cale> That's a rare enough situation that you can probably just use a flag or something.
00:36:19 <Cale> Or just build different code :P
00:36:46 <awpr> Ongy: wait, I have a better idea.  print (unsafeCoerce MultiShot :: GHC.Event.Lifetime)
00:37:03 <awpr> to see if it gets the right Lifetime value or not
00:37:34 <Ongy> awpr: Not in scope: type constructor or class ‚ÄòGHC.Event.Lifetime‚Äô
00:38:29 <awpr> Ongy: oh, right.  well, let x = unsafeCoerce MultiShot in seq (registerFd ... x) (print x)
00:38:42 <awpr> i.e. abuse unification to make it have that type without mentioning it
00:39:42 <Ongy> awpr: it doesn't know of the show instance
00:40:44 <awpr> oh, huh.  well, I haven't been able to make it do the wrong thing with data types isomorphic to Bool yet
00:42:50 <Ongy> maybe for 4.8.0.0 there is more broken than just the export
00:45:44 <Cale> Quite possible, given that the API is unusable :P
00:46:44 <awpr> yeah, could be.  given that my Bool-isomorphic types worked as expected even with the type totally unexported and in a different package, I'd say it's likely it's getting the right Lifetime value
00:50:30 <awpr> the easy way to find out is to build against 4.8.1.0 (unsafeCoerce and all) and see what happens
00:57:14 <Ongy> well my system will scream, but here we go
00:57:56 <autrilla> Is it ok to learn haskell on Windows or should I use linux? I'd have to fix my xorg if I switched to linux so I kind of want to stay on win :p
01:02:31 <Cale> autrilla: You should be able to do it.
01:03:43 <Cale> autrilla: Personally I think a bunch of things about it are easier on Linux, but if it's much trouble at all to get your Linux setup working, then it's not really a big enough deal to worry about.
01:04:19 <autrilla> Well, I have to set up xrandr in order to have proper scaling in my monitors
01:10:25 <sgronblo> How do you check which resolver is used by stack and how do you change it?
01:11:47 <nitrix> Could someone name drop a few elements that makes GHC sophisticated in comparison to other compilers? I find it strange for the community to put all their eggs in the same basket. My understanding is that it'd be a duplication of efforts; so what's the current state of GHC?
01:12:26 <sgronblo> I want to install psc-ide using stack, but apparently my current resolver lts-2.20 doesnt contain it.
01:14:20 <nitrix> sgronblo: You might want to add it as an extra dependency then (stack.yml).
01:19:57 <sgronblo> nitrix: which stac.yml?
01:20:09 <sgronblo> cant i just change the resolver being used to something newer?
01:20:53 <sgronblo> do i have a user-wide stack.yaml?
01:47:37 <Ongy> awpr: I might have to report back later today, compiling ghc takes ages and I have to go somehwere
01:50:44 <tomus> I have a long list of (x, y) coordinates and I want to group them into simply connected regions. One soution: groupBy and a function whether two points can be connected via a path. seems terribly inefficient
01:52:52 <Gurkenglas> The last element might connect two regions, so if you're gonna do this in a single pass you'll have to keep track of intermediate regions and connect them. Do you know anything about the order of the list of points?
01:53:37 <Gurkenglas> You could sort them by a coordinate, and effectively sweep a line across the plane, accumulating regions as you go; you'd only have to keep track of which parts of the line correspond to which regions that you are in progress of constructing
01:54:57 <tomus> Gurkenglas: I am in control of creating the list. Seems to me like a simple graph traversal (take a pixel and try to visit neighboors <- graph)
01:55:00 <Gurkenglas> Is this homework, do you want it so you have a black box that can turn coordinates into connected regions, or do you want to see if you can?
01:55:12 <tomus> it's not homework
01:55:59 <Gurkenglas> How do you construct the list?
01:56:40 <tomus> from a 2d image
01:57:04 <tomus> I have a masked image, masked meaning some pixels don't have colour
01:57:14 <tomus> I wanna split the image into blobs
01:57:34 <tomus> seems like graph traversal, but with haskell's immutability I am lost
02:02:07 <Gurkenglas> Seems like it's pretty close to the graph traversal approach I thought of :P
02:02:21 <Gurkenglas> I'll code you something up real quick. In what format do you want the results?
02:03:00 <tomus> just a [[a]] will do
02:03:05 <notdan> hi
02:03:12 <tomus> it's just a prototype I'll adopt it for my needs
02:03:26 <tomus> I should probably read on graph traversals in haskell
02:03:59 <tomus> I meant [(Int, Int)] -> [[(Int, Int]]
02:06:50 <Gurkenglas> Is there a monadic scanr?
02:07:23 <Gurkenglas> tomus, the algorithm naturally takes the form [[Bool]] -> [[Int]], where Int names the blobs
02:09:30 <Gurkenglas> Oh hey no actually resulting in [[(Int, Int)]] is also easy. On the other hand, [(Int, Int)] will require sorting if it isn't already sorted
02:09:37 <tomus> Int names blobs -> did you convert 2d to 1d? that's fine with me
02:10:36 <Gurkenglas> No, [[Bool]] and [[Int]] are both colorings of the picture. Bool says whether a pixel is to be included in a blob, Int says which blob
02:11:09 <tomus> ah ok
02:11:27 <quicksilver> Gurkenglas: yes there are monadic scans
02:11:31 <tomus> you are creating more masks
02:11:53 <tomus> named masked (named for each blob)]
02:12:42 <Gurkenglas> As I realized in my second last line, I can do either a mask or a list of points. If you can deal with a mask without going via coordinates, that is "more elegant". Do you still want a coordinate list?
02:12:58 <tomus> masks are fine
02:13:15 <Gurkenglas> quicksilver, keyword please?
02:34:00 <Gurkenglas> Grr looks like coordinates are easier after all, I can't quickly find a fusing strategy without pathological cases http://lpaste.net/142192
02:36:09 <Gurkenglas> (Also there'd have to be a second pass that actually fuses the numbers on the mask into one)
02:51:56 <SK0> for graphing some signals from ghci, what are my options? I just want to have to pass some x's and get a simple graph
02:52:37 <tomus> :t &~
02:52:38 <lambdabot> parse error on input ‚Äò&~‚Äô
02:52:55 <tomus> :t (&~)
02:52:56 <lambdabot> s -> State s a -> s
02:52:56 <f-a> gnuplot library, lemme search SK0 
02:53:56 <f-a> SK0: I see I used easyplot
02:54:03 <f-a> seemed nice and simple to me
02:54:24 <f-a> http://hackage.haskell.org/package/easyplot
02:54:25 <isocliff> SK0: I recently made something for that: https://github.com/BlackBrane/ansigraph
02:55:40 <f-a> isocliff: that's quite awesome, do you plan to put it on hackage (and show a minimal working example)?
02:56:06 <dimsuz> hi. I have a tuple (x,y) and function 'trans' which transforms it. I need to apply this function n times to (x,y). Am I right that this is best done by using fold functions?
02:56:19 <isocliff> f-a: thanks! :) Yeah theres an example module in there
02:56:44 <Gurkenglas> Why isn't there N.keyView :: k -> Map k a -> Maybe (a, Map k a)?
02:56:46 <isocliff> Its been kicking around on my comp for a little while but I just uploaded it yesterday, and I plan to put it on hackage pretty soon, like today I guess
02:57:35 <f-a> dimsuz: depending what you are willing to do, check iterate
02:57:41 <f-a> (from data.list)
02:58:55 <dimsuz> f-a: ah, no not that. need a single value in the end (to plot it)
02:59:00 <dimsuz> thanks
02:59:16 <tomus> Gurkenglas: I am still investigating what you wrote, I haven't ignored it
03:02:58 <SK0> f-a, easyplot seems to be what I am looking for, thanks
03:02:59 <f-a> going through it now dimsuz , really nice package
03:03:10 <Gurkenglas> tomus, using the mask approach again :P, do you care if masks have multiple names?
03:03:28 <SK0> isocliff, that does not seem to be what I am looking for, but I will definately try it out right now
03:03:42 <Gurkenglas> (There will be a list of masks, and a list of names for each one. I can make a second pass that'll rename everything to the main name)
03:06:14 <SK0> isocliff: your package is not on hackage yet, correct?
03:12:36 <tomus> Gurkenglas: M.empty from what module? I am trying to make a working example
03:12:54 <Gurkenglas> :t M.empty
03:12:55 <lambdabot> M.Map k a
03:14:01 <RaceCondition> is there a chat room for Reactive Banana, or Haskell FRP libraries in general?
03:14:32 <jle`> RaceCondition: people doing FRP often hang out in #haskell-game
03:14:38 <jle`> but it's not dedicated to that in particular
03:15:37 <tomus> :t scanrM
03:15:38 <lambdabot>     Not in scope: ‚ÄòscanrM‚Äô
03:15:39 <lambdabot>     Perhaps you meant one of these:
03:15:39 <lambdabot>       ‚Äòscanr‚Äô (imported from Data.List),
03:16:01 <Gurkenglas> quicksilver, how are the monadic scans called? I just pulled a name out for that snippet :P
03:16:33 <saulzar_> RaceCondition, and #reflex-frp, though there's a reflex bias people talk about other FRP stuff too often enough
03:17:51 <RaceCondition> jle`, saulzar_: thanks, I'll check these out
03:21:25 <tomus> :t <<+=
03:21:26 <lambdabot> parse error on input ‚Äò<<+=‚Äô
03:21:45 <isocliff> SKO: not yet. Though it will be soon
03:22:25 * geekosaur doesn;t thinkt hat's a thing...
03:22:26 <Gurkenglas> tomus, it is one of the maaannnnyyyy operators from lens. It takes a lens from the monadic state into something with a Num instance, adds one to it, and returns the old value
03:22:34 <geekosaur> :t (<<+=)
03:22:35 <lambdabot> (Num a, MonadState s m) => LensLike' ((,) a) s a -> a -> m a
03:22:42 <geekosaur> ah, lens, of course
03:22:44 <Gurkenglas> (I mean, adds the right-side value to it)
03:25:09 <hellofunk> hi, i have a general question about types, though i'm new to haskell and actually haven't started much with it. but am curious if something I do often in Clojure is possible in haskell.
03:25:33 <hellofunk> is it possible to restrict the return value of a function beyond just its type, but for example, something like a function which only returns a number between 0 and 1
03:25:36 <isocliff> i meant SK0: Not yet, but quite soon
03:25:41 <hellofunk> as if that was a special "type"
03:27:09 <isocliff> hellofunk: no, that would be a dependent type
03:27:31 <hellofunk> is "dependent type" a particular feature of Haskell?
03:27:55 <isocliff> Nope. Not yet at least. But languages like Idris or Agda could do that
03:28:28 <hellofunk> ok, interesting. it's a rather straightforward thing to do with macros in a lisp, but that is run-time checking. not sure how it would even be possible to check something like that compile time
03:28:55 <hc> hi, i'm trying to rewrite "let a = \x y -> Just (x,y)" like this: "let a = Just . (,)" ... could you help me out?
03:29:32 <tomus> Gurkenglas: what is lens?
03:30:25 <isocliff> hellofunk: Ah, I see. Yeah Im pretty sure thats impossible at the moment, at compile time. 
03:30:39 <Gurkenglas> tomus, a lens is a recipe for applying changes to a small type to a big type.
03:30:44 <Gurkenglas> @pl \x y -> Just (x,y)
03:30:44 <lambdabot> (Just .) . (,)
03:30:45 <Gurkenglas> hc, have fun
03:31:11 <hc> thanks! :)
03:31:14 <Gurkenglas> Beware: Do this is you only want ekmett and you of until 2 days in the future to be able to read your code
03:31:32 <hc> haha
03:31:47 <hc> well it's just to create a new type, so i guess it's ok
03:32:01 <hc> newtype Position = GisPosition (Float, Float)
03:32:37 <hc> who's ekmett btw?
03:32:46 <bollu> edward kemett
03:32:58 <bollu> https://www.fpcomplete.com/user/edwardk
03:33:06 <hc> ah
03:33:14 <Gurkenglas> > _2 +~ 1 $ (5,5) -- tomus, _2 is a lens into the second element of a tuple
03:33:15 <lambdabot>  (5,6)
03:34:14 <Gurkenglas> Operators with "~" make functions that apply to values, operators with "=" make monadic state actions
03:35:13 <Gurkenglas> I hadn't invoked the magic word to generate lenses for my record type yet, so here: http://lpaste.net/142192
03:39:25 <tomus> lens seem fine
03:39:38 <tomus> I can't grasp what your snippet is doing
03:40:15 <Gurkenglas> It's not done yet, I haven't done the second pass. But:
03:40:41 <Gurkenglas> Line 11 executes the monadic state action in line 12 on the initial state in line 13
03:42:07 <Gurkenglas> (Reload.) Line 12 traverses the plane, one line at a time, using the line function, and starting with a line of Nothings
03:42:32 <Gurkenglas> Line 13 says we start with the region index 0 and an empty maps of fuses
03:44:01 <Gurkenglas> Line 16 says we combine a line of the image and the line of Maybe Int we're keeping track of by zipping, and then scanning across it using the point function, and starting with a Nothing. (DÈj‡ vu? :P)
03:44:39 <Gurkenglas> The point function takes two neighbors that possibly herald a region in that direction, and combines them
03:46:35 <Gurkenglas> Line 18 says that the ensuing computation can invoke the magic word "guard" (among others) to return Nothing (and some other nice Maybe stuff), and otherwise looks like the Maybe type constructor isn't in the signature
03:47:00 <Gurkenglas> Line 19 says that we only care for these coordinates if they even contain a point (Otherwise, we return Nothing.)
03:47:28 <Gurkenglas> Line 20 looks at what/how many regions the neighbors herald
03:47:47 <Gurkenglas> Line 21 says "if none, make a new one and return its index. (remember to give a new index next time!)"
03:48:21 <Gurkenglas> Line 22 says "if one, return that one. Unambigious!"
03:49:05 <Gurkenglas> Line 23 finds that two regions must be fused, and "zoom fuses" takes a monadic state action on the small type Fuses and turns it into a monadic state action on the big type S
03:49:56 <Gurkenglas> Line 24 goes through previous fuses to find the main names of the regions we're fusing
03:50:43 <rcat> is Hastache supposed to support optional values in the context with Maybe types? :/
03:51:21 <Gurkenglas> (We're sweeping across the plane right-to-left, and across the line bottom-to-top)
03:51:30 <Gurkenglas> Line 25 finds all the nonmain names of the one from the bottom
03:52:09 <Gurkenglas> Line 26 inscribes that the region from the bottom is now subordinate to the region from the right
03:53:01 <Gurkenglas> Line 27 adds all the names of the bottom region into the list of nonmain names of the region from the right
03:53:34 <Gurkenglas> Line 28 says that this point belongs to the main name of the region from the right
03:54:06 <Gurkenglas> (Hmm maybe I should use the original name coming immediately from the right here.)
03:54:41 <Gurkenglas> (I also should take the main names of the regions before seeing whether they are the same one with the nub in line 20
03:54:45 <Gurkenglas> *)
03:55:42 <Gurkenglas> at i is a lens from a map into Just the value at key i. (Nothing if there is none)
03:56:55 <Gurkenglas> non S.empty replaces Nothing with a default value
03:57:17 <Gurkenglas> (As a lens, so it doesn't actually do any replacing, it just treats Nothing and the default value as the same)
03:57:58 <Gurkenglas> (Reload.)
03:58:38 <Gurkenglas> Gotta go. Be back in like 3-4 hours probs
03:58:51 <tomus> Gurkenglas: thank you
04:00:47 <Gurkenglas> (Reload.)
04:21:50 <Alcherk> @help
04:21:50 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:21:58 <Alcherk> @list
04:21:58 <lambdabot> What module?  Try @listmodules for some ideas.
04:22:06 <Alcherk> @help list
04:22:07 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
04:22:16 <Alcherk> @listmodules
04:22:17 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
04:26:50 <hellofunk> reading up on dependent types is quite interesting. seems to be an active area of research. eventually, you end up with a type system that extends all the way to the value level
04:27:29 <Big_G> How can I make the following line work?
04:27:30 <Big_G> > map 4 $ map (*) [1..10]
04:27:31 <lambdabot>      Could not deduce (Enum a0)
04:27:31 <lambdabot>      from the context (Enum a, Num a, Num ((a -> a) -> b))
04:27:31 <lambdabot>        bound by the inferred type for ‚Äòe_14110‚Äô:
04:32:45 * hackagebot turing 0.1.1 - A simple simulator for Turing machines  https://hackage.haskell.org/package/turing-0.1.1 (SebastianPoeplau)
04:38:31 <SK0> Big_G what is it you want to do?
04:38:38 <SK0> > map (* 4) [1..10]
04:38:39 <SK0> ?
04:38:39 <lambdabot>  [4,8,12,16,20,24,28,32,36,40]
04:38:53 <Big_G> SK0, I figured it out. I wanted
04:39:09 <Big_G> > map ($ 4) $ map (*) [1..10]
04:39:10 <lambdabot>  [4,8,12,16,20,24,28,32,36,40]
04:39:47 <SK0> that's possible too, but why not the simpler map (* 4) ?
04:40:50 <Big_G> I'm trying to create a filter for armstrong numbers where that number won't always be 4
04:41:55 <SK0> > let foo x = map (* x)
04:41:56 <lambdabot>  <no location info>: not an expression: ‚Äòlet foo x = map (* x)‚Äô
04:42:02 <SK0> > foo x = map (* x)
04:42:03 <lambdabot>  <hint>:1:7: parse error on input ‚Äò=‚Äô
04:42:10 <lpaste> Pro9 pasted ‚ÄúHow to put restrictions on the value quickcheck uses for testing‚Äù at http://lpaste.net/6326315625316614144
04:42:18 <ski> @let foo x = map (* x)
04:42:20 <lambdabot>  Defined.
04:42:23 <SK0> cheers
04:42:34 <SK0> > foo 4 [1..10]
04:42:36 <lambdabot>  [4,8,12,16,20,24,28,32,36,40]
04:43:06 <SK0> maybe I'm misunderstanding your needs Big_G
04:43:31 <Big_G> SK0, I don't think I understand my needs so no worries
04:43:47 <SK0> but the number being variable doesn't seem to warrant the "map ($ x) $ map (*)" stuff
04:44:16 <ski> Pro9 : you can use `==>' to add preconditions on the test data
04:45:12 <ski> Pro9 : also, instead of `(l,r) = ...' you could have `(l,_:r)' (removing the `tail')
04:46:02 <ski> Pro9 : `prop_ReplaceElementAtIndex list (index, value) = not (null list) ==> ...' ..
04:47:10 <Pro9> ski: Going to try and include your suggestions and see if I can get it to work
04:47:36 <SK0> Big_G, if you need any more help feel free to ask
04:47:47 <Big_G> Will do. Much appreciated
04:52:57 <Pro9> Ski: When I try to add the precondition: not (null list) ==> .... , I get the error message: Couldn't match expected type ‚ÄòBool‚Äô with actual type ‚ÄòProperty‚Äô  not sure what I did wrong?
04:55:22 <simon_> has anyone made an LR(k) parser generator library?
05:02:20 <Alcherk> @help
05:02:20 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:03:12 <Pro9> ski: accidentially trypes your username wrong, but I had some trouble adding the precondition
05:05:10 <lpaste> Pro9 revised ‚ÄúHow to put restrictions on the value quickcheck uses for testing‚Äù: ‚Äúski: my attempt at adding the not null precondition‚Äù at http://lpaste.net/6326315625316614144
05:10:06 <bollu> braid is turing complete, for anyone who cares. I think that is extremely cool :O (http://arxiv.org/abs/1412.0784)
05:17:46 * hackagebot tasty-golden 2.3.0.2 - Golden tests support for tasty  https://hackage.haskell.org/package/tasty-golden-2.3.0.2 (RomanCheplyaka)
05:21:51 <ski> Pro9 : you must change the type signature
05:22:30 <ski> (replace `Bool' with `Property')
05:24:16 <augur> is there a monad for logic program (not logicT!) that uses metavariables and that sort of thing?
05:24:47 <augur> something that's prolog-ish in how it solves things by refining possible solutions through a not-quite-unification process?
05:28:40 <dipsoxo> h
05:32:00 <jakub> Hello, I wanted to create a simple graphical app that stretches over the whole screen horizontaly, features an image a text entry field and a label, the app should statefully consume text entered to the field and respon by modifying the label. What haskell libraries would you suggest for the GUI part? Thank you
05:32:29 <jakub> Oh and the target platform is linux/macos/bsd/...
05:32:47 * hackagebot tasty 0.11.0.1 - Modern and extensible testing framework  https://hackage.haskell.org/package/tasty-0.11.0.1 (RomanCheplyaka)
05:33:24 <saulzar_> jakub, For a native app? Probably gtk
05:33:52 <saulzar_> Though maybe gtk is iffy on osx
05:34:14 <jakub> well osx is not that important for me personally
05:34:29 <saulzar_> Qt is another option, there is an HsQML
05:34:29 <jakub> linux is the most important platform from those i listed
05:34:53 <saulzar_> gtk is probably the most well used UI library in Haskell for native interfaces
05:36:05 <jakub> ok, why I was asking is that 1) I had problems installing gtk3 via cabal, 2) I wouldnt mind learning about maybe much better ways to do GUI (FRP?), 3) The app is rather simple so maybe large GUI libraries are an overkill.
05:36:19 <jakub> but gtk was what I sort of expected to be the best choice afterall
05:36:30 <jakub> let me retry installing it
05:37:59 <jakub> yes, this is what I get: http://pastebin.com/raw.php?i=zr3J8est (not much helpful, is it?)
05:38:40 <jakub> I tend to have problems with cabal package dependencies :/
05:39:24 <saulzar_> Hmm
05:39:46 <saulzar_> That's something to do with the gtk preprocessor not cabal
05:40:07 <niez> jakub: maybe you need to install gtk dev packages using system package manager first?
05:40:40 <jakub> niez: done :/ I am on gentoo
05:41:35 <Pro9> ski: ye I tried that but it didnt seem to work first, but if I changed from "generic" variables to int and lists of int, it compiled. [a] -> (Int, a) -> Property did not compile, [Int] -> (Int, Int) -> Property did though
05:42:06 <jakub> niez: gtk+-3.14.13 is installed
05:42:47 * hackagebot tasty-quickcheck 0.8.4 - QuickCheck support for the Tasty test framework.  https://hackage.haskell.org/package/tasty-quickcheck-0.8.4 (RomanCheplyaka)
05:42:52 <saulzar_> http://tryinghaskell.blogspot.co.nz/  <- at least one person has the same error jakub ..
05:43:00 <niez> jakub: gtk+ is a c++ library, haskel uses gtk (plain C)
05:43:51 <jakub> niez: no its not
05:44:02 <saulzar_> jakub, try installing latest gtk2hs-buildtools first
05:44:04 <jakub> niez: the `+` has nothing to do with c++
05:44:12 <jakub> saulzar_: also done
05:45:12 <jakub> saulzar_: oh but maybe it broke for some reason, i will reinstall
05:46:08 <jakub> saulzar_: why does `cabal info gtk2hs-buildtools` keep reporting unknown installed version :/?
05:46:50 <saulzar_> Hm, maybe because it's an executable only
05:47:37 <saulzar_> What does gtk2hsC2hs --version say?
05:47:58 <jakub> saulzar_: "C->Haskell Compiler, version 0.13.13 (gtk2hs branch) "Bin IO", 27 May 2012"
05:48:33 <saulzar_> Hm, it's the same as I have.
05:48:55 <orion> thoughtpolice: Hey there. You around?
05:48:56 <saulzar_> Are you using a sandbox?
05:49:11 <jakub> how can I tell?
05:50:20 <saulzar_> If you set one up. To make a sandbox you just find/make a directory somewhere and inside it type "cabal sandbox init"
05:50:38 <jakub> no i did not do that
05:50:43 <saulzar_> Then whenever you use caball install in that directory it will install to a local sandbox 
05:50:52 <jakub> i see
05:51:02 <saulzar_> Which usually makes installing packages easier because they don't tend to conflict with other versions on the same system
05:51:14 <saulzar_> I don't _think_ what you're seeing is anything to do with that
05:51:16 <jakub> well i dont have much installed
05:53:38 <jakub> ok, so now I did cabal install glib --reinstall --force-reinstalls and gtk now fails because of pango file not glib file ... seems related
05:54:20 <ski> Pro9 : oh, i didn't notice. you have to add the constraint `Arbitrary a'
05:57:16 <ski> Pro9 : er, actually no, i'm confused. i think just `Eq a => [a] -> (Int, a) -> Property' should work fine, for `prop_ReplaceElementAtIndex'
05:58:06 <ChristianS> hm, with ghc 7.10 i get "No instance for (Foldable t5) arising from a use of ‚Äòelem‚Äô" when doing  ch `elem` "string-literal"  (OverloadedStrings extension is on)
05:58:08 <jakub> saulzar_: sorry, my network connection sucks
05:58:29 <ChristianS> is there a better way to fix that than adding :: String to each of the "string-literals" ?
05:58:33 <bennofs> ChristianS: what is `ch`?
05:58:37 <bennofs> :t elem
05:58:38 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
05:58:41 <ChristianS> bennofs: Char
05:58:42 <jakub> saulzar_: I reinstalled glib cairo pango gio. Lets see whats broken next :)
05:58:57 <saulzar_> jakub, Nice, sounds like progress - I wonder what was the problem...
05:59:05 <bennofs> ChristianS: oh, no, I don't think there is a better way, short of defining elemStr = elem with a restricted type signature
05:59:20 <ski> Pro9 : you need `Eq a' since you're comparing list elements for equality. and you need to return a `Property' since `==>' adds some extra info (apart from whether the test succeeded or failed, it can not also end as "inadmissible", meaning that the given input doesn't satisfy your precondition. so a plain `Bool' doesn't suffice to express this)
05:59:50 <ski> Pro9 : but the actual generation of test cases happens elsewhere, so you shouldn't need `Arbitrary a' here
06:00:09 <ChristianS> bennofs: ah i had just considered the elemStr thing. guess i'll go that route as it happens in multiple places.
06:00:24 <jakub> saulzar_: when one produces a binary will it depend only on the c library or will there be dependancies on the haskell binding library as well?
06:00:28 <Pro9> Ski: ahha, I wasnt really sure what a property was, I managed to solve it using "a", I'll update the "lpaste"
06:00:29 <bennofs> ChristianS: you could also define str :: String -> String; str = id
06:00:38 <bennofs> ChristianS: then you can write  ch `elem` str "string-literal"
06:00:40 <ski> Pro9 : just checked. at least here, `prop_ReplaceElementAtIndex :: Eq a => [a] -> (Int, a) -> Property' typechecks ok
06:00:51 <bennofs> ChristianS: and you can use str with other functions as well
06:00:55 <saulzar_> jakub, I think the haskell library is static in 7.6
06:01:01 <jakub> saulzar_: great, gtk got through!
06:01:09 <ChristianS> bennofs: hmm, would that involve any run-time overhead (just curious) ?
06:01:14 <lpaste> Pro9 revised ‚ÄúHow to put restrictions on the value quickcheck uses for testing‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/6326315625316614144
06:01:32 <bennofs> ChristianS: very likely not if you compile with even just a little bit of optimization, since GHC will inline & eliminate the id
06:01:38 <ski> Pro9 : satisfied ?
06:01:49 <ChristianS> bennofs: fine, good idea
06:02:09 <Pro9> ski: yes, it works great, thanks for the help :)
06:03:57 <ski> Pro9 : sorry for the intermittency. i was occupied
06:04:01 <jakub> saulzar_: is there anywhere any kind of documentation to gtk3 haskell?
06:04:44 <Bez_> @src Data.Set.delete
06:04:44 <lambdabot> Source not found. :(
06:04:54 <Bez_> :m + Data.Set
06:04:57 <saulzar_> Not sure - there's the haddocks on hackage: https://hackage.haskell.org/package/gtk
06:05:10 <Bez_> @src Data.Set.delete
06:05:10 <lambdabot> Source not found. The more you drive -- the dumber you get.
06:05:14 <saulzar_> gtk haskell website seems down
06:05:36 <ski> @where src
06:05:36 <lambdabot> The fixed database for the `src' lambdabot command is at <https://github.com/lambdabot/lambdabot/blob/master/lambdabot/State/source>
06:05:40 <ski> Bez_ ^
06:10:37 <jakub> saulzar_: thank you gtk seem to work ;)
06:11:34 <saulzar_> Looks like there's some tutorials around - e.g. http://www.muitovar.com/gtk2hs/chap1.html
06:11:52 <saulzar_> No prob :)
06:14:07 <tomus> How to concatenate [State s [Int]] into State s [Int]. mconcat right?
06:14:17 <Bez_> Ah come on ... 
06:14:19 <Bez_> thx ski
06:17:13 <ski> @type liftM concat . sequence :: [State s [Int]] -> State s [Int]  -- tomus
06:17:14 <lambdabot> [State s [Int]] -> State s [Int]
06:17:39 <ski> @type sequence :: [State s [Int]] -> State s [[Int]]
06:17:40 <lambdabot> [State s [Int]] -> State s [[Int]]
06:17:57 <ski> @type liftM concat :: State s [[Int]] -> State s [Int]
06:17:58 <lambdabot> State s [[Int]] -> State s [Int]
06:18:42 <tomus> ski: ah! I was thinking that I need sequence just now!
06:19:04 <ski> `fmap' would work just as well as `liftM'
06:22:56 <tomus> after applying sequence, my [State s [a]] became StateT [P.Point] Data.Functor.Identity.Identity [[a]]
06:23:07 <tomus> s = [P.Point]
06:23:14 <tomus> why is that?
06:23:53 <tomus> (I anticipated State [P.Point] [[a]])
06:25:18 <ahihi> State s a is an alias for StateT s Identity a
06:28:01 <tomus> ok, I'll have to read up on monad transformers after all
06:29:07 <ahihi> it's an implementation detail and not really necessary just for using State
06:29:11 <ahihi> but learning is always good!
06:31:00 * ski thinks it ought to be possible to give multiple definitions of a `newtype', as long as they all would expand to the same thing, after unravelling the body `newtype' a few times
06:31:39 <ski> so that you could have both
06:32:02 <ski>   newtype State s a = MkState (s -> (a,s))
06:32:03 <ski> and
06:32:24 <ski>   newtype State s a = StateFromT (StateT s Identity a)
06:32:26 <ski> at the same time
06:33:15 <ski> (hm, i suppose you actually would need deeper `newtype'-iso, not just at the body level)
06:34:42 <saulzar_> and instances?
06:35:17 <Pro9> if I want to express a,b,c,d > 0, is there a more consice way to express that than a>0 && b>0 ....
06:35:18 <ski> you'd have to manually make (or derive) instances, as usual
06:36:21 <saulzar_> How'd you distinguish between the State(s) ?
06:36:31 <ski> Pro9 : `all (> 0) [a,b,c,d]'
06:36:43 <ski> saulzar_ : i wouldn't. they'd be the same type
06:37:00 <Pro9> ski: thanks!
06:49:29 <deech> Hi all, I was trying to understand why my program was taking a while to compile so I passed `-v` and I get this long list of CPSZ. What does that mean?
06:49:44 <deech> That seems to be where it's spending most of it's time.
06:52:23 <indiagreen> meanwhile, I'm an idiot: I've spent a week writing tests and only now realised that my tests specify the behavior better than my rule files, and so my tests should *be* my rule files
06:52:50 * hackagebot app-settings 0.2.0.6 - A library to manage application settings (INI file-like)  https://hackage.haskell.org/package/app-settings-0.2.0.6 (EmmanuelTouzery)
06:53:00 <ski> programming-by-demonstration/example ?
06:53:01 <mrkgnao> I want to make a Haskell program to model polynomials.
06:54:22 <mrkgnao> I'm thinking of writing `data Term v = Term Coeff Var` for things like 3x^2. The `v` is a sort of "tag" to refer to the variable.
06:59:58 <ttt_fff> is there a library like threepenny-gui, but "auto works the same" both under GHC and GHCJS ?
07:06:02 <bennofs> ttt_fff: reflex-dom works under GHC and GHCJS, but requires webkitgtk to run on GHC which may be difficult to compile (especially on non-linux). Perhaps you could extend it to use a webbrowser instead of using webkitgtk directly?
07:06:29 <ttt_fff> bennofs: I'm on osx
07:06:36 <ttt_fff> what do I need to get reflex-dom to work?
07:07:51 * hackagebot engineering-units 0.0.2 - A numeric type for managing and automating engineering units.  https://hackage.haskell.org/package/engineering-units-0.0.2 (TomHawkins)
07:08:09 <bennofs> ttt_fff: hmm, I don't know, sorry. I have heard that the nix setup for reflex-dom + webkitgtk doesn't work on osx unfortunately :/
07:10:02 <suppi> ttt_fff, try this https://github.com/ryantrinkle/try-reflex
07:21:42 <suppi> I have a file, .DS_Store, I don't exactly know what its content is, what I try reading it using Data.Text.Lazy.IO.readFile it throws an exception. how can I handle that?
07:22:01 <suppi> when*
07:23:49 <indiagreen> suppi: it's some OS X file
07:24:05 <indiagreen> suppi: you probably can't read it because it's binary and not decodable as UTF-8
07:24:25 <indiagreen> suppi: try to read it as a ByteString, or perhaps just ignore it
07:25:05 <suppi> indiagreen, I want to handle that generically, is there a way to catch that exception?
07:25:32 <suppi> and like, return Nothing when something like this happens
07:25:45 <forker> Hi guys, could you please advise on what is happening in this case https://gist.github.com/anonymous/d764b135689d952887d3
07:25:45 <forker> and give some pointers for reading.
07:26:25 <indiagreen> suppi: you can read it as lazy ByteString and then use decodeUtf8' from here
07:26:29 <indiagreen> http://hackage.haskell.org/package/text-1.2.1.3/docs/Data-Text-Lazy-Encoding.html
07:26:45 <suppi> indiagreen, thanks, I will try that.
07:28:10 <indiagreen> forker: I think it's because your ‚ÄúcreatePool‚Äù function can't have a polymorphic type
07:28:16 <indiagreen> thanks to the monomorphism restriction
07:28:24 <indiagreen> either disable it or give it an explicit type signature
07:28:46 <indiagreen> to disable it, you can put {-# LANGUAGE NoMonomorphismRestriction #-} at the top of your file
07:30:44 <forker> duh, weasels.. tried it before - didn't work, but now it does! 
07:30:52 <forker> indiagreen: Thank you!
07:37:58 <forker> Ah, right, I tried it before for a different case: https://gist.github.com/anonymous/81b3d8998e9d20756058
07:38:31 <lpaste> vitalij pasted ‚ÄúString mingling‚Äù at http://lpaste.net/142208
07:40:51 <hc> I'm trying to use Data.ProtocolBuffers, but I get compiler errors when trying to use Enums:
07:40:57 <Gurkenglas> vitalij, remove line 9 and 11 and it should compile. I would inline line 12, replace "[x] ++ [y] ++" with "x : y :" and maybe replace lines 8 and 10 with [string1, string2] <- replicateM 2 getLine
07:41:07 <hc> No instance for (Foldable Last) arising from a use of `protobuf-0.2.1.0:Data.ProtocolBuffers.Encode.$gdmencode'
07:41:11 <hc> any hints? :-)
07:41:58 <Gurkenglas> Also you never use s, and your error stems from the first stdin line not being an integer
07:43:09 <vitalij> Thank you <Gurkenglas>
07:43:17 <anon_1234> hi
07:43:33 <anon_1234> i got this code and it is error 
07:43:34 <anon_1234> https://gist.github.com/acsudeep/11ecf653730c456a7d64
07:43:40 <anon_1234> for credit card validation
07:43:52 <anon_1234> doubleSecondEach is mistake
07:44:12 <anon_1234> instead of starting from second-to-last it is starting from last one
07:44:37 <Gurkenglas> hc, Last isn't Foldable, you'll have to unpack it into a Maybe if what you're trying to do is "fromMaybe mempty". Beyond that, paste your code on lpaste
07:44:41 <lpaste> hc pasted ‚Äúprotobuf work‚Äù at http://lpaste.net/142209
07:44:55 <hc> Gurkenglas: just did that
07:45:04 <hc> it's not the complete code but the extract that causes the erorr
07:45:21 <hc> If you comment line 6, it compiles fine
07:47:40 <Gurkenglas> hc, is that all of the compiler error? Can you paste all of it if not?
07:48:47 <lpaste> Pro9 pasted ‚ÄúNeed a little help figuring out why my generated value doesnt work in my quickcheck test‚Äù at http://lpaste.net/8161848759156736000
07:49:20 <lpaste> hc pasted ‚Äúcompiler error‚Äù at http://lpaste.net/142210
07:49:27 <hc> Gurkenglas: that's the compiler error ^^^
07:49:42 <Gurkenglas> anon_1234, line 16 double's the first number of its list, which is the last number of your digit sequence. You don't want to double a single number.
07:50:19 <Gurkenglas> Line 17 also doubles the first number, and doesn't double the second. Are you surprised that doesn't work?
07:51:12 <Gurkenglas> hc, ah, I see. You'll want to import https://hackage.haskell.org/package/protobuf-0.2.1.0/src/src/Data/ProtocolBuffers/Orphans.hs I guess?
07:51:30 <hc> hmm, will try that, thank you!
07:51:44 <Gurkenglas> (Or put "deriving instance Foldable Last" into your code if you don't mind orphans. Mind orphans :P!)
07:52:02 <hc> ah i think i am getting what is the root of the problem
07:52:13 <hc> if the field is optional, which value to use as a default
07:52:29 <hc> so if i make it non-optional i should be fine as is, right?
07:52:49 <Gurkenglas> Pro9, first of all I recommend capitalizing types
07:52:52 * hackagebot product-profunctors 0.6.3.1 - product-profunctors  https://hackage.haskell.org/package/product-profunctors-0.6.3.1 (tomjaguarpaw)
07:55:06 <lpaste> vitalij pasted ‚ÄúString mingling (second attempt)‚Äù at http://lpaste.net/142211
07:55:55 <lpaste> Gurkenglas annotated ‚ÄúString mingling (second attempt)‚Äù with ‚ÄúString mingling (second attempt) (annotation)‚Äù at http://lpaste.net/142211#a142212
07:56:27 <Gurkenglas> Your indentation was wrong. (Shame on you for using tabs. You are discouraged, because I am discouraging you.)
07:57:28 <vitalij> ok!
07:58:06 <vitalij> so two spaces are enough to indent
07:58:15 <Gurkenglas> One space is enough, you can also do 100
07:58:53 <hc> Gurkenglas: importing orphans did the trick, thanks again! :)
07:59:29 <Gurkenglas> And that, folks, is why we don't do orphan instances
07:59:43 <Gurkenglas> At least not in anything that someone other than you is to import
08:01:16 * osfamero1 reports hc to the child trafficking police
08:02:26 <Gurkenglas> Pro9, I'm reluctant to comment on that because it looks a certain sort of wrong that might be right with the correct extensions/imports... why do you think you can use genPos in a type signature?
08:04:04 <Pro9> Gurkenglas: I'm working on a better solution, I realised that putting genPos in a type signature was wrong
08:04:31 <Pro9> Gurkenglas:  I'm currently thikning that I should have Pos in the type signature, but instead use genPos in my function
08:07:53 * hackagebot aur 4.0.0 - Access metadata from the Arch Linux User Repository.  https://hackage.haskell.org/package/aur-4.0.0 (fosskers)
08:11:27 <ttt_fff> type in ./try-reflex, go off to get breakfast, expect to be built by time I return
08:11:45 <ttt_fff> wrong channel
08:13:06 * hackagebot clash-prelude 0.10 - CAES Language for Synchronous Hardware - Prelude library  https://hackage.haskell.org/package/clash-prelude-0.10 (ChristiaanBaaij)
08:13:08 * hackagebot clash-lib 0.6 - CAES Language for Synchronous Hardware - As a Library  https://hackage.haskell.org/package/clash-lib-0.6 (ChristiaanBaaij)
08:13:10 * hackagebot clash-systemverilog 0.6 - CAES Language for Synchronous Hardware - SystemVerilog backend  https://hackage.haskell.org/package/clash-systemverilog-0.6 (ChristiaanBaaij)
08:13:12 * hackagebot clash-verilog 0.6 - CAES Language for Synchronous Hardware - Verilog backend  https://hackage.haskell.org/package/clash-verilog-0.6 (ChristiaanBaaij)
08:13:14 * hackagebot clash-vhdl 0.6 - CAES Language for Synchronous Hardware - VHDL backend  https://hackage.haskell.org/package/clash-vhdl-0.6 (ChristiaanBaaij)
08:15:12 <Pro9> Gurkenglas: I managed to solve it with forAll, just to couble check: forAll genPos $ \(x,y) means that for every (x,y) use genPos to generate a values instead of the default generator?
08:16:41 <Gurkenglas> Your syntax is alien to me. I know \ as initiating a lambda expression. Unless you mean that that snippet goes before "-> <code using x and y>"
08:17:17 <bennofs> Pro9: it means: "use genPos to generate many values (x, y)"
08:17:56 <Pro9> Gurkenglas: ye, sorry if it was unclear, it goes before -> (code that uses x and y)
08:18:06 * hackagebot clash-ghc 0.6 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.6 (ChristiaanBaaij)
08:19:37 <Gurkenglas> If forAll genPos doesn't do eldritch things, x and y are going to be constant within each term - x + x can still be replaced by 2*x, that is.
08:20:08 <anon_1234> hey
08:20:30 <anon_1234> what is difference between (a . b) x and (a $ b) x
08:20:48 <Gurkenglas> :t (?a . ?b) ?x
08:20:48 <monochrom> that is a (b x) vs (a b) x
08:20:49 <lambdabot> (?a::b -> c, ?b::a -> b, ?x::a) => c
08:20:50 <hpc> (a . b) x expands to a (b x)
08:20:50 <Gurkenglas> :t (?a $ ?b) ?x
08:20:51 <lambdabot> (?a::r -> t -> t1, ?b::r, ?x::t) => t1
08:20:57 <hpc> (a $ b) x expands to (a b) x
08:22:29 <FreeFull> $ is id
08:22:54 <FreeFull> :t ($)
08:22:56 <lambdabot> (a -> b) -> a -> b
08:23:07 * hackagebot HGamer3D 0.6.2 - Toolset for the Haskell Game Programmer  https://hackage.haskell.org/package/HGamer3D-0.6.2 (PeterAlthainz)
08:24:12 <Gurkenglas> letlpaste can't handle TemplateHaskell? http://lpaste.net/142192
08:24:19 <Gurkenglas> @letlpaste 142192
08:24:19 <lambdabot>  Parse failed: Parse error: '
08:26:10 <flexfit> I'm having trouble understanding this datatype
08:26:13 <flexfit> newtype Matrix a = Mat ((Int,Int),(Int,Int) -> a)
08:26:25 <flexfit> Is the matrix being represented as a list of lists?
08:27:27 <Myrl> is there a function which does (
08:27:52 <Myrl> (\x -> many x *> many (notFollowedBy x))
08:28:28 <ggole> Why does ghci print some type variables as a, b, c etc and some as t, t1, t2 etc?
08:28:29 <Gurkenglas> "Matrix a" contains a pair of ints and a function from pairs of ints to a. I'd guess they stand for the size of the matrix and the values. Poor form by whoever wrote that.
08:29:10 <flexfit> Gurkenglas: What makes it poor form?
08:30:52 <Gurkenglas> flexfit, who knows what behavior those functions have outside the size of the Matrix. (Also that ought to be a record, not a pair, pairs are elegant for a handful of uses and beyond that tuples are seldom a good idea)
08:32:08 <tomus> my program doesn't return. how to quickly dianose the function it is stuck in?
08:32:59 <Gurkenglas> tomus, you can insert calls to trace. Generally you should avoid recursion where possible, or make the loops small where not
08:32:59 <flexfit> tomus: ghci does have a debugger. https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-debugger.html
08:33:39 <Gurkenglas> (Avoid recursion by using recursive functions other people wrote instead, like map or foldr. You're going to have trouble building an infinite loop from those)
08:34:02 <Gurkenglas> You can profile your code, and see where your program spends most of its time
08:34:25 <tomus> I want a poor man's profiler: where ctrl + c tells me where it was...
08:34:33 <tomus> flexfit: it's a complied program
08:34:57 <tomus> a guess a strack trace on ctrl c
08:35:04 <Gurkenglas> Myrl, https://hackage.haskell.org/package/parsec-3.1.7/docs/Text-Parsec-Combinator.html#v:notFollowedBy says it doesn't consume any input. Why would you stick it into many? (just for zero or one?)
08:35:08 <tomus> so that I can quicly go and fix what is broken
08:35:29 <Myrl> Gurkenglas: Oops, I didn't realize that.
08:35:57 <Myrl> Gurkenglas: What's the consuming version of notFollowedBy?
08:36:11 <Myrl> Actually, I just realized something, what I'm doing is just sepBy.
08:36:27 <flexfit> I'm having trouble trying to extract data from this type. newtype Matrix a = Mat ((Int,Int),(Int,Int) -> a). What would be the syntax that I need in order to extract data from the first tuple? I've been trying something like foo (Mat a _ _ ) = a, but it's not compiling.
08:36:33 <Myrl> To be more exact, one iteration of sepBy.
08:37:09 <geekosaur> flexfit, it's a tuple
08:37:17 <exio4> flexfit: (Mat (t,_)), if you are newtyping a tuple, you might want a normal datatype instead
08:37:18 <geekosaur> Mat (a,_)
08:37:28 <Gurkenglas> Or you could add record names and do it sanely.
08:37:58 <Gurkenglas> (Oops, ninja'd)
08:38:10 <gfixler> I'm having trouble grokking how (->) works here: category'Function :: CategoryI (->) category'Function
08:39:06 <gfixler> it looks like a partial application (category'Function ->), but I've never seen a function used in its own type
08:39:33 <gfixler> oh wait, I think I'm joining lines that shouldn't be joined
08:39:50 <gfixler> it's actually just: category'Function :: CategoryI (->)
08:49:58 <nkaretnikov> how can i encode the same thing so that it typechecks?  https://gist.github.com/nkaretnikov/b5a626d529c871318935
08:51:51 <bennofs> nkaretnikov: use data SomeNat where SomeNat :: forall n. Nat n -> SomeNat   (using -XGADTs) or data SomeNat = forall n. SomeNat (Nat n) (using -XExistentialQuantificiation)
08:52:44 <nkaretnikov> bennofs: i want to see what number i have in its type
08:53:08 <nkaretnikov> this nat thing is just my attempt to merge data Zero and data Succ n
08:53:10 <nkaretnikov> together
08:59:31 <camm_v222> Hello everyone. I want to work with the haskell-mpi library. However, I'm getting this error message: "Missing dependencies on foreign libraries:* Missing C libraries: mpi, open-rte, open-pal". Do you know what can I do?
09:01:13 <pavonia> camm_v222: Install the dev-versions of these libraries
09:03:28 <camm_v222> Is because I have installed them, right? :( Sorry, about the silly question.
09:04:33 <pavonia> Either you haven't installed them or cabal isn't finding them
09:05:35 <pavonia> If you have installed them, you can add "--extra-lib-dirs=path-to-mpl" to cabal configure
09:08:28 <camm_v222> I'll try that. Thanks.
09:21:20 <julianleviston> Is there a way to load code to be interpreted inside a module with Hint? Like, say I have a string with five modules in it? From what I‚Äôve seen, Hint doesn‚Äôt let you directly work with modules other than via the filesystem...
09:24:38 <julianleviston> or if anyone knows of a better way to do that, mueval or something else, that‚Äôd be fine :)
09:35:28 <breadmonster> Hey guys/
09:36:21 <athan> breadmonster: sup
09:36:31 <breadmonster> athan: What's up?
09:37:50 <athan> breadmonster: Seeing how purescript turns a hindley-milner, pure language with multiparam type classes and stuff, and turns it into javascript in a "readable", minimally AST manipulating way. PureScript is interesting... how about you?
09:38:13 <breadmonster> uhh i lyk pizza lol
09:39:43 <julianleviston> Is there a good way to namespace things other than modules? I essentially want to load up some code with Hint, and I want to keep small pieces modular and separate from each other...
09:40:31 <athan> julianleviston: You can re-export modules... :D
09:40:52 <julianleviston> athan: what is that like?
09:41:02 <athan> the nice thing about imports is that name clashes only happen when you use terms, also
09:41:26 <hiptobecubic> I have a system that can use multiple backends. I was about to implement it as data Backend = B { op1 :: String -> IO a, op2 :: Whatever -> Output } etc, and then just create values of that type with the right functions plugged in. It seems to me, though, that this is just directly reimplementing typeclasses. Is there a reason to prefer one over the other?
09:41:34 <athan> julianleviston: module (Foo (..), bar, module X) where; import SomeModule as X; data Foo = Foo (); bar = undefined
09:41:52 <hpc> hiptobecubic: your current approach lets you dynamically pick a different backend
09:41:55 <athan> where the n-tuple after `module` states the exports
09:42:22 <julianleviston> athan: oh‚Ä¶ what I‚Äôm talking about is loading code into Hint from a string, so not from a File.
09:42:50 <hpc> hiptobecubic: a type class approach would let you specify the common API and keep stricter type-checking
09:42:52 <athan> :x
09:42:54 <julianleviston> athan: I pretty much want programmatic modules, but fairly sure Haskell doesn‚Äôt let you do that
09:42:58 <tyrion-mx> Hello, why I can define a function as ":: a -> Int" and it will take anything as a parameter, but I cannot do "() :: a" ?
09:43:14 <Fuuzetsu> because () :: ()
09:43:28 <athan> left-to-right
09:43:43 <hiptobecubic> hpc, why would typeclasses have stricter type checking? You're still specifying the API when you define the data type
09:43:44 <athan> :: = "has a type"
09:43:53 <athan> or "can have a type"
09:44:10 <athan> or "can has a typeburger"
09:44:12 <julianleviston> tyrion-mx:  the type of empty tuple (data) is empty tuple (type)
09:44:14 <hpc> hiptobecubic: suppose for instance, instance Backend DBBackend
09:44:14 <tyrion-mx> I am not sure I understand
09:44:20 <hpc> hiptobecubic: and instance Backend FileBackend
09:44:28 <julianleviston> tyrion-mx: ask in words and it might be easier for all.
09:44:33 <hpc> DBBackend and FileBackend are different types
09:44:36 <tyrion-mx> yes, sorry, I will try
09:44:48 <hpc> whereas dbBackend = Backend {op1 = HDBC.connect, ...}
09:44:53 <julianleviston> tyrion-mx: no need for apologies :)
09:44:57 <hpc> fileBackend = Backend {op1 = openFile, ...}
09:44:59 <hpc> those are the same type
09:45:14 <tyrion-mx> for example in java I think I can cast anything to Object, and if I have a function that takes an Object I can pass (almost) anything to it
09:45:16 <hpc> depends on what sort of flexibility and control you care about having
09:45:25 <tyrion-mx> here it is the same, but I cannot upcast stuff?
09:45:48 <julianleviston> tyrion-mx: what on earth do you mean? This isn‚Äôt OOP.
09:45:54 <hpc> hiptobecubic: welcome to one of the harder design decisions you have to make in haskell
09:46:15 <hiptobecubic> hmm
09:47:15 <tyrion-mx> julianleviston, I was thinking that if I can pass () as a function that expects "a" as a type, I might as well "store" it into a variable of type "a"
09:47:20 <hiptobecubic> hpc, ah I see. So with the typeclass approach, you could still specify functions that work explicitly on FileBackend, which would not accept DBBackend
09:47:30 <julianleviston> tyrion-mx: () means ‚Äúnothing at all‚Äù in a sense.
09:47:47 <julianleviston> tyrion-mx: so start with that. It‚Äôs the empty tuple.
09:47:51 <hiptobecubic> hpc, why do typeclasses prevent you from selecting one dynamically at runtime though?
09:48:04 <tyrion-mx> ok
09:48:15 <julianleviston> tyrion-mx: so what are you trying to actually do?
09:48:19 <hpc> they don't totally prevent you from doing so, but you have to do it more explicitly
09:48:41 <hpc> because you're dealing with two different types now instead of just two values of the same type
09:48:53 <hpc> it's like making something deal with both Float and Double values
09:48:54 <tyrion-mx> julianleviston, nothing in particular, I just had a moment of confusion I guess
09:49:07 <hpc> when you probably just want it to work with both 0.0 and 1.0
09:49:12 <tyrion-mx> thank you :D
09:49:16 <julianleviston> tyrion-mx: no worries. Feel free to ask as many questions as you like
09:49:19 <flexfit> When considering this datatype : newtype Matrix a = Mat ((Int,Int),(Int,Int) -> a) and this function signature: at :: (Matrix a) -> (Int, Int) -> a. Is the at function returning an element of the matrix?
09:49:21 <hiptobecubic> hpc, right but the idea is that you're writing functions like "foo :: Backend a => a -> Whatever", no?
09:49:44 <hiptobecubic> as opposed to "foo :: Backend -> Whatever"
09:50:02 <shachaf> flexfit: It's your type. You tell us.
09:50:04 <julianleviston> athan:  hmmm just found this, which isn‚Äôt too promising https://ghc.haskell.org/trac/ghc/wiki/Records/NameSpacing
09:50:11 <bernalex> I have an educational type List a, and want to use quickcheck for solutions/property laws. what's a good thing to derive to get fromList for free?
09:51:46 <hpc> hiptobecubic: yeah
09:51:55 <hpc> hiptobecubic: and eventually at a low enough level your functions won't care
09:52:15 <hpc> hiptobecubic: but like, you can't pass around [Backend a => a], or whatever
09:52:33 <hpc> which doesn't seem like a useful operation in this example, but something to keep in mind
09:53:16 <hiptobecubic> hpc, ah. Where that list is heterogenous?
09:53:26 <hpc> yep
09:53:30 <hiptobecubic> and not just Backend a => [a]
09:53:34 <hiptobecubic> I see
09:54:49 <julianleviston> crap. It looks like GHC Haskell modules are very tied to the filesystem.
09:54:49 <hiptobecubic> Hmmm.... I'm torn :)
09:56:49 <hpc> for the case of your backend, it might be that you really don't care at all, and recompiling to switch backends isn't a big deal
09:56:51 <hiptobecubic> I will at some point need a way for the user to choose a backend to use, which to me implies some kind of function "Backend a => IO a" I guess? But does that really work? I'll still have to wrap it in sum kind of sum type in order to have the function actually be able to return eithr one
09:57:08 <bernalex> meh. I can just fold Cons Nil, I guess.
09:57:08 <hpc> or you can case out each individual type
09:57:10 <hiptobecubic> hpc, in this particular case, it should be switchable at run time
09:57:46 <hiptobecubic> (it's a front end to translation services like google translate and users (that's me) will want to compare outputs)
09:59:19 <bernalex> hmm this isn't quite right
09:59:22 <bernalex> instance Arbitrary a => Arbitrary (L.List a) where
09:59:24 <bernalex>   arbitrary = foldr L.Cons L.Nil <$> arbitrary
09:59:26 <bernalex> any one have an idea what I really want?
10:01:15 <hpc> hiptobecubic: think aobut the switch operation
10:01:23 <bernalex> I want to make an arbitrary list and then turn it into my List
10:01:36 <hpc> switchBackend :: Backend -> IO whatever
10:01:50 <hpc> or whatever monad you're working in
10:02:00 <hiptobecubic> wouldn't switchBackend *produce* the selected backend?
10:02:08 <hiptobecubic> rather than consume the old one?
10:02:19 <UncleAlf> I got a property to test a function that takes an int, how do I specify the range to test with in quickcheck?
10:02:21 <fizruk_> bernalex: don't you have fromList?
10:02:46 <fizruk_> bernalex: like in `arbitrary = L.fromList <$> arbitrary`
10:02:47 <bernalex> fizruk_: it's my own List class. foldr L.Cons L.Nil *is* fromList.
10:02:51 <hiptobecubic> More like, data Backend = G Googles | B Bing;  selectBackend :: IO Backend?
10:03:26 <bernalex> fizruk_: i.e. if I were to write fromList it would be fromList = foldr L.Cons L.Nil.
10:03:37 <hpc> hiptobecubic: it takes the new backend and replaces whatever is currently there
10:03:55 <hpc> :t put -- similar to this
10:03:56 <lambdabot> MonadState s m => s -> m ()
10:03:58 <hiptobecubic> oh.....
10:04:02 <hiptobecubic> hmm yes
10:04:03 <fizruk_> bernalex: so doesn't that work?
10:04:07 <hpc> i would expect, at least
10:04:27 <bernalex> fizruk_: Tests.hs|114 col 39 error| Couldn't match expected type ‚Äò[a]‚Äô
10:04:29 <bernalex> ||             with actual type ‚ÄòTest.QuickCheck.Gen.Gen a2‚Äô
10:04:53 <fizruk_> :t arbitrary
10:04:55 <lambdabot> Arbitrary a => Gen a
10:05:12 <fizruk_> :t foldr (:) [] <$> arbitrary
10:05:14 <lambdabot> (Foldable t, Arbitrary (t a)) => Gen [a]
10:05:58 <fizruk_> bernalex: maybe your foldr is ambiguous?
10:06:15 <bernalex> yeah. or <$> is? I'm not sure
10:06:17 <fizruk_> bernalex: I mean, it's for Foldable, not []
10:07:34 <bernalex> fizruk_: http://lpaste.net/515927676507127808
10:08:06 <fizruk_> bernalex: should be (arbitrary :: Gen [a])
10:08:21 <freinn> hi! when I try to read negative numbers from strings, it gives me an error like *** Exception: Char.intToDigit: not a digit -2. The code is in http://lpaste.net/142224
10:08:34 <tomus> @hoogle Vector a -> a -> Vector a
10:08:37 <lambdabot> Warning: Unknown type Vector
10:08:38 <lambdabot> Prelude asTypeOf :: a -> a -> a
10:08:38 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
10:09:27 <hiptobecubic> hpc, I think i'll go with the plain data type for now and see how it turns out. Thanks for your help1
10:09:31 <hiptobecubic> help!*
10:10:12 <fizruk_> bernalex: or use fromList, because fromList :: [a] -> L.List a, not fromList :: Foldable t => t a -> L.List a
10:11:24 <bernalex> fizruk_: yeah fixed it, thanks
10:11:27 <bernalex>   arbitrary = (foldr L.Cons L.Nil :: [a] -> L.List a) <$> arbitrary
10:11:28 <bernalex> ^ works
10:12:03 <fizruk_> bernalex: define fromList :)
10:15:06 <julianleviston> freinn: got the failing data?
10:16:00 <freinn> julianleviston: input: crearTimeStampCambio ["-200","3","4"] output: 00:04:03,*** Exception: Char.intToDigit: not a digit -2
10:19:39 <julianleviston> freinn: where‚Äôs intToDigit being called?
10:20:27 <julianleviston> freinn: from reads?
10:20:54 <freinn> julianleviston I have other functions in show that may be the problem
10:21:14 <Profpatsch> Is it a good idea to define EQ to only look at one field in my datatype?
10:21:15 <glguy> > (reads :: ReadS Int) "-200"
10:21:17 <lambdabot>  [(-200,"")]
10:21:36 <julianleviston> freinn: you might need to look to see where the bug is at?
10:22:01 <glguy> Profpatsch: It can be OK if you hide the data constructor for your datatype and ensure that the only ways to values of it ensure your notion of equality is maintained
10:22:15 <freinn> julianleviston http://lpaste.net/142225
10:23:21 <glguy> > (-200)`div`100
10:23:22 <lambdabot>  -2
10:23:30 <glguy> and you're calling intToDigit on that
10:24:05 <Profpatsch> glguy: Not sure I get that. Why do I need to hide the constructor?
10:24:54 <glguy> Because if your Eq instance is going to be valid you'll need to enforce that the one field you're testing somehow captures equality for the whole type
10:25:09 <Profpatsch> glguy: Ah, the laws of EQ.
10:25:20 <Profpatsch> Okay, thanks.
10:28:58 <cow_2001> what're some good haskell source code prettifiers?
10:31:15 <Gurkenglas> Gurkenglas
10:33:13 <bennofs> cow_2001: the only one I know is stylish-haskell
10:41:54 <ngastyle> hello everyone!
10:42:01 <Hijiri> hi ngastyle 
10:43:10 <ngastyle> i was expecting a lot more chatter on this channel, all I see are status updates about people joining and quitting, is this normal (at this hour)?
10:43:29 <flexfit> I guess it's slow right now.
10:44:07 <ngastyle> it's worth noting that this is my first time using IRC, so I don't really have baseline for comparison, still calibrating
10:44:11 <fizruk_> ngastyle: also, it's Saturday
10:45:13 <julianleviston> ngastyle: it *is* pretty quiet right now
10:46:35 <flexfit> I know that the flip function flips the 2 arguments for a function. Is there a similar function that flips the numbers in a tuple for a function? So if I want my function to take another function that takes a tuple as it's input and flip the numbers in the tuple.
10:47:02 <julianleviston> flexfit:  f (x,y) = (y,x)
10:47:34 <bennofs> :t swap
10:47:35 <lambdabot> (a, b) -> (b, a)
10:47:43 <julianleviston> bennofs: nice :)
10:47:43 <bennofs> > Data.Tuple.swap (1,4)
10:47:45 <lambdabot>  (4,1)
10:48:22 <julianleviston> ohhh
10:48:28 <julianleviston> that‚Äôs not what s/he was asking
10:48:40 <fizruk_> :t (. swap)
10:48:41 <lambdabot> ((b, a) -> c) -> (a, b) -> c
10:49:00 <ski> ngastyle : ok. regarding technical IRC channels in general (and slow ones in particular), note that you should wait at least perhaps half an hour (preferably hours) after a question/comment, before giving up
10:49:13 <fizruk_> > (fst . swap) (1, 2)
10:49:15 <lambdabot>  2
10:49:31 <julianleviston> fizruk_: of course :)
10:49:43 <ngastyle> ski: got it.
10:49:47 * julianleviston eats humble pie
10:50:01 <ayc> hello
10:50:17 <ski> ngastyle : many people are logged in to IRC all hours of the week, but don't look at IRC all the time, so they might not notice you at first
10:50:36 <athan> @tell Welkin PureScript may be wrong then, in that they've replaced << with <*
10:50:37 <lambdabot> Consider it noted.
10:51:34 <geekosaur> er? there is no <<
10:51:45 <fizruk_> :t (<<)
10:51:47 <lambdabot>     Not in scope: ‚Äò<<‚Äô
10:51:47 <lambdabot>     Perhaps you meant one of these:
10:51:47 <lambdabot>       data constructor ‚ÄòSeq.:<‚Äô (imported from Data.Sequence),
10:52:05 <fizruk_> :t (=<<)
10:52:07 <lambdabot> Monad m => (a -> m b) -> m a -> m b
10:52:15 <shachaf> lambdabot: That's the same thing geekosaur said, but in three lines instead of one.
10:52:23 <athan> geekosaur: If I could import Control.Monad from psci, then I would tell you for sure >_>
10:52:24 <ski> ngastyle : also, people are often shy about announcing themselves in connection to a question, if they don't know whether they'll have a good chance of being able to help. hence you should not ask whether you can ask, you should not ask if there's anyone who knows X. instead ask your specific question, with relevant background detail, and then wait. it sometimes happens that people answer the next day, even (mostly for slow channels, though), if only the as
10:52:33 <athan> geekosaur: https://github.com/purescript/purescript/wiki/Differences-from-Haskell#where-is--from-haskell
10:52:41 <ski> ngastyle : er, cut off near "it sometimes happens that people answer the next day, even (mostly for slow channels, though), if only the asker is still connected"
10:52:56 <athan> :t (Control.Monad.<<)
10:52:57 <lambdabot>     Not in scope: ‚ÄòControl.Monad.<<‚Äô
10:52:57 <lambdabot>     Perhaps you meant one of these:
10:52:57 <lambdabot>       ‚ÄòControl.Monad.=<<‚Äô (imported from Control.Monad),
10:53:02 <athan> ?
10:53:23 <julianleviston> ngastyle: that‚Äôs assuming you have a question :)
10:53:35 <ski> ngastyle : just mentioning this because you said this was your first time IRCing. these are some mistakes that newbies often make. it's frustrating to notice a question you can answer, only to realize the asker has already disappeared
10:53:55 <athan> D: does (<<) not even exist?
10:53:57 <athan> where have I been? :|
10:54:41 <athan> @tell Welkin Er, I mean (>>) with (*>), yeah.
10:54:41 <lambdabot> Consider it noted.
10:54:46 <ski> ngastyle : as julianleviston notes, it's fine to just stay and lurk, reading what other people say. otherwise, apply common sense. be nice and polite, especially if you don't know the tone of a new channel you've joined
10:55:21 <julianleviston> ngastyle: also, not many people respond to hello‚Ä¶ given there are 1500 people in channel.
10:55:50 <ngastyle> julianleviston: haha fair point
10:56:02 <julianleviston> ngastyle: but welcome! :)
10:56:26 <ski> ngastyle : if you have any particular question now, just ask
10:58:07 <ngastyle> ski: no particular question at the moment. I'm wondering how IRC users keep mental state of many interleaved conversations happening in a given channel, but that's probably not a question for #haskell
10:58:19 <ski> with practice
10:58:33 <geekosaur> if things get too busy, conversations move to overflow channels
10:58:35 <ski> and ignoring interleaved conversations they're not interested in
10:58:52 <ski> ngastyle : and by specifically referencing each other personally, like i'm doing now
10:59:01 <ski> (and that, yes)
11:00:06 <flexfit> Thanks! I ended up using (f . swap) 
11:01:08 <fizruk_> > (f . swap) (x, y)
11:01:10 <lambdabot>      Ambiguous occurrence ‚Äòf‚Äô
11:01:10 <lambdabot>      It could refer to either ‚ÄòL.f‚Äô,
11:01:10 <lambdabot>                               defined at /tmp/mueval5117023052084420925.hs:155:1
11:02:03 <fizruk_> it doesn't work anymore? :(
11:03:13 <julianleviston> is there any way to set definitions in Hint without loading modules from files?
11:03:19 <julianleviston> it‚Äôs even worse than I thought.
11:03:31 <julianleviston> maybe I‚Äôm doing something stupid.
11:03:42 <bitemyapp> julianleviston: what are you doing with Hint?
11:03:51 <julianleviston> bitemyapp: oh hey :)
11:03:52 <geekosaur> > (L.f . swap) (x,y)
11:03:53 <lambdabot>      Couldn't match type ‚Äò(Expr, Expr)‚Äô with ‚Äò[a]‚Äô
11:03:53 <lambdabot>      Expected type: (Expr, Expr) -> [a]
11:03:53 <lambdabot>        Actual type: (Expr, Expr) -> (Expr, Expr)
11:04:11 <julianleviston> bitemyapp: um‚Ä¶ I want to load code from a DB and eval it...
11:04:25 <julianleviston> bitemyapp: preferably a module of it, but modules seem impossibly tied to files
11:04:26 <geekosaur> "f" in lambdabot, like other single letter bindings, is bound to an Expr from simple-reflect
11:04:58 <geekosaur> julianleviston, hint is using ghc-api. I think ghc-api has no way to compile a module from a string
11:04:59 <julianleviston> bitemyapp: but for now, I‚Äôm just doing a small test in GHCi loading a file in that‚Äôs using Language.Haskell.Interpreter 
11:05:02 <tomus> Gurkenglas: you code was too advanced for me. I spent most of the day writign a simple graph traversal and now it's terribly slow :/
11:05:05 <bitemyapp> julianleviston: http://i.imgur.com/GwcmdLo.png
11:05:09 <julianleviston> geekosaur: yeah, I think you‚Äôre right
11:05:22 <julianleviston> bitemyapp: I don‚Äôt get it
11:05:30 <Gurkenglas> tomus, it halts? Kudos.
11:05:40 <tomus> it doesn't halt
11:05:44 <tomus> it's just slow
11:05:49 <julianleviston> geekosaur: bitemyapp: so I‚Äôm being idiotic?
11:05:55 <icbm> no halt = infinitely slow
11:06:33 <Gurkenglas> Halting means that it's not in an infinite loop
11:06:52 <bitemyapp> julianleviston: evaling arbitrary code is an exceptionally bad idea and Hint wouldn't likely get you to where you wanted to go anyway.
11:06:59 * geekosaur doesn't see where "idiotic" comes in. ghc-api was not really designed, and lots of things you might expect from a proper API aren't there
11:07:11 <julianleviston> bitemyapp: yeah, I‚Äôm pretty aware that it‚Äôs a bad idea. :)
11:07:12 <bitemyapp> julianleviston: that picture was me saying I was pulling a Pontius Pilate gtfo'ing.
11:07:25 <bitemyapp> and gtfo'ing*
11:07:27 <julianleviston> bitemyapp: sorry, I don‚Äôt follow
11:07:37 <bitemyapp> julianleviston: it's not idiotic as geekosaur says.
11:07:37 <julianleviston> bitemyapp: you want me to GTFO?
11:07:40 <bitemyapp> no
11:07:47 <bitemyapp> I'm saying I was washing my hands of it.
11:08:03 <julianleviston> bitemyapp: ah‚Ä¶ ok that‚Äôs what I actually thought you might have been saying lol
11:08:03 <bitemyapp> new people get into weird rabbit holes sometimes. This is one of them.
11:08:09 <tomus> Gurkenglas: my code picks a pixel, traverses as much as it can. removes the blob from the image and looks for a non-empty pixel again.
11:08:14 <julianleviston> bitemyapp: I‚Äôm not *that* new.
11:08:23 <julianleviston> bitemyapp: I mean, sure, new to Haskell‚Ä¶ 
11:08:32 <bitemyapp> julianleviston: that's what I mean by new.
11:08:40 <Gurkenglas> tomus, how does it traverse without going in a circle?
11:08:43 <julianleviston> bitemyapp: but I think it‚Äôs more the thing I‚Äôm trying to do (my project) is ‚Ä¶ kind of insane-seeming
11:08:49 <bitemyapp> well, don't.
11:09:01 <julianleviston> bitemyapp: yeah, not really an option :)
11:09:03 <tomus> Gurkenglas: keep a isVisited vector for each pixel
11:09:08 <Gurkenglas> kk
11:09:09 <bitemyapp> but writing a DSL / embedded DSL for what you want could be a good experience
11:09:14 <bitemyapp> but don't x-y yourself into a foxhole
11:09:20 <julianleviston> bitemyapp: I‚Äôd have to build a whole language.
11:09:26 <julianleviston> bitemyapp: maybe I‚Äôll just pull elm into it :) lol
11:09:37 <bitemyapp> so, first thing
11:09:40 <julianleviston> hahah :)
11:09:41 <Gurkenglas> julianleviston, lambdabot uses https://hackage.haskell.org/package/mueval
11:09:42 <bitemyapp> Hint doesn't have any real security
11:09:47 <julianleviston> Gurkenglas: yeah, I know.
11:09:48 <bitemyapp> you want what Gurkenglas just linked
11:09:52 <julianleviston> bitemyapp: yep.
11:09:55 <bitemyapp> but I'll surprised if you get it building and working in <1 hour
11:10:00 <bitemyapp> unless they've added Stack
11:10:01 * bitemyapp checks
11:10:14 <bitemyapp> they have not.
11:10:20 <Gurkenglas> No way, gwern wrote that?
11:10:25 <bitemyapp> Gurkenglas: yep
11:10:33 <julianleviston> bitemyapp: mueval luses hint ‚Äúunder the hood‚Äù for a lot of its stuff, tho anyway, right.
11:10:36 <bitemyapp> Gwern has many interests :P
11:10:39 <julianleviston> from what I‚Äôve read.
11:10:46 <geekosaur> worth noting that some errors from mueval reference L.hs -- mueval writes stuff to a temporary file and compiles that
11:10:57 <julianleviston> dang.
11:11:00 <Gurkenglas> This is like the Wikipedia Philosophy thing
11:11:08 <Gurkenglas> All roads lead to Gwern
11:11:38 <bitemyapp> I'll be goddamned, compiled out of the box.
11:11:41 <bitemyapp> all hail Stack
11:11:42 <julianleviston> It‚Äôs probably just really silly of me to try to make Haskell load code dynamically/interpreted‚Ä¶ but darn it, I want it :)
11:11:49 <julianleviston> haha :) nice :)
11:12:05 <icbm> OK, let's say I want to scan through some files. Forward only, char by char, and compute something. Is lazy IO and String good enough, or do I need to look at conduits/pipes/streams/Text/something-else?
11:12:20 <julianleviston> icbm: lazy is good enough
11:12:34 <julianleviston> icbm: you can use interact which does it chunk by chunk.
11:12:35 <bitemyapp> icbm: as long as you don't write back to the same file you're reading from
11:12:44 <glguy> osa1: The fix for long comments was in PR #27
11:12:48 <glguy> wasn't*
11:13:18 <icbm> Nope. Let's just imagine I'm computing a SHA1 or something.
11:13:50 <bitemyapp> icbm: you're fine then
11:13:53 <glguy> osa1: I did found and fixed it while cleaning up the lexer in this branch https://github.com/glguy/language-lua/tree/happy
11:13:59 <icbm> Cool, will keep on using it. Thx!
11:14:05 <bitemyapp> icbm: if you need absolutely constant memory use then you can use a streaming library but you're probably going to be fine.
11:14:05 <julianleviston> icbm: you *do* have to be a little careful with ‚Äúletting your handles go‚Äù tho, potentially if it‚Äôs a massive file.
11:14:29 <icbm> julianleviston: noted
11:14:30 <julianleviston> icbm: this is actually a case where reading RWH is a good reference, IMHO.
11:14:38 <bitemyapp> icbm: and as julianleviston alluded to, try to think carefully if there is anything persistent which will hold onto a reference to something. Could cause a leak, this happens in JS too.
11:15:19 <julianleviston> bitemyapp: haha rubyist ‚ÄúHey, why is my computers slowing down?‚Äù ‚ÄúOh, I‚Äôm reading a 1 GB textfile in‚Äù
11:15:48 <icbm> bitemyapp: Will do, thanks!
11:17:11 <julianleviston> so‚Ä¶ are all definitions in lambdabot / mueval inside a monad like with GHCi?
11:17:28 <Guest35399> +i
11:17:28 <julianleviston> monadic context*
11:17:30 <codehero> does anyone else here use ghci as a calculator?
11:17:42 <julianleviston> codehero:  lol yes :$
11:17:47 <codehero> :D
11:17:51 <codehero> nice. i'm not the only one
11:17:55 <bitemyapp> julianleviston: it requires performing effects so there's really no way around it, but it's different from how GHCi works and the answer doesn't tell you anything about how mueval works.
11:18:20 <nkaretnikov> Enigmagic: hey, i managed to fool the compiler with th: https://github.com/nkaretnikov/triangle-inequality/commit/339ad46088127728c7537305127484db095c4709 (sorry for the messy commit)
11:18:23 <julianleviston> bitemyapp: sure. I‚Äôm just wondering about how I‚Äôd go about getting a module loaded when it doesn‚Äôt seem to have provision for doing such things.
11:19:00 <athan> codehero: To calculate how your calculator will calculate?
11:19:33 <codehero> well. no, just to calculate stuff
11:19:48 <codehero> like calculating average, or even just adding two numbers
11:21:45 <athan> codehero: I do all the time now. Have you gotten into project euler yet?
11:22:20 <codehero> i did a few ones when i learned c
11:22:24 <codehero> haven't tried it with haskell yet
11:24:15 <Gurkenglas> Why does ide-haskell in atom only deduce types if the code compiles?
11:25:57 <julianleviston> wow chris done has done a fair mount of cool work on tryhaskell
11:26:09 <julianleviston> is it still up?
11:26:19 <julianleviston> yes. ok
11:26:48 <bitemyapp> Gurkenglas: I think because it relies on the GHC API
11:26:52 <monochrom> it is still used by the www.haskell.org main page (the one about "got 5 minutes?")
11:27:13 <nuttycom> Hey, everybody. I'm attempting to figure out how to generate the SHA256+RSA signature for a ByteString, given an X509 private key, using Haskell. I've looked through a lot of the Haskell crypto libraries, but and while http://hackage.haskell.org/package/x509-1.6.3/docs/Data-X509.html#objectToSignedExact seems like what I need, I'm not sure how to find an implementation of the appropriate signature function. Any Haskell crypto gee
11:27:18 <julianleviston> did he give up because of fpcomplete‚Äôs project things?
11:27:20 <bitemyapp> Gurkenglas: GHC cannot infer types "in a context" without the context type-checking.
11:27:48 <monochrom> I don't know.
11:27:51 <Gurkenglas> But it needs to infer types to typecheck the code...
11:29:05 <Gurkenglas> (Atom says sequence only works on lists. How do I smack sense into it?)
11:29:35 <bitemyapp> nuttycom: https://github.com/vincenthz/hs-certificate/blob/master/x509/Tests/Tests.hs
11:29:50 <bitemyapp> nuttycom: https://github.com/vincenthz/hs-certificate/blob/master/x509-util/tests/Generate.hs
11:29:57 <nkaretnikov> nuttycom: vincenthz is the person you need to talk to
11:30:08 <bitemyapp> nuttycom: yar @ what nkaretnikov said.
11:30:29 <bitemyapp> nuttycom: when I don't know how to use something, I usually look for tests/documentation. Do either of those test modules have anything that looks like what you want?
11:30:30 <julianleviston> looks like mueval can‚Äôt do definitions either (only file based imports). I don‚Äôt get it. If they can load a flie and its definitions, why can‚Äôt they load it from a string.
11:30:56 <nkaretnikov> nuttycom: i'm not claiming whether vincent is good at crypt or not, but they just implemented quite a few crypto libs
11:31:01 <nkaretnikov> crypto*
11:32:32 <julianleviston> It‚Äôs all GHC API‚Äôs fault. 
11:32:48 <Iceland_jack> I'll drink to that
11:33:07 <julianleviston> :)
11:37:01 <glguy> objectToSignedExact doesn't sign things, it parses a signed ASN.1 object
11:37:10 <glguy> and it maintains the exact representation of it so that the signature can be validated
11:38:14 * hackagebot gelatin 0.0.0.0 - An experimental real time renderer.  https://hackage.haskell.org/package/gelatin-0.0.0.0 (SchellScivally)
11:41:04 <glguy> Also what I said was wrong, I was thinking of a slightly different function, but this probably isn't quite what you're looking for
11:41:05 <julianleviston> hm‚Ä¶ this seems to say that there *used to be* a json service for tryhaskell.org that supported state loading‚Ä¶ but the github repo isn‚Äôt on chris‚Äôs github anymore :( http://chrisdone.com/posts/haskell-json-service-tryhaskell
11:41:30 <glguy> but this is probably more specific than you're looking for
11:41:48 <glguy> It expect you to provide the signing function yourself
11:42:11 <diracdelta> If I get a package build error that happens when building a dependency, how can I manually get the package working on my system?
11:42:29 <julianleviston> diracdelta: using cabal or stack?
11:42:35 <diracdelta> julianleviston: cabal
11:42:53 <julianleviston> diracdelta: ah‚Ä¶ not sure sorry.
11:43:04 <diracdelta> julianleviston: what's stack?
11:43:27 <julianleviston> diracdelta: kinda ‚Äúeasy mode‚Äù for cabal install
11:43:42 <diracdelta> julianleviston: is it built on top of cabal, or is it a separate system?
11:43:50 <julianleviston> diracdelta: both
11:43:56 <julianleviston> diracdelta: I think. bit hazy
11:44:01 <glguy> nuttycom: It realy depends on what you're doing as to what exactly signature you'd need to be producing. As far as signing something with an x.509 certificate
11:44:18 <julianleviston> diracdelta: https://github.com/commercialhaskell/stack
11:44:21 <glguy> you'll need to extract the public key from the certificate and then you can use functions like sign from http://hackage.haskell.org/package/cryptonite-0.7/docs/Crypto-PubKey-RSA-PKCS15.html
11:44:22 <diracdelta> julianleviston: Cool, I'll check it out.
11:44:27 <glguy> in order to produce a signature
11:45:28 <diracdelta> Correct me if this story is inc
11:45:47 <UncleAlf> mmm just spent 2 hours writing 1 line of code
11:46:21 <glguy> nuttycom: That'll give you the raw signature, but often you need to embed that signature in some other format, like PKCS#7
11:47:44 <diracdelta> Correct me if I'm wrong, when cabal installs a package, it contacts hackage, untars the source, and runs cabal build?
11:48:14 <diracdelta> Where does it untar the source?
11:48:15 * hackagebot varying 0.1.4.0 - Automaton based varying values, event streams and tweening.  https://hackage.haskell.org/package/varying-0.1.4.0 (SchellScivally)
11:49:09 <diracdelta> Out of curiousity, how do I get a package listed on Hackage?
11:49:26 <glguy> cabal get <packagename>
11:49:32 <glguy> will download and unpack the source
11:50:27 <diracdelta> glguy: cool; if I get the source, enter the directory, modify the source, and run cabal install, will my local version of cabal believe that the package is installed?
11:50:52 <glguy> It'll install it into your user package database like any other cabal install
11:51:22 <diracdelta> glguy: thanks, only have a vague idea how cabal actually works. :)
11:52:12 <diracdelta> glguy: reading docs now. :)
11:52:12 <hexagoxel> diracdelta: there is caching (so it may not download from hackage), and it does a bit more (resolving dependencies and installing those; registering in package db after successful build). otherwise description seems correct to me
11:53:29 <diracdelta> hexagoxel: so after the build happens, the installed artifacts are kept around in the correct directories under ~/.cabal, and the source used is nuked?
12:00:41 <hexagoxel> diracdelta: yes
12:02:22 <hexagoxel> (you can `-v`, but it is a bit spammy :)
12:03:01 <diracdelta> hexagoxel: thanks!
12:13:15 * hackagebot renderable 0.0.0.2 - Provides a nice API for rendering data types that change  over time.  https://hackage.haskell.org/package/renderable-0.0.0.2 (SchellScivally)
12:16:53 <Sindriava> What's the stack equivalent of cabal run?
12:18:19 <osa1> glguy: hey, could you have a look at the changelog? did I forget anything important?
12:18:25 <glguy> checking
12:18:26 <bernalex> any quickcheck gurus around? I want to make an arbitrary list with small numbers based on my own list and numbers types.
12:18:30 <bernalex> newtype TinyList  = TinyList  (L.List N.Nat) deriving Show
12:18:40 <bernalex> I already have
12:18:42 <bernalex> instance Arbitrary (TinyNats) where
12:18:44 <bernalex>   arbitrary = Tiny . N.toNat <$> choose (0, 3)
12:18:49 <hexagoxel> Sindriava: i don't use stack, but the #haskell-stack history says "stack build --exec foo"
12:18:50 <bernalex> which works, but now I want a list of Nats that are tiny
12:19:02 <bernalex> (as opposed to a list of TinyNats, which won't typecheck where I want to use them)
12:19:08 <osa1> glguy: also, let's at least fix #29 before pushing to hackage
12:19:15 <Sindriava> hexagoxel: Thanks!
12:19:30 <bernalex> so I want to make an arbitrary list of 'Tiny . N.toNat <$> choose (0, 3)'s.
12:21:03 <glguy> osa1: The changelog seems right to me
12:21:35 <fabri86live> ciao 
12:21:38 <fabri86live> !list
12:21:38 <monochrom> fabri86live: http://okmij.org/ftp
12:21:41 <glguy> osa1: I updated the travis.yml on my happy branch. Builds run in about 2 minutes now when it canreuse the previous dependency builds https://travis-ci.org/glguy/language-lua/builds/83481300
12:22:59 <osa1> glguy: do you have a commit for that? I just gave you push access, it'd be great if you could push changes for 1) fixing #29 2) faster travis builds
12:23:20 <athan> So I'm making an app store (as in storage, not purchase) for Haskell packages. What should I call it?
12:23:25 <bernalex>   arbitrary = TinyList . (foldr L.Cons L.Nil :: [a] -> L.List a) <$> replicateM 100 (N.toNat <$> (choose (0, 9)))
12:23:31 <athan> "Super Mega App Store +! Go"
12:23:33 <athan> +1*
12:23:35 <bernalex> that typechecks, but IDR how replicateM even works
12:23:47 <bernalex> will replicateM give me different results for choose (0, 9)?
12:23:49 <fabri86live> ciao
12:23:55 <fabri86live> !list
12:23:56 <monochrom> fabri86live: http://lpaste.net/browse
12:23:58 <athan> bernalex: Yes
12:23:59 <bennofs> bernalex: that will make a list of 100 elements all time
12:24:07 <bernalex> bennofs: yeah I know
12:24:11 <bernalex> I just wanted to demonstrate what I want
12:24:23 <athan> it chooses randomly each time
12:24:25 <bernalex> but surely quickcheck is equipped for this situation. I just don't know what I'm supposed to use.
12:24:44 <athan> bernalex: Look at the source for Arbitrary [a] :)
12:24:48 <bernalex> just... "give me an arbitrary list, where each element is generated from this expression" would be good.
12:24:51 <athan> you've got it very close
12:24:52 <bennofs> bernalex: how about http://hackage.haskell.org/package/QuickCheck-2.8.1/docs/Test-QuickCheck-Gen.html#v:listOf ?
12:25:01 <athan> listOf?
12:25:15 <bernalex> bennofs: that looks neat
12:25:24 <Iceland_jack> :t vectorOf
12:25:26 <lambdabot> Int -> Gen a -> Gen [a]
12:26:48 <bernalex>   arbitrary = TinyList . foldr L.Cons L.Nil <$> listOf (N.toNat <$> choose (0, 9))
12:26:50 <bernalex> works at least
12:27:30 <athan> ...what should I name the haskell app-store? :(
12:28:17 <lpaste> vitalij pasted ‚ÄúString compression‚Äù at http://lpaste.net/142231
12:28:34 <bernalex> an haskell app store sounds silly for the same reason distributing software through build tools instead of package managers is silly. endusers don't care about haskell, they care about what programs can do for them.
12:28:35 <tomus> type BlobState a = (M.MutableImage (M.MutableManifest a), M.MutableImage (M.MutableManifest a), V.Vector P.Point)
12:28:55 <tomus> The third argument of a tuple should have kind ‚ÄòConstraint‚Äô, but ‚ÄòV.Vector P.Point‚Äô has kind ‚Äò*‚Äô
12:29:01 <glguy> vitalij: You can use:    Just x == lastChar
12:29:02 <tomus> I don't understand this
12:29:11 <athan> bernalex: I have many sane use cases, trust me. I just need a name :|
12:29:48 <c_wraith> tomus: Something weird is going on if the third argument of a tuple should have kind Constraint
12:29:58 <bennofs> tomus: probably M.MutableImage is a typeclass
12:30:02 <bernalex> athan: everyone thinks they have a sane usecase. :] sometimes they're even right. even then it can often be detrimental to the greater good.
12:30:14 <bennofs> tomus: and you have the extension ConstraintKinds enabled
12:30:33 <vitalij> glguy it is not enough
12:31:26 <glguy> ok
12:32:00 <vitalij> glguy no, it works. Sorry, my fault.
12:32:01 <tomus> bennofs: it is a type class
12:32:06 <vitalij> And thank you!
12:32:09 <tomus> bennofs: extention isn't enabled
12:32:13 <athan> bernalex: It has nothing to do with shallow publicity
12:32:23 <athan> I just need a name ._.
12:32:41 <bennofs> tomus: well, if it is a typeclass, then all arguments of the tuple must be constraints (like for example, 'Show a' would be a constraint)
12:32:58 <bennofs> Has Anything :p
12:35:34 <isomorphismes> There's a room for #learnhaskell or #learninghaskell or #learn-haskell, right?
12:35:38 <isomorphismes> I'm in Cabal hell
12:36:02 <bennofs> isomorphismes: what's your problem?
12:36:16 <isomorphismes> bennofs: https://github.com/BinRoot/Haskell-Data-Analysis-Cookbook/issues/6
12:36:23 <lspitzner> there is #haskell-beginners
12:36:30 <isomorphismes> lspitzner: That's it! Thank you
12:36:36 <bennofs> isomorphismes: also, post ouput of 'ghc-pkg list' and 'ghc-pkg check' :) 
12:36:36 <lspitzner> but this channel is fine as well :)
12:36:43 <shachaf> That channel isn't associated with #haskell.
12:36:57 <shachaf> This channel is perfectly fine for beginners.
12:37:20 <bennofs> isomorphismes: oh, that looks like your GHC version is too new
12:37:50 <isomorphismes> bennofs: Generally any time I try to play with Haskell though (Yesod, https://stackoverflow.com/questions/3592212/beginning-haskell-getting-not-in-scope-data-constructor-error, http://learnyouahaskell.com/making-our-own-types-and-typeclasses#algebraic-data-types, http://leksah.org/, etc) I get bogged down in a beginner issue and then leave.
12:38:51 <bennofs> isomorphismes: that error message there is definitely not beginner friendly. In general, when you see cabal complaing about the version of 'base', it is related to your GHC version
12:38:53 <isomorphismes> bennofs: ah ok. I think I was told in #leksah or #yesod or whatever, last time I was messing around with Haskell, to upgrade from Ubuntu's (as usual, old & stable) ghc.
12:39:06 <isomorphismes> bennofs: yeah, I figured as much, but no idea how to solve it.
12:39:20 <isomorphismes> I remember from last time I was checking out H, there seems to be a sandboxing issue (stackage?).
12:39:37 <isomorphismes> Kind of a contentious community problem, yet it's generally agreed that Cabal hell is gonna keep away newbies.
12:39:43 <isomorphismes> Sort of like the opposite of CRAN.
12:39:50 <bennofs> isomorphismes: well, I don't use it myself, but many people recommend stack now
12:40:56 <isomorphismes> bennofs: What should I do to get that particular thing to build? Somehow sandbox an old ghc / base / cabal to that directory?
12:41:15 <bennofs> isomorphismes: it uses stackage by default, which picks a subset of hackage that is guarranted to built together (so no build failures). Though ofc that means that some packages of hackage are not available in stackage
12:41:26 <bennofs> isomorphismes: let me check that particular thing
12:41:36 <bennofs> isomorphismes: perhaps it is enough to just remove the upper bound on base
12:42:08 <glguy> osa1: pushed
12:42:36 <bennofs> isomorphismes: yeah, just edit Code0703.cabal and remove the "&& <4.7" and it should work
12:42:56 <isomorphismes> thanks bennofs 
12:43:01 <isomorphismes> bennofs: !
12:43:06 <osa1> glguy: thanks. I'll update the changelog and push 0.8 to hackage.
12:43:26 <isomorphismes> bennofs: Should I request them to pull that to their repo or just do it for myself?
12:43:42 <bennofs> isomorphismes: do it for yourself, and if it works, send a PR :)
12:45:24 <danilo2> Hello guys! :) Is there in Haskell something like liftST- similar to liftIO? 
12:46:22 <johnw> danilo2: there is Control.Monad.Base
12:46:30 <johnw> which will give you a liftBase, should ST be your base monad
12:46:55 <johnw> or generically: MonadBase ST m => m Int
12:47:00 <tomus> new :: PrimMonad m => Size -> m (i (PrimState m))
12:47:09 <danilo2> john: Oh, thats great! thanks a lot!
12:47:21 <tomus> struggling to use it. is i a free variable?
12:47:23 <isomorphismes> bennofs: Great, that worked =)
12:48:16 * hackagebot wai-transformers 0.0.2 - Simple parameterization of Wai's Application type  https://hackage.haskell.org/package/wai-transformers-0.0.2 (athanclark)
12:49:58 <tomus> a = M.new (I.shape img) :: State I.RGB (... what goes here...)
12:53:17 * hackagebot language-lua 0.8.0 - Lua parser and pretty-printer  https://hackage.haskell.org/package/language-lua-0.8.0 (OmerAgacan)
12:56:56 <glguy> osa1: travis-ci emails me when builds fail by default, what was that config section doing differently for you?
13:00:19 <osa1> glguy: I think it was the same as defaults.
13:00:50 <osa1> glguy: I don't remember, but it was sending emails when builds fail or fixed.
13:15:48 <nuttycom> Thanks, glguy!
13:18:25 <JagaJaga> What's the _easiest_ way to work with sql from haskell? Haskelldb of HDBC?
13:19:01 <felixn> does anyone use gratuitous types to avoid confusion?  I was having trouble with an algo because I forgot to `sequence` after moving things around.  differentiating between the two meanings of [[a]] and [[a]] would've provided clarity.  I've tried boxing before, and found it annoying, but that could be a good thing (in this case at least)
13:19:30 <pavonia> JagaJaga: mysql-simple is quite easy to use
13:19:41 <JagaJaga> pavonia: I need postgresql :)
13:19:54 <felixn> JagaJaga++ for good choices
13:20:08 <delYsid> How do I do an applicative product?  Like (*) <$> field1 <*> field2 but for more than two arguments?
13:23:32 <johnw> delYsid: can you show me what the non-applicative form looks like?
13:23:37 <johnw> do you mean a * b * c?
13:23:46 <johnw> or (*) a b c?
13:25:50 <delYsid> johnw: \f x -> product [a x, b x, c x]
13:26:18 <johnw> you don't use f?
13:26:50 <delYsid> er,
13:27:08 <delYsid> johnw: f x = product [a x, b x, c x]
13:28:02 <felixn> http://lpaste.net/142236 <-- :D  there's probably better nomenclature
13:30:30 <delYsid> hmm I think I was confused, thinking in term of varargs didnt help.
13:30:55 <Gurkenglas> :t fmap product . sequenceA -- delYsid 
13:30:56 <lambdabot> (Num b, Applicative f, Traversable t) => t (f b) -> f b
13:32:14 <Gurkenglas> Hmm, that ought to take a foldable.
13:34:10 <Gurkenglas> :t foldr (liftA2 (*)) (const 1) -- hmm not strict enough right
13:34:11 <lambdabot> (Num b, Foldable t) => t (b1 -> b) -> b1 -> b
13:34:28 <Gurkenglas> (pure instead of const, of course)
13:35:22 <delYsid> oh, how cool, yeah!
13:35:51 <felixn> http://lpaste.net/142236 <-- ahh this is what I mean by gratuitous types ;D, it's easy to get carried away.  anyone have insight on a good balance of boxing?  box all the things?
13:37:37 <Gurkenglas> You too will in time come to despise naming
13:40:41 <tomus> ...13,937,948,976 bytes copied during GC
13:40:42 <tomus> :D
13:41:15 <Hafydd> Sick GC, m8.
13:41:23 <felixn> that bites
13:41:26 <hexagoxel> pssh, not even into terabytes
13:45:16 <ReinH> felixn: you could at least use newtypes instead
13:46:32 <diracdelta> Huh, I just tried to install a package that lists happy and alex as build-tools, but will fail if they aren't manually installed. Is this the desired behavior of the build-tools section?
13:47:27 <hexagoxel> diracdelta: yes, because these dependencies are on the executables, not the libraries
13:48:03 <hexagoxel> diracdelta: and cabal does not support dependencies on executables in a more elegant way (unfortunately)
13:50:43 <diracdelta> hexagoxel: Huh. Okay, I get the distinction now, but why does cabal not then automatically build those executables?
13:53:22 <ReinH> diracdelta: Because it doesn't have the concept of building an executable dependency. It doesn't differentiate between executables that are built from a haskell package and other executables.
13:53:46 <ReinH> It's certainly possible to depend on executables that cabal *can't* build.
13:54:03 <ReinH> or rather, *couldn't* build.
13:54:59 <diracdelta> ReinH: oh, okay. How does cabal figure out the version of an arbitrary executable?
13:57:35 <ReinH> Does it?
13:58:24 <hexagoxel> (yes, it calls "alex --version" "c2hs --numeric-version" and a couple of others e.g. when installing cabal-install)
13:59:03 <hexagoxel> (it seems to distinguish for certain things; the generic "getter" might be `foo --version`)
13:59:43 <hexagoxel> (see `cabal install --dry-run cabal-install -v`)
13:59:57 <broma0> How are GADTs and the Free monad related? How can GADTs be used in the Free monad / interpreter pattern? Any thoughts?
14:01:14 <ReinH> hexagoxel: Interesting. Perhaps it tries to use --version and parse a version specifier?
14:02:27 <hexagoxel> ReinH: yes, that would be my guess as well. plus a couple of hard-wired things for tools it knows
14:03:33 <ReinH> broma0: You might find the operational monad tutorial here interesting https://themonadreader.files.wordpress.com/2010/01/issue15.pdf
14:05:51 <broma0> ReinH: seems interesting after briefly skimming the first few paragraphs. thank you!
14:13:21 * hackagebot pipes-extras 1.0.2 - Extra utilities for pipes  https://hackage.haskell.org/package/pipes-extras-1.0.2 (GabrielGonzalez)
14:20:33 <Pamelloes> Is there an "isUndefined" function?
14:21:04 <glguy> Not having that function is a feature of Haskell
14:21:44 <Pamelloes> Yeah. I guess so.
14:23:16 <athan> @let isUndefined :: (forall a. a) -> Bool; isUndefined _ = True
14:23:17 <lambdabot>  Defined.
14:23:25 <athan> > isUndefined undefined
14:23:27 <lambdabot>  True
14:23:31 <Pamelloes> nice
14:23:32 <athan> > isUndefined 2
14:23:33 <lambdabot>      No instance for (Num a) arising from the literal ‚Äò2‚Äô
14:23:33 <lambdabot>      Possible fix:
14:23:33 <lambdabot>        add (Num a) to the context of a type expected by the context: a
14:23:40 <athan> >:D
14:23:48 <athan> @undefined isUndefined
14:23:48 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
14:23:52 <athan> @undefine isUndefined
14:23:52 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
14:24:01 <athan> @undefine
14:24:01 <lambdabot> Undefined.
14:24:05 <athan> :S
14:24:08 <Pamelloes> errr
14:24:14 <pavonia> Isn't there a special exception for undefined your can catch, though?
14:24:38 <pavonia> Or maybe that was for error
14:24:53 <athan> pavlicek: Well, `error :: String -> (forall a. a)`
14:25:08 <glguy> You can catch The exception that comes from attempting to evaluate an undefined as an IO action
14:25:32 <glguy> That doesn't allow you to directly detect if some value is the Prelude.undefined
14:28:21 * hackagebot pandoc-crossref 0.1.5.3 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.1.5.3 (lierdakil)
14:29:06 <cleichner> Does anyone know of/want to provide an explanation of why greatest fixed points and least fixed points coincide in Haskell?
14:34:39 <ReinH> Pamelloes: If you can solve the halting problem for me I'll be happy to write that function for you
14:35:16 <shachaf> cleichner: You mean of types?
14:38:34 <Pamelloes> ReinH: The solution is simple: just disallow jumps and ensure a finite program size. Will it halt? Yes!
14:39:33 <mniip> that's not turing-complete
14:39:51 <Pamelloes> technicalities.
14:40:32 <mniip> also I guess this is a nice cheat for the halting problem
14:42:55 <cleichner> shacaf: yes
14:44:27 <shachaf> Well, the reason is general recursion, I guess.
14:44:56 <shachaf> It makes the least fixed point bigger.
14:45:23 <johnw> shachaf: is laziness a part of it?
14:46:58 <cleichner> General recursion as opposed to a more bounded form of recursion?
14:48:35 <mniip> basically
14:48:42 <mniip> turing completeness => halting problem
14:49:02 <mniip> cleichner, yeah, you can have induction
14:49:10 <mniip> a general recursion is something like
14:49:11 <mniip> :t fix
14:49:12 <lambdabot> (a -> a) -> a
14:50:25 <cleichner> So a total language would have different least fixed points and greatest fixed points for types?
14:53:22 * hackagebot gooey 0.0.0.0 - Graphical user interfaces that are renderable,  change over time and eventually produce a value.  https://hackage.haskell.org/package/gooey-0.0.0.0 (SchellScivally)
14:53:23 <cleichner> Do you have a good example of where this is the case?
14:53:34 <johnw> cleichner: that's the case in Coq, at least
14:54:58 <johnw> cleichner: you might be interested in https://mail.haskell.org/pipermail/haskell-cafe/2009-March/057983.html
14:55:38 <johnw> "This is true in a categorical semantics where initial algebras and final coalbebras are distinct, like in a total language that gets its semantics from sets and total functions thereon. However, Haskell gets its semantics (modulo some potential weirdness in IO that people have been discussing lately) from categories of partial orders and monotone functions. It turns out that you can show that initial algebras and final coalgebras
14:55:39 <johnw> coincide in such a category, and so least and greatest fixed points are the same in Haskell."
14:56:14 <johnw> that's from dolio
14:57:40 <xpilot> anyone familiar with Data.Data/scrap your boilerplate?
14:57:58 <xpilot> I'd like to know if there is a programmatic way of getting all the constructors of a datatype
14:58:13 <fried_chicken> shut up
14:58:20 <johnw> fried_chicken: ?
14:58:22 * hackagebot gelatin 0.0.0.2 - An experimental real time renderer.  https://hackage.haskell.org/package/gelatin-0.0.0.2 (SchellScivally)
14:58:51 <osa1> glguy: are you using irc-core right now?
14:58:52 <johnw> xpilot: yes, in fact, there are a few ways to get that information
14:59:05 <cleichner> johnw: That's excellent, exactly what I was looking for. Thanks
14:59:45 <johnw> xpilot: I think Data.Typeable can, GHC.Generics can, and I know Template Haskell can
15:00:14 <xpilot> johnw: I was looking at Data.Data and couldn't figure it out
15:00:48 <johnw> I thought Data.Data and syb are for introspecting on a value, rather than on a type
15:01:07 <johnw> (Data derives from Typeable to add generic folding)
15:01:18 <xpilot> ah ok
15:01:45 <xpilot> I've also looked at Typeable though, and couldn't figure it out
15:01:53 <glguy> osa1: Yeah, it's the only client i've really used since starting that project :)
15:01:58 <johnw> xpilot: can you show me your type and the information you'd like to retrieve from it?
15:02:13 <xpilot> should the TypeRep have the information?
15:02:17 <johnw> yes
15:02:33 <johnw> "typeRep (undefined :: Foo)" returns you the TypeRep for Foo
15:03:43 <xpilot> right - but how do I get information out of a TypeRep?
15:03:45 <johnw> this contains information about the type alone, I don't think it descends into it
15:04:07 <Gurkenglas> Is there something that given a history of file changes gives you the diff between the last that fulfills a quickcheck/profiling property and the first one that breaks it?
15:04:08 <johnw> have you looked at GHC.Generics?
15:04:46 <Gurkenglas> *the next one
15:05:06 <johnw> Gurkenglas: you mean, like git bisect'ing will do?
15:06:12 <glguy> TypeRep won't help you to get the data constructors afaik
15:06:26 <johnw> glguy: yeah, apparently not
15:07:21 <johnw> there's dataTypeConstrs from Data.Data, but I haven't used it before
15:08:08 <xpilot> ah that looks like what I want
15:08:30 <xpilot> the datatypes I'm interested in implement Data, not Generic
15:08:39 <johnw> xpilot: ah.  How do you get the DataType?
15:08:52 <ReinH> Gurkenglas: you could use git bisect
15:08:58 <xpilot> dataTypeOf :)
15:09:02 <johnw> ah
15:09:05 <ReinH> That's what it's designed for
15:09:06 <johnw> dataTypeOf (undefined :: Foo)
15:09:36 <xpilot> I guess I might ultimately want to derive Generic though
15:09:38 <johnw> > dataTypeConstrs (dataTypeOf (undefined :: Maybe Int))
15:09:39 <lambdabot>  [Nothing,Just]
15:09:52 <xpilot> cool!
15:10:33 <johnw> xpilot: thanks, I learned something about Data.Data today :)
15:10:46 <johnw> though I think Generics is the "new hotness", unless I'm mistaken
15:12:03 <xpilot> it does look more powerful, yeah
15:12:55 <xpilot> I'll see how far I can get with Data.Data
15:16:26 <mgsloan> I'd say that Data.Data / SYB is simpler and more powerful.  But Generics is a cleverer mechanism which can result in much better performance
15:16:35 <johnw> even syb is somewhat replaced by lens, depending on what you're doing
15:16:52 <johnw> the only time I've used syb, in a complier at work, the performance was utterly atrocious
15:17:07 <johnw> but that's not to say syb is bad, just that you need to keep an eye on what you're saying with it
15:17:45 <mgsloan> johnw: Yes, if you're using "everywhere" or something like that on an AST full of String without specializing for "String", you're going to get **terrible** performance
15:18:10 <mgsloan> As it will walk all the way down your strings!
15:18:23 * hackagebot gelatin 0.0.0.3 - An experimental real time renderer.  https://hackage.haskell.org/package/gelatin-0.0.0.3 (SchellScivally)
15:18:25 * hackagebot mathblog 0.6 - A program for creating and managing a static  weblog with LaTeX math and diagrams  https://hackage.haskell.org/package/mathblog-0.6 (JonathanDaugherty)
15:18:27 <johnw> I forgot what was happening in our case, but memory was blowing up horribly
15:20:12 <mgsloan> Hmm, I'm surprised that memory use would be an issue for SYB! Maybe too much laziness
15:24:12 <Pamelloes> Does cabal support copying static files to the build output?
15:26:13 <hexagoxel> Pamelloes: https://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-data-files-from-package-code
15:26:30 <hexagoxel> unless you mean something completely different :D
15:26:45 <Pamelloes> hexagoxel: That's it :)
15:29:15 <Fylwind> is there a (possibly dirty) way to specify a constraint that _prevents_ a type from being used? (e.g. NotString a => a -> a, everything that's not "String" is allowed)
15:30:08 <xpilot> dataTypeOf should probably take a proxy instead of an actual value though
15:30:42 <arkeet> Fylwind: why?
15:30:47 <arkeet> (also no)
15:31:44 <Fylwind> arkeet: making a DSL for a dynamic language that implements "Maybe a" as either a or null, but need to prevent 'null' from being used as 'a'
15:32:33 <Fylwind> maybe I could turn it into a runtime error using overlapping instances?
15:32:56 <arkeet> that won't work how you might expect.
15:33:20 <arkeet> instances are resolved at compile time.
15:34:57 <arkeet> why not just make it a runtime error when you see a 'null' where there shouldn't be?
15:35:30 <Fylwind> arkeet: the DSL has uses GHC for typing, so GHC knows whether something is null or not
15:35:40 <arkeet> ?
15:35:42 <mniip> Fylwind, impossible
15:36:03 <mniip> if NotString is a typeclass, then nothing prevents you from instantiating NotString String
15:36:50 <mniip> and you can't explain the fact that this is never to be done to the typechecker
15:36:54 <Fylwind> arkeet: the expressions for the DSL are typed, so GHC can resolve instances as needed
15:37:08 <Hafydd> I think there might be a dirty way to do it, still.
15:37:14 <Fylwind> mniip: yeah I kinda wish there was a "closed" type class or something
15:37:16 <Hafydd> Using type defaulting.
15:37:23 <Hafydd> Er... I mean, using overlapping instances.
15:37:24 <mniip> Hafydd, overlapping instances seem promising
15:37:32 <mniip> but those are, you know, inconsistent
15:37:32 <arkeet> no.
15:37:42 <Fylwind> no?
15:37:50 <arkeet> suppose you have some class C
15:37:54 <arkeet> instance C a (for all a)
15:37:56 <arkeet> instance C String
15:38:16 <Fylwind> mniip: well, this type classes isn't supposed to be extended by the users of the DSL so I don't think inconsistency will be an issue, no?
15:38:30 <Hafydd> Presumably you wouldn't expose the class to users.
15:38:31 <arkeet> now you have a function f :: a -> ... (polymorphic)
15:38:38 <arkeet> that uses a method of C internally
15:38:59 <arkeet> then even if you pass it a String, it'll most likely use the 'C a' instance
15:39:02 <mniip> oh yeah, f would be nonuniform despite the forall
15:39:14 <mniip> which is impossible/incorrect
15:39:27 <arkeet> (except possibly if there's inlining or something)
15:39:27 <mniip> so f would be uniform and use the 'C a' instance for String too
15:39:31 <arkeet> the point being that it's not really predictable
15:39:40 <mgsloan> I think there is a way to do this.  "class NotString a; instance {-# OVERLAPPABLE #-} NotString a; instance {-# OVERLAPPING #-} Error "String not allowed!" => NotString String;"
15:39:48 <mgsloan> Buut I haven't tried it, so maybe not
15:40:08 <arkeet> read what I said.
15:40:14 <mniip> mgsloan, still doesn't save you from nonuniformness
15:40:25 <arkeet> it won't catch every time String is passed.
15:41:20 <mgsloan> Good point
15:41:49 <Fylwind> arkeet: what about closed type families? if I do something like: type family F a where { F String = A; F a = B; }?
15:41:59 <mgsloan> How about "type family NotString a where { NotString String = Error "String not allowed!"; NotString a = () }"
15:42:04 <mgsloan> Yeah
15:42:14 <mgsloan> Mine is combining constraint kinds and closed type families :)
15:42:18 <mgsloan> should do the trick
15:42:30 <Fylwind> would that have the same inconsistency problems?
15:43:48 <mniip> :k Error
15:43:49 <lambdabot> Not in scope: type constructor or class ‚ÄòError‚Äô
15:44:17 <mniip> @let type family Error (s :: Symbol) :: k where Error s = Error s
15:44:18 <lambdabot>  .L.hs:146:25: Not in scope: type constructor or class ‚ÄòSymbol‚Äô
15:44:23 <mniip> :|
15:44:57 <mgsloan> I think the proper definition is "type family Error (s :: Symbol) :: k where {}"
15:45:14 <mniip> of all errors this is what I expected the least
15:45:23 <Fylwind> I just defined an empty type "ERROR_STRING_NOT_ALLOWED" :P
15:45:25 <mniip> @let type family Error (s :: l) :: k where {}
15:45:25 <lambdabot>  Parse failed: Parse error: }
15:45:33 <mgsloan> Oh hrmm
15:45:35 <mniip> @let type family Error (s :: l) :: k where Error s = Error s
15:45:36 <lambdabot>  Defined.
15:45:43 <mgsloan> @let type family Error (s :: l) :: k where
15:45:43 <lambdabot>  Parse failed: Parse error: EOF
15:45:47 <mgsloan> Yargh
15:46:23 <mniip> @let type family NotString a where { NotString String = Error "String not allowed!"; NotString a = a }
15:46:24 <lambdabot>  Defined.
15:46:52 <mniip> @let notString :: a -> NotString a; notString x = x
15:46:53 <lambdabot>  .L.hs:157:15:
15:46:53 <lambdabot>      Couldn't match expected type ‚ÄòNotString a‚Äô with actual type ‚Äòa‚Äô
15:46:53 <lambdabot>        ‚Äòa‚Äô is a rigid type variable bound by
15:46:53 <mgsloan> mniip: I like the polykinded version better anyway, it lets you put types in your error messages by using tuples and typelits
15:47:00 <mniip> okay well this type family is useless
15:47:35 <mgsloan> @let type family NotString a :: Constraint where { NotString String = Error "String not allowed!"; NotString a = () }
15:47:36 <lambdabot>  .L.hs:153:1:
15:47:36 <lambdabot>      Multiple declarations of ‚ÄòNotString‚Äô
15:47:36 <lambdabot>      Declared at: .L.hs:149:1
15:47:44 <mgsloan> @let type family NotString2 a :: Constraint where { NotString String = Error "String not allowed!"; NotString a = () }
15:47:45 <lambdabot>  .L.hs:154:9:
15:47:46 <lambdabot>      Mismatched type name in type family instance.
15:47:46 <lambdabot>        Expected: NotString2
15:47:55 <mgsloan> @let type family NotString2 a :: Constraint where { NotString2 String = Error "String not allowed!"; NotString2 a = () }
15:47:56 <lambdabot>  Defined.
15:47:58 <mgsloan> Sorry for the noise, y'all
15:48:08 <mniip> ::Constrant?
15:48:18 <mgsloan> @let notString :: NotString a => a -> a; notString x = x
15:48:19 <lambdabot>  .L.hs:157:14:
15:48:19 <lambdabot>      Expected a constraint, but ‚ÄòNotString a‚Äô has kind ‚Äò*‚Äô
15:48:19 <lambdabot>      In the type signature for ‚ÄònotString‚Äô:
15:48:22 <mniip> ah, a () constraint?
15:48:24 <mgsloan> @let notString :: NotString2 a => a -> a; notString x = x
15:48:25 <lambdabot>  Defined.
15:48:26 <mgsloan> Ya
15:48:30 <mniip> > notString "moo"
15:48:33 <lambdabot>  Stack space overflow: current size 33624 bytes.
15:48:33 <lambdabot>  Use `+RTS -Ksize -RTS' to increase it.
15:48:39 <mniip> close enough
15:48:52 <mgsloan> Haha yeah, your Error type family is really errorful
15:49:05 <mniip> > notString 123
15:49:06 <lambdabot>      No instance for (Show a0)
15:49:07 <lambdabot>        arising from a use of ‚Äòshow_M330797667171480252925585‚Äô
15:49:07 <lambdabot>      The type variable ‚Äòa0‚Äô is ambiguous
15:49:08 <mgsloan> (It trivially loops)
15:49:15 <mniip> > notString 123 :: Int
15:49:17 <lambdabot>  123
15:49:35 <mniip> > notString []
15:49:36 <lambdabot>      No instance for (Show t0)
15:49:36 <lambdabot>        arising from a use of ‚Äòshow_M7606267719897603025609‚Äô
15:49:36 <lambdabot>      The type variable ‚Äòt0‚Äô is ambiguous
15:49:45 <mniip> okay then
15:50:00 <mgsloan> I wish we could redefine things, the right definition is "type family Error (str :: k0) :: k"
15:50:12 <mniip> undefine
15:50:26 <mgsloan> Ah, haven't used lambdabot in a while
15:51:19 <mgsloan> @undefine NotString
15:51:19 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
15:51:33 <mgsloan> @undefine
15:51:33 <lambdabot> Undefined.
15:51:48 <Fylwind> honestly surprised this worked o.o
15:51:48 <mgsloan> @let type family Error (str :: k0) :: k
15:51:50 <lambdabot> Plugin `eval' failed with: .L.hs: renameFile: does not exist (No such file or directory)
15:51:56 <mgsloan> ugh
15:52:17 <Fylwind> (btw you can private message lambdabot for testing things)
15:52:25 <mniip> I hope I didn't just break lambdabot
15:52:35 <mniip> [01:52:02] <lambdabot> Plugin `eval' failed with: <<timeout>>
15:52:38 <mniip> whatever that means
15:53:01 <mgsloan> Fylwind: I'm not too surprised.  Constraints + closed type families give some surprising capabilities: https://github.com/mikeizbicki/ifcxt
15:53:35 <mgsloan> Oh, actually that doesn't use closed type families, just overlapping instances XD
15:53:41 <mniip> ifcxt is a terrible template haskell hack
15:55:13 <mgsloan> True, it ought to be in the language IMHO
15:57:41 <johnw> just the idea is kind of slick
15:57:49 <johnw> even if the way it's done is kind of sick
16:00:53 <nolrai66> what is ifcxt?
16:04:56 <info_is_good> After successfully running "stack install" in a directory exporting a module, "Foo", I still can't use "import Foo" with runhaskell or GHCI. Why?
16:06:52 <geekosaur> because neither one knows about sandboxes. "stack ghci" to get a ghci that knows about stack's sandbox
16:07:20 <geekosaur> I don't know how you get runhaskell to work with stack; with cabal it'd be "cabal exec -- runhaskell ..." but apparently that doesn't work with stack
16:08:24 * hackagebot Folly 0.2.0.1 - A first order logic library in Haskell  https://hackage.haskell.org/package/Folly-0.2.0.1 (dillonhuff)
16:08:58 <geekosaur> experience has shown that installing stuff in the global context instead of a sandbox is asking for trouble
16:09:16 <geekosaur> so stack always sandboxes, and cabal strongly recommends sandboxing
16:10:37 <info_is_good> but then I can't use runhaskell at all?
16:10:55 <info_is_good> runhaskell has been a great tool for getting fast feedback while avoiding build times
16:10:56 <geekosaur> runhaskell isn't acutally used that often
16:10:58 <geekosaur> we compile stuff
16:11:36 <info_is_good> you just code for hours and compile once? I'm used to compile each small stuff I change, runhaskell is a great way to quick get the error list
16:11:39 <info_is_good> quickly*
16:11:52 <glguy> For that what we do is leave GHCi open and type :r
16:11:53 <Fuuzetsu> most use GHCi
16:12:32 <info_is_good> let me see
16:26:41 <amf> if im using lenses and i have two data types with the same record name (prefix with _), is there a way to tell ghc that im not trying to make records with the same name?
16:26:59 <amf> e.g. prevent Multiple declarations of ‚Äò_name‚Äô
16:27:26 <glguy> amf: You can put the types in different modules. If you're using makeFields to resolve the ambiguity you can use declareFields instead
16:27:55 <glguy> (declareFields strips away the record accessors after making the field lenses)
16:28:57 <amf> they are part of a sum type and id rather keep them in the same module. guess ill just wait for ghc 8 as makeFields was more hairy than i want
16:43:05 <athan> Is there a simple test to see if a path is well-formed? Or other things, like if the path is absolute or relative?
16:49:22 <pavonia> athan: The filepath package has function for this
16:49:29 <pavonia> *functions
16:53:39 <Chobbes> If I have... "type blah = Int \n type blah2 = Int" is there a way to get these two types grouped in Haddock? I want the same description for each.
17:04:41 <squall> I'm trying to run a single Haskell program on two computers each with a gpu and a dual core processor but one of which is running Windows and one is running Linux. I don't think I should use operating system threads, how should I target each device? Can I create an object representing a processor?
17:05:52 <Chobbes> squall: what kind of Haskell program is it? There are many abstractions for parallelism and concurrency in Haskell.
17:06:10 <squall> Just a finite difference scheme
17:06:32 <Chobbes> squall: obligatory reference to good book: http://chimera.labs.oreilly.com/books/1230000000929/index.html
17:07:05 <squall> But the tensor operations should be run on the gpu.
17:07:20 <Chobbes> squall: accelerate may be your friend.
17:07:31 <Chobbes> squall: http://chimera.labs.oreilly.com/books/1230000000929/ch06.html
17:07:51 <squall> I know accelerate
17:08:02 <Chobbes> squall: either way, you shouldn't really need to worry about the operating system.
17:08:16 <Chobbes> Oh wait.
17:08:20 <squall> It's all I am worried about
17:09:02 <Chobbes> squall: you mean you're trying to use two computers for computation of a single program. I think I misinterpreted you.
17:09:13 <squall> Correct
17:09:23 <Chobbes> squall: maybe look into cloud Haskell? I'm not really sure what the best approach is right now.
17:09:33 <squall> Os threads are no longer so appealing
17:09:42 <Chobbes> http://haskell-distributed.github.io/
17:10:00 <squall> Perhaps there is another package
17:10:07 <squall> I know that one too
17:10:50 <squall> I'm looking for a way to store a list of processors and push functions to then for evaluation
17:11:15 <eta> just use a threadpool
17:11:37 <squall> Sounds promising
17:11:54 <eta> have an Channel and push functions onto the channel and have the threads execute them
17:12:01 <eta> well, IO actions, not functions
17:13:30 <squall> Hmmm it does not seem apparent how threadpool designates threads to processors
17:13:45 <eta> well, it doesn't
17:13:58 <eta> that's going to be impossible on most operating systems
17:14:04 <squall> Something has to, that's the control I require
17:14:21 <eta> what exactly are you trying to do?
17:14:41 <eta> i can lead you in the correct direction for doing that, but its a long path full of holes, C, and assembly
17:15:00 <squall> Send the gpu heavy work top the machine with more gpu slots
17:15:20 <eta> Oh, you just want Vulkan
17:15:31 <squall> Cool!
17:15:36 <eta> which... isn't out yet :/
17:15:47 <eta> DirectX12 or Metal are, but I don't know too much about them
17:16:10 <eta> and are also tied to their specific OS
17:16:36 <squall> Yeh Google says no for vulcan
17:17:00 <eta> no because the specs not out or no because it doesn't do what you want?
17:17:34 <squall> I imagine the os detects the hardware and makes it visible to the os task scheduler, I was going I could get at that with a Haskell library
17:18:00 <squall> Because I can't find any documentation or hackage repo
17:18:15 <eta> you're really only luck would be to look into the linux kernel source or write your own kernel
17:19:23 <squall> Hmmm Julian just looks like opengl in that it is a collection of shader compilers to various gpu architectures
17:19:30 <squall> Vulkan
17:19:40 <awpr>  wait, I don't think he wants to control which *core* a function runs on, I think he means 'processor' as in an entire machine with different hardware capabilities
17:20:24 <squall> Can I trust a potentially unknown task scheduler to handle my threads?
17:20:38 <eta> are you looking for security or control?
17:20:51 <squall> No, speed
17:20:58 <eta> what for?
17:21:07 <arahael> Why are you using threads if you want speed?
17:21:12 <squall> Chemistry cluster
17:21:22 <delYsid> How do I write spans, something that behaves like span, but returns [([a],[a])], i.e. all the substeps until the predicate fails?
17:21:25 <eta> Why are you usign HASKELL if you want speed, Fortran, C, or Asm
17:22:14 <squall> Sorry I dropped connection
17:22:58 <squall> Why use threads? Because much of the work can be run in parallel
17:23:38 <eta> Have you looked at OpenCL or CUDA?
17:23:47 <squall> Yes I know these well
17:24:28 <squall> Llvm backend?
17:27:03 <squall> Perhaps requires mpi? I'd prefer a more automated solution, but I would like to control both three days flow between the machines and the geometry of the message passing between computational nodes running on various cores.
17:27:26 <squall> Both the data flow
17:28:38 <noonan> what about hacking on HaLVM? That would probably give you the most control on the thinnest os layer..
17:29:07 <squall> I'm guessing cloud Haskell for the machines and trust accelerate for the scheduling, but I was wondering if there was another interface allowing me more control over how the tasks were scheduled
17:30:35 <squall> This virtual machine idea sounds really nice thanks noonan
17:31:00 <noonan> I might be projecting, since I think it is cool and would like to play with it myself :)
17:31:36 <squall> Does anyone have any idea how to handle gpu scheduling in halvm?
17:32:49 <squall> Would accelerate work out the box on this os? How developed is it's thread handler and how may I handle threads?
17:34:05 <squall> Can I run fuck on halvm?
17:34:11 <squall> Wow sorry
17:34:21 <MarcelineVQ> :>
17:34:32 <squall> Ghci, that was a bad autocorrect
17:35:16 <squall> Sorry
17:35:51 <arahael> squall: How did autocorrect get to that?
17:35:57 <lemevi> this is going to be a controversial thing to say in this channel, but holy cow I really like haskell!
17:36:05 <arahael> lemevi: Tsk tsk.
17:36:10 <lemevi> sorry
17:36:13 <squall> Swype
17:36:26 <arahael> squall: You must say it a lot, then.
17:36:38 <squall> ...
17:36:54 <Oscar1130> squall: I was wondering how you got "both three days flow" instead of "both the data flow"...
17:36:58 <squall> I should burn my keyboard
17:37:26 <squall> Anyway
17:38:36 <squall> I'm seeing some stuff on halvm parallel benchmarking buy this all seems a bit experimental. Isn't there a way people are doing this commonly? If not an I missing something?
17:39:29 <squall> I.e. Should I just use cloud Haskell and the native os of each machine?
17:41:03 <squall> The only problem is that I don't trust the various os threaders to behave the same, and so I'd like a more robust way to structure the data handling, for proofs on its efficiency
17:42:33 <squall> Sorry I dropped connection again
17:49:07 <squall_> No?
17:54:18 <squall2> I guess I'll try it out then!
17:55:04 <squall2> Thanks
17:56:53 <Myrl> Is there a consuming version of notFollowedBy?
17:57:15 <Myrl> By that, I mean, "consume if string does not satisfy parser."
17:57:39 <submain> is there an easy way to convert [Either a b] to Either a [b]
17:57:41 <submain> ?
17:58:00 <shachaf> sequence
17:58:01 <noonan> submain: sequence?
17:58:19 <submain> cool, I thought sequence was just for maybes
17:59:04 <submain> thanks!
17:59:20 <Myrl> Is what I described even useful?
18:00:32 <pavonia> Myrl: How much data would it consume?
18:00:43 <Myrl> pavonia: Hmmm...
18:01:39 <Myrl> pavonia: It'd consume as much data as long as the parser is not satisfied?
18:02:53 <Myrl> Also, we have endBy, but not startBy?
18:04:09 <noonan> So I have a program where I'm doing a bunch of AST manipulations on a type like "data Ast = Ident | Inverse Ast | Product Ast Ast"; somebody here suggested I check out recursion-schemes (which is rad)
18:04:46 <pavonia> Myrl: Is "manyTill anyChar (try p)" what you want?
18:05:00 <geekosaur> ...startBy? somehow that sounds like the parser version of Intercal
18:05:02 <noonan> So I rewrote it to use "data AstF a = Ident | Inverse a | Product a a" and Fix
18:05:10 <Myrl> pavonia: More or less.
18:05:39 <noonan> so now I get cata to fold over my ASTs for free, but..
18:06:09 <lemevi> https://en.wikibooks.org/wiki/Haskell/Mutable_objects
18:06:16 <lemevi> that looks like some pretty imperative code down there
18:06:20 <lemevi> with that for_ loop
18:06:21 <noonan> I'd also like something like cataM to do a fold in a monadic context
18:06:51 <lemevi> is haskell like pure and immutable in theory only, but in reality people use for_ and IORefs all over the place?
18:06:56 <noonan> it seemed like maybe I could have put it together from what's already in recursion-schemes, but I couldn't figure it out
18:08:29 * hackagebot ghcjs-dom 0.2.2.0 - DOM library that supports both GHCJS and WebKitGTK  https://hackage.haskell.org/package/ghcjs-dom-0.2.2.0 (HamishMackenzie)
18:09:08 <noonan> and similarly, I'd like to annotate each AST node with something of type t like "data AnnAst t = AnnAst t (AstF (AnnAst T))", but then I don't get cata for free and I can't figure out if it can be written as a fix point..
18:09:21 <noonan> any ideas?
18:09:54 <shachaf> noonan: That's a cofree comonad. hth
18:10:00 <shachaf> Assumng that by T you meant t.
18:10:15 <shachaf> Annotating an AST is a common use of Cofree.
18:10:29 <noonan> awesome, thanks! that should probably be enough to get me there.
18:11:35 <noonan> Is there a solution for getting cataM in general? I had to write it as a regular cata which did pure / liftM / liftM2 to each constructor as appropriate, which was annoying and boilerplate-y.
18:11:43 <shachaf> Not to be confused with the coffee comonad, which allows you to extract theorems out of mathematicians.
18:12:16 <Hafydd> Or urine.
18:12:30 <noonan> isn't that the ffee command?  or is that for cotheorems and comathematicians?
18:13:01 <Myrl> Urgh.
18:14:19 <shachaf> What are some interesting examples of cofree things?
18:14:30 <shachaf> Algebraic structures in general seem to lend themselves toward free things.
18:14:35 <Myrl> Lol, I really made a mistake with my datatypes.
18:17:36 <lemevi> also the haskell I see on github looks pretty imperative
18:17:39 <lemevi> https://github.com/joeyh/git-annex/blob/master/Command/ConfigList.hs#L44
18:21:38 <johnw> shachaf: I kind of liked http://dlaing.org/cofun/posts/free_and_cofree.html
18:25:59 <shachaf> I want to know about cofree things other than comonads.
18:26:18 <johnw> ah, let me know if you find anything interesting
18:30:52 <Hafydd> That's not very nice Haskell.
18:34:33 <glguy_> Haskell's a nice imperative language.
18:37:58 <Fylwind> is there a reason why (~) is not feature-gated behind an extension pragma?
18:40:11 <shachaf> There is no reason because it is not true.
18:44:30 <lemevi> Hafydd: I've been going through haskell on github and there's a lot of that
18:44:44 <Hafydd> I suppose that's just the Law of Shit at work.
18:45:33 <Clownpiece1> Whats not nice haskell?
18:45:49 <lemevi> the haskell on the top haskell repos on github apparently
18:45:52 <Hafydd> This: https://github.com/joeyh/git-annex/blob/master/Command/ConfigList.hs#L44
18:45:55 <lemevi> you know like real world github
18:45:59 <lemevi> er
18:46:02 <lemevi> real world haskell
18:46:46 <Hafydd> (I've realised that the author is in this channel and probably watching the shit-talking, but I stand by it.)
18:46:59 <lemevi> I just read that pattern matching  "in Haskell, this is the only way to make a decision."
18:47:18 <lemevi> then I'm like really? and see if else statements and dos and stuff all over the haskell repons on github
18:47:27 <lemevi> I read that quote on https://www.seas.upenn.edu/~cis194/spring13/lectures/02-ADTs.html
18:47:33 <geekosaur> "do" does not make a decision
18:47:48 <geekosaur> "if" is syntactic sugar that becomes a case
18:49:56 <Clownpiece1> So it would be acurate to say that in /Core/ its all case matching, but saying that about Haskell is a bit iffy to me.
18:50:11 <geekosaur> the desugaring is in Haskell, not core
18:50:36 <Clownpiece1> Still.
18:50:39 <lemevi> do may not making a decision but it seems to create a context in which you can create some pretty imperative code structure
18:51:05 <Clownpiece1> what does making a decision and imperative code structure have to do with each other?
18:51:09 <Clownpiece1> *do
18:52:06 <Fuuzetsu> Clownpiece1: iffy why? when you have a type, best you can do is pattern match on it
18:52:14 <lemevi> well I guess there's a difference in how decisions are made in declarative vs imperative code
18:52:18 <Fuuzetsu> you can build other decision-making things on top of it but in the end you're pattern matching
18:52:24 <geekosaur> and yet do is still more syntactic sugar that translates to Haskell
19:01:00 <lemevi> I like pattern matching
19:01:05 <lemevi> it's new to me though
19:01:13 <lemevi> well in the context of haskell
19:01:35 <lemevi> I've used pattern matching in regular expressions and parsers and in scala etc
19:02:29 <lemevi> pattern matching is very expressive, I think I prefer it over the if else syntactic sugar but I haven't written any haskell outside of learning exercises 
19:02:59 <rhovland> do guards desugar to a case?
19:03:18 <Clownpiece1> Fuuzetsu: Theres also if. Though I grant its just very very thin sugar.
19:05:32 <Clownpiece1> lemevi: "case bool of True -> bla; False -> blabla"; vs "if bool then bla else blabla" hmm. I think I slightly prefer the if one, just for conciseness.
19:06:27 <lemevi> yeah that's more readable
19:07:05 <kzong> When I check the type of prehook function (from spock package) I can see the type is MonadIO m =>  ActionCtxT ctx m ctx' -> SpockCtxT ctx' m () -> SpockCtxT ctx m (); but when I apply a function to prehook, the type change to: (MonadIO m, Num ctx') => SpockCtxT ctx' m () -> SpockCtxT ctx m (). What is this and how do I read it?
19:07:15 <Fuuzetsu> I often use case over if anyway
19:09:14 <kzong> I still can't understand how the type can changed from ActionCtxT ctx m ctx' -> SpockCtxT ctx' m () -> SpockCtxT ctx m () to SpockCtxT ctx' m () -> SpockCtxT ctx m ()
19:09:21 <qmm> import Data.List
19:09:28 <qmm> lastButOneIndex l = length l = 2
19:09:39 <qmm> oops
19:09:43 <qmm> lastButOneIndex l = length l - 2
19:09:50 <qmm> lastButOne l = l !! lastButOneIndex l
19:09:55 <qmm> :l ch2.hs
19:10:00 <qmm> ch2.hs:4:30: Not in scope: ‚Äò-‚Äô
19:10:59 <Fuuzetsu> do you have NoImplicitPrelude or something?
19:11:08 <qmm> not that i'm aware of
19:11:23 <qmm> ah
19:11:28 <qmm> ~/.ghci has :set -XNoImplicitPrelude
19:11:38 <qmm> how do you make it explicit without removing this?
19:11:45 <Fuuzetsu> import Prelude
19:12:25 <qmm> thank you Fuuzetsu :)
19:12:42 <Fuuzetsu> np
19:12:46 <qmm> it's probably not the best implementation, but it's all I could think of 
19:13:07 <Fuuzetsu> it seems strange to me
19:13:22 <Fuuzetsu> do you know of ‚Äòinit‚Äô by tha way?
19:13:23 <Clownpiece1> kzong: Looks like its getting aplied to a ActionCtxT ctx m ctx'.
19:13:30 <Fuuzetsu> @src init
19:13:30 <lambdabot> init [x]    = []
19:13:30 <lambdabot> init (x:xs) = x : init xs
19:13:30 <lambdabot> init []     = undefined
19:13:33 <qmm> i saw that
19:13:34 <EvanR> you can import Prelude hiding (whatever) instead of no implicit prelude
19:14:04 <Clownpiece1> Usually you only want no implicit prelude if you are replacing the prelude.
19:15:11 <qmm> thanks EvanR 
19:15:26 <qmm> Clownpiece1: oh, i didn't know that
19:16:33 <qmm> last tail init list
19:16:41 <qmm> i want something like that
19:18:16 <Clownpiece1> qmm: Other people would disagree with me.
19:18:29 <qmm> last (tail (init list))
19:18:55 <EvanR> isnt last (tail (...)) = last (...)
19:19:04 <qmm> you are correct
19:19:21 <EvanR> except for
19:19:28 <EvanR> > last (tail [0])
19:19:29 <lambdabot>  *Exception: Prelude.last: empty list
19:19:32 <qmm> wait, no 
19:19:35 <qmm> it works as expected
19:19:40 <qmm> it gives me lastButOne
19:19:58 <EvanR> > last (tail [0,1,2,3])
19:19:59 <lambdabot>  3
19:20:12 <qmm> > last (tail (init [1,2,3]))
19:20:13 <lambdabot>  2
19:20:33 <EvanR> > last (init [1,2,3])
19:20:34 <Fuuzetsu> what's the point of tail?
19:20:35 <lambdabot>  2
19:20:38 <Fuuzetsu> right
19:21:12 <EvanR> it sort of messes you up in the case of 1-elemnt list
19:21:45 <qmm> Fuuzetsu: ah, right
19:21:56 <qmm> not sure what i was thinking there :)
19:22:45 <qmm> i love haskell so much
19:22:51 <lemevi> yeah it's pretty cool
19:23:18 <qmm> oh, i actually have something others may find interesting :)
19:24:10 <lemevi> I'm learning haskell just to learn about functional programming, I'm not sure I would choose haskell if I had a need to accomplish some task 
19:24:16 <lemevi> I kind of like kotlin or java 8 these days
19:24:44 <EvanR> theres some time to get up to speed with haskell for "tasks"
19:25:24 <EvanR> its already weird enough relative to other languages that tutorials dont spend too much time on the interface to the outside world
19:25:24 <lemevi> yeah, I want to write an irc bot from scratch or do some other thing after going through all the reading I'm doing to learn haskell now
19:25:40 <qmm> lemevi: i want to use haskell's parsec library for a language i've been thinking about for awhile
19:25:52 <qmm> i think this is where haskell shines
19:26:01 <EvanR> parsec is pretty good
19:26:12 <EvanR> again, time to get up to speed for tasks ;)
19:26:14 <lemevi> oh, that's pretty cool
19:26:17 <AfC> Is there a way to use `stack` to generate a comprehensive local documentation set? I see it generating some docs in .stack-work, there's others in ~/.stack/snapshots, but none of them seem to hyperlink to base anywhere. What index.html should I be looking at?
19:26:21 <qmm> and to start using it for tasks, i'm starting with very small focuesed tasks
19:26:30 <lemevi> I used jison to write a parser once, it's a javascript implementation of flex/bison
19:26:35 <qmm> at least, that's the plan, it'll be a few weeks before that happens 
19:26:41 <lemevi> that's the extent of my parser experience
19:26:46 <EvanR> flex/bison are decidedly trickier to use
19:26:54 <lemevi> it was pretty fun
19:27:01 <lemevi> it was just a personal project though
19:27:11 <EvanR> C stuff is all very "fun" ;)
19:27:22 <lemevi> well this wasn't C, it was JavaScript :P
19:27:33 <EvanR> double the fun then
19:27:38 <lemevi> I write JavaScript to pay the bills
19:28:02 <lemevi> as a language it's getting better though
19:28:19 <exio4> it's getting more workarounds you mean? :P
19:28:21 <EvanR> its getting more obvious people should not be writing in js directly
19:28:22 <lemevi> :D
19:28:27 <qmm> lemevi: i think it's at a stage where it can be used in production systems
19:28:31 <lemevi> we don't, we use babel
19:28:44 <qmm> lemevi: i am by no means a voice to trust on this :)
19:29:03 <EvanR> javascript used in production systems? yeah right
19:29:14 <lemevi> lots of companies do it just fine
19:29:23 <EvanR> thatll be the day
19:29:25 <songzh> I implement a top-down derive by using TH, but I encountered 3 problems. Could any one help?
19:29:28 <songzh> https://ghc.haskell.org/trac/ghc/ticket/10607
19:29:30 <qmm> EvanR: i'm sorry, i was distracted. i wasn't advocating js :)
19:29:39 <lemevi> I mean netflix runs services on node.js
19:29:42 <qmm> i thought we were still talking about haskell
19:29:48 <lemevi> so, that day has come
19:29:49 <EvanR> tell me another one
19:29:49 <lemevi> :\\
19:29:58 <songzh> ‚Äãhttps://github.com/HaskellZhangSong/TopdownDerive
19:29:58 <lemevi> rackspace's monitoring service is node.js
19:30:03 <qmm> EvanR: wal-mart
19:30:19 <lemevi> there's lots of js in production
19:30:31 <EvanR> i was being sarcastic
19:30:34 <lemevi> :P
19:30:41 <qmm> EvanR:  "I think in the future, as proofs and programs become closer, people will see unit testing as a very primitive way to check program correctness, necessitated only by the limitations of formally incoherent programming languages"
19:30:45 <EvanR> thats like C is almost ready to be used in production
19:30:50 <lemevi> haha
19:31:14 <EvanR> qmm: uh, walmart said that?
19:31:17 <qmm> no
19:31:29 <qmm> that's someone discussing the future with dependent types
19:31:53 <qmm> i saw phillip wadler's talk recently and it got me so excited i started to read the idris tutorial
19:32:06 <qmm> even though idris wasn't in his slides
19:32:19 <songzh> a new paper?
19:32:35 <qmm> a new talk at the recent strangeloop conference
19:32:49 <qmm> EvanR: the quote is from http://spin.atomicobject.com/2012/11/11/unifying-programming-and-math-the-dependent-type-revolution/
19:33:06 <qmm> so are we going to be able to get rid of unit tests with dependent types?
19:33:11 <EvanR> yeah the era of dependent-types-are-the-future
19:33:37 <exio4> maybe in 20 years
19:33:59 <EvanR> maybe theyll be able to make that claim in 20 years ;)
19:34:24 <MarcelineVQ> I can't tell which statements are sarcastic anymore :O
19:34:50 <EvanR> qmm: you can really cut down on unit tests already with a simpler type system, and quickcheck-like stuff
19:34:52 <qmm> i was also reading another article earlier today where it was saying that dependent types will allow us to focus more on the specification instead of the implementation
19:34:59 <AlainODea> qmm: no. The tests are just encoded as types. It moves the tests to a (hopefully) more concise, more consistent form as type decla
19:35:13 <EvanR> AlainODea: dependent types arent tests
19:35:25 <EvanR> they are logical propositions
19:35:46 <EvanR> after type checking, they dont do any computation
19:35:57 <qmm> EvanR: by simpler, do you mean "well-typed"?
19:36:05 <EvanR> qmm: i meant haskells type system
19:36:20 <qmm> EvanR: thank you for your time, btw
19:36:29 <EvanR> ignoring the approaching at greater and gerater complexity dependent types in ghc extensions
19:37:51 <orion> Is it legal for a type to begin with a number?
19:39:13 <EvanR> https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/type-level-literals.html
19:39:28 <EvanR> apparently you can use numeric literals at the type level 
19:39:46 <EvanR> with extensions
19:40:29 <ReinH> orion: no
19:43:42 <qmm> ReinH, EvanR: you both are giving separate answers to orion's question. which is it?
19:44:08 <EvanR> you cant do data 3Foo = 
19:44:09 <qmm> type level literals aren't types that begin with a number?
19:44:16 <qmm> oh
19:47:17 <Clownpiece1> No they let you use "Bob" and 4 as tags on types.
19:47:43 <ReinH> DataKinds enables type-level natural numbers, but you can't define your own type that begins with a number.
19:48:17 <Clownpiece1> Or well "types" of kind String and Nat, IIRC.
19:48:31 <EvanR> types in scare quotes? ;)
19:48:55 <EvanR> theyre honest to god types
19:49:36 <awpr> the scare quotes are because most people think of "type" as the type of a value; but types that aren't of kind * are not the same as that
19:50:36 <Maxdamantus> > let foo :: Maybe in 5
19:50:37 <lambdabot>      The type signature for ‚Äòfoo‚Äô lacks an accompanying binding
19:50:38 <Clownpiece1> Yeah, they aren't a type anymore then Maybe by itself is.
19:52:10 <Clownpiece1> > let {foo :: Maybe; foo = error ""} in foo x :: 5
19:52:12 <lambdabot>      Expecting one more argument to ‚ÄòMaybe‚Äô
19:52:12 <lambdabot>      Expected a type, but ‚ÄòMaybe‚Äô has kind ‚Äò* -> *‚Äô
19:52:12 <lambdabot>      In the type signature for ‚Äòfoo‚Äô: foo :: Maybe
19:52:17 <qmm> thanks for the conversation! i'm out for the day
19:52:20 <EvanR> that makes the whole system even more confusing
19:57:08 <Maxdamantus> Yeah, that "expected a type" error was what I was intending, but was in the middle of something.
19:58:27 <EvanR> what would 3 be called in 3 :: Nat then
19:59:46 <Maxdamantus> A value term.
20:00:59 <Maxdamantus> in Idris/Agda you don't have a distinction between value terms and type-level terms, so you can just say "term" there.
20:01:06 <Maxdamantus> unfortunately Haskell does.
20:01:42 <EvanR> the type literal 3 is a value term not a type level term?
20:02:00 <ReinH> Clownpiece1: Maybe is a type.
20:02:18 <ReinH> The problem is that "type" has different meanings in different contexts.
20:02:23 <Maxdamantus> in Haskell? `3` has to be a value term.
20:02:40 <Maxdamantus> >> let a :: 3; a = a in 5
20:02:43 <Maxdamantus> > let a :: 3; a = a in 5
20:02:45 <lambdabot>      Expected a type, but ‚Äò3‚Äô has kind ‚ÄòGHC.TypeLits.Nat‚Äô
20:02:45 <lambdabot>      In the type signature for ‚Äòa‚Äô: a :: 3
20:02:45 <lambdabot>      In the expression:
20:03:00 <Maxdamantus> Ah, some GHC extension.
20:03:07 <EvanR> "Ceci n'est pas une type"
20:03:26 <ReinH> GHC takes "type" to mean "type of kind *".
20:03:38 <awpr> in Haskell parlance everything that participates in type-level stuff is a type; in Idris for example Type is only things that could be inhabited
20:03:39 <Maxdamantus> type-level term of kind *
20:05:36 <EvanR> :k 3
20:05:37 <lambdabot> GHC.TypeLits.Nat
20:05:39 <Maxdamantus> I've said before that there should be a more consise word for them.
20:05:43 <EvanR> :k "Not a type"
20:05:44 <lambdabot> GHC.TypeLits.Symbol
20:05:45 <Maxdamantus> "type" is wrong.
20:06:10 <EvanR> the RHS of :: should be the answer right ;)
20:06:25 <EvanR> 3 is a Nat, Nat is a BOX
20:06:49 <Maxdamantus> well, the RHS of :: can sometimes be a kind .. or maybe that's a GHC extension.
20:07:18 <Maxdamantus> (in which case the LHS is a type-level term)
20:07:30 <EvanR> a term is a term
20:07:32 <EvanR> a kind is a kind
20:07:34 <octophore2> hi :3 which of the 64 or 32 bit Haskell Platform downloads should I get for running on 64 bit Windows? (are they both stable?)
20:07:51 <EvanR> a box is a box
20:07:52 <Maxdamantus> imo, call them vands.
20:07:54 <ezyang> octophore2: 64-bit should be fine 
20:08:01 <Maxdamantus> type is one kind of vand.
20:08:07 <EvanR> vand?
20:08:08 <Maxdamantus> type ‚Üí type is another vand.
20:08:09 <Clownpiece1> Nat is only a kind curently.
20:08:10 <octophore2> thanks :)
20:08:19 <Maxdamantus> vand. The thing between values and kinds.
20:08:44 <EvanR> Nat is a BOX = Nat is only a kind
20:08:48 <ezyang> If you're teaching beginners Haskell and want to get the comfortable with using typeclasses (purely from an end-user perspective), what kind of coding task would you ask them to do? 
20:10:02 <noonan> what do they know so far?
20:10:30 <ezyang> they know basic Haskell, so like pattern matching, recursion, data types 
20:10:46 <ezyang> I'll also have tricked them into using some functions that use typeclasses, although sweeping the details under the rug 
20:10:59 <ezyang> They'll know a little bit about types 
20:11:18 <noonan> maybe something like a class with serialize / deserialize functions?
20:11:37 <Clownpiece1> Or just Ord?
20:12:02 <noonan> oh, maybe that's better.
20:12:11 <ezyang> Well, specifically what? Like, "Using type classes, make an API for serializing/deserializing things"? 
20:12:34 <ezyang> Clownpiece1: Ord and other typeclasses in Prelude are a bit difficult, because there's linguistic confusion for "our Ord" as well as "Prelude's Ord" 
20:12:48 <Maxdamantus> er, forget the last two things I said.
20:13:09 <Clownpiece1> Maxdamantus: about "vand"?
20:13:21 <Clownpiece1> ezyang: Oh, I didn't think of that.
20:13:21 <Maxdamantus> actually, the two things before the last thing I said (excluding the very last thing)
20:13:31 <noonan> I think I missed the mark; I thought you wanted to have them build instances for a class you define, but it sounds like you want them to design the class.
20:13:44 <EvanR> ezyang: custom typeclasses are kind of hard to do right, theyre not really a good beginner technique i thnk
20:14:08 <ezyang> noonan: Not necessarily. Honestly, I just want them to know enough about type classes to think, "Man, I really wish I had a typeclass" when they're coding somewhere else 
20:14:08 <EvanR> you wouldnt reach for them as a beginner. youd use existing classes
20:14:11 <ezyang> EvanR: Duly noted. 
20:14:52 <EvanR> they were invented to do arithmetic operators, and they ended up being used for logic programming
20:15:33 <ezyang> I also want to set the groundwork for monads, which are next week 
20:15:54 <EvanR> for ad-hoc polymorphism you can introduce records instead
20:16:07 <ezyang> So, it sort of sounds like just some easy programming exercises using existing type classes would be the recommended thing 
20:17:01 <awpr> isSorted :: Ord a => [a] -> Bool perhaps
20:17:04 <noonan> Especially if it's working toward "let's look at a zillion instances of this relatively complicated, built-in typeclass" :)
20:17:57 <ezyang> awpr: Oh, that's a nice one 
20:18:39 <ezyang> I guess, one problem is, I feel a bit doubtful whether or not just writing things like isSorted is really enough to get people understanding what typeclasses are about 
20:20:30 <ezyang> The (non)analogy to OO is kind of useful. 
20:22:18 <Clownpiece1> Hmm.
20:22:27 <Clownpiece1> You mean contrasting them to Classes?
20:22:31 <ezyang> yeah 
20:22:53 <ezyang> As in, an example where it behaves differently than OO classes would be useful 
20:23:05 <Clownpiece1> Conceptually they are pretty identical to interfaces, though the differnces in implemention are important.
20:23:08 <Clownpiece1> hmm.
20:23:27 <ezyang> No, they're pretty different from interfaces 
20:23:29 <Clownpiece1> Serialzation/deserialzation is a good choice then.
20:23:30 <ezyang> value versus type dispatch 
20:23:34 <awpr> I would call them generalized interfaces.  or if you want to bash OO more, say interfaces are a broken implementation of typeclasses
20:24:16 <Cale> heh
20:24:24 <Clownpiece1> "value versus type dispatch" I think I know what you mean, but could you explain?
20:24:54 <ezyang> Clownpiece1: OO interfaces select implementations for the interface based on the object value; e.g. you can have two objects with the same type but different behaviors 
20:25:15 <ezyang> Typeclasses select implementation based on the type 
20:25:17 <Cale> Type class polymorphism is its own thing, and is more closely related to parametric polymorphism than to ad-hoc polymorphism or subtyping polymorphism.
20:25:59 <Cale> A key thing about how type class polymorphism works is that you get to define new polymorphic values simply by using existing ones.
20:26:31 <Cale> e.g. sort uses the comparison operations, and ends up with the polymorphic type (Ord a) => [a] -> [a]
20:27:16 <awpr> interfaces still dispatch  on type though, it's just the dynamic type rather than static, and it's tied to one particular value
20:27:24 <ezyang> Yes. So I'm definitely going to have them, later in the lab, rewrite their code in explicit dictionary passing style 
20:27:29 <Cale> (which distinguishes it from ad-hoc polymorphism)
20:27:41 <Cale> ezyang: Thanks for that by the way :)
20:27:55 <Cale> ezyang: There's too few people who consider the option of passing records
20:28:01 <ezyang> Cale: :) 
20:28:18 <ezyang> awpr: True enough. 
20:28:39 <Cale> There are cases where you can do things with records that you can't do with the corresponding type classes as well
20:28:57 <Cale> e.g. if in order to build the record, you'll need values which came from doing I/O
20:29:11 <Clownpiece1> Cale: I thought type class polymorphism was an implementation of ad-hoc?
20:29:30 <Cale> Clownpiece1: A lot of people get confused about that because of the name of the paper which introduced type classes
20:29:40 <Cale> (How to make ad-hoc polymorphism less ad-hoc)
20:29:53 <Cale> But I think it's wrong to classify type class polymorphism as ad-hoc
20:30:20 <Cale> Ad-hoc polymorphism has you commit to an implementation of something based on the type context at the usage site alone.
20:30:26 <Cale> You can't defer that decision.
20:30:32 <Cale> With type class polymorphism, you can.
20:31:52 <ezyang> Cale: C++ template writers would disagree! :P 
20:32:08 <Cale> C++ templates aren't ad-hoc polymorphism either
20:32:37 <Cale> Like, if you had ad-hoc polymorphic implementations of (<=), you might be able to write sort using them, but you'd have to determine which (<=) it was that you were using, and you'd only be able to write a monomorphic sort function.
20:32:54 <Clownpiece1> ow.
20:33:37 <ezyang> Erm, I mean, C++ overloading is an instance of ad-hoc polymorphism, and C++ templates can be used to delay the decision. 
20:33:44 <ezyang> Maybe you'd still disagree though! 
20:34:39 <Cale> Yeah, well, that's two things working together to get a little closer to what type class polymorphism does
20:34:43 <ezyang> :) 
20:48:12 <programo> Hi , I have started programming in haskell recently and found it very intresting. I would like to contribute to some open source projects and also participte in gsoc 2016.Could anybody provide suggestions in this regard
20:49:43 <athan> programo: CODE :|
20:49:45 <danilo2> Hello guys :) Would it be theoretically safe to define instance of Functor for System.Mem.Weak.Weak using UnsafePerformIO and NoInline pragma? Is there a way it would fail when using it with for example different threads?
20:50:49 <athan> danilo2: Well, unsafePerformIO is /very/ risky when you want to operate on that data concurrently
20:51:08 <athan> is there a serious reason why you need Functor? There may be a `map` function hidden somewhere
20:51:46 <awpr> actually this might be a real use case for Coyoneda
20:52:46 <programo> athan, thank you !
20:53:03 <danilo2> than: no, no I don't need it so much, I'm just asking about it to learn more. I was just thinking in what situation something like that would fail. If we use NoInline pragma could the functor be computed by two threads and give different results? I suppose yes. Will it affect somehow GHC optimisations? That is a good question. Or will it affect only the clarity of the code?
20:54:54 <athan> danilo2: Good questions indeed :) I think that even with NoInline, you still run the risk of two concurrent threads mashing together (when using -threaded). Maybe quickcheck can be of service?
20:57:35 <danilo2> than: I'm sure it will, there is nothing protecting haskell for doing it this way.  I would just know if somebody thinks it will affect somehow how GHC optimises the code. Measuring it with anything (because its garbage-collection related question) would be little hard to accomplish
20:57:42 <flounders> Right now I am working on a feed reader in Haskell and was wondering if I should try embedding a web engine in a graphical toolkit (like WebKitGtk) or just make the whole thing a web app? I'm asking in terms of library maturity here more than anything.
20:58:34 <Cale> flounders: I know that reflex-dom will automatically switch to webkit if you build using ordinary ghc
21:00:00 <flounders> Cale: Thanks checking it out now.
21:08:35 * hackagebot standalone-derive-topdown 0.0.0.1 - This package will derive class instance along the data type declaration tree.  https://hackage.haskell.org/package/standalone-derive-topdown-0.0.0.1 (songzh)
21:29:33 <kristof> I never thought I would actually use the list monad
21:29:47 <kristof> And here I am, generating a cartesian product.
21:34:00 <kyfho> is ti me or deos python kinda suck
21:34:05 <kyfho> wow
21:34:10 <kyfho> haskell has to be better
21:34:22 <glguy> Python bashing is off-topic in #haskell
21:34:27 <kyfho> ok
21:34:38 <kyfho> emitting strings is not a problem for haskell I imagine?
21:36:23 <julianleviston> > ‚Äúthis is a string" ++ " joined to another"
21:36:24 <lambdabot>  <hint>:1:1: lexical error at character '\8220'
21:36:40 <julianleviston> > "this is a string" ++ " joined to another"
21:36:41 <geekosaur> defeated by smart quotes
21:36:41 <lambdabot>  "this is a string joined to another"
21:36:45 <julianleviston> indeed!
21:37:35 <julianleviston> geekosaur: ironic, because I actually went out of my way to paste it into an editor to not get curlies, only to have to type ‚Äú> ‚Äú in front of it, and have my IRC client convert ‚Äúfor me‚Äù lol.
21:38:04 * geekosaur turns that substitution off everywhere
21:38:12 <geekosaur> if I want smart quotes I know how to explicitly type them
21:38:13 <julianleviston> kyfho: depending on what you mean by ‚Äúemit‚Äù and ‚Äústring‚Äù, haskell is definitely capable of emitting strings.
21:38:23 <geekosaur> but like 99% of the time I'm in a context where they're not wanted
21:43:32 <julianleviston> kyfho: what kind of strings do you want to emit? :)
21:44:28 <glguy> Everyone can probably relax, the question is fully answered
21:46:29 <julianleviston> glguy: It‚Äôs my question! :)
21:46:41 <julianleviston> glguy: hehe. I‚Äôm curious. :) But fair enough. I‚Äôll be quiet.
22:23:37 * hackagebot second-transfer 0.7.1.0 - Second Transfer HTTP/2 web server  https://hackage.haskell.org/package/second-transfer-0.7.1.0 (dsign)
22:34:53 <julianleviston> what does ‚Äúquotient out‚Äù mean?
22:35:37 <scshunt> julianleviston: do you know what an equivalence relation is?
22:36:01 <julianleviston> scshunt: no
22:36:06 <julianleviston> scshunt: this is the context: In standard Haskell, we cannot quotient out or choose specific inhabitants (values) of types as arguments.
22:36:28 <julianleviston> scshunt: I‚Äôm guessing it simply means constrain the type on specific data or lack thereof?
22:37:20 <joobus> I think bytemyapp is writing a haskell book.  does anyone have a link to the books site?
22:37:42 <MarcelineVQ> http://haskellbook.com/
22:38:00 <julianleviston> joobus: lol that phase I just pasted is from it.
22:39:24 <julianleviston> scshunt: I just looked up equivalence relations and quotient sets. Nevermind, I‚Äôll just leave that for now.
22:39:38 <joobus> will the book be published in physical form?
22:40:00 <MarcelineVQ> check out the faq page :>
22:40:03 <joobus> julianleviston: i just logged on ;)
22:40:15 <julianleviston> joobus: oh so you did. sorry.
22:40:42 <julianleviston> joobus: the site answers that question, I think. http://haskellbook.com/faq.html
22:42:10 <scshunt> julianleviston: basically he's saying  that you can't make a function whose domain is all even numbers
22:42:26 <scshunt> if you accept an argument of a type, it's all or nothing
22:43:34 <julianleviston> scshunt: yep. That‚Äôs exactly what I understood it to mean.
22:43:38 <julianleviston> scshunt: thanks
22:43:56 <kristof> You guys know how flymake puts the error right at the location?
22:44:09 <kristof> Is there a way to get ghcmod's typechecking to do the same thing?
22:45:39 <xpilot> hello
22:45:52 <xpilot> what is the recommended way to do generics?
22:46:09 <kristof> use lowercase variable names
22:46:15 <scshunt> generics?
22:46:19 <xpilot> I see Data.Data, GHC.Generics, Uniplate
22:46:20 <kristof> for generic functions: myFun:: a -> b
22:46:31 <scshunt> kristof: exactly that
22:46:31 <glguy_> Xpilot: depends on the situation
22:46:35 <xpilot> no I mean datatype-generic operations
22:46:40 <xpilot> hi glguy_
22:46:50 <kristof> for generic datatypes: data MyData a = MyData a
22:47:00 <kristof> xpilot: see what I've written
22:47:10 <xpilot> I tried using Data.Data, but it looks like I can't get the types of the constructor fields
22:48:09 <xpilot> :t constrFields
22:48:10 <lambdabot> Constr -> [String]
22:48:34 <kristof> Oh, you mean scrap your boilerplate
22:48:45 <xpilot> kristof: yeah, that sort of thing
22:49:19 <xpilot> given a datatype, I'd like to generically get it's constructors and their fields
22:50:07 <kristof> Never played with SYB before
22:50:13 <xpilot> it looks like Data.Data can't do this - maybe GHC.Generics can?
22:50:15 <kristof> Is this stuff all runtime? Sounds like reflection
22:50:32 <xpilot> yeah reflection is the right name for it
22:50:59 <kristof> xpilot: I don't know if there's even a way to write the type of a function that takes a datatype and gives you back the constructors and fields
22:51:13 <kristof> you can't write [field], for instance, because they're all different types
22:51:53 <xpilot> of course such a function isn't well typed, but neither is Typeable - you use untyped representations
22:52:14 <xpilot> :t dataTypeConstrs
22:52:15 <lambdabot> DataType -> [Constr]
22:52:20 <xpilot> like that
22:53:04 <julianleviston> it‚Äôs a real pity that the language itself isn‚Äôt more functional.
22:53:38 <julianleviston> I guess we‚Äôll get there :)
22:53:56 <kristof> xpilot: I was going to say "dataTypeConstrs" for "get constructors"
22:54:09 <julianleviston> and I guess because types are erased at runtime, it makes things difficult to do things with types at that level
22:54:32 <glguy_> Xpilot: do you have an example of what you would want the generics to generate?
22:54:41 <julianleviston> would you not just use lenses for this use case?
22:54:44 <kristof> xpilot: constrFields gives you the field's labels, but that doesn't tell you its type.
22:54:46 <glguy_> Without using generics
22:55:44 <kristof> xpilot: Actually, yes, constrRep will give you the types
22:55:51 <xpilot> glguy_: what I want is a data type rep to be a list of constructors, and a constructor rep to be a list datatypes
22:55:59 <kristof> If I'm understand what ConstrRep means
22:56:10 <xpilot> kristof: it will? I haven't been able to get anything useful out of it
22:56:20 <kristof> :(
22:57:42 <glguy_> Xpilot, I'd still need to know what you're trying to do with that information
22:58:36 <xpilot> glguy_: so for data Nat = Z | S Nat I'd like to have natRep = [zRep, sRep], zRep = [], sRep = [natRep]
22:58:45 <xpilot> with some extra meta data like names of course
22:59:06 <ezyang> I wonder... SPJ has a talk "Classes, Jim, but not as we know them"... oh it's Star Trek reference haha 
22:59:23 <xpilot> natRep being a DataRep and zRep,sRep being ConstrReps or something
22:59:59 <glguy_> And what do you want to do with those?
23:00:34 <xpilot> well that allows me to reconstruct the Nat datatype at the value level
23:00:50 <xpilot> I'd also like to have a way of going from actual Nats to the Reps of course
23:01:02 <julianleviston> What‚Äôs the GHC extension that lets you elide data constructor fields in pattern matches?
23:01:10 <julianleviston> is it wildcard records?
23:01:28 <julianleviston> sorry I‚Äôll google
23:01:32 <xpilot> my ultimate goal is to do this on parse trees, like from Language.Java.Syntax
23:01:50 <xpilot> which has lots and lots of data types that I should be able to process generically
23:02:12 <xpilot> additionally, I should be able to extract the grammar itself generically
23:02:44 <julianleviston> Oh‚Ä¶ but I want to pattern match on _, not automagically assign all the field names to vars.
23:03:04 <julianleviston> Can I do that?
23:03:47 <julianleviston> something like: doSomething Comp{_} = ...
23:04:22 <julianleviston> where ordinarily I‚Äôd say doSomething (Comp _ _ _ _) and then when my def‚Äôn of Comp changes, I have to go through the entire source and change the number of _‚Äôs there are.
23:04:41 <crough> julianleviston: I think Comp{} does that
23:04:48 <julianleviston> crough: I‚Äôll check thanks
23:05:37 <julianleviston> crough: yep! thanks :0
23:05:40 <julianleviston> crough: :)
23:06:31 <crough> Of course!
23:28:23 <RedNifre> Good morning.
23:28:50 <crough> Morning!
23:28:56 <tabemann> is there a recommended approach for converting between Strings and UTF8-encoded ByteStrings?
23:29:25 <RedNifre> tabemann probably something to do with Text instead of String I would guess.
23:29:50 <crough> tabemann: I always `Data.Text.Encoding.encodeUtf8 . Data.Text.pack`
23:29:56 <crough> Pretty sure that's not great though
23:30:41 <glguy_> My utf8-string package has a function for that if you want to save the trip through Text
23:31:17 <tabemann> I was looking at utf8-string
23:32:40 <RedNifre> So I was wondering about what I think is called "Higher kinded types" which aren't standard... I mean, there are a lot of "one way" things like separate toJSON and fromJSON instances or monad transformers where one half is explicit and the other is generic, like MaybeT... could all this be simplified with higher kinded types? E.g. I like Convertible A B and use it to convert database rows to records and back instead of having separate 
23:32:40 <RedNifre> toDatabaseRow and fromDatabaseRow type classes (vocabulary might be inaccurate here). E.g. I would find one MonadTransformer A B type more intuitive than a bunch of SomeMonadT things... or would this be impossible? Am I making sense here? :)
23:33:33 <RedNifre> tabemann you might want to consider that String can contain invalid chars, e.g. U+FFFE, so using String instead of Text can become tricky...
23:33:43 <julianleviston> RedNifre: you want to separate monad transformer out as a separate thing from all the transformers?
23:34:14 <glguy_> That sounds like multi parameter type classes
23:34:20 <crough> RedNifre: I'm sure someone has defined "Isomorphic A B" befofe, but I don't know where
23:34:39 <crough> And yeah, glguy_ is correct: this is MultiParamTypeClasses
23:34:58 <glguy_> There's no limitation that keeps from and to json from being in the same class
23:35:03 <julianleviston> crough: https://hackage.haskell.org/package/lens-2.6/docs/Control-Lens-Isomorphic.html ?
23:35:13 <glguy_> It's just more flexible that way
23:35:35 <crough> Of course it's Lens ')
23:35:39 <julianleviston> lol
23:35:43 <RedNifre> julianleviston Well, I find Convertible MyType String + Convertible String MyType cleaner than having separate instances for Show MyType and Read MyType because in my head it's sort of the same thing only in different directions so having unrelated classes seems counter intuitive to me. Same for having MaybeT instead of a hypothetical T Maybe A...
23:35:45 <crough> it's *always* in Lens
23:35:47 <julianleviston> Haskell‚Äôs big old bag of tricks.
23:35:53 <glguy_> General purpose conversion classes general aren't useful and require lots of type annotations
23:36:16 <crough> Yeah, they tend to break type inference to a frustrating extent.
23:36:26 <glguy_> Read and show could be merged but then you'd always have to provide both
23:36:30 <glguy_> Or none
23:36:33 <RedNifre> no no no
23:36:36 <julianleviston> glguy: in general, generalisations aren‚Äôt ungeneral enough for specific use‚Ä¶ generally ;-) right? :)
23:36:39 <RedNifre> I don't want both in the same class.
23:37:01 <glguy_> Julian, sure
23:37:19 <RedNifre> So no class ReadAndShow, but instead Conventible MyType String and Convertible String MyType...
23:37:37 <crough> Yeah RedNifre: That's `Isomorphism` 
23:37:38 <julianleviston> RedNifre: what does that mean?
23:38:11 <RedNifre> julianleviston Do you know Convertible? (Not sure which part you are asking about)
23:38:34 <glguy_> There are likely multiple interesting functions MyType->String
23:38:35 <julianleviston> RedNifre: oh just ignore me. I‚Äôll leave this here: Isomorphism a b : This lets you place an isomorphism inside a container without using ImpredicativeTypes https://hackage.haskell.org/package/lens-2.6/docs/Control-Lens-Isomorphic.html
23:39:16 <shachaf> Don't read lens 2.6 documentation.
23:39:46 <glguy_> Those who don't learn from history are doomed to repeat it, shachaf
23:39:48 <julianleviston> <cough> sorry https://hackage.haskell.org/package/lens-3.4/docs/Control-Lens-Isomorphic.html better?
23:39:59 <shachaf> No.
23:40:04 <julianleviston> damn :)
23:40:05 <glguy_> No, 4.13 is current
23:40:08 <shachaf> Isomorphic is the scow of classes.
23:40:08 <RedNifre> glguy_ good point, maybe... 
23:40:19 <julianleviston> lol 4.7 guh.
23:41:14 <julianleviston> shachaf: what‚Äôs a scow?
23:41:19 <RedNifre> ...though I think that Read and Show are maybe what you would expect if you saw Convertible Something String (i.e. something that has the same characteristics as Show...)
23:41:38 <shachaf> A bad thing.
23:41:44 <shachaf> I came up with a much better way of doing things.
23:41:53 <RedNifre> What would be bad about MonadTransformer IO Maybe instead of MaybeT?
23:42:10 <julianleviston> RedNifre: that‚Äôs a lot of typing!
23:42:51 <RedNifre> type MaybeT = MonadTransformer A Maybe -- (if that is valid haskell)
23:43:36 <Hijiri> it is if A is an existing thing
23:44:27 <RedNifre> ...but if it isn't? The goal was that I could type MaybeT IO and it would look for an instance of MonadTransformer IO Maybe...
23:44:55 <RedNifre> I guess I meant type MaybeT A = MonadTransformer A Maybe
23:45:06 <Hijiri> what is the point when MaybeT is a monad transformer for any monad?
23:46:21 <RedNifre> Having T x y, T a b, T u v seems more elegant to me than having xT y, aT b, uT v...
23:46:35 <julianleviston> I think it‚Äôs just about the mental organisation of it
23:46:43 <RedNifre> I agree.
23:46:58 <RedNifre> So I might be asking if my mental organization makes sense? :)
23:47:19 <julianleviston> RedNifre: lol sorry - that‚Äôs my vernacular. :)
23:48:05 <Hijiri> what are the members of MonadTransformer
23:48:22 <Hijiri> I copy of bind and return?
23:48:22 <Hijiri> A copy*
23:48:25 <RedNifre> I mean, in my case I had classes FromDBRow Bla and ToDBRow Bla, but I changed it to Convertible Bla [SQLValue] and Convertible [SQLValue] Bla because it felt more organized to me...
23:48:53 <RedNifre> Hijiri I guess so, yeah. I mean a monad transformer behaves like a regular monad, right?
23:48:53 <julianleviston> RedNifre: that feels‚Ä¶ broken
23:48:59 <RedNifre> does it?
23:49:03 <Hijiri> when applied to a monad yes
23:49:05 <julianleviston> RedNifre: haha only to me.
23:49:08 <RedNifre> Interesting, tell me more. SEe, I'm a total beginner here.
23:49:15 <julianleviston> RedNifre: I‚Äôm more of a beginner.
23:49:34 <Hijiri> you wouldn't be able to use those bind and return with do notation though (without some language extensions)
23:49:49 <RedNifre> why not?
23:49:58 <RedNifre> I thought do notation works with all monads?
23:50:02 <Saizan> type MaybeT A = MonadTransformer A Maybe <- isn't this confusing types with typeclasses?
23:50:13 <Saizan> RedNifre: it works with the Monad class
23:50:13 <RedNifre> maybe?
23:50:16 <Hijiri> do notation uses Control.Monad.>>= and Control.Monad.return
23:51:00 <Saizan> RedNifre: anyhow, in general if you have a monad M it is not automatic to make the transformer version
23:51:01 <Hijiri> I assumed RedNifre was remaking MaybeT into a contstraint or something
23:51:05 <Hijiri> even though it's not currently
23:51:21 <RedNifre> Saizan right, I fully understand that.
23:51:29 <Saizan> RedNifre: that's why we have the specific FooT versions
23:51:53 <RedNifre> Would it be impossible to create a T Foo A then?
23:52:19 <Saizan> RedNifre: i guess you could do it with a type family and specific instances for each Foo
23:52:22 <Hijiri> T is MonadTransformer?
23:52:29 <julianleviston> RedNifre: it might be possible that if you described what you‚Äôre attempting to use these for in a broader way, there might be a more elegant way to do it...
23:52:39 <Saizan> RedNifre: it would be a type, not a typeclass
23:54:37 <RedNifre> Isn't MaybeT a type constructor and MaybeT IO is a type? Why couldn't you have a type constructor MonadTransformer Maybe which can give you a type MonadTransformer Maybe IO? (I'm using MonadTransformer and T interchangeably here)
23:55:31 <pacak> RedNifre: They are both type constructors
23:55:41 <pacak> RedNifre: :t Maybe
23:55:48 <pacak> :t Maybe
23:55:49 <lambdabot>     Not in scope: data constructor ‚ÄòMaybe‚Äô
23:55:49 <lambdabot>     Perhaps you meant variable ‚Äòmaybe‚Äô (imported from Data.Maybe)
23:55:50 <arahael> Man, the sieve of erath...  Is slow.
23:55:59 <pacak> :k Maybe
23:56:00 <julianleviston> :t Maybe Int
23:56:01 <lambdabot> * -> *
23:56:01 <lambdabot>     Not in scope: data constructor ‚ÄòMaybe‚Äô
23:56:01 <lambdabot>     Perhaps you meant variable ‚Äòmaybe‚Äô (imported from Data.Maybe)
23:56:01 <lambdabot>     Not in scope: data constructor ‚ÄòInt‚Äô
23:56:05 <pacak> :k Maybe Int
23:56:06 <lambdabot> *
23:56:22 <pacak> RedNifre: Maybe Int is a type.
23:56:49 <Hijiri> RedNifre: I thought you were saying that MonadTransformer should be a typeclass
23:56:54 <Hijiri> since you were talking about instances of it
23:57:00 <RedNifre> What I mean is: MaybeT and ListT look like two totally separate concepts, we only can tell from the convention "Monad name followed by the letter T" that they are the same concept... if it were "MonadTransformer Maybe" and "MonadTransformer List" it would be specified in the type that they are implement the same concept...
23:57:16 <Hijiri> RedNifre: there might already be what you are looking for
23:57:19 <Hijiri> have you looked at Compose
23:57:20 <RedNifre> Similar to how "Read" and "Show" look unrelated in the type system yet they are meant as a pair.
23:57:36 <Hijiri> it's not used for monad transformers but it is basically what you are describing data-wise
23:57:38 <RedNifre> no, I'll do that right now...
23:57:49 <RedNifre> (@ Compose)
23:58:04 <Hijiri> https://hackage.haskell.org/package/transformers-0.4.3.0/docs/Data-Functor-Compose.html#v:Compose
23:58:46 <Hijiri> Compose f is a "functor transformer" for any functor f, and is also an "applicative transformer" if f is an applicative
23:59:23 <RedNifre> okay, but why only for functor and applicative, not monads?
