00:00:05 <julianleviston> ReinH: I think he’s off reading them now :) 
00:01:57 <nitrix> Correct. It's a long blog post.
00:02:10 <ReinH> Seems good.
00:02:13 <xpilot> is there a way to use TemplateHaskell to reduce some of the verbosity of writing "deriving instance ..." for a bunch of types?
00:02:44 <ReinH> xpilot: probaby, but I'm not sure it woud be worth it
00:03:24 <xpilot> in particular, there are a lot of different instances for each type
00:03:41 <xpilot> I guess I can just write a script to generate the code myself...?
00:03:46 <xpilot> that seems ugly though
00:03:56 <lamefun> Are there fallible map and fold, i.e. fallibleMap :: (a -> Either e x) -> [a] -> Either e [x]?
00:04:17 <julianleviston> lambdabot: fmap no good?
00:04:35 <julianleviston> lamefun:  <cough> sorry - fmap / Functor no good?
00:04:45 <xpilot> lamefun: you could try mapM
00:04:48 <ReinH> :t traverse
00:04:50 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
00:04:50 <xpilot> :t mapM
00:04:52 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
00:05:21 <ReinH> traverse is mapM with a more general constraint and either sound like what you want
00:05:32 <julianleviston> lamefun:  sorry I didn’t read your question well enough.
00:05:44 <quicksilver> mapM/traverse is lamefun's fallible map, yes
00:05:57 <quicksilver> there are fallible folds too
00:06:14 <quicksilver> :t foldM
00:06:16 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
00:06:37 <ReinH> > traverse (const (Left "woops")) [1,2]
00:06:38 <lambdabot>  Left "woops"
00:07:38 * hackagebot streaming-bytestring 0.1.1.0 - effectful byte steams, or: bytestring io done right.  https://hackage.haskell.org/package/streaming-bytestring-0.1.1.0 (MichaelThompson)
00:07:38 * hackagebot streaming-utils 0.1.1.0 - http, attoparsec and pipes utilities for streaming and streaming-bytestring  https://hackage.haskell.org/package/streaming-utils-0.1.1.0 (MichaelThompson)
00:20:58 <quicksilver> xpilot: this question suggests that TH can't see or produce "deriving" declarations : http://stackoverflow.com/questions/14316656/standalone-deriving-declaration-in-template-haskell-quotation
00:22:22 <xpilot> quicksilver: wow, that is unfortunate! thanks for the tip
00:24:38 <xpilot> quicksilver: https://ghc.haskell.org/trac/ghc/ticket/8100 seems to indicate this has been fixed
00:26:45 <xpilot> this package looks promising: https://hackage.haskell.org/package/standalone-derive-topdown
00:27:37 <quicksilver> that does look promising xpilot, and good news
00:28:18 <xpilot> wow that package was literally uploaded yesterday! I had to do a cabal update first
00:28:56 <quicksilver> :)
00:28:59 <quicksilver> synchronicity!
00:44:33 <Phyx-> @src CInt
00:44:33 <lambdabot> Source not found. The more you drive -- the dumber you get.
00:44:37 <Phyx-> @Info CInt
00:44:37 <lambdabot> CInt
00:44:39 <Phyx-> lol
00:45:21 <quicksilver> Phyx-: what are you hoping to learn? it's a newtype wrapper around the underlying 'int' type used by C on the system
00:45:41 <arkeet> @hoogle CInt
00:45:43 <lambdabot> Foreign.C.Types data CInt
00:45:43 <lambdabot> Foreign.C.Types data CIntMax
00:45:43 <lambdabot> Foreign.C.Types data CIntPtr
00:45:49 <Phyx-> quicksilver: I was hoping to learn the module it's in :) but hoogle was faster
00:45:55 <Phyx-> oh, didn't know of @hoogle :P
00:45:56 <quicksilver> hayoo is a hayoo is a good way for such things
00:45:56 <quicksilver> http://hayoo.fh-wedel.de/?query=CInt
00:46:15 <arkeet> anyway, @src lies a lot and @info doesn't exist (it auto-corrects to @undo)
00:46:28 <liste> why @undo :D
00:46:34 <arkeet> because that's the closest thing.
00:46:40 <liste> edit distance?
00:47:08 <arkeet> I suspect so
00:47:13 <julianleviston> liste: perceived effort
00:47:39 <julianleviston> liste: ignore me :)
00:48:38 <liste> is CInt always 32-bit?
00:48:59 <arkeet> look at its source.
00:49:26 <quicksilver> it is the underlying 'int' type used by C on the system
00:49:53 <quicksilver> which to be honest is 32 bit in every situation which springs to mind
00:50:05 <quicksilver> but maybe one day GHC will be compiled to a platform where it isn't.
00:51:49 <liste> I was just confused about the CInt Int32 in Haddocks, but seems it's the `int' of the Haddock build server
00:52:13 <liste> took a peek of the docs and there's some CPP magic
00:52:40 <quicksilver> I was surprised by that too
00:52:57 <quicksilver> but I think it is the effect of haddock running after CPP so it can see the result of the CPP expansion
00:53:19 <liste> took a peek of the source*
00:55:00 <lamefun> Should I use https://github.com/nikita-volkov/refined directly or use newtypes or copy refined directly into my project?
00:56:18 <lamefun> For subset types (eg. different naming conventions, file paths, etc).
00:57:43 <quicksilver> honestly if I was to guess I'd say it was overkill
00:57:54 <quicksilver> btu if you want to use it, I'd depend on the package.
00:58:44 <lamefun> refined was an overkill?
01:07:41 <quicksilver> lamefun: well, normally we managed to write programs correctly without type-level assertions beyond the kind the type system gives us for free
01:07:46 <quicksilver> but in some cases, maybe, it's great
01:23:23 <hc> moin
01:24:09 <hc> i've got a problem with HFlags... looks like the last flag I define isn't recognised... here's the test program i'm using. it causes a runtime error on line 20: http://lpaste.net/142347
01:24:20 <hc> the error i'm getting is "Burg-exe: Flag runAppServer not found at runtime, look into HFlags-source/examples/package/Tup.hs.  Sorry."
01:24:37 <hc> If I uncomment line 13, the program runs fine... And ideas what I'm doing wrong?
01:25:09 <jle`> what do you all think of my course description for the haskell course i'm proposing at my uni
01:25:13 <jle`> "Learn how type inference, expressive types, pure functional programming, and design patterns inspired by mathematics can help you with development speed, code maintainability, code safety, and concurrency parallelism in the context of a rapidly changing landscape of development.  See what Facebook, Twitter, and much of the finance sector are embracing as the key to the future; pick up an new language as
01:25:15 <jle`> well as skills and mindsets you can apply to your every day programming."
01:25:17 <jle`> too many buzz words?
01:30:53 <julianleviston> jle`: what’s your aim?
01:31:03 <julianleviston> jle`: “make all the people in the uni come” ?
01:31:03 <jle`> it's a seminar class
01:31:08 <jle`> well
01:31:21 <jle`> i want to impact lives
01:31:34 <jle`> maybe expose a lot of people to a new way of thinking that they wouldn't have otherwise considered
01:31:36 <julianleviston> that’s a little too general as an aim.
01:31:47 <julianleviston> jle`: ok
01:32:01 <julianleviston> jle`: if you want to do that, it might be good to trojan horse it.
01:32:14 <jle`> i'm listening :)
01:32:27 <julianleviston> jle`: to do that, work out what your audience are interested in, and start with that (start with them), and connect it back
01:32:27 <Hafydd> This talk will be about C++ -- if by C++ you mean Haskell.
01:32:56 <julianleviston> jle`: in other words… if I’m teaching multiplication to a 7 year old, then I talk about boxes of lollies.
01:32:58 <lamefun> quicksilver, what type level assertions does type system give for free?
01:33:04 <julianleviston> jle`: I don’t mention group theory :)
01:33:13 <quicksilver> lamefun: that the only value an Int can hold is an Int.
01:33:14 <jle`> what's group theory...working in groups?
01:33:20 <jle`> :D
01:33:22 <quicksilver> lamefun: and the only value a [Bool] can hold is a list of Bools.
01:33:23 <quicksilver> etc.
01:33:47 <jle`> i tried to list things that people might be interested in...development speed, code maintainability, code safetly, and concurrency/parallelism
01:34:09 <jle`> oh, forgot to add performance
01:34:14 <julianleviston> jle`: this is how you start: Learn how type inference, expressive types, pure functional programming, and design patterns
01:34:26 <jle`> true
01:34:47 <jle`> i will put my resume writing skills to practice
01:35:13 <julianleviston> jle`: have you seen Evan’s talk… “Let’s be mainstream” about adopion of Elm? https://www.youtube.com/watch?v=oYk8CKH7OhE
01:35:20 <jle`> i haven't :)
01:35:31 <julianleviston> jle`: he makes some interesting points… like calling Monads callbacks so that javascript people can understand them.
01:35:36 <jle`> i'll look at it
01:35:50 <jle`> i didn't know that was how he pronounced his name
01:35:54 <julianleviston> jle`: upset a lot of FP people, I’m sure :) but it’s not *FOR* them, so it doesn’t matter.
01:36:03 <Hafydd> @_@
01:37:22 <chrzyki> I think I'm having a not-able-to-think-functionally-morning: Is there a straightforward way of calling a function that returns some IO (e.g. IO Int) a set amount of times?
01:37:24 <julianleviston> jle`: I’d actually advocate a level beyond where he takes it… making things accessible by showing exactly how the tool we have provides precisely what has frustrated them in the past… this is, essentailly, what comedians do. They take some thing, and make it clear by putting it into a context that the audience can associate with.
01:37:35 <quicksilver> chrzyki: replicateM
01:37:46 <quicksilver> :t replicateM 5 getLine
01:37:47 <lambdabot> IO [String]
01:37:52 <chrzyki> quicksilver: Whoopsy and thank you!
01:37:59 <quicksilver> returns a list of whatever the return type was of the thing
01:38:17 <quicksilver> @hoogle Int -> IO a -> IO [a]
01:38:18 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
01:38:18 <lambdabot> Prelude replicate :: Int -> a -> [a]
01:38:18 <lambdabot> Data.List replicate :: Int -> a -> [a]
01:38:26 <quicksilver> yay for hoogle :)
01:38:41 <chrzyki> quicksilver: Awesome! Thanks a bunch. :)
01:42:02 <lamefun> quicksilver, what there was only one built-in type (eg. Value) that could hold ints, floats, doubles, lists, booleans, etc.? What would the type system give for free in that case?
01:43:35 <suppi> julianleviston, I don't think it makes sense to call monads callbacks, but you can definitely not call callbacks monads
01:44:09 <quicksilver> lamefun: I don't understand the purpose of your question.
01:44:23 <quicksilver> lamefun: the type system would give very little in that case.
01:44:35 <suppi> julianleviston, and I agree with what you said, I actually started gathering things that people got annoyed with at work and how you can solve them with fp :)
01:48:15 <lamefun> quicksilver, I don't understand it either. What do you mean by "for free"? Are there languages in which you have to buy a paid subscription to be able to segregate values into types?
01:49:43 <lamefun> Why would it give very little? Couldn't I simply make separate Int, Bool, etc. types myself, based on the Value type?
01:51:08 <echo-area> How does `f *** g = first f >>> second g` type check?
01:51:33 <jle`> echo-area: what part confuses you?
01:51:56 <jle`> btw, this is first from Control.Arrow, not first from Data.Bifunctor
01:52:41 <echo-area> jle`: I got first f :: a (b,d) (c,d), second g :: a (d',b') (d',c'), and (>>>) :: Category cat => cat a b -> cat b c -> cat a c
01:53:06 <merijn> No
01:53:15 <merijn> Pretty sure that's >>> from Arrow
01:53:32 <merijn> Oh, they generalised it, nevermind
01:53:44 <arkeet> merijn: Arrow's >>> is Category's >>>
01:53:54 <merijn> arkeet: I think it wasn't in the past
01:54:04 <merijn> But I see Category is a superclass of Arrow now?
01:54:04 <arkeet> it has been as long as I can remember.
01:54:12 <arkeet> that has been too.
01:54:13 <jle`> echo-area: so in that case, f :: a b c, g :: a b' c'
01:54:14 <merijn> ok, I might be confused :)
01:54:15 <jle`> so what is f *** g ?
01:55:08 <echo-area> jle`: I was referring to Arrow.hs, so `f *** g` was `a (b,b') (c,c')`
01:55:20 <jle`> mhm
01:55:55 <jle`> so, look at the type of (>>>)
01:56:08 <echo-area> https://github.com/ghc/ghc/blob/master/libraries/base/Control/Arrow.hs#L113
01:56:17 <jle`> it says that the second parmeter of the type in f has to be the same as the first parameter of the type in g
01:56:35 <jle`> er, the second in the type of first f, and the first in the type of second g
01:56:42 <jle`> in this case it's saying that (c, d) ~ (d', b')
01:56:53 <echo-area> Oh, let me see
01:57:00 <jle`> so c ~ d', and d ~ b'
02:24:18 <echo-area> jle`: I wrote a test program and understood.  Thank you.
02:28:09 <echo-area> Yet an unresolved question to me is when to use ~ explicitly.  I have to come back for this later
02:29:28 <merijn> echo-area: You never need explicit ~ unless you're doing type level hackery :)
02:29:35 <sopvop> which binary package is now recommended binary or cereal?
02:29:40 <merijn> sopvop: binary
02:29:47 <sopvop> ok
02:30:01 <merijn> sopvop: Since it does both strict & lazy input and lazy construction vs cereal that only does strict input + strict construction
02:30:30 <merijn> And someone told me constructing lazy and converting to strict is cheap, but I forgot why
02:30:58 <sopvop> because it needs allocs probably. you know the length.
02:31:02 <sopvop> needs less
02:32:02 <echo-area> merijn: I had to use it once when using Yesod, e.g. in `(MonadHandler m, HandlerSite m ~ App) => ...` but that's for type constraints.
02:37:48 <merijn> echo-area: To be fair, I would say that a bunch of Yesod's stuff constitute "type level hackery" :p
02:39:16 <echo-area> I see.  It has become a source of motivation :)
02:39:45 <merijn> echo-area: TypeFamilies and GADTs are fun things to look into :)
02:40:15 <merijn> The GADT wikibook is a good intro and for TypeFamilies I recommend the "Fun with Type Functions" paper
02:40:50 <echo-area> Thank you, I will read them
03:17:09 <vev_> #libreidea is a collection of research questions and ideas - we re looking for people who have spare time to help us on our project / Je cherche des gens qui ont du temps pour m'aider sur notre projet
03:21:59 <concept3d> I want to use forkIO with execState
03:40:43 <Gurkenglas> concept3d, combine https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html#v:forkMapM with https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Exception.html#v:evaluate ?
03:41:44 <Gurkenglas> Oh wait, for some reason I thought you wanted multiple forks. Just forkIO with the second one, then?
03:47:56 <Twey> What's a nice XMPP client library?
03:59:22 <vev_> if haskell dev want to help an innovative project please join #libreidea
03:59:35 <vev_> we already have one haskell german dev
03:59:53 <vev_> and we need more help
04:01:22 <zomg> this sounds like "we want someone to code things for us for free"
04:01:48 <zomg> what is thie project about? That would be a good thing to mention when asking for contributors
04:02:33 <keko_> ...and they left already
04:04:03 <zomg> did they leave before or after what I said? I have joins/parts/etc. in ignore but I have a plugin that should show parts when they spoke recently, but not seeing it
04:04:16 <zomg> Need to check the settings if they left before I spoke :P
04:04:56 <cocreature> he left before you spoke :)
04:05:39 <keko_> weechat + smartfilter, hides joins and quits except from people who spoke recently :)
04:06:33 <keko_> (the join message pops up retroactively if someone new joins and then says something)
04:07:14 <zomg> cocreature: ok then definitely need to check that...
04:07:16 <zomg> thanks
04:07:39 * hackagebot polar-configfile 0.4.0.0 - Fork of ConfigFile for Polar Game Engine  https://hackage.haskell.org/package/polar-configfile-0.4.0.0 (Shockk)
04:07:54 <zomg> keko_: yeah I have an irssi script based on smartfilter :)
04:18:43 <MarcelineVQ> Typeclassopedia tasks me to `Implement Functor instances for Either e and ((->) e).` but I get `instance Functor ((->) r) -- Defined in ‘GHC.Base’` error if I try. I already have NoImplicitPrelude turned on to implement Either, but how do I make it let me remake ((->) e)
04:20:52 <liste> MarcelineVQ if you can't find any other way, you could always "newtype Func a b = Func (a -> b)"
04:23:03 <lpaste> tesrty pasted “abc-noOfSolutions” at http://lpaste.net/272207429423333376
04:23:57 <tesrty> So I wrote a simple function returning how many solutions there are to your abc function.
04:24:36 <tesrty> It lets you enter your a, b and c and then tells you if the determinant was smaller, larger or equal to zero.
04:25:17 <tesrty> So my linter tells me the function is non-exhaustive because _ _ _ is handled. I get the feeling either I'm missing something important about functions or the linter is just wrong.
04:25:24 <tesrty> *is NOT handled.
04:25:47 <tesrty> Doesn't that code handle all possible three integer inputs?
04:26:47 <tesrty> aaaah! I know. It's because I'm using guards without a catch all right?
04:27:11 <Shockk> if you change `d > 0' to `otherwise', I'd imagine it should work
04:27:36 <liste> tesrty that happens to be exhaustive for Integers, but not for floating values
04:27:40 * hackagebot haskell-import-graph 1.0.0 - create haskell import graph for graphviz  https://hackage.haskell.org/package/haskell-import-graph-1.0.0 (ncaq)
04:27:42 <MarcelineVQ> liste: thank you I'll try working with that, just trying to figure out how that fits compared to (->) e
04:27:45 <liste> > (0/0) == (0/0)
04:27:47 <lambdabot>  False
04:27:55 <Shockk> I don't know that the compiler has enough information to know that < and == and > cover all values of Integer
04:30:29 <Shockk> if it could, that would be interesting and nice though, to know whether your guards are total or not
04:32:18 <tesrty> Ah okay. I see. Thanks for the info people.
04:33:45 <Ferdirand> tesrty: you could shut it up by using case compare d 0 of LT -> ...; EQ -> ...; GT -> ... 
04:34:08 <mreh> I'm just using Shelly, and it seems to depend on deprecated system-fileio
04:34:34 <mreh> does anyone know why it was deprecated?
04:34:53 <mreh> I just want some Haskell scripting library that I can run cross platform
04:35:31 <mreh> I just want something nice for running shell commands and reading the output
04:35:44 <fizruk> mreh: turtle
04:36:01 <fizruk> @hackage turtle
04:36:01 <lambdabot> http://hackage.haskell.org/package/turtle
04:36:01 <mreh> fizruk, yeah I had a look, but it wouldn't compile on GHC 7.4
04:36:05 <mreh> time to upgrade...
04:37:06 <fizruk> mreh: you might also want to try stack then
04:37:49 <MarcelineVQ> oh wow I did it, thank you liste
04:39:11 <merijn> @hoogle a -> Void
04:39:13 <lambdabot> Warning: Unknown type Void
04:39:13 <lambdabot> Prelude id :: a -> a
04:39:13 <lambdabot> Data.Function id :: a -> a
04:39:17 <jellie> hmmm deciding on how to set up directories and files in the tests dir isn't easy.
04:40:04 <fizruk> merijn: that can only be bottom, right?
04:40:14 <merijn> oh, wait
04:40:21 <fizruk> :t absurd
04:40:22 <lambdabot> Not in scope: ‘absurd’
04:40:26 <merijn> @hoogle f a -> f Void
04:40:27 <lambdabot> Warning: Unknown type Void
04:40:27 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
04:40:27 <lambdabot> Control.Exception.Base block :: IO a -> IO a
04:44:14 <jgx> Hello
04:44:32 <jgx> I'm a beginner with Haskell, and I try to install haskell-ide plugin for Atom
04:44:39 <jgx> I need to install ghc-mod, I'm using stack
04:44:55 <jgx> But when I do "stack install ghc-mod" in my project folder, it fails with this error
04:45:00 <jgx> <command line>: can't load .so/.DLL for: libtinfo.so (libtinfo.so: cannot open shared object file: No such file or directory)
04:45:15 <jgx> I have the libtinfo.so installed on my system (ubuntu)
04:45:29 <jgx> maybe "stack install ghc-mod" isn't the right command to install ghc-mod ?
04:47:17 <MarcelineVQ> try: cabal install ghc-mod
04:47:22 <MarcelineVQ> and see if it can manage it
04:47:42 <jgx> MarcelineVQ: Is it a good idea to mix stack + cabal commands ?
04:47:42 <MarcelineVQ> Gurkenglas was having issue with stack and ghc-mod earlier as well iirc
04:48:04 <MarcelineVQ> Probably not, since it'd be a global install, but working is better than not-working
04:48:04 <jgx> I try :)
04:48:13 <julianleviston> If you do it in the project folder, it might not put it into your home directory, which is probably where it will need to go.
04:48:42 <jgx> MarcelineVQ: I'm not sure because it forces me to install cabal
04:48:48 <jgx> julianleviston: I'll try in my home
04:48:51 <MarcelineVQ> julianleviston: yep, jgx's problem is that it wasn't building at all though
04:49:00 <julianleviston> ah sorry
04:52:29 <MarcelineVQ> ah, hmm, there might be a bug currently
04:52:51 <MarcelineVQ> because I just tried to install ghc to a sandbox with stack and it failed with your error
04:53:25 <jgx> hum
04:53:32 <MarcelineVQ> Stack's gfc version was a point newer than mine, so it might be an update broke something
04:53:34 <MarcelineVQ> *ghc
04:53:39 <jgx> I tried to manually create the symbolic link for libtinfo.so and it worked ! :D
04:53:43 <MarcelineVQ> Right on!
04:54:01 <jgx> Thanks MarcelineVQ for your help
04:54:18 <jgx> This is still "in progress", but so far it didn't stop on my previous error
04:55:04 <jgx> I'll open an issue on stack to report this
04:55:19 <MarcelineVQ> If if fails and you can't get it working and you're on linux I'll send you my copy of ghc-mod, no gurantee it'll work with your libs though, I don't know much about dynamic links
05:09:29 <julianleviston> what does “build” do?
05:09:45 <julianleviston> like… here: http://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.OldList.html#unfoldr
05:10:01 <MarcelineVQ> click on it :>
05:10:07 <quicksilver> it is a generic function for making lists with a specific property
05:10:15 <julianleviston> guh haha ok :) thanks
05:10:18 <quicksilver> that it optimises well via a specific optimisation GHC has hard coded
05:10:28 <quicksilver> called build fusion.
05:10:39 <julianleviston> ah
05:11:43 <julianleviston> so in that foldr case, I can read `c` as (:) then...
05:12:18 <julianleviston> and n as [] ?
05:12:20 <quicksilver> it abstracts the common pattern of building a list recursively
05:12:22 <quicksilver> yes exactly
05:12:25 <julianleviston> sweet.
05:12:27 <julianleviston> thanks!
05:12:31 <quicksilver> so that if you pass (:) and [] you jsut get a list out the end
05:12:38 <quicksilver> but if you pass other functions you get a fold, basically
05:12:46 <julianleviston> MarcelineVQ:  and thanks for the click tip. I knew that once lol.
05:12:51 <quicksilver> and it takes that form so GHC can combine them all and avoid creating intermediate lists
05:13:08 <quicksilver> but it's not the *only* kind of optimisation that can do that trick.
05:13:29 <julianleviston> quicksilver: oh?
05:13:33 <quicksilver> stream fusion is a different one
05:13:45 <MarcelineVQ> Is that the dlist trick or is that different as well?
05:14:13 <julianleviston> is that what ~(h, t) = h : t in lines is?
05:14:28 <quicksilver> the dlist trick is also different
05:14:29 <julianleviston> actually what *is* ~(h,t) ? I’ve never seen ~ before.
05:14:35 <MarcelineVQ> ~ is a lazy pattern match iirc
05:14:37 <quicksilver> that's just about re-associating things you want tobe right associative
05:14:55 <quicksilver> it's irrefutable, yes
05:14:58 <julianleviston> I think I’ll ignore that for now.
05:15:03 <quicksilver> it helps avoiding making something too strict
05:23:50 <fizruk> Data.Functor.Contravariant.Generic is nice, but I can't use it for something like Show/Read, right?
05:32:06 <Guest33874> hello i have a exercise to do and i have no clue where to start somebody can help me 
05:32:19 <Guest33874> http://lpaste.net/142352
05:32:21 <julianleviston> Guest33874: sure what’s the prob
05:33:16 <MarcelineVQ> looks like a euler problem :>
05:33:30 <tdammers> yup
05:33:40 <tdammers> "if in doubt, use brute force"
05:33:50 <julianleviston> lol
05:34:05 <julianleviston> Guest33874: do you know divide and conquer?
05:34:16 <Guest33874> i know that i have to divide the number and see if the sum of all numbers has to be equal of the number
05:34:25 <julianleviston> Guest33874: where you break the problem into smaller pieces that you *can* solve?
05:34:50 <julianleviston> Guest33874: one way to do this is to consider a very small case of the problem. Usually we can easily start with that.
05:35:26 <Guest33874> first i have to [1..n] and divide that list of numbers
05:35:38 <julianleviston> Guest33874: are you listening?
05:35:41 <Guest33874> yes
05:35:54 <julianleviston> Guest33874: ok so what’s the smallest case?
05:36:03 <Guest33874> 1
05:36:04 <julianleviston> Guest33874: one you can just tell me off the top of your head
05:36:11 <julianleviston> Guest33874: what’s the answer to it?
05:36:13 <jgx> MarcelineVQ: It worked :)
05:36:28 <Guest33874> it is the number itself
05:36:30 <jgx> Now I need to figure out how to tell atom where my ghc-mod is :p
05:36:47 <julianleviston> Guest33874: ok… so put that in as your first case
05:37:02 <julianleviston> Guest33874: as in… fascinating 1 = [1]
05:37:18 <julianleviston> Guest33874: now consider the next one…
05:37:21 <MarcelineVQ> jgx: add ghc-mod's location to your path
05:37:37 <julianleviston> Guest33874: after about the fifth one, you might see a pattern.
05:37:40 <Guest33874> 2 = 2 1 
05:37:44 <Guest33874> 3= 3 1 
05:38:01 <tdammers> fascinating 3 = [3 2 1]
05:38:01 <MarcelineVQ> jgx: I added mine to my bashrc and I open atom from the terminal
05:38:12 <julianleviston> Guest33874: I d’nt really follow...
05:38:42 <Guest33874> but only has to be the sum of divisors pairs
05:38:47 <julianleviston> Guest33874: what is this function trying to do?
05:39:07 <Guest33874> the sum of all divisors pairs was to be the number 
05:39:14 <julianleviston> Guest33874: by the definition of the problem, it will only write fascinating numbers less than it, right?
05:39:47 <julianleviston> so 2 = [(fascinating 2), (fascinating 1)] doesn’t it?
05:40:05 <julianleviston> hm… that won’t make sense though, because you’ll end up recursing to inifinty.
05:40:07 <Guest33874> ffor example 12 is fasciniting because = 4+6+2 equals 12
05:40:09 <julianleviston> how will we solve this?
05:40:34 <julianleviston> Guest33874: I don’t follow that.
05:40:41 <julianleviston> Guest33874: what is a “splitter” ?
05:40:59 <Guest33874> i google from google tradutor :p
05:41:21 <julianleviston> traductor? tu es francais?
05:41:27 <Guest33874> portuguese
05:41:29 <julianleviston> ahhh ok
05:41:35 <MarcelineVQ> 2, 4, 8, 16 , 31, 32, 62, 124, 248, 496 multiplying pairs while moving inwards the result is always 992
05:41:54 <MarcelineVQ> nvm
05:41:57 <MarcelineVQ> I'm an idiot lol
05:42:28 <Guest33874> i will translate than i send again 
05:42:31 <MarcelineVQ> no wait, maybe not
05:42:35 <jgx> MarcelineVQ: I've put the direct path in the plugin preferences, /home/myUser/.local/bin/ghc-mod, now everything works :D
05:42:35 <julianleviston> I’m guessing divider = divisor (as in … “a number which divides evenly into another number”
05:43:10 <julianleviston> Guest33874: so you’ll need to a) write a function that finds a number’s even divisors. and b) write a function that works out if they’re “fascinating”. 
05:43:39 <jgx> MarcelineVQ: Cool; now I have "ghc not found" lol
05:43:50 <jgx> Pretty close :p
05:44:34 <jgx> MarcelineVQ: I did only a "stack new", maybe I need to do "stack setup" as well ?
05:44:51 <julianleviston> Guest33874: where “fascinating” means that the number itself is equal to its even divisors.
05:45:12 <MarcelineVQ> maybe, I'm surprised it let you build ghc-mod without putting ghc in that same project though
05:45:21 <julianleviston> Guest33874: at THAT point, you’ll be able to write the fascinating function, which simply maps isFascinating across [1..n] for a number.
05:45:56 <MarcelineVQ> they're not neccesarily even numbers
05:46:14 <julianleviston> MarcelineVQ: even divisors, meaning non-fractional.
05:46:22 <julianleviston> MarcelineVQ: apologies for my inaccurate language, if it was.
05:49:09 <julianleviston> Guest33874: usually when solving a problem, you must first completely understand the problem. Then break it down into smaller problems, then solve the smallest one, then the next largest, and so on… until you have solved the complete problem. At least, that’s *one* method of problem solving that works very well. https://pt.wikipedia.org/wiki/Divisão_e_conquista
05:50:27 <julianleviston> Guest17004: does that help at all?
05:50:31 <julianleviston> ops
05:50:53 <orion> peek :: Ptr a -> IO a -- poke :: Ptr a -> a -> IO () -- peek s >>= poke s . (+) 1 -- What's going on with the ". (+) 1" here?
05:54:25 <liste> :t (+) 1
05:54:26 <aweinstock> orion: (peek s >>= poke s . (+) 1) = (peek s >>= (\x -> poke s (1 + x)))
05:54:26 <lambdabot> Num a => a -> a
05:54:39 <liste> > ((+) 1) 10
05:54:41 <lambdabot>  11
05:54:56 <liste> it's the same as (1+)
05:55:22 <aweinstock> orion: also equivalent: do { x <- peek s; poke s (1 + x) }
05:55:44 <julianleviston> is s the address?
05:56:01 <julianleviston> no idea which monad this is from.
05:56:04 <aweinstock> s :: Ptr a
05:56:11 <julianleviston> guh. me=idiot.
05:56:16 <aweinstock> it's in IO
05:57:09 <aweinstock> :t (Foreign.Storable.peek, Foreign.Storable.poke)
05:57:10 <lambdabot> (Foreign.Storable.Storable a, Foreign.Storable.Storable a1) => (GHC.Ptr.Ptr a -> IO a, GHC.Ptr.Ptr a1 -> a1 -> IO ())
05:57:18 <orion> That's so interesting. What two functions are being composed?
05:57:32 <orion> (+1) and... ?
05:57:39 <aweinstock> poke s
05:57:52 <orion> Oh, partial application of poke.
05:57:59 <liste> @unpl poke s . (+) 1
05:57:59 <lambdabot> (\ c -> poke s (1 + c))
05:58:24 <dramforever> julianleviston: (possibly FYI) that's widely known as divide and conquer in English
05:58:33 <orion> Very interesting. The precedence rules are still hazy in my mind.
05:58:48 <orion> Thank you aweinstock, liste.
05:58:52 <julianleviston> dramforever: yeah, I mentioned that at the beginning.
05:59:10 <julianleviston> dramforever: thanks :)
05:59:13 <dramforever> oh then it looks like you just accidentally posted a link in the wrong language...
05:59:23 <julianleviston> dramforever: no, that’s his native tongue.
05:59:31 <julianleviston> dramforever: portuguese.
05:59:32 <aweinstock> "function application has higher precedence than anything" is probably the most relevant rule here
05:59:41 <julianleviston> dramforever: sorry for the confusion!
05:59:59 <dramforever> uuh no you're welcome, and sorry for bothering...that's what I get for reading log backwards
06:00:00 <jgx> MarcelineVQ: I added both ghc and ghc-mod in my path (.bashrc), now I have another error...
06:00:04 <jgx> It never ends :(
06:00:10 <julianleviston> dramforever: hehe :) but backwards is the best way
06:00:22 <jgx> MarcelineVQ: launching operating system process `cabal configure` failed: cabal: readProcessWithExitCode: runInteractiveProcess: exec: does not exist (No such file or directory)
06:00:24 <julianleviston> jgx: as long as you’re getting different errors, you’re progressing ;-) lol
06:00:50 <jgx> This error is emitted by haskell-ghc-mod plugin when I open atom
06:00:52 <julianleviston> dramforever: I was trying to work out if it was an algorithmic version of proof by induction from math, but I just gave up.
06:01:26 <MarcelineVQ> Probably easier if you installed ghc and cabal globally, seems like atom prefers that
06:01:59 * julianleviston wonders idlely if atom has fixed its janky paren-matching algorithm yet
06:02:49 <dramforever> julianleviston: I would say that it indeed is. 1. your algorithm solves trivial problems 2. as long as your program solves strictly smaller problems, your program solves problems that can be split into those smaller problems 
06:02:53 <MarcelineVQ> oh I see how it works
06:03:22 * dramforever mutters something about well-ordering stuff
06:03:31 <MarcelineVQ> You all the pairs of factors that multiply to be equal to n, take the even ones, and if you sum them it must equal n
06:03:42 <MarcelineVQ> *of factors of n
06:04:02 <julianleviston> MarcelineVQ: how what works?
06:04:11 <dcoutts> jgx: looks like it's trying to execute "cabal configure" as a program name, when of course it needs to exec "cabal" with an arg of "configure".
06:04:22 <MarcelineVQ> guest33874's pastebin
06:04:38 <dcoutts> jgx: some configuration error perhaps?
06:05:23 <MarcelineVQ> julianleviston: something like ` filter (\n -> n == sum [x | x<-[1..(n`div`2)], y<-[1..(n`div`2)], x*y == n, even x]) [1..1000] ` but that's really slow
06:05:25 <orion> :t (+) 1 <$> peek p
06:05:27 <lambdabot> Not in scope: ‘peek’
06:05:35 <orion> :t (+) 1 <$> Foreign.Storablepeek p
06:05:35 <julianleviston> MarcelineVQ: why even?
06:05:38 <lambdabot>     Not in scope: data constructor ‘Foreign.Storablepeek’
06:05:42 <orion> bah
06:06:03 <julianleviston> MarcelineVQ: sorry - I thought it was just about all divisors
06:06:06 <MarcelineVQ> if you read the paste closely it says, it just isn't at all clear about it
06:06:22 <MarcelineVQ> the actual summing line only includes even factors
06:06:36 <MarcelineVQ> But the pair extraction includes all of them
06:06:54 <julianleviston> MarcelineVQ: are you sure they didn’t mean “even factors” as avers to “factors which are divisible by 2”?
06:06:58 <aweinstock> :t \p -> (+) 1 <$> Foreign.Storable.peek p
06:07:00 <lambdabot> (Num b, Foreign.Storable.Storable b) => GHC.Ptr.Ptr b -> IO b
06:07:11 <julianleviston> MarcelineVQ: I didn’t read it terribly closely - I was more interested in him working it out himself. 
06:07:35 <MarcelineVQ> I couldn't say, I can say that that comprehension I posted will give you the expected output
06:07:44 <julianleviston> MarcelineVQ: in the sense of even I meant, which is “non-fractional”? :)
06:07:56 <julianleviston> MarcelineVQ: ah ok. :) cool.
06:17:35 <askell> i want to start a list with n elements how i initializate ?
06:17:44 <askell> xs = [1..n]?
06:18:00 <julianleviston> askell: guess it depends what you want them to be.
06:18:13 <julianleviston> askell: xs = replicate 5 works, too.
06:18:26 <opqdonut> > replicate 5 True
06:18:27 <jgx> Ok I think my main problem with atom is that I need to use ghc-mod 5.4, and by default I have ghc-mod 5.2.1.2
06:18:28 <lambdabot>  [True,True,True,True,True]
06:18:41 <julianleviston> oops
06:18:54 <askell> but i want to [1..n]... the fuction then returns the list
06:19:00 <Cale> askell: The manner in which you're asking that question makes it sound like you intend to change the list later
06:19:09 <julianleviston> askell:  well use that. That works fine.
06:19:25 <askell> but it says "n" no scope
06:19:37 <julianleviston> askell: that’s because you haven’t defined n
06:19:43 <julianleviston> > [1..5]
06:19:45 <lambdabot>  [1,2,3,4,5]
06:19:51 <julianleviston> askell:  see?
06:20:11 <julianleviston> @set makeList n = [1..n]
06:20:13 <askell> yes but how can i give n a value when that fuction is called
06:20:25 <askell> ah ok thaks 
06:20:26 <askell> tks
06:20:32 <julianleviston> askell: like that, above. (tho I don’t know lambda bot’s syntax for setting things)
06:20:41 <julianleviston> askell: no problem! :)
06:21:04 <julianleviston> askell:  you could also say (\n -> [1..n]) if you wanted to use a lambda...
06:21:18 <julianleviston> (\n -> [1..n]) 3
06:21:20 <JX7P> the red flag of functional programming: https://github.com/jarcane/red-flag-of-fp
06:21:22 <julianleviston> guh
06:22:05 <julianleviston> JX7P: why is it a russian flag?
06:22:26 <fizruk> julianleviston: this is not a russian flag
06:22:29 <Cale> Looks a lot more like China's flag to me
06:22:44 <fizruk> it might look like USSR flag also
06:22:44 <julianleviston> s;rry… chinese
06:23:14 <julianleviston> it’s just the colours, and the placement of the logo, I guess… and the star…  :)
06:23:32 <julianleviston> either way, it reminds me of communism.
06:23:50 <fizruk> julianleviston: this is russian flag: https://en.wikipedia.org/wiki/Flag_of_Russia
06:24:00 <julianleviston> fizruk:  sorry I actually meant the USSR one.
06:24:13 <julianleviston> fizruk: you were right.
06:24:18 <fizruk> for the last 25 years almost
06:24:30 <askell> about that list i want to create (\n -> [1..n]) 
06:24:42 <askell> and then i want to divide each number of the list
06:24:51 <askell>  function that finds a number’s even divisors.
06:24:57 <julianleviston> askell: inside the function?
06:24:57 <fizruk> > map (`div` 2) [1..10]
06:24:58 <lambdabot>  [0,1,1,2,2,3,3,4,4,5]
06:25:10 <julianleviston> erm
06:25:17 <askell> yes 
06:25:17 <julianleviston> (`div` 2 == 0) ?
06:25:18 <Cale> I think the point is to look like one of these communist flags, however, it's not exactly humourous and it doesn't really make all that much sense either. I'm not sure what the idea is.
06:25:23 <concept3d_> hello guys, I want to fork a monad transformer (particularly StateT Map IO () )
06:25:26 <concept3d_> how can I do this
06:25:39 <quicksilver> fork in what sense, concept3d_ ?
06:25:44 <quicksilver> what are you trying to achieve?
06:25:45 <Cale> concept3d_: You want to fork the transformers package?
06:25:51 <quicksilver> two threads accessing the same state?
06:26:17 <julianleviston> concept3d: or fork the project?
06:26:31 <concept3d_> thread forking
06:26:42 <Cale> forkIO doesn't work with StateT
06:26:45 <Cale> only IO actions
06:26:51 <concept3d_> yes that is the question
06:26:52 <Cale> So you have to runStateT
06:26:58 <MarcelineVQ> > [x | x<-[1..20], 20`mod`x==0]
06:27:00 <lambdabot>  [1,2,4,5,10,20]
06:27:18 <tdammers> StateT is just sugar for passing extra arguments
06:27:19 <concept3d_> how can I make forkIO work with StateT Map IO ()
06:27:29 <MarcelineVQ> > filter even $ [x | x<-[1..20], 20`mod`x==0]
06:27:31 <lambdabot>  [2,4,10,20]
06:27:34 <Cale> concept3d_: You don't.
06:27:36 <fizruk> concept3d: why do you want to do that?
06:27:36 <quicksilver> concept3d_: probably you want to store the state in an MVar
06:27:47 <tdammers> if you want to share state between threads, use one of the concurrency primitives
06:27:49 <quicksilver> you will have to think about how you want concurrent access to proceed
06:27:53 <tdammers> MVars, TVars, that kind of thing
06:28:04 <quicksilver> but that might possibly involve runnign StateT IO actions in either thread
06:28:20 <askell> but i want that 20 to be n
06:28:20 <quicksilver> but those parts will be inhernetly synchronised by the MVar
06:28:41 <Cale> runStateT myAction initialMap :: IO ()
06:28:52 <Cale> forkIO (runStateT myAction initialMap) :: IO ThreadId
06:28:53 <concept3d_> I have a main loop, and another loop recvEvents, I want to fork recvEvents, it also carries State.
06:29:01 <fizruk> askell: so make it a function: f n = [x | x <- [1..n], n `mod` x == 0]
06:29:08 <Cale> concept3d_: ^^
06:29:39 <askell> so in that fuction i start that list then
06:29:40 <concept3d_> Cale : I didn't understand
06:29:45 <fizruk> concept3d: perhaps you should paste actual code
06:29:49 <Cale> :t runStateT
06:29:50 <lambdabot> StateT s m a -> s -> m (a, s)
06:29:52 <fizruk> @where paste
06:29:52 <lambdabot> Haskell pastebin: http://lpaste.net/
06:30:08 <concept3d_> Ok
06:30:13 <Cale> Oh, I guess I got the type a bit wrong
06:30:17 <quicksilver> concept3d_: you cant "just fork"
06:30:23 <quicksilver> concept3d_: you need to address the questions we are raising.
06:30:33 <quicksilver> you need to understand concurrency and choose how you want your program to work.
06:30:37 <quicksilver> MVars are probably part of the solution.
06:31:03 <julianleviston> concept3d_: I’m a big advocate of reading simon’s book on concurrency and parallelism...
06:31:13 <concept3d_> quicksilver : you are probably correct, I am still new to haskell and trying to figure things out,
06:31:16 <Cale> I would question whether you really want to use StateT over IO at all
06:31:27 <julianleviston> concept3d_: http://chimera.labs.oreilly.com/books/1230000000929
06:31:34 <Cale> It might make a whole lot more sense to only use IORef or MVar
06:31:44 <concept3d_> Cale: yes, one approach is to pass the state explicitly
06:31:47 <Cale> But I guess it depends
06:32:19 <concept3d_> I actually looked at the book but I don't have much time
06:32:31 <Cale> concept3d_: Often the right thing is to make a record consisting of various operations on the state (functions and actions built using an IORef or something), and pass that around instead
06:33:13 <MarcelineVQ> askell, ideally it'd look like this: evenFactors n = [x | x<- filter even [1..n], n`mod`x==0]
06:33:29 <concept3d_> Cale: so it could be having an explicite mutable state
06:34:07 <MarcelineVQ> askell: filtering the list for even numbers before using mod on them saves wasting checking the odd numbers which can't possibly be even
06:34:47 <Cale> MarcelineVQ: uhhh
06:35:37 <Cale> MarcelineVQ: Oh, I see, yes
06:35:39 <MarcelineVQ> odd factors aren't even factors :>
06:35:46 <Cale> You could also just use [1,3..n]
06:35:52 <MarcelineVQ> true dat
06:35:56 <Cale> so as to not do the evenness tests
06:36:21 <aweinstock> > (\n -> [1,3..n]) 2
06:36:23 <lambdabot>  [1]
06:36:24 <julianleviston> Cale: lol yeah, that code made my brain go ughhhhh for a few seconds for some reason. Possibly because I’m used to list compehensions with the predicate at the end
06:36:37 <MarcelineVQ> does that actually save anything though? 1,3 stills has to succ from 1 to 3 right? idk how enums work
06:37:01 <Cale> MarcelineVQ: Nah, it takes the difference between the two elements and adds that to form successive ones
06:37:09 <MarcelineVQ> neat
06:37:14 <aweinstock> :t enumFromToThen
06:37:16 <lambdabot>     Not in scope: ‘enumFromToThen’
06:37:16 <lambdabot>     Perhaps you meant one of these:
06:37:16 <lambdabot>       ‘enumFromThen’ (imported from Prelude),
06:37:17 <julianleviston> MarcelineVQ: enumfromToThen
06:37:18 <julianleviston> lol
06:37:34 <julianleviston> what? I thought it was called that too
06:37:35 <aweinstock> :t enumFromThenTo
06:37:36 <lambdabot> Enum a => a -> a -> a -> [a]
06:37:38 <julianleviston> ah
06:38:06 <julianleviston> MarcelineVQ: that’s what it ends up as.
06:38:20 <aweinstock> how would it "add the difference" with only an Enum constraint? or is the Num instance optimized/specialized somehow?
06:38:39 <aweinstock> :t (fromEnum, toEnum)
06:38:40 <lambdabot> (Enum a, Enum a1) => (a -> Int, Int -> a1)
06:38:51 <aweinstock> (answered my own question)
06:40:06 <julianleviston> aweinstock: that’s pretty cool.
06:42:03 <aweinstock> > let {eFTT a b c = f a [] where {f x acc | x < c = f (toEnum $ fromEnum x + fromEnum b - fromEnum a) a:acc; f _ acc = acc}} in eFTT 1 3 10
06:42:04 <lambdabot>      Occurs check: cannot construct the infinite type: a1 ~ [a1]
06:42:04 <lambdabot>      Relevant bindings include
06:42:04 <lambdabot>        acc :: [a1] (bound at <interactive>:1:37)
06:42:11 <MarcelineVQ> typeclassopedia asks, `Give an example of a type of kind * -> * which cannot be made an instance of Functor (without using undefined).` How would I even go about determining that? Can hoogle be searched for kinds?
06:42:49 <MarcelineVQ> I know what a * -> * tends to look like but I don't know how to determine if it needs any sort of undefined value
06:42:49 <aweinstock> MarcelineVQ: data ProxyVoid a
06:43:15 <aweinstock> (not sure that's correct, but that was my first thought)
06:44:36 <opqdonut> aweinstock: or more concretely: data Dual a = Dual (a -> Double)
06:44:55 <Jinxit> since what ghc version are you able to foldl over Data.Tree?
06:45:45 <aweinstock> > let {eFTT a b c = (f a id) [] where {f x acc | x < c = f (toEnum $ fromEnum x + fromEnum b - fromEnum a) (acc . (x:)); f _ acc = acc}} in eFTT 1 3 10
06:45:48 <lambdabot>  [1,3,5,7,9]
06:46:06 <aweinstock> is that a correct implementation of enumFromThenTo?
06:46:07 <julianleviston> Ha! who knew that cabal was actually an acronym for Common Architecture for Building Applications and Libraries
06:46:39 <MarcelineVQ> Not me, I imagined it was a group of desert wizards performing arcane sacrifices to keep things mostly working.
06:47:17 <julianleviston> MarcelineVQ: lol… I just thought it was a reference to some prophetic yiddish text… but that’s probably because Yesod is named what it is.
06:47:59 <aweinstock> > let {eFTT a b c = (f a id) [] where {f x acc | x < c = f (toEnum $ fromEnum x + fromEnum b - fromEnum a) (acc . (x:)); f _ acc = acc}} in eFTT 'A' 'C' 'Z'
06:48:00 <lambdabot>  "ACEGIKMOQSUWY"
06:48:15 <aweinstock> :t let {eFTT a b c = (f a id) [] where {f x acc | x < c = f (toEnum $ fromEnum x + fromEnum b - fromEnum a) (acc . (x:)); f _ acc = acc}} in eFTT
06:48:17 <lambdabot> (Enum a, Enum a1, Ord a1) => a1 -> a -> a1 -> [a1]
06:49:06 <quicksilver> Jinxit: ever since data.foldable I would have thought
06:49:36 <hexagoxel> aweinstock: fmap = absurd, no?
06:51:20 <hexagoxel> fmap = absurd . runProxyVoid, to be precise
06:52:09 <aweinstock> hexagoxel: what's the type for runProxyVoid?
06:52:23 <Jinxit> quicksilver: when was that? not sure where to look
06:52:39 <quicksilver> Jinxit: well it already existed in containers-0.1.0.0
06:52:45 <hexagoxel> aweinstock: ProxyVoid a -> Void
06:52:46 <opqdonut> aweinstock: ProxyVoid a -> Void
06:52:51 <quicksilver> Jinxit: which is the oldest version of containers - before that, containers was part of base
06:53:03 <quicksilver> Jinxit: I don't know any easy way to work backwarfs from containers/base versions to GHC versions
06:53:16 <quicksilver> Jinxit: except google searching, release announcments, comparing dates, etc
06:53:24 <Jinxit> ah okay, so fairly old?
06:53:38 <Jinxit> the system I'm running against won't recognize the fold
06:54:15 <quicksilver> are you sure you don't just not have the right modules in scope?
06:54:31 <Jinxit> is Data.Tree enough?
06:55:24 <hexagoxel> aweinstock: i assume that `data ProxyVoid a = ProxyVoid { runProxyVoid :: Void }`, but you can take your signature and use the trick in `absurd`s implementation directly.
06:55:54 <quicksilver> Jinxit: Data.Tree and Data.Foldable
06:55:55 <fizruk> is there a reason for Complex not having a Generic instance?
06:55:57 <quicksilver> to get the right fold
06:56:16 <quicksilver> fizruk: to preserve data abstraction probably?
06:56:32 <quicksilver> it's supposed to be an abstract type, if it exported its generic instance you could take it apat.
06:56:40 <Jinxit> ahhh
06:56:58 <fizruk> quicksilver: but it's not abstract now, is it?
06:57:21 <fizruk> quicksilver: data Complex a = !a :+ !a
06:57:35 <quicksilver> apparently not
06:57:37 <quicksilver> :/
06:57:38 <ski> > 2 :+ 3
06:57:39 <lambdabot>  2 :+ 3
06:57:46 <quicksilver> hysterical raisins, then.
06:58:10 <fizruk> quicksilver: Ratio is, so for Ratio it makes sense
06:58:23 <quicksilver> since the type is fully exposed, you can standalone deriving your own instances if you want
06:59:20 <isocliff> Could anyone give me an idea why my Travis build fails with "cabal: can't find source" when it builds fine for me locally? https://travis-ci.org/BlackBrane/ansigraph/builds/83693746 
06:59:25 <fizruk> quicksilver: aha, I was just curious if there was some other reason
07:01:01 <quicksilver> fizruk: well apparently it's coming in the next version
07:01:09 <quicksilver> I don't know where my memory of Data.Complex being abstract comes from
07:01:29 <quicksilver> since the constructor is exposed in the oldest base library I can find
07:01:48 <fizruk> quicksilver: makes sense, I should not rely on a Generic for Complex then
07:02:01 <quicksilver> fizruk: https://github.com/ghc/ghc/blob/master/libraries/base/changelog.md
07:02:12 <hexagoxel> isocliff: https://github.com/BlackBrane/ansigraph/blob/master/src/System/Console/AnsiGraph.hs#L20
07:02:24 <hexagoxel> look closely at the case in the module name
07:02:26 <fizruk> quicksilver: oh, so it gets fixed
07:02:43 <quicksilver> fizruk: (in the currently unreleased lirbary which will come with the next GHC)
07:03:36 <aweinstock> :t 'a' :+ 'b'
07:03:37 <lambdabot> Complex Char
07:03:44 <hexagoxel> isocliff: it probably works locally because case-insensitive-filesystem (?)
07:04:20 <fizruk> quicksilver: I wonder how Applicative and Monad for Complex might be useful :)
07:04:30 <isocliff> ahh, hexagoxel: do you mean the links in my Haddock comments there? I see they have the old capitalization..
07:04:58 <hexagoxel> isocliff: nah, i mean the file name vs the module name
07:05:00 <Jinxit> so I'm trying to fold over a tree, but I want to abort when I find a zero
07:05:04 <Jinxit> any hints?
07:05:11 <Jinxit> (Data.Tree that is)
07:05:22 <bartavelle> Jinxit, foldM with Either or Maybe
07:05:33 <isocliff> Oh yeah that must be it. Thanks a lot!
07:05:38 <Jinxit> would that actually stop the search?
07:05:42 <bartavelle> yes
07:05:44 <Jinxit> okay
07:05:48 <Jinxit> thanks
07:05:53 <bartavelle> np :)
07:05:53 <aweinstock> :t foldM (let f 0 = Nothing; f n = Just n)
07:05:54 <lambdabot>     parse error in let binding: missing required 'in'
07:05:58 <aweinstock> :t foldM (let f 0 = Nothing; f n = Just n in f)
07:05:59 <lambdabot>     Couldn't match type ‘Maybe a1’ with ‘a -> m a1’
07:05:59 <lambdabot>     Expected type: a1 -> a -> m a1
07:05:59 <lambdabot>       Actual type: a1 -> Maybe a1
07:06:34 <fizruk> :t foldr (\x acc -> if acc == 0 then "STOP" else x ++ acc)
07:06:35 <lambdabot>     Could not deduce (Num [Char]) arising from the literal ‘0’
07:06:35 <lambdabot>     from the context (Foldable t)
07:06:35 <lambdabot>       bound by the inferred type of
07:07:26 <aweinstock> :t foldM (let f _ 0 = Nothing; f _ n = Just n in f)
07:07:27 <lambdabot> (Eq t1, Num t1, Foldable t) => t1 -> t t1 -> Maybe t1
07:08:02 <dgpratt> in what circumstance(s) will a package be installed "in-place"? or to ask another way, how can I cause a package to be installed "in place"?
07:08:05 <aweinstock> > fmap getSum $ foldM (let f _ 0 = Nothing; f _ n = Just n in f) (Just 0) [1..10]
07:08:06 <lambdabot>      Couldn't match expected type ‘Sum b’
07:08:07 <lambdabot>                  with actual type ‘Maybe Integer’
07:08:07 <lambdabot>      In the second argument of ‘foldM’, namely ‘(Just 0)’
07:08:07 <fizruk> > foldr (\x acc -> if x == 0 then "" else show x ++ acc) "" [10, 9..]  -- Jinxit 
07:08:09 <lambdabot>  "10987654321"
07:08:18 <aweinstock> > fmap getSum $ foldM (let f _ 0 = Nothing; f _ n = Just n in f) (Just 0) (map Sum [1..10])
07:08:19 <lambdabot>      Couldn't match expected type ‘Sum b’
07:08:19 <lambdabot>                  with actual type ‘Maybe Integer’
07:08:19 <lambdabot>      In the second argument of ‘foldM’, namely ‘(Just 0)’
07:08:19 <julianleviston> dgpratt:  do you mean sandboxed?
07:08:33 <dgpratt> julianleviston, no, I don't think I do
07:08:33 <aweinstock> > fmap getSum $ foldM (let f _ 0 = Nothing; f _ n = Just n in f) (Just 0) (map (Just . Sum) [1..10])
07:08:35 <lambdabot>      Couldn't match expected type ‘Sum b’
07:08:35 <lambdabot>                  with actual type ‘Maybe Integer’
07:08:35 <lambdabot>      In the second argument of ‘foldM’, namely ‘(Just 0)’
07:08:41 <julianleviston> dgpratt: apologies.
07:08:45 <dgpratt> no problem
07:09:01 <bartavelle> dgpratt, what do you mean then ? :)
07:09:45 <dgpratt> my understanding is that under certain circumstances, packages are installed "in place" and not given a proper...id?
07:10:08 <julianleviston> dgpratt: can you define “in place” and “id”?
07:10:16 <julianleviston> dgpratt: and what “in place” contrasts to?
07:10:17 <bartavelle> if you copy the package sources into your tree you will get that ... if I understand what you mean
07:11:00 <aweinstock> > foldM (let f _ 0 = Nothing; f m n = Just (m+n) in f) 0 ([1..10]++[0])
07:11:02 <lambdabot>  Nothing
07:11:03 <dgpratt> sorry for being vague, but that's kind of the problem I'm facing :)
07:11:04 <aweinstock> > foldM (let f _ 0 = Nothing; f m n = Just (m+n) in f) 0 ([1..10])
07:11:06 <lambdabot>  Just 55
07:11:45 <julianleviston> dgpratt: the problem being that you don’t know what you’re wanting to know?
07:11:55 <julianleviston> dgpratt: (just curious, not trying to annoy you)
07:12:02 <dgpratt> no problem at all
07:12:41 <julianleviston> aweinstock: is there such a thing as scanM? to show that it stops at a certain point?
07:12:41 <dgpratt> I'm trying to investigate an incompatibility between a couple toolsets and it relates to packages installed 'in-place'
07:13:04 <julianleviston> dgpratt: ah so locally to the installation rather than globally?
07:13:17 <julianleviston> dgpratt: as in, inside the build directory?
07:14:24 <dgpratt> I was hoping someone would know immediately what I was talking about; as that doesn't appear to be a reasonable hope, I will say thanks for the attempt to help me, but nvm for now -- I guess I need to do a bit more investigation on my own
07:14:54 <bartavelle> dgpratt, an "installed" package means that ghc can find it during compilation when pointer at the correct package database
07:14:58 <bartavelle> AFAIK
07:15:11 <bartavelle> so "in place" might mean you have a local package db (ie. a sandbox)
07:15:17 <julianleviston> dgpratt: if you can be a bit more concrete, it might help. as in “I do this, and this happens”.
07:15:19 <bartavelle> hence julianleviston's question
07:15:55 <aweinstock> julianleviston: what would the signature be? ((b -> a -> m b) -> b -> [a] -> m [b]) or ((b -> a -> m b) -> b -> [a] -> [m b])
07:16:01 <aweinstock> :t scanl
07:16:02 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
07:16:20 <julianleviston> aweinstock: that’s a really good question :)
07:17:05 <aweinstock> I think the latter would be more general, in the sense that (sequence . scanlM2) = scanlM1
07:17:38 <aweinstock> or ((sequence .) . scanlM2) or something, but you know what I mean
07:18:08 <hexagoxel> i would assume "in-place" refers to "installing in the build-local environment" (which is not the sandbox, even when using sandboxes)
07:18:10 <aweinstock> :t ((sequence .) .)
07:18:12 <lambdabot> (Monad m, Traversable t) => (a -> a1 -> t (m a2)) -> a -> a1 -> m (t a2)
07:18:45 <aweinstock> huh, that's more specific-looking than I expected
07:18:51 <obadz> why does stackage.org recommand downloading MinGHC for windows while the MinGHC page recommand downloading stack?
07:19:00 <hexagoxel> because with a package that contains lib + exe, `cabal build` will need to put the compiled lib somewhere (but not in any "official" db, just so that it is available for the exe build
07:19:20 <hexagoxel> dgpratt: ^
07:19:41 <zipper> Hello. I am trying to run tests with hspec and I get this error "tests:  executable not found"
07:19:49 <dgpratt> hexagoxel, that sounds right
07:20:05 <bennofs> zipper: are you running cabal test ?
07:20:14 <bennofs> zipper: or what exact command are you executing?
07:20:15 <zipper> bennofs: No stack test
07:20:35 <zipper> `stack test wai-devel` where wai-devel is the package I'm testing.
07:20:55 <hexagoxel> dgpratt: as to when this happens - i would assume any time you `cabal build` (with at least one package-internal dependency ?)
07:21:12 <zipper> bennofs: Let me try `cabal test`.
07:21:15 <hexagoxel> lot of assuming on my part as well, sorry :D
07:21:25 <dgpratt> :)
07:22:46 * hackagebot pontarius-xmpp 0.4.4 - An XMPP client library  https://hackage.haskell.org/package/pontarius-xmpp-0.4.4 (PhilippBalzarek)
07:23:13 <dgpratt> I was thinking that any such "in place" installation would show up in "ghc-pkg dump" with an id like <package>-<version>-inplace
07:23:37 <dgpratt> but I don't see anything like that in my own environment
07:25:23 <bennofs> dgpratt: in-place installation is performed when a component that depends on the library defined in the same cabal file is built I believe
07:25:46 <bennofs> dgpratt: so for example if you have a test-suite that depends on the library defined in the same cabal file
07:25:59 <bennofs> dgpratt: you can also trigger inplace installation manually by running 'cabal register --inplace'
07:26:06 <dgpratt> ohh
07:26:28 <dgpratt> that's very enlightening, thanks bennofs
07:27:02 <bennofs> note that the package is not really "installed", but only registered inplace, which means that the datafiles for the package won't be copied, all that happens is that lib is registered in the inplace package database
07:28:41 <zennist> I've written a DFS search to solve the 8 puzzle; for some reason the performance doesn't seem be right - anyone can care to take a look?
07:28:42 <zennist> http://lpaste.net/142358
07:29:52 <bartavelle> oh a class :)
07:30:06 <hexagoxel> dgpratt: you can observe the registered package with `ghc-pkg` when you give it the right --package-db flags to know about the in-place db.
07:30:56 <hexagoxel> look at how cabal calls ghc-pkg (using cabal build -v)
07:31:47 <dgpratt> I will do that, thanks for the advice, hexagoxel
07:32:26 <zipper> How come stack test can't run hspec tests? :(
07:32:40 <zennist> it prints about 15000 lines and then the process is killed - I assume that's because out of memory on the machine..?
07:33:18 <Ankhers> zipper: What happens when you try to run the tests?
07:34:44 <bartavelle> zennist, your program seems very complicated ... do you have to use the class, the zipper, the RWS monad ?
07:35:28 <zennist> I guess no, was half experiementing :P
07:35:35 <bartavelle> heh
07:35:50 <ayc> can someone explain how this works in point free style:  \x -> f. (g x) = \x ((.) f) (g x)
07:35:51 <zipper> Ankhers: I get Ankhers https://gist.github.com/urbanslug/2a6e56a60c1ddf364b7d
07:36:01 <zennist> but also thinking about generalizing so that I can specify new Problem instances and reuse the same search algorithms
07:36:12 <zipper> bartavelle: Oh man being in this channel is hard. People keep mentioning zipper.
07:36:39 <zipper> Ankhers: Uh there is the error, sorry for what I wrote before.
07:36:49 <bartavelle> sorry :)
07:38:08 <monad> any mathematicians in the room?
07:38:29 <hexagoxel> zipper: at least your nick is not ^
07:39:06 <bennofs> monad: what's the question?
07:39:07 <zipper> hexagoxel: haha yeah life would be rough.
07:40:02 <monad> Let [0,1]^N denote the set of functions from the natural numbers to the closed interval [0,1]. So the question is: are [0,1]^N and [0, inf) equinumerous?
07:40:21 <quicksilver> ayc: that's not point free. That's just writing the dot (.) as prefix instead of infix
07:40:33 <monad> I know that [0,inf) is equinumerous to R.
07:41:08 <zipper> Trying to manually create a value of type `Parser CmdArgs` where CmdArgs is defined like https://gist.github.com/urbanslug/342737b078d448c63ecb
07:41:47 <monad> bennofs: any idea?
07:41:57 <bennofs> monad: no, sorry :/
07:42:07 <zipper> I want to do this for tests to ensure it works. Is there  a way to test my cmdArgs function here: https://gist.github.com/urbanslug/342737b078d448c63ecb#file-cmdargs-L7
07:42:40 <quicksilver> monad: yes, they are
07:43:00 <monad> quicksilver: could you please explain your reasoning?
07:44:15 <quicksilver> monad: I don't think it's particularly trivial or obvious. 
07:44:24 <quicksilver> monad: some reasoning is give here : http://math.stackexchange.com/questions/183361/examples-of-bijective-map-from-mathbbr3-rightarrow-mathbbr
07:46:51 <orion> In this function: copyAndFreeze :: (ByteArrayAccess bs1, ByteArray bs2) => bs1 -> (Ptr p -> IO ()) -> bs2 -- Will I be unable to write a lambda that uses peek and poke (part of the Storable class), since the type signature doesn't contain a class constraint on 'p'?
07:47:25 <bartavelle> zennist, at first glance i would say that your NPState type is huge and the "explored" set will grow a lot
07:48:56 <zennist> bartavelle: that's a necessary part of the solution, and I don't think it should be that big as cause the process to stop i.e. if I implement the same thing in another language it shouldn't have a problem
07:49:19 <bartavelle> zennist, why don't you implement it like in another language then ? :)
07:49:20 <quicksilver> zennist: I think you need to understand why your program stops.
07:49:28 <quicksilver> zennist: assuming it's out of memory doesn't satisfy me
07:49:31 <bartavelle> persistent single linked lists aren't often featured in other languages
07:49:37 <quicksilver> there would be a clear error message if it was
07:49:39 <quicksilver> or there should be
07:49:53 <bartavelle> quicksilver, running it here, it does OOM quickly
07:49:55 <zennist> quicksilver: yeah I'll try to find out
07:50:33 <quicksilver> ah
07:51:01 <latro`a> monad, a nice argument looks like this: |[0,1]^N|=|(2^N)^N|=|2^(N x N)|=|2^N|=|R|
07:51:07 <aweinstock> @let scanM f i l = aux (return i) l where { aux _ [] = []; aux acc (x:xs) = let acc' = acc >>= flip f x in acc' : aux acc' xs}
07:51:08 <lambdabot>  .L.hs:166:1: Warning:
07:51:09 <lambdabot>      Pattern match(es) are overlapped
07:51:09 <lambdabot>      In an equation for ‘scanM’: scanM f i l = ...
07:51:13 <zipper> Can anyone help with creating values of type Parser a from OptParse Applicative?
07:51:17 <aweinstock> @undefine
07:51:17 <lambdabot> Undefined.
07:51:18 <aweinstock> @let scanM f i l = aux (return i) l where { aux _ [] = []; aux acc (x:xs) = let acc' = acc >>= flip f x in acc' : aux acc' xs}
07:51:20 <lambdabot>  Defined.
07:51:29 <aweinstock> scanM (let {f _ 0 = Nothing; f m n = Just (m+n)} in f) 0 [10,9..0]
07:51:33 <zennist> ah I think I get my problem now
07:51:36 <aweinstock> > scanM (let {f _ 0 = Nothing; f m n = Just (m+n)} in f) 0 [10,9..0]
07:51:38 <lambdabot>  [Just 10,Just 19,Just 27,Just 34,Just 40,Just 45,Just 49,Just 52,Just 54,Jus...
07:51:42 <camm1> Hey people. I was reading about GHC/Memory Footprint (https://wiki.haskell.org/GHC/Memory_Footprint) when I realize that the size of Bool type is 0 word (a word's size is 4 bytes on 32bit architecture and 8 bytes on 64bit architecture). Does it mean it's less than 4 bytes? Then what is the size of bool type?
07:51:44 <latro`a> monad, the first step bijects [0,1] with 2^N (i.e. P(N)); the second step uncurries the functions; the third step bijects N x N with N
07:51:51 <aweinstock> julianleviston: ^ scanM
07:51:52 <julianleviston> aweinstock:  ;-)
07:51:56 <julianleviston> aweinstock: I saw. :)
07:52:09 <zennist> foldr (liftM2 (<|>)) (return empty) $ complexListOfMonadOps
07:52:17 <aweinstock> that took me much longer than it should have
07:52:25 <julianleviston> :t scanM
07:52:26 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> [m a]
07:52:32 <zennist> can someone verify that this will only give me my result when every single item of the list is consumed
07:52:37 <julianleviston> [b] ?
07:52:45 <zennist> my goal: lazily return the first non empty result
07:53:17 <aweinstock> julianleviston: the list of things that get scanned?
07:53:23 <julianleviston> aweinstock: ah it’s scanMInsideList
07:53:30 <zennist> but maybe liftM2 demands its second argument to be entirely evaluated
07:53:36 <julianleviston> aweinstock: hehe :) of course, coz scan builds a list.
07:53:36 <aweinstock> :t foldM
07:53:37 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
07:53:43 <julianleviston> right
07:54:02 <jgx> MarcelineVQ: Hey, I finally makes atom works, by adding ghc-mod-5.4.0.0 in extra-deps (stack.yaml file)
07:54:10 <aweinstock> :t foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> a
07:54:11 <lambdabot>     Couldn't match type ‘a1’ with ‘m1 a1’
07:54:11 <lambdabot>       ‘a1’ is a rigid type variable bound by
07:54:11 <lambdabot>            an expression type signature:
07:54:12 <aweinstock> :t foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
07:54:14 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
07:54:21 <jgx> MarcelineVQ: Dumb question, once I use stack build, how can i run my program ? xD
07:54:23 <julianleviston> aweinstock: can’t you then just “specialise” foldm to be scanm?  I need to understand more things :)
07:54:47 <aweinstock> :t ((last .) . scanM)
07:54:48 <lambdabot>     Couldn't match type ‘[b] -> [m a]’ with ‘[c]’
07:54:48 <lambdabot>     Expected type: (a -> b -> m a) -> a -> [c]
07:54:48 <lambdabot>       Actual type: (a -> b -> m a) -> a -> [b] -> [m a]
07:55:17 <julianleviston> jgx: it will tell you where it’s built.
07:55:30 <julianleviston> jgx: where it put the executable.
07:55:37 <aweinstock> :t ((fmap last .) . scanM)
07:55:37 <jgx> julianleviston: is there a "build and run" command ?
07:55:38 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
07:55:47 <aweinstock> :t [((fmap last .) . scanM), foldM]
07:55:48 <lambdabot> Monad m => [(a -> b -> m a) -> a -> [b] -> m a]
07:55:50 <julianleviston> jgx: I’m not sure.
07:56:00 <aweinstock> julianleviston: those're the same type
07:57:33 <julianleviston> aweinstock: I feel like there’s something simpler trying to get out, but this will probably pass once I understand more.
07:57:47 * hackagebot singletons 2.0.0.2 - A framework for generating singleton types  https://hackage.haskell.org/package/singletons-2.0.0.2 (RichardEisenberg)
07:57:56 <aweinstock> > last $ scanM (let {f _ 0 = Nothing; f m n = Just (m+n)} in f) 0 [10,9..1]
07:57:57 <lambdabot>  Just 55
07:58:11 <aweinstock> > foldM (let {f _ 0 = Nothing; f m n = Just (m+n)} in f) 0 [10,9..1]
07:58:13 <lambdabot>  Just 55
07:59:13 <aweinstock> oh, that fmap is using (->)'s functor instance...
07:59:16 <aweinstock> :t (((last .) .) . scanM)
07:59:17 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
07:59:38 <aweinstock> (that should be less confusing)
07:59:55 <jgx> julianleviston: I think stack exec did the trick :)
08:00:06 <jgx> stack build && stack exec myApp
08:00:09 <julianleviston> jgx: nice! I’ll keep that in my memory for later. thanks.
08:00:27 <aweinstock> equivalently: ((.).(.).(.)) last scanM
08:00:35 <camm1> stack build --exec myApp it's easier.
08:01:09 <julianleviston> camm1:  ah that’s what he was asking for a minute ago :) cool
08:01:15 <julianleviston> jgx: ^
08:05:46 <dfeuer> If GHC didn't have overlapping instances and closed type families, would   instance c => d    imply that    d :- c ?
08:06:05 <dfeuer> Or are there plumbing reasons that wouldn't work out?
08:08:15 <quicksilver> julianleviston: "I feel like there's something simpler trying to get out" -- I spend so much haskell time thinking this.
08:08:26 <quicksilver> julianleviston: sometimes it's so distracting I don't get actual programming done :P
08:08:34 <julianleviston> quicksilver: :)
08:09:20 <julianleviston> quicksilver: I’ve spent the last 2 weeks to month learning… I need to get back to programming and start on my project!
08:10:41 <julianleviston> quicksilver: In a way, I think perhaps it’s the fact that so much of what is possible in Haskell is so amazingly elegant, that we kind of search it out more, perhaps… 
08:10:51 <julianleviston> quicksilver: who knows :)
08:13:37 <quicksilver> julianleviston: yes, you see something particularly neat and it sets your expectations high and when something else doesn't seem to match up...
08:14:35 <julianleviston> quicksilver: yeah, whereas in other languages, you’re just happy if you get it working and your tests passing (because THAT alone is so much effort).
08:23:56 <zipper> Is there a way to ensure that a value is of a certain type with hspec?
08:24:22 <hpc> zipper: this isn't something you can just use the type system for?
08:24:37 <jstimpfle> julianleviston: i have tried for ages to make some simple rdbms layer
08:25:06 <jstimpfle> problem is, many things just don't lend easily to expression through types. DB schemas certainly not
08:25:37 <julianleviston> jstimpfle: there are a number of RDBMS layers in haskell
08:25:40 <zipper> hpc: Well I want to ensure that a certain call to forkIO actually didn't throw an exception.
08:25:59 <julianleviston> jstimpfle: none of those good enough?
08:25:59 <jstimpfle> they all use some template haskell hackery and i don't think they are practically usable
08:26:17 <hpc> ah, hmm
08:26:19 <zipper> hpc: That it returned a value of type ThreadId
08:26:31 <jstimpfle> like, i want to code my own abstractions. Define my own types
08:26:35 <julianleviston> jstimpfle: oh I looked at HDBC a little, and I found it pretty ok looking from the outside. I haven’t actulaly started to use one yet… but yeah.
08:26:40 <hpc> well, forkIO always returns a value of type ThreadId
08:26:56 <zipper> hpc: Can't it throw an exception or something idk
08:26:57 <hpc> exceptions are embedded in IO
08:27:05 <julianleviston> jstimpfle: yeah, defining your own types… well that’s an interesting question :) hehe… I’ve been musing and pondering this for quite a while now...
08:27:11 <jstimpfle> HDBC i think is just the SQL-string with ? replacement which you also (more) easily get in e.g. python no?
08:27:51 <hpc> don't know enough about hspec to say if it has any way of talking about IO exceptions
08:29:04 <zipper> hpc: It does
08:29:07 <jstimpfle> But what i would really like is having my functions indicate e.g. what row schema they are returning. And to combine query to form bigger ones. This type of stuff can't easily work. One important problem is that row types have named members, and the names depend on the query
08:29:07 <zipper> http://hspec.github.io/expectations.html
08:29:24 <zipper> hpc: But I want to check that it did not throw an exception idk
08:29:34 <julianleviston> jstimpfle: have you seen opaleye?
08:30:02 <jstimpfle> looked at out and thought it looked VERY complex.
08:30:05 <hpc> zipper: i think expecting no exceptions is the default behavior then
08:30:22 <hpc> any exception thrown will fail whatever other spec you give, since you haven't said it should be throwing anything
08:30:23 <julianleviston> jstimpfle: there’s also relational record
08:30:27 <julianleviston> jstimpfle: http://khibino.github.io/haskell-relational-record/quickstart.html
08:30:52 <julianleviston> jstimpfle: lets you do compositions of queries, etc. I don’t think it uses TH (much?)
08:31:41 <quicksilver> zipper: I don't think thre is any need to explicitly mention it doesn't throw an exception
08:31:42 <julianleviston> jstimpfle: but if you want to, say, store a tree, then I think perhaps it’s not the best. Mind you, that’s already reasonably tricky anyway… because of the mismatch between the shape of the data and the shape of RDBMS… so you’re probably better choosing a better store.
08:31:51 <quicksilver> hspec will complain if it does
08:31:59 <quicksilver> (unless you used shouldThrow or whatever)
08:32:01 <camm1> When I write a record: data Person = Person { name :: !String , salary :: !Int }. What do the !String and !Int mean?
08:32:22 <julianleviston> camm1: I don’t know…! where did they come from?
08:32:28 <hpc> jstimpfle: something that may interest you is acid-state and ixset
08:32:34 <quicksilver> they are strictness annotations
08:32:36 <hpc> camm1: they mean strict fields
08:32:47 <julianleviston> hpc: I think he’s particularly interested in RDBMS
08:32:55 <julianleviston> hpc: there are some troubles with acid-state...
08:32:56 <hpc> Person {name = undefined, salary = 5} will be the same as undefined
08:32:58 <quicksilver> they mean that whenever the 'Person' value is forced to WHNF, the name and salary fields will be too.
08:33:08 <hpc> julianleviston: there are?
08:33:13 <jstimpfle> julianleviston: yeah i know trees are just a (very opinionated, in terms of access-path) representation. Tables are what express logical relationship
08:33:20 <julianleviston> hpc: one of them is that you’re stuck to a filesystem… in some contexts, one can’t use a filesystem to store one’s stuff...
08:33:38 <zipper> hpc: quicksilver Well I really wanted to find a way to do it this is the best way I could http://lpaste.net/3364312762732773376
08:33:51 <julianleviston> jstimpfle: yeeeah, some data doesn’t fit within the relational model very well.
08:33:52 <EvanR> julianleviston: how do you implement ACID without a filesystem?
08:34:10 <hpc> EvanR: STM and such
08:34:11 <quicksilver> I don't see how tid `shouldBe` tid says anythign interesting
08:34:18 <EvanR> huh
08:34:19 <hpc> EvanR: the better question is how you implement persistence without a filesystem
08:34:22 <EvanR> Durability
08:34:24 <julianleviston> EvanR: I wasn’t passing comment on whether that was possible or not. I was simply explaining the issues with it.
08:34:31 <hpc> ah right, durability
08:34:34 <hpc> yeah, no idea
08:34:39 <zennist> how can I keep the writer output in a RWST r w s Maybe
08:34:42 <camm1> Thanks a lot guys.
08:35:15 <EvanR> julianleviston: i think theres probably bigger issues with acid state for most people than that
08:35:21 <zennist> I want the RWST to have the ability to tell failure apart from result; and also keep the log even if it's a failure result
08:35:26 <julianleviston> EvanR: yeah?
08:35:57 <julianleviston> EvanR: how come an RDMS isn’t ACID necessarily, by the way?
08:36:20 <julianleviston> EvanR: depending on your definition of file system, I guess...
08:36:32 * EvanR scrolls up and tries to find the context for that
08:36:53 <julianleviston> EvanR: I assume you’re using “file system” to mean an eventual “resting place” for the data?
08:36:58 <EvanR> you were thinking an RDBMS doesnt need a filesystem?
08:37:03 <julianleviston> EvanR: no.
08:37:30 <julianleviston> EvanR: I was saying that ACID-STATE stores its stuff on a file system directly rather than has a separate server context.
08:37:39 <julianleviston> EvanR: but I could be just talking rubbish.
08:37:39 <EvanR> theres a networked mode
08:37:43 <julianleviston> EvanR: ahh…
08:37:49 * hackagebot cabal-helper 0.6.1.0 - Simple interface to some of Cabal's configuration state used by ghc-mod  https://hackage.haskell.org/package/cabal-helper-0.6.1.0 (DanielG)
08:37:52 <Shockk> acid-state can connect to a remote acid-state server
08:38:03 <julianleviston> aren’t there issue with multiple connections tho?
08:38:14 <EvanR> why would there be?
08:38:26 <bartavelle> zennist, I found the bug in your program
08:38:27 <julianleviston> EvanR: just what I remember reading last time I looked.
08:38:38 <julianleviston> I’ll have to go look it up again when it comes time to investigate persistent storage in my app again.
08:38:50 <bartavelle> zennist, at the line where you "put $ DFSState ns explored' (path `mappend` ([a], stepCost p s a ns))"
08:39:03 <bartavelle> explored' is from outside of the foldl'
08:39:07 <julianleviston> EvanR: tho… if I want to deploy to heroku, it’s probably not a viable option.
08:39:30 <EvanR> its not a drop in replacement for SQL thats for sure
08:39:38 <zennist> bartavelle: mhh, actually I think it's the liftM2'
08:39:41 <julianleviston> EvanR: oh yeah, obviously.
08:39:41 <zennist> liftM2
08:39:59 <EvanR> but if you change the expectations of your application it might work out, but then theres managing migrations
08:40:19 <zennist> liftM2 requires the computation results of both sides to perform a map; that means my old program will explore all states before it gives the goal state
08:40:33 <julianleviston> EvanR: I was interested in jstimpfle ’s comment that there aren’t any good wrappers for RDBMS’s tho… I thought the ones that exist were *reasonable*
08:40:35 <bartavelle> zennist, perhaps it's too, but this is definitely buggy
08:40:51 <EvanR> mysql and postgres-simple are pretty awesome for that
08:40:58 <zennist> bartavelle: http://lpaste.net/142358
08:41:01 <bartavelle> zennist, this finds the solution instantly : http://lpaste.net/2828868763422556160
08:41:05 <julianleviston> EvanR: yeah, not so much, IMHO
08:41:27 <julianleviston> EvanR: I feel like writing direct SQL is a bit… broken.
08:41:31 <EvanR> if im using SQL, then im not interested in a wrapper to store arbitrary JSON or whatever and ignoring the fact that im using SQL
08:41:44 <julianleviston> EvanR: fair enough.
08:42:19 <quicksilver> bartavelle/zennist: one of the main goals of using the state monad is *not* carrying around things like 'explored' and 'explored'' and accidentally confusing them
08:42:26 <quicksilver> but having them hidden away so you can't get it wrong
08:42:26 <zennist> bartavelle: that's basically fixing the liftM bug by using recursion :)
08:42:41 <jstimpfle> My biggest itch with writing SQL directly are that it becomes unmanageable VERY quickly.
08:42:45 <sicasal> hello again i have two functions one that creates a list of [1..n] and other that divide the number 
08:42:47 <bartavelle> zennist, no, it doesn't work if you don't fix the explored' problem
08:43:05 <sicasal> how can i join them ?
08:43:09 <bartavelle> quicksilver, exactly, the state that is "get" from outside the loop is reinjected in the loop instead of being updated
08:43:45 <julianleviston> EvanR: I find writing boilerplate pretty tedious, and SQL is a lot of it. Then there’s managing the traversal of the data back into the langauge structure, etc.
08:43:45 <quicksilver> I have made similar mistakes many times
08:43:53 <EvanR> jstimpfle: "directly" is a bit of a stretch for mysql-simple
08:43:57 <quicksilver> once a mistake like that made a GHC optimisation fail
08:44:05 <quicksilver> (a mistake like that in the GHC code that is)
08:44:18 <jstimpfle> SQL too much boilerplate, especially if you can't define your own types (i heard postgresql lets you do that)
08:44:21 <athan> If you were to embed a monadic action into a monoidal concatenation, how would you do it?
08:44:28 <jstimpfle> EvanR: ok, don't know mysql-simple
08:45:00 <sicasal> f n = [1..n] and g x =[x|x<-f n , fn mod x==0] ?
08:45:01 <EvanR> like, theres no string concating
08:45:11 <sicasal> i would like to join them
08:45:21 <sicasal> i cannot do that right?
08:45:39 <julianleviston> sicasal:  what do you mean by “join” ?
08:45:41 <zennist> bartavelle: unfortunately I think you missed the point of my old algorithm
08:45:50 <bartavelle> probably
08:45:55 <bartavelle> yes it's buggy
08:46:02 <bartavelle> you can witness it by traceShowM (S.size explored)
08:46:11 <bartavelle> you will see that it sometimes decreases
08:46:13 <sicasal> two functions in a list comprehension
08:46:17 <zennist> explored' is injected into subsequent RWST monads so that the subsequent searches get the updated explored set
08:46:24 <julianleviston> sicasal: yes, you do that.
08:46:38 <julianleviston> sicasal: list comprehensions can have function calls inside them.
08:46:44 <aweinstock> :t liftA2 (<>) -- athan
08:46:45 <lambdabot> (Applicative f, Monoid c) => f c -> f c -> f c
08:46:57 <bartavelle> zennist, yes but you call dfs which should update it again. Except for the next loop in the "asum" you put the same, discarding the previous results
08:46:59 <julianleviston> sicasal:  and you can write predicates (conditional modifier functions) in your comprehensions, too.
08:47:01 <athan> aweinstock: Awesome :) thank you!
08:47:28 <bartavelle> zennist, just print the size of the explored set, you'll see that you discard it
08:47:35 <julianleviston> > [x | x <- [1..5], x > 3]
08:47:36 <lambdabot>  [4,5]
08:47:44 <sicasal> one creates a list of f n =[1...n] the other will divide the numbers of that list and see if they are dividers of the number
08:48:14 <julianleviston> > [x | x <- [1..10], even x]
08:48:15 <lambdabot>  [2,4,6,8,10]
08:48:34 <sicasal> i can do [x| x<-[1..n], n mod x ==0]?
08:48:35 <bartavelle> zennist, that's why it's good practice to use "modify" instead of "put", it's less likely you inject state from a previous state in your "do" block ...
08:48:42 <julianleviston> sicasal: yes.
08:48:54 <zennist> bartavelle: yeah, but I don't really care -- my explored set was originially intended to detect a loop; basically, something that has been seen in the CURRENT search
08:49:02 <sicasal> where i get the n then?
08:49:08 <julianleviston> sicasal:  or you could take one function and wrap the output of the call in a call to filter
08:49:16 <julianleviston> sicasal:  in the function call
08:49:33 <athan> aweinstock: In my use case, I'm trying to search for a file, with a list of possible locations as the input I can test against. I was thinking about embedding `Any` and some kind of tuple logic, to make it O(n), but I'm just not sure how I would `foldMap` the monadic actions :s (let alone the tuple information)
08:49:38 <pikajude> is hackage up
08:49:51 <zennist> if it's in another branch then I don't need to carry the explored states in that other branch into all the remaining branches
08:49:55 <athan> (using `doesFileExist`, I mean)
08:50:05 <bartavelle> zennist, except if you don't want to run useless searches ?
08:50:06 <julianleviston> sicasal:  that you embed your comprehension in.
08:50:32 <julianleviston> sicasal: eg: f n = [x| x<-[1..n], n `mod` x == 0]
08:50:37 <zennist> bartavelle: that's true I'll think about it
08:50:43 <julianleviston> sicasal: then call it like: f 20
08:51:20 <julianleviston> sicasal:  20 would get “subbed in” for n… 
08:51:27 <sicasal> oh that´s what i want to do it but i didn t know how to do it 
08:52:08 <julianleviston> sicasal:  cool :)
08:52:39 <zennist> bartavelle: yes, you are right; given the current problem formulation it will make no difference to the subsequent given the same state (the action generation function doesn't depend on past actions)
08:53:35 <sicasal> julianleviston: tks now i have another question
08:53:42 <julianleviston> sicasal:  ok
08:54:24 <sicasal> what i want know is that the sum of the dividers pair are equal to the number what i mean is 
08:54:27 <julianleviston> sicasal:  you also could have written it with filter… f n = filter (\x -> n `mod` x == 0) [1..n]
08:54:56 <EvanR> sicasal: is this homework?
08:55:01 <sicasal> yes
08:55:10 <julianleviston> sicasal: ah, then it’s best I not tell you answers.
08:55:15 <julianleviston> EvanR: good point!
08:55:31 <sicasal> i dont want the answers :p
08:55:40 <julianleviston> sicasal:  haha ok
08:55:59 <sicasal> i just need help in rewriting the code because i know what to do in paper
08:56:02 <julianleviston> sicasal: now I know that, I’ll structure my responses a little differently. :)
08:56:20 <sicasal> i just dont know how to put in haskell code
08:56:28 <julianleviston> sicasal: what class is it?
08:56:39 <sicasal> principles of programing
08:56:54 <julianleviston> sicasal: and they’re not teaching you haskell?
08:57:28 <julianleviston> sicasal:  seems a little strange to give you problems without explaining the syntax of the language they want the answers in.
08:57:29 <EvanR> sicasal: whats the actual problem description
08:57:47 <EvanR> you might want to use lpaste
08:57:48 <sicasal> i am not very good at programming
08:58:16 <julianleviston> sicasal: it’s fine. 
08:58:52 <EvanR> http://lpaste.net/
09:01:08 <sicasal> know i wanted that the list that was made it f n = [x|x<-[1..n],n´mod´x==0] 
09:01:30 <sicasal> i know wanted the sum of the divisors that are pair and compare to the x
09:01:44 <sicasal> like sum n ==x
09:01:47 <sicasal> ?
09:01:55 <julianleviston> sicasal: sorry, but I’m not following. non-english?
09:01:59 <EvanR> I'm not sure I understand the word pair there
09:02:08 <sicasal> portuguese
09:02:12 <julianleviston> sicasal: ah...
09:02:25 <julianleviston> sicasal: use small sentences.
09:02:49 <EvanR> sum x = n ?
09:02:53 <sicasal> for example the dividers of 12 are 
09:02:58 <athan> Is there a recursive `findFile`?
09:03:15 <julianleviston> sicasal: do you mean “factors” ?
09:03:32 <julianleviston> sicasal: 12 = 1,2,3,4,6 ?
09:03:32 <sicasal> for example the dividers of 12 are 2 3 4 6 
09:03:37 <EvanR> divisors of 12 are 1 2 3 4 6 and 12
09:03:43 <julianleviston> ok.
09:03:47 <sicasal> yes but the sum of the dividers pair give 12 
09:04:08 <sicasal> the 3 goes way that s way i put n´mod´x==0
09:04:13 <EvanR> 2+3+4+6 ?
09:05:10 <julianleviston> won’t that function show you the divisors of the number?
09:05:32 <sicasal> yes i know want to sum that list that function gives
09:05:35 <EvanR> (1,12) (2,6) (3,4)
09:05:39 <sicasal> and compare to the number
09:06:00 <julianleviston> EvanR: he wants to do sum (divs num) == num
09:06:02 <EvanR> what here adds up to 12 ?
09:06:09 <julianleviston> EvanR: the divisors.
09:06:22 <julianleviston> EvanR: he wants to check that. He was asking earlier.
09:06:22 <sicasal> yes julian
09:06:24 <EvanR> julianleviston: no, something to do with the pairs. "3" doesnt count for some reason
09:06:41 <sicasal> i just want the divisors that are even
09:06:47 <sicasal> sorry i said pair 
09:06:48 <EvanR> ah even
09:06:53 <julianleviston> EvanR: 3 doesn’t count because it’s not an “interesting” number or something.
09:07:02 <EvanR> 3 doesnt count because its odd
09:07:08 <julianleviston> sicasal: there is a function called even.
09:07:16 <julianleviston> > even 2
09:07:17 <EvanR> 2+4+6 = 12
09:07:17 <lambdabot>  True
09:07:43 <EvanR> sicasal: so you want to filter out the odd divisors.
09:07:54 <julianleviston> you can put multiple conditions in your comprehension.
09:10:25 <sicasal> so how can i sum the list that gives me the divisors even ?
09:11:20 <sicasal> and then compare it to the number to see if it is the same 
09:11:43 <julianleviston> sicasal: see if you can work it out...
09:11:46 <julianleviston> > sum [1,2,3,4]
09:11:48 <lambdabot>  10
09:11:55 <sicasal> yes i understand that 
09:12:01 <julianleviston> > filter even [1,2,3,4]
09:12:03 <lambdabot>  [2,4]
09:12:16 <julianleviston> [x | <- [1..20], even x]
09:12:46 <sicasal> yes but now how do i sum julian ?
09:12:54 <sicasal> i put before the function ?
09:12:57 <EvanR> > [x | x <- [1..20], even x]
09:12:59 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
09:13:03 <EvanR> > sum [x | x <- [1..20], even x]
09:13:04 <lambdabot>  110
09:13:08 <EvanR> mix and match!
09:13:15 <julianleviston> sicasal: sum takes a list
09:13:31 <sicasal> and then compare to the number that it was given me by the list 
09:13:34 <julianleviston> sicasal: a list comprehension produces a list. Plug them together, as EvanR showed.
09:13:36 <EvanR> sicasal: its instructive to ask what is the type of a function
09:13:37 <EvanR> :t sum
09:13:39 <lambdabot> (Num a, Foldable t) => t a -> a
09:13:43 <EvanR> hmm
09:13:46 <julianleviston> lol
09:13:56 <julianleviston> EvanR: this might be better
09:13:59 <julianleviston> :t [1,2,3]
09:14:01 <lambdabot> Num t => [t]
09:14:13 <EvanR> sum :: Num a => [a] -> a
09:14:14 <julianleviston> :t sum [1,2,3]
09:14:16 <lambdabot> Num a => a
09:14:18 <EvanR> :t even
09:14:19 <lambdabot> Integral a => a -> Bool
09:14:25 <julianleviston> guh, not really that simple is it.
09:14:36 <julianleviston> we need “pedagogical simple haskell” :) with trainer wheels,
09:14:57 <sicasal> but how can i compare to a number ?
09:15:01 <EvanR> i remember when it was like that ;)
09:15:05 <EvanR> no burning bridges
09:15:06 <julianleviston> sicasal:  what comparison? :)
09:15:15 <julianleviston> EvanR: <shrug> not really that serious.
09:15:16 <sicasal> to every element of the list 
09:15:24 <julianleviston> sicasal: what type of comparison?
09:15:31 <julianleviston> > 1 == 1
09:15:32 <sicasal> ==
09:15:32 <lambdabot>  True
09:15:45 <tomus> I presume most ppl here program in many languages as one ought to be quite curious about programming langugages in general in order to come accross haskell
09:15:45 <julianleviston> > [1,2] == [1,2]
09:15:47 <lambdabot>  True
09:15:58 <julianleviston> sicasal:  makes sense?
09:16:13 <julianleviston> tomus: or they have to use it for school :)
09:16:29 <julianleviston> EvanR: it might be helpful, tho, no?
09:16:32 <emmanuel_erc> hello there! 
09:16:44 <ski> hello emmanuel_erc
09:16:48 <EvanR> what is helpful
09:17:03 <emmanuel_erc> hi ski
09:17:29 <EvanR> list comphrehensions might not be the best introduction to programming in general
09:17:49 <tomus> now isn't this somewhat suboptimal to spread your horizons across different langauges rather than learn just one but really really well. be it Java/C# or .Net. if you insist on using just one language for all your needs you end up honing the skills for years.
09:17:50 <EvanR> they are syntactic sugar
09:18:05 <EvanR> tomus: in terms of money, maybe
09:18:07 <tomus> Java/C++ or c#
09:18:11 <hpc> julianleviston: fwiw, other languages have similar initial hurdles and get by just fine
09:18:20 <Sindriav_> How should I install binaries with stack?
09:18:21 <Sindriav_> like ghc-mod
09:18:24 <EvanR> people pay big bucks for ye olde cobol guru
09:18:26 <julianleviston> hpc: have you used Racket?
09:18:26 <emmanuel_erc> I want to ask if a lens (ekmett style) would be appropriate in my situation.
09:18:33 <julianleviston> hpc: compare that to anything else and that’s what I mean :)
09:18:38 <hpc> julianleviston: for instance in java, System.out.println brings in a whole mess of concepts
09:18:39 <julianleviston> hpc: but yeah :)
09:18:44 <julianleviston> hpc: sure.
09:18:51 <emmanuel_erc> I always feel like I making a problem more difficult than it needs to be.
09:18:57 <hpc> inheritance, overloading, toString
09:19:13 <tomus> EvanR: in terms of time investment
09:19:29 <tomus> I understand that perhaps most haskellers do it for fun
09:19:34 <EvanR> tomus: most languages are pretty much the same thing
09:19:49 <tomus> only superficially
09:19:57 <julianleviston> tomus: being a polyglot can increase your understanding, because there are different ways of looking at things, and it’s just syntax differences. Most Haskellers are polyglots.
09:19:58 <tomus> once you start digging into ffi/standard libs
09:20:05 <EvanR> not superficially, they differ wildly on inconsequential syntax
09:20:08 <tomus> other implementation details
09:20:21 <tomus> there's A LOT to learn for each language
09:20:29 <tomus> look at JVM or CLR specs
09:20:50 <emmanuel_erc> So, I have a list of things with type  [[(Double,Int)],Int,String,[(Double,Int)]] 
09:20:52 <julianleviston> tomus: <cough> you should do what is most appropriate in your situation :)
09:21:13 <EvanR> are the jvm specs that important to being a java programmer?
09:21:21 <julianleviston> emanuelz: I don’t understand that type.
09:21:21 <emmanuel_erc> And I want to append items to the two inner list, but it can be based on previous computations.
09:21:22 <tomus> it's easy to be competent in many but hard to be an expert in one
09:21:37 <EvanR> being an expert in anything is going to be hard to convince anyone of
09:21:37 <julianleviston> emanuelz: it seems to be a four-element tuple, except it’s a list?
09:22:01 <EvanR> and being an expert in something is going to be hard if you arent aware of anything outside your narrow focus
09:22:06 <julianleviston> emmanuel_erc: ohhh it’s not a type…?
09:22:15 <emmanuel_erc> julianleviston: sorry you're right I screwed up
09:22:21 <Sindriav_> How should I install utilities with Stack? Like ghc-mod
09:22:40 <emmanuel_erc> the actual type that I have from my repl is [([t], Int, [Char], [t1])]
09:22:41 <bitemyapp> Sindriav_: stack install should be fine, then make sure ~/.local/bin is in your path.
09:23:05 <Sindriav_> bitemyapp: I'm getting errors when doing stack install ghc-mod, I thought I might be doing something wrong
09:23:17 <Sindriav_> bitemyapp: I'll check if ~/.local/bin is in PATH ^^
09:23:32 <Cale> Sindriav_: which errors?
09:23:39 <julianleviston> I think someone was having issues installing ghc-mod earlier… not sure if this is related. Cale might know
09:23:49 <Sindriav_> Cale: Could not find package cabal-helper in known packages
09:23:51 <bitemyapp> Sindriav_: well no, if you're getting build errors it's not the path.
09:24:07 <emmanuel_erc> oh wait...I just realized something. I may be back soon.
09:24:41 <bitemyapp> Sindriav_: https://www.stackage.org/lts-3.8/hoogle?q=cabal-helper
09:24:44 <Sindriav_> bitemyapp: well, it recommends `stack solver`, which complains about not being able to see cabal in path
09:24:55 <ttt_fff> I have the following problem: cabal install --only-dep is NOT installing some pacakges because it's globally available; but then hdevtools is complaining because it can't find theseglobal packages
09:25:04 <bitemyapp> Sindriav_: slow down homeslice.
09:25:13 <bitemyapp> Sindriav_: see that link and how cabal-helper doesn't show up in Stackage?
09:25:30 <ttt_fff> (1) cabal sandbox init; cabal install --only-dep (2) some packages are NOT installed in local sandbox, becuase they're globally available, then (3) hdevtools check Main.hs complainsa bout these packages because it's not searching for them globally
09:25:41 <bitemyapp> Sindriav_: the lts resolvers for Stack are basically giving it a set of known-good packages to work with, but they're from Stackage, which has a subset of what Hackage has.
09:26:03 <Sindriav_> bitemyapp: aaaand?
09:26:08 <bitemyapp> I'm typing
09:26:12 <Sindriav_> I see
09:26:23 <bitemyapp> Sindriav_: when this happens, you can just pick a resolver (latest lts or whatever you ordinarily use), and add the stuff that is in Hackage but _not_ Stackage to the extra-deps list in either your personal stack.yaml or in the project.
09:26:38 <Sindriav_> bitemyapp: I see!
09:26:41 <bitemyapp> Sindriav_: stack install is sort of a "just install this thing, using my personal stack.yaml to figure out what to do"
09:26:52 <Cale> ttt_fff: Try --upgrade-dependencies
09:27:00 <bitemyapp> Sindriav_: whereas you could git clone the project and install it from there, modifying or adding a stack.yaml as needed.
09:27:07 <ttt_fff> Cale: cabal install --upgrade-dependencies ?
09:27:12 <Cale> yeah
09:27:22 <Cale> Or perhaps --reinstall?
09:27:24 <mniip> ReinH, I think I'm starting to get some intuition on tensors
09:27:25 <bitemyapp> Sindriav_: incidentally, my coauthor and I are going to make a video explaining how to do this stuff with Stack soon, so I'm glad you asked this question as it gives me a project to demonstrate in the video.
09:27:30 <bitemyapp> Sindriav_: so thank you for asking for help ;)
09:27:51 * hackagebot polar-configfile 0.4.1.0 - Fork of ConfigFile for Polar Game Engine  https://hackage.haskell.org/package/polar-configfile-0.4.1.0 (Shockk)
09:27:52 <Sindriav_> bitemyapp: Thank you for answering! ^^
09:28:16 <mniip> that article really helps with understanding matrices as morphisms rather than objects
09:28:19 <Sindriav_> bitemyapp: It's kinda confusing, when this happens, because it feels like an error, not something that's expected to happen when you run `stack install ghc-mod`
09:28:26 <mniip> ReinH^
09:28:34 <bitemyapp> Sindriav_: anyway, that's the basic process. Stackage LTS snapshot covers a lot of packages, but any that aren't in the LTS snapshot will need to be specified in extra-deps with a specific version.
09:29:00 <bitemyapp> Sindriav_: yeah, I'm not totally happy with the behavior here either. I'm going to test the installation on a fresh machine and see if I have UX feedback for Stack as a result.
09:29:26 <mniip> in haskell terms, we CPS the scalar multiplication
09:29:55 <mniip> er
09:30:03 <mniip> matrix multiplication
09:30:08 <Sindriav_> bitemyapp: I mean, it suggested adding cabal-helper to stack.yaml, but I had a hard time figuring how something in LTS would have a dependency that's not in there O.o
09:30:12 <bitemyapp> Sindriav_: these might help: https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md http://seanhess.github.io/2015/08/04/practical-haskell-getting-started.html https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md
09:30:21 <mniip> and tensors would be... generalizations of such morphisms to arbitrary amount of dimensions
09:30:23 <bitemyapp> Sindriav_: the Cabal files still specify dependencies - not the stack.yaml
09:30:38 <Sindriav_> bitemyapp: Thanks! I see
09:30:46 <bitemyapp> Sindriav_: Stack still determines all dependencies based on the build-deps in the Cabal stanzas.
09:30:54 <bitemyapp> this is another point of confusion we need to clear up.
09:30:55 <EvanR> mniip: what article, and what does CPS the scalar multiplication mean
09:30:55 <Sindriav_> Ah
09:31:21 <bitemyapp> Sindriav_: the stack.yaml isn't so much a dependency or project config spec like Cabal, as a "build plan" config.
09:31:23 <Sindriav_> bitemyapp: What would really help is not using stack for these things… But there are arguments for it, too
09:31:37 <bitemyapp> Sindriav_: *shrug* I find it helps me a lot, but I'm comfortable with how it works.
09:31:52 <bitemyapp> I think it's a win for most people, you just run into sticking points that aren't well explained in the docs yet because it's new.
09:31:57 <Sindriav_> bitemyapp: Yeah, but installing stuff like ghc-mod should be done by a package manager IMO
09:32:06 <bitemyapp> I would agree if it were more stable.
09:32:10 <Sindriav_> Yeah
09:32:11 <mniip> EvanR, partially applied matrix multiplication is a morphism in the category of vectors
09:32:33 <Sindriav_> One of the *biggest* pains when starting with Haskell was why is there `cabal install` but not `cabal uninstall`
09:32:51 * hackagebot ig 0.6.1 - Bindings to Instagram's API.  https://hackage.haskell.org/package/ig-0.6.1 (cdepillabout)
09:32:52 <EvanR> partially applied?
09:33:14 <EvanR> oh you mean just having the matrix by itself
09:33:21 <hackrilege> hi crew, I just tried to install my project on a new machine and it broke horribly... could someone cabal install zebedde and see if it works for you?
09:33:31 <bennofs> mniip: in the category of vectors? really? I thought it would be in the category of natural numbers excluding zero, but perhaps that's isomorphic
09:33:35 <bitemyapp> Sindriav_: there is a way to uninstall packages but it's not what I would call a good idea.
09:34:00 <EvanR> mniip: right but matrices are kind of a sideshow to the theory of tensors
09:34:00 <Sindriav_> bitemyapp: Yeah, that's my point. Cabal broke waaay to easily before I knew what I was doing
09:34:49 <mniip> EvanR, but number arrays are irrelevant to tensors
09:34:50 <EvanR> mniip: a given morphism has many matrix representations
09:35:00 <bitemyapp> Sindriav_: yeah, although sandboxes helped a lot.
09:35:25 <mniip> it's a wrong intuition to have
09:35:27 <EvanR> mniip: thats what i was saying, matrix = number array
09:35:37 <Sindriav_> bitemyapp: Yeah, nowadays it's pretty easy. Though I still get worked up when I move a folder and all the hardcoded sandboxes break :D
09:35:54 <mniip> yes but
09:36:23 <mniip> matrices = linear maps = 2-tensors
09:36:40 <humanoyd> Is there a library for percent-encoding unicode in haskell?
09:36:42 <EvanR> you can represent a linear map with a matrix i wouldnt say =
09:37:31 <Welkin> bitemyapp: ghc-pkg unregister? :P
09:37:32 <mniip> it's an isomorphism, no?
09:37:46 <EvanR> once you pick a basis
09:37:50 <Welkin> it works well enough
09:37:52 <EvanR> that defines an isomorphism
09:37:59 <mniip> true
09:38:26 <bennofs> humanoyd: perhaps uri-encode?
09:39:26 <hackrilege> is there not the concept of an irriducable representation which would help?
09:39:32 <humanoyd> bennofs: That looks promising, thanks!
09:39:52 <ttt_fff> I am so confused aobut nixos
09:39:59 <ttt_fff> when using nix, should I be using cabal sandboxes ?
09:40:03 <ttt_fff> or should I just be installing everything globally
09:40:58 <mniip> [19:33] (bennofs) mniip: in the category of vectors? really? I thought it would be in the category of natural numbers excluding zero, but perhaps that's isomorphic
09:41:25 <mniip> including zero, but its kinda a different category
09:41:59 <bitemyapp> Welkin: yar
09:41:59 <bennofs> ttt_fff: no, you should not be using cabal sandboxes (except perhaps for it's add-source functionality to manage local source deps). You should also not be using cabal to install dependencies at all
09:42:19 <ttt_fff> bennofs: okay, can you point me at what to do read to figure out how to do all this?
09:42:34 <ttt_fff> becuase right now, I have no idea what I'm doing, and it's causing all types of weird, un-googleable errors
09:42:34 <bennofs> ttt_fff: https://nixos.org/nixpkgs/manual/#users-guide-to-the-haskell-infrastructure
09:43:59 <Welkin> I really need to try nix/nixos
09:45:21 <augustss> howdy
09:45:41 <Cale> hello!
09:48:38 <hackrilege> when I run cabal install for my package I get a base conflict... how do I resolve this!?
09:48:49 <hackrilege> try cabal install zebedde
09:49:06 <Cale> hackrilege: Install a different version of GHC, or edit the .cabal file and change the bound on base
09:49:07 <Gurkenglas> Why isn't there asumMap (= alaf Alt foldMap)?
09:49:08 <EvanR> if you dare!
09:49:22 <Shockk> hackrilege: it's depending on base 4.7.*
09:49:34 <Shockk> if you're on base 4.8 (which ghc 7.10 is on), it can't install
09:49:39 <hackrilege> ok
09:50:00 <hackrilege> so I need to edit the cabal file but I cant get the project from hackage
09:50:09 <athan> Gurkenglas: alaf?
09:50:30 <bennofs> :t alaf Alt foldMap
09:50:32 <lambdabot> forall (k :: BOX) (t :: * -> *) a (g :: k -> *) (b :: k). (Foldable t, Monoid (Alt g b)) => (a -> g b) -> t a -> g b
09:50:35 <bennofs> ugh
09:50:40 <bennofs> :t Alt
09:50:42 <lambdabot> forall (k :: BOX) (f :: k -> *) (a :: k). f a -> Alt f a
09:50:47 <athan> :o
09:50:47 <hackrilege> :t alaf
09:50:48 <Shockk> hackrilege: you can edit the cabal package file on hackage I think
09:50:50 <lambdabot> (Rewrapped s t, Rewrapped t s, Profunctor p) => (Unwrapped s -> s) -> (p r t -> e -> s) -> p r (Unwrapped t) -> e -> Unwrapped s
09:50:55 <Shockk> Maintainers' corner at the bottom
09:50:55 <athan> S_S
09:51:09 <hackrilege> ok thanks shocll ill try that
09:51:12 <bennofs> athan, hackrilege: alaf comes from the lens or from newtype package (lambdabot has it from lens)
09:51:18 <bennofs> it can be used like this:
09:51:40 <Gurkenglas> (I expected alaf Alt foldMap to produce a useful type :/)
09:52:09 <augustss> Is the name alaf supposed to tell me something?
09:52:12 <bennofs> > alaf Sum foldMap (+3) [1,2,3,4]
09:52:15 <lambdabot>  22
09:52:26 <hackrilege> which type did you think it would have gurkenglas?
09:52:28 <athan> that is awesome
09:52:45 <Gurkenglas> :t alaf Alt foldMap :: (Alternative f, Foldable t) => (a -> f b) -> t a -> f b -- asumMap, you see
09:52:47 <lambdabot> (Foldable t, Alternative f) => (a -> f b) -> t a -> f b
09:52:51 <bennofs> augustss: it comes from the french "à la" I think
09:52:59 <hackrilege> shock I cant find how to do that on hackage
09:53:20 <athan> Gurkenglas: Awesome find
09:53:27 <hackrilege> :t asumMap
09:53:29 <lambdabot> Not in scope: ‘asumMap’
09:53:34 <hackrilege> ofc
09:53:36 <bennofs> athan: if you don't like complicated types, you can also get if from the 'newtype' package
09:53:57 <athan> bennofs: !!! Okay, thank you
09:54:47 <bennofs> > ala Const 
09:54:49 <lambdabot>      No instance for (Typeable e0)
09:54:49 <lambdabot>        arising from a use of ‘show_M453695858527102877731599’
09:54:49 <lambdabot>      In the expression:
09:54:54 <athan> Quick question - is there an easy file-downloading library? I'd ideally like to just pipe the data to a new file, with all the file encodings etc. intact. My current method of http-client & bytestring has so far been unsuccessful, I have a feeling I'm missing a few headers
09:55:18 <Gurkenglas> Alt turns an applied alternative into a Monoid, alaf turns a function like foldMap into another like foldMap using the features of the provided wrapper by wrapping and unwrapping where needed
09:55:31 <bennofs> :t view
09:55:33 <lambdabot> MonadReader s m => Getting a s a -> m a
09:55:34 <bennofs> :t ala Const
09:55:36 <lambdabot> ((a' -> Const a' x') -> e -> Const a'1 x'1) -> e -> a'1
09:55:55 <Gurkenglas> (ala applies id afterwards, turning a function like foldMap into one like fold)
09:56:18 <bennofs> :t view `asTypeOf` ala Const `asTypeOf` view 
09:56:20 <lambdabot> Getting a' x' a' -> x' -> a'
09:56:29 <Gurkenglas> :t ala Alt foldMap :: (Alternative f, Foldable t) => t (f a) -> f a -- asum, you see
09:56:31 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
09:57:02 <bennofs> athan: I think that should work with bytestring + http-client
09:58:33 <athan> bennofs: Wait I think you're right, I didn't decompress the tar before extracting. Thank you!
09:59:07 <EvanR> tar isnt compressed!
09:59:17 <EvanR> maybe THATs your problem ;)
10:01:13 <Sindriav_> EvanR: It makes several files into a single one, which could count as compression (albeit very small), no?
10:01:15 <Sindriav_> :P
10:01:38 <Sindriav_> though I guess it still preserves that data, so it's probably bigger if anything
10:02:19 <MarcelineVQ> hey now, it's using two less filenames
10:02:20 <EvanR> > concat [[1],[2],[3]]
10:02:22 <lambdabot>  [1,2,3]
10:02:25 <EvanR> youre right
10:02:59 <Gurkenglas> bartavelle, http://lpaste.net/142360
10:04:27 <emmanuel_erc> hello again... Lazy evaluation is rearing its ugly head  at me. How can I force evaluation without resorting to complier optimizations in a sensible way?
10:04:51 <athan> emmanuel_erc: There's `force` from DeepSeq
10:05:02 <xandaros> seq?
10:05:09 <EvanR> you might want to use bang patterns, strict record fields, and seq
10:05:24 <EvanR> depending on the situation
10:05:31 <EvanR> probably not deepseq
10:05:49 <emmanuel_erc> Thank you! Do you mind if I post my little snippet of code?
10:06:08 <julianleviston> emmanuel_erc: not only do we not mind, we prefer it! :) lol
10:06:13 <emmanuel_erc> "(\x -> Data.List.zip3 x [0..534] x) (buildGraph 10 images)"
10:06:27 <Shockk> tar does count as compression kind of, depending on the filesystem; on some filesystems directories and files will take up a certain size
10:06:39 <emmanuel_erc> buildGraph is building a list of contexts. If you are familiar with the fgl package, you'll know wahat that means.
10:06:40 <Shockk> like 4096 bytes for dirs I think
10:07:16 <emmanuel_erc> I realize that haskell is only computing enough of the argument to the lambda expression for each zip operation.
10:08:22 <EvanR> whats the problem
10:08:53 <emmanuel_erc> When I run that piece of code, it is building the list I need too slowly
10:08:54 <julianleviston> emmanuel_erc: this is obviously effectful? just wrap it in seq () (note seq takes two args)
10:08:58 <julianleviston> oh
10:09:36 <julianleviston> emmanuel_erc: why is laziness (apparently) at play here?
10:09:37 <EvanR> im not sure lazy evaluation is the blame for that code running too slowly
10:09:51 <emmanuel_erc> (maybe I am just a bad coder)
10:09:53 <emmanuel_erc> lol
10:10:26 <EvanR> what does buildGraph do
10:10:27 <julianleviston> emmanuel_erc: what context are you running this in? ghci?
10:12:45 <hackrilege> I still have a problem with my cabal source file. I have changed the base dependency to include 3.8, but it still wont work
10:15:46 <cocreature> hackrilege: base 3.8 is ancient, you probably want 4.8, besides what's the error?
10:17:26 <hackrilege> oh ok it looks like cabal update was jamming. yes sorry its 4.8 not 3.8
10:19:23 <emmanuel_erc> hello theer
10:19:25 <emmanuel_erc> there
10:19:40 <emmanuel_erc> My emacs decided to blurp and then fall on its head.
10:19:52 <Rembane> emmanuel_erc: How?
10:20:38 <emmanuel_erc> I am not sure.
10:20:52 <Ankhers> emmanuel_erc: What is not working correctly?
10:20:57 <emmanuel_erc> I only have issues with haskell on my laptop however.
10:21:37 <Rembane> Any error messages?
10:21:43 <Rembane> Or strange noises?
10:21:47 <emmanuel_erc> I wasn't even in my haskell file's buffer. I was in IRC chatting and then everything just froze.
10:21:54 <emmanuel_erc> No error messages.
10:22:08 <emmanuel_erc> I had to kill my emacs from htop.
10:22:15 <Rembane> IRC and Haskell are sadly enough incompatibla on laptops.
10:22:20 <Ankhers> emmanuel_erc: So are things working correctly?
10:22:50 <emmanuel_erc> Ankhers: As far as I know right now, everything seems fine.
10:23:34 <emmanuel_erc> Rembane: I am running IRC in Emacs... are you saying Haskell and IRC don't get along in many cases?
10:24:04 <Ankhers> emmanuel_erc: I believe it was a joke. I use Haskell and ERC everyday.
10:24:34 <emmanuel_erc> Ok... I should have taken the hint when he asked about strange noises..
10:24:40 <emmanuel_erc> he/she*
10:27:02 <Rembane> emmanuel_erc: It was indeed a joke. :)
10:27:09 <athan> Agh wtf, haskell-src-exts module parser keeps failing for me, claiming I'm using TemplateHaskell when I'm not :(
10:29:14 <pikajude> have you misplaced a $ somewhere?
10:29:53 <athan> I don't think so, it compiles fine with ghc / stack / cabal-install :(
10:30:03 <pikajude> :(
10:30:32 <athan> pikajude: It's yelling on the first line >.>
10:30:50 <pikajude> i thought the templatehaskell parse error normally did that?
10:30:54 <pikajude> it's been awhile since I used that parser. maybe not
10:31:20 <athan> I'm not sure. Maybe it's because I have language extensions enabled, without needing them, maybe?
10:31:38 <athan> I'm trying it with acme-io, which has no $ anywhere
10:32:53 * hackagebot dywapitchtrack 0.1.0.0 - Bindings to the dywapitchtrack pitch tracking library  https://hackage.haskell.org/package/dywapitchtrack-0.1.0.0 (lortabac)
10:32:55 * hackagebot pitchtrack 0.1.0.0 - Pitch tracking library  https://hackage.haskell.org/package/pitchtrack-0.1.0.0 (lortabac)
10:34:38 <orion> Is there a way for cabal to only rebuild cbits which haven't changed? I get the sense that it's compiling from scratch every time.
10:35:09 <julianleviston> orion: doesn’t stack do diff-only builds?
10:35:16 <julianleviston> orion: sorry, I know that’s not what you were asking.
10:35:38 <orion> Is stack the new thing now?
10:36:00 <wedens> I'm writing csv parser using attoparsec. but csv format is not typical. strings are not quoted and fields separator inside string is escaped. how can I write parser for a field with escaped separator? 
10:40:56 <matsuura> I'm not on mushrooms today
10:41:36 <orion> matsuura: Drugs r bad mmkay
10:41:57 <matsuura> they're 100% organic, non-gmo
10:42:16 <matsuura> no artificial additives or anything like that
10:42:17 <julianleviston> matsuura: just like arsenic
10:42:30 <matsuura> except arsenic will kill you o_o
10:42:30 <jstimpfle> wedens: just go through the file and remember whether you are currently escaped or not?
10:42:54 * hackagebot yesod-crud-persist 0.2.1 - Flexible CRUD subsite usable with Yesod and Persistent.  https://hackage.haskell.org/package/yesod-crud-persist-0.2.1 (andrewthad)
10:44:05 <athan> Can someone help me diagnose why my hackage fetching & parsing is failing? Haskell-src-exts seems to be the culprit - apparently everything needs TemplateHaskell enabled or something - https://github.com/athanclark/hackage-use
10:44:55 <athan> The current commit compiles fine, and going into `stack ghci` and issuing `haskellModuels "acme-io" (HackageVersion [0,1,0,1])` will show you what I'm seeing
10:45:08 <athan> (shoot, you might need to delete the acme-0.1.0.1 folder in tmp/`
10:46:18 <Gurkenglas> ghc-mod doesn't build for me on Windows due to the old-time package not building. Has anyone on Windows solved that problem (or even just didn't have it?)
10:48:07 <julianleviston> athan: I don’t understand how you can import 4 things qualified as the same name “X” ...
10:48:26 <julianleviston> athan: in Fetch.hs
10:48:46 <julianleviston> athan: sorry, not qualified, aliased.
10:50:03 <julianleviston> athan: call me a noob, but in Fetch/Cabal.hs, don’t you need a $ here? hackagePackageDescription packageName vs = do
10:51:08 <nitrix> It's an simple teenager trick. You add a lowercase and uppercase X prefix and suffix to every words. It makes you instantly cooler and works with every language.
10:51:39 <athan> julianleviston: NOOB! :P
10:51:40 <julianleviston> athan: actually, there are a couple of missing $’s… assuming I understand when to use them before do...
10:51:41 <nitrix> xXjulianlevistonXx: ^
10:51:44 <julianleviston> athan: hehe :)
10:51:47 <julianleviston> nitrix: so pretty :)
10:51:48 <athan> it compiles, right? :v
10:51:57 <HaskUsr> Hello
10:52:01 <julianleviston> athan: I dunno, I’m not compiling it. Sorry.
10:52:08 <HaskUsr> Can anybody help me
10:52:08 <athan> nitrix++
10:52:12 <HaskUsr> ??
10:52:23 <julianleviston> HaskUsr: not unless you tell us more :)
10:52:56 <julianleviston> athan: why don’t you need a $ before the do? That’s so confusing to me...
10:53:07 <HaskUsr> i have problem loading a .hs into my ghci
10:53:21 <julianleviston> HaskUsr: tell us more… :)
10:53:27 <athan_> >.> wifi
10:53:33 <HaskUsr> but with other pc and same code i was able to load it fine
10:54:48 <julianleviston> HaskUsr: what error? is the file in the same relative spot in your project dirctory? what are you using to load it? (what command)
10:54:49 <HaskUsr> julianleviston, i you want i can send you the code so u can check it out
10:55:03 <julianleviston> HaskUsr: use pastie.
10:55:29 <julianleviston> but your code won’t explain the answers to those questions
10:55:36 <HaskUsr> :l Main.hs 
10:55:38 <HaskUsr> Main.hs:5:8:
10:55:40 <HaskUsr>     Could not find module `HGUI.Gui'
10:55:42 <HaskUsr>     Use -v to see a list of the files searched for.
10:55:44 <HaskUsr> Failed, modules loaded: none.
10:56:05 <HaskUsr> ?? pastie??
10:56:05 <lambdabot>  pastie
10:56:15 <orion> Hey, does anyone know why the output of this code does not meet my expectations?: http://lpaste.net/4027471720578285568
10:56:39 <MarcelineVQ> Are your expecations too high?
10:57:00 <orion> Calling "increment" on "\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL" gives me "\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL", but my expectation is that it would give me "\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\SOH"
10:57:04 <athan> bennofs: Can you show me your alaf example one last time? Sorry, my session got wiped
10:58:00 <bennofs> > alaf Sum foldMap (+3) [1,2,3,4] -- this one athan ?
10:58:02 <lambdabot>  22
10:58:13 <athan> Yep :) Thanks bennofs
11:00:33 <fabian___> Anyone here who has  familiarity with IxSet?
11:01:23 <osfamero1> fabian___: not I, but you're best off asking the actual question you wanted to ask in any case :-)
11:02:14 <fabian___> I have a IxSet in a acid-state db, and the size just keeps growing. If i rebuild the IxSet (fromList . toList) then the size behaves as expected
11:02:34 <fabian___> is there  some internal cache used by IxSet, or is this a bug?
11:02:54 * hackagebot aeson-extra 0.2.1.0 - Extra goodies for aeson  https://hackage.haskell.org/package/aeson-extra-0.2.1.0 (phadej)
11:03:05 <dfeuer> Hmm... nice ...:  arrowNotBifunctor :: Bifunctor (->) :- c ; blah = Sub $ bimap (const ()) id id ()
11:03:12 <dfeuer> er..
11:03:19 <dfeuer> Hmm... nice ...:  arrowNotBifunctor :: Bifunctor (->) :- c ; arrowNotBifunctor = Sub $ bimap (const ()) id id ()
11:04:36 <bennofs> oh, cool :p
11:05:57 <trubar68> Why does `$ ghc -ddump-simpl foo.hs` return no output for me?
11:06:09 <trubar68> I want to the GHC core for my compiled Main module.
11:06:37 <cchalmers> trubar68: does it work if you add -fforce-comp ?
11:06:50 <cchalmers> * -fforce-recomp
11:07:06 <trubar68> cchalmers: nailed it, thanks.
11:07:15 <trubar68> (that was the problem)
11:07:54 * hackagebot http-types 0.9 - Generic HTTP types for Haskell (for both client and server code).  https://hackage.haskell.org/package/http-types-0.9 (AristidBreitkreuz)
11:08:19 <monochrom> you can also add -ddump-to-file. then the output will be in foo.dump-simpl
11:08:37 <shachaf> Except for a few things that ignore -ddump-to-file, I think.
11:08:47 <shachaf> You also lose ordering information with -ddump-to-file.
11:11:59 * athan leaves this here: http://stackoverflow.com/questions/32955109/haskell-src-exts-throws-templatehaskell-error
11:24:37 <athan> Gurkenglas: How are `ala` and `alaf` related, again? Sorry, I just can't get Lens to compile :\
11:25:28 <bitemyapp> athan: using Stack?
11:25:59 <athan> bitemyapp: hm?
11:26:22 <bitemyapp> athan: alaf is f -> g, ala is a more ordinary iso/lens'ish thing I think.
11:26:42 <athan> :S
11:27:06 <athan> bitemyapp: Oh, then yes, using stack. I couldn't seem to get all the dependencies resolved, the lens-examples is using an older version of mtl or something
11:27:22 <bitemyapp> athan: http://hackage.haskell.org/package/newtype-0.2/docs/Control-Newtype.html#v:ala-39-
11:27:41 <bitemyapp> athan: anything in lens that references prior art, usually you have to look at the prior art to learn how it is supposed to work
11:28:17 <athan> bitemyapp: :) thanks
11:29:05 <bitemyapp> athan: np.
11:30:43 <athan> Mer. Haskell-src-extensions was working for a minute, now it's not including MultiParamTypeClasses :(
11:37:56 * hackagebot hastily 0.1.0.4 - A program to download subtitle files.  https://hackage.haskell.org/package/hastily-0.1.0.4 (sras)
11:38:00 <Gurkenglas> athan, alaf takes a function "with a hook" like foldMap, composes its first argument to the left of the hook, and composes the inverse of its first argument to the left of the foldMap
11:38:42 <Gurkenglas> That way, you can "pretend" to have features of a newtype without having anything wrapped before or after
11:39:09 <athan> Gurkenglas: Ahh! Because all newtypes are isos!
11:39:11 <athan> that's too cool
11:39:11 <Gurkenglas> ala also discards the hook at the end, because most of the time you don't need one
11:40:21 <Gurkenglas> (It doesn't actually work with any newtype, just the ones with Wrapped instances, which it defines for all newtypes in base, and which you can derive using deriveWrapped with TH)
11:40:47 <Gurkenglas> (The up side: There's also some wrapped instances for stuff that isn't a newtype)
11:40:56 <athan> Gurkenglas: Ahh, okay. Hm!
11:41:55 <Gurkenglas> (There's an alternative called auf/au that takes an actual iso (its like a lens but with an inverse))
11:42:45 <Gurkenglas> > ala ZipList traverse [[1,2], [1,2,3], [1,2]]
11:42:46 <lambdabot>  [[1,1,1],[2,2,2]]
11:43:07 <Gurkenglas> > ala S.fromList id [1,2,3,3,4,2,7]
11:43:08 <lambdabot>  [1,2,3,4,7]
11:43:52 <athan> o_o
11:46:01 <Gurkenglas> :t (ala MaybeT . alaf Alt) foldMap
11:46:02 <lambdabot> (Monad n, Foldable t) => t (n (Maybe b)) -> n (Maybe b)
11:46:39 <athan> Gurkenglas: Do you happen to know the name of Connor McBride's paper / related work in this?
11:46:46 <Gurkenglas> nope
11:47:01 <Gurkenglas> It says in I think lens's docs that it was from his work on Epigram?
11:47:02 <ReinH> @hackage newtype
11:47:02 <lambdabot> http://hackage.haskell.org/package/newtype
11:47:17 <ReinH> Yes, based on Epigram
11:47:41 <athan> Ahh, okay. Thank you
11:52:34 <Gurkenglas> > (2, "abc") & alaf Compose _2 %~ uncons
11:52:36 <lambdabot>  Just (2,('a',"bc"))
11:52:56 * hackagebot yesod-bootstrap 0.2.1 - Bootstrap widgets for yesod  https://hackage.haskell.org/package/yesod-bootstrap-0.2.1 (andrewthad)
11:54:03 <aweinstock> :t getCompose
11:54:04 <lambdabot> Compose f g a -> f (g a)
12:04:58 <dfeuer> If the Arrow class is as busted as it seems, why's it still going and going?
12:10:02 <ttt_fff> anyone here using hdevtools with NIX ?
12:10:11 <ttt_fff> hdevtools can't find ANY of the packages nix has instlaled
12:12:15 <dolio> dfeuer: Why is Array still around?
12:12:55 <mniip> dolio, do you have a problem with Array/
12:13:00 <dfeuer> dolio, well, it's still around for backwards compatibility. But unlike Arrow, no one thinks it's a good idea to build an API around Array.
12:13:22 <dfeuer> mniip, it's silly. The whole Ix thing is mostly pain.
12:13:24 <dfeuer> And
12:13:42 <dfeuer> the way Array is tied to lists makes it pretty much unusable for many sensible things.
12:18:27 <happyfree> :-D Started learning Haskell a few weeks ago. It's great!
12:19:12 <mniip> dfeuer, who
12:19:15 <mniip> whoa*
12:19:26 <dfeuer> mniip, eh?
12:19:52 <EvanR> whats wrong with lists, isnt that just standard carrier for control flow in haskell
12:19:56 <mniip> I have to agree, array/listArray make arrays pretty dumb
12:20:20 <mniip> should have an '(i -> e) -> Array i e' at least somewhere
12:20:47 <EvanR> what are the dimensions of the resulting array?
12:21:11 <mniip> (i, i) -> (i -> e) -> Array i e
12:21:21 <dfeuer> IIRC, you basically can't build an Array except from a list.
12:21:37 <dfeuer> Unless you use non-standard stuff.
12:22:26 <mniip> dfeuer, although, building an array has always been O(N)
12:22:32 <EvanR> so youd rather there be a new primitive which has the same functionality but is in some sense gauranteed to be faster because its avoiding a list node
12:22:50 <dfeuer> I don't remember all the problems.
12:23:08 <EvanR> the margin is too small to fit all the problem ;)
12:23:13 <mniip> EvanR, well Array is an array of closures, it's not obvious how it relates to a linked list of whatever
12:23:25 <dfeuer> Another issue is that the way Array stores its bounds is unfortunate.
12:23:57 <CpnStumpy> is attoparsec still the defacto standard for parsing in Haskell? Is it worth the hassle to learn one of the HTML parsing libs to do a simple page scraping utility when I've worked with attoparsec before?
12:24:21 <mniip> wouldn't be parsec instead?
12:24:26 <mniip> wouldn't that be*
12:24:27 <EvanR> mniip: of closures?
12:24:44 <EvanR> CpnStumpy: ive heard good things about trifecta
12:24:52 <arkeet> don't we have html scraping libraries?
12:24:56 <mniip> EvanR, of heap pointers, yeah
12:25:08 <mniip> let's disregard the GC card for now
12:25:11 <CpnStumpy> mniip: I don't know, last I checked attoparsec was the newer more performant choice from BoS deciding to improve over parsec
12:25:11 <EvanR> mniip: ... what? 
12:25:21 <CpnStumpy> unless I'm remembering all wrong
12:25:57 <EvanR> mniip: an array of boxed values, so like, thunks or whnfs, but closures seems like extra fast and loose
12:26:37 <hiptobecubic> CpnStumpy, i think it's a tradeoff, like whether or not you want reasonable error messages.
12:26:40 <EvanR> closures has been abuse enough that it might not denote anything in particular anymore
12:26:41 <CpnStumpy> arkeet: I'm sure there are some, but is it worth figuring out how to operate them when I already know how to just create a mindless parser to get my info? I'm specifically parsing HTML API documentation to create an AST for the API (code generation from the ast later, but that parts easy)
12:26:54 <mniip> EvanR, closure is the operational unit of STG machine
12:27:15 <EvanR> right
12:27:28 <CpnStumpy> hiptobecubic: Not really, this is going to be run only when the 3rd party service updates their API and I want to regenerate a client (basically they have HTML docs for their API and nothing more - but they have a standard format)
12:27:30 <EvanR> yet another kind of closure ;)
12:28:25 <EvanR> so i still dont see the issue with Array
12:28:34 <CpnStumpy> I'll look at trifecta I suppose and see if it looks straightforward enough to be worth using
12:28:47 <mniip> yeah, lists seemed like an issue at first
12:28:57 <dfeuer> I've not done much with parsing, but attoparsec seems easier to use and better from at least some performance standpoints; Parsec is supposedly better for error handling but feels weird.
12:28:59 <mniip> but they're merely a terrible annoyance
12:29:46 <EvanR> luckily you wouldnt really want to reach for them normally
12:30:12 <CpnStumpy> dfeuer: They're both relatively similar, just slight semantic differences because attoparsec heavily pushes you towards no backtracking and a few combinator choices that are different
12:30:19 <monochrom> megaparsec is also an option
12:30:33 <CpnStumpy> monochrom: newer?
12:30:41 <monochrom> it is new
12:30:48 <dfeuer> CpnStumpy, attoparsec always backtracks, doesn't it? While Parsec pushes you not to?
12:31:12 <pharaun> somehow it feels like its the other way around
12:31:25 <ttt_fff> https://gist.github.com/anonymous/104bb5b8ae47416ecb2c why does hdevtools not work on nix
12:32:24 <CpnStumpy> dfeuer: Perhaps I'm confusing it; but I recall attoparsec being lazier which is where a portion of it's performance comes from - but to be lazier it asks you to go down less choices you'll cull, and pushes you to char parsers for cases where it may backtrack so it consumes less before backtracking
12:32:53 <dfeuer> CpnStumpy, perhaps? I don't understand some of this well enough.
12:32:57 <CpnStumpy> (this is my admittedly vague understanding as someone who only fidgets with this stuff and is likely often wrong)
12:33:43 <CpnStumpy> monochrom: I'll look at that one since I haven't touched attoparsec in years; may be newer stuff with improvements now..
12:35:18 <dfeuer> CpnStumpy, https://hackage.haskell.org/package/attoparsec-0.13.0.1/docs/Data-Attoparsec-Internal-Types.html#t:Parser suggests lots of backtracking.
12:36:35 <mniip> [22:29:54] <monochrom> megaparsec is also an option
12:36:39 <mniip> when is exaparsec coming out
12:37:12 <isomorphismes> What happens when I try take 3 . reverse $ [1..] ?
12:37:19 <CpnStumpy> dfeuer: unless I'm mistaken, parsec has backtracking as well, it just uses explicit `try`s for itscaleb
12:37:25 <dfeuer> isomorphismes, what do you think?
12:37:25 <mniip> isomorphismes, you get bottom
12:37:26 <isomorphismes> Or reverse [1..] for that matter...
12:37:27 <hpc> isomorphismes: what's the last element of that list?
12:37:32 <isomorphismes> ∞
12:37:40 <dfeuer> No.
12:37:50 <dfeuer> isomorphismes, ∞ is not in that list.
12:37:52 <isomorphismes> haha. ok =) So what is it?
12:38:02 <dfeuer> It doesn't have one.
12:38:05 <hpc> isomorphismes: imagine you're the computer, how would you get to the end of the list?
12:38:25 <isomorphismes> hpc: well, if I were doing things, I would have a +∞ symbol at the end
12:38:28 <aweinstock> @src reverse
12:38:28 <lambdabot> reverse = foldl (flip (:)) []
12:38:39 <aweinstock> @src foldl
12:38:39 <lambdabot> foldl f z []     = z
12:38:39 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:38:43 <isomorphismes> aweinstock: ah ok. I'll have to look up foldl and flip
12:38:55 <CpnStumpy> isomorphismes: `+` isn't a valid `Num` instance
12:39:03 <dfeuer> [1..] ++ [1..] = [1..]
12:39:05 <aweinstock> flip (:) is just (\x y -> y : x)
12:39:10 <hpc> isomorphismes: but you don't know that, all you have is a list
12:39:17 <dfeuer> [1..] ++ undefined = [1..]
12:39:24 <isomorphismes> CpnStumpy: hmm?
12:39:25 <hpc> or to put it another way, what if the list was alternating [1, -1, 1, -1, 1, -1, ...]
12:39:29 <hpc> what's the last element?
12:39:40 <dfeuer> isomorphismes, you'd have a ∞ symbol *where*?
12:39:45 <hpc> and how do you mechanically distinguish between them?
12:39:47 <monochrom> mniip: when megaparsec also becomes unmaintained, and someone forks it
12:39:51 <aweinstock> > last (cycle [1, -1])
12:39:54 <dfeuer> hpc++
12:39:56 <lambdabot>  mueval: ExitFailure 1
12:40:08 <CpnStumpy> ismorphismes: implement reverse in Haskell and see what it has to find before it stops iterating the list
12:40:27 <hpc> (haskell can do many things, but it's still a programming language and not wizard tesla's lightning generator frankenstein machine)
12:40:51 <CpnStumpy> hpc: I disagree on your second point there, but reverse still has to fully iterate a list
12:41:00 * monochrom prefers tesla's electrifying cloning machine
12:41:11 <dfeuer> @remember hpc Haskell can do many things, but it's still a programming language and not Wizard Tesla's lightning generator Frankenstein machine.
12:41:11 <lambdabot> I will remember.
12:41:12 <hpc> that's actually bowie, but easy mistake to make
12:41:19 <monochrom> heh
12:41:22 <isomorphismes> dfeuer: not sure. You could have it be bumped away every time someone "pops" if you know what I mean? I'm just talking about the mathematician's "formal ∞".
12:41:42 <hpc> monochrom: tesla was having an off day and he was the understudy ;)
12:41:47 <isomorphismes> Probably for things to work like I'm thinking a lot of other stuff would have to be rewritten. I don't really know how [1..] works, is I guess really te issue.
12:41:51 <aweinstock> isomorphismes: infinity isn't a natural number
12:42:11 <hpc> isomorphismes: understand that first, then
12:42:19 <CpnStumpy> aweinstock: there's nothing unnatural about an 8 that got drunk and fell down
12:42:20 <dfeuer> isomorphismes, ah, well, we have a symbol for a certain sort of "formal ∞" we use for this, called ⊥
12:42:39 <aweinstock> CpnStumpy: data Nat = Z | S Nat
12:42:42 <hpc> isomorphismes: you'll find that everything about haskell is perfectly mechanical and clever design decisions have simply enabled a lot of things that appear to be magic
12:42:56 <dfeuer> It represents non-termination and exceptional conditions.
12:43:00 <hpc> and it's important to know anyway
12:43:12 <isomorphismes> And [1..] ++ [1..] == [1..]  tries to go through and check each thing?
12:43:27 <isomorphismes> aweinstock: thanks
12:43:44 <hpc> isomorphismes: the list type is a singly linked list
12:43:47 <monochrom> list equality doesn't stop for infinite lists
12:43:50 <hpc> the empty list is [], and cons is (:)
12:43:52 <aweinstock> isomorphismes: ([1..] ++ [1..] == [1..]) isn't intended as a piece of code to execute (it'd take forever to run)
12:44:00 <dfeuer> I didn't write ==. I wrote =. Those are different.
12:44:01 <isomorphismes> dfeuer: I don't understand how to put [1..] + undefined == [1,..] for testing
12:44:11 <hpc> [1,2,3] is really 1 : (2 : (3 : []))
12:44:20 <hpc> and [1..] is more or less similar
12:44:23 <dfeuer> You don't ask Haskell that. You have to reason it out for yourself.
12:44:27 <aweinstock> isomorphismes: it means "there is no algorithm that can distinguish ([1..] ++ [1..]) from ([1..])"
12:44:28 <isomorphismes> dfeuer: Yeah, but when I typed in with literally = it said <interactive>:5:17: parse error on input ‘=’
12:44:29 <CpnStumpy> aweinstock: data Nat = Eight (Natty Light -> Nat) | EightFallDown
12:44:47 <dfeuer> isomorphismes, that's because it was an equation; not Haskell code.
12:45:00 <hpc> isomorphismes: you can use ghci and :set +s (iirc) to view what parts of a list get evaluated when
12:45:05 <hpc> so [1..] starts out as _
12:45:13 <dfeuer> But Haskell code *looks* like a bunch of equations for a very good reason.
12:45:19 <hpc> and then you check against the first element and it's now 1 : _
12:45:29 <hpc> then 1 : 2 : _
12:45:31 <aweinstock> CpnStumpy: I have a vague suspicion that has to do with type-level calculations, but the joke is above my head
12:45:38 <isomorphismes> hpc: how do you mechanically distinguish between 8 in [1..8] and +∞ in [1..] ? I dunno enough about computer insides to guess at what would be needed to "mechanically distinguish" any two things.
12:45:41 <hpc> and you can keep going but you'll never get to that []
12:45:55 <hpc> which is what reverse looks for before it can begin producing a reversed list
12:46:07 <monochrom> I think EightFallDown refers to ∞
12:46:19 <CpnStumpy> dfeur: To ensure if I show any colleagues it and say "Look, we could write lean concise stuff like this!" they'll laugh at me?
12:46:23 <dfeuer> In a very real sense, Haskell solves equations for you. In particular, if you give it a set of equations, it gives back the worst possible solution.
12:46:43 <hpc> @src reverse
12:46:43 <lambdabot> reverse = foldl (flip (:)) []
12:46:47 <hpc> >:(
12:46:53 <monochrom> heh worst possible solution
12:47:08 <aweinstock> monochrom: I got that part, but I don't know what the significance of Eight or Light are (I know Natty is conventionally used to "lift" a type-level nat to value-level or something like that)
12:47:19 <monochrom> I don't know either
12:47:42 <isomorphismes> CpnStumpy: I don't know how to implement reverse in haskell. other than copying the code from @src reverse.
12:48:00 <drmoob> http://lpaste.net/5184665025427537920 will it not re-use any previous value in the tree? multiple ways can lead to the same outcome futher down the tree, I want to use memoization so I don't have to traverse that branch again
12:48:16 <CpnStumpy> isomorphismes: Well then you should try. Go open a haskell file and try to figure it out - use pattern matching and recursion, not particularly difficult. You'll learn something valuable.
12:49:18 <aweinstock> > let {rev = f [] where {f acc [] = acc; f acc (x:xs) = f (x:acc) xs}} in rev [1..5]
12:49:19 <lambdabot>  [5,4,3,2,1]
12:49:31 <hiptobecubic> aweinstock, spoilers
12:49:33 <phaazon> hey, I’m looking for advices
12:49:44 <hpc> that's not even a good spoiler!
12:49:49 <isomorphismes> aweinstock: well, all of these mathemaical definitions are really up in the air. Just adjoin ∞ to ℕ, done.
12:50:10 <phaazon> I know how to change the behavior of a function regarding a type in the function (via typeclasses)
12:50:19 <phaazon> but I’m looking for a way to do that without typeclasses
12:50:29 <phaazon> with GADTs, especially
12:50:34 <phaazon> or whatever suits the most
12:50:53 <isomorphismes> hpc: "understand" in the imperative mood is not helpful.
12:51:38 <aweinstock> isomorphismes: ∞ isn't in ℕ, but [1..] is in [ℕ]
12:51:54 <aweinstock> @src []
12:51:54 <lambdabot> data [] a = [] | a : [a]
12:52:18 <hpc> phaazon: perhaps you want to use a sort of proxy GADT thing?
12:52:19 <isomorphismes> dfeuer: ah ok, so ⊥ is what mniip meant by "bottom" ?
12:52:30 <aweinstock> isomorphismes: yes
12:52:36 <hpc> data Proxy a where IntProxy :: Proxy Int, StringProxy :: Proxy String, ...
12:52:42 <hpc> foo StringProxy = "yes"
12:52:46 <hpc> foo IntProxy = 42
12:52:56 <dfeuer> isomorphismes, yes. There's also a "top", which shows up in order and lattice theory but not in Haskell.
12:52:56 <phaazon> no that’s not what I meant
12:53:35 <phaazon> hpc: http://lpaste.net/5968883975882539008#line39
12:53:43 <aweinstock> isomorphismes: "bottom", in the context of haskell, means something that throws an exception or loops forever (or otherwise fails to return an answer, but I think those are the only two ways)
12:53:45 <phaazon> I’d like to able to create a function « createTexture »
12:53:59 <aweinstock> > undefined
12:54:00 <isomorphismes> Is there a way to print the source of a function, like show flip or something?
12:54:00 <lambdabot>  *Exception: Prelude.undefined
12:54:07 <isomorphismes> from GHCI
12:54:07 <phaazon> and call the right constructor regarding the returned type
12:54:08 <phaazon> like
12:54:09 <aweinstock> @src flip
12:54:09 <lambdabot> flip f x y = f y x
12:54:15 <arkeet>  @src lies.
12:54:16 <phaazon> createTexture :: TextureBase -> Texture tk tl tf
12:54:28 <phaazon> or…
12:54:29 <bitemyapp> isomorphismes: in GHCi, not really. :info is about it.
12:54:30 <aweinstock> lambdabot has some functions, but not others
12:54:30 <CpnStumpy> isomorphismes: You have to remember, computers can only represent an unbounded set, they can't *construct* one. [1..] can pretend to be an unbounded until you reach for the bound which reverse does. Computers are limited.
12:54:31 <hpc> oh, i see
12:54:33 <monochrom> I don't think it is useful to bring up bottom, until you also say how to obtain bottom.
12:54:33 <phaazon> I guess I should simply pass a function
12:54:34 <phaazon> like
12:54:42 <phaazon> (TextureBase -> Texture t k f)
12:54:46 <bitemyapp> isomorphismes: @src is specific to lambdabot. Could use Hoogle.
12:54:46 <phaazon> and that would solve everything
12:54:50 <hpc> :t ala
12:54:51 <lambdabot> (Rewrapped s t, Rewrapped t s) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
12:55:01 <isomorphismes> bitemyapp: thanks
12:55:05 <aweinstock> monochrom: this started with a discussion of (reverse [1..])
12:55:05 <hpc> hmm no, that trick uses type classes too
12:55:10 <phaazon> no, it doesn’t
12:55:24 <dfeuer> aweinstock, with unsafePerformIO, you can get more bottoms, such as setting off an explosion that destroys the computer and thus prevents the computation from completing.
12:55:39 <phaazon> createTexture :: (TextureBase -> Texture t l f) -> TextureBase -> IO (Texture t l f)
12:55:46 <phaazon> createTexture Texture1D
12:55:47 <phaazon> bim.
12:56:01 <monochrom> ok yeah but "why reverse [1..] = bottom" is equivalent to "why reverse [1..] is an infinite loop"
12:56:12 <aweinstock> dfeuer: using Foreign.Storable.poke to cause GHC to segfault counts as bottom?
12:56:13 <EvanR> dfeuer: i hate it when that happens
12:56:17 <bitemyapp> isomorphismes: I find the hoogle baked into Stackage to be most useful: https://www.stackage.org/lts-3.8
12:56:22 <aweinstock> s/GHC/the GHC runtime/
12:56:23 <bitemyapp> isomorphismes: but I mostly use libraries in Stackage.
12:56:31 <isomorphismes> aweinstock: define "algorithm"? And we're really talking about "the output of [1..] ++ [1..]" versus "the output of "1..]", right?
12:56:50 <bitemyapp> isomorphismes: I follow you on twitter don't I?
12:56:55 <isomorphismes> dfeuer: Sorry, responded before catching up to your comments.
12:56:57 <dfeuer> monochrom, bottom only makes sense when you start to talk about least fixed points.
12:57:18 <bitemyapp> dfeuer: lets not.
12:57:18 <dfeuer> Which is why I think it makes a lot of sense to talk about least fixed points :-)
12:57:32 <bitemyapp> dfeuer: this is a beginner that needs to understand what people mean when they say the word "bottom", that's it.
12:57:34 <hpc> phaazon: fortunately your constructors all have the same sort of arguments
12:57:44 <bitemyapp> dfeuer: prescriptivism has no functional place here.
12:57:44 <dfeuer> bitemyapp, the operational semantics of Haskell are not particularly trivial either
12:57:48 <phaazon> hpc: yeah, that’s the idea
12:57:52 <bitemyapp> dfeuer: again, doesn't matter in this context.
12:58:02 <dfeuer> bitemyapp, what's prescriptivism have to do with anything?
12:58:09 <isomorphismes> aweinstock: ah sorry, I was reading "+" instead of "++". I understand you now, my bad
12:58:34 <mniip> [22:54:08] <CpnStumpy> isomorphismes: You have to remember, computers can only represent an unbounded set, they can't *construct* one. [1..] can pretend to be an unbo
12:58:36 <aweinstock> > zipWith (+) [1..] [1..]
12:58:37 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
12:58:38 <mniip> but what about predicative sets
12:58:54 <mniip> sure, you cannot enumerate them, but you can construct them!
12:59:01 <hpc> phaazon: the tricky part i anticipate is being able to get useful information out of the result type once you're done, though i suppose that's what subsequent GADT matches will do for you anyway
12:59:04 <hpc> so that point is moot
12:59:08 <aweinstock> isomorphismes: it makes sense to do some calculations with infinite lists, reverse isn't one of them
12:59:12 <dfeuer> isomorphismes, you're thinking about [1..] as a data structure, but it's not one.
12:59:16 <monochrom> mniip: that looks like mincing the words "represent" and "construct" to me.
12:59:29 <dfeuer> Well, it can be *represented* by one, yes.
12:59:30 * hpc gtg
12:59:41 <dfeuer> But you don't have to think about the representation of [1..] to reason about it.
12:59:42 <monochrom> and both words weasel out of the real issue
13:00:05 <dfeuer> [1..] = fix (1:) 
13:00:11 <bitemyapp> see, this is why I started the other channel.
13:00:12 <dfeuer> That's the end of it.
13:00:14 <monochrom> the real issue is always the API issue: what operations are supported (and at what cost), and what operations are not supported
13:00:20 <phaazon> hpc: thanks anyway :)
13:00:26 <dfeuer> bitemyapp, you seem to be confusing me with someone else.
13:01:03 <dfeuer> bitemyapp, I would like to try to make some of these ideas more approachable.
13:01:13 <dfeuer> Because Haskell is *all about* equational reasoning.
13:01:21 <bitemyapp> dfeuer: I'm not confusing anything.
13:01:23 <monochrom> if you specify no operation at all, () already "represents" and "constructs" and "implements" infinite sets. because you haven't specified any accessor operations to observe anything wrong.
13:01:26 <dfeuer> That's what the game is about.
13:01:32 <bitemyapp> dfeuer: thanks, I know what Haskell is about.
13:01:36 <dfeuer> OK.
13:01:37 <dfeuer> So
13:01:43 <dfeuer> Why are you insulting me?
13:01:46 <bitemyapp> I'm not.
13:01:53 <lpaste> Gurkenglas annotated “No title” with “drmoob, how about this?” at http://lpaste.net/5184665025427537920#a142361
13:01:59 <CpnStumpy> dfeuer: It's the Internet, just go with it
13:02:04 <aweinstock> dfeuer: fix (1:) == cycle [1]
13:02:09 <phaazon> 22:07 < bitemyapp> dfeuer: thanks, I know what Haskell is about.
13:02:13 <phaazon> I laughed at that
13:02:43 <dfeuer> If you start with "infinite loop", you have to deal with "what will lead to an infinite loop?"
13:02:44 <phaazon> because, trying to explain what Haskell is to bitemyapp is like trying to explain Dijkstra what path finding is all about haha
13:02:46 <EvanR> And that's what it's all about!
13:02:55 <dfeuer> And in Haskell, reasoning about that *operationally* tends to be *hard*.
13:02:59 * hackagebot hreader 1.0.1 - Generalization of MonadReader and ReaderT using hset  https://hackage.haskell.org/package/hreader-1.0.1 (AlekseyUymanov)
13:03:01 <bitemyapp> dfeuer: there are more and less useful contributions to a conversation and they depend on context. Part of that is the background of your audience.
13:03:03 <aweinstock> > fix ((1:) . (fmap (+1)))
13:03:04 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:03:37 <bitemyapp> dfeuer: if your audience is currently trying to understand something like, "why does `reverse [1..]` not work?", there are better ways to begin than where you did.
13:03:46 <dfeuer> bitemyapp, this is true. 
13:03:55 <dfeuer> But!
13:04:16 <bitemyapp> dfeuer: this isn't a grad school math department
13:04:22 <optocoupler> I don't know, at least in haskell you can get assurance around if your application is going to leak file handles or do weird stuff
13:04:24 <bitemyapp> dfeuer: you cannot make assumptions about peoples' backgrounds.
13:04:24 <CpnStumpy> bitemyapp: So what you're saying is, you made a different channel that's intended to be more helpful? Where? I stink at Haskell and always need help.
13:04:25 <dfeuer> isomorphismes brought up the idea of "infinity", which seems like it really gets to the semantics of it and leads to the idea of bottom quite naturally.
13:04:36 <bitemyapp> dfeuer: you have to start with the lower prereqs unless the learner tells you to skip ahead.
13:04:39 <dfeuer> bitemyapp, I don't even have an undergraduate degree.
13:04:39 <optocoupler> we run a large java app at my work and we can't make any guarantees due to the sheer number of dependencies
13:04:45 <phaazon> CpnStumpy: this very channel is for people who’d like to learn
13:04:48 <phaazon> that’s the perfect place for ;)
13:04:50 <bitemyapp> dfeuer: that means literally nothing about how you explain things.
13:05:09 <dfeuer> Hrmm
13:05:12 <optocoupler> since the language provides no support for enforcing I/O type stuff
13:05:22 <phaazon> 22:05 < dfeuer> [1..] = fix (1:) 
13:05:24 <phaazon> ok, yeah.
13:05:32 <phaazon> unfolding fix to the beginners is WRONG
13:05:35 * chreekat has no idea what a fixed point is, and apparently gets by just fine
13:06:17 <phaazon> chreekat: a fix point is, in math, when the result of a function equals the parameter – f x = x
13:06:25 <CpnStumpy> chreekat: Oh! Oh! I know this one! it's when...uhh... f . p = p ?
13:06:26 <EvanR> x is a fixed point of f if f x = x
13:06:30 <athan> that ain't even right, neither :\
13:06:43 <CpnStumpy> oh I almost remembered it! Yay me!
13:06:50 <phaazon> and yeah
13:06:54 <monochrom> fixed point just means recursively defined things. you have done a lot of them yourself.
13:06:57 <phaazon> you don’t need that knowledge to understand what fix does
13:07:03 <optocoupler> haskell has a lot of tricks to remove verbosity, it seems wrong to start explanations with a condensed version of something like that
13:07:05 <phaazon> what monochrom said
13:07:13 <Feuerbach> hey chreekat and everyone else. haven't been here for a while
13:07:20 <arkeet> > fix ((1:) . map (1+))
13:07:21 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:07:23 <bitemyapp> Feuerbach: howdy
13:07:23 <chreekat> Feuerbach: yo!
13:07:27 <dfeuer> chreekat, the idea is  fix f = f (fix f), but that's actually implemented as   fix f = let x = f x in x for efficiency in certain contexts.
13:07:33 <mniip> this whole discussion also makes me wonder...
13:07:33 <dfeuer> Hello, Feuerbach.
13:07:35 <Rembane> Fix points, do I get it all wrong if I think about the functor laws?
13:07:46 <mniip> shouldn't reverse (x:⊥) be ⊥:⊥
13:07:55 <phaazon> Rembane: fix points are everything about recursivity, actually
13:07:59 * hackagebot HaRe 0.8.1.0 - the Haskell Refactorer.  https://hackage.haskell.org/package/HaRe-0.8.1.0 (AlanZimmerman)
13:08:06 <dfeuer> mniip, it would be possible to accomplish that, yes. But expensive.
13:08:07 <arkeet> mniip: a sufficiently lazy reverse would do that.
13:08:07 <CpnStumpy> mniip: Reverse makes bottom cry?
13:08:11 <Rembane> phaazon: Nice!
13:08:12 <CpnStumpy> that's the way I read that.
13:08:22 <mniip> arkeet, dfeuer I am aware
13:08:22 <athan> mniip: only if `x` is evaluated
13:08:26 <phaazon> Rembane: I remember how I struggled to get the source of fix
13:08:27 <athan> right?
13:08:30 <mniip> but
13:08:30 <phaazon> sounded so magical at first :)
13:08:39 <mniip> is there a perfomance implication?
13:08:54 <arkeet> usually one is interested in more than the spine of a list.
13:09:02 <Rembane> phaazon: I haven't understood it yet. Is there a need to actually understand fix?
13:09:05 <dfeuer> mniip, if you define reverse using traverse with lazy State you should get there.
13:09:13 <phaazon> Rembane: it’s just interesting
13:09:17 <mniip> dfeuer, nah, a lazy binding will do
13:09:26 <phaazon> because it helps to understand laziness and thunks
13:09:28 <phaazon> but in the end, no
13:09:31 <phaazon> it’s okay if you don’t
13:09:38 <arkeet> @where sneaky2
13:09:38 <lambdabot> lazyReverse xs = go xs (reverse xs) where go (_:xs) ~(y:ys) = y : go xs ys; go [] ~[] = []
13:10:18 <Feuerbach> in conduit, how do I say "take elements while the condition holds, and turn them into a new conduit"? Like if I wanted to sum up multiple groups of numbers separated by an empty line in a file
13:10:32 <mniip> reverse = go [] where go xs [] = xs; go xs (y:ys) = case go (y:xs) ys of ~(r:rs) -> r:rs
13:10:34 <Feuerbach> or maybe there's a better way to do it
13:10:42 <Rembane> phaazon: That's one of the better reasons I believe.
13:11:10 <EvanR> Rembane: i use fix sometimes as a quick and dirty loop
13:11:22 <dfeuer> mniip, that should work.
13:11:27 <mniip> @let lazyReverse = go [] where go xs [] = xs; go xs (y:ys) = case go (y:xs) ys of ~(r:rs) -> r:rs
13:11:29 <lambdabot>  Defined.
13:11:32 <phaazon> Rembane: yeah, I still don’t really understand how I should implement mfix and loop :D
13:11:36 <dfeuer> I think.
13:11:38 <Rembane> EvanR: Like a while(1) {...} ?
13:11:42 <phaazon> (monadic version of fix, and arrow version of fix)
13:11:42 <drmoob> Gurkenglas: it appears to be working, though I realized now that I made a misstake too, the popCount should go before minimum
13:11:47 <Rembane> phaazon: ^^
13:11:52 <EvanR> Rembane: right, or while(!foo){ ...
13:12:05 <mniip> > () <$ (take 3 $ lazyReverse (1:2:3:undefined))
13:12:07 <lambdabot>  [()*Exception: Prelude.undefined
13:12:14 <Rembane> EvanR: That's nice, I want them now and then and become frustrated because I can't find them.
13:12:14 <dfeuer> > length $ take 100 $ lazyReverse [1..]
13:12:15 <mniip> hmm it works... not
13:12:20 <lambdabot>  mueval-core: Time limit exceeded
13:12:20 <dfeuer> Nope.
13:12:30 <dfeuer> Oh well.
13:12:30 <Feuerbach> fix is cool to avoid passing shared variables in a recursive function definition (without introducing a subfunction)
13:12:33 <monochrom> mfix and loop are going to depend on the actual instances. if you know how to do them for State and for Reader, I think you're already pretty good
13:12:41 <mniip> > length $ take 3 $ 1:2:3:undefined
13:12:45 <lambdabot>  3
13:12:47 <Feuerbach> f a b = fix $ \rec -> {- here you can use a and b -}
13:12:49 <mniip> well that was slow
13:12:55 <mniip> er
13:13:00 <mniip> I didn't lazyReverse
13:13:01 <EvanR> Rembane: really its better to use a combinator that implements the recursion pattern for you
13:13:08 <EvanR> if it exists, and if it doesnt write one
13:13:44 <mniip> EvanR, we implemented goto using the State monad the other day!
13:13:53 <Rembane> EvanR: Yes. That should follow the principle about not writing too clever code.
13:13:56 <EvanR> Rembane: for example untilM
13:13:59 <Gurkenglas> Also if you can use fix you can use memoFix, which is sometimes useful
13:14:32 <Rembane> EvanR: That's a beauty! Thanks!
13:16:34 <EvanR> recursion works so well in haskell its scary to try and write analogous algorithms in like ruby or javascript
13:17:00 <EvanR> always wondering if its going to be dirt slow or just crash due to "too much recursion"
13:17:35 <EvanR> non recursive versions of the same algorithms are hard to understand!
13:20:00 <aweinstock> EvanR: do either ruby or js have guarenteed TCE like scheme does?
13:20:16 <monochrom> js doesn't
13:20:29 <EvanR> i think you have the guarantee that it WONT have that
13:20:48 <EvanR> because that is for functional programming, which is for weenies. let me get the reference in the spec
13:21:05 <athan> PureScript lets you!
13:21:53 <aweinstock> athan: did you manage to solve the monadic monoid thing from earlier? (the one I suggested (liftA2 (<>)) for)
13:23:00 * hackagebot postgresql-query 2.2.0 - Sql interpolating quasiquote plus some kind of primitive ORM  using it  https://hackage.haskell.org/package/postgresql-query-2.2.0 (AlekseyUymanov)
13:23:15 <athan> aweinstock: Well, it looks like system.Directory.findFile already had that tool, but I still plan to!
13:23:35 <dfeuer> mniip, I can't get lambdabot to give me lazy State for  xs = evalState (for xs (\_ -> do {~(h:t) <- get; put t; return h})) $ foldl (flip (:)) [] xs
13:23:38 <athan> I've found `Snd a b = Snd {getSnd (a,b)}` and Fst newtypes to be useful for monoids
13:24:07 <dfeuer> athan, what's that do?
13:24:16 <athan> For instance, that lets you find the min / max element of any FoldableWithKey in O(n)
13:24:42 <aweinstock> isn't there already an "instance Monoid a, Monoid b => Monoid (a,b)"?
13:24:47 <chreekat> Feuerbach: Seems like you would need the right variety of "join", since you have a Conduit creating a stream of Conduits
13:25:13 <athan> dfeuer: foldMapWithKey (\k v -> Option $ Just $ Min $ Snd (k, v)) xs
13:25:25 <EvanR> aweinstock: actually ruby has support for it disabled by default, but theres an infamous criticism by guido on TCE in python http://neopythonic.blogspot.in/2009/04/tail-recursion-elimination.html
13:25:26 <dfeuer> Brr.
13:25:28 <athan> aweinstock: Right, but that's for _both_ elements
13:25:37 <aweinstock> > let f a = (Sum a, Product a) in f 2 <> f 3
13:25:38 <lambdabot>  (Sum {getSum = 5},Product {getProduct = 6})
13:25:44 <Feuerbach> chreekat: well, I don't even see how I would create a conduit of conduits in the first place
13:25:52 <athan> o.o
13:25:54 <athan> hmm
13:26:32 <aweinstock> :t return (yield 5) >> yield (return ())
13:26:33 <lambdabot> Not in scope: ‘yield’
13:26:34 <lambdabot> Not in scope: ‘yield’
13:26:44 <Feuerbach> I posted this to SO, by the way, in case anyone wants to answer there https://stackoverflow.com/questions/32957258/how-to-model-nested-streams-with-conduits
13:27:03 <chreekat> Feuerbach: That's exhausted my sack of ideas. :) It just sounded like something I ran into when playing with Bacon.js, and felt kind of brilliant/stupid when I realized I needed to find the right way to do join in that api
13:27:13 <isomorphismes> hpc: Thanks for this explanation. +s is print timing/memory stats after each evaluation . How would I use that to see what parts of a list get evaluated when?
13:27:14 <aweinstock> :t return (Data.Conduit.yield 5) >> Data.Conduit.yield (return ())
13:27:15 <lambdabot>     Could not deduce (Monad m0)
13:27:15 <lambdabot>       arising from a use of ‘conduit-1.2.5:Data.Conduit.Internal.Conduit.yield’
13:27:15 <lambdabot>     from the context (Monad m, Monad m1)
13:29:21 <mniip> > (`execState` 0) $ do comefrom $ \loop -> do x <- get; put (x + 1); when (x < 5) $ goto loop
13:29:22 <lambdabot>  6
13:29:28 <mniip> dfeuer, do-while loop ^
13:30:07 <dfeuer> mniip, what the heck is comeFrom?
13:30:22 <mniip> I named it "label" initially, but the name appears to be taken
13:30:23 <EvanR> from the intercal package
13:30:27 <mniip> in lambdabot at least
13:30:27 <aweinstock> :t comefrom
13:30:29 <lambdabot> (a -> a) -> a
13:30:38 <aweinstock> :t goto
13:30:39 <lambdabot> a -> a
13:31:11 <aweinstock> :t ([comefrom, fix], [goto, id])
13:31:12 <lambdabot> ([(a -> a) -> a], [a1 -> a1])
13:31:24 <mniip> how did you know!
13:31:34 <dolio> Free theorems, clearly.
13:31:39 <aweinstock> how did I know what?
13:31:53 <mniip> it was a rhetorical question
13:32:13 <EvanR> from the you-can-write-C-in-any-language dept
13:33:21 <aweinstock> :t fix $ \line10 -> putStrLn "hello >> fix $ \line20 -> line10
13:33:22 <lambdabot>     lexical error in string/character literal at character 'l'
13:33:36 <aweinstock> :t fix $ \line10 -> putStrLn "hello" >> fix $ \line20 -> line10
13:33:37 <lambdabot>     Couldn't match expected type ‘(t0 -> a) -> a’
13:33:37 <lambdabot>                 with actual type ‘IO b0’
13:33:37 <lambdabot>     Relevant bindings include line10 :: a (bound at <interactive>:1:8)
13:33:55 <aweinstock> :t mfix $ \line10 -> putStrLn "hello" >> mfix $ \line20 -> line10
13:33:56 <lambdabot>     Couldn't match expected type ‘(t0 -> a) -> m a’
13:33:56 <lambdabot>                 with actual type ‘IO b0’
13:33:56 <lambdabot>     Relevant bindings include line10 :: a (bound at <interactive>:1:9)
13:35:58 <aweinstock> :t fix (\line10 -> putStrLn "hello" >> fix (\line20 -> line10))
13:35:59 <lambdabot> IO b
13:36:17 <aweinstock> there we go: "real programmers can write BASIC in any language"
13:39:31 <CpnStumpy> Feuerbach: Well filter can be defined in terms of fold, so if you have foldm or other such facilities on conduit (I know nothing of conduit) perhaps you can work it out from that?
13:40:26 <CpnStumpy> if conduit is Foldable which lots of things are you could use that (I have no idea what Foldable gives but presuming it gives the ability to fold)
13:41:14 <johnw> Feuerbach: you can make a producer of producers
13:41:34 <johnw> Feuerbach: since conduits can detect termination, this should be quite easy
13:46:42 <athan> What is the name for the `a -> (b -> r) -> r` profunctor? :(
13:47:23 <mniip> Compose (->) Cont
13:47:29 <mniip> or something :P
13:47:57 <athan> :o
13:48:17 <athan> actually it ought to be `b -> (a -> r) -> r`
13:48:58 <dolio> mniip: This is the real BASIC: http://augustss.blogspot.com/2009/02/more-basic-not-that-anybody-should-care.html
13:49:15 <dfeuer> I thought I liked closed type families. I've changed my mind. They and overlapping instances should all die die die.
13:49:46 <EvanR> dolio: hes been reimplemented by BASIC!
13:49:56 <dolio> Heh.
13:50:01 <bitemyapp> dolio: what changed your mind?
13:50:02 <mniip> hmm
13:50:07 <mniip> ST does not cooperate with mfix
13:50:24 <mniip> and State does not cooperate with arbitrarily declared state vars
13:50:28 <arkeet> athan: it's Kleisli Cont.
13:50:30 <arkeet> er
13:50:32 <arkeet> Kleisli (Cont r)
13:50:39 <mniip> hmmm actually
13:50:50 <dfeuer> What the heck? That BASIC thing is insane!
13:51:00 <aweinstock> @unmtl Cont
13:51:01 <lambdabot> Plugin `unmtl' failed with: `Cont' is not applied to enough arguments, giving `/\A B. (B -> A) -> A'
13:51:10 <aweinstock> @unmtl Cont r
13:51:10 <lambdabot> Plugin `unmtl' failed with: `Cont r' is not applied to enough arguments, giving `/\A. (A -> r) -> r'
13:51:35 <aweinstock> @unmtl Kleisli (Cont r a)
13:51:35 <lambdabot> Kleisli ((a -> r) -> r)
13:51:47 <arkeet> Kleisli m a b = a -> m b
13:51:59 <johnw> athan: UpStar (Cont r), in particular
13:52:14 <johnw> or, WrappedArrow (Kleisli (Cont r))
13:52:17 <arkeet> johnw: sure, but it becomes a category since Cont r is a monad.
13:52:27 <dfeuer> bitemyapp, closed type families and overlapping instances give ways to talk about things that *aren't* true, but they do so in ways that seem to me both limited and confusing.
13:52:36 <johnw> sure, I'm talking about instances for Profunctor
13:52:46 <aweinstock> Kleisli (Cont r b) = (a -> ((b -> r) -> r)) ?
13:52:53 <arkeet> there already is a Profunctor instance for Kleisli
13:52:58 <johnw> ah, ok
13:53:05 <arkeet> aweinstock: no, Kleisli (Cont r) a b
13:53:25 <aweinstock> @unmtl Kleisli (Cont r) a b
13:53:25 <lambdabot> Kleisli (Cont r) a b
13:53:37 <arkeet> Kleisli isn't a mtl thing.
13:53:43 <dfeuer> Also, bitemyapp, they break the nice old Data.Constraint.Forall in a way that cannot really be fixed. The new version is crippled.
13:53:53 <xplat> it's an arrow thing originally
13:53:54 <aweinstock> are there more general lambdabot thingies that would unroll that?
13:54:45 <xplat> aweinstock: not afaict, and i've been around lambdabot a long time
13:55:29 <monochrom> mniip: ST is surely a MonadFix instance. (IO is, too). so ST surely supports mfix. not that you can make your own, unless you also make your own ST.
13:55:45 <dolio> Breaking Data.Constraint.Forall sounds like an argument in their favor, since it's a huge hack.
13:55:48 <bitemyapp> dfeuer: usually when Kmett or dolio say they don't like something, there's a concrete anecdote that occurred while they were working on something.
13:56:13 <bitemyapp> dfeuer: I try to absorb that experience vicariously when I can, so if they speak up about something and don't explain anything, I ask.
13:56:21 <aweinstock> mniip: STRef is strict, that might be relevant
13:56:52 <bitemyapp> dfeuer: OI has made me uncomfortable in the past, but I don't have detailed objections.
13:57:04 <Cale> OI?
13:58:17 <aweinstock> mniip: (e.g. (do { s <- newSTRef 0; forever (readSTRef s); return 42}) evaluates to bottom, I think, even with Data.STRef.Lazy)
13:58:23 <EvanR> the dual of IO
13:58:36 <aweinstock> is OI actually a thing?
13:59:21 <dolio> You mean Output/Input?
13:59:38 <dolio> It's a thing that people have proposed, but it doesn't stand up to investigation very well.
14:00:19 <bitemyapp> aweinstock: Overlapping Instances
14:00:28 <aweinstock> ah
14:01:11 <athan> thanks johnw and arkeet!!
14:02:11 <EvanR> comonadic OI
14:02:20 <EvanR> should exist
14:03:41 <athan> bitemyapp: damn, my pvp constraint solver is a bust - already been done with the haskell matrix project :(
14:03:53 <athan> http://matrix.hackage.haskell.org/
14:03:59 <ski> EvanR : the problem with the proposal was lack of uniqueness or something like that, iirc
14:04:09 <bitemyapp> athan: you should ask and look around a bit more before diving in
14:04:09 <athan> And, there's even a flag in stack for --pvp-bounds D:
14:04:21 <bitemyapp> athan: prior art can save time, even if it doesn't do 100% of what you want.
14:04:41 <athan> It was still fun struggling with haskell-src-exts
14:04:46 <athan> thanks though
14:04:48 <bitemyapp> athan: fair enough. All the same :)
14:05:49 <ski> athan : is is equal to `return 42', with lazy `ST'
14:05:52 <ski> er
14:05:55 <ski> aweinstock ^
14:06:06 <mniip> what is this supposed to mean:     No instance for (MonadState [V] (StateT [V] Identity)) arising from a use of ‘get’
14:06:13 <athan> ski >:C
14:06:24 <mniip> clearly such an instance exists
14:06:27 <aweinstock> ski: it should be, but I don't think it is...
14:06:35 <ski> aweinstock : i just tested it
14:06:55 <ski> aweinstock : with `Control.Monad.ST.Lazy' as well, of course
14:07:37 <monochrom> mniip: interesting. how to reproduce it?
14:08:04 <aweinstock> ski: huh (I just tested it, and also tested with writeSTRef, and you're right; maybe I was thinking of something else)
14:09:07 <phaazon> hm
14:09:16 <aweinstock> ski: http://stackoverflow.com/questions/24072934/haskell-how-lazy-is-the-lazy-control-monad-st-lazy-monad
14:09:23 <phaazon> is there any other way to implement ad hoc polymorphism in Haskell than using typeclasses?
14:09:33 <phaazon> a lot of people tend to think typeclasses without laws suck
14:09:46 <mniip> monochrom, wow
14:09:50 <EvanR> phaazon: well you can use a record of functions
14:10:00 <phaazon> yeah
14:10:05 <phaazon> I could
14:10:05 <isomorphismes> CpnStumpy: A friend advised me to do this with Prelude.hs, which led me to http://lambda.jstolarek.com/2012/03/function-composition-and-dollar-operator-in-haskell/, which led me here.
14:10:05 <EvanR> which is more flexible than typeclasses anyway
14:10:10 <johnw> "records of functions" are very similar to objects
14:10:11 <phaazon> EvanR: why so?
14:10:11 <monochrom> oh, record of functions is even better
14:10:20 <phaazon> why?
14:10:32 <johnw> phaazon: http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf
14:10:35 <phaazon> you have to pass them around
14:10:42 <phaazon> while you can “spawn” methods
14:10:45 <mniip> monochrom, GHC.Exts.Any confirmed for being the cause
14:11:06 <EvanR> you dont have to pass them around if you dont want to, Reader, State etc
14:11:25 <EvanR> but you probably want to
14:11:41 <EvanR> oh also Implicit Params
14:11:48 <phaazon> yeah well…
14:11:58 <phaazon> Implicit Params scare me a lot
14:12:02 <EvanR> indeed
14:12:09 <phaazon> they sound a bit like a cheat in the language
14:12:14 <phaazon> and they’re totally opaque
14:12:21 <johnw> phaazon: the essay I linked to explains the subtlies of ADT vs. typeclass vs. objects in nice detail
14:12:37 <johnw> it's an easy read too
14:12:38 <phaazon> johnw: I’ll read it then
14:12:42 <phaazon> thanks
14:13:46 <isomorphismes> dfeuer: That seems not true. For example:
14:13:49 <isomorphismes> > [3,2,1] > [2,10,100]
14:13:51 <lambdabot>  True
14:14:03 <isomorphismes> The "worst possible answer" would be "incomparable" because it's not Pareto superior
14:14:26 <ski> phaazon : you might perhaps also like "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>, which that other paper refers to
14:14:46 <phaazon> downloaded as well, thanks!
14:14:51 <d34df00d_azoth> Hi there!
14:15:03 <ski> hello d34df00d_azoth
14:15:05 <phaazon> hi d34df00d_azoth 
14:15:38 <d34df00d_azoth> I'm trying to make a variadic function max' that'll be invokable as `max' 1` as well as say `max' 1 2 3 ...`
14:15:53 <ski> phaazon : TaPL also has some chapters on the differences between the use of existentials to get ADTs and to get OO
14:15:53 <d34df00d_azoth> I've come this far so far:
14:16:04 <d34df00d_azoth> https://bpaste.net/show/1c1b86d52fcb
14:16:06 <phaazon> d34df00d_azoth: you need a typeclass for that
14:16:07 <EvanR> :t maximum
14:16:08 <lambdabot> (Ord a, Foldable t) => t a -> a
14:16:14 <EvanR> :|
14:16:20 <phaazon> if you really mean variadic
14:16:28 <d34df00d_azoth> But I get:
14:16:35 <d34df00d_azoth> https://bpaste.net/show/33c55b053e4d
14:16:50 <phaazon> ski: that’s an interesting topic
14:16:55 <phaazon> I’ll read those :)
14:17:04 <phaazon> and come back to you later then :)
14:17:13 <d34df00d_azoth> phaazon: yeah, I have that, but there are problems when I try apply this to polymorphic values (like number literals are in ghci).
14:17:20 <lpaste> mniip pasted “Imperative programming in haskell” at http://lpaste.net/142367
14:17:27 <d34df00d_azoth> I previously had another version:
14:17:31 <d34df00d_azoth> https://bpaste.net/show/9f5432c143e0
14:17:47 <d34df00d_azoth> And it worked like a charm if invoked as, say, max' 'a' 'b' 'c', but max' 1 2 3 failed:
14:18:20 <d34df00d_azoth> https://bpaste.net/show/ee5cac255c3d
14:18:52 <mniip> aweinstock, dfeuer dolio ^
14:21:17 <mniip> hmm
14:22:43 <isomorphismes> aweinstock: I don't understand what you're getting at when you say [1..] is in [ℕ].
14:24:28 * ski . o O ( "loop in C , recursion in haskell" by Simon Marlow in 2004-03-24 at <http://mail.haskell.org/pipermail/haskell-cafe/2004-March/005939.html> )
14:25:55 <isomorphismes> CpnStumpy: "Computers can only represent an unbounded set" ← right, but clearly ∃ a finite representation of +∞, so maybe eg rev . rev $ [1..] could work -- in fact, I would have thought "laziness" gives you that.
14:26:22 <isomorphismes> bitemyapp: thanks, I've had some problems with stackage but will try it.
14:26:38 <isomorphismes> bitemyapp: yes, you do =)
14:27:03 <xplat> d34df00d_azoth: making variadic functions in Haskell is a bad idea.  if you want to get a very good idea of why it's a bad idea by all means continue, but if you're trying to get something done or learn idiomatic haskell use lists instead
14:27:59 <xplat> (sometimes learning why something is a bad idea is very helpful in the long run)
14:29:54 <d34df00d_azoth> xplat: sure, if I wanted to solve a real task I'd used `maximum` instead, but now I'm curious how this should be implemented, eh, on type level.
14:30:13 <d34df00d_azoth> So that's somewhat around "learning why something is a bad idea".
14:31:53 <xplat> d34df00d_azoth: yeah.  the problem is that you need to have a 'variadic function' type class to have variadic functions, but it's often important for a function to return a function.
14:33:02 * hackagebot yesod-newsfeed 1.5 - Helper functions and data types for producing News feeds.  https://hackage.haskell.org/package/yesod-newsfeed-1.5 (GregWeber)
14:33:04 <xplat> also, haskell doesn't have polymorphism of the sort 'anything but (a -> b)' for important reasons to do with making type inference possible
14:33:12 <lpaste> Gurkenglas annotated “Imperative programming in haskell” with “mniip, this one should give logarithmic runtimes, right?” at http://lpaste.net/142367#a142369
14:34:24 <isomorphismes> chreekat: A fixed point is when f(f(f(f(p)))) can get stuck at some point(s).
14:34:57 <d34df00d_azoth> xplat: hm, I don't see any problems yet (from your first reply here).
14:34:57 <xplat> and the only thing variadic arguments really allow in excange for those downsides is exchanging one syntax for another, both of which are pretty lightweight
14:36:08 <xplat> d34df00d_azoth: well, you already experienced a problem -- you couldn't get this to work for a polymorphic type
14:36:23 <d34df00d_azoth> xplat: right now I'm trying to understand the error message and I seem to fail at that.
14:36:43 <xplat> d34df00d_azoth: because if your argument is a polymorphic type 'a' then so is your return type
14:36:52 <d34df00d_azoth> xplat: so again, let's say I have the following code:
14:36:56 <d34df00d_azoth> https://bpaste.net/show/2ddd3c630393
14:37:01 <xplat> d34df00d_azoth: and that 'a' could be instantiated to something of the form 'b -> c'
14:37:13 <d34df00d_azoth> And I get the following error:
14:37:17 <d34df00d_azoth> https://bpaste.net/show/bc83e1935b67
14:37:23 <d34df00d_azoth> Well, why there is this error?
14:37:32 <d34df00d_azoth> V (v -> t) doesn't depend on t, it's purely v.
14:37:38 <d34df00d_azoth> So I see no troubles for the typechecker.
14:37:49 <xplat> d34df00d_azoth: but if that instantiation takes place, there is no local way to know where the arguments end
14:37:58 <d34df00d_azoth> xplat: and why there is a need to know this?
14:42:07 <xplat> d34df00d_azoth: the type family 'V t' can't compute when t is an uninstantiated variable
14:43:40 <d34df00d_azoth> xplat: does the translation "the type checker doesn't know at this point that there is another instance declaration for 'Maxable' for function types, so it doesn't know whether it's just 'v' or really 'v -> t' and as such it can't decide which type instance to choose" sound right?
14:44:11 <Welkin> d34df00d_azoth: functional dependencies?
14:44:23 <Welkin> d34df00d_azoth: also, your name is confusing
14:44:39 <Welkin> dead food azoth?
14:44:50 <d34df00d_azoth> Welkin: tried that, funny results (also, I guess fundeps are equivalent to type families in this case).
14:44:51 <osa1> does anyone know a small library that provides something similar to resourcet's "with" ?
14:44:52 <Welkin> at first I thought it was a hex code
14:45:14 <d34df00d_azoth> Welkin: yeah, dead food for the nick, and I'm already logged in to freenode at another machine, so my IRC client appended its name to the nick to avoid the conflict.
14:46:58 <Sonolin> endo monoid is same as function composition right?
14:47:11 <Sonolin> f = g . h ??
14:47:30 <xplat> d34df00d_azoth: first t has to be instantiated to something.  if that something is of the form a -> b, then V t computes to a.  if the something is of some other form, then V acts like id.  but t must be instantiated to some specific form first (must have a head constructor)
14:48:00 <xplat> d34df00d_azoth: a plain 'V t' just stays as 'V t'
14:48:06 <d34df00d_azoth> xplat: hm, this sounds like "it's impossible to use type families with type variables in instance declarations", is that correct?
14:49:10 <xplat> d34df00d_azoth: it's not impossible, you just have to be aware of when you can expect them to compute and when you can't.  it works like partial evaluation.
14:49:32 <d34df00d_azoth> But if it always stays like a plain 'V t' declaration, what's the point then?
14:51:37 <xplat> d34df00d_azoth: well, let's look at what happens in line 13.  the type of the max' you're defining, on the left of the '=', starts as 'T (v -> t) -> v -> t' and reduces to 'v -> v -> t', which is fine
14:52:14 <d34df00d_azoth> Yeah, makes perfect sense so far.
14:52:20 <xplat> d34df00d_azoth: it's the inner one, which you call recursively on the rhs, that is a problem.  it starts out as 'T t -> t' and it stays that way.
14:52:25 <JagaJaga> Do smone use Data.Persist? How can I create instances for my datas? Now I'm getting `error| ‘foobat’ is not a (visible) field of constructor` if I create datas via quasi.
14:52:53 <Welkin> JagaJaga: you mean Database.Persist?
14:52:53 <xplat> d34df00d_azoth: so you can't apply it to 'max v1 v2' which is of type v
14:53:07 <xplat> *'V t -> t'
14:53:11 <ifesdjeen> hi! Does anyone know a good http2 client library? There are plenty servers, but I can't seem to find a client at all...
14:53:15 <Welkin> JagaJaga: have you read the Persistent chapter in the Yesod book? http://www.yesodweb.com/book/persistent
14:53:43 <xplat> the rhs max' wants a V t, you are giving it a v
14:53:44 <JagaJaga> Welkin: yeah, Database.Persist. Yup, I've read it..
14:53:54 <JagaJaga> Welkin: OH
14:54:12 <Welkin> ifesdjeen: https://hackage.haskell.org/package/http-client
14:54:16 <JagaJaga> Welkin: It translates to datanameFieldname
14:54:24 <JagaJaga> Welkin: thank you ;)
14:54:33 <d34df00d_azoth> xplat: oh, yeah, indeed.
14:54:40 <d34df00d_azoth> Got it!
14:54:45 <d34df00d_azoth> And is there any workaround for this?
14:55:07 <ifesdjeen> @Welkin unfortunately that's http1 only
14:55:07 <lambdabot> Unknown command, try @list
14:55:18 <xplat> d34df00d_azoth: and indeed this code doesn't make sense.  if you just replace the definition with 'undefined' so it compiles, then besides the overlapping instances, you find that you could have a max' of type 'Int -> Integer -> Char'
14:56:07 <Welkin> ifesdjeen: also look at https://hackage.haskell.org/package/wreq
14:56:48 <d34df00d_azoth> xplat: hmm, yep, indeed. I guess I'll revert to the two-parameter Maxable, it compiles at least.
14:57:03 <xplat> Welkin: since you're pushing wreq, do you happen to know how to inject a cookie in wreq's cookie jar?
14:57:04 <Welkin> ifesdjeen: https://hackage.haskell.org/package/http2
14:57:18 <Welkin> xplat: I have never used any of these, I just know they exist :P
14:57:24 <Welkin> so I can't say
14:57:52 <ifesdjeen> Welkin: thanks! checked that one, too, turned out to be http1 too :) and http2 turned out to be only frame / HPACK parser :(
14:57:59 <ifesdjeen> i mean http2 the lib
14:59:01 <guillaum2> my heart just stopped when I realized that "Nothing < Just anything" is False...
14:59:21 <Welkin> hm, well I am sure one exists
14:59:31 <guillaum2> I don't know what I was expecting, but not a silent False...
14:59:34 <ifesdjeen> :) will keep searching, thanks!
15:00:15 <hiptobecubic> > Nothing < Just undefined
15:00:16 <lambdabot>  True
15:00:23 <hiptobecubic> guillaum2, ?
15:01:02 <guillaum2> hiptobecubic: or the opposite. The fact that Ord is defined on Maybe kills me...
15:01:29 <hiptobecubic> guillaum2, why? It has a sensible definition
15:02:12 <guillaum2> hiptobecubic: why it is sensible ? Nothing < Just (a big chicken)
15:02:17 <hiptobecubic> Yes
15:02:20 <hiptobecubic> @src Maybe
15:02:21 <lambdabot> data Maybe a = Nothing | Just a
15:02:58 <hiptobecubic> Nothing is less than something
15:03:08 <hiptobecubic> And if you have two somethings, the lesser one is less
15:03:27 <jstimpfle> I would be surprised if anybody has a usecase for this instance
15:03:43 <hiptobecubic> sorting a bunch of results of computations that can fail?
15:03:46 <guillaum2> hiptobecubic: Nothing < Just (-1)
15:04:02 <Hijiri> if you want a Map (Maybe Blah) Foo you will want the instance
15:04:04 <hiptobecubic> guillaum2, and? Nothing is not 0. It's Nothing.
15:04:27 <jstimpfle> using a generic sort for that (questionable) usecase would be terrible
15:04:27 <Welkin> Nothing is always less than Something :D
15:04:30 <Hijiri> it's like sticking negative infinity at the left
15:04:37 <Charles9391> it's suprising to me too - it reminds me of javascript's weird comparisons with null/undefined/empty collections
15:04:57 <hiptobecubic> It's not like you can compare Nothing < 8
15:05:40 <hiptobecubic> Maybe is a data type, it implements Ord in a very clear way that is not dependent on anything other than the type parameter also having a sensible definition. I don't see what's upsetting about it.
15:06:11 <Welkin> Nothing is a data constructor
15:06:14 <Welkin> it is not null
15:06:17 <hiptobecubic> Right
15:06:21 <Welkin> it is like any other data constructor
15:06:40 <Welkin> if you define a sum type and autoderive Ord, it will go in order from left to right
15:07:42 <Welkin> it's like an enum, where each value is assigned an ordering by default
15:07:43 <jstimpfle> Welkin: that's interesting
15:08:00 <guillaum2> hiptobecubic: finally I can understand your point, but I think it is really surprising.
15:08:37 <Welkin> > sort [Nothing, Just 4, Nothing, Just 2]
15:08:39 <lambdabot>  [Nothing,Nothing,Just 2,Just 4]
15:13:46 <jstimpfle> are attribute grammars well known here?
15:14:43 <jstimpfle> i am trying to make yet another (tm) cli library that lets me autogenerate cli syntax and shells with autocompletion
15:15:44 <jstimpfle> like, shells with autocompletion that may also lookup values from a database, for some CRUD or admin interface
15:15:56 <jstimpfle> and i'm still looking for a good theoretic model to dive into
15:24:26 <orion> How can I write this in one line?: x <- peekElemOff inp 31; let y = x .&. 0x7f; z = y .|. 0x40 -- My attempt failed: b31 <- (.&.) 0x7f <$> (.|.) 0x40 <*> peekElemOff inp 31
15:25:51 <glguy> (.&. 0x7f) . (.|. 0x40) <$> peekElemOff inp 31 -- should do that whether or not it's a good idea
15:27:01 <orion> Ah, I needed composition.
15:27:05 <orion> Why is it a bad idea?
15:27:49 <hpc> because someday someone's going to have to read that code
15:27:52 <glguy> Just makes things harder to read, you'll still get the same answer
15:28:09 <hpc> and the karma of writing such a terrible line of code guarantees it'll be you
15:28:22 <glguy> You can borrow some of my newlines if you're running out. We have a Sam's Club membership
15:28:40 <hpc> they're half off if you use linux
15:28:53 <orion> hah
15:28:56 <orion> Ok. :)
15:29:31 <arkeet> @undo do { x <- peekElemOff inp 31; let y = x .&. 0x7f; z = y .|. 0x40; rest }
15:29:31 <lambdabot> <unknown>.hs: 1: 72:Parse error: }
15:29:36 <arkeet> @undo do { x <- peekElemOff inp 31; let { y = x .&. 0x7f; z = y .|. 0x40 }; rest }
15:29:36 <lambdabot> peekElemOff inp 31 >>= \ x -> let { y = x .&. 127; z = y .|. 64} in rest
15:30:04 <glguy> If you're doing a lot of bit-level replacements it could be good to name what you're doing, for example
15:30:46 <glguy> then you could go back to one line:   replaceByteWith 0 0x40 <$> peekByteOff... or something like that
15:31:16 <arkeet> (I don't think it's replacing a byte)
15:31:18 <orion> Oh don't worry, I'm just doing crypto... no need to comment the code.
15:31:55 <arkeet> you don't have to obscure *everything* when doing crypto :-)
15:32:49 <MarcelineVQ> comment it while you make it, when you're done crypto the source files with the crypto you made, get meta
15:33:17 <orion> Public Key Cryptography - PKC 2006: 9th International Conference on Theory and Practice of Public-Key Cryptography states: "A user can, for example, generate 32 uniform random bytes, clear bits 0,1,2 of the first byte, clear bit 7 of the last byte, and set bit 6 of the last byte."
15:33:33 <orion> This is in reference to me generating a secure secret key for Curve25519.
15:34:00 <hpc> that sounds secure
15:34:12 <hpc> nobody suspects bit 7 of the last byte
15:37:48 <hunteriam> https://www.irccloud.com/pastebin/xklgA1WJ/Error
15:37:54 <hunteriam> Guys how do i begin to approach this compilation error
15:38:01 <hunteriam> id imagine im not at fault here
15:38:08 <hunteriam> but either way what should i do?
15:38:45 <hunteriam> Anyone?
15:43:07 <fizruk> :t Data.Coerce.coerce :: Data.Coerce.Coercible (f a) (f Int) => f a -> f Int
15:43:08 <lambdabot>     Couldn't match representation of type ‘f1 Int’ with that of ‘f1 a1’
15:43:08 <lambdabot>     NB: We cannot know what roles the parameters to ‘f1’ have;
15:43:08 <lambdabot>       we must assume that the role is nominal
15:43:10 <tommd> orion: Why on earth are you implementing 25519 in Haskell when there are prefectly good bindings on Hackage already
15:43:15 <fizruk> why does not that work? ^
15:43:37 <tommd> orion: And not just any bindings, but bindings to code written by AGL or DJB or Andy Moon.
15:44:12 <tommd> orion: AGL: curve25519-donna.  DJB: curve25519.  AM: ed25519-donna.
15:47:24 <orion> tommd: I'm merely extending cryptonite, which is written by Vincent Hanquez, which uses the AGL implementation.
15:47:37 <orion> Currently, cryptonite has no support for generating secret keys at all.
15:47:53 <tommd> lol, ok.  That's a unfortunate issue. Enjoy!
15:48:57 <orion> My solution? 21 lines of haskell, including all comments.
15:52:26 <tommd> orion: Doesn't "secretKey" generate a secret key?
15:52:55 <tommd> As in, exactly the byte masking you were discussing above.
15:53:45 <orion> https://hackage.haskell.org/package/cryptonite-0.7/docs/src/Crypto-PubKey-Curve25519.html#secretKey
15:53:47 <tommd> Except of course the bit masks are commented out because the underlying C libs already do this.
15:54:06 <orion> It doesn't.
15:54:45 <orion> `secretKey` never calls a C import.
15:55:01 <tommd> orion: Miscommunication.
15:55:20 <tommd> orion: When using a secret key for a computation (scalarmult) the mask is applied.
15:55:38 <tommd> So there is no need to (and some risk in) apply the mask eagerly.
15:57:46 <hunteriam> hey guys
15:57:51 <hunteriam> im getting a terrifying build error
15:57:54 <tommd> oh no!
15:57:54 <hunteriam> can anyone give me some tips
15:57:55 <tommd> Run!
15:57:59 <hunteriam> https://www.irccloud.com/pastebin/Cl5OhSjO/
15:58:05 <hunteriam> where shall i run?
15:59:31 <orion> tommd: The library allows you to construct bad SecretKeys.
16:00:35 <orion> This is provable because the unit tests themselves are invalid.
16:00:49 <orion> https://github.com/vincenthz/cryptonite/blob/master/tests/KAT_Curve25519.hs#L8
16:01:36 <orion> The first byte, 0x77 = 0b1110111. The whitepaper states that bits 0, 1, and 2 of the first byte need to be cleared.
16:04:01 <hunteriam> dear god
16:04:07 <orion> Yes?
16:04:23 <hunteriam> why is my stack build telling me during linking a function is undefined?
16:04:41 <arkeet> perhaps it is undefined.
16:04:53 <arkeet> hard to say without more detail.
16:05:07 <hunteriam> https://www.irccloud.com/pastebin/7olTGOuZ/
16:05:09 <hunteriam> arkeet
16:05:17 <hunteriam> any other details i could provide?
16:05:23 <hunteriam> it somehow passed the ghc phase
16:05:32 <hunteriam> and then pooted in the ld phase
16:05:34 <arkeet> okay, that's "undefined reference".
16:06:03 <arkeet> I don't know.
16:06:29 <hunteriam> D:
16:06:39 <hunteriam> well, have you got any clue what steps i could take to solve it?
16:06:47 <hunteriam> nuking stuff, maybe?
16:09:20 <Briann> hi ! can somebody help me with http://lpaste.net/142378
16:09:25 <Welkin> gandhi will nuke you the first chance he gets
16:09:49 <Briann> i cannot show a type imported from a moduel
16:09:52 <Briann> module*
16:10:43 <hunteriam> Welkin: can gandhi just nuke my gcc installation?
16:10:46 <phaazon> ski: ok
16:10:49 <hunteriam> also will stack install gcc for me?
16:10:51 <phaazon> very interesting
16:10:53 <phaazon> so basically
16:10:56 <hunteriam> i think i may have a shit gcc
16:11:12 <phaazon> a data gathering functions in Haskell is a way of doing OO
16:11:14 <phaazon> that’s funny
16:11:18 <Welkin> Briann: it tells you the error clearly
16:11:34 <arkeet> Welkin: there is also a Show instance on Queue clearly.
16:11:44 <Welkin> yes arkeet 
16:11:49 <Welkin> but the error is clear
16:11:55 <arkeet> yes.
16:11:59 <Welkin> it has something to do with the instance
16:12:01 <arkeet> but what to do about it is unclear.
16:12:08 <Briann> Welkin: But i don't understad, i have to add a deriving Show somewhere ?
16:12:19 <Welkin> it reminds me of the problem with type synonym instances
16:12:22 <zipper> Briann: It would help if you somehow constrained a to a value that has a Show instance. Am I right Welkin ?
16:12:41 <arkeet> Briann: did you add a Show instance recently? are you sure your most recent code is getting loaded?
16:12:52 <arkeet> try restarting ghci.
16:12:59 <zipper> Briann: or better yet instance Show Queue Int where ...
16:13:16 <zipper> Briann: It's the polymorphism eating you.
16:13:35 <arkeet> I don't see anything wrong with the code.
16:13:39 <arkeet> let's try.
16:13:52 <Welkin> instance Show a => (Queue a) where ...
16:13:57 <Welkin> you could try writing it yourself
16:14:01 <Welkin> er
16:14:04 <Briann> It just works fine from the module, but not outside
16:14:05 <Welkin> instance Show a => Show (Queue a) where ...
16:14:35 <arkeet> Briann: well, I put that code into two files (named Main.hs and Queue.hs)
16:14:39 <Welkin> oh
16:14:39 <arkeet> and ghci Main.hs
16:14:41 <arkeet> and put that code
16:14:41 <Welkin> I know the problem
16:14:42 <arkeet> and it works.
16:14:44 <jstimpfle> Briann: are you sure you import the correct "file"
16:14:44 <Welkin> you never exported the instances
16:14:51 <arkeet> Welkin: instances are always exported.
16:14:56 <Welkin> export Queue(..) instead
16:15:05 <arkeet> that would export the constructor. (which is unnecessary.)
16:15:06 <Welkin> arkeet: not from my experience
16:15:12 <jstimpfle> Welkin: by default all is exported
16:15:13 <zipper> Oh hahaha Welkin it was that simple.
16:15:18 <arkeet> there is no way to not export/import an instance.
16:15:23 <arkeet> that is not the problem.
16:15:35 <zipper> It shouldn't have allowed him to directly construct values of type Queue then
16:15:39 <arkeet> he didn't.
16:15:40 <jstimpfle> Queue(..) syntax specifies what constructors of a data type are exported (.. means all)
16:15:51 <zipper> arkeet: Queue(..)
16:16:06 <arkeet> he's using the queue function (from the Queue module) to construct his Queue.
16:16:11 <arkeet> no constructor involved.
16:16:19 <zipper> I use it every time I export a type.
16:16:23 <arkeet> besides, that wouldn't cause that error.
16:16:35 <zipper> arkeet: hmmmm
16:17:03 <arkeet> Briann: I think ghci just isn't loading the code you think i tis.
16:17:22 <zipper> Is there a way to ensure that a is an instance of Show when declaring the type Queue?
16:17:50 <arkeet> zipper: yes, but it's a bad idea, because it gains you nothing.
16:17:52 <Briann> i think it imports it fine, if i make an error in my module it doent import it
16:18:00 <jstimpfle> Briann: you should really post you complete Main.hs (at least the function in which you print)
16:18:13 <Welkin> I don't know how the autoderived Show instance looks
16:18:25 <jstimpfle> I suppose at the position where you print the Show constraint on type "a" just isn't there
16:18:26 <arkeet> fortunately you don't have to.
16:18:31 <Welkin> anyway, it is better to compile it to a binary and execute it instead
16:18:32 <Briann> well, its not really a main, it's a queue-test.hs 
16:18:44 <Welkin> write all of that in your main function to test it and just run the executable
16:18:53 <jstimpfle> Briann: just post it, don't hide it
16:18:59 <Briann> http://lpaste.net/142379
16:19:26 <Welkin> Briann: you can edit your previous pastes rather than creating brand new ones
16:19:28 <Briann> test2 it's the one that doesn't show
16:19:35 <lpaste> arkeet pasted “works for me” at http://lpaste.net/8131805183748341760
16:19:36 <jstimpfle> there's no print in there
16:19:41 <Briann> i didn't know, sorry
16:19:57 <jstimpfle> oh, sorry, it's in ghci
16:20:37 <jstimpfle> _and_ it's Integer. sorry
16:23:02 <hunteriam> anyone help me with scary build failure?
16:23:16 <hunteriam> http://lpaste.net/142381
16:24:20 <johnw> something similar: https://github.com/haskell/cabal/issues/1950
16:26:01 <jstimpfle> so I can't reproduce the error here. The expression works just fine if I make two files and fire up ghci
16:26:19 <hexagoxel> `runIdentity $ flip evalStateT d $ fmap (uncurry ($>)) $ runWriterT $ runStdCalinFetcher $ runEitherT $ (pushStack stackframe >> k)`
16:26:19 <jstimpfle> did you reload your files?
16:26:28 <hexagoxel> Monad transformer stacks are fun!
16:28:28 <hiptobecubic> jeebus
16:41:26 <hexagoxel> hunteriam: the most common cause of linker errors probably is missing exposed modules
16:41:42 <hexagoxel> what does the .cabal look like?
16:47:56 <broma0> Does anyone have a string literal parser for attoparsec lying around? one that handles all the escape sequences and whatnot
16:59:19 <Gurkenglas> If old-time won't build on my Windows, could I use a prebuilt old-time file instead to build ghc-mod?
17:01:49 <Hafydd> ...
17:02:41 <zipper> You know what I hate. When dependencies go seamlessly locally only to fail on travis.
17:02:48 <zipper> So pissed off.
17:09:50 <gfixler> main = getPOSIXTime >>= print >> main
17:09:56 <gfixler> any idea why that gets locked into a holding pattern?
17:10:14 <hpc> as in no output?
17:10:47 <gfixler> hpc: no, it fills the screen with numbers
17:10:51 <gfixler> but then they never change
17:11:14 <hpc> what happens if you insert a minimal threadDelay?
17:11:45 <gfixler> hmmm, it seems to be changing, but displaying non-changing
17:11:50 <gfixler> if I scroll back in the output
17:11:58 <gfixler> how do I insert a delay?
17:12:04 <hpc> :t threadDelay
17:12:05 <lambdabot> Not in scope: ‘threadDelay’
17:12:12 <hpc> @hoogle threadDelay
17:12:14 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
17:12:14 <lambdabot> GHC.Conc.IO threadDelay :: Int -> IO ()
17:12:14 <lambdabot> GHC.Conc threadDelay :: Int -> IO ()
17:12:31 <hpc> (it takes microseconds because code conventions are a suuggestion :P)
17:15:06 <Hafydd> It produces a constantly changing output for me, which increments once every second.
17:15:30 <Hafydd> On Linux x64.
17:15:53 <gfixler> hpc: fascinating - delays from 1 through 4 - no change - but at 5, it starts printing as expected
17:16:08 <gfixler> without it, it prints one screen, then no more
17:16:19 <gfixler> if I stop it, then the screen updates finally
17:16:31 <gfixler> Hafydd: OS? I'm on a MacBook
17:16:44 <Hafydd> gfixler: Arch Linux.
17:16:57 <gfixler> Hafydd: yeah, this worked fine at home on my Linux box (Ubuntu)
17:17:03 <Hafydd> I see.
17:19:18 <Hafydd> eazar001: what are you doing?
17:19:34 <eazar001> Hafydd, my bad
17:19:42 <eazar001> stupid testing in ##prolog
17:19:44 <Gurkenglas> :t forever -- gfixler, consider using this instead of explicit recursion
17:19:45 <lambdabot> Monad m => m a -> m b
17:19:47 <Hafydd> Heh.
17:19:55 <eazar001> i just did a hotfix
17:20:30 <squall> I have looked into havlm and found it is bare metal, can I run it on Windows?
17:21:17 <squall> Well can is bare metal, can I run havlm not on xen?
17:21:44 <squall> Xen is bare metal sorry
17:22:31 <gfixler> Gurkenglas: will do - just playing atm
17:30:29 <gfixler> alright, enough of this XY Problem
17:30:41 <gfixler> how do people get clock ticks for game loops in Haskell?
17:30:54 <gfixler> something like millis() in other languages
17:34:06 <sm> gfixler: what ever game lib you pick probably provides it
17:35:57 <sm> eg https://hackage.haskell.org/package/sdl2-2.0.0/docs/SDL-Raw-Timer.html
17:37:22 <gfixler> sm: I suppose, if I were using one
17:44:15 <greg`> anyone using HaRe
17:44:21 <greg`> just installed it
17:44:47 <athan> greg`: I want to o_o
17:44:52 <athan> I just don't use emacs :\
17:45:08 <greg`> athan: there is always evil-mode
17:45:25 * athan says "lalalalalala" with his ears plugged
17:45:51 <greg`> lol
17:46:58 * Welkin places a dripping bloody heart in athan's coat pocket
17:47:29 * Pamelloes wonders where said heart originated....
17:47:35 <athan> I love you too Welkin :)
17:48:47 <Welkin> lala la-lala-la
17:50:06 <cloudmonk> I’m new to Haskell and learning monads so this may seem like a silly question but what is the opposite of lift? For example, I have a function that I want to return a Bool and within that function I use a another function that returns an IO Bool
17:51:09 <shachaf> You can't do the thing you want to do.
17:51:17 <cloudmonk> lol, easy answer
17:51:46 <taylorhamcheese> #javascript
17:52:12 <greg`> cloudmonk: this is why they say you cannot escape the monad
17:52:18 <cloudmonk> In that case, can I print an IO Bool?
17:52:35 <greg`> yes, is the simple answer
17:52:36 <Welkin> sure, if you unwrap the bool
17:52:46 <shachaf> What would it look like?
17:52:51 <shachaf> @quote /bin/ls
17:52:51 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
17:52:57 <Welkin> myIOBool >>= print
17:52:59 * athan coughs up a comonad
17:53:14 <athan> It's all bloody D: Welkin YOU CURSED ME
17:53:38 <Welkin> athan: you have a dog and a traffic cop with a creepy mask though!
17:53:57 <greg`> you can >>= the IO Bool to println
17:54:04 <Pamelloes> :t (>>=)
17:54:05 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:54:19 <greg`> println ? lol
17:54:24 <athan> could a monad ~ anamorpism, while comonad ~ catamorphism? In any way? :|
17:54:26 <Welkin> putStrLn
17:55:05 <greg`> IO Bool >>= putStrLn 
17:55:17 <greg`> to give you IO ()
17:55:32 <athan> well
17:55:39 <arkeet> no, putStrLn takes a String.
17:55:42 <Pamelloes> greg`: errr putStrLn takes a String
17:55:53 <arkeet> but you can use print.
17:55:56 <arkeet> :t (>>= print)
17:55:57 <lambdabot> Show a => IO a -> IO ()
17:56:07 <greg`> what arkeet said
17:56:08 <athan> fmap show (IO Bool) >>= putStrLn :D
17:56:32 <arkeet> or ... >>= putStrLn . show
17:56:40 <greg`> details, details :P
17:56:50 <arkeet> @src print
17:56:50 <lambdabot> print x = putStrLn (show x)
17:57:11 <Pamelloes> greg`: what is the world if not an endless collection of details?
17:57:31 <athan> Pamelloes: Way to generalize it! <.<
17:57:39 <Welkin> Pamelloes: the universe is finite!
17:57:47 <Welkin> it is not endless
17:58:00 <arkeet> finite things can be endless.
17:58:14 <arkeet> e.g. a circle
17:58:33 <Welkin> that is not endless
17:58:39 <arkeet> where are the ends?
17:58:53 <Welkin> endless, meaning infinite
17:59:07 <greg`> anyone know where the documentation for HaRe is? I've installed it but dont know the shortcuts
17:59:30 <athan> co-end?
18:00:05 <greg`> can anyone provide a practical use of a comonad?
18:00:23 <Pamelloes> Welkin: Why do you believe the universe is finite? We can point to a beginning, but can we point to an end? Can we point to the edge of the observable universe and say this is where everything ends?
18:01:01 <Pamelloes> Perhaps it is finite but perhaps not.
18:01:11 <athan> greg`: Sure, the Reader comonad ~ (r,a): you populate `r` initially, then have read-only access from `a`. Then, when you're done, you extract `a` out
18:01:42 <Welkin> Pamelloes: because the energy in the universe is finite
18:01:43 <greg`> athan:  will ruminate on that , thanks
18:02:02 <Welkin> there is a possibility of an infinite multiverse, of which our universe is a member
18:02:13 <Pamelloes> Well there you go.
18:02:31 <athan> metafinite
18:02:32 <Pamelloes> Anyways, I wasn't speaking literally earlier—I was exaggerating a bit to make a point.
18:02:50 <Pamelloes> Well, an infinite amount technically but whatever.
18:03:10 <athan> lol
18:07:31 <erisco> anyone know of articles for "why immutability" or "why persistent data structures"?
18:07:55 <greg`> que?
18:19:57 <Gurkenglas> Welkin, how do you know energy is finite?
18:19:58 <jmmk> Is there a reason that so much Haskell code uses unqualified imports? Makes it really hard (for a beginner anyway) to tell if functions are being imported and where they are being imported from, or if they are defined somewhere else in the file
18:21:03 <dmj`> jmmk: calling ':i <function>' should tell you where it came from
18:21:08 <dmj`> in ghci
18:21:50 <gfixler> jmmk: laziness
18:22:15 <jmmk> gfixler: so it's not considered good practice then? It almost seems idiomatic I see it everywhere
18:22:16 <gfixler> jmmk: you can also get into a bit of micromanagement as you stop using qualified things
18:22:36 <gfixler> jmmk: I haven't heard of it being good practice. I tend to qualify, and agree it helps.
18:23:28 <Cale> One thing about qualified imports that makes me avoid them (really) is that the module path separator is '.'
18:23:32 <hpc> eventually you reach a point where you know where everything is
18:23:40 <Cale> Which makes compositions look terrible
18:24:03 <Cale> When you use the (.) infix operator a lot, and then also have module qualifications, it's kind of annoying to read
18:24:25 <hpc> only if you don't put whitespace around your operators like a heathen
18:24:26 <Cale> I'll qualify some stuff, especially the things which need to be qualified
18:24:56 <athan> Cale: I agree. I would even do something like `mapFromList = Map.fromList` if it's for other people
18:24:57 <Cale> No, even if you do, it's not as nice as unqualified
18:25:28 <Cale> (I do put spaces around all the composition operators)
18:25:48 <Cale> I also absolutely can't stand seeing qualified names in types for some reason
18:25:53 <dmj`> qualified imports are hard on the eyes
18:25:55 <Cale> This is less rational
18:26:06 <Cale> I just personally don't like it at all
18:26:37 <athan> I've gotten used to `T.Text` and `LBS.ByteString`, though
18:26:49 <Cale> I don't qualify Text
18:26:51 <Welkin> lol athan
18:26:55 <Cale> I'll just import the Text type separately
18:27:03 <Welkin> I always import twice for Data.Text and ByteString
18:27:06 <Cale> import Data.Text (Text)
18:27:12 <Welkin> once qualified and once unqualified for the types
18:27:14 <Cale> import qualified Data.Text as T
18:27:14 <hpc> ive gotten really lazy and just do import Data.Text as T
18:27:20 <hpc> then ambiguous stuff as whatever
18:27:22 * geekosaur wonders how dislike of qualified types correlates with exposure to Henning types >.>
18:27:24 <athan> :P
18:27:27 <athan> lazyness ftw
18:27:35 <Welkin> but hey, if you use classy-prelude, you can avoid much of those qualified imports!
18:27:38 <hpc> it's not like i would ever use the other ambiguous stuff unqualified at that point either
18:27:55 <Welkin> it has pack, elem/notElem, show, and many more functions that are generalized to work with everything
18:28:40 <athan> hpc with a `hiding` 30-tuple :P
18:28:47 <hpc> nah
18:32:32 <awpr> jmmk: for what it's worth I have a rule that every namespace has 0 or 1 modules imported without an import list.  then for any call you can find the containing module by hitting 'gd' (in Vim) or chasing the sole open import of the namespace.
18:36:49 <AdolfHitlr> what is the most elegant virus in haskell ever written?
18:42:00 <athan> Probably something that infects the GHC typechecker somehow, cause we're nerds :\
18:42:18 <AdolfHitlr> hmm interesting
18:42:24 <AdolfHitlr> i woul dlike to learn how to do that :)
18:44:17 <ttt_fff_> Use list comprehension Found: if e then ["editing"] else [] Why not: ["editing" | P.e]  
18:44:23 <ttt_fff_> how does this work? wtf is P.e ?
18:44:26 <ttt_fff_> and why does it work ?
18:44:45 <awpr> ttt_fff_: is 'e' from a module imported qualified as P?
18:44:54 <dmj`> > [ 3 | True ]
18:44:55 <lambdabot>  [3]
18:45:02 <dmj`> > [ 3 | False ]
18:45:03 <lambdabot>  []
18:45:06 <ttt_fff_> awpr: no, it's a local var
18:45:15 <ttt_fff_> dmj`: never realized list comprehensions worked this way
18:46:07 <awpr> weird, I'm not sure why it formatted it that way.  but yeah, list comprehensions can have guards and they don't have to have an "<-"
18:47:57 <Darien> > [3|]
18:47:58 <lambdabot>  <hint>:1:4: parse error on input ‘]’
18:48:04 <Darien> > [3 | ]
18:48:06 <lambdabot>  <hint>:1:6: parse error on input ‘]’
18:48:09 <awpr> (they have to have *something*)
18:48:32 <Darien> just wondered if that was the base case
19:07:34 <hunteriam> Hey guys, is there anyone here who will answer a couple of questions about GSOC?
19:07:41 <hunteriam> trying to work out what I ought to do next summer
19:08:07 <hunteriam> Alternately, anyone who can tell me about Jane Street and whos a good fit for an internship there?
19:10:38 <erikd> hunteriam: ask about GSoC anyway. may be someone here who can answer.
19:10:54 <hunteriam> Well I was just wondering what kinds of people are good fits for GSOC
19:10:59 <hunteriam> like undergrad, grad, etc.
19:11:08 <hunteriam> And if we needed our own ideas for projects
19:11:18 <hunteriam> Or if there was some collection to choose from
19:11:32 <erikd> hunteriam: that is very much project specific and the projects are usually proposed by the mentors.
19:11:41 <hunteriam> How do you get a mentor?
19:11:53 <hunteriam> And are there often projects suitable for undergrad students?
19:12:28 <erikd> when the time comes, there will be a bunch of projects (each suggested by one or more mentor) and you apply to the student for that project.
19:12:41 <hunteriam> Is it tough to get a spot usually?
19:12:49 <erikd> yes, there have been undergrads doing projects in the past.
19:13:21 <erikd> not sure how tough it is. haven't been at either end of the GSoC process, but thinking of being a mentor next year
19:13:37 <hunteriam> Do you think its better for someone whos not entirely sure if theyd rather do research or work (longterm) to do a gsoc or internship?
19:13:48 <hunteriam> Sorry ive got more than i thought to ask about
19:13:50 <hunteriam> haha
19:14:09 <hunteriam> Although i lean towards doing research
19:14:26 <erikd> i think both have value that is very much dependent on the project/internship
19:14:54 <hunteriam> I don't really know what I should prioritize
19:15:05 <hunteriam> I've got no clue whats going to matter in 2 years
19:15:16 <hunteriam> or, not much clue
19:15:50 <erikd> good work is good work regardless of whether its GSoC or an internship, but GSoC results are more public which is probably a good thing.
19:17:01 <hunteriam> Well, thanks erikd! Do you know when the GSoC process begins?
19:17:13 <erikd> sorry, not idea
19:17:40 <hunteriam> Well, thanks anyways
19:17:54 <hunteriam> I'm probably safest applying to both so I get a good shot at having SOMETHING to do this summer
19:18:03 <erikd> yes
19:18:33 <erikd> by "this summer" you mean southern or northern hemisphere summer?
19:18:54 <hunteriam> northern
19:19:00 <hunteriam> its a long ways off for sure
19:19:03 <erikd> ah ok.
19:19:08 <hunteriam> but last summer I did nothing and my parents were scarred
19:19:28 <erikd> i'm in the southern hemisphere so summer is pretty close :-)
19:22:15 <EvanR> is there a GSOC-south?
19:22:30 <erikd> EvanR: thats why i was asking. i wasn't sure.
19:22:44 <EvanR> if so then im not late, im just in time!
19:23:16 <EvanR> as soon as we spike B.A.'s milk and get murdock to fly me down there
19:23:44 <usr> murdoch
19:26:34 <skatenerd> Hey folks, I'm an "end of file" error with hdevtools-vim
19:26:52 <skatenerd> it looks like I should be using a newer GHC, but I'm dumb and not sure where to start
19:26:55 <skatenerd> (on ubuntu)
19:27:18 <Shockk> I've got a quick question
19:27:19 <lpaste> Shockk pasted “No title” at http://lpaste.net/4073907429513887744
19:27:56 <Shockk> I'm getting an error due to overlapping instances for a function I want to use that's in a typeclass
19:28:57 <Shockk> I'm writing a function that has a return type involving `a' as seen in that lpaste I just posted
19:29:48 <Shockk> the error says I can use IncoherentInstances to pick the first instance above, but that seems to imply it'll always pick the first rather than pick the appropriate instance depending on what `a' is
19:33:39 <Shockk> oh, I solved the problem
19:34:17 <Shockk> I think the problem was that one instance was constrained by Read whereas the other two weren't
19:34:52 <Shockk> I wrapped my own getConfig function in its own typeclass and wrote the same instances for it
19:38:40 <kristof> I was showing a friend how to do something and I really wanted to write the second vesrion of this, but ended up doing the first.
19:38:42 <kristof> http://hastebin.com/arileruyar.hs
19:39:03 <kristof> Am I a bad person for liking the second version more? Am I just sick?
19:40:03 <bitemyapp> kristof: both are pretty common
19:40:29 <bitemyapp> kristof: you're asking a question that is comparable to, "I like chocolate cake! Some people prefer other flavors. Am I sick?"
19:40:33 <bitemyapp> kristof: the answer is no.
19:41:24 <bitemyapp> kristof: thank you for using that site, the dark background is much appreciated.
19:42:13 <kristof> bitemyapp: I like hastebin a lot. :)
19:42:37 <kristof> bitemyapp: The suffixes are changeable, so it'll just apply syntax highlighting rules for whatever language you specify
19:45:03 <darkstalker> pastes should be browseable from inside your text editor
19:52:01 <kristof> darkstalker: There's a raw version
19:52:12 <kristof> darkstalker: Not that I agree with what you said. Also, hello, you still on #rust? :P
19:52:24 <darkstalker> yea, thats me
20:05:44 <Big_G> bitemyapp, The only correct answer is icecream cake
20:07:04 <Shockk> is there any reason `threadDelay' is hanging forever on values such as 10000 and 1000000 microseconds?
20:07:41 <Shockk> if I pass 1000 to it, it delays for 1 millisecond as expected
20:07:49 <EvanR> maybe you forgot that you multiplied by 1000000 or 1000 already
20:07:50 <bitemyapp> glguy_: did I lose you?
20:08:04 <Shockk> EvanR: I'm talking about literally this line of code
20:08:13 * hackagebot streaming 0.1.1.1 - an elementary streaming prelude and a general monad transformer for streaming applications.  https://hackage.haskell.org/package/streaming-0.1.1.1 (MichaelThompson)
20:08:20 <Shockk>     liftIO (threadDelay 10000)
20:08:52 <Shockk> oh wait, it *might* actually be output buffering or something
20:09:07 <EvanR> flush or output a newline
20:09:17 <EvanR> wow this megaparsec library looks pretty bad-ass
20:09:24 <Shockk> think I need to set the buffering mode to LineBuffering
20:10:46 <Shockk> ah great that worked, thanks EvanR 
20:30:56 <bollu> in Pipes, the type has input, a "result" (that it spits out), and an "output" ?
20:31:13 <bollu> I'm confused as to why there is both a result and a downstream
20:39:17 <johnw> bollu: it has to do with how monads work
20:40:08 <johnw> bollu: there's a type that you "await" from upstream, a type that "yield" to downstream, and a value you might pass to "return", and that might result from a lifted action.  These are three separate types.
20:40:56 <bollu> oh, okay. 
20:41:02 <bollu> aren't there.. 5?
20:41:15 <johnw> that's for the bidirectional use of pipes, which you normally don't use
20:41:21 <bollu> ah, right
20:41:30 <bollu> but.. the most general "Proxy" type has 5, correct?
20:41:39 <johnw> plus a 6th for the underlying monad type
20:41:48 <johnw> a' a b' b m r
20:43:57 <pavonia> Is there a way to get a list of all non-terminated threads for debugging purposes?
20:44:30 <dmj`> :t threadStatus
20:44:31 <lambdabot> Not in scope: ‘threadStatus’
20:45:53 <dmj`> pavonia: you can query a thread's status with GHC.Conc.threadStatus
20:46:20 <dmj`> if using async there's 'asyncThreadId'
20:46:28 <pavonia> But that only works if I know its idea
20:46:31 <pavonia> *ID
20:47:02 <dmj`> yes
20:47:45 <EvanR> better save those ids!
20:48:05 <dmj`> pavonia: unsure of a way to count thread state objects in ghc, might be possible
20:48:10 <pavonia> I'm using a package that starts several threads internally and I would like to see if all of them terminate properly
20:49:39 <EvanR> that would be a brutal invasive way to use the package
20:53:02 <pavonia> EvanR: Why "brutal invasive"?
21:01:10 <Fylwind> is there like a "standard" regex library that Haskellers use?
21:01:36 <johnw> Fylwind: that's actually a good question
21:01:44 <johnw> I haven't used a regexp library in Haskell in really long time
21:01:54 <johnw> pcre-light seems pretty popular
21:01:57 <Fylwind> there's so many of them and I don't have any particularly stringent requirement other than a library that works and hasn't collected dust
21:02:11 <johnw> what about unicode, does that matter to you?
21:02:34 <Fylwind> not for this particular purpose, though I would prefer a unicode friendly one
21:02:37 <johnw> most of the time, you can do better with parsecor some other function
21:02:54 <Fylwind> I can … but Parsec is a bit overkill for this
21:03:05 <johnw> what is it that you want to do?
21:03:23 <Fylwind> match [A-Za-z_][A-Za-z_0-9]*, that's it.
21:03:43 <johnw> ah, a symbol identifier
21:03:46 <Fylwind> basically
21:05:13 <johnw> liftA2 (:) (alphaNum <|> char '_') (many (alphaNum <|> char '_' <|> digit))
21:06:52 <johnw> that also works for regex-applicative, btw
21:07:10 <kristof> Speaking of <|>
21:07:19 <kristof> Why is there monadPlus AND Alternative?
21:07:27 <Fylwind> historical reasons?
21:07:36 <kristof> Are they ever different?
21:07:50 <kristof> In the same way that liftA2 and liftM2 are *not* different
21:08:00 <Fylwind> I would not expect them to be, but there's nothing stopping someone from doing something weird
21:08:26 <kristof> :c
21:08:47 <kristof> It also strikes me odd that people still write applicative and functor instances using do syntax
21:08:54 <kristof> at least in tutorials.
21:09:12 <kristof> LYAH is especially guilty. It's like "No, you've got it all backwards."
21:09:19 <Fylwind> http://stackoverflow.com/a/10168111/440302
21:09:36 <Fylwind> ekmett says that MonadPlus is a little bit stronger than Alternative, so there is still a distinction I guess
21:11:26 <kristof> Hm, okay
21:13:15 * hackagebot renderable 0.1.0.0 - Provides a nice API for rendering data types that change  over time.  https://hackage.haskell.org/package/renderable-0.1.0.0 (SchellScivally)
21:24:24 <EvanR> MonadPlus requires a Monad where Alternative requires only Applicative
21:24:56 <EvanR> so i guess you dont need MonadPlus
21:27:19 <nolrai666> Monad plus requires different laws I think.
21:27:20 <EvanR> applicative came out later so MonadPlus is a hold over
21:27:26 <EvanR> there are laws?
21:30:29 <EvanR> https://wiki.haskell.org/MonadPlus_reform_proposal
21:55:16 <elliptic00> does anyone know a simple Haskell web framework? I'm new to Haskell and want to use the framework to learn Haskell, any suggestion would be appreciated!
21:55:39 <liste> elliptic00 scotty
21:55:52 <liste> @hackage scotty
21:55:52 <lambdabot> http://hackage.haskell.org/package/scotty
21:56:10 <elliptic00> I try to install it, but get some independency issues,
21:56:25 <liste> how did you install it? did you use stack or cabal sandboxes?
21:56:29 <liste> (or stackage)
21:57:04 <elliptic00> yes, I use Cabal, and install in Sanboxes and still get dependency issues
21:57:13 <Hijiri> do you have platform?
21:58:10 <elliptic00> what do  you mean? #Hijiri
21:59:26 <elliptic00> I just install on my Macbook, 
22:00:00 <elliptic00> does anyone try Spock Framework?
22:01:18 <athan> elliptic00: You should start using stack, it has better support
22:01:39 <athan> I've heard Spock is a good framework, but I authored nested-routes, so I may be biased :)
22:01:48 <liste> elliptic00 spock is similar to scotty, but it uses advanced concepts (type families) to achieve great type safety
22:02:11 <johnw> servant also looks fun
22:02:21 <elliptic00> I'm new to Haskell, so I'm looking for something simple
22:03:10 <ReinH> servant is really cool
22:04:58 <athan> elliptic00: I suggest Scotty then if you're new
22:05:23 <nitrix> Scotty is great.
22:06:05 <elliptic00> thanks all the suggestions
22:08:17 * hackagebot gooey 0.1.0.0 - Graphical user interfaces that are renderable,  change over time and eventually produce a value.  https://hackage.haskell.org/package/gooey-0.1.0.0 (SchellScivally)
22:12:11 <jle`> EvanR: yes, there are extra laws for MonadPlus that Alternative doesn't have
22:12:15 <jle`> so it's still technically necessary
22:12:38 <jle`> it's basically an empty typeclass that offers only laws
22:13:47 <EvanR> namedly this law (in addition alternative = "applicative monoid")?
22:13:48 <EvanR> mzero >>= k = mzero
22:14:20 <EvanR> according to that wiki page people dont seem to agree on much else
22:14:37 <jle`> yeah, i think there's another law involving the distributability of >>= over <|>
22:15:01 <EvanR> mplus a b >>= k = mplus (a >>= k) (b >>= k)
22:15:27 <jle`> in theory one could have a type with a valid instance of Alternative and Monad, but no valid instance of MonadPlus (or an instance of MonadPlus where mplus /= (<|>), so also invalid)
22:16:00 <EvanR> > mplus (Maybe 1) (Maybe 2)
22:16:01 <lambdabot>      Not in scope: data constructor ‘Maybe’
22:16:02 <lambdabot>      Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)    Not in ...
22:16:02 <lambdabot>      Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
22:16:09 <EvanR> > mplus (Just 1) (Just 2)
22:16:11 <lambdabot>  Just 1
22:16:20 <wedens> what is portable approach to read file in non-utf encoding and convert result to utf?
22:16:53 <athan> In FRP-lingo, is a Signal the same thing as an Event? Where `Signal a ~ Time -> a` - a value indexed for any time?
22:16:54 <liste> wedens do you know the encoding?
22:17:05 <wedens> liste: yes
22:17:12 <Hijiri> athan: no
22:17:19 <Hijiri> events happen at specific points in time
22:17:20 <EvanR> wedens: try the encoding package
22:17:33 <jle`> wedens: maybe bytestring to text?
22:17:35 <Hijiri> signals(/behaviors) have a behavior at any time
22:17:41 <athan> Hijiri: So an `Event a ~ (Time, a)`?
22:17:47 <Hijiri> something like that
22:17:48 <athan> ahhh okay
22:17:55 <athan> thank you
22:17:56 <jle`> athan: type Event a = (Time, a)
22:17:57 <EvanR> Event a = [(Time,a)]
22:18:02 <jle`> er, yeah
22:18:04 <jle`> [(Time, a)]
22:18:09 <jle`> type Behavior a = Time -> a
22:18:12 <Hijiri> oh yeah
22:18:14 <athan> EvanR: Oh okay, so there are multiple
22:18:24 <athan> Are you sure it's not a unique mapping?
22:18:26 <athan> Map Time a?
22:18:26 <EvanR> its like the entire history of occurrences
22:18:27 <Hijiri> there was that one paper where event was (Time, a) though
22:18:33 <athan> hmm
22:18:45 <EvanR> multiple occurrences at the same time may or may not be permitted by your model
22:18:47 <Hijiri> and I guess frpnow though
22:18:50 <wedens> EvanR: I'll have a look. thanks.
22:18:58 <jle`> the original paper has it as [(Time, a)]
22:19:05 <athan> EvanR: Very interesting, thank you
22:19:31 <EvanR> if you have multiple at the same time, you have to decide if its ordered within that moment, or if its all simultaneous, i.e. you cant depend on any ordering
22:19:44 <EvanR> which would be interesting
22:20:13 <athan> EvanR: Events are only interesting if you're doing the plumbing of handling them, though, correct?
22:20:26 <EvanR> they are pretty interesting regardless i think
22:20:26 <athan> Where behaviours are more application design-oriented?
22:20:47 <EvanR> you think of events as happening when certain conditions are met by the behaviors
22:21:00 <athan> AH
22:21:05 <athan> wow, okay
22:21:32 <EvanR> like the progress bar has reached the end of the slot
22:21:33 <jle`> EvanR: you mean when certain conditions change, right?
22:21:37 <athan> so `Event \subseteq Behavior`?
22:21:50 <EvanR> jle`: well i think thats getting into some implementation details
22:22:00 <athan> hmm
22:22:03 <jle`> athan: i wouldn't say that
22:22:12 <jle`> EvanR: you can't have an event that is, "whenever this behavior is greater than 0"
22:22:31 <EvanR> well in "functional reactive animation" paper, you can
22:22:36 <jle`> you can have an event that is, "whenever this this behavior switches from positive to negative"
22:22:37 <EvanR> using predicate events
22:23:18 * hackagebot yesod-raml 0.1.4 - RAML style route definitions for Yesod  https://hackage.haskell.org/package/yesod-raml-0.1.4 (junjihashimoto)
22:23:21 <jle`> i'm looking at the paper now
22:23:23 <athan> thanks guys :)
22:23:27 <EvanR> you implement it so that the system freezes up when a signal becomes uniformly true after some point
22:23:40 <EvanR> which would suck
22:24:06 <EvanR> you can also get into trouble by limiting things to "when a condition changes"
22:24:11 <jle`> an Event is semantically a [(Time, a)], so event that describes "whenever the signal is positive" makes no sense
22:24:38 <EvanR> "when a condition changes" has the same problem
22:25:03 <jle`> so maybe simple labels like this aren't the best, heh
22:25:28 <jle`> where does "when a condition changes" fall through?
22:25:58 <EvanR> when i was doing game programming, i always thought of the rectangle collision system as necessarily "changing the color/class" of a rectangle at the time of a collision to prevent infinite loops, infinite occurrences
22:26:06 <jg> hi all, i'm using Stack with Hspec. Is there a way to run just one FooSpec.hs file?
22:26:21 <EvanR> i dont know how to generalize that to arbitrary functions of real time
22:26:56 <jle`> well, that's a part of the limits of your implementation
22:26:57 <EvanR> jle`: so the condition might have the values Red Green or Blue right and you can say ok, whenever it changes (discretely) thats an occurrence
22:27:04 <EvanR> that makes sense
22:27:25 <EvanR> but if the condition is Real-valued, that could be changing continuously
22:28:03 <jle`> yeah, but assuming it's real-valued and continuous and well-behaving, the event still is semantically defined
22:28:09 <jle`> it just is tricky at the implementation level
22:28:26 <EvanR> it has the same occurrence sequence as a "always true" Bool signal
22:28:41 <athan> jg: It's a bit tricky, Hspec has this weird auto-searching mechanism that's not really intuitive
22:29:11 <athan> jg: If you're testing your own _pure_ code, I suggest using tasty as a wrapper around Hspec / Hunit, to get a cleaner Main function
22:29:12 <jle`> how do you mean?
22:29:12 <EvanR> jle`: you also get into trouble if you limit yourself to only Bool-valued condition signals, there was a nice paper about this
22:29:34 <athan> jg: For more info, check out my hi template at https://github.com/athanclark/hi-quickcheck-lib
22:29:49 <jle`> well, i'm not talking about limiting anything; i'm just saying that an event that describes moments when well-behaved behaviors cross from negative to positive are well-defined
22:29:55 <EvanR> jle`: well what does the sequence look like for "whenever f(t) = t changes" ?
22:29:56 <jle`> positive to non-negative
22:30:16 <jle`> that's not a well-defined event
22:30:21 <EvanR> that particular kind of transition can also get into trouble
22:30:47 <jle`> but an event that describes when f(t) = t becomes non-negative is a well-defined event
22:31:08 <EvanR> it might be
22:31:17 <EvanR> even if it is thats a very special circumstance
22:31:41 <jg> athan: thanks! so using Tasty i'd just create a spec group with that one spec i want to work with?
22:31:45 <athan> EvanR, jle`: Have either of you guys tried Elm? Their Signal function is Applicative-only - do you have any opinions of that design?
22:31:56 <jle`> but an event that describes "whenever f(t) = t is positive" is definitely not a well-defined event
22:32:16 <jle`> athan: what do you mean by Applicative-only?
22:32:20 <athan> jg: Yep, that's right. You might have to do some searching to find which wrapper code you need, but the package is `tasty-hspec` I think
22:32:29 <athan> jle`: In Elm, Signal is not a monad
22:32:33 <jle`> oh
22:32:39 <jle`> that makes perfect sense to me
22:32:48 <athan> same here :)
22:32:52 <EvanR> jle`: consider f(0)=0, f(t) = sin(1/t)
22:33:03 <EvanR> or f(t) = isrational(t)
22:33:17 <jle`> f(t) = isrational(t) is not a behavior
22:33:24 <EvanR> why not
22:34:02 <EvanR> if this whole time youve only been talking about continuous real-valued functions then that sounds like a limitation ;)
22:34:10 <jle`> hm
22:34:28 <jle`> let me rethink this :)
22:34:39 <jle`> okay, so it's a behavior
22:34:41 <EvanR> and the sin(1/t) thing can be made continuous if necessary and still get mess ups
22:35:05 <EvanR> sin(1/t) / t, unless t=0 in which case 0
22:35:20 <EvanR> er t * sin(1/t)
22:35:54 <EvanR> that would give an "extra-infinite" occurrence sequence
22:35:57 <jle`> so you're saying that "when the bhavior transitions from negative to non-negative" is not well-defined for those behaviors
22:36:19 <EvanR> i would say its well defined
22:36:30 <EvanR> but the occurrence sequence model definitely has issues
22:36:56 <EvanR> ideally an implementation would freeze up at this point
22:37:18 <EvanR> but in functional reactive animation i believe his implementation would mess some events
22:37:22 <EvanR> miss
22:37:52 <EvanR> hmm maybe not, it might freeze up
22:37:59 <EvanR> unable to get past the first occurrence
22:38:35 <wolftune> how do I remove GHC 7.8.4 I installed manually from a .deb from the site on Ubuntu? I'm only using 7.10 now…
22:39:34 <athan> wolftune: you can't `sudo apt-get remove ghc` it?
22:39:42 <wolftune> nope
22:39:48 <athan> if anything, you can `which ghc` to find the binary, and mash it
22:39:57 <wolftune> I don't even see ghc in synaptic
22:40:23 <wolftune> yeah, I tried which ghc, just was hesitant to rm that if there's a cleaner way
22:40:32 <wolftune> there's a few related ghc things too…
22:40:36 <athan> Also, you can `sudo updatedb && locate ghc | grep 7.8` to find it too
22:41:04 <athan> wolftune: You should be OK - if you got 7.10 with stack, they install in their own isolated directoryu
22:41:54 <wolftune> athan: indeed, yeah
22:42:02 <wolftune> easy to reinstall besides
22:42:45 <EvanR> jle`: uhg internet
22:43:01 <athan> wolftune: :) If you still have the .deb, I think the deb installer also brings up a "reinstall / remove" prompt
22:43:29 <EvanR> jle`: so t*sin(1/t) does have occurrences but youd need something like 4 lists to get them all
22:43:38 <jle`> EvanR: yeah, i can see why the modeling of it as a [(Time, a)] would be tricky in practice and maybe inthjeory too
22:43:40 <EvanR> going forward and backwards from both sides of 0
22:44:14 <jle`> you'd have to drop an infinite amount of events just to get past t=1
22:44:25 <EvanR> and perhaps you can divide up regions like this and have countable number of lists for any continuous functions
22:44:26 <Romfeller> Hey guys
22:44:39 <liste> hey Romfeller
22:44:42 <EvanR> some going forward, some backwards
22:45:22 <Romfeller> someone have ever used simplemail'? Anyone knows why the mail body has the value Text [79,108,225,32,82,111,109,101,102,101,108,108,101,114,33] ?
22:45:25 <Romfeller> lol
22:45:56 <Romfeller> Network.Mail.Mime
22:46:00 <EvanR> jle`: Fran get around all this by doing interval analysis which seems very clever
22:46:10 <jle`> and semantically sound too :O
22:46:27 <EvanR> and it allows arbitrary bool-valued conditions
22:46:55 <EvanR> in this case signal == 0 would be the condition
22:47:27 <EvanR> it would have an occurrence at t=0
22:47:38 <ttt_fff_> how do I learn what MonadFix/mfix does ?
22:47:47 <ttt_fff_> https://wiki.haskell.org/MonadFix shows examples
22:47:48 <ttt_fff_> but doesn't define it
22:47:53 <EvanR> and then infinity occurrences at t=0 following
22:48:10 <liste> Romfeller how did you get that value? `show' ?
22:48:24 <EvanR> not because they are actually at t=0 but because the algorithm gives up after searching far enough for the right time
22:48:30 <EvanR> and takes the infimum
22:48:35 <Romfeller> liste (L.pack $ showText $ unTextarea m)
22:48:59 <Romfeller> Lazy Text
22:49:16 <liste> Romfeller showText's a debugging function
22:49:25 <Romfeller> oh
22:49:39 <Romfeller> what a noob am i
22:49:42 <Romfeller> hah
22:50:11 <Romfeller> thanks liste
22:50:22 <liste> yw (:
22:50:33 <liste> so you want strict -> lazy text?
22:50:53 <Romfeller> liste: simplemail' wantes that
22:50:56 <Romfeller> wants
22:51:09 <liste> there's L.fromStrict
22:51:41 <Romfeller> liste i will recompile and send to server
22:57:02 <Romfeller> deploying...
22:57:20 <jle`> ttt_fff_: the same way you learn about any typeclass...look at its instances :)
22:57:25 <jle`> and what the instances have as methods
22:57:40 <jle`> what is mfix for Maybe?  what is mfix for State s?  what is mfix for IO?
22:57:44 <EvanR> :t mfix
22:57:45 <lambdabot> MonadFix m => (a -> m a) -> m a
22:57:49 <jle`> each one will be very unique, very different
22:57:59 <jle`> and the link between all of them might not be obvious
22:58:08 <jle`> but that's how it is with every type class
22:58:40 <jle`> at the purest level, mfix is defined by its laws.  but that's the most impractical way of looking at it
22:58:57 <EvanR> mfix passes the "final result" to the callback, which is supposed to return the final result?
22:59:12 <EvanR> using monad actions
22:59:15 <jle`> asking "what does return do?" is the worst way to learn about monads...asking "what does return for IO do?  what does return for Maybe do?" is a helpful and productive way
23:00:21 <EvanR> oh wow fixIO
23:02:11 <EvanR> fixIO appears to do some time travel
23:02:13 <kristof> Hrm. Would be nice to be able to split lists into sized chunks.
23:02:23 <EvanR> i figured ghc was advanced, but ;)
23:03:05 <EvanR> :t chunksOf
23:03:06 <lambdabot> Int -> [e] -> [[e]]
23:03:08 <athan> jle`: I disagree, I think that the abstract theory is how you familiarize yourself with monads in general, and how they _should_ work. Then, if you have concrete examples, then you're in-the-money. But, probably splitting hairs :|
23:03:26 <kristof> EvanR: Clearly I didn't hoogle. Is that in Data.List?
23:03:33 <EvanR> no its in the split package
23:03:46 <kristof> Split! I didn't even know about this.
23:03:57 <kristof> Wish there was some whirlwind tour of the standard libs.
23:04:00 <jle`> athan: but how can you even have an intuition of "how they should work" unless you have concrete examples?
23:04:15 <athan> jle`: Through the laws of course!
23:04:27 <EvanR> athan: how monads work in general, im not even sure that makes sense
23:04:41 <EvanR> they dont do anything in general
23:04:45 <jle`> if someone asked me how they should learn about monads in haskell, i wouldn't tell them to study the laws
23:04:52 <athan> EvanR: They obey their laws!
23:05:10 <jle`> i would tell them to forget about it and just look at the interface of IO, the interface of Maybe, the interface of other things they use commonly, etc.
23:05:12 <athan> idk, I would. First starting with Functor, then Applicative, then Monad
23:05:21 <athan> :s
23:05:23 <EvanR> no you need to start with concrete examples
23:05:36 <jle`> and then after using a bunch of them they will start seeing how things relate, and feeling a general pattern
23:05:57 <EvanR> the laws help not much with specific use cases of monads
23:06:02 <athan> good point actually
23:06:02 <EvanR> Maybe, List etc
23:06:13 <jle`> i can look at the monad laws and have no idea how to use monads
23:06:15 <jle`> or even what they mean
23:06:34 <jle`> i can look at Maybe a -> (a -> Maybe b) -> Maybe b and see instnatly what it means, just from my familiarity with Maybe
23:06:35 <athan> I remember when I thought monads were something from space without the theory, though. I saw them everywhere, and felt like I could use them, but I still didn't know what they /were/
23:06:54 <EvanR> monads in particular inhabit a specialized zone of confusion among type classes for some reason, so you need extra special case dealing with pedagogy
23:07:14 <EvanR> extra special care 
23:07:19 <EvanR> my keyboard is coming apart
23:07:22 <athan> speaking of monads, who's in for the Monad without Return
23:07:26 <athan> ..proposal?
23:07:34 <EvanR> the heck is that
23:07:37 <kristof> they should deprecate return
23:07:39 <kristof> and >>
23:07:42 <athan> :)
23:07:45 <kristof> force everyone to use pure and *>
23:07:53 <jle`> >> might have a purpose still
23:07:53 <athan> return :: Applicative f => a -> f a
23:07:55 <EvanR> oh pure
23:07:56 <athan> return = pure
23:08:09 <jle`> there are applications where >> is not *>, and the difference is important and taken advantage of
23:08:19 <EvanR> uh they want to remove return, but not fail?
23:08:21 <kristof> jle`: Such as?
23:08:24 <jle`> the result is the same, but the operational aspects are different
23:08:26 <athan> parsers?
23:08:37 <EvanR> fuck fail
23:08:41 <kristof> Parsers was the first example I thought of to say that they are exactly the same
23:08:47 <jle`> situations where APplicative represents parallel exuection, and MOnad represents sequential execution
23:08:50 <athan> EvanR: I think they're already removing it
23:08:58 <jle`> so liftA2 f x y = do x and y in parallel, and apply f to the result
23:09:06 <jle`> liftM2 f x y = do x, then do y, and then apply f to the results
23:09:07 <athan> this is something sneaking in before ghc8 is solidified
23:09:15 <glguy_> Jle`: that'd be a bug
23:09:22 <kristof> jle`: Absolutely not.
23:09:28 <EvanR> Monad without return, thats going to add even more confusion
23:09:30 <kristof> jle`: liftM2 still applies things in parallel
23:09:49 <jle`> you can define an Applicative instance where (<*>) is parallel
23:09:53 <jle`> parallel sequencing
23:09:56 <glguy_> That bug was fixed in the async package for the Concurrent type, for example
23:10:00 <jle`> and (>>=) is sequential sequencing
23:10:29 <glguy_> If you have a monad instance the Applicative one must match to match the documented laws
23:10:32 <kristof> jle`: So you mean you want the right side of >> to only run after the left side has run, even though the right doesn't depend on the left by definition?
23:10:49 <jle`> i mean, that's the desired behvaior for IO
23:10:52 <athan> glguy: :D
23:10:58 <jle`> you don't want print 1 >> print 2 to print both in parallel
23:11:09 <kristof> jle`: How the IO happens is sort of irrelevant with respect to the monads themselves
23:11:11 * athan 's internal crowd goes wild
23:11:14 <jle`> i'm talking about instances
23:11:24 <jle`> specific instances, not monads in general
23:11:26 <kristof> for instance monads are associative but that does not mean evaluating later actions before previous actions makes sense
23:11:34 <jle`> it doesn't, but it does for specific instances
23:11:36 <athan> jle`: But would you want print 1 *> print 2 to be?
23:11:42 <EvanR> if IO didnt work like that, it would be chaos
23:11:45 <jle`> for IO, it should be sequential
23:11:52 <glguy_> It would be a bug for any instance
23:11:54 <jle`> but it makes sense to define a type where it's *not* sequential
23:12:02 <kristof> jle`: Are you familiar with goroutines?
23:12:07 <kristof> CSP, etc.
23:12:16 <jle`> that way liftA2 f x y = parallel exeuction of x and y, so *> is parallel execution
23:12:23 <jle`> i am not :)
23:12:40 <EvanR> did go reinvent node.js :(
23:12:47 <athan> :D
23:12:54 <kristof> jle`: I can imagine a CSP monad where print 1 *> print 2 might print one or the other first, nondeterministically, while print 1 >> print 2 forces order
23:12:56 <athan> we should have a purescript -> go compiler!
23:13:11 <jle`> it makes perfect sense to define an instance where *> and <*> do parallel sequencing/merging of actions
23:13:25 <jle`> that shouldn't be the default instance of IO, of course
23:13:35 <jle`> but it is a perfectly sensible instance for, say, a newtype wrapper over IO
23:13:44 <kristof> jle`: Right, see my example
23:13:53 <jle`> yeah
23:14:17 <jle`> and for that instance, (>>) being defined in terms of (>>=), (>>) would be in determistic non-parallel sequencing
23:14:22 <jle`> this isn't my idea; this is simon marlow's idea :o
23:14:31 <kristof> Oh, that's in the book? :C
23:14:36 * kristof burns his copy
23:14:44 <jle`> it's not in the book, he thought about it after he finished the book
23:15:00 <kristof> There's really one problem with that
23:15:26 <kristof> there's no good reason to make Applicatives parallel and Monads sequential besides convention.
23:15:47 <kristof> I mean it's impossible for sequences of applicative computations to rely on the result of previous ones, sure, however
23:15:51 <jle`> well, you're writing the instance
23:15:54 <EvanR> this sounds like an abuse of applicative
23:15:57 <jle`> you get to decide whatever arbitrary instance you write
23:15:57 <kristof> yeah
23:16:10 <kristof> the point of applicatives and monads is, well, in the types and the laws
23:16:13 <kristof> and nothing more
23:16:25 <EvanR> and cool syntax!
23:16:27 <EvanR> oh wait
23:16:28 <kristof> they're not supposd to know anything about your program counter
23:16:31 <jle`> but, in this case, keeping (>>) is important for practical usage
23:16:45 <jle`> otherwise people will define their own x >>= \_ -> y
23:17:04 <kristof> How is *> defined, again? I keep forgetting.
23:17:10 <kristof> >> is so simple, *> is not.
23:17:28 <jle`> (id <$ x) <*> y ?
23:17:45 <kristof> (flip const) <$> x <*> y
23:17:56 <ttt_fff_> fix f = let x = f x in x
23:17:58 <ttt_fff_> wtf does that do ?
23:18:05 <jle`> yeah, (\_ y' -> y) <$> x <*> y
23:18:07 <EvanR> this
23:18:09 <EvanR> > fix error
23:18:11 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
23:18:19 <jle`> ttt_fff_: try expanding it out for interesting f's
23:18:19 <kristof> ttt_fff_: Ask Bertrand Russell
23:18:35 <ttt_fff_> kristof: do you have a time machine or a way to talk to the dead ?
23:18:38 <ttt_fff_> > error
23:18:38 <jle`> for example, expand out `fix (const 1)`
23:18:39 <lambdabot>      No instance for (Typeable a0)
23:18:40 <lambdabot>        arising from a use of ‘show_M438358333064838864212051’
23:18:40 <lambdabot>      In the expression:
23:18:41 <EvanR> ttt_fff_: look at the type
23:18:47 <jle`> or expand out fix (1:)
23:19:04 <jle`> ttt_fff_: oh, the less-efficient-but-easier-to-understand rephrasing might help with understanading
23:19:12 <jle`> fix f = f (fix f)
23:19:43 <jle`> the two definitions are the same...but in this one it's easier to directly apply things out
23:19:48 <EvanR> to understand recursion you must first understand recursion
23:19:49 <jle`> fix (const 1) = const 1 (fix (const 1)) = 1
23:20:22 <jle`> fix (1:) = 1 : fix (1:) = 1 : 1 : fix (1:) = 1 : 1 : 1 : fix (1:) = [1,1,1...forever]
23:20:28 <EvanR> > fix (const 1)
23:20:29 <kristof> Did my definition of *> work?
23:20:29 <lambdabot>  1
23:20:39 <jle`> kristof: yes your definition works
23:20:52 <jle`> my second one had a typo, heh
23:21:07 <kristof> :t (ap) $ fmap (flip const)
23:21:08 <lambdabot> ((a -> b) -> a) -> (a -> b) -> c -> c
23:21:56 <jle`> :t \x y -> (\_ z -> z) <$> x <*> y
23:21:58 <ttt_fff_> jle`: okay, this is cool
23:21:58 <lambdabot> Applicative f => f a -> f b -> f b
23:22:09 <EvanR> ttt_fff_: see also fixed point combinators
23:22:20 <ttt_fff_> jle`, EvanR: how do strict pure langauges do this ?
23:22:20 <EvanR> in the untyped lambda calculus
23:22:25 <ttt_fff_> this seems very reliant upon laziness
23:22:26 <kristof> :t (((flip const)<$>)<*>)
23:22:28 <lambdabot> ((a -> b) -> a) -> (a -> b) -> c -> c
23:22:41 <kristof> I surrender
23:22:42 <jle`> ttt_fff_: one thing people like to use fix for is to let you write recursion without using explicit recursion
23:22:42 <EvanR> ttt_fff_: they cant, they cant even do normal recursion correctly a lot of the time
23:23:05 <EvanR> actually you can do a trampoline
23:23:34 <kristof> EvanR: I once added trampolining manually to a language with closures but no tail recursion
23:23:51 <kristof> It felt... wrong.
23:24:06 <EvanR> ttt_fff_: a lot of recursion patterns in haskell rely on laziness
23:24:40 <EvanR> see the monad-loops package
23:24:41 <kristof> In any case, jle`, if there is a case where there is some distinction between parallel and sequential, then two separate functions are required
23:24:57 <kristof> Monad needs bind | join, and that's it.
23:25:23 <kristof> my opinion doesn't matter much, though.
23:25:31 <ttt_fff_> > fix (1:)
23:25:33 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
23:25:43 <jle`> maybe the decision to leave (>>) would be a pragmatic one rather than a mathematically elegant one
23:25:48 <ttt_fff_> ah, (1:) is [Int] -> [Int]
23:26:01 <EvanR> :t fix
23:26:03 <lambdabot> (a -> a) -> a
23:26:14 <EvanR> ttt_fff_: it takes a function and returns a fixed point of it
23:26:17 <jle`> ttt_fff_: have you ever seen the fibs = 1 : 1 : zipWith (+) fibs (tail fibs) version of the fib sequence?
23:26:22 <ttt_fff_> jle`: I have
23:26:32 <jle`> it's nice, but it uses explicit recursion
23:26:35 <ttt_fff_> EvanR: yes, but there's difference between knowing def and intuition
23:27:09 <jle`> you can write it to not explicitly recurse by writing fibs nextFibs = 1 : 1 : zipWith nextFibs (tail nextFibs)
23:27:15 <EvanR> ttt_fff_: intuitively, fix (\loop -> ...) passes the (\loop -> ...) to itself
23:27:19 <jle`> what you really want is for nextFibs to be fibs
23:27:26 <EvanR> then you can use loop to restart the loop
23:27:27 <quicksilver> jle`: kristof: if by parallel merging you mean non-deterministic, then that would not be an Applicative instance in the normal sense.
23:27:27 <jle`> so you can just do `fix fibs`
23:27:41 <quicksilver> which is not to say it wouldn't be an interesting thing.
23:27:43 <liste> is fix same as the (lazy) Y combinator?
23:27:49 <EvanR> yes
23:27:55 <jle`> er, i wouldn't really say so
23:28:06 <jle`> the Y combinator is one possible implementation of a fixed point combinator in an untyped language
23:28:12 <jle`> fix is another completely separate implementation
23:28:14 <EvanR> its extensionally the same
23:28:25 <shachaf> fix isn't an implementation.
23:28:31 <EvanR> "fix" isnt specifying any implementation, at least it doesnt have to
23:28:34 <jle`> y combinastor specifically refers to a specific construction
23:28:36 <ttt_fff_> can fix/mfix be used to write a sipmle "REPL" loop ?
23:28:41 <jle`> okay, fix is not an implementation
23:28:57 <jle`> but the y combinator refers to a specific construction, not all fixed-point combinators in general
23:29:05 <EvanR> ttt_fff_: its enough to implement any recursion you want
23:29:06 <Cale> ttt_fff_: fix can be used to implement nearly anything you can otherwise write recursively.
23:29:18 <Cale> (with polymorphic recursion aside)
23:29:22 <ttt_fff_> is this related ot the y combinator of the sk combinator?
23:29:30 <Cale> It's related to Y
23:29:45 <quicksilver> Cale: fix with RankNTypes can presumably do polymorphic recursion?
23:29:49 <Cale> Y is a particular implementation of fix available in untyped lambda calculi
23:29:56 <Cale> quicksilver: hmmm
23:30:02 <jle`> fix f = f (fix f) is definitely *not* the y combinator, because the y combinator refers to a specific implementation/construction
23:30:04 <Cale> quicksilver: possibly!
23:30:29 <EvanR> jle`: and you cant even implement fix as Y in haskell, or wait, maybe you can with data
23:30:37 <Cale> quicksilver: Well, er... I think even with RankNTypes, it's hard to convince GHC to instantiate a type variable to a polytype
23:30:50 <EvanR> impredicative types
23:31:01 <Cale> quicksilver: Maybe just specifying the type directly is enough though, I haven't tried it
23:31:20 <Cale> (rather than having to reimplement the function at the type you need it)
23:31:22 <liste> so Y is one implementation of fix, and the one with recursive let is another?
23:31:29 <Cale> liste: yeah
23:31:59 <Cale> fix f = f (fix f)  is also not the same as  fix f = x where x = f x
23:32:10 <Cale> the latter is more efficient
23:32:10 <EvanR> Y combinator gives an entire first page of google about not the Y combinator
23:32:13 <EvanR> but one company
23:32:27 <Cale> EvanR: I hate that :P
23:32:59 <EvanR> now THATs and SEO budget
23:33:16 <Cale> ttt_fff_: Consider something like  fac n = if n == 0 then 1 else n * fac (n-1)
23:33:17 <jle`> well, the mathematical y combinator doesn't quite have the biggest SEO budget
23:33:50 <Cale> ttt_fff_: We can write fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) which is the same function anonymously
23:34:02 <jle`> > fix (\
23:34:04 <lambdabot>  <hint>:1:6: parse error: naked lambda expression ''
23:34:53 <jle`> > fix (\fibs -> 1 : 1 : zipWith (+) fibs (tail fibs))
23:34:55 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
23:35:01 <EvanR> Y f = let w x = f (x x) in w w
23:37:43 <ttt_fff_> Cale, jle`, EvanR: okay, I think I get intuition now
23:38:05 <ttt_fff_> fix is most useful in defining infinitely sized data structures, say infinite lists, infinite trees, etc  (though in Cale's example, it can be used for finite sized structures too)
23:38:29 <EvanR> its useful for doing recursion in a way that will confuse people
23:38:37 <ttt_fff_> well, I'm studying a FRP library
23:38:51 <ttt_fff_> why is "fix f = x where x = fx" more efficient than "f (fix f)" ?
23:39:17 <EvanR> x will only be evaluated once
23:39:24 <jle`> consider how fix (1:) is allocated
23:39:52 <jle`> fix (1:) = 1 : fix(1:), 1 cons'd with a "rest of the list" that is fix (1:)
23:39:54 <ttt_fff_> okay
23:40:08 <EvanR> in the other case youre passing (fix f) around each time
23:40:17 <jle`> and that is 1 : 1 : fix (1:), 1 consed with one consed with a rest of the list, unevaluated, completely separate/new in memory
23:40:54 <liste> does fix (1:) tie the knot ?
23:41:01 <jle`> but with the efficient version, the "tail" pointer of the (:) points to "itself" in memory
23:41:14 <liste> oh, that answers that
23:41:17 <jle`> it's x = 1 : x
23:41:17 <shachaf> let x = not x in x -- tying the not
23:41:59 <jle`> > let x = 1 : x in x    -- x is only allocated once, and the tail pointer of (:) just points to that x
23:42:00 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
23:42:12 <jle`> shachaf: heh
23:43:35 <EvanR> haskell programs look like dave in 2001 running around the loopy spaceship at runtime
23:49:32 <ttt_fff_> MonadFix laws
23:49:36 <ttt_fff_> do they have any intuition?
23:49:47 <EvanR> :t mfix
23:49:48 <lambdabot> MonadFix m => (a -> m a) -> m a
23:50:02 <ttt_fff_> i mean purity, left shrinking, sliding, nesting
23:50:28 <jle`> i've never discovered any, i just use them on an instance-by-instance basis for the most part :O
23:51:51 <athan> ttt_fff_: See "value recursion in monadic computations"
23:52:40 <ttt_fff_> athan: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.15.1543&rep=rep1&type=pdf actually loks really nice
23:52:41 <ttt_fff_> has diagrams
23:53:05 <athan> ttt_fff_: It's a juicy one :)
23:53:16 * athan needs to re-read it actually >.>
23:57:41 <montanonic> ttt_fff_: no one mentioned that fix is most powerful when used directly on an error
23:57:47 <montanonic> > fix error
23:57:48 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
23:58:36 <EvanR> i mentioned that today already
23:59:06 <ttt_fff_> :t (fix error)
23:59:07 <lambdabot> [Char]
23:59:30 <montanonic> Oh dang. I found it in a comment on SO. too funny
