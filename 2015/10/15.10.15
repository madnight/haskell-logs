00:07:39 * hackagebot rei 0.3.2.0 - Process lists easily  https://hackage.haskell.org/package/rei-0.3.2.0 (kerkomen)
00:07:39 * hackagebot pandoc-citeproc 0.8.0.1 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.8.0.1 (JohnMacFarlane)
00:13:39 <EvanR> Fylwind: how many?
00:13:47 <Fylwind> Fylwind: ~8 or so
00:14:02 <Fylwind> I tried deepseq and it made this even slower :/
00:14:11 <EvanR> oh then ! shouldnt be bad, and yeah i think its better than deepseq
00:14:21 <EvanR> but ! might have the same effect
00:15:00 <EvanR> you can create a strict : operation and <*> over it
00:15:30 <Unhammer> is there a way to match with Regex s.t. I get back ("stringuntilthematch",start_index_of_match) ?
00:16:01 <julianleviston> Fylwind: you deepseq the whole list as a single unit, right? 
00:16:03 <Unhammer> (alternatively, is there a simple invert-regex function?)
00:16:24 <EvanR> its better to evaluate the contents before you build the structure than after
00:16:43 <Fylwind> julianleviston: yes
00:18:46 <pavonia> Unhammer: Isn't length "stringuntilthematch" == start_index_of_match?
00:20:17 <julianleviston> EvanR: why does it make a difference on an 8-item list? Just interested :)
00:20:45 <EvanR> talking about performance, either dont do either one ;)
00:20:55 <EvanR> i mean, otherwise dont ! or deepseq
00:26:23 <Heather> hi what's difference with hindent and stylish haskell
00:28:24 <Unhammer> pavonia,  I don't want to calculate it twice
00:28:41 <Unhammer> I see functions that can return the index of the start
00:29:25 <Unhammer> but none that give the string up until that index
00:44:23 <BernhardPosselt> why is the monad wrapping function called return and the applicative wrapping function called pure?
00:44:44 <BernhardPosselt> can typeclass functions overlap?
00:44:53 <nitrix> They cannot.
00:45:11 <BernhardPosselt> ok, so this is a "hack" to get monads and applicative functors together?
00:45:28 <nitrix> There is no hack there.
00:45:45 <BernhardPosselt> i mean its the same type sig right?
00:45:58 <nitrix> BernhardPosselt: A monad is also an applicative.
00:46:11 <EvanR> pure :: Pointed f => a -> f a ;)
00:46:59 <BernhardPosselt> is there some sort of type class inheritance?
00:47:18 <EvanR> not inheritance, but prerequisits
00:47:23 <nitrix> It isn't the same signature, they have type class restrictions.
00:47:26 <BernhardPosselt> if a monad is also an applicative functor, couldnt it extend the applicative type functor typeclass?
00:47:57 <EvanR> Monad does extend Applicative, with >>=
00:47:59 <nitrix> it does.
00:48:25 <nitrix> BernhardPosselt: The question is wether or not you want to use your value as an applicative or a monad.
00:48:49 <nitrix> (Provided its type has an instance for both)
00:49:19 <nitrix> Not everything does.
00:49:48 <nitrix> BernhardPosselt: While monads are applicatives, applicatives aren't necessarily monads.
00:50:34 <BernhardPosselt> yep, no bind
00:52:10 <nitrix> You'll find a similar "problem" with record members.
01:02:03 <SpaghettiCat> Hello does anybody know what Haskell is named after? I can't find any info online
01:02:19 <ReinH> SpaghettiCat: mathematician Curry Haskell
01:02:21 <LokiSnake> Haskell Curry
01:02:25 <SpaghettiCat> ah thanks
01:02:54 <ReinH> SpaghettiCat: it's the second sentence of the wikipedia article.
01:03:03 <ReinH> Haskell Curry ofc, lol
01:03:25 <SpaghettiCat> Ah so it is, I tried finding it in the History section
01:04:34 <EvanR> i made curry haskell once, on a recipe tip from this channel
01:08:19 <jonascj> Hi all. I am trying to learn haskell via Real World Haskell. Why does ":type readFile" (answer: "readFile :: FilePath -> IO String") tell me it has side effects? Some comments on the online version say IO is the hint.
01:10:02 <frerich> jonascj: Yes, the 'IO' is the hint. To be more pedantic, the function itself is perfectly pure: given a FilePath, it yields an IO action. However, *executing* that action may have all kinds of side effects. In fact, you don't *know* what it does. It just promises to eventually produce a String value, which hopefully resembles the file contents.
01:11:18 <SX> jonascj: If you see IO it potentially has side effects. Well, better think it *has* side effects.
01:11:58 <SX> But only if it reaches the top level
01:12:20 <SX> It can be dropped in evaluation process
01:13:21 <jonascj> frerich: how can readFile be thought of as having side effects? I asked for a string, and I got a string. The file can hopefully not be accidentally deleted or modified by readFile. So what is the side effect?
01:13:52 <SX> Side effect is all about communicating with outside world
01:14:13 <SX> File *is* located in outside world
01:14:26 <SX> It's not a part of your program
01:14:29 <jonascj> SX: okay, so if something triggers a system call it is said to have an side effect?
01:14:29 <julianleviston> jonascj: the “side” part is the fact that if you have a different contents of file, you’ll get a different string.
01:15:01 <SX> If you read about pure functions, you'll understand the difference
01:15:22 <frerich> jonascj: 'readFile' is a function (because it has '->' in its type). If you apply that function to a FilePath, you get a value of type 'IO String' (an 'IO action'). IT doesn't actually *perform* that action yet. If you give the same filepath, you'll get the same action - it's "pure". However, executing that action will actually read the file.
01:15:36 <jonascj> Alright, I get it now. I don't know if this is possible in Haskell, but if calling a function could create a new global variable, that would be my definition of a side effect, inside haskell/my program :P
01:15:41 <SX> Result of evaluation of pure function depends *only* on it's arguments
01:15:58 <SX> Same arguments - same result. Always. Thats a rule.
01:16:15 <frerich> jonascj: In a simplified (and wrong) way, you could say that applying 'readFile' to the exact same FilePath multiple times may yield different output, so you will not always get the same value for the same input -- hence the function is not pure.
01:16:24 <SX> In IO it's the same except one: the world state is always different
01:16:42 <julianleviston> ^ yeah world state is always different.
01:16:49 <SX> Because outside world has states.
01:16:59 <jonascj> Thanks, I understand it much better now.
01:17:53 <SX> You better read Learn You A Haskell For The Great Good
01:17:54 <julianleviston> jonascj: you actually *can’t* re-define “variables” in the way you were talking about earlier… this has some really nice implications… such as… you can do equational reasoning in a programming language!
01:18:32 <SX> It's better for novice (like me), it's better structured IMO
01:19:10 <julianleviston> jonascj: I recommend http://haskellbook.com
01:19:30 <SX> RWH is good, but old enough
01:19:32 <julianleviston> jonascj: even in its “unfinished” form, it’s vastly better than most other books out there.
01:20:03 <ttt_fff> how is https://github.com/tomjaguarpaw/haskell-opaleye/blob/master/Doc/Tutorial/TutorialBasic.lhs#L180 valid code?
01:20:21 <julianleviston> ttt_fff: proc is in arrows.
01:20:27 <SX> What do you guys think of switching Prelude to some custom Prelude like basic-prelude in libs?
01:20:28 <julianleviston> ttt_fff:  {-# LANGUAGE Arrows #-}
01:20:50 <ttt_fff> julianleviston: ah, thanks :-)
01:20:54 <julianleviston> ttt_fff: it’s a syntax like do syntax, but for arrows.
01:20:58 <ttt_fff> if I don't do langauge arrows, does this code become quite ugly?
01:22:18 <julianleviston> ttt_fff: have you looked at Groundhog? (just curous)
01:22:35 <ttt_fff> julianleviston: only used sqlite-simple and opaleye
01:23:14 <julianleviston> ttt_fff: groundhog “wraps” sqlite-simple and postgres-simple, I think… it makes working with the database quite pleasant.
01:23:22 <ttt_fff_> my other client just froze
01:23:30 <ttt_fff_> the last msgs I got from you is "have you looked at Groundhog? (just curious)"
01:24:33 <SX> julianleviston: so it's 59$ for a incomplete (for now) book.. Quite expensive. How good is it?
01:24:40 <julianleviston> SX: very.
01:24:49 <julianleviston> SX: it’s not that incomplete. 
01:24:55 <julianleviston> ttt_fff: withPostgresqlConn connStr $ runDbConn $ do {allCustomers <- select CondEmpty; liftIO $ putStrLn $ "All customers: " ++ show (allCustomers :: [Customer])}
01:25:20 <julianleviston> ttt_fff: it kind of “wraps” sqlite-simple or postgres-simple (it’s a DSL on top of them kinda)
01:25:23 <LokiSnake> SX: i'm a haskell novice working through it, at ~700 pages, and it's very very good (after trying to get into it via other means many times before and failing)
01:25:51 <SX> modern practices (I find RWH old and confusing)
01:25:54 <SX> ?
01:25:57 <LokiSnake> and yeah, it's a WIP, but the material i've gone through has been not at all incomplete 
01:26:08 <ttt_fff_> which book are you talking about?
01:26:23 <SX> http://haskellbook.com
01:26:24 <julianleviston> ttt_fff: haskell programming
01:26:27 <LokiSnake> I wouldn't know as much about modernity of the practices, but does work in ghc 7.10.2, and notes differences/etc. with 7.8 when appropriate
01:26:50 <julianleviston> It’s not a “projects” book. :)
01:27:10 <julianleviston> SX: In particular, I find the approach to Monoid, Functor, Applicative, Monad incredibly good.
01:27:36 * hackagebot profiteur 0.2.0.2 - Treemap visualiser for GHC prof files  https://hackage.haskell.org/package/profiteur-0.2.0.2 (JasperVanDerJeugt)
01:27:47 <ttt_fff_> what is the qualifications of the authors?
01:27:51 <LokiSnake> i am going through the applicatives chapter now, and couldn't be happier
01:27:56 <julianleviston> ttt_fff_: check the website. it’s on there.
01:27:59 <ttt_fff_> has either written any important hackage package
01:28:06 <ttt_fff_> yeah I see http://haskellbook.com/authors.html
01:28:10 <ttt_fff_> what has either accomplished?
01:28:20 <julianleviston> ttt_fff_: bitemyapp has done quite a few packages...
01:28:35 <LokiSnake> ttt_fff_: http://bitemyapp.com/projects.html I guess
01:28:36 <ttt_fff_> chris alien is bitemyapp ?
01:28:43 <julianleviston> ttt_fff_: yep
01:28:55 <ttt_fff_> ah, was not awware of that
01:29:06 <ttt_fff_> bitemyapp has some rep
01:30:21 <EvanR> BITE LIFE
01:30:51 <C0MPAQ> anyone knows videos that show females in front of a PC code in Haskell?
01:30:58 <clintm> heh
01:31:26 <k_bx> Hi! Can anybody explain a simple thing to me, please? I understand what is Proxy, but what’s a lower-cased proxy, where is it defined?
01:31:42 <EvanR> in base
01:31:45 <ttt_fff_> hoogle proxy
01:31:47 <ttt_fff_> @hoogle proxy
01:31:49 <lambdabot> package proxy-kindness
01:31:49 <lambdabot> Network.HTTP.Proxy module Network.HTTP.Proxy
01:31:49 <lambdabot> Graphics.Rendering.OpenGL.GL.PixelRectangles.ColorTable Proxy :: Proxy
01:31:52 <EvanR> :t proxy
01:31:53 <lambdabot>     Not in scope: ‘proxy’
01:31:53 <lambdabot>     Perhaps you meant data constructor ‘Proxy’ (imported from Data.Typeable)
01:32:05 <k_bx> Data.Proxy?
01:32:14 <k_bx> http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Proxy.html
01:32:17 <k_bx> Can’t see any
01:32:45 <EvanR> oh, not sure what lowercase proxy is
01:32:58 <k_bx> I see it used in many places
01:33:03 <EvanR> theres on in this package but https://hackage.haskell.org/package/tagged-0.2/docs/Data-Proxy.html
01:33:07 <k_bx> For example here in type-declaration http://hackage.haskell.org/package/tagged-0.8.1/docs/Data-Tagged.html
01:33:27 <MarcelineVQ> https://www.stackage.org/lts-3.9/hoogle?q=proxy
01:33:28 <k_bx> Or in “what I wish I knew” http://dev.stephendiehl.com/hask/
01:33:48 <EvanR> see the source
01:33:54 <EvanR> proxy :: Tagged s a -> proxy s -> a
01:33:56 <k_bx> EvanR: the source of what?
01:33:59 <EvanR> proxy (Tagged x) _ = x
01:34:02 <k_bx> No, I mean the type-level “proxy s"
01:34:07 <k_bx> Not the function
01:34:25 <davidreis> how can I add an empty list to a list? Eg. [1,2,3] -> [[],1,2,3]
01:34:40 <EvanR> kmm, lowercase means type variable at the type level
01:34:47 <EvanR> proxy might just be a placeholder
01:34:57 <ttt_fff_> http://imgur.com/JzFf4Qp <-- on groundhog/haskell
01:35:05 <ttt_fff_> julianleviston: ^
01:35:08 <k_bx> https://gist.github.com/k-bx/2bea7feeae252be03f85
01:35:33 <k_bx> Oh, you don’t even need to import anything to use it
01:35:48 <EvanR> proxy is any * -> * 
01:36:08 <EvanR> for example, Proxy
01:36:22 <k_bx> is there a documentation stating that?
01:36:33 <k_bx> I really fill I missed this
01:36:45 <EvanR> i think the choice of name proxy is just stylistic
01:36:49 <davidreis> how can I add an empty list to a list? Eg. [1,2,3] -> [[],1,2,3]
01:36:52 <EvanR> and surprising when you only ever see single letter names
01:36:53 <k_bx> s/fill/feel/
01:37:18 <julianleviston> ttt_fff_: sure… one is for the database, the other for te data type… I *guess* it’s a repetition if you’re using the same values there….. but what if they’re different??
01:37:33 <EvanR> davidreis: you can't, lists have elements that are all the same type
01:37:33 <davidreis> can someone help pls
01:37:37 <ttt_fff_> dunno; I don't see why the haskell code can't be generated from the TH code
01:37:42 <k_bx> EvanR: but, I mean, is it implemented as a special case in ghc? Since I can’t do “:i proxy” or “:k proxy” in ghci
01:37:49 <EvanR> k_bx: no
01:37:50 <julianleviston> ttt_fff_: only if you have the same data types as column names.
01:38:10 <ttt_fff_> julianleviston: that makes sense; thanks
01:38:12 <julianleviston> ttt_fff_: otherwise, use something magic I guess ;-)
01:38:17 <julianleviston> ttt_fff_: rails? lol
01:38:20 <MarcelineVQ> k_bx: it could be `proxy :: Tagged s a -> p s -> a`
01:38:22 * julianleviston ducks
01:38:37 <ttt_fff_> jjulianleviston: get with the program. elixir/phoenis is the new ROR
01:38:40 <k_bx> MarcelineVQ: no, I can use it without having tagged installed or imported
01:38:40 <julianleviston> davidreis: not unless you tell us what your problem is
01:38:45 <julianleviston> ttt_fff_: oh sorry :)
01:38:52 <EvanR> k_bx: you can try it with explicit foralls turned on, and write it more explicitly
01:39:12 <k_bx> MarcelineVQ: see this https://gist.github.com/k-bx/ece76eff392f954ed509
01:39:29 <MarcelineVQ> `let f :: p a -> Int; f _ = 10`
01:39:56 <julianleviston> davidreis: oh… [] : [1,2,3]
01:40:00 <EvanR> let f :: forall (proxy::*->*) (a::*) . proxy a -> Int; f _ = 10
01:40:02 <k_bx> Aah, so you mean it’s just a type-name which is not used, e.g. could be anything.
01:40:07 <julianleviston> > [] : [1,2,3]
01:40:07 <EvanR> right
01:40:08 <MarcelineVQ> let f :: fiddlestick a -> Int; f _ = 10
01:40:09 <lambdabot>      No instance for (Show t0)
01:40:09 <lambdabot>        arising from a use of ‘show_M20787849918920207925926’
01:40:09 <lambdabot>      The type variable ‘t0’ is ambiguous
01:40:11 <MarcelineVQ> oop
01:40:13 <k_bx> Thank you! Hahaha.
01:40:14 <julianleviston> oops.
01:40:18 <julianleviston> guh I’m an idiot.
01:40:46 <EvanR> > () : [(),(),()]
01:40:48 <lambdabot>  [(),(),(),()]
01:40:52 <EvanR> good enough
01:41:01 <MarcelineVQ> dat unit
01:41:34 <julianleviston> > Nothing : [Just 5, Just 2, Just 3]
01:41:36 <lambdabot>  [Nothing,Just 5,Just 2,Just 3]
01:41:38 <julianleviston> much better.
01:42:07 <davidreis_> h
01:42:19 <EvanR> NULL : [FALSE, 0, "", UNDEFINED, NaN]
01:42:54 <EvanR> -XPHP
01:43:16 <davidreis_> no, im sorry, what I want is to go from [1,2,3] to [[],[1],[2],[3]]
01:43:24 <SX> is there any patterns or design best practices out there?
01:43:26 <davidreis_> how can I add that empty list?
01:43:41 <EvanR> first convert [1,2,3] to [[1],[2],[3]]
01:43:46 <EvanR> then prepend the []
01:44:14 <julianleviston> SX: yeah, Haskell is pretty much full of patterns & best practices.
01:44:37 <EvanR> the first one is a regular transformation, so you can use map with an appropriate function
01:44:47 <EvanR> :t map
01:44:48 <lambdabot> (a -> b) -> [a] -> [b]
01:45:04 <EvanR> a = Int, b = [Int]
01:45:05 <MarcelineVQ> SX do you want an answer or hints?
01:45:06 <davidreis_> ok thank you
01:45:16 <SX> I'm from OOP world, so it's quite difficult to think differently
01:45:17 <MarcelineVQ> SX woops
01:45:24 <MarcelineVQ> davidar:  do you want an answer or hints?
01:45:34 <julianleviston> SX: yeah, OOP got its patterns from FP AFAIC
01:46:18 <MarcelineVQ> man I'm bad at tab-completing tonight
01:46:23 <jonascj> Having switched to "learn you a haskell for a greater good", I now have a function "doubleMe x = x+x" and its type is "doubleMe :: Num a => a -> a". How should I read that, specifically the two arrows?
01:46:27 <SX> Some resource to read about good software design in haskell? How to get things done haskell-way =)
01:46:53 <julianleviston> SX: OOP AbstractFactory :: Haskell’s “smart constructors”.
01:47:14 <julianleviston> SX:  (or polymorphic types, depending on your viewpoint)
01:47:15 <SX> jonascj: takes one type of Num and returns same type
01:47:22 <SX> or smth like that
01:47:24 <davidar> MarcelineVQ: yes, if you can guess what my question is :p
01:47:28 <quicksilver> jonascj: "Give that 'a' is a Num', a function a -> a
01:47:32 <quicksilver> Given that.
01:47:33 <MarcelineVQ> davidar: sry :3
01:47:59 <jonascj> quicksilver: that makes sense, thank you
01:50:38 <jonascj> And another function "doubleUs x y = [x*2 y*2]" ("doubleUs :: Num t => t -> t -> [t]"). Why three arrows now? "Given 't' is a number it returns a list of num in the end". But the middle t->t->?
01:50:42 <julianleviston> SX: I’m just looking at my design patterns book again… so much of these patterns are just not needed at all or make no sese.
01:50:50 <julianleviston> SX: (so many*)
01:51:05 <julianleviston> jonascj: x -> y means a function from x to y.
01:51:18 <julianleviston> jonascj: x -> y -> z means a function from x and y to z.
01:51:32 <LokiSnake> julianleviston: which book?
01:51:35 <julianleviston> jonascj: if you leave off one of thm when you call it, you get a function that takes ONE argument instead of two
01:51:45 <julianleviston> LokiSnake: It’s called design patterns
01:52:22 <EvanR> "gang of four"
01:52:31 <SX> julianleviston: if I need object-like something, I define data type with operations and make a closure with required field, right?
01:52:47 <EvanR> thats a pattern
01:52:57 <EvanR> not used too much but works 
01:53:10 <julianleviston> SX: I would question why you need something “object-like” 
01:53:13 <LokiSnake> ohh, that one
01:53:24 <julianleviston> SX: you might be fighting against FP! :)
01:53:33 <jonascj> julianleviston: so it should be read as "function of t and t, to [t]"? (like your "x->y->z" means "function of x and y, to z")
01:53:54 <Kristler> function of t to t to t
01:54:01 <SX> It's IO =)
01:54:03 <julianleviston> SX:  I find it somewhat ironic that the OOP world is slowly turning OOP into FP… (separate your concerns, DRY, etc etc)
01:54:25 <julianleviston> jonascj: take the (+) function.
01:54:30 <julianleviston> :t (+)
01:54:31 <lambdabot> Num a => a -> a -> a
01:54:46 <julianleviston> jonascj: see it’s a function of a to a function of a to a value of a.
01:54:47 <jonascj> :t (*)
01:54:49 <lambdabot> Num a => a -> a -> a
01:55:11 <julianleviston> jonascj: that means as a whole, it takes two values of type a and returns one value of type a.
01:55:34 <julianleviston> jonascj: but… if you only pass it ONE value of type a, you get back a function a -> a. that will add that first value to another value.
01:55:48 <Kristler> julianleviston: Would it be correct to say -> is right associative?
01:56:00 <SX> I need to implement network client with constant socket reading and operations queue
01:56:03 <EvanR> SX: check out the concurrency support in haskell, could be a good transition from cruddy languages / thread systems to eventually pure FP
01:56:23 <EvanR> SX: haskell forkIO threads are awesome
01:56:34 <julianleviston> SX: go read that concurrency book! :) it’s really good.. by simon marlow
01:56:39 <SX> But I need to provide some api with simple funtions. And I need to control all these threads.
01:56:43 <EvanR> and you typically use those for services sockets
01:56:54 <EvanR> its not hard
01:57:04 <SX> So closure is a good way to store and control all the things
01:57:07 <julianleviston> Kristler: yeah, I think so :)
01:57:11 <Kristler> neat
01:57:13 <EvanR> closures are very useful
01:57:24 <Kristler> thank you!
01:57:28 <SX> Like socket, queue, api functions and all
01:57:30 <julianleviston> Kristler: I might be wrong!
01:57:31 <EvanR> you probably wont notice how often you use them
01:57:36 <jonascj> julianleviston: but it can be read as "function of a", to a "funciton of a", to a "value of a"? I don't grasp 2x "function of a".
01:57:38 <MarcelineVQ> :t (+1)
01:57:39 <lambdabot> Num a => a -> a
01:57:58 <julianleviston> jonascj: ok. so what does + do?
01:58:05 <julianleviston> jonascj: it takes two values and adds them
01:58:06 <EvanR> SX: once you get started you might be surprised how little of all that you actually end up using
01:58:30 <julianleviston> jonascj: what about a function called (2+) what does that do?
01:58:37 <julianleviston> jonascj: it adds 2 to anything, right?
01:58:59 <julianleviston> jonascj: so I can write 2 + 3 as either f(2,3) = (2 + 3)
01:59:05 <jonascj> julianleviston: my irc client / the channel just lagged heavily, I need to catch up with your messages I did not see :)
01:59:14 <SX> well, i'm tied to how I see the solution coming from OOP exp, not how it should be done in FP
01:59:22 <julianleviston> jonascj: OR I can write it as f(2) = (f (3) = 2 + 3)
01:59:35 <SX> that's why I'm asking. I know there should be some easy and better way to do it
01:59:36 <julianleviston> jonascj: ah ok :)
01:59:55 <SX> than just make an object with closure =)
02:00:28 <Kristler> julianleviston: just in case you may be interested, found this that supports our hypothesis: http://stackoverflow.com/a/5449888
02:00:45 <julianleviston> Kristler: haha yeah, it *is* right-associative.
02:00:58 <EvanR> SX: heres an example, a value of type IO () can be considered like a command. you can execute it, store it in a container, send it over a channel, or whatever. you can construct such a command using closures, but you might not even notice you are using them
02:00:59 <julianleviston> Kristler: just like function application is left-associative
02:01:09 <Kristler> indeed
02:01:17 <EvanR> SX: in which case you dont need a whole object, just use that IO ()
02:01:36 <julianleviston> Kristler: which is why map has the type signature it has:
02:01:40 <julianleviston> :t map
02:01:41 <lambdabot> (a -> b) -> [a] -> [b]
02:01:46 <julianleviston> Kristler: notice the parens! :)
02:01:53 <Kristler> Of course!
02:02:00 <Kristler> Otherwise that type signature would mean a completely different thing
02:02:05 <jonascj> julianleviston: (2+) not being valid haskell? ghci will not accept it, so I suppose it is invalid. It was just your way of thinking of it? I can not do stuff like "let a = 2+" and afterwards do "a 3" and expect to get 5?
02:02:17 <MarcelineVQ> kinda
02:02:21 <julianleviston> jonascj: (2+) is perfectly valid haskell
02:02:26 <julianleviston> > (2+) 5
02:02:28 <lambdabot>  7
02:02:32 <julianleviston> > (2+) 8
02:02:34 <lambdabot>  10
02:02:44 <EvanR> SX: to get started with concurrency, look at the docs for MVar
02:02:46 <julianleviston> jonascj: it’s a partially applied function.
02:02:51 <Kristler> :t (+) 2
02:02:52 <lambdabot> Num a => a -> a
02:02:53 <julianleviston> jonascj: otherwise known as a section
02:02:55 <EvanR> SX: thats a basic container youre going to need
02:03:35 <jonascj> > let a = (2+)
02:03:35 <kritzcreek> How can I tell stack to use a git repository for installing a library rather than stackage?
02:03:36 <lambdabot>  <no location info>: not an expression: ‘let a = (2+)’
02:03:39 <julianleviston> jonascj: you can pretend that a function a -> a -> a is a two argument function… which it kind of is… but really, it’s a function from one argument that returns a function from a second argument to a result.
02:04:08 <jonascj> > (2+) 8
02:04:10 <lambdabot>  10
02:04:21 <jonascj> julianleviston: I suppose it makes sense, thank you :)
02:04:53 <julianleviston> jonascj: this is one reason why haskellbook.com is so good - it STARTS with lambda calculus, which is handy for realising that (+) is just f(x) -> (f (y) -> x + y )
02:05:38 <julianleviston> jonascj: the beauty of the fact that (2+) 8 == (2 + 8) is that you can do equational reasoning…
02:05:52 <julianleviston> jonascj: and if you can do that, refactoring becomes very very pleasing :)
02:06:51 <tdammers> I'm thinking that it's positively harmful that mainstream programming has picked up the term "function" to mean "procedure" or "subroutine"
02:07:01 <julianleviston> jonascj: you realise, for example, that doubleMe (x) could be expressed as x + x, or as 2 * x. They’re equal.
02:07:09 <tdammers> that part causes a lot of confusion among beginning haskellers, I'd think
02:07:12 <julianleviston> tdammers: yeah, I think I appreciate that a lot more now
02:08:35 <tdammers> thinking of a function as a mapping that projects one set onto another just makes a lot more sense than "a function is a thing that takes a number of arguments, does arbitrary things, and then returns a value, or maybe doesn't return a value, oh, and did I mention functions can also throw exceptions, and modify their arguments in place?"
02:08:39 <julianleviston> tdammers: it’s like… “It’s called function because it does FUNCTIONALITY, right??” lol.
02:09:02 <tdammers> haha
02:09:09 <julianleviston> tdammers: yes. That should be a procedural command...
02:09:10 <tdammers> "if you write your code right, it will function"
02:09:14 <julianleviston> lol
02:09:26 <julianleviston> tdammers: ironically, it’s often the opposite :)
02:09:35 <tdammers> yep
02:10:17 <tdammers> "what do you call a function that takes exactly one argument, returns exactly one value, has no side effects, and always returns the same output for the same input" - "a function."
02:10:35 <tdammers> at least scheme has the intellectual honesty to call them "procedures"
02:10:41 <julianleviston> tdammers: yes.
02:11:26 <EvanR> dysfunctions
02:13:31 <SX> EvanR: not TVar? Ok. But what about API? If I have, let's say, 10 operations for the server. Socket, several threads to process data. Api is blocking until task is fully done.
02:13:57 <EvanR> use a thread to respond to connections, fork a worker thread for the new socket
02:14:11 <EvanR> the worker dies as soon as the request is services
02:14:21 <EvanR> is serviced
02:15:16 <SX> UDP, no connections here, just reader thread to get packets from socket, another thread to process it
02:15:38 <julianleviston> SX: read this book… :) http://chimera.labs.oreilly.com/books/1230000000929
02:15:44 <EvanR> TVar is not like MVar, but TMVars are. T means transaction and is in a separate section of support: STM
02:15:53 <julianleviston> SX: he takes you through building a chat program…
02:16:10 <EvanR> datagrams yummy
02:16:11 <Unhammer> (as an answer to my previous question about partitioning on a regex and getting both pre/match/post strings as well as indices in one go, b =~ pat :: (b,MatchText b,b) is the way to do it)
02:16:29 <EvanR> part of this balanced breakfast
02:18:43 <jonascj> Should "if else" be introduced so quickly as it is in "learn you a haskell for a great good"? From university programming class I remember functional programming / declarative programming as something without direct flow control (steps). Isn't if/then/else a form of explicit steps?
02:19:09 <quicksilver> no, it isn't
02:19:16 <julianleviston> jonascj: if then else is an expression
02:19:18 <quicksilver> if/then/else is a very natural and basic function.
02:19:28 <quicksilver> it's a quirk of haskell that it has special syntax
02:19:39 <quicksilver> it could reasonable be a three argument function
02:19:44 <tdammers> the only wart about if is that it's a language construct when it could have been a plain old function
02:19:46 <quicksilver> condition, then branch, else branch
02:19:58 <jonascj> if(a,b,c) = if a then b else c?
02:20:03 <quicksilver> yes, jonascj 
02:20:10 <tdammers> almost, minus the tuple, but yes
02:20:13 <quicksilver> in haskell we'd normally not bother with the (,,)
02:20:15 <quicksilver> but yes that's the idea
02:20:24 <julianleviston> jonascj: the “mental hitch” you’re probably having is that in Haskell, things are evaluated when they need to be only.
02:20:31 <tdammers> I think there's an if' somewhere that does exactly that
02:20:34 <SX> you can control flow via monads (or applicatives?)
02:20:41 <SX> like Maybe or Either
02:20:52 <SX> implicitly.
02:20:53 <fizruk> > let if' True t _ = t; if' False _ f = f in if' (2 > 3) "true" "false"
02:20:55 <lambdabot>  "false"
02:21:19 <julianleviston> fizruk: that might not be the best example for someone who has only just seen if then else
02:21:19 <jonascj> SX: don't tempt me. I am learning haskell because I love the Xmonad window manager. I can barely wait to find out why it is called what it is (xmonad)
02:21:22 <tdammers> SX: I'd prefer to say that certain kinds of control flow can be implemented to follow a monad (or applicative) pattern
02:21:39 <julianleviston> jonascj: oh you should watch “a taste of haskell” by SPJ
02:22:06 <tdammers> SX: it's a bit like how the IO type implementing effects and the IO type being a Monad is orthogonal
02:22:11 <julianleviston> jonascj: he actually goes through some of the code in it… and explains haskell as he does. It’s quite delightful if you can get over the shonky video work
02:22:23 <jonascj> julianleviston: I like to have many tools at my disposal, so if I learning a bit of haskell is a side effect of learning to configure xmonad, all the better :)
02:22:33 <tdammers> SX: Maybe can be use for control flow, and Maybe is a Monad, so monadic code over Maybe amounts to control flow
02:22:34 <julianleviston> jonascj: https://www.youtube.com/watch?v=jLj1QV11o9g
02:23:02 <SX> Maybe can be used explicitly
02:23:03 <tdammers> SX: one could argue that `fail` is a control flow construct in a way...
02:23:19 <jonascj> thanks, I will watch it, maybe after I've been through some more chapters of the "learn you a haskell ..."
02:23:48 <julianleviston> jonascj: I think simon p j is a lot easier to understand than LYAH
02:25:16 <SX> Oh! About fail. Can I define a function as func :: (Monad m) => a -> m a, with return and fail. This will work for Maybe and Either the same way?
02:26:50 <fizruk> > (\x -> return x >> fail "failed") 123 :: Maybe Int
02:26:52 <lambdabot>  Nothing
02:26:54 <fizruk> > (\x -> return x >> fail "failed") 123 :: Either String Int
02:26:56 <lambdabot>  *Exception: failed
02:28:08 <fizruk> this should be due to Monad (Either e) instance where we don't know that e is a String
02:28:44 <SX> so it would throw in Either?
02:29:16 <fizruk> yes, in Either it errors
02:29:57 <fizruk> > fail "failed" :: Either Int Bool
02:29:59 <lambdabot>  *Exception: failed
02:33:45 <jonascj> What is the deal with "4 `elem` [1,2,3,4]" vs. "4 elem [1,2,3,4]"? The + function have the same syntax whether it is prefix or infix...
02:34:50 <jonascj> or is it an ghci artifact? Maybe it can be just "4 elem [1,2,3,4]" in a .hs file. Let me test
02:35:03 <ahihi> + is infix by default because its name consists of symbols
02:35:14 <ahihi> to make it prefix, you write (+) a b
02:36:32 <jonascj> ahihi: oh, you are right. So it is just how it is. If you wan't to use a function whose name consist of chars, as infix, you have to quote it.
02:37:32 <ahihi> yep
02:39:49 <fkbm> well backtick it :)
02:52:40 * hackagebot megaparsec 4.1.0 - Monadic parser combinators  https://hackage.haskell.org/package/megaparsec-4.1.0 (mrkkrp)
02:56:54 <julianleviston> If I have import Snap.Snaplet.Groundhog.Postgresql in my Main.hs file… and a folder called src/Snap/Snaplet/Groundhog with Postgres.hs in it, how come my main won’t compile? (It says it couldn’t find the module Snap.Snaplet.Groundhog.Postgresql but it’s named correctly)
02:57:15 <Heather> Help me to understand hindent :/ where is Chris
02:57:25 <julianleviston> Oh
02:57:32 <julianleviston> nevermind it wasn’t named correctly afterall! 
02:57:49 <Heather> when I run stylish-haskell on .hs file I'm getting output right there, when I run hindent I'm getting nothing
02:58:08 <Heather> I just don't understand how to handle it :/
03:15:52 <fractalsea> If I have a RearT stacked over an ExceptT, and I want to apply withExceptT, is there any way of doing this other than running the ReaderT, applying withExceptT and re-wrapping ReaderT?
03:17:41 * hackagebot shake-language-c 0.8.4 - Utilities for cross-compiling with Shake  https://hackage.haskell.org/package/shake-language-c-0.8.4 (StefanKersten)
03:21:42 <quicksilver> fractalsea: seems odd that there isn't a typeclass version of it
03:21:45 <quicksilver> maybe there is  reason
03:22:41 * hackagebot hakyll 4.7.3.1 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.7.3.1 (JasperVanDerJeugt)
03:23:05 <jonascj> How come this is not a recursive factorial: "fac n = if n == 0 then 1 else fac (n-1)", for me that function returns 1 if I input 4. It hsould return 24.
03:23:24 <jonascj> I saw fac implemented with pattern matching, and thought I'd try it with if/then/else instead.
03:23:40 <ggole> jonascj: how it is ever going to return anything other than 1?
03:23:45 <quicksilver> fractalsea: oh, because it changes the type
03:23:52 <quicksilver> of course
03:24:07 <quicksilver> fractalsea: does your withExceptT actually change the type of the error?
03:24:09 <jonascj> ggole: oh, I missed a n*
03:24:32 <fractalsea> quicksilver, yes it does
03:25:00 <jonascj> ggole: nicely spotted, thank you
03:25:00 <quicksilver> fractalsea: yeah, the MonadError framework isn't powerful enough to 'reconstruct' a new Stack with a different monad
03:25:39 <julianleviston> jonascj: be careful - recursive functions need an end point.
03:25:40 <fractalsea> quicksilver, ok well I guess I’ll have to go for the unwrapping and wrapper
03:26:11 <fractalsea> quicksilver, it’s a shame that monad transformers don’t provide a way of “mapping” the underlying monad
03:26:21 <quicksilver> it's hard to get it right I think fractalsea 
03:26:57 <quicksilver> fractalsea: check out https://hackage.haskell.org/package/mmorph-1.0.4/docs/Control-Monad-Morph.html
03:27:01 <julianleviston> jonascj: if you don’t have a base case (the “way out” for the function - the point where it stops), then recursion easily becomes infinite recursion.
03:27:14 <fizruk> fractalcat: there is mmorph package for that
03:27:21 <quicksilver> fractalsea: what you're talking about is an instance of what that package calls 'hoist'
03:27:34 <fizruk> I meant fractalsea...
03:27:47 <quicksilver> fractalsea: in your specific example, you can probably just use ExceptT e (ReaderT r)
03:28:06 <quicksilver> and then use mapExceptT directly.
03:28:37 <fractalsea> quicksilver, thanks I will look into that
03:28:51 <quicksilver> Either e (r->a) and r -> Either e a are not isomorphic but the difference may not matter to you
03:29:03 <quicksilver> it's about whether or not you can observe the erorr condition without ever providing the 'r'.
03:29:03 <fractalsea> will probably take me a while to get my head around mmorph because it looks very abstract
03:29:31 <fizruk> fractalsea: you probably only need MFunctor class from there
03:29:43 <fractalsea> hmm ok
03:29:48 <jonascj> How is "non-exaustive pattern in function" different from a runtime type error? Of course they are different things, but the book mentions haskell's strong typedness as guaranteeing against a runtime type error. This has almost the same flavor, the program crashes during execution. Does it have a name, the thing you risk if you make a pattern without catch-all?
03:29:54 <fractalsea> Thank you
03:30:12 <quicksilver> oh I'm wrong
03:30:19 <julianleviston> jonascj: because sometimes you might *know* you’ll never need an exchaustive pattern.
03:30:22 <quicksilver> exceptT and readerT actually commute, don't they?
03:30:26 <quicksilver> you get r -> Either e a
03:30:31 <quicksilver> either way around.
03:30:43 <julianleviston> jonascj: mostly, you should have exhaustive patterns, though.
03:30:51 <ggole> There's no guarantee
03:31:01 <liste> jonascj having a catch-all may hide errors
03:31:01 <quicksilver> jonascj: it isn't different. "Non-exhaustive pattern" is precisely a runtime error.
03:31:29 <julianleviston> quicksilver: no it’s not.
03:31:33 <quicksilver> I don't know which book you read but I expect it says something like "haskell's type systems can prevent a wide range of run-time errors"
03:31:36 <fizruk> jonascj: compiler (with -Wall I think) will tell you if you don't handle all the cases
03:31:44 <quicksilver> not all of them.
03:31:49 <quicksilver> julianleviston: how is it not?
03:32:19 <julianleviston> quicksilver: are you talking about the warning that GHC gives you?
03:32:20 <fractalsea> No worries. It looks like hoist is exactly what I need :)
03:32:25 <fizruk> jonascj: and making functions partial is considered bad, so there are not many of them
03:32:52 <quicksilver> julianleviston: no, I'm talking about the runtime error you get when a case match fails.
03:32:55 <julianleviston> quicksilver: you can easily have data that has a shape that doesn’t fit an exhaustive pattern… that’s why it’s a warning and not an error
03:33:03 <quicksilver> quite so
03:33:04 <julianleviston> quicksilver: ok apologies then. You’re of course correct.
03:33:32 <fizruk> fractalsea: note that not every monad is an instance of MFunctor (ContT isn't for instance)
03:33:39 <jonascj> quicksilver: it said it would guard against run-time type errors. Which is true as far as I understand it. But your's "against a wide range of run-time errors" is a broader (maybe softer) similar statement.
03:33:49 <julianleviston> jonascj: a lot of people would suggest that the haskell function “head” is a mistake, for example.
03:33:51 <fractalsea> fizruk. Got ya. Luckily ReaderT is :)
03:33:51 * quicksilver nods at jonascj 
03:34:09 <quicksilver> jonascj: yes well the type system saves you from a lot of validation on function entry/exit
03:34:19 <quicksilver> which you see in well-written javascript, python or perl programs, say.
03:34:35 <quicksilver> (and programs in those languages which dont' validate parameters are normally subject to hard to track down bugs)
03:34:44 <quicksilver> but it doesn't save you from everything.
03:34:58 <quicksilver> Every interesting program I've written has used partial functions somewhere
03:35:08 <quicksilver> but it's excellent idea to minimise them and think twice before using.
03:35:32 <jonascj> I agree, thanks for the explanation
03:36:09 <julianleviston> jonascj: I often think of it as the compiler automatically writing a huge number of basic unit tests for you…
03:38:16 <jonascj> julianleviston: I don't remember my compiler course much, so I don't remember the mechanisms underlying type checking. It has to be some form of testing of course :)
03:39:42 <julianleviston> jonascj: when you get up to it, quickcheck is an amazing way to test your code. It lets you assert properties about your code and quickcheck then goes and creates auto-generated tests with rubbish values that test as many possible combinations of values as inputs…
03:44:30 <julianleviston> Why isn’t RecursiveDo standard?
03:45:31 <zaquest> julianleviston, it requires MonadFix?
03:45:47 <julianleviston> zaquest: ah ok. Complexity then?
03:46:40 <zaquest> julianleviston, im not sure, but i think not every Monad is also a MonadFix
03:46:51 <zaquest> julianleviston, im new to haskell :D
03:47:08 <julianleviston> zaquest: haha I think I am, too. It’s hard to tell :)
03:50:36 <jonascj> "learn you a haskell" compares guards to big if/else constructs, isn't it more exactly a switch?
03:51:43 <fizruk> jonascj: pattern matching is more like switch
03:52:57 <julianleviston> jonascj: have you seen case yet?
03:52:59 <fizruk> actually, I don't know if any mainstream language switch can also have guards
03:53:11 <julianleviston> jonascj: I think it all actually desugars into cases.
03:53:21 <frerich_> jonascj: Guards permit using arbitrary expressions evaluating to some boolean value, much like an 'if'. E.g. 'f x | x > 5 = True | otherwise = False'
03:53:43 <jonascj> fizruk: yeah okay, then guards are more like switch with expressions as cases. Which is most commonly a if/then construct.
03:53:57 <julianleviston> jonascj: except… you have pattern matching...
03:53:59 <frerich_> jonascj: ...unlike in a 'switch', where you commonly select a branch by testing some value for equality with some constant.
03:54:24 <jonascj> desugars :P
03:54:44 <julianleviston> jonascj: oh sorry “desugar = transform the syntax into a simpler syntax”
03:55:30 <fizruk> jonascj: probably, I am not sure which switch construct you're referring to (they are somewhat different across languages)
03:56:34 <tdammers> I'd go with "desugar = rewrite without using syntax sugar constructs"
03:56:45 <tdammers> or just the reverse of "sugar"
03:57:21 <jonascj> julianleviston: I got it, I had just never seen desugar. People usually say "a is sugar for b" instaed of "a desugars to b". The second one is refreshing :)
03:57:23 <julianleviston> jonascj: “under the hood” haskell has a simpler language called core… that has few syntactical constructs… that is the target for de-sugaring.
03:58:03 <tdammers> although quite often, desugaring is taken to target "Haskell minus do notation"
03:58:23 <tdammers> because do notation is the most commonly used sugar construct
03:59:13 <jonascj> I see, so it has a more specific haskell meaning than just a play on "syntactic sugar"
03:59:50 <julianleviston> jonascj: well all functions turn into lambdas, for example. (I think - tdammers will correct me I’m sure if I’m wrong) :)
03:59:51 <tdammers> more like, in a Haskell context, desugaring do notation is the most common case for desugaring
04:00:23 <capisce> does Haskell need a sugar tax?
04:02:33 <quicksilver> the reason we desugar into haskell-minus-that-construct is that is the way the report defines it, for the most past
04:02:44 <quicksilver> and it's not tied to a specific implementation.
04:03:17 <quicksilver> other constructs which are or can be defined as sugar are guards and numeric-matches
04:04:18 <Heather> do you prettify your haskell code?
04:04:44 <quicksilver> a bit, by hand
04:04:52 * quicksilver <3 M-x align-regexp
04:04:58 * certainty too
04:06:12 <Heather> I've tryed few prettifiers and all of them doesn't work or I can't handle them xD
04:06:22 <Unhammer> isn't stylish ok?
04:07:20 <pavonia> What do you do if you have a data type that you want to use as key for a Map that doesn't have a reasonable Ord instance?
04:07:47 <quicksilver> synthesise a key
04:07:50 <quicksilver> probably an Int
04:08:12 <pavonia> What do you mean by that?
04:08:20 <Heather> Unhammer stylesh fails on first non-ascii symbol :/
04:08:38 <quicksilver> well if there is no possible Ord instance for SubtleThing
04:08:47 <quicksilver> then I create a type called SubtleThingID
04:08:51 <quicksilver> (Which is probably just an Int)
04:08:57 <quicksilver> I keep those IDs around everywhere
04:09:01 <fizruk> pavonia: unordered-containers?
04:09:03 <quicksilver> and use them as map keys if needed.
04:09:19 <quicksilver> if there is a sensible way to hash the type, sure, fizruk 
04:09:38 <quicksilver> I kind assumed 'no sensible Ord intance' means 'no sensible Hashable instance'
04:09:50 <pavonia> I could derive the instance but it doesn't make much sense (to me at least)
04:10:03 <quicksilver> oh well if it's deriveable but not interesting
04:10:06 <quicksilver> then I derive it
04:10:09 <quicksilver> just for use in Maps
04:10:15 <quicksilver> and I don't worry about it not having an intrinsic meaning.
04:10:30 <pavonia> Oh, okay
04:10:44 <quicksilver> there are cases where you really *can't* produce one - like "IO ()" for example
04:10:52 <quicksilver> in those cases you have to do smoething like the synthetic ID approach.
04:12:09 <fizruk> quicksilver: yes, I took "doesn't have a reasonable Ord instance" as there is an instance, just not reasonable :)
04:12:34 <quicksilver> there is always an instance
04:12:40 <quicksilver> instance Ord Fizruk where compare = LT
04:13:29 <fizruk> that will break Map
04:13:34 <fizruk> I think
04:15:31 <hpc> it breaks a lot of things
04:15:46 <hpc> i think the best you could do is instance Eq Blahblah where (==) _ _ = False
04:16:29 <hpc> which still breaks refl, but NaN gets along just fine
04:20:30 <quicksilver> fizruk: yes it will :)
04:20:56 <Unhammer> Heather,  oh :-/ hadn't seen that yet. I've been pretty happy with hindent (gibiansky) and stylish so far
04:21:03 <quicksilver> to be honest Map is the main reason I have Ord instances.
04:21:17 <quicksilver> I very rarely actually care what the ordering is, on a custom data type
04:21:31 <quicksilver> if I sort somethiing it's normally sorting by a number or a string
04:21:41 <Heather> Unhammer please help me with hindent :) how can I use it from CLI or integrate into another editor?
04:21:54 <Unhammer> what editor?
04:22:21 <Unhammer> (I use emacs; hindent.el with pretty much no setup)
04:22:26 <Heather> Unhammer atom, I'm about to complete mode for it however... I even can't run it from console :/
04:22:44 * hackagebot network-info 0.2.0.8 - Access the local computer's basic network configuration  https://hackage.haskell.org/package/network-info-0.2.0.8 (JacobStanley)
04:22:46 <Unhammer> I haven't tried the cli actually
04:23:54 <Unhammer> but it seems that hindent.el just sends a region of text through "hindent --style somestyle"
04:24:18 <Profpatsch> Huh, okay, that might be strange (and is not even Haskell-related).
04:24:38 <Profpatsch> I’ve got a list of Peers a .. n that need to be initialized
04:24:47 <Profpatsch> s/a/1/
04:25:16 <Heather> Unhammer so far it doesn't work :/
04:25:17 <Profpatsch> Those need a a list of values to be initialized.
04:25:47 <Profpatsch> These values are the IDs of all other Peers in that list (after initialization).
04:26:22 <Profpatsch> Now: Is it possible to write a function that initializes all Peers in that list in a lazy way?
04:27:01 <Profpatsch> And by that I mean a function that doesn’t evaluate to bottom. :)
04:27:12 <Heather> UnknightMalta okay, I've tested on linux shell, if I do cat f.hs | hindent --style some - it works
04:27:40 <Unhammer> http://sprunge.us/KgPZ
04:27:42 <Unhammer> yeah
04:28:00 <julianleviston> Do I need to import Control.Monad.IO.Class for liftIO?
04:28:22 <Heather> Unhammer let me try to github my progress with atom
04:28:45 <Heather> Unhammer I can paste gist
04:31:23 <Heather> Unhammer here is my basic implementation: https://gist.github.com/Heather/911c9f92da7d0b829561
04:31:48 <fizruk> julianleviston: Control.Monad.Trans should be enough
04:31:49 <Heather> Unhammer but it just wipes all the text in open file :D
04:32:24 <julianleviston> fizruk: thanks! what’s the hackage name for it?
04:32:40 <julianleviston> fizruk: like for in my cabal file?
04:32:53 <fizruk> julianleviston: mtl
04:33:11 <fizruk> julianleviston: https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Trans.html
04:33:16 <julianleviston> fizruk: ahhh cool… I never know how to get from Module name to package name :) 
04:33:43 <fizruk> I just type module name in google
04:33:57 <julianleviston> fizruk: wow that seems a bit broken.
04:34:02 <fizruk> if it does not work, I add "hackage"
04:34:03 <julianleviston> fizruk: I spose whatever works! :)
04:34:05 <julianleviston> lol
04:34:07 <julianleviston> ok
04:34:18 <julianleviston> fizruk: so um… that didn’t work 
04:34:26 <Unhammer> Heather,  I've never done atom plugins so have no idea … but how about trying with some simple program first like command: 'hindent'
04:34:29 <Unhammer> sorry
04:34:51 <Unhammer> pasted too quickly
04:34:53 <Unhammer> command:'tr' args: ['a', 'b']
04:34:56 <fizruk> julianleviston: that should've worked, can you share code?
04:35:04 <julianleviston> fizruk: just doing so now
04:35:15 <fizruk> julianleviston: and the error message
04:35:29 <Heather> Unhammer good idea
04:35:42 <lpaste> JulianLeviston pasted “No title” at http://lpaste.net/143064
04:35:51 <julianleviston> fizruk: ^
04:36:16 <Heather> Unhammer works flawlessly
04:36:25 <fizruk> julianleviston: I don't see import Control.Monad.Trans
04:36:35 <Heather> Unhammer replaced all a to b in hs file
04:36:47 <julianleviston> fizruk: oh… that wasn’t my code… so I didn’t think I’d need to change it… 
04:37:03 <julianleviston> fizruk: I thought it was just that I was missing package includes in my cabal file
04:37:09 <Heather> Unhammer maybe hindent is just suddenly failing somewhere XD
04:38:33 <julianleviston> fizruk: I’ll add it and see what’s up then
04:38:44 <Unhammer> Heather,  try an absolute path?
04:38:53 <Unhammer> in the command
04:38:54 <fizruk> julianleviston: there is a missing import, clearly
04:39:06 <julianleviston> hm…. 
04:40:02 <fizruk> julianleviston: liftIO might have been re-exported by one of other imports in a different version of a dependency, so that code might have worked for someone else in the past... but I doubt that's the case
04:40:16 <julianleviston> fizruk: god ok
04:40:26 <Heather> Unhammer tr works w/o absolute path :/
04:40:56 <Heather> Unhammer https://github.com/Heather/atom-hindent - pushed full package so people will be able to test/reproduce or not
04:41:47 <julianleviston> fizruk: sweet :-)
04:42:04 <Unhammer> Heather,  but is hindent installed to the same folder?
04:42:21 <julianleviston> fizruk: nice! a groundhog snaplet huzzah :) see what’s next :)
04:42:23 <julianleviston> fizruk: thanks.
04:42:53 <Gurkenglas> julianleviston: For lines 169-175, consider https://hackage.haskell.org/package/text-1.2.1.3/docs/Data-Text.html#v:split
04:43:07 <quicksilver> fizruk: Monad-CatchIO looks like a very likely candidate to have rexported MonadIO in a previous version, IMO.
04:43:15 <julianleviston> Gurkenglas: I didn’t write this
04:43:33 <Unhammer> Heather,  could be that tr is in /usr/bin (and /usr/bin is in atom's PATH) and hindent in /usr/local/bin or ~/.cabal/…bin 
04:43:39 <quicksilver> Heather: can you run hindent on the command line?
04:43:41 <fizruk> quicksilver: my suspect was also Control.Monad.Logger
04:43:41 <julianleviston> quicksilver: although, it’s only importing MonadCatchIO from that isn’t it?
04:44:00 <Unhammer> Is there a way to pattern match on Array bounds?
04:44:06 <julianleviston> seems a bit weird that there are two qualified improts both aliased to “C” !
04:44:06 <fizruk> quicksilver: which does not have explicit import list
04:44:25 <quicksilver> you can't avoid importing instances
04:44:26 <quicksilver> can you?
04:44:28 <Heather> quicksilver yes and I can get results on linux from cli, sadly don't know how to get results on windows
04:44:33 <fizruk> julianleviston: that's convenient actually
04:44:42 <julianleviston> fizruk: what does it do?
04:44:49 <fizruk> quicksilver: that does not import methods, right?
04:44:56 <quicksilver> fizruk: oh, that's true :)
04:45:03 <julianleviston> fizruk: I would have thought it’d clash
04:45:12 <quicksilver> not much point trying to debug running a program from inside atom until you can run it outside atom
04:45:16 <quicksilver> IMO.
04:46:16 <Unhammer> oh windows
04:46:20 <fizruk> julianleviston: nope, a convenient union. note that this C alias is used for Data.Configurator and Data.Configurator.Types, which come from the same place
04:46:42 <julianleviston> fizruk: ah right
04:46:43 <fizruk> julianleviston: the similar and more common example is with Data.Text imported as T
04:47:10 <fizruk> julianleviston: which you can find a few lines below in that same file
04:47:43 <julianleviston> fizruk: yeah, cool. Thanks! :) that’s good to know.
04:48:22 <fizruk> julianleviston: it is not necessary though for the modules to come from one place to be aliased to the same name
04:48:36 <julianleviston> fizruk: now I have to work out how to mount this snaplet into my snap app :)
04:58:50 <julianleviston> why is mtl in quotes here? import "mtl" Control.Monad.State (get)
04:59:24 <liste> julianleviston it specifies the package to import from
05:03:45 <julianleviston> liste: thanks :0
05:05:29 <jophish> Has anyone given any thought to optional dependencies. So I could write a library which has an optional dependency on quickcheck which does the following: If any other package being compiled has a dependency on quickcheck then this acts as a proper dependency, and my instance for Arbitrary (a class in quickcheck) is compiled and exports. If no other package depends on quickcheck then my package doesn't pu
05:05:33 <Heather> works! :D
05:05:35 <jophish> ll it in, and the instance declaration isn't compiled
05:05:38 <jophish> there may be a better way of phrasing that
05:06:11 <jophish> but it would allow libarary writers to write all the instances they like, without pulling in the world in dependencies
05:07:04 <jophish> or get rid of mypackage-quickcheck-instances packages full of orphan instances
05:07:46 * hackagebot stack 0.1.6.0 - The Haskell Tool Stack  https://hackage.haskell.org/package/stack-0.1.6.0 (borsboom)
05:08:31 <Heather> Unhammer my mode aws only failing because of my file, maybe because of UTF either :( - works fine on it's own sources (however it's really makes code look ugly for now
05:08:47 <fizruk> jophish: I think you can use flags currently for almost that
05:10:39 <julianleviston> Sometimes it’s just SO hard to work out which functions are coming from which imports… unless you “just already know”. Makes understanding code really difficult.
05:11:30 <voidzero> there is :i
05:11:32 <julianleviston> not using unqualified, undescribed imports would solve that
05:11:53 <julianleviston> voidzero:  yeah, that’s inside ghci, but I’m just meaning reading source.
05:12:06 <voidzero> yeah, not saying i disagree
05:12:14 <julianleviston> fair enough!
05:13:00 <julianleviston> voidzero: it’s usually not *so* bad, unless you’re reading something that has 25 imports or so
05:14:00 <jophish> fizruk: yeah, that just occurred to me, to get exactly what I'm asking would just require cabal to automatically set a flag if another package was included in a build
05:14:35 <jonascj> Is compiled haskell different from "compiled" python? Python is still an interpreted language, what about Haskell?
05:15:08 <quicksilver> GHC compiles haskell to native code
05:16:21 <tdammers> that native code does contain the GHC runtime though
05:16:27 <quicksilver> julianleviston: yes, that's nasty. A smart editor can solve that.
05:16:49 <quicksilver> tdammers: that's true of C as well though ;)
05:16:49 <tdammers> so for some values of "interpreted", one could say that GHC Haskell is interpreted
05:16:51 <jonascj> quicksilver: so you could take a compiled haskell binary with you and only need some libraries? (like compile c programs need glibc or similar)?
05:16:58 <quicksilver> yes jonascj 
05:16:58 <tdammers> quicksilver: not all C
05:17:12 <quicksilver> tdammers: true. But the C that most people mostly use.
05:17:13 <tdammers> quicksilver: but when it's not, you're probably writing a kernel
05:17:35 <tdammers> or firmware for an embedded device or sth
05:17:45 <mariooo> Hey all! :) I'm slowly learning the lens package, and have come a bit stuck with how to deal with function composition when a Maybe is involved.
05:17:58 <mariooo> Here's a contrived but hopefully simple example: https://gist.github.com/supermario/5c54e07bf461c280794b
05:18:42 <jonascj> so it is not 100% retarded to compare quick sort written in haskell and compiled, with quick sort written in c and compiled? It might not be either with java vs. c, but java will always have some overhead due to its virtual machine etc.
05:18:45 <quicksilver> mariooo: box . value . _Just %= succ
05:19:00 <quicksilver> erm
05:19:03 <quicksilver> sorry misread your code
05:19:11 <quicksilver> box . _Just . value %= succ
05:19:33 <clinton> quick question, how can I get "cabal haddock" to recursively generate required documentation so I don't get the warning "Warning: The documentation for the following packages are not installed"
05:19:33 <quicksilver> will have the effect of running 'succ' if it's a Just value, and leaving it unchanged if it was Nothng.
05:19:47 <jophish> jonascj: haskell as compiled by ghc doesn't run on a virtual machine, if that's what you're asking
05:19:58 <fizruk> clinton: stack haddock :p
05:19:59 <clinton> or alternatively, how do I generate the docs for a particular package that's already installed
05:20:05 <mariooo> @quicksilver wow... was not expecting such a fast response, thanks so much!
05:20:06 <lambdabot> Unknown command, try @list
05:20:12 <quicksilver> mariooo: you're welcome :)
05:20:28 <mariooo> Gonna go give it a go now and stretch my mind a little more :D
05:20:51 <jonascj> jophish: that was not what I was asking. I was asking if you could hope haskell to match c performance for something like quick sort. And stating that you can of course compare any implementation, i.e. C vs. Java, but java would per definition have more overhead than C. 
05:21:00 <quicksilver> tdammers: so it turns out there isn't a hard difference between interpreter and compiler but if we have to be black and white Im' pretty sure we'd come down on the side of compiler.
05:21:06 <quicksilver> (for GHC)
05:22:08 <tdammers> quicksilver: absolutely
05:22:15 <fizruk> clinton: for Cabal, I guess you have to reinstall packages: http://stackoverflow.com/a/7777341/442535
05:23:02 <jophish> jonascj: Measuring which language is faster is really tricky to do. Java can be faster than (most C) in cases thanks to it running in a VM.
05:23:50 <tdammers> jophish: I proposed a different metric a while ago: given an example problem, and a minimum acceptable performance metric, how much developer time does it cost to build a valid solution?
05:23:52 <jophish> Given enough effort, C will always win, because it could be used to generate the same machine code any other language runs on, but this may prove to be not worth the development cost
05:24:10 <jophish> tdammers: that's a good one :)
05:24:30 <quicksilver> that's actually untrue
05:24:39 <jophish> My money would be on Haskell to have a pretty good tradeoff there
05:24:40 <quicksilver> there is lots of machine code sequences which C is entirely unable to generate
05:24:41 <julianleviston> jonascj: sometimes, haskell is actually faster.
05:24:45 <quicksilver> (without all kinds of C extensions)
05:24:48 <tdammers> for some problems, PHP wins - not because it's fast, but because the required speed is easy to achieve, the problem is brain-dead simple, and PHP happens to have the required functionality built into it
05:24:59 <jophish> quicksilver: excluding inline asm :D
05:25:05 <quicksilver> FORTRAN is faster than C for some programs because FORTRAN compilers generate different asm
05:25:15 <quicksilver> jophish: yes, but that's not C, is it? that's asm.
05:25:25 <tdammers> C usually wins the performance metric given an unlimited developer time budget
05:25:30 <tdammers> (usually, not always)
05:25:36 <jophish> quicksilver: wait, couldn't one just write fortranesque machine code to memory, mark it as executable and run that?
05:25:46 <jonascj> so yes, you could hope the straight forward implementation of quick sort in Haskell to compete with the straight forward implementation in C :)
05:25:52 <julianleviston> jonascj: we have some ridiculously fast websevers, for example.
05:25:53 <jophish> I suppose that requires some OS library
05:26:09 <quicksilver> jophish: personally I don't think that counts as writing C.
05:26:12 * quicksilver shrugs
05:26:19 <quicksilver> you have to have rules I suppose.
05:26:28 <tdammers> but if you want to reimplement, say, Pandoc, in C, it'll take a long while before you reach the same level of performance and quality
05:26:29 <quicksilver> I could write haskell to do that trick you just did too.
05:26:30 <obadz> julianleviston: huh?
05:26:31 <jophish> quicksilver: I agree, it is a stretch
05:26:35 <obadz> julianleviston: what are those?
05:26:35 <merijn> Fortran is faster than C for A LOT of programs
05:26:40 <merijn> C is a terrible HPC language
05:26:54 <obadz> Fortran can vectorize more since it understands arrays
05:26:59 <julianleviston> obadz: yesod and snap
05:27:44 <julianleviston> obadz: you don’t agree?
05:27:50 <jonascj> I got more than I bargined for, thank you guys. I think I'll do a little quicksort haskell vs. c test, now that I now it is not immediately given which should be faster.
05:27:51 <merijn> GHC's threading and IO are ridiculous fast compared to anything but hand optimised server loops, and even then it compares decently
05:28:18 <merijn> jonascj: Well, to be fair I think quicksort is a pretty poor algorithm for Haskell
05:28:29 <tdammers> transparent green threads are an amazing productivity boost when it comes to writing performant parallel code
05:29:04 <merijn> jonascj: Because quicksort needs mutable array to perform sanely. So that requires you use arrays or vectors instead of lists (quicksort *especially* doesn't make sense on Haskell lists
05:29:20 <obadz> julianleviston: https://www.youtube.com/watch?v=McYhbIubeTc&hd=1#t=5m15s this guy doesn't agree..
05:29:28 <merijn> jonascj: I think merge-sort is a more logical sort for haskell (which is why the default sort in base is optimised merge-sort)
05:30:07 <jonascj> merijn: yes this Learn You A Haskell book says quicksort is the go-to example for elegant Haskell code. I'll have to think about what you said.
05:30:15 <obadz> julianleviston: or that: https://www.techempower.com/benchmarks/
05:30:23 <merijn> obadz: Ooh! Ur/Web talk? :D
05:30:51 <merijn> jonascj: To be fair, I don't think the "example quicksort" people give in haskell is actually quicksort (opinions differ)
05:31:09 <jonascj> oh, even more to think about. I'll get back to thinking. Thank you for your input
05:31:35 <julianleviston> obadz: oh ok… I thought we were pretty good… dang.
05:32:16 <obadz> julianleviston: speed isn't everything. it's very easy to paralellize web frontends so why bother.. correctness and expressivity are more important to me. speed is gravy.
05:32:22 <julianleviston> obadz:  that can’t be right. 
05:32:24 <merijn> jonascj: IMO quicksort is 1) in place and 2) O(n log n), the usual "qsort (x:xs) = qsort [e | e <- xs, e <= x] ++ [x] ++ qsort [e | e <- xs, e > x]" is neither of those two
05:33:08 <merijn> julianleviston: We are pretty fast in terms of raw IO power, the framework/apps tend to be bottlenecks
05:33:13 <hodapp> jonascj: I'm curious why you'd say that Java would have "per definition" more overhead than C.
05:33:20 <hodapp> which definition would that be?
05:33:27 <julianleviston> obadz: that’s not a good metric
05:33:35 <tdammers> hodapp: the "compile-once-run-anywhere" approach, I guess
05:33:40 <julianleviston> obadz: rails slows down massively the moment you have a few objects loading.
05:33:46 <tdammers> for some values of "more", anyway
05:33:53 <merijn> tdammers: Java + JIT can beat C on a lot of benchmarks
05:33:53 <m1dnight_> Guys, I have a lambda calculus evaluator and I would like to add the primitive "fork" which would spark a new thread (to then communicate with channels). But the thing is, my entire evaluator is not in the IO monad. How can I still fork a new thread in a pure function?
05:33:56 <obadz> julianleviston: good metrics are few and far between
05:34:00 <julianleviston> obadz: yeah.
05:34:13 <tdammers> merijn: I know. And the whole JIT thing is the main reason for that, I believe
05:34:19 <merijn> m1dnight_: You can't, unless you simulate threads in your interpreter using coroutines
05:34:25 <julianleviston> obadz: I was taliking about websrving, not application serving per se… but yes. :)
05:34:29 <obadz> merijn: yeah, got to admit that guy has really put in the effort to squeeze out max performance :)
05:34:43 <tdammers> C simply cannot profile the target machine and re-optimize the application code on the fly
05:34:51 <tdammers> but Java can
05:35:00 <aweinstock> https://github.com/aweinstock314/haskell-stuff/blob/master/Quicksort.hs
05:35:21 <aweinstock> ^ benchmarks of ST-based quicksort, naive "quicksort", and C's qsort(1) via FFI
05:35:30 * obadz wonders why we talk so much about performance when it's so often not a problem.
05:35:32 <julianleviston> obadz: however, Haskell / FP is more likely to be fast simply because our code is more efficient by design (IMO)
05:35:41 <julianleviston> obadz: it’s a problem for me.
05:35:58 <hodapp> obadz: because it's one of the few numbers people can find.
05:35:59 <jonascj> hodapp: It was just what I had always thought. If you want to go from scratch (no process created, no cpu time used) to a solved problem (processes started, cpu time used etc.) I think Java would inevitably have more overhead since it needs to create/start a JVM to run the java program, whereas the C application could be loaded straight into memory and executed.
05:36:01 <obadz> julianleviston: what is your domain?
05:36:06 <julianleviston> obadz: web apps
05:36:23 <obadz> julianleviston: and they can't be distributed?
05:36:34 <obadz> julianleviston: or are amazon instances too expensive?
05:36:36 <julianleviston> obadz: it depends on the architecture.
05:36:38 <hodapp> jonascj: If it's "you think", then "by definition" or "per definition" really doesn't belong there.
05:36:49 <julianleviston> obadz: yeah, that, but also the fact that data collection is expensive, if unoptimized.
05:36:58 <julianleviston> obadz: time-wise.
05:37:24 <jonascj> obadz: people always want to compare and compete. Who can run the fastest 100m sprint? It isn't really a problem that matters much to our daily lives, yet we still spend quite a lot of time and energy discussing it and competing about it.
05:37:46 <aweinstock> foreign import ccall "dynamic" callFunPtr :: FunPtr () -> IO ()
05:37:47 <aweinstock> unsafeExecuteString = flip withArray (callFunPtr.unsafeCoerce) . map ((id::Word8->Word8).fromIntegral.ord)
05:38:00 <julianleviston> obadz: I see your point, though… however, that “performance isn’t going to matter” was the argument Rails’ creator used to use… and that fell over quite quickly (IMO) the moment you build a “big” app.
05:38:03 <aweinstock> ^ executing a string as RWX machine code
05:38:03 <hodapp> jonascj: I would submit that a better thing to worry about is correctness, and then scalability.
05:39:05 <jonascj> hodapp: you are right, per definition was wrong (unless "starting VM + execution" > "execution", like 2>1).
05:39:10 <merijn> Not all code has to be fast, but all code has to be correct :p
05:39:21 <merijn> Or, put differently
05:39:37 <merijn> I can optimise any algorithm to be constant if I don't have to be correct ;)
05:39:39 <ideuler> @pl foldList l = foldr (++) [] l
05:39:40 <lambdabot> foldList = foldr (++) []
05:40:25 <aweinstock> ideuler: mconcat
05:40:29 <ideuler> Hm, I'm getting a error on the pl implementation of concat "No instance for (Foldable t0) arising from a use of", but when I do a let in ghci such does not happen.
05:40:38 <hodapp> jonascj: No, it's wrong unless you've given pretty strict definitions for all terms involved.
05:40:55 <aweinstock> :t [foldr (++) [], mconcat]
05:40:57 <lambdabot> [[[a]] -> [a]]
05:42:00 <jonascj> hodapp: I am not worried about Haskell performance, it was just something I thought about when the book I am reading mentioned implementing quicksort. And when somebody mentions sorting implementations, I always start thinking about large input. Because otherwise the algorithm choosen does not matter.
05:42:33 <merijn> jonascj: The optimised sort used by GHC is actually surprisingly simple and readable
05:42:40 <breadmonster> jonascj: There's another reason why that matters, honestly the quicksort implementation we show foreigners is not the one we use.
05:42:45 <putis> Is it possible to execute Template Haskell without compilation?
05:42:50 <merijn> jonascj: https://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.OldList.html#sort
05:42:52 <breadmonster> merijn: Source?
05:42:54 <ideuler> aweinstock the thing is, implementing it in ghci works with :t "Foldable t => t [a] -> [a]" (as intended), yet on my file, when I try to load it, " No instance for (Foldable t0) arising from a use of ‘foldr’", point-wise works. Why is that?
05:43:00 <merijn> jonascj: Plus lots of comments about other implementations and speed
05:43:14 <jonascj> merijn: I'll hvae to look at it osme day, but maybe it is not as quick as others for large input. But then again, who sorts trilions of entries in Haskell?
05:43:14 <merijn> putis: No, Template Haskell is compile time by definition
05:43:28 <breadmonster> That's a really interesting sort.
05:43:38 <merijn> jonascj: I mean, for "trillions" you want to handroll a streaming sort anyway, most likely
05:43:48 <putis> marijn: thanks
05:43:52 <merijn> jonascj: But mergesort has a better worst-case behaviour than quicksort, so... :)
05:44:32 <merijn> breadmonster: Basically it skips splitting everything into 1 element chunks by keeping ascending and descending (i.e. pre-sorted chunks) together and then merge sorting
05:45:19 <jonascj> So like hodapp said, most people will neve rhave to worry about performance, more about correctness and scalability (like a web app which can handle being run on many webservers simultaniously to load balance). Performance maybe if you do something scientific or implement databases or similar.
05:46:11 <merijn> jonascj: Writing high performance stuff in haskell is doable and not substantially harder than in C (this is not because it's easy, but because doing so in C is harder than people seem to think :p)
05:47:09 <meijiJAPAN> i'm a little rusty about haskell
05:47:09 <merijn> jonascj: I would say the biggest weakness of haskell would be realtime performance, since garbage collection +laziness can make it trickier to talk about reaching deadlines. But for most HPC we tend to care more about throughput than latency/jitter
05:47:26 <meijiJAPAN> any e-books that you can recommend
05:48:16 <breadmonster> meijiJAPAN: There's a really nice book called Learn You a Haskell.
05:48:29 <merijn> jonascj: Snoyman (from Yesod) was working on high-frequency trading stuff with conduit, if I remember. Optimising to like nanosecond inner-loops
05:48:30 <jonascj> merijn: I have had a little glimse at that. As an assigment I had to implement GotoBLAS matrix-matrix multiplication with optimixation for cache sizes etc. It was immensly hard to get a single core to be loaded more than 80% when doing matrix matrix multiplication. The point was to get what you could from one core before you decide to distribute it (like 10% load on 10 cores vs. 100% load on 1 core).
05:48:57 <breadmonster> merijn: Snoyman does high frequency stuff?
05:49:40 <breadmonster> I'm not sure if you guys notice this, but Haskell standard library code looks like something even a beginner could write.
05:50:11 <breadmonster> It just struck me as a measure of ghc's awesomeness.
05:50:24 <merijn> breadmonster: Not really, I think it was "toy" high frequency example to check the speeds
05:50:40 <merijn> breadmonster: Be careful, the source has 2 versions usually, the traditional Prelude and the GHC version
05:50:52 <breadmonster> merijn: What do you mean?
05:50:55 <merijn> And the GHC version + rewrite rules tend to be more complex
05:51:09 <merijn> breadmonster: "#ifdef USE_REPORT_PRELUDE" <- those
05:51:33 <breadmonster> I've never seen those, but okay.
05:51:46 <breadmonster> But yeah, there are some rewrite rules I never really figured out.
05:51:49 <quchen> Data.List.sort looks like it could have been written by a smart beginner. It's a really nice function.
05:51:50 <breadmonster> The build/foldr rule was one.
05:52:01 <breadmonster> quchen: hi!
05:52:31 <quchen> Hello
05:53:14 <merijn> I would say a beginner couldn't have written sort, but I agree that a beginner can relatively easily UNDERSTAND sort
05:56:40 <aweinstock> :t Data.Foldable.foldr
05:56:41 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
05:56:46 <aweinstock> :t Prelude.foldr
05:56:47 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
05:57:04 <aweinstock> ideuler: if you're on an older GHC version, try "import Data.Foldable"?
05:58:04 <breadmonster> @let (!=) = (/=)
05:58:06 <lambdabot>  Defined.
05:58:07 <ideuler> aweinstock doesn't seem to be the issue, I'm on 7.10.2 
05:58:11 <breadmonster> @undefine
05:58:11 <lambdabot> Undefined.
05:58:41 <breadmonster> why on earth does Haskell use the strange (/=)?
05:58:41 <breadmonster> I thought it was some parsing issue, but that's clearly not the case.
05:59:44 <merijn> Looks more like math
05:59:53 <merijn> Math uses ≠
06:00:02 <merijn> So if you imagine the / being over the =
06:00:30 <Heather> I wonder if there is ≠ in Lnaguage UnicodeSyntax even
06:01:13 <aweinstock> :t let (!=) = (/=) in (!=)
06:01:13 <Heather> also not sure if ≠ is correct :) because (=) /= (==)
06:01:14 <lambdabot> Eq a => a -> a -> Bool
06:01:37 <aweinstock> > let (!=) = (/=) in 1 != 2
06:01:38 <lambdabot>  True
06:02:09 <merijn> Heather: I said it was inspired by that symbol
06:03:01 <merijn> > let (≠) = (/=) in 2 ≠ 3
06:03:03 <lambdabot>  True
06:03:11 <Heather> merijn I mean another thing :/
06:04:01 <Heather> if == should be treated as ≡ then logically there should be ≢ and /== XD
06:04:21 <fkbm> Whoah =ception
06:04:22 <Heather> and /= is not (not equal) /= is not bind :D
06:04:59 <Heather> confusion everywhere
06:05:05 <merijn> Heather: You sound like a dependent types/homotopy type theory person :p
06:05:10 <jophish> I'm pretty sure it should be ≠=
06:05:12 <jophish> ho ho
06:05:23 <merijn> They always find fifteen gazillion different kinds of equality to talk about :p
06:05:38 <Heather> jophish ≢ is fine enough XD
06:06:06 <fkbm> merijn: it's weird because just minutes ago a guy on C said “There's no «in theory» in the world of programming...”
06:06:07 <jophish> I seem to remember subhask having some fancy equality machinary
06:06:07 <kriztw> :q
06:06:11 <kriztw> oops
06:06:12 <jophish> machinery *
06:06:50 <Ferdirand> Heather: in that case, what should be the semantics of ≠ ?
06:06:57 <merijn> fkbm: Hah, shows what he knows, there's LOTS of in theory that we don't know how to do :p
06:07:29 <fkbm> merijn: The more you learn, the more you think you know less.
06:07:37 <Heather> Ferdirand let x ≠ 1 in 1 + x // error :D
06:07:47 <merijn> fkbm: Such as, IN THEORY rank 2 types can be inferred. In practice, no one knows how to do it...(well, besides this one research paper that came up with an implementation of 37 pages long that no one ever attempted to use :p)
06:07:58 <Unhammer> Heather,  try out the various styles in hindent though; they vary a lot
06:08:00 <Heather> Ferdirand I dunno, it's some fun context under it
06:08:33 <fkbm> merijn: that sounds like a big undertaking :D I doubt that someone would use it unless he needed it that much
06:08:49 <Heather> Unhammer I even can't switch to one style after switching to another, e.g. in order, on some files.... seems like it's still being very young and buggy
06:09:29 <aweinstock> jophish: https://github.com/mikeizbicki/subhask/blob/master/README.md#comparison-hierarchy
06:10:31 <merijn> fkbm: Well, in practice no one bothers because type-checking rank2 is simple, so in practice the solution in GHC is: Well, just write down type signatures if you want Rank2 types, then!
06:13:09 <aweinstock> merijn: is rank-n type-inference decidable for specific n? (I remember hearing that the general case is undecidable)
06:14:12 <quicksilver> it's decideable for n=1, aweinstock :)
06:14:15 <quicksilver> that's one specific n.
06:14:19 <merijn> quicksilver: n <= 2
06:14:28 <merijn> n > 2 is proven undecidable
06:14:32 <ideuler> unless I specify foldList = foldr (++) [] as type foldList :: Foldable t => t [a] -> [a]  (same as concat) it fails to load due to "several potential instances: of Foldable to" anything I can do?
06:14:42 <merijn> 1 and 2 have been proven decidable, albeit it ridiculously hard for 2
06:14:50 <quicksilver> haskell type inference isn't even decidable for n=1 though
06:15:01 <merijn> quicksilver: Eh, yes it is...
06:15:15 <quicksilver> merijn: show . read
06:15:17 <aweinstock> ideuler: try: foldList :: Data.Foldable.Foldable t => t [a] -> [a]
06:15:30 <merijn> quicksilver: That's not undecidable, just ambiguous
06:15:46 <quicksilver> seems undecidable to me
06:15:53 <quicksilver> it can't decide what type the term 'read' means
06:15:57 <aweinstock> quicksilver: (show . read) :: (Show a, Read a) => a -> a
06:16:11 <merijn> aweinstock: No, it's "String -> String"
06:16:26 <merijn> And it can't decide which instances to use function to use
06:16:32 <ggole> Polymorphic recursion causes inference problems, and doesn't (necessarily) involve rank-n types
06:16:37 <quicksilver> ideuler: you could make it [[a]] -> [a], if you like, but what do you want it to be?
06:16:46 <aweinstock> oops, was my type for (read . show)?
06:17:03 <ggole> Typically the answer is the same: provide annotations, problem pretty much goes away.
06:17:08 <quicksilver> aweinstock: yes, it was, although read.show actually has the type (Show a, Read b) => a -> b
06:17:30 <Freundlich> quicksilver: "Decidable" has a precise mathematical definition.
06:17:42 <Freundlich> It isn't about a humans making decisions.
06:17:42 <aweinstock> > (show . read) (5::Int) :: Float
06:17:44 <lambdabot>      Couldn't match type ‘[Char]’ with ‘Float’
06:17:44 <lambdabot>      Expected type: Float
06:17:44 <lambdabot>        Actual type: String
06:17:53 <aweinstock> > (read . show) (5::Int) :: Float
06:17:53 <quicksilver> Freundlich: yes, I obviously don't understand it well enough.
06:17:54 <lambdabot>  5.0
06:18:08 <SrPx> Simpler Haskell lib for creating a static web server and REST service with post/get ? 
06:18:24 <frerich_> Scotty!
06:18:27 <quicksilver> Freundlich: it seems to me a type inference algorithm that cannot assign a type to the subterm 'read' in the term 'show . read' has failed as a type inference algorithm.
06:18:48 <ideuler> quicksilverI want it to be foldList :: Foldable t => t [a] -> [a] and it works only I do specify its type like that. But I would like not to specify its type. So that "foldList = foldr (++) []" is enough, just like when I do a let in ghci
06:19:11 <quicksilver> ideuler: set the language option NoMonomorphismRestriction
06:19:12 <jkarni1> SrPx: servant :)
06:19:42 <frerich> > show . _
06:19:44 <lambdabot>      Found hole ‘_’ with type: a -> ()
06:19:44 <lambdabot>      Where: ‘a’ is a rigid type variable bound by
06:19:44 <lambdabot>                 the inferred type of it :: a -> String at <interactive>:1:1
06:20:02 <frerich> Hm
06:20:15 <jophish> Someone must have written a quickcheck suite for num instances. Where might I find this, {h,g}oogle wasn't any help
06:20:29 <Freundlich> quicksilver: A "problem" is a subset of the natural numbers (or any countable set). A decision problem is, given a natural number i, does i belong to that set?
06:20:47 <jkarni1> jophish: http://hackage.haskell.org/package/checkers maybe
06:21:05 <Freundlich> quicksilver: We call such a set decidable if there is an algorithm that, given such an i, can correctly say yes or no.
06:21:17 <quicksilver> Freundlich: yes.
06:22:03 <jophish> jkarni1: yeah, that was the first place I looked :) no Num checker though
06:22:32 <jophish> Freundlich: I'm pretty sure quicksilver understands already :)
06:22:42 <Freundlich> Ok.
06:22:43 <quicksilver> I don't.
06:22:52 <quicksilver> my maths education was a very long time ago.
06:22:58 <jophish> ah sorry, my mistake
06:23:07 <quicksilver> I don't see why ambiguity isn't a kind of undecidability
06:23:24 <quicksilver> do the details lie in precisely how you express type inference as a decision problem?
06:24:05 <SrPx> jkarni1: ah not what I'm looking for, thanks :( I just need a simple way to set a get/post handler to expose a haskell lib as a rest service
06:25:00 <SrPx> (I think)
06:28:17 <ideuler> quicksilver Yes, it works that way. So, unless I specify that, it attempts to type my function as monadic? Whilst doing it in ghci directly by default uses nomonomorphism?
06:28:43 <quicksilver> ideuler: monomorphic yes. top-level values with no arguments are forced to be monomorphic in the haskell standard
06:28:52 <quicksilver> lots of people regard this as a bad choice (with hindsight)
06:29:00 <quicksilver> the resason for it was to do with intuitions about sharing.
06:29:04 <aweinstock> quicksilver: typechecking is obviously a decision problem ("do these typing judgements satisfy the constraints of the typesystem (yes/no)?"), expressing type inference as a decision problem seems a lot trickier
06:29:27 <quicksilver> ideuler: some information is here - https://wiki.haskell.org/Monomorphism_restriction
06:30:34 <aweinstock> quicksilver: the standard way of expressing optimization problems ("find x minimizing f(x)") as decision problems is ("is f(x) < k ?"), in case that's relevant
06:31:07 <ideuler> quicksilver thanks! I did find it odd, that the behaviour through a let in the interpretor or the function defined in a file was different. I'll read it 
06:31:30 <quicksilver> aweinstock: "is there some valid assignment of types which is a superset of all assignments I can construct" perhaps
06:32:49 * hackagebot naver-translate 0.1.0.2 - Interface to Naver Translate  https://hackage.haskell.org/package/naver-translate-0.1.0.2 (hongminhee)
06:39:04 <rjbs> I'm learning Haskell and have a question about an example I have just read.
06:39:41 <clrnd> rjbs, ask ahead
06:39:42 <rjbs> mapF is defined in this example as:  mapF :: Monad m => (a -> b) -> m a -> m b
06:40:01 <rjbs> mapF f m = do x <- m \n return (f x)
06:40:02 <clrnd> :t fmap
06:40:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:40:57 <clrnd> okay
06:41:04 <rjbs> I was curious as to how "return" here wraps (f x) in the right monadic type.  Has it been type-inferred somewhere, so the return is implicitly (( return (f x) :: Whatever )) ?
06:41:15 <clrnd> yeah
06:41:16 <clrnd> :t return
06:41:18 <lambdabot> Monad m => a -> m a
06:41:39 <hexagoxel> is Ord necessary for a "Map" type, if performance does not matter?
06:42:09 <rjbs> Okay.  So the type returned will be inferred from the context in which mapF is used?  That would make sense to me
06:42:12 <clrnd> hexagoxel, Map uses internally a data structure that uses Ord, you can build your own map out of a List with bad performance if you want to anyway
06:42:13 <tdammers> Ord isn't necessary for the type itself, but all the useful operations do require it
06:42:26 <clrnd> rjbs, exactly
06:42:32 <rjbs> clrnd++ # thanks, very helpful
06:42:33 <clrnd> > return 5 :: Maybe Int
06:42:35 <lambdabot>  Just 5
06:42:46 <clrnd> > return 5 :: [Int]
06:42:47 <lambdabot>  [5]
06:43:00 <clrnd> > return 5 :: Either () Int
06:43:02 <lambdabot>  Right 5
06:43:04 <hexagoxel> clrnd: does that exist somewhere already? i currently use Map interface, but now need to add one thing to the key that cannot have Ord instance.
06:43:05 <clrnd> rjbs, ^
06:43:33 <hexagoxel> i.e. is there a non-Ord container with an interface similar to Map?
06:44:04 <clrnd> hexagoxel, well .... https://hackage.haskell.org/package/unordered-containers-0.2.5.1/docs/Data-HashMap-Strict.html
06:44:25 <clrnd> there may be others
06:44:33 <tdammers> without Ord, you can still construct empty maps and singleton maps, and you can query for length and emptiness; you can also map/traverse/fold over the Map in various ways, and extract various list representations
06:44:44 <cofo> haskell
06:44:49 <cofo> ,hgcc
06:44:54 <cofo> ,hcc
06:45:18 <tdammers> http://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Map-Strict.html
06:45:30 <tdammers> interestingly, there's quite a bunch of functions in there that don't require Or
06:45:33 <tdammers> Ord
06:45:49 <nomeata> Hi. Has there ever been a published paper on the criterion library?
06:46:34 <jonascj> what is the concept there "addThree = \x -> \y -> \z -> x + y + z ", it is suppose to be equal to "addThree x y z = x+y+z"? What is this "\x->" construct called?
06:47:12 <Big_G> Does return for either only work for the right side? What if it's either into () 
06:47:21 <SrPx> I am thinking, couldn't, with Template Haskell, one create a lib that transforms normal haskell functions in an HTTP service?
06:47:27 <jonascj> oh, it's lambdas?
06:47:50 <kriztw> jonascj: yes
06:48:21 <kriztw> also known as anonymous functions
06:49:33 <merijn> Big_G: I have a question for you to consider :)
06:49:35 <merijn> :t return
06:49:37 <lambdabot> Monad m => a -> m a
06:49:52 <merijn> Big_G: When we are talking about Either, what does 'm' equal in that type? :)
06:51:09 <jonascj> kriztw: so three nested lambdas? \x-> (\y-> (\z -> x + y +z)))
06:51:36 <Big_G> If I'd have to guess,I'd say it's either x where x  is the left. e 
06:51:43 <merijn> jonascj: Right
06:52:06 <merijn> Big_G: Correct :) Does that answer your question?
06:52:50 * hackagebot secp256k1 0.1.2 - secp256k1 bindings for Haskell  https://hackage.haskell.org/package/secp256k1-0.1.2 (xenog)
06:53:05 <Big_G> Yeah, it does. Seems odd though if left is a non error type 
06:53:12 <kriztw> jonascj: yes, and this view also makes currying easier to understand: if you apply that to an argument, you get (\y-> (\z -> x + y +z)) back, i.e. a function of two arguments
06:53:25 <kriztw> with x replaced with the argument of course
06:54:07 <merijn> Big_G: It's just that the kind of Monad doesn't allow anything else. Semi-related (it doesn't have pure, but other stuff) you might be interested in Data.Bifunctor?
06:54:44 <Big_G> Never heard of it so I can't say 
06:54:53 <merijn> Bifunctor is a generalisation of functor to types with two arguments
06:55:33 <merijn> So instead of "fmap :: Functor f => (a -> b) -> f a -> f b" you get "bimap :: Bifunctor f => (a -> c) -> (b -> d) -> f a b -> f c d"
06:55:58 <merijn> The obvious case of Either being "(a -> c) -> (b -> d) -> Either a b -> Either c d"
06:56:35 <jonascj> kriztw: I'll have to think about it. Immidiately I think "addTwo = (2+)" and "addTwo 2" illustrates currying much simpler (I am a beginner). But maybe that one illustrates it batter.
06:57:36 <kriztw> jonascj: it's of course individual preference which you think is simpler/better :P
06:57:51 <Big_G> Is there bimonad or trifunctor? 
06:58:21 <merijn> I don't think Trifunctor exists as class, but conceptually it could. I'm actually not sure about Bimonad that's an interesting question...
06:58:30 <quicksilver> trifunctors are a perfectly sensible notion, but you don't see them often
06:58:44 <quicksilver> I have some vague memory there is more than one way of generalising Monad
06:58:51 <quicksilver> and they turn out different.
06:59:03 <merijn> I know about indexed monads, but that's slightly different, I think?
06:59:03 <Big_G> Would it be better to abstract it to nfunctor? 
06:59:26 <merijn> Big_G: You can't write that abstraction in Haskell, though.
06:59:37 <merijn> Big_G: But nfunctor are a perfectly sensible idea
07:00:08 <Big_G> Is that because of wouldn't type check? 
07:00:31 <Big_G> it
07:00:51 <merijn> Big_G: It's because you would need a type level number to pass the arity of the functor into the class, which is not really feasible in Haskell
07:01:26 <merijn> Anyway, I need to go to a meeting for a bit. Might wanna ask the mailing list about whether or not bimonads can exist, someone is bound to know
07:01:34 <Big_G> Can't you do that with kinds? 
07:01:51 <Big_G> Thanks for the help 
07:02:24 <aweinstock> also, would fmap for NFunctors be called nmap?
07:03:28 <Big_G> Most likely 
07:06:12 <kriztw> aweinstock: that's funny :D
07:07:51 * hackagebot pusher-http-haskell 0.2.1.0 - Haskell client library for the Pusher HTTP API  https://hackage.haskell.org/package/pusher-http-haskell-0.2.1.0 (willsewell)
07:08:56 <aweinstock> kriztw: nmap-the-network-scanner vs nmap-mapping-over-n-underlying-types?
07:09:34 <Big_G> Just nmap over the results from Nmap 
07:10:56 <kriztw> aweinstock: yes
07:11:21 <aweinstock> Big_G: that wouldn't let you do computations combinding multiple fields from the scan (e.g. filtering by OS and a specific port), so you'd want a fold, not an NFunctor map
07:12:07 <aweinstock> kriztw: I'm glad the pun wasn't too subtle :)
07:20:37 <jonascj> I am still thinking about how this works "add = \x -> \y -> x+y". It is two lambda definitions ("signature" '\a ->'), but how can you think about in plain English? add is a lambda function with one input, which is another lambda function of one input?
07:21:04 <quicksilver> jonascj: ... "which returns a lambda function"
07:21:12 <quicksilver> add takes one integer and returns a lambda function
07:21:28 <quicksilver> ... the lambda function returned, takes one integer and returns an integer
07:22:08 <quicksilver> @def let add :: Int -> (Int -> Int); add = \x -> (\y -> x + y)
07:22:08 <lambdabot>  Parse failed: Parse error: EOF
07:22:25 <quicksilver> @def add :: Int -> (Int -> Int); add = \x -> (\y -> x + y)
07:22:26 <lambdabot>  Defined.
07:22:40 <jonascj> > add 2 2
07:22:41 <lambdabot>  4
07:22:44 <quicksilver> jonascj: now, I give add one integer and look at the type:
07:22:48 <quicksilver> @type add 2
07:22:49 <lambdabot> Int -> Int
07:23:01 <quicksilver> "add 2" returns a lambda of type (Int -> Int)
07:23:11 <quicksilver> which I can then apply to another Int
07:23:13 <quicksilver> to get my Int out.
07:23:18 <jonascj> which is more or less the "\y -> x+y" part of the defnition?
07:23:25 <quicksilver> it is precisely that part
07:23:29 <quicksilver> except x is now '2'
07:23:40 <quicksilver> add 2 === \y -> 2 + y
07:24:08 <jonascj> alright, it kind of makes sense. I'll have to sleep on it a few years before it becomes my favorite example :)
07:24:16 <quicksilver> :)
07:24:21 <fkbm> This is silly but how would I get the index when I map
07:24:36 <quicksilver> fkbm: you mean, how far you got through the list?
07:24:48 <fkbm> exactly quicksilver 
07:24:59 <quicksilver> the standard trick is to use zip and [0..]
07:25:06 <fkbm> Aaaaa!
07:25:06 <quicksilver> the lens library has a general function for it though
07:25:08 <fkbm> right
07:25:22 <fkbm> Thanks quicksilver ! 
07:25:45 * fkbm is newbie < _ > 
07:25:55 <quicksilver> > map (\(i,x) -> "Found " ++ show x ++ " at " ++ show i)) $ zip [0..] ['a','b','c']
07:25:57 <lambdabot>  <hint>:1:55: parse error on input ‘)’
07:26:06 <quicksilver> > map (\(i,x) -> "Found " ++ show x ++ " at " ++ show i) $ zip [0..] ['a','b','c']
07:26:07 <lambdabot>  ["Found 'a' at 0","Found 'b' at 1","Found 'c' at 2"]
07:26:20 <quicksilver> fkbm: is that the kind of thing you need?
07:26:34 <fkbm> Yeah! That's exactly it :) Thank you!
07:26:47 <quicksilver> > imap (\i x -> "Found " ++ show x ++ " at " ++ show i) ['a','b','c']
07:26:49 <lambdabot>  ["Found 'a' at 0","Found 'b' at 1","Found 'c' at 2"]
07:26:52 <quicksilver> lensy version.
07:27:11 <frerich> Using 'zipWith' might be useful in this context, too.
07:27:59 * quicksilver nods
07:28:11 <quicksilver> considered that, though 'zip' might be easier to explain, am not sure I was right :)
07:29:14 <frerich> I think what you wrote is what everybody who's getting started would come up with (at least me). I only later noticed that 'map .: zip' is often a candidate for zipWith
07:29:51 <quicksilver> often? not 'always' ?
07:30:03 <frerich> I.e. I think it *is* easier to explain.
07:30:47 <jophish> :q
07:30:48 <frerich> quicksilver: MAybe, I'm careful with saying 'always' around here because there's always one out of the 1500+ clever people here to find a counterexample. :-)
07:31:30 <quicksilver> map f $ zip xs ys === zipWith (curry f) xs ys
07:31:55 <quicksilver> if by some unusual chance you already have an uncurried function to use the map/zip might look nicer
07:32:02 <frerich> Maybe 'map' is nicer if your 'f' is uncurried
07:32:07 * frerich nods
07:32:39 <aweinstock> :t imap
07:32:41 <lambdabot> FunctorWithIndex i f => (i -> a -> b) -> f a -> f b
07:32:46 <exio4> I would still use zipWith
07:32:53 <beastwick987> Can someone succintly describe what a monad is? Is it a place a fxnal language goes to do non functional things (i.e. state changes)?
07:33:23 <exio4> beastwick987: it's a wam fuzxy thing that you can hug
07:33:29 <exio4> warm*
07:33:33 <capisce> /win 15
07:33:47 <ChristianS> beastwick987: no, monads are a very functional concept
07:33:56 <clrnd> I vote for lambdabot to have a "what is monad" response command
07:34:22 <ChristianS> clrnd: but what should it say?
07:34:28 <Hafydd> Will the response consist of, "It's just a monoid in the category of endofunctors"?
07:34:32 <quicksilver> I think the answer to beastwick987's question is "No"
07:34:45 <quicksilver> No, no one can succintly describe what a Monad is.
07:34:49 <clrnd> c'mon, no
07:34:53 <quicksilver> and I've seen 10 years of attempts in this channel.
07:35:01 <clrnd> it should have a coherent and simple answer
07:35:08 <beastwick987_> exio4 :(
07:35:15 <Baughn> quicksilver: It's an applicative functor with an added 'join' method?
07:35:22 <clrnd> quicksilver, exactly, we should let a robot do it
07:35:29 <quicksilver> clrnd: to every question, there is an answer which is simple, elegant, and wrong.
07:35:47 <clrnd> quicksilver, to every statement, there is a response that is a quote
07:35:53 <clrnd> which*
07:35:57 <quicksilver> Baughn: there are plenty of short descriptions; including your one, and Hafydd's one.
07:36:09 <quicksilver> but none of them are succint in the sense which, I believe, beastwick987_ intended.
07:36:27 <quicksilver> that is, none of them simply and clearly conveys the entire meaning to somebody who has no experience of the concept.
07:36:44 <clrnd> let's try, beastwick987_ what is your background?
07:36:55 <clrnd> are you a math teacher or a PHP dev?
07:37:39 <quicksilver> beastwick987_: monads are a clever way to abstract out a bunch of common ways of writing code including: abort-on-error, continuations, keeping log messages, non-determinism. 
07:38:06 <quicksilver> beastwick987_: it's clever because one abstract is the right shape to capture all of those (and more besides) and we have a library of useful functions which work on monads no matter which monad it is.
07:38:31 <quicksilver> nothing inherently to do with state or change.
07:38:32 <clrnd> monads are iterators ©
07:38:46 <hexagoxel> tdammers: adding Hashable instance was possible and probably easiest path, thanks for idea.
07:38:48 <quicksilver> but, state and change are things which, in some respects, you can build monads for.
07:40:32 <lamefun> How to name a structure that's both a list and a set?
07:40:39 <yyyyy> is there a better option than having separate modules for each datatype if you have field name collision? I'd rather not use prefixes, as then I lose the ability to derive Generic for Aeson FromJson instances.
07:40:50 <yyyyy> lamefun: what do you mean?
07:42:01 <lamefun> List with no duplicates + a set.
07:42:17 <hodapp> so, an ordered set?
07:42:38 <Hafydd> yyyyy: there is a GHC extension that allows field names to be non-unique.
07:42:55 <quicksilver> Hafydd: is there? I thought there was going to be, in GHC 8.0, but isn't yet?
07:42:58 <Hafydd> (I don't know if I'd say that's a strictly better option, though.)
07:43:34 <Hafydd> quicksilver: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#disambiguate-fields
07:43:49 <lamefun> hodapp, yes, is there a library for that?
07:43:52 <clrnd> so guys what is a monad
07:44:08 <Hafydd> quicksilver: on closer inspection, maybe that does require separate modules after all.
07:44:15 <yyyyy> Hafydd: is there any downsides to using it?
07:44:31 <Hafydd> yyyyy: yes: that your code is not standard Haskell.
07:44:43 <Hafydd> Also, that it might be harder to read in some cases.
07:45:07 <quicksilver> yyyyy: I think separate modules is the way to go for now. Or lenses and classes.
07:45:16 <hodapp> lamefun: I wouldn't know offhand
07:45:19 <quicksilver> yyyyy: (but I don't know how that interoperates with Aeson deriving)
07:45:30 <quicksilver> because I don't know Aeson deriving.
07:45:38 <quicksilver> lamefun: Data.Set is inherently ordered
07:45:51 <quicksilver> that's why it has a fast (O(n)) toAscList
07:46:53 <yyyyy> Hafydd: ah, we're not planning on compiling anywhere but on GHC, so for me that's not an issue.
07:47:22 <hodapp> is Haskell2010 a standard?
07:47:28 <hodapp> I've been a little confused on that.
07:47:37 <Hafydd> yyyyy: but when using a relatively radical extension like like, there's a risk it will be deprecated, I think.
07:47:41 <yyyyy> I suppose it works only for accessing the field from the module that imports clashing modules, not for defining multiple types with clashing names on the same one?
07:47:48 <Hafydd> *like that
07:47:54 <yyyyy> Hafydd: ahhhh, that's a fair point.
07:48:21 <quicksilver> hodapp: haskell2010 is a standard, yes
07:48:28 <yyyyy> quicksilver: I'll give it a try. Worst thing that can happen is having to tack qualified import prefixes to everything afterwards
07:49:26 <hodapp> quicksilver: in the same right as Haskell98?
07:50:08 <quicksilver> hodapp: hard to answer that.
07:50:22 <quicksilver> hodapp: it was certainly intended to be comparable to Haskell98
07:50:23 <davean> hodapp: what does that even mean?
07:50:29 <davean> hodapp: https://www.haskell.org/onlinereport/haskell2010/
07:50:33 <quicksilver> but Haskell98 has more implementations, I believe
07:50:44 <quicksilver> Haskell2010 has 1 or 0 depending how you count
07:50:45 <hodapp> davean: I guess I'd gotten the idea that Haskell2010 was some sort of recommendation/report, not so much a standard or a specification
07:50:52 <hodapp> quicksilver: UHC is not Haskell2010 compliant?
07:51:29 <quicksilver> UHC only claims to "support almost all Haskell 2010 features"
07:51:36 <hodapp> ahh, okay
07:51:38 <quicksilver> I'm not sure on the specifics.
07:51:41 <hodapp> me neither.
07:52:25 <quicksilver> it lacks some LANGUAGE pragmas and it lacks pattern guards
07:52:30 <quicksilver> and its FFI is not complete
07:52:32 <quicksilver> I found the docs :)
07:52:54 <hodapp> huh, pattern guards are Haskell2010?
07:53:17 * quicksilver nods
07:57:35 <hodapp> but, those LANGUAGE pragmas are extensions that *aren't* Haskell2010 - right?
07:57:38 <hodapp> or am I misunderstanding that
07:57:48 <Hitstare> Hi!
07:57:52 <hodapp> hiya
07:59:02 <beastwick1087> hi
08:05:41 <quicksilver> hodapp: I didn't understand that either.
08:06:20 <hodapp> I thought that every LANGUAGE pragma that I use is a GHC extension (though other implementations might happen to handle them), and outside of Haskell2010.
08:07:41 <merijn> hodapp: Correct
08:07:58 <merijn> hodapp: Except that even without pragma's GHC isn't completely Haskell2010 compliant
08:08:09 <ChristianS> hodapp: some older LANGUAGE pragmas did become part of haskell2010, though
08:08:19 <hodapp> ChristianS: but are they still LANGUAGE pragmas?
08:08:37 <ChristianS> hodapp: yes, you can use them, but if your base lang is haskell2010, you don't have to
08:08:38 <quicksilver> hodapp: for backwards compatibility you are still allowed to declare the pragma explicitly
08:08:41 <merijn> Several notable differences are: GHC does not have Eq and Show as superclass for Num, Applicative is a superclass of Monad and the Foldable/Traversable in Prelude changes
08:08:44 <hodapp> ah, oay
08:08:47 <hodapp> s/oay/okay/
08:08:57 <merijn> quicksilver: UHC isn't haskell2010?
08:09:19 <quicksilver> merijn: "even without pragma's GHC isn't completely Haskell2010 compliant" <--- the problems, you just noted, pragmas do not make them go away :P
08:09:35 <quicksilver> apparently not, re UHC
08:09:49 <jophish> It's a long shot, but has anyone tried to use Nix on Windows for Haskell?
08:10:03 <hodapp> it sounds kind of like UHC is about as Haskell2010-compliant as GHC.
08:10:06 <merijn> quicksilver: UHC is haskell2010, but no FFI and pattern guards, apparently
08:10:07 <hodapp> which is 'mostly'.
08:10:16 <quicksilver> merijn: not "no FFI". Just incomplete FFI.
08:10:20 <Hafydd> Eq and Show as superclasses of Num? How did that get through?
08:10:35 <quicksilver> hodapp: GHC 7.8 or 7.6 was very close to haskell2010 compliant
08:10:38 <jophish> Hafydd: how did the Num class itself get through!
08:10:46 <Hafydd> Heh. Good answer.
08:10:46 <quicksilver> hodapp: recent changes have (deliberately) moved away from it.
08:11:03 <merijn> Hafydd: What did you mean how did that get through?
08:11:14 <merijn> Hafydd: Eq and Show superclasses of Num have been in the report since pre-98
08:11:16 <jophish> merijn: I presume "That seems like a bad idea"
08:11:27 <merijn> That's why GHC doesn't have that
08:11:32 <quicksilver> the things merijn listed, in particular, are deliberate choices GHC has made recently, which distance it from haskell 2010
08:11:44 <merijn> quicksilver: Eq/Num isn't recent
08:11:57 <merijn> GHC hasn't had those since before I started learning haskell
08:12:04 <quicksilver> rly?
08:12:08 <Hafydd> merijn: I'm wondering how the committee didn't remove it when they first considered it. Perhaps for backward-compatibility?
08:12:19 <merijn> Hafydd: No idea
08:12:19 <quicksilver> I thought they wre in the last 3-4 years
08:12:56 <quicksilver> merijn: the change was in 7.4. I consider that recent :)
08:13:18 <quicksilver> Feb 2012, apparently
08:13:34 <merijn> hmmm, maybe I'm misremembering, then
08:13:57 <quicksilver> https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/release-7-4-1.html
08:16:35 <julianleviston> How do I convert strings to text when I have overloaded strings on?
08:16:51 <julianleviston> This is the context: writeText "<html><body>Hello from " ++ "hey!" ++ " GetContented!</body></html>"
08:17:25 <bergmark> julianleviston: use <> for concatenation and it should be automatic
08:17:26 <quicksilver> are you sure your problem isn't just precedence?
08:17:38 <quicksilver> writeText ( .... ) or writeText $ ...
08:17:46 <narendraj9> What does {..} do when used as a pattern?
08:17:47 <julianleviston> quicksilver: yeah I tried with $.
08:17:48 <merijn> I'm betting on bergmark being right
08:17:56 <quicksilver> yeah, what bergmark said also
08:17:57 <merijn> Using ++ to concat non-lists
08:18:03 <quicksilver> ++ forces the type to [a]
08:18:14 <julianleviston> quicksilver: Couldn't match expected type ‘[a0]’ with actual type ‘Text’
08:18:17 <narendraj9> I saw it in the yesod book. instance ToJSON Person where
08:18:19 <narendraj9>     toJSON Person {..} = object
08:18:20 <quicksilver> exactly.
08:18:21 <merijn> ding ding
08:18:21 <narendraj9>         [ "name" .= name
08:18:22 <julianleviston> quicksilver:  oh… what should I be using?
08:18:23 <narendraj9>         , "age"  .= age
08:18:25 <narendraj9>         ]
08:18:31 <quicksilver> julianleviston: <> as bergmark said
08:18:36 <merijn> julianleviston: mappend/<>
08:18:42 <merijn> :t (<>)
08:18:43 <lambdabot> Monoid m => m -> m -> m
08:18:47 <quicksilver> narendraj9: { .. } is record syntax
08:18:50 <hodapp> though, it looks like Frege is aspiring to get to some level of Haskell2010 compliance.
08:19:08 <julianleviston> quicksilver:  sorry I missed that. Ok monoid it is :)
08:19:09 <quicksilver> narendraj9: that looks like an example of NamedFieldPuns as well
08:19:09 <julianleviston> thanks
08:19:15 <Parad0x_> quick question
08:19:22 <Parad0x_> what irc client do you guys use?
08:19:33 <narendraj9> quicksilver: Where can I find everything about record syntax? Because I didn't see this anywhere else.
08:19:57 <merijn> Parad0x_: Which OS?
08:19:59 <julianleviston> hm… now it doesn’t like (<>) (sigh).
08:20:01 <quicksilver> narendraj9: if you google 'haskell record syntax' you will find lots.
08:20:02 <narendraj9> Parad0x_: I use weechat. And I am pretty happy with it.
08:20:05 <Parad0x_> OSX
08:20:08 <julianleviston> importing it with import Data.Monoid (<>)
08:20:08 <quicksilver> I use irssi.
08:20:12 <merijn> Parad0x_: I just use irssi
08:20:21 <Hafydd> telnet.
08:20:24 <merijn> julianleviston: Missing parens
08:20:31 <julianleviston> merijn: huh?
08:20:31 <merijn> julianleviston: "import Data.Monoid ((<>))"
08:20:42 <julianleviston> merijn: oh stupid me. Yeah, I should have known that thank you :)
08:20:44 <merijn> Parens for import list + parens for operator
08:20:55 <Big_G> I use andchat on Android but have been having issues with joining rooms by default 
08:21:04 <julianleviston> merijn: yeah I’ve done that before. thanks :)
08:21:58 <julianleviston> feels like trudging through mud sometimes.
08:22:40 <Big_G> :t +
08:22:42 <lambdabot> parse error on input ‘+’
08:22:53 <julianleviston> Big_G: (+)
08:22:53 <narendraj9> :t (+)
08:22:55 <lambdabot> Num a => a -> a -> a
08:23:05 <clrnd> @kind (->)
08:23:06 <lambdabot> * -> * -> *
08:23:27 <Parad0x_> I'm bored. Can any of you guys give me an idea, something to program, something I can whip up in an hour or so.
08:23:41 <flexfit> Write a kernel in haskell
08:24:10 <Parad0x_> too easy
08:24:15 <Parad0x_> ;)
08:24:36 <clrnd> write a haskell compiler in python
08:24:37 <hodapp> flexfit: What about it?
08:24:57 <hodapp> flexfit: This was the goal of the METASEPI project which tried to do it with Ajhc
08:25:00 <ggole> Write a haskell in kernel
08:25:06 <clrnd> :P
08:25:18 <flexfit> I'm having trouble understanding tail recursion. So tail recursion is when the last call is only the call to itself right? So would this be considered tail recursive? https://bpaste.net/show/94c991df5383
08:25:27 <ideuler> @pl circle p r = join (circlePos p r) (circleDis r)
08:25:27 <lambdabot> circle = (`ap` circleDis) . (join .) . circlePos
08:26:41 <quicksilver> flexfit: interesting one.
08:27:14 <narendraj9> flexfit: I don't think it is tail recursive because you get the result of your tail call and then decide the result of your original call.
08:27:17 <quicksilver> flexfit: it's not tail-recursive in a useful way, no. You could possibly make an argument that it's *technically* tail recursive.
08:27:41 <narendraj9> So, you have extra work to do after the recursive call.
08:27:51 <clrnd> flexfit, it is not because a branch has `x > self-call` where the last function is (>)
08:27:57 <julianleviston> god. it’s so incredibly hard for me to do this.
08:28:07 <julianleviston> and it feels like it should be the simplest thing.
08:28:07 <julianleviston> O(
08:28:25 <narendraj9> So, it's not a tail call. It's not even in the tail position. It just looks like that because of the guards.
08:28:33 <narendraj9> I think.
08:28:35 <flexfit> I see.
08:28:40 <clrnd> yeah
08:28:46 <clrnd> julianleviston, may we help you somehow?
08:28:54 <quicksilver> narendraj9: if we forget we're using haskell - which will only call 'maximum' once, and store the value
08:29:04 <julianleviston> clrnd: that’d be lovely
08:29:07 <flexfit>  I have an exam on tail recursion in haskell, and we're not allowed to use folds :(
08:29:08 <quicksilver> narendraj9: pretend it will evaluate maxTail twice
08:29:16 <julianleviston> clrnd: I’ll formulate a question
08:29:21 <merijn> flexfit: No, it's not tail recursive
08:29:28 <quicksilver> narendraj9: then, it is calling maximum in tail position in the 'otherwise' case.
08:29:43 <merijn> flexfit: Because the guard on line 5 requires you to evaluate "maxium'" first before it can decide what to return
08:29:50 <quicksilver> the main problem is it's a terrible algorithm for maximum :)
08:29:54 <julianleviston> clrnd: tho… it’s just kinda mostly that it all feels so hard. Like just then when I couldn’t even frigging join two strings together in the context coz I hadn’t used Text before. 
08:30:22 <merijn> Also, note that tail recursion isn't very interesting in haskell, because it doesn't get you much
08:30:47 <julianleviston> clrnd: right now I’m trying to work out how to connect to my postgres database in this snap application.
08:30:47 <clrnd> julianleviston, that happens the first couple of times, but I promise you that some day you'll open a ne wlibrary, se it has a Monoid instance and say "oh I can use this right now"
08:30:50 <flexfit> really? my professor spent nearly an entire lecture on tail recursion, and how great it is in Haskell.
08:30:59 <julianleviston> clrnd: I know monoids.
08:31:09 <julianleviston> clrnd: it was just that I didn’t know I had to use monoids for Text.
08:31:21 <quicksilver> julianleviston: personally I don't like OverloadedStrings
08:31:26 <quicksilver> I think you'd have had less trouble without it.
08:31:32 <julianleviston> clrnd: rather “I didn’t know that I had to use the monoid interface of Text”
08:31:33 <flexfit> Looking at the problem, I would probably use a foldl, but we're not allowed to use folds. I'm trying to figure out a way to do it without folds.
08:31:41 <merijn> flexfit: Really?
08:31:42 <julianleviston> quicksilver: nah they’re web strings. I get why it’s like that.
08:31:45 <quicksilver> I like to look at a string constant and know that it's a string constant
08:31:55 <quicksilver> not some overloaded thing which depends on context.
08:31:56 <glguy> julianleviston: You don't have to use the Monoid interface of Text, but you can
08:32:01 <merijn> flexfit: I don't think your professor knows all that much, then >.>
08:32:04 <clrnd> like `5` quicksilver? :P
08:32:13 <julianleviston> glguy: how else was I to join two Text’s?
08:32:21 <clrnd> NonOverloadedNumbers +1
08:32:28 <glguy> Data.Text.append
08:32:30 <clrnd> you could use Text.append
08:32:31 <quicksilver> clrnd: I don't like that much either, but it is a price I'm prepared to pay to not have to have multiple syntaxes for numeric constants.
08:32:35 <julianleviston> clrnd: ah ok
08:32:39 <merijn> flexfit: The main goal of tail recursion in strict languages is to recursve in constant stack space. But haskell (well, GHC haskell..)doesn't have a call stack so you don't need tail recursion for that
08:32:41 <flexfit> merijn: It doesn't help that he was reading from a haskell book as he's teaching the class. He wanted us to use an iter function.
08:33:03 <clrnd> > "lol" `T.append` " omg"
08:33:04 <lambdabot>      Not in scope: ‘T.append’
08:33:04 <lambdabot>      Perhaps you meant ‘BS.append’ (imported from Data.ByteString)
08:33:08 <clrnd> meh
08:33:14 <julianleviston> well mostly it was just that I didn’t know. <shrug>
08:33:25 <clrnd> anyway, julianleviston what's your current issue
08:33:29 <julianleviston> clrnd: ok
08:33:36 <aweinstock> > "abc" <> "def" :: BS.ByteString
08:33:38 <lambdabot>      Couldn't match expected type ‘BSC.ByteString’
08:33:38 <lambdabot>                  with actual type ‘[Char]’
08:33:38 <lambdabot>      In the first argument of ‘(<>)’, namely ‘"abc"’
08:33:56 <aweinstock> > BS.pack "abc" <> BS.pack "def" :: BS.ByteString
08:33:58 <lambdabot>      Couldn't match type ‘Char’ with ‘Word8’
08:33:58 <lambdabot>      Expected type: [Word8]
08:33:58 <lambdabot>        Actual type: [Char]
08:34:03 <narendraj9> @quicksilver No I am still not convinced it is a tail call because before you take the otherwise branch you make the call. Your decision depends upon the result of the recursive call.
08:34:03 <lambdabot> Unknown command, try @list
08:34:16 <julianleviston> clrnd: so… I started very simply. I grabbed Groundhog, and I built a test for it with Sqlite… and tried it out… in a separate project… and I got that working.
08:34:19 <merijn> flexfit: Here is a (decent, I think? I only skimmed it) explanation of recursion vs tail recursion: https://stackoverflow.com/questions/13042353/does-haskell-have-tail-recursive-optimization
08:34:24 <julianleviston> clrnd: so then I switched to Postgres, and got that working
08:34:29 <Like> can someone help me o a function?
08:34:30 <Like> https://gyazo.com/6faffc203635aa70eede8dcd9df051c4
08:34:30 <narendraj9> This is andchat. Sorry. 
08:34:34 <Like> tails one
08:34:37 <flexfit> merijn: Would this be considered tail recursive then? https://bpaste.net/show/b4b15a57266b
08:34:37 <julianleviston> clrnd: so then I built a dead simple snap application… and got that working
08:34:43 <clrnd> okay
08:34:48 <quicksilver> narendraj9: it's quite normal to classify somethign as 'tail recursive' even when one brnach doesn't recurse
08:34:52 <suppi> merijn, what about this? http://www.scs.stanford.edu/14sp-cs240h/slides/basics-slides.html#%2810%29
08:34:53 <quicksilver> narendraj9: otherwise you never end!
08:34:58 <merijn> flexfit: The thing with haskell is that haskell only evaluates expressions to what is called "Weak Head Normal Form" (whnf), which roughly translates to "the outermost result is a constructor"
08:35:00 <julianleviston> clrnd: next I got groundhog postgresql working inside snap as a snaplet.
08:35:20 <clrnd> I've never used groundhog nor snap, so okay :P
08:35:26 <merijn> flexfit: No, that's basically the same as before :)
08:35:32 <julianleviston> clrnd: so I *think* that’s working… at least it compiles… so now I’m trying to connect to it… but I’m not entirely sure how the thing works out what hte connection string should be… 
08:35:42 <merijn> flexfit: Look at the accepted SO answer to see a discussion about it
08:35:42 <clrnd> okay
08:35:44 <narendraj9> quicksilver: Right. :-D 
08:35:48 <clrnd> julianleviston, are you usin postgresql-simple?
08:35:57 <hodapp> Can one have a tail-recursive call where anything occurs with the result of the supposed tail call, except returning it?
08:36:00 <julianleviston> clrnd: but irrespectilve of that, I can’t find out how to even issue a select statement...
08:36:02 <merijn> suppi: Wow...that's terribad
08:36:13 <julianleviston> clrnd: groundhog uses postgres-simple...
08:36:24 <julianleviston> clrnd: https://github.com/lykahb/groundhog
08:36:31 <julianleviston> clrnd: well it can. 
08:36:33 <narendraj9> But the decision usually doesn't depend upon the result of the recursive call.
08:36:36 <julianleviston> clrnd: it can also use sqlite.
08:36:44 <narendraj9> But on the inputs only
08:37:03 <suppi> merijn, that's a pretty well known course from a well known person
08:37:04 <hodapp> Because it seems to me that if you do anything else with that call's result, it's not a tail call.
08:37:16 <flexfit> merijn: What makes it bad?
08:37:16 <clrnd> julianleviston, http://hackage.haskell.org/package/groundhog-0.7.0.3/docs/Database-Groundhog.html has `select`
08:37:20 <merijn> suppi: The problem you have in haskell is not requiring "stack frames" for function calls, but the fact that "foo + bar" merely evaluates to a thunk that will evaluate "foo + bar", so "(foo + bar) + xyzzy" evaluates to a thunk that evaluates the "thunk from foo + bar" and a thunk for xyzzy
08:37:28 <clrnd> it is an ORM sou it will build queries based on the datatypes you ask for
08:37:28 <julianleviston> clrnd: in my “dummy app” I just passed in a connection string, but in the snap app (snaplet) I’m using an instance… so I guess I’ve kind of skipped a step… I know it *should* read from some config file, but Im’ not too sure how to get the config file set up etc.
08:37:33 <julianleviston> clrnd: yeah it does.
08:37:36 <julianleviston> clrnd: yeah I know that.
08:37:46 <merijn> suppi: It's bad because it conflates things in confusing ways for beginners
08:37:48 <julianleviston> clrnd: hang on let me pastie you
08:37:54 <clrnd> sorry, I'm just blind guessing
08:38:04 <julianleviston> clrnd: it’s fine. I appreciate the help.
08:38:07 <julianleviston> clrnd: a lot!
08:38:22 <quicksilver> julianleviston: if you're just beginning haskell (and it sounds like you are?) you've bitten of a pretty big mouthful with quasiquoters and stuff.
08:38:29 <hodapp> is it properly called an ORM when the "O" as in "OOP" is sort of missing?
08:38:45 <suppi> merijn, doesn't 'loop (acc * n') (n' - 1)' build the exact same number of thunks as 'n * factorial (n-1)' ?
08:38:53 <merijn> flexfit, suppi: The problem with the haskell factorial is that you first build an "n" sized thunk of thunks consuming linear amount of HEAP memory and then forcing the outer one forces *everthing*
08:38:53 <quicksilver> julianleviston: "my first haskell program" doesn't normally include an experimental library like haskell with clever compile-time code generation.
08:39:08 <merijn> suppi: Yes, UNLESS you make loop (i.e. the tail recursive one) strict in it's argument
08:39:11 <lpaste> JulianLeviston pasted “can't see the instance of pesistentity” at http://lpaste.net/1149653013019754496
08:39:21 <quicksilver> groundhog
08:39:26 <clrnd> hodapp, an object can exist in a piece of paper or 3-d euclidean space, no need for java
08:39:28 <julianleviston> quicksilver:  it’s not my first haskell program.
08:39:36 <suppi> merijn, that doesn't look like that's what he is doing though
08:39:39 <merijn> suppi: On further inspection, these slides are plain wrong
08:39:52 <merijn> suppi: His tail recursive function is EXACTLY as bad as the original
08:39:56 <quicksilver> julianleviston: nod
08:40:07 <merijn> It's still O(n) space so he achieved nothing
08:40:22 <julianleviston> quicksilver: and I’ve been trying to step myself to it slowly bit by bit… because I realise it’s biting off a lot all at once.
08:40:36 <merijn> suppi, flexfit: If you assume a strict language, like OCaml/SML/F#/etc. this would be correct, but haskell is not strict
08:40:44 <julianleviston> quicksilver:  is snap experimental?
08:40:51 <suppi> merijn, I get what you are saying. let's test
08:40:58 <julianleviston> quicksilver: or were you talikng about groundhog?
08:41:00 <merijn> suppi: I'm guessing this guy taught some form of ML and only recently switched to haskell, because he's just objectively wrong
08:41:00 <ggole> It does seem like the sort of advice you'd give for ML or scheme
08:41:13 <merijn> ggole: Exactly
08:41:22 <quicksilver> julianleviston: groundhog, I was talking about
08:41:25 <suppi> merijn, that's bos' course
08:41:29 <hodapp> clrnd: I don't see what that has to do with ORM, given that all I've read about ORM has said pretty explicitly that it exists because of the impedance mismatch between relational databases, and the objects of OOP.
08:41:32 <julianleviston> quicksilver: ah… is it experimental?
08:41:38 <merijn> Like I said, tail recursion + tail call optimisation is crucial for strict languages, but not for haskell
08:41:50 <clrnd> julianleviston, coming back to your paste, I guess that it can't infer the type of `allCustomers` since you don't use it
08:41:53 <merijn> suppi: Really? I'm gonna go tweet him...
08:41:53 <quicksilver> merijn/ suppi : it is true that fac n = n * fac (n-1) uses n stack frames.
08:41:55 <julianleviston> quicksilver: to me, it feels like *everything* in haskell is experimental.
08:42:04 <merijn> quicksilver: *bzzzt*
08:42:05 <quicksilver> julianleviston: yes, lots of the web/db stuff is.
08:42:10 <merijn> quicksilver: GHC haskell does not have stack frames
08:42:12 <julianleviston> quicksilver:  ah ok :)
08:42:15 <suppi> merijn, http://www.scs.stanford.edu/14sp-cs240h/slides/basics-slides.html#%281%29
08:42:15 <quicksilver> merijn: it uses them when it actually reduces the thunk.
08:42:18 <merijn> *call* stack frames
08:42:26 <quicksilver> merijn: it is probably a misnomer to call them 'frames'
08:42:29 <julianleviston> clrnd: come to think of it, I haven’t setup my entities & data model yet… hmmm
08:42:33 <clrnd> julianleviston, exactly
08:42:36 <quicksilver> merijn: but it uses O(n) stack space when GHC reduces the thunk.
08:42:40 <suppi> merijn, can you post the tweet when you do? I'd like to follow
08:42:47 <clrnd> julianleviston, btw this is *really* *advanced* piece of code
08:42:49 <julianleviston> clrnd: but still, that’s telling me that it can’t see the instance isn’t it?
08:42:52 <clrnd> Lens and Groundhog and Snap?
08:43:01 <julianleviston> clrnd: yeah it’s cool… I realise that .
08:43:19 <julianleviston> clrnd: depending on your definitions of advanced, I guess huh...
08:43:22 <merijn> quicksilver: Sure, but the crucial point is that *tail recursion does not reduce the amount of pattern stack space GHC uses*
08:43:30 <merijn> quicksilver: Strictness annotations reduce those
08:43:32 <clrnd> julianleviston, and yeah, it is saying that, `allCustomers` is `v0`, it can't dispatch select based on nothing
08:43:48 <flexfit> Who is bos?
08:43:48 <merijn> The only reason you use tail calls here is because you can't add the required strictness in the non-tail form
08:43:59 <merijn> flexfit: Bryan O'Sullivan well known haskell programmer
08:44:05 <julianleviston> clrnd: I thought it was saying “hey! I can’t see the underlying instance of grounhog.
08:44:11 <dmj`> flexfit: bos is boss
08:44:19 <merijn> quicksilver: Lacking strictness means the tail version isn't faster, because it's still not forcing the thunks
08:44:39 <clrnd> check select's type (which is amazingly complex btw):
08:44:40 <clrnd> select :: (PersistEntity v, EntityConstr v c, HasSelectOptions opts (PhantomDb m) (RestrictionHolder v c)) => opts -> m [v]
08:44:40 <julianleviston> clrnd: which would make me think I need to lift it or something
08:44:49 <julianleviston> clrnd: yeah that’s fine.
08:44:50 <merijn> suppi: Tweet is only 140 chars, so that's annoyingly small to frame my question in
08:44:55 <quicksilver> merijn: I think it will be faster, with -O2
08:45:06 <quicksilver> merijn: because I believe that example is simple enough for the strictness analyzer to get right
08:45:12 <quicksilver> merijn: I agree it's not a foregone conclusion.
08:45:18 <flexfit> merijn: Let me know when you tweet it as well. I'm interested in this.
08:45:19 <julianleviston> clrnd: the trouble seem to *me* to be that inside that Handler, it can’t see the instance of the PersistEntity typeclass… no?
08:45:23 <suppi> merijn, definitely. twitter is a really bad platform for these sort of things
08:45:32 <julianleviston> clrnd: isn’t that because of the lack of a lift?
08:45:43 <julianleviston> clrnd: I really should learn more MT’s before I get completely stuck in this stuff...
08:45:44 <quicksilver> merijn: but even if it isn't, it is *still* true that it won't generate a deep chain of thunks
08:45:56 <clrnd> julianleviston, oh yeah the `m` fails to match too, but you haven't got that error yet
08:46:03 <julianleviston> clrnd: I just thought I had enough of a handle on MTs that I could give it a go… and mostly it’s been ok.
08:46:03 <quicksilver> oh it will, in the acc parameter
08:46:10 <julianleviston> clrnd: ok :) again, thank you so much for helping me.
08:46:10 <quicksilver> yes the strictness analyzer is critical.
08:46:18 <julianleviston> clrnd: I’ll go put the entity stuff in.
08:47:07 <quicksilver> julianleviston: the problem with stuff like groundhog and snap is that lots of keen haskell programmers are really keen on finding awesome/neat/powerful ways to do things
08:47:17 <quicksilver> so there is a lot of experimenting with ideas
08:47:29 <quicksilver> GADTs, phantom types, rank-N types, quasiquotation, etc.
08:47:41 <quicksilver> and that's awesome.
08:47:57 <julianleviston> quicksilver: sure.
08:47:57 <quicksilver> but it's a different attitude to some other library communities where first and foremost they just want to write a library with features.
08:48:03 <clrnd> it's also hilarious when you have bigger-than-a-tweet types
08:48:10 <julianleviston> clrnd: :D
08:48:17 <julianleviston> clrnd: yeah, lens gets pretty funny.
08:48:33 <julianleviston> lens is kinda indispensible tho.
08:48:45 <clrnd> I don't even read lens errors, I just go to the position and tinker around
08:49:16 <jophish> :( Why does the bits package pull in text, cereal, containers and time?
08:49:29 <jophish> (obviously because of the dependency on bytes)
08:49:36 <jophish> but it shouldn't have to be this way
08:50:11 <julianleviston> god. I’m missing some extension and I’m not sure which one it is… getting mismatched brackets error… some template haskell stuff, but I’ve got that pragma in place
08:50:37 <Taneb> Might you just have mismatched brackets?
08:50:38 <clrnd> TemplateHaskell or QuasiQUoters?
08:50:48 <julianleviston> oh hang on… what uses this? deriving instance Show Product
08:50:53 <julianleviston> flexible instances?
08:51:02 <Taneb> standalone deriving
08:51:05 <julianleviston> standal
08:51:06 <julianleviston> yeah ok
08:51:14 <merijn> suppi, flexfit: https://twitter.com/comerijn/status/654685438800588800 https://twitter.com/comerijn/status/654685711820394496
08:51:45 <flexfit> merijn: Thanks!
08:52:04 <quicksilver> those tweets didn't come from you they came from your evil twin
08:52:11 <clrnd> co-merijn!
08:52:12 <suppi> merijn, did a small test, I wrote 3 factorials, the first two are the same as the slide, the third is the same as the 2nd factorial with ! before each variable in the loop
08:52:29 <merijn> flexfit: Anyway, back to the topic. In haskell EVERY function call (recursive or not) compiles to a simple ASM jump instruction
08:53:00 <suppi> merijn, then I ran each with 100000, 3rd was definitely faster than the other two
08:53:29 <merijn> flexfit: So recursion doesn't cost you stack frames, however non-strictness can lead to a linear memory consumption due to thunks (like here, you're effectively building a linked list of thunks by multiplying with the thunk from the previous recursion
08:53:58 <quicksilver> suppi: did you cmpile with -O2 ?
08:54:04 <merijn> flexfit: To solve this thunk leak you need to add strictness (i.e., tell the compiler that it should immediately evaluate the result instead of postponing it)
08:54:12 <suppi> quicksilver, no, ran in ghci
08:54:20 <suppi> quicksilver, let me try compiling now
08:54:25 <merijn> flexfit: However, in the non tail case you can't add this strictness annotation anywhere
08:55:23 <merijn> flexfit: If you use the tail call version (i.e. loop in those slides) you can add either a BangPattern or "seq" cal to force the accumulation parameter before continuing the recursion. This will avoid building a list of thunks and instead only keep one thunk at a time.
08:55:28 <quicksilver> merijn: [early versions of GHC paid quite a high cost for descending into deep thunk stacks; so early versions of GHC had quite a small stack limit and stack overflows were pretty common; bos will remember this time]
08:56:12 <merijn> flexfit: So the speed gain in haskell is *not* from the tail recursion, it's from adding strictness! The fact that it's difficult (maybe impossible?) to add the right strictness without moving to tail-call form is just coincidental
08:56:42 <merijn> And now my workday is over, so if you are still confused, too bad ;)
08:56:57 <julianleviston> wow that was fun.
08:56:59 <julianleviston> lol
08:57:29 <flexfit> ok. I think I understand it. ish? How does this look? https://bpaste.net/show/fb21a67b41ee
08:57:34 <flexfit> tail recursive wise
08:58:00 <julianleviston> clrnd: ok I put the entities in… and added a whole bunch more pagmas, a couple more packages, and adjusted everything so it compiles again, uncommented that code that was bugging out before and it has the same error… 
08:58:03 <merijn> flexfit: Right, that one is tail recursive
08:58:27 <merijn> flexfit: Incidentally, can you spot the memory leak that's in there after my past explanation? ;)
08:58:28 <clrnd> julianleviston, now you need to add a type anotation, so it knows what instance to use
08:58:32 <clrnd> (if you haven't alread)
08:58:36 <julianleviston> clrnd: ok I’ll do that
08:59:47 <julianleviston> clrnd: I don’t know where to.
08:59:49 <Cale> flexfit: If you like, rather than thinking in terms of the low-level representation using thunks (i.e. pointers to code and tables), thunks are just the data structures used to represent unevaluated expressions at run time. You can imagine expressions taking up memory, and being reduced by evaluation to resulting data which might be smaller or larger than the original expression. Usually things are fairly proportional 
08:59:49 <Cale> to how much space you'd expect an expression to take if you were to write it down, though really expressions at runtime are (rooted, directed) graphs rather than trees, i.e. they may reuse some subexpression simply by referring to it many times, and reduction of that subexpression will effectively result in reduction of all its occurrences.
09:00:26 <julianleviston> clrnd: do you mean to this expression? allCustomers <- select CondEmpty
09:00:39 <clrnd> julianleviston, yeah, http://stackoverflow.com/questions/16549148/how-do-i-declare-the-type-of-a-variable-inside-a-function-in-haskell
09:00:39 <julianleviston> clrnd: or the type definition of the entire expression? indexHandler :: Handler GetContented GetContented ()
09:00:49 <clrnd> (didn't recall how to do it in a do block)
09:00:54 <Cale> But yeah, for many purposes, it's fine to just think of expressions being rewritten like they were text, like you'd do things by hand, when trying to work out how much memory things will take :)
09:01:11 <julianleviston> clrnd: but it’s not a particular type is it? it needs to be an instance of that type.
09:01:17 <julianleviston> clrnd: instance of that typeclass*
09:01:19 <clrnd> more complicated but possible too: x <- stuff :: My Super Type
09:01:34 <clrnd> julianleviston, no, you anotate a specific type
09:01:42 <julianleviston> clrnd: are you *sure*?
09:01:42 <clrnd> you could, but let's not complicate this further
09:01:45 <quicksilver> clrnd: (just remember to include the Monad you're using there)
09:01:56 <julianleviston> clrnd: that doesn’t seem right to me.
09:02:00 <clrnd> yeah `instance Monad My`
09:02:07 <flexfit> merijn: is the memory leak from that fact that I'm building up thunks and not forcing it to only have one at a time?
09:02:21 <Cale> flexfit: So, minimum_iter will work well, but only if the compiler is clever enough to make the evaluation of min m x happen sooner than it otherwise would.
09:02:31 <julianleviston> clrnd: huh?
09:02:32 <merijn> flexfit: Yes, so you'll want to force the "min m x" computation every recursion
09:02:37 <Cale> flexfit: Generally GHC will be smart enough if you turn on -O2
09:02:42 <clrnd> julianleviston, how is gonna ghc know what instance to `select` on?
09:02:49 <clrnd> you have to at least specify that far
09:02:57 <merijn> flexfit: You can do this by writing "m `seq` minimum_iter (min m x) xs" on line 7
09:03:02 <julianleviston> clrnd: because I have this: instance HasGroundhogPostgres (Handler b GetContented) where
09:03:05 <Cale> If you don't want to rely on that, you'll want to force it to evaluate min m x (or at least m) sooner
09:03:19 <merijn> flexfit: I just tried in ghci and for inputs of like 10,000,000 it starts to become obviously faster :)
09:03:27 <merijn> Anyway, time to leave for home
09:03:33 <Cale> You can write  minimum_iter !m (x:xs) = minimum_iter (min m x) xs  using bang patterns, which ought to work
09:03:37 <julianleviston> clrnd: which is why I was asking if it’s not just because it couldn’t “see” the MT behind it?
09:04:00 <Cale> Or more manually using seq, you can write   minimum_iter m (x:xs) = m `seq` minimum_iter (min m x) xs
09:04:05 <clrnd> julianleviston, select is polymorphic on it's return type
09:04:20 <clrnd> the outter monad doesn't care bout what's inside
09:04:20 <julianleviston> clrnd: yeah, but how do I specify what return type it should be?
09:04:26 <julianleviston> clrnd: ok.
09:04:27 <Cale> This will ensure that the compiler is aware that it's okay to evaluate m early.
09:04:30 <clrnd> try that stack overflow link
09:04:36 <Cale> (and it generally will do that for you)
09:04:39 <julianleviston> clrnd: I did. I don’t understand it.
09:04:50 <clrnd> (allCustomers :: MyEntity) <- select CondEmpty
09:05:16 <julianleviston> clrnd: does that require typed scope variables?
09:05:25 <Cale> Otherwise, you'll build up a large expression like:
09:05:26 <clrnd> yeah
09:05:28 <clrnd> it does
09:05:35 <julianleviston> clrnd: hm ok. another expnsion :0
09:05:39 <julianleviston> clrnd: extension.
09:05:45 <clrnd> :P
09:06:04 <clrnd> welcome to haskell2010
09:06:20 <julianleviston> lol thansk :)
09:06:22 <Cale> minimum_iter 10 [1,2,3] -> minimum_iter (min 10 1) [2,3] -> minimum_iter (min (min 10 1) 2) [3] -> minimum_iter (min (min (min 10 1) 2) 3) [] -> min (min (min 10 1) 2) 3
09:06:49 <flexfit> Cale: You can use $! to enforce strictness too rigth?
09:06:50 <Cale> and this expression involving the min applications will generally take about as much space as the list would
09:06:52 <Cale> yes
09:06:58 <Cale> f $! x = x `seq` f x
09:07:23 <Cale> But $! is annoying to use sadly, since $ and $! both have the wrong associativity
09:07:27 <julianleviston> clrnd: ok so the problem now is, that’s not a TYPE that I’m returning, it’s a typeclass.
09:07:34 <Cale> They ought to be left associative, but instead they're right associative.
09:07:34 <julianleviston> clrnd: which is why I was confused before...
09:07:46 <julianleviston> clrnd: Oh… I should include my type that is an instance of that class
09:07:52 <clrnd> yep
09:07:55 * hackagebot reflex-animation 0.1 - Continuous animations support for reflex  https://hackage.haskell.org/package/reflex-animation-0.1 (saulzar)
09:07:57 <clrnd> I assume there is a type somewhere
09:07:58 <julianleviston> clrnd: which I don’t know what is.
09:08:01 <clrnd> don't know groundhog
09:08:05 <Cale> So if you want to write  f $! x $! y to strictly apply two arguments, or  f $! x $ y to strictly apply the first argument, you can't.
09:08:11 <clrnd> julianleviston, didn't you say you had an entity?
09:08:19 <Cale> You have to write (f $! x) $! y instead
09:08:19 <julianleviston> clrnd: oh… ok
09:08:20 <clrnd> julianleviston, can I see your code so far?
09:08:28 <julianleviston> clrnd: hang on sec I’ll try that then show you
09:09:07 <Cale> That's awkward enough that people end up just using something else a lot of the time, but occasionally you'll see a lone $! get used, for sure
09:09:14 <julianleviston> clrnd: yeah that didn’t work
09:09:17 <julianleviston> clrnd: I’ll pastie.
09:09:36 <clrnd> :P
09:09:37 <flexfit> Cale: I see. So by adding 'Seq', i'm forcing the evaluation early. Can you explain bang pattern a litte more? I saw it mentioned in the SO post, but i'm not sure what they do exactly.
09:09:57 <lpaste> JulianLeviston pasted “latest results of smashing brains on keyboard” at http://lpaste.net/143080
09:10:40 <FUZxxl> Gurkenglas: poäng
09:10:47 <Cale> Bang patterns roughly act as if you matched against a constructor of the underlying data type, i.e. forcing enough evaluation to occur to determine the top-level data constructor that was used.
09:10:50 <julianleviston> clrnd: that error will be different than the code… because I *had* (allcCustomers :: [Customer]) <- select CondEmpty but I changed it back before pastie
09:10:53 <clrnd> julianleviston, and NOW we try to lift it
09:10:58 <julianleviston> clrnd: GUHHH
09:11:02 <Cale> Really they're just translated into uses of seq on the corresponding variables
09:11:17 <MarcelineVQ> I have a print command behaving differently in ghci/runghc and in a compiled program, http://lpaste.net/143079 is there something special about ghci's use of print?
09:11:17 <julianleviston> clrnd: that’s exactly what I thought it was all along. :P
09:11:17 <clrnd> but even if we've lift it before, ghc would have needed allCustomers' type
09:11:36 <julianleviston> clrnd: yeah I know.. but to me, this was the “next” error - it was saying “it’s not lifted”, but all good.
09:11:46 <julianleviston> clrnd: using? just lift? where is that applicative? I can’t remember.
09:11:57 <julianleviston> clrnd: containers?
09:12:03 <Cale> flexfit: At some level, essentially all evaluation gets done for the purposes of matching patterns (perhaps with these strictness annotations and seq excepted)
09:12:09 <clrnd> julianleviston, it's in Control.Monad.Trans.Class
09:12:15 <clrnd> but it's not that simple...
09:12:15 <julianleviston> clrnd: ok thanks.
09:12:25 <julianleviston> clrnd: what do you mean?
09:12:25 <flexfit> Cale: I see, so it's basically an abstraction for using seq.
09:12:36 <Cale> flexfit: yeah, it's just syntax sugar
09:12:38 <clrnd> julianleviston, I have to see what all these types are first
09:13:00 <julianleviston> indexHandler :: Handler GetContented GetContented ()
09:13:02 <Cale> flexfit: In the early days of Haskell, seq was actually a type class method
09:13:23 <julianleviston> clrnd: (Handler b GetContented) has an instance of what we want.
09:13:24 <Cale> flexfit: There was a  class Eval a where seq :: a -> b -> b
09:14:02 <Cale> flexfit: and for example, there was an instance Eval [a] where seq [] y = y; seq (x:xs) y = y
09:14:31 <Hafydd> Interesting.
09:14:53 <clrnd> julianleviston, I can see this:
09:14:54 <clrnd> class HasGroundhogPostgres m where getGroundhogPostgresState :: m GroundhogPostgres
09:14:56 <flexfit> That's interesting. Why did they take it out?
09:15:03 <julianleviston> clrnd: yup.
09:15:29 <julianleviston> clrnd: I just added Control.Monad.Trans.Class
09:15:46 <clrnd> julianleviston, maybe you need to call getGroundhogPostgresState? I'm not sure how a snaplet works
09:15:49 <Cale> flexfit: Because it cluttered types of polymorphic functions
09:15:59 <lpaste> suppi pasted “tail recursion?” at http://lpaste.net/143081
09:16:00 <julianleviston> clrnd: how does lift work?
09:16:05 <clrnd> :t lift
09:16:06 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
09:16:14 <julianleviston> clrnd: inside a do block, I mean?
09:16:16 <julianleviston> oh
09:16:21 <suppi> quicksilver, ^
09:16:24 <clrnd> stuff <- lift $ etc
09:16:24 <Cale> flexfit: You'd end up with Eval a constraints for various types a showing up and revealing something about the implementations of functions which wasn't necessarily something you'd want to reveal.
09:16:34 <julianleviston> clrnd: really? oh ok… I’ll give it a shot
09:16:47 <clrnd> yeah try
09:16:58 <julianleviston> clrnd: hm some kind mismatching… 
09:17:08 <julianleviston> clrnd: you sue you’ve got your in-do-block lift syntax right?
09:17:13 <julianleviston> clrnd: coz that’s not how liftIO works
09:17:21 <clrnd> liftIO is just lift for MonadIO
09:17:26 <quicksilver> suppi: yeah annotate all three with Int -> Int
09:17:29 <julianleviston> clrnd: yeah I know
09:17:30 <quicksilver> suppi: and see if that changes your results.
09:17:38 <quicksilver> clrnd: no it isn't.
09:17:47 <Cale> flexfit: Oh, and then there's the real difference between that and the current seq, which is that the current seq can be used at function types.
09:17:53 <clrnd> quicksilver, I know, but let's leave it like that
09:17:58 <quicksilver> clrnd: lift lifts exactly one level. liftIO lifts 'all the way from the IO at teh bottom'
09:18:13 <Cale> flexfit: as well as other abstract data types like IO (), which it would otherwise be impossible to pattern match on
09:18:29 <clrnd> julianleviston, can I see the error? I'm not sure about lift anyway
09:18:31 <julianleviston> clrnd: changed it to this… and got a “better error” let allCustomers = lift $ select CondEmpty
09:18:41 <clrnd> wat lol
09:18:42 <quicksilver> "let"
09:18:43 <Cale> flexfit: This is both a good and a bad thing. It's good because it's there when you need it for performance reasons
09:18:48 <quicksilver> it's a monad action isn't it?
09:18:56 <suppi> quicksilver, definitely changed the result. now I'm getting 0 as the result
09:18:59 <clrnd> well, if he wants the customers it is
09:18:59 <Cale> flexfit: But it's bad because it very much complicates the equational reasoning of Haskell
09:19:02 <julianleviston> quicksilver:  yup.
09:19:11 <suppi> quicksilver, as I said, I don't think factorial 100000 can be an Int :)
09:19:13 <julianleviston> clrnd: the error is now ambiguous type (I have products and customers)
09:19:24 <Cale> flexfit: undefined :: Int -> Int  and  const undefined :: Int -> Int   are no longer the same function
09:19:32 <Cale> this is because:
09:19:35 <flexfit> Cale: gotcha. I can see why they took it out.
09:19:36 <clrnd> julianleviston, we could work out the types like this, try adding a type anotation
09:19:44 <clrnd> > let a :: Int; a = 5a
09:19:45 <lambdabot>  <no location info>: not an expression: ‘let a :: Int; a = 5a’
09:19:46 <Cale> > (undefined :: Int -> Int) `seq` ()
09:19:47 <lambdabot>  *Exception: Prelude.undefined
09:19:49 <clrnd> > let a :: Int; a = 5
09:19:50 <lambdabot>  <no location info>: not an expression: ‘let a :: Int; a = 5’
09:19:50 <Cale> > (const undefined :: Int -> Int) `seq` ()
09:19:52 <lambdabot>  ()
09:19:55 <Cale> uhh
09:19:58 <Cale> heh
09:20:00 <Cale> > (undefined :: Int -> Int) `seq` ()
09:20:02 <lambdabot>  *Exception: Prelude.undefined
09:20:04 <Cale> > (const undefined :: Int -> Int) `seq` ()
09:20:06 <lambdabot>  ()
09:20:07 <clrnd> nvm
09:20:30 <quicksilver> suppi: oh haha. OK annotate it to Integer then.
09:20:48 <camm1> Hello everyone. Do you know how can I restrict the uploading files (according to the extension) with the Snap Framework Utility?
09:20:50 <suppi> quicksilver, did that. fac2 is still at around 9s
09:20:59 <quicksilver> suppi: shame. ah well. interesting :)
09:21:05 <suppi> quicksilver, definitely!
09:21:09 <julianleviston> clrnd: ah I don’t know
09:21:13 <Cale> flexfit: So, that tends to break equations that would otherwise hold, in a way which usually is unimportant if you're programming, but does actually matter if you're writing a compiler.
09:21:21 <suppi> quicksilver, I was actually impressed that fac1 was really close to fac3
09:21:41 <lpaste> JulianLeviston pasted “Bash bash Bashing :)” at http://lpaste.net/143082
09:21:47 <julianleviston> clrnd: that’s the current error.
09:22:03 <flexfit> Cale: I can see why that would be a problem. I gotta head to class. Thanks for the explanations!
09:22:05 <clrnd> ugh
09:22:07 <julianleviston> clrnd: I tried :: [Customer] but it couldn’t work out the monad from that...
09:22:12 <Cale> flexfit: no problem, cheers!
09:22:20 <julianleviston> clrnd: funtimes ugliness! :)
09:22:29 <suppi> quicksilver, I'm definitely not going to write code like fac2 or fac3 in the future unless told by a profiler or something
09:22:30 <clrnd> julianleviston, those errors are a result of using let anyway
09:22:36 <julianleviston> clrnd: oh ok...
09:22:43 <julianleviston> clrnd: so I should *not* do that thn? :)
09:22:46 <clrnd> the first one complains it doesn't know where to lift to
09:23:04 <julianleviston> clrnd: gives me kind errors otherwise.
09:23:15 <clrnd> julianleviston, we could try to find the type in the let, to make things easier maybe
09:23:31 <clrnd> julianleviston, nevermind, what kind error?
09:23:56 <lpaste> JulianLeviston pasted “You're very... kind” at http://lpaste.net/143083
09:24:26 <clrnd> groundhog-postgres-snap
09:24:35 <clrnd> the mantainer of groundhog-postgres-snap is not really a documentation guy
09:24:44 <julianleviston> clrnd: you *could* say that ;-)
09:25:18 <clrnd> oh pfff silly me, you can't lift there
09:25:30 <joco42> i am getting started with emacs for haskell , how can i check that i setup up ghc-mod correctly? what i really want to use is the explicit import feature 
09:25:37 <clrnd> we are looking for a specific function that can be in groundhog-snap or snap that lets us do this
09:26:04 <clrnd> groundhog-postgres-snap has runGH, maybe try it?
09:26:06 <clrnd> instead of lift
09:26:11 <clrnd> this is getting way out of hand
09:26:24 <julianleviston> clrnd: the point of this line: instance HasGroundhogPostgres (Handler b GetContented) where
09:26:44 <julianleviston> clrnd: is that it’s supposed to wack an instance of it around all snaplet/handlers, I thought.
09:27:20 <julianleviston> clrnd: let me just go check the heist example on the snap site, because I think that uses that pattern (hasHeist)
09:27:31 <clrnd> julianleviston, link it please
09:27:36 * clrnd has to go in 5 minutes
09:29:29 <julianleviston> clrnd: oh I’m an idiot.
09:29:47 <julianleviston> clrnd: I think you can just use getGroundhogPostgresState as the lens into the app state … guh
09:29:57 <clrnd> >.> okay
09:30:09 <julianleviston> clrnd: no idea how right now, but that’s how hasHeist works… so I’ll dig in there
09:30:11 <clrnd> yeah that's was obious ?????
09:30:24 <julianleviston> clrnd: hey thanks so much for all the help! you’re a legend
09:30:32 <quicksilver> things called HasFoo are likely to be lenses, yes
09:30:41 <julianleviston> clrnd: I guess if I just keep bashing my brain on it, I’ll get there in the end :)
09:30:48 <clrnd> quicksilver, you could have said so .... :|
09:30:50 <julianleviston> quicksilver: :) thanks
09:30:51 <quicksilver> (to be more clear, classes called HasFoo are likely to have lenses as their methods)
09:30:52 <julianleviston> hehe :)
09:31:02 <quicksilver> clrnd: I didn't realise that was what was going on :)
09:31:04 <clrnd> gotta go, you can do it!
09:31:10 <julianleviston> clrnd: thanks! <3
09:35:27 <Darwin226> Say I want to make Data.Map a monad. I decide that I'll restrict the key with Ord and Monoid. The way bind would work is that I would construct a new map by mappending the keys (when I need to collapse a Map k (Map k b)).
09:36:02 <Darwin226> The problem is what to do when I get two of the same key from the mappends. I can' just pick one of the possible values and call it cannon
09:36:34 <Darwin226> What I'm wondering is how legit would it be to say that this monad implementation should only be used if the values with the same "path" always lead to the same value ultimately
09:36:50 <Darwin226> So the choice of which one to pick doesn't matter because they're all the same
09:36:59 <julianleviston> ZOMG it works :) woo!
09:37:04 <zomg> awesome
09:37:18 <julianleviston> zomg:  haha of course there’s someone called zomg :)
09:37:19 <Darwin226> if this is unclear (because it really is) please tell me so I can write the actual implementation you can examine.
09:37:20 <julianleviston> hehe.
09:37:31 <zomg> yep =)
09:38:21 <julianleviston> zomg:  you get *all* the happy people exclaiming to you, don’t you? :) hehe.
09:38:44 <zomg> occasionally yeah
09:39:34 <julianleviston> If I have a String, how can I “convert” it to Text ?
09:39:49 <liste> :t T.pack
09:39:50 <lambdabot>     Not in scope: ‘T.pack’
09:39:50 <lambdabot>     Perhaps you meant ‘BS.pack’ (imported from Data.ByteString)
09:39:57 <liste> julianleviston pack
09:40:03 <julianleviston> liste: sweet. thank you.
09:40:29 <liste> also fromString
09:40:32 <liste> :t fromString
09:40:34 <lambdabot> IsString a => String -> a
09:41:54 <julianleviston> liste: ah that’s like the fromIntegral ones for Num ?
09:43:00 <bergmark> `fromString` is used when you have a string literal and OverloadedStrings
09:49:37 <Nux__> does GHC use fusions for it's list functions?
09:49:42 <Nux__> *fusion
09:49:57 <Nux__> (in it's latest release)
09:50:48 <roelof> Anyone who can help me with this wierd hlint error : http://lpaste.net/143086
09:50:55 <dolio> Nux__: Yes.
09:51:48 <Nux__> dolio, and am I to understand that this means that I don't have to be so careful about having intermediate lists when building a list using said functions?
09:52:17 <bergmark> roelof: you forgot :: after minThree
09:52:38 <inad922> Hi
09:52:42 <dolio> Nux__: Yes, that's the idea, at least.
09:52:45 <Darwin226> Ok, so I wrote the implementation. https://gist.github.com/2701f2e2231c36a068ae What's wrong with it (that makes it break laws) is the fromList in the bind implementation which will lose values with the same key
09:53:09 <inad922> Is there any way I can list the code of built-in function(aka functions in Prelude) in ghci?
09:53:10 <Darwin226> am I alright with this monad instance if I say that all the values with the same key are REQUIRED to be the same?
09:53:14 * hackagebot yesod-content-pdf 0.2.0.0 - PDF Content Type for Yesod  https://hackage.haskell.org/package/yesod-content-pdf-0.2.0.0 (alexkyllo)
09:53:20 <inad922> I mean I want to see the code of foldr for example
09:53:41 <bergmark> inad922: in ghci... I don't think so. but you can read it on hackage
09:53:51 <davean> inad922: its easily available on hackage via the "source" links
09:54:07 <inad922> bergmark, davean: Ok, I give that a try. Thanks!
09:54:16 <roelof> bergmark:  thanks , I was confused and looked at the wrong place 
09:54:49 <bitemyapp> julianleviston: maybe I should add a link to my website on the book site?
09:55:01 <bitemyapp> julianleviston: a little surprised anyone would think my projects list amounted to anything :P
09:55:09 <julianleviston> bitemyapp: huh?
09:55:11 <bergmark> oh right base even has linked sources on hackage :-)
09:55:22 <julianleviston> bitemyapp: that was out of the blue :)
09:55:41 <julianleviston> bitemyapp: are you talking about the person who was asking if you had cred before?
09:55:57 <inad922> If I can have another question. Is there a speed comparison between data structures like haskell lists and STL vectors preformance wise somewhere? Or this is a silly question for some reason?
09:56:10 <julianleviston> bitemyapp: oh by the way, did you get my email with textfile?
09:56:18 <Sonolin> can I do something like this:
09:56:20 <Sonolin> putStrLn <$> (: "asdf") <$> getChar
09:56:27 <julianleviston> inad922: it’s not a silly question, IMO.
09:56:28 <dolio> STL vectors are very different data structures than lists.
09:56:35 <julianleviston> inad922: depends on the sizes of things, tho...
09:57:08 <inad922> julianleviston, What do you mean by that it depends of sizes of things
09:57:22 <inad922> dolio, I'm comparing a linked list to an array? :)
09:57:36 <dolio> That's one difference.
09:57:38 <bitemyapp> julianleviston: I check my lastlogs when I see someone mentioned me.
09:57:45 <julianleviston> bitemyapp: ah :)
09:57:46 <bitemyapp> julianleviston: yes that
09:58:12 <bitemyapp> julianleviston: yep, got it, thank you.
09:58:20 <bitemyapp> julianleviston: sorry for not replying, we're in the middle of release prep right now.
09:58:27 <julianleviston> bitemyapp: um… well, I guess the person in question wondered if you were “any good” lol. Ironically they knew you as bitemyapp, but not Chris. ;-)
09:58:33 <bitemyapp> ~900 pages i the next release.
09:58:34 <julianleviston> bitemyapp: no worries at all. Just checking.
09:58:41 <julianleviston> bitemyapp: :) can’t wait.
09:59:02 <Sonolin> ah, this maybe?
09:59:02 <Sonolin> putStrLn <- (: "asdf") <$> getChar
09:59:11 <Sonolin> doesn't seem to quite work in ghci though
09:59:53 <Darwin226> Hey, if someone replied to me, could you repeat it? My connection broke
10:00:04 <dolio> That is defining putStrLn as the result of (: "asdf") <$> getChar
10:00:27 <julianleviston> Sonolin:  what do you want to do?
10:00:39 <quicksilver> Darwin226: I would be inclined to force the values to be Monoids
10:00:40 <bitemyapp> Darwin226: I checked and didn't see any replies that mentioned your name, but that's no guarantee.
10:00:49 <julianleviston> Sonolin: print out the input with “asdf” on the end?
10:00:51 <bitemyapp> Darwin226: use http://ircbrowse.net/ to check more thoroughly.
10:00:54 <Sonolin> just trying to learn applicatives better
10:00:54 <quicksilver> Darwin226: and then combine any values which end up occuring at repeated keys.
10:00:55 <Sonolin> yes
10:01:05 <Darwin226> bitemyapp: Thanks.
10:01:21 <Darwin226> quicksilver: I can't do that for the same reason I can't have Set as a monad
10:01:27 <quicksilver> true
10:01:38 <quicksilver> well
10:01:42 <quicksilver> is it the same reason?
10:01:48 <Darwin226> quicksilver: Also, for the purposes that I would find this implementation useful, it might not be that great to restrict only to monoids
10:01:49 <julianleviston> :t getChar
10:01:51 <lambdabot> IO Char
10:01:58 <julianleviston> :t (<$>)
10:01:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:03:02 <Darwin226> quicksilver: With this monad you can write nondeterministic computations and be able to see the path to each of the results
10:03:35 <quicksilver> Darwin226: maybe you don't want to allow the keys to be any arbitrary monoid
10:03:50 <quicksilver> Darwin226: maybe you want them to be a specifically free monoid (like [] or Seq)
10:03:58 <quicksilver> Darwin226: then you can't get the same value twice.
10:04:13 <quicksilver> that fits my intuition of what a 'path' should be
10:04:20 <julianleviston> :t (: "asdf") <$>  getChar
10:04:22 <lambdabot> IO [Char]
10:04:27 <julianleviston> :t putStrLn
10:04:29 <lambdabot> String -> IO ()
10:04:36 <Darwin226> quicksilver: Well, it's certainly the best solution so far. Not really happy with it
10:04:58 <julianleviston> Sonolin: you following this? :)
10:05:03 <quicksilver> Darwin226: in fact you might as well make it specifically []
10:05:11 <Sonolin> I got it 
10:05:13 <Sonolin> its (: "asdf") <$> getChar >>= putStr
10:05:29 <julianleviston> Sonolin: sure… 
10:05:37 <julianleviston> Sonolin: but >>= isn’t really part of applicative, is it? :)
10:05:44 <quicksilver> newtype PathNoDet p a = PathNoDet (Map [p] a)
10:05:52 <Darwin226> quicksilver: That's actually pretty decent now that I think about it
10:05:52 <dolio> Neither is (<$>), technically.
10:05:56 <julianleviston> Sonolin: so long as you understand what’s going on
10:05:59 <Sonolin> julianleviston no but can you write that without >>= ?
10:06:01 <julianleviston> dolio:  true :)
10:06:05 <Darwin226> quicksilver: Can you tell me if I have thequadratic append problem here, then?
10:06:12 <Sonolin> I thought that would be necessary (without binding to a var of course)
10:06:12 <Darwin226> Do I need to use a difflist instead?
10:06:25 <quicksilver> Darwin226: I don't think so, because you only ever append path items one at a time.
10:06:48 <Darwin226> quicksilver: Yeah, but if they associate the wrong way...
10:07:09 <quicksilver> well you write the instance :)
10:07:10 <julianleviston> :t join
10:07:11 <lambdabot> Monad m => m (m a) -> m a
10:07:17 <quicksilver> build the list backwards
10:07:21 <quicksilver> so path items get pushed on the 'front'
10:07:22 <julianleviston> :t join $ fmap putStrLn $ (: "asdf") <$>  getChar
10:07:24 <lambdabot> IO ()
10:07:29 <Darwin226> quicksilver: Smart... Smart guy
10:07:41 <Darwin226> quicksilver: Thanks for all the help man!
10:07:43 <Sonolin> ooh interesting
10:07:44 <julianleviston> Sonolin: same thing tho.
10:07:47 <quicksilver> yw
10:08:20 <quicksilver> getChar >>= putStrLn . (:"asdf")
10:08:24 <quicksilver> is another way
10:08:42 <julianleviston> quicksilver: s/he wanted to not use bind.
10:09:11 <quicksilver> if you execute two actions, you are using bind
10:09:17 <quicksilver> hiding it in join doesn't change that :)
10:09:31 <julianleviston> quicksilver: sorry… “didn’t want to use the >>= operator”. ;-)
10:09:34 <julianleviston> quicksilver:  but yes.
10:09:42 <Sonolin> I was missing join! thanks julianleviston :)
10:10:18 <quicksilver> :t join $ putStrLn . (:"asdf") <$> getChar
10:10:19 <lambdabot> IO ()
10:10:26 <quicksilver> you have an un-necessary fmap there, julianleviston 
10:10:29 <quicksilver> had.
10:10:57 <quicksilver> that is, fmap f $ g <$> h is just f . g <$> h
10:11:19 <quicksilver> because fmap f (fmap g h) is fmap (f.g) h
10:11:45 <julianleviston> quicksilver:  thanks.
10:11:53 <julianleviston> quicksilver:  I am ever the student.
10:12:02 <quicksilver> that never stops being true.
10:12:06 <julianleviston> quicksilver:  one of the functor rules.
10:12:12 <julianleviston> quicksilver: laws* right?
10:12:21 <quicksilver> yes.
10:12:55 <quicksilver> Three laws : (1) fmap id = id; (2) fmap f . fmap g = fmap (f.g) (3) we are all students always
10:14:44 <dolio> Also, join (fmap f x) = x >>= f
10:15:19 * quicksilver nods
10:15:31 <quicksilver> which is why 'there is a bind hiding in join'
10:16:06 <becks1> ciao
10:16:10 <becks1> !list
10:16:10 <monochrom> becks1: http://okmij.org/ftp
10:16:28 <magneticduck> what's the state of stack + ghc-mod integration?
10:16:56 <quicksilver> although of course it's equally true that 'there is a join hiding in bind'
10:17:04 <magneticduck> I really need ghc-mod q_q
10:17:18 <quicksilver> before I learnt haskell I felt that join was the more fundamental operation.
10:17:19 <clrnd> magneticduck, isn't ghc-mod something you install?
10:17:31 <becks1> http://okmij.org/ftp/Computation/
10:17:36 <julianleviston> quicksilver:  there’s a movie title there somewhere… hidden join… crouching bind?
10:17:43 <quicksilver> :)
10:17:51 <clrnd> quicksilver, where did you use join before haskell?
10:18:07 <julianleviston> clrnd: hey I got it working! :)
10:18:13 <clrnd> julianleviston, I read! congrats
10:18:15 * hackagebot monoid-absorbing 0.1.0.0 - A library for (left, right) zero monoids and backtracking with cut  https://hackage.haskell.org/package/monoid-absorbing-0.1.0.0 (maciejpirog)
10:18:22 <MarcelineVQ> magneticduck: I​ just install ghc-mod globally "cabal install ghc-mod" to keep things simple
10:18:36 <julianleviston> clrnd: it was this: (allCustomers :: [Customer]) <- gh $ select CondEmpty
10:18:43 <julianleviston> clrnd: like you said - using the gh thing.
10:18:50 <clrnd> so `gh` was the magic bit 
10:19:21 <ReinH> quicksilver: it still is
10:19:35 <julianleviston> clrnd: part of the magic bit, yeah. and the type signature…
10:19:52 <ReinH> magneticduck: you can stack install ghc-mod, but I believe you need to use a nightly resolver
10:19:56 <becks1> https://hackage.haskell.org/package/monoid-absorbing-0.1.0.0
10:19:59 <ReinH> (you can stack install things globally as well)
10:20:15 <clrnd> julianleviston, well you wanted to mess up with not one but TWO complex projects at once :P
10:20:32 <quicksilver> clrnd: I learnt category theory as an undergrad
10:20:35 <julianleviston> clrnd: :) yeah… sadly I don’t know how to learn this stuff any “easier” :0
10:20:53 <julianleviston> clrnd: I’m all ears if you have suggestions.
10:20:55 <magneticduck> anybody here happily using sublime text + ghc-mod?
10:20:57 <magneticduck> with stack?
10:21:01 <quicksilver> Gurkenglas: hey, I found a use for modifyT
10:21:15 <quicksilver> Gurkenglas: or, that is, I found myself writing some code in which I wished I had it.
10:21:33 <clrnd> julianleviston, well I learnt doing CLI apps :P
10:21:44 <magneticduck> quick show of hands, what IDEs / editors are you all using here?
10:21:50 <quicksilver> o/ emacs
10:21:56 <clrnd> web things are really complex, it just isn't obvious
10:22:05 <julianleviston> clrnd: hehe ah yes.
10:22:14 <julianleviston> clrnd: no, I realise they’re very complex.
10:22:54 <Sonolin> vim :)
10:23:04 <quicksilver> julianleviston: certainly you tried to do two things at once. I would have tried (1) accessing DB directly (trying it out in GHCi) then (2) making hello world webapp before (3) combining
10:23:08 <julianleviston> clrnd: I’ve done numerous little apps, but not used MFAM on much… let alone MTs
10:23:20 <julianleviston> quicksilver: that’s precisely what I *did* do.
10:23:27 <magneticduck> I've been using atom, but on large projects it's just really slow
10:23:32 <julianleviston> quicksilver:  in fact, I did it in smaller steps than that.
10:23:44 <quicksilver> ah ok :)
10:23:46 <julianleviston> quicksilver:  I made several smaller apps before trying that joined one. :)
10:23:56 <julianleviston> quicksilver: otherwise I wouldn’t have had a hope :)
10:24:00 <clrnd> even if she/he did, the complexity arises from adding them
10:24:39 <ReinH> magneticduck: you should use emacs :p
10:24:39 <clrnd> julianleviston, btw I find yesod a better web framework than snap, but I can only talk from what I've read
10:25:05 <magneticduck> ReinH: or spacemacs
10:25:12 <magneticduck> I'm a vimmer
10:25:16 <julianleviston> but you’re both right… I was trying to do a few things… implement someone else’s badly documented snaplet… 
10:25:23 <ReinH> magneticduck: I use spacemacs.
10:25:28 <ReinH> It's great.
10:25:41 <julianleviston> clrnd: I don’t like the design choices of yesod much.
10:25:44 <ReinH> stack and ghc-mod work
10:25:45 <magneticduck> cool, I just need to get it set up for haskell
10:25:52 <julianleviston> clrnd: and the static routing is a deal breaker for me
10:26:08 <ReinH> magneticduck: just set some variables on the haskell layer and you're good to go
10:26:15 <julianleviston> clrnd: I need to have “non-typesafe-routing”… ie fully parametric routing.
10:26:24 <clrnd> oh okay
10:26:30 <clrnd> I don't like that is uses TH so yeah
10:26:58 <julianleviston> clrnd: plus the templating system isn’t powerful enough for me (need dynamic templating, or not using it at all), I dislike the reliance on TH
10:27:24 <julianleviston> clrnd: as well as that, Persisent isn’t capable of doing relations that I could see, and generally feels very boilerplatey.
10:27:27 <clrnd> julianleviston, well the template engine is a matter of choice (in any decent framework)
10:27:35 <julianleviston> clrnd: yeah… 
10:27:57 <julianleviston> clrnd: I’m probably not going to use a templating system much anyway… but if I do, Heist feels amazingly good to me.
10:28:11 <clrnd> perfect
10:28:24 <julianleviston> clrnd: if not a *little* complex.
10:29:18 <julianleviston> ok I gotta go to sleep… :) I’m wrecked.
10:29:23 <julianleviston> clrnd: thanks again… :)
10:29:26 <clrnd> cya
10:29:32 <clrnd> glad we could help
10:29:40 <Zemyla> clrnd: So I'm not the only one that doesn't like Template Haskell?
10:29:49 <clrnd> Zemyla, a lot of people don't
10:29:51 <Zemyla> I guess it's just not what I'm used to.
10:30:33 <quicksilver> it's ugly and fiddly. On the other hand if you want metaprogramming features, it's powerful
10:30:46 <quicksilver> and generating data types from a DB schema is a metaprogramming task
10:31:12 <quicksilver> I think that's a good use case for it. I'm less sold on it as a 'templating' language.
10:31:30 <dolio> It's less ugly for some things than it used to be, at least. But still pretty ugly in a lot of cases.
10:32:39 <quicksilver> generating lenses seems a good use case for it
10:32:53 <quicksilver> especially since as the user I'm just typing 'makeLenses ''Foo' which is pretty inoffensive
10:32:58 <dolio> Yeah.
10:33:23 <dolio> For things where you just want to generate code at the top level, it's not bad.
10:38:10 <magneticduck> fk it, I'm going to learn spacemacs
10:38:14 <magneticduck> enough postponing lisp
10:39:02 <solfu> love lisp, good luck!
10:47:24 <roelof> bitemyapp:  what do you think of my solutions so far : https://github.com/rwobben/craft
10:48:51 <bitemyapp> roelof: https://github.com/rwobben/craft/blob/master/chapter_3/exercise1/src/Lib.hs#L6 I'm at work so can't really spend a sustained amount of time, but I don't think this is correct.
10:49:25 <bitemyapp> wait n/m
10:49:27 <bitemyapp> it's right
10:49:35 <bitemyapp> I'm sick right now and can't really think straight, sorry.
10:49:44 <roelof> I know it right. All the tests are passing 
10:49:51 <roelof> bitemyapp:  NP 
10:51:05 <roelof> maybe someone else who can give feedback 
10:51:25 <roelof> bitemyapp:  wish that you are well soon 
10:51:35 <bitemyapp> roelof: I've been pretty preoccupied with the book, sorry. Not enough sleep + sick makes me counter-productive as a helper :\
10:51:46 <bitemyapp> roelof: thank you. I hope you find somebody to look over your stuff.
10:51:48 <roelof> as I said no problem 
10:52:03 <clrnd> roelof, any specific solution you have doubts about?
10:52:35 <roelof> nope, I know all code passes the QuickCheck and the hlint checks 
10:59:02 <ncb> anyone else have problems accessing ghc.haskell.org/trac/ ?
11:02:45 <roelof> clrnd:  but im most in doubt about exercise 10 and expecially the fourDifferent with the help of threeDifferent
11:02:59 <clrnd> let's see
11:04:10 <ReinH> bitemyapp: Your XOR function is correct, but it's also cheating :p
11:04:19 <hexagoxel> ncb: looks ok over here. maybe try a different browser, that worked for me last time the tracker seemed down..
11:04:28 <johnw> ncb: it works here
11:05:15 <ncb> hexagoxel: ok thanks. hrrm yes, works in another browser
11:05:19 <ncb> johnw: thanks
11:05:40 <roelof> another question : Is there something which can format my code to the standard 
11:06:01 <hexagoxel> ncb: and here i wondered if that advice was too far-fetched .. :D
11:06:19 <fkbm> Is it wrong to think about backtracking for a solution involving a list?
11:06:26 <ReinH> fkbm: nope
11:07:27 <clrnd> roelof, it looks correct
11:07:31 <clrnd> fourDifferentB a b c d = threeDifferent b c d && threeDifferent a b c && threeDifferent a c d
11:07:44 <roelof> :) 
11:07:45 <fkbm> Thought this was the way to go... Just trying to wrap my head around a way to do it.
11:07:57 <ReinH> fkbm: what's the problem?
11:08:01 <clrnd> roelof, maybe the last check is redundant?
11:08:26 <ReinH> clrnd: Last check picks up a and d
11:08:30 <roelof> clrnd:  we still talking about exercise 10 ?? 
11:09:11 <clrnd> yeah right
11:09:34 <roelof> I did add the a c d because otherwise QuickCheck found some causes which will not work 
11:10:00 <clrnd> nevermind
11:10:20 <indiagreen> is there some way to make GHC annotate a source file? in particular, my use case is as follows: I have a fully qualified function name and I want to know where in a package is this function used
11:10:30 <ReinH> allDifferent [] = True; allDifferent (x:xs) = not (elem x xs) && allDifferent xs
11:10:38 <ReinH> won't perform later checks if an earlier check fails
11:12:51 <ReinH> ofc neither will the other versions
11:13:17 * hackagebot texmath 0.8.4 - Conversion between formats used to represent mathematics.  https://hackage.haskell.org/package/texmath-0.8.4 (JohnMacFarlane)
11:14:14 <favetelinguis> just trying out irssi with highlight window, coule someone plz send me a message highlighting my nic..?
11:14:29 <ncb> favetelinguis: ping
11:14:50 <roelof> Bummer, I thought I could test my average function with the use of import Math.Statistics but it cannot find Math.Statistics :( 
11:14:59 <favetelinguis> ncb: thanks it works
11:15:35 <roelof> clrnd:  thanks for the feedback 
11:16:15 <Phyx-> @type liftM3
11:16:17 <lambdabot> Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
11:17:33 <fkbm> ReinH: Maybe I don't have a problem. I'm thinking about having a _stack_ and an output _list_ the stack would be used to backtrack and the list to accumulate solutions
11:18:15 <fkbm> Just thought I'd ask if that was the right way to start. :)
11:18:24 <roelof> Anyone who has a idea how I can test a function which looks like this (a+b+c)/3.0  ???
11:19:40 <roelof> Haskell do not seem to have a average function :( 
11:19:58 <fkbm> fold ?
11:20:26 <monochrom> it is not in the standard library. you are to write one yourself.
11:20:29 <ReinH> fkbm: fkbm see http://mgaut72.github.io/2014/05/07/Backtracking-in-Haskell.html
11:20:40 <roelof> The book did not mention fold at this point. I only have read chapter 1 till 3 in the Craft book 
11:20:42 <ReinH> roelof: test it?
11:21:15 <roelof> yes, one of the exercises is stated I have to make quickCheck test for my average function 
11:21:15 <fkbm> ReinH: ! Thank you very much! Reading now. :)
11:21:15 <MarcelineVQ> roelof: you'll learn about fold in chapter 5 or 6 I think, whever it covers higher order functions
11:21:20 <Bez_> with fold you might not have that kind of accuracy regarding Ints or the like
11:21:23 <MarcelineVQ> roelof: What is the actual problem though?
11:21:30 <ReinH> fkbm: then you might be intereted in http://www-ps.informatik.uni-kiel.de/~sebf/data/pub/atps09.pdf
11:21:51 <Phyx-> lol... if there a nicer way to write "liftM3 ((<|> id) . (<|>))"
11:21:52 <Phyx-> ?
11:22:15 <roelof> MarcelineVQ:  I have written a function which calculates the average of 3 numbers ( a + b +c) / 3 
11:22:29 <monochrom> @type liftM3 ((<|> id) . (<|>))
11:22:30 <lambdabot> (Monad m, Alternative ((->) a3), Alternative ((->) (a3 -> r))) => m (a3 -> r) -> m (a3 -> r) -> m a3 -> m r
11:22:53 <roelof> MarcelineVQ: now I have to write QuickCheck test for it but I do not know another way to calculate the average 
11:23:16 <Ankhers> @pointful liftM3 ((<|> id) . (<|>))
11:23:16 <lambdabot> liftM3 (\ e -> ((<|>) e) <|> \ a -> a)
11:23:17 * hackagebot sdl2-cairo 0.1.0.2 - Render with Cairo on SDL textures. Includes optional convenience drawing API.  https://hackage.haskell.org/package/sdl2-cairo-0.1.0.2 (apirogov)
11:23:26 <Ankhers> Phyx-: ^^
11:23:38 <Ankhers> I don't know if that is any better...
11:23:40 * ankitk slaps lambdabot around a bit with a large fishbot
11:23:45 <Phyx-> was gonna say hehe
11:23:48 <roelof> I could put it into a list and so sum lists / length lists but that is not a nice way 
11:24:04 <monochrom> the constraint Alternative ((->) a3) suggests that you did something wrong
11:24:21 <nomeata> Recent GHCs adjust the input and output encoding to the current locale. How does that work on Windows?
11:24:31 <nomeata> And how does it then work with wine? :-)
11:24:44 <Phyx-> monochrom: yes, I just noticed that
11:24:53 <Phyx-> what I actually wanted was just \a b c -> a <|> b <|> c
11:25:11 <roelof> I do not know, I use the cloud so I have a linux vm for my haskell work 
11:25:33 <ReinH> Phyx-: Yes, use points.
11:25:44 <ReinH> Phyx-: use that.
11:25:58 <Ankhers> @pl \a b c -> a <|> b <|> c
11:25:58 <lambdabot> ((<|>) .) . (<|>)
11:26:06 <ReinH> Don't use that.
11:26:08 <Ankhers> So much clearer
11:26:46 <monochrom> nomeata: this means in a console you get the encoding corresponding to the codepage, by default windows-125? (varies by what you told Windows about your country). use "chcp 65001" to get the codepage for utf-8.
11:27:00 <Phyx-> ReinH: yeah, I stuck to the pointful one :)
11:27:31 <Ankhers> > foldl1 (\acc a -> (acc + a) / 2) [1..10] 
11:27:33 <lambdabot>  9.001953125
11:27:39 * monochrom hates windows-125? and the whole notion of "every country gets a different charset and/or encoding"
11:28:35 <Ankhers> > foldl1 (\acc a -> (acc + a) `div` 2) [1..10] 
11:28:36 <lambdabot>  9
11:28:50 <ankitk> hi, I am writing a coding judge to evaluate haskell based competitions. For safely running code, I have used mueval. However mueval seems to restrict output
11:28:57 <monochrom> the whole notion is ridiculous because it says you can't store both Polish song titles and Swedish song titles in the same file.
11:29:11 <ankitk> like map succ [0..1000]
11:29:17 <ankitk> gives only output till 283
11:29:18 <monochrom> even the same computer
11:29:23 <ankitk> same with lambdabot
11:29:44 <ankitk> why this behaviour ?
11:30:39 <monochrom> ankitk: mueval deliberately cuts off by time and by output length in order to fight DoS attacks.
11:30:44 <MarcelineVQ> ankitk, dunno but probably the "It uses resource limits, " part of its package description
11:30:54 <dgpratt> after all this time messing with it and still a handful of Haskell code can totally make my head spin
11:31:36 <dgpratt> maybe Dijkstra was right, starting with (Visual) Basic has mentally mutated me
11:31:58 <ankitk> and my whole library is built around mueval
11:32:01 <nomeata> monochrom: ok. is there a way to find out what ghc thinks is the current codepage?
11:32:02 <Sonolin> its ok same here dgpratt
11:32:17 <Sonolin> and I started with ti86 basic & autoit macros
11:32:21 <ankitk> monochrom is there a way I can get around this limit? because test case solutions are typically much larger than this
11:33:04 <dgpratt> :)
11:33:12 <roelof> So there is no other way then using folds to calculate the average of 3 numbers ?? 
11:33:29 <Ankhers> ankitk: Why not just write some test cases for the challenges?
11:33:48 <liste> > (\a b c -> (a + b + c) / 3) 10 15 20
11:33:50 <lambdabot>  15.0
11:33:55 <ankitk> Ankhers you mean using quickcheck ?
11:33:59 <monochrom> nomeata: look for hGetEncoding in System.IO. the type TextEncoding is abstract but has a Show instance tell you its name
11:34:10 <Ankhers> ankitk: quickcheck, hspec, hunit, whatever.
11:34:55 <roelof> liste:  thanks but I use already a+b+c / 3 
11:35:00 <aweinstock> Ankhers: that handles the judging, but what if someone writes a reverse-shell at compile time with TH?
11:35:05 <aweinstock> s/writes/submits/
11:35:15 <monochrom> ankitk: I don't know how to change mueval's limits
11:35:44 <ankitk> It seems for large output, I will have to go for quickcheck
11:35:45 <ankitk> Actually I wanted to give both the functionalities, (to manually give output file / or give property of quickcheck)
11:36:31 <aweinstock> :t Language.Haskell.TH.runIO (System.Process.system "netcat and stuff")
11:36:32 <lambdabot> Language.Haskell.TH.Syntax.Q GHC.IO.Exception.ExitCode
11:36:34 <liste> roelof \a -> sum a / length a ?
11:36:35 <nomeata> monochrom: I found GHC.IO.Encoding.CodePage.localeEncoding which says that my codepage is CP850
11:37:05 <ankitk> monochrom then I will have to use quickcheck for checking large outputs
11:37:22 <Ankhers> aweinstock: I thought there were limits on TH to prevent stuff like that already. Guess I was wrong.
11:37:31 <bitemyapp> ReinH: yeah the simplicity threw me off.
11:37:36 <roelof> liste:  so a is then a list of the three arguments ?? 
11:37:42 <liste> yeah
11:37:50 <aweinstock> Ankhers: why would there be limits on TH? how else could you read database schemas from files at compile-time? :)
11:37:59 <liste> > let a = [1, 2, 3, 4, 5] in sum a / length a
11:38:01 <lambdabot>      No instance for (Fractional Int) arising from a use of ‘/’
11:38:01 <lambdabot>      In the expression: sum a / length a
11:38:01 <lambdabot>      In the expression: let a = [...] in sum a / length a
11:38:06 <aweinstock> (i.e. without arbitrary IO)
11:38:09 <liste> > let a = [1 :: Double, 2, 3, 4, 5] in sum a / length a
11:38:10 <MarcelineVQ> lenght returns an Int
11:38:11 <lambdabot>      Couldn't match expected type ‘Double’ with actual type ‘Int’
11:38:11 <lambdabot>      In the second argument of ‘(/)’, namely ‘length a’
11:38:11 <lambdabot>      In the expression: sum a / length a
11:38:24 <liste> thanks MarcelineVQ
11:38:35 <liste> but yeah, genericLength
11:38:42 <aweinstock> Ankhers: and that's without buffer-overflowing the GHC runtime using Foreign.Marshal
11:38:46 <liste> so sum a / genericLength a
11:39:42 <Ankhers> > let (x,y) = foldl (\(a,l) a' -> (a+a',l+1)) [1,2,3,4,5] in x / y
11:39:43 <lambdabot>      Couldn't match expected type ‘(t, t1)’
11:39:44 <lambdabot>                  with actual type ‘t0 Integer -> (Integer, Integer)’
11:39:44 <lambdabot>      Relevant bindings include
11:40:26 <Ankhers> let (x,y) = foldl (\(a,l) a' -> (a+a',l+1)) (0,0) [1,2,3,4,5] in x / y
11:41:09 <Ankhers> > let (x,y) = foldl (\(a,l) a' -> (a+a',l+1)) (0,0) [1,2,3,4,5] in x / y
11:41:10 <lambdabot>  3.0
11:41:23 <Ankhers> Probably a better way to do that.
11:41:30 <aweinstock> > let (x,y) = foldl (\(a,l) a' -> (a+a',l+1)) (0,0) [1..10000] in x / y
11:41:31 <lambdabot>  5000.5
11:41:36 <aweinstock> > let (x,y) = foldl (\(a,l) a' -> (a+a',l+1)) (0,0) [1..1000000] in x / y
11:41:38 <lambdabot>  *Exception: stack overflow
11:41:45 <aweinstock> > let (x,y) = foldl' (\(!a,!l) a' -> (a+a',l+1)) (0,0) [1..1000000] in x / y
11:41:49 <lambdabot>  mueval-core: Time limit exceeded
11:41:53 <Ankhers> right
11:42:03 <aweinstock> > let (x,y) = foldl' (\(!a,!l) a' -> (a+a',l+1)) (0,0) [1..100000] in x / y
11:42:05 <EvanR> Ankhers: or a exclicir recursion to avoid tuples
11:42:05 <lambdabot>  50000.5
11:42:10 <aweinstock> > let (x,y) = foldl (\(a,l) a' -> (a+a',l+1)) (0,0) [1..100000] in x / y
11:42:12 <EvanR> explicit
11:42:12 <lambdabot>  50000.5
11:42:42 <Ankhers> EvanR: Indeed.
11:43:09 <aweinstock> EvanR: BangPatterns isn't simpler than recursion (for this case)?
11:43:18 * hackagebot random-variates 0.1.0.0 - "Uniform RNG => Non-Uniform RNGs"  https://hackage.haskell.org/package/random-variates-0.1.0.0 (kpratt)
11:43:21 <EvanR> simpler?
11:43:31 <EvanR> sum xs / length xs ;)
11:43:44 <aweinstock> doesn't that traverse the list twice?
11:43:48 <EvanR> yes
11:44:02 <Ankhers> That's what I was trying to get away from.
11:44:08 <Ankhers> Rather, my solution.
11:44:26 <aweinstock> > (\xs -> sum xs / fromIntegral (length xs))  [1..1000000]
11:44:28 <lambdabot>  *Exception: stack overflow
11:44:33 <EvanR> but fold and foldl' will both create a big list of nested (,)
11:44:47 <Ankhers> Would foldr be better?
11:44:52 <aweinstock> foldl' with bangpatterns won't (if I understand correctly)
11:44:56 <EvanR> hmm wait fold' might work
11:45:12 <aweinstock> foldr creates a list of thunks instead of a list of tuples
11:45:19 <EvanR> still you dont even need that, and explicit recursion is easy
11:45:38 <EvanR> in this case
11:45:51 <EvanR> you still need bang patterns
11:47:12 <aweinstock> > let avg xs = aux xs 0 0 where { aux [] s l = s / l; aux (x:xs) s l = aux xs (s+x) (l+1)} in avg [1..1000000]
11:47:16 <lambdabot>  mueval-core: Time limit exceeded
11:47:25 <EvanR> wow the naive version stack overflows?
11:47:40 <aweinstock> time expire, not stack overflow
11:47:43 <aweinstock> > let avg xs = aux xs 0 0 where { aux [] s l = s / l; aux (x:xs) s l = aux xs (s+x) (l+1)} in avg [1..100000]
11:47:45 <lambdabot>  50000.5
11:47:48 <EvanR> above
11:47:50 <aweinstock> > let avg xs = aux xs 0 0 where { aux [] s l = s / l; aux (x:xs) s l = aux xs (s+x) (l+1)} in avg [1..500000]
11:47:52 <lambdabot>  *Exception: stack overflow
11:47:56 <aweinstock> oh, huh
11:48:05 <aweinstock> > let avg xs = aux xs 0 0 where { aux [] s l = s / l; aux (x:xs) !s !l = aux xs (s+x) (l+1)} in avg [1..500000]
11:48:07 <lambdabot>  250000.5
11:48:23 <EvanR> you need bang patterns on s and l
11:48:31 <johnw> yeah
11:48:54 <johnw> otherwise, I think you're allocating stack to hold arguments that yet to be forced
11:49:19 <EvanR> one day i will understand this stuff
11:49:29 <johnw> one day you will
11:54:20 <EvanR> > let xs = [1..1000000] in sum xs / length xs
11:54:22 <lambdabot>      No instance for (Fractional Int) arising from a use of ‘/’
11:54:22 <lambdabot>      In the expression: sum xs / length xs
11:54:22 <lambdabot>      In the expression: let xs = [1 .. 1000000] in sum xs / length xs
11:54:25 <aaronm04> are there any good Haskell bindings to Qt?
11:54:58 <monochrom> no, heap holds the arguments yet to be forced. later, stack holds control-flow information for the evaluator when the arguments are forced.
11:55:13 <EvanR> > let xs = [1..1000000] in sum xs / fromIntegral (length xs)
11:55:15 <lambdabot>  *Exception: stack overflow
11:55:32 <monochrom> stack overflow is a consequence of forgetting to set a heap limit
11:55:51 <EvanR> is that a thing?
11:56:07 <EvanR> heap limits huh
11:56:10 <monochrom> yes, heap limit is a thing. set it with +RTS -M8M
11:57:07 <monochrom> there is no tenable reason to leave heap unlimited but set a puny stack limit such as the traditional 8M
11:57:08 <EvanR> so if the thunks go too deep when start evaluating them, stack overflow
11:57:32 <monochrom> every reason said has been refuted by me
11:57:38 <johnw> EvanR: that doesn't sound right
11:57:54 <monochrom> in fact, for every reason said, setting heap limit is a better solution
11:59:07 <EvanR> if you cant get the next result without going very deep in thunks 
11:59:18 <johnw> what does "very deep in thunks" mean?
11:59:33 <johnw> usually if lots of thunks are being created, it is because evaluation is too shallow across a large structure
11:59:42 <EvanR> a big tower of strict ops
11:59:45 <johnw> the nature of thunk itself is what prevents "depth"
11:59:48 <johnw> ah
11:59:52 <johnw> thunks that reference thunks, you mean
11:59:57 <EvanR> yeah
12:00:03 <johnw> yeah, like what foldl (+) does
12:00:10 <johnw> ok, I get you know
12:00:11 <johnw> now
12:00:19 <EvanR> this is my hypothesis
12:00:53 <EvanR> strict ops are the problem!
12:00:58 <nomeata> too bad that the RTS options do now allow overriding the detected locale/codepage.
12:01:33 <monochrom> nomeata: you can always hSetEncoding utf8
12:01:36 <sinelaw> causing program to fail due to tiny stack does sometimes point at otherwise unnoticed leaks
12:01:49 <monochrom> of course, I mean hSetEncoding stdin utf8
12:02:04 <nomeata> monochrom: well, but then I have to change the code and recompile, and I cannot use "readFile" conveniently any more etc.
12:02:15 <Ararat> Clint, PM.
12:02:30 <nomeata> and e.g. for a test suite it makes sense to adjust the environment, not the program.
12:02:37 <monochrom> sinelaw: that reason is destroyed by setting heap limit, which detects the problem even earlier.
12:04:56 <monochrom> in order to spend Θ(n) stack space, first you have to spend Θ(n) heap space to build the thunk that later requires the said stack space to evaluate
12:06:35 <monochrom> so for example your program leaks 32GB heap space, and then requires 32GB stack space to evaluate that monster. and you want to catch that leak.
12:06:51 <monochrom> but you only have 8GB RAM
12:07:35 <monochrom> the traditional solution, which sets heap unlimited, stack 8MB limit, is clearly sillily painful
12:08:27 <monochrom> it means first you wait for your poor computer to thrash to death, and then, after half an hour of thrashing, you can finally observe the 8MB stack overflow
12:08:47 <sinelaw> stack usage is always proportional to heap usage?
12:08:49 <monochrom> this is clearly inferior to setting 4GB heap limit in the first place
12:09:08 <monochrom> no, and that's not what I said.
12:09:45 <monochrom> my sentence is an "implies" sentence, not an "equivalent" sentence.
12:10:29 <monochrom> I guess I also erred by using Θ throughout. how about this:
12:10:52 <monochrom> in order to spend Θ(n) stack space, first you have to spend Ω(n) heap space
12:12:22 <ReinH> monochrom: Those squigglies always confuse me anyway
12:14:14 <sinelaw> monochrom: me also, what's your definition of Omega?
12:14:55 <sinelaw> lower bound?
12:14:59 <hiptobecubic> isn't it always "lower-bounded by"?
12:15:17 <monochrom> g ∈ Ω(f)  iff  f ∈ O(g)
12:16:14 <fkbm> !request Viva unicode ☺
12:16:19 <monochrom> I have a donkey doll with this label: "it's all greek to me"
12:16:31 <fkbm> That totally came out wrong.
12:16:40 <monochrom> it is from an ACM programming contest
12:16:58 <ReinH> monochrom: nice :)
12:17:00 <sinelaw> monochrom: so you need _more_ heap space than stack space? can't the evaluation diverge much worse than the thunks required to represent it?
12:17:58 <lpaste> flexfit pasted “No title” at http://lpaste.net/8400172534451929088
12:18:31 <flexfit>   I'm trying to create a list comprehension to add the tuples together into a list, but I'm getting an error and i'm not sure why.
12:19:15 <sinelaw> flexfit: 'x' and 'y' are supposed to be lists in that syntax
12:19:16 <aweinstock> x and y aren't lists, so can't be drawn from
12:19:21 <ReinH> flexfit: You've pattern matched x and y, which are now elements of the list, and are then using them in the list comprehension in the place where lists go.
12:19:33 <aweinstock> addPairs xs = [a+b | (a,b) <- xs]
12:19:41 <ReinH> er, x and y are not elements of the tuple that is the first element of the list.
12:19:44 <ReinH> *now
12:20:03 <aweinstock> :t map (uncurry (+))
12:20:04 <lambdabot> Num b => [(b, b)] -> [b]
12:20:23 <sinelaw> monochrom: also, looks like when running out of heap space, -xc doesn't help
12:20:34 <aweinstock> :t map (uncurry (+)) `asTypeOf` (\xs -> [a+b | (a,b) <- xs)
12:20:35 <lambdabot> parse error on input ‘)’
12:20:36 <sinelaw> monochrom: whereas for stack space it does print the cost center stack
12:20:39 <aweinstock> :t map (uncurry (+)) `asTypeOf` (\xs -> [a+b | (a,b) <- xs])
12:20:40 <lambdabot> Num b => [(b, b)] -> [b]
12:21:01 <sinelaw> monochrom: what's your way of knowing which part of the program cause the heap to be exhausted?
12:22:09 <lpaste> flexfit pasted “My revision” at http://lpaste.net/3700856010521444352
12:22:18 <monochrom> it is unfortunate that heap overflow is currently uncatchable, so that if you really want -xc to work, you have to resort to stack
12:22:19 <flexfit> This revision seems to be erroring out as well.
12:23:31 <EvanR> sinelaw: well, testing a single algorithm in isolation that youre expecting to use not much memory, heap limit would make the debug compile test cycle faster
12:23:47 <EvanR> im in the gigs of heap usage before i know it
12:23:57 <EvanR> and it doesnt crash
12:23:58 <ReinH> @google haskell profiling memory usage
12:23:59 <lambdabot> https://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html
12:24:43 <EvanR> in my case ill never get a stack overflow either
12:26:30 <flexfit> Ah, I see where I went wrong.
12:26:51 <sinelaw> EvanR: but that means I already know which part of my program is the algorithm with the problem. I'm profiling a large application here
12:26:59 <EvanR> yeah
12:27:07 <EvanR> the the rest of your application may need more than 8M of heap ;)
12:27:24 <sinelaw> ReinH: the various heap profile hint at a direction but don't always help tracking down the issue to specific parts of the code
12:27:26 <EvanR> and its crashing itself of the problem part
12:27:29 <sinelaw> *profiles
12:27:43 <EvanR> instead of*
12:28:32 <sinelaw> forcing stack overflows and catching them with -xc was a nice trick to learn
12:28:57 <EvanR> link?
12:29:23 <ReinH> sinelaw: Well, that's true. There re no specific parts of your code on the heap to begin with.
12:29:25 <ReinH> *are
12:29:56 <sinelaw> EvanR: http://neilmitchell.blogspot.co.uk/2015/09/detecting-space-leaks.html
12:30:36 <EvanR> thx
12:34:11 <nomeata> monochrom, JFTR: I moved the question here: http://stackoverflow.com/questions/33156758/get-haskell-programs-to-assume-a-utf8-locale-under-wine
12:35:06 <monochrom> I don't know what Wine does
12:36:16 <monochrom> LANG is a linux or unix thing, most likely does nothing to Windows. but ah, I don't know mingw and cygwin either.
12:37:43 <luite> monochrom: how about allocation limits, they're catcheable aren't they?
12:37:57 <ReinH> I have to wonder why someone would run their Haskell program in a windows emulation when they have a perfectly good native linux environment available.
12:38:06 <monochrom> which allocation limit? heap? stack?
12:38:10 <luite> heap
12:38:23 <monochrom> that is the uncatcheable one that pains me a lot
12:38:30 <anelson-> hey guys, I'm reading this blog post for how to use data-files with cabal: http://neilmitchell.blogspot.com/2008/02/adding-data-files-using-cabal.html. This works fine when I'm doing development, but the problem is that when I actually install the package, the getDataFileName is not being overloaded by cabal (it just keeps using the one that I had). Anyone know how to change this behavior?
12:38:42 <luite> monochrom: i mean the ones that ezyang implemented not too long ago
12:39:12 <anelson-> I suppose the quick way of asking is, since this module is supposed to be auto-generated by cabal on installation, how can I get it to skip the existing one that I wrote?
12:39:16 <monochrom> I would really love to write to Neil Mitchell to say "your method would be so much greater if you changed -K to -M", but current GHC doesn't help
12:39:20 <EvanR> is there something on the mailing list which complains about that
12:39:36 <EvanR> "we want heap allocation limit exceptions with traces"
12:40:06 <monochrom> I haven't know ezyang's work. is it already in GHC 7.10.2?
12:40:56 <bitemyapp> monochrom: why -K to -M?
12:41:22 <luite> monochrom: yeah, but i think they just count allocated bytes, so it may not be a good approximation of what actually uses the heap
12:42:30 <monochrom> EvanR, I worry that there is something fundamental about heap overflow that says it will be very difficult to do "upon heap overflow, do something that... needs moar heap!"  stack overflow does not suffer from this self-referential paradox because moar stack can always be obtained from the not-yet-full heap
12:43:52 <EvanR> yes if the heap limit is taken seriously and its not just for cases like debugging on a 1234GB PC
12:43:57 * clrnd was wondering if someone coded a replacement of python -m SimpleHttpServer in hackage, they did!
12:44:02 <EvanR> it wont work in general
12:44:05 <monochrom> bitemyapp: in order to spend Θ(n) stack space, first you must spend Ω(n) heap stack to build the stuff that later requires said stack space during evaluation. therefore limiting heap catches your problem earlier, not later.
12:44:40 <EvanR> but when you run out of heap, all bets are off anyway, so why not try to do a report
12:44:49 <EvanR> it cant get any WORSE ;)
12:45:07 <monochrom> also consider the scenerio where your heap leak is 32GB but you only have 8GB RAM. you really don't want to wait for the heap to really grow to 32GB so that you can then observe your 8MB stack overflow
12:45:25 <sinelaw> clrnd: what's it called?
12:45:28 <monochrom> ok, maybe you really want to, but it will be painful
12:45:36 <clrnd> hserv
12:45:59 <sinelaw> thanks
12:48:33 <bitemyapp> monochrom: I think I get your point, but it doesn't line up changing the K to M in my head yet.
12:49:05 <monochrom> -K sets stack limit, -M sets heap limit
12:49:53 <EvanR> are they separate or is it like you said and stack is allocated in the heap
12:50:15 <sinelaw> should I roll out my own unification-fd?
12:51:00 <monochrom> they are no separate
12:51:53 <twomashi> Hi all; im a bit confused about what Data.Conduit.Attoparsec
12:53:01 <aweinstock> twomashi: it looks like you stopped in the middle of a sentence
12:53:09 <twomashi> ^ ... actually does. I'm trying to write a conduit to parse a stream into records. Should I be using conduitParser? sinkParser seems wrong since I want to stream the parsed records to another conduit
12:53:45 <twomashi> aweinstock: indeed I did. 
12:55:49 <aweinstock> twomashi: conduitParser looks like it does what you want
12:56:12 <monochrom> luite: I have found the stuff about -xq and enableAllocationLimit. it is going to be hard to use if I have something like "print (map f (map g [1..]))" but without fusion for whatever reason, which takes O(1) memory but the allocation count is going to go crazy.
12:56:15 <twomashi> I really am being terribly lazy not reading the source code
12:56:19 <aweinstock> (or possibly conduitParserEither, if you want the parse errors as Lefts)
12:57:05 <twomashi> aweinstock: thank you !
12:58:05 <luite> monochrom: right, you need profiling to know what retains memory
12:59:21 <hexagoxel> quicksilver, nshepperd, cchalmers: Any of you have a bit of time to look at my implementation (before i upload to hackage); all this unsafe stuff feels risky :D https://github.com/lspitzner/bindynamic/blob/master/src/Data/Dynamic/Binary.hs
13:00:46 <elkorn> hello everyone. I'm continuing my newbie struggles with State. What I would like is to get numbers from stdin, append them to a stack contained within a State monad and print the stack on each iteration. Here is what I have: http://sprunge.us/IMMH?haskell . The problem, obviously, is that I don't know how to 'continue' the state so that I can see the stack being extended.
13:01:14 <elkorn> merijn has recommended looking into state transformers and I did but unfortunately I'm not able to see how can I use a transformer to my advantage here
13:01:34 <elkorn> (and I've also implemented State and StateT as per his recommendation, for which I'm grateful)
13:02:08 <sinelaw> elkorn: look at State's 'modify'
13:02:08 <breadmonster> elkorn: you could use an IORef?
13:02:13 <sinelaw> plus 'get' and 'put'
13:02:24 <breadmonster> :info IORef
13:02:42 <sinelaw> elkorn: http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State-Lazy.html
13:03:38 <elkorn> sinelaw: am I not essentialy doing that by using my `push` function?
13:03:46 <sinelaw> you can then: push n = modify (n:)
13:04:34 <sinelaw> elkorn: yes, but it lets your write nicer code
13:05:09 <sinelaw> elkorn: anyway, with StateT you can combine those actions with IO
13:05:17 <elkorn> sinelaw: most defintiely, however I have to grok this first
13:05:54 <sinelaw> :t StateT
13:05:55 <lambdabot> (s -> m (a, s)) -> StateT s m a
13:06:08 <elkorn> breadmonster: I'll read up on IORef because I know absolutely nothing about it as of now
13:06:36 <breadmonster> elkorn: Actually, I think it's a better idea to use StateT.
13:06:42 <EvanR> combining IO with a State which is just for doing IO with is kind of beating around the bush
13:06:47 <breadmonster> IORef is what's used to implement imperative programming.
13:06:49 <sinelaw> elkorn: you can use IORef, but you probably don't want to
13:06:51 <EvanR> you can keep your stack in an IORef
13:07:26 <breadmonster> The IO monad is horribly named, it does so much more than IO.
13:07:36 <sinelaw> using StateT means you'll be able to extract more pure code 
13:07:49 <EvanR> StateT over IO is not great in real apps
13:07:53 <breadmonster> It should be called the Imperative monad or something.
13:07:58 <breadmonster> EvanR: As opposed to?
13:07:58 <elkorn> hmmm
13:08:03 <breadmonster> STT over IO?
13:08:07 <EvanR> im skeptical about being able to extra pure code from StateT over IO
13:08:20 <EvanR> breadmonster: no, just IO or ReaderT over IO
13:08:27 <EvanR> using IORefs or MVars
13:08:33 <EvanR> or TVars
13:09:08 <elkorn> is there a possibility of some hand-holding for how this should look like with StateT instead of just State? I would also appreciate references to examples that are not random number generators 
13:09:25 <EvanR> :t runStateT
13:09:27 <lambdabot> StateT s m a -> s -> m (a, s)
13:09:33 <EvanR> m = IO
13:09:39 <hexagoxel> but with IORefs/any vars you put a bit more work on the reader, who has to check that you only use the IORef in that specific place.
13:10:11 <EvanR> StateT plus a multitude of helper utilities to do the same thing isnt much better
13:10:31 <EvanR> i mean, for the whole app
13:11:25 <elkorn> EvanR: the thing that bogs me down right now is how can I get the s from previous iteration - how can I extract it from the previous state to print it out and pass on the new state with the extended stack
13:11:34 <sinelaw> elkorn: https://wiki.haskell.org/Simple_StateT_use
13:11:51 <EvanR> elkorn: see runStateT, the new state is returned
13:12:14 <EvanR> but you actually dont have to do that, you can stay in the StateT the whole time and use IO from in there
13:12:15 <sinelaw> elkorn: that link looks like a good example
13:12:17 <EvanR> :t liftIO
13:12:19 <lambdabot> MonadIO m => IO a -> m a
13:12:19 <hexagoxel> i don't disagree; in an all-powerful environment (IO) you already force the reader to be rather careful anyway. but it is a tradeoff.
13:12:27 <elkorn> sinelaw: looking into it
13:13:18 <EvanR> using just IO instead of a stack of monads that do what IO can do greatly simplifies things, which i like
13:13:49 <bitemyapp> EvanR: it's a good idea for beginners so they don't get tangled up in transformers before they're ready
13:13:49 <hexagoxel> the stack still adds additional info.
13:14:08 <bitemyapp> EvanR: but there's a danger that it leads to bad designs. Stuff like Pipes is better than using IO, for example.
13:14:09 <EvanR> it adds additional info, at a huge cost of code
13:14:20 <bitemyapp> I don't know about huge. It depends on the scale of the project.
13:14:24 <EvanR> yeah for pipes you just replace the whole thing with pipes
13:14:25 <sinelaw> IO comes with lots of power
13:14:33 <bitemyapp> you don't want to bury everything in IO. Really, you don't.
13:14:34 <sinelaw> often much more than what you need
13:14:38 <bitemyapp> but it's okay if you're just learning.
13:14:40 <EvanR> not everything
13:15:08 <johnw> EvanR: you can always use mtl too to make IO for your application appear like a stack
13:15:21 <EvanR> hows that
13:15:35 <joe9> template-default seems to be obsolete. Is there an alternative to derive default values?
13:15:41 <bitemyapp> mtl deserves more love than it gets.
13:15:57 <johnw> MonadState String IO .... get = readIORef someVar
13:15:58 <johnw> etc.
13:16:54 <EvanR> MonadState the class? whats the type?
13:17:02 <johnw> it's in the mtl
13:17:15 <johnw> you're just making an instance to turn IO into a notional state monad
13:17:23 <johnw> around some chosen variable
13:17:24 <EvanR> anonymous instance?
13:17:32 <johnw> why anonymous?
13:17:40 <johnw> instance MonadState String IO where
13:17:41 <EvanR> im just having a hard time parsing your example
13:18:06 <johnw> you can make any monad a MonadState for exactly one type, if you can implement get and put
13:18:27 <EvanR> so for many variables, your use newtypes?
13:18:30 <EvanR> youd*
13:18:42 <johnw> you'd have to newtype IO itself for that
13:18:51 <johnw> so better to have state over a record of those many variables
13:18:52 <EvanR> ..... ok
13:19:01 <johnw> MonadState AppEnv IO
13:19:02 <EvanR> might as well use StateT
13:19:03 <monochrom> elkorn: http://lpaste.net/143093
13:19:18 <bitemyapp> EvanR: it's a little hard to motivate mtl ex nihilo
13:19:32 <bitemyapp> EvanR: better with an example that has meat on the bone.
13:19:38 <bitemyapp> but it really is nice.
13:19:43 <joe9>  http://codepad.org/xbTmiE5a is my code and I want to replace the deriveDefault with something that will work without the need for template-default.
13:19:43 <elkorn> monochrom: thanks
13:19:48 <joe9> any kind suggestions, please?
13:20:57 <elkorn> and thank you very much everyone for the help, I think I got it and you also gave new stuff to process which is always good
13:21:46 <EvanR> from a modularity perspective, a module or library for doing IO seems like should export IO (or MonadIO) for everything instead of a complex monad. since the complex monad client can probably incorporate the IO, but a simple client might not be able to incorporate the complex monad
13:21:59 <johnw> correct
13:22:13 <johnw> a library should require its most minimal needs
13:22:38 <johnw> it's exactly like in math, you want theorems with the weakest requirements and the strongest results
13:23:15 <johnw> it's not always bad to use IO instead of MonadIO though
13:23:28 <johnw> because the user can always lift
13:23:39 <johnw> what's harder is direct use of IO in higher-order contexts
13:23:51 <johnw> which can then require quite complex uses of monad-control to work around
13:24:18 <bennofs> but it's also hard to do that generically, since it's not always clear how the generic function should behave
13:24:20 <EvanR> right monad base control is where i get off the crazy train
13:24:49 <johnw> yeah, and monad-control has hidden semantic requirements which are not forced by the types
13:25:14 <johnw> bennofs: true
13:25:26 <johnw> also related to the semantic requirements issue
13:26:15 <dgpratt> one thing I really appreciate about Haskell is that for nearly every challenge it presents, there is a solution
13:27:02 <breadmonster> dgpratt: dependent types :(
13:27:07 <dgpratt> as an example, for purely pedagogical purposes, I find myself trying to define some type class instances for a data type involving an explicit forall
13:27:18 <dgpratt> I really have no idea what I'm doing
13:27:30 <EvanR> breadmonster: im sort of using this in my current project, with GADTs and singletons
13:27:34 <EvanR> and type families
13:27:47 <breadmonster> EvanR: It's not the same thing!
13:27:49 <EvanR> i want to use type nats
13:27:51 <dgpratt> but it doesn't matter! I just insert an _ here or there and mess around until it type checks!
13:27:59 <breadmonster> Why can't we just put dependent types in Haskell?
13:28:06 <dgpratt> I don't understand it, but it works
13:28:10 <EvanR> its not set up for all that
13:28:32 <EvanR> its too far down the road its on
13:28:33 <breadmonster> EvanR: We know how to do it.
13:28:46 <deni> is there a package that will let me programatically find out what the kernel version is on a linux box ?
13:29:13 <dgpratt> we can make it better! stronger! faster!
13:29:17 <johnw> system "uname -a"?
13:30:25 <dgpratt> breadmonster, I can barely wrap my mind around Haskell's type system as it is and you want to add dependent types?!
13:31:36 <dgpratt> even 'simple' dependent type constructions like "Fin" hurt my head
13:32:13 <johnw> dgpratt: Fin is a type with a restricted set of contructors
13:32:23 <EvanR> haskell has GADTs
13:32:33 <EvanR> which is half way there
13:32:45 <johnw> i.e., For type Fin n, there is no constructor that can construct a value outside that range
13:32:46 <dgpratt> I know that now, johnw, but too many brain cells were lost on the learning of it
13:32:49 <johnw> ah
13:33:06 <EvanR> too many brain cells exploded...
13:33:14 <EvanR> and were replaced with 10 more!
13:33:30 <johnw> I find that mostly dependent types are about restricting value spaces by having more qualified types
13:34:00 <dgpratt> what about things like liquid types?
13:34:10 <johnw> refinement types are a subset of that description
13:34:14 <EvanR> dependent types can do more things
13:34:26 <dgpratt> yeah, but do we need the more things?
13:34:29 <EvanR> i do!
13:34:30 <johnw> you do
13:34:41 <johnw> liquid types can only reason about decidable things
13:34:42 <bitemyapp> dgpratt: I see people asking how to do stuff on /r/haskell periodically
13:34:57 <bitemyapp> dgpratt: and the answer to their question is usually, "well, it'd be straight-forward in a dependently typed language"
13:35:22 <bitemyapp> dgpratt: like the "matrix with size in the type" similar to a classic dependent types demo.
13:35:58 <EvanR> sized structures is just the tip of the iceberg
13:37:38 <bitemyapp> EvanR: right
13:38:24 <EvanR> the classic example of the Vect is off putting to me, its good for a basis in how to prove theorems and termination, but
13:38:42 <bitemyapp> not the most compelling thing in the universe.
13:38:50 <EvanR> really the type-level offers a lot that doesnt have to do anything with the implementation
13:39:07 <EvanR> doesnt have to have to do with implementations
13:39:10 <tsahyt> What are some simple comonads to look at to get an idea as to why I would want to use the concept?
13:39:18 <johnw> I'm *so* tired of the Vect example
13:39:25 <monochrom> sized structure is also a wrong reading.
13:39:33 <johnw> especially since you don't even need the full power of dependent types for it
13:39:39 <johnw> Haskell can do it these days too
13:39:55 <johnw> tsahyt: there's a great paper from ICFP you should read
13:40:09 <phaazon> hey, what is the nickname of Michael Snoyman?
13:40:13 <johnw> snoyberg
13:40:16 <ggVGc> I want to consume some JSON containing links, and trigger wget processes for downloading. What are my best options in haskell?
13:40:17 <phaazon> thanks
13:40:26 <phaazon> arf, not on IRC
13:40:34 <EvanR> ggVGc: aeson
13:40:43 <tsahyt> johnw: What's the title of that paper?
13:40:44 <monochrom> when you read the type "Vec 4 Int", the 4 there is not the size, it is the shape. i.e., you are looking at the ():():():():[] aspect of 4, not the "4 cc of whiskey" aspect.
13:40:47 <johnw> tsahyt: https://www.reddit.com/r/haskell/comments/3e052c/haskell_15_preprint_functional_pearl_getting_a/
13:41:01 <tsahyt> johnw: Thanks!
13:41:12 <phaazon> monochrom: where have you read such a type?
13:41:19 <phaazon> that’s funny because I defined one in luminance
13:41:27 <ggVGc> EvanR: and for the process management of the wget instances?
13:41:44 <phaazon> https://github.com/phaazon/luminance/blob/master/src/Graphics/Luminance/Core/Vertex.hs#L25 monochrom 
13:41:47 <EvanR> ggVGc: well you can just use forkIO and MVars, or the async package
13:41:52 <ggVGc> mkay, thanks
13:41:59 <tsahyt> Is that modal operator really supposed to be a box or am I missing a font here or something?
13:42:07 <ggVGc> I haven't written any real useful haskell programs yet. This will be a big step :)
13:42:20 <phaazon> ggVGc: what you are about to write? :)
13:42:21 <monochrom> to see this, when you try to define a binary tree type, you can't just include "number of nodes in the tree" in your dependent type or refinement type. if you try, you find that it does nothing.
13:42:22 <EvanR> glhf
13:42:22 <phaazon> just being curious :)
13:42:49 <breadmonster_> So type level nats have no results on implementation.
13:42:51 <ggVGc> phaazon: literally processing a datasetin JSON that contains URL links, and downloading them based on some heuristics over the links
13:42:57 <breadmonster_> Does that mean that ghc optimizes them away?
13:42:58 <ggVGc> i.e choosing which links to download
13:43:14 <phaazon> ggVGc: great!
13:43:16 <EvanR> breadmonster_: types dont exist at runtime anyway
13:43:16 <phaazon> have fun :)
13:43:23 * hackagebot hspec-webdriver 1.1.0 - Write end2end web application tests using webdriver and hspec  https://hackage.haskell.org/package/hspec-webdriver-1.1.0 (JohnLenz)
13:43:25 <breadmonster_> EvanR: Oh really?
13:43:25 * hackagebot webdriver-angular 0.1.8 - Webdriver actions to assist with testing a webpage which uses Angular.Js  https://hackage.haskell.org/package/webdriver-angular-0.1.8 (JohnLenz)
13:43:29 <monochrom> i.e., whereas you know that the tail of a "Vec 4 Int" gives you a "Vec 3 Int", you don't know how to answer the question "the left of a 'BinTree 4 Int' is 'BinTree ? Int'"
13:43:48 <EvanR> breadmonster_: not unless you reified them like Typeable Typerep values
13:43:50 <monochrom> then you find that instead of putting 4 there, you have to put the whole tree shape there.
13:44:13 <johnw> Vec 4 Int is the family of values that can inhabit that shape
13:44:22 <ggVGc> what do I use in haskell to check filesystem information? I will need to check file sizes of some things after downloads, and delete some of them
13:44:23 <EvanR> > typeOf 4
13:44:24 <lambdabot>  Integer
13:44:31 <EvanR> :t typeOf 4
13:44:32 <lambdabot> TypeRep
13:44:43 <ggVGc> and issuing delete commands to the file system too I guess
13:44:50 <johnw> BinTree 4 Int is a family where the size of the left sub-tree is not expressed in the type
13:45:14 <ReinH> ggVGc: Do you need Windows support?
13:45:18 <ggVGc> nope
13:45:19 <EvanR> ggVGc: System.IO
13:45:20 <ggVGc> linux is fine
13:45:24 <johnw> you'de need BinTree 1 3 Int or something, for a family whose subtrees are specific families
13:45:41 <ggVGc> thanks
13:45:53 <ReinH> @hackage unix
13:45:53 <lambdabot> http://hackage.haskell.org/package/unix
13:46:03 <ggVGc> ah, nie
13:46:04 <ggVGc> nice*
13:46:18 <ReinH> e.g. getFileStatus
13:46:23 <monochrom> johnw, then the left of a "BinTree 1 3 Int" will be "BinTree ? ? Int"
13:46:25 <ggVGc> ReinH: for the future, if I wanted windows support, what would I do then?
13:46:26 <EvanR> johnw: you could define BinTree 4 to be trees with 4 levels exactly
13:46:31 <ReinH> ggVGc: be sad?
13:46:36 <ggVGc> :(
13:46:36 <johnw> monochrom: it will be something that adds up to 1, is all that you know
13:46:40 <ggVGc> story of my programmer life
13:46:54 <johnw> so you now have knowledge of immediate descendents, but nothing beyond
13:47:05 <johnw> for that, you'd need to encode more, as you said
13:47:16 <EvanR> or 4 leaf nodes at the last level
13:47:23 <johnw> until you get a type whose inhabitants are only trees of that exact same shape
13:47:29 <ReinH> ggVGc: There's a package called easy-file that claims to be portable and work on Windows, but I haven't used it
13:47:33 <dgpratt> at one point I tried to prove that transpose :: Vec m (Vec n a) -> Vec n (Vec m a)
13:47:42 <dgpratt> I failed miserably
13:48:01 <EvanR> right, you have to implement that function to prove that theorem
13:48:12 <dgpratt> me and dependent types have been on the outs ever since
13:48:12 <johnw> dgpratt: in what language?
13:48:17 <dgpratt> Agda
13:48:24 <EvanR> but if the theorems are already correct, you can replace the proof with some hidden algorithm for the application
13:48:39 <johnw> dgpratt: part of the difficulty was likely your choice of Vec
13:48:46 <johnw> some Vecs are much better for proof than others
13:48:59 <sinelaw> @hoogle Applicative f => (a -> b -> f c) -> f a -> f b -> f c
13:49:00 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
13:49:00 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
13:49:00 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
13:49:09 <sinelaw> needs join :|
13:49:56 <breadmonster_> :t join
13:49:57 <lambdabot> Monad m => m (m a) -> m a
13:50:18 <dgpratt> johnw, the only Vec I know is basically a list type indexed by Nat
13:50:34 <johnw> there are also n-tuples
13:50:48 <monochrom> sinelaw: even the fewer-parameters version, (a -> f c) -> f a -> f c, is already >>=
13:50:50 <johnw> and size-constrained lists
13:51:24 <monochrom> so in a very strong sense, Applicative is not enough, you are really asking for Monad
13:51:33 <dolio> The easiest implementation for writing that function is Vec n a = Fin n -> a.
13:51:39 <breadmonster_> johnw: I don't see how those are different.
13:52:02 <johnw> breadmonster_: they are equivalent, but they are very different
13:52:15 <johnw> a size-constrained list is trivially coercible to a list
13:52:19 <breadmonster_> johnw: expound?
13:52:23 <johnw> an n-tuple is not a list
13:52:54 <dgpratt> because the constituents can have different types?
13:52:58 <monochrom> as in, if you have an Applicative instance X, and it also supports (a -> b -> X c) -> X a -> X b -> X c, or even just (a -> X c) -> X a -> X c, then you can already write Monad instance code for X
13:53:04 <johnw> yeah, the representation is different
13:53:06 <phaazon> hey, what does nub stand for?
13:53:13 <johnw> with a size-constrained list, you can always just throw away the constraint
13:53:19 <johnw> for an n-tuple, you'd have to convert it to a list
13:53:19 <breadmonster_> phaazon: removes duplicates.
13:53:28 <EvanR> a homogenous n-tuple
13:53:29 <phaazon> breadmonster_: huh…
13:53:35 <indiagreen> phaazon: “The nub of a situation, problem, or argument is the central and most basic part of it.”
13:53:39 <phaazon> oh
13:53:40 <phaazon> ok
13:53:41 <phaazon> thanks indiagreen 
13:54:14 <monochrom> . o O ( what is the nub of nub? )
13:54:14 <breadmonster_> Is there a faster nub than n^2?
13:54:26 <EvanR> isnt nub already not n^2?
13:54:36 <phaazon> breadmonster_: sure, we can have O(n log n)
13:54:37 <breadmonster_> @src nub
13:54:37 <lambdabot> nub = nubBy (==)
13:54:43 <breadmonster_> @src nubBy
13:54:43 <lambdabot> nubBy eq []     = []
13:54:43 <lambdabot> nubBy eq (x:xs) = x : nubBy eq (filter (\ y -> not (eq x y)) xs)
13:54:56 <phaazon> if you have the Ord constraint on the type 
13:55:02 <monochrom> nub is already n^2
13:55:14 <breadmonster_> that's clearly quadractic.
13:55:15 <EvanR> hmm
13:55:16 <jonascj> I've just gotten to "main = do..." in Learn You A Haskell, and I am uncertain why I can not just have 'name = "John"' inside that indented do-block. I have to use <- (for IO actions) or 'let name = "John"'. How come?
13:55:25 <EvanR> breadmonster_: well its not comparing every pair
13:55:35 <EvanR> at least
13:55:40 <breadmonster_> EvanR: asymptotically.
13:56:11 <dolio> It is only n^2 if the number of distinct elements is proportional to the number of total elements (n).
13:56:22 <monochrom> jonascj: this syntax aspect reflects our idea of emphasizing expressions rather than commands
13:57:00 <fizbin> dolio: True. It's probably better to say that it's O(n^2) in the worst case, when every element is distinct.
13:57:02 <dolio> Or if n is the number of distinct elements, then it is O(n^2).
13:57:25 <jonascj> monochrom: right, because "main = do \n expression \n expression \n expression" looks somewhat like an imperative program with lines needing execution in the order they appear. 
13:57:48 <fizbin> With an Ord constraint, here's a better (worst-case) nub:
13:57:51 <fizbin> nub :: Ord a => [a] -> [a]
13:57:51 <fizbin> nub = go S.empty
13:57:51 <fizbin>   where
13:57:51 <fizbin>     go _ [] = []
13:57:51 <fizbin>     go s (a:as) | a `S.member` s = go s as
13:57:51 <fizbin>     go s (a:as) = a : go (S.insert a s) as
13:57:56 <dolio> Actually, I guess that latter one is a bad way to put it.
13:58:20 <dolio> Use a paste website.
13:58:48 <monochrom> or use a one-liner. S.toList . S.fromList
13:59:04 <arkeet> monochrom: that doesn't preserve order
13:59:05 <indiagreen> monochrom: won't it mess up order?
13:59:05 <EvanR> is that better than nub?
13:59:18 <monochrom> oh, oops, you're right
13:59:18 <fizbin> dolio: Maybe. 5 lines seems a bit too small to go paste.
13:59:24 <fizbin> Though I guess that was 6.
13:59:31 <johnw> dgpratt: not at all helpful, but since you nerd-sniped me: https://gist.github.com/fe9941dd52eb51f38dd7
13:59:39 <beepbeep_> init: Return all the elements of a list except the last one. The list must be non-empty. Where does the name init come from? I'll never remember that.
13:59:51 <barrucadu> beepbeep_: "initial"
13:59:54 <monochrom> unfortunately 5 lines is also at the border of too-large-to-IRC
14:00:03 <dolio> Paste sites don't ban you for pasting things that are too small.
14:00:08 <johnw> monochrom: 5 is what my auto-pastie-maker is set for
14:00:13 <dgpratt> johnw, what's the target language?
14:00:16 <johnw> dgpratt: Coq
14:00:19 <dolio> :)
14:00:20 <dgpratt> oh
14:00:32 <jokleinn> is there somewhere i could set ghc's default invocation to include "-fPIC"? I'm using hardened gentoo, this is basically manditory for ld to work with haskell programs.
14:00:39 <jokleinn> and no, an alias won't help me
14:00:40 <dgpratt> I do not get Coq at all
14:00:48 <johnw> dgpratt: if you squint, you'll see that all I'm doing is induction on naturals
14:01:01 <beepbeep_> barrucadu, "initial" still doesn't make sense to me but thx!
14:01:04 <johnw> now, whether this *behaves* like the transpose you know and love, I haven't verified
14:01:15 <johnw> I've only proved that the type is inhabited
14:01:24 <dgpratt> to me Coq looks like "utter this magic thing...utter that magic thing...etc...QED"
14:01:37 <johnw> dgpratt: that is indeed Coq in a nutshell
14:01:41 <dgpratt> lol
14:02:02 <phaazon> :t right
14:02:03 <lambdabot> ArrowChoice a => a b c -> a (Either d b) (Either d c)
14:02:14 <phaazon> :t right'
14:02:15 <lambdabot> Choice p => p a b -> p (Either c a) (Either c b)
14:02:40 <EvanR> alphaconversion go!
14:03:00 <monochrom> jokleinn: in *.cabal, you can add a "ghc-options:" line
14:03:10 <johnw> dgpratt: cool, it even transposes vectors ;)
14:03:43 <dgpratt> hey now!
14:03:49 <johnw> the last question then, since this definition is computational relevant, is whether it does it efficiently
14:04:12 <dolio> And the answer is, no. :)
14:04:26 <johnw> dolio: are you saying that because of the code, or because of Coq?
14:04:37 <dolio> The latter.
14:04:39 <phaazon> :t second
14:04:40 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
14:04:46 <jokleinn> monochrom: I mean globally. xmonad, far as I can tell, does not use cabal when it hit my recompile keybind, which unfortunately means I never get a new config loaded.
14:04:50 <dolio> I didn't look at the code.
14:04:59 <johnw> dolio: you'd probably be right on both counts
14:05:00 <beepbeep_> When I Hoogle "null" I see the signature null :: t a -> Bool. When I :type null in Hugs I see null :: a -> Bool. What does the "t" in null :: t a -> Bool mean?
14:05:24 <monochrom> I don't know how to do it globally
14:05:28 <johnw> beepbeep_: it's expecting some kind of Foldable thing, I think
14:05:29 <EvanR> null :: [a] -> Bool
14:05:42 <EvanR> :t null
14:05:43 <lambdabot> Foldable t => t a -> Bool
14:05:45 <dolio> Transpose will be very efficient using my optimized representation.
14:05:46 <dgpratt> elim: m => /= [|m IHm] in v *. ??? I mean, seriously now. I know Coq is from France, but c'mon!
14:05:52 <johnw> dolio: you around Dec 1-3?
14:05:56 <jokleinn> monochrom: can I do something stupid like block ghc updates in my package manager, then make something like a shell script to forward all commands to ghc with -fPIC at the end?
14:06:07 <johnw> dgpratt: seriously!
14:06:21 <johnw> I'm waiting for Coq 9 to just adopt TECO syntax
14:06:59 <dolio> johnw: Not sure. Maybe.
14:07:02 <johnw> dgpratt: however, note that I'm using ssreflect, which is more "line noise-like" until you get used to it
14:07:07 <johnw> dolio: time for ribs again
14:07:11 <dolio> Ooo.
14:08:45 <beepbeep_> EvanR, yeah, I saw that, but when I check on Hoogle, it looks like t a -> Bool. It's my first day playing with Haskell, I wonder what the "t" stands for.
14:09:42 <EvanR> beepbeep_: i think thats a bug, its because null is part of the Foldable class now so the source literally says null :: t a -> Bool on that line
14:09:43 <magneticduck> beepbeep_: a foldable data structure
14:09:59 <EvanR> but the full type is Foldable t => t a -> Bool
14:10:36 <fizbin> beepbeep_: If it's your first day playing with Haskell, you're going to need to find some place to explain how type classes work.
14:10:36 <EvanR> beepbeep_: null used to have the type [a] -> Bool
14:10:58 <EvanR> and it still does, but with t = [ ]
14:11:05 <EvanR> its been generalized
14:12:12 <beepbeep_> EvanR, hmz okay, I don't really understand that.. I guess I'll learn about those Foldable things later :)
14:12:38 <EvanR> yeah, when you see Foldable t, just replace t with [_] in your head
14:13:07 <EvanR> t a -----> [a]
14:14:07 <fizbin> > (null [1], null [], null (Just 5), null Nothing)
14:14:09 <lambdabot>  (False,True,False,True)
14:14:54 <EvanR> null NULL, null 0, null FALSE, null NaN
14:15:03 <EvanR> joking
14:15:32 <bennofs> Hmm. I'm compiling the Cabal library and my CPU is staying at <30% use ... seems like GHC is not actually CPU-bounds
14:16:18 <monochrom> also depends on how many cores
14:16:41 <monochrom> CPU-bound + 10 cores = 10% CPU
14:17:28 <EvanR> so hes got 3 cores
14:17:49 <bennofs> monochrom: yeah ok I have 2 cores with Hyper threading, but it seems like cabal does parallise the compile (GHC 7.10)
14:17:52 <mniip> 3.33 cores
14:18:03 <monochrom> or 4 cores in which 1 core is fully building Cabal and 1 core is playing a youtube video
14:18:13 <johnw> monochrom: yeah
14:18:20 <absence> how can i undo a @let import on lambdabot?
14:18:32 <bennofs> absence: @undef
14:18:37 <monochrom> for some purposes 2 HT cores may count as 4 cores
14:18:41 <bennofs> absence: but that undoes everything
14:19:07 * hackagebot webdriver 0.8.0.2 - a Haskell client for the Selenium WebDriver protocol  https://hackage.haskell.org/package/webdriver-0.8.0.2 (AdamCurtis)
14:19:13 <absence> bennofs: better than nothing, thanks
14:20:02 <monochrom> AFAIK cabal's parallelizing is only as coarse as "let me run 5 GHC instances to build 5 independent packages"
14:20:23 <bennofs> monochrom: no, it's not. With GHC 7.10 at least, ghc has -j itself for --make
14:20:33 <bennofs> monochrom: also, I saw 4 GHC processes at least :)
14:20:45 <monochrom> alright
14:23:44 <beepbeep_> fizbin, null Nothing results in a type error in Hugs.
14:23:59 <beepbeep_> (null Nothing)
14:24:07 <Joann8670> EvanR: do you mean you are joking about "just replace t with [_] in your head" ?  Because I'm new to haskell and I still do that with Functor-like typeclasses...
14:24:07 * hackagebot qt 1.1.6 - Qt bindings  https://hackage.haskell.org/package/qt-1.1.6 (IvanPerez)
14:24:37 <bennofs> wow, qt bindings? /me checks
14:24:48 <fizbin> beepbeep_: Yes, because Hugs has the [ ]-specific version of "null".
14:25:12 <beepbeep_> fizbin, what does that mean?
14:25:49 <fizbin> beepbeep_: It means that in Hugs, the type of null is [a] -> Bool
14:26:07 <beepbeep_> okay
14:26:08 <fizbin> So, in Hugs, you can pass lists to "null", but that's it.
14:26:15 <beepbeep_> aha okay
14:26:20 <beepbeep_> ok totally confused
14:26:33 <beepbeep_> I did :type null and that's the type annotation it gave me.
14:26:39 <beepbeep_> then I hoogled it, and hoogle also gave me that one
14:26:46 <fizbin> But in modern ghc, or ghci, you can also pass other things that are Foldable.
14:26:46 <beepbeep_> but that seems like a bug
14:26:51 <beepbeep_> hox do I fix that?
14:27:12 <fizbin> Hoogle should give you as the type: Foldable t => t a -> Bool
14:27:20 <beepbeep_> null :: [a] -> Bool
14:27:24 <beepbeep_> c/p from hoogle
14:27:26 <monochrom> "null Nothing" is meant to be a type error.
14:27:48 <fizbin> > null Nothing
14:27:50 <lambdabot>  True
14:28:06 <monochrom> ok, I am outdated on the generality of null
14:28:18 <monochrom> but Hugs is more outdated than me.
14:28:36 <fizbin> monochrom: lambdabot here uses the Data.Foldable version of null.
14:28:42 <bennofs> monochrom: basically every list operation is defined on Foldable now
14:28:44 <monochrom> hoogle may or may not be up to date. this is a fairly recent change
14:28:50 <bennofs> > length (Just ())
14:28:52 <lambdabot>  1
14:29:28 <monochrom> > length (Left ())
14:29:29 <lambdabot>  0
14:30:20 <absence> and everyone's favourite:
14:30:25 <absence> > length (1,2)
14:30:28 <lambdabot>  1
14:30:44 <monochrom> :D
14:32:00 <phaazon> aaaaah I hate that linear depends on lens!
14:32:19 <fizbin> > toList (4,5)
14:32:20 <lambdabot>      Ambiguous occurrence ‘toList’
14:32:20 <lambdabot>      It could refer to either ‘Lambdabot.Plugin.Haskell.Eval.Trusted.toList’,
14:32:20 <lambdabot>                               imported from ‘Lambdabot.Plugin.Haskell.Eval.Tr...
14:32:29 <bennofs> > Data.Foldable.toList (4,5,6)
14:32:30 <lambdabot>      Could not deduce (Foldable ((,,) t0 t1))
14:32:31 <lambdabot>        arising from a use of ‘Data.Foldable.toList’
14:32:31 <lambdabot>      from the context (Num a)
14:32:33 <bennofs> > Data.Foldable.toList (4,6)
14:32:34 <lambdabot>  [6]
14:32:40 <bennofs> oh, no Foldable for (,,) a b ?
14:34:02 <fizbin> bennofs: What would the foldable for (,,) a b look like?
14:34:18 <bennofs> fizbin: toList (_, _, x) = x
14:34:31 <bennofs> fizbin: foldMap f (_, _, x) = f x
14:34:37 <Nux__> Does someone here have experience using SDL2 with haskell?
14:34:37 <bennofs> fizbin: only possible instance
14:35:53 <monochrom> wait, toList (_, _, x) = x? [x]?
14:36:04 <bennofs> monochrom: eh, right, [x]
14:36:34 <phaazon> btw
14:36:50 <phaazon> is it possible to reverse that with TypeSynonymInstances?
14:36:56 <phaazon> type P2 a b = (b,a)
14:37:02 <phaazon> instance Foldable (P2 a) where…
14:37:05 <quicksilver> no
14:37:14 <phaazon> quicksilver: it would result in the same instance?
14:37:19 <quicksilver> you can't partially apply a type synonym
14:37:28 <phaazon> right
14:37:30 <quicksilver> and yes the type checker wouldn't be able to tell them apart, even if you could
14:37:38 <quicksilver> has to be a newtype
14:37:38 <phaazon> then, newtype
14:37:40 <phaazon> yep
14:37:45 <phaazon> thanks for the hint
14:38:06 <joe9> http://codepad.org/cArcj5AI is my source and I am receiving this error:  http://codepad.org/JEEdwI7L
14:38:29 <joe9> Any suggestions on what I couldl be missing please? I reinstall cabal and all the packages and seem to be missing something.
14:44:36 <anelson-> hey guys, my program in haskell exited with just a <<loop>> message. What does that mean? I definitely never explicitly programmed that behavior...
14:44:58 <dmj`> anelson-: lpaste.net that ish :P
14:45:13 <anelson-> dmj`: there really isn't anything to lpaste...
14:45:16 <hexagoxel> joe9: that seems to be a type error in the TH expansion of your own code, nothing to do with other packages..
14:45:27 <anelson-> it just says `nixfromnpm: <<loop>>` and returns exit status 1
14:45:35 <dmj`> anelson-: let loop = loop in loop -- <<loop>>
14:45:52 <dmj`> anelson-: some recursion isn't terminating, maybe a missed base case
14:46:17 <anelson-> blergh
14:46:19 <anelson-> ok
14:46:31 <anelson-> thanks for the stack trace haskell...
14:46:35 <anelson-> :P
14:46:55 <joe9> hexagoxel: Thanks for the response. But, my code is really small and I do not see anything in that that could be wrong.
14:47:46 <glguy> joe9: It looks like a bug in aeson
14:48:15 <hexagoxel> anelson-: enable profiling, then +RTS -xc for stack trace
14:48:22 <dmj`> anelson-: ghc gives stack traces now
14:48:31 <bitemyapp> glguy: 0.10 has been a bit rough.
14:48:45 <anelson-> hexagozel: is that an argument to cabal build, or where would I enable that
14:49:11 <joe9> glguy: yes, it appears that way. Thanks.
14:50:04 <hexagoxel> anelson-: RTS stands RunTimeSystem; you pass it to the executable. you need -rtsopts ghc option when compiling. profiling is enabled with cabal on configuring `--enable-profiling`.
14:51:36 <anelson-> hexagoxel: is there a way to do all of that just by editing the cabal file, or would I need to add some scripting around cabal configure/build to get it to work?
14:51:57 <dmj`> anelson-: you can have seperate executable sections that build the same code just with different flags
14:52:10 <dmj`> or maybe..
14:52:10 <dmj`> ghc -rtsopts -threaded Main.hs -o main && ./main +RTS -xs 
14:52:17 <dmj`> -xc*
14:52:36 <anelson-> dmj`: what would I need to modify in the executable section to add those flags
14:54:03 <dmj`> anelson-: in an executable section have a line for ghc-options:
14:54:10 <dmj`>  ghc-options: -Wall -rtsopts -threaded -funbox-strict-fields -O2
14:54:13 <UncleAlf> what line length do you generally use for haskell?
14:55:28 <dmj`> anelson-: for profiling might need, -prof -fprof-auto
14:55:47 <lpaste> neals pasted “No title” at http://lpaste.net/5495253669882363904
14:56:21 <c_wraith> UncleAlf: if I go over 80, I'd better have some sort of extenuating circumstances 
14:56:31 <hexagoxel> UncleAlf: i use 80, only few exceptions.
14:56:36 <anelson-> dmj`: thanks
14:57:10 <monochrom> -O2 is better off not specified by ghc-options, but instead by http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#O2
14:57:35 <dmj`> anelson-: ofc
14:57:46 <neals> Hi folks, I'm learning haskell and thought it would be a fun project to write a program that converts DNA bases into codons.  What I have works, but is a lot of copy-pasta, so I'm wondering if there's a more haskell way to do it?
14:57:51 <neals> my code's at http://lpaste.net/5495253669882363904
14:57:56 <UncleAlf> c_wraith hexagoxel ok, is there some sort of guideline for how to break up what would be long lines?
14:58:08 <monochrom> -Wall is also a very personal preference and it's immoral to hijack everyone's question to sneak it in the answer
14:59:58 <monochrom> -threaded can be more desirable or less desirable depending on the actual program.
15:00:58 <monochrom> overall the answer "-Wall -rtsopts -threaded -funbox-strict-fields -O2" is an immoral mix of 20% answering the question and 80% of hijacking the opportunity to advocate some personal agenda
15:01:14 <drostie> @neals yeah there are probably better ways to do that, like separating out the match-3 logic from the looking-up-bases-into-letters logic.
15:01:15 <lambdabot> one prollem. T broke confines of the visual basic langage and would not compile
15:01:15 <bennofs> monochrom: Well, if I have a project, I put -Wall in my cabal file because I expect every contributor to follow my no-warnings policy
15:01:21 <joe9> glguy, I opened an issue with aeson. https://github.com/bos/aeson/issues/305 any suggestions on if there is anything I can do to get the program running for now.
15:02:22 <bennofs> monochrom: I think -Wall is quite ok. It's really a per-project policy IMO, so it should be in the cabal file. -O2 on the other hand is more personal and except in rare cases (like packages especially tuned for high performance) should not be in the cabal file
15:02:28 <monochrom> yes, but that is a conscious choice in the context of choosing a project policy, not in the context of "how do I turn on profiling?"
15:02:30 <dmj`> joe9: this is the .:? issue right?
15:02:44 <drostie> @neals so split3 ls = case ls of x:y:z:rest -> [x,y,z]: split3 rest; [] -> []; _ -> error "Length must be a multiple of 3."
15:02:44 <lambdabot>  what have you been smoking? you narrow minded Haskell user?
15:03:05 <drostie> I'm triggering lambdabot, whoops.
15:03:16 <joe9> dmj`: I do not know about the .;? . Is it related to deriveJSON on Maybe fields?
15:03:21 <hsyl20> hi. Is there a function that does: MonadPlus m => Maybe a -> m a ? Hoogle cannot find any
15:03:59 <c_wraith> :t maybe mzero return
15:04:00 <lambdabot> MonadPlus m => Maybe a -> m a
15:04:11 <bennofs> :t msum
15:04:13 <lambdabot> (Foldable t, MonadPlus m) => t (m a) -> m a
15:04:31 <bennofs> :t Data.Foldable.msum
15:04:32 <lambdabot> (Foldable t, MonadPlus m) => t (m a) -> m a
15:04:49 <drostie> neals: then you can map a lookup over those things.
15:04:54 <bennofs> oh no, that's not it :/
15:05:01 <neals> drostie: that's a better way to handle the splitting of bases into triplets
15:05:11 <neals> drostie: yeah that's more what I was wondering about
15:05:18 <dmj`> joe9: I assume so, previously .:? had the same behavior on fields that didn't exist and null types... now .:? is explicitly for null types only, and errors on non existant fields
15:05:31 <neals> drostie: how would you do such a thing as mapping a lookup?
15:05:38 <hsyl20> c_wraith: thanks.
15:06:39 <roconnor> Anyone have Foldable instances that are not a Functor?
15:06:57 <joe9> dmj: it is erroring on a field :    , name :: Maybe String, source http://codepad.org/yJzwtWaV
15:07:01 <bennofs> roconnor: Data.Set
15:07:02 <drostie> neals: map (flip lookup [("ATT", "Z"), ("ATC", "Z")]) ["ATC", "ATC", "ATT"]
15:07:21 <dmj`> joe9: I think a way around it is the following, fmap join (o .:? "val")
15:07:25 <drostie> flip :: (x -> y -> z) -> y -> x -> z
15:07:35 <drostie> neals: ^
15:07:48 <roconnor> ;_;
15:07:50 <joe9> dmj, but, I am not using .;?. I am calling deriveJSON
15:07:53 <drostie> anywho, gotta go.
15:08:27 <monochrom> there is a meta-level immorality. by suggesting a slew of options (of which 80% are irrelevant to the question) without explaining what they stand for, and what their pros and cons are so the reader can decide for themselves, you perpertuate the bad status quo of programming as a rule-of-thumb do-not-think just-believe-me black art
15:10:50 <hexagoxel> well none of us explained why profiling is necessary to get a stack trace.
15:10:55 <hexagoxel> black art!
15:11:25 <hexagoxel> monochrom: you seem to be rather negative there (although not wrong).
15:11:30 <monochrom> but at least it directly answers the question
15:11:44 <monochrom> -Wall does not even answer the question
15:12:06 <bennofs> hexagoxel: here's why: the "stack trace" that you get is in fact a "cost centre stack", which is only kept when you enable profiling
15:12:27 <hexagoxel> bennofs: i was not asking :)
15:12:39 <bennofs> hexagoxel: ah, it sounded like you wanted to know :o
15:13:02 <hexagoxel> anelson-: ^ in case you are interested
15:13:10 <hexagoxel> bennofs: yeah, sorry, was unclear.
15:13:17 <monochrom> hexagoxel: there cannot be a positive way to state what I stated. I was precisely stating a subtraction, not an addition.
15:13:40 <monochrom> there is no positive way to say "exclude irrelevant information"
15:14:14 <monochrom> in constrast, including irrelevant information is an addition and therefore always seen in the misguided "positive" light
15:14:19 <bennofs> monochrom: include less irrelevant information, but that is just a contradiction :p
15:14:32 <monochrom> which is exactly what plagues most wikis
15:15:18 <hexagoxel> monochrom: i was not arguing content, but form.
15:15:32 <dmj`> joe9: deriveJSON might be using it, otherwise no idea
15:15:46 <monochrom> yes, I am precisely saying there cannot be a positive form for this content.
15:16:54 <reactormonk> Which function to expand ~/foo to $HOME/foo ?
15:17:15 <joe9> dmj, line 963 of https://github.com/bos/aeson/blob/master/Data/Aeson/TH.hs is using that.
15:17:47 <davean> monochrom: I read it as he was giving an example of such a line
15:18:33 <hexagoxel> monochrom: "immorality" just seems a rather strong phrase for something that was bad/confusing advice at best.
15:19:41 <dmj`> joe9: it's using it correctly (fmap join (o .:? key)), so it must be something else
15:19:50 <hexagoxel> monochrom: in that sense, there certainly is a "less negative form"
15:24:06 <indiagreen> reactormonk: you can use getHomeDirectory and then detect the tilde and expand it by yourself
15:24:10 * hackagebot luminance 0.4 - Type-safe, dependently-typed and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.4 (DimitriSabadie)
15:24:12 * hackagebot luminance-samples 0.4 - Luminance samples  https://hackage.haskell.org/package/luminance-samples-0.4 (DimitriSabadie)
15:24:14 * hackagebot atto-lisp 0.2.2.1 - Efficient parsing and serialisation of S-Expressions.  https://hackage.haskell.org/package/atto-lisp-0.2.2.1 (ThomasSchilling)
15:24:54 <indiagreen> reactormonk: if you need this to execute a command, you can use ‘shell’ which would do that: http://hackage.haskell.org/package/process-1.3.0.0/docs/System-Process.html#v:shell
15:25:26 <monochrom> does getHomeDirectory give you ~ ever?
15:25:53 <monochrom> oh, nevermind, that's not what you mean
15:26:32 <ideuler> @pl join l1 l2 = concat (zipWith zip l1 l2)
15:26:33 <lambdabot> join = (join .) . zipWith zip
15:28:07 <monochrom> @pl j l1 l2 = concat (zipWith zip l1 l2)
15:28:07 <lambdabot> j = (join .) . zipWith zip
15:29:10 * hackagebot monoid-absorbing 0.1.0.1 - A library for (left, right) zero monoids and backtracking with cut  https://hackage.haskell.org/package/monoid-absorbing-0.1.0.1 (maciejpirog)
15:29:26 <phaazon> dammit
15:29:35 <phaazon> what is that monoid-absorbing thing :D
15:30:22 <mniip> "A library for (left, right) zero monoids"
15:30:27 <mniip> it says that on the tin
15:30:38 <phaazon> yeah, I just thougth it was redundant.
15:30:55 <phaazon> https://hackage.haskell.org/package/zero
15:31:03 <phaazon> mniip: ^
15:31:26 <mniip> that's the neutral element
15:31:31 <phaazon> nope
15:31:35 <phaazon> that’s the absorbing element
15:31:40 <phaazon> the neutral element is mempty
15:31:48 <mniip> oh
15:31:49 <mniip> true
15:33:23 <monochrom> integer multiplication gives you an example of 0*x = 0
15:34:10 <phaazon> yep
15:34:16 <phaazon> I added the Zero instance for Product
15:34:18 <jophish> Why doesn't Fractional have a default definition for fromRational.   fromRational n = fromInteger (numerator n) / fromInteger (denominator n)
15:35:30 <jophish> And why aren't MINIMAL pragmas autogenerated?
15:36:02 <phaazon> jophish: by default, everything is required
15:36:17 <phaazon> unless you specify default implementation
15:36:29 <jophish> I think generatng MINIMAL pragmas might be undecidable 
15:36:40 <monochrom> I don't know how to answer the first question. the second question is probably just economics aka no one has enough incentive to do it yet
15:38:10 <jophish> I think one could come up with mutually recursive functions which don't need either of them to be overloaded
15:38:43 <jophish> and from that, one could create those functions, and their validity could be dependent on weather an algorithm terminates
15:39:14 <mniip> that reminds me of a particular unsolvable problem whose name begins with h
15:39:29 <jophish> the *hard* problem
15:39:43 <phaazon> the hiccups problem
15:40:04 <jophish> what's a sensible place to suggest that definiton for fromRational?
15:40:23 <mniip> a GHC trac ticket?
15:40:24 <monochrom> the "libraries" mailing list. something like "libraries@haskell.org".
15:40:41 <monochrom> but probably requires subscription to post
15:41:04 <frerich> I think Haskell truly became mainstream because I just pasted something at pastebin.com (unrelated to Haskell) and then, out of boredom, clicked a recent random paste - and got http://pastebin.com/G8MWeYtr
15:41:46 <reactormonk> indiagreen, neat, thanks.
15:45:11 <eriksensei> frerich: my god, and it's all reactive and everything!
15:45:28 <dmj`> nothing says mainstream like a function names 'reactimate'
15:45:37 <dmj`> s/names/named
15:48:43 <eriksensei> all we need now is http://haskell.io
15:49:19 <ttt_fff> what am I doing wrong at https://gist.github.com/anonymous/c29664ce0d3875e5fd79#file-snap-hs-L35 ?
15:49:40 <ideuler> In joinLists = (concat .) . (zipWith zip) , I don't quite understand the need for 2 '.' , is it a way to not apply the point-free arguments in concat? The goal was just to concat after the results of zipWith , ence why I'd post at first though: joinLists = concat . (zipWith zip)
15:49:44 * indiagreen waves to ttt_fff 
15:49:51 <lispy> Nux: did you message me?
15:50:18 <ttt_fff> "Pattern syntax in expression context: row@(id, txt)" https://gist.github.com/anonymous/c29664ce0d3875e5fd79#file-snap-hs-L35 <-- what am I doing wrong?
15:50:38 <Nux> lispy, yep but now I'm going to bed :) thanks anyway
15:50:49 <lispy> Nux: cool
15:50:53 <glguy> ttt_fff: you probably meant for the first -< to be a <-
15:51:10 <ttt_fff> glguy: I'm an idiot; thanks!
15:51:33 <ttt_fff> indiagreen: how are you?
15:51:53 <indiagreen> annoyed that glguy beat me
15:52:29 <ttt_fff> indiagreen: if you buy me chocolates, I'll forigve you
15:52:42 <ttt_fff> steak_+frices would work too
15:53:15 <ttt_fff> indiagreen: how do you know about arrows?
15:54:51 <indiagreen> ttt_fff: I'm broke at the moment but the next time I'll definitely buy you chocolates
15:55:02 <indiagreen> ttt_fff: I have approximate knowledge of many things
15:56:16 <ttt_fff> https://gist.github.com/anonymous/d0c801e11b70db3e8624#file-snap-hs-L37 gives errors https://gist.github.com/anonymous/3278003735af0a79e7e3 ... why? (I'm just copying https://github.com/tomjaguarpaw/haskell-opaleye/blob/master/Doc/Tutorial/TutorialBasic.lhs#L254-L259 )
15:56:21 <ttt_fff> glguy , indiagreen: ^ :-)
15:56:37 <indiagreen> maybe returnA?
15:57:54 <gryph> what are most people actually using haskell for?
15:58:01 <ttt_fff> i;'m an idiot :-)
15:58:03 <ttt_fff> indiagreen: thanks
15:58:19 <gryph> what type of production apps are common...i know you can do web stuff with yesod. but what's the normal use case for most of you 
15:58:43 <johnw> gryph: I use it for everything
15:59:06 <johnw> today I use it to parse a series of DOT files, knit together the graphs they represent, and then output the information in a minimal format
15:59:18 <ttt_fff> I use it to debug my thinking. Why I'm not sure I understand something, I swtart out twriting the data types and don't stop unti GHC stops complaining.
15:59:30 <dmj`> gryph: it's a general purpose language, it can do many things normally
15:59:31 <johnw> to do that I mainly used the graphviz and fgl library, and lens to provide a good interface
15:59:35 <gryph> johnw: so was that work related, or just a personal project
15:59:40 <johnw> work related
15:59:55 <gryph> because alot of languages are associated with a specific use case. like python is great for web and science
16:00:04 <gryph> ruby essentially = rails these days lol
16:00:15 <newsham> i wouldnt say that python is great for web :(
16:00:20 <newsham> (i wish it was)
16:00:24 <gryph> well django isn't that bad
16:00:26 <johnw> I only reach for a different language if (a) the project requires it, or (b) I need features it can't provide, like fully dependent types
16:00:56 <gryph> the global interpreter lock is definitely bad =/
16:01:27 <gryph> so theres no one dominant use case.. people are basically using it for everything
16:01:40 <johnw> pretty much
16:01:53 <johnw> it's dominant use case is not being other things :)
16:01:54 <newsham> perhaps this can help answer your question https://wiki.haskell.org/Haskell_in_industry
16:02:14 <pikajude> i wouldn't say python really feels like a mature "enterprise"-level language
16:02:18 <pikajude> especially after having used django
16:02:39 <dmj`> gryph: https://github.com/Gabriel439/post-rfc/blob/master/sotu.md
16:02:42 <gryph> newsham: thx very nice link :)
16:04:11 <gryph> wow haskell is used to compile elm to js...didn't know that
16:04:24 <gryph> are functional languages better for compilers?
16:04:40 <johnw> gryph: it's going to be very hard to come up with general rules about what haskell is and isn't good for
16:04:46 <newsham> high level languages are good for writing compilers
16:04:58 <johnw> C is a terrible language for compilers, that is also a great language for compiler
16:05:05 <johnw> s
16:05:06 <newsham> and people who do prog lang theory tend to have affinity for languages like ocaml and haskell with "interesting" features
16:05:39 <johnw> gryph: haskell does especially excel at DSLs
16:05:46 <johnw> I think it might do that better than anything else
16:05:46 <monochrom> I teach some courses with Java programming assignments. but I solve them in Haskell, so that I have a high-confidence, low-effort way to get and compare test outputs.
16:05:56 <int-index> How do I solve this kind of space leak? http://lpaste.net/6879754158912569344
16:06:13 <gryph> yea im interested in weird languages
16:06:27 <johnw> int-index: how do you know that's a space leak?
16:06:27 <ttt_fff> how do I convert " Data.ByteString.Internal.ByteString " into an Int (by reading it as an Int, not by length)
16:06:28 <gryph> learning elixir at the moment
16:06:58 <johnw> int-index: I can't see why they're be any leak at all
16:06:58 <newsham> did you just call us 'weird' ;-)
16:07:17 <dmj`> ttt_fff: readInt
16:07:25 <int-index> johnw: well, each new version of a function references the previous version, so they pile up
16:07:40 <int-index> the function is actually stored in a data structure
16:07:56 <gryph> yes, the cool weird :)
16:07:58 <johnw> int-index: then your example is not the real question?
16:08:12 <johnw> int-index: come to be with real code, and a heap profile, and then we can talk
16:08:28 <monochrom> ttt_fff: readInt and readInteger are in Data.ByteString.Char8
16:09:11 * hackagebot opengl-dlp-stereo 0.1.2.5 - Library and example for using DLP stereo in OpenGL  https://hackage.haskell.org/package/opengl-dlp-stereo-0.1.2.5 (BrianBush)
16:09:20 <int-index> johnw: ok, I thought minimal examples are easier to work with
16:09:34 <johnw> well, it sounds like you're hypothesizing a space leak, and showing me your hypothesis on the part of the problem that would cause it
16:09:38 <johnw> I can't really do anything with that
16:09:59 <monochrom> int-index: yes, if you pile up, you consume both O(n) time and O(n) space. I wouldn't call this a leak; this is an obvious inefficiency.
16:10:03 <johnw> minimal examples are only easier if they can standalone
16:10:17 <ttt_fff> dmj` , monochrom: noted, thanks!
16:10:36 <johnw> monochrom: what would "pile up" in this case?
16:10:55 <monochrom> except lately the word "leak" has become so broad that everything the author doesn't like is a leak
16:11:21 <johnw> I see the cost of a comparison to 42 at every call to f', but no other costs...
16:11:38 <johnw> because in the "otherwise" case, f' = f
16:11:44 <johnw> which the optimizer should resolve
16:12:28 <Welkin> but what will optimize the optimizer!?
16:12:45 <kulakowski> the superoptimizer
16:12:46 <Welkin> which reminds me
16:12:47 <newsham> the superoptimizer
16:12:52 <Welkin> what compiles the compiler?
16:13:08 <Welkin> where is compiler zero?
16:13:12 <Walther> Welkin: bootstrapping
16:13:13 <thimoteus> what's the closest possible smiley operator? so far i've managed to define <-: and >-: but they're not very convincing as smileys
16:13:16 <newsham> ever bootstrap a new code generator?
16:13:21 <newsham> its an interesting process
16:13:26 <arkeet> <:
16:13:30 <newsham> where you start with other tools and ween yourself off of them
16:13:33 <arkeet> or :> if you want a constructor
16:13:46 <arkeet> you could also do :/ /:
16:13:50 <thimoteus> oooh
16:13:51 <arkeet> etc
16:14:09 <thimoteus> awesome, now i just need to find a place to define them
16:14:12 * hackagebot b9 0.5.14 - A tool and library for building virtual machine images.  https://hackage.haskell.org/package/b9-0.5.14 (SvenHeyll)
16:14:57 <johnw> <~:
16:15:22 <pikajude> emoticonoroperator.org
16:15:40 <dmj`> :~>
16:16:25 <johnw> that's only a type operator...
16:16:33 <johnw> or constructor?
16:17:34 <monochrom> johnw, there is a comment about "do this a million times", so imagine f' n = if n==1 then 0 else f n; f'' n = if n==2 then 0 else f' n; f''' n = if n==3 then 0 else f'' n; ...; f''''...''' n = if n==1000000 then 0 else f'''...'' n
16:18:31 <monochrom> ok, if you literally write that million lines of code in a file statically, I don't know what will happen to the poor compiler
16:18:47 <monochrom> but suppose you write a 3-line loop that generates a list of those functions
16:18:53 <frerich> Is anybody here familiar with Hamlet (AKA Shakespeare) templates? I'm passing a [[Int]] from Haskell to the template and would like to loop over one of the [Int] values depending on a JavaScript variable, i.e. something like 'function f(x) { $forall e <- values !! x }'. Does anybody know how to do that?
16:19:32 <monochrom> oh, I know what will happen to the poor compiler. my identifiers are too long, and the compiler simply goes on strike.
16:20:02 <int-index> johnw: http://lpaste.net/3824233692037906432
16:20:13 <int-index> This code gets killed on my machine because it consumes too much memory
16:20:30 <ttt_fff> tomjaguarpaw: what needs to be done to make opaleye-sqlite production ready?
16:20:37 <int-index> those `succ`s pile up
16:20:43 <ttt_fff> tomjaguarpaw: I like it quite a lot (mainly because I don't like managing postgresql insallations)
16:29:37 <monochrom> int-index: if you say, the paste is already literally the real algorithm, then we can simply replace a large chunk of it by just "let f = (100000000 +)" and it will be fast and short and sweet. but suppose no, your actual real algorithm is something else...
16:31:19 <monochrom> say, your real algorithm is "start with the empty function. for a hundred million times: read a number, replace the function by "\n -> if n == the read number then x else (the previous function) n". then you are better off with a Map from Data.Map
16:32:13 <int-index> monochrom: right, Data.Map would suit me perfectly, except it doesn't guarantee that every possible key is present, and I need that in my case
16:32:20 <monochrom> programming has always been "find a better algorithm and data structure than brute-forcing"
16:32:57 <int-index> also Data.Map can't be dependent (I use singletons to get something resembling pi-types)
16:32:59 <monochrom> ok, but you can add one last wrapper that handles key-not-found keys
16:33:59 <monochrom> ok, that's too advanced for Haskell, unless you settle with Dynamic and Typeable, which doesn't give as much static guarantee as you like
16:34:31 <int-index> I see, thanks
16:42:29 <int-index> monochrom: ok, I think I have a solution
16:42:37 <int-index> use *both* a map and a function
16:42:55 <int-index> override values in the map, and fallback to the function if the key is not present
16:43:01 <int-index> it gives the necessary guarantees
16:43:27 <int-index> as for dependent types, it's just a matter of enough hasochism to promote Ord-instances
16:43:40 <int-index> there's the dependent-map package
16:43:59 <px_> I'm having trouble with installing libraries on El Capitan, can someone help?
16:44:13 * hackagebot Deadpan-DDP 0.9.4.0 - Write clients for Meteor's DDP Protocol  https://hackage.haskell.org/package/Deadpan-DDP-0.9.4.0 (LyndonMaydwell)
16:44:15 * hackagebot qt 1.1.6.1 - Qt bindings  https://hackage.haskell.org/package/qt-1.1.6.1 (IvanPerez)
17:28:07 <tobiasBora> Is it possible to "kill" a mapM_ when I found something interesting ?
17:29:26 <Clint> tobiasBora: like using EitherR?
17:30:29 --- mode: leguin.freenode.net set +o ChanServ
17:30:56 <tobiasBora> Clint: I cannot fint EitherR in hoogle
17:31:35 <Clint> tobiasBora: https://hackage.haskell.org/package/errors-2.0.1/docs/Data-EitherR.html
17:34:30 <SoCool> Is freenode done spamming yet?
17:35:38 <hodapp> Never.
17:36:13 <Joann8670> what's the best way to find something like EitherR?  Just the other day I wrote my own splitOn :: Char -> String -> [String] because hoogle didn't look in Data.List.Split
17:36:18 <bitemyapp> SoCool: it's like weather. It just happens.
17:36:41 <SoCool> So. Back to what I came here for. Anybody wish to help me understand the cont monad? I continually think it should do what the functor over (-> a) does, but that's of course wrong
17:37:23 <SoCool> What's it's *purpose* ? What should I expect when I have a function and I start binding more functions to it in a Cont?
17:38:13 <tobiasBora> Clint: It's based on exceptions ? I learnt that exceptions should not be used in "pure" code so I don't know if it's exactly what I need. I fact I'm doing a mini-game (plus or minus), which stops when the user get the right number, but I don't know how to stop. Here is my actual code : http://pastebin.com/TxSNfRZA. Can you confirm it's EitherR the best solution ?
17:38:21 <SoCool> I've read about it a variety of times, just going off the type signature of bind it has an obvious derivation which I can even derive myself, but I can't figure out what use it would provide mearnsh
17:38:29 <SoCool> ...stupid emacs autocomplete. s/mearnsh/me/f
17:39:05 <MarcelineVQ> dude
17:39:18 <MarcelineVQ> Mearnsh actually sounds like a really cool new word
17:39:47 <SoCool> just the name of somebody in the room, thanks global company-mode
17:39:48 <Clint> tobiasBora: well, no, if you want to do it in IO you should use ExceptRT
17:39:48 <MarcelineVQ> mearnsh, props bro
17:40:18 <nshepperd_> SoCool: Cont r a is (a -> r) -> r, right?
17:41:37 <nshepperd_> which can sort of be treated like it contains an 'a'
17:41:46 <SoCool> nshepperd_: see this is what screws me up about it, if I think of `Cont` as `->` I can make sense of it, but when the monads have type aliases that are used more often than the plain data type i have a harder time
17:42:55 <SoCool> when I think of `Cont` as `->` and the monad is over `Cont r` it's like a monad over `(-> r)`, and the implementation is naturally obvious from the types
17:43:04 <johnw>  SoCool: but Cont isn't `->`
17:43:21 <SoCool> johnw: so have I been just screwing up the whole meaning?
17:43:25 <MarcelineVQ> Cont
17:43:29 <MarcelineVQ> oops
17:43:30 <nshepperd_> (-> r) isn't right though
17:43:36 <nshepperd_> it's (a -> r) -> r
17:44:36 <SoCool> so is the cont got a fixed return and a malleable input transformed through layers of functions bound on top of it where the functor (-> a) is the opposite ?
17:44:46 <shachaf> (-> r) isn't even a functor.
17:44:54 <shachaf> It may not be covariant, but it is a Cont r a variant.
17:45:09 <shachaf> Hmm, I messed that up.
17:45:14 * hackagebot first-and-last 0.1.0.1 - First and Last generalized to return up to n values  https://hackage.haskell.org/package/first-and-last-0.1.0.1 (andrus)
17:45:14 <nshepperd_> forget about (-> a)
17:46:06 <nshepperd_> '(a -> r) -> r' says "if you have an r with an a-shaped hole, I can make an r for you"
17:46:41 <nshepperd_> or "if you have a way of making an r from an a"
17:46:47 <shachaf> I think "r parameterized on a" is pretty different from "r with an a-shaped hole"
17:47:16 <nshepperd_> eh
17:47:17 <shachaf> But I shouldn't say that here now.
17:47:24 <SoCool> shachaf: yes, but his "r with an a-shaped hole" fits my intuition that it may have a fixed return and allow layering transformations on topi
17:47:47 <SoCool> is that roughly accurate? Vaguely so?
17:47:55 <tobiasBora> Clint: I'm not familiar with exception yet, but I found a good solution with a recursive function
17:48:01 <shachaf> I can't tell what it means, so I don't know whether it's accurate.
17:48:05 <SoCool> gah. I wish all monads were as easy to understand as list, either, maybe...
17:48:29 <MarcelineVQ> wow Cont looks really interesting
17:49:13 <johnw> SoCool: also think about what the two Kleisli arrows mean: a -> r -> b on the one hand, and a -> (b -> r) -> r on the other.  The former just provides a second argument, while the latter is a CPS transformation
17:50:05 <SoCool> shachaf: So if I have a function (Int -> String), I could compose on the front of it a function ([Foo] -> Int). and I could continually compose stuff onto the front but at the end of the composition would still be a String; the String is fixed in that scenario
17:50:14 * hackagebot webdriver 0.8.0.3 - a Haskell client for the Selenium WebDriver protocol  https://hackage.haskell.org/package/webdriver-0.8.0.3 (AdamCurtis)
17:50:56 <SoCool> shachaf: Does that make sense? My question is, is that type of composition similar to what binding functions together in the Cont monad is?
17:52:29 <SoCool> johnw: ok... what are the two Kleisli arrows? I think of `>=>` as kleisli and use that but not sure what "the other kleisli" arrow is?
17:52:57 <johnw> for a Monad 'm', the arrows of its Kleisli category have type a -> m b
17:53:31 <johnw> sometimes it's easier to think about how Klesli arrows compose, sometimes it's easier to think about join, when trying to build intuition for why some construction is monadic
17:54:10 <johnw> it's trivial to write join :: (r -> r -> a) -> (r -> a), for example
17:54:15 <johnw> it's not so trivial to write join for Cont
17:54:19 <SoCool> johnw: I think you have singlehandedly made me understand what an arrow is... I understand a -> m b, that I'm comfortable with conceptually
17:54:40 <arkeet> @djinn ((((a -> r) -> r) -> r) -> r) -> (a -> r) -> r
17:54:40 <lambdabot> f a b = a (\ c -> c b)
17:55:00 <johnw> arkeet: hah, count me completely wrong :)
17:55:17 <SoCool> johnw: it is and it isn't, like I said, I can comfortable derive bind just from the type signature, I did it earlier today, but afterwards I looked at it and couldn't figure out what it was actually doing
17:55:18 <arkeet> well you'd have to think about it still :-)
17:55:35 <arkeet> SoCool: indeed
17:55:41 <arkeet> fortunately you don't really have to think about it
17:56:04 <SoCool> or rather, I could see what the code did but not what the benefit would be.
17:56:27 <SoCool> it felt like it was carrying an input value into multiple functions and then joining the outputs or something which didn't make sense
17:56:51 <nshepperd_> that doesn't sound right
17:56:55 <SoCool> arkeet: Yeah, that's why I need an intuition for it.. the code is easy from the types but the purpose eludes me
17:57:01 <nshepperd_> each input in (>>=) is only used once
17:57:15 <awpr> wait, I don't think that's the type of join on unwrapped Cont.
17:57:27 <awpr> :t runCont . fmap runCont
17:57:28 <lambdabot> ContT r Identity (Cont r1 a) -> (((a -> r1) -> r1) -> r) -> r
17:57:44 <arkeet> @unmtl Cont r (Cont r a) -> Cont r a
17:57:44 <lambdabot> Cont r (Cont r a) -> Cont r a
17:57:46 <arkeet> hm.
17:57:49 <arkeet> well whatever it's that.
17:58:16 <johnw> ((((a -> r) -> r) -> r) -> r) -> (a -> r) -> r
17:58:17 <nshepperd_> SoCool: (>>=) here takes (a -> r) -> r, and a -> ((b -> r) -> r) and produces (b -> r) -> r
17:58:23 <nshepperd_> SoCool: is that what you had?
17:59:51 <SoCool> nshepperd_: perhaps I was looking at the wrong function. I was deriving based on `(->) i` which gives a natural `ma >>= f = /x -> f(ma(x))(x)` if I recall correctly
18:00:07 <johnw> SoCool: another way to think about it: every Cont "action" is parameterized on a function to be called with the value it results in; composing two such actions "carries the continuation through", so that instead of the first action calling that function, it passes the responsibility to the next action, which then calls that function
18:00:28 <nshepperd_> SoCool: (->) i isn't the cont monad
18:00:35 <SoCool> right, I may have had it all shit up.
18:00:36 <nshepperd_> SoCool: that's the reader monad
18:00:58 <SoCool> yeah. I'm a dummy. I wondered why it felt like it was carrying a value around which is what I thought the reader should do
18:01:28 <johnw> a -> Cont r b takes an 'a' to an action that, given a function from b to r, results in an r.  This is just codifying a CPS transformation
18:01:38 <johnw> composing it with a b -> Cont r c is when things get interesting
18:02:08 <johnw> because the "something" here is another Cont action, and we don't want that.  We need to compose the CPS-nature so that at the end, we only need to give it a function from 'c' to something
18:02:30 <johnw> thus, a -> Cont r b and b -> Cont r c can become a -> Cont r c
18:02:40 <johnw> this ability is what makes it monadic
18:02:47 <johnw> otherwise, you can think about Cont without thinking about monads at all
18:03:57 <MarcelineVQ> johnw: is the link from Control.Monad.Trans.Cont, http://okmij.org/ftp/continuations/#tutorial , a good source to learn about using it?
18:04:14 <MarcelineVQ> I guess a better question is, do you know of a better source?
18:04:22 <johnw> personally I don't think that's a great place to start
18:04:37 <johnw> I wrote https://www.fpcomplete.com/user/jwiegley/understanding-continuations
18:04:43 <SoCool> right, that makes perfect sense...
18:04:46 <johnw> can't say that's the best tutorial though
18:05:03 <johnw> a lot of people really like http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
18:05:26 <MarcelineVQ> Thank you
18:05:33 <johnw> in fact, reddit thinks what I wrote is a terrible introduction, so probably skip it
18:05:50 <SoCool> johnw: So given an a -> Cont r c, given an a, we'll get a `(c -> r)` ?
18:05:57 <MarcelineVQ> As a general rulde I don't usually believe reddit :>
18:06:00 <MarcelineVQ> rule
18:06:07 <johnw> SoCool: you'll get something that wants a (c -> r)
18:06:17 <johnw> that way, you get the 'c', and you return an 'r'
18:06:25 <johnw> rather than the 'c' being returned as a function
18:06:29 <johnw> it is presented to the "continuation function"
18:06:42 <platz> I expected monad-coroutine to use Cont but it doesn't... maybe it kind of rolls it's own cont
18:06:45 <johnw> have to run now, good luck!
18:07:07 <johnw> s/being returned as a function/being return as a value/
18:07:57 <SoCool> johnw: Ok, so if I pull out the confusing Cont part, you just said (a -> (b -> r) -> r) and (b -> (c -> r) -> r) can give you a (a -> (c -> r) -> r)
18:09:12 <SoCool> the fact that `Cont r` must be used to do a funny flip on (->) makes it a little less straightforward but I get that it's required to keep the type system sane
18:09:47 <arkeet> btw
18:09:56 <arkeet> it may help to rearrange stuff a bit
18:10:03 <arkeet> a -> Cont r b = a -> (b -> r) -> r
18:10:04 <arkeet> is like
18:10:06 <arkeet> (b -> r) -> (a -> r)
18:10:16 <arkeet> now it's obvious how to compose.
18:14:55 <SoCool> arkeet: it is? I'm going to have to think about that transformation for a moment.. isn't that the same as (flip (->) a -> (b -> r) -> r)
18:15:08 <SoCool> > flip (->) a
18:15:09 <lambdabot>  <hint>:1:7: parse error on input ‘->’
18:15:10 <arkeet> ??
18:15:28 <arkeet> well I mean
18:15:29 <arkeet> you can just flip
18:15:33 <arkeet> a -> (b -> r) -> r
18:15:36 <arkeet> to get (b -> r) -> a -> r
18:15:49 <SoCool> arkeet: Yeah, that's what you just referred to above more or less, no?
18:15:52 <arkeet> yes
18:16:01 <arkeet> I just mean on paper though
18:16:48 <SoCool> arkeet: I get it, it's a clear composition to say (b -> r) -> (a -> r)
18:17:15 <SoCool> understanding the transformation from flip though just helps me recognize how those are the same things
18:18:39 <SoCool> why would you want a function from b -> r to get a function from a -> r ? if you have a b -> r, why don't you just use it and get your r?
18:18:59 <SoCool> oh, because you might have an a but no b
18:20:24 <arkeet> a value of type (a -> r) -> r 
18:20:36 <arkeet> is something that tells how to answer any r-valued question about an a
18:20:53 <arkeet> or something
18:22:03 <arkeet> uh
18:22:07 <SoCool> arkeet: Right. I think this is making sense now. We'll see how well I can translate this to C# tomorrow when I get into the office..
18:22:52 <SoCool> It'll make more sense once I work with it more closely I'm sure, that's how it's always been with the monads I've used in the past, implementing and actually using them is the only way I can build a good sense of them
18:25:30 * hackagebot reflex-transformers 0.2.1 - Collections and switchable Monad transformers for Reflex  https://hackage.haskell.org/package/reflex-transformers-0.2.1 (saulzar)
18:31:21 <koshmar> hellow, I am probobly not the first to ask that, but even with google, I still can't decide... I've finished LYAH and now started RWH but it's a bit old, so I am thinking to change the book.  what would you pick after LYAH?
18:32:19 <MarcelineVQ> I'd do cis194, and/or nicta, or get haskellbook.com/
18:32:33 <MarcelineVQ> links for cis194/nicta and others: https://github.com/bitemyapp/learnhaskell 
18:33:20 <koshmar> thanks.
18:33:21 <dfeuer> koshmar, you can also read fun things in The Monad Reader.
18:33:39 <dfeuer> And various Functional Pearls.
18:33:57 <dfeuer> You know, to blow your mind and stuff.
18:34:17 <koshmar> (=
18:34:24 <MarcelineVQ> Be kind to your mind, blow it at most once daily
18:37:48 <ttt_fff> m a -> ExceptT e m a
18:37:51 <ttt_fff> how do I get a function of that type ?
18:42:25 <peddie> ttt_fff: for questions of this variety, you can use @hoogle
18:42:32 <peddie> @hoogle m a -> ExceptT e m a
18:42:33 <lambdabot> Control.Monad.Trans.Except throwE :: (Monad m) => e -> ExceptT e m a
18:42:33 <lambdabot> Control.Monad.Trans.Maybe maybeToExceptT :: (Functor m) => e -> MaybeT m a -> ExceptT e m a
18:42:50 <peddie> hm
18:43:03 <peddie> :t ExceptT
18:43:05 <lambdabot> m (Either e a) -> ExceptT e m a
18:43:29 <peddie> maybe not, sorry :)
18:44:08 <peddie> anyway, ttt_fff, what you want is 'lift' from transformers
18:44:39 <ttt_fff> peddie: https://www.haskell.org/hoogle/?hoogle=m+a+-%3E+Either+t+m+a did not work
18:45:20 <platz> :t foldl ((>>=))
18:45:22 <lambdabot> (Monad m, Foldable t) => m a -> t (a -> m a) -> m a
18:45:22 <peddie> :t lift
18:45:24 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
18:45:27 <platz> does that have a name?
18:45:31 <peddie> ttt_fff: ^^
18:45:37 <ttt_fff> yeah, loift works
18:45:42 * hackagebot reflex-animation 0.1.1 - Continuous animations support for reflex  https://hackage.haskell.org/package/reflex-animation-0.1.1 (saulzar)
18:45:56 <arkeet> :t ExceptT . fmap return
18:45:58 <lambdabot> Functor m => m a -> ExceptT e m a
18:50:43 * hackagebot reflex-animation 0.1.2 - Continuous animations support for reflex  https://hackage.haskell.org/package/reflex-animation-0.1.2 (saulzar)
18:51:51 <platz> can't seem to see what foldl ((>>)) actually encodes
18:51:53 <platz> it's not traverse
18:52:12 <platz> err foldl ((>>=))
18:52:29 <Big_G> Why the double parentheses? 
18:52:44 <platz> i guess they are not necessary, yeah
18:53:18 <Big_G> Is it still correct with them? 
18:53:33 <platz> yeah
18:54:06 <Big_G> Do parentheses convert any portrait 
18:54:16 <nshepperd_> :t foldr (>=>) return
18:54:17 <lambdabot> (Monad m, Foldable t) => t (c -> m c) -> c -> m c
18:54:36 <Big_G> Operator to a function?
18:55:17 <nshepperd_> Big_G: yeah. (>>=) is syntactically a function
18:55:23 <nshepperd_> while >>= is an operator
18:55:46 <nshepperd_> anyway, I don't think this thing has any particular name
18:55:54 <platz> interesting
18:56:05 <nshepperd_> it's just a fold, using a sort of Endo monoid
18:56:29 <Big_G> So ('elem') is a valid function? 
18:56:53 <nshepperd_> like, you're taking all the actions in the container and composing them in order
18:57:07 <nshepperd_> Big_G: you mean (`elem`)? not sure
18:57:11 <platz> seems like someone would have done that before though
18:57:26 <platz> it's close to traverse, but not quite
18:57:31 <awpr> it's kind-of mconcat if Endo were on Kleisli categories instead of Hask
18:57:32 <Big_G> Yeah. Irc on a phone is hard 
18:57:41 <pavonia> :t (`elem`)
18:57:42 <lambdabot> parse error on input ‘)’
18:57:48 <pavonia> :t (1 `elem`)
18:57:49 <lambdabot> (Eq a, Num a, Foldable t) => t a -> Bool
18:57:50 <shachaf> No, (`foo`) is unfortunately a syntax error.
18:58:41 <Big_G> But when given an argument, it works? 
18:58:54 <nolraiU> @ty bimap
18:58:55 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
18:58:56 <awpr> Big_G: with an argument it's an operator section
18:58:59 <nshepperd_> platz: it's more like sequence than traverse. traverse lets you do something to each value first
18:59:13 <nshepperd_> platz: this thing just blindly concatenates them
18:59:19 <Big_G> What is an operator section? 
18:59:28 <awpr> :t (+2)
18:59:29 <lambdabot> Num a => a -> a
18:59:33 <awpr> ^ that thing
18:59:46 <Big_G> A function? 
18:59:46 <platz> ahh yes
18:59:50 <pavonia> Big_G: A binary operator applied to one argument
19:00:18 <nshepperd_> platz: and it's more like foldMap Endo than either of those
19:00:20 <Big_G> But you have to partially apply it 
19:01:08 <pavonia> You don't have to, but you have to to get a section
19:01:32 <Big_G> I just want a Cinco
19:01:45 <Big_G> Function, not a section 
19:01:55 <pavonia> A section is a function too
19:02:04 <Big_G> Binary function 
19:02:36 <pavonia> Not sure what you mean
19:02:43 <awpr> I'm fairly certain you can have sections of unary operators too
19:02:53 <awpr> @let (!!!) x = x+2
19:02:55 <lambdabot>  Defined.
19:03:00 <awpr> :t (!!!2)
19:03:02 <lambdabot> (Num a, Num (a -> t)) => (a -> t) -> t
19:03:22 <awpr> :t (2!!!) -- right, I did it backwards
19:03:23 <lambdabot> Num a => a
19:03:58 <nshepperd_> that's a ghc extension, but yes
19:03:59 <pavonia> That's an extension, no?
19:04:21 <Big_G> How can I pass bind into a function then? 
19:04:29 <awpr> :t id (>>=)
19:04:30 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:04:54 <Big_G> I have to use id? 
19:05:07 <awpr> no, id is just the first function I thought of
19:05:31 <pavonia> (>>=) already is a function
19:05:40 <Big_G> But I couldn't just use bo
19:05:42 <Big_G> Ind
19:05:51 <Big_G> Bo
19:05:55 <Big_G> Bind? 
19:06:29 <awpr> well, its name is (>>=), so doing that *is* "just using it"
19:07:33 <Big_G> Could I pass it into a function like that? 
19:07:48 <Clint> ...
19:08:00 <awpr> I'm not sure what you're asking, if "id (>>=)" didn't answer the question
19:08:28 <glguy> Big_G: 'id (>>=)' is applying the function 'id' to '(>>=)'
19:08:51 <platz> Big_G: Putting parenthesis around an infix operator converts it into a prefix function https://wiki.haskell.org/Infix_operator
19:09:29 <Big_G> Oh, I'm an idiot.  You already answered my question 
19:11:09 * hackagebot reflex-animation 0.1.3 - Continuous animations support for reflex  https://hackage.haskell.org/package/reflex-animation-0.1.3 (saulzar)
19:11:31 <Big_G> Thanks all 
19:49:49 <elliptic00> can anyone explain to me what is mempty?
19:50:13 <elliptic00> is the identity? from Monoid definition?
19:51:11 * hackagebot markdown-unlit 0.3.0 - Literate Haskell support for Markdown  https://hackage.haskell.org/package/markdown-unlit-0.3.0 (SimonHengel)
19:52:19 <MarcelineVQ> Yes
19:52:23 <MarcelineVQ> as far as I known
19:55:43 <MarcelineVQ> similarily mappend is the binary operation of the Monoid
19:56:06 <Lokathor> so Int is 64bits by default?
19:56:18 <Lokathor> (on 64 bit machines)
19:56:19 <MarcelineVQ> If your processor is
19:56:28 <Lokathor> trippy
19:57:10 <MarcelineVQ> elliptic00: the weird names come from the list instance of Monoid http://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Base.html#line-227
19:57:34 <MarcelineVQ> you can see how mempty = [] and mappend = (++) makes sense
20:05:47 <MarcelineVQ> Lokathor: https://github.com/ghc/ghc/blob/master/includes/MachDeps.h It checks what size pointers are, I think, and uses that to determine the architecture
20:06:23 <Lokathor> having started with java, i sometimes forget that int size changes from place to place
20:08:34 <MarcelineVQ> https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Base.html#maxInt are int sizes for haskell, depending on the previous
20:11:16 * hackagebot webdriver-angular 0.1.9 - Webdriver actions to assist with testing a webpage which uses Angular.Js  https://hackage.haskell.org/package/webdriver-angular-0.1.9 (JohnLenz)
20:19:28 <montanonic> Suppose I wanted to learn to write JavaScript, but wanted to do so in the most disciplined manner possible. There is a book called Functional JavaScript that claims to teach it this way, and I was wondering if anyone here has read it or has resources they'd recommend on this topic.
20:20:40 <montanonic> I've been *very* reluctant to dive into JavaScript, but given that I'd only plan on using it for small things (html canvas, for example), the bloat of needing to deal with another language's compiler to compile-to-JS just seems unnecessary to me right now.
20:21:17 <montanonic> I just realized this is a #haskell-blah question, my bad. I'm going to repost there.
20:23:20 <ttt_fff_> is there a way in haskell to say "depend on this other package; but don't fetch this other package from ahcakge; just fetch it from ~/my-libs/foo" ?
20:24:46 <lispy> ttt_fff_: if you use a sandbox you can add-source
20:24:56 <ttt_fff_> I'm using nixos
20:25:15 <lispy> someone like johnw would know
20:25:27 <ttt_fff_> is I use cabal, but not cabal sandbox can I not use add-source?
20:25:40 <ttt_fff_> the important part is just that I have a *.cabal file around and I exec 'cabal build' right ?
20:26:05 <lispy> right, so if you don't use sandboxes you would install it into your global package db
20:26:22 <ttt_fff_> right now;  Ijust a a bunch of sym links
20:26:23 <lispy> WHich would be 'cabal install' in the directory where the .cabal file lives
20:26:26 <ttt_fff_> which I know fora  fact is not optimal
20:26:32 <ttt_fff_> every time I update my 'foo library'
20:26:35 <ttt_fff_> do I need to 
20:26:46 <ttt_fff_> do I need to cabal install again in the projects taht depend on foo-library ?
20:27:05 <lispy> I think you'd really benefit from using sandboxes
20:30:39 <ttt_fff_> lispy: I'm using nixos
20:31:17 * hackagebot markdown-unlit 0.3.1 - Literate Haskell support for Markdown  https://hackage.haskell.org/package/markdown-unlit-0.3.1 (SimonHengel)
20:32:45 <MissValeska> Hi
20:38:38 <aupiff> I'm using `parMap` from `Control.Parallel.Strategies` and I'm a bit confused why I am seeing many PIDs for my program. Shouldn't all the threads have unique TID but there be one PID, or is it that every core has to run a separate process that is launched by my haskell program?
20:52:07 <Lokathor> aupiff, how does one use parMap exactly?
20:52:34 <Lokathor> that is, what strategy do you pass to it for the Strategy b part?
20:53:46 <Lokathor> something like, parMap parBuffer (+2) [1,2,3]
20:53:48 <Lokathor> ?
20:55:40 <Hijiri> nf or whnf maybe?
20:56:15 <Hijiri> rnf I mean
20:56:36 <bluezone> How long does it take to pick up this language if i'm coming from a Java8  background? To a level where I could use it to develop a microservice for a SaaS project
20:56:37 <Lokathor> was that to me?
20:57:05 <Axman6> aupiff: Control.Concurrent.* shouldn't produce any extra processes, there should only be N OS threads
20:57:06 <Lokathor> bluezone, Haskell takes a fair bit of brain reformatting from java
20:57:21 <Stratege> Lokathor that's putting it lightly ^^
20:57:30 <Axman6> bluezone: have you ever used a functional language? (Java 8 does not count)
20:57:45 <njosh> Are there any resources specific to building a microservice in Haskell?
20:57:50 <bluezone> Axman6: i've user map/foreach/ this kind of thing in javascript 
20:57:58 <bluezone> njosh: I don't think so but i'd like to investigate :)
20:58:03 <Axman6> bluezone: so no then =)
20:58:22 <Axman6> njosh: 1Servant is excellent for writing microservice type apps, we use it all the time
20:58:27 <Axman6> s/1//
20:58:35 <julianleviston> bluezone: that’s not functional programming, that’s an iterator.
20:59:23 <bluezone> they call it functional programming in the javascript community. it's a poorly defined term when it's used in day-to-day talk 
20:59:24 <Axman6> bluezone: to use a language liuke haskell yuou'll have to forget a lot of what you know, many things that you assume to be constant throughout languages are not so in Haskell in particular, but also most other fuinctional languages
20:59:26 <Lokathor> bluezone, https://github.com/bitemyapp/learnhaskell is the guide you want. Depending on what you want to build in haskell, you might have quite the road ahead of you
20:59:35 <julianleviston> bluezone: a function is NOT a procedure.
20:59:52 <Stratege> bluezone eh it's always sort of a poorly defined term.
21:00:32 <julianleviston> bluezone: haskell uses the mathematical definition of a function… so it’s very different than what you’ve probably heard called a function before. 
21:00:35 <Lokathor> bluezone, I'll say though, your Java code will probably be much better once you know Haskell and apply some of its ideas back to Java, where appropriate
21:01:18 <julianleviston> bluezone: given an input x, a pure function f(x) can NEVER EVER EVER return different answers.
21:01:40 <julianleviston> bluezone: in other words, so long as x stays the same, the answer stays the same
21:01:46 <saulzar> I use functions in my code.. that's functional programming isn't it?  (I'm pretty sure that was my immediate thought on first hearing the term)
21:01:54 <Stratege> oh, also be prepared to start hating most other programming languages, or atleast developing a disdain for them. - not because people expect you to hate it, but rather 'cause that tends to be a common story "I picked up haskell and now I get frustrated at other languages"
21:02:03 <julianleviston> saulzar: for some definition of “functions”
21:02:30 <julianleviston> saulzar: in javascipt, for example, they write what they call functions. They’re not mathematical functions… 
21:02:44 <saulzar> julianleviston, Yeah, that's really the problem.. isn't it - procedures/methods/functions are all called the same thing by the programming community at large
21:02:50 <bluezone> Stratege: I think I @already (HaveADisdain, For) -> them 
21:02:50 <Hijiri> Lokathor: I meant rseq, sorry
21:03:01 <Hijiri> I was looking through my code to see what I used
21:03:09 <Lokathor> Hijiri, does this stack overflow look correct? http://stackoverflow.com/questions/5606165/parallel-map-in-haskell
21:03:10 <julianleviston> saulzar: that’s why we have the term “pure functional"
21:03:10 <Stratege> bluezone ... what syntax was that?
21:03:13 <Lokathor> if so i'll bookmark that
21:03:21 <bluezone> Stratege: java 8 lol
21:03:34 <Stratege> bluezone mind explaining it? xD
21:03:49 <Lokathor> bluezone, that's like no java8 i've ever seen
21:03:51 <Stratege> ^
21:03:56 <julianleviston> it’s lamdas
21:04:03 <julianleviston> Java 8 got lambdas, right bluezone ?
21:04:05 <Lokathor> i know java8 lambdas, but what's the @ part do?
21:04:09 <bluezone> @already is an annotation 
21:04:09 <lambdabot> Unknown command, try @list
21:04:20 <Stratege> and what are annotations for?
21:04:24 <Lokathor> oh, didn't know you could annotate a lambda too
21:04:48 <bluezone> Lokathor: not sure if you can I'm just being stupid, Stratege they just give information  to the technologies your using
21:04:56 <Lokathor> Stratege, notes for tools to use, basically. usually no runtime effect as far as I know
21:05:23 <Hijiri> Lokathor: it looks right
21:05:28 <Lokathor> example, @Override means "this should override something, if it doesn't throw a warning because i messed up hard"
21:05:29 <Stratege> oh! like the [Serializeable] things in C# and such?
21:05:37 <Hijiri> I didn't use parMap but I used parTraversable in one spot
21:05:41 <Stratege> or just comments, apparently.
21:06:17 <bluezone> well glad to see this community is much more amicable than in #java
21:06:33 <Lokathor> Stratege, in the particular case of Serializable, java does the (probably wrong) thing where you just say an object implements the interface (with no methods) and then the JVM makes the code for you
21:06:35 <julianleviston> bluezone: the haskell community is *so* nice.
21:06:46 <julianleviston> bluezone: I’m a new person, too… and man… they’re SO nic.
21:06:57 <Stratege> heh ... I once went there asking what java is good for. The answer was basically "shut up, we are making money, your haskell friends aren't"
21:07:04 <julianleviston> LOL
21:07:08 <bluezone> lol
21:07:23 <Lokathor> I asked if they'd want to do property based testing by giving methods randomized inputs to make sure all the cases were covered
21:07:26 <lfairy> I guess from a purely economic point of view that's a great answer
21:07:30 <Lokathor> they almost couldn't understand the question
21:08:33 <julianleviston> Lokathor: well if you don’t have pure functions, and methods can mutate everything everywhere, how can you talk about invariant properties of things? :)
21:08:35 <awpr> that seems to happen a lot with those kinds of languages -- anything higher-order than 'map' is so tedious to implement that nobody's ever seen it before
21:08:56 <saulzar> julianleviston, Restart the program? :)
21:09:20 <Welkin> WAR!
21:09:22 <Stratege> julianleviston the same way you do TDD: pray that people do the right thing and that nothing breaks.
21:09:23 <Lokathor> julianleviston, that's what i mean by "learning haskell will make your java better when/if you go back" :3
21:09:24 <Welkin> HUH!
21:09:25 <Welkin> YEAH!
21:09:31 <Welkin> What is it good for!?~
21:09:37 <Welkin> ABSOLUTELY NUTHIN'!
21:09:38 <bluezone> lol
21:09:39 <Lokathor> mutating a turing machine
21:09:57 <bluezone> that's good, .war files too :D
21:10:02 <julianleviston> Lokathor: yeah… Rich Hickey (clojure creator) has this really funny / interesting talk about writing concurrent Java… I really like it… 
21:10:34 <julianleviston> Lokathor: he has a silly jibe at Haskell at the beginning… “and how many people are coming from Haskell to hear about Clojure?” (no hands go up) “Well, they’re probably all tired because they learnt Haskell”
21:10:39 <bluezone> Ok I shall investigate this tomorrow at work, instead of working with Java lol
21:10:54 <julianleviston> Lokathor: (Or… maybe they have a vastly better language at their disposal)
21:10:55 <Lokathor> Hijiri, the main thing I thought that parMap might be good for some time soon is an FOV module i'm working on. Each quadrant could be computed in parallel. Or perhaps many monsters could each have their FOV dont in parallel, something like that
21:11:07 <julianleviston> Lokathor: that’s the bit he missed out.
21:11:20 <Welkin> a lot of people are put off by Hickey's constant need to justify his language
21:11:20 <Welkin> lol
21:11:21 <awpr> julianleviston: I think we're just not interested in what amounts to Python masquerading as Lisp after learning Haskell
21:11:41 <Stratege> awpr isn't python lisp masquerading as C in a lot of ways? ^^
21:11:49 <saulzar> bluezone, Careful there- you'll end up messing with Haskell all the time at the expense of 'real' work :P
21:12:00 <bluezone> lol
21:12:01 <Lokathor> python without a GIL is cool. Trying to pull off functional style coding without TCO seems like tilting at windmills
21:12:06 <julianleviston> bluezone: we’re serious. it’s addictive.
21:12:11 <Welkin> bluezone: once you get comfortable with haskell, you can build anything with it
21:12:18 <Welkin> then you'll reach nirvana
21:12:38 <julianleviston> bluezone: coz once your programs are composed of these “immutable units”, you can muck round with them and look at the interesting properties they have and wonder what will happen if you put this thing there… and BAM 6 hours have gone by.
21:12:45 <Lokathor> Stratege, yes, python is like a dumbed down lisp in a few key ways
21:14:04 <Lokathor> bluezone, if i had to pick a feature of haskell that's easy for a java programmer to understand and love: your data types are so simple that they'll *actually* be reusable and composable
21:14:14 <julianleviston> Lokathor hehe… “Blub Paradox” springs to mind about lisps.
21:14:15 <Stratege> julianleviston and that's before someone gives you a type like "Functor f => (f b -> b) -> (a -> f a) -> a -> b" and leaves you to figure out how it works/how to implement it ^^
21:14:29 <julianleviston> Stratege: hehe :)
21:14:30 <bluezone> hmmm :)
21:14:35 <awpr> julianleviston: ironic because that article was written *about* lisps :D
21:14:43 <julianleviston> awpr: I know!
21:14:53 <awpr> I assumed so, just seemed worth mentioning
21:14:55 <julianleviston> awpr: exactly what I was saying. It’s so amusing.
21:15:07 <julianleviston> Stratege: thanks for reminding me I need to study more :)
21:15:25 <Stratege> julianleviston np ^^ that one is really fun to figure out btw.
21:15:26 <Lokathor> julianleviston, I've glanced at Common Lisp, but... it seemed to me that it's got a lot of pain points that can creep up on you
21:15:44 <julianleviston> Stratege: I’ll take a look
21:16:03 <julianleviston> Lokathor: yes. I actually read PG’s book… that was… painful.
21:16:49 <julianleviston> Stratege: I should probably go and do the NICTA course, I think.
21:16:59 <julianleviston> Lokathor: well, the common lisp one.
21:17:17 <Welkin> cis194 and nicta are good to start with
21:17:29 <Lokathor> I have a lot of books to read. and CIS194 to finish in fact i think
21:17:32 <Stratege> julianleviston as long as you know what functors are, you can figure out how to implement this (it is, to my knowledge, a function called 'hylo')
21:17:35 <Welkin> I cannot use dynamicly typed languages anymore
21:17:38 <julianleviston> Welkin: I sorta finished cis194… I found large chunks of it… difficult to approach.
21:17:39 <Welkin> it's painful
21:18:48 <julianleviston> Lokathor: funny story about how I discovered Haskell actually… I was in the clojure channel and I was complaining bitterly about how functions arguments are evaluated before the function gets to them… I kept saying “But… why is it like this? We could have a much simpler language that doesn’t evaluate its arguments… and we wouldn’t have to continually use macros”.. Most of the people there thought I was 
21:18:48 <julianleviston> completely nuts…
21:19:00 <julianleviston> Lokathor: then someone PM’d me and said “you’re describing Haskell"
21:20:23 <Lokathor> i asked on Erlang one time if any of them thought that limited lazyness might be a cool feature for Erlang to have
21:20:41 <Ralith> I'm not sure I'd describe laziness as "simpler"
21:20:45 <julianleviston> Stratege: I know how to functor some… I’m giving it a go :)
21:21:05 <Stratege> julianleviston feel free to poke me if you need some clues :D and best of luck!
21:21:14 <julianleviston> Ralith: currying is what I was talking about particularly.
21:21:19 * hackagebot accelerate-cuda 0.15.1.0 - Accelerate backend for NVIDIA GPUs  https://hackage.haskell.org/package/accelerate-cuda-0.15.1.0 (TrevorMcDonell)
21:21:20 <julianleviston> Ralith: and that enables the simplicity
21:21:21 <Welkin> > let fib a b = a : fib b (a+b) in fib 0 1 -- julianleviston 
21:21:23 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
21:21:24 <Welkin> :D
21:21:45 <julianleviston> Welkin: not sure what your point is :)
21:21:53 <Welkin> it's laziness
21:22:00 <julianleviston> Welkin:  it’s all laziness :)
21:22:03 <Welkin> and recursion
21:22:05 <Stratege> also, tbh, in Haskell lazy evaluation -should- just be an "optimization" to my knowledge.
21:22:06 <julianleviston> Welkin: still not point what your point is.
21:22:07 <Welkin> and other cool things
21:22:29 <julianleviston> Welkin: not sure* what your point is
21:22:31 <exio4> Haskell is non-strict
21:22:31 <Stratege> (and I guess in some cases optimizing it from non-halting to halting ^^)
21:22:38 <Welkin> julianleviston: there is no point
21:22:41 <Welkin> I just like that function
21:22:48 <julianleviston> Welkin:  it *is* a pretty function :)
21:23:08 <awpr> > fix ((1:) . (1:) . (zipWith (+) <*> tail))
21:23:10 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
21:23:11 <julianleviston> Welkin:  well… I prefer the expression form because it memoises its lists and is more efficient right
21:23:15 <julianleviston> yeah that one.
21:24:12 <julianleviston> awpr: pretty sure there’s an even “simpler” way to put that… at least without using applicative.
21:24:24 <julianleviston> awpr: think it’s on my notes. one sec.
21:24:25 <awpr> julianleviston: yeah, this one was obfuscated for fun
21:24:30 <julianleviston> awpr: ok :)
21:24:34 <exio4> that's the same as let fib = 1:1:zipWith (+) fib (tail fib) in fib 
21:24:37 <awpr> > let fibs = 1:1:zipWith (+) fibs (tail fibs)
21:24:38 <Stratege> > fib = 1 : 1 : zipWith (+) fib (tail fib)
21:24:39 <lambdabot>  <no location info>:
21:24:39 <lambdabot>      not an expression: ‘let fibs = 1:1:zipWith (+) fibs (tail fibs)’
21:24:40 <lambdabot>  <hint>:1:5: parse error on input ‘=’
21:24:41 <julianleviston> Excureo: that’s it :0
21:24:46 <julianleviston> exio4:  that’s it :) (I mean)
21:24:47 <awpr> ... in fibs
21:24:54 <Stratege> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fib
21:24:56 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
21:25:21 <Welkin> it starts at 0!
21:25:23 <julianleviston> Stratege: man… that let…in. syntax confused the HELL out of me when I was a beginner.
21:25:30 <Welkin> 0, 1, 1, ...
21:25:42 <julianleviston> Stratege: I wish lambdabot had a way to do the in-IO-monad let expressions to show new people things...
21:25:51 <Stratege> > let fib = 0 : 1 : zipWith (+) fib (tail fib) in fib
21:25:56 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
21:26:03 <Stratege> Welkin happy?
21:26:17 <Stratege> :3
21:27:19 <Lokathor> some people insist on "non-strict" over "lazy", and i've never quite gotten the difference
21:27:49 <exio4> let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs == fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs) == fix $ \fibs -> ((1:) . (1:) . (\xs -> zipWith (+) xs (tail xs))) fibs == fix ((1:) . (1:) . (\xs -> zipWith (+) xs (tail xs))) == fix ((1:) . (1:) . (zipWith (+) <*> tail))
21:29:18 <MarcelineVQ> > fix ((0:) . scanl (+) 1)
21:29:21 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
21:30:19 <MarcelineVQ> Lokathor: nonstrict means things are evulated from the outside in, which lets you short-circuit evaluating things you don't need, lazy means not computing values until you need them
21:30:49 <exio4> non-strict is also a denotational thing, lazyness is an operational thing
21:30:54 <Lokathor> thennnnn isn't it both?
21:31:11 <Welkin> a THEN?
21:31:13 <Welkin> where!?
21:31:19 <Welkin> Thenn*
21:31:30 <exio4> Lokathor: non-strictness doesn't have thunks, lazyness does
21:31:42 * hackagebot accelerate-random 0.15.0.0 - Generate Accelerate arrays filled with high quality pseudorandom numbers  https://hackage.haskell.org/package/accelerate-random-0.15.0.0 (TrevorMcDonell)
21:31:50 <Welkin> MarcelineVQ: ;O
21:31:57 <MarcelineVQ> :>
21:32:22 <exio4> Lokathor: lazyness gives you non-strict semantics, but non-strict semantics also can be implemented differently if you wanted to
21:33:27 <njosh> exio4: I have always wondered how else could non-strict semantics be implemented.
21:34:19 <exio4> iirc I read that a `typical` counter-example is speculative evaluation or something like this?
21:35:15 <njosh> exio4: https://en.wikipedia.org/wiki/Speculative_execution? But this seems like the opposite. 
21:36:09 <exio4> njosh: well, how does it sounds like the opposite? 
21:37:18 <exio4> njosh: remember, btw, that a function being non-strict means f _|_ /= _|_ 
21:37:33 <exio4> > let f = const 1 in f (error "_|_") 
21:37:35 <lambdabot>  1
21:38:57 <julianleviston> Stratege: I’m kinda lost… how can I do this
21:39:11 <njosh> Okay. Reading tihs https://wiki.haskell.org/Lazy_vs._non-strict. It seems that non-strictness is about the *how* of the evaluation while laziness adds the *when* to non-strictness in a specific way. Am I correct?
21:39:20 <njosh> exio4: ^^
21:40:22 <Lokathor> julianleviston, i was told the answer, and it made me frown a lot
21:40:43 <njosh> exio4: Okay. So implementing non-strict semantics means specifying when the evaluation happens, before the results are needed or when they are needed? 
21:41:20 <Lokathor> exio4, so is lazyness a subtype of non-strict?
21:42:42 <exio4> for me it was clearer when I split that non-strictness and lazyness live in different worlds, one (non-strictness) lives in the denotational world, when mapping things to mathematical values, and lazyness implies thunks, operational details and what not
21:42:55 <exio4> njosh: evaluation? reduction? 
21:43:57 <Lokathor> I hear SPJ say "haskell is a lazy language" a lot in talks, and then people here in the channels insist on saying non-strict instead
21:44:05 <Lokathor> strikes me as odd
21:44:10 <njosh> I haven't had any PL education. So, the operational and denotational thingies dont' make much sense to me. 
21:44:48 <srhb> Lokathor: GHCHaskell is a lazy language, and that's what he (and everyone, really) is talking about all the time
21:45:11 <exio4> njosh: some analogy, operational = implementation, denotational = meaning (kinda, specification :P)
21:45:24 <exio4> indeed, GHC is lazy, saying Haskell is non-strict is just being annoying
21:46:01 <srhb> It's technically right though, but since there's no non-lazy variant in the wild, it is a bit pedantic. :)
21:46:19 <exio4> njosh: I haven't had a formal education in PL/type/category theory either! 
21:46:40 <njosh> exio4: Okay. I think I was thinking right. Laziness (Operational) and Non-strictness. So, lazy implementation would add a layer to the semantics.
21:47:03 <njosh> What I mean by a layer is simply more information.
21:47:22 <njosh> Sorry for the lousy language. 
21:48:31 <njosh> Non-strictness leaves out the details that the real would require for things to operate because the real world is imperative. Laziness is one way to fill the holes up.  Right exio4?
21:50:06 <exio4> the Haskell report doesn't really defines how you could implement Haskell in the machine, so that's up to the compiler, yeah
21:51:09 <Lokathor> implement it with unicorns
22:01:43 * hackagebot hmatrix-gsl-stats 0.4.1.3 - GSL Statistics interface  https://hackage.haskell.org/package/hmatrix-gsl-stats-0.4.1.3 (VivianMcPhail)
22:03:35 <awpr> huh, that was a satisfying exercise.  and there are two totally different, almost opposite, key insights you can use to get to the answer.
22:04:04 <awpr> (oh, it's scrolled off the top by now.  the exercise was implementing hylo)
22:05:21 <Stratege> awpr mhm! :D
22:05:26 <Stratege> really cool, isn't it?
22:05:55 <Stratege> although it appears to be a non-standard way of implementing it (checking the web ^^)
22:06:22 <awpr> what's a non-standard way of implementing it?
22:06:43 * hackagebot accelerate-fft 0.15.1.0 - FFT using the Accelerate library  https://hackage.haskell.org/package/accelerate-fft-0.15.1.0 (TrevorMcDonell)
22:06:50 <awpr> we haven't mentioned any actual implementations of it, or have I missed something?
22:07:02 <Stratege> the type I provided for "hylo" implies a different implementation than the one I have seen on the web
22:38:14 <julianleviston> ah I can’t do this… 
22:38:15 <julianleviston> blah :: Functor f => (f b -> b) -> (a -> f a) -> a -> b
22:39:45 <kadoban> julianleviston: (Functor f, Comonad f) => ?
22:40:03 <julianleviston> kadoban: it’s an exercise … I can’t change the type signature and I have to define blah
22:40:16 <julianleviston> at least - an exercise that Stratege mentioned :) 
22:41:07 <kadoban> Ah. Oh I don't know why I thought that would help anyway, nevermind, haha.
22:41:48 <julianleviston> I don’t see how you can get a function from a -> b from (f b -> b) and (a -> f a) but I’m probably misunderstanding something no doubt.
22:42:54 <kadoban> Yeah I don't see it either.
22:43:40 <Stratege> julianleviston it's sorta clever
22:43:48 <Stratege> note the Functor f => constraint
22:44:00 <julianleviston> Stratege: yeah, I saw that lol… of course. :)
22:44:13 <julianleviston> Stratege: the only thing I can think to do
22:44:18 <Stratege> that one is crucial for being able to do it, atleast to my knowledge it is ^^
22:44:32 <julianleviston> Stratege: … is to use the fact that we have a (f b -> b) which effectively unwraps the b.
22:44:45 <julianleviston> Stratege: so we can fmap that into the other one
22:44:51 <julianleviston> Stratege: but it doesn’t typecheck when i do that
22:45:20 <Stratege> mhm
22:45:42 <julianleviston> Stratege: ok give me a sec :)
22:45:44 <Stratege> I can provide a few tips if you want
22:45:51 <kadoban> You'd need a (f a -> f b) or to already have an (a -> b) to fmap or something, otherwise that doesn't work?
22:45:55 <Stratege> the fmaping of (f b -> b) is probably wrong
22:46:03 <Stratege> kadoban you are on the right track :D
22:46:23 <Lokathor> the secret is that the answer is partly stupid :P
22:46:27 <Stratege> ^
22:46:32 <Stratege> and partly clever
22:46:39 <Lokathor> yes, and won't actually execute properly for many things
22:46:54 <julianleviston> Stratege: I thought I could just do equational reasoning on it but I obviously don’t know what the Functor I’m doing. :)
22:47:03 <kadoban> Oh well if it doesn't have to work, then 'undefined' it is.
22:47:14 <Stratege> kadoban it has to work for appropriate f and gs.
22:48:05 <Stratege> kadoban note that we can rewrite our type to be: Functor f => (f b -> b) -> (a -> f a) -> (a -> b)
22:48:31 <julianleviston> Stratege: oh dear
22:48:36 <Stratege> yes.
22:49:39 * quicksilver doesn't think Stratege's type has any non-trivial inhabitants.
22:50:51 <julianleviston> Stratege: “we know we’re going to be there in the future because we’re going that way… so we just bootrap the universe backwards”
22:51:07 <Stratege> julianleviston you appear to be on the right track. :D
22:51:24 <julianleviston> Stratege: makes me feel like we’re in a terminator movie. 
22:52:09 <kadoban> I really don't think it's possible. If it were Monad or something I'd maybe think I was missing something, but … Functor just doesn't allow you to do much there, and there's just kind of obviously a piece missing that can never be created.
22:53:03 <Stratege> kadoban I assure you, it is possible to construct something that typechecks and also terminates for certain inputs. Inputs that can even do things and not involve undefined and the like.
22:53:29 <Stratege> and we -can- create the obviously missing piece, using recursion.
22:54:26 <julianleviston> Stratege: yeah I just flat can’t work this out.
22:54:51 <Stratege> julianleviston see pm for solution
22:54:53 <julianleviston> Stratege: I need to know how fmap across a function works and I can’t remember/don’t understand
22:55:09 <julianleviston> Stratege: I don’t want the answer.
22:55:11 <Stratege> 'kay
22:55:13 <julianleviston> Stratege: I want to understand.
22:55:19 <julianleviston> Stratege: (how to get it myself)
22:55:35 <Stratege> you have 3 pieces:
22:55:40 <Stratege> f, g and fmap
22:56:02 <Stratege> f :: (f b -> b)
22:56:10 <Stratege> well 4 I suppose
22:56:12 <Stratege> g :: (a -> f a)
22:56:12 <julianleviston> Stratege: and the remainder of the functions.
22:56:14 <julianleviston> function*
22:56:19 <julianleviston> f g and a.
22:56:22 <Stratege> fmap :: (a -> b) -> (f a -> f b)
22:56:38 <Stratege> hylo :: (f b -> b) -> (a -> f a) -> (a -> b)
22:56:40 <julianleviston> Stratege: I think I’m missing basic understandings though.
22:56:51 <julianleviston> Stratege: because we’re talking at the type level
22:56:55 <Stratege> mhm
22:57:02 <julianleviston> Stratege: and I’m thinking about doing substitutions and my brain falls apart
22:57:25 <Stratege> you currently feel like you are missing something to make it all work, aren't you? :D what is the typo of what you are missing?
22:57:30 <Stratege> *type, not typo
22:57:56 <julianleviston> Stratege: No, I just really don’t know how to reason about this stuff. Every time I think I get it, it turns out I was completely wrong.
22:58:08 <kadoban> (a -> b) or (f a -> f b)
22:58:32 <Stratege> stick with the type level for this one, I doubt substitutions will lead to an easy answer
22:58:33 <julianleviston> Stratege: (f b -> b) -> (a -> f a) -> a -> b I just look at that and go… I don’t really understand what it means.
22:58:59 <jle`> it means, given a way to take (f b -> b), and a way to take (a -> f a), you can turn an `a` into a `b`
22:59:07 <Stratege> kadoban given what we have, is there -any- way to get (a -> b) or (f a -> f b)
22:59:08 <julianleviston> Stratege: I think what it means is … you’ve got “f”, a function from wrapped b to b…. 
22:59:22 <jle`> so, blah f g x = (something of type `b`)
22:59:28 <julianleviston> jle`: yeah, I got that.
22:59:37 <kadoban> Stratege: Not that I see
22:59:42 <julianleviston> jle`: yep. got that.
22:59:57 <julianleviston> kadoban: you have (f b -> b) -> (a -> f a) -> ( a -> b )
23:00:09 <julianleviston> kadoban: so you can take the (a -> b) and feed it into fmap…
23:00:15 <julianleviston> :t fmap
23:00:15 <Stratege> mhm
23:00:16 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:00:30 <julianleviston> fmap will spit out a (f a -> f b)
23:00:44 <Stratege> note that the (a -> b) is the return type of our function :D
23:00:44 <kadoban> julianleviston: Hmm, how do we have an (a -> b) to feed it? The (a -> b) is essentially what we have to produce, not a given.
23:00:56 <julianleviston> kadoban: that’s the “dumb trick"
23:01:25 <julianleviston> kadoban: because of currying, you *can* do that. You feed it what you’d ordinarily conceive of as the “function once it has been partially appied”
23:02:09 <Stratege> julianleviston exactly :D you are on the right track
23:03:20 <julianleviston> yeah, so we have an “fmap a” which is (f a -> f b) now.
23:03:28 <julianleviston> let’s call it “h”.
23:03:51 <Stratege> mhm
23:04:27 <julianleviston> so “f” is (f b -> b) and we need a “b” from an “a”. So this is “good".
23:05:07 <julianleviston> we also have “g” which is (a -> f a)
23:05:27 <julianleviston> so we should be able to create a function a -> b by plugging f g & h together using (.)
23:05:33 <Stratege> eyup
23:05:37 <julianleviston> and then feed it the original “a” and we’ll be “good".
23:05:39 <julianleviston> but it stinks.
23:05:44 <Stratege> stinks how?
23:06:19 <julianleviston> well it doesn’t typecheck for me
23:06:24 <julianleviston> but it also feels kind of wrong.
23:06:38 <Stratege> write out how you would write: hylo f g = /* implementation here */
23:06:44 <Stratege> assuming we have an h out of nowhere
23:07:33 <julianleviston> Stratege: g . h . f $ a
23:07:47 <julianleviston> Stratege: but it doesn’t typecheck.
23:08:13 <Stratege> well that's the wrong way around
23:08:23 <Stratege> hylo f g = f . h . g is the right way around.
23:08:26 <julianleviston> oh yeah.
23:08:42 <julianleviston> still doesn’t typecheck
23:08:51 <Stratege> with h = undefined :: (f a -> f b) ?
23:09:01 <Stratege> or how do you do the typechecking?
23:09:10 <julianleviston> Stratege: i run it through ghci
23:09:36 <Stratege> well yes but what is your h, since from the above you have not given it a full definition
23:09:59 <julianleviston> h = fmap a
23:10:02 <julianleviston> :t fmap 
23:10:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:10:27 <Stratege> and I guess your hylo is: hylo f g a = f . fmap a . g $ a then?
23:10:36 <julianleviston> yes.
23:10:49 <Stratege> that can't typecheck, since you are trying to use the last variable as both a and as (a -> b)
23:11:01 <julianleviston> Stratege: hylo f g a = f . h . g $ a ; where h = fmap a
23:11:10 <Stratege> ignore that this function takes 3 variables, drop the a entirely
23:11:23 <Stratege> and h = fmap x is correct, you just need to figure out what the x is.
23:11:25 <julianleviston> Stratege: but then I’d have somehow write it point free
23:11:46 <Stratege> mhm hylo f g = f . fmap x . g where x = ???
23:12:07 <julianleviston> huh? 
23:12:24 <Stratege> that's the pointfree version, without implementing the x
23:12:31 <julianleviston> what so I have to use the rest to get back to a -> b ok… but that wont’ work.
23:12:41 <Stratege> what -rest-?
23:12:52 <julianleviston> and my brain begins the circular convolution pattern which means it’s going to chuck a tantrum.
23:12:55 <MarcelineVQ> does it help to write hylo :: (f b -> b) -> (a -> f a) -> (a -> b) as hylo :: (f b -> b) -> (a -> f a) -> a -> b
23:13:17 <Lokathor> MarcelineVQ, actually it anti-helps :P
23:13:17 <Stratege> MarcelineVQ the first version is the way more helpful one, really, since it aggressively hints at the solution
23:13:45 <MarcelineVQ> Lokathor: does it? that helped me a lot with these kind of problems ^^;
23:14:05 <julianleviston> Stratege: oh god I just got it
23:14:07 <Stratege> yes
23:14:09 <Stratege> :D
23:14:13 <Lokathor> in some cases perhaps, but in this case, i have seen the solution, and i can tell you that -> (a -> b) is the better way to write it
23:14:38 <julianleviston> Oh maybe I didn’t. It doesn’t typecheck still
23:14:47 <Stratege> what's your current solution?
23:14:57 <julianleviston> Stratege: spoiler alert?
23:15:30 <julianleviston> Oh no I *did* get it
23:15:32 <julianleviston> dang.
23:15:34 <Stratege> :D
23:15:36 <julianleviston> that’s intensely silly
23:15:38 <Stratege> yes
23:15:39 <julianleviston> it now typechecks
23:15:50 <julianleviston> Stratege: but also kind of elegant
23:15:53 <Stratege> worse than it being silly is that you can do useful things with it.
23:15:59 <Joann8670> julianleviston: post it please, I'm still not sure how to get the `x` that we're fmapping...
23:16:02 <Stratege> I -did- say it's part clever and part stupid and that that is the same part
23:16:10 <julianleviston> Joann8670: I’ll message you
23:16:15 <jle`> i can't find too many interesting inputs
23:16:28 <jle`> but it works :3
23:17:00 <roelof> Anyone who can help me with this problem : http://lpaste.net/143107
23:17:03 <Stratege> jle` tbh me neither, but catamorphisms, anamorphisms and hylomorphisms cause my head to start spinning ^^
23:17:22 <julianleviston> Stratege: why do catamorphisms??
23:17:52 <julianleviston> Stratege: isn’t a catamorphism just a fold?
23:18:36 <jle`> oh, it's `hylo`. now i see how it can be useful
23:18:37 <Stratege> I think so, yes. And anamorphisms are "just" unfold.
23:18:45 <Stratege> jle` mhm
23:21:11 <acanucin> hi
23:21:19 <acanucin> i want to know about haskell
23:21:28 <acanucin> is it really good for get money?
23:21:39 <gfixler1> roelof: I'm spoling up to parse YAML as well (but don't know that error)
23:22:03 <gfixler1> jle`: everyone keeps sending me links to your blog
23:22:08 <Lokathor> acanucin, I'm not sure it's the best way to earn money right away
23:22:08 <acanucin> im just learn haskell from tryhaskell
23:22:19 <jle`> im sorry ;_;
23:22:25 <gfixler1> jle`: :)
23:22:30 <acanucin> i'm so amazed with the beauty of code
23:22:39 <roelof> gfixler1:  what do you mean with spoling up ? 
23:22:51 <gfixler1> roelof: meant 'spooling'
23:22:53 <acanucin> why programming language like haskell not so popular
23:23:05 <gfixler1> just getting started/looking into parsing YAML for Unity prefab/meta/unity files
23:23:13 <jle`> i like to think that it's been bad press/publicity
23:23:29 <gfixler1> I've seen a lot of negativity around Haskell on the webs lately
23:23:31 <echo-area> h f g x = f (fmap (h f g) (g x))
23:23:31 <gfixler1> makes me sad
23:23:40 <acanucin> hi..
23:23:55 <Stratege> echo-area jup, although point-free makes it look way more nice in my opinion
23:23:57 <acanucin> i want to know how you people utilize haskell
23:24:08 <acanucin> when you use haskell
23:24:19 <gfixler1> acanucin: for one, it completely changed how I write Python
23:24:30 <acanucin> i'm really interest in haskell know...
23:24:34 <roelof> gfixler1:  thanks, and how do I spool the yaml file of stylish-haskell
23:24:42 <elliptic00> if I have list [1, 2, 3], how can I append 4 to the list?
23:24:58 <gfixler1> roelof: there's a yaml parser written in Haskell
23:25:18 <jle`> elliptic00: [1,2,3] ++ [4] ?
23:25:20 <acanucin> i have good knowledge in java n .net
23:25:25 <roelof> acanucin:  a good book to learn Haskell is the craft of functional programming in haskell by hutton. I do learn haskell this way 
23:25:47 <Stratege> jle` do you have some actual usecases for hylo? ^^ I only got a handful of toy examples.
23:25:48 <jle`> i use haskell for web dev, physical simulations, numerical computation, games, networking
23:25:53 <elliptic00> thx
23:26:07 <gfixler1> I keep records of the papers, books, blog posts, etc., that I read through
23:26:11 <echo-area> Stratege: lambdabot gave this for point-free, but I don't think it's comprehensible: fix (liftM2 (.) (.) . flip flip id . (liftM2 ((.) . fmap) .))
23:26:27 <gfixler1> I think eventually I'll just print out thousands of pages from those links, bind them, and say "Here's how I learned Haskell"
23:26:30 <acanucin> brb...lunch time
23:26:52 <roelof> gfixler1:  and sold your papers for big bucks :) 
23:26:54 <Stratege> echo-area good lord xD yeah partial point-free not -entirely-: hylo f g = f . fmap (hylo f g) . g
23:27:10 <jle`> Stratege: it's more useful if you think of it in terms of ana + cata
23:27:29 <Stratege> jle` which I'm really really bad at.
23:27:33 <jle`> ana = ways to construct recursive data structures, cata = ways to collapse/fold them down
23:27:34 <roelof> acanucin:  lunch time. It's here 8:27 in the morning. Time for breakfast you mean :) 
23:27:49 <jle`> the prototypical ana/cata are unfoldr and foldr
23:27:51 <gfixler1> almost midnight here - time for a midnight snack
23:28:00 <gfixler1> I love unfoldr
23:28:19 <jle`> so you can imagine implementing a factorial function as taking n to [1..n] (ana), and then using product on that (cata)
23:28:20 <gfixler1> but I don't know why it's an anamorphism
23:28:21 <julianleviston> Oh… apparently the factorial function is a common hylomorphism!
23:28:33 <Adeon> can I globally add a hook that catches all uncaught exceptions in threads
23:28:45 <roelof> gfixler1:  where do you live. I live in Europe The Netherlands 
23:28:52 <jle`> > foldr (*) 1 . unfoldr (
23:28:54 <lambdabot>  <hint>:1:24:
23:28:54 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
23:28:54 <julianleviston> gfixler: I guess because it expresses a relationship with itself … a transmutative relationship?
23:28:54 <jle`> oops
23:28:55 <gfixler1> roelof: just north of Los Angeles
23:29:22 <gfixler1> julianleviston: I need a morphisms cheat-sheet
23:29:32 <jle`> > foldr (*) 1 . unfoldr (\x -> if x <= 1 then Nothing else Just (x, x-1)) $ 10
23:29:32 <julianleviston> gfixler1: lol! :)
23:29:33 <lambdabot>  3628800
23:29:57 <roelof> no one who is using stylish-haskell by using the prompt ?? 
23:30:03 <jle`> the unfoldr (\x -> if x <= 1 then Nothing else Just (x, x-1)) is the anamorphism that turns 10 into [10,9,8,7,6,5,4,3,2]
23:30:11 <jle`> and the foldr (*) 1 is the catamorphism
23:30:14 <julianleviston> https://en.wikipedia.org/wiki/Hylomorphism_(computer_science)
23:30:35 <julianleviston> Ooh… apomorphism, paramorphism
23:31:04 <julianleviston> lol the reference is that bananas, Lenses Envelopes & Barbed wire paper by Meijer.
23:32:14 <Adeon> answering my own question: yes I apparently can catch uncaught exceptions by using setUncaughtExceptionHandler from GHC.Conc
23:32:22 <julianleviston> quicksort solved with a hylomorphism https://ulissesaraujo.wordpress.com/2009/04/09/hylomorphisms-in-haskell/
23:33:34 <jle`> @let data ListPrim a b = Nil | Cons a b deriving (Show, Functor)
23:33:36 <lambdabot>  Defined.
23:34:23 <jle`> @let hylo f g = f . fmap (hylo f g) . g
23:34:25 <lambdabot>  Defined.
23:34:47 <mniip> :t hylo
23:34:48 <lambdabot> Functor f => (f b -> b) -> (a -> f a) -> a -> b
23:35:19 <jle`> > hylo (\l -> case l of Nil -> 1; Cons x y -> x * y) (\x -> if x <= 1 then Nil else Cons x (x-1)) 10
23:35:21 <lambdabot>  3628800
23:35:43 <Stratege> nice use o.o
23:36:04 <jle`> the second argument is the ana, which turns 10 into [10,9,8,7,6,5,4,3,2], and the first argument is the cata, which finds the product of the list
23:36:29 <mniip> > hylo (foldr (*)) (enumFromTo 1) 10
23:36:30 <lambdabot>      Occurs check: cannot construct the infinite type: b ~ [t b -> b]
23:36:30 <lambdabot>      Expected type: [t b -> b] -> t b -> b
23:36:30 <lambdabot>        Actual type: b -> t b -> b
23:36:38 <mniip> > hylo (foldr (*) 1) (enumFromTo 1) 10
23:36:40 <lambdabot>  *Exception: stack overflow
23:37:12 <mniip> :(
23:37:19 <Stratege> jup ^^
23:37:40 <Stratege> that's what I got with most of my tries to do something useful with hylo
23:37:58 <jle`> you don't have a base case for your anamorphism that way i think
23:41:03 <jle`> Fix Maybe is the natural numbers, so you can use Maybe with hylo to do induction type of stuff
23:42:31 <jle`> > hylo (\x -> case x of Nothing -> 1; Just y -> y^2) (\x -> if x <= 0 then Nothing else Just (x - 1)) 10
23:42:33 <lambdabot>  1
23:42:37 <jle`> um
23:42:44 <jle`> > hylo (\x -> case x of Nothing -> 1; Just y -> y*2) (\x -> if x <= 0 then Nothing else Just (x - 1)) 10
23:42:46 <lambdabot>  1024
23:43:00 <jle`> 1 * 2) * 2) * 2 ... (10 times)
23:44:57 <jle`> the anamorphism (\x -> if x <= 0 then Nothing else Just (x - 1)) generates an inductive encoding of the natural numbers...and the catamorphism (maybe 1 (*2)) breaks that down by applying (*2) 10 times to 1
23:45:15 <YellowOnion> Anyone familiar with JuicyPixels? something straight forward like applying dynamicPixelMap to a DynamicImage is giving me type errors.
23:45:18 <jle`> er, the anamorphism/catamorphism encoded by those functions
23:47:28 <Stratege> jle` pretty cool
23:52:49 <kallisti> uh, for some reason cabal can't find the dependencies for my test suite?
23:52:57 <kallisti> when I do cabal configure --enable-tests
23:53:15 <kallisti> it's just like "nah, not gonna download those extra dependencies"
23:54:00 <jle`> Stratege: i was writing a language where i wanted everything to be able to terminate, but i also wanted to implement recursion, so my solution was just to offer unfoldr and foldr as primitives, but have the user always offer a finite number as an argument to unfoldr that gives a maximum size for the resulting list
23:54:36 <jle`> basically it was a scheme to allow them to encode their almost-arbitrary recursion as an anamorphism + catamorphism pair
23:55:07 <jle`> but with the restriction on unfoldr, the "fake recursion" would always terminate in finite time
23:56:48 * hackagebot pathwalk 0.1.0.0 - Path walking utilities for Haskell programs  https://hackage.haskell.org/package/pathwalk-0.1.0.0 (Xena)
23:56:49 <MarcelineVQ> kallisti: are they listed in the build-depends of the test-suite in your .cabal file, and did you rebuild after adding them if they are?
23:57:44 <kallisti> yes to the first part, no to the second party because cabal is failing on the configure step, saying that it can't find any of the dependencies that the library itself doesn't already list as a build-depend
23:59:34 <Stratege> jle` that's pretty cool, what came of it?
