00:00:01 <amicuscuriae> I don't know Sir
00:00:16 <amicuscuriae> I made a Cli program back in school, in C++. it has colors in it also local fonts
00:00:23 <amicuscuriae> also an extensive menu
00:00:25 <srhb> amicuscuriae: How about you start reading a guide and write it yourself. :)
00:00:35 <amicuscuriae> srhb, please help me
00:00:37 <srhb> amicuscuriae: I don't recommend learning Haskell by jumping into a project though.
00:00:42 <srhb> amicuscuriae: You should start with basics first.
00:00:44 <amicuscuriae> kk
00:00:50 <amicuscuriae> I want to see the binary
00:00:57 <amicuscuriae> that adds two digits
00:01:17 <Lokathor> amicuscuriae, learning a programming language is a big process, and what you're asking for isn't very useful as first example material
00:01:29 <srhb> amicuscuriae: There are many ways to write it. This is one. main = do { a <- read <$> getLine; b <- read <$> getLine; print (a+b) }
00:01:45 <srhb> amicuscuriae: Which means probably nothing to you right now. :)
00:02:17 <baweaver> Monads \o/
00:02:35 <delYsid`> gah, this csp is making me crazy.  I can express it with traverse f, but I need more flexibility.
00:02:57 <delYsid`> er, actually, filter f . traverse g
00:02:58 <amicuscuriae> srhb, hehe :)
00:03:12 <slack1256> csp the concurrent thingy or cps?
00:03:18 <amicuscuriae> Lokathor, ok which book do you suggest for someone who wants to give haskell a try but don't have programming knowledge?
00:03:28 <delYsid`> slack1256: Constraint satisfaction problem.
00:03:40 <slack1256> @where LYAH
00:03:40 <lambdabot> http://www.learnyouahaskell.com/
00:03:49 <Lokathor> amicuscuriae, sadly the book that might be best suited to you is still being written
00:04:25 <baweaver> Huh, bitemyapp really has a following now eh?
00:04:40 <baweaver> Just bought it myself, haven't had much time to flip through yet.
00:05:43 <amicuscuriae> Lokathor, which one?
00:06:22 <Lokathor> http://haskellbook.com/ is the book's site
00:06:26 <Lokathor> you can buy the early access
00:06:33 <Lokathor> i did the other week, it's a solid book
00:06:42 <baweaver> https://gumroad.com/l/haskellbook
00:07:03 <baweaver> honestly early access is still ~800 pages and more than enough for a start
00:07:18 <baweaver> short of a programmer of another FP language, it'll tie them over for a good long while.
00:07:51 <baweaver> Curious though, what's the neg on LYAH?
00:08:03 <slack1256> it's old
00:08:16 <baweaver> mmm, makes sense.
00:08:59 <amicuscuriae> Lokathor, can you share?
00:09:00 <amicuscuriae> :)
00:09:43 <baweaver> probably not the wisest question there.
00:09:54 <amicuscuriae> ok
00:10:23 <baweaver> LYAH is free, so as far as an immediate start at least it's something to base on.
00:10:45 <baweaver> I have no solid opinions on the other book yet as I've just opened it today.
00:10:45 <Lokathor> baweaver, LYAH also has essentially 0 examples
00:11:15 <Lokathor> and is sometimes excessively vague in an incomplete sort of way
00:11:26 <baweaver> define example, because they do have code snippets about quite often
00:11:41 <Lokathor> mm, i should say "exersize" perhaps
00:11:42 <MarcelineVQ> so like, there's this thing here https://en.wikibooks.org/wiki/Haskell
00:11:42 <baweaver> I don't intend to say it's infallible, no, just more of curious.
00:11:46 <MarcelineVQ> and it's pretty good and free
00:13:02 <Lokathor> baweaver, persoanlly, it didn't kill me or anything, but when i finally got to the part where i started to think, "okay now we're building some real examples and doing some real work here"
00:13:07 <Lokathor> it turns out that was the last page
00:13:11 <Lokathor> :/
00:13:11 <baweaver> https://gist.github.com/quchen/5280339 - also this amuses me greatly
00:13:15 <baweaver> fair
00:29:11 <lpaste_> ruslantalpa pasted “how to make sepBy forget the last item (Thank you)” at http://lpaste.net/141231
00:34:48 <ReinH> Lokathor: are you familiar with monoids?
00:35:09 <Lokathor> uhhh, no
00:35:17 <ReinH> Lokathor: How about Alternative?
00:36:11 <ReinH> Lokathor: Oh, you figured out that there are monad return laws because there's one for each side of the >>=
00:36:13 <ReinH> Never mind.
00:36:14 <Lokathor> nope, i think the only weird typeclass thing that haskell has that wouldn't just be in any other language is Functor, which i'm only really familiar with as "a thing that holds values in a shape"
00:37:09 <ReinH> or doesn't hold values
00:37:20 <Lokathor> nothing is a shape
00:37:22 <baweaver> http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html - this helps
00:37:23 <ReinH> or is a recipe for computing a value
00:37:31 <slack1256> meh, that abstraction get you 95% of the way
00:37:33 <ReinH> Lokathor: I was referring to Const
00:37:52 <baweaver> actually very nice in terms of 'wtf is a monad?' type tutorials
00:38:09 <ReinH> Lokathor: are you familiar with (>=>)?
00:38:33 <Lokathor> uhm, don't think i've seen that one
00:38:38 <ReinH> :t (>=>)
00:38:39 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
00:39:12 <montanonic> baweaver: awesome link; thanks
00:39:33 <Lokathor> takes ah... transform-return, and another transform-return, and a start, and links it up
00:39:40 <Lokathor> looks like a cross-monadic compose
00:39:42 <ReinH> Lokathor: right, it's a form of composition
00:39:53 <Lokathor> oh just normal compose
00:39:57 <Lokathor> not cross-monadic
00:39:59 <ReinH> right
00:40:09 <ReinH> it composes things shaped like a -> m b
00:40:13 <ReinH> rather than things shaped like a -> b
00:40:37 <ReinH> anyway, here are those two monad laws restated in terms of >=>:
00:40:41 <ReinH> k >=> return = k
00:40:47 <ReinH> return >=> k = k
00:40:51 <MarcelineVQ> baweaver: this is amazingly clear
00:41:21 <baweaver> It's perhaps the only one on the subject I've seen that didn't leave me starting blankly as a result.
00:41:32 <baweaver> and now those ones make a lot more sense.
00:41:41 <Lokathor> "fmap is from the street, fmap is hip to contexts"
00:41:56 <ReinH> Lokathor: maybe that helps show the difference between them
00:42:22 <Lokathor> uhhh, so you can compose it backwards and forwards?
00:42:32 <Lokathor> like, return is identity either way, seems to be what i'm seeing
00:42:38 <ReinH> One says if you perform a monadic computation and then return, the return does nothing
00:42:40 <montanonic> baweaver: I love it when people who can draw help out us science and math folks. 
00:42:47 <ReinH> The other says if you return and then perform a monadic computation, the return does nothing
00:42:59 <baweaver> Hm, I should start doing that then
00:43:00 <ReinH> yes, the laws are exactly that return is the left and right identity for composition of "monadic computations"
00:43:04 <baweaver> I have the arts \o/
00:43:17 <Cooler> when does the pattern matching occur? during compile time or runtime?
00:43:24 <ReinH> Cooler: runtime
00:43:30 <Lokathor> baweaver, work with bitemyapp and add art to his book
00:43:32 <Cooler> i would imagine compile time to indicate type errors/
00:43:36 <baweaver> https://twitter.com/keystonelemur/status/641500004578816002 - charcoal lemur speaks to me
00:43:41 <Lokathor> inflate the page count from 800 pages to 1000 pages!
00:43:49 <baweaver> I'll ping him on that idea later.
00:43:53 <ReinH> Cooler: pattern matching failures are not type errors
00:43:57 <ReinH> pattern matching happens to values
00:44:17 <ReinH> Lokathor: anyway does that make more sense?
00:44:22 <Lokathor> Cooler, all of the types are computed at compile time though
00:44:29 <Lokathor> and a pattern match is type-related
00:44:47 <Lokathor> for example, matching (x:xs) matches to a list because the (:) operator is for the list type
00:44:47 <montanonic> I mean, it'd be a significant investment of time, but damn, if there's one thing that could take a user-friendly Haskell book and elevate it into another level, it'd be pictures.
00:45:00 <Cooler> thats what i thought
00:45:02 <ReinH> montanonic: have you seen Bartoz's stuff?
00:45:22 <ReinH> *Bartosz
00:45:23 <montanonic> ReinH: some scattered things here and there, but at the time, all too advanced for my Haskell skills
00:45:24 <Lokathor> ReinH, it both makes more sense and less sense
00:45:31 <ReinH> It has awesome pictures http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
00:45:35 * slack1256 finds funny that the math book with most pictures or diagrams he has seen is one of category theory
00:45:39 <slack1256> people still hate it
00:45:43 <slack1256> I do too
00:45:52 <Lokathor> it is clearer that 1 and 2 are saying that return is both left and right identity
00:46:19 <ReinH> Lokathor: you might try to prove to yourself that the two versions are equivalent by using the definition of (>=>)
00:46:23 <ReinH> That would be a good exercise.
00:46:23 <Lokathor> it is less clear why copies of these laws leave off the plain english explanations so frequently
00:46:45 <baweaver> I swear programming sights are cursed with horrid font composition
00:46:48 <montanonic> ReinH: I've seen that before; very nice stuff. When in one's Haskell education do you think is a good time for that?
00:46:48 <ReinH> Lokathor: Haskell has a documentation problem
00:47:15 <ReinH> montanonic: When you're ready you will know. Or something.
00:47:18 <montanonic> ReinH: have you seen githubs new documentation beta ideas?
00:47:23 <ReinH> montanonic: no?
00:47:31 <montanonic> Shit
00:47:35 <montanonic> I meant Stack Overflow
00:47:50 <ReinH> oh
00:47:57 <montanonic> http://meta.stackoverflow.com/questions/306213/warlords-of-documentation-your-questions-answered?cb=1 for anyone wondering.
00:48:00 <ReinH> I actually think github would do a better job
00:48:06 <ReinH> since that's where the projects actually live these days
00:48:08 <ReinH> but anyway
00:48:16 <ReinH> They could even do source analysis to link to docs
00:48:24 <montanonic> Probably true. Then again, Stack Overflows semi-gamification is surprisingly effective (personally speaking)
00:48:46 <ReinH> montanonic: For Q&A, absolutely. I'm not sure that automatically translates to documentation writing.
00:49:14 <montanonic> Yeah, we'll have to see. I really want all popular and semi-popular libraries in Haskell to be intelligeble though.
00:49:15 <ReinH> In fact it's probably dangerous to assume that it does, so I hope they are re-evaluating their gamification model
00:49:26 <ReinH> Absolutely.
00:49:29 <montanonic> So whatever gets us to that goal.
00:49:43 <lpaste_> ruslantalpa revised “how to make sepBy forget the last item (Thank you)”: “how to make sepBy forget the last item (Thank you)” at http://lpaste.net/141231
00:50:56 <baweaver> I think I've taken up a roll as a nomadic documentation writer
00:51:01 <baweaver> I use, I fix docs
00:51:13 <baweaver> boyscout rules, whatnot
00:51:21 <montanonic> ReinH: hey, speaking of github docs, Purescript: http://pursuit.purescript.org/
00:51:38 <montanonic> They really do an incredible job (and they are still not even at v1.0)
00:51:49 <ReinH> I really need to start using purescript
00:52:01 <montanonic> If Hackage could look like that website... with all those linked docs... man.
00:52:41 <ReinH> montanonic: er, that looks like it offers less functionality than hackage though?
00:52:55 <ReinH> Am I missing something?
00:53:03 <montanonic> How so?
00:53:27 <baweaver> Someone remind me later, I can work design magicks on Hackage
00:53:28 <montanonic> I think it's only official packages, but that's the only strong limitation I'm aware of
00:54:06 <montanonic> If you were looking for exposed functions: http://pursuit.purescript.org/packages/purescript-semirings/0.2.0/docs/Data.Semiring.Free
00:54:28 <Lokathor> yeah these pages are much nicer to look at
00:54:37 <Lokathor> even if they're largely the same data
00:54:39 <montanonic> And basically everyone has a linked doc or more.
00:54:43 <montanonic> every one *
00:55:36 <ReinH> montanonic: every what?
00:55:51 <montanonic> ReinH: what feature was noticeably absent for you?
00:56:00 <montanonic> every package *
00:56:13 <ReinH> Whatever you think makes it better than haddock docs on hackage.
00:56:20 <ReinH> It looks like a port
00:56:45 * Lokathor nods
00:56:55 <montanonic> You were talking about Github-based documentation
00:57:04 <montanonic> I just figured: that's what they use to host their docs
00:57:24 <montanonic> I haven't worked with Hackage myself, so I don't know how easy it us to update docs to it.
00:57:31 <baweaver> I shall return to #haskell more often in the future, but for now ZZZzzzzzzzz
00:57:44 <montanonic> baweaver: night!
00:59:16 <ReinH> montanonic: It (is supposed to) happen automatically when the package is pushed
00:59:34 <montanonic> ReinH: does it require a version update?
00:59:52 <montanonic> if you wanted to update them
00:59:57 <montanonic> or other people wanted to contribute
01:00:21 <ReinH> You can push documentation update manually, but people don't tend to do that much except if the docs fail to build automatically
01:00:28 <ReinH> *updates
01:00:37 <montanonic> Okay. Thanks.
01:02:26 <ReinH> montanonic: I was rather hoping the documentation had some nice features we could steal for haddocks :)
01:03:56 <montanonic> Ah, I see. I was more focused on the more pleasant layout of the site. Also, I think linking to an external document that others can edit which provides an overview and example of the package, along with several examples, is absolutely the right thing to do.
01:04:10 <montanonic> Not that all of them have exactly that, but (1) they should, and (2) we should too.
01:05:05 <ReinH> Yeah
01:05:20 <montanonic> I definitely, for example, would benefit from "noob sections" in documentation, for example. That would really only be standard if the docs were super easy to openly edit (with moderation of course).
01:05:31 <Lokathor> yeah, there should be auto-gen docs based on the source
01:05:33 <montanonic> Anyways, just some thoughts.
01:05:43 <ReinH> Lokathor: there are.
01:05:59 <Lokathor> ReinH, i mean even in the scenario where guides are written
01:06:04 <ReinH> yeah
01:06:13 <Lokathor> still *also* maintain hackage's system of auto-generating for each update
01:06:43 <ReinH> montanonic: I think git has really improved its documentation in the last few years https://git-scm.com
01:07:17 <montanonic> ReinH: oh most definitely; *and* they have Pro Git.
01:07:38 <ReinH> montanonic: and github folks have contributed pretty heavily to it ofc
01:10:57 <delYsid`> f [] = []
01:10:57 <delYsid`> f xs = case g xs of (ls, rs) -> ls ++ f rs
01:10:57 <delYsid`>  where
01:10:57 <delYsid`>   g (x:xs) = ([x], xs)
01:11:01 <delYsid`>   g []     = ([], [])
01:11:17 <ReinH> delYsid`: please don't paste code directly into the channel. Use lpaste.
01:11:23 <delYsid`> if I want g to return a list of tuples, and f return a list of all possible concatenations, what do I do?
01:11:41 <delYsid`> ReinH: sorry.
01:11:52 <ReinH> what do you want f to do?
01:12:12 <ReinH> what should its output be for, e.g., [1,2,3,4,5]?
01:12:45 <delYsid`> since g only produces 1 result right now, it should be [[1,2,3,4,5]]
01:13:09 <ReinH> so why not use f xs = [xs]?
01:13:13 <delYsid`> but eventually, g would be giving a list of tuples. each tuple is a "possible way forward"
01:13:22 <ReinH> what do you want the result to be?
01:13:25 <ReinH> not what is it now?
01:14:00 <delYsid`> no
01:14:07 <delYsid`> the result should be a list of lists
01:14:14 <delYsid`> and g should be returning a list of tuples.
01:14:29 <delYsid`> and f should give me all possible combinations.
01:14:35 <delYsid`> but I dont get it.
01:15:00 <ReinH> so you want a function that gives you permutations?
01:15:25 <delYsid`> I guess thats the correct term, yeah.
01:15:37 <ReinH> > permutations "hello" -- like this?
01:15:39 <lambdabot>  ["hello","ehllo","lehlo","elhlo","lhelo","hlelo","lleho","lleho","lelho","le...
01:16:03 <delYsid`> no
01:16:35 <ReinH> ok...
01:16:53 <felixn> ReinH: no means no
01:16:58 <ReinH> so can you describe your function then?
01:17:10 <delYsid`> I want something like sequence . map g but without the limiation that map can only produce one element of a list
01:17:34 <ReinH> so sequence . concatMap ?
01:18:07 <delYsid`> gah, nice guess, but no :-(
01:18:19 <ReinH> Ok, I'm not going to keep guessing
01:18:34 <ReinH> If you can't describe your function sufficiently, I can't help you
01:18:41 <delYsid`> sorry, the language barrier and the need to keep myself short is a block here
01:19:05 <ReinH> what does your function output for, e.g., "hello" or "cat"?
01:19:18 <delYsid`> that depends on g
01:19:29 <ReinH> g is fixed
01:19:43 <ReinH> so what do you want g to do?
01:19:47 <delYsid`> imagine g would always return lower and uppercase char
01:20:05 <ReinH> what does g "cat" return?
01:20:28 <delYsid`> so f "hello" = ["HELLO", "HELLo", "HELlO" ...]
01:21:11 <delYsid`> g "cat" = [('C', "at"), ('c', "at")]
01:21:27 <ReinH> > "cat" >>= \c -> [toLower c, toUpper c]
01:21:28 <lambdabot>  "cCaAtT"
01:21:32 <ReinH> woops
01:21:35 <delYsid`> er, ("c", "at")
01:22:13 <delYsid`> ReinH. g "cat" = [("C", "at"), ("c", "at")]
01:22:37 <Hijiri> > sequence . map (\c -> [toLower c, toUpper c]) $ "cat"
01:22:39 <lambdabot>  ["cat","caT","cAt","cAT","Cat","CaT","CAt","CAT"]
01:22:43 <delYsid`> because g needs to be able to process several chars at once, so it needs to return the rest...
01:23:17 <ReinH> > sequence . transpose $ ["CAT", "cat"]
01:23:18 <Hijiri> > mapM (\c -> [toLower c, toUpper c]) "cat"
01:23:19 <lambdabot>  ["CAT","CAt","CaT","Cat","cAT","cAt","caT","cat"]
01:23:20 <lambdabot>  ["cat","caT","cAt","cAT","Cat","CaT","CAt","CAT"]
01:23:27 <Lokathor> > (\word -> [(head . toLower word, tail word),(head . toUpper word, tail word)]) "cat"
01:23:29 <lambdabot>      Couldn't match expected type ‘a -> [c]’ with actual type ‘Char’
01:23:29 <lambdabot>      Possible cause: ‘toLower’ is applied to too many arguments
01:23:29 <lambdabot>      In the second argument of ‘(.)’, namely ‘toLower word’
01:23:35 <Lokathor> whoops :/
01:23:43 <delYsid`> Hijiri: Yes, I know that sequence can do that.  But I need to be able to process several elements of a list at once, so the simple map doesnt work for me
01:24:13 <ReinH> delYsid`: Ok, so again... what does f do?
01:25:27 <Lokathor> > (\word -> [((toLower . head) word, tail word),((toUpper . head) word, tail word)]) "cat"
01:25:30 <lambdabot>  [('c',"at"),('C',"at")]
01:25:49 <Lokathor> ...do you want to map that over something?
01:26:00 <ReinH> Lokathor: use (\(x:xs) -> ...), not head and tail
01:26:45 <Lokathor> oh right
01:26:52 <Lokathor> i often forget about patten matching in a lambda too
01:27:08 <delYsid`> Lokathor: Almost, it is ([a],[a]), not (a,[a]) though.
01:27:50 <ReinH> delYsid`: Can you just explain what you want the function to do please?
01:27:51 <Lokathor> > (\(x:xs) -> [([toLower x], xs),([toUpper x], xs)]) "cat"
01:27:52 <lambdabot>  [("c","at"),("C","at")]
01:27:54 <delYsid`> see, I get a list, and return a tuple of taken values and the unprocessed rest
01:28:14 <delYsid`> Lokathor: yeah, thats a simple example of my g
01:28:21 <Lokathor> ReinH, i think some variant of scanl or scanr is what's desired here
01:28:28 <ReinH> :t select
01:28:30 <lambdabot> Not in scope: ‘select’
01:28:35 <frerich> Isn't that like Cale's select?
01:28:39 <ReinH> I'm not sure
01:29:03 <ReinH> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in select "hello"
01:29:04 <lambdabot>  [('h',"ello"),('e',"hllo"),('l',"helo"),('l',"helo"),('o',"hell")]
01:29:06 <ReinH> this
01:29:08 <ReinH> ?
01:29:17 <delYsid`> f now produces all the possible concatenations of the taken values.
01:30:00 <ReinH> delYsid`: is that what you want?
01:30:15 <delYsid`> no :-(
01:30:21 <ReinH> Ok, I don't want to play this game any more.
01:30:25 <delYsid`> I am sorry for wasting your time...
01:30:48 <ReinH> Can't you just show an example input and output
01:31:38 <levi> delYsid`: It sounds like you are describing at the wrong level of abstraction. You're trying to describe implementation details without giving the actual specification for the overall operation.
01:32:06 <delYsid`> levi: maybe.
01:32:11 <ReinH> Or perhaps just describe the problem you are trying to solve
01:32:34 <levi> Sometimes, when you can't get your implementation details right, it's because you're working on the wrong implementation.
01:32:46 <frerich> delYsid`: I think it would be more helpful if you gave a couple of sample invocations (like 'f [] = ...; f [1,2,3] = ...; f ["Hello", "World"] = ...') and then people could give you definitions for 'f' which you could check -- and if they are inappropriate you could give a counter-example.
01:33:01 <delYsid`> My input is a list of values whoes actual meaning is yet undecided, say A could mean 1 or 16, B could mean 2 or 32, and so on.  I need to generate all possible combinations which satisfy a certain constraint (sum doesnt exceed a maximum...).  
01:33:18 <slack1256> ...
01:33:21 <delYsid`> That works with filter constraint . traverse makePossibilities
01:33:25 <ReinH> Then do that.
01:34:08 <frerich> delYsid`: Using English words to describe your requirement doesn't seem to get you anywhere. I'd suggest you write it out in Haskell as I wrote earlier. :-}
01:34:19 <frerich> I.e. some less ambiguous language. ;-)
01:34:28 <delYsid`> However, the rules I need to implement need to look ahead.  I.e., it is not enough to just look at once item of the list at a time, sometimes, I need to produce several items at a time.  Something like: If A is followed by 2 Bs, then [1,1,1]
01:35:05 <ReinH> :t concatMap
01:35:06 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
01:35:09 <slack1256> like spanish!
01:35:16 <ReinH> concatMap lets you look at the whole list
01:35:44 <ReinH> :t concatMap `asAppliedto` "hello"
01:35:45 <lambdabot>     Not in scope: ‘asAppliedto’
01:35:45 <lambdabot>     Perhaps you meant ‘asAppliedTo’ (line 150)
01:35:51 <ReinH> :t concatMap `asAppliedTo` "hello"
01:35:53 <lambdabot>     Couldn't match expected type ‘a -> [b]’ with actual type ‘[Char]’
01:35:53 <lambdabot>     In the second argument of ‘asAppliedTo’, namely ‘"hello"’
01:35:53 <lambdabot>     In the expression: concatMap `asAppliedTo` "hello"
01:35:56 <ReinH> ugh sorry
01:37:51 <levi> Sounds like you want a parser that returns a parse forest?
01:37:53 <ReinH> > inits "hello
01:37:55 <lambdabot>  <hint>:1:13:
01:37:55 <lambdabot>      lexical error in string/character literal at end of input
01:37:56 <ReinH> ugh
01:38:00 <ReinH> > inits "hello"
01:38:02 <lambdabot>  ["","h","he","hel","hell","hello"]
01:38:25 <ReinH> I mean
01:38:28 <ReinH> > tails "hello"
01:38:30 <lambdabot>  ["hello","ello","llo","lo","o",""]
01:39:14 <Hijiri> > tails []
01:39:16 <lambdabot>  [[]]
01:39:18 <Hijiri> why not [] ?
01:39:38 <ReinH> Hijiri: notice the last value of tails "hello"
01:39:48 <delYsid`> ReinH: Yeah, tails helps with the simple filter constraint . traverse makePossibilities . init . tails case
01:40:02 <Hijiri> ReinH: that makes sense, because [] is the tail of 'o' : []
01:40:08 <Hijiri> but there is no tail in []
01:40:08 <delYsid`> but that still doesn't give me the ability to produce several elements at once, I still always return 1 element.
01:40:27 <ReinH> then return more than one element?
01:40:41 <ReinH> and concat them
01:40:52 <ReinH> thus concatMap
01:41:15 <delYsid`> OK, thanks for trying, I give up.
01:41:22 <delYsid`> I will stay in procedural land.
01:41:49 <Lokathor> give it another try in a few days after you think on it
01:41:52 <Lokathor> you'll get it
01:42:06 <delYsid`> I know the algorithm.  I wrote it in C
01:42:20 <levi> How does the C program work?
01:42:23 <delYsid`> I just cant get my head around what Haskell wants me to bend over backwards to be able to implement it.
01:42:28 <Lokathor> i know, but C knowledge doesn't always translate to haskell knowledge
01:42:53 <Lokathor> step 1 is write out the type signature you think you'll use
01:43:11 <Lokathor> then see if there's that already in a lib, then slowly see how to make that if you don't find what you want
01:43:29 <delYsid`> Lokathor: [a] -> [[a]] isn't very helpful I'm afraid, because the magic happens inside the function.
01:43:41 <Lokathor> true i suppose
01:44:00 <Lokathor> well, it's not [a] is it?
01:44:05 <ReinH> It tends to be much harder to explain things to computers than to other humans.
01:44:09 <Lokathor> it's String -> [String]
01:44:26 <levi> What data structures and algorithms do you use to do this in C?
01:44:53 <ReinH> So explaining your function so that other humans can understand is a good preparation for trying to explain it so a computer can understand
01:45:04 <delYsid`> Lokathor: No, no strings involved at all.
01:45:17 <delYsid`> We were only using strings as an example, assuming a would be Char
01:45:30 <ReinH> delYsid`: you have a makePossibilities function. What is its type?
01:46:36 <frerich> delYsid`: I must say I'm somewhat curious to see your C code which implements that algorithm, it must be fascinating if it's so hard to explain the semantics :-)
01:46:47 <delYsid`> ReinH: In the filter f . traverse g case, makePossibilities is a -> [a]
01:47:02 <ReinH> delYsid`: and that's not what you want
01:47:21 <delYsid`> But as explained, thats not general enough, I need makePossibilities to be [a] -> [([a], [a])]
01:47:40 <ReinH> what does the tuple represent?
01:47:42 <Hijiri> does it choose every point to break in the middle?
01:47:51 <delYsid`> frerich: Let me fetch you a link.
01:48:40 <delYsid`> https://github.com/mlang/bmc/blob/master/value_disambiguation.cpp
01:49:04 <delYsid`> ReinH: The translated part, and the unprocessed part.
01:49:56 <ReinH> delYsid`: and are there multiple possible translations? Why the list of tuples?
01:50:12 * frerich patiently waits for delYsid` to explain how part(s) of that C++ code he wants to reimplement in Haskell. :-)
01:50:16 <frerich> s/how/which/
01:50:30 <delYsid`> ReinH: Yes, there are multiple possible translations, thats the whole point.  I need to find the list of all possible translations
01:51:15 <ReinH> delYsid`: If that's "the whole point" then why didn't you mention it a half hour ago?
01:51:42 <ReinH> Do different possible translations consume different amounts of the list?
01:52:13 <ReinH> is that why you have [([a],[a])] instead of ([[a]], [a])?
01:52:31 <delYsid`> frerich: I realize the C++ code is not easy to explain.  It uses continuation-passing style to get decent performance.  The interesting part is the implementation of "interpretations"
01:53:08 <delYsid`> ReinH: Now you've got me!!!
01:53:16 <delYsid`> Thats why I cant use map or concatMap
01:53:22 <montanonic> To be fair, now you've explained what you're doing.
01:54:07 <ReinH> and what is the type of the predicate that you use to filter?
01:54:42 <delYsid`> [a] -> Bool
01:54:58 <ReinH> how should [([a],[a])] be combined into [a]?
01:55:21 <frerich> delYsid`: Do you have tests (e.g. unit tests) for that C++ code?
01:55:28 <delYsid`> like sequence would do it if it could consume several items of a list...
01:55:45 <frerich> delYsid`: Often tests are a plausible approximation of the specification, i.e. the desired behaviour when observed from the caller side.
01:56:01 <ReinH> delYsid`: in terms of your domain, please
01:56:21 <delYsid`> frerich: Yeah, a ton of them.  Braille music code that translated to LilyPond.  But no low-level tests, because the input is hard to construct manually in C++
01:56:53 <ReinH> you have a list of translation + unconsumed part
01:56:55 <ReinH> what happens to that
01:58:33 <levi> It looks to me like 'interpretations' is a streaming parser that returns all possible parses in the face of ambiguity. Am I reading it right?
01:58:41 <delYsid`> The translations are appended, and I guess then recurse on the unconsumed part...
01:58:57 <ReinH> Right, so it's a parer
01:59:00 <ReinH> *parser
01:59:03 <frerich> delYsid`: Sounds like a nice use case for Haskell indeed - it sounds like you're basically compiling BMC into the LilyPond text notation? :-)
01:59:51 <delYsid`> frerich: I know, thats why I am playing with it.  But Haskell is giving me a hard time translating my concepts
02:00:30 <delYsid`> levi: Hmm, that might be true.  I don't yet know what parser means in this context.
02:00:48 <ReinH> levi: http://www.willamette.edu/~fruehr/haskell/seuss.html :)
02:01:23 <frerich> delYsid`: I suspect this may be difficult to you because you already have an imperative solution, at least I notice you trying to explain *how* to do something instead of saying *what* you want to do. :-)
02:01:52 <ReinH> delYsid`: type Parser a = String -> [(a, String)]
02:02:02 <ReinH> just generalized to consume a different type of token
02:02:26 <ReinH> So a parser-combinator library should work
02:02:41 <levi> delYsid`: A parser is a program that attempts to match a stream of tokens against some formal description of a language.
02:03:01 <ReinH> delYsid`: "A parser for things is a function from strings to lists of pairs of things and strings"
02:03:17 <delYsid`> This is confusing me because I already need a parser to read the ambiguous notation.
02:03:28 <delYsid`> I guess its new to me that I need yet another parser to disambiguate the data.
02:03:43 <delYsid`> In C++ it was "just" recursive continuation-passing.
02:03:51 <levi> It's the same thing in Haskell.
02:03:54 <ReinH> Now, given that a parser is:
02:03:59 <ReinH> @unmtl StateT s [] a
02:03:59 <lambdabot> s -> [] (a, s)
02:04:17 * hackagebot http-client 0.4.23 - An HTTP client engine, intended as a base layer for more user-friendly packages.  https://hackage.haskell.org/package/http-client-0.4.23 (MichaelSnoyman)
02:04:19 * hackagebot amazonka-core 1.3.2 - Core data types and functionality for Amazonka libraries.  https://hackage.haskell.org/package/amazonka-core-1.3.2 (BrendanHay)
02:04:21 * hackagebot amazonka 1.3.2 - Comprehensive Amazon Web Services SDK  https://hackage.haskell.org/package/amazonka-1.3.2 (BrendanHay)
02:04:23 * hackagebot amazonka-test 1.3.2 - Common functionality for Amazonka library test-suites.  https://hackage.haskell.org/package/amazonka-test-1.3.2 (BrendanHay)
02:04:25 * hackagebot amazonka-config 1.3.2 - Amazon Config SDK.  https://hackage.haskell.org/package/amazonka-config-1.3.2 (BrendanHay)
02:04:26 <ReinH> Perhaps StateT would be an elegant way of expressing your function
02:05:13 <ReinH> delYsid`: think of it like lexing
02:05:17 <ReinH> you are tokenizing first
02:06:16 <delYsid`> ok, so I have these tokens that have several meanings.
02:06:25 <delYsid`> I've never encountered something like that in parsing.
02:07:07 <levi> What does '*' mean in C?
02:07:30 <delYsid`> levi: pointer, dereference, or multiply :-)
02:07:34 <ReinH> delYsid`: consider a function String -> Maybe (a, String)
02:07:43 <levi> Well, there you go. A token with several meanings.
02:07:44 <ReinH> delYsid`: this represents a parse that can either succeed or fail
02:07:57 <ReinH> a function String -> [(a, String)] represents a parse that can have 0 or more results
02:08:33 <delYsid`> ReinH: OK, I get that.
02:09:01 <frerich> delYsid`: As levi mentioned, you used a lot of tokens which have several meanings depending on the context while writing your C++ code ;-)
02:09:01 <levi> Real-world parsers have to deal with all sorts of ambiguities; that's why they typically have some form of lookahead or backtracking.
02:09:27 * hackagebot amazonka-sns 1.3.2 - Amazon Simple Notification Service SDK.  https://hackage.haskell.org/package/amazonka-sns-1.3.2 (BrendanHay)
02:09:29 * hackagebot amazonka-sqs 1.3.2 - Amazon Simple Queue Service SDK.  https://hackage.haskell.org/package/amazonka-sqs-1.3.2 (BrendanHay)
02:09:31 * hackagebot amazonka-glacier 1.3.2 - Amazon Glacier SDK.  https://hackage.haskell.org/package/amazonka-glacier-1.3.2 (BrendanHay)
02:09:33 * hackagebot amazonka-cloudhsm 1.3.2 - Amazon CloudHSM SDK.  https://hackage.haskell.org/package/amazonka-cloudhsm-1.3.2 (BrendanHay)
02:09:35 * hackagebot amazonka-datapipeline 1.3.2 - Amazon Data Pipeline SDK.  https://hackage.haskell.org/package/amazonka-datapipeline-1.3.2 (BrendanHay)
02:09:44 <ReinH> yep, the amazonka flood is coming
02:09:44 <frerich> delYsid`: E.g. in 't * x' you don't even know whether that's a multiplication or a declaration of a variable 'x' with type 't*'. :-}
02:10:03 <phadej> uh, amazonka is already 1.3.x
02:10:15 <ReinH> it's growing up so fast
02:10:26 <delYsid`> Yeah, OK, so parsers can help me here, but I am totally at a loss how to combine this stuff.
02:11:03 <ReinH> delYsid`: so how do you combine the translations and what do you do with the remainders? I'm still wobbly on that bit.
02:11:33 <frerich> ReinH: I'm seriously impressed by your patience and diligence here. :-)
02:12:25 <delYsid`> ReinH: All translations of a "line" are just concatenated to form the final line.  The rest is needed to know where to continue.
02:12:44 <levi> Are you looking for a single disambiguated interpretation of the whole thing, or every possible interpretation?
02:13:08 <ReinH> delYsid`: ok, that's basically what >>= does
02:13:17 <delYsid`> frerich: You're right... I am really just stealing everyones time here.  I am clearly not intelligent enough to port this algorithm to Haskell, so I will just give up.  Really really thanks for having tried.
02:13:20 <ReinH> it continues the parse with the remainder
02:13:23 <levi> Think in terms of the final result of the whole program, not some intermediate steps.
02:14:03 <frerich> delYsid`: I don't think you're stealing anybodies time here, I think people are making an honest attempt at helping you.
02:14:04 <levi> delYsid`: Knock that off. You're plenty intelligent, we all had to figure out how to do this stuff at some point.
02:14:10 <MarcelineVQ> delYsid`: Well I doubt he meant it like that, ReinH's just been helping people all day
02:14:37 * hackagebot amazonka-iam 1.3.2 - Amazon Identity and Access Management SDK.  https://hackage.haskell.org/package/amazonka-iam-1.3.2 (BrendanHay)
02:14:39 * hackagebot amazonka-route53-domains 1.3.2 - Amazon Route 53 Domains SDK.  https://hackage.haskell.org/package/amazonka-route53-domains-1.3.2 (BrendanHay)
02:14:41 * hackagebot amazonka-directconnect 1.3.2 - Amazon Direct Connect SDK.  https://hackage.haskell.org/package/amazonka-directconnect-1.3.2 (BrendanHay)
02:14:43 * hackagebot amazonka-devicefarm 1.3.2 - Amazon Device Farm SDK.  https://hackage.haskell.org/package/amazonka-devicefarm-1.3.2 (BrendanHay)
02:14:45 * hackagebot amazonka-cognito-sync 1.3.2 - Amazon Cognito Sync SDK.  https://hackage.haskell.org/package/amazonka-cognito-sync-1.3.2 (BrendanHay)
02:14:52 <frerich> delYsid`: I just mean that ReinH is voluntarily investing a lot of time in helping people, which is a nice thing. That's all.
02:14:53 <levi> How long did it take you to learn how to write continuation-passing C++ programs?
02:14:59 <ReinH> delYsid`: so you might have: do { start <- parseStart; middle <- parseMiddle; end <- parseEnd; return (start ++ middle ++ end) }
02:15:05 <sedeki> the functions (*), (+), etc that are infix by default, are they a fixed set? or is there some procedural thing going on? say I want to create a new infix operator (>>>=) will this work for instance?
02:15:21 <ReinH> delYsid`: you could probably write your parser in exactly that style
02:15:21 <sedeki> i see a lot of combinations of > in the tutorials
02:15:24 <levi> You surely didn't get to your current C++ skill level in a couple weeks of part-time hacking. :)
02:16:01 <delYsid`> ReinH: Yes, only problem is, that the number of elements is unknown.  So I have to do that till the end, and then concat them all
02:16:11 <ReinH> sedeki: infix operations are determined by syntax
02:16:40 <ReinH> delYsid`: you can write combinators like "many", etc
02:16:43 <levi> sedeki: You can make all the custom operators you like by glomming together non-alphanumeric symbols. :)
02:16:44 <ReinH> indeed, this is already done for you
02:17:03 <ReinH> sedeki: identifiers that use symbols are considered infix operators
02:17:08 <ReinH> so +++, >>>><><><><<>, whatever
02:17:28 <sedeki> ReinH what do you mean by symbols?
02:17:52 <ReinH> sedeki: there's a formal definition in the grammar, but basically: non-alpha-numeric printable characters
02:17:58 <levi> I feel like no one sees what I write. :P
02:18:05 <sedeki> ReinH i see
02:18:19 <ReinH> with the exceptions of _ and '
02:18:27 <ReinH> and ()
02:18:36 <ReinH> actually
02:19:20 <levi> Except for some reason shachaf has an eagle-eye for when I am slightly hand-wavey about something or other. It's uncanny.
02:19:47 * hackagebot amazonka-elb 1.3.2 - Amazon Elastic Load Balancing SDK.  https://hackage.haskell.org/package/amazonka-elb-1.3.2 (BrendanHay)
02:19:49 * hackagebot amazonka-cloudformation 1.3.2 - Amazon CloudFormation SDK.  https://hackage.haskell.org/package/amazonka-cloudformation-1.3.2 (BrendanHay)
02:19:51 * hackagebot amazonka-sts 1.3.2 - Amazon Security Token Service SDK.  https://hackage.haskell.org/package/amazonka-sts-1.3.2 (BrendanHay)
02:19:53 * hackagebot amazonka-kinesis 1.3.2 - Amazon Kinesis SDK.  https://hackage.haskell.org/package/amazonka-kinesis-1.3.2 (BrendanHay)
02:19:55 * hackagebot amazonka-cloudsearch-domains 1.3.2 - Amazon CloudSearch Domain SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-domains-1.3.2 (BrendanHay)
02:20:09 <ReinH> levi: :p
02:20:15 <ReinH> levi: it's like some sort of spider sense
02:20:59 <delYsid`> levi: Yeah, I realize there is a learning curve for everything.
02:22:28 <levi> delYsid`: When you become familiar with how parsers work in Haskell, I think the similarity to your C++ continuation-passing stuff will surprise you.
02:22:32 <ReinH> Wow, I can't find the grammar for operator symbols in the report all of a sudden
02:23:06 <ReinH> Ok, it's ascSymbol
02:23:07 <levi> Especially when coupled with something like the 'pipes' library.
02:23:35 <ReinH> Ah, nice TLDR at http://stackoverflow.com/a/10548541/2225384
02:23:38 <ReinH> sedeki: ^
02:23:47 <delYsid`> levi: Whats so irritating is, that I already use parsers, but haven't understood the underlying structure enough to generalize the concept to my own needs.
02:23:56 <ReinH> https://www.haskell.org/onlinereport/lexemes.html
02:24:23 <delYsid`> Another issue is probably that I have never defined my own Monad.
02:24:27 <levi> delYsid`: When you say you use parsers, do you mean you use a parser generator like yacc or something?
02:24:46 <delYsid`> levi: I use Parsec :-)
02:24:50 <ReinH> delYsid`: you should read https://www.fpcomplete.com/school/starting-with-haskell/basics-of-haskell/8_Parser
02:24:57 * hackagebot amazonka-cloudwatch 1.3.2 - Amazon CloudWatch SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-1.3.2 (BrendanHay)
02:24:59 * hackagebot amazonka-cloudtrail 1.3.2 - Amazon CloudTrail SDK.  https://hackage.haskell.org/package/amazonka-cloudtrail-1.3.2 (BrendanHay)
02:25:01 * hackagebot amazonka-elasticache 1.3.2 - Amazon ElastiCache SDK.  https://hackage.haskell.org/package/amazonka-elasticache-1.3.2 (BrendanHay)
02:25:03 * hackagebot amazonka-importexport 1.3.2 - Amazon Import/Export SDK.  https://hackage.haskell.org/package/amazonka-importexport-1.3.2 (BrendanHay)
02:25:05 * hackagebot amazonka-s3 1.3.2 - Amazon Simple Storage Service SDK.  https://hackage.haskell.org/package/amazonka-s3-1.3.2 (BrendanHay)
02:25:19 <levi> delYsid`: There's actually not much defining of new monads going on, just combining of the existing ones and putting them in custom wrappers.
02:25:24 <delYsid`> ReinH: Will do.
02:25:25 <ReinH> delYsid`: you should also read http://dev.stephendiehl.com/fun/002_parsers.html
02:25:43 <ReinH> delYsid`: both explain this notion of parsers from the ground up, the second one perhaps more successfully
02:25:58 <ReinH> delYsid`: perhaps you will see their application to your problem once you do
02:26:11 <delYsid`> levi: OK, I've never written my own custom wrapper, then :-)
02:26:14 <levi> Continuation passing is actually closely related to monadic programming.
02:26:26 <ReinH> as a subset of all programming, yes. :D
02:26:57 <ReinH> levi: "throw a yoneda on it", as I like to say ;)
02:29:52 <levi> http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
02:30:07 * hackagebot amazonka-swf 1.3.2 - Amazon Simple Workflow Service SDK.  https://hackage.haskell.org/package/amazonka-swf-1.3.2 (BrendanHay)
02:30:09 * hackagebot amazonka-sdb 1.3.2 - Amazon SimpleDB SDK.  https://hackage.haskell.org/package/amazonka-sdb-1.3.2 (BrendanHay)
02:30:11 * hackagebot amazonka-codecommit 1.3.2 - Amazon CodeCommit SDK.  https://hackage.haskell.org/package/amazonka-codecommit-1.3.2 (BrendanHay)
02:30:13 * hackagebot amazonka-codedeploy 1.3.2 - Amazon CodeDeploy SDK.  https://hackage.haskell.org/package/amazonka-codedeploy-1.3.2 (BrendanHay)
02:30:15 * hackagebot amazonka-cloudfront 1.3.2 - Amazon CloudFront SDK.  https://hackage.haskell.org/package/amazonka-cloudfront-1.3.2 (BrendanHay)
02:33:46 <levi> ReinH: ekmett points out some of the categorical stuff in the comments there, though he doesn't mention Yoneda by name.
02:33:58 <levi> Anyway, must sleep. Bye, all.
02:34:41 <ReinH> levi: yoneda is to CPS as <$> is to $
02:34:43 <ReinH> literally
02:35:17 * hackagebot amazonka-efs 1.3.2 - Amazon Elastic File System SDK.  https://hackage.haskell.org/package/amazonka-efs-1.3.2 (BrendanHay)
02:35:19 * hackagebot amazonka-codepipeline 1.3.2 - Amazon CodePipeline SDK.  https://hackage.haskell.org/package/amazonka-codepipeline-1.3.2 (BrendanHay)
02:35:21 * hackagebot amazonka-elasticbeanstalk 1.3.2 - Amazon Elastic Beanstalk SDK.  https://hackage.haskell.org/package/amazonka-elasticbeanstalk-1.3.2 (BrendanHay)
02:35:23 * hackagebot amazonka-autoscaling 1.3.2 - Amazon Auto Scaling SDK.  https://hackage.haskell.org/package/amazonka-autoscaling-1.3.2 (BrendanHay)
02:35:25 * hackagebot amazonka-ses 1.3.2 - Amazon Simple Email Service SDK.  https://hackage.haskell.org/package/amazonka-ses-1.3.2 (BrendanHay)
02:38:19 * frerich wonders whether he'll see the amazonka-1.4.0 release today.
02:40:27 * hackagebot amazonka-support 1.3.2 - Amazon Support SDK.  https://hackage.haskell.org/package/amazonka-support-1.3.2 (BrendanHay)
02:40:29 * hackagebot amazonka-dynamodb-streams 1.3.2 - Amazon DynamoDB Streams SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-streams-1.3.2 (BrendanHay)
02:40:31 * hackagebot amazonka-redshift 1.3.2 - Amazon Redshift SDK.  https://hackage.haskell.org/package/amazonka-redshift-1.3.2 (BrendanHay)
02:40:33 * hackagebot amazonka-opsworks 1.3.2 - Amazon OpsWorks SDK.  https://hackage.haskell.org/package/amazonka-opsworks-1.3.2 (BrendanHay)
02:40:35 * hackagebot amazonka-emr 1.3.2 - Amazon Elastic MapReduce SDK.  https://hackage.haskell.org/package/amazonka-emr-1.3.2 (BrendanHay)
02:41:50 <sedeki> what is the correct way of writing this? instance (Applicative M) => Monad M where
02:42:54 <Hafydd> sedeki: just: instance Monad M where
02:43:01 <sedeki> i get a warning
02:43:10 <Hafydd> Of course, you'll also have to define instances of Applicative and Functor.
02:43:14 <sedeki> ‘M’ is an instance of Monad but not Applicative - this will become an error in GHC 7.10, under the Applicative-Monad Proposal.
02:43:24 <sedeki> aha.
02:43:41 <sedeki> so it is not done in the instance declaration, but in the class declaration...
02:43:42 <sedeki> of course
02:44:06 <Hafydd> Do you know what "Applicative a =>" means?
02:44:32 <sedeki> hmm that it is an applicative functor?
02:45:27 <ReinH> sedeki: what version of GHC?
02:45:35 <Hafydd> That's a constraint saying that in order for a type to be an instance of the Monad class, it must also be an instance of the Applicative class -- in other words, that Applicative is a superclass.
02:45:37 * hackagebot amazonka-cognito-identity 1.3.2 - Amazon Cognito Identity SDK.  https://hackage.haskell.org/package/amazonka-cognito-identity-1.3.2 (BrendanHay)
02:45:39 * hackagebot amazonka-ssm 1.3.2 - Amazon Simple Systems Management Service SDK.  https://hackage.haskell.org/package/amazonka-ssm-1.3.2 (BrendanHay)
02:45:41 * hackagebot amazonka-ml 1.3.2 - Amazon Machine Learning SDK.  https://hackage.haskell.org/package/amazonka-ml-1.3.2 (BrendanHay)
02:45:43 * hackagebot amazonka-workspaces 1.3.2 - Amazon WorkSpaces SDK.  https://hackage.haskell.org/package/amazonka-workspaces-1.3.2 (BrendanHay)
02:45:45 * hackagebot amazonka-dynamodb 1.3.2 - Amazon DynamoDB SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-1.3.2 (BrendanHay)
02:45:50 <sedeki> i'm using haskell for mac, and it is sandboxed
02:45:51 <Hafydd> Of course, that doesn't make any sense when giving an instance of a concrete type.
02:45:52 <sedeki> not sure how to check
02:46:02 <sedeki> www.haskellformac.com
02:46:04 <Hafydd> Because either the concrete type is known to be Applicative, or is known not to be.
02:48:39 <sedeki> ReinH is it too old?
02:49:01 <DEA7TH> Why aren't view patterns enabled by default, are they a bad practice?
02:50:11 <nyon> just a sanity check -- ghc doesnt depend on ncurses right?
02:50:18 <Hafydd> DEA7TH: they are not part of the current language standard.
02:50:47 * hackagebot amazonka-rds 1.3.2 - Amazon Relational Database Service SDK.  https://hackage.haskell.org/package/amazonka-rds-1.3.2 (BrendanHay)
02:50:49 * hackagebot amazonka-ds 1.3.2 - Amazon Directory Service SDK.  https://hackage.haskell.org/package/amazonka-ds-1.3.2 (BrendanHay)
02:50:51 * hackagebot amazonka-cloudwatch-logs 1.3.2 - Amazon CloudWatch Logs SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-logs-1.3.2 (BrendanHay)
02:50:53 * hackagebot amazonka-route53 1.3.2 - Amazon Route 53 SDK.  https://hackage.haskell.org/package/amazonka-route53-1.3.2 (BrendanHay)
02:50:55 <ReinH> nyon: right
02:50:56 * hackagebot amazonka-cloudsearch 1.3.2 - Amazon CloudSearch SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-1.3.2 (BrendanHay)
02:51:26 <ReinH> sedeki: the relationship between Applicative and Monad changed between 7.8 and 7.10 so our advice might need to change too
02:51:28 <DEA7TH> can I safely use them, then? are they going to be removed
02:51:42 <ReinH> DEA7TH: Yes, you can safely use them.
02:52:01 <nyon> ReinH: i just upgraded my system (totally unrelated to haskell), and now running either ghc or ghci results in this error: http://imgur.com/YVS0bMP :-|
02:52:04 <Hafydd> DEA7TH: you can safely use them as long as you intend to use a compiler (such as GHC) that supports the ViewPatterns language extension.
02:52:18 <DEA7TH> uh oh...
02:52:18 <Hafydd> DEA7TH: if you want to write Haskell2010-compliant code, however, you may not use them.
02:52:38 <DEA7TH> Hafydd: how about Haskell2016, or whatever the next version will be?
02:52:41 <ReinH> DEA7TH: GHC is the de facto standard Haskell compiler.
02:52:49 <ReinH> I'm not even sure if you could install another compiler right now
02:52:49 <Hafydd> (They're more likely to be added to the standard than removed from anything.)
02:53:13 <ReinH> DEA7TH: just go ahead and use them
02:53:28 <DEA7TH> Alright.
02:54:37 <DEA7TH> Looks like it's the only good way to pattern match on the head of a heap. My code would be a mess otherwise
02:55:07 <ReinH> yep
02:55:17 <ReinH> possibly pattern synonyms
02:55:45 <ReinH> DEA7TH: they're used by, e.g., the containers package, so theyre basically a de facto standard extension
02:55:58 * hackagebot amazonka-storagegateway 1.3.2 - Amazon Storage Gateway SDK.  https://hackage.haskell.org/package/amazonka-storagegateway-1.3.2 (BrendanHay)
02:55:59 <ReinH> but GHC's default is to conservative
02:56:00 * hackagebot amazonka-ec2 1.3.2 - Amazon Elastic Compute Cloud SDK.  https://hackage.haskell.org/package/amazonka-ec2-1.3.2 (BrendanHay)
02:56:02 * hackagebot amazonka-kms 1.3.2 - Amazon Key Management Service SDK.  https://hackage.haskell.org/package/amazonka-kms-1.3.2 (BrendanHay)
02:56:04 * hackagebot amazonka-elastictranscoder 1.3.2 - Amazon Elastic Transcoder SDK.  https://hackage.haskell.org/package/amazonka-elastictranscoder-1.3.2 (BrendanHay)
02:56:06 * hackagebot amazonka-lambda 1.3.2 - Amazon Lambda SDK.  https://hackage.haskell.org/package/amazonka-lambda-1.3.2 (BrendanHay)
02:56:07 <ReinH> *to be
03:01:08 * hackagebot amazonka-ecs 1.3.2 - Amazon EC2 Container Service SDK.  https://hackage.haskell.org/package/amazonka-ecs-1.3.2 (BrendanHay)
03:06:17 <Sindriava> Is there an extension to make lambdas using holes?
03:06:46 <Sindriava> ` (_ + 1) == \x -> (x + 1) `
03:07:07 <Sindriava> And *please*, don't say ` (+1) `, that's not the same thing.
03:08:51 <saulzar_> Sindriava, What do you mean then? Something like the mix-fix thing in agda ? 
03:09:46 <Sindriava> saulzar_: I don't know Agda, but imagine `myComplexFunction 1 2 3 _ 4 5` == `\x -> myComplexFunction 1 2 3 x 4 5` 
03:11:50 <Saizan> Sindriava: there isn't
03:11:59 <Sindriava> Aw. Oh well
03:12:16 <saulzar_> They have this thing where you can define a function like   if_then_else_  cond a b = .. 
03:12:44 <saulzar_> Where _ are holes for parameters
03:12:46 <Sindriava> Ooh, nifty. Sounds a bit like Objective-C
03:13:10 <MayIO> Hi, I'm getting the follwing error on Archlinux with ghc:
03:13:19 <MayIO> $ ghc
03:13:20 <MayIO>  /usr/lib/ghc-7.10.2/bin/ghc: error while loading shared libraries: libncursesw.so.5: cannot open shared object file: No such file or directory
03:13:23 <MayIO> Any clues?
03:13:38 <Sindriava> MayIO: I'd guess the ncurses library is missing ;)
03:13:46 <Sindriava> MayIO: How did you install GHC?
03:13:50 <raichoo> MayIO: Selfbuilt ghc with arch?
03:13:51 <MayIO> I tried to reinstall ghc and ncurses, and did full updates.  Googling for the error messages doesn't reveal anything useful.  ncurses _IS installed.
03:14:04 <MayIO> No, via sudo pacman -Suy ghc
03:14:17 <MayIO> I have haskell-core repositories.
03:14:37 <Sindriava> MayIO: Keep in mind that there may be different versions of ncurses out there. Arch can be a wild distro
03:14:45 <MayIO> Hmm, that might be it.
03:14:47 <MayIO> [haskell-core] Server = http://xsounds.org/~haskell/core/$arch
03:15:06 <Sindriava> MayIO: I'd suggest looking up where GHC looks for ncurses and then possibly just symlinking it
03:15:16 <Sindriava> MayIO: But that more of a fix than a solution
03:15:28 <MayIO> I did an strace ghc.
03:15:42 <MayIO> The first place it looks at, actually does have the file..
03:15:52 <MayIO> But I can symlink all over the place.  Might be a worth a try.
03:16:11 <Sindriava> MayIO: Then check privileges on that file. It might be that GHC doesn't have the perms to read it
03:16:30 <Sindriava> (though that should report permission denied)
03:16:51 <Sindriava> MayIO: Also keep in mind that the load path could be affected by environment variables, like "LD_LOAD_PATH" or whatever
03:17:01 <Sindriava> MayIO: Try running GHC from a pristine environment
03:17:15 <MayIO> $LD_LOAD_PATH seems to be empty
03:17:29 <Sindriava> Yeah, it's probably not named like that
03:17:56 <MayIO> Sindriava: I can `cat' that file with my user.
03:18:10 <Sindriava> Ok, hm…
03:18:29 <Sindriava> Oh yeah, it's LD_LIBRARY_PATH iirc
03:21:22 <MayIO> Fixed (but not solved) via
03:21:25 <MayIO> sudo ln -s /usr/lib/libncursesw.so.6 /usr/lib/ghc-7.10.2/bin/../haske_1dVCRhdIH7hAQWJrKwByYv/tls/i686/sse2/libncursesw.so.5
03:21:25 <indiagreen> what's the easiest way to force all elements of a Vector to WHNF?
03:21:43 <MayIO> The latter path comes from an strace on ghc.
03:21:46 <Sindriava>  indiagreen: WHNF?
03:22:07 <indiagreen> weak head normal form (i.e. what happens when you apply seq)
03:23:43 <MayIO> Hmm, the simpler sudo ln -s /usr/lib/libncursesw.so.6 /usr/lib/libncursesw.so.5, does it too.  OK, seems like a version mismatch.
03:24:09 <Sindriava> MayIO: Yeah, that seems like it
03:24:12 <Walther> sorry, a bit of a silly question, but: what does "do" actually mean? Can there be a main without do, or a do without main?
03:24:28 <MayIO> They'll probably fix it in a few days in the official repositories.  Thanks for the help.
03:24:32 <Hafydd> Oh god.
03:24:36 <MayIO> Walther: yes.
03:24:36 <frerich> Walther: Yes - there can be a main without do (e.g. 'main = putStrLn "Hello!"') and there can be a do without main.
03:24:36 <Sindriava> MayIO: What a perfect time to learn more about Nix! The package manager that allows you to install arbitrary number of versions of the same package!
03:24:47 <MayIO> Walther: do is just syntactic sugar.
03:25:08 <Walther> nod, for what?
03:25:10 <Sindriava> Walther: `do` is just sugar for (>>) and (>>=)
03:25:26 <Sindriava> Walther: do { a; b } is the same as `a >> b`
03:25:47 <MayIO> Walther: it's right assositiative.
03:25:52 <Sindriava> Walther: do { x <- a; b x } is the same as `a >>= \x -> b x`
03:26:01 <MayIO> Ie do {a; b; c} is the same as a >> (b >> c)
03:26:06 <MayIO> (But that doesn't matter too much.)
03:26:20 <MayIO> Matters a bit for >>=
03:26:53 <Walther> hmm. What does >> really stand for then? "do the thing on the right first, then do the next thing"
03:26:53 <Sindriava> MayIO: Oh yeah, that's a good point. Isn't (>>) left associative without do? that might be a pitfall I'll run into one day
03:27:16 <Sindriava> Walther: (>>) is an operator defined in the Monad typeclass
03:27:22 <Walther> it doesn't pass on the values of previous things or anything, I mean, you can do a lot of completely separated things in a main do block
03:27:28 <Sindriava> Walther: What it "does" is dependent on the instance
03:27:31 <MayIO> infixl 1 >>
03:27:49 <Sindriava> Walther: But if you squint hard enough, it's a sequence of "do the left thing and then do the right"
03:28:08 <Sindriava> Walther: Since it's defined as "a >> b = a >>= \_ -> b"
03:28:14 <MayIO> Oh, weird >>= is also infixl?
03:28:31 <Sindriava> MayIO: Yeah, same as >> it seems
03:28:41 <MayIO> I thought you'd put the parens to the right?
03:28:56 <MayIO> Maybe it's the customary lambda that's doing that?
03:29:19 <Sindriava> Maybe o.O
03:29:31 <MayIO> Actually, it does make sense, because (=<<) is like ($) and should be infixr.  Thus >>= needs to be infixl.
03:29:37 <Walther> Sindriava: Hmm, so basically a >> b is the same thing as a put through into an empty lambda that passes nothing through, passed as an argument for b (essentially making it a "move on to b without caring about a anymore")?
03:29:43 <MayIO> Walther: sorry for the sidetracking and confusion from me. ;)
03:29:51 <MayIO> Walther: yes.
03:29:57 <Sindriava> Walther: Yes.
03:30:03 <Walther> why would one need to explicitly define that behaviour though?
03:30:11 <Sindriava> Walther: Which semantically forces a to be evaluated first
03:30:16 <Sindriava> Walther: What do you mean?
03:30:34 <Walther> interesting, that sounds like we're getting there; "semantically forces a to be evaluated first"
03:30:48 <MayIO> It's a data dependency.
03:30:48 <Sindriava> Walther: Well, see this:
03:30:55 <Sindriava> a >>= \x -> b x
03:30:58 <MayIO> Haskell expresess all control dependencies as data dependencies.
03:31:16 <Sindriava> Walther: You can't evaluate b without evaluating a first, since b depends on the result of a
03:31:20 <Walther> nod
03:31:30 <Sindriava> Walther: If you throw that result away, that doesn't change anything about that
03:31:34 <MayIO> (So in some sense, control structures in Haskell (what would be for/while etc in other languages) _are_ data structures in Haskell.
03:31:34 <Walther> and with an empty lambda you cause that dependency without ...yes
03:32:03 <Walther> MayIO: hmmmm
03:32:10 <Sindriava> Walther: Since you can substitute `b` for a function that takes x and performs b
03:32:15 <Sindriava> f x = b
03:32:17 <Walther> sure
03:32:49 <Sindriava> e.g. (a >>= \_ -> b) == (a >>= \x -> f x)
03:33:00 <Sindriava> So the data dependency holds, even if you throw that away
03:33:15 <MayIO> The original paper introducing Monads for Haskell is a good read, too: http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
03:33:16 <kuribas> > let a = undefined, b = const (Just 2) in a >>= \x -> b x
03:33:17 <lambdabot>  <hint>:1:18: parse error on input ‘,’
03:33:17 <Walther> but say we have a main where one say, fetches a temperature from a sensor, humidity from the other, time from a clock, and so on, and outputs a neatly formatted weather raport
03:33:26 <kuribas> > let a = undefined; b = const (Just 2) in a >>= \x -> b x
03:33:27 <lambdabot>  *Exception: Prelude.undefined
03:33:39 <Sindriava> @karma+ kuribas 
03:33:39 <lambdabot> kuribas's karma raised to 3.
03:33:40 <Walther> it is not strictly speaking necessary to obtain the sensor information in any order, as long as the report is not passed forward before having all of the data
03:34:14 <Walther> i.e. it isn't necessary to getTemp >> getTime >> getHumid >> buildRaport
03:34:17 <MayIO> Walther: if the compiler knows that reordering is fine, it might reorder in the optimization.
03:34:43 <Walther> so how would one notate thet "just get temp, time, humidity, and *then* >> buildraport"
03:34:46 <Sindriava> I think you *can* rely on IO to do it in the specified order, though
03:34:47 <MayIO> In general the compiler has to be conservative when dealing with IO, since it doesn't have any knowledge about eg how your weather sensors work.
03:35:12 <delYsid`> Isn't s -> [(a,s)] something like the State monad?
03:35:12 <MayIO> Walther: you can't tell ghc (yet) that you don't core about order of IO.
03:35:15 <Walther> because from what I'm reading and understanding, it appears that having a do applies >> to all "rows"
03:35:24 <Sindriava> I can find it anywhere right now, but I think IO should have a guarantee of ordering by default
03:35:31 <Walther> so you get all the next function calls depending on the result of previous
03:35:51 <Sindriava> e.g. putStr "foo" >> putStr "bar" should *always* print out "foobar", no matter what
03:36:26 <Walther> so it should be possible, in theory, that I write a main without a do, have function calls getting results, and have >> only on the last call to build the raport
03:36:35 <Walther> depending on all the previous ones having completed
03:36:55 <Sindriava> Walther: Sure, you don't have to write `do` at all
03:37:16 <Sindriava> in fact, lambdabot does have some desugaring abilities so you can see it a bit more clear
03:37:38 <Walther> Is there a way to "escape" the constraint caused by "do" when you have a majority of operations depending on the previous ones but some in between that you wouldn't need >> between?
03:37:55 <Walther> other than well, grouping those into one function call where it is internally not a do
03:38:04 <kuribas> > let a = undefined, b = const (Identity 2) in a >>= \x -> b x
03:38:05 <lambdabot>  <hint>:1:18: parse error on input ‘,’
03:38:10 <kuribas> > let a = undefined; b = const (Identity 2) in a >>= \x -> b x
03:38:11 <lambdabot>  Identity 2
03:38:27 <kuribas> Sindriava: ^^
03:38:51 <Sindriava> neat
03:40:08 <kuribas> > let a = undefined; b = const (+ 2) in a >>= \x -> b x 3
03:40:10 <lambdabot>      No instance for (Show (m0 b0))
03:40:10 <lambdabot>        arising from a use of ‘show_M144375989485726120921509’
03:40:10 <lambdabot>      The type variables ‘m0’, ‘b0’ are ambiguous
03:40:36 <kuribas> > let a = undefined; b = const (+ 2) in (a >>= \x -> b x) 3
03:40:38 <lambdabot>  5
03:41:28 <kuribas> Sindriava: the order of evaluation isn't always intuitive.
03:42:46 <kuribas> Sindriava, Walther : if (>>=) doesn't use "case", a may not be evaluated at all.
03:43:43 <Walther> so my next question is: if I don't have "do" or >> in my main, is it possible that the different lines get executed in arbitrary order?
03:43:52 <delYsid`> @let f = s -> case s of (x:xs) -> [([x],xs)]; [] -> [([],[])]
03:43:52 <lambdabot>  Parse failed: Parse error: ->
03:44:07 <Walther> without explicitly labeling it "parallel-conpatible"
03:44:36 <delYsid`> hmm
03:45:33 <delYsid`> @let f = \s -> case s of (x:xs) -> [([x],xs)]; [] -> [([],[])]
03:45:35 <lambdabot>  Defined.
03:45:40 <liste> Walther what different lines? if you have multiple actions, how would you combine them without >>= or >> ?
03:45:53 <liste> <*> ?
03:46:18 <kuribas> Walther: in the IO monads statements are executed sequentially (without parallel IO).
03:46:26 <Walther> liste: that's what I'm wondering; why is the do or >> required, if it is always required anyway
03:46:45 <kuribas> Walther: semantically at least, because the compiler could rearrange things.
03:47:24 <kuribas> Walther: both do and (>>) are defined in terms of (>>=)
03:47:46 <Walther> yes, where >> is a >>= with an emptifying lambda inbetween
03:47:57 <kuribas> Walther: yes
03:48:11 <Walther> but why is that required to be explicitly mentioned in code, if it is always required in some form anyway
03:48:30 <kuribas> Walther: what do you mean by required?
03:48:36 <liste> Walther that's what do is for, to reduce the >>'s and >>='s
03:48:51 <kuribas> Walther: "do" is mostly syntactic sugar.
03:48:57 <Walther> kuribas: like liste said earlier, if one wants to have multiple actions
03:49:15 <Walther> Sure, it is syntactic sugar for >> on every line/action
03:49:26 <keko_> I think there might be confusion here between _actions_ and _computations_
03:49:33 <kuribas> Walther: >>= is the only primitive that can combine IO actions.
03:49:45 <keko_> or the difference between doing IO and evaluating something
03:49:56 <liste> > putStrLn "hello" <*> putStrLn "world"
03:49:57 <lambdabot>      Couldn't match type ‘()’ with ‘() -> b’
03:49:57 <lambdabot>      Expected type: IO (() -> b)
03:49:57 <lambdabot>        Actual type: IO ()
03:50:03 <statusfailed> Is there a way to make cabal sandboxes use less disk space?
03:50:03 <liste> > putStrLn "hello" *> putStrLn "world"
03:50:05 <lambdabot>  <IO ()>
03:50:12 <Walther> but if do isn't required, and >> means "you need to do these things in this order", wouldn't it be possible to have a piece of code that does multiple things but doesn't care about their order, by just not using do or >>
03:50:28 <keko_> yes
03:50:33 <keko_> most haskell code is like that
03:50:50 <kuribas> Walther: >> doesn't mean do things in order.
03:50:57 <keko_> as long as "does multiple things" means "evaluates multiple functions" rather than "does IO"
03:51:13 <keko_> that is, as long as the multiple things don't have side effects
03:51:14 <kuribas> Walther: neither does (>>=).  It does so for the IO monad, but not for any monad.
03:51:37 <kuribas> See my example above.
03:52:25 <liste> @hackage async -- Walther if you want to do I/O out of order, check this
03:52:26 <lambdabot> http://hackage.haskell.org/package/async -- Walther if you want to do I/O out of order, check this
03:53:25 <kuribas> The description that monads are for sequencing computations is simply wrong.  However monads "can be used" for sequencing computations, but it is not true in general.
03:53:27 <Walther> yes, i'm aware there exists packages that help you do async stuff
03:53:37 <keko_> > [1, 2, 3] >>= \n -> replicate n n
03:53:39 <lambdabot>  [1,2,2,3,3,3]
03:53:57 <Walther> I'm just wondering why leaving out >> and >>= doesn't already net you that
03:54:10 <Walther> if >> and >>= imply ordering / prequisites
03:54:35 <kuribas> Walther: they don't
03:54:35 <keko_> how would you leave them out?
03:54:55 <kuribas> Walther: >> and >>= don't imply ordering
03:55:14 <Walther> of evaluation, that is
03:55:34 <kuribas> Walther: no
03:56:26 <kuribas> In the IO monad, yes, but when you use parallel computation and threads, even that is not true.
03:57:51 <Walther> I'm just curious because somehow the >> feels like a compulsory line ending like ; in other languages
03:57:56 <delYsid`> hmm, I guess I need to combined Monad [] and Monad ((,) x) somehow.
03:58:22 <Walther> and I'm wondering why it would be compulsory
03:58:57 <kuribas> Walther: Because otherwise you cannot combine IO actions, due to haskell being a purely functional language.
03:59:07 <Intolerable> wait, where did Monad ((,) x) come from?
04:00:25 <Walther> kuribas: but what if the IO actions don't depend on each ither, at all?
04:00:35 <Walther> o*
04:00:43 <Intolerable> use Concurrently then
04:02:18 <kuribas> Walther: if your action contains a side effect, like reading a key, or outputting something to the screen, then they have to be evaluated.
04:02:59 <kuribas> Walther: Even if they don't depend on each other, the computer needs to know which order to use (or parallel).
04:03:38 <Walther> I'm just wondering if >> and >>= purposes are to make things be in series, why isn't omitting them considered a permission to run them parallel
04:04:11 <kuribas> Walther: you know the type of main?
04:04:26 <Walther> kuribas: main is IO, right?
04:04:29 <kuribas> :t main
04:04:30 <lambdabot>     Not in scope: ‘main’
04:04:30 <lambdabot>     Perhaps you meant ‘min’ (imported from Data.Ord)
04:04:44 <liste> Walther their purpose is to combine values of monadic types
04:04:46 <nshepperd> what would 'leave them out' mean?
04:05:05 <Walther> nshepperd: not have "do" and not have >> on ends of lines either
04:05:20 <nshepperd> "foo bar" is function application, how would you even combine two values any other way without an operator?
04:05:40 <kuribas> Walther: yes.  So if you have two actions, how can you pass them both to "main", without combining them?
04:06:08 <kuribas> :t (print "hello") (print "world")
04:06:09 <lambdabot>     Couldn't match expected type ‘IO () -> t’ with actual type ‘IO ()’
04:06:09 <lambdabot>     The function ‘print’ is applied to two arguments,
04:06:09 <lambdabot>     but its type ‘[Char] -> IO ()’ has only one
04:07:58 <Walther> so in a sense >> is a compulsory notation of a line/expression ending
04:08:22 <Walther> why couldn't the compiler infer that from a line ending and indentation
04:08:24 <nshepperd> um, well, \n is a compulsary notation of a line ending
04:08:36 <nshepperd> that what 'do' notation is for
04:08:47 <kuribas> Walther: (>>) is not syntax, it's a function.
04:09:21 <Walther> yes, so why wouldnt main = (print "hello) \n (print "world") be enough, if we don't care about if we output helloworld or worldhello
04:09:26 <Walther> note the lack of do
04:09:51 <nshepperd> because that syntax already means function application
04:09:59 <kuribas> Walther: That's the difference between haskell and most languages, where statements are seperated by syntax.
04:10:50 <Walther> please elaborate
04:11:32 <maerwald> ';' is not syntax?
04:12:01 <aweinstock> :t (>>)
04:12:02 <lambdabot> Monad m => m a -> m b -> m b
04:12:19 <aweinstock> > length [(>>), (>>)]
04:12:21 <lambdabot>      No instance for (Monad m0) arising from a use of ‘>>’
04:12:21 <lambdabot>      The type variable ‘m0’ is ambiguous
04:12:21 <lambdabot>      Note: there are several potential instances:
04:12:22 <kuribas> maerwald: it's syntactic sugar for (>>), which is a function.
04:12:36 <maerwald> so it is syntax if it's syntactic sugar
04:12:44 <aweinstock> > length [(>>) :: IO a -> IO b -> IO b, (>>)]
04:12:46 <lambdabot>  2
04:13:01 <Walther> ah right, so ; is the same as >>
04:13:06 <kuribas> maerwald: but it's not syntax for statements.
04:13:22 <Walther> so it can indeed be considered a "compulsory line/expression ending"
04:13:25 <nshepperd> erm I would say in haskell that (;) is syntax
04:13:39 <nshepperd> it's a substitute for \n, in most cases
04:14:04 <sunnymilk> \n + some number of spaces
04:14:21 <frerich> Haskell has no statements in the first place.
04:14:35 <kuribas> frerich: that's the point I am trying to make.
04:14:38 <aweinstock> ; (in the context of do-notation) becomes >> or >>= (e.g. (do { x <- a; f x}) simplifies to (a >>= f))
04:14:40 <liste> frerich++
04:14:57 <nshepperd> Walther: I don't see why you think (print "hello") \n (print "world") is better than (print "hello") <operator> (print 
04:15:05 <nshepperd> "world"), though
04:15:42 <kuribas> Walther: do notation looks like imperative statements, but it is quite different under the hood.
04:15:50 <aweinstock> is there a good writeup of do-notation desugaring? I don't remember learning about it from any specific place, just gradually picking it up
04:15:52 <nshepperd> it's 'syntax' either way, and in the latter case doesn't require adding anything to the language
04:15:53 <Walther> nshepperd: coming from other languages, ; or a \n is commonly used as an ending for an expression, whereas >> is very different
04:16:01 <nshepperd> since operators already exist
04:16:04 <Walther> and it can be easily assumed it does something very different
04:16:08 <kuribas> aweinstock: it's described in the standard.
04:16:22 <aweinstock> @where haskell standard
04:16:22 <lambdabot> http://haskell.org
04:16:37 <frerich> aweinstock: It's also explained in the section "do notation" of http://learnyouahaskell.com/a-fistful-of-monads
04:17:19 <aweinstock> found it: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
04:18:34 <kuribas> Walther: Because do notation translates to function application.  (>>) is just a function like (+).
04:18:44 <nshepperd> or why that's better than writing 'do foo\n   bar'. is the burden of writing two letters at the start of a block really enough to justify making it ambiguous?
04:19:38 <kuribas> maerwald, nshepperd I didn't say ';' isn't syntax.  (>>) isn't syntax, which is more primitive in haskell.
04:19:41 <frerich> Does anybody know whether there's a language extension which makes dealing with multiline string literals less noisy? The "backslash at start and end of line" syntax is a bit ugly.
04:20:18 <Philonous> frerich, You can write a quasi quoter that just returns the string
04:21:09 <kuribas> frerich: I believe there exist a TH extension for that, idk if it qualifies as less ugly.
04:21:35 <Philonous> str = QuasiQuoter{quoteExp = litE . stringL }
04:21:48 <Philonous> then you can write [str| ..... <newline> ... |]
04:22:34 <kuribas> frerich: http://hackage.haskell.org/package/string-qq
04:24:56 <Philonous> That doesn't strip newlines and indentation, though. But you can easily extend it to do it for you
04:27:05 <akegalj> I am running my program with '+RTS -N1 -sstderr -p -hd' flags but -sstderr output and .hp show different results of total memory in use. I am aware that with profing total memory is jumping higher. Is this memory discounted in .hp analysis?
04:27:31 <akegalj> .hp graph shows 3 times less memory footprint then -sstderr
04:27:38 <Walther> Thanks for the explanations, i hope i learned something new
04:37:21 <Rurik> ghci> [if 5 > 3 then "Woo" else "Boo", if 'a' > 'b' then "Foo" else "Bar"]  
04:37:22 <Rurik> ["Woo", "Bar"]  
04:37:27 <Rurik> What is happening here?
04:38:05 <Rurik> oh wait, got it
04:40:36 <aweinstock> > 'a' > 'b'
04:40:38 <lambdabot>  False
04:42:28 <fvgvxmpv1> > 'a' < 'b'
04:42:29 <lambdabot>  True
04:55:20 <quchen> frerich: \ \ is much better than lists+concat at least.
04:55:26 <DEA7TH> In a let statement, I'm allowed to reference variables which are defined forward in the same let?
04:55:34 <quchen> Yes.
04:55:38 <DEA7TH> Awesome!
04:55:56 <quchen> a "let" block is much like the top level of your module, only not at the top level.
04:57:06 <quchen> > let x = 1:y; y = 0:x in take 10 x
04:57:08 <lambdabot>  [1,0,1,0,1,0,1,0,1,0]
05:05:51 <Xnuk> > take 10 (concatMap (const [1,0]) (repeat 0))
05:05:53 <lambdabot>  [1,0,1,0,1,0,1,0,1,0]
05:20:07 <DEA7TH> My program doesn't work and I find myself needing to use print in the middle of the program (before it can reach IO). How should I approach this? I need to view the value of a variable in mid-execution.
05:20:44 <c_wraith> DEA7TH: look at the Debug.Trace module
05:20:56 <DEA7TH> c_wraith: I already did, but it didn't print anything.
05:21:18 <c_wraith> DEA7TH: then you've discovered laziness makes debugging prints weirder. :)
05:21:45 <c_wraith> DEA7TH: laziness means that you only see output if the expression containing the trace is forced to be evaluated
05:21:49 <DEA7TH> My program probably gets stuck in infinite recursion in the middle of a pure function. 
05:22:07 <DEA7TH> Hm, I'll try to trace something which needs to be evaluated.
05:22:38 <c_wraith> DEA7TH: a common trick is to put an extraneous equation in at the start for a function..  fooo _ _ _ | trace "hi!" False = undefined
05:23:33 <c_wraith> DEA7TH: since guards always need to be evaluated to see if that equation will be selection when that function is used, it means that you will get output whenever a call to that function is evaluated
05:24:05 <DEA7TH> I probably used trace wrongly.
05:24:41 <c_wraith> It's a little tricky.  You have to remember that the compiler thinks trace is a pure function
05:25:47 <c_wraith> Think of it as a decorator.  You replace an expression e with the expression trace (value to print) e
05:26:42 <c_wraith> There's also the traceShow helper for if you want to just simply output a non-string after calling show on it
05:26:59 <DEA7TH> for some reason, trace "foo" "bar" still doesn't work
05:27:11 <Intolerable> then "bar" is never being evaluated
05:27:51 <quicksilver> if face trace *is* working
05:27:54 <quicksilver> in fact, that is
05:27:59 <hackrilege> :t trace
05:28:00 <lambdabot> Not in scope: ‘trace’
05:28:04 <quicksilver> because it's telling you taht evaluation never reaches that point
05:28:11 <Intolerable> :t Debug.Trace.trace
05:28:11 <quicksilver> which is a valuable peice of evidence in pinpointing your bug
05:28:12 <lambdabot> String -> a -> a
05:28:30 <hackrilege> :t Debug.Trace.trace
05:28:31 <lambdabot> String -> a -> a
05:28:53 <quicksilver> As a more general answer to DEA7TH's original quesiton though: I would decompose your program into smaller functions which you can test individually in GHCi
05:29:07 <quicksilver> and then you can work towards finding out why the whole thing doesn't work as you want it to
05:29:11 <quicksilver> that's how I debug haskell personally.
05:29:16 <hackrilege> Yes unit tests ftw
05:29:21 <DEA7TH> that's pretty difficult, I'm doing state-space exploration and those are difficult to debug in the first place
05:29:43 <hackrilege> Why?
05:29:44 <DEA7TH> but I think I know where the problem is, I just need to print out the fringe
05:30:04 <DEA7TH> because the program does something very general
05:30:23 <DEA7TH> similar to how machine learning algorithms are difficult to debug
05:30:35 <hackrilege> It can't be broken into smaller testable chunks?
05:30:56 <hackrilege> I don't know why learning algorithms are hard to debug...
05:31:28 <kuribas> DEA7TH: you can output lot's of diagnostic information using trace, then check that by hand.
05:31:32 <bennofs> Because inspecting the state of the "brain" doesn't generally yield much useful information i'd assume
05:31:34 <DEA7TH> they might compile and give output which looks right, while still having a bug
05:31:37 <hackrilege> They are deterministic and modular?
05:31:57 <quicksilver> it's hard to debug things which only work on massive datasets and have massive internal state
05:32:02 <quicksilver> for sure.
05:32:04 <hackrilege> They should be made of testable components
05:32:11 <quicksilver> generally such things have bugs and nobody knows :P
05:32:34 <bennofs> hackrilege: but the components may work fine in isolation and still the composition might have bugs
05:32:40 <DEA7TH> I'll now read the advice above, it's my first time using trace so I guess it will help
05:33:02 <quicksilver> bennofs: then the bug must be in the way they are composed!
05:33:52 <hackrilege> Then test also the compositions... I was taught if you can't write a unit test then you don't understand what your program is doing... I guess your telling me that this is the case?
05:34:58 <cluzz> Is there a function to get [Int] -> [a] -> [a] that returns all the elements from [a] with indices from [Int]?
05:35:13 <quicksilver> cluzz: zipwith (!!)
05:35:25 <cluzz> thanks :)
05:35:29 <DEA7TH> could it be this? 
05:35:30 <DEA7TH>         node1 = [references node2]
05:35:30 <DEA7TH>         node2 = [references node1]
05:35:36 <quicksilver> it's a bit slow to do that with lists of any substantial length (say more than 100)
05:35:44 <quicksilver> also I have hte parameters the wrong way around:
05:35:44 <hackrilege> :t elems
05:35:45 <Intolerable> that's super slow with lists tho
05:35:46 <lambdabot> Ix i => Array i e -> [e]
05:35:47 <cluzz> Yeah.. doesn't matter ;P
05:35:52 <DEA7TH> I assumed it will use pointers, rather than create a new instance each time it needs to access the reference
05:35:53 <quicksilver> @type zipWith (!!)
05:35:54 <lambdabot> [[c]] -> [Int] -> [c]
05:36:00 <cluzz> uni assignment i'm stuck on, the list is just 5 long
05:36:12 <quicksilver> DEA7TH: you've just made a recursion
05:36:24 <quicksilver> as to whether that is what you want, I don't know!
05:36:26 <Intolerable> there's also backpermute from Data.Vector
05:36:30 <Intolerable> if you can shove it into a vector
05:36:46 <Intolerable> :t Data.Vector.backpermute
05:36:47 <lambdabot> Data.Vector.Vector a -> Data.Vector.Vector Int -> Data.Vector.Vector a
05:36:53 <DEA7TH> quicksilver: I want to allocate only one copy of each of node1 and node2 in memory
05:37:03 <DEA7TH> not a copy per access
05:37:18 <quicksilver> @type \indices list -> map (list!!) indices
05:37:19 <lambdabot> [Int] -> [b] -> [b]
05:37:22 <hackrilege> :t map (map !!)
05:37:23 <lambdabot>     Couldn't match expected type ‘[b]’
05:37:23 <lambdabot>                 with actual type ‘(a0 -> b0) -> [a0] -> [b0]’
05:37:23 <lambdabot>     Probable cause: ‘map’ is applied to too few arguments
05:37:38 <quicksilver> cluzz: I was actually wrong in my first answer. Correct one there ^^ map (list!!) indices
05:37:57 <quicksilver> DEA7TH: that does indeed only allocate 1 copy of each. but it defines them recursively.
05:37:59 <Intolerable> :t \x y -> pure x <$> ZipList y
05:38:00 <lambdabot> b -> [a] -> ZipList b
05:38:09 <quicksilver> I suspect that's not what you are expecting.
05:38:16 <Intolerable> :t \x y -> pure x <*> ZipList y
05:38:16 <lambdabot> (a -> b) -> [a] -> ZipList b
05:38:22 <Intolerable> erm
05:38:24 <Intolerable> thats not right
05:39:23 <DEA7TH> it explodes when I try to show a node :P but otherwise I assume it would be fine
05:39:43 <quicksilver> I very much doubt it DEA7TH 
05:40:03 <quicksilver> data-level mutual recursion like that produces a looped in memory structure
05:40:03 <DEA7TH> quicksilver: why?
05:40:10 <DEA7TH> why is that bad
05:40:11 <quicksilver> I can't imagine that's what you want
05:40:17 * quicksilver shrugs
05:40:40 <DEA7TH> looped in memory structure?
05:40:49 <hackrilege> (hackrilege) :t (map (!!)) .flip
05:41:02 <hackrilege> :t (map (!!)) .flip
05:41:03 <lambdabot>     Couldn't match type ‘b -> a1 -> c’ with ‘[[a]]’
05:41:03 <lambdabot>     Expected type: (a1 -> b -> c) -> [[a]]
05:41:03 <lambdabot>       Actual type: (a1 -> b -> c) -> b -> a1 -> c
05:41:09 <cluzz> ahh it works ;D
05:41:14 <cluzz> thanks, been stuck on this all day
05:41:23 <quicksilver> I'm purely guessing. Without seeing more of your code and understanding your intentions I can't really be more precise.
05:42:08 <hackrilege> Does anyone know how to start a private message with lambdabot?
05:42:23 <bennofs> hackrilege: type /query lambdabot 
05:42:30 <hackrilege> Thanks
05:42:38 <Intolerable> or /msg lambdabot
05:43:13 <bennofs> msg only sends a single message though
05:48:46 <DEA7TH> Solved! Couldn't get trace to work, though.
05:50:50 <JackSierkstra> Can somebody help me with a little problem I got? : http://lpaste.net/8604061486760853504
05:53:15 <geekosaur> JackSierkstra, I would suggest trying the haskell-cafe mailing list
05:53:26 <lyxia> JackSierkstra: I thought the depth should be bounded already, except that terms just get large quickly.
05:53:58 <JackSierkstra> Well, I don't know how to bound the depth..
05:54:14 <hackrilege> (DEA7TH) so in the end could you have caught it with unit tests?
05:54:32 <JackSierkstra> geekosaur: Why should I try that list? I already got some help from lyxia already last time.
05:54:44 <JackSierkstra> This is just a follow up on that problem
05:55:34 <DEA7TH> hackrilege: Maybe, but only if I find a reference implementation to test it against. Anyway it's a toy project
05:55:53 <hackrilege> Ok
05:56:13 <lyxia> JackSierkstra: this perhaps   verboseCheckWith (stdArgs{maxSize=5})
05:56:31 <aweinstock> JackSierkstra: geomList g = oneof [return <$> g, (:) <$> g <*> geomList g] -- produces a list with 50% chance of 1 element, 25% chance of 2 elements, and so on
05:57:08 <JackSierkstra> Wow, nice. Let me try it out.
05:57:12 <aweinstock> use (geomList arbitrary) instead of (arbitrary) for sublists
05:57:57 <aweinstock> I came up with it to help someone else with the same issue: http://lpaste.net/139737
05:57:58 <hackrilege> Can we write a compiler from Intel to arm in Haskell? Or an Intel emulator which runs on arm?
05:59:03 <JackSierkstra> Thnx lyxia: that works!
05:59:48 <hackrilege> It seems like it should be a simple implementation of a virtual machine
06:01:23 <hackrilege> And that containing the arm and Intel architecture specs (the api) should be sufficient, am I missing something?
06:01:41 <c_wraith> hackrilege: well, there's QEMU
06:01:58 <hackrilege> I'll check that, one sec
06:02:02 <c_wraith> hackrilege: but in general, there's way more to a computer than the CPU, and you need to emulate all of it.  All the IO systems, etc
06:02:18 <hackrilege> That should be minimal
06:02:44 <c_wraith> QEMU isn't fast, by the way.  It's just an ISA interpreter.
06:02:53 <geekosaur> "minimal"? don't bet on that...
06:03:10 <hackrilege> Sound display keyboard mouse network sockets, can't think of any more, maybe the motion sensors of the phone and the touch screen...
06:03:25 <c_wraith> Ok, now I'm with geekosaur.  That's not minimal.
06:03:30 <c_wraith> Especially when timing issues come into play
06:03:41 <aweinstock> hackrilege: each of those is a ton of code on their own to get correct
06:03:43 <geekosaur> sockets wouldn't normally be part of that, they're OS level
06:03:58 <geekosaur> network driver definitely is, and I think you're underestimating the complexity there
06:04:04 <bennofs> hackrilege: graphics card? 
06:04:07 <kaidelong> was trying to think of a good thing to do with unfoldCofree
06:04:11 <kaidelong> decided on fizzbuzz
06:04:15 <geekosaur> vmware emulates some common things and provides its own drivers for others (notably video)
06:04:40 <geekosaur> (but also emulates a simple 640x480 VGA)
06:05:10 <c_wraith> kaidelong: I recently realized that coiter creates game trees from a "list all legal moves from here" function!
06:05:12 <geekosaur> also, if you think keyboard emulation is simple, go look at the documentation for the 8051 chip >.>
06:05:50 <bennofs> c_wraith: heh, that's nice
06:05:59 <geekosaur> which most keyboards have to emulate one way or another on PC-like hardware. (granted you may be able to get away with USB keyboard only, but even that has some backward compatibility "fun")
06:06:06 <aweinstock> c_wraith: where's the definition of coiter?
06:06:11 <bennofs> aweinstock: free
06:06:13 <bennofs> @hackage free
06:06:13 <lambdabot> http://hackage.haskell.org/package/free
06:06:18 <c_wraith> aweinstock: Control.Comonad.Cofree
06:06:20 <Intolerable> Control.Comonad.Trans.Coiter in free
06:06:30 <hackrilege> Opengl has it's own shaders for graphics cards, and we have various tools for compiling to both architecture. As the specification to both should be finite and similar, how is it any more complex than pinning between the two protocols?
06:07:27 <bennofs> hackrilege: the OS needs to talk to the graphics card. You either need to write your own graphics drivers for each OS or emulate a card with drivers available already
06:07:28 * geekosaur notes, by the by, that qemu provides sparc and powerpc emulators that are more or less useless because they emulate nonexistent hardware so real OSes for those pretty much do not have drivers compatible with them
06:08:01 <kaidelong> http://codepad.org/A1XGBgeH
06:08:32 <bennofs> is it possible to implement list-like fusion rules for Free/Cofree?
06:08:37 <geekosaur> (the ppc one emulates PREP, and there was only one actual implementastion of that --- an early proof of concept for PPC Mac, which was abandoned such that no released version of MacOS ran on it)
06:09:37 <kaidelong> bennofs: I wouldn't see what would stop you in the cofree case
06:09:47 <kaidelong> it's "just" a lazy stream
06:09:52 <kaidelong> so you could update it in place
06:10:05 <kaidelong> at least, for certain functors
06:10:27 <hackrilege> Geekosaur,  you were working with prolog right? Admittedly hardware drivers aside, any purely numeric program should be translatable through prolog right?
06:10:27 <kaidelong> I guess you could run into problems with functors like []
06:10:35 <geekosaur> hackrilege, opengl is not a hardware interface. somewhere there is glue that interfaces the hardware with the API (in xorg it's the mesa component) and it has separate drivers for each video card
06:10:38 <c_wraith> Cofree IO is a streaming IO abstraction!  Well, not very abstract.  It's actually the simplest possible streaming IO.  Cofree is remarkably flexible.
06:11:03 <hackrilege> But we can use those drivers
06:11:04 <kaidelong> I'm not sure how the free case could be subject to fusion, though
06:11:20 <kaidelong> free needs its structure and is really all about its structure
06:11:38 <kaidelong> it's more like free magmas than like fusion-prone free monoids, I guess
06:11:43 <geekosaur> ...and that interface also has a lower level component (DRM/DRI) involving a kernel module that talks to the hardware
06:13:06 <geekosaur> hackrilege, I don't see what prolog has to do with it
06:13:10 <hackrilege> I guess an intermediate stage would be to implement a minimal OS to act as an intimidate vm.
06:13:37 <geekosaur> also, "anu purely numeric program" as soon as you want to see the result of the computation, it is no longer purely numeric
06:13:56 <hackrilege> Prolong or any Turing equivalent representation of a finite state machine could represent the computations contained within the exe
06:14:49 <hackrilege> Perhaps this is not the minimal route to getting Haskell to compile to arm...
06:16:20 <hackrilege> Though a minimal intimidate OS for the translation between architectures could be very useful
06:16:33 <quicksilver> haskell already does compile to arm tho?
06:16:38 <hackrilege> No
06:16:59 <quicksilver> rly? because it did, like, 4 years ago
06:17:07 <hackrilege> Yeh it broke
06:17:22 <CpnStumpy> Does anyone know how to move my cabal folder on windows from Roaming? I want all my cabal stuff to be looked for somewhere else
06:17:31 <CpnStumpy> I presume there's an environment variable I can change for it, but don't know what
06:18:07 <hackrilege> And the status of Linux on arm with debootstrap and prior is unstable, so the cross compiler cannot be built on android
06:18:12 <freq47> i am stumped on something in a haskell tutorial
06:18:27 <hackrilege> Proot not prior
06:18:50 <freq47> how does tokenize :: String -> [Token] tokenize str = map tokenizeChar str
06:19:01 <quicksilver> hackrilege: I can see postings as recently as this august on the ghc-iphone list.
06:19:06 <quicksilver> they don't suggest that it doesn't work
06:19:18 <freq47> simply to tokenize = map tokenizeChar
06:19:22 <hackrilege> That's OS, I mean android sorry
06:19:35 <quicksilver> hackrilege: ok but there is no problem with compiling GHC to ARM
06:19:35 <hackrilege> IOS
06:19:40 <quicksilver> that part works fine.
06:19:46 <quicksilver> you're talking about OS support for android
06:19:49 <Intolerable> freq47: function x = otherFunction x is the same as function = otherFunction
06:19:50 <quicksilver> the ARM archicture works.
06:19:57 <freq47> i know its currying, because the tutorial says it
06:20:13 <CpnStumpy> You're not stumped, you're just learning what it feels like to write Haskell. It's the sensation of learning there are a bunch of people too smart out there, and you're not one of them. Oh wait, I was speaking for myself there, maybe you're one of them.
06:20:25 <hackrilege> Why can't I use the IOS compiler since it targets the device architecture?
06:21:02 <freq47> why is it that function x = otherFunction x is the same as function = otherFunction
06:21:12 <hackrilege> Same add when and used Intel I guess...
06:21:14 <hackrilege> As
06:21:20 <hackrilege> Mac
06:21:29 <Intolerable> :t reverse
06:21:30 <kaidelong> freq47: that is called an eta reduction, the basic idea is that if you generate a value by taking an extra parameter, it's the same as just generating the function itself
06:21:30 <lambdabot> [a] -> [a]
06:21:36 <Intolerable> :t \x -> reverse x
06:21:37 <lambdabot> [a] -> [a]
06:22:01 <bennofs> hackrilege: I google search found https://github.com/sseefried/docker-build-ghc-android
06:22:10 <hackrilege> Thanks
06:22:34 <exio4> freq47: function x = otherFunction x is `the same` (nearly) function = \x -> otherFunction x, maybe that way it becomes a bit clearer how a lambda abstraction and then application can be eliminated 
06:23:37 <hackrilege> Wow that's great I didn't know that anyone had revised the old nerocyte ghc-android
06:24:19 <hackrilege> Iv asked here repeatedly too! I thought it was dead.
06:24:53 <hackrilege> Thanks I'll investigate. Has anyone managed to build this project successfully?
06:24:54 <freq47> my brain is hurting but i think i am seeing now
06:25:35 <CpnStumpy> freq47: think of the = as equality/definition, *not* assignment and then think of this: func = otherFunc is like x = y right? Now func x = otherFunc x is like x * 1 = y * 1, the 1 is irrelevant right? It's exactly the same as x = y, like x + 1 - 5 = y + 1 - 5 is still the same as x = y
06:27:57 <CpnStumpy> when you have an equation with the same variables on each side you can cancel them out by i.e. x + 1 - 5 = y + 1 - 5 you can add 5 to both sides and subtract one from both sides and you get x = y without having lost the actual value of x, or y. You just simplified the equation. Haskell does that when you assign a function with the same signature to a function with the same signature - parameters can be cancelled out
06:27:57 <CpnStumpy>  while the functions maintain the same value
06:27:58 <bennofs> hackrilege: https://hub.docker.com/r/sseefried/debian-wheezy-ghc-android/ I think is a binary image
06:28:49 <hackrilege> It seems like the kind of thing that would be better built on an Intel Linux box, as I say, proot Linux on android is down arm (it worked on the previous version of Android)
06:29:16 <hackrilege> A binary! Sweet
06:29:27 <bennofs> hackrilege: problem is that this probably doesn't support TemplateHaskell :/
06:29:44 <hackrilege> I don't even know what that is...
06:29:50 <bennofs> hackrilege: it
06:29:54 <kaidelong> I thought GHC 7.10.2 could do TH when cross compiling
06:30:14 <kaidelong> so long as you had a way to emulate the target env available
06:30:31 <bennofs> kaidelong: yes, but this is GHC 7.8 and GHC 7.10 only has the possibility to do it, I don't think there is integration with any emulator except for GHCJS via nodejs yet 
06:30:36 <hackrilege> Something about auto generating code for the ffi...
06:30:52 <geekosaur> just auto generating code
06:30:52 <freq47> very helpful CpnStumpy
06:31:17 <geekosaur> the bigger problem for you is that it also rules out ghci for the most part
06:34:50 <freq47> haskell is trully amazing with its composition
06:35:16 <hackrilege> Noo! I want ghci
06:38:32 <jgertm> is there a way to inspect how an automatically derived typeclass is instantiated?
06:39:52 <geekosaur> -ddump-deriv?
06:46:28 <aweinstock> freq47: the specific name for (\x -> f x) being the same as (f) is "eta-reduction" (or "eta-expansion")
06:49:32 <quicksilver> haskell violates eta-equivalence! monomorphism restriction! memoization! we're all DOOMED
06:49:45 <quchen> More importantly, GHC inlining.
06:49:47 <Intolerable> rip
06:50:14 <quchen> Hm, that's probably memoization in a sense. Nevermind
06:51:05 <RageD> I want to use the Network.Transport layer for a service. That being said, is there any way to connect to (for instance) the TCP implementation from non-Network.Transport clients? Say I want a client in another language or want to do a quick netcat to debug something. Any thoughts?
06:53:40 <quicksilver> I would imagine that might be hard, but I have no idea what their encoding is like
06:53:54 <quicksilver> dunno if any network-transport experts awake. dcoutts ?
06:54:00 <RageD> afaict, it looks like there is a special handshake which is beyond the scope of TCP (to determine redundant endpoints), but was wondering if anyone else had seen this
06:55:05 <freq47> thanks for the help, much appreciated
06:56:47 <jgertm> geekosaur: thanks, thats what i was looking for
07:11:50 <Reshi> How is the ghc-ios project? Sounds really fun since I was just getting into iOS too. 
07:12:24 <Reshi> Aaand it will take hours to update Xcode nevermind
07:14:48 <trumar8> I'm trying to compile my executable with stack with the ability to create a cost centre turned on. I'm running:
07:14:50 <trumar8> stack install --enable-executable-profiling --enable-library-profiling --ghc-options="-prof -fprof-auto -rtsopts"
07:15:04 <trumar8> And I'm getting "Failed to load interface for ‘GHC.Integer.Type’         Perhaps you haven't installed the "p_dyn" libraries for package ‘integer-gmp-1.0.0.0’?"
07:15:17 <bennofs> trumar8: do not pass -prof via --ghc
07:15:23 <bennofs> --ghc-options*
07:15:25 <trumar8> oh.
07:16:24 <trumar8> bennofs: Is there a list of which --ghc-options options that /are/ still relevant with stack? Or does that also apply to cabal ?
07:16:34 <bennofs> trumar8: it does also apply to cabak
07:23:21 <trumar8> Where can I find the git repo for the pages at https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ ?
07:24:36 * hackagebot epub-tools 2.8 - Command line utilities for working with epub files  https://hackage.haskell.org/package/epub-tools-2.8 (DinoMorelli)
07:27:38 <quchen> trumar8: It's in the standard GHC repo
07:27:57 <quchen> trumar8: ghc/docs/*
07:28:32 <trumar8> quchen: hurrah, thank you. https://github.com/ghc/ghc/tree/master/docs/users_guide
07:38:37 <trumar8> where I do go to ask about login issues at https://ghc.haskell.org/trac/ghc ?
07:40:10 <dutchie> trumar8: maybe #haskell-ops
07:40:15 <quchen> trumar8: Hm, I think #ghc might be the place for that.
07:40:48 <trumar8> dutchie: quchen  thanks.
07:49:37 * hackagebot dead-code-detection 0.1.2 - detect dead code in haskell projects  https://hackage.haskell.org/package/dead-code-detection-0.1.2 (SoenkeHahn)
07:51:51 <fishburne> I am trying to use Conduit to solve this problem I have http://lpaste.net/141241 . But I cannot seem to find to make a conduit from a file handle. I saw articles that use a function called 'SourceFile' in Conduit.Binary package. But it is not present in the new versions of this library. Please help.
07:52:38 <DEA7TH> Can I use one derivation of Eq to put my data in a heap, and another one to put it in a set? Because the one in the heap only looks at a single field, and that appears to confuse the set, I think
07:53:00 <tekkkz> Hello! One question: When/For What is Haskell good for where other languages arent so suitable? Maybe examples are enought
07:54:08 <DEA7TH> or actually, instance of Ord. Not Eq.
07:54:46 <quicksilver> don't write bad instances of Eq
07:54:50 <quicksilver> or Ord, indeed
07:55:04 <quicksilver> only write ones which consistently distinguish every element.
07:55:06 <DEA7TH> It's a very common use case. I'm implementing Dijkstra's algorithm.
07:55:36 <quicksilver> do the comparisons manually for the dijkstra heap
07:55:41 <quicksilver> don't use your Ord instance
07:55:46 <cocreature> DEA7TH: you can write a newtype wrapper around your datatype and provide a different instance
07:55:53 <quicksilver> and keep the Ord instance for the honest safe one which you use for Set
07:57:07 <quicksilver> a good priority queue (priority heap) lets you specify priority (distance in this case) separately from payload anyway
07:57:37 <quicksilver> because you very often have 'more stuff' in the payload than the metric.
07:57:39 <fractalsea> In a profiling report, what is the cost centre ‘MAIN’ and how is it different to ‘main’? Apparently my program is spending 38% of my time in this cost centre (individual)..
07:58:07 <quicksilver> for my recent dijkstra impl I just used a couple of Data.Maps because I couldn't decide which pqueue implementation to use.
07:58:10 <bennofs> fractalsea: :O are there any other cost centres beside MAIN and main?
07:58:14 <quicksilver> fractalsea: top-level constants, I think
07:58:20 <quicksilver> a.k.a. CAFs
07:58:36 <quicksilver> but they might not look toplevel in your source code because GHC will float them up.
07:58:41 <fractalsea> bennofs, yes, but that is the one where most time is spent
07:58:57 <fractalsea> quicksilver, ah I see
07:59:13 <bennofs> fractalsea: hmm, you can try -fprof-cafs to confirm that hypothesis
07:59:15 <fishburne> How can I make a conduit from a file?
07:59:25 <fractalsea> quicksilver, But I also see CAFs appear further down in the call graph. What’s the difference?
08:00:12 <quicksilver> :( not sure.
08:00:20 <fractalsea> bennofs, thanks I will look into that
08:00:50 <bennofs> quicksilver, fractalsea: could be that those 35% are from CAFs from a different library which doesn't have cost centre annotations
08:01:11 <bennofs> (-fprof-cafs won't help there either though :/)
08:02:35 <fractalsea> bennofs, ahh. Maybe that’s it. Is there any way of tracking down where that would be
08:02:38 <fractalsea> ?
08:03:33 <cluzz> can somebody please help me in the right direction? I'm really really stuck on a uni assignment and my previous solution was rejected by the program verification >.<
08:03:56 <cluzz> http://foswiki.cs.uu.nl/foswiki/pub/FP/CourseAssignments/Assignment1.pdf <-- exercise 7
08:04:33 <fishburne> Can somebody help me with conduits?
08:04:43 <carrotlord> like, in the matrix sense?
08:05:07 <carrotlord> > :t [[1,2,3],[4,5,6],[7,8,19]]
08:05:08 <lambdabot>  <hint>:1:1: parse error on input ‘:’
08:05:24 <carrotlord> > :t []
08:05:26 <lambdabot>  <hint>:1:1: parse error on input ‘:’
08:05:41 <DEA7TH> It would've been handy if I could have multiple instances of Ord and decide which one to use where.
08:06:01 <carrotlord> > tail [1,2,3,4]
08:06:03 <lambdabot>  [2,3,4]
08:06:13 <dutchie> :t ]
08:06:14 <lambdabot> parse error on input ‘]’
08:06:15 <dutchie> er
08:06:16 <dutchie> :t []
08:06:17 <lambdabot> [t]
08:06:22 <fractalsea> bennofs, I compiled with -fprof-cafs, but I still get 35% time spent in MAIN
08:06:37 <fishburne> Why do I get this error http://lpaste.net/141241 ?
08:07:33 <carrotlord> :t [[[]]]
08:07:34 <fractalsea> I also have another question about the report: what do the ‘.\’ mean after a function name? For example a cost centre called ‘myfunction.\.\’?
08:07:35 <lambdabot> [[[t]]]
08:07:46 <Cale> DEA7TH: It's a very important property of type classes that you can have at most one instance of a class per type, and any manner in which the compiler obtains an instance will result in the same instance, so that programs don't have to worry about the providence of the instances they obtain when trying to ensure that the same one gets used.
08:08:18 <Cale> DEA7TH: If you find yourself wanting more than one instance per type, consider just using a record type with fields for what would be the type class methods.
08:09:09 <fishburne> how can I set newlinemode for a file read using readFile?
08:09:11 <Cale> DEA7TH: In the case of Ord, you can just pass around functions of type (a -> a -> Ordering) for the most part
08:09:56 <DEA7TH> Cale: can I do that with the function in order to make Set a?
08:10:09 <Cale> DEA7TH: No, and with good reason.
08:10:36 <Cale> DEA7TH: There are operations which combine multiple values of type Set a which rely on the instance used being the same
08:11:22 <Cale> It's really really nice not to have to worry about whether two Sets of the same type are using the same Ord instance.
08:12:23 <Cale> fractalsea: Could it be referring to a lambda?
08:13:14 <kaidelong> basically there are two approaches to dealing with this
08:13:16 <DEA7TH> Cale: My reasoning was that in corner cases, you might need a more precise meaning of Ord - for example, ordering by priority in a heap and ordering in order to minimize equal elements in a set. One might solve this by changing heap and set, but that's a corner case and my idea would work for all cases where someone needs a more precise meaning of something where an instance is used.
08:13:18 <kaidelong> use plain HOFs
08:13:21 <kaidelong> or use a newtype
08:13:34 <fractalsea> Cale, ah quite possibly. I’ll check
08:13:43 <kaidelong> HOF is when you expect the user might want to pass in a different implementation of a typeclass
08:13:46 <Cale> Yeah, the other approach is to make a newtype of your datatype, and define a different instance for that
08:14:06 <kaidelong> newtype is for when you have some universal default you want to use, but it's not the one available by default
08:14:13 <Cale> fractalsea: I'm pretty certain that's what it refers to
08:15:07 <fractalsea> Cale, yeah that makes sense. Matches up what I see in my source. Thanks!
08:15:39 <quicksilver> DEA7TH: in your example it's clear to me that the instance should be used for Set
08:16:05 <quicksilver> because that has hte soundness priority that Cale is talking about.
08:16:10 <quicksilver> property.
08:16:36 <joseph07> quicksilver:By "the instance should be used for Set" you mean define a newtype with an Ord instance?
08:16:40 <DEA7TH> quicksilver: I was thinking about the general case. But for my example, how can I use a heap then? I was using Data.Heap
08:17:00 <quicksilver> for the priority queue you should be able to provide either an explicit ordering function or an out-of-band priority.
08:17:05 <Cale> If your ordering is not a total order, it doesn't belong in an Ord instance.
08:17:16 <quicksilver> joseph07: no, I meant the instance for the main type should be the Ord type you use in Set
08:17:19 <quicksilver> the Ord instance.
08:17:27 <Cale> and putting it there will cause things like Data.Set to malfunction horribly
08:17:35 * quicksilver looks up Data.Heap docs.
08:18:02 <quicksilver> the Data.Heap I just google has (priority,val) pairs
08:18:13 <quicksilver> so you just use Int for the priority and don't mess with instances
08:18:18 <quicksilver> which Data.Heap are you using?
08:18:28 <Cale> http://hackage.haskell.org/package/heap-1.0.2/docs/Data-Heap.html
08:18:48 <joseph07> You need instances of HeapPolicy
08:18:52 <quicksilver> as I said earlier, a priority queue which forces you to use your own Ord instance seems poorly designed; it's a very common case to want a different notion of priority.
08:18:58 <fishburne> how can I set newlinemode for a file read using readFile?
08:19:01 <DEA7TH> Hm, that would work. I had hoped to avoid it because it means I have the int both inside the thing and outside of it, or that I'll have to pass it always along with it.
08:19:39 * hackagebot mustache 0.1.0.0 - A mustache template parser library.  https://hackage.haskell.org/package/mustache-0.1.0.0 (justus)
08:19:44 <Cale> fishburne: Don't use readFile
08:20:07 <Cale> fishburne: Use openFile and then hSetNewlineMode on the resulting Handle, and then hGetContents
08:20:09 <quicksilver> I just used Map Int [Val] for my priority queue 
08:20:19 <quicksilver> should have used IntMap really but I wasn't worried about priority
08:20:31 <DEA7TH> what is Val?
08:20:31 <geekosaur> ...and then consider not using getContents, since lazy I/O has gotchas
08:20:41 <joseph07> DEA7TH: You could still use a newtype to get the Ord instance you want
08:20:53 <quicksilver> (dijkstra requires you to be able to look up the previous best cost for a node so I also had an auxiliary Map Val (Int,Path)
08:21:06 <quicksilver> DEA7TH: Val was the type of the node I was doing shortest-paths through
08:21:44 <quicksilver> "I wasn't worried about performance" I meant, 3 sentences back. My typing is really bad when I can't see what I'm typing :(
08:21:45 <fractalsea> quicksilver, the CAFs under MAIN on the report only add up to a 2 or 3% of the running time, so I still don’t understand where the extra 35% is coming from…
08:23:02 <fishburne> Cale: But then I get this http://lpaste.net/141241
08:23:23 <Cale> I didn't say to use withFile
08:23:29 <Cale> I said to use openFile
08:23:45 <Sindriava> @src withFile
08:23:45 <lambdabot> withFile name mode = bracket (openFile name mode) hClose
08:23:51 <fishburne> Cale: I tried both. 
08:23:53 <Cale> hGetContents will take care of closing the Handle when it's done
08:24:04 <Cale> Your error message indicates that the file handle is being closed
08:24:33 <Cale> You are not allowed to hClose a handle which has had hGetContents run on it.
08:25:57 <Cale> (Well, not quite true, you are really not allowed to continue observing a String which came from hGetContents once the handle has had hClose run on it, but it's pretty much the same thing)
08:26:39 <fishburne> Cale: Ok. I think I included an hClose when I tried the version using openFile. Let me check.
08:27:20 <quicksilver> I have just read more of the docs on HeapItem and I believe that DEA7TH could implement his own instance of HeapItem which correctly points at his embedded priority number
08:27:32 <quicksilver> without the cost of duplicating it
08:27:42 <quicksilver> not that I believe that cost is likely to be a substantial issue.
08:28:09 <DEA7TH> not computationally, only in elegance
08:28:28 <DEA7TH> I'll look up HeapItem then
08:28:43 <tiler> Hey all! Has anyone used ReadP, and can explain how chainl is supposed to be used?
08:28:59 <tiler> http://hackage.haskell.org/package/base-4.8.1.0/docs/Text-ParserCombinators-ReadP.html#v:chainl1
08:29:48 <tiler> I also have a grammar that *I think* it's supposed to be used on: https://gist.github.com/anonymous/77001f54a30c03f750fa
08:30:07 <fishburne> Cale: I get another error. But it seems unrelated. The error is " hGetContents: invalid argument (invalid byte sequence)"
08:30:40 <Cale> fishburne: That sounds like an issue with the text encoding being used to read the file
08:32:00 <Cale> Perhaps check out what localeEncoding is presently
08:32:16 <Cale> and either make sure that the file matches that, or set a different TextEncoding
08:33:10 <Cale> (localeEncoding is the default, and depends on your system's locale)
08:39:15 <paul0> aeson is the best library for json parsing?
08:39:47 <joseph07> paul0: I think so
08:40:09 <indiagreen> paul0: more-or-less (there are other libraries that can do interesting stuff like bidirectionality, but they aren't very polished yet)
08:41:17 <recur22> hi, did anyone try this example before https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/win32-dlls.html
08:41:18 <joseph07> > readP_toS (fmap read (manyTill (satisfy isDigit) eof)) "42534"
08:41:20 <lambdabot>  Not in scope: ‘readP_toS’Not in scope: ‘manyTill’Not in scope: ‘satisfy’Not ...
08:41:57 <Cale> recur22: I'm sure that at some point someone tried it with some version of GHC ;)
08:42:33 <quchen> Do the tokens in Phab mean something particular?
08:43:14 <geekosaur> recur22, it worked in some previous version, but ghc linking has changed a lot and all too often fixing a problem with (say) arm has knock-on effects on win32 or mac or ...
08:44:28 <thoughtpolice> quchen: No. You can just award them for giggles and cuteness if you want. You have to read each token for what the title of it is, and anyone can award 1 token to any revision/commit etc.
08:44:47 <recur22> ghc is really depressing 
08:45:20 <carrotlord> use 'runhaskell' program for interpretation of lang
08:45:27 <carrotlord> no need to compile
08:45:56 <quchen> thoughtpolice: While you're here, is it alright if I push changes that frequently to Phab? I'm not familiar with the workflow really, and I don't want people to get annoyed by the flood of mails
08:45:58 <Sindriava> recur22: I'm 99% sure that if it's a GHC issue on windows, it's not GHC's fault
08:46:15 <Sindriava> carrotlord: I'd maybe recommend using `runghc` instead
08:46:17 <thoughtpolice> recur22: If there's something wrong with the example, filing a bug would be very useful so we can fix the documentation or fix any bugs that might come about.
08:46:36 <thoughtpolice> recur22: https://ghc.haskell.org/trac/ghc/newticket
08:46:40 <carrotlord> 'ghc panic' refers to a mathematical contradiction
08:46:48 <carrotlord> sometimes the compiler has bugs
08:47:12 <carrotlord> well, it's very *very* rare
08:47:26 <thoughtpolice> quchen: It's fine. Patches may go through a lot of revisions in practice anyway.
08:47:26 <geekosaur> Sindriava, carrotlord, the manual reference is to building a DLL, runhaskell will not help here
08:49:14 <recur22> ghc docs is really good comparing to haskell.org wiki
08:54:40 * hackagebot hsndfile 0.8.0 - Haskell bindings for libsndfile  https://hackage.haskell.org/package/hsndfile-0.8.0 (StefanKersten)
08:55:42 <tekkkz> Hi. How to get the first character of a string?
08:56:02 <Intolerable> :t head `asAppliedTo` "hello!"
08:56:03 <lambdabot> [Char] -> Char
08:56:10 <Intolerable> > head "hello!"
08:56:12 <lambdabot>  'h'
08:56:25 <recur22> is there any *stable* way to call haskell from real world?(other than writing file)
08:56:51 <Intolerable> (you can also pattern match like on a list, and you can handle the empty string case there)
08:56:58 <tekkkz> lambdabot, and how to get the n-th char?
08:57:04 <Intolerable> recur22: what do you mean?
08:57:09 <Intolerable> :t (!!)
08:57:10 <lambdabot> [a] -> Int -> a
08:57:26 <Intolerable> bear in mind that (!!) is very inefficient if you're indexing strings
08:57:46 <recur22> i've tried ffi but no luck
08:57:48 <tekkkz> uhh, Intolerable , how to get the n-th character of a string?
08:57:57 <Intolerable> (!!)
08:58:01 <Intolerable> > "hello!" !! 5
08:58:02 <lambdabot>  '!'
08:58:11 <jgertm> can anyone give me an example of how to implement the MonadBaseControl typeclass with version 1 of the library? im having trouble with the 'type StM ...' part
08:59:08 <tekkkz> http://ix.io/kTQ -> error at compiling?
08:59:09 <recur22> Intolerable: i'm looking for _stable_ way to call haskell from other enviroments
08:59:54 <dutchie> tekkkz: (alphabet !! 2) :: Char, putStrLn :: String -> IO (). can you see the problem?
09:00:06 <tekkkz> no, im new
09:00:14 <tekkkz> ahh
09:00:15 <tekkkz> its char
09:00:17 <Intolerable> :t putStrLn
09:00:18 <lambdabot> String -> IO ()
09:00:18 <tekkkz> but we need string
09:00:25 <Intolerable> :t "hello!" !! 4
09:00:27 <lambdabot> Char
09:00:30 <tekkkz> yo
09:00:35 <tekkkz> so how to get string from it?
09:00:43 <dutchie> a String is a list of Char
09:00:49 <tekkkz> ya
09:00:51 <Intolerable> if you just put the char in a list
09:00:53 <Intolerable> it's a string
09:00:55 <tekkkz> but i want to print just a single char
09:01:01 <Intolerable> > ['h']
09:01:03 <lambdabot>  "h"
09:01:15 <dutchie> > ["Hello!" !! 4]
09:01:16 <lambdabot>  "o"
09:01:28 <dutchie> (careful though:)
09:01:32 <srhb> dutchie: That's a list of strings though.
09:01:34 <geekosaur> recur22, I'm afraid that *on Windows* that is going to be somewhat difficult; ghc is far better tested on Posix-likes (linux, freebsd, solaris/illumos)
09:01:34 <dutchie> > ["Hello" !! 100]
09:01:36 <lambdabot>  "*Exception: Prelude.!!: index too large
09:01:50 <srhb> > "Hello!" !! 4
09:01:52 <lambdabot>  'o'
09:02:04 <tekkkz> thanks, but why is this working? what is [...] doing?
09:02:09 <Kron> anyone know how to fix "cabal: does not exist"?
09:02:12 <dutchie> [] is list syntax
09:02:18 <Kron> it's the most existentially amusing error message I've ever seen
09:02:22 <bennofs> Kron: try rm'ing dist
09:02:26 <Kron> dist?
09:02:35 <tekkkz> dutchie, kk, thx
09:02:36 <bennofs> Kron: the dist directory. also, what OS are you on=
09:02:39 <Kron> Arch linux!
09:02:40 <Kron> sorry
09:02:50 <srhb> tekkkz: In this case It was a single element list of a single character String.
09:03:01 <geekosaur> "does not exist" is a /bin/sh error message and suggests it's not in $PATH
09:03:06 <Kron> ahhh
09:03:14 <Kron> but cabal --version works and the like
09:03:21 <Kron> it's just cabal update that makes the "does not exist" message
09:03:23 <Kron> or cabal install
09:03:31 <bennofs> Kron: try cabal clean first
09:03:36 <geekosaur> odd
09:03:43 <Kron> no cabal file found
09:03:52 <Kron> please create a package description file <pkgname>.cabal
09:04:01 <geekosaur> (usually a program getting that error says "No such file or directory"; "does not exist" is a sh-ism)
09:04:05 <bennofs> Kron: do you have a .cabal-sandbox directory in your working directory
09:04:14 <bennofs> ?
09:04:14 <Kron> oooh! thanks
09:04:21 <Kron> moving back to ~ somehow fixed it
09:04:24 <Kron> which... is confusing to me
09:04:31 <Kron> doesn't cabal have a global state outside sandboxes?
09:04:39 <bennofs> yes it does
09:04:39 <Kron> I was in /usr/share/haskell earlier
09:05:36 <geekosaur> cabal update I would expect to work. "cabal install" with no argument would be expected to fail since it wnts a cabal file in the current directory... but if that's the case then they need to work on their error messages
09:06:04 <Cale> recur22: What exactly is the problem that you're running into with the example in the GHC documentation?
09:06:21 <srhb> Kron: If you have a sandbox setup in your home directory (which is a bit weird, probably) this would explain the behaviour.
09:06:32 <geekosaur> otherwise I think it'd be strace time to see what it is doing
09:06:34 <Kron> I don't
09:06:36 <Kron> oddness
09:06:36 <srhb> but yeah, terrible error message.
09:06:55 <geekosaur> (...which in and of itself suggests that a better debug mechanism is needed...)
09:09:40 <gwo> Are type classes and interfaces basically two ways to describe the same thing in Haskell?
09:09:57 <gwo> Such as Num and Ew?
09:10:05 <gwo> Eq even
09:10:35 <srhb> gwo: We don't _have_ interfaces, so that's hard to answer.
09:11:07 <geekosaur> "interfaces" isn't really a thing in haskell. some people compare typeclasses to Java interfaces, but it's a very sloppy/loose comparison that can get you into a lot of trouble
09:11:27 <geekosaur> because while they are indeed similar in some ways, the type systems work in different ways
09:11:40 <gwo> Ah ok, just watching a video where they make the comparison.
09:11:52 <gwo> I see what you mean
09:12:34 <recur22> geekosaur: i see no difference in this regard between OSs
09:13:13 <geekosaur> you pointed to a manual section on building a DLL. if you do not see a difference between Windows DLLs and ELF .so-s, then you lack experience in one or both
09:14:49 <carrotlord> ELF is the x86-64bit for linux, and PE (windows portable executable) is the binary for Windows
09:16:22 <truman8> Does anyone know how to keep ghc-mod quiet in emacs when it encounters an error. It's quite distracting to have the "*GHC Error*" buffer appear whilst working.
09:16:35 <truman8> I don't want the *GHC Error* buffer to appear.
09:17:37 <recur22> geekosaur: it matters of docs correctness more than technical..
09:17:45 <geekosaur> carrotlord, there's a bit more to it than just file formats. there's the question of variant APIs (ghc still has portability issues with x86_64 windows, since it assumes some things are stdcall but x86_64 windows apis are ccall)
09:18:03 <carrotlord> well yes, I don't know much about DLLs in particular
09:18:42 <geekosaur> there's the fact that it takes more than just slapping a bunch of stuff into the file, and what exactly you need to do to make a working shared object differs by platform (including win32 vs. win64)
09:18:58 <recur22> how can I trust now that wont happen in any other os
09:19:29 <geekosaur> stick to interpreters or VM-based languages? platforms are hard
09:23:00 <geekosaur> the ghc devs know that win64 support is lacking and are actively looking for help (and funding, although the industrial haskell group has helped a bit there)
09:23:30 <geekosaur> if you need it to work *right now* and are not willing to help, then you must look elsewhere
09:28:57 <paul0> I'm trying to parse a json from url
09:28:59 <paul0> http://pastebin.com/raw.php?i=k0aQ9EbL
09:29:26 <paul0> I can fetch the url data and parse, but when I try to load the fetch function, i get this error http://pastebin.com/raw.php?i=aMF04pYS
09:29:27 <tekkkz> why is this just printing me "z" instead of the whole alphabet ? http://ix.io/kTT
09:30:54 <joseph07> tekkkz: The second and third pattern matchings for go are the same, so the third never gets matched
09:31:43 <srhb> tekkkz: loop 35 = go 35 = putStrLn [alphabet !! 35] ... There's no recursive call or anything.
09:32:03 <joseph07> paul0: it looks like fetchData is doing IO, so it's type should be IO (Maybe [Object])
09:32:37 <joseph07> tekkkz: You might have meant putStrLn [alphabet !! n] >> go (n - 1)
09:32:44 <tekkkz> ahh ja ok
09:32:54 <tekkkz> im new so i use haskell since 3 hours
09:35:06 <clrnd> so, I want to build ghcjs with stack, so I cloned ghcjs and ghcjs-prim and now ... how do I build two folders at once?
09:35:56 <clrnd> meaning, with cabal there was this option to search for compiled libs in a directory
09:36:29 <joseph07> paul0: fmap decode (simpleHttp tradesUrl) :: IO (Maybe [Object])
09:37:30 <clrnd> gonna try this https://www.fpcomplete.com/blog/2015/06/announcing-first-public-beta-stack
09:45:10 <bam365> http://lpaste.net/141247
09:45:35 <bam365> ^ could anyone help we with what I need to do to make the setIsValid2 function compile in that paste?
09:46:08 <bam365> the function f is getting locked into the type (Card -> Shape) -> Bool and I'm not sure how to tell the compiler it's polymorphic
09:47:34 <ferdev> hi
09:47:36 <Intolerable> give f a type signature?
09:47:38 <Intolerable> hello
09:47:39 <ferdev> hola
09:49:16 <ferdev> somebody speaks spanish ?
09:49:58 <lyxia> bam365: or eta expand f x = attributeFormsSet c1 c2 c3 x
09:50:11 <lyxia> Monomorphism restriction strikes again.
09:51:30 <bam365> lyxia: oh wow, eta expansion worked
09:54:19 <bam365> Intolerable: I tried to use ScopedTypeVariables and RankNTypes to give f a signature but couldn't make that work. Out of curiosity, do you have an example of how you would provide a type signature for that that works?
09:56:19 <srhb> bam365: With scopedtypevariables it simply looks like id :: forall a. a -> a; id x = x :: a
09:56:43 <lyxia> you don't even need scopedtypevariables here I think.
09:56:55 <srhb> Nope.
09:57:32 <lyxia> Try adding f :: Eq a => (Card -> a) -> Bool in the where clause
09:59:12 <bam365> lyxia: that worked, I think it was a syntax issue with how I was doing the type annotation in the first place, was doing it inline like (f :: Eq a => (Card -> a) -> Bool)
09:59:25 <bam365> but doing it on the line above like a normal function worked
09:59:44 * hackagebot lens-aeson 1.0.0.5 - Law-abiding lenses for aeson  https://hackage.haskell.org/package/lens-aeson-1.0.0.5 (EricMertens)
10:04:44 * hackagebot aeson 0.10.0.0 - Fast JSON parsing and encoding  https://hackage.haskell.org/package/aeson-0.10.0.0 (BryanOSullivan)
10:05:14 <glguy> wow, 5 minutes after I release the minor fix a new aeson comes out
10:05:27 <glguy> and now I need to do a new version to be compatible
10:06:52 <Shockk> does anyone know if there are any academic papers or anything relating to video game development or game engine development or similar in Haskell or more generally pure functional languages?
10:09:35 <hodapp> I feel like I read some slides on this... but *shrug*
10:09:35 <Shockk> hmm, I found one on Functional Programming and 3D Games from uni of new south wales
10:14:25 <Cale> Shockk: heh, I have to apologise, there was a point at which I'd meant to write one along with Ryan Trinkle and Stephen Blackheath, but it never really materialised.
10:14:36 <Shockk> aww
10:15:26 <Shockk> right now I'm considering whether or not to go for a university module where I'd do independent study and end up writing some dissertation/report on some area relating to games
10:15:30 <Cale> Shockk: Several years ago, we worked on an action RPG in Haskell, with an engine based on arrowised FRP
10:16:10 <Cale> Shockk: (though not with the standard Arrow class, we had our own, with its own preprocessor for the proc/do-notation)
10:16:17 <Shockk> interesting, is that similar to Yampa? (from my understanding of Yampa over the last 3 minutes)
10:17:19 <Cale> Kind of -- it ended up being very different in terms of the details, and the implementation was quite a lot more complicated than Yampa's, due to the way that it represented the entire computation graph and did runtime simplification of it
10:17:28 <Shockk> ahh
10:18:07 <Cale> A lot of what we learned about FRP has been encoded in the non-arrowy FRP system called Reflex
10:18:28 <Shockk> hmm, I'm take a look at that
10:18:36 <Shockk> I'll* even
10:19:15 <Cale> Ryan's been using Reflex to build web applications for various clients (and he's now hired me again to work with him doing it)
10:21:15 <GLM> How do I operate on a list of lists that modifies that last list?
10:21:42 <Cale> GLM: I don't think I understand the question
10:21:46 <cocreature> GLM: if I understand your question correctly, nested maps might be what you are looking for
10:22:19 <GLM> Cale:I have a list of list of Bools. I want to swap that last list of bools with a new list of bools
10:22:36 <Cale> That's a terrible operation to want to perform on a list
10:23:01 <Cale> But you can use something like init xs ++ [x] to replace the last element of a list
10:23:09 <Cale> This is O(n) time
10:23:52 <GLM> Cale:That is true but then I'd also have to get the first part of the list to concat to
10:24:39 <Cale> init
10:24:43 <Cale> > init [1,2,3,4,5]
10:24:45 <lambdabot>  [1,2,3,4]
10:24:54 <Cale> ^^ this operation is slow and you should avoid it
10:25:12 <Cale> If you're manipulating the end of a list repeatedly, consider just storing the list in reverse
10:25:25 <Cale> Or using another data structure entirely
10:25:28 <GLM> Cale:Is there an init for everything but the last n lines?
10:25:45 <ARM9> drop?
10:25:53 <Cale> reverse . drop n . reverse
10:27:16 <dfeuer> Cale, you can do a lot better than that, I think.
10:27:27 <dfeuer> yes, indeed.
10:27:38 <Cale> dfeuer: you can do slightly better, but not asymptotically better
10:28:03 <dfeuer> dropFromEnd n xs = zipWith const xs $ drop n xs
10:28:03 <Cale> and doing better will require more code that you're probably going to end up throwing away anyhow
10:28:12 <Cale> right
10:28:47 <dfeuer> Cale, that's not much more code, and it's a lot lazier than your implementation; likely substantially more efficient for long lists.
10:28:55 <Cale> sure
10:28:58 <Cale> I totally agree
10:29:09 <Cale> But if you're performing this operation, you shouldn't be using lists.
10:29:10 <dfeuer> OK.
10:29:26 <dfeuer> If you're performing it multiple times, true.
10:29:32 <dfeuer> If you only do it once, it's probably not bad.
10:29:42 <Cale> yeah, once is probably okay
10:30:52 <dfeuer> Lots of things are cheap to do once or twice, and horrible to stack up.
10:34:46 * hackagebot sbp 0.50.9 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-0.50.9 (markfine)
10:52:58 <YellowOnion> most of the calling haskell-from-c examples are extremely trival that don't work with any proper communication between the functions. how do you pass references around without a main function?
10:53:48 <Cale> YellowOnion: hm?
10:53:59 <luntain> Why doesn regex-tdfa not match "\\d{2}" while it does match both "[[:digit:]]{2}" and "\\d"? Eg: ("22" =~ "\\d{2}") :: Bool is False
10:55:04 <luntain> correction, it doesn't match \\d either
10:55:13 <voidzero> \d then?
10:55:25 <voidzero> oh you need to double escape, nvm
10:55:33 <voidzero> yeah \d is a perl type regex
10:55:37 <luntain> \d is a lexical error
10:56:13 <geekosaur> regex-tdfa is not perl compatible regex, it is posix compatible regex. \d in posix regex is just d
10:56:26 <YellowOnion> Cale, ok, imagine an app calls a dll that you're making, the spec has a start(), update(), stop() functions, how would I get data from the start() function (like say a file handle) to the update() function.
10:56:37 <voidzero> posix re is teh sux
10:56:43 <voidzero> [[:alnum:]]
10:56:45 <voidzero> blah
10:57:05 <bob_twinkles> much clearer than [\w\d]
10:57:23 <geekosaur> [\w\d] better written as \w
10:57:29 <voidzero> :)
10:57:32 <geekosaur> (\w is alnum plus underscore)
10:57:34 <Cale> Sometimes people have a problem, and they think "I know, I'll use regex", and then they have two problems.
10:57:50 <bob_twinkles> I think that demonstrates my point =P
10:58:02 <voidzero> clearer? nah
10:58:10 <clrnd> and they ask #haskell, now have a n-dimensional space of problems
10:58:16 <monochrom> :)
10:58:27 <geekosaur> manyfold manifold
10:58:33 <bob_twinkles> *category of problems
10:58:58 <voidzero> regular expressions are called 'write-only' because they're usually hard to read
10:59:17 <voidzero> i don't think posix style really negates that :)
10:59:18 <monochrom> in #haskell, what you see is: they think "I know, I'll use category theory".
10:59:44 <monochrom> now they output a lot of abstract libraries.
10:59:48 * hackagebot OpenGLRaw 2.5.4.0 - A raw binding for the OpenGL graphics system  https://hackage.haskell.org/package/OpenGLRaw-2.5.4.0 (SvenPanne)
11:00:23 <voidzero> luntain, do you really need regular expressions?
11:01:09 <Cale> YellowOnion: I don't know how to begin to answer that other than "in the obvious way by passing values around"
11:01:14 <benzrf> a 'category of problems' is appropriate
11:01:32 <benzrf> theres any number of morphisms taking your problem to another problem, but no actual solutions
11:02:02 <YellowOnion> Cale, thats the thing, you can't do that when something in c is calling a function.
11:02:05 <Cale> Sometimes people have a problem and think "I know, I'll use n-categories", and then they have an (n+1)-category of problems.
11:02:26 <monochrom> that can be resolved by designating some problems (perhaps the final ones, or close-to-final ones) as solutions, i.e., solutions are special cases of problems.
11:02:39 <Cale> YellowOnion: why?
11:02:59 <Cale> YellowOnion: FFI will happily export functions with C-typed parameters
11:03:39 <Cale> (and results)
11:03:54 <monochrom> in other words you consider some problems as "already solved" and so if you find a reduction from your original problem to them, you are done.
11:04:20 <YellowOnion> Cale, I'm not sure you quite understand, the spec doesn't allow me to modify the c functions
11:04:42 <YellowOnion> its another app (closed source), that is calling in to my code.
11:04:43 <luntain> voidzero: I have a simple use case, but what are alternatives, just out of curiosity
11:04:47 <Cale> YellowOnion: Then you might have to write some C-side marshalling code
11:05:34 <monochrom> for example, sorting is considered a solved problem. if you are trying to do convex hull, and you come up with an algorithm that calls up a sorting subroutine (and other subroutines for other solved problems), you are done. you do not worry about solving sorting, even though sorting is a problem.
11:06:11 <YellowOnion> Cale, so I would store my file handle in some c-global?
11:06:20 <kaidelong> how do I get stack to put a ghc in my path?
11:06:35 <kaidelong> or remove it and replace it with another
11:06:39 <Cale> YellowOnion: I'm not sure if it needs to be global, that depends on the design of the interface which you're required to provide
11:06:50 <kaidelong> ~/.local/bin is already in my path
11:06:50 <voidzero> luntain, simple pattern matching, maybe isInfixOf?
11:07:02 <tippenein> kaidelong: this? https://github.com/commercialhaskell/stack/issues/725
11:07:26 <tippenein> ah, nope. not extra-path
11:07:27 <ReinH> luntain: parsing
11:07:30 <kaidelong> tippenein: no, I just want "ghc" to be available for shell scripts and system calls
11:07:38 <kaidelong> as opposed to "stack ghc"
11:07:47 <qmmm> is there a decent explanation somewhere of how a url shortener works? do you really need a bijection function?
11:07:47 <Cale> YellowOnion: It's quite possible that it's an obnoxious API which really requires that sort of thing.
11:07:50 <kaidelong> mmm, does linux support powershell style command aliases?
11:07:56 <ReinH> parser combinator libraries are generally easier to work with than regexp
11:08:00 <kaidelong> I guess I could just alias stack ghc to ghc?
11:08:01 <tippenein> and runhaskell won't do it for you?
11:08:03 <ReinH> and have far more library support
11:08:39 <tippenein> sorry, I might be misunderstanding and I don't know that much about stack anyway
11:08:50 <kaidelong> runhaskell is not on the path either
11:09:02 <Cale> qmmm: It works by having a big table of all the links people have submitted
11:09:19 <kaidelong> mm, actually, that's a problem
11:09:32 <kaidelong> how do I make haskell scripts that use #!/usr/bin/runhaskell
11:09:46 <qmmm> i've seen a lot of examples converting strings to an alternate base, is that necessary?
11:09:57 <frerich> kaidelong: It should be '#!/usr/bin/env runhaskell'
11:10:04 <Cale> qmmm: It's only necessary to make the links shorter
11:10:13 <qmmm> the other question is how short can you make a string and guarantee it's unique?
11:10:15 <dfeuer> Cale, are you the one who thinks $ should've been infixl?
11:10:19 <Cale> qmmm: Using a larger base means you have fewer digits
11:10:22 <Cale> dfeuer: yes
11:10:32 <Cale> dfeuer: I'm one of the people who thinks that anyway
11:10:35 <dfeuer> *nod*. I suspect you were right.
11:10:39 <Cale> perhaps one of the more vocal of them
11:10:42 <clrnd> qmmm, I could store your link in a table with a sequential id and call it a day yo
11:10:45 <YellowOnion> Cale, I can't really think of any other ways to get this to work, I thought there might be a better way.
11:11:25 <qmmm> clrnd: oh
11:11:36 <Cale> YellowOnion: Well-designed plugin APIs will often provide some pointer to user data to callbacks
11:11:49 <qmmm> i guess that's why they use base64/base32
11:11:56 <qmmm> otherwise it becomes too long
11:12:06 <Cale> qmmm: Right, that's all it is
11:12:08 <qmmm> it = the shortened url
11:16:41 <nitrix> Doesn't in theory any broken package stall Stackage releases?
11:16:54 <nitrix> Since they ensure everything works prior to releasing?
11:21:53 <ReinH> nitrix: stackage could just not include that package'version
11:22:01 <ReinH> package/version
11:23:56 <AndroUser> quick question
11:24:29 <AndroUser> is there any way to make a function that will take a data constructor and check if something uses that data constructor?
11:25:38 <AndroUser> for example, a function that takes as an argument Just or Nothing, and a maybe value, and returns true if said value has the same constructor as the one input for example
11:25:45 <AndroUser> is this at all possible
11:26:26 <barrucadu> Yes, you can use toConstr from Data.Data
11:26:48 <ReinH> Robly18: Do you need this to be polymorphic?
11:27:03 <Robly18> no, not necessarily
11:27:14 <ReinH> You could use prisms instead.
11:27:38 <ReinH> > has _Just Nothing
11:27:39 <Robly18> what are those
11:27:40 <lambdabot>  False
11:27:45 <ReinH> > has _Just (Just 1)
11:27:46 <lambdabot>  True
11:27:53 <ReinH> from lens
11:28:14 <Robly18> uh, ive heard of that but its worth noting im not much of an expert in haskell yet
11:28:22 <Robly18> ill look it up nonetheless
11:28:44 <Robly18> so, i could use Data.Data or prisms from lens
11:30:02 <ReinH> Robly18: you have a sum type like data Foo = Foo | Bar | Baz. A prism _Foo is basically a way of splitting the sum type into "Foo" and "the other constructors"
11:30:13 <ReinH> see, it's a prism because it spits things apart
11:30:18 <ReinH> we like puns
11:30:28 <Robly18> heh heh
11:30:51 <ReinH> a lens is a pair of (the thing being focused, the rest of the structure)
11:31:03 <Robly18> but would i need to implement this myself? like, the Foo_ function
11:31:16 <Robly18> or would it be made by the compiler
11:31:22 <ReinH> You can, or you can use template haskell to generate them
11:31:26 <ReinH> makePrisms
11:31:41 <ReinH> There are already prisms for built-in types like Maybe
11:32:13 <Robly18> wait so how do i do this?
11:32:17 <nitrix> Mhhh, `docker: \n repo: "fpco/stack-build"` to my stack.yaml doesn't seem to help me run `stack image container`.
11:32:26 <Robly18> should i just read the lens docs and come back if i have questions
11:32:29 <nitrix> Trying to build a docker image with my app :/
11:33:10 <ReinH> Robly18: let me write up an example
11:33:28 <Sonolin> anybody care to help a noob? trying to simplify: 
11:33:30 <Sonolin> makeColor p $ makeChar p
11:33:31 <Robly18> thanks ReinH, sorry for the hassle
11:33:38 <Sonolin> tried makeColor <*> makeChar doesn't work
11:33:49 <ReinH> Robly18: np
11:33:50 <Sonolin> (both funcs are type "Piece -> Char")
11:34:05 <ReinH> Sonolin: what does "doesn't work" mean?
11:34:21 <ReinH> and anyway, makeColor p (makeChar p) is pretty simple.
11:34:30 <Sonolin> generates error... for that <*> I'd assume because neither are monadic
11:34:36 <ReinH> I'm mnot sure (makeColor <*> makeChar) p is any better
11:34:44 <ReinH> Sonolin: Well, *what* error does it generate?
11:34:49 <Robly18> <*> doesnt need monadic, just applicative
11:34:58 <ReinH> Sonolin: when you have questions about code and errors, show your code and errors.
11:34:58 <Robly18> though i guess the point stands
11:35:10 <ReinH> @where lpaste
11:35:10 <lambdabot> http://lpaste.net/
11:35:11 <monochrom> (f <*> g) p = f (g p) p, IIRC, but you want f p (g p)
11:35:36 <Robly18> couldnt you just flip
11:35:46 <ReinH> You want makeColor p (makeChar p) :p
11:36:08 <ReinH> not everything needs to be pointfree
11:36:13 <Robly18> ((flip makeColor) <*> makeChar) p?
11:36:17 <Robly18> looks ugly
11:36:17 <Sonolin> yea just trying as learning style :P
11:36:32 <Sonolin> hmm maybe this is as simple as can be
11:36:37 <mniip> [20:30:25] <monochrom> (f <*> g) p = f (g p) p, IIRC, but you want f p (g p)
11:36:39 <mniip> what what what
11:36:45 <mniip> that's =<<
11:36:47 <bernalex> anyone with wiki access around? https://wiki.haskell.org/User_groups#Norway would be neat if you could add Trondheim here.
11:36:49 <mniip> <*> is the correct one
11:36:55 <monochrom> ok
11:36:59 <nitrix> @src (<*>)
11:37:00 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:37:10 <mniip> > (f <*> g) x :: Expr
11:37:11 <lambdabot>      Ambiguous occurrence ‘f’
11:37:11 <lambdabot>      It could refer to either ‘L.f’,
11:37:11 <lambdabot>                               defined at /tmp/mueval17345751981973594324.hs:1...
11:37:14 <mniip> aww
11:37:32 <monochrom> @undefine
11:37:32 <lambdabot> Undefined.
11:37:39 <mniip> doesn't help
11:38:11 <mniip> > ((a +) <*> (b *)) x
11:38:13 <lambdabot>      Couldn't match type ‘Expr’ with ‘Expr -> b’
11:38:13 <lambdabot>      Expected type: Expr -> Expr -> b
11:38:13 <lambdabot>        Actual type: Expr -> Expr
11:38:25 <mniip> screw you
11:38:33 <monochrom> you probably want (+) instead of (a +)
11:38:35 <mniip> > ((+) <*> (b *)) x
11:38:36 <lambdabot>  x + b * x
11:40:54 <Sonolin> ah I'm getting it
11:40:57 <Sonolin> that's why flip is necessary
11:40:59 <Sonolin> ok :)
11:41:07 <mniip> you could use =<< instead
11:41:13 <Sonolin> I'll resist creating a new operator for a stupid simple thing :P
11:41:15 <mniip> > ((+) =<< (b *)) x
11:41:16 <lambdabot>  b * x + x
11:41:26 <ReinH> Robly18: http://lpaste.net/141254
11:41:39 <Sonolin> hmm ok
11:41:42 <Sonolin> thanks for the insight
11:41:44 <Sonolin> gotta go
11:42:23 <Robly18> > :t has
11:42:24 <lambdabot>  <hint>:1:1: parse error on input ‘:’
11:42:35 <ReinH> :t has
11:42:36 <Robly18> >:t has
11:42:36 <lambdabot> Getting Any s a -> s -> Bool
11:42:59 <Robly18> hmm whats the Getting Any mean
11:43:24 <nitrix> I think as much as Java developers loves creating design patterns that involves into convoluted abstractions, Haskell developers are trying too hard to minimize things. It's like everything should be operators or pointfree.
11:43:32 <nitrix> That's not the definition of simplicity.
11:43:37 <ReinH> Robly18: http://haddock.stackage.org/lts-3.5/lens-4.12.3/Control-Lens-Fold.html#v:has
11:44:09 <nitrix> Sonolin: Don't fall for it and you'll be good.
11:44:55 <maerwald> nitrix: well yeah, sometimes... and sometimes they enjoy smart code which is a very terrible habit, but hard to not fall for
11:44:58 <monochrom> but there is still an assymetric difference
11:45:19 <Robly18> ReinH: i really appreciate the help, but i think an overview of the big picture might help me understand this better. do you have any resources to read up on lenses? this looks like one of thlse
11:45:31 <Robly18> one of those* things that  ould be really useful
11:45:33 <monochrom> minimization teaches you new knowledge and perspectives. (not to say that minimized code is practical code.)
11:46:08 <maerwald> debatable if that is always useful... it could certainly make collaboration on a project more difficult
11:46:14 <monochrom> convolution is anti-teaching. it only serves to raise the barrier to learning and comprehension.
11:46:16 <ReinH> Robly18: http://lens.github.io, https://www.youtube.com/watch?v=cefnmjtAolY, https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation
11:46:41 <Robly18> thanks a lot!
11:46:48 <ReinH> Robly18: although this is one of those things where you can understand how to solve your particular problem without really needing to learn lens as a whole
11:47:10 <ReinH> (not that doing so would be a bad idea)
11:47:21 <Robly18> yes, but im not really learning haskell for the practicality
11:47:29 <Robly18> i mean, i realize haskell can be quite practical
11:48:03 <Robly18> but im here to stretch my horizons
11:48:20 <Robly18> not to see things through a narrow lens (pun very much intended)
11:48:34 <Robly18> so ill take a stab at it
11:49:06 <Robly18> so thanks ReinH, ill come back if i have any lingering questions
11:49:24 <ReinH> Robly18: seems good
11:53:40 <zarathostra> hey
11:54:10 <bind> hello
11:54:19 <zarathostra> I just coded something in Haskell, the program allows you to manage errors easily
11:54:49 <zarathostra> it's basically an enhanced version of Either
11:55:13 <zarathostra> and i just wanted to share it with you, because I don't know if it's really useful
11:55:27 <Robly18> what does it do
11:55:36 <Robly18> that either doesnt
11:56:34 <zarathostra> it just filters it it's an error or not and apply functions on it depending if hte reslt failed or succeeded
11:57:12 <ReinH> zarathostra: you should release a package to hackage
11:57:36 <ReinH> although that sounds a bi like the `either` function to me.
11:57:39 <ReinH> *nit
11:57:40 <Cale> s/hackage/lpaste/ ;)
11:57:42 <ReinH> uh
11:57:51 <lpaste_> zarathostra pasted “Error Handler” at http://lpaste.net/141255
11:57:54 <ReinH> zarathostra: s/lpaste/hackage :)
11:58:05 <zarathostra> here it is :)
11:58:20 <zarathostra> see the last lines for practical example
11:58:46 <zarathostra> maybe it's totally useless
11:58:51 <Cale> What's the difference between Result e a and Either e a? The instances are the same as the ones for Either
11:59:24 <ReinH> try f = either id f; catch f = either f id; tryCatch = either
11:59:24 <zarathostra> I could just use Either for my Handler type
11:59:48 <ReinH> :t either
11:59:50 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
12:00:22 <ReinH> Hansler is is an initial encoding of `either`
12:00:32 <zarathostra> Result seems more explicit since it's supposed to manage errors specifically
12:00:39 <ReinH> *Handler
12:01:11 <zarathostra> does your code allows you to chain operations as well ?
12:01:30 <ReinH> Yes. Via function composition.
12:01:31 <Cale> zarathostra: Either is conventionally used to handle errors in Haskell, with Left essentially always being failure, and Right always being success
12:02:11 <Cale> (It sort of has to be that way because of the order of the type arguments, and how that forces what the Monad instance does)
12:03:00 <zarathostra> I feel dumb right now
12:03:28 <zarathostra> but thanks
12:03:29 <Cale> You could keep Handler if you want it
12:04:19 <zarathostra> is it really helpful since we can do it in just 3 lines ?
12:04:22 <monochrom> @quote monochrom downloaded.ghc
12:04:22 <lambdabot> monochrom says: I was trying to design a sensible language... then I downloaded ghc.
12:04:22 <ReinH> zarathostra: instead of feeling dumb, don't feel dumb.
12:06:27 <zarathostra> ReinH: why? if i think i'm right i can't see my errors so i can't learn from it
12:06:46 <voidzero> that doesn't sound dumb
12:09:58 <ReinH> zarathostra: you can be wrong without feeling dumb
12:10:21 <ReinH> making mistakes is normal, as is not knowing things
12:10:24 <kqr> the struggle is real. either I start my project in haskell and get access to parser combinators which I would really like
12:10:30 <kqr> ...or I do it in C and get the help of a friend
12:10:53 <bob_twinkles> there's always https://github.com/colinh/pegtl
12:11:00 <bob_twinkles> parser combinators in C++ templates
12:11:09 <kqr> c++ is right out unfortunately
12:11:11 <mniip> oh god
12:11:19 <mniip> I wonder if I want to see the horror
12:11:25 <mniip> of C++ parser combinators
12:11:34 <bob_twinkles> it's about as C++ templating gets actually
12:11:47 <zarathostra> why does Haskell use uncatchable errors (which are not purely functional) instead of Either?
12:12:05 <kqr> zarathostra, to make it easier to teach
12:12:45 <zarathostra> as far as I know, Haskell is not written for begginers (eg Monads)
12:12:52 <mniip> zarathostra, imagine all haskell functions returning Either
12:13:00 <mniip> tail, head, fromJust
12:13:14 <ReinH> zarathostra: which uncatchable errors are you referring to?
12:13:50 <zarathostra> ReinH: div and (/), head, tail, and everything mniip said
12:14:12 <ReinH> partial functions are sometimes useful if you can enforce the invariant in other ways, but generally shouldn't be used
12:14:59 <zarathostra> how are exceptions and partial functions related (btw just seen https://wiki.haskell.org/Exception)
12:15:27 <zarathostra> i must leave, thanks for helping
12:15:50 <monochrom> (/) and div are a tug war between "but it clusters up code for those people who use it correctly" and "but it is unsafe for those people who use it incorrectly"
12:16:17 <ReinH> monochrom: and efficiency? boxing floating point results in a Maybe seems bad.
12:17:33 <monochrom> well, I have no interest in participating in the tug war.
12:17:53 <monochrom> but I have a lot of interest in telling both sides of the tug war that the other side is not dead yet.
12:18:01 <ReinH> :)
12:18:41 <ReinH> monochrom: I guess one argument is that if you don't want to incur the cost of checking for zero, you shouldn't be forced to
12:19:37 <dmwit> cmccann: I thought you might enjoy the name I settled on for this operation: `purify m = do { v <- memento m; case v of { Left e -> empty <$ dictate e; Right v -> return (pure v) } }`
12:20:02 <dmwit> to fit in with the confess/absolve/etc. theme =)
12:20:34 <monochrom> is that a religion library?! :)
12:20:47 <ReinH> monochrom: aren't most of them?
12:22:01 <gganley> edwardk: I'm trying to write a SAT solver as a little side project that my professor has sent me on. I remeber talks about the Uniplate library and that there is some relation to Lens. I was curious if Uniplate+Lens would be a nice way to create a SAT solver or am I way off
12:22:20 <mniip> gganley, SAT as in boolean satisfiability?
12:22:26 <gganley> mniip: yes
12:22:51 <mniip> what's wrong with the obvious 2^n solution
12:23:46 <gganley> mniip: obvious solution?
12:24:08 <dmwit> mniip: In practice, heuristics can vastly speed up SAT search.
12:24:26 <mniip> but they're heurisitcs
12:24:26 <dmwit> mniip: It turns out that most (for a very rigorous meaning of most) SAT problems are not in the NP-hard part of the search space.
12:24:48 <dmwit> "heuristic" is not a dirty word
12:26:56 <monochrom> I don't see any useful relation from Uniplate+Lens to SAT solving.
12:26:58 <gganley> I'm doing this little project as an excersise in solving equations using rigorus reasoning. I've never done something like this so its quite new ground. Like I'm allowed to use haskell and parrelelism to speed the program up but no SAT solving libraries for obvious reasons
12:27:40 <gganley> monochrom: I want to implement something like DPLL in haskell: https://en.wikipedia.org/wiki/DPLL_algorithm
12:28:11 <gganley> monochrom: and getting sub expressions and tree rewriting is essential 
12:28:20 <voidzero> dmwit, unless people say "ggheuristic"
12:28:34 <voidzero> as in cool whip
12:28:59 <voidzero> family guy reference, sorry. It's friday night here.
12:30:31 <monochrom> ok, I see that Lens could be convenient (and only convenient). but still no useful relation from Uniplate.
12:31:42 <ReinH> monochrom: tree rewriting and Plated seem related
12:31:50 <gganley> using Control.Lens.Plated seems that it would make things so easy https://hackage.haskell.org/package/lens-4.13/docs/Control-Lens-Plated.html 
12:32:13 <ReinH> I've used Plated to perform query optimizations before
12:33:07 <gganley> rewriteing is perfect for something like unit propagation https://en.wikipedia.org/wiki/Unit_propagation
12:33:15 <tekkkz> hello, its me again
12:33:24 <nitrix> Hello me.
12:33:32 <monochrom> ok, but Control.Lens.Plated is saying "uniplate is being replaced" rather than "uniplate is being used"
12:33:44 <gganley> monochrom: I mispoke
12:33:48 <gganley> mistyped?
12:34:12 <tekkkz> I have these guys: (num:length:_) <- getArgs and i want to parse num and length to a function now, how must this function be defined? everything i tried didnt worked
12:34:25 <ReinH> monochrom: I took "uniplate" to mean "something that does uniplate-y things" :)
12:34:32 <tekkkz> http://ix.io/kUf
12:34:41 <tekkkz> thats what i tried, but its not working
12:34:41 <gganley> ReinH, monochrom: and thats how i meant it lol
12:34:43 <tommd> tekkkz: "pase num and length to a function"?
12:34:56 <tekkkz> parse
12:34:57 <tommd> tekkkz: f (read num) (read len)?
12:35:12 <gganley> :t getArgs
12:35:13 <tekkkz> hm what? nono look my example what is not working
12:35:13 <lambdabot> Not in scope: ‘getArgs’
12:35:19 <tekkkz> http://ix.io/kUf
12:35:25 <ReinH> tekkkz: well, "runcrack" has the wrong type
12:35:26 <gganley> @type getArgs
12:35:28 <lambdabot> Not in scope: ‘getArgs’
12:35:33 <gganley> well fuck
12:35:51 <ReinH> which the compiler should tell you
12:35:52 <tekkkz> what type do i need?
12:35:56 <tekkkz> yeah
12:35:59 <ReinH> tekkkz: what does the compiler tell you?
12:36:02 <tekkkz> :t ("4", "6")
12:36:03 <lambdabot> ([Char], [Char])
12:36:07 <tekkkz> thats my type
12:36:10 <ReinH> No, it isn't.
12:36:14 <ReinH> you use putStrLn
12:36:34 <kqr> is there a quasiquoter for pre-formatted strings?
12:36:49 <kqr> it feels like such an obviousity
12:36:51 <tekkkz> http://ix.io/kUg
12:36:56 <tekkkz> tahts what the compiler tells me
12:37:34 <ReinH> tekkkz: it's telling you exactly what the type should be
12:37:39 <tekkkz> ohh
12:37:40 <tekkkz> ya
12:37:43 <tekkkz> let me have a try
12:37:48 <monochrom> kqr: perhaps http://hackage.haskell.org/package/string-qq
12:37:57 <ReinH> if you removed the type annotation, that type would be inferred and it should just work
12:37:58 <kqr> ah yeah, + various here/heredoc libraries
12:38:00 <tekkkz> (String, String) -> IO a0
12:38:00 <kqr> thanks
12:38:13 <monochrom> the same author actually uploaded about 3 packages under slightly different names doing the same thing. string-qq is just one
12:38:26 <tekkkz> yap
12:38:29 <tekkkz> i just removed it
12:38:30 <tekkkz> thx
12:39:20 <tekkkz> btw, why must i use ++ to merge two arrays instead of one + ?
12:39:27 <ReinH> tekkkz: because + is for numbers
12:39:42 <tekkkz> so + is just addition like in maths and ++ is merging?
12:39:47 <ReinH> :t (+)
12:39:48 <lambdabot> Num a => a -> a -> a
12:39:50 <ReinH> :t (++)
12:39:51 <lambdabot> [a] -> [a] -> [a]
12:39:55 <quchen> edwardk: While I'm on a regex spree to convert Markdown to Wiki, which Wiki is the right one - Trac or Haskell?
12:40:09 <ReinH> Technically, "concatenation". Merging means something else.
12:40:21 <kqr> tekkkz, ++ is smashing together lists, specifically
12:40:35 <kqr> tekkkz, <> smashes together pretty much anything that can be smashed together
12:40:44 <tekkkz> ahh okay
12:40:45 <tekkkz> :D
12:40:46 <kqr> tekkkz, including lists
12:40:58 <tekkkz> man haskell is  really funny man :D im new since today
12:41:01 <chattered> > 1 <> 3
12:41:03 <lambdabot>      No instance for (Show a0)
12:41:03 <lambdabot>        arising from a use of ‘show_M508313435374397614930063’
12:41:03 <lambdabot>      The type variable ‘a0’ is ambiguous
12:41:18 <kqr> chattered, there are two ways to smash together numbers, you have to specify which you want
12:41:22 <kqr> > Sum 1 <> Sum 3
12:41:24 <lambdabot>  Sum {getSum = 4}
12:41:31 <kqr> Product 1 <> Product 3
12:41:33 <kqr> > Product 1 <> Product 3
12:41:34 <lambdabot>  Product {getProduct = 3}
12:41:43 <ReinH> (at least two)
12:41:47 <kqr> well, yes
12:41:55 <chattered> kqr: I know. Just pointing out that "+" and "++" don't really generalise to "<>".
12:42:05 <ReinH> chattered: sure they do.
12:42:17 <ReinH> they do exactly
12:42:31 <chattered> You have to newtype to say what monoid you want.
12:42:34 <monochrom> two great binary operators (associative and commutative too!) on numbers: min, max.
12:42:57 <monochrom> max and min are the greatest binary operators ever!
12:43:18 <monochrom> reason: max is the greatest because x `max` y is the greatest of x and y
12:43:41 <monochrom> err, my reason for min is wrong. I'll have to re-think.
12:43:53 <monochrom> oh, it's right.
12:43:54 <ReinH> monochrom: min is the dual greatest.
12:44:04 <monochrom> min is the greatest because it is the greatest lower bound.
12:44:47 <voidzero> how is min associative?
12:45:07 <voidzero> x `min` y == y `min` x?
12:45:18 <monochrom> (x `min` y) `min` z = x `min` (y `min` z)
12:45:34 <voidzero> oh, of course.
12:45:38 <kqr> voidzero, that's commutatitivy
12:45:52 <kqr> which it also is, luckily
12:47:07 <voidzero> yes, i keep mixing up those two
12:47:08 <kqr> i like that the syntax highlighter in haskell-mode recognises quasi-quoters as strings
12:47:54 <ggole> (And neither holds for floats, hooray!)
12:48:50 <kqr> if you squint
12:59:21 <Cale> ggole: Floating point operations are commutative
12:59:34 <Cale> ggole: They're just not associative
12:59:39 <JagaJaga> Hi, guys! Do smone use Turtle library? How can I output result to the same as input file? Now I'm getting error that the resource is busy.
13:00:20 <shersh> Hello everyone! I have tree definition like this: data Tree a = Leaf | Node a (Tree a) (Tree a), -- which is classic. I'm interested in defining treeFold function in a such way, that `treeFold (:) []` could convert my tree to lilt in inorder traversal. Or simply if I have binary search tree, I want to convert it to sorted list using treeFold. Could anyone help me this task?
13:01:11 <ggole> Cale: some FP ops are commutative. min is not.
13:01:28 <ggole> Try it with some interesting values like -0.0 and NaN.
13:01:58 <ChristianS> JagaJaga: you cannot overwrite a file while you're still reading it. you could write the output to a temp file and finally rename x to x.old (or delete it) and the temp file to x.
13:02:12 <geekosaur> note that this is also true of the shell
13:02:28 <geekosaur> except instead of an error you will get an empty input file
13:02:46 <geekosaur> (sort is a special case, if you use -o)
13:04:24 <JagaJaga> ChristianS: oh.. Thank you.
13:09:14 <Hijiri> > (min (-0) 0, min 0 (-0)) :: (Float,Float)
13:09:16 <lambdabot>  (-0.0,0.0)
13:09:45 <joco42_> http://pasteboard.co/JTz1mp2.png, what does this type constraint mean here ? PyO.Object (IO a) => ?
13:09:59 <joco42_> A (B a) ?
13:10:13 <joco42_> what is the kind of A ?
13:10:29 <joco42_> *->* ?
13:11:21 <voidzero> I'd say *
13:11:34 <joco42_> PyO.Object :: * -> Constraint
13:11:34 <joco42_> *Main> :k PyO.Object
13:12:03 * voidzero quickly shuts up again
13:12:07 <joco42_> ghc says
13:12:11 <joco42_> *Main> :k PyO.Object
13:12:11 <joco42_> PyO.Object :: * -> Constraint
13:12:14 <kqr> what's the easiest way to create a parsec parser that parses "any whitespace except newline-ish characters"?
13:12:41 <joco42_> i think i did not become much wiser... after asking ghc 
13:12:59 <joco42_> voidzero: :)
13:13:25 <geekosaur> PyO.Object is a typeclass. IO a, for whatever a is, must have an instance of PyO.object
13:13:29 <voidzero> come join me at the table for people who silently nod.
13:13:45 <joco42_> :)
13:14:09 <geekosaur> can't really say any more without knowing what PyO.Object is
13:14:23 <joco42_> geekosaur: thanks, how can you tell this ?
13:14:44 <mniip> geekosaur, my name analysis heuristics suggest that it's something to do with python
13:14:51 <joco42_> so a has to be an instance of PyO.Object ? not IO a ?
13:15:00 <geekosaur> (IO a) must
13:15:11 <joco42_> right
13:15:13 <joco42_> indeed
13:15:16 <geekosaur> whether (a) must cn't be answered just from that
13:15:23 <joco42_> yes
13:15:25 <joco42_> i see
13:15:32 <joco42_> this is how i read this too
13:15:51 <joco42_> then this type definition is not what i want...
13:15:53 * geekosaur asks hayoo
13:16:28 <kqr> unrelated: what's the way to install all dependencies with stack?
13:16:56 <kqr> I've always done stack build to accomplish that, but is there a more explicit way?
13:17:34 <kqr> I guess not, nothing useful in the help anyway
13:17:43 <geekosaur> joco42, just looking at your image of igraph.hs, I wonder if you intended "(^.) o s" to be "(^.) o' s"
13:17:49 <joco42_> what i am after is : (^^.) :: PyO.Object a => IO a -> String -> IO PyO.SomeObject
13:17:52 <ReinH> kqr: stack build --dependencies-only ?
13:17:56 <geekosaur> (definition of (^^.))
13:17:59 <joco42_> :)
13:18:09 <joco42_> geekosaur: :)
13:18:11 <joco42_> yes
13:18:20 <joco42_> i think that was my messup
13:18:20 <kqr> ReinH, not an option
13:19:19 <joco42_> geekosaur: I think you solved my mystery, thanks
13:19:47 <joco42_> maybe i should not use '-s anymore
13:20:23 <joco42_> mystery solved: http://pasteboard.co/JUivZQ4.png
13:21:16 <joco42_> correction : http://pasteboard.co/JUm6wJc.png
13:21:28 <nolrai66> So If I wanted to make an irc bot that interacted with a forum what should I read?
13:27:26 <quchen> Well, you need an IRC bot, and you need a program to talk to your forum.
13:27:37 <quchen> Those are pretty independent components of the final program.
13:27:53 <quchen> So you might as well start writing an IRC bot until you're happy with its capabilities.
13:29:41 <josephle> https://wiki.haskell.org/Roll_your_own_IRC_bot is what I used to start writing my own irc bot
13:30:46 <mniip> >irc.freenode.org
13:30:51 <mniip> what is this, 2006?
13:32:45 <josephle> hahahaha
13:34:57 <dgpratt> lately ghc-mod and some other Haskell programs recently installed/built on my computer issue a bunch of warnings along the lines of "warning: _tzset from msvcrt is linked instead of __imp__tzset
13:34:57 <dgpratt> "
13:35:12 <dgpratt> has anyone else seen that? is there an explanation to be had for its cause?
13:35:33 <Shockk> I've had similar warnings from glfw-bindings
13:36:01 <Shockk> https://github.com/bsl/bindings-GLFW/issues/27
13:36:10 <dgpratt> just found this https://ghc.haskell.org/trac/ghc/ticket/10454
13:36:25 <Shockk> is apparently to do with MinGW       
13:36:31 <dgpratt> hmm
13:37:21 <nolrai66> quchen: That makes sense.
13:37:24 <Shockk> looks like it was fixed 6 weeks ago
13:37:28 <Shockk> 5*
13:37:40 <Shockk> https://git.haskell.org/ghc.git/commitdiff/7b211b4e5a38efca437d76ea442495370da7cc9a
13:37:49 <tjpeden> I'm having trouble figuring out how to go from IO String to String... I realize this is super noob, but I'm just not getting it
13:37:55 <dgpratt> oh, cool
13:38:01 <dgpratt> thanks Shockk
13:38:04 <Shockk> np
13:38:25 <nolrai66> The short useless awnser tjpeden is you don't.
13:38:52 <tjpeden> That's kind of what I figured, so what do I do?
13:39:04 <quchen> tjpeden: Did you see the chapter about IO in LYAH?
13:39:06 <geekosaur> usually, >>= (or the do syuntax equivalent which is <-)
13:39:08 <Shockk> tjpeden: if you have an IO String, that's a value representing an IO action that will result in a String
13:39:24 <nolrai66> The more useful awnser is you can use either fmap or bind on (a -> b) or (a -> IO b) to get (IO a -> IO b).
13:39:31 <nolrai66> (respectively).
13:39:47 <quchen> I'm sure that's very useful to someone who doesn't know about IO.
13:39:59 <quchen> ಠ_ಠ 
13:40:08 <nolrai66> (by bind I mean >>=).
13:40:17 <nolrai66> Hey I said more useful.
13:40:25 <nolrai66> Not useful.
13:40:27 <nolrai66> :P
13:40:31 <quchen> Grrr
13:40:32 <geekosaur> do { val <- some IO action; {- here `val` is a String -}
13:41:58 <Sonolin> so you can do something like
13:41:59 <Sonolin> getChar >>= \c -> return $ ord c
13:42:24 <dgpratt> tjpeden, something of type "IO String" is an action that when run will produce a result of type "String"
13:42:51 <dgpratt> you can combine actions together in various ways, such as geekosaur demonstrates
13:43:10 <dgpratt> which make more actions
13:43:18 <Shockk> } -- closing geekosaur's curly braces
13:43:39 <nolrai66> Sonolin: ord <*> getChar, surely?
13:43:41 <dgpratt> ultimately you have to incorporate each action into "main", the action that defines your program
13:45:34 <Sonolin> nolrai66: yea "return ord <*> getChar" right?
13:45:48 <Sonolin> just trying not to confuse
13:45:53 <Sonolin> I'll excuse myself now :P
13:46:02 <Shockk> or 'ord <$> getChar'
13:46:08 <nolrai66> Yeah.
13:46:29 <nolrai66> Return is such a terible name.
13:46:54 <Xe> return just wraps a pure value into a monadic value
13:47:42 <geekosaur> it didn't reallu want to be closed since it needs more to be valid :)
13:47:51 <Shockk> lol
13:49:05 <quchen> The C people probably should not have used the name for monadic unary lifting to signal the result of a procedure.
13:49:21 <dgpratt> lol
13:49:24 <quchen> FSVO unary
13:50:52 <quchen> But despite "return" being a terrible name, we don't have any better ones. "inject" is wrong as well, "lift" is overused as a term, "eta" is indescriptive. "pure" is probably the best of the bunch.
13:51:23 <geekosaur> and pure's not that great (how much sense does it make with the list monad?)
13:51:49 <nolrai66> Wrap?
13:51:52 <quchen> A single result in a nondeterministic computation is somewhat pure.
13:51:54 <dgpratt> promote?
13:52:01 <mniip> if <*> is ap(ply)
13:52:02 <quchen> liftA0?
13:52:06 <mniip> the pure is con(st)
13:52:11 <geekosaur> promote, maybe. wrap incorrectly gives the idea that it's a container
13:52:25 <nolrai66> Eh.
13:52:27 <quchen> Eh, liftA1.
13:52:41 <quchen> Wait, no.
13:52:45 <mniip> liftA0
13:52:47 <quchen> Yes.
13:53:09 <quchen> I keep confusing myself because pure takes an argument, but that's not the n-ary thing that makes the number in liftA*.
13:53:14 <nolrai66> How are applicatives not genralized containers?
13:53:24 <quchen> nolrai66: (r ->) contains what?
13:53:25 <mniip> nolrai66, is IO a container
13:53:27 <quchen> Proxy contains what?
13:53:44 <mniip> Const
13:53:48 <kristof> Applicatives are generalized Functors.
13:53:57 <mniip> not generalized
13:54:01 <mniip> on the contrary
13:54:03 <quchen> No, Functors are generalized Applicatives. :-þ
13:54:14 <mniip> applicatives are extended functors
13:54:20 <Shockk> specialized functors?
13:54:26 <mniip> that is, they are more specific
13:54:26 <kristof> By generalized, I mean to say that it is possible to lift more functions into Applicatives than Functors.
13:54:41 <nolrai66> mniip: generalized, yes. 
13:55:15 <quchen> Applicatives generalize Functor's fmap to take functions of any arity, if that's what you mean. But the abstraction itself is a specialization to the subset of Functors for which such an operation makes sense.
13:55:25 <nolrai66> I mean I guess I can sort of see the argument that they don't "realy" contain something.
13:55:32 <nolrai66> But the intuition works.
13:55:41 <kristof> Right, that is in fact what I mean. We all understand what Applicatives and Functors are, no use preaching to each other over definitions.
13:55:41 <mniip> true
13:55:51 <chpatrick> OverloadedLabels looks pretty swee
13:55:51 <chpatrick> t
13:56:06 <mniip> kristof, "We all understand" gotta doubt that from time to time
13:56:26 <quchen> I understand none of the Applicative laws as demanded by the docs :-S
13:56:54 <quchen> unit and (**) are much easier in that respect, but less useful in practice.
13:57:10 <mniip> well unit and (**) are closer to container intuition
13:57:24 <mniip> and also you can implement <*> in terms of (**) with relative ease
13:57:30 <quchen> Are they? They're closer to "one and associative" intuition for me.
13:58:02 <mniip> correct
13:58:22 <quchen> But then how do unit/** relate to Monad?
13:58:28 <quchen> ap = <*> is fairly simple
13:58:29 <mniip> but (**) is also 'pair up elements from 2 containers'
13:58:45 <quchen> The containers part is unnecessary there.
13:58:55 <quchen> Pair up elements of two things in the same Functor.
13:59:03 <quchen> Doesn't need to be about containment.
13:59:48 <mniip> I guess,
13:59:55 <nolrai66> ..how can something have elements and not be about containment?
14:00:06 <mniip> (*<<) :: Monad m => m a -> (a -> m b) - > m (a, b)
14:00:30 <mniip> nolrai66, a specific functor may have elements
14:00:30 <quchen> nolrai66: Proxy has no elements, yet it is Applicative
14:00:33 <mniip> but a generic one does not
14:00:39 <quchen> data Proxy a = Proxy
14:00:47 <quchen> pure _ = Proxy
14:00:55 <quchen> _ <*> _ = Proxy
14:02:17 <quchen> nolrai66: A "Parser Int" does not contain an Int
14:02:35 <quchen> It's something that makes an Int available in a certain special way, yes, but it doesn't contain it in any way.
14:03:30 <nolrai66> I disagree with that "in anyway" thing.
14:03:42 <nolrai66> *s/thing./.
14:03:54 <quchen> ?quote shachaf /bin/ls
14:03:54 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
14:04:04 <nolrai66> Yes.
14:04:07 <argent0> Hi, how could I use http://hackage.haskell.org/package/regex-compat-0.92/docs/src/Text-Regex.html#subRegex
14:04:11 <argent0> I can't :mod +Text.Regex
14:04:12 <argent0> i'm using the PCRE backend
14:04:42 <quchen> We'll need more details than "I can't".
14:05:14 <argent0> quchen: I have the regex-base and regex-pcre in my project.cabal
14:05:20 <argent0> and I'm running cabal repl
14:06:27 <quchen> nolrai66: Do you know the State Functor/Applicative/Monad instances? It's quite hard to see that as having elements when you look at the source. The instances are literally about modifying *functions* of a certain shape.
14:06:32 <quchen> argent0: Okay, continue?
14:06:51 <quchen> What does :browse Text.Regex say?
14:08:11 <quchen> nolrai66: I agree that one can trick the brain to think about everything as containers, but that requires skewing what you think of as containers quite a bit.
14:08:11 <argent0> quchen: Can't find module. The doc suggests, at least to me, that importing Text.Regexp.PCRE shoudld be the same as Text.Regexp.Base
14:08:59 <quchen> argent0: The Hackage docs say that regex-compat only has one module. http://hackage.haskell.org/package/regex-compat
14:09:01 <argent0> also the function seems to be in the Text.Regexp package. Is that right?
14:09:08 <geekosaur> the source suggests me ot that Text.Regex only works with Text.Regex.Posix
14:09:15 <geekosaur> *to me that
14:10:04 <quchen> Oh, Text.Regex.Posix is a transitive dependency.
14:10:17 <quchen> In that case I guess the import should work.
14:10:35 <argent0> quchen, geekosaur: I'll check that, Thanks
14:12:06 <spion> is there a language extension that allows you to do something like
14:12:15 <spion> with QualifiedNamespace $ ...
14:12:26 <geekosaur> not yet
14:12:31 <mniip> template haskell?
14:12:32 <geekosaur> it's been discussed
14:12:44 <quchen> osa1: I admire your strange code digging skills :-D
14:13:02 <mniip> spion, wait you mean like pascal's "with"?
14:13:05 <spion> geekosaur: cool, I'll google it
14:13:14 <spion> mniip: sort of yes, but only for namespaces
14:13:21 <mniip> ah, C++'s "using"
14:13:25 <quchen> geekosaur: Also on my wishlist: multiple modules per file.
14:15:38 <nolrai66> quchen: Well my original question was how can something have elements and not be at least sort of a container.
14:15:39 <spion> would be cool for things like e.g. let timestampSelector = with Text.XML.Cursor $ descendant >=> laxElement "timestamp" >=> child >=> content
14:15:52 <quchen> nolrai66: "Proxy"
14:15:59 <quchen> That would be the trivial answer.
14:16:06 <quchen> Oh, "have elements".
14:16:14 <quchen> Well, things that have elements are containers, I agree.
14:16:33 <quchen> But I disagree that Applicatives model either.
14:16:48 <nolrai66> <quchen> Pair up elements of two things in the same Functor.
14:16:48 <nolrai66> <quchen> Doesn't need to be about containment.
14:16:54 <nolrai66> ?
14:17:30 <quchen> nolrai66: There is an alternative formulation of Applicative that has  `unit :: f ()` and `(**) :: f a -> f b -> f (a,b)` as operations instead of pure/<*>.
14:17:40 <quchen> (**) is that pairing-up-operation.
14:17:45 <nolrai66> I mean I've been using monads for years, its not that I don't understand what you mean. I just think I have a broader intuition of "container" then you do.
14:18:01 <quchen> ?quote kmc synonym
14:18:01 <lambdabot> kmc says: monads are like containers, as long as you forget everything you know about the meaning of the word "container" and take it to be a totally abstract word synonymous with "monad"
14:18:08 <tjpeden> What am I doing wrong here? https://gist.github.com/tpeden/719c77746cb30d9d8ebf
14:18:10 <nolrai66> Eh.
14:18:32 <quchen> tjpeden: foo lacks IO in its type
14:18:37 <nolrai66> To me container basicly equials Functor+pure.
14:18:53 <quchen> fmap _ Proxy = Proxy
14:18:55 <tjpeden> Sorry, forgot a bit
14:18:56 <quchen> pure _ = Proxy
14:19:06 <quchen> Nothing contained.
14:19:18 <nolrai66> Eh, I guess.
14:19:25 <nolrai66> I mean you still put things in it.
14:19:33 <tjpeden> quchen: Look again, I messed up the function
14:19:42 <tjpeden> quchen: please
14:19:47 <mniip> nolrai66, no
14:19:49 <quchen> pure = \x -> \s -> (x,s) -- contains what?
14:19:51 <mniip> you put no things in it
14:20:08 <nolrai66> (Maybe I should say "cocontainer" and reserve container for things with extract.)
14:20:14 <Hijiri> container of state and value indexed by previous state
14:20:19 <mniip> that's a comonad
14:20:21 <quchen> Lists are containers of things but don't have extract.
14:20:33 <nolrai66> quchen: yes they do.
14:20:39 <nolrai66> Or..wait no.
14:20:48 <nolrai66> Because [].
14:20:52 <nolrai66> Right.
14:21:17 <nolrai66> Eh. Then I go back to Functor + Pure.
14:21:27 <quchen> Then I go back to Proxy. This doesn't lead anywhere.
14:22:01 <nolrai66> Proxy is a trivial case, yes.
14:22:14 <quchen> tjpeden: I don't know what you're trying to accomplish here. What do you want your "foo" to do?
14:22:15 <nolrai66> But well its also a trivial Functor.
14:22:19 <lpaste_> geekosaur pasted “for tjpeden” at http://lpaste.net/141262
14:22:42 <quchen> State is a nontrivial Functor. What does \s -> (x,s) contain?
14:22:45 <geekosaur> note that "foo" must be in IO
14:23:44 <fjordrunner> please,...I'm trying to query my sqlite db with persistent with following command: get $ Key (PersistInt64 $ fromIntegral id)
14:24:02 <fjordrunner> but I'm getting: Not in scope: data constructor ‘Key’
14:24:20 <Hijiri> what module does Key come from?
14:24:20 <cmccann> dmwit: yes, excellent choice of name, I approve
14:24:38 <Hijiri> it means you haven't imported Key from wherever it's from
14:24:40 <fjordrunner> that is, what I'm trying to figure out,...
14:24:44 <Gurkenglas> fjordrunner, have you imported PersistInt64 but not Key?
14:24:53 <nolrai66> quchen: the x indexed by s?
14:25:05 <tjpeden> quchen: foo should return string concatenated with suffix which takes the return value of currentBranch
14:25:18 <quchen> So `\x -> x` contains () indexed by x?
14:25:27 <quchen> I don't think id is much of a container.
14:25:49 <Hijiri> I found it in Database.Persist.Class
14:25:52 <Hijiri> using hayoo
14:26:03 <Hijiri> maybe it's also reexported by some other modules
14:26:14 <quchen> nolrai66: We can play this game forever, I've had this talk a couple of times, on both sides of the opinion spectrum :-þ
14:26:18 <Hijiri> it should be reexported by Database.Persist
14:26:21 <nolrai66> quchen: yes.
14:26:33 <nolrai66> ..well sort of.
14:26:35 <tjpeden> geekosaur: I'm not sure if that's quite what I'm trying to do.
14:26:59 <nolrai66> \ () x -> x contains x indexed by ().
14:27:11 <spion> hmm can't find a proposal for "with" - probably googling the wrong thing
14:27:18 <geekosaur> it does what you described to quchen
14:27:19 <Gurkenglas> Google says PersistInt also comes from that module, so he should just need to add Key to his import Database.Persist line
14:27:26 <quchen> nolrai66: You can use the container analogy for yourself if it's helpful, but I don't think it's good practice to teach others that way. There are plenty of pitfalls from that way of thinking. When you already *know* what a Monad is and you find this way of lying to yourself helpful (which is what I'm secretly doing) then that's alright.
14:27:35 <geekosaur> spion, try "open"
14:27:47 <spion> ohh open as in ML?
14:28:03 <geekosaur> also the original request was for something similar but different, "with"/"open" was brought in as a better way to accomplish it
14:28:16 <geekosaur> (they asked for "import" local to a "let"/"where", iirc)
14:28:20 <quchen> `\x -> ((),x)` is `id` is `\x -> x`, and that's not a container for me.
14:28:39 <geekosaur> and yes, as in ML
14:28:42 <nolrai66> quchen: yeah I guess. I mean..I am not saying my intuition is perfect, but people act like the container idea breaks down and it doesnt.
14:28:48 <fjordrunner> Hijiri: thank you, but even when I import it, it still can not find it,..
14:28:50 <nolrai66> Is a an empty list a list?
14:29:07 <quchen> I'll just stop here before I get ლ(ಠ益ಠლ)
14:29:07 <tjpeden> geekosaur: it does? wow, I'm really bad at this
14:29:47 <nolrai66> Also () is cheating because its somewhat special.
14:29:59 <quchen> How is being special cheating
14:30:00 * hackagebot MFlow 0.4.5.12 - stateful, RESTful web framework  https://hackage.haskell.org/package/MFlow-0.4.5.12 (AlbertoCorona)
14:30:14 <quchen> "Let's talk about natural numbers but you can't use 0 because that's special and cheating"
14:30:17 <nolrai66> Because you get trivial examples when you use trival examples.
14:30:24 <geekosaur> I could have written it in a few other ways as well, some of which might have been clearer; I went for more idiomatic (although some would have used <$> instead)
14:30:33 <nolrai66> quchen: Yes, and lots of times you have to just that.
14:30:45 <quchen> I gave you a trivial counterexample. That doesn't mean the example is stupid, it means the thing it's disproving is easily disproven.
14:31:04 <geekosaur> foo string = currentBranch >>= \s -> return (string ++ suffix s)
14:31:06 <geekosaur> same thing
14:31:16 <nolrai66> Being a container of () doesn't mean anything though.
14:31:27 <nolrai66> (Well it means your not Void).
14:31:45 <nolrai66> (But in Haskell thats only sort of meaning full..)
14:32:33 <nolrai66> I mean its like saying something doesn't use prime numbers because it doesn't work on 1.
14:34:02 <Hijiri> if \x -> x is a container, I would say it's for any type a, a container of a indexed by a
14:34:05 <Hijiri> not a container of ()
14:34:27 <Hijiri> or you could interpret any function as just the result type indexed by the input type if you really wanted
14:34:55 <nolrai66> Yeah, but it is isomorphic to \ () a -> ((), a).
14:35:23 <nolrai66> Yes..that is what indexed by (in this context) means isn't it?
14:35:40 <nolrai66> Which is why I am saying () is a special case.
14:35:57 <Hijiri> \() a -> ((), a) isn't really a container of () either
14:36:06 <tjpeden> Still having trouble, so I posted the actual code: https://gist.github.com/tpeden/fe26871675ae03b7e0b3
14:36:09 <lpaste_> geekosaur annotated “for tjpeden” with “for tjpeden (annotation)” at http://lpaste.net/141262#a141264
14:36:25 <nolrai66> Ah, should be \ a -> ((), a).
14:36:28 <nolrai66> Sorry.
14:36:36 <Hijiri> that wouldn't be either, its' a continer of ((), a)
14:36:39 <Hijiri> container*
14:36:52 <geekosaur> what kind of trouble?
14:37:19 <nolrai66> Yeah, but State \ a -> ( (), a) is a container of ().
14:37:23 <geekosaur> I note that your `git` function is a stub which doesn't pass any parameters to the `git` program, so it's not going to do anything useful
14:37:25 <tjpeden> geekosaur: you're my hero... that makes so much more sense
14:37:34 <nolrai66> (Because of the differnt Functor/Aplicative instances.)
14:37:36 <cheater> quchen: you make me hungry.
14:37:40 <geekosaur> (other than give you a usage message)
14:37:48 <geekosaur> if you got an error, add the full error message to the paste
14:37:50 <cheater> sorry, wrong window.
14:38:16 <Hijiri> what does that have to do with the containerness
14:38:46 <tjpeden> geekosaur: updated gist with error message
14:38:51 <Hijiri> if anything it would be more "natural" to call it a container of a, since that's the type argument to State
14:38:53 <geekosaur> oh, I see. you have updateFirstLine :: [String] -> [String] but you cannot do IO in there
14:39:22 <Hijiri> if it was natural at all in the first place, at least
14:39:31 <cheater> Hijiri: I would say a function that always returns a () is a container of (). so \() a -> ((), a) would be a container of a.
14:39:34 <geekosaur> I would suggest that you are going about this the wrong way, since you are going to run the git rev-parse for every line
14:39:44 <geekosaur> or rather every string
14:39:52 <Hijiri> cheater: I agree
14:40:00 <geekosaur> I would run it once and pass it to updateFirstLine and thence to update
14:40:01 <cheater> rather, a function that always returns a tuple that has () inside it.
14:40:09 <tjpeden> geekosaur: Just the first line... or that's what I'm hoping
14:40:47 <tjpeden> geekosaur: but you're right, I'm most likely going about this the wrong way
14:40:49 <nolrai66> Hijiri: State a b is a container of b by the normal Functor/Aplicative instance, because I am arguing that Aplicative is "genralized container".
14:41:17 <nolrai66> And people are saying thats a bad intuition.
14:41:20 <kristof> Arrrggh. It's Writer w a, but writer :: (a, w) -> Writer w a?
14:41:25 * kristof kicks something
14:41:32 <nolrai66> Yes.
14:41:55 <Hijiri> I think it's a bad intuition
14:42:07 <quchen> kristof: Same thing with State
14:42:14 <Hijiri> I think when people think of container, they think of real tangible values already existing somewhere in the data structure
14:42:36 <Hijiri> and people don't tend to think of functions as containers
14:42:55 <kristof> Hijiri: You mean, * a generator for a value existing somewhere in the data structure
14:43:15 * bitemyapp scrunches up face
14:43:24 <kristof> bitemyapp: hope it stays that way
14:43:30 <nolrai66> I guess.
14:43:34 <nolrai66> I don't though.
14:43:34 <cmccann> a function is just a fixed-size container, holding one element for each value of the argument type. this is a completely sensible way to think about it, undoubtedly.
14:43:36 <Hijiri> kristof: what do you mean
14:43:45 <bitemyapp> kristof: try putting a church-encoding into those words :P
14:44:19 <kristof> ._.
14:44:39 <bitemyapp> kristof: what's the advice polyglots always give you?
14:44:40 <cmccann> bitemyapp: in other news, what bizzaro world have I wandered into when you're one of the more patient and polite people involved in a discussion on /r/haskell
14:44:58 <kristof> bitemyapp: I don't know, what is the advice?
14:45:01 * hackagebot dynobud 1.7.1.0 - your dynamic optimization buddy  https://hackage.haskell.org/package/dynobud-1.7.1.0 (GregHorn)
14:45:01 <bitemyapp> cmccann: you know how a lot of misbehaving dogs just need play & exercise so they mellow out?
14:45:08 <cmccann> haha
14:45:11 <bitemyapp> cmccann: that, but I'm a bear and it's the book rather than play & exercise.
14:45:24 <bitemyapp> kristof: don't translate into the language you're speaking, think in the language.
14:45:26 <cmccann> sounds very thetaputic
14:45:34 <cmccann> theraputic even
14:45:39 <cmccann> or something, I can't spell tonight
14:45:44 <bitemyapp> kristof: functions (lambdas) should be a first order construct in your head, not something you're smuggling into containersville
14:45:51 <kristof> bitemyapp: I've never heard that advice before, but speaking 3 languages fluently, I think it's very good advice.
14:45:59 <bitemyapp> funny thing is, I'm a monoglot.
14:46:02 <bitemyapp> anyhoo
14:46:11 <kristof> You live in Tejas
14:46:16 <kristof> speak the native language
14:46:23 <bitemyapp> the native language is BBQ
14:46:39 <bitemyapp> Cale's advice to write things out is useful because it forces you think in those terms.
14:46:47 <slack1256> I wouldn't mind being monoglot if that's the native lang
14:46:55 <bitemyapp> cmccann: anyway, thank you :)
14:47:08 <lpaste_> geekosaur pasted “commit-msg.hs (untested)” at http://lpaste.net/141267
14:47:08 <bitemyapp> cmccann: though, that thread did bring something very annoying to my attention which I am likely to act upon soon.
14:47:36 <cmccann> bitemyapp: on the whole that thread could have gone much worse than it has
14:47:44 <geekosaur> hm, that's slightly wrong come to think of it
14:48:01 <bitemyapp> cmccann: oh for sure. Just a handful of rude people.
14:48:17 <lpaste_> geekosaur revised “commit-msg.hs (untested)”: “commit-msg.hs (still untested)” at http://lpaste.net/141267
14:48:33 <geekosaur> tjpeden, ^^
14:48:33 <bitemyapp> the sniping at FPco is fucking bizarre given WT and IHG, but w/e
14:49:30 <nolrai66> Eh, to me containers are restricted functions.
14:49:39 <nolrai66> Sort of.
14:50:17 <cmccann> bitemyapp: it has something to do with how they present themselves publicly but I really don't understand the reaction
14:50:37 <nolrai66> I mean just because functions are a kind of container, doesn't mean functions aren't fundamental.
14:50:48 <bitemyapp> cmccann: clearly taking a cue from the Illuminati would've avoided this
14:50:51 <tjpeden> geekosaur: hmm I guess I don't understand fmap very well
14:50:58 <nolrai66> Addition is a group for example.
14:51:06 <nolrai66> (Well with negatives.)
14:51:08 <tjpeden> I get the partial application part
14:51:14 <bitemyapp> cmccann: I had people taking some pretty nasty snipes at me over the book because they didn't want people buying a book from somebody that was so self-aggrandizing
14:51:16 <cmccann> bitemyapp: yeah but that's not possible
14:51:22 <cmccann> bitemyapp: the illuminati are a cabal, after all
14:51:26 <bitemyapp> cmccann: LOL
14:51:38 <geekosaur> well, the first thing you are missing in most of this is that what happens in IO stays in IO. you cannot use an IO action in a [String] -> [String]; it has to be [String] -> IO [String]
14:51:44 <nolrai66> bitemyapp: Who they talking about?
14:52:08 <tjpeden> geekosaur: I did miss that. I like the way you put that lol
14:52:15 <bitemyapp> cmccann: I'm not sure how else I was supposed to make people aware of the book other than to talk about it in forums and explain why it's different.
14:52:15 <ezrios> why are Elm extensible records so much easier to work with than Haskell's implementations?
14:52:30 <ezrios> are Haskell's implementations of extensible records stricter/offer stronger guarantees?
14:52:50 <bitemyapp> ezrios: well, Haskell's just a bigger language for one
14:52:55 <geekosaur> mostly that haskell does not yet have a good story for extensible records, I think
14:53:01 <geekosaur> they're working on it for ghc8
14:53:10 <bitemyapp> ezrios: for another, most implementations of a record system (vinyl, nikita volkov's) are libraries which have limitations.
14:53:15 <bitemyapp> ezrios: Elm's is baked into the language.
14:53:15 <kristof> what are extensible records
14:53:21 <kristof> record subtyping?
14:53:27 <bitemyapp> kristof: I think they're like the Stretch Armstrong of record types.
14:53:40 <kristof> That reference went right over my head
14:53:44 <bitemyapp> okay, I'm old.
14:53:45 <cmccann> bitemyapp: that kinda doesn't surprise me and I think it's partly the same reaction? like a "oh no, they're selling something, they must have evil ulterior motives".
14:53:47 <ezrios> geekosaur: when is ghc8 slated to release?
14:53:48 <kristof> I only know of Lance and Neil
14:54:00 <bitemyapp> cmccann: I wouldn't have bothered writing a book if I didn't think it was sorely needed.
14:54:09 <bitemyapp> cmccann: I got tired of patching over problems in existing resources in the guide.
14:54:26 <geekosaur> ezrios, the plan I've heard is the branch gets cut in November and from there it's up to release engineering
14:54:30 <bitemyapp> a book was the only thing I was going to be happy with long term. I would've made way more money contracting and investing the savings if that was my primary concern.
14:54:38 <geekosaur> (i.e. debugging and polishing)
14:55:08 <geekosaur> bitemyapp, I have to admit I was wondering if the kids here would get that :)
14:55:20 <bitemyapp> it's not easy being grey
14:55:22 <geekosaur> https://en.wikipedia.org/wiki/Stretch_Armstrong
14:55:34 <geekosaur> 1976
14:55:40 <bitemyapp> book is adding nicely to my grey-hair collection too
14:55:47 <bitemyapp> I'll have a nice shock of it soon
14:55:52 <tjpeden> geekosaur: It seems to still have some errors, but I've got to go for now. Thanks so much for your help! I'll be back on later if you
14:56:22 <nolrai66> bitemyapp: what book did you/are you writing?
14:56:38 <bitemyapp> nolrai66: http://haskellbook.com/
14:56:41 <tjpeden> if you're still on and don't mind helping me some more*
14:57:02 <geekosaur> ezrios, I will remind you that the past several major releases of ghc have tended to take much longer than expected
14:58:13 <geekosaur> (and some minor releases; 7.8.1 was expected to be released during ICFP 2013.... 
14:58:16 <kristof> Okay, extensible records is record subtyping. Got it.
14:58:19 <geekosaur> oh, whoops
14:58:42 <geekosaur> started out thinkng it was 7.8.3 that was delayed, didn't fix start of message after correcting
15:04:31 <ferdev> hi
15:04:43 <ferdev> guys
15:04:43 <GLM> Is there a function that returns Nothing if a function is True but just a value if it is true?
15:05:23 <ferdev> I have a hash pwd and salt. Does exist anyway to get de encrypt text ?
15:06:19 <geekosaur> GLM, can you ... rephrase that question?
15:06:27 <ferdev> sorry about my english
15:06:30 <ferdev> I have the next
15:06:32 <ferdev> hash
15:06:40 <ferdev> 76bdaaf33b5f01b26f592970b4fda105b7e2a69146dafcb140d3e84c891ecd49
15:06:44 <cmccann> GLM: something like "justIf :: (a -> Bool) -> a -> Maybe a"?
15:06:46 <ferdev> and one thing called salt
15:06:53 <geekosaur> ferdev, hashes are not generally reversible
15:06:58 <GLM> geekosaur: This is what I currently have
15:06:59 <GLM> git remote add origin https://github.com/GarrettMosier/Hatris.git
15:07:04 <ferdev> ah ok
15:07:11 <GLM> Not that
15:07:18 <ferdev> so... no exist any way to get the text ?
15:07:51 <GLM> addPiece :: Board -> Piece -> Maybe Board 
15:07:51 <GLM> addPiece board piece = if isValidBoard updatedBoard 
15:07:51 <GLM>                             then Just updatedBoard 
15:07:51 <GLM>                             else Nothing
15:07:51 <GLM>                         where updatedBoard = board
15:07:57 <geekosaur> ferdev, the hash for 100MB of text is the same size as the hash for 8 characters of text
15:08:07 <cmccann> ferdev: not being able to to get the text is kind of the point of hashing passwords
15:08:08 <geekosaur> you cannot tell which it is
15:08:15 <GLM> geekosaur:I'm hoping to convert that to something like bind
15:08:22 <geekosaur> and it should be obvious that you could not unpack that hash into 100MB of text
15:09:01 <ferdev> the text is between 5 and 10 chars
15:09:06 <geekosaur> so?
15:09:19 <geekosaur> if it's not reversible for the one, how would it be for the other?
15:09:24 <geekosaur> think about it a bit
15:10:32 <ferdev> ok, thanks man
15:10:47 <geekosaur> it should be obvious that you cannot reverse a short hash into 100MB of data. which should also tell you that a hash computed the same way on 5 charatcres *also* cannot be reversed
15:10:52 <geekosaur> you cannot distinguish the two
15:11:17 <ferdev> I got it
15:11:23 <geekosaur> the most you can do is run a dictionary attack, hashing words from some source with the salt and seeing if the reuslting hash matches
15:12:04 <geekosaur> ...and if the hash is something like PBKDF2 then even that gets somewhat expensive
15:12:12 <ferdev> Im trying that, with hashcat
15:12:26 <cmccann> GLM: I don't think the kind of utility function you're looking for exists in any standard library, no
15:12:39 <ferdev> but is very very slow... 
15:12:48 <geekosaur> well, yes
15:12:54 <GLM> cmccann:Really? I figured that'd be a standard operation for Maybe
15:12:55 <geekosaur> that also is kinda the point of hashing
15:13:02 <geekosaur> it's not *supposed* to be easy to do this
15:13:04 <ferdev> yes :)
15:13:06 <geekosaur> or fast
15:13:33 <cmccann> GLM: it's one that's obvious enough to get reinvented often but apparently not persuasive enough to get added to the core library
15:13:47 <cmccann> at least last I checked
15:13:51 <lyxia> mfilter ?
15:14:07 <lyxia> > mfilter odd (Just 1)
15:14:08 <lambdabot>  Just 1
15:14:11 <ferdev> tank you geekosaur for you help 
15:14:11 <lyxia> > mfilter even (Just 1)
15:14:13 <lambdabot>  Nothing
15:15:44 <cmccann> lyxia: "\f x -> mfilter f (Just x)" is the form I find most useful
15:15:57 <cmccann> which is just enough of an annoyance that I like to give it a name
15:16:43 <lyxia> Right, I see your point now.
15:16:50 <mniip> cmccann, generalization: mfilter f (return x)
15:18:30 <GLM> lyxia:Just got that solution working. Thanks. Do you know a way of doing that without putting in something as a Maybe?
15:19:10 <hexagoxel> can the networks in reactive-banana be "rewired" dynamically? i.e. is it possible to implement a spreadsheet with changeable formulas?
15:19:47 <lyxia> > (find odd [1], find even [1])
15:19:49 <lambdabot>  (Just 1,Nothing)
15:19:53 <lyxia> You can put it in any Traversable with find! :D
15:20:35 <lyxia> Otherwise, it's as cmccann said.
15:21:12 <lyxia> s/Travers/Fold/
15:22:30 <cmccann> lyxia: ha, nice. I think I like that better than the MonadPlus version using mfilter.
15:24:51 <lyxia> It looks cool indeed, just let 1 be some complex expression and the only thing that looks weird is the brackets.
15:24:58 <Cooler> how do you use data to define new types?
15:26:53 <lyxia> Cooler: data MyType = MyConstructor FieldType
15:28:23 <geekosaur> maybe the right question here is "what kind of new type do you want?"
15:28:50 <Cooler> what the deriving keyword do?
15:30:04 <MarcelineVQ> It generates certain default code for your type
15:30:22 <Cooler> what does that mean?
15:30:48 <MarcelineVQ> Well if you derive Show, your type can be turned into a string already
15:31:21 <MarcelineVQ> because it gets a default `show` method generated for it
15:31:54 <Cooler> how does it turn a type into a string?
15:32:22 <Cooler> also why is it called Show instead of toString()
15:33:23 <nolrai66> 4 letters vs. 7?
15:33:37 <Intolerable> because "show something" makes more sense than "toString something"
15:34:51 <Zekka> Cooler: There's no real reason, it's just a convention to call that operation 'show'
15:34:57 <Cooler> how does it turn a type into a string?
15:35:00 <Zekka> There had to be some name for it and that's what the Haskell authors picked
15:35:05 <MarcelineVQ> Show is a type class, which lets things that implement it have common operations, in the case of Show that common operation is called `show` and it turns your type into a string. How it does that is different for each type, in general, though there's probably a basic method for when you're using `deriving (Show)`
15:35:07 <Zekka> Cooler: It depends on the data type -- do you know about typeclasses?
15:36:07 <Cooler> don't you have to specify how to convert your type into a string?
15:36:28 <Cooler> actually implement show i mean
15:36:49 <Intolerable> no
15:36:59 <Intolerable> deriving does that for you
15:37:19 <MarcelineVQ> Certainly you can, you just don't derive (Show) and instead create an `instance` of Show for your class, but you don't have to
15:37:20 <Intolerable> @let data Hello x = Hello (Maybe x) deriving Show
15:37:22 <lambdabot>  Defined.
15:37:30 <Intolerable> > Hello (Just 5) :: Hello Int
15:37:34 <lambdabot>  Hello (Just 5)
15:37:38 <geekosaur> Cooler: there's a few things here. first, for some types you do in fact want to specify it yourself, but in most cases you can derive it
15:37:45 <barrucadu> Cooler: If the compiler knows how to turn all the components of your type into a string, it can figure out how to turn the entire thing into a string
15:38:04 <geekosaur> second, Show and Read are expected to be related, such that you can round-trip a value through them
15:38:13 <osa1> @tell quchen heh :) what's strange about it?
15:38:13 <lambdabot> Consider it noted.
15:38:20 <cmccann> in fact, if you're exporting the constructors it's generally bad form to write a custom, non-standard Show instance
15:38:32 <geekosaur> third, they're really intended more for debugging usage and as such are expected to produce something resembling Haskell source code
15:38:38 <Cooler> in the first example shown here
15:38:39 <Cooler> http://www.seas.upenn.edu/~cis194/spring13/lectures/02-ADTs.html
15:38:47 <Cooler> the data Thing example
15:38:50 <geekosaur> (so as to closely represent what the original would have looked like if you typed it into your program)
15:38:56 <Cooler> how does it convert it to a string?
15:39:31 <Zekka> Cooler: It cheats and looks at the actual definition of your type, then uses that information to generate a Show instance
15:39:33 <geekosaur> so we prefer to derive Show and Read because that way we get things that adhere to all three (the Haskell Language Report describes how Show and Read derivation work)
15:39:45 <Zekka> There's not really a way in pure Haskell to do what 'deriving (Show)' is doing, barring language extensions
15:40:14 <Zekka> (pure as in "only Haskell inside your program" not "side-effect free")
15:40:59 <Cooler> it uses reflection to look at the name of the constructors?
15:41:06 <hpc> i would perhaps say "in-language" rather than "pure"
15:41:14 <Zekka> hpc: That's a better word
15:41:16 <Zekka> less ambiguous
15:41:19 <hpc> it doesn't use reflection, it's just generated code
15:41:29 <Zekka> Cooler: It generates code at compile time by looking at its internal representation of your type
15:41:30 <kristof> ...I've got a function definition in a where clause. How do I give it a type hint?
15:41:34 <hpc> it's also not a conversion
15:41:39 <monochrom> "the compiler does it for you" is different from reflection
15:41:45 <geekosaur> kristof, same way you would at the top level?
15:42:02 <Cooler> what exactly are the strings generated
15:42:06 <Zekka> It's only like reflection in that it's looking at a representation of your type instead of values of your type
15:42:16 <monochrom> in particular, reflection means "you do it yourself" therefore "the compiler doesn't do it for you"
15:42:29 <Zekka> Cooler: For the Thing example, show can output "Shoe" "Ship" "SealingWax" "Cabbage" or "King"
15:42:33 <lpaste_> geekosaur pasted “type annotations work the same in where (and let for that matter)” at http://lpaste.net/141271
15:42:44 <MarcelineVQ> kristof: you can have `myfunc :: Int -> Int` on the line above it in your where clause
15:42:55 <Zekka> Usually the Show instance will generate code that looks pretty close to valid Haskell for the original value
15:43:10 <Zekka> @data X = LeftBranch Int | RightBranch Int String
15:43:11 <lambdabot> Unknown command, try @list
15:43:11 <hpc> *will generate code that outputs
15:43:18 <Zekka> @let data X = LeftBranch Int | RightBranch Int String
15:43:19 <lambdabot>  Defined.
15:43:23 <Zekka> hpc: Whoops, typo!
15:43:27 <barrucadu> kristof: If your type annotation needs to refer to type variables from the top-level definition's type signature, look up ScopedTypeVariables
15:43:30 <Zekka> > show (LeftBranch 40)
15:43:31 <lambdabot>      No instance for (Show X) arising from a use of ‘show’
15:43:31 <lambdabot>      In the expression: show (LeftBranch 40)
15:43:36 <hpc> the generated code for the show instance is kinda icky
15:43:39 <Zekka> @let data X = LeftBranch Int | RightBranch Int String deriving (Show)
15:43:40 <lambdabot>  .L.hs:152:1:
15:43:40 <lambdabot>      Multiple declarations of ‘X’
15:43:40 <lambdabot>      Declared at: .L.hs:149:1
15:43:43 <geekosaur> https://www.haskell.org/onlinereport/haskell2010/haskellch11.html#x18-18600011.4
15:43:45 <Zekka> oh phooey
15:43:58 <Shockk> I'm still to try and write a read instance
15:44:00 <Shockk> :(
15:44:06 <hpc> because it's dealing with operator precedence and other things internally which you wouldn't expect from just looking at input and output
15:44:17 <Zekka> Shockk: You probably shouldn't be writing that stuff yourself, it's a pain in the rear
15:44:19 <hpc> (or maybe it was read that was ugly)
15:44:33 <Shockk> Zekka: true
15:44:54 <hpc> you should never be writing the instances yourself unless you're in deep enough to know better
15:48:07 <Cooler> Zekka, that piece of code gives an error
15:48:09 <Cooler> let data X = LeftBranch Int | RightBranch Int String deriving (Show)
15:48:19 <Cooler> parse error in let binding: missing required 'in'
15:48:24 <GLM> Would the Writer Monad be the best choice to accumulate a score in a game while updating the board state?
15:48:54 <Zekka> Cooler: 'let' is just a prefix lambdabot uses for commands that define things
15:49:05 <Zekka> it has a different, much more specific meaning in Haskell
15:49:12 <Zekka> So drop the let, try just using data X = [...]
15:49:13 <hpc> Cooler: @let, anyway
15:49:32 <Shockk> GLM: it depends if you need to read from that score while updating
15:49:33 <Cooler> Zekka, i tried it in the REPL, where you do need let to define functions
15:49:37 <hpc> lambdabot has a file it hides user-specified definitions in, @let puts a line in that file (after sanity checks and things)
15:49:44 <Zekka> Cooler: You can't define data types in the repl afaik
15:49:58 <Zekka> I have to go, but there's other guys here who can probably help you with this stuff.
15:50:04 <GLM> Shockk:What do you mean by read? I'd like to have the intermediate scores so I can display it on the GUI I'll be adding later
15:51:23 <hpc> Cooler: a relatively easy way to write haskell and not have to worry about which form of what you need to use when
15:51:26 <Shockk> I mean, you can't get what you write into Writer except as the result of runWriter or whichever function you use to run it
15:51:41 <hpc> Cooler: is to do all your coding in a file, run "ghci thatfile.hs", and use :r to reload the changes you make
15:52:36 <Shockk> so if you also need to get the current score at any point in the same place you want to update the score, you'd need to use State rather than Writer for that
15:52:59 <cmccann> personally, I do all my coding in a /msg tab to lambdabot, then copy-and-paste from the IRC client chat log when I'm done.
15:53:09 <Cooler> hpc i know, i am using the REPL to test out small code fragments
15:53:10 <hpc> Cooler: and once you get more comfortable and familiar with what haskell looks like, there's a trick to remembering when certain syntax forms can be used where
15:53:35 <hpc> the REPL is juuuust slightly different from writing code in a file
15:53:39 <GLM> Shockk:Thanks. I'll look at that. Is there a seperate Monad for seeing the score at all points in time?
15:53:48 <kristof> Can someone please help me with this type signature? http://lpaste.net/141274
15:53:52 <Shockk> what do you mean?
15:54:01 <hpc> mainly due to how "let" works, but there's probably other differences i am forgetting
15:54:33 <Cooler> @let datatest X = LeftBranch Int | RightBranch Int String deriving (Show)
15:54:33 <lambdabot>  Parse failed: Parse error: |
15:54:40 <Cooler> why is it giving a parse error
15:54:56 <kristof> Here's the version with the error: http://lpaste.net/141274
15:55:16 <Shockk> datatest?
15:55:27 <Cooler> oh
15:55:32 <hpc> data Test
15:55:41 <hpc> :k Test
15:55:42 <lambdabot> Not in scope: type constructor or class ‘Test’
15:55:44 <Cooler> @let data TestX = LeftBranch Int | RightBranch Int String deriving (Show)
15:55:45 <lambdabot>  .L.hs:153:14:
15:55:45 <lambdabot>      Multiple declarations of ‘LeftBranch’
15:55:45 <lambdabot>      Declared at: .L.hs:150:10
15:55:53 <hpc> @undefine
15:55:53 <lambdabot> Undefined.
15:55:59 <hpc> @let data TestX = LeftBranch Int | RightBranch Int String deriving (Show)
15:56:00 <lambdabot>  Defined.
15:56:19 <Cooler> show (LeftBranch 40)
15:56:24 <Cooler> @show (LeftBranch 40)
15:56:24 <lambdabot> "(LeftBranch 40)"
15:56:29 <Shockk> would be interesting if lambdabot did that per-user
15:56:32 <hpc> > LeftBranch 40 -- also works
15:56:33 <lambdabot>  LeftBranch 40
15:56:45 <Shockk> had per-user defines, that is
15:56:48 <kristof> Should I just follow the advice and use Flexbile Contexts?
15:56:57 <Cooler> i don't understand what show did
15:57:07 <geekosaur> kristof, I suspect your problkem there is that you assume the a and b in lfn are the same as the ones in bindMaybeWrite2
15:57:09 <Cooler> it literally just printed out the argument
15:57:15 <hpc> the @show command is some lambdabot thing
15:57:21 <kristof> geekosaur: I expect them to be, yes
15:57:26 <hpc> @show "<!@IH$IN NOT valid haskell does this work?"
15:57:26 <lambdabot> "\"<!@IH$IN NOT valid haskell does this work?\""
15:57:28 <geekosaur> i.e. you need ScopedTypeVariables
15:57:33 <hpc> @show <!@IH$IN NOT valid haskell does this work? -- er
15:57:33 <lambdabot> "<!@IH$IN NOT valid haskell does this work? -- er"
15:57:38 <Gurkenglas> :t (WriterT (undefined :: Maybe (a, String)) >>=) -- If you're implementing that out of necessity rather than interest, you can just use WriterT.
15:57:39 <lambdabot> (a -> WriterT String Maybe b) -> WriterT String Maybe b
15:57:41 <hpc> right, so @show does nothing
15:57:43 <Gurkenglas> *kristof
15:57:52 <kristof> geekosaur: And in fact I would expect the "a" and "b" to mean precisely the same thing.
15:57:56 <Cooler> @Show (LeftBranch 40)
15:57:56 <lambdabot> "(LeftBranch 40)"
15:58:04 <Cooler> Show is the same though
15:58:05 <hpc> the REPL (and lambdabot's expression evaluation) will automatically show what you give it
15:58:06 <kristof> Gurkenglas: I am implementing this out of interest to validate the necessity of monad transformers
15:58:08 <hpc> if possible
15:58:12 <geekosaur> then you want ScopedTypeVariables, becausr that is *not* how things work
15:58:14 <hpc> > id -- some things can't be shown
15:58:15 <lambdabot>      No instance for (Typeable a0)
15:58:15 <lambdabot>        arising from a use of ‘show_M3328235760026102808499’
15:58:15 <lambdabot>      In the expression:
15:58:28 <hpc> > getLine -- and some things are weird and special in lambdabot
15:58:29 <lambdabot>  <IO [Char]>
15:58:31 <Cooler> what about the deriving (Show)
15:58:41 <Cooler> how do you call that?
15:59:07 <geekosaur> kristof, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/other-type-extensions.html#scoped-type-variables
15:59:09 <hpc> deriving (Show) just means that now the function show works on values of that type
15:59:16 <kristof> Gurkenglas: I am finding that when you compose two monads together, it turns out that you can always define a bind for that monad with something along the lines of mna >>= f = mna >>= inject f, where inject is a method completely determined by the monad n
15:59:20 <kristof> ...I think it's fascinating :P
15:59:28 <hpc> > show (LeftBranch 40) -- a string result of such, which is then shown which adds quotes
15:59:29 <lambdabot>  "LeftBranch 40"
15:59:38 <Cooler> but show works on everything
15:59:41 <hpc> > length $ show (LeftBranch 40) -- it's a string
15:59:43 <lambdabot>  13
15:59:50 <hpc> show doesn't work on everything
15:59:58 <MarcelineVQ> kristof: the compiler gives unique names to variables that shadow each other in let and where, so you need to tell it you're not shadowing, which is what ScopedTypeVariables does, I think
16:00:02 <Shockk> Cooler: when you derive a show instance for something like 'data X = Number Int', you can think of the instance being something like this:  show (Number n) = "Number " ++ show n
16:00:20 <Gurkenglas> kristof, I vaguely think remembering also thinking that until I found a counterexample... keep up the effort :D! I'll try finding it again
16:00:53 <kristof> MarcelineVQ: geekosaur, is there a way to do this, then, if I just remove the type signature in the where clause?
16:01:15 <geekosaur> as for why it's not the default... well, people have been wondering and complaining about that for years. they're trying to reboot the standardization stuff, I think this is one of the things they most urgently want to have considered
16:01:47 <geekosaur> kristof, removing the type signature *might* work. if not, then again look at ScopedTypeVariables
16:01:50 <Cale> I don't believe that standardisation is the place to change defaults for anything
16:01:50 <Gurkenglas> kristof, I'm pretty sure if StateT's >>= has such a form, so will WriterT and ReaderT.
16:01:55 <kristof> Gurkenglas: I'm sure there *are* counterexamples, which is demonstrated precisely by the need for some method inject. My hope is that I can find some class (Monad m) => Embeddable m that is strong enough to allow for some newtype Compose m n that permits a monad instance in general
16:02:01 <MarcelineVQ> kristof: Is there a reason not to just use the extension? I only ask because I find once it works you can optomise from there.
16:02:26 <kristof> geekosaur: Well, the type signature was added becuase it didn't work... :)
16:02:30 <kristof> So scoped it is
16:02:30 <geekosaur> kristof, in the absence of ScopedTypeVariables there are things like
16:02:33 <geekosaur> :t asTypeOf
16:02:34 <lambdabot> a -> a -> a
16:02:43 <Cale> The Haskell Report should describe what contemporary Haskell is, rather than try to influence that.
16:02:56 <kristof> MarcelineVQ: Well, my type signature was causing the problem, so it just piqued my curiousity.
16:02:59 <Cale> If we want a different default, the right thing to do first is implement that. :)
16:03:20 <hpc> and prove it's better
16:03:36 <hpc> or at least worth the cost of restandardizing
16:04:14 <Cale> tbh, the standard is not very valuable right now beyond serving as an advanced tutorial
16:04:35 <kristof> geekosaur: Did not work.
16:04:45 <geekosaur> did you read the link I sent about it?
16:04:45 <hpc> it's ghc developer documentation, surely
16:04:51 <Cale> There don't seem to be enough resources to really support more than GHC at the moment.
16:04:51 <geekosaur> you need more than just the extension enabled
16:05:04 <geekosaur> you need to add "forall"s to indicate which variables to scope over the whole thing
16:05:13 <Cale> and other implementations of Haskell-ish languages deliberately make different decisions on lots of things
16:05:19 <geekosaur> Cale, I think that's a large part of why they're rebooting the standards committee
16:05:36 <geekosaur> there is a perception that the current setup is not serving the community
16:06:01 <hpc> Cale: if all we had was ghc and no standard, we'd be no better than perl!
16:06:08 <kristof> geekosaur: It worked! :o
16:06:31 <hpc> (i like perl, but they could do with some specs)
16:06:36 <Cale> It would be really nice to see a formal semantics for what exists in GHC though.
16:06:36 <Cooler> hpc show seems to work on anything
16:06:45 <hpc> > show id -- Cooler
16:06:46 <lambdabot>      No instance for (Typeable a0) arising from a use of ‘show’
16:06:46 <lambdabot>      In the expression: show id
16:06:47 <Cooler> @show thisisweird
16:06:47 <lambdabot> "thisisweird"
16:06:50 <Cale> It's been a long time since Haskell had a formal semantics
16:06:55 <hpc> Cooler: that's not show
16:07:05 <hpc> it's a lambdabot command that seems to do nothing
16:07:08 <ttt_fff> is there a way to hack haskell syntax so that "a[b]" expands into "a `getIndex` b" ?
16:07:11 <Shockk> @help show
16:07:12 <lambdabot> show <foo>. Print "<foo>"
16:07:20 <Shockk> ^
16:07:29 <Cooler> so how do you call the actual show?
16:07:32 <Shockk> you do 
16:07:36 <Shockk> > show thisisweird
16:07:37 <lambdabot>  Not in scope: ‘thisisweird’
16:07:44 <Cooler> oh ok
16:07:46 <Cale> ttt_fff: With a preprocessor you can do lots of stuff
16:08:05 <ttt_fff> Cale: with CPP2HS? or a custom preprocessor?
16:08:14 <Cooler> > show cool
16:08:16 <lambdabot>  "LeftBranch 40"
16:08:16 <Cale> ttt_fff: a[b] *also* means the function a applied to the one-element list whose sole element is b though
16:08:22 <Cale> custom
16:08:22 <geekosaur> custom preprocessor, like SHE
16:08:26 <Cooler> is it just me or is that show really slow?
16:08:29 <Cooler> > show cool
16:08:31 <lambdabot>  "LeftBranch 40"
16:08:35 <ttt_fff> ouch; right, okay, maybe this is a bd idea
16:08:48 <ttt_fff> geekosaur: https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/ ?
16:08:55 <kristof> geekosaur: So were you saying that some people want this to be the default?
16:09:15 <geekosaur> Cooler, you might want to experiment in a local ghci. can you tell the difference between show being slow and lambdabot being slow? or irc being slow? or the virtual host lambdabot is running on being slow?
16:09:41 <geekosaur> ttt_fff, that was what I was talking about, but as a representative of the type, not necessarily as something that does what you want
16:09:55 <geekosaur> kristof, yes
16:10:02 <ttt_fff> > a { b }
16:10:04 <lambdabot>      Illegal use of punning for field ‘b’
16:10:04 <lambdabot>      Use NamedFieldPuns to permit this
16:10:26 <ttt_fff> argh, so haskell already assigns meanings to "a(b)", "a{b}", "a[b]", "a<b>"
16:10:29 <geekosaur> ttt_fff, I think you'll find there isn't really a lot of spare syntax hanging around
16:10:33 <ttt_fff> what 'pairing operator' is left for me?
16:12:09 <Intolerable> ≤≥
16:12:34 <cmccann> geekosaur: imo the next revision of the haskell spec should be typeset in comic sans
16:13:28 <Shockk> comic lambds
16:15:14 <cmccann> ttt_fff: fun fact, if memory serves me most bracket-y or quote-y unicode characters are lexical errors in Haskell, since unicode classifies them as neither a symbol nor alphanumeric
16:15:28 <ttt_fff> hmm
16:15:39 <ttt_fff> looks like the entire haskell language was designed in such a way to prevent anyone from ever defining array notation
16:15:53 <ttt_fff> the devs were like "what choices can we do to amke sure anyone who tries to define array notation will get frustrated" ?
16:15:57 <ttt_fff> and they came up with haskell syntax
16:16:04 <cmccann> why do you want that notation?
16:16:32 <cmccann> it seems out of place in Haskell, even if you could implement it sanely
16:16:49 <geekosaur> it doesn't really compose well
16:17:44 <cmccann> though I admit it would be... fun... if you could declare circumfix operators
16:18:10 <ttt_fff> i'm building a dsl in haskell
16:18:20 <ttt_fff> and I'd like "haskell code" to be dsl code, instead of wriitng a parser in parsec
16:18:24 <cmccann> though I guess you might as well go full adga at that point and mixfix your way to madness
16:18:37 <ttt_fff> with parsec, the problem I have is: I don't know how to combine indentation-layout-parser with expresision-parser
16:18:46 <ttt_fff> if you know how to combine the two, I'd appreciate that
16:19:27 <nolrai66> Hmm.
16:19:51 <nolrai66> Have the expression parser consume input from the layout parser?
16:20:22 <ttt_fff> nolrai66: how do you tell https://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Expr.html to consume input from the layout parser?
16:20:26 <pacak> ttt_fff:  tokenize first and expression parse resulting stream?
16:20:31 <ttt_fff> and at point, isn't 'layout parser' really a 'layout lexer' ?
16:20:59 <ttt_fff> you know what? what does FAY use to parse it's mini haskell
16:22:36 <Cooler> i am getting this error
16:22:37 <Cooler>     Illegal type signature: ‘TestX’
16:22:37 <Cooler>       Perhaps you intended to use ScopedTypeVariables
16:22:37 <Cooler>     In a pattern type-signature
16:22:53 <pacak> Cooler: Code?
16:23:04 <KaneTW> remember to pastebin it
16:23:10 <Cooler> for the data TextX =  LeftBranch Int | RightBranch Int String
16:23:11 <Intolerable> lpaste please
16:23:15 <Intolerable> not pastebin
16:23:48 <Cooler> test1 :: TestX = LeftBranch 40
16:24:02 <dicioccio> 6
16:24:04 <cmccann> ttt_fff: judging from the dependency list, haskell-src-exts
16:24:05 <geekosaur> ttt_fff, I don't think that helps... it uses Language.Haskell.Exts.Annotated
16:24:11 <cmccann> ttt_fff: which probably doesn't help you at all
16:24:13 <Intolerable> put the signature and the definition on differnet lines
16:24:13 <geekosaur> Cooler: incorrect usage
16:24:22 <geekosaur> test1 :: TestX; test1 = ...
16:24:41 <geekosaur> otherwise, as the error says, it's using it as a pattern type signature which is illegal
16:24:52 <geekosaur> (or put them on separate lines)
16:25:27 <Cooler> geekosaur, but type signatures can't contain = can they?
16:25:50 <geekosaur> Cooler, correct, which is why it's parsing it as a pattern
16:26:01 <geekosaur> name patterns_go_here = ...
16:26:10 <geekosaur> and you have a type signature where a pattern is expected
16:27:02 <ttt_fff> (1) what is rhe relation between HAPPY and ALEX? (2) does HAPPY support indentation/layout parser? (I skimmed the HAPPY manual; found info on precdence, but nothing on layout)
16:27:13 <Cooler> shouldn
16:27:28 <Cooler> shouldn't the error be Illegal pattern then?
16:27:35 <geekosaur> ttt_fff, it's the same relationship as yacc/bison and lex/flex
16:27:43 <cmccann> ttt_fff: I'm assuming alex is for lexing, given the name
16:27:43 <ttt_fff> oh, so one is lexer, one is aprser?
16:27:48 <geekosaur> alex tokenizes, happy parses tokens
16:28:10 <cmccann> ttt_fff: btw, the elm compiler depends on parsec and it has haskell-y syntax
16:28:21 <geekosaur> Cooler, "In a pattern type-signature"
16:28:44 <geekosaur> the thing is, there is an extension that allows use of type signatures in patterns --- they do not do what you want here though
16:29:13 <Cooler> its mixing up patterns and type signatures?
16:29:17 <geekosaur> but the existence of that extension means it produces a different error message than the simple one you'd like
16:29:25 <geekosaur> no
16:29:29 <geekosaur> it thinks *you* are
16:29:46 <Cooler> what does pattern type signature even mean?
16:30:11 <geekosaur> a type signature in a pattern
16:30:20 <geekosaur> foo (a :: Int) = ...
16:30:27 <geekosaur> is the thing it expects with the extension
16:30:27 <kristof> is there an autoderivation of monoid for (Monoid a, Monoid b) => Writer a b ?
16:31:27 <geekosaur> "a" is the pattern there and the type signature is applied to it
16:32:02 <geekosaur> so it's complaining that it found a type signature in a pattern, but (a) nothing to apply it to (b) the extension necessary to use those is not enabled
16:33:08 <ttt_fff> okay
16:33:09 <Ongy> Hi, is there an 'exec' interface in haskell? all I can find is the System.Process which only provides 'fork + exec'
16:33:16 <ttt_fff> so from what I've read, in alex/happy parsing, ALEX handles alyout parsing
16:33:24 <ttt_fff> how does this work? can someone point me at docs to read
16:36:36 <kristof> No instance Monoid for WriterT Identity String [a]
16:36:57 <kristof> sigh
16:37:07 <c_wraith> I wouldn't really expect there to be.
16:37:24 <c_wraith> :t liftA2 (<>)
16:37:25 <lambdabot> (Applicative f, Monoid c) => f c -> f c -> f c
16:37:30 <Intolerable> really?
16:37:36 <c_wraith> That exists
16:38:20 <mac10688> Are a lot of haskell developers using nixOs? I've been hearing a lot about it lately
16:38:29 <kristof> Can't think of the simplest way to add two writers
16:38:44 <scshunt> kristof: what do you mean by "add"?
16:38:51 <kristof> scshunt: I mean mappend
16:38:52 <c_wraith> kristof: I can't think of what that would even mean
16:39:11 <kristof> scshunt: mappend the writable bits and then mappend they're parameterized over.
16:39:14 <c_wraith> kristof: what's wrong with liftA2 mappend?
16:39:24 <kristof> oh, would that work? Let me see
16:39:29 <Intolerable> nothing, but it should have a monoid instance
16:39:57 <Hafydd> Ongy: I don't believe there's a cross-platform one, probably because Windows does not in fact support exec() (althought it has a wrapper that spawns a subprocess then kills the calling process).
16:39:59 <c_wraith> Writer could probably have a legal monoid instance, but WriterT isn't so lucky
16:40:01 <Hafydd> *although
16:40:07 <c_wraith> and Writer isn't its own type anymore
16:40:15 <c_wraith> It's a type synonym for WriterT
16:40:22 <kristof> Aha!
16:40:36 <kristof> It works, thank you c_wraith
16:40:45 <Ongy> Hafydd: I don't need it corss platform, linux only is ok
16:40:56 <c_wraith> Hmm.  I guess WriterT *should* be able to have a legal instance too.  Well, file a change request. :)
16:41:00 <Ongy> I just wanted to do it the wrapper way, doesn't really hurt
16:41:01 <Intolerable> why can't WriterT have it?
16:41:36 <Intolerable> :t \x y -> mappend <$> x <*> y
16:41:37 <lambdabot> (Applicative f, Monoid b) => f b -> f b -> f b
16:42:01 <c_wraith> that's exactly the same as the liftA2 version
16:42:27 <dedgrant_> Type question! Let's say I'm using DataKinds, and I have some 'data T = A'. Why then does (['A,'A] :: [T]), but ['A] is a type error?
16:42:28 <Hafydd> Ongy: in which case, look at <https://downloads.haskell.org/~ghc/latest/docs/html/libraries/unix-2.7.1.0/System-Posix-Process.html#v:executeFile>.
16:42:45 <Intolerable> :t (\x y -> mappend <$> x <*> y) :: (Monad m, Monoid b) => WriterT m b -> WriterT m b -> WriterT m 
16:42:46 <lambdabot>     Expecting one more argument to ‘m’
16:42:46 <lambdabot>     The first argument of ‘WriterT’ should have kind ‘*’,
16:42:46 <lambdabot>       but ‘m’ has kind ‘* -> *’
16:42:52 <Intolerable> :t (\x y -> mappend <$> x <*> y) :: (Monad m, Monoid b) => WriterT m b -> WriterT m b -> WriterT m b
16:42:53 <lambdabot>     Expecting one more argument to ‘m’
16:42:53 <lambdabot>     The first argument of ‘WriterT’ should have kind ‘*’,
16:42:53 <lambdabot>       but ‘m’ has kind ‘* -> *’
16:43:19 <Intolerable> :t (\x y -> mappend <$> x <*> y) :: (Monad m, Monoid a, Monoid b) => WriterT a m b -> WriterT a m b -> WriterT a m b
16:43:20 <lambdabot> (Monad m, Monoid a, Monoid b) => WriterT a m b -> WriterT a m b -> WriterT a m b
16:43:34 <Intolerable> that's a valid mappend for WriterT
16:43:43 <Intolerable> mempty = pure mempty
16:43:57 <c_wraith> Intolerable: ok, but that was covered like 3 minutes ago
16:45:19 <c_wraith> dedgrant_: I suspect that it's not determining you mean the promoted [] type
16:45:43 <c_wraith> dedgrant_: it's rather conservative about when to promote things that are ambiguous.
16:46:31 <Ongy> Hafydd: thank you
16:47:08 <dedgrant_> c_wraith: Ah! Seeing if I can find any evidence for this, thanks.
16:48:47 <c_wraith> dedgrant_: (A ': '[]) works as a type.  There are probably better ways to write it, but I'm off now.
16:49:30 <dedgrant_> c_wraith: cheers, I'll see what I can find
16:50:11 <Cooler> is _ the wildcard character in haskell?
16:50:47 <cmccann> dedgrant_: try '[ 'A ]
16:51:12 <arw_> Cooler: placeholder for unbound parameters, yes.
16:52:24 <dedgrant_> cmccann: GHCi (7.10.2) reports parse error on the first '
16:52:39 <dedgrant_> cmccann: Maybe I'm missing a particular syntax extension?
16:53:44 <cmccann> dedgrant_: typing ":k '[ 'A ]" worked for me but that's as far as I tested it
16:53:48 <dedgrant_> cmccann: Nevermind ghc is very picky about spacing.
16:53:53 <cmccann> aha
16:53:57 <athan> I wonder if a NonEmpty Seq would be useful...
16:54:12 <dedgrant_> The space between '[ and 'A is vital :)
16:54:14 <dedgrant_> Thanks!
16:54:28 <cmccann> dedgrant_: '['A] looks like the Char literal '[' followed by A], I imagine
16:54:36 <athan> Cale: I think I found a winner (possibly)
16:54:45 <athan> lookup paths for tries
16:55:05 <dedgrant_> cmccann: Excellent thought.. didn't dawn on me
16:55:30 <cmccann> dedgrant_: that's because your internal parser has the -XDoWhatIMean enabled
16:55:35 <cmccann> that's not implemented in GHC yet
16:55:36 <athan> maybe
16:55:38 <athan> idk :|
16:56:33 <dedgrant_> cmccann: Haha tell me about it :)
17:03:51 <kristof> I have a typeclass that takes a kind * -> *
17:03:55 <kristof> what's wrong with this instance?
17:03:57 <kristof> instance Embeddable (WriterT w (IdentityT m))
17:06:26 <geekosaur> :t WriterT w (IdentityT m))
17:06:27 <lambdabot> parse error on input ‘)’
17:06:28 <geekosaur> 'er
17:06:32 <geekosaur> :k WriterT w (IdentityT m))
17:06:33 <lambdabot> parse error on input ‘)’
17:06:36 <geekosaur> :k WriterT w (IdentityT m)
17:06:38 <lambdabot> Not in scope: type variable ‘w’
17:06:38 <lambdabot>     Not in scope: type constructor or class ‘IdentityT’
17:06:38 <lambdabot>     Perhaps you meant ‘Identity’ (imported from Control.Monad.Identity)
17:06:57 <geekosaur> right, not gonna do that :/
17:08:02 <geekosaur> I don;t think I was headed in the right direction anyway...
17:08:06 <kristof> Got it!
17:08:14 <kristof> I just used Identity. Didn't work the first time.
17:08:41 <geekosaur> I'mnot sure what IdentityT would be anyway (actually, I know what it would be, but not *why*)
17:09:24 <cmccann> geekosaur: you could use it with monad transformer transformers to recover the original plain monad transformer!
17:11:10 <kristof> geekosaur: Well, I was trying to use Identity because I was trying to write an instance for Writer. And I got a weird error and thought "oh, maybe I need to use IdentityT". But Identity works.
17:18:31 <athan> Knuth tries seem legitly fast, dawgs
17:21:19 <Axman6> athan: what are they/got a link?
17:21:56 <athan> Axman6: Here you go :) http://htmlpreview.github.io/?https://github.com/athanclark/tries/blob/master/profile.html
17:22:21 <athan> Axman6: ListTrie is based off Data.Tree
17:22:34 <athan> ListTrie p a ~ Tree (p, Maybe a)
17:22:37 <Axman6> thanks =)
17:22:54 <athan> in that version, adjacency and depth are separated atomically (and hence why it takes so o
17:22:57 <athan> long*)
17:23:03 <athan> MapTrie is based off Data.Map
17:23:22 <athan> MapTrie p a ~ Map p (Maybe a, Maybe (MapTrie p a))
17:23:46 <athan> in that one, adjacency is taken at one step with Map, and depth later
17:23:56 <athan> then KnuthTrie is based off a B-Tree
17:24:08 <athan> KnuthTrie p a ~ BTree (p, Maybe a)
17:24:23 <athan> where Left means depth, and right is adjacency
17:24:24 <Axman6> is p the key?
17:24:31 <athan> yep :)
17:24:47 <Axman6> ok
17:25:10 * hackagebot tries 0.0.2 - Various trie implementations in Haskell  https://hackage.haskell.org/package/tries-0.0.2 (athanclark)
17:25:59 <athan> I'm actually really surprised, because Map even has Ord on its side
17:26:08 <athan> the lookup instance for KnuthTrie only uses Eq
17:26:58 <Axman6> so what does using a knuth trie get you? i mean it appears to be paft, but when would you use it?
17:29:04 <athan> Axman6: I think it's pretty bloated for space, not sure though
17:29:30 <athan> Axman6: That's why I made this library, to give people some options when making a nested lookup table :)
17:31:10 <Axman6> i made a ternary map package once, stuck it on hackage, and forgot about it. it later appeared in someone's academic paper, and proved to be quite fast compared to a lot of the other libraries being compared
17:31:24 <ttt_fff> Is there any tutorial on the internets on how to do indentatino sensnstive parsing with Alex/Happy ?
17:31:29 <cmccann> Axman6: that's hilarious
17:31:37 <ttt_fff> I can't find any such tutorial, there's just manuals + "go read the parser for haskell"
17:31:57 <Axman6> I never implemented delete for it, so that part of the benchmarks was missing =)
17:33:18 <athan> ttt_fff: Use parsec to tokenize it, then manually process the token streams :x
17:33:22 * athan ducks
17:33:36 <athan> Axman6: Ha! That's awesome :)
17:33:51 * ttt_fff throws gold bars at athan
17:34:09 <cmccann> Axman6: http://hackage.haskell.org/package/TernaryTrees I assume?
17:34:14 <Axman6> yep
17:35:02 * geekosaur has not used a generated lexer in many years
17:35:21 <geekosaur> stopped using lex after about 3 months, having realized I could hand write a lexer easily
17:35:48 <athan> ttt_fff: OW
17:36:39 <Axman6> cmccann, athan: this was the paper: http://research.microsoft.com/en-us/um/people/simonpj/papers/containers/containers.pdf
17:37:08 <geekosaur> generated lexers aren't really a win unless you need to squeeze them into absolutely minimal memory... which is what lex was designed to do. they're kinda wasted on something like haskell
17:38:16 <Axman6> ok, it did well in one benchmark anyway =D
17:38:59 <Axman6> (which was for lookups, which I'd argue it the thing you most often want to be fast in a k/v map)
17:40:01 <athan> Axman6: hmm, I'll see if I can integrate it :)
17:40:06 <Axman6> oh no shit, it also ended up in his PhD thesis
17:40:11 <Axman6> http://fox.ucw.cz/papers/thesis/thesis.pdf
17:40:58 <Axman6> I've been cited twice =) that's pretty funny
17:42:19 <Axman6> athan: there's a really good chance it won't compile any more
17:44:34 <athan> Axman6: You also don't even have delete implemented :(
17:45:08 <Axman6> yah
17:45:23 <athan> ain't even got a github repo :C
17:45:26 <Axman6> patches welcome, but probably ignored, not even sure where the code is
17:45:45 <Axman6> yeah I think it was on ... whatever that darcs hosting site was
17:46:14 <cmccann> the source is probably at "cabal unpack TernaryTrees"
17:46:20 <Axman6> yes
17:46:50 <geekosaur> hub.darcs.net currently; patch-tag and darcsden got merged with it iirtc
17:46:52 <geekosaur> *iirc
17:47:16 <athan> Okay cool, I'll get the polish
17:47:30 <Axman6> just found the source
17:51:12 <Axman6> the main thing I was playing with was an efficient binary serialisation of the trees. for word dictionaries it would usually reduce the size by half iirc
17:52:16 <ttt_fff> okay, so in alex/happy
17:52:22 <ttt_fff> it's alex's responsibility to output {} + ;'s
17:52:26 <ttt_fff> so that happy doesn't have to deal with it?
17:52:32 <Axman6> yep
17:52:34 <athan> Axman6: That sounds really interesting. I've had no experience with serialization in Haskell, except Show instances :P
17:53:55 <Axman6> athan: Binary does things in a pretty braindead way (one byte tag per constructor numbered 1-n). Since my trie often had lots of null trees, I encoded them using three bits in that byte. nothing more complex than that
17:54:55 <Axman6> hoping that one day dcoutts will release his CBOR based binary work =)
17:58:07 <flexfit> Does Haskell do tail recusion optimization automatically? Or is that something that I have to set when I compile?
17:58:31 <cmccann> flexfit: tail recursion isn't always what you want in Haskell
17:59:32 <athan> Axman6: Ahh wow, that's cool. Okay, I'll keep that in mind :)
17:59:34 <Axman6> to answer a slightly different question, iirc all calls in haskell turn into calls in tail position, because everything gets compiled to continuations
18:00:22 <athan> Axman6: Do you happen to have the darcs link? Or should it just be on darcshub?
18:01:23 <Axman6> i'll see if i can find it. I think it's still available at axman6.com
18:01:34 <cmccann> flexfit: what you do need to worry about is strictness vs. laziness. something that looks like it would be tail-call optimized but isn't strict enough can have horrible results
18:02:01 <athan> Axman6: I don't see anything "Ternary" in the public repos :(
18:02:14 <athan> awesome :)
18:02:20 <Cooler> when writing function to do operations on algebraic data atypes
18:02:26 <Axman6> http://axman6.com/darcs/TernaryTrees/
18:02:54 <Cooler> do you have to write expressions for each value the type can have?
18:03:37 <kadoban> Cooler: Sometimes?
18:03:40 <cmccann> flexfit: if you want to know more, look into the difference between foldr, foldl, and foldl'
18:03:47 <Cooler> for example if you define a type
18:03:48 <geekosaur> Cooler: depends on what you are doing, but if you are directly manipulating values of that type then yes
18:03:52 <Cooler> data Tree = Empty
18:03:53 <Cooler>           | Leaf Int
18:03:53 <Cooler>           | Node Tree Tree
18:04:07 <Cooler> and a function to find its depth
18:04:08 <Cooler> depth :: Tree -> Int
18:04:09 <Cooler>  depth Empty = 0
18:04:09 <Cooler>  depth (Leaf n) = 1
18:04:27 <Cooler> does that give an error
18:04:42 <Cooler> the depth function doesn
18:04:55 <Cooler> 't have a case for the 3rd value of node tree tree
18:06:30 <kadoban> Cooler: It's a warning, and very bad practice. It'll fail at run-time if you use it with a Node
18:06:35 <athan> Axman6: Sweet, thanks!
18:06:55 <flexfit> cmccann: I see. My professor was going on and on about how great tail recursion was, and how we should make everything tail recursive.
18:07:39 <cmccann> flexfit: I assume your professor was talking about some other functional language?
18:07:52 <Cooler> so it won
18:08:02 <geekosaur> that would be true for imperative languages in general, and maybe some non-lazy functional languages
18:08:04 <Cooler> so it won't show any errors during comile time?
18:08:17 <Cooler> compile*
18:08:21 <geekosaur> lazy languages evaluate by graph reduction; "tail recursion" is a somewhat dubious concept
18:08:27 <flexfit> cmccann: He doing Haskell on the computer while he was talking about it. He talked about how a lot of languages don't have tail recursion optimization.
18:08:30 <geekosaur> Cooler: warnings, unless you use -Werror
18:08:54 <cmccann> flexfit: imagine me side-eyeing your professor warily then
18:09:26 <kadoban> geekosaur: Is that strictly true? I thought tail recursion was still a well defined and useful concept, just not TCO ?
18:09:37 <geekosaur> flexfit, ghc does tail recursion optimization with its generated code. this is a low level implementation detail, though. at the level of Haskell code, it's somewhat dubious --- things you might think were amenable to tail recursion might not be, and vice versa
18:11:20 <flexfit> cmccann: Well, he did have the textbook open next to him as he was doing the lecture.
18:11:20 <cmccann> flexfit: in any case, something like map or foldr isn't and shouldn't be tail recursive in Haskell
18:11:20 <geekosaur> kadoban, in some contexts it is, in others not so much, is my understanding
18:11:20 <geekosaur> what
18:11:20 <broma0> anyone here familiar with the issue of left-recursion in recursive descent parsers? ....and a solution to the problem? http://lpaste.net/3336162597887016960
18:11:20 <geekosaur> 's fuzzy is not so much the concept as where it is appropriate
18:11:20 <ttt_fff> with parsec, is there a way to (1) convert String -> [Tokens], then a separate parse process for [Tokens] -> AST ?
18:11:23 <ttt_fff> instead currently, it appears that both parts are entrtwined in String -> AST
18:11:27 <geekosaur> ttt_fff, multiple parsers
18:11:46 <geekosaur> you can define one parser to produce the first and another to produce the second, and chain them together
18:12:14 <cmccann> flexfit: the idea with map &c. is that the recursion happens inside the returned data constructor, so the result can be processed lazily without forcing the entire thing
18:12:28 <cmccann> flexfit: which is what allows those functions to operate on infinite lists
18:14:36 <flexfit> cmccann: So is it possible to replace general recursion with maps and folds?
18:14:53 <Stratege_> map can be implemented with fold as well.
18:15:10 <srhb> General no, a lot of it, yes.
18:15:16 <cmccann> flexfit: well, any list functions can be implemented in terms of foldr, but that's not terribly interesting
18:15:35 <cmccann> recursion in general probably not
18:15:55 <flexfit> I see. Maps and Folds are new and exciting for me.
18:16:01 <srhb> :)
18:16:02 <tjpeden> Okay, so I'm getting these two errors and they are a bit over my head: https://gist.github.com/tpeden/fe26871675ae03b7e0b3
18:16:03 <flexfit> It's a different way of thinking for sure
18:17:08 <cmccann> > foldl (+) 0 [1..1000000] -- flexfit: this is what you get with a "tail recursive" function and no TCO btw
18:17:10 <lambdabot>  *Exception: stack overflow
18:17:26 <cmccann> > foldl' (+) 0 [1..1000000] -- but this works
18:17:28 <lambdabot>  500000500000
18:17:46 <srhb> flexfit: Does it help if you remove the needless qualifiers?
18:17:53 <geekosaur> tjpeden, I think I got a bit too clever there
18:18:14 <tjpeden> It happens to me all the time lol
18:18:20 <srhb> Woops, I meant tjpeden 
18:18:59 <tjpeden> srhb: not sure what you mean
18:19:30 <geekosaur> :t \text = ?updateFirstLine (lines text) >>= return . unlines
18:19:31 <srhb> tjpeden: Expected type String -> IO String; actual type String -> String; in expression ...
18:19:31 <lambdabot> parse error on input ‘=’
18:19:39 <geekosaur> :t \text -> ?updateFirstLine (lines text) >>= return . unlines
18:19:40 <lambdabot> (Monad m, ?updateFirstLine::[String] -> m [String]) => String -> m String
18:20:16 <srhb> tjpeden: You said it's over your head. If you condense it a bit, it's not that bad -- it might help :)
18:20:26 <srhb> I don't even know why you're getting those qualifiers, but they sure are noisy.
18:20:37 <geekosaur> also, man, the FTP implementation made error messages hideous
18:20:41 <geekosaur> all those qualified names
18:20:44 <srhb> Indeed.
18:21:08 <tjpeden> srhb: I'm getting those from Atom's Haskell IDE plugin
18:21:10 <geekosaur> basically this is a side effect of Data.OldList as backward compatibility hack for the FTP
18:21:14 <srhb> Yeah.
18:21:40 <srhb> tjpeden: Anyway, you can more or less safely ignore the qualifiers and focus on the essence. :)
18:22:06 <geekosaur> srhb, the other haldf of it is this is code I gave tjpeden, written quickly and not tested
18:22:16 <srhb> oh, okay.
18:22:19 * srhb butts out
18:22:49 <geekosaur> so anyway, replace line 12 with:  commitMsg text = updateFirstLine (lines text) >>= return . unlines
18:24:11 <geekosaur> which can be written better with an fmap but that was the starting point I tried to get too clever with >.>
18:24:41 <geekosaur> hmmm
18:25:02 <geekosaur> :t fmap unlines . ?updateFirstLine . lines
18:25:03 <lambdabot> (Functor f, ?updateFirstLine::[String] -> f [String]) => String -> f String
18:25:12 <geekosaur> that works too
18:25:33 <geekosaur> (leave out the question mark, that was a hack so I didn;'t have to define updateFirstLine to it)
18:35:14 * hackagebot userid 0.1.1.0 - A library which provides the UserId type and useful instances for web development  https://hackage.haskell.org/package/userid-0.1.1.0 (JeremyShaw)
18:40:13 <flexfit> Does this count as elimatinating tail recursion?
18:40:13 <flexfit> http://pastebin.com/7uwz7Cj4
18:40:14 * hackagebot pred-trie 0.3.0 - Predicative tries  https://hackage.haskell.org/package/pred-trie-0.3.0 (athanclark)
18:40:42 * athan laughs maniacally
18:43:42 <broma0> how can I eliminate the left recursion in this very simple grammar/parser example? http://lpaste.net/3336162597887016960
18:44:07 <cmccann> flexfit: looks tail recursive to me
18:44:21 <broma0> I keep seeing things on the internet about fixing some S -> S a | B by chaing it to S -> B | S' but Im not sure how to apply it
18:44:48 <cmccann> flexfit: though depending on how clever GHC decides to be, that might blow up with a stack overflow
18:45:14 * hackagebot stripe-haskell 0.1.4.2 - Stripe API for Haskell  https://hackage.haskell.org/package/stripe-haskell-0.1.4.2 (DavidJohnson)
18:46:00 <cmccann> flexfit: since what you've got is basically foldl I think
18:46:01 <Axman6> flexfit: that's explicitly tail recursive - average_iter calls itself as the last thing it does
19:01:38 <Gurkenglas> :t \t f g -> [fmap (t f) . t g, getCompose . t (Compose . fmap f . g)]
19:01:39 <lambdabot>     Occurs check: cannot construct the infinite type: f ~ Compose f f
19:01:39 <lambdabot>     Expected type: a -> Compose f f a
19:01:39 <lambdabot>       Actual type: a -> f a
19:01:42 <pqmodn> is there something like cabal sandbox add-source, but without the sandbox? alternatively, has anyone used hvr's multi-ghc-travis but made it work with sandboxes?
19:02:24 <Gurkenglas> Apparently t was deduced to have a too specific type signature. Can I make ghci deduce as general as possible type signatures?
19:03:09 <glguy> No. If you want an infinite type you have to break the recursion with a new type
19:03:39 <glguy> 03newtype Fix f 07= MkFix (f (Fix f)) 11--11 for example
19:03:59 <Axman6> oh yeah, I need to try out your IRC client some time =)
19:04:54 <Axman6> glguy: does irc-core support multiple networks?
19:05:06 <Xe> irc-core?
19:05:34 <Axman6> https://github.com/glguy/irc-core
19:06:02 <glguy> Axman6: No, I started massaging things toward that but I never need it so it hasn't  been a priority
19:06:54 <Axman6> fair enough. I guess you could just run different instances inside tmux windows anyway
19:07:08 <glguy> http://imgur.com/fTTp3cC
19:11:03 <Hafydd> glguy: did you really make an IRC client plugin to highlight code?
19:11:27 <Axman6> he made an irc client =)
19:11:28 <flexfit> Axman6: Wait, am I understanding tail recursion correctly. It's tail recursive if it doesn't do any action except call itself as the last action?
19:11:41 <glguy> No, I made an IRC client and it can highlight Haskell code :)
19:11:49 <Axman6> it's tail recursive if the last thing it calls is itself
19:11:50 <Hafydd> Okay.
19:12:27 <Hafydd> It looks like it would be quite unreadable against a white background.
19:12:48 <cmccann> flexfit: it's tail recursive if the only recursive calls are the last thing it does in that code path
19:14:02 <flexfit> cmccann: So in that case, Haskell would be able to reuse the AR?
19:14:07 <glguy> Hafydd: Well, people who pick mIRC colors that don't work on white won't be able to see it very well
19:14:42 <cmccann> flexfit: "AR"?
19:14:50 <Hafydd> glguy: do you really think the onus is on other people to change their colours just so your highlighting works?
19:15:06 <glguy> Yeah. There are only a few of these standardized color codes
19:15:15 * hackagebot diagrams-lib 1.3.0.5 - Embedded domain-specific language for declarative graphics  https://hackage.haskell.org/package/diagrams-lib-1.3.0.5 (BrentYorgey)
19:15:28 <Hafydd> But if they do that, it will break all sorts of other things that (more sensibly, perhaps) use background colours.
19:16:11 <glguy> can't help everyone
19:16:14 <Hafydd> Of course, the most sensible course of action is to just write in plain text, so the IRC channel doesn't look like someone vomited skittles all over it.
19:16:19 <glguy> It hasn't generally been a problem
19:16:27 <glguy> andpeople who don't want to see colors can turn them off in their clients
19:17:22 <flexfit> cmccann: According to my notes. If I implement a function tail recusively, Haskell can reuse the Activation Record
19:18:55 <cmccann> to be pedantic, I'm pretty sure Haskell doesn't know anything about activation records. GHC might, though. :P
19:19:33 <flexfit> er the GHC can reuse the activation record.
19:20:19 <cmccann> anyway I don't know the details of how GHC implements this stuff
19:20:47 <geekosaur> I don't think it has activation records as such
19:21:15 <cmccann> but I'm pretty sure it'll only work the way you want if things are strict enough, e.g. foldl and stack overflows
19:21:33 <geekosaur> the STG is about graph reduction; the stack is a pattern match stack, and if you treat those as "activations" then you'd need to track strictness *very* carefully to reuse them
19:22:00 <geekosaur> er, to produce a situation where they might be reusable
19:24:04 <flexfit> Dang. I wish my professor had not spent so much time on tail recursion then. Ah well.
19:26:07 <cmccann> it's an important concept in pretty much every functional language that's not haskell or based on haskell
19:26:20 <cmccann> so it's hardly a waste of time, I'd think
19:26:37 <geekosaur> right, but it was apparently raised in the context of haskell in the first place
19:27:37 <cmccann> perhaps a case of someone adapting course material based on another language to haskell, idk
19:28:24 <chasm> beginner question... does this code (http://lpaste.net/141279) require any annotations to make sure that the ByteString read from the file does not leak?
19:28:32 <cmccann> hm, something seems fishy about the header text here.... https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html#g:2
19:29:35 <geekosaur> chasm, in fact since it's lazy I/O the file has not been read at that point
19:29:49 <geekosaur> you would need to force the whole tree
19:29:57 <chasm> I think the ByteString.readFile is strict?
19:30:16 * hackagebot diagrams-graphviz 1.3.0.0 - Graph layout and drawing with GrahpViz and diagrams  https://hackage.haskell.org/package/diagrams-graphviz-1.3.0.0 (BrentYorgey)
19:31:08 <geekosaur> oh, strict ByteString, I guess it would have to be
19:31:29 <geekosaur> still not sure it's fully evaluated at that point though
19:32:08 <chasm> what I would want to be sure of is, whenever the readFile takes place, that all the other processing of the ByteString happens as well, so I don't have a huge ByteString hanging around... my theory is that Data.Set would require all the internal thunks to fire, but I don't know
19:32:50 <chasm> (because I think all the keys for the Set have to be evaluated)
19:33:41 <geekosaur> I think what you get is that it is either in the state of being a single ByteString or it is the Set
19:34:18 <geekosaur> what is not clear is whether the latter has happened yet. but there should not be a point where the ByteString cannot be gc-ed but the Set is populated
19:34:31 <geekosaur> (I think)
19:35:39 <flexfit> I'm a little confused about how to do recursion with tuples. I understand how to do recursion with list with the x:xs
19:35:51 <geekosaur> you can't, really
19:35:56 <chasm> ty it is confusing to reason about... whether requiring the readFile also requires the Set
19:36:00 <geekosaur> a tuple is not like a list, it is not a recursive structure
19:36:07 <geekosaur> nor an iterable structure
19:36:48 <geekosaur> chasm, exactly, it's difficult to reason about. but I would guess that, because nothing has yet been demanded from the Set, the ByteString hasn;t actually been read yet!
19:36:56 <flexfit> So the unzip doesn't really work recursively?
19:37:21 <geekosaur> :t unzip
19:37:22 <lambdabot> [(a, b)] -> ([a], [b])
19:37:33 <geekosaur> it recurses on the list part, not the tuple part
19:37:33 <flexfit> :t unzip3
19:37:34 <lambdabot> [(a, b, c)] -> ([a], [b], [c])
19:38:21 <geekosaur> there is no unzipN that can work on an arbitrary tuple, and the only way to write one uses typeclasses for which an instance would need to be written for each tuple size
19:38:24 <amicuscuriae> how are you people
19:38:26 <flexfit> So if I do something like x:xs, then x would represent the first tuple in the list then?
19:38:33 <geekosaur> flexfit, yes
19:38:35 <amicuscuriae> Do you recommend any book for a complete noob?
19:38:38 <flexfit> amicuscuriae: Marvelous. Thanks for asking.
19:38:48 <geekosaur> or (a,b):xs which extracts the elements from the tuple
19:38:52 <flexfit> amicuscuriae: I liked LearnYouAHaskell
19:39:48 <cmccann> chasm: every key added to a non-empty Set has to be compared to at least one other key, and the final result must have done at least one comparison against the final key that was added, so I can't see how it wouldn't be all-or-nothing in forcing the input
19:39:50 <Cale> amicuscuriae: If you're looking for a physical book, Graham Hutton's book is good
19:40:02 <geekosaur> flexfit, see the list of instances here http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/haskell2010-1.1.1.0/Prelude.html#t:Eq
19:40:17 <geekosaur> note that the end is a bunch of explicit instances for various tuple sizes
19:40:36 <barrucadu> amicuscuriae: There's also a list of resources here: https://github.com/bitemyapp/learnhaskell
19:40:51 <geekosaur> if you could unpack a tuple recursively, they would do so, not do that
19:41:04 <flexfit> What does ~ mean in the context of a fold?
19:41:22 <cmccann> chasm: also, getting the size of the final Set and forcing that should logically force the entire input since the size depends on how many duplicate keys there were.
19:41:29 <geekosaur> ?? I'd have to see the exact context
19:41:29 <lambdabot>  I'd have to see the exact context
19:41:36 <geekosaur> ... thanks lb
19:41:55 <cmccann> flexfit: if you're looking at unzip, it's probably an irrefutable pattern
19:42:05 <geekosaur> ~ in a type signature is type equality; ~ in a pattern means that the pattern is lazy instead of strict
19:42:07 <flexfit> http://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.List.html#unzip3
19:42:23 <geekosaur> (normally pattern matching is strict, and that is in fact how you cause evaluation to happen)
19:42:32 <cmccann> yep, that's so the unzipped lists can be as lazy as they should be
19:42:47 <geekosaur> yep
19:46:25 <amicuscuriae> Cale, ok Introduction book?? it is too old
19:46:28 <chasm> cmcann: thanks!
19:46:38 <amicuscuriae> flexfit, Link?
19:46:42 <chasm> cmccann: thanks!
19:46:46 <Cale> amicuscuriae: Pretty much everything it covers is still relevant
19:47:09 <flexfit> amicuscuriae: http://learnyouahaskell.com/introduction#about-this-tutorial . It even has pictures!
19:47:11 <amicuscuriae> ok
19:50:36 <cmccann> chasm: reasoning about the strictness of an expression need not be any more confusing that the expression itself. if an output value "x" would give you--even indirectly--some information about an input value "y", then forcing "x" will force enough of "y" to determine that information
19:50:50 <amicuscuriae> flexfit, but it says it is not intended for absolute beginners
19:52:21 <cmccann> chasm: for example, taking the length of a list has to force all the list constructors, since it needs to know how many of them there are. but it won't force the elements of the list because they don't have anything to do with the length.
19:53:12 <Fr4n> how would you guys write this? \xs -> map reverse $ scanl (flip (:)) [] xs
19:53:55 <cmccann> Fr4n: "inits"
19:54:00 <cmccann> :]
19:54:01 <Fr4n> derp
19:55:06 <cmccann> that reminds me, didn't someone at some point have a tool that would let you search for functions based on input/output pairs? or was that only something discussed hypothetically?
19:56:42 <dmj`> aeson has a *massive* breaking change in 0.10
19:56:49 <Axman6> yeah?
19:57:43 <dmj`> -- 0.9
19:57:44 <dmj`> λ: newtype A = A { val :: Maybe String } deriving (ToJSON, Show)
19:57:44 <dmj`> (0.01 secs, 3,077,712 bytes)
19:57:44 <dmj`> λ: instance FromJSON A where parseJSON (Object o) = A <$> o .:? "val"
19:57:47 <dmj`> (0.00 secs, 1,032,488 bytes)
19:57:51 <dmj`> λ: eitherDecode "{ \"val\" : null }" :: Either String A
19:57:54 <dmj`> Right (A {val = Nothing})
19:57:55 <dmj`> (0.00 secs, 1,552,616 bytes)
19:57:58 <dmj`> -- 0.10
19:58:01 <dmj`> λ> newtype A = A { val :: Maybe String } deriving Show                                                                                                                            
19:58:06 <dmj`> (0.01 secs, 3,086,560 bytes)                                                                                                                                                      
19:58:09 <dmj`> λ>  instance FromJSON A where parseJSON (Object o) = A <$> o .:? "val"                                                                                                                                                                                                                                                                       
19:58:12 <dmj`> (0.01 secs, 2,069,808 bytes)                                                                                                                                                      
19:58:13 <glguy> dmj`: A pastebin is better for this much 
19:58:15 <dmj`> λ> eitherDecode "{ \"val\" : null }" :: Either String A                                                                                                                           
19:58:18 <dmj`> Left "Error in $.val: failed to parse field val: expected String, encountered Null"                                                                                               
19:58:20 --- mode: ChanServ set +o glguy
19:58:20 --- kick: dmj` was kicked by glguy (dmj`)
19:59:52 <glguy> I'm guessing dmj` didn't actually mean to paste so much
20:00:39 <amicuscuriae> there are a lot of good introductory books
20:01:56 <amicuscuriae> haskell's syntax is too scary
20:02:01 <amicuscuriae> Which editor do you recommend?
20:02:21 <Axman6> I just use sublime text
20:02:33 <echo-area> Is there a pdf version of the yesod book?  I didn't find one.  I want to read it on my kindle
20:02:52 <echo-area> (There is a pdf one but it's too old)
20:03:10 <echo-area> I mean the most recent version of the book
20:03:36 --- mode: glguy set -o glguy
20:04:38 <echo-area> amicuscuriae: I use Emacs
20:05:29 <rdz_> I'm trying to create a 2D matrix that's symmetrical across a diagonal, i.e: arr ! (x,y) == arr ! (y,x) && arr ! (x,x) == 1
20:05:36 <naudiz> echo-area: I feel sorry for you.
20:05:46 <rdz_> I was thinking about using Array (Int,Int) Double but wasn't sure about the best way to construct it
20:06:00 <echo-area> naudiz: For what?
20:06:33 <naudiz> rdz_: I've done that before and Array created lots of overhead
20:06:55 <naudiz> rdz_: people kept recommending Vector instead
20:07:04 <rdz_> can vector do 2D arrays?
20:07:05 <naudiz> echo-area: Because of emacs.
20:07:19 <rdz_> I'm finding 2 dimensional stuff with Vectors to be a bit of a pain (Vector (Vector a))
20:07:28 <pqmodn> dmj`: is this related to https://github.com/bos/aeson/commit/d0414be92ee6bf5b4c057978955b89d111767dab ?
20:07:44 <naudiz> rdz_: I'm not sure, I didn't change my implementation because I was mostly done at that point.
20:08:18 <emmanuel_erc> rdz_: You should consider using HMatrix.
20:08:26 <echo-area> naudiz: Oh well.  That is not necessary :)
20:08:40 <naudiz> rdz_: you could use a 1d vector and arrange the elements in a predictable way
20:08:51 <rdz_> emmanuel_erc: I would give it a try but having trouble installing it on Windows
20:09:17 <emmanuel_erc> Are you using cygwin?
20:09:21 <rdz_> yes
20:09:50 <emmanuel_erc> FWIW, I have tried installing hmatrix on Arch and Ubuntu. I have had the best luck with Ubuntu.
20:10:18 <emmanuel_erc> Also, the alberto ruiz recently just released hmatrix 17.0.1 if I  recall correctly.
20:10:18 * hackagebot nationstates 0.4.0.0 - NationStates API client  https://hackage.haskell.org/package/nationstates-0.4.0.0 (ChrisWong)
20:10:35 <rdz_> I do have a linux VM I use when things get particularly annoying with Windows, but prefer my dev in Windows if I can
20:10:41 <rdz_> I can always give that a try
20:10:45 <geekosaur> glguy, fwiw I usually immediately invite someone right back in after that kind of kick, so they know it's not a matter of not wanting them around
20:10:45 <rdz_> oh, is there a new version?
20:10:59 <emmanuel_erc> Yeah
20:11:00 <cmccann> rdz_: just use a (Vector a) and then use the Ix class (which is what Array itself uses) to convert your (Int, Int) indices to Int offsets
20:11:53 <emmanuel_erc> cmccann: Is there any significant difference between Arrays and Vectors?
20:12:29 <naudiz> rdz_: what cmccann said is pretty much what I'd suggest as well
20:12:31 <cmccann> um... everyone loves Vector whereas Array sits alone in the corner and cries itself to sleep at night?
20:12:34 <emmanuel_erc> rdz_: Herer's the link: http://dis.um.es/%7Ealberto/hmatrix/hmatrix.html
20:12:35 <geekosaur> Array is older and in many ways less flexible
20:13:06 <naudiz> I've had big thunk problems with array
20:13:20 <geekosaur> Vector got to take advantage of many years of experience and development that Array didn't
20:13:21 <cmccann> I think the vector package as a whole is better than Array in pretty much every way
20:13:27 <emmanuel_erc> I see, I am still fairly new to Haskell and I've been using Vector so far.
20:13:34 <cmccann> but there might be a few extra hoops to jump through and more choices to make
20:13:43 <geekosaur> so I think at this point Array hangs around just because it is old and was used a lot before Vector was written
20:14:43 <amicuscuriae> How do you compare this with rust?
20:15:29 <naudiz> I really wish I had known Vector before.
20:15:34 <geekosaur> I think Rust compares more directly to SML, since it's a strict language
20:15:52 <naudiz> But it was just a bachelor thesis, so it doesn't really matter.
20:16:00 <geekosaur> (it looks in many ways like SML with C/Algol family syntax)
20:16:05 <rdz_> I'm a bit confused about how to use the Ix class to convert (Int,Int) to an Int offset
20:16:10 <emmanuel_erc> Would you guys consider it a bit misguided to think that Haskell can be useful/productive for people in the sciences?
20:16:11 <rdz_> anyone have an example to reference?
20:16:31 <cmccann> rdz_: well, the source code for Array is one option, heh
20:16:32 <bjz> geekosaur: it's ad-hoc polymorphism is like Haskell though
20:16:43 <Axman6> emmanuel_erc: not at all
20:17:16 <naudiz> rdz_: you could arrange a symmetrical matrix ((a,b),(b,c)) as a vector like (a,c,b)
20:17:17 <cmccann> rdz_: but mostly you just want the "index" function. you give it a range and an index in that range and it spits out an Int
20:17:40 <bjz> geekosaur: but yes, it was bootstrapped from ocaml, and shares lots of that heritage
20:17:46 <Axman6> in fact, there's now a really nice (looking, I haven't used it) package for calling R from Haskell, with zero or minimal marshalling
20:17:53 <cmccann> > index ((0,0), (9,9)) (1,5) -- rdz_ 
20:17:55 <lambdabot>  15
20:17:58 <amicuscuriae> What is a functional programming language?
20:18:10 <naudiz> Axman6: do you even need R anymore?
20:18:38 <amicuscuriae> I really like complied languages
20:18:47 <emmanuel_erc> rdz_: If you take a look at the Numeric.LinearAlgebra.Static, there are some really nice functions!
20:18:57 <amicuscuriae> Do we have to worry about memory management in Haskell?
20:19:02 <Axman6> amicuscuriae: haskell is a compiled language
20:19:04 <naudiz> amicuscuriae: https://en.wikipedia.org/wiki/Functional_programming 
20:19:19 <Axman6> amicuscuriae: like all languages, yes, you do
20:19:21 <cmccann> rdz_: that said, if you want to play with matrices you're better off using a library for that, rather than rolling your own
20:19:30 <emmanuel_erc> Axman6: In my graduate program, Matlab (predominantly) and python are the most used languages.
20:19:36 <amicuscuriae> Axman6, but some of them are garbage collected
20:19:42 <Axman6> you don't need to do your own memory management in haskell, but you'll write bad code if you don't think about it
20:19:42 <amicuscuriae> you don't really have to work about it
20:19:45 <naudiz> amicuscuriae: most of the time, you don't. But the larger your program becomes, the more you need to care about memory.
20:19:45 <rdz_> I see how it's done here: https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Arr.html#line-280
20:19:50 <emmanuel_erc> I told some colleagues about my recent transition and they gave me the stink eye.
20:20:05 <rdz_> I guess I could create an alternative to `!` that calls index and do that
20:20:15 <julianleviston> amicuscuriae: Haskell is garbage collected. He was being very literal. People in here tend to be.
20:20:30 <amicuscuriae> ok
20:20:41 <Axman6> naudiz: R has excellent libraries for many statistical domains which don't exist in other languages, so sure, it still has a place
20:20:44 <amicuscuriae> how do we assign a variable? Do we need headers?
20:20:52 <amicuscuriae> I would go thru official intro guide
20:21:06 <naudiz> amicuscuriae: that's not true... in some languages you can't care about memory, which makes them terrible, but in haskell you actually can.
20:21:16 <rdz_> my only other issue with HMatrix is that it is so huge with (imho) poorly named functions/operators, so when I have looked through it I can never find the thing for what I want to do
20:21:21 <julianleviston> amicuscuriae: it’s a VERY different language to anything you’ll have seen before.
20:21:48 <naudiz> Axman6: couldn't you just implement those things in Haskell?
20:22:08 <Axman6> naudiz: of course, but they haven't been. you make doing that sound trivial
20:22:08 <emmanuel_erc> rdz_: Admittedly, before 17.0.1, some of the operators were poorly named. I think Ruiz has changed it now to make it more sensible.
20:22:37 <julianleviston> amicuscuriae: are you coming from C/C++?
20:22:48 <naudiz> Axman6: I haven't used R myself, yet, so I don't really know how complicated this stuff is.
20:23:09 <Axman6> it can be very complicated
20:23:17 <rdz_> emmanuel_erc: it's just one of those libraries where I can't seem to work out what's happening based purely on the types, are there any tutorials/guides on how to use it?
20:24:14 <rdz_> I have looked at http://dis.um.es/~alberto/hmatrix/hmatrix.html but it's like looking for a needle in a haystack
20:24:25 <rdz_> or more precisely I have no idea where to begin
20:24:32 <emmanuel_erc> I had a hard time getting through the library at first, but I read the pdf he has on the website (I can point you towards it). There also tutorials from previous versions.
20:24:58 <rdz_> compared to say using NumPy or Pandas where, while I dislike Python, there were a plethora of resources to get started
20:25:22 <emmanuel_erc> rdz_: Here is the link to the pdf : http://dis.um.es/~alberto/material/hmatrix.pdf#section.3
20:25:36 <rdz_> excellent, thanks I'll take a look :)
20:26:18 <emmanuel_erc> Some of the operators in the pdf are not in the newest version, but I did not have a hard adjusting to the new syntax once I read enough of the pdf.
20:26:29 <rdz_> emmanuel_erc: link didn't seem to work for me - perhaps it's down?
20:26:40 <emmanuel_erc> I can post the pdf on dropbox if you like.
20:27:37 * geekosaur is having trouble loading some things right now, for what it's worth --- may be an outage somewhere
20:29:16 <emmanuel_erc> rdz_: https://www.dropbox.com/s/yl53hklqm4oapg4/hmatrix.pdf?dl=0
20:29:30 <rdz_> emmanuel_erc: oh hey, that's awesome! thanks :)
20:29:49 <emmanuel_erc> Tell me what you think of the documentation.
20:30:20 <rdz_> emmanuel_erc: argh, still can't install on Windows, even with 0.17.0.1
20:30:39 <emmanuel_erc> wow....
20:30:48 <emmanuel_erc> I am surprised to hear that.
20:30:50 <rdz_> will save testing it for another time when I can be bothered to fire up VM
20:31:53 <rdz_> emmanuel_erc: can't tell if sarcasm! but there are plenty of Haskell related things that suck on Windows
20:32:05 <rdz_> hence the VM for when I get frustrated enough
20:32:55 <rdz_> though I will admit, getting NumPy working on Windows was as painful (except that there are solutions)
20:32:57 <emmanuel_erc> It wasn't sarcasm. But it's a good I know that now.
20:33:47 <emmanuel_erc> For a brief moment in time, I consider using Python. Before that I was using Matlab for most of my work but eventually decided to ditch it because I didn't want to deal with licensing.
20:33:57 <emmanuel_erc> considered*
20:34:30 <rdz_> I am learning a bit of Data Analytics/Data Science right now and everything is either in Python or R
20:34:45 <rdz_> I started with Python but got pretty sick of the lack of types
20:34:57 <rdz_> I missed being able to work out what was going on with :t
20:35:15 <rdz_> so decided to see if I could implement the lessons in Haskell instead
20:35:16 <geekosaur> yeh, I know someone who has to work in matlab because everyuone in his field uses and knows only matlab --- and desperately wants to use something else
20:35:22 <rdz_> though with the new R bindings I think I might give that a try soon
20:35:36 <emmanuel_erc> I might consider that too.
20:35:48 <rdz_> I've never tried Matlab but it seems to get a lot of hate... why's it so bad? Just licensing?
20:36:01 <geekosaur> it's terribly idiosyncratic
20:36:05 <emmanuel_erc> I am wanted to try Haskell because of the sheer number of abstractions within the language and their connection to mathematics.
20:36:09 <emmanuel_erc> connections*
20:36:37 <emmanuel_erc> So at my school, there aren't enough licenses to give to everyone.
20:36:42 <rdz_> geekosaur: yes but people say that about Haskell too
20:36:46 <naudiz> rdz_: sagemath is okay for small things, but for whole projects it's terrible.
20:36:56 <geekosaur> one example: http://swaldman.dreamwidth.org/345215.html
20:37:03 <emmanuel_erc> So sometimes your matlab code won't run because of someone else. 
20:37:16 <julianleviston> I’m confused
20:37:25 <julianleviston> why is -5 `div` 2 == -2
20:37:34 <julianleviston> but (-5) `div` 2 == -3
20:37:37 <geekosaur> haskell is different from what many people expect languages to look or behave like, but it is self-consistent
20:37:56 <geekosaur> I just linked to an example of matlab being inconsistent *with itself*
20:38:02 <scshunt> > -(5 `div` 2)
20:38:03 <lambdabot>  -2
20:38:07 <scshunt> there's your answer
20:38:23 <julianleviston> oh is it rounding?
20:38:28 <geekosaur> julianleviston, handling of prefix (-) is a known pain point. every language has its own solutions to it
20:38:36 <scshunt> julianleviston: just operator precedence
20:38:39 <DoYouKnow> emmanuel_erc: do you think it's an elegant language so far?
20:38:59 <julianleviston> geekosaur: yeah, I know the - opertor thing.
20:39:05 <naudiz> geekosaur: many lanuages are. Especially those with weak typing.
20:39:07 <julianleviston> I was just wondering why one was 3 the other 2.
20:39:11 <geekosaur> in the case of haskell, the usual tricks to try to make unary (-) sane conflict with operator sections and some other things
20:39:14 <julianleviston> I’m missing something really obvious aren’t I?
20:39:21 <emmanuel_erc> It is wonderful. I love that the compiler complains and forces me to think carefully about what I write.
20:39:48 <geekosaur> julianleviston, it truncates downward IIRC
20:39:55 <julianleviston> geekosaur: right.
20:40:00 <geekosaur> so 2.5 becomes 2 but -2.5 becomes -3
20:40:01 <scshunt> julianleviston: 2 is the least integer x such that x * 2 <= 5
20:40:02 <julianleviston> geekosaur: thanks!
20:40:02 <rdz_> rolling out my own Ix class seems like too much of a pain for such a small project, I think I might just stick with Arrays and just do an inefficient implementation
20:40:10 <rdz_> thanks for the discussion though everyone
20:40:21 <rdz_> I think HMatrix is definitely something I have to learn
20:40:21 <julianleviston> scshunt: I assumed rounding toward 0… thanks
20:40:21 <scshunt> err, greatest
20:40:29 <exio4> rdz_: you might want to look at vector, btw 
20:40:32 <emmanuel_erc> Yes, it very elegant DoYouKnow. Whenever, I write code in Haskell, it may take some time to work out all the details, but is usually very terse and  easy to read once it is done.
20:40:53 <rdz_> exio4: yes but 2D vectors were where the conversation started
20:40:54 <geekosaur> actually all the posts with the matlab tab in that dreamwidth journal are worth reading
20:41:06 <naudiz> rdz_: just write a function that converts (a,a) to (a)
20:41:07 <rdz_> I'm trying to create a 2D matrix where arr ! (x,y) == arr ! (y,x) && arr ! (x,x) == 1
20:41:16 <emmanuel_erc> Have any of you guys heard af sigphe?
20:41:40 <scshunt> emmanuel_erc: that an AMS SIG?
20:41:44 <rdz_> naudiz: yes you mentioned that before, and now I see how that works
20:41:46 <naudiz> sorry (a,a) to a
20:41:53 <rdz_> but Array already does it
20:42:07 <cmccann> rdz_: you really don't have to implement anything to use Ix
20:42:07 <emmanuel_erc> Sorry i mean sigfpe
20:42:14 <rdz_> and it's not like I'm writing code that complex that I need to evaluate performance tradeoffs between Vector and Array
20:42:22 <cmccann> rdz_: you just have to provide it with the index range you're using each time
20:42:25 <naudiz> rdz_: Array is likely to give you lots of overhead. How big are your matrices going to be?
20:42:29 <cmccann> Array stores that inside the Array data type IIRC
20:43:02 <rdz_> naudiz: I think the biggest one is something like 10k rows
20:43:35 <naudiz> rdz_: use vector, seriously
20:43:43 <rdz_> haha, overhead that bad?
20:44:06 <naudiz> to me it was unusable without deepsey
20:44:10 <naudiz> deepseq
20:44:13 <cmccann> rdz_: e.g. if you have a 13x13 matrix you'd use "index ((0,0), (12,12)) (i,j)" to get the Int offset for element i,j
20:44:41 <naudiz> because on traversion it created lots of overhead
20:44:52 <naudiz> sorry, lots of thunks
20:45:03 <rdz_> I'll be using an Unboxed array
20:45:07 <rdz_> should be strict, no?
20:45:41 <naudiz> afaik unboxed array can't be used with (Int,Int) as long as you don't implement it yourself
20:46:00 <rdz_> cmccann: assuming I don't ever know the size of hte matrix and I use multiple matrix, I'd essentially have to create a new data type that is aware of it's dimensions
20:46:04 <rdz_> at that point I'm replicating a lot of array work
20:46:13 <naudiz> at least there was a restriction, I don't remember how it was exactly
20:46:38 <cmccann> naudiz: (Int,Int) would be the index type. should be no problem with that.
20:46:50 <rdz_> naudiz: damn you're right
20:47:09 <rdz_> https://hackage.haskell.org/package/array-0.5.1.0/docs/Data-Array-Unboxed.html
20:47:45 <naudiz> yes, you'd have to implement it yourself. I don't know how complicated this is.
20:48:41 <rdz_> has anyone tried repa?
20:50:07 <nitrix> If Functors are "things that can be mapped over', how would you simplify monads in a couple words?
20:50:23 <nitrix> Monad*
20:50:46 <naudiz> rdz_: my biggest matrices were 600 times 600 and they were tridiagonal.
20:50:51 <shachaf> "things which cannot be simplified in a couple words"
20:50:53 <amicuscuriae> which editor do you guys use?
20:50:55 <amicuscuriae> I want to know
20:51:25 <naudiz> amicuscuriae: vim.
20:51:32 <rdz_> nitrix: I like (though many would disagree about accuracy) "things that can be sequenced"
20:51:38 <Reshi> amicuscuriae: emacs
20:51:39 <geekosaur> nitrix, I'm not sure you can --- Monad is too general. it's any Applicative that supports the concept of "bind" (or equivalently "join")
20:51:44 <Cale> I use vim, but anything which can convert tabs to spaces, maintain the indentation of the previous line, and maybe do a bit of syntax colouring is enough to keep me happy.
20:51:47 <amicuscuriae> naudiz, please dont' punish me
20:51:50 <amicuscuriae> I am a complete noob
20:52:01 <amicuscuriae> Reshi, noooooooo
20:52:03 <naudiz> amicuscuriae: I just answered your question.
20:52:10 <Cale> Seriously, gedit is fine
20:52:11 <amicuscuriae> Has anyone tried "Leksah.org?"
20:52:23 <Reshi> nitrix: sequential computations resulting in a value?
20:52:25 <rdz_> naudiz: and you regret no doing it in Vector? Assuming that size caused space leaks using Array?
20:52:37 <cmccann> amicuscuriae: I use ScitTE if you want something fancier than gedit that isn't "scary"
20:52:39 <amicuscuriae> I could be the next RMS with right kinda tools
20:52:43 <naudiz> rdz_: not space leaks, thunks
20:53:03 <amicuscuriae> cmccann, I want something that looks like Sublimetext and has autocompletion and tinting and all
20:53:04 <rdz_> oh, so just slowed down because of unevaluated thunks?
20:53:05 <Reshi> amicuscuriae: use anything which makes you feel good, in terms of aesthetic and comfort. 
20:53:15 <naudiz> amicuscuriae: RMS is mostly known as an activist, not as a programmer
20:53:22 <rdz_> amicuscuriae: I've tried Leksah, it's good but buggy
20:53:22 <cmccann> oh, I dunno about autocomplete
20:53:24 <Reshi> amicuscuriae: why not sublime text? 
20:53:26 <geekosaur> amicuscuriae, maybe you want the Sublime Haskell plugin for Sublime Text?
20:53:51 <hiptobecubic> amicuscuriae, there's also atom, which has been gaining steam lately
20:53:59 <naudiz> amicuscuriae: vim has a lot of plugins, everything is possible
20:54:08 <naudiz> I don't like atom...
20:54:09 <Reshi> Yeah and it has ghc-mod support too, atom
20:54:30 <Cooler> when lazy evaluating
20:54:38 <Cooler> how does it avoid work duplication?
20:54:39 <amicuscuriae> naudiz, But he is the best known programmer and also knows as last MIT hacker for a reason only
20:54:53 <amicuscuriae> Reshi, I don't use non-free
20:55:20 <geekosaur> Cooler: when it reduces something, it replaces the expression node with its computed value
20:55:41 <cmccann> amicuscuriae: maybe you should just bite the bullet and learn emacs :P
20:55:43 <geekosaur> (yes, this is mutation; it happens below the level of Haskell though and is not observable)
20:56:46 <cmccann> it's not like it's actually *changing* the value. forcing a thunk is just a very extremely magical flavor of "id".
20:56:57 <geekosaur> the lack of mutation in Haskell is what makes the replacement at the STG graph reduction level safe, in fact
20:57:18 <geekosaur> and thereby lets it share values and avoid extra work
20:57:24 <nitrix> Cooler: It's a graph and the thunk is replaced by the actual value once evaluated.
20:58:10 <amicuscuriae> cmccann, ok Hail Freedom of Code! May the Freedom with all
20:58:13 <Reshi> geekosaur: what does STG stand for?
20:58:34 <rdz_> Cooler: it should be noted though that occasionally Haskell does evaluate the thunk more than once
20:58:51 <rdz_> it happens rarely but because the language is pure it doesn't matter
20:59:42 <nitrix> rdz_: What's an example of this? Race conditions when multithreaded?
20:59:56 <amicuscuriae> julianleviston, the problem is that i am not coming from anything, I am a complete newbie
21:00:09 <julianleviston> amicuscuriae: newbie at what?
21:00:15 <rdz_> nitrix: yes pretty much, that's why it's rare
21:00:41 <kadoban> Reshi: Presumably Spineless Tagless g-machine: http://research.microsoft.com/pubs/67083/spineless-tagless-gmachine.ps.gz
21:00:43 <geekosaur> Reshi: "spineless tagless G-machine"
21:00:43 <julianleviston> amicuscuriae: how can you know about headers, and memory management if you’re a complete newbie? In fact, how do you even know the word “newbie”???
21:01:01 <geekosaur> (which is actually neither spineless nor tagless these days, I understand, but the name remains)
21:01:10 <geekosaur> the "G" there means "graph reduction"
21:01:20 <rdz_> nitrix: I think that's one of the reasons why unsafeInterleaveIO is considered particularly unsafe
21:01:44 <Reshi> geekosaur: thanks! I found the ghc page on STG, but it still never said what STG is an acronym for :P Good learning I guess
21:01:45 <amicuscuriae> julianleviston, complete new @ programming, I have no experience whatsoever.
21:01:54 <julianleviston> amicuscuriae: ah ok.
21:02:01 <amicuscuriae> julianleviston, just reading about it all, and taking help from people @ #fsf
21:02:09 <julianleviston> amicuscuriae: what’s fsf?
21:02:13 <nitrix> rdz_: Makes sense.
21:02:39 <amicuscuriae> they say people are being taught C++ but Haskell might actually be easier than C++ in terms of Syntax and other stuff and its Modern and Stable now
21:02:44 <rdz_> nitrix: https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/deamortized-st
21:02:49 <amicuscuriae> julianleviston, its Free Software Foundation fsf.org
21:02:58 <rdz_> it's an interesting read on the topic
21:03:00 <julianleviston> amicuscuriae: haskell is much easier to learn than C++
21:03:05 <amicuscuriae> julianleviston, the license used by Linux kernel was written by them only
21:03:09 <amicuscuriae> also GNU is by them only
21:03:13 <rdz_> though I haven't read it in a while - when I last looked at it, it was a bit over my head
21:03:16 <amicuscuriae> Debian was helped by them only
21:03:33 <julianleviston> amicuscuriae: yeah, I know who the free software foundation are - just didn’t know the abbreviation
21:04:16 <julianleviston> amicuscuriae: the problems with learning Haskell are the same as learning math.
21:04:22 <julianleviston> amicuscuriae: whatever they may be ;-)
21:04:44 <amicuscuriae> julianleviston, ok :) but I am not finding a complete idiot guide or Guide to Programming with Haskell, I almost started with C++ and then a person stopped me and said if you had interpreted languages and only want compiled lang try Rust or Haskell w/e works for you and then I looked into Hell World and got scared by Rust
21:05:17 <amicuscuriae> hate/not/had
21:05:20 <julianleviston> amicuscuriae: can I ask “what are you learning programming for?”
21:05:50 <amicuscuriae> For developing small cli / gui programs for doing small calculations stuff based on user inputs and other arguments
21:06:04 <julianleviston> amicuscuriae: it’s good to have very clear aims in mind
21:06:12 <julianleviston> amicuscuriae: to drive you.
21:06:42 <amicuscuriae> I did program back in high school via C++ and Turbo C++, it was huge program with 2650 lines (basically because I did not know how to optimize it :) It was unit converter 
21:06:57 <julianleviston> amicuscuriae: if that’s the extent of your requirements, a scripting language or even shell programming might suffice.
21:07:11 <amicuscuriae> it has colors / local fonts even - people were shocked to see local fonts in Dos 
21:07:12 <naudiz> what's Turbo C++? Something like Turbo Pascall?
21:07:21 <amicuscuriae> its a compiler
21:07:22 <julianleviston> amicuscuriae: “small” being the operative condition that drives that response.
21:07:55 <amicuscuriae> julianleviston, then something from fsf said C++ with QT works
21:08:15 <amicuscuriae> but another one was like if he loves compiles let him go with Haskell / Rust only
21:08:17 <julianleviston> amicuscuriae: sorry, but someone who has programmed a 2650 line C++ program *IS NOT* a “noob” :-)
21:09:43 <julianleviston> amicuscuriae: go follow the CIS194 course…
21:09:46 <amicuscuriae> julianleviston, but that was 7 yrs ago, I also programmed pure HTML site in high shcool it was huge, it was a course to learn HTML itself lol :) girls loved it, it was silly because i used pics for syntax printing i did not know how to print code back then,, I am from a very small place .. so we did not have internet .. only thing I had was book in School which sucked.. old book and no help at all, teachers knew less than me
21:09:47 <amicuscuriae> lol
21:09:51 <rhovland> amicuscuriae: haskell is great, highly recommend
21:10:21 * hackagebot DAV 1.2 - RFC 4918 WebDAV support  https://hackage.haskell.org/package/DAV-1.2 (ClintAdams)
21:10:22 <julianleviston> @where cis194
21:10:22 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
21:11:38 <rhovland> amicuscuriae: I mostly went from learnyouahaskell and easy problems on hackerrank, but if I were doing it now I'd do that cis194 thing... thinking of doing that now anyway. But I knew a bunch of other languages already.
21:12:31 <julianleviston> amicuscuriae: don’t forget to do the exercises! :) haha I didn’t do enough of them.
21:13:19 <rhovland> amicuscuriae: you'll probably struggle a lot with the type system until it clicks. stay as far away from monads as possible.
21:14:20 <naudiz> amicuscuriae: learnyouahaskell is okay to get an idea for haskell
21:15:11 <dmj`> Axman6: did you see the aeson paste?
21:15:12 <exio4> I found it to be a cool resource if you knew some functional languages before
21:15:59 <amicuscuriae> julianleviston, ok thanks 
21:16:00 <amicuscuriae> rhovland, ok
21:16:12 <dmj`> Axman6: http://lpaste.net/141282
21:16:15 <amicuscuriae> naudiz, I see, but I want that Haskellbook.com my card won't work only
21:16:16 <amicuscuriae> :/
21:16:39 <julianleviston> amicuscuriae: if you want my list of exercises go here: http://www.genericoverlords.com/haskell_notes
21:16:45 <rhovland> amicuscuriae: really recommend easy problems on hackerrank... since you can look at other people's haskell solutions to the problems and get ideas
21:16:59 <amicuscuriae> kk
21:17:06 <naudiz> amicuscuriae: I don't understand what you mean. you can read learnyouahaskell for free on their website
21:17:11 <julianleviston> amicuscuriae: note they’re my personal exercises that I use - don’t treat the answers as authoratative…. the important things are the questions.
21:17:29 <julianleviston> rhovland: hey thanks, I’ll go check them out too
21:18:02 <julianleviston> rhovland: guh. signups :(
21:18:46 <naudiz> I didn't know all those excercises at all, maybe there's something to learn for me, too. thanks
21:19:13 <rhovland> julianleviston: yeah, hate that too. they want to make it slightly harder for people to plagiarise things though, I suppose
21:20:22 * hackagebot hsilop 0.2.0.0 - RPN calculator  https://hackage.haskell.org/package/hsilop-0.2.0.0 (rnhmjoj)
21:20:29 <naudiz> rhovland: they should just use a free license... who cares about plagiates?
21:21:35 <rhovland> naudiz: well they do competitions... so if you read people's solutions for a problem it won't give that account credit for later solving the problem
21:22:35 <naudiz> hrm...
21:22:58 <naudiz> btw, Euler project is another great site for exercises
21:23:09 <naudiz> used it a lot when I was learning Haskell
21:23:13 <rdz_> naudiz: btw I thought you might want to know - UArray does work with (Int,Int) as the Index. The restriction is just on the element types
21:23:27 <naudiz> (I'm still learning it' but you get the idea)
21:23:50 <montanonic> Euler is great for exercises if you also want to learn about math. If not, it's not recommended.
21:24:08 <naudiz> rdz_: maybe it was another restriction that made it not usable for me.
21:24:35 <naudiz> montanonic: I'm doing numerics with Haskell, so I can agree with you.
21:24:41 <rhovland> naudiz: yeah... definitely like project euler too... I used it a bunch too... it's on hackerrank too as some sort of extended contest (so it'll only let you pass if you run within time/memory constraints, and you can see other people's solutions once you solve a problem, etc)
21:25:10 <julianleviston> project euler goes to fast, I reckon
21:25:17 <naudiz> rhovland: cool thing
21:26:06 <rhovland> naudiz: although I suppose a ton of people post their solutions for PE in the PE forums for a question, same sort of deal
21:26:26 <rhovland> naudiz: but harder to e.g. filter for haskell solutions
21:26:36 <rdz_> has anyone used http://hackage.haskell.org/package/keys-3.10.2/docs/Data-Key.html ?
21:26:46 <rdz_> for such a simple looking module it took a heck of a lot to build
21:26:51 <rdz_> yikes
21:27:06 <naudiz> rhovland: it's mostly mathematical solutions one should be interested in, since they can be translated into any computer language
21:27:32 <naudiz> efficiency might be another topic, though...
21:28:16 <rhovland> naudiz: well, true. I care more about the haskell than the math, though. 
21:31:43 <rhovland> naudiz: I've tried a bunch of the places that let you submit haskell (spoj,hackerearch,codechef,etc) and hackerrank seems to have the best "expectations" for time/memory... although that's partly b/c some places are using really old ghc versions.
21:32:07 <naudiz> nb
21:32:17 <naudiz> rhovland: I'll definately take a look, thanks
21:33:53 <rhovland> naudiz: I haven't run into anything that wasn't solvable with haskell on HR, and I almost never need to do stuff like use mutable vector
21:35:02 <naudiz> rhovland: are there things you can't solve with haskell but in other languages? I mean, it's turing complete
21:35:25 <rhovland> naudiz: well I mean within the time/space limits
21:35:33 <naudiz> ah, okay
21:36:00 <kadoban> To be fair though, haskell gets slightly longer time limits than some other languages on hr
21:36:05 <rhovland> naudiz: generally a 5sec limit for haskell (as opposed to 2sec for c/c++)
21:36:40 <naudiz> seems a little unfair to me :D
21:37:14 <naudiz> most of the time, Haskell isn't that slow
21:37:36 <rhovland> really important to use bytestring too, 30-40M input files are pretty common
21:37:55 <naudiz> why not text?
21:38:02 <kadoban> You can use Data.Text usually, which is slightly less fugly than bytestring
21:38:17 <rhovland> hmm haven't tried too much with data.text. Will try.
21:38:20 <naudiz> that answers my question, tahnks
21:38:27 <kadoban> I think I remember one that I had problems meeting the time limits using Text though, but I can't remember if I just got lazy or actually needed to.
21:38:48 <rhovland> and sometimes I really need to use builder for output if I need to output a ton
21:43:21 <rhovland> naudiz: yeah, haskell is quite fast, I mean, python has 10sec limits. scala is 7sec. java at 4sec.
21:44:10 <kadoban> The haskell limits seem to be fairly generous as well, in that I kinda suck at those kinds of problems and have been able to do quite a few without problem.
21:44:28 <exio4> which site are we talking about?
21:44:50 <kadoban> But I never tried them in a different language either, so maybe they're all equally generous. https://www.hackerrank.com/
21:50:27 <rhovland> kadoban: the python limits seem really generous.. I've had one or two I could barely pass in haskell, and throwing an almost naive python solution was fine
21:53:27 <kadoban> That's kinda funny
21:59:23 <rhovland> kadoban: it was https://www.hackerrank.com/challenges/jim-and-the-challenge 
22:01:10 <kadoban> Hmm, I don't remember ever looking at this one.
22:03:45 <Reshi> For evaluating a string to a function name I should make a map/assoc list right?
22:05:35 <naudiz> hackerrank has a terrible website
22:05:41 <naudiz> way too much js
22:06:08 <kadoban> Yeah it's pretty funky and sometimes buggy.
22:07:52 <naudiz> Haskell is not within the popular lanuage list? whaaaat?
22:08:13 <kadoban> There's a popular languages list?
22:08:19 <Axman6> dmj`: yeah I saw your problem - seems worth reporting since it could break a lot of code
22:08:20 <dmj`> naudiz: probably not a popular list
22:08:47 <Axman6> Reshi: that's probably the easiest way
22:10:40 <dmj`> Axman6: yea, will do
22:10:47 <rhovland> naudiz: heh one of the few sites I use chrome for instead of firefox. and still, sometimes a HR tab will eat 100% of my cpu for no apparent reason, I'm pretty sure
22:11:13 <naudiz> rhovland: they're mining bitcoins on your computer
22:12:40 <naudiz> I'm doing "Solve me first FP" and it already gives me the solution?
22:12:57 <naudiz> this is strange.
22:14:03 <rhovland> naudiz: that seems to be just to give you something that reads/writes IO.. most everything on HR is read from stdin, write to stdout
22:15:17 <kadoban> naudiz: The FP ones aren't the best either, IMO. You can just do whatever problems in haskell, it doesn't matter.
22:15:21 <rhovland> naudiz: pretty odd though the way they do it. and really, the stuff in the "algorithms" or "mathematics" sections are more interesting imho. The "functional languages" section sometimes seems to cater to people with worse functional languages
22:17:57 <kadoban> The only thing that sucks about haskell at hr is that it's missing quite a few basic data structures and such in the libraries it has allowed … so like if you want a priority queue, you have to implement one. But there's … not that many missing I guess.
22:18:00 <rhovland> although it's funny, pretty much every discussion in the "functional programming" section has someone complaining that they can't use c++
22:18:29 <rhovland> kadoban: mm.. they used to have data.list.split, and don't any more.. I've been meaning to send a feature request about that
22:19:04 <kadoban> Ugh, that's annoying. That package is really useful.
22:19:32 <naudiz> koala_man: what do you recommend?
22:19:32 <rhovland> kadoban: I usually just use set/map for priority queue... deleteFindMin etc. they do support vector/unboxed/mutable etc though
22:19:59 <rhovland> kadoban: they don't support vector.algorithms though, which bites
22:20:38 <naudiz> rhovland: you CAN do functional programming in C++
22:20:57 <naudiz> especially with TMP
22:21:51 <kadoban> rhovland: I just started putting together a quite little "Template.hs" with the stuff I ended up missing badly enough. Mostly just as a fun addendum I guess, probably not really anything I actually /needed/. Turns out stuff from Purely Functional Data Structures really comes in handy, and is almost trivial to implement.
22:22:03 <rhovland> naudiz: the HR-supported languages for "functional programming" is a small subset... clojure, scala, erlang, f#, haskell, uh.. couple others.. 
22:22:16 <rhovland> naudiz: but I mean, no python or ruby, and those can do pretty functional things
22:22:42 <naudiz> true, but I've written functional code in C++ before discovering Haskell.
22:23:14 <naudiz> it's not worth it, though... lots of code for little functionality
22:23:19 <kadoban> In practice if they allowed C++ and python and such it'd just be a useless category … but it already is basically useless, IMO.
22:23:42 <rhovland> yeah, it's a bad category
22:24:03 <naudiz> C++ has been inspired a lot by Haskell
22:24:16 <rhovland> some ok problems in there. but nothing specific to functional languages
22:24:31 <naudiz> discovering Haskell was like an epiphany :D the same things with less code
22:25:24 <rhovland> heh I do stuff on HR in the language-specific domains (c++, java, python).. and man.. I don't know if java was always this terrible... but after haskell... just sooo much extra cruft
22:25:44 <naudiz> it always was.
22:25:52 <rhovland> really, both c++ and java... the lambda/iterators/etc.. 
22:26:37 <naudiz> at least C++ has TMP and lets you manage memory...
22:26:46 <naudiz> Java is just... no.
22:26:47 <dfeuer> Is Cale still about?
22:26:55 <Cale> dfeuer: kinda
22:26:58 <Cale> I should be asleep
22:27:04 <dfeuer> Haaaahahahahahahaha!
22:27:19 <rhovland> python is nice, though. well, mostly. I used to complain about python's OO stuff, coming from ruby. now that I do haskell, that doesn't bother me at all
22:27:20 <dfeuer> Cale, do you get haskell-cafe? I just sent a message and wonder if you have thoughts on such things.
22:27:20 <Cale> what's so funny?
22:27:27 <Cale> uhhh
22:27:39 <dfeuer> I've been going to sleep at rather unfortunate hours lately :(
22:27:56 <Cale> Yeah, just a sec while I try to get gmail to load
22:28:02 <naudiz> rhovland: scripting languages are okay, as long as you don't use them on a large scale
22:28:03 <dfeuer> Honky donkey.
22:28:24 <Cale> Haskell Cafe 9776 unread threads
22:28:26 <kadoban> rhovland: Mostly when doing python I just miss haskell's types. Runtime crashes that would have been caught by even a semblance of a type system are kinda painful.
22:28:38 <dfeuer> C++ is okay, as long as you don't use it on a large scale (where large scale = more than ten characters)
22:29:13 <Cale> dfeuer: I don't think they already exist somewhere as far as I know
22:29:37 <naudiz> dfeuer: I used to do a lot of C++ and it's an awesome language once you've seen through all that legacy bullshit and know what NOT to do.
22:30:01 <dfeuer> Cale, do you think they are sensible? Or that similar things may be? I just don't too much care for all those attoparsec combinators that return *lists* of things.
22:30:42 <Cale> Lists of things are appropriate when you're planning on iterating over them...
22:30:57 <Cale> But maybe?
22:31:01 <Cale> Use them and see
22:31:15 <rhovland> haskell's inconsistancy about uh.. argument order for objects.. irrites me.. like I never remember if it's Data.Sequence.index sq 5 or index 5 sq. seems to depend on the module. while in e.g. ruby, it'd be sq.index(5)
22:31:31 <spacekitteh> is there a type-level sum which I can use with a free monad?
22:31:32 <dfeuer> Cale, if you only need to work through the list once (e.g., parsing a list of numbers to its product), there's no reason to build it.
22:32:34 <montanonic> rhovland: thankfully, if you check the type, you'll know immediately
22:32:41 <rhovland> sometimes I think it'd be nice if there were a language where you could give arguments in any order. obviously, (unless the function guarantees f a b == f b a) you'd have to send same-typed arguments as a list or tuple
22:32:44 <kadoban> naudiz: IMO it's only a decent language at that point … it's still not very safe, not very fun, etc. And that's after a /lot/ of work.
22:33:38 <montanonic> rhovland: hmm, that's interesting; sounds theoretically possible, seems like it'd be problematic with Haskell's currying though.
22:33:39 <rhovland> montanonic: well, but I'm not checking the type while I'm writing it. So sure, at the end, try to compile, and it's an easy error to fix
22:33:54 <naudiz> kadoban: you need a lot of work, yes
22:34:13 <montanonic> rhovland: right, yes, it can be an inconvenience, but it is necessary sometimes to have a particular order if you want nice curried functionality
22:34:24 <montanonic> so there *are* reasons for having different orders 
22:34:44 <kadoban> naudiz: Plus, the more I learned of C++, the more pitfalls I started to see. It got to a point I'd spend as much time with my head stuck in the standard as actually working on real problems and got kinda tedious.
22:34:45 <levi> I think you can use OCaml's named arguments in different orders.
22:35:06 <levi> Definitely adds some syntactic overhead, though.
22:35:34 <dfeuer> In Haskell, you can always pass a single record as an argument. That's sometimes done when the number of arguments would otherwise be absurd.
22:35:56 <rhovland> I dunno if type inference would be able to work properly if you don't care about argument order
22:37:01 <quchen> (^) 2 3 -- Order matters.
22:37:21 <quchen> The compiler can't go "oh and here it matters and here it doesn't".
22:37:23 <rhovland> quchen: sure, you'd have to use a tuple or list as arguments for those
22:37:43 <Axman6> sounds horrible
22:38:14 <quchen> In particular much more horrible than the proven way of using a lambda.
22:38:17 <levi> You have to have some way to identify which is which. Position is one way (a la tuples), naming is another (a la record syntax).
22:39:00 <rhovland> sometimes I have a bunch of code, using sequence, or map, or set, and I want to change from one to the other, and I have to change a bunch of stuff, b/c they're not consistant about which position is the object
22:39:14 <quchen> Some languages have named left-open parameters, such as Mathematica. You can write something like "#1" to mean the first argument of the current function, e.g. "lookup #1 db  ===  \entry -> lookup entry db". It's messy.
22:41:09 <ReinH> rhovland: can you give an example of an inconsistent function?
22:41:21 <rhovland> like, when can you replace Data.Sequence.index with (!!) for list? will you have to swap the argument order? I always screw up data.sequence.index
22:41:45 <MarcelineVQ> check the type sig
22:42:06 <ReinH> index and (!!) have the same argument order
22:42:09 <dfeuer> :t index
22:42:10 <lambdabot> Ix a => (a, a) -> a -> Int
22:42:17 <dfeuer> Wrong index, I guess.
22:42:18 <rhovland> :t Data.Sequence.index
22:42:19 <lambdabot> Seq.Seq a -> Int -> a
22:42:42 <Axman6> whichever argument is most likely to change most often usually gets passed last, because the other arguments often act as "settings" for the function
22:42:45 <ReinH> I don't think containers is as inconsistent as you are suggesting
22:42:52 <ReinH> I'd like some examples
22:43:02 <rhovland> :t Data.Map.lookup
22:43:03 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
22:43:14 <rhovland> :t Data.Set.member
22:43:15 <lambdabot> Ord a => a -> S.Set a -> Bool
22:43:48 <ReinH> seems fine
22:43:50 <Axman6> sometimes people don't follow that rule because they want to use functions infix, like k `member` set
22:44:43 <rhovland> I'd say map/set lookup and list/sequence lookup seem like they should have the same argument order
22:45:33 <Axman6> which is similar to the k ∈ ks syntax
22:45:41 <ReinH> lookup is designed so you can do, e.g., lookup k <=< lookup k'
22:47:14 <Axman6> I'm not sure that's true
22:47:27 <ReinH> I'm still not seeing "haskell's inconsistency"
22:48:06 <Axman6> I would agree it is somewhat inconsistent, but it's also trivial to resolve by asking for the types of functions
22:48:44 <ReinH> It's not like Data.List.lookup and Data.Map.lookup are inconsistent
22:49:45 <sssilver> Hey guys, I have a problem... I feel like I understand monads, but I don't really know category theory, and I always assumed it would be much harder to understand. So I'm confused.
22:50:27 * hackagebot pandoc-citeproc 0.7.4 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.7.4 (JohnMacFarlane)
22:50:49 <Axman6> sssilver: I don't know category theory and use monads daily
22:50:53 <ReinH> sssilver: what's the question?
22:51:02 <Axman6> why do you think you'd need to know any category theory?
22:52:44 <levi> The significance of monads to doing category theory is pretty different than the significance of monads to Haskell programming, even though they're the same structure.
22:52:45 <sssilver> Axman6 well my friends were like it's really advanced math, and unless you're a serious CS/advanced applied math person it's impossible to understand for you, and I'm not even that bright of a programmer. But as a practical concept it made total sense to me and so I'm wondering if I'm missing something.
22:53:06 <rhovland> sssilver: are you saying you assumed category theory would be hard to understand, or monads would be hard to understand?
22:53:07 <dfeuer> > let s = Seq.fromFunction (2^30) (1+) in ((*) <$> s <*> s) `Seq.index` (2^60-1)
22:53:08 <lambdabot>  1152921504606846976
22:53:13 <quchen> sssilver: After knowing Monads in Haskell for some time, I went ahead and learned what mathematical monads are. The result is that I'm amazed that someone found that abstraction useful for programming, and not much else.
22:53:14 <levi> They are really simple, actually.
22:53:56 <levi> It's the fact that they're abstract that makes them hard for people to grasp, not that they're complicated.
22:53:56 <quchen> sssilver: If you're going to learn mathematical monads in order to understand them in Haskell you'll going to be quite disappointed I think.
22:54:21 <sssilver> but all programming is abstract on a similar level then
22:54:21 <ReinH> quchen: especially since the presentation is different
22:54:38 <quchen> sssilver: Sounds like your friends have no idea what they're talking about.
22:54:45 <Axman6> sssilver: your friends told you complete bullshit =)
22:55:04 <sssilver> well they don't know any of it, because they say it's too complex stuff
22:55:07 <sssilver> sec
22:55:08 <quchen> "Hey this addition thing is quite advanced you need like Galois theory to understand that"
22:55:42 <rhovland> hmmm
22:55:57 <levi> All programming is abstract to some degree, but programmers are familiar with the parts they're familiar with.
22:55:58 <sssilver> my friend basically sent me this -- "A monad is just a monoid in the category of endofunctors, how does that sound"
22:56:08 <levi> Monads aren't typically part of that 'familiar set' right now.
22:56:09 <sssilver> and I was like well crap I need to google each one of those
22:56:13 <Axman6> both true and irrelevant
22:56:18 <ReinH> sssilver: it sounds like jargon
22:56:33 <kadoban> It's basically a CT joke, in this context.
22:56:35 <Axman6> you don't know any of those words (except monoid, which you already know what it means, even if you didn't know the name)
22:56:36 <MarcelineVQ> sounds like your friend isn't interested in your learning :X
22:56:43 <ReinH> of course different fields have different jargon
22:57:29 <sssilver> so instead of going and trying to understand what each of those words mean, I just tried to understand what monad means according to a few YouTube videos and an excellent web page. And it made total sense.
22:57:46 <Axman6> yep, because the idea is incredibly simple
22:57:49 <rhovland> hm read something about endofunctors etc that made a lot of sense
22:58:15 <sssilver> I've read this http://dev.stephendiehl.com/hask/ and watched this https://www.youtube.com/watch?v=dkZFtimgAcM
22:58:29 <rhovland> seeing simple recursion as the same as a linked list was a bit of a revelation for me
22:58:46 <Axman6> I found this quite good for explaining the general concept of pattern: http://codon.com/refactoring-ruby-with-monads
22:58:46 <sssilver> I've had a much harder time understanding arrays when I was really young
22:58:49 <ReinH> sssilver: oh god not crockford
22:58:56 <ReinH> sssilver: he has no idea what a monad is
22:59:01 <sssilver> ReinH oh crap
22:59:04 <Axman6> it's not a great introduction to the theory, but it gives intuition nicely
22:59:21 <dfeuer> How about adjunctions? Is there some easy explanation of those somewhere?
22:59:32 <ReinH> dfeuer: thecatsters?
22:59:34 <ReinH> leinster?
22:59:52 <dfeuer> ReinH, now you're getting into territory beyond "easy explanations" :-P
22:59:57 <ReinH> er
23:00:03 <ReinH> leinster? I'm mixing things up
23:00:06 <dfeuer> But thanks for the reminder.
23:00:09 <ReinH> Lawvere
23:00:12 <dfeuer> I meant to watch the catsters.
23:00:28 <dfeuer> And I have Lawvere and Schanuel too, which I need to get back to ....
23:01:02 <ReinH> Leinster's new Basic Category Theory book looks very good
23:01:30 <ReinH> sssilver: crockford's explanation is easy to digest because it's hand-wavey bullshit
23:01:53 <sssilver> ReinH what does that metaphor mean? sorry, I'm not a native speaker
23:01:56 <naudiz> kadoban: the books by Mayers tell you a lot about those pitfalls and it quickly becomes intuitive, at least that was the case for me.
23:02:23 <ReinH> sssilver: https://en.wikipedia.org/wiki/Handwaving
23:02:25 <rhovland> while I'd like to do things with map/fold/etc, I often fall back on just doing a recursive function.. I mean.. so many things are so easy to do as a recursive function
23:02:54 <ReinH> specifically https://en.wikipedia.org/wiki/Handwaving#Mathematics
23:02:54 <dfeuer> Thanks, ReinH 
23:03:21 <ReinH> uh, that wikipedia article is awful
23:03:33 <naudiz> ReinH: do you have an expample?
23:03:45 <naudiz> most wikipedia articles are...
23:03:47 <ReinH> http://c2.com/cgi/wiki?HandWaving
23:03:55 <ReinH> naudiz: of?
23:04:01 <hodapp> 'most' wikipedia articles are awful?
23:04:02 <naudiz> handwaving
23:04:11 <levi> rhovland: It's all a matter of practice and familiarity with different ways of expressing things.
23:04:17 <ReinH> "monads are like boxes"
23:04:49 <naudiz> ReinH: I thought, they were Tacos?
23:04:58 <rhovland> eg, I was trying to implement knuth-morris-pratt, and just following the wikipedia pseudocode... which is imperative.. and converting that to haskell, was _far_ easier to think of as recursion
23:05:04 <sssilver> OK so ReinH I don't really understand monads then, cool beans :(
23:05:29 <levi> sssilver: Probably the best place to start to build a good intuition about monads is by building an intuition about functors.
23:05:33 <ReinH> sssilver: maybe you do, but I woudn't listen to crockford try to explain something he doesn't understand
23:05:41 <hodapp> who's crockford?
23:05:49 <rhovland> levi: doing a while loop, in particular.. while (j<x) {} , when inside the block they mess with j
23:05:50 <sssilver> levi I understand functors I think
23:05:51 <kadoban> hodapp: The JS guy
23:06:02 <ReinH> sssilver: if you want videos, try https://www.youtube.com/watch?v=9fohXBj2UEI&list=PL0E91279846EC843E
23:06:05 <baweaver> Douglass Crockford
23:06:17 <hodapp> ohhh *that* Crockford
23:06:29 <baweaver> ooooo
23:06:31 <baweaver> monads again
23:06:40 * baweaver cracks knuckles
23:06:45 <baweaver> we goin learn today folks
23:06:48 <ReinH> sssilver: or https://www.youtube.com/watch?v=ZKmodCApZwk
23:06:51 <levi> sssilver: How would you explain what a functor is?
23:07:12 <baweaver> http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
23:07:15 <levi> (I find the best way to find the gaps in my knowledge of something is to try to explain it)
23:07:21 <baweaver> that helps
23:07:21 <rhovland> levi: and it's totally easy to do the while loop as recursion, with j as an argument
23:07:25 <kadoban> sssilver: You're likely not missing anything important if you can use them in haskell. The CT concept of a monad seems to be just about completely irrelevent to haskell, IMO.
23:07:28 <sssilver> levi basically a class that represents a function?
23:07:56 <ReinH> sssilver: what does that mean?
23:07:57 <hodapp> sssilver: that's the bullshit C++ definition of a functor, which is best left ignored.
23:08:16 <sssilver> hodapp ah that's all I know
23:08:52 <sssilver> OK guys sorry I completely fucked up
23:08:53 <levi> Note that there are a lot of things from various lines of thought called 'functor', and they don't all come from the same lineage.
23:09:03 <MarcelineVQ> lol relax sssilver 
23:09:19 <levi> sssilver: Hey, don't worry! We all learn by forming ideas and figuring out where they're wrong.
23:09:31 <ReinH> kadoban: what do you mean "completely irrelevant"?  It's quite relevant.
23:09:36 <ReinH> It's the same thing, after all.
23:10:01 <ReinH> And various results about monads from CT have been useful in Haskell
23:10:32 <montanonic> sssilver: don't worry if you feel like you don't understand Monads right now anymore; consider this: what's a List?
23:10:45 <sssilver> montanonic it's a data structure
23:11:01 <montanonic> but now introduce the idea of recursion
23:11:07 <montanonic> to someone who hasn't experienced it yet
23:11:08 <kadoban> ReinH: Does learning and understanding the CT definition somehow help greatly when actually using haskell? I haven't seen how if it does.
23:11:14 <rhovland> wait, I thought sssilver does understand monads, and was confused becuase he understands it
23:11:21 <ReinH> kadoban: it can from time to time
23:11:27 <sssilver> rhovland well apparently I don't
23:11:36 <montanonic> sssilver: the point being: intuition for Lists is a really broad thing that you understand more the more you use them and see different use cases of them
23:11:41 <rhovland> sssilver: :( you were giving me hope
23:11:50 <ReinH> sssilver: well, what's a monad?
23:12:11 <montanonic> sssilver: Monads are incredibly simple on the surface, because they are, like lists, but I'd argue that *understanding* them really means *knowing how and where to use them*, and the simple fact is, that just takes time
23:12:18 <montanonic> and it takes using them a lot
23:12:24 <sssilver> ReinH I can't easily express it with words, but I can relatively easily implement one I think
23:12:33 <montanonic> in exercises, in small projects, in implementing your own library, and in reading other code
23:13:02 <montanonic> That's where I'm at right now. I can explain a Monad, but I don't think I really *get* them, because I need to continue to develop more of an intuition for there uses and power.
23:13:34 <levi> If you are comfortable using monads in Haskell, then I wouldn't worry too much about whether or not you 'understand monads'. If you have a burning desire to learn more about them, though, we'll be happy to help.
23:13:43 <rhovland> I suppose just do everything in haskell inside "
23:13:51 <rhovland> do" blocks, b/c then you'll be using monads
23:14:06 <sssilver> levi that sounds extremely reasonable
23:14:24 <montanonic> yeah that's definitely the best approach, levi 
23:14:36 <julianleviston> If you want to understand monads, you need to see over and over, the use-cases where they make things useful by doing things “the longer way” first…
23:14:44 <julianleviston> a lot
23:14:44 <naudiz> I still don't understand what hand waving is ._.
23:15:14 <montanonic> precisely. I think the idea of *getting* monads is as much a fallacy as *understanding programming*; you just get better.
23:15:17 <julianleviston> it’s the same problem as “why would I ever want to use a higher order function?”
23:15:17 <sssilver> naudiz what I understand is that it's Douglas saying things without showing that they're actually right in a mathematical sense
23:15:21 * ReinH goes and replaces things like 1 with do 1 so he can use more monads
23:15:28 <levi> naudiz: Hand waving is distracting someone away from the fact that you can't actually show what you're saying is correct.
23:15:31 <MarcelineVQ> naudiz: It's when you dismiss or gloss over something difficult and don't return to it
23:15:35 <julianleviston> ReinH: might have missed my point :P
23:15:47 <montanonic> I feel like I totally understand recursion. But sometimes I see a mutually recursive set of functions that makes me feel like I know nothing all over again.
23:15:49 <ReinH> julianleviston: was responding to rhovland
23:15:58 <julianleviston> ReinH: ahaha apologies. :)
23:16:02 <naudiz> so, hand waving is like teaching at a school?
23:16:11 <MarcelineVQ> naudiz: oh yes
23:16:18 <levi> The term comes from academia
23:16:40 <naudiz> okay, thanks
23:17:16 <levi> When you're skipping over all the details and rigor that supposedly led to your result, you're hand-waving.
23:17:16 <julianleviston> monochrom: you can probably use higher order functions as an example, or even addition / multiplication “Why would I want to use multiplication? I can just use (+)!”
23:18:07 <julianleviston> monochrom: until you can implement monads, you probably shouldn’t learn them. (Other than to sequence things in IO, perhaps, but even that is reasonably debateable)
23:18:43 <julianleviston> monochrom: then you probably just need more practice doing recursion!
23:18:47 <naudiz> levi: is referring to another source also considered to be hand waving? e.g. not deriving the Schrödinger equation, but referring to a paper about it.
23:19:21 <levi> naudiz: No, that's just citing a reference.
23:19:30 <MarcelineVQ> Only if someone's asked you about how that works, you're supposed to know, and you tell them to just go read the paper.
23:19:36 <MarcelineVQ> *they're supposed to know
23:19:47 <MarcelineVQ> wait that was right then​I made it wrong
23:19:48 <ReinH> julianleviston: I assume you aren't telling monochrom how to learn monads?
23:19:51 <kadoban> naudiz: I'd say not really, as long as the other source actually directly answers whatever questions aren't being directly resolved.
23:19:55 <julianleviston> ReinH: correct.
23:20:00 <julianleviston> ReinH: I’m agreeing with him about stuff.
23:20:03 <julianleviston> naudiz:  lol otherwise everyone would be reinventing the wheel every time anyone wanted to make a car!
23:20:10 <ReinH> julianleviston: monochrom hasn't said anything
23:20:17 <rhovland> I remember reading (and implementing) something about monad transformers that helped me a lot
23:20:19 <kadoban> If it's something like "learn all of this, study for a few weeks and meditate on top of a mountain and you'll come up with it", then it's a handwave.
23:20:21 <ReinH> I think you're confusing him with montanonic
23:20:30 <naudiz> julianleviston: I'm just trying to understand when and why the word is used :)
23:20:39 <julianleviston> ReinH: I definitely am.
23:20:47 <naudiz> kadoban: so it's definately school xD
23:20:54 <julianleviston> naudiz: which word? monad?
23:21:10 <montanonic> wait, was someone intending to talk to me?
23:21:15 <naudiz> julianleviston: "hand waving"
23:21:28 <julianleviston> aha :)
23:21:32 <montanonic> oh! okay
23:21:33 <julianleviston> montanonic: I’m not sure :)
23:21:34 <rhovland> oddly I can't find it with google... hmm.. transformers.hs
23:22:26 <levi> Sometimes people who are hand-waving *could* be rigorous, but they assume that they're speaking with someone who also understands so they just gloss over it.
23:22:57 <montanonic> julianleviston: hah :), I agree with what you've said having now looked over the posts, if that means anything 
23:23:09 <julianleviston> montanonic: :)
23:23:14 <julianleviston> montanonic: soz.
23:23:27 <montanonic> julianleviston: no prob :>
23:25:43 <montanonic> Anyways, being able to say "this works this way" and intuiting it are two drastically different things, in which the latter usually demands far more knowledge. I highly encourage the avoidance of terms like "I understand X" in reference to a lot of things in Haskell because they encourage a fallacies about how one acquires knowledge and what it means to understand. my $0.02 as someone who's only Haskelled for a couple months.
23:26:02 <julianleviston> montanonic: monad tutorials either use straw man setups, or talk abstractly when they really need to begin with a set of concrete, actual problems… and then show how they solve those problems elegantly…
23:26:40 <montanonic> julianleviston: indeed; and then, at the end, offer a few open-ended exercises/projects where a person implements Monads and uses them, from the ground up
23:26:51 <montanonic> I learn so much just from trying to implement standard library stuff.
23:26:53 <julianleviston> montanonic: BINGO
23:27:02 <julianleviston> montanonic: oh god yes… and reimplementing it
23:27:25 <montanonic> julianleviston: and, of course, only *after* you learn how to work with Functors and Applicatives, doing the same thing.
23:27:26 <julianleviston> montanonic: that’s really what the “you could have invented… monads” post was attempting, but it didn’t go too well IMHO
23:28:50 <montanonic> julianleviston: yeah, I think the key is to recognize that these things really take time, and both encourage people that "yes, you can learn this", but also to convey that it's going to take time, and that you need to actually work with things yourself.
23:29:10 <julianleviston> montanonic: I don’t think they take time. They take work.
23:29:28 <montanonic> julianleviston: yes! indeed
23:29:54 <montanonic> And it's easy to forget that once you've become comfortable with something yourself.
23:30:04 <montanonic> Hence the paradox of instructing others.
23:31:18 <montanonic> julianleviston: are there any resources you've come across that you really got a lot out of? This could anything really, even some Haskell library.
23:31:21 <julianleviston> montanonic: sure…. and then there’s the interesting divide between understanding / having had to deal with the ideas and concepts (which all programmers actually already do), and seeing them where they appear in practice (not easy), and learning how they work in a particular language (requires practice).
23:31:45 <montanonic> Hah, so true as well. Lots of layers of knowledge. Very good points.
23:31:46 <julianleviston> montanonic: hutton.
23:31:51 <montanonic> the book?
23:31:56 <julianleviston> montanonic: he’s an author
23:31:58 <montanonic> his* book
23:32:08 <julianleviston> montanonic: he’s written a few
23:32:31 <montanonic> julianleviston: which do you recommend, and for what level of profeciency in Haskell do they correspond?
23:32:41 <julianleviston> montanonic: I’m a noob at Haskell.
23:32:59 <montanonic> Likewise
23:33:03 <julianleviston> montanonic: montanonic but I find his stuff beginner to reasonable level. 
23:33:21 <montanonic> julianleviston: okay, well good to know; thank you!
23:33:24 <adas> can someone please tell me what are type level literals? the ghc 7.10 doc is confusing. I also see them being used in servant
23:33:37 <levi> I thought his 'Programming in Haskell' book was good.
23:34:33 <julianleviston> adas: this should help: https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/type-level-literals.html
23:35:49 <adas> julianleviston: i just read that and was confusing. so does it essentially mean if I have fn :: Symbol "sup", then the function fn can only be called with "sup"?
23:35:51 <julianleviston> montanonic: also if you haven’t read the marlow book, that’s pretty ace...
23:35:56 <julianleviston> montanonic: http://chimera.labs.oreilly.com/books/1230000000929/index.html
23:36:38 <montanonic> julianleviston: oh awesome! I wasn't going to touch that until later because I assumed it required a lot of haskell knowledge?
23:36:51 <julianleviston> adas: oh sorry I don’t understand them at all - I was just finding you a definition of them!
23:37:02 <MarcelineVQ> nah montanonic it's actually explains a lot of basic concepts on its own, and very well too
23:37:20 <montanonic> MarcelineVQ: it looks like the topics it spans are really impressive
23:37:21 <montanonic> too
23:37:38 <adas> all these extensions make haskell more complicated
23:37:54 <montanonic> Thanks for the recommendation; I'm definitely going to spend time with it; looks great.
23:38:04 <Axman6> montanonic: that book is incredibly accessible, I can't recommend it highly enough
23:38:18 <julianleviston> MarcelineVQ: agreed… if you don’t get caught up by some of the stuff too much it’s actually a pretty good slightly above beginner book - great to understand how thunks work, for example.
23:38:24 <julianleviston> Axman6:  same!
23:38:44 <montanonic> Axman6: awesome! I found RWH to be too much for me, so I've just assumed that other stuff was like that.
23:38:51 <montanonic> As far as Haskell books are concerned.
23:38:59 <julianleviston> montanonic: it’s one of the best written programming books I’ve read.
23:39:10 <montanonic> julianleviston: wow, I'm shocked no one had mentioned it until now
23:39:25 <montanonic> julianleviston: I found it on my own when I was doing broad searches for books in Haskell
23:39:33 <montanonic> hadn't heard it mentioned since until now; 
23:39:38 <julianleviston> montanonic: RWH isn’t written well… in fact one of the authors is marlow’s “mentor” at Facebook (If they’re still there), and he admits hes’ a better writer than him
23:40:08 <julianleviston> montanonic: well, the subject area isn’t particularly “beginner friendly” ;-) interest-wise.
23:40:37 <julianleviston> montanonic: marlow wrote a lot of the concurrency parts of GHC
23:40:40 <montanonic> julianleviston: I was with it up until Chapter 5 and onwards, then we started defining things in very odd orders and it was super hard to follow even when I was going step-by-step; anyways, thanks for your feedback on the Marlow text
23:40:57 <montanonic> julianleviston: wow, I'm super extra hype now
23:41:01 <montanonic> :)
23:41:17 <Axman6> RWH makes a better reference than a book you read from start to finish
23:41:20 <julianleviston> montanonic: yeah, if you can get through the bits that are awful, RWH is great. It’s also an excellent reference.
23:41:35 * julianleviston hi5s Axman6
23:41:51 <julianleviston> montanonic: the comments actually help a LOT.
23:41:57 <montanonic> yeah, they do
23:41:58 <julianleviston> montanonic: so glad they put them in there, TBH
23:45:30 * hackagebot wai-routes 0.9.0 - Typesafe URLs for Wai applications.  https://hackage.haskell.org/package/wai-routes-0.9.0 (AnupamJain)
23:46:30 <julianleviston> Hm… what we really need is DYNAMIC typesafe URLs.
23:47:12 <dramforever> btw that bitemyapp haskell book looks interesting, although it's not finished yet
23:47:35 <rhovland> dramforever: almost certain the book exists
23:47:46 <julianleviston> rhovland:  ;-) lol
23:47:50 <julianleviston> rhovland: nice.
23:48:46 <dramforever> rhovland: um...yeah early access...or is there a finished one available to the general public already and the site doesn't mention it?
23:51:38 <kadoban> Naw, it's not even done yet. They're still working on it. They release new bits every month or so it seems.
23:52:18 <julianleviston> FYI this tells you what’s done / not / what will be http://haskellbook.com/progress.html
23:55:06 <julianleviston> I haven’t seen a beginner Haskell book that strikes me as any good yet, really.
23:55:30 * hackagebot postgresql-simple 0.5.0.0 - Mid-Level PostgreSQL client library  https://hackage.haskell.org/package/postgresql-simple-0.5.0.0 (LeonSmith)
23:55:33 <julianleviston> not that I’ve read all programming language books by a log shot, but I haven’t come across a nice one yet.
23:56:21 <julianleviston> There’s a possible exception…: https://pragprog.com/book/dswdcloj/web-development-with-clojure
23:56:38 <julianleviston> Not really a beginner book tho...
23:57:51 <dramforever> also I was wondering if I should actually buy it, because I already know some haskell, but it I'm not familiar with testing (because actually I've never done any real work with haskell), foldable, traversable (never really used these three), parsers (parsec is kinda hard...) and non-strictness and efficiency (again, no real work experience)
23:58:17 <dramforever> tl;dr I find 5 announced chapters promising
23:59:07 <montanonic> dramforever: not to dissuade or promote it, but if you want to get comfortable with typeclasses like those, (1) try making instances of them with a data structure that you make up, (2) try implementing them.
23:59:35 <montanonic> Foldable and Traversable are exactly what I'm working on learning right now, and actually making instances of them is *so* helpful.
