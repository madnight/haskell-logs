00:00:01 <glguy> and passing extra arguments
00:00:07 <srhb> Right.
00:00:08 <Hafydd> julianleviston: well, in this case it would depend on the context of what you're going to do with the result.
00:00:11 <julianleviston> srhb: oh ok… well, in that case, if I’m just using pattern matching, I can do it just fine.
00:00:17 <julianleviston> Hafydd: cool beans
00:00:21 <srhb> julianleviston: Good, then there's nothing you can't do! :-)
00:00:39 <julianleviston> srhb: except understand what’s going on whenever I see most Haskell code! :) yay!
00:01:02 <srhb> OK, perhaps I am trivializing things a bit.
00:01:25 <julianleviston> srhb: I’m trying to get to the point where I can understand monads, so I can understand how ((->) r) forms a monad so I can understand state monad so I can understand lens so I can understand Snap so I can build my web app :)
00:01:29 <julianleviston> srhb: hehe :)
00:01:30 <srhb> It's just that your complaint was "I can't do anything non-simple" in Haskell.
00:01:48 <julianleviston> srhb: oh I can do things! :) I know tricks :)
00:02:14 <srhb> Right, let's leave that be. You already know my opinion on learning all those details and whether they are necessary for building a web app. :P
00:02:15 <julianleviston> srhb: I just feel like “basic things like let and where” are beyond my ken, which is a little infuriating at times, especially when everything I want to read about uses them liberally.
00:02:23 <srhb> That's understandable.
00:02:56 <Hafydd> julianleviston: have you read the Haskell Language Report? It gives their syntax and semantics exactly.
00:03:15 <montanonic> julianleviston: write more code, at some point it will be clear that you can't do what you want to do unless you make two different functions; at that point, you'll see at least one use of let and where
00:03:23 <julianleviston> Hafydd: having read it doesn’t mean I understand it tho hmmm :)
00:04:31 <julianleviston> montanonic: I don’t follow that, sorry.
00:04:56 <montanonic> julianleviston: are you using a tutorial?
00:05:02 <julianleviston> montanonic: not at present
00:05:14 <julianleviston> montanonic: I’ve read various books, though… and read numerous tutorials in the past
00:05:28 <montanonic> julianleviston: okay, gotcha; do you write code to solve exercises?
00:05:39 <julianleviston> montanonic: no… got any good ones?
00:05:53 <montanonic> julianleviston: okay, so until you do that, I promise you that you will learn at a snails pace, and yes I do
00:06:01 <montanonic> https://github.com/bitemyapp/learnhaskell
00:06:01 <Hafydd> That would be your problem!
00:06:01 <julianleviston> montanonic: you mean like RWH ?
00:06:22 <montanonic> julianleviston: very much no; RWH is very dense and hard for anyone who isn't pretty damn comfortable with Haskell
00:06:31 <montanonic> julianleviston: I tried it. I did not like it at all.
00:06:35 <julianleviston> montanonic: do you mean yorgy’s?
00:06:51 <julianleviston> montanonic: I found RWH reasonable most of the time.
00:06:58 <julianleviston> montanonic: just a bit too boring
00:07:01 <liste> I learned haskell thru RWH and was comfortable with it, but ymmv
00:07:13 <liste> everyone learns their own way
00:07:16 <montanonic> julianleviston: yes, his is very good; and then just ask #haskell-beginners if you need help
00:07:19 <julianleviston> liste:  indeed!
00:07:31 <julianleviston> montanonic: I had no idea there was a haskell-beginners
00:07:47 <montanonic> liste: fair points; I'm new to programming in general so that may contribute heavily
00:08:20 <liste> yeah, I've been programming since 12 so it's a bit different
00:08:26 <montanonic> julianleviston: it's great! So work on exercises, and then check Stackoverflow if you get stuck, and then ask haskell-beginners if there's nothing on SO
00:08:30 <julianleviston> yeah… 8 here! :)
00:08:39 <julianleviston> so I should solve the problems in yorgey’s is a good idea?
00:08:47 <srhb> julianleviston: cis194? Absolutely
00:08:55 <julianleviston> ok I’ll go do them and come back later
00:08:58 <montanonic> julianleviston: yes, very
00:09:09 <srhb> See you in a few weeks ;)
00:09:10 <montanonic> julianleviston: then try NICTA afterwards
00:09:15 <montanonic> ^
00:09:37 <julianleviston> CIS194 is actually how I learned haskell btw
00:09:49 <dibblego> julianleviston: NICTA/course is run in Sydney right now.
00:09:49 <julianleviston> but I didn’t do the exercises. Silly me :)
00:09:58 <julianleviston> dibblego: oh. I live in sydney
00:10:08 <dibblego> julianleviston: I don't, but I am here at the moment running FP course.
00:10:13 <dibblego> day 3 is tomorrow
00:10:20 <Hafydd> Well, I've been programming since I was 4.
00:10:29 <julianleviston> Hafydd: ok
00:10:56 <julianleviston> Hafydd: When I say programming, I mean typing BASIC into a commodore 64… and modifying sprites and whatnot… 
00:11:27 <julianleviston> dibblego: is it for a uni?
00:11:37 <dibblego> No, for NICTA, for fun.
00:11:39 <Hafydd> julianleviston: not really. I was just continuing the arithmetic progression.
00:11:41 <dibblego> $0
00:11:59 <julianleviston> dibblego:  oh ok.
00:12:10 <glguy> dibblego: USD?
00:12:52 <julianleviston> dibblego:  is it a beginner course?
00:13:01 <dibblego> julianleviston: yes, it assumes some programming experience
00:13:09 <dibblego> today we wrote monad instances and implemented sequence
00:13:15 <julianleviston> dibblego:  I have quite a lot of programming experience! :)
00:13:26 <julianleviston> dibblego: ah ok cool…
00:14:02 <julianleviston> dibblego:  how does one go to it?
00:14:18 * hackagebot sbp 0.50.5 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-0.50.5 (markfine)
00:14:34 <dibblego> julianleviston: https://www.nicta.com.au/event/nictas-introduction-to-functional-programming-sydney/
00:14:39 <dibblego> just come
00:16:26 <julianleviston> oh…?
00:17:52 <julianleviston> where is it?
00:17:58 <julianleviston> oh nevermind
00:18:02 <julianleviston> I’m an idiot
00:19:44 <julianleviston> I think what I need is practice, though.
00:19:48 <julianleviston> so I’ll go practice.
00:20:29 <jle`> happy haskelling :)
00:20:45 <julianleviston> jle`: oh hey man! :) 
00:20:59 <jle`> hi :D
00:21:44 <echo-area> Is there a convenient way of binding values inside vectors when defining functions?
00:21:59 <jle`> echo-area: what do you mean, exactly?
00:22:02 <jle`> what's the "inconvenient" way?
00:22:22 <jle`> (just to know what you're talking about so we can find the more convenient way)
00:22:53 <echo-area> jle`: E.g. with lists this is possible: f (x:y:z:_) = ...
00:23:17 <echo-area> I don't find such constructors for vectors though
00:23:41 <julianleviston> echo-area:  oh you mean pattern matching on them?
00:23:45 <echo-area> Yes
00:25:40 <jle`> you can kind of fake it with PatternSynonyms, I think...or you can use ViewPatterns and deconstructing functions like uncons, but they're not built into the library
00:27:15 <echo-area> jle`: Oh, thanks for the info.  I'll first done the work and check them out later
00:27:29 <echo-area> s/done/finish
00:28:54 <julianleviston> I gotta write myself a set of exercises.
00:30:13 <jle`> echo-area: fwiw i don't think it's something that is worth looking into that much.  one of the big powers of pattern matching on list constructors is that it's the "only" O(1) operation you can do to get items from lists, and it also tells you a lot about the strucure of lists
00:30:33 <jle`> (x:xs) is much better than ys !! 0, for example
00:31:31 <jle`> for vectors there isn't that intimate relationship with the structure of a Vector, and also any random access is the same amount of time
00:32:01 <jle`> but actually..who am i to judge what is worth and not worth doing, heh
00:32:46 <jle`> echo-area: if you just want to unsafely bind a bunch of names you can do [x,y,z] = map (myVec !!) [0,1,2] but people might get mad at me for suggesting that :)
00:32:54 <jle`> s/!!/!
00:34:48 <echo-area> jle`: The other value of using pattern matching, besides performance, is it can improve program structure, IMO.  Definitions using pattern matching are often cleaner than those don't use it
00:35:26 <echo-area> jle`: Perhaps I could also use toList
00:49:19 * hackagebot glue-common 0.4.3 - Make better services and clients.  https://hackage.haskell.org/package/glue-common-0.4.3 (seanparsons)
00:49:21 * hackagebot glue-core 0.4.3 - Make better services and clients.  https://hackage.haskell.org/package/glue-core-0.4.3 (seanparsons)
00:49:23 * hackagebot glue-ekg 0.4.3 - Make better services and clients.  https://hackage.haskell.org/package/glue-ekg-0.4.3 (seanparsons)
00:49:25 * hackagebot glue-example 0.4.3 - Make better services and clients.  https://hackage.haskell.org/package/glue-example-0.4.3 (seanparsons)
01:32:24 <ttt_fff> Text.ParserCombinators.Parsec.Language 
01:32:24 <ttt_fff> this does not support indentation sensistive parsing, does it?
01:32:27 <ttt_fff> how can I get indentation sensistive parsing?
01:38:19 <sopvop> why HashMap is not instance of Hashable?
01:38:41 <tdammers> because you hash the keys, not the entire thing
01:38:59 <tdammers> you can have :: Hashable a => HashMap a b
01:39:12 <tdammers> which cannot possibly have a derived Hashable instance
01:39:34 <jle`> how about instance (Hashable a, Hashable b) => Hashable (HashMap a b)
01:40:01 <sopvop> jle`: yeah, that's what I was thinking
01:40:19 <ChristianS> sopvop: but why would you want to hash a hashmap?
01:40:47 <jle`> maybe it'd be nice to have nested hashmaps
01:40:48 <sopvop> ChristianS: because Shake wants all it's cachable values to be hashable :P
01:41:01 <sopvop> I'll just use Map
01:41:10 <sopvop> if it is hashable...
01:41:20 <ChristianS> sopvop: same problem, i'd suppose
01:41:46 <sopvop> nope it does not :(
01:41:49 <sopvop> it is not
01:42:02 <jle`> time to write some orphan instances :|
01:42:21 <sopvop> Hm, If I get two equal HashMaps different ways, will it produce same lists with toList?
01:43:15 <ChristianS> sopvop: Map is ordered, but HashMap isn't, so I wouldn't bet on it
01:43:47 <sopvop> jle`: newtype all the things!
01:44:43 <tdammers> I think the most robust solution would be newtyping, or even explicitly converting your map to something hashable
01:46:19 <sopvop> like hashWithSalt s . sortBy (comparing fst) . toList? :O
01:51:49 <fishburne> I am trying to use the 'download' package in my program, (https://hackage.haskell.org/package/download). I am using stack. When I build, it errors out with "Not in scope: `unsafePerformIO'" . Here is the complete build output. http://lpaste.net/141102
01:53:26 <merijn> edwardk: Ping? :)
02:03:21 <tennix> i just build yesod quickstart project, and find that the generated executable file is 58M
02:06:53 <liste> tennix the Haskell libs are statically linked
02:06:53 <merijn> tennix: Is there any specific reason that's a problem? (Also, did you build with debug symbols?)
02:07:21 <liste> so the executable contains all of Yesod, among other things
02:07:29 <liste> (IIRC)
02:07:38 * merijn is always confused why people seem to care about binary sizes for stuff that don't run embedded systems...
02:08:29 <tennix> even the templates and static files?
02:09:16 <merijn> Not sure about the static files, the templates are, afaik (they were when I last looked at Yesod anyway)
02:11:27 <tennix> ok, that makes sense
02:16:19 <dmwit> cmccann: I chuckled over "as far as I know, 100% of the users support this change"
02:16:28 <tennix> yes, deployment only needs three sets: static and config folders and the executable file
02:17:27 <tdammers> I tend to compile static files into the binary for production builds
02:18:20 <tdammers> faster to serve from RAM than from disk, more reliable, more secure (can't accidentally serve malicious content that someone has managed to upload), easier to deploy
02:18:31 <tdammers> downside is of course that this won't work with CDNs
02:18:44 <merijn> AMP and FTP were 7.10, right? (I don't have 7.8 atm and I'm trying to fix some sloppy code)
02:19:42 <cocreature> yep
02:19:49 <kadoban> merijn: Yes, though I believe there was some leadup that was active at least in 7.8 if not earlier, like a warning about AMP possibly?
02:20:10 <merijn> kadoban: Yeah, but I need to add conditional imports to fix trifecta
02:21:20 <lpaste_> ruslantalpa pasted “combine filters” at http://lpaste.net/141104
02:21:24 <dmwit> sopvop: You might like to start reading at 19:31:43 here: http://tunes.org/~nef/logs/haskell/15.04.19
02:21:57 <dmwit> sopvop: tl;dr HashSet's toList does not respect (==), but easily could with a small change. Presumably the same is true of HashMap.
02:22:12 <dmwit> sopvop: Ignore all the idiots that didn't agree with me. ;-)
02:23:31 <lpaste_> ruslantalpa revised “combine filters”: “combine filters” at http://lpaste.net/141104
02:23:49 <merijn> how do I nuke a single package from a sandbox?
02:24:10 <indiagreen> cabal sandbox hc-pkg unregister packagename
02:24:24 * hackagebot graphql 0.2.1 - Haskell GraphQL implementation  https://hackage.haskell.org/package/graphql-0.2.1 (jdnavarro)
02:24:24 <sopvop> dmwit: thanks :)
02:24:26 <kadoban> ruslantalpa: I'm not sure how you want them composed? How should it behave?
02:25:02 <ruslantalpa> compose is not the right word i guess, i am thinking something like <|>
02:25:24 <ruslantalpa> if one function fails (Nothing) the other onw should try the input
02:25:38 <merijn> hmmm, how do I know which version bounds to pick for a dependency?
02:26:16 <dmwit> ruslantalpa: \x -> filter1 x <|> filter2 x -- ?
02:27:15 <ruslantalpa> i guess that is correct, anyway to do that without the inline function?
02:27:32 <dmwit> ?pl \x -> filter1 x <|> filter2 x
02:27:32 <lambdabot> liftM2 (<|>) filter1 filter2
02:27:38 <dmwit> Not that I recommend this.
02:28:11 <dmwit> ?unmtl ReaderT Int Maybe String
02:28:12 <lambdabot> Int -> Maybe String
02:28:18 <dmwit> That would probably work, too.
02:28:37 <ruslantalpa> probably that, but why not liftM2, is that bad?
02:28:47 <dmwit> Not bad, just...
02:28:52 <dmwit> More polymorphism is harder to read.
02:28:54 <kadoban> ruslantalpa: It's a bit … unreadable if you're not familiar with the trick.
02:29:41 <dmwit> "More polymorphism" isn't really the right property to complain about. But it's hard to say the property I mean.
02:29:48 <kadoban> ruslantalpa: (the trick being using ((->) e)'s Monad instance)     By the way, if you are going to do it, I think liftA2 is much more often used, it means the same thing there.
02:29:55 <dmwit> "Using operations which are more polymorphic, even though you mean their monomorphic version" or something like that.
02:30:04 <cocreature> if you can't figure out the @pl version yourself other people probably would have trouble understanding it
02:30:17 <ruslantalpa> perfect, got it, thank you (helpful community as usual :))
02:31:09 <echo-area> Is it good practice to use unsafePerformIO to initialize global defintions?
02:31:16 <merijn> echo-area: No
02:31:26 <echo-area> merijn: What is the alternative?
02:31:38 <Intolerable> it is occasionally necessary unfortunately
02:31:48 <Intolerable> but rarely the best solution
02:31:52 <merijn> Depends on the details of your usecase (mind you, I do use it occasionally, but it's certainly not good practice :p)
02:32:14 <dmwit> echo-area: Often, the alternative is "initialize things in main".
02:32:44 <echo-area> My use case involves a definition which, other than assigning when initialized, is considered a constant
02:33:10 <dmwit> Pass the value around manually or use a reader monad.
02:33:14 <bz> run it in ReaderT
02:33:18 <tdammers> ^ that's what I'd do
02:33:34 <Intolerable> can you initialize it twice?
02:33:53 <bz> initialize n+1 times just to be sure
02:33:55 <Intolerable> (for two different contexts, for example)
02:34:08 <echo-area> Okay, let me be very specific.  It is a local time zone.
02:34:15 <dmwit> As a bonus, your functions will be more honest about what inputs their outputs actually depend on, instead of having a subtle bug source hiding inside.
02:34:20 <Intolerable> don't initialize that
02:34:25 <Intolerable> pass a time zone aroudn
02:34:31 <srhb> echo-area: main = getTimeZone >>= myPureFunctionDependingOnTimeZone
02:34:36 <srhb> needs more return
02:34:38 <srhb> or print
02:34:40 <echo-area> But I got the idea of using a reader monad
02:34:40 <srhb> or something.
02:34:43 <bartavel`> fmap
02:34:49 <bz> ^ that needs to be a <$>
02:34:56 <bz> (flip <$>) even
02:34:59 <echo-area> Thank you all! :D
02:35:00 <Intolerable> <&>
02:35:06 <Intolerable> :t (<&>)
02:35:07 <lambdabot> Functor f => f a -> (a -> b) -> f b
02:35:08 <bz> :t (<&>)
02:35:09 <lambdabot> Functor f => f a -> (a -> b) -> f b
02:35:12 <bz> cool thanks
02:35:14 <dmwit> I really don't think fmap is an appropriate fix for srhb's blunder.
02:35:22 <srhb> No, not really.
02:35:45 <bz> pure fn, won't typecheck with (>>=)
02:35:50 <srhb> But I don't know what the program needs to ultimately do, so meh.
02:35:52 <dmwit> Probably renaming myPureFunctionDependingOnTimeZone to myIOActionDependingOnTimeZone is more appropriate. ;-)
02:35:58 <srhb> Yes.
02:36:16 <dmwit> bz: I didn't say it didn't need a fix. Just that fmap was the wrong fix. =)
02:36:50 <srhb> But what I wanted to convey was really something like.. getCurrentTimezone >>= theIOThingYourProgramDoes . yourPureThing -- or something like that. I hope that makes more sense.
02:36:52 <dmwit> I am tickled to learn of (<&>).
02:38:05 <srhb> I didn't know of it either. It makes sense, though, so of course it's there :P
02:38:11 <srhb> @index (<&>)
02:38:11 <lambdabot> bzzt
02:38:14 <srhb> Ah well.
02:38:37 <dmwit> :t (Control.Lens.Lens.<&>)
02:38:38 <lambdabot> Functor f => f a -> (a -> b) -> f b
02:39:46 <srhb> But of course.
02:39:48 <bz> what's @index?
02:39:58 <dmwit> A really crappy version of hoogle.
02:40:04 <srhb> Indeed. 
02:40:15 <srhb> @index fmap
02:40:15 <lambdabot> Data.Functor, Control.Monad, Prelude, Control.Monad.Instances
02:40:56 <dmwit> srhb: I agree with you a lot. If we're ever in the same city, we should hang out.
02:41:43 <srhb> dmwit: I think it's me that's agreeing with you a lot! :-P
03:24:27 * hackagebot R-pandoc 0.2 - A pandoc filter to express R plots inside markdown  https://hackage.haskell.org/package/R-pandoc-0.2 (CorentinDupont)
03:29:27 * hackagebot R-pandoc 0.2.1 - A pandoc filter to express R plots inside markdown  https://hackage.haskell.org/package/R-pandoc-0.2.1 (CorentinDupont)
03:36:02 <roelof> merijn:  I tried to do the roots problem with a Maybe. Is this what you mean :  http://lpaste.net/141108
03:39:18 <makalu> can I have a global extra-include-dirs setting with stack? If I edit ~/.stack/global/stack.yaml and then do stack init in my project directory, the local stack.yaml will not have extra-include-dirs.
03:42:34 <roelof> someone else who can give feedback to this solution : http://lpaste.net/141108
03:47:42 <fishburne> I am trying to use the 'download' package in my program, (https://hackage.haskell.org/package/download). I am using stack. When I build, it errors out with "Not in scope: `unsafePerformIO'" . Here is the complete build output. http://lpaste.net/141102
03:48:33 <Intolerable> don't use download
03:48:35 <Intolerable> it's ancient
03:52:50 <fishburne> Intolerable: What should I use instead?
03:53:00 <Intolerable> what are you trying to do?
03:53:19 <Intolerable> just load a file over http?
03:53:25 <fishburne> Intolerable: I want to download small files.
03:53:36 <Intolerable> what kind of files
03:53:41 <Intolerable> and what protocol
03:53:43 <fishburne> Intolerable: Subtitles
03:53:49 <fishburne> Intolerable: Http
03:54:12 <Intolerable> try http-client
03:54:17 <Intolerable> @hackage http-client
03:54:17 <lambdabot> http://hackage.haskell.org/package/http-client
03:55:45 <Intolerable> there are a few examples in the documentation
03:55:48 <fishburne> Intolerable: I use it already. But I am not sure I saw a function dedicated to file downloads.
03:55:51 <Intolerable> if you have any problems let us know
03:57:31 <makalu> how do I install a library I build from source with stack so that I can use it in other projects?
03:57:41 <makalu> "stack install" does not work
03:58:06 <makalu> (it doesn't appear anywhere in .stack)
04:02:07 <Intolerable> what are you having trouble doing?
04:02:25 <Intolerable> are you just downloading something to a file?
04:04:33 <marchi> quit
04:08:52 <makalu> answering my own question: add the relative path to the source in stack.yaml 'packages' value
04:25:42 <roelof> Hello, what is a good place to get feedback on code I wrote. I tried the haskell-questions on reddit but get not much respons. Maybe haskell-cafe Mailing list ? 
04:27:22 <HEGX64> Maybe: http://codereview.stackexchange.com/
04:29:06 <roelof> HEGX64:  thanks, that can be a good one ? 
04:29:58 <merijn> r/haskell and/or here?
04:30:47 <roelof> merijn:  thanks for the tip, I ask you one about a half hour ago about the roots one 
04:39:18 <Hakim> hi, am having a problem linking haskell finles together, as to say modules in Eclipse. I had a flag in the arguments component in run configurations but it mysteriously vanished. The flag was something -i blah blah
04:39:30 * hackagebot charsetdetect-ae 1.1 - Character set detection using Mozilla's Universal Character Set Detector  https://hackage.haskell.org/package/charsetdetect-ae-1.1 (Artyom)
04:39:34 <Hakim> but i dont remember what the details where as i copy pasted it from one website
04:41:33 <liste> Hakim are you using Cabal?
04:41:46 <Hakim> ya...using Cabal
04:44:15 <Gurkenglas> roelof, Maybe [a] with Nothing standing for [] is redundant in my opinion. Here's some refactoring. http://lpaste.net/141108
04:44:16 <liste> so you have your main module in main-is: and the other modules in other-modules: in your .cabal file?
04:44:30 * hackagebot charsetdetect-ae 1.1.0.1 - Character set detection using Mozilla's Universal Character Set Detector  https://hackage.haskell.org/package/charsetdetect-ae-1.1.0.1 (Artyom)
04:45:27 <h1fuelcell> j/part
04:45:32 <h1fuelcell> eep sorryh
04:51:57 <roelof> Gurkenglas:  thanks, instead of a case , can you use a where ? 
04:56:22 <Gurkenglas> You mean like this? http://lpaste.net/141108 sure but I wouldn't do it that way :P
04:56:30 <Gurkenglas> *roelof
05:00:14 <roelof> Gurkenglas:  that is what I mean, but why is the case better then the where  ? 
05:02:19 <Gurkenglas> It introduces less names, it is more readable to a seasoned haskell programmer because reading "case compare" tells you a lot about what kind of function is to follow, and I could say something about the comparison to 0 only being done once but I don't know how efficient compare is.
05:03:40 <roelof> oke, thanks for the explantion. In my next assignments I will try the case statement.  I have to find the number in between two numbers 
05:10:44 <merijn> Introducing less names is always good, because then you don't have to think of names :p
05:11:40 <roelof> merijn : thanks
05:12:00 <Freinn> hi!
05:12:16 <Freinn> I'm having problems using MonadRandom
05:12:55 <roelof> one question : what do yoiu experts think of this code : http://lpaste.net/141117
05:12:58 <Freinn> this is my code: http://lpaste.net/141118
05:14:58 <merijn> roelof: Hint:
05:15:01 <merijn> :t maximum
05:15:03 <lambdabot> (Ord a, Foldable t) => t a -> a
05:15:07 <merijn> hmm
05:15:12 <merijn> :t maximum `asAppliedTo` []
05:15:13 <lambdabot> Ord b => [b] -> b
05:15:54 <ski> roelof : no need for the brackets
05:16:43 <roelof> ski you mean in the second and thirt solution ??
05:16:58 <roelof> I used them because in the book they also be used 
05:17:05 <ski> in `maxFour2',`maxThree',`maxFour3'
05:17:17 <roelof> merijn:  sorry I do not get the hint 
05:17:24 <dramforever> merijn: hmm...looks like ghc doesn't optimize the list traversal away
05:17:38 <ski> also, perhaps you'd want to do decision tree for `maxFour1'
05:17:41 <merijn> dramforever: For maximum? Who cares for this example?
05:17:52 <ski> > maximum [1,4,2,8,5,7]
05:17:52 <dramforever> that's true...
05:17:54 <lambdabot>  8
05:18:27 <dramforever> roelof: just like you don't need the parens in 1 + 2 + 3 + 4
05:19:28 <ski> Freinn : you forgot to say what your problem was ..
05:19:53 <Freinn> ski The code is not compiling
05:20:18 <roelof> oke, I delete them and will try it as soon as I done with another assignment 
05:20:41 <Freinn> ski and I don't even understand the Rand monad cause is the first time I see it
05:21:46 <ski> Freinn : .. and the compilation error is ?
05:22:24 <ski> Freinn : `Rand (Maybe a) Int' looks weird. `Rand StdGen Int' is maybe what you're after ?
05:22:48 <ski> Freinn : perhaps you should tell us what the intended behaviour of `randomElt' is ?
05:23:01 <Freinn> nope
05:23:01 <Freinn> ok
05:23:22 <roelof> and the functions are all working 
05:26:32 <ski> Freinn, re
05:26:42 <merijn> I don't suppose there a way to use the fail/match trick from list comprehensions to build a generalised partitionEithers?
05:26:46 <jameseb> Freinn: the first parameter to Rand does have to be an instance of RandomGen if you want Rand to be an instance of MonadRandom
05:26:47 <merijn> :t partitionEithers
05:26:48 <lambdabot> [Either a b] -> ([a], [b])
05:26:50 <ski> Freinn_ ^
05:27:14 <roelof> Can this also be rewroten with case of : http://lpaste.net/141120
05:27:56 <pavonia> roelof: Yes, case () of _ | x == y ...
05:28:31 <Freinn_> jameseb okay, the tutorial means a Rnd type, but I don't know what type is that
05:28:34 <ski>   weakAscendingOrder x y z = x /= y && x /= z && y /= z
05:28:38 <Freinn_> so I've changed it to Rand
05:29:15 <jameseb> Freinn_: they may be different types...
05:30:06 <jameseb> A Hayoo search shows up Rnd types in various packages
05:33:00 <jameseb> Freinn_: okay, the CFLP Rnd looks closest to how the code uses it, but it's hard to figure out what it's supposed to be without knowing what you're trying to do here
05:33:03 <quchen> There is a thread on the mailing lists about GHC compilation results being non-deterministic. What introduces non-determinism here?
05:34:14 <quchen> Ah, nevermind, should have kept reading.
05:34:34 <Freinn_> jameseb sorry, I've checked the file in http://www.seas.upenn.edu/~cis194/extras/07-monads/HW07.hs and: type Rnd a = Rand StdGen a. So thank you for your time
05:35:13 <hexagoxel> hackage docs builder is broken/slow again? (was it ever working?)
05:35:19 <quchen> roelof: There's also the (very lightweight) MultiWayIf extension to do it with nicer syntax.
05:35:40 <hexagoxel> (multiple packages i looked at recently did not have docs)
05:35:52 <quchen> roelof: http://lpaste.net/141120
05:35:59 <jameseb> Freinn_: ah, okay, that doesn't explain the two parameters though
05:35:59 <hexagoxel> can we just tell maintainers to upload the docs? once set up, it is one additional command.
05:36:04 <roelof> guchen thanks 
05:36:30 <quchen> roelof: I think the "=" should be "->", forgot changing that.
05:37:10 <quchen> roelof: Here's the manual entry on it. https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#multi-way-if
05:38:27 <roelof> Another question : I have this assignment. But how can a function returns true or false and later on display a number when used with between x y z = x ? 
05:39:24 <zoug> hello, I'm trying to define an instance of the Num type class for "Stream Integer" that I have already defined and that works well (type containing only infinite lists of Integers). To do so this is my code, but it doesn't compile, and don't understand why: http://arin.ga/lviNm7. What ghci tells me is that I can't put "Num (Steam Integer)", but I really don't see how I could replace it by something else. Can
05:39:25 <zoug> you guys help me? Thanks!!
05:39:38 <Freinn_> jameseb original signature: randomElt :: Vector a -> Rnd (Maybe a)
05:40:54 <roelof> Sorry , you can find the text here : http://lpaste.net/141123
05:41:29 <jameseb> Freinn_: okay, that makes sense
05:41:41 <ski> Freinn_ : and you're trying to change the behaviour of it ?
05:42:32 <ski> zoug : tried `FlexibleInstances' ?
05:42:44 <ski> zoug : or even better, `instance Num a => Num (Stream a)' ?
05:43:46 <zoug> ski: yeah tried FlexibleInstances, but I only want to define it for Integers and not for any type (if possible)
05:44:13 <zoug> maybe this is related: http://stackoverflow.com/questions/8367426/why-cant-one-put-type-signatures-in-instance-declarations-in-haskell ski ??
05:44:15 <zoug> not sure
05:45:06 <Freinn_> ski no, now it worked xD thanks
05:45:10 <zoug> from what I understood, this means that I can't put the type sig of my negate and fromInteger f'n because that type signature is already part of the class definition of Num ?
05:45:14 <Freinn_> ski and jameseb thanks and bye
05:45:59 <zoug> (but the answer's old now so maybe things changed)
05:47:18 <ski> zoug : what is the actual error you got ?
05:48:47 <greymalkin> Anyone with JuicyPixel experience: I'm trying to change a raw ByteString (not from a format) of image data into an image. Having trouble with the (Word8 -> PixelBaseComponent Pixel8) portion. Any advice?
05:48:56 <roelof> merijn:  can you answer my last question ?
05:49:34 <merijn> roelof: What was your last question?
05:49:49 <roelof> Another question : I have this assignment. But how can a function returns true or false and later on display a number when used with between x y z = x ? 
05:49:51 <roelof> Sorry , you can find the text here : http://lpaste.net/141123
05:50:10 <zoug> ski: "illegal type signature in instance declaration" then my negate and fromInteger signatures
05:50:50 <ski> zoug : comment them out (or remove them), or turn on `InstanceSigs'
05:51:06 <merijn> roelof: That's not a question :)
05:51:52 <zoug> ski: oooh awesome it works
05:52:02 <zoug> ski: what's InstanceSigs though??
05:52:07 <roelof> merijn:  what is it then. I do not know if Im wrong or I found another error in the book 
05:52:37 <merijn> roelof: Your paste just has a type signature and statement?
05:52:41 <ski> zoug : enables writing type signatures for your definitions inside type class instances
05:52:42 <merijn> Anyway, I need to go to a meeting
05:54:07 <zoug> ski: awesome well that's exactly what I wanted
05:54:12 <zoug> thank you for your help!!
05:54:15 <roelof> someone else who can shine a light on this? 
05:55:20 <clrnd> roelof, hi, what is the problem?
05:55:20 <frerich> roelof: I see no question mark in your paste - what is the question?
05:56:44 <roelof> my problem is that according to the type signature it returns a bool. But when I look at how the function is used here  between y x z = x it returns a integer.
05:57:09 <roelof> I think this is a error. Am I right or do I overlook something ? 
05:57:18 <roelof> clrnd:  frerich  ^^^^
05:57:27 <frerich> roelof: The 'between' function yields a Bool -- and 'between y x z' yields a bool.
05:57:35 <frerich> roelof: The '= x' part belongs to the 'middleNumber' function
05:57:37 <clrnd> I didn't see the paste
05:58:04 <roelof> clrnd: http://lpaste.net/141123
05:58:07 <frerich> roelof: I.e. if 'between y x z' yields True, then middleNumber gives 'x'. Otherwise, if 'between x y z' yields True then middleNumber gives 'y'. Otherwise, middleNumber gives 'z'.
05:58:12 <dgpratt> is there a way to do a "cabal update" in a more manual fashion?
05:58:18 <dgpratt> at least the downloading part?
05:58:38 <dgpratt> something on my machine is causing problems for the download
05:59:33 <roelof> frerich:  oke, so I have to check in between if x is smaller then y and bigger then z  for the first one 
05:59:42 <elkorn> hello everybody. I'm getting the following error while running `cabal test`: http://sprunge.us/WZIS . Do you know what can be this caused by and what to do about it?
06:00:53 <elkorn> I'm running Arch Linux on kernel 4.1.6
06:02:28 <hexagoxel> dgpratt: have you tried `cabal update -v3`? it says the url (and the destination once it finished successfully.. it would be .cabal/packages/hackage.haskell.org/00-index.tar.gz)
06:03:18 <jack_> Hi everybody, I like to test my program with QuickCheck. Therefore I have to make an Arbitrary instance of my datatype (custom). The custom datatype looks as follows : data Form = Prop Name | Neg Form | Cnj [Form] | Dsj [Form] | Impl Form Form | Equiv Form Form. The type of Prop is Int. Currently I can generate Form instances with the following arbitrary instance: instance Arbitrary Form where arbitrary = do prop <- arbitrary return $ Prop prop.
06:03:32 <dgpratt> I'll give that a go as soon as the current attempt fails, thanks hexagoxel
06:03:36 <jack_> But this will obviously only generate Int's.
06:04:08 <roelof> frerich: so between has to test if a number is the middle number , Do I understand this well ? 
06:04:18 <jack_> I'm not quite familiar with the syntax to create instances of all constructor variants.
06:04:53 <yashinbasement> Hey guys how do i approach this type of problem https://gist.github.com/ynarwal/f02bd098738ee7dc46f7 , let's I need to find different font_color in the html
06:04:56 <jack_> Oops, I will make a paste out of it.
06:06:08 <lyxia> jack_: Generate an integer between 0 and 5 to select one of the variants and then recursively use arbitrary to fill in the fields
06:06:52 <jack_> I will make a paste out of it. Can you guide me into doing that?
06:06:57 <lyxia> jack_: oh, there's actually a combinator just for that
06:06:58 <jack_> Give me a second.
06:08:02 <jack_> http://lpaste.net/141124
06:08:02 <lyxia> jack_: oneof [Prop <$> arbitrary, Neg <$> arbitrary, Cnj <$> arbitrary, Dsj <$> arbitrary, Impl <$> arbitrary <*> arbitrary, Equiv <$> arbitrary <*> arbitrary]
06:08:23 <jack_> Wow, that looks so easy.
06:08:36 <lyxia> heh
06:08:36 <jack_> Let me test it, thank you so far.
06:08:56 <Intolerable> what's oneOf?
06:08:59 <Intolerable> asum?
06:09:27 <lyxia> Test.QuickCheck.oneof :: [Gen a] -> Gen a
06:09:45 <zoug> with a structure of the type, say, (Cons 0 (Cons 1 (Empty))), is it possible to assign a name to the whole thing, like I would do with a list? something like wholeThing@(Cons 0 (Cons 1 (Empty))) ? If so, how? gchi says "parse error" when I try that
06:09:49 <Intolerable> is it asum tho
06:09:52 <Intolerable> :t asum
06:09:53 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
06:10:03 <lyxia> uh
06:10:06 <Intolerable> :t asum :: [Gen a] -> Gen a
06:10:07 <lambdabot>     No instance for (Alternative Gen) arising from a use of ‘asum’
06:10:07 <lambdabot>     In the expression: asum :: [Gen a] -> Gen a
06:10:12 <Intolerable> oh
06:10:34 <ski> jack_ : perhaps use `sized' and `resize' to decrement the size on the recursive calls, and only use the `Prop' form if `size' is not positive
06:10:43 <yashinbasement> hey guys I missed my chance of getting answer :)
06:11:13 <lyxia> Intolerable: Gen doesn't have empty, but that seems pretty close otherwise
06:11:18 <ski> zoug : did you mean `wholeThing = Cons 0 (Cons 1 (Empty))' (with a `let' before, if in GHCi) ?
06:11:25 <jack_> @ski I don't know what that means, but I will definitely look it up. This code does compile, but it will hang at a certain point.
06:11:25 <lambdabot> Maybe you meant: wiki src ask
06:11:39 <Intolerable> lyxia: yeah that makes sense
06:11:42 <frerich> roelof: Right.
06:11:50 <jack_> @ski Maybe that is because of to much recursive calls?
06:11:50 <lambdabot> Maybe you meant: wiki src ask
06:11:57 <zomg> yashinbasement: your question was a bit vague. What exactly is it that you're having a problem with?
06:12:01 <frerich> roelof: between just tests if some number is between two others. middleNumber uses between to give the middle of three numbers.
06:12:20 <zoug> ski: no I meant when doing pattern matching in a f'n
06:12:28 <ski> jack_ : IRC custom is to add `:' or `,' after nick name, not prepend it with `@'
06:12:51 <zoug> something like f'n list@(a:b:c:[]) = ... which would be valid
06:12:52 <ski> (also, lambdabot will get confused)
06:12:54 <jack_> Ok, my bad. I'm sorry.
06:13:15 <ski> zoug : should work
06:13:29 <Intolerable> why doesnt adium have a "double-click to reply" option
06:13:36 <Intolerable> thats the real problem
06:14:04 <zoug> oooooooooooooooooh ok I found the mistake.... i tried assigning it to the variable A but I can't do that in Haskell
06:14:15 <zoug> replaced with a everything is perfect
06:14:34 * hackagebot persistent-postgresql 2.2.1 - Backend for the persistent library using postgresql.  https://hackage.haskell.org/package/persistent-postgresql-2.2.1 (FelipeLessa)
06:14:51 <roelof> oke, so it fails on 2 2 3 because then there is no middle number because in my opinion a middele number is x < y < z  
06:14:52 <yashinbasement> my question, actually don't know how to solve this type of problems, for example how many font_tag are there in the html
06:14:57 <yashinbasement> https://gist.github.com/ynarwal/f02bd098738ee7dc46f7
06:14:58 <lyxia> jack_: oh right I did not see your structure is recursive, that makes things more complicated :/
06:15:30 <jack_> Yeah, that inline thingy in IRC doesn't make it all that clear..
06:15:41 <Intolerable> lpaste it
06:16:13 <yashinbasement> gives me the int if I give you HTML , like countHtmlFont :: HTML -> Int
06:16:17 <roelof> yashinbasement:  do you use a framework? I ask this out of curiosiy 
06:16:23 <yashinbasement> nah
06:16:57 <frerich> roelof: I think you can always sort three numbers, and there will always be one in the middle. So there's always a middle number. So I'd go for x <= y <= z.
06:17:01 <yashinbasement> why , my question makes me to ask that
06:17:33 <DEA7TH> Can I pattern match on a heap's head? Or do I have to do this: solveUCS _ f _ = case bestState of (pattern) -> f \n where bestState = fromJust $ viewHead f
06:17:44 <roelof> frerich:  then it will be 2  with the number 2 2 3 
06:17:57 <DEA7TH> (replace pattern with something)
06:18:02 <jack_> lyxia: It has to generate a propositional logic formula.
06:18:05 <frerich> roelof: Right.
06:18:18 <frerich> roelof: And indeed - 2 is in the middle. Right of 2 and left of 3. :)
06:18:32 <jack_> lyxia: Maybe I need to set a maxDepth somewhere, would that be a good idea?
06:18:51 <roelof> I can live with that but my feeling is that there is no middle number 
06:19:22 <circ-user-ZLh45_> then you would feel good about having 2 left numbers? :)
06:19:30 <dgpratt> hexagoxel, I tried 'cabal update -v3' but...I'm not sure what now
06:20:28 <roelof> I will try to implement that and go on learning haskell but the way things are mentioned is very confusing for me in this book. But I cannot find a better beginner book with a lot of exercises 
06:20:50 * frerich puts on his helmet for the inevitable flood of book references
06:21:30 <hexagoxel> dgpratt: have you downloaded the index manually?
06:21:35 <circ-user-ZLh45_> while some prepares that book link collection... I tried to cabal install idris today on a windows system and it failed. Is there any hope I can get it running?
06:21:46 <roelof> not needed 
06:21:53 <dgpratt> hexagoxel, no, but I can
06:21:58 <dgpratt> sorry, feeling dense
06:22:19 <dgpratt> caffeine hasn't kicked in yet
06:23:16 <dgpratt> hexagoxel, I don't see anything in the -v3 output that would tell me where it's trying to put the index
06:24:22 * roelof has not seen the book reference flood :) 
06:24:31 <jack_> How to make this always finite?: http://lpaste.net/141124
06:24:33 <clrnd> roelof, have you tried cis194?
06:24:37 <hexagoxel> dgpratt: that's why i included the path in my first reply (relative to the current user)
06:24:55 * roelof so frerich  can put his helmet of 
06:25:32 <clrnd> roelof, haskellbook by bitemyapp already has good reviews too
06:25:43 <hexagoxel> dgpratt: but indeed it is unfortunate that the -v3 does not include that information.
06:25:54 <roelof> clrnd:  yes, and I found out I have to little knowlegde to do this right. On week 2 I stuck on the tree structure 
06:25:55 <dgpratt> hexagoxel, so you did
06:26:09 <clrnd> roelof, what about LYAH?
06:26:35 <roelof> clrnd: I did not found exercises there 
06:26:45 <clrnd> true ...
06:27:32 <clrnd> #haskell-beginners must have more pointers
06:28:12 <roelof> clrnd:  I can ask there and look at the haskell book by bitemyapp 
06:28:22 <lyxia> jack_: I updated it
06:28:47 <circ-user-ZLh45_> would some sort of programming puzzle site not also help him? I mean towers of hanoi etc...
06:29:05 <delYsid`> Do I need to do anything special to allow unicode identifiers?
06:29:18 <jack_> lyxia: Thank you so much!
06:29:21 <delYsid`> Or do I remember incorrectly that Haskell supports writing code with unicode chars?
06:29:38 <tdammers> delYsid`: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#unicode-syntax
06:29:40 <quchen> delYsid`: You don't need anything special, and it does support it.
06:29:40 <clrnd> -XUnicodeSomething
06:30:03 <quchen> That's for unicode syntax for some reserved tokens.
06:30:06 <SK0> will OverloadedRecordFields land in next release?
06:30:17 <tdammers> yeah
06:30:18 <quchen> > let äüö = 2 in äüö
06:30:20 <lambdabot>  2
06:30:24 <tdammers> other than that, no extensions needed
06:30:27 <delYsid`> quchen: Strange, it doesnt work for me, but maybe I expect too much.
06:30:35 <quchen> delYsid`: What are you trying to do?
06:30:43 <tdammers> delYsid`: you cannot use just any unicode char you want
06:30:43 <circ-user-ZLh45_> um...noone knows if my idris problem is fixable? I really wonder if I should spend time on trying or simply give my ubuntu vm a larger hard disk...
06:30:49 <delYsid`> partialMeasure = sepBy partialVoice ⠐⠂ where ⠐⠂ = brl Dot5 *> brl Dot2
06:30:53 <tdammers> delYsid`: character ranges are relevant
06:31:11 <clrnd> that's just nasty
06:31:32 <delYsid`> clrnd: For me, it is native format :-)  I am sorry that you dont read braille :-)
06:31:56 <clrnd> ningún problema amigo
06:32:43 <delYsid`> so it doesnt work, and I gather people advise against doing so anyway :-)
06:33:16 <clrnd> > let ⠐⠂ = 5 in ⠐⠂
06:33:18 <lambdabot>  <hint>:1:1: parse error in let binding: missing required 'in'
06:33:38 <tdammers> unicode does work, but character ranges are relevant
06:33:45 <ski> @let middle x y z = maximum [min x y,min x z,min y z]
06:33:47 <lambdabot>  Defined.
06:33:50 <delYsid`> so Haskell hates Braille, then...
06:33:56 <tdammers> let ä = 23 in ä * 2
06:34:00 <ski> roelof ^
06:34:01 <tdammers> > let ä = 23 in ä * 2
06:34:02 <lambdabot>  46
06:34:15 <clrnd> sorry I forgot my unicode ranges man, I was up to UU65FG
06:34:18 <quchen> More importantly, Haskellers hate (code written in) Braille.
06:34:19 <dgpratt> hexagoxel, the location is a bit different on Windows, but I'm pretty sure I found it
06:34:33 <tdammers> Haskell doesn't hate Braille; Haskell just has rules about which ranges valid characters for identifiers must be from
06:34:40 <quchen> And any other character you can't type on a standard keyboard, for that matter.
06:34:44 <dgpratt> but there are two similarly named files in there, one .tar.gz, the other just .tar
06:34:47 <delYsid`> quchen: heh, how nice of you, thanks.
06:34:47 <circ-user-ZLh45_> only those who do not have haptic monitors where you can touch-feel the braille...
06:34:55 <dgpratt> do I only need to replace the first one?
06:34:57 <geekosaur> haskell doesn't like character sets without case
06:35:13 <delYsid`> geekosaur: That is an explanation!
06:35:15 <roelof> ski: thanks for your solution but the book and assignments want to do it another way 
06:35:37 <delYsid`> Of course, it would need to destinguish case for the datatype naming rule.
06:35:52 <ski> roelof : just another way of doing it, for fun
06:36:07 <delYsid`> OK, so I give up on this one, its only really useful for me anyway.
06:36:15 <circ-user-ZLh45_> okay - I give up with my question...no audience... toodles!
06:36:16 <ski> roelof : for more fun, try proving that it is equal also to `minimum [max x y,max x z,max y z]'
06:36:40 <ski> frerich : perhaps you'll like that ^
06:36:42 <geekosaur> although here it's worth checking whether the unicode consortium bothered to define letter vs. symbol for braille sensibly
06:36:53 <roelof> oke, I appreciate that. I think I can do this sorts of solution after chapter 5. That one is about lists and tuples 
06:36:56 <Intolerable> > unicode consortium
06:36:57 <lambdabot>  Not in scope: ‘unicode’Not in scope: ‘consortium’
06:36:58 <Intolerable> > sensibly
06:37:00 <lambdabot>  Not in scope: ‘sensibly’
06:37:01 <Intolerable> choose one
06:37:33 <tdammers> their task is kind of gargantuan, in their defense
06:37:39 <geekosaur> you could generalize that to "consortium" vs. "sensibly" and it's still be True :p
06:37:48 <Intolerable> yeah, fair
06:37:52 <hexagoxel> dgpratt: afaik the normal update process includes unpacking the .tar.gz to .tar
06:38:28 <geekosaur> dgpratt, it unpacks the tar.gz and builds an index for it
06:38:50 <roelof> I will work on Craft book and after a few chapters or the whole book I will try CIS 194 and NICTA 
06:38:51 <dgpratt> anyway to do that part manually?
06:38:58 <roelof> thanks all for the help 
06:39:03 <jack_> lyxia: I'm quite new to Haskell, but how do I pass the sized param into Arbitrary Form? If I do the call: sample ( arbitrary :: Gen Form )
06:39:17 <jack_> lyxia: Where does sized comes into place?
06:39:41 <dgpratt> I mean, build an index for the package db I just downloaded manually?
06:40:40 <dgpratt> btw, this describes my issue pretty well https://github.com/haskell/HTTP/issues/72
06:40:59 <dgpratt> but afaik, there is not a proxy in play here
06:42:33 <ski> jack_ : you use `sized' to get access to the current (implicit) size, like `sized $ \n -> do ..n..' e.g.
06:43:07 <ski> jack_ : use `resize' to (locally) change the current size, like `resize n $ do ...'. the changed size is only in effect in the `do ...'
06:48:51 <delYsid`> Whats idiomatic if I have input data which lacks certain info that I am going to calculate later?  Use a Maybe and initialize it with Nothing, or create two data structures, one for input, and one for the algorithm results which are basically identical except for the new field added to the output data struct?
06:49:34 <Intolerable> have two structures
06:49:45 <Intolerable> one with Maybes for each field
06:49:47 <Intolerable> one without
06:50:02 <hexagoxel> dgpratt: i think the index is automatically built when it actually needs it later.
06:50:10 <Intolerable> and then a RecordWithMaybes -> Maybe RecordWithoutMaybes function
06:50:16 <Intolerable> or rely on laziness, if you can
06:50:22 <dgpratt> hexagoxel, I'll try it, thanks
06:50:23 <Intolerable> there's also validation stuff if you want that
06:50:54 <hexagoxel> dgpratt: but you might still have to do the .tar.gz -> .tar unpacking step manually, not sure.
06:51:08 <delYsid`> Intolerable: Is there any way to deal with the resulting duplication?
06:51:29 <Intolerable> you mean having to write it twice?
06:51:35 <delYsid`> yeah.
06:51:44 <Intolerable> a couple of options
06:51:45 <ski> dgpratt : perhaps parameterize, using `Maybe' for the input and `Identity' for the output ?
06:51:47 <Intolerable> TemplateHaskell
06:51:51 <delYsid`> and change it in two places if I end up extending the basic structure
06:51:51 <Intolerable> or ski's suggestion, yeah
06:51:53 <ski> er
06:51:56 <ski> delYsid` ^
06:52:12 <frerich> ski: That's kinda neat (your minimum / max offer)
06:52:21 <Intolerable> you're gonna have to enable a bunch of extensions either way, tbh
06:52:46 <ski> frerich : next step, generalize and prove
06:53:02 <quicksilver> parameterising your type with an abitrary functor so you can do the 'Maybe' trick is a really nice thing
06:53:08 <quicksilver> it's a bit syntax heavy to use tho :(
06:53:30 <frerich> ski: Generalize for what - more than 3 numbers? What would a 'middle number' be for 4 values?
06:53:48 <delYsid`> I think you might have misunderstood me.  My input data does not have the field at all, and my output data will always have a value there.  I was only mentioning Maybe as a way tu fuse both data structures into one...
06:54:18 <frerich> ski: I see how it drops the smallest value from the set and then takes the minimum of that (which is no larger than the maximum and no smaller than the minimum, so it would be the middle) - but I don't know what you mean by 'generalization' here.
06:54:35 * hackagebot signal 0.1.0.3 - Multiplatform signal support for Haskell  https://hackage.haskell.org/package/signal-0.1.0.3 (PiotrMlodawski)
06:55:00 <Intolerable> delYsid`: data Record f = Record { field1 :: f Int, field2 :: f String }
06:55:02 <Intolerable> something like that
06:55:04 <ski> frerich : like `forall a,b,c,d. maximum [minimum [a,b,c],minimum [a,b,d],minimum [a,c,d],minimum [b,c,d]] = minimum [maximum [a,b],maximum [a,c],maximum [a,d],maximum [b,c],maximum [b,d],maximum [c,d]]'
06:55:24 <Intolerable> then you have Record Maybe for the possibly-uninstantiated one, and Record Identity for the validated one
06:55:52 <merijn> Man, why don't we have ApplicativeDo yet? :\
06:56:32 <delYsid`> Intolerable: Oh, I get it, thanks for the example!
06:56:34 <ski> frerich : given numbers `a_0,a_1,...,a_{n-1}' you compute new numbers `b_0,b_1,...,b_{n-1}' where `i |-> b_i' is increasing
06:57:40 <merijn> I have a "f a" and "f b" and now I have to do ugly things like "(,) <$> x <*> y" so I can gather both side-effects before continuing :\
06:58:57 * ski . o O ( reflective syntax )
07:04:00 <phadej> merijn: do you know how https://ghc.haskell.org/trac/ghc/wiki/ApplicativeDo#Trickycase works
07:04:22 <phadej> If I read the rest of the page, seems the (A | B) ; C variant is picked?
07:04:35 <merijn> No idea
07:19:54 <knotman> Hi guys I'm struggling using Data.Sequence. Has someone tried to implement mapM for Seq DataType?
07:20:23 <dgpratt> hexagoxel, it was rough going, but in the end I got what I needed -- thanks for the help
07:22:49 <quchen> knotman: Seq is traversable already
07:23:14 <merijn> Whooo! Made GHC crash
07:23:23 <quchen> You win one Haskell point
07:24:06 <knotman> quchen,  From hoogle docs yes looks traversable and foldable etc. When I ask ghci (:i Seq) it tells me it is not traversable and foldable
07:24:37 <quchen> knotman: For me it does. What GHC version are you using?
07:24:38 <merijn> And I don't even know why this time...
07:24:56 <Gurkenglas> knotman, what does it tell you about []?
07:25:09 <knotman> quchen, 7.6.3 Debian Wheezy
07:25:13 <quchen> Ah, you probably didn't import Foldable/Traversable.
07:25:17 <Intolerable> blegh
07:25:19 <quchen> :i only lists the instances in scope I think.
07:25:36 <quchen> Try ":m +Data.Traversable" and retry :i
07:26:20 <quchen> 7.6.3 is a somewhat dated compiler version; GHC 7.10 has Traversable in Prelude, so you can skip that import
07:26:30 <knotman> quchen, damn you're right!
07:27:12 <knotman> quchen, thanks a lot, I wasted 2 hours on this. shame on me
07:33:34 <sm> bitemyapp: shouldn't your blog be on planet haskell ?
07:33:54 <sm> I just found it and read eg http://bitemyapp.com/posts/2014-12-31-functional-education.html which is great - thanks!
07:34:36 <sm> looking forward to reading your review of the wikibook
07:46:39 <chpatrick> is there an inverse to Data.Map.splitLookup?
07:47:57 <quchen> chpatrick: mappend?
07:48:11 <quchen> map1 <> singleton k v <> map2
07:49:34 <chpatrick> is that as efficient though?
07:49:54 <chpatrick> can't see why not I suppose
07:52:45 <OutlawStar> hmm, anyone possibly know why a thread spawned with (Control.Concurrent.Async.async) from a gtk application  gets killed eventually, even though gtk is still running. If for example I were to wait on the async, it stays alive...
07:54:18 <quchen> chpatrick: Well, it's less efficient than building the Map yourself with the (unavailable) data constructors.
07:54:20 <Cale> OutlawStar: Does the result get GCed?
07:54:32 <OutlawStar> cale: the result of the async?
07:54:36 <Cale> OutlawStar: yes
07:54:36 <quchen> chpatrick: On the other hand, it works for any maps, and not just for "neatly partitioned" ones.
07:55:19 <quchen> chpatrick: union of two maps isn't the most efficient thing, so you shouldn't overdo it. It scales linearly with the sizes of its operands.
07:55:31 <chpatrick> yep
07:55:39 <chpatrick> I was just wondering about improving the lens interface to Map
07:55:50 <chpatrick> because right now it does lookup and insert
07:55:54 <OutlawStar> cale: the action performed on the separate thread handles receives from a network socket, so it never really completes. But eventually that separate thread gets a file descriptor error when reading from socket.
07:56:05 <OutlawStar> cale: so i'm guessing something gets gc'd...
07:56:06 <chpatrick> it would be nice to have a lens on the position in the map
07:56:08 <Cale> OutlawStar: You should not be using async for that
07:56:11 <chpatrick> but the constructors aren't exposed
07:56:30 <Cale> OutlawStar: async is *only* for asynchronously computing values that you care about
07:56:30 <nshepperd> I thought maps had an efficient union?
07:56:47 <OutlawStar> cale: ah ok, so should i be using fork os?
07:56:54 <Cale> OutlawStar: If you don't wait on the resulting Async value, then you should just have been using forkIO
07:57:10 <OutlawStar> cale: i thought forkIO was used by async?
07:57:10 <quchen> nshepperd: "efficient" can mean a lot of things.
07:57:18 <quchen> I guess it's "relatively efficient".
07:57:29 <nshepperd> certainly, you can find the minimum key of one and the maximum key of the other and /prove/ that they are disjoint in log(n) time
07:57:35 <Cale> Lots of stuff is used by async
07:57:47 <nshepperd> and then you should be able to just put them as subtrees of a new node
07:58:14 <nshepperd> er, s/disjoint/separable/ or something
07:58:20 <OutlawStar> cale: ok, well i will try basic forkIO, thx
07:59:38 * hackagebot git-annex 5.20150916 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-5.20150916 (JoeyHess)
07:59:54 <quchen> nshepperd: I'm not familiar with the hedge union algorithm, which Map supposedly uses.
08:00:12 <quchen> nshepperd: I'd have to read the paper.
08:02:59 <greg`> where does stack store its dependencies?
08:03:29 <clrnd> .stack/
08:03:59 <greg`> thanls
08:04:30 <clrnd> greg`, stack path
08:05:32 <chpatrick> is there a microlens that has Fold?
08:06:01 <nshepperd> ooh, looks like it might be able to do that
08:06:07 <chpatrick> I should say lens' fold with Contravariant
08:06:30 <OutlawStar> Cale: that didn't work
08:07:42 <bitemyapp> sm: sure, how do I add it?
08:07:47 <Cale> OutlawStar: So your forkIO'ed thread just vanishes?
08:08:05 <Cale> OutlawStar: How are you checking this exactly?
08:08:41 <OutlawStar> Cale: maybe I am misunderstanding what is happening: I get this exact error: recv: invalid argument (Bad file descriptor). 
08:09:11 <OutlawStar> Cale: At a high level I open an http connection that sends back HTTP chunks and i stream them through a conduit
08:09:24 <OutlawStar> Cale: while the conduit is running, eventually I get that
08:10:02 <Cale> OutlawStar: If you get that error, it probably means that the socket you were trying to recv on is closed.
08:10:52 <OutlawStar> Cale: But I'm wondering what closes that, since if i wait on that async (or did), the socket would not close.
08:11:18 <OutlawStar> Cale: If this helps: https://github.com/jm4games/lightstreamer/blob/master/src/Lightstreamer/Http.hs, line 101 is work I make the async. 
08:11:23 <l8star> hi
08:13:04 <Cale> OutlawStar: hmm, jeez, trying to think about how conduit interacts with this is going to get really interesting :)
08:13:34 <OutlawStar> it works, great when i wait on that async
08:13:36 <nshepperd> aha, it recursively splits the right map according to the key at the top of the left map, and then unions the subtrees. so in the seperable case, we just recurse down to the rightmost node of the left tree, and put the entire right tree there, then balance in log(n+m) time
08:13:41 <OutlawStar> but when i don't after about 7 sec it dies
08:14:39 * hackagebot snaplet-purescript 0.4.0.0 - Automatic (re)compilation of purescript projects  https://hackage.haskell.org/package/snaplet-purescript-0.4.0.0 (AlfredoDiNapoli)
08:14:53 <nshepperd> so, log(n)*log(m) for "naive" union of separable Maps I think
08:15:27 <Cale> OutlawStar: Right, well, not waiting on an async is a great way to have the thread which is computing its result killed.
08:15:56 <Cale> OutlawStar: asyncs exist to be waited on, and their associated threads are automatically killed by design if nothing is waiting on them any longer
08:15:58 <OutlawStar> Cale: But i would think as long as the run time is running, the thread would not die
08:16:12 <bitemyapp> sm: I read their FAQ and emailed them.
08:16:23 <Cale> (or rather if nothing has the option to wait on them)
08:16:23 <OutlawStar> Cale: fork io, does have anything but thread id, so why would that die?
08:16:56 <Cale> If you create it with forkIO, it should keep running as long as your program is otherwise running.
08:17:03 <Black0range> Hey i was wondering how `div` was implemented in haskell where can i find its source?
08:17:30 <Black0range> prelude only shows the class defenition
08:17:33 <OutlawStar> Cale: which didn't work, so I'm wondering if the thread getting GC'd is not actually the problem, maybe something is happening to the socket in the conduit?
08:17:33 <Cale> If the main thread of your program ends, then all the other threads do, but otherwise, forkIO'ed threads shouldn't just go away for no reason.
08:18:02 <Cale> Black0range: Well, it's implemented separately for each numeric type. Any particular type you're interested in?
08:18:46 <Black0range> any type would be fine really :) 
08:19:44 <tsahyt> Hello! How would I go about finding neighbor cells in a quad tree in Haskell? In an imperative language I'd just keep a pointer to the parent in each node and then "recurse upwards" through the tree, but as far as I understand I can't do that in Haskell. At least I can't without tying the knot, which introduces all sorts of problems on its own, because the structure is modified a lot.
08:20:09 <Cale> OutlawStar: If you're not using async, then it has nothing to do with the result being collected any more
08:20:44 <nshepperd> Black0range: for the built in numeric types like Int, Int32, Int64 etc I believe it's implemented as a primop (compiler magic)
08:20:49 <Black0range> Cale: just found the defenition for word... 
08:20:51 <OutlawStar> Cale: Hmm then I guess the trick is to figure out, why when you wait on the result the socket doesn't die, but when you don't it does
08:21:35 <nshepperd> Black0range: because it eventually gets compiled into an asm operation
08:21:43 <Black0range> uuuuh what does the # mean? https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Word.html#Word8
08:22:09 <geekosaur> Black0range, it means it's internal
08:22:22 <Cale> Black0range: It's conventional to name internal things with a trailing #
08:22:34 <Cale> Especially unboxed things
08:22:56 <Black0range> sweet
08:23:11 <quchen> Does MagicHash do anything besides promoting "#" to be a letter of sorts?
08:25:39 <lpaste_> Cale pasted “divInt# from ghc source” at http://lpaste.net/141133
08:25:53 <Cale> quchen: no, that's all it does
08:26:19 <Cale> quotInt# is a primop
08:26:21 <lyxia> tsahyt: Use a zipper for quad trees perhaps. https://wiki.haskell.org/Zipper
08:26:25 <SK0> it only allows you to use it at the end of the identifier
08:26:31 <SK0> to my great sadness
08:28:00 <SK0> I have a type Tone = A0 | A0# ...
08:28:01 <ryantrinkle> is there something like tree rotation distance, but where the leaves are labeled and may be reordered, as well?
08:28:12 <SK0> I would have preferred A#0
08:28:53 <ryantrinkle> e.g.: tree rotation distance lets me talk about ((a, b), c) versus (a, (b, c)), but i also want to be able to talk about ((a, b), c) versus ((b, a), c)
08:29:21 <tsahyt> lyxia: Thanks, I'll look into it!
08:29:35 <Cale> ryantrinkle: hmm :)
08:29:45 <geekosaur> SK0, I think I'd have skipped MagicHash for that and replaced # with '
08:30:19 <geekosaur> not as pretty but less magic and less likely to accidentally run into some internal thing you never heard of
08:32:02 <delYsid`> Its been a just a week since I came back to Haskell.  Would anyone mind to give my learning project a quick glance over?   I am going to write a Braille music parser / post-processor... Its here: https://github.com/mlang/hbmc/blob/master/Text/Braille/Music.hs  Let me know if I am doing something weird, or if you have any suggestions in general to a (re)learner... Thanks!
08:32:47 <Cale> ryantrinkle: I don't know if there's a term for it, but it definitely makes sense as an idea.
08:33:52 <pyrtsa> Tree permutation?
08:34:28 <stapler> Cale: do you have any familiarity with scotty?
08:35:11 <Cale> stapler: Not especially. I've answered questions about it here, but I haven't actually used it.
08:35:26 <stapler> do you think you could explain something to me regarding monads in scotty
08:35:30 <stapler> mostly a "why" question
08:35:32 <Cale> Perhaps
08:35:33 <stapler> let me pull it up real quick
08:35:40 <SK0> geekosaur, that's an idea too
08:36:01 <SK0> I also have a type like Note = A Int | A# Int
08:36:12 <SK0> this has some advantages other than being correct syntactically
08:36:30 <SK0> like supporting fictitious octaves
08:36:30 <stapler> Cale: so you know how you can put params in URLs and such
08:36:43 <stapler> heres the type of the function used to access it 
08:36:43 <stapler> param :: Parsable a => Text -> ActionM a
08:36:50 <SK0> but it has to be parenthesized for most uses
08:36:53 <stapler> my question is: why is this in a monad?
08:36:56 <SK0> which makes it less pretty
08:37:39 <Cale> ryantrinkle: Now you have me trying to picture a crazy thing with 120 copies of this all joined up by edges corresponding to commutation:  https://en.wikipedia.org/wiki/Associahedron#/media/File:Tamari_lattice,_ovals.svg
08:39:18 <geekosaur> SK0, not a lot can be done about the precedence of application being higher than anything else. some people define their own version of ($) which associates left instead of right; (|>) is somewhat common by analogy with F# (the .Net/CLR language)
08:40:01 <Cale> stapler: Because its result doesn't only depend on the Text parameter you give it.
08:40:04 <tdammers> how about €
08:40:34 <ryantrinkle> Cale: hahaha
08:40:41 <tdammers> $ associating to the right, € associating to the left, how beautiful do you want your mnemoics
08:40:43 <geekosaur> I suspect they'll want something that looks vaguely like it belongs in a music score...
08:41:35 <stapler> Cale: so ActionT is just like uh
08:41:39 <stapler> a way of chaining operations together?
08:41:45 <stapler> a monad foer that at least
08:42:36 <stapler> monad transformer but...
08:42:46 <SK0> geekosaur I appreciate that, the hash being at the end is not so morally incorrect anyhow
08:42:57 <Cale> stapler: That's the glib answer anyway -- it depends on some data which is available only when the ActionM action is being "run", i.e. when the steps described by an ActionM action are being carried out.
08:43:26 <stapler> right
08:43:27 <Cale> stapler: In particular, the parameters to the request are available as part of the data which is carried around by that interpreter.
08:43:40 <Cale> So, param just has too look up the given parameter
08:44:05 <stapler> so in this case is ActionM /actually/ like passing a struct around?
08:44:17 <carrotlord> error during MVar operation (??)
08:44:27 <carrotlord> ghc panic
08:44:56 <Intolerable> carrotlord: do an lpaste
08:45:21 <Cale> Yeah, the bit of code which turns an ActionM action into an IO action carries around a structure of a bunch of things which include a list of parameters to the request
08:45:23 <Cale> http://hackage.haskell.org/package/scotty-0.10.2/docs/Web-Scotty-Internal-Types.html#v:getParams
08:45:34 <Cale> One of these ActionEnv things
08:59:41 * hackagebot ihaskell 0.8.0.0 - A Haskell backend kernel for the IPython project.  https://hackage.haskell.org/package/ihaskell-0.8.0.0 (gibiansky)
08:59:43 * hackagebot ipython-kernel 0.8.1.0 - A library for creating kernels for IPython frontends  https://hackage.haskell.org/package/ipython-kernel-0.8.1.0 (gibiansky)
08:59:45 * hackagebot ihaskell-widgets 0.2.0.0 - IPython standard widgets for IHaskell.  https://hackage.haskell.org/package/ihaskell-widgets-0.2.0.0 (gibiansky)
09:10:41 <stapler> Cale: cool
09:17:54 <ocramz> hi all
09:18:18 <Intolerable> hello
09:18:18 <ocramz> anybody knows whether this has a name already? `test f (a, b) = f a >>= \x -> return (x, b)`
09:18:32 <samba1> How can I parse a string taking all but the last character, and then taking the last character, doing something with the first chunk and then the last. I can't figure it out, peekChar isn't enough
09:19:03 <samba1> using attoparsec, but interested in parsec as well
09:22:39 <Gurkenglas> ocramz, for "test f (a, b) = f b >>= \x -> return (a, x)" it would be "traverse f"
09:22:50 <Intolerable> there must be a Swap newtype or something for that
09:23:02 <ocramz> Gurkenglas: hmmm; what I need is a bit like `first` in Control.Arrow but with an arrow instead of a function
09:24:08 <byorgey> :t _1 :: Monad m => (a -> m a') -> (a,b) -> m (a',b)
09:24:09 <lambdabot> Monad m => (a -> m a') -> (a, b) -> m (a', b)
09:24:19 <ocramz> ooo it's a lens
09:24:21 <byorgey> ocramz: this function is called _1  from Data.LEns
09:24:27 <ocramz> thanks Brent!
09:24:32 <byorgey> sure!
09:24:34 <JannisLimperg> Hi everyone. I faintly recall a library/executable for expanding TH expressions into regular source code. Would anyone happen to know that package?
09:25:09 <Intolerable> --ddump-splices?
09:25:16 <byorgey> ocramz: if you look at the actual type of _1 you will see that it is actually much more general than that, though I don't particularly recommend it in this case =)
09:26:04 <byorgey> JannisLimperg: there was 'zeroth' but I don't think it is maintained anymore
09:26:08 <ocramz> yes I'd rather not import the whole lens package for this, but it's handy to know
09:26:22 <ocramz> I'll stash it in Utils.hs :D
09:26:23 <Gurkenglas> ocramz, https://hackage.haskell.org/package/microlens
09:26:40 <Intolerable> tbh when ur just redefining _1, you don't need any kind of lens library
09:26:53 <edwardk> byorgey: Control.Lens, Data.Lens called the equivalent fstLens or something =)
09:27:05 <lodin_> If I have a list of values of a sum type, and a function that only makes sense for some of them, should I return Maybe (and e.g. remove Nothings)? Or is it a sign of a design issue?
09:27:18 <Intolerable> depends
09:27:18 <ocramz> Intolerable: what do you mean?
09:27:40 <ocramz> Intolerable: (re: redefining _1 and similar)
09:27:51 <Intolerable> ocramz: if you just need _1, there's really no reason to import a whole lens library
09:27:57 <ocramz> agree
09:27:57 <Intolerable> regardless of how big said lens library is
09:28:04 <Intolerable> :t _1
09:28:05 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
09:28:14 <ocramz> :i Field1
09:28:20 <ocramz> no workey
09:28:28 <Intolerable> im trying to remember how to define it
09:28:30 <Intolerable> its p simple
09:28:53 <JannisLimperg> byorgey: Yes, that was what I meant, thank you. I'll look into whether it does anything useful.
09:29:55 <Intolerable> :t \f (a,b) -> fmap (\x -> (x, b)) (f a)
09:29:56 <lambdabot> Functor f => (t -> f t1) -> (t, t2) -> f (t1, t2)
09:30:09 <JannisLimperg> Intolerable: Good call, I forgot about -ddump-splices. Thanks.
09:30:17 <Intolerable> :t \f (a,b) -> fmap (, b) (f a)
09:30:18 <lambdabot> Functor f => (t -> f a) -> (t, t1) -> f (a, t1)
09:32:30 <samba1> How can I parse a string taking all but the last character, and then taking the last character, doing something with the first chunk and then the last. I can't figure it out, peekChar isn't enough
09:32:34 <samba1> using attoparsec, but interested in parsec as well
09:34:26 <ocramz> Intolerable: the last example you gave requires TupleSections
09:34:41 <Intolerable> the one before doesn't
09:34:46 <Intolerable> and does exactly the same thing
09:34:47 <ocramz> aye
09:34:57 <Intolerable> the tuplesections one just looks slightly nicer
09:35:40 <ocramz> ok, enough golfing :D back to work!
09:35:44 <ocramz> thanks all !
09:40:45 <JannisLimperg> samba1: For clarity: Are you looking for a parser (f :: Parser (String, Char)) where the pair's first element is the string prefix and the second is the string's last char?
09:44:20 <samba1> JannisLimperg: sure, that's a simple example
09:44:52 <samba1> do I have to use the length of the input from the start?
09:45:05 <samba1> or can I parse and then backtrack when suddenly I'm at the last character
09:47:11 <JannisLimperg> samba1: If you don't care much about performance, you could write a function (splitLast :: String -> Maybe (String, Char)) which splits off the last char from a string. Then suppose you have a parser p that parses the entire string, (fmap splitLast p) does what you want (except for handling the Maybe).
09:48:06 <JannisLimperg> samba1: If you do care about performance, things become a bit more tricky.
09:48:27 <dgpratt> is there a known issue with how stack deals with flags in .cabal files? or has anyone encountered issues relating to the same?
09:49:11 <samba1> well, I'm not dying for performance, I just figured there was a better way, so the parser reads more like what it does
09:49:14 <samba1> but I guess that's fine
09:49:45 <dgpratt> I see that "snap init" creates a .cabal file with reference to an 'old-base' flag; the flag is off by default, but "stack init" seems to treat it as it being true
09:52:49 <JannisLimperg> samba1: There's almost certainly a better way, I just don't see it after a cursory scan of the Attoparsec API. Someone else well might. ;)
10:09:56 <ReinH> dgpratt: That's not a thing parsers are particularly good at. Your parser would basically be an annoying-to-write version of (init xs, tail xs).
10:11:36 <dgpratt> ReinH, maybe you meant to direct that to samba1 ?
10:11:48 <ReinH> hah, sorry
10:11:54 <ReinH> samba1: ^
10:11:56 <dgpratt> np
10:15:52 <ReinH> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in last . select $ "hello"
10:15:53 <lambdabot>  ('o',"hell")
10:16:32 <ReinH> I agree with Cale. select should be in the prelude.
10:16:36 <ski> yes
10:17:29 <ski> with type `MonadPlus m => [a] -> m (a,[a])', or possibly `Alternative' instead of `MonadPlus' ?
10:17:49 <ReinH> hmm, perhaps!
10:18:06 <Cale> I wasn't even asking for it to be in the Prelude
10:18:10 <ReinH> What other interesting instances of m would you use?
10:18:11 <Cale> I just wanted it in Data.List
10:18:17 <ski> well, `Data.List' would also be fine
10:18:18 <ReinH> Cale: Ok. I would go one step further than Cale. :
10:18:21 <ReinH> :)
10:18:27 <exio4> it should be in base
10:18:36 <ReinH> Data.List would be fine though
10:19:13 <ski> ReinH : fair nondeterminism. logic programming
10:19:53 <ReinH> ski: right
10:20:18 <ReinH> makes sense, select is a prologism anyway
10:20:35 <FireFly> When would one use select?
10:21:14 <FireFly> Oh, hm
10:21:41 <FireFly> I guess it makes sense for using lists to model nondeterminism, yeah
10:21:48 <ReinH> Among other things
10:22:20 <paldepind> Is there an idiom for "if something then transform argument else return argument unchanged"?
10:22:46 <ski> paldepind : i suppose you could say `(if something then transform else id) argument'
10:23:03 <mniip> FireFly: hi!
10:23:13 <athan> Why isn't this a thing? ...
10:23:29 <athan> @let size' = getSum . foldMap (Sum . const 1)
10:23:31 <lambdabot>  Defined.
10:23:34 <athan> :t size'
10:23:35 <lambdabot> (Num c, Foldable t) => t b -> c
10:23:42 <athan> :|
10:23:42 <mniip> :t bool <*> show
10:23:43 <lambdabot> String -> Bool -> String
10:23:46 <exio4> @type length
10:23:47 <lambdabot> Foldable t => t a -> Int
10:23:51 <athan> :O
10:23:53 <athan> thanks exio4
10:23:57 <mniip> paldepind, perhaps bool <*> transform
10:24:13 <ReinH> paldepind: It's a cheap way to get a "element with rest of list" comonad-like, so you can use it wherever you want that context.
10:24:19 <paldepind> ski: I'm thinking something like: doIf condFn doFn val = if condFn val then doFn val else val
10:24:19 <mniip> bool <*> transform argument something
10:24:53 <aweinstock> :t (bool <*>)
10:24:54 <lambdabot> (a -> a) -> a -> Bool -> a
10:25:26 <exio4> paldepind: \c f v -> if c then f v else v = \c f v -> if c then f v else id v = \c f v -> (if c then f else id) v :p 
10:26:01 <ReinH> e.g. do { (bird, rest) <- select birds; return $ move bird (filter (near bird) rest) } is a separation steering algorithm, if move takes a bird and a list of birds and returns a new bird moved away from all the other birds birds.
10:26:41 <ReinH> s/birds birds/birds
10:26:44 <paldepind> exio4, Yes. Something like that, except the value should be passed to a (a -> Bool) function.
10:26:50 <paldepind> Does something like that exist?
10:27:12 <ReinH> paldepind: no, because it's easy to write.
10:27:52 <ski> i've seen `cond :: (a -> Bool) -> (a -> a) -> (a -> a) -> (a -> a); cond p f g x = if p x then f x else g x'
10:28:01 <paldepind> ReinH, lots of things in libraries are easy to write.
10:28:10 <ReinH> you could instead give a Maybe (a -> a) and write applyMaybe :: Maybe (a -> a) -> a -> a
10:28:18 <mniip> ski, so like
10:28:20 <mniip> liftA3 bool
10:29:16 <ReinH> paldepind: "easy to write" is shorthand for a point on the ease and utility curve below someone's arbitrary measure of "important enough to include in the standard library".
10:29:45 * hackagebot trifecta 1.5.2 - A modern parser combinator library with convenient diagnostics  https://hackage.haskell.org/package/trifecta-1.5.2 (EdwardKmett)
10:30:37 <ReinH> :t id
10:30:39 <lambdabot>     Ambiguous occurrence ‘id’
10:30:39 <lambdabot>     It could refer to either ‘L.id’,
10:30:39 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:162:1
10:30:40 <ReinH> Please don't do this.
10:30:42 <ReinH> @undef
10:30:42 <lambdabot> Undefined.
10:30:44 <paldepind> ReinH, I see. I just didn't want to write it myself if there was a known function with the purpose.
10:30:44 <ReinH> :t id
10:30:45 <lambdabot> a -> a
10:31:04 <ski> mniip, aye
10:31:13 <mniip> dee
10:31:14 <FireFly> mniip: hiya
10:31:36 <ReinH> > fromMaybe id Nothing 1
10:31:37 <lambdabot>  1
10:31:41 <ReinH> > fromMaybe id (Just succ) 1
10:31:42 <lambdabot>  2
10:31:59 <ReinH> Booleans are a lie.
10:32:22 <ReinH> If you either have a function to apply or nothing then you have a Maybe (a -> a) :)
10:32:26 * ski . o O ( "blie" )
10:33:26 <mniip> ReinH, yeah, let's rewrite the Eq typeclass using constructivist logic
10:33:34 <mniip> instead of Eq a => a -> a -> Bool
10:33:41 <mniip> we will have Eq a => a -> a
10:33:47 <ReinH> mniip: fine by me. :
10:33:49 <ReinH> :p
10:35:03 <exio4> Eq a b => a -> b -> Dec (a = b)
10:35:20 <exio4> or something :P 
10:37:01 <broma0> Hello, I'm having a bit of trouble converting a LALR grammer to haskell data types. I've pasted a subset of the grammer and my haskell translation here: http://lpaste.net/141137. Is there a standard way of doing this?
10:37:03 <lpaste_> wedifik pasted “attempt at understanding erisco” at http://lpaste.net/141138
10:38:23 <wedifik> whoops wrong channel
10:41:37 <emmanuel_erc> hello
10:42:21 <lpaste_> wedifik revised “attempt at understanding erisco”: “No title” at http://lpaste.net/141138
10:43:13 <broma0> Anyone know of a good way to translate a grammar into haskell ADTs/GADTs ?
10:43:27 <SK0> geekosaur I actually went with your suggestion of A'0 in the Note type
10:43:54 <erisco> "attempt at understanding erisco"
10:44:08 <erisco> I get that reaction a lot
10:44:46 * hackagebot sbp 0.50.6 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-0.50.6 (markfine)
10:50:07 <Luke> is there a specific channel for stack support?
10:50:18 <sm> #haskell-stack
10:51:07 <Luke> ty
10:53:17 <clrnd> what data sctructure gives me a fast op like Data.List.++ ?
10:53:30 <clrnd> fast and lazy probably
10:56:42 <broma0> clrnd: Data.Sequence?
10:56:47 <athan> clrnd: Like Data.Sequence.>< ?
10:56:52 <athan> dangit :(
10:57:14 <clrnd> oh yeah this is it
10:57:14 <broma0> clrnd: concatenate is O(log(min(n1,n2)))
10:57:25 <clrnd> athan, jaja you lose
10:57:31 <clrnd> broma0, thanks
10:57:54 <broma0> clrnd: no problem!
10:57:55 <hodapp> is the pattern "foo n >>= foo >>= foo >>= foo ..." already done someplace?
10:58:11 <broma0> iterate
10:58:13 <broma0> hodapp: iterate
10:58:47 <Cale> clrnd: If your algorithm constructs a list of type [t] all at once, you may also consider instead constructing a function [t] -> [t] which adds elements to the beginning of a list it's given. You can represent [] by id, and [x] by (x:), and most importantly (++) becomes (.)
10:59:02 <broma0> bolmar: whoops.. i think its called replicateM maybe
10:59:12 <ReinH> @hackage dlist -- clrnd
10:59:12 <Cale> clrnd: Since (.) is constant time, as opposed to (++) being linear time, this can reduce the complexity of your program
10:59:12 <lambdabot> http://hackage.haskell.org/package/dlist -- clrnd
10:59:16 <clrnd> Cale, huh, you know I spent a full minute thinking how to do that
10:59:19 <clrnd> you just said it
10:59:37 <clrnd> I couldn't get the id right, but ofc silly me it's id
10:59:39 <Cale> clrnd: and then at the end you can just apply the resulting function to []
10:59:43 <clrnd> yeah
10:59:49 <clrnd> >,>
11:00:13 <Cale> So for example, instead of:
11:00:17 <Cale> reverse [] = []
11:00:24 <Cale> reverse (x:xs) = reverse xs ++ [x]
11:00:29 <Cale> you might have
11:00:31 <Cale> reverse [] = id
11:00:38 <hodapp> broma0: I need to chain the results, not gather them
11:00:39 <Cale> reverse (x:xs) = reverse xs . (x:)
11:00:53 <clrnd> this must probably be what Seq does though
11:00:57 <Cale> nope
11:00:58 <clrnd> Data.Sequence
11:01:00 <clrnd> oh ok
11:01:01 <Cale> Seq is much more complicated
11:01:24 <Cale> and its constant factors are quite poor by comparison if this technique works at all
11:01:45 <exio4> a difference list is pretty cool as long as you have "separated" the process of creating a list and using it
11:01:45 <clrnd> Cale, thanks!
11:01:51 <Cale> But Seq is also much more robust in cases where you need to peek at the sequences you're building as you build them
11:01:54 <exio4> if you need to interleave those two, this doesn't work as well
11:02:06 <exio4> that* 
11:02:20 <ski> (note that "difference list" in the context of logic programming is slightly different)
11:02:33 <Cale> Yeah, I don't like the term difference list
11:02:49 <Cale> I just say "function which adds elements to the beginning of a list"
11:03:04 <ski> "prepending function"
11:03:15 <Cale> Yeah, that's certainly more concise :)
11:03:37 <athan> Cale: Sequences would be good for, say, filtering a list into a unique sublist (or sequence as the accumulator)?
11:03:52 <athan> shoot idk
11:04:22 <Cale> Sequences are particularly good when you know where you're going to need to chop the sequence into parts.
11:04:47 * hackagebot composition-extra 1.3.0 - Combinators for unorthodox structure composition  https://hackage.haskell.org/package/composition-extra-1.3.0 (athanclark)
11:04:49 * hackagebot google-translate 0.1.1.1 - Google Translate API bindings  https://hackage.haskell.org/package/google-translate-0.1.1.1 (DavidJohnson)
11:06:00 <athan> Cale: Hm! okay. I've also heard that peeking from the left or the right has the same complexity, opposed to lists
11:06:08 <Cale> yes
11:06:17 <hodapp> broma0: looks like 'foldM' is actually what I needed!
11:06:19 <Cale> You can look at the ends in constant time
11:06:44 <Cale> and you can chop anywhere in log-of-the-shorter-piece time
11:07:05 <broma0> hodapp: gah!
11:07:11 <broma0> hodapp: just came up with this:
11:07:12 <broma0>  let f n g i = foldl (>>=) (g i) (replicate n g)
11:07:41 <hodapp> broma0: hah... same thing?
11:07:45 <broma0> hodapp: is it?
11:07:48 <hodapp> :t foldMap
11:07:49 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
11:07:57 <broma0> @let f n g i = foldl (>>=) (g i) (replicate n g)
11:07:58 <lambdabot>  Defined.
11:08:00 <broma0> :t f
11:08:01 <lambdabot>     Ambiguous occurrence ‘f’
11:08:01 <lambdabot>     It could refer to either ‘L.f’,
11:08:01 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:148:1
11:08:05 <broma0> oops
11:08:09 <broma0> @let somefunction n g i = foldl (>>=) (g i) (replicate n g)
11:08:10 <lambdabot>  Defined.
11:08:13 <broma0> :t somefunction
11:08:14 <lambdabot> Monad m => Int -> (a -> m a) -> a -> m a
11:08:19 <athan> Cale: That's awesome :) thank you. That also makes sense why `Seq Int` is the Key for Data.Tree in the keys library - you could investigate top-down, or build bottom-up
11:08:33 <hodapp> :t foldM
11:08:34 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
11:08:35 <athan> @unset size'
11:08:35 <lambdabot> Unknown command, try @list
11:08:39 <athan> er
11:08:59 <hodapp> broma0: looks like almost the same except with some arguments reversed and an int instead of a list
11:09:32 <broma0> hodapp: right. well, i hope you found the answer you were looking for
11:10:04 <athan> hodapp: I use foldM often, it's nice :)
11:10:23 <lingxiao> hey all
11:10:32 <lingxiao> do you think it's ok to pattern matchin against strings in functions?
11:10:33 <lingxiao> ie...
11:10:40 <Cale> athan: Maybe! I haven't run across many real cases where Sequence actually wins out over other options unfortunately.
11:10:51 <athan> Cale: list fusion is nuts :\
11:11:00 <lingxiao> func (ValConstructor "HELLO" xs) = length "HELLO" + xs
11:11:10 <Cale> athan: I'll always think I have a case where it's good, and then I'll try it and it's really mediocre or worse than what I already had.
11:11:11 <athan> I tried making a Data.Set-based rose tree, and it was about 2x slower than Data.Tree
11:11:11 <broma0> Now that some people are awake.. Can anyone take a look at http://lpaste.net/141137 and help me figure out how to clealy represent a grammer in haskell's ADT/GADTs?
11:11:14 <athan> even with the ordering :\
11:11:19 <lingxiao> func (ValConstructor "WORLD" xs) = length "WORLD" + xs + xs
11:11:36 <Cale> lingxiao: Yeah, that kind of matching is valid.
11:11:39 <lingxiao> Im seeing this in some of student's code and although I wouldn't do it ... i can seem to decide it's "bad"
11:11:57 <lingxiao> so ditto for lists?   
11:12:01 <Cale> yes
11:12:06 <athan> I prefer `x == "WORLD"`, just because string literals look like values :x
11:12:11 <lingxiao> func (10:x:y:xs) = 10 + xs
11:12:20 <lingxiao> or  err ... that doenst make sense ..
11:12:30 <Cale> well, that's probably a type error
11:12:32 <Cale> but yeah
11:12:37 <Cale> You can also match against things like  [x,y,z]
11:12:47 <lingxiao> Cale yeah I said what athan to a student 
11:12:56 <athan> not unless you make an Num a => Num [a] instance >:D
11:13:08 <lingxiao> yeah [x,y,z] make sense to me
11:13:10 <lingxiao> lol
11:13:22 <lingxiao> which is why match against "hello" should be fine?
11:13:29 <lingxiao> ok from now on I'll say it's fine
11:13:29 <Cale> yeah
11:13:35 <ReinH> "hello" is another kind of sugar for lists.
11:13:44 <ReinH> (excepting cases with OverloadedStrings)
11:14:16 <Cale> Because you're literally matching against 'h':('e':('l':('l':('o':[])))), and if you think of the characters as constructors, it makes sense to be able to do that
11:14:19 <tommd> Then it is a sugar for application of a function to a list.
11:14:43 <lingxiao> yeah ... ok hmm learned something new today
11:14:44 <lingxiao> thanks!
11:15:14 <athan> Is `mfix` only practical with IO-related monads? :\
11:15:26 <athan> > mfix (++ [1])
11:15:27 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ [a]
11:15:27 <lambdabot>      Expected type: [a] -> [[a]]
11:15:27 <lambdabot>        Actual type: [a] -> [a]
11:15:28 <Cale> athan: uhhh... no
11:15:30 <athan> er
11:15:32 <ReinH> athan: no.
11:15:37 <athan> :(
11:15:45 <athan> lay it on me
11:16:26 <ski> broma0 : why distinguish between `Expression',`SimpleExpression',`Term',`Factor' in the abstract syntax trees ?
11:16:37 <ReinH> MonadFix can be used as an alternative to recursive do
11:17:26 <sezna> hello!
11:17:29 <johnw> ReinH: in fact, recursive do requires it
11:17:31 <athan> I'll need to read that paper again
11:17:39 <ReinH> johnw: true enough
11:17:55 <athan> i remember it talking about how ContT can't be MonadFix or something
11:18:01 <ReinH> athan: think about things that need to tie a knot with effects, like tagging a tree with some value obtained via monadic effects.
11:18:06 <ReinH> e.g. https://ocharles.org.uk/blog/posts/2014-12-09-recursive-do.html
11:18:08 <sezna> are you guys open for a quick question regarding a list operation? 
11:18:23 <ReinH> johnw: I should have said mfix :)
11:18:35 <johnw> sezna: ask away
11:18:36 <broma0> ski: because i dont know how to translate between the two.. I just tried to be as literal as possible
11:19:07 <broma0> ski: what i'm really looking for is the standard way to write an AST from a grammar like the one i have commented
11:19:18 <athan> Thanks ReinH :)
11:19:28 <sezna> I am trying to write a function that takes a type a, a list of lists, and :'s a onto the beginning of every sub-list in the list
11:19:35 <ReinH> athan: :)
11:19:43 <ski> broma0 : the staging between `Expression',`SimpleExpression',`Term',`Factor' is necessary in the concrete syntax, because of ambiguity, which is removed by precedence (and associativity) rules
11:19:44 <johnw> map (a:)
11:19:46 <sezna> johnw: the end result is to make a powerset function without higher order functions or maps
11:19:58 <johnw> ah
11:19:59 <sezna> alas, we must do it with recursion and comprehensions.
11:20:08 <ReinH> sezna: why wouldn't you want to use higher order functions to do higher order things? For an exercise?
11:20:09 <ski> broma0 : it is not needed in the abstract syntax, and would probably mostly be in the way, unless you have some real reason to retain it
11:20:21 <sezna> reinH, yes, part of the exercise. it is for a class
11:20:33 <ReinH> I mean, if I didn't have map and I needed to map something, the first thing I would do is write map ;)
11:20:38 <Cale> > runState (do rec { put (0 : map (+1) xs); xs <- get }; get) []
11:20:40 <lambdabot>  <hint>:1:24: parse error on input ‘(’
11:20:43 <Cale> tsk
11:20:46 <sezna> but writing map in itself is using a higher order function 
11:20:58 <sezna> its not that we cant use library ones, we just cant use that concept on this assignment :(
11:21:04 <ReinH> Cale: do you want mdo?
11:21:06 <ski> broma0 : start by smashing these four types together into a single one ?
11:21:16 <Cale> I suppose mdo will work as well
11:21:19 <ReinH> sezna: huh.
11:21:31 <Cale> > runState (mdo put (0 : map (+1) xs); xs <- get; get) []
11:21:32 <lambdabot>  <hint>:1:36: parse error on input ‘;’
11:21:42 <ReinH> sezna: Does your assignment read "write a powerset function in the most annoying way possible?" :D
11:21:49 <ski> broma0 : also, you need to figure out how `( expression_list )' is supposed to work in case the list is a singleton. is that then a tuple, or just a bracketed expression ?
11:21:51 <sezna> hahaah. essentially.
11:21:54 <Cale> nope, no recursive do notation for us :S
11:22:09 <sezna> reinH: the professor said something along the lines of this being the most pedantic homework we will have.
11:22:17 <ReinH> sezna: well, you can just inline everything until there are no more higher order functions, I guess
11:22:23 <ReinH> hah
11:22:29 <johnw> Cale: move the xs <- get to before the put in the mdo?
11:22:34 <Cale> we can just use mfix
11:22:36 <ski> broma0 : .. i think it would be more common to start with an AST, and then refine/stage it to get the concrete syntax version (the opposite of what you're asking for), though ?
11:22:44 <sezna> ReinH: can you explain what you mean by that?
11:22:48 <Cale> johnw: No, that wouldn't mean the same thing
11:22:56 <Cale> johnw: The order of effects matters :)
11:23:01 <johnw> ah, right
11:23:02 <akegalj> I am trying to find equivalent functionality as Data.Iterate.Parallel.mapReduce in conduit package. Is there such?
11:23:04 <broma0> ski: honestly, I have been given that grammar and told to write a lexer/parser/interpreter for it. I'm not sure how to start the process with a grammer 
11:23:40 <Cale> > runState (do mfix (\xs -> do put (0 : map (+1) xs); get); get) []
11:23:42 <lambdabot>  ([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
11:23:51 <ski> broma0 : ok. well, you need to figure out which syntactical categories are split only for purposes of disambiguating. in this case, i'd say it's those four
11:24:03 <putis> karma putis
11:24:10 <ski> ?
11:24:18 <putis> ups, does not work
11:24:38 <Cale> We probably don't need the extra get, really
11:24:48 * hackagebot Euterpea 1.1.1 - Library for computer music research and education  https://hackage.haskell.org/package/Euterpea-1.1.1 (MarkSantolucito)
11:24:49 <broma0> ski: ok.. so once i figure that out, do i then try to write the AST form that? or start with the lexer?
11:24:50 <Cale> > runState (mfix (\xs -> do put (0 : map (+1) xs); get)) []
11:24:51 <lambdabot>  ([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
11:25:12 <Cale> because the fixpoint solution is the result of the mfix
11:25:19 <broma0> ski: the grammer is about 5 times as large as the small subset i provided
11:26:01 <ski> broma0 : i dunno which end you want to start at
11:26:40 <ski> putis : do you have a Haskell-related question or comment ?
11:27:11 <breadmonster> Cale: Is there a way to implement the lambda calculus in Haskell?
11:27:12 <sezna> reinH this is the recursion I was thinking of: powersetHelper _ [] = [] powersetHelper z (x:xs) = (z : x) : powersetHelper z xs
11:27:25 <breadmonster> The last time I tried implementing the untyped version, I got a type error.
11:27:28 <tommd> breadmonster: See the lambdacalculator on Hackage.
11:27:44 <putis> ski: yes, but a 'karma putis' was a test if functionality found at https://wiki.haskell.org/IRC_channel does work
11:27:48 <Cale> breadmonster: Yes of course.
11:28:01 <Gurkenglas> :t map (z:) -- sezna
11:28:02 <lambdabot> [[Expr]] -> [[Expr]]
11:28:11 <Cale> breadmonster: Haskell is Turing complete, you can compute essentially anything which is possible to compute with it.
11:28:44 <breadmonster> Cale: Oestensibly, sure.
11:28:47 <Gurkenglas> That'll go in a quote, you do know that?
11:28:52 <breadmonster> Why do I get type errors though?
11:28:54 <sezna> Gurkenglas class assignment that requires no higher order functions...
11:29:05 <sezna> :(
11:29:13 <quchen> You can't type in any untyped lambda calculus expression, e.g. Y won't typecheck in its usual representation. But you can certainly implement untyped LC.
11:29:25 <Cale> http://dev.stephendiehl.com/fun/lambda_calculus.html appears to take you through the construction of an evaluator for the untyped lambda calculus step-by-step
11:29:38 <Cale> breadmonster: Because your evaluator has a bug in it?
11:29:58 <mniip> breadmonster, simply typed lambda calculus is not turing complete
11:30:01 <Cale> breadmonster: It's really hard to say without knowing what the type errors are and what the source code is.
11:30:02 <ReinH> sezna: right, that's just inlining map (z:)
11:30:09 <mniip> haskell, however, is not *just* STCL
11:30:10 <breadmonster> Cale: I'll try finding it.
11:30:13 <mniip> STLC
11:30:14 <Gurkenglas> sezna, if I gave such an assignment I would allow you to define your own hofs in a where or disallow defining functions like powersetHelper in a where.
11:30:23 <mniip> haskell is much more than simply typed lambda calculus
11:30:23 <Cale> mniip: hm? How is this relevant...
11:30:28 <mniip> and therefore is turing complete
11:30:32 <Cale> I mean, yeah, Haskell has recursion
11:30:39 <Gurkenglas> (not that I would disallow hofs in the first place ._.)
11:30:42 <Cale> which you're probably going to use in your eval
11:30:56 <ski> @karma putis
11:30:57 <lambdabot> putis has a karma of 0
11:31:00 <ski> putis, works
11:31:54 <Cale> breadmonster: https://github.com/sdiehl/write-you-a-haskell/blob/master/chapter4/untyped/Eval.hs#L44
11:32:35 <putis> ski: thanks :)
11:32:47 <Cale> That uses an evaluation monad, so it's already more complicated than I'd really want as an example, but hey, this is what google turns up
11:32:48 <breadmonster> Cale: Why won't it let me define the omega combinator?
11:33:05 <breadmonster> :t \x -> x x
11:33:06 <lambdabot>     Occurs check: cannot construct the infinite type: r1 ~ r1 -> r
11:33:06 <lambdabot>     Relevant bindings include x :: r1 -> r (bound at <interactive>:1:2)
11:33:06 <lambdabot>     In the first argument of ‘x’, namely ‘x’
11:33:06 <Cale> breadmonster: Why won't your untyped lambda calculus evaluator let you do this?
11:33:15 <Cale> Oh, why won't *Haskell* let you do that
11:33:19 <ski> breadmonster : because it doesn't allow equi-recursive types
11:33:32 <breadmonster> ski: Isn't that a tautology?
11:34:00 <Cale> If you start allowing infinite types, there are a lot of programs which are clearly typos that suddenly typecheck and fail at runtime
11:34:17 <ski> breadmonster : because allowing them tend to turn legitimate type errors into strange type-checking code, while they don't give you much that an explicit iso-recursive type doesn't give
11:34:44 <putis> Do you have any tips where to start, when I am trying to compile code written in Core Haskell? I have found so far article at https://wiki.haskell.org/GHC/As_a_library and looked into the compiler sources, but with your help it would be easier.
11:34:48 <ski> breadmonster : if you want to play with them, you can try `ocaml -rectypes'
11:34:53 <breadmonster> Cale: damn. We should make this some extension though.
11:35:16 <quchen> Haskell doesn't aim at completeness rather than being practical.
11:35:27 <quchen> It's not a "put in all the things" bucket.
11:35:42 <Cale> http://copilotco.com/mail-archives/haskell-cafe.2006/msg05831.html
11:35:45 <quchen> Infinite types have pretty big drawbacks, and not many benefits that I've heard of.
11:35:50 <Cale> ^^ read that post
11:36:50 <breadmonster> Cale: An optional extension? :(
11:36:58 <breadmonster> Though I wonder what those things would do.
11:37:01 <Cale> It's doable, but not useful
11:37:23 <quchen> If you're going to extend the typechecker by something, make it rank-2-inference ;-)
11:37:56 <Cale> There's not a heck of a lot which you can do with infinite/equirecursive types that you can't already do in a more type-safe way with recursive newtypes
11:37:59 <breadmonster> quchen: I would have actually loved to do a project on ghc like that, but I have no idea how to.
11:38:15 <breadmonster> quchen: I hear it's not so much ingenuity but a lot of work.
11:38:30 <Cale> and by "not a heck of a lot", I mean "essentially nothing", apart from gaining that syntactic convenience writing yourself infinite loops.
11:38:50 <nolrai666> I guess Infinit types work to implement equi-recursive types which some languages seem to like.
11:38:52 <quchen> GHC 8.12: improved support for expressing ⊥ ;-)
11:39:09 <breadmonster> quchen: lol
11:39:19 <nolrai666> Hmm.
11:39:21 <quchen> breadmonster: I keep thinking the typechecker would be a neat example of using ST in practice, but it's quite a beast.
11:39:28 <quchen> One day …
11:39:44 <````> wtf they're all registered.
11:39:52 <nolrai666> You mean the ghc checker?
11:39:55 <quchen> Now that my computation slave desktop works again I can at least compile GHC again.
11:40:08 <quchen> nolrai666: Yes.
11:40:18 <quchen> It's currently heavily and awkwardly IO-based.
11:40:22 <_`--`_> quchen: Shame.
11:40:28 <nolrai666> Are you the ```` from qq?
11:40:41 <_`--`_> nolrai666: Nope, I just realized that four backticks was a valid nick.
11:40:56 <quchen> Apparently you need mutability for an efficient implementation of the typechecker, but I'm not sure whether IO is necessary.
11:41:08 <quchen> You need a supply of new names and mutable references from what I've seen.
11:41:30 <nolrai666> So ST should handle that just fine.
11:41:32 <quchen> But this whole chain of IO that threads itself through the entire compiler confuses me, and ST sounds like it could introduce nice logical bottlenecks.
11:41:52 <Cale> breadmonster: you can do this:
11:41:58 <Cale> data Rec a = In { out :: Rec a -> a }
11:42:04 <Cale> y :: (a -> a) -> a
11:42:04 <Cale> y = \f -> (\x -> f (out x x)) (In (\x -> f (out x x)))
11:42:10 <Cale> loop = (\(In x) -> x (In x)) (In (\(In x) -> x (In x)))
11:42:16 <breadmonster> Cale: So much work :O
11:42:31 <Cale> breadmonster: well, it's just sticking in these isomorphisms here and there
11:42:42 <breadmonster> It's still so much work :O
11:42:48 <Cale> and it should be a bit of work, imo, to do something stupid like that
11:43:12 <Cale> Because most of the time, this is not something you want to do
11:43:26 <Cale> If you meant to express recursion, you'd have just used recursion which is already in the language.
11:43:33 <Cale> It's far more likely that you just screwed up
11:43:39 <nolrai666> Do you mean nice as in good or nasty?
11:44:42 <quchen> breadmonster: The purpose of a type system is restricting the amount of programs you can express in a language. A good type system prevents you from more invalid programs than from valid programs. In the process, you always lose some valid programs, but we argue it's worth it.
11:44:51 <Cale> quchen: (Monad m) => m FreshName -> ... -> m ...
11:45:05 <quchen> > map show [4 :: Int, ()] -- looks useful, but the type system doesn't like it.
11:45:06 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘()’
11:45:06 <lambdabot>      In the expression: ()
11:45:06 <lambdabot>      In the second argument of ‘map’, namely ‘[4 :: Int, ()]’
11:45:12 <quchen> Cale: Hm?
11:45:13 <Cale> quchen: and then plug in a bunch of IO actions at the top level ;)
11:45:20 <osmium_> newbie question...I would like to download haddocks for offline usage. Does either hackage or stackage offer this feature? I see there's a hoogle database for download on stackage, but I don't think that's what I want (browsable docs). Or do people just locally build haddock from source each time I change dependencies?
11:45:33 <Cale> quchen: I'm just expressing a possible way to ensure the code is pure apart from the few effects you want
11:45:49 <quchen> Cale: Oh, you mean making the code monad-polymorphic?
11:45:53 <Cale> yeah
11:46:00 <quchen> Not sure whether that's an option.
11:46:05 <Cale> Probably not for GHC :P
11:46:41 <quchen> I talked to Andres Löh and a couple of others on IRC a couple of times, and what I've learned is that a straight and pure implementation is somewhat inefficient.
11:46:47 <breadmonster> quchen: Shouldn't it restrict you from logically invalid programs, rather than culturally invalid programs?
11:47:08 <Cale> Well, maybe? It would be a bunch of work to figure out all the things which are needed and build some sort of record type of them (polymorphic in m, but we all know it'll be IO in the end)
11:47:11 <breadmonster> quchen: ie. this is mathematically inconsistent vs. this is probably not what you want to do?
11:47:35 <ski> quchen : of type inference ?
11:47:44 <quchen> breadmonster: It should restrict me from writing programs I did not intend to write.
11:48:00 <Cale> breadmonster: When you're designing the rules of the system, you get to choose which things are mathematically valid.
11:48:02 <breadmonster> quchen: That presupposes perfect knowledge of intent.
11:48:13 <quchen> A seatbelt should restrict me from injury. I don't care whether it's mathematical or cultural injury ;-)
11:48:15 <Cale> breadmonster: and refine that set of things to just the ones you want it to be
11:48:18 <breadmonster> Cale: Fair enough, I didn't see it that way.
11:48:21 <quchen> ski: Yes.
11:49:08 <Cale> breadmonster: There is also some irony in your question which you might not be aware of
11:49:18 <quchen> ski: I don't understand why exactly though, so I'm the wrong guy to ask further questions :-|
11:49:41 <Cale> breadmonster: The untyped lambda calculus started life at an attempt at a logical formalism, but the very thing you're asking for is what caused it to be logically inconsistent.
11:49:49 * hackagebot seqid-streams 0.4.1 - Sequence ID IO-Streams  https://hackage.haskell.org/package/seqid-streams-0.4.1 (LukeHoersten)
11:49:50 <quchen> ski: But seeing zonking in GHC it's pretty obvious that that's not the natural functional way to do things, and someone put some effort into making the system that way :-)
11:49:52 <Cale> breadmonster: and this is what created type theory in the first place
11:50:15 <breadmonster> I thought type theory was in response to Russell's Paradox.
11:50:19 <Cale> :t fix
11:50:20 <lambdabot> (a -> a) -> a
11:50:30 <Cale> :t fix id
11:50:31 <lambdabot> a
11:50:39 <Cale> ^^ once you have recursion, you can prove anything
11:50:44 <breadmonster> Interesting.
11:51:47 <quchen> ⊥ destroys everything, but not having it prevents you from building things in the first place :-\
11:51:56 <ski> quchen : "zonking" ?
11:52:39 <quchen> ski: Handwavily, GHC types are "ADTs of IORefs". Unification means modifying such IORefs, for example.
11:52:53 <quchen> Zonking is something like "freezing" those IORefs.
11:53:02 <hodapp> quchen: this is the first time I've seen the word "handwavily".
11:53:09 <quchen> I like to neologism.
11:53:23 <Cale> Zonking is GHC's word for instantiating type variables during unification. 
11:53:23 * ski misses Pseudonym
11:53:29 <ski> ok
11:53:29 <Cale> er
11:53:31 <quchen> Unfortunately, all the docs say about where "zonking" is that the "reason for naming it has been forgotten" or something like that :-þ
11:53:48 <ski> @quote yet.implemented
11:53:48 <lambdabot> Pseudonym says: A "newbie", in Haskell, is someone who hasn't yet implemented a compiler. They've only written a monad tutorial.
11:53:48 <quchen> Cale: Are you sure about that?
11:54:03 <Cale> Well, that's what I thought it meant
11:54:07 <ski> quchen : it's basically logic/meta variables
11:54:23 <quchen> Cale: Zonking from my perspective is something done after type inference, when everything's settled.
11:54:28 <Cale> I could be wrong, I haven't spent a whole lot of time working on GHC, just read some of the source here and there.
11:54:34 <quchen> Cale: Instantiating type variables sounds like an intermediate step.
11:54:46 <quchen> But I'm by no means familiar with the typechecker. I only modify it :>
11:55:05 <quchen> Speaking of which, GHC's done compiling! Weee.
11:55:11 <Cale> ah, you're right
11:55:30 <indiagreen> is there some ultra-fast mutable intset I could use when I need an ultra-fast mutable intset?
11:55:38 <quchen> Cale: Instantiation should simply be newIORef
11:55:40 <Cale> Zonking replaces the mutable references that got filled in by unification with their final values.
11:55:49 <ski> quchen, huh ?
11:56:07 <ski> Cale : oh, so it's freezing at the end ?
11:56:11 <quchen> Cale: That's what I meant with freezing.
11:56:13 <Cale> yeah
11:56:31 <quchen> ST is probably wobbling up and down in its room all the time yelling "why not meeee"
11:56:59 <quchen> You don't need network filesystem time access to do this!
11:57:00 <Cale> quchen: and the little s hiding under its bed is giggling away
11:57:19 <quchen> Giggling? It's sad because it can never come out from under the bed
11:57:27 <quchen> It can only work with the crumbs you give it
11:57:57 <quchen> s is grounded by the evil wizard ∀ 
12:04:50 * hackagebot plotfont 0.1.0.0 - Plotter-like fonts i.e. a series of straight lines which make letter shapes.  https://hackage.haskell.org/package/plotfont-0.1.0.0 (mjoldfield)
12:05:23 <Denommus> how can I make this code prettier? https://gist.github.com/Denommus/80aa4f00a89b82987fa1
12:05:59 <Cale> Use isAlpha
12:06:01 <Cale> ?
12:06:09 <Cale> hmm
12:06:29 <Denommus> Cale: nope
12:06:59 <johnw> file <- head <$> getArgs is the same as [file] <- getArgs
12:07:06 <johnw> or, file:_
12:07:36 <quchen> f ~foo@(bar:baz) -- this is syntactically valid, no?
12:07:56 <quchen> Or how do I make an as-pattern irrefutable
12:08:19 <Cale> It might be more self-explanatory to use ord 'a', etc. in place of the numbers at least.
12:09:00 <Cale> You seem to be checking multiple times if the character lies in each range, which can't be ideal.
12:09:28 <johnw> quchen: is it foo@~(bar:baz) maybe?
12:10:14 <Cale> oh, you're not using mod
12:10:18 <Cale> I see
12:10:23 <Cale> That's... interesting
12:10:37 <Denommus> Cale: I haven't thought about using mod
12:11:35 <quchen> > let f ~xx@(x:xs) = xx in f []
12:11:37 <lambdabot>  *Exception: <interactive>:3:5-21: Irrefutable pattern failed for pattern xx@...
12:11:43 <quchen> Uh.
12:11:48 <quchen> Well, the syntax is right at least.
12:11:49 <quchen> johnw: ^
12:12:15 <quchen> > let f xx@~(x:xs) = xx in f []
12:12:16 <lambdabot>  <hint>:1:5: Parse error in pattern: f
12:12:47 <quchen> This MonadFail business makes me want to have lazy bang patterns.
12:12:58 <quchen> Patterns that are guaranteed to match, but should not be delayed. :-D
12:13:58 <Denommus> Cale: updated it
12:14:26 <ski> just use `! ~ x' ? :)
12:14:38 <quchen> Needs parentheses
12:14:43 <ski> possibly
12:14:48 <quchen> I did that a couple of times, and then decided to not do that.
12:15:02 <quchen> It's really ugly and confuses everyone.
12:15:24 <quchen> So now I'm just using ~ instead, hopefully not introducing laziness where it's not desirable.
12:20:40 <nitrix> What is the longest function type in Haskell you've seen?
12:20:57 <quchen> I haven't seen the largest type because it won't fit in my memory.
12:21:31 <Denommus> nitrix: a -> b
12:21:57 <lpaste_> Cale pasted “Perhaps something like this?” at http://lpaste.net/141149
12:22:08 <Cale> Denommus: ^^
12:22:14 <nitrix> This isn't only informative, I'm designing a toy language to better understand language theory and curious if I should be worried about having explicit type declarations taking multiple lines.
12:22:26 <quchen> let a x = (x,x); b = a.a; c = b.b; d = c.c; e = d.d; f = e.e; g = f.f in g () -- Ask GHCi for my type
12:22:55 <quchen> Oh, you mean practical types.
12:23:08 <quchen> Yes, multiple lines are something I frequently use (and see used).
12:23:09 <nitrix> Yeah, nothing that's crazily inferred.
12:23:25 <Cale> nitrix: I've seen types which span 10 or 15 lines.
12:23:37 <Denommus> Cale: good one
12:23:40 <Cale> Not always particularly dense lines
12:23:58 <quchen> On my screen right now: dataFlowPassFwd :: NonLocal n => GenCmmGraph n -> [(BlockId, f)] -> FwdPass UniqSM n f -> UniqSM (GenCmmGraph n BlockEnv f)
12:24:08 <nitrix> Crap. So, first, would you recommend having a dedicated type declaration line that isn't part of the function declaration?
12:24:11 <quchen> The entire module is full of these types.
12:24:20 <Cale> nitrix: yes
12:24:50 * hackagebot orgmode 0.1.0.1 - Org Mode library for haskell  https://hackage.haskell.org/package/orgmode-0.1.0.1 (lally)
12:24:54 <Cale> nitrix: This also forces you to think about a syntax for types at least somewhat separate from the syntax of expressions.
12:25:07 <nitrix> Correct and the worst is that spaces aren't significant.
12:25:27 <nitrix> I don't want silly {} or [] either, I'm in a strange position.
12:25:48 <Cale> nitrix: When in doubt, I'd say just do what Haskell does.
12:26:01 <nitrix> Haskell has significant whitespaces.
12:26:20 <nitrix> The identation of functions and types determines the block.
12:26:41 <Cale> Types aren't particularly whitespace sensitive
12:27:00 <Cale> There are only a few layout keywords in Haskell
12:27:05 <Cale> let, do, of, where
12:27:11 <statusfailed> Are there any good video lectures covering TAPL or TAPL-like material?
12:27:25 <Cale> (and a handful more if you turn on extensions, like mdo)
12:27:26 <nitrix> Cale: My language has none of those.
12:28:00 <Cale> nitrix: The way things work in Haskell is that the first non-whitespace character following one of those keywords sets the block indentation level
12:28:04 <dmj`> statusfailed: https://www.cs.uoregon.edu/research/summerschool/summer10/curriculum.html
12:28:06 <suppi> I don't know why, but I'm trying to run TestList with two cases with hunit but all I get is that -one- case succeeded.
12:28:29 <Cale> Subsequent lines which start in that column will have a semicolon inserted between the previous line and that line.
12:28:40 <Cale> Lines which start in a deeper column will not.
12:28:43 <statusfailed> dmj`: Thanks! I should have googled first, haha
12:28:44 <nitrix> Cale: Right. This is what "I don't like".
12:28:46 <statusfailed> dmj`: have you watched those?
12:28:51 <Cale> Lines which start in a shallower column will close the block.
12:29:10 <Cale> So there's nothing in the syntax of types which is whitespace sensitive.
12:29:35 <nitrix> Cale: Given my language is concatenative (RPN), it'd be best to keep whitespaces non-significant as it already means composition.
12:29:43 <Cale> However, since the top level of your module is all sitting inside a where block, you get line continuation to happen by indenting to any extent at all.
12:30:11 <dmj`> statusfailed: not all of them
12:30:43 <statusfailed> dmj`: how are they?
12:30:43 <Cale> So I dunno, I guess that *sort of* counts as whitespace sensitivity.
12:30:52 <Cale> But if you were putting semicolons in at the top level, it wouldn't.
12:30:58 <Cale> You wouldn't have to indent or anything.
12:31:20 <Cale> You just have a semicolon at the end of your type signature
12:31:36 <Cale> and it can span multiple lines, and they're not whitespace sensitive anymore
12:32:25 <Cale> However, we do like to indent to align the ->'s
12:32:36 <nitrix> Well, yeah, I just need a way to distinguish the begining and ends of type declaration and functions, without using identation nor wrapping them into blocks.
12:32:59 <Cale> Use whatever separator you were already using to separate declarations.
12:33:54 <Cale> (and don't tell me it's newline, I thought you didn't want to be whitespace sensitive ;)
12:34:54 <nitrix> I'm thinking, I could technically parse on = to find definitions, but it'd require the first word, the function name, to always be at the begining of the line.
12:34:59 <nitrix> Cale: This makes that possible: http://lpaste.net/141151
12:35:04 <quchen> ಠ_ಠ 2 hours of mind-numbing adding tildes and then I realize I forgot the IO instance for MonadFail
12:35:12 <quchen> reset hard head, recurse
12:36:32 <ski> nitrix : SML starts function declarations with `fun'
12:36:47 <nitrix> I can't have keywords :/
12:37:02 <nitrix> Even the = sign makes me unhappy.
12:37:19 <ski> you don't have a forth-like `:' ?
12:37:28 <nitrix> Being RPN, it should be something like...     [term term term] 'symbol def
12:38:17 <nitrix> But that's just not usuable, so I figured, how bad can it gets if I introduce a bit of syntax for declarations. It's a declarative language afterall, it should be easy to declare things.
12:38:40 <ski> do you have pattern-matching ?
12:39:50 <nitrix> I don't think it's necessary for the language to work (I could be wrong), but I'd like it, yeah.
12:39:51 * hackagebot not-gloss 0.7.6.1 - Painless 3D graphics, no affiliation with gloss  https://hackage.haskell.org/package/not-gloss-0.7.6.1 (GregHorn)
12:39:53 <breadmonster> Is there an xmonad tutorial?
12:40:09 <breadmonster> my xmonad installation looks ugly, but it's so pretty for other people :(
12:40:13 <ski> something like
12:40:21 <ski>   : nil  length = 0
12:40:29 <ski>   | cons length = drop length 1 +
12:40:31 <ski>   ;
12:40:32 <ski> perhaps
12:41:28 <Sonolin> I use https://wiki.haskell.org/Xmonad/General_xmonad.hs_config_tips#ManageHook_examples
12:41:32 <geekosaur> breadmonster, https://wiki.haskell.org/Xmonad/Config_archive/John_Goerzen%27s_Configuration (also there is #xmonad)
12:41:36 <Sonolin> also there's #xmonad (just fyi)
12:41:48 <breadmonster> Oh right cool.
12:42:44 <geekosaur> http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Doc-Extending.html has some nice pointers
12:43:01 <ski> nitrix : you get the idea, i hope
12:43:43 <breadmonster> Cool stuff, thanks guys.
12:43:58 <aweinstock> @where real world haskell
12:43:58 <lambdabot> http://book.realworldhaskell.org/read/ <-- the comprehensive xmonad configuration syntax reference
12:45:09 <nitrix> ski: Yeah, I'm brainstorming.
12:46:28 <Cale> ski: I'm not sure if I get it yet, could you write Red-Black tree balancing in that style? ;)
12:46:44 <Cale> (I'm joking)
12:51:18 <ski> Cale : hm, sounds fun
12:52:21 <thoughtpolice> nitrix: Any of the functions in this package have the longest types I've ever seen - http://hackage.haskell.org/package/sessions
12:52:44 <thoughtpolice> quchen: It's called zonking "because of the sound it makes"
12:52:50 <quchen> thoughtpolice: ?
12:52:55 <quchen> Oooh, sessions.
12:52:59 <quchen> A good guide for what not to do.
12:53:04 <thoughtpolice> I was just reading backlog. And 
12:53:16 <thoughtpolice> `sessions' is from a time before we even had type families, so it's pretty... out there :)
12:53:19 <quchen> Yes, but I don't see zonking making a zonking sound.
12:53:32 <quchen> I also don't know what sound zonking is.
12:53:48 <thoughtpolice> That's what I said!
12:53:55 <ski> @quote zonk
12:53:55 <lambdabot> GhcSource says: In zonking, do we need to zonk the kinds of coercion variables?
12:54:09 <thoughtpolice> I presume it's in-line with the sound you might imagine in your head when you read it in a comic book.
12:54:34 <nitrix> That's insane.
12:54:47 <quchen> Taking α equivalence to the next level, I guess.
12:55:20 <nitrix> Isn't it one of those things that you'd think people would refactor as the language matured up.
12:56:08 <thoughtpolice> nitrix: The project was abandoned long before GHC had anywhere near the type-level features it does today. GHC 6.8 was, in certain ways, a very different kind of GHC to program with :)
12:56:20 <thoughtpolice> These days I imagine a lightweight session types package would be a lot simpler.
12:56:49 <thoughtpolice> I also seem to remember `sessions' being especially advanced, as far as those systems go
12:57:17 <Cale> nitrix: Why bother? It just becomes a technical term.
12:57:32 <Cale> (if you're referring to zonking)
12:58:00 <quchen> Cale: A bad name *has* to become a technical term. A good name doesn't have to.
12:58:18 <quchen> Zonking is an example of an abysmal name. Maybe there's no better name, but it's still awful.
12:58:24 <Cale> Ergo: we should always choose bad names
12:58:40 <quchen> s/Control.Category/Control.Monoidoid/
12:58:54 <Cale> (so as to ensure that everything become formalised as soon as possible)
12:59:04 <quchen> Because that's going to happen ;-)
13:01:24 <quchen> To be fair, GHC's source is quite good for a 20-year effort written by so many people.
13:02:02 <Gurkenglas> I would like to have there be a website that provides UI for "modify . (:)" and "gets . filter", such that the state is shared between everyone accessing the website, and persistent. How would I go about this?
13:02:03 <quchen> It's full of quirks, but the amount of implicit knowledge required is much smaller than other things I'm working with.
13:02:11 <thoughtpolice> 25 years :)
13:02:13 <quchen> And none of the quirks broke my neck so far.
13:02:38 <quchen> thoughtpolice: Okokok
13:02:53 <thoughtpolice> GHC is roughly as old as I am so it's just easy to remember :P
13:03:06 <quchen> Up to a constant factor, the same is true for myself.
13:03:12 <quchen> When was GHC started? 1990?
13:03:25 <quchen> Wait, the first STG book thing is from 1987, no?
13:04:20 <mizu_no_oto> quchen: http://haskell.cs.yale.edu/wp-content/uploads/2011/02/history.pdf
13:04:30 <Cale> The first implementation of Haskell is a trademark of Research Software Ltd. ;)
13:05:07 <bz> is it possibel to make a monad instance out of a * -> * whose parameter has an Ord constraint?
13:05:07 <quchen> Learning from the GIF people
13:05:25 <thoughtpolice> quchen: The first GHC release was in 1991, AFAIK
13:05:33 <quchen> bz: Nope. Because of that reason we don't have Monad Set, for example.
13:05:37 <thoughtpolice> About 1 year after the initial Haskell 1.0 report, I think
13:05:57 <bz> quchen: and yet it works for []
13:06:04 <quchen> bz: [] doesn't require Ord.
13:06:05 <Cale> (I'm of course joking about Miranda and the subsequent required trademark notices in various research papers)
13:06:12 <quchen> Ah.
13:06:25 <lpaste_> suppi pasted “hunit?” at http://lpaste.net/141153
13:06:25 <mizu_no_oto> quchen: the initial idea of "lets write haskell" was '87, the language report was in '90, and GHC was ~'92, looking at the timeline in that paper
13:06:33 <bz> well duh. the question is what the presence of Ord changes
13:06:41 <quchen> Hm. I'll stick with 87 then because that's easiest to remember for me.
13:06:41 <suppi> ^does this make sense to anyone?
13:07:52 <bz> suppi: what's your question? non-decimal literals are polymorphic so ghc has to default to Integer
13:08:09 <suppi> bz, not the warning, the result
13:08:23 <suppi> bz, 1 of 1 test suites (1 of 1 test cases) passed.
13:08:28 <suppi> so 1 == 2?
13:09:13 <Cale> suppi: Just paranoia: what happens if you write (1 :: Integer) in the source code instead? Should be the same...
13:09:49 <mizu_no_oto> quchen: searching through that paper, GHC development was started in '89, the first beta release was april 1st, '91, and GHC 1.0 was released december of '92.
13:09:59 <suppi> Cale, compiling without warning, same result
13:10:04 <Cale> okay, hmm
13:10:09 <ski> bz : the operations in `Monad m' promises to work for any types (of kind `*') being used as argument of `m', not just ones that happen to satisfy `Ord'
13:10:14 <thoughtpolice> bz: Because if your type needs 'Ord', you also have to thread 'Ord' through the constraints on the members of 'Monad', which can't be done. You can do it by defining your own class and abstracting over the set of constraints mentioned for the members, though
13:10:26 <Cale> suppi: and if you replace main with something completely different?
13:10:40 <thoughtpolice> bz: See the 'RMonad' example here - http://blog.omega-prime.co.uk/?p=127
13:10:55 <bz> why is main :: IO Counts, though
13:10:59 <Cale> suppi: like  main = putStrLn "Hello, world!"
13:11:21 <suppi> Cale, same result @_@
13:11:37 <suppi> I have to go, I will try tackling this tomorrow
13:11:37 <Cale> suppi: So you're not compiling the code you think you're compiling :)
13:11:41 <suppi> thanks for the help
13:11:46 <suppi> Cale, yeah, probably :)
13:11:49 <thoughtpolice> bz: Note that with RMonad, you don't just specify that 'return = S.singleton' for example, you also specify that the constraint that appears on the left side of => for each of these member functions is 'Ord a'. The typechecker can then allow this.
13:11:51 <suppi> we'll see tomorrow
13:11:54 <bz> 22:11:07 ~> stack runghc wtf.hs 
13:11:55 <suppi> thanks for the help
13:12:13 <bz> expected: 1
13:12:15 <bz>  but got: 2
13:12:40 <Cale> Or you're not *running* the code that you're actually compiling, is more likely.
13:14:45 <bz> thoughtpolice: that would work. but then RFunctor and RApplicative would have to be defined too, right?
13:15:28 <bz> also, is it still morally a monad with non-empty constraints?
13:17:00 <thoughtpolice> *shrug* I don't think there's anything 'morally' wrong with wanting Set to be a Monad. It just can't be so in the current design of `base`, so you're out of luck. As for the other stuff, yes, you'll have to define your own 'R'-ified AMP hierarchy. You'll also have to use RebindableSyntax and NoImplicitPrelude if you want 'do' syntax with these monads, but it
13:17:00 <thoughtpolice> does work.
13:17:48 <thoughtpolice> (Well, aside from the fact you also have to re-implement everything else in terms of RMonad - thems' are the breaks for restricted/indexed monads, as it stands.)
13:19:09 <hellertime> someone remember how to get cabal-install to look at non-standard include paths during a build?
13:19:53 * hackagebot connection-pool 0.1.2.1 - Connection pool built on top of resource-pool and streaming-commons.  https://hackage.haskell.org/package/connection-pool-0.1.2.1 (PeterTrsko)
13:20:02 <thoughtpolice> hellertime: --extra-include-dirs and --extra-lib-dirs
13:20:10 <thoughtpolice> You can pass those to either 'cabal install' or 'cabal configure'
13:20:37 <hellertime> thoughtpolice: that sounds like what I'm looking for thanks
13:20:47 <ski> hm .. i wonder which ordering is used on `Set a'
13:24:53 * hackagebot cqrs-core 0.10.0 - Command-Query Responsibility Segregation  https://hackage.haskell.org/package/cqrs-core-0.10.0 (BardurArantsson)
13:29:53 * hackagebot cqrs-testkit 0.10.0 - Command-Query Responsibility Segregation Test Support  https://hackage.haskell.org/package/cqrs-testkit-0.10.0 (BardurArantsson)
13:32:51 <ttt_fff> In Parsec, what is the difference between Text.Parsec.* and Text.ParserCombinators.* is one of them out-dated?
13:33:05 <ttt_fff> In Parsec, what is the difference between Text.Parsec.* and Text.ParserCombinators.*? Is one of them out-dated? (edit: correcting grammar)
13:34:53 * hackagebot cqrs-memory 0.10.0 - Memory backend for the cqrs package.  https://hackage.haskell.org/package/cqrs-memory-0.10.0 (BardurArantsson)
13:34:55 * hackagebot cqrs-postgresql 0.10.0 - PostgreSQL backend for the cqrs package.  https://hackage.haskell.org/package/cqrs-postgresql-0.10.0 (BardurArantsson)
13:35:43 <cocreature> ttt_fff: the docs say the latter is a compatibilty module so that's probably true :)
13:35:55 <Turion> I'm trying to implement a typeclass that is supposed to model the behaviour of an MVar, in an arbitrary Monad. So I have `class Monad m => MVarLike v m where ...` and then I have e.g. `newemptyvar :: m (v a)`. But if I let this appear in any function that doesn't have v in its type, I get errors like "Could not deduce (MVarLike v0 m)     from the context (MVarLike v m)". What can I do?
13:37:34 <ttt_fff> cocreature: Noted. Thanks!
13:39:54 * hackagebot cqrs-example 0.10.0 - Example for cqrs package  https://hackage.haskell.org/package/cqrs-example-0.10.0 (BardurArantsson)
13:39:56 * hackagebot gitlib 3.1.1 - API library for working with Git repositories  https://hackage.haskell.org/package/gitlib-3.1.1 (JohnWiegley)
13:39:58 * hackagebot gitlib-libgit2 3.1.1 - Libgit2 backend for gitlib  https://hackage.haskell.org/package/gitlib-libgit2-3.1.1 (JohnWiegley)
13:43:21 * frerich just optimized the loading time of his Haskell-based web app by successfully merging 15 consecutive SQL queries into a single clever query and thinks "Real Men Do It In One Trip"
13:44:05 <orion> If you're using postgres you could make a stored procedure and still get optimization benefits.
13:44:54 * hackagebot git-monitor 3.1.1.5 - Passively snapshots working tree changes efficiently.  https://hackage.haskell.org/package/git-monitor-3.1.1.5 (JohnWiegley)
13:47:23 <Welkin> frerich: that is one reason why ORMs are pretty useless
13:47:43 <Welkin> they offload all the heavy work to the application
13:47:44 <orion> ORMs are indeed terrible.
13:47:52 <Welkin> when the database can handle that itself
13:49:01 <frerich> Alas, I still need a nice Haskell'ish solution for composing (and constructing) SQL queries.
13:49:03 <orion> I suspect that the reason ORMs are popular is because SQL is a declarative language which makes imperative programmers squirm.
13:49:11 <Welkin> frerich: Opaleye?
13:49:27 <Welkin> when I actually bothered to properly learn SQL I was amazed at how nice it is
13:50:03 <frerich> Welkin: Hm, never heard of that, looks interesting. I wonder how well it works with MySQL.
13:50:16 <frerich> I found JMacro earlier today but it seemed... meh.
13:50:26 <Welkin> frerich: https://hackage.haskell.org/package/opaleye
13:50:35 <Welkin> frerich: it is only for Postgres
13:50:41 <Welkin> there is a version for sqlite too
13:50:55 <Welkin> I haven't used opaleye yet, but it looks nice
13:51:11 <Welkin> there is also Esqueleto (which requires Persistent)
13:51:19 <Welkin> that works with most SQL databases
13:51:40 <frerich> I'm hoping there's something which is reasonably type safe, not too far from plain SQL syntax (I'm hoping for a quasi quoter of some sort) and which supports interpolation and construction of queries without too much pain.
13:51:49 <Welkin> yeah, you want Esqueleto then
13:51:55 <frerich> I commonly construct queries at runtime using filters or limits specified by the user.
13:51:57 <Welkin> it is not fool-proof
13:52:04 <Welkin> but it is pretty close
13:52:37 <Welkin> frerich: https://hackage.haskell.org/package/esqueleto
13:52:38 * frerich inhales sharply as he realizes that persistent it snoyman-ware.
13:52:42 <Welkin> it has a good tutorial too
13:52:49 <Welkin> lol
13:52:52 <frerich> I have a love-hate relationship with anything surrounding Yesod :}
13:53:00 <Welkin> I love yesod
13:53:04 <frerich> I really like shakespeare
13:53:05 <Welkin> but I don't use it for everything
13:53:09 <sm> lol
13:53:12 <frerich> but I use scotty for the actual webserver.
13:53:18 <Welkin> you can use persistent without any of the other packages
13:53:47 <sm> snoyman makes good stuff
13:54:07 * frerich often uses the author as some sort of indicator what to expect - right now he's using mysql-simple by Bryan O'Sullivan, which is always a good sign to me :)
13:54:17 <statusfailed> I think there's a mistake in the servant tutorial, who do I ping? :-)
13:55:29 <srhb> statusfailed: #servant :)
13:55:54 <statusfailed> oh :D
13:56:47 <Welkin> I never knew bos wrote a mysql library
13:56:52 <Welkin> huh
13:57:02 <Welkin> I don't see why anyone would choose mysql over postgres though
13:57:14 <Clint> don't get me started
13:57:31 <geekosaur> because someone else chose it and that's what they must work with?
13:57:49 <geekosaur> <-- former DBA. don't get me started either
13:57:51 <frerich> Welkin: The backend is not actually under my... yeah, what geekosaur wrote. :-}
13:57:54 <Welkin> lol Clint 
13:58:28 <Welkin> geekosaur: then in that case, they did not choose it
13:58:48 <Welkin> so it doesn't answer my question, other than "it doesn't happen"
13:58:53 <BKnyte> afternoon y'all
13:59:16 <sm> nobody get started, breathe everybody
13:59:45 <BKnyte> just save everything to a text file.  Who needs fancy database tools anyway?  *ducks
13:59:53 <MotokoKusanagi> window splitv 50
13:59:55 <Welkin> BKnyte: sqlite?
14:00:10 <geekosaur> don't laugh. for simple tasks grep, awk, cut, paste, and join are sufficient
14:01:37 <geekosaur> and sort
14:01:59 <BKnyte> ehh, missed the first half of the discussion, just threw that in to stir y'all up
14:02:03 <orion> frerich: How do you like scotty?
14:02:36 <frerich> orion: It's the first web framework I ever used with Haskell (about two years ago) and I used it for all my projects since. It just hits the sweet spot for me.
14:02:39 <Welkin> geekosaur: do you have any advice concerning Haskell interfaces to databases, like Esqueleto, Opaleye, etc.?
14:02:50 <Cale> BKnyte: the fancy database tools aren't fancy enough anyway :(
14:02:50 <frerich> orion: I understand how it works, it does well for all my use cases and yeah - I'm a happy camper.
14:02:57 <Welkin> frerich: I can see the appeal in the simplicity
14:03:18 <frerich> orion: Plus, it says "Setting phasers to stun..." when starting up. What's not to like? :-)
14:03:29 <Welkin> frerich: really? haha
14:03:35 <frerich> Yeah :-)
14:03:36 <Welkin> I only tried spock
14:03:55 <Welkin> I didn't like it, but I suppose I was comparing it to yesod
14:04:02 <orion> frerich: Hah, yeah. I am using it in production, and I really enjoy the control I have. I get claustrophobia very easily when using web frameworks.
14:04:21 <frerich> I never did any Internet-facing web frontends though, it was always only internal stuff for the company. So it's not like I need to handle tens of thousands of clients or so.
14:04:30 <geekosaur> Welkin, no, sorry. I did say ex-dba :)
14:04:48 <geekosaur> have had little to do with databases since 1996
14:05:17 <orion> frerich: Here's one thing I am grappling with: https://github.com/scotty-web/scotty/issues/175
14:05:33 <Cale> We need a new SQL with at least sum types for columns
14:06:10 <Welkin> Cale: I noticed that was missing in a recent project
14:06:19 <Welkin> otherwise you have tons of null values everywhere
14:06:23 <Cale> I want to easily express the notion that I have a key into table A or a key into table B, and I know which, and it's not neither or both, and I want to be able to write sensible queries on that.
14:07:01 <Welkin> is there an easy way to avoid null values?
14:07:12 <Welkin> I want to avoid them if possible
14:07:37 <Welkin> I suppose some designs just won't work without null values though, because of the limitations of the db
14:07:50 <geekosaur> pity quel lost to sql
14:08:28 <Cale> Welkin: You can have the solution with multiple extra tables, but it's really not better.
14:09:03 <Cale> Well, maybe it's a little better? I dunno
14:10:23 <Cale> I mean, you can have a table C of just keys representing values of your sum type, and then a pair of tables, one with a C column and an A column, and the other with a C column and a B column.
14:10:34 <frerich> What's disappointing to me though is that in many cases, I end up pushing a lot of backend logic to some SQL server (for simplicity and performance) and a lot of frnt-end logic to the client side, into JavaScript (for interactivity and whatnot).
14:10:54 <frerich> So the Haskell part doesn't have a whole lot of meat after some time. Maybe I'm doing it wrong.
14:11:03 <geekosaur> you can always define a schema with all NOT NULL columns, and use tables to store the optional stuff. better to just think of Maybe types being default and NOT NULL for columns that aren't Maybe something
14:11:24 <Welkin> yeah
14:11:36 <Welkin> like in Persistent, when you define a schema, the default is NOT NULL
14:11:54 <Welkin> you must explicitly specify Maybe to make it nullable
14:12:34 <Welkin> but if you have a sum type you want to represent, such as data T = A | B | C
14:12:45 <Welkin> then you will need three tables, A, B and C
14:13:03 <geekosaur> sufficiently high end databases support enum types
14:13:39 <Welkin> and in another table you need to have 3 columns (A, B, C) that are either null or point to their respective table
14:13:49 <Welkin> that tables would be T
14:13:49 <geekosaur> (pretty sure that includes postgres and does not include mysql or sqlite)
14:13:54 <Welkin> table*
14:18:03 <geekosaur> if it has other values with the enum, that gets harder; this is something network databases could handle a bit better than relationals. or with postgres I think you can use the OO stuff to simulate it, with a bit of work
14:19:47 <magnap> Hi everyone! My code mysteriously gets a type error when I flip a certain function. In the following paste, lines 22 and 23 should be equivalent, but line 23 (uncommented) returns a type error http://lpaste.net/141156
14:20:43 <magnap> The error is Couldn't match type `MC.MC (GHC.ST.ST s0) (MonteCarloTree b)' with `forall s. MC.STMC s (MonteCarloTree b)'
14:27:21 <Gurkenglas> Very curious, @pl even gives the same output on both lines
14:28:43 <awpr> magnap: that's related to impredicative types; basically putting universal quantifiers ("forall") through combinators like flip will always instantiate them.
14:28:43 <Hafydd> magnap: did you change the type signature?
14:28:53 <merijn> edwardk: Ping? :)
14:28:57 <magnap> Hafydd: I did not
14:29:13 <Hafydd> Oh... well, your solution is above, anyway, it seems.
14:29:21 <magnap> awpr: Is there a way to fix that?
14:29:46 <merijn> Or ping to any other trifecta experts, I guess, if those exist :p
14:29:48 <awpr> magnap: if you really need to protect a forall, you can hide it under a newtype, but basically it's a known issue that working with universally quantified types is a bit awkward.
14:30:03 <magnap> awpr: Oh, well. Thanks for the help anyway :-)
14:31:22 <awpr> e.g. "newtype HiddenST a = HiddenST { unHide :: forall s. ST s a }".  I think there might be some way to force it to take the right type by sprinkling type annotations in the right places, but I haven't tried.
14:31:28 <mizu_no_oto> magnap: see http://stackoverflow.com/questions/9468963/runst-and-function-composition
14:31:59 <merijn> $ has special dirty impredicative hacks built into ghc :p
14:32:55 <magnap> That's frustrating! But I'll live with having to be slightly more pointfull sometimes
14:33:01 <quchen> merijn: "sudo unify"
14:33:10 <merijn> quchen: ?
14:33:15 <merijn> oh
14:33:18 <merijn> I get it :)
14:33:18 <quchen> :-)
14:34:35 <magnap> :/query lambdabot "@pl f x = x"
14:34:45 <magnap> Nooo, not here. Just testing, ignore that
14:34:56 * hackagebot nvim-hs 0.0.6 - Haskell plugin backend for neovim  https://hackage.haskell.org/package/nvim-hs-0.0.6 (saep)
14:34:58 * hackagebot nvim-hs-contrib 0.0.6 - Haskell plugin backend for neovim  https://hackage.haskell.org/package/nvim-hs-contrib-0.0.6 (saep)
14:39:57 * hackagebot monoid-extras 0.4.0.2 - Various extra monoid-related definitions and utilities  https://hackage.haskell.org/package/monoid-extras-0.4.0.2 (BrentYorgey)
14:49:57 * hackagebot dual-tree 0.2.0.7 - Rose trees with cached and accumulating monoidal annotations  https://hackage.haskell.org/package/dual-tree-0.2.0.7 (BrentYorgey)
14:59:56 <hexagoxel> why do some of the frp frameworks never even consider concurrency / running in multi-threaded contexts? i cannot grasp how you would implement a (simple?) use-case such as "push computation to separate thread, send progress notifications to gui" half of the time.
15:01:58 <merijn> The entire notion of threads is orthogonal to FRP
15:02:06 <hexagoxel> (although sodium seems to address my issues)
15:04:44 <hexagoxel> merijn: so most frp implemenations expect to run in a single thread?
15:05:09 <quchen> Orthogonal means "independent of".
15:05:12 <merijn> hexagoxel: No, but any threading is/should be internal
15:05:39 <merijn> hexagoxel: Being able to say "this should run in a separate thread" is completely counter to the semantics of FRP
15:05:52 <merijn> Because that's 100% operational thinking
15:06:06 <ReinH> "push computations to a separate thread" doesn't sound like FRP
15:07:50 <hexagoxel> but you could encapsulate the worker-thread using some "trigger computation"/"yield result" events/signals/behaviours/.., right?
15:08:35 <kristof> you mean a fork join?
15:08:37 <merijn> hexagoxel: The existence of threads, "triggering computation" and "yielding results" is also very nonFRP :)
15:08:39 <Rurik> why doesn't [1,2,4..] work
15:08:49 <delYsid`> Whats the meaning of ! in a datatype definition?
15:08:50 <merijn> Rurik: Only two start values
15:08:57 <kristof> Rurik: Try 1:2:[4..]
15:08:57 <Hafydd> Yielding results is un-FRP?!
15:09:08 <kristof> delYsid`: unboxed
15:09:08 <merijn> Rurik: [<start>,<next>..<end>]
15:09:19 <kristof> delYsid`: strict, unboxed.
15:09:20 <merijn> Rurik: Where step equals next-start
15:09:20 <Rurik> ah, gotcha
15:09:25 <merijn> And next is optional
15:09:40 <delYsid`> thanks
15:09:50 <merijn> Hafydd: Because FRP is about time-varying values. You can't "yield"
15:10:29 <merijn> kristof, delYsid`: It just means strict
15:10:36 <merijn> Unboxed is something entirely different
15:10:55 <hexagoxel> the worker "varies" a "result box" some period after the "input box" changed/triggered.
15:11:01 <hexagoxel> is that really not frp?
15:11:06 <kristof> who cares what frp is
15:11:08 <merijn> ! is standard haskell, {-# UNPACK #-} is a pragma that unboxes things
15:11:11 <kristof> ask the pope
15:11:15 <_d0t> how do I remove everything from a table using persistent?
15:11:41 <merijn> hexagoxel: No, not in the sense defined by Conal, although people seem to have stolen his term and coopted it into all sorts of different things
15:11:53 <merijn> hexagoxel: I can recommend the Push-Pull FRP paper, it's very good
15:12:06 <merijn> hexagoxel: http://conal.net/papers/push-pull-frp/
15:14:58 * hackagebot singletons 2.0 - A framework for generating singleton types  https://hackage.haskell.org/package/singletons-2.0 (RichardEisenberg)
15:16:00 <hexagoxel> merijn: ah, i had a brief look at that at some point today, but maybe got too borrowed in all the resourced around the topic. i will have another look, thanks.
15:17:05 <merijn> hexagoxel: The essence of FRP is that it defines a "denotational semantics", i.e. an abstract meaning of "time varying values" (i.e. events and behaviours). It's all about "what do they mean, abstractly" and what are the semantics of composing
15:17:16 <merijn> It says nothing about how to *implement* them
15:17:52 <merijn> The problem with "spawn a new thread" is that it presumes the existence of threads and addressing them. That is, very operational and specifying details that FRP is supposed to abstract from
15:20:40 <merijn> hexagoxel: Conal's papers are the best source to learn about "true" FRP, since
15:20:46 <merijn> @quote defun FRP
15:20:46 <lambdabot> defun says: [defun] conal: you seem knowledgable on the subject of FRP ... [conal] defun: btw, i invented frp.
15:23:02 <quchen> merijn: That paper you linked, would you say it's a good introduction to FRP? It's probably my number one blind spot I've dragged along 
15:23:16 <merijn> quchen: For you? Probably
15:23:27 <akegalj> can someone explain why is this 'Bad loop' ? I can't figure out myself https://www.reddit.com/r/haskell/comments/29nvsx/how_to_get_good_performance_when_processing/cinhemp
15:23:28 <merijn> The FRAN paper is the first one, but Push Pull was clearer to me
15:23:42 <quchen> I don't know who "I" am, so I'm going to go with the "probably" part. :-)
15:23:56 <merijn> Because it uses analogies to existing typeclases (Monad, Applicative, etc.) to explain semantics of Behavior and Event
15:24:20 <merijn> quchen: Someone who is already comfortable with Monad/Applicative/that sorta stuff
15:24:33 <merijn> Because those explanations don't help complete haskell n00bs :p
15:24:52 <quchen> merijn: Yeah one of the problems I've had with some tutorials was that they were essentially monad tutorials with a funny FRP hat ;-)
15:25:20 <merijn> quchen: Note that most libraries/frameworks advertised as FRP actually aren't :p
15:25:36 <quchen> merijn: I'd ask what FRP is but then you would just be repeating yourself.
15:25:54 <quchen> "Informally defined" is probably what FRP is.
15:25:58 <merijn> reactive-banana and sodium are, I think newest netwire is, but there's also a lot of close but not quite, things
15:26:05 <quchen> Hm.
15:26:13 <merijn> quchen: Conal's papers are actually pretty formal and thorough :p
15:26:34 <quchen> If you can give me the explanation in one sentence then go ahead, if not I don't want to waste your time talking about things I don't know enough.
15:26:55 <merijn> quchen: "Time as first class notion" :)
15:27:10 <quchen> … is something required for FRP?
15:27:11 <quchen> Or not
15:27:19 <merijn> And thus, also things like "time-varying vaues"
15:27:25 <merijn> quchen: FRP *is* time as first class notion
15:27:33 <merijn> That's what it tries to define/describe
15:27:33 <quchen> Oh.
15:27:51 <merijn> i.e. what does it mean for values to be "time-varying"
15:28:51 <quchen> And many libraries model around that, instead of implementing it?
15:28:58 <quchen> … if that makes sense
15:29:09 <hexagoxel> merijn: but even if it abstracts away from "operational stuff", it must be possible to make the connection at some point. e.g. many examples somewhere along the line connect a "block until user clicks something" to the abstract "user-input-event".
15:29:11 <merijn> Many libraries end up introducing explicit stepping
15:29:34 <merijn> Which is much easier to do efficiently, but also less expressive
15:29:43 <quchen> akegalj: Do you know DLists?
15:29:57 <quchen> merijn: I see. I'll keep an eye out for that then.
15:34:12 <hexagoxel> merijn: which implementation is close to the "pure"/conal frp?
15:34:33 <merijn> Those I just mentioned, plus reactive (probably bitrotted)
15:34:38 <merijn> Might be more, but I dunno
15:42:35 <ReinH> quchen: more like FRP was formally defined and then that definition was subsequently ignored ;)
15:44:16 <dgpratt> #haskell-emacs is a little too quiet :(
15:44:50 <dgpratt> does anyone use spacemacs for haskell? I'm wondering how the auto-complete functionality is supposed to work
15:45:05 <slack1256> i do
15:45:23 <dgpratt> slack1256, does it automatically auto-complete as you type?
15:45:36 <ReinH> dgpratt: it uses company-mode
15:45:40 <ReinH> (by default)
15:45:55 <ReinH> dgpratt: you need to include the auto-completion layer
15:46:00 <dgpratt> ReinH, included
15:46:01 <slack1256> but I don't use ghc-mod nor hlint. Just pure spacemacs and a terminal with ghci/hoogle
15:46:31 <dgpratt> ReinH, I think I just don't understand yet how to use it or what it's supposed to do
15:46:47 <slack1256> being fair, I use nix and nix-shell to set up a good environment, then when launching spacemacs inside of it "everything just works". But it can be complicated to play correctly without it
15:47:38 <dgpratt> e.g. in VS, in any context where I'm typing the name of something, I get "intellisense" automatically
15:47:53 <dgpratt> not sure if I should expect the same here
15:48:18 <slack1256> yeah, company does that
15:48:24 <slack1256> company-ghc I mean
15:48:26 <dgpratt> hmm
15:48:40 <ReinH> dgpratt: you should, yes
15:48:47 <slack1256> but templates are provided by yasnippet (which the haskell layer set correctly)
15:49:02 <slack1256> they are triggered with M-/ I think
15:49:54 <dgpratt> oh, hold up
15:50:00 * hackagebot sbp 0.50.7 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-0.50.7 (mookerji)
15:50:04 <dgpratt> I think it's working
15:50:17 <dgpratt> as I expected, a mis-understanding of how it works
15:50:57 <dgpratt> #unnecessary-hyphenation
15:51:25 <Hafydd> #un-necessary-hyphenation
15:51:31 <dgpratt> lol
15:51:39 <quchen> ReinH: "combinator" comes to mind
15:52:34 <dgpratt> from VS-land, my expectation would be that if I typed "foo = ", that would be enough to trigger an autocompletion popup
15:53:20 <slack1256> I guess there is somewhere an option for "always" trigger such completions
15:53:23 <dgpratt> but typing something like "foo = T." *does* trigger autocompletion
15:54:20 <dgpratt> is there a shortcut for triggering it?
15:55:08 <dgpratt> I didn't see anything on the company-ghc project page
15:56:21 <dgpratt> oh, just found it on the company-mode  project page
15:56:55 <dgpratt> looks like I need to figure out how to create a key binding, but that's not #haskell, is it?
15:57:35 <dgpratt> thanks for the help, guys
16:08:24 <ttt_fff> is there a tutorial on how to use https://hackage.haskell.org/package/indents-0.3.3/docs/Text-Parsec-Indent.html ?
16:13:04 <Gurkenglas> I would like to have there be a website that provides UI for "modify . (:)" and "gets . filter", such that the state is shared between everyone accessing the website, and persistent. How would I go about this?
16:17:52 <cads> hey guys
16:18:42 <Gurkenglas> cads, cut out the preliminaries :D
16:18:56 <aweinstock> :t modifyMVar
16:18:57 <lambdabot> Not in scope: ‘modifyMVar’
16:19:29 <aweinstock> :t Control.Concurrent.modifyMVar_
16:19:30 <lambdabot> GHC.MVar.MVar a -> (a -> IO a) -> IO ()
16:20:00 <Axman6> cads: what Gurkenglas means is "Welcome!"
16:20:39 <Gurkenglas> He's been here before, I'm not gonna scare him off that easily.
16:20:54 <cads> hey all
16:20:55 <aweinstock> Gurkenglas: have post requests to the "add item" thing use modifyMVar to poke some server state, and have the "get item" accessed via get requests (with the filter predicate via query strings), and read that server state?
16:21:02 <cads> what you guys up to?
16:21:46 <Axman6> waiting for people to ask questions about haskell
16:21:51 <Axman6> do you have some?
16:22:17 <cads> No :)
16:22:22 <Welkin> Axman6: What're ya buyin'? What're yer sellin'?
16:22:54 <Axman6> I got some fiiine answers in my trunk
16:23:26 <Welkin> trenchcoat*
16:23:34 <Axman6> come look, first one's free
16:24:53 <Gurkenglas> aweinstock, sounds good in theory, but how do I get an actual website set up with that when my home machine isn't on 24/7 and this just ceased to be a Haskell question didn't it
16:25:58 <Welkin> Gurkenglas: digital ocean vps
16:26:11 <Welkin> cheap and simple
16:27:36 <Gurkenglas> Hm, 5 bucks a month. Does it go cheaper? What I aim for would be as load-bearing as, say, a wiki entry
16:27:49 <cads> Anyone know if there are any graphical algorithm editors for haskell?
16:27:51 <Welkin> oh, you want a static site?
16:28:12 <Gurkenglas> Not quite, it does have to access a shared state :I
16:28:17 <Axman6> just stick it in S3 and use Route 53 for DNS
16:28:24 <Axman6> or not
16:28:25 <ttt_fff> Does Parsec ExpressionParser work together with indentation parser ?
16:28:26 <Welkin> lol
16:28:45 <Welkin> Gurkenglas: $5/month is super cheap
16:28:53 <Welkin> I have not found anything cheaper for a decent vps
16:28:55 <emc2> does anyone know if any of edwardk's talks on morton-ordered sparse matrix multiply are posted anywhere
16:28:56 <ttt_fff> I need a tutorial where indentation parsing + expression parsing working together.
16:29:10 <Welkin> you can put several sites on the same server
16:29:49 <Gurkenglas> Who needs decent? 512 MB, 1 Core, 20 GB and 1 TB of transfer sounds enough for 100 of people like me. Except maybe that the haskell runtime takes some ram :I...
16:29:56 <Welkin> actually, I need to move one of my applications off of aws
16:30:05 <Welkin> it is costing me almost $30/month
16:30:28 <Welkin> Gurkenglas: well, you wouldn't compile on that kind of machine
16:30:32 <Welkin> you just upload the binaries
16:30:33 <kadoban> Welkin: Not exactly a VPS, but: https://www.nearlyfreespeech.net/ <-- these guys are cheap as hell and great. I pay like … $0.03 cents a month for my personal site, and it scales nicely.
16:30:48 <kadoban> s/cents//
16:30:48 <Gurkenglas> How much ram does a hello world binary take?
16:31:31 <Hafydd> Our service includes all your favorite features!  PHP 5.4 / 5.5 / 5.6  Advanced web frameworks: Django, Node.JS, Ruby on Rails, and many more
16:31:41 <Welkin> "advanced"
16:31:43 <Hafydd> Oh wow, PHP 5.4 AND 5.5 AND 5.6?
16:31:56 <emc2> nevermind, found it
16:32:30 <Rurik> ghci says something like
16:32:38 <Rurik> In the definition of `it': it = ...
16:32:43 <Rurik> why does it say that
16:33:14 <arkeet> because everything you evaluate in ghci gets bound to a variable called 'it'
16:33:16 <kadoban> Hafydd: You can throw any of the haskell frameworks on there :) And GHC is installed.
16:33:22 <Hafydd> That would probably be because it assigns each expression to the variable "it", so you can write something like this:
16:33:33 <Hafydd> Prelude> 5
16:33:34 <Hafydd> 5
16:33:34 <Hafydd> Prelude> succ it
16:33:34 <Hafydd> 6
16:34:03 <Rurik> ah, cool
16:34:20 <Hafydd> kadoban: is it? Interesting.
16:35:36 <thomasd> is anyone here familiar with the LLVM bindings in Haskell?
16:35:42 <thomasd> or LLVM in general?
16:35:49 <Gurkenglas> kadoban, that sounds like what I want, thanks
16:36:02 <kadoban> 'welcome
16:37:04 <nshepperd> Gurkenglas: if you want a cheap vps, something good comes up on lowendbox.com every once in a while
16:38:06 <emc2> use llvm-general
16:38:15 <emc2> the old LLVM bindings library is way out of date
16:38:46 <Welkin> kadoban: digital ocean is still cheaper based on what you get
16:38:59 <Welkin> compared to nearlyfreespeech
16:39:43 <kadoban> Welkin: Probably. Most places are if you actually get what they promise and you use /exactly/ the max.
16:39:55 <Sonolin> ghc is installed? what vps is that :o
16:40:29 <kadoban> It works great for me though, I do a bunch of pretty tiny, low traffic sites, and don't really have any interest in managing my own sysadmin stuff in detail.
16:43:02 <emc2> though llvm-general is now a couple of versions behind
16:44:44 <edwardk> emc2: there are two on youtube
16:45:17 <edwardk> emc2: https://www.youtube.com/watch?v=uA0Z7_4J7u8 and https://www.youtube.com/watch?v=sdHXaYCX3RE
16:45:45 <edwardk> emc2: the former was filmed at Prezi in Budapest, the latter was filmed at Johns Hopkins
16:47:11 <kadoban> Sonolin: Oh, my link above. It's not exactly a VPS though.
16:50:29 <ttt_fff> okay
16:50:34 <ttt_fff> so parsec has "indents" whican can do layout parsing
16:50:48 <ttt_fff> and Parser Expressions, which can parse expressions with infix/left/right associativity
16:50:51 <ttt_fff> is there a way to combine the two?
16:59:43 <stapler> time to start writing haskell i guess
17:27:08 * voidzero unplugs bitemyapp
17:30:04 * hackagebot fasta 0.8.0.2 - A simple, mindless parser for fasta files.  https://hackage.haskell.org/package/fasta-0.8.0.2 (GregorySchwartz)
17:51:33 <Rurik> How do I read this? λ: read "5" :: Int ; read "5" is a type of Int ?
17:52:08 <scshunt> Rurik: do you mean to read it aloud, or do you just not understand the code?
17:52:15 <Rurik> read it aloud
17:52:42 <scshunt> I would probably say "read 5 cast to int" or "read 5 as an int"
17:52:52 <feryll_> Quick cabal issue, I have mandatory sandboxes set, but when I type "cabal --no-require-sandbox install foo" it still complains that there's no sandbox in the cd.
17:53:03 <Rurik> scshunt, makes sense
17:53:06 <mniip> scshunt, "cast" gives the wrong meaning
17:54:16 <Lynn> "as an Int" is exactly what it is, IMO.
17:54:35 <mniip> right
17:55:49 <arkeet> or "with type Int" maybe.
17:56:05 <stapler> trying to break into haskell here! how can i add something to a list and access the modified list later through a scotty handler
17:56:09 <stapler> wish i could phrase that better but..
17:56:21 <mniip> there is no modification!
17:56:23 <scshunt> ^
17:56:34 <mniip> </pedantry>
17:58:10 <Hafydd> Error: closing tag </pedantry> without an opening tag.
17:58:59 <mniip> Hafydd, you haven't scrolled up enough
18:01:29 <Hafydd> mniip: in my 3 years of logs, I can only see two more </pedantry> closing tags prior.
18:01:34 <MarcelineVQ> stapler: You can use ++ to glue lists together, or you can use : to add an element to the front of a list 'a':"bc" = "abc" I don't know anything about scotty. You can learn about lists here http://learnyouahaskell.com/starting-out#an-intro-to-lists
18:03:33 <stapler> MarcelineVQ: i know that much
18:03:39 <stapler> its just accessing the updated list 
18:04:09 <feryll_> stapler: What mniip means about no modification, if you aren't aware, is that Haskell isn't an object-oriented language where you can just say A.append(x) and A will look different later on in the code
18:04:39 <stapler> yes
18:04:40 <feryll_> If you want to use the object (x:xs) later, you have to explicitly say (x:xs)
18:04:40 <stapler> i know
18:04:45 <stapler> thats why im asking what i should do!
18:04:51 <mniip> well if you're old enough you can learn about iorefs and mutablebytearray
18:05:31 <feryll_> Well, what's the case you're trying to do?
18:05:52 <feryll_> It's a paradigmatic issue here, like asking how to say "is" in Russian.
18:06:05 <MarcelineVQ> Hmm, it sounds to me like you need to learn about doing IO, because it'll teach you the parts needed to do what you're after along the way.
18:06:32 <mniip> feryll_, "являться" is almost always semantically correct
18:06:55 <MarcelineVQ> Does anyone know of a well rounded tutorial for IO?
18:07:08 <feryll_> mniip: Oh how I didn't expect to be called out on that fact.
18:07:34 <stapler> MarcelineVQ: i do know how to do io, heh
18:08:18 <feryll_> mniip: But I retort saying that only a practitioner of the hard sciences could see являться == to be
18:08:25 <MarcelineVQ> If that's the case I'm not sure what you're asking at all
18:09:02 <stapler> i have a list that i want to add too on a POST request, and get that list on a GET request.
18:09:15 <stapler> i don't know how to translate this into the functional paradigm.
18:09:21 <mniip> feryll_, I haven't yet found a sentence where a direct translation would put the word in a semantically incorrect context
18:10:06 * hackagebot sbp 0.50.8 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-0.50.8 (markfine)
18:10:15 <Shockk> stapler: it depends on how you get those POST and GET requests
18:10:24 <tangentbundler> hey everyone, having an FFI problem here
18:10:29 <Shockk> like, what interface you have for being able to handle them
18:10:36 <feryll_> mniip: являться is awfully formal even as a translation as a copula, but still other uses; "He is running," "There is an apple"
18:10:52 <zaquest> feryll_, mniip, i wonder if #haskell people are so smart that they casually discuss russian language, or it's just you two are russians? :D
18:11:24 <feryll_> zaquest: I brought it up, so you can blame the rest of mniip's self-proclaimed pedantry I suppose
18:11:28 <feryll_> on*
18:11:32 <mniip> feryll_, the first sentence is okay if you translate "running" as a participle
18:11:47 <Gurkenglas> iirc it's about as formal as "has the property of"
18:11:48 <mniip> in the second sentence "there is" does make a single syntactic construct
18:11:50 <tangentbundler> wondering if anyone knows the fastest way to allocate data across an FFI
18:12:14 <tangentbundler> the fastest way I know if is unsafeUseAsCString, and it's pretty slow
18:12:24 <stapler> Shockk: right now im using scotty
18:12:51 <tangentbundler> scotty? the web framework?
18:13:06 <stapler> tangentbundler: yes.
18:13:37 <tangentbundler> ok... is this related to the FFI topic? 
18:14:49 <stapler> tangentbundler: nope.
18:15:06 <feryll_> mniip: All right, how about if someone at #russian asked how to apply f to each element in a list xs, and someone responded foldl (\acc x -> f x : acc) [] xs? :p
18:15:11 <Shockk> stapler: hmm okay so you use 'get' to add a route for GET, right?
18:15:22 <stapler> yes
18:16:03 <nshepperd> tangentbundler: Storable vectors? I don't know how fast they are
18:16:17 <tangentbundler> yeah I've tried storable vectors
18:16:38 <tangentbundler> as in, a string passed as a vector of storable chars
18:17:07 <tangentbundler> also tried using ByteString.Unsafe
18:17:43 <hardmath123> Quick question, do the contents of a list comprehension ever affect its length? I'm getting some very strange behavior. See http://lpaste.net/141158
18:17:43 <Shockk> stapler: 'get' is in the monad 'ScottyM', which is a type alias for ScottyT Text IO, and what I'm thinking your best bet would be is to use an IORef or MVar or similar
18:18:04 <Cooler> hello
18:18:24 <hardmath123> the only difference is the function-to-be-evaluated of the comprehension, but for some reason, replacing `1` with the function makes the result empty.
18:18:34 <stapler> Shockk:  i see
18:18:47 <Shockk> create the IORef or MVar before you do 'post' and 'get', and apply that to the functions you give to each of those
18:18:48 <Cooler> i am trying to learn haskell and i am not sure how to use the main function
18:19:51 <nshepperd> hardmath123: ...any chance Show for your clause type would return the empty string?
18:20:02 <mniip> feryll_, fix $ ($null) . liftA2 (bool[]) . (liftA2 (:) (f.head) . (. tail))
18:20:24 <Shockk> MVar may be the best to use as it's synchronized
18:20:27 <feryll_> mniip: Exactly, you'd correct them!
18:20:31 <Shockk> (thread-safe I believe)
18:20:50 <mniip> :t fix $ ($null) . liftA2 (bool[]) . (liftA2 (:) (f.head) . (. tail))
18:20:51 <lambdabot>     Ambiguous occurrence ‘f’
18:20:51 <lambdabot>     It could refer to either ‘L.f’,
18:20:51 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:148:1
18:20:57 <mniip> :t fix $ ($null) . liftA2 (bool[]) . (liftA2 (:) (?f.head) . (. tail))
18:20:58 <lambdabot> (?f::a -> t) => [a] -> [t]
18:21:03 <mniip> yup, correct type
18:21:13 <Shockk> stapler: in your post function, you would use modifyMVar_
18:21:37 <stapler> Shockk:  and real quickly, how does the type def of ScottyM work?
18:21:43 <feryll_> Cooler: What don't you get about main?
18:21:51 <stapler> i was under the impression that it was like transformer, monad, type
18:21:57 <feryll_> Or is your issue with IO functions in general?
18:22:20 <feryll_> Well, monads in general likely
18:22:40 <Shockk> stapler: type ScottyM = ScottyT Text IO,
18:22:44 <mniip> monads have nothing to do with IO
18:22:52 <mniip> well other than they intersect
18:23:03 <hardmath123> nshepperd: dang, that's it. thanks, i would never have figured that one out. :)
18:23:08 <Cooler> this is the code
18:23:09 <Cooler> http://pastebin.com/NrbJ1KVn
18:23:16 <Shockk> stapler: newtype ScottyT e m a = ScottyT {runS :: State (ScottyState e m) a }
18:23:27 <Cooler> its a simple quicksort program
18:23:36 <Shockk> so it seems to be a transformer using State
18:23:43 <stapler> ah
18:23:47 <mniip> Cooler, that's not a quicksort
18:23:48 <stapler> Shockk: i see...
18:23:56 <mniip> it's a mergesort
18:23:57 <Cooler> i know i get a lot of errors
18:24:06 <Shockk> my guess is that the type variable e, which is Text for ScottyM, is the error type
18:24:17 <feryll_> Cooler: If you wanted to show the results of the program, for example, you'd do "print $ qsort $ listOfNums"
18:24:22 <Shockk> ah, yes it is
18:24:35 <mniip> Cooler, the last statement in the do block determines the return type of the block
18:24:37 <Shockk> in ScottyState, e is used for handler :: ErrorHandler e m
18:24:43 <mniip> main expects it to be IO ()
18:24:51 <stapler> Shockk:  so a is () when its like uh ScottyM ()
18:24:52 <stapler> right
18:24:53 <mniip> whereas 'qsort listOfNums' has type [Int]
18:25:01 <feryll_> Or if you wanted main to output "qsort $ listOfNums" as a result, you'd do "return $ qsort $ listOfNums"
18:25:11 <Shockk> stapler: e *
18:25:19 <stapler> !
18:25:21 <Shockk> oh
18:25:22 <Shockk> I misread
18:25:37 <Shockk> that's tright
18:25:39 <Shockk> right*
18:25:53 <Cooler> i am getting "parse error on input module"
18:25:59 <Shockk> 'a' there is just the result type, like you have IO () or IO String or whatever
18:26:04 <mniip> Cooler, you can't have multiple modules in one file
18:26:05 <feryll_> Basically, you have to get the results of pure functions into an IO context, however you want to use them (as input, for printing, etc)
18:26:21 <mniip> Cooler, you probably want the module header to be at the top
18:26:22 <stapler> right right right
18:26:37 <stapler> Shockk: so basically i should look into mvars
18:26:39 <Cooler> multiple modules? theres only one main
18:27:02 <Shockk> stapler: that's what I'd suggest, unless there's a better way to do that
18:27:45 <Shockk> stapler: an MVar can be empty or full, and when you do takeMVar, it waits until it's full; similarly when you do putMVar, it waits until it's empty
18:27:47 <stapler> Shockk: use a database maybe?
18:27:48 <stapler> haha
18:28:37 <Shockk> I believe modifyMVar_/modifyMVar take the MVar, map over it, and put the MVar back
18:29:45 <Shockk> so if you have an MVar [String] for example, in your POST handler, you could simply do 'modifyMVar_ m (newString :)'
18:30:02 <stapler> Shockk:  now what do MVars have to do with IO?
18:30:24 <Shockk> MVar operations are done in IO
18:30:40 <stapler> ah, ok.
18:31:35 <Shockk> just because it's a mutable variable that's intended to be able to be accessed from a different part of the program, which you kind of need to be in IO to do
18:32:30 <Cooler> i am not sure what you mean by mutliple modules
18:32:47 <Shockk> stapler: in your GET handler you can also use readMVar rather than simply takeMVar
18:33:04 <Shockk> to read it without emptying it
18:33:14 <stapler> Shockk:  but how could i pass the mvar into it?
18:33:19 <lpaste_> echo-area pasted “mapEither” at http://lpaste.net/141160
18:33:32 <Shockk> stapler: if your get handler is defined like idk,
18:33:41 <Shockk> one sec
18:33:57 <Gurkenglas> @letlpaste 141160
18:33:59 <lambdabot>  Defined.
18:34:10 <Shockk> how is your get handler defined? like, what's the type of it?
18:34:16 <Gurkenglas> :t [mapEither, traverse] -- echo-area
18:34:17 <lambdabot> [(a -> Either e b) -> [a] -> Either e [b]]
18:34:35 <Shockk> just something like getH :: ActionM () ?
18:34:39 <stapler> Shockk: ActionM ()
18:34:45 <Shockk> okay, so if you're adding that like:
18:34:46 <stapler> yeah
18:34:53 <echo-area> Hi, this mapEither function is using too much memory, how to improve it?  I checked its core code, but didn't find a clue
18:34:58 <Shockk> 'get routePattern getH'
18:35:14 <feryll_> So this should be a stupid question, why does "cabal --no-require-sandbox install foo" still complain about sandboxes?
18:35:20 <Shockk> you can simply make getH :: MVar [String] -> ActionM ()
18:35:28 <Shockk> and do 'get routePattern (getH m)'
18:35:37 <Shockk> because haskell and partial application
18:35:49 <Shockk> because haskell and how application works*
18:38:07 <Shockk> stapler: does that make sense?
18:38:24 <stapler> Shockk: yeah
18:38:28 <stapler> it does actually :-)
18:39:03 <Shockk> great
18:40:17 <giantwaffelcat> is there a cabal command to add a requirement for a package and install it?
18:40:41 <Shockk> I actually had that same question about a year ago when I was using forkIO and I needed to get a Channel to the function I was using, so it could communicate data back to the main function
18:41:14 <Shockk> and then someone pointed out I could simply apply the channel to the function because application
18:41:37 <Cooler> i keep getting parse error at input Module
18:41:48 <Shockk> lowercase m?
18:44:17 <Cooler> http://pastebin.com/vVtxgg5E
18:44:20 <Cooler> this is the new code
18:44:34 <Cooler> i am getting a lot of errors
18:45:14 <Shockk> your second pattern for qsort is attempting to match [x:xs], but x:xs itself constructs a list
18:45:16 <Cooler> http://pastebin.com/tkrUzJTx
18:45:25 <Shockk> so that's attempting to match a list containing a list of x:xs
18:45:31 <Shockk> you want to match (x:xs)
18:45:56 <Cooler> whats the difference?
18:46:27 <MarcelineVQ> [x] vs [[x]]
18:46:36 <Shockk> the brackets around x:xs are simply so it's parsed as qsort (x:xs) rather than (qsort x) : xs)
18:46:57 <Shockk> so imagine it as just: qsort    x:xs
18:47:12 <Shockk> so if you're doing: qsort   [x:xs]
18:47:13 <Cooler> what does the sqaure brackets do?
18:47:21 <Shockk> [...] is a list
18:47:32 <carrotlord> it is?
18:47:33 <Shockk> something:list is also a list
18:47:48 <Cooler> wait so its correct? the input is a list
18:47:50 <carrotlord> [[], [], [], []] as [[List]] or something
18:47:52 <Gurkenglas> echo-area, if you run out of memory because the list is too large, note that you cannot access the first element of the list before the last element is traversed, because that one might return left and then there is no list in the first place. That means the whole list will be loaded into memory. You might be able to do something using two passes, or by strictly folding the resulting [b] while traversing the [a].
18:47:58 <carrotlord> [[a]]
18:48:04 <nshepperd> :t [x]
18:48:05 <lambdabot> [Expr]
18:48:07 <nshepperd> :t [x:y]
18:48:08 <lambdabot>     Couldn't match expected type ‘[Expr]’ with actual type ‘Expr’
18:48:08 <lambdabot>     In the second argument of ‘(:)’, namely ‘y’
18:48:08 <lambdabot>     In the expression: x : y
18:48:11 <nshepperd> bah
18:48:18 <RouxTheDay> Anyone here have experience with HNN? I'm running into a strange bug where the weights go to infinity, would love to hash it out with anyone that has more experience with HNN, or neural nets in general
18:48:18 <Shockk> Cooler: okay, if I've got a list called list, and I've got a number I want to put onto it
18:48:24 <nshepperd> :t [x:[]]
18:48:25 <lambdabot> [[Expr]]
18:48:28 <Cooler> the input for the function is a list to be sorted, so shouldn't i be using square brackets?
18:48:32 <nshepperd> Cooler: ^^
18:48:47 <Shockk> I can do:  let newList = number : oldList
18:48:58 <nshepperd> Cooler: [x:xs] makes a list of lists
18:49:09 <Cooler> how does it know xs is a list?
18:49:13 <Shockk> the colon puts something onto the existing list to make a new list with that something
18:49:29 <Shockk> so when you do x:xs, that whole expression is a list
18:49:42 <Shockk> when you do [x:xs], that whole expression is a [list], which you can also say is a list of lists
18:50:18 <ReinH> Cooler: : is the constructor for lists, so x:xs can only be a list. Also the type system knows it's a list.
18:50:21 <MarcelineVQ> :t (:)
18:50:22 <lambdabot> a -> [a] -> [a]
18:50:24 <Shockk> the input for the function is a list to be sorted, yes
18:50:31 <Shockk> so you don't want it to be a list of lists
18:50:33 <echo-area> Gurkenglas: I tried traverse but it performed worse than mapEither.  I'm stilling working on it
18:50:36 <Shockk> you just want a list
18:50:54 <Cooler> ok
18:50:55 <Shockk> which something:restOfList is
18:51:03 <Cooler> i am getting parse error at where now
18:51:22 <Gurkenglas> echo-area, abort your work and read the above.
18:51:31 <echo-area> Okay
18:51:52 <Shockk> using [something:restOfList] though, tries to pattern match for a list containing (something:restOfList)
18:52:01 <Shockk> that last part, you know is a list, so a list containing a list
18:52:13 <Shockk> so rather than using [something:restOfList], you'd just want to use (something:restOfList)
18:52:35 <Shockk> the ( ) simply being for it to parse correctly like I said earlier
18:52:56 <echo-area> Gurkenglas: Got it, let me try
18:53:00 <Cooler> i got it
18:53:12 <Cooler> why am i getting an parse error on input where
18:53:31 <ReinH> Cooler: well, what's the error?
18:53:44 <Cooler> that is the error, thats all it says
18:53:52 <Cooler> testinghs.hs:5:1: parse error on input ‘where’
18:53:53 <ReinH> It says "an parse error on input where?
18:53:56 <ReinH> I don't ebelieve you.
18:54:08 <ReinH> Cooler: use lpaste to show us the code and the error
18:54:29 <Cooler> the code is the same pastebin as above
18:54:41 <Cooler> i just changed the sqaure brackets to ()
18:56:07 <ReinH> are you using tabs?
18:56:36 <Cooler> tabs?
18:56:45 <ReinH> instead of spaces?
18:57:04 <Cooler> what?
18:57:23 <ReinH> Are you using tabs or spaces for indentation?
18:57:24 <Shockk> the whitespace before the `where`, which indents the line
18:57:38 <Shockk> that could be space characters or a tab character
18:57:39 <Cooler> oh
18:57:46 <Cooler> it cares about identation?
18:58:07 <ReinH> yes
18:58:08 <Shockk> I think it requires you use spaces 
18:58:13 <ReinH> no
18:58:15 <KaneTW> no
18:58:20 <ReinH> it treats tabs as 8 spaces
18:58:28 <Cooler> i put a tab and now it works
18:58:35 <ReinH> No, don't use tabs
18:58:39 <Cooler> but i also get a warning
18:58:39 <Cooler> testinghs.hs:5:1: Warning: Tab character
18:58:53 <ReinH> The code you pasted with the change parses for me
18:58:57 <ReinH> So you must be doing something else
18:59:12 <KaneTW> it seems to treat tabs as actual tabs
18:59:20 <Cooler> no it works after i put a tab before the where
18:59:27 <Cooler> i just get the warning
18:59:31 <ReinH> Don't use tabs.
18:59:36 <KaneTW> don't use tabs
18:59:41 <Shockk> are you using tabs for the other three lines already?
18:59:43 <KaneTW> goddamn i'm delayed today
18:59:48 <Cooler> yeah
18:59:50 <Shockk> I wonder if you're mixing spaces and tabs in different lines
18:59:52 <ReinH> Use spaces everywhere.
18:59:56 <Cooler> ok
19:00:10 <ReinH> GHC treats a tab character as 8 spaces for determining indentation
19:00:34 <ReinH> if your editor treats it differently, as many do, then it will cause confusion and parse errors.
19:00:44 <KaneTW> ReinH: i mixed indentation and it seemed to treat 8spc, tab and <8spc+tab identically
19:00:46 <ReinH> The easiest solution is just to not use tabs
19:01:05 <Cooler> where do you have to put identation?
19:01:11 <ReinH> KaneTW: perhaps it uses the next tabstop. I'm not sure, since I don't use tabs.
19:01:15 <KaneTW> yeah
19:01:17 <KaneTW> i had to test
19:01:20 <ReinH> @google haskell indentation
19:01:21 <lambdabot> https://en.wikibooks.org/wiki/Haskell/Indentation
19:01:22 <KaneTW> i don't use tabs either
19:01:32 <Cooler> is there a way to disable that?
19:01:35 <ReinH> Cooler: Haskell has some rules for whitespace. There aren't many so it's best to just learn them.
19:01:38 <ReinH> Cooler: No.
19:01:40 <ReinH> Well, yes.
19:01:44 <ReinH> You can use {} instead.
19:01:51 <KaneTW> you shouldn't though
19:01:52 <ReinH> indentation is sugar for {} and ;
19:01:57 <ReinH> But you should use indentation
19:02:11 <Cooler> why does it give an error instead of a warning?
19:02:18 <KaneTW> because it can't parse it
19:02:18 <ReinH> "it"?
19:02:27 <ReinH> I parse error is an error.
19:02:30 <ReinH> s/I/a
19:03:42 <ReinH> Literally everyone who uses haskell uses indentation except for a single exception who we tolerate because he also designed the language.
19:03:50 <ReinH> And even he uses indentation in most places.
19:04:55 <ReinH> In fact he doesn't even use braces to avoid indentation.
19:10:05 <slack1256> what is the current status of backpack? I haven't seen a blogpost in a while
19:10:19 <slack1256> well ezyang is a busy man
19:12:18 <Cooler> why did you guys say it was merge sort?
19:12:25 <Cooler> it looks like quicksort
19:13:02 <KaneTW> hm?
19:14:07 <Cooler> http://pastebin.com/FwshRXZs
19:14:13 <Cooler> this is quicksort isn't it?
19:15:02 <KaneTW> looks like it
19:15:09 <KaneTW> it's not entirely correct
19:15:37 <KaneTW> but the partitioning is there
19:16:35 <Cooler> what do you mean?
19:17:27 <KaneTW> oh you do mid a bit weirdly
19:17:38 <KaneTW> nah it seems fine, was confused by the list comprehension in mid for a moment
19:18:50 <ReinH> slack1256: He gave a talk about it at ICFP, there might be a video
19:18:56 <ReinH> they've been uploaded to youtube
19:19:18 <ReinH> Cooler: it has a similar shape to quicksort
19:19:57 <ReinH> Merge sort is different (although nicer for a functional language)
19:20:09 <Gurkenglas> Requesting "(Enum a, Bounded a) => (b -> a) -> [b] -> [[b]]" or something like it.
19:20:29 <ReinH> Gurkenglas: what do?
19:25:07 <Gurkenglas> ReinH, it partitions the [b] into the buckets [minBound..maxBound] according to the given function
19:26:18 <slack1256> ReinH: I think the closer to it is the 1ML talk
19:26:34 <KaneTW> :t groupBy
19:26:35 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
19:27:07 <Cooler> what does the -> mean?
19:28:16 <Gurkenglas> Oh boy. (a -> b) is a function that takes an a and gives a b. (a -> b -> c) desugars to (a -> (b -> c)) and is a function that takes an a and gives a function that takes a b and gives a c, effectively taking a and b and giving c.
19:28:36 <Gurkenglas> (a -> b) -> c is a function that takes a function from a to b and gives a c.
19:29:03 <ReinH> @where learnhaskell
19:29:03 <lambdabot> https://github.com/bitemyapp/learnhaskell
19:29:13 <ReinH> Cooler: you should start with some introductory material, like the ^
19:31:44 <Gurkenglas> :t partition -- "Generalizes this", I should have said.
19:31:45 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
19:32:39 <Cooler> so all function actaully only take one argument?
19:32:47 <Cooler> functions*
19:32:49 <Gurkenglas> Correct.
19:33:21 <slack1256> You actually can pretend to pass two or more arguments if the function accepts a tuple
19:33:28 <slack1256> @type fst
19:33:29 <lambdabot> (a, b) -> a
19:33:42 <slack1256> > fst ("batman", "superman")
19:33:43 <lambdabot>  "batman"
19:34:11 <Gurkenglas> You can also pretend to pass two arguments by having the type signature a -> b -> c :P
19:34:14 <Lynn> IMO fst takes one argument, namely a tuple, containing two values... Calling it anything else is just confusing.
19:34:49 <ReinH> fst takes two arguments if by two you mean one.
19:35:18 <Lynn> Haha
19:35:52 <ReinH> to further confuse things, GHC has the notion of fully saturated function application
19:36:09 <ReinH> were fmap f is not fully saturated
19:36:30 <Gurkenglas> Is 0 fully saturated?
19:36:36 <ReinH> 0 is not a function application
19:36:39 * Lynn doesn't really like the "programmer habit" of bringing up every edge case about X around newbies confused about X.
19:36:49 <ReinH> Lynn: fair point
19:37:45 <Lynn> I mean, you're absolutely not wrong! But it makes things seem a lot more complicated than they really are, I guess, which is a problem Haskell probably already deals with enough of...
19:37:51 <ReinH> Lynn: you're right.
19:39:22 <Lynn> IO probably being the most notable offender :)
19:39:25 <ReinH> slack1256: I was actually sad that I didn't get to meet ezyang in person... and ask him to come on the haskell cast
19:41:17 <slack1256> oh that would be awesome
19:41:37 <dfeuer_> ReinH, I don't think that's just GHC.
19:42:23 <dfeuer_> Or maybe I'm confused. 
19:43:53 <ReinH> dfeuer_: GHC runtime optimizes what it calls "known, fully saturated function applications" into a jump in the RTS.
19:44:25 <dfeuer_> ReinH, I just got mixed up. Sorry.
19:44:26 <ReinH> That's what I'm referring to. I'm sure other things refer to fully saturated function application too, but this is one in the context of Haskell that I'm familiar with.
19:44:30 <ReinH> dfeuer_: np <3
19:44:54 <KaneTW> i'd call that "optimization of fully saturated function applications" or somesuch
19:45:11 <dfeuer_> It also has an impact on inlining.
19:45:25 <ReinH> Yep
19:45:32 <dmwit> Is `fmap (+) id` fully saturated?
19:45:39 <ReinH> The fast curry paper describes this.
19:45:47 <ReinH> As does https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode, I believe.
19:45:56 <geekosaur> dmwit, thank you, I was trying to figure out how to concisely ask that...
19:46:02 <ReinH> dmwit: I don't know.
19:46:08 <dfeuer_> That fast curry had better be spicy and flavorful. Okra maybe, or chickpeas...
19:46:13 <ReinH> dfeuer_: mmmm
19:46:20 <ReinH> http://research.microsoft.com/en-us/um/people/simonpj/Papers/eval-apply/eval-apply.ps postscript :(
19:46:36 <Ralith> ps2pdf is your friend
19:46:46 <ReinH> Preview.app does it for you too
19:46:56 <dfeuer_> Okular works fine with it.
19:47:02 <ReinH> fast currying, of course named for Moses Schoenfinkel
19:47:15 <dfeuer_> But someone really should go through that old PS stuff and PDFize it for mobile use.
19:47:22 <bzm3r> is anyone here pretty good at elementary number theory?
19:47:43 <dfeuer_> bzm3r, I bet some are.
19:47:55 <geekosaur> it's usually best to just ask your question
19:48:37 <bzm3r> i'm not sure if i want to treat this place openly as a "help me with my math homework" kind of place
19:48:40 <bzm3r> i'd rather find a couple of contacts i can ask privately, i guess
19:48:47 <KaneTW> ask in #haskell-blah
19:48:51 <KaneTW> or #math
19:48:53 <dmwit> Perhaps #math is a better place for math questions.
19:48:55 <bzm3r> sweet, i'll try that
19:49:04 <dmwit> If they happen to be #haskell-related, here is okay, too.
19:49:30 <dmwit> Often you will get helpful responses even to non-#haskell-related technical questions here; but it's an easy way to squander a good reputation.
19:50:17 <bzm3r> yeah
19:50:19 <dfeuer_> dmwit, how's it hurt your reputation to ask questions, as long as they're not stupid and not terribly frequent?
19:50:19 <bzm3r> i don't really want to do that
19:50:29 <bzm3r> even though i don't have a reputation
19:50:37 <dmwit> dfeuer_: Off-topic questions are off-topic.
19:50:54 <dmwit> bzm3r: Yeah, perhaps I should have said "clean reputation" instead of "good reputation". =)
19:51:56 <bzm3r> dmwit: haha
19:59:35 <dmwit> dfeuer_: sorry, that answer was lame
20:00:33 <dmwit> off-topic discussions can clutter the conversation and are distracting for folks with actual haskell quetions
20:00:42 <dfeuer_> dmwit, it's fine. I must admit I have a tendency to imagine an 'i' between the first two letters of your nick, though I know you're far from that.
20:01:32 <dmwit> yup, i think of myself that way sometimes, too =)
20:03:24 <lpaste_> bldzrr pasted “What is the Identity? Functional Programming Haskell” at http://lpaste.net/141162
20:04:05 <shachaf> That looks like a good homework exercise.
20:04:17 <bldzrr> Yes
20:04:26 <bzm3r> n                       bbbbbbbbbbbbbbbbbbbb\\\
20:04:28 <bldzrr> I've been stuck on it for ages trying to figure it out haha
20:04:44 <shachaf> There aren't that many possible combinations.
20:05:19 <bldzrr> I've tried identity = ap (proj) (proj) (proj) 
20:05:28 <bldzrr> I'm new to Haskell
20:05:33 <bldzrr> so that's probably very wrong haha
20:06:10 <Sinestro> It's close
20:06:24 <Sinestro> Try building that up in GHCi
20:06:29 <Sinestro> Using :t as you go
20:06:36 <johnw> bldzrr: remember that identity is going to receive an argument
20:06:47 <bldzrr> so :t instead of :l ?
20:06:54 <bldzrr> I'm writing in notepad++
20:07:04 <Sinestro> :l loads the file
20:07:13 <Sinestro> :t checks the type of a sub thing
20:07:14 <lambdabot> parse error on input ‘type’
20:07:56 <bldzrr> identity = ap (proj) (proj)
20:07:59 <bldzrr> is that the correct answer?
20:08:01 <Sinestro> Yep
20:08:06 <johnw> give the man a cookie!
20:08:06 <Sinestro> But drop the parens
20:08:06 <bldzrr> it works
20:08:26 <bldzrr> sick, thanks guys!
20:08:36 <Sinestro> Generally, you can get pretty far just thinking about the type signatures
20:08:42 <nitrix> Hi, I have a question. How does functional languages with algebraic data types lets you identify the value you're working with without a mechanism like pattern-matching in function declarations?
20:09:00 <johnw> nitrix: identify in what sense?
20:09:22 <nitrix> johnw: data A = B | C, wether your A is a B or C.
20:09:27 <johnw> ah
20:09:34 <slack1256> Well algebraic data types are really regular, that is why you can pattern match
20:10:02 <slack1256> you know a priori their kind of structure. A product or a Sum
20:10:20 <dmwit> nitrix: what language has algebraic dt but not pattern match?
20:10:41 <nitrix> dmwit: I don't know any but I'm still wondering about the feasability.
20:10:41 <slack1256> other alternative is to have a really regular structure for all data, which is what lisp (i think) does with lists
20:11:27 <nitrix> dmwit: Clearly the compiler could generate a bunch of `isB`, `isB` functions automatically, so pattern matching isn't the only option.
20:11:29 <dmwit> nitrix: pattern match is pretty much the canonical destructor
20:11:32 <nitrix> isC*
20:11:53 <johnw> in Haskell at least, all those is* function would become cases
20:11:58 <keith_> I'm not really sure this is the correct place to ask this, but is there any way to make dzen display the titles of unfocused windows in xmonad?
20:12:10 <dmwit> other destructor patterns exist but usually are not for algebraic dts
20:12:33 <dmwit> keith_: #xmonad
20:13:03 <keith_> thanks
20:13:32 <dmwit> nitrix: e.g. W types, combinatorial species, containers
20:14:14 <dmwit> nitrix: one can also expose only catamorphisms instead of patterns, though it is very rare
20:15:00 <dmwit> catamorphisms are less convenient and not obviously as efficient in all algorithms
20:15:02 <nitrix> dmwit: In the same idea of destructors, my second question, if I look at the mtl package, the StateT newtype, there is a monad instance like so: Monad m => Monad (StateT s m)
20:16:20 <nitrix> Is it possible to break any `StateT s m a` to only work with `StateT s m` to operate on it as a Monad, or would I have to use some of the functions the library provides?
20:17:04 <dmwit> what?
20:17:14 <Clint> i think you mean "wut"
20:17:25 <slack1256> you are misunderstanding the kind of the mona 
20:17:30 <slack1256> monad type class
20:17:37 <monochrom> perhaps s/break/case-analysis/
20:17:45 <dmwit> oh, i think i understand your question
20:18:34 <dmwit> StateT offers some operations that cannot be reproduced using only return, fmap, and join
20:18:49 <dmwit> does that answer your question?
20:21:06 <monochrom> but yeah, there is no value of type "StateT s m" because its kind is not *
20:21:47 <nitrix> No, but there are things of type "StateT s m a", right?
20:21:57 <monochrom> yes.
20:22:08 <dmwit> e.g. nothing of type `Monad m => m Bool` has the same semantics as `get` when specialized to type `StateT Bool Identity Bool`
20:22:13 <nitrix> Can you take something that's of that type and use it in a monadic fashion?
20:22:24 <nitrix> Partially... destructing it, maybe?
20:23:35 <monochrom> well, I have always used everything of that type in monadic fashions.
20:24:26 <dmwit> wow! those are some strong quantifiers =)
20:24:26 <monochrom> I write code like "do { x <- get; liftIO (print x); put (x+1) }"
20:24:42 <nitrix> Anyway. It's fine. One day I'll understand Haskell's type system. I wish.
20:24:44 <monochrom> that code has type StateT Int IO Int
20:25:20 <monochrom> also, each of "get", "liftIO (print x)", and "put (x+1)" has type StateT Int IO ???
20:25:40 <monochrom> so yeah, I'm using such values in monadic fashions
20:25:55 <dmwit> i am not sure "destructing" is an appropriate description of using the Monad interface on stateful operations
20:25:59 <monochrom> more specifically, in a do-block aka chained by >>=
20:26:01 <nitrix> But can you go from that do expression to `StateT Int IO` ?
20:26:12 <monochrom> no. wrong kind.
20:26:36 <monochrom> I can only go from do-blocks to StateT Int IO XXX. I cannot get rid of the XXX.
20:27:11 <dmwit> nitrix: what does it mean to "go to StateT Int IO"?
20:27:17 <monochrom> I have a lot of freedom of choosing what XXX is, but it has to be something
20:27:56 <Sinestro> It can be ()
20:28:04 <scshunt> monochrom: this sounds like an assignment :P
20:28:27 <Clint> the assignment is "go to StateT Int IO"?
20:28:42 <dmwit> scshunt: what is "this"?
20:29:00 <scshunt> monochrom's problem
20:29:10 <monochrom> I have a problem?!
20:29:26 <Clint> i'm sure you have a problem of some kind
20:29:33 <dmwit> monorhrom does not seem to have a problem to me...
20:29:48 <Clint> for example, his 'c' is mutating
20:30:01 <nitrix> I was curious if the whole boxed type thing meant information was incoded in such a way that someone could start with a `StateT Int IO ()` and finish with a `StateT Int IO`, because type destructors were mentioned.
20:30:13 <monochrom> well, kind of. I have the problem of slacking off in IRC and procrastinating brushing my teeth.
20:30:24 <Clint> i should brush my teeth right now
20:31:23 <Gurkenglas> :t liftIO . print =<< id <<+= 1
20:31:25 <lambdabot> (Num s, Show s, MonadIO m, MonadState s m) => m ()
20:31:28 <amindfv> ok, here's a crazy idea i've been banging on:
20:31:39 <amindfv> so given a class like:
20:31:55 <amindfv> class Foo a where foo :: a -> Int
20:32:40 <amindfv> and given only String and Float Foo instances
20:32:56 <amindfv> I want to infer Float for Foo when I see a number
20:33:33 <amindfv> the crazy idea os to do something like
20:33:40 <amindfv> type family F a where
20:33:45 <amindfv>    F String = String
20:33:50 <amindfv>    F a = Float
20:34:06 <amindfv> and then I can say e.g.:
20:34:22 <amindfv> bar :: (Foo a, F a ~ a) => a -> Int
20:34:32 <amindfv> am i barking up the wrong tree?
20:34:48 <monochrom> I have a much more low-tech solution, amindfv. use {-# LANGUAGE ExtendedDefaulting #-} and add "default (Float, Double, Integer)"
20:34:59 <exio4> well, that's ruling out any other possible instance
20:35:03 <amindfv> (of course I can't literally do that because of the infinite type, but it seems like I can "refine" the type)
20:35:13 <monochrom> now, I admit that I haven't tested my idea.
20:35:21 <exio4> monochrom: where's that infinite type?
20:35:31 <monochrom> what infinite type?
20:35:33 <amindfv> monochrom: for other reasons I can't use -XExtendedDefaulting... :/
20:35:39 <exio4> er, amindfv 
20:35:40 <monochrom> ok I see
20:35:42 <exio4> sorry monochrom :P
20:35:42 <amindfv> F a ~ a
20:36:04 <exio4> try that code, there's no infinite type there 
20:36:05 <amindfv> exio4: yes, I'm fine with ruling out other instances
20:36:16 <dmwit> nitrix: There are no term-level inhabitants of the type `StateT Int IO` (even `undefined`!).
20:37:17 <amindfv> exio4: you get the infinite type error if you try and use bar
20:38:17 <amindfv> more specifically, when i say "i want to infer Float when i see a number", i do mean infer
20:39:41 <dmwit> amindfv: I don't get an infinite type error when I try it.
20:41:39 <dmwit> amindfv: Also, I have bad news: `instance Num String` can be made to work.
20:41:49 <dmwit> So "infer" ain't going to work with that type family.
20:42:08 <amindfv> dmwit: you don't get an error with "bar 4" in ghci?
20:42:16 <dmwit> Okay, I can make the infinite type error appear.
20:42:19 <dmwit> I claim this is a GHC bug.
20:42:35 <dmwit> The real complaint is that the type variable is ambiguous; the infinite-ness is not correct.
20:42:36 <amindfv> dmwit, yes I'm fine with undefined behavior if the user has a String Num instance
20:43:35 <amindfv> my idea with this is to "reduce the ambiguity" with the closed type family
20:44:12 <dmwit> But I am telling you that it does not reduce the ambiguity.
20:44:14 <amindfv> I've tried something similar with ConstraintKinds but haven't landed on it yet
20:44:35 <dmwit> Because you will get the constraint `(Num a, F a ~ a)`, and `a ~ String` is a fine solution to that constraint.
20:44:44 <amindfv> right
20:44:52 <amindfv> that makes sense
20:45:24 <amindfv> i think i'm looking for something more like a class constraint on a class instance
20:46:29 <dmwit> After further thought, I concur with monochrom.
20:46:36 <dmwit> This is the domain of defaulting, and that is what you should use.
20:47:26 <amindfv> my issue is that the "real" thing I'm doing is a MPTC, and extendeddefault doesn't work with MPTCs
20:47:29 <amindfv> or so it seems
20:48:12 <amindfv> I'm also building a DSL where it would be a burden for users to add the extra pragma and "defaulting" line
20:48:52 <dmwit> If you're only planning to have two variants, you could consider just supplying two monomorphic versions of the class method.
20:50:08 <amindfv> dmwit: the reason i'm trying to "refine" the type is so that users don't need to annotate the numeric literals
20:50:23 <dmwit> Yes, I understand.
20:50:27 <amindfv> and if I just have a vanilla Float constraint, the numeric literals are ambiguous
20:50:34 <amindfv> right
20:50:45 <dmwit> Monomorphic types are not ambiguous.
20:52:29 <amindfv> but calling e.g. "bar 4" is ambiguous
20:52:40 <amindfv> necessarily, because of the open world assumption
20:53:01 <amindfv> unless I'm missing what you mean by supplying monomorphic versions
20:53:29 <amindfv> oh! i see, you just mean have "barString" and "barFloat"?
20:54:21 <dmwit> yes
20:54:35 <amindfv> that doesn't work for what I'm trying to build
20:54:55 <amindfv> possibly injective type families will allow me to do what I'm trying here?
20:55:54 <exio4> how would they help?
20:57:29 <amindfv> exio4: with closed injective type families, ghc might be able to solve for "F a ~ a", where the only possible 'a' is Float
20:58:58 <dmwit> The open world assumption means you *cannot* go from "class constraint" to "not type Foo".
20:59:08 <dmwit> So, no, you can't go from "Num a" to "not String".
20:59:34 <johnw> amindfv: what about something basic like https://gist.github.com/0a0309754032a50cb581
20:59:36 <dmwit> No matter which extensions you turn on. =)
21:00:49 <exio4> johnw: that code scared me
21:01:00 <johnw> not every extension is needed; some were from earlier iterations
21:01:40 <amindfv> hey johnw , you helped me with a variation of this problem before so apologies if it looks familiar, haha
21:01:43 <exio4> RankNTypes, UndecidableInstances, OverloadedStrings aren't needed
21:01:56 <johnw> neither should be TypeFamilies or ConstraintKinds
21:02:12 <amindfv> that's actually what i've cooked up currently
21:02:17 <amindfv> almost exactly
21:02:30 <exio4> I think flexible instances is needed for [] Char 
21:02:47 <amindfv> but IncoherentInstances is makin' me nervous, and my latest inspiration was an attempt to get rid of it
21:03:26 <amindfv> something still seems very wrong in the fact that I feel like i'm unable to refine/constrain types
21:04:06 <amindfv> dmwit: re: the open world assumption: isn't that not true if I've got a closed type family?
21:04:34 <dmwit> The type family may not be open, but `Num` still is.
21:04:56 <KaneTW> nothing is stopping me from making an instance Num String
21:05:03 <KaneTW> then using your code
21:05:18 <amindfv> but if I say "F a ~ a" in the function/instance type
21:05:29 <amindfv> and have a "F a = Float" in the type family
21:05:41 <amindfv> ... I don't know, it feels like that gives me something
21:05:58 <amindfv> KaneTW: right, I'm ok with telling people "don't do that"
21:07:03 <johnw> exio4: IncoherentInstances isn't needed, but UndecidableInstances is
21:07:25 <dmwit> amindfv: It's not about talking to users here. It's about talking to the compiler.
21:07:34 <dmwit> amindfv: And you can't tell the compiler "don't do that".
21:07:41 <johnw> the minimal list I've found is TypeSynonymInstances, FlexibleInstances, UndecidableInstances
21:07:49 <exio4> johnw: why is it needed? 
21:07:55 <johnw> Real a => Foo a
21:08:01 <exio4> oh
21:08:03 <amindfv> johnw: IncoherentInstances is needed, i believe, if I want to not decorate the numbers with ":: Float"
21:08:04 <johnw> "constraint is no larger than instance head"
21:08:20 <exio4> makes sense, nevermind
21:08:49 <johnw> amindfv: right you are
21:09:18 <amindfv> dmwit: of course, but the user would have to have added the instance, no? And I'm ok with saying "the behavior of this class is undefined if you do that"
21:09:31 <amindfv> i'd rather not but I feel like I've run out of other good options
21:09:50 <dmwit> No, the user need not have added the instance for the instance to be an allowable one.
21:10:18 <amindfv> oh! sorry, misunderstood your point
21:10:23 * hackagebot DAV 1.1 - RFC 4918 WebDAV support  https://hackage.haskell.org/package/DAV-1.1 (ClintAdams)
21:10:41 <johnw> btw, edwardk's Mu/Nu equivalence exercise is really good, if anyone is looking for a head scratcher.  Prove (by implementing the conversion functions) that the following types are isomorphic in Haskell:
21:10:42 <johnw> newtype Mu f = Mu { runMu :: forall r. (f r -> r) -> r}
21:10:42 <amindfv> that's a good point
21:10:45 <johnw> data Nu f = forall x. Nu x (x -> f x)
21:11:14 <johnw> for bonus points, also show equivalence of both to newtype Fix f = Fix { unFix :: f (Fix f) }
21:11:47 <amindfv> ok
21:11:52 <amindfv> on further inspection
21:11:56 <lpaste_> EXio4 pasted “trick using GADTs” at http://lpaste.net/141164
21:12:00 <exio4> amindfv: ^
21:12:12 <exio4> this is the closest hack I could think of
21:12:42 <dmwit> `magic (Str x)` doesn't seem better than `magicStr x`.
21:12:58 <dmwit> or, for that matter, particularly better than `magic (x :: String)`.
21:13:40 <dmwit> Oh, I see. You're claiming `magic 0` is better than `magic (0 :: Float)`.
21:13:43 <dmwit> Okay, admitted.
21:14:06 <dmwit> That's a cute trick. =)
21:14:46 <exio4> and magic "abc" also works, because it wants a Param a, it finds the instance Param a... and so on
21:14:50 <dmwit> right
21:15:21 <johnw> why not just instance Num (Param Float) where?
21:15:31 <johnw> (and likewise with IsString)
21:15:40 <exio4> johnw: magic takes a "Param a" as parameter
21:16:05 <johnw> ah, right, I see what happens when I do it the other way now
21:16:12 <johnw> neat trick!
21:16:18 <johnw> I like your solution better
21:16:22 <dmwit> So it works for sufficiently polymorphic arguments, but holds a hidden surprise for beginners that try to add a normal-looking type signature. =P
21:16:58 <amindfv> exio4: ooh la la
21:17:02 <dmwit> exio4++
21:17:09 <johnw> also, I still can't call magic (0 :: Int)
21:17:14 <johnw> wasn't that part of the original request?
21:17:24 <johnw> that is, not without providing instances for every other numerical type
21:17:39 <amindfv> this is a little limiting in that the "String | Float" was a bit of a contrived example
21:17:48 <amindfv> but maybe this'll get me where I want to be
21:18:05 <amindfv> johnw: I can live without the ":: Int"
21:18:24 <exio4> anyway, there's a downside of my solution, if you have a Float you need to "lift" it into a param first
21:19:47 <exio4> anyway, I am surprised it's possible without enabling 400 extensions too, :P
21:20:46 <johnw> amindfv: one thing I _like_ about Haskell is that all behavior is explicit: i.e., given the types and the code, you can be aware (modulo unsafePerformIO) of everything the code might do (unlike C++, where some behaviors might be perfectly invisible due to coersions, temporaries and conversions).  So while I understand wanting to make a DSL more convenient, consider what you are giving up too by making things more "magical".
21:21:22 <exio4> johnw: there's a reason the function in my paste has that name! 
21:21:33 <johnw> yep
21:21:57 <johnw> i mean, having a StringOrFloat type might in the end be just as good
21:22:23 <exio4> or just data Param a = Param a
21:23:17 <amindfv> johnw: I absolutely agree with you in the general case, but in this particular instance I was flat-out told by users that they wouldn't use my library if I required them to e.g. have specialized functions or annotate numbers
21:23:18 <exio4> oh well, it is needed for pattern matching, nvm
21:23:30 <johnw> amindfv: ah
21:23:31 <amindfv> even annotate numbers with e.g. "f :: Float -> F"
21:23:42 <amindfv> i.e. "f 4 `foo` f 5"
21:23:48 <johnw> amindfv: note that you always have the power of the proprocessor, if it comes to that
21:23:52 <johnw> preprocessor
21:23:57 <amindfv> johnw: like TH?
21:24:06 <johnw> I was thinking of "program formatters"
21:24:28 <johnw> like how SHE works
21:25:05 <johnw> if you use -pgmF foo, then foo gets a chance to rewrite the source however it wants
21:26:02 <amindfv> johnw: hmm, that's a possibility
21:27:03 <johnw> so I would think, using GHC API, that you could find every occurrance of "magic" and insert the annotations you need, if the type isn't a String, for example
21:30:08 <dmwit> If you're going to do your own type inference, you've already lost a lot of the reason for making your DSL an EDSL.
21:30:23 <howdoi>  say the matrix is like [[1,2,3],[4,5,6],[7,8,9]] I am trying to traverse it to [[1, 5, 9], [2, 6],[4,8], [3],[7]]; as in principal diagonal first and then subdiagonals and superdiagonals 
21:31:12 <dmwit> howdoi: You might like http://stackoverflow.com/q/32465776/791604
21:32:59 <howdoi> dmwit: No, it's not just the diagonals
21:33:57 <dmwit> I'm not sure I understand.
21:50:57 <c_wraith> The monad instance for Cofree is a little...  not what I expected.
21:51:57 <shachaf> Monad instance for Cofree?
21:52:13 <c_wraith> Yeah, depends on Alternative
21:54:06 <shachaf> Oh.
21:54:16 <c_wraith> Speaking of which, is there a flipped newtype for Alternative somewhere?
22:00:27 * hackagebot hmatrix-gsl-stats 0.4.1.1 - GSL Statistics interface  https://hackage.haskell.org/package/hmatrix-gsl-stats-0.4.1.1 (VivianMcPhail)
22:02:02 <amindfv> exio4: (+ dmwit + johnw) thanks -- I'm actually starting to get some real traction on my non-contrived example with what we talked over!
22:09:14 <c_wraith> But like..  Cofree Maybe is isomorphic to non-empty lists.  I would never have predicted the behavior of that Monad instance there.
22:34:50 <Lynn> c_wraith: Nice, I found Alternative f => Alternative (Backwards f) looking for the thing you mentioned earlier, and guess what it does? Nothing different is what. :( https://hackage.haskell.org/package/transformers-0.3.0.0/docs/Control-Applicative-Backwards.html
22:35:40 <Lynn> c_wraith: It flips the order Applicative stuff is run in I guess... There should maybe be a Control.Alternative.Backwards as well? But yeah, can't find anything
22:35:42 <c_wraith> Lynn: Well, in some cases, it'll do things differently.  Like, Backwards IO and IO will have observable differences.
22:35:57 <c_wraith> But no changes to the Alternative instances.
22:36:02 <c_wraith> Honestly, that's a different axis of change
22:37:26 <drewbert> Using Codec.Archive.LibZip, how do I open a zip file that's stored inside a zip file?
22:37:49 <drewbert> It would appear that the library only accepts filenames for opening.
22:38:10 <drewbert> I would prefer not to be writing to and reading from temp files.
22:38:46 <liste> drewbert which package?
22:38:51 <glguy> drewbert: https://hackage.haskell.org/package/LibZip-0.11.1/docs/Codec-Archive-LibZip.html#t:Archive
22:39:00 <glguy> drewbert: Look down around "sourcePure"
22:39:42 <drewbert> glguy: excellent, thanks!
22:39:56 <drewbert> I was really looking for that... Guys I needed to scan better.
22:40:01 <drewbert> Guess*
22:47:50 <yrashk> how can I define an Eq instance on something like `data A a = { f :: a -> a }` ? Or is it impossible?
22:49:02 <srhb> yrashk: First off, that's not a valid data definition, and second off, yes, equality instances for functions are generally impossible to make sane.
22:49:14 <kadoban> yrashk: I would think that's impossible (to write a useful definition at least)
22:49:40 <yrashk> I don't want to compare the function, in the real example I have a non-function field that I want to do Eq for
22:49:56 <srhb> Then you can just derive Eq
22:50:05 <srhb> Oh
22:50:12 <srhb> You ALSO have a function field but you want to ignore that?
22:50:16 <yrashk> exactly
22:50:29 <srhb> Right, then it should be possible to define the Eq instance simply as equality of the other fields
22:50:39 <yrashk> shachaf: yeah I forgot to type in a tag
22:50:45 <yrashk> err* srhb
22:50:50 <srhb> :)
23:19:44 <edwardk> how often do folks here wind up with data constructors with a single unpacked field that would be 4 bytes or less?
23:20:22 <edwardk> they can be one of several constructors in the data type
23:20:34 <edwardk> just trying to get a sense of how often it happens in practice
23:20:40 <shachaf> In 64-bit GHC, never. :-)
23:20:48 <edwardk> shachaf: "would be"
23:21:00 <edwardk> if the compiler was less silly
23:21:33 <luite> also "fewer"
23:21:35 <luite> fewer silly
23:21:45 <shachaf> Most of my single-field unpacked constructors are probably newtypes.
23:21:51 <shachaf> So I guess this is mainly applicable to sums?
23:21:56 <edwardk> luite: yes, yes
23:22:01 <edwardk> shachaf: yeah
23:22:14 <shachaf> That reminds me of the thing about unboxed sums I always go on about.
23:22:27 <shachaf> Which I still think could be a big improvement in GHC.
23:22:29 <edwardk> tibbe spent a bunch of time hacking on unboxed sums at icfp
23:22:33 <luite> edwardk: ghcjs unpacks these as you probably know, makes quite a big difference for String
23:22:34 <edwardk> so they are coming =)
23:22:48 <shachaf> edwardk: Oh? Also "CPR" for sums?
23:22:48 <luite> also Int since it's 32 bit
23:23:20 <luite> but it can only do it for the first data constructor
23:23:43 <edwardk> luite: basically the thc stuff gets the same benefits, it gets to unpack any one field 40 bits or smaller into the "pointer" with the tag due to the pointer encoding
23:24:05 <luite> haha
23:24:20 <edwardk> but only if that is the only field =)
23:24:39 <edwardk> but it means float, int32, word32, char, etc. are very cheap
23:25:01 <luite> good job on correcting the term :)
23:26:34 <edwardk> shachaf: CPR?
23:26:46 <shachaf> Constructed Product Result
23:27:10 <shachaf> CSR in this case, I guess.
23:27:19 <shachaf> E.g. say you have f :: ... -> Maybe ..., which is big enough that it doesn't get inlined.
23:27:22 <edwardk> shachaf: basically the stuff he was hacking on used an unpacked product encoding of a tag and the shape
23:27:36 <shachaf> GHC is always going to allocate a Just when it returns Just, even if it gets matched on immediately at the use site.
23:28:03 <shachaf> It would be much better to automatically do a worker-wrapper thing with a worker that returns (# Int#, a #)
23:28:23 <luite> that's what tibbes unboxed sum stuff is supposed to fix
23:28:42 <shachaf> OK, I'm glad someone is working on it.
23:28:57 <edwardk> shachaf: thats basically what it is
23:29:16 <shachaf> Years ago SPJ said that there was some trickiness to it but I don't remember the details.
23:31:00 <edwardk> Now, with some LLVM-like integer packing tricks clearly the way to do this is to just start allocating small sets of bits rather than whole words when someone gives you a !Bool or !Ordering field. ;)
23:31:26 <edwardk> Foo !Bool !Ordering     unpacking into a rather convoluted pointer would be kind of funny
23:31:48 <shachaf> The whole Int#-instead-of-Bool hack that people added recently would probably be obsolete with unboxed sums.
23:32:04 <edwardk> shachaf: SPJ was very enthusiastic about the unboxed sums at ICFP
23:32:19 <shachaf> I wish I'd've gone. :-(
23:33:44 <shachaf> I've blabbered about unboxed sums in here for years now but never done much beyond that.
23:36:56 * ski has also talked about unboxed sums, though maybe not in the same sense
23:37:40 <shachaf> Yes, ski talks about a different sense.
23:37:45 <shachaf> Something involving continuations.
23:38:03 <ski> yes, unboxing the continuation of the sum type
23:40:38 <ski> in the `f :: ... -> Maybe ...' case, you'd ideally pass two continuations, one for the `Nothing' case, and one for the `Just' case
23:41:21 <ski> (and one of the nice things about this is that you can have "semi-tail-calls", where you pass on some of the same continuations. Olin Shivers' wrote a paper about this)
