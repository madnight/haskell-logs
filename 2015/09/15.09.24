00:00:23 <ttt_fff> Cale: glguy answere the right question; I have a stream, the type is not [Char] or Text, but instead is [MyTokenType]
00:00:24 <Cale> ttt_fff: You will typically use runParser in order to run a parser of any stream type, including those which parse lists of tokens
00:00:31 <ttt_fff> and I want to know how to define parsecs over that stream type
00:00:36 <ttt_fff> instead of matching on chars/strings
00:01:54 <Cale> Ah, to actually define the parsers in the first place, yeah, first use tokenPrim to build parsers for each of the possible tokens in your language, and then from there it's basically as usual.
00:03:07 <Gurkenglas> dxld, what editor should I use for ghc-mod on Windows? I'm scared of what I've heard about learning the controls for vim/emacs.
00:03:32 <dxld> Gurkenglas: atom probably
00:03:38 <dxld> if that run on windows?
00:04:22 <dxld> at it's core ghc-mod is just a commandline program, so if you want to build a service on top of it you can just use that for trying it out
00:07:42 <ttt_fff> When using Parsec.Expr ( https://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Expr.html ), is there a way to tell Parsec that "white space between Terms = function application"; or doI need separate "TokenSpace" (i.e. do I need to inejct TokenFunctionApp in between TokenTerms)
00:08:03 <xpilot> gamegoblin: this should work http://lpaste.net/722473345261502464
00:08:42 * hackagebot wai-routes 0.9.2 - Typesafe URLs for Wai applications.  https://hackage.haskell.org/package/wai-routes-0.9.2 (AnupamJain)
00:14:12 <xpilot> whoops Gurkenglas already had edited it with the same solution
00:21:57 <Gurkenglas> whoops meant to make that an annotation
00:41:14 <theme2> I think I have some problem with my haskell installation
00:41:30 <theme2> I think I used to install haskell, and uninstalled it (incompletely)
00:41:36 <theme2> and now I'm installing it again
00:41:59 <theme2> how do I clean up everything related to haskell/cabal?
00:42:22 <srhb> theme2: Depends what you actually installed and your distribution, and how you installed it.
00:42:30 <srhb> theme2: For instance, did you install ghc and cabal, or Haskell Platform?
00:42:35 <theme2> srhb, the thing is, I don't know
00:42:44 <theme2> I'm on ubuntu, btw
00:42:54 <srhb> Right, that makes it next to impossible to give sane answers. Time to use find throughout your file system :)
00:43:11 <srhb> Or you could just go "meh, I have enough space" and reinstall a working environment over the current one.
00:43:37 <srhb> Or you could try to explain what your problem is, someone might be able to help.
00:43:43 * hackagebot classy-prelude 0.12.4 - A typeclass-based Prelude.  https://hackage.haskell.org/package/classy-prelude-0.12.4 (MichaelSnoyman)
00:43:46 * hackagebot classy-prelude-conduit 0.12.4 - conduit instances for classy-prelude  https://hackage.haskell.org/package/classy-prelude-conduit-0.12.4 (MichaelSnoyman)
00:43:48 * hackagebot classy-prelude-yesod 0.12.4 - Provide a classy prelude including common Yesod functionality.  https://hackage.haskell.org/package/classy-prelude-yesod-0.12.4 (MichaelSnoyman)
00:43:55 <theme2> lemme try to figure stuff out myself first...
00:47:44 <theme2> OK... so using "sudo apt-get install ghc" gives me 1014 lines of errors/warnings
00:48:49 <mgsloan> theme2: You might consider using stack, it will quite reliably install ghc for you
00:49:10 <theme2> mgsloan, what stack?
00:49:37 <lpaste> theme2 pasted “output of "sudo apt-get install ghc"” at http://lpaste.net/141605
00:49:39 <lpaste> theme2 pasted “output of "sudo apt-get install ghc"” at http://lpaste.net/1143032570041073664
00:49:48 <mgsloan> theme2: the stack build tool, it can be installed from apt
00:49:59 <theme2> whoops... double-pasted
00:50:07 <theme2> that's my error messages ^
00:50:37 <theme2> FYI ~/.cabal does not exist on my system
00:50:42 <mgsloan> (use "sudo apt-get install haskell-stack")
00:51:06 <mgsloan> Then running "stack setup" will install ghc
00:51:16 <theme2> mgsloan, unable to locate package
00:52:07 <mgsloan> Oh, actually my bad, it's just "sudo apt-get install stack"
00:52:25 <theme2> mgsloan, unable to locate package again
00:52:27 <theme2> :/
00:52:50 <mgsloan> Are you on an old version of Ubuntu?  The GHC APT is trying to install is pretty old (7.6)
00:53:32 <theme2> mgsloan, ubuntu 14.04
00:53:34 <mgsloan> theme2: Ahh, here we go: https://github.com/commercialhaskell/stack/blob/master/doc/install_and_upgrade.md#ubuntu
00:53:47 <mgsloan> Sorry, I didn't realize there was a PPA involved.  I usually install stack from source
00:54:31 <theme2> mgsloan, before installing stack, I want to know "what it stack?"
00:54:33 <theme2> *is*
00:57:36 <mgsloan> It's a new-ish build tool which makes a different set of design decisions than cabal-install.  Its intent is to automate common workflows, streamlining any pain points 
00:58:13 <mgsloan> For example, installing GHC and managing different versions of it can be a pain point, but stack automates that away
00:58:49 * theme2 struggles to understand packages and modules in any programming language
00:59:33 <mgsloan> Then you probably want stack, because figuring out what's wrong with a particular cabal build plan is a black art
00:59:44 <mgsloan> Whereas with stack things tend to just work ^TM
00:59:55 <theme2> :)
01:00:14 <mgsloan> (now, I'm biased, I'm one of the developers of it)
01:01:34 <theme2> afaik, complains about cabal a horribly common for haskell users
01:01:53 <theme2> so I think that it would not be too difficult to build something better than cabal :)
01:02:00 <theme2> I mean, relatively
01:02:06 <mgsloan> Yes, that's why stack exists - most of those complaints are really about the cabal-install build tool, rather than the Cabal library itself
01:02:30 <theme2> mgsloan, seriously, what is cabal supposed to do?
01:03:08 <theme2> FYI, currently I only understand the package system in C/C++ (nonexistent) and Rust (Cargo)
01:03:09 <mgsloan> Be a commandline interface for building haskell packages
01:03:45 * hackagebot pcre-utils 0.1.6 - Perl-like substitute and split for PCRE regexps.  https://hackage.haskell.org/package/pcre-utils-0.1.6 (SimonMarechal)
01:05:08 <lpaste> montanonic pasted “NICTA, lift composition” at http://lpaste.net/141606
01:05:17 <theme2> mgsloan, what is the "cabal library"?
01:05:39 <montanonic> I was hoping that I could do something more elegant than the lift2 and lift3 implementations for lift4. See code.
01:06:17 <montanonic> Composition is the idea. I don't want to just rewrite the same code out with one more parameter.
01:06:24 <zaquest> is there a way to do something like `cabal sandbox add-source` with stack?
01:06:25 <theme2> montanonic, every saw <$> and <*> ?
01:06:31 <theme2> s/every/ever
01:06:50 <montanonic> theme2: yes? did you look at the lpaste
01:06:53 <theme2> oh, wait
01:07:23 * theme2 hates point-free code, except for the obvious cases
01:07:44 <montanonic> well I think this is an obvious case if it could work
01:07:50 <montanonic> a lift4 is just two lift2's, no?
01:08:16 <mgsloan> theme2: It's the bit that takes a .cabal file and asks ghc to do compilation.  But it doesn't do anything about downloading stuff or resolving dependencies
01:08:21 <theme2> montanonic, I think it's 3 lift2's
01:08:53 * montanonic wonders if theme2 is joking?
01:09:16 <theme2> montanonic, that, or it's lift2 and lift
01:10:01 <theme2> mgsloan, does ghc know *anything* about the filesystem?
01:10:22 <theme2> or does cabal tell ghc that (like make)?
01:11:24 <theme2> lolwat
01:11:42 <theme2> I typed "man stack" and I got "Stack - Last-in first-out stacks." in the header
01:11:53 <theme2> wait, it's the OCaml stack -_-
01:12:39 <dom314> Wowee, now that is a lot of peeps
01:12:49 <mgsloan> GHC does know things about the filesystem, but cabal also tells it about what to build
01:13:04 <mgsloan> I've gotta get back to work, though, happy haskelling!
01:13:39 <theme2> :)
01:15:18 <srhb> montanonic: Try considering liftA4 f a b c d = liftA2 f a b <*> c <*> d
01:15:45 <montanonic> srhb: ah, well if that works, that's much better; thank you
01:15:53 <srhb> montanonic: Perhaps this makes it clear that you need to be able to "extract" the new function to compose two liftA2s
01:16:15 <srhb> montanonic: ie. we could do that for, say, Maybe, but not for ANY Applicative
01:17:00 <srhb> montanonic: If you're just looking to shorten it, `liftA3 f a b c <*> d` is even shorter
01:17:32 <montanonic> srhb: I implemented it as lift4 f a b c d = lift3 f a b c <*> d
01:17:34 <montanonic> thank you! :)
01:17:58 <montanonic> srhb: if I flip <*> could I eta reduce?
01:18:07 <montanonic> at the cost of readability
01:18:17 <srhb> montanonic: try @pl, but yes, it's not worth it.
01:18:32 <montanonic> @pl?
01:18:32 <lambdabot> (line 1, column 1):
01:18:32 <lambdabot> unexpected end of input
01:18:32 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
01:18:39 <srhb> @pl \f a b c d -> liftA3 f a b c <*> d
01:18:39 <lambdabot> ((((<*>) .) .) .) . liftA3
01:18:41 <montanonic> oh, pointless
01:19:27 <montanonic> is there a way to do that in ghci? Or another chatroom where I can mess with lambdabot without spamming the channel?
01:19:39 <srhb> montanonic: You can just private query lambdabot
01:19:46 <montanonic> ah! right!
01:19:48 * theme2 punches lambdabot for being pointless
01:19:55 <montanonic> srhb: thanks again!
01:19:57 <srhb> Sure.
01:21:22 <theme2>  @pl (\x -> x x) (\x -> x x)
01:21:26 <theme2> @pl (\x -> x x) (\x -> x x)
01:21:29 <lambdabot> ap id id (ap id id)
01:21:30 <lambdabot> optimization suspended, use @pl-resume to continue.
01:21:33 <theme2> lolwat
01:21:37 <theme2> @pl-resume
01:21:43 <lambdabot> ap id id (ap id id)
01:21:43 <lambdabot> optimization suspended, use @pl-resume to continue.
01:21:56 * theme2 thought that wouldn't type-check
01:22:48 <quchen2> mgsloan: ping
01:23:25 <srhb> quchen2: Nice to see your self nomination. :-)
01:23:41 <mgsloan> quchen2: pong
01:23:43 <quchen2> srhb: Is that so? Thanks, I guess! :-)
01:24:09 <quchen2> mgsloan: Are you still using Sublime? I've got trouble with the highlighting (the default is quite crappy) and I'm wondering what other people do.
01:24:22 <quchen2> None of the highlighting alternatives seem to work properly either :-|
01:24:23 <mgsloan> Ah, I'm an emacs convert these days
01:24:37 <quchen2> Arrr. Pity!
01:24:50 <mgsloan> Sublime is indeed fast and pretty though, no doubt about it :)
01:25:46 <quchen2> Emacs+Sublime+Vim are a very good editor in a combined dream world, and they all suck in their current form :-C
01:26:04 <xpilot> no love for yi?
01:26:22 <srhb> xpilot: One day, one day...
01:26:33 <quchen2> Haven't tried it. I'm not in the mood for an editor war either. I just wanted to find out about highlighting fixes.
01:33:47 * hackagebot geoip2 0.1.0.2 - Pure haskell interface to MaxMind GeoIP database  https://hackage.haskell.org/package/geoip2-0.1.0.2 (ondrap)
01:33:49 * hackagebot compactmap 0.1.1 - A read-only memory-efficient key-value store.  https://hackage.haskell.org/package/compactmap-0.1.1 (SimonMarechal)
01:43:47 * hackagebot stateWriter 0.2.4 - A faster variant of the RWS monad transformers.  https://hackage.haskell.org/package/stateWriter-0.2.4 (SimonMarechal)
01:43:49 * hackagebot filecache 0.2.9 - A Linux-only cache system associating values to files.  https://hackage.haskell.org/package/filecache-0.2.9 (SimonMarechal)
01:44:26 <merijn> Man, there's a bunch of tension implementation. A nameless AST implementation is really simple and nice to implement, but impossible to pretty print, but tracking names it very cumbersome to work with :\
01:50:36 <{AS}> Hi, if I use a HOAS encoding of an AST, how would it be possible to print it?
01:50:52 <{AS}> that is the AST :)
01:50:55 <merijn> {AS}: Very annoyingly :p
01:51:01 <{AS}> :P
01:52:00 <merijn> oh...maybe I should look how idriss AST is put together...
01:52:20 <{AS}> merijn: You mean PTerm?
01:52:59 <merijn> What's PTerm?
01:53:11 <{AS}> The Idris AST for expressions
01:53:44 <merijn> I don't know, I haven't looked at the idris source yet
01:54:09 <merijn> I'm trying to figure out how I can keep names/locations for prettyprinting without making my AST really annoying to deal with
01:54:33 <{AS}> Ah, In Idris they use FC
01:55:28 <merijn> FC?
01:56:01 <{AS}> https://github.com/idris-lang/Idris-dev/blob/1f8944f6da207da96a1acd75087a4af401c61b78/src/Idris/Core/TT.hs#L82
01:56:38 <merijn> oh...maybe I can just newtype "(Int, String)" and compare only on Int, using the String as name when prettyprinting...
02:23:49 * hackagebot ghc-events-analyze 0.2.2 - Analyze and visualize event logs  https://hackage.haskell.org/package/ghc-events-analyze-0.2.2 (EdskoDeVries)
02:25:58 <Hi-Angel> Does anybody knows of an article about — would be monads are still useful if the «do-notation» wouldn't exist?
02:26:23 <merijn> Hi-Angel: Sure they are, you can write "almost do-notation"
02:27:02 <merijn> Hi-Angel: See this wikibook: https://en.wikibooks.org/wiki/Haskell/do_notation
02:29:52 <delYsid> OK, I have parts of my algorithm translated from C++ to Haskell.  The code is very elegant, but (kind of expected), runtime is horrible.  I've been told here I should first write the code, then ask here for how to make it faster.
02:30:37 <delYsid> It is https://github.com/mlang/hbmc, just "cabal repl" and then "test".  On my machine, this simple tests takes several seconds.  I need this to be *a lot
02:30:40 <delYsid> * faster
02:35:09 <kriztw> delYsid: do you have experience with profiling in haskell=
02:36:40 <delYsid> kriztw: Absolutely none.
02:38:06 <kriztw> delYsid: I can't remember the exact resources I used for my masters thesis, but you need to do something like this: https://nikita-volkov.github.io/profiling-cabal-projects/
02:39:34 <kriztw> then you get a .prof and a .hp file
02:39:52 <kriztw> the .prof file specifies how much execution time and allocation time is spent inside the different parts
02:40:50 <kriztw> the .hp file contains a graph of memory usage over time, which is useful for spaceleaks
02:42:05 <kriztw> the hard part about profiling is that you need all libraries installed with profiling enabled, and I haven't found an easy way to do that after the fact :/
02:45:08 <xpilot> the best thing to do is enable profiling locally in a cabal sandbox
02:45:28 <xpilot> by creating a cabal.config in the sandbox
02:47:13 <tj_> how could i put a haskell executable in a bash pipeline? I struggle with it for a few days, i guess the (getArgs !! 0) isn't cut for the job, i have no idea... i have something like this: ./py_script.py path/to/file.dbf | ./hs_parse_to_sexp
02:47:53 <Rembane> tj_: What about getArgs !! 1?
02:47:59 <Rembane> tj_: Or no. Nevermind.
02:48:07 <Rembane> tj_: You need to read from standard input, (stdin)
02:48:37 <tj_> Rembane: yeah, do you know how would that bo possible?
02:48:53 <Rembane> tj_: getLine should be able to do that for you.
02:49:20 <tj_> Rembane: oh, cool, i'm on it
02:49:25 <Rembane> tj_: Sweet!
02:50:14 <kriztw> tj_: or getContents if you need everything and not just a single line
02:52:08 <tj_> kriztw, that's better, awesome
02:52:40 <hamilto-nyan> @hoogle Monad m => (a1 -> a2 -> m r) -> m a1 -> m a2 -> m r
02:52:42 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
02:52:42 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
02:52:42 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
02:52:42 <frerich> tj_: You may want to consider the 'interact' function
02:52:57 <frerich> tj_: It's a convenient helper for writing programs which merely translate some input String into an output String.
02:54:29 <tj_> fererich, aham, i'm looking into it
02:54:37 <tj_> you guys are really helpful
02:54:52 <tj_> frerich*
02:54:58 <frerich> tj_: E.g. you can save a file 'prog.hs' with 'import Data Char; main = interact (map toUpper)' and then use that like 'echo "hello world" | runhaskell prog.hs'
02:55:07 <frerich> (or go without 'runhaskell' but compile it)
03:00:23 <esimp> Anyone have a better way to write a function ([a] -> [b] -> [a]) where the output a's are only the ones that had a 1 in the corresponding [b] position
03:02:10 <esimp> I currently, (map fst (filter (\(p,e) -> (e == 1)) (zip ps es))
03:02:23 <pyrtsa> You could use zipWith.
03:02:55 <pyrtsa> But I don't think it'll get much shorter.
03:03:23 <esimp> pyrtsa, I can't think of how to use zipWith to remove elements from the output list...
03:03:34 <pyrtsa> Yeah, you'd filter after that.
03:03:51 <esimp> pyrtsa, gotcha
03:05:19 <delYsid> kriztw: Thanks for that link.
03:05:33 <kriztw> esimp: you could use a list comprehension
03:05:39 <delYsid> "1,954,532,728 bytes allocated in the heap" oh sh*t :-)
03:05:55 <kriztw> esimp: something like [ p | (p,e) <- zip ps es, e == 1]
03:06:17 <esimp> kriztw, much cleaner, I like it
03:06:33 <delYsid> So Haskell behaves roughly like C++, the readable implementation is dead slow.
03:08:00 <kriztw> delYsid: have you pinpointed which part is slow?
03:08:28 <esimp> kriztw, so the list comprehension is like syntactic sugar for (zip -> filter -> map) ?
03:08:42 <delYsid> kriztw: Not yet, I am just guessing the amount of allocations is the killer.
03:09:01 <delYsid> This is roughly 20 characters of input, which results in 2GB of allocs :-)
03:10:10 <kriztw> delYsid: then it should be pretty easy to see which part blows up
03:13:14 <delYsid> kriztw: Yeah, apparently it is some use of fold(l/r)
03:14:25 <srhb> delYsid: foldl is almost never what you want.
03:14:33 <srhb> Did you choose it for some specific reason?
03:16:46 <srhb> That said, have you tried running optimizations?
03:17:34 <rhovland> delysid: it's spending all the time in allEqDur
03:17:36 <delYsid> srhb: No, I am a newbie :-)  Switching to foldr didn't help very much either though.  And yes, I am using -O2
03:18:44 <delYsid> rhovland: Looks like the actual problem is the dur method.
03:18:56 <delYsid> allEqDur makes use of the underlying dur.
03:19:43 <delYsid> dur         Data.Braille.Music   82.0   91.4
03:20:23 <MarcelineVQ> It probably won't help with your speed, but foldl' is constant memory use, so it tends to be the preferred foldl when using foldl
03:20:26 <delYsid> however, dur is a method, so I don't see which instances is the culprit.
03:20:53 <rhovland> delysid: profiling: http://lpaste.net/141611
03:21:23 <delYsid> MarcelineVQ: Where is foldl' defined?
03:21:30 <MarcelineVQ> Data.List
03:22:07 <rhovland> delysid: it's calling dur-realvalue 3.4M times, I'd look at that
03:25:24 <delYsid> rhovland: So no lazy mapping, I guess I'll need to cache the duration in my data structure :-(
03:27:32 <kriztw> delYsid: I haven't used them myself, but take a look at https://wiki.haskell.org/Memoization
03:29:45 <rhovland> delysid: if you can make it work in data.array, that's usually the fastest way to get memoization. 
03:30:06 <rhovland> delysid: (fastest as in least amount of trouble)
03:56:12 <hamilto-nyan> So, I wrote this toy implementation of unification for a Haskell98-like kind language: http://ix.io/kZi -- Now, how do I test it in GHCi?
03:58:12 <rhovland> hamilto-nyan: well, it loads fine into ghci... what are you asking?
03:58:37 <hamilto-nyan> The problem is the monad transformer layers... How do I write test code for stuff that's in monad transformer layers?
04:07:49 <quicksilver> hamilto-nyan: runStateT?
04:08:29 <quicksilver> and run ExceptT
04:08:32 <srhb> hamilto-nyan: Is that the total energy of Schrödingers cat? :-)
04:08:54 <quicksilver> it might be conveneint to have a helper function which calls the two run functions on a given start state
04:10:17 <hamilto-nyan> Should it be something like this? «unifyTest k1 k2 = runExceptT $ unify k1 k2 `execStateT` M.empty» ?
04:10:34 <hamilto-nyan> The part that isn't clear to me is in which order I should stack the State and Except effects in the monad transformer stack.
04:11:01 <quicksilver> either option is a valid choice :)
04:11:15 <quicksilver> one way around you get the current (partially unified?) state even if there is an error
04:11:20 <quicksilver> the other way around you only get the error.
04:12:51 <hamilto-nyan> Ah!
04:13:09 <hamilto-nyan> I'm aware that, in general, the order of the effects matters.
04:13:29 <hamilto-nyan> It's just that, in this particular case, I can go for either order, right?
04:18:09 <quicksilver> yes. it matters but both choices are meaningful
04:18:49 <quicksilver> the difference between \state -> Either error (state,answer) and \state -> (state,Either error answer)
04:21:51 <hamilto-nyan> Ah!
04:26:05 <hamilto-nyan> @pl \k -> modify (M.insert x k) >> return k
04:26:05 <lambdabot> ap ((>>) . modify . M.insert x) return
04:34:16 <merijn> Whooops...
04:34:33 <merijn> spend 2 hours debugging my type checker only to find out it was right and my test code had a type error >.>
04:34:55 <merijn> On the bright side, my checker has substantially better diagnostics now :p
04:38:12 <tdammers> yesterday I spent 15 minutes trying to figure out why my CSS didn't produce the desired effect
04:38:28 <tdammers> until I realized that I was editing on the build server, but looking at the dev server
04:39:00 <merijn> :p
04:39:44 <merijn> To be fair, I only just fixed a bug where I was building wrong ASTs for function applications, so I was testing whether I fixed them, and checking whether typing worked correctly now :p
04:42:45 <jfeltz> should I start writing Haskell again, or continue blogging? http://jfeltz.com/posts/2015-09-24-simple-functional-decomposition.html
04:43:01 <jfeltz> decisions decisions :/
04:44:24 <zipper> Here https://hackage.haskell.org/package/optparse-applicative#regular-options it says "A regular option can have a default value, which is used as the result if the option is not found in the command line. An option without a default value is considered mandatory, and produces an error when not found."
04:44:46 <zipper> However when I look at the docs I see no way to pass it a default value.
04:44:54 <montanonic> and the silver light of insight dawned upon me, and I realized that sequenceA is actually only just list construction, with two extra bits of syntax to lift the prepend operation, and apply applicative functions instead of standard functions.
04:45:05 <montanonic> shone upon me*
04:45:16 <montanonic> or whatever, I don't care, fuck yes I understand
04:46:17 <quicksilver> 'getting' sequenceA is a good moment montanonic :)
04:46:17 * silver light shines upon montanonic utill he combusts
04:46:46 <montanonic> quicksilver: indeed :)
04:49:06 <kriztw> zipper: found it: http://hackage.haskell.org/package/optparse-applicative-0.11.0.2/docs/Options-Applicative-Builder.html
04:49:11 <kriztw> zipper: its called value
04:53:00 <riaqn> Hello, is there any mutable, fast vector in haskell, without state transformer monads?
04:53:47 <merijn> riaqn: State transformer monads?
04:54:01 <merijn> riaqn: Mutable vectors usually use IO/ST, not state transformer
04:54:20 <zipper> kriztw: Thanks a ton mate. <3
04:54:44 <riaqn> merijn: well, I 'm justing reading this: http://hackage.haskell.org/package/vector-0.10.0.1/docs/Data-Vector-Storable-Mutable.html
04:55:01 <riaqn> merijn: set :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> a -> m ()
04:55:15 <riaqn> what's IO/ST, BTW? (new here)
04:55:27 <merijn> riaqn: The IO and ST monads?
04:55:48 <quicksilver> merijn: they are (confusingly) referred to that way in some documents
04:56:03 <quicksilver> merijn: PrimMonad m .... Class of primitive state-transformer monads
04:56:07 <mniip> hold on, is GHC.TypeLits.+ injective?
04:56:08 <quicksilver> it is a poor choice of words IMO.
04:56:34 <merijn> quicksilver: Ah, well, it's technically true, ST and IO being effectively like State internally
04:56:48 <quicksilver> and yet, not.
04:56:50 <merijn> I'm guessing vector assumes a bit more advanced haskell knowledge
04:56:53 <quicksilver> thus, poor choice :)
04:57:11 <riaqn> quicksilver: huh, I knew. PURE functional!
05:00:48 <clrnd> so, yesterday I organized the first haskell meetup in my city, 10 people which is cool
05:01:40 <quicksilver> nice clrnd 
05:02:01 <riaqn> quicksilver: so how haskell people handle demands like primitive data structure? using monads the only way?
05:02:01 <ioerror> can anyone help me with this bug? im stumped... http://lpaste.net/141616
05:02:11 <clrnd> the thing is, I didn't want to end up explaining Monad, I did anyway
05:02:12 <keko_> "privitive data structure"?
05:02:26 <keko_> *primitive
05:02:30 <riaqn> keko_: hmm, like raw vector.
05:02:37 <riaqn> oh sorry. 
05:02:42 <keko_> wasn't your typo
05:02:44 <keko_> was my typo
05:02:44 <clrnd> not sure how it happened, people started asking and I just answered, then they wanted to understand do notation ... well
05:02:47 <mniip> question
05:02:54 <keko_> I was just wondering what you meant by that
05:02:55 <mniip> if I have a length-indexed list GADT
05:03:10 <mniip> how do I implement a pure :: KnownNat n => a -> LengthyList n a
05:03:53 <keko_> riaqn: if you want to mutate a data structure without copying it, monads will be involved
05:04:42 <keko_> https://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Mutable.html
05:05:06 <ioerror> any clues? im not sure if im using mapM correctly...
05:05:08 <riaqn> keko_: Thanks. I 'm writing a compiler for STLC, and wondering how to write a quick sort in a pure functional way.
05:05:29 <riaqn> guess monad is the way to go.
05:05:29 <ioerror> the commented out function used to work ok...
05:06:25 <riaqn> or just copy it, if performance not matters.
05:06:27 <clrnd> ioerror, I can see at least one "wrong" mapM_
05:06:33 <ioerror> awesome
05:06:56 <clrnd> ioerror, `mapM_ putStrLn ("gathering data from; "++whereTheDataIs++x)` this is gonna printLn for each character in the String
05:06:58 <ioerror> im not sure how it breaks the rest of it though...
05:07:21 <clrnd> :t mapM_
05:07:22 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
05:07:32 <srhb> clrnd: putStrLn does not take Char as argument though :)
05:07:32 <ioerror> x::[String]
05:07:43 <clrnd> roght
05:08:17 <ioerror> that was a function that worked fine until i wrote some more code, now it is broke
05:08:39 <Shubhra> Unignore -channels #mwsf * JOINS PARTS quits NICK
05:08:47 <zipper> Could someone please paste the scrollback for the last 30 mins on lpaste for me? I accidentally closed emacs and might've missed something.
05:08:53 <quicksilver> riaqn: your intuitions about performance may be wrong.
05:08:58 <mniip> zipper, see topic
05:09:04 <clrnd> ioerror, try removing the mapM_, mapM_ is for when you wanna apply a monadic action to a list of stuff
05:09:11 <quicksilver> riaqn: copying isn't as expensive as most people imagine
05:09:18 <merijn> riaqn: Quicksort is not a good algorithm for purely functional languages
05:09:23 <zipper> approx 30 mins
05:09:27 <quicksilver> but memory locality/comapactness is sometimes an issue.
05:09:28 <merijn> riaqn: Mergesort is much more natural
05:10:08 <riaqn> merijn: actually all in-place sorting algorithm is not for pure functional, I guess.
05:10:09 <ioerror> but im writing to a file, thats a monadic action.
05:10:26 <mniip> hey merijn
05:10:36 <riaqn> quicksilver: how about mutate a array of 1M elements?
05:10:46 <mniip> any idea how would one implement 'pure' for length-indexed lists?
05:10:59 <delYsid> kriztw: Thanks for the link.  However, I fail to understand the document.
05:11:29 <Shubhra> join #mozilla
05:11:29 <cocreature> mniip: pure a = a :. Nil should do the trick, no?
05:11:47 <ioerror> the only place im using mapM_ is in; mapM_ (appendFile "output.txt") x
05:11:53 <mniip> cocreature, that's not how length-indexed list applicatives work
05:11:58 <quicksilver> riaqn: there are different approaches. Persistent data structures which share memory with older versions.
05:12:01 <cocreature> ah right, I got confused
05:12:09 <quicksilver> riaqn: it's hard to give useful responses in such generality.
05:12:11 <ioerror> where x is a list of strings
05:12:22 <mniip> cocreature, first of all it has to be a zip list, not nondeterminism list
05:12:31 <quicksilver> riaqn: yes, sometimes, haskell is slower than other languages. Sometimes it's faster. Sometimes mutability is really what you want. Often it isn't.
05:12:34 <ioerror> that should be fine no?
05:12:35 <riaqn> quicksilver: which requires complicated C/C++ back-ends.
05:12:54 <quicksilver> riaqn: what requires complicated C/C++ backends?
05:13:26 <cocreature> mniip: so pure becomes replicate?
05:13:44 <riaqn> quicksilver: never minds. my bad.
05:13:49 <quicksilver> :)
05:14:01 <mniip> cocreature, yes
05:14:05 <mniip> thing is,
05:14:11 <zipper> mniip: Thanks
05:14:26 <mniip> pure :: KnownNat n => a -> LengthyList n a
05:14:34 <riaqn> quicksilver: anyway, vector sharing memory with old version requires complicated implementation.
05:14:35 <cocreature> yeah you don't have the n
05:14:56 <quicksilver> riaqn: yes, but Data.Sequence and Data.IntMap have that property 'for free'
05:14:57 <mniip> it should get the list from the type, and then ensure the typechecker that everything is indeed correct
05:16:22 <bernalex> if anyone knows a(ny) company that might be interested in getting some haskell hacking done (or financing hacking on libraries they use), please let me know! :]
05:17:05 <delYsid> Hmm, I don't see how Data.Array would speed duration calculation up.  I guess I should write a mail to haskell-beginners?
05:17:56 <clrnd> ioerror, oh sorry, I though the problem was in the comments
05:18:38 <clrnd> I don't understand your issue then
05:18:48 <ioerror> ok i have a better version
05:19:00 <ioerror> i cleared up the bug you spotted, but the real problem is another bu
05:19:07 <ioerror> bug
05:19:11 <ioerror> 1 sec
05:19:59 <cocreature> mniip: https://personal.cis.strath.ac.uk/conor.mcbride/pub/hasochism.pdf shoes an approach using a separate class on page 4
05:21:18 <ioerror> http://lpaste.net/141618
05:23:43 <fractalsea> I’m trying to improve the latency of my program. I’ve been doing a lot of profiling, but I still don’t really know where a particular bit of data that is flowing through the system spends most of its time. Is there a way of attaching some kind of timer to data, or some other way of profiling this?
05:24:23 <cocreature> mniip: I think you could also make a Replicate class that returns Nil for Vect 0 a and so on
05:27:31 <JustAQuestion> ls
05:28:40 <quicksilver> progging/ haskell/ typehacker/
05:28:54 <cocreature> [sudo] password for JustAQuestion: 
05:29:22 <int-e> Il0Uo9miu7cae
05:29:35 <int-e> :-P
05:29:56 <c_wraith> fractalsea: the only thing I can think of is profiling under a load that consists only of repititions of that data
05:30:12 <c_wraith> *repetitions
05:31:28 <quicksilver> is there a good (TH-based?) trick for getting sub names into error text?
05:32:57 <hamilto-nyan> Is there any shorter way to say `join $ foo <$> bar <*> qux` ?
05:33:22 <fractalsea> c_wraith, but what would that tell me about where in the program that data is spending most of the time?
05:33:55 <quicksilver> I love GHC's new suggestion code for typoed identifiers. It would be even cleverer if it ran the type-checker over its suggestions and suggested only the type-correct ones :)
05:34:56 <clrnd> ioerror, `x <- mySimpleHTTP whereTheDataIs`
05:35:34 <clrnd> ioerror, aren't you always calling it with the same URL? `whereTheDataIs`
05:36:04 <clrnd> oh that's another thing
05:36:57 <quicksilver> hamilto-nyan: you're not hte first person to ask them
05:37:08 <quicksilver> hamilto-nyan: see https://wiki.haskell.org/Idiom_brackets
05:37:27 <hamilto-nyan> Checking.
05:37:44 <quicksilver> hamilto-nyan: there are a bunch of partial solutions which may seem like overkill
05:37:51 <quicksilver> I don't know which is the most recent / most recommended
05:38:10 <quicksilver> https://hackage.haskell.org/package/applicative-quoters
05:38:19 <hamilto-nyan> Ah, I was expecting something that could be done with existing combinators.
05:38:27 <hamilto-nyan> It isn't a big enough deal to bring in new dependencies. :-p
05:38:41 <hamilto-nyan> Checking.
05:38:44 <quicksilver> yeah there isn't really a way to do it with combinators which works out any neater than join
05:38:52 <quicksilver> because of the way association and parsing works
05:39:02 <quicksilver> so all the hacks involve a preprocessor of some kind
05:39:11 <quicksilver> people have proposed to add something like this ti GHC more than once
05:39:37 <Fay> http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
05:39:50 <hamilto-nyan> Actually, at some point in time, I preferred to think in terms of join rather than bind.
05:40:14 <hamilto-nyan> But, if I'm going to have bind, at least make it nice, please!
05:40:17 <quicksilver> hamilto-nyan: also, read the comments here-
05:40:18 <quicksilver> https://www.reddit.com/r/haskell/comments/2wclln/haskellcafe_lets_teach_ghc_idiom_brackets/
05:40:31 <quicksilver> and, optional, wait to see if ocharles__ wakes up and chimes in :)
05:40:32 <hamilto-nyan> Checking.
05:40:42 <ocharles__> what'd I do!?
05:40:52 <quicksilver> you discussed idiom brackets
05:40:53 <quicksilver> in public
05:40:56 <quicksilver> you can't deny it now
05:41:01 <ocharles__> it's true, I went there
05:41:04 <quicksilver> you posted it to reddit! no subtlety at all.
05:41:12 <hamilto-nyan> One thing I like about <$> and <*> is that, AFAICT, they cover everything that's needed when working with Applicatives.
05:41:33 <hamilto-nyan> OTOH, I dislike liftAn's.
05:41:50 <quicksilver> it is a theorem in the applicative paper
05:41:53 <quicksilver> (maybe the only theorem?)
05:42:00 <quicksilver> that <$> and <*> cover everything you need
05:42:04 <hamilto-nyan> Ah!
05:42:04 <quicksilver> it's a nice readable paper :)
05:42:13 <Fay> link?
05:42:26 <hamilto-nyan> OTOH, with monads and >>=, the situation is less clear.
05:43:09 <ioerror> i really cant figure out what its doing... is it something to do with showing a monad? http://lpaste.net/141618
05:43:17 <quicksilver> Fay: http://staff.city.ac.uk/~ross/papers/Applicative.html
05:43:29 <Fay> quicksilver: ty
05:43:54 <cocreature> mniip: http://lpaste.net/141619 that should do the trick
05:44:00 <clrnd> ioerror, I'm building it to see what's going on
05:44:02 <cocreature> seems to work at least
05:45:28 <ioerror> clrnd, whereTheDataIs is just the prefix of the url, it get prepended to what should be a datwe which is being destroyed for some unfathomable reason...
05:45:30 <clrnd> ioerror, I think `getTheLocationOfTheData` is actually returning some URLs like that, which end in C=O etc
05:46:36 <ioerror> but when i show it myShow it looks correct...
05:47:02 <ioerror> with myShow*
05:47:20 <clrnd> ioerror, I just ran the program and it printed "gathering data from; http://tunes.org/~nef/logs/haskell/?C=N;O=D"
05:47:39 <ioerror> exactly...
05:47:43 <clrnd> `getTheLocationOfTheData` is really giving you back that
05:47:48 <dhil> could somebody explain, in layman terms, what a delayed array is?
05:48:08 <clrnd> ioerror, then the error is un munch
05:48:19 <ioerror> hmm
05:48:45 <ioerror> but why when i show it within that function is it looks different?
05:48:57 <ioerror> and correct...
05:49:20 <ioerror> there are barely any lines between the two shows and they are showing different things...
05:49:37 <clrnd> ioerror, I have them showing the same thing
05:49:40 <clrnd> double check that
05:49:40 <ioerror> the error is not in munch.
05:49:48 <ioerror> how wierd...
05:49:58 <Fay> weird^
05:50:05 <ioerror> thanks
05:50:13 <Fay> lol
05:50:26 <clrnd> ioerror, look: http://lpaste.net/141620
05:50:46 <ioerror> it really is returning that for me...
05:50:48 <clrnd> ioerror, I stoped it after 2 "requesting"
05:52:17 <ioerror> ARGH!!!! ok thanks so much. those are the worst kind of bugs....
05:52:46 <ioerror> the problem was that i was looking at only the first 5 urls, and the first 5 just happened to be gibberish
05:53:07 <ioerror> again. thanks so much, i was really struggeling to see what had gone wrong
05:53:07 <clrnd> ioerror, yeah, so difficult to debug :P
05:53:13 <clrnd> no problem!
05:53:42 <ioerror> *falls in crumpled heap on floor*
06:04:50 <clrnd> what happens when I do `stack instal blah` from some random directory?
06:05:10 <clrnd> I love that it does what I want (re: running `stack ghci` and having that module available)
06:05:33 <clrnd> but how? does it create a new porject somewhere for that dir? does it add the package globaly? what happens if I need different versions?
06:09:13 <cocreature> clrnd: afaik it uses the snapshot database corresponding to the snapshot specified in ~/.stack/global/stack.yaml
06:09:53 <clrnd> oh I understand, I CANT install a specific version, least I write a stack.yaml
06:10:00 <cocreature> yep
06:13:09 <clrnd> thanks
06:14:38 <Ankhers> clrnd: `stack install somePackage-0.3' -- I believe that should install a specific version of a package for you
06:15:16 <clrnd> Ankhers, ok, where? if I then do stack ghci, will I have that version? or the snapshot one? what if I change directory?
06:15:32 <clrnd> (sorry many question, much doubt)
06:16:09 <Ankhers> I
06:16:18 <cocreature> clrnd: if you want to be sure, just run stack ghci from within i project :)
06:16:25 <cocreature> s/i project/a project/
06:16:26 <Ankhers> I'm not entirely sure to be honest. I've only done it in context of a project.
06:16:37 <clrnd> yeah me too, and it works
06:16:40 <cocreature> stack install outside of a project is really more for installing binaries
06:16:46 <clrnd> but what happens when I'm just in some random directory
06:17:01 <clrnd> cocreature, yeah I guess, it works though
06:17:07 <Ankhers> Lets find out.
06:18:30 <Ankhers> clrnd: http://lpaste.net/141621
06:18:33 <Ankhers> That's what happens.
06:18:50 <clrnd> Ankhers, lol should have just tried it
06:18:52 <clrnd> thanks!
06:19:03 <clrnd> (that just like, explains everything)
06:19:35 <Ankhers> clrnd: As cocreature said, stack install outside of a project is more meant for installing binaries.
06:24:12 <Ankhers> I hate the internet at work...
06:57:28 <Luke> acfoltzer: ping
07:12:41 <mitochon> is there a library function for grouping elements in a list into tuples of size 2 ? e.g. [1..] -> [(1,2),(3,4) ...]
07:15:14 <delYsid> mitochon: f (x:y:xs) = (x,y):f xs
07:17:01 <julianleviston> delYsid: might need an additional case there to catch the rest, tho… f _ = []
07:17:10 <julianleviston> or f x = x
07:17:26 <julianleviston> depending on what they want to do with the “end bits” assuming oddness.
07:18:00 <julianleviston> oops. just realised it’s producing pairs :(
07:20:20 <delYsid> @let groupTup l = case l of { (x:y:xs) -> (x,y):groupTup xs; [] -> []}
07:20:22 <lambdabot>  Defined.
07:20:29 <delYsid> > groupTup [1,2,3,4]
07:20:32 <lambdabot>  [(1,2),(3,4)]
07:21:31 <clrnd> > groupTup [(), (), ()]
07:21:35 <lambdabot>  [((),())*Exception: /tmp/mueval1911759956749241873.hs:(153,5)-(155,16): Non-...
07:21:50 <clrnd> do you even patter match?
07:22:44 <delYsid> clrnd: Yeah, dont pass lists with odd length :-)
07:23:02 <julianleviston> erm.
07:23:21 <ggole> It would have been *shorter* to write the version that is exhaustive ಠ_ಠ
07:23:48 <clrnd> specify that in the types, wait this isn't #idris...
07:24:02 <clrnd> ggole, show us
07:24:28 <ggole> _ instead of []
07:25:45 <delYsid> ggole: Using _ would have silently swallowed the error.  I actually prefer an exception to loosing data unexpectedly.
07:26:18 <hc> any pointers to read up on the meaning of "data HostPreference :: *"?
07:26:35 <delYsid> hc: me too! :-)
07:26:40 <ggole> Then return ([a,a], Maybe a)?
07:26:48 <ggole> I don't think an exception is nice at all
07:26:59 <julianleviston> ggole: I agree.
07:27:13 <julianleviston> “Something went wrong in your program” - at runtime. Yay.
07:27:15 <hc> delYsid: hmm?
07:27:32 <ggole> Although I can understand the sentiment
07:27:41 <delYsid> hc: I am also interested in what that syntax actually means.
07:27:44 <hc> ah
07:28:25 <delYsid> ggole: I guess is depends on the context.  If you never expect an odd length list, I would still prefer an exception over having to deal with Maybe in all the follow up code.
07:28:27 <mauke[1]> > chunksOf 2 [1,2,3]
07:28:28 <lambdabot>  [[1,2],[3]]
07:28:41 <delYsid> However, if you really expect odd length lists, maybe is the way to go I guess.
07:28:50 <julianleviston> mauke: seems they wanted pairs. tho.
07:29:21 <julianleviston> delYsid: it’d be better to wrap it in a Maybe, no?
07:29:41 <julianleviston> delYsid: same reason a lot of people think head and last are mistakes.
07:30:19 <delYsid> head is as much of a mistake as pattern matching on head is.
07:30:58 <delYsid> but yeah, I am on your side regarding compile-time vs. runtime errors, I also want the compiler to tell me, instead of having to write a test case that covers the error case.
07:30:58 <julianleviston> delYsid: not if you pattern match the empty list as well.
07:31:25 <delYsid> julianleviston: Sure, but same applies to using head without a conditional.
07:31:34 <julianleviston> delYsid: yes. exactly.
07:31:43 <delYsid> so its the same game.
07:32:02 <delYsid> *you* as a programmer have to know, the compiler is not helping you, because we are dealing with runtime data.
07:32:03 <julianleviston> delYsid: in the one case you get an irrefutable pattern compile error, tho, right?
07:32:33 <julianleviston> delYsid: I don’t see it that way at all.
07:32:37 <delYsid> julianleviston: I am not sure, I hope so.
07:32:56 <julianleviston> delYsid: yeah, pretty sure.
07:33:44 <delYsid> IIRC, incomplete patterns do not raise an error inside of do-notation, but thats fine.
07:34:07 <kriztw> with pattern matching you can at least make an -> error "func: impossible case", which is better than the error head gives if it fails
07:34:21 <hamilto-nyan> Can a monad transformer stack have multiple instances of the same kind of effect?
07:34:26 <hamilto-nyan> e.g., multiple MonadState layers
07:35:12 <delYsid> julianleviston: I think I see your point.  head is ineed more dangerous than pattern matching.
07:35:51 <julianleviston> delYsid: my point is relying on exceptions is probably a bad idea if you want your code to work well.
07:37:25 <julianleviston> …because it means the full semantics of your code’s execution shape is not captured within your code. 
07:39:59 <delYsid> @let groupTup' l = case l of { (x:y:xs) -> (x,Just y):groupTup' xs; [x] -> x:Nothing; _ -> []}
07:40:01 <lambdabot>  .L.hs:159:20:
07:40:01 <lambdabot>      Couldn't match expected type ‘[(a, Maybe a)]’
07:40:01 <lambdabot>                  with actual type ‘Maybe a0’
07:40:39 <delYsid> @let groupTup' l = case l of { (x:y:xs) -> (x,Just y):groupTup' xs; [x] -> [x,Nothing]; _ -> []}
07:40:40 <lambdabot>  .L.hs:159:20:
07:40:41 <lambdabot>      Couldn't match expected type ‘(a, Maybe a)’
07:40:41 <lambdabot>                  with actual type ‘Maybe a0’
07:41:00 <delYsid> gah, sorry, I shouldn't do that yet.
07:41:02 <julianleviston> delYsid: you can direct message lambdabot if you like.
07:43:00 <shlevy> Is there any way to get a report of which top-level declarations lack haddock comments overall or for some of their parameters/arguments?
07:46:30 <jkaye> In structured-haskell-mode, how can I add another case to an existing case statement? It seems that no matter which node I mark, C-j and ret both simply add newlines instead of inserting new cases
07:58:42 <Ankhers> jkaye: C-h c C-j
07:58:45 <Ankhers> What does it say?
07:59:04 <Ankhers> I think it had to do with electric indent.
07:59:26 <Ankhers> I believe it doesn't work with electric indent mode.
08:00:03 <Ankhers> jkaye: I had to add http://lpaste.net/141622 to my .emacs to get SHM to work correctly.
08:00:44 <jkaye> Ankhers: Mine is bound to shm/newline-indent
08:04:05 * hackagebot stack 0.1.5.0 - The Haskell Tool Stack  https://hackage.haskell.org/package/stack-0.1.5.0 (borsboom)
08:12:06 <asciiascetic> When using the TypeFamilies extension, does GHC do kind inference? That is, do I always need to provide the kind of my type declarations? Or when should I?
08:14:06 * hackagebot shelduck 0.1.3.0 - Test webhooks locally  https://hackage.haskell.org/package/shelduck-0.1.3.0 (boblong)
08:22:09 <anks> assuming i got function Word8 → Word8 → Word 16 how would I write Parser combinator to parse word16 ?
08:22:31 <haskell167> I am using Text.Regex.TDFA library to match "^[STFG]\\d{7}[A-Z]$" but somehow it doesn't get matched
08:23:21 <haskell167> Am I doing very stupid here?
08:23:24 <anks> ive tried this: thefunction <$> word8 <*> word8 , but it doesnt work
08:24:15 <haskell167> I am trying to match lazy text with above pattern
08:25:03 <mauke[1]> anks: how does it not work?
08:25:40 <anks> Couldn't match expected type ‘Data.Attoparsec.Internal.Types.Parser
08:25:40 <anks>                                  Data.ByteString.Internal.ByteString Word8’
08:25:40 <anks>              with actual type ‘Word8 -> Parser Word8’
08:25:40 <anks>  Probable cause: ‘word8’ is applied to too few arguments
08:26:15 <haskell167> my expression is `lazyText =~ ("^[STFG]\\d{7}[A-Z]$" :: Text) :: Bool` 
08:26:15 <anks> _ <$> word8 <*> word8  -- hole got type a0 -> a1 -> Word16
08:26:21 <haskell167> it returns me False
08:26:33 <haskell167> where lazyText = G1211211A
08:26:38 <mauke[1]> anks: sounds like word8 parses a specific byte only
08:26:55 <mauke[1]> haskell167: does that library support \d?
08:27:12 <anks> specific byte ? what do you mean ?
08:27:44 <mauke[1]> http://hackage.haskell.org/package/attoparsec-0.13.0.1/docs/Data-Attoparsec-ByteString.html#g:7
08:27:48 <mauke[1]> yep, I was right
08:27:59 <mauke[1]> 'word8 x' parses the byte x
08:27:59 <anks> oh boy
08:28:02 <anks> yeaaa
08:28:23 <anks> thx a lot.
08:29:36 <mauke[1]> haskell167: "The package does not provide Perl style regular expressions."
08:29:54 <Ankhers> jkaye: Did you compile the Haskell code?
08:31:01 <haskell216> Hi mauke sorry got disconnested same regex ;)
08:31:23 <haskell216> dint find much documentation for the library
08:33:29 <mauke[1]> haskell216: what?
08:33:45 <mauke[1]> what do you mean by "same regex"?
08:33:56 <mauke[1]> and what does that have to do with you getting disconnected?
08:34:18 <haskell216> oh same regex question "("^[STFG]\\d{7}[A-Z]$""
08:34:38 <haskell216> you said Text.Regex.TDFA doesn't support \d?
08:35:00 <mauke[1]> I asked you whether it did
08:35:16 <haskell216> not much documentation about it
08:35:18 <mauke[1]> and then you didn't answer, so I looked at the manual, and it said that it doesn't support perl-style regexes
08:35:31 <mauke[1]> <mauke[1]> haskell167: "The package does not provide Perl style regular expressions."
08:36:05 <haskell216> oh. where will I get comprehensive information about the library?
08:36:11 <haskell216> did not find much on hackage
08:37:02 <mauke[1]> "This regex-tdfa package implements, correctly, POSIX extended regular expressions." http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04
08:37:41 <haskell216> thanks, will read that
08:44:06 * hackagebot hapistrano 0.2.1.1 - A deployment library for Haskell applications  https://hackage.haskell.org/package/hapistrano-0.2.1.1 (jpvillaisaza)
08:45:01 <jkaye> Ankhers: Yeah, it compiles without a problem
08:47:44 <Ankhers> jkaye: Does any other part of SHM work for you? Does your mode-line say `SHM', `SHM!' or `SHM?'
08:48:24 <jkaye> Yup, lots of things are working. Data types work well, even case works well if I write a new one
08:48:31 <jkaye> But trying to add a new case to an existing statement
08:48:34 <jkaye> Doesn't seem to work
08:49:57 <Ankhers> My only suggestion would be to log a ticket on GitHub.
08:50:46 <jkaye> Ankhers: I'll probably do that. Thought I'd check if anyone had a similar problem first. Thanks
08:55:51 <Ankhers> jkaye: I hope it gets sorted out.
08:57:14 <jkaye> Ankhers: FWIW, it seems that I can work around the issue by making sure I'm at the end of the line and hitting C-j. Then the case isn't added for me but at least the cursor is in the right position
08:58:19 <parseIRC> hi, i was on earlier with a silly bug, which got fixed! here is the result, you should be able to use it to parse the irc logs for your conversations.... http://lpaste.net/141625
08:59:18 <parseIRC> would someone be able to appraise this for me?
08:59:28 <parseIRC> there are probably bugs...
08:59:36 <parseIRC> infact there are certainly bugs
09:00:14 <parseIRC> it would be great if i could get this to be more robust... http://lpaste.net/141625
09:02:09 <parseIRC> i think maybe that read fails on some bizare characters, or something
09:03:44 <mniip> so, how is it better than grep
09:03:47 <quicksilver> parseIRC: what are you trying to do with read ("\""++x++"\"") ?
09:03:57 <quicksilver> parseIRC: why would not just use 'x'
09:04:08 <quicksilver> are you trying to activate some part of the string escaping mechanism?
09:04:16 <parseIRC> it helps read not fail some of the time that it would otherwise fail. i think...
09:04:32 <parseIRC> yeh, its about getting the newlines right by using read
09:04:33 <mniip> ...
09:05:08 <parseIRC> probably not better than grep mniip, but for me its less work than learning how to use grep.... i know thats a lame reason
09:05:54 <mniip> grep '<parseIRC>' log/irc/freenode/#haskell/*
09:06:11 <parseIRC> ... ffs
09:06:12 <quicksilver> appendFile "myConvo.txt" x seems plausible to me...
09:06:22 <mniip> not very precise, but it's enough for most cases
09:06:26 <parseIRC> it puts it all in one line if you dont use read...
09:07:01 <quicksilver> I can't imagine why
09:07:10 <quicksilver> but just add your own newline if you want newlines
09:07:15 <parseIRC> mniip, i was going to use it to extract all the pdf's which were directed at me, and also i can control the html targets...
09:07:31 <quicksilver> appendFile "myConvo.txt" (x ++ "\n")
09:07:35 <mniip> html targets?
09:07:55 <mniip> a0
09:07:59 <parseIRC> quicksilver, the newlines are there, but gedit ignores them in some awful way if you dont use read... i dont know why
09:08:08 <mniip> oop
09:08:54 <julianleviston> does anyone know of any good typeclass and/or newtype exercises?
09:10:06 <parseIRC> https://wiki.haskell.org/Newtype
09:10:08 <mniip> julianleviston, implement Prelude!
09:10:27 <cocreature> julianleviston: nicta is fairly good for learning the standard type classes
09:10:39 <cocreature> which is basically reimplementing the prelude
09:10:45 <julianleviston> ah good idea.
09:10:46 <julianleviston> :)
09:10:57 <cocreature> not quite sure about newtype
09:10:57 <julianleviston> tho a lot of the typeclasses are rather complex, aren’t they?
09:11:28 <mauke[1]> I can't think of any class in Prelude I'd call "complex"
09:13:09 <clrnd> Monad
09:13:17 <parseIRC> so thats a big thumbs down for my irc parser?
09:13:28 <julianleviston> parseIRC: how do you mean?
09:13:39 <quicksilver> parseIRC: well as it stands it's an overcomplicated way to implement grep
09:13:44 <julianleviston> parseIRC: you could refactor and clean up the code a fair bit.
09:13:47 <quicksilver> but that doesn't mean it wasn't a useful learning exercise :)
09:14:11 <clrnd> parseIRC, everything can be done in a couple bash commands and pipes, bash is awesome, doesn't mean you should
09:14:13 <parseIRC> there is always typeclassopidia
09:14:18 <mauke[1]> clrnd: 2 tiny methods?
09:14:27 <mauke[1]> ok, and 2 other methods :-)
09:14:35 <julianleviston> mauke[1]: I’m trying to do exercise 2 in this: http://www.seas.upenn.edu/~cis194/hw/04-typeclasses.pdf
09:14:57 <mauke[1]> just as everything is a function in haskell, everything is a bash command in linux
09:15:13 <dolio> mauke[1]: RealFloat.
09:15:35 <mauke[1]> dolio: that's just tedious
09:15:41 <parseIRC> i didnt really learn too much... other than i suck at catching errors...
09:15:55 <dolio> Okay. :)
09:16:03 <mauke[1]> 13 methods, most of which take only one argument
09:16:10 <mauke[1]> no interesting type-level stuff
09:16:55 <jle`> definitely arguably "complex" :)
09:17:20 <clrnd> julianleviston, do you understand the mathematical aspect of excercise 2?
09:17:41 <julianleviston> clrnd: pretty sure it’s that [0,0,1,1] == [1,1]
09:17:47 <julianleviston> clrnd: or should ==…
09:17:52 <julianleviston> clrnd: that what you mean?
09:17:56 <clrnd> julianleviston, yeah
09:18:07 <julianleviston> clrnd: yeah… hang on i’ll pastie
09:18:20 <jle`> parseIRC: i think you did a good job
09:18:39 <julianleviston> clrnd: http://lpaste.net/141626
09:18:49 <julianleviston> clrnd: thanks so much for helping.
09:18:59 <parseIRC> i quite like Tree for its instances in looking at simple typeclasses well used in haskell https://hackage.haskell.org/package/containers-0.5.6.3/docs/src/Data-Tree.html#Tree
09:19:20 <parseIRC> thanks jle'
09:19:48 <mauke[1]> [0,0,1,1] is x^2 + x^3; [1,1] is 1 + x
09:20:36 <julianleviston> parseIRC: in particular, interested in polmorphic types being instanced to Eq.
09:20:42 <clrnd> julianleviston, the problem there is that you forgot to say that Eq (Poly a) works only if a is also in Eq
09:20:43 <julianleviston> (no idea if that’s the right language)
09:20:54 <julianleviston> clrnd: yeah, I don’t know how to say that
09:20:58 <clrnd> instance Eq a => Eq (Poly a) where ...
09:20:59 <julianleviston> clrnd: I *want* to say that :-)
09:21:05 <julianleviston> ahhh sweet
09:21:06 <clrnd> oh, perfect then!
09:21:11 <clrnd> syntax is the easy part :P
09:21:24 <julianleviston> clrnd: yeah, but I’d like more exercises because I need practice...
09:21:42 <julianleviston> preferably guided small-step practice  ;-)
09:22:20 <parseIRC> polymorphic types are what exactly (sorry for being a noob...) they have kind *->*?
09:22:25 <mauke[1]> julianleviston: won't that fail P [1, 2] /= P [3, 1, 2]?
09:23:01 <lyxia> parseIRC: types that contain type variables
09:23:02 <parseIRC> or its the concept of a superclass?
09:23:06 <julianleviston> mauke[1]: oh yeah… I’m sure it’s buggy.
09:23:27 <parseIRC> lyxia, so they have kind * -> * ?
09:23:34 <julianleviston> mauke[1]: I just got to that particular problem and realised I didn’t know how to make it show a is (Eq a) => 
09:23:37 <lyxia> parseIRC: No they have kind *
09:23:50 <parseIRC> hmmm....
09:24:04 <parseIRC> can i get an example of a polymorphic type?
09:24:22 <lyxia> parseIRC: A value with a polymorphic type can be used as if it had any type which is more specific.
09:24:33 <lyxia> parseIRC: a -> a
09:24:59 <parseIRC> oh, because a can be any type... ok i guess thats pretty simple
09:25:20 <mauke[1]> :t (==) `on` (dropWhile (0 ==) . reverse)
09:25:22 <lambdabot> (Eq a, Num a) => [a] -> [a] -> Bool
09:25:24 <mauke[1]> disgusting
09:25:42 <julianleviston> Maybe a ?
09:25:52 <julianleviston> mauke[1]: ok I’m sorry.
09:25:56 <mauke[1]> julianleviston: hmm?
09:26:09 <julianleviston> mauke[1]: weren’t you saying that code was disgusting? :)
09:26:21 <mauke[1]> yes, but why are you apologizing? I wrote it
09:26:37 <julianleviston> mauke[1]: Oh I thought I’d written it.
09:26:54 <mauke[1]> do you understand how it works? :-)
09:27:20 <julianleviston> mauke[1]: I’d written dropWhile (0 ==) . reverse earlier. lol
09:28:29 <mauke[1]> the fundamental disgustitude is in P itself
09:28:57 <parseIRC> :t filter
09:28:58 <mauke[1]> [0, 0 ..] should be equivalent to [] but there's no way to check that in finite time
09:28:59 <lambdabot> (a -> Bool) -> [a] -> [a]
09:29:28 <parseIRC> :t \a filter (a==)
09:29:29 <lambdabot> Parse error in pattern: a ==
09:29:37 <julianleviston> I actually have no idea how I’m going to check if this has no 0’s at the beginning given that it’s polymorphic… sigh
09:29:46 <hexagoxel> is there a nice way to annotate the types of results of binds in do-notation?
09:29:59 <parseIRC> :t \a -> filter (a==)
09:30:00 <lambdabot> Eq a => a -> [a] -> [a]
09:30:09 <parseIRC> thats more like it!
09:30:20 <julianleviston> parseIRC: huh?
09:30:37 <parseIRC> thats not what you were after?
09:30:41 <julianleviston> parseIRC: no
09:30:41 <parseIRC> sorry...
09:30:53 <julianleviston> parseIRC: because [0,1,1] should == [1,1]
09:31:15 <julianleviston> parseIRC: for this type.
09:31:20 <parseIRC> ok im going to read the excersize and stop making a fool of myself
09:31:26 <julianleviston> parseIRC: you’re fine :)
09:31:26 <mauke[1]> julianleviston: huh? didn't you say you'd written dropWhile (0 ==) . reverse earlier?
09:31:31 <mauke[1]> what's the problem?
09:31:39 <julianleviston> mauke[1]: it has 0 in it.
09:31:44 <julianleviston> mauke[1]: isn’t that the problem?
09:32:16 <mauke[1]> how is that a problem?
09:32:35 <julianleviston> Poly a = P [a] ? == Int ?
09:32:47 <julianleviston> maybe I’m missing something
09:33:01 <parseIRC> that link is dead for me... not sure why...
09:33:07 <julianleviston> oh weird
09:33:33 <julianleviston> parseIRC: just tried it again - works fine here http://www.seas.upenn.edu/~cis194/hw/04-typeclasses.pdf
09:33:37 <mauke[1]> :t 0
09:33:38 <lambdabot> Num a => a
09:33:39 <mauke[1]> not an Int
09:34:06 <julianleviston> mauke[1]: yeah but it’s a Num…
09:34:13 <parseIRC> works in chrome, dont know why i was using firefox...
09:34:16 <julianleviston> mauke[1]: won’t that constrain it to nums?
09:34:20 <mauke[1]> julianleviston: yes
09:34:25 <julianleviston> mauke[1]: ok.
09:34:26 <mauke[1]> which is sensible
09:34:44 <julianleviston> mauke[1]: cool then! :) It was just the Eq a => bit I was missing then! :)
09:34:48 <julianleviston> mauke[1]: thanks! :)
09:35:23 <mauke[1]> instance (Eq a, Num a) => Eq (P a)
09:36:32 <julianleviston> I need exercises.
09:36:44 <julianleviston> :)
09:38:15 <parseIRC> > (\ a b ->reverse (zipWith (==) (reverse a) (reverse b)) )[0,1,1] [1,1]
09:38:17 <lambdabot>  [True,True]
09:38:29 <parseIRC> :t (\ a b ->reverse (zipWith (==) (reverse a) (reverse b)) )[0,1,1] [1,1]
09:38:30 <lambdabot> [Bool]
09:38:34 <parseIRC> :t (\ a b ->reverse (zipWith (==) (reverse a) (reverse b)) )
09:38:36 <lambdabot> Eq a => [a] -> [a] -> [Bool]
09:38:52 <parseIRC> :t (\ a b ->all (zipWith (==) (reverse a) (reverse b)) )
09:38:53 <lambdabot>     Couldn't match expected type ‘a -> Bool’ with actual type ‘[Bool]’
09:38:53 <lambdabot>     Possible cause: ‘zipWith’ is applied to too many arguments
09:38:53 <lambdabot>     In the first argument of ‘all’, namely
09:39:00 <dolio> I think we don't all need to see this.
09:39:05 <parseIRC> :t (\ a b ->and (zipWith (==) (reverse a) (reverse b)) )
09:39:06 <lambdabot> Eq a => [a] -> [a] -> Bool
09:39:31 <parseIRC> dolio, please forgive me
09:39:52 <julianleviston> parseIRC: I have an answer dude. It’s cool.
09:39:52 <jle`> you can also always use lambdabot in PM too :)
09:40:18 <parseIRC> i guess i wanted to answer the question in public incase my answer looked wrong
09:40:33 <julianleviston> parseIRC: this is mine : http://lpaste.net/141627
09:40:39 <parseIRC> ok cheers
09:40:52 <parseIRC> im sorry im just messing things up here ill go
09:41:02 <julianleviston> parseIRC: feel free to answer in public, maybe just don’t work it out in public :) (Not that I haven’t done that before)
09:41:58 <parseIRC> fair
09:46:01 <lingxiao> hey all
09:46:03 <lingxiao> I have a style question
09:47:18 <ChristianS> lingxiao: go ahead
09:48:08 <lingxiao> so Im seeing this alot while grading homework
09:48:27 <lingxiao> data SimpleXML =
09:48:27 <lingxiao>           PCDATA  String
09:48:27 <lingxiao>         | Element ElementName [SimpleXML]
09:48:33 <lingxiao> suppsoe my datatype is that --^
09:48:44 <ChristianS> lingxiao: don't paste here, use a paste site
09:48:49 <lingxiao> i know im sorry :(*
09:48:53 <lingxiao> shouldve used hpaste
09:48:59 <lingxiao> it was an acciddent :-\
09:49:31 <lingxiao> so a bunch of people went ahead and defined their own funtion alias for value constructors, ie:
09:49:33 <dredozubov> how can i "eval" TFs in ghci?
09:49:39 <lingxiao> wrapInTag = Element
09:49:51 <dredozubov> something like :runtf IsFoo Foo
09:50:08 <lingxiao> And I think it's an extra level of indirection that's not necessary .. especially since all their code is in one document, and it's pretty short ... 40 - 50 lines
09:50:25 <ChristianS> lingxiao: i agree
09:50:36 <mauke[1]> but see smart constructors
09:51:13 <johnw> lingxiao: doing so does allow them to export their smart constructors, but not export their real constructors, thus permitting construction but not destruction
09:51:52 <dolio> dredozubov: Try :kind!
09:54:25 <kristof> Using data kinds is confusing.
09:54:37 <kristof> What's the difference between type constructors and data constructors at that point?
09:54:44 <julianleviston> So… does this… instance (Num a, Eq a) => Eq (Poly a) where … mean that while Poly a can be anything, you can only use Eq methods on it if it’s a number and its “contents” (given newtype Poly a = P [a]) are members of Eq?
09:55:50 <kristof> julianleviston: Yes.
09:55:51 <Cale> kristof: Well, each (ordinary) data constructor automatically defines a corresponding but not identical type constructor, and each (ordinary) data type automatically defines a corresponding kind.
09:55:53 <quicksilver> julianleviston: not "it's a number"
09:56:07 <julianleviston> quicksilver: hehe I was just reading that frowning :)
09:56:09 <quicksilver> julianleviston: the number constraint also applies to what you're calling the contents.
09:56:15 <julianleviston> quicksilver:  “is an instance of Num"
09:56:19 <kristof> Cale: Ah, okay. That makes more sense.
09:56:40 <quicksilver> julianleviston: both constraints refer to a not Poly a, is the point I'm making
09:56:46 <julianleviston> quicksilver:  but only when using == right? otherwise, I can say P [ “hey” ] ?
09:57:16 <julianleviston> quicksilver:  yeah, but I’m trying to work out if my newtype declaration is influenced by the Eq instance declaration
09:57:21 <julianleviston> quicksilver: I shoudl just try it out :)
09:57:42 <julianleviston> Ok works fine :)
09:57:43 <julianleviston> cool
09:58:22 <quicksilver> yes
09:58:47 <kristof> Cale: Yesterday people were talking about using Datakinds to make typeclasses be instances of other typeclasses. My question is, where would meta-typeclass even be used? This sounds like type level lambdas
09:59:01 <kristof> I mean, where would methods over typeclasses even be used
09:59:27 <Cale> kristof: I don't think that requires DataKinds...
09:59:32 <Cale> hmm
09:59:40 * hackagebot combinat 0.2.7.1 - Generate and manipulate various combinatorial objects.  https://hackage.haskell.org/package/combinat-0.2.7.1 (BalazsKomuves)
09:59:42 <Cale> But anyway, you might have something like
09:59:44 <kristof> Ah, well meta type classes are mostly what I'm asking about.
10:00:19 <Cale> class ConstrainedFunctor c f where cfmap :: (c a, c b) => (a -> b) -> f a -> f b
10:00:51 <kristof> Hmm
10:01:10 <julianleviston> quicksilver:  actually it *isn’t* influenced. I can write y = [“a”] just fine
10:01:15 <Cale> instance ConstrainedFunctor Ord Set where cfmap = Set.map
10:01:32 <lingxiao> ok great thanks!
10:01:34 <Cale> (actually, Set.map doesn't need the constraint on 'a' there)
10:01:38 <lingxiao> yeah they're not exporting anything
10:01:41 <lingxiao> its just an exrcise
10:01:43 <lingxiao> thank you all!
10:02:12 <quicksilver> julianleviston: yes the instances are only demaned if you try to use the Eq instance
10:02:22 <kristof> Why not instance Functor (Ord o) => Set where …
10:02:25 <julianleviston> quicksilver:  :) yay
10:02:32 <julianleviston> quicksilver:  thnx
10:03:04 <dolio> kristof: What is o?
10:03:35 <monochrom> if o is not mentioned in "Functor Set", then "Ord o" is vacuously true.
10:03:47 <bitemyapp> kristof: o no
10:03:52 <kristof> bitemyapp: shush
10:03:54 <Cale> kristof: Write the rest of the definition :)
10:04:01 <bitemyapp> kristof: no
10:05:22 <kristof> Cale: dolio: Okay, then I guess I would move the constraint to the definitions.
10:05:27 <Cale> Well, yeah, if you never again mention the type variable o, 1) The Ord o constraint isn't really constraining anything, and 2) There would be no way to decide which instance of Ord to supply due to ambiguity.
10:05:31 <kristof> Isn't that suggested practice, anyway? To constrain functions, not types?
10:05:43 <Cale> hm?
10:05:45 <dolio> What functions?
10:05:51 <kristof> fmap
10:05:59 <dolio> Then you have OrdFunctor
10:06:35 <dolio> Cale's parameterizes by the choice of Ord vs. anything else.
10:06:36 <kristof> Is it not legal to add a constraint to Ord in my instance of fmap?
10:06:41 <kristof> *constraint of Ord
10:06:45 <monochrom> Functor's definition is already written and it bears no Ord constraint
10:06:47 <Cale> Where would you even put it?
10:06:58 <Cale> :t fmap
10:06:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:07:05 <Cale> ^^ fmap's type doesn't mention Ord
10:07:14 <kristof> Ah, I can't refine it.
10:07:15 <lpaste> nchambers pasted “brainfuck.hs” at http://lpaste.net/141628
10:07:27 <nchambers> ^ would someone mind helping me with this
10:07:29 <Cale> If you want to put an Ord constraint on, you have to change the definition of Functor, which screws up all the programs ever written to use Functor.
10:07:33 <nchambers> errors are in the paste
10:07:58 <kristof> "There is only a functor definition of Set for elements that are Ord." You're saying ConstraintFunctor would be the only way to write that?
10:08:23 <quicksilver> nchambers: it's the semicolon on line 6 it doesn't like
10:08:29 <nchambers> oh ok
10:08:36 <julianleviston> nchambers:  what does tape[cell] mean?
10:08:43 <nchambers> so just break it up to multiple lines?
10:08:46 <quicksilver> or is it
10:08:58 <Cale> kristof: You could also just define a new typeclass like:
10:09:07 <nchambers> julianleviston: err sorry... habits. I meant tape !! cell
10:09:10 <kristof> Cale: We've actually come across this very problem recently discussing what higher kinded types would look like in Rust.
10:09:11 <Cale> class OrdFunctor f where ofmap :: (Ord b) => (a -> b) -> f a -> f b
10:09:12 <quicksilver> nchambers: breaking it up into lines doesn't help
10:09:14 <julianleviston> nchambers:  ah!
10:09:18 <quicksilver> nchambers: that's still not haskell
10:09:30 <quicksilver> two expressions separated by ; or separated by newlines is not haskell
10:09:40 <quicksilver> an expression is, well - only one expression.
10:09:47 <nchambers> quicksilver: oh? can I only have one expression then?
10:10:02 <quicksilver> yes.
10:10:06 <kristof> Cale: We want a typeclass to be generic, which is what we want for most instances of that typeclass, but in one case there is no way to write one of the methods without imposing additional constraints that affect everyone else unnecessarily.
10:10:25 <julianleviston> nchambers:  what’s code?
10:10:28 <Cale> kristof: Yes, there is no way around this
10:10:40 <nchambers> julianleviston: brainfuck code
10:10:42 <julianleviston> nchambers:  your first pattern match - line 3… what is code?
10:10:43 <kristof> Cale: The suggested solution was an extension to type families that allowed you to associate traits
10:10:54 <julianleviston> nchambers:  it doesn’t appear anywhere else.
10:11:09 <kristof> I'm sorry, typeclasses
10:11:17 <nchambers> julianleviston: oh oops... I forgot to take that out. I was originally going to return the whole code when I ran out of op codes
10:11:26 <quicksilver> I'm fairly sure what you want is (execute code_tail (take cell tape ++ ((tape !! cell)+1) ++ drop (cell+1) tape) cell)
10:11:36 <quicksilver> I might have an off-by-one error there
10:11:37 <julianleviston> nchambers:  can I suggest wholemeal programming? Do it in pieces, and check it at each tiny change.
10:11:48 <quicksilver> but I think you need to follow a journey to reach that point
10:11:48 <Cale> kristof: The "Set can't be made an instance of Functor" problem is quite old, and there are lots of solutions to it, but they all have downsides.
10:12:08 <nchambers> quicksilver: yeah... this might have been a bit too ambitious starting off
10:12:11 <nchambers> julianleviston: eh
10:12:12 <quicksilver> you seem to think you can modify one cell in the list? you can't; haskell data is immutable. all you can do is build the new list based on the old one.
10:12:32 <nchambers> I was worried I would have to do that
10:12:42 <kristof> Cale: I see. Over the many years that I've seen you in this channel I've come to trust your opinion, so what is your favorite solution?
10:12:46 <julianleviston> nchambers: comment out everything but the very first thing that works… then slowly introduce bits.
10:13:48 <Cale> kristof: I don't know. It depends on whether I want to abstract over those operations which don't quite fit. It hasn't really been so important to be able to generalise over Set.map usually, and so having it be its own thing hasn't really been that painful.
10:14:10 <Cale> kristof: There are not *that* many other data structures which require an Ord constraint to map over them.
10:14:45 <kristof> Cale: In Rust, we don't actually have a single closure type, we have a few particular closure typeclasses.
10:15:28 <Cale> I find it weird that you'd have an exposed closure type at all, though this is possibly just a nitpick about terminology ;)
10:16:04 <Shockk> are there any guidelines for sending to one of the mailing lists? for example, should I specify the Reply-To field as the same mailing list address?
10:16:15 <Cale> I refuse to use the term "closure" for any data structure for which I can no longer separate the pair of code and environment mapping.
10:16:36 <kristof> Cale: So in spitballing what a Monad typeclass would look like, we found that some types required a stricter closure typeclass than others. Monads that sequentially apply some f to their innards need a closure that can be applied many times, while there are other closures that can only be called once that are equally valid to be used in other monad instances.
10:16:36 <Cale> Once you use closures to implement functions, and hide the ability to do that, they're not closures any more :)
10:16:56 <Cale> (they're just functions of some sort)
10:17:00 <kristof> Cale: Ah, but in Rust we have unboxed closures and throw them directly on the stack.
10:17:11 <kristof> Cale: Even the ones with dynamic environment. It's a neat trick.
10:17:58 <kristof> But it means all closures have unique types because they have different representations. So the type looks something like [closure: anon linenum] 
10:18:09 <Cale> So can you inspect what's in the environment of a closure, and perhaps make a new closure with the same code and different environment from it?
10:18:09 <kristof> But they all implement some typeclass.
10:19:02 <Cale> If so, then I guess it's fair to call them closures :)
10:19:21 <kristof> Cale: There are two reason why you wouldn't be able to do that. One is that the types are opaque, and the other is that the types are anonymized so you wouldn't be able to refer to any member of their environment in a way the compiler would let you :P
10:19:49 <Shockk> Cale: could a typeclass be multiparam and take a constraint kind or something to solve what kristof was asking?
10:19:57 <Shockk> or do I misunderstand what constraint kinds are?
10:20:02 <Cale> Shockk: Did you miss my paste?
10:20:11 <Shockk> I did sorry, I've just come in
10:20:15 <Cale> Or, not paste :)
10:20:22 <Cale> class ConstrainedFunctor c f where cfmap :: (c a, c b) => (a -> b) -> f a -> f b
10:20:23 <kristof> Was that an example of constraint kinds?
10:20:41 <Cale> (you only need to constrain b for Set's case though)
10:20:43 <jkaye> How is it possible for a case to fail pattern matching when the final pattern is _ -> ?
10:20:46 <dolio> kristof: Yes. Ord :: * -> Constraint
10:20:56 <Cale> yeah
10:21:27 <Shockk> ahh interesting
10:21:39 <kristof> Cale: Okay, what about some class that is parameterized over c, but c must always at least satisfy some constraint?
10:21:45 <Shockk> is there some identity constraint defined?
10:21:59 <Shockk> like class Identity a
10:22:07 <Shockk> and instance Identity a
10:22:22 <Cale> oh, actually, there needs to be a fundep as well
10:22:25 <Cale> f -> c
10:22:43 <kristof> In other words, the Constrained class can be instantiated for any c, but c must be an instance of some particular class c0
10:22:53 <Shockk> I need to learn functional dependencies at some point
10:23:26 <lpaste> Cale pasted “working example” at http://lpaste.net/141629
10:23:58 <Cale> kristof: That's also possible, but I can't think of any use case off hand
10:24:17 <kristof> Shockk: class name parameters* | one_parameter -> other reads quite nicely as "the class name takes parameters*, where one_paramter uniquely determines the other"
10:24:35 <kristof> Cale: Precisely what I mentioned earlier :)
10:24:40 <Cale> kristof: Which doesn't mean that they don't exist -- there might be many, I just don't have enough experience abstracting over constraints to know when I'd like to abstract over constraint abstractions.
10:26:26 <quicksilver> jkaye: it isn't
10:26:56 <kristof> Cale: Yeah, in Rust we have come across the problem of trying to say "Our Monad class should be parameterized over some type f which at minimum satisfies the FunctionOnce constraint (can be called once) but which may be refined by other instances as necessary"
10:27:05 <jkaye> quicksilver: You're right, I was misreading the error
10:27:09 <quicksilver> :)
10:27:10 <jkaye> All set now, thanks
10:27:39 <Cale> kristof: That sounds like something other than Monad
10:28:12 <kristof> Cale: Well, something like Maybe only requires that during a bind, the function be called once.
10:28:23 <kristof> No more than once, rather.
10:28:25 <kristof> That is a monad.
10:28:31 <Cale> Uh, what about list?
10:28:39 <t7> whats the regex lib everyone uses?
10:28:47 <kristof> That requires a function that can be called many times :) which is precisely the problem
10:28:57 <Cale> Drop the constraint altogether
10:29:13 <Cale> At least, if you want the class to be for monads
10:29:20 <kristof> You mean the constraint on F?
10:29:23 <Cale> Parser is another big practical one
10:29:24 <Cale> yes
10:29:42 <kristof> Then there is no way to define default methods in the typeclass because you cannot treat the f as a function
10:29:47 <Cale> If you want to do backtracking parsers, you need to be able to apply the function to the right of >>= zero or more times.
10:29:59 <Cale> what?
10:30:03 <Zemyla> I wish that divMod were separated from toInteger.
10:30:19 <Cale> Zemyla: hmm
10:30:21 <Zemyla> Because I have things that can be divModded, but not converted to Integers.
10:30:30 <Cale> Zemyla: Are you sure?
10:30:43 <Zemyla> Yeah. Dice.
10:30:55 <Zemyla> Well, probability distributions.
10:31:33 <Cale> I suppose that's sensible enough :)
10:31:34 <kristof> Cale: What I just said was nonsense, never mind.
10:32:43 <kristof> Cale: Well, actually...
10:33:07 <kristof> Cale: (>>=) :: forall a b. m a -> (a -> m b) -> m b
10:33:19 <Zemyla> Yeah, I want to be able to divide two integer dice, and I suppose I could create another function for it, but that seems wrong.
10:33:36 <jacereda> What's the equivalent of "runhaskell -ifoo Main.hs" in a sandboxed environment?
10:34:03 <Shockk> bah I just realized I published my package on hackage using the function I pull requested to containers that doesn't exist yet
10:34:07 <geekosaur> prepend "cabal exec --" (or "stack exec --")?
10:34:21 <jacereda> geekosaur: I tried but it doesn't seem to find the packages for some reason
10:34:56 <kristof> Cale: Using Rust's type system, this would look more like (>>=) :: (Fn f) => m a -> f -> m b
10:35:27 <Shockk> is there no way in Haskell in 'catch' a call to error?
10:35:45 <kristof> Cale: So if we dropped the constraints entirely then (>>=) :: m a -> f -> m b. :(
10:36:24 <geekosaur> Shockk: catch (\(ErrorCall msg) -> handler) ... -- with ScopedTypeVariables enabled
10:36:42 <Shockk> geekosaur: ooh thanks
10:36:53 <geekosaur> or other handler functions from Control.Exception; the key is the exception type being ErrorCall
10:37:55 <Shockk> :t const
10:37:57 <lambdabot> a -> b -> a
10:38:15 <Shockk> is there a short name for (flip const)?
10:38:46 <shachaf> No.
10:38:57 <Shockk> oh no, I need to match ErrorCall anyway so that's a silly question to begin with
10:40:37 <Cale> kristof: That seems questionable. :)
10:40:46 <Cale> kristof: Why not m a -> (a -> m b) -> m b?
10:40:57 <Cale> kristof: Rust just can't function types?
10:41:14 <Vq> What's the point of the MonadState, MonadReader, etc instances for Free in the free package?
10:41:50 <bitemyapp> Vq: so you don't have to write them if Free is in your stack.
10:42:15 <ggole> Rust has some "closure type" stuff going on which might complicate that
10:42:31 <Shockk> oh, catch is in IO :(
10:43:40 <Cale> Shockk: This is why you don't take ReaderT/StateT lightly :)
10:43:44 <geekosaur> Shockk, yes, exceptions can only be caught in IO. if you want something "exception-ish" that isn't in IO, you're looking at Either or possibly Cont
10:43:51 <Vq> bitemyapp: But they force my f in (Free f) to be a monad when I want to implement the interface (or face overlapping instances which admitedly I can work around nicely with 7.10).
10:44:00 <pleiosaur> closures in rust need special care because they're unboxed, and have the same shared/mutable/owned trichotomy as the rest of the type system
10:45:05 <Cale> pleiosaur: Sounds troublesome
10:45:08 <johnw> Vq: they allow MonadReader to "bleed through", in those cases where you are applying Free to a monad
10:46:53 <Vq> johnw: For my application transformers don't make sense and I wanted the MonadState behaviour.
10:48:01 <pleiosaur> Cale: it's very consistent with the rest of the language, but composing functions definitely isn't as easy. zero-cost abstractions are a hell of a drug :P
10:48:46 <Cale> pleiosaur: Does it also have boxed, nicely typed functions?
10:48:49 <johnw> Vq: can you show me the code you're having difficulties with?
10:48:57 <Cale> If not, maybe it ought to.
10:49:47 <pleiosaur> Cale: closures are unboxed, but you can box them yourself. `FnOnce(Foo)->Bar` would be an unboxed closure type, `Box<FnOnce(Foo)->Bar>` is a boxed type, which is often easier to use
10:50:13 <monochrom> GHC moves costs of abstraction from run time to cabal time
10:52:33 <Vq> johnw: http://lpaste.net/141630
10:54:08 <Vq> johnw: It's an excerpt, I got a few different interpreters for it.  One for IO/STM and some pure ones.
10:54:27 <johnw> Vq: that instance is not right
10:54:37 <johnw> Vq: you're saying that Game a is a monad whose state is 'a'?
10:54:42 * hackagebot polymap 0.1.0.1 - Polydirectional maps  https://hackage.haskell.org/package/polymap-0.1.0.1 (Shockk)
10:54:47 <johnw> oh, sorry
10:54:49 <johnw> misread the type variables
10:56:13 <Vq> johnw: It actually works with the {-# OVERLAPPING #-}  so it can't be that wrong. :)
10:56:14 <johnw> Vq: in this sort of situation, you'll need to make Game a newtype, not a type synonym
10:56:31 <johnw> yeah, here OVERLAPPING is like an override, but it's bad practice
10:57:15 <johnw> oh, wait
10:57:16 <johnw> of course
10:57:28 <johnw> make (GameF s) the instance of MonadState, and it should all work
10:58:00 <Vq> (GameF s) isn't a monad though.
10:58:21 <monochrom> hmm!
10:58:22 <Vq> And there isn't really a good implementation for it, it's just a Functor.
10:58:30 <johnw> I'm beginning to think this is a bug in 'free'.  Wonder what edwardk says
10:58:53 <johnw> because you're right, this is a Catch-22, forcing you to use a newtype
10:58:54 <Sindriava> Are there any good resources on ResourceT?
10:59:00 <edwardk> which bug?
10:59:07 <Sindriava> I can't really find any :/
10:59:14 <Sindriava> Which is ironical, given it's ResourceT :D
10:59:19 <johnw> edwardk: (Functor m, MonadState s m) => MonadState s (Free m)
10:59:27 <Vq> I could use a newtype but it feels like a hassle to reimplement all the typeclasses.
10:59:28 <edwardk> johnw: that is a dangerous instance
10:59:36 <edwardk> all of the instances on Free that lift in like that are dangerous
10:59:40 <edwardk> they only hold 'up to retract'
10:59:45 <edwardk> but that never stopped folks from using them
10:59:50 <Sindriava> Vq: You can use GeneralisedNewtypeDeriving, maybe?
10:59:51 <Vq> edwardk: I'm not using it.
10:59:53 <johnw> Vq: GeneralizedNewtypeDeriving will make the reimplementation trivial
11:00:02 <sinelaw> edwardk, you mentioned yesterday there's a problem with how unification-fd does weighted path compression? what is it?
11:00:09 <johnw> edwardk: what I mean is, your 'free' library provides that instance
11:00:10 <Vq> edwardk: It's in my way when I want to implement my own MonadState.
11:00:13 <johnw> edwardk: and I'm thinking it shouldn't
11:00:40 <edwardk> johnw: i get a fair bit of complaining about the presence of any instances for free that aren't fully legal ;)
11:00:57 <johnw> because what if m isn't MonadState s, but Free m is a legitimate MonadState s, as is the case here
11:00:58 <edwardk> so lets just say i'm less militant on this issue than you might be =P
11:01:03 <johnw> haha
11:01:09 <Vq> edwardk: To be fair, I would have complained even if it were legal. ;)
11:01:43 <edwardk> vq: any decision i make here is wrong in some sense, so i'm going to stick to the status quo for now
11:01:53 <edwardk> as it is the least disruptive of two bad options
11:01:55 <johnw> I'm just wondering if the utility of (Functor m, MonadState s m) => MonadState s (Free m) is greater than allowing Free m to be MonadState for particular m
11:01:56 <Vq> edwardk: Fair enough
11:02:21 <edwardk> johnw: any such instance would be an orphan mess
11:02:29 <johnw> edwardk: ok, status quo it is, thanks for chiming in!
11:02:45 <Vq> Can I automagically derive the (Free f) Monad implementation in a newtype?
11:02:47 <edwardk> it doesn't 'own' Free, so it shouldn't be making instances for it.
11:02:52 <edwardk> vq: absolutely
11:03:06 <edwardk> that is the solution i was going to offer
11:03:19 <edwardk> once you shove it in a newtype you 'own' the whole thing and can carve out whatever instances you like
11:03:42 <Vq> Sounds a lot more reasonable than my overlapping pragma.
11:03:44 <dolio> edwardk: That's not true for a sufficiently enhanced definition of what makes an orphan.
11:04:18 <Sindriava> Vq: Also careful with newtypes when dealing with Haskell's FFI, I've heard it can cause troubles when doing runtime magic
11:04:19 <edwardk> not entirely true, but it needs flexibleinstances and messiness that i generally don't let myself use at all
11:04:31 <edwardk> Sindriava: ?
11:04:42 * hackagebot crypto-enigma 0.0.1.3 - An Enigma machine simulator with display.  https://hackage.haskell.org/package/crypto-enigma-0.0.1.3 (Orome)
11:04:44 * hackagebot MTGBuilder 0.1.0.0 - Builds decks out of a meta  https://hackage.haskell.org/package/MTGBuilder-0.1.0.0 (willfancher)
11:04:57 <diracdelta> Does ghc provide an option to emit an abstract syntax tree from a file?
11:04:57 <monochrom> hearsay is the root of all evil
11:05:13 <Sindriava> edwardk: AFAIK newtypes can disappear during compilation, which could cause confusion when doing finicky stuff with the code after it's compiled
11:05:40 <mniip> is there a way to do induction on typelit naturals?
11:06:08 <edwardk> Sindriava: newtypes _do_ disappear during compilation. this doesn't create any specific FFI issues though
11:06:13 <mniip> '0' and '(1 <= n) => n' are overlapping for GHC
11:06:28 <edwardk> mniip: short answer: no. they are basically useless right now
11:06:35 <mniip> :(
11:06:40 <Sindriava> edwardk: Not during compilation.
11:06:50 <Sindriava> edwardk: But I assume some tags could be missing in the compiled code?
11:06:56 <edwardk> Sindriava: i still have no idea what issue you are trying to allude to
11:07:02 <edwardk> what 'tags'?
11:07:17 <Sindriava> edwardk: Eh, nevermind, this is lowlevel stuff that doesn't belong here
11:07:26 <edwardk> you give me an foreign function that takes some arguments newtype or not, i call it.
11:07:30 <edwardk> it works
11:07:36 <edwardk> the ffi definition said what it took
11:07:49 <Sindriava> edwardk: As I said. *AFTER* compilation
11:08:03 <edwardk> it belongs here if it belongs anywhere, so i earnestly want to clarify your concern, because i don't believe it holds any water.
11:08:09 <Sindriava> anyways, what I was going for is that it's important to remember newtypes can disappear sometimes
11:08:36 <edwardk> Sindriava: newtypes disappear _all_ the time. the only thing they are 'visible to' is the typeclass machinery and type inference.
11:08:51 <Sindriava> edwardk: More so, then.
11:08:52 <edwardk> but anything FFI based is written to a concrete type
11:09:06 <Sindriava> edwardk: You are talking about Haskell's FFI only
11:09:18 <edwardk> ok, what other ffi do you have in mind?
11:09:26 <Sindriava> edwardk: You could be working with compiled code *AFTER* compilation
11:09:29 <Vq> edwardk: Were you thinking of the GeneralizedNewtypeDeriving extension for deriving Monad?
11:09:42 <Sindriava> edwardk: `newtype Foo = Foo Int` and `data Foo = Foo Int` produce different binaries, right?
11:09:50 <edwardk> Sindriava: yes, deliberately so
11:09:58 <edwardk> because they have different operational characteristics
11:10:08 <Sindriava> edwardk: Yes, I know, no need to explain, thanks
11:10:18 <Sindriava> edwardk: Then if you were not aware of that fact, it could cause confusion when working with that binary
11:10:37 <monochrom> "data Foo = Foo Int" makes Foo ineligible for FFI to begin with.
11:10:42 <edwardk> you're saying basically 'using a newtype' makes a different thing than making a data type. but then ANYTHING you do changing a data type has that same effect. you swap the order of constructors, you add a field, add a constraint, etc.
11:10:48 <edwardk> _none_ of that goes out to the FFI at all
11:10:57 <mniip> oh are you serious
11:10:58 <edwardk> and i'm pretty sure you're not hot-swapping haskell
11:11:18 * Sindriava sighs
11:11:19 <mniip> Nat -> INat where data INat = Z | S Inat
11:11:24 <mniip> requires undecidableInstances
11:11:31 <monochrom> in other words no one cares about the runtime representation of "data Foo = Foo Int" in the context of FFI. you simply can't use it.
11:11:46 <Sindriava> edwardk: What's so difficult about this? I was *just* pointing out the fact that this could be confusing
11:11:55 <Sindriava> which it was, when I encoutered it, when looking through the compiled binary
11:13:02 <Sindriava> edwardk: You're reading too much into it, let's leave it
11:13:13 <edwardk> Sindriava: and i'm just pointing out that it is no worse than any other scenario where you define two different things and get different results.
11:13:15 <edwardk> gotta go anyways
11:13:27 <Sindriava> edwardk: You don't have to define the newtype
11:13:51 <Sindriava> if you don't get to see the part where the newtype is defined, only the part where it's used, you might not know it's a newtype
11:14:09 <Sindriava> edwardk: *DUH* you get different results from different stuff
11:14:23 <Sindriava> but the stuff doesn't have to appear different at first sight, was my point
11:14:43 * hackagebot MTGBuilder 0.1.0.1 - Builds decks out of a meta  https://hackage.haskell.org/package/MTGBuilder-0.1.0.1 (willfancher)
11:14:55 <edwardk> Sindriava: none of the code you write can or should be able to care that it is a newtype or a data type that is strict in its first argument unless you start invoking unsafeCoerce and the like whereupon you have bigger problems
11:15:18 <edwardk> (or unless you take advantage of generalizednewtypederiving which is just shut off from you in the latter scenario)
11:15:26 <Sindriava> edwardk: Which is my point, why are you explaing this
11:15:30 * Sindriava rolls on the floor
11:15:47 <Sindriava> edwardk: It makes the newtype hard to notice sometimes, *that's it*
11:15:52 <edwardk> Sindriava: because you started shouting from the bloody rooftops that it was somehow dangerous to use newtype deriving for rather incoherent reasons.
11:15:59 <edwardk> good day
11:16:07 <Sindriava> edwardk: Why this tone all of a sudden?
11:16:08 <edwardk> er not newtype deriving, newtypes
11:16:11 <Sindriava> edwardk: No need to get personal :/
11:16:32 <Sindriava> edwardk: And I wasn't saying it was dangerous, just that it *can* be dangerous under certain circumstances
11:16:49 <Sindriava> edwardk: If those circumstances aren't common for you, it doesn't mean they aren't for someone else.
11:16:52 <tsahyt> Wasn't there something about generalized newtype deriving that was actually unsafe?
11:17:13 <edwardk> and what i'm saying is that the warning you are giving is all our of proportion to any actual concern and you keep on going on about magical dangers
11:17:30 <edwardk> tsahyt: that was 'fixed' by the roles machinery
11:17:37 <monochrom> \∩/
11:17:51 <monochrom> wait, you put quotes around "fixed"
11:17:58 <Denommus> I think I just thought about the slowest implementation of factorial ever :-D
11:18:00 <Sindriava> edwardk: I really don't appreciate how condescending you are. I mean, hats off if you understood everything perfectly the minute you saw it, but this particular issue gave me days of grief until I realised it
11:18:12 <monochrom> Denommus: I want to know!
11:18:35 <Sindriava> edwardk: If I somehow offended you by trying to ensure others don't get stuck there (if in a maybe confusing way), I really apologize
11:18:58 <monochrom> my two cents: edwardk was not condescending.
11:19:03 <Sindriava> edwardk: But I don't think it's a reason to start personal attacks against me. I *genuinely* don't feel comfortable right now
11:19:06 <edwardk> Sindriava: my concern is there are ~1500 people in here. and an assertion that newtypes are dangerous is something that if left unchallenged could cause a great deal of disproportional grief.
11:19:20 <Sindriava> edwardk: Can you quote me on that?
11:19:42 <Sindriava> edwardk: Because I don't really think that "newtypes are dangerous" is a reasonable interpretation of what I said
11:19:43 * hackagebot MTGBuilder 0.1.0.2 - Builds decks out of a meta  https://hackage.haskell.org/package/MTGBuilder-0.1.0.2 (willfancher)
11:20:09 <Sindriava> monochrom: Didn't have to be, maybe I just perceived it to be. This stuff is subjective, but thanks for the input, maybe I was looking to much into it
11:20:18 <Denommus> monochrom: you first define a permutations function
11:20:29 * davidfetter has no idea what this is all about, but "newtypes are dangerous" is a thing a person could very easily apprehend from what you said
11:20:33 <Denommus> monochrom: then factorial x = length . permutations $ take x $ repeat 1
11:20:54 <Sindriava> davidfetter: From what I said, or from the ensuing discussion where edwardk was contesting my claims?
11:21:09 <davidfetter> does it matter?
11:21:13 <Sindriava> davidfetter: because my statement was literally "Also careful with newtypes when dealing with Haskell's FFI, I've heard it can cause troubles when doing runtime magic"
11:21:23 <Sindriava> davidfetter: Which is *pretty specific* IMO
11:21:49 <Sindriava> Anyways, as I said, this doesn't belong here and I'm growing really tired of the hostile atmosphere, so I'll excuse myself
11:21:59 <davidfetter> you seem to be under the misapprehension that human communication is rational. please to disabuse yourself of that.
11:22:29 <Sindriava> I don't even know how to answer that.
11:22:38 <Sindriava> Sorry for trying to be as rational as possible?
11:22:39 <Sindriava> I guess.
11:22:53 <greg> lo
11:23:00 <Sindriava> Meh, I don't care about being right, if that's what's this is about
11:23:17 <Denommus> monochrom: of course, permutations can be defined as let permutations [] = [[]]; permutations (x:xs) = [y | p <- permutations xs, y <- interleave p] where interleave [] = [[x]]; interleave (y:ys) = (x:y:ys) : map (y:) (interleave ys)
11:25:10 <monochrom> Denommus: I'm wondering if this scheme is slower: multiply [1..n], but multiplication is done by repeated addition, and addition is done by repeated succ, e.g., n*m takes Θ(n*m) time
11:25:35 <Vq> johnw, edwardk: Works like a charm with newtype+GeneralisedNewtypeDeriving, thanks for the tip.
11:26:13 <monochrom> ah, yours is slower. mine takes Θ(n!) time, yours takes Θ(n! * time per permutation) time
11:26:46 <monochrom> that's probably Θ(n! * n)
11:27:28 <pikajude> is that (n+1)! - n!
11:27:42 <pikajude> no. i don't think so
11:29:04 <dolio> (n+1)! = (n+1)*n! = n*n! + n!
11:29:18 <pikajude> but it is nΓ(n+1)!
11:29:26 <pikajude> sorry, the last ! is enthusiasm, not factorial
11:31:26 <Sindriava|afk> pikajude :D
11:34:29 <mniip> if I have a kind E = L | R
11:34:58 <mniip> can I make a function forall (e :: E). F L -> F R -> F e
11:35:05 <mniip> without additional constraints on e
11:35:23 <Sindriava|afk> mniip: F is a functor?
11:35:50 <mniip> not important
11:36:07 <mniip> the idea is that based on the type of e, either L or R value will be used
11:36:17 <mniip> and the typechecker will be happy
11:37:16 <Sindriava|afk> Ah
11:37:23 <dolio> mniip: There's no way you will be able to write that, no.
11:37:37 <mniip> crap
11:38:27 <Sindriava|afk> mniip: What are you trying to do? ^^
11:38:35 <dolio> You can define a class that will let you define 'forall (e :: E). C e => F L -> F R -> F e', but that is as close as you will come.
11:38:44 <et09> https://gist.github.com/djvs/587723548af458d035c1 can anyone help me resolve this 
11:38:44 <dolio> C being the class.
11:39:06 <mniip> Sindriava|afk, still the same length-indexed lists
11:39:37 <mniip> data N = Z | S N
11:39:41 <Sindriava|afk> mniip: Length indexed?
11:40:05 <mniip> data L (n :: N) e where Nil :: L Z e; Cons :: e -> L n e -> L (S n) e
11:40:07 <Sindriava|afk> mniip: Like compile-time bounds checking?
11:40:13 <Sindriava|afk> ooh
11:40:15 <mniip> instance Applicative (L n) where pure = ???
11:41:37 <Sindriava|afk> mniip: length `n` list filled with the element?
11:41:49 <Sindriava|afk> mniip: I can't think of anything more minimal of the top of my head.
11:41:50 <Shockk> hm
11:42:28 <lpaste> Shockk pasted “?” at http://lpaste.net/141632
11:42:42 <Shockk> any idea why this happened?
11:42:51 <[1]et8> whats a good way to convert a PDF to an image in Haskell?
11:44:12 <cocreature> [1]et8: to be honest I would probably just call an external tool for that, e.g. imagemagick
11:44:45 <cocreature> I think inkscape can also do this via the command line so you could call that as well
11:45:23 <drewbert> There's a haskell library that wraps imagemagick.
11:45:24 <Hijiri> mniip: you might need special case for Z an S n
11:45:29 <Cale> [1]et8: http://hackage.haskell.org/package/poppler is probably useful
11:45:51 <Cale> [1]et8: Most of the Haskell tools for interacting with PDFs in any way just produce PDFs
11:46:01 <Hijiri> pure for Z would be const Nil, for S n is would be \x -> Cons x (pure x)
11:46:40 <Denommus> monochrom: I don't think that's slower XD
11:49:58 <Sindriava|afk> cocreature + 1, no need to do this manually IMO
11:50:08 <Sindriava|afk> [1]et8: What are you trying to do? :)
11:52:48 <dolio> Denommus: No?
11:53:01 <tsahyt> I just saw the implementation of the list monad in GHC.Base. It's written in terms of list comprehensions. I thought list comprehensions desugared to binds? Am I right to assume that they're actually special then?
11:53:27 <dolio> tsahyt: They don't turn into binds. They turn into other things.
11:53:52 <tsahyt> dolio: Ah okay.
11:57:53 <dolio> I should say, they don't turn into binds unless you enable the MonadComprehensions extension.
11:58:18 <Denommus> dolio: permutations have O(n!) time
11:59:07 <monochrom> more than that. it is not like you just need O(1) time to emit the next permutation
11:59:40 <Shockk> hahaha the generated haddock documentation for this file, this kind of thing gets me every time
11:59:42 <Shockk> https://hackage.haskell.org/package/polymap-0.1.0.1/docs/Data-PolyMap-Relation.html
11:59:45 <Sindriava> Are there any good resources on the ResourceT monad?
12:00:11 <johnw> Sindriava: http://www.yesodweb.com/blog/2011/12/resourcet
12:00:17 <johnw> Sindriava: https://www.fpcomplete.com/user/snoyberg/library-documentation/resourcet
12:00:36 <Sindriava> johnw: Thanks!
12:03:27 <jophish_> I wonder how tricky it would be to get basic Category Theory taught to high schoolers
12:03:33 <jophish_> or even some Type Theory
12:04:02 <johnw> it would be hard to motivate by example, wouldn't it?
12:04:16 <tsahyt> jophish_: How basic are we talking?
12:04:30 <bitemyapp> johnw: how easy is it to motivate FOIL?
12:04:40 <johnw> what is FOIL?
12:04:44 <jophish_> I suppose, as basic as the calculus and trig
12:05:45 <tsahyt> The bare basics of category theory aren't really that hard to grasp in my opinion
12:06:03 <johnw> tsahyt: even if you've never heard of set theory?
12:06:03 <tsahyt> Then again I already had quite a bit of experience with highly abstract things when I first looked at it
12:06:15 <cocreature> it's just hard to get what the point of it is if you don't have examples
12:06:22 <tsahyt> johnw: You don't need set theory to understand categories
12:06:26 <bitemyapp> johnw: is that version of Github with Free up anywhere?
12:06:29 <jophish_> johnw: I remember plenty of the high school maths not having too many real world examples
12:06:37 <bitemyapp> johnw: first outside inside last
12:06:38 <johnw> bitemyapp: "Github with Free"?
12:06:51 <bitemyapp> johnw: didn't you say you had a version of the client in prototype that used a Free monad?
12:07:03 <johnw> bitemyapp: oh, you mean gitlib v4?
12:07:19 <johnw> I also use Free to build a simple assembly language for do notation in another project
12:07:43 <johnw> I still don't understand motivating FOIL means, in the context of this discussion...
12:07:54 <tsahyt> johnw: I'd actually argue that not automatically thinking about functions between sets can be beneficial when you're trying to learn about categories
12:07:54 <bitemyapp> ohhhh gitlib
12:08:04 <bitemyapp> johnw: https://en.wikipedia.org/wiki/FOIL_method
12:08:07 <cocreature> jophish_: it's not only about real world examples, a lot of standard categories like Top and Vect and Set just don't make sense if you don't know what a topological space is
12:08:12 <cocreature> or a vector space or whatever
12:12:25 <jophish_> cocreature: I suppose the list of prerequisites is long to fully understand category theory, but there must be interesting subsets of it which don't require that
12:12:50 <cocreature> jophish_: interesting to whom is the question here :)
12:12:54 <tyler_durden> howdy, haskellers
12:13:23 <dolio> There's a book by Lawvere that you could probably teach to high school students. But it also covers a bunch of background on mathematics in general to be able to get to the category theory.
12:13:38 <jophish_> tyler_durden: Hi, nice to see you again. I loved that fighting club we had the other day. sorry I missed the beginning of it though
12:13:50 <diracdelta> jophish_: first rule man.
12:13:51 <tyler_durden> funny story, my actual name is tyler durden
12:14:16 <tyler_durden> and i was born before the book or movie
12:14:43 <jophish_> cocreature: the most sensible answer might be "interesting to university interviewers"
12:14:52 <dolio> And it would have to, because high school mathematics (at least in the US) doesn't cover much that is easy to abstract into category theory.
12:16:18 <tyler_durden> anyway, got a question about pattern matching. is there a way to do a default case? I know about otherwise (but this is not a guarded expression) and _ but that would overlap in this situation. I'm working on a simple evaluator here: http://pastebin.com/WgNpJY1k
12:16:26 <tyler_durden> Sorry about the line numbers being in the paste
12:16:46 <cocreature> tyler_durden: the pattern matchings are tried from top to bottom
12:16:50 <cocreature> so the overlap is no problem
12:17:10 <tyler_durden> I know! It shouldn't be! but ghc gives me an error
12:17:21 <dolio> Is it because you've covered all possible cases?
12:17:22 <jophish_> What's the error there?
12:17:25 <cocreature> then the other patterns already cover all the cases
12:17:41 <tyler_durden> the last line doesn't work due to patterns overlapping. I want to output an error if the user enters something like Plus (BoolLit True) (IntLit 3)
12:18:01 <tyler_durden> Oh shoot you know what, it does cover all patterns
12:18:04 <cocreature> that will be matched by Plus a b
12:18:14 <tyler_durden> Yes yes
12:18:25 <tyler_durden> I need to rethink this. It's a logic error, not a syntax error.
12:18:48 <cocreature> debugging brains is hard
12:21:48 <tyler_durden> This is for a homework assignment. Here's the instructions if it helps: http://pastebin.com/iNgkHjRk   I'm thinking of just leaving it as-is. If I currently do Plus (BoolLit True) (IntLit 3), it just spits the input back at me. But if I nest a function within one of the arguments, it recurses infinitely (as the pattern matching dictates). If I don't do that, I can't have nested evaluation in general (meaning the evaluator does n
12:33:55 <pilne> hello, anyone have a moment for an ubuntu 14.04 user that is having massive difficulty getting any tooling setup?
12:34:21 <cocreature> pilne: what kind of problem are you running into?
12:35:05 <pilne> the standard repos for ubuntu 14.04 are not installing anything that I can seem to even get to launch, and there are at least a dozen PPAs that come up with what look like somewhat "good" flies
12:36:09 <cocreature> If you're going for a ppa look for the one from hvr
12:36:30 <cocreature> another option would be to use https://github.com/commercialhaskell/stack to setup ghc
12:36:41 <pilne> should I try and uninstall everything that I pulled from the ubuntu repos before adding either of those?
12:37:03 <cocreature> wait, what exactly do you mean by tooling? just ghc and cabal?
12:37:58 <pilne> ... i think i followed the wrong instructions
12:38:10 <pilne> more redbull less water i think
12:38:35 <bitemyapp> pilne: https://github.com/bitemyapp/learnhaskell#installing-haskell
12:38:41 <bitemyapp> pilne: or as cocreature mentioned, Stack.
12:38:48 <cocreature> personally I would recommend uninstalling whatever you have installed and going with https://github.com/commercialhaskell/stack/blob/master/doc/install_and_upgrade.md#ubuntu
12:39:02 <bitemyapp> pilne: either should set you straight, but Stack will probably have you happier long term.
12:39:54 <pilne> ahhhh, yeah.... gotta love when the irc channel points you to instructions that state "do not install" what i already tried to install :)
12:40:19 <pilne> (: it happens, i do appreciate the prompt and helpful replies though
12:40:23 <bitemyapp> pilne: it happens a lot. We actually happen to be having a debate about this on the mailing list right now.
12:41:19 <dolio> Not everyone agrees with that recommendation.
12:41:24 <pilne> hopefully the end result of the debate will save at least one person who has decided to go functional, i've been coding in imperative languages for years, but when i would go back over my "scratch pad" of sorts for anything, everything was "planned out" functionally
12:42:07 <pilne> so i decided to jump in and learn haskell, figured it would be as easy as getting the python environment setup (: but i don't mind the challenge whatsoever
12:43:32 <cocreature> pilne: it's not that hard, there are just various options to get it setup which can be quite confusing
12:43:56 <cocreature> at some point it starts to make sense :)
12:44:09 <pilne> i'll agree, after spending a summer dabbling in slackware and gentoo linux distros, nothing seems hard anymore :)
12:44:30 <dmj`> nixpkgs works great too 
12:46:03 <Sindriava> jophish_: I hope I'm not late to the discussion, but IMO starting with high schoolers is skipping the universities
12:46:36 <Sindriava> jophish_: You could go through the whole 5 years of getting a programming master's on mine without hearing about categories AFAIK
12:47:40 <dolio> That goes for pretty much every other major except mathematics.
12:48:45 <Sindriava> dolio: It's not relevant for most other things you can get a major in, though :D
12:48:57 <Sindriava> dolio: I was really surprised how little theory I've encountered on uni so far
12:49:18 <Sindriava> Or more specifically, the theory is really weird and uneven
12:49:31 <Sindriava> "Here's a whole lot of theory on linear algebra"
12:49:37 <Sindriava> "Here's how to make a for loop"
12:49:39 <Sindriava> -.-
12:50:30 <Cale> Most undergraduate degrees in mathematics don't include a course on category theory either.
12:50:42 <Cale> You might be expected to know what a category is at the end of it though.
12:52:14 <pilne> thank you all for the help, i've saved those links and will give everything a shot later in the day!
12:52:21 <Cale> There's still a prevailing opinion (which is probably correct) that category theory is better saved as a graduate course in mathematics, because it's more relevant once you have lots of examples of categories (provided by other branches of mathematics) under your belt.
12:53:45 <Cale> So even though in principle category theory is not really much more abstract than group theory, the nature of the concrete examples tends to push it further along.
12:54:34 <linman32> is persistent-db able to encrypt/decrypt sql? using persistent-postgresql
12:54:41 <Sindriava> Cale: That's a fair point
12:54:48 <Sindriava> johnw: Got a minute? :)
12:58:40 <linman32> looks like this does the job for sqlite: https://github.com/emmanueltouzery/projectpad
13:03:34 <dolio> Cale: I might say category theory is actually too 'concrete' (or, specific) for teaching to undergrad CS students. :)
13:04:08 <monochrom> that's scary
13:04:15 <Cale> I can't say that I understand that remark
13:05:30 <Sindriava> I'd be happy if more languages had monads etc.
13:05:47 <breadmonster> Sindriava: Many languages have monads :P
13:05:54 <tsahyt> Some don't even know it
13:05:57 <breadmonster> I think you can implement monads in Java, it's just a design pattern.
13:06:15 <Sindriava> Oh, sorry, let me be specific enough so that noone can pretend they don't know what I meant:
13:06:15 <breadmonster> Or rather an abstraction, before people pounce on me.
13:06:35 <mauke> breadmonster: I don't think you can integrate them the way haskell does
13:06:46 <Sindriava> I wish more languages had this stuff as explicit and nicely implemented as Haskell does
13:06:56 * Vq miss the little things more, functors, monoids...
13:06:57 <breadmonster> mauke: Haskell has do notation, there's little else I imagine.
13:06:58 <pilne> i like how functional programs tend to handle data like i would handle it in the real world, leave the source intact and work with something on a "separate piece of paper" if it were.
13:07:10 <dolio> I mean I know why you should learn it to help with designing your data types and such, and representing things in different ways for performance.
13:07:11 <Sindriava> Vq: Good point.
13:07:11 <mauke> breadmonster: the main issue is 'return'
13:07:22 <breadmonster> mauke: What do you mean?
13:07:26 <dmj`> breadmonster: you can implement a specific monads (maybe monad), but java lacks higher kinded types, so it would be hard I imagine..
13:07:29 <dolio> Cale: But that's like teaching Java design patterns as part of your university curriculum.
13:07:49 <Sindriava> breadmonster: Not to mention "i wish more had" doesn't make "many have it" relevant
13:07:50 <breadmonster> dmj`: There's always interfaces, irrc.
13:07:51 <mauke> breadmonster: well, how do you represent Monad? as an interface?
13:08:14 <Sindriava> Java has Monads like C has OOP
13:08:26 <breadmonster> C doesn't have OOP?
13:08:29 <breadmonster> Or does it?
13:08:34 <dolio> Cale: It's too in-depth for a survey course on language paradigms and such.
13:08:38 <pilne> i wish i could use that "like C has OOP" quote with my normal social circle, i dig it.
13:08:42 <Sindriava> breadmonster: Java doesn't have Monads?
13:08:45 <Cale> dolio: There are definitely concepts from CT which all computer scientists sort of end up having to know
13:09:03 <Cale> dolio: It's sort of bad not to know what products and coproducts are, I think.
13:09:13 <Cale> (for instance)
13:09:22 <dolio> I guess. But I'm not sure it's worth teaching category theory for that, instead of just that.
13:09:23 <Sindriava> breadmonster: Nothing's stopping you from writing OOP code in C, just like nothing is stopping you to write functional code in C
13:09:47 <Cale> Yeah, it might not deserve its own whole course
13:09:48 <breadmonster> Sindriava: What about passing and returning functions?
13:09:50 <Sindriava> Cale: I don't know what those are, writing them down for future reference :D
13:09:52 <Cale> I agree
13:09:52 <tsahyt> breadmonster: You can kinda sorta write OOP code in C, but it's rather painful
13:09:55 <Sindriava> breadmonster: Function pointers.
13:10:04 <arkeet> Sindriava: what about closures?
13:10:07 <breadmonster> Sindriava: Creating functions on the spot?
13:10:16 <breadmonster> Yeah, closures.
13:10:25 <breadmonster> I keep forgetting these CS terms ><
13:10:32 <Sindriava> breadmonster: There's either compiler extensions for that, or some macro magic, or very explicit code
13:10:38 <breadmonster> tsahyt: Can I PM you? I'd like to know how.
13:10:45 <mauke> breadmonster: you create them manually
13:11:04 <arkeet> the high level effort is what would stop you, then.
13:11:07 <arkeet> level of effort
13:11:14 <Sindriava> arkeet: Yep.
13:11:30 <Sindriava> You can compile any language to C, C is turing complete.
13:12:01 <Sindriava> arkeet: I wasn't trying to say that it's reasonable to do it though. The origin was that "Java has Monads like C has OOP"
13:12:12 <dmj`> tristanp: ping 
13:12:16 <arkeet> alright.
13:12:28 <dseitz> C++ implements them by constructing an object on the fly
13:12:37 <dseitz> C, you'd have to emulate that the best you can
13:12:41 <Sindriava> arkeet: Sure, but sane people wouldn't consider it as "X having Y"
13:13:08 <tristanp> dmj`: ?
13:13:10 <Sindriava> Also, afaik anonymous functions aren't a requirement for functional programing… right?
13:13:30 <aweinstock> struct object { void(**)(void) vtable; char data[]; } // C has OOP
13:13:32 <Purlox> No, but they make it a pain to do functional programming without them.
13:13:32 <Sindriava> You can always name the function a random string of letters and extract it to a separate declaration
13:13:33 <Fuuzetsu> there's no strict definition
13:13:40 <Sindriava> arkeet: Oh yeah, I forgot about that!
13:14:08 <arkeet> ?? I haven't said anything
13:14:08 <lambdabot>  I haven't said anything
13:14:24 <Fuuzetsu> he meant aweinstock 
13:14:28 <Sindriava> arkeet: Oh, sorry, *aweinstock
13:14:28 <dmj`> tristanp: PM
13:14:43 <Sindriava> Purlox: What I meant is that there's no need for them to be "anonymous", e.g. not explitly named
13:15:05 <Sindriava> *explicitly
13:15:42 <aweinstock> struct monad_vtable { void* (*return)(void*); void* bind(void* (*f)(void*), void* x); } // kinda weakly typed
13:15:53 <Sindriava> neat
13:16:09 <Sindriava> Point being (this is getting OT), that Haskell has a good support for Monads and other things
13:16:22 <aweinstock> it enforces that the first argument to bind is a function, but not much else
13:16:26 <Sindriava> It makes them explicit and the syntax is pretty neat in itself (like => basically being implication)
13:16:47 <Sindriava> And I wish more languages had this. Most of them are pretty opaque now that I know Haskell
13:18:04 <Sindriava> With lens, you can write `foo.bar += 42` and every single part of that is well defined. None of it is syntax
13:18:21 <aweinstock> :t (+=)
13:18:22 <lambdabot> (Num a, MonadState s m) => ASetter' s a -> a -> m ()
13:18:34 <Fuuzetsu> syntax also tends to be well defined
13:18:46 <aweinstock> s/well/user/ ?
13:19:03 <Sindriava> Fuuzetsu: It tends to be well documented in most languages, but the reasons behind it can be quite arbitrary
13:19:29 <Sindriava> Fuuzetsu: like differentiating functions and variables
13:20:11 * Fuuzetsu takes a bad whiff of the ‘everything is a function’ smell
13:20:29 <Sindriava> ?
13:20:50 <Fuuzetsu> nothing, don't worry about it
13:21:11 <Sindriava> I don't mean to say everything is a function, but that everything is an expression
13:21:17 <Sindriava> some are just parametrised
13:21:29 <Sindriava> which I find soothing and calming. There's less stuff to worry about ^^
13:21:35 <Fuuzetsu> top level definitions are not expressions
13:21:41 <Fuuzetsu> or stuff in where
13:22:05 <Sindriava> Fuuzetsu: Weeell
13:22:08 <Fuuzetsu> and I know what you mean, just wish you were more specific
13:22:44 <Sindriava> I would hold back on the top-level definition ot being an expression.
13:23:08 <Fuuzetsu> Why?
13:23:23 <Sindriava> I know it's not literally implemented like that, but I imagine it like an expression inside the scope of a program
13:23:41 <hiptobecubic> Sindriava, well you can just imagine that about other languages too then
13:23:44 <Sindriava> kinda like `let <source> in call main`
13:24:06 <Fuuzetsu> as hiptobecubic points out, you have to be careful to not imagine too much
13:24:17 <Sindriava> hiptobecubic: Top level definitions? Sure. Everything else? No. Take part in the whole discussion please, not just parts of it
13:24:26 <Saizan> Sindriava: either you have a very broad meaning for expression, or data or class declarations won't really fit
13:24:39 <hiptobecubic> Sindriava, I had no reason to say anything until now.
13:25:12 <Sindriava> hiptobecubic: I can't imagine it about C's if statements, for example. So you comment was irrelevant in that.
13:25:17 <Sindriava> Saizan: Good point.
13:25:52 <Fuuzetsu> pretty sure even in C you can do stuff like ‘1 + (if p then x else y)’
13:25:57 <hiptobecubic> Sindriava, sure you can.
13:26:15 <Sindriava> Fuuzetsu: "like", yeah. As I said before, you can do anything in C.
13:26:19 <Fuuzetsu> if is a really bad example because it gets special treatment in Haskell
13:26:25 <Sindriava> hiptobecubic: Please stop.
13:26:37 <Sindriava> Fuuzetsu: Fair enough
13:26:39 <hiptobecubic> Sindriava, (p ? x : y) is an expression.
13:27:02 <Sindriava> hiptobecubic: Thank you for your input. How is that relevant?
13:27:14 <Sindriava> Saizan had a good point about class declarations, hmmm
13:27:14 <monochrom> what is the point of this prolonged discussion?
13:27:20 <Sindriava> monochrom + 1
13:27:20 <hiptobecubic> clearly nothing.
13:27:30 <Fuuzetsu> Sindriava: no, you can't do ‘anything’ in C; you can emulate the effects at best. ‘if’ is just a bad example
13:27:44 <Sindriava> Fuuzetsu: "emulate"
13:27:49 <Sindriava> Let's stop there.
13:28:09 <Sindriava> This is a discussion for other contexts that trying to prove other's wrong.
13:28:31 <aweinstock> C's (,) is Haskell's (>>), if that's relevent
13:28:44 <mauke> > [1,2] >> "abc"
13:28:46 <lambdabot>  "abcabc"
13:28:57 <Fuuzetsu> but you're wrong ;P If you don't want to discuss it then stop insisting otherwise. Anyway I grow tired of this as well
13:28:59 * Fuuzetsu tunes out
13:29:02 <Sindriava> mauke + 1, I was about to say something like that
13:29:03 <aweinstock> well, (>>) specialized to IO
13:29:18 <Fuuzetsu> I knew I should have stopped reading way up when someone mentioned Java and monads
13:29:21 <mauke> let foo = bar >> baz
13:29:46 <monochrom> on the other hand, I am not a fan of the postmodernist's "everyone is right" either
13:30:18 <sinelaw> you're also right
13:30:28 <monochrom> heh
13:30:47 <Sindriava> monochrom: The discussion was a bit more abstract than factual, so I what I meant was that "being right" is kinda moot
13:31:16 <Sindriava> monochrom: I imagine top level declarations being expressions in a similar way that I imagine IO being a state monad
13:32:24 <monochrom> I am a learner using the scientific method. if a hypothesis is made, and people tell me 20 ways to break that hypothesis, I am grateful, I learn 20 aspects of the thing.
13:34:07 <Saizan> Sindriava: btw, IO as a state monad does not make sense either :)
13:34:19 <Sindriava> Saizan: Elaborate?
13:34:32 <Sindriava> Saizan: It's compared to one in a plethora of resources
13:34:53 <bitemyapp> Sindriava: there are many bad explanations out there.
13:35:12 <monochrom> they were written before concurrency became popular
13:35:31 <pklausler> what, in the 1960's?
13:35:32 <Sindriava> monochrom: concurrency could break that model I guess
13:36:10 <Saizan> "forever (print ())" breaks that model as well
13:36:27 <monochrom> today the preferred model is a free monad and an interpreter
13:37:08 <aweinstock> :t GHC.Prim.RealWorld
13:37:09 <lambdabot>     Not in scope: data constructor ‘GHC.Prim.RealWorld’
13:37:15 <Sindriava> monochrom: ooh, that makes a bit more sense
13:37:57 <Luke> I'm using Options.Applicative and it doesn't seem to be showing the header and footer
13:38:40 <Sindriava> monochrom: Still, would likening TLDs to expressions like `let <code> in call main` be similar to likening IO to Free monad + interpreter?
13:39:21 <arkeet> everything is similar if you squint hard enough
13:39:24 <hiptobecubic> Seems odd to write your program by implementing your own new language and then programming in that. I get the benefits of being able to parametrize over the interpreter, but it still seems like a roundabout way to mock things and comes at a performance cost doesn't it?
13:39:55 <Sindriava> Maybe I'm being too lispy about it. It *is* true that if I have a file that contains just `print "foo"`, it doesn't work (unlike lisp)
13:40:50 <gganley> I feel like im doing something very wrong. I'm writing a SAT solver but when i try and write optimizations that require rewriting nested statements and back tracking I feel like im doing something wrong. and my implementation is absolutly appaling and I havent gotten off the ground really. simple things like ((Or A B) and A) => A is very difficult for me. I dont know whether im incompitent or I'm approaching it wron
13:40:50 <gganley> g
13:40:58 <monochrom> I don't know. I don't understand most analogies.
13:41:09 <bitemyapp> gganley: is this your first Haskell project?
13:41:25 <gganley> bitemyapp: no its not and thats what is concerning
13:41:29 <bitemyapp> IO doesn't need analogies to be explained and tutorials that resort to them suffer for it.
13:41:34 <Luke> anyone use optparse-applicative and know how to get header and footer to work?
13:41:38 <bitemyapp> gganley: my understanding was that SAT solvers were pretty difficult to write.
13:42:19 <bitemyapp> gganley: are you writing your stuff in terms of manually recursive functions?
13:42:20 <gganley> bitemyapp: the basic equation im writing is pretty easy and can be explained in notation on the back of a napkin. but writing it in haskell is getting on my nerves
13:42:44 <aweinstock> gganley: do you have a datatype that represents a logic formula?
13:42:45 <gganley> bitemyapp: I'm trying to write it in terms of `transform` functions from Control.Lens.Plated
13:43:09 <gganley> data Sat = Or Sat Sat | And Sat Sat | Or Sat | Var String | Val Bool
13:43:42 <hiptobecubic> gganley, this sounds like you're having trouble with the "optimizing compiler" half and not the "efficiently search the space" part
13:43:55 <pklausler> might help to normalize to CNF or DNF
13:45:25 <gganley> pklausler: thats how im planning on parsing in the data from command line yes
13:45:36 <gganley> but im not sure how that would help with rewriting
13:46:04 <dmj`> anyone know the guy who created vcache ?
13:46:11 <dmj`> the acid-state killer
13:46:24 <aweinstock> gganley: try writing a naive recursive bruteforcer first, to get started?
13:46:53 <gganley> aweinstock: that would be smart...
13:47:08 <gganley> aweinstock: I'll write that tonight 
13:47:59 <Fuuzetsu> dmj`: his info is on his GitHub if that's what you're after
13:48:19 <hiptobecubic> Isn't that somewhat independent of just rewriting the clauses using algebraic manipulation? Not that it's not a good idea, just that it's orthoganal.
13:49:00 <hiptobecubic> I'm no expert on compilers nor SAT solvers though, so you know... grain of salt and all that
13:50:45 <dmj`> Fuuzetsu: yea, was curious if anyone knew his handle
13:50:48 <gganley> hiptobecubic: I've never used ADT's like this so its completly new to me
13:51:10 <dmj`> Fuuzetsu: no worries
13:51:18 <Fuuzetsu> dmbarbour is the best guess though I can't say I have seen him before, maybe he just doesn't come on IRC
13:52:48 <bitemyapp> gganley: try not to blow your cognitive budget all at once
13:52:57 <bitemyapp> gganley: use what's comfortable/familiar, expand/refine incrementally
13:55:22 <radens> How do I rewrite this to be valid haskell? length tokens >= 2 and (tokens !! 1) == "(" = parse_func_call tokens
13:55:57 <Fuuzetsu> replace and with && ?
13:56:24 <hiptobecubic> radens, what happens if the lhs is false?
13:56:37 <hiptobecubic> assuming this is some kind of weird backwards conditional
13:56:42 <Fuuzetsu> or you could pattern match on tokens@(_:'(':_) = …
13:56:58 <radens> Fuuzetsu: that fixed it. Thanks
13:57:28 <Fuuzetsu> _:"(":_ rather
13:58:39 <mniip> sad smileys
13:59:22 <monochrom> that is totally a half-empty half-full cup :)
13:59:31 <hiptobecubic> mniip, tilt your head the other way
13:59:58 <Fuuzetsu> one man's sadness is another's happiness
14:03:47 <drewbert> It's a butt hanging over a ledge.
14:09:50 * hackagebot polymap 0.1.1.0 - Polygonal maps  https://hackage.haskell.org/package/polymap-0.1.1.0 (Shockk)
14:10:29 <mniip> (Show a, Show (s a), Show (PolyMap as)) => Show (PolyMap ((:) ((,) * (* -> *)) ((,) * (* -> *) a s) as))
14:10:32 * mniip pets haddock
14:11:04 <Fuuzetsu> are you complaining about the extra *
14:11:09 <Fuuzetsu> because patches welcome ;P
14:12:48 <jkaye> If anyone is feeling bored and would like to do a code review of my first piece of Haskell code I would really appreciate it: http://pastebin.com/MvrEVAJh
14:13:01 <jkaye> It's just a basic brainfuck interpreter
14:18:47 <hiptobecubic> You're using RWS, but none of the functions that operate on the state are monadic so you're having to pass around the state manually anyway
14:20:15 <jkaye> Hmm. I do see what you mean. I was wondering if I was using the State piece correctly
14:20:19 <jkaye> Is there a way for me to fix that?
14:21:50 <jophish_>  Sindriava, ah! I guess it depends on where you go to university then. My Computer Science course was pretty much an alternative Maths course with one programming assignment a term
14:23:01 <Sindriava> jophish_: Ooh. We straight up started with "Here's how to make an if. That's a for. This is a pointer. Now make your own fucking database using C and it better be flawless fuckers, because the system of tests we'll put it through will make your nails shed"
14:23:46 <Sindriava> jophish_: If you leak *any* memory, you get 70% off and if you segfault on any of the weird edge cases, you get 0
14:23:56 <jophish_> I think our first lecture was "This is the definition of a set"
14:23:57 <Sindriava> Oh and it doesn't tell you what went wrong, so you have to guess :D
14:24:05 <jophish_> Sindriava: did you get the test suite beforehand?
14:24:14 <jophish_> also, C, that's a little cruel
14:24:16 <Sindriava> jophish_: You get a set of testing data
14:24:16 <cmccann> dmwit_: ping
14:24:22 <Sindriava> jophish_: which is *nowhere* near complete
14:24:54 <Sindriava> jophish_: it's around 5% (if not less) of the data you're going to see, and it's all neat. The random tests fill your input with thousands of random bytes etc.
14:24:57 <hiptobecubic> jkaye, try writing a function like `updateValue :: Int -> RWS String String BfState ()` and having *that* function ask for, modify, and put back the state itself.
14:25:10 <Sindriava> jophish_: Color me jealous, that mathy thing seems a bit more fun to me
14:26:09 <KaneTW> jophish_: you got zernelo-fraenkel in your first lecture? nice.
14:26:35 <Shockk>     * | mniip pets haddock    
14:26:36 <Shockk> haha
14:28:07 <jophish_> It wasn't all great. We had to do a stack of boring calculus too. Most CS students spent the whole lecture thinking "A computer could do this much easier than I ever could"
14:29:48 <jkaye> hiptobecubic: So maybe a couple of functions, one for updating the pointer location and another for updating the values in the registers?
14:29:50 <hiptobecubic> jophish_, someone has to implement that.
14:29:52 <jophish_> KaneTW: I'm sure the lecturer stuck that in somewhere :)
14:30:12 <jkaye> Then these functions would just be called from within the executeBf function instead of where I'm manually doing get/put?
14:30:38 <jophish_> hiptobecubic: oh, for sure. But hopefully not everyone in that lecture hall :)
14:30:47 <hiptobecubic> jkaye, you would want a funtion for each operation you care about, yes. I could point you to my own toy, likely bad, BF interepreter but there are plenty online if you're interested in spoilers, which it seems like you aren't.
14:31:30 <jkaye> hiptobecubic: The whole thing is a learning exercise, so I'd like to figure it out :) I'll give it a shot and come back later
14:31:59 <hiptobecubic> jophish_, sure, but the idea is that any of you *should* be able to. Not that there's a magic student who happens to be good enough at arithmancy to build a TI-89 for everyone else :)
14:32:15 <hiptobecubic> At least, that's what I kept telling myself when I had to do really long-winded, tedious things :)
14:41:57 * hackagebot hgrev 0.1.0.0 - Template Haskell splices for including the current Mercurial revision info in code.  https://hackage.haskell.org/package/hgrev-0.1.0.0 (LukeHoersten)
14:48:45 <texasmynsted> Anybody have suggestions for papers, or other resources that might be useful to reference when giving a presentation about the usefulness of type safety?
14:52:10 <hiptobecubic> texasmynsted, you could try grep 'NullPointerException' /var/log/tomcat/*
14:52:46 * hiptobecubic is only kind of joking
14:52:59 <jkaye> hiptobecubic: If you're around, how does this look? http://pastebin.com/8AcDhmxZ
14:53:23 <texasmynsted> That is not my goal.  My goal was to provide links to useful resources created by professionals or academics.
14:53:46 <hiptobecubic> jkaye, much sexier
14:55:07 <hiptobecubic> jkaye, there are 'modify' functions for when you are just doing `get` followed by `put (f x)`
14:55:28 <hiptobecubic> At least usually, I haven't actually used RWS for anything
14:57:30 <srhb> :t modify
14:57:31 <lambdabot> MonadState s m => (s -> s) -> m ()
14:57:34 <srhb> So yes. :)
14:57:46 <jkaye> Let's give it a shot!
14:59:28 <hiptobecubic> I implemented memory as a zipper when I did this at first. It was really nice but terribly slow. 
15:00:40 <mniip> well... there we go
15:00:55 <mniip> I don't think I can optimize things like this in P time: (B && not A || B && A)
15:01:30 <xolrup> why not just B ?
15:02:08 <hiptobecubic> xolrup, discovering that transformation is the problem at hand.
15:02:27 <jkaye> That is much nicer! http://pastebin.com/29A7nu8c
15:02:40 <xolrup> Oh, right
15:02:48 <mniip> more generally, consider
15:02:51 <mniip> data Expr = T | F | V String | Not Expr | Xor [Expr] | And [Expr] | Or [Expr]
15:03:19 <mniip> I've just written 150 lines of heuristics for this
15:03:34 <jkaye> hiptobecubic: Thanks for taking a look
15:04:19 <hiptobecubic> jkaye, sure. Much nicer than doing real work.
15:05:15 <hiptobecubic> jkaye, other people probably have more educated opinions about this, but I think "new*" is rarely used in the way you are here. I'd call it "emptyBfState" instead. I've only seen 'new' used for mutable things like `newIORef`
15:05:46 <jkaye> hiptobecubic: Hmm, okay. That makes sense
15:05:50 <hiptobecubic> Hmm. Couldn't seem to decide on a style of quotes there.
15:05:52 <jkaye> Can you tell I am used to OO :)
15:06:37 * hiptobecubic is writing python as we speak
15:07:47 <hiptobecubic> jkaye, anyway. Now you're at the fun part. You can come up with interesting ways to optimize your AST and implement them
15:08:18 <texasmynsted> somebody have me this link in another channel http://arxiv.org/pdf/1409.0252.pdf
15:08:20 <hiptobecubic> So that things like "+++++" and "[-]" can be done efficiently.
15:08:21 <jkaye> hiptobecubic: I would think the first thing would be trying to model the registers as something other than Map Int Int
15:08:49 <texasmynsted> I guess if I want to create reliable, correct, software I should be using Go?  
15:09:04 <hiptobecubic> jkaye, you could I suppose. Although I don't see anything wrong with it.
15:09:06 <Fuuzetsu> texasmynsted: see, now I have to open it
15:09:12 <hiptobecubic> Fuuzetsu, :D
15:09:13 <Fuuzetsu> you should feel awful
15:09:24 <monochrom> texasmynsted: if the paper turns out to be off-topic, I will ban you.
15:09:36 <jkaye> hiptobecubic: Why would the existing AST make that inefficient? (Performance in Haskell is not really something I've considered up to this pint)
15:09:40 <jkaye> point*
15:09:41 <texasmynsted> ban me?
15:09:58 <Fuuzetsu> it says Haskell in abstract so it's on-topic ;^)
15:10:14 <srhb> texasmynsted: I don't think gaming the channel is bannable as a first-time infraction :-)
15:10:18 <texasmynsted> I am trying to find resources to support my interest in Haskell and other statically typed, functional languages.
15:12:12 <srhb> What does "support" mean?
15:12:14 <hiptobecubic> I don't think texasmynsted has done anything bannable at all. Whatever happened to '#haskell is too helpful to troll' ?
15:12:25 <srhb> I was joking. Sorry if that was not clear.
15:12:32 <monochrom> ok, then you should have said that at the beginning, rather than "someone else made me tell you about this paper" at the beginning.
15:12:34 <srhb> I don't think it was anywhere near anything bannable. :-)
15:12:35 <Fuuzetsu> I actually don't know of anyone who contributes to Rosetta Code, all that stuff seems to come from thin air
15:13:00 <Fuuzetsu> monochrom: you should have read up a bit, he was looking for similar resource already
15:13:04 <hiptobecubic> monochrom, he asked about this a half hour ago and no one gave him anything useful.
15:13:33 <hiptobecubic> I gave him something not-useful, as I often do. But that's neither here nor there :D
15:13:45 <texasmynsted> I have serious questions about the science in the paper, but so far it is the only resource I have.
15:14:24 <bitemyapp> texasmynsted: that's not a serious study
15:15:16 <Fuuzetsu> 22 Jan 2015 and they are using GHC 7.4.1 ;)
15:15:54 <hiptobecubic> Who cares about these benchmarks anyway? Ram usage? Runtime? Likelihood of failure? Where are the statistics about street cred and respect from one's peers?
15:19:44 <hiptobecubic> I don't understand how so many examples apparently didn't even compile
15:19:53 * hackagebot regex-genex 0.7.0 - From a regex, generate all possible strings it can match  https://hackage.haskell.org/package/regex-genex-0.7.0 (AudreyTang)
15:22:35 <tommd> texasmynsted: The implication that their program database is representative is a pretty big pill to swallow.
15:32:00 <jacereda> hmmm... why is "getCurrentDirectory" different from "getCurrentDirectory >>= canonicalizePath"? I get c:\foo vs C:\foo...
15:33:16 <monochrom> hrm, then it canonicalizes a drive letter to an uppercase letter
15:34:03 <monochrom> ok, maybe you ask, why doesn't getCurrentDirectory canonicalize? then I don't know
15:34:20 <shachaf> I think OS/2 required uppercase drive letters.
15:34:24 <jacereda> That's making "cwd" in http://hackage.haskell.org/package/shake-0.15.1/src/src/Test/Command.hs fail in my case
15:34:33 <shachaf> So try running getCurrentDirectory on OS/2 and then report a bug if it fails.
15:35:49 <hiptobecubic> texasmynsted, I an important point that tommd is getting at is that Go will be great in the domain it was designed for, but you can't extrapolate that to all kinds of programs. For example, writing a network service in Go is not at all the same as writing a compiler or a drawing API, etc.
15:35:59 <hiptobecubic> Well, "great"
15:38:22 <jacereda> does haskell try to isolate the user from OS stupidity or is that left as an exercise? If the former, changing getCurrentDirectory to uppercase drive names might be a good thing...
15:40:05 <texasmynsted> I agree.  I do not place much value in that paper.  I would like to find useful sources
15:41:18 <texasmynsted> My experience has shown me that type safety results in more expressive, more contained and maintainable code.  
15:41:38 <texasmynsted> I am not a haskell expert.  I am still learning.
15:41:59 <hiptobecubic> c:\ isn't wrong though, is it? Windows paths are case insensitive I think.
15:42:45 <hiptobecubic> And if you haven't canonicized a path, then it doesn't have to be in canonical form, although I can't think of a good reason not to for a function like getCurrentDirectory
15:43:22 <jacereda> hiptobecubic: I think it depends on the underlying filesystem and on registry settings
15:43:41 <texasmynsted> bitemyapp:  I have not looked through your book yet for links to papers, but I suspect there may be some there.  (I am trying to take it a page at a time, and have not made time to read much of it lately)
15:43:43 <hiptobecubic> jacereda, oh, sure. But windows only officially supports case insensitive paths i think
15:44:00 <hiptobecubic> err, filesystems which only support case insensitive paths
15:45:00 <jacereda> ok, I guess getSaneCurrentDirectory is defined easily enough :-)
15:45:07 <texasmynsted> I guess I can check in "papers we love", I just thought there might be somebody here that might have different ideas.
15:45:29 <texasmynsted> bitemyapp: fwiw, I have really enjoyed your book so far.
15:46:59 <jacereda> started compiling ghc right now with BuildFlavor=quick, is it really quick or should I go to bed?
15:51:21 <Jacoby6000> Does anybody know of some papers that show that typesafe languages are more advantageous than unityped languages in practice? I've got a CS paper i have to write and was hoping you guys knew of some resources
15:59:55 * hackagebot VKHS 0.5.5 - Provides access to Vkontakte social network via public API  https://hackage.haskell.org/package/VKHS-0.5.5 (SergeyMironov)
16:10:26 <hiptobecubic> hah
16:14:56 * hackagebot these 0.6.1.0 - An either-or-both data type & a generalized 'zip with padding' typeclass  https://hackage.haskell.org/package/these-0.6.1.0 (cmccann)
17:21:40 <johnw> Jacoby6000: if you hunt around Google Scholar and the Net, you should a fair bit of research on that question
17:39:47 <pilne> to whomever pointed me to the "stack" implementation of haskell, where would you like me to ship my hypothetical first-born? 
17:44:59 * hackagebot casadi-bindings-internal 0.1.3.1 - low level bindings to CasADi  https://hackage.haskell.org/package/casadi-bindings-internal-0.1.3.1 (GregHorn)
17:45:01 * hackagebot casadi-bindings-core 2.4.1.0 - autogenerated low level bindings to casadi  https://hackage.haskell.org/package/casadi-bindings-core-2.4.1.0 (GregHorn)
17:45:13 <johnw> pilne: you can send him to Scylla, Greek Isles, SEA MAIL
17:46:00 <pilne> hrm.... i wonder if i can get a discount.... i'm a zergling in the corporate empire that is UPS
17:47:27 <hamilto-nyan> Is there any way to say «import all prefix symbols qualified, but all infix symbols unqualified»?
17:48:02 <pikajude> not unless you mean manually
17:48:11 <hamilto-nyan> Mmm...
17:48:28 <pikajude> there is no way to automatically do what you want, not even with template haskell, which cannot form import statements
17:49:01 <johnw> pikajude: well, there are always ways
17:49:20 <pikajude> of course. you could patch the compiler
17:49:31 <slack1256> import qualified Control.Applicative as X -- everything qualified
17:49:31 <pikajude> now, if patching GHC counts as automatic, count me in!
17:49:37 <johnw> pikajude: you could write a program formatter that uses GHC API to determine the import list, write it to a temporary module, and then compile that for its exports
17:49:47 <slack1256> import Control.Applicative (mine , alsomine) -- unqualified
17:49:51 <slack1256> bot as different imports?
17:49:57 <pikajude> johnw: hardly automatic
17:50:00 * hackagebot casadi-bindings 2.4.1.0 - mid-level bindings to CasADi  https://hackage.haskell.org/package/casadi-bindings-2.4.1.0 (GregHorn)
17:50:01 <johnw> in terms of "build time magic", there's literally nothing you can't do
17:50:11 <johnw> well, it's automatic for anyone doing "cabal build", just not the person setting it up
17:50:24 <pikajude> something something use nix something something
17:50:39 <pikajude> oh, that reminds me, since i'm waiting for my coworker to do a code review that is now over one hour late, i'll try to build xquartz again
17:50:47 <johnw> cool
17:50:52 <johnw> we'll talk in ##nix-darwin
18:04:18 <Guest14434> zjebane te czaty
18:04:52 <hamilto-nyan> With unboxed arrays, it's possible to recursively define some elements in terms of others. Is the same thing possible with maps?
18:04:57 <hamilto-nyan> (As in Data.Map.Map)
18:05:39 <pikajude> how do you mean?
18:07:00 <majorseitan> hi does anyone have a few minutes to test a theorem prover for me?
18:08:39 <hamilto-nyan> pikajude: I'm making an implementation of first-order unification where, instead of actually substituting variables as soon as they're solved, I'm just building a map from unification variable IDs to expressions.
18:09:21 <johnw> hamilto-nyan: sounds like it could be a job for loeb...
18:09:48 <hamilto-nyan> johnw: Who/what's that? :-O
18:10:06 <johnw> loeb :: Functor f => f (f a -> a) -> f a
18:10:30 <johnw> it ties the knot to turn a structure of evaluators into a structure of evaluations dependent on other results within the structure
18:10:44 <hamilto-nyan> Mmm...
18:10:48 <hamilto-nyan> Let me think about that.
18:11:28 <lamefun> Is there a reference counting library for Haskell?
18:11:51 <jmcarthur> lamefun: what are you wanting it to do for you?
18:12:19 <johnw> hamilto-nyan: https://github.com/quchen/articles/blob/master/loeb-moeb.md
18:12:26 <hamilto-nyan> johnw: Checking, thanks.
18:13:04 <lamefun> jmcarthur, I mean, just like C++ std::shared_ptr.
18:13:34 <jmcarthur> lamefun: but we have a garbage collector, so i don't know what you are really after
18:15:01 * hackagebot dynobud 1.8.0.0 - your dynamic optimization buddy  https://hackage.haskell.org/package/dynobud-1.8.0.0 (GregHorn)
18:16:17 <Shockk> I wonder if lamefun wants something whose memory is explicitly deallocated when there are no more references, as opposed to being garbage collected and deallocated at some point
18:17:07 <hamilto-nyan> johnw: So I have `type Var = Int` and `type Subst = Map Var Expr`. What would `f` and `a` be? `f ~ (->) Var` and `a ~ Expr`?
18:17:16 <lamefun> Not memory, files, etc. like std::shared_ptr<std::fstream>
18:17:20 <jmcarthur> Shockk: i kind of suspect that may be, too, but i don't want to assume
18:17:53 <johnw> from your decription, I had thought f would be Map Var
18:17:56 <exio4> there's ResourceT for stuff like that... I think? 
18:18:01 <jmcarthur> lamefun: ah! well, there are some thing to do. one is reference counting, but that's error prone, because you have to remember to bump it up or down.
18:18:12 <jmcarthur> lamefun: ResourceT is a fine way to go, as suggested by exio4 
18:18:13 <johnw> it's possible it doesn't relate
18:18:26 <johnw> just your description sounded awfully familiar
18:18:27 <jmcarthur> lamefun: there are also super fancy things like monadic regions, but... you probably shouldn't bother with that
18:18:30 <hamilto-nyan> johnw: No... I have the suspicious that this combinator actually can help.
18:18:36 <hamilto-nyan> suspicion*
18:18:59 * cmccann contemplates a script to automatically build up-to-date haddocks from the git repo and push the haddock HTML to github pages
18:19:00 <jmcarthur> lamefun: https://hackage.haskell.org/package/resourcet
18:19:36 <jmcarthur> there's also just plain and simple bracket
18:19:37 <jmcarthur> :t bracket
18:19:39 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
18:19:53 <jmcarthur> not always powerful enough, but often fine
18:20:52 <johnw> in a lot of ways, ResourceT is a bracket you can add/remove resource management to/from while inside it
18:21:18 <Shockk> interesting, I need to look into that
18:21:47 <johnw> SafeT is another implementation of the same idea, and plays better with pipes if you use that library
18:21:48 <cmccann> hm, http://hackage.haskell.org/package/standalone-haddock is nice
18:23:41 <Welkin> is it safe to use stack when the rest of my system uses cabal?
18:23:48 <Welkin> e.g. outside of a cabal sandbox
18:23:57 <mgsloan> Yes
18:24:03 <Welkin> I don't want to screw up my cabal setup
18:24:20 <mgsloan> It's completely independent of your cabal setup and existing ghc install
18:24:26 <Welkin> I see
18:24:34 <mgsloan> (though, if you have a global install of ghc, then it will reuse that, but not modify it)
18:24:42 <cmccann> Welkin: I hear that putting them within three meters of each other can cause a chain reaction releasing several times the recommended maximum dose of reddit comments
18:24:44 <Welkin> so, `stack install <package>` will install the package globally?
18:24:50 <mgsloan> (which means if your global ghc's package DB is screwed up, it will break stack)
18:24:58 <Welkin> or is it only for the current directory/project based on the stack.taml file?
18:25:03 <johnw> cmccann: lol
18:25:22 <Welkin> yaml*
18:25:58 <Welkin> also, this is strange
18:26:06 <mgsloan> "stack install <package>" will build using the stack.yaml in the current project (otherwise, .stack/global/stack.yaml) , and put the binaries in ~/.local/bin
18:26:14 <Welkin> in the new yesod quickstart it says to use `stack install yesod-bin cabal-install`
18:26:35 <mgsloan> That's because yesod-bin uses the cabal executable
18:26:41 <Welkin> I see
18:27:17 <Welkin> and if I provided --install-ghc?
18:27:39 <Welkin> I have 7.8.4 on my path and 7.10.2 hidden
18:27:41 <johnw> stack install cabal-install; cabal install stack.  The Quickening.
18:28:21 <mgsloan> Welkin: Then it will install ghc to ~/.stack/programs/...
18:29:01 <mgsloan> Alternatively just run "stack setup" to do the install
18:30:15 <mgsloan> "--install-ghc" is mostly intended for build scripts, or the case where you are using stack in the shebang of a executable Haskell script (and so your haskell script only depends on stack and nothing else) 
18:33:50 <Peach1> Hi!
18:33:58 <Peach1> Is there an IRC haskell bot here?
18:34:09 <Peach1> Like an interpreter ?
18:34:29 <Pamelloes> > "yes"
18:34:31 <lambdabot>  "yes"
18:34:49 <Peach1> > fold [1,2,3,4,5] (+)
18:34:51 <lambdabot>      Could not deduce (Num a0)
18:34:51 <lambdabot>      from the context (Num a, Num ((a -> a -> a) -> t), Monoid t)
18:34:51 <lambdabot>        bound by the inferred type for ‘e_112345’:
18:35:22 <Shockk> this is a weird question, but I'm wondering if there's some monad that allocates memory in blocks or something, for any objects created by code running in it
18:35:29 <Pamelloes> Peach1: You should PM lambdabot unless your code is relevant to what's being discussed :)
18:36:31 <jmcarthur> Shockk: not literally continiguous memory blocks, if that's what you mean
18:37:01 <jmcarthur> Shockk: monadic regions are a way to group resources together in a safe way though
18:37:16 <Peach1> Pamelloes: I was hoping this channel would be a place where others would help in learning Haskell by example
18:37:29 <Shockk> I'm not sure exactly what I mean or what I'm asking
18:37:30 <Shockk> lol
18:37:54 <Welkin> Peach1: this is
18:37:59 <hamilto-nyan> > fold $ map Sum [1..5] // Peach1 ?
18:38:00 <lambdabot>  <hint>:1:34:
18:38:00 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
18:38:11 <hamilto-nyan> > fold $ map Sum [1..5] -- Peach1 ?
18:38:13 <lambdabot>  Sum {getSum = 15}
18:38:15 <jmcarthur> Peach1: it is within the limits of what is bearable for a channel with 1485 people
18:38:50 <jmcarthur> Peach1: but since your question was just whether there was an irc bot, the warning not to flood the channel with experiments was, i think, relevant.
18:39:45 <jmcarthur> Peach1: if you have a haskell question, feel free to use lambdabot to demonstrate something. when answering, we sometimes use lambdabot too. the constraint is that in here, lambdabot should just be used as a communication tool.
18:40:02 * hackagebot coverage 0.1.0.3 - Exhaustivity Checking Library  https://hackage.haskell.org/package/coverage-0.1.0.3 (NicolasDelPiano)
18:40:22 <Peach1> Ok, how can I do a simple fold?  >  fold (+) [1,2,3,4,5]       is not working
18:40:50 <jmcarthur> i see a couple issues with that expression. first, i think that's not the fold you mean to use
18:40:51 <jmcarthur> :t fold
18:40:53 <lambdabot> (Foldable t, Monoid m) => t m -> m
18:40:53 <Shockk> Relevant c => LambdaBot (Channel c)
18:41:02 <geekosaur> Peach1, you can open a /query to lambdabot for yourself, or if you are doing things in a group you might try #haskell-overflow
18:41:04 <jmcarthur> :t foldl'  -- you probably want to use this
18:41:05 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
18:41:37 <geekosaur> if it's something you expect to do regularly, perhaps get your own channel and ask int-e to have the bot join it
18:41:43 <jmcarthur> the other issue is kind of affected by what fold function you are using, but at least if you are using foldl', you will need to also supply an initial value for the accumulator
18:42:08 <jmcarthur> so here is a correct fold:
18:42:09 <geekosaur> this channel is large and fairly busy; not the best place for demonstrations or teaching sessions
18:42:17 <jmcarthur> > foldl' (+) 0 [1,2,3,4,5]
18:42:18 <lambdabot>  15
18:42:32 <Shockk> #haskell-beginners may be a good place for that right? (or am I wrong?)
18:42:34 <jmcarthur> geekosaur: i think it's fine for teaching sessions unless there's a lot going on
18:42:51 <Lokathor> In C++, Java, python, etc you can dynamically load a module and use it, which allows you to *unload* a module as well, load a new verseion (with matching function headers) and then load it back in and keep going.
18:42:53 <geekosaur> well, yes, the problem is guessing when a lot will be going on >.>
18:43:06 <Lokathor> I'm assuming that Haskell has some sort of feature like this? What should I look up?
18:43:07 <geekosaur> (or won't be)
18:43:29 <Pamelloes> Where's the function fold located?
18:43:42 <gganley> :t fold 
18:43:42 <geekosaur> Lokathor, ghc-api can do it, hint and mueval are more usable interfaces to the functionality (with different use cases)
18:43:43 <lambdabot> (Foldable t, Monoid m) => t m -> m
18:43:46 <jmcarthur> Pamelloes: Data.Foldable (maybe in the Prelude since ghc 7.10 though?)
18:43:51 <gganley> i think thats in Data.Foldable
18:44:09 <Pamelloes> jmcarthur: Not in Prelude as of GHC 7.10.2 :)
18:44:15 <jmcarthur> nope, not in prelude
18:44:16 <geekosaur> Lokathor, or plugins
18:44:30 <jmcarthur> Pamelloes: welp, Data.Foldable it is then
18:44:50 <Lokathor> geekosaur, I don't have a specific use case at the moment, just trying to feel out what's possible I suppose
18:44:58 <cmccann> Lokathor: fwiw mueval is what lambdabot uses and IIRC hint basically works like GHCi
18:45:07 <Pamelloes> Ah! fold is the Monoid one :) I always forget about it.
18:45:13 <cmccann> also doesn't xmonad have something weird it does?
18:45:30 <slack1256> xmonad recompiles and exec the new binary
18:45:34 <geekosaur> right, and plugins is more akin to dlsym() in C but with Haskell types
18:45:47 <slack1256> admitelly a hack, but a working one
18:45:50 <cmccann> slack1256: ah well that's one way to do it I guess
18:46:24 <slack1256> :-)
18:46:34 <slack1256> I guess this is called hot-swapping right?
18:46:42 <Lokathor> yeah that's the idea
18:46:44 <Shockk> bear in mind plugins does have problems I think when one of the things you want to dynamically load is linked with something that's also linked into the main object
18:46:47 <slack1256> like what the erlang guys do?
18:47:05 <Shockk> I had issues with that when I was using it a year or so ago
18:47:07 <slack1256> I guess the cloud haskell could have need something like this, they probably have some info on their documentation
18:47:24 <Lokathor> eg: you have some module with, updateGameState :: GameState -> GameInput -> TimeDelta -> GameState
18:47:25 <Shockk> I decided to use the GHC API instead
18:47:28 <Lokathor> and you want to load a new version
18:47:53 <geekosaur> Shockk, the same issues dlsym() has with the additional complexities of a more complex runtime system, sure
18:48:00 <Shockk> geekosaur: yep
18:49:17 <slack1256> wait, can hot-swapping be implemented on top of a good IPC mechanism like unix sockets?
18:49:31 <geekosaur> there are systems that can do "true" hotswapping; erlang is one of them, and doing it as transparently as erlang does depends on specific features of the BEAM VM
18:50:06 <lolisa> Hi, I have a "Maybe (Either nat bool)" and a "bool->bool", how do I apply the former to the latter? Do I just do "pure" twice?
18:50:33 <geekosaur> you can get maybe 90% (less for more complex runtimes) without such support, but that last part is nearly impossible to get right without it
18:50:57 <slack1256> > fmap (fmap (+1)) (Just (Right 5))
18:50:58 <lambdabot>  Just (Right 6)
18:51:11 <slack1256> lolisa: you probably discovered lenses :-)
18:51:34 <geekosaur> ...note that it also needs ecosystem support; mnesia is there to handle the aspects of copying data between instances that may not be 100% compatible, for example
18:51:47 <lolisa> Oh god, you're right, maybe what I need is lenses...
18:51:56 <geekosaur> cloud haskell is definitely working on that aspect
18:52:20 <lolisa> slack1256, thx
18:52:44 <slack1256> lolisa: there is a explanation of lenses from edk which shows things like (fmap . fmap) and (traverse . traverse). Your use case probably can get away with them
18:52:59 <slack1256> no need to bring more stuff (and pain) to the table
18:53:12 <Welkin> lolisa: you are blind, take these: .~ %~ .^ %=
18:53:41 <slack1256> @info Compose
18:53:41 <lambdabot> Compose
18:54:01 <geekosaur> no @info
18:54:06 <Fay> lol
18:54:08 <geekosaur> (you got @undo)
18:54:12 <slack1256> > fmap (+1) (Compose (Right (Just 8)))
18:54:16 <lambdabot>      Not in scope: data constructor ‘Compose’
18:54:17 <lambdabot>      Perhaps you meant variable ‘icompose’ (imported from Control.Lens)
18:54:24 * geekosaur sometimes wishes edit correction would say what it corrected to...
18:54:25 <Welkin> @lwwt lol
18:54:25 <lambdabot> Maybe you meant: list let leet l33t
18:54:28 <cmccann> ...ok, the "magic number" used in GHC .hi files is hilarious
18:54:33 <Welkin> @seen lol
18:54:33 <lambdabot> 1o1
18:54:36 <Shockk> :tpye 5
18:54:43 <Shockk> er..
18:54:44 <geekosaur> those don't edit correct
18:54:46 <Shockk> @tpye 5
18:54:47 <lambdabot> Maybe you meant: type time
18:54:51 <Welkin> haha
18:54:53 <Shockk> ah interesting
18:54:56 <gganley> :t 5
18:54:57 <lambdabot> Num a => a
18:55:00 <slack1256> oh well, it doesn't matter :-)
18:55:15 <gganley> @l33t
18:55:15 <lambdabot> Say again?
18:55:17 <geekosaur> bot commands with ? or @ edit correct; the :-commands are more like input triggers and don't have any edit correction
18:55:21 <slack1256> the thing was you can omit a inner fmap if you wrap in the Compose newtype thing
18:55:29 <slack1256> as the composition of functors is a functor
18:55:30 <gganley> @?
18:56:02 <lolisa> Welking, what is %= ? Hoogle doesnt give me anything...
18:56:13 <Welkin> lolisa: lens isn't in hoogle
18:56:17 <gganley> :t (%=)
18:56:19 <lambdabot> (Profunctor p, MonadState s m) => Setting p s s a b -> p a b -> m ()
18:56:19 <Welkin> hoogle only covers the base libraries
18:56:26 <geekosaur> fpcomplete's might
18:56:29 <gganley> @where lens 
18:56:30 <lambdabot> #haskell-lens | http://lens.github.io/ | https://github.com/ekmett/lens | http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
18:56:30 <Welkin> using hayoo to search non-base
18:56:34 <lolisa> Welking, thx
18:56:35 <pikajude> hayoo will
18:56:36 <cmccann> Welkin: what, isn't lens in base yet
18:56:46 <Welkin> http://hayoo.fh-wedel.de/?query=%28%25%3D%29
18:56:52 <gganley> lolisa: lens.github.io is quite good
18:56:54 <slack1256> no, but base is in lens 
18:57:01 <geekosaur> I think ekmett wants to be able to change it without a ghc update :)
18:57:32 <glguy> You can search lens in hoogle, you just add "+lens"
18:57:36 <cmccann> geekosaur: alternatively, I think nobody else wants GHC on an ekmett update schedule
18:57:42 <geekosaur> heh
18:58:07 <geekosaur> (otoh if you're using stack you may not care >.> )
18:58:15 <gganley> does edward sleep... or drink... 
18:58:22 <johnw> if lens were in base, and wanted to name a new operator, the bike shedding would be epic
18:58:59 <johnw> although, maybe because it wouldn't be in the Prelude wouldn't be so bad
18:59:04 <slack1256> I would like people started using over, view more in lens
18:59:08 <slack1256> instead of the operators
18:59:22 <pikajude> i would like the classy-prelude prelude
18:59:52 <cmccann> johnw: on the bright side, it would make that old lambdabot quote of mine about lens operators much closer to truth
18:59:56 <cmccann> @quote none.left
18:59:56 <lambdabot> cmccann says: for instance, some people don't like how much haskell uses operators. lens solves this by using all of them itself and leaving none left.
19:00:04 <johnw> pikajude: but nothing is stopping you from using it
19:00:13 <pikajude> johnw: in base
19:00:24 <Shockk> cmccann: hahah
19:00:37 <glguy> pikajude: There's not much risk of that happening
19:00:43 <johnw> pikajude: I wouldn't want that at all
19:00:46 <Welkin> how does stack manage conflicting packages?
19:00:49 <pikajude> well there you go
19:00:57 <Welkin> I know there is some kind of global package cache
19:01:02 <Welkin> does it also have a local package cache?
19:01:02 <lolisa> BTW, I think I got something wrong, since lense is isomorphic to set and get, if we have a lense of option T to T, doesnt it mean that we can get T from option T?
19:01:07 <slack1256> delegates the problem to stackage?
19:01:23 <Welkin> slack1256: not what I meant
19:01:28 <geekosaur> stack has the same conflicting package issues that ghc does
19:01:32 <glguy> lolisa: You can't make a lens for Option T
19:01:40 <geekosaur> (obviously)
19:02:08 <geekosaur> basically some conflicts will get you type errors, some will get you link time errors
19:02:53 <lolisa> So how come lense can help me when all my data is in an option T... I am a bit lost...
19:03:43 <johnw> prisms work great on Option T
19:03:45 <Welkin> oh boy
19:03:48 <Welkin> here is a fun one
19:03:49 <Welkin> cabal: 'require-sandbox' is set to True, but no sandbox is present. Use
19:03:50 <Welkin> '--no-require-sandbox' if you want to override 'require-sandbox' temporarily.
19:04:08 <Welkin> it won't stop printing this message every 2 seconds
19:04:28 <lolisa> Oh I get it, thx
19:04:29 <Welkin> I have require-sandbox on for a reason though... so what's up with this?
19:04:47 <geekosaur> what were you doing?
19:05:00 <Welkin> geekosaur: stack exec -- yesod devel
19:05:54 <geekosaur> oh. I bet "yesod devel" uses cabal-install still, and of course wouldn't know that stack is providing the sandbox...
19:06:11 <Welkin> how can I solve this without messing with my cabal setup?
19:06:18 <mgsloan> geekosaur: recent yesod devel hacks on support for this
19:06:33 <mgsloan> By doing what cabal should always have been doing, and turning GHC_PACKAGE_PATH into --package-db args
19:06:44 <geekosaur> Welkin, ^^
19:06:49 <Welkin> what do you mean?
19:07:17 <geekosaur> otherwise I'd consider dropping a shell script wrapper for cabal in the local bin directory that adds --no-require-sandbox to its parameters and runs the real one
19:07:47 <mgsloan> Welkin: yesod-bin > 1.4.11 supports stack
19:07:57 <geekosaur> mgsloan, I vaguely recall there are old ghc versions that don't quite do the right thing with --package-db?
19:08:02 <Welkin> mgsloan: I just used stack to install a new yesod-bin
19:08:22 <geekosaur> cabal-install may still be catering to stuff that should preferably be buried >.>
19:08:28 <Welkin> 1.4.14
19:08:30 <mgsloan> geekosaur: Perhaps so!  Stack only directly supports >= GHC 7.8
19:08:47 <mgsloan> indeed
19:08:55 <hellertime> I attempted to implement the thread wait functions in the Control.Concurrent docs: http://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Concurrent.html#g:12
19:09:17 <mgsloan> Welkin: So, yeah, `stack exec -- yesod devel` should do it.  Does it not work?
19:09:26 <geekosaur> right, that's already a problem --- I'm on Mint (~ Ubuntu ~ Debian so ghc 7.6)
19:09:29 <hellertime> but I just end up with an indefinitly blocked exception...
19:09:42 <geekosaur> am working toward switching to hvr's ppa, have completed one machine but not the other yet
19:09:56 <Welkin> mgsloan: nope
19:10:20 <geekosaur> (mostly because of that moment of sheer terror where I switch ghc-s out from under xmonad and hope I didn't miss something >.> )
19:10:35 <mgsloan> Welkin: What does "stack exec -- yesod --version" say?
19:11:06 <geekosaur> also I really need to find time to work stack/cabal-install/sandbox support into xmonad at some point
19:11:33 <Welkin> Invalid option `--version'
19:11:49 <Welkin> I do have yesod-bin on my path already (for my older yesod projects)
19:11:51 <geekosaur> which may get "interesting" as I'm likely to need some fun hackery to enable the precompiled one to find out what the new one wants to do
19:11:53 <Welkin> I wonder if this matters
19:13:50 <Shockk> is there anything like records at the type level, in place of something potentially like this:
19:13:53 <lpaste> Shockk pasted “T.hs” at http://lpaste.net/141641
19:14:29 <Shockk> along with the matching lines that would have to go with such a type when using it for a typeclass instance
19:15:24 <Welkin> mgsloan: any thoughts?
19:15:34 <Shockk> for example being able to create an instance for, say, T a b c d e 'LogLevelHigh g h
19:16:03 <Shockk> perhaps shortened to something like T {f = 'LogLevelHigh }
19:21:37 <Welkin> mgsloan: are you still around?
19:22:07 <Shockk> that might sound like an odd question, but I'm wondering if it would be worthwhile encoding options like debug level and such in a type, rather than passing them in value space
19:22:35 <lagrangi-wan> Can I have two `StateT s` layers in a single monad transformer stack?
19:22:46 <lagrangi-wan> (0) For different `s`s? (1) For the same `s`?
19:22:52 <jle`> lagrangi-wan: you can have StateT s1 (StateT s2) a
19:23:01 <jle`> you can do anything as long as the kinds mathc u
19:23:03 <jle`> *State s2
19:23:08 <jle`> :k StateT
19:23:10 <lambdabot> * -> (* -> *) -> * -> *
19:23:16 <deech> Hi all, upgraded to 7.10.2 from 7.8.4 and noticed that compilation of code with lots of overlapping instances is taking quite a bit longer. Has anyone else seen this?
19:23:25 <jle`> so the second argument can be any Monad...and State s2 is a Monad, so it can go there
19:24:08 <Shockk> hmm, how do functions operating in a monad constrained by MonadState, work with two StateTs?
19:24:21 <jle`> look at the instance for StateT :)
19:24:22 <Shockk> like get/put
19:24:54 <Welkin> okay
19:25:03 <Shockk> ahh looks like it it does it on the inner monad
19:25:06 <Welkin> geekosaur: any help?
19:25:31 <Shockk> as far as I can tell
19:25:31 <jle`> i think it's instance Monad m => MonadState s (StateT s) where get = getOnTheOuter; set = setOnTheOuther
19:25:39 <Shockk> oh
19:25:55 <lagrangi-wan> Mmm.
19:26:00 <jle`> here ya go
19:26:02 <jle`> https://hackage.haskell.org/package/mtl-2.2.1/docs/src/Control-Monad-State-Class.html#line-104
19:26:09 <dolio> deech: Other stuff takes longer, too.
19:26:16 <lagrangi-wan> jle`: Checking, thanks.
19:26:42 <geekosaur> Welkin: if you mean the --version thing, I have no idea
19:26:50 <jle`> working with the MonadState instance of nested StateT's might not be the best idea though
19:27:04 <jle`> MonadState isn't really the best tool for handling this I think
19:27:14 <jle`> if you can, use State (s1, s2)
19:27:22 <geekosaur> you end up working directly with one and lift-ing to get the other
19:27:23 <lagrangi-wan> I really can't. :-|
19:27:26 <geekosaur> yuck
19:27:29 <deech>  dolio: Ah, I haven't added the recommended OVERLAPPABLE etc. annotations yet. I was going to in the hopes that would make it compile faster. Maybe I'll hold off then.
19:31:31 <Welkin> geekosaur: no, not that in particular
19:31:45 <Welkin> geekosaur: getting stack to work and stop printing that error
19:33:11 <geekosaur> aside from my original suggestion, can't really help with that either
19:33:44 <geekosaur> [25 02:06] <geekosaur> otherwise I'd consider dropping a shell script wrapper for cabal in stack's local bin directory that adds --no-require-sandbox to its parameters and runs the real one
19:33:54 <geekosaur> (edited with sliught clarification)
19:35:03 <Welkin> great...
19:35:10 <Welkin> stack is supposed to solve problems
19:35:15 <Welkin> but it only created them for me
19:35:42 <bitemyapp> texasmynsted: we try to link follow-up resources at the end of each chapter.
19:35:59 <bitemyapp> texasmynsted: quality and coverage there isn't 100% consistent, but we believe we've captured some good resources. Glad you're enjoying the book :)
19:36:13 <geekosaur> not sure why stack is to blame here
19:36:56 <geekosaur> yesod is using cabal-install, presumably for cbackward compatibility, and cabal-install does not know about stack and therefore does not think it is sandboxed
19:38:02 <Welkin> should I just create a cabal sandbox in the directory then?
19:38:07 <Welkin> would that fix it?
19:38:20 <geekosaur> should shut it up at least
19:39:02 <Welkin> no
19:39:05 <Welkin> it shut it up
19:39:14 <Welkin> but now it is broken in another way
19:39:26 <Welkin> it can't see the packages that stack already installed...
19:39:28 <Welkin> oh boy
19:41:37 <wraithm> :t \p xs -> do { ts <- filterM p xs; fs <- filterM (fmap not . p) xs; return (ts, fs) }
19:41:38 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m ([a], [a])
19:45:04 <mgsloan> Welkin: Back, sorry.  I didn't realize yesod-bin didn't take "--version"
19:46:49 <Welkin> mgsloan: okay
19:46:49 <mgsloan> Welkin: So what's the error?
19:46:55 <Welkin> the same as before
19:47:03 <Welkin> cabal: 'require-sandbox' is set to True, but no sandbox is present. Use
19:47:04 <Welkin> '--no-require-sandbox' if you want to override 'require-sandbox' temporarily.
19:47:46 <glguy> Assuming that "yesod devel" is the thing that tries to build your package over and over again so that you can make changes and see them right away,
19:48:08 <glguy> you probably aren't going to be able to make it work by making a fake sandbox for it to try and build into over and over
19:48:18 <mgsloan> Yeah, sounds like this isn't a stack issue.  I bet it has something to do with your global cabal config
19:48:50 <texasmynsted> :-)
19:48:53 <Welkin> mgsloan: of course
19:49:10 <Welkin> but I don't want to remove the require-sandbox constraints because I set it for a reason
19:49:31 <Welkin> so I don't mess up my global cabal package db by accident
19:50:05 * hackagebot ses-html 0.3.0.1 - Send HTML formatted emails using Amazon's SES REST API with blaze  https://hackage.haskell.org/package/ses-html-0.3.0.1 (DavidJohnson)
19:50:06 <geekosaur> I'm liking my earlier suggestion more and more tbh
19:50:44 <texasmynsted> bitemyapp:  I figured you might since there was something like that at the end of the lambda calculus chaper.
19:50:47 <texasmynsted> chapter
19:52:02 <mgsloan> Welkin: How about modifying yesod devel to pass "--no-require-sandobox" when yesod devel is run with stack (when there's a GHC_PACKAGE_PATH set) 
19:52:03 <texasmynsted> I find external sources reinforce what I have learned and often expose things in another way
19:52:13 <radens> How do I make this valid syntax? if length head > 0 && head rest `elem` operators then ...
19:52:41 <mgsloan> Welkin: Should be an easy fix.  I'm sorry that such issues give you a bad impression of stack, but this really has nothing to do with it
19:52:45 <jle`> radens: parentheses?
19:52:56 <Welkin> mgsloan: how can I do that?
19:53:02 <radens> jle`: I tried, it starts complaining about infix operators
19:53:22 <jle`> if (length head > 0) && (head rest `elem` operators) then ... ?
19:53:47 <radens> jle`: No instance for (Foldable ((->) [a0])) arising from use of length
19:53:55 <mgsloan> https://github.com/yesodweb/yesod/blob/ae0d0b12c4e17705a01f3bdd78a2a3743b17bdf7/yesod-bin/main.hs#L147  Add "--no-require-sandbox" here
19:54:02 <jle`> ah that's not a syntax error
19:54:11 <radens> so sue me it's a type error
19:54:57 <Ralith> that's a very different kind of thing
19:55:33 <Welkin> mgsloan: is there a way to do it without keeping a custom version of yesod-bin around?
19:55:54 <mgsloan> Yes, you can create a wrapper script around cabal install or change your global config
19:56:00 <jle`> radens: ah, if head is from Prelude
19:56:08 <radens> it is
19:56:11 <jle`> radens: then you can't call length on head
19:56:14 <jle`> head is a function
19:56:22 <radens> derp
19:56:27 <mgsloan> Or fix it in yesod-devel so that others can benefit from it
19:56:37 <mgsloan> That's the approach I prefer
19:57:06 <Welkin> mgsloan: you mean submit a pull request?
19:57:15 <mgsloan> Yup
19:57:18 <Welkin> is this a common problem then?
19:57:23 <radens> jle`: thanks!
19:57:40 <jle`> np!
19:57:52 <mgsloan> Welkin: First I've heard of it, but it doesn't matter if it's common
19:58:25 <mgsloan> AFAIK it's not that common to have require sandbox in your global cabal config
19:58:29 <Welkin> how would I install a local package using stack?
19:58:34 <Welkin> like add-source in cabal
19:59:00 <mgsloan> Add it to your packages list
19:59:09 <mgsloan> In stack.yaml
20:00:58 <mgsloan> ( https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md#multi-package-projects )
20:05:06 * hackagebot stripe-haskell 0.1.4.3 - Stripe API for Haskell  https://hackage.haskell.org/package/stripe-haskell-0.1.4.3 (DavidJohnson)
20:07:05 <lagrangi-wan> Just wondering... What are the historical reasons why is Applicative called Applicative? Shouldn't it be more, like, Monoidal?
20:08:10 <geekosaur> ???
20:08:21 <jle`> probably because of ap/(<*>)?
20:08:24 <jle`> :t (<*>)
20:08:25 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
20:08:44 <jle`> being able to "apply" over f
20:08:46 <geekosaur> there are associated monoids, but that's true of functions in general --- and a whole lot of other stuff
20:09:06 <exio4> maybe people found that Applicative sounded less fancy than lax monoidal functor :p
20:09:06 <geekosaur> and Applicative has relatively little to do with monoids other than the function monoids
20:09:28 <exio4> geekosaur: I think he's refering to the `category theory` equivalent of Applicative 
20:09:54 <geekosaur> yeh, got that from what you just sent
20:10:06 <geekosaur> and I think the issue there is that programming languages kinda can't do any other kind?
20:10:19 <geekosaur> (IIRC)
20:10:29 <hamilto-nyan> Any other kind of what? :-O
20:10:42 <geekosaur> there have been discussions, including one a couple days ago where someone suggested that even talking about the category theory verison of it was not helpful
20:10:58 <radens> Should I commit cabal.sandbox.config?
20:16:04 * geekosaur looks for discussion of how there's no real point in discussing those things, because it implies a more general structure that you can't represent in a programming language 
20:16:07 <dmj`> radens: nah, maybe cabal.config (from cabal freeze), but nah
20:16:44 <geekosaur> meh
20:17:01 <dmj`> radens: it's specific to a single environment, so it might confuse others
20:17:25 <radens> Okay
20:17:46 <radens> I was thinking it might be like Gemfile.lock
20:17:55 <geekosaur> was related to the oh, I guess it's not all programming languages, just this kind of type system
20:18:40 <geekosaur> like, haskell has no nontrivial comonoids
20:19:45 <dmj`> radens: cabal.config, from calling `cabal freeze` is more like that
20:19:46 <geekosaur> which IIRC led to various other things not being meaningfully "reversible" and that leading to not being able to talk about more general structures
20:19:52 <geekosaur> but I'm not finding the discussion :/
20:20:06 * hackagebot google-translate 0.1.1.2 - Google Translate API bindings  https://hackage.haskell.org/package/google-translate-0.1.1.2 (DavidJohnson)
20:21:23 <hamilto-nyan> geekosaur: I'm pretty sure Haskell (or at least GHC) is capable of representing more than what its standard library actually does. I once tried to define a type class for strict monotone maps, so that Set could be an actual functor (from the category of strict total orders to Hask). The result wasn't terribly pleasant to use, though. :-|
20:21:40 * geekosaur admits he is not very knowledgeable about category theory in depth, which is not helping with finding discussions
20:24:46 <hamilto-nyan> I'm not terribly knowledgeable about CT either. I just find it annoying that, given `m :: Set Foo` and `f :: Foo -> Bar`, where `x < y --> f x < f y`, I can't `fmap f m :: Set Bar`.
20:26:56 <hamilto-nyan> A workaround that I've found is to expose search trees directly to users, leaving up to them to guarantee that the elements are stored in any meaningful order. But this means I can't use the existing `containers` library. :-|
20:27:12 <Pamelloes> hamilto-nyan: How would you codify that second condition as a Haskell type?
20:27:53 <Welkin> mgsloan: I can't even get stack to recognize the package
20:28:18 <Welkin> I tried puttin it in another directory adjacent to the one I am working in and gave it a relative path for the package
20:28:22 <Welkin> that did not work
20:28:24 <slack1256> I actully would be very against what every constrain hack you would need to do that with fmap and Set
20:28:30 <Welkin> it doesn't seem to recognize ../
20:28:57 <Welkin> then I tried putting it on github, but that doesn't work either, because the .cabal for yesod-bin is in a sub-directory
20:29:27 <slack1256> just because that fmap conserves shapes is a very useful thing
20:29:36 <hamilto-nyan> Pamelloes: I'd have a `class Morphism m where { type Source m ; type Target m }`, as then define `Functor` this way: https://github.com/eduardoleon/salami/blob/master/Functor/Functor.hs
20:30:23 <exio4> slack1256: that was the point of hamilto-nyan's extra constraints
20:30:50 <johnw> hamilto-nyan: I have a feeling your type errors are just no fun at all
20:30:52 <hamilto-nyan> Pamelloes: That way, each Functor is responsible for declaring over which morphism it can `map`.
20:30:58 <hamilto-nyan> johnw: Of course they are no fun.
20:31:03 <Welkin> ah, I found it
20:31:12 <Welkin> there is a subdirs options
20:31:41 <Pamelloes> hamilto-nyan: I don't really understand that code, so I'll take your word for it :)
20:31:47 <tomberek> ski: you around?
20:32:31 <johnw> hamilto-nyan: there's a blog article on "exofunctors" in Haskell
20:32:44 <johnw> hamilto-nyan: https://dorchard.wordpress.com/2011/10/18/subcategories-in-haskell-exofunctors/
20:32:52 <hamilto-nyan> johnw: Checking.
20:33:42 <exio4> the type errors as soon as you go past the `easy-to-infer` code become a bit harsh :P  
20:34:19 <Welkin> mgsloan: that did not work
20:34:40 <Welkin> I added --no-require-sandbox where you specified, but that only caused cabal to give another error
20:34:42 <johnw> hmm. fpcomplete links are just not working for me today
20:34:45 <johnw> they fail to load every time
20:34:48 <Welkin> cabal: unrecognized 'configure' option `--no-require-sandbox'
20:34:51 <hamilto-nyan> johnw: «type classes define subcategories» --> Only if there's an appropriate notion of morphisms between instances! (Which is exactly what Haskell's standard library never bothers trying to express.)
20:35:44 <bitemyapp> johnw: weird, my coauthor happened to discuss that article two days ago.
20:36:07 <hamilto-nyan> johnw: Also, the function `Data.Set.map` mentioned in that post seems a tiny bit unsafe -- who guarantees that the function being mapped over is strict monotone? :-|
20:36:24 <hamilto-nyan> (Which is exactly the problem I'm trying to solve.)
20:37:05 <johnw> hamilto-nyan: have you seen http://mmisamore.github.io/2015/04/28/SetFunctor/ ?
20:37:30 <slack1256> this monotony is over some total-order right? not that weird domain theory semantic order right?
20:37:52 <hamilto-nyan> slack1256: Over `Ord` instances.
20:39:09 <slack1256> you want a type (Monotonous f) that say forall x y , x < y => f x < f y
20:39:10 <tomberek> the instance for applicative for Maybe fails whenever either side of <*> is Nothing. This lpaste is an attempt to have an instance that fails in the other direction, such that two Nothing's are required to fail the <*>.  http://lpaste.net/141642    I can't find any clear Applicative law violations, thoughts?
20:39:41 <hamilto-nyan> slack1256: It is more or less what I do here: https://github.com/eduardoleon/salami/blob/master/Category/Morphism.hs
20:39:45 <slack1256> that reeks of dependent typing. I also don't think you can provide only say ways to build a monotonous function and make that datatype abstract
20:39:51 <hamilto-nyan> johnw: Just finished reading it.
20:41:00 <hamilto-nyan> slack1256: I think it's just impolite to allow a function to exist such that `x = y` but `f x /= f y`.
20:41:03 <hamilto-nyan> Err, johnw *
20:41:42 <mgsloan> Welkin: Oh?  TBH I haven't used cabal
20:41:52 <slack1256> well, that is the functional requeriment
20:41:54 <mgsloan> johnw: Which links?
20:41:54 <hamilto-nyan> johnw: That is, `unAlwaysEq` should not exist.
20:42:12 <mgsloan> Welkin: Didn't finish my sentence.  *used cabal much in the last couple years
20:42:32 <mgsloan> So I'm not really very good at working around such issues
20:42:41 <johnw> mgsloan: it was that Set is not a functor link, but it's loading now
20:42:48 <johnw> mgsloan: it was happening to me earlier today too
20:43:22 <mgsloan> Strange!
20:44:25 <cmccann> what's the best library for deserializing binary data when you don't want to process it linearly
20:44:29 <johnw> hamilto-nyan: it is kind of impolite, isn't it :)
20:44:41 <cmccann> i.e. a file format with internal pointers that you need to chase around to make sense of what comes next
20:45:20 <toxicPoiSon> yo
20:45:30 <johnw> cmccann: just seek around and deserialize on read (ala binary) as needed?
20:45:57 <cmccann> johnw: that's what I've done in the past and was hoping there was a nicer way
20:46:08 <johnw> if it's overall linear, but you just want pieces, you could use a FreeT of pipes producers
20:46:15 <johnw> i.e., your stream is not the data, but a series of accessors for the data
20:47:05 <cmccann> I have a large bytestring in memory and I want to deserialize chunks of it in potentially arbitrary order
20:47:10 <hamilto-nyan> johnw: If a type has an `Eq` instance that couldn't possibly be `deriving`'d, then methinks it should be kept abstract (constructors sealed inside the module).
20:48:12 <johnw> cmccann: you can't just have an array of deserialization thunks then?
20:48:26 <cmccann> i.e. treating it as any sort of "stream" is exactly what's counterproductive here. individual chunks are linear, but I'd like to avoid having to read offsets, finish deserializing that chunk, then go back and chase those around
20:49:02 <johnw> if it's all in memory already
20:49:07 <cmccann> like, to use an example from something I was tinkering with a while back, the file has a dictionary of strings shoved in there somewhere and everything else uses offsets to those strings instead of storing strings inline
20:49:31 <cmccann> and if I'm deserializing a data structure I'd like to get those strings where they belong, not read offsets and fill them in later
20:49:36 <johnw> yeah, like object files do
20:49:41 <cmccann> it's pretty common
20:50:08 * hackagebot hackernews 0.5.0.1 - API for Hacker News  https://hackage.haskell.org/package/hackernews-0.5.0.1 (DavidJohnson)
20:50:23 <johnw> can you read the string table in as an IntMap Text, and then just access them that way?  I feel like I'm missing some other requirement here...
20:50:48 <johnw> dmj`: does hackernews use servant? :)
20:51:24 <bitemyapp> johnw: supposedly IntMap is almost always slower than HashMap
20:51:40 <bitemyapp> johnw: and so if it can be done, you can use HashMap instead and get a "free" win.
20:51:41 <johnw> yeah, but he has integer offsets into the string table
20:52:01 <cmccann> johnw: at least in one case I had no way to know where the string table started until I'd done a fair bit of digging through the file :T
20:52:28 <dmj`> johnw: soon :) 
20:53:02 <cmccann> stuff had byte offsets directly into the table, not indices into a "dictionary" like structure, so I couldn't just read all the strings in advance
20:53:12 <johnw> hmm
20:53:15 <cmccann> without doing multiple passes through the file or other additional complications
20:53:47 <cmccann> for that one I ended up rolling my own bit of stuff on top of binary that let me jump around and pick up where I left off
20:54:32 <cmccann> which was ok in the end since it let me do some other stuff as well like pretty print a hex dump of the file showing where everything was and what sections I never touched
20:55:13 <cmccann> (this example was a bit of experimental reverse engineering, fwiw, so I had no file format spec to reference, heh)
20:56:06 <cmccann> anyway, it just seems like there should be *something* on hackage that would make this kind of scenario easier but I can't find anything :[
20:58:08 <Welkin> well mgsloan, geekosaur: neither of your suggestions worked
20:58:14 <Welkin> I tried them both
20:58:18 <cmccann> ah well, I guess I'll just wing it again
20:58:18 <johnw> cmccann: how would you describe the library, if it were on Hackage?
20:58:33 <cmccann> johnw: beats me, that's part of why I'm asking
20:58:34 <Welkin> first modified yesod-bin, then tried wrapping stack's cabal with a shell script that passed in --no-require-sandbox
20:58:46 <johnw> I don't feel that I understand clearly enough yet
20:58:59 <cmccann> johnw: since a few dozen attempts at ctrl-F for keywords on the package list page found nothing that looked promising
20:59:45 <tomberek> Anyone strong with Applicative/MonadPlus/Alternative?
20:59:59 <johnw> tomberek: what is the question?
21:00:04 <tomberek> the instance for applicative for Maybe fails whenever either side of <*> is Nothing. This lpaste is an attempt to have an instance that fails in the other direction, such that two Nothing's are required to fail the <*>.  http://lpaste.net/141642    I can't find any clear Applicative law violations, thoughts?
21:00:21 <cmccann> johnw: if I had a clearer idea of exactly what such a library should look like I'd just write a proper one myself and put that on hackage :P
21:00:36 <tomberek> johnw: it's almost like bringing Alternative/MonadPlus behavior down to Applicative operators
21:01:21 <tomberek> or did I just horribly re-invent something that already exits? or worse, break laws?
21:01:36 <johnw> tomberek: what is the meaning of Just (+1) <*> Nothing?
21:01:51 <cmccann> johnw: anyway, thanks and sorry I'm not being very clear, heh
21:02:20 <johnw> cmccann: you are tantalizing me with cool library ideas just out of reach
21:02:21 <tomberek> johnw: evaluates to Nothing, it uses Maybe for failure
21:02:42 <johnw> tomberek: isn't that the current behavior?
21:02:54 <cmccann> johnw: I gotta say the bit where I had it prettyprint the hex dump was actually pretty rad once I got it working
21:02:55 <tomberek> johnw: I want to use Maybe for success
21:03:09 <johnw> tomberek: I don't understand
21:03:47 <cmccann> johnw: it made reverse-engineering the format a lot easier when I could skim a hex dump annotated with all the stuff I had figured out
21:03:56 <tomberek> johnw: if either side of the <*> is Just _, then both sides are sucessfull. Obviously i need to carry around a pure value for that, hence my S newtype
21:04:15 <johnw> what does "both sides are successful" mean?
21:04:47 <johnw> cmccann: that sounds like a useful analysis tool
21:05:19 <cmccann> johnw: I'm sure something similar already exists somewhere. probably written in C and at least 20 years old.
21:06:03 <tomberek> johnw:  so...    S id Nothing <*> S 3 (Just 3)  should be =>    S 3 (Just 3)
21:06:35 <tomberek> S (+2) Nothing <*> S 3 (Just 3)  should be =>    S 5 (Just 5)
21:07:30 <Pamelloes> tomberek: Why is that better than Just (+2) <*> Just 3? It seems you're adding an extra layer for no real reason....
21:07:31 <exio4> tomberek: what does S 5 (Just 4) mean?
21:08:01 <tomberek> exio4:  shouldn't exist
21:08:45 <exio4> tomberek: then you want "Either a a"? where the Left would represent the extra a, and Right a would represent the Just a? 
21:08:45 <awpr> wait, so S x (pure y) has an invariant that x === y?
21:09:00 <exio4> tomberek: now, I would ask, what's the point of this? 
21:09:06 <exio4> tomberek: it seems you want just "a"
21:09:11 <tomberek> awpr: yes
21:09:22 <awpr> that sounds isomorphic to (a, Bool)?
21:09:24 <tomberek> exio4: i still need the failure signal when both sides are Nothing
21:09:42 <tomberek> awpr: perhaps, i hadn't thought of that
21:09:49 <tomberek> context:
21:11:16 <tomberek> I am using compos (generics library which uses Applicative) and want to describe rewrite rules. Problem is that if one half of the AST has no rewrites, it's value is Nothing, but if the other side has a rewrite, i need to capture it.
21:11:42 <exio4> tomberek: so you want to represent something like a classical `and`?
21:11:49 <exio4> er, classical or
21:11:56 <tomberek> exio4: or
21:12:10 <tomberek> exio4: yes, this brings Alternative-like behavior to <*>
21:12:33 <Pamelloes> tomberek: Is there a reason you can't just use Alternative?
21:12:45 <Pamelloes> Seeing as Applicative a => Alternative a?
21:13:06 <cmccann> johnw: here I grabbed an sample to show you https://gist.github.com/isomorphism/6def39f8d99d7ab2e005
21:13:14 <awpr> so you want to merge two values of type a that may have been rewritten, and the result also knows whether it was rewritten?
21:13:37 <cmccann> johnw: a chunk of the annotated output and some corresponding parsing code
21:13:55 <tomberek> Pamelloes: the compos formulation doesn't admit Applicative.... I could of course write one, but I wanted to see if this was possible.... i don't see any law violations, and it expresses something different than Maybe
21:14:15 <johnw> cmccann: ah, nice
21:14:26 <johnw> a labelling parser, of sorts
21:14:35 <cmccann> johnw: wait I think I actually grabbed the wrong section of code, haha
21:14:36 <Welkin> well, I had to remove require-sandbox from my cabal config
21:14:41 <Welkin> this is not a good solution
21:14:47 <cmccann> but you get the idea, even if that's not the code that generated that section of the output
21:15:18 <awpr> tomberek: in fact I think you want the Monoid m => Applicative ((,) m) instance with a suitable newtype over Bool (which I assume exists)
21:15:19 <Welkin> actually, I also realized that stack is *not* using its own cabal binary
21:15:23 <Welkin> it is using the one on my system
21:15:30 <exio4> awpr: I was going to suggest that :p
21:15:31 <johnw> cmccann: this is a handy trick.  blog it at least!
21:15:32 <cmccann> johnw: as you can probably tell I was trying to decipher some fiddly propriety 3d model format
21:15:36 <Welkin> even though it installed its own in .local/bin
21:15:40 <tomberek> awpr: yes, i was just looking at that...
21:15:51 <edwardk> fun hack for faster uniques. allocate a 0 byte MutableByteArray# s, then unsafeCoerce it into an Addr#, keep that Addr# and the original MutableByteArray# as your unique. no global locks to grab. you can meet the same API.
21:16:11 <edwardk> data Unique = Unique Addr# (MutableByteArray# RealWorld)
21:16:39 <edwardk> just tested it
21:16:52 <johnw> edwardk: that's the C++ trick of "the pointer to your heap object is always a unique value" right?
21:16:54 <mgsloan> Welkin: stack only uses the cabal binary for "stack solver"
21:16:57 <tomberek> awpr: (Any, a) seems to do the trick
21:17:03 <edwardk> johnw: well, the problem is the gc moves it
21:17:11 <edwardk> so you need to snapshot it when you get it
21:17:15 <Welkin> mgsloan: technically, this is yesod-bin using cabal
21:17:26 <edwardk> and you need the object identity to fix it when it lies because you reused that address on the heap
21:17:26 <mgsloan> Ahh, right, then yes, it will use the one on your PATH
21:17:29 <Welkin> mgsloan: but why would it use mine and not the one in stack's environment?
21:17:31 <johnw> how do you prevent reuse of the same Addr#?
21:17:34 <edwardk> you don't
21:17:41 <johnw> ah, so it is kind of the same trick
21:17:41 <mgsloan> Welkin: Oh, good point, hmm
21:17:42 <edwardk> we use the addr for the hashcode
21:17:45 <johnw> just in C++, the fixing is implied
21:17:56 <Welkin> mgsloan: this is why wrapping cabal in a shell script did not work
21:17:57 <cmccann> johnw: ohh actually I think that output is from an older version of the code, that's why it doesn't match. but anyway.
21:17:57 <edwardk> we use the sameMutableByteArray# for the equality check
21:18:06 <edwardk> so you can get hash collisions, but not equality collisions
21:18:12 <mgsloan> Welkin: How about adding the shell scrippt to your PATH manually?
21:18:14 <Welkin> mgsloan: and your suggestion for modifying yesod-bin also did not work
21:18:20 <mgsloan> Why not?
21:18:22 <cmccann> johnw: I sorta don't have a blog which makes it hard to blog silly things like this on short notice :T
21:18:37 <johnw> cmccann: write it up, I'll post it somewhere for you :)
21:18:52 <Welkin> mgsloan: cabal: unrecognized 'configure' option `--no-require-sandbox'
21:19:09 <johnw> I love cheap techniques like this that use no type hackery, yet can have huge value
21:19:42 <mgsloan> Welkin: Well that's strange, where is the flag supposed to go?
21:20:04 <johnw> we're walking through a structure, to produce a value, but we want to "map" the structure as we move through it, so we can dump both the territory and the value we constructed from some part of it
21:20:10 <edwardk> johnw: https://github.com/ekmett/propagators/commit/4f0092ad71cc585294669493d0d70d8c8c61fd85
21:20:18 <mgsloan> As I said, I don't really use cabal much, so I'm not much use with working out what it's doing
21:20:20 <Welkin> cabal --no-rquire-sandbox I suppose
21:20:36 <cmccann> johnw: it's not really a trick, is it? it's just a parser that records some extra data while it goes and then prettyprints it elaborately at the end
21:20:48 <johnw> edwardk: that might be useful all on its own, under 'uniques' or something
21:21:10 <edwardk> johnw: well if its fast enough i might encourage it for ghc's base Unique =)
21:21:14 <johnw> cmccann: your StructParser is the trick, I'd think, and the way it builds the map
21:21:50 <johnw> cmccann: I'm already thinking of ways I could use this...
21:22:13 <johnw> normally I just throw the extra info away, and use print debugging when I need to dig through it
21:22:23 <cmccann> johnw: yeah
21:22:50 <bitemyapp> mgsloan: what a world to live in :)
21:22:51 <cmccann> I was doing that, and then I upgraded to printf debugging file offsets and looking through a hex dump in a separate program
21:23:21 <cmccann> johnw: and then at some point I realized that I was inventing a complex workflow for no good reason since I had all the info right there to begin with
21:23:55 <Welkin> if yesod-bin is still using cabal-install, then what is the point in suggesting to newcomers that they use stack to install it?
21:24:05 <cmccann> johnw: if you want to tinker with it I can give you the code for StructParser etc.
21:25:04 <mgsloan> Welkin: Well, it's known to build that way.  Whereas newcomers who try to cabal install it might have it say scary things about --force-reinstall always being dangerous
21:25:06 <cmccann> I'm sure it's a horrific mess though, it's the sort of code that grow "organically" in the same sense a tumor grows organically
21:25:52 <johnw> cmccann: sure
21:25:55 <mgsloan> Welkin: Plus, snoyberg wrote a lot of the stack code, so there's that
21:25:58 <Stratege_> cmccann I need to remember that quote. Thanks :D
21:26:42 <johnw> @remember cmccann I'm sure it's a horrific mess though, it's the sort of code that grows "organically" in the same sense a tumor grows organically
21:26:43 <lambdabot> Okay.
21:26:53 <cmccann> ha
21:27:59 <cmccann> johnw: anyway, I'll just toss it in a proper repo on github, that's probably simplest
21:28:17 <johnw> and thence to Hackage
21:28:44 <johnw> struct-parse
21:29:20 <johnw> it should really be reversible, to be cool
21:29:29 <johnw> an extension of binary
21:29:54 <johnw> or some kind of wicked lens
21:30:22 <johnw> since we've got a pairing of (annotated binary data, value from subset of data)
21:31:26 <johnw> actually, I wonder if Binary a => Lens' ByteString a is already a thing
21:32:23 <johnw> or maybe it's better as a prism
21:33:01 <radens> Can you extend haskell's type system?
21:33:09 <radens> Or embed haskell in a DSL easily?
21:33:27 <tomberek> awpr: thanks!  (Any,a) worked perfectly. I guess I just went the long way around to reimplement it.
21:35:32 <cmccann> johnw: ok, I stripped everything general-purpose I could find and pushed it
21:35:57 <cmccann> surprisingly it actually compiles. for me, anyway.
21:36:28 <cmccann> if you want to mess with it you'll probably want to start by removing the part where it uses my increasingly irrelevant alternate prelude
21:37:01 <cmccann> and then probably add a bunch of missing imports that it was getting from there
21:37:40 <cmccann> johnw: https://github.com/isomorphism/labelled-hexdump-parser 
21:39:31 <cmccann> johnw: most of what's in Common.hs is probably not reusable directly but I left it in to demonstrate more of how the labeling and grouping is used
21:50:11 * hackagebot debian-build 0.9.0.0 - Debian package build sequence tools  https://hackage.haskell.org/package/debian-build-0.9.0.0 (KeiHibino)
21:50:59 <shyardo> hey, anyone knows if is there a function like 'minimum', but with a key function, as such that minimum :: (a -> b) -> [a] -> a?
21:52:38 <awpr> http://haddock.stackage.org/lts-3.4/base-4.8.1.0/Data-Foldable.html#v:minimumBy should be able to implement that
21:52:45 <glguy> :t minimumBy . comparing
21:52:46 <lambdabot> (Ord a1, Foldable t) => (a -> a1) -> t a -> a
21:53:58 <shyardo> nice
21:54:02 <shyardo> thanks a lot
22:00:11 * hackagebot http2 1.1.0 - HTTP/2.0 library including frames and HPACK  https://hackage.haskell.org/package/http2-1.1.0 (KazuYamamoto)
22:24:44 <nchambers> if I wanted to change a value in random cell in a list, then get the new list, how would I do that?
22:25:09 <Lokathor> well first you pick a random index
22:25:26 <Lokathor> probably some sort of State StdGen situation there
22:26:23 <Lokathor> then you can use lens to modify the list, or perhaps a simpler solution like updateList :: (a -> a) -> Int -> [a] -> [a]
22:30:57 <lpaste> Lokathor pasted “example updateList” at http://lpaste.net/141647
22:31:10 <awpr> you could also change the container to one better suited to random updates, like MVector, and do something similar, except with constant time instead.
22:32:04 <Lokathor> yeah lists aren't really the best for that sort of thing
22:32:49 <awpr> I think Data.Sequence would be O(log n) too, if you don't feel like bringing ST or IO into the equation
22:33:33 <quicksilver> GHC.Exts.the deserves a place in a more central library
22:33:37 <quicksilver> Data.List probably
22:35:36 <Lokathor> quicksilver, i don't get the description
22:35:38 <awpr> I don't think we need more partial functions in base.  [a] -> Maybe a could be nice, though
22:35:42 <julianleviston> updateList n x xs = take n xs ++ [x] ++ drop (n+1) xs
22:35:42 <Lokathor> what is meant by "ensures"
22:36:01 <quicksilver> Lokathor: it returns Nothing if they're not all equal
22:36:10 <Lokathor> @type the
22:36:11 <lambdabot> Not in scope: ‘the’
22:36:15 <quicksilver> the [3,3,3] ==  Just 3, but the [1,2,3] == Nothing
22:36:25 <exio4> you mean `crashes`, not `returns`
22:36:29 <awpr> that's not the type I see on Stackage Hoogle
22:36:29 <Lokathor> well the doc says "the :: Eq a => [a] -> a"
22:36:38 <exio4> @type GHC.Exts.the
22:36:40 <lambdabot> Eq a => [a] -> a
22:36:45 <quicksilver> oh haha
22:36:51 <quicksilver> then I reimplemented a safe version of it
22:36:56 <quicksilver> I like the Maybe-version I wrote :)
22:36:59 <Lokathor> yeah that's why I was wondering
22:37:47 <Lokathor> of course safeThe should really be named safedByThe
22:37:50 <Lokathor> for comedy reasons
22:38:15 <awpr> also, it's the join operation of a uniqueness lattice, which is a term I just invented that means "data Uniq a = Bot | Top | Elem a"
22:38:39 <Lokathor> hmmmm
22:38:43 <Lokathor> Bot = undefined?
22:38:45 <Lokathor> Top = ???
22:39:13 <Lokathor> oh oh they're the ends!
22:39:28 <awpr> yep, it's a bounded lattice and they're the join and meet
22:39:55 <awpr> I actually asked if there's a name for this yesterday and nobody answered, so I made one up this time
22:40:27 <quicksilver> neat awpr 
22:40:47 <quicksilver> anyhow checking for uniqueness at the same time as possibly returning the common value seems very natural to me
22:41:28 <mgsloan> awpr: the lattices package calls them bounded lattices
22:41:33 <shachaf> What's a uniqueness lattice? A free bounded lattice on a lattice?
22:41:36 <mgsloan> which seems like good terminology
22:42:01 <mgsloan> Check this out - it makes a lattice bounded by grafting on top and bottom https://hackage.haskell.org/package/lattices-1.4/docs/Algebra-Lattice-Levitated.html
22:42:56 <mgsloan> (and is pretty much identical to your Uniq type)
22:43:12 <shachaf> That looks free to me.
22:44:14 <Gurkenglas> :t [1,1,1] ^. unsafeSingular (to group . each) -- How to plug _head into that now?
22:44:15 <lambdabot> (Eq t, Num t) => [t]
22:44:27 <awpr> shachaf: I did try to justify calling it "free", but I don't think it's quite the same as 'free bounded lattice on a lattice'
22:44:49 <shachaf> Why not?
22:44:52 <Gurkenglas> (Is there a Maybe version of unsafeSingular?)
22:45:06 <awpr> because Elem x `join` Elem y | x /= y is Top
22:45:06 <quicksilver> the maybe version is to use ^? not ^.
22:45:09 <quicksilver> perhaps?
22:45:28 <awpr> not Elem (x `join` y)
22:46:01 <Gurkenglas> quicksilver, I don't want the first target, I want "the" target, as unsafeSingular specifies
22:47:00 <shachaf> awpr: Oh. That's not the instance in https://hackage.haskell.org/package/lattices-1.4/docs/src/Algebra-Lattice-Levitated.html
22:47:38 <awpr> indeed it isn't
22:49:01 <glguy> > [1,1,1,2] ^.. folding group . _head -- this?
22:49:02 <lambdabot>  [1,2]
22:53:02 <Gurkenglas> glguy, now you got rid of unsafeSingular and I can't wrap it around folding group and I don't know why
22:53:39 <Gurkenglas> Although I can wrap it around the whole thing and I don't know why
23:00:14 * hackagebot ihaskell 0.8.2.0 - A Haskell backend kernel for the IPython project.  https://hackage.haskell.org/package/ihaskell-0.8.2.0 (gibiansky)
23:00:16 * hackagebot ipython-kernel 0.8.2.0 - A library for creating kernels for IPython frontends  https://hackage.haskell.org/package/ipython-kernel-0.8.2.0 (gibiansky)
23:00:18 * hackagebot ihaskell-widgets 0.2.2.0 - IPython standard widgets for IHaskell.  https://hackage.haskell.org/package/ihaskell-widgets-0.2.2.0 (gibiansky)
23:08:39 <orb_> I'm trying out lenses.  What's an idiomatic way to do write a function / lens to swap.  Eg if we had, data Foo = Foo Int Int Char, I'd want swap (Foo a b c) = Foo b a c
23:10:50 <Lokathor> the function there seems to swap quite well
23:25:32 <cocreature> orb_: I would probably make a lens that gives you a swapped view of Foo, but I don't claim to be an expert on lens
23:25:54 <orb_> cocreature: ok, how?
23:26:28 <orb_> Oh, I want to return a new Foo that's swapped.  (It's for a game.  We are swapping position, to use the same evaluation function for both sides.)
23:27:02 <cocreature> if you really only want to swap it I don't think lens buys you anythin
23:27:05 <orb_> I thought there might be a way to combine to lenses to get a view into tuple, then use a standard tuple swap for the map / update?
23:27:18 <orb_> Oh, I'm just trying to get my head around lenses, it's just an example.
23:27:23 <orb_> Not meant to buy much.
23:27:38 <orb_> (But in this case, there's more I want to do.  Swapping is just one of the things.)
23:27:48 <orb_> I also need to invert score etc.
23:27:59 <cocreature> what lenses would allow you would be to map a function over the swapped Foo but getting backed the unswapped version of that
23:31:17 <orb_> Actually, that view would be good, too.
23:31:28 <cocreature> give me a minute, I'll write it
23:31:33 <orb_> It's basically an isomorphism.
23:32:13 <orb_> Thanks!
23:33:06 <shachaf> involuted yourSwapFunction
23:33:32 <cocreature> swapped = iso (\(Foo a b c) -> Foo b a c) (\(Foo b a c) -> Foo a b c) should probably do the trick
23:33:33 <shachaf> Or, if it changes types, iso yourSwapFunction yourSwapFunction
23:34:22 <cocreature> ah nice, I didn't know about involuted
23:34:26 <breadmonster> :t iso
23:34:27 <lambdabot> (Functor f, Profunctor p) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
23:34:35 * breadmonster blinks.
23:36:16 <orb_> In my case, my swap function is it's own inverse.  It's for https://www.hackerrank.com/challenges/the-bidding-game
23:36:22 <orb_> Thanks for the code.
23:36:57 <shachaf> An involution is a function which is its own inverse.
23:37:03 <shachaf> Hence involuted.
23:37:04 <cocreature> yeah if it's it's own inverse, "involuted (\(Foo a b c) -> Foo b a c)" is easier
23:38:31 <julianleviston> :r
23:38:34 <julianleviston> oops
23:43:55 <orb_> In my case, I also have \(GameParam maxPosition, GameState moneyA moneyB position) -> (GameParam maxPosition, GameState moneyB moneyA (maxPosition - position))
23:44:24 <orb_> The GameParam is just passed through, and viewed but not touched (but the type doesn't show this).
23:46:48 <opqdonut> orb_: the type would show it if you didn't pass GameParam out
23:46:59 <orb_> Yes.
23:47:18 <orb_> I need a wrapper function that does: (a, b) -> (a -> b -> b) -> (a,b) then.
23:47:42 <cocreature> what is that supposed to do?
23:48:28 <orb_> let invert2 (GameParam maxPosition) (GameState moneyA moneyB position) = (GameParam maxPosition, GameState moneyB moneyA (maxPosition - position))
23:48:40 <jle`> orb_: any reason why you'd want the a back?
23:48:55 <jle`> if you don't need it, it's just uncurry
23:49:05 <orb_> Oh, I need to keep track of it for later.
23:49:11 <orb_> It's just that it's constant per game.
23:49:26 <jle`> how about using Reader then, maybe?
23:49:31 <opqdonut> orb_: that wrapper is called Reader
23:49:33 <orb_> But the bots that are supposed to play (and the invert/swap function) need access to it to make decisions.
23:49:36 <opqdonut> oh, jle` beat me to it :)
23:49:43 <orb_> Yeah, Reader would do it.
23:50:23 <jle`> it really depends ultimately on what you're doing
23:51:01 <orb_> Yes.
23:51:04 <jle`> Reader is nice because it's sort of a way of saying that all recursive/successive calls will not "change" the `a` by the end of it (without using local to change it for a small part)
23:51:33 <jle`> it's essentially the same as just passing the argument down normally as an argument, though
23:51:59 <jle`> the main benefit is that using (>>=) instead of function calls is a way to enforce that the `a` is always the same
23:52:10 <jle`> whereas function calls can re-call with anything they want
23:52:13 <orb_> I'd rather use <*>
23:52:14 <orb_> ;)
23:52:18 <jle`> yeah, (<*>) too :)
23:52:47 <jle`> the benefits of Reader over just manual parameter passing are sort of marginal admittedly.  what i mentioned is probably the only advantage that i see
23:53:08 <orb_> I guess it makes sense in a monad transformer stack.
23:53:15 <jle`> yeah
23:53:18 <quicksilver> and, actually, the downside is forcing you to write your code in a certain shape
23:53:29 <quicksilver> (so you can use >>= or <*> or monad notation)
23:53:33 <jle`> or in general when you're using a type that is parameterized for a Monad for extra effects
