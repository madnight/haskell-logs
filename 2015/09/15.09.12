00:13:24 <kalkin-> it cant be so hard to just parse some xml.
00:23:58 <scshunt> kalkin-: well, it's not hard to parse XML, it just has lots of boilerplate :P
00:24:25 <scshunt> kalkin-: the point of Generic is to allow you to provide one implementation of Serialize based on a a representation of the type
00:24:26 <kalkin-> fair enough :)
00:25:01 <scshunt> so the compiler hands you a Haskell version of the type's structure, and then you implement your serialization based on that
00:25:36 <scshunt> but this is one type which is common across everything you might serialize, so you only need to write one implementation
00:25:44 <scshunt> it's a new and rather experimental feature
00:26:10 <scshunt> the "old way" would be Template Haskell, which allows you do write arbitrary code at compile time. It's more powerful but also much more dangerous
00:26:28 <scshunt> with great power comes great ability to shoot yourself in the foot, yadda yadda
00:27:53 <kalkin-> scshunt: i get the general idea of GHC.Generics (basically it some serialization mechanism) but i do not understand how to apply it. 
00:28:16 <kalkin-> Why should i teach haskell what a String is and how to parse it out from xml? this is what hxt is for
00:28:22 <scshunt> it's not a serialization mechanism
00:28:28 <scshunt> it's a reflection mechanism
00:29:08 <kalkin-> so it uses reflection to figure out what fields in a record it needs to initialize?
00:29:11 <scshunt> at its core, all a Generic instance does is  tell your haskell code what an object of that type looks like, and provide a way to go to or from a representation in the common structure to an actual type
00:29:22 <scshunt> what you do with the representation is up to you
00:29:33 <cocreature> kalkin-: you teach haskell how your type is represented as xml
00:30:14 <kalkin-> scshunt: when i do data Foo = Foo {...} isn't that the same as telling Haskell what my type looks like? 
00:30:25 <scshunt> kalkin-: right. Generic lets haskell tell your code what it looks like
00:30:38 <scshunt> you can't do things like enumerate the constructors of Foo
00:30:44 <scshunt> Generic lets you do that
00:32:35 <kalkin-> hmm, ok. 
00:35:16 <scshunt> in your case, you would use that information to generate the XML serialization data
00:35:23 <scshunt> but you can use it for whatever
00:39:12 * hackagebot period 0.1.0.3 - Parse and format date periods, collapse and expand their text representations.  https://hackage.haskell.org/package/period-0.1.0.3 (alkar)
00:39:18 <kalkin-> in the Haskell Wiki in the link scshunt kindly provided, in the Complete Working Example part, we use the put method of the Serialize type class (specefied above) to serialize a Bool to a Bit right?
00:39:37 * kalkin- just trying to figure out if he is on the right track
01:20:31 <srhb> kalkin-: Well, a list of bits.
02:55:23 <zoug> hello, I'm trying to implement the ruler f'n in haskell and hence have a number, say 16, that could be written 2^4. I want to use the a in 2^a for all the numbers of the list, how could I do it? thanks
02:56:06 <zoug> so for 16 something that returns 4, for 128 something that returns 7, etc
02:58:11 <mniip> zoug, like a logarithm?
03:08:11 <MarcelineVQ> > map (logBase 2) [2,4,8,16,32,64,128] -- zoug, is this what you mean?
03:08:12 <lambdabot>  [1.0,2.0,3.0,4.0,5.0,6.0,7.0]
03:09:00 <MarcelineVQ> > map (2^) [1..7] -- Or did you mean generating them in the first place?
03:09:01 <lambdabot>  [2,4,8,16,32,64,128]
03:09:17 <zoug> exactly
03:09:28 <mniip> "A or B?" - "yes"
03:09:38 <suppi> I'm not sure how to use haddock to build documentation for a library, can anyone help?
03:09:51 <zoug> yeah a logarithm
03:10:01 <zoug> i'm bad at math.. :p
03:12:12 <mniip> > let f n | n `mod` 2 == 0 = f (n `div` 2) + 1; f n = 0 in map f [1..]
03:12:14 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1...
03:12:38 <suppi> whoever helps me will get a link to an illustration of haddock...
03:14:39 <bennofs> suppi: you want to build it so you can upload it to hackage?
03:14:51 <suppi> bennofs, no, I want to read it
03:15:14 <bennofs> suppi: oh, for a single library? How about cabal haddock ?
03:15:18 <suppi> yes
03:15:37 <bennofs> suppi: documentation should then be in dist/build/doc or dist/doc (don't remember atm)
03:15:43 <suppi> bennofs, yes! thank you :D
03:15:53 <suppi> bennofs, here's what I promised: https://upload.wikimedia.org/wikipedia/commons/e/e4/Melanogrammus_aeglefinus.jpg
03:16:08 <bennofs> :)
03:16:11 <suppi> :)
03:56:24 <jophish> Is Adam Gundry about?
03:58:16 <roelof> Hello, I have this challenge : Define a function to convert small letters to capitals which returns unchanged  characters which are not small letters. 
03:58:52 <roelof> do I understand it right that I have to change small letters to capital but if the letter is a capital do not change anything ? 
04:00:41 <bennofs> roelof: and also return characters which aren't letters at all unchanged (ex.: numbers, or some weird unicode smileys and other characters for which there is no "uppercase" or "lowercase")
04:02:43 <roelof> bennofs:  thanks. So I need guards or a if - then and a type definition of char -> char 
04:03:35 <bennofs> roelof: hmm, or just use Data.Char.toUpper :: Char -> Char, which does the right thing I believe (although I'm no unicode expert)
04:03:39 <bennofs> :t toUpper
04:03:40 <lambdabot> Char -> Char
04:03:44 <mettekou> Can anyone recommend one of the web frameworks (Happstack, Yesod, Spock, Scotty...) for building a simple REST API with Haskell? It does require authentication and authorization though.
04:03:46 <bennofs> > toUpper 'a'
04:03:47 <lambdabot>  'A'
04:03:48 <bennofs> > toUpper 'A'
04:03:49 <lambdabot>  'A'
04:08:27 <jophish> > toUpper '☃'
04:08:28 <lambdabot>  '\9731'
04:14:20 * hackagebot graphql 0.1 - GraphQL Haskell implementation  https://hackage.haskell.org/package/graphql-0.1 (jdnavarro)
04:21:18 <roelof>  Thanks all. I think I have enough to make this challenge 
04:22:02 <roelof> mettekou:  I also like to know that but then for a ecommerce site with authentication. But first learn Haskell 
05:05:02 <delYsid> \p -> \l -> do { cs <- filterM p l ; case cs of [] -> return Nothing; (x:xs) -> return $ Just x }
05:05:39 <delYsid> Is there a way to stop the filter as soon as it returns True?  I.e., avoid the unnecessary predicate calls?
05:08:44 <delYsid> The type of that function is (a -> IO Bool) -> [a] -> IO (Maybe a), iow, get the first element of the list that does not fail, else Nothing.
05:10:11 <ski> @let findM :: Monad m => (a -> m Bool) -> [a] -> m (Maybe a); findM p = foldr (\a cont -> p a >>= \b -> if b then return (Just a) else cont) (return Nothing)
05:10:12 <lambdabot>  Defined.
05:10:36 <ski> delYsid : not really
05:10:46 <RageYL> hi
05:11:03 <ski> @type find
05:11:05 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
05:11:08 <ski> lo RageYL
05:11:10 <RageYL> i do not understand why the following expression return False: let a = newIORef [] in do { b <- a; c <- a; return $ b == c }
05:11:40 <ski> you create two different reference cells, both initialized to `[]'
05:12:19 <ski> `a' is the identical action creating them, `b' and `c' are the two different reference cells (or, perhaps more properly, the locations of the cells)
05:12:39 <ski>   let a = newIORef [] in do { b <- a; c <- a; return $ b == c }
05:12:41 <ski> is equal to
05:12:41 <RageYL> ok so each time i do <- it create a new one
05:12:54 <ski>   do { b <- newIORef []; c <- newIORef []; return $ b == c }
05:13:03 <ski> (you can always replace equals by equals)
05:13:07 <ski> RageYL : yes
05:13:20 <RageYL> is it the same for all monad ?
05:13:34 <ski> (the `let a = newIORef [] in' is claiming that `a' is equal to `newIORef []', so you can replace one with the other in the scope of `a' there)
05:13:34 <RageYL> if i use either for example
05:13:49 <ski> there is no `newIORef' for the `Either exn' monad
05:14:11 <RageYL> let a = Right [] in do { b <- a; c <- a; return $ b == c }
05:14:20 <RageYL> it return True this time
05:14:28 <RageYL> so this behaviour is specific to ioref
05:14:33 <ski> `newIORef init' is "anti-idempotent". it never gives the same result twice
05:14:46 <RageYL> ok
05:15:02 <RageYL> thanks for your very clear explanations ;)
05:15:08 <ski> other actions, in `IO' or otherwise, may or may not be idempotent (always yielding the same result when executed more than once)
05:15:46 <ski> (by `act' being idempotent, i mean that `do x <- act; y <- act; return (x,y)' is the same as `do x <- act; return (x,x)')
05:16:16 <ski> in your second example, `Right []' is idempotent
05:16:35 <ski> this is because in `Either exn', `return = Right', and `return val' is always idempotent
05:17:04 <ski> RageYL : yes, particular to `newIORef'
05:17:16 <RageYL> ok
05:18:23 <RageYL> i read again the documentation, it doesn't seems to be written (or i missed it)
05:18:31 <ski> `newIORef' allocates a new/fresh location for a reference cell, each time
05:19:34 <brtmr> I am following this tutorial https://pbrisbin.com/posts/automated_unit_testing_in_haskell/ to add unit testing to my library. My problem is: i would like to test functions within a hidden module, which i therefore cant import into my tests - how do I test hidden modules? 
05:21:17 <ski> RageYL : i suppose it's implied by "new" in "Build a new `IORef'"
05:21:52 <RageYL> ok, i will know now :D 
05:28:32 <ski> jophish : agundry, iirc
05:51:55 <ReinH> brtmr: you can't.
05:52:33 <delYsid> ski: huh, thanks :-)
05:53:08 <ReinH> RageYL: in your Either example, you are comparing [] with []. In your IORef example, you are comparing an IORef with an IORef
05:54:24 * hackagebot unbound 0.4.4 - Generic support for programming with names and binders  https://hackage.haskell.org/package/unbound-0.4.4 (sweirich)
05:56:38 <delYsid> @:t findM
05:56:39 <lambdabot> Maybe you meant: wn v rc pl let id do bf @ ? .
05:57:42 <srhb> :t findM
05:57:43 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m (Maybe a)
05:57:46 <delYsid> @bf ++++[>++<-].
05:57:47 <lambdabot>  Done.
05:58:05 <delYsid> aha, tnx
06:19:25 * hackagebot graphviz 2999.18.0.1 - Bindings to Graphviz for graph visualisation.  https://hackage.haskell.org/package/graphviz-2999.18.0.1 (IvanMiljenovic)
06:24:11 <nawal_> Hi, newbie playing with TagSoup
06:24:26 <nawal_> I manage to get the bit to work in ghci, but not compile
06:24:28 <nawal_> http://pastebin.com/zVdxHHL9
06:25:00 <nawal_> Code that doesn't work: http://pastebin.com/Re9XyCmJ, error above in the other pastebin
06:32:39 <brtmr> ReinH: how unsatifying. Do I have to declare all my modules as exposed to test them?
06:36:25 <ReinH> Yes, since you need to import them in the test modules
06:37:52 <AndChat107604> hello
06:39:24 <cchalmers> brtmr: You could have a CPP flag to export internals from exposed module's like containers does: https://github.com/haskell/containers/blob/32df5aa4bc89111d2baf912df742df7324889920/Data/Set.hs#L52-L56
06:43:22 <setser> How I can realize heap in Haskell?
06:43:54 <setser> What differencies between C++ and Haskell realizations?
06:44:11 <erisco> like, g++ vs ghc?
06:44:50 <ReinH> What do you mean by "realize heap"?
06:46:54 <setser> I'm learning some basic algorithms
06:47:06 <setser> Now i'm learning heaps
06:47:29 <setser> And i try to make heap on Haskell
06:47:42 <erisco> I don't think heap is a good functional data structure
06:48:15 <setser> And what can replace it&
06:48:18 <setser> ?
06:48:31 <ReinH> Okasaki has a heap
06:48:43 <erisco> yeah I am seeing that now
06:48:48 <erisco> trying to find what it is backed with
06:49:04 <erisco> heaps are often backed with arrays which would make them a poor choice
06:49:27 <ReinH> @google brodal-okasaki heap haskell
06:49:29 <lambdabot> https://hackage.haskell.org/package/heaps
06:49:49 <ReinH> based on http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.48.973
06:50:03 <setser> Thanks
06:50:18 <erisco> probably a tree something something
06:50:28 <ReinH> Ah, another one of edwardk's
06:50:38 <ReinH> So probably not made with poor choices ;)
06:51:33 <erisco> tis a tree
06:51:53 <ReinH> yep
06:52:57 <setser> And is there a functional way to make a cartesian tree&
06:53:00 <setser> ?
06:53:44 <ReinH> yes
06:54:13 <setser> OK, thanks
06:57:13 <ashl> hi
06:57:17 <ashl> how do you pronounce <*>
06:57:21 <ashl> in the sense of applicative
06:57:24 <srhb> ap, usually
06:57:37 <ashl> okay, that's what i thought, thanks
06:57:49 <julianleviston> if I write data Hello = Hello { }  what does that mean?
06:57:50 <ReinH> map and ap
06:57:53 <erisco> <*> and ap are homophones
06:58:08 <ashl> ta
06:58:19 <srhb> julianleviston: data Hello = Hello
06:58:24 <erisco> julianleviston, that means you can construct a value of type Hello with the Hello data constructor
06:58:31 <julianleviston> srhb: no, data Hello = Hello { }
06:58:38 <srhb> julianleviston: Yes, they are equivalent.
06:58:42 <ReinH> julianleviston: which means data Hello = Hello
06:58:44 <julianleviston> what does { } mean though?
06:58:47 <srhb> Nothing
06:58:56 <Hafydd> { } would usually contain field names.
06:58:58 <srhb> record syntax with no fields = no record syntax
06:59:02 <ReinH> an empth list if fields
06:59:06 <ReinH> *of
06:59:07 <Hafydd> But in this case it contains the empty set of fields.
06:59:08 <julianleviston> record syntax with no fields. Ok. That was what I thought.
06:59:21 <julianleviston> so it means “we might put some fields in here later” cool :)
06:59:25 <srhb> Err... not really.
06:59:32 <ReinH> no, it means "we wasted some characters for no reason"
06:59:35 <srhb> It means exactly the same as data Hello = Hello as stated before
06:59:38 <srhb> What ReinH said.
06:59:50 <julianleviston> I disagree, but that’s fine.
07:00:03 <ReinH> if you want to add fields, you can add { }
07:00:06 <srhb> Well, in that case data Hello = Hello means "we might put some fields in here later" too :P
07:00:16 <julianleviston> (only because in the case I’m reading it, the author HAS left them blank on purpose, indicating tey’ll be filled in later)
07:00:28 <ReinH> you also might not want to name them, in which case the  { } have to be removed
07:00:32 <srhb> OK, I suppose we're talking pedagogy instead of Haskell now :)
07:01:12 <julianleviston> Thanks!
07:01:30 <erisco> data Hello = Hello -- TODO: add fields
07:01:32 <delYsid> :t \p l -> listToMaybe `liftM` filterM p l
07:01:34 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m (Maybe a)
07:01:46 <julianleviston> erisco: yes yes, thanks :) 
07:01:58 <julianleviston> so in Snap, what does “b” and “v” mean here? data SnapletInit b v
07:02:19 <delYsid> ski: ^^
07:02:26 <julianleviston> This is the definition: newtype SnapletInit b v = SnapletInit (Initializer b v (Snaplet v))
07:02:38 <julianleviston> I’m having trouble parsing that sentence!
07:02:40 <ReinH> they are type variables
07:02:48 <julianleviston> Yep. Got that.
07:02:53 <ReinH> So that's what they mean.
07:02:56 <julianleviston> thansk
07:03:16 <julianleviston> does what does SnapletInit mean though?
07:03:42 <setser> q
07:03:45 <setser> sorry
07:03:50 <julianleviston> like… if I said SnapletInit Int String does that translate to SnapletInit (Initializer Int String (Snaplet Int)) ?
07:04:22 <ReinH> That's where the types would go, but you are mixing up type and value level expressions
07:04:26 <julianleviston> I am.
07:04:49 <julianleviston> How would I use it? like SnapletInit x  where x is an initaliser?
07:04:57 <srhb> julianleviston: But yes, it does mean that the argument to the SnapletInit value constructor has type Initializer Int String (Snaplet Int)
07:05:10 <julianleviston> ah ok
07:05:11 <ReinH> You would pass it x where x is an Initializer b v (Snaplet v)
07:05:17 <julianleviston> right.
07:05:53 <srhb> julianleviston: You could write it as SnapletInit :: Initializer b v (Snaplet v) -> SnapletInit b v
07:06:10 <ReinH> or indeed that's the type of SnapletInit
07:06:17 <srhb> Yes. :)
07:06:33 <ReinH> a/or/and
07:06:39 <julianleviston> wow I’m really confused now
07:06:39 <ReinH> s/a/s
07:06:48 <srhb> julianleviston: Mentally rename them then
07:07:09 <srhb> SnapletInitValueConstructor :: Initializer b v (Snaplet v) -> SnapletInitType
07:07:21 <ReinH> SnapletInit takes an Initializer b c (Snaplet v) and provides a SnapletInit b v
07:07:24 <julianleviston> that’s so confusing
07:07:38 <julianleviston> but how do you know what b c v are?
07:07:42 <srhb> I don't.
07:07:48 <srhb> You pick them. :)
07:07:49 <julianleviston> not you
07:07:50 <julianleviston> one.
07:08:05 <julianleviston> I’m having trouble translating this to my actual code.
07:08:22 <julianleviston> nevermind I’ll go back to the concrete.
07:08:27 <ReinH> One doesn't pick them. You do. ;)
07:08:38 <julianleviston> One means “anyone”. Me in this case.
07:08:49 <ReinH> Then one knows because one picks them. :p
07:09:00 <julianleviston> Sure.
07:09:02 <julianleviston> Except I’m not.
07:09:06 <srhb> Well, you can't determine it from nothing. The type of the Initializer determines the type of the SnapletInit.
07:09:07 <julianleviston> because I don’t know what to put there
07:09:21 <srhb> The type of the lens in the initalizer determines the type of the Initalizer.
07:09:22 <julianleviston> it seems to rely on other things  - not sure where they’re specified.
07:09:28 <srhb> The type of your Snaplet determines the type of your lenses.
07:09:30 <srhb> etc.
07:09:32 <srhb> Turtles all the way down.
07:09:36 <ReinH> well, you need to construct an Initializer
07:09:40 <julianleviston> yeah
07:09:41 <srhb> (Until we hit your choice :-))
07:09:43 <ReinH> so look for ways to do that
07:09:46 <julianleviston> I’m doing that 
07:09:56 <julianleviston> my code works. It’s very simple. I’m just trying to understand it.
07:09:57 <julianleviston> :)
07:10:13 <ReinH> if you have an in itializer x, SnapletInit x gives you a SnapletInit value
07:10:24 <julianleviston> Well I have this helloWorldInit :: SnapletInit HelloWorld HelloWorld
07:10:41 <ReinH> SnapletInit takes a single argument
07:10:42 <julianleviston> helloWorldInit = makeSnaplet "helloWorld” …
07:10:53 <ReinH> what is the type of makeSnaplet?
07:11:17 <ReinH> Isn't there documentation for this?
07:11:34 <julianleviston> there is
07:12:11 <julianleviston> makeSnaplet :: Text -> Text -> Maybe (IO FilePath) -> Initializer b v v -> SnapletInit b v
07:12:35 <ReinH> makeSnaplet gives you a SnapletInit value.
07:12:43 <ReinH> you don't need to use SnapletInit on the result
07:12:45 <erisco> some type
07:12:51 <julianleviston> This is my code 
07:12:52 <julianleviston> http://pastie.org/10414454
07:13:01 <delYsid> :let findM :: Monad m => (a -> m Bool) -> [a] -> m (Maybe a); findM p l = listToMaybe `liftM` filterM p l
07:13:12 <ReinH> If you're fully applying makeSnaplet, you already have a SnapletInit value
07:13:14 <delYsid> @let findM :: Monad m => (a -> m Bool) -> [a] -> m (Maybe a); findM p l = listToMaybe `liftM` filterM p l
07:13:16 <lambdabot>  .L.hs:148:1:
07:13:16 <lambdabot>      Duplicate type signatures for ‘findM’
07:13:16 <lambdabot>      at .L.hs:146:1-5
07:13:32 <delYsid> ah, redef
07:13:34 <julianleviston> ReinH: I’m having trouble understanding what you mean
07:14:43 <delYsid> @let findM' :: Monad m => (a -> m Bool) -> [a] -> m (Maybe a); findM' p l = listToMaybe `liftM` filterM p l
07:14:44 <lambdabot>  Defined.
07:15:09 <julianleviston> I’m not sure why the type of helloWorldInit is SnapletInit HelloWorld HelloWorld, and I don’t really understand what that type even means?
07:15:17 <srhb> delYsid: You can talk privately to lambdabot if you don't mean to show us things :)
07:15:41 <delYsid> srhb: sorry for the noise.
07:15:47 <srhb> delYsid: No worries :)
07:16:17 <ReinH> julianleviston: it's SnapletInit HelloWorld HelloWorld because you provided a value of type Initializer HelloWorld HelloWorld HelloWorld
07:16:23 <ReinH> so b and v are both HelloWorld
07:16:32 <julianleviston> like… the type SnapletInit takes b and v but what do b and v represent, to snap? Like… I’m led to believe that one of them is the application state, and the other is the snaplet state… but it doesn’t appear anywhere in the docs
07:16:53 <delYsid> Its really amazing that the bot actually remembers definitions.  I can imagine rather interesting group sessions based on that feature :-)
07:17:02 <ReinH> Dunno.
07:17:12 <ReinH> delYsid: We need to clear them sometimes
07:17:14 <ReinH> :t succ
07:17:15 <lambdabot> Enum a => a -> a
07:17:22 <ReinH> Earlier, someone had redefined succ
07:17:33 <ReinH> what was annoying
07:17:36 <ReinH> *which
07:17:52 <Hafydd> Some good Group Action goes on in #haskell.
07:17:55 <delYsid> ReinH: I can imagine a reboot is nice from time to times, didnt think redef were even possible.
07:18:07 <ReinH> Hafydd: personally I prefer monoid actions
07:18:21 <julianleviston> ReinH: but what does SnapletInit HelloWorld HelloWorld mean?
07:18:22 <Hafydd> Each to their own.
07:18:33 <ReinH> delYsid: well, it doesn't "redef" actually, it introduces a new definition in the module L, the module lambdabot namespaces everything in
07:18:39 <ReinH> which conflicts with Prelude.succ
07:18:40 <julianleviston> ReinH: it’s kinda werid to me, because I’m just trying to get a basic grap of snaplet creation… 
07:18:47 <AleXoundOS> Hi. Do Haskell programmers often use ghci in order to test parts of code?
07:18:48 <julianleviston> grasp*
07:18:53 <ReinH> AleXoundOS: yes
07:19:04 <ReinH> julianleviston: dunno, I don't use snap
07:19:13 <julianleviston> ReinH: ok, thanks.
07:19:29 <delYsid> AleXoundOS: liekly.
07:19:51 <julianleviston> ReinH: I actually have this trouble generally with haskell documentation - it seems really hard to know what’s what from reading the docs.
07:19:59 <srhb> julianleviston: iirc the b decides which snaplet it can be nested or embedded in.
07:20:00 <ReinH> Hafydd: diff lists are constructed from monoid actions ;)
07:20:09 <srhb> julianleviston: Well, it's not that important. :)
07:20:11 <ReinH> Hafydd: generally, mappend m is a monoid action ;)
07:20:17 <julianleviston> srhb: where would I find that out?
07:20:53 <srhb> julianleviston: By reading all the source or asking someone knowledgable. or you can try embedding something with an initalizer with b ~ HelloWorld and decipher the type error :)
07:20:59 <AleXoundOS> ReinH, delYsid: So it's not only used for learning purposes and has effective usage in hands of experienced programmers?
07:21:10 <srhb> julianleviston: It's a very internal thing.
07:21:55 <erisco> AleXoundOS, I develop Haskell interactively with ghci, I always have it open and am running things, type checking things
07:22:18 <julianleviston> srhb: it’s incredibly badly documented.
07:22:23 <julianleviston> srhb: the source...
07:22:30 <srhb> julianleviston: Why do you need to know this?
07:22:41 <srhb> julianleviston: Are you going to hack on Snap?
07:22:53 <julianleviston> srhb: I’m just trying to make a Snap application
07:23:04 <srhb> I don't understand why you need this information then.
07:23:07 <ReinH> julianleviston: then why are you reading the source?
07:23:26 <julianleviston> ReinH: because it’s about the only way to work out what to pass certain type constructors
07:23:33 <srhb> It's not.
07:23:40 <ReinH> Eh?
07:23:41 <srhb> Type inference should take care of it for you :)
07:23:51 <julianleviston> srhb: ok… how do I know what to pass SnapletInit then?
07:23:57 <ReinH> Snap has an entire site with documentation, examples, tutorials http://snapframework.com/
07:24:09 <julianleviston> ReinH: yeah, it has 3 tutorials on it, and one vide
07:24:11 <julianleviston> video*
07:24:13 <ReinH> You don't pass anything to SnapletInit
07:24:32 <julianleviston> ReinH: I mean here: helloWorldInit :: SnapletInit HelloWorld HelloWorld
07:24:38 <ReinH> ...
07:24:54 <julianleviston> How am I supposed to know what to put in those places?  (where I currently have HelloWorld)
07:25:12 <srhb> julianleviston: What is the type of makeSnaplet "" "" Nothing $ return HelloWorld ?
07:25:29 <julianleviston> srhb: I have no idea
07:25:35 <srhb> julianleviston: Ask your friendly compiler then :)
07:25:49 <julianleviston> srhb: why?
07:25:57 <julianleviston> srhb: oh type inference
07:25:59 <srhb> Because that's one of the huge points of using Haskell
07:26:01 <srhb> Yes
07:26:21 <julianleviston> s it says SnapletInit b HelloWorld
07:26:24 <srhb> Yep.
07:26:31 <srhb> So now you know, if you want to annotate it.
07:26:38 <srhb> No need for trawling through sources.
07:26:41 <julianleviston> srhb: but what is b?
07:26:45 <julianleviston> that’s not a concrete type
07:26:47 <srhb> It's b
07:26:49 <srhb> No
07:26:53 <julianleviston> erm
07:26:57 <ReinH> Why are you even creating a snaplet initializer?
07:27:06 <julianleviston> that means I’m still using type inference, and I don’t actually know what the type is, doesn’t it?
07:27:13 <julianleviston> ReinH: to make a snaplet.
07:27:15 <srhb> julianleviston: The type is polymorphic
07:27:22 <ReinH> Why are you creating a snaplet?
07:27:39 <julianleviston> ReinH: to learn how to create snaplets so I can build the website I want to build
07:28:07 <julianleviston> ReinH: web app*
07:28:12 <srhb> ReinH: It's quite normal to have a Snaplet be the "root of your application" and then serve that :)
07:28:24 <srhb> Embedding other snaplets as needed.
07:28:46 <ReinH> srhb: Sure, but I wasn't sure if they specifically wanted that functionality, or were confused about whether it was necessary just to write an app
07:28:50 <julianleviston> It’s so I can mount routes.
07:28:53 <ReinH> julianleviston: Did you read the snaplet tutorial?
07:28:58 <srhb> julianleviston: But it seems to me that you think you somehow need to pick a specific type rather than let b be polymorphic. That is not necessarily true.
07:29:08 <julianleviston> ReinH: Yeah, I’ve read both of them, and watched the video
07:29:12 <srhb> And if it does become true, you will get a type error
07:29:15 <srhb> And then you can fix it.
07:29:15 <julianleviston> ReinH: but a lot of it gives me questions
07:29:29 <julianleviston> srhb: I don’t really understand how that makes sense, actually
07:29:37 <ReinH> Then I don't understand how you're stuck on something the snaplet tutorial covers in the first example
07:29:44 <srhb> julianleviston: Do you think that id :: a -> a is weird?
07:30:05 <julianleviston> ReinH:  because I want to understand what it means, not just be able to monkey-see monkey-do what they show me.
07:30:30 <julianleviston> ReinH: otherwise, how can I change it to do what I want it to do? I’m trying to understand this very simple thing at quite a deep level so I can work with it.
07:30:38 <julianleviston> srhb: no
07:30:48 <srhb> Learning by doing isn't dumb at all. If you happen to constrain the b, you will get a type error AND a feeling for why it has to be constrained to some specific type.
07:30:53 <julianleviston> srhb: it’s just a polymorphic function
07:31:01 <srhb> julianleviston: Then I don't understand why this confuses you. :)
07:31:18 <julianleviston> srhb: because It’s not what the tutorial video has done
07:31:31 <julianleviston> srhb: and I want to know why he’s doing it the way he’s doing it (Ryan Trinkle)
07:31:42 <julianleviston> and how both of them can reconcile - therefore what’s going on
07:31:57 <julianleviston> if that makes sense?
07:32:13 <srhb> OK, I can't answer why some person does something. :) But I really would just go ahead with the inferred types and you'll see when it happens that b must be a specific type.
07:32:46 <srhb> julianleviston: (Hint: runSnaplet)
07:32:48 <julianleviston> srhb: damn… coz that’s the educational material from the site.
07:33:13 <ReinH> Have you tried to run your code?
07:33:19 <julianleviston> ReinH: of course.
07:33:24 <ReinH> And?
07:33:30 <julianleviston> ReinH: works fine
07:33:33 <ReinH> Ok...
07:33:41 <julianleviston> ReinH: you might misunderstand me. I want to understand how it works… 
07:33:45 <julianleviston> ReinH: which I don't.
07:33:51 <srhb> Not if you have runSnaplet yourSnaplet and it has an initalizer with a polymorphic b it doesn't
07:33:55 <julianleviston> srhb: I know how to make it do what I want to do… at least… to show a route with hello world printing… I’ve done that in a later version.
07:34:10 <srhb> julianleviston: I'm trying to tell you how you will come to the realization that Haskell will show you what it means.
07:34:15 <julianleviston> srhb: ahhhh ok
07:34:20 <julianleviston> srhb: thanks let me go do that
07:34:23 <srhb> Good. :)
07:34:30 <ReinH> You're using return to construct an Initializer. Do you know what return does for the Initializer b v monad?
07:34:32 <julianleviston> srhb: sorry it took me so long
07:35:01 <julianleviston> ReinH: hang one sec - that’s intermediate code that I showed you. It’s not the “final” version. I’ll show you that then you can be satisfied I can make it work.
07:35:53 <julianleviston> ReinH: http://lpaste.net/140741
07:37:25 <julianleviston> srhb: ok got the error from SnapletInit b HelloWorld
07:37:42 <julianleviston> srhb: couldn’t match type ‘b’ with ‘HelloWorld’
07:37:55 <srhb> julianleviston: Yep. Look at the type of runSnaplet
07:38:15 <julianleviston> srhb: in the docs?
07:38:21 <srhb> julianleviston: Or in ghci, whichever.
07:38:38 <julianleviston> ok
07:38:50 <julianleviston> Maybe String -> SnapletInit b b -> IO (Data.Text.Internal.Text, Snap (), IO ())
07:38:52 <ddrone> Hi, does anyone know how to prevent haddock from stripping hash signs from code blocks?
07:38:52 <ReinH> well, ghc has inferred that the type is SnapletInit HelloWorld HelloWorld
07:39:26 <julianleviston> ReinH: sure… however this doesn’t explain what the HelloWorld are supposed to be, right?
07:39:42 <julianleviston> ReinH: in other words, where can I find out what the function is supposed to take, symantically?
07:39:50 <julianleviston> ReinH: it tells me the types just fine.
07:40:09 <julianleviston> but types aren’t meanings
07:40:38 <srhb> julianleviston: Well you have just learned that you can only run a snaplet if b ~ v
07:41:07 <julianleviston> srhb: srhb yes, but I’m not interested in getting it working. I know how to do that.
07:41:17 <julianleviston> srhb: I’m interested in knowing what it means. what’s going on.
07:41:22 <julianleviston> srhb: right?
07:41:30 <julianleviston> srhb: do you understand?
07:41:38 <julianleviston> srhb: sorry if I’m not explaining myself well enough.
07:42:59 <srhb> julianleviston: It's just ensuring that you're using the snaplet api correctly. If you want to know WHY it works like this, and why the types force you to do it directly, you're basically saying "I want to hack on Snap" -- not "I want to learn to be a Snap user"
07:43:45 <srhb> Which is fine, of course, but claiming that you NEED to know this to make snaplets and snap websites is emphatically untrue.
07:43:48 <julianleviston> srhb: I disagree… if I want to do something beyond a trivial example, I need to understand how it works. 
07:43:57 <srhb> How do you know that?
07:44:00 <geekosaur> ...and you probably need to talk to the Snap developers, since it's not like they're following a natural law; they designed it, they understand the design
07:44:23 <srhb> julianleviston: You're claiming that you need to know this to develop in Snap, but why do you think so?
07:46:19 <julianleviston> srhb: because I like to understand what I’m doing.
07:46:43 <julianleviston> srhb: I really don’t like the “just do this, because that’s what you do” way of doing things.
07:46:55 <srhb> Yeah, but that's entirely different from needing it to develop with it. You usually don't need to know internals to use something. Do you know how Data.Map works is different from Do you know how to use Data.Map
07:47:16 <julianleviston> srhb: but I’m not talking about the internals
07:47:25 <srhb> Yes, you are.
07:47:27 <julianleviston> I’m talking about the exposed API
07:47:29 <julianleviston> no way
07:47:41 <julianleviston> If i see this: helloWorldInit :: SnapletInit HelloWorld HelloWorld
07:47:43 <julianleviston> in my code
07:47:47 <julianleviston> that I have to write
07:47:53 <julianleviston> then I’d like to know what it means
07:47:53 <srhb> You don't have to write it.
07:48:07 <julianleviston> srhb: how not?
07:48:10 <srhb> Type inference.
07:48:20 <srhb> You can't use it wrong. The internals of how b and v relate ensure this.
07:48:20 <julianleviston> seriously?
07:49:01 <julianleviston> what is the fourth argument to makeSnaplet? it’s some kind of thing called a SnapletInit b v - I have no idea what that means
07:49:26 <julianleviston> but Ryan Trinkle’s video shows that you can put a do block there… 
07:49:36 <julianleviston> and that addRoutes can be “run” in it
07:49:45 <julianleviston> so I now know that because it’s in the video...
07:49:52 <julianleviston> but how am I supposed to know what it means otherwise?
07:50:20 <julianleviston> how can I know what addRoutes is doing? or are you saying I don’t need to know what it’s doing, I can just accept it’s magic and continue on my way?
07:50:21 <slack1256> julianleviston: the types help to refactoring and as a reference of an API, you are right that don't help much when you are learning a library
07:50:31 <julianleviston> slack1256: thank you
07:50:38 <julianleviston> slack1256: feel like I’m taking crazy pills
07:50:46 <slack1256> specially when you don't know what a specific type class is supposed to do
07:51:04 <srhb> julianleviston: I don't think I can giver you a better answer. You can't use it wrong, SnapletInit is there to make sure the user doesn't fuck up, and that's about it. :) If you want to know more besides the stuff about parent snaplets that I already said, you will have to read the source and ask the developers, because it really, really is internals.
07:51:06 <slack1256> julianleviston: is not that crazy argument, everybody thought of it with ... lens
07:51:08 <xikuuky> Hey guys! :D
07:51:16 <srhb> julianleviston: But good luck :)
07:51:24 <julianleviston> srhb: thanks for your help!
07:51:27 <srhb> julianleviston: By the way, there's #snap for specifics.
07:51:57 <julianleviston> srhb: oh? really? you mean snapframework I think… last time I went in there it was dead
07:52:15 <srhb> julianleviston: You're right, I forgot I aliased it to something shorter.
07:52:23 <julianleviston> If I compare this with SmallTalk or Clojure or Ruby, they have an extremely large amount of documentation around their APIs… in Clojure it’s actually IN the language… you can query a function for its docstring. God I wish Haskell had that...
07:52:29 <srhb> julianleviston: And the devs usually answer, even if they aren't there right when you ask the question.
07:52:33 <julianleviston> sweet
07:52:52 <julianleviston> That’d be awesome because I’m actually trying to write a tutorial as well...
07:56:37 <julianleviston> srhb: thanks for your help
07:56:40 <julianleviston> ReinH: you too!
07:57:00 <ReinH> julianleviston: I wasn't much help but you're welcome
07:57:27 <srhb> julianleviston: You're welcome. By the way, your question in there looks like you missed my answer: the b is the parent Snaplet and v is the current Snaplet
07:57:38 <srhb> julianleviston: I think you mean to ask "why is this not documented"
07:57:39 <julianleviston> srhb: cool - which is which?
07:57:45 <srhb> Huh?
07:57:58 <julianleviston> srhb: is the left the parent? or is it the right?
07:58:01 <srhb> SnapletInit b v
07:58:05 <srhb> b is parent
07:58:11 <julianleviston> b is parent ok cool
07:58:14 <srhb> or "base"
07:58:16 <srhb> for a mnemonic
07:58:17 <julianleviston> haha why did they choose b and v? lol
07:58:19 <julianleviston> Ahhhh
07:58:26 <julianleviston> and v for “VERY ANNOYING” lol j/k
07:58:28 <julianleviston> ReinH:  :) yeah, I was interested also in how 
07:58:45 <julianleviston> ReinH: … a legit pro haskeller deconstructs and understands a library 
07:59:08 <julianleviston> ReinH: sadly, the answer seems to be “with painnnn” :)
07:59:37 <ReinH> julianleviston: often like this https://s-media-cache-ak0.pinimg.com/736x/a7/26/97/a72697a095886df3ba2ae96fe8ee1385.jpg
07:59:48 <julianleviston> ReinH: lol luv it
08:00:20 <julianleviston> Best typesignature ever: runSnap :: Snap a -> (ByteString -> IO ()) -> ((Int -> Int) -> IO ()) -> Request -> Iteratee ByteString IO (Request, Response)
08:09:09 <julianleviston> I guess the thing I’m really not getting, though… is… if there’s this type newtype SnapletInit b v = SnapletInit (Initializer b v (Snaplet v))
08:09:19 <julianleviston> … and then I say this: helloWorldInit :: SnapletInit HelloWorld HelloWorld
08:09:23 <julianleviston> … then how does that work?
08:09:35 <srhb> What, type unification?
08:09:40 <julianleviston> I thought that newtype specified that the only way to construct values was by using the type constructor…
08:09:48 <nawal_> Hi, newbie playing with TagSoup, I manage to get this to work in ghci: http://pastebin.com/zVdxHHL9, but it won't compile: http://pastebin.com/Re9XyCmJ
08:09:59 <julianleviston> Sorry, the only way to construct TYPES, (not values)
08:09:59 <srhb> julianleviston: Yes, and makeSnaplet does that internally.
08:10:04 <srhb> Huh, no.
08:10:06 <julianleviston> aha!
08:10:06 <srhb> values.
08:10:11 <julianleviston> yeah, ok cool
08:10:24 <julianleviston> ahhhh
08:10:34 <julianleviston> I’m a dunce.
08:10:59 <julianleviston> so the thing on the left of newtype SnapletInit b v matches to the thing on the right of helloWorldInit ::
08:11:01 <julianleviston> GOTCHA
08:11:39 <julianleviston> now it makes sense. I really should have known that all along… but it’s seeing it in practice that’s so vastly different than reading 10 books of theory.
08:11:57 <srhb> julianleviston: Well yes, the left hand side of data decls is the type
08:13:11 <julianleviston> srhb: which is obvious if I type :t makeSnaplet into GHCI lol
08:13:12 <julianleviston> silly me
08:13:17 <srhb> :)
08:13:23 <julianleviston> it creates values of :: SnapletInit b v
08:13:24 <julianleviston> duh.
08:13:29 <srhb> Indeed.
08:21:00 <julianleviston> god this language is amazing
08:30:15 <drewbert> what is the de facto program arguments library?
08:30:30 <srhb> optparse-applicative ?
08:30:40 <srhb> I don't know if it's de facto, but it's really nice.
08:31:00 <julianleviston> with Lenses, what does s t a b stand for?
08:31:13 <drewbert> stab
08:32:11 <slack1256> s source t (to) a b
08:32:30 <slack1256> usually (f a) (f b) a b
08:32:42 <slack1256> is more like a fmap without higher types
08:32:43 <julianleviston> ahhh
08:32:47 <julianleviston> cool :) thanks
08:32:58 <slack1256> (I did struggle with that for like a day)
08:33:03 <julianleviston> lol
08:33:20 <julianleviston> sorry - wasn’t laughing at your misfortune. Was our misfortune.
08:33:29 <slack1256> hahah no worries, it is funny
08:33:52 <julianleviston> every time I see it, I think “STABBY STABBY!”
08:33:57 <slack1256> Traversals do the same "trick" just replace the s with (f a) and t with (f b)
08:34:41 <slack1256> yes, there was also an anecdote when the type variables started to describe a malevolous statements
08:34:49 <geekosaur> julianleviston, you missed when ekmett considered something with "i m a s t a b u"
08:34:53 <slack1256> something like i m a s t a b
08:34:56 <julianleviston> lol
08:35:23 <julianleviston> geekosaur: speaking of which sorry for OT, but seriously apply, y u no ipad maxi? (here = tampon)
08:35:32 <julianleviston> apple*
08:42:34 <hardmath123> Does Haskell's pattern-matching engine try patterns in order from the first one defined, or does it go with the most specific one like ML?
08:42:57 <julianleviston> hardmath123: I think it usually does general first to specific.
08:43:13 <julianleviston> usually first tho.
08:43:19 <julianleviston> but hey I’m a noob.
08:46:27 <silver> hardmath123, in order of definition
08:48:25 <hardmath123> thanks silver 
08:54:22 <elperdut> i am loving this - http://slpopejoy.github.io/posts/Effectful01.html
08:54:55 <IP92> hey, can anyone tell me how to produce cartesian product of 2 lists, that might be infinite, so that elements from both lists would be used?
08:55:14 <elperdut> weekend readings while baby is asleep and wife is away. apologies for being sappy.
08:58:43 <suppi> IP92, do you mean all the possible pairs from both lists?
08:59:00 <IP92> suppi: yes
08:59:44 <IP92> [1..] [1..] should result in (1,1), (1,2), (2,1), (2,2), (2,3), etc
08:59:53 <IP92> or something of the like
08:59:58 <fvgvxmpv1> "cantor diagonal"
09:00:08 <suppi> https://en.wikipedia.org/wiki/Cantor's_diagonal_argument
09:00:11 <suppi> like this? :)
09:00:49 <suppi> I think i did not link to the right thing
09:01:16 <julianleviston> [(a,b)| a <- [1..], b <- [1..]]
09:01:47 <IP92> julianleviston: that will only produce (1,1), (1,2), (1,3) 
09:02:56 <mrkgnao> Does anyone here use spacemacs? (or emacs, more generally_
09:03:16 <julianleviston> IP92: you could wrtie merge
09:03:16 <julianleviston> http://stackoverflow.com/questions/3938438/merging-two-lists-in-haskell
09:03:21 <mrkgnao> I'm trying to set up a Haskell environment in emacs, using spacemacs.
09:03:28 <mrkgnao> Preferably with stack.
09:03:35 <suppi> I want to use spacemacs but had trouble setting it up :O
09:03:51 <jmcarthur> mrkgnao: i recently use spacemacs
09:04:24 <jmcarthur> mrkgnao: i think stack and spacemacs aren't playing very nicely. i intend to see what happens if i move all my stack infrastructure aside and try the haskell layer again
09:04:32 * hackagebot pg-harness-server 0.4.0 - REST service for creating temporary PostgreSQL databases  https://hackage.haskell.org/package/pg-harness-server-0.4.0 (BardurArantsson)
09:04:34 * hackagebot pg-harness-client 0.4.0 - Client library for pg-harness-server  https://hackage.haskell.org/package/pg-harness-client-0.4.0 (BardurArantsson)
09:04:41 <jmcarthur> mrkgnao: other than that, my adventures with spacemacs are going really smoothly and i'm loving it
09:05:04 <mrkgnao> So I'm trying to get the basic packages set up, and I did stack install stylish-haskell hlint ghc-mod hasktags and ran into . . . stack hell.
09:05:09 <mrkgnao> Do you use stack with emacs?
09:05:43 <jmcarthur> i do currently, but as i just said, it's not exactly working well. ghc-mod and interactive-haskell are both having different kinds of trouble relating to it
09:06:10 <mrkgnao> Does everything go fine if you use Cabal?
09:06:35 <mrkgnao> I don't mind doing that. I'm just here for structured-haskell-mode and autocompletion, I'll settle for whatever gets me that.
09:06:57 <jmcarthur> mrkgnao: as i just said, i *intend* to try just cabal, but haven't yet
09:07:06 <mrkgnao> Oh.
09:07:22 <AndChat107604> do anybody knows how to use open UDP port for free internet
09:07:24 <mrkgnao> Any ideas on how I can fix the stack problems?
09:07:49 <mrkgnao> All those version number mismatches everywhere.
09:08:03 <jmcarthur> mrkgnao: that sounds unrelated to emacs, right?
09:08:18 <jmcarthur> mrkgnao: could you put your errors on hpaste?
09:08:32 <mrkgnao> Sure.
09:08:34 <AndChat107604> how to use open UDP port for free internet on isp
09:08:42 <AndChat107604> plz tell me
09:09:02 <Voltz> Is there anything that gives Haskell some of those metavariables/auto case splitting tools like Idris?
09:09:21 <lpaste_> mrkgnao pasted “Stack errors, 12.9.15” at http://lpaste.net/6493397519647637504
09:09:51 <mrkgnao> There. ^
09:09:53 <AndChat107604> my problem bro
09:11:19 <AndChat107604> helo
09:11:36 <srhb> AndChat107604: Do you have a Haskell question? :)
09:11:43 <AndChat107604> no
09:11:49 <srhb> AndChat107604: This channel is for discussion of Haskell topics. :)
09:12:01 <jmcarthur> mrkgnao: it tells you what to do right there in the "Recommended action" section of that error message
09:12:04 <AndChat107604> where should I go yhen
09:12:11 <srhb> AndChat107604: I don't know. Not here. :)
09:12:17 <mrkgnao> I did that. 
09:12:22 <mrkgnao> Here's what that gave.
09:12:30 <julianleviston> Voltz: do you mean like this? https://ghc.haskell.org/trac/haskell-prime/wiki/PartialTypeAnnotations
09:12:37 <wedify> AndChat: you could look at chapter 27 of realworld haskell
09:13:06 <AndChat107604> what's that
09:13:15 <julianleviston> AndChat107604: it’ll help you open UDP sockets
09:13:28 <mrkgnao> http://lpaste.net/140743
09:13:35 <mrkgnao> That paste site is gorgeous.
09:13:45 <julianleviston> AndChat107604: you’ll probably have to learn a bit of haskell though :) http://book.realworldhaskell.org/read/sockets-and-syslog.html
09:14:02 <kadoban> mrkgnao: ghc-mod isn't in stackage, at least in lts-3, because it took /forever/ to get updated for GHC 7.10
09:14:15 <KaneTW> > let f n m = [(a,b) | a <- [n..m], b <- [1..m]] in [1..] >>= \x -> f x (x+1)
09:14:17 <lambdabot>  [(1,1),(1,2),(2,1),(2,2),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3),(3,1),(3,2),(3,...
09:14:25 <mrkgnao> . . . oh.
09:14:28 <kadoban> mrkgnao: So I think that's why you're getting that, lts-3.4 is the stackage resolver, you'll probably have to use the solver or something? I dunno.
09:14:35 <KaneTW> IP92: something like that might work
09:14:39 <Voltz> No, I mean like in this video : https://youtu.be/4i7KrG1Afbk?t=5m40s There's an idris mode for Emacs
09:14:51 <kadoban> mrkgnao: You could try doing what it says, add as extra deps
09:14:51 <mrkgnao> Yeah, it's installing fine without ghc-mod.
09:15:04 <IP92> what's the >>= symbol?
09:15:08 <Voltz> bind
09:15:12 <julianleviston> KaneTW: he wants the product, so :: [[a]] -> [a]
09:15:12 <Voltz> :t bind
09:15:13 <lambdabot>     Not in scope: ‘bind’
09:15:13 <lambdabot>     Perhaps you meant one of these:
09:15:13 <lambdabot>       ‘BS.find’ (imported from Data.ByteString),
09:15:15 <KaneTW> concatMap in this case
09:15:16 <mrkgnao> How'd I add ghc-mod as a dep?
09:15:18 <Voltz> whoops
09:15:22 <KaneTW> :t (>>=)
09:15:22 <Voltz> :t (>>=)
09:15:23 <mrkgnao> :t >>=
09:15:23 <lambdabot> Monad m => m a -> (a -> m b) -> m b
09:15:24 <lambdabot> Monad m => m a -> (a -> m b) -> m b
09:15:24 <KaneTW> :t concatMap
09:15:25 <lambdabot> parse error on input ‘>>=’
09:15:26 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
09:15:27 <julianleviston> Voltz: >>= ?
09:15:35 <Voltz> Yeah..
09:15:47 <kadoban> mrkgnao: Well, try what it says and see what happens? There'll probably be a few rounds of that
09:15:49 <julianleviston> KaneTW: is it lazy?
09:16:00 <KaneTW> it produces an infinite list, has to be
09:16:26 <KaneTW> > let f m = [(a,b) | a <- m, b <- [1..m]] in [1..] >>= \x -> f x 
09:16:27 <lambdabot>      No instance for (Show t0)
09:16:28 <lambdabot>        arising from a use of ‘show_M237359741762518169216315’
09:16:28 <lambdabot>      The type variable ‘t0’ is ambiguous
09:16:30 <julianleviston> KaneTW: unless it’s producing two at a time ;-)
09:16:38 <julianleviston> KaneTW: depends “*how*” lazy.
09:17:08 <KaneTW> > let f m = [(a,b) | a <- m, b <- [1..m]] :: [(Integer,Integer)] in [1..] >>= \x -> f x 
09:17:10 <lambdabot>      Couldn't match expected type ‘Integer’ with actual type ‘[Integer]’
09:17:10 <lambdabot>      In the expression: b
09:17:10 <lambdabot>      In the expression: (a, b)
09:17:22 <mrkgnao> kadoban: So here's what I did just now.
09:17:49 <KaneTW> > let f (m::Int) = [(a,b) | a <- m, b <- [1..m]] in [1..] >>= \x -> f x 
09:17:51 <lambdabot>      Couldn't match expected type ‘[t1]’ with actual type ‘Int’
09:17:51 <lambdabot>      Relevant bindings include
09:17:51 <lambdabot>        f :: Int -> [(t1, Int)] (bound at <interactive>:1:5)
09:17:54 <mrkgnao> In my global stack.yaml, I put cabal-helper-0.5.1.0 as an extra-dep.
09:17:56 <KaneTW> oh
09:17:58 <KaneTW> goddamn
09:18:10 <KaneTW> > let f m = [(m,b) | b <- [1..m]] in [1..] >>= \x -> f x 
09:18:12 <lambdabot>  [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(4,4),(5,1),(5,2),(5,...
09:18:24 <KaneTW> hm, now it's only doing the upper half
09:20:29 <julianleviston> KaneTW: how about this? (concat . transpose) [1..] [1..]
09:20:43 <julianleviston> > (concat . transpose) [1..] [1..]
09:20:45 <lambdabot>      Couldn't match expected type ‘[Integer] -> t’
09:20:45 <lambdabot>                  with actual type ‘[a0]’
09:20:45 <lambdabot>      The function ‘concat . transpose’ is applied to two arguments,
09:21:11 <KaneTW> :t transpose
09:21:12 <lambdabot> [[a]] -> [[a]]
09:21:13 <KaneTW> :t concat
09:21:14 <lambdabot> Foldable t => t [a] -> [a]
09:21:59 <_kartoffel_> Hi! I'm trying to use Ed Kmetts Control.Zipper package and strugglin'. Can anyone explain to me how one is supposed to store a current `Zipper' via `saveTape' into a state data structure? My problem is that the return type of safeTape varies depending on your current Zipper.
09:24:32 * hackagebot hset 2.0.0 - Primitive list with elements of unique types.  https://hackage.haskell.org/package/hset-2.0.0 (AlekseyUymanov)
09:29:39 <mrkgnao> okay, ghc-mod, stylish-haskell, hlint, and hasktags are installed!
09:30:37 <Voltz> I kind of think I should learn Emacs, Watching some screencasts, it seems to work well
09:31:04 <suppi> Voltz, I feel the same
09:31:10 <KaneTW> emacs is probably my favorite editor for haskell
09:31:24 <suppi> But I keep having trouble running and configuring spacemacs for Haskell
09:31:38 <Voltz> I like my modes though.. Maybe I'll give Evil Mode a chance if I ever figure out how to config Emacs.
09:32:08 <suppi> I have a hard time justifying not just running vim instead :O
09:32:27 <KaneTW> i use just plain haskell-mode and ghc-mod, although ghc-mod is totally optional
09:32:36 <KaneTW> https://ghc.haskell.org/trac/ghc/wiki/Emacs
09:32:56 <suppi> KaneTW, do you get type errors in emacs?
09:33:23 <KaneTW> you can get them automatically but i disabled that
09:33:38 <suppi> really? why?
09:33:54 <KaneTW> doesn't work too well imo when working on ghc
09:33:59 <KaneTW> or is a pain to set up properly at least
09:34:09 <suppi> :O
09:34:19 <KaneTW> i do use them when doing non-ghc stuff
09:34:35 <suppi> weird, I always use them in vim
09:34:44 <suppi> specifically for ghc stuff
09:34:48 <KaneTW> i always get a bunch of preprocessor errors
09:36:57 <mrkgnao> oh my god.
09:37:08 <mrkgnao> I just got autocomplete working accidentally.
09:37:14 <mrkgnao> by starting the interpreter.
09:37:19 <suppi> mrkgnao, how is it?
09:39:47 <mrkgnao> suppi: just a second.
09:40:05 <suppi> mrkgnao, would you mind submitting a solution here https://github.com/parsonsmatt/hasktuts/issues/8 once you managed to get spacemacs to work?
09:41:41 <mrkgnao> I definitely will.
09:43:47 <Hakim> hi guys, when i have a haskell code like this one.....size :: Num a => Hand -> a
09:43:47 <Hakim> size Empty            = 0
09:43:47 <Hakim> size (Add card hand)  = 1 + size hand
09:44:05 <Hakim> what does Add do..my tutor never defined it anywhere
09:44:47 <mrkgnao> Add is something like an "object", if you're familiar with that. :)
09:45:27 <mrkgnao> It basically represents a "sum" of a card and a hand.
09:45:28 <geekosaur> you sure it was not defined? is there not something: data Hand = ...
09:45:39 <geekosaur> and what is happening there is a pattern match
09:46:31 <Hakim> the purpose of the function is to give the number of cards in a hand....but i was expecting something like length or count
09:46:50 <Hakim> but rather i see the "Add" word....
09:47:00 <geekosaur> there isn't either defined for it. so a pattern match is being used to deconstruct the Hand
09:47:43 <geekosaur> data Hand = Empty | Add Card Hand
09:48:10 <geekosaur> Empty and Add are constructors for a Hand. in the case of Add, there is another Hand associated with it, as well as a Card
09:48:27 <suppi> mrkgnao, thank you!
09:48:43 <Hakim> i think am now starting to understand it pretty well
09:49:07 <Hakim> but this constructor, does it work like the constructors in procedural programming?
09:49:08 <geekosaur> to count these, we match against Empty (empty hand, count = 0) or (Add _ hand) (add 1 card to hand, plus the count of (size hand) (i.e. the rest of the hand)
09:49:37 <geekosaur> sort of, except procedural programs don';t generally do pattern matching like this
09:49:48 <geekosaur> when used like this, it's sometimes called a "destructor" instead
09:50:10 <geekosaur> because we're kinda using it backwards
09:50:13 <suppi> though not the same as a destructor in OO languages at all
09:50:17 <geekosaur> yes
09:50:32 <mrkgnao> ah, not working properly, suppi.
09:50:40 <suppi> mrkgnao, too bad :(
09:50:47 <Hakim> oke...i think am starting to get the picture...
09:51:07 <mrkgnao> for instance, renamed imports are supposed to be autocompleted properly.
09:51:18 <suppi> data Hand = Empty | Add Card Hand
09:51:35 <suppi> is like defining two ways to represent a value of type Hand
09:51:40 <lvh> That seems like an ... interesting ... definition of Hand
09:51:47 <suppi> one value is Empty
09:51:52 <mrkgnao> So it basically says: a Hand is either empty, or a card plus a Hand.
09:52:07 <suppi> Empty is a value of Hand
09:52:15 <lvh> I guess maybe if someone is convolutedly trying to build linked lists without building linked lists or something?
09:53:23 <Hakim> data Hand = Empty | Add Card Hand deriving (Eq, Show)...when am looking at a code like this one, i would translate it like....i am creating a custom data type called hand that can either be empty or contain a card onto a hand...
09:53:34 <Hakim> i dont know whether am even making sense out of it
09:53:39 <mrkgnao> you are :)
09:53:41 <suppi> and Add <Card> <Hand> is another value of Hand, which depends on <Card> and <Hand>
09:54:10 <suppi> Hakim, sounds pretty much it.
09:54:32 <mrkgnao> suppi, I'm trying to get it to work with Cabal now.
09:54:39 <mrkgnao> Hopefully it all works out.
09:54:52 <suppi> yes, good luck
09:54:58 <mrkgnao> I already smell Cabal hell brewing.
09:55:09 <mrkgnao> Any tips on dealing with version number problems?
09:56:06 <lpaste_> mrkgnao pasted “Cabal . . .” at http://lpaste.net/2137124247011590144
09:56:20 <mrkgnao> suppi, could you please take a look at that?
09:57:10 <suppi> mrkgnao, are you using sandboxes?
09:57:11 <mrkgnao> wait, I think I need happy.
09:57:16 <mrkgnao> nope.
09:57:21 <geekosaur> use -v to see what actually failed
09:57:34 <mrkgnao> I figured you don't have to for these "global" packages?
09:57:51 <suppi> I always use sandboxes :)
09:58:00 <mrkgnao> Ah, I installed happy and the installation is proceeding now.
09:58:12 <suppi> and just add the relevant .cabal-sandbox/bin to $PATH
09:58:14 <mrkgnao> Could you link me to a tut or something? I'm new.
09:58:19 <suppi> if their are global
09:58:21 <suppi> sure,
09:58:21 <geekosaur> yeh, cabal-install doesn't handle program dependencies
09:58:56 <suppi> mrkgnao, http://howistart.org/posts/haskell/1
09:59:46 <mrkgnao> does using sandboxes help a lot?
09:59:58 <mrkgnao> I mean, I guess it does.
10:00:30 <suppi> extremely
10:00:40 <mrkgnao> But what if I need to install some packages and they're incompatible?
10:00:45 <mrkgnao> How do I fix that?
10:01:15 <suppi> if they are different tools, install them on different sandboxes
10:01:33 <mrkgnao> oh.
10:01:33 <mrkgnao> oh.
10:01:37 <mrkgnao> interesting.
10:01:41 <suppi> that's what I do anyway.
10:02:07 <mrkgnao> so, say, one sandbox for hlint, another for hasktags, etc?
10:02:19 <mrkgnao> wow, I guess that would solve everything.
10:02:32 <mrkgnao> because there would be no sharing the same package.
10:02:42 <suppi> it will
10:02:52 <suppi> though you can install some in the same sandbox
10:03:56 <suppi> ➜  chip-8 git:(master) ✗ ls ~/code/haskell/cabaling/.cabal-sandbox/bin/
10:03:56 <suppi> HsColour        ghc-modi        hlint           json2yaml       stack           yaml2json
10:03:56 <suppi> cpphs           hasktags        hoogle          shake           stylish-haskell
10:04:05 <suppi> I have these installed in the same sandbox
10:04:34 <suppi> sometimes it works, sometimes it doesn't
10:05:07 <mrkgnao> suppi: "What does the package build?"
10:05:08 <suppi> if I'm trying to install and cabal says that something might break, I just use a different sandbox
10:05:28 <suppi> mrkgnao, I'm not sure I understand the question
10:05:30 <Hakim> help me understand whats going on...is it okay if i describe the flow of this function like...size of an empty is 0 by default and
10:05:44 <Hakim> size :: Num a => Hand -> a
10:05:44 <Hakim> size Empty            = 0
10:05:44 <Hakim> size (Add card hand)  = 1 + size hand
10:05:45 <mrkgnao> During cabal init, this comes up.
10:05:55 <mrkgnao> yup.
10:05:56 <Hakim> but i get confused on the last line
10:06:04 <geekosaur> Hakim, I tried to explain that earlier
10:06:16 <mrkgnao> so you remove cards one by one and add one to the size each time.
10:06:20 <Hakim> why would i want to figure out the size of a hand but yet add something to it instead
10:06:22 <geekosaur> a Hand is either Empty or Add card hand, where hand is some value of type Hand
10:06:33 <mrkgnao> suppi: that came up during cabal init in the sandbox
10:06:39 <geekosaur> so that matches the two possibilities. in the first the Hand is Empty, so the size is 0
10:06:46 <Hakim> sorry if am not getting it...coz its somehow confusing
10:07:04 <geekosaur> in the second, it is Add card hand, so the size is 1 for the card in the Hand plus the size of the remainder of the Hand
10:07:09 <suppi> mrkgnao, "cabal init" creates a cabal file for your project
10:07:13 <geekosaur> thsi is pattern matching
10:07:26 <geekosaur> let's try that as the compiler expands it
10:07:39 <mrkgnao> so "cabal sandbox init".
10:07:46 <suppi> mrkgnao, yes
10:07:46 <mrkgnao> I should've read your link first :P
10:07:50 <suppi> yes :)
10:07:59 <geekosaur> size hand = case hand of { Empty -> 0; Add card hand' -> 1 + size hand' }
10:08:09 <geekosaur> Hakim ^^
10:08:28 <mrkgnao> You do realise that my username is how Joyce spelt "meow" in Ulysses? "mrkgnao, yes" is soooo funny if you know that :P
10:08:41 <mrkgnao> That came across wrong, I think, sorry.
10:08:42 <geekosaur> when you are doing that, instead of writing the case you can just specify the patterns directly
10:08:57 <suppi> ?
10:09:00 <Hakim> ok geekosaur....i think your explanation is pretty much clearer
10:09:33 <mrkgnao> I think my earlier statement sounded a bit condescending, and I didn't mean to do that.
10:10:14 <mrkgnao> Anyway, James Joyce spelt "meow" as "mrkgnao" in Ulysses. When you said "mrkgnao, yes" a while back, I found it funny. That's all.
10:10:32 <suppi> heh
10:10:43 <suppi> I don't know what you're talking about, but alright
10:10:58 <mrkgnao> Ulysses is a novel.
10:11:24 <suppi> oh.
10:11:48 <mrkgnao> I sort of imagined you as being a cat on the internet saying "meow, yes". :P
10:12:04 <mrkgnao> Anyway, seems I have to run cabal update separately in each sandbox.
10:12:37 <mrkgnao> Why doesn't someone write some kind of auto-sandboxing tool?
10:12:51 <geekosaur> stack?
10:13:04 <mrkgnao> Stack gets cabal hell-ish problems too.
10:13:17 <mrkgnao> (I think)
10:14:06 <geekosaur> it will get them sometimes. the fundamental problem is ghc, not cabal or stack
10:14:32 <mrkgnao> ghc?
10:14:33 <monochrom> what is auto-sandboxing?
10:14:39 <mrkgnao> could you explain?
10:14:52 <suppi> mrkgnao, maybe I am :)
10:15:03 <mrkgnao> monochrom: I meant creating sandboxes to avoid version number conflicts.
10:15:22 <suppi> there is the beta "no-reinstall cabal"
10:15:30 <mrkgnao> Haha. I have definitely struck username gold here ;)
10:15:32 <suppi> which is supposed to solve cabal hell, I think.
10:15:43 <suppi> mrkgnao, yes ;)
10:16:07 <suppi> http://blog.ezyang.com/2015/08/help-us-beta-test-no-reinstall-cabal/
10:16:15 <monochrom> I think nix qualifies as auto-sandboxing, and some people here use it
10:16:20 <roelof> Hello, How can I take care that this is printed on several lines : onThreeLines s1 s2 s3 = s1 ++ "\n" ++ s2 ++ "\n" ++ s3 ++ "\n" 
10:16:56 <roelof> now the output is "line1\nline2\nLine3\n"
10:17:00 <maerwald> monochrom: yep and you can run nix in your home dir without actuall switching your distro
10:17:13 <suppi> roelof, did you write "print" or "putStrLn" ?
10:17:17 <roelof> I tried to use show but also no luck 
10:17:22 <MarcelineVQ> use putStr
10:17:47 <roelof> putStr s1 ++ "\n" ++ s2 ++ "\n" ++ s3 ++ "\n"   ???
10:17:57 <mitochon> what does '~' mean in haskell? e.g.     ~(a, _) <- runStateT m s
10:18:11 <geekosaur> mrkgnao, as an optimization, ghc exports part of your module source as part of a compiled library. this creates a hard dependency not only on a library version but on an exact binary build
10:18:25 <suppi> mitochon, I think it's for not evaluating the pattern match
10:18:33 <monochrom> mrkgnao: my http://www.vex.net/~trebla/haskell/sicp.xhtml#hash explains why multiple versions co-existence is so troublesome
10:18:34 <MarcelineVQ> mitochon: looks like lazy pattern matching
10:18:49 <MarcelineVQ> mitochon: https://wiki.haskell.org/Lazy_pattern_match
10:19:08 <geekosaur> (because what part of the source ends up in the .hi file along wth the type information will depend on compile options, and because it's stored in an internal form it can have different generated names in it)
10:19:11 <mitochon> thanks MarcelineVQ
10:19:32 <suppi> bye for now.
10:19:42 <roelof> when I do onThreeLines s1 s2 s3 = putStr s1 ++ "\n" ++ s2 ++ "\n" ++ s3 ++ "\n"  I see this error message : Couldn't match expected type ‘[Char]’ with actual type ‘IO ()’
10:20:15 <monochrom> is it "slippery slope" or is it "slippery rope"?
10:20:17 <geekosaur> you can cause this in C/C++ as well by putting inline function definitions (or, sometimes, macros) in .h files, and old KDE versions used to end up with the same library hell issues because they did it
10:20:36 <mrkgnao> dinner calls; see you people later.
10:21:07 <geekosaur> roelof, that means (putStr s1) ++ ...
10:21:17 <geekosaur> instead: putStr (s1 ++ ... )
10:22:09 <roelof> geekosaur: then I see this error : Couldn't match type ‘IO ()’ with ‘[Char]’
10:22:31 <geekosaur> then you need to look at what calls onThreeLines
10:22:50 <roelof> Here my whole function : http://lpaste.net/140756
10:23:00 <geekosaur> (which is probably also where you are doing the wrong kind of print operation)
10:23:18 <geekosaur> yes. now what *calls* onThreeLines?
10:23:23 <geekosaur> what does that look like?
10:23:24 <aweinstock> roelof: String -> String -> String -> IO String
10:23:33 <geekosaur> um, no
10:23:34 <geekosaur> IO ()
10:23:38 <aweinstock> (since you're calling putStr)
10:23:46 <aweinstock> geekosaur: oops
10:23:58 <Algebr> Why do seemingly simple package require what feels like hundreds of packages to install?
10:24:13 <monochrom> because "seemingly" lies.
10:24:20 <Welkin> Algebr: not all do
10:24:24 <aweinstock> roelof: or you could remove the putStr, and have (String -> String -> String -> String)
10:24:25 <roelof> Wierd, in chapter 3 exercise 3.18 I stated to use this : onThreeLines : : String -> String -> String -> String 
10:24:26 <Welkin> pipes has few dependencies
10:24:29 <Welkin> conduit has tons
10:24:32 <Welkin> they do the same thing
10:24:40 <monochrom> and "feels like" is fuzzy
10:24:44 <geekosaur> roelof, that would be fine if you were not doing output in onThreeLines
10:25:01 <Algebr> I just want ghc-mod and it has like 50 dependencies
10:25:02 <geekosaur> my guess is that you are supposed to do putStr (onThreeLines ...) somewhere
10:25:22 <roelof> oke, so I have to made a second function that calls onTreelines  
10:25:23 <maerwald> Algebr: because haskell developers are lazy and use solution from other people?
10:25:23 <monochrom> ghc-mod is far from simple. and 50 is far from hundreds
10:25:41 <geekosaur> Algebr, this is actually not unusual for C or C++ packages, it's just you usually get those from your package manager
10:26:02 <geekosaur> and often the dependencies are preinstalled because so many other things use them if you have e.g. gnome installed
10:26:18 <maerwald> geekosaur: 50 dependencies is rather uncommon for C/C++ packages
10:26:18 <Algebr> i am comparing it to merlin, ocaml thing.
10:26:48 <Algebr> maerwald: that or there are many scattered and fragmented libraries
10:27:11 <monochrom> oh, so you already know the answer to your question.
10:27:17 <ReinH> ghc-mod has 32 dependencies, many of which are related to... ghc
10:27:33 <roelof> geekosaur:  thanks, calling the function this way works putStr(onThreeLines "line1" "Line2" "Line3")
10:27:41 <Algebr> no, I don't know the answer but I am looking at the libraries more carefully now
10:27:54 <roelof> sometimes the book is not clear on what to do or expect 
10:28:31 <MarcelineVQ> Which book is that?
10:28:38 <ReinH> Well, perhaps 50 dependencies are uncommon for C/C++ because C/C++ don't have a reasonable dependency management story
10:28:50 <roelof> Craft book 3 edition  MarcelineVQ 
10:29:05 <Algebr> I also want an easy http library, I see HTTP or wreq, what is best maintained
10:29:10 <ReinH> Algebr: wreq
10:29:25 <maerwald> ReinH: what do you mean with "dependency management story"?
10:29:40 <ReinH> maerwald: package management, etc
10:30:02 <geekosaur> mostly it's because gtk+ and similar libraries split things into a zillion small libraries, or used to. if I ask for a recursive dependency list (without duplicates) I get an insane number of dependencies
10:30:16 <geekosaur> and glib brings in many of those dependencies and is not a gui library
10:30:19 <maerwald> then that doesn't make a lot of sense to me, because distro package managers are able to handle C/C++ deps a hundred times better than haskell
10:30:39 <marchelzo> I'm interested in parsing a language with a syntax similar to Haskell's (no parens for function application, arbitrary fixity for operators, etc.). Does anyone know of a good tutorial?
10:31:03 <geekosaur> maerwald, that is because they are distributions, *and* because they only deal with stuff already built (which doesn't have ghc's insane cross-module inlining story)
10:31:16 <Algebr> is aeson still the defacto json library?
10:31:17 <maerwald> geekosaur: mh, I am running a source distro
10:31:32 <geekosaur> c/c++ still has not solved package manageemnt for source. pkg-config is as close as it gets and can get pretty nightmarish
10:31:51 <ReinH> geekosaur: ryppl was abandoned, clib isn't actually being used afaik
10:32:04 <geekosaur> ReinH, what?
10:32:06 <maerwald> it's probably not the job of the language to provide a package management system
10:32:15 <geekosaur> I did not say clib
10:32:23 <geekosaur> *g*lib is very, very much being used
10:32:29 <ReinH> geekosaur: I didn't say you did.
10:32:52 <ReinH> I was just mentioning the only two C package managers I am aware of
10:33:07 <Algebr> Also these compile times are nuts, I didn't even ask for any optimizations
10:33:09 <ReinH> Algebr: yes
10:33:10 <maerwald> There's no big problem with C/C++ dependency management, except that people use a lot of different build systems.
10:33:33 <geekosaur> sigh
10:33:34 <maerwald> in addition, ABI breakages are less 
10:33:45 <ReinH> geekosaur: ?
10:33:48 <geekosaur> yes, someone solved all of them for you and that means they never ecisted in the first place, obviously
10:33:55 <maerwald> ?
10:34:09 <geekosaur> try building that stuff from source without the package manager that someone slaved over figuring out the deps for you
10:34:13 <geekosaur> I used to do that
10:34:17 <maerwald> I do
10:34:28 <maerwald> I am the one figuring out the deps, because I package for a source distro
10:35:02 <ReinH> maerwald: distro package managers are fine if you are ok with being limited to libraries that are 6+ months old
10:35:18 <maerwald> ReinH: that depends on the distro
10:35:20 <geekosaur> ...and you have never worked with arch :p
10:35:23 <ReinH> maerwald: sure
10:35:27 <maerwald> geekosaur: arch linux?
10:35:29 <geekosaur> (sorry "you" = ReinH)
10:35:29 <ReinH> but generally the release cycles are much longer
10:35:50 <ReinH> geekosaur: true enough. Mostly debian.
10:35:57 <maerwald> ReinH: as that heavily depends on the distro, I wouldn't make a "general" assumption there
10:36:04 <geekosaur> also if the poroblem is solved so very well there, why do we often have to deal with arch version skew in #xmonad?
10:36:23 <ReinH> maerwald: I think it's generally true that distro package managers release more slowly than, e.g. hackage
10:36:37 <maerwald> ReinH: for haskell, that might be true
10:36:40 <ReinH> Anyway, it doesn't really matter
10:36:41 <geekosaur> not even with haskell stuff necessarily, stuff gets brought in without testing on everything and C dependencies end up whacked out
10:37:07 <maerwald> ReinH: but that's basically because there are very few distro package managers that can properly deal with the haskell eco-system, since most PMs were written for, well... C/C++ ;)
10:37:10 <Algebr> Oh excellent, ghc-mod actually works quite well. This go at haskell will be much more pleasurable i think.
10:37:49 <ReinH> maerwald: I don't mean specifically for haskell packages. Generally, distro package managers have more than zero upstream quality control in their release process. ;)
10:38:14 <Algebr> Is Debug.Trace basically a way to wrap anything with a printed string?
10:38:17 <maerwald> ReinH: there are branches
10:38:27 <monochrom> yes
10:39:39 <ReinH> maerwald: Well, I like distro package managers, and it would be more accurate to compare against stackage or LTS anyway.
10:40:13 <ReinH> hackage is a free for all, for better and sometimes worse.
10:40:45 <Algebr> cabal still doesn't uninstall, correct?
10:41:00 <geekosaur> (I'm also reminded of debian unstable and occasionally testing "oh, you want to install <x> but it was built against a newer glibc so I'mma remove most of your system" >.> )
10:41:09 <ReinH> Algebr: I would suggest trying stack now.
10:41:21 <maerwald> geekosaur: luckily that will not happen on source distros
10:41:40 <maerwald> but you get other foo ofc
10:41:46 <ReinH> It will probably be easier to work with than cabal. https://www.stackage.org/
10:41:58 <Algebr> ReinH: I did look at stack but honestly I don't want so much mental overhead for just trying some small code
10:42:13 <ReinH> I'm recommending it because there's less overhead.
10:42:17 <Algebr> oh
10:42:19 <ReinH> It tends to Just Work more frequently than cabal
10:42:41 <Algebr> will try then given your recommendation
10:42:45 <ReinH> And its user experience is nicer as well
10:42:49 <ReinH> They did a good job with stack.
10:42:53 <maerwald> ReinH: as long as all packages are in stackage ;)
10:42:58 <maerwald> if not, good luck
10:43:08 <ReinH> I haven't had trouble with extra deps.
10:43:13 <maerwald> I had a lot
10:43:15 <monochrom> ReinH: but by now there is a sunk-cost consideration of "but I have just successfully built ghc-mod using cabal" :)
10:43:16 <maerwald> and I gave up
10:43:19 <ReinH> At least, no more than I would have with cabal hell, usually less.
10:43:45 <maerwald> tried to use stack for my project... it just threw more errors than cabal ever did. Maybe I was unlucky because of my deps
10:44:03 <ReinH> monochrom: It's called the "sunk cost fallacy" for a reason. ;)
10:44:23 <roelof> As a beginner in Haskell , it it wise to use Servant in the future for web development  ? 
10:44:40 <ReinH> maerwald: I think there are some perverse cases, but for most cases it's easier to use than cabal. Especially if you are familiar with neither.
10:44:56 <ReinH> roelof: sure, if it fits your use case.
10:45:03 <Sonarpulse> is `setup-depends` in a released version of cabal yet?
10:45:30 <roelof> ReinH:  I think I can try to make a ecommerce or accounting app 
10:45:31 <ReinH> maerwald: And as someone who is now intimately familiar with cabal, I definitely prefer stack for day-to-day development.
10:45:36 <Algebr> monochrom: heh, that is true.
10:45:53 <ReinH> maerwald: Anyway, it's fine to disagree :)
10:46:40 <roelof> but first the Craft book, CIS194 and the other course so I hope I can begin this year :)
10:47:56 <ReinH> roelof: I'd definitely recommend working on your own projects even while you're doing the courses. You have to put things into practice.
10:48:15 <Algebr> is there a tool availabel, like a cli viewer of a module and it dumps all the functions with type signatures?
10:48:18 <maerwald> ReinH: I am currently not sure what the solution is for haskell packages. But it's not just a tool problem, it's also an ecosystem problem (not just ABI breaks too quick, APIs too)
10:48:56 <ReinH> Algebr: ghci can provide some of this info
10:48:59 <roelof> ReinH:  Thanks for the tip 
10:49:00 <Algebr> also what's a good terminal manipulation library?
10:49:10 <ReinH> Algebr: do you want ncurses or readline or?
10:49:23 <Algebr> something closer to ncurses but not ncurses
10:49:31 <ReinH> http://hackage.haskell.org/package/brick
10:50:10 <ReinH> Algebr: ^
10:50:31 <Algebr> I see, looks very promising.
10:50:35 <ReinH> It is!
10:51:47 <Algebr> ReinH: Also, can I get type information out of compiled haskell, like is there a compiled interface, like ocaml's .cmi
10:53:15 <ReinH> When would you use that?
10:53:20 <ReinH> (I'm not sure)
10:54:14 <Algebr> To get the function signatures contained in compiled code
10:54:16 <geekosaur> Algebr, .hi files?
10:54:43 <Algebr> ah, don't know about .hi files. Is there somethign already available to parse it
10:55:01 <geekosaur> which are binary, but there is ghc -show-iface foo.hi
10:55:21 <geekosaur> er --show-iface
10:56:05 <geekosaur> there is also -ddump-hi during compilation which will output it in a different format
10:57:11 <Algebr> ah, it dumps it in an awkward format
10:57:33 <KaneTW> theres a description of the format but you should probably use the GHC API
10:57:35 <Algebr> Can I get this with like compiler-libs 
10:59:27 <geekosaur> as mentioned, you want ghc-api (or a wrapper there of, like the hint or plugins packages)
10:59:54 <Algebr> thank you, you guys were very helpful.
11:02:43 <mpickering> be warned that it's actually non-trivial to parse the files using the GHC API.. the interface is not ideal
11:03:22 <mpickering> This guy was trying to do it a few weeks ago https://github.com/urbanslug
11:03:26 <mpickering> not sure how far he got
11:05:23 <geekosaur> that's why I suggested looking at hint and/or plugins
11:05:39 <geekosaur> or ghc-mod or ide-backend maybe
11:13:46 <VitorCBSB> Hi, is this the correct place to ask stupid questions about Haskell?
11:15:08 <exio4> VitorCBSB: it indeed is
11:16:54 <VitorCBSB> Great, I just so happen to have one.
11:17:03 <scshunt> excellent!
11:17:16 <VitorCBSB> So, in: type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
11:17:26 <VitorCBSB> What's the point of the forall f.?
11:17:34 <VitorCBSB> Can I not just type Functor f => (a -> f b) -> s -> f t?
11:17:55 <scshunt> VitorCBSB: you can, and the compiler will implicitly insert the forall f for you
11:18:02 <jmcarthur> well
11:18:14 <jmcarthur> wait, it will do that in a type definition?
11:18:17 <scshunt> yes
11:18:20 <OnkelTem> Hi all
11:18:30 <jmcarthur> i don't think it does...
11:18:32 <edwardk> jmcarthur: in some compilers
11:18:32 * jmcarthur tries
11:18:34 <scshunt> all type variables introduced without any other context are implicitly quantified
11:18:37 <jmcarthur> huh
11:18:40 <edwardk> jmcarthur: i forget when it was added or removed
11:18:46 <edwardk> but it only works 'some times'
11:19:00 <scshunt> you may not see the result, but the important thing is that, in this case, they are semantically equivalent
11:19:09 <edwardk> since i support a wide range of compilers i have to write it, so i just stopped thinking about the hack
11:19:09 <jmcarthur> is ghc one such compiler?
11:19:29 <jmcarthur> RankNTypes doesn't enable this behavior on its own at least
11:19:32 <edwardk> jmcarthur: ghc either added or removed support for the implicit forall, i forget which way
11:19:38 <jmcarthur> i guess removed
11:19:44 <scshunt> edwardk: there's no semantic difference though, right?
11:19:59 <edwardk> scshunt: on the range of compilers in which both syntaxes are supported, no
11:20:07 <Welkin> in what version?
11:20:11 <scshunt> edwardk: oh really? What's the difference?
11:20:20 <Welkin> ghc 8?
11:20:25 <edwardk> scshunt: the difference is that there are versions of ghc where youhave to have the forall
11:20:31 <ReinH> scshunt: The implicit version is either the same or a compile error.
11:20:37 <edwardk> Welkin: no, the transition was some time since 7.4 
11:20:41 <Welkin> really?
11:20:44 <scshunt> edwardk: sure, but what's the semantic difference if you leave it off
11:20:48 <Welkin> how does it still work then?
11:20:59 <scshunt> where can I use an explicilty quantified function but not one that isn't quantified?
11:21:00 <OnkelTem> I'm new to Haskell and recently started reading "Learn You a Haskell for Great Good" book. I'd like to try Haskell, but even after reading the instructions from Download section and README from haskell-platform, I still have no idea what to do
11:21:02 <Welkin> I use implicit foralls everywhere
11:21:03 <edwardk> scshunt: the semantic difference is that some compiler versions won't compile. so it is either the same or a type error
11:21:04 <breadmonster> edwardk: Hi.
11:21:13 <edwardk> Welkin: implicit foralls on terms are fine
11:21:18 <scshunt> edwardk: won't compile what, though?
11:21:19 <breadmonster> OnkelTem: What OS are you using?
11:21:22 <edwardk> implicit foralls in _TYPE SYNONYMS_ is different
11:21:45 <scshunt> this is what I'm confused about :)
11:21:45 <Welkin> OnkelTem: install the platform and then type ghci in your terminal emulator
11:21:50 <edwardk> type Foo a b = c  -- 99% of the time is a bug
11:21:53 <scshunt> edwardk: ahhh
11:21:57 <OnkelTem> breadmonster: Ubuntu 12.04, but I don't want to try some old stuff. What is haskell-platform really? Does it contain Haskell compiler? What is cabal? Why I can't find it? So confusing
11:22:15 <breadmonster> OnkelTem: `sudo apt-get install ghc ghc-cabal`
11:22:15 <nkaretnikov> speaking of foralls, are there any plans to add a proper exists?
11:22:30 <breadmonster> OnkelTem: There's no "old stuff" you really won't know the difference (:
11:22:37 <Welkin> OnkelTem: haskell platform installs ghc (the compiler and related tools), cabal (for building and installing packages) and several libraries
11:22:37 <edwardk> >>> type Foo a b = c     ==> <interactive>:2:16: Not in scope: type variable ‘c’
11:22:40 <breadmonster> nkaretnikov: I don't think so.
11:22:51 <Welkin> breadmonster: don't recommend that
11:23:01 <Welkin> OnkelTem: avoid using haskell from your package manager
11:23:03 <breadmonster> Welkin: It's what I did...
11:23:04 <Welkin> it is too old
11:23:12 <edwardk> nkaretnikov: my understanding is that it doesn't play nicely with type families
11:23:16 <VitorCBSB> Ok, hold on, let me see if I get it then. The explicit forall is there mostly to support as many compilers as possible? If it's left out, then it might or might not work?
11:23:17 <breadmonster> Welkin: It's 7.8.2,  it's really not that bad.
11:23:18 <Welkin> download haskell platform from the official site
11:23:23 <Welkin> or just ghc + cabal-install
11:23:29 <OnkelTem> Welkin: that is what I understood after readin the README, but then when I type: ./platform.sh it fails to find cabal
11:23:49 <breadmonster> OnkelTem: There's also an Ubuntu PPA from hvr that has the latest ghc. Let me link it to you.
11:23:54 <Welkin> OnkelTem: https://www.haskell.org/platform/
11:23:59 <edwardk> nkaretnikov: uhc has first class existential support, but IIRC they also have things that make me cry like local instances
11:24:06 <OnkelTem> breadmonster: thanks, but wait. I'd like to get it from sournce
11:24:10 <OnkelTem> breadmonster: source*
11:24:22 <breadmonster> OnkelTem: You need Haskell to compile source.
11:24:23 <ReinH> OnkelTem: haskell-platform contains ghc, cabal-install, and a variety of commonly-used packages. cabal (the cabal-install executable) installs haskell packages.
11:24:38 <Welkin> OnkelTem: https://www.haskell.org/platform/#linux-generic
11:24:50 <geekosaur> apt-add-repository ppa:hvr/gcc
11:24:56 <nkaretnikov> edwardk: i have to admit, forall still confuses me for this particular reason.  in coq, it's much nicer to work with.
11:25:03 <OnkelTem> ReinH: ok, then what exactly should I do after fetching git haskel-platform? What should i run to get the mentioned things installed?
11:25:07 <geekosaur> er
11:25:11 <geekosaur> apt-add-repository ppa:hvr/ghc
11:25:14 <geekosaur> I can type >.>
11:25:39 <ReinH> OnkelTem: if you just want to install ghc and cabal-install, you can do this: https://github.com/freebroccolo/docker-haskell/blob/master/7.10/Dockerfile#L8-L15
11:26:08 <breadmonster> OnkelTem: `sudo apt-add-repository ppa:hvr/ghc` and then `sudo apt-get update`
11:26:09 <edwardk> nkaretnikov: coq trades making some things easier to work with for making you work down from types more often. its great when you know exactly what you want, but bad when you are less principled and just want to have a dialog with the compiler about what a term means
11:26:13 <OnkelTem> ReinH: I'd like to use haskel-platform as as you said - it contains everything :)
11:26:41 <breadmonster> OnkelTem: You really don't need Haskell Platform, just install ghc and cabal.
11:26:45 <OnkelTem> breadmonster: thanks! That's what I'll do if I can't installed fetched haskell-platform :)
11:26:49 <breadmonster> And then you can cabal install anything that's required.
11:27:14 <breadmonster> Haskell platform is also old, I'd recommend Stack.
11:27:22 <ReinH> If you want to install the haskell platform, you can apt-get install haskell-platform or for the most recent version, https://www.haskell.org/platform/#linux-generic
11:27:30 <OnkelTem> breadmonster: ah, maybe. I just repeating after the book. There I read I need haskell-platform. as I said - I'm very new :)
11:27:31 <breadmonster> OnkelTem: https://github.com/commercialhaskell/stack
11:27:38 <ReinH> Haskell platform is not old
11:27:39 <nkaretnikov> edwardk: having inference is nice, yeah
11:27:41 <ReinH> unless 7.10.2 is old
11:27:58 <breadmonster> ReinH: Wow is that even on windows?
11:28:01 <ReinH> In fact it was just recently released
11:28:11 <breadmonster> When I installed it a few months ago it was the 2013 version.
11:28:25 <ReinH> "The latest version of the Haskell Platform for Windows is 7.10.2-a.
11:28:33 <ReinH> So yes. :)
11:28:56 <monochrom> yeah now Haskell Platform uses the associated GHC version number for version number
11:29:14 <ReinH> OnkelTem: you should be able to use these instructions to install latest haskell platform on linux https://www.haskell.org/platform/#linux-generic
11:29:28 <ReinH> your package manager likely has an older version
11:29:31 <monochrom> the "-a" there means updating a library ("text" in this case)
11:29:40 <ReinH> monochrom: yeah, that's much nicer
11:29:55 <ReinH> iirc even wily is on 2014
11:32:31 <bezirg> question: the {-# UNPACK #-} pragma works only with 1-constructor datatypes?
11:32:49 <ReinH> bezirg: no
11:32:52 <OnkelTem> To say truth I had a faint hope, that I'll get Haskell running by just typing "npm install haskell" :)
11:32:57 <bezirg> ReinH: ok thanks
11:33:08 <ReinH> bezirg: Wait. Yes.
11:33:28 <monochrom> it is yes or no depending on which position you refer to.
11:33:40 <ReinH> bezirg: Let me be clear: it only works with 1-constructor datatypes. See https://ghc.haskell.org/trac/ghc/ticket/9214
11:33:52 <ReinH> monochrom: yeah.
11:33:58 <ReinH> monochrom: or nah.
11:34:02 <monochrom> haha
11:34:38 <bezirg> ReinH: monochrom: :D
11:35:19 <ReinH> OnkelTem: seems unlikely, unless someone has written a haskell compiler in javascript.
11:35:37 <exio4> couldn't we compile GHC with GHCJS? :p
11:35:40 <ReinH> Which isn't as ridiculous as it sounds, given what some people are writing in javascfript these days.
11:35:47 <ReinH> exio4: too much C stuff
11:35:49 <ReinH> I assume
11:36:32 <ReinH> Well, C++... some shitty language that starts with C...
11:36:38 <exio4> ReinH: emscripten! ..
11:36:42 <ReinH> Probably not COBOL
11:37:02 <monochrom> Data.Set shows a valid use. "data Set a    = Bin {-# UNPACK #-} !Size !a !(Set a) !(Set a) | Tip". Set is not required to be 1-constructor. But Size is. (type Size = Int; Int is 1-constructor internally)
11:37:23 <OnkelTem> ReinH: I think implementing haskell in javascript *is* ridiculous  :) I meant just packaging maybe. But really, I meant nothing serious. Just very used to use package managers :)
11:37:28 <ReinH> monochrom: wait what?
11:37:30 <ReinH> huh
11:37:56 <ReinH> OnkelTem: Ubuntu has haskell-platform in its package manager.
11:38:07 <OnkelTem> Very oooold one
11:38:12 <ReinH> Not that old.
11:38:13 <nawal_> Hi, I contacted the author of TagSoup, and he gave the advice: Try adding explicit type signatures to the String literals. I'm not sure what that means. Minimum non-working example:
11:38:14 <OnkelTem> (but I say the link to PPA)
11:38:17 <OnkelTem> saw*
11:38:19 <nawal_> http://pastebin.com/gs5iMFPT
11:38:24 <monochrom> I admit that I haven't checked generated code to really verify that the UNPACK is honoured. :)
11:38:28 <OnkelTem> ReinH: 2012.*
11:38:38 <monochrom> (but I trust that tibbe did :) )
11:39:00 <ReinH> Unless you're on Precise, which is end-of-life anyway
11:39:15 <ReinH> OnkelTem: Well, Precise is a very oooold Ubuntu :p
11:40:09 <ReinH> monochrom: "unpack pragma doesn't apply to sum types with more than one constructor... unless it does"
11:42:26 <mrkgnao> I'm having some trouble installing ghci-ng, any help?
11:42:44 <lpaste_> mrkgnao pasted “ghci-ng install errors” at http://lpaste.net/7117007740026748928
11:42:54 <mrkgnao> There they are.
11:49:19 <koral> Hello
11:50:19 <koral> what's the cleanest way to publish canonical Arbitrary instances for types defined in my library ?
11:50:54 <koral> exporting them with the library adds QuickCheck as dependency, which seems bad
11:51:34 <koral> creating a distinct package "mylibrary-arbitrary" seems overkill and might go unnoticed
11:51:55 <koral> adding a cabal flag maybe ?
11:52:57 <mmaruseacph2> some do that (http://hackage.haskell.org/packages/search?terms=optparse)
11:53:23 <mmaruseacph2> others just include everything in a single package, even though it adds QuickCheck as dependency (though you'd have it if you test anyway)
11:56:07 <t_> @pl \a b -> a * (b + 1)
11:56:07 <lambdabot> (. (1 +)) . (*)
11:56:29 <t_> @pl \a b -> (b + 1) * a
11:56:29 <lambdabot> (. (1 +)) . (*)
12:10:59 <Gurkenglas> Is there a shorthand for liftA2 (,)?
12:12:53 <quchen> It's sometimes called (**) but that's not in any standard lib
12:13:17 <quchen> You can define Applicative in terms of it (and unit :: Applicative f => f ())
12:13:39 <quchen> I think the Typeclassopedia talks about this a bit
12:20:10 <drewbert> What's an elegant way to get what would be the equivalent of partitionM?
12:20:40 <Javran> http://lpaste.net/6401782444135022592  anyone familar with haskeline? 
12:21:13 <drewbert> paritionM being of type (a -> m Bool) -> [a] -> m ([a], [a]) ?
12:21:48 <Javran> while https://hackage.haskell.org/package/haskeline-0.7.2.1/docs/System-Console-Haskeline-MonadException.html#t:MonadException has all instances needed, ghc couldn't find it, not sure why
12:22:27 <Gurkenglas> drewbert, "the equivalent"? Those two words need context.
12:23:46 <byorgey> perhaps drewbert means that partitionM should be the monadic equivalent of partition, as filterM is to filter?
12:23:56 <drewbert> byorgey: precisely
12:24:20 <Javran> hmm, turns out the instance is made for Control.Monad.State.Strict ...  kind of confusing.. 
12:24:25 <rklv> What are the differences between OCaml, Haskell and Erlang? Are they each suited for some specific uses? I know there is information that I can google, but still prefer to come here.
12:25:36 <drewbert> It exists in Control.Monad.Extra.  Sorry guys.  I tried hoogle and didn't find it, but byorgey gave me the language that allowed me to find it using google.
12:25:39 <Alien_FX_Fiend> Wow told ya
12:25:47 <byorgey> drewbert: ah, great =(
12:25:51 <Gurkenglas> dangit, was about to write out an elegant solution
12:25:55 <byorgey> hehe, whoops, that was supposed to be a =)
12:26:32 <PermaPissed> Bonjour les hommes!
12:27:01 <PermaPissed> WTF do you talk about here?
12:27:14 <Alien_FX_Fiend> More than #electronics. Whats up guy books.realworldhaskell.org amirite?
12:27:15 <Gurkenglas> :t \f -> fmap (join (***) (map fst) . partition snd) . mapM (ap f) -- I'll do it anyway!
12:27:17 <lambdabot> Monad f => f (a -> (b, Bool)) -> [f a] -> f ([b], [b])
12:27:22 <byorgey> PermaPissed: hi, we talk about the programming language Haskell.   http://haskell.org
12:27:37 <byorgey> Gurkenglas: try again =)
12:27:52 <PermaPissed> dafuq?
12:28:07 <drewbert> Gurkenglas: I was curious, and I appreciate the response.  If you figure it out, then I want to see it.
12:28:08 <byorgey> PermaPissed: are you interested in discussing Haskell?  it's really cool
12:28:11 <a___> What is the easiest way to apply a binary function on first two elements of a list?
12:28:35 <byorgey> a___: just pattern match the list to get out the first two elements, then apply the function
12:28:38 <PermaPissed> byorgey I don't know what that is :@
12:28:40 <Alien_FX_Fiend> Got me interested!
12:28:46 <PermaPissed> I saw this place is full.
12:29:02 <byorgey> PermaPissed: http://haskell.org, check it out
12:29:10 <drewbert> a___: case xs of [a, b] -> myBinary a b
12:29:45 <byorgey> drewbert: that will match only on lists of exactly two elements, a___ said "first two elements"
12:29:46 <Alien_FX_Fiend> no its book.realworldhaskell.org, google it, free online!
12:30:14 <drewbert> oops then (a : b : _) instead
12:30:28 <kristof> I've got a friend who downloaded the osx haskell platform package from haskell.org
12:30:38 <kristof> cabal is not install on his system
12:30:42 <a___> Can I do it without defining any function. I mean I have a long list of functions already applied. (a . b . c . d). At the end a list of two elements will be there after a runs. I want to apply fn on those two.
12:30:46 <kristof> Shouldn't cabal be there?
12:30:56 <PermaPissed> haskell?
12:30:59 <Alien_FX_Fiend> Why isnt the book in the topic anymorez?
12:31:00 <PermaPissed> languae?
12:31:12 <PermaPissed> awesome, this will be my second language!
12:31:28 <PermaPissed> After HTML, but I don't think html counts.
12:31:39 <byorgey> Alien_FX_Fiend, PermaPissed: it is strange that you entered the channel at the same time and started talking to each other.  you are starting to be annoying.  please behave or I will kick you both.
12:32:06 <PermaPissed> OK.
12:32:43 <PermaPissed> So what do you do here?
12:33:12 <byorgey> PermaPissed: I already answered that.  You are welcome if you want to learn about Haskell, please go read something on the website I linked and that will answer some of your basic questions.
12:33:40 <PermaPissed> OK, thanks. I guess.
12:35:37 <PermaPissed> afk now
12:36:04 <Gurkenglas> :t \f -> fmap (join (***) (map fst) . partition snd) . mapM (liftA2 fmap (,) f) -- drewbert
12:36:05 <lambdabot> Monad f => (a -> f Bool) -> [a] -> f ([a], [a])
12:36:23 <Alien_FX_Fiend> Hey im an old reg,been coming here for 2 decades,dont disfront beset me /w threats
12:37:23 <Alien_FX_Fiend> This chan used to be a nice,hospitable place…
12:37:40 <byorgey> Alien_FX_Fiend: who founded this channel?
12:38:28 <PermaPissed> Haskell is nice! Where can I use it?
12:38:32 --- mode: ChanServ set +o byorgey
12:38:33 <zettablade> Is there a way to import a module implicitly for every file in a cabal project? I want to toy around with prelude alternatives, and I'd like to not have to import it every file.
12:38:35 <Alien_FX_Fiend> My minds a bit foggy,but i remember having a convo loong time ago!
12:38:39 --- kick: PermaPissed was kicked by byorgey (PermaPissed)
12:38:41 --- kick: Alien_FX_Fiend was kicked by byorgey (Alien_FX_Fiend)
12:40:10 <byorgey> zettablade: no, there isn't
12:40:23 --- mode: ChanServ set -o byorgey
12:41:40 <zettablade> Ah that's too bad.
12:42:42 <bergmark> zettablade byorgey: there is, use http://hackage.haskell.org/package/base-noprelude and define your own Prelude
12:43:06 <wedify> easy enough to write a script to do it. i'm pretty sure cabal has a way to call that script before compiling
12:43:11 <byorgey> woah, neat!
12:43:40 <byorgey> bergmark: so ghc will just implicitly import whatever Prelude module it can find, even if it's not the one from base?
12:44:54 <PermaPissed> byorgey: How can I trigger the bot that's here?
12:45:10 --- mode: ChanServ set +o byorgey
12:45:14 --- mode: byorgey set +b *!*4f8da404@*.com/ip.79.141.164.4
12:45:15 --- kick: PermaPissed was kicked by byorgey (PermaPissed)
12:45:19 --- mode: ChanServ set -o byorgey
12:45:49 <drewbert> Gurkenglas: thanks, what's ***?
12:46:05 <bergmark> byorgey: yup
12:46:15 <byorgey> I learn something every day =)
12:46:49 <quchen> That's strange. I thought you would have to change GHC to have a different Prelude.
12:46:51 <Gurkenglas> drewbert, as far as I am concerned, (f *** g) = \(x, y) -> (f x, g y)
12:47:21 <quchen> (***) is, like the rest of Control.Arrow, a general function almost exclusively abused for tuple convenience.
12:47:25 <quchen> But now we have bimap! :-)
12:47:37 <zettablade> bergmark: nice! thanks!
12:47:43 <quchen> :t [bimap, (***)]
12:47:44 <lambdabot> [(a -> b) -> (c -> d) -> (a, c) -> (b, d)]
12:48:48 <Gurkenglas> quchen, what about (&&&)?
12:48:56 <quchen> That's not in Bifunctor.
12:50:11 <quchen> Gurkenglas: I don't think it's such a useful operator though, I rarely need it. And it works only for tuples; the nice thing about bimap is that it generalizes e.g. mapLeft/mapRight as well, among other things.
12:50:47 <quchen> Bifunctor abstracts over the type constructor of the things mapped, whereas Arrow abstracts over the function arrows. The former is what we want most of the time.
12:51:18 <Algebr> I'm using haskell-mode, ghc-mod and have brick in my .cabal's build-depends file but haskell-mode is still complaining about it not finding the module and that its part of a hidden package. What did I miss
12:55:16 <imPure> Is it possible to define a bifunctor on a multi-parameter type where one parameter is a natural?
12:57:04 <quchen> What's a natural?
12:57:34 <quchen> imPure: ^
12:57:43 <imPure> quchen: Kind Nat, as defined in GHC.TypeLits
12:58:27 <drewbert> Gurkenglas: I have to say https://hackage.haskell.org/package/extra-1.4.1/docs/src/Control-Monad-Extra.html#partitionM is easier to read.
12:58:38 <dmwit> Are you asking whether you can make something of kind `Nat -> * -> *` a bifunctor?
12:58:46 <imPure> dmwit: Yes.
12:58:48 <byorgey> imPure: it is not possible to define a Bifunctor, because it would not kind-check.  Whether it is possible to consider/define it as a bifunctor in some suitably generalized sense, I don't know
12:58:51 <dmwit> If so, what are you imagining supplying as the fmap for the `Nat` kind...?
12:59:05 <dmwit> There are no functions of type `3 -> 4`, so...
12:59:26 <imPure> dmwit: I want to hold the Nat constant.
12:59:42 <dmwit> There are no functions of type `3 -> 3`, either. =P
12:59:42 <byorgey> imPure: so in that case it is just a Functor.
13:00:20 <imPure> dmwit: So it's overkill... But trying to define it as a functor I get the error I have an illegal type synonym family application
13:00:36 <dmwit> Perhaps you had better share a small example.
13:00:38 <dmwit> ?paste
13:00:38 <lambdabot> Haskell pastebin: http://lpaste.net/
13:02:59 <imPure> Had to type it manually due to silly issues, but: http://lpaste.net/8022513238321135616
13:03:16 <imPure> So, there's always a chance I have a typo.
13:03:31 <byorgey> imPure: is  Hyper = Foo ?
13:03:42 <kristof> Hey, a friend of mine installed the haskell platform
13:03:52 <imPure> Yes
13:03:59 <imPure> One of those typos I mentioned :)
13:04:05 <byorgey> imPure: no worries =)
13:04:08 <kristof> on OSX. He has /Library/Haskell/cabal, but I can't find ghc on his computer. which ghc yields nothing. What's going on?
13:04:17 <byorgey> imPure: you cannot make type synonyms, type families, etc. instances of type classes
13:05:00 <imPure> byorgey: How do I accomplish something like this? Or must I use a GADT instead?
13:05:01 <Gurkenglas> :t \f xs -> (both %~ map fst) . partition snd <$> mapM (\x -> (x,) <$> f x) xs -- drewbert, how's this?
13:05:03 <lambdabot> Monad f => (a -> f Bool) -> [a] -> f ([a], [a])
13:05:18 <quchen> Unreadable.
13:05:23 <Beardful> How do i apply a list of functions to an argument sequentially and in the end get one value?
13:05:28 <Gurkenglas> (By the way, you don't need Monad for this. Applicative suffices, by replacing mapM with traversable.)
13:06:02 <Gurkenglas> *traverse
13:06:02 <imPure> Bearful: zipWith (fmap) ?
13:06:02 <byorgey> imPure: build your definition of Hyper out of functors. i.e.  change   Foo 0 t = t   to   Foo 0 t = Identity t, and change Foo n t = Pair (Foo (n-1) t)
13:06:06 <quchen> Beardful: You mean "magic [f,g,h] x = f (g (h x))?
13:06:09 <elfeck> heyoh, I'm using persisent and I have a list of Keys. Now I want all rows to these keys. Can I do that with selectList instead of mapM get keys?
13:06:17 <byorgey> imPure: where Pair a = Pair a a deriving Functor
13:06:26 <quchen> :t foldr (.) id  -- Beardful 
13:06:28 <lambdabot> Foldable t => t (b -> b) -> b -> b
13:06:28 <Beardful> quchen: Yes.
13:06:39 <Beardful> quchen: Thank you!
13:06:40 <Gurkenglas> :t ala Endo foldMap
13:06:42 <lambdabot> Foldable t => t (a -> a) -> a -> a
13:06:49 <drewbert> It's nicer than the first, I feel.  I think it's cool that you manage to represent it so densely.
13:06:52 <quchen> Beardful: You basically want to transform [f,g,h] to (f.g.h), which is what the above fold does.
13:06:58 <byorgey> imPure: hmm, wait, what I was thinking doesn't quite work
13:07:08 <byorgey> imPure: yes, perhaps you should use a GADT
13:09:38 <imPure> byorgey: Yea, just tried, doesn't work. GADTs it is.
13:10:25 <byorgey> imPure: I think GADTs will make it much nicer to write *any* functions over Foo, not just a Functor instance
13:10:57 <byorgey> because you can just match on the GADT constructors directly, instead of having to know what n is
13:11:04 <imPure> byorgey: My biggest complaint, I don't know how to write a GADT such that each "subtype" doesn't overlap.
13:11:17 <byorgey> imPure: I'm not sure what you mean
13:11:51 <imPure> byorgey: I can do FooLeaf :: t -> Foo 0 t, and I can do FooBranch :: t -> t -> Foo n t
13:12:08 <imPure> byorgey: But I'd rather say FooBranch :: t -> t -> Foo (n+1) t
13:13:07 <byorgey> imPure: hmm, I see what you mean.  Let me think about this for a minute.
13:14:17 <imPure> byorgey: It's possible that's not valuable for this case, but for another it is.
13:14:42 * hackagebot language-lua2 0.1.0.3 - Lua parser and pretty printer  https://hackage.haskell.org/package/language-lua2-0.1.0.3 (mitchellwrosen)
13:14:49 <byorgey> imPure: no, wait, to transcribe Foo you would write    FooBranch :: Foo n t -> Foo n t -> Foo (S n) t
13:14:56 <byorgey> not t -> t -> Foo n t
13:15:17 <imPure> byorgey: Good point, you're right.
13:17:25 <mmachenry> Is it recommended to use "pure" instead of "return" now that the applicative functor proposal is in GHC? Will "return" eventually be removed from Monad in years to come?
13:18:58 <Algebr> How do I pipe things from left to right. like ocaml's things |> List.iter
13:19:20 <quchen> mmachenry: "return" will probably never be gone, but it may be moved out of Monad and be made a top-level synonym for pure somewhere in the future.
13:19:22 <byorgey> mmachenry: I don't think it really matters.  Note that with the ApplicativeDo extension, 'return' is already automatically translated into 'pure' for you anyway
13:19:57 <quchen> :t (&) -- Algebr 
13:19:58 <lambdabot> a -> (a -> b) -> b
13:20:06 <quchen> 2 & (*3)
13:20:24 <Algebr> thank you
13:20:34 <quchen> byorgey: Is it? That doesn't sound like a good idea for Applicatives in terms of Monad
13:20:47 <byorgey> quchen: who not?
13:20:50 <byorgey> *why
13:21:14 <Gurkenglas> Is there an f such that pure, <*> and (>>=) can construct f and all three of pure, <*> and f are needed to construct (>>=)?
13:21:32 <quchen> Well when GHC replaces all "return" with "pure" but you have "pure = return" then you get cyclic problems
13:21:55 <mmachenry> byorgey: It doesn't matter, since they are basically synonyms but reducing the sizes of the interfaces, and limiting us to one name for that might be benefitial in the long run. 
13:21:56 <byorgey> Gurkenglas: yes, join
13:21:56 <Gurkenglas> (I guess it's also ok if you can construct (>>=) using only pure and f or <*> and f.)
13:22:22 <byorgey> quchen: I never said GHC replaces all "return" with "pure"
13:22:46 <byorgey> quchen: with the ApplicativeDo extension, if you write a do-block that GHC determines does not actually need >>=, then it will be translated to use Applicative
13:23:27 <quchen> Ah, if it happens only once in the desugaring then it's fine.
13:24:42 * hackagebot implicit 0.0.4 - Math-inspired programmatic 2&3D CAD: CSG, bevels, and shells; gcode export..  https://hackage.haskell.org/package/implicit-0.0.4 (mmachenry)
13:26:41 <Gurkenglas> byorgey, you can construct (>>=) from fmap and join, without anything from applicative.
13:26:43 <imPure> Ok, another question. Is it possible to provide a custom, compile time error? That is, if a class instance for Foo 1 and Foo n where n > 0 are defined, can one define Foo 0 with a special error message when matched?
13:28:04 <ReinH> Algebr: I think you'd get more mileage out of training yourself to be comfortable with right to left application/composition instead, since all of the code you're ever likely to read will use it.
13:28:07 <byorgey> imPure: not really, though you can get pretty far using type-level Strings, i.e. Symbols
13:28:24 <Gurkenglas> Bonus points if f and pure (and fmap) cannot construct <*>
13:28:27 <imPure> byorgey: I see what you mean.
13:28:38 <byorgey> imPure: i.e. define Foo 0 in terms of a type-level string that will show up in a type mismatch message
13:28:59 <ReinH> byorgey: o/
13:29:05 <byorgey> hey ReinH!
13:29:05 <ReinH> byorgey: nice to see you again :)
13:29:09 <byorgey> =)
13:29:17 <ReinH> and in person this time :D
13:29:28 <byorgey> likewise!
13:31:15 <Algebr> ReinH: I'm comfortable with both, but just have a preference
13:32:11 <tosun> Hi
13:32:14 <ReinH> Algebr: There was a now obsolete dialect of Haskell that used left-to-right composition, but it also reversed function arrows, which helped.
13:33:09 <tosun> I understand what monads are. But I still don't understand how they keep Haskell pure. A function that returns a Monadic value rtill relies on the state of the outside of the world. So how exactly do monadic structures keep Haskell pure?
13:33:22 <ReinH> tosun: the monadic values do not rely on the state of the outside world.
13:33:44 <ReinH> Only with IO can there even be this confusion
13:33:49 <ReinH> the rest are obviously pure
13:33:54 <Algebr> okay I'll play ball
13:34:36 <geekosaur> monads don't actually keep haskell pure. IO does so, by hiding its data constructor (same as you cannot construct a Data.Map "by hand" but must use fromList or other approved interface).
13:35:08 <ReinH> Evaluation in Haskell is pure, whether IO is involved or not.
13:35:15 <geekosaur> IO happens to use Monad or Applicative to pull pure values in or apply pure operations; it does not need to do so, it could provide its own interface
13:36:08 <tosun> ReinH: IO is confusing me. When I'm reading a line from stdinput I am relying on the state of the outside world. So how does returning something encapsulated in a monadic type preserve the purity in conceptual terms?
13:36:25 <ReinH> tosun: Execution of IO actions relies on the state of the outside world
13:36:31 <ReinH> Evaluation does not.
13:36:36 <geekosaur> some of the confusion here comes from using the State monad to pretend that there is hidden state somewhere --- but State is just a type alias for passing an extra parameter in and returning a possibly new value as part of a tuple
13:36:42 <ReinH> But there is no expectation that execution is pure.
13:37:04 <ReinH> Execution is performed on the main IO action by the GHC runtime.
13:37:26 <ReinH> (or equivalent for another compiler)
13:38:26 <ReinH> getLine *evaluates* to the same IO action every time. It is pure.
13:38:29 <geekosaur> tosun: "getLine :: IO String" does not do IO. It (conceptually) encodes an instruction for a primitive IO evaluator; you produce a sequence of such instructions as the result of "main :: IO a" and the runtime evaluates them
13:39:22 <geekosaur> >>= adds something to the sequence ("do" notation turns into a collection of these)
13:40:02 <geekosaur> it's a bit like writing a program that writes another program
13:40:54 <kristof> Who here is using the Haskell platform on El Capitan?
13:43:59 <tosun> getLine is of type IO String so it will return a IO monad that contains an arbitrary string depending on the state of the stdio? Am I missing something?
13:44:09 <tosun> Or will that happen when the IOAction returned by getLine gets executed?
13:44:40 <geekosaur> getLine returns a slug. when it is executed by the runtime, which is not under your control, that will produce a String
13:45:20 <geekosaur> you then hang stuff off of it (using the Monad >>= interface, although this is not essential, it was just convenient) that acts like a callback run by the runtime whenever it gets that value
13:45:23 <ReinH> tosun: getLine does not "contain" a string.
13:45:26 <ReinH> @quote ls
13:45:26 <lambdabot> kmc says: it's important to show that Haskell is usable not just for useless maths, but also for real-world tasks such as rendering teapots
13:45:30 <ReinH> :(
13:45:49 <geekosaur> I think the quotes got cleared at some ppint
13:45:52 <geekosaur> @quote /bin/ls
13:45:53 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
13:45:55 <monochrom> tosun: I recommend that you read my http://www.vex.net/~trebla/haskell/IO.xhtml
13:45:57 <ReinH> tosun: This is the problem with "Monads are containers" analogies.
13:46:03 <ReinH> geekosaur: thanks
13:46:10 <ReinH> monochrom: +1
13:46:21 <tnks> that quote is pretty good.
13:46:59 <ReinH> tosun: The latter is true: IO actions must be executed. Evaluation does not perform IO.
13:47:18 <tosun> Okay I see
13:48:04 <tosun> But why does it not contain a string? How can I express the fact that the IO type is based on another type?
13:48:14 <scshunt> tosun: Consider the list type
13:48:26 <scshunt> List is a monad
13:48:41 <scshunt> [1, 2, 3, 4] :: List Int contains four Ints, while [] :: List Int contains none
13:48:49 <monochrom> getLine cannot possibly "contain" a string, in all common senses.
13:49:19 <ReinH> IO actions don't contain anything.
13:49:20 <monochrom> it doesn't even know what string the user will input in the future
13:50:15 <tnks> I wonder why people don't have this "container" problem when learning about generics in Java.
13:50:29 <ReinH> You can say "an IO action that returns a String" for a value of type IO String and people will probably understand you.
13:50:35 <monochrom> consider how you are using getLine to write your program in 2015, but the program will only be run by me in 2047.
13:50:47 <tnks> people seem to understand Matcher<A> without thinking that Hamcrest matchers contain anything.
13:51:13 <ReinH> Does a Parser Foo contain a Foo? No, it is a recipe for parsing something and obtaining a Foo.
13:51:28 <ReinH> There is no Foo "there". There isn't even a "there" there.
13:51:49 <monochrom> tnks: yes I think there is a cognitive dissonance here
13:52:14 <monochrom> then again Matcher<A> is a class, rather than a, shall we say, callable.
13:52:33 <tnks> monochrom: that Matcher is a class is not of consequence.
13:52:43 <adas> can someone please tell me what this means - `False &&! (head [] == 'x')
13:52:53 <ReinH> adas: That depends on what &&! means
13:52:58 <tnks> perhaps I just made matters worse bringing up Java (sorry)
13:53:10 <ReinH> tnks: that sounds suspiciously like a tautology
13:53:12 <monochrom> yeah but cognitive dissonance plays tricks on your mind based on all kinds of irrelevant differences
13:53:15 <adas> I've never seen bangpatterns used to make functions strict.
13:53:22 <adas> in this case (&&) is the function
13:53:32 <ReinH> Are you sure?
13:53:32 <tnks> ReinH: yeah, I'm /truly/ sorry
13:53:45 <adas> ReinH: this is the example used in the cis194 course
13:53:45 <MarcelineVQ> adas: it might just be a custom version of &&! not a band
13:53:46 <MarcelineVQ> *bang
13:54:00 <ReinH> adas: There is no bang pattern happening here. There isn't even a pattern.
13:54:00 <Welkin> bang patterns are for patterns
13:54:01 <MarcelineVQ> like how foldl'' is a cusotm foldl
13:54:05 <monochrom> no, I think this particular mention of Java is better, not worse. it's relevant.
13:54:26 <Welkin> there is a version of $ called $! that uses seq to make the application strict
13:54:32 <ReinH> ! is part of the identifier &&!
13:54:38 <ReinH> Not a separate thing.
13:54:39 <Welkin> but it is just a new function
13:54:44 <MarcelineVQ> last time I saw &&! it was to show a non-lazy version of &&
13:54:53 <ReinH> I mean, infix operator &&!
13:55:01 <adas> MarcelineVQ: yup. thats exactly how cis194 uses it
13:55:04 <ReinH> MarcelineVQ: so max
13:55:04 <tnks> can hoogle find it?
13:55:07 <MarcelineVQ> "(&&!) :: Bool -> Bool -> Bool"
13:55:09 <adas> but i thought is was a bang patern
13:55:15 <MarcelineVQ> It's just a custom &&
13:55:17 <tnks> (probably more than one)
13:55:20 <geekosaur> bang patterns are only parsed in patterns
13:55:21 <Welkin> adas: bang patterns are for patterns
13:55:30 <ReinH> So say we all.
13:55:35 <geekosaur> there's also a ! that can be used in data declarations
13:56:07 <wedify> is there an equivalent to (&-&) f g = \v -> f v || g v? i use this a lot
13:56:17 <wedify> s/||/&&
13:56:19 <adas> geekosaur: to make specific fields strict?
13:56:21 <ReinH> wedify: liftA2 (||)
13:56:31 <ReinH> wedify: I like (<||>) = liftA2 (||)
13:56:36 <ReinH> so f <||> g
13:57:37 <geekosaur> adas, yes
13:58:09 <ReinH> wedify: sometimes it's fun when your client automatically evaluates s/re/ lines for you https://gist.github.com/reinh/a47e2a5c8893d05d4a0a
13:58:11 <geekosaur> data Foo a = Foo !a !a -- basically tells the compiler to insert a "seq" when producing a value using the Foo constructor
13:58:14 <MarcelineVQ> adas: `False &&  (head [] == 'x')` short curcuits and works because `False && _ = False` doesn't evaluate the _ part, but `False &&! (head [] == 'x')` errors because `False &&! False = False` has to evaluate the right side of &&! to check if it's False, and evaluating head [] is an error
13:58:14 <geekosaur> actually two of them in that case
13:58:57 <ReinH> MarcelineVQ: (btw, max is a strict &&)
13:59:09 <ReinH> sorry, min
13:59:15 <monochrom> yeah, min :)
13:59:29 <ReinH> since False is bottom
13:59:36 <ReinH> > min False True
13:59:37 <lambdabot>  False
13:59:39 <ReinH> > min False undefined
13:59:41 <lambdabot>  *Exception: Prelude.undefined
14:00:01 <adas> thanks.. now i understand. confugsion was because i thought the bang pattern `!` was being applied to a function. Now i know bang patterns only work on patterns
14:00:06 <ReinH> monochrom: hey, it's an arbitrary choice, I can't be expected to remember it ;)
14:00:26 <monochrom> true, I took an effort to remember it for my other purposes
14:00:33 <adas> so are bang patterns like syntactic sugar which gets unsugared using `seq`?
14:00:43 <adas> or are they a completely different construct
14:00:45 <adas> ?
14:00:57 <ReinH> monochrom: I had enough trouble remembering which of meet and join were which until someone told me a ridiculously awful punny mnemonic
14:01:11 <ReinH> adas: exactly
14:01:34 <Beardful> http://sprunge.us/OSdF Can foldr do something like this, if not, what function can?
14:01:38 <MarcelineVQ> adas: it's bascially seq sugar, http://www.stephendiehl.com/what/#laziness
14:02:02 <monochrom> I set my irc client to mark join messages with the join symbol, quit messages with the not symbol, and rename messages with alpha
14:02:32 <ReinH> Beardful: but you are using foldr there.
14:02:38 <ReinH> Oh.
14:02:46 <ReinH> It's wrong. You want: foldr (.) id fs
14:03:04 <kadoban> > foldr (.) id [(*2), (+2)] 4
14:03:05 <lambdabot>  12
14:03:14 <ReinH> Beardful: apparently this is a popular question today http://stackoverflow.com/a/32542129/2225384
14:03:29 <adas> thank for the link
14:03:46 <ReinH> You can also use foldr ($) 4, as in my answer, but foldr (.) id is more elegant
14:05:14 <ReinH> monochrom: clever :)
14:05:16 <Beardful> ReinH: I wonder why the other guy wanted to know that.. It worked btw, many thanks.
14:05:40 <ReinH> monochrom: btw the ridiculously awful pun that you didn't bite on is "meat is heavy so it falls to the floor"
14:05:52 <ReinH> just thought you might want to know
14:06:05 <ReinH> also did you see my pun about the pun?
14:06:28 <ReinH> I'm in rare form.
14:06:39 <MarcelineVQ> get it, rare form, meat
14:07:54 <monochrom> heh
14:10:00 <ReinH> well I guess that's it for today
14:14:44 * hackagebot hjsonpointer 0.2.0.4 - JSON Pointer library  https://hackage.haskell.org/package/hjsonpointer-0.2.0.4 (seagreen)
14:20:25 <Sindriava> How do I export lenses?
14:23:07 <RedSpah> hi all
14:24:19 <ReinH> Sindriava: the same way as other functions.
14:24:42 <Sindriava> Huh
14:24:48 <Sindriava> I'm getting a GHC stage restriction
14:24:57 <RedSpah> so I literally started using Haskell today, and I got stuck in type error hell
14:25:22 <Sindriava> RedSpah: Go on
14:25:35 <scshunt> Sindriava: that is a template haskell issue
14:25:45 <Sindriava> scshunt: Ah. How do I fix it?
14:25:45 <scshunt> you can't splice something in the module that defins it
14:25:51 <RedSpah> that's the code: http://prntscr.com/8fmqvm
14:26:16 <ReinH> RedSpah: Better to use a pastie service and to include your error message
14:26:17 <scshunt> Sindriava: define it in a different module
14:26:18 <ReinH> @where lpaste
14:26:18 <lambdabot> http://lpaste.net/
14:26:34 <Sindriava> scshunt: Oh, it was because I forgot to import Control.Lens :|
14:26:46 * Sindriava shakes fist at GHC errors
14:27:56 <RedSpah> can you directly copy text from ghci?
14:28:20 <imPure> Is there any way to pattern match on the return type of a function? I'm having trouble with GADTs.
14:28:45 <kadoban> RedSpah: What is the code supposed to do?
14:29:26 <Sindriava> kadoban: from a brief look, it can be replaced with a fold
14:29:44 <RedSpah> you have a worker with salary of x, every 2 months he gets a 10% bonus, he gets a raise of 5 every 3 months, sum the salaries from m months
14:30:09 * Sindriava cries
14:30:20 * Sindriava has flashbacks from high-school math
14:30:50 <RedSpah> wrote it in C afterwards, both return different values but I can't quite tell which is wrong
14:31:04 <Sindriava> RedSpah: Give me a sec
14:31:04 <RedSpah> the funny thing that it ain't even math homework
14:31:08 <submain> imPure: maybe you can use case .. of in the result?
14:31:36 <RedSpah> here's the error: http://prntscr.com/8fms6o
14:32:02 <submain> Why is my ghc mode not getting updated with new cabal packages? Anyone has any clues?
14:32:08 <submain> *ghc mod
14:32:34 <imPure> submain: Was trying to use guards. Not sure this is any different.
14:32:58 <kadoban> RedSpah: Can you copy-paste the code to lpaste? It's easier to play with that way
14:33:25 <RedSpah> http://lpaste.net/140776
14:33:46 <RedSpah> > redundant brackets
14:33:47 <lambdabot>  Not in scope: ‘redundant’
14:34:34 <submain> imPure: gotcha, yeah not sure about that. Still learning haskell myself!
14:34:39 <RedSpah> any less and the part of my brain that learnt the C-family wants to scream at me
14:34:45 * hackagebot hjsonschema 0.6.0.2 - JSON Schema Draft 4 library  https://hackage.haskell.org/package/hjsonschema-0.6.0.2 (seagreen)
14:35:18 <kadoban> RedSpah: Hehe. Yeah don't sweat that too much, but it's worth attempting to reduce them until you're used to it. Let me take a look.
14:38:09 <Sindriava> RedSpah: Create an infinite list of salaries, take `m` of them and `sum` it
14:38:53 <Sindriava> RedSpah: That infinite list of salaries is the initial salary (`x`) repeated infinitely, with every 3 elements being increased by 5
14:39:08 <Sindriava> RedSpah: With bonus mapped over it, where bonus multiplies it by 1.1 for even positions
14:39:15 <Sindriava> RedSpah: Also:
14:39:26 <Sindriava> > (even 1, even 2)
14:39:27 <lambdabot>  (False,True)
14:39:58 <RedSpah> > take 15 [5,5,5,10,10,10..]
14:39:59 <lambdabot>  <hint>:1:24: parse error on input ‘..’
14:40:18 <Sindriava> RedSpah: Yeah, that doesn't work. But you can do:
14:40:40 <kadoban> RedSpah: http://lpaste.net/140776 besides reformating it, all I did was separate out the m==0 case with a pattern match and add fromIntegral
14:40:45 <Sindriava> > take 12 $ mconcat [ replicate 3 (x + i * 5) | i <- [0..] ]
14:40:46 <lambdabot>  [x + 0 * 5,x + 0 * 5,x + 0 * 5,x + 1 * 5,x + 1 * 5,x + 1 * 5,x + 2 * 5,x + 2...
14:41:23 <Sindriava> > let x = 1 in take 12 $ mconcat [ replicate 3 (x + i * 5) | i <- [0..] ]
14:41:24 <lambdabot>  [1,1,1,6,6,6,11,11,11,16,16,16]
14:41:33 <Sindriava> RedSpah ^
14:41:36 <RedSpah> Sindriava thx
14:41:53 <Sindriava> RedSpah: But don't you dare copypaste that code until you know precisely what it does
14:42:00 <Sindriava> That's not how homework works
14:42:01 <kadoban> Sindriava: Just a suggestion ... I think he has to work out why the original wasn't working before worrying about implementing it in a more clever way.
14:42:21 <Sindriava> kadoban: Oh yeah, that might be a fair point
14:42:34 <Sindriava> RedSpah: Listen to kadoban, he's cleverer
14:42:46 <kadoban> Though your suggestions otherwise sound good :)
14:43:22 <Sindriava> It's an idiomatic way of solving it IMO
14:43:33 <kadoban> Yeah it looks like a nice way to go
14:43:34 <RedSpah> I understand most of it, mconcat seems to take a list of lists and concats them together
14:43:42 <RedSpah> I don't get the $ tho
14:43:55 <Sindriava> RedSpah: ($) is function application with low precedence
14:43:58 <ReinH> Sindriava: gives answer, demands that they don't use answer... that's not how answering homework questions works... :p
14:44:16 <Sindriava> ReinH: I never demanded they not use the answer.
14:44:21 <Sindriava> RedSpah: f $ blah blah blah == f (blah blah blah)
14:44:25 <kadoban> RedSpah: The key to remember about numbers in haskell is: there are /no/ implicit conversions. In C if you have and integer 5 and use it like a float -- boom, it's a float now. That doesn't happen in haskell. You have to explicitly tell it to convert it.
14:44:39 <ReinH> "Sindriava │ RedSpah: But don't you dare copypaste that code until you know precisely what it does"
14:45:06 <Sindriava> ReinH: Yeah, where is the part that demands they not use it, precisely?
14:45:16 <ReinH> Uh, the entire thing?
14:45:20 <Sindriava> ReinH: I only demanded they not use it until they know how it works.
14:45:39 <RedSpah> the homework itself was from CS, I had to figure out the algorithm itself, but I wanted to look clever and implement it, since 4/5 of the class hasn't programmed, and the remaining 20% seems to only have had c++
14:45:45 <ReinH> Do you think arguing about this is worth our time?
14:45:55 <Sindriava> ReinH: By your logic, I'd claim all numbers are even, if I stated "x is even, unless it's remainder after division is 2"
14:46:06 <Sindriava> ReinH: Is it worth yours? I've clearly not stated what you said.
14:46:13 <ReinH> Ok.
14:46:31 <kadoban> RedSpah: That is a very good idea. Actually implementing stuff will do you well.
14:47:09 <Sindriava> RedSpah: Yeah, making a solution is worth reading 5 solutions
14:47:24 <ReinH> Good job ignoring the point I was making and trying to have a pedantic argument instead.
14:47:43 <Sindriava> ReinH: Why are you so aggressive? :(
14:47:51 <ReinH> Sindriava: I'm the aggressive one?
14:48:03 <ReinH> You might reread your responses to me.
14:48:17 <kadoban> ReinH: It's very possible that they didn't understand the point you were trying to make and just saw it as a pedantic wordplay in the first place.
14:48:28 <Sindriava> ReinH: I'm sorry if me making sure I was understood correctly offended you, but I'm starting to get *really* distressed by the tone you're taking.
14:48:34 <RedSpah> Okay now how do you apply a function to every other element of the list
14:48:38 <Sindriava> RedSpah: For problems like these, it's good to manually write out first few elements and see if there's a pattern emerging :)
14:48:52 <Sindriava> kadoban: Thank you.
14:49:24 <RedSpah> oh, figuring the algorithm itself was trivial, but I wanted to use it to learn a foreign language
14:50:08 <Sindriava> RedSpah: One thing that's specific about Haskell (or indeed functional programming) is that you often describe *what things are*, instead of *how to compute them*
14:50:28 <kadoban> RedSpah: Learning Haskell that way is going to be a bit tough probably (depending on your background in other languages).
14:50:37 <Sindriava> RedSpah: That can be very confusing for people coming from imperative backgrounds.
14:50:49 <RedSpah> 5 years of C++/C# and pretty much nothing else won't be of much help
14:51:10 <kadoban> RedSpah: As to how to apply a function to every other element in a list.  Do you know about any of: zipWith, ($) and 'id` ?
14:51:44 <Welkin> > zipWith ($) (repeat [id, (+1)]) [1,2,3,4,5,6,7]
14:51:45 <lambdabot>      Couldn't match expected type ‘Integer -> c’
14:51:45 <lambdabot>                  with actual type ‘[Integer -> Integer]’
14:51:45 <lambdabot>      In the first argument of ‘repeat’, namely ‘[id, (+ 1)]’
14:51:48 <Sindriava> RedSpah: They will be of great help, but only if you don't dwell on them. Way too many people get scared when a new languages is too different
14:51:58 <kadoban> RedSpah: Ah. Yeah Haskell has /quite/ different semantics than imperative style languages. If you're serious about learning it you might want to start with a good guide, like https://github.com/bitemyapp/learnhaskell is nice.
14:52:05 <Sindriava> Welkin: You want cycle.
14:52:13 <ReinH> I still don't think providing answers that people don't understand is a good way of teaching.
14:52:27 <MarcelineVQ> > zipWith ($) (cycle [id,(*2)]) [1..10]
14:52:27 <Welkin> I always confuse repeat and cycle
14:52:28 <Welkin> haha
14:52:28 <lambdabot>  [1,4,3,8,5,12,7,16,9,20]
14:52:42 <kadoban> ReinH: I agree. (I don't think he correctly read your initial message, which made him take it the wrong way).
14:53:00 <ReinH> kadoban: That's reasonable. It wasn't clearly worded.
14:53:07 <Sindriava> ReinH: You might have wanted to actually start with that statement, yeah.
14:54:00 <kadoban> Welkin: I do too XD Like, every time *sigh*
14:54:30 <ReinH> Sindriava: fair point.
14:54:46 * hackagebot envy 0.3.0.0 - An environmentally friendly way to deal with environment variables  https://hackage.haskell.org/package/envy-0.3.0.0 (DavidJohnson)
14:55:01 <Sindriava> ReinH: Sorry if I came of as pedantic, I often sound like that since I tend to get very nitpicky about what I said and how I said it
14:55:11 <ReinH> Sindriava: I understand that impulse.
14:55:19 <ReinH> Apologies for being aggressive.
14:55:52 <Sindriava> ReinH: What you said is the reason I've been talking with them for the last 10 minutes. Personally, I find the best way to learn is to get slammed in the face with the correct, idiomatic solution and then making sure I understand it thoroughly before moving on
14:56:31 <kadoban> I don't tend to be able to learn like that, unless I'm /very/ close to understanding it already.
14:56:44 <Sindriava> Granted, it's likely because I was taught like that and it might not work for everyone
14:57:04 <kadoban> Yeah I think it depends, unfortunately. It'd be so much easier if everyone learned the same way.
14:57:18 <Sindriava> Where's the fun in that :P
14:57:28 <RedSpah> > sum (zipWith (*) (take 6 (mconcat [replicate 3 (1000 + i * 5) | i <- [0..]])) (take 6 (cycle [1.0,1.1]))) 
14:57:30 <lambdabot>  6316.0
14:57:47 <RedSpah> that seems to work
14:58:18 <Sindriava> RedSpah: But now it's unreadable. Try to slice it up into smaller chunks, parametrize them (make them into functions) and it will get a lot nicer :)
14:58:31 <Welkin> yeah
14:58:43 <Welkin> a good goal is a clean pipeline of functions composed together
14:58:59 <Welkin> f . g . h
14:59:19 <ReinH>  It'll immediately get a lot nicer if you start using composition.
14:59:19 <mniip> watcha guys doing
15:00:24 <ReinH> Also note that zipWith f (take n xs) (take n ys) = take n (zipWith f xs ys)
15:00:48 <ReinH> with no loss of efficiency
15:01:00 <ReinH> in fact, possibly improved efficiency
15:02:11 <ReinH> (this is also a nice introduction to equational reasoning, which will come in handy a very frequently)
15:03:54 <Gurkenglas> Can one (using ala, probably?) simplify loopM in the direction of loop? http://lpaste.net/137991
15:04:27 <ReinH> (.) . liftM o_O
15:05:15 <Gurkenglas> Yea, I "lens" the (either id absurd) first out of the monad, then out of the (s ->)
15:05:18 <RedSpah> what's the typeclass that includes all numbers?
15:05:28 <Sindriava> RedSpah: Num
15:05:30 <Sindriava> :t 1
15:05:32 <lambdabot> Num a => a
15:05:35 <RedSpah> thx
15:05:56 <Sonarpulse> is `setup-dependencies` part of a released version of cabal yet?
15:06:02 <ReinH> Not a fan of that pointfree stuff with (.) o_O. Anyway, it seems more obvious to me to make loop the special case of loopM for m ~ Identity
15:07:07 <Gurkenglas> Yes, I added the last line just now as an afterthought to compare loopM to.
15:07:34 <RedSpah> http://lpaste.net/140783 I tried
15:07:38 <ReinH> if 15..19 is a valid definition of loopM then I prefer it infinitely to the given definition.
15:07:49 <indiagreen> ReinH++
15:08:05 <ReinH> I literally have no idea what the given definition is doing, but that one is obvious.
15:08:29 <Guest20394> I'm new to Haskell and still learning, I wish to represent: S = {2-x|x <- [s..e], x `isPrime`}, is there a function for prime checking or do I need to write one?
15:08:30 <cads> hey al
15:09:08 <srhb> Guest20394: The primes package has one such function.
15:09:21 <ReinH> I might use loopM f s = either return (loopM f) =<< f s
15:09:31 <srhb> Guest20394: It's ancient though, so not sure it even builds these days.
15:09:36 <ReinH> which has the advantage of preventing a misuse of s insteaf of s'
15:09:46 <ReinH> But I would never use the given definition
15:10:12 <srhb> Guest20394: Oh, it does. :)
15:10:18 <Gurkenglas> ReinH, 10..13 makes the (s -> m (Either e s)) go: (s -> EitherT e m s), (StateT s (Either e m) ()), (StateT s (Either e m) Void), (s -> EitherT e m Void), (s -> m (Either e Void)), (s -> m e).
15:10:26 <Guest20394> srhb: Thanks, I'll check it out.
15:10:37 <ReinH> Gurkenglas: You mistake me... I don't even want to understand it. :p
15:10:41 <ReinH> I want to kill it with fire.
15:11:22 <kadoban> srhb: It does, I use that thing all the time.
15:11:39 <kadoban> Oh you realized ... I should read more before I answer.
15:11:56 <srhb> kadoban: In fairness I should have just tried before voicing my doubt (since I was going to anyway) :P
15:12:12 <kadoban> Hehe
15:12:35 <Gurkenglas> The advantage of my way is that it cannot possibly bs used to accidentally have the Either type arguments the wrong way round as https://hackage.haskell.org/package/extra-1.4.1/docs/Control-Monad-Extra.html#v:loopM does <.<
15:12:40 <Sindriava> Bad indiagreen, we don't do incrementation in here!
15:12:58 <Guest20394> srhb: Is there a program in Haskell for quickly retrieving libraries?
15:13:08 <ReinH> Guest20394: How is that possible with mine?
15:13:09 <srhb> Guest20394: cabal-install, stack...
15:13:15 <ReinH> er, Gurkenglas^
15:13:18 <ReinH> Guest20394: sorry
15:13:30 <srhb> Guest20394: Usually you'll have the cabal install command available with any haskell installation
15:13:33 <indiagreen> Sindriava: well, you could punish me by using “--”, but since you're opposed to “++”, I guess you would be equally opposed to “--”, mmhm
15:13:49 <kristof> Where are the ghc and ghci binaries locaated on OSX?
15:13:54 <Sindriava> indiagreen - 1 ? :D
15:14:08 <srhb> kristof: Have you tried `which` ? I assume that's available even on OS X
15:14:19 <kristof> srhb: Not my computer.
15:14:20 <Sindriava> kristof: That depends on your installation.
15:14:22 <srhb> Ah :)
15:14:25 <RedSpah> so, more hell http://prntscr.com/8fnb8v
15:14:41 <kristof> srhb: Friend's. I tried everything but we couldn't get ghc working.
15:14:42 <ReinH> Gurkenglas: Frankly, that is the least readable haskell code I have ever seen.
15:14:47 <Sindriava> kristof: Haskell platform installs into /Library, I think, while homebrew installs into /usr/local/Cellar IIRC
15:14:51 <ReinH> And that includes various code golf answers.
15:15:02 <kristof> Sindriava: Yeah, but /Library/Haskell/bin has no ghc executable
15:15:07 <srhb> RedSpah: You're applying sum to a function `take`
15:15:16 <kristof> It has a ghc-clang wrapper thing.
15:15:38 <Sindriava> kristof: Then they're probably using the Haskell platform
15:15:40 <Sindriava> which is horrible
15:15:50 <ReinH> Wow... StateT s m ()...
15:15:50 <RedSpah> well, doesn't sum take a Num list, and doesn't take return a list?
15:15:57 <srhb> RedSpah: In fact, you're applying it to three arguments: take, m and (zipWih ...)
15:15:57 <Sindriava> kristof: `brew install ghc cabal-install` should get you up and running, and it's much better IMO
15:16:03 <srhb> RedSpah: take is not a list.
15:16:06 <geekosaur> ah yes, polatform as root of all evil that cabal is not the ultimate root of
15:16:08 <srhb> RedSpah: That's the important thing.
15:16:11 <Sindriava> kristof: As for your *current* problem I can't help, sorry :(
15:16:14 <geekosaur> use the one approved thing or else
15:16:22 <kristof> geekosaur: Is that sarcasm?
15:16:27 <srhb> RedSpah: If you want to apply sum to the result of take m ... then you'll have to use sum (take m ...)
15:16:29 <geekosaur> preferably approved by a web framework which is your only god now
15:16:33 <ReinH> Even managed to pull in void
15:16:34 <kristof> Ok.
15:16:40 <ReinH> That's.. impressive?
15:16:55 <kristof> I've been using Haskell for about 3 years now on Linux, never had a problem.
15:17:16 <Gurkenglas> ReinH, 15..19 and https://hackage.haskell.org/package/extra-1.4.1/docs/src/Control-Monad-Extra.html#loopM are easily mixed up, while I don't think it is possible to use EitherT to implement the latter without explicitly using something like swap at some point.
15:17:26 <Sindriava> RedSpah: Function application has the highest precedence in haskell, so `foo a b` is equal to `(foo a) b`
15:17:27 <kristof> But my friend is a professional C# developer used to Visual Studio and has OSX, and I didn't want to throw emacs at him.
15:17:52 <Sindriava> kristof: Emacs? Did I miss something? O.o
15:17:54 <srhb> RedSpah: There are different ways to write this (using composition and low-precedence function application, called $) but it's important to understand that normally, it has such high precedence that foo bar baz always means apply foo to arguments bar and baz, NOT apply foo to (bar baz)
15:17:56 <geekosaur> I get just a little bit tired of you will use stackage the son of yesod because it is your god, you will use stack the father of yesod because it is your god, you will use everything yesod
15:18:10 <Sindriava> RedSpah: If you want to forward from one function to another, you use (.)
15:18:15 <Sindriava> :t (.)
15:18:16 <ReinH> Gurkenglas: What about my definition?
15:18:16 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:18:26 <kristof> Sindriava: Well, no, you didn't. I wanted him to use Sublime or Atom. Something nice. But then I remembered, ah, ghc-mod
15:18:30 <Gurkenglas> Oh, I didn't see yours. Where is it?
15:18:47 <kristof> Sindriava: So I told him to install ghc-mod. And that's when the problems started.
15:18:55 <Sindriava> kristof: oh boy.
15:18:58 <ReinH> whileRight k s = either return (whileRight k) =<< k s
15:19:07 <kristof> Sindriava: He was using ghci. cabal install ghc-mod
15:19:12 <kristof> cabal: command not found
15:19:20 <Sindriava> kristof: How about "Haskell for Mac" ?
15:19:23 <Guest20394> How do I view the man page of a haskell library?
15:19:33 <ReinH> @where hackage
15:19:33 <lambdabot> <http://hackage.haskell.org/package/>, also see `revdeps'
15:19:34 <kristof> Sindriava: GHC for OSX. Tried that. That's ANOTHER funny error.
15:19:35 <srhb> Guest20394: Look them up on Hackage, usually.
15:19:52 <Sindriava> kristof: http://haskellformac.com ?
15:19:55 <Guest20394> srhb: So there's no way to do it from a shell?
15:19:56 <kristof> Sindriava: ar: permission denied. That was supposed to be fixed by GHC 7.10
15:20:02 <ReinH> Uh, I don't think "see `revdeps'" is very useful, but anyway
15:20:13 <srhb> Guest20394: Yes, if haddocks have been built locally. I've no idea how though, never actually tried.
15:20:24 <Sindriava> Guest20394: There's the `hoogle` command line utility too.
15:21:00 <kristof> Sindriava: Oh. That's nice.
15:21:02 <Guest20394> srhb: sindriava: Thanks.
15:21:11 <Gurkenglas> ReinH, "whileLeft k s -> either (whileLeft k) return =<< k s" does the other way
15:21:13 <kristof> Sindriava: Does it manage the GHC stuff for the user?
15:21:17 <Sindriava> kristof: It's 25 bucks, though O.o I though it was free
15:21:20 <Sindriava> kristof: No idea
15:21:23 <ReinH> Gurkenglas: sure?
15:21:38 <Welkin> 7.10.2 works on osx
15:21:43 <Welkin> 7.10.1 has problems though
15:22:03 <Gurkenglas> Rein, by accidentally, I meant that someone who is not aware that the left side of either ought to stand for aborting the computation might implement either of the two ways. Using EitherT, one would have trouble doing the wrong one.
15:22:07 <Gurkenglas> *ReinH
15:22:21 <RedSpah> > sum . take 6 (zipWith (*) (mconcat [replicate 3 (1000 + i * 5) | i <- [0..]]) (cycle [1.0,1.1]))
15:22:22 <lambdabot>      Couldn't match expected type ‘a -> t0 c’
15:22:22 <lambdabot>                  with actual type ‘[Double]’
15:22:22 <lambdabot>      Possible cause: ‘take’ is applied to too many arguments
15:22:27 <ReinH> Gurkenglas: I think it's easier to make a mistake while writing a function I find incomprehensible than while writing one that I find easy and obvious.
15:22:27 <Sindriava> kristof: Presumably it does, because Mac App Store requires the apps to be sandboxed
15:22:32 <srhb> Gurkenglas: Obviously it should be Wrong e | Right a
15:22:58 <Gurkenglas> srhb, people might still read that as "Continue poking the Wrong value until it turns into a Right one"
15:23:03 <srhb> :P
15:23:46 <ReinH> Gurkenglas: If you want to use EitherT, I'd much much prefer to just use a version with do notation than that pointfree abomination
15:24:12 <RedSpah> > sum (take 6 (zipWith (*) (mconcat [replicate 3 (1000 + i * 5) | i <- [0..]]) (cycle [1.0,1.1])))
15:24:13 <lambdabot>  6316.0
15:24:30 <Sindriava> I greatly prefer the Rust version " Ok value | Error value"
15:24:43 <Sindriava> eh
15:24:45 <ReinH> :t sum . take 6 . zipWith (*)
15:24:46 <lambdabot>     Couldn't match type ‘[c1] -> [c1]’ with ‘[c]’
15:24:46 <lambdabot>     Expected type: [c1] -> [c]
15:24:46 <lambdabot>       Actual type: [c1] -> [c1] -> [c1]
15:24:50 <scshunt> Sindriava: Ok = Right, Error = Left.
15:24:52 <scshunt> there you go, done
15:24:52 <Sindriava> ` Ok v | Error e `
15:25:02 <kristof> It's actually Err :)
15:25:08 <ReinH> That's the biggest issue with function composition: it doesn't plug in cleanly with functions that take multiple arguments.
15:25:11 <kristof> Sindriava: You would be greatly interested in... 
15:25:19 <Sindriava> kristof: Woop
15:25:32 <Beardful> Juicypixels repa has a function 'onImg', it has a type :: (Array -> Array) -> img a -> img a. I'd like to print out the largest value on that array and then return the array, but im thinking it'll be impossible because onImg type doesn't allow to return IO, right?
15:25:32 <kristof> Sindriava: http://m4rw3r.github.io/parser-combinator-experiments-part-3/
15:25:36 <RedSpah> > sum . take 6 . zipWith (*) (mconcat [replicate 3 (1000 + i * 5) | i <- [0..]]) (cycle [1.0,1.1])
15:25:38 <lambdabot>      Couldn't match expected type ‘a -> [c]’ with actual type ‘[Double]’
15:25:38 <lambdabot>      Possible cause: ‘zipWith’ is applied to too many arguments
15:25:38 <lambdabot>      In the second argument of ‘(.)’, namely
15:26:11 <RedSpah> braces, man
15:26:15 <Sindriava> Oh wow, attoparsec is *fast*
15:26:19 <ReinH> Either isn't an error type, it's the canonical sum type, whose injections are canonically called left and right :p
15:26:25 <kadoban> ReinH: I always kinda wonder why there aren't more combinators like (.) commonly used. I know at one point I was using like (.:) for two arguments and something else for 3, etc. It was kinda nice, but also kinda funky because nobody else would be able to read it.
15:26:27 <ReinH> its use as an error type is a specialization
15:26:53 <Sindriava> RedSpah: You can't do (.) on a fully applied function
15:27:02 <Sindriava> RedSpah: Look:
15:27:04 <kristof> Sindriava: That same guy is working on a very large writeup about all the problems that need to be resolved before Higher Kinded Types can ever hit Rust
15:27:04 <Sindriava> :t (.)
15:27:06 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:27:14 <Sindriava> :t (const 1)
15:27:15 <lambdabot> Num a => b -> a
15:27:20 <Sindriava> :t (const 1 2)
15:27:22 <lambdabot> Num a => a
15:27:43 <Sindriava> :t (const 1) . (const 2)
15:27:44 <lambdabot> Num c => b -> c
15:27:48 <Sindriava> :t (const 1) . (const 2 3)
15:27:49 <lambdabot> (Num c, Num (a -> b)) => a -> c
15:27:57 <Sindriava> Wait, what
15:28:04 <exio4> numbers are polymorphic
15:28:06 <exio4> @type 42
15:28:08 <lambdabot> Num a => a
15:28:28 <srhb> Sindriava: Clearly if you can give a Num (a -> b) instance, that's fine :-P
15:28:38 <Sindriava> (╯°□°）╯︵ ┻━┻
15:28:45 <ReinH> The use of Right for the success case would be entirely arbitrary if it weren't for the way higher-kinded types work with typeclasses (Either a is a Monad, but \a -> Either a b can't even be expressed directly)
15:28:55 <RedSpah> let's skip the dots, there's more type error magic up ahead
15:28:56 <Cale> > 1 2
15:28:58 <lambdabot>      Could not deduce (Num a0)
15:28:58 <lambdabot>      from the context (Num a, Num (a -> t))
15:28:58 <lambdabot>        bound by the inferred type for ‘e_112’: (Num a, Num (a -> t)) => t
15:28:58 <kadoban> I still think GHC should give a better hint for that ...
15:29:02 <Sindriava> (╯°□°）╯︵ ʇoqɐpqɯɐl
15:29:08 <MarcelineVQ> how do I generate a list of functions? like say I want an infinite list of the partial function (^n), like this if it worked `map (\x->(^x)) [1..]`
15:29:23 <Sindriava> MarcelineVQ: repeat (^n) ?
15:29:24 <kadoban> Like, has /anyone/ ever wanted  (Num (a -> c)) ? It has to at least be rare. GHC should really bold that or something, heh.
15:29:29 <sinelaw> is there / where is there an ST transformer?
15:29:33 <jmcarthur> yes
15:29:36 <Sindriava> MarcelineVQ: Oh, nevermind, I read it wrong
15:29:38 <jmcarthur> i use that instance often
15:29:51 <scshunt> > map (\x -> (^x)) [1..]
15:29:53 <jmcarthur> i wish it was in the standard library despite that it's not super beginner friendly
15:29:53 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>,<Integer -> ...
15:30:00 <scshunt> I don't see why you say it doesn't work...
15:30:02 <ReinH> :t map (\x -> (^ x)) [1..]
15:30:03 <lambdabot> Num a => [a -> a]
15:30:04 <kadoban> jmcarthur: Really? Oh ...
15:30:11 <ReinH> MarcelineVQ: It works.
15:30:13 <Sindriava> scshunt: Woops
15:30:49 <MarcelineVQ> oh, well then, I guess I read the error wrong. It was probably warning me that it couldn't show partial functions. oops :X
15:30:57 <jmcarthur> kadoban: a cute example:   sin^2 + cos^2
15:30:58 <Cale> @let instance Num b => Num (a -> b) where { (f + g) x = f x + g x; (f * g) x = f x * g x; negate f x = negate (f x); fromInteger n x = fromInteger n; abs f x = abs (f x); signum f x = signum (f x) }
15:31:00 <lambdabot>  Defined.
15:31:03 <MarcelineVQ> that'll teach me to not check with :t
15:31:17 <Cale> > (sin^2 + cos^2) 5
15:31:19 <lambdabot>  0.9999999999999999
15:31:41 <exio4> (Applicative f, Num a) => Num (f a) where ... :p 
15:31:41 <ReinH> Cale: I really enjoy that instance.
15:31:46 <jmcarthur> yes, it lets you be overly "clever", but it also lets you write some pretty easy to understand code
15:31:55 <jmcarthur> and it's really convenient sometimes
15:31:55 <kadoban> Oh hah, that's ... cute as hell.
15:32:11 <ReinH> If you're doing a bunch of math it becomes very elegant
15:32:46 <ReinH> as in, translating mathematical formula into haskell
15:32:58 <Cale> > 7 8 9
15:32:59 <lambdabot>  7
15:33:04 <ReinH> hahaha
15:33:06 <jmcarthur> there's a confusing example
15:33:19 <RedSpah> so now ghc seems to have an issue with this http://lpaste.net/140786
15:33:32 <jmcarthur> turns out numeric literals swallow anything they are applied to! can be very beginner unfriendly
15:33:47 <kadoban> Haha yeah someone had that instance defined in lambdabot before and it confused the crap out of me for a minute when I was playing with something else.
15:33:49 <srhb> :t replicate
15:33:50 <ReinH> jmcarthur: Yep, best to not do that then. ;)
15:33:50 <lambdabot> Int -> a -> [a]
15:34:13 <srhb> RedSpah: replicate does not take an Integral p => p as its first argument, but an Int
15:34:14 <jmcarthur> i don't think the needs of a beginner should outweight the convenience of the expert
15:34:18 <jmcarthur> *outweigh
15:34:45 <ReinH> the needs of the many or something
15:34:47 <kadoban> jmcarthur: It's almost like there should be two different modes though, like beginner mode that gives different error hints than an expert would need.
15:34:51 <jmcarthur> good teaching materials, good error messages, etc. blah blah blah
15:35:00 <jmcarthur> i'm not against such ideas
15:35:36 <srhb> RedSpah: You're also missing an Enum constraint for [0..]
15:36:08 <jmcarthur> well, i'm against making error messages harder to understand for experts just because they don't need as much. good error messages are good for everybody.
15:36:11 <kadoban> Of course figuring out what things need different messages depending on if you're a beginner or not is pretty hard ... sigh.
15:36:28 <jmcarthur> but i think something like a more limited version of haskell for beginners wouldn't be so bad.
15:36:39 <srhb> RedSpah: You should try reading the error messages again with this knowledge, they're saying exactly what I just did. Pay particular attention to "... in the first argument of ..." in the Int error.
15:36:45 <jmcarthur> as long as it's easy to turn on, and is compatible with libraries written in "expert mode"
15:37:05 <Sindriava> jmcarthur: IMO Elm managed to make easy error messages while retaining information
15:37:29 <Sindriava> jmcarthur: A lot of the time you don't need less information in the error message, you just need to word it differently
15:37:32 <jmcarthur> anyway, no error message could fix   7 8 9
15:37:44 <jmcarthur> that would just need to be turned off for beginners
15:38:14 <jmcarthur> (because obviously it doesn't generate an error!)
15:38:26 <RedSpah> How to precise the type of the argument to Int? (substituting Integral for Int produces yet another error)
15:38:36 <srhb> RedSpah: Int is a type, not a type class
15:38:50 <RedSpah> I've gathered this much
15:38:51 <srhb> RedSpah: so your constraints => b -> b -> Int -> [b]
15:38:52 <exio4> which is an instance of a typeclass, with magically, happen to be intrusive, and if any library the beginner is using happens to put that instance in scope, ...
15:38:59 <Sindriava> RedSpah: `Integral a => a` -> `Int`
15:39:13 <RedSpah> oh
15:40:19 <RedSpah> I can't find anything on enum constraints, mind enlightening me?
15:40:36 <srhb> RedSpah: You can't do [n..] on any type that is not an instance of Enum
15:40:51 <srhb> RedSpah: So you must add that constraint to the return type, since that is the type of i as well.
15:40:58 <srhb> Er, to b, rather.
15:41:05 <jmcarthur> @info Enum
15:41:06 <lambdabot> Enum
15:41:08 <jmcarthur> wow
15:41:10 <ReinH> jmcarthur: Well, luckily it isn't turned on for beginners in the first place :)
15:41:11 <srhb> RedSpah: You can also query ghci with :i Enum
15:41:12 <jmcarthur> such useful
15:41:20 <srhb> RedSpah: To see which methods it exposes :)
15:41:23 <jmcarthur> ReinH: luckily for beginners, at least
15:41:30 <Sindriava> RedSpah: Enum are types that can be enumerated. The bare minimum is the `succ` functions, which returns the next element
15:41:30 <ReinH> I can always import it if I need it.
15:41:33 <Sindriava> :t succ
15:41:34 <lambdabot> Enum a => a -> a
15:41:37 <Sindriava> > succ 'a'
15:41:39 <lambdabot>  'b'
15:41:51 <ReinH> jmcarthur: Or probably there's some alternative prelude I could use.
15:41:53 <jmcarthur> i don't like relying on an orphan instance
15:42:01 <Sindriava> RedSpah: That's how [a..] works. it returns [a, succ a, succ (succ a), …]
15:42:12 <ReinH> jmcarthur: fair point
15:42:25 <RedSpah> so, how do I specify that i is an Enum?
15:43:11 <srhb> RedSpah: By specifying that b is one.
15:43:45 <srhb> RedSpah: They are the same type.
15:43:49 <Sindriava> RedSpah: Enum is a type constraint, just like Integral
15:44:01 <RedSpah> finally done
15:44:08 <RedSpah> thanks a lot for help guys
15:45:51 <Sindriava> RedSpah: Happy to help
15:46:33 <Sindriava> RedSpah: Feel free to message me directly, if you need anything
15:50:09 <arkeet> > let a = False in [a, succ a, succ (succ a), succ (succ (succ a))]
15:50:11 <lambdabot>  [False,True,*Exception: Prelude.Enum.Bool.succ: bad argument
15:50:43 <Sindriava> > True > False
15:50:45 <lambdabot>  True
15:50:47 <Sindriava> neat
15:51:26 <arkeet> Enum kind of sucks.
15:51:33 <arkeet> (or succs?)
15:54:48 * hackagebot postgresql-schema 0.1.5 - PostgreSQL Schema Management  https://hackage.haskell.org/package/postgresql-schema-0.1.5 (markfine)
15:54:53 <RedSpah> heh, and I thought C# type checking was anal because it didn't allow me to implicitly cast short to int
15:55:44 <Sindriava> RedSpah: You shouldn't mostly run into those issues. Often these issues signify too strict types
15:56:19 <Sindriava> RedSpah: For example, if you were to define (+) as Int → Int → Int, you'd get lots of type errors. But since it's Num a => a → a → a, you can add all sorts of stuff
15:57:18 <RedSpah> compared to C where you could probably cast Tank to a float and compiler would oblige, with crashing at runtime ofc
16:01:18 <some_types> New to haskell. Suppose I define two sum types, like Foo = A | B and Bar = C | D. How can I make the type A | B | C | D? Doing it explicitly is no good, as Foo or Bar might be the union of many more than two things.
16:01:37 <quchen> Either Foo Bar
16:01:44 <Sindriava> quchen + 1
16:02:25 <kadoban> some_types: That ^ or you can do something like       data Baz = F Foo | G Bar
16:02:39 <Cale> some_types: Note that if you use Either Foo Bar, you will have to use Left A, Left B, Right C, and Right D
16:02:41 <Sindriava> kadoban: Which is… Either? O.o
16:02:58 <Sindriava> :i Either
16:03:02 <some_types> There also may be many more than two of Foo and Bar, so these will get many layers deep (which seems no good to me)
16:03:02 <quchen> Sindriava: Up to naming, ye.s
16:03:06 <quchen> There is no :i in Lambdabot.
16:03:11 <Cale> Sometimes defining a type like kadoban mentioned makes sense because you have more specific names that you can use.
16:03:15 <Sindriava> @info Either
16:03:16 <lambdabot> Either
16:03:22 <Sindriava> I don't know why I even try
16:03:35 <Sindriava> Cale + 1, good point
16:04:54 <Sindriava> some_types: Anyways, why do you want to do this?
16:05:15 <some_types> It's really more like Foo1 = A | B, Foo2 = C | D, Foo3 = E | F, and I want to generate A | B | C | D, and then A | B | C | D | E | F, for various values of 3
16:05:16 <Hijiri> I remember there was some discussion on haskell-cafe about someone wanting anonymous unions
16:05:43 <Sindriava> some_types: That sounds weird. Try describing your use case
16:05:47 <Sindriava> @where xyproblem
16:05:48 <lambdabot> xyproblem.info
16:06:54 <pavonia> Is there a way to make attoparsec parse only a prefix of a bytestring and return a pair of that prefix and the rest of the input?
16:07:34 <Cale> some_types: Haskell doesn't have untagged union types and it doesn't have subtyping.
16:08:06 <Cale> some_types: The problem with allowing something like a union of Foo1 and Foo2 with all the constructors of both, is that when you see B for instance, you don't know how to infer its type.
16:08:18 <some_types> Okay, so these types represent operations (not that it matters). We have OpA = AddA | SubA | ... | MulA and OpB = AddB | SubB | ... | MulB | OpThatsOnlyInB | DivB, and I'd like to map AddA -> AddB, SubA -> SubB, ..., MulA -> MulB.
16:08:26 <Cale> This leads to lots of ambiguities and makes the language annoying to use.
16:08:37 <Sindriava> some_types: You want higher ranked types IMO
16:08:56 <Sindriava> some_types: Or even just parametric ones?
16:09:19 <some_types> Yeah, but I am only working with sums of, like, really simple things. Don't know what they're called. Like when you write Foo = A | B, A and B don't have any other structure
16:09:27 <Cale> some_types: How about  data OpB = A OpA | OpThatsOnlyInB
16:09:38 <ttt_fff> besides ghcjs / threepenny, is there a way to do DOM based GUI in haskell?
16:09:39 <Hijiri> pavonia: (,) <$> prefixParser <*> (takeWhile (const True) <* endOfInput) ?
16:09:42 <ttt_fff> (or any type of GUI at all on OSX) ?
16:10:15 <Hijiri> not sure if there's a preexisting parser that just gets the rest of everything
16:10:16 <MarcelineVQ> some_types: Types of operations? This might be useful for you when you have time to read it https://en.wikibooks.org/wiki/Haskell/GADT
16:10:21 <some_types> that doesn't scale when you have A, B, C, D, ...
16:10:31 <Welkin> Opa!
16:10:34 <some_types> because then D becomes C ( B (A Add))
16:11:27 <Cale> some_types: Well, maybe tell us about what you're actually trying to represent then
16:11:32 <pavonia> Hijiri: Ah, thanks
16:12:04 <Cale> some_types: So we can try to design something saner. It's hard to do this well without knowing what's really happening.
16:13:37 <some_types> Cale: uh, so it's a compiler for a language that's sort of like C, and it has intermediate representations of the language that add more and more operations as you get closer to assembly. I don't think there's much more designing you can do.
16:15:02 <Hijiri> I would probably just give each representation its own datatype
16:15:56 <Cale> Yeah, that's reasonable.
16:16:11 <Cale> There are some fancy things you can pull off with GADTs
16:16:49 <Cale> Where you define a single big type for all the languages, but index the results based on which intermediate languages the operations are allowed in
16:17:07 <some_types> Cale: oh, that sounds pretty good
16:17:11 <Cale> That's handy in that you can then define polymorphic operations
16:17:56 <some_types> Cale: how do you do this indexing thing?
16:18:34 <Cale> So you'd have some types for each of the levels whose only purpose is to serve as a tag
16:18:44 <Cale> data Level1 = Level1
16:18:47 <Cale> data Level2 = Level2
16:18:49 <Cale> etc.
16:19:01 <Cale> and then you have something like:
16:19:12 <Cale> data Operation a where
16:19:24 <Cale>    Add :: ... -> Operation Level1
16:20:16 <exio4> Cale: data Level = Level1 | Level2 | Level3 ; data Operation (a :: Level) where ... with DataKinds! :P 
16:20:41 <Cale> exio4: Yeah, you can do that as well, which is a bit nicer.
16:20:56 <Cale> (but requires learning about one more extension)
16:20:58 <exio4> and then you add type families for working with multiple levels (some LTE function), and end rewriting the code in Idris :p 
16:21:07 <Cale> yep
16:21:09 <Cale> Pretty much
16:21:15 <Cale> haha
16:21:31 <some_types> I'm not sure I understand this: 
16:21:32 <some_types> Add :: ... -> Operation Level1
16:22:13 <Cale> some_types: I'm assuming that Add has some arguments there, if it doesn't, it would just be  Add :: Operation Level1
16:22:37 <some_types> oh, nope, no arguments.
16:23:02 <some_types> okay, I think that works.
16:23:02 <Cale> (usually addition has operands ;)
16:23:39 <some_types> Yeah, lol, it's possibly more useful to think of this as a plus sign
16:23:42 <Cale> So yeah, now the tricky part is that you're going to want to be able to express that something has level less than or equal to 3 or something like that
16:24:02 <some_types> nah, I can just make Level2 = Level2 | Level1
16:24:06 <Cale> huh?
16:24:09 <Cale> nope
16:24:49 <some_types> most of the requirements should be "greater than or equal to"
16:25:46 <Cale> Right, so you'll have to implement "greater than or equal to" at the type level
16:25:51 <some_types> In any case, I think this is all I needed. Thanks a bunch :)
16:25:57 <Cale> Possibly using type families as exio4 suggested
16:26:08 <Cale> Something like:
16:26:32 <exio4> defining a type family from Level to Nat and then use GHC.TypeLits operations or what I would do, pretty much
16:26:51 <exio4> (given that there's only one way to order anything)
16:27:48 <exio4> something like this http://lpaste.net/139730 may be nicer if there's no such ordering, for some definition of `nicer` :P 
16:28:01 <Sindriava> Holy fucking shit
16:28:02 <Sindriava> https://www.youtube.com/watch?v=UIWWLg4wLEY
16:28:34 <Sindriava> Wait, this isn't #haskell-blah, dammit
16:29:55 <some_types> Cale: exio4: oh. I see why my suggestion is no good.
16:30:26 <some_types> time to read about type families
16:31:47 <Cale> some_types: In the end, doing this kind of type level programming in Haskell is not always worth the trouble.
16:32:17 <Cale> some_types: given that there's an easy solution which is just to define each of your languages separately and write some functions between them which say how one is mapped to the next
16:32:52 <some_types> well, when there are like 30 operations and quite a few languages, that's pretty cumbersome
16:33:22 <Cale> It's a bit cumbersome, but it's not tricky in any way.
16:33:41 <Cale> Depending on how you feel like spending your time, I guess. :)
16:34:49 * hackagebot bson-lens 0.1.0 - BSON lenses  https://hackage.haskell.org/package/bson-lens-0.1.0 (WilliamCasarin)
16:34:52 * hackagebot bson-lens 0.1.1 - BSON lenses  https://hackage.haskell.org/package/bson-lens-0.1.1 (WilliamCasarin)
16:43:34 <int-index> http://lpaste.net/1886180053914484736 Is there such `actCont` that `runActCont1` and `runActCont2` would have different behavior?
16:43:41 <Guest44711> I wish to read to documentation of a library in Haddock, where are they located and how do I do such?
16:43:54 <Guest44711> s/to d/the d
16:44:59 <int-index> Guest44711: If you want documentation for a package published on Hackage/Stackage, you can read the documentation online. If you want local documentation, it depends on how you've installed the library.
16:45:36 <Guest44711> int-index: I installed it via cabal, care to expand?
16:46:33 <int-index> If you installed the library globally by doing `cabal install LIBNAME`, not being in a cabal sandbox, then the documentation is in `~/.cabal/share/`
16:46:49 <ReinH> ... if you've turned on documentation in your cabal config
16:46:56 <ReinH> which is off by default for... reasons... I guess.
16:47:27 <ReinH> (See monochrom's http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml)
16:47:52 <int-index> Guest44711: If the documentation is not there (look for `index.html`), you might need to reinstall the library with `--enable-documentation` flag.
16:48:56 <int-index> If you want to build local documentation for all libraries you install, enable documentation in your `~/.cabal/config`
16:49:19 <Guest44711> int-index: ReinH: Thanks.
16:50:25 <MarcelineVQ> Just to add, if you're after standard library documentation, you can find it here https://downloads.haskell.org/~ghc/latest/docs/html/libraries/
16:50:56 <MarcelineVQ> Or just search hoogle
16:51:43 <int-index> MarcelineVQ: It's also on Hackage
16:51:51 <ReinH> @hackage base
16:51:51 <lambdabot> http://hackage.haskell.org/package/base
16:56:46 <trvoldemort> Hello, TESTING! Don't reply.
16:59:48 <drewbert> Is there a set of higher-order abstractions for template haskell functions? Let's say I have a Name of a TyCon and I want to list the names of all the Con for its DataD, is there an easy way to go about doing that?
16:59:50 * hackagebot cuda 0.6.7.0 - FFI binding to the CUDA interface for programming NVIDIA GPUs  https://hackage.haskell.org/package/cuda-0.6.7.0 (TrevorMcDonell)
17:01:57 <drewbert> Haskell could benefit from an introspection library, even if it only contained convenience functions.
17:09:55 <Gurkenglas> Yes please.
17:25:38 <Big_G> What is the best way to handle exceptions in web apps?
17:27:16 <KaneTW> usually Either
17:27:45 <ReinH> Big_G: depends on what you're using to build your web app and what kind of exception
17:27:46 <Big_G> That's what I thought
17:28:01 <ReinH> scotty has the ScottyError typeclass, for instance
17:28:07 <Big_G> ReinH, It is in Java but I'm trying to write it in a style close to Haskell
17:28:25 <Big_G> I implemented it with Either but the senior dev didn't like it
17:28:30 <KaneTW> well yeah
17:28:33 <KaneTW> because you're coding in java
17:28:37 <KaneTW> in java just use exceptions
17:28:47 <ReinH> When in rome.
17:28:49 <KaneTW> each language has tools appropriate for the task
17:28:52 <KaneTW> ^
17:28:58 <KaneTW> don't be a cargo cult functional programmer
17:29:08 <Big_G> Yeah but I've been having a lot of stupid issues because of it
17:29:16 <Big_G> like exceptions popping out of no wher
17:29:27 <ReinH> I thought that was a rite of passage as a Java programmer...
17:29:30 <KaneTW> welcome to java
17:29:48 <Rembane> Isn't that a feature?
17:30:02 <ReinH> Rembane: if all else fails, call it a feature!
17:30:04 <Big_G> ReinH, I've been through that rite of passage. Now I want to avoid it
17:30:12 <ReinH> Big_G: stop writing Java?
17:30:28 <Big_G> ReinH, Have stuff fail randomly and not in the form of a return value
17:30:28 <KaneTW> well obviously not an option for him
17:30:37 <Big_G> but not writing Java would be good too
17:30:41 <ReinH> Yeah, getting paid sure is a motivator...
17:30:49 <KaneTW> use `throws' to document what your methods can throw
17:30:59 <KaneTW> make custom exception types
17:31:09 <Big_G> KaneTW, I have been but a lot of our code doesn't have that
17:31:19 <KaneTW> bring that issue up with your head dev
17:31:20 <Rembane> ReinH: I do it with almost everything nowadays! The world will never become featurecomplete!
17:31:27 <Big_G> We have some custom types but they get generalize later on to all be runtime exceptions
17:32:00 <Big_G> KaneTW, I did. I showed him the either solution and he just shook his head and said fp people are hippies
17:32:18 <KaneTW> either isn't a solution in java
17:32:31 <KaneTW> if he tells you to catch Exception just tell him it's a bad idea, cover your ass (save the email or whatever) and do it
17:32:51 <KaneTW> talk with your devs because there seems to be a documentation issue at your place and there isn't much you can do about that
17:32:55 <Big_G> KaneTW, Is there a way to improve the situation rather than cover my ass?
17:32:55 <KaneTW> maybe ask in #java
17:33:14 <KaneTW> use appropriately specialized exceptions, that's about it
17:33:16 <Big_G> KaneTW, I'll do that but wanted to get your all opinions first
17:33:28 <augur> is this familiar to anyone?    data FList f a = Nil | Cons a (f (FList f a))
17:33:31 <KaneTW> if they all get generalized you don't have an option short of refactoring the whole thing
17:33:48 <KaneTW> augur: looks like a free monad with some extra data
17:35:31 <KaneTW> i don't know whether it's actually free though
17:36:39 <adas> ultimately are type families and data kinds and all those other type extensions about promoting types as first class values in haskell?
17:37:25 <Big_G> ReinH, I don't imagine you know of any good non-java jobs, do you?
17:38:23 <ReinH> Big_G: Well, Heroku is hiring for Ruby and, I believe, Go
17:38:32 <ReinH> Unless they decided to drop go
17:38:39 <Big_G> I can't say I've heard good things about those languages
17:38:57 <ReinH> Ruby is definitely better than Java. Go is awful.
17:39:07 <ReinH> But probably better than Java.
17:39:11 <Big_G> ReinH, Why did you say that? I've heard Ruby is super unsafe
17:39:31 <ReinH> And here we are having a discussion about lack of expection safety in Java ;)
17:39:38 <ReinH> *exception
17:39:44 <KaneTW> Ruby is at least not terrible to program in from what I heard
17:39:56 <KaneTW> Python seems fine.
17:40:15 <KaneTW> check https://news.ycombinator.com/item?id=10152809
17:40:45 <ReinH> Ruby is as safe as you make it.
17:40:48 <Big_G> I have to go for a bit but we can continue when I get back
17:40:59 <ReinH> Which is not great, but also not terrible.
17:40:59 <Big_G> message me if you have anything else. Thanks for the help
17:41:13 <ReinH> Big_G: https://www.heroku.com/careers fwiw
17:41:36 <ReinH> They have a lot of Erlang but I'm not sure if they're hiring for it.
17:41:44 <lolisa> Hi, can anyone give an example of what is the proper way to do "renaming when necessary?" It came up in algorithm W and in the SMT tutorial, but I dont have a slightest clue of how to do so...
17:42:00 <KaneTW> uh
17:42:09 <ReinH> lolisa: can you describe what you mean by that?
17:42:11 <KaneTW> i guess you mean when you having scoping issues?
17:42:21 <ReinH> Are you referring to capture avoiding substitution?
17:42:28 <lolisa> Yes
17:42:50 <ReinH> Well, there are lots of ways. Here's one https://www.fpcomplete.com/user/edwardk/bound
17:45:16 <lolisa> Thx
17:46:19 <lolisa> Great, haskell library... While I am required to do it in Coq :(
17:47:25 <ReinH> Ah. Well, you're in a Haskell channel and you didn't specify...
17:47:38 <edwardk> lolisa: the coq story is more complicated. phoas or something usually works
17:49:01 <lolisa> Oh, sorry, Coq channel is in a sense dead and the hottest PLT channel I known is here...
17:49:29 <KaneTW> lolisa: you can follow the links in that article and implement that
17:49:31 <lolisa> edwardk, thx
17:50:06 <lolisa> Yes I am doing that right now, thx for helping, I am just wishing that things will be much nicer if there's library in Coq
17:50:19 <edwardk> lolisa: its harder to abstract over in coq
17:50:56 <ReinH> lolisa: no worries, but a haskell answer shouldn't be too surprising ;)
17:54:18 <lolisa> edwardk, is it because of strict positivity and total function requirement?
17:54:26 <edwardk> yep
17:55:16 <edwardk> phoas is basically a weak hoas variant because of that
17:55:50 <edwardk> https://www.fpcomplete.com/user/edwardk/phoas talks a bit about how phoas relates to a more traditional free monad, by splitting apart the positive and negative occurences
17:56:02 <edwardk> the post is in haskell but the results transfer to coq
17:57:08 <lolisa> edwardl, Thx
17:57:14 <lolisa> edwardk, Thx
17:57:44 <edwardk> http://comonad.com/reader/2014/fast-circular-substitution/ is faster, but definitely _doesn't_ transfer to coq ;)
17:58:10 * edwardk likes to kick the tires on ideas in this space from time to time in case you haven't noticed
18:00:02 <lolisa> Ah... Why wont it transfer? Strict positivity?
18:00:12 <edwardk> http://adam.chlipala.net/cpdt/html/InductiveTypes.html talks a bit about why naive HOAS doesn't work, whereas http://adam.chlipala.net/cpdt/html/ProgLang.html talks about how to fix that
18:00:58 <edwardk> you can modify the bound technique to get something that transfers
18:01:55 <rola> yo
18:02:41 <rola> are there any attempts in haskell to seperate what is computed from where and when the computation happens
18:02:50 <edwardk> my recollection was that it was the positivity check
18:03:08 <int-index> edwardk: Why don't you mark `either` deprecated if we have `transformers` and `transformers-compat` with ExceptT?
18:03:10 <edwardk> https://github.com/jwiegley/coq-pipes/blob/master/src/Pipes/Internal.v#L11
18:04:06 <edwardk> int-index: because the vast majority of the population can't compile the current transformers, and the instances for Data.Functor.Classes are worse than the prelude-extras ones it replaces. Until folks have had a longer migration window I won't even start a deprecation cycle.
18:04:36 <edwardk> int-index: its getting close to when i'm willing to do so though
18:04:54 <edwardk> he transformers-compat layer for ExceptT works pretty well now
18:05:02 <edwardk> when i last revisited this decision it wasn't usable
18:05:35 <edwardk> anyways the either package itself will survive as a home for the rest of the stuff in it
18:06:01 <edwardk> so the package won't get deprecated even if i do eventually deprecate EitherT in favor of the unfortunately bikeshedded ExceptT
18:06:43 <edwardk> anyways, in 8.0 we're eyeballing moving Data.Functor.Classes into base, with the current generation of improvements to it directly incorporated
18:06:49 <edwardk> this eliminates the stumbling block there
18:07:33 <edwardk> so if i had to guess a timeline with the release of 8.0 i'll probably ship an 'either' version with a deprecated EitherT that says to use ExceptT.
18:10:00 <edwardk> writing python after a long time writing haskell feels strange
18:12:40 <int-index> edwardk: Do you consider ExceptT unfortunately bikeshedded because of its name?
18:13:27 <edwardk> Had it been a direct transplant there would have been zero user pain. I could have just taken the existing EitherT package and had it silently stop exporting the module entirely when a new enough transformers was used.
18:14:21 <edwardk> My usual experience is when other people standardize a chunk of code I wrote is that I lose something valuable in the process. Either the migration is more painful than necessary or hey rip out bits of functionality I had added that seem unnecessarily complex on the surface.
18:14:21 <KaneTW> rola: what do you mean
18:15:08 <edwardk> For the longest time this is why I stopped caring about the Haskell Platform as a thing. It just inevitably felt like something that would come along and kick me in the teeth from time to time.
18:15:19 <KaneTW> you can do something like a `seq` f a to force a to whnf before actually using it in f a
18:15:26 <edwardk> Nowadays we tend to bring APIs largely unbikeshedded in
18:16:16 <edwardk> So, yes, I think the rename was unfortunate. It served consistency at the cost of user experience and discoverability
18:18:06 <KaneTW> what's the difference between EitherT and ExceptT?
18:18:13 <int-index> KaneTW: their name
18:20:13 <int-index> edwardk: thanks for the answers
18:22:54 <Big_G> ReinH, Sorry about leaving. Back now
18:23:38 <ReinH> Big_G: np
18:24:04 <Big_G> beyond Heroku, any ideas? Also, why do you prefer Ruby to Java?
18:25:15 <ReinH> edwardk: When you do, say you're going to call iy Control.Functor.Classes to give people a bikeshed honeypot to argue over.
18:25:31 <edwardk> ReinH: =P
18:25:51 <KaneTW> Big_G: i only have python exprience but java is just needlessly verbose
18:25:55 <ReinH> Big_G: Hmm, not really. I prefer Ruby because if I'm going to have to use such a language, I'd prefer to have as little boilerplate as possible.
18:26:19 <Big_G> ReinH, Doesn't the boilerplate give safety like Haskell?
18:26:36 <edwardk> I prefer Java, because if I'm going to have to use such a language, I'd prefer to have as much boilerplate as possible -- to highlight the absurdity ;)
18:26:47 <ReinH> I'm not quite sure how to parse that sentence, but I don't think the builerplate gives safety and I also don't think that Haskell's safety derives from boilerplate.
18:26:53 <KaneTW> ^
18:27:07 <Big_G> How so? If I say something is an int, it is an int
18:27:23 <KaneTW> Object x = null; x.equals("foo");
18:27:25 <KaneTW> poof
18:28:54 <ReinH> Java's type safety is compromised. At least Ruby doesn't pretend to type safety.
18:29:00 <edwardk> Big_G: FooBarBaz<AbstractSingletonProxyFactoryBean,T> myfooBarBazAbstractProxyFactoryBean = new FooBarBaz<AbstractSingletonProxyFactoryBean,T>() -- involves a fair bit of useless repetition.
18:29:33 <edwardk> ReinH: the one that gets me is array covariance
18:29:48 <KaneTW> python, ruby, etc provide you with flexibility by having dynamic types and crash-safety by being strongly typed (ie you can't do "foo" == 0)
18:30:13 <ReinH> edwardk: array covariance?
18:30:15 <exio4> array covariance is so cool, I mean, it's doing something so wrong in so little that it is fun
18:30:36 <KaneTW> http://c2.com/cgi/wiki?JavaArraysBreakTypeSafety
18:31:06 <exio4> ReinH: if X is a subtype of Y, X[] is a subtype of Y[], if they were immutable, it would be fine
18:31:27 <ReinH> ahahaha
18:31:50 <edwardk> I have an array of dogs, let me give it to you as an array of animals. assuming animal is a superclass of dog. now you go to put an animal in it because you were told its a damn array of animals and get a runtime error.
18:32:02 <ReinH> nice
18:32:12 <edwardk> it predates generics in java, so its a historical wart
18:32:24 <ReinH> Have class loaders been fixed yet?
18:32:30 <edwardk> permgenspace?
18:32:34 <edwardk> that fixed in 8
18:32:43 <KaneTW> never mind that generics in java are pretty terrible too
18:33:09 <ReinH> only took 20 years, I guess
18:33:16 <ReinH> KaneTW: despite being added by Wadler...
18:33:35 <exio4> they have partial type erasure there, so it's not a nice feature when you have reflection
18:33:46 <edwardk> ok, i'm going to drop out of the 'lets bitch about java' session and go try to figure out how to get a usable C++11 project build system =(
18:33:50 <ReinH> hah
18:34:52 <KaneTW> i usually go for cmake but it has it's own issues
18:34:58 <edwardk> any suggestions? i need to build c++11 code. i can use autoconf, because its what i know, but my tolerance for autoconf has waned over the years
18:35:00 <KaneTW> its*
18:35:04 <ReinH> We tend to frown on bitching about other languages. I am however tempted to make a formal request for a java exception.
18:35:16 <ReinH> That was a java exception safety pun. Hilarious.
18:35:33 <exio4> ReinH: you are on fire today, eh? 
18:35:35 <KaneTW> edwardk: how big is the project
18:35:39 <ReinH> exio4: :D
18:35:46 <edwardk> ReinH: you forgot to annotate your comment with 'throws (Exception)'
18:35:56 <ReinH> edwardk: or did I?
18:36:05 <KaneTW> derives RuntimeException
18:36:34 <edwardk> KaneTW: right now? its about 2-3 source files, but it'll rather quickly metastasize as soon as i can figure out how to get the gc designed right and have something to bolt the rest of the runtime system onto
18:37:10 <KaneTW> if you're starting from scratch i'd just use cmake. it's pretty painless and keeps your buildtree clean (mkdir build; cd build; cmake ..; make)
18:37:15 <edwardk> on the plus side, i'm willing to cut off at the knees anything before c++11
18:38:06 <edwardk> another complication is i may wind up wanting to build this through cabal, so the autoconf hooks may be inevitable
18:38:48 <edwardk> in fact that is probably inevitable =(
18:40:13 <ReinH> edwardk: what are you doing in C++11?
18:40:27 <edwardk> playing with a runtime system for turbo haskell
18:40:32 <ReinH> edwardk: btw use shake trollolol
18:40:43 <edwardk> figured out an interesting heap representation for haskell
18:40:47 <edwardk> wanted to actually code it up
18:40:51 <ReinH> Does that rhyme with turbo pascall? Please say yes.
18:40:56 <edwardk> it does
18:40:56 <ReinH> *pascal
18:40:59 <ReinH> Excellent.
18:41:22 <edwardk> for years after i found haskell every time i'd say "haskell" people would assume i meant "pascal" ;)
18:41:31 <int-index> edwardk: do you have any objections against Rust? (compared to C++11). It seems to be a generally better language.
18:41:35 <ReinH> hah
18:41:41 <edwardk> int-index: yes
18:41:57 <ReinH> edwardk: go on
18:41:59 <edwardk> the c++11 bits are being used basically as portable assembly language mostly
18:42:19 <edwardk> anyways turbo pascal was a large part of why i was able to move from CP/M to DOS back in the day
18:42:33 <edwardk> the compiler has always had a special place in my heart
18:42:42 <KaneTW> https://github.com/Microsoft/bond/
18:42:47 <KaneTW> appears to use both cmake and cabal
18:42:50 <ReinH> James bond?
18:43:09 <ReinH> ctrl-f "James"... nothing. Shame.
18:43:15 <edwardk> KaneTW: and how many people do you know who have installed it? =)
18:43:23 <int-index> edwardk: and in what language are you going to write your garbage collector?
18:43:24 <KaneTW> no idea, i'm just googling :v
18:43:35 <ReinH> edwardk: apparently lots of people at microsoft?
18:43:44 <edwardk> int-index in a mixture of c++ and a very modified form of GRIN
18:43:52 <edwardk> int-index the gc is the only thing i _have_ so far
18:43:55 <ReinH> seems to not be a build system though?
18:44:07 <KaneTW> ReinH: not a build system, but as an example of combining cabal and cmake
18:44:11 <ReinH> ahhh
18:44:40 <edwardk> int-index: the gc gets pretty tied to the execution model here, because it can do O(1) work during enqueue and dequeuing towards graph reduction in my model
18:44:44 <ReinH> oh, it's a thrift alternative, righto
18:44:54 <ReinH> but I guess with more "framework"
18:45:12 <ReinH> edwardk: doesn't rust give you good control over that?
18:45:14 <edwardk> int-index: and it being mostly mark-compact without any headers on objects by using VERY heavily tagged objects means that anything rust does will basically get in my way
18:45:20 <ReinH> you can turn off the runtime
18:45:40 <KaneTW> it does feel a bit backwards, and having cabal call cmake seems better
18:45:51 <ReinH> ah
18:46:34 <KaneTW> in the end it probably depends on how much you dislike autoconf
18:47:16 <int-index> edwardk: as ReinH mentioned you can disable the runtime, but you get a borrow checker, which is nice
18:47:24 <edwardk>     std::uintptr_t uniqueness : 1, closure : 1, reserved : 1, offset : 9, segment : 9,region : 19, space : 4, nmt : 1, tag : 19;
18:47:42 <edwardk> int-index: my semantics for how i deal with pointers are rather radically different than rust's model.
18:47:51 <edwardk> ^- that is a pointer to me
18:48:31 <ReinH> edwardk: so this isn't a general criticism of rust, just that it isn't fit for this use?
18:48:40 <edwardk> its just totally irrelevant to this use, eys
18:48:42 <edwardk> yes
18:48:49 <ReinH> righto
18:48:57 <edwardk> rust is interesting and if i had a problem that suited it i might some day consider using it for something
18:48:59 <edwardk> this isn't that day
18:49:48 <bitemyapp> edwardk: that's Turbo Haskell?
18:49:55 <bitemyapp> edwardk: what sort of thing would Rust suit, do you think?
18:50:11 <ReinH> I suppose lots of things that didn't involve inventing your own pointers ;)
18:51:11 <edwardk> anyways the pointer type above has to track a not-marked through flag for a concurrent collector, moves the entire tag of the object into the tag bits at the top, tracks the garbage collection space in a way lets me manage a C4 style LVB read barrier, needs to know uniqueness of closures so it can avoid allocating the indirection, then contracting the
18:51:11 <edwardk> reference to a closure actually mandates allocating the 8 byte indirection node, also tagged, but i need a heavier blackholing scheme for the now reduced set of spaces where the indirection is used
18:51:48 <edwardk> evaluating a GRIN-like model means I can use this rather huge space of tags
18:52:01 <wedify> i think i've finally found a way to handle head/tail; list fallback fun l = if not $ null l then fun l else fallback
18:53:04 <edwardk> but now case analysis has the benefit that its looking directly at a tag in the pointer it has, rather than following to the memory in question, so you get to 'steal a prefetch' worth of time in every case analysis, and with a tracing jit or whole program optimizer for GRIN in the style of JHC you can specialize to the types of closures that actually occur
18:53:22 <edwardk> getting away from the megamorphic indirect jumps in the spineless tagless g-machine
18:53:47 <edwardk> and enabling concurrent collection and compaction, at the expense of using a read-barrier
18:54:04 <bitemyapp> edwardk: whoa concurrent collection and compaction?
18:54:17 <edwardk> but to avoid tagging objects on the heap you wind up having to basically write the gc half in GRIN itself so it can do the mark queuing and compaction
18:54:56 <edwardk> bitemyapp: gc looks a lot like C4/compressor, but the first generation or two may be local to the haskell execution context
18:55:28 <edwardk> in which case they'd be able to be "stop the local world" or not, but my goal is to avoid any global world stops
18:56:05 <edwardk> using a c4/compressor scheme also enables immediate reclamation of a page after eviction in the compaction phase, which cuts about half the heap overhead
18:56:49 <int-index> wedify: now use explicit pattern matching instead of calling `null` and you'll discover that it's just a list deconstructor
18:56:55 <edwardk> basically as i'm looking at ghc i'm seeing the current collector as a bigger and bigger bottleneck and the amount of space we're wasting in the pointers as almost criminal from a latency standpoint
18:57:05 <edwardk> so i'm curious to see what we could do if something worked differently
18:57:17 <edwardk> bitemyapp: right now its mostly a thought experiment
18:58:02 <edwardk> by tracking "local uniqueness" in the pointers themselves i can do more in place trickery and elide more barriers
18:58:45 <exio4> edwardk: good luck with that, sounds pretty cool :P 
18:58:53 <edwardk> i also spent some time playing around with what i could get away with if i just assumed availability of hardware transactional memory support, figuring on a long enough timeline it'll be there.
18:59:02 <edwardk> but i eventually walked back the need for that
18:59:30 <edwardk> exio4: right now its probably too big of a project to bolt onto something, because it basically needs a full GRIN-variant to generate code for it
19:00:14 <edwardk> and i have er.. religious objections to working on GPL code, so i won't be adapting from jhc/lhc.
19:03:12 <int-index> what's the nicest trick to simulate open unions in Haskell?
19:03:33 <edwardk> int-index: not using them =)
19:03:44 <int-index> edwardk: why?
19:03:52 <int-index> what's wrong with them?
19:03:54 <rola> what are those
19:04:12 <edwardk> int-index: because my experience with 'data types a la carte' is that you wind up limiting yourself to the 'checkable' fragment of haskell rather than the inferrable fragment
19:04:40 <int-index> rola: first-class sum types, so you can have a type like `Int | Bool | String` 
19:04:53 <rola> oh so like an un-tagged union?
19:05:19 <edwardk> on the other hand, we have a great place to deal with open unions of features the constraint system, so if you want to deal with several possibilities, one way to do this is to use classy prisms or the like. this stays 'inferable' but the price is you can't 'handle' cases one by one and have to write a big wrapper type at the end with all the instances
19:05:41 <edwardk> so i tend to use the 'classy prism' solution myself because i find that the user experience is saner
19:05:49 <edwardk> but i can understand the attraction of the open sums
19:06:25 <edwardk> class AsFoo t where _Foo :: Prism' t Foo; class AsBar t where _Bar :: Prism' t Bar
19:06:50 <exio4> edwardk: I see, makes sense
19:06:56 <int-index> edwardk: I don't care at all about staying in the inferrable fragment, I always specify full type signatures and I don't understand why they should be inferrable from terms
19:06:58 <edwardk> data Baz = BazFoo Foo | BazBar Bar; instance AsFoo Baz where ...; instance AsBar Baz where ...
19:07:08 <edwardk> int-index: then knock yourself out
19:07:10 <ReinH> wedify: use pattern amching
19:07:33 <edwardk> i stay with inferrable types wherever possible as a courtesy to users
19:07:47 <ReinH> wedify: generally you shouldn't use head, tail, or null in places where you can use pattern matching.
19:08:03 <ReinH> In fact, it's rarely a good idea to use head or tail at all
19:08:50 <edwardk> int-index: anyways you can implement them with closed type families, typeclasses or with typeable horribleness. the former is probably the best solution
19:09:06 <edwardk> because the latter two incur limitations
19:09:36 <edwardk> anyways, re the compiler stuff. i've set up a #thc channel with freenode and am happy to talk about that stuff in there
19:09:37 <int-index> i'm not a native speaker, what are you asking me to do exactly by telling me to knock myself out?
19:10:15 <edwardk> int-index: it is a turn of phrase meaning "Go for it"
19:10:59 <edwardk> "can I have some of your french fries? sure, knock yourself out."
19:12:24 <glguy> Lunch with edwardk sounds violent
19:12:39 <edwardk> glguy: =)
19:12:41 <edwardk> https://en.wiktionary.org/wiki/knock_oneself_out
19:13:34 <lolisa> edwardk, how long have you been programming? you are amazing...
19:16:07 <wedify> ReinH: Those approaches clutter up the code. my 'list' function allows in-place use
19:16:48 <int-index> edwardk: the BazFoo/BazBar + instances is what I'm currently using and it's hacking because all BazX constructors have exactly one argument, each of different type, so effectively it's type-indexed, so the constructors are boilerplate.
19:16:56 <int-index> *hackish
19:20:01 <int-index> the typeable stuff (as found in the `open-union` package) is unsatisfactory because the union is annotated with a list of types, not a set of types, so I can have `Union '[Int, Bool, String]`, but it's not the same as `Union '[String, Int, Bool]`
19:20:55 <int-index> i figured that to get something unordered I'd use the constraints, like `Has Int s, Has Bool s, Has String s`, but now I have no way to say that there's no other types in the union.
19:21:31 <int-index> `(Has Int s, Has Bool s, Has String s) => Union s`, to be more precise
19:24:02 <int-index> if there was a way to sort a list of types, I'd be content with the type-level list solution, unfortunately there isn't.
19:25:24 <exio4> I "solved" that by making a closed type family that returns a type-level boolean 
19:26:14 <ReinH> wedify: You can (and should) define that function using pattern maatching.
19:26:16 <exio4> (for something totally different)
19:26:45 <lolisa> edwardk, I think formatting on the number of pro section of de bruijn index is lacking a newline here... https://www.fpcomplete.com/user/edwardk/bound
19:30:56 <greymalkin> Anyone have any pro/cons to JuicyPixels?
19:31:45 <pavonia> Is there an equivalent to liftIO in MonadLib?
19:31:59 <bitemyapp> edwardk: cool :)
19:32:04 <glguy> pavonia: inBase
19:32:27 <pavonia> Thanks!
19:50:35 <edwardk> lolisa: thanks fixed
20:03:43 <mrkgnao> hey, all.
20:06:09 <lpaste_> mrkgnao pasted “Working .spacemacs config” at http://lpaste.net/5218634428577742848
20:06:18 <mrkgnao> suppi: that works
20:06:38 <mrkgnao> if you could link me to the page where I could report it, that'd be nice
20:06:48 <mrkgnao> autocomplete doesn't work, but everything else does
20:27:30 <nitrix> Hi, how good is the leksah ide?
20:28:05 <KaneTW> i find it rather meh
20:28:13 <nitrix> I've decided I'd customize vim for a proper haskell environment and couldn't get anything to work.
20:28:18 <KaneTW> but try it for yourself
20:28:28 <KaneTW> i just use emacs with haskell-mode and ghc-mod
20:28:34 <nitrix> It's very frustrating. Emacs users seems to have it easier.
20:29:07 <KaneTW> i used subl3 for a while but it's rather slow
20:29:15 <nitrix> KaneTW: That's the thing. I might switch to emacs for Haskell, just because of this. If only the keybindings werent so dumb.
20:29:26 <KaneTW> takes a while to get used but it's worth it imo
20:29:44 <KaneTW> used to them/
20:30:10 <nitrix> And you say that all the haskell tools/goodies are painless to get to work?
20:31:20 <KaneTW> yeah pretty much
20:31:50 <KaneTW> only issue i had was getting ghc-mod to work with the ghc source but i didn't try too hard. works fine with everything else
20:36:30 <tomberek> Is there a Generic2 available in GHC Generics? Or a way to hack to it? While trying to create a instance for Generic for a GADT manually: a b c -> a c d -> MyType a b d.  This causes problems because the 'c' parameter dissapears and I can't introduce it using the Generics datatype description DSL. Next, foralls are not allowed in type families for the Rep parameter.
20:39:59 * hackagebot woot 0.0.0.4 - Real time group editor without operational transform.  https://hackage.haskell.org/package/woot-0.0.0.4 (tgolson)
20:45:44 <lrunze> 新人报道～I'm a new man, and I hope to learn with you.
20:49:15 <KaneTW> don't hestitate to ask questions :)
21:09:52 <lolisa> Are there method to increase confident using proof that substitution is correct? I am thinking of something like typeclass and instance, but not sure how to do it in general... Or is proving some isomorphism to PHOAS the only way?
21:10:00 * hackagebot postgresql-orm 0.4.0 - An ORM (Object Relational Mapping) and migrations DSL for PostgreSQL.  https://hackage.haskell.org/package/postgresql-orm-0.4.0 (AmitLevy)
21:10:30 <mrkgnao> KaneTW: did you see the config I posted above?
21:10:40 <mrkgnao> outside of autocomplete, it all just works in emacs now.
21:10:43 <mrkgnao> for me.
21:15:38 <lolisa> BTW I think I came up of a joke: "do or do not there's no try" - yoda on why he prefer exceptT over try catch mechanism
21:23:03 <Hafydd> Unfortunately, the "try / catch" mechanism still makes sense for ExceptT.
21:23:17 <Hafydd> Which is why ExceptT is an instance of MonadTry and MonadCatch.
21:24:05 <lolisa> Sorry my back, not an Haskeller as you can see :) I guess option work　than
21:24:25 <lolisa> s, an, a
21:27:09 <lolisa> Oh nevermind... Maybe is still in monadtry, stupid me :)
21:44:53 <nitrix> Given a list of Foo, which is declared as `data Foo = A | B b`, how would I filter out all the B's ?
21:45:43 <nitrix> Bear in mind the actually type has many more value constructors so I can't do anything that involves choosing only A explicitly.
21:46:13 <nitrix> Do I need a special function that pattern matches the lists and then concatenate all the results?
21:46:54 <nkaretnikov> nitrix: you could probably define a helper
21:47:03 <nkaretnikov> isB :: Foo -> Bool
21:47:09 <nitrix> I basically just need a isB.
21:47:20 <nkaretnikov> then filter (not . isB) xs
21:47:39 <nitrix> Exactly, then that'd be my predicate. Is there a way without the helper? Lambda magic maybe?
21:47:48 <nkaretnikov> isB B {} = True; isB _ = False
21:48:01 <nitrix> Otherwise I'll go with that.
21:48:22 <Zekka> How about [x | B x <- foos]?
21:48:40 <Zekka> > [x | Just x <- [Just 1, Nothing, Just 2, Just 3]]
21:48:43 <lambdabot>  [1,2,3]
21:48:46 <MarcelineVQ> He doesn't want B
21:49:09 <Zekka> Still applies
21:49:13 <nshepperd> mapMaybe (\case { B _ -> Nothing; foo -> foo })
21:49:20 <Zekka> > [Nothing | Nothing <- [Just 1, Nothing, Just 2, Just 3]]
21:49:22 <lambdabot>  [Nothing]
21:49:26 <nshepperd> er, mapMaybe (\case { B _ -> Nothing; foo -> Just foo })
21:49:34 <Zekka> Although wait, he said he has more data constructors
21:49:39 <MarcelineVQ> :>
21:49:40 <Zekka> Never mind, what I'm suggesting is not useful
21:50:03 <nkaretnikov> nitrix: i can' t think of any other way that'd be more concise.  you need to match on a value constructor.
21:50:37 <nkaretnikov> you could use case or even lambda case maybe, but that's the same thing
21:50:38 <nitrix> I'm going with the case lambda, it's used only once in a where clause.
21:50:50 <nkaretnikov> sure
21:50:56 <nitrix> I love haskell :)
21:53:15 <nshepperd> I guess you don't really need mapMaybe, filter (\case{ B _ -> False; _ -> True }) would be slightly shorter 
21:57:17 <nitrix> This gives me a "naked lambda expression error"
21:58:23 <KaneTW> -XLambdaCase
22:00:50 <nitrix> Dumb question, why are these extensions? Doesn't it create multiple Haskell dialects?
22:00:59 <joobus> Question: I'm reading through this, https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/json
22:01:11 <joobus> some of the type declarations have !Text
22:01:20 <joobus> what is the exclamation point doing?
22:02:08 <nitrix> joobus: That's a strictness declaration. The value will be evaluated to weak normal head form (WNHF) as soon as it's created.
22:02:18 <shachaf> Hoogle can answer this question.
22:02:40 <KaneTW> nitrix: sort of, but there's nothing wrong with that
22:02:58 <ricochet1k> Many of the language extensions are just syntax sugar.
22:03:10 <joobus> nitrix: thanks
22:03:20 <nitrix> KaneTW: I see. Is this the way of saying "If there's enough people using the extension, then we'll consider making it standard" ?
22:04:18 <dmwit> The standards committee is not so active.
22:04:57 <dmwit> It can be hard to see the benefit of standardization when there's only one implementation.
22:05:35 <dmwit> (There are actually a few. But GHC is used far and away the most of any of them.)
22:05:50 <dmwit> Even some of the non-GHC implementations are GHC. =P
22:06:31 <nitrix> Yeah, that's a little strange when you're comming from C.
22:06:48 <nitrix> I supposed if that worked out for PHP, why not.
22:07:00 <KaneTW> barely any language has more than one compiler
22:07:08 <KaneTW> or effectively one
22:07:30 <kadoban> That's not exactly true, depending on what you mean by "barely any"
22:07:31 <nitrix> My understanding is that it'd be an enormous task (if not impossible) for Haskell.
22:08:09 <KaneTW> kadoban: well it's sort of an empty statement, considering how many programming languages there are
22:08:31 <dmwit_> nitrix: I don't know about that. I think the two major extant alternatives were each written by essentially one person.
22:09:00 <kadoban> KaneTW: Then yes if you compare against every language ever invented in someone's basement and never used by anybody :-/
22:10:54 <isd> There are actually quite a few notable languages out there that have multiple "serious" implementations --- even ones *without* standards
22:11:00 <kadoban> KaneTW: If you look at the popular languages though, it's not very rare at all to have multiple implementations.
22:11:08 <KaneTW> yeah
22:11:24 <KaneTW> the less popular the get the lower the chances, though
22:12:09 <isd> Python has at least half a dozen despite the "standard" being basically "whatever cpython does"
22:12:22 * slack1256 wonders how the esoterics langs get more than 5+ implementation
22:12:28 <isd> My hunch is the issue is basically "GHC sets a really high bar"
22:12:57 <isd> making haskell go fast is non-trivial.
22:13:03 <nitrix> slack1256: Usually due to simplicity and academic purposes. Brainfuck for example.
22:13:12 <KaneTW> slack1256: implementing them for fun/as a joke
22:13:32 <isd> See also: scheme: the only language with more implementations than users
22:14:13 <slack1256> yep, still amusing
22:14:36 <joobus> isd: +1, I tried playing with scheme for a while.  couldn't get much past figuring out which scheme to use.
22:14:56 <slack1256> pff, obviously the one that comes with your editor!
22:15:08 <slack1256> :-)
22:15:10 <ricochet1k> then you have to pick an editor
22:15:27 <kadoban> Scheme is a good language to learn, if for no other reason than it gives you an excuse to read SICP.
22:15:31 <isd> joobus: yeah, I first got anywhere by wanting to contribute to an existing project --- the decision was made for me.
22:15:37 <isd> hah
22:17:10 <isd> slack1256: if you're assuming emacs, I have to point out that not (elisp `elem` scheme)
22:17:26 <isd> also oh dear god dynamic scope
22:17:52 <slack1256> well rms followed somehow scheme as it had a standard and CL didn't exist back then. but yeah
22:18:44 <isd> Also no macro hygine (I think?). Those are some pretty huge differences
22:18:52 <joobus> isd: I watched the SICP lectures while learning Clojure.  I looked into scheme to try and get away from the JVM.
22:19:15 <isd> Yeah... that's the one thing that's really kept me away from clojure
22:19:18 <isd> and scala, for that matter
22:19:25 <joobus> yep
22:19:48 <isd> I may cave on the latter if I end up wanting to do stuff with android badly enough at some point.
22:19:53 <slack1256> but really, how smart GHC actually has to be? Last time I read any code, it seemed a grand exercise on finding the proper ration of inlining functions and binary size
22:20:19 <slack1256> also a note said it was its primary job to inline to do not remote call and something about flushing registers
22:21:53 <slack1256> that an when to eta-expand/reduce watching aritities and stuff
22:22:19 <slack1256> *and
22:22:24 <dmwit> I dunno. There's been some non-trivial work on list fusion and the runtime system.
22:22:25 <joobus> aritities... hmmm
22:22:35 <dmwit> Strictness analysis can be a big win.
22:22:36 <slack1256> arity/arities
22:22:44 <dmwit> There's a lot of little touches in GHC.
22:23:10 <slack1256> yep.
22:23:20 <slack1256> btw, ghc notes are great, just great
22:23:37 <dmwit> Definitely the best-commented source I've ever seen.
22:23:49 <slack1256> and is so obvious
22:26:24 <carter_cloud> theres always room for more awesome though
22:26:33 <carter_cloud> dmwit:  you graduated right? whats afoot?
22:40:40 <ReinH> carter_cloud: stop recruiting people already geez :p
22:40:46 <carter_cloud> :p
22:40:54 <ReinH> carter_cloud: <3 how are you?
22:40:55 <carter_cloud> i wasn't recruitng
22:40:59 <carter_cloud> YET
22:41:00 <carter_cloud> :)
22:41:02 <ReinH> :)
22:41:03 <carter_cloud> i'm decent
22:41:09 <ReinH> yayish
22:41:17 <ReinH> how's the raft impl?
22:41:20 <carter_cloud> ed and a few people talked me out adding linear types to a demo
22:41:30 <ReinH> a demo of?
22:41:32 <carter_cloud> https://github.com/chrisnc/tangaroa helped :)
22:41:50 <ReinH> ah
22:41:53 <carter_cloud> its a better demo-ware raft than the verdi based one
22:41:56 <carter_cloud> though still has issues
22:41:58 <mrkgnao> lolisa: another joke I like: "Don't use unsafeCoerce." -- Gregor Samsa
22:42:02 <ReinH> nice
22:42:12 <carter_cloud> ReinH:  i still need to put some time into the state machien compostion thing
22:42:17 <ReinH> right
22:42:23 <ReinH> you should like totally do t hat
22:42:28 <carter_cloud> i was playing with the idea of doing a coninductive formulation of the state machine data type earlier today
22:42:33 <dmwit> carter_cloud: Yep, graduated. Working at Galois now in Portland, OR.
22:42:38 <carter_cloud> dmwit:  cool!
22:42:41 <ReinH> dmwit: nice!
22:42:49 <dmwit> Yeah!
22:42:55 <dmwit> Lots of overlap with #haskell there.
22:43:00 <ReinH> yep yep
22:43:04 <ReinH> dmwit: I'm from Portland as well
22:43:16 <dmwit> Oh, sweet! Whereabout?
22:43:22 <thomaseding> Is it possible to pass classes around in types? Example: data Box c a where { Box :: c a => a -> Box }
22:43:24 <ReinH> Well technically I live in Washington now
22:43:36 <dmwit> thomaseding: Yep, and of course edwardk has a package for it.
22:43:54 <thomaseding> dmwit: what's the package?
22:44:19 <ReinH> dmwit: but I'm still pretty close to portland
22:44:41 <dmwit> thomaseding: Trying to find it, wait a moment.
22:44:45 <edwardk> constraints
22:44:52 <thomaseding> cool
22:44:55 <edwardk> @hackage constraints
22:44:55 <lambdabot> http://hackage.haskell.org/package/constraints
22:45:13 <dmwit> ...that one, yep
22:45:20 <dmwit> Just found it, but it helps to have the author around. =)
22:45:25 <edwardk> that reminds me i need to ship a new version with a worse version of Forall
22:45:42 <dmwit> ReinH: If you're in town often, perhaps we could grab lunch sometime or something.
22:47:53 <drewbert> I friggin' love optparse-applicative
22:48:28 <dmwit> edwardk: Is "thin" a standard CT term? (You use it in that package to describe categories with at most one arrow between any two objects.)
22:48:46 <edwardk> http://ncatlab.org/nlab/show/thin+category
22:49:06 <dmwit> neat
22:49:20 <edwardk> there are also 'gaunt' categories in hott
22:49:44 <edwardk> http://ncatlab.org/nlab/show/gaunt+category
22:49:53 <carter_cloud> ReinH:  the two versions of state machine roughly are    data Stm m in out = State (in -> m out)
22:49:57 <edwardk> for a related concept
22:50:11 <dmwit> that property seems evil
22:50:15 <edwardk> so the naming here is a little silly
22:50:39 <carter_cloud> or Stm m in out = StateM {thisState :: out , nextState :: in -> m (Stm m in out)}
22:50:42 <nshepperd> undead categories
22:50:57 <carter_cloud> ReinH:  those are eseentially equivalent
22:51:02 <edwardk> dmwit: in the category theory evil sense or the general evil sense?
22:51:11 <dmwit> the CT evil sense
22:51:23 <dmwit> But I'm just reviewing what CT evil actually means to see if I'm right.
22:51:50 <edwardk> my understanding is there is a nice technical reason why they need it
22:51:59 <dmwit> I believe that.
22:52:00 <edwardk> but i don't have any of that paged into my brain right now
22:52:16 <edwardk> it shows up in the hott book though
22:52:23 <edwardk> #hott would probably know more
22:52:39 <edwardk> i remembered it from a passing comment by sclv
22:53:13 <carter_cloud> ReinH:  does my claim make sense?
22:53:59 <dmwit> Well, http://ncatlab.org/nlab/show/principle+of+equivalence talks about object equality being the main evil thing, and morphism equality being fine.
22:54:08 <dmwit> So that's good.
22:54:39 <dmwit> carter_cloud: Your `data Stm m in out = State (in -> m out)` one might be missing something.
22:54:52 <dmwit> oh
22:54:59 <dmwit> Or not. =)
22:55:02 <carter_cloud> dmwit:  yes, state arge can be factored out :)
22:55:14 <carter_cloud> but doesn't matter for eg, writing a profunctor instance
22:55:23 <dmwit> I didn't understand that.
22:55:42 <carter_cloud> (in,statein)->(out,stateout)
22:55:55 <carter_cloud> or whatever
22:55:56 <carter_cloud> yeah
22:56:06 <carter_cloud> it took me a while to accept that too :)
22:56:23 <dmwit> huh?
22:56:42 <carter_cloud> the coinductive version of the stepper can have a private state
22:56:55 <carter_cloud> the function one can't (unless you fix the m)
22:57:32 <carter_cloud> dmwit: i'm crashing
22:57:34 <carter_cloud> ttyyl?
22:57:39 * dmwit shrugs
22:57:41 <dmwit> sleep well
23:02:22 <lpaste_> mrkgnao pasted “This .spacemacs works perfectly. Enjoy.” at http://lpaste.net/3275725072228155392
23:13:51 <Mishac> Hi Guys, can someone help me understand why this code does not typecheck? And what can I do to make it typecheck? This is the link: http://pastebin.com/UDXa2Evh
23:14:23 <Mishac> Size Int belongs to monoid and Sized typeclass
23:16:18 <Cale> Mishac: the type you gave for makeSize is more polymorphic than the implementation you gave
23:17:26 <Cale> You gave an implementation of makeSize which specifically produces a result of type Size, while you claimed that it ought to be able to produce a result of *any* type which is an instance of Sized
23:17:45 <Mishac> Ohh I see now, the error in my ways
23:17:53 <Cale> For example, I should be able to demand that makeSize produces a result of type (String -> String, Size)
23:17:57 <Mishac> so it checks the generality as well
23:18:12 <Cale> yep
23:18:34 <ReinH> carter_cloud: sorry
23:19:00 <ReinH> dmwit: not too often, but I'd be happy to visit and have lunch
23:20:02 <Mishac> Interesting, so in other words the function definition is general, you cannot implement it using one specific subset of the type b
23:20:34 <Mishac> in which case it is of the type Size
23:22:06 <Mishac> Thank you Cale. in other words somehow it is perfectly safe to implement a function: getTreeSize :: (Monoid b, Sized b) => JoinList b a -> Int
23:22:13 <Mishac> but make a reverse of it is difficult
23:24:35 <nitrix> Given a string of characters, "a(bc)de(f(g)h)" how would I isolate it into ["a", "(bc)", "de", "(f(g)h)"], that is, based on pairs of enclosing characters? I've tried a naive approach of dropWhile/reverse but it swallowed "(bc)de(f(g)h)" as if it was one element.
23:24:36 <Cale> Mishac: Yeah, since the class Sized doesn't provide some sort of operation  unsize :: Size -> a  it's hard to go in the opposite direction. You're losing information.
23:25:01 <nitrix> I'm essentially looking for a dropWhile or takeWhile that'd have an accumulator like foldl.
23:25:09 <Cale> nitrix: I would use a parsing library like Parsec
23:25:37 <nitrix> Cale: I'm familiar with Parsec but we are trying to avoid it for the sake of seeing how it'd be done.
23:26:02 <suppi> nitrix, I think you'll need recursion for this
23:26:13 <Mishac> for some reason I find this example fascinating, i have been strugling to understand why it does not go in reverse for several days and I feel like it makes sense now
23:26:41 <nitrix> suppi: I do have recursion, but there's also a matter of counting the opening and closing parenthesis.
23:27:00 <Mishac> it is sort of like in monad comonad duality, you can create something in one and only destroy something in another
23:27:00 <suppi> nitrix, why do you need to count?
23:27:36 <kadoban> nitrix: You could just use explicit recursion and process char by char, you just have to keep track of what paren depth you're at. ... but yeah I'd just use Parsec, it's far easier and /far/ clearer that way.
23:27:38 <nitrix> suppi: Because they can be nested and I want the outermost as an element so that I can apply the function recursively.
23:28:13 <nitrix> suppi: But I can't just split it into left ++ middle ++ right, and apply recursively to the middle, as you can see, you can have many of those nested parenthesis at the root level.
23:28:30 <nitrix> kadoban: I agree with you.
23:29:26 <suppi> nitrix, brb
23:31:29 <Mishac> Cale: Thank you for your help. Would you say that this asymetry is akin to the moand - comonad duality? Ie create something in one and destroy something in another;
23:32:12 <Mishac> Cale: or maybe I am just trying to connect things that are not related.
23:32:28 <Cale> Mishac: it's kind of similar vaguely
23:34:40 <suppi> nitrix, what you might want to do is create a function that parses a string such that
23:35:09 <Mishac> Cale; yeah, that's sort of what i mean. Its very vague, but in some ways it conveys the jist of the duality.  Like, in my example it is safe to go one way, IE read the m and extract value from it. But going other way is unsafe because you lose information. Anyway, thank you.!
23:35:13 <suppi> a string can be either (<string>) or a <string-without-parens>
23:35:56 <lpaste_> Cale pasted “slightly ridiculous but direct version” at http://lpaste.net/140826
23:35:57 <suppi> or is that not what you are looking for?
23:36:04 <Cale> nitrix: ^^
23:36:26 <nitrix> It's fine, I'm figuring it out atm.
23:37:12 <suppi> the "recursion stack" will count the number of open parens to close for you
23:40:05 <rhz> Is it possible in Haskell to allow more than one LHS for the same RHS when doing pattern matching? Sort of how OCaml allow it.
23:40:42 <Cale> rhz: no
23:40:52 <suppi> rhz, example?
23:41:03 <Cale> rhz wants or patterns
23:41:17 <rhz> Sure. Here is a valid OCaml functions: let f list = match list with [x;y] | [x;_;y] -> x;;
23:41:31 <suppi> oh, I see.
23:41:32 <Cale> https://hackage.haskell.org/package/OrPatterns -- there's a quasiquoter implementation of them here
23:41:55 <Cale> But just how dire is your need for them? :)
23:44:21 <rhz> Not dire at all
23:46:13 <ww> hey rhz
23:47:01 <rhz> hi ww
23:48:05 <lpaste_> Cale annotated “slightly ridiculous but direct version” with “lol, no reverse” at http://lpaste.net/140826#a140827
23:49:30 <Cale> anyway, the right way to do this is to write a parser :P
23:56:05 <thomaseding> Is it possible to alias kinds? Example: type X = (* -> Constraint)
23:56:32 <thomaseding> data Foo :: X where
23:56:32 <thomaseding>  { ... }
23:56:55 <thomaseding> EDIT: Foo :: X -> * 
