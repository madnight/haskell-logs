00:00:12 <dramforever> screw it why did say that...it makes no sense to you doesn't it
00:00:34 <montanonic> I've been using a Rose Tree data structure; data RoseTree a = Node a [RoseTree a].
00:01:45 <montanonic> what you said seems to have made sense?
00:01:52 <montanonic> perhaps I misinterpreted 
00:02:11 <rhovland> I'd like to see ways to translate wikipedia pseudocode to haskell.. really assumes mutable state.. eg https://en.wikipedia.org/wiki/Disjoint-set_data_structure 
00:02:29 <dramforever> montanonic: I mean, that's really nothing to do with anyone except me
00:02:31 <rhovland> or https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm
00:03:31 <rhovland> I mean, I turned it into recursive calls (for while()) .. but I'd like to know a _good_ way to do it
00:04:30 <levi> Depends on what you think is a good way.
00:04:53 <rhovland> levi: I guess using map/fold/etc instead of recursion
00:05:35 <levi> One could argue that imperative, mutating algorithms should be implemented via imperative mutation. In that case, you could do it in the ST monad.
00:05:38 <levi> Or in IO.
00:07:40 * hackagebot wai-routes 0.9.0 - Typesafe URLs for Wai applications.  https://hackage.haskell.org/package/wai-routes-0.9.0 (AnupamJain)
00:07:40 * hackagebot postgresql-simple 0.5.0.0 - Mid-Level PostgreSQL client library  https://hackage.haskell.org/package/postgresql-simple-0.5.0.0 (LeonSmith)
00:08:02 <kadoban> rhovland: I believe that KMP is in 'pearls of functional algorithm design', but I haven't read it yet, only skimmed.
00:10:33 <levi> There's the Haskell version of 'quicksort' in 5 lines, though it's not particularly quick and, of course, doesn't swap things in-place.
00:10:49 <dramforever> in KMP the array generated + the original string is actually a DFA with the edges compressed
00:10:49 <rhovland> kadoban: huh.. that would be interesting.. I totally just copied from wikipedia.. I'm still amazed that substring search is even a thing
00:11:59 <rhovland> kadoban: I wouldn't think KMP would be in pearls of FAD, but hm
00:12:35 <rhovland> favorite thing is queue implemented as two stacks
00:12:50 <dramforever> rhovland: union-find and kmp are both amazing
00:13:04 <levi> rhovland: Here's a HAMT implementation: https://github.com/ezyang/hamt/blob/master/HAMT.hs
00:13:17 <rhovland> dramforever: wait are union-find and kmp related?
00:13:32 <dramforever> no, but they are two amazing things
00:13:55 <dramforever> connected because they are amazingly fast and (somewhat) simple
00:13:56 <kadoban> rhovland: I checked, it's chapter 17 or whatever, in case that helps. I haven't read it though, only the first couple.
00:14:28 <rhovland> kadoban: er.. of knuth?
00:15:01 <Cooler> can someone explain the main::IO() syntax?
00:15:11 <Cooler> what is the syntax even
00:15:27 <kadoban> rhovland: No, the book I mentioned.
00:15:29 <levi> Cooler: You mean you're having trouble parsing that particular line?
00:15:37 <rhovland> er wait.. I meant, converting various algorithms (usually from knuth) to haskell can be rough
00:16:08 <kadoban> rhovland: http://www.amazon.com/Pearls-Functional-Algorithm-Design-Richard/dp/0521513383
00:16:10 <Cooler> levi how are you suppposed to do IO?
00:16:34 <rhovland> kadoban: er k.. I thought it was the errr.. the one about fingertrees
00:16:37 <julianleviston> Cooler: what do you mean by IO? That’s a broad topic!
00:16:44 <levi> Cooler: With functions that have signatures with 'IO' in them.
00:16:47 <julianleviston> Cooler: do you mean “how do you print “hi” to the screen"?
00:17:19 <Cooler> no i mean the main::IO() module
00:17:26 <Cooler> whats the syntax you have to use?
00:17:36 <julianleviston> Cooler: to do what?
00:17:41 <levi> You just have to write a function called 'main'
00:17:46 <rhovland> cooler: import Prelude
00:18:11 <julianleviston> Cooler: main is just a hook that GHC uses, same as in C main() is the function c programs call first.
00:18:14 <dramforever> Cooler: are you expecting to get started with haskell?
00:18:17 <levi> You don't import Prelude explicitly unless you want to use qualified Prelude names or hide Prelude names.
00:18:19 <dramforever> *attempting
00:18:33 <Axman6> Cooler: that's just a type signature, and it's usually written as main :: IO (), which means main is a value with type IO unit (equivalent to IO void)
00:18:45 <rhovland> levi: well i just know I have to import prelude or things don't work
00:18:59 <Axman6> Cooler: types are essential to learning haskell, so you should know what they are by now, given you've been here for a few days
00:19:33 <levi> rhovland: That's rather unusual. The point of a prelude is that it's implicitly imported to provide a standard set of common functions and types.
00:19:46 <rhovland> levi: something about goa
00:20:01 <rhovland> levi: emacs, ghc-mod
00:20:27 <rhovland> levi: it didn't make sense to me either, but now I import prelude, it doesn't hurt
00:21:14 <levi> Something's not configured right then, or you've copied the config of someone who doesn't like the Prelude and has -XNoImplicitPrelude turned on.
00:21:25 <dramforever> Cooler: oh looks like you already got started with haskell...
00:22:34 * hackagebot cgrep 6.5.5 - Command line tool  https://hackage.haskell.org/package/cgrep-6.5.5 (NicolaBonelli)
00:22:49 <rhovland> levi: well... dunno.. things change day-to-day, gentoo compiles things
00:23:28 <rhovland> levi: when I installed goa, I have to use import prelude on things
00:23:54 <kadoban> If gentoo is changing the meaning of your haskell code on you …
00:24:37 <rhovland> kadoban: well adding import Prelude at the top isn't a big deal
00:25:09 <kadoban> rhovland: It's pretty sketchy though. It wouldn't give me a lot of confidence in my setup if that was magically required suddenly.
00:25:39 <levi> I've never heard of goa before, what is it?
00:27:39 <rhovland> levi: "ghci on acid" or something.. using lambdabot from ghci
00:28:09 <rhovland> don't quite remember why I installed it
00:28:48 <rhovland> well, gentoo... installed it for fun
00:30:07 <levi> Yeah, it includes a .ghci that has :set -XNoImplicitPrelude
00:30:41 <rhovland> levi: it did make me aware of what I was using from prelude
00:31:53 <julianleviston> :r
00:32:03 <julianleviston> haha oops :) sorry
00:32:21 <rhovland> levi: it made me add "import Prelude" at the top, kinda like I had {-# LANGUAGE NoMonomorphismRestriction,ScopedTypeVariables,BangPatterns #-}
00:32:24 <rhovland> {-# OPTIONS_GHC -O2 #-}
00:32:45 <rhovland> levi: but the OPTIONS_GHC crashes ghci sometimes
00:33:49 <rhovland> I wish there was a way to say "do everything strict" .. just for testing purposes
00:36:06 <julianleviston> Ooh is anything that begins with _ pattern matched the same as _ on its own? (eg filter _pred []    = [])
00:36:37 <julianleviston> labellable holes?
00:36:50 <rhovland> julianleviston: hm what?
00:37:19 <julianleviston> rhovland: in this… filter _pred []    = []
00:37:31 <julianleviston> rhovland: is _pred not evaluated, just like _ is not evaluated
00:37:52 <julianleviston> rhovland: in pattern matching, therefore.
00:38:05 <rhovland> julian: _pred the same as _ pred?hm
00:38:13 <julianleviston> rhovland: what?
00:38:16 <julianleviston> rhovland: no.
00:38:27 <julianleviston> rhovland: is filter _pred []    = [] the same as filter _ [] = []
00:38:30 <rhovland> "filter _pred" .. /= " filter _ pred"
00:38:32 <julianleviston> rhovland: it seems it is
00:38:39 <julianleviston> rhovland: that’s not what I’m asking at all
00:38:49 <ReinH> > let foo _x = _x in foo 1
00:38:50 <lambdabot>  1
00:39:09 <ReinH> It is a variable, but ghc won't want if it's unused
00:39:17 <julianleviston> ReinH: can you explain this to me then? https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.List.html#local-1627397328
00:39:21 <levi> The haskell report suggests that compilers suppress warnings for unused variables if they start with _
00:39:36 <rhovland> julianleviston _pred == _ pred, isn't it? or else _pred is just a name, and the underscore doesn't matter
00:39:56 <julianleviston> levi:  but I thought named variables are still evaluated at least to WHNF if they’re not matched out with _ ? or is it just nomenclature?
00:40:13 <ReinH> _ is different. _ is reserved
00:40:24 <levi> Binding a variable doesn't force its evaluation.
00:40:40 <julianleviston> levi:  oh?
00:40:50 <julianleviston> levi:  to weak head normal form even?
00:40:51 <rhovland> levi: of course not
00:40:56 <ReinH> julianleviston: no
00:41:17 <julianleviston> then why is blah [_] better than blah [x] ? 
00:41:17 <ReinH> julianleviston: what do you want me to explain?
00:41:24 <julianleviston> or (_:_) better than (x:xs) ?
00:41:25 <levi> Pattern matches force evaluation if it is required to see if it matches.
00:41:36 <rhovland> I wanna know why _asef is differnet from asef
00:41:36 <julianleviston> ReinH: you’ve already explained it, I think.
00:41:43 <ReinH> julianleviston: only because it indicates that the identifier won't be used
00:41:51 <ReinH> to humanss
00:41:54 <julianleviston> rhovland: it’s not other than the GHC warnings, from what they said.
00:41:56 <ReinH> s/ss/s
00:42:05 <julianleviston> ReinH: Oh. I have to go re-read some books!
00:42:30 <julianleviston> Thanks.
00:42:40 <rhovland> how does underscore affect variable names?
00:42:57 <ReinH> rhovland: we just expained that
00:42:57 <levi> Like I said, the Haskell Report says that _ is lexically equivalent to a lowercase letter and encourages compilers that warn about unused variables to suppress those warnings when an identifier starts with a _ (but is not *just* _, which is a reserved identifier)
00:44:35 <rhovland> so _asdf is the same as asdf, I think
00:44:37 <levi> So, if you had a pattern like:  (a:b) -> a  you'd get a warning for not using 'b', but if you had: (a:_b) -> a  you would not, assuming the compiler followed the encouragement of the Report.
00:44:52 <ReinH> rhovland: well, one of them begins with a _
00:45:27 <levi> _asdf is the same as asdf in the way that fasdf is the same as asdf.
00:45:36 <rhovland> levi: yes
00:45:50 <levi> Aside from not triggering a warning if you don't use it.
00:46:10 <rhovland> and _ -> x is something else
00:46:14 <levi> Yes.
00:46:26 <julianleviston> I really appreciate how much attention to detail you guys give things. It’s awesome. :)
00:47:29 <levi> In recent versions of GHC, you have TypedHoles, which adds a new wrinkle in the story of _
00:48:05 <julianleviston> As E. Kmett says “Let’s do the dance” ;=)
00:49:41 <julianleviston> “Let’s start doing the dance” : https://youtu.be/hIZxTQP1ifo?t=3382
00:50:09 <rhovland> so I feel I've lost a lot by not reading knuth.. but then again, when I see stuff from knuth, it doesn't work well functional
00:50:22 <levi> Using _ (or _name where _name is *not* a bound variable in scope) tells GHC that you're not sure what should go there, and it will helpfully tell you the type of the thing that should go there.
00:51:23 <julianleviston> rhovland: it’s possibly an interesting exercise traversing between functional programming (human abstaction / high level) and imperative programming (machine abstraction / low level)
00:51:25 <levi> I enjoy reading Knuth for the amazing depth of background detail he includes.
00:51:50 <julianleviston> levi: hehe was reading a paper yesterday and it had all these pretty margin things in it they’d put in… so nice :)
00:52:17 <julianleviston> levi: concrete mathematics
00:52:22 <rhovland> knuth is awesome, but the algorithms ar really not-functional
00:52:26 <julianleviston> sorry not a paper - a book :)
00:52:27 <levi> It's no wonder it takes him so long to write his books.
00:53:16 <johnw> does anyone know of good case studies showing the merits of functional programming in industrial contexts, like: scalable, less code, more reusability, etc., but with comparative numbers to back it up?
00:53:23 <julianleviston> levi: I really like his christmast tree (trie?) lectures, but I get very lost in them :)
00:53:48 <rhovland> you can look at almost any knuth algos.. eg. DLX https://en.wikipedia.org/wiki/Dancing_Links 
00:54:03 <rhovland> and that is _really_ not set up for functional languages
00:54:17 <baweaver> johnw: https://spark.apache.org/ in which a Scala base straight murders Hadoop while using less than 5% the code footprint for users.
00:54:51 <levi> Most of the classic literature on algorithms is not really set up for functional languages.
00:55:00 <rhovland> johnw: suppose it's a problem b/c everyone else is using fuctional stuff without admitting to it
00:55:14 <baweaver> It's really not, though there is Perls of Functional Algorithm Design iirc
00:55:20 <johnw> baweaver: excellent, just the sort of thing I'm looking for
00:55:21 <baweaver> ...dangit perl
00:55:23 <baweaver> pearls
00:55:28 <julianleviston> rhovland: the main reason is an algorithm is imperative by nature. That’s what it means, right?
00:55:38 <baweaver> http://www.amazon.com/Pearls-Functional-Algorithm-Design-Richard/dp/0521513383
00:55:49 <julianleviston> rhovland: “way of deconstructing things into steps to do such that you can achieve an aim”
00:56:00 <johnw> for example, I found a study that did a fair comparison of C++ and Erlang by having two companies implement the same system in both languages, and then comparing their behaviors
00:56:01 <baweaver> Then there was Purely Functional Data Structures. 
00:56:05 <ReinH> rhovland: I've seen DLX used to solve sudoku in Haskell
00:56:09 <julianleviston> rhovland: but… any list of instructions can be integrated into a map… they’re translatable
00:56:09 <johnw> those types of studies come with a lot of good numbers
00:56:31 <baweaver> The big thing there is that Hadoop is them trying to shoehorn FP onto Java
00:56:38 <baweaver> which ends in an awful mess
00:56:39 <julianleviston> rhovland: hence how it’s an interesting exercise - you need to undertand the problem space.
00:56:40 <ReinH> rhovland: https://wiki.haskell.org/wikiupload/d/d8/DancingSudoku.lhs
00:57:29 <levi> Functional vs. Imperative is in some ways a false dichotomy.
00:57:32 <baweaver> I'd mentioned on Twitter once that it'd be interesting to see a variant of Cracking the Coding Interview in Scala / Haskell / OCaml instead.
00:57:43 <julianleviston> levi:  yeah, you need both to get anywhere.
00:58:20 <baweaver> Java is straight OO which does not play nicely with FP, or at least didn't for Hadoop.
00:58:48 <levi> We've known for a long time how to translate the semantics of procedural languages into mathematical form; this is the field of denotational semantics.
00:58:52 <baweaver> (yes yes, J8)
01:00:00 <baweaver> levi: probably most of the problem is translating the mindframe of Java/C to stateless Haskell.
01:00:08 <baweaver> especially in harder algorithms
01:00:11 <julianleviston> levi:  the moment you write something as simple as “x = (5 + 2) / 2” you’re using sequencing, which is imperative by nature.
01:00:16 <baweaver> though Rosetta Code is great for that.
01:00:43 <julianleviston> levi: kind of just a different way of looking at things… 
01:00:45 <kadoban> julianleviston: Ehhh, why is that imperative by nature? That seems denotational to me?
01:00:51 <julianleviston> kadoban: it is.
01:00:54 <levi> julianleviston: Yet sequencing can be modeled via functions.
01:01:06 <julianleviston> kadoban:  it’s declarative and yet it contains a relationship of ordering in it.
01:01:12 <julianleviston> levi: exactly!
01:01:23 <johnw> any other studies people know of?
01:01:33 * baweaver coughs turing complete languages coughs
01:01:41 <julianleviston> lol
01:01:42 <julianleviston> soz
01:01:55 <levi> And even the pure lambda calculus requires a reduction procedure to determine the normal form of an expression.
01:02:04 <rhovland> disjoint set in haskell?
01:03:02 <julianleviston> levi:  well, “evaluation” is an imperative operation ;-)
01:03:14 <levi> The important thing is whether you can express the program you need to write in a way that is both amenable to reasoning by humans and suitable for translating by computer to machine code that is efficient enough for the task.
01:03:25 <ReinH> @hackage union-find -- rhovland
01:03:25 <lambdabot> http://hackage.haskell.org/package/union-find -- rhovland
01:03:31 <ReinH> julianleviston: what?
01:03:36 <julianleviston> levi: yep.
01:03:42 <julianleviston> ReinH: what about which?
01:03:55 <ReinH> evaluation is an imperative operation?
01:04:01 <julianleviston> ReinH: yes.
01:04:01 <ReinH> in what sense?
01:04:07 <julianleviston> ReinH: in the sense that it’s an activity
01:04:11 <rhovland> reinh: mm thanks
01:04:13 <levi> Evaluation is a *procedure* to follow in order to reduce an expression to normal form.
01:04:17 <julianleviston> ReinH: someone has to do it.
01:04:22 <ReinH> what does that mean?
01:04:31 <julianleviston> ReinH: what do you mean?
01:04:35 <ggole> Evaluation can and often is loose in terms of ordering of operations
01:04:37 <ReinH> that's what I'm asking you
01:04:48 <julianleviston> ReinH: you’re asking me what you mean?
01:05:14 <julianleviston> ReinH: To evaluate something (in the sense of a program) means to work out an answer, right?
01:05:48 <julianleviston> ReinH: If it was declarative it’d already *be* the answer. 3/4 is already the most reduced shape of a thing it can be.
01:05:59 <srhb> What nonsense.
01:06:02 <ReinH> what?
01:06:04 <srhb> This is not how these terms are used.
01:06:14 <ReinH> are you just making up definitions as you go?
01:06:24 <rhovland> that the expected value?
01:06:30 <julianleviston> ReinH: all’s I’m saying is the very act of evaluating a program causes some form of “imperative” operation to take place.
01:06:37 <ReinH> no, it doesn't
01:06:40 <levi> Expressions are expressions whether they're in normal form or not. They still mean what they mean.
01:06:42 <srhb> No, this is not what the word means in programming.
01:07:14 <ReinH> maybe you're confusing evaluation with execution
01:07:22 <levi> Evaluating a program doesn't *cause* an operation, it *is* an operation.
01:07:31 <julianleviston> levi: uhhuh.
01:07:55 <rhovland> ok, I'm ok with that
01:08:13 <ReinH> there is nothing inherently imperative about evaluation
01:08:22 <julianleviston> ReinH: not in an abstract sense
01:08:43 <ReinH> evaluation is a function
01:08:43 <levi> ReinH: I'm not sure I agree.
01:08:47 <julianleviston> ReinH: but the moment it has to be “done” it starts to require some form of imperative code to get an answer, right?
01:08:59 <srhb> No, wrong.
01:09:04 <ReinH> julianleviston: is 2 + 2 imperative?
01:09:04 <julianleviston> there need to be commands at the bottom level, otherwise memory wouldn’t get moved around
01:09:10 <julianleviston> assembly is inherently imperative.
01:09:11 <rhovland> "imperative" already requires a >>= b
01:09:20 <ReinH> julianleviston: so by your definition of imperative, everything is imperative
01:09:29 <julianleviston> ReinH: no, but its evaluation involves a bottom level of “imperative” code.
01:09:32 <ReinH> so the term is meaningless
01:09:34 <julianleviston> ReinH: no
01:09:37 <julianleviston> ReinH: no!
01:09:47 <levi> Well, in the sense that an evaluation is a function that maps an expression to its normal form, it's not imperative.
01:09:47 <julianleviston> ReinH: All i’m saying is one needs both to get anything done
01:09:52 <srhb> This topic is so far removed from Haskell that it can be removed from the channel safely.
01:10:02 <julianleviston> srhb: sure.
01:10:02 <rhovland> ha
01:10:03 <ggole> Linear code is only one possible "bottom level": there are things like data flow and graph reduction machines that aren't linear at all
01:10:12 <julianleviston> srhb: I’ll stop talking about it now.
01:10:13 <ggole> And besides, CPUs delinearize as soon as possible anyway
01:10:28 <montanonic> #haskell-blah
01:10:31 <ReinH> ggole: guess which one GHC is ;)
01:11:13 <ReinH> hint: it's what the G in STG machine stands for
01:11:45 <ggole> I had physical machines in mind, but yeah
01:11:50 <levi> Haskell is described in the Report via informal denotational semantics, but GHC is (as ReinH mentioned) described in terms of an operational semantics, the STG *machine*.
01:13:14 <rhovland> bah
01:13:26 <levi> Part of the point of the paper that introduced the STG machine was to describe a correspondence between the denotational and operational semantics.
01:16:11 <montanonic> Anyone else think that the Haskell wikibook should have Monads *after* Applicative Functors? I get that they are ubiquitous in Haskell, but honestly, it doesn't make sense to go from Functor to Monad while skipping Applicative (to me at least).
01:16:32 <levi> montanonic: Applicative is a relative newcomer to the Haskell scene.
01:16:59 <montanonic> levi: ah, okay; is it nonetheless agreeable to say that they are a good intermediary point between Functors and Monads?
01:17:09 <Iceland_jack> montanonic: Absolutely, as levi says Applicative is fairly recent
01:17:17 <srhb> montanonic: In many ways I agree, but I think most people want to expose newcomers to decision making in IO pretty quickly.
01:17:22 <srhb> montanonic: That might be a mistake.
01:17:29 <levi> They certainly are, but it has taken a while for them to become ingrained in common usage.
01:17:38 <Iceland_jack> srhb: You don't need Monad for using IO
01:17:47 <montanonic> Hmm, okay. I'm just wondering if I should propose edits to the wikibook to this effect.
01:18:07 <srhb> Iceland_jack: I didn't claim so. :)
01:18:10 <levi> For a while, it looked like Arrows were going to be a big thing, but Applicative has more or less replaced them for most of the things they were used for.
01:18:40 <montanonic> levi: really? See everyone has seemed to indicate that Arrows aren't really worth it anymore
01:19:01 <montanonic> I'm new to all of this so I'm not up to speed on reasons
01:19:11 <montanonic> you've already provided one, of course
01:19:14 <levi> montanonic: I'm talking about over the course of the past 5-10 years or so?
01:19:59 <montanonic> ah, okay
01:20:21 <levi> I don't recall how long it's been. But Arrows were the Big New Thing and everyone was writing Arrow libraries for parsing XML and whatnot.
01:20:41 <levi> They even got their own syntax!
01:20:54 <montanonic> what were their drawbacks?
01:21:29 <Iceland_jack> srhb: Indeed :) but even if you use (>>=)/join underneath, the do-notation hides it just fine
01:21:31 <levi> The relative deprecation of Arrow seems to have come about as a result of the rise of acceptance of Applicative functors.
01:22:01 <srhb> Iceland_jack: My point was more that you can't implement ifM, etc. IO without the monad would be scary. :-)
01:23:27 <levi> I don't recall the reasons people put forth for not liking Arrow, but I think they were a mix of practical and theoretical concerns.
01:23:35 <rhovland> not sure about arrows, but lens seems to still be useful
01:23:47 <montanonic> levi: okay, thank you
01:23:49 <levi> Lens is even newer.
01:23:52 <Iceland_jack> I feel that's a separate point, you can implement ifM using do-notation just fine, I have no issues with using some Monad goodness under the bonnet
01:24:40 <ReinH> lens is a baby in Haskell terms
01:24:41 <Iceland_jack> But then again I happen to like to show 
01:24:41 <Iceland_jack>     main = do
01:24:41 <Iceland_jack>       line <- getLine
01:24:41 <Iceland_jack>       putStrLn ("Hello, " ++ line)
01:24:44 <levi> The idea of using lenses has been around for a while, but not the current 'grand unified lens library' thing we've got.
01:24:44 <Iceland_jack> to newcomers, just to make them not^Wless scared?
01:25:08 <srhb> Iceland_jack: Erm.. Well, it wasn my point, there was nothing separate from it :-)
01:25:17 <srhb> was my*
01:26:01 <Iceland_jack> My bad :)
01:26:12 <srhb> No problem! I'm sure the other points are important too.
01:26:30 <levi> If you go back a bit further, there was a time before Haskell had (or was able to define) the typeclasses for Functor and Monad.
01:27:06 <Iceland_jack> If you go back slightly less further, 'map' was a Functor method iirc :)
01:27:38 * hackagebot MFlow 0.4.5.13 - stateful, RESTful web framework  https://hackage.haskell.org/package/MFlow-0.4.5.13 (AlbertoCorona)
01:27:54 <levi> Yeah, it got moved there from List, and then moved back.
01:28:03 <Iceland_jack> There's augustss discussing it http://stackoverflow.com/questions/6824255/whats-the-point-of-map-in-haskell-when-there-is-fmap#comment8112310_6824333
01:30:50 <srhb> Wow, type classes were called constructor classes...
01:31:03 <levi> No, not all of them.
01:31:06 <srhb> Oh?
01:31:37 <levi> Type classes were in the original Haskell, but only plain types could belong to them, not type constructors.
01:31:47 <levi> I.e., types of kind *
01:31:56 <srhb> Ah
01:32:02 <srhb> So it was a distinction.
01:33:15 <levi> Monoid and Num would be implementable, but things like Functor and Monad were originally called constructor classes because they couldn't be implemented in Haskell's type class system.
01:33:26 * Iceland_jack . o O (( Next step to combine all the different forms of fmap/(<$>)/(<&>)/map as (.)... ))
01:34:42 <levi> Once Haskell got the ability to make type classes over type constructors, the distinction in terms between 'type class' and 'constructor class' was dropped.
01:35:16 <Iceland_jack> levi: Do you know when that happened?
01:35:37 <levi> I think at the same time Functor and Monad were introduced.
01:35:45 <srhb> I don't think so.
01:36:07 <levi> But they existed in hugs before they were officially part of the language.
01:36:29 <levi> As they came from Gofer, and hugs is short for 'Haskell Users Gofer System'
01:37:04 <srhb> oh. :D
01:37:20 <srhb> These are fun trivia.
01:37:43 <ReinH> Gofer was weird
01:39:21 <fr33domlover> If I export a type without any of its constructors, and then I add a new constructor, does it break binary compatibility?
01:40:37 * Maxdamantus is pretty sure Haskell doesn't have a notion of binary compatibility, and suspects GHC doesn't expose something like that either.
01:41:08 <Maxdamantus> usually with GHC you end up statically linking everything anyway.
01:41:30 <levi> https://www.haskell.org/definition/from12to13.html
01:41:53 <julianleviston> Maxdamantus:  doesn’t it actually strip types at compile time after checking?
01:42:09 <levi> Indeed, constructor classes, do notation, and the monad-based IO were introduced in the same version of the report.
01:42:23 <julianleviston> Maxdamantus: oh… nevmerind - he wasn’t talking about compiling
01:43:14 <Maxdamantus> I wouldn't expect you'd be able to derive all the types from the compiled code, if that's what you mean.
01:43:24 <levi> julianleviston: GHC actually uses a typed intermediate language. The types are eventually erased, but keeping them around helps to ensure that the transformations in the compiler are correct.
01:43:30 <Maxdamantus> but types are just things that people and compilers reason in terms of.
01:46:13 <levi> Maxdamantus: GHC *can* do dynamic linking. Haskell-the-language doesn't have much in the way of operational specification, aside from bits about how IO and the FFI should work.
01:49:05 <levi> BTW, the notion of 'kinds' as part of the language was also introduced in 1.3 as part of the constructor class support.
01:49:06 <Maxdamantus> Yeah, it also uses objects with machine code when producing the static binaries, but I suspect there isn't really an assumption you'd be able to use the code between different versions of GHC, etc
01:50:23 <levi> Generally not, as far as I remember.
01:51:25 <fr33domlover> so I assume compatibility is in terms of type, not binary
01:51:25 <julianleviston> levi: ooh I heard kinds are going away! :)  and turning into types...
01:51:32 * Maxdamantus tends to like the idea of just using dynamic linking as a possible space optimisation.
01:51:48 <Maxdamantus> and not as an interface for swapping code.
01:53:51 <levi> julianleviston: Hmmm... are you referring to the 'levity polymorphism' work?
01:54:04 <Maxdamantus> -rwxr-xr-x 1 max max  21M Mar  8  2014 xmonad-arm-linux
01:54:09 <Maxdamantus> Wow, didn't notice that.
01:54:30 <levi> Didn't notice what?
01:54:46 <Maxdamantus> 8.6 MiB after stripping, still pretty significant.
01:55:07 <Maxdamantus> that the xmonad binary is so big.
01:55:12 <Cooler> if you need to use a hash table, do you have to use a monad to access memory?
01:55:23 * Maxdamantus has been thinking of replacing his phone's WM with xmonad.
01:55:29 <julianleviston> Cooler: you might be better off using a map.
01:55:37 <julianleviston> Cooler: or do you specifically need a hash table?
01:55:56 <levi> Cooler: You can use a HashMap without being in a monad.
01:56:28 <julianleviston> Cooler: sorry hashmap*
01:56:28 <levi> You can find HashMap in unordered-containers
01:57:08 <julianleviston> levi: oh I’m not sure (about levity polymorphism) nevermind. I was just watchind an ICFP video the other day about it, is all
01:58:19 <Cooler> this is an external hashmap in memory
01:58:44 <Cooler> hash table even
01:58:51 <levi> Yeah, there was an ICFP video about kind-level polymorphism, which was called 'levity polymorphism' intstead of 'liftedness polymorphism' because it sounds more fun. :)
01:59:12 <levi> Cooler: You'll have to use IO, then.
02:00:18 <levi> Because it's doing IO effects if it's accessing an external hash table in memory.
02:00:36 <ReinH> Cooler: why would you want to use an external hashmap in memory?
02:00:54 <julianleviston> levi: I was talking about dependent types… https://www.youtube.com/watch?v=W6a36RoFeNw
02:01:02 <levi> Oh, okay.
02:02:04 <levi> That makes more sense.
02:02:40 <levi> ReinH: Lots of people use them. Stuff like memcached or redis or whatever.
02:03:05 <levi> Not sure if that's what Cooler is referring to, though.
02:03:08 <julianleviston> johnw: are you still here?
02:03:14 <johnw> yeah, I'm here
02:03:18 <julianleviston> johnw: this might help your cause: https://www.youtube.com/watch?v=IOEGfnjh92o
02:03:32 <johnw> heh, I was in the audience :)
02:03:40 <johnw> thanks!
02:03:42 <julianleviston> johnw:  oh..  lol! :)
02:03:43 <julianleviston> sorry
02:04:00 <johnw> no, I'm looking for anything, even stuff I already know :)
02:04:06 <julianleviston> johnw:  are you trying to convince some pointy haired bosses?
02:04:38 <johnw> it's a gov't proposal, to motivate the use of FP+DSL over OO languages and UML-like design tools
02:04:41 <amicuscuriae> julianleviston, I am looking for an editor yet lol :)
02:04:54 <julianleviston> amicuscuriae: “still”.
02:05:14 <ReinH> levi: I don't think "accessing memory" is how most people would describe interacting with redis
02:05:26 <julianleviston> amicuscuriae: use whatever you like… it makes little difference.
02:05:36 <amicuscuriae> julianleviston, I want something cool
02:05:50 <julianleviston> amicuscuriae: what are your criteria for cool?
02:05:54 <ReinH> I'm wondering if they think they need to use hash tables with haskell
02:07:14 <amicuscuriae> julianleviston, SublimeText like but Libre
02:07:31 <julianleviston> amicuscuriae: atom
02:07:35 <levi> Well, I meant the general idea of a hash table in either shared memory or an external process as an interprocess communication mechanism, not just those specific implementations.
02:07:46 <amicuscuriae> julianleviston, ok atom works out of the box with Haskell?
02:07:46 <julianleviston> amicuscuriae: or TextMate.
02:08:05 <julianleviston> amicuscuriae: there are plugins. Nothing works out of the box with Haskell, apart from Leksah, I don’t think.
02:08:24 <amicuscuriae> julianleviston, ok then Leksah it is
02:09:00 <julianleviston> johnw: ah… did you see any of the jane street stuff?
02:09:05 <julianleviston> amicuscuriae: it’s a bit buggy
02:09:29 <julianleviston> amicuscuriae: YMMV, but that’s just in my experience - I gave it up becaues it was too slow and janky for my liking
02:09:44 <levi> ReinH: I was assuming this was an already-existing hash table they wanted to access, but I suppose they might want to create it as well.
02:09:57 <julianleviston> johnw: jane street use OCaml to do huge amounts of things, from memory
02:10:07 <johnw> right
02:10:29 <julianleviston> johnw: realise that’s not very concrete
02:10:31 <spaceloop> amicuscuriae: Leksah is not perfect yet, I'm working on improving it, please let me know if you have any problems or suggestsion ;)
02:10:54 <johnw> the most convincing data would be: location A tried to use language X and resulting in YEARS/SLOC/CAPABILITY, while location B used language Y resulting in ...  with a quantitative win for FP
02:12:00 <julianleviston> johnw: there are a lot of customers stories on the cognitect website (clojure) http://cognitect.com/resources#success-stories
02:12:33 <johnw> ooh, some of those are nice, thanks
02:12:38 <julianleviston> johnw:  theyr’e quite good at PR
02:13:16 <julianleviston> spacebug: I’d happily give you feedback, too, if you’d like - where’s best to give you feedback?
02:13:33 <julianleviston> spacebug: on the github acct?
02:14:02 <levi> johnw: The VP of engineering at LucidChart came to a local meetup a while back to talk about how they were rewriting their codebase from PHP to... Scala, I think? It's been a while, my memory is a bit fuzzy.
02:14:46 <levi> I don't have any hard numbers, obviously, but if you reach out to them they might have something that could help you.
02:15:11 <johnw> levi: https://www.lucidchart.com/techblog/2012/12/18/using-scala-to-handle-exponential-growth-at-a-startup/
02:15:36 <levi> Well, there you go. :)
02:15:41 <julianleviston> johnw: and twitter is an excellent example
02:15:56 <julianleviston> johnw: in fact they’re possibly one of the best examples possible.
02:17:35 <julianleviston> johnw: they were using Ruby / Rails, pretty sure… switched to Scala and built their own backend version of hadoop sort of thingie… 
02:18:40 <julianleviston> johnw: also, linked-in switched to a thing that they built called apache samza, which is written in clojure mostly… that’s really interesting, because it’s built on top of apache kafka, but it uses an inverted database kind of thing which equates to a massive stream as the database, cached at appropriate positions. 
02:19:57 <julianleviston> johnw: effectively taking the imperative structure and remapping the whole thing to a form of declarative stream over time kind of like wrappering FRP around their whole DB. It’s let them scale to massive sizes.
02:21:51 <fishburne> Is there a uniform way to read from text files. I Just found that even after setting unicode encoding to a handle, hGetContents will include the initial BOM in the returned data.
02:22:15 <fishburne> *unicode -> utf8
02:22:44 <levi> UTF8 shouldn't have a byte order mark?
02:23:13 <fishburne> levi: It is optional, I think
02:23:21 <Reshi> Can I have a return statement without do if that's the only thing I am doing
02:23:50 <ChristianS> levi, fishburne: technically optional but generally strongly advised against
02:24:12 <ChristianS> bom is only meant for utf16, actually
02:24:30 <fishburne> ChristianS: Yes. But that does not help me when I have to deal with files downloaded from the wild..
02:25:06 <ChristianS> fishburne: in that case, you should probably be prepared to ignore a bom, if present
02:25:19 <dramforever> fishburne: can you somehow treat the bom like any other char? because I think it's a valid char anyway
02:25:39 <fishburne> ChristianS: That is what I am doing now.  I just use dropwhile until it is over.
02:25:42 <ReinH> Reshi: return is just a function
02:25:49 <ReinH> > return 1 :: Just Int
02:25:50 <lambdabot>      Expected a type, but ‘Just Int’ has kind ‘Maybe *’
02:25:50 <lambdabot>      In an expression type signature: Just Int
02:25:50 <lambdabot>      In the expression: return 1 :: Just Int
02:25:55 <ReinH> > return 1 :: Maybe Int
02:25:56 <lambdabot>  Just 1
02:25:57 <ReinH> lol
02:26:24 <dramforever> fishburne: wait I think that bom thing should parse into a single char, so if it doesn't then something is really wrong
02:26:30 <Reshi> ReinH: yes thank you! I thought about it for more than a second and realised I was being foolish. do just makes >>= neater
02:26:31 <dramforever> or are you just reading bytes?
02:27:06 <levi> Which hGetContents are you using?
02:27:16 <fishburne> dramforever: If am expecting a Parsec.digit at the start of my stream...so the initial BOM prevents it even from starting the parsing.
02:27:40 <dramforever> (that was train-of-thought style talking, feel free to tell me if you feel uncomfortable)
02:27:54 <dramforever> fishburne: ok then, sounds reasonable
02:29:47 <fishburne> levi: Now I am using ByteStrings.hContents, but I have also tried the default one, when the file was opened in Text mode.
02:30:41 <levi> Maybe try Data.Text.IO?
02:31:14 <levi> Not sure what the difference in codec handling is between them, if any.
02:34:01 <levi> Apparently there's a utf8_bom encoding as well as utf8. Try using that. :)
02:34:58 <fishburne> levi: But will it handle files without the bom too? 
02:35:18 <levi> Probably.
02:36:46 <levi> Yes, I looked at the source. It will handle files without it just fine.
02:38:48 <levi> At the beginning of the file, it looks for a bom and skips it if it finds it. Either way, it just calls on to the standard utf8 decoder from that point on.
02:42:42 * hackagebot connection-pool 0.1.3 - Connection pool built on top of resource-pool and streaming-commons.  https://hackage.haskell.org/package/connection-pool-0.1.3 (PeterTrsko)
03:02:13 <Cooler> i am trying to execute this example on monads
03:02:15 <Cooler> http://pastebin.com/neETSfSm
03:02:28 <Cooler> its giving a error
03:03:35 <Cooler> No instance for (Applicative Labeled)
03:03:35 <Cooler>       arising from the superclasses of an instance declaration
03:03:35 <Cooler>     In the instance declaration for `Monad Labeled'
03:03:35 <Cooler> Failed, modules loaded: none.
03:03:35 <Cooler> Prelude>
03:04:51 <julianleviston> Cooler: forgive me, but didn’t you just start Haskell today?
03:08:00 <levi> Cooler: It used to be the case that you could make a Monad instance for a type like that, but now you also have to define a Functor and Applicative instance.
03:09:36 <Cooler> levi,  what exactly does that entail?
03:10:52 <levi> You write something like the code there that's making the Monad instace (i.e. the lines that begin with the one that starts with 'instance') except for the Functor and Applicative.
03:13:20 <levi> I'm off to sleep. Bye!
03:14:46 <julianleviston> levi:  sleep tight!
03:14:46 <jdnavarro> I'm trying to find out where exactly a FFI function is being called for a given Haskell executable
03:15:12 <jdnavarro> concretely I'm looking for ncurses calls
03:15:27 <jdnavarro> if I knew the package it'd be enough
03:22:37 <int-e> jdnavarro: How about looking at packages' extra libraries as a starting point, e.g.  for i in $(ghc-pkg list --simple-output); do echo $i $(ghc-pkg field $i extra-libraries); done
03:24:02 <jdnavarro> int-e, thanks that helps
03:25:43 <jdnavarro> I'm following the trail: optparser-applicative -> ansi-wl-print -> ansi-terminal -> unix
03:25:56 <jdnavarro> but can't find where the dynamic library is actually loaded...
03:30:35 <pikajude> is thyme still a recommended library?
03:34:35 <kaidelong> AFAIK yes
03:36:51 <int-e> jdnavarro: I don't think that any of those should bring in ncurses.
03:46:45 <jdnavarro> int-e, found it, it's terminfo
03:46:49 <jdnavarro> thanks!
04:03:57 <fabian__> Im writing a multi-threaded server in Haskell. When I enabled threads by setting ghc-options to '-rtsopts -threaded -with-rtsopts=-N', the server segfaults..
04:05:04 <fabian__> with double free or corruption (fasttop): 0x00000000030cbd10 ***
04:26:58 <Walther> Hmm. I'm trying out stack. I ran stack install hakyll, hakyll-init, and stack init. However if I try to build the project with ghc --make site.hs I get error for Hakyll not found (asssuming it tries to use cabal-based stuff), or if I use stack build, I don't seem to get an executable
04:27:48 * hackagebot lattices 1.4 - Fine-grained library for constructing and manipulating lattices  https://hackage.haskell.org/package/lattices-1.4 (phadej)
04:29:48 <Walther> Ah, stack ghc -- --make site.hs; seemed to be the correct way :)
04:50:31 <srhb> fabian__: Can you paste a program that exhibits this behaviour?
04:52:08 <fabian__> srhb: I got help in GHC, I was using a ODBC connection from multiple threads
04:52:08 <wshcdr> :)
04:52:17 <srhb> fabian__: OK, great :)
04:52:37 <wshcdr> anyone who knows haskell Parser?
04:53:47 <srhb> wshcdr: Do you mean a parser that parses the Haskell language, or a general parser library for Haskell?
04:57:08 <wshcdr_> general parser library for haskell
04:57:47 <srhb> wshcdr_: There are a lot of them. One of the most common parser combinator libraries is Parsec. :)
04:58:26 <srhb> People may be able to give you more specific recommendations if you try to describe the problem you are trying to solve.
04:58:40 <fabian__> A network question: recv 1 bytes (Network.Socket) returns 0 bytes, which would suggest that the connection is closed. However, I really don't think that the connection is closed, could there be any other reason?
04:58:41 <wshcdr_> I will take a try. thanks
05:03:25 <pikajude> does th have a library function for showing a Loc in a friendly way?
05:17:55 <fvgvxmpv1> pikajude: show?
05:18:25 <pikajude> i was looking for something more like what GHC gives you
05:27:39 <fabian__> Seriously, why is recv returning [] when I request 1 byte and the connection is not closed?
05:27:42 <flexfit> How do you generally build a tuple recursively? I know that generally you build lists by doing something like x:foo x, but what do you do for lists?
05:27:47 <flexfit> er tuples
05:29:05 <srhb> flexfit: Depends what you mean. You need a set return type, after all.
05:29:11 <ggole> You can nest them easily enough
05:29:19 <ggole> eg tuple_cons a t = (a, t)
05:30:30 <flexfit> I'm trying to write my own version of unzip. So it would be something like [(a,b)] -> ([a],[b])
05:32:15 <srhb> flexfit: There's no recursive tuple building there though.
05:32:51 <ggole> Oh, it's not the *tuple* that is recursive.
05:33:27 <flexfit> What would be recursive in this case then?
05:33:36 <srhb> You're recursing through the list
05:33:41 <ggole> unzip itself
05:33:41 <srhb> Or through some other combinator :)
05:35:06 <srhb> flexfit: yourUnzip 
05:35:08 <srhb> Woops
05:35:35 <flexfit> Then you're iterating through each tuple in the list?
05:36:03 <srhb> flexfit: yourUnzip pairs = someHelper pairs ([],[]) might be helpful. Now someHelper will "fill" its second parameter, adding each element from the tuple to each list as it goes along.
05:36:22 <srhb> flexfit: This is just one way to do it of course.
05:36:46 <ggole> Probably good to write it a few ways
05:36:51 * srhb nods
05:37:28 <pavonia> fabian__: Do you have some code to show?
05:38:58 <flexfit> I'm getting a parse error on line 3, but I'm not sure why. http://pastebin.com/1j0GUjds.
05:39:25 <srhb> flexfit: Needs more parens
05:39:35 <scshunt> flexfit: stick the : in parens
05:40:37 <akegalj> https://en.wikibooks.org/wiki/Haskell/Monad_transformers#Application_to_the_passphrase_example says that `guard` is provided by MonadPlus. But guard :: Alternative f => Bool -> f () , doesn't MonadT then need to have instance of Alternative?
05:41:02 <akegalj> s/MonadT/MaybeT
05:41:51 <flexfit> Where would I need more parens? I thought I closed all the parens though.
05:42:01 <srhb> flexfit: ((x,y,z):xs)
05:42:47 <flexfit> So what is GHC interpreting the code as when I don't have the parens?
05:42:52 * hackagebot range-set-list 0.1.0.0 - Memory efficient sets with continuous ranges of elements.  https://hackage.haskell.org/package/range-set-list-0.1.0.0 (phadej)
05:43:18 <ggole> A misformed program?
05:43:25 <srhb> flexfit: What you wrote is parsed as (unzip3 (x,y,z)) : xs -- which makes no sense.
05:43:35 <breadmonster> :t unzip
05:43:36 <lambdabot> [(a, b)] -> ([a], [b])
05:43:47 <amicuscuriae> when we have cons operator why ++ ?
05:43:48 <flexfit> srhb: I see
05:44:02 <srhb> amicuscuriae: ++ concats two lists together. cons adds an element to a list.
05:44:17 <pavonia> :t (:)
05:44:17 <KaneTW> :t (:)
05:44:18 <lambdabot> a -> [a] -> [a]
05:44:18 <flexfit> amicuscuriae: cons is also much much faster
05:44:18 <lambdabot> a -> [a] -> [a]
05:44:19 <pavonia> :t (++)
05:44:20 <lambdabot> [a] -> [a] -> [a]
05:44:40 <KaneTW> @src (++)
05:44:41 <lambdabot> []     ++ ys = ys
05:44:41 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
05:44:41 <lambdabot> -- OR
05:44:41 <lambdabot> xs ++ ys = foldr (:) ys xs
05:44:52 <KaneTW> whereas (:) is just a constructor
05:45:07 <flexfit> amicuscuriae: Since ++ has to iterate through both lists, which is a pain if they're both huge lists.
05:45:16 <srhb> flexfit: Not both.
05:45:39 <breadmonster> flexfit: Just the first list.
05:46:04 <ggole> You could easily do [elt] ++ list instead of cons
05:46:21 <ggole> *But* only on the RHS. The constructor is necessary for pattern matching.
05:46:46 <amicuscuriae> flexfit, ok
05:46:50 <amicuscuriae> KaneTW, I see 
05:47:17 <amicuscuriae> Why "let" if it is not required in the source code?
05:47:19 <amicuscuriae> or is it?
05:47:35 <flexfit> srhb, breadmonster: My bad. I must have misrememberd. From what I gather, cons is almost always prefered though.
05:47:50 <srhb> amicuscuriae: Are you asking why you need to write let foo = bar in ghci instead of just foo = bar ?
05:48:49 <amicuscuriae> srhb, yep
05:48:50 <srhb> amicuscuriae: Because ghci is basically a giant do-block, not a top level as your source file would be.
05:49:02 <amicuscuriae> ok
05:49:05 <srhb> If do block doesn't mean much to you yet, don't worry too much about it. :)
05:49:13 <amicuscuriae> srhb, I am going to compile .hs to binary now
05:49:35 <amicuscuriae> srhb, how do we do it?
05:49:49 <srhb> amicuscuriae: Write a source file with a main action and run ghc yoursourcefile.hs
05:50:26 <amicuscuriae> in ghci
05:50:29 <amicuscuriae> ?
05:50:34 <srhb> No, in your shell.
05:50:43 <breadmonster> srhb: Should we change that?
05:50:49 <srhb> breadmonster: Change what?
05:50:53 <breadmonster> And allow for direct top level definitions in ghci?
05:51:03 <srhb> I don't think so. I saw the discussion and I disagree that it's a good idea.
05:51:30 <breadmonster> srhb: Discussion? Where?
05:51:34 <breadmonster> haskell-cafe?
05:51:43 <srhb> breadmonster: The haskell subreddit, iirc.
05:52:25 <srhb> breadmonster: https://www.reddit.com/r/haskell/comments/3ks5mi/function_definition_in_ghci/
05:52:49 <ggole> Top level definitions are supposed to all recurse, but you are supposed to be able to run code immediately after typing in a definition.
05:52:53 <ggole> How would that work?
05:54:31 <breadmonster> srhb: Why don't you think it's a good idea?
05:55:29 <srhb> breadmonster: I think it should be clear that we are, semantically, in an environment that behaves like a do block. In a do block, you use let foo = bar; stmts.
05:56:09 <amicuscuriae> [3,2,1] > [2,10,100]
05:56:14 <amicuscuriae> how is this true?
05:56:15 <srhb> I wouldn't mind as much if we just agreed that it _doesn't_ behave like a do block anymore, but then foo <- bar should be disallowed etc.
05:56:49 <srhb> amicuscuriae: Presumably because the Ord instance does not continue after concluding that 3 > 2, but you'd have to actually read the instance definition to be sure.
05:58:36 <amicuscuriae> srhb, I don't understand
05:58:56 <srhb> amicuscuriae: So, (>) uses the Ord instance for your type. In this case, Ord a => Ord [a]
05:59:04 <flexfit> http://pastebin.com/DwpQ6Fe1 Is there a better way for me to implement unzip3? Without using folds? I know the official implementation uses folds, but I was exploring efficient alternate ways to implement the function without using the official one.
06:00:28 <tekkkz> Hello! I have this code: http://ix.io/kUX and I want to make a function where the alphabet (keys called) shold be builded with the length given, e.g. length 3, then it should generate "000" "001" ... "zzy" "zzz" so every possible combination should be printed out, how to make this?
06:01:19 <dramforever> tekkkz: do you know about the list monad?
06:01:59 <srhb> amicuscuriae: And that implementation is true as soon as it is pairwise true for the elements. And 3 is indeed greater than 2
06:02:20 <amicuscuriae> but its a list
06:02:50 <JagaJaga> I need to pass the same argument to 3 functions "in a row". How to do that in a pretty way?
06:02:57 <tekkkz> dramforever, no, will it helps me? should i have a look at it? im new since yesterday so i dont know it yet
06:03:20 <hodapp> JagaJaga: do they all return the same type?
06:03:41 <JagaJaga> hodapp: yes
06:03:45 <dramforever> tekkkz: yes it helps so greatly that there's a function for that, and no you should learn at your current pace rather than jumping around
06:04:08 <srhb> amicuscuriae: And?
06:04:09 <dramforever> > replicateM 3 "abc" -- this is an answer, simplified to make output shorter
06:04:10 <JagaJaga> :t (&&&)
06:04:11 <lambdabot>  ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","bb...
06:04:12 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
06:04:18 <srhb> amicuscuriae: Lists can have Ord instances too.
06:04:51 <amicuscuriae> srhb, it has to compare each item in the list .. I don't follow Ord sorry, also it says only if first element is equal it would head for next
06:04:53 <hodapp> > map ($ 10) [(+ 1), (+ 2), (+ 3)]
06:04:55 <lambdabot>  [11,12,13]
06:05:00 <hodapp> JagaJaga: just put them in a list, like that.
06:05:23 <srhb> amicuscuriae: Yes, and they are not equal, so it is just true. You could define an Ord instance that behaved differently, if you'd like.
06:05:39 <tekkkz> dramforever, what do you mean with the learning part o your sentence?
06:06:12 <JagaJaga> hodapp: oh, no, they depend on each other. like \a -> f 1 a >>= \m -> b m a >>= \n -> c n a 
06:06:16 <dramforever> tekkkz: just keep learning by whatever way you are currently using
06:06:38 <srhb> amicuscuriae: Are you trying to compare each element pairwise and get the result for each of them? If so, try using map.
06:07:00 <amicuscuriae> srhb, ok should I install haskell-platform ?
06:07:06 <amicuscuriae> I am ready to install it now
06:07:27 <srhb> amicuscuriae: I don't personally use it. I don't know if you want it.
06:07:33 <srhb> amicuscuriae: Don't you already have ghc/ghci ?
06:08:24 <amicuscuriae> in Debian?
06:08:25 <amicuscuriae> wait
06:08:34 <amicuscuriae> no
06:08:37 <amicuscuriae> it is not there 
06:08:42 <hodapp> JagaJaga: can you show a less convoluted example than that nested lambda?
06:08:51 <amicuscuriae> srhb, Should I just install the compiler? ghc and ghci?
06:09:01 <tekkkz> dramforever, i dont have a way, can you ercommend any structure or learning strategy?
06:09:16 <srhb> amicuscuriae: I don't know what's smartest on Debian.
06:09:25 <dramforever> tekkkz: um...no, sorry...
06:09:28 <srhb> amicuscuriae: I think you'd probably be fine just installing ghc.
06:10:00 <amicuscuriae> ok
06:10:02 <tekkkz> dramforever, just some tipps how i could learn it good?
06:10:27 <dramforever> tekkkz: bitemyapp wrote some here, check it out https://github.com/bitemyapp/learnhaskell
06:11:08 <pikajude> can I import ClassyPrelude and exclude everything it reexports from Data.Time?
06:11:18 <pikajude> or do I have to list all the symbols manually?
06:11:33 <dramforever> tekkkz: btw you should really try to figure that problem out, it would be an interesting exercise. hint: how would you do it by hand?
06:12:10 <tekkkz> dramforever, what do you mean now?
06:13:06 <dramforever> tekkkz: I don't think it's good for you if I guide you through this, so I'll give you some hints and let you figure it out yourself
06:13:35 <tekkkz> dramforever, okay, so explain your question pls
06:14:09 <dramforever> tekkkz: sorry I'm not a native English speaker and often struggle to express myself, and that might lead to some confusing stuff
06:14:15 <JagaJaga> hodapp: `let keyname = "foo" in generateKey keyName >> cryptDevice device keyName >> copyFileToEtc keyName >> openDevice device keyName`
06:14:58 <dramforever> tekkkz: if you write down those strings by hand, what rules do you follow?
06:15:15 <JagaJaga> @pl \keyName -> generateKey keyName >> cryptDevice device keyName >> copyFileToEtc keyName >> openDevice device keyName
06:15:15 <lambdabot> ap ((>>) . ap ((>>) . liftM2 (>>) generateKey (cryptDevice device)) copyFileToEtc) (openDevice device)
06:15:29 <hodapp> JagaJaga: I think you just need mapM_ or something similar in that case
06:16:43 <tekkkz> dramforever, im german, 17 years, so who you wanna tell about english problems? :D Okay, i think im going through char to char of the string which should get generated, and for every position there will be sth like a loop where the position in my array is increased by 1, right?
06:20:06 <dramforever> tekkkz: hmm...now *I'm* not understanding *you*. I'm not getting the "for every position" part this time
06:21:56 <dramforever> tekkkz: sorry, bedtime here, gotta go
06:22:55 * hackagebot json-autotype 1.0.8 - Automatic type declaration for JSON input data  https://hackage.haskell.org/package/json-autotype-1.0.8 (MichalGajda)
06:23:20 <tekkkz> byebye, gn8
06:27:55 * hackagebot dynamic-mvector 0.1.0.4 - A wrapper around MVector that enables pushing, popping and extending.  https://hackage.haskell.org/package/dynamic-mvector-0.1.0.4 (AndrasKovacs)
06:30:15 <XniX23> i know this isnt haskell specific, but do you guys know of a book that explains the differences between languages like for instance (HKP, algebraic datatypes, why some use null and others dont, etc.) in an easy way?
06:45:00 <knupfer> Is it recommendable to always use Integer and use Int only after performance issues and profiling?  I'm asking because haskell is quite mathematical and Int is just an implementation detail...
06:51:03 <meretrix> knupfer: I always use Int, as I think most people do.  I've never needed more than a 64-bit integer in my work.
06:52:40 <knupfer> meretrix: I also always use Int, I just wondered because Int is a low level concept compared to Integer
06:54:22 <ChristianS> meretrix: though Int is 64-bit only on 64-bit platforms, right?
06:54:33 <knupfer> ChristianS: yes
06:54:54 <knupfer> Int is machine dependent, ergo low level
06:58:00 <meretrix> Well depends what you're doing.  Floating point math may not be appropriate either.
06:58:06 <knupfer> Another performance question: why doesn't ghc fully evaluate on compile time every pure function which is used in main?  Looking at http://stackoverflow.com/questions/3646330/how-to-improve-the-performance-of-this-haskell-program/3646472#3646472 it seems strange that the runtime isn't 0s
06:59:54 <hodapp> To paraphrase Alan Perlis, it's low-level if it requires attention to the irrelevant, and the use of Int doesn't particularly *require* any attention until you're within a few orders of magnitude of, say, 2^32.
07:03:52 <meretrix> Floating point math always requires a little attention, otherwise seemingly basic things can go wrong:
07:03:57 <meretrix> > 0.3 == 0.1 + 0.1 + 0.1
07:03:58 <lambdabot>  False
07:04:52 <voidzero> from a computer standpoint this is true
07:05:21 <voidzero> https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
07:05:26 <voidzero> "What Every Computer Scientist Should Know About Floating-Point Arithmetic
07:05:28 <voidzero> "
07:05:48 <shiona_> is there a monad that keeps tabs if a floating point computation is accurate?
07:05:49 <meretrix> from that perspective, computer programs never have bugs.. except for cosmic rays shifting bits
07:06:07 <hodapp> meretrix: what?
07:06:20 <knupfer> M-x butterfly 
07:07:26 <knupfer> citing the manual:
07:07:36 <knupfer> butterfly is an interactive autoloaded compiled Lisp function in
07:07:36 <knupfer> `misc.el'.
07:07:36 <knupfer>  
07:07:36 <knupfer> (butterfly)
07:07:39 <knupfer>  
07:07:42 <knupfer> Use butterflies to flip the desired bit on the drive platter.
07:07:44 <knupfer> Open hands and let the delicate wings flap once.  The disturbance
07:07:48 <knupfer> ripples outward, changing the flow of the eddy currents in the
07:07:51 <knupfer> upper atmosphere.  These cause momentary pockets of higher-pressure
07:07:54 <knupfer> air to form, which act as lenses that deflect incoming cosmic rays,
07:07:57 * hackagebot foldl-transduce-attoparsec 0.1.0.0 - Attoparsec and foldl-transduce integration.  https://hackage.haskell.org/package/foldl-transduce-attoparsec-0.1.0.0 (DanielDiazCarrete)
07:07:57 <knupfer> focusing them to strike the drive platter and flip the desired bit.
07:08:00 <knupfer> You can type `M-x butterfly C-M-c' to run it.  This is a permuted
07:08:04 <knupfer> variation of `C-x M-c M-butterfly' from url `http://xkcd.com/378/'.
07:08:07 <knupfer>  
07:08:10 <knupfer> [back]
07:08:13 <knupfer>  
07:08:37 <voidzero> this is where you say 'oops, sorry'
07:10:21 <voidzero> anyway meretrix my point is that if you want decimal precision, don't use floating point types
07:11:07 <tjpeden> Alright, why does < 50 LoC result in a 1.4M executable? It's an order of magnitude bigger than the source
07:11:20 <knupfer> more seriously, why doesn't ghc evaluate pure computations if main just prints and doesn't read anything from the real world?
07:11:36 <voidzero> tjpeden, because it contains the vm and debugging symbols
07:11:40 <knupfer> tjpeden: the runtime
07:11:51 <tjpeden> Ah, runtime, gotcha
07:11:56 <voidzero> 'strip' will reduce the binary somewhat
07:12:16 <knupfer> tjpeden: also note that ghc links statically
07:12:27 <voidzero> /usr/bin/file will tell you if the binary has already been stripped
07:12:49 <tjpeden> knupfer: Good to know, I am okay with that
07:14:00 <knupfer> is my question related to super compilation?
07:14:47 <tjpeden> strip removed .4M
07:15:31 <knupfer> tjpeden: if performance doesn't matter, don't compile and start it with runhaskell
07:15:48 <pikajude> is there anything like stylish-haskell for cabal files?
07:16:23 <tjpeden> knupfer: I don't really care about the size so much, it was just odd at first
07:17:08 <tjpeden> I'm (obviously) new to Haskell and I decided to make a git hook as my first haskell program
07:17:51 <knupfer> tjpeden: projet euler is nice for getting started
07:18:48 <hodapp> knupfer: it's a case where seemingly no one has had sufficient need to implicitly compute things at runtime
07:18:51 <tjpeden> knupfer: Oh yeah, that's a good idea
07:18:55 <hodapp> knupfer: given that you can already do it explicitly with TH
07:19:02 <hodapp> er, compute things at compile-time
07:19:05 <fluggir> does anyone know how to calculate the multiplicative order of a modulo n using prime factors of (n-1)?
07:19:19 <hodapp> this sounds like homework.
07:19:21 <fluggir> it is
07:19:22 <fluggir> lol
07:19:48 <tjpeden> Homework costs, bro
07:20:00 <tjpeden> lol
07:20:43 <knupfer> hodapp: ok thanks
07:20:58 <hodapp> knupfer: and no, not related to supercompilation.
07:21:38 <ggole> Trying to evaluating pure code brings up some irritating design issues that it's nicer to not have to address
07:22:05 <knupfer> ggole: For example? I'm curious...
07:22:15 <tjpeden> as am i
07:22:22 <ggole> Computations aren't necessarily bounded, so you have to decide when to stop
07:23:47 <ggole> If you do that by imposing a large upper bound, then you get issues like inlining exposing an expensive computation in many places, resulting in huge compilation times
07:23:48 <knupfer> That makes sense.  And what about a compilation flag which limits the time of evaluation?
07:24:05 <knupfer> ahh
07:24:41 <ggole> There's also issues with unfolding constant calls that are recursive causing code bloat
07:24:58 <ggole> Which are well known in the partial evaluation scene
07:25:29 <ggole> If you make the *default* to always unfold, you're going to pay by making cold code (which is most code) run slower than it has to
07:26:01 <ggole> All of these issues can be addressed, but they take design work that could be applied elsewhere.
07:26:08 <hodapp> and there's already Template Haskell.
07:26:32 <knupfer> yeah, but TH is unsafe
07:26:40 <hodapp> unsafe how?
07:27:05 <amicuscuriae> Texas Ranges in awesome
07:27:05 <amicuscuriae> :)
07:27:20 <knupfer> if I'm not wrong, it can perform arbitrary IO on compilation and it breaks module boundaries
07:28:43 <Ov3rload> Does anyone have stack working on archlinux after the ncurses upgrade?
07:28:45 <hodapp> but it's not performing arbitrary IO at *runtime*.
07:29:12 <hodapp> and it's not performing arbitrary IO that you don't tell it to do.
07:29:31 <knupfer> hodapp: well, but it means that cabal install foo could format your hard drive
07:29:40 <Ov3rload> Apparently it cannot install ghc
07:29:42 <hodapp> knupfer: cabal itself could also format your hard drive.
07:30:05 <knupfer> hodapp: true, but less likely
07:30:13 <hodapp> knupfer: how would you know?
07:30:30 <knupfer> hodapp: reading #haskell
07:30:32 <hodapp> knupfer: and a better question is, why are you running compilation jobs with privileges that high?
07:31:08 <knupfer> hodapp: being an example doesn't imply that it's what I'm doing
07:31:09 <hodapp> cabal mucks around on the filesystem a lot more - so it's probably *more* likely to accidentally destroy something than an arbitrary package that builds with TH.
07:33:08 <knupfer> hodapp: usually I don't install via cabal, but via nix (obviously with more or less the same risks)
07:33:39 <hodapp> god forbid you might use a Makefile.
07:34:01 <gnosticascension> hi, huge haskell newb here
07:34:13 <gnosticascension> starting learnyouahaskell
07:34:14 <knupfer> hodapp: actually I've managed to avoid makefiles
07:34:51 <gnosticascension> could someone explain to me why ['w','o'] ++ ['o','t'] give "woot" in ghci, and not ['w', 'o', 'o', 't']?
07:35:08 <knupfer> gnosticascension: it's the same
07:35:18 <hodapp> gnosticascension: "woot" is that.
07:35:31 <knupfer> "foo" is syntactic sugar
07:35:36 <Ankhers> newtype String = [Char]
07:35:37 <hodapp> > ['w', 'o', 'o', 't']
07:35:39 <lambdabot>  "woot"
07:35:42 <knupfer> (assuming it's a string and not a text)
07:36:18 <Crosta> because it's more readable
07:36:26 <srhb> Ankhers: You mean type, right?
07:37:39 <knupfer> gnosticascension: note that it is sugar-free 'w':'o':'o':'t':[]
07:37:58 <gnosticascension> aha, so String is defined (somewhere in the internals) as a lists of Chars
07:38:04 <knupfer> yep
07:38:05 <gnosticascension> s/lists/list
07:38:11 <jmcarthur> :i String
07:38:12 <gnosticascension> thanks!
07:38:20 <jmcarthur> :info String
07:38:23 <jmcarthur> ...
07:38:28 <jmcarthur> @info String
07:38:28 <lambdabot> String
07:38:33 <jmcarthur> thanks lambdabot 
07:38:35 <amicuscuriae> knupfer, What does Sugar--free mean?
07:38:41 <gnosticascension> are any of those valid in ghci?
07:38:43 <jmcarthur> gnosticascension: try :i String in a ghci session
07:38:53 <knupfer> amicuscuriae: without syntactic sugar
07:39:02 <zomg> amicuscuriae: no calories
07:39:04 <gnosticascension> nice, type String = [Char] 	-- Defined in ‘GHC.Base’
07:39:05 <knupfer> lol
07:39:24 <amicuscuriae> What do you mean??? knupfer zomg programming wise, now I am an expert, I even know what Texas ranges is
07:40:00 <Ankhers> srhb: Probably. I'm still not great with type vs newtype.
07:40:19 <srhb> Ankhers: type is for type aliases, newtype is for new types (implied, new data constructor too)
07:40:34 <Ankhers> Fair enough. Thanks.
07:41:17 <knupfer> amicuscuriae: look at https://wiki.haskell.org/Syntactic_sugar/Cons
07:41:20 <srhb> amicuscuriae: They are talking about this syntax: [1,2,3] -- which is just "sugar" ie. an extra feature for making lists nicer to write, while it really means 1:2:3:[] without the extra sugar.
07:41:43 <srhb> amicuscuriae: Also "texas ranges" is just a wordplay from LYAH (like Texas Rangers) -- you're presumably just talking about ranges.
07:41:45 <voidzero> syntactic aspartame
07:42:17 <knupfer> voidzero: makes sense, it raises the appetite
07:42:25 <amicuscuriae> ok thanks srhb knupfer hehe yep I am 
07:42:30 <srhb> And I think people aren't paying attention to the language barrier, so all the funny stuff is causing a lot of confusion :-)
07:42:56 <knupfer> mea maxima culpa :(
07:42:59 * hackagebot twitter-feed 0.2.0.4 - Client for fetching Twitter timeline via Oauth  https://hackage.haskell.org/package/twitter-feed-0.2.0.4 (jpvillaisaza)
07:43:00 <srhb> Meh. :-)
07:43:11 <srhb> Fun is important, too.
07:44:21 <knupfer> srhb: actually it isn't a language barrier because it isn't specific to haskell
07:44:33 <amicuscuriae> srhb, that is why I am waiting for other book.. also leksah sucks, do you know if atom works fine with Haskell?
07:44:57 <knupfer> amicuscuriae: use emacs or vim
07:44:58 <srhb> amicuscuriae: No idea, I use Emacs, and even it doesn't feel perfect (probably because my setup is bad.)
07:45:01 <tjpeden> LOL @ voidzero 
07:45:28 <amicuscuriae> knupfer, don't torture me I am just a kid only
07:45:31 <amicuscuriae> srhb, k
07:45:41 <srhb> knupfer: Now I can't tell if you're making fun (because of the language barrier?) but I was talking human language, not Haskell :P
07:46:20 <hiptobecubic> atom works fine with haskell I think
07:46:30 <hiptobecubic> At least, there seems to be a community around it
07:46:37 <tjpeden> Atom works great with Haskell, amicuscuriae 
07:46:44 <tjpeden> That's what I'm using
07:46:45 <knupfer> knupfer: Well, languages are sometimes overloaded
07:46:47 <hodapp> haven't tried Atom (the editor) yet
07:46:54 <hodapp> I use Emacs now
07:47:36 <tjpeden> hodapp: have you tried the classical atom yet? lol
07:47:51 <knupfer> amicuscuriae: I think you should use EMACS, considering your name you're quite religious and EMACS is a religion
07:48:02 <hodapp> tjpeden: classical Atom? I was differentiating it from Atom, the Haskell library.
07:48:13 <lasticot> hi, I am trying to compile this project https://github.com/danr/hipspec and I am running into this error:
07:48:15 <lasticot>     Could not find module `Control.Monad.State'
07:48:16 <lasticot>     Perhaps you haven't installed the "dyn" libraries for package `mtl-2.2.1'?
07:48:18 <lasticot> Does someone knows how to solve it? I have installed ghc-dynamic to solve a previous similar error.
07:48:25 <hodapp> knupfer: It's Emacs, not EMACS, and it's not particularly religious...
07:48:25 <tjpeden> hodapp: I'm just being silly
07:48:38 <gnosticascension> i'm using emacs with haskell-mode; but apparently ghc-mod (why not mode?) is what i really should be having
07:48:48 <hodapp> ghc-mod?
07:48:50 <gnosticascension> but it has > 10 lines of setup instructions, so no go
07:49:15 <hodapp> what does it get you over haskell-mode?
07:49:22 <knupfer> gnosticascension: you should use both
07:49:23 <tjpeden> Atom's Haskell plugin uses ghc-mod
07:49:29 <knupfer> !
07:49:42 <tjpeden> Use them all
07:49:59 <knupfer> hodapp: historically it's EMACS and it certainly is a religion, search for st. ignucius
07:50:09 <Walther> hmm. any ideas on why hakyll would appear to interpret some .md files as ...different markdown formats than others? I have one .md file render correctly and another doesn't make ## headings and ~~~ into codeblocks
07:50:13 <gnosticascension> hodapp: i think it allows you to load stuff directly into ghci and whatnot
07:50:14 <knupfer> hodapp: or ask on #emacs
07:50:45 <gnosticascension> and a lot of other things, including linting
07:50:47 <knupfer> hodapp: it allows you to ask for type signatures and autocomplete type signatures...
07:50:48 <hodapp> knupfer: I'm in there now, and I don't particularly care what it is historically.
07:51:13 <knupfer> hodapp: I'm as well there and I'm interested in history.
07:51:56 <delYsid`> How do I make this pattern recursive? \(a,s) -> g' s >>= \(a',s') -> return (a ++ a')
07:52:36 <srhb> delYsid`: You'll need fix to make a lambda recursive, more or less. It's probably a lot easier to name the function. :-)
07:52:57 <knupfer> search for Y combinator
07:52:57 <gnosticascension> Walther: i don't use hakyll, but from a general markdown user's perspective – some sort of caching?
07:52:58 <hodapp> gnosticascension: ahh, I know haskell-mode (or one of its related things) can load code; don't know about linting, but it can do type signatures
07:53:17 <knupfer> hodapp: linting is actually done with hlint
07:53:43 <srhb> knupfer: I thought you couldn't make a well-typed Y in Haskell.
07:54:02 <hodapp> knupfer: I don't think anyone's asking how it's done.
07:54:06 <knupfer> srhb: I think you're right, but that's the concept
07:54:11 <srhb> Right, ok :)
07:54:26 <delYsid`> srhb: I know :-)  Lets call it f.
07:54:51 <hodapp> tjpeden: have you liked Atom pretty well for Haskell?
07:55:03 <srhb> delYsid`: Your function?
07:55:09 <knupfer> hodapp: Writing doesn't imply answering.
07:55:18 <delYsid`> yes
07:55:47 <srhb> delYsid`: OK, what are you trying to do exactly?
07:57:04 <gnosticascension> why does this fail?
07:57:04 <tjpeden> hodapp: Well, I use it for work (nodejs web dev) so it was kind of natural for me. But it's been really handy, if I hover over something (anything) it'll give me the type. The linting and compile checking on save is really nice
07:57:06 <gnosticascension> > [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3], 1, 1, 1, 1] ++ [2, 2, 2, 2]
07:57:07 <lambdabot>      No instance for (Show t0)
07:57:07 <lambdabot>        arising from a use of ‘show_M34987934736523178115100’
07:57:07 <lambdabot>      The type variable ‘t0’ is ambiguous
07:57:16 <hodapp> knupfer: Yeah, it rather does, contextually.
07:57:27 <delYsid`> I have a parser type g' which has signature [a] -> [([b], [a])] and I'd like to combine it such that it takes a list of as and gives me the concatenated result of >>= in the list monad...
07:57:46 <hodapp> tjpeden: do you try to integrate with stack or cabal much with it?
07:58:06 <Walther> I wonder if there's a way to force a format in the headers... I think the file is not read as markdown but autodetected as html or haskell or something else
07:58:16 <knupfer> hodapp: No, it was intended as an helpful addition because people are asking about setting up an haskell environment.
07:58:29 <srhb> gnosticascension: Lists are homogenous. Every element must have the same type.
07:58:38 <hodapp> knupfer: So then why was it directed at me?
07:58:41 <srhb> gnosticascension: [1,2,3,4] has a different type from 1
07:58:56 <gnosticascension> ah, thanks – didn't realize that
07:59:19 <gnosticascension> so what type is [1, 'a', 2, "4"]?
07:59:26 <srhb> gnosticascension: It isn't.
07:59:32 <gnosticascension> > let a = [1, 'a', b, '4']
07:59:34 <lambdabot>  <no location info>: not an expression: ‘let a = [1, 'a', b, '4']’
07:59:36 <srhb> gnosticascension: It simply is not well-typed, thus it cannot exist
07:59:41 <srhb> :t [1,'a']
07:59:43 <lambdabot>     No instance for (Num Char) arising from the literal ‘1’
07:59:43 <lambdabot>     In the expression: 1
07:59:43 <lambdabot>     In the expression: [1, 'a']
07:59:48 <gnosticascension> aha, okay, fair enough
08:00:09 <gnosticascension> i guess that goes well with haskell's reputed strictness about types
08:00:18 <srhb> Well yes. :-)
08:00:29 <hodapp> reputed strictness?!
08:00:36 <knupfer> hodapp: Your "don't know about linting" pulled the trigger, but if it is nothing new nor interesting for you I beg that you interpret it as directed at the general audience.
08:01:22 <hodapp> knupfer: Context. I meant that I don't know whether or not haskell-mode handles linting.
08:02:14 <knupfer> hodapp: The language barrier strikes back, I'm actually not a native speaker.
08:04:18 <knupfer> gnosticascension: You can use tuples for that: (1, 'a', "b", '4')
08:05:04 <gnosticascension> hodapp: reputed because i'm just starting out
08:05:13 <hodapp> gnosticascension: it's more than just reputed :P
08:05:17 <gnosticascension> once i use it for a month or two i'll say 'stricness about types'
08:05:37 <hodapp> once you use it for a month or two you'll probably just call it "types" :P
08:05:42 <gnosticascension> just don't want to appear as if i'm a seasoned user who knows a lot about the type system
08:06:01 <knupfer> strictness is often used word in haskell context
08:06:47 <hodapp> knupfer: strictness means something else in that context.
08:07:07 <knupfer> hodapp: I know, it was intended as a joke...
08:07:10 <hodapp> o_O
08:08:00 * hackagebot streaming 0.1.0.18 - a free monad transformer optimized for streaming applications with an elementary streaming prelude  https://hackage.haskell.org/package/streaming-0.1.0.18 (MichaelThompson)
08:08:03 * hackagebot streaming-bytestring 0.1.0.7 - effectful byte steams, or: bytestring io done right  https://hackage.haskell.org/package/streaming-bytestring-0.1.0.7 (MichaelThompson)
08:08:27 <knupfer> Computations at the type level are probably strict. -- This is not an answer.
08:09:56 <Shersh> Hello everyone! I have data definition with context: data (Ord a) => Tree a = Leaf | Node a (Tree a) (Tree a), -- and function: insert :: a -> Tree a -> Tree a. I wonder why compiler cannot deduce, that type variable `a` should have `Ord` type bound? Is haskell compiler really stupid so it cannot verify this type constraint?
08:10:58 <Axman6> don't put class constraints on data types, only put them on the functions that need the constraint
08:12:17 <knupfer> DatatypeContexts is considered a bad extensions.
08:12:49 <Shersh> :Axman6 I know that DatatypeContext is extension and more -- it is now deprecated. But why?
08:12:50 <Axman6> if you put constraints on data types, then they infect all functions which you use the data type in, even if they don't need the constraint
08:13:00 <knupfer> Shersh: look at http://stackoverflow.com/questions/7438600/datatypecontexts-deprecated-in-latest-ghc-why
08:13:11 <ggole> Shersh: if you don't write the type sig yourself, ghc should infer the right type
08:13:26 <Axman6> I'm surprised it's even supported at all, it's just plain wrong to do it
08:13:42 <hiptobecubic> So it seems like if you want to use Generics to derive instances for Aeson, you really need to put your datatypes in a separate module to avoid needing to prefix all of the field names, yes?
08:15:12 <Shersh> ggole: Thanks! Well, at least ghc can infer type by itself. But DatatypeContexts are really shouldn't be used, I agree.
08:15:56 <ggole> Shersh: another way to think about it is to say that the variable a in that signature should be taken as forall a, with no constraints
08:16:18 <ggole> Otherwise you could write an implementation of a function that was less general than you intended, and it would still type check
08:17:24 <ggole> (OCaml's type variables work that way, and it is a rather annoying wart in the language.)
08:18:54 <hiptobecubic> ggole, what do you mean? Can you give an OCaml example that shows that?
08:18:54 <Shersh> ggole: But if I have more general function like: insert :: a -> s a -> s a, and I use Tree instead of s, will compiler also apply all constraints which I have on my Tree data? 
08:19:17 <hiptobecubic> ggole, you mean like you could write a function foo : a -> a; foo i = i + 1   ?
08:19:22 <ggole> hiptobecubic: let id : 'a -> 'a = fun x -> 0
08:19:40 <Axman6> Shersh: you can't have a type like that and get the behaviour you want
08:20:06 <Axman6> because of paramatricity, the only implementation of that is insert _ sa = sa
08:20:13 <hiptobecubic> ggole, How would that work? Would the type checker force 'a ~ Int ?
08:20:29 <quux> hello, is there a channel for dependent types?
08:20:33 <ggole> hiptobecubic: that's what it does, yes.
08:20:49 <Shersh> Axman6: I don't want this behaviour :) I just want to figure out why DatatypeContext are really bad
08:21:38 <glguy> Shersh: Edwardk did a talk about why you want your constraints on your functions and not your datatypes (among other things) https://www.youtube.com/watch?v=hIZxTQP1ifo
08:21:54 <Axman6> Shersh: if you have data Ord a => Foo a = ... then if you have an implementation for instance Show (Foo a), that Shpw instance must have both a Show a and an Ord a constraint, even though Show doesn't use anything at all from Ord
08:22:26 <hiptobecubic> ggole, seems analogous to https://en.wikipedia.org/wiki/Liskov_substitution_principle
08:22:35 <Axman6> Shersh: if you have a count function to count the number of elements, it also needs an Ord constraint, even though it doesn't order anything
08:23:47 <ggole> hiptobecubic: I dunno about that. You can think about what's happening as 'a simply naming a type variable, which is then unified with whatever it happens to unify with.
08:24:03 <ggole> eg, it's exposing part of the guts of type inference
08:24:14 <Shersh> Axman6: It doesn't matter if function don't use this constraint. In Java I can write `public class Tree<T extends Comparable<T>> ...` and there is no problems at all if some functions on tree don't use Comparable interface properties.
08:24:41 <Axman6> but it's unnecessary, and makes all code that ever uses Tree a need an Ord constraint
08:24:42 <hiptobecubic> ggole, I guess I'm thinking that you have a function "a -> a", but it's hiding the fact that "a" is actually required to unify with Int.
08:24:59 <Axman6> functions should have as few constraints as possible
08:25:24 <hiptobecubic> ggole, the same way saying you work on "ellipses" but having assumptions baked into implementations that assume the special case of circular ellipses
08:26:41 <ggole> I'm not sure I see the analogy... anyway, the Haskell behaviour is considerably more clear and useful in practice
08:26:59 <knupfer> Axman6: Is this always the case?  Aren't specialized functions as well usefull?
08:27:31 <Axman6> not really
08:27:54 <Axman6> if the implementation are identical, a more constrained version is less useful
08:28:20 <knupfer> Ah, that makes sense.
08:28:29 <ggole> It's the other way around: a greater constraint allows the implementation to be changed (to be faster, say)
08:28:54 <ggole> As in, say, IntMap
08:29:23 <knupfer> or nub vs ordNub
08:30:55 <Axman6> see ekmett's discrimination package for alternative ways to deal with that
08:33:27 <knupfer> Axman6: That's great!
08:41:42 <knupfer> Is it possible to splice in TH with another syntax?  Like the `splice' from the original paper.
08:45:16 <hodapp> knupfer: it sounds like you're describing quasiquoting
08:46:47 <knupfer> hodapp: I would like to provide functions which use TH as an implementation detail which shouldn't be visible to the user. Is this possible?
08:47:35 <knupfer> voidzero: Concerning your syntactic aspartame, wikipedia knows about syntactic saccharine.
08:50:47 <magneticduck> https://github.com/dmjio/google-translate/blob/master/src/Web/Google/Translate.hs
08:51:11 <magneticduck> does anybody else feel like this kind of huge enumeration of what is essentially *data* in native code is a bad idea?
08:51:25 <magneticduck> see line 211
08:53:13 <magneticduck> I'm thinking about this, there are arguments to go both ways
08:53:28 <magneticduck> with this, you have compile-time checking
08:54:33 <magneticduck> and it lets ghc optimize symbol lookup by running it at compile-time also
08:54:52 <magneticduck> but for some reason it feels strange to me, like there's arguments to be had against it
08:55:21 <julianleviston> isn’t foldl’ supposed to be faster than foldr for adding numbers?
08:55:31 <julianleviston> or is just that it consumes constant stace space?
08:55:57 <ChristianS> julianleviston: adding numbers?
08:56:33 <julianleviston> ChristianS: foldl' (+) 0 [1..10000000]
08:56:34 <ChristianS> julianleviston: generally, either foldl’ or foldr is the right thing, depending on your use case. while foldl hardly ever is.
08:57:02 <magneticduck> julianleviston: we know what you mean, we're confused about why adding numbers is a relevant context here
08:57:04 <julianleviston> ChristianS: I was just re-implementing it, using higher order functions
08:57:22 <julianleviston> magneticduck: was testing my reimplementation, is all
08:57:37 <ChristianS> julianleviston: foldl' is fine there
08:57:46 <julianleviston> takes 8.18 secs to evaluate foldl' (+) 0 [1..10000000] but foldr takes 3.39 secs
08:57:56 <julianleviston> sorry - should qualify - that’s MY foldl’
08:58:05 <mniip> foldr is when you want to produce an incremental structure
08:58:12 <julianleviston> This one http://lpaste.net/141307
08:58:19 <julianleviston> mniip: cool
08:58:19 <mniip> foldl is when you have a stateful loop
08:58:25 <mniip> err foldl'
08:58:28 <julianleviston> erm
08:58:39 <ChristianS> julianleviston: when i try it in ghci, foldl' is faster than foldr
08:58:57 <mniip> julianleviston, your foldl' implementation is drastically different from GHC's
08:59:01 <julianleviston> ChristianS: yeah, but that’s using Foldable right? the built in one
08:59:14 <julianleviston> mniip: yeah, I know… I was interested in mine, not GHC’s particularly.
08:59:20 <mniip> julianleviston, because of all the RULES pragmas missing
08:59:32 <julianleviston> mniip: hence why I said “using higher order functions"
08:59:59 <ChristianS> julianleviston: compare your own foldl' with your own foldr
09:00:06 <julianleviston> I just assumed a thunk-evaluating “myFoldl’” would be faster than foldr standard.
09:00:13 <julianleviston> ChristianS: ah good idea!
09:00:18 <ChristianS> doesn't make sense to compete against ghc's built-ins, as they'll be highly optimized
09:00:22 <julianleviston> bad assumption.
09:00:25 <julianleviston> ok. cool :)
09:00:46 <julianleviston> purely self-pedagogical! :)
09:02:04 <jmcarthur> foldl' is tail recursive with a strict accumulator. foldr is not tail recursive. also, before making a quicky judgement, note that tail recursion is not always better.
09:02:08 <jmcarthur> *quick
09:03:03 * hackagebot streaming-bytestring 0.1.0.8 - effectful byte steams, or: bytestring io done right.  https://hackage.haskell.org/package/streaming-bytestring-0.1.0.8 (MichaelThompson)
09:03:05 <jmcarthur> in particular, tail recursion means the result has the be evaluated all at once, not incrementally
09:03:33 <julianleviston> jmcarthur: oh? interesting
09:03:43 <julianleviston> jmcarthur: what does all at once mean?
09:03:48 <jmcarthur> some results can only be evaluated all at once anyway. that's usually when foldl' is better, because foldl' has better constant factors and space efficiency then.
09:04:06 <julianleviston> jmcarthur: I thought foldl’ *was* incremental 
09:04:18 <jmcarthur> julianleviston: when you sum a list of Ints, you can't observe anything about the result until the whole computation is done
09:04:19 <julianleviston> jmcarthur: could you define what you mean by incremental and all at once?
09:04:46 <jmcarthur> julianleviston: however, if you are concatenating a list of lists, you can start observing the beginning of the result before the rest is done
09:05:02 <jmcarthur> > foldr (++) [] ["foo", "bar", "baz", undefined]
09:05:04 <lambdabot>  "foobarbaz*Exception: Prelude.undefined
09:05:16 <julianleviston> jmcarthur: oh, useful for laziness and “piping” functions together? like say, with interact or something? streaming results and whatnot
09:05:19 <julianleviston> jmcarthur: ok cool
09:05:33 <jmcarthur> and the reason this works is *because* foldr is not tail recursive
09:05:35 <julianleviston> jmcarthur: lol ;-)
09:06:03 <julianleviston> jmcarthur: yep.
09:06:20 <jmcarthur> in fact, the recursive call is "guarded" by (++) in the above example, because (++) doesn't need to evaluate the recursive call until the result has been traversed far enough to need it
09:06:59 <julianleviston> jmcarthur: you’ve exceeded my interest point. Thanks for your comments, though.
09:07:17 <jmcarthur> thanks for saving my fingers
09:07:17 <julianleviston> jmcarthur: not to be rude! Just saving you effort.
09:07:44 <jmcarthur> i sometimes go on just because others are reading too, though
09:07:53 <julianleviston> jmcarthur: feel free!
09:08:01 <jmcarthur> that's usually when i stop addressing somebody directly
09:08:42 <julianleviston> ah that’s better - my foldl’ (0.81 secs, 338418552 bytes) my foldr (1.02 secs, 277237728 bytes)
09:08:44 <julianleviston> cool
09:12:09 <kaidelong> looks like hackage can't build category-extras
09:12:28 <kaidelong> I'm looking to understand adjunctions, but I'm not getting the example of ((,) a) ((->) a)
09:13:42 <kaidelong> @instances Adjunction
09:13:43 <lambdabot> Couldn't find class `Adjunction'. Try @instances-importing
09:15:49 <glguy> category-extras is old tech, try: https://hackage.haskell.org/package/adjunctions-4.2.2/docs/Data-Functor-Adjunction.html
09:16:00 <kaidelong> I just figured that out!
09:16:04 <kaidelong> looks like hackage built it fine
09:16:07 <monochrom> :)
09:16:11 <kaidelong> but category-extras is just a meta-package now
09:16:15 <kaidelong> so it has only deps, no source
09:17:02 <kaidelong> okay
09:17:10 <kaidelong> the new one has a different constraint on g
09:17:15 <kaidelong> it calls it "Representable"
09:17:47 <kaidelong> Every Distributive Functor is actually Representable.
09:17:56 <kaidelong> in this case, why not just require Distributive?
09:22:41 <julianleviston> is there such a thing as unsided fold for commutative operations? or am I wandering into Monoid Endo territory here?
09:23:08 <kaidelong> I think there was something in Control.Parallel.Strategies, hang on
09:24:05 <julianleviston> kaidelong: it’s just me being inquisitive, which will probably lead me somewhere I don’t understand fast, so perhaps I should abandon this until I know more!
09:27:16 <magneticduck> what exactly is the term for how haskell 'caches' function calls so they don't take time to evaluate when they're called repeatedly?
09:27:43 <magneticduck> like how the intuitive fibbinocci number definition in haskell is O(n) whereas writing the same definition in another language would be O(n^2)
09:28:05 * hackagebot relational-query 0.6.0.0 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.6.0.0 (KeiHibino)
09:28:06 <ReinH> magneticduck: sharing
09:28:13 <magneticduck> huh
09:28:21 <ReinH> which intuitive definition do you mean?
09:28:33 <magneticduck> fibb x = fibb (x - 1) + fibb (x - 2)
09:28:40 <ReinH> nope, that's O(n ^2)
09:28:44 <magneticduck> oh really?
09:28:46 <magneticduck> huh
09:28:47 <ReinH> yep
09:28:58 <magneticduck> huh okay
09:29:05 <julianleviston> magneticduck: memoization?
09:29:07 <ReinH> haskell/ghc doesn't memoize functions
09:29:13 <ReinH> it shares bound values
09:29:14 <julianleviston> magneticduck: no I’m not sure that’s what you really mean
09:29:21 <julianleviston> magneticduck: tho*
09:29:35 <shachaf> It is much worse than n^2.
09:29:40 <magneticduck> julianleviston: well I guess I don't mean anything because I was interpreting a performance gap in a wrong way
09:30:05 <kaidelong> that fibb looks exponential to me
09:30:22 <ReinH> Oh right, O(2^n)
09:30:25 <ReinH> much worse
09:30:30 <kaidelong> julianleviston: I thought there was a parallel fold in Control.Parallel.Strategies but I couldn't find it
09:30:34 <magneticduck> yeah
09:30:42 <magneticduck> was thinking about something else
09:31:10 <magneticduck> (was only considering one branch x))
09:31:20 <julianleviston> kaidelong: thanks, but don’t worry about it… I’ll just keep going. I’m sure I’ll eventually stumble upon something like it. 
09:31:50 <kaidelong> anyway the stargy in haskell would be to define a lazy data structure in terms of itself
09:32:01 <kaidelong> but with a list it would still be polynomial, not linear
09:32:07 <shachaf> phi^n, I think.
09:32:10 <kaidelong> I think the best you could do is linearithmic
09:32:31 <julianleviston> kaidelong: lol
09:32:38 <julianleviston> kaidelong: I like that there’s this page https://wiki.haskell.org/The_Fibonacci_sequence
09:33:02 <kaidelong> oh right, I forgot about scanl
09:33:05 * hackagebot streaming-utils 0.1.0.0 - utilities for http-client, attoparsec, pipes etc with streaming and streaming-bytestring  https://hackage.haskell.org/package/streaming-utils-0.1.0.0 (MichaelThompson)
09:33:10 <julianleviston> constant time “binet formula” ones. lol
09:33:10 <kaidelong> that threads an accumulator, so it is linear
09:33:44 <kaidelong> binet's formula needs flouting point ops IIRC
09:34:01 <kaidelong> so there could be errors
09:34:38 <kaidelong> however chance of error for better runtime is usually a good tradeoff to make
09:34:49 <kaidelong> especially since the cost of verifying the result is very low
09:34:50 <julianleviston> do bangpatterns just turn on seq (v) v type things for !v ?
09:35:04 <julianleviston> syntaxes*
09:35:08 <kadoban> Floating point is a broken way to do it, there /will/ be errors by the time you get to any value big enough to warrant using a decent algorithm. There's a way to do it without floating point though.
09:35:43 <julianleviston> how bad is this? fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
09:36:02 <kadoban> julianleviston: Pretty good, especially if you need every value and not just the nth one.
09:36:16 <kadoban> Then it's basically optimal, AFAIK.
09:36:24 <kaidelong> it is amortized constant time
09:36:49 <kaidelong> the cost of generating each additional value is constant
09:37:07 <kadoban> Constant number of additions at least, but the additions get more costly to do.
09:37:33 <kaidelong> oh right yes
09:39:04 <kaidelong> mmm I wonder if that really matters though, you can treat + as constant so long as you need all of finitely many fibbonaci numbers
09:39:17 <kadoban> If you need only the nth fib, then http://mathworld.wolfram.com/FibonacciQ-Matrix.html is the way that I always remember. Someone else here told me a more direct way that ends up with better constants, but I always forget it.
09:40:21 <kadoban> Well, it depends what computational model you're talking about and etc. I don't think in the usual ones you can treat + as constant time though, unless you're bounding 'n', in which case you can just say the whole thing is constant time, which is pretty useless.
09:41:47 <kadoban> If you were doing something like doing fibs in math modulo p, then you could say it's constant time, because it's bounded by something that doesn't depend on n.
09:42:26 <hodapp> kadoban: You can also treat the Fibonacci sequence as an IIR filter and use normal DSP techniques to analyze it, and get a closed-form solution which generates the Nth term.
09:42:36 <hodapp> of course, that only works as far as your real numbers do
09:42:43 <kaidelong> I suppose that's true, you can say that the overhead of + still scales to n, even if it is upper bounded by some constant
09:43:06 <kaidelong> we are just used to dealing with fixed size integer representations which have an actual constant time + done "in parallel"
09:43:21 <kaidelong> implemented in hardware
09:43:46 <kaidelong> so the fact that + isn't constant time gets lost in the abstraction but not the fact that the overall computation isn't constant time
09:43:50 <kadoban> hodapp: My math skills aren't good enough to understand that, heh.
09:45:24 <kadoban> Well, Integer for example is less fixed size than usual, so it starts to matter greatly. But more fundamentally, asymptotic analysis is all about what happens as 'n' grows arbitrarily large. If you're setting bounds on 'n' before you even start the analysis, you're not going to get much that's meaningful. (Then everything is O(1))
09:47:59 <julianleviston> :r
09:48:03 <julianleviston> oops
09:56:52 <kristof> So
09:57:03 <kristof> I've got a question.
09:57:09 <kristof> Kind of a two-parter.
09:57:30 <julianleviston> and…. GO!
09:57:43 <kadoban> (twice)
09:58:06 * hackagebot pandoc-csv2table 1.0.2 - Convert CSV to Pandoc Table Markdown  https://hackage.haskell.org/package/pandoc-csv2table-1.0.2 (baig)
09:59:05 <kristof> I tried writing monad instances for Maybe [], [Maybe], Write w Maybe, etc.
09:59:37 <kristof> all combinations of compositions of Maybe, List, and Write, because I wanted to see what the solution would look like without monad transformers.
10:00:26 <kristof> At first I was quite excited because it turned out all m (n a) combinations relied only on monadic methods of m, and not only that, but they all looked the same for fixed n
10:00:52 <kristof> So I devised that perhaps if you added extended the monad class with a simple method, you would get a compositional monad ipso facto.
10:01:09 <kristof> I wrote my Embeddable class, added a method inject, then looked at MTL source to compare
10:01:59 <kristof> and I had essentially come up with exactly the same thing :PPP except, well, instead of writing MaybeT, ListT, and WriterT, I was just extending monads that already existed.
10:02:08 <kristof> So my first question is: is that useful?
10:03:06 * hackagebot foldl-transduce-attoparsec 0.1.0.1 - Attoparsec and foldl-transduce integration.  https://hackage.haskell.org/package/foldl-transduce-attoparsec-0.1.0.1 (DanielDiazCarrete)
10:03:11 <julianleviston> kristof: under what context? for your own understanding?
10:04:04 <kristof> julianleviston: You mean the usefulness or the experiment? The experiment for my own understanding, but now that I have _something_ which is similar to MonadT but not quite the same, I was wondering if there are any benefits in that.
10:05:51 <kristof> My second question is irrespective of monad transformers or my own homebrew solution.
10:08:03 <kristof> When you look at the way MonadT's handles >>=, it looks *almost* exactly like the way >>= is defined for the underlying monad. 
10:08:28 <kristof> They are so similar in fact that I wonder if there is simply a way to define one in terms of the other, generally.
10:14:11 <augur> kristof: how do you mean
10:16:16 <kristof> augur: https://hackage.haskell.org/package/transformers-0.4.3.0/docs/src/Control-Monad-Trans-Maybe.html#line-134
10:17:51 <kristof> x >>= f looks almost word for word what the signature of >>= looks like for a naked Maybe. The only difference is "return Nothing", and also the type of "f y" is one context too layered for Maybe's monadic bind.
10:19:37 <kristof> That has to bother someone. :)
10:21:00 <zaquest> kristof, some monads are defined like this Monad a = MonadT Identity a
10:21:35 <kristof> Ah, true.
10:22:27 <kristof> Okay, that was what I thought the answer might be, but I didn't like it.
10:22:31 <ReinH> type List a = ListT Identity a
10:22:42 <kristof> ReinH: Surely that's not how it's defined.
10:23:39 <haskell941> Hi everybody!
10:24:14 <radix> Can anyone offer some insight into why free monad DSLs are always defined with a terminal "End" or "Done" case? when I play around with them I seem to be able to get by without it just fine, but I must be missing something
10:25:23 <glguy_> Radix: the terminal case allowed return to be implemented
10:26:49 <radix> glguy_: okay, I'm confused. I should probably put up some example code. I have a free monad / DSL that allows me to use "return" without an End... I'll throw up a gist in a second
10:28:37 <glguy_> Having the Done case allows generic free monad to assume less about the type it is parameterized over
10:28:58 <radix> https://gist.github.com/radix/f7ac6243d4d16fdb5789 -- there's some typeclass stuff in there that's not relevant to the example, sorry
10:30:02 <glguy_> runIO (Pure x) = return x
10:30:20 <augur> kristof: yes, the general principle at work here is that instead of defining Maybe, you define MaybeT and when you apply it to Identity, the normal case falls out
10:30:22 <glguy_> And your uses of return use that Pure constructor
10:30:28 <radix> is there something bada bout that?
10:30:46 <kristof>  augur: Okay, I can accept that.
10:30:47 <augur> kristof: so that all monads are transformers applied to Identity, and there's really only one actual monad -- Identity
10:30:53 <glguy_> Nope. It just means you're using the Done constructor you asked about
10:31:02 <kristof> augur: Yeah, that jives.
10:31:08 <augur> well, only one primitive monad
10:31:36 <augur> so the derived monads should all look like they would in the basic case, but with some extra returns and stuff
10:31:37 <radix> glguy_: oh, you mean that Free type's Pure is equivalent to the Done constructors in all the examples I see?
10:31:49 <augur> but its not a pain in the ass, because you never write both Maybe and MaybeT
10:31:55 <augur> you only write MaybeT
10:32:13 <glguy_> Radix, I'd assume so
10:32:30 <radix> okay. I guess they include them because they're usually building up Free from scratch... I guess...
10:32:42 <radix> a bit weird that they factor it differently
10:32:53 <kristof> augur: Isn't there a performance cost to using Identity? Or are all those methods inlined because it's a newtype over a?
10:34:15 <kristof> augur: This has been extremely helpful conceptually, thank you for taking the time to respond.
10:34:25 <augur> kristof: because Identity is a newtype, all the wrappers, etc. vanish at runtime. the only cost is the call to return, which is an identity function at that point, and the compiler will optimize that out of existence i think
10:34:42 <augur> so there ought to be no overhead for Identity cases
10:34:48 <radix> glguy_: thanks for your help :)
10:34:55 <glguy_> Yw
10:38:08 * hackagebot streaming-utils 0.1.0.1 - http, attoparsec and pipes utilities for streaming and streaming-bytestring  https://hackage.haskell.org/package/streaming-utils-0.1.0.1 (MichaelThompson)
10:41:41 <kaidelong> okay so if I'm understanding this right
10:42:03 <kaidelong> the main idea behind adjunctions is that you can avoid a monad transformer because the composition of two adjunct monads forms a new monad
10:42:16 <kaidelong> but there are so few instances of adjunction that this isn't actually very useful
10:42:37 <c_wraith> State is exactly and adjunction of Reader and Writer!
10:42:57 <c_wraith> (least surprising adjunction ever)
10:44:30 <tjpeden> Okay, so I didn't think this through all the way, I now need to take what I'm printing out to stdout and write it to the file I read from, but that value is lost to the rest of the code. Can anyone suggest a better structure? https://github.com/tpeden/git-hooks/blob/master/commit-msg.hs Normally I wouldn't ask such a crazy question, but there is much of
10:44:30 <tjpeden> Haskell I still don't quite grasp
10:45:53 <kristof> tjpeden: What you want is some monadic form of tee
10:46:27 <kristof> tjpeden: If you just used do-syntax you could write str <- commitMsg; putStr str; -- then do more stuff with str later on
10:46:38 <tjpeden> kristof: That sounds useful
10:46:55 <jmcarthur> or you could abandon point free style
10:47:15 <jmcarthur> err, yes, like with do notation
10:47:39 <kristof> however! if you wrote a tee :: m () -> (a -> m a) then that would also work
10:48:03 <jmcarthur> i don't understand how that type is tee
10:48:04 <kristof> tee action a = action >> (return a)
10:48:13 <jmcarthur> ah
10:48:21 <kristof> jmcarthur: Wait, what were you thinking?
10:48:43 <jmcarthur> i'm used to thinking of tee as passing results to two places
10:48:48 <jmcarthur> in parallel
10:48:56 <jmcarthur> but i see what you were going for
10:48:58 <kristof> Oh
10:49:08 <kristof> I'm used to thinking of tee as "passing along" its argument
10:49:09 <jmcarthur> somethink like what you get with Control.Arrow is what you're doing
10:49:19 <kristof> bah, I hate Arrows
10:49:46 <jmcarthur> i hate the Control.Arrow interface for arrows
10:50:07 <jmcarthur> i'd be pretty happy if arr was left for some subclass of the rest of the interface
10:50:34 <jmcarthur> and the rest is some cartesian category or something
10:50:36 <kristof> What's with the coupling between tuples and arrows?
10:50:49 <kristof> I'd much prefer being able tie arrows to lenses instead
10:50:51 <jmcarthur> arrows are all about tuples, really
10:50:58 <jmcarthur> in a similar way that applicative is all about tuples
10:51:13 <kristof> Have you read that "arrows are categories + applicatives" article?
10:51:18 <jmcarthur> yeah
10:51:46 <kristof> I like the idea of generalized  a -> b processes but I never see arrow style as actually being useful
10:52:13 <kristof> I mean someone would have to demonstrate to me a program that is a mess without them and then appears orderly and pristine with arrows
10:52:24 <cmccann> isn't it really more like arrows are categories with an automatic equivalent of the ((->) e) Applicative instance?
10:53:16 <jmcarthur> arr is the part that messes up the generality. i'd be much happier with something like http://www.eecs.berkeley.edu/Pubs/TechRpts/2014/EECS-2014-130.pdf
10:53:43 <augur> edwardk: ping
10:53:51 <jmcarthur> page 18 has a GArrow type class (which you wouldn't normally use without sugar, but there it is)
10:54:16 <jmcarthur> sorry, page 19 i mean
10:54:26 <augur> edwardk: so basically https://gist.github.com/psygnisfive/da20b3e7b0e968c7a911
10:54:29 <jmcarthur> and page 20 has some useful extensions
10:54:37 <kristof> maybe tee should have had type  tee :: (a -> mb) -> (a -> ma)
10:55:13 <augur> edwardk: this "schema" presents a way to represent tree types as sort of "flat" sequences of constructors
10:56:00 <jarlopez> Why does Haskell use /= as the 'not equal' operator? (rather than !=)
10:56:28 <cmccann> jarlopez: because =/= is too long and nobody wants to type ≠
10:56:29 <jmcarthur> jarlopez: because in haskell (!) does not otherwise mean "not"
10:56:44 <jmcarthur> jarlopez: so might as well make (/=) look more like the math notation
10:57:55 <jarlopez> cmccann, jmcarthur: Ah, I see. Thanks! It took me a moment to realize that /= does not imply 'divide-equals'
10:59:46 <tjpeden> How do I do this:
10:59:47 <jmcarthur> :t (fmap.fmap.uncurry) (<$) (Prelude.id &&&)  -- kristof: overly clever implementation of tee, for fun
10:59:49 <lambdabot> Functor f => (a -> f b) -> a -> f a
10:59:55 <kadoban> jarlopez: Yeah, that pattern from C-ish wouldn't really make sense in Haskell.
11:00:11 <tjpeden> https://www.irccloud.com/pastebin/6WyDSgA1/read_write_same_file
11:00:45 <jmcarthur> kadoban: it kind of would make sense as a lens operator, if you're into that kind of thing
11:01:26 <jmcarthur> oops, i left the qualified Prelude in that expression
11:01:57 <kadoban> I just mean it expanding to  x = x / 4  wouldn't be sensical. I'm sure the operator itself could mean sometihng else in other contexts, where it wouldn't expand to '=' (though maybe I'm missing what you're saying, I don't know lens yet really).
11:02:05 <cmccann> jmcarthur: I think the lens operator is called (//=) to avoid the conflict 
11:02:26 <jmcarthur> kadoban: the lens version of the operator would do exactly what /= would do in C
11:03:13 <kadoban> So it's an imperative action of some kind?
11:03:20 <tjpeden> I have to use openFile instead of readFile >>= writeFile huh?
11:03:22 <jmcarthur> i do wish (/=) had just been called (=/=)
11:03:24 <cmccann> > (6,8) & _1 //~ 2
11:03:28 <lambdabot>  (3.0,8)
11:03:29 <jmcarthur> kadoban: basically
11:03:43 <cmccann> /= is the same thing, except it operates on the state value in a state monad
11:03:49 <cmccann> er
11:03:50 <cmccann> /=
11:04:02 <jmcarthur> irc killing you?
11:04:02 <cmccann> blargh, I mean //=, stupid irc
11:04:08 <cmccann> :[
11:04:09 <monochrom> :)
11:04:16 <jmcarthur> prefix with a space i think is enough
11:04:18 <jmcarthur>  //=
11:04:21 <cmccann> yeah
11:04:32 <monochrom> //=
11:04:37 <kadoban> Oh okay, I see what you mean.
11:04:48 <jmcarthur> monochrom: wat
11:04:55 <cmccann> //=
11:04:57 <jmcarthur> \//=
11:04:59 <jmcarthur> lol
11:05:00 <cmccann> forgot about that
11:05:13 <monochrom> I used the "/say" command
11:05:19 <cmccann> yep
11:05:28 <jmcarthur> ah!
11:05:31 <monochrom> (ok, I don't know how universal it is.)
11:05:35 <cmccann> /me is also using /say right now
11:05:47 <jarlopez> I'm walking through the beginning of learnyouahaskell.com and came across this example:    [ x*y | x <- [2,5,10], y <- [8,10,11], x*y > 50 ]     In the languages I'm familiar with, I'd be concerned with it evaluating x*y twice; once for the result and once in the predicate. Is this not something to worry about in Haskell?
11:06:16 <jmcarthur> jarlopez: in general, if you write something twice, it might happen twice, even in haskell
11:06:27 <tjpeden> https://gist.github.com/tpeden/1802be312818d4a07d26
11:06:39 <jmcarthur> jarlopez: sometimes ghc will perform common subexpression elimination, but only in very limited cases
11:06:51 <jarlopez> jmcarthur: So that example might not be the most performant?
11:06:52 <cmccann> jarlopez: it will still be evaluated twice in unoptimized code. whether GHC would be clever enough to avoid it when optimizing that I dunno.
11:07:07 <jmcarthur> i think ghc is not clever enough to avoid it in this case
11:07:22 <jarlopez> Hmm is there an alternate 'solution' that'd accomplish the same thing?
11:07:29 <cmccann> jarlopez: if you're worried about performance, I think the overhead of the list comprehension might matter more than an extra multiplication
11:07:44 <cmccann> I think the correct solution is to write what you mean and then profile afterwards
11:07:46 <jmcarthur> list comprehensions are usually pretty fast...
11:07:56 <kadoban> jarlopez: [xy | x <- [], y <- [1], let xy = x * y, xy > 50] or something would be the way to avoid that
11:08:13 <cmccann> jmcarthur: faster than multiplying what's probably Int or Float? :P
11:08:14 <kadoban> jarlopez: But … it's generally not going to matter. A few extra multiplies isn't the end of the world.
11:08:25 <jmcarthur> > do { x <- [2,5,10]; y <- [8,10,11]; let result = x * y; guard (result > 50); return result }
11:08:27 <lambdabot>  <hint>:1:76: parse error on input ‘;’
11:08:36 <jmcarthur> ?
11:09:12 <jmcarthur> cmccann: that is not a well formed question
11:09:43 <jarlopez> kadoban, jmcarthur: Thanks for the examples
11:10:10 <jmcarthur> > do { x <- [2,5,10]; y <- [8,10,11]; result <- return (x * y); guard (result > 50); return result }   -- does lambdabot hate let in curly-brace-and-semicolon do statements or something?
11:10:13 <lambdabot>  [55,80,100,110]
11:10:42 <kadoban> XD maybe lambdabot is just f-ing with you.
11:10:57 <monochrom> it is not just lambdabot. it is Haskell 2010.
11:11:04 <jmcarthur> <lambdabot> semicolons, wtf is wrong with you
11:11:21 <monochrom> > do { x <- [2,5,10]; y <- [8,10,11]; let {result = x * y}; guard (result > 50); return result }
11:11:25 <lambdabot>  [55,80,100,110]
11:11:30 <jmcarthur> meh
11:11:33 <augur> edwardk: the gist of it is that if B comes after A in a normal data type (in the args), then B is inside A in the Lin version
11:11:56 <monochrom> "let x=y; guard z; return a" means "let {x=y; guard z; return a}".
11:12:01 <edwardk> augur: rewind a bit more, what is Lin?
11:12:14 <monochrom> see the fineprints of Haskell 2010 for details
11:12:16 <kadoban> Ohh
11:12:18 <augur> edwardk: https://gist.github.com/psygnisfive/da20b3e7b0e968c7a911
11:12:26 <augur> edwardk: its that data family
11:12:51 <jmcarthur> monochrom: this is what i guessed after seeing the error message, though i think it's a bit annoying, because i think of any ambiguities that would arise from allowing what i tried
11:13:00 <jmcarthur> *i can't think of
11:13:23 <edwardk> ok
11:13:31 <augur> edwardk: the definition of   Lin a r   looks like the definition for   a   but with products replaced with composition, you see?
11:13:32 <edwardk> what is the goal for this? just to figure out how to do it?
11:13:52 <jmcarthur> probably just an oversight or to make it easier for parser writers, because the curly-brace-and-semicolon syntax isn't the most often used anyway
11:14:15 <augur> edwardk: ultimately its for efficiently compiled pattern matches :)
11:14:29 <edwardk> how so?
11:14:44 <augur> edwardk: im going to write a blog post on that :)
11:14:51 <monochrom> if Haskell 2010 said "if a statement contains '=', it belongs to the current let-block, else the let-block ends and it belongs to the outer block", then you would not need the extra {}
11:16:00 <augur> edwardk: but the cute part, the thing that i find most interesting, is that the types of the Lin constructors look an awful lot like the types for the algebras
11:16:41 <augur> only with (,) and () and -> replaced by  composition, Id, and index-lifted ->
11:17:05 <augur> LinNil :: Id ~> Lin [a]   ;   LinCons :: Lin a . Lin [a] ~> Lin [a]
11:17:25 <augur> vs   Nil :: () -> [a]   ;   Cons :: (a,[a]) -> [a]
11:18:03 <monochrom> I guess you are thinking another approach. "if the let-block does not start with {, then it consists of one statement only". but then this would disallow "let x=1; y=2 in x+y"
11:19:06 <augur> Lin seems to be some kind of interesting mapping. maybe its a cute little functor from  |Set  to  |Set^|Set   that preserves algebraic structure or something???
11:19:22 <tjpeden> Am I missing something here: https://gist.github.com/tpeden/1802be312818d4a07d26 ?
11:19:37 <augur> i dont quite know whats going on with it tho
11:31:16 <glguy> tjpeden: tjpeden: readFile uses lazy IO, so you need to make sure you've read the whole file before you start writing back out
11:32:19 <nitrix> glguy: If you sequence (>>=) the read with the write, is this enough of a guarantee?
11:32:21 <tjpeden> glguy: how would I go about doing that?
11:32:40 <nitrix> glguy: Or it has to be made strict explicitly?
11:32:43 <chpatrick> :t foldr (\x _ -> Just x) Nothing -- is this defined anywhere?
11:32:44 <tjpeden> nitrix: That's what I'm doing so no lol
11:32:45 <lambdabot> Foldable t => t a -> Maybe a
11:32:49 <glguy> nitrix: No.
11:33:10 <glguy> tjpeden: I'll paste something back
11:33:11 * hackagebot streaming 0.1.0.19 - an elementary streaming prelude and a free monad transformer optimized for streaming applications  https://hackage.haskell.org/package/streaming-0.1.0.19 (MichaelThompson)
11:33:13 * hackagebot language-nix 2.1 - Data types and useful functions to represent and manipulate the Nix language.  https://hackage.haskell.org/package/language-nix-2.1 (PeterSimons)
11:33:19 <tjpeden> glguy: Thanks!
11:33:22 <michaelt> the commitMsg function would have to be right.
11:33:27 <ChristianS> tjpeden: write the output to a temp file. once you're finished, move to old file away to .bak (or delete it) and rename the temp file.
11:33:35 <cmccann> hpc: I think I traumatized a bunch of people on /r/haskell by linking to acme-php again, it's great
11:33:37 <michaelt> tjpeden: just use Data.Text.IO.readFile and writeFile unless the file is huge
11:33:48 <tjpeden> Like in LYAH
11:33:59 <michaelt> oh i thought he was a writing a new file oh
11:34:09 <tjpeden> michaelt: They are COMMIT_MSG files, so no lol
11:35:48 <michaelt> tjpeden: if you are appending to the file, you can use appendFile. I think that will work even under conditions of extreme laziness
11:35:50 <glguy> tjpeden: I pasted some code
11:35:55 <fjordrunner> please, can you help me with following? ... http://lpaste.net/2367952161913962496
11:36:15 <fjordrunner> I just want to remove one dataclass,...
11:37:16 <michaelt> fjordrunner: it's that you are using return 
11:37:29 <glguy> tjpeden:   readFile file >>= evaluate . force >>= commitMsg >>= writeFile file >> exitSuccess
11:37:30 <michaelt> fjordrunner: which the type checker thinks is Just, in this case
11:37:36 <glguy> should be about the same
11:37:51 <glguy> force is from Control.DeepSeq
11:38:05 <tjpeden> interesting
11:38:13 <fjordrunner> michaelt: millions thanks,...yes its working..
11:38:43 <tjpeden> michaelt: I am replacing the file's contents
11:38:54 <augur> edwardk: anyway, im just mentioning it to you in case it looks interesting from a categorial perspective. it seems like it might, so..
11:39:13 <edwardk> augur: nothing leaps to mind
11:39:16 <michaelt> tjpeden: I see. Not just making an append.  
11:39:34 <edwardk> but i'm sure there is some nice explanation that someone could come up with that invokes yoneda ;)
11:40:12 <michaelt> tjpeden: like I said, the effect of glguy 's forcing will be come with the territory if you use Data.Text.IO.readFile (which of course would require a revision of commitMsg). 
11:40:38 <shachaf> edwardk: I think the name "Coyoneda" is justified, by the way.
11:40:51 <michaelt> ugh
11:40:55 <shachaf> I think you were against that name at one point?
11:41:10 <edwardk> shachaf: i don't remember
11:41:14 <edwardk> i might have been =)
11:41:26 <edwardk> i hold lots of strong opinions that i later recant when given strong evidence ;)
11:42:06 <shachaf> Anyway they're dual in the usual sense, Coyoneda -| U -| Yoneda.
11:43:01 <monochrom> I am against Coyoneda because I am for CoYoneda
11:43:26 <shachaf> Are you also for CoLimit?
11:43:35 <monochrom> no
11:43:38 <shachaf> Or is it just proper nouns?
11:43:49 <monochrom> yes, the reason is proper noun
11:43:54 <augur> froyoneda
11:57:41 <delYsid`> How do I check if all elements of a list are equal?
11:57:53 <kristof> But what color is the bikeshed going to be?
11:58:09 <kristof> delYsid`: fold (eq) list
11:58:35 <kristof> foldr (eq) True your_list
11:58:37 <chpatrick> :t \xs -> zipWith (==) xs (tail xs)
11:58:38 <monochrom> that is not going to type-check
11:58:39 <lambdabot> Eq a => [a] -> [Bool]
11:58:50 <kristof> sure it will
11:58:58 <monochrom> ok
11:59:10 <monochrom> @type \xs -> foldr (==) True xs
11:59:11 <lambdabot> Foldable t => t Bool -> Bool
11:59:17 <monochrom> is that the type you want?
11:59:34 <kristof> nope! ._.
12:00:36 <kristof> > let list = [1..100] in foldr (==) (first list) list
12:00:40 <lambdabot>  mueval-core: Time limit exceeded
12:00:48 <mach> what's the most painless way to update macports from ghc to haskell-package?
12:01:55 <monochrom> what is "first"?
12:01:58 <monochrom> @type first
12:02:00 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
12:02:06 <quchen> lmap, mostly.
12:02:33 <monochrom> it doesn't sound like "first" means what you want
12:03:03 <delYsid`> Thanks
12:04:01 <ggole> Sounds like delYsid` wants something like let alleq [] = True; alleq (x:xs) = all (== x) xs
12:04:10 <kaidelong> > (\xs -> all (head xs ==)) [1,1,1,1,1,1]
12:04:12 <lambdabot>      No instance for (Typeable t0)
12:04:12 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
12:04:12 <lambdabot>        arising from a use of ‘show_M700880887423881804118810’
12:04:32 <kaidelong> > (\xs -> all (head xs ==)) [1,1,1,1,1,1]
12:04:33 <lambdabot>      No instance for (Typeable t0)
12:04:33 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
12:04:33 <lambdabot>        arising from a use of ‘show_M823839370929579569218820’
12:04:36 <kaidelong> oops
12:04:48 <monochrom> IIRC section syntax has some restrictions
12:04:49 <kaidelong> didn't mean to send that twice
12:05:11 <quchen> allEqual (x:xs) = all (== x) xs
12:05:13 <cmccann> I like how "first" has absolutely nothing to do with "last". very intuitive naming.
12:05:29 <kaidelong> quchen: that doesn't support the empty list case
12:05:35 <monochrom> because it has something to do with "second"
12:05:43 <quchen> kaidelong: That's left as an exercise to the reader.
12:05:47 <kaidelong> all elements of an empty list equal one another trivially
12:05:59 <monochrom> and you haven't critiqued "fst" either
12:06:39 <quchen> Oh, I see someone mentioned the same solution above already. Hm.
12:06:41 <monochrom> this is the problem with meaningful names
12:06:56 <monochrom> there are so many meanings to choose from
12:07:16 <kristof> > let list = [1..100] in foldr (==) True $ map ((==) (head list)) list
12:07:18 <lambdabot>  False
12:07:28 <cmccann> fst is excused on account of its spelling. anything with a name that sounds like a unix command clearly does something unexpected.
12:07:29 <kristof> > let list = repeat 5 in foldr (==) True $ map ((==) (head list)) list
12:07:30 <ggole> monochrom: you just need the -XDWIM extension
12:07:33 <lambdabot>  mueval-core: Time limit exceeded
12:07:49 <kristof> > let list = take 5 (repeat 5) in foldr (==) True $ map ((==) (head list)) list
12:07:51 <lambdabot>  True
12:07:57 <kristof> I am satisfied. :)
12:09:01 <kaidelong> I guess the correct thing to return may not actually be Bool but something like [a]
12:09:14 <kaidelong> [a] being the list starting at the first element not equal to the head
12:09:15 <kristof> But I thought you could make a short-circuiting version with fold{l,r}. :/
12:09:18 <monochrom> "first" is so called because it is a generalization of "fst". similarly "second" and "snd"
12:09:26 <monochrom> @type first
12:09:27 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
12:09:30 <kaidelong> wait no that doesn't help
12:10:19 <cmccann> monochrom: so the rule is that generalized versions get correctly spelled names, specialized versions get abbreviations, I see
12:10:48 <monochrom> it applies an arrow to the fst of a tuple. similarly, "second" applies an arrow to the snd of a tuple
12:11:03 <kaidelong> GHCi accepts my defn.
12:11:05 <kaidelong> lambdabot is broken
12:11:08 <monochrom> I don't know about "the" rule. clearly everyone has their own rules.
12:11:14 <kaidelong> also it treats the empty list case correctly
12:11:28 <kaidelong> I figured it would, but good to check
12:11:42 <monochrom> different people think up names by different conventions and inspirations
12:11:48 <cmccann> monochrom: I'm being firmly tongue-in-cheek with all of this. I'm well aware of what all these functions are and why they have those names :P
12:12:04 <monochrom> no one's convention and inspiration is universally canonical.
12:12:05 <kaidelong> OO/modules helps with the meaningful names thing
12:12:23 <kaidelong> List.first can clearly be differentiated from Tuple.first
12:12:46 <kaidelong> although it's still nice to come up with different conventions
12:12:57 <kaidelong> like lens' _1, _2 etc
12:13:03 <kaidelong> is probably better than fst, snd
12:13:35 <monochrom> the problem with _1 and _2 is "what happened to _0 ?"
12:13:41 <kristof> (#.) -- function coerce
12:13:53 <kristof> a little weird to see that in the standard library ._.
12:13:57 <kaidelong> it's not a cardinal number, no reason to have 0
12:14:02 <cmccann> > firstOf each (2, 3)
12:14:05 <lambdabot>  Just 2
12:14:07 <kaidelong> it annoys me how CS people use 0 as an ordinal actually
12:14:07 <cmccann> > firstOf each "abcd"
12:14:09 <lambdabot>  Just 'a'
12:14:15 <cmccann> lens saves the day once again
12:15:47 <cmccann> kaidelong: because they conflate ordinal numbers with offsets from a starting position
12:16:03 <monochrom> I don't see what's wrong with allowing 0 as an ordinal. apart from correcting a mistake made by ancient people who didn't understand 0.
12:16:39 <kaidelong> I don't really see how that's a mistake, why is "the zeroth element" meaningful?
12:16:54 <monochrom> the purpose of ordinals is to give you a nice sequence and total order.
12:16:54 <cmccann> of course, as a CS person, I tend to think of the latter as being the right way to look at it :P
12:16:54 <kaidelong> in fact, I thought that problem was exactly why zero was such a controversial thing
12:17:02 <kaidelong> I guess that's true
12:17:07 <kaidelong> putting 0 in there doesn't mess much up
12:17:13 <monochrom> since 0<1 it certainly serves that purpose, too
12:17:31 <kristof> Because there are places where cardinal vs. ordinal is blurred.
12:17:39 <kaidelong> but it is unsatisfying from an aesthetic standpoint because 0 has a completely different meaning in this context, I guess you could say
12:17:44 <quchen> It's funny how there are unused zeros everywhere. Maybe in 100 years we won't believe how we didn't use the empty type all the time.
12:17:53 <kaidelong> the cardinals hang onto the meaning it has in ordinal context, too
12:18:14 * hackagebot streaming 0.1.0.20 - an elementary streaming prelude and a free monad transformer optimized for streaming applications  https://hackage.haskell.org/package/streaming-0.1.0.20 (MichaelThompson)
12:18:43 <kristof> People get confused when talking about arithmethic/geometric/whatever kinds of sequences and recurrences because the ith element of a sequence is the result of applying the rule i-1 times.
12:19:09 <kaidelong> alright, well, I'm convinced
12:19:12 <kaidelong> CS people do it better
12:19:15 <kaidelong> nevermind
12:19:21 <kristof> lol
12:20:33 <kristof> kaidelong: Have you never read Dijkstra's explanation?
12:20:43 <kaidelong> can't say I have
12:21:45 <kristof> Actually, that's for the precedent of Closed-open...
12:21:46 <cmccann> kaidelong: CS people still mess it up often enough that there's a specific bit of jargon for bugs caused by mismatched notions of ordinals :P
12:21:55 <kristof> Use iterators! \o/
12:24:13 <monochrom> kaidelong: http://www.cs.utexas.edu/users/EWD/ewd08xx/EWD831.PDF or http://www.cs.utexas.edu/users/EWD/ewd08xx/EWD831.PDF
12:24:25 <monochrom> err, http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html
12:25:23 <kaidelong> I guess I just have a general annoyance that math/CS are different disciplines at all
12:25:47 <monochrom> oh, math is going to be a different discipline from itself, too
12:25:59 <kaidelong> right
12:25:59 <cmccann> CS is a mixture of applied pure math and bad engineering
12:26:09 <kaidelong> math is broad enough that all of CS could probably fit under it
12:26:19 <monochrom> set theory people are going to say "0 is a natural number" and number theory people are going say the opposite.
12:26:24 <kaidelong> cmccann: degrees in software engineering might actually be a good thing to offer
12:26:43 <monochrom> combinatorics people say "0^0 = 1" and analysis people want it undefined
12:26:44 <kaidelong> my uni offers "computer systems" but not "software"
12:27:32 <cmccann> kaidelong: software engineering sounds like a good idea, someone should invent that
12:27:35 <kaidelong> there was a blog post rant a while back about how software would be better and languages would suck less if software was actually treated like engineering with all the associated legal risks
12:27:50 <cmccann> monochrom: yeah but the combinatorics people are obviously right :P
12:28:14 <kristof> Absolutely not
12:28:18 <kadoban> kaidelong: Because what's stopping the maturity of software engineering is that not enough lawyers are involved? O.o
12:28:19 <kristof> The analysis people are right
12:28:29 <kristof> just take lim x -> 0 of x^x and it is quite obvious
12:28:38 <maerwald> kadoban: haha :D
12:28:43 <kaidelong> we're in the wrong channel, wanna go blah kadoban?
12:28:50 <kaidelong> but I think basically the idea was "actually, yes"
12:29:07 <geekosaur> "If builders built buildings the way programmers write programs, the first woodpecker to come along would destroy civilization." things haven't really changed since the 1950s
12:29:22 <kristof> So obviously 0^0 should have the value of 1 but 0^x then is discontinuous at x = 0. So there should be no definition at all at that point.
12:29:28 <cmccann> anyway I'm off to grab food, have fun debating lawyers and/or real analysis
12:29:28 <kadoban> kaidelong: Probably at another time I'd be interested in talking about it, but not at the moment :-/
12:30:29 <kaidelong> I don't see how making it undefined is better, that introduces a discontinuity too
12:30:40 <monochrom> :)
12:30:46 <kaidelong> I think the problem people had with 0^0 = 1 is that you can then show 0/0 = 1 using equations
12:30:55 <kaidelong> but people generally don't define 0/0 as 1
12:31:08 <maerwald> geekosaur: sounds like someone said that who doesn't know stuff about buildings ;)
12:31:14 <kristof> kaidelong: No, that is not true. You would never be able to construct the expression 0/0.
12:31:24 <hae> 0/0 is indeterminate. Maybe 0^0 should be indeterminate too.
12:31:34 <Gurkenglas> or Nothing.
12:31:35 <silver> it is
12:31:45 <kristof> hae: Indeterminate means "I cannot determine a limit." That is untrue.
12:32:02 <silver> 0^0 is not a limit
12:32:03 <monochrom> Haskell actually illuminates this with three different ^, ^^, **
12:32:31 <hae> https://en.wikipedia.org/wiki/Indeterminate_form
12:32:31 <kristof> silver: undefined and indeterminate are different
12:32:57 <monochrom> ^ is combinatoric, and ** is analytic. they serve different purposes and need not be entirely unified
12:33:15 <kristof> kaidelong: My point is actually that b^x and x^a are two different functions and both demand a different value of 0^0 for continuity, so neither should be preferred.
12:33:28 <kristof> Assuming x is the free variable and b and a are fixed.
12:33:34 <monochrom> ^^ is algebraic
12:33:38 <Gurkenglas> > 0**0
12:33:40 <lambdabot>  1.0
12:34:26 <jle`> kaidelong: how does 0^0 = 1 imply 0/0 = 1 ?
12:34:39 <kaidelong> n^0 = x/x
12:34:41 <kaidelong> n/n*
12:34:47 <monochrom> I mean that in x^^y you want x to be a field element and y be an integer, so that both x^^3 and x^^(-3) make sense
12:34:54 <kaidelong> basically, divisions by itself balances out multiplications by itself
12:34:58 <kaidelong> so it becomes 1
12:35:19 <kaidelong> if you use that interpretation, anyway
12:35:40 <kaidelong> n^1 = x/x^2
12:35:42 <kristof> kaidelong: the former is not true forall n anyway
12:35:44 <kaidelong> ^-1 *
12:35:49 <kristof> so, explosion principle.
12:36:08 <kaidelong> again using n on the left and x on the right, should be n both ways
12:36:16 <roconnor> Ugh, we still don't have Data.Map.alterF
12:36:26 <quchen> roconnor: alterF?
12:36:26 <monochrom> the explosion principle and the detonational semantics :)
12:36:56 <roconnor> alterF :: (Functor f, Ord k) => (Maybe a -> f (Maybe a)) -> k -> Map k a -> f (Map k a)
12:37:13 <roconnor> just because we cannot decide whether to flip the order of the arguments or not.
12:37:33 <quchen> Hm.
12:37:42 <monochrom> I propose having both versions, and call them "alterF" and "fAlter"
12:37:51 <roconnor> I'd be happy with either order, just implement the damn thing!
12:38:04 <jle`> oh, it's `alter`, but with f
12:38:14 <kristof> What is that used for?
12:38:15 <roconnor> It's been like what 3 years?
12:38:21 <monochrom> @type alter
12:38:22 <lambdabot>     Not in scope: ‘alter’
12:38:23 <lambdabot>     Perhaps you meant one of these:
12:38:23 <lambdabot>       ‘IM.alter’ (imported from Data.IntMap),
12:38:30 <monochrom> @type M.alter
12:38:31 <lambdabot> Ord k => (Maybe a -> Maybe a) -> k -> M.Map k a -> M.Map k a
12:38:36 <jle`> i'm guessing the argument against the "alter" type is that the flipped version can be used as a traversal/lens?
12:38:42 <quchen> containers could use some expansion anyway. Edward's Heaps package for example looks like a nice fit.
12:38:58 <kristof> Takes a map and "explodes" it using some function a -> f a? ignoring the maybes
12:38:59 <roconnor> kristof: it can be used for lots fo things: you can make a list of alterations, or maybe alter something.
12:39:00 <Gurkenglas> Sounds like "\f k -> at k %~ f"?
12:39:00 <monochrom> I think alterF should simply follow the same convention as alter. why would anyone argue at all?
12:39:01 <kristof> That's the best I've got.
12:39:10 <roconnor> Gurkenglas: it is exactly that.
12:39:17 <Gurkenglas> So then why not use that?
12:39:26 <jle`> alterF :: k -> Lens' (Maybe a) (Map k a)
12:39:31 <monochrom> I mean, if one wants to argue, go back and argue about "alter" first.
12:39:32 <roconnor> monochrom: because the flipped version is the form of a van laarhoven lens.
12:39:42 <kristof> Gurkenglas: So my work from yesterday ended up being isomorphic to transfomers.
12:39:47 <kristof> I ended up with exactly the same definitions.
12:40:00 <jle`> i think keeping the ordering of `alter` from containers makes the most sense...
12:40:11 <jle`> if you're using `lens` you already have a lens for it anyways
12:40:14 <roconnor> Gurkenglas: because to be efficent it needs to work on the internal structure of Data.Map
12:40:16 <jle`> so you don't need to use alterF as your lens
12:40:24 <jle`> oh i see
12:40:25 <roconnor> jle`: I agree 
12:40:37 <jle`> or you can just use `flip alterF` as your lens...
12:40:45 <jle`> sounds kinda silly
12:40:49 <roconnor> I agree
12:41:22 <roconnor> kristof: the maybe's are not ignored; altering to nothing implies deletion.
12:41:29 <roconnor> kristof: but otherwise you are right.
12:41:41 <kristof> roconnor: I meant "ignoring the maybes because I do not know what those are for"
12:41:45 <kristof> But now I do!
12:41:49 <roconnor> :)
12:41:53 <Gurkenglas> You'd think you could have "at" work with a default implementation usually and with a special one for map
12:42:22 <roconnor> Gurkenglas: once alterF is implemented, at will be redefined to use alterF instead of insert/delete
12:42:44 <roconnor> and everything will be faster.
12:42:58 <jle`> well 8.0 is coming, maybe it'll give library maintainers impetus to get down and commit to choices for changes
12:44:24 <kazagistar> Is there any existing work on building a declarative syntax like a grammar, but which is also aware of variable scope and possibly even types? The idea being that you would use the same input to both create a parser, and to define an Arbitrary for valid strings 
12:45:49 <knupfer> is there a function which does  fromMaybe x (f x)
12:46:59 <athan> knupfer: I don't think so
12:47:00 <jle`> :t \x f -> fromMaybe x (f x)
12:47:01 <lambdabot> a -> (a -> Maybe a) -> a
12:47:27 <athan> it's like fromJustWithDefault . f
12:47:29 <athan> or something
12:47:54 <knupfer> I thought that it is very common pattern
12:47:59 <knupfer> is a
12:48:01 <jle`> fromMaybe x (f x) might be the cleanest way
12:48:05 <kazagistar> @hoogle a -> (a -> Maybe a) -> a
12:48:06 <lambdabot> Data.IntMap.Strict updateMax :: (a -> Maybe a) -> IntMap a -> IntMap a
12:48:07 <lambdabot> Data.IntMap.Lazy updateMax :: (a -> Maybe a) -> IntMap a -> IntMap a
12:48:07 <lambdabot> Data.IntMap.Strict updateMin :: (a -> Maybe a) -> IntMap a -> IntMap a
12:48:14 <kazagistar> nvm I guess
12:48:18 <jle`> from my experience it hasn't been a common pattern for me
12:48:24 <athan> knupfer: You should probably use `throwError` if you're using previous inputs as errors
12:48:27 <jle`> but maybe it is for other people
12:48:28 <athan> idk
12:48:30 <athan> :|
12:49:04 <MarcelineVQ> oh neat mapMaybe is kinda cool, it's like filtering with failures
12:49:19 <athan> knupfer: Are you aiming for some kind of partial recursion? "apply only if result succeeds"?
12:49:37 <athan> MarcelineVQ: Check out Data.Witherable (if you already understand Traversable) :)
12:49:46 <jle`> the Maybe utility functions tend to be more about operations structurally fundamental to the maybe data type, so things like this might just not be common or important enough to warrant a name that people have to remember or look up
12:49:47 <knupfer> athan: I want to strip a Prefix from some lines
12:49:49 <jle`> MarcelineVQ: it's great :)
12:49:56 <kazagistar> I think the most common patterns are either fromMaybe or (>>=)
12:50:09 <athan> Oh okay, that's pretty neat now that I think about it knupfer
12:50:12 <knupfer> so I use: \x p -> fromMaybe x $ T.stripPrefix p x
12:50:34 <jle`> if you have a lot of options, you maybe can do f x <|> g x <|> Just x
12:50:41 <cmccann> :t ap fromMaybe
12:50:42 <lambdabot> (b -> Maybe b) -> b -> b
12:50:55 <jle`> definitely do not use ap fromMaybe :p
12:51:20 <cmccann> yeah, if you already have f you should use fromMaybe <*> f instead!
12:51:36 <jle`> cmccann: not if you want to write readable code :P
12:52:30 <jle`> but yeah i think any name for this function might be a bit too obscure to be readable instantly or useful...fromMaybe x (f x) is a pretty readable thing already anyways too
12:52:30 <cmccann> ap fromMaybe is easy to read. understanding is another matter, but reading the identifiers is quite simple!
12:52:46 <jle`> :)
12:53:18 <knupfer> jle`: ok, it just seemed redundant with the two xs
12:54:24 <jle`> it's definitely not a bad question
12:55:10 <knupfer> cmccann: could you explain ap fromMaybe?
12:56:09 <kazagistar> uhhh
12:56:15 <kazagistar> :t ap
12:56:17 <lambdabot> Monad m => m (a -> b) -> m a -> m b
12:56:22 <kazagistar> :t fromMaybe
12:56:23 <lambdabot> a -> Maybe a -> a
12:56:33 <cmccann> knupfer: it's using the ((->) e) Monad instance, the main purpose of which is to write obfuscated point-free code
12:56:46 <kadoban> Hehe
12:57:14 <kadoban> It is pretty useful and readable though if you're in on the trick.
12:57:20 <cmccann> knupfer: basically (ap fromMaybe f x) expands to (fromMaybe x (f x))
12:58:14 <knupfer> hmm, it isn't logical that it uses a Monad instance, an Applicative shoud suffice, no? 
12:58:21 <knupfer> should
12:58:30 <kazagistar> knupfer: you are right
12:58:33 <cmccann> well, yeah. ap is just (<*>)
12:58:44 <cmccann> and I guess ap probably only has an Applicative constraint these days?
12:58:57 <knupfer> :t ap
12:58:58 <cmccann> mostly I said monad because it's fewer letters to type
12:58:58 <lambdabot> Monad m => m (a -> b) -> m a -> m b
12:58:59 <kadoban> I think it still has a Monad constraint, though I don't know if that will always be true.
12:59:01 <knupfer> no
12:59:19 <jle`> ap is useful to have the Monad constraint
12:59:42 <knupfer> ?
12:59:43 <jle`> because if you write the Monad instance first and are too lazy to write the Applicative instance, you can just write (<*>) = ap
12:59:49 <jle`> pure = return
13:00:05 <jle`> sometimes people write the Monad instance first and the Applicative instance after I guess
13:00:12 <kadoban> Ah, right.
13:00:13 <knupfer> is it possible to define an Applicative in terms of Monad?
13:00:16 <jle`> and they don't want to bother defining (<*>) from scratch, heh
13:00:25 <jle`> knupfer: yes, because ap only uses return and (>>=)
13:00:28 <jle`> it doesn't use pure or (<*>)
13:00:30 <kadoban> knupfer: jle` just did
13:00:45 <Gurkenglas> Also it tells the reader you're working with a monad, like using liftM where you could have used fmap
13:00:50 <knupfer> don't I have to have already the Applicative instance in the first place?
13:01:00 <jle`> if you write both instances in the same file
13:01:17 <jle`> you can have the Monad instance defined, and the applicative instance can use (>>=) and return if it's already defined somewhere else
13:01:32 <knupfer> good to know
13:02:17 <cmccann> knupfer: anyway, the type of ap specialized to the instance here is (a -> b -> c) -> (a -> b) -> (a -> c)
13:02:22 <kadoban> Gurkenglas: But should that ever matter, if you're only using 'ap' and nothing that actually requires Monad?
13:02:59 <knupfer> @pl \x -> fromMaybe x (f x)
13:02:59 <lambdabot> ap fromMaybe f
13:03:05 <knupfer> lol
13:03:31 <cmccann> knupfer: see above re: the main purpose of that instance :P
13:03:32 <knupfer> lambdabot is awesome
13:03:48 <athan> interesting how it flips the `f` and the `x`
13:04:00 <athan> @pl \f x -> fromMaybe x (f x)
13:04:00 <lambdabot> ap fromMaybe
13:04:07 <athan> idk
13:04:21 <mniip> what are you trying to do
13:04:51 <athan> wait nvm hah
13:05:27 <Gurkenglas> @pl \x f -> fromMaybe x (f x)
13:05:27 <lambdabot> liftM2 (.) fromMaybe (flip id)
13:06:06 <mniip> interesting
13:06:11 <athan> :t flip id
13:06:12 <lambdabot> b -> (b -> c) -> c
13:06:36 <mniip> oh well, yeah, I wouldn't got to the same result there
13:06:36 <kadoban> :t (&)
13:06:38 <lambdabot> a -> (a -> b) -> b
13:06:57 <athan> :O
13:07:04 <knupfer> @pl (\x -> do x; y; z)
13:07:04 <lambdabot> (line 1, column 12):
13:07:04 <lambdabot> unexpected ";"
13:07:04 <lambdabot> expecting variable, "(", operator or ")"
13:07:27 <knupfer> @pl (\x -> x >>= y >>= z)
13:07:28 <lambdabot> (z =<<) . (y =<<)
13:07:32 <knupfer> what
13:07:41 <mniip> knupfer, that's now what that 'do' reduces to
13:08:47 <knupfer> now I have to take a tee
13:09:00 <athan> :t flip (id :: (a -> b) -> (a -> b))
13:09:01 <lambdabot> a -> (a -> c) -> c
13:09:49 <athan> ah derp
13:10:01 <athan> :t flip (id :: (a -> b) -> a -> b) :: a -> (a -> b) -> b
13:10:02 <lambdabot> a -> (a -> b) -> b
13:10:39 <kadoban> Just trying to get the letters to match or something?
13:10:42 <mniip> :t undefined :: forall (what :: * -> * -> * -> *) are you doing. what are you doing
13:10:43 <lambdabot> what are you doing
13:11:04 <kadoban> Nice
13:11:51 <knupfer> > sum [1..]
13:11:56 <lambdabot>  mueval-core: Time limit exceeded
13:12:11 <knupfer> whats mueval?
13:12:22 <haskell238> hey guys. learning haskell, curious what I'm missing: if the :t for Netowork.Socket.accept returns (Socket, SockAddr), and the socket demo uses conn <- accept sock (which I've got working so far), is it correct to assume that accept is ruturning a tuple of Socket, SockAddr and that something like (conn, sa) <- accept sock should work? ..Cause it isn't, and I don't understand why.
13:12:39 <athan> > foldM (\n _ -> print n) [1..]
13:12:41 <lambdabot>      Couldn't match expected type ‘()’ with actual type ‘[Integer]’
13:12:41 <lambdabot>      In the second argument of ‘foldM’, namely ‘[1 .. ]’
13:12:41 <lambdabot>      In the expression: foldM (\ n _ -> print n) [1 .. ]
13:12:47 <athan> :(
13:12:54 <athan> > foldM (\n _ -> print n >> return n) [1..]
13:12:55 <lambdabot>      No instance for (Typeable t0)
13:12:55 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
13:12:55 <lambdabot>        arising from a use of ‘show_M117429106332555321819990’
13:13:07 <kadoban> athan: You can PM lambdabot
13:13:25 <Hijiri> haskell238: post your code and the error on lpaste.net
13:13:32 <Hijiri> or some other paste site
13:13:52 <Hijiri> with just the information you've given it looks like it should work
13:14:01 <haskell238> Ok, brb.
13:14:10 <MarcelineVQ> The benefit of pming lamdbabot is when you find something really clever it looks like you came up with it on the spot when you redo it in a channel
13:15:03 <athan> :x
13:15:10 * Welkin slaps athan with a monad
13:15:57 * athan starts melting
13:16:02 <athan> D:
13:16:50 <cmccann> MarcelineVQ: truly, those are words of wisdom for the ages
13:17:00 <Welkin> MarcelineVQ: sounds like vanity
13:17:10 <Welkin> the real reason is to not spam the channel
13:17:15 <cmccann> the other benefit is that you don't spam the channel with your typos and type errors :P
13:17:27 <Welkin> otherwise, I encourage all to fail publicly and often
13:18:03 <haskell238> OH. That's hilarious. I'm copying stuff into lpaste and I think I figured it out. I was trying to deconstruct the tuple (conn,sa) <- accept sock, where as the original code assigns the entire tuple to conn, before running a function that breaks it apart. My error was a type mismatch from 'conn' no longer representing the tuple it wanted.
13:18:05 <athan> I was just trying to show an alternative way at looking at progress :\
13:18:38 <athan> s/at looking/to look
13:20:37 <athan> Here we go
13:21:00 <athan> > scanl (+) 0 [1..] -- knupfer
13:21:01 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
13:23:22 <knupfer> Is it possible to use rewrite rules to parMap all maps?
13:23:48 <mniip> yes
13:23:50 <hpc> cmccann: :D
13:23:51 <knupfer> Albeit haskell is excellent in parallelism, I'm dreaming of doing nothing for it.
13:24:49 <barrucadu> knupfer: Just parallelising everything that can be parallelised often leads to a slowdown, due to thread contention
13:24:50 <cmccann> hpc: https://www.reddit.com/r/haskell/comments/3lg4vy/suggestion_use_for_function_application/cv60xdj
13:25:27 <barrucadu> There was a paper at the Haskell Symposium this year on automatically parallelising things, however: http://dl.acm.org/citation.cfm?id=2804308&CFID=714685325&CFTOKEN=27771900
13:25:36 <Welkin> plus if you have a machine with only one core, it is pointless :D
13:25:56 <barrucadu> (disclaimer: I may be biassed in how good I think that is as I share an office with the author)
13:26:06 <cmccann> it's pretty easy to parallelize code to run across 1 core, though.
13:26:10 <knupfer> Welkin: I'm blessed with having two of them.
13:26:17 <jmcarthur> is there a way to get incomplete pattern warnings to list all the patterns it thinks are missing instead of just the first few?
13:27:44 <cmccann> jmcarthur: that sounds like something that would turn out to be much harder to implement than it seems at first
13:27:51 <knupfer> thanks for the paper
13:28:14 <quchen> How does GHC determine whether something should be inlined? Doesn't it have some metric to calculate the size of a definition? Could that size be a basis for parallelization?
13:28:39 <jmcarthur> cmccann: really? do you think it often generates an infinite number of patterns?
13:28:39 <cmccann> jmcarthur: for instance, how would you list the missing patterns for "foo 0 = (); foo :: Integer -> ()"
13:28:51 <jmcarthur> cmccann: it already does something for that
13:28:55 <suppi> knupfer, if you got some time: https://www.youtube.com/watch?v=hlyQjK1qjw8
13:29:49 <jmcarthur> cmccann: Patterns not matched: #x with #x `notElem` [0#]
13:30:00 <cmccann> jmcarthur: handling any one example is probably easy, it's the general case I'm not sure about
13:30:21 <jmcarthur> cmccann: i'm not looking for some formal proof that it's always correct
13:30:23 <cmccann> though I didn't know it did that for number literals in patterns, that's awesome
13:30:35 <jmcarthur> cmccann: i just want the stuff that ghc is intentionally truncating
13:30:48 <cmccann> jmcarthur: fair enough
13:30:52 <jmcarthur> cmccann: (when it outputs the ... after a few patterns)
13:31:06 <cmccann> I'm just thinking that it sounds like a can of worms that they might have decided it was easier to just not open
13:32:36 <jmcarthur> cmccann: Yeah, I know it's not super easy. GADTs, in particular, make exhaustiveness checks really hard (impossible in general I've heard, but I don't quite understand why that would be).
13:33:18 * hackagebot funbot-ext-events 0.1.0.0 - Interact with FunBot's external events.  https://hackage.haskell.org/package/funbot-ext-events-0.1.0.0 (akrasner)
13:34:21 <jmcarthur> I also wish we had or-patterns like in OCaml.
13:34:31 <cmccann> jmcarthur: probably something to do with some syntactically plausible patterns being type errors
13:34:55 <quchen> jmcarthur: Or patterns?    Left x | Right x -> print x?
13:35:01 <MarcelineVQ> jmcarthur: thank you for asking that question btw, it showed me that  -fwarn-incomplete-uni-patterns is not enabled by -Wall
13:35:13 <jmcarthur> quchen: e.g. case a `compare` b of (LT | EQ) -> foo; GT -> bar
13:35:28 <quchen> Ah. That would be nice.
13:35:32 <MarcelineVQ> It confused me that my lamdbas could fail pattern matches and I wasn't warned about it
13:35:38 <jmcarthur> quchen: also works with binding variables, as long as you bind all the same variables in each case and they have the same type
13:35:39 <Sindriav_> It would be kinda neat if function application was a typeclass-level feature
13:36:09 <jmcarthur> Sindriav_: I made a preprocessor to do that once, but I found it difficult to play nicely with type inference.
13:36:32 <cmccann> or patterns like that always struck me as obvious and useful, it's cool that OCaml has them
13:36:34 <jmcarthur> MarcelineVQ: Ah! You're welcome. Note that when you enable fancy type system features, that check is not perfect.
13:36:45 <Sindriav_> jmcarthur: What I figured would be particularly nice is to have values act like functions for certain stuff
13:37:10 <jmcarthur> Sindriav_: Yup. I did exactly that. I made a type class for types whose denotations are functions.
13:37:16 <MarcelineVQ> jmcarthur: My code was pretty vanilla, I​ just didn't understand patterrn matching in lamdas at the time, but it was especially confusing when -Wall didn't let me know it was an issue
13:37:17 <Sindriav_> Neato!
13:37:26 <Sindriav_> jmcarthur: e.g. ` apply :: a -> (a -> b) -> b ` and then you get infix notation for free
13:38:14 <jmcarthur> MarcelineVQ: oh, actually, i was thinking you were just talking about -fwarn-incomplete-patterns
13:38:19 * hackagebot funbot-client 0.1.0.0 - Report events to FunBot over a JSON/HTTP API.  https://hackage.haskell.org/package/funbot-client-0.1.0.0 (akrasner)
13:38:47 <Sindriav_> jmcarthur: because if `Num a` behaves like a function that takes `Num a => (a -> b)` and you have `div`
13:38:50 <jmcarthur> MarcelineVQ: I think the reason -fwarn-incomplete-uni-patterns isn't enabled by -Wall is that they are normally lazy.
13:39:01 <Sindriav_> jmcarthur: They you can write ` 5 div 2 ` and it works really nicely
13:39:27 <jmcarthur> Sindriav_: i don't think i understand, but what i'm seeing frightens me :)
13:39:36 <Sindriav_> jmcarthur: Yeah, it's hacky as fuck
13:39:39 <Sindriav_> jmcarthur: parenthesized as ` (5 div) 2 `
13:40:00 <Sindriav_> jmcarthur: You say that "function application is a general behaviour, described by a typeclass"
13:40:09 <jmcarthur> Sindriav_: The kind of thing I was doing wasn't really hacky. Anything with a function denotation could be an instance. For example, you could apply a (Map k v) to a k to get a v.
13:40:13 <jmcarthur> Sindriav_: *a Maybe v
13:40:16 <Sindriav_> I see
13:40:25 <Sindriav_> jmcarthur: (->) implements that typeclass as expected
13:40:45 <Sindriav_> and any general `a` implements it as I said above
13:41:09 <Sindriav_> e.g. value is a function, that takes a function and returns itself applied to that function
13:41:18 <Sindriav_> `5 div` == `div 5`
13:41:39 <jmcarthur> If we had or-patterns, I would hardly ever use wildcard patterns anymore. I would explicitly match the cases I expect to be there.
13:41:46 <shersh> Hello everyone! I have value of type `Rand StdGen Double` and I want to get that Double value from functions. How can I write function with type: getRandDouble :: Rand StdGen Double -> Double? And I'm also interested in general way, like: unbox :: (Monad m) => m a -> a
13:42:04 <athan> Is there an `insert` analogue to Data.lookup? insert :: Eq k => k -> v -> [(k,v)] -> [(k,v)]
13:42:17 <Sindriav_> shersh: That's not possible in a safe way.
13:42:17 <jmcarthur> athan: (:)
13:42:23 <athan> er Prelude.lookup **
13:42:32 <Sindriav_> shersh: How would `unbox` work for `Maybe` ?
13:42:35 <athan> :u
13:42:38 <mniip> :t insert
13:42:39 <Sindriav_> shersh: error on Nothing?
13:42:40 <lambdabot> Ord a => a -> [a] -> [a]
13:42:49 <athan> jmcarthur: Well, what about checking `k`
13:42:55 <athan> sorry, almost had me :P
13:42:58 <jmcarthur> athan: what about it?
13:42:58 <shersh> unbox (Just a) = a; unbox Nothing = undefined; This is fine for me :)
13:43:13 <mniip> shersh, nice comonad you got there
13:43:14 <athan> jmcarthur: You don't want duplicate keys
13:43:16 <jmcarthur> athan: lookup applied to the result will find your new mapping before the old one
13:43:20 <Sindriav_> shersh: That's also ridiculously debilitating
13:43:24 <cmccann> shersh: that's not really fine though
13:43:28 <jmcarthur> athan: the only dodgy operation here would be delete. you'd have to use filter instead
13:43:46 <shersh> And how can I check value under Rand StdGen Double? There is no Show instance for Rand StdGen Double :( 
13:43:52 <Sindriav_> shersh: I mean really, that's *seriously* not fine
13:43:52 <jmcarthur> athan: if you really want something that behaves like a map, why not just use a map?
13:44:03 <Sindriav_> shersh: Of course there isn't, why would there be? What would it show?
13:44:12 <jmcarthur> athan: the assumption i was making was that this was for something small and short-lived, so temporary duplication would be okay
13:44:16 <athan> jmcarthur: You're right. Because it still allows for duplicate nodes, but `insert` overwrites the /first/ occurance of the same k
13:44:18 <athan> otherwise, append
13:44:22 <Sindriav_> shersh: Rand StdGen Double isn't a Double.
13:44:22 <jmcarthur> athan: also, that's the fastest insert operation in the west
13:44:49 <athan> :P
13:45:18 <shersh> Ok, but how can I see Double value inside Rand StdGen Double? How can I check output of randomd or smth similar?
13:45:35 <Hijiri> you need to give it an StdGen
13:45:37 <Sindriav_> shersh: There is no Double value inside Rand StdGen Value
13:45:39 <athan> It's for Network.Wai.mapHeaders or whatever that function is - to set a content-type cookie :\
13:45:52 <Sindriav_> shersh: If you want to create a Double from that, you have to run it
13:45:58 <athan> it's sadly a k,v list of pairs
13:45:59 <glguy> There isn't a Double inside Rand StdGen Double, there are instructions for making random doubles. What you do is build up the whole random think you want our of those instructions and then extract the result at the end
13:46:12 <Sindriav_> shersh: and by running, I mean supplyin initial conditions to that operations, such as a generator
13:46:16 <jmcarthur> athan: convert it to whatever type you really want it to be
13:46:30 <glguy> shersh: Do you have the URL for this exercise handy?
13:46:33 <jmcarthur> athan: just because you're using an annoying API doesn't mean you have to write all your code to be equally annoying
13:46:35 <athan> =/
13:46:40 <Sindriav_> shersh: What you're asking is "How do I get a cookie from a thing that makes cookies from dough?"
13:46:58 <Sindriav_> shersh: If you want a cookie, provide some dough. There is no cookie in the cookie maker, the cookie maker is not edible.
13:47:10 <jmcarthur> athan: I admit my advice seems overkill if all you want to do is update a single element.
13:47:12 <athan> but... performance cost maaan....
13:47:14 <glguy> There's going to be a function like:  runRand :: g -> Rand g a -> a
13:47:22 <athan> haha
13:47:24 <Sindriav_> shersh: The cookie maker is not a cookie in itself. There's probably something like glguy said
13:47:25 <glguy> that you'll use at the very end
13:47:29 <jmcarthur> athan: maybe lens has something for this
13:47:33 <shersh> Ok, I get it. How to produce Double? What should I pass to value with type Rand StdGen Double?
13:48:19 <Sindriav_> shersh: You don't pass stuff to it, you *pass it* to something, that runs it. In this case, I think there's something like "evalRand", which takes a generator and returns the value
13:48:19 * hackagebot Tic-Tac-Toe 0.1.0.0 - Tic Tac Toe in your command line!  https://hackage.haskell.org/package/Tic-Tac-Toe-0.1.0.0 (2016rshah)
13:48:41 <Sindriav_> shersh: Or there's variants like `evalRandIO`, which don't take a generator and use the system time or whatever, but those return IO Value
13:49:01 <Sindriav_> shersh: e.g. `Rand StdGen Double -> IO Double`
13:49:23 <Sindriav_> shersh: For making a generator, there's `mkStdGen` which takes a seed, if I'm not mistaken 
13:49:40 <Sindriav_> shersh: Are you using the `monadrandom` library?
13:50:10 <cmccann> Sindriav_: anything is edible if you chew hard enough
13:50:20 <shersh> Sindriav_: Thanks! Yes, I'm using MonadRandom. Now I get the whole situation thanks to you :)
13:50:48 <Sindriav_> cmccann: IMO `able to be eaten /= edible`
13:51:05 <Sindriav_> cmccann: Poisonous shrooms are easy to eat, but aren't labeled as edible commonly
13:51:43 <Sindriav_> shersh: No prob. It's important to get the intuition that "Monad m => m a" isn't necessarily close to `a`
13:51:45 <cmccann> hm, good point
13:52:45 <Sindriav_> shersh: For example, if you asked me how to get a `Double` from `[Double]`, the answer isn't so clear. You might have an empty list, or you might have thousands of Doubles to choose from
13:52:47 <cmccann> @quote shachaf ls
13:52:47 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
13:53:08 <athan> Can anyone recommend a good form-data parser? From browser forms?
13:53:12 <Sindriav_> @karma+ shachaf cmccann 
13:53:12 <lambdabot> shachaf's karma raised to 88.
13:53:16 <Sindriav_> @karma+ cmccann 
13:53:16 <lambdabot> cmccann's karma raised to 21.
13:53:23 <Sindriav_> That's a really good quote :D
13:53:28 <cmccann> it's a classic
13:53:34 <athan> it can be Data.Text, Data.ByteString or whatever ._.
13:58:39 <flexfit> I'm not quite sure what rootLabel does. Is that just a constructor for a tree?
14:00:27 <flexfit>  https://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Tree.html
14:01:07 <radix> I just asked this SO question, in case anyone here is interested in helping out with some type-level stuff http://stackoverflow.com/questions/32673144/how-do-i-interpret-a-free-dsl-program-against-a-test-description-of-expected-eff
14:01:36 <geekosaur> flexfit, looks to me like it's the node value?
14:02:15 <geekosaur> data Tree a = Node a [Tree a] -- shorter version of that type
14:02:18 <knupfer> @pl \x -> x { f = g $ f x }
14:02:18 <lambdabot> (line 1, column 9):
14:02:18 <lambdabot> unexpected '{'
14:02:18 <lambdabot> expecting variable, "(", operator or end of input
14:02:40 <catgocat> How would I evaluate code in haskell at runtime?
14:02:49 <catgocat> Say I need to catch a piece of haskell code and run it and return result
14:02:54 <geekosaur> catgocat, hint
14:02:59 <geekosaur> @hackage hint
14:02:59 <lambdabot> http://hackage.haskell.org/package/hint
14:03:13 <catgocat> is that what lambdabot uses?
14:03:17 <catgocat> to evaluate given expressions?
14:03:23 <catgocat> > "this"
14:03:24 <geekosaur> haskell is compiled, not interpreted, so there is no magically available "eval" in the language
14:03:25 <lambdabot>  "this"
14:03:27 <flexfit> geekosaur: So if someone is mapping that over a tree, they're just grabbing all the node values?
14:03:45 <geekosaur> lambdabot actually uses mueval, which IIRC has some extra safety features on top of hint
14:04:04 <geekosaur> flexfit, not sure what you mean
14:04:16 <geekosaur> the actual declaration used record syntax instead of ADT syntax
14:04:21 <geekosaur> data Tree a = Node a [Tree a] -- shorter version of that type
14:04:34 <quchen> Is *Haskell* compiled? I'd be surprised if the Report demanded that.
14:04:43 <flexfit> geekosaur: I was looking at someone's implementation of BFS. http://blogs.msdn.com/b/matt/archive/2008/05/11/breadth-first-tree-traversal-in-haskell.aspx. 
14:04:48 <geekosaur> data Tree a = Node { rootLabel :: a; subForest :: [Tree a ] } -- actual declaration
14:04:59 <geekosaur> which just lets you name the fields
14:05:24 <cmccann> the Haskell 2020 Report will be just one page that says "what GHC does? yeah, let's go with that"
14:05:45 <geekosaur> anyway that makes rootLabel a function:  rootLabel (Node v _) = v
14:05:45 <quchen> Let's not do that.
14:06:08 <athan> quchen: Hugs was an interpreter, wasn't it?
14:06:36 <quchen> I don't know. I'm also not sure whether GHCi is an interpreter or an on-the-fly compiler or something.
14:06:38 <geekosaur> yes, hugs was an interpreter. it was not a dynamic interpreter though, still no built-in eval
14:06:46 <quchen> I wasn't around when Hugs was still a thing.
14:06:55 <hvr> cmccann: ;-)
14:07:21 <geekosaur> ghci is using the same mechanism as hint underneath, which is ghc-as-a-library. but it's an odd mechanism, which leads to a bunch of weird behaviors
14:07:49 <geekosaur> (for example, it's why a lot of FFI stuff tends to behave oddly in ghci vs. compiled code)
14:08:20 * hackagebot Tic-Tac-Toe 0.1.0.1 - Tic Tac Toe in your command line!  https://hackage.haskell.org/package/Tic-Tac-Toe-0.1.0.1 (2016rshah)
14:08:25 <geekosaur> historically there have been linking issues, threading issues, etc.
14:09:11 <geekosaur> I think there's in ghc 7.10.2 (but supposedly fixed in HEAD) currently a warning when you use ghci on Windows and use a compiled package linked against a DLL
14:09:36 <geekosaur> where it warns about using the actual symbol instead of the import symbol, because ghci / ghc-api is cutting corners on the link step
14:10:33 <ttt_fff> are there vim bindings for happy/alex ? I can't find any on github
14:22:49 <flexfit> If I want to use Data.Tree in GHCi, do I type "
14:22:55 <flexfit> :l Data.Tree?
14:23:10 <geekosaur> import Data.Tree
14:23:11 <geekosaur> or
14:23:16 <geekosaur> :m +Data.Tree
14:23:21 * hackagebot Tic-Tac-Toe 0.1.0.2 - Tic Tac Toe in your command line!  https://hackage.haskell.org/package/Tic-Tac-Toe-0.1.0.2 (2016rshah)
14:23:40 <flexfit> ah. That makes more sense. It wasn't letting me load it in.
14:25:08 <JagaJaga> If I have `data A = A { a :: Int, b :: [Int]}` how can I update b without lens?
14:27:49 <Hijiri> banana { b = newlist }
14:28:05 <Hijiri> update banana newlist = banana { b = newlist }
14:28:12 <JagaJaga> Hijiri: thank you!
14:31:29 <timmy_tofu> Is there a way to split up doctest prop checks across multiple lines?
14:34:25 <roconnor> Did (&) make it anywhere nice?
14:34:33 <roconnor> Some base module?
14:34:36 <shachaf> Data.Function
14:34:47 <roconnor> really. wow
14:35:37 <roconnor> so I can remove it from Lens.Family I guess.
14:36:33 <athan> What's it's fixity? 9, like $?
14:37:13 <athan> wwoah, 1 ?
14:37:15 <kadoban> athan: ($) is precedence 0
14:37:29 <athan> >< sorry
14:37:34 <roconnor> @info (&)
14:37:34 <lambdabot> (&)
14:38:17 <geekosaur> no @info or :i in the bot
14:38:18 <mniip> info is not a command
14:38:26 <athan> that's cool :)
14:38:31 <geekosaur> (@info editcorrects to @undo)
14:38:57 <kadoban> lol
14:39:13 <mniip> geekosaur, if it's a levenshtein distance of 2, why doesn't @ew correct to @pl
14:39:39 <geekosaur> because it refuses for something short, iirc. think it requires at least 3 characters
14:40:21 <geekosaur> actually IIRC the levenshtein distance it uses is 3 and it only does it for commands 4 chars or longer
14:40:54 <roconnor> kadoban: infixl 1
14:40:55 <geekosaur> also it rejects it if it gets more than one match
14:41:34 <kadoban> roconnor: Mine says infixr 0
14:41:41 <geekosaur> hm, actually I think just the latter, because I recall it suggesting @bf and @pl for random 2-character ones
14:41:45 <roconnor> :(
14:41:54 <geekosaur> are you both talking about (&)?
14:42:02 <kadoban> I'm talking about ($)
14:42:06 <geekosaur> I think ($) is infixr 0 and (&) is infixl 1
14:42:08 <roconnor> I'm talking about (&)
14:43:00 <cmccann> "infixl 1" and "infixr 0" are separated by levenshtein distance of 2, so according to lambdabot they're basically the same anyhow
14:43:26 <geekosaur> :p
14:43:50 <geekosaur> and ($) and (&) are levenshtein distance 1 :p
14:44:46 <athan> (&) is to >>= as ($) is to =<< ?
14:45:10 <athan> nice
14:45:32 <cmccann> (&) is equivalent to (>>=) for Identity modulo newtype wrappers, yes
14:45:38 <ttt_fff> ARGH
14:45:49 <ttt_fff> is there a way to tell cabal "ignore warnings generated by Lexer.hs and Parser.hs" (which are output by Alex/Happy) ?
14:47:47 <mniip> cmccann, Acme.PHP and Prelude have a levenshtein distance of 7!
14:47:55 <mniip> that means they're similar enough right
14:50:21 <hexagoxel> ttt_fff: can you tell Alex/Happy to prefix {-# OPTIONS_GHC -w #-} ?
14:50:40 <ttt_fff> at the very top of the file
14:50:43 <ttt_fff> or somewhere in the file?
14:51:06 <hexagoxel> ttt_fff: needs to be top, apparently
14:51:22 <ttt_fff> hmm, parser.hs already has it
14:51:27 <ttt_fff> guess all warnings are fom lexeer.hs
14:51:51 <ttt_fff> hexagoxel: okay, that fixed it
14:51:53 <ttt_fff> thanks!
14:53:39 <athan> Does `fail` cause a `throwError` too? :L
14:54:49 <kadoban> 'fail' does whatever the Monad instance says it should. The default is 'error, though I'm pretty sure.
14:56:45 <athan> owch. Is there a way to catch errors, internally? And turn them into a sound `Either String`?
14:56:57 <voidzero> there is ExceptT
14:57:06 <kadoban> Most of what I know about 'fail' is … don't.
14:57:10 <voidzero> not sure if that's what you're looking for?
14:57:16 <athan> voidzero: That's what I normally use, but this thing I have is calling `fail` :|
14:57:20 <kadoban> But I don't think so, unless yeah the Monad does that.
14:57:23 <athan> :(
14:57:25 <cmccann> athan: http://hackage.haskell.org/package/spoon
14:57:35 <glguy`> ErrorT is for catching fail
14:57:50 <glguy`> ExceptT is for passing it through
14:58:10 <athan> glguy`: Thank you :)
14:58:26 <athan> cmccann: that looks also good, thanks!
14:59:13 <cmccann> athan: it's pretty hackish though. it's catching the exceptions and then using unsafePerformIO, heh
15:00:58 <athan> cmccann: :\ yeah, I feel uneasy about it
15:01:26 <athan> Does anyone here know of a good url-encoded parser library? Ideally using attoparsec?
15:01:43 <athan> this is not very good: https://hackage.haskell.org/package/urlencoded-0.4.1
15:02:32 <athan> it's what's calling fail ;-;
15:02:49 <kadoban> Heh
15:04:31 <ChristianS> athan: Network.HTTP.Base
15:22:45 <kaidelong> spoon looks like something to avoid
15:22:58 <kaidelong> $ has lowest precedence, right?
15:23:03 <kaidelong> this seems kinda unfortunate
15:23:09 <kaidelong> how does it interact with &?
15:23:23 <kaidelong> it'd be nice to be able to things like
15:23:31 <kaidelong> foo & bar $ baz quux
15:24:10 <kaidelong> or "foo $ bar baz & quuz"
15:24:22 <tomus> anyone knows of a library which would alow me to extract subtitles from an image, e.g. https://witneyman.files.wordpress.com/2009/12/subtitled-keanu.png
15:24:29 <kaidelong> but I get the feeling I'm not going to be able to rely on $ binding more tightly?
15:24:30 <tomus> (not necesserily haskell)
15:26:07 <kadoban> tomus: Sounds like a job for whatever OCR library.
15:28:48 <radens> What do curly braces mean in haskell? I see them in data definitions and in lambdas?
15:29:33 <radens> Also, what is the difference between -> and =? I suspect one binds a value and the other defines a function?
15:29:38 <tomus> kadoban: instead of going through the list of all of them, would be helpful if somebody guided me instead. do you know of an appropriate chat/person to ask?
15:30:06 <radens> Oops I meant <-
15:32:13 <Hakim> hi. if i create a function like this one below, how could i call it in GHCi independenetly
15:32:14 <Hakim>     shuf :: StdGen -> Hand -> Hand
15:32:14 <Hakim>     shuf gen deck = shuffleHelperFunc gen deck Empty
15:32:34 <Hakim> hand i already have but what is the best suited argument for StdGen?
15:32:37 <radens> Hakim: Have you tried using let?
15:32:46 <radens> oh, never mind, I have no clue.
15:33:28 <kadoban> Hakim: getStdGen or mkStdGen ?
15:34:09 <geekosaur> radens, <- turns into >>=
15:34:13 <geekosaur> :t (>>=)
15:34:14 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:34:42 <lspitzner> radens: {} are for records ("record syntax", e.g. see http://learnyouahaskell.com/making-our-own-types-and-typeclasses)
15:34:45 <radens> Okay, thanks geekosaur
15:34:51 <geekosaur> conceptually, it runs a monadic action and makes the result available to some other function
15:35:01 <geekosaur> ...which is invoked as a "callback"
15:35:21 <athan> radens: Also, bookmark this:
15:35:22 <athan> @learn
15:35:23 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
15:35:39 <Hakim> Couldn't match expected type `StdGen'
15:35:39 <Hakim>                 with actual type `Int -> StdGen'
15:35:39 <Hakim>     Probable cause: `mkStdGen' is applied to too few arguments
15:35:45 <Hakim> getting it not right enough
15:35:47 <geekosaur> (thus for IO it does not actually mean you can turn an IO String into a String, it means you can "attach" a function which at some point will be given a String)
15:35:52 <Hakim> am just wondering what am really missing
15:36:04 <geekosaur> :t mkStdGen
15:36:05 <lambdabot> Int -> StdGen
15:36:15 <geekosaur> mkStdGen takes a seed and produces a StdGen
15:36:51 <athan> :t getStdGen
15:36:52 <lambdabot> IO StdGen
15:37:56 <kadoban> Hakim: You have to check the types and read the docs and such.
15:38:48 <lspitzner> radens: the official docs in the 2010 report would be https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-490003.15
15:39:00 <Hakim> well, tht was quite helpfull 
15:40:47 <osa1> does anyone else here ever wanted something like a list section? [a, b, c, , d] etc. like tuple sections but for lists
15:42:40 <geekosaur> not really; plus it'd be rather hard to do, and slow
15:53:26 * hackagebot funbot-client 0.1.0.1 - Report events to FunBot over a JSON/HTTP API.  https://hackage.haskell.org/package/funbot-client-0.1.0.1 (akrasner)
16:12:00 <ttt_fff_> is there a way to do "cabal sandbox init; cabal install --only-deps; cabal GLOBAL CACHE THIS .cabal-sandbox directory so I don't have to recompile on every new project" ?
16:12:45 <geekosaur> ttt_fff_, no, cabal-install can't do that
16:12:47 <geekosaur> stack can
16:12:54 <geekosaur> (and does implicitly, I believe)
16:13:04 <ttt_fff_> well, with stack, don't you just have one global repo
16:13:06 <lspitzner> not yet, at least
16:13:09 <ttt_fff_> since there's one version pegged for every library
16:13:41 <geekosaur> stack keeps a global cache, yes, but things in the cache do not interfere with each other
16:14:19 <geekosaur> it's more like "cache this specific build and if some other stack sandbox can use this specific build then copy it into that sandbox when needed"
16:14:39 <geekosaur> but they're not in the global package list and won't interfere with anything that doesn't require that specific build
16:16:57 <geekosaur> basically current cabal-install relies on ghc-pkg, which does the wrong thing with multiple builds (cf. what lspitzner said); stack keeps its own private cache to avoid the limitations of ghc-pkg
16:19:09 <geekosaur> "no-reinstall cabal" aims to address this but is still dependent on ghc-pkg which still does the wrong thing. see http://blog.ezyang.com/2015/09/is-no-reinstall-cabal-coming-to-ghc-8/
16:21:51 <lspitzner> as i understand it, ghc-7.10 (and its ghc-pkg) would already work (apart from potential errors having messages that are hard to understand). but cabal-install needs to support older ghc versions.
16:22:03 <geekosaur> partly work
16:22:48 <geekosaur> "no-reinstall cabal" is *functional* with ghc 7.10, but still has shortcomings that must be fixed in ghc. the blog entry I just mentioned describes the ghc shortcomings and two patches that aim to address them
16:23:06 <geekosaur> (also talks about the backwards compat issue)
16:27:18 <lspitzner> i wonder if you can get the functionality with plain cabal-install atm, provided that you somehow avoid the reinstall issues. afaik you already _can_ relatively freely specify the stack of package db's to use.
16:28:14 <geekosaur> with older ghc-s, you can't prevent it from looking at the global db so you must shadow everything in it that might be of interest
16:28:16 <lspitzner> you'd still have to directly install to the right db, not move retroactively. but i don't any tool does moving.
16:28:50 <geekosaur> I think 7.10.1 was the first version that was able to disable the global db entirely? and I think stack does the shadow-everything with older ghc
16:29:16 <lspitzner> yeah but still, you migth be able to use [global, user-shared-db, project-specific-sandbox]
16:29:19 <geekosaur> basically cabal-install tries to work with ghc and runs into its library management shortcomings, while stack goes out of its way to take library management away from ghc as much as possible
16:29:41 <lspitzner> while cabal-install with sandboxes defaults to [global, sandbox-specific]
16:30:08 <geekosaur> (which was something I suggested some time ago as a route cabal-install would have to follow to escape ghc/ghc-pkg's shortcomings)
16:30:58 <ttt_fff_> Alex + Happy is so nice
16:31:07 <ttt_fff_> I no longer get why all haskell tutoirlas are all PARSEC = THE GREATEST EVER
16:33:42 <mniip> ttt_fff_, the fact that GHC itself doesn't use parsec
16:34:54 <geekosaur> that's largely historical though
16:35:03 <levi> Parser combinators are an interesting topic, they're more flexible than external parser builder tools, and they show off the power of Haskell for making efficient embedded domain-specific languages.
16:35:17 <geekosaur> ghc predates parsec, and would require a lot of rewiring to switch. the devs discuss it every so often
16:36:19 <geekosaur> by and large, if you are used to parser generators in other languages you'll probably like happy; but... well, they;re historical artifacts really. lex and yacc, the grandparents of the whole field, existed solely to make stuff fit in a PDP11's address space
16:36:27 <levi> A downside of Alex and Happy is that they introduce a binary dependency for programs that use them, and cabal-install doesn't handle those. But if you're not releasing your app on Hackage, that's a non-issue.
16:37:33 <glguy> cabal-install will tell you that alex or happy are build-tools for your package
16:37:43 <glguy> and is also able to install those for you, just doesn't do it automatically
16:38:16 <levi> I'm aware, but it does cause some friction when installing things.
16:41:02 <levi> geekosaur: I wouldn't go as far as saying that parser generators are historical artifacts. They can help a lot if your goal is to generate a highly efficient parser and you have enough control over what you're parsing to restrict it to one of the formal language classes that there are known-fast parsers for.
16:43:22 <levi> But I'd say that for day-to-day parsing tasks as well as for parsers that have to make a lot of heuristic decisions for things like error handling, parser combinators are easier to employ.
16:49:45 <ttt_fff_> can ALEX + HAPPY parse APL ?
16:52:31 <mniip> probably
16:52:46 <mniip> definitely even
16:53:35 <quchen> apl = many anyToken? :-x
16:54:38 <Welkin> how does this know that all UUIDs are unqiue? https://hackage.haskell.org/package/uuid-1.3.11/docs/Data-UUID.html
16:54:43 <Welkin> how does it track that?
16:55:39 <spopejoy> is there some elegant way to deploy two isos simultaneously to convert both sides of a tuple with `view`? something like `view (bothIsos iso1 iso2)`? I have an iso that can do it, but it's calling view on both sides so it seems overly mechanical.
16:56:17 <ttt_fff_> APL has ops that have binary and unary meanings and verbs and adverbs or something
16:59:23 <hexagoxel> Welkin: it probably does not, but collisions are almost impossible for truely random uuids.
17:01:22 <Pamelloes> Welkin: https://en.wikipedia.org/wiki/Universally_unique_identifier#Random%5FUUID%5Fprobability%5Fof%5Fduplicates
17:01:23 <Welkin> hexagoxel: it uses the mac adress + datetime
17:01:38 <Welkin> is there a proof that it is guranteed to be unique?
17:01:45 <Welkin> guaranteed*
17:03:22 <Pamelloes> Welkin: There is no proof, but (see the source I linked) after generating 1 billion UUIDs every second for the next 100 years, the probability of creating just one duplicate would be about 50%
17:04:07 <adas> doing stack install --dependencies-only does not do anything. i have the package 'directory' in build depends in the cabal file
17:04:29 <Pamelloes> Basically, for all intents and purposes, generating a repeat UUID can be considered impossible.
17:05:49 <hexagoxel> Welkin: the MAC+datetime is just one way; the Random instance seems to fill all bits randomly.
17:06:02 <hexagoxel> Welkin: see https://hackage.haskell.org/package/uuid-types-1.0.2/docs/src/Data-UUID-Types-Internal.html
17:06:21 <Welkin> so would this be suitable for generating database primary keys?
17:06:49 <hexagoxel> if you have a database that supports such large keys..
17:07:28 <Welkin> how big are they?
17:07:52 <hexagoxel> 16 byte i think..
17:08:10 <Welkin> hm
17:08:13 <hexagoxel> 128 bit
17:08:17 <Welkin> that is what is used in this opaleye example
17:08:18 <Welkin> https://github.com/silkapp/silk-opaleye/blob/master/example/Example.hs
17:08:50 <Welkin> I am disappointed with opaleye's lack of features
17:09:06 <Welkin> I was hoping it could support table creation at least
17:09:08 <Welkin> and migrations
17:10:51 <Welkin> does anyone have any opinion on persistent + esqueleto vs opaleye?
17:15:21 <Pamelloes> I have not used opaleye, but I've been very happy with persistent + esqueleto.
17:17:11 <Welkin> Pamelloes: yeah, I am happy with persistent + esqueleto, but esqueleto does not guarantee that the query won't fail at runtime
17:17:14 <Welkin> where as opaleye does
17:17:30 <Pamelloes> Yep, that's the big drawback.
17:18:43 <Pamelloes> Also, though I can't compare it to opaleye, esqueleto's type system is a bit convoluted and the syntax could be cleaner.
17:20:06 <jarlopez> Reading through the example of length' at http://learnyouahaskell.com/syntax-in-functions.  Is there a reason to use length' :: (Num b) over length'
17:20:18 <jarlopez> length' :: (Num b)     over    length
17:20:26 <jarlopez> length' :: (Integral b)
17:20:47 <jarlopez> Sorry for the trigger-happy return key :-\
17:21:26 <adas> why the fuck do the stack option not do the most obvious thing?
17:22:34 <Pamelloes> jarlopez: length' :: Num b => [a] -> b is more generic. Its results can be used directly in calculations that require non-integral numbers like (/).
17:23:46 <jarlopez> Pamelloes: Ahh, right. So despite being guaranteed to be Integral, using Num makes it easier to work with
17:23:53 <Pamelloes> Exactly
17:23:57 <jarlopez> Thanks
17:24:28 <Pamelloes> jarlopez: In general, you want to make your type signature as generic as possible.
17:25:07 <Pamelloes> Of course, more specific type signatures can often allow for more efficient algorithms or better compiler optimizations but pre-mature optimization is never a good thing :)
17:28:40 <Axman6> adas: what do they do, and what do you think they should do?
17:30:52 <KaneTW> length should definitely be Integral
17:32:51 <adas> stack haddock - build the fucking documentation for all the dependencies in the local stack.yaml
17:32:55 <jarlopez> KaneTW: You don't agree with the signature which uses Num?
17:33:00 <KaneTW> no, not at all
17:33:09 <glguy> adas: Please keep your comments productive
17:33:17 <KaneTW> if you just make the isgnature Num you lose a lot of information about the length value
17:33:49 <KaneTW> like how it's a bounded, real (ordered) number or that you can use toInteger/div/mod on it
17:34:06 <KaneTW> arguments should be as generic as possible
17:34:09 <adas> productive? you mean communicating the information respectfully? or just simply communicating the information?
17:34:11 <jarlopez> but you'd gain compatibility with most types of calculations, no?
17:34:17 <KaneTW> return values as special as possible
17:34:22 <KaneTW> Integral is a subclass of Num
17:34:46 <KaneTW> any data type that's an instance of Integral has to be a instance of Real and Enum, and Real implies Num and Ord
17:35:45 <KaneTW> *actually it doesn't tell you that it's bounded, but yeah
17:35:46 <adas> either way i was disrespecting the tool. not anyone here in the channel
17:36:49 <adas> oops sorry. should have been stack haddock --only-dependencies . regardless doesn't work there either
17:37:33 <jarlopez> Hmm Pamelloes what do you think re: KaneTW's comments?
17:43:08 <roconnor> are there cases when someone would want to use modify' in Lazy.State or modify in Strict.State?
17:43:23 <roconnor> I guess I mean State.Lazy and State.Strict 
17:43:52 <Pamelloes> jarlopez: I agree with KaneTW. Arguments should be as generic as possible while result types should encode all relevant information. I was thinking about the result as a parameter which was a mistake :)
17:45:06 <tjpeden> glguy: you still around?
17:45:12 <glguy> Yeah
17:45:20 <jarlopez> Hmm OK. So both of you agree that the example on learnyouahaskell.com could be improved by explicitly stating that an Integral type is returned?
17:46:03 <KaneTW> yeah
17:46:05 <Pamelloes> yep
17:46:10 <KaneTW> it's also part of the reason i don't really like lyah
17:46:16 <adas> apologies. just got frustrated.
17:46:29 <jarlopez> I'm happy to switch gears if you have something better you'd recommend, KaneTW 
17:46:48 <Pamelloes> adas: Happens to the best of us :)
17:46:54 <KaneTW> bitemyapp's book (haskellbook.com i think) or 
17:46:57 <KaneTW> @where learnhaskell
17:46:57 <lambdabot> https://github.com/bitemyapp/learnhaskell
17:47:16 <jarlopez> Thanks a bunch
17:47:48 <bz> is there any performance difference between a tagged and a tagless interpreter? intuitively it feels like compiler optimizations can gonfurther in the tagless case
17:47:53 <tjpeden> So, I was poking around on your Github and I noticed the unicorn-hat-hs repo, so Haskell compiles to R-Pi then?
17:48:32 <glguy> tjpeden: Yeah, GHC 7.4.2 is in the raspbian (I think that's what I use) repository
17:48:34 <adas> Pamelloes: silly of me to be swearing in here. helpss no one. but yup i agree. tis happens
17:50:01 <tjpeden> glguy: That's awesome, I'm going to have to play with that!
18:07:21 <cmccann> urgh. why does GHC have to complain about "no instance for (Foo bar)" just because an unrelated type error made it give up in the middle of type inference?
18:07:47 <kadoban> Presumably because it can't tell that you don't want there to be an instance for whatever.
18:08:10 <KaneTW> because once a type error happens it can't continue inferring
18:08:18 <cmccann> except that if I fix the other, unrelated type error it accepts the code and infers the relevant constraint
18:08:37 <KaneTW> there's a rationale in the code somewhere
18:08:38 <cmccann> it makes the output noisy so it's hard to find the actual error
18:08:46 <ttt_fff> is there a way to make cabal Alex/Happy aware, and to process *.x and *.y files on my behalf,
18:08:52 <ttt_fff> or do I have to handle this separately in my Makefile
18:09:08 <cmccann> at least turning off the DMR seems to make it not do this in some (all?) cases
18:09:33 <geekosaur> doesn't it already? just name them somewhere
18:10:32 <geekosaur> if you list the module name and it finds a .x or .y file matching (but no .hs) it should use alex or happy
18:11:23 <cmccann> KaneTW: rationale for not continuing type inference? or for generating spurious constraint errors because of it? the former I can totally understand, it's just the latter that annoys me.
18:12:10 <KaneTW> former
18:12:26 <KaneTW> if you can give me an example of what generates too many errors i can take a look at it
18:18:44 <athan> ChristianS: Hey, that actually isn't what I'm looking for. POST data is in `x-www-urlencoded`, not actually the same thing that GET data would be encoded with: https://en.wikipedia.org/wiki/Percent-encoding#The_application.2Fx-www-form-urlencoded_type
18:19:17 <athan> ChristianS: This one, for instance, is only valid for GET data: https://hackage.haskell.org/package/HTTP-4000.2.20/docs/Network-HTTP-Base.html#v:urlEncode
18:24:11 <cmccann> KaneTW: I don't have any examples at the moment since I usually fix the type errors :P
18:25:52 <KaneTW> if you encounter one that you think is too verbose pm it or post a ticket
18:26:21 <cmccann> KaneTW: but on occasion I've had a dozen or more "no instance for.." errors vs. a single actual type error, and fixing the later made the code compile just fine
18:27:05 <cmccann> and at least in some cases, NoMonomorphismRestriction makes the spurious errors go away
18:27:57 <cmccann> hm
18:28:02 <cmccann> oh, I think I see what's happening there
18:29:41 <cmccann> it doesn't infer the type of the top-level definition, which has no type signature, and because the DMR is in effect stuff in the where clause generates errors
18:33:15 <athan> agh this one is wrong too: https://hackage.haskell.org/package/urlencoded-0.4.1/docs/Data-URLEncoded.html
18:45:17 <Javran> @hoogle (Enum a, Bounded a) => [a]
18:45:19 <lambdabot> Prelude enumFrom :: Enum a => a -> [a]
18:45:19 <lambdabot> Prelude maxBound :: Bounded a => a
18:45:19 <lambdabot> Prelude minBound :: Bounded a => a
18:45:38 <Javran> :t [minBound .. maxBound]
18:45:39 <lambdabot> (Bounded t, Enum t) => [t]
18:46:37 <lpsmith> hmm, is there a way to catch any exception *except* async exceptions?
18:50:47 <tjpeden> Is there a better way to do this: https://gist.github.com/tpeden/5d1022176bfd5918a093
18:55:32 <lpsmith> tjpeden, why not inline the case statement?
18:55:44 <pavonia> > (fromMaybe "" . fmap ("issue #" ++) . stripPrefix "issue") "issue 123"
18:55:46 <lambdabot>  "issue # 123"
18:56:00 <pavonia> > (fromMaybe "" . fmap ("issue #" ++) . stripPrefix "issue") "tissue 123"
18:56:02 <lambdabot>  ""
18:56:26 <dibblego> maybe "" (" - issue #" ++) (stripPrefix "issue" string)
18:56:27 <lpsmith> basically = case stripPrefix "issue" string of { Just number -> " - issue #" ++ number;  Nothing -> "" }
19:03:33 <tjpeden> I am a bit confused between pavonia's version and dibblego's version
19:03:56 <dibblego> the maybe function and the combination of fromMaybe+fmap provide the same power
19:04:10 <tjpeden> ah, good to know!
19:04:58 <dibblego> maybe a f = fromMaybe a . fmap f
19:05:28 <dibblego> you can write any function on Maybe using the maybe function, and ∴ the combination of (fromMaybe, fmap) [which is the same in power]
19:06:07 <mniip> when is GHC getting inline core snippets
19:06:22 <tjpeden> dibblego: Thanks so much!
19:06:48 <mniip> and when is GHC core getting inline Cmm snippets
19:06:54 <mniip> and when is Cmm getting inline assembly
19:07:12 <dibblego> tjpeden: no worries
19:08:57 <dibblego> the solution by lpsmith is one step from the solution using maybe  that pattern-matching also provides the same power
19:26:33 <tjpeden> I do like lpsmith's solution, I was wondering if it could be done that way (I got the solution I posted from a website), but I think I'll go with the maybe solution thanks to all three of you though!
19:38:39 * hackagebot keera-hails-reactivevalues 0.2.0.0 - Haskell on Rails - Reactive Values  https://hackage.haskell.org/package/keera-hails-reactivevalues-0.2.0.0 (IvanPerez)
19:43:39 * hackagebot keera-hails-reactive-gtk 0.3 - Haskell on Gtk rails - Reactive Fields for Gtk widgets  https://hackage.haskell.org/package/keera-hails-reactive-gtk-0.3 (IvanPerez)
19:51:21 <kristof> Can anyone think of an interesting typeclass that has a kind of (* -> *) -> * -> *
19:51:54 <cmccann> :k MonadTrans
19:51:55 <lambdabot> ((* -> *) -> * -> *) -> Constraint
19:52:16 <cmccann> kristof: probably others but that's the obvious one
19:52:59 <amicuscuriae> guys why is a linux binary with just "Hello World" turning out to be 1 MB?
19:53:08 <amicuscuriae> What wrong am I doing? Should not it be smaller?
19:53:15 <amicuscuriae> like 50 KB?
19:53:51 <kristof> You've got a, you know, garbage collector in there.
19:54:02 <Shockk> assuming you're using GHC as the compiler, it's compiling in a runtime system with a garbage collector
19:54:23 <Lokathor> amicuscuriae, the haskell runtime uses a lot of space, so the final size on haskell binaries tends to be (relatively) huge
19:54:27 <kristof> I also don't think you can dynamically link a garbage collector.
19:54:30 <cmccann> 1MB sounds a bit large to me
19:54:51 <kristof> I think that sounds quite reasonable.
19:54:54 <geekosaur> I think it's par for recent ghc?
19:55:04 <kristof> cmccann: Yeah, didn't think about the monadtrans class.
19:55:05 <cmccann> runtime must've gotten bigger over time I guess
19:55:13 <cmccann> I would've expected maybe half that size or a bit more
19:55:14 <geekosaur> there was some discussion of stuff coming out larger than expected in ghc 7.10 recently
19:56:03 <cmccann> amicuscuriae: anyway, if you think that's big, try compiling with profiling enabled and look at how much memory is allocated and GC'd in a typical program
19:56:28 <geekosaur> first off, what version of ghc?
19:56:45 <geekosaur> 7.10 includes a lot of extra debugging information (although it's not all usable yet)
19:57:27 <amicuscuriae> cmccann, 1 MB is huge right? For Hello World?
19:57:38 <amicuscuriae> Shockk, So it comes with garbage collector?
19:57:43 <amicuscuriae> Lokathor, I see
19:57:55 <cmccann> amicuscuriae: it's not like the code for the "hello world" part itself is more than a tiny tiny fraction of that
19:57:57 <bitemyapp> $ ghc --version
19:57:59 <bitemyapp> The Glorious Glasgow Haskell Compilation System, version 7.10.2
19:58:04 <bitemyapp> -rwxrwxr-x    1 callen 1.2M Sep 19 21:57 hello
19:58:04 <bitemyapp> -rw-rw-r--    1 callen  614 Sep 19 21:57 hello.hi
19:58:04 <bitemyapp> -rw-rw-r--    1 callen   51 Sep 19 21:57 hello.hs
19:58:04 <bitemyapp> -rw-rw-r--    1 callen 2.9K Sep 19 21:57 hello.o
19:58:08 <bitemyapp> module Main where
19:58:09 <bitemyapp> main = putStrLn "Hello, world!"
19:58:34 <amicuscuriae> my next question, if since I presume it is going to be the smallest size... until when the size would be about ~1 MB only? I guess I can write a whole Cli based Unit Converter it would still be about the same right?
19:58:56 <Shockk> curious question; is there currently any work being done on a compiler without a garbage collector, like JHC for example?
19:58:59 <bitemyapp> GHC 7.6.3: -rwxrwxr-x    1 callen 1.1M Sep 19 21:58 hello
19:59:06 <cmccann> amicuscuriae: anyway, if you want a fair comparison try writing hello world in Java and then compare the size of the output plus the size of the entire JVM to your Haskell program :P
19:59:15 <cmccann> (ok, that's not exactly fair, but closer)
19:59:27 <bitemyapp> GHC 7.8.4: -rwxrwxr-x    1 callen 1.2M Sep 19 21:58 hello
20:00:01 <amicuscuriae> 1 MB for Hello World is bad, since we can have 7zip in about 1 MB right?
20:00:07 <kristof> Shockk: You'd have to manage your memory explicitly or not manage it at all, since Haskell does not track linear types or anything.
20:00:08 <bitemyapp> running strip dropped it from 1.2MB to 800 kb
20:00:26 <amicuscuriae> bitemyapp, you human?
20:00:31 <kristof> no
20:00:33 <kristof> he is a bot
20:00:33 <bitemyapp> amicuscuriae: some would argue against that.
20:00:38 <amicuscuriae> ok
20:00:39 <amicuscuriae> :)
20:00:41 <bitemyapp> amicuscuriae: I think I'm a bear that owns a dog.
20:00:57 <bitemyapp> http://bitemyapp.com/
20:01:00 <bitemyapp> see? bear.
20:01:05 <amicuscuriae> ok
20:01:06 <amicuscuriae> brb
20:01:11 <amicuscuriae> I need to do some laundry
20:01:17 <bitemyapp> anyway, that is your binary size public service announcement.
20:01:34 <bitemyapp> you can get it smaller, I'm not sure why you'd care.
20:02:27 <Shockk> kristof: I think JHC compiled the Haskell code to C with either stack or manual dynamic memory allocation for things, I can't remember 
20:02:44 <Shockk> but I tried that fairly recently (within the last 3 months) and it broke on really simple code
20:03:52 <geekosaur> last I saw, it had experimental garbage collection
20:04:29 <kristof> Luckily, the runtime is a fixed, not variable cost.
20:04:53 <Shockk> like I think this is the code I used
20:04:54 <Shockk> https://gist.github.com/shockkolate/03b1db7a5e9623ab75ac
20:05:24 <Shockk> with jhc, I compiled, entered '1' and hit return and it output
20:05:26 <Shockk>  + 2 =  + 2 = 3
20:06:48 <Shockk> I think I looked into the generated C source at the time
20:07:39 <Shockk> is hard to remember but I think in the generated code, the putStrLn had been generated as two separate calls to putStr, but each output exactly the same string
20:07:44 <Shockk> the " + 2 = "
20:08:34 <Big_G> Why does having an IO String not print but putStrLn which returns an IO String print?
20:08:51 <geekosaur> ???
20:08:58 <geekosaur> putStrLn does not produce an IO String
20:09:05 <geekosaur> :t putStrLn
20:09:06 <lambdabot> String -> IO ()
20:09:35 <Big_G> geekosaur, Oh, I was thinking of getLine
20:10:20 <Big_G> If I returned an IO (), would it automatically print?
20:11:02 <Shockk> that depends entirely on what IO action specifically you're using
20:11:38 <geekosaur> Big_G, no
20:12:01 <geekosaur> and getLine doesn't "print" anything either. the terminal emulator echoes your input
20:12:16 <geekosaur> try it with "stty -echo" sometime
20:12:18 <Big_G> Shockk, What are the kinds of IO Actions? Should that be encapsulated in an IO () somehow?
20:12:26 <geekosaur> ("stty echo" to reverse it)
20:12:33 <Lokathor> sadly the state of haskell on ARM and also the large binaries that GHC makes cause haskell to be slightly rpi unfriendly
20:12:58 <geekosaur> Big_G, the type has nothing to do with what an IO action does. the IO action itself determines what it does
20:13:12 <Shockk> geekosaur: interesting, today I learned
20:13:50 <Shockk> Lokathor: I was thinking about it in relation to running Haskell code on my Rasperry Pi systems, yes
20:13:53 <Lokathor> Big_G, you're confusing the differnce between having an IO action and exeucting that IO action
20:13:55 <geekosaur> ...this may not work in ghci because it uses a fancy line editor which takes over most terminal functions itself
20:14:08 <geekosaur> (much as readline does in bash)
20:15:13 <GitGud> sup
20:15:26 <Shockk> hmm, does anyone know if GHC's generated C-- code has garbage collection already or if that's done at the backend compilation stage?
20:16:04 <Big_G> Lokathor, What is the difference? My understanding is that those actions are automatically run
20:16:08 <MarcelineVQ> At a complete guess I would think gc is done by the linked runtime
20:16:26 <geekosaur> garbage collection is a function of the runtime, not of the generated code
20:16:33 <Shockk> oh
20:16:47 <geekosaur> it happens at timer ticks or as a fallback when memory is allocated
20:17:28 <Lokathor> Big_G, if this were C or Java you'd be correct. In haskell though an action isn't always run right away. (putStrLn "foo") makes an IO () value, but unless it's in your 'main' action (or an action that it uses) then it won't execute
20:17:36 <Shockk> hmm, is there a flag to have ghc output its C-- representation?
20:17:57 <dolio> Shockk: -ddump-cmm?
20:18:04 <Shockk> ooh, thanks
20:18:22 <Big_G> Lokathor, How do I make it execute then? All the actions I've done have been in Main
20:19:20 <Shockk> oh, ouch
20:19:29 <Shockk> dolio: is there a way to redirect that to a file?
20:19:55 <Shockk> it outputs to stdout or stderr (idk which) along with the rest of the compilation output
20:20:09 <Lokathor> Big_G, things in main execute as it executes through main. for example, put the line (let test = purStrLn "foo") in your main, but then *don't use* test. You'll see that since it doesn't need test's result and evaluate it, it never prints "foo"
20:20:38 <Shockk> aha, -ddump-to-file
20:20:57 <ttt_fff> is there a way to tell "cabal repl" 's :r to also rebuild alex/happy files?
20:21:06 <ttt_fff> i.e. "cabal build" knows how to auto exec alex/happy on *.x/*.y
20:21:11 <ttt_fff> is there a way to do this also from inside a "cabal repl" ?
20:21:18 <geekosaur> no
20:21:39 <geekosaur> cabal repl can't rewire ghci to do extra stuff on :l or :r
20:21:45 <geekosaur> (neither can stack ghci)
20:22:03 <ttt_fff> okay, is there a different command I can do inside of "cabal repl"
20:22:10 <ttt_fff> which will also exec alex/ahppy ?
20:22:36 <lpaste_> Lokathor pasted “Big_G look at this example” at http://lpaste.net/141347
20:22:46 <Cooler> how are functors different from map?
20:23:13 <Big_G> Lokathor, Will do. brb
20:23:15 <Lokathor> Cooler, map works for only a List, a Function can be a thing other than a List though
20:23:36 <Lokathor> Functor*
20:24:03 <Big_G> Could you do a more complex example? I understand how it works in main but not in other parts of code
20:24:23 <Lokathor> Cooler, so fmap is the more generic version, and it take the concept of "mapping" and extends it out to things of other shapes, basically
20:24:40 <Cooler> like trees?
20:24:45 <Lokathor> yes exactly
20:25:22 <Lokathor> now, for some of the functor instances that explanation isn't quite right, but those are a little more esoteric
20:25:37 <mniip> Cooler, more than just shapes
20:25:49 <mniip> besides lists, trees, maybes, eithers
20:25:53 <mniip> you've got functions
20:25:53 <Cooler> so functors are just map for data structures other than lists?
20:25:56 <mniip> IO actions
20:26:29 <geekosaur> not necessarily data structures. you can fmap over monadic actions
20:26:30 <mniip> those are functors too
20:26:40 <Lokathor> yeah not just shapes
20:26:41 <geekosaur> which may or may not be data structures (e.g. IO)
20:27:09 <bitemyapp> Is there a nicer way to "repeat" values from a generator without lifting and tupling?
20:27:19 <bitemyapp> referring to quickCheck and forAll
20:27:28 <Shockk> hmm, took me a while to decipher the meaning of the C-- dump but it seems to dump the C-- at different stages of compilation and at final output
20:27:40 <bitemyapp> quickCheck $ forAll (liftA3 (,,) g g g) $ \(a, b, c) -> f a (f b c) == f (f a b) c
20:27:44 <bitemyapp> I'd like a nicer way to do that ^^
20:27:58 <bitemyapp> the alternating forAll / lambdas getting repeated irritates me.
20:29:07 <Lokathor> Big_G, what sort of other example would you like?
20:30:20 <Lokathor> bitemyapp, i'm not sure what you want the type signature to be there
20:30:46 <mniip> bitemyapp, replicateM
20:30:48 <Welkin> bitemyapp: wrap it in a newtype and define a monad instance for it?
20:31:22 <bitemyapp> Welkin: normally that'd be the advice I give others but this is getting into "on the principle of the thing" territory.
20:31:52 <mniip> replicateM 3 g
20:31:57 <Lokathor> in what way does replicateM not work here, is what i'm wondering.
20:31:57 <mniip> \[a, b, c] -> ...
20:33:18 <bitemyapp> well, now I have to write a partial function.
20:34:06 <bitemyapp> doesn't typecheck.
20:34:21 <mniip> :t replicateM
20:34:23 <lambdabot> Monad m => Int -> m a -> m [a]
20:34:25 <Lokathor> bitemyapp, what is the type signature you need?
20:34:33 <mniip> should be ok
20:34:54 <bitemyapp> quickCheck $ replicateM 3 (forAll g) $ \[a, b, c] -> f a (f b c) == f (f a b) c
20:35:04 <bitemyapp> have I missed something?
20:35:11 <mniip> what no
20:35:16 <mniip> forAll (replicateM 3 g)
20:35:30 <mniip> also it's not partial if it's an obvious invariant :P
20:35:33 <bitemyapp> ah right there we go.
20:35:39 * bitemyapp hand wobble
20:35:55 <mniip> lol
20:36:17 <bitemyapp> it's fine
20:36:33 <Lokathor> Cooler, http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
20:36:49 <stapler> can someone explain some black magic thats being used in sqlite-simple to me please?
20:37:06 <bitemyapp> stapler: which? The record marshalling stuff?
20:37:13 <stapler> bitemyapp: sort of
20:37:16 <stapler> the uh "field" function
20:37:22 <stapler> like uh 
20:37:25 <stapler> instance FromRow TestField where
20:37:25 <stapler>   fromRow = TestField <$> field <*> field
20:38:36 <Shockk> magic in what sense?
20:39:05 <stapler> how does field do what it does there
20:39:10 <Shockk> ahh
20:39:34 <Shockk> I can't answer what field actually does, I've only looked at the types over the last 2 minutes 
20:40:47 <geekosaur> think like a parser?
20:41:12 <geekosaur> "parse the next field out of the data stream and return it" and then using Applicative to combine those
20:41:25 <Shockk> on a side note is there no cleaner way to do things like defining instances for tuples of increasing sizes?
20:41:42 <Shockk> like all the instances at https://hackage.haskell.org/package/sqlite-simple-0.4.9.0/docs/Database-SQLite-Simple.html#t:FromRow
20:42:01 <geekosaur> I doubt that there is
20:42:03 <Shockk> I also think back to this too https://hackage.haskell.org/package/ghc-prim-0.4.0.0/docs/GHC-Tuple.html
20:42:06 <geekosaur> because tuples
20:42:22 <geekosaur> tuples are not recursive data structures
20:42:59 <geekosaur> you cannot recurse or iterate over the elements (except via some generics hack like lens or syb)
20:43:31 <Shockk> hmmm.. mhm
20:43:48 <pavonia> What's the best way to hide a global state in the Bot type from http://hackage.haskell.org/package/fastirc-0.2.0/docs/Network-FastIRC-Session.html that can be used from within all of the event handlers of onEvent? I could probably wrap an extra ReaderT around that stores an MVar, but maybe there's another/better way?
20:45:16 <lpsmith> stapler, field is overloaded;  so based on the return type your program is expecting,  it'll perform type checking for that Haskell type.
20:45:43 <lpsmith> Since it's an applicative,  it can consume one row,  and then next one can consume the next row,  etc.
20:46:10 <lpsmith> So you aren't actually calling the same function over and over again,  as the overloading is resolved at compile time.
20:46:41 <amicuscuriae> guys Hello World Linux binary in C = ~10 kb ; in Haskell = 1 MB; how is Haskell modern and efficient and memory caring over C/C++ then?
20:47:20 <mniip> no one ever claimed that
20:47:36 <amicuscuriae> ok
20:47:37 <amicuscuriae> :)
20:47:38 <amicuscuriae> heh
20:47:44 <mniip> haskell has a huge RTS, and enormously sized data structures
20:47:45 <glguy> 12K Sep 19 20:47 Main*
20:47:51 <Shockk> also, binary size doesn't have anything to do with how modern Haskell is
20:48:07 <glguy> When you dynamically link Haskell executables like you do C executables they are tiny, too
20:48:07 <amicuscuriae> Shockk, it does, we get 7zip for Windows in 1 MB
20:48:07 <kadoban> It's far more modern. The rest sounds like stuff that's not true though. "What size are my binaries?" is a /really/ weird test.
20:48:13 <mniip> amicuscuriae, by the way
20:48:14 <geekosaur> again?
20:48:20 <glguy> also executable size is generally irrelevant to why people use Haskell
20:48:23 <mniip> I can write a hello world binary in about 400 bytes
20:48:25 <geekosaur> didn;'t we just discuss this half an hour ago?
20:48:28 <mniip> how is C++ modern and efficient
20:48:44 <amicuscuriae> mniip, How? Tell me!
20:49:01 <ari``> hi
20:49:04 <mniip> well you just gotta write a linker script and pass some extra linker options
20:49:06 <amicuscuriae> mniip, but it is default Compiled lang choice and has a lot of tutorial and books out there?
20:49:08 <mniip> to get past the page size limit
20:49:10 <amicuscuriae> Easy to learn?
20:49:10 <Shockk> I can write hello world in x86 assembly that fits in under 200 bytes but it's hardly modern
20:49:15 <amicuscuriae> heh
20:49:15 <ari``> any of you guys (or gals) also do Prolog?
20:49:17 <geekosaur> I thought the record for that was like 58 bytesby abusing unused parts of the ELF header?
20:49:26 <mniip> Shockk, will the ELF image fit in 200 bytes too
20:49:31 <amicuscuriae> But why is Haskell doing hello world in 1 MB!
20:49:36 <mniip> geekosaur, that was the instantly terminating program
20:49:38 <kadoban> amicuscuriae: Who cares?
20:49:42 <Shockk> mniip: hmm no idea
20:49:44 <amicuscuriae> kadoban, I do
20:49:45 <glguy> amicuscuriae: Because you're using a statically linked executable
20:49:49 <kadoban> amicuscuriae: Why do you care?
20:49:49 <mniip> amicuscuriae, because haskell has a huge RTS
20:49:51 <KaneTW> amicuscuriae: because it needs a runtime system and links statically
20:49:55 <amicuscuriae> :/
20:49:57 * amicuscuriae cries
20:49:59 <KaneTW> the first part is just how the language works
20:50:00 <geekosaur> ok, we need to have the same discussion we did half an hour ago until amicuscuriae hears what they want?
20:50:01 <glguy> amicuscuriae: and like it said, that's optional
20:50:12 <rcyr> amicuscuriae: The same thing happens with C... if you statically link the C library.
20:50:15 <kadoban> amicuscuriae: Not even a rhetorical question … seriously, why do you care?
20:50:22 <ari``> amicuscuriae,  the runtime?
20:50:24 <KaneTW> the second part is optional but dynamic linking really isn't that good
20:50:28 <amicuscuriae> omg
20:50:54 <ari``> this is the price you pay for conveinence
20:51:01 <amicuscuriae> geekosaur, how do I not use Statically linked ?
20:51:01 <geekosaur> (1) strip the debug information and it gets smaller. (2) there is a runtime. C is close to the metal and doesn't need a runtime. C++ has a runtime but it's usually linked shared (whch has its own problems); I think ghc usually links it statically
20:51:05 <ari``> if you make a VB exectubale it might be like 30 kb
20:51:13 <ari``> but the runtime will be 500 kb or whatever
20:51:20 <ari``> I dont know anymore, havent done VB in like a decade
20:51:26 <amicuscuriae> ok
20:51:34 <KaneTW> amicuscuriae: even a basic hello world with static linking is 725kb in C 
20:51:43 <rcyr> Exactly.
20:51:53 <Lokathor> amicuscuriae, didn't we answer your same question like 20 minutes ago?
20:51:55 <geekosaur> you build a custom ghc with shared base library
20:52:04 <Lokathor> amicuscuriae, it's the garbage collector and stuff
20:52:05 <amicuscuriae> Ok
20:52:07 <KaneTW> and be prepared for a ton of problems
20:52:09 <ari``> amicuscuriae,  if you want small executables then do C
20:52:09 <glguy> Or you use the -dynamic flag
20:52:14 <ari``> or ASM
20:52:24 <amicuscuriae> glguy, -dynamic flag with ghc?
20:52:28 <ari``> But of course no one does ASM except masochists
20:52:31 <Shockk> Lokathor: that was a different person
20:52:31 <KaneTW> ghc is not designed for size constrained applications
20:52:59 <geekosaur> [20 02:58] <amicuscuriae> my next question, if since I presume it is going to be the smallest size... until when the size would be about ~1 MB only? I guess I can write a whole Cli based Unit Converter it would still be about the same right?
20:53:00 <ari``> Try making an app in ASM
20:53:01 <Shockk> ari``: I wrote in ASM when I was doing a bootsector though
20:53:03 <geekosaur> looks like the same person to me
20:53:04 <ari``> like they did 40 years ago
20:53:07 <Lokathor> Shockk, nope, scross back :P
20:53:08 <ari``> you will hate programming
20:53:11 <ari``> and become an artist
20:53:15 <glguy> amicuscuriae: yeah, which is how you get a 12k Haskell hello world
20:53:23 <ari``> shockk, well sure, for those types of things
20:53:28 <ari``> but not app development right?
20:53:35 <amicuscuriae> glguy, What are the loss?
20:53:37 <Lokathor> ari``, I don't do prolog but i've dabbled in Erlang, which has prolog-like syntax. that close enough?
20:53:39 <Shockk> oh, perhaps not
20:53:49 <ari``> Lokathor,  yes sir it is!
20:54:00 <ari``> I learned that the first erlang compiler was written in prolog!
20:54:03 <glguy> amicuscuriae: All the normal dynamic linking problems, you have to make sure all the libraries you need are on the machine you want your program to run on on your own
20:54:07 <ari``> And I just started learning prolog last week
20:54:14 <kadoban> Err, prolog is close to assembly, or did I miss a step in the conversation?
20:54:22 <amicuscuriae> glguy, ok I get it
20:54:29 <KaneTW> if you remove a dynamicially linked library (update or whatever) your program breaks
20:54:29 <geekosaur> C is pretty much always going to win compiled code size wars, given that few bother with asm these days
20:54:32 <Shockk> although I know someone who graduated in computer games a few years back who would apparently look through some of the assembly of the code he wrote to try and optimize things further 
20:54:42 <KaneTW> that's pretty normal
20:54:51 <ari``> kadoban,  nope I dont see where anyone said prolong is like assembly
20:54:51 <geekosaur> of course, C requires library functions just to do simple string manipulation
20:54:58 <ari``> sorry if thats the impression I gavce
20:54:59 <kadoban> Okay, must have misread.
20:55:30 <ari``> but anyway I a typical computer scientist
20:55:33 <ari``> got a BS in CS
20:55:40 <levi> C requires library functions to allocate heap memory. :)
20:55:41 <ari``> mostly done imperitive langs my whole career
20:55:44 <geekosaur> it's a very low level language. haskell is a very high level language and requires more support --- not to mention that it is non0-strict and therefore the runtime needs a graph reduction engine built in. and garbage collection, where C makes you do manual memory management
20:55:46 <ari``> I studied functional langs
20:55:53 <ari``> now I am trying to understand logical langs
20:56:03 <ari``> and actually I think prolog is harder to grasp than haskell
20:56:06 <ari``> belieeve it or not
20:56:12 <levi> ari``: Check out minikanren
20:56:25 <ari``> levi, ah ok..thanks I will
20:56:30 <amicuscuriae> glguy, it gives an error Could not find module "Prelude"
20:56:44 <levi> It's sort of a minimal logic language
20:57:10 <glguy> amicuscuriae: you'll have to have the dynamic libraries installed
20:57:40 <Shockk> levi: that's more a limit  of the design of an operating system though; you can't allocate memory except through the interface the kernel provides through the library functions
20:57:50 <amicuscuriae> glguy, how? kindly help me
20:57:57 <glguy> amicuscuriae: Did you install GHC via your OS package manager?
20:58:08 <Shockk> but sorry, now I'm not on the topic of haskell any more
20:58:19 <amicuscuriae> glguy, yep 
20:58:36 <glguy> amicuscuriae: OK, hopefully they were nice enough to package those, too! You'll have to check.
20:58:51 <levi> Shockk: It's part of the C language specification. It *could* have been included in the core language (as it is in C++ via 'new') but instead it's part of the standard library.
20:59:11 <amicuscuriae> glguy, Whaat?
20:59:36 <glguy> amicuscuriae: Some distributions split things up a lot and have -dev packages and similar
20:59:56 <Shockk> levi: well I just meant if X operating system was designed so you could allocate memory by.. say, writing bytes to a specific location in memory, you could do that 
21:00:59 <glguy> amicuscuriae: You'll have to ask someone who has experience with your package manager how they split things up, a normal GHC install isn't split up on its own
21:01:00 <mniip> Shockk, hmm, I hit 432 bytes
21:01:46 <Shockk> small
21:02:26 <Shockk> oh, I had a question I wanted to ask last night
21:02:34 <Welkin> god damn
21:02:35 <kristof> Is there a kind of bind that works for monad homomorphisms?
21:02:37 <Shockk> I just remembered it, is about bimaps in haskell
21:02:41 <Welkin> there is o much boilerplate in opaleye
21:03:01 <Welkin> and so many duplicated types and names with an extra letter pre/appended
21:03:01 <kristof> ...well, I guess that would just be homo . bind
21:03:16 <Welkin> it feels like going backwards when coming from PErsistent
21:03:38 <Shockk> I looked up and found this the other day and have been thinking about it in relation to something I'm writing
21:03:39 <Welkin> I feel like this could have been avoided with template haskell
21:03:40 <Shockk> https://hackage.haskell.org/package/bimap-0.3.0/docs/Data-Bimap.html
21:04:00 <Welkin> at least for schema definitions
21:04:56 <amicuscuriae> glguy, hmm I know ghc-dynamic is to be installed
21:05:05 <amicuscuriae> mniip, hit bytes for what?
21:05:18 <mniip> amicuscuriae, for a helloworld executable
21:05:23 <Shockk> although I don't know that it would work exactly as I'd like it to; basically I'm coming from thinking in terms of the Bimap library that Boost (C++ thing) provides, in that the 'left' and 'right' sides of the bimap have some representation/container 
21:05:52 <Shockk> but in addition, a 'type of relation' can be used for each side which is like set_of or multiset_of
21:05:55 <mniip> I can bring it down to 235 bytes by hand
21:05:58 <mniip> but not by compiler
21:06:33 <amicuscuriae> mniip, in what? Haskell? 
21:06:56 <geekosaur> "not by compiler" so presumably writijng assembly language
21:07:03 <Shockk> those combined allow things like being able to map from something unique on the left to multiple things on the right, as well as map from *each* of those things on the right back to the unique thing on the left
21:07:05 <geekosaur> if it's in Haskell thenit si going through as compiler
21:07:08 <amicuscuriae> glguy, ok even if I do statically linked lib .. would the size of binary increase if I develop a basic Unit Converter? I don't think it would more than few kbs
21:07:12 <mniip> amicuscuriae, no
21:07:13 <Shockk> and I wondered if there's anything like that in haskell
21:07:24 <mniip> geekosaur, I /was/ writing in assembly
21:07:31 <Shockk> that provides some bidirectional map to that level of flexibility
21:07:33 <mniip> the point was to get the toolchain to strip all the stuff for me
21:07:39 <amicuscuriae> mniip, Is Assembly high level?
21:07:43 <mniip> no
21:08:00 <amicuscuriae> then why are you trying to?
21:08:17 <geekosaur> ...
21:08:18 <amicuscuriae> we are talking about different level of lang here
21:08:38 <geekosaur> yes, but you were complaining that high level haskell code ends up larger than low level C code
21:08:50 <geekosaur> we are talking about different level of lang here
21:08:55 <amicuscuriae> because I did not know about statically linked vs Dynamically linked
21:08:59 <geekosaur> asm gets even smaller than C
21:09:02 <amicuscuriae> now I do
21:09:13 <geekosaur> C++ is somewhere in between since it's a low level language pretending to be a higher level language
21:09:44 <amicuscuriae> glguy, What size you got with dyn?
21:09:59 <geekosaur> (some aspects of C++ still seem to think that it is cfront, the original preprocessor that output C code from C++ code)
21:10:16 <amicuscuriae> does haskell have a runtime package?
21:10:36 <levi> Haskell has a significant runtime; I don't know if you'd call it a 'package'.
21:10:57 <kristof> what a bizarre question
21:11:34 <kristof> The runtime I believe is written in c-- so you'd have to be writing in that to even call it as a library
21:12:28 <amicuscuriae> I got hello world in about 17.1 KB
21:12:35 <amicuscuriae> now
21:12:40 <levi> It's a GHC-specific variant of C--, too.
21:12:40 <amicuscuriae> with -dynamic
21:13:38 <kadoban> Still missing why a 1 MB compared to 17 KB executable even matters in any sense.
21:13:41 <MarcelineVQ> You still need to ship your program with the libs it dyamiclly links to unless you're sure the next place you use it has the same libs, so you're really not saving any effort
21:13:45 * hackagebot json-autotype 1.0.9 - Automatic type declaration for JSON input data  https://hackage.haskell.org/package/json-autotype-1.0.9 (MichalGajda)
21:14:03 <geekosaur> the runtime is built into libHSbase, I believe (which is why you can't install a separate base for ghc, it has to come with the compiler)
21:15:15 <geekosaur> (and the GHC.* modules depend on direct access to the runtime, and Prelude pulls a lot of basic stuff from the GHC modules --- notably IO and the low level implementation of the high level basic types Int, Integer, Float, Double, etc.)
21:16:42 <amicuscuriae> kadoban, Size and space ; but I want to know if the size would future increase than 1 MB with the same rate with slight more complex apps?
21:16:47 <amicuscuriae> like a Unit Converter?
21:16:58 <amicuscuriae> I think it should not go beyond 1.3 MB
21:17:10 <geekosaur> did you ever run "strip" on your program?
21:17:23 <Shockk> 1.3 MB is oddly specific
21:17:23 <amicuscuriae> geekosaur, how do I do it?
21:17:26 <geekosaur> ghc produces a lot fo (currently useless) debug information
21:17:26 <amicuscuriae> :))
21:17:43 <amicuscuriae> <-- complete idiot guide version 
21:17:53 <kadoban> amicuscuriae: "the same rate". What rate? You have one data-point.
21:18:00 <geekosaur> if "foo.hs" compiled to a binary "foo" then run "strip foo"
21:18:09 <kadoban> amicuscuriae: And if that's what you're interested in … I'm not sure how any of this is actually relevant.
21:18:32 <geekosaur> I think sommone reported that their 1.3MB output dropped to quite a bit less last time you asked this
21:18:45 <amicuscuriae> lol
21:18:46 <amicuscuriae> :)\
21:18:59 <geekosaur> oh, no, not as much as hoped
21:19:00 <geekosaur> [20 02:59] <bitemyapp> running strip dropped it from 1.2MB to 800 kb
21:19:06 <geekosaur> so only about 1/3
21:19:16 <geekosaur> (removed 1/3 that is)
21:19:25 <amicuscuriae> why is stripping taking some time?
21:19:29 <geekosaur> and with your version of ghc, what it removes is completley useless
21:19:46 <geekosaur> ... it should be fairly fast unless it's about to come back with a message saying how to install strip
21:20:04 <amicuscuriae> $ strip hey
21:20:08 <amicuscuriae> Nothing
21:20:12 <geekosaur> (ubuntu's magic look-for-uninstalled-program takes up to a minute to run in my experience, and that's on a machine with SSD root)
21:20:14 <amicuscuriae> but Not $ yet
21:20:29 <geekosaur> ???
21:20:36 <geekosaur> it won;'t say anything. just give you aprompt back
21:20:41 <amicuscuriae> no
21:20:42 <geekosaur> but the file should be smaller
21:20:48 <amicuscuriae> it is not giving me a prompt back
21:20:55 <amicuscuriae> Should i force Stop?
21:22:00 <geekosaur> control-=c I guess
21:22:04 <geekosaur> control-c
21:22:08 <amicuscuriae> I know that
21:22:08 <amicuscuriae> :)
21:22:11 <geekosaur> no idea why it would take so long, it's usually fast
21:22:14 <amicuscuriae> 9.5 KB!!!!
21:22:17 <amicuscuriae> yahhhhhhh
21:22:20 <geekosaur> er?
21:22:25 <amicuscuriae> I don't know what happened
21:22:32 <amicuscuriae> 17.1 KB to 9.5 Kb
21:23:04 <geekosaur> "strip" removes debugging symbols from a program
21:23:18 <geekosaur> (on some OSes it may remove more, but on Linux that's pretty much it)
21:23:19 <amicuscuriae> is that good are bad thing?
21:23:35 <geekosaur> you cannot sanely use a debugger on a ghc generated program
21:23:42 <geekosaur> becuase debuggers do not understand graph reduction
21:23:43 <mniip> yes you can
21:23:50 <mniip> actually you can
21:24:16 <mniip> it won't be of much help, but it gives rather sane results, given you're familiar with STG
21:24:18 <geekosaur> well, you can hget useful information of it crashed in an FFI call. I haven't found much useful otherwise since you don;t usually have things like stack frames
21:24:20 <Lokathor> would you have to use a ghc specialized debugger?
21:24:25 <mniip> there's even a gdb script on GHC trac
21:24:34 <amicuscuriae> Guys is leksah broken?
21:24:38 <geekosaur> ghc 7.10 has a start on some real debugging stuff and ghc8 will have the rest of it
21:24:42 <amicuscuriae> it won't show no results?
21:25:10 <mniip> https://ghc.haskell.org/trac/ghc/attachment/wiki/Debugging/CompiledCode/.gdbinit
21:25:14 <geekosaur> not sure anyone here actually uses leksah
21:25:36 <geekosaur> most people use emacs or vim with their respective haskell modes
21:25:38 <Welkin> what is planned for ghc 8 and when will it be released?
21:25:53 <amicuscuriae> geekosaur, ah
21:26:09 <amicuscuriae> I installed Atom too but it did not work well
21:26:09 <geekosaur> there's also a decent haskell plugin for sublime text
21:26:17 <amicuscuriae> omg 
21:26:20 <amicuscuriae> non-free software?/
21:26:21 <geekosaur> there used to be an eclipse plugin but last I heard it had been abandoned
21:26:24 <mniip> anyway, here comes 432-byte hello world https://bpaste.net/show/5528e294a9ca
21:26:27 <amicuscuriae> Against my principles
21:26:38 <amicuscuriae> I am looking into limetext.org
21:27:17 <amicuscuriae> doMetersToFeet 1 = Awesome I would start my book again now.. but I need a decent editor with autocompletetin first :/ 
21:27:32 <amicuscuriae> Leksah is awesome editor but I don't know hoow IDE stuff works in it
21:27:32 <geekosaur> Welkin, https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.0.1
21:28:05 <geekosaur> atom.io is alsp popular as someone mentioned. I'm a bit old-skool and stick to emacs for serious development
21:28:10 <mniip> >autocompletion
21:28:15 <mniip> >2015
21:29:10 <Lokathor> we use emacs and vim, our editing tech is firmly in the 1980s
21:29:26 <mniip> well, I use vim too
21:29:31 <mniip> but I can't stand autocompletion
21:29:38 <kadoban> Some exciting stuff in that GHC 8 list
21:29:39 <geekosaur> I did say I was old-skool
21:29:50 <stapler> mniip: have you ever used a good autocomplete
21:29:59 <geekosaur> gimme a break, I started programming in, er, 1978
21:30:01 <mniip> it's like you're speaking and then someone interrupts you
21:30:08 <Lokathor> kadoban, i can't make sense of most of the list :/
21:30:12 <stapler> mniip: good autocomplete is incredible
21:30:17 <SShrike> How do I setup a Haskell project with Cabal that compiles a Haskell library into a shared library that exports C functions?
21:30:17 <stapler> see: visual studio, eclipse
21:31:15 <kadoban> Lokathor: Some of it I can't either. But applicative do should be nice, overloaded record fields kinda cool if I like how it works in practice, and the call stack thing maybe? I'm not entirely sure what that one means, but sounds neat.
21:31:19 <mniip> I've  tried VS
21:31:20 <amicuscuriae> is purging leksah
21:31:22 <mniip> can't stand it
21:31:25 <stapler> mniip: what?!
21:31:33 <stapler> VS is the best development environment I have ever worked in
21:31:35 <geekosaur> call stack means that exceptions include actual usable backtraces
21:31:42 <amicuscuriae> mniip, why sir?
21:31:56 <stapler> I use c# when I'm not writing haskell
21:32:03 <stapler> which is frequently because I suck at haskell.
21:32:13 <geekosaur> overloaded record fields, iirc, will come with a basic thing but be easily extensible so you can e.g. hook lens into it
21:32:20 <mniip> stapler, vim + coreutils is the best development environment I have ever worked in
21:32:40 <mniip> well, plus gcc, binutils, make, and possibly other friends
21:32:42 <stapler> mniip: agree to disagree I suppose..
21:33:11 <Lokathor> kadoban, my guess is that overloaded record fields turns (kinda) a record field into a typeclass sort of deal
21:33:17 <kadoban> Oh MonadFail too, always nice getting some work towards that.
21:33:18 <geekosaur> yes
21:33:24 <geekosaur> autogenerated Has instances
21:33:49 <mniip> oh god
21:33:53 <mniip> autogenerated classes
21:33:57 <kadoban> I'll have to look into what that means. But I bet it'll be nice, even though how records work has never bothered me as much as it seems to bother others.
21:33:57 <geekosaur> basically fclabels' makeLenses built in, or overrideable with lens' version, etc.
21:33:59 <mniip> it's probably going to be something like
21:34:10 <mniip> Has_a9q_field_tz4
21:34:46 <mniip> field :: Has_a9q_field_tz4 a9w tz4 => a9w -> tz4
21:34:59 <Welkin> mniip: if you don't have to read it, then who cares?
21:35:02 <geekosaur> actually, I beliebve it uses type level strings
21:35:04 <Welkin> like with any metaprogramming
21:35:07 <Lokathor> kadoban, in the same way that (+) 2 3 dispatches correctly compared to (+) 2.5 3.5, getX myCreature will dispatch properly compared to getX myItem
21:35:10 <geekosaur> so you get something readable and comprehensible
21:35:20 <mniip> Welkin, you better hope you don't have to read it
21:35:31 <geekosaur> Has '"fieldname" or whatever the syntax for type level strings is
21:35:51 <mniip> just "fieldname"
21:36:09 <mniip> so you're telling me
21:36:21 <mniip> Has -> Symbol -> * -> * -> Constraint
21:36:26 <mniip> er
21:36:29 <mniip> Has :: Symbol -> * -> * -> Constraint
21:36:45 <geekosaur> something like that. I didn't read the details
21:37:18 <geekosaur> but they're trying to make it something that is sane, not something that produces incomprehensible type errors
21:38:48 <Welkin> so that means we won't need to name our field accessors things like `_userFirstName`
21:38:57 <Welkin> instead, `firstName`
21:39:03 <geekosaur> that is the intent, yes
21:39:09 <geekosaur> and it Just Works
21:39:53 <Shockk> Just Works | Nothing
21:40:02 <geekosaur> (you would of course have to turn on the extension to get that instead o old-style accessors)
21:40:05 <kadoban> XD
21:40:25 <geekosaur> IIRC there's also autogenerated pattern synonyms to go the other way
21:42:23 <geekosaur> (i.e. you don't *have* to use lens-style operators)
21:44:56 <amicuscuriae> geekosaur, mniip Have you ever tried Brackets or Lighttable?
21:46:12 <mniip> brackets?
21:46:15 <mniip> I use brackets: []
21:46:36 <amicuscuriae> [] is an empty list
21:46:37 <amicuscuriae> :)
21:46:47 <amicuscuriae> I like Texas Ranges
21:46:57 <amicuscuriae> or Ranges
21:47:03 <amicuscuriae> [2,4..100]
21:48:47 <amicuscuriae> mniip, brackets.io
21:49:44 <mniip> amicuscuriae, no idea what that is
21:50:26 <MarcelineVQ> it's just like atom
21:51:25 <amicuscuriae> oh
21:55:05 <ttt_fff> this has been surprisingly hard to google: how do I say, at the top of a file, with  pragma, "DISABLE ALL WARNINGS FOR THIS FILE" ?
21:58:47 * hackagebot json-autotype 1.0.10 - Automatic type declaration for JSON input data  https://hackage.haskell.org/package/json-autotype-1.0.10 (MichalGajda)
21:59:01 <kadoban> ttt_fff: Look in the GHC pragma documentation for how to specify GHC options, and then the command-line flag that turns off warnings (if there is one)
21:59:41 <ttt_fff> yeah
21:59:41 <ttt_fff> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/pragmas.html
21:59:46 <ttt_fff> I don't see "turn off all warnings"
21:59:49 <ttt_fff> yet I could have sworn I did this earlier today
22:00:28 <MarcelineVQ> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/options-sanity.html
22:01:02 <MarcelineVQ> -w appearantly so something like {-# OPTIONS_GHC -w #-}
22:01:53 <ttt_fff> MarcelineVQ: nice, thanks!
22:01:54 <MarcelineVQ> I agree that it was hard to find, but `man ghc` gave me the lead to check compiler options which lead to https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flag-reference.html which leads there
22:02:28 <MarcelineVQ> idk why you'd want warning off though :>
22:04:49 <ttt_fff> it's a file genrated by Blah.x
22:04:55 <ttt_fff> and the ile Alex generates, has lots and lots of warnings
22:39:33 <Shockk> would anyone be able to briefly explain covariance and contravariance to me?
22:40:43 <greg> lo
22:44:38 <mniip> Shockk, covariance is when you expect a generic thing, and therefore you can be given a more specific one
22:44:56 <mniip> contravariance is when you're expected to provide a specific thing, so you can give a more generic one instead
22:45:40 <Shockk> in the context of Haskell, would that be like a function expecting.. say, a Fractional, and I give it a Floating or something?
22:46:01 <Shockk> for covariance, that is
22:47:40 <Shockk> no, sorry, ignore that question it doesn't really make sense
22:47:57 <ttt_fff> ignored
22:48:01 <Shockk> thanks
22:54:31 <Shockk> hmm, is there any way in Haskell to make some data type in Haskell which can be created from some variable amount of type arguments, like ermmm.. for example the ability to construct a type such as:  NMap Integer Char String NMapEnd or something
22:54:47 <spacekitteh> heterogenous lists
22:55:06 <Shockk> where NMap would be an n-directional map like a unimap or bimap or trimap etc
22:57:29 <Shockk> spacekitteh: isn't that for storing a bunch of values of various types in a single list type?
22:58:12 <cmccann> Shockk: you can do that with DataKinds and lots of black magic
22:58:13 <spacekitteh> have a look at how they're implemented though
22:58:23 <Shockk> ahh
22:58:33 <cmccann> Shockk: the type would end up looking like NMap '[Integer, Char, String]
22:58:50 <Shockk> hmm, is that TH?
22:58:54 <cmccann> no
22:58:56 <cmccann> it's a list of types
22:59:12 <Shockk> oh
22:59:17 <cmccann> like a list of values
22:59:25 <Shockk> ahh, the ' is part of that syntax?
22:59:31 <cmccann> :k '[Integer, Char, String]
22:59:32 <lambdabot> [*]
22:59:41 <Shockk> interesting
22:59:52 <cmccann> yeah, that means it's lifted up one level, basically
23:00:21 <cmccann> Shockk: so [Integer] is a list of integers, while '[Integer] is a one-element list containing the type Integer
23:00:59 <cmccann> anyway, that's how you'd write the type in type signatures. implementing code to do stuff is slightly more complicated.
23:01:18 <Shockk> I can imagine
23:01:21 <Shockk> I can only imagine*
23:01:41 <cmccann> Shockk: look at http://hackage.haskell.org/package/vinyl if you want to see it in action
23:01:56 <Shockk> is that ' syntax specific to that kind of usage there? i.e. with []?
23:02:01 <cmccann> no
23:02:03 <Shockk> or can it be used with any type?
23:02:16 <cmccann> not *any* type, at least not yet afaik
23:02:23 <Shockk> er, any kind? I don't know what the correct terminology would be 
23:02:46 <Shockk> ahh
23:03:25 <Shockk> so is that what DataKinds is or is this something different to that?
23:03:34 <Shockk> (so I know what I can google)
23:03:39 <cmccann> DataKinds, yes
23:03:58 <Shockk> thanks, time to research :D
23:04:24 <cmccann> but yeah, all simple data types can be promoted, where "simple" is defined as according to some rules  I don't remember
23:05:02 <Shockk> ohh, is that to do with this?:
23:05:11 <Shockk> "GHC automatically promotes every suitable datatype to be a kind, and its (value) constructors to be type constructors"
23:05:20 <cmccann> yes
23:06:03 <cmccann> you also get type-level natural numbers and strings, which have special support from GHC
23:06:34 <Shockk> ooh
23:06:37 <cmccann> vinyl uses that for its extensible records, so that the type of a vinyl record includes a list of field names/types
23:06:38 <Shockk> that sounds interesting
23:07:28 <Shockk> out of interest is there a way to tell GHC to make something a DataKind explicitly? (and error if it fails)
23:07:34 <Shockk> rather than just making ones it can, ones
23:07:51 <cmccann> doing anything too complicated is a headache because GHC's cleverness is distinctly finite and you have to hold its hand and explain why things should type check
23:08:02 <Shockk> lol
23:08:10 <mniip> Shockk, yes
23:08:26 <cmccann> well, every type is promoted implicitly if possible. if you try to use one that can't be promoted, GHC will whine about it I'm sure
23:08:42 <Shockk> oh right
23:08:46 <cmccann> :k 'ReaderT
23:08:48 <lambdabot>     Data constructor ‘ReaderT’ comes from an un-promotable type ‘ReaderT’
23:08:48 <lambdabot>     In a type in a GHCi command: ReaderT
23:09:03 <Shockk> :k 'Map
23:09:04 <lambdabot>     Not in scope: data constructor ‘Map’
23:09:04 <lambdabot>     Perhaps you meant one of these:
23:09:04 <lambdabot>       variable ‘map’ (imported from Data.List),
23:09:08 <Shockk> oops
23:09:23 <mniip> :k 'Int
23:09:24 <lambdabot>     Not in scope: data constructor ‘Int’
23:09:24 <lambdabot>     Perhaps you meant one of these:
23:09:24 <lambdabot>       ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
23:09:42 <mniip> :k (1 :: 'Int)
23:09:43 <lambdabot> parse error on input ‘'’
23:09:49 <mniip> >:(
23:09:52 <Shockk> lol
23:09:57 <mniip> :k (1 :: Int)
23:09:58 <lambdabot>     ‘Int’ of kind ‘*’ is not promotable
23:09:58 <lambdabot>     In the kind ‘Int’
23:09:58 <lambdabot>     In a type in a GHCi command: (1 :: Int)
23:11:14 <forgottenone> hi what is lens exactly, can someone explain or provide a links a haskell newbie can understand?
23:12:03 <shachaf> lens the library?
23:12:40 <lolisa> SPJ on skill matter had a talk, go search for it it's very good
23:12:57 <Shockk> https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation
23:12:58 <forgottenone> shachaf: tbh i'm not sure, i encounter in haskell reddit frequently
23:13:07 <Shockk> that's what I watched before I got into lenses
23:13:22 <Shockk> you need to register/login before you can watch
23:13:24 <cmccann> forgottenone: https://github.com/ekmett/lens/wiki/Overview if you don't want to watch a video
23:13:57 <forgottenone> ok,thanks for all answers
23:17:56 <Shockk> cmccann: so could I write some type that has a kind of [*] -> * ?
23:19:22 <cmccann> @let data Foo (a :: [*]) = Foo
23:19:23 <lambdabot>  Defined.
23:19:25 <cmccann> :k Foo
23:19:26 <lambdabot> [*] -> *
23:20:46 <Shockk> hmm so if I have a type of Foo '[Integer, String], the type (..kind?) variable a is a list of Integer and String?
23:21:52 <cmccann> :t Foo :: Foo [Int, Bool]
23:21:53 <lambdabot> Foo '[Int, Bool]
23:22:02 <cmccann> do note that there are no values of a type with kind [*]
23:22:16 <cmccann> :t undefined :: '[Int, Bool]
23:22:17 <lambdabot>     Expected a type, but ‘'[Int, Bool]’ has kind ‘[*]’
23:22:17 <lambdabot>     In an expression type signature: '[Int, Bool]
23:22:17 <lambdabot>     In the expression: undefined :: '[Int, Bool]
23:22:26 <Shockk> :k undefined
23:22:27 <lambdabot> Not in scope: type variable ‘undefined’
23:22:38 <Shockk> oh
23:22:40 <Shockk> I'm silly
23:23:08 <cmccann> the best thing to do is just try it out with GHC
23:23:10 <cmccann> tinker around
23:23:22 <cmccann> you can try some things in a /msg to lambdabot but that only goes so far
23:23:27 * Shockk nods
23:23:54 <cmccann> and again, you can look at vinyl for an example of putting this stuff to use
23:24:05 <Shockk> hmm one more quick question, would a data type like Foo there be useful for anything simple?
23:24:28 <cmccann> yeah, but not by itself
23:24:28 <mniip> [08:17:11] <cmccann> do note that there are no values of a type with kind [*]
23:24:30 <mniip> blasphemy
23:24:36 <mniip> error# has an open kind
23:24:56 <cmccann> mniip: anything with magic hash doesn't count
23:25:09 <mniip> error has a wired in open kind too
23:25:20 <Shockk> :i error
23:25:30 <Shockk> :(
23:26:16 <mniip> well error is complicated
23:26:17 <Shockk> thanks for the answers both of you
23:27:20 <Lokathor> does haskell have a user-friendly hot-loading-code system?
23:28:34 <mniip> not user-friendly
23:28:37 <mniip> it's just a "hot load"
23:29:22 <mniip> GHC has an API, but everything is centered around interpreting expressions
23:29:35 <mniip> if you want to do something below that you're basically doomed
23:30:01 <mniip> I once tried to dynamically load a module and lookup a symbol in that module
23:30:19 <mniip> got stuck while trying to instantiate the polymorphic value to a concrete type
23:30:31 <Lokathor> with erlang, you can just recompile and reload a module, then if you've integrated into the frameworks correctly the framework moves you to the new version on the next call safely
23:32:03 <shachaf> People were talking about the category of type constructors (not necessarily functors) in Haskell, where arrows are polymorphic functions (not necessarily natural transformations).
23:32:49 <shachaf> Yoneda and Coyoneda are right and left adjoint to the forgetful functor from the category of endofunctors to that category.
23:33:10 <shachaf> What else can be said about it?
23:34:21 <shachaf> You can make it monoidal in various ways; what do you get as a monoid object? Maybe this is related to modal logic?
23:34:27 <dolio> error's open kind doesn't cover [*]
23:37:57 <shachaf> Does anything change when you allow constructors that aren't even invariant, like you can get with GADTs?
23:39:51 <dolio> Nothing about the status of the Yoneda and Coyoneda types requires you to rule out GADTs.
23:40:55 <mniip> oh, you are correct
23:41:04 <mniip> OpenKind is only * and #, and unrelated to promoted kinds
23:41:11 <shachaf> Of course. I didn't mean to say that it did.
23:41:36 <shachaf> Just that that category is more interesting when you allow those things.
23:41:57 <shachaf> And also things like IORef and so on.
23:42:32 <mniip> and IORef kind?
23:44:28 <mniip> type family PutStrLn (a :: String) :: IO () where
23:44:48 <Shockk> mniip: I wrote some code to do that with the GHC API
23:45:10 <Shockk> like, lookup a symbol in a module#
23:45:27 <Shockk> I can link it if you'd want
23:45:42 <mniip> I have the same over here I suppose
23:46:35 <Shockk> I derived Typeable for the type of the symbol I was looking up
23:46:52 <Shockk> and I used the function that looks up the symbol as 
23:46:55 <Shockk> as a Dynamic* sorry
23:47:04 <Shockk> (then fromDyn/fromDynamic)
23:47:13 <mniip> ew
23:47:31 <mniip> Dynamic can't handle polymorphism anyway
23:47:38 <Shockk> oh
23:59:27 <amicuscuriae> yo guys
