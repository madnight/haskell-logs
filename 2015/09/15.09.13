00:01:09 <thomaseding> I suppose I can use #define X (* -> Constraint)
00:04:44 <slack1256> why not type family X (a :: *) :: Constraint ?
00:05:09 <slack1256> I guess you need a bunch of extensions 
00:06:05 <thomaseding> The type I actually want to alias is ((* -> Constraint) -> *)
00:06:49 <thomaseding> My use case is for kind specifications
00:07:37 * hackagebot woot 0.0.0.4 - Real time group editor without operational transform.  https://hackage.haskell.org/package/woot-0.0.0.4 (tgolson)
00:07:37 * hackagebot postgresql-orm 0.4.0 - An ORM (Object Relational Mapping) and migrations DSL for PostgreSQL.  https://hackage.haskell.org/package/postgresql-orm-0.4.0 (AmitLevy)
00:27:54 <kalkin-> i have a typeclass Living which consist of types Home String | Apartment String | UnderTheBrdige String
00:28:19 <vozz> Can someone explain to me why DLists append O(1) and (++) appends O(n)? I get that function concatenation is O(1), but when you finally turn it back into a list, isnt it going to be O(n) again? And similarly, isn't ++ lazy so the O(n) stuff doesn't happen until the end?
00:28:27 <kalkin-> i want to have a function foo to Which i can pass a type and a String, and it will instantiate the right type
00:29:10 <kalkin-> how can i do that?
00:30:37 <thomaseding> vozz: You are correct that reading the dlist is O(n). Thus reading and updating a dlist many times (interleaved) is really bad for performance
00:30:55 <thomaseding> vozz: Thus dlists are best for construction of a final string to be read at the end
00:31:51 <vozz> I don't understand, even if it's just read at the end, isn't each individual dlist inside it read, so it's something like O(n^2)?
00:31:52 <kadoban> kalkin-: types exist at compile time and Strings exist at runtime, so I don't think you even possibly could?
00:32:01 <montanonic> I feel like Hackage could learn some design and layout lessons from Purescripts version of a package manager, Pursuit. Here's a link to their Arrows package: http://pursuit.purescript.org/packages/purescript-arrows/0.6.0
00:32:04 <thomaseding> vozz: Concatenation (((x ++ y) ++ z) ++ y) is really slow despite laziness
00:32:04 <vozz> O(n) for each of the function concats you did
00:32:51 <thomaseding> vozz: this turns quadratic because it has to evaludate the intial head of the string each time it concats
00:32:58 <kalkin-> kadoban: k thanks
00:33:01 <vozz> When you do it with DList you get (x ++ (y ++ (z ++ y))), is that faster?
00:33:12 <kadoban> vozz: a ++ b is  O(|a|). Is that perhaps the part you're missing? It's not symmetric.
00:33:34 <thomaseding> (x ++ (y ++ b)) is linear. ((x ++ y) ++ z)  is quadratic
00:34:07 <vozz> I think I see
00:34:10 <vozz> Thanks a lot
00:34:19 <kadoban> vozz: So a DList is a trick to change  (((a ++ b) ++ c) ++ d) into (a ++ (b ++ (c ++ d)))
00:34:23 <kadoban> Kinda
00:34:32 <kalkin-> but how do i model inheritance? I have a record which has a loot of constructor fields and i have two functions which serialize and deserialize it from XML. And i want to have like 4 different Kinds of this record, based on the Xml Element name used. What i don't want is to duplicate 4 times my code. so i'm trying to wrap the basic record in some other type. may be this wrong?
00:35:16 <vozz> the first is O(|x| + |y|), the second is O(|x| + |x|+|y|)?
00:37:29 <nshepperd> vozz: suppose you concatenate `m` strings to produce a result of length `n` in the ((a ++ b) ++ c) manner. dlist takes O(n + m), while [] takes O(nm)
00:38:17 <nshepperd> just as, for lists, (a ++ (b ++ (c ++ d))) is O(n+m) while (((a ++ b) ++ c) ++ d) is O(nm)
00:42:28 <nshepperd> the dlist 'trick' is that rewriting (((a ++ b) ++ c) ++ d) to (a ++ (b ++ (c ++ d))) only takes O(m) time, so you can do it (once, when you read the dlist) without affecting the O(n+m) time to do the actual concatenation
00:46:48 <nshepperd> or, that's one way to think about it anyway, I guess
00:47:02 <vozz> Thanks for the explanation, just trying to wrap my head around it :)
01:04:25 <jle`> aw, reached the end of edwin's idris book so far :/
01:05:39 <jle`> kalkin-: inheritance is typically considered a bad idea by most modern language developers, and can lead to a lot of problems in general.  so maybe 'modeling' it might not be the best idea :)
01:06:30 <jle`> kalkin-: in Haskell the typical way of doing things like what you mentioned is with type classes
01:06:35 <kalkin-> jle`, don't call it inteheratance call it same class of stuff :)
01:07:25 <jle`> even though type classes are a bit of an iffy decision because they're easily misused
01:07:52 <jle`> but things like "all things that can be serialized/deserialized from XML" is typically handled using typeclasses
01:08:33 <kalkin-> jle`: i'm think i'am on the right track right now. i just need to really figure out how the use the type classes  and types right. but i think i see the light at the end of the tunnel :)
01:09:01 <jle`> kalkin-: heh, my general point was, looking for solutions matching solutions you've seen in other languages might lead you into trouble.  the most headache you'll get in when using haskell is trying to apply things you've learned/intuition you've gained from other languages and trying to find "haskell equivalents"
01:09:39 <jle`> so instead, state the problem in terms that don't involve concepts from other languages, and you might get a fresh perspective without clouding your thought with biases :)
01:10:18 <jle`> instead of solving the problem with a "haskell version of inheritance", maybe the problem is a completely different one entirely
01:11:53 <kalkin-> jle`: thanks for the advice. i will try to sum up what i'm trying to achieve
01:12:38 <lpaste_> nshepperd pasted “faking dlist with a tree” at http://lpaste.net/140828
01:17:08 <kalkin-> I need to parse some XML ( http://pastebin.com/y8K6q9ht), do some stuff (like
01:17:08 <kalkin-> create images, clone images), generate another XML for xen and start a vm from
01:17:08 <kalkin-> it.
01:17:08 <kalkin-> There're different kind of vms, based on which vm kind the programm is handling
01:17:08 <kalkin-> different solutions (i.e. for storage) are applied
01:17:59 <kalkin-> i think using typeclasses to model different kinds of vms is the right solution isn't it?
01:19:01 <jle`> if you know the "types of vm" you can have in advance, you might be able to use an ADT with a bunch of different constructors?
01:20:09 <jle`> typeclasses would start becoming the preferred choice if you start having a lot of different constructors/types of vm that can't be united as a single data type in a nice way
01:20:35 <jle`> or if you plan on adding many different types later, typeclasses might be an ok trade-off
01:21:06 <jle`> if you just have different types of VM, can you describe/represent them all under the same data type?
01:21:48 <jle`> if you have a solution involving typeclasses now, or are close to one, feel free to finish it and refine it later, too :)
01:22:08 <edwardk> KaneTW: FYI- In the end I did wind up going with cmake
01:24:03 <kalkin-> jle`: they all share the same constructors. I even trying to define them right now with the help of an type VM which contains all the records fields and with a data QubesVM = QubesAdminVm Vm | QubesTemplateVm Vm| ...
01:24:24 <kalkin-> %s/VM/Vm/
01:24:50 <kalkin-> overkill?
01:25:34 <kalkin-> jle`, btw with ADT do you mean Abstract Data Type or Algebraic Data Type?
01:25:51 <jle`> mhm i mean algebraic data type here
01:26:48 <jle`> hm, you can probably refactor that into data QuebesVM = QVM QType VM, and data QType = Admin | Template | ...
01:27:35 * hackagebot http-client 0.4.22.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  https://hackage.haskell.org/package/http-client-0.4.22.1 (MichaelSnoyman)
01:28:04 <kalkin-> So QVM will be the type which contains all the record fields did i understand it right?
01:28:15 <jle`> yeah, one single constructort
01:28:32 <jle`> if you can isolate your parsing logic into parsing only VM's, then that would mean you can pasre anything
01:28:34 <jle`> *parse
01:31:48 <kalkin-> jle` i think i'm getting the general idea, but I'm sorry I don't get what you meant with your last sentence.
01:33:11 <jle`> kalkin-: hm, i meant that if your problem is writing the same function for a bunch of different situations...then one thing you can do is write one "master" function parameterized by a value to get the right behavior
01:33:23 <jle`> that way you can write one function and have it work for different situations
01:34:02 <jle`> i'm being a bit vague, but getting deeper would involve knowing more about exactly what you're doing heh
01:34:18 <kalkin-> jle` ahh. i see
01:34:41 <kalkin-> jle` doesn't matter i think i see the way now. you helped a lot thanks!
01:34:55 <jle`> in general...if you can implement your program using only normal algebraic data types and parmeterized functions/higher order functions, it's usually a big win over using typeclasses
01:35:18 <jle`> because typeclasses are "magic" in haskell, but data types are first-class and manipulatable within haskell
01:35:59 <jle`> np!
01:36:20 <julianleviston> Can someone tell me what the ## operator does and where it comes from? I’ve searched Hoogle and Hackage and been googling for a while now, but I can’t find a definition anywhere… this is the page: https://github.com/snapframework/snap-website/blob/master/src/Main.hs
01:36:55 <julianleviston> It seems to be specifing to the Monad that bindSplices has about which splices and what functions to connect to them…
01:37:05 <kalkin-> ok, i will keep it in mind. i do not fully understand yet what you mean, but this is because all the differences between type, typeclass and algebraic types aren't completely settled in my head
01:37:23 <kalkin-> haskel is different
01:37:25 <kalkin-> :)
01:37:28 <jle`> kalkin-: don't worry, it will all make sense in time :)
01:37:35 * hackagebot exherbo-cabal 0.1.0.4 - Exheres generator for cabal packages  https://hackage.haskell.org/package/exherbo-cabal-0.1.0.4 (NikolayOrlyuk)
01:37:35 <jle`> took a while for it to settle in for me too
01:37:37 * hackagebot shakespeare 2.0.6 - A toolkit for making compile-time interpolated templates  https://hackage.haskell.org/package/shakespeare-2.0.6 (MichaelSnoyman)
01:37:42 <jle`> julianleviston: it looks like it's from heist
01:37:47 <jle`> http://hackage.haskell.org/package/heist-0.14.1.1/docs/doc-index-All.html
01:38:17 <julianleviston> wow how did you find that?
01:38:22 <julianleviston> thanks by the way
01:38:28 <jle`> julianleviston: oh it was next to hesit functions
01:38:32 <jle`> *heist functions
01:38:36 <jle`> so i looked in the heist docs
01:38:54 <jle`> oh it looks like it's been deprecated from heist the package http://hackage.haskell.org/package/heist-0.14.1.1/docs/Heist-SpliceAPI.html
01:38:59 <julianleviston> ah, in the index.
01:39:10 <jle`> http://hackage.haskell.org/package/map-syntax-0.2/docs/Data-Map-Syntax.html
01:39:34 <jle`> it looks like it's a cute trick to simulate map literals
01:39:57 <julianleviston> yeah, ok cool :) thanks!
01:40:08 <julianleviston> that’s quite cool
01:40:19 <jle`> julianleviston: you can also try new-hoogle
01:40:21 <jle`> http://hoogle.haskell.org/?hoogle=%23%23
01:40:37 <jle`> the normal hoogle's index is actually *significantly* outdated
01:40:56 <julianleviston> sweet that works fine.
01:40:59 <jle`> the indexing on normal hoogle has been suspended until the new version of hoogle is released
01:41:13 <jle`> but we've been waiting for a long time, heh
01:41:16 <julianleviston> so confuse! :)
01:41:17 <jle`> and the index is pretty old
01:41:36 <jle`> so the hoogle.haskell.org hoogle is a beta of the new version...or something...
01:41:40 <julianleviston> cool
01:41:53 <julianleviston> as averse to?
01:42:14 <jle`> the normal hoogle at haskell.org/hoogle ?
01:42:29 <jle`> i feel like they should probably update it if there isn't a definite release date for the new hoogle though
01:42:34 <jle`> it's been like this for over a year i think
01:42:39 <jle`> *update the index, at least
01:43:17 * ahihi has used Hayoo for years
01:44:57 <jle`> oh yeah there's that too heh
01:47:19 <julianleviston> Hayoo didin’t help too much
01:47:21 <julianleviston> for my case
01:47:32 <julianleviston> Yay! Got a splice in my thang. Yay.
01:47:35 <julianleviston> thanks @jle` 
02:00:43 <jle`> congrats!
02:20:27 <joco42_> I am starting to learn about ffi, the first question that comes to mind, what happens if I have some data on the stack in C and I want to transfer that to Haskell ? Will that data be copied ? What happens if I do the same with data on the heap in C ? Like a large 1GB matrix? Can I just pass some kind of pointer to that matrix ? To avoid copying costs?
02:21:08 <joco42_> say i want to use matrix operations, like lapack
02:21:13 <joco42_> from haskell
02:21:20 <joco42_> finding eigenvalues
02:22:30 <joco42_> is it possible to pass pointers to arrays?
02:22:55 <joco42_> i have a pointer to a large array in C and I want to access that large array from haskell, without copying.
02:23:04 <dramforever> joco42_: "pointer" yes that's possible, you can read/write pointers in haskell, it's in a typeclass Storable. you can also use wrappers like Storable vectors/arrays. I don't know about the details, though
02:23:44 <joco42_> dramforever: ok, thanks, i will look out for these keywords when reading the docs
02:23:53 <dramforever> https://hackage.haskell.org/package/base-4.8.1.0/docs/Foreign-Storable.html#t:Storable
02:24:06 <dramforever> also look around in Foreign.* modules for nice wrappers
02:24:57 <ernst> e.g. Foreign.Marshal.Array is probably useful
02:25:11 <joco42_> dramforever: this Storable looks pretty nice
02:25:28 <joco42_> ernst: thanks, now I know where to  look around
02:27:33 <joco42_> what is the difference between stack vs heap variables?
02:27:49 <joco42_> say i have some value on the stack in C
02:28:07 <joco42_> i assume i cannot get a pointer to that, right?
02:28:13 <joco42_> from the haskell side
02:28:38 <joco42_> so anything created on the stack will be copied?
02:28:39 <cocreature> well you can get a pointer, but if the stack changes it's obviously no longer a valid pointer
02:28:50 <cocreature> just like in c
02:28:55 <joco42_> ok
02:28:57 <joco42_> i see
02:29:15 <joco42_> cocreature: so when dealing with stack then it is better to copy it
02:29:53 <cocreature> unless you are really sure that you know the pointer is going to stay valid as long as you use it, yeah
02:33:52 <jerrrry> joco42 do you mean a local function stack? that memory is no longer valid when a function returns
02:36:20 <joco42_> jerrrry: yes, local function stack, yeah
02:39:44 <joco42_> is there some nice talk about ffi ?
02:41:31 <quchen> ?tell dfeuer Now I'm confused as well, maybe we should pick the discussion again when we're both on IRC :-)
02:41:31 <lambdabot> Consider it noted.
02:41:58 <joco42_> https://www.google.fi/webhp?sourceid=chrome-instant&ion=1&espv=2&ie=UTF-8#safe=off&tbm=vid&q=haskell+ffi
02:42:08 <joco42_> there are some talks on ffi
02:43:31 <ion> ion=1
02:56:39 <djh_> hi all, I am a haskell newbie and I got problem in cabal build in sandbox environment
02:57:29 <djh_> I compile pandoc and pandoc-types with cabal install in a sandbox
02:58:49 <djh_> But after installation (it says), I can't import Text.Pandoc from ``cabal repl'' from root directory
02:59:27 <djh_> Instead of I could import them from ``<root>/.cabal-sandbox/'' directory
03:00:26 <djh_> How can I build my pandoc filter which needs these module from root directory(which contains src/ xx.cabal)
03:00:54 <jerrrry> by root directory do you mean yourproject/src ?
03:01:51 <djh_> to Jerrrry: No, I mean <yourproject>/
03:03:27 <djh_> to Jerrrry: I found that I could import the library from <myproject>/src
03:04:00 <jerrrry> djh then I guess your hs-source-dirs is set to src (which is fine)
03:05:21 <djh_> Jerrrry Yes, I checked <projectName>.cabal, src is the value of hs-source-dirs
03:07:08 <jerrrry> oddly enough, it works for me in the root directory, but not if I switch to src before running cabal repl
03:07:25 <jerrrry> and I also have hs-source-dirs set to src
03:11:17 <djh_> jerrrry It's also very strange that I have installed pandoc but I got no pandoc executable in .cabal-sandbox/bin
03:11:58 <djh_> FYI: I use Archlinux, GHC(7.10.1) from offical repo, 
03:12:42 <djh_> cabal from offical repo too with no ArchHaskell repo setup.
03:14:04 <jerrrry> did you get "Notice: installing into a sandbox located at.." just 
03:14:13 <jerrrry> after running cabal install?
03:14:23 <jerrrry> or cabal install pandoc
03:16:06 <djh_> Jerrrry I ran it, it says ``... located at <dirname>/.cabal-sandbox''
03:17:16 <tapesh> hello everyone please help me make my first contribution to haskell project
03:17:16 <djh_> and I checked that there is nothing special from ``<this_directory>/<dirname>''
03:17:26 <lamefun> When OverloadedRecordFields lands, would there be any reason to keep making normal functions to operate on records instead of just 'HasField' instances?
03:19:45 <tapesh> i would like to begin with the clone ,install dependencies and build wiki :)
03:20:53 <bennofs> tapesh: what project is it that you want to contribute to?
03:21:41 <tapesh> bennofs: i haven't seen the list of projects :(
03:22:09 <tapesh> bennofs: is there a wiki for that ?
03:22:56 <bennofs> tapesh: sorry, I don't understand what your question is. So you want to contribute to *some* haskell project, but you have no idea which one?
03:23:27 <joco42_> any idea why this ghc panic can happen when importing archives? http://pasteboard.co/BFDhVUA.png
03:23:53 <joco42_> how can i fix this?
03:24:08 <joco42_> how can i use my own sum frm mylib.h in ghc?
03:24:25 <bennofs> joco42_: I believe GHC 7.8 and later do not support static archives in GHCi anymore. 
03:24:40 <bennofs> joco42_: you can only load shared libraries in GHCi 
03:24:43 <joco42_> ok, bennofs, so what is the better way to di it ?
03:24:57 <joco42_> i have to admit i am not a c guru
03:25:09 <joco42_> i have to make a .so ?
03:25:28 <bennofs> joco42_: I believe just adding the .o to the ghci command line should work
03:25:34 <iron_houzi> Does anybody know how to get a solid haskell development environment for arch linux? I know there have been some recent changes to avoid cabal-hell, is it enough to just get stack? Also, the ghc package is flagged out of date in the arch package page. Does anybody know what I should do if I want ghc for arch?
03:25:35 <joco42_> ok
03:25:37 <joco42_> i try
03:25:38 <bennofs> joco42_: as in: ghci mylib.o 
03:25:41 <joco42_> thanks bennofs
03:25:53 <tapesh> bennofs: i am a newbie and i like graphics, command line tools ..please suggest me a project i can contribute to ..the main motive is to participate in Google Summer of Code 2016 :)
03:26:06 <jerrrry> djh_ I just tried creating a fresh sandbox and running cabal install pandoc, and I got pandoc executable in .cabal-sandbox/bin. so there is something strange going on at your end
03:26:45 <Beardful> Anyone know how to search for something in a repa array? I'd like to find the largest value in it.
03:27:04 <bennofs> iron_houzi: getting stack should work. it can install GHC for you
03:27:53 <joco42_> bennofs: cool, it worked !
03:27:55 <iron_houzi> bennofs: Ah. Thanks. Do you have any recommendations for how I should learn to use stack apart from the github page?
03:28:27 <cocreature> the guide is probably the best way https://github.com/commercialhaskell/stack/blob/master/GUIDE.md
03:32:20 <tapesh> bennofs: which haskell projects are included in GSoC ? maybe i can begin with that :)
03:33:30 <joco42_> any idea why this does not work ? http://pasteboard.co/BGj0bPi.png
03:33:40 <joco42_> i know, i am doing print in a pure function
03:33:50 <joco42_> but how does haskell know that?
03:33:55 <bennofs> tapesh: I remember diagrams, cabal, darcs and ghc are mentioned quite often regarding GSoC
03:34:19 <djh_> jerrrry Thanks, I am trying build my pandoc filter from a fresh sandbox with pandoc, pandoc-types as dependencies
03:34:48 <bennofs> joco42_: that's the same image as the last one for me
03:35:20 <joco42_> bennofs: sorry, a mistake, let me fix that
03:36:42 <joco42_> bennofs: here is the correct one, http://pasteboard.co/BGvXFb0.png
03:37:27 <arkeet> joco42_: the error message suggests what to do.
03:37:51 <bennofs> joco42_: use gcc -fPIC ...
03:37:56 <bennofs> joco42_: for compiling the .o
03:38:06 <delYsid> Say the digits of an integer designate the bits of value.  How would I go about going from decimal to the final value?  i.e., 123 = 7, 12 = 3, 14 = 9 ...
03:38:27 <joco42_> arkeet: the problem is I have no clue what that means, It might fix the problem, but i would like to know the WHY 
03:38:39 <arkeet> PIC = position independent code
03:39:06 <joco42_> arkeet: why is that needed with a print statement ?
03:39:12 <arkeet> so that it may be loaded at some arbitrary base address in case it collides with something else.
03:39:15 <arkeet> this has nothing to do with print
03:39:26 <joco42_> https://en.wikipedia.org/wiki/Position-independent_code
03:40:01 <joco42_> arkeet: ok, so that is always how i have to compile for haskell ffi ?
03:40:06 <arkeet> I guess so.
03:40:08 <bennofs> joco42_: yes
03:40:18 <joco42_> bennofs: i did not know that, thanks
03:40:39 <joco42_> i worked without -fPIC without the print statement
03:40:57 <joco42_> so i thought that it was the print statement that was messing something up...
03:41:07 <bennofs> joco42_: that's just a weird coincidence
03:41:19 <joco42_> bennofs: ok... good to know
03:41:23 <joco42_> :)
03:41:23 <arkeet> I wonder why -fPIC would be unnecessary without it.
03:41:31 <bennofs> arkeet: right, I have no idea either
03:41:35 <joco42_> maybe because it has no data
03:41:40 <arkeet> maybe because the code is so trivial that it has nothing to relocate yeah.
03:41:58 <bennofs> right, it doesn't have any references at all. just a blob of assembly
03:42:06 <cocreature> delYsid: make a function that converts your integer to a list of digits (or use some library that provides that). then you can map (\x -> 2^(x-1)) over that list and finally call sum
03:42:09 <joco42_> cool
03:42:21 <joco42_> i have learned something interesting today
03:42:23 <joco42_> thanks
03:42:27 <bennofs> with print, it probably needs to push a return address or something, which needs to be relocated
03:42:27 <arkeet> yeah, no rodata (you have a string now)
03:42:34 <bennofs> hmm
03:43:08 <arkeet> bennofs: well, it specifically mentions .rodata, which is where that string "%i\n" would end up.
03:43:22 <arkeet> and not really anything else.
03:43:26 <bennofs> oh right. function calls just push the IP
03:43:49 <arkeet> oh wait wrong file, "hello" instead.
03:44:45 <joco42_> http://pasteboard.co/BH2OiCG.png
03:44:55 <joco42_> the "hello" does not print :)
03:44:58 <joco42_> strange
03:45:14 <arkeet> you never use c_sum
03:45:17 <arkeet> oh wait.
03:45:23 <arkeet> hmm.
03:45:31 <tapesh> bennofs: diagrams seems interesting to me :)
03:45:38 <arkeet> sorry it's late.
03:46:00 <joco42_> arkeet: :)
03:46:01 <bennofs> joco42_: try flushing stdout after the print
03:46:11 <joco42_> bennofs: ok
03:46:14 <jerrrry> > floor $ logBase 2 127 + 1
03:46:16 <lambdabot>  7
03:46:22 <jerrrry> > floor $ logBase 2 128 + 1
03:46:24 <lambdabot>  8
03:47:41 <arkeet> > (\x -> finiteBitSize x - countLeadingZeros x) (127 :: Int)
03:47:43 <lambdabot>  7
03:47:44 <arkeet> > (\x -> finiteBitSize x - countLeadingZeros x) (128 :: Int)
03:47:46 <lambdabot>  8
03:48:15 <joco42_> bennofs: it worked :) http://pasteboard.co/BHgQFv2.png
03:48:17 <arkeet> (both of those are from Data.Bits)
03:48:17 <joco42_> this is fun
03:48:25 <joco42_> haskell is now impure :)
03:48:49 <arkeet> not that that's new :-)
03:48:50 <bennofs> joco42_: yeah, the FFI is scary. You can do bad stuff with it, be careful
03:49:09 <joco42_> the dark side
03:50:58 <bennofs> joco42_: it get really messy when you have a higher-order C function taking a callback that should execute haskell code (don't ask me how that works)
03:51:25 <joco42_> bennofs: yeah... one step at a time...
03:51:39 <joco42_> right now i just want to find a way to wrap some python code into haskell
03:51:47 <delYsid> cocreature: I ended up using Data.Bits.setBit and recursion.
03:52:49 <arkeet> sounds like the way to go yeah.
03:53:04 <arkeet> or a fold
03:54:02 <arkeet> > foldl' ((.|.) . bit) 0 [1,4]
03:54:03 <lambdabot>  6
03:54:06 <arkeet> oops.
03:54:41 <arkeet> > foldl' (\a x -> a .|. bit x) 0 [1,4]
03:54:43 <lambdabot>  18
03:55:00 <arkeet> > foldl' (\a x -> a .|. bit (x-1)) 0 [1,4]
03:55:01 <lambdabot>  9
03:55:53 <arkeet> > foldMapBy (.|.) 0 (bit . pred) [1,4]
03:55:55 <lambdabot>  9
03:56:40 <arkeet> > foldl' (\a x -> setBit a (x-1)) 0 [1,4] -- yeah ok.
03:56:42 <lambdabot>  9
04:09:54 <djh_>  jerrrry: Install and compile from fresh sandbox still gives type match error I used to have
04:10:21 <djh_> I googled it which says the GHC-7.10.1 problem
04:10:40 <jerrrry> ah
04:10:55 <jerrrry> I am still on 7.8.4
04:10:56 <djh_> if you interested, it reports Main.hs:10:11:
04:10:56 <djh_>     Couldn't match type ‘Either Text.Pandoc.Error.PandocError Pandoc’
04:10:56 <djh_>                    with ‘Pandoc’
04:11:40 <jerrrry> is that Pandoc's main?
04:12:27 <djh_> jerrrry: no, it's  In the expression: readMarkdown def
04:12:41 <jerrrry> did you try using cabal.sandbox.config ?
04:13:03 <srhb> djh_: I think we're missing part of the story here. Could you maybe paste a minimal version of the problem? :)
04:13:08 <djh_> no, I didn't edit it, but it exists
04:14:01 <arkeet> djh_: can you paste your code?
04:14:09 <arkeet> and the full error?
04:14:10 <djh_> srhb: I am not able to compile pandoc filtering script
04:14:11 <jerrrry> sorry, I meant cabal.config from stackage
04:14:12 <arkeet> @lpaste
04:14:12 <lambdabot> Haskell pastebin: http://lpaste.net/
04:14:34 <arkeet> oh is this some existing package that has an error?
04:14:40 <jerrrry> pandoc
04:15:15 <djh_> jerrrry: I didn't use stackage.
04:15:37 <djh_> jerrrry: I think I am going with default hackage repo.
04:15:50 <jerrrry> worth a try. it saved me in the past
04:18:57 <djh_> jerrrry: Thanks, I would take your advice. Let me paste my error log first.
04:20:39 <djh_> arkeet: console error log: [djh@snow pdf]$ cabal build myfilter
04:20:40 <djh_> Package has never been configured. Configuring with default flags. If this
04:20:40 <djh_> fails, please run configure manually.
04:20:40 <djh_> Resolving dependencies...
04:20:40 <djh_> Configuring myfilter-0.0.0.1...
04:20:42 <djh_> Warning: The 'license-file' field refers to the file 'LICENSE' which does not
04:20:44 <djh_> exist.
04:20:47 <djh_> Preprocessing executable 'myfilter' for myfilter-0.0.0.1...
04:20:49 <djh_> [1 of 1] Compiling Main             ( src/Main.hs, dist/build/myfilter/myfilter-tmp/Main.o )
04:20:52 <djh_> src/Main.hs:10:11:
04:20:55 <djh_>     Couldn't match type ‘Either Text.Pandoc.Error.PandocError Pandoc’
04:20:57 <djh_>                    with ‘Pandoc’
04:21:00 <djh_>     Expected type: String -> Pandoc
04:21:02 <djh_>       Actual type: String
04:21:05 <djh_>                    -> Either Text.Pandoc.Error.PandocError Pandoc
04:21:07 <djh_>     In the expression: readMarkdown def
04:21:10 <djh_> oh sorry, I am not mean to spam
04:21:34 <arkeet> that's what lpaste is for
04:21:56 <djh_> Sorry let me do that again.
04:22:15 <arkeet> I'm mostly concerned about the code
04:23:17 <djh_> arkeet: Main.hs(the only source file) http://lpaste.net/140836
04:23:20 <jerrrry> if that is your code (as opposed to pandoc's code) it should be an easy fix. and yes, paste your code
04:25:11 <arkeet> djh_: ok, now read the comment.
04:25:13 <arkeet> in your own code.
04:25:30 <arkeet> because presumably the type of readMarkdown changed in pandoc 1.14
04:27:00 <djh_> arkeet: Thanks, I would try it.
04:27:11 <arkeet> anyway it's sleepy time for me.
04:27:13 <arkeet> bye
04:27:18 <djh_> and I'd like setup stackage first
04:27:27 <djh_> arkeet: Thanks, good night
04:28:04 <jerrrry> I thought you had errors compiling pandoc program. there's no need to switch to stackage for this
04:32:04 <djh_> jerrrry: Thanks for your helps and tips, I am going offline.
04:32:20 <djh_> Have a nice day or night, bye :)
04:49:58 <kalkin-> i have a function which gives me back IO (QVM qtype vm) i want to execute the function name on the vm
04:50:04 <kalkin-> how do i get around IO?
04:50:44 <kalkin-> i tried with do and <- but some how ghc does not make any sense, first it says IO is missing than that he expects IO 
04:51:14 <kalkin-> i tried fmap and mapM_
04:52:43 * hackagebot quiver 1.0.0 - Quiver finite stream processing library  https://hackage.haskell.org/package/quiver-1.0.0 (patrykz)
04:54:41 <cocreature> kalkin-: what do you mean by "execute the function name?"
04:55:00 <kalkin-> execute the function "name" :)
04:55:02 <kalkin-> sorry
04:55:20 <kalkin-> exactly spoken it's a field on the record vm
04:55:38 <bennofs> kalkin-: so do you have a function QVM qtype vm -> something
04:55:40 <bennofs> ?
04:57:06 <kalkin-> benoffs: yes getName :: QubesVm -> String
04:57:24 <int-index> http://lpaste.net/2998460134130188288 - it prints 20.0 20.0 20.0 2.71561612948e-312
04:57:34 <int-index> I would expect it to print 20.0 20.0 20.0 20.0
04:57:41 <int-index> Why does it break in the fourth case?
04:58:08 <Gurkenglas> kalkin-, http://lpaste.net/140838
05:00:42 <bennofs> int-index: here's why;
05:00:43 <bennofs> test.hs:12:19: Warning:
05:00:45 <bennofs>     Defaulting the following constraint(s) to type ‘Integer’
05:00:47 <bennofs>       (Num a0) arising from a use of ‘f’
05:00:49 <bennofs>     In the first argument of ‘unsafeCoerce’, namely ‘f’
05:00:51 <bennofs> int-index: -Wall :)
05:01:15 <kalkin-> Gurkenglas: thanks, i think this guides me in the right direction
05:01:25 <int-index> bennofs: Thanks!
05:05:18 <tomberek> Is there a Generic2 available in GHC Generics? Or a way to hack to it? While trying to create a instance for Generic for a GADT manually: a b c -> a c d -> MyType a b d.  This causes problems because the 'c' parameter dissapears and I can't introduce it using the Generics datatype description DSL. Next, foralls are not allowed in type families for the Rep parameter.
05:07:32 <kalkin-> Gurkenglas: while i learned about return in your example, i do i get a not tainted X
05:08:10 <kalkin-> i do not understand how do i get a not tainted X. so no IO X
05:09:13 <Gurkenglas> kalkin-, lpaste your code
05:13:30 <kalkin-> http://lpaste.net/140840
05:14:01 <kalkin-> so getList is obviously broken because it should return IO [QubesVm]
05:15:25 <int-index> kalkin-: getList = fmap getVmList getCol
05:15:27 <int-index> no?
05:16:27 <kalkin-> why?
05:17:24 <int-index> well, you have `IO QubesVmCollection`, (QubesVmCollection -> [QubesVm]`, and you want to get `IO [QubesVm]`
05:18:34 <kalkin-> actually i'm trying to get rid of IO but maybe it's a bad idea ?
05:19:02 <int-index> IO indicates that the function does IO. It does. Don't get rid of it.
05:19:22 <int-index> if you want to get rid of IO in the type, get rid of it in the code
05:21:15 <kalkin-> int-index: do you mean like literally do not do IO if you do not want to have IO in the type or do you mean i need to find ways to have pure functions which in some way should be applied to IO?
05:21:24 <Gurkenglas> If you want to get rid of it because you need to use the data for something else, lift the something else into working on IO (by using fmap/liftA/liftM which are all just synonyms for each other, but liftA doesnt compile when used on a Functor that isnt an Applicative and liftM doesnt compile when used on a Functor that isn't a monad. (Every monad is an applicative and every applicative is a functor.))
05:21:59 <int-index> kalkin-: that's a false dichotomy. I mean both.
05:22:15 <Gurkenglas> :t liftM
05:22:16 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
05:22:25 <int-index> Gurkenglas: liftM is fmap
05:22:30 <Gurkenglas> Yes, I just said that
05:22:32 <kalkin-> int-index: ashh ok
05:22:51 <int-index> Gurkenglas: oh, I didn't read your message, only the lambdabot query, sorry
05:23:41 <Gurkenglas> When you want to use the data for something that does IO again, use (>>=). do notation makes code with lots of that more readable.
05:23:46 <Gurkenglas> :t (>>)
05:23:47 <lambdabot> Monad m => m a -> m b -> m b
05:23:49 <Gurkenglas> dangit
05:23:53 <Gurkenglas> :t (>>=)
05:23:54 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:23:59 <kalkin-> so i need to define rawList :: QubesVmCollection -> [String] and then apply it via fmap to someIoGetCollectionFunction right?
05:24:28 <int-index> kalkin-: sounds reasonable
05:24:29 <kalkin-> this way i have my pure rawList function and the IO stuff separated, right?
05:24:35 <int-index> correct
05:24:38 <Gurkenglas> Yes, that'll net you a IO [String]. Refering to undefined functions by type rather than by name is often wise :P
05:25:14 <dramforever> actually...we use :t more than > here don't we
05:25:30 <kalkin-> ok thanks, i think i have now enough food for thoughts :)
05:26:29 <brtmr> hi - what is the name of this notation (from the postgresql-simple hackage page): executeMany c [sql|SELECT * FROM FOO|] [(1, "hello"),(2, "world")
05:26:40 <boran> hey! i have a simple question about my laboration question. can someone check it and tell me what the wrong is? http://lpaste.net/140842
05:26:55 <brtmr> googling for [| |] is unsurprisingly not very helpful ;).
05:27:05 <mniip> brtmr, quasiquoters
05:27:10 <mniip> a part of Template Haskell
05:27:26 <brtmr> mniip: thank you. i knew i had read it before.
05:27:44 * hackagebot quiver-bytestring 1.0.0 - Quiver combinators for bytestring streaming  https://hackage.haskell.org/package/quiver-bytestring-1.0.0 (patrykz)
05:28:25 <dramforever> boran: "in function karpsvaror" what's that? oh I'll assume you rename the functions
05:28:27 <srhb> boran: You didn't include karsvaror?
05:28:53 <dramforever> it's because decodeIt was called with [], but you didn't really specify how to deal with it
05:30:03 <int-index> boran: if `decodeIt` is renamed `karpsvaror`, then look at `decodeIt` more closely. It doesn't handle []
05:30:18 <int-index> calling `decodeIt []` crashes your program
05:30:22 <srhb> boran: Also your comment in it is confusing. You state that it replaces x, which is a consonant, with x:'o':x:... but it does the opposite, the if case is the one where x is a consonant.
05:30:27 <tomberek> can any Generics framework cope with existential types defined in a GADT: a b c -> a c d -> MyType a b d ?
05:30:49 <srhb> boran: Oh wait, it's because isConstant actually checks for vowels. Sorry.
05:31:40 <boran> yes, it is renamed. 
05:31:46 <boran> wow yes, that is true!
05:32:18 <boran> thank you int-index. 
05:35:11 <glendc> is there any good library available to create/manipulate images. For example to create a visual pattern, distort it with some noise and than store it?
05:35:58 <bennofs> tomberek: I don't think the generic representation supports GADTs
05:37:07 <tomberek> bennofs: yes, i've seen that none of them can automatically derive, I'm ok with doing it manually, but the existential doesn't seem supported even manually.
05:37:26 <srhb> glendc: You probably want to combine juicypixels with something else.
05:37:44 * hackagebot stopwatch 0.1.0 - A simple stopwatch utility  https://hackage.haskell.org/package/stopwatch-0.1.0 (debugito)
05:38:14 <srhb> glendc: friday may also be of interest :)
05:42:12 <Gurkenglas> I would like to have there be a website that provides UI for "modify . (:)" and "liftIO . putStrLn . unlines . map show <=< gets . filter", such that the state is shared between everyone accessing the website, and persistent. How would I go about this?
05:43:54 <delYsid> I'd like to represent braille dots in Haskell.  Braille is an 8 dot system.  Really very much like a unsigned 8-bit value.  I'd like to have decimal values like (1234) represent a braille value with the corresponding dots/bits set.  But I'd like to have invalid values, like 1239 oder 111 be rejected by the *type system*.  Is such a thing possible?
05:46:19 <srhb> delYsid: It's difficult, because that's basically dependent typing, or at least subtyping, which we don't really have.
05:46:43 <srhb> delYsid: Usually we instead hide the actual data constructor for the type and use so-called "smart constructors" -- ie. functions that prevent you from creating invalid values.
05:46:58 <delYsid> ok, so I just fail in my conversion function.  How do I fail if I encourage an invalid value?
05:47:16 <srhb> mkBraille :: Int -> Maybe Braille
05:47:18 <srhb> ?
05:47:39 <delYsid> ah
05:48:52 <delYsid> but this feels weird, because all the input to mkBraille will be "static".  So the maybe handling will thread through the code although I am really just trying to statically catch type errors.
05:49:19 <srhb> delYsid: Yes, we've relegated it to runtime checking, but we can at least force the user to make sure they've done it right by using Maybe.
05:50:07 <delYsid> grml.
05:50:59 <srhb> Otherwise you can skip the conversion function and make a data type that exactly expresses the invariants.
05:51:13 <delYsid> I have 256 possible values, I might as well just create an Ord class with all these alternatives, and somehow convert to/from that.  But that is very excessive, would do away with the Maybe tough.
05:51:27 <srhb> But to convert from Int to that and have it be checked at compile time, you will need to jump through hoops because we don't have dependent types.
05:51:51 <srhb> delYsid: yes, data Braille = Braille Bit Bit Bit Bit Bit Bit Bit Bit -- would work.
05:52:32 <srhb> But convert would still be Int -> Maybe Braille
05:54:06 <srhb> delYsid: if you _really_ want to get your hands dirty, you can try playing with TypeNats :)
05:54:20 <delYsid> since I always want increasing dot numbers anyway, I could also define constants like brl1, brl12... and ignore all the Int conversion madness.  But that really feels weird, although also right...
05:55:31 <delYsid> brl1 = Braille False False False False False False False True
05:59:48 <srhb> delYsid: How about a fixed length list (with typelits and normalization plugins) ?
06:01:29 <delYsid> srhb: I have no idea what that means :-)
06:01:49 <srhb> Yeah, it's a little advanced...
06:02:20 <srhb> And carrying around proofs will be cumbersome anyway.
06:03:55 <delYsid> I am too green to do anything far outlandish here, after all, its just a simple data type.  Maybe I'll try something like data Braille = NoDots | Dot1 | Dot2 | ... | Dots12 | Dots13 ...
06:05:35 <srhb> I think you'll be happier if you bite the bullet and go the smart constructor route.
06:06:35 <srhb> It really is the idiomatic way to do this in Haskell. :)
06:07:46 * hackagebot haddocset 0.4.0 - Generate docset of Dash by Haddock haskell documentation tool  https://hackage.haskell.org/package/haddocset-0.4.0 (HirotomoMoriwaki)
06:08:54 <Gurkenglas> Is there a tool that writes imports into my code all unknown identifiers for which it can find only one result of an appropriate type?
06:09:52 <delYsid> I am just thinking, if I autogenerate the data Braille from above, and make sure the ordering is correct, I can deriving (Eq, Ord, Enum) and convert from/to unicode with from/toEnum and an addition/subtraction.  That would be rather neat actually, and express the actual intent, instead of introducing Maybe for no reason...
06:28:34 <nschoe> Hi, I've successfully sent an email via SMTP with the lib 'smtp-mail'. Now if I understand correctly, this is send in plain text. Can I use STARTTLS with this library?
06:37:47 * hackagebot polar-shader 0.1.0.2 - High-level shader compiler for Polar Game Engine  https://hackage.haskell.org/package/polar-shader-0.1.0.2 (Shockk)
06:44:25 <demize> nschoe: Nope. But you could try HaskellNet and HaskellNet-SSL instead. Never used it though.
06:44:38 <nschoe> demize, thanks I'll take a look.
06:47:47 * hackagebot exherbo-cabal 0.1.1.0 - Exheres generator for cabal packages  https://hackage.haskell.org/package/exherbo-cabal-0.1.1.0 (NikolayOrlyuk)
06:47:50 <int-index> how do I get the current day in the year using the `time` library?
06:48:04 <int-index> `toGregorian` gives me the current day in the month
06:54:01 <jerrrry> did anyone use inline-C? calling C functions without bindings sounds awesome.. how well does it work in practice?
06:54:03 <jerrrry> https://www.fpcomplete.com/blog/2015/05/inline-c
06:54:21 <lowtech> Troy Aikman wont be playing this weekend do to a leg injury that hasnt yet occurred.
06:57:07 <lowtech> Troy Aikman wont be playing this weekend do to a leg injury that hasnt yet occurred.
07:00:07 <jerrrry> that is just amazing.. you can use C inside haskell, with C syntax. and it works seamlessly (supposedly, I have ye tto try)
07:04:29 <srhb> jerrrry: Yes indeed. :)
07:04:40 <srhb> I've yet to try it, but I think I could port some of my FFI things that way.
07:04:58 <srhb> Not exactly sure if it's worth it, but hey. Learning experience.
07:07:30 <dramforever> int-index: what about using toGregorian to get the year, and use fromGregorian with Jan 1st to get the first day, and use diffDays?
07:07:38 <dramforever> could be off by one
07:13:39 <julianleviston> If x = BlogEntry {title = "hey", author = "", body = “”} then how can I use a lens setter to swap out, say, the title?
07:14:06 <julianleviston> and I have a lens set up as x, sorry.
07:22:08 <srhb> > set _1 4 (1,2) -- ?
07:22:10 <lambdabot>  (4,2)
07:22:29 <srhb> Replace _1 with your setter and (1,2) with x
07:22:52 <julianleviston> I don’t understand. What’s my setter?
07:23:06 <srhb> You've generated lenses for you BlogEntry type, yes?
07:23:07 <julianleviston> sorry. totally new to lenses.
07:23:51 <julianleviston> srhb: I’ve actually generated lenses for this data HelloWorld = HelloWorld { _heist :: S.Snaplet (SH.Heist HelloWorld) , _blogEntries :: [BlogEntry] }
07:24:09 <srhb> You want to generate some lenses for BlogEntry too. 
07:24:26 <julianleviston> which will actually become this: data HelloWorld = HelloWorld { _heist :: S.Snaplet (SH.Heist HelloWorld) , _blogEntries :: [BlogEntry] , _inputBlogEntry :: BlogEntry }
07:24:44 <julianleviston> and I’d like to set a field of inputBlogEntry
07:25:24 <srhb> Yes, so you will need to generate some lenses for BlogEntry too.
07:25:30 <julianleviston> ah..
07:27:35 <srhb> And then you ultimately get yourHelloWorld & inputblogEntry . title .~ "newtitle" or a similar version with the prefix set
07:29:41 <julianleviston> ah ok sweet!
07:29:43 <julianleviston> thanks so much
07:31:34 <julianleviston> srhb: tho I’m not sure what that means yet.
07:31:42 <srhb> What what means?
07:33:13 <julianleviston> the last thing you said
07:33:48 <julianleviston> I’ve got my inputBlogEntry lens… 
07:34:02 <julianleviston> and I’ve got something called title (which is the new title)
07:34:23 <julianleviston> BlogEntry {title :: Text, body :: Text, author :: Text}
07:34:25 <srhb> Oh, just that you can write it as set (inputBlogEntry . title) "newtitle" yourHelloWorld -- instead of using .~
07:34:51 <julianleviston> do I say inputBlogEntry .= ?
07:34:54 <srhb> julianleviston: You should rename the fields in your BlogEntry datatype to be _title etc. and generate lenses for it.
07:34:58 <julianleviston> ah I don’t know what .~ is.
07:35:11 <srhb> infix set
07:35:11 <julianleviston> um… oh ok.
07:35:27 <srhb> The thing is, you have lenses for HelloWorld, but not for BlogEntry
07:35:32 <julianleviston> I did generate lenses for it
07:35:35 <srhb> Ah, good.
07:35:57 <srhb> Then title should be a lens and you can just do exactly what I said.
07:36:26 <julianleviston> oh ok
07:36:39 <julianleviston> what is .= then?
07:36:44 <julianleviston> just out of cursiosity
07:36:59 <srhb> A stateful version of .~
07:37:09 <julianleviston> oh ok
07:37:18 <srhb> More or less
07:41:01 <julianleviston> srhb: that doesn’t seem to work too well… complaining about matching T.Text with bytestring-0.10.4.0:Data.ByteString.Internal.ByteString
07:41:09 <julianleviston> odd isn’t it, because I have overloaded strings on
07:41:24 <srhb> julianleviston: Time for some pastes. :)
07:41:31 <julianleviston> Oh I’m in GHCI… hand on
07:41:33 <julianleviston> hang on
07:41:58 <julianleviston> Hm nah ok pastie time :)
07:42:49 * hackagebot OpenGLRaw 2.5.3.0 - A raw binding for the OpenGL graphics system  https://hackage.haskell.org/package/OpenGLRaw-2.5.3.0 (SvenPanne)
07:42:59 <julianleviston> srhb: http://lpaste.net/140845
07:43:03 <julianleviston> Error at the bottom… 
07:44:03 <srhb> julianleviston: Things are still functional. You haven't actually set anything. You haven't even given it the value to operate on.
07:44:32 <julianleviston> isn’t this what you said to write? L.set (inputBlogEntry . title) newTitle
07:44:50 <srhb> julianleviston: L.s (inputBlogEntry . title) newTitle -- where is the HelloWorld value?
07:44:52 <julianleviston> the value to operate on is inputBlogEntry . title isn’t it?
07:45:04 <srhb> julianleviston: You said you had an x :: HelloWorld or something like that.
07:45:33 <julianleviston> I thought inputBlogEntry implicitly “gets” it…?
07:45:40 <srhb> Nope.
07:45:49 <julianleviston> oh… I wonde how it’s been working before.
07:46:08 <srhb> I wonder what you were doing before. :-)
07:46:34 <julianleviston> Oh
07:46:34 <julianleviston> ok
07:46:47 <julianleviston> nah that was within the init, and I had a reference to it.
07:46:58 <srhb> Sounds more likely. :)
07:47:21 <julianleviston> Hang on tho… in indexHangler, isn’t it in a Hangler ?
07:47:33 <jerrrry> about inline-c.. slightly annoying thing is that you have to restart ghci each time you make some changes to the C code. other than that it works great. 
07:47:56 <julianleviston> Handler* sorry haha
07:49:23 <julianleviston> srhb: I’m pretty sure in that handler, those lense functions refer to the right data… because you can write inputBlogEntry .= BlogEntry {…} for example, can’t you?
07:49:57 <jerrrry> is there a command in ghci for restarting?
07:50:16 <srhb> julianleviston: If you're in a MonadState with HelloWorld as the state, yes. 
07:50:27 <srhb> Is that the case?
07:50:35 <julianleviston> srhb: I’d have to look into Handler.
07:50:48 <julianleviston> If I look here:, it seems to be the case https://github.com/ryantrinkle/memoise/blob/lesson-8/src/Main.hs
07:50:56 <julianleviston> check out his indexHandler...
07:51:32 <julianleviston> srhb:  yeah I just checked… https://hackage.haskell.org/package/snap-0.14.0.6/docs/Snap-Snaplet.html#t:Handler
07:51:35 <srhb> julianleviston: It's quite simple, if .= is not a type error, then you are.
07:51:41 <julianleviston> it’s an instance of MonadState
07:51:52 <julianleviston> .= is not a type error
07:52:42 <julianleviston> tho I’m not sure why he writes mainTextboxContents .= Just (“…”) — like… why the Just?
07:53:18 <julianleviston> oh… maybe I have to do decodeUtf8 on it… hm… 
07:53:23 <julianleviston> let me check
07:54:02 <srhb> julianleviston: But did you switch it back to use .= instead of set?
07:54:12 <srhb> julianleviston: You'll need that to operate on the state.
07:54:23 <julianleviston> srhb: no
07:54:30 <julianleviston> ah ok
07:54:40 <julianleviston> but how do I get the particular field of the state, tho?
07:54:48 <srhb> julianleviston: They compose trivially.
07:54:57 <julianleviston> not like this? L.set (inputBlogEntry . title) netTitleData
07:55:09 <srhb> julianleviston: inputBlogEntry . title .= newTitle
07:55:11 <julianleviston> L.set (inputBlogEntry . title) newTitleData
07:55:14 <julianleviston> ahhh
07:55:17 <julianleviston> oh sweet!
07:55:42 <srhb> That's basically the entire point of lenses. :)
07:55:51 <srhb> Oh wow, I should not have said that. /ducks
07:55:53 <julianleviston> same problem tho
07:55:55 <srhb> But it is ONE point, for sure :-)
07:56:23 <julianleviston> srhb: it’s cool. I’m pretty aware of how complex they are… and a lot of the magic things you can do with them - watched a couple of EK’s talks and read a LOT of stuff about them. 
07:56:28 <julianleviston> this is just the first time I’m using them :)
07:56:35 <srhb> julianleviston: I'm guessing the parameter you get in the request is a ByteString thing, and you want Text
07:56:40 <srhb> julianleviston: You'll have to manually convert.
07:56:42 <julianleviston> still getting a BS / Text mismatch
07:56:45 <julianleviston> aha… ok cool
07:57:10 <julianleviston> is that the decodeUtf8 function?
07:57:23 <julianleviston> Data.Text.Encoding I’m guessing?
07:57:39 <srhb> Sounds right.
07:57:48 <julianleviston> cool yeah I just took a look… seems about right.
07:58:11 <srhb> Be careful though, it's only valid for actually valid UTF8 encoded bytestrings.
07:59:00 <srhb> Partial functions are scary. :)
07:59:53 <julianleviston> srhb:  woo! worked!
08:00:04 <julianleviston> srhb: why are they scary?
08:00:14 <srhb> julianleviston: Because they crash your program on invalid arguments.
08:00:19 <srhb> > head []
08:00:20 <julianleviston> srhb: ew.
08:00:21 <lambdabot>  *Exception: Prelude.head: empty list
08:00:32 <julianleviston> srhb: oh you don’t mean partial
08:00:36 <srhb> Yes, I do.
08:00:40 <julianleviston> srhb: you do?
08:00:44 <julianleviston> like this? (+1)
08:00:51 <srhb> A partial function is one which is not defined for some of its argument values
08:00:55 <julianleviston> or do you mean non-complete?
08:00:58 <srhb> No, that's just partially _applied_
08:01:02 <julianleviston> ok I’ve never heard them called that before.
08:01:08 <srhb> I mean partial. That's the correct term.
08:01:11 <julianleviston> ok.
08:01:16 <julianleviston> I learned something else new.
08:01:18 <srhb> :)
08:01:19 <julianleviston> :) thanks.
08:01:37 <julianleviston> so decodeUtf8 is partial huh?
08:01:39 <julianleviston> dang.
08:01:40 <srhb> Yes.
08:01:50 <julianleviston> yay it typechecks
08:02:10 <srhb> decodeUtf8' is complete, though.
08:02:27 <srhb> Er, total*
08:02:33 <julianleviston> god I have so many windows open
08:02:38 <srhb> In keeping with the correct terminology :-)
08:02:51 <julianleviston> thanks. :) I like it.
08:02:56 <julianleviston> God. Haskell is SO HARD.
08:02:59 <julianleviston> but I love it.
08:03:01 <julianleviston> and it’s worth it
08:03:08 <srhb> So you should use decodeUtf8 and handle the Left case.
08:03:12 <srhb> decodeUtf8'
08:03:12 <julianleviston> and it’s actually a LOT easier than trying to debug a stateball of mess.
08:03:16 <srhb> Yes, it is.
08:03:30 <julianleviston> which is basically impossible at a certain point.
08:03:32 <julianleviston> :)
08:04:26 <julianleviston> I’ve been trying to write myself a little tutorial as if I was teaching myself from the beginnig of making this web app… it’s been… itneresting :)
08:04:46 <julianleviston> not sure if it’ll be useful for anyone other than me, but maybe I’ll clean it up and make it a tutorial.
08:04:56 <julianleviston> step by tiny step.
08:06:07 <julianleviston> Not skipping steps is really hard when one of the steps is “do the splices” ;-) there’s so much involved in getting splicing working.. but wow is it nice once it’s done.
08:06:24 <srhb> I never got a hang of Heist and the splicing stuff.
08:06:46 <srhb> I prefer lucid and friends anyway.
08:06:57 <julianleviston> it’s a big jump between learning beginning stuff and BAM now you’re in the middle of 5 monads and lenses.
08:07:16 <srhb> Very true. That's why people shouldn't try to learn Haskell by making a web app, usually. :P
08:07:20 <julianleviston> I’m not sure how to mitigate that jump yet.
08:07:40 <julianleviston> srhb: :) yeah, I know. but I need to use it for my work, so I’m throwing myself in the deep end.
08:08:10 <srhb> julianleviston: That's fine. It's just a general problem that people expect to be able to do just that, because they're used to doing it whenever they learn a new (I'm basically C) language.
08:08:20 <julianleviston> I figure building a little web app shouldn’t be that hard, and so far it isn’t. I’m incredibly familiar with web apps. 
08:08:57 <julianleviston> srhb: yeah… well, I came here from smalltalk, ruby, clojure, so I’m pretty across lots of different things… 
08:09:02 * srhb nods
08:10:10 <Xnuk> > print ">_<"
08:10:12 <lambdabot>  <IO ()>
08:10:35 <Xnuk> > putStrLn " <IO ()>"
08:10:37 <lambdabot>  <IO ()>
08:11:15 <mniip> :t text
08:11:16 <lambdabot> String -> Doc
08:11:22 <mniip> > text "moo"
08:11:24 <lambdabot>  moo
08:11:39 <julianleviston> :t ...
08:11:41 <lambdabot> parse error on input ‘...’
08:11:41 <julianleviston> :t (...)
08:11:43 <lambdabot> (Applicative f, Plated c) => LensLike f s t c c -> Over p f c c a b -> Over p f s t a b
08:11:54 <srhb> Xnuk: lambdabot is forbidden from evaluating IO actions. :)
08:14:51 <julianleviston> srhb: in the same vein as this inputBlogEntry . title L..= newTitleData how would I append to a list? I’m guessing it’s not .= but rather some kind of general “run this function on this” operator?
08:15:14 <srhb> julianleviston: Correct!
08:15:27 <julianleviston> :)
08:15:32 <julianleviston> what is that function?
08:15:39 <srhb> julianleviston: And now you should try to find that operator in the lens library. I'll give you a hint and tell you that for plain stateful things it's called modify, so try to find it with that knowledge.
08:15:42 <julianleviston> I find the lenses docs kind of scary
08:15:46 <julianleviston> ok I’ll go take a look
08:16:34 <c_wraith> julianleviston: don't forget that haddocks have an index.  (It's kind of useful)
08:16:55 <srhb> julianleviston: It's in Control.Lens.Setter, under the state combinators :)
08:17:06 <julianleviston> oh I’m on the right track. 
08:17:41 <julianleviston> god the documentation is awful
08:17:58 <srhb> It's just very verbose.
08:18:08 <srhb> I think it's some of the best documentation quality on all of Hackage.
08:18:16 <julianleviston> ok (+=) then I guess
08:18:20 <julianleviston> :t (+=)
08:18:23 <lambdabot> (Num a, MonadState s m) => ASetter' s a -> a -> m ()
08:18:36 <srhb> julianleviston: The Num constraint should be a warning sign.
08:18:47 <julianleviston> srhb: all of it is a warning sign
08:18:57 <julianleviston> it’s saying “you have no idea what you’re reading”
08:19:06 <srhb> Well, lens is complex. :)
08:19:24 <julianleviston> ooh mappending a value
08:19:24 <srhb> And you're diving in the deep ind, as you said.
08:19:30 <julianleviston> (<>=) sounds good
08:19:36 <julianleviston> srhb: yep.
08:19:37 <srhb> julianleviston: It does. :)
08:19:42 <srhb> If you have a monoid at least.
08:19:54 <julianleviston> srhb: there’s not really a shallow end tho, honestly, is there...?
08:20:00 <julianleviston> srhb: I didn’t see a shallow end
08:20:10 <srhb> julianleviston: Sure. You start from the bottom instead of the top :P
08:20:29 <julianleviston> srhb: but there’s a huge jump at lenses
08:20:34 <srhb> julianleviston: Anyway, the general function is (%=) if you don't have a monoid
08:20:40 <srhb> julianleviston: Okay, that's probably true.
08:20:43 <julianleviston> srhb: I did start from the bottom :)
08:21:08 <julianleviston> srhb: the jump happens after typeclasses I think
08:21:20 <srhb> julianleviston: But maybe you would do fine with just this: https://wiki.haskell.org/LensBeginnersCheatsheet
08:21:41 <c_wraith> lenses aren't actually hard to use, but the type signatures are abstract in a way very few other libraries are.
08:21:45 <julianleviston> hm… I read that earlier I find that opaque
08:21:56 <julianleviston> c_wraith: yeah, consequently, I can’t read them.
08:22:12 <srhb> Learning to read them helps a lot. :-)
08:22:34 <julianleviston> c_wraith: it’s like most things in Haskell - it’s *really* not hard to use, however you do need to know exactly what is going on...
08:23:39 <julianleviston> isn’t [] a monoid?
08:23:47 <c_wraith> it is
08:23:48 <julianleviston> :i []
08:23:53 <julianleviston> that’s what I thought.
08:23:57 <julianleviston> cool
08:24:02 <c_wraith> lambdabot isn't ghci.  Doesn't support :i :)
08:24:06 <julianleviston> haha ok
08:24:27 <julianleviston> hm… isn’t an instance of monoid.
08:25:01 <julianleviston> how confusing
08:25:29 <c_wraith> > [1,2,3] <> [4,5,6]
08:25:31 <lambdabot>  [1,2,3,4,5,6]
08:25:47 <julianleviston> why isn’t it an instance of Monoid?
08:26:03 <julianleviston> oh… it’s not a typeclass?
08:26:09 <julianleviston> I think I’ve gone nuts
08:26:13 <c_wraith> What is "it"?
08:26:25 <julianleviston> []
08:26:31 <srhb> instance Monoid [a] -- Defined in ‘GHC.Base’
08:26:32 <julianleviston> list.
08:26:44 <c_wraith> Ah.  [a] is an instance of Monoid, but [] isn't
08:26:56 <julianleviston> oh right.
08:27:05 <julianleviston> what’s the operation? (++) ?
08:27:13 <srhb> Yep.
08:27:35 <julianleviston> what is <> ?
08:27:48 <srhb> mappend.
08:27:51 * hackagebot myo 0.2.0.0 - Haskell binding to the Myo armband  https://hackage.haskell.org/package/myo-0.2.0.0 (AlfredoDiNapoli)
08:27:59 <c_wraith> :t (<>)
08:27:59 <julianleviston> ah ok :)
08:28:00 <julianleviston> cool
08:28:01 <lambdabot> Monoid m => m -> m -> m
08:28:06 <c_wraith> :t (++)
08:28:07 <lambdabot> [a] -> [a] -> [a]
08:28:14 <julianleviston> man my ghci doesn’t have <> in it!
08:28:16 <c_wraith> For lists, they do the same thing
08:28:21 <srhb> julianleviston: It's in Data.Monoid
08:28:28 <julianleviston> duh
08:28:32 <julianleviston> I’ve been programming for too long
08:28:33 <julianleviston> thanks :)
08:29:18 <julianleviston> today I mean :)
08:30:06 <julianleviston> How come I can’t use <>= from Control.Lens ?
08:30:57 <julianleviston> oh … if it’s not a monoid. Ok. Lol
08:34:02 <stephenmac7> Is there any difference between seq and (flip const)?
08:34:20 <mniip> > (flip const) undefined ()
08:34:21 <lambdabot>  ()
08:34:24 <mniip> > seq undefined ()
08:34:25 <lambdabot>  *Exception: Prelude.undefined
08:34:29 <mniip> that's like
08:34:32 <mniip> the whole idea of seq
08:34:50 <stephenmac7> So, seq isn't lazy?
08:34:56 <srhb> stephenmac7: seq is magical, and that property cannot be expressed in the type.
08:35:14 <mniip> stephenmac7, http://hackage.haskell.org/package/base-4.8.1.0/docs/Prelude.html#v:seq
08:35:21 <srhb> stephenmac7: It's not just not lazy, it explicitly evaluates the first argument when it evaluates the second one.
08:36:30 <stephenmac7> Okay, so it seems that what I'm looking for is (flip const) instead of seq. Thanks, guys
08:36:43 <mniip> stephenmac7, what are you trying to do
08:36:51 <srhb> stephenmac7: Yeah, seq is used when you want to introduce strictness (in a dependency like way) directly. :)
08:36:59 <julianleviston> god this makes no sense to me.
08:37:03 <mniip> also have you heard of 'const id'
08:38:13 <stephenmac7> mniip: Solving this: https://github.com/NICTA/course/blob/master/src/Course/Apply.hs#L212
08:38:40 <stephenmac7> mniip: The "solution" uses const id instead of flip const
08:39:16 <mniip> const id <*>
08:39:27 <mniip> is that the solution
08:39:40 <stephenmac7> Yeah, it is
08:39:41 <mniip> hmm no
08:39:52 <stephenmac7> But it's written lift2 (const id)
08:39:57 <mniip> \x y -> const id <$> x <*> y
08:40:04 <mniip> yeah totally different thing
08:40:32 <stephenmac7> :t const id
08:40:37 <lambdabot> b -> a -> a
08:40:42 <stephenmac7> :t flip const
08:40:44 <lambdabot> b -> c -> c
08:41:55 <stephenmac7> mniip: Is there any difference?
08:42:36 <mniip> no
08:42:55 <mniip> const id x y -> id y -> y
08:43:04 <mniip> flip const x y -> const y x -> y
08:43:45 <stephenmac7> mniip: That really helped. Thanks
08:47:28 <julianleviston> kinda bogus how all the examples in Lens aren’t by themselves - they all use other parts of lens, too… non-isolation makes it very hard to understand what each of the things are doing.
08:48:54 <julianleviston> This, for example, to explain <>~ : (Sum a,b) & _1 <>~ Sum c
08:52:22 <srhb> julianleviston: How on earth would you explain a lens operator without introducing a lens?
08:52:38 <srhb> Or are you complaining about & ?
08:53:11 <julianleviston> Take this… (<>=) :: (MonadState s m, Monoid a) => ASetter' s a -> a -> m ()
08:53:18 <srhb> What's wrong with your previous example?
08:53:19 <julianleviston> waht is s, m, a there?
08:53:26 <julianleviston> ok
08:53:30 <julianleviston> take the previous example
08:53:49 <glguy> julianleviston: There's a pattern here, once you figure out one of the __= operators you understand them all
08:53:56 <glguy> once you figure out one of the ___~ operators, same thing
08:54:10 <geekosaur> also, you might want to study the State monad, because MonadState s m is actually kinda standard
08:54:13 <glguy> They don't all need individual detailed explanations
08:54:32 <julianleviston> geekosaur:  hey good point - I skipped that!
08:54:43 <julianleviston> geekosaur: I was planning on coming back to it. 
08:55:00 <julianleviston> geekosaur: but I forgot
08:55:14 <Hafydd> & is really quite independent.
08:55:19 <julianleviston> srhb: nevermind. I’m just tired.
08:55:24 <srhb> julianleviston: I think so too. :-)
08:55:40 <julianleviston> srhb: mind you, I’ve had this problem with Haskell the entired time.
08:55:43 * srhb nods
08:55:57 <julianleviston> srhb: but at a certain point, I’m not particularly helping anyone, including myself. I have the same problem with Math nomenclature too.
08:56:01 <srhb> I just think this exact complaint was a little unreasonable. Mind, what you feel is what you feel. I just disagreed with the examples :)
08:56:26 <julianleviston> srhb: my problem mainly revolves around self-referential and missing labels.
08:56:56 <julianleviston> srhb: names *really* matter, and they seem to be largely elided in Haskell, and math. That’s all.
08:57:28 <glguy> julianleviston: In your example, the important things were labeled: MonadState, Monoid, ASetter'
08:57:42 <Hafydd> Yes, the SingletonLensFactory library in Java is much better.
08:58:06 <Big_G> Hafydd, You forgot the DAOimpl
08:58:45 <julianleviston> glguy: s and m aren’t labeled. You’re supposed to know them.
08:59:14 <glguy> julianleviston: They aren't labeled because there's no more specific name for them
08:59:24 <julianleviston> glguy: but m is usually the monad, isn’t it?
08:59:32 <glguy> julianleviston: MonadState s m   tells you what s and m are
08:59:32 <Hafydd> (They are labelled: as s and m, respectively.)
08:59:53 <julianleviston> glguy: ok nevermind. I’ll go read more.
08:59:54 <glguy> There's no more specific name for them
09:01:55 <julianleviston> glguy: a good example is this… Consider a point X,Y
09:02:14 <julianleviston> glguy: now, I *know* you know that X is the horizontal point in a cartesian co-ord system… right?
09:02:28 <julianleviston> glguy: that’s a convention, tho… 
09:02:49 <srhb> Which is actually worse. There's no convention in MonadState s m. What s and m is is exactly specified.
09:03:11 <julianleviston> srhb: don’t you mean MonadState p z ?
09:03:17 <srhb> Same thing.
09:03:29 <srhb> It doesn't matter what you call them, they obey the exact same rules.
09:04:04 <julianleviston> srhb: ok. In that caes, I’ve got to go study more :)
09:04:08 <julianleviston> thanks all :)
09:04:17 <Jinxit> so I'm learning about monads slowly, are there any good ways to know that you should create a monad to solve a certain problem?
09:04:21 <julianleviston> talk to you soon, no doubt :) 
09:04:27 <julianleviston> <3
09:04:30 <srhb> julianleviston: have fun :)
09:04:32 <srhb> oh well.
09:04:49 <Zekka> Jinxit: Do you know how to know if you should use a functor?
09:04:56 <Hafydd> Jinxit: when you have operations that obey the monad laws, perhaps.
09:04:59 <c_wraith> Jinxit: monads don't "solve problems".  They're an abstraction for being able to treat lots of types the same way
09:05:12 <Zekka> Because pretty much the answer is "when it looks like you should use a functor, but you need something like 'join' a lot"
09:06:29 <Jinxit> hmm okay
09:06:32 <srhb> I usually go the other way and aggregate some transformer stack. It's rare that I need some kind of Monad that isn't described by what's already there. And then I can decide whether to make a single Monad for that purpose.
09:06:41 <srhb> And by rare I mean "that never happened to me."
09:06:59 <srhb> Turns out people are smart and made a lot of things that are useful!
09:07:01 <srhb> :-)
09:07:16 <Jinxit> you mean like using StateMonad that was mentioned earlier?
09:07:25 <srhb> Yes, State, Reader, ...
09:07:51 <Zekka> The monad types in 'transformers' are pretty broad and cover a lot of usecases: imho they don't cover quite all of them
09:08:12 <srhb> Zekka: I'm sure that's the case. I was only trying to say that I haven't personally needed to invent a new monad yet.
09:10:03 <the_2nd> How can I access all elemts of a list except the last? similar to tail
09:10:17 <srhb> the_2nd: "access" ? I think you mean init
09:10:22 <srhb> Which _drops_ the last element
09:10:30 <Zekka> the_2nd: init. Be warned, if you need to use that it might be a sign your solution is not quite right
09:10:54 <the_2nd> Zekka, https://upload.wikimedia.org/math/9/9/a/99a7fa8da2d1abbcb3fb8a5723eb75bb.png
09:10:58 <Zekka> going through a list elementwise in reverse is something you can accomplish by reversing the list and patternmatching
09:11:12 <Zekka> the_2nd: I don't know what that means
09:11:45 <the_2nd> func of [0..n] = func [0..n-1] + func[1..n]
09:12:12 <Zekka> the_2nd: OK, I follow you. Yeah, usually you would accomplish this by reversing the list, then pulling off the head and operating on the rest
09:12:25 <Zekka> Your code will probably still work if you don't do it that way, but it'll be O(n^2) instead of O(n)
09:12:40 <srhb> I don't understand where reverse came into the picture.
09:12:50 <the_2nd> so, reverse, tail, reverse?
09:12:53 * hackagebot streaming 0.1.0.17 - a free monad transformer optimized for streaming applications  https://hackage.haskell.org/package/streaming-0.1.0.17 (MichaelThompson)
09:12:54 <Zekka> Wait a second
09:13:01 <the_2nd> why would init be implemented slower than that?
09:13:13 <srhb> what I'm seeing is foo (init xs) + foo xs
09:13:15 <srhb> Why are we reversing?
09:13:30 <Zekka> srhb: Because he's going to init again immediately after
09:13:40 <srhb> But init doesn't reverse anything.
09:13:43 <Zekka> His solution is probably still right, I should be clear -- I'm trying to give a performance tip
09:14:00 <srhb> Ok, I'll shut up, clearly I've missed something important. :-)
09:14:02 <Zekka> I'm trying to give him a way to express his solution using mostly pattern matchin
09:14:49 <Zekka> the_2nd: This performance detail is a side effect of how lists are already implemented to make pulling the first element off O(1)
09:15:18 <Zekka> (there are sequence types that make both operations O(1), but they have a huge constant factor iirc)
09:15:46 <Zekka> the_2nd: Let me write an example of how to do this with pattern matching
09:15:56 <Zemyla> Zekka, off topic question, but are you a Battle Angel Alita fan? Because that's the only place I've seen the name "Zekka" before.
09:16:14 <srhb> I think we're simplifying things too much here. What are you saying about the complexity of sum (init xs) + sum xs ?
09:16:20 <Zekka> I don't know what that is. So the answer is "yes, and I'm also a Spanish rap musician and a restaurant in New York"
09:16:25 <srhb> Because there's certainly no non-constant cost from that init.
09:16:40 <Zekka> srhb: Doing just that is linear, two passes
09:16:46 <srhb> No, it's not?
09:17:01 <Zekka> srhb: How is it not? To clarify, linear is O(n)
09:17:16 <Zemyla> Ahh, okay. Also, there are ways to make deques in Haskell.  You basically have two lists, and two lengths, and you keep the lists balanced.
09:17:27 <srhb> Hmm.
09:17:37 <srhb> I mean the sums are linear, sure.
09:17:47 <Zemyla> They have an amortized push/pop time of O(1) on both ends.
09:17:50 <Zekka> In the example you gave me, I don't see anything but hte sums
09:18:02 <srhb> Right, that's what I meant. The init is still O(1)
09:18:10 <Zekka> Zemyla: Oh yeah, that works afaik
09:18:17 <Zekka> that's a simpler structure than the one I had in mind
09:18:22 <Zekka> srhb: No, init is O(n)
09:18:23 <Zekka> @src init
09:18:23 <lambdabot> init [x]    = []
09:18:23 <lambdabot> init (x:xs) = x : init xs
09:18:23 <lambdabot> init []     = undefined
09:18:33 <srhb> Zekka: Yes, but sum is forcing the list, not init.
09:18:40 <Zekka> It has to operate on every element of the list to generate a new list
09:18:42 <srhb> sum (init xs) does not traverse a list twice
09:18:55 <Zekka> srhb: Yes, but sum (init xs) + sum xs, which you asked about, does
09:18:57 <c_wraith> Init adds O(1) work to evaluating each (:) constructor
09:18:58 <srhb> Yes, sorry
09:19:01 <agocorona> String a -> Ptr a  ???
09:19:08 <srhb> I should not have included the second sum.
09:19:11 <agocorona> or ByteString a -> Ptr a ???
09:19:35 <Zekka> (c_wraith is right afaik)
09:20:53 <c_wraith> haskell's evaluation model requires more precision in expressing runtime of operations. :)
09:21:01 <srhb> agocorona: Check out Storable
09:21:47 <srhb> agocorona: And neither ByteString nor String takes a type parameter
09:22:08 <agocorona> srhb:  I checked bu my lazy reader did not find the response at first sight
09:22:21 <agocorona> ok: [a] -> Ptr a
09:22:27 <Zekka> the_2nd: FWIW I think I was mistaken that you can write this particular algorithm much faster with reverse
09:22:30 <Sindriava> How do I solve import cycles?
09:22:34 <srhb> agocorona: Well, you need an IO action in there, so that's probably why
09:22:53 * hackagebot streaming-bytestring 0.1.0.6 - effectful byte steams, or: lazy bytestring done right  https://hackage.haskell.org/package/streaming-bytestring-0.1.0.6 (MichaelThompson)
09:23:05 <kalkin-> !topic
09:23:22 <Zekka> let me finish my program and you'll see why
09:25:04 <agocorona> srhb:  ok , I found it
09:28:50 <Zekka> the_2nd: http://lpaste.net/4828139699992264704
09:31:31 <wedify> Sindriava: https://wiki.haskell.org/Mutually_recursive_modules
09:32:12 <Sindriava> wedify: Thanks ^^
09:33:15 <Sindriava> wedify: Well, that sucks. *sigh*
09:41:59 <Sindriava> wedify: Can GHC really not reason about that intelligently? I mean, the cycle I have is really not that complex
09:42:06 <Sindriava> wedify: And it's well justified, I'd say
09:42:50 <scshunt> Sindriava: the objective is to avoid having to make GHC reason about them
09:43:02 <scshunt> Sindriava: and in particular, to avoid it having to load multiple modules at once
09:43:21 <Sindriava> scshunt: Maybe I separate stuff too much, then?
09:43:24 <scshunt> the point of modules is to encapsulate compilation so that you don't need to consider them all at once, but you can consider each one as an independent entity
09:43:34 <Sindriava> scshunt: I see.
09:43:42 <scshunt> possibly
09:44:05 <Sindriava> scshunt: In that case, haskell is missing a system that allows you to split stuff into multiple files (and i *don't* want to use CPP)
09:44:20 <Sindriava> scshunt: I have a Game module, which stores the Game state and such in a monad transformer stack newtype
09:44:54 <Sindriava> scshunt: Then I have a Player file, which instances a `render` function, which has to access the reader part of the stack
09:45:05 <Sindriava> scshunt: Because it needs to fetch the renderer
09:45:31 <Sindriava> I suppose I *could* pass the renderer in as a parameter to render, but what's the point of having the reader then :/
09:46:08 <scshunt> Sindriava: that's probably what you should do
09:46:19 <Sindriava> *sigh*
09:46:27 <scshunt> Sindriava: the point of the reader is to use bind with it
09:46:38 <scshunt> because you might have another way of getting a renderer in a different transformer stack
09:47:12 <Sindriava> I guess, but this is dangerously close to not being pragmatic
09:47:16 <scshunt> e.g. what if you decide that your renderer is now stateful and you need to move it to the state part of the stack?
09:47:41 <scshunt> alternatively, you could move the rendering function to a third module
09:47:41 <Sindriava> scshunt: Fair enough, I guess.
09:47:56 <Sindriava> scshunt: That would be just ridiculous
09:48:27 <Sindriava> I suppose it will allow me to render infix, like ` renderer `render` player '
09:48:50 <scshunt> Sindriava: what do you mean by "not being pragmatic?"
09:49:13 <the_2nd> how can I overload
09:49:17 <the_2nd> 5 * myType?
09:49:49 <scshunt> the_2nd: you can't
09:51:13 <scshunt> the_2nd: you could declare a function (*) : Int -> MyType -> Something but you would have to hide the prelude's (*) to use it
09:53:45 <kadoban> Well, you can if it makes sense to convert 5 to MyType. If MyType is an instance of Num, that'd be fine.
09:54:59 <kadoban> the_2nd: So the answer is: make MyType an instance of Num ... but sometimes that's not really sane.
09:55:36 <the_2nd> kadoban, I have Vec with x and y
09:55:41 <the_2nd> and would do a
09:55:53 <the_2nd> Vec{x=5, y=5} * myVec
09:56:08 <the_2nd> * + myVec
09:56:18 <kadoban> Sounds doable then.
09:57:23 <the_2nd> do the overloads have to return the same type?
09:57:38 <the_2nd> or can abs myType return Double?
09:57:43 <kadoban> :t (*)
09:57:45 <lambdabot> Num a => a -> a -> a
09:57:47 <exio4> @type abs
09:57:50 <lambdabot> Num a => a -> a
09:57:54 <the_2nd> aw
09:57:55 <exio4> the_2nd: apparently, it needs to be the same type
10:13:57 <kalkin-> I am using HXT for pickling/unpickling XML. I want to use the xml elements name as paramter for my pickle function. But how can i get the name of the currently pickled element? 
10:16:52 <adas> while browsing the documentation, the frame view usually has a synopsis of functions and types available in the docs on the lower bottom left side. But when I build the docs using `stack haddock` in my project dir, the synopsis is missing. Is there some way to get it back?
10:21:16 <adas> https://imgur.com/zwhtczL <- this is what I mean
10:21:29 <adas> that is a screen shot of the docs built by `stack haddock`
10:23:00 <adas> https://imgur.com/k6GmA41 <- and this is the standard haskell docs
10:24:46 <adas> can someone please tell me how to get the synopsis in the docs generated by haddock?
10:27:00 <adas> anyone?
10:28:54 <phaazon> adas: yep?
10:29:40 <phaazon> ah
10:29:54 <phaazon> adas: I never actually succeeded to have it in my html/ rep either
10:30:01 <phaazon> it only appears on hackage
10:30:09 <phaazon> it might be an option to pass to haddock, I guess
10:31:33 <adas> phaazon: searching haddock docks. but i can't seem to find any option that would do that.
10:32:02 <phaazon> :/
10:32:06 <phaazon> I have no idea then
10:32:08 <phaazon> sorry pal
10:32:53 <geekosaur> I have seen that and think it is a haddock bug
10:33:10 <geekosaur> xmonad haddocks have a bunch of truncated listings
10:34:28 <adas> that synopsis is so useful to just get to what you want instead of browsing thru the entire doc
10:36:05 <geekosaur> right, I am seeing a number of haddocks which have them but the last function is missing, too
10:36:49 <geekosaur> so I'm going with haddock bug
10:37:15 <Gurkenglas> How should I write "sequenceA [[f, id], [g, id], [h, id]] `forM` \[f, g, h] -> do" such that it ends on "\f g h -> do"?
10:38:10 <socumbersome> Hi. If the keyword 'forall' is implicit in type declarations (so `a -> a` is same as `forall a. a -> a`), then why isn't `data T = forall a. MkT a` the same as `data T a = MkT a` ?
10:39:03 <geekosaur> socumbersome, it is scoped. but it is also passed in
10:39:19 <monochrom> that is a strange question, conflating two worlds.
10:39:27 <geekosaur> likewise if I write a function and name a parameter, the parameter name's scope is my function but I can still pass it from outside
10:39:54 <monochrom> if you stick to Haskell 2010, then "'forall' is implicit" is true, but you don't get to ask about "data T = forall a. MkT a", since that's illegal.
10:40:35 <monochrom> if you turn on ExistentialQuantification, then "data T = forall a. MkT a" is legal. but then you are stepping outside of Haskell 2010.
10:40:53 <geekosaur> this is the difference between "function foo(a) { ... }" and "function foo() { local a; ... }"
10:41:34 <ggole> socumbersome: the kind is the same for a -> a and forall a. a -> a, but different for your datatype example
10:41:47 <geekosaur> in both cases, the scope of the name "a" is the function. but in one of them it is a parameter. "data T a =" makes a a parameter to the type
10:42:52 <socumbersome> hmm, so it's like, there is a "type-level lambda" when having `data T a = MkT a`, but with the explicit 'forall' this lambda is in the data constructor?
10:42:56 * hackagebot log-domain 0.10.3 - Log-domain arithmetic  https://hackage.haskell.org/package/log-domain-0.10.3 (EdwardKmett)
10:42:58 * hackagebot semigroups 0.17 - Anything that associates  https://hackage.haskell.org/package/semigroups-0.17 (EdwardKmett)
10:43:02 <geekosaur> yes
10:43:55 <geekosaur> I think GADT synbtax might make this clearer, actually?  data T a where MkT :: a -> T a        vs.   data T where MkT :: forall a. T a
10:44:07 <sbrg> given a type signatgure like: foo :: Enum a => Functor a; is it not possible to do something like: foo = map bar (enumfrom (toEnum 0 :: a)) ?
10:44:20 <geekosaur> er
10:44:40 <sbrg> that is, use whatever type it choices for a?
10:44:41 <socumbersome> hm, I think I get it, but the name probably confuses me -- why "forall" and not something like "bindvar"? :)
10:44:46 <monochrom> data T where MkT :: a -> T
10:44:56 <geekosaur> not exactly, the forall is hidden inside the implementation on that second, nbot in the type signature
10:44:56 <srhb> sbrg: What does Enum a => Functor a even mean?
10:45:10 <srhb> sbrg: Constraints go on the left hand side of =>
10:45:29 <geekosaur> socumbersome, lambda calculus
10:45:36 <sbrg> srhb: yeah I know, that was silly of me. I just meant to indicate that what I am dealing with is a Functor, nvm. 
10:46:06 <srhb> sbrg: But do you mean a Functor f which is also Enum f? I don't know what that would be.
10:46:08 <geekosaur> ∀a. ...
10:46:20 <srhb> sbrg: Or do you mean (Enum a, Functor f) => f a ?
10:46:27 <sbrg> the latter, yes.
10:46:38 <sbrg> which doesn't really matter as such so it was silly of me. 
10:46:42 <geekosaur> but without UnicodeSyntax extension we write ∀ as forall
10:47:15 <voidzero> without?
10:47:30 <voidzero> oh
10:47:35 <geekosaur> with itm we can write the ∀
10:47:36 <voidzero> nvm. 
10:47:47 <voidzero> yes. My brain misparsed. :)
10:47:56 * hackagebot half 0.2.1 - Half-precision floating-point  https://hackage.haskell.org/package/half-0.2.1 (EdwardKmett)
10:47:58 * hackagebot reducers 3.12 - Semigroups, specialized containers and a general map/reduce framework  https://hackage.haskell.org/package/reducers-3.12 (EdwardKmett)
10:48:12 <voidzero> I just read this essay
10:48:14 <voidzero> http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/
10:48:34 <geekosaur> unicode has lots of dark corners >.>
10:48:37 <sbrg> but wnat I want to do is, given the inferred type(which is chosen via context when I use this function), do something like: f :: (Enum a, Show a) => SomeFunctor a; f = functorify $ map show (enumFrom (toEnum 0 :: a))
10:48:44 <geekosaur> and politics and ...
10:48:56 <socumbersome> geekosaur, ok, but when you say that forall is hidden inside the implementation -- so, like... where in the implementation, more or less? :) 
10:49:00 <voidzero> yes, I am now scared for all of them
10:49:07 <geekosaur> sbrg, it sounds to me like you want ScopedTypeVariables
10:49:27 <geekosaur> socumbersome, I meant it has to be more like data T where MkT :: T; MkT = forall a. T a
10:49:33 <geekosaur> er, no
10:49:33 <srhb> sbrg: I mean, enumFrom (toEnum 0) is already Enum a => [a]
10:49:46 <srhb> sbrg: The problem is, how do you transform a list to an arbitrary different functor?
10:50:35 <srhb> That doesn't even make sense, sorry
10:50:43 <srhb> An arbitrary different Functor a :)
10:50:58 <geekosaur> I think I actually meant: data T where MkT :: forall a. a -> T
10:51:16 <sbrg> geekosaur: hmm
10:51:43 <srhb> > enumFrom (toEnum 0) :: [Bool] -- just to make that clear
10:51:45 <lambdabot>  [False,True]
10:51:50 <geekosaur> where the a is something visible only within MkT and not within the type, as opposed to something visible from outside; you cannot usefully get at the "a" by pattern matching
10:52:09 <geekosaur> (unless you add some constraints, and those constraints give you useful functions; Typeable can be useful here...)
10:52:18 <sbrg> srhb: This makes perfect sense. What I am doing is taking any Show-, Read- and Enumerable type, generating all its possible values, converting them to strings, then creating a parsec parser for them(string value), and then read <$> result
10:52:49 <sbrg> I can't see how anything here should be ambiguous(to the type system)
10:52:57 <socumbersome> oh, ok, makes sense. So data constructors are like normal lambdas (so they sometimes happen to be polymorphic, but in some cases it's not possible implicitly and that's why we need 'forall there)? Kind of :D
10:53:33 <geekosaur> I'm trying to figure out how to describe this. in the first case, we represent a as part of the type
10:53:46 <int-index> > (\s0 a -> (\s b -> (r . (a:&) . (b:&)) s) s0)
10:53:48 <lambdabot>      Not in scope: data constructor ‘:&’
10:53:48 <lambdabot>      Perhaps you meant one of these:
10:53:48 <lambdabot>        ‘:+’ (imported from Data.Complex),
10:53:54 <geekosaur> so we know the type of a any time we have a value of that type
10:53:55 <srhb> sbrg: I don't see why you would need anything but Read for that... But maybe I'm just confused. :)
10:54:10 <int-index> how do I ask lambdabot to simplify an expression?
10:54:34 <sbrg> srhb: oh.. my god
10:54:42 <srhb> int-index: I don't think there is such a thing. You can undo pointless, though.
10:54:49 <sbrg> I was thinkign "I'm doing this in parsec" the whole time and I didn't .. oh my god
10:54:53 <srhb> sbrg: I hope that's a good thing? :-)
10:54:58 <geekosaur> in the second, the type is only visible in the constructor. this in particular means that if you pattern match the constructor, you *lose* the type --- unless you have a constraint on it, in which case you can use anything from the constraint (you may need to use GADT syntax though)
10:55:06 <sbrg> srhb: yes. thanks. I am a complete idiot, lol.
10:55:07 <int-index> @pl (\s0 a -> (\s b -> (r . (a:&) . (b:&)) s) s0)
10:55:07 <lambdabot> flip (flip . ((r .) .) . (. (:&)) . (.) . (:&))
10:55:20 <srhb> sbrg: That's nice, recovering from idiocy is usually a great experience. :D
10:55:26 <geekosaur> that is, if at some point I say foo (MkT a) = ... the compiler will error because a cannot be given a type
10:55:45 <geekosaur> it only existed when the MkT was created, and disappeared afterward
10:56:01 <socumbersome> but isn't T a lambda as well? I mean, having data T a = MkT a, first occurrence of 'a' can be thought as a parameter, but why not as just value put to 'T lambda'?
10:56:02 <geekosaur> but if we have data T a = forall a. Show a => MkT a
10:56:47 <geekosaur> then we can get the Show instance by pattern matching. of course the only thing you can do with it is suff defined by Show, so this is not very useful
10:57:07 <srhb> sbrg: (I'm kidding, obviously I hope, I don't think you're an idiot. :P)
10:57:26 <geekosaur> with (for example) Typeable, we can extract a representation of its actual type, and use cast; this is used by things like aeson that need to be polymorphic
10:57:58 <delYsid> What the heck does this error mean please? "Non type-variable argument in the constraint: Stream s m Char"
10:58:02 <geekosaur> T is a type lambda
10:58:22 <geekosaur> delYsid, standard Haskell only allows things to be type variables there
10:58:46 <socumbersome> hmmm, so could I write: forall a. data T a = MkT a ?
10:58:50 <delYsid> so why does :t give me such a sig then? :-)
10:59:15 <socumbersome> and even if I cannot - should this, intuitively, be the same as "data T a = MkT a" ?
10:59:21 <geekosaur> delYsid, older versions of ghc would silently let you work with types that were built with an extension
10:59:44 <sbrg> srhb: don't worry, I was being an idiot. It's like I got from A to B by walking across the entire earth when I started out standing to B lol
10:59:51 <sbrg> next to B*
10:59:52 <srhb> sbrg: :D
11:00:02 <geekosaur> current versions require you to also turn on that extension yourself (FlexibleContexts, in this case)
11:01:02 <geekosaur> socumbersome, you can;t because ghc can;t really do type lambdas as such yet, and doesn't support forall there
11:01:05 <delYsid> hmm. so what is the correct way to proceed?  I am trying to define a ParsecT parser that does "satisfy (== someChar) *> return Type", i.e., it parses Char as input but returns a different type as result
11:01:08 <geekosaur> this ... is somewhat complex
11:01:20 <geekosaur> delYsid, {-# LANGUAGE FlexibleContexts #-}
11:01:24 <geekosaur> at the top of your source
11:01:53 <socumbersome> geekosaur, but if it did, is my reasoning correct?
11:01:56 <geekosaur> this is not a particularly dangerous extension, but the haskell standard is rather conservative
11:02:00 <delYsid> geekosaur: ah, so Parsec is built with an extension I need to enable in my Module?
11:02:27 <geekosaur> delYsid, yes
11:02:34 <delYsid> geekosaur: thanks!
11:02:38 <geekosaur> it has FlexibleContexts enabled
11:03:07 <geekosaur> and while it used to be possible to "inherit" that extension, these days ghc is pedantic about standards confrmance and you need to turn it on explicitly yourself
11:03:37 <geekosaur> socumbersome, if ghc were handling types inthat direction then yes
11:03:56 <geekosaur> however the story is actually a bit more complex. types themselves have "types", which ghc calls "kinds"
11:04:49 <geekosaur> kind polymorphism, as distinct from type polymorphism, is still in development
11:04:55 <geekosaur> and I think will not use forall
11:04:55 <MarcelineVQ> :k Functor
11:04:56 <lambdabot> (* -> *) -> Constraint
11:05:51 <geekosaur> (that said, my understanding starts going away pretty quickly once we get into that kind of stuff..._
11:11:12 <bzm3r> \help
11:13:01 <Gurkenglas> Kind polymorphism? Like, IdentityT is specialized Identity?
11:17:57 * hackagebot void 0.7.1 - A Haskell 98 logically uninhabited data type  https://hackage.haskell.org/package/void-0.7.1 (EdwardKmett)
11:22:57 * hackagebot semigroups 0.17.0.1 - Anything that associates  https://hackage.haskell.org/package/semigroups-0.17.0.1 (EdwardKmett)
11:24:53 <qq> Hi everyone. I've stubled upon a case wich seemed quite obvious, yet GHC couldn't help me. Please see http://ideone.com/s0p9Kt
11:25:24 <cow_2001> line 76 says ClassOpI accepts 3 arguments, but 4 provided. https://hackage.haskell.org/package/QuickCheck-2.8.1/docs/src/Test-QuickCheck-All.html
11:25:38 <qq> What am I doing wrong?
11:26:32 <EvanR> qq: youre trying to make a multiparameter type class without a functional dependency or type family
11:26:41 <cow_2001> how do i install a package in cabal sandbox after i change a bit of its source?
11:27:27 <geekosaur> cow_2001, cabal sandbox add-source /path/to/your/source
11:27:27 <qq> Yes, functional dependencies solve the issue, but they ruin the purpose of the Has class.
11:27:38 <cow_2001> geekosaur: you're an angel!
11:27:43 <cow_2001> thanks!
11:28:37 <EvanR> qq: the way type classes work normally, the compiler has to be able to identify the instance unambiguously from the combination of types involved
11:30:30 <EvanR> I'm not sure what the purpose of the Has class is in practice?
11:30:48 <EvanR> isn't it better to use the type a -> b
11:30:48 <qq> It's just an experiment.
11:31:51 <hackrilege> Seems unidiomatic
11:32:22 <EvanR> the class Convertible is similar and is used in practice sometimes
11:33:06 <EvanR> class Convertible a b where safeConvert :: a -> ConvertResult b
11:33:42 <EvanR> it doesn't use functional dependencies, but doesnt try to make an instance like instance (Convertible a b, Convertible b c) => Convertible a c
11:34:13 <hackrilege> Wow that class has a lot of instances
11:34:26 <EvanR> which makes sense
11:34:30 <qq> Ideomatic or not, but I don't see the ambiguty unless there are overlapping instances. Due to some reason GHC substitutes b in the second constraint by b0
11:35:32 <hackrilege> @src fix
11:35:32 <lambdabot> fix f = let x = f x in x
11:36:17 <hackrilege> @src hylo
11:36:17 <lambdabot> Source not found. :(
11:36:45 <EvanR> 7.6.3.1. Instance resolution of https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-class-extensions.html might help
11:37:41 <Saizan> qq: it's complaining because 'b' won't appear in the argument or result type of the methods you define
11:37:43 <hackrilege> @src Data.Fix.hylo
11:37:43 <lambdabot> Source not found. My brain just exploded
11:38:01 <EvanR> one fact that might help is that even if you think your instance is unambiguous, ghc will also have to work no matter what other instances are added later in another module
11:38:08 <hackrilege> help...
11:38:33 <Saizan> qq: you can use that AllowAmbiguousType flag, i suspect in the end instance resultion will just loop though
11:39:23 <qq> Now I see. Too bad. But such instance makes sense, doesn
11:39:28 <qq> 't it?
11:39:47 <Saizan> not even because of the ambiguity, just because nothing is decreasing in that instance, transitivity is well known to cause problems
11:39:49 <EvanR> its equivalent to using get . get right
11:40:30 <hackrilege> @src Control.Morphism.Hylo.hylo
11:40:31 <lambdabot> Source not found. The more you drive -- the dumber you get.
11:40:36 <Saizan> qq: purely semantically i guess so, but it's not a good strategy to build "Has" dictionaries
11:40:46 <hackrilege> Right...
11:40:49 <Saizan> qq: also, it overlaps with any other instance
11:41:15 <EvanR> hackrilege: the @src command doesnt lookup anything for real, it just has a carefully crafted text file of selected functions
11:41:22 <hackrilege> Aha
11:41:26 <hackrilege> Thanks
11:41:30 <Saizan> qq: and would require GHC to guess through which types you want to go through when there's more than one possibility
11:41:51 <hackrilege> hylo f e g = f . e . fmap (hylo f e g). g
11:42:06 <hackrilege> What is this mess?
11:42:58 * hackagebot foldl-transduce 0.4.2.0 - Transducers for foldl folds.  https://hackage.haskell.org/package/foldl-transduce-0.4.2.0 (DanielDiazCarrete)
11:43:29 <monochrom> I wonder why we don't simply merge f and e, i.e., hylo2 fe = fe . fmap (hylo2 fe g) . g
11:43:44 <monochrom> since hylo f e g = hylo2 (f . e) g
11:44:20 <monochrom> err, hylo2 fe g = fe . fmap (hylo2 fe g) . g
11:45:29 <c_wraith> monochrom: only makes sense to me if it's a typeclass function
11:45:32 <monochrom> anyway, it looks like "pass your parameter to g; it produces a list/tree/whatevercollection of items; use recursion on each item; postprocess the whole by fe"
11:46:04 <hackrilege> f . e . fmap (f . e . fmap (...). g). g
11:47:17 <monochrom> no, don't unfold. unfolding has never really helped anyone to understand anything.
11:47:42 <hackrilege> But that's what it does....
11:47:55 <monochrom> ok, that's a lie. unfolding helps in the simplest and most trivial cases
11:48:12 <hackrilege> It's the for after the bracket that gets me...
11:48:26 <cow_2001> why did you move from hpaste?
11:48:34 <c_wraith> hackrilege: it's better not to unfold it.  It's just "fmap the thing that magically works properly"
11:48:36 <hackrilege> For, not for, sorry
11:48:47 <hackrilege> Dot rather...
11:49:19 <c_wraith> cow_2001: the whole channel?  hpaste was unmaintained for some time.  lpaste was introduced to fix some of its problems.  hpaste's owner decided to just make their site redirect to lpaste instead
11:49:37 <c_wraith> cow_2001: in particular, hpaste used takusen, which didn't really work properly.
11:49:41 <cow_2001> ah
11:49:52 <delYsid> When do I use Text.Parsec.Parsec, and when Text.Parsec.ParsecT?
11:50:06 <hackrilege> Yeh I don't see what flap is being applied too...
11:50:12 <cow_2001> PipePaste it is
11:50:14 <hackrilege> Fmap...
11:50:35 <EvanR> class Flunctor
11:50:38 <monochrom> delYsid: my http://www.vex.net/~trebla/haskell/parsec-generally.xhtml#monad shows some uses of ParsecT
11:50:40 <EvanR> flap ::
11:50:55 <monochrom> but at the end it's your call.
11:51:31 <qq> Aha, got it finally.
11:51:32 <qq> It'
11:51:42 <c_wraith> delYsid: Parsec and ParsecT are the same thing.  Parsec is just a slightly simplified interface for when you don't need the additional power.
11:52:05 <qq> The diamond problem arises here.
11:52:30 <hackrilege> f a b = a . (fmap (f a b)) . b
11:53:00 <hackrilege> so i get a.a.a....b.b.b
11:53:39 <hackrilege> when will i reach a fixed point?
11:54:24 <drewbert> scalac makes ghc look speedy
11:54:29 <EvanR> you mean you get a . (fmap (a . fmap (...) . b) . b
11:54:41 <c_wraith> hackrilege: you don't need to, because fmap handles various cases itself
11:54:42 <hackrilege> sorry i missed the fmaps
11:54:44 <monochrom> when you reach a function h that satisfies "h = fe . fmap h . g", you reach a fixed point
11:54:57 <EvanR> hackrilege: at any point fmap might ignore its argument
11:55:24 <EvanR> or pass it to something that ignores it
11:55:29 <hackrilege> im not sure I understand that c_wraith
11:57:18 <hackrilege> And what do you mean by it when you say pass it to something which ignores it?
11:57:48 <EvanR> you should work some examples picking a particular non-trivial functor
11:57:50 <hackrilege> I get that a fixed point is one where the function acts as id
11:57:57 <EvanR> and evaluate it by hand and see how it works
11:58:12 <EvanR> use Maybe for example
11:58:13 <hackrilege> It was not helpful
11:58:36 <hackrilege> I did not understand how it reached the fixed point
11:59:36 <hackrilege> And so it was unclear which function could be used with hylo
11:59:52 <hackrilege> Out how to identify such functions
11:59:59 <hackrilege> Or...
12:00:00 <EvanR> does it matter which functions you use? the behavior of fmap is whats important
12:00:12 <EvanR> thats where the recursion is going on
12:00:49 <hackrilege> So if gmail is just map because we are using a list add our Functor...
12:00:58 <hackrilege> Fmap...
12:01:13 <hackrilege> As...
12:01:21 <hackrilege> Sorry
12:01:25 <monochrom> gmail is fmap? what is this magic?
12:01:37 <EvanR> google does it again
12:01:46 <hackrilege> Mobile keyboard...
12:02:39 <hackrilege> It detects my most used words, fmap should be the default before long
12:03:45 <EvanR> hylo length (replicate 5) []
12:03:48 <EvanR> 5
12:03:50 <EvanR> seems legit
12:04:04 <hackrilege> Great stuff
12:04:40 <hackrilege> Hmm no I don't like this
12:04:46 <cow_2001> ding. pastepipe won't work :(
12:05:08 <hackrilege> Your asking for the length of a list infinity many times?
12:05:30 <EvanR> so i used this def
12:05:32 <EvanR> hylo f g = f . fmap (hylo f g) . g
12:05:50 <monochrom> if it terminates and spits out "5", it can't be doing anything infinitely many times
12:06:30 <hackrilege> Omg no your asking for the length of a list of 5 ellements which are lists of five elements which are lists of five....
12:06:50 <hackrilege> Is that right?
12:07:04 <monochrom> did you know that "fmap whatever []" terminates and gives, simply, []?
12:07:24 <hackrilege> And it terminates because it only I'd lazy and does not care what the elements are?
12:07:26 <monochrom> err, nevermind
12:07:33 <EvanR> hylo length (replicate 5) [] = length . map (hylo length (replicate 5)) . replicate 5 $ []
12:07:46 <monochrom> yeah, this is a good time to unfold
12:07:52 <EvanR> = length . map(hylo length (replicate 5)) $ [[],[],[],[],[]]
12:08:25 <dbushenko> paf31, hi!
12:08:29 <EvanR> = length $ ???
12:08:36 <EvanR> where ??? is 5 length
12:08:38 <dbushenko> oops, wrong channel
12:08:39 <EvanR> 5
12:08:39 <hackrilege> Exactly
12:08:58 <EvanR> you can carry out the ??? yourself
12:09:50 <hackrilege> It's just length map length map .... Replicate 5 replicate 5.... Empty list
12:10:22 <EvanR> after 2 levels i believe it can evaluate the first length
12:10:46 <EvanR> @src length
12:10:46 <lambdabot> Source not found. You type like i drive.
12:11:17 <hackrilege> So every nested list of five nested lists wool have length mapped onto it and each will return five, making a list of five elements all of which are the number five and keep going until we ask for the length of the outer list
12:11:36 <EvanR> because of lazy evaluation it never evaluates most of that
12:12:18 <hackrilege> So I should be able to use hylo when I do not need to know the contents of the later recursion?
12:12:32 <hackrilege> It seems unformal
12:12:39 <EvanR> i have no idea what hylo is good for
12:12:55 <hackrilege> It's very important for me
12:13:32 <OnkelTem> Hi all. I'm still installing GHC and I decided to build it from source. I'm following instructions from here: https://ghc.haskell.org/trac/ghc/wiki/Building . And at the first step (Setting up your system for building GHC) I see very strange thing: to get build environment I need to install haskell-platform.
12:13:33 <hackrilege> But it's kind of protected ip
12:13:34 <EvanR> so yeah i guess the choice of f and g matter
12:13:49 <OnkelTem> But haskell-platform depends on ghc. What is that?
12:14:05 <OnkelTem> So to build ghc I need ghc?
12:14:09 <BCraig> Hi ! can anyone help me  ? I don't know how to group various types
12:14:28 <kadoban> OnkelTem: Why are you building it from source? (don't)
12:15:02 <hackrilege> And shouldn't it just need a c compiler
12:15:10 <nitrix> OnkelTem: Correct, GHC is self bootstrapped because it's written in Haskell.
12:15:14 <kadoban> OnkelTem: In fact you should just skip all of that. Install https://github.com/commercialhaskell/stack and it will handle installing GHC for you when it needs to and etc.
12:15:14 <OnkelTem> kadoban: why not?
12:15:18 <EvanR> hackrilege: nope
12:15:31 <hackrilege> What do you mean bcraig?
12:15:33 <kadoban> OnkelTem: It's kinda fiddly and doesn't gain you anything.
12:15:41 <OnkelTem> kadoban: ok, I can do this either. But what is wrong with all that? I just don't get 
12:16:13 <nitrix> OnkelTem: GHC is written in Haskell, so one needs an inferior or similar version of GHC to compile the next version of GHC.
12:16:17 <kadoban> Not sure I understand the question.
12:16:26 <OnkelTem> nitrix: omg
12:16:39 <lpaste_> BC pasted “multiple types function” at http://lpaste.net/140852
12:16:47 <EvanR> good thing you dont need the next version of GHC to compile this one
12:16:49 <hackrilege> Ok well thanks for the example evanr but I really have no idea when i can use hylo
12:17:31 <BCraig> can anyone help me with this please ? http://lpaste.net/140852
12:17:35 <OnkelTem> And what if I had a linux disrto with no prebuilt ghc?
12:17:43 <nitrix> OnkelTem: All compilers that are self bootstrapped works like this. You need to get your hands on the official binary from someone that already went through the full bootstrapping process. This is documented on the wiki, trust me, you don't want to compile it from sources yourself. Just use your package manager from your distro.
12:17:49 <dmwit> BCraig: What does "group" mean? I'll look at your paste.
12:18:10 <fvgvxmpv1> BCraig: that looks like you want to use typeclasses
12:18:22 <hackrilege> The idea of the fixed point still eludes me, I guess since length ignores contents I see how lazy evaluation saves us from infinity in this case, bit normally I'm sure I'd like to check the contents and terminate the recursion with a function returning a bool
12:18:25 <EvanR> hackrilege: depending on what fmap does, one thing you need to watch out for if the first function inspecting the entire result
12:18:32 <OnkelTem> nitrix: okay, thanks. I thought that Linux kernel, Xorg and Emacs are pretty tricky to compile. Now I see how that was wrong
12:18:36 <BCraig> typeclasses ?
12:18:42 <dmwit> BCraig: You probably want something like `data Foo = Paty TipoDePaty | Superpancho Pancho | Gaseosa TipoDeGaseosa`.
12:18:51 <dmwit> BCraig: I think typeclasses are a bad hammer to hit this screw with.
12:19:03 <Algebr> I see this  "<" <> s <> ">" and I'm using overloaded strings. Is this concat for the overloaded text string?
12:19:20 <dmwit> Algebr: yes
12:19:27 <EvanR> hackrilege: any algorithm which requires checking the entirety of an infinite structure wont terminate
12:19:33 <dmwit> Algebr: (<>) is the Monoid operation, which for the common IsString instances is concatenation.
12:19:37 <hackrilege> Not the whole contents, just until I am satisfied...
12:20:01 <BCraig> dmwit: im gonna try that now
12:20:13 <OnkelTem> Can't way to finally write my first "hello, world" proggy on Haskell :)
12:20:16 <hackrilege> Normally I would provide a base case to a recursion
12:20:33 <t7> OnkelTem: main = putStrLn "Hello World"
12:20:53 <Qndel> hello
12:20:54 <t7> now you can try fizzbuzz
12:21:04 <dmwit> Hi, Qndel!
12:21:09 <OnkelTem> t7: that is of course fine! But I want it myself :) 
12:21:11 <Algebr> dmwit: thanks
12:21:15 <Qndel> Guys I need your help!
12:21:19 <EvanR> t7 you ruined it all for him
12:21:29 <dmwit> Qndel: No need for a preface. Just go ahead and ask your question.
12:21:33 <Qndel> I have to write a game in haskell
12:21:45 <Qndel> I've been programming in C++ and other languages for years but haskell is a nightmare for me
12:21:57 <Qndel> is there somebody willing to do it for me if I pay? ^ ^
12:22:01 <EvanR> lol
12:22:02 <btipling> learn you a haskell is such a great book, I'm reading it now
12:22:10 <Qndel> but I don't have time
12:22:13 <nitrix> Qndel: Which part of it is a nightmare?
12:22:16 <OnkelTem> Qndel: nightmare! Lol
12:22:16 <srhb> Qndel: There are a few Haskell job sites out there where you can post such an inquiry. :)
12:22:20 <exio4> BCraig: nice names there
12:22:24 <foboo> I'm trying to do something that is basically subtypes (mainly just for fun). So I've got a nested sequence of families, say Foo A1, Foo A2, ... Foo An. Foo Am is a subset of Foo A(m+1), but the compiler can't figure that out. I want to use types in Foo Am as types of Foo A(m+1). I could explicitly map them for each m (because the compiler is smart enough to check that, say,
12:22:25 <foboo>  A of type Foo Am has type Foo A(m+1) for an explicit A) but that's gross. Can I make some declaration like "forall a, a :: Foo Am => a :: Foo A(m+1)" to tell the compiler that this subtype condition actually holds?
12:22:30 <OnkelTem> btipling: ++
12:22:32 <srhb> And I can tell you that many people will be jumping at the opportunity if the pay is fair :)
12:22:42 <Qndel> so far I've managed to display a simple cube
12:22:42 <dmwit> Qndel: "I have to write a game in Haskell" sounds like a school assignment.
12:22:47 <Qndel> yup it is
12:22:52 <monochrom> OnkelTem: https://www.haskell.org/ghc/download_ghc_7_10_2#binaries has good stuff
12:22:53 <dmwit> Qndel: What you are asking is unethical.
12:22:59 <nitrix> Then you should do the assignment.
12:23:05 <dmwit> Qndel: If I were a mod here, I would probably kick you right now.
12:23:10 <BCraig> dmwit: thank you, it worked
12:23:14 <hackrilege> game = getLine>>= putStrLn >>= game
12:23:15 <dmwit> BCraig: Great!
12:23:17 <EvanR> channel rules, no unethicalness
12:23:18 <Qndel> I'm trying to do it myself but I can't
12:23:31 <EvanR> for some value of unethical
12:23:33 <dmwit> Qndel: We will be happy to help you past some hurdles.
12:23:38 <Qndel> ok
12:23:39 <OnkelTem> monochrom: above was posted more friendly thing - https://github.com/commercialhaskell/stack . Following it now
12:23:40 <Qndel> for example this
12:23:47 <Qndel> I have some code that works
12:23:50 <BCraig> exio4: that are local foods name from Argentina
12:23:55 <Qndel> I copy paste the code and modify 1 function and it doesn't work
12:24:04 <nitrix> -What- dosn't work?
12:24:04 <hackrilege> >> rather
12:24:11 <Qndel> its just black magic for me
12:24:13 <dmwit> ?paste some code, along with the exact error message
12:24:14 <lambdabot> Haskell pastebin: http://lpaste.net/
12:24:20 <exio4> BCraig: I know, soy argentino :P 
12:24:31 <EvanR> Qndel: I'll do it if you pay me and I also get the credit hours
12:24:37 <srhb> Qndel: It often help if you go back to basics if you've no experience with Haskell. There are a lot of great beginners' materials out there, which we can point you at. :)
12:24:47 <srhb> Qndel: Or if you have specific questions, we can help you with those.
12:24:50 <BCraig> exio4: So why do you speak in english ? 
12:24:54 <dmwit> ?where tutorials
12:24:55 <lambdabot> http://haskell.org/haskellwiki/Tutorials
12:24:55 <Qndel> http://lpaste.net/140853
12:24:56 <srhb> Qndel: "Haskell is black magic" doesn't help us help you. :)
12:25:03 <nitrix> Qndel: That's the case for literally every language out there. It's not specific to Haskell. Provide more information.
12:25:11 <BCraig> exio4: Im just starting learning haskell, for the "facultad"
12:25:11 <nitrix> Is black magic a side-effect?
12:25:17 <Qndel> yeah but haskell is worse than every other language combined
12:25:26 <srhb> Qndel: It's just different.
12:25:27 <EvanR> haskell is pure, nothing black about it
12:25:32 <nitrix> Qndel: Based on what?
12:25:39 <srhb> Qndel: You can't expect to transfer all your previous knowledge to it. :)
12:25:43 <dmwit> Qndel: Line 19 looks like it's indented too far.
12:25:43 <Qndel> I don't
12:25:48 <Qndel> really?
12:26:02 <nitrix> Qndel: You're making claims that have no foundation.
12:26:04 <exio4> BCraig: which uni? UTN? and well, I don't think other people would like us talking in spanish :P 
12:26:10 <dmwit> Qndel: Haskell's tabs are eight spaces wide.
12:26:17 <dmwit> Qndel: I would bet your editor has tabs set to two spaces.
12:26:26 <Qndel> thx lol
12:26:27 <dmwit> Qndel: So that it looks correct in your editor, but different to the compiler.
12:26:29 <Qndel> it compiled
12:26:31 <Qndel> I know
12:26:32 <BCraig> exio4: for the UNQ ( Quilmes University )
12:26:33 <Qndel> it's so confusing
12:26:41 <dmwit> Qndel: I strongly suggest having a look through the editor configuration section of http://dmwit.com/tabs
12:26:44 <exio4> oh, nice! 
12:26:47 <monochrom> I don't think it's worthwhile to debate with Qndel
12:26:52 <Qndel> I started to appreciate the C++'s brackets ; (
12:27:04 <dmwit> Qndel: You may use explicit brackets and semicolons if you wish, of course.
12:27:04 <BCraig> exio4: and im sorry for everyone here, but i hate haskell 
12:27:08 <Qndel> anyway
12:27:15 <Algebr> this channel gets lots of trolls I see.
12:27:24 <srhb> I think people are being a bit quick to judge here.
12:27:25 <exio4> BCraig: wow, rude, it's not that bad though :P 
12:27:27 <Qndel> what data structure would you suggest for storing a 2d map?
12:27:39 <Qndel> I just want to write this game and forget about haskell
12:27:39 <monochrom> when someone says "this is black magic" it is possibly a way to say "I haven't learned it" without admitting they haven't learned it
12:27:50 <Qndel> haven't you had things at school that weren't interesting to you?
12:27:52 <exio4> Qndel: Map (Int,Int) ? 
12:28:00 * hackagebot psc-ide 0.1.0.0 - Language support for the PureScript programming language  https://hackage.haskell.org/package/psc-ide-0.1.0.0 (kritzcreek)
12:28:03 <dmwit> Qndel: Is it important to broadcast whether this is interesting to you or not?
12:28:17 <srhb> Qndel: Yes, but people are usually disinclined to teach those that aren't interested. The driving force is usually common enthusiasm :)
12:28:18 <dmwit> Qndel: Just skip the judgments, and let's talk about the technical content.
12:28:23 <monochrom> similarly the other related sayings such as "this is worse than everything else combined" etc
12:28:24 <nitrix> Qndel: A regular map wich takes a tuples, effectively giving you two dimensions.
12:28:38 <EvanR> "haskell sucks, help me"
12:28:42 <Qndel> :D
12:28:52 <exio4> EvanR: a great way to say hello
12:29:10 <nitrix> To me, it's an indicator of the programmer's experience.
12:29:22 <Qndel> okay, I'll tell you if I encounter any more problems! back to my game ... thanks :)
12:29:37 <btipling> Qndel: are you doing any opengl with your game? Is there a gui?
12:30:03 <monochrom> psychologically humans' first try at wording a problem tend to attribute the problem to all external factors they can think of. only after much reflection do they finally accurately point it to PEBKAC
12:30:05 <btipling> ashttps://wiki.haskell.org/OpenGL
12:30:07 <btipling> er
12:30:10 <btipling> https://wiki.haskell.org/OpenGL I mean
12:31:35 <Qndel> yes opengl
12:31:39 <OnkelTem> ghc 7.10.2 - 87Mb!
12:31:42 <Qndel> no, I'm not doing any gui
12:31:51 <EvanR> Qndel: the library gl for opengl is pretty cool
12:31:54 <Qndel> it's supposed to be as simple as possible - I'm writing pacman
12:32:19 <nitrix> OnkelTem: GHC is one of the most sophisticated compiler our there.
12:32:25 <monochrom> drawing a cube doesn't seem to get you closer to pacman. unless you're doing 3D pacman
12:32:35 <Qndel> yes it's supposed to be a 3d pacman
12:32:37 <monochrom> draw some squares and circles instead
12:32:38 <btipling> Qndel: did you already have experience with opengl before?
12:32:42 <Qndel> not really
12:32:49 <btipling> wow that's tough, learning two things then
12:32:52 <Jinxit> out of similar interest, what parts of a game (like reversi, chess, etc) would be good uses of monads? and which ones?
12:32:55 <btipling> two complicated things
12:33:04 <Qndel> I've been creating websites / bots for games / nongraphical stuff
12:33:28 <Qndel> one cube will be the player and I adjusted second cube to be the ground :D
12:33:32 <btipling> right lowlevel opengl pipeline is not trivial to learn, usually people use a library or engine
12:33:40 <btipling> I don't know what's available for haskell though
12:34:01 <Qndel> I was going to use gtk at first but I haven't managed to make it work
12:34:04 <nitrix> Jinxit: I say Chess. The stateful part to maintain the chess board while accepting user IO for interracting with the pieces.
12:34:05 <EvanR> Jinxit: theres several common data structures that are generally useful which happen to support the monad operations, Maybe, Parser, [], IO
12:34:15 <EvanR> ->
12:34:29 <btipling> Qndel: I think gtk comes with a canvas you can just draw on, it wont be hardware accelerated but it will lead to fast dev time 
12:34:45 <btipling> https://developer.gnome.org/goocanvas/stable/goocanvas-simple-canvas.html
12:34:49 <dmwit> Modern 2D gtk drawing is hardware accelerated.
12:34:51 <Qndel> yeah but I wasted hours trying to make it work but failed
12:34:52 <Jinxit> yeah makes sense
12:34:55 <btipling> dmwit: even better
12:35:02 <btipling> I wonder how that works
12:35:07 <dmwit> There's a special backend for cairo.
12:35:11 <nitrix> Qndel: If you make it work, then the hours wont have been wasted.
12:35:22 <EvanR> dmwit: which cairo backend are you referring to
12:35:40 <btipling> dmwit: I wish other canvas implementations were hardware accelerated, i can't think of one
12:35:43 <Qndel> I've already started in opengl and I can actually see my cube so I think I'm on a good way
12:35:58 <btipling> jvm graphics2d and browser canvas for example are not
12:36:02 <btipling> Qndel: nice
12:36:09 <Qndel> ^ ^
12:36:13 <EvanR> btipling: i beg to differ
12:36:17 <dmwit> EvanR: I never looked into it much. I just took the cairo library's claims at face value.
12:36:23 <btipling> EvanR: beg to differ on what?
12:36:30 <dmwit> EvanR: From cairographics.org: "Cairo is designed to produce consistent output on all output media while taking advantage of display hardware acceleration when available (eg. through the X Render Extension)."
12:36:39 <EvanR> dmwit: yeah i really like cairo, but i dont see many working backends for it
12:36:44 <EvanR> ah X
12:37:03 <dmwit> Oh, right, I should have specified "probably not on Windows". =P
12:37:05 <btipling> EvanR: you can use browser canvas with opengl, but just straight up canvas it isn't if that's what you mean
12:37:16 <btipling> but in that case you're using low level opengl apis
12:37:18 <EvanR> btipling: in all browsers you mean?
12:37:30 <monochrom> oh, so is this why hexchat on windows takes more CPU work? :)
12:37:32 <btipling> no I mean the basic canvas api 
12:38:00 <dmwit> monochrom: Oh, man, is a bit of text enough of a CPU hit to notice?!
12:38:02 <EvanR> btipling: im taking exception with say that an API itself is not accelerated
12:38:28 <btipling> if you're just doing basic draw operations on a browser canvas, that is all being done in software, try it your CPU heat up and fan will spin
12:38:37 <btipling> if you're doing the opengl canvas it's another story
12:38:39 <EvanR> thats a particular implementation of the canvas
12:39:02 <monochrom> dmwit: yeah, but I did not measure that. I measured flipping between channels (i.e., between tabs)
12:39:36 <btipling> EvanR: which browser implements the basic 2d api with hardware acceleration?
12:40:18 <OnkelTem> Lol. I've build my first project and it's executable is called h1-exe :)
12:40:20 <EvanR> its still not right to prove the non existence of something by not knowing of any counterexamples
12:40:29 <EvanR> especially when an API is not an implementation
12:40:59 <btipling> EvanR: sure, I would really love to just be able to use a 2d API and get that performance boost so I thought maybe you knew something I didn't
12:41:24 <dmwit> btipling: You're arguing a technicality with a computer programmer. The only winning move is to admit that he's probably technically right but that language is too squishy for that to matter. ;-)
12:41:28 <EvanR> i know graphics is currently extremely complicated with respect to what "acceleration" even means
12:41:48 <EvanR> and cairo still doesn't have a working opengl backend
12:41:56 <EvanR> or how to make such a thing
12:42:06 <btipling> dmwit: I'm also a programmer :P
12:42:11 <EvanR> and that opengl's interface is far from the only way to get faster graphics these days
12:42:15 <btipling> but ya
12:42:45 <dmwit> btipling: I never claimed you weren't!
12:43:16 <dmwit> btipling: Would you like to argue this technicality with me? ;-)
12:43:23 <OnkelTem> So my first project executable was placed relative to a project in: .stack-work/install/x86_64-linux/lts-3.5/7.10.2/bin - which doesn't seem like a conventient location
12:43:24 <btipling> dmwit: but you tripped my self-conscious insecurities!
12:43:25 <btipling> ;\
12:43:27 <btipling> :D
12:43:34 <btipling> ok back to this book
12:43:44 <btipling> I'm just avoiding learning haskell  right now lol
12:43:56 <EvanR> not a good thing to avoid
12:44:00 <btipling> +1
12:44:08 <btipling> I really like what I know about haskell already
12:44:18 <btipling> which isn't much yet
12:44:57 <dmwit> OnkelTem: Ways forward include adding that directory to your PATH, using whatever stack's analog of cabal exec is, or learning how to configure stack. Which sounds most interesting to you?
12:45:03 <torvic> My notebook broke. Does anyone know a way to turn iOS into a temporary workstation to code in Haskell ? Maybe an app that allowed me to clone a repository, an editor to write code and an interpreter. Or perhaps an unix environment, if that is possible.
12:45:17 <OnkelTem> dmwit: the latter
12:45:39 <Jinxit> torvic: ssh if you have an unix server somewhere
12:45:40 <OnkelTem> dmwit: and if you use stack - what was your choice?
12:45:54 <dmwit> I don't use stack. My choice with cabal would be cabal exec.
12:46:29 <dmwit> OnkelTem: The stack repository claims that it has a "complete guid": https://github.com/commercialhaskell/stack/blob/master/GUIDE.md
12:46:40 <torvic> Jinxit I do. I will give it a try.
12:46:51 <OnkelTem> dmwit: thanks!
12:47:48 <Qndel> okay question time
12:48:02 <Qndel> I have the ground in my game, but I need to block some areas
12:48:30 <Qndel> I thought about doing it like this, I add 1,1 as a blocked point and it'd be the center of a square that I cannot access
12:48:58 <Sindriava> I really wish I could infix functions with more that 2 parameters
12:49:02 <Qndel> is map of (GLfloat,GLfloat) what I'm looking for?
12:49:13 <Sindriava> Is there an extension for that by chance?
12:49:21 <dmwit> > let (x + y) z = sum [x,y,z] in (3 + 4) 5
12:49:22 <lambdabot>  12
12:49:27 <dmwit> No extension needed. =)
12:49:35 <dmwit> Although it's not quite as pretty as mixfix in, say, Agda.
12:49:41 <reduceleft> hi I have what I hope is a simple question, I am following the code on this page https://daniel-levin.github.io/2015/01/19/primitive-state-machine-in-haskell.html and I have made a few minor changes... I'm wondering why the following change doesn't work, added deriving Bounded to States and then I give final :: State and final = maxBound which evaluates to S2 as it should but when I try to use it durin
12:49:47 <reduceleft> g pattern matching it doesn't work as expected
12:50:00 <EvanR> Qndel: if your world is on a grid, then use Int or Integer for the coordinates of grid squares
12:50:08 <Qndel> its not on a grid
12:50:14 <Sindriava> dmwit: Was that meant for me?
12:50:18 <Qndel> I'm already moving the player by increasing the coordinates by 0.1
12:50:20 <dmwit> reduceleft: `maxBound` is a pattern that matches anything and binds the value to the variable named `maxBound` (shadowing the existing `maxBound`).
12:50:24 <EvanR> for rendering in 3d you can map the simplier world into floast
12:50:40 <dmwit> reduceleft: You could consider using a guard, or using the actual constructor.
12:50:45 <dmwit> Sindriava: yes
12:50:59 <Sindriava> dmwit: Because I doubt that has anything to do with what I said
12:51:03 <EvanR> the position of a player animation can be floating, but it doesnt mean everything in the program has to be floating
12:51:09 <Sindriava> dmwit: What I meant was ` x `foo` y z '
12:51:17 <reduceleft> i.e. dmwit Ah, so that has higher precedence, okay!
12:51:20 <dmwit> Sindriava: Yes, you can do that. `(x `foo` y) z`.
12:51:35 <Sindriava> dmwit: Oh, THAT'S what you meant
12:51:41 <Sindriava> Yeah screw that
12:51:59 <delYsid> How do I generate Enum a, Bounded a => [a] ?
12:52:08 <dmwit> You can also ```x `foo` y $ z```.
12:52:12 <reduceleft> dmwit: thanks
12:52:26 <dmwit> delYsid: [minBound .. maxBound], but see also:
12:52:28 <dmwit> ?hackage universe
12:52:28 <lambdabot> http://hackage.haskell.org/package/universe
12:52:44 <Qndel> @EvanR how do I add elements to Map?
12:52:44 <lambdabot> Unknown command, try @list
12:52:55 <dmwit> Qndel: Have you tried looking at the fine documentation?
12:53:05 <EvanR> Qndel: with insert from the Map doc
12:53:12 <Qndel> https://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Map.html I'm looking at this
12:53:23 <Qndel> and is it possible to call some function for all elements in the map?
12:53:24 <mniip> 	 
12:53:24 <mniip> ~ * a Integer => Universe (Ratio a)
12:53:24 <mniip> what
12:53:29 <dmwit> Qndel: Ah, yeah, that is a bit confusing. Look at this, instead: https://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Map-Lazy.html
12:53:43 <Qndel> ohh
12:53:49 <EvanR> Qndel: yes, fmap
12:53:50 <Qndel> I can finally understand something :D thanks haha
12:54:02 <delYsid> dmwit: *Main> map toEnum [minBound..maxBound] :: [Braille]
12:54:02 <delYsid> [*** Exception: toEnum{Braille}: tag (-9223372036854775808) is outside of enumeration's range (0,63)
12:54:04 <geekosaur> mniip, haddock buglet, it interprets ~ oddly
12:54:05 <dmwit> Qndel: There are Functor, Foldable, and Traversable instances for (Map k).
12:54:17 <geekosaur> well, arguably "notabug" but highly annoying
12:54:20 <mniip> geekosaur, oh I see
12:54:25 <mniip> (~) * a Integer
12:54:38 <mniip> where * is the implicit polykinds argument
12:54:41 <geekosaur> yeh
12:54:42 <dmwit> delYsid: `[minBound .. maxBound]` *already* has type `[Braille]`. No need to use `map toEnum` at all.
12:54:57 <dmwit> delYsid: Otherwise you are using `minBound` and `maxBound` at the type `Int`, which is almost certainly not what you want.
12:56:03 <dmwit> Qndel: (From the documentation you linked, there is a "module Data.Map.Lazy" link. That means that the `Data.Map` module exports everything that `Data.Map.Lazy` exports, so you should look in both places to see what's available.)
12:56:22 <delYsid> dmwit: ah, tnx
12:56:28 <Qndel> yeah but I didn't know that there could be something useful in Lazy
12:56:35 <Sindriava> > take 10 $ [minBound..maxBound] :: String
12:56:35 <Qndel> so far I've only had problems with haskell laziness :D
12:56:37 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t"
12:56:47 <broma0> Does anyone know of some good documentation on implementing a lexical analyzer in haskell? 
12:56:59 <dmwit> ?where alex
12:57:00 <lambdabot> http://www.haskell.org/alex/
12:57:01 <broma0> (i.e. not using parsec or attoparsec)
12:57:05 <Sindriava> broma0: Do you *want* to make one, or do you need one?
12:57:17 <broma0> Sindriava: well i NEED to make one for a school assignment :D
12:57:22 <Qndel> I have something like this
12:57:23 <Qndel> forM_ (points 1) $ \(x,y,z) -> preservingMatrix $ do       color $ Color3 ((x+1)/2) ((y+1)/2) ((z+1)/2)
12:57:28 <dmwit> Oh. Alex probably isn't suitable for a school assignment.
12:57:29 <Sindriava> broma0: Oh, okay. Then look at alex, yeah
12:57:37 <Qndel> so it takes all my 3d points and executes the loop for each point
12:57:40 <Sindriava> It might be too complex, hm
12:57:48 <broma0> My assignment is to implement a cimpiler/interpreter for a subset of Pascal
12:58:01 <Qndel> nvm
12:58:02 <dmwit> I mean, if the school assignment is to create a lexer, then probably alex is sort of "cheating". If the assignment involves using a lexer for some bigger goal, alex is probably perfect.
12:58:05 <Qndel> answered my question myself :D
12:58:40 <broma0> ive used free monad/ interpreter patteran a ton so the architechture is clear to me, i'm just struggling with implementing my own parser and lexer when things like parsec and attoparsec wrap them up in to one super general monad
12:58:48 <Sindriava> Qndel: Consider not using old OpenGL
12:59:03 <broma0> ill take a look at alex
12:59:06 <Qndel> I'm ok with this opengl
12:59:13 <Qndel> its the haskell itself that I have problems with
12:59:13 <monochrom> broma0: almost every book on compiler/interpreter has a chapter on making your own lexer, even from scratch
12:59:21 <Sindriava> Qndel: People are okay with PHP, doesn't make it not horrible
12:59:38 <Qndel> :)
12:59:57 <Qndel> still better than writing your game in javascript and expecting it to be safe
13:00:10 <Sindriava> Qndel: I don't see how that relates.
13:00:14 <broma0> monochrom: yeah, there's probably something good in write you a scheme 
13:00:20 <monochrom> some of them are FP-friendly (e.g., "modern compiler implementation in ML") so they can be easily translated to haskell
13:00:20 <broma0> monochrom: thank you
13:00:26 <Sindriava> broma0: Check out "Write yourself a Haskell", there might be something nice in there
13:01:10 <monochrom> but even for the imperative ones, if you understand the spirit (as opposed to the letter) of their algorithms, you can get inspirations
13:01:21 <dmwit> Is there really a "Write Yourself a Haskell"? That sounds kind of fun.
13:01:26 <broma0> dmwit: the assignment is to write a compiler/interp for a subset of pascal, and to to that, i'm supposed to write a Lexer, a parser, and then either an interp or some code generator
13:02:15 <broma0> i can't use any libraries that satisfy any of those steps in its entirety (like using parsec for the parse/lexer)
13:02:27 <EvanR> its annoying how compiler-writing resources spend so much time on lexing/parsing
13:02:48 <EvanR> was that really a significant part of compilers back in the day?
13:02:59 <dmwit> broma0: Okay. Given that, I'm not sure it would be reasonable to stick a lexer generator like alex in your toolchain. But you will certainly be able to judge that better than me.
13:03:27 <Qndel> MyMap <- Map.fromList [(0.1,0.1), (0.2,0.2)]
13:03:32 <broma0> dmwit: yeah i cant use a generator.. gotta make the damn lexer manually (unless, of course, i write the lexer generator)
13:03:37 <Qndel> Display.hs:17:3: Not in scope: data constructor `MyMap'
13:03:41 <Qndel> what's wrong?
13:03:43 <EvanR> Qndel: let myMap = Map.fromList [.....
13:03:47 <Qndel> ohh right
13:03:53 <dmwit> Qndel: I strongly suggest working through a Haskell tutorial.
13:04:03 <dmwit> Qndel: These kinds of basic syntax questions will be covered in them.
13:04:16 <Qndel> well
13:04:18 <Qndel> I've used let
13:04:21 <Qndel> still the same error
13:04:32 <exio4> broma0: I would implement a small "library" with parser combinators and go with it, if you don't care about performance, it's pretty easy to write one :P
13:04:33 <EvanR> it cant be the same error
13:04:36 <dmwit> Qndel: `let` was only part of the change EvanR suggested.
13:04:44 <EvanR> because i used a different variable name
13:05:06 <Qndel> thanks :)
13:06:29 <some_types> so I asked about this yesterday, and got some helpful tips on making a hierarchy of nested sets of types. I'm having trouble mapping between them though - here's a simple example: http://lpaste.net/140854 (@Cale, exio4)
13:07:18 <broma0> exio4: im looking through write you a haskell now and im thinking thats what ill do.. its a pain that the assignment makes me write a separate lexer and parser when nowadays their often wrapped up together
13:07:59 <geekosaur> history, sadly
13:08:41 <EvanR> maybe go the other way, and divide the parsing into N levels each which do one simple thing during the pass
13:09:26 <dmwit> some_types: Looks like you will have to teach GHC about transitivity.
13:09:31 <dmwit> (of (<=))
13:09:56 <some_types> yeah. any idea how to do that?
13:11:05 <dmwit> Let me try.
13:12:02 <dmwit> Whoa, neat, I think I looped GHC.
13:14:25 <some_types> lol good job
13:14:40 <Qndel> http://lpaste.net/140855
13:14:48 <dmwit> trans :: (a <= b, b <= c) => ((a <= c) => d) -> d; trans = undefined
13:14:50 <dmwit> Try it at home!
13:15:43 <reduceleft> lol dmwit
13:16:43 <Cale> heh
13:17:31 <dmwit> Hm, 7.10.1 seems to do funny things, but 7.8.4 gives a type error immediately.
13:17:37 <dmwit> Perhaps this is a GHC bug.
13:17:48 <Cale> I'd consider it a bug
13:18:53 <srhb> dmwit: Yep, crashes in 7.10.2 too
13:18:59 <srhb> Well, loops
13:19:26 <srhb> That's funny, you get a really interesting ghci session after halting it :-)
13:19:27 <rntz> @let poly f = (f 3, f True)
13:19:29 <lambdabot>  .L.hs:232:13:
13:19:29 <lambdabot>      No instance for (Num Bool) arising from the literal ‘3’
13:19:29 <lambdabot>      In the first argument of ‘f’, namely ‘3’
13:19:51 <dmwit> Okay, I'll make a report.
13:19:53 <Qndel> how bad is something like this?
13:19:58 <Qndel> fmap myMap $ \(x,y) -> preservingMatrix $ do
13:20:45 <srhb> Qndel: It's a fairly common pattern.
13:21:01 <srhb> If you can even call it that. 
13:21:09 <Qndel> so it should work?
13:21:26 <drewbert> Does anybody know a haskell library that can walk a directory tree and has options for following or not following symlinks (and hopefully also loop detection)?  Wishful thinking?
13:21:40 <rntz> @let poly :: (forall v. v -> v) -> (Int, Bool)
13:21:41 <lambdabot>  .L.hs:229:1:
13:21:41 <lambdabot>      Duplicate type signatures for ‘poly’
13:21:41 <lambdabot>      at .L.hs:227:1-4
13:21:50 <rntz> @undef
13:21:51 <lambdabot> Undefined.
13:21:57 <srhb> Qndel: Assuming it's well-typed and it's actually mapped over some Functory value, sure.
13:22:04 <rntz> @let poly :: (forall v. v -> v) -> (Int, Bool); poly f = (f 3, f True)
13:22:06 <lambdabot>  Defined.
13:22:09 <Qndel> ohh, too bad it doesn't work :P
13:22:15 <rntz> > poly id
13:22:17 <lambdabot>  (3,True)
13:22:20 <rntz> > poly $ id
13:22:22 <lambdabot>  (3,True)
13:22:25 <rntz> > ($) poly id
13:22:27 <lambdabot>      Couldn't match type ‘a0 -> a0’ with ‘forall v. v -> v’
13:22:27 <lambdabot>      Expected type: (a0 -> a0) -> (Int, Bool)
13:22:27 <lambdabot>        Actual type: (forall v. v -> v) -> (Int, Bool)
13:22:43 <srhb> rntz: $ has magical higher rank properties.
13:22:51 <rntz> apparently
13:23:15 <srhb> rntz: Mainly because people like to do ... runST $ do ...
13:23:30 <Qndel> here's the error message if you could look at it
13:23:32 <Qndel> http://lpaste.net/140856
13:23:44 <Qndel> my map is simple   let myMap = Map.fromList [(0.1,0.1), (0.2,0.2)]
13:23:51 <catgocat> what is a dirty way to put a value in a function through fmap ? something like `fmap ($3) (+3)`
13:24:03 <catgocat> or any function really
13:24:44 <dmwit> > fmap ($3) (+3) 3 -- looks like it works fine
13:24:46 <lambdabot>      Could not deduce (Num a0)
13:24:46 <lambdabot>      from the context (Num a, Num (a -> b))
13:24:46 <lambdabot>        bound by the inferred type for ‘e_1333’: (Num a, Num (a -> b)) => b
13:24:50 <dmwit> oh no!
13:24:54 <catgocat> dmwit, yeah but just with fmap
13:24:54 <drewbert> Do I need to canonicalize the paths and add them to a hashmap to map sure that I'm not re-visiting the same folder?
13:25:04 <dmwit> catgocat: I'll be honest. I don't really understand the question.
13:25:08 <drewbert> hashset*
13:25:12 <srhb> Qndel: What's the code?
13:25:33 <dmwit> :t fmap ($3) (+3)
13:25:35 <lambdabot> (Num a, Num (a -> b)) => (a -> b) -> b
13:25:40 <Qndel> http://lpaste.net/140858 here's the code
13:25:49 <dmwit> oh, right
13:25:58 <dmwit> > fmap (+3) (+3) 3
13:26:00 <lambdabot>  9
13:26:13 <dmwit> > fmap ($3) (+) 3
13:26:15 <lambdabot>  6
13:26:28 <srhb> Qndel: The order of fmap arguments is the opposite of for
13:26:40 <srhb> Qndel: Also you're never actually using x and y.
13:26:47 <Qndel> I know
13:26:56 <Qndel> because I removed the function using them for testing
13:27:06 <srhb> Qndel: So flip fmap myMap $ ...
13:27:11 <Qndel> ok :)
13:28:21 <Qndel> how would I flip it? :D
13:28:30 <dmwit> :t flip
13:28:31 <srhb> Qndel: flip fmap myMap
13:28:31 <lambdabot> (a -> b -> c) -> b -> a -> c
13:28:34 <srhb> Qndel: No magic.
13:29:00 <Qndel> ohh
13:29:02 <srhb> Qndel: I'm also not sure why forM_ wasn't fine for your purpose, if you're not gathering any values.
13:29:06 <Qndel> it's a function!
13:29:10 <srhb> Yes, it is :)
13:29:14 <Qndel> hahaha
13:29:22 <Qndel> and I was trying things like fmap \(x,y) $ myMap -> preservingMatrix $ do
13:29:33 <srhb> Yeah that won't work...
13:29:41 <some_types> dmwit: so what does this mean for teaching the compiler about transitivity? No dice?
13:29:54 <srhb> fmap (\x,y) -> do ... ) myMap -- would work
13:30:38 <Qndel> still doesn't work, but the error became more complicated
13:31:09 <dmwit> some_types: Well, I've never been very good at type-level hacking. So I'm not sure how to do this. But people who have more experience might have an idea for a way.
13:31:12 <srhb> Qndel: The actual error is important. :-)
13:31:39 <some_types> alright :)
13:31:41 <Qndel> http://lpaste.net/140861
13:31:47 <Qndel> now I don't understand a word from the error :D
13:31:52 <Qndel> I posted my whole code
13:31:54 <rntz> can anyone explain http://lpaste.net/140860 to me?
13:32:32 <Qndel> and you wrote "Qndel: I'm also not sure why forM_ wasn't fine for your purpose, if you're not gathering any values.", I will be gathering the values when I make it work
13:32:36 <rntz> I've been reading "practical type inference for arbitrary-rank types", and it explains that it can't infer impredicative type application, but GADTs seem to get around that somehow
13:32:40 <rntz> and I don't really understand why
13:32:41 <dmwit> rntz: ImpredicativeTypes aren't really a supported extension. They don't do what they say on the tin.
13:33:04 <rntz> ok, I'm not really concerned with the ImpredicativeTypes extension, I'm wondering why GADTs seem to be a loophole out of "no impredicative types"
13:33:20 <Cale> Qndel: I don't think you want flip fmap there. Maybe you intended to use forM_ ?
13:33:41 <Cale> Or forM without the _
13:33:42 <dmwit> rntz: But there's no impredicative type in the GADT version.
13:33:46 <rntz> sure there is, Foo
13:33:49 <rntz> Foo has a forall in it
13:33:50 <srhb> I too think you want forM :)
13:33:51 <Cale> :t flip fmap
13:33:53 <lambdabot> Functor f => f a -> (a -> b) -> f b
13:33:53 <rntz> (it's not visible, but it's there)
13:33:55 <Qndel> ^ ^
13:34:16 <rntz> why isn't Foo considered a "type with a forall in it" and therefore not a monotype?
13:34:16 <dmwit> rntz: The type `Foo` has no forall in it!
13:34:27 <Cale> ^^ if myMap is a Map, then flip fmap myMap (\(x,y) -> ...) will be a Map as well, not an IO action.
13:34:29 <dmwit> rntz: The type of `Foo`'s constructor, namely `Foo`, has a `forall` in it. But that's fine.
13:34:36 <rntz> ok, but *why* is it fine?
13:34:48 <srhb> :t forM
13:34:49 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
13:34:54 <rntz> why is this different than "type Foo = (forall a. a -> a)"?
13:34:57 <dmwit> rntz: Types are allowed to have `forall` in them. The rule is that you can't substitute a type variable with a polymorphic type.
13:35:03 <rntz> since in fact Foo and (forall a. a -> a) are isomorphic
13:35:21 <srhb> Qndel: So it will traverse over the map (the Traversable t, here) with the function from (a -> m b) where m is IO here, and produce an IO action that has a Map of the resulting values
13:35:35 <dmwit> rntz: `type Foo = (forall a. a -> a)` doesn't need impredicative types either.
13:36:17 <Qndel> so how would I get the coordinates stored in the map? one by one?
13:36:24 <rntz> dmwit: that's just not true. maybe I have miscommunicated?
13:36:32 <rntz> if I do
13:36:36 <rntz> type Bar = forall a. a -> a
13:36:39 <rntz> y :: Tree Bar
13:36:39 <srhb> Qndel: Similarly, the (a -> m b) gets that as its argument.
13:36:41 <rntz> y = Leaf id
13:36:44 <rntz> I will get an error message
13:36:57 <rntz> that is what I mean by type Foo = (forall a. a -> a) "not working"
13:37:12 <dmwit> rntz: Yes, because you are trying to substitute a polymorphic type for the type variable argument to `Tree`.
13:37:15 <glguy> rntz: You needed impredicative types to write: Tree Bar, not type Bar = ...
13:37:24 <rntz> right, yes, absolutely
13:37:34 <dmwit> rntz: Whereas `Foo` is not a polymorphic type. It is a monomorphic type with a constructor of polymorphic type.
13:37:47 <rntz> I'm just confused why the GADT Foo is "not polymorphic" when Bar is polymorphic and they are isomorphic types
13:38:05 <dmwit> Isomorphism simply isn't the same as equality.
13:38:07 <rntz> no
13:38:08 <dmwit> Never has been.
13:38:11 <srhb> Qndel: So forM yourMap $ \value -> ...
13:39:04 <Qndel> forM myMap $ \(x,y) -> preservingMatrix $ do ?
13:39:20 <dmwit> rntz: This comes up a lot. See equirecursive vs. isorecursive types. Equirecursive type systems are undecidable; isorecursive type systems are not.
13:39:29 <rntz> equirecursive type systems are not undecidable
13:39:40 <Qndel>      or just \value where value is the tuple?
13:39:46 <monochrom> rntz: at this point, I will just say that ImpredicativeTypes is made available but incompletely implemented, and call it a day.
13:39:46 <dmwit> rntz: It just so happens that having to pattern match at appropriate times and having to apply constructors at appropriate times gives the type checker enough of a hint about what's happening that it can make progress.
13:39:47 <srhb> Qndel: Either way.
13:39:59 <rntz> dmwit: hm, ok.
13:40:10 <srhb> Qndel: If you write value, then value is the tuple. If you pattern match on the elements, then you get a name for each of the elements.
13:40:17 <geekosaur> is it worth mentioning here that while rank-2 types could be inferred, ghc does not try?
13:40:25 <rntz> I guess I was looking for what that hint was. perhaps if I read the entire paper I will understand.
13:40:29 <rntz> thanks for the help!
13:40:57 <monochrom> as opposed to going philosophical and raising a debate that is doomed to not change GHC a bit
13:41:08 <dmwit> rntz: Sorry, I specifically meant type systems with subtyping *and* equirecursive types vs systems with subtyping and isorecursive types.
13:41:09 <Qndel> still doesn't work
13:41:10 <Qndel> forM myMap $ \value -> preservingMatrix $ do
13:41:17 <rntz> dmwit: ahh, ok
13:41:24 <Qndel>    Couldn't match expected type `[a0]'                with actual type `Map.Map GLfloat GLfloat'    In the first argument of `forM', namely `myMap'    In the expression: forM myMap
13:41:25 <srhb> Qndel: "Doesn't work" doesn't help. :)
13:41:31 <Qndel> I know I know :P
13:41:41 <geekosaur> and in fact ImpredicativeTypes is buggy, always has been, and apparently always will be; smart people have been banging their heads against it for years and all they have to show for it is bruises :/
13:41:43 <srhb> Qndel: What's the type of your forM?
13:41:51 <Qndel> no idea
13:41:57 <Qndel>   let myMap = Map.fromList [((0.1::GLfloat),(0.1::GLfloat)), ((0.2::GLfloat),(0.2::GLfloat))]
13:41:58 <srhb> Qndel: ask ghci :)
13:42:04 <srhb> Qndel: :t forM
13:42:47 <Qndel> ghci doesn't want to talk
13:43:00 <Qndel> it doesn't load my things when there's an error
13:43:03 <Qndel> or so I think
13:43:16 <srhb> Qndel: Well, I suspect you're on an older base which has forM :: Monad m => [a] -> (a -> m b) -> m [b]
13:43:23 <monochrom> at some point in the past, it was famous that the good GHC people figured out a very unifying type inference (the paper about "OutsideIn") that covers almost all extensions in one elegant swoop. and the only exception was ImpredicativeTypes.
13:43:27 <geekosaur> try: ghci -fdefer-type-errors
13:43:34 <geekosaur> (if your ghc is old enough thne that won't work)
13:43:43 <monochrom> and so they did sacrifice it.
13:43:47 <srhb> Qndel: In which case you can grab the polymorphic version from Data.Traversable instead
13:44:22 <jle`> is impredicative types planned to be removed?
13:44:33 <geekosaur> not that I'm aware of
13:44:41 <jle`> but
13:44:42 <dmwit> ImpredicativeTypes does still do *something*.
13:44:54 <monochrom> it is rumoured that getting ImpredicativeTypes in will land you a Millenium Prize from the Cayley Institute
13:44:56 <dmwit> It's just very unwieldy, because you aren't allowed to rely on inference happening anywhere.
13:44:58 <geekosaur> SPJ threatened to remove it once, but was overruled
13:44:58 <jle`> but not the thing people intend for it to do
13:45:05 <dmwit> So you practically need to annotate the type of *every* subterm.
13:45:35 <Qndel> ohh
13:45:44 <Qndel> the thing from traversable worked
13:45:51 <srhb> Qndel: Goodie.
13:45:54 <jle`> that's like if -XTupleSections wipes your hard drive.  but we keep it because it does *something*
13:46:06 <jle`> it's just not the thing people intend when they use it
13:46:16 <srhb> Qndel: The last major revision of GHC made a lot of functions more polymorphic, forM is one of them. The old version only worked on lists.
13:46:31 <monochrom> dmwit: I am now actually annotating everything under the sun. it still errors out. here:
13:46:33 <srhb> Well, made the _defaults_ more polymorphic :)
13:46:37 <monochrom> i :: Maybe (forall a. a -> a)
13:46:39 <Pamelloes> jle`: "April Fools!" :D
13:46:43 <monochrom> i = (Just :: (forall a. a->a) -> Maybe (forall a. a->a)) (id :: forall a. a -> a)
13:46:57 <jle`> impredictable types
13:47:14 <geekosaur> not really. if it were really unsafeLaunchMissiles then removing it would be a good thing, but the current behavior is considered acceptable since it "just" necessitates care around higher-ranked types
13:47:16 <monochrom> (I have {-# LANGUAGE ImpredicativeTypes, RankNTypes, ScopedTypeVariables #-} )
13:47:34 <GLM> Why have I heard multiple times that I shouldn't use String?
13:47:37 <Qndel> jesus
13:47:41 <Qndel> I don't get anything anymore
13:47:48 <Qndel> let myMap = Map.fromList [((0.1::GLfloat),(0.1::GLfloat)), ((0.2::GLfloat),(0.2::GLfloat))]
13:47:50 <Sindriava> GLM: It's unwieldy.
13:47:51 <Qndel> that's my map
13:47:51 <dmwit> monochrom: Oh, dang, I'm wrong again.
13:47:55 <monochrom> :)
13:47:59 <jle`> geekosaur: but if it's buggy, doesn't that mean that it doesn't even do *that* correctly?
13:48:01 <Qndel> import qualified Data.Traversable as Trav
13:48:03 * hackagebot text-show 2.1 - Efficient conversion of values into Text  https://hackage.haskell.org/package/text-show-2.1 (ryanglscott)
13:48:03 <maerwald> GLM: depends on what for
13:48:04 <GLM> Sindriava:Why?
13:48:05 <monochrom> I wish I knew what more to annotate :)
13:48:08 <Qndel> Trav.forM myMap $ \v -> preservingMatrix $ do
13:48:18 <Qndel> so v should be a tuple of floats right?
13:48:27 <Sindriava> GLM: String is *literally* a list of characters. And list is a linked list, which constitutes of cons cells
13:48:35 <srhb> Qndel: doesn't fromList take a key,value pair?
13:48:40 <Sindriava> GLM: Cons cell is a value, and a pointer to the next cons cell
13:48:45 <srhb> Qndel: a list of that.
13:48:53 <GLM> Sindriava:I get that but I don't see why that is bad
13:48:56 <geekosaur> GLM, String is either very slow and inefficient, or more efficient than anything else. usually the former unless you can convince things to fuse perfectly. it may still be acceptable for short strings, but for serious text manipulation you really want Data.Text and for octet manipulation (e.g. network connections) you want ByteString
13:49:01 <Qndel> lol
13:49:05 <jle`> GLM: String really isn't an ideal type for dealing with text, but the main advantage is that it's really usable as a list
13:49:08 <srhb> :t Map.fromList
13:49:09 <lambdabot>     Not in scope: ‘Map.fromList’
13:49:09 <lambdabot>     Perhaps you meant one of these:
13:49:09 <lambdabot>       ‘M.fromList’ (imported from Data.Map),
13:49:13 <srhb> :t M.fromList
13:49:14 <lambdabot> Ord k => [(k, a)] -> M.Map k a
13:49:16 <monochrom> dmwit: in the good spirit of "the best way to win is not to play", I now resort to "i = Nothing" :)
13:49:24 <jle`> but when you're working with text, being used as a streaming/infinite list is probably usually not on your list of priorities
13:49:36 <jle`> it almost never us
13:49:38 <jle`> *is
13:49:38 <maerwald> don't use complicated data structures if all you have is really small strings
13:49:39 <GLM> jle`:So what I'm hearing is use Strings if you don't care about performance
13:49:41 <geekosaur> because String is a singly linked list of lazy codepoints
13:49:41 <Sindriava> GLM: That means that for *each character*, even if it was a byte, you use up 9 bytes (!!!) per character on a 64bit platform
13:49:42 <dmwit> monochrom: =)
13:49:45 <Qndel> so how can I convert the actual tuples into the map?
13:49:46 <srhb> Qndel: Yes it does, so you're using the first GLFloats as keys in the map, and thus your v is the second GLFloat of each tuple in your list.
13:49:55 <Qndel> yeah, so how to fix it?
13:50:04 <srhb> Qndel: Construct your Map sanely? :)
13:50:05 <jle`> GLM: also when you don't care about having an API that works on text intelligently
13:50:09 <srhb> Qndel: Do you _need_ keys?
13:50:12 <Qndel> no!
13:50:15 <Qndel> I need tuples
13:50:18 <srhb> Qndel: Then why not use a list of tuples?
13:50:20 <jle`> GLM: remember that String is just [Char], so it doesnt' really semantically recognize it as a "String", intelligently
13:50:22 <GLM> jle`:What counts as intelligently?
13:50:32 <srhb> Qndel: just delete the fromList bit.
13:50:35 <MitchellSalad> Qndel: the traversable instance of Map doesn't give you access to the keys, only the values
13:50:36 <Qndel> o.O
13:51:06 <srhb> Qndel: I assumed you had a reason for using a Map. :) Maps are key-value stores.
13:51:08 <jle`> GLM: things like encoding/decoding from different text encodings...just things that make "strings" different from [a] for any a
13:51:11 <Sindriava> Qndel: Why does that suprise you? The keys don't have to be stored in the map.
13:51:18 <Qndel> I asked you!
13:51:21 <Qndel> You told me to use map xD
13:51:27 <dmwit> GLM: There are a number of operations that you want to do on natural-language-text that aren't readily available in a library for String. For example, upper-casing or lower-casing a String with map toUpper is easy, but wrong.
13:51:28 <jle`> if you're using String you basically have the tools of [a], for lists, available to you
13:51:30 <srhb> Well, it might be sane.
13:51:33 <geekosaur> um. 64 bit platform you have a list of <64-bit constructor tag, 64-bit pointer to separately allocated <64-bit constructor tag, 64-bit codepoint value>> for 4*8=32 bytes per character, not 9 bytes
13:51:36 <GLM> Alright, I'll use Text then
13:51:48 <Sindriava> geekosaur: EVEN
13:51:54 <Qndel> I just need a function to check if somebody is in my set
13:51:54 <jle`> GLM: think of it like, say, using "123" instead of the number 123
13:52:03 <Qndel> something*
13:52:05 <jle`> GLM: i mean, you can.  but...you lose the ability to add, subtract, multiply, etc. in a nice way
13:52:18 <Sindriava> geekosaur: I was working with simple `struct cons { char c; cons *next; }`
13:52:18 <jle`> and "123" isn't really "aware" of the fact that it's a number
13:52:19 <srhb> Qndel: If you need a Set, why not use a Set...
13:52:22 <GLM> Why does String exist then?
13:52:27 <srhb> Qndel: The right data type for the job etc. :)
13:52:28 <jle`> good question!
13:52:34 <maerwald> don't exaggarate, GHC can optimize lists very efficiently. So it's really not as bad for simple thing as you make it sound
13:52:35 <geekosaur> Sindriava, even C will pad the char c
13:52:44 <Sindriava> geekosaur: That's not true.
13:52:47 <dmwit> Because it was convenient, and because Haskell was designed by folks who probably hadn't done very much String munging in real applications. ;-)
13:52:49 <jle`> maerwald: i'm not talking about performance and efficiency
13:52:49 <Qndel> tears of joy
13:52:50 <Qndel> it works!
13:52:51 <Sindriava> geekosaur: Some *compilers* might.
13:52:56 <Qndel> I don't know what to use
13:52:56 <jle`> maerwald: i'm talking about semantic correctness
13:53:06 <srhb> Qndel: No, that's the thinky bit. ;)
13:53:08 <Qndel> I need a data structure to store tuples of floats
13:53:15 <GLM> dmwit:Seems to be true of a lot of languages
13:53:19 <Qndel> and to be able to ask if a  tuple (x,y) is in the structure
13:53:20 <geekosaur> most compilers will unless specifically told otherwise, because it vastly simplifies and often vastly speeds up memory access
13:53:26 <jle`> maerwald: if my compiler can optimize arithmetic with strings of numbers, "123" + "345", it doesn't mean i should use strings instead of just Int's
13:53:32 <MitchellSalad> Qndel: How about a Set?
13:53:33 <Sindriava> geekosaur: You're really talking nonsense, sorry
13:53:41 <Sindriava> geekosaur: *padding* is not well defined. On a 8bit architecture, you wouldn't pad it to anything
13:53:45 <Qndel> okay, let it be set then :D
13:53:52 <srhb> Qndel: It sounds like you want Set, yes. But it really depends on your needs. What should the data structure offer of access complexity etc.
13:53:55 <Sindriava> geekosaur: Furthermore, you can manually tell the compiler to pack the struct
13:54:02 <monochrom> if you use lists, avoid allowing a long list to entirely stay in memory (as opposed to "immediately produce, immediately consume and forget")
13:54:05 <Qndel> I don't care
13:54:06 <Qndel> really
13:54:08 <Qndel> its just a pacman
13:54:18 <Sindriava> geekosaur: What you're saying is simply not applicable in any general sense
13:54:19 <srhb> Qndel: Fine, then stick with list and have expensive lookup :-)
13:54:20 <geekosaur> Sindriava, I'm talking real implementations, which we are in the land of if we are talking the same thing I said about what ghc is doing
13:54:20 <Qndel> the complexity could be n^5 and it should still run
13:54:25 <Qndel> :)
13:54:28 <srhb> Qndel: Sure, continue then. Don't get hung up on this.
13:54:34 <geekosaur> if you want to stick to abstracts then you cannot talk about bytes
13:54:40 <jle`> GLM: and yes, as people have mentioned before, you can have "infinite strings" with String implicitly, Text, etc. aren't really meant for 'infinite streams'
13:54:40 <Sindriava> geekosaur: "real implementations" ? WTF is that
13:54:57 <geekosaur> ...?
13:54:58 <syntagma> Is Stack basically a (like) Python's virtualenv, for Haskell programs?
13:55:08 <Sindriava> geekosaur: It's offtopic, wrong and simply trolling, so I'll stop this discussion now.
13:55:10 <monochrom> because if you're really doing "immediately produce, immediately consume and forget", then even if optimizations don't kick in, you're just talking about O(24 bytes) memory footprint or something
13:55:37 <GLM> syntagma:It is like Pip
13:56:04 <Qndel> let myMap =  [((0.1::GLfloat),(0.1::GLfloat)), ((0.2::GLfloat),(0.2::GLfloat))]
13:56:08 <Qndel> thats my LIST
13:56:16 <Qndel> do I have to write the GLfloat every time?
13:56:21 <monochrom> but if you start going like "I want to read a 1MB file into a list and have the whole thing in memory because my faulty intuition tells me to", that's going to be 24MB or maybe 64MB or whatever
13:56:25 <Sindriava> Qndel: No, lists are homogenous.
13:56:31 <srhb> Qndel: Annotate the entire thing as :: [(GLFloat, GLFloat)]
13:56:38 <Qndel> ok :)
13:56:38 <Hijiri> Qndel: you could write myMap :: [(GLfloat,GLfloat)]
13:56:39 <syntagma> I see
13:56:40 <jle`> Qndel: no, and usually the compiler will be able to infer it anyway
13:56:50 <srhb> Probably not with gl types
13:56:53 <jle`> Qndel: if you eventually use mMap later with a function that only takes GLfloats, you do'nt need to annotate ever :o
13:56:55 <srhb> It's rather finicky like that.
13:57:01 <jle`> ah
13:57:02 <monochrom> also sometimes s/faulty intuition/XY problem/
13:57:10 <srhb> jle`: Yeah, sadly...
13:57:25 <jle`> isn't the problem in that case more about the functions using it are polymorphic?
13:57:29 <srhb> Yes.
13:57:39 <srhb> Perhaps it would actually make sense to stick in a default statement.
13:57:43 <Qndel> let myMap :: [(GLFloat, GLFloat)] =  [(-0.5,-0.5), (0.5,0.5)]
13:57:46 <monochrom> e.g., "I want to close the file handle ASAP. I think it can be achieved by reading the whole file into memory upfront."
13:57:54 <Sindriava> jle`: GL functions use manual type tags (in C)
13:58:01 <Qndel>    Illegal type signature: `[(GLFloat, GLFloat)]'      Perhaps you intended to use ScopedTypeVariables
13:58:01 <jle`> Qndel: myMap :: [(GLFoat, GLFloat)]; myMap = [(-05.,.... .. )]
13:58:02 <srhb> Qndel: let myMap :: [(FLFloat, GLFloat)]; myMap = ...
13:58:04 <Hijiri> Qndel: put the type annotation and the definition on separate lines
13:58:09 <Hijiri> like wiht a top level definition
13:58:11 <Qndel> ok
13:58:11 <srhb> echo echo echo
13:58:12 <Sindriava> jle`: e.g. GL_UNSIGNED_INT etc. So the actual types are usually `Ptr ()`
13:58:30 <srhb> Or you can annotate the list, myMap = [...] :: ...
13:59:03 <GLM> Anyone have a project to get beyond the basics of Haskell?
13:59:37 <jle`> make command line hangman :)
13:59:43 <maerwald> GLM: write a GUI for darcs
13:59:59 <GLM> maerwald:Is Haskell meant for GUIs?
14:00:14 <maerwald> GLM: what do you mean with "meant"? It's a programming language
14:00:16 <geekosaur> define "meant for"
14:00:20 <monochrom> to some extent Data.Map etc also come with similar concerns. in a binary search tree, each node is going to take up 40 bytes at least
14:00:24 <jle`> it's general purpose, so it was meant for anything
14:00:33 <Qndel> okay works
14:00:42 <geekosaur> I will say that GUIs are currently "interesting" because your choices are:
14:00:47 <Qndel> myMap = [(-1,-1), (1,1)] - how would I add points from 1,1 to 1,10? :)
14:00:48 <GLM> geekosaur:Have easy to use libraries
14:00:56 <Sindriava> GLM: I suppose your question is "Is it usable for GUIs?", and the answer to that is yes and no
14:01:03 <geekosaur> (a) unwieldy procedural interfaces to things like WxWindows or Gtk+
14:01:07 <Sindriava> GLM: Yes, it has very good libraries and support
14:01:14 <geekosaur> (b) FRP systems, which are still something of an active rfesearch area
14:01:22 <Sindriava> GLM: And no, it's not as good as some other languages
14:01:23 <maerwald> gui support is not as good as in other languages, because most "libraries" are just C bindings
14:01:33 <Sindriava> maerwald +1
14:01:34 <geekosaur> so we have libraries, but using them can sometimes be rather annoying
14:01:45 <monochrom> ("to some extent" this time, even though numerically worse, because by the time you are non-beginner enough to start using Data.Map, you are unlikely crazy enough to actually plan "let me read all of a 1GB file into a Data.Map")
14:01:45 <srhb> Qndel: map (\x -> (1,x)) [1..10] ?
14:02:12 <srhb> Qndel: Oh actually that's no good with GLFloat
14:02:19 <Qndel> ohh
14:02:26 <Qndel> so no way to add 0.1 or something?
14:02:34 <dmwit> > range (1,1) (1,10)
14:02:36 <lambdabot>      Couldn't match expected type ‘(Integer, Integer) -> t’
14:02:36 <lambdabot>                  with actual type ‘[Integer]’
14:02:36 <lambdabot>      The function ‘range’ is applied to two arguments,
14:02:47 <dmwit> > range ((1,1), (1,10))
14:02:49 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10)]
14:02:59 <Qndel> this lambdabot is such a nice guy
14:03:01 <srhb> Qndel: Yes, just add a second step.. [1,1.10..10]
14:03:01 <Qndel> : D
14:03:03 <jle`> > map (1,) [1..10]
14:03:05 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10)]
14:03:17 <dmwit> > zip (repeat 1) [1..10]
14:03:19 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10)]
14:03:22 <Sindriava> Qndel: But be careful of rounding errors. I'd recommend to use Raional
14:03:22 <dmwit> Spelling bees are fun!
14:03:24 <Sindriava> *Rational
14:03:25 <srhb> dmwit: Nice.
14:03:39 <srhb> hadn't thought of that.
14:04:04 <jle`> actually i've accidentally used zip + repeat more than once
14:04:11 <jle`> it's always a little embarassing when i see it later
14:04:15 <jle`> it's just so tempting, heh
14:04:23 <dmwit> > [x/10 | x <- [10..100]]
14:04:25 <lambdabot>  [1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.0,2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8...
14:04:31 <dmwit> > last [x/10 | x <- [10..100]]
14:04:32 <lambdabot>  10.0
14:04:38 <dmwit> > last [1, 1.1 .. 10]
14:04:40 <lambdabot>  10.000000000000053
14:04:45 <Qndel> but how would I actually add it to my list?
14:04:49 <jle`> (++) ?
14:04:57 <suppi> http://oi60.tinypic.com/16a4aw2.jpg I don't know what I'm doing lol
14:04:59 <Qndel> haskell doesn't like this myMap = [(-1,-1), (1,1), map (1,) [0,1.10..1]]
14:05:06 <jle`> Qndel: you can use (++)
14:05:12 <jle`> > [1,2,3] ++ [4,5,6]
14:05:14 <lambdabot>  [1,2,3,4,5,6]
14:05:17 <Qndel> ok :D
14:05:51 * dmwit gets the feeling we are writing Qndel's entire application one ten-character code answer at a time
14:06:16 <monochrom> yes, this is why I stopped answering two hours ago.
14:06:44 <jle`> there should be a program where you can give a description/type signatures and it uses IO to write the program for you by using a combination of stack overflow and irc bots
14:06:51 <jle`> by should i mean shouldn't
14:07:11 <monochrom> "I know nothing and I have this project to do and it's probably due tomorrow" is a trainwreck from the very first minute it was said.
14:07:44 <srhb> I don't understand why you feel the need to comment on it though.
14:07:48 <dmwit> jle`: http://esolangs.org/wiki/IRC
14:07:52 <srhb> If people want to help, they'll help. If not, they won't.
14:08:02 <srhb> And the channel won't be full of bitter spam :)
14:08:03 * hackagebot invariant 0.2.1 - Haskell 98 invariant functors  https://hackage.haskell.org/package/invariant-0.2.1 (ryanglscott)
14:08:05 * hackagebot foldl-transduce 0.4.3.0 - Transducers for foldl folds.  https://hackage.haskell.org/package/foldl-transduce-0.4.3.0 (DanielDiazCarrete)
14:08:08 <monochrom> from hanging around in those math homework help channels, I learned one precious lesson: don't answer on Sundays.
14:08:10 <dmwit> jle`: Oh, wait, that wasn't the language I wanted to point to.
14:08:32 <srhb> monochrom: You're not not answering. You're commenting, repeatedly, on why it's wrong of people to answer. :P
14:09:19 <glguy> This is getting quite meta
14:09:25 <monochrom> because Sundays are filled with procrastinator questions who have non-trivial homework due the next day. they are too desperate to want to learn.
14:09:38 <dmwit> jle`: Anyway there's a channel here on Freenode which is essentially what you're saying. You describe a computation and ask nicely for somebody to perform it for you, and other people hanging out on the channel give it a go.
14:09:53 <jle`> but we do not refer to it by name?
14:09:53 <monochrom> (of course, if you are fine with just giving copyable answers, good for you)
14:10:06 <dmwit> jle`: I would refer to it by name if I could remember the name. =P
14:10:12 <jle`> we do not speak of it
14:10:49 <jle`> there should be a programming language that does all of its arithmetic through calls through Mechanical Turk
14:11:07 <jle`> s/programming language/haskell library
14:11:11 <dmwit> jle`: Here we go! https://esolangs.org/wiki/IRP
14:11:41 <hexagoxel> srhb: maybe monochrom is concerned about the contents of this channel in just the same way that you seem to be (as you "merely" comment on monochroms commenting)
14:11:51 <srhb> hexagoxel: I think so, yes :)
14:11:56 <breadmonster> Hello, everyone.
14:11:58 <srhb> It would be nice with actual policy here.
14:12:11 <breadmonster> I finally have a legit project idea, except I have no idea how to pull it off. 
14:12:14 <breadmonster> Can someone help me out?
14:12:22 <srhb> breadmonster: Try asking about it, and maybe someone will.
14:12:24 <breadmonster> How do I implement dynamically updating variables.
14:12:27 <breadmonster> ? 
14:12:32 <srhb> breadmonster: A map with names and values?
14:12:43 <srhb> Wrap a State over that and you're done.
14:12:52 <breadmonster> srhb: No, like I mean variables that have dependence on other variables.
14:12:54 <monochrom> no, I am concerned with your mental health, when your goal is teaching, but your audience has a conflicting goal.
14:12:56 <srhb> Ah
14:13:04 <breadmonster> So that once you change one of them, everything updates.
14:13:07 <srhb> monochrom: OK, now you're just being rude.
14:13:19 <monochrom> I disagree.
14:13:22 <jle`> dmwit: nice read :)
14:13:32 <jle`> breadmonster: it depends on how you want to eventually use them
14:13:36 <jle`> or what sort of interface you'd want
14:13:42 <jle`> but i guess that's a part of the question too, huh? :)
14:13:52 <breadmonster> haha, yup yup.
14:14:38 <Qndel> that's how I move my character (SpecialKey KeyLeft ) -> ppos $~! \(x,y) -> (x-0.1,y)
14:14:51 <Qndel> how can I check if (x,y) is in the list?
14:14:57 <jle`> breadmonster: there are "spreadsheet" libraries in haskell that are based on comonads
14:15:04 <breadmonster> Ideally, I'd have some type `DVar a` and a function `peek :: DVar a -> a` and some function `update = fmap`.
14:15:07 <dmwit> Qndel: Have you tried looking through the fine documentation?
14:15:11 <breadmonster> jle`: Damn, I wanted to implement one myself.
14:15:14 <jle`> breadmonster: basically your program is an infinite spread sheet, where every cell depends on every other cell
14:15:18 <dmwit> breadmonster: We have several varieties of ref cells.
14:15:25 <breadmonster> dmwit: :(
14:15:28 <jle`> breadmonster: and you can "update" a cell, and you get a new spreadsheet of updated values based on what you updated
14:15:35 <srhb> Qndel: You can even look it up by type if you consider what the arguments should be and what the result should be. 
14:15:47 <dmwit> ?where hoogle
14:15:47 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
14:16:00 <Qndel> yes I tried
14:16:07 <jle`> breadmonster: the whole thing is nice because it's like a direct application of comonads
14:16:08 <dmwit> What did you try?
14:16:16 <Qndel> but I'd have to print values to debug things
14:16:23 <Qndel> and I have no idea how to do it :D
14:16:39 <dmwit> ?where tutorials
14:16:39 <lambdabot> http://haskell.org/haskellwiki/Tutorials
14:16:42 <breadmonster> jle`: Okay, shame, but like really, it's awesome.
14:16:52 <breadmonster> jle`: Mathematica has something like this.
14:17:10 <jle`> breadmonster: if you don't want to go through the comonadic approach maybe you can model it using explicit graphs
14:17:40 <dmwit> breadmonster: I don't really understand why you sent me a sad face. Can you say a bit more?
14:17:41 <jle`> or like, data Val = Lit Int | FromAddr String (Int -> Int)
14:17:48 <jle`> and then having a Map String Val
14:18:18 <jle`> where String is the "name" of the memory hole, and FromAddr name f means that the value at that location is a reference to the cell at that given `name`, and applying a function to it
14:19:01 <breadmonster> dmwit: It was the first exciting project I thought of, since I'm a Haskell n00b. Ideally, it wouldn't have been done before.
14:19:12 <jle`> this is sort of an explicit graph implementation of what the comonadic spreadsheet library does
14:19:37 <Qndel> can I compare with Nothing?
14:19:43 <jle`> you can pattern match
14:19:51 <Qndel> because I see that find can return the element I want to find or Nothing
14:20:05 <dmwit> breadmonster: Aha. Well, you can always tackle it anyway. Can be fun to reimplement things for yourself. =)
14:20:18 <jle`> case thing of Just x -> stuff-with-x; Nothing -> stuff-with-nothing
14:20:24 <geekosaur> you can compare with if the type has an Eq instance, but in general you want a pattern match instead
14:20:40 <jle`> breadmonster: i say, implement it for fun :)
14:20:48 <jle`> if learning is your goal
14:21:32 <srhb> Qndel: You can, Maybe a has an Eq instance. Or you could search for a -> [a] -> Bool
14:21:32 <breadmonster> jle`: I'm trying to think of an efficient way of doing this, but the problem is that the type system gets in my way.
14:21:54 <jle`> or maybe you are getting in the way of the type system? :)
14:22:03 <geekosaur> I think if the type system is "getting in your way" then you are probably doing it wrong :)
14:22:25 <jle`> the best solution will probably be one where the type system *helps* you and pushes you to places you could have never reached before
14:23:31 <jle`> if your types stop you then it's almost always because the programmer is the one that's wrong, heh
14:24:40 <Jinxit> just sitting down and thinking about the type of my function helps me a lot
14:24:50 <Jinxit> after that it's almost always smooth sailing
14:26:00 <Qndel> can I use do in pattern matching?
14:26:09 <kristof> How do I partially apply a type constructor somewhere other than the leftmost parameter?
14:26:12 <jle`> Qndel: i know one way to find out :)
14:26:20 <Qndel> keyboardMouse prevPos x y a p ppos key Down _ _ = case key of
14:26:22 <Qndel> (SpecialKey KeyLeft ) -> do
14:26:31 <jle`> the compiler is your friend
14:26:44 <Qndel>     parse error (possibly incorrect indentation or mismatched brackets) Failed, modules loaded: Display, Cube, Points, Ground.
14:26:47 <kristof> Newtype, like Flip b a = Either a b ?
14:26:54 <Qndel> I feel that compiler hates me
14:27:20 <jle`> Qndel: you need to indent more on the SpecialKey case...it has to be past the k in keyboardMouse
14:27:27 <dmwit> Qndel: Indent the patterns more than their enclosing blocks; indent the lines of the `do` block more than their enclosing block.
14:27:42 <Qndel> I think I did
14:27:50 <kristof> Qndel: lpaste it, please?
14:27:52 <dmwit> ?paste your exact code
14:27:52 <lambdabot> Haskell pastebin: http://lpaste.net/
14:28:05 <Qndel> http://lpaste.net/140863
14:28:08 <kristof> Qndel: If you want to avoid a nasty indent, then put the case on a newline
14:28:19 <dmwit> kristof: That is not necessary.
14:28:32 <jle`> kristof: you can use a type synonym too sometimes
14:28:36 <srhb> Qndel: You can't just throw a let binding in the middle like that.
14:28:42 <Qndel> :D
14:28:43 <jle`> it depends on what you want to do with it
14:29:19 <Qndel> so where can I put it?
14:29:39 <Qndel> if I put it above the case, the compiler doesn't like it anyway
14:29:49 <srhb> Qndel: You can use let foo = bar in expr inside expressions and let foo = bar in do blocks.
14:30:07 <dmwit> srhb: Might be good to delimit the code part of your answer somehow.
14:30:13 <dmwit> srhb: It's a bit confusing otherwise.
14:30:16 <srhb> dmwit: Good point.
14:30:36 <Sindriava> What's the lens equivalent of Reader's `local` ?
14:30:37 <srhb> Qndel: `let foo = bar in expr` is an expression and goes in expressions. `let foo = bar` is only valid in do blocks.
14:31:05 <Qndel> not in scope find
14:31:10 <Qndel> where can I find find?
14:31:11 <Qndel> :D
14:31:20 <srhb> Qndel: Look it up with hoogle, as linked earlier :)
14:31:29 <mniip> srhb, find find in hoogle
14:31:34 <mniip> err, Qndel &
14:31:38 <mniip> err *
14:32:12 <Qndel>     Couldn't match type `(GLfloat, GLfloat)'                   with `IORef (GLfloat, GLfloat)'
14:32:14 <Qndel> pff :/
14:32:45 <Sindriava> Qndel: You trying to use `IORef a` as `a`
14:32:51 <breadmonster> jle`: How do I get started modeling the graph?
14:32:56 <Sindriava> > :t readIORef
14:32:56 <dmwit> I used to hate type errors. Then I tried hacking on a largish Python project for a few weeks.
14:32:58 <lambdabot>  <hint>:1:1: parse error on input ‘:’
14:33:03 <Sindriava> :t readIORef
14:33:04 <lambdabot>     Not in scope: ‘readIORef’
14:33:04 <lambdabot>     Perhaps you meant ‘readSTRef’ (imported from Data.STRef)
14:33:09 <Qndel> will get help me?
14:33:11 <Sindriava> Something like that
14:33:17 <Qndel> (x',y') <- get pos
14:33:23 <jle`> breadmonster: by graph here i meant just `Map NodeAddress SomeType`, where SomeType may contain a `NodeAddress` field
14:33:23 <Qndel> thats what I used on some other tuple ioref
14:33:32 <jle`> basically pointer manipulation heh
14:33:56 <breadmonster> jle`: Could I PM?
14:34:08 <jle`> so like for your case, Map CellAddr Val; data Val = Lit Int | FromAddr CellAdr (Int -> Int)
14:34:23 <jle`> breadmonster: sure, but i'm sort of working on a couple of things right now so i might not be able to reply timely ever :|
14:34:32 <Qndel> sweet jesus, it compiled!
14:36:06 <athan> haskell is cool
14:36:18 <breadmonster> jle`: Sure, but like what if I want it in full generality? Like the cell dependencies don't have to have the same type?
14:36:21 <breadmonster> It just needs to typecheck.
14:37:32 <breadmonster> jle`: I'll leave you a memo.
14:43:32 <Profpatsch> Okay, really dumb question:
14:43:48 <Profpatsch> Is there some kind of pattern guards for case?
14:44:23 <Qndel> http://lpaste.net/140864\
14:44:25 <Qndel> http://lpaste.net/140864
14:44:34 <geekosaur> shouldn't they just work? top level definitions desugar to case...
14:44:34 <Qndel> sometimes it works, sometimes it doesn't
14:44:40 <Qndel> do you think it might be because of rounding error?
14:45:11 <Profpatsch> geekosaur: I’ve got case get "address" of
14:45:26 <Profpatsch> And the result is a Response
14:45:40 <geekosaur> Qndel, if your type is not Rational then probably yes
14:45:49 <Qndel> its GLfloat
14:45:49 <Profpatsch> So something likecase get … of resp
14:46:02 <geekosaur> I think there might be a Map-with-error-bars somewhere on hackage for use with Double
14:46:17 <Profpatsch>   | resp^.responseBody == ok200 -> Something
14:46:20 <geekosaur> pretty much the same thing, so yes
14:47:00 <dmwit> Profpatsch: That doesn't even require any extensions. That's just a normal old guard.
14:47:19 <Profpatsch> ugh, I’m too tired.
14:47:31 <Profpatsch> r <- get "http://"
14:47:36 <Profpatsch> case r of
14:47:48 <Qndel> I'll just convert my coordinates into Int
14:47:50 <dmwit> Don't paste multiline code in-channel.
14:47:51 <dmwit> ?paste
14:47:51 <lambdabot> Haskell pastebin: http://lpaste.net/
14:47:53 <Profpatsch>   | r^.responseBody -> Something
14:48:02 <Qndel> and zoom away from the game
14:48:34 <edwardk> Sindriava: 'magnify'
14:48:46 <edwardk> Sindriava: magnify works on reader, zoom works on state
14:49:03 <Sindriava> edwardk: Thanks!
14:50:37 <Gurkenglas> :t \f g -> [mapM f >=> mapM g, mapM (f >=> g)] -- equal for commutative monads, right?
14:50:38 <lambdabot> (Monad m, Traversable t) => (a -> m b1) -> (b1 -> m b) -> [t a -> m (t b)]
14:54:22 <dmwit> Gurkenglas: Sounds plausible.
14:54:40 <Qndel> how would I convert GLfloat to float?
14:56:08 <dmwit> :t realToFrac
14:56:09 <lambdabot> (Fractional b, Real a) => a -> b
14:56:20 <dmwit> That one is not easy to find.
14:57:30 <dmwit> Huh, the documentation for base doesn't list a Fractional Double or FractionalFloat instance.
14:57:33 <dmwit> That's odd.
14:57:41 <dmwit> > fromRational 1 :: Double
14:57:43 <lambdabot>  1.0
14:59:10 <Qndel> mouseWheel a num dir _ = a $~! (+(a*0.1*(fromIntegral dir)))
14:59:19 <Qndel> a is IORef GLfloat
14:59:43 <Qndel>   Couldn't match type `IORef GLfloat' with `Foreign.C.Types.CFloat'   Expected type: GLfloat     Actual type: IORef GLfloat
14:59:59 <geekosaur> dmwit, another haddock bug I think
15:00:07 <geekosaur> it confuses Double with its newtype CDouble
15:00:10 <Qndel> I tried realToFrac but didn't work
15:00:36 <geekosaur> Qndel, if you have an IORef then you need to use readIORef to extract the value from it
15:00:47 <dmwit> geekosaur: reported here https://github.com/haskell/haddock/issues/444
15:01:48 <dmwit> geekosaur: The `Floating` class has instances listed for both Double and CDouble.
15:01:55 <dmwit> for what that's worth
15:02:07 <Qndel> mouseWheel a num dir _ = a $~! (+((readIORef a)*0.1*(fromIntegral dir)))
15:02:16 <Qndel>     Couldn't match type `IO GLfloat' with `Foreign.C.Types.CFloat'
15:02:40 <srobert> cabal install dumps core every time I try to run it.  This is from the latest port build on FreeBSD 10.2. Has anyone else experienced this?
15:02:47 <geekosaur> yes, you cant do it like that because an IORef is in IO
15:02:54 <Qndel> sweet jesus
15:02:58 <Qndel> what do I have to do then? :D
15:03:14 <Qndel> I just want to increase/decrease the variable by its 10%
15:03:18 <kristof> Who thought $~! was a good operator?
15:03:24 <Qndel> no idea
15:03:30 <Qndel> I have no clue what I'm doing
15:03:38 <kristof> ~ means lazy and ! means strict
15:03:45 <Qndel> pasting random bunch of code from the internet together
15:03:48 <geekosaur> that was the author of the opengl package trying to channel lens before lens existed :p
15:04:05 <edwardk> geekosaur: =P
15:04:07 <kristof> I'm reading that as "do this lazy pattern strictly"
15:04:07 <geekosaur> my guess is you want a "modify" operator, not a "set" operator
15:04:41 <Qndel> so how would I increase/decrease the variable by 10%?
15:05:14 <edwardk> v $~! (* 0.9)
15:05:29 <Qndel> what does ~mean? :D
15:05:40 <srhb> Nothing, it's just part of the operator name.
15:05:43 <edwardk> he StateVar package uses ~ for 'update' and = for assignment
15:05:43 <srhb> Sadly.
15:06:13 <edwardk> ! is if its strict or not
15:06:25 <geekosaur> I think they want 1.1 instead of 0.9 there?
15:06:39 <edwardk> well it was increase/decrease so i picked one =)
15:07:01 <Qndel> I can't do it that way
15:07:09 <Qndel> mouseWheel a num dir _ = a $~! (+((readIORef a)*0.1*(fromIntegral dir)))
15:07:12 <Qndel> thats my current code
15:07:20 <Qndel> the dir takes 1 or -1 value
15:07:22 <geekosaur> why can't you do it that way?
15:07:39 <Qndel> so I want to increase the variable by 10% or decrease, depending on the value of dir
15:08:02 <Qndel> or wait ...
15:09:00 <edwardk> mouseWheel a dir = modifyIORef a (* if dir == -1 then 0.9 else 1.1)
15:09:24 <edwardk> probably modifyIORef'
15:09:47 <Qndel> thanks
15:09:49 <edwardk> anyways the readIORef you have shoved in there doesn't make sense
15:09:51 <Qndel> I think mouseWheel a num dir _ = a $~! (*(1+0.1*(fromIntegral dir))) did the trick
15:10:04 <edwardk> that works too
15:10:20 <srhb> You have some superfluous parens there.
15:10:51 <Qndel> where?
15:10:55 <srhb> The innermost one
15:11:04 <Qndel> ;o
15:13:13 <srhb> Qndel: Function application has the highest precedence. :)
15:13:36 <Qndel> in other words, black magic :D
15:13:53 <srhb> Qndel: I don't think you really mean that precedence is black magic. :P
15:14:36 <srhb> (You seem to be grasping it just fine wrt numerical operators)
15:14:38 <Qndel> I've got so many strange errors that I'm putting parentheses everywhere
15:15:27 <hpc> srhb: once you get out of basic algebra / category stuff, operator precedence is arbitrary and hard to remember
15:16:07 <srhb> hpc: I don't doubt it. Not really the case here though. :)
15:17:01 <exio4> well, once I got to the point where I was comfortable, at least to some basic point, writing Haskell, I abused ()s too 
15:17:41 <srhb> Superfluous parens are pretty common, function application is just the easy one to root out. :)
15:17:41 <sternenseemann> hello, anyone familiar with the linear library? If I want to have floating Point numbers and floating point V2 and multiply them with each other what is the Type to go? CDouble?
15:17:52 <sternenseemann> because I have Problems with Double and Float
15:18:06 * hackagebot fast-tags 1.1.1 - Fast incremental vi and emacs tags.  https://hackage.haskell.org/package/fast-tags-1.1.1 (EvanLaforge)
15:18:30 <exio4> srhb: sometimes I prefer () for making the code look more regular
15:18:41 <srhb> exio4: Sure. :)
15:19:07 <sternenseemann> nope CDouble was just silly :D
15:19:10 <srhb> It wasn't a huge complaint, I was ust pointing it out.
15:19:23 <sternenseemann> in ghci everything works fine
15:19:48 <sternenseemann> :t gives me always type signatures with (Num a) =>; (Fractional a) etc.
15:19:50 <lambdabot> parse error on input ‘type’
15:19:53 <sternenseemann> :D
15:20:28 <sternenseemann> but I have an Type defined with data, so I can't use Typeclasses I suppose?
15:20:44 <geekosaur> sternenseemann, are you trying to use (*) to multiply them? I think you need to use (^*) or (*^)
15:21:01 <sternenseemann> oh wait
15:21:06 <geekosaur> because (*) requires everything to have the same type
15:21:12 <sternenseemann> maybe I just found a  very stupid mistake, hang on
15:21:15 <geekosaur> and a vector is not going to be the same type as a scalar
15:22:33 <sternenseemann> geekosaur: I would like to have it as nice as in ghci
15:22:46 <sternenseemann> geekosaur: where I can just do 2.0 * (V2 1.0 3.0)
15:22:58 <sternenseemann> but it is (Num a) => a
15:23:14 <sternenseemann> and V2 has a Num instance
15:23:53 <geekosaur> hm, right
15:24:13 <geekosaur> can you show the full error message you get
15:24:14 <geekosaur> @paste
15:24:14 <lambdabot> Haskell pastebin: http://lpaste.net/
15:24:20 <geekosaur> ^ use a pastebin don't paste into the channel;
15:24:29 <sternenseemann> hang on
15:24:39 <geekosaur> this *shouldn't* be extended defaulting, I think...
15:25:44 <sternenseemann> geekosaur: http://lpaste.net/140868
15:26:40 <eikke> :t (*)
15:26:41 <lambdabot> Num a => a -> a -> a
15:26:47 <geekosaur> oh, I see
15:27:05 <geekosaur> you are getting what you expect not because ghci is special, but because numeric literals are special
15:27:42 <geekosaur> so if you say 2.0 * (V2 1.0 3.0), Haskell turns 2.0 into an appropriate V2
15:27:54 <eikke> :t 2.0
15:27:56 <lambdabot> Fractional a => a
15:28:06 <mniip> fromRational (20 % 10)
15:28:07 <geekosaur> but it only does that for literals, not for computed values, so it won't do that with (vectorLength distanceVector)
15:28:41 <sternenseemann> geekosaur: yeah right
15:29:02 <sternenseemann> geekosaur: *^ ^* seem to be the way to go
15:29:10 <sternenseemann> geekosaur: altough this is kind of sad
15:29:31 <geekosaur> you may be able to use fromIntegral (vectorLength distanceVector)
15:29:35 <eikke> sternenseemann: you could turn your float into a V2something
15:29:47 <geekosaur> hm, may not be an Integral though, nemmind
15:29:54 <geekosaur> wrong kind of length
15:30:09 <eikke> :t fromRational
15:30:10 <lambdabot> Fractional a => Rational -> a
15:30:17 * geekosaur waiting for brain to come back, @#$%&* sinuses...
15:30:52 <sternenseemann> geekosaur: it compiles with the scalar product operator
15:31:12 <sternenseemann> geekosaur: I will try fromRational definately
15:31:43 <sternenseemann> geekosaur: slowly my brain is putting together everything it knows about numbers in Haskell :)
15:31:47 <geekosaur> it's not a Rational though. and I think going that way has some other nasties lying in weight
15:31:49 <geekosaur> *in wait
15:32:02 <geekosaur> I think it's a Double?
15:32:15 <eikke> Float, in the compiler error
15:32:18 <sternenseemann> currently Float
15:32:21 <geekosaur> right
15:32:31 <sternenseemann> not sure if I should switch for Double atm
15:32:37 <geekosaur> it's going to be annoying in any case, just use the scalar multuiplication op
15:33:06 * hackagebot settings 0.1.0.1 - Runtime-editable program settings.  https://hackage.haskell.org/package/settings-0.1.0.1 (akrasner)
15:33:14 <geekosaur> (we're getting somewhat near a conversion operation that is infamously slow)
15:33:25 * eikke thinks it makes sense to use a more-precise less-abstract function/operator for these operations
15:33:29 <sternenseemann> geekosaur: okay, sounds reasonable
15:33:52 <sternenseemann> geekosaur: oh really?
15:34:04 <geekosaur> basically, fromRational would work but generating a Rational from a random Float or Double is *nasty*
15:34:23 <eikke> geekosaur: maybe it shouldnt be a float in the first place ;-)
15:34:42 <Qndel> okay
15:34:48 <Qndel> now wall is blocking movement properly
15:35:04 <Qndel> didn't change the value type but multiplied the floats by 10 so they are integers
15:35:04 <sternenseemann> eikke: what then?
15:35:05 <geekosaur> because it has to handle the general case, where generating a Rational equivalent to (say) pi/4 is pretty bad
15:35:11 <sternenseemann> Double?
15:35:25 <Qndel> I have to add enemies to my game, how would i make them to move every second?
15:35:27 <sternenseemann> geekosaur: that sounds very inperformant :D
15:36:07 <eikke> sternenseemann: dunno what you're doing exactly, wasn't around from the beginning, but maybe Rational?
15:37:00 <geekosaur> Qndel... I'm probably not the one to ask about this. it sounds like you may want to look into functional reactive programming
15:37:05 <sternenseemann> eikke: wow, that's an intersting type sound interesting
15:38:06 <sternenseemann> eikke: if it is giving me advantages, I should use – also I generate all my values randomly so constructing a Rational shouldn't be a problem
15:39:37 <sternenseemann> eikke: but using Rational doesn't give me advantages whilst interacting with linear, does it?
15:40:18 <exio4> geekosaur: it's homework, I don't think we know how he should do it 
15:40:25 <eikke> sternenseemann: I was referring to someone else's comment about the fact floats can't always become nice rationals or something, so I was wondering whether float is the correct type in the first case (depending on where the float comes from, e.g. some divisions going on), nothing more
15:40:45 <geekosaur> oh, homework, I expect if they wanted you to use FRP then you would have known it up front
15:42:36 <sternenseemann> eikke: oh, I see
15:42:45 <sternenseemann> must have misunderstood that
15:42:54 <Qndel> functional reactive programming
15:42:58 <Qndel> sounds scary
15:43:08 <sternenseemann> Qndel: pretty cool thing though
15:43:22 <sternenseemann> Qndel: I can really recommend having a look at FRPNow
15:43:27 <Qndel> sounds too complicated
15:43:36 <Qndel> I'll pass
15:43:40 <sternenseemann> :D
15:43:45 <Qndel> can I get a simple time value in haskell?
15:43:54 <Qndel> because I already have a function
15:44:02 <Qndel> I think its called every frame or something
15:44:17 <Qndel> so I'd just have to keep 1 second intervals between moves
15:45:22 <sternenseemann> is this function in the IO Monad?
15:46:10 <Cale> I don't know what type of game you're making. Do things move at intervals other than a second?
15:46:43 <sternenseemann> Qndel: you're problem would be easily solvable with FRP btw :)
15:46:51 <Cale> If it's otherwise "real time", you'd want to store the last time that the thing moved, and check if the difference from the current time is more than a second.
15:47:19 <Cale> I love FRP, but it's a huge detour
15:47:36 <Cale> http://hackage.haskell.org/package/time-1.5.0.1/docs/Data-Time-Clock.html
15:47:41 <Cale> getCurrentTime :: IO UTCTime
15:47:44 <Qndel> uhm cale
15:47:46 <Qndel> that's what I said
15:47:50 <Cale> diffUTCTime :: UTCTime -> UTCTime -> NominalDiffTime
15:47:56 <Qndel> I just asked about a way to get the time in haskell :D
15:48:07 * hackagebot uri-bytestring 0.1.9 - Haskell URI parsing as ByteStrings  https://hackage.haskell.org/package/uri-bytestring-0.1.9 (MichaelXavier)
15:48:42 <Welkin> :t getCurrentTime
15:48:43 <lambdabot> Not in scope: ‘getCurrentTime’
15:48:59 <Cale> You probably want getCurrentTime somewhere (even if you were using FRP, there would probably need to be a getCurrentTime somewhere).
15:49:28 <Cale> But you can collect its result and pass the resulting UTCTime throughout your game logic, if you'd prefer to keep the logic free of IO
15:50:04 <Welkin> https://hackage.haskell.org/package/time-1.5.0.1/docs/Data-Time-Clock.html
15:50:32 <Cale> Something important to note: NominalDiffTime is an instance of Num, and the numbers are treated as seconds.
15:50:44 <sternenseemann> eikke, geekosaur: thank you for your help, I have got it right :D
15:51:59 <sternenseemann> Cale: might be true, but I'm pretty enthusiastic about it
15:52:11 <Cale> So you can test whether diffUTCTime tNow tLastMoved > 1
15:52:28 <sternenseemann> going to bed now, I am up for 16 hours already :O
15:52:31 <Cale> sternenseemann: Yeah, I've worked on an action RPG written in Haskell using FRP
15:52:41 <sternenseemann> Cale: what library?
15:52:50 <Cale> An internal library
15:52:58 <sternenseemann> oh, wow
15:52:58 <Cale> (was never released to the public)
15:53:11 <Cale> sternenseemann: and I use FRP in my current job (reflex-dom)
15:53:41 <sternenseemann> Cale: cool!
15:54:03 <Cale> I'm working for Obsidian Systems, we're rewriting Lanehoney's web application in Haskell using reflex-dom and Snap
15:54:28 <Cale> It's nice being able to use the same data structures and common code between the frontend and backend :)
15:55:59 <sternenseemann> Does reflex-dom generate JS?
15:56:29 <c_wraith> Sounds like it must, given what Cale says about it. :)
15:56:40 <sternenseemann> yeah
15:56:55 <sternenseemann> I am probably too tired, going to sleep now o/
15:57:00 <exio4> ghcjs generates JS
15:57:14 <sternenseemann> good night/day/morning guys!
15:57:39 <ttt_fff> what's the name of a type system where instead of just saying "Array of Int", I can say "Array of Int, where valid indices are between 0 and n" ?
15:58:44 <Iceland_jack> ttt_fff: Are you looking for LiquidHaskell
16:00:23 <pavonia> Dependent types maybe?
16:01:42 <srhb> Sounds dependent. 0 and n are usually terms. 
16:01:50 <srhb> If ttt_fff mean that terms are in the type, it's pretty much dependent.
16:02:24 <geekosaur> subtyping?
16:03:10 <Iceland_jack> You can implement that in dependently typed languages like LiquidHaskell, Agda, Idris, Coq, ...
16:03:54 <Iceland_jack> but you don't need full dependent types for examples like that
16:06:13 <exio4> well, can't you implement it in the quasi-dependent GHC Haskell? :p
16:07:05 <srhb> Yep!
16:07:22 <srhb> And that's a good name, too. :P
16:18:08 * hackagebot kan-extensions 4.2.3 - Kan extensions, Kan lifts, various forms of the Yoneda lemma, and (co)density (co)monads  https://hackage.haskell.org/package/kan-extensions-4.2.3 (EdwardKmett)
16:18:10 * hackagebot adjunctions 4.2.2 - Adjunctions and representable functors  https://hackage.haskell.org/package/adjunctions-4.2.2 (EdwardKmett)
16:18:12 * hackagebot linear 1.20 - Linear Algebra  https://hackage.haskell.org/package/linear-1.20 (EdwardKmett)
16:18:53 <chpatrick1> Prompt looks very similar to Control.Monad.Free.Church
16:19:05 <chpatrick1> is there an advantage one way or the other?
16:22:36 <c_wraith> chpatrick: they're the same thing.  As is operational.  And operational-free
16:22:39 <c_wraith> chpatrick: and others.
16:22:48 <c_wraith> chpatrick: well, *nearly* the same thing.
16:22:51 <chpatrick1> thought so
16:23:05 <chpatrick1> I jus haven't heard of prompt until I looked at random-fu's source
16:23:21 <c_wraith> They're all free monad constructions of one sort or another.
16:23:29 <c_wraith> Prompt is actually the oldest of the family, I think.
16:24:02 <chpatrick1> the kmett one is probably the most popular these days right?
16:24:32 <Qndel> paste
16:24:35 <geekosaur> that's my recollection, yes, prompt was the first one
16:24:57 <Qndel> http://lpaste.net/140871
16:25:01 <Qndel> can you look at this code?
16:25:09 <Qndel> I can't get it to work
16:25:21 <Hijiri> paste the error too
16:25:40 <chpatrick1> what is $~!?
16:25:46 <Qndel> Display.hs:61:5: parse error on input `print'
16:25:57 <Qndel> assigning variable I hope
16:26:04 <chpatrick1> can't do that in haskell :)
16:26:06 <geekosaur> you need to have another "do"
16:26:12 <geekosaur> if ... then do
16:26:18 <Qndel> ohh lol
16:26:47 <chpatrick1> where did you get that operator from?
16:27:32 <Qndel> I got it from the internet
16:27:40 <Qndel> thats how modifying a variable was made mouseWheel a num dir _ = a $~! (*(1+0.1*fromIntegral dir))
16:28:09 * hackagebot reflection 2.1 - Reifies arbitrary terms into types that can be reflected back into terms  https://hackage.haskell.org/package/reflection-2.1 (EdwardKmett)
16:28:11 * hackagebot lens 4.13 - Lenses, Folds and Traversals  https://hackage.haskell.org/package/lens-4.13 (EdwardKmett)
16:28:18 <chpatrick1> can you link it?
16:29:31 <Qndel> here
16:29:31 <Qndel> https://wiki.haskell.org/OpenGLTutorial2
16:29:47 <arkeet> that's modifying an IORef
16:29:52 <Qndel> cool
16:29:56 <Qndel> that's exactly what I want
16:30:01 <Qndel> but somehow doesn't work
16:30:09 <Qndel> lastTime $~! (integralTime)
16:30:13 <Qndel> is it bad?
16:30:14 <arkeet> lastTime isn't an ioref
16:30:18 <Qndel> it should be
16:30:27 <arkeet> at least, it can't be if lastTime /= integralTime works
16:30:44 <Qndel> but lastTime is IORef Int
16:30:53 <arkeet> ok, well lastTime /= integralTime won't work then.
16:31:01 <chpatrick1> ah it's StateVar
16:31:39 <chpatrick1> yes then you need to read the current lastTime and compare that
16:31:44 <chpatrick1> not the ioref directly
16:32:16 <Qndel> myTime <- get lastTime
16:32:26 <Qndel> if myTime /= integralTime then do     like this?
16:32:28 <chpatrick1> yep
16:32:38 <Qndel> but still lastTime $~! integralTime doesn't work
16:32:52 <Qndel>   Couldn't match expected type `Int -> Int' with actual type `Int'   In the second argument of `($~!)', namely `integralTime'   In a stmt of a 'do' block: lastTime $~! integralTime
16:32:54 <chpatrick1> do you want $=!?
16:33:02 <Qndel> what's that?
16:33:04 <Qndel> assignment?
16:33:05 <chpatrick1> it's assing
16:33:06 <chpatrick1> yeah
16:33:07 <Qndel> sure
16:33:10 <chpatrick1> $~ applies a function
16:33:17 <Qndel> my hero :)
16:33:19 <Welkin> oh
16:33:23 <Qndel> that's why I came here!
16:33:28 <Welkin> that is using the old OpenGL bindings
16:33:29 <Qndel> you know all these things
16:33:29 <Welkin> ugh
16:33:35 <Qndel> and I'd waste hours trying to figure it out
16:33:38 <Welkin> well
16:33:42 <chpatrick1> this style is a bit oldschool
16:33:45 <Welkin> the "high-level" opengl haskell bindings suck
16:33:53 <Welkin> they are very confusing
16:34:02 <Welkin> even worse since opengl by itself is confusing
16:34:40 <Qndel> what can I say? new to opengl and haskell
16:34:41 <Qndel> xD
16:34:57 <chpatrick1> that's kinda the deep end together :D
16:35:17 <greg`> is it possible to specify a number like 1e-1 in haskell?
16:35:25 <chpatrick1> you can write it just like that I think
16:35:28 <Welkin> > 1e-1
16:35:30 <lambdabot>  0.1
16:35:42 <Qndel> okay
16:35:42 <greg`> thanks
16:35:46 <Qndel> so that was just IORef int
16:35:58 <Qndel> now I have IORef [(GLfloat,GLfloat)]
16:36:13 <Qndel> I have to modify each tuple
16:36:20 <Qndel> how would I do this?
16:36:39 <chpatrick1> you could use %~
16:36:49 <Qndel> and what's that ? :D
16:36:51 <MarcelineVQ> :t 1e-1
16:36:53 <lambdabot> Fractional a => a
16:37:01 <chpatrick1> err
16:37:02 <chpatrick1> $~
16:37:03 <chpatrick1> sorry
16:37:10 <Qndel>  :D
16:37:24 <Qndel> cool
16:39:38 <Qndel> forM ePos $~! \(x,y) -> (x,y+1)
16:39:43 <Qndel> can't do this for IORef
16:39:54 <chpatrick1> that doesn't make sense
16:40:02 <chpatrick1> what is ePos?
16:40:10 <Qndel> IORef [(GLfloat,GLfloat)]
16:40:44 <chpatrick1> so you want to apply a function to everything in the ioref
16:41:08 <chpatrick1> you want ePos $~! map ...
16:42:53 <Qndel> that's confusing
16:42:55 <Qndel> and what after map?
16:43:56 <Axman6> the function you want to apply to each element of the list
16:45:15 <Qndel> so the function takes (GLfloat,GLfloat)
16:45:18 <Qndel> and what does it return?
16:45:35 <Axman6> (GLfloat, GLfloat)
16:45:36 <chpatrick1> the same
16:45:39 <Qndel> ohh
16:46:17 <Axman6> (if it doesn't, you're going to be in a lot of trouble - this is how you implement unsafeCoerce in haskell if you're not careful))
16:46:34 <chpatrick1> btw I just want to say this IO-heavy stuff isn't a very nice way to get introduced to haskell
16:46:52 <Axman6> yeah it seems like you're missing a lot of the basics of Haskell
16:46:53 <chpatrick1> pure stuff is a lot nicer
16:47:24 <Qndel> I finish this game and I won't touch haskell ever again
16:47:25 <chpatrick1> opengl is not where you really see the benefits
16:47:25 <Qndel> :P
16:47:38 <chpatrick1> that's a shame though :(
16:47:48 <Qndel> it's too tricky for me
16:48:00 <chpatrick1> but it's also a particularly bad case for haskell imo
16:48:10 <Qndel> I write code, compile and I'm actually surprised when it works
16:48:14 <chpatrick1> writing stuff like a compiler is beautiful
16:48:23 <chpatrick1> opengl stuff not so much
16:48:28 <Qndel> :D
16:48:34 <Axman6> Qndel: that's a shame, I assume this is an assignment of some sort then?
16:48:39 <Qndel> yup
16:48:42 <simon> hi. is it hard to make (Integer, Integer) an instance of PrintfArg?
16:49:07 <Qndel> I had this subject almost a year ago
16:49:11 <Axman6> then the point of giving you the assignment is for you to learn something, not for you to get a grade. perhaps you should use it as an excuse to learn something new =)
16:49:14 <Qndel> it's time to finally pass it lol
16:49:19 <simon> StackOverflow suggests doing (\(x,y) -> printf "(%g, %g)" x y) p, but I don't like this.
16:49:32 <arkeet> simon: it is impossible.
16:49:36 <simon> :(
16:49:37 <arkeet> because the class methods are not exported.
16:49:42 <chpatrick1> @hackage formatting -- chek this out simon
16:49:42 <lambdabot> http://hackage.haskell.org/package/formatting -- chek this out simon
16:50:04 <chpatrick1> Qndel: can you tell us what course it is?
16:50:13 <chpatrick1> is it for haskell, opengl or both?
16:50:13 <arkeet> and also because what would you do with the format string.
16:50:19 <Qndel> functional programming
16:50:19 <simon> chpatrick1, thanks!
16:50:21 <arkeet> format string stuff is hardcoded.
16:50:27 <chpatrick1> it's a really weird way to teach haskell
16:50:28 <Qndel> its for haskell
16:50:34 <Qndel> they don't teach haskell that way
16:50:38 <Qndel> I said I'd make a game
16:50:41 <Qndel> <bad idea>
16:50:43 <chpatrick1> :P
16:50:55 <Qndel> I don't have much experience with 3d
16:51:02 <Axman6> Qndel: have you considered using a simpler graphics interface, like Gloss?
16:51:05 <Qndel> so far I've written bots / cheats and some utility programs
16:51:15 <Qndel> no idea whats that
16:51:26 <Axman6> it's much easier to get started - trying to teach yourself both haskell and 3D programming at the same time sounds like a recipe for disaster
16:51:49 <Axman6> do you need your game to be 2D?
16:51:52 <Axman6> uh, 3D?
16:51:52 <Qndel> I like that in other programming languages if something works, it works
16:51:59 <chpatrick1> yeah opengl is a real pain in the ass on its own
16:52:04 <simon> Qndel, you're taking a Haskell course?
16:52:07 <chpatrick1> actually haskell is really famous for that
16:52:08 <Qndel> in haskell something can work but I change 1 parenthesis and it works 100x faster
16:52:21 <Qndel> took haskell at school
16:52:25 <Qndel> thought it be fun
16:52:27 <chpatrick1> can you elaborate?
16:52:30 <Qndel> but apparently its too much fun
16:52:33 <simon> gotta love those magic parentheses.
16:52:41 <Qndel> I had lectures and labs
16:52:53 <Qndel> wrote some encryption in haskell to pass the lecture
16:53:03 <Qndel> wait
16:53:07 <Qndel> wasn't encryption, compression
16:53:13 <Qndel> I wrote the same thing in C++
16:53:17 <Qndel> C++ worked 100x faster
16:53:35 <Qndel> I reversed the order in which I added things to the list in haskell - 100x faster
16:53:47 <chpatrick1> I'm just bummed out that you're having a bad time
16:53:50 <lethjakman> Qndel: Learn you a haskell talks about that. 
16:53:59 <Axman6> probably because you don't have enough experience with Haskell to write fast code. this is the same with pretty much any language
16:54:00 <simon> one of the first things you can do in Haskell to increase performance is to get rid of Strings.
16:54:12 <lethjakman> If I remember right it's because of how lists are composed in haskell. 
16:54:19 <Axman6> there are both encryption and compression algorithms written in haskell that run quite fast
16:54:20 <Qndel> yup
16:54:22 <chpatrick1> yeah that's actually really important
16:54:28 <Qndel> but its so confusing for me
16:54:33 <Qndel> or my program was working
16:54:38 <Qndel> but in a completely weird way
16:54:50 <chpatrick1> it's because haskell lists are linked lists
16:54:50 <Qndel> turned out one parenthesis changed the code so it did something else than I wanted
16:55:09 <chpatrick1> and appending is quadratic if you do it the wrong way
16:55:28 <Qndel> anyway
16:55:30 <Qndel> let me show you some code
16:55:50 <cheater> ttt_fff: you can have types like that without full blown dependent types, either by value promotion or by use of ZFC naturals
16:56:20 <Qndel> http://lpaste.net/140872
16:56:47 <Qndel> you think I could reuse the code for SpecialKeys somehow and make it shorter?
16:57:01 <Qndel> because I basically copy/pasted the same code 4 times and only changed +2 to -2 and stuff
16:57:17 <Axman6> you don't need tpo use fromIntegral on those 0's
16:57:37 <chpatrick1> don't pattern match on the key in SpecialKey
16:57:43 <chpatrick1> then do the common stuff
16:57:48 <chpatrick1> then do a case on the key
16:57:50 <delYsid> Is there a simpler way to write "a *> pure b" ?  I.e, something like Applicative f => f a -> b -> f b
16:58:06 <exio4> delYsid: $> 
16:58:10 <exio4> @type ($>) 
16:58:10 <arkeet> :t ($>)
16:58:11 <lambdabot>     Not in scope: ‘$>’
16:58:11 <lambdabot>     Perhaps you meant one of these:
16:58:11 <lambdabot>       data constructor ‘Seq.:>’ (imported from Data.Sequence),
16:58:11 <lambdabot>     Not in scope: ‘$>’
16:58:12 <lambdabot>     Perhaps you meant one of these:
16:58:13 <lambdabot>       data constructor ‘Seq.:>’ (imported from Data.Sequence),
16:58:15 <chpatrick1> that doesn't exist
16:58:33 <exio4> @let import Data.Functor
16:58:35 <lambdabot>  Defined.
16:58:37 <exio4> @type ($>)
16:58:38 <lambdabot> Functor f => f a -> b -> f b
16:58:41 <chpatrick1> beg my pardon :)
16:58:58 <chpatrick1> err I beg your pardon
16:58:58 <chpatrick1> wtf
16:59:06 <arkeet> :t flip (fmap . const)
16:59:06 <exio4> :P 
16:59:07 <lambdabot> Functor f => f a -> b -> f b
16:59:16 <chpatrick1> wat is englis
16:59:31 <delYsid> cool, thanks!
17:00:16 <chpatrick1> Qndel: also you don't need to parenthetize all those pattern matches
17:00:38 <Qndel> I copied the code from the internet ;p
17:01:31 <exio4> that may explain your problems
17:01:40 <hackrilege> > Just 3 $> 'a'
17:01:42 <lambdabot>  Just 'a'
17:02:08 <lethjakman> Qndel: So...I'm still new at this. But I think you could use where key_func_with_a_good_name = all the special key stuff. and curry in the +2 -2, no?
17:02:30 <Qndel> I have no idea
17:02:51 <Qndel> apes know haskell better than me xD
17:04:36 <lethjakman> Qndel:http://learnyouahaskell.com/syntax-in-functions
17:04:41 <lethjakman> look for bmiTell
17:05:47 <hackrilege> is there a class for: interact :: Functor f => (a -> b -> (a,b)) -> f a -> f b -> (f a,f b)
17:05:53 <hackrilege> ?
17:06:29 <arkeet> that's Applicative
17:06:33 <arkeet> :t liftA2 (,)
17:06:34 <lambdabot> Applicative f => f a -> f b -> f (a, b)
17:06:39 <arkeet> well
17:06:46 <arkeet> :t liftA2
17:06:48 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
17:06:50 <arkeet> wait never mind.
17:06:51 <chpatrick1> it's just functor right?
17:06:55 <arkeet> I have no idea what you want there.
17:06:56 <chpatrick1> wait no
17:07:03 <chpatrick1> it's applicative + fst, snd right?
17:07:22 <arkeet> :t const (,)
17:07:24 <lambdabot> b -> a -> b1 -> (a, b1)
17:07:34 <kadoban> It's liftA2, isn't it?
17:07:47 <kadoban> Or ... oh no.
17:08:07 <chpatrick1> :t \f fa fb -> let t = f <$> fa <*L fb in ( fst <$> t, snd <$> t )
17:08:08 <lambdabot> Not in scope: data constructor ‘L’
17:08:08 <arkeet> :t const (,) :: Functor f => (a -> b -> (a,b)) -> f a -> f b -> (f a,f b)
17:08:09 <lambdabot> Functor f => (a -> b -> (a, b)) -> f a -> f b -> (f a, f b)
17:08:22 <exio4> @type \f fa fb -> let tu = liftA2 f fa fb in (fmap fst tu, fmap snd tu)
17:08:24 <lambdabot> Applicative f => (a -> b -> (a1, b1)) -> f a -> f b -> (f a1, f b1)
17:08:26 <chpatrick1> :t \f fa fb -> let t = f <$> fa <* fb in ( fst <$> t, snd <$> t )
17:08:27 <lambdabot> Applicative f => (a -> (a1, b1)) -> f a -> f b -> (f a1, f b1)
17:08:31 <chpatrick1> right
17:08:45 <arkeet> let's stop guessing what hackrilege wants.
17:08:51 <arkeet> hackrilege: what do you want
17:08:52 <chpatrick1> yes it's a bit strange
17:09:07 <exio4> we're just giving him a function with that type signature! :p 
17:09:16 <hackrilege> e.g. interact (\a b -> (a+(length b) , take a b)) (Just 3) (Just "hello")
17:09:30 <tehgeekmeister> where's best to start learning about session types? I'm fumbling through papers right now, but if anyone has a recommendation that'd be great.
17:09:38 <arkeet> hackrilege: what does it *do*?
17:09:39 <chpatrick1> hackrilige: I think you want Applicative basically
17:09:49 <kadoban> hackrilege: 'interact' is already something else, by the way ... so give it a different name.
17:09:49 <hackrilege> = (Just 8,Just "hel")
17:09:56 <hackrilege> ok
17:10:12 <chpatrick1> > (\a b -> (a+(length b) , take a b)) <$> Just 3 <*> Just "hello"
17:10:14 <lambdabot>  Just (8,"hel")
17:10:50 <hackrilege> nope two functors please
17:10:50 <chpatrick1> I know that's not it but I don't know why you would want that
17:11:09 <chpatrick1> exio4 and me wrote it just above
17:11:12 <chpatrick1> but it's a bit strange
17:11:20 <hackrilege> the functors "interact"...
17:11:22 <arkeet> :t fmap fst &&& fmap snd
17:11:24 <lambdabot> Functor f => f (b, b1) -> (f b, f b1)
17:11:28 <Qndel> http://lpaste.net/140873
17:11:49 <Qndel> can't I make an enum and name it Up/Down etc?
17:11:53 <Qndel> are these names reserved?
17:11:59 <kadoban> So it's ... liftA2 and arkeet's thing, I guess?
17:12:44 <hackrilege> i know such a function can be implemented, but im asking if it resembles a common class, i thought there was something more going on than just Applicative...
17:12:49 <chpatrick1> Qndel: what's the error?
17:13:07 <hackrilege> and yes, you managed to implement it, thanks
17:13:54 <Qndel> Display.hs:59:3:     Ambiguous occurrence `Up'     It could refer to either `Display.Up', defined at Display.hs:56:19                           or `Graphics.UI.GLUT.Up',                              imported from `Graphics.UI.GLUT' at Display.hs:3:1- 23                              (and originally defined in `Graphics.UI.GLUT.Callba cks.Window')
17:14:19 <chpatrick1> ah there's another type that has an Up constructor
17:14:48 <hackrilege> perhaps its about things which can interact with one another but not with themselfs, i.e. needing two functors, maybe thats just applicative... im not sure
17:15:07 <chpatrick1> that sounds like applicative
17:15:32 <hackrilege> hmmm
17:15:44 <chpatrick1> interacting with each other but not themselves I mean
17:15:56 <hackrilege> ok thanks ill think a bit more about why i think it could be different, but probably its not
17:16:15 <exio4> I don't know what you mean with "interact" there
17:16:21 <hackrilege> it modifies two functors
17:16:30 <kadoban> Yeah I still don't really understand the point of it, but that's not new to me.
17:16:35 <hackrilege> i think thats it
17:19:14 <hackrilege> we needed to seperate the result from one functor of a pair, because at its heart liftA2 is (a -> b -> c) -> f a -> f b -> f c, wheras my thing is ((a,b)->(a,b)) -> (f a,f b) -> (f a,f b) with some curry
17:20:11 <hackrilege> and while i could use applicative to define liftA3, such an interaction would not be well defined on my system of pairwise interactions
17:21:10 <hackrilege> its not functors contents being loaded into the arguments of a multivariate function, its a strict subclass with only bivariate functions...
17:21:46 <hackrilege> as the interaction between three objects may be ill defined...
17:21:57 <hackrilege> think radial force between atoms
17:22:26 <hackrilege> its not a standard class is it?
17:22:32 <hackrilege> ok off i go.
17:22:34 <hackrilege> thanks\
17:22:57 <arkeet> you don't need a class for that...
17:24:05 <hackrilege> oh no, yes i do have a question, does it seem to be a well motivated class or is this restriction on applicative definatly seem pointless as you suggest, and if so why not clasify this subcategory?
17:24:25 <hackrilege> arkeet, why? because applicative exists?
17:25:04 <Qndel> I'm stuck again ;s
17:25:49 <Qndel> http://lpaste.net/140874
17:26:11 <Qndel>   Couldn't match expected type `(t, t1)'               with actual type `IO (GLfloat, GLfloat)'   Relevant bindings include     xx :: t (bound at Display.hs:59:8)     yy :: t1 (bound at Display.hs:59:11)   In the expression: get pos   In a pattern binding: (xx, yy) = get pos iled, modules loaded: Cube, Points, Ground.
17:26:15 <Qndel> the hell does it want now?
17:26:59 <geekosaur> it wants you to sit down and figure out how IO works :)
17:27:00 <slack1256> you're passing an IO (a,b) when it wants a (a,b)
17:27:09 <hackrilege> to me it seems somewhat distinct from applicative in that and modification of one functor by a function partially applied to the contents of another functor, should certainly modify both functors
17:27:45 <Qndel> can you tell me?
17:27:54 <hackrilege> if your in a do loop you can write (xx,yy) <- get pos iled
17:27:55 <Qndel> thats how my programming in haskell looks like
17:28:04 <Qndel> I look at stuff and don't get a thing
17:28:26 <slack1256> @type (>>=)
17:28:27 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:28:28 <delYsid> Hmm, so this is what I'Ve learnt today: http://blind.guru/Music.hs
17:28:34 <chpatrick1> tbh it's because you jumped in the deep end
17:28:35 <delYsid> Comments very welcome...
17:28:40 <pacak> Qndel: Monads are nice and fluffy things.
17:28:45 <Qndel> : D
17:28:59 <exio4> hug the monad
17:29:00 <slack1256> Qndel: replace in that type above `m` for IO
17:29:18 <Qndel> huh?
17:29:48 <slack1256> then you have the correct function, in some sense (>>=) will tear up the IO (a,b) and pass it to you the (a,b)
17:29:49 <hackrilege> > (return 1) >>= putStrLn
17:29:50 <lambdabot>      No instance for (Num String) arising from the literal ‘1’
17:29:50 <lambdabot>      In the first argument of ‘return’, namely ‘1’
17:29:50 <lambdabot>      In the first argument of ‘(>>=)’, namely ‘(return 1)’
17:29:59 <hackrilege> > (return 1) >>= putStrLn.show
17:30:01 <lambdabot>  <IO ()>
17:30:08 <hackrilege> omg
17:30:12 <slack1256> hahaha
17:30:22 <Qndel> (xx,yy) <- >>= get pos
17:30:24 <Qndel> doesn't work
17:30:28 <Qndel> and I want to sleep but I can't
17:30:29 <Qndel> xD
17:30:36 <pacak> Qndel: Monad tutorial?
17:30:38 <hackrilege> it wouldnt, your not using it the right way
17:30:48 <Qndel> can't you just tell me?
17:30:51 <Qndel> its just a dumb assignment
17:30:58 <hackrilege> >>= makes most sense outside of a do loop
17:30:59 <Qndel> : (
17:31:01 <Axman6> -_-
17:31:08 <pacak> Qndel: No, we can't.
17:31:19 <slack1256> Qndel: you already lost.
17:31:22 <slack1256> sorry to be blunt
17:31:37 <hackrilege> tell you what?
17:31:43 <hunteriam> Sorry this is vaguely off topic, but can anyone help me understand this notation for a Group? http://imgur.com/dColsYK
17:31:51 <hackrilege> if you could ask with that description we probably could...
17:32:02 <uwap> Qndel, it's not an assignment at all. read up about monads
17:32:22 <hunteriam> uwap i think he meant school assignment haha
17:32:45 <hackrilege> the things on the rhs of the bar are the conditions ellements of the group should satisfy
17:32:58 <slack1256> hunteriam: you mean the "powers"? S^2 = S * S
17:33:04 <slack1256> where * is the group operation
17:33:24 <slack1256> (also #haskell-blah)
17:33:27 <hunteriam> slack1256: im trying to figure out what the group operation is, and how i could possibly figure out what elements are int his group from the picture i sent you
17:33:27 <KaneTW> @where learnhaskell
17:33:28 <lambdabot> https://github.com/bitemyapp/learnhaskell
17:33:31 <KaneTW> Qndel: ^
17:33:49 <hackrilege> we have not been told which set S and T are drawn from
17:33:52 <Qndel> I don't want to learn haskell
17:33:59 <hackrilege> bye then!
17:34:07 <KaneTW> well, you want to do your assignment
17:34:13 <hunteriam> slack1256: i posted to blah, thanks for referring
17:34:16 <hackrilege> you do really though, i promise
17:35:04 <Qndel> I've been programming in many languages
17:35:11 <Qndel> but the errors that haskell displays are just bullshit
17:35:15 <KaneTW> haskell is not similar to imperative languages
17:35:17 <chpatrick1> that's fair
17:35:28 <slack1256> although that error above was pretty clear
17:35:29 <chpatrick1> but it's not a language you can use without deeply understanding though
17:35:39 <slack1256> other are worse
17:35:47 <chpatrick1> and you went straight for something tricky
17:35:49 <hackrilege> suppose you define a function taking (xx,yy), such as f (xx,yy) = xx++yy, then you could write; getStuff >>= f
17:35:50 <exio4> Qndel: indeed, GHC errors aren't beginner-friendly, specially not friendly to people that don't know the language at all 
17:36:08 <exio4> hackrilege: you couldn't, unless you have some weird Num instance :)
17:36:31 <hackrilege> oh i didnnt realise they were Nums
17:37:27 <hackrilege> in the way i described you deligate the nasty Monad contents stuff as in writing your function f you get to use (xx,yy) the way you are used too
17:37:29 <uwap> hackrilege, also don't forget returning into the monad again
17:37:56 <hackrilege> yes, sorry, f (xx,yy) = return (xx+yy)
17:38:25 <exio4> I mean, \(x,y) -> x+y is uncurry (+) ; which has type Num a => (a,a) -> a, getStuff should have some type similar to Monad m => m (m a, m a) where there's a instance for Num (m a)
17:38:59 <antimeme> :t uncurry
17:38:59 <lambdabot> (a -> b -> c) -> (a, b) -> c
17:39:20 <KaneTW> Qndel: it's a different way of thinking and Haskell has a much stronger type system than most imperative languages, so GHC gives you unfamiliar errors
17:39:53 <hackrilege> yes, but these type definitions are more helpful to us than to a beginner, i guess thats the barrier we are at
17:39:57 <KaneTW> none of us are going to write your code for you, but we can assist you in learning the language
17:39:59 <Qndel> I have a variable ePos IORef [(GLfloat,GLfloat)]
17:40:16 <Qndel> and this             ePos $~! map nextEnemyMove
17:40:30 <hackrilege> hellish
17:40:30 <exio4> what's the type of ($~!)? :)
17:40:32 <Qndel> so the nextEnemyMove function takes the elements from ePos as arguments
17:40:46 <Qndel> how can I make the function take 1 more argument?
17:40:49 <hackrilege> what is the type of ePos?
17:40:51 <Qndel> where would I put it?
17:40:58 <Qndel> IORef [(GLfloat,GLfloat)]
17:41:05 <hackrilege> aha
17:41:47 <hackrilege> you should have written (Qndel) I have a variable ePos :: IORef [(GLfloat,GLfloat)]
17:42:17 <Qndel> so can I make that function take more arguments or not?
17:42:27 <hackrilege> which one?
17:42:38 <Qndel> ePos $~! map nextEnemyMove
17:42:48 <Qndel> when i added another argument     ePos $~! map nextEnemyMove myMap     ghc started to cry
17:42:59 <hackrilege> what is the infix opperators type?
17:43:12 <Qndel> what?
17:43:33 <exio4> Qndel: rephrased, what's the type of ($~!)
17:43:34 <hackrilege> the dollar tilde bang thing, sorry my keyboard lacks the tilde sign...
17:43:39 <Qndel> how can I know?
17:43:54 <exio4> :type <expr> in GHCi
17:43:59 <Qndel> I can't write in ghci
17:44:04 <hackrilege> hugs?
17:44:09 <Qndel> no, ghci
17:44:11 <uwap> Qndel, parenthesis are the solution!
17:44:51 <KaneTW> Qndel: why do you want a map there
17:44:52 <uwap> Qndel, think about how they are applied
17:45:15 <Qndel> I dont know anything
17:45:16 <uwap> is f x y the same to f (x y) or (f x) y? 
17:45:45 <uwap> s/to/as/
17:46:01 <hackrilege> can you try changing line 4 to read (xx,yy) <- get e.t.c
17:46:29 <Qndel> what for?
17:46:43 <hackrilege> uwap (f x) y
17:46:57 <Qndel> I already deleted that code
17:47:10 <Qndel> will just copy/paste, I don't need a function
17:47:22 <Qndel> ugly but should work
17:47:22 <hackrilege> thats confusing
17:47:30 <uwap> hackrilege, I should've pointed that this question was for Qndel, since obviously he has written his code as it was the other way around
17:47:31 <hackrilege> try not to confuse us
17:47:48 <hackrilege> uwap, ok
17:47:51 <Qndel> ePos $~! map nextEnemyMove
17:48:02 <Qndel> hpw to add additional argument to the nextEnemyMove function?
17:48:15 <hackrilege> with brackets?
17:48:24 <hackrilege> ...
17:48:25 <Qndel> I've already placed them everywhere, no success
17:48:35 <hackrilege> good approach!
17:48:35 <KaneTW> Qndel: what's the type of nextEnemyMove
17:48:45 <Qndel> nextEnemyMove:: (GLfloat,GLfloat) ->  [(GLfloat,GLfloat)] -> (GLfloat, GLfloat)
17:49:07 <hackrilege> then why use map?
17:49:11 <uwap> Qndel, there's your problem
17:49:19 <KaneTW> nah he wants map
17:49:19 <uwap> Qndel, what's the type of map? 
17:49:25 <KaneTW> ePos :: IORef [(GLFloat, GLFLoat)]
17:49:27 <Qndel> because I have to access every element from ePos?
17:49:38 <Qndel> and its some crazy IORef stuff
17:49:40 <hackrilege> :t mapM_
17:49:41 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
17:49:53 <hackrilege> sorry...
17:50:05 <KaneTW> Qndel: you want to make a lambda to make sure the first argument goes to the right place and pass the second argument that you want
17:50:25 <KaneTW> or you can use
17:50:27 <KaneTW> :t flip
17:50:28 <lambdabot> (a -> b -> c) -> b -> a -> c
17:50:38 <KaneTW> but i'd just use a lambda if you're starting out
17:50:42 <hackrilege> yes thats it!
17:51:12 <hackrilege> map (flip nextEnemyMove myMap)
17:51:46 <hackrilege> the problem is that map wants the function to take a single element as its last argument
17:52:20 <hackrilege> but since nextEnemyMove wants the single element as its first argument, you have to flip the arguments
17:53:01 <mniip> you could use section syntax perhaps?
17:53:20 <hackrilege> basically we are doing (map (\a -> nextEnemyMove a myMap))
17:53:36 <mniip> map (`nextEnemyMove` myMap)
17:53:54 <hackrilege> wheras what you are doing atm is (map (\a -> nextEnemyMove myMap a))
17:54:14 <hackrilege> does that make sense?
17:54:37 <hunteriam> Can anyone help me with some group theory math that im struggling with?
17:55:00 <hackrilege> sure
17:55:15 <johnw> hunteriam: that you're implementing in Haskell?
17:55:27 <hunteriam> nope its not related
17:55:32 <KaneTW> hunteriam: put it in -blah or #math then
17:55:33 <johnw> I'd recommend ##math then
17:55:41 <hunteriam> ok, thanks guys
17:55:46 <johnw> sure!
17:55:47 <hunteriam> ill stop asking those questions here
17:55:52 <hackrilege> i can still help, can you open up a message to me using /msg?
17:56:42 <hackrilege> i like group theory...
17:57:20 <hackrilege> Qndel how are you getting on?
17:57:35 <Qndel> did one if else
17:57:37 <Qndel> it worked
17:57:44 <Qndel> so I copy/pasted it 4 times and I get tons of errors
17:58:03 <hackrilege> can you put up a paste?
17:58:17 <Qndel> http://lpaste.net/140877
17:58:28 <antimeme> I have a question about laziness and monads. I have a state monad and a function that gets and modifies the state, but only sometimes. Pasting to lpaste right now.
17:58:32 <lpaste_> antimeme pasted “lazy monads” at http://lpaste.net/140878
17:59:15 <antimeme> thing is, with a non-monadic function I could put something like "id <- getID" into a where clause and it just would only get hit when needed. But not so with the do notation
17:59:43 <antimeme> I understand why it doesn't work right now. Right now it executes every time because the call is on the left of a (>>=), implicitly
17:59:56 <antimeme> but I'm looking for guidance on how to get the monadic equivalent of having that in the where clause
18:00:10 <pacak> antimeme: Move it under corresponding if branch?
18:00:37 <antimeme> pacak: I could do that, I know. And if that's the only option I guess I will. It feels a bit clunky, though.
18:02:04 <uwap> Qndel, sorry but you should really read about monads
18:02:32 <Qndel> what do monads have to do with this?
18:02:49 <pacak> antimeme: If you can decide if you want to do something to some i without using any monadic stuff - you can filter your list before
18:02:57 <uwap> Qndel, you are trying to use do-notation
18:03:02 <tomberek> does it make sense (or does it already exist) for there to be Generic/Data/Typeable instances for Exp or even TExp? (Template Haskell types)
18:04:19 <antimeme> pacak: I think the challenge is that there is something that needs to happen in both cases "rem <- doTheThing is" but another thing that only needs to happen sometimes "id <- getID" but which must happen first when it does happen
18:04:57 <antimeme> in an imperative language I would have the same if statement at the beginning and end of the function, but that feels so ugly
18:05:09 <antimeme> or the same code common to the blocks inside each if block
18:05:31 <antimeme> both feel ugly, and in a non-monadic situation laziness would manage it very nicely
18:06:05 <KaneTW> Qndel: please just go through https://github.com/bitemyapp/learnhaskell because you're trying to solve a puzzle via telephone
18:06:26 <KaneTW> you're writing if-statements like in a C-derived language
18:06:49 <antimeme> KaneTW: is that last comment to me or Qndel?
18:07:09 <KaneTW> antimeme: Qndel, see his paste
18:07:20 <antimeme> just checking because I'm having an if statement problem too :P
18:07:49 <Qndel> I don't care how it looks, I just want it to work so bad
18:08:00 <KaneTW> i'm not going about looks
18:08:06 <KaneTW> on*
18:08:12 <KaneTW> you just don't know the language
18:08:13 * hackagebot reducers 3.12.1 - Semigroups, specialized containers and a general map/reduce framework  https://hackage.haskell.org/package/reducers-3.12.1 (EdwardKmett)
18:08:19 <Qndel> I don't
18:08:28 <chpatrick1> it's not going to work though dude
18:08:38 <KaneTW> then don't expect us to code for you and learn it, or go and fail that assignment
18:08:39 <chpatrick1> you're trying to run before you can walk
18:08:50 <chpatrick1> and I appreciate you don't really want to do either but still
18:09:37 <chpatrick1> haskell isn't really a hack together from the internet kind of language
18:11:16 <Qndel> what would be the best thing to do key -> value things where key is a tuple of floats and I want to recover the stuff with lowest value quickly?
18:12:17 <derdon> KaneTW:  why does the guide recommend not to install platform? Isn't it simpler, esp. for Windows and Mac users?
18:13:19 <KaneTW> derdon: iirc it can get rather annoying to install cabal packages afterwards, not sure of the exact reason though
18:13:49 <KaneTW> i'd just use it on windows
18:14:18 <KaneTW> i found https://www.reddit.com/r/haskell/comments/23tj8y/haskellplatform_vs_ghccabal/
18:14:48 <derdon> Hm, ok. I'm going to be a tutor next semester and thought of recommending platform b/c it's easy for beginners
18:15:05 <KaneTW> yeah
18:15:08 <KaneTW> i'd just do that
18:15:18 <derdon> And the exercises won't need 3rd party packages btw
18:15:49 <KaneTW> on linux installing ghc from your package manager should be fine for a beginner-targeted course too
18:16:30 <derdon> Yes, of course
18:16:49 <slack1256> ghc as is comes bundled with a bunch of useful stuff already (base transformers)
18:17:05 <derdon> I guess I don't have to explain anything about installing to the Linux users ^^
18:17:15 <slack1256> plataform where things like Vector and wasn't well coordinated
18:17:42 <MarcelineVQ> derdon: have a look at Stack and see if it might be simple enough for your students
18:18:12 <MarcelineVQ> https://github.com/commercialhaskell/stack
18:21:43 <derdon> MarcelineVQ: looks like a bunch of (tested) 3rd party Haskell packages bundled into one project. Not what I'm looking for, but thanks
18:24:10 <Qndel> how to make few ifs execute one after another ?
18:24:21 <johnw> derdon: it doesn't actually install all of those packages at once; it installs them by request, like any package manager
18:25:11 <derdon> johnw: so it's like getting a repository of packages which you can update?
18:28:09 <johnw> yes
18:30:09 <mniip> how do I run an efficient BFS with path recovery
18:30:14 <mniip> if I have a Set (a, a)
18:30:28 <mniip> i.e a set of edges of a digraph
18:31:12 <johnw> mniip: use fgl?
18:31:37 <Qndel> idle :: IORef GLfloat -> IORef GLfloat -> IORef [(GLfloat,GLfloat)] -> IORef (GLfloat,GLfloat) -> IORef Int -> [(GLfloat,GLfloat)] -> IdleCallback idle angle delta ePos pPos lastTime myMap = do
18:31:44 <Qndel> do you see anything wrong here?
18:31:45 <mniip> o.o
18:31:51 <mniip> johnw, how
18:32:03 <Qndel> Display.hs:101:43: parse error on input `='
18:32:05 <Qndel> I'm so fkin lost
18:32:41 <johnw> mniip: fgl use a Graph abstraction that allows for multiple implementations
18:32:41 <uwap> Qndel, stop coding and go learn haskell
18:32:55 <Qndel> I don't think I've modified this part of code
18:32:56 <mniip> johnw, I'm not familiar with the module
18:32:59 <mniip> give a few hints?
18:32:59 <Qndel> and I don't see any errors
18:33:01 <johnw> mniip: I would imagine you could implement Graph for Set (a, a), and then use https://hackage.haskell.org/package/fgl-5.5.2.3/docs/Data-Graph-Inductive-Query-DFS.html
18:33:30 <dmj`> bitemyapp: ping
18:34:45 <johnw> mniip: fgl is a good module to know, I've used it to solve a lot of basic graph problems
18:48:20 <Qndel> http://lpaste.net/140881
18:48:23 <Qndel> why doesn't it work?
18:48:46 <dmwit> Why should it work?
18:49:33 <Qndel> no idea, but I don't see a reason for it not to work as well
18:49:45 <KaneTW> what does >>= do
18:50:08 <Qndel> bow ammo probably or something
18:50:17 <Qndel> haven't found IO a -> a function
18:50:52 <solatis> Qndel: unsafePerformIO ?
18:51:09 <antimeme> Qndel: having an idea of why something should work, but being wrong, is a great way to learn. Not having any idea why something should work, and expecting it to anyway, is stubborn and ignorant.
18:51:56 <antimeme> if you don't know how (>>=) works then you should go read about what it is, what it does, and how to use it. Otherwise you shouldn't use it and expect anything to work the way you expect.
18:52:56 <KaneTW> it's like you're in a well and instead of grabbing the rope we're lowering (learning the language) you just dig deeper
18:53:25 <Qndel> it's 4 am
18:53:44 <antimeme> I'll concede to one thing. Sometimes I feel like this community pushes learning harder than is necessary
18:53:47 <Qndel> I just want to use the things from IORef
18:53:51 <antimeme> and for some people that can be a deterent
18:54:19 <KaneTW> there's that and there's not even knowing the basics of the language
18:54:32 <antimeme> KaneTW: I agree with that
18:54:36 <KaneTW> quite literally copy-paste coding and if something doesn't work, trying to code c in haskell
18:54:43 <antimeme> haha
18:55:14 <Qndel> :D
18:55:30 <antimeme> *facepalm*
18:55:35 <exio4> Qndel: you do 4not want a function with that the type IO a -> a
18:55:37 <antimeme> just looked at the paste
18:55:49 <Qndel> too late
18:55:52 <Qndel> used unsafeIO
18:55:59 <Qndel> I like adventures
18:56:02 <solatis> you're lost
18:56:04 <Zekka> KaneTW: It reminds me! I was just writing this large, idiomatic haskell program that parses a limited subset of bash input!
18:56:15 <Zekka> How good it is to write idiomatic, straightforward haskell
18:56:20 <Zekka> http://lpaste.net/
18:56:21 <exio4> you should know that unsafePerformIO has unsafe in its name for a reason :) 
18:56:21 <solatis> Qndel: that means you simply are stubborn and refuse to understand the language
18:56:22 <Zekka> whoops
18:56:24 <adas> i have a very simple project with just 3 modules. Only one of the exported. Doing a `stack build` throws a `collect2: error: ld returned 1 exit status
18:56:25 <Zekka> http://lpaste.net/4974970217932259328
18:56:30 <adas> can someone tell me whats up?
18:56:38 <adas> it works fine in ghci
18:56:43 <antimeme> Qndel: adventures are good. But what you're doing is walking through the woods and asking for help. And when the person tells you to walk on this nice path next to the forest, you're saynig no.
18:56:45 <adas> just can't seem to compile
18:56:49 <solatis> if you use unsafePerformIO, why do you want to use haskell anyway?!
18:56:57 <solatis> that whole function defeats the purpose of haskell
18:56:59 <Zekka> I think using unsafePerformIO will be really interesting for him
18:57:00 <Zekka> he should do it
18:57:06 <KaneTW> i agree
18:57:10 <solatis> yeah, let him have it
18:57:25 <Gurkenglas> Qndel, try https://github.com/haskell/bytestring/blob/master/Data/ByteString/Internal.hs , line 616
18:57:29 <exio4> I'll give you that one
18:57:52 <adas> i do not understand why I get a link error
18:58:13 <exio4> Gurkenglas: hahahahaha
18:58:17 <KaneTW> accursedUnutterablePerformIO will never not be my favorite function name
18:58:32 <antimeme> Qndel: if I understand correctly, you're asking why you get the error you do? The error is in the context of a use of (>>=). You should learn what that function does and you'll understand your error.
18:58:53 <solatis> antimeme: why learn when you can be stubborn and use unsafePerformIO!
18:59:05 <antimeme> solatis: haha
18:59:14 <solatis> heck
18:59:19 <solatis> i think i should write my code in C
18:59:28 <solatis> and make one big haskell exposing function
18:59:34 <KaneTW> inline-c!!
18:59:36 <exio4> I am waiting for him to be surprised when a IORef magically changes values :p 
18:59:37 <solatis> yes!
18:59:39 <lpaste_> adas pasted “Link error” at http://lpaste.net/140882
18:59:44 <Qndel> unsafeDupablePerformIO
18:59:45 <Zekka> I've been considering writing a jokey guide to writing all your code with unsafeperformio
18:59:47 <Qndel> sounds better
18:59:47 <Qndel> :D
18:59:49 <solatis> and then i can put "Haskell master [*]" on my resume
18:59:52 <Zekka> mostly as a way of introducing people to strictness
18:59:53 <adas> can someone pleas tell me why i get that link error?
18:59:59 <mniip> johnw,     let gr = mkGraph (map (\n -> (tomap M.! n, n)) all) (map (\(f, t) -> (tomap M.! f, tomap M.! t, ())) $ S.toList rels)
19:00:02 <mniip> I like where this is going
19:00:03 <Zekka> but I never got around to it. Someone else should steal that idea
19:00:50 <solatis> adas: upgraded ghc by any chance?
19:00:55 <solatis> using sandboxes?
19:01:10 <solatis> make sure to run "cabal clean" in all sandboxed projects
19:02:40 <johnw> mniip: I was thinking you could make Set (a, a) be directly a graph representation, since it implies one
19:03:13 <antimeme> Qndel: what's your actual question? I'm late to the conversation. Your last paste with the error at "xx" and "yy". Is that what you're trying to figure out?
19:03:13 <mniip> it doesn't allow for labelled edges
19:03:41 <Qndel> to be honest I don't know anymore
19:03:42 <exio4> antimeme: he's trying to write a game using opengl, for some kind of homework
19:04:00 <adas> solatis: im using stack
19:04:00 <Zekka> exio4: That's his problem? I figured it would be something trivial
19:04:04 <Zekka> That sounds pretty intense
19:04:06 <johnw> mniip: right...
19:04:21 <exio4> learning Haskell and OpenGL at the same is pretty hardcore :p
19:04:22 <Qndel> let moves :: [(Float, (GLfloat,GLfloat))]; moves =[];  
19:04:27 <Qndel> I have this list
19:04:34 <mniip> Graph is of kind (* -> * -> *) -> Constraint
19:04:41 <mniip> you don't get to dictate what edge types are
19:04:44 <solatis> adas: i know, stack hides a lot of stuff from you... but is sandboxing everything
19:04:45 <Qndel> and I made a function checkMove::IORef (GLfloat,GLfloat) -> Directions -> [(GLfloat,GLfloat)] -> Bool
19:05:09 <Qndel> and to make things even more fun, I have an enum! 
19:05:10 <Qndel> data Directions = DUp | DDown | DLeft | DRight deriving (Enum)
19:05:30 <Gurkenglas> Zekka, why not "advance = atomicModifyIORef . splitAt"?
19:05:32 <Zekka> Nothing you've said sounds too wrong to me yet
19:05:51 <Zekka> Gurkenglas: Oh, in my program? Yeah, that would probably work
19:05:59 <Qndel> what would be a nice way to run the checkMove function with all possible enum values and adding the position to the list if the function returns false?
19:06:11 <exio4> Zekka: didn't IORef a -> b where b is not of the form IO c sound a bit wrong to you? :p 
19:06:31 <Zekka> exio4: Oh wait
19:06:34 <Zekka> I didn't see the IORef there
19:06:38 <Zekka> Oh wow that's really interesting
19:06:44 <solatis> Qndel: I really suggest you first learn the basics before you get your head so deep in Haskell game programming
19:06:52 <Zekka> Qndel: Sounds like you have a lot of steps there you can factor out
19:06:52 <Gurkenglas> You'd think there'd be some interface between IORef and MonadState
19:07:09 <antimeme> Qndel: ah, I understand now. This is actually a situation where I feel people push learning more aggressively than necessary.
19:07:19 <Qndel> yup
19:07:23 <antimeme> you SHOULD go learn Haskell better. I agree with people on that
19:07:34 <antimeme> there are a lot of basics here that would answer your question
19:07:38 <Zekka> Qndel: Things to think about right now: how do you get all the possible enum values?
19:07:51 <Zekka> If you have all the xs, how do you do a thing for each x over all the xs
19:07:51 <Zekka> ?
19:07:53 <Qndel> no idea
19:08:07 <Qndel> map?
19:08:17 <solatis> map maps lists to lists
19:08:19 <solatis> your enum is an enum
19:08:28 <solatis> how do you convert you enum to a list ?
19:08:28 <Zekka> Map could be one part of the solution though
19:08:32 <Qndel> no idea then
19:08:35 <Qndel> probably unsafeIO
19:08:38 <solatis> haha
19:08:40 <Qndel> :D
19:08:51 <antimeme> you have 3 things you need to do. 1) somehow get all of the enums. 2) apply the checkMove function to all of those. 3) only keep the false ones.
19:09:16 <solatis> Qndel: http://hackage.haskell.org/package/base-4.8.1.0/docs/Prelude.html#t:Enum
19:09:32 <Qndel> 1. It's 4 am
19:09:35 <Qndel> 2. I'm ill
19:09:36 <antimeme> those are all pretty basic things in Haskell. You don't need to learn much. But keep those 3 things in mind. Also read solatis' link about Enum
19:09:40 <Qndel> 3. You want me to learn haskell XD
19:09:49 <solatis> no, you want us to teach us haskell
19:09:49 <antimeme> Qndel: no, 3. You want to learn Haskell
19:09:55 <antimeme> you came here to learn
19:10:04 <solatis> i feel like he came here to have us fix his problems..
19:10:19 <antimeme> well, it does seem that way, yeah
19:10:20 <Qndel> ^ yup :D
19:10:25 <antimeme> but that's not what this community is about
19:10:35 <dmwit> Bad planning on your part does not constitute an emergency on our part.
19:10:37 <johnw> mniip: could you perhaps just pair your Set (a,a) with a Map (a,a) b?  That is, provide the labels from a secondary map?  Then you could just have the map start empty
19:10:41 <solatis> we don't give people free fish, we teach them how to catch fish
19:10:52 <solatis> if you are unwilling to learn how to catch fish, you ain't getting any
19:10:56 <Gurkenglas> I like people coming here to have their programs fixed. I like refactoring almost-sane code, and come here with my problems too.
19:10:57 <Qndel> haha
19:10:59 <antimeme> Qndel: you don't need to know everything about Haskell in order to do what you're trying to do. But you need to learn some basics. We can help point you at what you need to learn, but you still need to actually learn it
19:11:04 <Qndel> funny that you've mentioned fish
19:11:15 <antimeme> enums are a good thing to learn before you use them. Just read the doc solatis linked.
19:11:22 <Qndel> Ive watched a short movie about jesus fighting zombies and he was using fish as weapon
19:11:36 <solatis> i think enums are a perfect way to learn about haskell typeclasses, too
19:11:54 <johnw> solatis: let's start teaching them how to build fish from DNA combinators
19:12:07 <Qndel> so tell me
19:12:10 <solatis> DNA combinators! why didn't i think of that!
19:12:14 <Qndel> because now I'm so fking lost that I don't know anything
19:12:16 <KaneTW> G <> A <> T <> T <> A <> C <>A
19:12:19 <Qndel> you say that unsafeIO is bad
19:12:29 <solatis> Qndel: go to bed, sleep, and wake up in the morning, and spend one hour learning basics
19:12:31 <Qndel> but I've read that if I used IO once, then I have to keep using it
19:12:43 <Zekka> Yeah, you can't stop, it's like heroin
19:12:47 <solatis> Qndel: well, what does your main function look like ?
19:12:47 <Qndel> so its my function
19:12:49 <Qndel> checkMove::IORef (GLfloat,GLfloat) -> Directions -> [(GLfloat,GLfloat)] -> Bool
19:12:55 <solatis> is it, perhaps, main :: IO () ?
19:12:56 <antimeme> Qndel: that is an oversimplification of the truth. You only need to use IO where you need to use it.
19:13:00 <Qndel> so if I don't use unsafeIO, it will have to return IO Bool ?
19:13:13 <Gurkenglas> Qndel, when you want to use data from inside IO for things that don't take IO stuff, you use "fmap" on that stuff to make it take IO (and produce IO)
19:13:14 <solatis> Qndel: your whole application is wrapped inside one big IO
19:13:14 <Qndel> my main?
19:13:24 <solatis> so technically, you never need to "get rid" of IO
19:13:32 <dmj`> Qndel: if you want to read the IORef yes, you'll have to do it in I/O
19:13:32 <Qndel> main :: IO () main = do
19:13:35 <solatis> it just bubbles up until it reaches main
19:13:44 <solatis> and you can return it there
19:15:15 <Gurkenglas> (You can also call that fmap "liftM". They are the same thing, except that liftM only typechecks when used on monads rather than the more general functors, which works like a type signature telling the reader "I'm being used on a monad!")
19:16:48 <gganley> While the Raspberry Pi image downloads at 100k (this speed is unacceptible) what developements have happend since the release of 7.10. thats the last release before I started focusing on other things and lost focus on haskell
19:17:14 <bitemyapp> dmj`: yeeeesss?
19:18:17 <Zekka> Maybe it'll help if I use the phrase "RealWorld#" in the presence of bitemyapp
19:36:37 <Shockk> hello, I've got a question / I'm trying to understand how to do something, related to lenses
19:36:40 <Shockk> http://lpaste.net/5623608733163585536
19:37:37 <kristof> Are there any free theorems you get from monoids being associative?
19:37:54 <Shockk> I'm wanting to write a lens that works something like that, where it returns some property of my type that isn't actually a record of the type or whatever,
19:38:14 <Shockk> but specifically, the (\newMagnitude -> ?) part is what I'm curious about,
19:39:07 <kristof> Parallel aggregation is useful but I mean theoretical results useful in design
19:39:17 <Shockk> I could do any number of things there, but I don't know what to do if I want to make it a lens that can only be 'gotten'
19:40:34 <awpr> Shockk: a lens that can't be used to change the larger structure is a 'Getter'.  But, I think you could also legitimately allow it to re-scale the Point to have the new magnitude.
19:41:30 <Shockk> awpr: I could, I'm going to do basically just p * new / old, more or less
19:41:49 <Shockk> how would a Getter be implemented if I was doing that though?
19:42:41 <awpr> changing it to a Getter would get you some extra typeclass on 'f' that would let you give an 'f Point' without actually constructing a modified one
19:42:50 <Qndel> http://lpaste.net/140886
19:42:54 <Qndel> why doesn't it work? ;/
19:43:11 <Qndel> god, I can't wait for the moment when I'll finally be able to forget about haskell never to see it again
19:43:30 <scshunt> Qndel: :(
19:43:36 <Axman6> so you're not interested in software then?
19:43:37 <hackrilege> Irstly please do not use unsafeperformIO
19:43:50 <Axman6> jesus, unsafePerformIO? don't do that >_<
19:44:01 <hackrilege> Why do you say these mean things about haskell?
19:44:02 <Qndel> whats wrong with moves
19:44:09 <Qndel> why is it treating it as function?
19:44:09 <nolrai66> lots of things.
19:44:11 <Qndel> its a goddamn list
19:44:19 <Shockk> awpr: so if I changed Lens' s a to Getter s a, would I just do magnitude f point = f (etc..)?
19:44:27 <hackrilege> It's not haskells fault you are teaching youself in a rush...
19:44:29 <scshunt> Qndel: because your syntax makes it look like one
19:44:55 <scshunt> Qndel: you've indented line 7, so haskell treats it as the same line as 6
19:44:55 <nolrai66> Yeah, you are applying to two things.
19:45:03 <scshunt> so it looks like "moves return moves" to the compiler
19:45:13 <scshunt> Qndel: also, the return moves at the end is redundante
19:45:15 <scshunt> *redundant
19:45:24 <nolrai66> And bad.
19:45:27 <scshunt> ^
19:45:34 <hackrilege> Its an indentation error?
19:45:35 <scshunt> actually
19:45:36 <Qndel> goddamn tabs
19:45:45 <scshunt> Qndel: Actually, I don't think you want do-syntax there at all
19:45:48 <Qndel> coming instead of spaces and wasting my time ;s
19:46:12 <scshunt> Qndel: are you trying to use the list monad?
19:46:15 <nolrai66> What editor are you using?
19:46:31 <nolrai66> And yeah, you don't need do syntax I don't think.
19:46:53 <nolrai66> Oh.
19:46:56 <scshunt> Qndel: is this for an assignment?
19:47:05 <scshunt> and have you programmed in scheme before?
19:47:07 <hackrilege> Please replace line 4 with; (xx,yy) <- get pos
19:47:21 <nolrai66> Woah, I see. Yeah that isn't going to work.
19:47:33 <scshunt> hackrilege: a) don't give away answers b) the type of the function is wrong
19:47:48 <nolrai66> Haskel variables are immutable by default.
19:48:01 <Qndel> (xx,yy) <- get pos - tried, didn't work
19:48:09 <hackrilege> Sorry my bad
19:48:27 <nolrai66> Qndel: Do youu know what an IORef is?
19:48:33 <Qndel> nah
19:48:42 <Axman6> then wnhy are you using it?
19:48:43 <scshunt> Qndel: I repeat, is this for an assignment?
19:48:47 <scshunt> also what Axman6 said
19:48:47 <Axman6> so: yes
19:48:50 <Qndel> yes it is
19:48:50 <johnw> Qndel: we are not here to complete homework assignments for others
19:48:51 <Axman6> uh, scshunt*
19:49:01 <johnw> if you are not interested in Haskell, I ask you to take your frustrations elsewhere
19:49:10 <hackrilege> Its ok he found out about the importance of indentation?
19:49:15 <nolrai66> Eh. 
19:49:15 <Qndel> because it was in the code I got from the internet
19:49:16 <scshunt> I'm okay helping teach the language. I won't solve the assignment though!
19:49:25 <scshunt> Qndel: ... why did you get code from the internet to do an assignment?
19:49:27 <hackrilege> Which could have been a nasty bug if you didnt understand it
19:49:29 <Qndel> why not?
19:49:32 <Axman6> so you're plagiarising on an assignment?
19:49:33 <Gurkenglas> I would be okay with solving the assignment, but people don't seem to want it!
19:49:38 <nolrai66> Yeah Johnw, that seems over harsh.
19:49:42 <Qndel> XD
19:49:51 <glguy> No, johnw's right, this has been going on for a while
19:49:53 <Axman6> Qndel: there is a very good chance people in here know your professor
19:49:59 <scshunt> Qndel: I am interested in teaching the language, but not in helping you plagiarize
19:50:05 <nolrai66> Ah. Sorry.
19:50:08 <johnw> nolrai66: I grant that it may be, but sometimes a line must be drawn
19:50:12 <hackrilege> We want to make less it less frustraiting right?
19:50:20 <dmwit> nolrai66: Qndel has been here for at least 8 hours, mostly complaining about how he doesn't want to learn the basics.
19:50:29 <Zekka> 8 hours? I've only been following for like three
19:50:31 <Axman6> and will happily tell them that you've been plagiarising code
19:50:34 <Zekka> probably closer to two
19:50:36 <Zekka> That's impressive!
19:50:40 <nolrai66> Well then he should quit the class.
19:50:41 <Qndel> cool ;) go on
19:50:53 <hackrilege> But also powering on through like a true hero, probably far beyond the end of his teather but still persevering
19:51:44 <Axman6> Qndel: is this a university assignment? because if so, and you are caught, plagiarism is one of the most serious forms of misconduct at university - it can ruin your career, it is something that stays on your record from your university forever
19:52:03 <nolrai66> Okay, short awnser here, don't use IORref and dont use do notation here.
19:52:14 <Axman6> and learn some haskell :\
19:52:20 <johnw> nolrai66: I do appreciate your coming to the defense of others; if Qndel wants to learn Haskell, that's why we're here.  But if we are only serving to circumvent the learning process, I feel it's an abuse of the channel's time.
19:52:22 <hackrilege> It's really hard to learn when you are tired though, and it's kind of not our fault you dont have time to actually understand the lessons at the heart of your learning process...
19:52:34 <Gurkenglas> He said it's 4 am a while back so he's probably not in America. In Germany, it doesn't seem like _that_ big of a deal for homework assignments.
19:52:58 <KaneTW> Gurkenglas: homework, no
19:53:01 <nolrai66> He should just go to sleep then.
19:53:04 <exio4> I checked, apparently it has been going on for about a bit (19:20UTC yesterday, 02:50UTC today, now) :p 
19:53:16 <KaneTW> but it is a big deal for exams or projects
19:53:26 <Qndel> I couldn't care less
19:53:37 <derdon> Gurkenglas: it's also a very big deal in Germany!
19:53:42 <nolrai66> About what?
19:53:45 <exio4> Qndel: imagine if you had spent those eight hours learning Haskell!
19:53:49 <scshunt> ^
19:53:53 <derdon> At least on a university
19:53:57 <KaneTW> imagine if you had spent those eight hours sleeping
19:54:32 <scshunt> Qndel: So why are you taking this course if you hate it so much?
19:54:34 <hackrilege> Anyway regardless of german examination techniques, if he comes back with another bug, we will kill it, give our lessons and have them be ignored all the same. But I guess the point is we are doing ourselfs no favours by encouraging this
19:54:39 <KaneTW> derdon: i was tutoring at a german universirt this semester and no one here particularly cared about people who plagigarize homework. projects or exams or whatever are a huge deal though
19:54:49 <Gurkenglas> derdon, I'm on a university, and iirc at the course where they adressed the issue the penalty was... loss of homework points.
19:54:58 <KaneTW> ya
19:55:04 <dolio> No. This channel isn't for examining why someone is taking a course he or she dislikes.
19:55:06 <Qndel> 1. didn't know it'd be such a crap
19:55:13 <derdon> ok, then it's different at my uni.
19:55:16 <Qndel> 2. I've already taken it so I have to finish it, I have no choice
19:55:21 <Zekka> What's your course description?
19:55:22 <scshunt> fine, I'll move it to PM
19:55:26 <Zekka> It seems weird to be having to write games in Haskell
19:55:35 <Qndel> who reads descriptions?
19:55:36 <hackrilege> I'll join, invite me I dont know how
19:55:39 <Qndel> they never speak the truth
19:55:54 <Zekka> I figured you'd know you were getting into a new language, etc.
19:56:12 <exio4> Qndel: which project do you need to do? does it need to be a game?
19:56:13 <KaneTW> derdon: what university are you at
19:56:26 <nolrai66> Qndel you are taking up space that is for people to learn haskell. 
19:56:34 <derdon> University of Bremen, KaneTW
19:56:42 <hackrilege> Ok, yeh you should move off the channel with that discussion... Im happy to bugcheck for you in a pm, to save others having to read that kind of commentary, please respect our irc
19:57:00 <KaneTW> ah
19:57:24 <Shockk> Zekka | It seems weird to be having to write games in Haskell
19:57:27 <KaneTW> i'm at RWTH Aachen myself; makes sense it's different here, way more people probably
19:57:29 <Shockk> I'm writing a game engine!
19:57:37 <hackrilege> Nice
19:57:37 <Shockk> and it's in my leisure time :D
19:57:42 <Zekka> Shockk: To be *having* to be
19:58:07 <Shockk> I misread that at first
19:58:11 <hackrilege> Id love someone to help me rehack an arm ghc cross compiler from what was left to us by neurocyte if anyone is interested...
19:58:23 <Zekka> If I were a professor and I were starting a gamedev course I probably wouldn't require guys to use Haskell for it, because most of them won't know it and there's not much Haskell does that's relevant to games in particular afaik
19:58:23 <Shockk> it does seem weird to be assigned to write a game in haskell
19:58:30 <derdon> KaneTW: cool, I heard it has one of the best reputations of German unis.
19:58:50 <hackrilege> Not if the aim was to learn haskell
19:59:05 <Shockk> haven't touched anywhere near functional programming on my games course
19:59:14 <KaneTW> that's what i heard too; theoretical cs is really weak here though
19:59:34 <Shockk> is an area that I'm pretty interested in exploring though
19:59:59 <derdon> We wrote our own core Haskell parser and interpreter when I had fp classes
20:00:13 <Shockk> in Haskell?
20:00:19 <derdon> Yep
20:00:21 <Shockk> nice
20:00:37 <apo_> KaneTW: nice
20:00:40 <hackrilege> Wow cool, where was that?
20:00:51 <hackrilege> Derdon^
20:00:56 <apo_> KaneTW: My uni's pretty weak with everything compsci :|
20:00:57 <Shockk> I wrote something far less impressive but kind of similar, recently
20:00:59 <Alpha64> derdon that sounds tough
20:01:10 <derdon> University of Bremen, Bremen. hackrilege
20:01:14 <apo_> at least as far as I'm concerned
20:01:37 <Shockk> I could have used something like parsec, but takes the fun out of learning how to do it
20:01:49 <johnw> Shockk: there's some interesting stuff being done wrt games using functional reactive programming; Cale has done some of that
20:02:00 <derdon> Alpha64: it was, but also fun. Unifying and other type related stuff was hard though
20:02:01 <hackrilege> > hylo length (repeat 5) []
20:02:02 <lambdabot>  Not in scope: ‘hylo’
20:02:13 <KaneTW> yeah i'm probably going abroad for postgrad studies
20:02:17 <Shockk> I've seen a couple of things about functional reactive programming
20:02:22 <KaneTW> that does sound like a pretty good project though
20:02:37 <Shockk> I saw elm-lang a while ago
20:03:22 <hackrilege> I feel totally overwhelmed in the haskell environment by those specialising in compsci, I did math, and thats why I love haskell, but all the stuff im coming up against like cross compiling for android puts me way out of my depth
20:03:36 <Shockk> I guess I'll link this because it seems more people here are interested in games stuff that I imagined there to be https://hackage.haskell.org/package/polar-shader
20:03:48 <Shockk> although I guess there *are* 1400 people here 
20:04:02 <hackrilege> Hardly, there are like 20 tops
20:04:21 <johnw> hackrilege: have you seen http://kovach.me/posts/2014-04-30-hylomorphisms-and-treesort.html?
20:04:45 <hackrilege> Thanks johnw those papers you posted the other day were great too
20:05:04 <johnw> the abundance of material of this quality is one of the things that makes Haskell a joy to learn
20:05:09 <Shockk> parses something like "vertex { position = projection * vertex 0 1 }" and then can compile to output string using whatever instance of Compiler (example GLSL)
20:06:32 <simon> when generating syntax trees for my quickchecker, I'd like to generate meaningful identifiers. what's a good way to do this?
20:06:49 <hackrilege> Id like to see the next most simple recursive design pattern after hylo... Any ideas what such a thing could be?
20:07:41 <hackrilege> There was some bad thing I was trying to do with a hylomorphism that used a hylomorphic call at each recursive stage....
20:08:35 <simon> 'Gen' isn't a monad, so I'm not sure how I could generate trees that depend on state.
20:08:37 <hackrilege> But I guess some kind of "branching" rather than just a single recursive call at each stage would be a natural extension...
20:09:06 <Gurkenglas> hackrilege, isn't branching already possible by choosing the correct functor for hylo?
20:10:20 <simon> wait, Gen *is* a monad! so I could have StateT s (Gen AST) a
20:10:32 <Gurkenglas> @let hylo f g = h where h = f . fmap h . g -- so you can have your examples :D
20:10:34 <lambdabot>  Defined.
20:11:39 <Shockk> Gurkenglas: my brain is officially broken
20:12:03 <KaneTW> :t hylo
20:12:04 <lambdabot> Functor f => (f b -> b) -> (a -> f a) -> a -> b
20:12:06 <Gurkenglas> (It's pretty fun just showing people that type signature and having them try to implement it)
20:12:10 <hackrilege> :t fix
20:12:11 <lambdabot> (a -> a) -> a
20:12:22 <hackrilege> A more complex recursion scheme
20:12:28 <KaneTW> :t foldr
20:12:29 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
20:12:32 <KaneTW> :t unfoldr
20:12:33 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
20:13:07 <hackrilege> > hylo length (repeat 5) []
20:13:08 <lambdabot>      Couldn't match expected type ‘[t1] -> t0 [t1]’
20:13:08 <lambdabot>                  with actual type ‘[Integer]’
20:13:08 <lambdabot>      Possible cause: ‘repeat’ is applied to too many arguments
20:13:20 <Gurkenglas> repeat 5 isn't a function o.o
20:13:42 <hackrilege> > hylo length ((take 5).repeat) []
20:13:44 <lambdabot>  5
20:13:51 <KaneTW> > hylo length (replicate 5) "a"
20:13:52 <lambdabot>  5
20:14:19 <Gurkenglas> That's a boring use of it.
20:14:25 <hackrilege> Sorry...
20:15:10 <exio4> look at Either 
20:15:14 <hackrilege> It would be nice to see it half something until it was so small that it was a fixed point...
20:16:19 <Gurkenglas> > hylo (either id id) (\(x, y) -> if y == 0 then Left x else Right (x*x, y-1)) (3,3)
20:16:21 <lambdabot>  6561
20:16:27 <exio4> > hylo (either id id) (\x -> if x > 10 then Left x else Right (x*2)) 3
20:16:29 <lambdabot>  12
20:18:24 <Gurkenglas> > hylo ((+1) . sum) (\x -> [1..x-1]) 10
20:18:26 <lambdabot>  512
20:19:37 <Shockk> hmm, I'm having trouble with trying to write a Getter
20:19:57 <hackrilege> Great stuff
20:20:01 <glguy_> Usually you just use 'to' to make a getter
20:20:16 <Shockk> http://lpaste.net/7489486742957850624
20:20:40 <hackrilege> So we use if then else and either to break the recursion...
20:20:53 <hackrilege> Can we wrap this functionality for general use?
20:20:59 <breadmonster> Hey guys.
20:21:09 <hackrilege> Yo
20:21:10 <glguy_> Getters aren't generally useful to make on their own. Functions are better
20:21:18 <Shockk> hmm, I read up about 'to' and it looks like I'd just use 'to magnitude' right?
20:21:26 <breadmonster> glguy_: Lenses?
20:21:34 <glguy_> Later you can turn your function into a getter with to if needed
20:22:50 <Shockk> I'm mostly just trying to understand how to write one like you would write a Lens by doing fmap (\x' -> ...) (f x) or whatever
20:22:58 <Shockk> just because I'm curious 
20:23:16 <glguy_> Well, lens package but not lenses
20:23:30 <hackrilege> @let f b g y= hylo (either id id) (\x -> if b x then Left x else Right g x) y
20:23:31 <lambdabot>  .L.hs:151:57:
20:23:31 <lambdabot>      Couldn't match expected type ‘b -> Either b b’
20:23:31 <lambdabot>                  with actual type ‘Either a0 b1’
20:23:58 <Gurkenglas> :t (.) (either id absurd) . evalStateT . forever . modifyT -- hackrilege
20:23:59 <lambdabot> (a -> Either c a) -> a -> c
20:24:25 <awpr> Shockk: yeah, that's a fun thing to figure out.  the definition of Getter has both Contravariant and Functor constraints on the 'f' type parameter.
20:24:55 <hackrilege> I dont get that one Gurkenglas
20:25:01 <Shockk> hmm, ah and Lens only has Functor on it
20:25:23 <Zekka> Gurkenglas: What's thtat do?
20:25:26 <Gurkenglas> :t modifyT -- (I cheated and just defined that myself. It's the inverse of execStateT as modify is to execState)
20:25:27 <lambdabot> Monad m => (s -> m s) -> StateT s m ()
20:25:30 <Shockk> does that explain why I get "Couldn't match type `a' with `Point a'" when I try and build?
20:25:43 <hackrilege> I dont know anything about these exec state thingys
20:25:50 <Shockk> expected type f (Point a), actual type f a
20:25:59 <awpr> well, the key is that those two together let you cheat, via Void
20:26:36 <awpr> which I think is in the 'void' package.  fmap absurd . contramap absurd is 'f a -> f b'
20:27:11 <Gurkenglas> hackrilege/Zekka, the (a -> Either c a) goes (StateT a (Either c) ()), (StateT a (Either c) Void), (a -> Either c Void), (a -> c). The forever is the important step, which loops the StateTy part forever such that the a-buck disappears into infinity
20:27:14 <awpr> basically if something is both Functor and Contravariant, that proves it can't actually contain any values of its type parameter.
20:27:35 <Shockk> hm
20:27:57 <Gurkenglas> It's my favorite line of haskell code atm :D
20:28:34 <awpr> I think somewhere in one of Edward Kmett's packages there's an actual function with that type
20:30:16 <Shockk> :t contramap
20:30:18 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
20:30:25 <Shockk> this type is rather confusing at first glance
20:31:11 <awpr> Shockk: it's like a reversed 'map'.  a type that's Contravariant in its type parameter 'a' *consumes* 'a' values, rather than *producing* them
20:32:33 <c_wraith> Shockk: newtype Predicate a = Predicate (a -> Bool)
20:32:51 <c_wraith> Shockk: That's an example of a type that can be Contravariant
20:33:27 <Welkin> rmap and lmap
20:33:33 <edwardk> :t Data.Functor.Contravariant.phantom
20:33:34 <Welkin> I didn't understand those
20:33:35 <lambdabot> (Functor f, Contravariant f) => f a -> f b
20:33:47 <Shockk> hmm, going through this in my head from the top, to write something like magnitude :: Getter (Point a) a,
20:34:24 <Shockk> (Point a) needs to have both a Functor instance and a Contravariant instance for that, right?
20:34:33 <Welkin> how does contramap work?
20:34:52 <Welkin> you only have a function from a -> b
20:34:58 <Welkin> how do you transform f b to f a?
20:35:17 <exio4> c_wraith's example shows it pretty well
20:35:17 <Zekka> Usually because f eats bs, it doesn't contain or produce them
20:35:56 <exio4> "f a" doesn't mean it is some container of as :) 
20:36:31 <exio4> (for some definition of container...)
20:37:33 <edwardk> Welkin: consider newtype Predicate a = Predicate (a -> Bool)
20:37:59 <edwardk> Welkin: now, if you give me a function from Double -> Int,   and you have a Predicate Int, then you can now apply it to Double's
20:38:13 <Shockk> I mean, if (Point a) has a constructor Point a a a a, it does contain values of its type parameter, contrary to what you said earlier awpr, so can I not write a Contravariant instance then?
20:38:25 <edwardk> (Double -> Int) -> Predicate Int -> Predicate Double = (Double -> Int) -> (Int -> Bool) -> Double -> Bool  -- that is basically just flipped (.) plus newtypes
20:39:01 <edwardk> Shock: data Point a = Point a a a a is 'positive' in a, it can only be a Functor, not Contravariant
20:39:17 <edwardk> data Const x a = Const x  -- has no occurrences of 'a' it is both Functor _and_ Contravariant
20:39:34 <edwardk> newtype Endo a = Endo (a -> a)  has both positive and negative occurences of 'a' so it can be neither one
20:39:35 <awpr> the functor instance in question is not for 'Point' but for the type your 'Getter' will be instantiated on
20:40:08 <Shockk> hmm I see
20:40:11 <edwardk> newtype Predicate a = Predicate (a -> Bool) only has negative occurences of 'a' so it can be Contravariant
20:40:15 <Shockk> sort of
20:40:25 <edwardk> 'positive' vs 'negative' comes from how many times you go to the left of an (->)
20:40:42 <edwardk> (x -> a) is 'negative in x' and 'positive in a'
20:41:08 <edwardk> but if you go ((x -> a) -> b) you walk to the left twice, so x wraps around to become positive, a is negative, b remains positive
20:42:00 <edwardk> on the other  hand data Equivalence a = a -> a -> Bool  only walks to the 'left' once    (a -> (a -> Bool)  the first argument is on the left of its ->, whereas the second argument is on the right of the first -> and the left of the second. so both of those are negative
20:42:21 <edwardk> the sign flips when you walk into the arguments of a function
20:42:54 <Welkin> fa = (fb :: b -> c) . (ab :: a -> b) :: a -> c
20:42:55 <Welkin> wow
20:43:00 <Welkin> that makes sense
20:43:02 <Welkin> thanks edwardk 
20:43:16 <edwardk> no problem
20:43:25 <hunteriam> If anyone has the time, i need some help with a group theory question in #haskell-blah
20:43:26 <edwardk> it trips up some people who have been at this a long time. =)
20:43:42 <edwardk> one of my favorite languages was eiffel way back in the day and it always saddened me that the designer didn't understand variance properly =)
20:44:11 <exio4>  I woke up and edwardk was here, I am oging to sleep and he's here too, I don't understand
20:44:17 <exio4> edwardk: do you ever sleep?
20:44:21 <edwardk> hahahaha
20:44:54 <edwardk> i don't sleep much
20:52:02 <Shockk> I thought I was on to something just then with:
20:52:18 <Shockk> magnitude :: Getter (Const a (Point a)) a
20:52:29 <Shockk> but that didn't work unfortunately
20:55:01 <awpr> Shockk: it's still Getter (Point a) a, but the caller will always use something like Const
20:55:11 <Shockk> oh
20:56:03 <Shockk> awpr: but if I do that, I get a type error 
20:56:45 <Shockk> using this definition: magnitude' f (Point x y z w) = f (sqrt (x * x + y * y + z * z) * w)
21:00:58 <awpr> f gives you (something like) Const a a; you still need to make an (f (Point a)) based on that; that's where the 'phantom' trick comes in.
21:01:46 <edwardk> exio: this is his wife talking for him.  He's more away to go to 7-11 than he sleeps regularly.
21:05:43 <Shockk> interesting
21:05:58 <Shockk> awpr: so this compiled successfully
21:06:04 <Shockk> = phantom $ f (sqrt etc)
21:06:10 <Shockk> that's how it's done?
21:06:26 <awpr>  of course the only reasons to actually do it this way are: 1) provide a Getter without depending on Lens, or 2) to learn :D
21:06:45 <Shockk> is reason 2 for me :D
21:06:52 <Shockk> out of interest actually, as well
21:07:59 <Shockk> out of interest:, if I understand, doing that with lens would just be 'to magnitude' where magnitude :: Point a -> a, right?
21:08:24 <awpr> yep, and I bet if you look up the definition of 'to' it will probably be using 'phantom'
21:08:47 <Shockk> is there a similar function like that but for creating lenses?
21:09:10 <Shockk> something like:
21:09:13 <awpr> yep, I forget the name, but it takes a function going the other direction too
21:09:17 <Shockk> ahh
21:09:19 <awpr> maybe 'lens'
21:09:23 <Shockk> :t lens
21:09:24 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
21:09:36 <Shockk> very type variable
21:10:09 <Shockk> :t to
21:10:09 <lambdabot> (Profunctor p, Contravariant f) => (s -> a) -> Optic' p f s a
21:10:51 <Shockk> ahh I see, that might look like it, if I squint a little
21:12:08 <Shockk> that's it yes; lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b 
21:12:19 <Shockk> thanks awpr 
21:13:24 <shachaf> You shouldn't use the function "lens" to make lenses.
21:13:51 <Shockk> what should I use instead?
21:14:02 <shachaf> You should write them directly.
21:14:04 <awpr> ah right, performance issues.  the direct form is good instead
21:14:17 <Shockk> hmm I see
21:14:34 <shachaf> _2 f (x,y) = (x,) <$> f y
21:15:53 <simon> I want to generate a syntax tree for arithmetic expressions that have a negative sum.
21:16:36 <Shockk> hmm, where do those performance issues arise from? like, does 'lens' do it differently to writing it out directly and using fmap / <$> ?
21:17:13 <shachaf> If you write it directly, you can get sharing between the setter and the getter.
21:17:26 <Shockk> ohhh I see
21:17:38 <Shockk> because lens is written against Lens s t a b
21:17:48 <Shockk> where s might not be the same as t?
21:18:13 <Shockk> or am I way off on that?
21:18:17 <shachaf> That's not related.
21:18:23 <Shockk> hah, sorry
21:24:35 <edwardk> the performance issue with using the 'lens' combinator to make a lens is this. if you split open a big data type to 'get' the field you have all the pieces ready to reassemble the answer you'd get if you swapped out the part.
21:25:13 <edwardk> when you go to change a spark plug do you get it out, then go take apart the engine all over again to change it?
21:25:28 <Shockk> ahh right
21:25:32 <Shockk> that analogy makes sense
21:25:53 <edwardk> i'm rather bad with cars, i don't think you need to disassemble the engine to change a spark plug, but the idea is in that area =)
21:26:22 <Shockk> I don't know what spark plugs even do but it did make sense, thanks
21:26:40 <bitemyapp> edwardk: yeah spark plug changes are relatively easy. Good example would be head gasket.
21:26:40 <edwardk> anyways the way the more direct definition works you have already flayed open your data structure and have all the bits you aren't using ready to be put back in place around the new thing
21:26:46 <edwardk> bitemyapp: fair enough =)
21:26:50 <bitemyapp> head gaskets are universally gnarly as fuck
21:26:53 <bitemyapp> even my dad won't fuck with them
21:26:57 <shachaf> They plug the sparks. Otherwise you'll have sparks spilling everywhere.
21:27:29 <edwardk> i was going to use a heater core as an example but it felt less universally understandable to those who didn't grow up in michigan and have them blow all the damn time in american made automobiles =)
21:28:04 <bitemyapp> edwardk: I lost the heater core in my beater olds when I lived in Ohio. I went two winters without heat in Ohio and Michigan.
21:28:14 <athan> shachaf: I thought it was a plug /made/ with sparks, like a badass fuel injector that takes the polarized ions of the fuel to propel them
21:28:27 <bitemyapp> athan: I like your idea
21:28:34 <athan> (not really but it'd be the shnizz)
21:28:40 <bitemyapp> made a big watery mess when it went too.
21:28:43 <athan> bitemyapp: :)
21:28:45 <bitemyapp> in the winter no less. That sucked.
21:28:50 <bitemyapp> being poor sucked.
21:33:40 <dfeuer> edwardk, this silly thing won't get out of my head: http://stackoverflow.com/a/32488218/1477667   Why can I get away without OverlappingInstances by using an intermediate class? Why can't I seem to do so without one?
21:35:14 * dfeuer wonders if type families are designed to confuse the bleepity bleep out of everyone.
21:40:24 <breadmonster> Hello.
21:40:53 <dmj`> breadmonster: Hi
21:41:18 <breadmonster> How are you dmj`?
21:41:46 <tmillc> if you were to describe yourself as a type, how would you do so
21:42:03 <breadmonster> tmillc: IO a -> a
21:42:47 <tmillc> consider a company picnic, as a type
21:42:57 <dmj`> breadmonster: good you?
21:43:01 <pacak> #haskell-blah
21:43:09 <tmillc> sorry
21:44:30 <simon> in quickcheck, when generating sized syntax trees, won't 'boundedTree = sized tree where tree 0 = return Leaf; tree n | n>0 = Node <$> arbitrary <*> tree (n `div` 2) <*> tree (n `div` 2)' mean that it only generates somewhat balanced trees?
21:46:04 <pacak> simon: More or less. Except that I'd go with n not as number of nodes but as number of layers
21:46:19 <pacak> ... tree (n - 1) <*> (n - 1)
21:47:20 <pacak> And if you want unbalanced ones - you need to use random numbers
21:49:29 <montanonic> God, fibs = 0 : scanl (+) 1 fibs, really blows my mind.
21:49:42 <montanonic> Like, I understand the reasoning behind it; still blows my mind.
21:56:34 <edwardk> montanonic: https://www.reddit.com/r/math/comments/3ksk42/anyone_into_functional_programming_here/cv0udna
21:58:22 * hackagebot half 0.2.2 - Half-precision floating-point  https://hackage.haskell.org/package/half-0.2.2 (EdwardKmett)
21:59:01 <simon> pacak, and how does quickcheck determine what sizes my sized generators should go towards?
21:59:53 <montanonic> edwardk: that is really interesting! 
22:00:08 <edwardk> simon: you can pick a random number from the range of the size to pick the ratio between the two sides
22:00:11 <montanonic> I've never used classes that way before (at all), cool to see
22:00:56 <edwardk> montanonic: https://www.fpcomplete.com/user/edwardk/fibonacci/search gives the derivation of that 'Fib' type
22:01:06 <simon> edwardk, good idea!
22:01:21 <montanonic> edwardk: awesome, ty!
22:05:30 <crough> Anyone know anything about Hugs? Running on OS9 atm and honestly getting that compiled, I feel, is going to be much easier than GHC
22:09:29 <simon> is there anything wrong with 'instance Enum a => Arbitrary a where arbitrary = elements $ enumFrom $ toEnum 0'?
22:09:49 <shachaf> It overlaps with every other instance.
22:10:06 <simon> good point.
22:10:10 <shachaf> Not to mention that that won't enumerate every value of every Enum type.
22:19:04 <liste> simon how about newtype + Enum + Bounded ?
22:20:11 <liste> newtype ArbitraryEnumBounded a = ArbitraryEnumBounded a; instance (Enum a, Bounded a) => Arbitrary (ArbitraryEnumBounded a) where ...
22:21:55 <simon> liste, ah. nice.
22:22:29 <simon> liste, I've just settled with 'instance Arbitrary Colour where arbitrary = elements $ enumFrom $ toEnum 0' for now :P
22:25:10 <liste> though [minBound..maxBound] doesn't necessarily span all the values of a type, afaik :/
22:25:55 <liste> or is there a rule that says it does?
22:26:16 <liste> (modulo bottom, ofc)
22:28:39 <simon> I suppose there isn't such a rule. I guess a type can be enumerable and have multiple representations of the same value of which only some of them are spanned under Enum...
22:32:02 <hunteriam> I have a group theory question that id like to advertise for here
22:33:24 * hackagebot google-translate 0.1.0.0 - Google Translate API bindings  https://hackage.haskell.org/package/google-translate-0.1.0.0 (DavidJohnson)
22:53:25 * hackagebot bloodhound 0.8.0.0 - ElasticSearch client library for Haskell  https://hackage.haskell.org/package/bloodhound-0.8.0.0 (bitemyapp)
22:57:17 <nitrix> Hi, given an eval function `eval :: Instruction -> StateT Tape IO ()`, how do I run this state on [Instruction]?
22:57:34 <awpr> mapM_
22:57:41 <nitrix> I tried all sorts of mapM_ weird combinations and can't get it right. 
22:58:02 <Axman6> should just be mapM_ eval instrs
22:58:03 <liste> nitrix show us what you tried
22:58:39 <nitrix> Ah nevermind. The instrs were missing
22:58:51 <liste> good ol' rubber-duck method
22:59:07 <nitrix> I had (mapM_ eval) instead of (mapM_ eval instrs)
22:59:16 <nitrix> Man the error messages gets confusing as hell.
22:59:26 <nitrix> Axman6: Thanks man.
23:00:49 <Axman6> no worries. I had the same problem like an hour ago
23:39:34 <nitrix> gets :: MonadState s m => (s -> a) -> m a
23:39:56 <nitrix> Can this somehow accept a function of type (s -> m a) instead?
23:40:33 <arkeet> :t get
23:40:34 <lambdabot> MonadState s m => m s
23:40:41 <arkeet> :t (get >>=)
23:40:43 <lambdabot> MonadState a m => (a -> m b) -> m b
23:41:05 <nitrix> Oh, bind.
23:41:18 <nitrix> arkeet: Sorry, this is still new to me.
23:41:38 <arkeet> np
23:52:52 <liste> I asked this earlier but may've missed the answer but: what's the best way to handle secure strings (eg plaintext passwords) in Haskell? mutable arrays?
23:56:12 <lpaste_> aoeuaoeu pasted “No title” at http://lpaste.net/140896
23:57:11 <aoeuaoeu> Hi, I'm having a problem with the websockets library with the paste: http://lpaste.net/140896 - steps to reproduce in there. Basically when a connection is closed, there's a few seconds lag and CPU usage jumps
23:57:33 <aoeuaoeu> I'm relatively new to haskell - wondering if I've done something stupid here
