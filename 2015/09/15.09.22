00:18:27 <delYsid> @pl \l s -> map fst $ runStateT parser (l, s)
00:18:27 <lambdabot> ((map fst . runStateT parser) .) . (,)
00:18:44 <delYsid> Someone should teach @pl about (un)curry.
00:18:50 <mniip> it knows
00:19:00 <delYsid> but it doesnt use it in this case?
00:19:03 <mniip> yes
00:19:14 <mniip> @pl \x y -> f (x, y)
00:19:14 <lambdabot> (f .) . (,)
00:19:19 <mniip> hm maybe not
00:19:29 <delYsid> see, thats what I mean.
00:19:30 <mniip> I know for certain it knows about *un*curry
00:19:39 <mniip> @pl \(x,y) -> f x y
00:19:40 <lambdabot> uncurry f
00:19:54 <delYsid> ok, so someone should teach it about curry, then :-)
00:20:08 <quicksilver> uncurry is more obviously useful to help eta reduction
00:20:30 <quicksilver> bearing in mind the purpose of @pl is to float parameterss to the front and then eta reduce them away
00:21:23 <mniip> well actually
00:21:34 <mniip> pl just translates your lambdas into SK calculus
00:21:37 <mniip> and them optimizes some
00:21:53 <mniip> and by some I mean a lot
00:25:53 <quicksilver> are you sure mniip?
00:26:04 <quicksilver> I looked at the source code of pl once and it's just a series of adhoc rewrite rules
00:26:12 <mniip> that's what it did last time I've looked at it
00:38:53 <Nobos> Hello, I have a noob question regarding Persistent & Haskell Templates
00:39:24 <Nobos> I'm trying to generate a type deriving from Show, Eq  & Generic
00:39:59 <Nobos> However, my code fails saying (Show, Read, Eq) is an illegal type constructor or class name
00:40:12 <Nobos> gist here: https://gist.github.com/ToJans/20e362e1c852f7b082d1
00:40:25 <Nobos> I'm probably missing some kind of directive?
00:40:52 <Nobos> {-# LANGUAGE ... #-} 
00:40:59 <merijn> Nobos: That's a quasi quoter, so I don't expect it to know "deriving" syntax
00:41:24 <Nobos> is there anyway I could enforce this, or how would you do it?
00:41:28 <mada> I have a working one with the 'deriving' inside the quotes
00:41:37 <mada> although it only says deriving Show.
00:41:54 <Nobos> Do I need to manually implement Aeson ToJSON etc?
00:41:55 <quicksilver> as a work around just pull the deriving out
00:42:01 <quicksilver> and use standalone deriving
00:42:17 <quicksilver> I have no idea if that QQ is supposed to support deriving or not but standalone deriving is an easy workaround
00:42:38 <Nobos> in the docs you see the examples with a single "deriving"
00:42:48 <Nobos> but I'd love to have multiple
00:43:22 <Nobos> aha, I found it!
00:43:32 <Nobos> share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase| KeyValue     tenant TenantId     type String     key String     content String     deriving Show     deriving Eq     deriving Generic |]
00:43:40 <Nobos> oops, I'll update the gist
00:44:22 <Nobos> gist updated: https://gist.github.com/ToJans/20e362e1c852f7b082d1
00:44:32 <Nobos> apparently you need to split it over multiple lines
00:44:46 <Nobos> using a "deriving" statement/line
00:45:20 <quicksilver> good ot know
00:45:43 <Nobos> thanks guys! (& girls maybe ;) )
00:52:14 <cluzz> > transpose [[1,2],[3,4]]
00:52:16 <lambdabot>  [[1,3],[2,4]]
01:00:20 <jle`> i hope people know that they can use lambdabot in pm too ;_;
01:00:43 <slack1256> it's not that bad when nobody is speaking
01:01:12 <jle`> it's too bad, but i think it is still a nice thing to be aware of
01:01:21 <quicksilver> that wasn't at all bad
01:01:23 <jle`> what if people want to use it but are too afraid when the room is crowded? :o
01:01:36 <jle`> then they might never use lambdabot because they are too sellf conscious
01:01:36 <quicksilver> it's nice to have discussion in public
01:01:41 <quicksilver> but it's also nice to know it works in PM
01:01:51 <jle`> i think the world would be a better place if people were aware of both use cases
01:02:02 <jle`> it would enrich people's experiences i believe.
01:02:21 <Hafydd> Holy Shit. You can use lambdabot in the channel? I'd be only sending him PMs all this time.
01:02:22 <quicksilver> I agree.
01:03:00 <Nobos> > 1+2
01:03:02 <lambdabot>  3
01:03:43 <Nobos> > :t Maybe
01:03:45 <lambdabot>  <hint>:1:1: parse error on input ‘:’
01:03:48 <Nobos> lol
01:03:50 <Nobos> ;)
01:03:59 <slack1256> @type maybe
01:04:00 <lambdabot> b -> (a -> b) -> Maybe a -> b
01:04:14 <Nobos> hehe
01:04:18 <Nobos> thanks
01:04:23 <slack1256> np
01:39:40 * hackagebot irc-fun-client 0.2.0.0 - Another library for writing IRC clients.  https://hackage.haskell.org/package/irc-fun-client-0.2.0.0 (akrasner)
01:43:01 <Wizek> Hello
01:43:14 <Wizek> Anyone knows any apps/games written with gloss?
01:44:31 <Wizek> I am checking out the examples; I am impressed, and curious how many projects use gloss in production.
01:45:27 <montanonic> There's been a fair amount of comments I've seen from the IRCs about Arrows not being widely used. Is there truth to this? And if so, is there a reason? I'm just learning about Arrows now through the Typeclassopedia.
01:59:41 * hackagebot irc-fun-bot 0.3.0.0 - Library for writing fun IRC bots.  https://hackage.haskell.org/package/irc-fun-bot-0.3.0.0 (akrasner)
02:04:41 * hackagebot hpack 0.8.0 - An alternative format for Haskell packages  https://hackage.haskell.org/package/hpack-0.8.0 (qoelet)
02:24:42 * hackagebot dead-code-detection 0.2 - detect dead code in haskell projects  https://hackage.haskell.org/package/dead-code-detection-0.2 (SoenkeHahn)
02:25:17 <Gurkenglas> How come all these packages never have working links in the "Modules" section in the latest version?
02:26:04 <merijn> Gurkenglas: Because documentation is build as batch job
02:26:18 <merijn> Gurkenglas: So new versions take a few hours to receive docs unless the maintainer manually uploads them
02:26:57 <Gurkenglas> merijn, why is the documentation not built immediately by hackage?
02:28:00 <merijn> Gurkenglas: Because building documentation requires building the entire package which takes a ton of compute?
02:28:42 <Gurkenglas> merijn, why is it better to procrastinate that into a batch job?
02:29:42 * hackagebot funbot 0.2 - IRC bot for fun, learning, creativity and collaboration.  https://hackage.haskell.org/package/funbot-0.2 (akrasner)
02:29:56 <merijn> Gurkenglas: Because those are run on donated servers instead of on hackage
02:31:24 <Gurkenglas> merijn: Hmmmm. That sounds like a problem that could be solved by having the cloud compute it now, and having the donated servers compute stuff for the cloud later...
02:32:31 <merijn> Gurkenglas: Maintainers that care can just manually upload the docs
02:32:32 <slack1256> or actually fundraising money for server
02:34:16 <tdammers> Gurkenglas: procrastinating this stuff means it can happen asynchronously, which in turn means it can be rate-limited such that it will never slow down uploads and downloads too much
02:35:02 <tdammers> the batch job just churns through its job queue, building documentation for one package after the other, but this will never block the more critical processes
02:39:08 <merijn> Also means they the builders can scale with availability (i.e. if a company donates compute they can use more machines during slow times) although I forget whether a company was donating the builders
02:55:45 <dtscode> is LYAH still relevant for learning haskell?
02:56:10 <erikD> I think it is, at least it gives good explanations of all the basics
02:56:23 <dtscode> sweet thanks
03:00:35 <montanonic> dtscode: if you share your programming background and your current goals for Haskell we could offer you alternative resources
03:00:46 <ski> dtscode : some would suggest CIS194 and NICTA. <https://github.com/bitemyapp/learnhaskell>
03:00:55 <montanonic> ^indeed
03:02:20 <quicksilver> "DO NOT INSTALL HASKELL PLATFORM" :-( :P
03:02:59 <quicksilver> I disagree with this advice, incidentally
03:03:07 <dtscode> montanonic: mostly imperative (ie C/python), a bit of oop (c++/python), I've done *some* functional programming with racket (for like a month) and some fp with perl
03:03:07 <quicksilver> if the emoticons did not make it clear.
03:03:23 <dtscode> my goal is to learn how to solve problems from a functional programming perspective
03:03:31 <quicksilver> I think if you find the 'tone of voice' used in LYAH engaging (as opposed to, annoying) then it's a great intro.
03:03:38 <dtscode> ski: thanks
03:03:57 <ski> dtscode : SICP might be worth a look (including the videos)
03:04:05 <dtscode> whats sicp?
03:04:10 <ski> @where SICP
03:04:10 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
03:04:16 <ski> (first two links)
03:04:27 <ski> teaches CS, using Scheme
03:04:33 <dtscode> ah thanks
03:04:38 <ski> (Racket is a Scheme)
03:04:38 <montanonic> dtscode: racket! hell yeah! I got into Haskell from that.
03:04:46 <dtscode> :D <3 racket
03:05:03 <ski> dtscode : though the Racket people might suggest HtDP over SICP ..
03:05:15 <montanonic> dtscode: I'm 80% confident that if you stick with Haskell that you'll love it even more.
03:05:31 <dtscode> ski: is it the same concepts?
03:06:02 <ski> i've only skimmed HtDP, and some years ago
03:06:06 <dtscode> montanonic: oh I'm sure. all of my programmer buddies (like wei2912) are functional programmers and they seem to have all the fun
03:06:19 <dtscode> + can do the things I want to do fairly easily
03:06:27 <montanonic> dtscode: I haven't read it myself, but from what I've heard and skimmed, SCIP is computer science heavy in its ideas, and has a lot of implied math/science prerequisites
03:06:46 <dtscode> hmmm I'll stay away from that for now as math is not my strong subject
03:06:50 <montanonic> dtscode: HtDP tries to get rid of any prerequisites, and teach programming from the ground up
03:07:09 <dtscode> oh really? I'll check that one out then :D
03:07:14 <ski> Scheme is nice for learning about continuations (including delimited/composable ones), and macros (preferably hygienic ones !)
03:07:21 <montanonic> dtscode: how long have you programmed for?
03:07:29 <dtscode> ~5 years
03:07:46 <ski> (for the more unique pros of it, i.e.)
03:08:01 <montanonic> Nice! That's a solid ten times what I've got on me. HtDP will probably be very easy for you.
03:08:17 <dtscode> :D yay
03:08:19 <erikD> what’s the opinion around here on Write yourself a scheme? I liked it a lot for building an actual application that does something less trivial then computing fibonacci. https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
03:08:47 <frerich> erikD: It's the thing which I wanted to do 'next' for the last four years or so.
03:09:08 <montanonic> dtscode: and so to that extent, I'm not sure I'd recommend going through HtDP; you might genuinely be in the optimal position to try http://haskellbook.com/
03:09:28 <montanonic> dtscode: it is *not* free however, but from what I've heard it *is* excellent at teaching FP, specifically, in Haskell.
03:09:49 <montanonic> dtscode: there is a sample PDF with the first three chapters; HtDP is very long-winded if you are already conversant with programming
03:10:00 <dtscode> ]ooo once I get money for this I'll take that for a spin too
03:10:09 <shiona_> erikD: I think I followed the first few chapters, until the library APIs were different to the point I was unable to make them work any more
03:11:59 <montanonic> dtscode: while I don't own it myself and would not normally recommend something you have to pay for, if CIS194 and NICTA are too confusing for you (and trust me, it's not your fault if they are), you might want to seriously consider the book. Also, #haskell-beginners is a thing, and I'd strongly recommend asking for help when you get stuck there. You will for the most part always get a response.
03:12:25 <dtscode> just joined :D
03:13:27 <montanonic> dtscode: great! :) Have fun with Haskell! It will definitely expand your mind. Maybe I'll end up helping you with it some time on the beginners channel.
03:13:43 <lpsmith> https://github.com/lpsmith/syslog-simple
03:13:52 <frerich> Of course, this channel is perfectly friendly to Haskell beginners, too.
03:14:08 <montanonic> True.
03:14:28 * frerich understands that #haskell-beginners was created because #haskell was too noisy for longer discussions, but I think the separation is a bit sad.
03:14:47 <ski> dtscode : btw, just fyi, beginner questions are welcome in here as well
03:15:11 <dtscode> ski: I figured. I just like having multiple resources
03:15:24 <ski> fine
03:15:50 <quicksilver> the beginners channel is useful if some big conversation is going on here and you can't follow the other conversation at the same time
03:16:07 <quicksilver> it would be nice if IRC had a meta-protocol for splitting out discussion threads
03:16:15 <ski> there's also #haskell-overflow for such things
03:20:25 <dtscode> ok whats the best way to get haskell?
03:20:36 <slack1256> what is your OS?
03:20:36 * frerich puts on his asbestos underwear...
03:20:44 <dtscode> linux mint
03:20:56 <Gurkenglas> quicksilver, nothing speaks against everyone in a conversation saying everything in blue
03:21:02 <slack1256> your package manager ghc package
03:21:11 <tdammers> dtscode: easiest way - apt-get install haskell-platform
03:21:24 <slack1256> maybe cabal, haddock, alex & happy if they aren't included
03:21:32 <dtscode> thanks
03:21:50 <slack1256> *cabal-install, cabal the library is included with ghc I think
03:22:07 <tdammers> alternatively, installing the haskell-platform tarball for "generic linux" will also work, and it's not much harder
03:22:11 <knupfer> I've got some questions on type-level stuff
03:22:52 <knupfer> I've written some functions which can add natural numbers on the typelevel and convert them to integers.
03:22:54 <montanonic> Why not any recommendations for Stack, out of curiousity? 
03:23:19 <slack1256> dtscode: the thing with just installing the absolute essential is that you can do cabal sandboxes with less problems (but more compilation time) or just use stackage on top of it
03:23:35 <dtscode> oh ok
03:23:53 <lpaste_> knupfer pasted “type level stuff” at http://lpaste.net/141462
03:24:08 <slack1256> he said install haskell, he needs that first before getting stack (he will probably want it though)
03:24:39 <montanonic> ah, okay.
03:24:45 <knupfer> Can anyone explain me why (test3 test4) works fine, but (test1 test4) not?
03:25:38 <montanonic> dtscode: to be honest with you the installation *can* be one of the most frustrating parts of the Haskell experience; it should go okay for you, but if it doesn't, please come back here to ask for help. I'm projecting my own experience with this, but I was personally turned off from Haskell just because I couldn't figure out a good way of setting it up.
03:25:58 <montanonic> Milage may vary.
03:26:15 <dtscode> montanonic: yeah i remember having difficulty when trying to roll a geordi on fedora
03:27:17 <knupfer> Ideas?
03:28:03 <dtscode> what is referential transparency?
03:28:42 <montanonic> perhaps an oversimplified answer: an operation that *always* yields the same result
03:29:18 <dtscode> the same result always, or one that yields the same result for the same input?
03:29:25 <montanonic> the latter
03:29:30 <dtscode> ah ok
03:29:32 <knupfer> dtscode: the = is like in math, not like in C
03:29:34 <merijn> That's purity, not referential transparency
03:29:47 <montanonic> merijn: oh. apologies
03:29:51 <merijn> referential transparency is that "a name can always be replaced by it's definition"
03:29:55 <dtscode> knupfer: oh really? thats interesting
03:30:10 <merijn> Which requires purity, but you can be pure without referential transparency
03:30:18 <dtscode> merijn: oh ok that makes sense
03:30:36 <knupfer> dtscode: yes
03:30:44 <merijn> dtscode: Sure, it's a fairly obvious idea, it just doesn't hold in many programming languages :)
03:30:52 <montanonic> Ah, I see. Okay. That's why I got them mixed up.
03:31:09 <dtscode> merijn: yeah... in C/python I was taught to use functions/methods more often than not
03:31:10 <knupfer> for example x += 1 isn't valid
03:31:24 <knupfer> > let x = x + 1 in x
03:31:28 <lambdabot>  mueval-core: Time limit exceeded
03:31:29 <dtscode> wouldn't it have to be lex x = 1 in x + 1?
03:31:35 <dtscode> let even
03:31:55 <knupfer> dtscode: no, that would be valid
03:32:08 <ski> dtscode : a context is referentially transparent, if when you replace an expression in the context with another one having the same value, the overall result is the same
03:32:16 <dtscode> oh you were showing an invalid example
03:32:27 <dtscode> ski: ok that makes sense
03:32:31 <merijn> dtscode: So basically if I have "map f (x:xs) = f x : map xs" and "take 10 (map (+1) (1:(2:(3:[]))))" I can expand it to "take 10 ((+1) 1 : map (+1) (2:(3:[])))" and nothing changes about the result
03:33:06 <ski> dtscode : iow, the context is only depending on the value of the subexpression, not on other features of it
03:33:33 * dtscode nods
03:34:01 <Nobos> does anyone here have experience with persistent?
03:34:09 <tero-> Nobos: yes
03:34:10 <Nobos> I'd like to fake some data
03:34:20 <quicksilver> dtscode: example of non referential transparency in C, compare "a = b++; c = a + a" versus "c = (b++) + (b++)"
03:34:30 <Nobos> the problem is I can't set the Id of the fake data?
03:34:34 <quicksilver> you might reasonably say 'expressions can have side effects'
03:34:40 <tero-> Nobos: which backend?
03:34:45 <Nobos> none yet
03:34:50 <Nobos> I'd like to fake it first
03:35:06 <Nobos> so I have a tenant with a name property
03:35:15 <Nobos> and I'd like to reference that in a project
03:35:18 <dtscode> quicksilver: huh... ok yeah thats different from what I was thinking
03:35:59 <quchen2> (b++) + (b++) isn't even well-defined in C, is it?
03:36:12 <tero-> Nobos: insert returns the id. you could have a program that generates the fake data
03:36:28 <Nobos> @tero one second, I'll post a gist
03:36:28 <lambdabot> Maybe you meant: vera todo tell
03:36:34 <dtscode> quchen2: I think in c++ it is. I try not to think about the bastard child C
03:36:51 <Nobos> tero: https://gist.github.com/ToJans/7edd74980eb48d58e905
03:37:30 <quicksilver> quchen2: yeah maybe not a very good example.
03:37:31 <Nobos> tero: how do I add references in the projects to the tenant?
03:37:43 <quicksilver> dtscode: it's  not the only way referential transparency can fail.
03:38:27 <Nobos> tero: is there some kind of mocking fw?
03:38:37 <quchen2> quicksilver: Maybe a good example how it's not that simple to even talk about referential transparency in C. But let's say you have a Lisp in which functions are eagerly evaluated depth-first.
03:38:42 <tero-> Nobos: tId <- insert $ Tenant "name" ; _ <- insert $ Project "description" tId content
03:39:07 <Nobos> aha
03:39:37 <Nobos> tero: I'll try, thank you!
03:39:51 <tero-> Nobos: good luck
03:41:39 <quicksilver> quchen2: you still need either non-termination or mutation for the evaluation order to matter
03:41:43 <quicksilver> quchen2: (don't you?
03:44:31 <merijn> quicksilver: You are correct, it's undefined in C and C++ (not 100% about the latter)
03:44:59 <quicksilver> merijn: but it's not full-on 'nasal demons' undefined
03:45:05 <merijn> quicksilver: It is
03:45:28 <quicksilver> merijn: it is guaranteed to return b+b or b+b+1 isn't it?
03:45:57 <merijn> quicksilver: Multiple ++/-- operations on the same identifier are full on undefined behaviour unless there's a sequence point between both invocations
03:46:03 <knupfer> dtscode:  C is the child of C++ ?
03:46:11 <quicksilver> ok then
03:46:15 <merijn> quicksilver: I'm pretty sure even "a = b + b++" is undefined
03:46:33 <dtscode> knupfer: no its the bastard child of knuth and ritchie :D
03:46:34 <quicksilver> int f() { return (b++) }; c = f() + f();
03:46:51 <merijn> quicksilver: Because C does not guarantee order of evaluation of expressions
03:47:43 <knupfer> in this case the order doesn't play a role (assuming b are wellbehaved ints)
03:48:11 <merijn> knupfer: Eh, yes it does
03:48:28 <merijn> knupfer: Because the first 'b' might be evaluated after the ++ of the "b++" expression
03:48:30 <knupfer> merijn: Oh!  You're right
03:48:42 <knupfer> I'm thinking to functional
03:49:36 <suppi> quicksilver, The rules for sequencing says that you can only update a variable once
03:49:37 <suppi> between sequence points.
03:49:42 <Nobos> turo: I'm assuming what I'm trying to do is impossible without a DB instance? :p
03:49:50 <knupfer> At the other hand, if they are wellbehaved ints, they aren't mutable
03:50:07 <merijn> const all the things! :)
03:50:20 <Nobos> turo: or, not imossible but a lot of work ;)
03:50:31 <knupfer> Can anybody help me with my typelevel example? http://lpaste.net/141462
03:51:21 <Nobos> tero: tero, not turo #DOH
03:51:23 <knupfer> Why doesn't test1 work like test3?
03:52:05 <knupfer> And what is ghc exactly doing when I write: main = print (undefined :: N:::10000) 
03:52:26 <knupfer> It compiles but takes more or less 10 minutes to do so
03:52:40 <knupfer> the result is instant 10000 when running
03:53:12 <suppi> knupfer, is that valid haskell?
03:53:17 <knupfer> yep
03:53:21 <merijn> suppi: No, it's valid GHC, though :p
03:53:24 <suppi> what is N:::10000 ?
03:53:25 <knupfer> ok
03:53:31 <knupfer> look at the lpase
03:53:35 <knupfer> http://lpaste.net/141462
03:53:43 <knupfer> it's a type level operator
03:53:55 <knupfer> a natural number of value and type 10000
03:53:56 <suppi> oh, type families and things. no idea what that is
03:53:58 <merijn> knupfer: It's generating and inlining ten thousand calls to the fromNatural class
03:54:00 <tero-> Nobos: my 1,5 toddler just woke up. I'll reply later
03:54:19 <Hafydd> 1.5 toddlers.
03:55:05 <knupfer> merijn: And why does (test1 test4) don't typecheck but (test3 test5) returns 17 as expected?
03:55:17 <merijn> knupfer: It has to expand the recursion at compile time, then generate the relevant typeclass indirection, notice they can all be inlined/specialised away, eventually producing a static constant that's isntant at compile time (hence the long time :p)
03:55:19 <knupfer> 16
03:56:22 <knupfer> or (test3 test4) is N:::14
03:56:47 <knupfer> but test2 and test1 doesn't work, or I don't know how to sooth the typechecker
03:56:49 <merijn> no idea, this is pretty hard to read, tbh :)
03:57:05 <merijn> knupfer: I'd suggest having a look at Idris/Agda :)
03:57:40 <knupfer> merijn: the idea was experimenting with dependent types is haskell
03:58:22 <merijn> knupfer: GHC doesn't have a numeric solver yet, so it's pretty bad at dealing with Nat
03:58:24 <knupfer> funnily without extending the context-stack, it is quite easy to nuke ghc
03:58:38 <merijn> You can read the Hasochism stack, but there's lots of cases GHC just can't figure out
03:58:45 <merijn> s/stack/stuff
03:58:48 <Axman6> you might also want to use the build in type level naturals, they're implemented more efficiently than the classic Nat example (ie, GHC knows they are numbers and can do maths efficiently)
03:59:03 <merijn> Axman6: Except it can't do maths efficiently
03:59:10 <merijn> Axman6: Because the solver isn't implemented
03:59:16 <merijn> Axman6: It's work in progress in head
03:59:22 <Axman6> I thought it was, this is sad news :(
03:59:43 <Axman6> well... use them anyway, and with GHC 8.0 it'll hopefully compile a lot faster =)
03:59:58 <knupfer> Axman6: Considering that yesterday I've written my first *, I'm glad that it seems to work
04:00:04 <Nobos> tero: in case you're back: I've read up on persistent; apparently there's a generic instance of Tenant, and Tenant is a TenantGeneric SqlBackEnd type, so it wouldn't make sense to do what I'm trying here...
04:00:11 <knupfer> and can transform type-level nats to value-level integers
04:00:26 <nshepperd> eh? GHC.TypeLits can do math efficiently last I heard
04:00:39 <Axman6> I'd definitely recommend having a look at Idris, it's lots of fun
04:00:42 <nshepperd> what it can't do is reasoning back and forward with unknown values
04:00:53 <nshepperd> which we need the solver for
04:01:14 <quicksilver> 2 * NShepperd = NShepperd + 6
04:01:25 <knupfer> Is it possible to have a function :: n -> N:::n  ?
04:01:40 <bz> ':::'?
04:01:45 <quchen2> Then (+ (++ b) (++ b)) would be the example program, quicksilver. I just meant to pick an example in which the "++" are evaluated in some order.
04:01:49 <knupfer> bz: http://lpaste.net/141462
04:02:01 <quicksilver> quchen2: nod.
04:02:24 <knupfer> n should be essentially a typelevel nat, but it should be passable to the function in value of say an Int
04:02:52 <knupfer> So the function would map from an Int into a class (types depending on the int)...
04:03:10 <nshepperd> stuff like 10000 :: Nat and 123*456 is instant though
04:03:42 <bz> knupfer: Z and N are uninhabited
04:03:50 <bz> you'll be trapped with undefined
04:04:38 <knupfer> bz: How could I change that?  The inverse fromNatural works reliable.
04:05:15 <bz> knupfer: use Proxy
04:05:15 <nshepperd> knupfer: somenat :: Integer -> (forall n. Natural n => r) -> r ?
04:05:39 <nshepperd> er, (forall n. Natural n => n -> r), that is
04:05:49 <nshepperd> or Proxy n or whatever
04:07:57 <knupfer> nhepperd: and how would i call such a function? what is the second argument?
04:09:07 <nshepperd> a function that accepts a type-level number (any number), and produces a value
04:09:46 * hackagebot idris 0.9.19.1 - Functional Programming Language with Dependent Types  https://hackage.haskell.org/package/idris-0.9.19.1 (EdwinBrady)
04:10:02 <nshepperd> it has to be existential like this because when you turn an Integer into a type level number you "don't know" what number it is at compile time
04:10:36 <nshepperd> so whatever uses this type-level number had better work for any number...
04:11:30 <ski> knupfer : fyi, nshepperd's `somenat' is the CPS encoding of `somenat :: Integer -> exists n. Natural n *> n'
04:13:12 <knupfer> I'm trying to run that function in ghci but I don't manage to give it valid inputs
04:17:33 <nshepperd> right, you can alternatively do 'data Boxed where Boxed :: Natural n => n -> Boxed' and then 'somenat :: Integer -> Boxed'
04:17:34 <knupfer> somenat 4 (undefined :: n -> N:::2)   returns N (N Z)
04:17:39 <nshepperd> for the un-cps version
04:18:12 <tero-> Nobos: so you'd want to represent your (fake) data set in a declarative and backend-agnostic way?  
04:18:23 <knupfer> but somenat 4 (undefined :: n -> N:::n)   doesn't typecheck
04:18:56 <tero-> Nobos: if so, I don't know of any "add just water and it works" solutions.. :-/ 
04:19:12 <nshepperd> yeah, your output type can't depend on the input
04:19:26 <nshepperd> what would the type of 'somenat 4 (undefined :: n -> N:::n)' be?
04:19:49 <knupfer> nshepperd: undefined at typelevel?
04:20:45 <knupfer> so I can't (with extensions) write a function which takes an Int and returns a typelevel number which corresponds to that int?
04:21:03 <Nobos> tero: that's what I assumed
04:21:05 <nshepperd> right, there's no such thing. we don't have naked existentials in ghc
04:21:06 <tero-> Nobos: you could generate FromJSON and ToJSON instances in the persistent schema declaration (just add json keyword) and then represent the data set as a JSON object
04:21:07 <knupfer> in the sense that i can use it in typesignatures?
04:21:14 <nshepperd> you can't have a type be undefined
04:21:14 <knupfer> argh
04:21:21 <tero-> Nobos: but it's tricky to add the objects in the right order
04:21:23 <knupfer> Ghc.Any?
04:21:39 <Nobos> tero: so you're saying it might not be worth the effort
04:22:10 <tero-> Nobos: it'd be a useful piece of code for many people
04:22:19 <Nobos> tero: how do you usually test things like this? It feels to me like Persistent gets entangled in my domain code
04:22:37 <knupfer> nshepperd: But it would work with TH, no?
04:22:47 <nshepperd> GHC.Any is more like a universal that can only be used once or something
04:22:51 <Nobos> tero: but than again, that's normal as it's part of it
04:22:53 * nshepperd not quite sure
04:22:54 <tero-> Nobos: what would you like to test? 
04:22:54 <Nobos> :D
04:23:14 <tero-> Nobos: database transactions are very much domain code IMO
04:23:14 <Nobos> tero: I'd like to get something up & running with in-mem data first
04:23:26 <knupfer> With TH, I can write a function which maps an Int to a type...
04:23:29 <nshepperd> I don't understand how TH comes into it
04:23:34 <Nobos> tero: so I should probably just use inmem sqlite?
04:24:09 <nshepperd> yeah, you could write a function that produces the AST for some type
04:24:28 <tero-> Nobos: I'd use postgres from the very beginning because it takes care of referential integrity 
04:24:43 <tero-> in case you do something silly, postgres is happy to  point it out
04:24:48 <nshepperd> Proxy :: Proxy $(number 7)
04:24:53 <nshepperd> or whatever
04:25:09 <Nobos> tero: agreed; I'm probably needlessly complicating things by trying to implement an intermediate step
04:25:13 <gremble> In an effort to get fix a cabal dependency issue, I seem to have burnt down my package library. I tried to fix it with cabal update and even reinstalling ghc. Is there a way to repair missing files?
04:25:37 <tero-> oh, sqlite3 seems to support foreign keys these days
04:25:44 <dcoutts> gremble: presumably you did something like rm -rf ~/.ghc  ?
04:26:01 <dcoutts> gremble: or did you just rm -rf ~/.cabal ?
04:26:13 <gremble> That is exactly what I did dcoutts. Both the former and the latter
04:26:22 <gremble> an internet blog suggested that
04:26:28 <tero-> Nobos: once you have selected your DB, you can create your fake data set using your favorite database editor
04:26:32 <knupfer> nshepperd:  I'll try that, albeit I don't really like TH syntax.
04:26:33 <tero-> and then store it as a dump file
04:26:35 <dcoutts> gremble: if you did both you're fine. If you only did the latter then you deleted the files but not the package registration.
04:27:22 <dcoutts> gremble: did you ever install things globally? ie with sudo or --global
04:27:28 <Nobos> tero: ok. When I did other platforms I usually started with fake data and no database, but I assume that's a bit hard in haskell
04:27:44 <dcoutts> gremble: you can check on the status of everything using: ghc-pkg check. If it only complains about missing haddock files then you're good.
04:27:54 <knupfer> Why is the context-stack in ghc limited at 100?
04:28:05 <gremble> dcoutts: no, no global installs. It compains about more than just haddock files
04:28:12 <gremble> Even Data.Generic is missing
04:28:13 <knupfer> To avoid looping at compile time?
04:29:10 <tero-> Nobos: well, you just need to do it programmatically for the moment. it's not a very "hard" part but may cause some rash
04:29:48 <Nobos> tero-: ok, doing that
04:29:58 <dcoutts> gremble: Data.Generic? that's not a standard module
04:30:05 <dzhus> what is the cheap way to do "forever $ return ()" (block thread for indefinite amount of time)?
04:30:06 <merijn> knupfer: Because people don't like 20 minute compiles? :p
04:30:50 <gremble> dcoutts: I have no idea what is going on with it. I just removed .ghc again. It is rebuilding some files. Perhaps it works now
04:30:53 <knupfer> merijn: Better 20 minute than no compile at all, no?
04:30:57 <dcoutts> dzhus: you can wait for a specific amount of time, or you can block on an MVar and have some other thread wake it later
04:31:27 <dcoutts> gremble: certainly deleting .ghc is the sledgehammer approach, non-registered packages can't have missing files.
04:31:37 <knupfer> merijn: What I still don't understand is why (test1 test4) doesn't work.
04:32:07 <gremble> dcoutts: I am a sledgehammer kind of person. It seems to have fixed the problem. So thanks for the help :P
04:32:42 <dzhus> dcoutts: When a make it takeTMVar from an TMVar I never write to, the application terminates with 'thread blocked indefinitely in an STM transaction'
04:32:57 <dcoutts> dzhus: which makes sense of course
04:33:17 <dcoutts> dzack: a thread that will never wake up doesn't make a whole lot of sense
04:33:25 <dcoutts> erm sorry
04:33:28 <dcoutts> dzhus: ^^
04:33:33 <knupfer> What is more approchable/related to haskell: agda or idris? I want to learn a bit dependent typing to learn about typelevel stuff in haskell.
04:33:52 <dzhus> knupfer: start with Haskell type-level capabilities
04:34:01 <dcoutts> dzhus: what might wake the thread up again?
04:34:05 <dzhus> dcoutts: I'll try with plain MVars then
04:34:13 <dcoutts> dzhus: no, same problem
04:34:26 <dcoutts> you need to think about what causes the thread to wake up
04:34:46 <Axman6> a thread that will never wake up does make sense, if it's the main thread
04:35:01 <merijn> edwardk: Ping? :)
04:35:08 <edwardk> ?
04:35:12 <knupfer> dzhus: At the moment I'm not really understanding the haskell side, so I thought that after using say idris, I understand that better (assuming that there are tons of good tutorials for idris).
04:35:44 <merijn> edwardk: I have some questions for you about the Rendering stuff in trifecta. I think I managed to figure a lot out, but not everything
04:35:45 <edwardk> something about 20 minute compiles?
04:35:46 <edwardk> =)
04:35:49 <edwardk> ah
04:35:54 <Axman6> in the past I've used things like newEmptyMVar >>= \mv -> forkIO (forever foo >> putMVar mv ()); takeMVar mv
04:36:07 <edwardk> i keep meaning to replace all the rendering code in there with an ADT that describes the markup
04:36:11 <edwardk> we never use the current flexibility
04:36:28 <Axman6> knupfer: the official idris tutorial is quite good
04:36:57 <dzhus> Axman6: roughly what I have (an optional put and unconditional take afterwards), except without a forever
04:36:57 <knupfer> Axman6: so you would suggest idris and not agda (I heard that idris is strict).
04:36:59 <merijn> edwardk: And trifecta errors in general :) So I was trying to simulate the "addSpan" output (caret followed by tildes), but I can't seem to manage it?
04:37:19 <edwardk> merijn: 'simulate' how?
04:37:24 <merijn> edwardk: Using "spanned" or "careted" to parse something and render it works, but I don't know how to combine/compose them?
04:37:42 <Axman6> knupfer: it feels more usable for actual programming instead of theorum proving only - it feels like haskell with dependant types
04:37:48 <merijn> edwardk: Span only does tildes, caret only places a caret, but the addSpann docs show a caret followed by tildes
04:38:07 <merijn> edwardk: I tried "careted (spanned foo)" but that just produces a caret
04:38:26 <edwardk> ah, i may have changed the formatting from the way i documented at first
04:38:35 <merijn> I also don't understand the purpose of Fixit?
04:38:49 <shiona_> anyone here who's worked on bnfc?
04:39:19 <edwardk> http://hackage.haskell.org/package/trifecta-1.5.2/docs/src/Text-Trifecta-Rendering.html#spanEffects drawSpan indeed only includes the ~'s
04:39:35 <merijn> And while I'm spilling a deluge of questions. I don't grok how MarkParsing is supposed to work :)
04:39:47 * hackagebot RoyalMonad 1000.0 - All hail the Royal Monad!  https://hackage.haskell.org/package/RoyalMonad-1000.0 (AtzeVanDerPloeg)
04:39:49 <shiona_> I case there is: our lecturer sends his thanks
04:40:14 <quicksilver> dzhus: why not forever $ threadSleep SOME_NUMBER ?
04:40:18 <edwardk> merijn: http://clang.llvm.org/diagnostics.html shows a bunch of fixit examples
04:40:42 <knupfer> Axman6:  Ok, thank you and thank you merijn
04:40:58 <edwardk> merijn: hah. markparsing is like timetravel. it takes you back to a given position in the input and you can parse from there. an example usecase would be to do an initial parse that mostly skips sub-expressions, then come back once you know fixities
04:41:25 <edwardk> in practice i haven't used it like i'd originally planned
04:42:16 <edwardk> next major release of trifecta should include simplifying delta, turning rendering into a simple, serializable ADT, killing markparsing and the ropes and switching to a more straightforward attoparsec style feeding mechanism
04:43:21 <edwardk> i should also move the highlighting support out to a monad transformer
04:46:30 <merijn> edwardk: Right, that seemed mostly like what I wanted to use it for. I looked at the Ermine parsing of operators but it's use of parsers operator stuff is...confusing
04:46:31 <dzhus> quicksilver: SOME_NUMBER is infinity
04:46:43 <nyon> Is it possible to provide Foldable and Traversable instances for Free monads that use the trick from the Reflection Without Remorse paper?
04:46:56 <edwardk> merijn: i don't remember if we even got around to parsing operators in the haskell side of ermine
04:47:07 <edwardk> we kind of got distracted by other things and never really finished that project
04:47:09 <dcoutts> dzhus: any luck with the threads thing? Worked out when that thread needs to wake up?
04:48:03 <edwardk> nyon: you'd need to transform the whole free monad into RwR style but there isn't any particular reason why not
04:48:34 <merijn> edwardk: ok, I think I get the Fixit thing, so is it possible to combine different rendering things like Caret/Span/Fixit somehow, or not?
04:49:04 <edwardk> well, you can 'addSpan' then addCaret on top using the first endpoint =)
04:49:36 <edwardk> the 'careted' etc. combinators are just conveniences around capturing the locations
04:49:48 <merijn> Right
04:50:00 <lpsmith> hmm, does anybody know *why* addMVarFinalizer is deprecated?
04:50:10 <merijn> I guess I could have a  combinator that does both and splat them
04:50:16 <quicksilver> dzhus: ok and htat's fine. although I don't understand what the point is
04:50:28 <edwardk> yep
04:50:29 <quicksilver> dzhus: what is the purpose of having a thread do nothing forever?
04:50:42 <edwardk> just capture the location, before and after, then tell it how to render
04:51:14 <dzhus>  quicksilver: it's a part of a bigger system and I just want a workaround to suppress further execution in of its parts in case a certain list is empty
04:51:15 <quicksilver> lpsmith: JaffaCake does :/
04:51:24 <merijn> edwardk: So if MarkParsing is going, how would you do operator parsing? Parse a sequential list of operators/expressions and then rejigger according to fixity afterwards?
04:51:38 <edwardk> merijn: that is the usual story
04:51:41 <edwardk> and what i do now
04:51:42 <quicksilver> dzhus: the forever $ threadDelay MAXINT seems reasonable
04:51:49 <edwardk> i just never got around to using the markparsing machinery for anything
04:51:55 <edwardk> and afaik nobody else has either
04:52:09 <merijn> edwardk: No, because I couldn't find any examples :p
04:52:17 <edwardk> hahahaha
04:52:46 <merijn> edwardk: So the ByteString in Caret/Span are they entire input line?
04:52:58 <merijn> Or just the parsed part
04:53:23 <merijn> And would multi-line span's work? or should I use multiple separate things for that?
04:53:25 <sabrehagen> i'm confused: i'm using dwm with no desktop environment. what's responsible for skining graphical applications then?
04:54:04 <edwardk> yes
04:54:19 <edwardk> merijn: basically they just show the starting line and run off the end and don't say where they stop
04:54:25 <edwardk> we only show one line in a single rendering
04:54:41 <sabrehagen> sorry - wrong channel!
04:55:04 <edwardk> you can make extra diagnostic message 'note's and get things like long distance callouts to e.g. conflicting declarations, or to the end of a span if you want
04:56:02 <edwardk> those are the 'footnotes' in http://hackage.haskell.org/package/trifecta-1.5.2/docs/src/Text-Trifecta-Result.html#Err, which are usually the result of rendering other diagnostics
04:56:11 <merijn> Right
04:56:39 <edwardk> but in any event there isn't direct support for it
04:56:52 <edwardk> decided to just try to handle the common case well
04:57:56 <dzhus> quicksilver: gotcha, that's all I need now
04:58:46 <merijn> The last thing (for now) is that raiseErr seems to always add expected symbols even if my initial Err has an empty symbol set? Some errors I don't want to give "expected" symbols, but I can't seem to arrange that?
04:59:48 * hackagebot ContextAlgebra 0.1.0.0 - Context Algebra  https://hackage.haskell.org/package/ContextAlgebra-0.1.0.0 (jhahn)
04:59:50 * hackagebot NearContextAlgebra 0.1.0.0 - Context Algebra of near  https://hackage.haskell.org/package/NearContextAlgebra-0.1.0.0 (jhahn)
05:10:55 <edwardk> merijn: can you break it down to a test case and file an issue? i don't have time right now to look into that one
05:11:52 <merijn> edwardk: I was trying to figure it out myself, but the variable naming of Parser is...unhelpful :p
05:12:09 <edwardk> heh they were helpful to me =)
05:12:30 <edwardk>   raiseErr e = Parser $ \ _ ee _ _ _ _ -> ee e
05:12:31 <merijn> raiseErr is just "raiseErr e = Parser $ \ _ ee _ _ _ _ -> ee e", so the "ee" callback is responsible for modifying the err, but I don't know how/where
05:12:37 <edwardk> just passes it out there
05:13:42 <edwardk> guessing you're getting it passed along to (<?>) (<|>) or something that is attaching the expected tokens for the current location
05:13:59 <edwardk> foo <|> bar   -- will track the expected set of 'foo' until you 'move'
05:15:04 <edwardk> Parser m <|> Parser n = Parser $ \ eo ee co ce d bs -> m eo (\e -> n (\a e' -> eo a (e <> e')) (\e' -> ee (e <> e')) co ce d bs) co ce d bs
05:15:33 <merijn> Basically I have StateT over parser and am doing "do { (result, state) <- runStateT parser state; if predicate state then return result else raiseErr err }"
05:15:40 <edwardk> that calls 'm' with a hacked up 'ee' hat tries to recover and call the second parser n, with the combined expected sets
05:16:11 <merijn> Which is tacking "expected: " followed by all possible top level tokens
05:17:09 <edwardk> well, you might be able to hack the 'err' up by hand to remove them i guess.
05:17:26 <edwardk> raiseError (err & expected .~ mempty)
05:17:46 <merijn> edwardk: I'm using "failed" which already initialises the Err with mempty
05:17:50 <edwardk> oh yeah
05:17:51 <edwardk> hrmm
05:17:57 <merijn> So they're getting added to the set *after* passing to raiseErr
05:18:12 <edwardk> let me guess your parse state doesn't actually 'consume' anything when it fails
05:18:23 <edwardk> it just fails at first position?
05:18:36 <edwardk> so when you finally raiseErr you are just blaming the first position?
05:18:43 <merijn> It fails at EOF
05:18:46 <edwardk> and you're getting all the backtracks from all the try's up tothat point
05:18:54 <edwardk> hrmm
05:18:57 <merijn> It consumes the entire input and fails after parsing terminates
05:20:34 <edwardk> merijn (Parser m) = Parser $ \ eo ee -> m (\a e -> eo a e { _expected = mempty }) (\e -> ee e { _expected = mempty })
05:20:38 <edwardk> then you can do
05:20:51 <c_wraith> merijn is a function now?
05:21:04 <edwardk> do { (result state) <- merijn (runState parser state); if predicate state then return result else raiseErr err }
05:21:09 <edwardk> c_wraith: yes
05:21:31 <edwardk> that will strip the expected set from the first part of the computation
05:22:08 <edwardk> er do { (result, state) <- merijn ...; ... }
05:23:51 <edwardk> you could also use something like bump :: Parser (); bump = Parser $ \ _ _ co _ -> co () mempty
05:24:06 <edwardk> do { (result, state) <- runState parser state; bump; if predicate state then return result else raiseErr err }
05:24:25 <edwardk> bump will cause it to drop all the current accumulated expected tokens on the floor
05:24:44 <edwardk> and it will prevent backtracking
05:24:45 <merijn> hmmm, doesn't seem to work (the first one), lemme try the second
05:24:49 * hackagebot rest-gen 0.18.0.0 - Documentation and client generation from rest definition.  https://hackage.haskell.org/package/rest-gen-0.18.0.0 (ErikHesselink)
05:24:59 <quicksilver> edwark: if you used TeX's analogy of the mouth of the parser
05:25:02 <c_wraith> Isn't preventing backtracking usually named cut?
05:25:05 <quicksilver> edwardk: you could call that combinator vomit
05:25:11 <edwardk> quicksilver: =P
05:25:22 <quicksilver> I'm not suggesting that's a good idea though :)
05:25:24 <edwardk> c_wraith: that might be a better name for it
05:25:41 <edwardk> its basically a 'commit' combinator
05:25:51 <edwardk> in the polyparse vocabulary
05:25:53 <quicksilver> cut is a good name for people who've done theoretical logic but I'd argue it's a bad name for the casual programmer
05:26:11 <c_wraith> it's the prolog name.  So....  yeah
05:26:12 <quicksilver> cut is a very technical term and I'm not sure it has the right (non-technical) symbolism for this
05:26:14 <edwardk> well if people don't like it you can always threaten to cut them
05:26:22 <quicksilver> quite
05:26:22 <merijn> whoo
05:26:27 <merijn> This seems to work :)
05:26:29 <quicksilver> edwardkscissorhands
05:26:45 <quicksilver> I quite like 'commit' though
05:27:04 <edwardk> commit is sort of an 'anti-try'
05:27:23 <Axman6> merijn: quick, write a tutorial
05:27:45 <Axman6> I'd love to know how to use trifecta, particularly how to do the nice error messaging
05:27:56 <merijn> Untry :)
05:28:07 <merijn> Axman6: The nice errors are easy, they're standard :p
05:28:22 <merijn> I was planning to at like a Trifecta.Tutorial Tekmo style once I finish this stuff
05:28:35 <Axman6> excellent
05:28:47 <Axman6> I'm very much looking forward to seeing it
05:29:21 <merijn> Axman6: The short summary is: Use parsers and a newtype to get the tokenization you want
05:29:46 <merijn> Axman6: The stuff I was working on is: https://github.com/merijn/lambda-except
05:29:49 * hackagebot avatar-generator 0.1.0.0 - A simple 5x5 random avatar icon generator  https://hackage.haskell.org/package/avatar-generator-0.1.0.0 (IvanPerez)
05:30:01 <merijn> Most of the "how do I use Trifecta" stuff is pretty evident from Lexer.hs
05:30:16 <Axman6> thanks, I'll take a look
05:30:16 <cocreature> ; reconcilation
05:30:18 <cocreature> sry
05:30:39 <merijn> It has a hacky haskell style layout rule for whitespace (although it doesn't allow optional braces, because screw that)
05:30:47 <cocreature> the idris source is also a fairly good example of how to use trifecta
05:32:33 <dtscode>     removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]   ← this is like def removeNonUppercase(st): return [ c for c in st if c in ['A' .. 'Z']] right?
05:32:43 <Axman6> oh, I wasn't aware it's using trifecta, excellent
05:32:46 <dtscode> ** in python right?
05:33:01 <merijn> dtscode: Yeah, it's also a terrible function
05:33:09 <merijn> dtscode: Breaks for anything non ascii
05:33:27 <dtscode> merijn: yeah. LYAH is just using it to teach list comps for strings
05:33:45 <dtscode> I just wanted to make sure I was understanding what it did correctly
05:33:51 <merijn> Better would be [c | c <- st, not (isUpper c)] :)
05:34:12 <merijn> dtscode: But yeah, it's like a python list comprehension
05:34:29 <merijn> dtscode: Or rather, python copied haskell's list comprehensions so they are like this, I guess :p
05:34:30 <Axman6> s/not//
05:34:48 <dtscode> merijn: :D I did think they looked pretty similar
05:34:54 <dutchie> merijn: surely best would be "filter (not . isUpper)"
05:35:13 <merijn> dutchie: Yeah
05:35:18 <quicksilver> dutchie: not for teaching list comps :P
05:35:18 <dutchie> though obv not for teaching list comprehensions
05:35:24 <dutchie> hehe
05:36:25 <dutchie> errr, we gained a not at some point
05:36:30 <dutchie> but yeah
05:37:41 <merijn> I misread what it did :)
05:39:51 * hackagebot graphql 0.3 - Haskell GraphQL implementation  https://hackage.haskell.org/package/graphql-0.3 (jdnavarro)
05:40:05 <Axman6> merijn: this (lambda-except) is really nice
05:40:27 <merijn> Axman6: I still need to actually implement everything it's meant to accomplish :p
05:40:36 <merijn> i.e. type system :p
05:40:52 <Axman6> heh
05:41:03 <Axman6> but the parser is quite educational
05:41:28 <merijn> Once you get the trick it's pretty easy to use Trifecta
05:41:47 <Axman6> where does "reserved" come from?
05:41:55 <merijn> parsers
05:42:16 <Axman6> right, ok
05:42:37 <merijn> Axman6: Basically 90% of the combinators are from parsers or the TokenParsing class
05:45:02 <merijn> Now I need to figure out how can I nicely worked Spanned into my AST so I can more easily highlight things :p
05:46:56 <Axman6> data Annotated a = Ann (Maybe Caret) (Maybe Span) a ?
05:47:29 <merijn> Axman6: I don't have a Free based AST (because that was a pain and edwardk recommended against it)
05:47:31 <beaky> hello
05:47:46 <liste> hello beaky
05:47:51 <beaky> how do i import a file as String or Text in haskell (like #include)
05:47:58 <beaky> in compile-tiem
05:48:16 <Axman6> you can use the CPP language extension
05:48:23 <Axman6> but, why do you want to do that?
05:48:34 <beaky> so i can put sql scripts in separate .sql files
05:48:42 <Axman6> D:
05:48:47 <liste> @hackage file-embed -- check this out
05:48:48 <lambdabot> http://hackage.haskell.org/package/file-embed -- check this out
05:48:48 <ARM9> #include as in the c preprocessor? that directive inserts the text in the included file verbatim to the includer
05:48:48 <beaky> but then #include them up into prepared statements
06:01:32 <fedorafan> hey could anyone try to explain this Type->Type definitions or what name is
06:02:19 <liste> fedorafan any more context?
06:02:36 <liste> a -> b is the type of a function from a to b
06:02:38 <suppi> fedorafan, (->) symbolizes a function from the left type to the right type
06:02:52 <fedorafan> yeah is there a name for that way of definitions
06:03:34 <quchen2> It's called a type. If it's associated to a value, we call it "the type signature of that value".
06:03:55 <liste> fedorafan https://wiki.haskell.org/Type_signature
06:04:27 <fedorafan> hmm
06:04:31 <fedorafan> I will take a look thx
06:06:37 <fedorafan> could you give me a short example with brackets I am not that sure if you use that too I read it another context but it is the same way of notation with type signatures
06:07:08 <liste> > (5 :: Int) -- fedorafan
06:07:10 <lambdabot>  5
06:07:32 <fedorafan> hmm I need this with the arrows
06:07:50 <liste> > ((+) :: Int -> Int -> Int) 1 2
06:07:52 <lambdabot>  3
06:07:54 <fedorafan> yeah much better
06:08:07 <fedorafan> so add takes two parameters of type int and gives an int right
06:08:26 <fedorafan> the first 2 are the parameters and the last is the given value of the function in right
06:08:27 <liste> or, alternatively, it takes one parameter of type Int and returns a Int -> Int
06:08:36 <fedorafan> ahhh good point
06:08:44 <fedorafan> how to understand that dont got it
06:08:58 <liste> :t ((+) 5)
06:08:59 <lambdabot> Num a => a -> a
06:09:11 <fedorafan> and what is the difference
06:09:40 <liste> they're the same thing in Haskell
06:09:52 <liste> it's called currying
06:09:55 <fedorafan> but you said the last 2 parameters stands for the function?
06:10:18 <fedorafan> a1 => a2 -> a3
06:10:28 <fedorafan> a1 is your first parameter and what is the rest
06:10:35 <kaidelong> a1 there is a context
06:10:40 <liste> => is different from ->
06:10:43 <fedorafan> ahhh puhh what is that
06:11:01 <liste> as kaidelong said, the thing left of => is called context
06:11:06 <fedorafan> oki
06:11:10 <kaidelong> a1 has to have a2 or a3 used inside it somewhere
06:11:14 <fedorafan> ahhhh
06:11:17 <jerojasro> fedorafan: the typeclass; basically, a constraint, or condition for the argument(s)
06:11:19 <kaidelong> it provides additional information about another type to the right
06:11:23 <kaidelong> for example
06:11:31 <kaidelong> @type (*)
06:11:32 <lambdabot> Num a => a -> a -> a
06:11:42 <fedorafan> what is that :D
06:11:46 <kaidelong> (*) would not make any sense on something that isn't a number
06:11:52 <jerojasro> in this situation, it tells you: you have a two args function
06:11:52 <fedorafan> a is the context and needs to have 3 parameters
06:12:07 <jerojasro> and those arguments have to belong to the "Num" typeclass
06:12:08 <kaidelong> so it has to use a context to prevent you from passing an 'a' in that isn't a number
06:12:30 <fedorafan> ahhh the context is a typedefinition
06:12:38 <jerojasro> fedorafan: is a concept similar to a Java interface
06:12:42 <fedorafan> got it
06:12:55 <FireFly> well it's not a definition, but a constraint on the type
06:12:56 <fedorafan> wow you are so cool guys thx
06:13:23 <liste> you're welcome fedorafan (:
06:13:29 <kaidelong> basically the most important thing to remember about functions is that -> is right associative
06:13:43 <kaidelong> you can always change a -> (b -> c) to a -> b -> c and back
06:13:46 <kaidelong> the two are equivalent
06:14:14 <kaidelong> it won't break any code either, those two types match
06:14:32 <fedorafan> ahhh
06:14:37 <fedorafan> good point to know
06:14:58 * hackagebot libgraph 1.6 - Store and manipulate data in a graph.  https://hackage.haskell.org/package/libgraph-1.6 (faddegon)
06:15:00 * hackagebot RoyalMonad 1000.1 - All hail the Royal Monad!  https://hackage.haskell.org/package/RoyalMonad-1000.1 (AtzeVanDerPloeg)
06:15:11 <fedorafan> but (a->b)->c is something else
06:15:22 <liste> fedorafan yes
06:15:46 <fedorafan> is the parameter a function with a as parameter and b as output
06:15:53 <fedorafan> so something like a function
06:17:34 <fedorafan> a -> (b -> c) says it takes a as parameter and puhh not that sure now
06:18:25 <kaidelong> in this case, a is its input and (b -> c) is its output
06:18:32 <fedorafan> hmmoki
06:18:36 <fedorafan> that makes sense
06:18:40 <fedorafan> and why is it the same
06:18:42 <kaidelong> function application is left associative
06:18:58 <kaidelong> so this means that f x y is always the same as (f x) y
06:19:17 <kaidelong> you can change them back and forth into each other without breaking any code
06:19:29 <fedorafan> dont got that
06:19:56 <fedorafan> so we are in another topic not anymore the arrowbase notation right?
06:19:58 * hackagebot avatar-generator 0.1.0.1 - A simple random avatar icon generator  https://hackage.haskell.org/package/avatar-generator-0.1.0.1 (IvanPerez)
06:20:00 <kaidelong> when you see "f x y" it means "apply y to the result of f(x)"
06:20:16 <fedorafan> ok
06:20:21 <fedorafan> that is something else right
06:20:28 <kaidelong> this is "value-level"
06:20:36 <kaidelong> functions are applied
06:20:54 <kaidelong> when you have a function f : a -> b, and a value x : a, you can write "f a : b"
06:21:24 <kaidelong> when you have a function f : a -> b -> c, and a value x : a, and a value y : a, you can write f x : b -> c and f x y : c
06:21:45 <fedorafan> understand you
06:21:52 <kaidelong> the type (->) associates right but the way it is used with application associates left
06:21:52 <fedorafan> it is another way of describe it right
06:22:02 <kaidelong> this is how haskell simulates multi-parameter functions
06:22:06 <fedorafan> got you
06:22:44 <kaidelong> all haskell functions only take one parameter, but because a function can produce a new function that expects the next parameter, you can act like you take multiple
06:23:21 <fedorafan> ahhh that is completely new to me
06:23:21 <kaidelong> thus "a -> b -> c" is practically a multi-parameter function even if it is really "a -> (b -> c)"
06:23:32 <hodapp> it is different from how most languages handle functions
06:24:46 <fedorafan> so it says I got a function with b as parameter and this takes a as parameter, hmm could you say it in usual words
06:26:48 <fedorafan> more concrete and very easy probably it would help an add-functio as a->b->c
06:27:13 <fedorafan> with brackets so that way a->(b->c) right associative makes the same right
06:27:21 <jerojasro> fedorafan: do you understand what is function currying?
06:27:26 <fedorafan> I think no
06:27:51 <jerojasro> fedorafan: http://learnyouahaskell.com/higher-order-functions
06:28:02 <fedorafan> thanks I will take a look
06:28:20 <jerojasro> that should help you grasp all what has been said here a little bit more
06:28:34 <fedorafan> ok I first will try to understand it
06:34:32 <fedorafan> ok so our example a->(b->c), it takes a parameter a and gives a function (b->c) (a is in mind of the new function) 
06:35:29 <fedorafan> so it is part of the new function that way
06:35:50 <jerojasro> yes, you can say that :)
06:35:52 <suppi> fedorafan, a -> (b -> c) is a function that takes an a and returns a function b -> c
06:36:05 <suppi> as you said
06:36:33 <suppi> since (->) is right associative you can omit the parens in this example
06:37:30 <fedorafan> it is fine for now thanks
06:38:12 <suppi> sure
06:39:33 <fedorafan> like f(a) = g(b) = c
06:39:36 <fedorafan> something like that
07:05:19 <programo> Hi the program loaded successfully, but I coulkd not get the results .Here is the code http://lpaste.net/141465
07:05:39 <tero-> is anyone using Haste.App?
07:06:31 <Sindriava> Can I zoom with lens inside a state monad?
07:06:40 <Sindriava> e.g. `world.player.position.x += 10 >> world.player.position.y += 10` to something like `zoom (world.player.position) $ x += 10 >> y += 10` ?
07:07:01 <magneticduck> so I started working on a proprietary codebase, and here is a little list of operators that I have *never fking seen before* in haskell: § != -<> -<>- <>-
07:07:14 <magneticduck> and that first one doesn't even appear on my keyboard
07:07:21 <magneticduck> hoogle doesn't give me anything
07:07:30 <magneticduck> how can I search hackage for symbols like these?
07:07:33 <Intolerable> none of those are anything i've ever seen before
07:07:34 <programo> Could anybody help me finding the issue?
07:07:50 <clrnd> Sindriava, doesn't that work?
07:07:54 <frerich_> magneticduck: They may well be functions defined specifically for your code base, i.e. try grepping for '(-<>-)' or so.
07:07:58 <Intolerable> how big are the modules with those symbols?
07:08:08 <Sindriava> clrnd: It doesn't seem so
07:08:15 <Intolerable> if you can narrow it down to a specific import that's probably the best idea
07:08:21 <Intolerable> especially if its something internal
07:08:32 <Sindriava> clrnd: Though I am using a custom monad stack, so MonadState Foo, not StateT Foo a
07:09:07 <ImNotAKompjoetr> magneticduck: seems like custom defined operators, best you can do is somehow search their definition in your codebase
07:09:12 <magneticduck> frerich_: okay I've gone through a bit and found that the things with <> in them are just slightly augmented mappends for dealing with text in various ways
07:09:17 <magneticduck> one sec, grepping a bit
07:09:47 <magneticduck> § isn't defined in the codebase
07:10:01 <magneticduck> neither is '==.'
07:10:12 <magneticduck> hahaha I need to have a conversation with the guy
07:10:22 <Intolerable> that's a esqueleto thing iirc
07:10:45 <magneticduck> well last resort I could do some dependency grepping hackery
07:10:55 <Intolerable> https://hackage.haskell.org/package/esqueleto-2.4.1/docs/Database-Esqueleto-Internal-Language.html#v:-61--61-.
07:11:00 <programo> Could anybody look into my code  Hi the program loaded successfully, but I coulkd not get the results .Here is the code http://lpaste.net/141465
07:11:15 <clrnd> programo, what do you mean by "get the result"?
07:12:18 <magneticduck> Intolerable: hmm well esqueleto isn't being used, but there is a lot of persistant database stuff, probably something from there
07:12:31 <hexagoxel> clrnd: it does not terminate
07:12:39 <Intolerable> magneticduck: yeah, probably one of the two
07:12:41 <Sindriava> clrnd: Yeah, it seems that `zoom' works on StateT and not MonadState :/
07:12:51 <programo> when I tried gcdiv 6 3 , I did not get any result , does not terminate
07:12:56 <hexagoxel> programo: you can observe what happens by using `import Debug.Trace` and adding a case `  | traceShow (a,b) False = error "cannot happen"`
07:13:01 <clrnd> Sindriava, was checking that, where the hell is the definition, so many modules damn
07:13:18 <magneticduck> programo: that should be very noticable from looking at the code
07:13:19 * clrnd always uses the slim lens alternatives
07:13:27 <magneticduck> it only terminates when b== 0
07:13:33 <magneticduck> and b is only set to be a `div` b
07:13:56 <Sindriava> clrnd: Control.Lens.Zoom.zoom
07:14:02 <magneticduck> oh god this § operator is messing with me so much
07:14:02 <haskell504> How can i do so i dont get all combination of this list comphrensasion?
07:14:03 <haskell504> http://lpaste.net/141466
07:14:49 <Sindriava> clrnd: Although it doesn't seem like it in the definition, hm…
07:15:13 <clrnd> Sindriava, https://hackage.haskell.org/package/lens-4.13/docs/Control-Lens-Internal-Zoom.html#t:Zoomed ?
07:15:28 <clrnd> it's a type fam with StateT
07:15:44 <Sindriava> clrnd: I'm looking at https://hackage.haskell.org/package/lens-3.10/docs/Control-Lens-Zoom.html, but that's apparently an old version
07:16:20 <cocreature> magneticduck: hayoo gave me https://hackage.haskell.org/package/altcomposition-0.2.2.0/docs/Data-AltComposition.html#v:-167- for §
07:16:30 <quicksilver> Sindriava: it works with StateT anywhere in the stack, but StateT does have to be in the monad stack yes.
07:16:47 <magneticduck> cocreature: I didn't have any luck with hackage
07:16:49 <clrnd> he is not using StateT, that's the thing
07:16:49 <Sindriava> quicksilver: Well I have it in the monad stack, that's not an issue
07:16:49 <magneticduck> cool thanks
07:16:59 <Sindriava> clrnd: I'm am, but *inside* the monad stack
07:17:05 <lyxia> haskell504: I did not understand your problem.
07:17:06 <clrnd> ohh, though it was full custom
07:17:17 <Sindriava> newtype Game a = Game { unG :: ReaderT GameConfig (StateT GameState IO) a } deriving (...)
07:17:30 <haskell504> when I'm using that code i get all the possible combinations
07:17:30 <clrnd> Sindriava, then maybe it's your MonadState instance?
07:17:42 <Sindriava> clrnd: Dunno, It's derived
07:17:45 <quicksilver> I'm not sure how it's supposed to work via newtypes :(
07:17:48 <haskell504> i dont want all combinations
07:18:01 <quicksilver> I don't really understand zoom very well. I think you need edwardk...
07:18:03 <clrnd> me neither ...
07:18:07 <beaky> hello
07:18:13 <lyxia> haskell504: combinations of what?
07:18:22 <beaky> is there a way to quote a variable into a Text or String
07:18:48 <Sindriava> quicksilver: Well, using GeneralizedNewtypeDeriving, you can derive MonadState Foo if you have StateT Foo in the newtype
07:18:52 <lyxia> haskell504: Can you paste more context to your code?
07:18:56 <haskell504> ok
07:19:06 <magneticduck> beaky: hoogle search "a -> String" https://www.haskell.org/hoogle/?hoogle=a+-%3E+String
07:19:08 <beaky> e.g. f foo = "foo"; f bar = "bar"
07:19:12 <quicksilver> Sindriava: yes but that's not how zoom works
07:19:14 <haskell504> http://lpaste.net/141467
07:19:14 <Sindriava> beaky: Not really. You can use mconcat and show
07:19:20 <liste> beaky no, it's not possible
07:19:21 <lyxia> haskell504: Where's the problem, what does it do, what do you expect it to do?
07:19:23 <quicksilver> Sindriava: zoom doesn't hook into your MonadState instance
07:19:32 <quicksilver> Sindriava: it works directly on the structure of the monad stack
07:19:33 <haskell504> if u try to use isOkay with example
07:19:33 <programo> magneticduck,  got it thanks!
07:19:34 <magneticduck> beaky: oh a variable
07:19:36 <beaky> i want to show the literal variable name itself as entered in teh source code
07:19:39 <haskell504> just write isOkay example
07:19:43 <liste> beaky except with TH hackery
07:19:46 <beaky> oh 
07:19:51 <magneticduck> yeah with TH it wouldn't be that far off
07:19:58 <haskell504> you will get all possible combinations of those list i entered in isOkay list comprensasion
07:19:59 <magneticduck> but.. WHY WOULD YOU EVER POSSIBLY WANT THAT xD
07:20:01 <Sindriava> quicksilver: Yeah, that's what's confusing. Why doesn't it use MonadState like `+=` for example?
07:20:01 * hackagebot diagrams-svg 1.3.1.5 - SVG backend for diagrams drawing EDSL.  https://hackage.haskell.org/package/diagrams-svg-1.3.1.5 (BrentYorgey)
07:20:02 <slacko1256> does seq (id . id) () eval the (id . id) part?
07:20:09 <slacko1256> if so, what is its whnf
07:20:10 <beaky> magneticduck: i want to write sql statements
07:20:16 <beaky> but i find myself repeating myself
07:20:19 <quicksilver> Sindriava: because MonadState doesn't provide enough information to run the other effects
07:20:24 <Sindriava> @where xyproblem
07:20:24 <lambdabot> xyproblem.info
07:20:24 <beaky> in terms of the actual data i pass in
07:20:24 <quicksilver> it needs the actual monad.
07:20:25 <Sindriava> beaky: ^
07:20:26 <magneticduck> beaky: use TH
07:20:29 <haskell504> its kinda hard to explain..
07:20:36 <beaky> wow how do i learn template haskell
07:20:43 <Sindriava> beaky: You should probably use something that's tailored for SQL then.
07:20:45 <clrnd> beaky, this? https://hackage.haskell.org/package/postgresql-simple-0.4.10.0/docs/Database-PostgreSQL-Simple-SqlQQ.html
07:20:55 <magneticduck> by doing crazy stuff like $([|1|])
07:21:04 <Sindriava> beaky: The important take away is that you *didn't want to interpolate strings*
07:21:11 <lyxia> haskell504: what does a Block represent?
07:21:15 <opqdonut> slacko1256: a lambda is always in whnf
07:21:19 <haskell504> [Maybe Int]
07:21:21 <beaky> wow ill try those quasiquotes
07:21:33 <Sindriava> beaky: Next time, try generalising your question to what you really want to do. Chances are, there's an idiomatic way to do it better in haskell ^^
07:21:39 <opqdonut> slacko1256: so the eval will be something like id.id ==> \x -> id (id x)
07:21:42 <c_wraith> slacko156: yes, it does. The whnf is approximately \x -> id (id x) 
07:21:47 <opqdonut> slacko1256: so just inlining the definition of (.)
07:22:09 <haskell504> i want the first list in all 3 list
07:22:14 <haskell504> then the second list in 3 list
07:22:15 <magneticduck> > $([|1|]) 
07:22:17 <lambdabot>  <hint>:1:1:
07:22:17 <lambdabot>      parse error on input ‘$’
07:22:17 <lambdabot>      Perhaps you intended to use TemplateHaskell
07:22:20 <magneticduck> booooo no template haskell
07:22:25 <beaky> i want to write queries
07:22:33 <haskell504> now its giving me all possible combinations of these 3 list
07:22:36 <magneticduck> > set -XTemplateHaskell
07:22:38 <lambdabot>      Not in scope: data constructor ‘XTemplateHaskell’
07:22:40 <beaky> but quasiquotes seem boiletplayer
07:22:41 <magneticduck> it was worth a shot
07:22:45 <Sindriava> quicksilver: I still don't see it
07:22:56 <beaky> or actually not
07:22:58 <magneticduck> beaky: yeah well, they are; but if you're writing enough queries, it pays off
07:23:33 <magneticduck> I mean, calling it boilerplate might be a bit strange
07:23:42 <lyxia> haskell504: perhaps you want   f s@(Sudoku x) = getColumns s ++ x ++ get3x3 s   ?
07:23:43 <slacko1256> opqdonut: oh, that seems reasonable
07:24:02 <slacko1256> the first lambda it will reach is the (.) one obvioously.
07:24:17 <slacko1256> But can optimization level mess up with which lambda it ends up?
07:24:29 <slacko1256> I guess it doesn't matter
07:24:34 <lyxia> haskell504: I can read what Block is a type synonym for, that doesn't tell me what a Block represents.
07:24:38 <opqdonut> slacko1256: the lambda from (.) will be the outer lambda
07:24:54 <opqdonut> slacko1256: but yeah optimization might already inline (.)
07:24:59 <haskell504> Block represent a block of sudoko.. 
07:25:01 * hackagebot debian 3.89 - Modules for working with the Debian package system  https://hackage.haskell.org/package/debian-3.89 (DavidFox)
07:25:08 <haskell504> it can contain 9 cells
07:25:56 <beaky> what do i do if i have variable length query parameters
07:26:23 <magneticduck> beaky: first of all, use a library
07:26:37 <magneticduck> writing queries is something lots of people have done on all kinds of absurd scales
07:27:15 <beaky> i am using sqlite.simple
07:27:43 <lyxia> haskell504: I suggested to concatenate the lists of rows, columns, and 3x3 blocks, is that not what you want?
07:28:02 <haskell504> yes 
07:28:07 <haskell504> thats what i want to do
07:28:21 <haskell504> but i dont understand the line u sent me
07:28:35 <haskell504> I'm new to haskell
07:28:41 <lyxia> haskell504: isOkay s@(Sudoku x) = getColumns s ++ x ++ get3x3 s
07:28:58 <Gurkenglas> :t transpose -- From looking at the past few hundred lines, this might be what haskell504 needs
07:28:59 <lambdabot> [[a]] -> [[a]]
07:29:42 <hexagoxel> in reactive-banana, is there a way to `mask` an event, similar to Exception's mask?
07:29:49 <haskell504> now working as i want either.
07:30:11 <haskell504> i want to concatenate my 3 list into 1
07:30:32 <haskell504> every Sudoku contains 27 blocks.
07:30:36 <lyxia> That's what my function does; yes.
07:30:44 <slacko1256> > [1,2 <> [3,4] <> [5,6]
07:30:46 <lambdabot>  <hint>:1:23:
07:30:46 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
07:30:55 <slacko1256> > [1,2 ++ [3,4] ++ [5,6]
07:30:57 <lambdabot>  <hint>:1:23:
07:30:57 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
07:31:00 <slacko1256> > [1,2] ++ [3,4] ++ [5,6]
07:31:02 <lambdabot>  [1,2,3,4,5,6]
07:31:23 <haskell504> i want to concatante these 27 into 9 list
07:32:30 <lyxia> Sorry, I find it hard to figure out what you want.
07:32:38 <haskell504> yea i know
07:32:41 <haskell504> its hard to explain
07:33:05 <haskell504> if i do it like this
07:33:38 <ImNotAKompjoetr> haskell504: You're trying to have a list for each square of nine blocks?
07:33:48 <haskell504> yes
07:35:05 <haskell504> [x+y+z| x<- [1,2,3] , y <- [1,2,3] z <- [1,2,3] now you see i want this to do like this: take 1+1+1 then 2+2+2 then 3+3+3. I dont want it to take all poisslbe combinations like 1+2+3 
07:35:24 <haskell504> is this possible?
07:35:56 <quicksilver> yes
07:35:59 <Gurkenglas> > transpose [[1,2,3], [1,2,3], [1,2,3]]
07:36:00 <Denommus> haskell504: map (\(x,y,z) -> x+y+z) $ zip3 [1, 2, 3] [1, 2, 3] [1, 2, 3]
07:36:01 <lambdabot>  [[1,1,1],[2,2,2],[3,3,3]]
07:36:32 <Denommus> > map (\(x,y,z) -> x+y+z) $ zip3 [1, 2, 3] [1, 2, 3] [1, 2, 3]
07:36:34 <lambdabot>  [3,6,9]
07:36:56 <Denommus> or even
07:37:03 <Denommus> > (\(x,y,z) -> x+y+z) <$> zip3 [1, 2, 3] [1, 2, 3] [1, 2, 3]
07:37:05 <lambdabot>  [3,6,9]
07:37:13 <lyxia> :t zipWith3
07:37:15 <lambdabot> (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
07:37:58 <haskell504> so if i want to call a function the x y z as argument
07:38:04 <haskell504> i just put it in the (\(x,y,z)?
07:38:11 <haskell504> (\(isOkay' x y z)
07:38:17 <slacko1256> is test-framework still the default framework for testing?
07:38:33 <slacko1256> iirc somebody said it was unmaintained
07:39:10 <quicksilver> haskell504: put it instead of the x+y+z part
07:39:14 <quicksilver> that's the function part
07:39:56 <haskell504> nice
07:39:58 <haskell504> thanks a lot
07:40:09 <haskell504> what does \ mean?
07:40:19 <geekosaur> slacko1256, I think Tasty is the current preferred test framework?
07:40:25 <quicksilver> > map (\[x,y,z] -> x+y+z) . transpose $ [[1,2,3],[1,2,3],[1,2,3]]
07:40:27 <lambdabot>  [3,6,9]
07:40:33 <ImNotAKompjoetr> haskell504: it's the symbol for an anonymous function
07:40:40 <quicksilver> another version using transpose and lists rather than zip and tuples
07:40:57 <slacko1256> geekosaur: it is difficult knowing what is the flavor of the month :-)
07:41:12 <geekosaur> I think that's been pretty consistent for about a year now?
07:41:27 <slacko1256> flavor of the year!
07:41:56 <Gurkenglas> quicksilver, (\[x,y,z] -> x+y+z) is sum. (Note me mentioning transpose twice above >:P)
07:42:11 <quicksilver> Gurkenglas: indeed it is
07:42:37 <haskell504> (\(x,y,z) -> isOkay' x y z) this is (a -> b) in map?
07:43:05 <quicksilver> yes, haskell504 
07:43:06 <Gurkenglas> yep
07:43:09 <haskell504> ok
07:43:17 <haskell504> very cleaver 
07:45:16 <haskell504> Why do i need that \?
07:45:26 <haskell504> thats the only thing i dont understand..
07:45:28 <dzhus> Is hp2ps on Hackage somewhere? I am on Mac OS X with GHC installed using stack, how do I get hp2ps?
07:45:43 <Gurkenglas> It's used to define a function without giving it a name
07:46:07 <Gurkenglas> > (\x -> x + 1) 3
07:46:08 <lambdabot>  4
07:46:27 <cocreature> dzhus: stack exec hp2ps doesn't do the trick?
07:46:55 <haskell504> (x,y,z) is a tuple because zip3 return is at a tuple?
07:47:02 <quicksilver> yes exactly
07:47:15 <Gurkenglas> The symbol is derived from the greek letter lambda, which is used in the theoretical notation of programming in ye olden times
07:47:15 <quicksilver> (zip3 return is a *list* of tuples)
07:47:27 <haskell504> yea a list of tuples
07:47:29 <cocreature> dzhus: it is in ~/.stack/programs/x86_64-linux/ghc-7.10.2/bin/hp2ps on linux, I assume it's similar on os x
07:47:43 <haskell504> but that \... I'm not sure why it need to be there...
07:48:21 <Gurkenglas> What would you rather have your code look like?
07:48:41 <haskell504> map ((x,y,z) -> isOkay' x y z) $ zip3 x (getColumns(Sudoku x)) (get3x3(Sudoku x))
07:48:49 <haskell504> i would like to have it like this..
07:48:54 <quicksilver> haskell504: that's just the syntax of the language
07:48:54 <haskell504> but i need that \..
07:48:59 <quicksilver> fair enough, but that isn't how haskell looks
07:49:03 <dzhus> cocreature: yep, right, thanks
07:49:33 <haskell504> :t map (a -> b) -> [a] -> [b]
07:49:34 <lambdabot> parse error on input ‘->’
07:49:38 <haskell504> what is a in this case?
07:49:42 <Axman6> ::
07:49:42 <haskell504> "\”?
07:49:44 <quicksilver> (Int,Int,Int)
07:49:50 <haskell504> hm..
07:49:53 <quicksilver> your 3-tuples of ints
07:50:02 * hackagebot diagrams-rasterific 1.3.1.4 - Rasterific backend for diagrams.  https://hackage.haskell.org/package/diagrams-rasterific-1.3.1.4 (BrentYorgey)
07:50:03 <haskell504> and b is my function
07:50:05 <haskell504> isOkay'
07:50:09 <Axman6> no
07:50:16 <quicksilver> b is whatever isOkary' x y z produces
07:50:18 <Axman6> b is what isOK returns if applied to three ints
07:50:19 <quicksilver> Bool perhaps?
07:50:23 <quicksilver> I'm only guessing
07:50:30 <haskell504> ok
07:50:38 <haskell504> so why do i need the "\"?...
07:50:42 <haskell504> it doesn't do anything
07:50:47 <quicksilver> it is the syntax of the language
07:50:52 <quicksilver> that is how you write functions
07:51:03 <haskell504> yes but if i write this functrion
07:51:03 <quicksilver> I can imagine a programming language where (x -> x+1) is valid syntax
07:51:08 <quicksilver> but in haskell you write it (\x -> x+1)
07:51:10 <Axman6> it tells you that you are creating a lambda function
07:51:10 <haskell504>  map reverse ["abc","cda","1234"]
07:51:13 <haskell504> i dont need the \..
07:51:25 <Axman6> IIRC python uses the word "lambda" to do the same thing
07:51:31 <quicksilver> haskell504: because in that example you are not defining any anonymous functions.
07:52:10 <haskell504> so every time i will create my own function and now a function that exist in haskell then i need to use the \¿
07:52:10 <haskell504> ?
07:53:07 <Axman6> > map (\n -> 4*n+7*n^2) [1..10] -- I just made an anonymous function (a function without a name)
07:53:09 <lambdabot>  [11,36,75,128,195,276,371,480,603,740]
07:53:23 <quicksilver> haskell504: you can also created named function
07:53:27 <quicksilver> myFun a = a + 1
07:53:31 <magneticduck> Axman6: you MONSTER
07:53:39 <haskell504> but i already have a function..
07:53:42 <quicksilver> but it's convenient to be able to create small ones without giving them names.
07:53:44 <haskell504> map (\(x,y,z) -> isOkay' x y z) $ zip3 x (getColumns(Sudoku x)) (get3x3(Sudoku x))
07:53:48 <quicksilver> or somethings big ones.
07:53:51 <haskell504> isOkay' x y z? 
07:53:56 <haskell504> isn't that my function?
07:54:03 <Axman6> > let f n = 4*n+7*n^2 in map f [1..10]
07:54:05 <lambdabot>  [11,36,75,128,195,276,371,480,603,740]
07:54:21 <geekosaur> haskell504, isOkay' would be, but you need to unpack the parameters because it does not take atuple
07:54:29 <geekosaur> *that* requires an anonymous function
07:54:35 <haskell504> oh
07:54:38 <Axman6> haskell504: but your function doesn't accept a tuple of Ints, it is applied to three ints individually
07:54:46 <fryguybob> geekosaur: Or uncurry3
07:54:55 <geekosaur> yeh, was debating mentioning that
07:55:08 <Axman6> haskell504: remember that foo x y = ... and foo (x,y) = ... are not the same thing
07:55:17 <haskell504> yea..
07:55:25 <geekosaur> given an uncurry3 it would have been: map (uncurry3 isOkay') ...
07:55:36 <haskell504> but zip3 will return [(1,2,3), (1,2,3) (1,2,3)]
07:55:55 <geekosaur> if you can specify it without parameters then you don't need the \params -> value thing
07:56:05 <haskell504> then \(x,y,z) -> isOka' x y z
07:56:11 <haskell504> will split the tuple into 3 ints?
07:56:12 <Axman6> :t zipWith3
07:56:14 <lambdabot> (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
07:56:22 <geekosaur> but if you need to get at / manipulate the parameters, or modify the result, you need the lambda
07:56:25 <Axman6> maybe that's useful to you
07:56:35 <Axman6> haskell504: yes
07:57:00 <haskell504> Pattern syntax in expression context: (x, y, z) -> isOkay' x y z
07:57:08 <haskell504> so thats why i got that one
07:57:15 <haskell504> because i tried to send a tuple to my function?
07:57:18 <haskell504> isOkay'
07:57:21 <haskell504> instead of 3 ints
07:57:24 <geekosaur> because you left out that \ you dislike so much
07:57:52 <geekosaur> you need the \ so it knows that it should expect a pattern instead of an expression
07:58:10 <haskell504> but if my function would take a tuple of (a,b,c)
07:58:14 <haskell504> i wouldn't need the \?
07:58:27 <Axman6> correct
07:58:30 <haskell504> nice
07:58:31 <haskell504> thanks a lot
07:58:33 <geekosaur> if it had been defined that way, yes, because you would not need to use a pattern to break the tuple apart
07:58:45 <haskell504> so all that \ does it to pattern my function?
07:58:49 <haskell504> like pattern matching 
07:58:52 <quicksilver> no
07:58:54 <haskell504> ...
07:58:57 <beaky> hello
07:59:00 <quicksilver> what \ does is let you write an anonyomous function
07:59:02 <beaky> are there alternatives to persistent 
07:59:12 <beaky> for db access
07:59:14 <Axman6> > (\x y -> x^2+y) 4 6
07:59:14 <quicksilver> one possible anonymous function is breaking your tuples apart
07:59:15 <lambdabot>  22
07:59:21 <quicksilver> but you could have given that a name if you'd wanted
07:59:26 <liste> beaky opaleye, *-simple, hdbc...
07:59:26 <Axman6> > (\x -> \y -> x^2+y) 4 6
07:59:28 <lambdabot>  22
07:59:39 <Intolerable> how do i uninstall a specific version of GHC?
07:59:40 <quicksilver> runIsOkayOnTuple (x,y,z) = isOkay' x y z
07:59:49 <quicksilver> haskell504: ^^ you could have defined that
07:59:50 <quicksilver> and then
07:59:56 <beaky> are there any review sof all of them
07:59:59 <beaky> to see whcih ist he best
08:00:01 <quicksilver> map runIsOkayOnTuple $ zip3 [....]
08:00:07 <Intolerable> i want to remove 7.10.1, installed with the binary package on OS X
08:00:17 <clrnd> beaky, PostgreSQL.Simple
08:00:18 <beaky> is there something like yesql
08:00:25 <beaky> but for haskell
08:00:31 <Axman6> what is yesql?
08:00:36 <beaky> it is a clojreu lib for sql
08:00:39 <beaky> clojrue*
08:00:43 <haskell504> ok think i got it
08:00:47 <Axman6> what features does it have
08:00:49 <haskell504> i need to read more about that
08:00:52 <liste> beaky do you know esqueleto?
08:01:00 <beaky> yes
08:01:09 <beaky> its like linq for haskell
08:01:27 <beaky> (i think more like a sql ast lib actually)
08:01:30 <liste> not whole Haskell, just Persistent
08:01:36 <Axman6> linq is like haskell for C#
08:01:51 <Axman6> (because linq was added to C# by people who knew Haskell)
08:02:04 <liste> opaleye is type-safe and high-level, postgresql-simple is medium-level
08:02:49 <liste> then there's HaskellDB
08:03:21 <liste> but I had problems finding decent tutorials for it in the past
08:03:35 <liste> maybe someone has written one after that
08:10:06 <Gurkenglas> I've just done cabal sandbox init, cabal install ghc-mod. How do I get an executable of ghc-mod so I can make SublimeHaskell use it?
08:10:34 <clrnd> Gurkenglas, that already has, it's in .cabal-sandbox/something/.. in theory
08:11:21 <Gurkenglas> Gah, there was a hidden folder
08:11:35 <geekosaur> you should be able to copy .cabal-sandbox/bin/ghc-mod somewhere useful
08:14:16 <hexagoxel> or just use `cabal install --bindir=$USEFULBINDIR --datadir=$USEFULDATADIR`
08:14:33 <hexagoxel> more reliable than copying the executable.
08:15:07 <hexagoxel> (dirs might be .cabal/bin and .cabal/share)
08:15:27 <hexagoxel> (relative to $HOME, that is.)
08:15:34 <Gurkenglas> I'll just make SublimeHaskell use the C:\Users\Gurkenglas\Desktop\Haskell\ghcmod\.cabal-sandbox\bin folder
08:16:51 <Denommus> anyone managed to use stack-ide with Emacs?
08:17:11 <Gurkenglas> Aww that didn't work. Do I have to do more than '"add_to_PATH": ["C:/Users/Gurkenglas/Desktop/Haskell/ghcmod/.cabal-sandbox/bin"],' in the SublimeHaskell settings?
08:20:04 * hackagebot HerbiePlugin 0.1.0.0 - automatically improve your code's numeric stability  https://hackage.haskell.org/package/HerbiePlugin-0.1.0.0 (MikeIzbicki)
08:20:27 <geekosaur> hope the hackage page says more than the email did...
08:21:38 <Gurkenglas> Is it just me or has there been a rising focus on programming-assisting packages? I approve.
08:22:09 <Denommus> Gurkenglas: yeah, I guess it's related to FPComplete's work
08:28:44 <Denommus> I DID IT
08:28:44 <Denommus> whoa
08:28:49 <Denommus> it seems as good as merlin!
08:33:42 <Gurkenglas> Does someone have a vm image up for grabs with all of the haskell workflow stuff setup?
08:33:49 <erisco> anyone use rx?
08:34:09 <Gurkenglas> *set up
08:35:33 <ocramz> hi all!
08:35:43 <clrnd> sure, hi
08:36:56 <timthelion> Just came across a mutability bug gem.
08:37:12 <timthelion> Taking the length of an iterator in python mutates the iterator: https://github.com/subuser-security/subuser/commit/af9078195bb3fd3dc4fc052f68394bbbb914ac05
08:37:37 <ocramz> is there a standard way of mapping over a Storable array? I was thinking something along the lines of `peekArray` -> MVector -> `pokeArray` or similar
08:38:27 <ocramz> or copying into a mutable array, unsafeThaw, map over the MVector, unsafeFreeze
08:39:01 <nobos> would anyone care to review my Haskell Servant code?
08:39:07 <nobos> https://gist.github.com/ToJans/73f3ba4ac62df65ce755
08:41:46 <bz> timthelion: what's the type of installedImageLineage?
08:46:25 <alpounet> nobos: you'll have more luck on the #servant channel, but shoot the url I can take a quick look :)
08:47:03 <nobos> alpounet: I'll join there too; this is the url: https://gist.github.com/ToJans/73f3ba4ac62df65ce755
08:47:50 <timthelion> bz: it is a list, but image source lineage is a reversed list(aka an iterator)
08:48:13 <nobos> alpounet: I'm especially looking for feedback regarding beginner mistakes...
08:48:26 <timthelion> bz: so by taking a list and using the reversed function on it, in python, you get something that running a for loop over "iterates" and therefor destroyes :D
08:49:36 <timthelion> bz: I think it is an intersting example, in that haskell uses laziness, but iterating over lists doesn't destroy them. In python, lazy lists(called iterators) are destroyed by being iterated.
08:50:35 <lamefun> Are there guidelines on when to use fmap and when to use <$> or should I just use whatever looks better in my eyes?
08:50:59 <timthelion> lamefun: use whatever looks beter
08:52:10 <liste> imo <$> is better when you need infix, and fmap is better when you need prefix
08:52:22 <clrnd> (<$>) nah bro
08:52:31 <suppi> `fmap`
08:52:55 <suppi> if you happen to write fmap f $ some something something
08:53:14 <suppi> consider replacing it with f <$> some something something
08:54:09 <clrnd> > ((+1) <$>) [1,2,3]
08:54:10 <lambdabot>  [2,3,4]
09:00:39 <beaky> i love parsec
09:08:13 <KrzyStar> @pl (\a b c d -> (a,b,c,d))
09:08:13 <lambdabot> (,,,)
09:08:13 <magicman> timthelion: Doesn't list(iterator) then also destroy the iterator in the same way that len(iterator) does?
09:10:45 <timthelion> magicman: yep
09:15:42 <nshepperd> sometimes I write 'fmap f <$> something something'
09:15:54 <nshepperd> i'm a monster
09:17:19 <derdon> is there an infix operator for ``flip (<$>)``?
09:17:46 <slomo> derdon: <&>
09:17:55 <clrnd> :t (<&>)
09:17:56 <lambdabot> Functor f => f a -> (a -> b) -> f b
09:18:08 <clrnd> o.O
09:18:45 <derdon> which module? hoogle doesn't yield any results
09:18:59 <derdon> :hoogle (<&>)
09:20:07 * hackagebot diagrams-postscript 1.3.0.3 - Postscript backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-postscript-1.3.0.3 (BrentYorgey)
09:20:28 <nshepperd> oh cool, that's yoneda
09:21:16 <quicksilver> derdon: it's somewhere in Control.Lens
09:21:56 <derdon> quicksilver: ah, so not part of the standard library
09:21:57 <quicksilver> derdon: http://hayoo.fh-wedel.de/?query=%3C%26%3E
09:22:01 <quicksilver> no
09:22:36 <quicksilver> > [1,2,3] <&> (*2)
09:22:37 <lambdabot>  [2,4,6]
09:22:41 <nshepperd> f a ~= forall b. (a -> b) -> f b
09:23:30 <nshepperd> so much sense
09:23:51 <quicksilver> very embedded so much sense WOW yoneda
09:24:04 <quicksilver> dogegory theory in action
09:25:59 <dzhus`> in what format do I give cost centre names to -hc RTS option?
09:27:26 <quicksilver> you don't give anything to the option
09:27:39 <quicksilver> oh do you mean how do you embed them in your code so that -hc can see them?
09:30:07 * hackagebot tls 1.3.3 - TLS/SSL protocol native implementation (Server and Client)  https://hackage.haskell.org/package/tls-1.3.3 (VincentHanquez)
09:30:10 * hackagebot tls-debug 0.4.1 - Set of programs for TLS testing and debugging  https://hackage.haskell.org/package/tls-debug-0.4.1 (VincentHanquez)
09:30:53 <dzhus`> quicksilver: you do when you want to "restrict the profile to closures produced by cost-centre stacks with one of the specified cost centres at the top"
09:31:22 <quicksilver> oh I didn; tknow about that :)
09:45:08 * hackagebot diagrams-builder 0.7.2.0 - hint-based build service for the diagrams graphics EDSL.  https://hackage.haskell.org/package/diagrams-builder-0.7.2.0 (BrentYorgey)
09:45:24 <siddhu_> Is it possible to invoke a system command such as "COMPILER=gcc make" from System.Process (callCommand) ?
09:46:03 <quicksilver> that's a shell command siddhu_ 
09:46:12 <quicksilver> that is, you need to use your shell to interpet COMPILER=gcc
09:46:26 <quicksilver> (alghouth if that's all you need to do you could just tweak the environment yourself)
09:47:17 <quicksilver> but callCommand is supposed to run via the shell so that should work
09:47:20 <quicksilver> according to the docs
09:47:23 <siddhu_> using callCommand results in 'COMPILER' is not recognized as an internal or external command
09:47:36 <siddhu_> the first argument seems to be used as the program name
09:48:09 <quicksilver> works for me siddhu_ 
09:48:12 <quicksilver> what OS are you on?
09:48:33 <siddhu_> Windows... I hope its not a Cygwin thing.
09:49:00 <quicksilver> I suspect it's a cygwin thing
09:49:06 <quicksilver> I can't help you I'm afraid :(
09:49:42 <siddhu_> ah, I guess I could just modify all the Makefiles instead. Thanks quicksilver !
09:49:46 <fryguybob> siddhu_: You can specify the environment in createProcess
09:49:56 <Fuuzetsu> barrucadu: didn't know you contributed to lainchan
09:50:03 <cmperez> exit
09:51:49 <barrucadu> Fuuzetsu: Yup, I'm one of the admins
09:52:46 <Fuuzetsu> I was thinking of starring it but I don't want to be seen next to PHP repos ;)
09:53:24 <Fuuzetsu> also dejafu seems interesting
09:54:21 <barrucadu> Thanks! I need to read some papers on testing relaxed memory models, so it's more widely applicable
09:54:50 <siddhu_> fryguybob: will try that out. Thanks!
09:55:44 <Fuuzetsu> barrucadu: release notes mention a peresentation at Haskell Symp, is there a video from that available somewhere?
09:58:03 <barrucadu> Not yet… it seems that whoever was recording my talk and the one after didn't stop the recording between the two, so it's just one video file which needs to be split, which Iavor doesn't seem to have got around to yet
09:58:16 <barrucadu> Shame, as all the other videos have been up for a little while now
09:59:06 <barrucadu> However an email has confirmed that the recording does exist and will be up at some point
09:59:15 <Denommus> is there a FRP library like reactive-banana that works better with programs where I have the control over the loops?
09:59:21 <Fuuzetsu> Do you have the file up somewhere? I could just like, watch half of the video
09:59:32 <barrucadu> I don't, no
09:59:37 <Fuuzetsu> oks
10:05:16 <ocramz> could someone tell me what does this do? `inlinePerformIO (IO m) = case m realWorld# of (# _, r #) -> r`
10:05:38 <ocramz> it's within HMatrix
10:06:03 <johnw> it looks like it's executing the IO action and giving you back the result
10:06:09 <Fuuzetsu> ocramz: why do you need to know that, it uses compiler internals
10:06:25 <Denommus> ocramz: it unsafely executes an IO action. Don't do that
10:07:22 <ocramz> I was just curious to know its effect
10:07:43 <Fuuzetsu> then the type should have told you what it is
10:08:12 <ocramz> IO a -> a , like unsafePerformIO
10:08:35 <ocramz> I was wondering about the magic hashes
10:08:48 <Fuuzetsu> it's an unpacked tuple
10:09:32 <Fuuzetsu> https://downloads.haskell.org/~ghc/7.10.2/docs/html/users_guide/primitives.html
10:09:38 <ocramz> Fuuzetsu: ok thanks
10:09:50 <Fuuzetsu> unboxed tuple rather
10:09:53 <athan> Is there a `MonadWriter a (a,)` instance anywhere? :\
10:10:42 <athan> mer, only WriterT :(
10:15:10 * hackagebot diagrams-haddock 0.3.0.7 - Preprocessor for embedding diagrams in Haddock documentation  https://hackage.haskell.org/package/diagrams-haddock-0.3.0.7 (BrentYorgey)
10:15:12 * hackagebot syb 0.6 - Scrap Your Boilerplate  https://hackage.haskell.org/package/syb-0.6 (JosePedroMagalhaes)
10:18:51 <Cale> ocramz: It's like unsafePerformIO, but it'll be inlined by the compiler, making it even unsafer :)
10:23:11 <derdon> hello, I'm coming from #haskell-beginners. I found this weird bug that the statement ``let xs = [(+2), (-10)]`` doesn't yield an error even though the types differ (function vs. number)
10:23:25 <bennofs> ocramz: wasn't inlinePerformIO renamed to accursedUnutterablePerformIO
10:23:48 <derdon> using GHC version 7.8.4 on Debian. ``uname -a`` says "Linux lenovot540p 4.1.0-1-amd64 #1 SMP Debian 4.1.3-1 (2015-08-03) x86_64 GNU/Linux"
10:24:12 <KaneTW> :t [(+2), (-10)]
10:24:13 <lambdabot> (Num a, Num (a -> a)) => [a -> a]
10:24:24 <KaneTW> there's your answer
10:24:31 <mniip> derdon, a function can be a number
10:24:33 <mniip> :t 1
10:24:35 <lambdabot> Num a => a
10:24:42 <mniip> nothing is preventing 'a' from being 'x -> y'
10:25:10 * hackagebot diagrams-html5 1.3.0.3 - HTML5 canvas backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-html5-1.3.0.3 (BrentYorgey)
10:25:12 * hackagebot happstack-authenticate 2.2.0 - Happstack Authentication Library  https://hackage.haskell.org/package/happstack-authenticate-2.2.0 (JeremyShaw)
10:25:52 <derdon> mniip: how can a number be a binary function at the same time?
10:26:17 <mniip> unary function
10:26:23 <derdon> I get how every value can be seen as a function getting no arguments.
10:26:33 <Denommus> so
10:26:33 <MarcelineVQ> mniip: Without FlexibleContexts isn't that an error though?
10:26:36 <y> that is twisted
10:26:40 <mniip> MarcelineVQ, no, not at all
10:26:48 <y> MarcelineVQ: why would it be?
10:26:54 <derdon> but (a -> a) is a function getting one argument and returning one
10:26:56 <mniip> Num ((->) a a)
10:27:02 <mniip> derdon, that's unary
10:27:19 <clrnd> derdon, "being a number" is just being a member of the Num typeclass
10:27:24 <mniip> derdon, you know how we can define an instance of Num for many different types
10:27:32 <Denommus> is there a FRP library like reactive-banana, but where I feed input events values inside a loop instead of creating them with a callback?
10:27:37 <mniip> nothing prevents us from defining an instance for functions
10:27:42 <KaneTW> derdon: a literal like -10 has type Num a => a
10:27:44 <MarcelineVQ> y: because when​ I type it in ghci I get: [(*2),(-10)] <interactive>:5:1:    Non type-variable argument in the constraint: Num (a -> a)    (Use FlexibleContexts to permit this)    When checking that ‘it’ has the inferred type   it :: forall a. (Num a, Num (a -> a)) => [a -> a]
10:28:28 <y> MarcelineVQ: you need flexiblecontexts for that type signature, not for creating a num instance
10:28:32 <mniip> MarcelineVQ, that's due to an implicit a ~ a'
10:28:34 <mniip> or something
10:28:46 <derdon> mniip: (->) is an instance of Num? How is it defined?
10:28:46 <y> which would get 'reduced' when used there too
10:28:53 <mniip> derdon, it's not
10:28:54 <mniip> but it could be
10:29:35 <mniip> :t (id ==)
10:29:36 <lambdabot> Eq (a -> a) => (a -> a) -> Bool
10:29:37 <geekosaur> derdon, the compiler is not allowed to assume that nobody will ever create such a thing
10:29:50 <geekosaur> and occaisonally people *do* create one
10:29:51 <mniip> just because it doesn't have an instance, doesn't mean we can't create such a value
10:30:00 <mniip> it only becomes an issue when we get rid of the constraint
10:30:46 <derdon> Ahhh, I think I'm getting closer. So not every single value of xs has to be of the same type but they all have to be the instance of the same type class
10:30:48 <derdon> right?
10:31:01 <mniip> no
10:31:04 <derdon> :(
10:31:19 <Shockk> derdon: in this code:  let xs = [(+2), (-10)]
10:31:20 <ReinH> :t (-10)
10:31:22 <lambdabot> Num a => a
10:31:30 <mniip> derdon, you can create a value before you instantiate the class
10:31:42 <mniip> like hmm
10:31:47 <y> @type [ (+2) :: Int -> Int , (-10) :: Int ] 
10:31:47 <Shockk> hm I was about to say something and now I don't know after ReinH's :t
10:31:48 <lambdabot>     Couldn't match expected type ‘Int -> Int’ with actual type ‘Int’
10:31:48 <lambdabot>     In the expression: (- 10) :: Int
10:31:48 <lambdabot>     In the expression: [(+ 2) :: Int -> Int, (- 10) :: Int]
10:31:51 <joco42_> what is the difference between cabal's exposed-modules vs other-modules ?
10:31:57 <mniip> @let data X = X; foobar = (X ==)
10:31:58 <lambdabot>  .L.hs:155:13:
10:31:59 <lambdabot>      No instance for (Eq X) arising from a use of ‘==’
10:31:59 <lambdabot>      In the expression: (X ==)
10:32:05 <ReinH> derdon: number literals are polymorphic, so if functions are instances of Num then (-10) can be a function
10:32:09 <mniip> aww monomorphism restriction
10:32:23 <y> mniip: wut? 
10:32:27 <mniip> or
10:32:29 <mniip> err nevermind
10:32:30 <mniip> I'm dumb
10:32:34 <Denommus> joco42_: exposed modules are exposed for the users of the library. Other modules are only internal, users can't use them
10:32:38 <Shockk> joco42_: exposed-modules are ones which are exported as part of the library's API, so projects using the library can import them
10:32:40 <derdon> ReinH: are functions instances of Num or are they not?
10:32:46 <ReinH> derdon: no, but they could be
10:32:56 <Shockk> joco42_: other-modules are still linked in with the library but not exposed
10:33:03 <mniip> @let data X a = X; foobar = (X ==)
10:33:04 <lambdabot>  Defined.
10:33:06 <mniip> :t foobar
10:33:07 <lambdabot> forall (k :: BOX) (a :: k). Eq (X a) => X a -> Bool
10:33:10 <joco42_> Denommus, Shockk, thanks ! 
10:33:27 <mniip> even though X is not an instance of Eq, foobar is a value in case it ever becomes one
10:33:31 <ReinH> s/if functions are/if functions can be
10:33:33 <derdon> ReinH: so (-10) is not a function but (+2) is. are (-10) and (+2) of the same type or are they not?
10:33:49 <Shockk> :t [(+2), (-10)]
10:33:51 <lambdabot> (Num a, Num (a -> a)) => [a -> a]
10:33:54 <mniip> (-10) is fromInteger negative_integer_ten
10:34:03 <mniip> (+2) is (+) (fromInteger integer_two)
10:34:04 <ReinH> In [(+2), (-10)], both must be functions
10:34:09 <ReinH> since lists are homogeneous
10:34:31 <ReinH> so the type of (-10) must unify with the type of (+2)
10:34:33 <Shockk> with (+2) which is a function, it's unknown what type will be applied to that function yet
10:34:36 <MarcelineVQ> Does anyone know what's different in 7.10.1 vs derdon's 7.8.4 that causes ghci to make that same statement [(*2),(-10)] a FlexibleContexts error in mine?
10:34:44 <mniip> derdon, really, this is a very complicated clash of multiple unclear features of the languages
10:35:03 <ReinH> :t (+2)
10:35:04 <lambdabot> Num a => a -> a
10:35:09 <ReinH> :t (-10)
10:35:10 <mniip> MarcelineVQ, I'm guessing proper ~ support
10:35:10 <lambdabot> Num a => a
10:35:15 <joco42_> what does it mean when cabal says after "cabal build" that : "in place registering ..." ?
10:35:42 <derdon> mniip: where "unclear" means "undefined"?
10:35:44 <joco42_> where does the built package go ?
10:35:51 <ARM9> (Num a, Num (a -> a)) what's the Num in Num (a -> a) for?
10:35:58 <ReinH> So if they are to unify, then if (+2) :: Num b => b -> b and (-10) :: Num a => a, then a must be Num b => b -> b, which must itself be an instance of Num
10:36:01 <MarcelineVQ> mniip: Could be, 7.8.4 does have -XFlexibleConstraints as a flag, but maybe it doesn't apply it as broadly
10:36:10 <geekosaur> joco42, it's somewhere under the dist subdirectory
10:36:15 <geekosaur> which is a staging area
10:36:29 <ReinH> ARM9: it's saying that (a -> a) must be an instance of Num
10:36:50 <Shockk> ARM9: that means there needs to be an instance of Num for (a -> a), so whatever value you do apply to that (+10), there needs to be a Num instance for thetype -> thetype
10:37:01 <geekosaur> MarcelineVQ, ghc used to allow inferred types to do thinsg that you couldn't type explicitly without enabling extensions
10:37:16 <geekosaur> ghc 7.10 is pedantic; it no longer infers types that would require an extension
10:37:25 <MarcelineVQ> Good to know
10:37:30 <ARM9> but a is already instance of Num from the previous type no?
10:37:37 <joco42_> geekosaur: ok, thanks
10:37:37 <ReinH> derdon: no, it is well defined
10:37:41 <joco42_> i have a look
10:37:48 <derdon> ReinH: I understand that. So because these values are in the same list, (-10) will behave as a function in this list?
10:37:57 <Shockk> ARM9: (a -> a) is a different type to (a)
10:38:01 <ReinH> Yes, there must be some way for (-10) to have the same type as (+2)
10:38:13 <ReinH> luckily, because of typeclass polymorphism, there is
10:38:19 <ggole> Wow, that's quite the convoluted example
10:39:19 <ReinH> :t (-10) `asTypeOf` (+2)
10:39:20 <lambdabot> (Num a, Num (a -> a)) => a -> a
10:39:24 <ggole> Sections and the -x notation don't quite mix well, I suppose.
10:39:31 <ReinH> So that is the type it unifies to
10:39:40 <ReinH> a and a -> a must both be instances of Num
10:39:56 <Shockk> y: in case you might be interested; last night I got member and notMember implemented for the PolyMap I'm writing :D
10:40:10 * hackagebot BlogLiterately 0.8.1.2 - A tool for posting Haskelly articles to blogs  https://hackage.haskell.org/package/BlogLiterately-0.8.1.2 (BrentYorgey)
10:40:12 <joco42_> say I create a module named "ModuleA.ModuleB" then what determines the visibility from ModuleC vs ModuleA ? are some kind of special visibility rules for modules ? similar to package level visibility in Java - or something like that ?
10:40:12 * hackagebot clckwrks 0.23.10 - A secure, reliable content management system (CMS) and blogging platform  https://hackage.haskell.org/package/clckwrks-0.23.10 (JeremyShaw)
10:40:27 <y> Shockk: nice, code? 
10:40:35 <derdon> ReinH: ah cool. haven't heard of asTypeOf before, looks useful
10:40:41 <ReinH> ggole: like mniip said, it's an unfortunate combination of a couple language features that are confusing when combined
10:40:44 <Shockk> I'm bad at remembering to commit, one sec
10:40:46 <joco42_> or is it just imported vs not imported modules and that's it ?
10:41:05 <joco42_> do these module namespaces means some special visibility ?
10:41:37 <Shockk> y: https://github.com/shockkolate/hs-polymap/blob/master/src/Data/PolyMap.hs
10:41:45 <ARM9> so what differentiates (Num a, Num (a -> a)) => [a -> a] from Num a => [a -> a]
10:41:46 <joco42_> say that ModuleA can always see all the functions in ModuleA.ModuleB ?
10:42:03 <ReinH> ARM9: the additional constraint Num (a -> a)
10:42:03 <joco42_> regardless what ModuleB exposed?
10:42:13 <ARM9> :t [(+2), (+5)]
10:42:14 <joco42_> is there such a thing?
10:42:14 <lambdabot> Num a => [a -> a]
10:42:31 <joco42_> i am asking this because i am coming from java/scala
10:42:33 <ARM9> ReinH I can see that, but what function does it serve
10:42:43 <ReinH> ARM9: to ensure that both a and a -> a must be instance of Num
10:42:54 <ReinH> which is what must be true for the types to unify
10:42:59 <joco42_> and i am trying to figure out what is the best way to organize code... in haskell
10:43:00 <indiagreen> joco42_: no, it's simply “module names can have a dot in them”
10:43:11 <ARM9> but how can a -> a not be instance of Num when a is already instance of Num?
10:43:13 <joco42_> i see, that's it ?
10:43:16 <ReinH> Num a => a -> a says that a must be a Num instance, but says nothing about a -> a
10:43:17 <Cale> ARM9: Num (a -> a) requires an instance of Num for functions, which isn't normally present, so you'd have to import or add one yourself.
10:43:27 <joco42_> indiagreen: no special magic ?
10:43:38 <ReinH> ARM9: nothing implies that a -> a is an instance of Num if a is
10:43:44 <indiagreen> joco42_: nope
10:43:47 <aweinstock> ARM9: if you see Num (a -> a), and you're not trying to do typeclass-level hackery, it probably means you're making an arity error
10:43:51 <joco42_> indiagreen: cool
10:43:55 <joco42_> i like simple
10:43:57 <ARM9> I see, I guess I need to dig deeper in the type system to fully grasp this distinction
10:43:59 <ReinH> Int is an instance of Num. Int -> Int isn't.
10:43:59 <aweinstock> :t (\x y z -> (+) x y z)
10:44:01 <lambdabot> Num (t -> r) => (t -> r) -> (t -> r) -> t -> r
10:44:01 <ReinH> (by default)
10:44:10 <indiagreen> joco42_: the only thing GHC does is checking for your module in “A/B/C.hs” if it's called A.B.C
10:44:21 <joco42_> right
10:44:28 <joco42_> that is nice and simple
10:44:30 <Cale> ARM9: We can add an instance of Num for functions to show off what it would mean
10:44:49 <Shockk> y: this is how I use member right now https://github.com/shockkolate/hs-polymap/blob/master/examples/basic/Main.hs#L9
10:44:52 <joco42_> indiagreen: but it can be located in the main directory too ?
10:44:59 <aweinstock> ARM9: there's a sensible instance Num a => Num (a -> a), where f + g = \x -> f x + g x (and so on)
10:45:14 <indiagreen> joco42_: yep, and then the file should be named A.B.C.hs
10:45:17 <Shockk> but I'll probably write helper type aliases like First Second Third 
10:45:24 <indiagreen> joco42_: actually, I think even A/B.C.hs is permitted
10:45:36 <joco42_> indiagreen: cool, good to know, thanks
10:45:36 <aweinstock> ARM9: (I think that's not typically done because Num has a Eq constraint, and equality isn't decidable on functions)
10:45:51 <aweinstock> (so you'd need hacks to do that)
10:45:54 <Cale> @let instance Num b => Num (a -> b) where { (f + g) x = f x + g x; (f * g) x = f x * g x; fromInteger n x = fromInteger n; negate f x = negate (f x); abs f x = abs (f x); signum f x = signum (f x) }
10:45:56 <lambdabot>  Defined.
10:46:06 <Cale> > (sin + cos) 1
10:46:10 <lambdabot>  1.3817732906760363
10:46:21 <ReinH> (it's basically just lifted using the Applicative ((->) r) instance)
10:46:40 <Cale> > map (1 + cos + cos^2) [0..10]
10:46:41 <aweinstock> > (sin*sin + cos*cos) 1
10:46:42 <lambdabot>  [3.0,1.8322288875945687,0.7570313530210517,0.9900926467247375,0.773606362232...
10:46:43 <lambdabot>  1.0
10:47:00 <aweinstock> > map (sin*sin + cos*cos) [1..10]
10:47:02 <lambdabot>  [1.0,1.0,0.9999999999999999,1.0,0.9999999999999999,0.9999999999999999,0.9999...
10:47:28 <ReinH> floating points
10:47:39 <Cale> ARM9: So this lets you do arithmetic with functions
10:48:01 <Cale> ARM9: Something which is usually disallowed only because the errors that result can be a bit confusing...
10:48:26 <Cale> Numerical constants also get interpreted as constant functions
10:48:45 <Cale> So if you accidentally write 2 x where you meant to write 2 * x, instead of an error, you'll just get 2.
10:49:00 <Shockk> not type alias, sorry, I meant actual value of the correct Proxy type
10:49:01 <Cale> > 2 6
10:49:04 <lambdabot>  2
10:49:11 <ReinH> This is actually more useful than it seems.
10:49:24 <ReinH> Unless it seems surprisingly useful, in which case it is as useful as it seems.
10:49:33 <Cale> Yeah, once you're doing arithmetic with functions, you probably want to be able to use constants as constant functions
10:49:44 <Cale> Being able to write 2 * f is useful
10:49:52 <ReinH> If you're translating math equations into Haskell, it makes it much easier
10:50:22 <Cale> ARM9: Is that any clearer?
10:53:10 <ggole> Another question: why does :t [1..10] induce Enum t? Isn't Num enough to add one to something?
10:53:36 <ggole> Or is it about knowing when to stop?
10:54:01 <Shockk> does GHC have a max depth at the type level or something?
10:54:22 <benzrf> ggole: [1..10] desugars as enumFromTo 1 10
10:54:24 <benzrf> or something along those lines
10:54:25 <eikke> ggole: how can you be sure '+ 1' is the correct 'next' function in the enumeration?
10:54:26 <c_wraith> > [False..] 
10:54:28 <lambdabot>  <hint>:1:9: parse error on input ‘]’
10:54:30 <geekosaur> ggole, because it is not "adding one to something", it is using "succ". not all things you can "succ" make sense to "add one to"
10:54:38 <geekosaur> > succ False
10:54:39 <benzrf> > [False ..] -- ftfy
10:54:40 <lambdabot>  True
10:54:41 <lambdabot>  [False,True]
10:54:44 <humanoyd_> When writing an application, do you prefix your app-specific modules? I.e. do you write "import MyApp.Util" or do you prefer "import Util"?
10:54:44 <ggole> Hmm.
10:54:46 <Shockk> like, is this going to break it or anything?  tenth :: Proxy (S (S (S (S (S (S (S (S (S Z)))))))))
10:55:01 <ReinH> Shockk: what are S and Z?
10:55:06 <ReinH> Are they types?
10:55:11 * hackagebot wai-routes 0.9.1 - Typesafe URLs for Wai applications.  https://hackage.haskell.org/package/wai-routes-0.9.1 (AnupamJain)
10:55:12 <eikke> ggole: say you have a type representing all even numbers, then [1..10] :: [MyType] can't be calculated through '+1'
10:55:12 <ggole> eikke: if +1 wasn't the right thing to move from 1 towards 10, that would be pretty weird
10:55:17 <MarcelineVQ> Shockk: how long can lists be?
10:55:20 <benzrf> c_wraith: parses as [ False.. {- module member -} ]
10:55:25 <ggole> Ah, I see
10:55:28 <Shockk> ReinH: data Nat = Z | S Nat
10:55:32 <Shockk> promoted to kinds
10:55:39 <Shockk> promoted to kind*
10:55:42 <geekosaur> ggole, what is False + 1?
10:55:46 <geekosaur> (in Haskell)
10:56:05 <ggole> False isn't Num?
10:56:06 <frerich> humanoyd_: I never use hierarchical names.
10:56:07 <Shockk> MarcelineVQ: hmm but : is a data constructor though rather than a type
10:56:07 <geekosaur> given data X = A | B | C | D deriving Enum -- what is B + 1?
10:56:18 <geekosaur> False is not Num
10:56:25 <c_wraith> benzrf: I know, but this client doesn't make fixes as easy as pressing up and editing. 
10:56:26 <geekosaur> more precisely, Bool is not Num
10:56:27 <ReinH> eikke: Sure it can, represent all even numbers using the nats and the function (*2)
10:56:29 <eikke> ggole: there's no Num instance for Bool
10:56:31 <benzrf> ah
10:56:34 <MarcelineVQ> Shockk: I must not be understanding your example
10:56:36 <ggole> Yes, I know
10:56:59 <MarcelineVQ> Oh I see like a type sig, idk why I glossed over the ::
10:57:15 <eikke> ReinH: sure
10:57:27 <ggole> I seemed to have assumed that .. was about Num, which it obviously isn't
10:57:28 <humanoyd_> frerich: thx
10:58:37 <eikke> ggole: see 'arithmetic sequences' in https://en.wikibooks.org/wiki/Haskell/Syntactic_sugar#Lists for the desugarings
10:59:02 <Shockk> either way, that type signature didn't cause problems when I built, but I'd imagine ghc should be able to handle much greater-nested higher kinded types anyway
11:00:11 * hackagebot uuid-orphans 1.3.11 - Orphan instances for the UUID datatype  https://hackage.haskell.org/package/uuid-orphans-1.3.11 (DavidFox)
11:00:13 * hackagebot managed 1.0.1 - A monad for managed values  https://hackage.haskell.org/package/managed-1.0.1 (GabrielGonzalez)
11:00:28 <geekosaur> ggole: "money" types widely used in accounting would want the successor to be 0.01 or sometimes 0.001
11:02:07 <arkeet> @let instance Num Bool where fromInteger n = toEnum (n `mod` 2); (+) == (/=); negate = id; (*) = (&&); abs = id; signum = id
11:02:07 <lambdabot>  Parse failed: Parse error: ;
11:02:08 <ARM9> Cale yes I believe I understand it a little better now at least, thanks
11:02:15 <arkeet> @let instance Num Bool where fromInteger n = toEnum (n `mod` 2); (+) = (/=); negate = id; (*) = (&&); abs = id; signum = id
11:02:16 <lambdabot>  .L.hs:158:33:
11:02:16 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘Integer’
11:02:16 <lambdabot>      In the first argument of ‘mod’, namely ‘n’
11:02:19 <arkeet> oh.
11:02:35 <arkeet> @let instance Num Bool where fromInteger = odd; (+) = (/=); negate = id; (*) = (&&); abs = id; signum = id
11:02:36 <lambdabot>  Defined.
11:03:44 <arkeet> > False + 1
11:03:46 <lambdabot>  True
11:05:12 * hackagebot uuid-orphans 1.3.11.1 - Orphan instances for the UUID datatype  https://hackage.haskell.org/package/uuid-orphans-1.3.11.1 (DavidFox)
11:05:41 <derdon> > product [True, True, False]
11:05:42 <lambdabot>  False
11:05:46 <derdon> > product [True, True, True]
11:05:48 <lambdabot>  True
11:06:01 <arkeet> @check product x == and x
11:06:03 <lambdabot>  Couldn't match expected type ‘t0 Bool’ with actual type ‘Expr’
11:06:03 <lambdabot>  In the first argument of ‘product’, namely ‘x’ In the first argument of ‘(==...
11:06:10 <arkeet> @check \x -> product x == and x
11:06:12 <lambdabot>  No instance for (Show (t0 Bool))
11:06:12 <lambdabot>  arising from a use of ‘myquickcheck’ The type variable ‘t0’ is ambiguous Not...
11:06:25 <arkeet> @check \x -> product (x :: [Bool]) == and x
11:06:27 <lambdabot>  +++ OK, passed 100 tests.
11:06:51 <ggole> Neat.
11:08:22 <Shockk> great :D
11:08:42 <ReinH> such algebra wow
11:08:43 <Shockk> I can write `PM.member first "one" twoPM' and works as intended
11:09:20 <Shockk> and if I write `PM.member third anything twoPM' it fails to compile
11:10:18 <Shockk> kind of undecipherable compile errors though
11:10:42 <edwardk> @remember johnw hearing SPJ talk about GHC 8 at ICFP was as close to sitting in front of Santa Claus at a North Pole pep rally that I've ever been
11:10:42 <lambdabot> Okay.
11:10:49 <Shockk> although that's just if I pass a Num a in there
11:11:32 <ReinH> edwardk: <3
11:11:37 <Shockk> edwardk: haha
11:26:18 <anicake> :help
11:26:23 <anicake> :?
11:28:19 <anicake> first time using irssi... like the CLI client. first time online on IRC. newbie completely! Hi Haskell people! I'm a fan of your work. Thanks for inspiring new engineers like my friends and I.
11:30:27 <joco42_> how can i re-generate cabal.sandbox.config after i have renamed the directory in which the sandbox is ?
11:30:37 <glosoli> is stack something I should consider by default instead of cabal when starting with Haskell ? 
11:31:47 <joco42_> ok, i figured it ou t ;)
11:32:10 <anicake> im a newbie here... and yes i started learning with yorgeys course... and im using Stackage
11:33:00 <Welkin> glosoli: I don't know at this point
11:33:18 <Welkin> stack is still quite new and people seem to have trouble with it (perhaps because of lack of documentation?)
11:33:28 <Welkin> at least with cabal, you can get help
11:33:44 <Welkin> cabal is not a problem once you get used to working with it
11:33:49 <Welkin> as long as you use sandboxes
11:33:58 <glosoli> I see, thanks for reply! 
11:34:18 <Welkin> stack also downloads the compiler too though
11:34:30 <Welkin> and manages a global sandbox of some sort so you can share libraries
11:34:38 <Welkin> which reduces the time spent setting up a new project
11:34:41 <glosoli> sounds familiar to maven 
11:34:43 <Welkin> but it dependso n what you are doing
11:35:04 <Welkin> 30-45 minutes to set up a new project (one time event per project) is not too bad
11:35:20 <glosoli> 30-45 minutes with cabal you mean ? 
11:35:38 <Welkin> well, stack uses cabal underneath
11:35:42 <Welkin> it is a wrapper around it really
11:36:14 <Welkin> my typical web project takes 30-45 minutes to compile because I use libraries with a lot of dependencies
11:36:15 <ReinH> To be clear, stack is not a wrapper around cabal-install, which provides the cabal binary
11:36:20 <ReinH> It uses the Cabal library
11:36:24 <Welkin> things like hakyll, yesod, etc.
11:36:35 <Welkin> ReinH: I see, thanks for the clarification
11:36:52 <ReinH> stack uses the cabal binary for `stack solver`, but I believe that's all?
11:37:00 <Welkin> typical project takes 30-45 minutes to build the initial environment*
11:37:02 <ReinH> You don't even need cabal-install installed to use stack
11:37:14 <Welkin> compilation of my program itself takes seconds
11:37:26 <ReinH> Welkin: what percentage of that is lens? ;)
11:37:33 <Welkin> ReinH: none actually!
11:37:36 <ReinH> hah
11:37:37 <Welkin> I haven't really used lens
11:37:45 * Fuuzetsu mentions something about nix and binary caches
11:37:58 <ReinH> stack does some caching too
11:38:13 <Fuuzetsu> but you still have to build first time
11:38:18 <Fuuzetsu> and if things go awry it gets ugly
11:38:38 <ReinH> Fuuzetsu: I was going to try nix again but stack has been working surprisingly well so I lost my motivation..
11:38:45 <ReinH> I do like nix though
11:38:56 <Fuuzetsu> my experience is opposite, I use stack because I have to but don't really like it…
11:39:04 <Fuuzetsu> I mean it's better than cabal-install
11:39:07 <ReinH> Yes.
11:39:25 <ReinH> Fuuzetsu: A non-trivial part of my previous job was trying to convince cabal-install to do things so...
11:43:35 <clrnd> stack is amazing, Fuuzetsu what don't you like? (just curious)
11:44:42 <Fuuzetsu> most recently I was trying to make a project work with vector 0.10 and vector 0.11 and switching between those versions basically ended up with me having to manually one version or the other and rebuild some packages…
11:45:06 <Fuuzetsu> it's also a bit young still, had problems with docker support etc.
11:45:17 <Fuuzetsu> issues get resolved fairly quickly though, especially if you send a PR so that's good
11:46:05 <clrnd> Fuuzetsu, oh you wanted tot est it against different versions .. using mutiple stack.yaml didn't work?
11:46:18 <clrnd> (also don't use docker, can't talk about that)
11:46:24 <clrnd> I don't*
11:46:33 <Fuuzetsu> I didn't use multiple, I just changed the vector version in extra-depends (because vector-0.11 is not even in lts)
11:46:46 <lamefun> Why doesn't Haskell have an equivalent of C# methods?
11:46:53 <clrnd> lamefun, what's C# methods?
11:47:34 <bob_twinkles> you mean like functions directly attached to the datatypes?
11:47:46 <lamefun> like, value.doSomething() instead of Module.doSomething value
11:48:01 <Fuuzetsu> doSomething value
11:48:12 <ReinH> lamefun: because Haskell doesn't have methods.
11:48:20 <ReinH> because Haskell doesn't have objects
11:48:20 <suppi> I actually thought a bit about it today
11:48:38 <indiagreen> I'd like it if UFCS was available in Haskell
11:48:46 <hiptobecubic> what is an "object" really?
11:48:54 <ReinH> A thing that has methods, for starters ;)
11:49:00 * Fuuzetsu tunes out
11:49:02 <suppi> and once you start adding a bunch of method to data, it is no longer data
11:49:03 <y> http://lpaste.net/141487 just wasting time, do you know any way to remove that use of overlapping instances? (I am using 7.8 right now, and thus not using the new OVERLAP stuff) 
11:49:08 <suppi> it is harder to think about it's type
11:49:17 <suppi> and add operations to it, and compose them
11:49:25 <clrnd> what's a method though? it's just a funciton with the object info attached
11:49:34 <clrnd> we could emulate that with State and lenses
11:49:40 <hiptobecubic> ugh
11:49:54 <ReinH> clrnd: and indeed we do.
11:49:57 <hiptobecubic> doesn't ocaml do this? Does anyone actually use the object system there?
11:50:00 <clrnd> :D
11:50:15 <ReinH> hiptobecubic: yes and no, apparently
11:50:18 <ReinH> (respectively)
11:50:59 <ReinH> Perhaps it's because of the weirder symbol choice (s#pop)
11:51:04 <anicake> UFCS??
11:51:36 <hiptobecubic> Why did they do that, anyway? Are they using '.' for something else? Composition?
11:51:46 <dolio> What's weird bout #?
11:52:02 <ReinH> hiptobecubic: Function composition isn't defined in the ocaml stdlib
11:52:09 <ReinH> dolio: It's not . ;)
11:52:10 <hiptobecubic> dolio, it's not '.' like every other language with objects that everyone knows.
11:52:10 <Fuuzetsu> it's not . which as we all know is the only thing objective people grew to accept
11:52:22 <suppi> ReinH, that's really sad to hear ReinH
11:52:26 <anicake> haskell has it in reverse order... the UFCS
11:52:29 <anicake> :)
11:52:32 <ReinH> The batteries included project defines it
11:52:35 <suppi> I think the one thing i love most about haskell is composition
11:52:50 <ReinH> Yeah, it's weird for a functional language to not even define composition
11:53:18 <ReinH> Huh, even Jane Street don't define a composition infix operator? Madness.
11:53:28 <hiptobecubic> really?
11:53:39 <hiptobecubic> What do they do? How do they function?  (heyooooo)
11:53:41 <anicake> object.method1().method2().method3() ==> func3 . func2 . func1 data-instead-of-object
11:53:55 <ReinH> hiptobecubic: I guess application via |> (pipe) is more idiomatic
11:54:22 <hiptobecubic> ReinH, as in pointful-only?
11:54:27 <ReinH> hiptobecubic: right
11:54:32 <hiptobecubic> f $ g $ h $ x ?
11:54:35 <lamefun> I mean, type inference seems backwards. In C#, you have eg. "Text name = ...; name.strip().filter(isSpace).toUpper()" instead of "Text.toUpper (Text.filter isSpace (Text.strip name))". In C# I only have to tell it that name is a Text once, in Haskell I have to do it lots of times.
11:54:44 <ReinH> h x |> g |> f
11:54:58 <dolio> It doesn't have the o operator?
11:55:13 <hiptobecubic> lamefun, that's a namespace decision you made. It doesn't have to be that way
11:55:14 <Fuuzetsu> lamefun: I don't think you understand the Text. stuff
11:55:22 <Welkin> you mean >>>
11:55:30 <ReinH> dolio: there's -| and |- from batteries included
11:55:40 <Welkin> I always assume |> is append from Data.Sequence
11:55:40 <hiptobecubic> ReinH, eww
11:55:44 <ReinH> hiptobecubic: indeed
11:55:47 <dolio> Is it SML that has o, then?
11:55:49 <Fuuzetsu> hiptobecubic: unless he's complaining about no type-assisted type inference
11:55:51 <suppi> lamefun, you can import unqualified
11:55:54 <ReinH> Welkin: I mean |> from ocaml
11:55:55 <Fuuzetsu> or whatever it's called
11:56:03 <ReinH> dolio: perhaps?
11:56:10 <Fuuzetsu> type assistend namespace inference? I forget the term
11:56:13 <Fuuzetsu> Agda does it
11:56:36 <indiagreen> type directed name resolution?
11:56:39 <geekosaur> type directed name resolution?
11:56:40 <Fuuzetsu> yeah that's the one
11:56:42 <geekosaur> slooow
11:57:00 <hiptobecubic> well if there's anything GHC needs, it's slower compilation times
11:57:04 <ReinH> lamefun: That isn't type inference though
11:57:05 <josephle> dolio: yes
11:57:15 <suppi> if we are already on the subject, what exactly are modules? do we want them first class? are they useful as first class?
11:57:30 <ReinH> suppi: If we had "proper" ML style modules, yes.
11:57:36 <ReinH> What we have are namespaces that we call modules.
11:57:37 <Fuuzetsu> I'd like parametrised modules
11:57:52 <suppi> ReinH, what can we do with them?
11:57:54 <hiptobecubic> ReinH, I never really understood the use case because I've never used it
11:58:05 <suppi> I read a little bit about struct and sig today
11:58:16 <hiptobecubic> ReinH, are you familiar with python? It seems like modules are first class there, is that right?
11:58:19 <lamefun> hiptobecubic, which decision? suppi, if I import eg. filter unqualified, I can't have List.filter in my namespace root (i.e. import Prelude hiding (filter)).
11:58:25 <ggole> First class modules are basically "whatever you can put in a file", wrapped up in a value
11:58:29 <suppi> but I'm not sure if they are useful or may get in the way in some way
11:58:45 <ReinH> suppi: Well, Bob Harper can tell you about it in his usual manner https://existentialtype.wordpress.com/2011/04/16/modules-matter-most/
11:58:45 <suppi> lamefun, you're right, my bad
11:58:55 <ggole> Although I dunno that it makes much sense in Haskell, with it's non-lexical typeclass machinery
11:58:59 <hiptobecubic> ReinH, for example i can import numpy and pass it as an argument to a function which, thanks to the wonders of duck-typing, will just use functions in it assuming they are named correctly.
11:59:01 <ReinH> hiptobecubic: I'm not sure how to relate python modules to ML modules
11:59:31 <suppi> what about static classes, are they similar to modules in some way?
11:59:32 <ReinH> hiptobecubic: I suppose?
11:59:35 <ggole> (There's also an element of structural typing that comes into play with functors.)
11:59:37 <suppi> ReinH, thanks for the link
11:59:39 <defanor> i'm looking for a mime library for both parsing and composition of letters, something to use with HaskellNet; i see a bunch of packages, but not sure which one to pick. any suggestions?
12:00:10 <ReinH> suppi: here's probably a better one http://jozefg.bitbucket.org/posts/2015-01-08-modules.html
12:00:14 * hackagebot hset 2.1.0 - Primitive list with elements of unique types.  https://hackage.haskell.org/package/hset-2.1.0 (AlekseyUymanov)
12:00:51 <L8> hey guys. not sure I understand the difference between: "func :: [a] -> Num" vs "func :: (Num b) => [a] -> b"
12:01:00 <L8> while the first one seems not to work
12:01:03 <mniip> [a] -> Num doesn't make sense
12:01:08 <ReinH> L8: Num is not a type
12:01:10 <mniip> Num is not a type
12:01:16 <mniip> it's a typeclass
12:01:33 <ReinH> L8: The important thing is =>, which separates types on the right from constraints on the left
12:01:36 <L8> while Int, Integer and so on are types, right?
12:01:40 <mniip> yes
12:01:46 <ReinH> typeclass constraints like ``Num b'' go on the left
12:01:49 <ww> and they are *instances* of Num
12:01:52 <mniip> Num is a declaration/requirement that some type supports arithmetic operations
12:02:03 <L8> Char is also a type, right?
12:02:07 <mniip> yes
12:02:11 <dolio> ML doesn't have first-class modules, depending on how you define them.
12:02:16 <ReinH> L8: if it appears on the right hand side of =>, it's a type.
12:02:19 <dolio> OCaml does now, I think.
12:02:28 <ReinH> If it appears on the left, it's a typeclass or a type variable
12:02:29 <dolio> ML only has higher-order modules.
12:02:35 <L8> gotcha
12:02:37 <L8> thanks guys
12:02:43 <ReinH> L8: the things on the lhs of => constrain the things on the right
12:02:46 <hiptobecubic> dolio, what is the difference?
12:02:47 <echolot> btw is there any easy way to tell type from a class in ghci?
12:02:53 <mniip> :k Num
12:02:54 <lambdabot> * -> Constraint
12:02:57 <mniip> :k Int
12:02:59 <lambdabot> *
12:03:08 <suppi> ReinH, I think I read this one
12:03:09 <ReinH> so f :: Num a => a says that a is constrained to be an instance of Num
12:03:20 <dolio> hiptobecubic: OCaml has module values that can be put in types and such, I believe.
12:03:26 <dhsyhgdasy7g> Help hi tutorial me learn new haskell to?
12:03:56 <L8> another small question
12:04:18 <johnw> dhsyhgdasy7g: it seems you already understand that order of evaluation of arguments is not defined
12:04:25 <L8> trying to implement indexOf (indexOf a -> [a] -> Integer)
12:04:28 <dolio> In ML the module system is kind of like a higher order functional language around the base language of types and values.
12:04:29 <dhsyhgdasy7g> Understand I sorry no don't/
12:04:29 <Welkin> L8: how small?
12:04:38 <L8> small-medium :)
12:04:57 <suppi> dhsyhgdasy7g, https://github.com/bitemyapp/learnhaskell
12:05:03 <mniip> dhsyhgdasy7g, what's your native language, you don't appear to speak english very well :/
12:05:10 <L8> but I'm lacking of understanding how can I keep a counter, when I can't pass current index to the function
12:05:13 <dhsyhgdasy7g> English I fine speak.
12:05:23 <dhsyhgdasy7g> suppi: much you thank
12:05:32 <johnw> dhsyhgdasy7g: if you have a question, please ask
12:05:50 <ww> L8: that signature doesn't parse for me
12:06:12 <suppi> johnw, I heard there is a paper about unifying the base and module languages of ML (1ML)
12:06:17 <L8> ww, indexOf :: (Eq a, Num b) => a -> [a] -> b
12:06:37 <L8> i.e. indexOf 1 [2,5,1] will result: 2
12:06:42 <dolio> hiptobecubic: So, for instance, in Haskell + modules, you might imagine wanting 'foo :: IO (Module ...)' so that you could have an IO computation that creates some mutable references that are 'top level' in a module that you can then open and do things with.
12:07:15 <ww> :i Data.List.elemIndex
12:07:18 <dolio> But that kind of thing wouldn't make sense in ML's module system, because modules are at an outer level than types.
12:07:23 <suppi> johnw, woops, I meant dolio 
12:07:24 <dhsyhgdasy7g> Asked question already my 
12:07:35 * ww forgets how to use lambda bot
12:07:44 <ww> but does Data.List.elemIndex do what you want?
12:07:58 <L8> ww, yes, but I want to implement it by my own
12:08:14 <dolio> suppi: I'm sure there are papers. But I don't think, say, SML includes them. OCaml might have adopted one of them, though.
12:08:33 <hiptobecubic> is this yet *another* defintion of Functor?
12:08:46 <suppi> dolio, probably not
12:09:18 <suppi> dolio, I think it is about a new language called 1ML
12:09:45 <dolio> Well, I'd be a little surprised if it were the only such synthesis in a paper.
12:09:51 <suppi> dolio, http://www.mpi-sws.org/~rossberg/1ml/
12:09:52 <ww> L8 ok... so you iterate through the list until you find an element that is equal (or you reach the end of the list)
12:10:19 <dolio> I feel like papers about tweaks to add things to the ML module system are a significant portion of the papers that are written involving ML. :)
12:10:29 <suppi> :)
12:10:52 <shane> what is an example of something that can be done in Haskell owing to typeclasses but becomes very cumbersome in ML using modules? I mean cumbersome beyond just the fact that you have to name the module explicitly?
12:11:06 <dolio> Overloaded numbers.
12:11:13 <ww> if you want an increasing sequence of integers for the index, just make one, and use zip perhaps
12:11:26 <dolio> And arithmetic in general.
12:11:57 <shane> By overloaded number do you mean deriving my own instance for Num?
12:12:29 <hiptobecubic> ReinH, I'm unclear on how this example with Ord and Map is better than what haskell currently can do
12:12:33 <dolio> No, I just mean that 3 can be an Int, Integer, Double, Float, Complex Double, etc.
12:13:01 <shane> How is that achieved using typeclasses?
12:13:13 <dolio> :t 3
12:13:15 <lambdabot> Num a => a
12:13:18 <hiptobecubic> Specifically, under Functors it says you can represent “For any module implementing Ord, I can give you a module implementing MAP which keys of type O.t."
12:14:21 <hiptobecubic> How is that different than having a class (Ord a) => Map a where  ..... ?
12:14:42 <shane> dolio: do you have any other examples too>
12:14:44 <shane> ?
12:14:53 <suppi> I've seen a lecture by Rich Hickey yesterday, and he talked about "specificity vs generality" https://www.youtube.com/watch?v=VSdnJDO-xdg#t=48m53s
12:15:45 <suppi> he shows an example of an HTTP Request in Java and says that "this is basically a glorified map"
12:16:07 <suppi> and then show the same this in clojure, which is just a map
12:16:45 <dolio> shane: I could probably come up with others if I thought about it.
12:17:00 <suppi> so he says, I can use all operations i know of map over this thing which is a pro
12:17:04 <dolio> lens is undoable in ML without first-class modules.
12:17:12 <dolio> And it would probably be worse even with them.
12:17:36 <dmj`> when was the PolyKinds extension added? anyone know off hand
12:17:39 <suppi> but how do we approach it in haskell and types? aren't we doing something similar? don't we gain type safety?
12:17:43 <shane> I see...also I guess quickcheck? I mean it is perhaps not as simple as it is to implement in Haskell right?
12:18:15 <dolio> I don't know about implementation, but it would probably be much more annoying to use.
12:18:24 <y> dolio: 7.6 if I remember correctly 
12:18:46 <y> dmj`: ^
12:18:51 <y> sorry dolio too :P 
12:19:03 <ggole> shane: equality would be a good example
12:19:13 <dolio> Random generation is also an example.
12:19:24 <dmj`> y: kk cool
12:19:40 <dolio> Oh yeah, equality is something that often gets hacked into languages without type classes.
12:19:41 <ggole> You could write a functor that given equality for a type, gives you a bunch of functions
12:19:54 <dmj`> y: DataKinds too?
12:19:58 <ggole> But it would be a fixed set of functions
12:20:03 <shane> but with equality, could i not define an equality module signature in SML/OCAml but then use an infix function like eq for instance 
12:20:18 <y> dmj`: I believe
12:20:32 <ggole> You could define a signature easily enough, but to use it you'd have to apply functors
12:21:00 <ggole> It's all very possible, and not particularly hard, but all the plumbing is very boring
12:21:09 <shane> but apart from the slight code verbosity are there any other disadvantages?
12:21:26 <shane> Right, what plumbing are you referring to here?
12:21:29 <ggole> I don't think there's any loss in expressiveness
12:21:50 <dmj`> y: ty
12:22:02 <shane> Do you mean the functors being applied, possibly composed?
12:22:16 <ggole> Well, in Haskell you have an Eq instance for pairs that will tacitly find equality for the components and glue it together to give you equality for the pair
12:22:34 <ggole> With ML functors you have to select all the parts yourself.
12:23:03 <shane> Oh I see,!
12:23:06 <ggole> There's nothing *hard* about doing it, it's just a pain
12:23:18 <Shockk> I just wrote a ToRelation typeclass that goes from some type to a Relation for my PolyMap and I wrote instances for Relation itself as well as tuples from size 0 up to size 10
12:23:39 <Shockk> so I can now just do `PM.singleton ("one", 1 :: Integer)'
12:23:43 <ggole> The benefit is that you can select all the parts yourself
12:23:51 <ggole> There's no need for newtype wrappers
12:24:08 <ggole> In order to have a type to direct the type class machinery where you want it
12:24:34 <y> Shockk: have you seen http://lpaste.net/141487 ? :p
12:24:36 <shane> Are newtype wrappers really that big a problem considering that can use the Generalized newkind deriving extension?
12:24:48 <ggole> No, you just wrap and unwrap a bit
12:24:56 <shane> Right
12:25:13 <Shockk> y: what's this?
12:26:34 <shane> But what sort of things do ML modules allow that in Haskell is a huge problem. I mean multiple implementations of something, one can do with newtype and some may find it annoying, but I think it is a minor inconvenience given that one can derive instances for newtypes
12:27:18 <y> Shockk: it's basically type-indexed lists, maybe, booleans and natural numbers at the type-level, with some extra stuff for tagging it for extra fancyness
12:27:43 <shane> Again with multi parameter classes, in conjunction with newtype, and class constraints, one can mimic the role of functors
12:27:52 <edwardk> shane: the nice thing about ml modules is you can to things like parameterize an entire module over, say, what random number generator you are using rather than mangling every type and method inside of it to pass a proxy or an extra argument
12:27:54 <Shockk> ahhhh
12:28:01 <dolio> shane: I think the problem comes down to scope of use.
12:28:16 <edwardk> this means that many code transformations in the presence of ml modules basically just involve 'currying out' the argument into the module itself rather than passing it everywhere
12:28:29 <dolio> For arithmetic and equality, you often want to use the operations at several different types very often, and modules are a poor fit.
12:28:37 <edwardk> this is the thing that makes me really want them, but just not enough to want to give up the power of typeclasses.
12:29:00 <dolio> But for some things, you want to parameterize a bunch of code by one choice of implementation, and modules are good for that, and type classes are less good.
12:29:07 <edwardk> the idea that you can take global code transformations like that and mostly make them local is kind of great
12:29:38 <shane> edwardk: what power of type classes that are very tough with ML modules, do you have in mind?
12:29:42 <ggole> There are various schemes floating around to reconcile the two approaches
12:30:02 <edwardk> shane: "fmap.fmap.fmap.fmap" with 4 different fmaps. =)
12:30:03 <ggole> Although none of them have really struck me as obviously better
12:30:13 <edwardk> shane: that is a rather big pain in the ass with ml style modules
12:30:29 <shane> edwardk : Ah!
12:30:29 <edwardk> because you are stuck dealing with all the naming of all the instances yourself, the solution is always going to be more verbose
12:30:49 <edwardk> the thing is that haskell's typeclasses deal with a ton of 'administrative' instance plumbing for you
12:31:02 <ggole> Mmm. Modules are good at, uh, coarse grained stuff.
12:31:10 <edwardk> this is the kind of plumbing that is tedious to fix up when you refactor your code
12:31:12 <dolio> shane: So, like, parameterizing by a string implementation is probably better done with modules.
12:31:38 <edwardk> anyways, i like both, i just like typeclasses more =)
12:31:43 <ggole> Something like parameterising a compiler backend by a structure containing all the target info
12:31:48 <c_wraith> The power of type classes is really that the compiler writes so much code for you. 
12:31:59 <ggole> Where you have hundreds of places referencing the single argument
12:32:02 <shane> edwardk: Is that why while in Haskell powerful abstractions like monads, traversable, foldable, applicative functors etc exist for such diverse data types that at first seem to have nothing in common...like lists and State both being monads...they are not so common in ML
12:32:11 <shane> ?
12:32:20 <edwardk> shane: well that and they can't do the higher kinded stuff
12:32:29 <edwardk> so they can't talk about the abstraction
12:32:47 <shane> edwardk: and that is not something that can be done with modules and functors?
12:32:55 <ggole> Modules can express monads: it's just clumsy
12:33:07 <dolio> To do higher-kinded stuff you need to use modules. :)
12:33:10 <shane> edwardk: or rather does the clumsiness get out of hand?
12:33:35 <edwardk> i should say you can do it, but they get dumped into a module
12:33:56 <edwardk> https://www.irccloud.com/pastebin/EXMeP5we/
12:34:00 <shane> edwardk: is there a disadvantge to that?
12:34:12 <bitemyapp> shane: http://blog.enfranchisedmind.com/2007/08/a-monad-tutorial-for-ocaml/ look for yourself.
12:34:19 <ggole> Even if ML type variables could range over type constructors, without bounded quantification you couldn't use them
12:34:33 <bitemyapp> shane: the lack of higher-kindedness means you aren't talking about an explicit relationship between the structure and what it's structuring
12:34:38 <bitemyapp> shane: they're just type variables.
12:34:39 <ggole> Bundling them up in a structure gives you that
12:34:43 <edwardk> shane: now parameterize over 'monad', write compose as a data type, etc. in a way that doesn't care about the classes you're going to use
12:35:10 <ggole> So the difference is not just lack of HKTs that
12:35:12 <edwardk> if you go to use an ml module to talk about 'compose' you need to know all the properties of the two arguments f and g that you want to compose together
12:35:25 <edwardk> this means using one off combinators to swap them out that rely on the properties of the _other_ argument, etc.
12:35:32 <edwardk> it eventually becomes a right mess
12:35:38 <shane> I see...thanks
12:35:45 <edwardk> there is a reason why you start to hit a certain sort of ML abstraction ceiling
12:36:43 <shane> Also, what is meant by course grained abstraction vs the fine grained abstraction and why are ML modules better for the former but type classes better for the latter, if that is a true statement?
12:37:23 <ggole> By coarse grained I just meant that the functor body contains a lot of stuff
12:37:35 <edwardk> i'd say it differently. i'd say that ml modules are good at making global choices without having to refactor _all_ the types. while typeclasses are very good at dealing with administrative plumbing
12:37:36 <ggole> So that you get a lot of "plumbing" for one functor application
12:37:45 <dolio> shane: Coarse grained means making a choice for a whole other module, instead of multiple times at an expression level or something.
12:38:02 <edwardk> if you screwed up and didn't parameterize your data types enough then making that thing a parameter is a big global messy code transformation in haskell
12:38:17 <dolio> The more times you have to make the decision, the more the overhead of making it matters.
12:38:22 <edwardk> the ml story permits you to fix that with a more local change to the signature of your functor
12:38:59 <edwardk> the cost is that moving in and out of the different cases becomes harder, and you polymorphic recursion through that thing you just parameterized is basically gone
12:39:11 <edwardk> s/you//
12:40:36 <shane> Also I believe that typeclasses works by passing an extra argument at runtime...does the compiler optimize this wherever it can by ensuring that this is not done at runtime?
12:41:30 <edwardk> shane: typeclasses get simplified away where they can, e.g. when the type of the argument is known and the function inlines, etc.
12:41:31 <geekosaur> it resolves typeclasses at compile time if it can
12:45:40 <shane> I am particularly interested in some of these very very high level abstractions that apply on seemingly very different datatypes: for instance lists and IO seem to have nothing in common at first glance, but they both can have a monadic structure...and interpreting functions like sequenceM, filterM etc in terms of these monadic interpretations for each of them is fun...I am also aware of Applicative functors, Traversable, and Foldable...are there any other
12:45:40 <shane> s that you can suggest?
12:45:50 <shane> Sorry of the question is a bit vague
12:46:33 <nolrai666> Is there a prefix or word y, such that yX something that is both X and coX?
12:47:14 <arkeet> nolrai666: not in general afaik, but there is e.g. https://en.wikipedia.org/wiki/Biproduct
12:48:06 <shane> I mean when I want to say add two numbers after applying the functions f and g respectively, it may not be useful but is certainly fun to observe that by interpreting the way functors are defined as an instance of Applicativefunctor one can use (+) <$> f <*> g and apply that to the number
12:48:16 <THE_alex> hi guys, sorry if this is a dumb question or something but is there a good way to kind of get into the mindset of how to write idiomatic haskell?
12:48:24 <shane> I am asking for something similar
12:48:31 <Fuuzetsu> just write more Haskell and join projects
12:48:42 <arkeet> read haskell, write haskell, get feedback on what you write
12:49:05 <dmj`> THE_alex: there are some style guides out there, tibbe has one
12:49:09 <THE_alex> thing is, i don't have to write haskell at work, which is the usual way i learn a programming language
12:49:18 <dmj`> THE_alex: https://github.com/tibbe/haskell-style-guide
12:49:24 <Fuuzetsu> don't have to? does that mean you can? ;)
12:49:51 <Fuuzetsu> dmj`: I don't think style guide is what he's after
12:49:52 <THE_alex> i wen through LYAH and felt like i understood everything they explained but kind of crapped out of most of the exercises
12:50:01 <THE_alex> is that a common thing?
12:50:06 <Fuuzetsu> sure
12:50:13 <Fuuzetsu> just keep at it
12:50:14 <Welkin> THE_alex: LYAH is not good for true understanding
12:50:16 <breadmonster> THE_alex: LYAH doesn't have examples.
12:50:21 <clrnd> LYAH is not that good for teaching haskell either
12:50:23 <Welkin> it is more of a gentle introduction to the high-level concepts
12:50:25 <breadmonster> THE_alex: Do you get monads?
12:50:31 <THE_alex> i think so
12:50:34 <Fuuzetsu> wow the anti-LYAH crowd is really into it today
12:50:35 <breadmonster> Fantastic.
12:50:36 <Welkin> THE_alex: go through the upenn course and nicta
12:50:40 <Welkin> @where learnhaskell
12:50:41 <lambdabot> https://github.com/bitemyapp/learnhaskell
12:50:45 <montanonic> ^indeed
12:50:47 <montanonic> that
12:50:49 <breadmonster> Fuuzetsu: I love the book, it was my first Haskell book.
12:50:49 <montanonic> Do that
12:50:57 <clrnd> me too! I got into haskell because of it
12:51:00 <montanonic> Likewise
12:51:04 <montanonic> It showed me the cool stuff
12:51:04 <shane> same here
12:51:07 <Welkin> I likewise started with LYAH
12:51:08 <gfixler1> The upenn course takes about 2 years, if I'm any indicator
12:51:14 <Welkin> but it is not the best to start with
12:51:18 <clrnd> wow the LYAH lvoe is really into it today
12:51:30 <Welkin> lol gfixler1 
12:51:31 <Fuuzetsu> it's OK to start with
12:51:44 <gfixler1> Welkin: I still have to finish up the final week (12)
12:51:49 <montanonic> It's okay to start with, but won't prep most people to do much with Haskell.
12:51:59 <montanonic> which is not a bad thing; lots to learn at first
12:52:00 <THE_alex> i think i get a lot of concepts about functional programming, but i just run into a wall as soon as i try something that's not quicksort or a parser
12:52:00 <gfixler1> Welkin: part of the slowdown was that any time it suggested reading other things, I did
12:52:01 <Welkin> the upenn course + nicta + typeclassopedia + some papers + the wiki + this channel
12:52:02 <Ankhers> LYAH is a fun book to read. But you probably won't come out of it knowing how to write Haskell.
12:52:04 <Fuuzetsu> neither will any learning material…
12:52:14 <Welkin> RWH is also good (although quite outdated now in some ways)
12:52:15 <montanonic> THE_alex: CIS194 is for you then
12:52:17 <bitemyapp> Fuuzetsu: I'm trying to change that.
12:52:32 <breadmonster> THE_alex: Haha try network programming?
12:52:35 <bitemyapp> Fuuzetsu: not everything, not a ton, but trying to put together something that leaves people better prepared.
12:52:38 <gfixler1> I feel like I'm learning a lot of Haskell from its critics, most of them being Haskellers
12:52:45 <THE_alex> yes, i do network programming a lot :D
12:52:51 <montanonic> THE_alex: if it's too easy, try NICTA, still too easy, Real World Haskell, since you already know hot to program.
12:52:51 <gfixler1> When they say what it can't do, or is bad at, I get a better lay of the land
12:52:57 <Fuuzetsu> bitemyapp: right, and that's good; what's not good is people flipping tables when LYAH gets mentioned…
12:53:12 <THE_alex> you guys are great by the way, i'm kind of overwhelmed with the response :D
12:53:19 <Welkin> THE_alex: the best way to get comfortable writing realistic/practical haskell is you start working on a project
12:53:25 <gfixler1> THE_alex: you're getting the Haskell Hug
12:53:28 <shane> I also found some of the articles in Journal of Functional Programming to be quite useful
12:53:37 <breadmonster> THE_alex: Try doing something interesting. Yesod is fantastic.
12:53:40 <arkeet> I remember when I first tried learning haskell and I was reading YAHT
12:53:42 <arkeet> https://www.umiacs.umd.edu/~hal/docs/daume02yaht.pdf
12:53:47 <Welkin> THE_alex: the project that pushed me over from being unable to program anything non-trivial to writing real applications was building a website with Yesod
12:53:53 <arkeet> it hurt my head at the time so I put it aside for a while.
12:53:57 <arkeet> LYAH didn't exist
12:54:09 <nolrai666> shane: there's comonads, and arrows, and monoids, and rigs, though the last isn't a type class.
12:54:13 <Fuuzetsu> did yesod exist before LYAH?
12:54:21 <montanonic> I think most people here arre thoroughly convinced that Haskell is the best medicine for shitty programming. We like to share that enthusiasm.
12:54:27 <tommd> arkeet: I learned from YAHT too.
12:54:54 <tommd> arkeet: I was infuriated at the low quality of the exercise questions, as I recall.
12:54:56 <Welkin> Fuuzetsu: yes
12:54:57 <shane> norlrai666: thanks , I know about monoids, and have heard of arrow and comonads, but will check out rigs
12:54:58 <hiptobecubic> I've been making a desktop app with hsQML. It's definitely forcing me to reconsider what the hell I'm doing
12:55:04 <Welkin> Yesod came out March 2010
12:55:05 <arkeet> heh
12:55:07 <montanonic> Welkin: that's great to know! I'm planning on going back to trying Yesod once I finish NICTA.
12:55:08 <Welkin> LYAH came out April 2011
12:55:09 <Welkin> lol
12:55:11 <dolio> tommd: Should have used the gentle introduction.
12:55:13 <THE_alex> so yesod seems to be popular, i'm thinking of writing a braindead rss feed, that just combines a bunch of feeds (with a sampling threshold to turn down noisy feeds by a notch) without stuff like "blabla unread messages" stuff
12:55:33 <Fuuzetsu> yesod might be a bit hard to get started with ;)
12:55:37 <Welkin> THE_alex: haskell has an amazing web development ecosystem
12:55:40 <Fuuzetsu> but if you persist you'll learn a lot
12:55:41 <tommd> dolio: I switched to Craft of FP, iirc, pretty quickly.
12:55:44 <THE_alex> that sounds great
12:55:49 <hiptobecubic> THE_alex, yesod can do anything you'd like I'm sure, but that sounds like a pretty simple project for such a enormous framework.
12:55:57 <Welkin> THE_alex: yesod, scotty, spock, servant, persistent, opaleye, blaze-html, etc.
12:55:58 <hodapp> at least, as amazing as web development allows.
12:56:08 <dolio> tommd: That costs money, though. :)
12:56:12 <hiptobecubic> I'd try servant or spock probably.
12:56:18 <tommd> dolio: No, I'm wrong.  Don't recall my first book I guess.
12:56:30 <dolio> Well, maybe it doesn't. I thought it di.
12:56:48 <bitemyapp> dolio: it does
12:57:03 <hiptobecubic> Has anyone tried writing anything on top of Electron? It seems like a good fit
12:57:09 <THE_alex> that sounds good, so i've tried a bunch of other langauges (chicken scheme, erlang) but i felt like they're just missing something (which unfortunately is hard to describe) so i want to take a peek at haskell
12:57:20 <hodapp> is that something...... static types?
12:57:24 <hiptobecubic> Specifically because you are essentially writing a web app and you implement the GUI using web... stuff.
12:57:29 <hodapp> and a type system that's not atrocious?
12:57:35 <breadmonster> THE_alex: Haskell is awesome. Like, it can do absolutely anything with the same performance as Java and like one third of the code.
12:57:41 <Welkin> hiptobecubic: threepenny-gui
12:57:45 <breadmonster> It's so awesome that I'll be running my start up in OCaml.
12:57:54 <Welkin> breadmonster: better performance than java*
12:57:54 <THE_alex> @breadmonster yes, that's what got me interested in the first place
12:57:54 <lambdabot> Unknown command, try @list
12:58:16 <THE_alex>  @breadmonster: that's exactly what got me interested in the first place
12:58:20 <montanonic> THE_alex: haskell is the most popular and performant language that is on the bleeding-edge of programming language theory as far as I'm aware.
12:58:21 <hiptobecubic> THE_alex, @ is not needed in the ancient halls of IRC
12:58:33 <breadmonster> Yeah, @ is a twitter thing.
12:58:37 <THE_alex> how do i do the @ thing?
12:58:40 <Welkin> haha
12:58:49 <hiptobecubic> it's a lot of things now. Just not IRC
12:59:01 <breadmonster> montanonic: Are you sure?
12:59:01 <montanonic> You can however
12:59:11 <montanonic> @ty (+)
12:59:13 <lambdabot> Num a => a -> a -> a
12:59:13 <hiptobecubic> THE_alex, IRC clients just tell you when your name is used. There's no notation for it.
12:59:21 <montanonic> breadmonster: "as far as I'm aware"
12:59:22 <hiptobecubic> At least, that's how most people have it configured
12:59:29 <gfixler1> You still need @ to make Princess Leia @-_-@
12:59:41 <THE_alex> damn, you guys are scarily understanding
13:00:03 <montanonic> breadmonster: I searched a lot, though I'm not at all opposed to being shown other languages! :)
13:00:13 <hiptobecubic> The faster than java argument always seemed a little bogus to me and mostly misses the point anyway
13:00:37 <THE_alex> breadmonster: so what i do is HPC with a focus on machine learning, i want to use the rss feed as a "toy project"
13:00:44 <hiptobecubic> The reason to use something other than Java only comes down to performance like 10% of the time at best I bet
13:01:00 <hiptobecubic> Most of the time it's "Anything but Java!" that's driving the discussion
13:01:06 <dolio> 10% might be high.
13:01:12 <THE_alex> how does perform at numbercrunching?
13:01:15 <breadmonster> THE_alex: wow okay...
13:01:16 <THE_alex> +haskell
13:01:19 <breadmonster> Might have some issues.
13:01:23 <hiptobecubic> THE_alex, /j #numericalhaskell
13:01:26 <breadmonster> Haskell is not the best for sheer numbers.
13:01:29 <breadmonster> iirc.
13:01:32 <THE_alex> damnit
13:01:43 <hiptobecubic> THE_alex, the ecosystem there is pretty weak at the moment
13:01:55 <montanonic> breadmonster: can you elaborate on the issues with it? I've heard a decent amount of chattering about that.
13:02:01 <montanonic> But not the specifics.
13:02:01 <clrnd> weak compared to fortran
13:02:05 <hiptobecubic> THE_alex, although not weaker than, say, C. You just don't have as much of the haskelly goodness you've come to expect.
13:02:07 <clrnd> storng compared to javascript
13:02:12 <THE_alex> i was hoping to get some answer like "no, they're wrong, check out X"
13:02:23 <THE_alex> yeah that's my experience
13:02:32 <THE_alex> people say "oh well, use mutable data"
13:02:33 <Welkin> THE_alex: there are still many domains without a lot of support, but that is true of any language
13:02:39 <Welkin> in time it will come
13:02:44 <sunnymilk> montanonic its not very fast, its not very easy (fromIntegral, div vs /, ^ ** and etc), and its not very intuitive
13:02:44 <hiptobecubic> THE_alex, the problem so far seems to be coming with a good library/api for HPC without giving up haskell's bread and butter
13:02:45 <clrnd> THE_alex, haskell is great for mutable data too
13:03:08 <montanonic> sunnymilk: thanks! is that more to do with Haskell features, or lack of libraries?
13:03:11 <Welkin> THE_alex: oh yeah, it is common to hear "Haskell is the best imperative language"
13:03:13 <hodapp> Also, in most cases where you think you need the *best* raw single-core performance... you likely don't.
13:03:34 <sunnymilk> i think it would be possible to have a proper number type hierarchy in haskell but it does not currently exist in the3 standard library
13:03:40 <sunnymilk> so i guess the latter
13:03:43 <hiptobecubic> THE_alex, if you *do* want to give it up, it's not like there aren't linear algebra library bindings you can just use directly. hmatrix for example.
13:04:39 <THE_alex> so what this sounds like to me is "use specialized libraries or write specialized (non-idiomatic) haskell code"
13:04:39 <sunnymilk> i also dont agree with implicit modularization of the Int type (its modulus is 2^(32 or 64 depending on CPU type) but it doesnt tell you this anywhere
13:04:47 <THE_alex> is that correct?
13:04:59 <THE_alex> not judging btw
13:05:03 <hiptobecubic> THE_alex, I think so. But even then it depends on how fast it *really* needs to be.
13:05:07 <sunnymilk> so you could write code that works fine on a 32 bit machine but behaves differently on a 64 bit machine (or vice versa)
13:05:14 <Welkin> sunnymilk: Int64 and Int32
13:05:15 <sunnymilk> it also doesnt tlel you when Int rolls over
13:05:17 * hackagebot psc-ide 0.2.0.0 - Language support for the PureScript programming language  https://hackage.haskell.org/package/psc-ide-0.2.0.0 (kritzcreek)
13:05:21 <montanonic> THE_alex: Monads, in some sense, let you define how an imperative environment behaves. For example, the Haskell List, [], has two standard Monad instance implementations, one of which allows you to right code like : do {x <- [1,2] ; y <- [3,4] ; return (x,y)} = [(1,3),(1,4),(2,3),(2,4)]. So, like a for loop. 
13:05:26 <sunnymilk> Welkin those are things but i am talking about Int proper
13:05:32 <sunnymilk> ie, the Int in the standard library
13:05:33 <hiptobecubic> THE_alex, if you're willing to back off on it a little, libraries like Vector are really nice to use
13:05:55 <hiptobecubic> THE_alex, and in mysterious cases can compile down to very tight code
13:06:28 <THE_alex> well, since i'm interested in good performance for inner loops i'm really willing to back off, as long as the overall architecture doesn't change a lot
13:07:24 <ww> or repa with nifty stream fusion for linalg
13:07:50 <THE_alex> so what's your opinion, does a backend that does the heavy lifting with a web frontend make sense to be implemented in haskell?
13:08:07 <THE_alex> or should the backend be implemented in c++/c/whatever?
13:08:26 <dolio> Int32 and Int64 are in the standard library.
13:10:11 <ww> THE_alex: use whatever language you like best. haskell is a good choice and well capable. other languages are also good choices.
13:11:08 <montanonic> THE_alex: As far as I know, Yesod should be entirely great for something like that.
13:11:47 <zomg> THE_alex: I've done some web backend work with Haskell and it works quite nicely. Yesod as mentioned by montanonic is great for it, but it might be a bit difficult to jump into if you're not very experienced with Haskell, so you might want to start with Scotty or such which are easier to understand
13:12:02 <THE_alex> alright, thank you very much and again, i'm impressed by how much you guys don't try to puch an agenda
13:12:02 <montanonic> It's also a bit like Rails though with regards to how much it handles, so there's a need to learn it as a DSL that might be too steep of an initial investment.
13:12:09 <fabian__> Im writing a TCP server in Haskell. Looking at memory profiling output, I see a potential space leak. Running with -hy I see 3 types that dominate: ->>Ix Map and [] (https://www.dropbox.com/s/aea9ie3fx65549p/flicloud.ps?dl=0)
13:12:46 <THE_alex> puch=push
13:12:52 <zomg> montanonic: tbh the biggest issue I had with Yesod was the error messages at least used to be really confusing because of all the type magic it does :D
13:12:53 <fabian__> If someone could look at that profiling output and give pointers on how to pinpoint the  error, I would appreciate it!
13:12:54 <clrnd> fabian__, I read this earlier today, maybe it proves useful: http://neilmitchell.blogspot.com.ar/2015/09/detecting-space-leaks.html
13:13:25 <montanonic> zomg: I have that experience too. Totally. My solution was to learn more Haskell, which I'm doing now, and then step back into it :)
13:13:34 <Welkin> montanonic: yesod is nothing like rails
13:13:39 <Welkin> montanonic: I don't get why people say that
13:13:48 <Welkin> montanonic: yesod is very modular and is no opinionated
13:14:01 <Welkin> montanonic: you can use whatever parts you wany and ignore others
13:14:06 <Welkin> want*
13:14:21 <zomg> It's rails-like in the sense that it comes with all the things included if you want to use them though
13:14:29 <montanonic> I would qualify my opinion as hearsay; it does seem to be echoed a bit though.
13:14:33 <zomg> but yeah I think they've made it more modular, I'm not sure if it used to be that way always
13:15:06 <jophish_> yo yo yo!
13:15:09 <montanonic> Perhaps it would be best to not phrase things that way, but I think the point is what zomg just said: it's very batteries included.
13:15:16 <zomg> Scotty is fairly similar to Sinatra to make another Ruby comparison :)
13:15:16 <Welkin> yes
13:15:31 <Welkin> yesod gives you good defaults to work with, but you can choose to do whatever you want
13:16:11 <THE_alex> sorry for being intruding again, so yesod is a "no-config" solution by default as long as you don't want anything special?
13:16:20 <jophish_> I have a record R with a field f :: 0. I have a function foo :: Monad m => m R. I'd like to do something similar to: do x <- foo; pure x{f = 1}
13:16:25 <THE_alex> like martini for go?
13:16:41 <Welkin> in particular, the best parts of yesod are Persistent (which you can use by itself without yesod), the route handling, and hamlet (which uses blaze-html)
13:16:59 <Welkin> THE_alex: I'm not sure what you mean
13:17:16 <jophish_> @pl foo >>= \ x -> pure x{f = 0}
13:17:16 <lambdabot> (line 1, column 22):
13:17:16 <lambdabot> unexpected '{'
13:17:16 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
13:17:22 <Welkin> THE_alex: there is a scaffolding you can use that pulls in good default libraries and sets up the wiring automatically, but that it it
13:17:37 <Welkin> THE_alex: you can do whatever you want with it. You do not need to use the scaffolding at all.
13:17:44 <THE_alex> that it "just works" if you're a newbie that doesn't really get along in the language, but offers customizations in case you know what you want
13:17:53 <Welkin> yes
13:17:55 <THE_alex> that sounds pretty good
13:20:13 <THE_alex> when you say 'persistent' do you mean 'Persistent' or 'Data.Vector.Persistent'?
13:20:14 <Fay> hey guys
13:20:18 * hackagebot wai-middleware-verbs 0.0.1 - Route different middleware responses based on the incoming HTTP verb.  https://hackage.haskell.org/package/wai-middleware-verbs-0.0.1 (athanclark)
13:20:21 <dmj`> Fay: sup
13:20:48 <Fay> there exists in haskell a type called Ptr correct?
13:20:53 <L8> could done anything better here? http://paste.ofcode.org/jP7RHSNtEChLBeuDNMVM8i (except using already defined length & Data.List.elemIndex)
13:21:22 <Welkin> THE_alex: https://hackage.haskell.org/package/yesod-0.0.0
13:21:56 <Fay> okay whats the hidden package
13:22:04 <THE_alex> Welkin: i'll look into that, thanks!
13:22:16 <Welkin> THE_alex: https://hackage.haskell.org/package/persistent
13:22:18 <Welkin> that is persistent
13:23:17 <Welkin> THE_alex: This is the official yesod book that explains a lot of this http://www.yesodweb.com/book/persistent
13:23:24 <Welkin> THE_alex: if you want to use yesod, this is the best place to start
13:23:33 <dmj`> Fay: yes
13:24:04 <Fay> dmj`: ghc is telling me its a member of the hidden package
13:24:25 <Welkin> Fay: it should say on the next line down
13:24:43 <montanonic> THE_alex: Also the yesod website has a quickstart guide. Use that to get a local website set up so you can play around with it.
13:25:07 <montanonic> The scaffolding code is fairly well documented, so just reading the source can be a good companion to the book.
13:25:18 <THE_alex> Welkin: that looks good, i feel like i'm stealing time from you, i'll look intro all the info you gave me and then check back in with you
13:27:17 <THE_alex> this really is one helpful irc channel, thanks a lot guys, i'll probably be back!
13:35:18 * hackagebot react-flux 1.0.0 - A binding to React based on the Flux application architecture for GHCJS  https://hackage.haskell.org/package/react-flux-1.0.0 (JohnLenz)
13:35:56 <clrnd> react flux lol, and I haven't even tried ghcjs, thing go so fast
13:36:08 <clrnd> 1.0 sounds optimistic though
13:39:28 <Igloo> Do any fancy GHC extensions (e.g. TypeFunctions) allow me to write something like http://lpaste.net/7870937919685394432 using a single parameter to T, like in http://lpaste.net/959790990107869184 ?
13:40:17 <fabian__> In a ExceptT block, does except break a forever?
13:41:09 <pavonia> @src forever
13:41:09 <lambdabot> Source not found.
13:43:01 <clrnd> fabian__, afaik ExcepT is pure, so ... my guess is not
13:43:14 <clrnd> :t forever
13:43:15 <lambdabot> Monad m => m a -> m b
13:44:11 <clrnd> or yes! since it's just >>
13:45:00 <fabian__> clrnd: that doesnt matter
13:45:05 <aweinstock> @undo forever
13:45:05 <lambdabot> forever
13:45:06 <clrnd> > forever Nothing
13:45:07 <lambdabot>  Nothing
13:45:22 <clrnd> > forever Just 5
13:45:26 <pavonia> It Except works like the Either monad instance, it really should break
13:45:27 <lambdabot>  mueval: ExitFailure 1
13:45:32 <clrnd> there is your answer :P
13:45:49 <clrnd> I guess it depends on the definition of >>=, it's it's lazy on the second argument
13:45:54 <aweinstock> :t fix (\f g -> do { g; f})
13:45:56 <lambdabot>     Occurs check: cannot construct the infinite type: m ~ (->) (m a)
13:45:56 <lambdabot>     Expected type: m b
13:45:56 <lambdabot>       Actual type: m a -> m b
13:46:11 <aweinstock> :t fix (\f g -> do { g; return f})
13:46:12 <lambdabot>     Occurs check: cannot construct the infinite type: b ~ m a -> m b
13:46:12 <lambdabot>     Relevant bindings include
13:46:12 <lambdabot>       g :: m a (bound at <interactive>:1:9)
13:46:59 <kosmikus> Igloo: you could tuple them up, but that's probably not what you mean ...
13:48:39 <bryanedds> for parsec, do I need to specify a separator to use chainl?
13:49:04 <bryanedds> what if I want to parse a recursive expression when the separator is just whitespace?
13:49:05 <Igloo> kosmikus: No, I want to have a single "phase number" rather than a boolean for each phase (plus associated other types)
13:49:42 <Igloo> And also to have the "Pattern match(es) are non-exhaustive" warning to the right thing
13:49:43 <kosmikus> Igloo: oh, I see, so you want to index by 1, 2, 3, ...?
13:49:46 <bryanedds> I don't know how to use chainl when I use whitespace as a separator for my terms
13:50:00 <kosmikus> Igloo: and then map the type-level numbers to the Booleans etc?
13:51:04 <Igloo> kosmikus: Well, I want the C2 constructor to exist in (T P1) and (T P2), but not (T P3) or (T P4), for example
13:52:41 <Matti565> what is the best place for general programming questions? About the closest pair algorithm specifically?
13:52:53 <johnw> Matti565: that's actually a good question
13:53:17 <johnw> the #compsci channel has 2 people in it
13:53:25 <bryanedds> oh hmmm... I guess I can just use `many readValue`
13:53:39 <nolrai666> What I was going to say.
13:53:44 <arkeet> maybe ##programming or #algorithms ?
13:53:48 <arkeet> I dunno.
13:54:15 <johnw> Matti565: you could implement it in Haskell, and then ask here :)
13:54:39 <Matti565> johnw: Thats what I'm doing at the moment actually :)
13:55:15 <johnw> then ask away...
13:55:48 <bryanedds> picking up parsec after a long break isn't like riding a bicycle :)
13:56:53 <Matti565> I'll ask my question then: The first step for the algorithm in a 2d plane is dividing in two parts via the median value. However, to get this median value, I need to sort. However, in the explanations about the algorithm I read, sorting comes much later in the process. Is there a way to find the median without sorting?
13:57:06 <cmccann> bryanedds: meaning that you try to do it and find the tires are flat and the seat is full of spiders?
13:57:37 <bryanedds> I... suppose?
13:57:48 <bryanedds> mostly I just look like an idiot :)
13:58:00 <seanparsons> edwardk: Discrimination feels like witchcraft.
13:58:14 <Rembane> Matti565: Yes, but if you eventually want to sort, why not do it at the start?
13:58:19 <edwardk> seanparsons: hahaha
13:58:54 <Matti565> Uhhm, yeah, I made a very simple reading mistake... Sorting is first step on x coords, then later sort again on y coords
13:59:49 <seanparsons> edwardk: I've now watched Fritz's and your Zurihac talk about it which are still blowing my mind into a million pieces.
14:02:09 <edwardk> seanparsons: i think the key is realizing that what it does is improve O(sum(longest common prefixes of your data) + n log n) to O(sum(longest common prefixes of your data) + n log sigma) where sigma is the number of buckets used at a time, not the word size
14:02:21 <cmccann> Igloo: there's probably lots of ways to do that if you want to restrict what constructors can be used for which types. making it so GHC knows which constructors are possible given a particular type is probably much harder.
14:02:22 <edwardk> when the former term dominates it is no faster, when the latter term does it wins
14:02:35 <edwardk> so the worst case is that it has the same asymptotics as before
14:02:35 <kristof> > :k Data.Traversable
14:02:36 <lambdabot>  <hint>:1:1: parse error on input ‘:’
14:02:43 <edwardk> but the best case is better
14:02:55 <kristof> > :t Data.Traversable
14:02:56 <lambdabot>  <hint>:1:1: parse error on input ‘:’
14:03:01 <kristof> Whatever :/
14:03:31 <cmccann> Igloo: even so every way I can think of restrict constructor use amounts to basically the same as what you have, just sweeping the "here's the list of thingies" under a different rug
14:04:48 <seanparsons> edwardk: Yeah, I fired it up and my first wavy experiment was with large [Int] where now I believe that is worst-ish case scenario.
14:05:19 <phaazon> hey, what is the main worflow to get Haskell -> JS compilation?
14:05:42 <edwardk> seanparsons: i haven't actually done much in the way of macrobenchmarking with it, just setting up the right asymptotics and building better tools for fixing the microbenchmarks of parts of it
14:05:57 <cmccann> phaazon: step 1 is pick one of the 3 (?) options, then proceed to one of several steps 2
14:06:11 <phaazon> the 3 options?
14:06:19 <phaazon> you mean, UHC / Fay / GHCJS?
14:06:29 <montanonic> phaazon: GHCJS is the standard Haskell one, and Purescript is the most Haskelly non-Haskell one.
14:06:30 <cmccann> also Haste
14:06:33 <kosmikus> Igloo: I don't think you can fix the pattern matching warnings, although there are improvements in the pipeline
14:06:45 <phaazon> which Haskell library would you recommend then?
14:06:47 <phaazon> GHCJS?
14:06:50 <arkeet> purescript and fay aren't haskell
14:06:52 <montanonic> Though, I probably shouldn't use the word "standard".
14:07:00 <phaazon> montanonic: de facto, then
14:07:07 <montanonic> ^
14:07:24 <kosmikus> Igloo: but you can e.g. do this: http://lpaste.net/141500
14:07:26 <Cale> phaazon: GHCJS isn't exactly a library, but I'd recommend it :)
14:07:35 <phaazon> Cale: isn’t that a compiler?
14:07:40 <Cale> yes
14:07:40 <montanonic> yes
14:07:49 <seanparsons> edwardk: This was a few weeks ago and I quickly fiddled with just dumb sorts of [1..<bignumber>], which is probably the worst it could be for discrimination.
14:07:49 <phaazon> great then
14:07:53 <phaazon> I’ll test it!
14:07:54 <phaazon> thanks
14:07:58 <montanonic> Purescript is an alternative if you want less code output.
14:07:59 <cmccann> as of last time I looked into it, haste produced the best results but didn't support everything, fay was simple to use/understand but only supported a small fragment of Haskell, GHCJS did everything but had some headaches associated with it and the output wasn't as good
14:08:04 <Cale> phaazon: It's really nice to be able to use most of the things on Hackage in your frontend.
14:08:11 <montanonic> But it is a different language. Very similar, but *different*.
14:08:11 <phaazon> montanonic: I don’t really give a heck about code output
14:08:14 <phaazon> I won’t read the JS
14:08:19 <montanonic> phaazon: yeah, GHCJS then :)
14:08:22 <phaazon> Cale: even FFI?
14:08:23 <phaazon> like
14:08:23 <cmccann> it's not about reading, it's about speed and size
14:08:25 <phaazon> my al library?
14:08:26 <phaazon> I guess not
14:08:35 <phaazon> or gl / luminance / lambdacube / whatever
14:08:50 <phaazon> cmccann: so does ghcjs generate slow code?
14:08:50 <montanonic> what cmccann said though, that's worth considering; I hear that GHCJS does just fine though?
14:08:51 <cmccann> phaazon: sure, you can use those. you just have to reimplement the C lib in JS yourself :P
14:08:57 <Cale> phaazon: Obviously you can't FFI to native code libraries
14:09:05 <edwardk> seanparsons: i should be able to speed up the core of the 'grouping' machinery some more. i haven't spent much time on sorting lately though
14:09:06 <Cale> phaazon: But you can FFI to Javascript libraries
14:09:08 <Igloo> kosmikus: Thanks! I'll take a look...right after I install a newer GHC that can understand it  :-)
14:09:09 <cmccann> GHCJS used to be terrible from what I understand and has improved dramatically
14:09:16 <phaazon> Cale: oh, that’s great
14:09:24 <montanonic> I've heard similarly cmccann .
14:09:24 <Cale> We're using GHCJS in production at Obsidian Systems.
14:09:30 <phaazon> ok, thanks you guys
14:09:34 <phaazon> I’ll try it out!
14:09:40 <montanonic> Cale: good to hear! 
14:09:43 <phaazon> Cale: what do you think of all those “modern” frameworks
14:09:49 <phaazon> like angular.js and so on and so forth?
14:09:57 <Cale> phaazon: I don't know much about them
14:10:19 <phaazon> Cale: I feel like an alien when I hear friends of mine venting and almost bragging about that
14:10:32 <Cale> Thankfully, using Reflex to write the frontend we've been working on means that I don't have to actually care much about external Javascript stuff.
14:10:33 <phaazon> “Yeah, I’m a full stack developer and I use backbone.js and angular.js »
14:10:45 <phaazon> Reflex
14:10:54 <phaazon> I’ve been told about that a few months ago
14:10:56 <Cale> Yeah, Reflex-dom, more specifically
14:11:03 <phaazon> isn’t that jle`’s FRP library?
14:11:14 <Cale> It's ryantrinkle's FRP library
14:11:26 <phaazon> oh I see :)
14:11:35 <phaazon> does it work outside of the Web world?
14:11:38 <Cale> yes
14:11:45 <phaazon> is it arrowized FRP?
14:11:48 <Cale> no
14:11:51 <phaazon> (based on Auto and so on)
14:11:52 <phaazon> ok
14:12:04 <phaazon> I’ll check it out then
14:12:18 <phaazon> I’d like to find a correct – read as simple and elegant – implementation of FRP
14:12:24 <phaazon> which I’ve been failing to spot out
14:12:45 <phaazon> conal’s paper and theory are great, but implementation are utterly hard to understand
14:12:56 <monochrom> "I am a full stack developer. I use stack."
14:13:03 <phaazon> monochrom: <3
14:13:07 <phaazon> nice one
14:13:15 <phaazon> I’ll tweet that right away :D
14:13:20 <monochrom> hehe
14:13:21 <Cale> It's not a simple implementation, but from a user's perspective, it's reasonably conceptually simple. I think there's still a fair amount of polishing which can be done.
14:13:28 <nolrai666> I am not sure such a thing exists phaazon.
14:13:29 <Cale> But it's pretty nice to use already.
14:13:39 <phaazon> nolrai666: that’s why I stay away from the FRP world
14:13:41 <kosmikus> Igloo: what ghc version do you have?
14:13:43 <phaazon> it’s been around for what
14:13:44 <phaazon> 20 years?
14:13:47 <ReinH> denotational FRP is a simple concept with a hairy implementation :)
14:13:53 <phaazon> and it’s still not mature enough for serious uses
14:14:00 <Cale> I disagree.
14:14:06 <ReinH> Cale: about which?
14:14:07 <Igloo> kosmikus: 7.6.3 (Debian stable)
14:14:08 <Cale> We're putting it to serious use.
14:14:18 <Cale> and it's working quite nicely
14:14:21 <Igloo> kosmikus: But if I'm fiddling with type functions I should probably be using the latest anyway
14:14:25 <ReinH> Cale: do you use a library?
14:14:29 <phaazon> ReinH: Reflex
14:14:32 <Cale> Reflex / Reflex-dom
14:14:37 <ReinH> Cale: word
14:14:59 <ReinH> I should give it a try
14:15:13 <ReinH> I just need to find an FRP-shaped hole to put it in
14:15:39 <phaazon> I stay away from FRP frameworks because I find those very complex for such a simple aim
14:16:06 <Cale> One thing which is really cool about using FRP for Web-related stuff is that there are a lot of "callbacky" things which you can turn into not-callbacky things
14:16:15 <bitemyapp> monochrom: you use Stack now?
14:16:19 <bitemyapp> monochrom: I thought you used Platform fsr.
14:16:35 <Cale> i.e. they can become functions of type  Event t Request -> m (Event t Response)
14:16:35 <phaazon> is there anyone left using Haskell Platform?!
14:16:46 <ReinH> I'
14:16:50 <ReinH> I'm sure some people do
14:17:36 <monochrom> no, I don't use stack.
14:18:06 <monochrom> I still use haskell platform
14:18:25 <kosmikus> Igloo: this one should work with 7.6.3: http://lpaste.net/141502
14:19:19 <Cale> I use neither stack nor Haskell Platform
14:19:30 <bitemyapp> Cale: you have no use for a corporeal form either
14:19:41 <bitemyapp> Cale: you exist in the universe of mathematical forms
14:19:50 <Cale> heh
14:20:07 <bitemyapp> I'll take a "heh"
14:20:09 <ReinH> Cale writes platonic ideal haskell code
14:21:14 <KaneTW> who manages lambdabot again
14:21:28 <simon> bitemyapp, I'm sure Cale exists in the real world... in WHNF.
14:21:38 <arkeet> KaneTW: int-e 
14:21:42 <bitemyapp> simon: lmao
14:22:23 <ReinH> simon: unsure, I have never been able to scrutinize him
14:22:53 <simon> ReinH, well, if you do, I'm sure he'll unthunk!
14:23:10 <KaneTW> you just need to remember to force his spine
14:23:29 <ReinH> haskell jokes everyone
14:24:50 <gfixler1> Back from lunch. Did I miss any Haskell jokes while out?
14:25:12 <bitemyapp> gfixler1: yes
14:25:15 <Fuuzetsu> yes, you blink and you miss them all
14:25:30 <gfixler1> :(
14:25:32 <Fuuzetsu> you will most likely have to wait 10 more minutes for another
14:25:36 * dmj` mumbles something about burritos
14:26:25 <gfixler1> Can I force a new one with !?
14:27:10 <mniip> no it will be the old one still
14:27:30 <simon> did you hear the one about the Haskell programmer who doesn't hit on people in bars? they're not his type!
14:27:46 <monochrom> heh
14:28:10 <lpaste_> cmccann pasted “No title” at http://lpaste.net/141505
14:28:16 <tommd> Also, that might have a side-effect.
14:28:24 <cmccann> Igloo: ^ there's another way to do it btw
14:29:24 <cmccann> Igloo: same basic idea as what kosmikus did, just a bit more compact and the constraints on the constructors are more self-descriptive
14:29:36 <Igloo> cmccann: Thanks!
14:29:50 * Igloo has 7.10 now, and is experimenting
14:30:17 <cmccann> Igloo: also True ~ False is horrible as a "fail" constraint, do we have an official type-level "error" yet?
14:30:26 <mniip> cmccann, it's not an error
14:30:33 <mniip> it's a "no" constraint
14:30:41 <cmccann> yeah
14:30:52 <cmccann> either way I dunno what the best or recommended way to do that is
14:30:56 <mniip> an error would be something like an undecidableinstances loop
14:31:16 <cmccann> I guess the nice thing these days would be an unsatisfiable constraint on a Symbol with the error messaeg
14:31:32 <quchen> Oh hey Igloo, long time no see! I thought you left the Haskell world.
14:33:28 <mniip> no one leaves the haskell world
14:33:40 <mniip> they can only be unexported
14:34:01 <Igloo> Hey quchen  :-)
14:34:23 <quchen> Igloo: Are you still working with Haskell, or did nostalgia get to you? :-)
14:35:00 <kosmikus> cmccann: just let it get stuck. that's still a better error message.
14:35:03 <shachaf> whoa, Higloo
14:35:09 <shachaf> seen any good trains lately?
14:35:25 <Igloo> kosmikus, cmccann: Ah, I see, the type system knows what's going on and won't let you write the missing clauses, it's just the warning that doesn't realise that. Shame  :-(
14:35:42 <kosmikus> cmccann: or alternatively, define an open type family Error with no instances, until the proper one gets implemented
14:35:58 <shachaf> cmccann: That reminds me that I wanted to be able to write a value :: True ~ False => Void
14:35:59 <kosmikus> Igloo: yes, right. the warning is bogus.
14:37:07 <shachaf> I wrote in an email that it prevents this transformation:
14:37:12 <shachaf> data Foo a = a ~ Char => A | a ~ Bool => B -- valid
14:37:20 <shachaf> newtype Bar a = Bar { runBar :: forall r. (a ~ Char => r) -> (a ~ Bool => r) -> r } -- unusable
14:37:53 <shachaf> By "it" I mean GHC.
14:38:08 <cmccann> kosmikus: yeah, that's what I remember doing a couple years back when I was playing with type-level trickery, wasn't sure if there was something nicer now
14:38:12 <shachaf> Or GHC's restriction on values :: (Char ~ Bool => Void) (even undefined).
14:38:55 <cmccann> after all, so many of the ridiculous shenanigans that used to let you accomplish things back then are obsolete due to GHC supporting stuff directly, heh
14:38:56 <Igloo> quchen: I only do Haskell in my (vanishingly small) free time at the moment, I'm afraid
14:39:05 <kosmikus> cmccann: I think type-level error is in progress
14:39:19 <kosmikus> cmccann: but no, not yet there
14:39:31 <cmccann> kosmikus: I remember seeing a ticket about it I think, but don't remember when
14:39:43 <kosmikus> yes, the ticket exists for quite some time
14:39:47 <mniip> cmccann, I still remember implementing division for binary type-level numbers using MPTC
14:39:55 <cmccann> mniip: ahahaha
14:39:58 <cmccann> oh! that reminds me
14:40:10 <cmccann> shachaf: guess what, that silly kind error still isn't fixed
14:40:31 <cmccann> shachaf: https://ghc.haskell.org/trac/ghc/ticket/10114 remember that
14:41:24 <shachaf> whoa whoa whoa, we talked about that on IRC.
14:41:29 <cmccann> yeah
14:41:42 <cmccann> spent like an hour tinkering with smaller examples in #haskell-lens I think
14:41:46 <cmccann> good times
14:41:53 <shachaf> "this elaborated T simply doesn't have a sensible kind"
14:44:31 <cmccann> shachaf: the only disappointing thing is that you didn't somehow use that bug to implement unsafeCoerce
14:44:37 <cmccann> I seem to recall that was your hobby for a while
14:45:25 <shachaf> The kind of bug where GHC doesn't print an error when it should works better for that.
14:45:36 <shachaf> That was the kind of bug where it prints an error when it shouldn't.
14:45:43 <cmccann> meh, details
14:46:39 <shachaf> cmccann: Anyway I shared that hobby with oerjan.
14:46:46 <mniip> wait
14:46:49 <cmccann> it's an exciting hobby.
14:46:53 <mniip> is that T basically
14:47:22 <mniip> type family UnsafeCoerce
14:47:24 <mniip> :D
14:47:27 <shachaf> cmccann: You should read all the IRC logs from when we were figuring out the bug ramifications of #10000. It was great.
14:47:37 <cmccann> mniip: I don't think that T is basically anything. it's more complicatedly something.
14:47:37 <shachaf> s/bug //
14:48:43 <shachaf> Oh, GHC even has this classification.
14:48:57 <shachaf> "GHC rejects valid program" vs. "GHC accepts invalid program"
14:49:06 <shachaf> boring bugs vs. fun bugs
14:49:13 <mniip> so wait, once we get infinite taxonomy
14:49:26 <mniip> what will foralls look like?
14:49:29 <shachaf> fun bugs vs. funpuns
14:49:44 <mniip> forall (a :: k) (k :: kk) (kk :: kkk) (kkk :: kkkk) ...
14:49:54 <arkeet> shaohtf?
14:49:55 <cmccann> shachaf: unsafeCoerce is kind of like making a really terrible pun, I suppose.
14:50:49 <mniip> cmccann, unsafeCoerce is kind of *
14:52:13 <cmccann> mniip: ಠ_ಠ
14:53:12 <mniip> hey that's my line
15:16:12 <quchen-mobile> iirc a failable pattern is irrefutable or refutable only by bottom. Is that correct? 
15:17:08 <quchen-mobile> What's an example of such a pattern then? ()? Data Id a = Id a? 
15:25:23 * hackagebot luminance-samples 0.1.1 - Luminance samples  https://hackage.haskell.org/package/luminance-samples-0.1.1 (DimitriSabadie)
15:27:48 <quchen-mobile> Eh, i meant unfailable above. 
15:32:57 <stoopkid> i'm having a bit of trouble getting going with NICTA
15:34:29 <stoopkid> i try to compile the Course.List but it tells me it can't find Course.Optional, but i have Course.Optional here
15:35:20 <glguy> Are you doing that from the directory that contains the Course directory?
15:35:59 <stoopkid> hrm i had everything in the same directory
15:37:58 <dolio> quchen-mobile: (x, y)
15:40:24 * hackagebot wai-middleware-content-type 0.0.0 - Route to different middlewares based on the incoming Accept header.  https://hackage.haskell.org/package/wai-middleware-content-type-0.0.0 (athanclark)
15:41:51 <quchen-mobile> dolio: so all single-constructor *data* types? 
15:42:00 <dolio> Yes.
15:42:03 <quchen-mobile> Any others? 
15:43:40 <glguy> newtype data constructors would be fine, and make sure you consider the patterns recursively: ((),()) is OK
15:44:15 <jake_> I'm trying to write this, I think it should be possible but I'm not coming up w/ it, any ideas? forall a b c f. (Applicative f) => f (a -> c) -> (a -> b) -> f (b -> c)
15:45:03 <glguy> jake_: You can't do that
15:45:17 <jake_> really? It has to be a Monad?
15:45:27 <quchen-mobile> dolio: but newtype constructors are irrefutable, no? 
15:45:41 <dolio> Yes, but you have to be careful.
15:45:57 <dolio> NewtypeCon (Just x) is not an irrefutable pattern.
15:46:09 <johnw> jake_: that's not the problem
15:46:14 <dolio> (x, (y, z)) is unfailable
15:46:28 <dolio> (x, (~Nothing, w))
15:46:41 <quchen-mobile> dolio: sure, those properties are recursively defined. 
15:46:44 <dolio> !x is unfailable
15:47:00 <quchen-mobile> Ah, good point
15:47:03 <Fay> unfailable?
15:47:08 <johnw> jake_: you're returning a function that receives a 'b', but you need an 'a' to make a 'c'.  Where does the 'a' come from?
15:47:13 <shachaf> jake_: Doesn't have to be a Monad. Try f = Identity.
15:47:28 <jake_> uh, maybe I screwed up my type sig then
15:47:29 <dolio> `Nil :: Vec a 0` is unfailable
15:47:35 <quchen-mobile> ?quote dolio unfailable 
15:47:35 <lambdabot> dolio says: Unfailable is irrefutable or refutable only by bottom.
15:47:38 <quchen-mobile> Fay
15:48:05 <Fay> ahh ok thankyou quchen-mobile 
15:48:09 <jake_> yeah whoops: (Applicative f) => f (a -> c) -> (a -> b) -> f (a -> c)
15:48:50 <glguy> that one's easier: const
15:49:15 <jake_> haha
15:49:23 <jake_> okay I'm probably still wrong then
15:54:47 <EvanR> @djinn (Applicative f) => f (a -> c) -> (a -> b) -> f (a -> c)
15:54:47 <lambdabot> Error: Class not found: Applicative
15:58:29 <jake_> okay sorry for my confusion, I have a Monad impl of this now so I'm pretty sure the types are right, but I'm trying to reduce it to Applicative: (Applicative f) => f (a -> b) -> (b -> c) -> f (a -> c)
15:58:35 <bz> ls
16:00:40 <shachaf> :t \x f -> fmap (f .) x
16:00:41 <lambdabot> Functor f => f (a -> b) -> (b -> c) -> f (a -> c)
16:00:57 <jake_> awesome
16:19:01 <Shockk> hmm is there a standard function defined something like elemAt :: Int -> [a] -> Maybe a?
16:19:25 <FreeFull> I think so, let me check
16:19:31 <Welkin> :t elemIndex
16:19:33 <lambdabot> Eq a => a -> [a] -> Maybe Int
16:19:44 <Welkin> oh
16:19:51 <Welkin> I misread what you said
16:19:54 <Shockk> that's like the reverse I think, takes an elem and returns maybe the index
16:20:21 <FreeFull> Yeah, it is the reverse
16:20:35 <Shockk> I know there's (!!) :: [a] -> Int -> a
16:20:39 <Welkin> Shockk: if such a function exists, it would be in Data.List
16:20:46 <Welkin> yeah, !! is unsafe
16:20:49 <Shockk> although (!!) is- yep
16:20:52 <Welkin> classy-prelude has a safe !!
16:21:10 <Welkin> you can define (!!?) :: Int -> [a] -> Maybe a
16:21:23 <Welkin> or use classy-prelude
16:22:04 <FreeFull> Maybe there is one in the new Prelude
16:22:12 <EvanR> theres a package filled with a variety and "safe" versions of things
16:22:35 <EvanR> safe
16:22:40 <Welkin> oops
16:22:41 <Welkin> yeah
16:22:42 <Welkin> it is Safe
16:22:46 <Welkin> not classy-prelude
16:23:10 <EvanR> at :: [a] -> Int -> a
16:23:21 <EvanR> atMay :: [a] -> Int -> Maybe a
16:23:37 <Welkin> https://hackage.haskell.org/package/safe-0.3.9/docs/Safe.html
16:23:39 <EvanR> theres also atDef and atNote
16:26:01 <Shockk> hmm it should be pretty simple to define so I'll probably just do that rather than depend on an extra package
16:27:15 <Shockk> does this look right:
16:27:54 <Shockk> elemAt _ [] = Nothing  /  elemAt 0 (x:_) = Just x  /  elemAt i (_:xs) = elemAt (pred i) xs
16:27:55 <Shockk> ?
16:29:56 <EvanR> the code in safe is more extensive
16:30:24 <EvanR> but its doing more
16:30:37 <EvanR> Shockk: you will want to use a guard or two to catch negatives
16:30:47 <Shockk> oh right
16:31:27 <EvanR> safe puts a check for negatives around essentially what you wrote
16:31:58 <EvanR> instead of pred it does i-1
16:32:07 <Shockk> listElemAt i (_:xs) | i < 0 = Nothing | otherwise = listElemAt (pred i) xs
16:32:39 <EvanR> isnt that always nothing
16:33:02 <Shockk> only if i < 0?
16:33:11 <EvanR> or 0 or > 0
16:33:17 <Shockk> that's not the only pattern match
16:33:50 <Shockk> I've got before that: listElemAt 0 (x:_) = Just x
16:33:51 <EvanR> well i cant speak to the code not visible
16:33:55 <ttt_fff> happy shift/reduce
16:34:06 <ttt_fff> happy shift/reduce got a conflict ; how do I ask it to tell me what the conflict is?
16:34:28 <Shockk> it's easier if I just lpaste it
16:35:05 <lpaste> Shockk pasted “ListElemAt.hs” at http://lpaste.net/141516
16:35:23 <EvanR> http://lpaste.net/141517
16:35:38 <geekosaur> ttt_fff, -i?
16:35:41 <EvanR> i modified that from the safe code which is more like either
16:35:44 <geekosaur> with optional filename for the output
16:35:56 <ttt_fff>  happy -i X/Interp/Parser.y  shift/reduce conflicts:  1
16:36:06 <johnw> ttt_fff: https://www.haskell.org/happy/doc/html/sec-conflict-tips.html
16:36:27 <geekosaur> also note that shift-reduce conflicts are not necessarily errors
16:36:43 <EvanR> Shockk: hmm yours in inside out, continually doing a check for negatives at each step
16:37:02 <Shockk> EvanR: ohh I see
16:37:41 <geekosaur> ttt_fff, then look for a file Parser.info
16:37:48 <geekosaur> which should have been geenrated
16:37:52 <ttt_fff> geekosaur: yeah, found it :-)
16:38:26 <ttt_fff> geekosaur: https://gist.github.com/anonymous/874ce9e3f97b986f9a73 <-- where is the actual conflict ?
16:38:34 <ttt_fff> it says there's a conflict but I don't see where it tells me where the conflict is
16:38:40 <geekosaur> you can often refactor a grammar to remove shift/reduce conflicts, but often it's easier to just keep it
16:39:29 <geekosaur> state 39, I think
16:39:47 <geekosaur> it shows the shift that it is doing and in parentheses the reduce it could also have done
16:42:31 <ttt_fff> geekosaur: okay
16:42:42 <ttt_fff> geekosaur: do you think it'd be a good idea for me to just study the Hskell happy/alex files
16:42:46 <ttt_fff> since I'm parsing a haskell like language
16:43:20 <geekosaur> hm. not sure I'd suggest that because the happy grammar ghc uses is pretty gnarly
16:43:35 <geekosaur> in order to cope with possible extensions and such
16:49:13 <geekosaur> you should also note the advice on the conflict resolution page johnw pointed to; while you can remove the conflict, it's often better to accept it --- a shift/reduce conflict will be resolved in favor of the shift, which is almost always what you want, and dicing the grammar more finely to avoid the conflict has costs
16:49:45 <EvanR> im not sure i understand fully the difference between mtl and transformers can anyone summarize
16:49:58 <geekosaur> (in particular I've always found a grammar that accepts such conflicts easier to comprehend than one that resolves them. this is a case of make the computer do the work, not the human reading the code)
16:50:02 <shachaf> I,I What about a shift/reset conflict?
16:50:09 <ttt_fff> geekosaur: yeah, but I don't like warnings
16:50:17 <athan> ttt_fff: Use parser combinators to generate token streams! :x
16:50:27 * hackagebot directory 1.2.4.0 - Platform-agnostic library for filesystem operations  https://hackage.haskell.org/package/directory-1.2.4.0 (Rufflewind)
16:50:44 <geekosaur> EvanR, very roughly, transformers is mechanism but not implementation. mtl, built on top of transformers, adds implementations
16:51:25 <EvanR> ok... but i couldnt find any implementation of Writer in mtl
16:51:36 <Shockk> muhaahahahaha (evil laughter as I drown in my own Haskell code):  show $ PM.relationAt 0 (PM.singleton ("one", 1 :: Integer))
16:51:42 <geekosaur> the implementation of multiparameter typeclasses used in monad transformers could be in terms of functional dependencies, or it could be in terms of associated types
16:51:43 <Shockk> outputs Just ("one" :<->: (1 :<->: UnitRelation))
16:51:56 <Shockk> PM.relationAt 1 outputs Nothing for that singleton
16:52:28 <geekosaur> there were trial implementations of both (monads-fd and monads-tf); the current mtl version 2 is essentially monads-fd using the mtl version 1 names
16:52:44 <geekosaur> Writer is a type alias
16:52:47 <nolrai666> What advice did johnw point to?
16:52:52 <geekosaur> as are Reader and State
16:52:53 <EvanR> or WriterT
16:52:57 <johnw> happy docs on conflict resolution
16:53:09 <EvanR> it must be in transformers, so its just confusing which exists for what why
16:53:11 <geekosaur> [22 23:35] <johnw> ttt_fff: https://www.haskell.org/happy/doc/html/sec-conflict-tips.html
16:53:24 <johnw> there's a lot written on doing the same for yacc grammars, too
16:53:28 <ttt_fff> geekosaur, johnw: yeah, aware of that link
16:53:38 <ttt_fff> I'm rethinking my parsec -> alex + happy
16:53:49 <geekosaur> sorry ttt_fff I reposted that for nolrai666 
16:53:50 <ttt_fff> and might move to parsec -> alex + parsec
16:54:08 <EvanR> whats the point of alex is that chain?
16:54:15 * Clint squints.
16:54:50 <EvanR> (parsec -> alex + parsec) -> parsec
16:55:26 <ttt_fff> alex for lexing
16:55:32 <ttt_fff> and so I can do layout parsing
16:55:54 <EvanR> but you can lex with parsec too
16:56:04 <ttt_fff> yeah, but then I need two stage parsec
16:56:20 <EvanR> you already have 2/3 stages anyway
16:56:34 <geekosaur> EvanR, http://lambda.haskell.org/platform/doc/current/packages/transformers-0.3.0.0/doc/html/Control-Monad-Trans-Writer-Lazy.html#t:Writer
16:57:24 <ttt_fff> EvanR: yeah, you're right, f*ck it, I should just have multiple Parsec layers
16:58:07 <EvanR> ok so mtl is specifically for implementing certain MPTCs, and for exporting stuff like Writer w = WriterT Identity w in a different location
16:59:01 <EvanR> well in the only, commonly known location
17:00:28 * hackagebot cabal-debian 4.31.6 - Create a Debianization for a Cabal package  https://hackage.haskell.org/package/cabal-debian-4.31.6 (DavidFox)
17:03:48 <geekosaur> yes, so that we could experiment with both forms of MPTC
17:05:06 <kristof> There are different kinds of multi parameter typeclasses?
17:05:11 <kristof> Or does this have to do with coherence
17:05:29 <geekosaur> well, multiple ways to deal with type inference involvoing them
17:05:43 <geekosaur> functional dependencies vs. type classes
17:06:04 <geekosaur> the transformers package originated along with implementations using both of those: the monads-fd and monads-tf packages
17:07:37 <geekosaur> without one of those, you would have to annotate every use of an MPTC with an explicit type
17:08:05 <kristof> Ah
17:08:14 <kristof> In Rust we've completely gone the way of type families
17:09:14 <EvanR> functional dependencies vs type families*
17:09:42 <geekosaur> it was determined that type families had problems (not specifically intrinsic to them, but IIRC related to Haskell requiring that all typeclass instances be globally visible)
17:10:27 <geekosaur> so monad transformers stuck with FDs and type families were taken in a different direction (closed type families)
17:11:28 <kristof> geekosaur: Can you summarize the problems related to global visibility? I'm not sure what Haskell's rules are with respect to Typeclasses, to be honest.
17:11:51 <geekosaur> not really, I remember the discussion but it was a bit above my pay grade
17:12:00 <kristof> Ah, ok
17:12:15 <Fay>  we get paid?!
17:12:21 <geekosaur> vague recollection that it turned out to be trivial to abuse typeclass visibility to derive unsafeCoerce, and that the type system mechanisms needed to close the loophole were really expensive
17:12:34 <kristof> I know for a fact that in Rust we borrowed Haskell's coherence and orphan rules exactly
17:12:51 <kristof> Either that, or we specifically wrote ours to combat the problems present in Haskell's. It's one of those two, I can't remember :)
17:13:10 * geekosaur tries to find discussion
17:13:23 <kristof> Thanks
17:17:14 <NateAGeek> Hello, I', new to haskell. I thought it would be a simple exercise to write a function and print out every element in an array recursively. http://pastebin.com/Bq64ed7Z I think it's a syntax issue. If someone could give me some feedback that would be great
17:18:25 <nolrai666> Well first that's a list not a array.
17:18:28 <Shockk> y: `lookup' is written and works :D
17:19:19 <geekosaur> kristof, fwiw I seem to have remembered correctly but forgotten that the original claim was actually debunked. https://mail.haskell.org/pipermail/haskell-cafe/2010-July/080043.html
17:19:43 <geekosaur> (that is, it was claimed that TF opened a hole. that message showed that FDs open the same hole...)
17:20:10 <NateAGeek> nolrai666: sorry, wrong wording
17:20:21 <kristof> NateAGeek:  You're recursing on i - 1
17:20:27 <kristof> but you're checking if it's less than the length
17:20:32 <geekosaur> kristof, also https://mail.haskell.org/pipermail/haskell-prime/2011-June/003423.html re FDs vs TFs in ghc
17:20:49 <kristof> second, you can't write that print right before recursing. you need a do in there
17:21:50 <nolrai666> NateAGeek: or a >> instead of the new line.
17:22:08 <kristof> NateAGeek: so choose either to start at 0 and go until the length, or start from the length and go until it's 0
17:22:16 <NateAGeek> kristof: yeah, that logic was off, haha. So, do are blocks right
17:22:41 <NateAGeek> syntax wise, allowing me to have multiple lines
17:22:45 <kristof> NateAGeek: Not quite. do is for sequencing of monadic computations
17:23:05 <kristof> NateAGeek: You should read Learn You a Haskell :)
17:23:31 <kristof> NateAGeek: Haskell has a relatively high barrier to entry. You can't just pick up some pieces and expect them to work because there are some fundamental concepts required even to write a simple main function
17:23:50 <NateAGeek> kristof: That's what I'm reading right now. lol. I'm just getting a little exited, and tried to write some code.
17:24:44 <NateAGeek> kristof: I've been coding for a bit now; so, this is not my first language. However, I think that's why I'm impatient
17:25:06 <kristof> NateAGeek: Right, I don't think you're a novice programmer
17:26:02 <kristof> NateAGeek: I've got a friend who's a professional C# programmer and he's recently picked up haskell. Slow progress! But he's getting the ideas
17:26:22 <nolrai666> And yeah, the lie to children is do blocks is how to write blocks.
17:26:28 <NateAGeek> kristof: is there any big difference with ">>" and "do"?
17:26:39 <kristof> NateAGeek: do will often desugar into calls to >> and >>=
17:27:11 <kristof> NateAGeek: Let me show you a better way to write the program you wrote just for a reference
17:27:31 <NateAGeek> kristof: That would be awesome!
17:31:34 <NateAGeek> kristof: http://pastebin.com/g74ZRktm
17:31:42 <NateAGeek> that is what I ended up making
17:34:21 <kristof> NateAGeek: http://lpaste.net/141522
17:34:24 <kristof> 4 different ways to do it
17:35:03 <kristof> NateAGeek: lists in haskell are not arraylists like in Java and C# or vectors in C++. They are linked lists. There is an array datatype sitting around somewhere in the stanard library.
17:35:26 <geekosaur> Vector is probably better than Array fwiw
17:35:55 <kristof> Sorry, that's what I meant by "array" datatype. Not a naked array :P
17:36:25 <NateAGeek> kristof: Nice to know, Thank you for the code!
17:38:24 <NateAGeek> kristof: kinda curious of printArray2. Does the rest just contain a pointer to the head address of the list. Or does it create a new list?
17:41:17 <indiagreen> NateAGeek: a pointer
17:41:44 <NateAGeek> indiagreen: Thanks, that's what I thought. But just making sure.
17:42:21 <indiagreen> NateAGeek: almost everything is a pointer by default, even Int (so [Int] is a list of pointers to integers)
17:42:41 <indiagreen> this lets us have very interesting things
17:43:16 <indiagreen> such as being able to write use infinite lists, such as “let ones = 1 : ones” or [1,2..]
17:43:47 <indiagreen> because pointers can point to “thunks” instead of just values (a thunk is an unfinished computation)
17:44:58 <indiagreen> don't worry, if you want speed it's possible to get rid of pointers in many places
17:45:31 <NateAGeek> indiagreen: Example? is it just casting it or something?
17:46:20 <NateAGeek> indiagreen: You got me interested in infinite lists. How the heck does the computer handle those?
17:46:30 <nolrai666> I still haven used Vector yet.
17:46:39 <NateAGeek> Because, mines, is really starting to slow down now
17:46:47 <indiagreen> an example: “Vector” is a type for int-indexed arrays. If you import “Data.Vector”, your vectors would be storing pointers. If you import “Data.Vector.Unboxed”, your vectors would be storing honest-to-goodness values
17:47:27 <indiagreen> however, if you're a Haskell beginner, in the vast majority of cases your performance problems will come from elsewhere, so don't worry about it now
17:48:55 <indiagreen> to understand infinite lists, imagine a type “Box a” that can hold either an actual “a” or a pointer to a computation that produces an “a”. When a value in the box is needed, it's evaluated and stored automatically
17:49:22 <indiagreen> let's say you have a definition: “ints = [1..]”
17:49:36 <indiagreen> when you just have it lying around, it's stored as “[1..]”
17:49:49 <indiagreen> then you print first 10 values: “print (take 10 ints)”
17:50:35 <NateAGeek> indiagreen: so infinite lists are just computed as they go
17:50:42 <indiagreen> after this the ints “variable” will be updated behind the scenes to something like “1:2:3:4:5:6:7:8:9:10:Box [11..]”
17:50:51 <NateAGeek> indiagreen: makes sense
17:51:30 <NateAGeek> indiagreen: thanks for that insight!
17:52:06 <Welkin> is there a way to explicitly export an import without having to explicitly export everything else from a module?
17:52:29 <arkeet> what do you mean
17:52:32 <Welkin> I want everythin defined in the module to be exported by defauly (without an explicit export list) but there is also an import I want to export too
17:52:42 <arkeet> oh
17:53:43 <indiagreen> I think you can't but <usual disclaimer about never being 100% sure about the /impossibility/ of things>
17:54:00 <EvanR> module Foo ( module Bar, Baz ) where import Bar \n data Baz ?
17:54:26 <indiagreen> EvanR: no, you're exporting Baz explicitly
17:54:29 <geekosaur> can't you just name module YourModule in the export list?
17:55:03 <arkeet> I believe so
17:55:13 <geekosaur> module Foo (module Foo, Baz) where import Bar (Baz) ...
17:55:18 <arkeet> ^
17:55:31 <arkeet> https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1000005.2
17:55:35 <arkeet> A module can name its own local definitions in its export list using its own name in the “module M” syntax,
17:55:38 <arkeet> etc
17:55:43 <indiagreen> whoa
17:55:55 <indiagreen> good that I added the disclaimer, then
17:56:52 <Welkin> wow
17:56:53 <Welkin> thanks arkeet 
17:59:17 <Gurkenglas> What's the default location ghc-mod is usually installed to? Would anything break if I just put a ghc-mod executable there? SublimeHaskell doesn't seem to find it when I tell it to look in the sandbox I installed it in.
18:00:14 <geekosaur> afaik anywhere in $PATH
18:00:37 <geekosaur> ...note that $PATH may be different for something launched from a GUI than for something launched from a terminal
18:00:49 <MarcelineVQ> it installs to .cabal/bin for me
18:00:56 <MarcelineVQ> I had to add that to my path
18:10:31 * hackagebot clckwrks-plugin-ircbot 0.6.15 - ircbot plugin for clckwrks  https://hackage.haskell.org/package/clckwrks-plugin-ircbot-0.6.15 (JeremyShaw)
18:10:33 * hackagebot clckwrks-plugin-page 0.4.1 - support for CMS/Blogging in clckwrks  https://hackage.haskell.org/package/clckwrks-plugin-page-0.4.1 (JeremyShaw)
18:15:31 * hackagebot clckwrks-plugin-media 0.6.14 - media plugin for clckwrks  https://hackage.haskell.org/package/clckwrks-plugin-media-0.6.14 (JeremyShaw)
18:17:14 <Shockk> :k '[String]
18:17:15 <lambdabot> [*]
18:17:30 <Shockk> :k '[(String, Int)]
18:17:31 <lambdabot> [*]
18:23:52 <nshepperd> :k '[ '(String, Int) ]
18:23:53 <lambdabot> [(,) * *]
18:23:58 <athan> :k (:) :: [k]
18:23:59 <lambdabot> parse error on input ‘:’
18:24:02 <athan> merrrr
18:24:09 <athan> :k (':) :: [k]
18:24:10 <lambdabot> parse error on input ‘:’
18:24:15 <nshepperd> intriguing
18:24:53 <athan> a... type-le :)
18:25:12 <nshepperd> :k '(:)
18:25:13 <lambdabot> k -> [k] -> [k]
18:25:33 <athan> o_o
18:25:36 <athan> thanks nshepperd
18:26:32 <Shockk> lol
18:26:35 <Shockk> :k BOX
18:26:36 <lambdabot> Not in scope: type constructor or class ‘BOX’
18:26:42 <Shockk> hmm what is BOX anyway?
18:27:17 <Shockk> :k [*]
18:27:19 <lambdabot> parse error on input ‘*’
18:28:25 <Shockk> oh wait, apparently BOX is a "sort"
18:28:41 <nshepperd> the type of kinds
18:32:49 <Gurkenglas> "use $ players . singular (filtered $ (==myName) . playerName)" What did I do wrong here?
18:38:52 <Gurkenglas> Ah, playerName was also lensified so now I have to use _playerName there, that reduced the errors of that line from 3 to 1. Is there a flowchart about which compile errors are likely to mean which things with the lens package? It says I've got an Optic' (->) [...] instead of a Traversing (->) [...]
18:42:13 <Gurkenglas> Why isn't lens in the Haskell Platform?
18:50:39 <birmjin> @help
18:50:39 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:51:16 <Gurkenglas> Use "/query lambdabot" for that. Someone put that into the @help answer.
18:51:35 <birmjin> @help list
18:51:35 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
18:54:06 <edwardk> Gurkenglas: because it'd bring with it an _awful_ lot of stuff
18:54:18 <edwardk> it is, however, in stackage
18:54:37 <edwardk> which given the prevalence of stack lts these days is morally about the same =)
18:54:40 <MarcelineVQ> I've heard it said in here some people consider it un-idiomatic haskell as well, but I've no idea about that
18:54:54 <edwardk> MarcelineVQ: =P
18:56:17 <Shockk> :k (->)
18:56:18 <lambdabot> * -> * -> *
18:58:42 <Shockk> is there a function that goes from [(a,b)] to ([a],[b]) ?
18:59:19 <MarcelineVQ> unzip
18:59:36 <Shockk> :t unzip
18:59:37 <lambdabot> [(a, b)] -> ([a], [b])
18:59:52 * AfC waves
18:59:55 <Shockk> ahh right the name didn't make sense for a moment
19:00:05 <MarcelineVQ> :t zip
19:00:06 <lambdabot> [a] -> [b] -> [(a, b)]
19:00:14 * Shockk nods
19:01:13 <Shockk> I want to write some type family or something that goes from [(*, *)] to ([*], [*]) and needed a good name for it
19:01:17 <Shockk> Unzip works
19:01:49 <Gurkenglas> Is there a version of the hierarchy diagram at the top of https://hackage.haskell.org/package/lens that includes stuff like Optic' and Traversing?
19:04:01 <Shockk> wait let me check that that's possible 
19:04:29 <Shockk> :k '([Int], [String])
19:04:30 <lambdabot> (,) * *
19:04:49 <Shockk> it's a weird way to write it but great
19:10:43 <athan> Shockk: I bet you `Unzip` is defined in singletons!
19:11:02 <Shockk> is singletons a package?
19:11:11 <athan> Shockk: With tons of Prelude goodies :)
19:11:13 <lightandlight> Anyone familiar with this pen and paper game? https://en.wikipedia.org/wiki/Dots_and_Boxes
19:11:46 <athan> Shockk: http://www.cis.upenn.edu/~eir/packages/singletons/README.html
19:12:21 <lightandlight> I'm trying to reason how to only represent valid states using the type system
19:13:09 <Shockk> athan: interesting
19:13:45 <athan> lightandlight: The issue with type-level safety with graph-related structures is their inductive definition isn't obvious (if it exists)
19:14:26 <athan> lightandlight: my `dag` library, for instance, is just a list of edges. But - on each `Cons` cell of the list, I check to make sure the added edge doesn't induce cycles
19:14:40 <athan> there's a much better way to do this - topological sort, but I liked the challenge :)
19:15:11 <lightandlight> athan: I wasn't really thinking about using a graph representation, just an array of "cells"
19:15:18 <athan> Shockk: Are you familiar with /closed/ type families? :)
19:15:33 <athan> lightandlight: Just some inspiration :P
19:15:37 <Shockk> hmm, I'm not sure
19:15:45 <athan> er, experience report
19:15:58 <athan> Shockk: They're different from open type families
19:16:16 <athan> basically, open type families are like a typeclass - anyone in another package could make definitions / instances
19:16:17 <Shockk> the type families I've got right now are written using `where' and then a couple of clauses
19:16:27 <athan> Shockk: That's a closed type family then
19:16:35 <Shockk> ahhh
19:16:39 <athan> where the type level pattern-matching is private
19:16:46 <Shockk> is it possible to write a closed *data* family?
19:16:59 <athan> You can get overlaps which are a pain to debug, though - that's why I'm asking
19:17:06 <athan> Shockk: Welcome to GADTs :P
19:17:07 <Shockk> I tried `where' with my data family but it's a syntax error
19:17:16 <athan> Oh man you're going to have a kick
19:17:23 <athan> check this out:
19:17:26 <athan> @hackage dag
19:17:26 <lambdabot> http://hackage.haskell.org/package/dag
19:17:30 <athan> er, the code
19:17:37 <athan> (warning, it's putridly code-rotten)
19:19:03 <Shockk> my head 
19:19:04 <Shockk> :(
19:20:38 <lightandlight> I was thinking something like this- Cell = Owned Char | Empty [Edge]
19:21:23 <lightandlight> But is there a way that you can enforce that length [Edge] <= 3 and has no duplicates?
19:21:26 <athan> lightandlight: Where the edges are...?
19:21:35 <athan> lightandlight: Welcome to dependent types :P
19:21:38 <lightandlight> The filled in edges
19:21:44 <athan> ahh okay
19:21:50 <athan> that's good!
19:22:12 <athan> You might even say that `data EdgeSet = EdgeSet {topEdge :: Edge, leftEdge :: Edge, ...}
19:22:25 <athan> Shockk: Where are you confuse?
19:22:38 <athan> lightandlight: That way you can make sure you only have 4 edges
19:22:41 <Shockk> oh I'm just pretty sleepy right now so is hard for me to understand stuff
19:22:53 <athan> acutally, you rather would have `EdgeSet {topEdge :: Maybe Edge, ...}`, right?
19:22:56 <lightandlight> athan: 
19:22:58 <athan> Shockk: oh :P
19:23:24 <lightandlight> athan: Yep
19:24:22 <athan> lightandlight: That way, you can also forget the need for global coordinates for your Edge type :) it could just be `data Edge = Filled | NotFilled`
19:26:03 <lightandlight> athan: Yeah, although I'm mainly wondering how (if possible) we represent "any 3 edges filled" as valid, but "4 edges filled" as invalid
19:27:23 <athan> lightandlight: Without (pre-) dependent types, that would be hard :\
19:27:45 <athan> but, you can always represent something like that as a runtime expression `isValid :: EdgeSet -> Bool`
19:28:32 <lightandlight> Oh of course, I've already written this
19:28:50 <athan> lightandlight: Oh okay, I didn't know your skill level
19:29:08 <athan> lightandlight: Have you gotten into dependent types or GADTs etc. yet?
19:29:22 <lightandlight> Not at all
19:29:48 <athan> lightandlight: You will be amazed. Just read Idris's manual :)
19:30:12 <lightandlight> I want to use haskell for this though :P
19:30:37 <athan> lightandlight: We'll have dependent types by January. Make haste!!
19:30:52 <athan> Plus, we have GADTs, which is probably all you need for this case
19:31:13 <hodapp> by January?!
19:31:41 <athan> hodapp: I thought that's when 8.0.0.0.0. ++ fix (++.0) ++ .1 was supposed to deploy
19:31:48 <athan> GHC 8.*
19:32:46 <hodapp> athan: but is that gonna bring dependent types?
19:33:16 <athan> Nevermind!
19:33:37 <athan> hodapp: My mistake, i guess only phase 1 :\
19:33:47 <Shockk> is there any way for me to have a kind variable in some form or another, in a kind signature?
19:33:55 <Shockk> for example
19:33:56 <Shockk> type family TypeMap (f :: * -> *) (as :: [*]) :: [*]
19:34:12 <c_wraith> You mean something with a polymorphic kind?
19:34:36 <c_wraith> Or you just mean specifying kinds?
19:34:43 <c_wraith> Looks like the latter.  -XKindSignatures
19:34:44 <Shockk> like, I can't give something of kind ((*, *) -> *) to that first parameter
19:35:01 <c_wraith> Oh.  That's because (*,*) isn't normally a kind
19:35:07 <athan> Shockk: Totally, check out -XPolyKinds
19:35:09 <c_wraith> Unless you've used -XDataKinds
19:35:14 <athan> :k '[] -- for instance
19:35:15 <lambdabot> [k]
19:35:22 <athan> polymorphic in kind `k`
19:35:22 <Shockk> ooh
19:35:25 <c_wraith> Oh, you really do mean PolyKinds
19:35:38 <Shockk> like the kind signature I was thinking of was something like
19:36:05 <Shockk> type family TypeMap (f :: k0 -> k1) (as :: [k0]) :: [k1]
19:36:15 <c_wraith> Yeah, that works.
19:36:18 <Shockk> would PolyKinds let me do that?
19:36:20 <c_wraith> yep
19:36:26 <Shockk> ooh great thanks
19:36:35 <athan> Are there type-level functors? :|
19:36:43 <Shockk> I love all these extensions
19:36:57 <Shockk> using like 10 or so in this file
19:37:03 <Shockk> 11 now
19:37:30 <athan> I think that's the first time I've heard someone enjoy them o_o
19:38:44 <Shockk> athan: lol
19:39:19 <Shockk> it lets me do (TypeMap Fst as) where as :: [(*, *)]
19:39:27 <c_wraith> What?  I love PolyKinds and DataKinds.
19:39:41 <athan> c_wraith: I'm talking about the language extension header :P
19:39:50 <c_wraith> Well that's a different story.
19:40:19 <c_wraith> I wonder if Dependent Haskell will happen as semi-scheduled.
19:40:20 <athan> Shockk: Be careful! You /may/ run into ambiguity... table smashing o_o
19:40:40 <athan> c_wraith: 
19:40:42 <athan> I hope so
19:41:05 <c_wraith> That's the problem with the project being one guy's...  PhD Thesis?
19:41:42 <c_wraith> Is it his PhD thesis?  All I know is he's been behind a bunch of interesting type system work already.
19:42:01 <athan> I'm not sure, I really want to see what he does to change SystemFC_pro though
19:43:46 <lpaste> Shockk pasted “PolyMap.hs” at http://lpaste.net/141529
19:43:53 <Shockk> hm I'm getting an error
19:43:59 <Shockk>  Type family `Fst' should have 3 arguments, but has been given 2
19:44:04 <Shockk> when checking singleton'
19:45:48 <lightandlight> What if we did "Cell = Owned Char | ThreeSides Edge Edge Edge | TwoSides Edge Edge | OneSide Edge | Empty"
19:46:18 <lightandlight> That removes the possibility of having four sides set but no owner, but it still doesn't enforce uniqueness on each edge
19:46:18 <glguy> Shockk: You shouldn't be able to apply the TypeMap type family to the Fst type family
19:47:12 <chromatome> Anyone know of a function like isInfixOf but that doesn't require the "intact" part?
19:47:12 <Shockk> glguy: I'm trying to apply Fst to TypeMap though
19:47:25 <glguy> "f x" means "apply f to x"
19:47:33 <Shockk> oh
19:47:45 <chromatome> e.g. Trying to find whether the word "cat" could be made using the characters in "watches"
19:48:07 <Shockk> why shouldn't it be possible?
19:49:08 <glguy> Shockk: type families are like type synonyms, yoiu have to fully apply them
19:49:46 <Shockk> oh, so I can't do partially like that, like I would with a function to the `map' function?
19:50:00 <stoopkid> hi, i'm following NICTA, and i'm doing Courses.List and doing the 'length' exercise to implement a function that gives length of a list
19:50:30 <stoopkid> i have the following:
19:50:48 <stoopkid> length :: List a -> Int
19:50:53 <Shockk> that's disappointing, do you know of a similar way to do what I'm trying to do there?
19:50:59 <stoopkid> length Nil = 0
19:51:29 <stoopkid> length (h :. t) = 1 + (length t)
19:51:50 <stoopkid> it works but i was wondering how i might implement this using a fold
19:52:04 <dibblego> stoopkid: when the course is run, we often give that solution first, then factor into a solution using foldLeft
19:52:09 <geekosaur> Shockk, ghc really does not like type lambdas (partially applied things at the type level)
19:52:25 <Shockk> :(
19:52:30 <dibblego> stoopkid: this is how foldLeft and foldRight work: http://functionaltalks.org/2013/06/19/tony-morris-explain-list-folds-to-yourself/
19:52:51 <lpaste> glguy annotated “PolyMap.hs” with “PolyMap.hs (annotation)” at http://lpaste.net/141529#a141532
19:52:57 <glguy> Shockk: You can do stuff like this:
19:53:00 <stoopkid> alrighty then, i'll check that out and see what i can come up with, thank you :)
19:54:05 <dibblego> stoopkid: in short, the expression (foldLeft f z list) does the following pseudocode: { var r = z; foreach(el in list) { r = f(r, el); } return r; }
19:54:26 <dibblego> stoopkid: so, given that loop, and you can replace (f) and (z) with whatever you like, what to replace them with so that the list's length is computed?
19:54:33 <dibblego> apply the same reasoning to sum and product from earlioer
19:54:36 <Shockk> hmm I see
19:55:10 <glguy> You're working against the system (basically) so it's not going to be clean
19:55:34 <Shockk> out of interest, is there work planned in that area in GHC?
19:56:25 <geekosaur> not sure "planned" is the right word
19:56:37 <dolio> If you used a language with type lambdas, you wouldn't like them either. :)
19:56:45 <geekosaur> there is intention to expose anything you can do in ghc core, including type lambdas
19:56:53 <geekosaur> there are no concrete plans that I am aware of
19:57:20 <Shockk> ah right
19:59:31 <stoopkid> dibblego: ok i made a function addOne :: a -> Int -> Int
19:59:36 <stoopkid> addOne _ x = x + 1
19:59:42 <geekosaur> (but that's about all I can say about it, from reading various discussions; that I have heard and seen that core does not have types, yet somehow it has type lambdas... I am clearly missing something)
19:59:45 <stoopkid> and then i change my length function to:
20:00:00 <geekosaur> (I've seen the type lambdas too, occasionally)
20:00:09 <dibblego> stoopkid: yep that will work
20:00:09 <stoopkid> length a = foldLeft addOne 0 a
20:00:12 <dolio> Wait, what? Core has types.
20:00:30 <geekosaur> it does? I think the only time I have seen types is as type dictionaries?
20:00:30 <roconnor> dolio: turns out it catches errors
20:00:46 <geekosaur> thought types were erased by then, except when expressed as type dictionaries
20:01:00 <roconnor> in theory Core doesn't need types, but in practice ...
20:02:19 <dolio> Like, polymorphic functions actually take type arguments in Core.
20:02:42 <geekosaur> actually I think I have seen types expressed as what look like annotations at top level, come to think of it
20:03:23 <roconnor> Such is system F
20:03:37 <dolio> If you're talking about STG, apparently types are much less important there, although they still exist.
20:05:47 <Shockk> I wrote a family MapFst which does what Fst did instead of taking an (f :: k1 -> k2)
20:10:31 <Shockk> :k ':
20:10:32 <lambdabot> parse error on input ‘:’
20:10:36 <Shockk> :k (':)
20:10:37 <lambdabot> parse error on input ‘:’
20:10:42 <Shockk> bah
20:10:55 <Shockk> is it '(:)  ?
20:11:02 <Shockk> :k '(:)
20:11:03 <lambdabot> k -> [k] -> [k]
20:16:26 <Shockk> I keep typing (a, b) instead of '(a, b)
20:16:46 <Shockk> and here I am wondering why it errors
20:41:55 <wavewave> success in making android sample app in haskell with ghc and nix.
20:42:26 <wavewave> http://github.com/wavewave/haskell-android-example   http://github.com/wavewave/nix-build-ghc-android 
21:20:13 <dmj`> jle`: ping
21:20:33 <Shockk> :k []
21:20:35 <lambdabot> * -> *
21:21:59 <Shockk> geekosaur or glguy : can I also not give [] in a place that takes a (* -> *)?
21:22:50 <Shockk> the kind of the parameter to my PolyMap is now [(*, * -> *)]
21:23:25 <Shockk> if I try typing something as PolyMap '[ '(String, []) ] though
21:23:38 <Shockk>   '(String, []) is applied to too many type arguments
21:25:33 <Shockk> :k '[]
21:25:34 <lambdabot> [k]
21:25:38 <Shockk> oops
21:26:39 <breadmonster> :k []
21:26:43 <lambdabot> * -> *
21:27:33 <Shockk> oh
21:27:42 <Shockk> somehow I lost a comma somewhere
21:27:51 <Shockk> totally my fault
21:28:37 <glassresistor> i was on here a while back and someone turned me onto type of formal logic that doens't have official axioms and instead is a map of espressions that lead to each other
21:28:48 <dmj`> Is there any kind of Monoid that mappend's based on equality
21:29:11 <dmj`> like (1,"a") `mappend` (1, "b") == (1,"ab")
21:29:15 <ttt_fff> in "f a" what is the operator precendence of " " , i.e. the level of precence of "apply this arg to this function"
21:29:31 <glassresistor> i was talking about the difference between math/logic and a program is that programs can execute and then they said check out "X kind of logic" it is executable
21:29:48 <Shockk> ttt_fff: 10, iirc
21:30:47 <Shockk> ttt_fff: application has a higher precedence than any infix operator (infix precedence can be from 0 to 9)
21:31:10 <Shockk> so f x {any operator} g x
21:31:19 <Shockk> will always parse as (f x) {operator} (g x)
21:31:28 <ttt_fff> Shockk: noted, thanks
21:32:08 <dmj`> Or is there a way to combine hash maps so [(1,"a")] `combine` [(1, "b")] == [(1, "ab")]
21:32:26 <dmj`> it seems simple...
21:32:26 <glguy> Is there a "unionWith" operation?
21:33:18 <dmj`> glguy: that seems promising
21:33:53 <dmj`> glguy: thanks, "If a key occurs in both maps, the provided function (first argument) will be used to compute the result."
21:38:10 <glassresistor> oh i figured it out its Intuitionistic logic
21:40:55 <athan> glassresistor: Dig into Martin-Löf :)
21:41:04 <athan> glassresistor: https://en.wikipedia.org/wiki/Intuitionistic_type_theory
21:46:03 <hardmath123> Hi #haskell; quick question: is there any way to make an infixl operator that has higher precedence than "space" function application?
21:46:13 <Stratege> no
21:46:21 <hardmath123> I'd like to be able to write `a @@ b c` to mean `(a @@ b) c`
21:46:35 * Shockk quotes something he said 15m ago
21:46:37 <Shockk> Shockk | ttt_fff: application has a higher precedence than any infix operator (infix precedence can be from 0 to 9)     
21:47:06 <bananagram> that's not possible
21:47:20 <Shockk> it's weird when similar questions come up one right after another
21:47:45 <hardmath123> Sorry. I was reading the docs, and it said "space-application" was 10.
21:47:56 <hardmath123> I was wondering more about whether there was any hack that could make that work anyway?
21:48:19 <hardmath123> In Scheme, for example, you could write a macro to make it work out.
21:49:38 <Stratege> I guess maybe with template haskell since to my understanding that's something macro-ish. Though you can't really without it.
21:49:53 <hardmath123> Ah, okay.
21:50:06 <hardmath123> The context for this is that I'm trying to write a haskell equivalent of Scheme's `cut`.
21:50:36 <Stratege> the haskell way of doing "a @@ b c" would be to just admit defeat and write "a @@ b $ c"
21:50:43 <mniip> or just
21:50:47 <mniip> at a b c
21:50:47 <hardmath123> so (f a b <#> c d) would be equal to (\x -> f a b x c d)
21:51:19 <hardmath123> it works for bi-adic functions, but not vari-adic functions without lots of $'s
21:51:38 <mniip> hardmath123, what would the type of that function be
21:51:57 <hardmath123> mniip: I think  (x -> y -> z) -> y -> (x -> z)
21:52:35 <mniip> :t id :: (x -> y -> z) -> y -> (x -> z)
21:52:37 <lambdabot>     Couldn't match type ‘x1’ with ‘y1’
21:52:37 <lambdabot>       ‘x1’ is a rigid type variable bound by
21:52:37 <lambdabot>            an expression type signature: (x1 -> y1 -> z1) -> y1 -> x1 -> z1
21:52:44 <mniip> oh err
21:52:53 <mniip> :t flip :: (x -> y -> z) -> y -> (x -> z)
21:52:54 <lambdabot> (x -> y -> z) -> y -> x -> z
21:53:06 <Stratege> ^ was about to say
21:54:18 <hardmath123> Sure, yeah, I saw flip, but that only works on bi-adic functions. I think you'd need multiple `flip` operations to make it work for variadic functions.
21:54:27 <hardmath123> to "float" the argument to the end
21:54:32 <Sgeo> Does Haskell rhyme with Pascal?
21:54:40 <codebje> I have getSomeRecord :: Word16 -> Word16 -> Word32 -> Get Record; I was hoping to use it as "do ... record <- getSomeRecord <$> getWord16be <*> getWord16be <*> getWord32be ..."
21:54:43 <Ralith> that's what, like three characters shorter than just writing the lambda?
21:54:48 <mniip> hardmath123, and what would the type of /that/ be
21:54:49 <codebje> but that gives me a type of Get (Get Record)
21:54:57 <codebje> is there something straightforward I'm missing
21:54:58 <codebje> ?
21:55:02 <Sgeo> I've been told by another Haskell-ish friend of mine that I've been pronouncing 'Haskell' wrong
21:55:24 <codebje> sgeo, given I've heard Pascal as PAScal and pasCAL, I don't think I can help you there at all :-)
21:55:28 <Stratege> hardmath123 I'm not 100% sure, but I think haskell doesn't have variadic functions, atleast not without some advanced trickery.
21:55:34 <hardmath123> Ralith: but I find it prettier to read! it's like pattern-matching syntax.
21:56:06 <hardmath123> Stratege: uh, poly-adic? >2-adic? that's what I meant, anyhow, variadic was the wrong word
21:56:08 <Shockk> I pronounce Haskell as HASkell 
21:56:15 <jle`> Sgeo: usually people pronounce it as *has*kle
21:56:31 <codebje> as in, "ruby really gets my haskles up" ?
21:56:36 <Sgeo> jle`, that's how my friend pronounces it
21:56:37 <mniip> Stratege, haskell does have variadic functions
21:56:45 <mniip> but, it's complicated
21:56:49 <stoopkid> it's a guy's name it should probably be pronounced like he pronounced it XD
21:56:50 <Sgeo> I've been pronouncing it "Has-*kell*"
21:56:54 <jle`> i think its namesake pronounces it the same way
21:56:55 <hardmath123> mniip: shouldn't it be the same? if you theoretically had a super-high-precedence infix operator.
21:57:01 <Sgeo> Or.. I'm not sure
21:57:02 <Stratege> mniip without having to resort to the stuff that quickcheck does?
21:57:06 <Sgeo> Now I can barely remember
21:57:09 <flippant> Sgeo: like pascal?
21:57:13 <jle`> https://en.wikipedia.org/wiki/Haskell_Curry
21:57:17 <flippant> except paskel
21:57:20 <jle`> if only i knew how to read those pronunciation symbols
21:57:33 <jle`> such cryptic
21:57:37 <Sgeo> Which is probably why half the people I try telling about Haskell think I'm talking about Pascal
21:57:42 <stoopkid> jle`: practically a prog-lang of its own haha
21:57:46 <codebje> the ipa: confusing the issue 1888
21:58:44 <Sgeo> Apparently I also mispronounce other English words.
21:58:54 <jle`> language is a living thing anyways
21:59:02 <mniip> jle`, "haskell", with a like in "cat", and e like in "bird"
21:59:04 <mniip> apparently
21:59:28 <jle`> it looks like everyone in that half of the century was trying to find foundations for mathematics
21:59:38 <jle`> like it was some huge mega-fad in math
21:59:39 <stoopkid> mniip: that is how that human name is pronounced, yes
22:00:02 * stoopkid knows somebody named haskell in real life, and that's how they pronounce it
22:00:37 <jle`> how did you meet them when you never leave your stoop?
22:01:00 <stoopkid> jle`: ah, i got over my fear at the end of that episode, remember?
22:01:20 <stoopkid> life's been great since
22:01:34 <jle`> ah yes, but i'm always skeptical of things i see on tv
22:02:44 <stoopkid> i'm getting a bit confused implementing the 'map' function from NICTA's Course.List
22:03:12 <stoopkid> and, i'm not sure if that's because i'm not thinking hard enough (/too hard) or because i should be doing another tutorial first
22:03:45 <Stratege> well what exactly has you confused?
22:03:48 <dibblego> stoopkid: start by pattern-matching the list
22:03:57 <dibblego> stoopkid: a List is made of either Nil or (:.)
22:04:08 <dibblego> stoopkid: for the Nil case, there is only one possible type-checking answer, so just give that one
22:04:12 <stoopkid> dibblego: you mean don't try to fold my first go-around?
22:04:30 <dibblego> you might try to foldRight, but if that is difficult, use pattern-matching first
22:04:36 <dibblego> foldRight does constructor replacement
22:05:00 <dibblego> in the list (a :. b:. c :. Nil), then for (map f), you want to replace (:.) with ((:.) . f) and Nil with Nil
22:05:01 <stoopkid> i see, thanks, yea i was telling myself i had to use fold
22:05:36 <dibblego> so to have (f a :. f b :. f c :. Nil)
22:06:08 <stoopkid> hmm ok, lemme see if i can make this work
22:06:26 <dibblego> or, just pattern-match
22:06:29 <jle`> once you implement it using pattern matching, you can compare it to the implementation/definition of foldRight, and you'll start to see the similarities if you stare long enough :)
22:06:36 <jle`> but write the pattern match implementation first
22:07:06 <codebje> down the ipa rat hole, Haskell is HASkel, Blaise Pascal is pah-SCAL
22:08:03 <codebje> well, french has no word stress, so pah-scal, I guess.
22:08:09 <stoopkid> codebje: yea i had always mispronounced pascal, the same way as haskell is actually pronounced
22:08:20 <stoopkid> then i heard people say it on youtube
22:11:20 <stoopkid> hm
22:12:01 <stoopkid> map f Nil = Nil
22:12:13 <stoopkid> map f (h :. t) = (f h :. map f t)
22:12:29 <stoopkid> this works, but... it's maybe working *too* well
22:12:57 <stoopkid> well
22:13:17 <jle`> it sort of makes sense if you say it out loud in english
22:13:20 <stoopkid> i guess it's not the map that's working 'too' well it's (+ 5) and (5 +)
22:13:27 <jle`> "mapping f over an empty list is just the empty list"
22:13:34 <stoopkid> sure
22:13:46 <stoopkid> what i'm confused about here is:
22:14:01 <jle`> "the head of mapping f over a list is f applied to the head of the original list.  the tail of the mapped list is f mapped over the tail of the original list"
22:14:15 <nitrix> Hi, I have an interesting problem that is probably due to a misconception about the language.
22:14:16 <stoopkid> map (+ 5) (1 :. 2 :. Nil) and map (5 + ) (1 :. 2 :. Nil)
22:14:42 <jle`> stoopkid: probably because (+ 5) is the same as (5 +) for most Num instances
22:14:54 <jle`> (+ 5) is \x -> x + 5, and (5 +) is \x -> 5 + x
22:15:10 <nitrix> I'm trying to `show` a value of type :: (Num a, Random a) => a
22:15:43 <nitrix> The compiler complains because the type is ambiguous. I can make it explicitly an Int, but I was wondering what's going on. Isn't it supposed to commit to a type?
22:16:02 <Shockk> nitrix: the type also has to constrained by Show a
22:16:09 <jle`> it doesn't know what type to pick
22:16:11 <jle`> there are multiple options
22:16:37 <nitrix> jle`: Aren't all these options covered by Show anyway?
22:16:41 <jle`> hindley milner always picks the most general type possible (in GHC there are some limited defaulting rules for specific occasions, but those are built-in to the compiler for convenience)
22:16:48 <nitrix> Oh wait, it isn't.
22:17:39 <Shockk> nitrix: not all instances of Num are necessarily also instances of Show; same thing for instances of Random
22:17:58 <jle`> if your value is of type (Num a, Random a) => a, then there are several types it can be instantiated as
22:18:08 <jle`> even if it's (Show a, Num a, Random a) => a, there are several candidates
22:18:14 <nitrix> Shockk: I think that's where I made the wrong assumption.
22:18:29 <jle`> it can be Int...Integer...Float...Double...
22:18:54 <nitrix> jle`: Those all have show instances though.
22:19:04 <jle`> yeah, but GHC needs to know which one you want to Show
22:19:21 <kristof> type hints!
22:19:31 <kristof> oh, I actually came across something odd the other day
22:19:43 <jle`> and, practically, which instance of Show to use
22:19:49 <kristof> fun :: a -> f a
22:19:49 <nitrix> > randomRIO (10000, 99999) :: IO Float
22:19:51 <lambdabot>  <IO Float>
22:20:12 <kristof> I want to give this function a type hint at the usage spot
22:20:16 <jle`> remember that Int, Integer, Float, Double all have different Show instances, so if your value is (Num a, Rnadom a) => a, which instance is it going to use?
22:20:25 <nitrix> > f <- randomRIO (10000, 99999) :: IO Float
22:20:27 <lambdabot>  <no location info>:
22:20:27 <lambdabot>      not an expression: ‘f <- randomRIO (10000, 99999) :: IO Float’
22:20:33 <jle`> you have to instantiate it as a specific type so it knows how to show it
22:20:34 <nitrix> lambdabot: >:(
22:20:41 <Shockk> lambdabot doesn't do IO
22:20:47 <nitrix> Oh I see.
22:20:57 <kristof> Well it doesn't matter, actually.
22:21:14 <nitrix> Right, I think I just assumed randomRIO would give me an IO Int, but it doesn't.
22:21:24 <nitrix> Sorry about that.
22:21:32 <jle`> no need to be sorry :P
22:21:32 <liste> would it be possible to make lambdabot do fake I/O like TryHaskell ?
22:21:46 <Shockk> > putStrLn "test"
22:21:48 <lambdabot>  <IO ()>
22:21:48 <jle`> yes it would
22:21:51 <Shockk> hmm
22:22:03 <jle`> Shockk: it evaluates the value
22:22:12 <jle`> at least, enough to Show it
22:22:14 <jle`> > [1..]
22:22:15 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
22:22:17 <Shockk> oh
22:22:38 <jle`> it gives IO () a `Show` instance, so it evaluates it enough to be able to use `show` on it
22:22:52 <jle`> just like...any other normal haskell value
22:23:08 <Shockk> > unsafePerformIO (putStrLn "hello")
22:23:09 <lambdabot>  Not in scope: ‘unsafePerformIO’
22:23:12 <kristof> > "test"
22:23:13 <lambdabot>  "test"
22:23:17 <kristof> Works fine over here
22:37:23 <adas> can someone please tell me what is the end goal for having extensions like datakinds, typefamiles, derivegeneric? I am trying to understand what do they help us to accomplish collectively? 
22:37:49 <jle`> write more type safe code
22:38:11 <jle`> be able to state more in our types
22:38:40 <jle`> so the compiler can know enough to disallow bad implementations
22:38:58 <jle`> i wouldn't really lump DeriveGeneric into that group, though
22:39:13 <johnw> adas: the more expressive a type is, the more it can says about the values that inhabit it; this means we can constrain our programs to... disallow bad implementations, haha, exactly what jle` just typed :)
22:39:44 <adas> jle`: so you mean like, trying to make our types more restrictive so that it is impossible to write bad programs and get aways with it?
22:40:07 <jle`> for example, instead of putting in your documentation: "this Int -> [Double] will only return lists of 0 or 1 values"
22:40:12 <jle`> we could instead wrote Int -> Maybe Double
22:40:14 <adas> oh okay i see johnw and jle` said same thing
22:40:28 <johnw> adas: it's possible, in a dependently typed language, to make the type of "sort" such that the only possible thing any implementation of the type can do, is exactly what you would expect
22:40:40 <Gurkenglas> What's the least-defined left inverse of (:[])? Something like headNote, but also crashing on 2+ elements
22:42:01 <Gurkenglas> Ooh, actually "the right inverse of (:[])" is a more elegant specification
22:42:13 <jle`> adas: this goal is sort of a deeply rooted "goal" and philosophy of Haskell...datakinds, type families, etc. let us take it further to levels that normal haskell don't let us
22:42:33 <jle`> s/don't/doesn't
22:42:38 <jle`> or s/haskell/haskells i guess
22:43:19 <adas> johnw: jle` if dependent typing solves all these problems why can't we simply have {-# LANGUAGE DependentTyping #-} instead of 5 other extensions?
22:43:39 <johnw> adas: next time you see Richard Eisenburg at any conference, ask him that :)
22:43:40 <jle`> DeriveGeneric is not really as lofty a thing...it's just kind of a shortcut way to write a normal instance for a typeclass that's useful
22:43:44 <johnw> Eisenberg
22:44:03 <johnw> adas: fully dependent types have a cost too
22:44:12 <johnw> adas: it's not simply "moar better"
22:44:41 <johnw> Haskell types have a fluidity and ease of expression that you come to miss if you program in Agda for a while
22:44:54 <johnw> you don't always *need* to constrain everything so much
22:45:16 <johnw> sometimes, you want just enough sloppiness that you can leave it to the type checker to infer what you meant
22:45:33 <jle`> haskell ends up being a pragmatic sweet spot between safety and unsafety...which is a bit ironic to say if you consider how much safer haskell is than other languages
22:46:03 <cocreature> jle`: probably most people would say the same thing about the languages they like :)
22:46:08 <Stratege> jle` hey if I slap enough unsafePerformIO into my code I can get the unsafety of Scala.
22:46:32 <cocreature> Stratege: don't forget to put some unsafeCoerce in there too
22:46:55 <jle`> cocreature: heh.  i actually don't know any many people who think that agda is more pragmatic than haskell.  but i think some people can argue about idris
22:47:24 <cocreature> jle`: I was more talking about java, scala, python, …
22:47:25 <Stratege> cocreature or reallyUnsafePointerEquality? :D
22:47:33 <jle`> ah i see
22:47:56 <cocreature> Stratege: I still smile everytime I see that function :)
22:48:02 <adas> so what are those extneions that help us to restrict the inhavitants in our types? DataKinds is one. TypeFamilies is another. GADTs is another. am i missing antyhing else?
22:48:17 <Stratege> cocreature you know what the equivalent of that is called in C? :D
22:48:29 <johnw> adas: PolyKinds
22:48:36 <cocreature> Stratege: =  ?
22:48:42 <Stratege> cocreature close, ==
22:48:50 <cocreature> eh yeah it's too early here
22:48:53 <Stratege> :D
22:48:59 <johnw> adas: KindSignatures
22:49:48 <adas> and if the purpose of all those extensions is simply to reduce the inhabitants in our types, why do we have so many different extensions? can't we just have one? like {-# InhabitantRestrictor #}. i know i sound childish. sorry. but I just wish there were less extensions to learn about.
22:50:16 <johnw> adas: this was mentioned at the Haskell Implementors Workshop
22:50:20 <johnw> it may happen some day
22:50:23 <cocreature> adas: well then learning that one extension would require learning the same thing as learning all those small extensions
22:50:40 <jle`> yea,h it's not like the actual amount you have to learn goes down at all, heh
22:50:57 <adas> cocreature: atleast there's peace is knowing that I'm learning one thing to accomplish one thing. not learning 5 things to accomplish one thing
22:50:59 <jle`> you have to learn the same net amount of things overall.  unless you count "names of extensions" as a thing
22:51:13 <jle`> i think each one really works well on their own, though
22:51:18 <johnw> adas: you can list all the extensions in your .cabal file too, instead of in every file
22:51:29 <Stratege> cosndiering the amount of extensions that GHC has, maybe being able to group them by name and just having to enable that one new name for the group might be useful though.
22:51:32 <jle`> i wouldn't say they're all just to "reduce inhabitants", i would say that it's to let you be more expressive with what you state in your types
22:51:50 <jle`> and each one gives you a way to express a new thing in its own way/approach
22:51:50 <johnw> Stratege: I've always wanted an "EverythingThat'sConsistent"
22:52:21 <quchen2> Let's name that extension glasgow-exts!
22:52:23 <Stratege> johnw yeah, stuff like that would be neat
22:52:32 <stoopkid> ok so, for this map i have to sequence my operations of applying the function, and then appending this to my list
22:52:40 <Shockk> {-# LANGUAGE GlasgowExtsMinusTH #-}
22:52:44 <johnw> Stratege: or even just a web page that show every consistent grouping
22:53:06 <johnw> i.e., if I have extension, A B C and D, is it safe to include E in that set?
22:53:12 <Shockk> actually the MinusTH could be inferred with {-# LANGUAGE Safe #-}
22:53:31 <johnw> quchen2: lol
22:53:56 <Stratege> johnw if I knew more about Haskell extensions, I'd actually do that, but I don't :/
22:54:15 <johnw> I usually avoid IncoherentInstances.  Sounds very incoherent.
22:54:16 <kristof> Can anyone tell me about the problems type families and functional depedencies have?
22:54:27 <jle`> but still, grouping them together isn't going to reduce the amount of things you have to learn by any meaningful amount
22:54:33 <jle`> you still have to learn the same amount of things
22:54:36 <kristof> And why there are two things that exist to solve the same problem
22:54:50 * quchen2 considers compiling his own compiler with MultiWayCaseBangs enabled by default
22:54:52 <jle`> now you'd just have to learn them *all at once*, instead of one at a time, as you need them
22:54:56 <quchen2> … on a regular basis
22:55:00 <Stratege> jle` sure but it gives you a sense of which ones you usually require together (and thus need to learn together) to be useful
22:55:10 <johnw> kristof: I think it's a bit inconvenient to say this with type families: class Foo a b | a -> b, b -> a where
22:55:10 <jle`> i don't always require them all together, though
22:55:27 <jle`> sometimes i only use KindSignatures...or sometimes I only use GADTs, or sometimes i only use DataKinds
22:55:32 <kristof> johnw: :O So a and b uniquely determine each other?
22:55:32 <jle`> or PolyKinds
22:55:39 <kristof> How does that even work?
22:55:52 <jle`> it's nice to be able to learn them all at once and begin integrating them into my haskell programing one at a time, bit by bit
22:55:53 <johnw> kristof: a and b together must be a unique pairing
22:55:56 <jle`> instead of jumping into everything all at once
22:56:04 <johnw> no a with another b, no b with another a
22:56:16 <jle`> the idea of learning every dependent-typing-related-thing in Haskell sounds pretty daunting to me...
22:56:34 <jle`> (all at once, from scratch)
22:56:40 <adas> why are all these extensions only ever extensions. some of these extensions have been around for a long time. why are they enabled only when we use these special pragmas?
22:56:46 <kristof> johnw: Ah, okay. But how is that different from having an associated type b?
22:56:51 <jle`> adas: technically they aren't Haskell, they are GHC
22:56:56 <johnw> jle`: better yet, learn Agda where all those features are the same level of difficulty as ordinary types and functions, and then translate back to Haskell
22:57:01 <kristof> johnw: Oh, because b can appeaar as Foo b _
22:57:15 <jle`> johnw: maybe i should have done that :)
22:57:41 <adas> you mean every extension is not in the haskell standard? it's only in GHC?
22:57:41 <Stratege> jle` true, yeah. One of them on its own is already enough material to learn at once.
22:57:46 <adas> the compiler i mean
22:57:56 <jle`> and one on its own is already enough to benefit your haskell programming, in a lot of cases
22:58:19 <jle`> but arguments-based-on-pedagogy are shaky at best, admittedly :)
22:58:21 <kristof> johnw: yeah, I can think of ways to express what you're talking about, but they're all strictly worse than fundeps.
22:58:23 <hodapp> johnw: translate *back* to Haskell? how possible is that?
22:58:27 <Stratege> adas jup, thus why they are extensions. Next Haskell standard is going to include a few more as a normal part of haskell though, iirc.
22:58:39 <adas> Stratege: next haskell standard?
22:58:49 <johnw> kristof: fundeps have a convenience factor that's very hard to ignore
22:58:58 <jle`> adas: yeah, the extensions are features that aren't a part of Haskell
22:59:02 <jle`> they are just GHC features
22:59:06 <jle`> that GHC adds on top of Haskell
22:59:16 <hodapp> sometimes more than just GHC
22:59:20 <hodapp> but not part of the standard
22:59:22 <johnw> hodapp: for example, GADTs make perfect sense going from Agda -> Haskell.  I don't mean actual translation; just translating your understanding
22:59:33 <adas> jle`: and I always thought the reason why they were extensions is because they are experimental and not mature
22:59:43 <Stratege> adas mhm, not entirely sure for when that one's planned, but just as is typical for languages, you get a new standard once in a while. There's Haskell98 and Haskell 2010 so far (atleast, if I don't entirely missremember things)
22:59:54 <jle`> yeah, there are a bunch of extensions that are clearly mature and make perfect sense, like TupleSections
23:00:09 <jle`> they're just not a part of Haskell.  so it's kind of weird to just integrate them into your compiler and say "this is Haskell".  when it's not Haskell
23:00:36 <Xe> OverloadedStrings is so convenient
23:00:40 <adas> so am i correct in assuming that all the extensions are very mature and stable to use, but they exist as extensions only because they are not part of the haskell standard?
23:00:51 <jle`> a lot of extensions are universally considered bad
23:00:53 <jle`> heh
23:01:08 <jle`> but i think they're still there for compatibility reasons or something
23:01:12 <CindyLinz> universally...
23:01:15 <srhb> adas: Some are very mature and stable, all are extensions because they are not part of the standard.
23:01:17 <Stratege> IncoherentInstances comes to mind for "bad"
23:01:20 <Xe> jle`: name one?
23:01:27 <jle`> ImpredicativeTypes
23:01:29 <quchen2> safe, useful, no-risk extensions: LambdaCase, MultiWayIf, BangPatterns, NumDecimals, BinaryLiterals, for example. Not sure if good idea for the standard: IncoherentInstances, the type family zoo.
23:02:10 <jle`> ImpredicativeTypes is just plain broken, from what I hear
23:02:38 <quchen2> n+k isn't broken but doesn't really help much and it's an awkward special case
23:02:39 <jle`> also DatatypeContexts offers no value whatsoever
23:03:01 <jle`> and using it is discouraged pretty heavily by anyone anywhere
23:03:22 <Gurkenglas> How do I make "GameState {}" not throw a warning?
23:03:23 <Stratege> what does DatatypeContexts do again?
23:03:31 <jle`> people look at it to solve a problem that they think they have, but it ends up not solving it, and they end up not even trying to solve the right problem
23:03:36 <quchen2> data Foo a = Bar a => XXX a
23:03:39 <quchen2> Stratege: ^
23:03:46 <quchen2> Not sure where the constraint goes
23:03:51 <Stratege> quchen2 ah, thanks.
23:03:53 <jle`> it goes before, i think
23:04:03 <Stratege> yeah I get the idea, LYAH mentions it I believe. And also how it's pointless.
23:04:10 <jle`> data Eq a => Blah a = BlahBlah
23:04:34 <adas> i was reading a stackoverflow answer and it said that there are "types" of values, "kinds" of types, "sorts" of kinds and nothing more than that in haskell. although agda has multiple universes to unlimited depth. what does it mean?
23:04:54 <adas> types and kinds i understand.
23:04:55 <quchen2> Is DataTypeContexts what gives rise to the "stupid theta" functions in GHC?
23:05:05 <adas> sorts.. never heard of that before
23:05:21 <Shockk> there's a proposal I read about earlier
23:05:35 <Shockk> to replace sorts with just kinds so that a kind is of a kind
23:06:15 <darkf> adas: AFAIK Haskell only has one sort (the sort of kinds). it means as it suggests: types may be abstracted by type constructors, type constructors may be abstracted by kinds, and kinds may be abstracted by sorts, and so on, infinitely.
23:06:32 <Shockk> the sort is BOX from what I've seen
23:07:27 <adas> ima read that stack anser again
23:07:46 <adas> https://stackoverflow.com/questions/20558648/what-is-the-datakinds-extension-of-haskell
23:08:05 <Shockk> DataKinds allows-
23:08:05 <Shockk> oh
23:08:17 <Stratege> Shockk infinite tower style or directly circular? (that is would the kind of kinds be of its own kind, or of a kind one higher similiar to agda?)
23:08:21 <darkf> "but Haskell lumps everything into one sort." yeah, the sort of kinds
23:08:33 <Shockk> Stratege: I have no idea
23:10:06 <Shockk> https://ghc.haskell.org/trac/ghc/wiki/GhcKinds
23:10:10 <Shockk> that's what I read
23:10:11 <Shockk> I think
23:11:02 <Stratege> thanks for the link
23:12:08 <Stratege> "The sort BOX should become a kind, whose kind is again BOX." directly circular.
23:12:16 <Shockk> ahhh
23:12:29 <darkf> how is this different from just having infinite universes (and why can't we do that?)
23:23:47 <Gurkenglas> How do I supress these warnings? http://lpaste.net/647171762424905728 I deliberately leave those undeclared so the user gets verbose errors when he doesn't use the stdin api to supply data in the following lines
23:26:12 <liste> Gurkenglas {-# OPTIONS_GHC -fno-warn-missing-fields #-} maybe, not sure
23:26:45 <glguy_> You fill the field in with explicit error uses
23:27:29 <Gurkenglas> But they would be basically the default ones
23:28:12 <Gurkenglas> It's like ''deriveErrors, only without me even having to say ''deriveErrors!
23:42:44 <ttt_fff> is there a way, in ahskell, to do `liftA2 :`, i.e.         a `liftA2 :` b    ==     liftA2 (:) a b
23:46:18 <Gurkenglas> :t let (+) = liftA2 (:) in ?a + ?b -- ttt_fff
23:46:19 <lambdabot> (Applicative f, ?a::f a, ?b::f [a]) => f [a]
23:46:20 <jle`> yeah, you can't put expressions inside backticks like that
23:46:35 <jle`> i think parsing would be too ambiguous
23:47:37 <opqdonut> ttt_fff: there are some nice hacks that enable things like that
23:47:47 <jle`> you can use `mod` anywhere you can use an operator, syntactically...so what about `liftA2 `mod`` ?
23:47:57 <opqdonut> ttt_fff: see e.g. https://wiki.haskell.org/Infix_expressions
23:48:48 <ww> of course... let modL = liftA2 mod
23:49:18 <ww> and a `modL` b
23:49:44 <ttt_fff> okay
23:49:49 <ttt_fff> I thikn the answer is "DON"T DO THAT"
23:49:52 <ttt_fff> and I accept that response
23:50:38 <opqdonut> ttt_fff: for applicative specifically, https://hackage.haskell.org/package/InfixApplicative-1.1/docs/Control-Applicative-Infix.html
23:56:21 <Xnuk> :t ?a
23:56:22 <lambdabot> (?a::t) => t
23:56:30 <Xnuk> :t (?)
23:56:31 <lambdabot> Not in scope: ‘?’
23:57:34 <liste> Xnuk that's implicit parameters
23:57:41 <liste> a GHC extensions
23:57:55 <liste> https://wiki.haskell.org/Implicit_parameters
23:58:49 <liste> haven't seem them used much, though
